post_cb({"40418962": {"ParentId": "40418833", "LastEditDate": "2016-11-04T09:54:02.527", "CommentCount": "6", "CreationDate": "2016-11-04T09:18:15.780", "OwnerUserId": "3852968", "LastEditorUserId": "3852968", "PostTypeId": "2", "Id": "40418962", "Score": "3", "Body": "<p>Short answer: <strong>no</strong>, thread ID does not necessarily increment with each new thread. Thread IDs can be reused.</p>\n<hr>\n<p>The standard says</p>\n<blockquote>\n<ol>\n<li><p id=\"so_40418833_40418962_0\">An object of type thread::id provides a unique identifier for each\n  thread of execution and a single distinct value for all thread objects\n  that do not represent a thread of execution (30.3.1). Each thread of\n  execution has an associated thread::id object that is not equal to the\n  thread::id object of any other thread of execution and that is not\n  equal to the thread::id object of any std::thread object that does not\n  represent threads of execution.</p></li>\n<li><p id=\"so_40418833_40418962_1\">thread::id shall be a trivially\n  copyable class (Clause 9). The library may reuse the value of a\n  thread::id of a terminated thread that can no longer be joined.</p></li>\n</ol>\n</blockquote>\n<p><em>-- <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">n4296</a>; 30.3.1.1 [thread.thread.id]</em></p>\n<p>It doesn't say that the ID is monotonically increasing, and it <strong>does</strong> permit thread IDs to be reused.</p>\n<p>It's likely that you want the <a href=\"http://en.cppreference.com/w/cpp/thread/thread/native_handle\" rel=\"nofollow noreferrer\"><code>native_handle</code></a>, which will be the handle that the underlying implementation uses. This will correspond to the Windows thread handle, under MSVC. Whether these are monotonically increasing is a matter for your implementation's documentation.</p>\n<p>The MSDN documentation for the <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms683183(v=vs.85).aspx\" rel=\"nofollow noreferrer\"><code>GetCurrentThreadId</code></a> function suggests that the thread ID uniquely identifies a thread until it terminates; it doesn't say whether the IDs are monotonically increasing, and the implication of that sentence appears to be that they may be reused.</p>\n<p>In summary, <em>the C++ standard provides no guarantee about the values of thread IDs</em>. If you want to guarantee this, you'll need to have each thread increment an atomic counter, or otherwise obtain a monotonically increasing value with appropriate synchronisation.</p>\n</hr>", "LastActivityDate": "2016-11-04T09:54:02.527"}, "40418833": {"CommentCount": "1", "ViewCount": "104", "CreationDate": "2016-11-04T09:10:33.150", "LastActivityDate": "2016-11-04T09:54:02.527", "Title": "Does this_thread::get_id() always increment with every new thread started", "AcceptedAnswerId": "40418962", "PostTypeId": "1", "Id": "40418833", "Score": "0", "Body": "<p>I can print thread ID to console following way:</p>\n<pre><code>cout &lt;&lt; \"thread ID: \"  &lt;&lt; std::this_thread::get_id() &lt;&lt; endl;\n</code></pre>\n<p>After this the IDs printed to console corresponds to IDs that can be found in Visual Studio 2013 Community under:</p>\n<pre><code>Debug -&gt; Windows -&gt; Threads -&gt; [ID column]\n</code></pre>\n<p>If I do ascending sort by this ID in <code>Debug -&gt; Windows -&gt; Threads</code> do I get the order in which threads started? Or In another words: does <code>std::this_thread::get_id()</code> always increment with every new thread started or it can also decrement?</p>\n", "Tags": "<c++><multithreading><visual-studio>", "OwnerUserId": "1616488", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_40418833_40418962_1": {"section_id": 2693, "quality": 0.9375, "length": 15}, "so_40418833_40418962_0": {"section_id": 2692, "quality": 0.975, "length": 39}}, "n3337": {"so_40418833_40418962_1": {"section_id": 2655, "quality": 0.9375, "length": 15}, "so_40418833_40418962_0": {"section_id": 2654, "quality": 0.975, "length": 39}}, "n4659": {"so_40418833_40418962_1": {"section_id": 3433, "quality": 0.9375, "length": 15}, "so_40418833_40418962_0": {"section_id": 3432, "quality": 0.95, "length": 38}}}, "40419313": {"ParentId": "40418833", "CommentCount": "0", "Body": "<p>The answer is <strong><em>probably</em></strong>.  For a particular implementation, it's a useful debugging heuristic (particularly if the thread handles are close).</p>\n<p>On the other hand, if you want to rely on it for program correctness then the standard clearly makes no such guarantee, and you will need to solve your underlying problem some other way.</p>\n", "OwnerUserId": "771073", "PostTypeId": "2", "Id": "40419313", "Score": "0", "CreationDate": "2016-11-04T09:37:13.630", "LastActivityDate": "2016-11-04T09:37:13.630"}});