post_cb({"7778698": {"CommentCount": "0", "ViewCount": "3340", "PostTypeId": "1", "LastEditorUserId": "635608", "CreationDate": "2011-10-15T15:20:25.710", "LastActivityDate": "2011-10-15T15:35:32.623", "Title": "Copy-constructor inheritance", "FavoriteCount": "0", "LastEditDate": "2011-10-15T15:23:17.813", "Id": "7778698", "Score": "5", "Body": "<pre><code>struct A{\n  virtual void what() { cout &lt;&lt; \"Base\" &lt;&lt; endl; };\n};\n\nstruct B : A {\n  virtual void what() { cout &lt;&lt; \"Sub\" &lt;&lt; endl; };\n  int m;\n  B() : m(10) {};\n  B(const A &amp; x) : m(50) {};\n};\n\nvoid main() {\n  B b1;\n  B b2 = b1;\n  cout &lt;&lt; \"Number:  \"\n       &lt;&lt; b2.m &lt;&lt; endl;\n};\n</code></pre>\n<p>Why isn't b2.m = 50? I'm trying to copy a b-object and i have the copy constructor B(const A &amp; x) : m(50). Do i need need to make a copy c'tor for the derived class ass well ? Like B(const B&amp;x) ??  I thought since a b-object has an a part, we could use B(const A &amp; x) : m(50) instead of the default constructor: :S</p>\n<p>In the case where you have a function with the parameter of an A object, you can send in a B object. How come it differs with the copy constructor?</p>\n", "Tags": "<c++><inheritance><copy-constructor>", "OwnerUserId": "951732", "AnswerCount": "3"}, "7778720": {"ParentId": "7778698", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The reason is that <code>B(const A&amp; x)</code> is not a copy-ctor \u2014 copy constructor for type <code>T</code> must always take an lvalue reference to <code>T</code> as the first (and have no other non-default arguments) argument. Your class has no defined copy-ctor, so the compiler generates the default one, which does a member-wise copy, hence why <code>b2.m</code> is the same as <code>b1.m</code>.</p>\n<blockquote>\n<p id=\"so_7778698_7778720_0\">A non-template constructor for class <code>X</code> is a copy constructor if its \ufb01rst parameter is of type <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>, and either there are no other parameters or else all other parameters have default arguments (8.3.6).</p>\n</blockquote>\n", "OwnerUserId": "16102", "LastEditorUserId": "16102", "LastEditDate": "2011-10-15T15:35:32.623", "Id": "7778720", "Score": "14", "CreationDate": "2011-10-15T15:24:38.007", "LastActivityDate": "2011-10-15T15:35:32.623"}, "7778722": {"ParentId": "7778698", "CommentCount": "0", "Body": "<p>Copy constructors need to be of the same type.</p>\n<p>You haven't actually made a copy constructor.  <code>B(const A &amp; x)</code> is just a constructor that takes a <code>const A</code> by reference.</p>\n<p>So, you don't need to make one for the derived class \"as well\",  but \"at all\".  As you stated, the type of this will be <code>B(const B &amp;x)</code>.</p>\n", "OwnerUserId": "286340", "PostTypeId": "2", "Id": "7778722", "Score": "1", "CreationDate": "2011-10-15T15:24:57.390", "LastActivityDate": "2011-10-15T15:24:57.390"}, "7778724": {"ParentId": "7778698", "CommentCount": "0", "Body": "<p>The default copy-ctor for classes of type B would be B(const B&amp;). Since you haven't specified this one, the compiler kindly generates it for you.</p>\n<p>Its different with user defined methods as those cannot be compiler generated.</p>\n", "OwnerUserId": "989510", "PostTypeId": "2", "Id": "7778724", "Score": "1", "CreationDate": "2011-10-15T15:25:19.887", "LastActivityDate": "2011-10-15T15:25:19.887"}, "bq_ids": {"n4140": {"so_7778698_7778720_0": {"section_id": 451, "quality": 0.92, "length": 23}}, "n3337": {"so_7778698_7778720_0": {"section_id": 442, "quality": 0.92, "length": 23}}, "n4659": {"so_7778698_7778720_0": {"section_id": 474, "quality": 0.92, "length": 23}}}});