post_cb({"8467994": {"ParentId": "8467968", "CommentCount": "0", "Body": "<p>Elements of vectors must be copy-assignable, which your <code>Student</code> struct isn't because of the <code>const</code> member. Simply use <code>string name</code> instead of <code>const string name</code>.\nUnless you have a specific requirement, constant members in classes are seldom useful. If you want to prevent changes to the member, make it private and add a public getter function.</p>\n", "OwnerUserId": "178761", "PostTypeId": "2", "Id": "8467994", "Score": "1", "CreationDate": "2011-12-11T22:21:08.263", "LastActivityDate": "2011-12-11T22:21:08.263"}, "8467987": {"ParentId": "8467968", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>You can't. Your type violates the \"Assignable\" requirement for standard containers.</p>\n<p>ISO/IEC 14882:2003 23.1 [lib.container.requirements] / 3:</p>\n<blockquote>\n<p id=\"so_8467968_8467987_0\">The type of objects stored in these components must meet the requirements of <code>CopyConstructible</code>\n  types (20.1.3), and the additional requirements of <code>Assignable</code> types.</p>\n</blockquote>\n<p>From table 64 (<code>Assignable</code> requirements):</p>\n<blockquote>\n<p id=\"so_8467968_8467987_1\">In Table 64, <code>T</code> is the type used to instantiate the container, <code>t</code> is a value of <code>T</code>, and <code>u</code> is a value of (possibly <code>const</code>) <code>T</code>.</p>\n<p id=\"so_8467968_8467987_2\">expression: <code>t = u</code>; return type: <code>T</code>; post-condition: <code>t</code> is equivalent to <code>u</code></p>\n</blockquote>\n<p>In theory, a <code>std::vector</code> equivalent could choose to do destruction and copy construction in all cases, but that's not the contract that has been chosen. If reallocation isn't required, then using the contained type's assignment operator for things like <code>vector::operator=</code> and <code>vector::assign</code> might be significantly more efficient.</p>\n", "OwnerUserId": "19563", "LastEditorUserId": "19563", "LastEditDate": "2011-12-11T22:52:41.283", "Id": "8467987", "Score": "7", "CreationDate": "2011-12-11T22:20:08.233", "LastActivityDate": "2011-12-11T22:52:41.283"}, "8467968": {"CommentCount": "3", "AcceptedAnswerId": "8467987", "CreationDate": "2011-12-11T22:17:28.940", "LastActivityDate": "2011-12-11T22:52:41.283", "PostTypeId": "1", "ViewCount": "1479", "FavoriteCount": "1", "Title": "Vector of structs with const members?", "Id": "8467968", "Score": "11", "Body": "<p>Let's say I have</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct Student\n{\n    const string name;\n    int grade;\n    Student(const string &amp;name) : name(name) { }\n};\n</code></pre>\n<p>How do I, then, keep a vector of students?</p>\n<pre><code>int main()\n{\n    vector&lt;Student&gt; v;\n\n    // error C2582: 'operator =' function is unavailable in 'Student'\n    v.push_back(Student(\"john\"));\n}\n</code></pre>\n<p>Is there even a way to do this, or must I allocate all the students on the heap, and store a pointer to each of them instead?</p>\n", "Tags": "<c++><const><c++03>", "OwnerUserId": "541686", "AnswerCount": "4"}, "8467985": {"ParentId": "8467968", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The simple answer is: you can't.  If you have <code>const</code> member variables, then the compiler can't supply a default copy-assignment operator.  However, many of the operations that <code>std::vector</code> provides need to make assignments, and therefore require a (public) copy-assignment operator.</p>\n<p>Your options are:</p>\n<ol>\n<li>Make <code>name</code> non-<code>const</code>.</li>\n<li>Write your own copy-assignment operator, and think of a way to deal with \"copying\" a <code>const</code> member.</li>\n</ol>\n", "OwnerUserId": "129570", "LastEditorUserId": "129570", "LastEditDate": "2011-12-11T22:33:42.087", "Id": "8467985", "Score": "8", "CreationDate": "2011-12-11T22:20:02.757", "LastActivityDate": "2011-12-11T22:33:42.087"}, "8468093": {"ParentId": "8467968", "CommentCount": "0", "Body": "<p>A <code>vector</code> often needs to move elements around.  Every time a vector needs to grow when you call <code>push_back()</code> it reallocates memory to keep itself contiguous, and copies all the existing elements into the new space.  Also if you call <code>insert()</code> or <code>remove()</code> elements must\nbe shifted. For <code>vector</code> to be able to do all that the elements must be copy-assignable, which means that the type you store in the vector must have the assignment operator defined.</p>\n<p>Generally, if you define a class, the compiler will generate the assignment operator for that class for you.  However, there are cases when the compiler is unable to do that.  One of these cases is when the class has constant members (note that pointers-to-const are ok).  </p>\n<p>So, in your case, the problem is the <code>const string name</code>.  It prevents the compiler from generating <code>operator=()</code>, which in turn prevents <code>vector</code> from compiling, even though you do not actually use assignment on its elements yourself.</p>\n<p>One solution is to make <code>name</code> non-const.  The other is to write your own <code>Student::operator=()</code>, in some way that makes sense.  The third way is, as you have pointed out, to use a vector of pointers rather than a vector of objects.  But then you have to handle their allocation and de-allocation.</p>\n<p>P.S. The other case when the compiler cannot generate <code>operator=</code> is when your class has members that are references.</p>\n", "OwnerUserId": "13313", "PostTypeId": "2", "Id": "8468093", "Score": "3", "CreationDate": "2011-12-11T22:40:13.393", "LastActivityDate": "2011-12-11T22:40:13.393"}, "bq_ids": {"n4140": {"so_8467968_8467987_2": {"section_id": 715, "quality": 0.8, "length": 4}, "so_8467968_8467987_1": {"section_id": 763, "quality": 0.625, "length": 5}}, "n3337": {"so_8467968_8467987_2": {"section_id": 3773, "quality": 0.8, "length": 4}, "so_8467968_8467987_1": {"section_id": 750, "quality": 0.625, "length": 5}}, "n4659": {"so_8467968_8467987_2": {"section_id": 745, "quality": 0.8, "length": 4}, "so_8467968_8467987_1": {"section_id": 823, "quality": 0.625, "length": 5}}}});