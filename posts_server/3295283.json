post_cb({"bq_ids": {"n4140": {"so_3295283_3295425_0": {"length": 69, "quality": 0.9452054794520548, "section_id": 243}, "so_3295283_3295425_1": {"length": 45, "quality": 0.8823529411764706, "section_id": 245}}, "n3337": {"so_3295283_3295425_0": {"length": 69, "quality": 0.9452054794520548, "section_id": 235}, "so_3295283_3295425_1": {"length": 45, "quality": 0.8823529411764706, "section_id": 237}}, "n4659": {"so_3295283_3295425_0": {"length": 67, "quality": 0.9178082191780822, "section_id": 250}, "so_3295283_3295425_1": {"length": 44, "quality": 0.8627450980392157, "section_id": 252}}}, "3295425": {"Id": "3295425", "PostTypeId": "2", "Body": "<p>The following fails for my in Dev Studio:</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nstd::vector&lt;std::vector&lt;T&gt; &gt; transform(std::vector&lt;std::vector&lt;T&gt; &gt; const &amp;vec,\n                                       std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;T&gt; &gt; &gt; &gt; const &amp;m,\n                                       T z = T(0), T w = T(1));\n\n\ntemplate &lt;typename T&gt;\nstd::vector&lt;std::vector&lt;T&gt; &gt; transform(std::vector&lt;std::vector&lt;T&gt; &gt; const &amp;vec,\n                                       std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;T&gt; &gt; &gt; &gt; const &amp;m,\n                                       T z, T w)\n{\n    std::cout &lt;&lt; \"Z\" &lt;&lt; z &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"W\" &lt;&lt; w &lt;&lt; \"\\n\";\n\n    return vec;\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    std::vector&lt;std::vector&lt;int&gt; &gt;  xi;\n    std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; &gt; mi;\n    transform(xi,mi);\n\n    std::vector&lt;std::vector&lt;float&gt; &gt;    xf;\n    std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;float&gt; &gt; &gt; &gt; mf;\n    transform(xf,mf);\n\n    std::vector&lt;std::vector&lt;double&gt; &gt;   xd;\n    std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;double&gt; &gt; &gt; &gt; md;\n    transform(xd,md);\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Z0\nW1\nZ0\nW1.4013e-045\nZ2.122e-314\nW3.60689e-305\n</code></pre>\n<p>So I suppose it does not work as expected!!!</p>\n<p>If you remove the pre-declaration and put the default arguments in the template function then it works as expected.</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nstd::vector&lt;std::vector&lt;T&gt; &gt; transform(std::vector&lt;std::vector&lt;T&gt; &gt; const &amp;vec,\n                                       std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;T&gt; &gt; &gt; &gt; const &amp;m\n                                       T z = T(0), T w = T(1))\n{\n    std::cout &lt;&lt; \"Z\" &lt;&lt; z &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"W\" &lt;&lt; w &lt;&lt; \"\\n\";\n\n    return vec;\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    std::vector&lt;std::vector&lt;int&gt; &gt;  xi;\n    std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;int&gt; &gt; &gt; &gt; mi;\n    transform(xi,mi);\n\n    std::vector&lt;std::vector&lt;float&gt; &gt;    xf;\n    std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;float&gt; &gt; &gt; &gt; mf;\n    transform(xf,mf);\n\n    std::vector&lt;std::vector&lt;double&gt; &gt;   xd;\n    std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;double&gt; &gt; &gt; &gt; md;\n    transform(xd,md);\n}\n</code></pre>\n<p>This works as expected.<br>\nThis has something to do with the template pre-declaration not actually being a function pre-declaration and thus it does not actually have default parameters and as such you are getting random values in the parameter list.</br></p>\n<p>OK. Not from my reading of the standard this should work as expected:</p>\n<p>Using n2521<br>\nSection 14.7.1 Implicit instantiation<br>\nParagraph 9</br></br></p>\n<blockquote>\n<p id=\"so_3295283_3295425_0\">An implementation shall not implicitly instantiate a function template, a member template, a non-virtual member func- tion, a member class or a static data member of a class template that does not require instantiation. It is unspecified whether or not an implementation implicitly instantiates a virtual member function of a class template if the virtual member function would not otherwise be instantiated. The use of a template specialization in a default argument shall not cause the template to be implicitly instantiated except that a class template may be instantiated where its complete type is needed to determine the correctness of the default argument. <b>The use of a default argument in a function call causes specializations in the default argument to be implicitly instantiated.</b></p>\n</blockquote>\n<p>The bold part of the paragraph seems (to me) to indicate that each specialization created because of default arguments will be implicitly instantiated into the translation unit when used.</p>\n<p>Paragraph 11:</p>\n<blockquote>\n<p id=\"so_3295283_3295425_1\">If a function template f is called in a way that requires a default argument expression to be used, the dependent names are looked up, the semantics constraints are checked, and the instantiation of any template used in the default argument expression is done as if the default argument expression had been an expression used in a function template specialization with the same scope, the same template parameters and the same access as that of the function template f used at that point. This analysis is called default argument instantiation. The instantiated default argument is then used as the argument of f.</p>\n</blockquote>\n<p>Indicates that even if the default arguments are template parameters they will be correctly instantiated.</p>\n<p>Well I hope I interpreted that correctly. :-)</p>\n", "LastEditorUserId": "14065", "LastActivityDate": "2010-07-22T04:00:50.503", "Score": "5", "CreationDate": "2010-07-21T00:23:21.957", "ParentId": "3295283", "CommentCount": "12", "LastEditDate": "2010-07-22T04:00:50.503", "OwnerUserId": "14065"}, "3295357": {"Id": "3295357", "PostTypeId": "2", "Body": "<p>Is the code optimized? Maybe that's why the debugger is showing you the wrong values.</p>\n<p>I tried this simpler code (in g++ 4.3.3) and it works as expected.</p>\n<pre><code>template &lt;typename T&gt;\nT increment(T a, T b = T(1))\n{\n    return a + b;\n}\n\nint main()\n{\n    double a = 5.0;\n    std::cout &lt;&lt; increment(a) &lt;&lt; \", \";\n    std::cout &lt;&lt; increment(a, 3.0) &lt;&lt; \"\\n\";\n}\n</code></pre>\n", "LastActivityDate": "2010-07-21T00:06:12.537", "Score": "2", "CreationDate": "2010-07-21T00:06:12.537", "ParentId": "3295283", "CommentCount": "1", "OwnerUserId": "17221"}, "3295283": {"ViewCount": "626", "Body": "<p>I have hit upon a real brain scorcher in C++, it has never happened to me before.</p>\n<p>The gist of the problem is that upon invocation of my (template) function the arguments I have defined defaults for have their values scrambled. It only happens if I call the function with the defaults.</p>\n<p>My template function is declared like this:</p>\n<pre><code>template &lt;typename T&gt;\nvector2&lt;T&gt; transform(vector2&lt;T&gt; const &amp;vec, matrix4&lt;T&gt; const &amp;m, T z = T(0), T w = T(1));\n</code></pre>\n<p>It is later, in the same header, defined like this:</p>\n<pre><code>template &lt;typename T&gt;\ninline vector2&lt;T&gt; transform(vector2&lt;T&gt; const &amp;vec, matrix4&lt;T&gt; const &amp;m, T z, T w)\n{\n vector4&lt;T&gt; res = m * vector4&lt;T&gt;(vec.x, vec.y, z, w);\n return vector2&lt;T&gt;(res.x, res.y);\n}\n</code></pre>\n<p>Now when I call this with defaults (<code>transform(vector2&lt;double&gt;(0, 1), view_transform)</code>) I don't get the values I expect. Stepping into <code>transform</code> with VC++s debugger I see <code>z</code> and <code>w</code> having \"funny\" values (which in my experience means something isn't initialized properly).</p>\n<p>Example funny values would be: 0.0078125000000000000 and 2.104431116947e-317#DEN</p>\n<p>Now I've tried finding the answer on C++ FAQ Lite, googling it; even tried to calm myself with Schubert, but I can't for the life of me figure it out. I'm guessing it's really simple and I suspect it's some kind of template tomfoolery at work.</p>\n<p>Is there a way to get the default values I expect and want, and why does it do this to me?</p>\n<p><strong>Edit 1:</strong></p>\n<p>If I the change call so it uses floats instead (<code>transform(vector2&lt;float&gt;(0, 1), view_transform)</code>) the problem goes away. It appears this only occurs if <code>T</code> = <code>double</code>.</p>\n<p><strong>Edit 2:</strong></p>\n<p>It only happens if I have two specializations for <code>double</code> and <code>float</code>. If I use a float specialization in one place the double specialization gets weird default values. If I change all the places the function is called so it uses double the problems \"goes away\". I still don't understand why though, it's like it's using faulty offsets or something when setting up <code>z</code> and <code>w</code>.</p>\n<p><strong>Edit 3:</strong></p>\n<p>Tales from the C++ Crypt:</p>\n<pre><code>#include &lt;sgt/matrix4.hpp&gt;\n\nint main(int argc, char *argv[])\n{\n    sgt::matrix4&lt;double&gt; m0(\n        2, 0, 0, 1,\n        0, 2, 0, 1,\n        0, 0, 1, 0,\n        0, 0, 0, 1);\n\n    m0 *= m0;\n\n    sgt::vector2&lt;double&gt; blah0 = sgt::transform(sgt::vector2&lt;double&gt;(1, 0), m0);\n\n    sgt::matrix4&lt;float&gt; m1(\n        2, 0, 0, 1,\n        0, 2, 0, 1,\n        0, 0, 1, 0,\n        0, 0, 0, 1);\n\n    m1 *= m1;\n\n    sgt::vector2&lt;float&gt; blah1 = sgt::transform(sgt::vector2&lt;float&gt;(1, 0), m1);\n\n    printf(\"%f\", blah0.x);\n    printf(\"%f\", blah1.x);\n}\n</code></pre>\n<p>In matrix4.hpp:</p>\n<pre><code>// ...\n\ntemplate &lt;typename T&gt;\nvector2&lt;T&gt; transform(vector2&lt;T&gt; const &amp;vec, matrix4&lt;T&gt; const &amp;m, T z = T(0), T w = T(1));\n\ntemplate &lt;typename T&gt;\ninline vector2&lt;T&gt; transform(vector2&lt;T&gt; const &amp;vec, matrix4&lt;T&gt; const &amp;m, T z, T w)\n{\n    vector4&lt;T&gt; res = m * vector4&lt;T&gt;(vec.x, vec.y, z, w);\n    return vector2&lt;T&gt;(res.x, res.y);\n}\n\n// ...\n</code></pre>\n<p>If I run that, the double-specialization has it's default arguments correct, but the float version gets both it's default arguments as zero (0.000000) which albeit better, it's still is not <code>z = 0</code> and <code>w = 1</code>.</p>\n<p><strong>Edit 4:</strong></p>\n<p>Made a <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/577070/pre-declared-function-template-gets-erronous-default-values\" rel=\"nofollow noreferrer\">Connect issue</a>.</p>\n", "AcceptedAnswerId": "3295425", "Title": "C++ template function gets erronous default values", "CreationDate": "2010-07-20T23:50:23.440", "Id": "3295283", "CommentCount": "10", "LastEditDate": "2010-07-21T16:52:58.597", "PostTypeId": "1", "LastEditorUserId": "12183", "LastActivityDate": "2010-07-22T04:00:50.503", "Score": "10", "OwnerUserId": "12183", "Tags": "<c++><templates><default-value><compiler-bug>", "AnswerCount": "3"}, "3295335": {"Id": "3295335", "PostTypeId": "2", "Body": "<p>I do not know if this will work, but try using a static_cast instead of a C style cast for your default values.</p>\n<p><strong>*Edit:</strong> Apparently, the problem is the compiler.</p>\n", "LastEditorUserId": "209824", "LastActivityDate": "2010-07-21T03:44:49.973", "Score": "1", "CreationDate": "2010-07-21T00:01:12.857", "ParentId": "3295283", "CommentCount": "5", "LastEditDate": "2010-07-21T03:44:49.973", "OwnerUserId": "209824"}});