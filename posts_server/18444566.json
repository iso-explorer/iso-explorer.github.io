post_cb({"bq_ids": {"n3337": {"so_18444566_18444749_0": {"section_id": 5913, "quality": 1.0, "length": 13}}, "n4659": {"so_18444566_18444749_0": {"section_id": 7709, "quality": 0.5384615384615384, "length": 7}}}, "18445886": {"ParentId": "18444566", "CommentCount": "2", "CreationDate": "2013-08-26T13:55:51.490", "PostTypeId": "2", "Id": "18445886", "Score": "2", "Body": "<p><code>==</code> and <code>!=</code> are valid and well-defined for all pointers of the same type. <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> are only meaningful for pointers that point to objects in the same array or one-past-the-end of the array. They are also meaningful for pointers to sub-objects of a class object if the sub-objects have the same type and the same access specifier. If those conditions aren't met, the result is unspecified; one immediate consequence is that <code>a&lt;b</code> and <code>b&lt;c</code> does <strong>not</strong> imply that <code>a&lt;c</code>, so you cannot use <code>&lt;</code>, etc. as the comparator for a sort function.</p>\n<p><code>std::less</code>, <code>std::less_equal</code>, <code>std::greater</code>, and <code>std::greater_equal</code> for pointer types all define a total ordering; they can be used for sorting.</p>\n", "OwnerUserId": "1593860", "LastActivityDate": "2013-08-26T13:55:51.490"}, "18444611": {"ParentId": "18444566", "LastEditDate": "2013-08-26T13:04:28.517", "CommentCount": "5", "CreationDate": "2013-08-26T12:52:31.067", "LastEditorUserId": "14860", "PostTypeId": "2", "Id": "18444611", "Score": "4", "Body": "<p>You can compare pointers with the relational operators (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>) provided they both point to an element of the same array, or one past that array. Anything else is unspecified behaviour as per C++11 <code>5.9 Relational operators</code>. So, given:</p>\n<pre><code>char xyzzy[10];\nchar plugh[10];\n</code></pre>\n<p>All these are specified to function correctly:</p>\n<pre><code>assert(&amp;(xyzzy[1]) &lt; &amp;(xyzzy[4]));\nassert(&amp;(xyzzy[9]) &lt; &amp;(xyzzy[10])); // even though [10] isn't there.\n</code></pre>\n<p>but these are not:</p>\n<pre><code>assert(&amp;(xyzzy[1]) &lt; &amp;(xyzzy[15]));\nassert(&amp;(xyzzy[9]) &lt; &amp;(plugh[3]));\n</code></pre>\n<p>The type doesn't come into it except that it has to be the same type if you're comparing two elements in the same array. If you have two <code>char *</code> variables, that's unspecified if they point to <em>different</em> arrays even though they have the same type.</p>\n", "OwnerUserId": "14860", "LastActivityDate": "2013-08-26T13:04:28.517"}, "18444749": {"ParentId": "18444566", "LastEditDate": "2013-08-26T13:11:04.120", "CommentCount": "0", "CreationDate": "2013-08-26T12:59:11.220", "LastEditorUserId": "319403", "PostTypeId": "2", "Id": "18444749", "Score": "3", "Body": "<p>You can determine the order of pointers only with on array object and if they are non-<code>void</code>. However, within one array object the comparison is well defined. The relevant clause in the standard is 5.9 [expr.rel] paragraph 2:</p>\n<blockquote>\n<p id=\"so_18444566_18444749_0\">[...] Pointers to objects or functions of the same type (after pointer conversions) can be compared, with a result defined as follows:</p>\n<ul>\n<li>If two pointers <code>p</code> and <code>q</code> of the same type point to the same object or function, or both point one past the end of the same array, or are both null, then <code>p&lt;=q</code> and <code>p&gt;=q</code> both yield <code>true</code> and <code>p&lt;q</code> and <code>p&gt;q</code> both yield <code>false</code>.</li>\n<li>If two pointers <code>p</code> and <code>q</code> of the same type point to different objects that are not members of the same object or elements of the same array or to different functions, or if only one of them is null, the results of <code>p&lt;q</code>, <code>p&gt;q</code>, <code>p&lt;=q</code>, and <code>p&gt;=q</code> are unspecified.</li>\n<li>If two pointers point to non-static data members of the same object, or to subobjects or array elements of such members, recursively, the pointer to the later declared member compares greater provided the two members have the same access control (Clause 11) and provided their class is not a union.</li>\n<li>If two pointers point to non-static data members of the same object with different access control (Clause 11) the result is unspecified.</li>\n<li>If two pointers point to non-static data members of the same union object, they compare equal (after conversion to <code>void*</code>, if necessary). If two pointers point to elements of the same array or one beyond the end of the array, the pointer to the object with the higher subscript compares higher.</li>\n<li>Other pointer comparisons are unspecified.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "1120273", "LastActivityDate": "2013-08-26T13:11:04.120"}, "18444566": {"CommentCount": "0", "AcceptedAnswerId": "18444611", "LastActivityDate": "2013-08-26T13:55:51.490", "Body": "<pre><code>char** buffer{ /* some buffer */ };\nchar* ptr1{buffer[0]};\nchar* ptr2{buffer[10]};\n\nassert(ptr1 &lt; ptr2);\n</code></pre>\n<p>If two pointers point to different locations in the same buffer, is it safe to compare them?</p>\n<p>I want to know if a <em>range of pointers</em> is valid by comparing: <code>assert(rangeBeginPtr &lt; rangeEndPtr)</code>.</p>\n", "PostTypeId": "1", "ViewCount": "394", "Title": "Is it safe to compare pointers of same type?", "Id": "18444566", "Score": "1", "CreationDate": "2013-08-26T12:50:22.650", "Tags": "<c++><pointers><c++11><comparison>", "OwnerUserId": "598696", "AnswerCount": "3"}});