post_cb({"1445294": {"Id": "1445294", "PostTypeId": "2", "Body": "<p>The type of the ternary expression is determined at compile-time; it doesn't matter what some_condition is at runtime. </p>\n<p>I guess the question is then: why does the compiler choose int instead of double in the first example? </p>\n", "LastActivityDate": "2009-09-18T15:31:14.760", "CommentCount": "1", "CreationDate": "2009-09-18T15:31:14.760", "ParentId": "1445274", "Score": "1", "OwnerUserId": "137624"}, "1445407": {"Id": "1445407", "PostTypeId": "2", "Body": "<p>ternary operator guesses the type from its arguments. it cannot convert item to int but it can convert item to double which it then converts to int.</p>\n", "LastActivityDate": "2009-09-18T15:49:42.110", "CommentCount": "0", "CreationDate": "2009-09-18T15:49:42.110", "ParentId": "1445274", "Score": "0", "OwnerUserId": "44952"}, "1445327": {"Id": "1445327", "PostTypeId": "2", "Body": "<p>The conditional operator checks conversions in both directions. In this case, since your constructor is explicit (so the <code>?:</code> is not ambiguous), the conversion from <code>Foo</code> to <code>int</code> is used, using your conversion function that converts to <code>double</code>: That works, because after applying the conversion function, a standard conversion that converts the <code>double</code> to <code>int</code> (truncation) follows. The result of <code>?:</code> in your case is <code>int</code>, and has the value <code>6</code>. </p>\n<p>In the second case, since the operand has type <code>double</code>, no such trailing conversion to <code>int</code> takes place, and thus the result type of <code>?:</code> has type <code>double</code> with the expected value. </p>\n<p>To understand the \"unnecessary\" conversions, you have to understand that expressions like your <code>?:</code> are evaluated \"context-free\": When determining the value and type of it, the compiler doesn't consider that it's the operand of a <code>return</code> for a function returning a <code>double</code>.</p>\n<hr>\n<p>Edit: What happens if your constructor is <em>implicit</em>? The <code>?:</code> expression will be ambiguous, because you can convert an <code>int</code> to an rvalue of type <code>Foo</code> (using the constructor), and a <code>Foo</code> to an rvalue of type <code>int</code> (using the conversion function). The Standard says</p>\n<blockquote>\n<p id=\"so_1445274_1445327_0\">Using this process, it is determined whether the second operand can be converted to match the third operand, and whether the third operand can be converted to match the second operand. If both can be converted, or one can be converted but the conversion is ambiguous, the program is ill-formed.</p>\n</blockquote>\n<hr>\n<p>Paragraphs explaining how your <code>Foo</code> is converted to <code>int</code>:</p>\n<p><code>5.16/3</code> about <code>condition ? E1 : E2</code>: </p>\n<blockquote>\n<p id=\"so_1445274_1445327_1\">Otherwise, if the second and third operand have different types, and either has (possibly cv-qualified) class type, an attempt is made to convert each of those operands to the type of the other. [...]  E1 can be converted to match E2 if E1 can be implicitly converted to the type that expression E2 would have if E2 were converted to an rvalue (or the type it has, if E2 is an rvalue).</p>\n</blockquote>\n<p><code>4.3</code> about \"implicitly converted\":</p>\n<blockquote>\n<p id=\"so_1445274_1445327_2\">An expression e can be implicitly converted to a type T if and only if the declaration <code>T t = e;</code> is well-formed, for some invented temporary variable t.</p>\n</blockquote>\n<p><code>8.5/14</code> about copy initialization ( <code>T t = e;</code> )</p>\n<blockquote>\n<p id=\"so_1445274_1445327_3\">If the source type is a (possibly cv-qualified) class type, conversion functions are considered. The applicable conversion functions are enumerated (13.3.1.5), and the best one is chosen through overload resolution (13.3). The user-defined conversion so selected is called to convert the initializer expression into the object being initialized. If the conversion cannot be done or is ambiguous, the initialization is ill-formed.</p>\n</blockquote>\n<p><code>13.3.1.5</code> about the conversion function candidates</p>\n<blockquote>\n<p id=\"so_1445274_1445327_4\">The conversion functions of S and its base classes are considered. Those that are not hidden within S and yield type T or a type that can be converted to type T via a standard conversion sequence (13.3.3.1.1) are candidate functions. </p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "34509", "LastActivityDate": "2009-09-18T16:20:35.713", "Score": "9", "CreationDate": "2009-09-18T15:36:23.527", "ParentId": "1445274", "CommentCount": "21", "OwnerUserId": "34509", "LastEditDate": "2009-09-18T16:20:35.713"}, "1445454": {"Id": "1445454", "PostTypeId": "2", "Body": "<p>This is covered in positively confusing detail in section 5.16 of the standard.  The important part is in paragraph 3.  \"If E2 is an lvalue:  E1 can be converted to match E2 if E1 can be implicitly converted (clause 4) to the type 'reference to T2', subject to the constraint that in the conversion the reference must bind directly (8.5.3) to E1.\"</p>\n<p>In the expression, the only lvalue is <code>item</code>, so the question is whether 0 (an int) can be implicitly converted to type <code>Foo</code>.  In this case, there is no implicit conversion of any other type to a <code>Foo</code>, since the only available conversion function is marked <code>explicit</code>.  Therefore, that doesn't work, and we follow with \"if E2 is an rvalue, or if the conversion above cannot be done:\" (skipping the part about if they both have class type) \"Otherwise (i.e., if E1 or E2 has a nonclass type, or if they both have class types but the underlying classes are not either the same or one a base class of the other):  E1 can be converted to match E1 if E1 can be implicitly converted to the type that expression E2 would have if E2 were converted to an rvalue (or the type it has, if E2 is an rvalue).\"</p>\n<p>Therefore, we see that 0 is an rvalue, of type <code>int</code>.  We can convert a <code>Foo</code>, since we can implicitly convert a <code>Foo</code> to a <code>double</code> and thence to an <code>int</code>.  Then:</p>\n<p>\"Using this process, it is determined whether the second operand can be converted to match the third operand, and whether the third operand can be converted to match the second operand.  If both can be converted, oor one can be converted but the conversion is ambiguous, the program is ill-formed.  If neither can be converted, the operands are left unchanged and further checking is performed as described below.  If exactly one conversion is possible, that conversion is applied to the chosen operand and the converted operand is used in the place of the original operand for the remainder of this section.\"</p>\n<p>Since we can convert a <code>Foo</code> to an <code>int</code>, we convert the <code>Foo</code> to an <code>int</code> for the remainder of the determination.  We've now got two <code>int</code>s as expression types, and at least one is an rvalue.</p>\n<p>I can go on with paragraph 5 and 6, but I think it's pretty obvious that the expression has type <code>int</code>.</p>\n<p>I think the takeaways are:</p>\n<ol>\n<li><p>Your compiler is functioning according to the standard.</p></li>\n<li><p>The rules on the type of a conditional expression are too complicated to be easily learned.  Don't push the envelope, because you'll make a mistake sometime.  (Besides, this is exactly the sort of place where a compiler might fail to implement the standard precisely.)</p></li>\n<li><p>Try to specify types so that both the second and third expression are of the same type.  In any case, try to avoid expressions that are not of the desired type.</p></li>\n</ol>\n", "LastActivityDate": "2009-09-18T15:57:56.453", "CommentCount": "4", "CreationDate": "2009-09-18T15:57:56.453", "ParentId": "1445274", "Score": "7", "OwnerUserId": "14148"}, "bq_ids": {"n4140": {"so_1445274_1445327_0": {"length": 29, "quality": 1.0, "section_id": 6169}, "so_1445274_1445327_3": {"length": 35, "quality": 0.8974358974358975, "section_id": 3296}, "so_1445274_1445327_4": {"length": 19, "quality": 0.9047619047619048, "section_id": 595}, "so_1445274_1445327_1": {"length": 33, "quality": 0.9428571428571428, "section_id": 6169}, "so_1445274_1445327_2": {"length": 11, "quality": 1.0, "section_id": 2}}, "n3337": {"so_1445274_1445327_0": {"length": 29, "quality": 1.0, "section_id": 5930}, "so_1445274_1445327_3": {"length": 35, "quality": 0.8974358974358975, "section_id": 3166}, "so_1445274_1445327_4": {"length": 19, "quality": 0.9047619047619048, "section_id": 585}, "so_1445274_1445327_1": {"length": 33, "quality": 0.9428571428571428, "section_id": 5930}, "so_1445274_1445327_2": {"length": 11, "quality": 1.0, "section_id": 2}}, "n4659": {"so_1445274_1445327_0": {"length": 15, "quality": 0.5172413793103449, "section_id": 7667}, "so_1445274_1445327_3": {"length": 35, "quality": 0.8974358974358975, "section_id": 4058}, "so_1445274_1445327_4": {"length": 19, "quality": 0.9047619047619048, "section_id": 618}, "so_1445274_1445327_1": {"length": 24, "quality": 0.6857142857142857, "section_id": 7667}, "so_1445274_1445327_2": {"length": 11, "quality": 1.0, "section_id": 2}}}, "1445274": {"ViewCount": "3021", "Body": "<pre><code>class Foo {\n  public:\n  explicit Foo(double item) : x(item) {}\n\n  operator double() {return x*2.0;}\n\n  private:\n  double x;\n}\n\ndouble TernaryTest(Foo&amp; item) {\n  return some_condition ? item : 0;\n}\n\nFoo abc(3.05);\ndouble test = TernaryTest(abc);\n</code></pre>\n<p>In the above example, why is test equal to 6 (instead of 6.1) if some_condition is true?</p>\n<p>Changing the code like below returns value of 6.1</p>\n<pre><code>double TernaryTest(Foo&amp; item) {\n  return some_condition ? item : 0.0; // note the change from 0 to 0.0\n}\n</code></pre>\n<p>It seems that (in the original example) the return value from Foo::operator double is cast to an int and then back to a double. Why?</p>\n", "AcceptedAnswerId": "1445327", "Title": "Ternary operator evaluation order", "CreationDate": "2009-09-18T15:27:48.323", "Id": "1445274", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2009-09-18T16:20:35.713", "Score": "1", "OwnerUserId": "136720", "Tags": "<c++><ternary-operator><ternary>", "AnswerCount": "4"}});