post_cb({"42212104": {"ParentId": "42196926", "CommentCount": "0", "Body": "<p>The C++ standard says that <code>iword()</code> and <code>pword()</code> should behave as if they are manipulating two separate, independent blocks of storage - rather than, say, a single block whose contents are interpreted as <code>long</code> sometimes and <code>void*</code> other times.</p>\n<blockquote>\n<p id=\"so_42196926_42212104_0\"><strong>[ios.base]</strong></p>\n<pre><code>namespace std {\n  class ios_base {\n  // ...\n  private:\n    long* iarray; // exposition only\n    void** parray; // exposition only\n  };\n}\n</code></pre>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_42196926_42212104_1\"><strong>[ios.base.storage]/3</strong></p>\n<pre><code>  long&amp; iword(int idx);\n</code></pre>\n<p id=\"so_42196926_42212104_2\"><em>Effects:</em> If <code>iarray</code> is a null pointer, allocates an array of <code>long</code> of unspecified size and stores a pointer to its first element in <code>iarray</code>. The function then extends the array pointed at by <code>iarray</code> as necessary to include the element <code>iarray[idx]</code>. Each newly allocated element of the array is initialized to zero. The reference returned is invalid after any other operations on the object. However, the value of the storage referred to is retained, so that until the next call to <code>copyfmt</code>, calling <code>iword</code> with the same index yields another reference to the same value...</p>\n</blockquote>\n<p><strong>[ios.base.storage]/5</strong> repeats the exact same wording, substituting <code>pword</code> for <code>iword</code>, <code>parray</code> for <code>iarray</code> and <code>void*</code> for <code>long</code>.</p>\n<p>The important part is \"the value of the storage ... is retained\" - a subsequent <code>iword</code> call with a given index should see the value that was written into the storage that the previous <code>iword</code> call with the same index provided a reference to, regardless of intervening method calls (other than <code>copyfmt</code>), even if that intervening method call is <code>pword</code> (and vice versa).</p>\n</hr>", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "42212104", "Score": "1", "CreationDate": "2017-02-13T19:33:40.660", "LastActivityDate": "2017-02-13T19:33:40.660"}, "bq_ids": {"n4140": {"so_42196926_42212104_2": {"section_id": 1977, "quality": 0.9491525423728814, "length": 56}}, "n3337": {"so_42196926_42212104_2": {"section_id": 1965, "quality": 0.9491525423728814, "length": 56}}, "n4659": {"so_42196926_42212104_2": {"section_id": 2248, "quality": 0.9491525423728814, "length": 56}}}, "42196926": {"CommentCount": "6", "AcceptedAnswerId": "42212104", "PostTypeId": "1", "LastEditorUserId": "510036", "CreationDate": "2017-02-13T04:59:11.797", "LastActivityDate": "2017-02-13T19:33:40.660", "LastEditDate": "2017-02-13T05:24:05.497", "ViewCount": "63", "FavoriteCount": "1", "Title": "Given the same index, are iword() and pword() guaranteed to refer to separate underlying values?", "Id": "42196926", "Score": "1", "Body": "<p>In the standard C++ <code>ios</code> library, is it guaranteed that <code>&amp;stream.iword(ind) != &amp;stream.pword(ind)</code> when called on the same <code>stream</code> with the same <code>ind</code> value?</p>\n<p>Moreover, is it guaranteed that I can use the <code>void*</code> and <code>long</code> values individually given the same index (i.e. they're not implemented as a union, etc.)?</p>\n<p>I suppose the X-Y problem here is how do I know if, given a random stream, my custom value (\"allocated\" using <code>xalloc()</code>) has been initialized? I ask because I've seen people use <code>pword()</code> to check a magic constant and then <code>iword()</code> to initialize that value if the previous condition fails.</p>\n<p>I mainly care about C++11 and onward, though any relevant historical information is welcome.</p>\n", "Tags": "<c++><c++11><iostream><xalloc>", "OwnerUserId": "510036", "AnswerCount": "1"}});