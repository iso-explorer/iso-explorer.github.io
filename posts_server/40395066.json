post_cb({"40395066": {"CommentCount": "13", "ViewCount": "4437", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-11-03T06:23:49.327", "LastActivityDate": "2016-12-22T19:31:50.310", "Title": "Can '\\0' and NULL be used interchangeably?", "FavoriteCount": "7", "LastEditDate": "2017-05-23T12:25:13.057", "Id": "40395066", "Score": "54", "Body": "<p>NULL is often used in the context of pointers, and is defined via macros in multiple standard libraries (such as <code>&lt;iostream&gt;</code>) to be the integer <code>0</code>. <code>'\\0'</code> is the null character, and is 8 bits of zeros. Incidentally, 8 bits of zeros is equivalent to the integer <code>0</code>. </p>\n<p>In some cases, although it is considered to be horrible style, these two can be interchanged:</p>\n<pre><code>int *p='\\0';\nif (p==NULL) //evaluates to true\n    cout &lt;&lt; \"equal\\n\";\n</code></pre>\n<p>Or</p>\n<pre><code>char a=NULL;\nchar b='\\0';\nif (a==b) //evaluates to true\n    cout &lt;&lt; \"equal again\\n\";\n</code></pre>\n<p>There are already many similar questions on SO alone; for example, the top answer for this question (<a href=\"https://stackoverflow.com/questions/1296843/what-is-the-difference-between-null-0-and-0\">What is the difference between NULL, '\\0' and 0</a>) says \"they are not really the same thing.\" </p>\n<p>Could anyone provide an example that <code>NULL</code> and <code>\\0</code> cannot be interchanged (preferably an actual application and not a pathological case)?</p>\n", "Tags": "<c++><null>", "OwnerUserId": "7107381", "AnswerCount": "7"}, "40417890": {"ParentId": "40395066", "CommentCount": "0", "Body": "<p>Computer programs have two types of readers.</p>\n<p>The first type are computer programs, like the compiler.</p>\n<p>The second type are humans, like yourself and your coworkers.</p>\n<p>Programs are generally fine with getting one type of zero in place of another.\nThere are exceptions, as the other answers have pointed out, but that is not really important.</p>\n<p>What is important is that you are messing with the <em>human</em> readers.</p>\n<p>Human readers are <em>very</em> context sensitive. By using the wrong zero, you are <strong>lying</strong> to you human readers.  They are going to curse you.</p>\n<p>A human that is lied to can overlook bugs more easily.<br>\nA human that is lied to can see \"bugs\" that aren't there. When \"fixing\" these phanthom bugs, they introduce real bugs.</br></p>\n<p>Don't lie to your humans.  One of the humans you are lying to is your future self.  You are going to curse you too.</p>\n", "OwnerUserId": "4989472", "PostTypeId": "2", "Id": "40417890", "Score": "6", "CreationDate": "2016-11-04T08:08:46.510", "LastActivityDate": "2016-11-04T08:08:46.510"}, "40395588": {"ParentId": "40395066", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_40395066_40395588_0\">Could anyone provide an example that NULL and \\0 cannot be interchanged?</p>\n</blockquote>\n<p>The difference between <code>NULL</code> and <code>'\\0'</code> may affect overload resolution.</p>\n<p>Example (<a href=\"http://coliru.stacked-crooked.com/a/fc32a09997ed4946\" rel=\"nofollow noreferrer\">check it on Coliru</a>):</p>\n<pre><code>#include &lt;iostream&gt;\n\n// The overloaded function under question can be a constructor or \n// an overloaded operator, which would make this example less silly\nvoid foo(char)   { std::cout &lt;&lt; \"foo(char)\"  &lt;&lt; std::endl; }\nvoid foo(int)    { std::cout &lt;&lt; \"foo(int)\"   &lt;&lt; std::endl; }\nvoid foo(long)   { std::cout &lt;&lt; \"foo(long)\"  &lt;&lt; std::endl; }\nvoid foo(void*)  { std::cout &lt;&lt; \"foo(void*)\" &lt;&lt; std::endl; }\n\nint main()\n{\n    foo('\\0'); // this will definitely call foo(char)\n    foo(NULL); // this, most probably, will not call foo(char)\n}\n</code></pre>\n<p>Note that the gcc compiler used at Coliru defines <code>NULL</code> as <code>0L</code>, which for this example means that <code>foo(NULL)</code> resolves to <code>foo(long)</code> rather than to <code>foo(void*)</code>. <a href=\"https://stackoverflow.com/a/40396865/6394138\">Ville-Valtteri Tiittanen's answer</a> discusses that aspect in detail.</p>\n", "OwnerUserId": "6394138", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:31:52.503", "Id": "40395588", "Score": "51", "CreationDate": "2016-11-03T07:01:43.773", "LastActivityDate": "2016-11-03T11:32:40.413"}, "40395304": {"ParentId": "40395066", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Please don't do this. It is an anti-pattern, and it is actually wrong. NULL is for NULL pointers, <code>'\\0'</code> is the null-character. They are logically different things. </p>\n<p>I don't think I have ever seen this:</p>\n<pre><code>int* pVal='\\0';\n</code></pre>\n<p>But this is fairly common:</p>\n<pre><code>char a=NULL;\n</code></pre>\n<p>But it is not good form. It makes the code less portable, and in my opinion less readable. It is also likely to cause issues in mixed C/C++ environments.</p>\n<p>It relies on assumptions regarding how any particular implementation defines NULL. For instance, some implementations use a simple </p>\n<pre><code>#define NULL 0\n</code></pre>\n<p>Others might use:</p>\n<pre><code>#define NULL ((void*) 0)\n</code></pre>\n<p>And I have seen others defining as an integer, and all sorts of odd treatment.</p>\n<p><code>NULL</code> should, in my opinion be used solely to indicate an invalid address. If you want a null-character, use <code>'\\0'</code>. Or define this as <code>NULLCHR</code>. But that isn't as clean.</p>\n<p>This will make your code more portable- you won't start getting warnings regarding types etc if you change compiler / environment /compiler settings. This might be more important in a C or mixed C/C++ environment.</p>\n<p>An example of warnings that might arise: Consider this code:</p>\n<pre><code>#define NULL 0\nchar str[8];\nstr[0]=NULL;\n</code></pre>\n<p>This is equivalent to:</p>\n<pre><code>#define NULL 0\nchar str[8];\nstr[0]=0;\n</code></pre>\n<p>And we are assigning an integer value to a char. This may cause a compiler warning, and if there are enough occurrences of this, pretty soon you can't see any <em>important</em> warnings. And for me, this is the real problem. Having warnings in the code has two side effects:</p>\n<ol>\n<li>Given enough warnings, you don't spot new ones.</li>\n<li>It gives the signal that warnings are acceptable.</li>\n</ol>\n<p>In both cases, actual bugs can then slip through, that would be caught by the compiler had we bothered to read the warnings (or turn on -Werror )</p>\n", "OwnerUserId": "2139094", "LastEditorUserId": "2139094", "LastEditDate": "2016-11-03T09:54:34.837", "Id": "40395304", "Score": "8", "CreationDate": "2016-11-03T06:41:55.480", "LastActivityDate": "2016-11-03T09:54:34.837"}, "40396865": {"ParentId": "40395066", "PostTypeId": "2", "CommentCount": "3", "Body": "<h1>Definition of macro NULL in C++</h1>\n<p><a href=\"https://stackoverflow.com/a/40395588/5489178\">Leon is correct</a> that when there are several overloads for the same function, <code>\\0</code> would prefer the one that takes parameter of type <code>char</code>. However, it is important to notice that on a typical compiler, <code>NULL</code> would prefer the overload that takes parameter of type <code>int</code>, not of type <code>void*</code>!</p>\n<p>What probably causes this confusion is that C language allows defining <code>NULL</code> as <code>(void*)0</code>. C++ standard explicitly states <em><sup>(draft N3936, page 444)</sup></em>:</p>\n<blockquote>\n<p id=\"so_40395066_40396865_0\">Possible definitions [of macro <code>NULL</code>] include <code>0</code> and <code>0L</code>, but not <code>(void*)0</code>.</p>\n</blockquote>\n<p>This restriction is necessary, because e.g. <code>char *p = (void*)0</code> is valid C but invalid C++, whereas <code>char *p = 0</code> is valid in both. </p>\n<p>In C++11 and later, you should use <code>nullptr</code>, if you need a null constant that behaves as pointer.</p>\n<h2>How Leon's suggestion works in practice</h2>\n<p>This code defines several overloads of a single function. Each overload outputs the type of the parameter:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid f(int) {\n    std::cout &lt;&lt; \"int\" &lt;&lt; std::endl;\n}\n\nvoid f(long) {\n    std::cout &lt;&lt; \"long\" &lt;&lt; std::endl;\n}\n\nvoid f(char) {\n    std::cout &lt;&lt; \"char\" &lt;&lt; std::endl;\n}\n\nvoid f(void*) {\n    std::cout &lt;&lt; \"void*\" &lt;&lt; std::endl;\n}\n\nint main() {\n    f(0);\n    f(NULL);\n    f('\\0');\n    f(nullptr);\n}\n</code></pre>\n<p><a href=\"http://ideone.com/DVnMAp\" rel=\"nofollow noreferrer\">On Ideone</a> this outputs</p>\n<pre><code>int\nint\nchar\nvoid*\n</code></pre>\n<p>Therefore I would claim that the problem with overloads is not an actual application but a pathological case. The <code>NULL</code> constant will behave wrong anyway, and should be replaced with <code>nullptr</code> in C++11.</p>\n<h1>What if NULL is not zero?</h1>\n<p>Another pathological case <a href=\"https://stackoverflow.com/a/1296865/5489178\">is suggested by Andrew Keeton</a> at another question:</p>\n<blockquote>\n<p id=\"so_40395066_40396865_1\">Note that what is a null pointer in the C language. It does not matter on the underlying architecture. If the underlying architecture has a null pointer value defined as address 0xDEADBEEF, then it is up to the compiler to sort this mess out.</p>\n<p id=\"so_40395066_40396865_2\">As such, even on this funny architecture, the following ways are still valid ways to check for a null pointer:</p>\n<pre><code>if (!pointer)\nif (pointer == NULL)\nif (pointer == 0)\n</code></pre>\n<p id=\"so_40395066_40396865_3\">The following are INVALID ways to check for a null pointer:</p>\n<pre><code>#define MYNULL (void *) 0xDEADBEEF\nif (pointer == MYNULL)\nif (pointer == 0xDEADBEEF)\n</code></pre>\n<p id=\"so_40395066_40396865_4\">as these are seen by a compiler as normal comparisons. </p>\n</blockquote>\n<h1>Summary</h1>\n<p>All in all, I would say that the differences are mostly stylistic. If you have a function that takes <code>int</code> and overload that takes <code>char</code>, and they function differently, you will notice difference when you call them with <code>\\0</code> and <code>NULL</code> constants. But as soon as you place those constants in variables, the difference disappears, because the function that is called is deducted from the type of the variable.</p>\n<p>Using correct constants makes the code more maintainable, and conveys meaning better. You should use <code>0</code> when you mean a number, <code>\\0</code> when you mean a character, and <code>nullptr</code> when you mean a pointer. <a href=\"https://stackoverflow.com/users/147192/matthieu-m\">Matthieu M.</a> points out in comments, that <a href=\"http://www.viva64.com/en/b/0425/\" rel=\"nofollow noreferrer\">GCC had a bug</a>, in which a <code>char*</code> was compared to <code>\\0</code>, whereas the intention was to dereference the pointer and compare a <code>char</code> to <code>\\0</code>. Such errors are easier to detect, if proper style is used thorough the codebase. </p>\n<p>To answer your question, there is not really an actual use case that would prevent you from using <code>\\0</code> and <code>NULL</code> interchangeably. Just stylistic reasons and some edge cases. </p>\n", "OwnerUserId": "5489178", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:25:13.057", "Id": "40396865", "Score": "36", "CreationDate": "2016-11-03T08:31:51.633", "LastActivityDate": "2016-11-04T17:19:39.660"}, "40437060": {"ParentId": "40395066", "CommentCount": "0", "Body": "<h1>Let's define what's NULL in C/C++.</h1>\n<p>According to the C/C++ reference NULL is defined as a macro that expands to a null pointer constant. Next we can read that a null pointer constant can be converted to any pointer type (or pointer-to-member type), which acquires a null pointer value. This is a special value that indicates that the pointer is not pointing to any object.</p>\n<p>Definition referring to C:</p>\n<blockquote>\n<p id=\"so_40395066_40437060_0\">A null-pointer constant is an integral constant expression that\n  evaluates to zero (like 0 or 0L), or the cast of such value to type\n  void* (like (void*)0).</p>\n</blockquote>\n<p>Definition referring to C++98:</p>\n<blockquote>\n<p id=\"so_40395066_40437060_1\">A null-pointer constant is an integral constant expression that evaluates to zero (such as 0 or 0L).</p>\n</blockquote>\n<p>Definition referring to C++11:</p>\n<blockquote>\n<p id=\"so_40395066_40437060_2\">A null-pointer constant is either an integral constant expression that evaluates to zero (such as 0 or 0L), or a value of type nullptr_t (such as nullptr).</p>\n</blockquote>\n<h1>Overloading methods example.</h1>\n<p>Let's assume that we have following methods:</p>\n<pre><code>class Test {\npublic:\n    method1(char arg0);\n    method1(int arg0);\n    method1(void* arg0);\n    method1(bool arg0);\n}\n</code></pre>\n<p>Calling method1 with argument <code>NULL</code> or <code>nullptr</code> should call <code>method1(void* arg0);</code>. However if we call method1 with argument <code>'\\0'</code> or <code>0</code> should execute <code>method1(char arg0);</code> and <code>method1(int arg0);</code>.</p>\n", "OwnerUserId": "6927987", "PostTypeId": "2", "Id": "40437060", "Score": "1", "CreationDate": "2016-11-05T10:19:14.750", "LastActivityDate": "2016-11-05T10:19:14.750"}, "40396015": {"ParentId": "40395066", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Excerpts from C++14 draft N3936:</p>\n<blockquote>\n<h3>18.2 Types [support.types]</h3>\n<p id=\"so_40395066_40396015_0\">3 The macro <code>NULL</code> is an implementation-de\ufb01ned C++ null pointer constant in this International Standard (4.10).</p>\n<h3>4.10 Pointer conversions [conv.ptr]</h3>\n<p id=\"so_40395066_40396015_1\">1 A <em>null pointer constant</em> is an integer literal (2.14.2) with value zero or a prvalue of type <code>std::nullptr_t</code>.<br>\n  A null pointer constant can be converted to a pointer type; the result is the <em>null pointer value</em> of that type and is distinguishable from every other value of object pointer or function pointer type.</br></p>\n</blockquote>\n<p>Thus, <code>NULL</code> can be any integer literal with value zero, or a value of type <code>std::nullptr_t</code> like <code>nullptr</code>, while <code>'\\0'</code> is always the zero narrow-character literal.</p>\n<p>So, not in general interchangeable, even though in a pointer-context you cannot see any but stylistic difference.</p>\n<p>An example would be:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nint main() {\n    std::cout &lt;&lt; typeid('\\0').name &lt;&lt; '\\n'\n        &lt;&lt; typeid(NULL).name &lt;&lt; '\\n'\n        &lt;&lt; typeid(nullptr).name &lt;&lt; '\\n';\n}\n</code></pre>\n", "OwnerUserId": "3204551", "LastEditorUserId": "4850040", "LastEditDate": "2016-11-03T11:08:03.697", "Id": "40396015", "Score": "4", "CreationDate": "2016-11-03T07:33:21.173", "LastActivityDate": "2016-11-03T11:08:03.697"}, "bq_ids": {"n4140": {"so_40395066_40396015_0": {"section_id": 2515, "quality": 0.6, "length": 6}, "so_40395066_40437060_1": {"section_id": 5464, "quality": 0.625, "length": 5}, "so_40395066_40396015_1": {"section_id": 39, "quality": 0.90625, "length": 29}, "so_40395066_40396865_0": {"section_id": 6705, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_40395066_40396015_0": {"section_id": 6460, "quality": 0.6, "length": 6}, "so_40395066_40437060_2": {"section_id": 36, "quality": 0.5714285714285714, "length": 8}, "so_40395066_40396015_1": {"section_id": 36, "quality": 0.84375, "length": 27}, "so_40395066_40437060_0": {"section_id": 36, "quality": 0.5333333333333333, "length": 8}, "so_40395066_40437060_1": {"section_id": 36, "quality": 0.75, "length": 6}, "so_40395066_40396865_0": {"section_id": 6460, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_40395066_40396015_0": {"section_id": 3249, "quality": 0.6, "length": 6}, "so_40395066_40437060_1": {"section_id": 6898, "quality": 0.625, "length": 5}, "so_40395066_40396015_1": {"section_id": 39, "quality": 0.90625, "length": 29}, "so_40395066_40396865_0": {"section_id": 8180, "quality": 0.7142857142857143, "length": 5}}}, "40395457": {"ParentId": "40395066", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, they may exhibit different behaviour while doing resolution of overloaded functions. </p>\n<p><code>func('\\0')</code> invokes <code>func(char)</code>, </p>\n<p>while </p>\n<p><code>func(NULL)</code> invokes <code>func(integer_type)</code>.</p>\n<hr>\n<p>You can remove the confusion by using <a href=\"https://en.wikipedia.org/wiki/C%2B%2B11#Null_pointer_constant\" rel=\"nofollow noreferrer\">nullptr</a>, which is always a pointer type, displays no ambiguity while <em>assigning/comparing value or function overloading resolution</em>. </p>\n<pre><code>char a = nullptr; //error : cannot convert 'std::nullptr_t' to 'char' in initialization\nint x = nullptr;  //error : nullptr is a pointer not an integer\n</code></pre>\n<p>Note that, it is still compatible with NULL:</p>\n<pre><code>int *p=nullptr;\nif (p==NULL) //evaluates to true\n</code></pre>\n<p>Excerpt from C++ Programming Stroustrup 4th Edition book:</p>\n<blockquote>\n<p id=\"so_40395066_40395457_0\">In older code, 0 or NULL is typically used instead of nullptr\n  (\u00a77.2.2). However, using nullptr eliminates potential confusion\n  between integers (such as 0 or NULL) and pointers (such as nullptr).</p>\n</blockquote>\n<hr>\n</hr></hr>", "OwnerUserId": "1465553", "LastEditorUserId": "1465553", "LastEditDate": "2016-12-22T19:31:50.310", "Id": "40395457", "Score": "8", "CreationDate": "2016-11-03T06:53:23.383", "LastActivityDate": "2016-12-22T19:31:50.310"}});