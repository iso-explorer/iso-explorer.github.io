post_cb({"bq_ids": {"n4140": {"so_11856637_11859160_3": {"length": 60, "quality": 0.8823529411764706, "section_id": 300}, "so_11856637_11859160_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 242}}, "n3337": {"so_11856637_11859160_3": {"length": 60, "quality": 0.8823529411764706, "section_id": 291}, "so_11856637_11859160_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 234}}, "n4659": {"so_11856637_11859160_3": {"length": 56, "quality": 0.8235294117647058, "section_id": 307}, "so_11856637_11859160_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 249}}}, "11859160": {"Id": "11859160", "PostTypeId": "2", "Body": "<p>Resolving function calls in C++ proceeds in five phases:</p>\n<ol>\n<li><strong>name lookup</strong>: this finds two versions of  <code>operator*</code></li>\n<li><strong>template argument deduction</strong>: this will be applied to all functions found in step 1)</li>\n<li><strong>overload resolution</strong>: the best match will be selected</li>\n<li><strong>access control</strong>: can the best match in fact be invoked (i.e. is it not a private member)</li>\n<li><strong>virtuality</strong>: if virtual function are involved, a lookup in the vtable might be required</li>\n</ol>\n<p>First note that the return type is never ever being deduced. You simply <strong>cannot overload on return type</strong>. The template arguments to <code>operator*</code> are being deduced and then <strong>substituted</strong> into the return type template. </p>\n<p>So what happens at the call <code>a * b;</code>?  First, <strong><em>both</em></strong> versions of <code>operator*</code> have their arguments deduced. For the first overload, <code>T2</code> is deduced to being <code>A&lt;double&gt;</code>, and for the second overload <code>T2</code> resolves to <code>double</code>. If there multiple overloads, the Standard says:</p>\n<blockquote>\n<p id=\"so_11856637_11859160_0\"><strong>14.7.1 Implicit instantiation [temp.inst] clause 9</strong></p>\n<p id=\"so_11856637_11859160_1\">If a function template or a member function template specialization is\n  used in a way that involves overload resolution, a declaration of the\n  specialization is implicitly instantiated (14.8.3).</p>\n</blockquote>\n<p>So at the end of argument deduction when the set of candidate functions are being generated, (so before overload resolution) the template gets instantiated and you get an error because <code>rt</code> does not have a nested <code>type</code>. This is why the more specialized second template will not be selected: overload resolution does not take place. You might have expected that this substitution failure would not be an error. HOwever, the Standard says:</p>\n<blockquote>\n<p id=\"so_11856637_11859160_2\"><strong>14.8.2 Template argument deduction [temp.deduct] clause 8</strong></p>\n<p id=\"so_11856637_11859160_3\">If a substitution results in an invalid type or expression, type\n  deduction fails. An invalid type or expression is one that would be\n  ill-formed if written using the substituted arguments. \n  Only invalid types and expressions in the immediate context of the\n  function type and its template parameter types can result in a\n  deduction failure. [ Note: The evaluation of the substituted types and\n  expressions can result in side e\ufb00ects such as the instantiation of\n  class template specializations and/or function template\n  specializations, the generation of implicitly-de\ufb01ned functions, etc.\n  Such side e\ufb00ects are not in the \u201cimmediate context\u201d and can result in\n  the program being ill-formed. \u2014 end note ]</p>\n</blockquote>\n<p>In your original code, the <code>typename a_rt&lt;T,T2&gt;::type</code> return type is not an <strong>immediate context</strong>. Only during template instantiation does it get evaluated, and then the lack of the nested <code>type</code> in <code>rt</code> is an erorr. </p>\n<p>In your updated code <code>A&lt;typename rt&lt;T,T2&gt;::type&gt;</code> return type is an immediate context and the <strong>Substitution Failure is Not An Erorr</strong> (SFINAE) applies: the non-deduced function template is simply removed from the overload resolution set and the remaining one is being called. </p>\n<p>With your updated code, output will be: </p>\n<pre><code>&gt; A&lt;T2&gt;&amp; called     \n&gt; T2&amp; called\n</code></pre>\n", "LastEditorUserId": "819272", "LastActivityDate": "2012-08-08T09:19:04.933", "Score": "4", "CreationDate": "2012-08-08T06:53:41.990", "ParentId": "11856637", "CommentCount": "9", "OwnerUserId": "819272", "LastEditDate": "2012-08-08T09:19:04.933"}, "11856637": {"ViewCount": "411", "Body": "<p>I have been trying to implement a complex number class for fixed point types where the result type of the multiply operation will be a function of the input types.  I need to have functions where I can do multiply complex by complex and also complex by real number.</p>\n<p>This essentially is a simplified version of the code.  Where A is my complex type.</p>\n<pre><code>template&lt;typename T1, typename T2&gt; struct rt {};\n\ntemplate&lt;&gt; struct rt&lt;double, double&gt; { \n    typedef double type;\n};\n//forward declaration\ntemplate&lt;typename T&gt; struct A;\n\ntemplate&lt;typename T1, typename T2&gt;\nstruct a_rt {\n    typedef A&lt;typename rt&lt;T1,T2&gt;::type&gt; type;\n};\n\ntemplate &lt;typename T&gt;\nstruct A {\n    template&lt;typename T2&gt;\n    typename a_rt&lt;T,T2&gt;::type operator*(const T2&amp; val) const {\n        typename a_rt&lt;T,T2&gt;::type ret;\n        cout &lt;&lt; \"T2&amp; called\" &lt;&lt; endl;\n        return ret;\n    }\n    template&lt;typename T2&gt;\n    typename a_rt&lt;T,T2&gt;::type operator*(const A&lt;T2&gt;&amp; val) const {\n        typename a_rt&lt;T,T2&gt;::type ret;\n        cout &lt;&lt; \"A&lt;T2&gt;&amp; called\" &lt;&lt; endl;\n        return ret;\n    }\n};\n\nTEST(TmplClassFnOverload, Test) {\n    A&lt;double&gt; a;\n    A&lt;double&gt; b;\n    double c;\n    a * b;\n    a * c;\n}\n</code></pre>\n<p>The code fails to compile because the compiler is trying to instantiate the <code>a_rt</code> template with <code>double</code> and <code>A&lt;double&gt;</code>.  I don't know what is going on under the hood since I imagine the compiler should pick the more specialized <code>operator*(A&lt;double&gt;&amp;)</code> so <code>a_rt</code> will only be instantiated with <code>&lt;double, double&gt;</code> as arguments. </p>\n<p>Would you please explain to me why this would not work?\nAnd if this is a limitation, how should I work around this.</p>\n<p>Thanks a tonne!</p>\n<pre><code>unittest.cpp: In instantiation of 'a_rt&lt;double, A&lt;double&gt; &gt;':\nunittest.cpp:198:   instantiated from here \nunittest.cpp:174: error: no type named 'type' in 'struct rt&lt;double, A&lt;double&gt; &gt;' \n</code></pre>\n<p><strong>Update</strong></p>\n<p>The compiler appears to be happy with the following change.  There is some subtlety I'm missing here.  Appreciate someone who can walk me through what the compiler is doing in both cases.</p>\n<pre><code>    template&lt;typename T2&gt;\n    A&lt;typename rt&lt;T,T2&gt;::type&gt; operator*(const T2&amp; val) const {\n        A&lt;typename rt&lt;T,T2&gt;::type&gt; ret;\n        cout &lt;&lt; \"T2&amp; called\" &lt;&lt; endl;\n        return ret;\n    }\n    template&lt;typename T2&gt;\n    A&lt;typename rt&lt;T,T2&gt;::type&gt; operator*(const A&lt;T2&gt;&amp; val) const {\n        A&lt;typename rt&lt;T,T2&gt;::type&gt; ret;\n        cout &lt;&lt; \"A&lt;T2&gt;&amp; called\" &lt;&lt; endl;\n        return ret;\n    }\n</code></pre>\n", "AcceptedAnswerId": "11859160", "Title": "function resolution failed when return type is deduced from enclosed template class", "CreationDate": "2012-08-08T01:57:06.167", "Id": "11856637", "CommentCount": "2", "LastEditDate": "2012-08-08T08:23:11.183", "PostTypeId": "1", "LastEditorUserId": "819272", "LastActivityDate": "2012-08-08T09:19:04.933", "Score": "3", "OwnerUserId": "744029", "Tags": "<c++><function><templates><overloading><sfinae>", "AnswerCount": "2"}, "11858004": {"Id": "11858004", "PostTypeId": "2", "Body": "<p>Your forward declaration uses <strong>class</strong>:</p>\n<pre><code>template&lt;typename T&gt; class A;\n</code></pre>\n<p>But your definition uses <strong>struct</strong>:</p>\n<pre><code>template &lt;typename T&gt;\nstruct A {\n</code></pre>\n<p>Other than that, I can't see any problems...</p>\n", "LastActivityDate": "2012-08-08T05:10:56.710", "CommentCount": "4", "CreationDate": "2012-08-08T05:10:56.710", "ParentId": "11856637", "Score": "0", "OwnerUserId": "1441291"}});