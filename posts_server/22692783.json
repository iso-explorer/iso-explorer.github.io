post_cb({"22694959": {"ParentId": "22692783", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The closest the standard comes to specifying this is 17.6.5.8 <strong>[reentrancy]</strong>:</p>\n<blockquote>\n<p id=\"so_22692783_22694959_0\">1 - Except where explicitly specified in this standard, it is implementation-defined which functions in the Standard C ++ library may be recursively reentered.</p>\n</blockquote>\n<p>Unfortunately the specification of <code>call_once</code> doesn't say whether it is recursive (or cross-thread recursive), and the thread support library preamble doesn't say anything on this topic either.</p>\n<p>That said, the VC++ implementation is clearly suboptimal, especially as it's possible to write a userland version of <code>call_once</code> using <code>condition_variable</code>:</p>\n<pre><code>#include &lt;mutex&gt;\n#include &lt;condition_variable&gt;\n\nstruct once_flag {\n  enum { INIT, RUNNING, DONE } state = INIT;\n  std::mutex mut;\n  std::condition_variable cv;\n};\ntemplate&lt;typename Callable, typename... Args&gt;\nvoid call_once(once_flag &amp;flag, Callable &amp;&amp;f, Args &amp;&amp;...args)\n{\n  {\n    std::unique_lock&lt;std::mutex&gt; lock(flag.mut);\n    while (flag.state == flag.RUNNING) {\n      flag.cv.wait(lock);\n    }\n    if (flag.state == flag.DONE) {\n      return;\n    }\n    flag.state = flag.RUNNING;\n  }\n  try {\n    f(args...);\n    {\n      std::unique_lock&lt;std::mutex&gt; lock(flag.mut);\n      flag.state = flag.DONE;\n    }\n    flag.cv.notify_all();\n  }\n  catch (...) {\n    {\n      std::unique_lock&lt;std::mutex&gt; lock(flag.mut);\n      flag.state = flag.INIT;\n    }\n    flag.cv.notify_one();\n    throw;\n  }\n}\n</code></pre>\n<p>Note that this is a fine-grained implementation; it's also possible to write a coarse-grained implementation that uses a single pair of mutex and condition variable across all once flags, but then you need to ensure that you notify all the waiting threads on throwing an exception (for example, libc++ does this).</p>\n<p>For efficiency you could make <code>once_flag::state</code> an atomic and use double-checked locking; this is omitted here for conciseness.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2014-03-27T21:35:59.677", "Id": "22694959", "Score": "6", "CreationDate": "2014-03-27T17:29:26.100", "LastActivityDate": "2014-03-27T21:35:59.677"}, "22694793": {"ParentId": "22692783", "CommentCount": "0", "Body": "<p>Not an \"answer\" here, but at least confirmation that something seems wrong on the Visual Studio side vs. your usage pattern in general.  </p>\n<p>I compiled and ran this example on coliru.stacked-crooked.com and it seems to execute as expected, without any deadlock.</p>\n<p>Here's the compile line:</p>\n<pre><code>g++-4.8 -std=c++11 -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out\n</code></pre>\n<p>Here's the output:</p>\n<pre><code>Foo start\nHello World!\nFoo end\nFoo start\nHello World!\nFoo end\nFoo start\nHello World!\nFoo end\n</code></pre>\n<p>I tend to personally think there are problems with my own code before I go blaming a library implementation. </p>\n<p>I did see that there are some similar issues out there w.r.t. Visual Studio's call_once implementation:</p>\n<p><a href=\"https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;ved=0CDwQFjAC&amp;url=https://connect.microsoft.com/VisualStudio/feedback/details/811192/std-call-once-hangs&amp;ei=cVw0U-rZBor-2gXCh4HYDw&amp;usg=AFQjCNGDikvgq8YHVzWLC-BqjeOSN-Vm3Q&amp;sig2=7BtB2jH8DeTKEwzAOAf9lw&amp;bvm=bv.63808443,d.b2I&amp;cad=rja\" rel=\"nofollow\">https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;ved=0CDwQFjAC&amp;url=https%3A%2F%2Fconnect.microsoft.com%2FVisualStudio%2Ffeedback%2Fdetails%2F811192%2Fstd-call-once-hangs&amp;ei=cVw0U-rZBor-2gXCh4HYDw&amp;usg=AFQjCNGDikvgq8YHVzWLC-BqjeOSN-Vm3Q&amp;sig2=7BtB2jH8DeTKEwzAOAf9lw&amp;bvm=bv.63808443,d.b2I&amp;cad=rja</a></p>\n<p><a href=\"http://www.unknownerror.org/Problem/index/1100762158/why-does-this-c-static-singleton-never-stop/\" rel=\"nofollow\">http://www.unknownerror.org/Problem/index/1100762158/why-does-this-c-static-singleton-never-stop/</a></p>\n<p>I would be interested to know if this issue occurs in Debug or Release or both?</p>\n<p>The ISO standard does state that call_once is thread safe, after all!</p>\n", "OwnerUserId": "2041703", "PostTypeId": "2", "Id": "22694793", "Score": "0", "CreationDate": "2014-03-27T17:21:31.833", "LastActivityDate": "2014-03-27T17:21:31.833"}, "22692783": {"CommentCount": "3", "AcceptedAnswerId": "22694959", "PostTypeId": "1", "LastEditorUserId": "4850040", "CreationDate": "2014-03-27T15:52:44.687", "LastActivityDate": "2016-09-01T11:19:07.343", "LastEditDate": "2016-09-01T11:19:07.343", "ViewCount": "1749", "FavoriteCount": "1", "Title": "Is std::call_once reentrant and thread safe?", "Id": "22692783", "Score": "6", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/thread/call_once\" rel=\"nofollow\">std::call_once</a>  is thread safe, but is it re-entrant as well?</p>\n<p>My testing using VS2012 (Debug &amp; Release) has shown that calling <code>std::call_once</code> recursively from a single thread is okay, but if the calls are made on separate threads it will cause a deadlock. Is this a known limitation of <code>std::call_once</code>?</p>\n<pre><code>#include \"stdafx.h\"\n\n#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\n\nvoid Foo()\n{\n    std::cout &lt;&lt; \"Foo start\" &lt;&lt; std::endl;\n\n    std::once_flag flag;\n    std::call_once( flag, [](){\n        std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n    });\n\n    std::cout &lt;&lt; \"Foo end\" &lt;&lt; std::endl;\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    // Single threaded Works\n    {\n        std::once_flag fooFlag;\n        std::call_once( fooFlag, Foo);      \n    }\n\n    // Works\n    // Threaded version, join outside call_once\n    {\n        std::once_flag fooFlag;\n        std::thread t;\n        std::call_once( fooFlag, [&amp;t](){\n            t = std::thread(Foo);\n            std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n        }); \n        t.join();\n    }\n\n    // Dead locks\n    // Threaded version, join inside call_once\n    {\n        std::once_flag fooFlag;\n        std::call_once( fooFlag, [](){\n            auto t = std::thread(Foo);\n            t.join();\n        });     \n    }\n\n    return 0;\n}\n</code></pre>\n<p>It seems like <code>std:call_once</code> is locking a static mutex that doesn't get unlocked until the function exits. In the single-threaded case it works because on the second call that thread already has the lock. On the threaded version it will block until the first call exits.</p>\n<p>I also noticed that if you change the <code>std::once_flag</code> flag in the <code>Foo()</code> function to <code>static</code> that the deadlock will still occur. </p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "3469133", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_22692783_22694959_0": {"section_id": 6345, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_22692783_22694959_0": {"section_id": 6102, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_22692783_22694959_0": {"section_id": 7854, "quality": 0.8181818181818182, "length": 9}}}});