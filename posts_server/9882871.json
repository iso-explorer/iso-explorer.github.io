post_cb({"9882871": {"CommentCount": "1", "ViewCount": "596", "PostTypeId": "1", "LastEditorUserId": "1294391", "CreationDate": "2012-03-27T03:11:09.130", "LastActivityDate": "2012-03-27T13:08:49.657", "Title": "Overloaded function templates with reference parameters", "AcceptedAnswerId": "9883769", "LastEditDate": "2012-03-27T07:18:14.660", "Id": "9882871", "Score": "4", "Body": "<pre><code>template &lt;typename T&gt; void f(T&amp;) {}\ntemplate &lt;typename T&gt; void f(T&amp;&amp;) {}\nint main()\n{\n    int x;\n    f(x);   //ambiguous\n}\n</code></pre>\n<p>Why is this call ambiguous? The first template specialization is f<code>&lt;int&gt;</code>(int&amp;), and the second is f<code>&lt;int&amp;&gt;</code>(int&amp;). As the parameters are the same, the function template, which is more specialzed according to the partial ordering rules, is better. Then according to Standard 14.8.2.4/9  </p>\n<blockquote>\n<p id=\"so_9882871_9882871_0\">If, for a given type, deduction succeeds in both directions (i.e., the types are identical after the transformations above) and both P and A were reference types (before being replaced with the type referred to above):<br>\n  \u2014 if the type from the argument template was an lvalue reference and the type from the parameter template was not, the argument type is considered to be more specialized than the other; ...  </br></p>\n</blockquote>\n<p>The first template has T&amp; and the second has T&amp;&amp;, so the first should be more specialized. What is wrong here?</p>\n<hr>\n<p>Edit:\nThis code is tested in g++ 4.6.1 and VC++ 2010 Express, both give the ambiguous error.</p>\n</hr>", "Tags": "<c++><templates><c++11><overloading>", "OwnerUserId": "1294391", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_9882871_9882871_0": {"section_id": 328, "quality": 1.0, "length": 37}}, "n3337": {"so_9882871_9882871_0": {"section_id": 318, "quality": 1.0, "length": 37}}, "n4659": {"so_9882871_9882871_0": {"section_id": 336, "quality": 0.918918918918919, "length": 34}}}, "9883008": {"ParentId": "9882871", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><strong>Guideline</strong>:</p>\n<p>Do not overload:</p>\n<pre><code>template &lt;typename T&gt; void f(T&amp;) {}\ntemplate &lt;typename T&gt; void f(T&amp;&amp;) {}\n</code></pre>\n<p><strong>Reason</strong>:</p>\n<p>There is a special template deduction rule for the pattern:</p>\n<pre><code>template &lt;typename T&gt; void f(T&amp;&amp;) {}\n</code></pre>\n<p>This rule exists in order to enable so called \"perfect forwarding\".  It helps things like <code>bind</code> and <code>make_shared</code> forward their arguments perfectly, preserving both cv-qualifiers and \"value category\" (lvalue/rvalue-ness).</p>\n<p>This special rule says that when <code>f(T&amp;&amp;)</code> is called with an lvalue parameter (e.g. <code>int</code>), that T gets deduced as an lvalue reference (e.g. <code>int&amp;</code>) instead of <code>int</code>.  And an rvalue reference to lvalue reference to int collapses down to just lvalue reference to int.  I.e.</p>\n<pre><code>f(x)\n</code></pre>\n<p>calls</p>\n<pre><code>f&lt;int&amp;&gt;(int&amp; &amp;&amp; x);\n</code></pre>\n<p>which simplifies to:</p>\n<pre><code>f&lt;int&amp;&gt;(int&amp; x);\n</code></pre>\n<p><em>Edit</em></p>\n<p><del>This is not more or less specialized than <code>f&lt;int&gt;(int&amp;)</code>.</del></p>\n<p>Thanks to Johannes Schaub for the correction (see comments).</p>\n<p><strong>Solution</strong>:</p>\n<p>You can do whatever you want with the single function:</p>\n<pre><code>template &lt;typename T&gt; void f(T&amp;&amp;) {}\n</code></pre>\n<p>If <code>T</code> deduces as an lvalue reference, do whatever you wanted to do in your first overload, otherwise do whatever you wanted to do in your second overload:</p>\n<pre><code>template &lt;class T&gt; void f_imp(T&amp;, std::true_type) {std::cout &lt;&lt; \"lvalue\\n\";}\ntemplate &lt;class T&gt; void f_imp(T&amp;&amp;, std::false_type) {std::cout &lt;&lt; \"rvalue\\n\";}\n\ntemplate &lt;typename T&gt; void f(T&amp;&amp; x)\n{\n     f_imp(std::forward&lt;T&gt;(x), std::is_lvalue_reference&lt;T&gt;());\n}\n</code></pre>\n<p>And use <code>std::forward</code> to perfectly forward <code>x</code> to the implementation-detail function.</p>\n", "OwnerUserId": "576911", "LastEditorUserId": "576911", "LastEditDate": "2012-03-27T13:08:49.657", "Id": "9883008", "Score": "4", "CreationDate": "2012-03-27T03:28:48.737", "LastActivityDate": "2012-03-27T13:08:49.657"}, "9883769": {"ParentId": "9882871", "CommentCount": "0", "Body": "<p>Your interpretation of the standard appears to be correct.</p>\n<pre><code>template &lt;typename T&gt; void f(T&amp;) {}  // #1\ntemplate &lt;typename T&gt; void f(T&amp;&amp;) {} // #2\n</code></pre>\n<p>In #1, <code>T</code> is successfully deduced as <code>int</code>, and in #2, <code>T</code> is successfully deduced as <code>int&amp;</code>, so partial ordering is performed to select the function to call. During partial ordering for the call <code>f(x)</code>, the types of the first (only, in this case) argument will be ordered (<em>[temp.deduct.partial]/3</em> bullet 1). During deduction in both directions, type <code>P</code> will be <code>T</code>, and type <code>A</code> will be a synthesized type representing <code>T</code> (<em>[temp.deduct.partial]/5</em>), so deduction succeeds in both directions.</p>\n<p>As you observed, <em>[temp.deduct.partial]/9</em> then applies, and says that #1's first argument is more specialized. Therefore, by <em>[temp.deduct.partial]/10</em>, #1 is selected as the most-specialized template and its specialization is the result of overload resolution.</p>\n<p>You didn't mention which compiler you are using. I assume it's g++ -- this appears to be a bug in that compiler (I've tested versions between 4.4.3 and 4.7, and they all reject this code). clang accepts your code, and calls the <code>f(T &amp;)</code> overload as you expected.</p>\n", "OwnerUserId": "1041090", "PostTypeId": "2", "Id": "9883769", "Score": "4", "CreationDate": "2012-03-27T05:23:01.847", "LastActivityDate": "2012-03-27T05:23:01.847"}});