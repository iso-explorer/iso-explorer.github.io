post_cb({"24088197": {"ParentId": "24088148", "PostTypeId": "2", "CommentCount": "6", "Body": "<h3>What you are asking for is illegal</h3>\n<p>To legally overload an operator at least one of the operands involved has to be a <em>user-defined type</em>. Since neither <code>char*</code> nor <code>int</code> is <em>user-defined</em>, what you are trying to accomplish isn't possible.</p>\n<p>This, what you are trying to do, is intentionally, and explicitly, disallowed in the standard. Don't you think it would be weird if suddenly <code>1+3 = 42</code> because someone \"clever\" have defined an overload for <code>operator+(int, int)</code>?</p>\n<hr>\n<h3>What does the Standard say? (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">n3337</a>)</h3>\n<blockquote>\n<p id=\"so_24088148_24088197_0\"><code>13.3.1.2p1-2</code> <strong>Operators in expressions</strong> <code>[over.match.oper]</code></p>\n<blockquote>\n<p id=\"so_24088148_24088197_3\">If no operand of an operator in an expression has a type that is a class or an enumeration, the operator is assumed to be a built-in operator and interpreted according to Clause 5.</p>\n<p id=\"so_24088148_24088197_4\">If either operand has a type that is a class or an enumeration, a user-defined operator function might be declared that implements this operator or a user-defined conversion can be neccessary to convert the operand to a type that is appropriate for a built-in operator.</p>\n</blockquote>\n</blockquote>\n<p>( <strong>Note</strong>: The wording is the same in both <em>C++03</em>, and the next revision of the standard; <em>C++14</em> )</p>\n</hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2014-06-06T18:46:37.513", "Id": "24088197", "Score": "9", "CreationDate": "2014-06-06T18:11:28.507", "LastActivityDate": "2014-06-06T18:46:37.513"}, "24088148": {"CommentCount": "12", "ViewCount": "1332", "PostTypeId": "1", "LastEditorUserId": "2672165", "CreationDate": "2014-06-06T18:08:28.727", "LastActivityDate": "2014-06-06T18:46:37.513", "Title": "How to overload operator + for const char* and int", "AcceptedAnswerId": "24088197", "LastEditDate": "2014-06-06T18:12:48.687", "Id": "24088148", "Score": "0", "Body": "<p>I know this is silly and ugly, but I'm migrating some code automatically. My source language allows implicit conversion between strings and ints, and for example this is allowed:</p>\n<pre><code>var = \"hello \" + 2\nprint(var) # prints \"hello 2\"\n</code></pre>\n<p>How can I in C++ overload the + operator for <code>const char*</code> and <code>int</code>? I'm getting the error:</p>\n<blockquote>\n<p id=\"so_24088148_24088148_0\">error: \u2018std::string operator+(char* const&amp;, int)\u2019 must have an\n  argument of class or enumerated type</p>\n</blockquote>\n", "Tags": "<c++><c++11><vb6-migration>", "OwnerUserId": "209629", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24088148_24088197_3": {"section_id": 582, "quality": 1.0, "length": 13}, "so_24088148_24088197_4": {"section_id": 583, "quality": 0.9545454545454546, "length": 21}, "so_24088148_24088197_1": {"section_id": 582, "quality": 1.0, "length": 13}, "so_24088148_24088197_2": {"section_id": 583, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_24088148_24088197_3": {"section_id": 572, "quality": 1.0, "length": 13}, "so_24088148_24088197_4": {"section_id": 573, "quality": 0.9545454545454546, "length": 21}, "so_24088148_24088197_1": {"section_id": 572, "quality": 1.0, "length": 13}, "so_24088148_24088197_2": {"section_id": 573, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_24088148_24088197_3": {"section_id": 605, "quality": 1.0, "length": 13}, "so_24088148_24088197_4": {"section_id": 606, "quality": 0.9545454545454546, "length": 21}, "so_24088148_24088197_1": {"section_id": 605, "quality": 1.0, "length": 13}, "so_24088148_24088197_2": {"section_id": 606, "quality": 0.9545454545454546, "length": 21}}}});