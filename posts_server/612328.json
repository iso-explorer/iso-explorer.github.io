post_cb({"612328": {"ViewCount": "382418", "Body": "<p>In C++, is there any difference between:</p>\n<pre><code>struct Foo { ... };\n</code></pre>\n<p>and </p>\n<pre><code>typedef struct { ... } Foo;\n</code></pre>\n", "AcceptedAnswerId": "612350", "Title": "Difference between 'struct' and 'typedef struct' in C++?", "CreationDate": "2009-03-04T20:41:12.047", "Id": "612328", "CommentCount": "2", "FavoriteCount": "368", "PostTypeId": "1", "LastActivityDate": "2017-04-08T03:06:14.860", "Score": "623", "OwnerUserId": "47154", "Tags": "<c++><struct><typedef>", "AnswerCount": "8"}, "612350": {"Body": "<p>In C++, there is only a subtle difference.  It's a holdover from C, in which it makes a difference.</p>\n<p>The C language standard (<a href=\"http://port70.net/~nsz/c/c89/c89-draft.txt\" rel=\"noreferrer\">C89 \u00a73.1.2.3</a>, <a href=\"http://port70.net/~nsz/c/c99/n1256.html#6.2.3\" rel=\"noreferrer\">C99 \u00a76.2.3</a>, and <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.2.3\" rel=\"noreferrer\">C11 \u00a76.2.3</a>) mandates separate namespaces for different categories of identifiers, including <em>tag identifiers</em> (for <code>struct</code>/<code>union</code>/<code>enum</code>) and <em>ordinary identifiers</em> (for <code>typedef</code> and other identifiers). </p>\n<p>If you just said:</p>\n<pre><code>struct Foo { ... };\nFoo x;\n</code></pre>\n<p>you would get a compiler error, because <code>Foo</code> is only defined in the tag namespace. </p>\n<p>You'd have to declare it as:</p>\n<pre><code>struct Foo x;\n</code></pre>\n<p>Any time you want to refer to a <code>Foo</code>, you'd always have to call it a <code>struct Foo</code>.  This gets annoying fast, so you can add a <code>typedef</code>:</p>\n<pre><code>struct Foo { ... };\ntypedef struct Foo Foo;\n</code></pre>\n<p>Now both <code>struct Foo</code> (in the tag namespace) and just plain <code>Foo</code> (in the ordinary identifier namespace) both refer to the same thing, and you can freely declare objects of type <code>Foo</code> without the struct keyword.</p>\n<hr>\n<p>The construct:</p>\n<pre><code>typedef struct Foo { ... } Foo;\n</code></pre>\n<p>is just an abbreviation for the declaration and <code>typedef</code>.</p>\n<hr>\n<p>Finally,</p>\n<pre><code>typedef struct { ... } Foo;\n</code></pre>\n<p>declares an anonymous structure and creates a <code>typedef</code> for it.  Thus, with this construct, it doesn't have a name in the tag namespace, only a name in the typedef namespace.  This means it also cannot be forward-declared.  <em>If you want to make a forward declaration, you have to give it a name in the tag namespace</em>.</p>\n<hr>\n<p>In C++, all <code>struct</code>/<code>union</code>/<code>enum</code>/class declarations act like they are implicitly <code>typedef</code>'ed, as long as the name is not hidden by another declaration with the same name.  See <a href=\"https://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c/612476#612476\">Michael Burr's answer</a> for the full details.</p>\n</hr></hr></hr>", "CreationDate": "2009-03-04T20:45:36.950", "ParentId": "612328", "CommentCount": "16", "LastEditDate": "2017-05-23T11:55:00.137", "PostTypeId": "2", "LastEditorDisplayName": "Adam Rosenfield", "LastActivityDate": "2016-12-28T20:53:13.470", "LastEditorUserId": "-1", "Id": "612350", "OwnerDisplayName": "Adam Rosenfield", "Score": "957", "OwnerUserId": "9530"}, "612363": {"Body": "<p>There <strong>is</strong> a difference, but subtle. Look at it this way: <code>struct Foo</code> introduces a new type. The second one creates an alias called Foo (and not a new type) for an unnamed <code>struct</code> type.</p>\n<blockquote>\n<p id=\"so_612328_612363_0\"><strong>7.1.3 The typedef specifier</strong></p>\n<p id=\"so_612328_612363_1\">1 [...]</p>\n<p id=\"so_612328_612363_2\">A name declared with the typedef specifier becomes a typedef-name. Within the scope of its declaration, a\n  typedef-name is syntactically equivalent to a keyword and names the type associated with the identifier in\n  the way described in Clause 8. A typedef-name is thus a synonym for another type. A typedef-name <em><strong>does not introduce a new type</strong></em> the way a class declaration (9.1) or enum declaration does.</p>\n<p id=\"so_612328_612363_3\">8 If the typedef declaration defines an unnamed class (or enum), the first typedef-name declared by the declaration\n  to be that class type (or enum type) is used to denote the class type (or enum type) for linkage\n  purposes only (3.5). [ Example:</p>\n</blockquote>\n<pre><code>typedef struct { } *ps, S; // S is the class name for linkage purposes\n</code></pre>\n<p>So, a typedef <strong>always</strong> is used as an placeholder/synonym for another type.</p>\n", "CreationDate": "2009-03-04T20:49:16.943", "ParentId": "612328", "CommentCount": "0", "LastEditDate": "2009-03-04T22:01:13.557", "PostTypeId": "2", "LastEditorDisplayName": "dirkgently", "LastActivityDate": "2009-03-04T22:01:13.557", "LastEditorUserId": "66692", "Id": "612363", "OwnerDisplayName": "dirkgently", "Score": "26", "OwnerUserId": "66692"}, "36550088": {"Id": "36550088", "PostTypeId": "2", "Body": "<p>An important difference between a 'typedef struct' and a 'struct' in C++ is that inline member initialisation in 'typedef structs' will not work.</p>\n<pre><code>// the 'x' in this struct will NOT be initialised to zero\ntypedef struct { int x = 0; } Foo;\n\n// the 'x' in this struct WILL be initialised to zero\nstruct Foo { int x = 0; };\n</code></pre>\n", "LastActivityDate": "2016-04-11T13:26:25.633", "CommentCount": "2", "CreationDate": "2016-04-11T13:26:25.633", "ParentId": "612328", "Score": "0", "OwnerUserId": "2796283"}, "612389": {"Body": "<p>One more important difference: <code>typedef</code>s cannot be forward declared. So for the <code>typedef</code> option you must <code>#include</code> the file containing the <code>typedef</code>, meaning everything that <code>#include</code>s your <code>.h</code> also includes that file whether it directly needs it or not, and so on. It can definitely impact your build times on larger projects.</p>\n<p>Without the <code>typedef</code>, in some cases you can just add a forward declaration of <code>struct Foo;</code> at the top of your <code>.h</code> file, and only <code>#include</code> the struct definition in your <code>.cpp</code> file.</p>\n", "CreationDate": "2009-03-04T20:54:25.153", "ParentId": "612328", "CommentCount": "4", "LastEditDate": "2013-12-19T18:21:35.097", "PostTypeId": "2", "OwnerDisplayName": "Joe", "LastEditorUserId": "12711", "LastActivityDate": "2013-12-19T18:21:35.097", "Id": "612389", "Score": "52", "OwnerUserId": "12567"}, "bq_ids": {"n4140": {"so_612328_612363_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 5415}, "so_612328_612363_2": {"length": 37, "quality": 1.0, "section_id": 5407}}, "n3337": {"so_612328_612363_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 5210}, "so_612328_612363_2": {"length": 37, "quality": 1.0, "section_id": 5202}}, "n4659": {"so_612328_612363_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 6837}, "so_612328_612363_2": {"length": 37, "quality": 1.0, "section_id": 6829}}}, "43289714": {"Id": "43289714", "PostTypeId": "2", "Body": "<p>Struct is to create a data type.\nThe typedef is to set a nickname for a data type.</p>\n", "LastActivityDate": "2017-04-08T03:06:14.860", "CommentCount": "1", "CreationDate": "2017-04-08T03:06:14.860", "ParentId": "612328", "Score": "0", "OwnerUserId": "6123431"}, "18054549": {"Id": "18054549", "PostTypeId": "2", "Body": "<p>You can't use forward declaration with the typedef struct.</p>\n<p>The struct itself is an anonymous type, so you don't have an actual name to forward declare.</p>\n<pre><code>typedef struct{\n    int one;\n    int two;\n}myStruct;\n</code></pre>\n<p>A forward declaration like this wont work:</p>\n<pre><code>struct myStruct; //forward declaration fails\n\nvoid blah(myStruct* pStruct);\n\n//error C2371: 'myStruct' : redefinition; different basic types\n</code></pre>\n", "LastActivityDate": "2013-08-05T09:18:39.607", "CommentCount": "6", "CreationDate": "2013-08-05T09:18:39.607", "ParentId": "612328", "Score": "10", "OwnerUserId": "536086"}, "612476": {"Body": "<p>In <a href=\"http://drdobbs.com/article/print?articleId=184403396\" rel=\"noreferrer\">this DDJ article</a>, Dan Saks explains one small area where bugs can creep through if you do not typedef your structs (and classes!):</p>\n<blockquote>\n<p id=\"so_612328_612476_0\">If you want, you can imagine that C++\n  generates a typedef for every tag\n  name, such as</p>\n<pre><code>typedef class string string;\n</code></pre>\n<p id=\"so_612328_612476_1\">Unfortunately, this is not entirely\n  accurate. I wish it were that simple,\n  but it's not. C++ can't generate such\n  typedefs for structs, unions, or enums\n  without introducing incompatibilities\n  with C.</p>\n<p id=\"so_612328_612476_2\">For example, suppose a C program\n  declares both a function and a struct\n  named status:</p>\n<pre><code>int status(); struct status;\n</code></pre>\n<p id=\"so_612328_612476_3\">Again, this may be bad practice, but\n  it is C. In this program, status (by\n  itself) refers to the function; struct\n  status refers to the type.</p>\n<p id=\"so_612328_612476_4\">If C++ did automatically generate\n  typedefs for tags, then when you\n  compiled this program as C++, the\n  compiler would generate:</p>\n<pre><code>typedef struct status status;\n</code></pre>\n<p id=\"so_612328_612476_5\">Unfortunately, this type name would\n  conflict with the function name, and\n  the program would not compile. That's\n  why C++ can't simply generate a\n  typedef for each tag.</p>\n<p id=\"so_612328_612476_6\">In C++, tags act just like typedef\n  names, except that a program can\n  declare an object, function, or\n  enumerator with the same name and the\n  same scope as a tag. In that case, the\n  object, function, or enumerator name\n  hides the tag name. The program can\n  refer to the tag name only by using\n  the keyword class, struct, union, or\n  enum (as appropriate) in front of the\n  tag name. A type name consisting of\n  one of these keywords followed by a\n  tag is an elaborated-type-specifier.\n  For instance, struct status and enum\n  month are elaborated-type-specifiers. </p>\n<p id=\"so_612328_612476_7\">Thus, a C program that contains both:</p>\n<pre><code>int status(); struct status;\n</code></pre>\n<p id=\"so_612328_612476_8\">behaves the same when compiled as C++.\n  The name status alone refers to the\n  function. The program can refer to the\n  type only by using the\n  elaborated-type-specifier struct\n  status.</p>\n<p id=\"so_612328_612476_9\">So how does this allow bugs to creep\n  into programs? Consider the program in\n  <a href=\"http://drdobbs.com/cpp/184403396?pgno=1\" rel=\"noreferrer\">Listing 1</a>. This program defines a\n  class foo with a default constructor,\n  and a conversion operator that\n  converts a foo object to char const *.\n  The expression</p>\n<pre><code>p = foo();\n</code></pre>\n<p id=\"so_612328_612476_10\">in main should construct a foo object\n  and apply the conversion operator. The\n  subsequent output statement</p>\n<pre><code>cout &lt;&lt; p &lt;&lt; '\\n';\n</code></pre>\n<p id=\"so_612328_612476_11\">should display class foo, but it\n  doesn't. It displays function foo.</p>\n<p id=\"so_612328_612476_12\">This surprising result occurs because\n  the program includes header lib.h\n  shown in <a href=\"http://drdobbs.com/cpp/184403396?pgno=2\" rel=\"noreferrer\">Listing 2</a>. This header\n  defines a function also named foo. The\n  function name foo hides the class name\n  foo, so the reference to foo in main\n  refers to the function, not the class.\n  main can refer to the class only by\n  using an elaborated-type-specifier, as\n  in</p>\n<pre><code>p = class foo();\n</code></pre>\n<p id=\"so_612328_612476_13\">The way to avoid such confusion\n  throughout the program is to add the\n  following typedef for the class name\n  foo:</p>\n<pre><code>typedef class foo foo;\n</code></pre>\n<p id=\"so_612328_612476_14\">immediately before or after the class\n  definition. This typedef causes a\n  conflict between the type name foo and\n  the function name foo (from the\n  library) that will trigger a\n  compile-time error.</p>\n<p id=\"so_612328_612476_15\">I know of no one who actually writes\n  these typedefs as a matter of course.\n  It requires a lot of discipline. Since\n  the incidence of errors such as the\n  one in <a href=\"http://drdobbs.com/cpp/184403396?pgno=1\" rel=\"noreferrer\">Listing 1</a> is probably pretty\n  small, you many never run afoul of\n  this problem. But if an error in your\n  software might cause bodily injury,\n  then you should write the typedefs no\n  matter how unlikely the error. </p>\n<p id=\"so_612328_612476_16\">I can't imagine why anyone would ever\n  want to hide a class name with a\n  function or object name in the same\n  scope as the class. The hiding rules\n  in C were a mistake, and they should\n  not have been extended to classes in\n  C++. Indeed, you can correct the\n  mistake, but it requires extra\n  programming discipline and effort that\n  should not be necessary.</p>\n</blockquote>\n", "CreationDate": "2009-03-04T21:19:37.243", "ParentId": "612328", "CommentCount": "3", "LastEditDate": "2013-12-19T18:22:10.383", "PostTypeId": "2", "OwnerDisplayName": "Michael Burr", "LastEditorUserId": "12711", "LastActivityDate": "2013-12-19T18:22:10.383", "Id": "612476", "Score": "189", "OwnerUserId": "12711"}, "612345": {"Id": "612345", "PostTypeId": "2", "Body": "<p>There is no difference in C++, but I believe in C it would allow you to declare instances of the struct Foo without explicitly doing:</p>\n<pre><code>struct Foo bar;\n</code></pre>\n", "OwnerDisplayName": "kitchen", "LastActivityDate": "2009-03-04T20:44:20.310", "Score": "-2", "CreationDate": "2009-03-04T20:44:20.310", "ParentId": "612328", "CommentCount": "1", "OwnerUserId": "59844"}});