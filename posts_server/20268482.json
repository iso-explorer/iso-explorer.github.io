post_cb({"20268482": {"Body": "<p>I'm trying to make the following code work:</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;functional&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nclass Foo {\npublic:\n    Foo(): m_str(\"foo\") { }\n\n    void f1(string s1, string s2, unique_ptr&lt;Foo&gt; p)\n        {\n            printf(\"1: %s %s %s\\n\", s1.c_str(), s2.c_str(), p-&gt;str());\n        }\n\n    void f2(string s1, string s2, Foo* p)\n        {\n            printf(\"2: %s %s %s\\n\", s1.c_str(), s2.c_str(), p-&gt;str());\n        }\n\n    const char* str() const { return m_str.c_str(); }\n\nprivate:\n    string m_str;\n};\n\nint main()\n{\n    string arg1 = \"arg1\";\n    string arg2 = \"arg2\";\n    Foo s;\n    unique_ptr&lt;Foo&gt; ptr(new Foo);\n\n\n    //function&lt;void()&gt; f(bind(&amp;Foo::f1, &amp;s, arg1, arg2, std::move(ptr)));\n    function&lt;void()&gt; f(bind(&amp;Foo::f2, &amp;s, arg1, arg2, ptr.release()));\n\n    f();\n}\n</code></pre>\n<p>Calling f() bound to Foo::f2(last parameter is a raw pointer) works fine, but binding it to Foo::f1 causes compilation error:</p>\n<pre><code>test.cpp: In function \u2018int main()\u2019:\ntest.cpp:36:70: error: no matching function for call to \u2018std::function&lt;void()&gt;::function(std::_Bind_helper&lt;false, void (Foo::*)(std::basic_string&lt;char&gt;, std::basic_string&lt;char&gt;, std::unique_ptr&lt;Foo&gt;), Foo*, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;, std::unique_ptr&lt;Foo, std::default_delete&lt;Foo&gt; &gt; &gt;::type)\u2019\n     function&lt;void()&gt; f(bind(&amp;Foo::f1, &amp;s, arg1, arg2, std::move(ptr)));\n                                                                      ^\ntest.cpp:36:70: note: candidates are:\nIn file included from test.cpp:2:0:\n/usr/include/c++/4.8.2/functional:2251:2: note: template&lt;class _Functor, class&gt; std::function&lt;_Res(_ArgTypes ...)&gt;::function(_Functor)\n  function(_Functor);\n  ^\n/usr/include/c++/4.8.2/functional:2251:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8.2/functional:2226:7: note: std::function&lt;_Res(_ArgTypes ...)&gt;::function(std::function&lt;_Res(_ArgTypes ...)&gt;&amp;&amp;) [with _Res = void; _ArgTypes = {}]\n       function(function&amp;&amp; __x) : _Function_base()\n       ^\n/usr/include/c++/4.8.2/functional:2226:7: note:   no known conversion for argument 1 from \u2018std::_Bind_helper&lt;false, void (Foo::*)(std::basic_string&lt;char&gt;, std::basic_string&lt;char&gt;, std::unique_ptr&lt;Foo&gt;), Foo*, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;, std::unique_ptr&lt;Foo, std::default_delete&lt;Foo&gt; &gt; &gt;::type {aka std::_Bind&lt;std::_Mem_fn&lt;void (Foo::*)(std::basic_string&lt;char&gt;, std::basic_string&lt;char&gt;, std::unique_ptr&lt;Foo&gt;)&gt;(Foo*, std::basic_string&lt;char&gt;, std::basic_string&lt;char&gt;, std::unique_ptr&lt;Foo&gt;)&gt;}\u2019 to \u2018std::function&lt;void()&gt;&amp;&amp;\u2019\n/usr/include/c++/4.8.2/functional:2429:5: note: std::function&lt;_Res(_ArgTypes ...)&gt;::function(const std::function&lt;_Res(_ArgTypes ...)&gt;&amp;) [with _Res = void; _ArgTypes = {}]\n     function&lt;_Res(_ArgTypes...)&gt;::\n     ^\n/usr/include/c++/4.8.2/functional:2429:5: note:   no known conversion for argument 1 from \u2018std::_Bind_helper&lt;false, void (Foo::*)(std::basic_string&lt;char&gt;, std::basic_string&lt;char&gt;, std::unique_ptr&lt;Foo&gt;), Foo*, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;, std::unique_ptr&lt;Foo, std::default_delete&lt;Foo&gt; &gt; &gt;::type {aka std::_Bind&lt;std::_Mem_fn&lt;void (Foo::*)(std::basic_string&lt;char&gt;, std::basic_string&lt;char&gt;, std::unique_ptr&lt;Foo&gt;)&gt;(Foo*, std::basic_string&lt;char&gt;, std::basic_string&lt;char&gt;, std::unique_ptr&lt;Foo&gt;)&gt;}\u2019 to \u2018const std::function&lt;void()&gt;&amp;\u2019\n/usr/include/c++/4.8.2/functional:2206:7: note: std::function&lt;_Res(_ArgTypes ...)&gt;::function(std::nullptr_t) [with _Res = void; _ArgTypes = {}; std::nullptr_t = std::nullptr_t]\n       function(nullptr_t) noexcept\n       ^\n/usr/include/c++/4.8.2/functional:2206:7: note:   no known conversion for argument 1 from \u2018std::_Bind_helper&lt;false, void (Foo::*)(std::basic_string&lt;char&gt;, std::basic_string&lt;char&gt;, std::unique_ptr&lt;Foo&gt;), Foo*, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;, std::unique_ptr&lt;Foo, std::default_delete&lt;Foo&gt; &gt; &gt;::type {aka std::_Bind&lt;std::_Mem_fn&lt;void (Foo::*)(std::basic_string&lt;char&gt;, std::basic_string&lt;char&gt;, std::unique_ptr&lt;Foo&gt;)&gt;(Foo*, std::basic_string&lt;char&gt;, std::basic_string&lt;char&gt;, std::unique_ptr&lt;Foo&gt;)&gt;}\u2019 to \u2018std::nullptr_t\u2019\n/usr/include/c++/4.8.2/functional:2199:7: note: std::function&lt;_Res(_ArgTypes ...)&gt;::function() [with _Res = void; _ArgTypes = {}]\n       function() noexcept\n       ^\n/usr/include/c++/4.8.2/functional:2199:7: note:   candidate expects 0 arguments, 1 provided\n</code></pre>\n<p>What am I doing wrong?</p>\n<p>I'm using gcc 4.8.2 and -std=c++0x(-std=c++11 fails too) flags.</p>\n<p>Thanks</p>\n", "CreationDate": "2013-11-28T14:21:14.173", "Score": "7", "CommentCount": "4", "OwnerUserId": "338331", "Title": "Binding functions with unique_ptr arguments to std::function<void()>", "LastActivityDate": "2016-09-28T08:08:36.857", "PostTypeId": "1", "Tags": "<c++><c++11>", "AnswerCount": "3", "FavoriteCount": "1", "Id": "20268482", "ViewCount": "5751"}, "38681611": {"PostTypeId": "2", "ParentId": "20268482", "Body": "<p>1) The following code won't compile</p>\n<pre><code> function&lt;void()&gt; f(bind(&amp;Foo::f1, &amp;s, arg1, arg2, std::move(ptr)));\n // just define f, not even call it\n</code></pre>\n<p>because <code>function</code> requires the callable object is copy-constructible but when <code>bind</code> takes a non-copyable argument like <code>unique_ptr</code> the returned functor will be non-copyable, as mentioned in other answers.</p>\n<p>2) So just don't use <code>function</code> for <code>bind</code>. However the following code won't compile either</p>\n<pre><code> auto f(bind(&amp;Foo::f1, &amp;s, arg1, arg2, std::move(ptr))); // a\n f();                                                    // b\n</code></pre>\n<p>because at step (a) <code>bind</code> stores what you give to it as an lvalue (except for <code>reference_wrapper</code>), and passes it to the internal functor at step (b). Therefore it requires the bound arguments are copyable for those parameters are passed by value, not references.</p>\n<p>3) Then try using the raw pointer. However the following code won't compile either</p>\n<pre><code> auto f(bind(&amp;Foo::f1, &amp;s, arg1, arg2, ptr.release()));\n f();\n</code></pre>\n<p>A similar reason like (2), the functor stores an <code>int*</code>, and try to convert it to the parameter type <code>unique_ptr&lt;int&gt;</code> when called. But the constructor <code>unique_ptr(pointer p)</code> is <code>explicit</code>.</p>\n<hr>\n<p>To compile it, you need a function like this</p>\n<pre><code>void f3(string s1, string s2, unique_ptr&lt;Foo&gt;&amp; p)\n//                                           ^ use reference; add const if you need\n{\n    printf(\"3: %s %s %s\\n\", s1.c_str(), s2.c_str(), p-&gt;str());\n}\n\nauto f(bind(&amp;Foo::f3, &amp;s, arg1, arg2, std::move(ptr)));\nf();\n</code></pre>\n<p>Note that <code>f</code> could be called several times, and the parameters <code>p</code> reference the same <code>unique_ptr</code> that is stored in the returned object of <code>bind</code>.</p>\n</hr>", "LastEditorUserId": "555515", "LastActivityDate": "2016-09-28T08:08:36.857", "LastEditDate": "2016-09-28T08:08:36.857", "CommentCount": "0", "Id": "38681611", "OwnerUserId": "555515", "Score": "1", "CreationDate": "2016-07-31T07:03:40.530"}, "24484879": {"PostTypeId": "2", "ParentId": "20268482", "Body": "<p>The issues with bind described in the other answers (as of this writing) are not what the compiler is complaining about in the question. The problem is  that <code>std::function</code> must be CopyConstructible, which requires its argument (which will be stored by the function) also be CopyConstructible. </p>\n<p>From the standard [20.9.11.2 Class template function]</p>\n<pre><code>template&lt;class F&gt; function(F f); \ntemplate &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);\n</code></pre>\n<blockquote>\n<p id=\"so_20268482_24484879_0\">Requires: F shall be CopyConstructible. f shall be Callable (20.9.11.2) for argument types ArgTypes and return type R . The copy constructor and destructor of A shall not throw exceptions...</p>\n</blockquote>\n<p>Consider this example that doesn't even include bind in it:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nstruct NonCopyableFunctor {\n  NonCopyableFunctor(){}\n  NonCopyableFunctor(const NonCopyableFunctor &amp;) = delete;\n  NonCopyableFunctor(NonCopyableFunctor &amp;&amp;){}\n  void operator()(){}\n};\n\nint main() \n{\n  NonCopyableFunctor fun;\n  function&lt;void()&gt; vfun(move(fun)); // even though I move here,\n  // it still complains about a copy going on elsewhere.\n}\n</code></pre>\n<p>Here's the output from clang:</p>\n<pre><code>[orm@localhost ~]$ clang++ -std=c++11 bound_unique.cc \nIn file included from bound_unique.cc:1:\n/usr/bin/../lib/gcc/x86_64-redhat-linux/4.8.2/../../../../include/c++/4.8.2/functional:1911:10: error: call to deleted constructor of 'NonCopyableFunctor'\n            new _Functor(*__source._M_access&lt;_Functor*&gt;());\n                ^        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/bin/../lib/gcc/x86_64-redhat-linux/4.8.2/../../../../include/c++/4.8.2/functional:1946:8: note: in instantiation of member function\n      'std::_Function_base::_Base_manager&lt;NonCopyableFunctor&gt;::_M_clone' requested here\n              _M_clone(__dest, __source, _Local_storage());\n              ^\n/usr/bin/../lib/gcc/x86_64-redhat-linux/4.8.2/../../../../include/c++/4.8.2/functional:2453:33: note: in instantiation of member function\n      'std::_Function_base::_Base_manager&lt;NonCopyableFunctor&gt;::_M_manager' requested here\n            _M_manager = &amp;_My_handler::_M_manager;\n                                       ^\nbound_unique.cc:16:20: note: in instantiation of function template specialization 'std::function&lt;void ()&gt;::function&lt;NonCopyableFunctor, void&gt;' requested here\n  function&lt;void()&gt; vfun(move(fun));\n                   ^\nbound_unique.cc:8:3: note: function has been explicitly marked deleted here\n  NonCopyableFunctor(const NonCopyableFunctor &amp;) = delete;\n  ^\n1 error generated.\n</code></pre>\n<p>Note that if you bind a unique_ptr, the resulting bind object will be non-copyable. Bind will still compile anyway.</p>\n", "LastEditorUserId": "2392147", "LastActivityDate": "2015-04-21T19:04:29.800", "LastEditDate": "2015-04-21T19:04:29.800", "CommentCount": "0", "Id": "24484879", "OwnerUserId": "2392147", "Score": "7", "CreationDate": "2014-06-30T07:24:35.357"}, "bq_ids": {"n3337": {"so_20268482_24484879_0": {"quality": 0.8, "length": 12, "section_id": 4470}}}, "20299292": {"PostTypeId": "2", "ParentId": "20268482", "Body": "<p>Hmm it really seems that std::bind has troubles when dealing with r-value references. One alternative would be to use a lambda function:</p>\n<pre><code>function&lt;void()&gt; f([&amp;]() { s.f1(arg1,arg2,std::move(ptr)); });\n</code></pre>\n<p>In order for this to work you also have to change the signature of f1 such that it accepts the unique_ptr as an r-value reference:</p>\n<pre><code>void f1(string s1, string s2, unique_ptr&lt;Foo&gt;&amp;&amp; p)\n</code></pre>\n<p>(Even if std::bind could handle r-value references, you would still have to do this because std::unique_ptr doesn't have a copy constructor, only the move constructor is accessible!)</p>\n<p>Note however that your construct is rather dangerous (also if std::bind would work): if you call f() twice, you will end up with a runtime exception.</p>\n", "CreationDate": "2013-11-30T10:46:35.777", "Score": "3", "CommentCount": "1", "Id": "20299292", "OwnerUserId": "2796908", "LastActivityDate": "2013-11-30T10:46:35.777"}});