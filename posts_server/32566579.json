post_cb({"32567138": {"ParentId": "32566579", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You can create another class <code>MemberBase</code> that <em>does</em> have that member, and then subclass the two classes (the class to check <code>T</code> and <code>BaseMember</code>) and try to access the member of the subclass. If <code>T</code> also has a <code>member</code> member, then you will get an ambiguity problem. </p>\n<p>Code:</p>\n<pre><code>#include &lt;type_traits&gt;\n\n// Yakk's can_apply\n\ntemplate&lt;class...&gt;struct voider{using type=void;};\ntemplate&lt;class...Ts&gt;using void_t=typename voider&lt;Ts...&gt;::type;\n\ntemplate&lt;class...&gt;struct types{using type=types;};\nnamespace details {\n  template&lt;template&lt;class...&gt;class Z, class types, class=void&gt;\n  struct can_apply : std::false_type {};\n  template&lt;template&lt;class...&gt;class Z, class...Ts&gt;\n  struct can_apply&lt; Z, types&lt;Ts...&gt;, void_t&lt; Z&lt;Ts...&gt; &gt; &gt;:\n    std::true_type\n  {};\n}\ntemplate&lt;template&lt;class...&gt;class Z, class...Ts&gt;\nusing can_apply = details::can_apply&lt;Z,types&lt;Ts...&gt;&gt;;\n\n// Main code\n\nclass MemberBase {\n    public:\n        int member;\n};\n\ntemplate&lt;class ToCheck&gt;\nclass MemberCheck: public ToCheck, public MemberBase {\n};\n\ntemplate &lt;typename T&gt;\nusing member_type = decltype(&amp;T::member);\n\ntemplate &lt;typename T&gt;\nusing hasnot_member = can_apply&lt;member_type, MemberCheck&lt;T&gt;&gt;;\n\ntemplate &lt;typename T&gt; \nusing static_not = std::integral_constant&lt;bool, !T::value&gt;;\n\ntemplate &lt;typename T&gt;\nusing has_member = static_not&lt;hasnot_member&lt;T&gt;&gt;;\n\n// Tests\n\nclass A {\n    int member;\n};\n\nclass Ap {\n    public:\n    int member;\n};\n\nclass B {\n    float member;\n};\n\nclass C {\n    int member();\n};\n\nclass D {\n};\n\nstatic_assert(has_member&lt;A&gt;{}, \"!\"); // ok\nstatic_assert(has_member&lt;Ap&gt;{}, \"!\"); // ok\nstatic_assert(has_member&lt;B&gt;{}, \"!\"); // ok\nstatic_assert(has_member&lt;C&gt;{}, \"!\"); // ok\nstatic_assert(has_member&lt;D&gt;{}, \"!\"); // fail\n</code></pre>\n<p>However, this definitely smells like a dirty hack to me.</p>\n", "OwnerUserId": "3216312", "LastEditorUserId": "3216312", "LastEditDate": "2015-09-14T14:30:37.160", "Id": "32567138", "Score": "4", "CreationDate": "2015-09-14T14:17:08.453", "LastActivityDate": "2015-09-14T14:30:37.160"}, "32567205": {"ParentId": "32566579", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>There is indeed a way for non-final non-union class types:</p>\n<pre><code>namespace detail {\n    struct P {typedef int member;};\n    template &lt;typename U&gt;\n    struct test_for_member : U, P\n    {\n        template &lt;typename T=test_for_member, typename = typename T::member&gt;\n        static std::false_type test(int);\n        static std::true_type test(float);\n    };\n}\ntemplate &lt;typename T&gt;\nusing test_for_member =\n  std::integral_constant&lt;bool, decltype(detail::test_for_member&lt;T&gt;::test(0)){}&gt;;\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/b3c68849d50b8b4c\" rel=\"nofollow\"><strong>Demo</strong></a>. The trick is to check whether lookup into different base classes will yield an ambiguity. [class.member.lookup]/2:</p>\n<blockquote>\n<p id=\"so_32566579_32567205_0\">Member name lookup determines the meaning of a name (<em>id-expression</em>)\n  in a class scope (3.3.7). Name lookup can result in an <em>ambiguity</em>, in\n  which case the program is ill-formed. [\u2026] Name lookup takes place\n  before access control (3.4, Clause 11).</p>\n</blockquote>\n<p>Note that GCCs lookup is broken insofar as it ignores non-type names for lookup in <em>typename-specifier</em>s. </p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-10-11T17:38:52.943", "Id": "32567205", "Score": "21", "CreationDate": "2015-09-14T14:20:09.617", "LastActivityDate": "2015-10-11T17:38:52.943"}, "32566579": {"CommentCount": "4", "AcceptedAnswerId": "32567205", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-09-14T13:52:06.793", "LastActivityDate": "2015-10-11T17:38:52.943", "LastEditDate": "2017-05-23T10:27:04.670", "ViewCount": "1191", "FavoriteCount": "4", "Title": "Detect existence of private member", "Id": "32566579", "Score": "27", "Body": "<p>I want to write a type trait to check if some type has a member <code>member</code>. If <code>member</code> were <em>public</em>, there are any number of ways to do this (e.g. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3911.pdf\" rel=\"nofollow noreferrer\"><code>void_t</code></a>), the most concise of which is probably <a href=\"https://stackoverflow.com/a/29521342/2069064\">Yakk's <code>can_apply</code></a> (which could eventually be called <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\" rel=\"nofollow noreferrer\"><code>std::is_detected</code></a>):</p>\n<pre><code>struct C {\n    int member;\n};\n\ntemplate &lt;typename T&gt;\nusing member_type = decltype(&amp;T::member);\n\ntemplate &lt;typename T&gt;\nusing has_member = can_apply&lt;member_type, T&gt;;\n\nstatic_assert(has_member&lt;C&gt;{}, \"!\"); // OK\n</code></pre>\n<p>But if the member were <em>private</em>, this trait fails, since the access on <code>member</code> is ill-formed (we are not friends) and there is no differentiation between ill-formed due to access reasons and ill-formed due to this-thing-doesn't-exist reasons:</p>\n<pre><code>class D {\n    int member;\n};\n\nstatic_assert(has_member&lt;D&gt;{}, \"!\"); // error\n</code></pre>\n<p>Is there a way to write such a member checker across all access controls?</p>\n", "Tags": "<c++><templates><c++11><c++14><typetraits>", "OwnerUserId": "2069064", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32566579_32567205_0": {"section_id": 6989, "quality": 0.92, "length": 23}}, "n3337": {"so_32566579_32567205_0": {"section_id": 6735, "quality": 0.92, "length": 23}}, "n4659": {"so_32566579_32567205_0": {"section_id": 8487, "quality": 0.92, "length": 23}}}});