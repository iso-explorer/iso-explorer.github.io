post_cb({"21250110": {"ParentId": "21249978", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The standard guarantees that a pointer can be converted to a \"large enough\" integer type and back again resulting in the same pointer value. Specifically, C++11 5.2.10 Reinterpret cast [expr.reinterpret.cast]/4:</p>\n<blockquote>\n<p id=\"so_21249978_21250110_0\">A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is implementation-defined.</p>\n</blockquote>\n<p>and 5:</p>\n<blockquote>\n<p id=\"so_21249978_21250110_1\">A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted to an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type will have its original value; mappings between pointers and integers are otherwise  implementation-defined.</p>\n</blockquote>\n<p>The types <code>intptr_t</code> and <code>uintptr_t</code> from <code>&lt;cstdint&gt;</code> - if supported - are guaranteed to be large enough to store any object pointer type. Typically they are used - even when you know that <code>uint64_t</code> is the size of a pointer on your platform - because they make it clear that you intend to convert between pointers and integers.</p>\n<p>I'll leave as an exercise for the reader to prove that the C casts are equivalent to performing <code>reinterpret_cast</code>.</p>\n<p>TLDR: The standard guarantees that this program will never fail the assertion:</p>\n<pre><code>auto pointer_as_int = reinterpret_cast&lt;uintptr_t&gt;(&amp;foo);\nauto int_as_pointer = reinterpret_cast&lt;decltype(&amp;foo)&gt;(pointer_as_int);\nassert(&amp;foo == int_as_pointer);\n</code></pre>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2014-01-21T05:54:32.373", "Id": "21250110", "Score": "7", "CreationDate": "2014-01-21T05:47:44.637", "LastActivityDate": "2014-01-21T05:54:32.373"}, "bq_ids": {"n4140": {"so_21249978_21250110_0": {"section_id": 6043, "quality": 0.8461538461538461, "length": 11}, "so_21249978_21250110_1": {"section_id": 6044, "quality": 0.96875, "length": 31}}, "n3337": {"so_21249978_21250110_0": {"section_id": 5811, "quality": 0.8461538461538461, "length": 11}, "so_21249978_21250110_1": {"section_id": 5812, "quality": 0.96875, "length": 31}}, "n4659": {"so_21249978_21250110_0": {"section_id": 7542, "quality": 0.8461538461538461, "length": 11}, "so_21249978_21250110_1": {"section_id": 7543, "quality": 0.96875, "length": 31}}}, "21249978": {"CommentCount": "0", "ViewCount": "1935", "PostTypeId": "1", "LastEditorUserId": "1009479", "CreationDate": "2014-01-21T05:37:55.757", "LastActivityDate": "2014-01-21T05:54:32.373", "Title": "Pointer to memory location stored in uint64_t", "AcceptedAnswerId": "21250110", "LastEditDate": "2014-01-21T05:40:41.990", "Id": "21249978", "Score": "1", "Body": "<p>If I have the address of a memory location stored in a variable, i.e. <code>uint64_t</code> for 8 byte pointers on 64-bit systems, can I use the value stored in the <code>uint64_t</code> to create a new pointer pointing to the memory location that it holds?</p>\n<pre><code>struct Node { .. };\nNode* node = new Node(5);\nuint64_t addr = (uint64_t)static_cast&lt;void*&gt;(&amp;node); // 8 byte pointer\n</code></pre>\n<p>For example the address of node is <code>0x7fff76bb4880</code>, <code>addr</code> stores <code>140735185373312</code> (the dec representation), and I want a new pointer <code>Node* new_ptr = (Node*)0x7fff76bb4880</code>.</p>\n<p>I realize this will be platform specific. </p>\n", "Tags": "<c++><pointers>", "OwnerUserId": "3217789", "AnswerCount": "1"}});