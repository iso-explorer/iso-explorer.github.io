post_cb({"bq_ids": {"n4140": {"so_27872517_27872518_1": {"length": 9, "quality": 0.9, "section_id": 5314}, "so_27872517_27872518_2": {"length": 6, "quality": 1.0, "section_id": 5316}}, "n3337": {"so_27872517_27872518_1": {"length": 9, "quality": 0.9, "section_id": 5111}, "so_27872517_27872518_2": {"length": 6, "quality": 1.0, "section_id": 5113}}, "n4659": {"so_27872517_27872518_1": {"length": 9, "quality": 0.9, "section_id": 6738}, "so_27872517_27872518_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 6740}}}, "27872517": {"ViewCount": "468", "Body": "<p>The C++ standard mentions multiple different character sets. In particular, it mentions the following character sets:</p>\n<ol>\n<li>In 2.2 [lex.phases] bullet 1 <em>physical source file characters</em> and their mapping to the <em>basic source character set</em> is mentioned.</li>\n<li>In 2.2 [lex.phases] bullet 2 <em>execution character set</em> is mentioned.</li>\n<li>In 2.3 [lex.charset] paragraph 3 a <em>basic execution character set</em> and a <em>basic execution wide-character</em> set are mentioned.</li>\n<li>The same section 2.3 [lex.charset] 3 also mentions an <em>execution character set</em> and an <em>execution wide-character set</em>.</li>\n<li>When reading or writing files these use some other character set.</li>\n</ol>\n<p>What are all those different character set used for, how are conversions between them done, and which of these values are locale dependent? In particular, how are string literals represented?</p>\n", "AcceptedAnswerId": "27872518", "Title": "What are the different character sets used for?", "CreationDate": "2015-01-10T03:15:30.300", "Id": "27872517", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-01-10T03:16:28.310", "LastEditorUserId": "583833", "LastActivityDate": "2015-01-10T16:40:38.330", "Score": "6", "OwnerUserId": "1120273", "Tags": "<c++><encoding><utf-8>", "AnswerCount": "1"}, "27872518": {"Id": "27872518", "PostTypeId": "2", "Body": "<p>Here is a break down of the different character sets used by the compiler itself (all reference to the standard are for <a href=\"http://www.open-std.org/JTC1/SC22/WG21/prot/14882fdis/n4140.pdf\" rel=\"nofollow noreferrer\">C++14</a>, actually):</p>\n<ol>\n<li>The <em>physical source file characters</em> are those used in the C++ source. Most likely these are now encoded using some Unicode encoding, e.g., <a href=\"http://en.wikipedia.org/wiki/UTF-8\" rel=\"nofollow noreferrer\">UTF-8</a> or <a href=\"http://en.wikipedia.org/wiki/UTF-16\" rel=\"nofollow noreferrer\">UTF-16</a>. If you are from a European or an American background you may be using <a href=\"http://en.wikipedia.org/wiki/ASCII\" rel=\"nofollow noreferrer\">ASCII</a> whose characters are conveniently encoded identically in UTF-8 (every ASCII file is a UTF-8 file but not the other way around). The physical source file characters_ may also be something unusual like <a href=\"http://en.wikipedia.org/wiki/EBCDIC\" rel=\"nofollow noreferrer\">EBCDIC</a>.</li>\n<li><p>The <em>basic source character set</em> is what the compiler, at least conceptually, consumes. It is produced from the physical source file characters and either mapping them to their respective basic character or to a sequence of basic characters representing the physical source character using a <em>universal character name</em> (see 2.2 [lex.phases] paragraph 1). The basic source character set is a just a set of 96 character (2.3 [lex.charset] paragraph 1):</p>\n<blockquote>\n<p id=\"so_27872517_27872518_0\">a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 0 1 2 3 4 5 6 7 8 9 _ { } [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \\ \" \u2019</p>\n<p id=\"so_27872517_27872518_1\">and the 5 special characters space (' '), horizontal tab (\\t), vertical tab (\\v), form feed (\\f), and newline (\\n)</p>\n</blockquote>\n<p>The mapping between the physical source character set and the basic character set is implementation defined.</p></li>\n<li><p>The <em>basic execution character set</em> and the <em>basic execution wide-character</em> set are characters set capable of representing the basic source character set expanded by a few special character:</p>\n<blockquote>\n<p id=\"so_27872517_27872518_2\">alert ('\\a'), backspace ('\\b'), carriage return ('\\r'), and a null character ('\\0')</p>\n</blockquote>\n<p>The difference between the non-wide and the wide version is whether the characters are represented using <code>char</code> or <code>wchar_t</code>.</p></li>\n<li><p>The <em>execution character set</em> and the <em>execution wide-character set</em> are implementation defined extensions of the basic character set and the basic wide-character set. In 2.3 [lex.charset] paragraph 3 it is stated that the additional members and the values of the additional members of execution character set are locale specific. It isn't clear which locale is referred to but I suspect the locale used during compilation is meant. In any case, the execution character sets are implementation defined (also according to 2.3 [lex.charset] paragraph 3).</p></li>\n<li><p>Character and string literals are originally represented using the basic source character set with some characters possibly using universal character names. All of these are converted at compile time into the execution character set. According to 2.14.3 [lex.ccon] character literals representable as one <code>char</code> in the execution character set just work. If multiple <code>char</code>s are needed the character literals may be conditionally supported (and they'd have type <code>int</code>). For string literals the conversion is described in 2.14.5 [lex.string]. Paragraph 9 states that UTF-8 string literals (e.g. <code>u8\"hello\"</code>) result in a sequence of values corresponding to the code units of the UTF-8 string. Otherwise the translation of characters and universal character names is the same as that for character literals (in particular, it is implementation defined) although characters resulting in multi-byte sequences for narrow string just result in multiple characters (this case isn't necessary support for character literals).</p></li>\n</ol>\n<p>So far, only the result of compilation is considered. Any character which isn't part of a character or a string literal is used to specify what the code does. The interesting question is what happened to the literals? The literals are all basically translated into an implementation defined representation. That is implementation defined means that it is somewhere documented what is supposed to happen but it can differ between different implementations.</p>\n<p>How does that help when dealing with characters or strings coming from somewhere? Well, any character or string which is read is converted to the corresponding execution character set. In particular, when a file is read, all characters are transformed to this common representation. Of course, for this transformation to work, the locale used for reading a file needs to be setup according to the encoding of that file. If the locale isn't explicitly mentioned the global locale is used which is initially determined by the system is used. The initial global locale is probably set somehow based on user preferences, e.g., based no environment variables. If a a file is read which uses a different encoding than this global locale, a corresponding different locale matching the encoding of the file needs to be used.</p>\n<p>Correspondingly, when writing characters using one of the execution character sets, these are converted according to the encoding specified by the current locale. Again, it may be necessary to replace the locale if a specific encoding is needed.</p>\n<p>All this effectively means that internally to a program all string and character processing happens using the implementation defined execution character set. All characters being read by a program need to be converted to this character set and all characters written start as characters in this execution character set and need to be converted appropriately to the external encoding. If course, in an ideal set up the conversion between the execution character set and the external representation is the identity, e.g., because the execution character set uses UTF-8 and the external representation also uses UTF-8. Correspondingly for the execution wide-character set except in this case UTF-16 would be used (one of the two variations as UTF-16 can either use <a href=\"http://en.wikipedia.org/wiki/Endianness\" rel=\"nofollow noreferrer\">big endian or little endian</a> representation).</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2015-01-10T16:40:38.330", "Score": "8", "CreationDate": "2015-01-10T03:15:30.300", "ParentId": "27872517", "CommentCount": "2", "OwnerUserId": "1120273", "LastEditDate": "2015-01-10T16:40:38.330"}});