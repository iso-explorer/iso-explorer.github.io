post_cb({"1107225": {"Id": "1107225", "PostTypeId": "2", "Body": "<p>Sorry. The correct way to get rid of <code>Value</code> is to use <code>iterator_traits</code> as you suggested.</p>\n<p>If your non-STL iterator is a naked pointer, then you get correct iterator_traits typedefs for free. Otherwise the non-STL iterator class must define the correct typedefs.</p>\n<p>See the <a href=\"http://www.sgi.com/tech/stl/iterator_traits.html\" rel=\"nofollow noreferrer\">iterator traits documentation</a> for more information.</p>\n", "LastActivityDate": "2009-07-10T01:08:05.253", "CommentCount": "0", "CreationDate": "2009-07-10T01:08:05.253", "ParentId": "1107149", "Score": "1", "OwnerUserId": "99377"}, "1107916": {"Id": "1107916", "PostTypeId": "2", "Body": "<p>As to getting value type of iterator previous answers were correct.</p>\n<p>But there is more. The trick you are thinking of would not work with class. If <code>Bar</code> was a function like:</p>\n<pre><code>template &lt;typename Iterator, typename Value&gt;\nvoid bar(const Iterator&amp; dummy_iterator, const Value&amp; dummmy_value) {}\n</code></pre>\n<p>then type deduction would work for <code>bar(it, *it)</code> and you would have the value type inside of <code>bar</code>. (But keep in mind that to use this trick you would still have to have a dereferencable iterator it which is not always good - how to deal with empty sequence then?)</p>\n<p>Using a class <code>Bar</code> you would have to provide the template arguments <code>Iterator</code> and <code>Value</code> manually as there is no type deduction for classes and using <code>Bar(it, *it)</code> would no compile.</p>\n", "LastEditorUserId": "422489", "LastActivityDate": "2009-09-06T11:45:52.570", "Score": "1", "CreationDate": "2009-07-10T05:53:02.910", "ParentId": "1107149", "CommentCount": "1", "LastEditDate": "2009-09-06T11:45:52.570", "OwnerUserId": "422489"}, "1107149": {"ViewCount": "3655", "Body": "<p>I have a class</p>\n<pre><code>template &lt;typename Iterator, typename Value&gt;\nclass Foo {\n public:\n  Foo(const Iterator&amp; it) { ... }\n  ...\n private:\n   map&lt;Value, int&gt; m_;\n  }\n};\n</code></pre>\n<p>Is there any way to get rid of Value in the template? The Iterator may or may not be an STL iterator, but it's guaranteed that *it type is Value.</p>\n<p>I know about <code>iterator_traits&lt;T&gt;::value_type</code> for STL iterators, but wonder if there's any way to get Value type automatically for an arbitrary Iterator type?</p>\n<p>One trick I'm thinking about - say, we have a helper class</p>\n<pre><code>template &lt;typename Iterator, typename Value&gt;\nclass Bar {\n public:\n  Bar(const Iterator&amp; dummy_iterator, const Value&amp; dummmy_value) {}\n  ...\n};\n</code></pre>\n<p>Then if we instantiate Bar as Bar(it, *it), the type of Value will be known inside Bar. But I can't find a good way to combine Bar with Foo.</p>\n", "AcceptedAnswerId": "1107235", "Title": "Is it possible to get the value type from an arbitrary iterator (C++)?", "CreationDate": "2009-07-10T00:36:44.497", "Id": "1107149", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2009-07-10T01:10:41.120", "LastEditorUserId": "110177", "LastActivityDate": "2009-09-06T11:45:52.570", "Score": "14", "OwnerUserId": "110177", "Tags": "<c++><templates>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_1107149_1107235_0": {"length": 20, "quality": 1.0, "section_id": 5583}, "so_1107149_1107235_1": {"length": 9, "quality": 1.0, "section_id": 5583}}, "n3337": {"so_1107149_1107235_0": {"length": 20, "quality": 1.0, "section_id": 5365}, "so_1107149_1107235_1": {"length": 9, "quality": 1.0, "section_id": 5365}}, "n4659": {"so_1107149_1107235_0": {"length": 20, "quality": 1.0, "section_id": 7030}, "so_1107149_1107235_1": {"length": 9, "quality": 1.0, "section_id": 7030}}}, "1107235": {"Id": "1107235", "PostTypeId": "2", "Body": "<p><em>Any</em> iterator should provide <code>iterator_traits&lt;Iterator&gt;::value_type</code>. If it does not, then it is not an iterator. ISO C++ 2003 24.3.1[lib.iterator.traits] \"Iterator traits\":</p>\n<blockquote>\n<p id=\"so_1107149_1107235_0\">To implement algorithms only in terms\n  of iterators, it is often necessary to\n  determine the value and difference\n  types that correspond to a particular\n  iterator type. Accordingly, it is\n  required that if <code>Iterator</code> is the type\n  of an iterator, the types</p>\n<pre><code>iterator_traits&lt;Iterator&gt;::difference_type\niterator_traits&lt;Iterator&gt;::value_type\niterator_traits&lt;Iterator&gt;::iterator_category\n</code></pre>\n<p id=\"so_1107149_1107235_1\">be defined as the iterator\u2019s\n  difference type, value type and\n  iterator category, respectively.</p>\n</blockquote>\n<p>Aside from that, there's no general way to obtain a type of an arbitrary C++ expression. C++0x will rectify it by providing <code>decltype</code>.</p>\n", "LastActivityDate": "2009-07-10T01:10:44.397", "CommentCount": "1", "CreationDate": "2009-07-10T01:10:44.397", "ParentId": "1107149", "Score": "18", "OwnerUserId": "111335"}});