post_cb({"38038122": {"CommentCount": "6", "ViewCount": "52", "CreationDate": "2016-06-26T11:36:21.463", "LastActivityDate": "2016-06-27T22:49:51.850", "Title": "Object slicing or UB risk?", "AcceptedAnswerId": "38064418", "PostTypeId": "1", "Id": "38038122", "Score": "1", "Body": "<p>There's a couple of base classes outside my control like this:-</p>\n<pre><code>class BaseNode // Just a POD class. No VTable\n{\n  void foo();\n}\n\nclass BaseHost \n{\npublic:\n  BaseNode *getNode()\n  {\n    ...\n  } \n}\n</code></pre>\n<p>I want to \"extend\" the functionality of <code>BaseNode::foo</code>, but the class is effectively sealed. </p>\n<p>Here's the suggestion:-</p>\n<pre><code>class MyNode: public BaseNode \n{\n  void foo()\n  {\n    // do my stuff..., then\n    BaseNode::foo();\n  }    \n}\n\nclass MyHost: public BaseHost \n{\npublic:\n  MyNode *getNode()\n  {\n    return (MyNode*) BaseHost::getNode(); // Slicing or UB risk?\n  }   \n}\n</code></pre>\n<p>Things will go badly wrong if <code>MyNode</code> introduces additional class members, or virtual methods - but if those constraints are met, do I still have UB? </p>\n<p>Any other gotchas, or do I rethink the design entirely.?</p>\n", "Tags": "<c++><inheritance><undefined-behavior>", "OwnerUserId": "1737", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_38038122_38064418_0": {"section_id": 41, "quality": 0.9285714285714286, "length": 39}, "so_38038122_38064418_1": {"section_id": 6037, "quality": 0.8955223880597015, "length": 60}}, "n3337": {"so_38038122_38064418_0": {"section_id": 38, "quality": 0.9285714285714286, "length": 39}, "so_38038122_38064418_1": {"section_id": 5805, "quality": 0.8805970149253731, "length": 59}}, "n4659": {"so_38038122_38064418_0": {"section_id": 41, "quality": 0.9285714285714286, "length": 39}, "so_38038122_38064418_1": {"section_id": 7536, "quality": 0.7910447761194029, "length": 53}}}, "38064418": {"ParentId": "38038122", "CommentCount": "1", "Body": "<p>Such a downcasting shall be used with extreme care: it can very easily lead to UB.   </p>\n<p>The standard guarantees that you can safely convert from <code>MyNode*</code> to <code>BaseNode*</code>: </p>\n<blockquote>\n<p id=\"so_38038122_38064418_0\"><strong>4.10/3:</strong> A prvalue of type \u201cpointer to cv D\u201d, where D is a class type, can be converted to a prvalue of type \u201cpointer to cv B\u201d, where B\n  is a base class of D. If B is an inaccessible or ambiguous base class\n  of D, a program that necessitates this conversion is ill-formed. The\n  result of the conversion is a pointer to the base class subobject of\n  the derived class object. The null pointer value is converted to the\n  null pointer value of the destination type.</p>\n</blockquote>\n<p>But let's play with the fire: the standard also let you can cast from  <code>BaseNode*</code> to <code>MyNode*</code> under certain conditions : </p>\n<blockquote>\n<p id=\"so_38038122_38064418_1\"><strong>5.2.9/11:</strong> A prvalue of type \u201cpointer to cv1 B,\u201d where B is a class type, can be converted to a prvalue of type \u201cpointer to cv2 D,\u201d where\n  D is a class derived  from B, if a valid standard conversion from\n  \u201cpointer to D\u201d to \u201cpointer to B\u201d exists, cv2 is the same\n  cv-qualification as, or greater cv-qualification than, cv1, and B is\n  <strong>neither a virtual base class of D nor a base class of a virtual base class of D</strong>. The null pointer value  is converted to the null pointer\n  value of the destination type. <strong>If the prvalue of type \u201cpointer to\n  cv1 B\u201d points to a B that is actually a subobject of an object of type\n  D, the resulting pointer points to the enclosing object of type D.\n  <em>Otherwise, the behavior is undefined</em></strong></p>\n</blockquote>\n<p>I try to translating these quotes into plain text: </p>\n<ul>\n<li>If you are sure that <code>BaseHost::getNode()</code> returns an upcasted pointer to a <code>MyNode</code> object, and you have no virtual inheritance in your class hierarchy, then it's ok. </li>\n<li>But if <code>BaseHost::getNode()</code> would return something else (e.g. a pointer to a plain <code>BaseNode</code> or to another sibling derivate of <code>BaseNode</code>) you'll have UB.  </li>\n</ul>\n<p>As said, it's dangerous: the UB might already happen during the pointer conversion, before you even attempt to dereference the pointer.  So better try to avoid it.  If you'd have a polymorphic <code>BaseNode</code> class (e.g. with a virtual destructor), you could use a safer <a href=\"http://en.cppreference.com/w/cpp/language/dynamic_cast\" rel=\"nofollow\"><code>dynamic_cast</code></a>. </p>\n", "OwnerUserId": "3723423", "PostTypeId": "2", "Id": "38064418", "Score": "1", "CreationDate": "2016-06-27T22:49:51.850", "LastActivityDate": "2016-06-27T22:49:51.850"}});