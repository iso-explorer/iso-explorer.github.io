post_cb({"7473271": {"Id": "7473271", "PostTypeId": "2", "Body": "<p>It's well-defined.</p>\n<blockquote>\n<p id=\"so_7473106_7473271_0\"><code>[n3290: 12.7/4]:</code> <strong>Member functions, including virtual functions\n  (10.3), can be called during construction or destruction (12.6.2).</strong>\n<strong>When a virtual function is called</strong> directly or indirectly <strong>from a\n  constructor</strong> or from a destructor, including during the construction or\n  destruction of the class\u2019s non-static data members, and the object to\n  which the call applies is the object (call it <code>x</code>) under construction or\n  destruction, <strong>the function called is the final overrider in the\n  constructor\u2019s or destructor\u2019s class and not one overriding it in a\n  more-derived class.</strong> If the virtual function call uses an explicit\n  class member access (5.2.5) and the object expression refers to the\n  complete object of <code>x</code> or one of that object\u2019s base class subobjects but\n  not <code>x</code> or one of its base class subobjects, the behavior is undefined.</p>\n</blockquote>\n", "LastActivityDate": "2011-09-19T15:22:02.413", "Score": "2", "CreationDate": "2011-09-19T15:22:02.413", "ParentId": "7473106", "CommentCount": "0", "OwnerUserId": "560648"}, "bq_ids": {"n4140": {"so_7473106_7473271_0": {"length": 71, "quality": 0.9342105263157895, "section_id": 447}}, "n3337": {"so_7473106_7473271_0": {"length": 71, "quality": 0.9342105263157895, "section_id": 438}}, "n4659": {"so_7473106_7473271_0": {"length": 71, "quality": 0.9342105263157895, "section_id": 469}}}, "7473106": {"ViewCount": "169", "Body": "<p>C++ type change during deletion</p>\n<p>I've read that when you construct a derived type, the type changes depending on which constructor is being called.  So, if you create a derived object and call a virtual function using a base pointer, normally it would map to the implementation in the derived class.  If you called the virtual function in the base class constructor though, it would use the base class implementation as the type of the object is technically that of the base class while in that function.  For example (makeshift code, sorry if it doesn't compile):</p>\n<pre><code>class Base { \n    Base()\n    {\n        std::cerr &lt;&lt; \"Base Constructor.\";\n        func();\n    }\n\n    virtual void func() {\n        std::cerr &lt;&lt; \"Func base called.\" &lt;&lt; std::endl;\n    }\n};\n\nclass Derived : public Base {\n    Derived()\n    {\n        std::cerr &lt;&lt; \"Derived Constructor.\";\n        func();\n    }\n\n    void func() {\n        std::cerr &lt;&lt; \"Func derived called.\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Derived* d = new Derived;\n    delete d;\n}\n</code></pre>\n<p>Should output:</p>\n<pre><code>Base Constructor.\nFunc base called.\nDerived Constructor.\nFunc derived called.\n</code></pre>\n<p>First of all, is this always true or is it implementation dependent?</p>\n<p>If I used RTTI and typeinfo, would the type printed in the base actually be that of the base, or is this more of an unwritten rule sort of situation?</p>\n<p>Is it dangerous to call virtual functions from constructors with this in mind, or is it safe as long as you know what you're doing?</p>\n", "AcceptedAnswerId": "7473176", "Title": "C++ Type changes during derived class construction - virtual function question", "CreationDate": "2011-09-19T15:11:20.890", "Id": "7473106", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2011-09-19T18:54:43.370", "Score": "1", "OwnerUserId": "857994", "Tags": "<c++>", "AnswerCount": "3"}, "7475873": {"Id": "7475873", "PostTypeId": "2", "Body": "<p>There is an excellent article from Scott Meyers. It is from his book Effective C++.\nThe article can be found at: \n<a href=\"http://www.artima.com/cppsource/nevercall.html\" rel=\"nofollow\">Never Call Virtual Functions during Construction or Destruction</a></p>\n<p>It also discusses an alternative implementation. </p>\n<p>Recently I had a similar problem which I solved this way:</p>\n<pre><code>class EthernetFrame\n{\nprotected:\n  /** ctor to be called from derived classes */\n  EthernetFrame(unsigned inPayloadLength)\n  {\n    calculatePadBytes(inPayloadLength);\n  }\n\nprivate:\n  /** calculates needed required PadBytes for Frames &lt; 64B\n   * @param inPayloadLength we need to know the length of the actual L3 frame\n   */\n  void calculatePadBytes(unsigned inPayloadLength);\n\n};\n\nclass IPv4Frame : public EthernetFrame\n{\npublic:\n  /** create empty IPv4 packet */\n  IPv4Frame() :\n    EthernetFrame(cIPv4_MINIMUM_LENGTH)\n  {};\n  // IPv4 header + trailer in bytes\n  unsigned cIPv4_MINIMUM_LENGTH;\nprotected:\n  /** ctor to be called from derived classes */\n  IPv4Frame(unsigned inPayloadLength) :\n    EthernetFrame(cIPv4_MINIMUM_LENGTH+inPayloadLength)\n  {};\n\n};\n</code></pre>\n", "LastActivityDate": "2011-09-19T18:54:43.370", "Score": "1", "CreationDate": "2011-09-19T18:54:43.370", "ParentId": "7473106", "CommentCount": "3", "OwnerUserId": "943190"}, "7473176": {"Id": "7473176", "PostTypeId": "2", "Body": "<p>To keep it short and simple, you can have a Rule: </p>\n<p><strong>The virtual mechanism is disabled in Constructors and Destructors</strong></p>\n<p>A virtual function call in Base class will always call the base class version of the function, the same in derived class results in call to the Derived class version of the function.</p>\n<blockquote>\n<p id=\"so_7473106_7473176_0\">First of all, is this always true or is it implementation dependent?</p>\n</blockquote>\n<p>Yes this is always true. This is not implementation-dependent.</p>\n<blockquote>\n<p id=\"so_7473106_7473176_1\">If I used RTTI and typeinfo, would the type printed in the base actually be that of the base?</p>\n</blockquote>\n<p>Yes it would be of Base; Derived object doesn't even exist while you are in Base class constructor.</p>\n<blockquote>\n<p id=\"so_7473106_7473176_2\">Is it dangerous to call virtual functions from constructors with this in mind, or is it safe as long as you know what you're doing?</p>\n</blockquote>\n<p>No it is not dangerous to call virtual functions from constructor as long as you understand the semantics behind it.</p>\n<hr>\n<p><strong><a href=\"http://www.parashift.com/c++-faq-lite/strange-inheritance.html#faq-23.5\" rel=\"nofollow\">This C++ FAQ</a></strong> should be a good read for you.</p>\n</hr>", "LastEditorUserId": "560648", "LastActivityDate": "2011-09-19T15:33:43.180", "Score": "8", "CreationDate": "2011-09-19T15:15:11.430", "ParentId": "7473106", "CommentCount": "1", "LastEditDate": "2011-09-19T15:33:43.180", "OwnerUserId": "452307"}});