post_cb({"bq_ids": {"n4140": {"so_33988297_33989033_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 3298}, "so_33988297_33988299_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 3325}}, "n3337": {"so_33988297_33989033_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 3168}, "so_33988297_33988299_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 3195}}, "n4659": {"so_33988297_33989033_0": {"length": 12, "quality": 0.631578947368421, "section_id": 4063}, "so_33988297_33988299_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 4048}}}, "33989033": {"Id": "33989033", "PostTypeId": "2", "Body": "<p>What's messing you up is <em>aggregate initialization</em>.</p>\n<p>As you say, there are benefits and drawbacks to using list initialization.  (The term \"uniform initialization\" is not used by the C++ Standard).</p>\n<p>One of the drawbacks is that list initialization behaves differently for aggregates than non-aggregates. Also, the definition of <em>aggregate</em> changes slightly with each Standard.</p>\n<hr>\n<p>Aggregates are not created via a constructor. (Technically they actually might be, but this is a good way to think of it). Instead, when creating an aggregate, memory is allocated and then each member is initialized in order according to what's in the list initializer.</p>\n<p>Non-aggregates are created via constructors, and in that case the members of the list initializer are constructor arguments.</p>\n<p>There is actually a design flaw in the above:  if we have <code>T t1;  T t2{t1};</code>, then the intent is to perform copy-construction.  However, (prior to C++14) if <code>T</code> is an aggregate then aggregate initialization happens instead, and <code>t2</code>'s first member is initialized with <code>t1</code>.</p>\n<p>This flaw was fixed in a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1467\">defect report</a> which modified C++14, so from now on, copy-construction is checked for before we move onto aggregate initialization.</p>\n<hr>\n<p>The definition of <em>aggregate</em> from C++14 is:</p>\n<blockquote>\n<p id=\"so_33988297_33989033_0\">An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>In C++11, a default value for a non-static member meant a class was not an aggregate; however that was changed for C++14.   <em>User-provided</em> means user-declared , but not <code>= default</code> or <code>= delete</code>.</p>\n<hr>\n<p>If you want to make sure that your constructor call <em>never</em> accidentally performs aggregate initialization, then you have to use <code>( )</code> rather than <code>{ }</code>, and avoid MVPs in other ways.</p>\n</hr></hr></hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2015-11-29T22:56:15.087", "Score": "6", "CreationDate": "2015-11-29T22:41:48.863", "ParentId": "33988297", "CommentCount": "8", "LastEditDate": "2015-11-29T22:56:15.087", "OwnerUserId": "1505939"}, "33988297": {"ViewCount": "2323", "Body": "<h1>The naive, optimistic and oh.. so wrong view of the c++11 uniform initialization syntax</h1>\n<p>I thought that since C++11 user-defined type objects should be constructed with the new <code>{...}</code> syntax instead of the old <code>(...)</code> syntax (except for constructor overloaded for <code>std::initializer_list</code> and similar parameters (e.g. <code>std::vector</code>: size ctor vs 1 elem init_list ctor)).</p>\n<p>The benefits are: no narrow implicit conversions, no problem with the most vexing parse, consistency(?). I saw no problem as I thought they are the same (except the example given).</p>\n<p>But they are not.</p>\n<h1>A tale of pure madness</h1>\n<p>The <code>{}</code> calls the default constructor.</p>\n<p>... Except when:</p>\n<ul>\n<li>the default constructor is deleted and</li>\n<li>there are no other constructors defined.</li>\n</ul>\n<p>Then it looks like it it rather value initializes the object?... Even if the object has deleted default constructor, the <code>{}</code> can create an object. Doesn't this beat the whole purpose of a deleted constructor?</p>\n<p>...Except when:</p>\n<ul>\n<li>the object has a deleted default constructor and</li>\n<li>other constructor(s) defined.</li>\n</ul>\n<p>Then it fails with <code>call to deleted constructor</code>.</p>\n<p>...Except when:</p>\n<ul>\n<li>the object has a deleted constructor and</li>\n<li>no other constructor defined and</li>\n<li>at least a non-static data member.</li>\n</ul>\n<p>Then it fails with missing field initializers.</p>\n<p>But then you can use <code>{value}</code> to construct the object.</p>\n<p><em>Ok maybe this is the same as the first exception (value init the object)</em></p>\n<p>...Except when:</p>\n<ul>\n<li>the class has a deleted constructor</li>\n<li>and at least one data members in-class default initialized.</li>\n</ul>\n<p>Then nor <code>{}</code> nor <code>{value}</code> can create an object.</p>\n<p>I am sure I missed a few. The irony is that it is called <em>uniform</em> initialization syntax. I say again: <strong><em>UNIFORM</em></strong> initialization syntax.</p>\n<p>What is this madness?</p>\n<h2>Scenario A</h2>\n<h3>Deleted default constructor:</h3>\n<pre><code>struct foo {\n  foo() = delete;\n};\n\n// All bellow OK (no errors, no warnings)\nfoo f = foo{};\nfoo f = {};\nfoo f{}; // will use only this from now on.\n</code></pre>\n<h2>Scenario B</h2>\n<h3>Deleted default constructor, other constructors deleted</h3>\n<pre><code>struct foo {\n  foo() = delete;\n  foo(int) = delete;\n};\n\nfoo f{}; // OK\n</code></pre>\n<h2>Scenario C</h2>\n<h3>Deleted default constructor, other constructors defined</h3>\n<pre><code>struct foo {\n  foo() = delete;\n  foo(int) {};\n};\n\nfoo f{}; // error call to deleted constructor\n</code></pre>\n<h2>Scenario D</h2>\n<h3>Deleted default constructor, no other constructors defined, data member</h3>\n<pre><code>struct foo {\n  int a;\n  foo() = delete;\n};\n\nfoo f{}; // error use of deleted function foo::foo()\nfoo f{3}; // OK\n</code></pre>\n<h2>Scenario E</h2>\n<h3>Deleted default constructor, deleted T constructor, T data member</h3>\n<pre><code>struct foo {\n  int a;\n  foo() = delete;\n  foo(int) = delete;\n};\n\nfoo f{}; // ERROR: missing initializer\nfoo f{3}; // OK\n</code></pre>\n<h2>Scenario F</h2>\n<h3>Deleted default constructor, in-class data member initializers</h3>\n<pre><code>struct foo {\n  int a = 3;\n  foo() = delete;\n};\n\n/* Fa */ foo f{}; // ERROR: use of deleted function `foo::foo()`\n/* Fb */ foo f{3}; // ERROR: no matching function to call `foo::foo(init list)`\n</code></pre>\n<h1> </h1>\n", "AcceptedAnswerId": "33988299", "Title": "Deleted default constructor. Objects can still be created... sometimes", "CreationDate": "2015-11-29T21:22:00.753", "Id": "33988297", "CommentCount": "2", "FavoriteCount": "7", "PostTypeId": "1", "LastActivityDate": "2015-11-29T23:29:03.553", "Score": "22", "OwnerUserId": "2805305", "Tags": "<c++><c++14><list-initialization>", "AnswerCount": "2"}, "33988299": {"Id": "33988299", "PostTypeId": "2", "Body": "<p>When viewing things this way it is easy to say there is complete and utter chaos in the way an object is initialized.</p>\n<p>The big difference comes from the type of <code>foo</code>: if it is an aggregate type or not.</p>\n<blockquote>\n<p id=\"so_33988297_33988299_0\">It is an aggregate if it has:</p>\n<ul>\n<li>no user-provided constructors (a deleted or defaulted function does not count as user-provided),</li>\n<li>no private or protected non-static data members,</li>\n<li>no brace-or-equal-initializers for non-static data members (since c++11 until (reverted in) c++14)</li>\n<li>no base classes,</li>\n<li>no virtual member functions.</li>\n</ul>\n</blockquote>\n<p>So:</p>\n<ul>\n<li>in scenarios A B D E: <code>foo</code> is an aggregate</li>\n<li>in scenarios C: <code>foo</code> is not an aggregate</li>\n<li>scenario F:\n\n<ul>\n<li>in c++11 it is not an aggregate.</li>\n<li>in c++14 it is an aggregate.</li>\n<li>g++ hasn't implemented this and still treats it as a non-aggregate even in C++14.\n\n<ul>\n<li><code>4.9</code> doesn't implement this.</li>\n<li><code>5.2.0</code> does</li>\n<li><code>5.2.1 ubuntu</code> doesn't (maybe a regression)</li>\n</ul></li>\n</ul></li>\n</ul>\n<blockquote>\n<p id=\"so_33988297_33988299_1\">The effects of list initialization of an object of type T are:</p>\n<ul>\n<li>...</li>\n<li>If T is an aggregate type, aggregate initialization is performed. This takes care of scenarios A B D E (and F in C++14)</li>\n<li>Otherwise the constructors of T are considered in two phases:\n  \n  <ul>\n<li>All constructors that take std::initializer_list ...</li>\n<li>otherwise [...] all constructors of T participate in overload resolution [...]  This takes care of C (and F in C++11)</li>\n</ul></li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>:</p>\n<blockquote>\n<p id=\"so_33988297_33988299_2\">Aggregate initialization of an object of type T (scenarios A B D E (F c++14)):</p>\n<ul>\n<li>Each non-static class member, in order appearance in the class definition, is copy-initialized from the corresponding clause of the\n  initializer list. (array reference omitted)</li>\n</ul>\n</blockquote>\n<hr>\n<p><strong>TL;DR</strong></p>\n<p>All these rules can still seem very complicated and headache inducing. I personally over-simplify this for myself (if I thereby shoot myself in the foot then so be it: I guess I will spend 2 days in the hospital rather than having a couple of dozen days of headaches):</p>\n<ul>\n<li>for an aggregate each data member is initialized from the elements of the list initializer</li>\n<li>else call constructor</li>\n</ul>\n<hr>\n<blockquote>\n<p id=\"so_33988297_33988299_3\">Doesn't this beat the whole purpose of a deleted constructor?</p>\n</blockquote>\n<p>Well, I don't know about that, but the solution is to make <code>foo</code> not an aggregate. The most general form that adds no overhead and doesn't change the used syntax of the object is to make it inherit from an empty struct:</p>\n<pre><code>struct dummy_t {};\n\nstruct foo : dummy_t {\n  foo() = delete;\n};\n\nfoo f{}; // ERROR call to deleted constructor\n</code></pre>\n<p>In some situations (no non-static members at all, I guess), an alternate would be to delete the destructor (this will make the object not instantiable in any context):</p>\n<pre><code>struct foo {\n  ~foo() = delete;\n};\n\nfoo f{}; // ERROR use of deleted function `foo::~foo()`\n</code></pre>\n<hr>\n<p>This answer uses information gathered from:</p>\n<ul>\n<li><p><a href=\"https://stackoverflow.com/questions/23882409/c14-value-initialization-with-deleted-constructor\">C++14 value-initialization with deleted constructor</a></p></li>\n<li><p><a href=\"https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special\">What are Aggregates and PODs and how/why are they special?</a></p></li>\n<li><p><a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow noreferrer\">List initialization</a></p></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization\" rel=\"nofollow noreferrer\">Aggregate initialization</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/direct_initialization\" rel=\"nofollow noreferrer\">Direct initialization</a></li>\n</ul>\n<p>Many thanks to <a href=\"https://stackoverflow.com/users/1505939/m-m\">@M.M</a> who helped correct and improve this post.</p>\n</hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-29T23:29:03.553", "Score": "19", "CreationDate": "2015-11-29T21:22:00.753", "ParentId": "33988297", "CommentCount": "12", "LastEditDate": "2017-05-23T10:29:25.167", "OwnerUserId": "2805305"}});