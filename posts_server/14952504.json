post_cb({"14952504": {"ViewCount": "720", "Body": "<p>Is it possible to downcast an object to a subclass does not define any extra variable or virtual method?</p>\n<p>If I have these classes,</p>\n<pre><code>class A { public: A (); };\nclass B : public A { public: void method1 () {} B (); };\n</code></pre>\n<p>is this (1) possible and (2) safe by standard?</p>\n<pre><code>A* a = new A ();\nB* b = (B*)a;\nb-&gt;method1();\n</code></pre>\n", "AcceptedAnswerId": "14954413", "Title": "Is it possible to downcast an object to a subclass which does not define extra variable or vtable in C++?", "CreationDate": "2013-02-19T07:57:06.857", "Id": "14952504", "CommentCount": "6", "LastEditDate": "2013-02-19T10:27:37.983", "PostTypeId": "1", "LastEditorUserId": "546632", "LastActivityDate": "2013-02-19T13:26:22.653", "Score": "9", "OwnerUserId": "246776", "Tags": "<c++><downcasting>", "AnswerCount": "4"}, "14952597": {"Id": "14952597", "PostTypeId": "2", "Body": "<p>B* b = static_cast&lt; B* &gt;a or what you tried is an <strong>unsafe downcasting</strong>,it assigns the address of a base-class object (A) to a derived class (B) pointer. So if you access anything throught that pointer, it will cause undefined behavior. </p>\n<p>Let's assume one possible object layout of an instance of A:</p>\n<pre><code>a -&gt;|vptr|\n</code></pre>\n<p>When you perform a forced cast:</p>\n<pre><code>b -&gt;|vptr|\n</code></pre>\n<p>it is definitely unsafe since a doesn't point to an instance of B or subclass of B. When you call a virtual method or modify a field(not in this case), it will cause <a href=\"http://cpp-interviewquestions.blogspot.com/2010/02/upcasting-and-downcasting-in-c.html\" rel=\"nofollow\">undefined behavior</a> in general or error in this layout.  </p>\n<p>However, your method1 is non-virtual, so there is no need to look up virtual table. Since your implementation of the method1 doesn't and even can't do anything on \"this\", So when you run the code in this hypothetical object layout, it will probabaly report no error(See James' comment). </p>\n", "LastEditorUserId": "1365960", "LastActivityDate": "2013-02-19T10:09:50.120", "Score": "3", "CreationDate": "2013-02-19T08:02:50.000", "ParentId": "14952504", "CommentCount": "5", "OwnerUserId": "1365960", "LastEditDate": "2013-02-19T10:09:50.120"}, "14954413": {"Id": "14954413", "PostTypeId": "2", "Body": "<p>The pointer conversion acts as a <code>static_cast</code>. 5.2.9/2 says, </p>\n<blockquote>\n<p id=\"so_14952504_14954413_0\">If the object of type [<code>A</code>] is actually a subobject of an object of\n  type [<code>B</code>], the result refers to the enclosing object of type [<code>B</code>].\n  Otherwise, the result of the cast is unde\ufb01ned.</p>\n</blockquote>\n<p>Your object is <em>not</em> a subobject of a <code>B</code> object, so the result is undefined.</p>\n<p>Even if you were to <code>reinterpret_cast</code>, accessing the value of the object through the resulting pointer has undefined behavior because it violates strict aliasing. In the C++11 standard, 3.10/10:</p>\n<blockquote>\n<p id=\"so_14952504_14954413_1\">If a program attempts to access the stored value of an object through\n  a glvalue of other than one of the following types the behavior is\n  unde\ufb01ned:</p>\n</blockquote>\n<p>\"A derived class of the dynamic type of the object that adds no data members or virtual member functions\" is <em>not</em> in the list that follows.</p>\n<p>Depending on what <code>method1</code> actually does, it might be possible to avoid accessing the stored value of the object when calling it. But I'm not certain it's ever possible. Unless stated otherwise elsewhere in the standard I would assume for safety that calling a non-static member function inherently \"accesses the stored value of the object\" even if the function doesn't actually use any data members.</p>\n<p>This is one of those awkward cases that will probably work in practice either all the time or almost all the time. But it's not guaranteed, so even if it appears to work and the emitted code looks OK, you will live in fear that some day a new optimization will break it.</p>\n<p>Once defined, C++ classes are closed to new members, including new member functions. So your object created with <code>new A()</code> has all the member functions it will ever have. Just write a non-member function -- unless <code>A</code> has <code>protected</code> members it will have exactly the same access to <code>A</code> that your member function has. And if <code>A</code> does have <code>protected</code> members then there's an <em>approved</em> way of deriving from it, which you should use to create proper instances of <code>B</code>.</p>\n<p>If member function syntax means that much to you, then depending on the class <code>A</code> you might be able to write:</p>\n<pre><code>B b = *a;    // \"copy\" the object (give B a suitable ctor)\nb.method1(); // act on it\n*a = b;      // copy it back (A needs copy assignment operator)\n</code></pre>\n<p>Obviously there are issues here that could stop it working: to begin with whether the object is copyable, also thread-safety, and whether <code>method1</code> stores a pointer/reference to <code>b</code> somewhere that will start to dangle as soon as <code>b</code> is destroyed. In C++11 the copies could perhaps be moves for efficiency, but even so I hope you will agree that the hoops you have to jump through to use member function syntax <em>are not worth it</em>.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2013-02-19T13:26:22.653", "Score": "6", "CreationDate": "2013-02-19T09:46:17.847", "ParentId": "14952504", "CommentCount": "3", "OwnerUserId": "13005", "LastEditDate": "2013-02-19T13:26:22.653"}, "bq_ids": {"n4140": {"so_14952504_14954413_0": {"length": 12, "quality": 0.8, "section_id": 6028}, "so_14952504_14954413_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 7239}}, "n3337": {"so_14952504_14954413_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5796}, "so_14952504_14954413_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 6983}}, "n4659": {"so_14952504_14954413_0": {"length": 12, "quality": 0.8, "section_id": 7527}, "so_14952504_14954413_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 8748}}}, "14955015": {"Id": "14955015", "PostTypeId": "2", "Body": "<ol>\n<li>Yes, it is possible.</li>\n<li>No, it is not safe according to the standard; it is discouraged.</li>\n</ol>\n<p>This is more like C void* casting, which is not the best thing to do in C++. But I did this many times and it works fine.</p>\n", "LastEditorUserId": "777186", "LastActivityDate": "2013-02-19T11:01:55.800", "Score": "3", "CreationDate": "2013-02-19T10:18:41.093", "ParentId": "14952504", "CommentCount": "2", "OwnerUserId": "231388", "LastEditDate": "2013-02-19T11:01:55.800"}, "14952592": {"Id": "14952592", "PostTypeId": "2", "Body": "<p>You should read this extremely well-written post:</p>\n<p><a href=\"https://stackoverflow.com/questions/28002/regular-cast-vs-static-cast-vs-dynamic-cast\">Regular cast vs. static_cast vs. dynamic_cast</a></p>\n<p>If you use \"static_cast\", be warned that you are \"force\" converting and this is inherently unsafe.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-19T08:02:30.133", "Score": "1", "CreationDate": "2013-02-19T08:02:30.133", "ParentId": "14952504", "CommentCount": "1", "OwnerUserId": "1384030", "LastEditDate": "2017-05-23T12:23:53.600"}});