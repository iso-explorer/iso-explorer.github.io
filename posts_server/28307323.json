post_cb({"28307527": {"Id": "28307527", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_28307323_28307527_0\">Is there a flowchart that summarize all possible cases?</p>\n</blockquote>\n<p>In full generality, you would need to know the entire set of name lookup rules in C++, which is unfortunately very complicated.</p>\n<p>Assuming you just want to know what overrides what, you can find all the details in a few paragraphs in the standard.</p>\n<blockquote>\n<p id=\"so_28307323_28307527_1\">If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a class <code>Derived</code>, derived directly or indirectly\n  from <code>Base</code>, a member function vf with the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (or absence of same) as <code>Base::vf</code> is declared, then <code>Derived::vf</code> is also virtual (whether or not it is\n  so declared) and it <em>overrides</em> <code>Base::vf</code>.</p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_28307323_28307527_2\">Even though destructors are not inherited, a destructor in a derived class overrides a base class destructor\n  declared virtual; see 12.4 and 12.5.</p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_28307323_28307527_3\">The return type of an overriding function shall be either identical to the return type of the overridden\n  function or covariant with the classes of the functions. If a function <code>D::f</code> overrides a function <code>B::f</code>, the\n  return types of the functions are covariant if they satisfy the following criteria:</p>\n<ul>\n<li>both are pointers to classes, both are lvalue references to classes, or both are rvalue references to\n  classes</li>\n<li>the class in the return type of <code>B::f</code> is the same class as the class in the return type of <code>D::f</code>, or is an\n  unambiguous and accessible direct or indirect base class of the class in the return type of <code>D::f</code></li>\n<li>both pointers or references have the same cv-qualification and the class type in the return type of <code>D::f</code>\n  has the same cv-qualification as or less cv-qualification than the class type in the return type of <code>B::f</code>.</li>\n</ul>\n</blockquote>\n<p>Because <code>B::f</code> does not have the same parameter types as <code>A::f</code>, <code>B::f</code> does not override <code>A::f</code>, and for the same reason, <code>C::f</code> does not override <code>A::f</code>. Since <code>B::f</code> is not declared <code>virtual</code> <em>and</em> it does not override <code>A::f</code>, <code>B::f</code> is not virtual. <code>C::f</code> does not override <code>B::f</code> because <code>B::f</code> is not virtual.</p>\n<p>Since <code>B::f</code> is not virtual, <code>pb-&gt;f()</code> always invokes <code>B::f</code> and not any function named <code>f</code> in a derived class.</p>\n", "LastActivityDate": "2015-02-03T19:52:35.173", "CommentCount": "0", "CreationDate": "2015-02-03T19:52:35.173", "ParentId": "28307323", "Score": "1", "OwnerUserId": "481267"}, "28308320": {"Id": "28308320", "PostTypeId": "2", "Body": "<p>The output of your code is this :</p>\n<pre><code>pb-&gt;f()    B::f\npa-&gt;f(1)   D::f\n</code></pre>\n<p>Now, if we explain why by looking at the code :</p>\n<pre><code>  void main() {\n   D d;\n   C c;\n   B* pb = &amp;c;\n   pb-&gt;f();\n   A* pa = &amp;d;\n   pa-&gt;f(1);\n}\n</code></pre>\n<p><strong>pb</strong> is a pointer to the object C, which is by inheritance an object B (and also an object A, by inheritance, again). This allows this call to be legal (the compiler does not blocks you, it would otherwise).</p>\n<p>Since the value pointed to by \"pb\" is in fact an object b, it's B's function that will get executed. The compiler somehow manages to know this.</p>\n<p><strong>pa</strong> is a pointer to the object D (instanciated as a pointer to an A object). Again, the compiler allows this because in the end, D inherits from A, and will at least have some compatible methods (that you can of course use -&gt; A's methods).</p>\n<p>When the <code>f( int i )</code> method will be used, the program will know that this method was virtual on the object A. for this reason, the D's <code>f( int i )</code> method will be used instead, since it has priority (the virtual keyword specified it). </p>\n<p>If for some reason the <code>f( int i )</code> method was not implemented in the object pointed to by pa, the code would not have been able to build, with such a warning :</p>\n<pre><code>In function 'int main()': 41:15: error: no matching function for call to 'A::f(int)' 41:15: note: candidate is: 10:24: note: virtual void A::f() 10:24: note: candidate expects 0 arguments, 1 provided\n</code></pre>\n<p>If for some reason the <code>f( int i)</code> method was not virtual in A, then we would have a ambiguous situation - since two methods would have the same name. The compiler would still allow it, but A's method would have priority, since the object's pointer was instantiated as an address of an A object.</p>\n", "LastEditorUserId": "3416111", "LastActivityDate": "2015-02-03T20:52:23.650", "Score": "0", "CreationDate": "2015-02-03T20:40:45.310", "ParentId": "28307323", "CommentCount": "0", "OwnerUserId": "3416111", "LastEditDate": "2015-02-03T20:52:23.650"}, "28307417": {"Id": "28307417", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_28307323_28307417_0\">Would <code>pb-&gt;f()</code> invoke <code>C::f</code>?</p>\n</blockquote>\n<p>No, it won't.</p>\n<blockquote>\n<p id=\"so_28307323_28307417_1\">I ask it to know if <code>B::f</code> is still considered <code>virtual</code> so its derivative classes can override it, though it hides <code>A::f</code>.</p>\n</blockquote>\n<p><code>B::f()</code> is not a <code>virtual</code> member function.</p>\n<p>To make <code>B::f()</code> a virtual member function, you have to use:</p>\n<pre><code>class B : public A {\n   public:\n      // Hide A's f with new implementations\n      virtual void f() { cout &lt;&lt; \"B::f\" &lt;&lt; endl; }\n};\n</code></pre>\n<p><strong>Update</strong></p>\n<p>You updated your post with the following additional question:</p>\n<blockquote>\n<p id=\"so_28307323_28307417_2\">Would <code>pa-&gt;f(1)</code> invoke <code>A::f</code>?</p>\n</blockquote>\n<p>Yes, it would. Seen through <code>pa</code>, neither <code>B::f()</code> nor <code>C::f()</code> exist, only <code>A::f(int)</code> exists.</p>\n", "LastEditorUserId": "434551", "LastActivityDate": "2015-02-03T22:42:16.597", "Score": "2", "CreationDate": "2015-02-03T19:45:05.947", "ParentId": "28307323", "CommentCount": "3", "OwnerUserId": "434551", "LastEditDate": "2015-02-03T22:42:16.597"}, "28307323": {"ViewCount": "153", "Body": "<p>I got a little bit confused with the topic of virtual functions in c++.\nIs there a flowchart that summarize all possible cases?</p>\n<p>for example:</p>\n<pre><code>    class A {\n       public:\n          virtual void f(const int i) { cout &lt;&lt; \"A::f\" &lt;&lt; endl; }\n    };\n\n    class B : public A {\n       public:\n          // Hide A's f with new implementations\n          void f() { cout &lt;&lt; \"B::f\" &lt;&lt; endl; }\n    };\n\n    class C : public B {\n       public:\n          void f() { cout &lt;&lt; \"C::f\" &lt;&lt; endl; }\n    };\nclass D : public B { public:\n    void f(const int i) { cout &lt;&lt; \"D::f\" &lt;&lt; endl; }\n};\n\n\n    void main() {\n       D d;\n       C c;\n       B* pb = &amp;c;\n       pb-&gt;f();\n       A* pa = &amp;d;\n       A* paa = &amp;c;\n       pa-&gt;f(1);\n       paa-&gt;f(1); //in here C::f would be invoked?\n    }\n</code></pre>\n<p>In this case, <code>B</code> hides <code>A::f</code>, and <code>C</code> has an override for <code>B::f</code> with the same signature.</p>\n<p>Would <code>pb-&gt;f()</code> invoke <code>C::f</code>? \nWould <code>pa-&gt;f(1)</code> invoke <code>A::f</code>?</p>\n<p>I ask it to know if <code>B::f</code> is still considered virtual so its derivative classes can override it, though it hides <code>A::f</code>.</p>\n<p>As well as If C::f is considered virtual by default?</p>\n", "AcceptedAnswerId": "28307434", "Title": "virtual function hirarchy in c++", "CreationDate": "2015-02-03T19:39:53.087", "Id": "28307323", "CommentCount": "4", "LastEditDate": "2015-02-03T20:03:04.577", "PostTypeId": "1", "LastEditorUserId": "324922", "LastActivityDate": "2015-02-03T22:42:16.597", "Score": "1", "OwnerUserId": "324922", "Tags": "<c++><virtual>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_28307323_28307527_1": {"length": 31, "quality": 0.96875, "section_id": 7003}, "so_28307323_28307527_3": {"length": 24, "quality": 0.96, "section_id": 7008}, "so_28307323_28307527_2": {"length": 14, "quality": 0.875, "section_id": 7007}, "so_28307323_28307549_0": {"length": 31, "quality": 0.96875, "section_id": 7003}}, "n3337": {"so_28307323_28307527_3": {"length": 24, "quality": 0.96, "section_id": 6754}, "so_28307323_28307527_2": {"length": 14, "quality": 0.875, "section_id": 6753}, "so_28307323_28307549_0": {"length": 31, "quality": 0.96875, "section_id": 6749}, "so_28307323_28307527_1": {"length": 31, "quality": 0.96875, "section_id": 6749}}, "n4659": {"so_28307323_28307527_3": {"length": 23, "quality": 0.92, "section_id": 8505}, "so_28307323_28307527_2": {"length": 14, "quality": 0.875, "section_id": 8504}, "so_28307323_28307549_0": {"length": 31, "quality": 0.96875, "section_id": 8500}, "so_28307323_28307527_1": {"length": 31, "quality": 0.96875, "section_id": 8500}}}, "28307549": {"Id": "28307549", "PostTypeId": "2", "Body": "<p><code>B::f</code> does <strong>not</strong> override <code>A::f</code> because they do not have the same parameter-type-list and therefore it is also not virtual, [class.virtual]/p2:</p>\n<blockquote>\n<p id=\"so_28307323_28307549_0\">If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a member function <code>vf</code> with the same name, <strong>parameter-type-list</strong> (8.3.5), cv-qualification, and ref-qualifier (or absence of same) as <code>Base::vf</code> is declared, then <code>Derived::vf</code> is also virtual (whether or not it is so declared) and it <em>overrides</em> <code>Base::vf</code>.</p>\n</blockquote>\n<p>So a derived class method can be implicitly virtual whether or not it has the <code>virtual</code> specifier, only if it matches certain properties of the base class method. In this case <code>B::f</code> is not virtual and so <code>pb-&gt;f()</code> uses the static type of the pointer, <code>B*</code>, and calls <code>B::f</code> and not <code>C::f</code>.</p>\n", "LastActivityDate": "2015-02-03T19:53:49.580", "CommentCount": "0", "CreationDate": "2015-02-03T19:53:49.580", "ParentId": "28307323", "Score": "0", "OwnerUserId": "701092"}, "28307434": {"Id": "28307434", "PostTypeId": "2", "Body": "<p><code>A::f</code> and <code>B::f</code> are two different functions, even though they have the same name; since <code>B::f</code> was not declared as <code>virtual</code> only <code>A::f</code> is virtual - and nobody overrides it.</p>\n<p><code>pb-&gt;f()</code> uses the static type of the pointer, which is <code>B*</code>, to determine which function to call; that would be <code>B::f</code>.</p>\n", "LastActivityDate": "2015-02-03T19:46:12.100", "CommentCount": "0", "CreationDate": "2015-02-03T19:46:12.100", "ParentId": "28307323", "Score": "2", "OwnerUserId": "5987"}});