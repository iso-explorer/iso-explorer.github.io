post_cb({"bq_ids": {"n4140": {"so_25453665_25453786_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 7214}, "so_25453665_25453786_2": {"length": 27, "quality": 0.9310344827586207, "section_id": 7212}, "so_25453665_25453786_4": {"length": 13, "quality": 0.7647058823529411, "section_id": 7215}, "so_25453665_25453786_0": {"length": 14, "quality": 1.0, "section_id": 7210}, "so_25453665_25453786_1": {"length": 20, "quality": 0.7692307692307693, "section_id": 7212}}, "n3337": {"so_25453665_25453786_2": {"length": 27, "quality": 0.9310344827586207, "section_id": 6956}, "so_25453665_25453786_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 6958}, "so_25453665_25453786_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 6954}, "so_25453665_25453786_1": {"length": 20, "quality": 0.7692307692307693, "section_id": 6956}, "so_25453665_25453786_4": {"length": 13, "quality": 0.7647058823529411, "section_id": 6959}}, "n4659": {"so_25453665_25453786_2": {"length": 27, "quality": 0.9310344827586207, "section_id": 8721}, "so_25453665_25453786_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 8723}, "so_25453665_25453786_0": {"length": 14, "quality": 1.0, "section_id": 8719}, "so_25453665_25453786_1": {"length": 20, "quality": 0.7692307692307693, "section_id": 8721}, "so_25453665_25453786_4": {"length": 13, "quality": 0.7647058823529411, "section_id": 8724}}}, "25453665": {"ViewCount": "158", "Body": "<p>From</p>\n<p><a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v7v91/index.jsp?topic=/com.ibm.vacpp7a.doc/language/ref/clrc03compatible_types.htm\" rel=\"nofollow\">http://publib.boulder.ibm.com/infocenter/comphelp/v7v91/index.jsp?topic=/com.ibm.vacpp7a.doc/language/ref/clrc03compatible_types.htm</a></p>\n<p><strong><em>The presence of type specifiers in various combinations for arithmetic types may or may not     indicate different types. For example, the type signed int is the same as int, except when used as the types of bit fields; but char, signed char, and unsigned char are different types.</em></strong></p>\n<p>What is the reason for this difference between int and char with respect to type identity ?</p>\n<p>I guess the same rules apply in C++ as well. Hence adding the c++ tag as well to this question</p>\n", "AcceptedAnswerId": "25454412", "Title": "In C how is it determined if two types are identical?", "CreationDate": "2014-08-22T18:46:23.487", "Id": "25453665", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2014-08-26T10:01:41.713", "Score": "0", "OwnerUserId": "972659", "Tags": "<c++><c>", "AnswerCount": "2"}, "25453786": {"Id": "25453786", "PostTypeId": "2", "Body": "<p>From C++11: (snippets from various paragraphs in \u00a7 3.9)</p>\n<blockquote>\n<p id=\"so_25453665_25453786_0\">Plain char, signed char, and unsigned char are three distinct types, collectively called narrow character types.  </p>\n<p id=\"so_25453665_25453786_1\">There are five standard signed integer types : \u201csigned char\u201d, \u201cshort int\u201d, \u201cint\u201d, \u201clong int\u201d, and \u201clong long int\u201d.<br>\n  For each of the standard signed integer types, there exists a corresponding (but different) standard unsigned</br></p>\n<p id=\"so_25453665_25453786_2\">integer type: \u201cunsigned char\u201d, \u201cunsigned short int\u201d, \u201cunsigned int\u201d, \u201cunsigned long int\u201d,\n  and \u201cunsigned long long int\u201d, each of which occupies the same amount of storage and has the same\n  alignment requirements (3.11) as the corresponding signed integer type47;</p>\n<p id=\"so_25453665_25453786_3\">Type wchar_t is a distinct type...Types char16_t and char32_t denote distinct types...</p>\n<p id=\"so_25453665_25453786_4\">Values of type bool are either true or false.49 [ Note: There are no signed, unsigned, short, or long\n  bool types or values. \u2014end note ]</p>\n</blockquote>\n<p>\u00a7 7.1.6.2 lists a table of which keywords result in which types:</p>\n<pre><code>type-name          the type named\nsimple-template-id the type as defined in 14.2\nchar               \u201cchar\u201d\nunsigned char      \u201cunsigned char\u201d\nsigned char        \u201csigned char\u201d\nchar16_t           \u201cchar16_t\u201d\nchar32_t           \u201cchar32_t\u201d\nbool               \u201cbool\u201d\nunsigned           \u201cunsigned int\u201d\nunsigned int       \u201cunsigned int\u201d\nsigned             \u201cint\u201d\nsigned int         \u201cint\u201d\nint                \u201cint\u201d\nunsigned short int \u201cunsigned short int\u201d\nunsigned short     \u201cunsigned short int\u201d\nunsigned long int  \u201cunsigned long int\u201d\nunsigned long      \u201cunsigned long int\u201d\nunsigned long long int \u201cunsigned long long int\u201d\nunsigned long long \u201cunsigned long long int\u201d\nsigned long int    \u201clong int\u201d\nsigned long        \u201clong int\u201d\nsigned long long int \u201clong long int\u201d\nsigned long long   \u201clong long int\u201d\nlong long int      \u201clong long int\u201d\nlong long          \u201clong long int\u201d\nlong int           \u201clong int\u201d\nlong               \u201clong int\u201d\nsigned short int   \u201cshort int\u201d\nsigned short       \u201cshort int\u201d\nshort int          \u201cshort int\u201d\nshort              \u201cshort int\u201d\nwchar_t            \u201cwchar_t\u201d\nfloat              \u201cfloat\u201d\ndouble             \u201cdouble\u201d\nlong double        \u201clong double\u201d\nvoid               \u201cvoid\u201d\nauto               placeholder for a type to be deduced\ndecltype(expression) the type as defined below\n</code></pre>\n<p>As for why <code>char</code> is wierd, I'm told that origionally, there was some compiler that made <code>char</code> unsigned (before <code>unsigned</code> types were conceived of?).  The C++ standard wanted to rectify this, but didn't want to break existing code, so they made the signedness of <code>char</code> implementation defined, and added <code>signed char</code> as a separate type.</p>\n", "LastEditorUserId": "845092", "LastActivityDate": "2014-08-22T19:03:58.187", "Score": "3", "CreationDate": "2014-08-22T18:55:35.020", "ParentId": "25453665", "CommentCount": "2", "OwnerUserId": "845092", "LastEditDate": "2014-08-22T19:03:58.187"}, "25454412": {"Id": "25454412", "PostTypeId": "2", "Body": "<p>Originally C did not have <code>unsigned</code> types, so <code>char</code> was signed by default. Since the PDP-11 used 8-bit bytes and an ASCII character set, <code>char</code> objects were <a href=\"http://cm.bell-labs.com/cm/cs/who/dmr/cman.pdf\" rel=\"nofollow\">not expected to take negative values</a>:</p>\n<blockquote>\n<p id=\"so_25453665_25454412_0\">Characters (declared, and hereinafter called, <code>char</code>) are chosen from the ASCII set; they occupy the right-most seven bits of an 8-bit byte. It is also possible to interpret <code>char</code>s as signed, 2\u2019s complement 8-bit\n  numbers.</p>\n</blockquote>\n<p><code>unsigned</code> types were <a href=\"http://cm.bell-labs.com/cm/cs/who/dmr/chist.html\" rel=\"nofollow\">added around 1977</a> partially to discourage the use of pointers for unsigned arithmetic:</p>\n<blockquote>\n<p id=\"so_25453665_25454412_1\">[...] the similarity of the arithmetic properties of character pointers and unsigned integers made it hard to resist the temptation to identify them. The unsigned types were added to make unsigned arithmetic available without confusing it with pointer manipulation.</p>\n</blockquote>\n<p>The problem with making <code>char</code> signed is that in order to perform arithmetic on <code>char</code> values it is necessary to <a href=\"http://en.wikipedia.org/wiki/Sign_extension\" rel=\"nofollow\">sign-extend</a> them. This was efficient on PDP-11, which had an SXT instruction, but <a href=\"http://www.drdobbs.com/architecture-and-design/portability-the-arm-processor/184405435\" rel=\"nofollow\">not on ARM</a> (at least, not until version 4 of the ARM architecture was released in 1996):</p>\n<blockquote>\n<p id=\"so_25453665_25454412_2\">[...] you'll find no single \"load character from memory and sign extend\" in the ARM instruction set. That's why, for performance reasons, every compiler I'm aware of makes the default char type signed on x86, but unsigned on ARM. [...]</p>\n</blockquote>\n<p>Thus when C was standardized the committee had the choice of either making <code>char</code> signed - and thus forcing ARM implementations to change to become inefficient - or reflecting existing practice and making the signedness of <code>char</code> implementation-defined.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2014-08-26T10:01:41.713", "Score": "3", "CreationDate": "2014-08-22T19:38:24.303", "ParentId": "25453665", "CommentCount": "3", "OwnerUserId": "567292", "LastEditDate": "2014-08-26T10:01:41.713"}});