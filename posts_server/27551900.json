post_cb({"bq_ids": {"n4140": {"so_27551900_27552205_2": {"length": 9, "quality": 0.5294117647058824, "section_id": 1617}, "so_27551900_27552205_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 1619}}, "n3337": {"so_27551900_27552205_2": {"length": 9, "quality": 0.5294117647058824, "section_id": 1613}, "so_27551900_27552205_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 1615}}, "n4659": {"so_27551900_27552205_2": {"length": 10, "quality": 0.5882352941176471, "section_id": 1770}, "so_27551900_27552205_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 1772}}}, "27552205": {"Id": "27552205", "PostTypeId": "2", "Body": "<p><strong>tl;dr</strong> Your call to <code>glutInit</code> is wrong. See below.</p>\n<hr>\n<p>Despite what many other contributors are claiming, your individual C-strings are perfectly well NULL-terminated because in C++11 (which you're using) it is guaranteed for <code>str.operator[](str.size())</code> to evaluate to the null character:</p>\n<blockquote>\n<p id=\"so_27551900_27552205_0\"><code>[C++11: 21.4.5]:</code></p>\n<p id=\"so_27551900_27552205_1\"><code>const_reference operator[](size_type pos) const;</code><br>\n<code>reference operator[](size_type pos);</code></br></p>\n<p id=\"so_27551900_27552205_2\"><strong>1</strong> Requires: <code>pos &lt;= size().</code><br>\n<strong>2</strong> Returns: <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>, <strong>otherwise a reference to an object of type <code>T</code> with value <code>charT()</code></strong>; the referenced value shall not be modified.</br></p>\n</blockquote>\n<p><em>(Strictly speaking this doesn't state that <code>*(&amp;str.operator()(str.size()-1)+1)</code> is <code>charT()</code>, but that NULL <strong>must</strong> be stored in the actual data buffer in order for an implementation to abide by the constant-time access guarantee of the string.)</em></p>\n<p>So there is no need at all to resort to storing the result of <code>str.c_str()</code>, though that is a valid  alternative approach.</p>\n<p>And, since vectors default-initialise their members, your <code>argv</code> itself is also null-terminated.</p>\n<p>Therefore <strong>there is no problem with your vector</strong>; I cannot reproduce your problem when I abstract away OpenGL:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    std::vector&lt;std::string&gt; argv_storage;\n    for (std::size_t i = 0; i &lt; 10; ++i)\n    {\n        // I copy output of generate_rand_str() because I will need it\n        // later in the code.\n        argv_storage.push_back(std::to_string(i));\n    }\n\n    std::vector&lt;char *&gt; argv( argv_storage.size() + 1 );    // one extra for NULL\n    for (std::size_t i = 0; i != argv_storage.size(); ++i)\n    {\n        argv[i] = &amp;argv_storage[i][0];\n    }\n\n    char** test = argv.data();\n    while (*test != NULL) {\n        std::cout &lt;&lt; *(test++) &lt;&lt; ' ';\n    }\n}\n\n// 0 1 2 3 4 5 6 7 8 9\n</code></pre>\n<p>(<a href=\"http://coliru.stacked-crooked.com/a/3643863d0443610e\" rel=\"nofollow\">live demo</a>)</p>\n<p>However, <code>glutInit</code> expects a <em>pointer</em> to the data buffer size, rather than the size itself. So, when you're passing <code>argv.size()</code>, that's wrong.</p>\n<p>Try this:</p>\n<pre><code>int argv_size = argv.size();\nglutInit(&amp;argv_size, argv.data());\n</code></pre>\n</hr>", "LastEditorUserId": "560648", "LastActivityDate": "2014-12-18T17:31:24.957", "Score": "5", "CreationDate": "2014-12-18T17:20:58.390", "ParentId": "27551900", "CommentCount": "7", "OwnerUserId": "560648", "LastEditDate": "2014-12-18T17:31:24.957"}, "27552344": {"Id": "27552344", "PostTypeId": "2", "Body": "<p><code>glutInit</code> takes a <code>int *</code> as it's first argument, not an <code>int</code>. </p>\n<p>Your vector/string stuff looks messy but right. </p>\n", "LastActivityDate": "2014-12-18T17:28:43.460", "CommentCount": "4", "CreationDate": "2014-12-18T17:28:43.460", "ParentId": "27551900", "Score": "2", "OwnerUserId": "1737"}, "27551900": {"ViewCount": "97", "Body": "<p>I have heavily commented the code below with my problem. Basically the problem is that I am trying to fake <code>argv</code> by a <code>std::vector&lt;std::string&gt;</code> but I am getting a behavior from Visual Studio that is not expected by me. Could you please elaborate on what I am missing here?</p>\n<pre><code>std::vector&lt;std::string&gt; argv_storage;\nfor (std::size_t i = 0; i &lt; 10; ++i)\n{\n    // I copy output of generate_rand_str() because I will need it\n    // later in the code.\n    argv_storage.push_back( std::string( generate_rand_str() ) );\n}\n\nstd::vector&lt;char *&gt; argv( argv_storage.size() + 1 );    // one extra for NULL\nfor (std::size_t i = 0; i != argv_storage.size(); ++i)\n{\n    argv[i] = &amp;argv_storage[i][0];\n}\n\n// Here if I access elements like argv.data()[index]\n// they are perfectly fine but when I do:\n\nchar** test = argv.data();\n// Visual Studio debugger only shows argv.data()[0]\n\n// I want to pass this to glutInit() ...\nint argc = argv.size() - 1; // one less for the NULL\nglutInit(&amp;argc, argv.data());\n\n// Inspection of arguments passed to glutInit() also shows that ONLY the\n// the first element of argv is passed.\n</code></pre>\n", "AcceptedAnswerId": "27552205", "Title": "Conversion from vector<string> to char** only carries the first element", "CreationDate": "2014-12-18T17:03:23.207", "Id": "27551900", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-12-18T17:39:06.270", "LastEditorUserId": "388751", "LastActivityDate": "2014-12-18T19:28:01.807", "Score": "0", "OwnerUserId": "388751", "Tags": "<c++><c++11>", "AnswerCount": "2"}});