post_cb({"bq_ids": {"n4140": {"so_16590715_16590715_0": {"length": 43, "quality": 0.9555555555555556, "section_id": 7217}}, "n3337": {"so_16590715_16590715_0": {"length": 43, "quality": 0.9555555555555556, "section_id": 6961}}, "n4659": {"so_16590715_16590715_0": {"length": 41, "quality": 0.9111111111111111, "section_id": 8726}}}, "16590715": {"ViewCount": "265", "Body": "<p>Recently, I was reading the post: <a href=\"http://www.gotw.ca/gotw/067.htm\" rel=\"nofollow noreferrer\">Double or Nothing from GOTW by Herb Sutter</a>\nI am a little confused with the explanation of the following program:</p>\n<pre><code> int main()\n {\n     double x = 1e8;\n     while( x &gt; 0 )\n     {\n        --x;\n     }\n }\n</code></pre>\n<p>Assume that this code runs 1 second in some machine. I agree with the point that code like this is silly.</p>\n<p>However, per the explanation about the issue if we change <code>x</code> from <code>float</code> to <code>double</code>, then on some compilers, it will keep the computer running to forever. The explanation is based on the following quote from the standard.</p>\n<p><strong>Quoting from section 3.9.1/8 of the C++ standard:</strong></p>\n<blockquote>\n<p id=\"so_16590715_16590715_0\">There are three floating point types: float, double, and long double. The type double provides at least as much precision as float, and the type long double provides at least as much precision as double. The set of values of the type float is a subset of the set of values of the type double; the set of values of the type double is a subset of the set of values of the type long double.</p>\n</blockquote>\n<p>The question for the code is:</p>\n<blockquote>\n<p id=\"so_16590715_16590715_1\"><strong>How long would you expect it to take if you change \"double\" to \"float\"? Why?</strong></p>\n</blockquote>\n<p>Here is the explanation given:</p>\n<blockquote>\n<p id=\"so_16590715_16590715_2\">It will probably take either about 1 second (on a particular implementation floats may be somewhat faster, as fast, or somewhat slower than doubles), or forever, depending whether or not float can exactly represent all integer values from 0 to 1e8 inclusive.</p>\n<p id=\"so_16590715_16590715_3\">The above quote from the standard means that there may be values that can be represented by a double but that cannot be represented by a float. In particular, on some popular platforms and compilers, double can exactly represent all integer values in [0,1e8] but float cannot.</p>\n<p id=\"so_16590715_16590715_4\">What if float can't exactly represent all integer values from 0 to 1e8? Then the modified program will start counting down, but will eventually reach a value N which can't be represented and for which N-1 == N (due to insufficient floating-point precision)... and</p>\n</blockquote>\n<p>My question is:</p>\n<p><strong>If float is not even able to represent <code>1e8</code>, then we should have overflow already when we initialize <code>float x = 1e8</code>; then how come we will make the computer running forever?</strong></p>\n<p>I tried a simple example here (though not <code>double</code> but <code>int</code>)</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n   int a = 4444444444444444444;\n   std::cout &lt;&lt; \"a \" &lt;&lt; a &lt;&lt; std::endl;\n   return 0;\n}\nIt outputs: a -1357789412\n</code></pre>\n<p>This means that if the compiler is not able to represent the given number with <code>int</code> type, it will result in overflow. </p>\n<p>So did I misread? What point that I missed? Is changing <code>x</code> from <code>double</code> to <code>float</code> undefined behavior?</p>\n<p>Thank you!</p>\n", "AcceptedAnswerId": "16591015", "Title": "Understanding of Guru of the Week #67: Double or Nothing", "CreationDate": "2013-05-16T14:51:26.467", "Id": "16590715", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-05-16T19:30:44.467", "LastEditorUserId": "1774667", "LastActivityDate": "2013-05-16T19:30:44.467", "Score": "8", "OwnerUserId": "1760345", "Tags": "<c++><floating-point><precision><gotw>", "AnswerCount": "2"}, "16591015": {"Id": "16591015", "PostTypeId": "2", "Body": "<p>The key word is \"exactly\".</p>\n<p><code>float</code> can represent <code>1e8</code>, even exactly, unless you have a freak <code>float</code> type. But that doesn't mean it can represent all smaller values exactly, for example, usually <code>2^25+1 = 33554433</code>, which needs 26 bits of precision, cannot be exactly represented in <code>float</code> (usually, that has 23+1 bits of precision), nor can <code>2^25-1 = 33554431</code>, which needs 25 bits of precision.</p>\n<p>Both of these numbers are then represented as <code>2^25 = 33554432</code>, and then</p>\n<pre><code>33554432.0f - 1 == 33554432.0f\n</code></pre>\n<p>will loop. (You will hit a loop earlier, but that one has a nice decimal representation ;)</p>\n<p>In integer arithmetic, you have <code>x - 1 != x</code> for all <code>x</code>, but not in floating point arithmetic.</p>\n<p>Note that the loop might also finish even if <code>float</code> has only the usual 23+1 bits of precision, since the standard allows floating point computations to be carried out at a greater precision than the type has, and if the computation is performed at sufficiently greater precision (e.g. the usual <code>double</code> with 52+1 bits), every subtraction will change <code>x</code>.</p>\n", "LastActivityDate": "2013-05-16T15:02:48.100", "CommentCount": "3", "CreationDate": "2013-05-16T15:02:48.100", "ParentId": "16590715", "Score": "9", "OwnerUserId": "1011995"}, "16590981": {"Id": "16590981", "PostTypeId": "2", "Body": "<p>Try this simple modification that couts the value of consecutive x values. </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n {\n     float x = 1e8;\n     while( x &gt; 0 )\n     {\n        cout &lt;&lt; x &lt;&lt; endl;\n        --x;\n     }\n }\n</code></pre>\n<p>On some implementations of float you will see that the values of float are stuck at 1e8, or in that region.  This is because of the way float stores numbers.  Float cannot(and nor can any bit limited representation) represent all possible decimal values, so when you deal with very large values in float you have essentially a decimal, raized to some power.  Well, if this decimal value ends in a value where the last bit dropping off, means it gets rounded up.  What you end up with is a value that decrements down(then back up) to itself.  </p>\n", "LastActivityDate": "2013-05-16T15:01:46.580", "CommentCount": "0", "CreationDate": "2013-05-16T15:01:46.580", "ParentId": "16590715", "Score": "0", "OwnerUserId": "1467304"}});