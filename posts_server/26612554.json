post_cb({"26612762": {"ParentId": "26612554", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The assignment</p>\n<pre><code>tempCat = tempCat3\n</code></pre>\n<p>is investigated by overload resolution and rewritten as</p>\n<pre><code>tempCat.operator=(tempCat3)\n</code></pre>\n<p>Overload resolution now looks for a matching member function to call. It finds your copy assignment operator:</p>\n<pre><code>CCat&amp; operator=( CCat oldCat )\n</code></pre>\n<p>The parameter <code>oldCat</code> has to be initialized with the argument, <code>tempCat3</code>. The correct term is actually <em>copy-initialization</em>.</p>\n<blockquote>\n<p id=\"so_26612554_26612762_0\">The initialization that occurs in the form </p>\n<pre><code>T x = b;\n</code></pre>\n<p id=\"so_26612554_26612762_1\">as well as in argument passing, [\u2026] is <em>called copy-initialization</em>.</p>\n</blockquote>\n<p>copy-initialization only works with non-explicit constructors:</p>\n<blockquote>\n<p id=\"so_26612554_26612762_2\">For copy-initialization, the candidate functions are all the\n  converting constructors (12.3.1) of that class.</p>\n</blockquote>\n<p>(also called converting constructors):</p>\n<blockquote>\n<p id=\"so_26612554_26612762_3\">A constructor declared without the function-specifier <code>explicit</code>\n  specifies a conversion from the types of its parameters to the type of\n  its class. Such a constructor is called a <em>converting constructor</em>.</p>\n</blockquote>\n<p>So if you declare your copy constructor with the <code>const</code>-reference parameter as <code>explicit</code>, it isn't a converting constructor, copy-initialization doesn't work and the parameter cannot be initialized with the argument - that is also what the compiler tells us, no matching constructor was found.<br> The same applies to the other lines in <code>main</code>.</br></p>\n<p>If <code>explicit</code> is removed the initialization works just fine.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-10-28T16:02:43.310", "Id": "26612762", "Score": "1", "CreationDate": "2014-10-28T15:52:38.907", "LastActivityDate": "2014-10-28T16:02:43.310"}, "26612554": {"CommentCount": "4", "ViewCount": "199", "CreationDate": "2014-10-28T15:44:12.103", "LastActivityDate": "2014-10-28T16:02:43.310", "Title": "assignment operator by value not compiling with explicit copy constructor", "AcceptedAnswerId": "26612762", "PostTypeId": "1", "Id": "26612554", "Score": "0", "Body": "<p>I want to understand what correct parameter types should be used in an explicit copy constructor(s).</p>\n<p>As defined below, using \"explicit\", the assignment code will not compile. The assignment lines in main generate the error: 'No matching constructor for initialisation of CCat'</p>\n<p>Removal of \"explicit\" from the first copy constructor fixes the problem, but I don't understand why. </p>\n<p>The compiler is obviously doing some subtle implicit casting?</p>\n<pre><code>class CCat : public CAnimal\n{\npublic:\n    explicit CCat( string name, uint noLegs, bool fur, bool domestic, string breed );\n\n    explicit CCat( const CCat&amp; oldCat ) : CAnimal( oldCat )\n    {\n        std::cout &lt;&lt; \"\\nCCat::CCat( const CCat&amp; oldCat ) \\n\";\n    }\n    explicit CCat( CCat&amp; oldCat ) : CAnimal( oldCat )\n    {\n        std::cout &lt;&lt; \"\\nexplicit CCat::CCat( CCat&amp; oldCat ) \\n\";\n    }\n    ~CCat();\n\n    CCat&amp; operator =( CCat oldCat ){\n        //.. do assignment stuff\n        return *this;\n    }\n};\n\nint main(int argc, const char * argv[])\n{\n    CCat *cat1 = new CCat( string(\"Wiggy\"),  4, true, true, string(\"Tabby\") );\n    CCat *cat2 = new CCat( string(\"Tibles\"),  4, true, true, string(\"Tom\") );\n\n    CCat tempCat( *cat1 );\n    CCat tempCat2( *cat2 );\n    std::cout &lt;&lt; \"CCat tempCat2( *cat2 );\\n\";\n\n    const CCat&amp; tempCat3 = *cat2;\n\n    tempCat = tempCat3;    // will not compile without explicit removed from first C/Constr\n    tempCat = CCat(*cat2); // will not compile without explicit removed from first C/Constr\n    tempCat = tempCat2;    // will not compile without explicit removed from first C/Constr\n    return 0;\n}\n</code></pre>\n<p>The assignment operator (passing by value) forces the use of a copy constructor, however a perfect match cannot be found when explicit is used. So when explicit is removed what conversions is the compiler performing and how can I write a matching copy constructor?</p>\n", "Tags": "<c++><copy-constructor><assignment-operator>", "OwnerUserId": "2196409", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26612554_26612762_3": {"section_id": 388, "quality": 0.9411764705882353, "length": 16}, "so_26612554_26612762_1": {"section_id": 3294, "quality": 0.8, "length": 4}, "so_26612554_26612762_2": {"section_id": 592, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_26612554_26612762_3": {"section_id": 379, "quality": 0.9411764705882353, "length": 16}, "so_26612554_26612762_1": {"section_id": 3164, "quality": 0.8, "length": 4}, "so_26612554_26612762_2": {"section_id": 582, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_26612554_26612762_3": {"section_id": 405, "quality": 0.9411764705882353, "length": 16}, "so_26612554_26612762_1": {"section_id": 4056, "quality": 0.8, "length": 4}, "so_26612554_26612762_2": {"section_id": 615, "quality": 0.7777777777777778, "length": 7}}}});