post_cb({"14575450": {"ParentId": "14575347", "CommentCount": "1", "Body": "<p>Yes, this is valid, and Clang supports it.</p>\n<pre><code>$ clang++ your-example.cpp -std=c++11\n$ ./a.out\nMemArgs = 123\nNs = 0variadic_fun(MemArgs...) = 3\nMemArgs[Ns] = 1\nMemArgs = ABC\nNs = 1variadic_fun(MemArgs...) = 3\nMemArgs[Ns] = B\nMemArgs = XYZ\nNs = 2variadic_fun(MemArgs...) = 3\nMemArgs[Ns] = Z\n</code></pre>\n<p>The relevant rule is <strong>[temp.variadic]p5</strong>:</p>\n<blockquote>\n<p id=\"so_14575347_14575450_0\">An appearance of a name of a parameter pack that is not expanded is ill-formed.</p>\n</blockquote>\n<p>That does not apply in this case, since</p>\n<blockquote>\n<p id=\"so_14575347_14575450_1\">A parameter pack whose name appears within the pattern of a pack expansion is expanded by that pack expansion.</p>\n</blockquote>\n<p>... and the uses of the pack within the lambda are within the pattern of the function argument pack expansion.</p>\n", "OwnerUserId": "1041090", "PostTypeId": "2", "Id": "14575450", "Score": "6", "CreationDate": "2013-01-29T04:02:00.300", "LastActivityDate": "2013-01-29T04:02:00.300"}, "14575347": {"CommentCount": "2", "ViewCount": "281", "PostTypeId": "1", "LastEditorUserId": "51103", "CreationDate": "2013-01-29T03:48:44.937", "LastActivityDate": "2013-01-29T04:02:00.300", "Title": "Does C++11 allow the following nested variadic expansion within and of a lambda?", "AcceptedAnswerId": "14575450", "LastEditDate": "2013-01-29T03:58:52.310", "Id": "14575347", "Score": "4", "Body": "<p>Can anyone confirm for me that the following code (which includes nested expansions of a function parameter pack) is allowed in C++11 (I would certainly appreciate any references to the standard):</p>\n<pre><code>template&lt;class ... VFTs&gt; int variadic_fun(VFTs ... vfts) { \n  return sizeof ...(vfts); \n}\n\n\ntemplate&lt;int ... Ns&gt; struct IntPack {\n  template&lt;class ... MemTs&gt; static int variadic_memfun(MemTs ... MemArgs) {\n    return variadic_fun(([=]() {\n      cout &lt;&lt; \"MemArgs = \" &lt;&lt;  MemArgs &lt;&lt; \"\\n\";\n      cout &lt;&lt; \"Ns = \" &lt;&lt; Ns;\n      // Note the nested expansion of MemArgs here:\n      cout &lt;&lt; \"variadic_fun(MemArgs...) = \" &lt;&lt; variadic_fun(MemArgs ...) &lt;&lt; \"\\n\";\n      cout &lt;&lt; \"MemArgs[Ns] = \" &lt;&lt;  MemArgs[Ns] &lt;&lt; \"\\n\";\n      return 0;\n    })()...);\n  }  \n};\n\n\nint main() {\n  IntPack&lt;0, 1, 2&gt;::variadic_memfun(\"123\", \"ABC\", \"XYZ\");\n}\n</code></pre>\n<p>Thanks!<br>\nP.S. Since someone asked below, this code works with <a href=\"http://faisalv.github.com/clang-glambda/\" rel=\"nofollow\">my patch of clang that implements generic lambdas</a> (Not yet standard C++, still just a proposal) - I have not tried it with any other compilers - and am not sure if it works with the latest clang trunk currently (it probably does) - I would certainly welcome any information on whether it compiles with any of the mainstream compilers that implement variadics and lambdas. </br></p>\n", "Tags": "<c++><c++11><lambda><variadic-templates>", "OwnerUserId": "51103", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_14575347_14575450_1": {"section_id": 123, "quality": 1.0, "length": 12}, "so_14575347_14575450_0": {"section_id": 123, "quality": 1.0, "length": 6}}, "n3337": {"so_14575347_14575450_1": {"section_id": 117, "quality": 1.0, "length": 12}, "so_14575347_14575450_0": {"section_id": 117, "quality": 1.0, "length": 6}}, "n4659": {"so_14575347_14575450_1": {"section_id": 127, "quality": 1.0, "length": 12}, "so_14575347_14575450_0": {"section_id": 127, "quality": 1.0, "length": 6}}}});