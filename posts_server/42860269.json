post_cb({"42860269": {"CommentCount": "5", "ViewCount": "79", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-03-17T14:36:08.783", "LastActivityDate": "2017-03-17T17:35:17.847", "Title": "C++ Non-Pod starting address", "LastEditDate": "2017-05-23T11:53:50.157", "Id": "42860269", "Score": "1", "Body": "<p>In C, the first element of a struct has the same address as the struct itself.  Is the same true for non-POD structs in C++ if the first element is POD?</p>\n<p>For example, given this code:</p>\n<pre><code>struct bar\n{\n    struct bar *p1, *p2;\n    unsigned char h;\n}\n\nstruct foo\n{\n    struct bar node;\n    int a;\n\n    private:\n        int x;\n};\n\nint main(void)\n{\nstruct foo A;\nstruct bar *ptr;\n\nptr = &amp;A.node;\n\nstruct foo *n = ((struct foo*)((char*)(ptr)-(unsigned long)(&amp;((struct foo*)0)-&gt;node)));\n\nreturn 0;\n}\n</code></pre>\n<p>I get an \"invalid access to non-static data member 'foo::node' of NULL object ... perhaps the offsetof macro was used incorrectly\" warning.</p>\n<p>My question is this - can I assume that 'node' is at the beginning of foo (same address), even though this is a non-POD struct?</p>\n<p>If yes, I can just use a reinterpret cast, and I get no warning:</p>\n<pre><code>struct foo *o = reinterpret_cast&lt;struct foo*&gt;(ptr);\n</code></pre>\n<p>So, if the C++ struct starts with public POD data, will the first element share the address of the object per the standard?</p>\n<p>Thanks</p>\n<p>--edit--\n<a href=\"https://stackoverflow.com/questions/2624628/in-a-class-with-no-virtual-methods-or-superclass-is-it-safe-to-assume-address\">In a class with no virtual methods or superclass, is it safe to assume (address of first member variable) == this?</a> was pointed to as a possible answer.  It mentions \"Nonstatic data members of a (non-union) class declared without an intervening access-specifier are allo- cated so that later members have higher addresses within a class object. \"  That doesn't really address whether or not the first element in my case is the same address as the object itself.  </p>\n<p>I think since the standard does not say anything about it, I cannot assume it is the case.  I may need to change the objects at the end of the struct to pointers, and deal with allocating them as needed.</p>\n", "Tags": "<c++><struct><offsetof>", "OwnerUserId": "7727611", "AnswerCount": "2"}, "42860645": {"ParentId": "42860269", "LastEditDate": "2017-03-17T15:08:47.683", "CommentCount": "7", "CreationDate": "2017-03-17T14:53:19.670", "Score": "1", "LastEditorUserId": "4342498", "PostTypeId": "2", "Id": "42860645", "OwnerUserId": "4342498", "Body": "<p>The standard says in [class.mem]/19</p>\n<blockquote>\n<p id=\"so_42860269_42860645_0\">If a standard-layout class object has any non-static data members, its address is the same as the address of its first non-static data member. Otherwise, its address is the same as the address of its first base class subobject (if any). [ Note: There might therefore be unnamed padding within a standard-layout struct\n  object, but not at its beginning, as necessary to achieve appropriate alignment. \u2014end note ]</p>\n</blockquote>\n<p>So if the class is a <em>standard-layout class</em> which yours is not the standard guarantees the address of first member is the address of the class.  In your case it states that it is the address of it's first base class.  Since you do not have a base object that means the first member shares the address of the object as there can never be padding at the start of a object.  This means the address of a <code>foo</code> is the address of it's <code>bar</code> member and since <code>bar</code> is a standard layout class it would also be the address of <code>p1</code>.</p>\n<p>Do note though that trying to get any member after the first member is undefined behavior.  Class types (this includes <code>struct</code>) are allowed to have padding between any of the members of the class for alignment purposes.  This means you never know where exactly the other members are in relation to the first member.</p>\n", "LastActivityDate": "2017-03-17T15:08:47.683"}, "42860432": {"ParentId": "42860269", "LastEditDate": "2017-03-17T14:50:02.707", "CommentCount": "7", "CreationDate": "2017-03-17T14:44:05.810", "Score": "-3", "LastEditorUserId": "902384", "PostTypeId": "2", "Id": "42860432", "OwnerUserId": "902384", "Body": "<p>As per Slava since virtual tables can be part of struct so the short answer is no. Now vtables are not part of standard. They are just a mechanism to implement virtual thing and thus achieving polymorphism. The answer is still no for all practical reasons.</p>\n<p>Please see following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct bar\n{\n    struct bar *p1, *p2;\n    unsigned char h;\n};\n\nstruct foo\n{\n    struct bar node;\n    int a;\n\n    private:\n        int x;\n};\n\nint main(void)\n{\n    struct foo A;\n    struct bar *ptr;\n\n    A.node.p1 = new bar();\n    A.node.p2 = new bar();\n    ptr = &amp;A.node;\n\n    struct foo *n = ((struct foo*)((char*)(ptr)-(unsigned long)(&amp;((struct foo*)0)-&gt;node)));\n    cout &lt;&lt; n-&gt;a &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Code is compiled with <code>g++ -Wall -Werror -pedantic -std=c++14 test.cpp</code>. The problem is what I think is that you did not allocate memory for <code>p1</code> and <code>p2</code>.</p>\n", "LastActivityDate": "2017-03-17T14:50:02.707"}, "bq_ids": {"n4140": {"so_42860269_42860645_0": {"section_id": 5879, "quality": 0.9318181818181818, "length": 41}}, "n4659": {"so_42860269_42860645_0": {"section_id": 7363, "quality": 0.9318181818181818, "length": 41}}}});