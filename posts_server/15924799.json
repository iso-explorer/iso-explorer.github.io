post_cb({"15924799": {"CommentCount": "2", "AcceptedAnswerId": "15925165", "CreationDate": "2013-04-10T11:38:43.923", "LastActivityDate": "2013-04-10T11:57:11.287", "PostTypeId": "1", "ViewCount": "299", "FavoriteCount": "1", "Title": "Why are InputIterators one pass only?", "Id": "15924799", "Score": "1", "Body": "<p>From</p>\n<h3>24.2.3 Input iterators [input.iterators]</h3>\n<blockquote>\n<p id=\"so_15924799_15924799_0\">3) [...] Algorithms on input iterators should never attempt to pass\n  through the same iterator twice. They should be single pass algorithms. [...]</p>\n</blockquote>\n<p>This IMO restricts some fairly straight-forward optimizations (such as passing through the container once to see how many elements it has) - alas, the motivation is outside the scope of the question.</p>\n<p>Why this requirement?</p>\n", "Tags": "<c++><iterator><language-design>", "OwnerUserId": "673730", "AnswerCount": "2"}, "15925165": {"ParentId": "15924799", "CommentCount": "1", "Body": "<p>Input iterators are used to iterate over ranges that don't have a material realization (id est their elements do not actually exist somewhere in memory), like bytes from a network stream, or a sequence of random numbers from /dev/random. Consider this last example: once you consume the first random number, there is no way to retrieve it again.</p>\n<p>Forward iterators, on the other hand, provide access to ranges that either have a material realization (id est all their elements actually exist somewhere in memory) or that can be easily recomputed\u2020. By their very nature, containers usually provide forward iterators: the containers themselves are the materialization of the range.</p>\n<p>Ranges defined with input iterators can sometimes be converted to a range define with forward iterators, by simply materializing it: just use the single pass to copy the whole range into a container, and then iterate on that container as much as you like. Obviously this won't be desirable in all situations, and sometimes it is not even possible: some ranges, like the bytes from /dev/random, are infinite and can never be materialized in full.</p>\n<p>If an algorithm can be written in a single pass, there is no reason to forbid its use with input iterators. However, there is nothing that forbids such an algorithm from using an optimised version that performs multiple passes, when given forward or better iterators.</p>\n<hr>\n<p>\u2020 For instance, a range of all the even numbers does not need to materialize all numbers in a container, but one can easily start again from a given iterator since it is possible and cheap to recompute the numbers again.</p>\n</hr>", "OwnerUserId": "46642", "PostTypeId": "2", "Id": "15925165", "Score": "8", "CreationDate": "2013-04-10T11:57:11.287", "LastActivityDate": "2013-04-10T11:57:11.287"}, "15924830": {"ParentId": "15924799", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The name chosen already gives a hint as to why: think of the iterator as iterating over an <em>input stream</em> such as keyboard input or a network stream. There is no way to iterate over a stream twice, hence the restriction.</p>\n<p>In situations where optimization is desired and we don't mind upping the requirements from the iterator, a <a href=\"http://www.cplusplus.com/reference/iterator/ForwardIterator/\" rel=\"nofollow noreferrer\">forward iterator</a> or something even more powerful is the natural choice.</p>\n<p>Related question: <a href=\"https://stackoverflow.com/q/8869104/50079\">What's the difference between input iterators and read-only forward iterators?</a></p>\n", "OwnerUserId": "50079", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:17:10.753", "Id": "15924830", "Score": "4", "CreationDate": "2013-04-10T11:40:56.813", "LastActivityDate": "2013-04-10T11:40:56.813"}, "bq_ids": {"n4140": {"so_15924799_15924799_0": {"section_id": 5570, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_15924799_15924799_0": {"section_id": 5352, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_15924799_15924799_0": {"section_id": 7017, "quality": 0.9285714285714286, "length": 13}}}});