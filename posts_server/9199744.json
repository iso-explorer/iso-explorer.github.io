post_cb({"9201213": {"ParentId": "9199744", "CommentCount": "0", "Body": "<p>\u00a75.1.2/11:</p>\n<blockquote>\n<p id=\"so_9199744_9201213_0\">If a *lambda-expression( has an associated <em>capture-default</em> and its <em>compound-statement</em> odr-uses (3.2) <code>this</code> or <strong>a variable with automatic storage duration</strong> and the odr-used entity is not explicitly captured, then the odr-used entity is said to be <em>implicitly captured</em>; ...</p>\n</blockquote>\n<p>Global variables have static storage duration (\u00a73.7.1), so the global <code>a</code> will not be <em>implicitly</em> captured by value. Still, you can access a global variable anywhere, so</p>\n<pre><code>[=]() { a = 9; } ();\n</code></pre>\n<p>will set the global <code>a</code> to 9 as expected.</p>\n<p>Explicitly capturing a global should be an error or UB, because \u00a75.1.2/10 says</p>\n<blockquote>\n<p id=\"so_9199744_9201213_1\">The <em>identifiers</em> in a <em>capture-list</em> are looked up using the usual rules for unqualified name lookup (3.4.1); each such lookup shall find a variable <strong>with automatic storage duration</strong> declared in the reaching scope of the local lambda expression.</p>\n</blockquote>\n", "OwnerUserId": "224671", "PostTypeId": "2", "Id": "9201213", "Score": "24", "CreationDate": "2012-02-08T20:51:46.763", "LastActivityDate": "2012-02-08T20:51:46.763"}, "bq_ids": {"n4140": {"so_9199744_9201213_0": {"section_id": 5971, "quality": 0.55, "length": 11}, "so_9199744_9201213_1": {"section_id": 5969, "quality": 0.84, "length": 21}}, "n3337": {"so_9199744_9201213_0": {"section_id": 5739, "quality": 0.95, "length": 19}, "so_9199744_9201213_1": {"section_id": 5738, "quality": 0.92, "length": 23}}, "n4659": {"so_9199744_9201213_0": {"section_id": 7470, "quality": 0.55, "length": 11}, "so_9199744_9201213_1": {"section_id": 7467, "quality": 0.84, "length": 21}}}, "9199744": {"CommentCount": "2", "AcceptedAnswerId": "9201213", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2012-02-08T19:02:29.520", "LastActivityDate": "2013-06-09T20:07:44.243", "LastEditDate": "2012-02-08T20:25:52.977", "ViewCount": "2944", "FavoriteCount": "3", "Title": "GCC incorrectly captures global variables by reference in lambda functions?", "Id": "9199744", "Score": "12", "Body": "<p>GCC seems to incorrectly capture global variables by reference in lambda functions, even when they are specified as 'capture by value'. This code will compile and print \"a = 9\":</p>\n<pre><code>#include &lt;iostream&gt;\n\nint a = 10;\n\nint main()\n{\n    [=]() { a = 9; } ();\n    std::cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>While this code will not compile:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    int a = 10;\n    [=]() { a = 9; } (); // error: assignment of member 'main()::&lt;lambda()&gt;::a' in read-only object\n    std::cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>But explicitly capturing a global by value and then assigning to it gives the error:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint a = 10;\n\nint main()\n{\n    [a]() { a = 9; } (); // assigment of read-only object\n    std::cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>I'm pretty sure that the error is the correct behaviour -- why does the implicit capture circumvent this error? I am just exploring the new C++11 features and accidentally wrote the first piece of code (not realizing it should be an error) and was then surprised when the modifications to what I assumed was a local variable affected the global.</p>\n<p>Since it should be an error to assign to a captured-by-value variable in a lambda, GCC presumably uses a reference to the variable for optimization purposes, at least in this case, and doesn't detect the erroneous assignment.</p>\n", "Tags": "<c++><gcc><lambda><c++11>", "OwnerUserId": "1175938", "AnswerCount": "1"}});