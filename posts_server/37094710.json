post_cb({"37095223": {"ParentId": "37094710", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_37094710_37095223_0\">How can std::any avoid dynamic allocation and still destroy such\n  values if no compile time information is known at the time of\n  destruction</p>\n</blockquote>\n<p>That seems like a loaded question. The latest <a href=\"http://eel.is/c++draft/any.class\" rel=\"nofollow\">draft</a> requires this constructor:</p>\n<pre><code>template &lt;class ValueType&gt; any(ValueType &amp;&amp;value);\n</code></pre>\n<p>I can't think of why you need to have \"type erasure\" unless you want code to handle both small <em>and</em> large cases at the same time. But then why not have something like this?<sup>1</sup></p>\n<pre><code>template &lt;typename T&gt;\n  struct IsSmallObject : ...type_traits...\n</code></pre>\n<ul>\n<li>Small objects: use <a href=\"http://en.cppreference.com/w/cpp/types/aligned_storage\" rel=\"nofollow\">placement new</a> and explicit destructor calls.</li>\n<li>Large object: use an <a href=\"http://en.cppreference.com/w/cpp/concept/Allocator\" rel=\"nofollow\">allocator</a></li>\n</ul>\n<p>In the former case, you can have a pointer to your uninitialized storage:</p>\n<pre><code>union storage\n{\n    void* ptr;\n    typename std::aligned_storage&lt;3 * sizeof(void*), \n                std::alignment_of&lt;void*&gt;::value&gt;::type buffer;\n};\n</code></pre>\n<p>Using a union as <a href=\"https://stackoverflow.com/questions/37094710/how-can-i-design-storage-that-conforms-to-the-standards-implementation-of-std#comment61733126_37094710\">@KerrekSB</a> suggested.</p>\n<p>Notice that the type is not needed to be known for the storage class. Using some kind of handle/dispatch (not sure about the real name of the idiom) system it becomes trivial at this point.</p>\n<p>First let's tackle what destructing would look like:</p>\n<pre><code>  template &lt;typename T&gt;\n  struct SmallHandler\n  {\n    // ...\n\n    static void destroy(any &amp; bye)\n    {\n        T &amp; value = *static_cast&lt;T *&gt;(static_cast&lt;void*&gt;(&amp;bye.storage.buffer));\n        value.~T();\n        this.handle = nullptr;\n    }\n\n    // ...\n   };\n</code></pre>\n<p>Then the <code>any</code> class:</p>\n<pre><code>// Note, we don't need to know `T` here!\nclass any\n{\n  // ...\n\n  void clear() _NOEXCEPT\n  {\n    if (handle) this-&gt;call(destroy);\n  }\n\n  // ...\n  template &lt;class&gt;\n  friend struct SmallHandler;\n};\n</code></pre>\n<p>Here we factor out the logic that needs to know the compile-time type to a handler/dispatch system, while the bulk of the <code>any</code> class only has to deal with RTTI.</p>\n<hr/>\n<p><sup>1</sup>: Here's the conditions I would check for:</p>\n<ol>\n<li><code>nothrow_move_constructible</code></li>\n<li><code>sizeof(T) &lt;= sizeof(storage)</code>. In my case this is <code>3 * sizeof(void*)</code></li>\n<li><code>alignof(T) &lt;= alignof(storage)</code>. In my case this is <code>std::alignment_of&lt;void*&gt;::value</code></li>\n</ol>\n", "OwnerUserId": "6292850", "LastEditorUserId": "6292850", "LastEditDate": "2016-05-08T05:30:26.683", "Id": "37095223", "Score": "0", "CreationDate": "2016-05-08T01:09:01.100", "LastActivityDate": "2016-05-08T05:30:26.683"}, "37101152": {"ParentId": "37094710", "CommentCount": "0", "Body": "<p>Typically, <code>any</code> takes anything and dynamically allocates a new object from it:</p>\n<pre><code>struct any {\n    placeholder* place;\n\n    template &lt;class T&gt;\n    any(T const&amp; value) {\n        place = new holder&lt;T&gt;(value);\n    }\n\n    ~any() {\n        delete place;\n    }\n};\n</code></pre>\n<p>We use the fact that <code>placeholder</code> is polymorphic to handle all of our operations - destruction, cast, etc. But now we want to avoid allocation, which means we avoid all the nice things that polymorphism gives us - and need to reimplement them. To start with, we'll have some union:</p>\n<pre><code>union Storage {\n    placeholder* ptr;\n    std::aligned_storage_t&lt;sizeof(ptr), sizeof(ptr)&gt; buffer;\n};\n</code></pre>\n<p>where we have some <code>template &lt;class T&gt; is_small_object { ... }</code> to decide whether or not we're doing <code>ptr = new holder&lt;T&gt;(value)</code> or <code>new (&amp;buffer) T(value)</code>. But construction isn't the only thing we have to do - we also have to do destruction and type info retrieval, which look different depending on which case we're in. Either we're doing <code>delete ptr</code> or we're doing <code>static_cast&lt;T*&gt;(&amp;buffer)-&gt;~T();</code>, the latter of which depends on keeping track of <code>T</code>!</p>\n<p>So we introduce our own vtable-like thing. Our <code>any</code> will then hold onto:</p>\n<pre><code>enum Op { OP_DESTROY, OP_TYPE_INFO };\nvoid (*vtable)(Op, Storage&amp;, const std::type_info* );\nStorage storage;\n</code></pre>\n<p>You could instead create a new function pointer for each op, but there are probably several other ops that I'm missing here (e.g. <code>OP_CLONE</code>, which might call for changing the passed-in argument to be a <code>union</code>...) and you don't want to just bloat your <code>any</code> size with a bunch of function pointers. This way we lose a tiny bit of performance in exchange for a big difference in size. </p>\n<p>On construction, we then populate both the <code>storage</code> and the <code>vtable</code>:</p>\n<pre><code>template &lt;class T,\n          class dT = std::decay_t&lt;T&gt;,\n          class V = VTable&lt;dT&gt;,\n          class = std::enable_if_t&lt;!std::is_same&lt;dT, any&gt;::value&gt;&gt;\nany(T&amp;&amp; value)\n: vtable(V::vtable)\n, storage(V::create(std::forward&lt;T&gt;(value))\n{ }\n</code></pre>\n<p>where our <code>VTable</code> types are something like:</p>\n<pre><code>template &lt;class T&gt;\nstruct PolymorphicVTable {\n    template &lt;class U&gt;\n    static Storage create(U&amp;&amp; value) {\n        Storage s;\n        s.ptr = new holder&lt;T&gt;(std::forward&lt;U&gt;(value));\n        return s;\n    }\n\n    static void vtable(Op op, Storage&amp; storage, const std::type_info* ti) {\n        placeholder* p = storage.ptr;\n\n        switch (op) {\n        case OP_TYPE_INFO:\n            ti = &amp;typeid(T);\n            break;\n        case OP_DESTROY:\n            delete p;\n            break;\n        }\n    }\n};\n\ntemplate &lt;class T&gt;\nstruct InternalVTable {\n    template &lt;class U&gt;\n    static Storage create(U&amp;&amp; value) {\n        Storage s;\n        new (&amp;s.buffer) T(std::forward&lt;U&gt;(value));\n        return s;\n    }\n\n    static void vtable(Op op, Storage&amp; storage, const std::type_info* ti) {\n        auto p = static_cast&lt;T*&gt;(&amp;storage.buffer);\n\n        switch (op) {\n        case OP_TYPE_INFO:\n            ti = &amp;typeid(T);\n            break;\n        case OP_DESTROY:\n            p-&gt;~T();\n            break;\n        }\n    }\n};\n\ntemplate &lt;class T&gt;\nusing VTable = std::conditional_t&lt;sizeof(T) &lt;= 8 &amp;&amp; std::is_nothrow_move_constructible&lt;T&gt;::value,\n                   InternalVTable&lt;T&gt;,\n                   PolymorphicVTable&lt;T&gt;&gt;;\n</code></pre>\n<p>and then we just use that vtable to implement our various operations. Like:</p>\n<pre><code>~any() {\n    vtable(OP_DESTROY, storage, nullptr);\n}\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "37101152", "Score": "0", "CreationDate": "2016-05-08T14:53:31.417", "LastActivityDate": "2016-05-08T14:53:31.417"}, "37094710": {"CommentCount": "6", "ViewCount": "306", "LastEditDate": "2017-04-13T12:40:36.810", "LastEditorUserId": "-1", "CreationDate": "2016-05-07T23:30:44.770", "LastActivityDate": "2016-11-22T11:39:57.460", "PostTypeId": "1", "FavoriteCount": "1", "Title": "How can I design storage that conforms to the standard's implementation of std::any?", "Id": "37094710", "OwnerUserId": "2296177", "Body": "<p>The standard working draft (n4582, 20.6.3, p.552) states the following suggestion for implementations of <code>std::any</code>:</p>\n<blockquote>\n<p id=\"so_37094710_37094710_0\">Implementations should avoid the use of dynamically allocated memory for a small contained object. [ Example: where the object constructed is holding only an int. \u2014end example ] Such small-object optimization shall only be applied to types T for which is_nothrow_move_constructible_v is true.</p>\n</blockquote>\n<p>As far as I know, <code>std::any</code> can be easily implemented through type erasure/virtual functions and dynamically allocated memory.</p>\n<p>How can <code>std::any</code> avoid dynamic allocation and still destroy such values if no compile time information is known at the time of destruction; how would a solution that follows the standard's suggestion be designed?</p>\n<hr>\n<p>If anyone wants to see a possible implementation of the non-dynamic part, I've posted one on Code Review: <a href=\"https://codereview.stackexchange.com/questions/128011/an-implementation-of-a-static-any-type\">https://codereview.stackexchange.com/questions/128011/an-implementation-of-a-static-any-type</a></p>\n<p>It's a little too long for an answer here. It's based on the suggestions of Kerrek SB on the comments below.</p>\n</hr>", "Tags": "<c++><c++14><stdany>", "Score": "8", "AnswerCount": "3"}, "37095154": {"ParentId": "37094710", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Inspired by <a href=\"http://www.boost.org/doc/libs/1_55_0/boost/any.hpp\" rel=\"nofollow\">boost any</a> I came up with this <a href=\"http://ideone.com/OoyZSq\" rel=\"nofollow\">(test it on ideone)</a> (I created a minimal case to show how to destroy a type erased container like <code>any</code> without dynamic memory. I focused only on constructor/destructor, omitting everything else, ignoring move semantics and other things)</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nusing std::cout;\nusing std::endl;\n\nstruct A { ~A() { cout &lt;&lt; \"~A\" &lt;&lt; endl; }};\nstruct B { ~B() { cout &lt;&lt; \"~B\" &lt;&lt; endl; }};\n\nstruct Base_holder {\n  virtual ~Base_holder() {}\n};\n\ntemplate &lt;class T&gt;\nstruct Holder : Base_holder {\n  T value_;\n\n  Holder(T val) : value_{val} {}\n};\n\nstruct Any {  \n  std::aligned_storage_t&lt;64&gt; buffer_;\n  Base_holder* p_;\n\n  template &lt;class T&gt;\n  Any(T val)\n  {\n    p_ = new (&amp;buffer_) Holder&lt;T&gt;{val};\n  }\n\n  ~Any()\n  {\n    p_-&gt;~Base_holder();\n  }\n};\n\nauto main() -&gt; int\n{  \n  Any a(A{});\n  Any b(B{});\n\n  cout &lt;&lt; \"--- Now we exit main ---\" &lt;&lt; endl;\n}\n</code></pre>\n<p>The output:</p>\n<pre><code>~A\n~A\n~B\n~B\n--- Now we exit main ---\n~B\n~A\n</code></pre>\n<p>Of course the first one are temporaries being destroyed the last two prove that destruction of <code>Any</code> calls the right destructor.</p>\n<p>The trick is to have polymorphism. That's why we have <code>Base_holder</code> and <code>Holder</code>. We initialize them via placement new in a <code>std::aligned_storage</code> and we explicitly call the destructor.</p>\n<p>This is just to prove you can call the right destructor without knowing the type held by <code>Any</code>. Of course in a real implementation you would have an union for this or a pointer to a dynamically allocated memory and a boolean telling you which one you have.</p>\n", "OwnerUserId": "2805305", "LastEditorUserId": "2805305", "LastEditDate": "2016-05-08T06:28:00.527", "Id": "37095154", "Score": "-1", "CreationDate": "2016-05-08T00:58:16.087", "LastActivityDate": "2016-05-08T06:28:00.527"}, "bq_ids": {"n4659": {"so_37094710_37094710_0": {"section_id": 5308, "quality": 0.7916666666666666, "length": 19}}}});