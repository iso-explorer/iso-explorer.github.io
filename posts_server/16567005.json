post_cb({"16567005": {"CommentCount": "2", "ViewCount": "93", "CreationDate": "2013-05-15T13:54:51.030", "LastActivityDate": "2013-05-15T13:56:30.600", "Title": "Is this guaranteed to be a safe cast?", "AcceptedAnswerId": "16567025", "PostTypeId": "1", "Id": "16567005", "Score": "2", "Body": "<p>Consider the following definitions:</p>\n<pre><code>struct A {\n   // ...\n};\n\nstruct B : public A {}; // empty\n\nvoid f(B&amp; b) { /* use b */}\n\nvoid g(A&amp; a) {\n   f(static_cast&lt;B&amp;&gt;(a)); // is this a safe downcast?\n}\n\nint main() {\n   A a;\n   g(a);\n}\n</code></pre>\n<p>In the above example <code>a</code> is really an instance of <code>A</code>.</p>\n<p>Since <code>B</code> has an empty definition, I would like to know if in this specific case the call to f and its execution are undefined behaviour.</p>\n", "Tags": "<c++>", "OwnerUserId": "989331", "AnswerCount": "2"}, "16567025": {"ParentId": "16567005", "CommentCount": "3", "Body": "<p>No, that is not a legal cast, because it is being performed on an object that is not of type <code>B</code>. Your program has undefined behavior.</p>\n<p>Per paragraph 5.2.9/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16567005_16567025_0\">An lvalue of type \u201c<em>cv1</em> <code>B</code>,\u201d where <code>B</code> is a class type, can be cast to type \u201creference to cv2 <code>D</code>,\u201d where <code>D</code> is a class\n  derived (Clause 10) from <code>B</code>, if a valid standard conversion from \u201cpointer to <code>D</code>\u201d to \u201cpointer to <code>B</code>\u201d exists (4.10),\n  <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>, and <code>B</code> is neither a virtual base class\n  of <code>D</code> nor a base class of a virtual base class of <code>D</code>. The result has type \u201c<em>cv2</em> <code>D</code>.\u201d An xvalue of type \u201c<em>cv1</em> <code>B</code>\u201d\n  may be cast to type \u201crvalue reference to <em>cv2</em> <code>D</code>\u201d with the same constraints as for an lvalue of type \u201c<em>cv1</em> <code>B</code>.\u201d\n  <strong>If the object of type \u201ccv1 <code>B</code>\u201d is actually a subobject of an object of type <code>D</code>, the result refers to the enclosing\n  object of type <code>D</code>. Otherwise, the behavior is undefined</strong></p>\n</blockquote>\n", "OwnerUserId": "1932150", "PostTypeId": "2", "Id": "16567025", "Score": "6", "CreationDate": "2013-05-15T13:56:00.090", "LastActivityDate": "2013-05-15T13:56:00.090"}, "16567037": {"ParentId": "16567005", "CommentCount": "0", "Body": "<p>No. Irrespective of what you mean by <em>safe</em>, that cast is not correct, the real object is of type <code>A</code>, not <code>B</code> so you cannot downcast to <code>B</code>.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "16567037", "Score": "2", "CreationDate": "2013-05-15T13:56:30.600", "LastActivityDate": "2013-05-15T13:56:30.600"}, "bq_ids": {"n4140": {"so_16567005_16567025_0": {"section_id": 6028, "quality": 0.8450704225352113, "length": 60}}, "n3337": {"so_16567005_16567025_0": {"section_id": 5796, "quality": 0.8309859154929577, "length": 59}}, "n4659": {"so_16567005_16567025_0": {"section_id": 7527, "quality": 0.704225352112676, "length": 50}}}});