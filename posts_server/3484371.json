post_cb({"bq_ids": {"n4140": {"so_3484371_3487099_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 5999}}, "n3337": {"so_3484371_3487099_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 5767}}}, "3484371": {"ViewCount": "2283", "Body": "<p>I'm going through the full tutorial at cplusplus.com, coding and compiling each example manually. Regularly, I stumble upon something that leaves me perplexed.</p>\n<p>I am currently learning this section: <a href=\"http://www.cplusplus.com/doc/tutorial/structures/\" rel=\"noreferrer\">http://www.cplusplus.com/doc/tutorial/structures/</a> . There are some subtleties that could easily be overlooked by only reading the tutorial. The advantage of typing everything by hand is that such details do stand out.</p>\n<p>In the above page, there are two sample programs. One has this line:  </p>\n<pre><code>stringstream(mystr) &gt;&gt; yours.year;\n</code></pre>\n<p>The other one has this line:  </p>\n<pre><code>(stringstream) mystr &gt;&gt; pmovie-&gt;year;\n</code></pre>\n<p>What I don't understand is the difference (if any) between <code>function (myVar) = x;</code> and <code>(function) myVar = x;</code>.</p>\n<p>I am not doing the whole tutorial in sequential order. I checked but didn't find this addressed anywhere, though I may have missed it.</p>\n<ul>\n<li>Is there a difference?  </li>\n<li>Is there a preferred way to do it one way rather than the other?  </li>\n</ul>\n", "AcceptedAnswerId": "3487099", "Title": "What's the difference between function(myVar) and (function)myVar?", "CreationDate": "2010-08-14T17:25:47.103", "Id": "3484371", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-05-07T21:23:30.940", "LastEditorUserId": "246878", "LastActivityDate": "2013-05-07T21:23:30.940", "Score": "13", "OwnerUserId": "401523", "Tags": "<c++>", "AnswerCount": "2"}, "3484394": {"PostTypeId": "2", "Body": "<p>The page you cite is not what I would consider a authority on C++ in general.</p>\n<p>Anyway,</p>\n<blockquote>\n<p id=\"so_3484371_3484394_0\">(stringstream) mystr &gt;&gt; pmovie-&gt;year;</p>\n</blockquote>\n<p>casts a <code>std::string</code> to a <code>std::stringstream</code> object. This is a C-style cast. Rather dangerous if you don't know what you are doing. This would create a <code>stringstream</code> object and the value is extracted to <code>pmovie-&gt;year</code> next.</p>\n<blockquote>\n<p id=\"so_3484371_3484394_1\">stringstream(mystr) &gt;&gt; yours.year;</p>\n</blockquote>\n<p>Creates an anonymous <code>std::stringstream</code> object and initializes it with <code>mystr</code> and then the value is extracted to <code>pmovie-&gt;year</code>. The object vanishes at the end of its lexical scope which in this case would be the <code>;</code> at the end of the line.</p>\n<p>Not much of a difference (as others have noted so far) among the two w.r.t class objects.</p>\n<p>On the other hand, with identifiers (of functions/macros) this gets tricky: <code>function (myVar) = x;</code> works irrespective of whether <code>function</code> is an actual function or a macro. However, <code>(function) (myVar) = x;</code> only works for real functions. </p>\n<p>Some standard library identifiers are allowed to have both forms (most notably the <code>tolower</code> and friends) and therefore if you want to invoke the function always then you should go for the former. </p>\n", "LastActivityDate": "2010-08-15T13:16:39.530", "LastEditorUserId": "66692", "Id": "3484394", "CommentCount": "6", "CreationDate": "2010-08-14T17:32:15.573", "ParentId": "3484371", "Score": "4", "OwnerUserId": "66692", "LastEditDate": "2010-08-15T13:16:39.530"}, "3487099": {"PostTypeId": "2", "Body": "<p>There is no difference between <code>type(x)</code> and <code>(type)x</code>. These two are completely equivalent. Most people prefer <code>type(x)</code> for classes and <code>(type)x</code> for non-class types, but that's purely up to one's own choice. Both call constructors for classes with one argument <code>x</code>. </p>\n<p>The preferred way for classes is <code>type(x)</code>, because this allows passing more than one argument to the constructor, as in <code>type(x, y)</code>. Trying to apply the other form, <code>(type)x, y</code> will not work: It casts <code>x</code>, and then applies the comma operator and evalutes <code>y</code> in isolation. Parentheses like <code>(type)(x, y)</code> do not help: This will evaluate <code>x</code> and <code>y</code> in isolation using the comma operator and then cast <code>y</code> to <code>type</code>. </p>\n<p>For non-class types, such a cast is often too powerful. C++ has <code>static_cast&lt;type&gt;(x)</code> for roughly doing the reverse of an implicit conversion (such as casting base classes to derived classes and casting <code>void*</code> to another pointer), which often is what fits in. See <a href=\"https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-and-reinterprt-cast-be-used\">When should static_cast, dynamic_cast and reinterpret_cast be used?</a>. </p>\n<p><code>stringstream</code> is not a function, though. Doing <code>function(x)</code> will call it the function, but doing <code>(function)x</code> is illegal, beause there are two expressions next to each other, with no operator in between. </p>\n<hr>\n<p>For those who don't believe this answer, and downvote it on gut feeling, please consult the Standard at <code>5.2.3/1</code></p>\n<blockquote>\n<p id=\"so_3484371_3487099_0\">A simple-type-specifier (7.1.5) followed by a parenthesized expression-list constructs a value of the specified type given the expression list. If the expression list is a single expression, the type conversion expression is equivalent (in definedness, and if defined in meaning) to the corresponding cast expression (5.4). </p>\n</blockquote>\n</hr>", "LastActivityDate": "2010-08-15T11:40:24.460", "LastEditorUserId": "-1", "Id": "3487099", "CommentCount": "17", "CreationDate": "2010-08-15T11:08:49.807", "ParentId": "3484371", "Score": "54", "OwnerUserId": "34509", "LastEditDate": "2017-05-23T12:02:48.353"}});