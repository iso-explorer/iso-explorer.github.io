post_cb({"39659011": {"CommentCount": "0", "ViewCount": "115", "CreationDate": "2016-09-23T10:53:28.677", "LastActivityDate": "2016-09-23T11:19:08.300", "Title": "C++-conversion function template deduction, why does this work?", "AcceptedAnswerId": "39659230", "PostTypeId": "1", "Id": "39659011", "Score": "8", "Body": "<pre><code>class A\n{\n    struct B{};\npublic:\n    static void test(A::B){}\n};\n\nstruct C\n{\n    template&lt;class T&gt;\n    operator T()\n    {\n        return T();\n    }\n};\n\nint main()\n{\n    A::test(C());\n}\n</code></pre>\n<p>This code works for clang 3.7, gcc 5.1 and vc++ 14.2.<br>\n2 problems,<br>\n1. Why can template deduce the type is A::B? (so smart!)<br>\nAs far as I know, template deduce the type by return statement instead of parameter.<br>\nBut I found something interested in N4606 12.3.2 6 <code>A conversion function template shall not have a deduced return type (7.1.7.4).</code> (However, I cannot find further information about this, because 7.1.7.4 is too hard to understand.)<br>\n2. Why could conversion function template access A::B?</br></br></br></br></br></p>\n<p>Thanks.</p>\n", "Tags": "<c++><templates><type-conversion><implicit-conversion>", "OwnerUserId": "5642738", "AnswerCount": "2"}, "39659230": {"ParentId": "39659011", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2016-09-23T11:05:24.090", "Score": "4", "LastEditorUserId": "2069064", "LastEditDate": "2016-09-23T11:19:08.300", "Id": "39659230", "OwnerUserId": "2069064", "Body": "<blockquote id=\"so_39659011_39659230_0\">\n<ol>\n<li>Why can template deduce the type is A::B? (so smart!)</li>\n</ol>\n</blockquote>\n<p>Since <code>test()</code> takes an <code>A::B</code>, you need a way to convert a <code>C</code> to an <code>A::B</code>. We can attempt an initialization by conversion function, for which we have in [over.match.conv]:</p>\n<blockquote>\n<p id=\"so_39659011_39659230_1\">The conversion functions of <code>S</code> and its base classes are considered. Those non-explicit conversion\n  functions that are not hidden within <code>S</code> and yield type <code>T</code> or a type that can be converted to type <code>T</code> via\n  a standard conversion sequence (13.3.3.1.1) are candidate functions.</p>\n</blockquote>\n<p>We perform template deduction according to [temp.conv]:</p>\n<blockquote>\n<p id=\"so_39659011_39659230_2\">Template argument deduction is done by comparing the return type of the conversion function template (call\n  it P) with the type that is required as the result of the conversion (call it A; see 8.6, 13.3.1.5, and 13.3.1.6 for\n  the determination of that type) as described in 14.8.2.5.</p>\n</blockquote>\n<p>Basically, we deduce the <code>T</code> in <code>template &lt;class T&gt; operator T()</code> to be <code>A::B</code>. This is a well-formed conversion sequence, and the only viable one, so that's what happens.</p>\n<p>The line you quote, about \"deduced return type\", refers to <code>auto</code> or <code>decltype</code> in the return type. This doesn't happen here.</p>\n<blockquote id=\"so_39659011_39659230_3\">\n<ol start=\"2\">\n<li>Why could conversion function template access A::B?</li>\n</ol>\n</blockquote>\n<p>Access rules are strictly about names. The <strong>name</strong> <code>B</code>, and only the name, is private to <code>A</code>. But we're not accessing the <strong>name</strong>, we're deducing the type directly.</p>\n<p><code>B</code>'s constructor is public, so the body of the conversion function is also well-formed, so everything about the code is well-formed. </p>\n", "LastActivityDate": "2016-09-23T11:19:08.300"}, "bq_ids": {"n4140": {"so_39659011_39659230_1": {"section_id": 595, "quality": 0.9166666666666666, "length": 22}, "so_39659011_39659230_2": {"section_id": 313, "quality": 0.8695652173913043, "length": 20}}, "n3337": {"so_39659011_39659230_1": {"section_id": 585, "quality": 0.9166666666666666, "length": 22}, "so_39659011_39659230_2": {"section_id": 303, "quality": 0.7391304347826086, "length": 17}}, "n4659": {"so_39659011_39659230_1": {"section_id": 618, "quality": 0.9166666666666666, "length": 22}, "so_39659011_39659230_2": {"section_id": 321, "quality": 0.8695652173913043, "length": 20}}}, "39659249": {"ParentId": "39659011", "CommentCount": "0", "CreationDate": "2016-09-23T11:06:32.303", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "39659249", "Score": "0", "Body": "<p>To oversimplify things slightly:</p>\n<p>Making an inner class or a function private only means that the name of the class or a function can be used only by the class, and it is inaccessible otherwise. You cannot write any code that uses the name the private class or a function, outside of the class.</p>\n<p>In the shown code <code>A::B</code> is not used anywhere outside of the class.</p>\n<p>This works too, for the same exact reason:</p>\n<pre><code>class A {\n\n    class B {};\n\npublic:\n\n    B foo();\n};\n\n\nint main()\n{\n    A a;\n\n    auto bar=a.foo();\n    return 0;\n}\n</code></pre>\n<p><code>auto</code> works. <code>A::B</code> will not work.</p>\n", "LastActivityDate": "2016-09-23T11:06:32.303"}});