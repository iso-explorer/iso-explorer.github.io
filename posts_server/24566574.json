post_cb({"24566792": {"Id": "24566792", "PostTypeId": "2", "Body": "<p><code>uniform_int_distribution</code> should not be expensive to construct, so creating one every time with new limits should be OK. However, there is a way to use the same object with new limits, but it is cumbersome.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution/operator%28%29\" rel=\"nofollow noreferrer\"><code>uniform_int_distribution::operator()</code></a> has an overload that takes a <code>uniform_int_distribution::param_type</code> object which can specify the new limits to be used, but <code>param_type</code> itself is an opaque type, and there's no portable way to construct one except extracting it from an existing <code>uniform_int_distribution</code> instance. For instance, the following function can be used to construct a <code>uniform_int_distribution::param_type</code>.</p>\n<pre><code>std::uniform_int_distribution&lt;&gt;::param_type\n    make_param_type(int min, int max)\n{\n    return std::uniform_int_distribution&lt;&gt;(min, max).param();\n}\n</code></pre>\n<p>Pass these to <code>operator()</code> and the generated result will be in the specified range.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/c8c8e49fe044d12e\" rel=\"nofollow noreferrer\">Live demo</a></p>\n<p>So if you really want to reuse the same <code>uniform_int_distribution</code>, create and save multiple instance of <code>param_type</code> using the function above, and use these when calling <code>operator()</code>.</p>\n<hr>\n<p>The answer above is inaccurate, because the standard does specify that the <code>param_type</code> can be constructed from the same distribution arguments as those used by the corresponding distribution type's constructor. Thanks to @T.C. for <a href=\"https://stackoverflow.com/questions/24566574/using-c11s-random-header-what-is-the-correct-way-to-get-an-integer-between/24566792#comment38069029_24568034\">pointing this out</a>.</p>\n<p>From <em>\u00a726.5.1.6/9 [rand.req.dist]</em></p>\n<blockquote>\n<p id=\"so_24566574_24566792_0\">For each of the constructors of <code>D</code> taking arguments corresponding to parameters of the distribution, <code>P</code> shall have a corresponding constructor subject to the same requirements and taking arguments identical in number, type, and default values. <code>...</code></p>\n</blockquote>\n<p>So we don't need to construct the distribution object needlessly only to extract the <code>param_type</code>. Instead the <code>make_param_type</code> function can be modified to</p>\n<pre><code>template &lt;typename Distribution, typename... Args&gt;\ntypename Distribution::param_type make_param_type(Args&amp;&amp;... args)\n{\n  return typename Distribution::param_type(std::forward&lt;Args&gt;(args)...);\n}\n</code></pre>\n<p>which can be used as </p>\n<pre><code>make_param_type&lt;std::uniform_int_distribution&lt;&gt;&gt;(0, 10)\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/35b7c9416ec29e20\" rel=\"nofollow noreferrer\">Live demo</a></p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2014-07-04T17:25:43.460", "Score": "7", "CreationDate": "2014-07-04T04:37:25.480", "ParentId": "24566574", "CommentCount": "1", "OwnerUserId": "241631", "LastEditDate": "2017-05-23T11:52:25.333"}, "bq_ids": {"n4140": {"so_24566574_24566792_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 3518}}, "n3337": {"so_24566574_24566792_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 3383}}, "n4659": {"so_24566574_24566792_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 4281}}}, "24568034": {"Id": "24568034", "PostTypeId": "2", "Body": "<p>Answering my own question: by adapting an example found in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3551.pdf\" rel=\"nofollow\">this document</a>, the following appears to be the correct way to implement a function returning a random integer between 0 and n-1 inclusive:</p>\n<pre><code>template&lt;class URNG&gt;\nint rnd(int n, URNG &amp;engine) {\n    using dist_t = std::uniform_int_distribution&lt;&gt;;\n    using param_t = dist_t::param_type;\n\n    static dist_t dist;\n    param_t params{0,n-1};\n\n    return dist(engine, params);\n}\n</code></pre>\n<p>To make it thread-safe one must avoid the <code>static</code> declaration. One possibility is to make a convenience class along these lines, which is what I'm using in my own code:</p>\n<pre><code>template&lt;class URNG&gt;\nclass Random {\npublic:        \n    Random(): engine(std::random_device{}()) {}\n    Random(typename std::result_of&lt;URNG()&gt;::type seed): engine(seed) {}\n\n    int integer(int n) {\n        std::uniform_int_distribution&lt;&gt;::param_type params {0, n-1};\n        return int_dist(engine, params);\n    }\n\nprivate:\n    URNG engine;\n    std::uniform_int_distribution&lt;&gt; int_dist;\n};\n</code></pre>\n<p>This is instantiated with (for example) <code>Random&lt;std::default_random_engine&gt; rnd</code>, and the random integers can then be obtained with <code>rnd.integer(n)</code>. Methods for sampling from other distributions can easily be added to this class.</p>\n<p>To repeat what I said in the comments, reusing the distribution object is probably unnecessary for the specific task of uniformly sampling integers, but for other distributions I think this will be more efficient than creating it every time, because there are some algorithms for sampling from some distributions that can save CPU cycles by generating multiple values simultaneously. (In principle even <code>uniform_int_distribution</code> could do this, via SIMD vectorisation.) If you can't increase efficiency by retaining the distribution object then it's hard to imagine why they would have designed the API this way.</p>\n<p>Hooray for C++ and its needless complexity! This concludes an afternoon's work accomplishing a simple five-minute task, but at least I have a much better idea what I'm doing now.</p>\n", "LastEditorUserId": "1119340", "LastActivityDate": "2014-07-06T03:16:28.520", "Score": "7", "CreationDate": "2014-07-04T06:31:32.470", "ParentId": "24566574", "CommentCount": "9", "OwnerUserId": "1119340", "LastEditDate": "2014-07-06T03:16:28.520"}, "24579045": {"Id": "24579045", "PostTypeId": "2", "Body": "<p>The idiomatic way to generate code according to varying parameters is to create distribution objects as needed, per <a href=\"https://stackoverflow.com/questions/19036141/vary-range-of-uniform-int-distribution?rq=1\">Vary range of uniform_int_distribution</a>:</p>\n<pre><code>std::random_device rd;\nstd::default_random_engine eng{rd()};\nint n = std::uniform_int_distribution&lt;&gt;{0, A}(eng);\n</code></pre>\n<p>If you are concerned that performance may be hindered by failing to fully exploit the distribution's internal state, you can use a single distribution and pass it different parameters each time:</p>\n<pre><code>std::random_device rd;\nstd::default_random_engine eng{rd()};\nstd::uniform_int_distribution&lt;&gt; dist;\nint n = dist(eng, decltype(dist)::param_type{0, A});\n</code></pre>\n<p>If this seems complicated, consider that for most purposes you will generate random numbers according to the same distribution with the same parameters (hence the distribution constructor taking parameters); by varying parameters you are already entering into advanced territory.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-07-04T17:55:52.350", "Score": "2", "CreationDate": "2014-07-04T17:55:52.350", "ParentId": "24566574", "CommentCount": "0", "OwnerUserId": "567292", "LastEditDate": "2017-05-23T12:31:01.433"}, "24566574": {"ViewCount": "765", "Body": "<p>I'm just starting to use C++11's <code>&lt;random&gt;</code> header for the first time, but there are still some things that seem a bit mysterious. This question is about the intended, idiomatic, best-practice way to accomplish a very simple task.</p>\n<p>Currently, in one part of my code I have something like this:</p>\n<pre><code>std::default_random_engine eng {std::random_device{}()};\nstd::uniform_int_distribution&lt;&gt; random_up_to_A {0, A};\nstd::uniform_int_distribution&lt;&gt; random_up_to_B {0, B};\nstd::uniform_int_distribution&lt;&gt; random_up_to_some_other_constant {0, some_other_constant};\n</code></pre>\n<p>and then when I want an integer between 0 and B I call <code>random_up_to_B(eng)</code>. </p>\n<p>Since this is starting to look a bit silly, I want to implement a function <code>rnd</code> such that <code>rnd(n, eng)</code> returns a random integer between 0 and n.</p>\n<p>Something like the following ought to work</p>\n<pre><code>template &lt;class URNG&gt;\nint rnd(int n, URNG &amp;eng) {\n    std::uniform_int_distribution&lt;&gt; dist {0, n};\n    return dist(eng);\n}\n</code></pre>\n<p>but that involves creating a new distribution object every time, and I get the impression that's not the way you're supposed to do it.</p>\n<p>So my question is, what is the intended, best-practice way to accomplish this simple task, using the abstractions provided by the <code>&lt;random&gt;</code> header? I ask because I'm bound to want to do much more complicated things than this later on, and I want to make sure I'm using this system in the right way.</p>\n", "Title": "Using c++11's <random> header, what is the correct way to get an integer between 0 and n?", "CreationDate": "2014-07-04T04:08:34.963", "LastActivityDate": "2014-07-06T03:16:28.520", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-07-04T04:24:27.567", "LastEditorUserId": "1119340", "Id": "24566574", "Score": "15", "OwnerUserId": "1119340", "Tags": "<c++><c++11><random>", "AnswerCount": "3"}});