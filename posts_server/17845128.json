post_cb({"bq_ids": {"n4140": {"so_17845128_17845164_1": {"length": 20, "quality": 0.5263157894736842, "section_id": 5879}, "so_17845128_17845134_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 5879}, "so_17845128_17845134_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 5879}, "so_17845128_17845164_0": {"length": 56, "quality": 0.9655172413793104, "section_id": 5851}}, "n3337": {"so_17845128_17845164_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 5650}, "so_17845128_17845134_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 5650}, "so_17845128_17845134_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 5650}, "so_17845128_17845164_0": {"length": 56, "quality": 0.9655172413793104, "section_id": 5621}}, "n4659": {"so_17845128_17845134_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 7363}, "so_17845128_17845164_1": {"length": 20, "quality": 0.5263157894736842, "section_id": 7363}, "so_17845128_17845134_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 7363}, "so_17845128_17845164_0": {"length": 42, "quality": 0.7241379310344828, "section_id": 7330}}}, "17845134": {"Id": "17845134", "PostTypeId": "2", "Body": "<p>Yes, it is.</p>\n<p>It is guaranteed there is no padding before the first struct member in C and in C++ (if it is a POD).</p>\n<p>C quote:</p>\n<blockquote>\n<p id=\"so_17845128_17845134_0\">(C11, 6.7.2.1p15) \"There may be unnamed padding within a structure object, but not at its beginning.\"</p>\n</blockquote>\n<p>C++ quote:</p>\n<blockquote>\n<p id=\"so_17845128_17845134_1\">(C++11, 9.2p20) \"There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment\"</p>\n</blockquote>\n", "LastActivityDate": "2013-07-24T21:28:39.293", "CommentCount": "7", "CreationDate": "2013-07-24T21:28:39.293", "ParentId": "17845128", "Score": "16", "OwnerUserId": "1119701"}, "17845164": {"Id": "17845164", "PostTypeId": "2", "Body": "<p>In C, yes, they're the same address.  Simple, and straightforward.</p>\n<hr>\n<p>In C++, no, they're not the same address.  Base classes can (and I would suspect, do) come before all members, and virtual member functions usually add hidden data to the struct somewhere. Even more confusing, a C++ compiler may also rearrange members at will, unless the class is a standard layout type (though I don't know that any compiler does so)</p>\n<p>Finally, if the C++ struct is composed of <em>standard layout types</em>, contains no base classes nor virtual functions and all members have the same visibility, and possibly other limitations I forgot, <em>then</em> it falls back on the C rules, and requires the first member to be at the same address as the object itself.</p>\n<p>\u00a7 9.2/7  </p>\n<blockquote>\n<p id=\"so_17845128_17845164_0\">A standard-layout class is a class that:<br>\n  \u2014 has no non-static data members of type non-standard-layout class (or array of such types) or reference,<br>\n  \u2014 has no virtual functions (10.3) and no virtual base classes (10.1),<br>\n  \u2014 has the same access control (Clause 11) for all non-static data members,<br>\n  \u2014 has no non-standard-layout base classes,<br>\n  \u2014 either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and<br>\n  \u2014 has no base classes of the same type as the first non-static data member.</br></br></br></br></br></br></p>\n</blockquote>\n<p>\u00a7 9.2/20 </p>\n<blockquote>\n<p id=\"so_17845128_17845164_1\">A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note: There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment. \u2014end note ]</p>\n</blockquote>\n</hr>", "LastEditorUserId": "845092", "LastActivityDate": "2013-07-25T16:38:18.203", "Score": "44", "CreationDate": "2013-07-24T21:30:20.287", "ParentId": "17845128", "CommentCount": "6", "OwnerUserId": "845092", "LastEditDate": "2013-07-25T16:38:18.203"}, "17845128": {"ViewCount": "2588", "Body": "<p>In c/c++ (I am assuming they are the same in this regard), if I have the following:</p>\n<pre><code>struct S {\n  T a;\n  .\n  .\n  .\n} s;\n</code></pre>\n<p>Is the following guaranteed to be true?</p>\n<pre><code>(void*)&amp;s == (void*)&amp;s.a;\n</code></pre>\n<p>Or in other words, is there any kind of guarantee that there will be no padding <em>before</em> the first member?</p>\n", "AcceptedAnswerId": "17845164", "Title": "struct alignment C/C++", "CreationDate": "2013-07-24T21:27:57.820", "Id": "17845128", "CommentCount": "2", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2013-07-25T04:03:50.230", "LastEditorUserId": "1350209", "LastActivityDate": "2013-07-25T16:38:18.203", "Score": "31", "OwnerUserId": "331785", "Tags": "<c++><c><memory-layout>", "AnswerCount": "2"}});