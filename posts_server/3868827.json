post_cb({"3868844": {"ParentId": "3868827", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>No. In C, you can only get a pointer to a storage area (which means a variable, an array element, or another pointer; they call those \"l-values\"), not to any expression. You cannot get a pointer to an expressions that has no defined storage area (like an addition, or the result of a function call). It should be noted however that C++ messes these rules with references, but for the sake of clarity, I'll leave it out.</p>\n<p>Pointers aren't magical: in the end, they're just integers. Therefore, when you get the pointer of a pointer, it's just like you were getting the pointer of an integer. It has no more repercussions.</p>\n<p>For instance, if you get the pointer to <code>a</code> in your code, you're just copying this address in another variable. Nothing keeps you from changing said variable:</p>\n<pre><code>int a;\nint* p = &amp;a;\np = NULL;\n</code></pre>\n<p>And doing this, you <code>a</code> will remain unaltered. All you can change about <code>a</code> is its value. Its address is immutable. Anything else would imply that <code>&amp;a = NULL</code> (or any other pointer value) would work, which doesn't.</p>\n", "OwnerUserId": "251153", "LastEditorUserId": "251153", "LastEditDate": "2010-10-06T18:23:16.617", "Id": "3868844", "Score": "7", "CreationDate": "2010-10-06T00:58:56.743", "LastActivityDate": "2010-10-06T18:23:16.617"}, "3868871": {"ParentId": "3868827", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_3868827_3868871_0\">Would the above set b to the address of pointer or not?</p>\n</blockquote>\n<p>No, it won't. <code>&amp;(*pointer)</code> is the address of <code>a</code>, which is just a number (an r-value), and you can't take the address of or assign to an r-value. So both <code>&amp;(&amp;(*pointer))</code> and <code>&amp;(*pointer) = a</code> will not compile.</p>\n<p>The address of <code>pointer</code> is simply <code>&amp;pointer</code>, so what <em>will</em> work is <code>int **b = &amp;pointer;</code>.</p>\n", "OwnerUserId": "381345", "PostTypeId": "2", "Id": "3868871", "Score": "0", "CreationDate": "2010-10-06T01:07:05.310", "LastActivityDate": "2010-10-06T01:07:05.310"}, "3868845": {"ParentId": "3868827", "CommentCount": "4", "Body": "<p>You can't take the address of something twice, so the above code probably won't even compile (have you tried that? What happened?).</p>\n", "OwnerUserId": "893", "PostTypeId": "2", "Id": "3868845", "Score": "1", "CreationDate": "2010-10-06T00:58:57.833", "LastActivityDate": "2010-10-06T00:58:57.833"}, "3868896": {"ParentId": "3868827", "CommentCount": "0", "Body": "<p>1.No, and that make compile error at <code>int **b = &amp;(&amp;(*pointer));</code> <br>\n2.Set b to the address of pointer: <code>int **b = &amp;pointer;</code><br>\n3.<code>&amp;(*pointer) = a;</code>  -&gt; NO you cant. <code>&amp;something</code> is constant cant be changed, must be <code>*pointer = a;</code> or <code>pointer = &amp;a;</code></br></br></p>\n", "OwnerUserId": "464991", "PostTypeId": "2", "Id": "3868896", "Score": "0", "CreationDate": "2010-10-06T01:14:23.547", "LastActivityDate": "2010-10-06T01:14:23.547"}, "3868868": {"ParentId": "3868827", "CommentCount": "0", "Body": "<p>In your expression:</p>\n<p>*ptr is a lvalue\n&amp;(*ptr) is a rvalue </p>\n<p>&amp;(&amp;(*ptr)) is an ill-formed expression as you are trying to take the address of an rvalue which is not allowed in C++.</p>\n<p>Furthermore,</p>\n<p>&amp;(*pointer) = a;</p>\n<p>is ill-formed, because the type of the lhs expression is 'int *' where type of rhs expression is 'int'. C++ does not allow converting an 'int' to 'int *'</p>\n", "OwnerUserId": "418110", "PostTypeId": "2", "Id": "3868868", "Score": "0", "CreationDate": "2010-10-06T01:06:21.707", "LastActivityDate": "2010-10-06T01:06:21.707"}, "3868850": {"ParentId": "3868827", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_3868827_3868850_0\">int **b = &amp;(&amp;(*pointer));</p>\n</blockquote>\n<p>This doesn't, or shouldn't compile.</p>\n<p>You can only take the address of an l-value.  (See below for a description)</p>\n<p><strong>C++03 S5.3.1-2:</strong></p>\n<blockquote>\n<p id=\"so_3868827_3868850_1\">The result of the unary &amp; operator is\n  a pointer to its operand. The operand\n  shall be an lvalue or a qualifiedid.\n  In the first case, if the type of the\n  expression is \u201cT,\u201d the type of the\n  result is \u201cpointer to T.\u201d In\n  particular, the address of an object\n  of type \u201ccv T\u201d is \u201cpointer to cv T,\u201d\n  with the same cv-qualifiers. For a\n  qualified-id, if the member is a\n  static member of type \u201cT\u201d, the type of\n  the result is plain \u201cpointer to T.\u201d If\n  the member is a nonstatic member of\n  class C of type T, the type of the\n  result is \u201cpointer to member of class\n  C of type</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_3868827_3868850_2\">...and the reference of that is the address of a...</p>\n</blockquote>\n<p>Also you are using the term reference wrong here.  &amp; is a symbol that is used for different things.  one of those things is to declare references, an unrelated thing is the address of unary operator.  The later is not called a reference.</p>\n<hr>\n<blockquote>\n<p id=\"so_3868827_3868850_3\">Does this make sense? Could I do: <code>&amp;(*pointer) = a;</code></p>\n</blockquote>\n<p>An address of a variable, and hence <code>&amp;(*pointer)</code> or equivalently <code>&amp;a</code> are r-values.</p>\n<p>You can't assign anything to an r-avlue.  Ignoring things like const you can consider an r-value something that must appear on the right hand side.  An l-value is kind of like left hand side but really it means it can be stored in a storage location (the difference is because a const object for example can't appear on the left hand side but it is still considered an l-value).</p>\n</hr></hr>", "OwnerUserId": "3153", "LastEditorUserId": "3153", "LastEditDate": "2010-10-06T01:28:48.917", "Id": "3868850", "Score": "3", "CreationDate": "2010-10-06T01:00:52.313", "LastActivityDate": "2010-10-06T01:28:48.917"}, "3868827": {"CommentCount": "1", "AcceptedAnswerId": "3868844", "PostTypeId": "1", "LastEditorUserId": "321731", "CreationDate": "2010-10-06T00:53:38.503", "LastActivityDate": "2014-06-29T21:18:13.630", "LastEditDate": "2014-06-29T21:18:13.630", "ViewCount": "460", "FavoriteCount": "1", "Title": "How do pointers to pointers and the address-of operator work?", "Id": "3868827", "Score": "6", "Body": "<p>Take this piece of code:</p>\n<pre><code>int a;\nint *pointer = &amp;a;\n\nint **b = &amp;(&amp;(*pointer));\n</code></pre>\n<p>Would the above set <code>b</code> to the address of <code>pointer</code> or not?</p>\n<p>The reason I ask is because <code>*pointer</code> gives the value of <code>a</code>, and the reference of that is the address of <code>a</code>. Is this treated as just the address of <code>a</code>, or is it also treated as <code>pointer</code>.</p>\n<p>Does this make sense? Could I do:</p>\n<pre><code>&amp;(*pointer) = a;\n</code></pre>\n", "Tags": "<c++><c><pointers>", "OwnerUserId": "429435", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_3868827_3868850_1": {"section_id": 6066, "quality": 0.5217391304347826, "length": 24}}, "n3337": {"so_3868827_3868850_1": {"section_id": 5834, "quality": 0.5217391304347826, "length": 24}}, "n4659": {"so_3868827_3868850_1": {"section_id": 7562, "quality": 0.5434782608695652, "length": 25}}}});