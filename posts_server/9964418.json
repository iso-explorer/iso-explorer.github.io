post_cb({"9966215": {"CommentCount": "9", "CreationDate": "2012-04-01T16:48:14.710", "CommunityOwnedDate": "2012-04-01T18:50:13.817", "LastEditorUserId": "1175253", "LastActivityDate": "2012-04-08T13:59:41.330", "ParentId": "9964418", "PostTypeId": "2", "LastEditDate": "2012-04-08T13:59:41.330", "Id": "9966215", "Score": "6", "Body": "<p>Aside from the error when <code>sizeof(T) &gt; sizeof(U)</code>, the problem there could be, that the union has an appropriate and possibly higher alignment than <code>U</code>, because of <code>T</code>.\nIf you don't instantiate this union, so that its memory block is aligned (and large enough!) and then fetch the member with destination type <code>T</code>, it will break silently in the worst case.</p>\n<p>For example, an alignment error occurs, if you do the C-style cast of <code>U*</code>, where <code>U</code> requires 4 bytes alignment, to <code>dummy_union*</code>, where <code>dummy_union</code> requires alignment to 8 bytes, because <code>alignof(T) == 8</code>. After that, you possibly read the union member with type <code>T</code> aligned at 4 instead of 8 bytes.</p>\n<hr>\n<h3>Alias cast (alignment &amp; size safe reinterpret_cast for PODs only):</h3>\n<p>This proposal does explicitly violate strict aliasing, but with static assertions:</p>\n<pre><code>///@brief Compile time checked reinterpret_cast where destAlign &lt;= srcAlign &amp;&amp; destSize &lt;= srcSize\ntemplate&lt;typename _TargetPtrType, typename _ArgType&gt;\ninline _TargetPtrType alias_cast(_ArgType* const ptr)\n{\n    //assert argument alignment at runtime in debug builds\n    assert(uintptr_t(ptr) % alignof(_ArgType) == 0);\n\n    typedef typename std::tr1::remove_pointer&lt;_TargetPtrType&gt;::type target_type;\n    static_assert(std::tr1::is_pointer&lt;_TargetPtrType&gt;::value &amp;&amp; std::tr1::is_pod&lt;target_type&gt;::value, \"Target type must be a pointer to POD\");\n    static_assert(std::tr1::is_pod&lt;_ArgType&gt;::value, \"Argument must point to POD\");\n    static_assert(std::tr1::is_const&lt;_ArgType&gt;::value ? std::tr1::is_const&lt;target_type&gt;::value : true, \"const argument must be cast to const target type\");\n    static_assert(alignof(_ArgType) % alignof(target_type) == 0, \"Target alignment must be &lt;= source alignment\");\n    static_assert(sizeof(_ArgType) &gt;= sizeof(target_type), \"Target size must be &lt;= source size\");\n\n    //reinterpret cast doesn't remove a const qualifier either\n    return reinterpret_cast&lt;_TargetPtrType&gt;(ptr);\n}\n</code></pre>\n<p>Usage with pointer type argument ( like standard cast operators such as reinterpret_cast ):</p>\n<pre><code>int* x = alias_cast&lt;int*&gt;(any_ptr);\n</code></pre>\n<hr>\n<h3>Another approach (circumvents alignment and aliasing issues using a temporary union):</h3>\n<pre><code>template&lt;typename ReturnType, typename ArgType&gt;\ninline ReturnType alias_value(const ArgType&amp; x)\n{\n    //test argument alignment at runtime in debug builds\n    assert(uintptr_t(&amp;x) % alignof(ArgType) == 0);\n\n    static_assert(!std::tr1::is_pointer&lt;ReturnType&gt;::value ? !std::tr1::is_const&lt;ReturnType&gt;::value : true, \"Target type can't be a const value type\");\n    static_assert(std::tr1::is_pod&lt;ReturnType&gt;::value, \"Target type must be POD\");\n    static_assert(std::tr1::is_pod&lt;ArgType&gt;::value, \"Argument must be of POD type\");\n\n    //assure, that we don't read garbage\n    static_assert(sizeof(ReturnType) &lt;= sizeof(ArgType),\"Target size must be &lt;= argument size\");\n\n    union dummy_union\n    {\n        ArgType x;\n        ReturnType r;\n    };\n\n    dummy_union dummy;\n    dummy.x = x;\n\n    return dummy.r;\n}\n</code></pre>\n<p>Usage:</p>\n<pre><code>struct characters\n{\n    char c[5];\n};\n\n//.....\n\ncharacters chars;\n\nchars.c[0] = 'a';\nchars.c[1] = 'b';\nchars.c[2] = 'c';\nchars.c[3] = 'd';\nchars.c[4] = '\\0';\n\nint r = alias_value&lt;int&gt;(chars);\n</code></pre>\n<p>The disadvantage of this is, that the union may require more memory than actually needed for the ReturnType</p>\n<hr>\n<h3>Wrapped memcpy (circumvents alignment and aliasing issues using memcpy):</h3>\n<pre><code>template&lt;typename ReturnType, typename ArgType&gt;\ninline ReturnType alias_value(const ArgType&amp; x)\n{\n    //assert argument alignment at runtime in debug builds\n    assert(uintptr_t(&amp;x) % alignof(ArgType) == 0);\n\n    static_assert(!std::tr1::is_pointer&lt;ReturnType&gt;::value ? !std::tr1::is_const&lt;ReturnType&gt;::value : true, \"Target type can't be a const value type\");\n    static_assert(std::tr1::is_pod&lt;ReturnType&gt;::value, \"Target type must be POD\");\n    static_assert(std::tr1::is_pod&lt;ArgType&gt;::value, \"Argument must be of POD type\");\n\n    //assure, that we don't read garbage\n    static_assert(sizeof(ReturnType) &lt;= sizeof(ArgType),\"Target size must be &lt;= argument size\");\n\n    ReturnType r;\n    memcpy(&amp;r,&amp;x,sizeof(ReturnType));\n\n    return r;\n}\n</code></pre>\n<p>For dynamic sized arrays of any POD type:</p>\n<pre><code>template&lt;typename ReturnType, typename ElementType&gt;\nReturnType alias_value(const ElementType* const array,const size_t size)\n{\n    //assert argument alignment at runtime in debug builds\n    assert(uintptr_t(array) % alignof(ElementType) == 0);\n\n    static const size_t min_element_count = (sizeof(ReturnType) / sizeof(ElementType)) + (sizeof(ReturnType) % sizeof(ElementType) != 0 ? 1 : 0);\n\n    static_assert(!std::tr1::is_pointer&lt;ReturnType&gt;::value ? !std::tr1::is_const&lt;ReturnType&gt;::value : true, \"Target type can't be a const value type\");\n    static_assert(std::tr1::is_pod&lt;ReturnType&gt;::value, \"Target type must be POD\");\n    static_assert(std::tr1::is_pod&lt;ElementType&gt;::value, \"Array elements must be of POD type\");\n\n    //check for minimum element count in array\n    if(size &lt; min_element_count)\n        throw std::invalid_argument(\"insufficient array size\");\n\n    ReturnType r;\n    memcpy(&amp;r,array,sizeof(ReturnType));\n    return r;\n}\n</code></pre>\n<p>More efficient approaches may do explicit unaligned reads with intrinsics, like the ones from SSE, to extract primitives.</p>\n<hr>\n<h3>Examples:</h3>\n<pre><code>struct sample_struct\n{\n    char c[4];\n    int _aligner;\n};\n\nint test(void)\n{\n    const sample_struct constPOD    = {};\n    sample_struct pod               = {};\n    const char* str                 = \"abcd\";\n\n    const int* constIntPtr  = alias_cast&lt;const int*&gt;(&amp;constPOD);\n    void* voidPtr           = alias_value&lt;void*&gt;(pod);\n    int intValue            = alias_value&lt;int&gt;(str,strlen(str));\n\n    return 0;\n}\n</code></pre>\n<hr>\n<p>EDITS:</p>\n<ul>\n<li>Assertions to assure conversion of PODs only, may be improved.</li>\n<li>Removed superfluous template helpers, now using tr1 traits only</li>\n<li>Static assertions for clarification and prohibition of const value (non-pointer) return type</li>\n<li>Runtime assertions for debug builds</li>\n<li>Added const qualifiers to some function arguments</li>\n<li>Another type punning function using memcpy</li>\n<li>Refactoring</li>\n<li>Small example</li>\n</ul>\n</hr></hr></hr></hr></hr>", "OwnerUserId": "1175253"}, "9966370": {"ParentId": "9964418", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_9964418_9966370_0\">My question is, just to be sure, is this program legal according to the standard?</p>\n</blockquote>\n<p>No. The alignment may be unnatural using the alias you have provided. The union you wrote just moves the point of the alias. It may appear to work, but that program may fail when CPU options, ABI, or compiler settings change.</p>\n<blockquote>\n<p id=\"so_9964418_9966370_1\">And if not, how could one modify this to be legal?</p>\n</blockquote>\n<p>Create natural temporary variables and treat your storage as a memory blob (moving in and out of the blob to/from temporaries), or use a union which represents all your types (remember, one active element at a time here).</p>\n", "OwnerUserId": "191596", "LastEditorUserId": "191596", "LastEditDate": "2012-04-01T22:06:31.503", "Id": "9966370", "Score": "2", "CreationDate": "2012-04-01T17:08:20.633", "LastActivityDate": "2012-04-01T22:06:31.503"}, "9964418": {"CommentCount": "25", "ViewCount": "5560", "PostTypeId": "1", "LastEditorUserId": "718379", "CreationDate": "2012-04-01T12:34:11.950", "LastActivityDate": "2012-08-27T14:09:34.107", "Title": "strict aliasing and alignment", "FavoriteCount": "10", "LastEditDate": "2012-08-27T14:09:34.107", "Id": "9964418", "Score": "19", "Body": "<p>I need a safe way to alias between arbitrary POD types, conforming to ISO-C++11 explicitly considering 3.10/10 and 3.11 of n3242 or later.\nThere are a lot of questions about strict aliasing here, most of them regarding C and not C++. I found a \"solution\" for C which uses unions, probably using this section</p>\n<blockquote>\n<p id=\"so_9964418_9964418_0\">union type that includes one of the aforementioned types among its\n  elements or nonstatic data members</p>\n</blockquote>\n<p>From that I built this.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T, typename U&gt;\nT&amp; access_as(U* p)\n{\n    union dummy_union\n    {\n        U dummy;\n        T destination;\n    };\n\n    dummy_union* u = (dummy_union*)p;\n\n    return u-&gt;destination;\n}\n\nstruct test\n{\n    short s;\n    int i;\n};\n\nint main()\n{\n    int buf[2];\n\n    static_assert(sizeof(buf) &gt;= sizeof(double), \"\");\n    static_assert(sizeof(buf) &gt;= sizeof(test), \"\");\n\n    access_as&lt;double&gt;(buf) = 42.1337;\n    std::cout &lt;&lt; access_as&lt;double&gt;(buf) &lt;&lt; '\\n';\n\n    access_as&lt;test&gt;(buf).s = 42;\n    access_as&lt;test&gt;(buf).i = 1234;\n\n    std::cout &lt;&lt; access_as&lt;test&gt;(buf).s &lt;&lt; '\\n';\n    std::cout &lt;&lt; access_as&lt;test&gt;(buf).i &lt;&lt; '\\n';\n}\n</code></pre>\n<p>My question is, just to be sure, is this program legal according to the standard?<sup>*</sup></p>\n<p>It doesn't give any warnings whatsoever and works fine when compiling with MinGW/GCC 4.6.2 using:</p>\n<pre><code>g++ -std=c++0x -Wall -Wextra -O3 -fstrict-aliasing -o alias.exe alias.cpp\n</code></pre>\n<p><sup>*</sup> Edit: And if not, how could one modify this to be legal?</p>\n", "Tags": "<c++><c++11><unions><strict-aliasing><type-punning>", "OwnerUserId": "941699", "AnswerCount": "4"}, "9966013": {"ParentId": "9964418", "CommentCount": "12", "Body": "<p>I think that at the most fundamental level, this is impossible and violates strict aliasing. The only thing you've achieved is tricking the compiler into not noticing.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "9966013", "Score": "4", "CreationDate": "2012-04-01T16:20:16.147", "LastActivityDate": "2012-04-01T16:20:16.147"}, "bq_ids": {"n4140": {"so_9964418_9964418_0": {"section_id": 7239, "quality": 1.0, "length": 12}}, "n3337": {"so_9964418_9964418_0": {"section_id": 6983, "quality": 1.0, "length": 12}}, "n4659": {"so_9964418_9964418_0": {"section_id": 8748, "quality": 1.0, "length": 12}}}, "9974573": {"ParentId": "9964418", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This will never be legal, no matter what kind of contortions you perform with weird casts and unions and whatnot.</p>\n<p>The fundamental fact is this: two objects of different type may never alias in memory, with a few special exceptions (see further down).</p>\n<h1>Example</h1>\n<p>Consider the following code:</p>\n<pre><code>void sum(double&amp; out, float* in, int count) {\n    for(int i = 0; i &lt; count; ++i) {\n        out += *in++;\n    }\n}\n</code></pre>\n<p>Let's break that out into local register variables to model actual execution more closely:</p>\n<pre><code>void sum(double&amp; out, float* in, int count) {\n    for(int i = 0; i &lt; count; ++i) {\n        register double out_val = out; // (1)\n        register double in_val = *in; // (2)\n        register double tmp = out_val + in_val;\n        out = tmp; // (3)\n        in++;\n    }\n}\n</code></pre>\n<p>Suppose that (1), (2) and (3) represent a memory read, read and write, respectively, which can be very expensive operations in such a tight inner loop. A reasonable optimization for this loop would be the following:</p>\n<pre><code>void sum(double&amp; out, float* in, int count) {\n    register double tmp = out; // (1)\n    for(int i = 0; i &lt; count; ++i) {\n        register double in_val = *in; // (2)\n        tmp = tmp + in_val;\n        in++;\n    }\n    out = tmp; // (3)\n}\n</code></pre>\n<p>This optimization reduces the number of memory reads needed by half and the number of memory writes to 1. This can have a huge impact on the performance of the code and is a very important optimization for all optimizing C and C++ compilers.</p>\n<p>Now, suppose that we don't have strict aliasing. Suppose that a write to an object of any type can affect any other object. Suppose that writing to a double can affect the value of a float somewhere. This makes the above optimization suspect, because it's possible the programmer has in fact intended for out and in to alias so that the sum function's result is more complicated and is affected by the process. Sounds stupid? Even so, the compiler cannot distinguish between \"stupid\" and \"smart\" code. The compiler can only distinguish between well-formed and ill-formed code. If we allow free aliasing, then the compiler must be conservative in its optimizations and must perform the extra store (3) in each iteration of the loop.</p>\n<p>Hopefully you can see now why no such union or cast trick can possibly be legal. You cannot circumvent fundamental concepts like this by sleight of hand.</p>\n<h1>Exceptions to strict aliasing</h1>\n<p>The C and C++ standards make special provision for aliasing any type with <code>char</code>, and with any \"related type\" which among others includes derived and base types, and members, because being able to use the address of a class member independently is so important. You can find an exhaustive list of these provisions in <a href=\"https://stackoverflow.com/a/7005988/1307714\">this answer.</a></p>\n<p>Furthermore, GCC makes special provision for reading from a different member of a union than what was last written to. Note that this kind of conversion-through-union does not in fact allow you to violate aliasing. Only one member of a union is allowed to be active at any one time, so for example, even with GCC the following would be undefined behavior:</p>\n<pre><code>union {\n    double d;\n    float f[2];\n};\nf[0] = 3.0f;\nf[1] = 5.0f;\nsum(d, f, 2); // UB: attempt to treat two members of\n              // a union as simultaneously active\n</code></pre>\n<h1>Workarounds</h1>\n<p>The only standard way to reinterpret the bits of one object as the bits of an object of some other type is to use an equivalent of <code>memcpy</code>. This makes use of the special provision for aliasing with <code>char</code> objects, in effect allowing you to read and modify the underlying <em>object representation</em> at the byte level. For example, the following is legal, and does not violate strict aliasing rules:</p>\n<pre><code>int a[2];\ndouble d;\nstatic_assert(sizeof(a) == sizeof(d));\nmemcpy(a, &amp;d, sizeof(d));\n</code></pre>\n<p>This is semantically equivalent to the following code:</p>\n<pre><code>int a[2];\ndouble d;\nstatic_assert(sizeof(a) == sizeof(d));\nfor(size_t i = 0; i &lt; sizeof(a); ++i)\n   ((char*)a)[i] = ((char*)&amp;d)[i];\n</code></pre>\n<p>GCC makes a provision for reading from an inactive union member, implicitly making it active. From the <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html\" rel=\"nofollow noreferrer\">GCC documentation:</a></p>\n<blockquote>\n<p id=\"so_9964418_9974573_0\">The practice of reading from a different union member than the one most recently written to (called \u201ctype-punning\u201d) is common. Even with -fstrict-aliasing, type-punning is allowed, provided the memory is accessed through the union type. So, the code above will work as expected. See Structures unions enumerations and bit-fields implementation. However, this code might not:</p>\n</blockquote>\n<pre><code>int f() {\n    union a_union t;\n    int* ip;\n    t.d = 3.0;\n    ip = &amp;t.i;\n    return *ip;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_9964418_9974573_1\">Similarly, access by taking the address, casting the resulting pointer and dereferencing the result has undefined behavior, even if the cast uses a union type, e.g.:</p>\n</blockquote>\n<pre><code>int f() {\n    double d = 3.0;\n    return ((union a_union *) &amp;d)-&gt;i;\n} \n</code></pre>\n<h1>Placement new</h1>\n<p>(Note: I'm going by memory here as I don't have access to the standard right now).\nOnce you placement-new an object into a storage buffer, the lifetime of the underlying storage objects ends implicitly. This is similar to what happens when you write to a member of a union:</p>\n<pre><code>union {\n    int i;\n    float f;\n} u;\n\n// No member of u is active. Neither i nor f refer to an lvalue of any type.\nu.i = 5;\n// The member u.i is now active, and there exists an lvalue (object)\n// of type int with the value 5. No float object exists.\nu.f = 5.0f;\n// The member u.i is no longer active,\n// as its lifetime has ended with the assignment.\n// The member u.f is now active, and there exists an lvalue (object)\n// of type float with the value 5.0f. No int object exists.\n</code></pre>\n<p>Now, let's look at something similar with placement-new:</p>\n<pre><code>#define MAX_(x, y) ((x) &gt; (y) ? (x) : (y))\n// new returns suitably aligned memory\nchar* buffer = new char[MAX_(sizeof(int), sizeof(float))];\n// Currently, only char objects exist in the buffer.\nnew (buffer) int(5);\n// An object of type int has been constructed in the memory pointed to by buffer,\n// implicitly ending the lifetime of the underlying storage objects.\nnew (buffer) float(5.0f);\n// An object of type int has been constructed in the memory pointed to by buffer,\n// implicitly ending the lifetime of the int object that previously occupied the same memory.\n</code></pre>\n<p>This kind of implicit end-of-lifetime can only occur for types with trivial constructors and destructors, for obvious reasons.</p>\n", "OwnerUserId": "1307714", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:34:01.780", "Id": "9974573", "Score": "13", "CreationDate": "2012-04-02T10:16:12.663", "LastActivityDate": "2012-04-02T13:28:39.887"}});