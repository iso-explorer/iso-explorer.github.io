post_cb({"bq_ids": {"n4140": {"so_27301135_27301428_1": {"length": 18, "quality": 0.9, "section_id": 603}, "so_27301135_27301428_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 625}, "so_27301135_27301428_4": {"length": 15, "quality": 0.9375, "section_id": 300}}, "n3337": {"so_27301135_27301428_1": {"length": 18, "quality": 0.9, "section_id": 593}, "so_27301135_27301428_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 615}, "so_27301135_27301428_4": {"length": 15, "quality": 0.9375, "section_id": 291}}, "n4659": {"so_27301135_27301428_1": {"length": 18, "quality": 0.9, "section_id": 629}, "so_27301135_27301428_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 651}, "so_27301135_27301428_4": {"length": 15, "quality": 0.9375, "section_id": 307}}}, "27301135": {"ViewCount": "110", "Body": "<p>I have the following sample code:</p>\n<pre><code>class Serializable {};\n\nclass MyData : public Serializable {};\n\nvoid GetData( Serializable&amp; ) {}\n\ntemplate&lt;typename T&gt;\nvoid GetData( T&amp; data )\n{\n    std::istringstream s{\"test\"};\n    s &gt;&gt; data;\n}\n\nint main()\n{\n    MyData d;\n    GetData(d);\n}\n</code></pre>\n<p>(<a href=\"http://coliru.stacked-crooked.com/a/714cccdfa131169e\" rel=\"nofollow\">Live Sample</a>)</p>\n<p>Based on overload resolution rules, the non-template version should be preferred because the base class is of type <code>Serializable</code>. However, I expect SFINAE to kick in when there are errors in the template version when it is instantiated for overload resolution (because if the &gt;&gt; operator is not defined for a type, it should not be considered).</p>\n<p>Why is it still failing even though the template won't be used?</p>\n", "AcceptedAnswerId": "27301428", "Title": "Does SFINAE apply to function bodies?", "CreationDate": "2014-12-04T18:17:57.047", "Id": "27301135", "CommentCount": "1", "LastEditDate": "2016-03-18T10:57:54.630", "PostTypeId": "1", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-18T10:57:54.630", "Score": "2", "OwnerUserId": "157971", "Tags": "<c++><templates><language-lawyer><overload-resolution><upcasting>", "AnswerCount": "1"}, "27301428": {"Id": "27301428", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27301135_27301428_0\">Based on overload resolution rules, the non-template version should be\n  preferred because the base class is of type <code>Serializable</code>.</p>\n</blockquote>\n<p>Not quite. [over.match.best]:</p>\n<blockquote>\n<p id=\"so_27301135_27301428_1\">Given these definitions, a viable function <code>F1</code> is defined to be a\n  better function than another viable function <code>F2</code> if for all arguments\n  i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<ul>\n<li>for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), <strong>or, if not that,</strong></li>\n<li>[\u2026]</li>\n<li><code>F1</code> is not a function template specialization and <code>F2</code> is a function template specialization [\u2026]</li>\n</ul>\n</blockquote>\n<p>That means that only if the deduced specialization of the function template necessitates a conversion that isn't better than the conversion that the normal function necessitates, your rule applies.\nAnd the binding of <code>d</code> to <code>Serializable&amp;</code> is a worse conversion than the binding of d to <code>MyData&amp;</code> (which is the type of the parameter of the specialization), [over.ics.ref]:</p>\n<blockquote>\n<p id=\"so_27301135_27301428_2\">When a parameter of reference type binds directly (8.5.3) to an\n  argument expression, <strong>the implicit conversion sequence is the identity\n  conversion, unless the argument expression has a type that is a\n  derived class of the parameter type, in which case the implicit\n  conversion sequence is a derived-to-base Conversion (13.3.3.1).</strong></p>\n</blockquote>\n<p>\n<blockquote>\n<p id=\"so_27301135_27301428_3\">However, I expect SFINAE to kick in when there are errors in the\n  template version when it is instantiated for overload resolution\n  (because if the &gt;&gt; operator is not defined for a type, it should not\n  be considered).</p>\n</blockquote>\n<p>SFINAE doesn't apply for the content of a function template. [temp.deduct]/8:</p>\n<blockquote>\n<p id=\"so_27301135_27301428_4\">Only invalid types and expressions <strong>in the immediate context of the\n  function type and its template parameter types</strong> can result in a\n  deduction failure.</p>\n</blockquote>\n<p>Hence the deduced specialization of the function template is indeed chosen, and causes a compiler error while instantiating its definition.</p>\n</p>", "LastEditorUserId": "3647361", "LastActivityDate": "2014-12-04T18:40:52.560", "Score": "3", "CreationDate": "2014-12-04T18:35:46.217", "ParentId": "27301135", "CommentCount": "2", "OwnerUserId": "3647361", "LastEditDate": "2014-12-04T18:40:52.560"}});