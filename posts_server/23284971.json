post_cb({"23284971": {"CommentCount": "5", "AcceptedAnswerId": "23286933", "PostTypeId": "1", "LastEditorUserId": "557981", "CreationDate": "2014-04-25T05:40:20.420", "LastActivityDate": "2014-04-28T02:10:17.927", "LastEditDate": "2014-04-28T02:10:17.927", "ViewCount": "550", "FavoriteCount": "2", "Title": "Does std::function allow an implicit cast from reference to copy in its return type?", "Id": "23284971", "Score": "13", "Body": "<p>In the code snipped below, the compiler silently casts the return-by-copy function pointer into a return-by-const-reference std::function. When the std::function instance is called, a reference to the copy is returned and the application crashes (most of the time ;). </p>\n<p>By the way of comparison, ordinary function pointers don't allow this implicit cast, so I wonder if I should go off complaining to the compiler vendor (gcc 4.8 in this case), or is this behaviour mandated by the standard?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\ntypedef std::function&lt;const std::string&amp;(const std::string&amp; x)&gt; F;\n\nstd::string bad(const std::string&amp; x) { return x; }\nconst std::string&amp; good(const std::string&amp; x) { return x; }\n\ntypedef const std::string&amp; (*FP)(const std::string&amp;);\n\nint main(int, char**) {\n    std::cout &lt;&lt; F(&amp;good)(\"hello\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; F(&amp;bad)(\"hello\") &lt;&lt; std::endl;\n\n    FP a = &amp;good;\n    // FP b = &amp;bad;  Not allowed!\n\n    return 0;\n}\n</code></pre>\n<hr>\n<p>P.S. This is a simplified version of a real world problem, where <code>bad</code> was actually a lambda returning a member of some type:</p>\n<pre><code>typedef std::function&lt;const std::string&amp;(const X&amp; x)&gt; F;\nF f = [](const X&amp; x) { return x-&gt;member(); };\n</code></pre>\n<p>It took us a while to figure out that the return type of this lambda was deduced to <code>std::string</code>, not <code>const std::string&amp;</code>, and that this was causing a crash.</p>\n</hr>", "Tags": "<c++><c++11><std-function><return-by-reference>", "OwnerUserId": "557981", "AnswerCount": "1"}, "23286933": {"ParentId": "23284971", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This looks like a kind of corner case. The constructor definition in \u00a72.8.11.2.1/7 says:</p>\n<blockquote>\n<p id=\"so_23284971_23286933_0\"><em>Requires:</em> <code>F</code> shall be <code>CopyConstructible</code>. <code>f</code> shall be Callable (20.8.11.2) for argument types ArgTypes\n  and return type R. [...]</p>\n</blockquote>\n<p>\u00a72.8.11.2/2 says:</p>\n<blockquote>\n<p id=\"so_23284971_23286933_1\">A callable object <code>f</code> of type <code>F</code> is Callable for argument types <code>ArgTypes</code> and return type <code>R</code> if the expres-\n  sion <code>INVOKE (f, declval&lt;ArgTypes&gt;()..., R)</code>, considered as an unevaluated operand (Clause 5), is well\n  formed (20.8.2).</p>\n</blockquote>\n<p>and last \u00a720.8.2/2 says:</p>\n<blockquote>\n<p id=\"so_23284971_23286933_2\">Define INVOKE (f, t1, t2, ..., tN, R) as INVOKE (f, t1, t2, ..., tN) implicitly converted to R.</p>\n</blockquote>\n<p>Obviously <code>T</code> implicitly converts to <code>T const &amp;</code> and so in absence of further restriction, the <em>constructor should be allowed.</em></p>\n<p>However calling such function involves taking returning reference to a temporary whose life ends before the reference is even returned, which is Undefined Behaviour. And when something is Undefined Behaviour, the implementation may do whatever it pleases. Unfortunately the undefined behaviour only happens at invoking, so it's still not strictly conforming to detect it at construction time.</p>\n<p>Because calling it is the only use of the object, it would be better, if it was prohibited. So this <em>should be considered defect in the specification.</em></p>\n<p>In any case, I'd recommend bringing it up on appropriate gcc mailing list. The maintainers be willing to diverge from the specification slightly in case like this or at least they could raise or help you raise the issue with the C++ committee as they work with it regularly.</p>\n", "OwnerUserId": "201725", "LastEditorUserId": "201725", "LastEditDate": "2014-04-25T12:15:30.937", "Id": "23286933", "Score": "6", "CreationDate": "2014-04-25T07:36:40.310", "LastActivityDate": "2014-04-25T12:15:30.937"}, "bq_ids": {"n4140": {"so_23284971_23286933_1": {"section_id": 4651, "quality": 0.7368421052631579, "length": 14}, "so_23284971_23286933_0": {"section_id": 4660, "quality": 0.6666666666666666, "length": 6}}, "n3337": {"so_23284971_23286933_1": {"section_id": 4462, "quality": 0.7368421052631579, "length": 14}, "so_23284971_23286933_0": {"section_id": 4470, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_23284971_23286933_1": {"section_id": 6020, "quality": 0.6842105263157895, "length": 13}, "so_23284971_23286933_0": {"section_id": 6020, "quality": 0.5555555555555556, "length": 5}}}});