post_cb({"41505189": {"ParentId": "41505121", "LastEditDate": "2017-05-23T11:52:53.077", "CommentCount": "5", "CreationDate": "2017-01-06T11:56:24.920", "OwnerUserId": "598696", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "41505189", "Score": "6", "Body": "<p>My previous explanation was incorrect - as <a href=\"https://stackoverflow.com/questions/41505121/function-overloads-priority-references/41505189?noredirect=1#comment70277564_41505189\"><strong>T.C. mentioned in the comments</strong></a>, both overloads have the same <em>implicit conversion sequence</em>, and the disambiguation happens as a special tie-breaker defined in the standard.</p>\n<hr>\n<blockquote>\n<p id=\"so_41505121_41505189_0\"><strong>\u00a713.3.3.1.4</strong> <a href=\"https://timsong-cpp.github.io/cppwp/over.best.ics#over.ics.ref\" rel=\"nofollow noreferrer\">[over.ics.ref]</a>, par. 1</p>\n<blockquote>\n<p id=\"so_41505121_41505189_2\"><strong>When a parameter of reference type binds directly</strong> ([dcl.init.ref]) <strong>to an argument expression, the implicit conversion sequence is the identity conversion, unless the argument expression has a type that is a derived class of the parameter type</strong>, in which case the implicit conversion sequence is a derived-to-base Conversion ([over.best.ics]). [...]</p>\n</blockquote>\n</blockquote>\n<p>If the argument types are the same, the <em>implicit conversion sequence</em> applied to both overloads is the <em>identity conversion</em>. This does not yet disambiguate the two functions.</p>\n<p>The disambiguation is specified as a tie-breaker here:</p>\n<blockquote>\n<p id=\"so_41505121_41505189_3\"><strong>\u00a713.3.3.2</strong> <a href=\"https://timsong-cpp.github.io/cppwp/over.ics.rank#3.2.3\" rel=\"nofollow noreferrer\">[over.ics.rank]</a>, par 3.2.3</p>\n<blockquote>\n<p id=\"so_41505121_41505189_5\"><em>[Standard conversion sequence <strong>S1 is a better conversion sequence than standard conversion sequence S2 if</strong>...]</em> <strong>S1 and S2 are reference binding</strong> ([dcl.init.ref]) and neither refers to an implicit object parameter of a non-static member function declared without a ref-qualifier, <strong>and S1 binds an rvalue reference to an rvalue and S2 binds an lvalue reference</strong>. [...]</p>\n</blockquote>\n</blockquote>\n<p>The quotes imply that, in the case of two <em>identity implicit conversion sequences</em>:</p>\n<ul>\n<li><p>The sequence binding an rvalue to rvalue reference is the best one.</p></li>\n<li><p>The sequence binding an rvalue to an lvalue reference is worse than the aforementioned one.</p></li>\n</ul>\n<hr>\n<blockquote>\n<p id=\"so_41505121_41505189_6\"><em>[...] if S1 and S2 are reference binding [...]</em></p>\n</blockquote>\n<p>The reason why <code>const</code> is required to bind rvalues to <code>const&amp;</code> can be found here:</p>\n<blockquote>\n<p id=\"so_41505121_41505189_7\"><strong>\u00a78.6.3</strong> <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init.ref#5.2\" rel=\"nofollow noreferrer\">[dcl.init.ref]</a>, par 5.2</p>\n<blockquote>\n<p id=\"so_41505121_41505189_12\"><strong>A reference to type \u201ccv1 T1\u201d is initialized by an expression of type \u201ccv2 T2\u201d as follows:</strong> </p>\n<p id=\"so_41505121_41505189_13\"><em>[If the reference is an lvalue reference and the initializer expression...]</em></p>\n<p id=\"so_41505121_41505189_14\"><strong>Otherwise, the reference shall be an lvalue reference to a non-volatile const type</strong> (i.e., cv1 shall be const), <strong>or the reference shall be an rvalue reference.</strong></p>\n<p id=\"so_41505121_41505189_15\"><strong>If the initializer expression</strong> [...] <strong>is an rvalue</strong> (but not a bit-field) <strong>or function lvalue and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2\u201d</strong></p>\n</blockquote>\n</blockquote>\n</hr></hr>", "LastActivityDate": "2017-01-08T18:53:07.000"}, "41505121": {"CommentCount": "0", "CreationDate": "2017-01-06T11:52:09.570", "PostTypeId": "1", "AcceptedAnswerId": "41505189", "LastEditorUserId": "963864", "LastActivityDate": "2017-01-08T18:53:07.000", "LastEditDate": "2017-01-08T10:23:52.087", "ViewCount": "108", "FavoriteCount": "1", "Title": "Function overloads priority (references)", "Id": "41505121", "Score": "4", "Body": "<pre><code>void func(const int &amp;) { std::cout &lt;&lt; \"c lv ref\\n\"; }\nvoid func(int &amp;&amp;) { std::cout &lt;&lt; \"rv ref\\n\"; }\n\nfunc(1);\n</code></pre>\n<p>Since const lvalue reference is able to accept every kind of data (const and non- lval, const and non- rvalue), I wonder what is the guarantee that the code above will print \"rv ref\". Is it standardized or compiler dependent?</p>\n", "Tags": "<c++><reference><language-lawyer><rvalue-reference><function-overloading>", "OwnerUserId": "5538150", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41505121_41505189_1": {"section_id": 625, "quality": 0.9285714285714286, "length": 26}, "so_41505121_41505189_5": {"section_id": 639, "quality": 0.896551724137931, "length": 26}, "so_41505121_41505189_2": {"section_id": 625, "quality": 0.9285714285714286, "length": 26}, "so_41505121_41505189_14": {"section_id": 3321, "quality": 0.9166666666666666, "length": 11}, "so_41505121_41505189_8": {"section_id": 3321, "quality": 0.75, "length": 6}, "so_41505121_41505189_9": {"section_id": 3321, "quality": 1.0, "length": 5}, "so_41505121_41505189_12": {"section_id": 3321, "quality": 0.75, "length": 6}, "so_41505121_41505189_15": {"section_id": 3321, "quality": 0.8, "length": 8}, "so_41505121_41505189_10": {"section_id": 3321, "quality": 0.9166666666666666, "length": 11}, "so_41505121_41505189_4": {"section_id": 639, "quality": 0.896551724137931, "length": 26}, "so_41505121_41505189_11": {"section_id": 3321, "quality": 0.8, "length": 8}, "so_41505121_41505189_13": {"section_id": 3321, "quality": 1.0, "length": 5}}, "n3337": {"so_41505121_41505189_1": {"section_id": 615, "quality": 0.9285714285714286, "length": 26}, "so_41505121_41505189_5": {"section_id": 629, "quality": 0.896551724137931, "length": 26}, "so_41505121_41505189_2": {"section_id": 615, "quality": 0.9285714285714286, "length": 26}, "so_41505121_41505189_14": {"section_id": 3191, "quality": 0.9166666666666666, "length": 11}, "so_41505121_41505189_8": {"section_id": 3191, "quality": 0.75, "length": 6}, "so_41505121_41505189_9": {"section_id": 3191, "quality": 1.0, "length": 5}, "so_41505121_41505189_12": {"section_id": 3191, "quality": 0.75, "length": 6}, "so_41505121_41505189_15": {"section_id": 3191, "quality": 0.7, "length": 7}, "so_41505121_41505189_10": {"section_id": 3191, "quality": 0.9166666666666666, "length": 11}, "so_41505121_41505189_4": {"section_id": 629, "quality": 0.896551724137931, "length": 26}, "so_41505121_41505189_11": {"section_id": 3191, "quality": 0.7, "length": 7}, "so_41505121_41505189_13": {"section_id": 3191, "quality": 1.0, "length": 5}}, "n4659": {"so_41505121_41505189_1": {"section_id": 651, "quality": 0.9285714285714286, "length": 26}, "so_41505121_41505189_5": {"section_id": 667, "quality": 0.896551724137931, "length": 26}, "so_41505121_41505189_2": {"section_id": 651, "quality": 0.9285714285714286, "length": 26}, "so_41505121_41505189_14": {"section_id": 4087, "quality": 0.9166666666666666, "length": 11}, "so_41505121_41505189_8": {"section_id": 4087, "quality": 0.75, "length": 6}, "so_41505121_41505189_9": {"section_id": 4087, "quality": 1.0, "length": 5}, "so_41505121_41505189_12": {"section_id": 4087, "quality": 0.75, "length": 6}, "so_41505121_41505189_15": {"section_id": 4087, "quality": 0.8, "length": 8}, "so_41505121_41505189_10": {"section_id": 4087, "quality": 0.9166666666666666, "length": 11}, "so_41505121_41505189_4": {"section_id": 667, "quality": 0.896551724137931, "length": 26}, "so_41505121_41505189_11": {"section_id": 4087, "quality": 0.8, "length": 8}, "so_41505121_41505189_13": {"section_id": 4087, "quality": 1.0, "length": 5}}}});