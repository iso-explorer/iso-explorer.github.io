post_cb({"25037314": {"ViewCount": "1835", "Body": "<p>I'm trying to interface a C++ class (e.g., <code>class foo</code>) to C. What I have done so far is to define a C structure that holds an opaque pointer member variable (i.e., <code>void*</code>), that points to the associated C++ <code>foo</code> object.</p>\n<pre><code>struct C_foo {\n  void *foo_obj;\n};\n</code></pre>\n<p>I defined an <code>alloc()</code> C interface function that allocates objects of type <code>C_foo</code>:</p>\n<pre><code>struct C_foo* alloc(/* input */) {\n  struct C_foo *out = new struct C_foo;\n  out-&gt;foo_obj      = new foo(/* input */);\n\n  return out;\n};\n</code></pre>\n<p>What I want to do now, is to create a <code>dealloc()</code> C interface function that will properly deallocate objects of type <code>C_foo</code> previously allocated with <code>alloc()</code> shown above:</p>\n<pre><code>void dealloc(struct C_foo *obj) {\n  /* ??? */\n}\n</code></pre>\n<p>I know that explicitly deleting the <code>void*</code> pointer (i.e., <code>delete obj-&gt;foo_obj;</code>) would results in undefined behaviour (<em>\u00a7 5.3.5/1 [expr.delete]</em>):</p>\n<blockquote>\n<p id=\"so_25037314_25037314_0\"><em>The <code>delete</code>-expression\u2019s result has type <code>void</code> [81].</em></p>\n<p id=\"so_25037314_25037314_1\"><em>[81] This implies that an object cannot be deleted using a pointer of type</em> <em><code>void*</code></em> <em>because <code>void</code> is not an object type</em>.</p>\n</blockquote>\n<h2>Question:</h2>\n<p>How I'm going to properly deallocate a <code>struct C_foo</code> object?</p>\n", "AcceptedAnswerId": "25037360", "Title": "How to properly delete an object that is a void pointer?", "CreationDate": "2014-07-30T12:50:47.447", "Id": "25037314", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-07-30T14:03:34.357", "Score": "1", "OwnerUserId": "2352671", "Tags": "<c++><c><pointers><void-pointers>", "AnswerCount": "5"}, "25037778": {"Id": "25037778", "PostTypeId": "2", "Body": "<p>If you need to pass around opaque handles because of some C API, and your objects have totally disparate types, you can use an approach like the one outlined below.</p>\n<p>Note that if your types all <em>share a common base</em>, you can just provide a virtual destructor for the base, <code>static_cast</code> the <code>void*</code> to a pointer to base, then <code>delete</code> that. This is a much more common approach than the one I outline below.</p>\n<h2>The handle struct</h2>\n<p>This will need to hold a pointer to the object yuo allocated, and a pointer to something that encodes the type (so that you can delete it):</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>struct Handle {\n    void* handle;\n    void* deleter_info;\n};\n</code></pre>\n<h2>The C++ Implementation Detail</h2>\n<p>You'll have some classes; these are the things you want to pass around handles to instances of...</p>\n<pre><code>class Foo;\nclass Bar;\n// etc\n</code></pre>\n<p>You'll also need a base class for your deleter:</p>\n<pre><code>struct deleter_base {\n    virtual void destroy(Handle h) = 0;\n    virtual ~deleter_base() {}\n};\n</code></pre>\n<p>... and a class template to produce derived classes that know the relevant type:</p>\n<pre><code>template&lt;typename T&gt; struct deleter {\n    virtual void destroy(Handle h)\n    {\n        T* ptr = static_cast&lt;T*&gt;(h.handle);\n        delete ptr;\n    }\n};\n</code></pre>\n<h2>Creating objects</h2>\n<p>For each type you want to provide handles to, you'll need a function to create a handle:</p>\n<pre><code>Handle create_foo_handle()\n{\n    Handle h = {0};\n    h.ptr = new foo;\n    h.deleter_info = new deleter&lt;foo&gt;;\n    return h;\n}\n\nHandle create_bar_handle()\n{\n    Handle h = {0};\n    h.ptr = new bar;\n    h.deleter_info = new deleter&lt;bar&gt;;\n    return h;\n}\n</code></pre>\n<h2>Destroying objects</h2>\n<p>You'll need a destroy function:</p>\n<pre><code>void destroy(Handle h)\n{\n    deleter_base* deleter = static_cast&lt;deleter_base*&gt;(h.deleter_info);\n    deleter-&gt;destroy(h); // delete the foo, or bar, or whatever\n    delete deleter; // delete the deleter\n}\n</code></pre>\n<h2>Notes</h2>\n<p>The struct could hold a <code>deleter_base* deleter_info</code> as opposed to <code>void* deleter_info</code>. This is really a matter of taste, and whether you want a <code>struct deleter_info;</code> in your C API. Storing it in a <code>void*</code> hides the implementation details, making it truly opaque.</p>\n<p>To be able to use the handle meaningfully, you'll also need to encode some other information to be able to retrieve something useful from the <code>void* handle</code> member. Typically, variant types do this with an enum member. Alternatively, you could hope your users are smart enough to only pass their handles back to a function that expects a handle of the correct type. You could have different handle struct types (<code>struct HandleFoo;</code>, <code>struct HandleBar;</code>, ...) to enforce this, and still use <code>void*</code> members internally to maintain opacity.</p>\n", "LastEditorUserId": "3852968", "LastActivityDate": "2014-07-30T13:26:43.960", "Score": "4", "CreationDate": "2014-07-30T13:13:46.967", "ParentId": "25037314", "CommentCount": "3", "LastEditDate": "2014-07-30T13:26:43.960", "OwnerUserId": "3852968"}, "25037360": {"Id": "25037360", "PostTypeId": "2", "Body": "<p>If you know (for sure) what type it points to, then cast:</p>\n<pre><code>delete static_cast&lt;foo*&gt;(obj-&gt;foo_obj);\n</code></pre>\n<p>If you've lost track of the type, then you'll need to redesign.</p>\n", "LastActivityDate": "2014-07-30T12:53:02.800", "Score": "11", "CreationDate": "2014-07-30T12:53:02.800", "ParentId": "25037314", "CommentCount": "2", "OwnerUserId": "204847"}, "25037803": {"Id": "25037803", "PostTypeId": "2", "Body": "<p>Create a common base class with a virtual destructor, and use that instead of void*.</p>\n<p>You could do something like the following.</p>\n<pre><code>class GenericBase\n{\npublic:\n    virtual ~GenericBase() = 0;\n};\n\ninline GenericBase::~GenericBase() {} // or put in source file without inline\n\ntemplate&lt;class T&gt;\nclass GenericWrapper : public GenericBase\n{\npublic:\n    typedef T Type;\n    Type x;\n\n    GenericWrapper() {}\n    GenericWrapper(const Type&amp; x) : x(x) {}\n};\n</code></pre>\n<p>You can use dynamic_cast to convert GenericBase* to a concrete type, in order to benefit from safety-checking.</p>\n<p>I just noticed you want to use this with C. Obviously you can't pass a <code>GenericBase*</code> to C. But you can pass it to C as a <code>void*</code> and cast back to <code>GenericBase*</code> when you need to delete it.</p>\n", "LastActivityDate": "2014-07-30T13:14:58.967", "Score": "1", "CreationDate": "2014-07-30T13:14:58.967", "ParentId": "25037314", "CommentCount": "0", "OwnerUserId": "2068573"}, "25037365": {"Id": "25037365", "PostTypeId": "2", "Body": "<p>Cast to the right type:</p>\n<pre><code>delete static_cast&lt;foo*&gt;(obj-&gt;foo_obj);\n</code></pre>\n", "LastActivityDate": "2014-07-30T12:53:20.620", "Score": "3", "CreationDate": "2014-07-30T12:53:20.620", "ParentId": "25037314", "CommentCount": "2", "OwnerUserId": "2382136"}, "bq_ids": {"n4140": {"so_25037314_25037314_0": {"length": 4, "quality": 0.8, "section_id": 6105}, "so_25037314_25037314_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 6105}}, "n3337": {"so_25037314_25037314_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 5871}}, "n4659": {"so_25037314_25037314_0": {"length": 4, "quality": 0.8, "section_id": 7602}, "so_25037314_25037314_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 7602}}}, "25038251": {"Id": "25038251", "PostTypeId": "2", "Body": "<p>I will assume that you always put an instance of the same type into that <code>void*</code>.</p>\n<p>In which case, <code>pImpl</code> time:</p>\n<pre><code>struct foo_impl; // note, just a name\nstruct C_foo {\n  foo_impl *foo_obj; // can use pointers to undefined structs in both C and C++\n};\n</code></pre>\n<p>now most of your problem goes away.  C treats <code>foo_obj</code> as an opaque pointer.</p>\n<p>In C++ we include another header file (sample fields):</p>\n<pre><code>// in C++ **only** header file -- C does not see this:\nstruct foo_impl {\n  int x;\n  std::vector&lt;double&gt; v;\n  foo_impl( int, double const* b, double const* e ); // constructor\n};\n\n// functions exposed to C, but implemented in C++ with visibility of the above foo_impl\nextern \"C\" struct C_foo* alloc(int x, double const* b, double const* e) {\n struct C_foo *out = new struct C_foo;\n out-&gt;foo_obj      = new foo_impl(x, b, e);\n\n return out;\n};\n\nextern \"C\" void dealloc(struct C_foo *obj) {\n  delete obj-&gt;foo_obj;\n  delete obj;\n}\n</code></pre>\n<p>and you win.</p>\n<p>Note that a <code>struct</code> is just a name for a <code>class</code> in C++ with default <code>public</code> instead of default <code>private</code>.</p>\n<p>I changed the name from <code>foo</code> to <code>foo_impl</code>, and created some sample data in it.</p>\n<p>If you could put more than one different kind of type into your <code>void*</code>, I would first advise putting a pure-virtual interface class with a virtual destructor, and basically following the above steps.</p>\n<hr>\n<p>Now, there are cases where you actually want to store more than one distinct, unrelated type in your opaque pointer.  These are not that common.  But in those cases, we will want to store a destroy function.</p>\n<p>Again, prefer my above approach, but if it doesn't work, we have this one.</p>\n<p>There are a few ways to store the deleter function:</p>\n<pre><code>typedef void(*foo_deleter)(void*);\nstruct C_foo {\n  void* foo_obj;\n  foo_deleter* deleter;\n};\n</code></pre>\n<p>another approach is:</p>\n<pre><code>struct foo_impl;\nstruct C_foo {\n  foo_impl* foo_obj;\n};\n\n// elsewhere:\ntypedef void(*foo_deleter)(foo_impl*);\nstruct foo_impl {\n  foo_deleter* deleter;\n};\n\ntemplate&lt;typename T&gt;\nstruct foo_details {\n  foo_impl header;\n  T* data;\n  ~foo_details() { delete data; }\n  foo_details( T* in ):data(in) {}\n  foo_details( foo_details const&amp; ) = delete;\n  foo_details&amp; operator=( foo_details const&amp; ) = delete;\n  foo_details():data(nullptr) { header.deleter=nullptr; }\n};\n</code></pre>\n<p>then allocate a <code>foo_details</code> to stick into the <code>foo_obj</code> storing a <code>foo</code>, <code>reinterpret_cast</code> to a <code>foo_impl</code> (valid under standard layout clauses), and store into <code>foo_obj</code>.</p>\n<p>The <code>deleter</code> would then take a <code>foo_impl</code>, <code>reinterpret_cast</code> to a <code>foo_details&lt;foo&gt;</code> and <code>delete</code>.</p>\n<p>To access the data, you'd have to figure out what type it is (you can stick extra type information in the <code>foo_impl</code>, like an integer or whatever), then <code>reinterpret_cast</code> to the appropriate <code>foo_details&lt;?&gt;</code> and access the <code>data</code> in it.</p>\n<p>Realize that you'll need to be able to extract the type information of your opaque pointer somehow in order to use it: consider using whatever mechanism you use there to also determine how to delete it.</p>\n</hr>", "LastEditorUserId": "1774667", "LastActivityDate": "2014-07-30T14:03:34.357", "Score": "1", "CreationDate": "2014-07-30T13:34:20.030", "ParentId": "25037314", "CommentCount": "0", "LastEditDate": "2014-07-30T14:03:34.357", "OwnerUserId": "1774667"}});