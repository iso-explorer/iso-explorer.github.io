post_cb({"12717745": {"Id": "12717745", "PostTypeId": "2", "Body": "<p>There is a way to get close to what you are wanting.  Possibly this will work for you, although it adds an extra level of code to be maintained. </p>\n<p>It requires defining const char arrays with external linkage, then using the names of those arrays to instantiate classes from the templates.  Of course in real use this code would be separated into various .h and .cpp files.</p>\n<pre><code>extern const char a[] = \"a\";\nextern const char b[] = \"b\";\nextern const char ab[] = \"ab\";\nextern const char abc[] = \"abc\";\n\ntemplate &lt;const char * const  T&gt; class Test\n{\npublic:\n    Test() {str = typename T;};\nprivate:\n    const char * str;\n};\n\n\nSomeFunction()\n{\n    Test&lt;a&gt; A;\n    Test&lt;b&gt; B;\n    Test&lt;ab&gt; AB;\n    Test&lt;abc&gt; ABC;\n}\n</code></pre>\n", "LastActivityDate": "2012-10-03T22:23:11.200", "CommentCount": "2", "CreationDate": "2012-10-03T22:23:11.200", "ParentId": "12717174", "Score": "0", "OwnerUserId": "900626"}, "bq_ids": {"n4140": {"so_12717174_12717247_0": {"length": 15, "quality": 1.0, "section_id": 57}, "so_12717174_12717288_0": {"length": 5, "quality": 1.0, "section_id": 87}, "so_12717174_12717247_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 88}}, "n3337": {"so_12717174_12717247_0": {"length": 15, "quality": 1.0, "section_id": 52}, "so_12717174_12717288_0": {"length": 5, "quality": 1.0, "section_id": 82}, "so_12717174_12717247_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 83}}, "n4659": {"so_12717174_12717247_0": {"length": 15, "quality": 1.0, "section_id": 59}}}, "12717247": {"Id": "12717247", "PostTypeId": "2", "Body": "<p>14.1 lists the acceptable types of non-type template arguments:</p>\n<blockquote>\n<p id=\"so_12717174_12717247_0\">\u2014 integral or enumeration type,<br/>\n  \u2014 pointer to object or pointer to function,<br/>\n  \u2014 lvalue reference to object or lvalue reference to function,<br/>\n  \u2014 pointer to member,</p>\n</blockquote>\n<p>Arrays don't fit under any of these categories.</p>\n<p>14.3.2/1 lists categories of what's permitted as template arguments and 14.3.2/2 goes on to say:</p>\n<blockquote>\n<p id=\"so_12717174_12717247_1\">Note: A string literal (2.14.5) does not satisfy the requirements of any of these categories and thus is not an acceptable template-argument.</p>\n</blockquote>\n<p>Therefore you cannot do what you're trying to do.</p>\n", "LastEditorUserId": "365496", "LastActivityDate": "2012-10-03T21:41:01.737", "Score": "1", "CreationDate": "2012-10-03T21:34:53.940", "ParentId": "12717174", "CommentCount": "0", "OwnerUserId": "365496", "LastEditDate": "2012-10-03T21:41:01.737"}, "12717174": {"ViewCount": "795", "Body": "<p>So, I'm wishing to be able to have a static const compile \ntime struct that holds some value based on a string by using\ntemplates. I only desire up to four characters. I know that\nthe type of 'abcd' is <code>int</code>, and so is 'ab','abc', and although\n'a' is of type <code>char</code>, it works out for a <code>template&lt;int v&gt; struct</code></p>\n<p>What I wish to do is take sizes of 2,3,4,5 of some const char, \"abcd\"\nand have the same functionality as if they used 'abcd'. <em>Note that\nI do not mean 1,2,3, or 4 because I expect the null terminator.</em></p>\n<p><code>cout &lt;&lt; typeid(\"abcd\").name() &lt;&lt; endl;</code>  tells me that the type for\nthis hard coded string is <code>char const [5]</code>, which includes the null \nterminator on the end. </p>\n<p>I understand that I will need to twiddle the values as characters,\nso they are represented as an integer.</p>\n<p>I cannot use <code>constexpr</code> since VS10 does not support it (VS11 doesn't either..)</p>\n<p>So, for example with somewhere this template defined, and later the last line</p>\n<pre><code>template &lt;int v&gt; struct something {\n    static const int value = v;\n};\n\n//Eventually in some method\ncout &lt;&lt; typeid(something&lt;'abcd'&gt;::value).name() &lt;&lt; endl;\n</code></pre>\n<p>works just fine.</p>\n<p>I've tried</p>\n<pre><code>template&lt;char v[5]&gt; struct something2 {\n    static const int value = v[0];\n}\n\ntemplate&lt;char const v[5]&gt; struct something2 {\n    static const int value = v[0];\n}\n\ntemplate&lt;const char v[5]&gt; struct something2 {\n    static const int value = v[0];\n}\n</code></pre>\n<p>All of them build individually, though when I throw in my test,</p>\n<pre><code>cout &lt;&lt; typeid(something2&lt;\"abcd\"&gt;::value).name() &lt;&lt; endl;\n</code></pre>\n<p>I get</p>\n<pre><code>'something2' : invalid expression as a template argument for 'v'\n'something2' : use of class template requires template argument list\n</code></pre>\n<hr>\n<p>Is this not feasible or am I misunderstanding something? </p>\n</hr>", "AcceptedAnswerId": "12717247", "Title": "C++ Template const char array to int", "CreationDate": "2012-10-03T21:27:02.040", "Id": "12717174", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2012-10-03T22:23:11.200", "Score": "0", "OwnerUserId": "704626", "Tags": "<c++><string><templates>", "AnswerCount": "3"}, "12717288": {"Id": "12717288", "PostTypeId": "2", "Body": "<p>you cannot, from the standard.</p>\n<p>14.3.2.1:</p>\n<blockquote>\n<p id=\"so_12717174_12717288_0\">A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<ul>\n<li>an integral constant-expression of integral or enumeration type; or</li>\n<li>the name of a non-type template-parameter; or</li>\n<li>the address of an object or function with external linkage, including function templates &gt;and function template-ids but excluding non-static class members, expressed as &amp; id-&gt;expression where the &amp; is optional if the name refers to a function or array, or if the &gt;corresponding template-parameter is a reference; or</li>\n<li>a pointer to member expressed as described in 5.3.1 .</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2012-10-03T21:38:39.613", "CommentCount": "0", "CreationDate": "2012-10-03T21:38:39.613", "ParentId": "12717174", "Score": "0", "OwnerUserId": "238671"}});