post_cb({"35809469": {"Id": "35809469", "PostTypeId": "2", "Body": "<p>Array is <strong>not</strong> \"much like a pointer\". Arrays can decay to pointers, but in a non-decaying context, it's still an array with a known size.</p>\n", "LastActivityDate": "2016-03-05T03:01:39.933", "CommentCount": "0", "CreationDate": "2016-03-05T03:01:39.933", "ParentId": "35809460", "Score": "13", "OwnerUserId": "13"}, "35809513": {"Id": "35809513", "PostTypeId": "2", "Body": "<p>The compiler knows everything it needs to know about that array </p>\n<pre><code>T arr[]\n</code></pre>\n<p>is an incomplete type, but it gets better and \"feature complete\" with the part on the right which is a list, a list of defined size, known to the compiler at compile time so it is statically checked and there you have it, you know the size, you even know the elements; what more do you need ? </p>\n<p>Array are not pointers by the way, to better understand the problem you can tackle this from different angles, for example you should understand that when you pass an array to a function you are actually solving a problem that can't be solved neatly in C and C++, there is not <code>void foo( T arr [] )</code>, but you are forced to use <code>void foo ( T * arr )</code> because you can't create a real interface that is arrays-only in C/C++ .</p>\n", "LastActivityDate": "2016-03-05T03:08:23.930", "CommentCount": "2", "CreationDate": "2016-03-05T03:08:23.930", "ParentId": "35809460", "Score": "1", "OwnerUserId": "6020951"}, "35813404": {"Id": "35813404", "PostTypeId": "2", "Body": "<p>As mentioned in other answers, arrays are not pointers. They decay into pointers in some contexts, true, but only in some contexts.</p>\n<pre><code>int a[] = {1, 2, 3, 4, 5};\n</code></pre>\n<p>Type of <code>a</code> is <code>int [5]</code>, an array with five elements of type <code>int</code>. In this case a pair of empty square brackets tell the compiler to deduce the number of elements, so you definition is equivalent to <code>int a[5] = {1, 2, 3, 4, 5};</code>.</p>\n<p>If you are still not convinced, here is a piece of code that tries to make a compiler emit an error message containing the type of <code>a</code>:</p>\n<pre><code>template &lt;typename T&gt; struct Type;\n\nint main()\n{\n    int a[] = {1, 2, 3, 4, 5};\n    Type&lt;decltype(a)&gt; dummy;\n}\n</code></pre>\n<p>g++ 5.3 emits </p>\n<pre><code>error: aggregate \u2018Type&lt;int [5]&gt; dummy\u2019 has incomplete type and cannot be defined\n</code></pre>\n<p>As you can see, <a href=\"http://en.cppreference.com/w/cpp/language/decltype\" rel=\"nofollow noreferrer\">decltype</a>(a) is <code>int [5]</code>.</p>\n<p>cppreference.com contains a detailed explanation of <a href=\"http://en.cppreference.com/w/cpp/language/range-for\" rel=\"nofollow noreferrer\">range-based for loop</a>.\nYour for loop is equivalent to:</p>\n<pre><code>{\n    auto &amp;&amp; __range = a; \n    for (auto __begin = a, __end = a + 5; __begin != __end; ++__begin)\n    {\n        int i = *__begin; \n        std::printf(\"%d\\n\", i);\n    }\n}\n</code></pre>\n<p>To summarize: <code>T [N]</code> is a type: an array with <code>N</code> elements of type <code>T</code>. <code>N</code> is an integral constant known at compile-time, so the compiler knows where the last element of the array is, and hence is able to generate a loop that iterates over all the elements.</p>\n<p>If you want to know more about array decay, I suggest reading <a href=\"https://stackoverflow.com/questions/1461432/what-is-array-decaying\">What is array decaying?</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-06T20:32:47.367", "Score": "3", "CreationDate": "2016-03-05T11:15:20.733", "ParentId": "35809460", "CommentCount": "0", "OwnerUserId": "3046011", "LastEditDate": "2017-05-23T10:34:01.443"}, "35847688": {"Id": "35847688", "PostTypeId": "2", "Body": "<p>Because the compiler respect the C++ standard. Draft n4296 explicitely says that range-based for statement are valid for plain arrays:</p>\n<blockquote>\n<h3>6.5.4 The range-based for statement [stmt.ranged]</h3>\n<p id=\"so_35809460_35847688_0\">For a range-based for statement of the form</p>\n<pre><code>for ( for-range-declaration : expression ) statement\n</code></pre>\n<p id=\"so_35809460_35847688_1\">...<br/>\n  (1.1) \u2014 if _RangeT is an array type.... If _RangeT is an array of unknown size or an array of\n  incomplete type, the program is ill-formed;</p>\n</blockquote>\n<p>And <code>int a[] = {1, 2, 3, 4, 5};</code> defines an array of 5 integers.</p>\n", "LastActivityDate": "2016-03-07T15:34:30.603", "CommentCount": "0", "CreationDate": "2016-03-07T15:34:30.603", "ParentId": "35809460", "Score": "0", "OwnerUserId": "3545273"}, "bq_ids": {"n4140": {"so_35809460_35847688_1": {"length": 11, "quality": 1.0, "section_id": 3906}}, "n3337": {"so_35809460_35847688_1": {"length": 11, "quality": 1.0, "section_id": 3766}}, "n4659": {"so_35809460_35847688_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 4792}}}, "35847238": {"Id": "35847238", "PostTypeId": "2", "Body": "<p>It's because it calls <code>std::begin()</code> and <code>std::end()</code>, which specializes for C arrays.  This is from glibc's <code>&lt;range_access.h&gt;</code>:</p>\n<pre><code>template&lt;class _Tp, size_t _Nm&gt;\ninline _Tp*\nbegin(_Tp (&amp;__arr)[_Nm])\n{ return __arr; }\n\ntemplate&lt;class _Tp, size_t _Nm&gt;\ninline _Tp*\nend(_Tp (&amp;__arr)[_Nm])\n{ return __arr + _Nm; }\n</code></pre>\n", "LastActivityDate": "2016-03-07T15:14:08.670", "CommentCount": "1", "CreationDate": "2016-03-07T15:14:08.670", "ParentId": "35809460", "Score": "0", "OwnerUserId": "3517622"}, "35809487": {"Id": "35809487", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_35809460_35809487_0\">In my opinion, for (int i : a) only works when a is a vector of integers</p>\n</blockquote>\n<p>You are wrong.</p>\n<blockquote>\n<p id=\"so_35809460_35809487_1\">In above code, a is an array of integers which is much like a pointer to integer</p>\n</blockquote>\n<p>You are wrong here, too. Arrays and pointers are two completely different things.</p>\n<blockquote>\n<p id=\"so_35809460_35809487_2\">Why does this work?</p>\n</blockquote>\n<p>Because that's what ranged-for does. It iterates over <em>containers</em>. An array is a container.</p>\n", "LastActivityDate": "2016-03-05T03:03:46.063", "CommentCount": "0", "CreationDate": "2016-03-05T03:03:46.063", "ParentId": "35809460", "Score": "0", "OwnerUserId": "560648"}, "35809460": {"ViewCount": "288", "Body": "<p>Here is the code</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint a[] = {1, 2, 3, 4, 5};\n\nint main()\n{\n    for (int i : a)\n        printf(\"%d\\n\", i);\n    return 0;\n}\n</code></pre>\n<p>In my opinion, for (int i : a) only works when a is a vector of integers. But in above code, a is an array of integers which is much like a pointer to integer. Why does this work?</p>\n", "Title": "Why is such iterator legal?", "CreationDate": "2016-03-05T02:59:37.383", "LastActivityDate": "2016-04-06T20:32:47.367", "CommentCount": "3", "PostTypeId": "1", "Id": "35809460", "Score": "2", "OwnerUserId": "2751433", "Tags": "<c++><arrays><c++11>", "AnswerCount": "6"}});