post_cb({"6355438": {"CommentCount": "2", "AcceptedAnswerId": "6356071", "PostTypeId": "1", "LastEditorUserId": "50776", "CreationDate": "2011-06-15T09:09:10.300", "LastActivityDate": "2013-06-26T09:57:47.590", "LastEditDate": "2012-05-10T12:49:10.953", "ViewCount": "2246", "FavoriteCount": "2", "Title": "Overloading operator delete in a base class", "Id": "6355438", "Score": "5", "Body": "<p>From the C++ standard (ISO/IEC 14882:2003(E)), \u00a712.5.4, about overloading <code>operator delete</code>:</p>\n<blockquote>\n<p id=\"so_6355438_6355438_0\">If a delete-expression begins with a unary :: operator, the deallocation function's name is looked up in global scope. Otherwise, if the delete-expression is used to deallocate a class object whose static type has a virtual destructor, the deallocation function is the one found by the lookup in the definition of the dynamic type's virtual destructor (12.4). Otherwise, if the delete-expression is used to deallocate an object of\n  class T or array thereof, the static and dynamic types of the object shall be identical and the deallocation function's name is looked up in the scope of T. If this lookup fails to find the name, the name is looked up in the global scope. If the result of the lookup is ambiguous or inaccessible, or if the lookup selects a placement deallocation function, the program is ill-formed.</p>\n</blockquote>\n<p>\u00a712.5.7 is also interesting:</p>\n<blockquote>\n<p id=\"so_6355438_6355438_1\">Since member allocation and deallocation functions are static they cannot be virtual. [Note: however, when the cast-expression of a delete-expression refers to an object of class type, because the deallocation function actually called is looked up in the scope of the class that is the dynamic type of the object, if the destructor is virtual, the effect is the same. For example,</p>\n</blockquote>\n<pre><code>struct B {\n    virtual \u02dcB();\n    void operator delete(void*, size_t);\n};\nstruct D : B {\n    void operator delete(void*);\n};\nvoid f()\n{\n    B* bp = new D;\n    delete bp; // uses D::operator delete(void*)\n}\n</code></pre>\n<blockquote>\n<p id=\"so_6355438_6355438_2\">Here, storage for the non-array object of class D is deallocated by D::operator delete(), due to the virtual destructor.]</p>\n</blockquote>\n<p>After reading this, I am wondering...</p>\n<ul>\n<li>Is this part of the standard fully supported by all major C++ compilers (MSVC++, GCC)?</li>\n<li>If so, how did they do it? Hidden virtual function? \"Special\" virtual destructor call? RTTI?</li>\n<li>Using the example from the standard: can there be problems if f() and D::operator delete() are defined in separate EXE/DLL/DSOs? (Assuming that everything is compiled using the same compiler, of course)</li>\n</ul>\n<p>\u00a75.3.5.5 may also be relevant:</p>\n<blockquote>\n<p id=\"so_6355438_6355438_3\">In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand's dynamic type and the static type shall have a virtual destructor or the behavior is undefined. In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n", "Tags": "<c++><operator-overloading>", "OwnerUserId": "172594", "AnswerCount": "2"}, "17142055": {"ParentId": "6355438", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>After dig into the assembly code in emit by GCC 4.8</p>\n<p>The GCC will generate two piece of code (for class whose destructor is virtual):</p>\n<pre><code>One is assembly snippet#1 for {Destructor + Dealloc}\nThe other is assembly snippet#2 for {Destructor only}\n</code></pre>\n<p>And for the class whose destructor is not virtual, the call deallocation function instruction will generate in the point where you call delete.</p>\n<p>(Following discussion assume the destructor is virtual)\nSo for following code:</p>\n<pre><code>delete C   // This will be translate as call snippet#1 for the correct dynamic type\n</code></pre>\n<p>And if you code is following:</p>\n<pre><code>p-&gt;C::~C()  // this will be translate to call snippet#2\n</code></pre>\n<p>So the deallocate function is bind together with the virtual destructor.\nSo I think this will answere your question about how the deallocate function are implement like virtual but also static.</p>\n", "OwnerUserId": "2428052", "LastEditorUserId": "2428052", "LastEditDate": "2013-06-26T09:57:47.590", "Id": "17142055", "Score": "0", "CreationDate": "2013-06-17T07:06:23.317", "LastActivityDate": "2013-06-26T09:57:47.590"}, "bq_ids": {"n4140": {"so_6355438_6355438_0": {"section_id": 416, "quality": 0.7424242424242424, "length": 49}, "so_6355438_6355438_2": {"section_id": 418, "quality": 1.0, "length": 11}, "so_6355438_6355438_3": {"section_id": 6107, "quality": 0.8974358974358975, "length": 35}, "so_6355438_6355438_1": {"section_id": 418, "quality": 0.9428571428571428, "length": 33}}, "n3337": {"so_6355438_6355438_0": {"section_id": 407, "quality": 0.9545454545454546, "length": 63}, "so_6355438_6355438_2": {"section_id": 410, "quality": 1.0, "length": 11}, "so_6355438_6355438_3": {"section_id": 5873, "quality": 0.8974358974358975, "length": 35}, "so_6355438_6355438_1": {"section_id": 410, "quality": 0.9428571428571428, "length": 33}}, "n4659": {"so_6355438_6355438_0": {"section_id": 434, "quality": 0.7424242424242424, "length": 49}, "so_6355438_6355438_2": {"section_id": 436, "quality": 1.0, "length": 11}, "so_6355438_6355438_3": {"section_id": 7604, "quality": 0.8974358974358975, "length": 35}, "so_6355438_6355438_1": {"section_id": 436, "quality": 0.9142857142857143, "length": 32}}}, "6356071": {"ParentId": "6355438", "CommentCount": "2", "Body": "<p>I don't know much about VC++ ABI, but the Itanium ABI is well documented.</p>\n<p>Looking up at <a href=\"http://www.codesourcery.com/public/cxx-abi/abi.html#mangling\" rel=\"noreferrer\">the name mangling scheme</a>, one see:</p>\n<pre><code>&lt;ctor-dtor-name&gt; ::= C1     # complete object constructor\n                 ::= C2     # base object constructor\n                 ::= C3     # complete object allocating constructor\n                 ::= D0     # deleting destructor\n                 ::= D1     # complete object destructor\n                 ::= D2     # base object destructor\n</code></pre>\n<p>Of interest: <code>D0 # deleting destructor</code>, which means that even though <code>delete</code> is non virtual, since it is called from the virtual destructor, it can be considered virtual for all effects and purposes.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "6356071", "Score": "6", "CreationDate": "2011-06-15T10:07:24.100", "LastActivityDate": "2011-06-15T10:07:24.100"}});