post_cb({"28879996": {"ParentId": "28876228", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>The compiler error message is missleading*. You would intuitively think that it means that \"The function invocation is ambigious!\", but in reality the compilation fails in an earlier stage, the definition of the specialized function is not even generated at that point.</p>\n<p>What it really means is this: \"The function specialization is ambigious!\"</p>\n<p>Lets see how this compiles:</p>\n<pre><code>template &lt;short S&gt; void foo() { std::cout &lt;&lt; \"S: \" &lt;&lt; S &lt;&lt; '\\n'; }\n\nint main(int argc, char* argv[])\n{\n    foo&lt;0&gt;();\n    return 0;\n}\n</code></pre>\n<p>The first step of the compilation is the template specialization.</p>\n<p><strong>Step 1</strong>: The compiler realizes that <code>foo&lt;0&gt;</code> is a template specialization, and generates a function declaration accordingly:</p>\n<pre><code>template &lt;short S&gt; void foo() { std::cout &lt;&lt; \"S: \" &lt;&lt; S &lt;&lt; '\\n'; }\n\ntemplate&lt;&gt;\nvoid foo&lt;0&gt;();\n\nint main(int argc, char* argv[])\n{\n    foo&lt;0&gt;();\n    return 0;\n}\n</code></pre>\n<p><strong>Step 2</strong>: The compiler relizes that the function is actually invoked (This seems obvious in this case, but it is less obvious when you have a class template.), and generates a definition:</p>\n<pre><code>template &lt;short S&gt; void foo() { std::cout &lt;&lt; \"S: \" &lt;&lt; S &lt;&lt; '\\n'; }\n\ntemplate&lt;&gt;\nvoid foo&lt;0&gt;();\n\nint main(int argc, char* argv[])\n{\n    foo&lt;0&gt;();\n    return 0;\n}\n\ntemplate&lt;&gt;\nvoid foo&lt;0&gt;(){\n    std::cout &lt;&lt; \"S: \" &lt;&lt; 0 &lt;&lt; '\\n';\n}\n</code></pre>\n<p><strong>Step 3:</strong> Now you have a callable function, the compilation continues normally.</p>\n<p>Lets try to follow the same steps in your case:</p>\n<pre><code>template &lt;short S&gt; void foo() { std::cout &lt;&lt; \"S: \" &lt;&lt; S &lt;&lt; '\\n'; }\ntemplate &lt;int I&gt;   void foo() { std::cout &lt;&lt; \"I: \" &lt;&lt; I &lt;&lt; '\\n'; }\n\nint main(int argc, char* argv[])\n{\n    foo&lt;0&gt;();\n    return 0;\n}\n</code></pre>\n<p><strong>Step 1</strong>: Generating the function declaration:</p>\n<pre><code>template &lt;short S&gt; void foo() { std::cout &lt;&lt; \"S: \" &lt;&lt; S &lt;&lt; '\\n'; }\ntemplate &lt;int I&gt;   void foo() { std::cout &lt;&lt; \"I: \" &lt;&lt; I &lt;&lt; '\\n'; }\n\ntemplate&lt;&gt;\nvoid foo&lt;0&gt;();\n\nint main(int argc, char* argv[])\n{\n    foo&lt;0&gt;();\n    return 0;\n}\n</code></pre>\n<p>And at this point the compilation fails, because the specialized declaration of foo is ambigious.\nIf you want proof, try compiling this code:</p>\n<pre><code>template &lt;short S&gt; void foo() { std::cout &lt;&lt; \"S: \" &lt;&lt; S &lt;&lt; '\\n'; }\ntemplate &lt;int I&gt;   void foo() { std::cout &lt;&lt; \"I: \" &lt;&lt; I &lt;&lt; '\\n'; }\n\ntemplate&lt;&gt;\nvoid foo&lt;0&gt;();\n\nint main(int argc, char* argv[])\n{\n    return 0;\n}\n</code></pre>\n<p>You will get the same error message without the function invocation!</p>\n<p><strong>Update</strong></p>\n<p>So the takeaway is that <em>everything</em> translates to specialized function declarations. So no matter if you write <code>foo&lt;int{0}&gt;</code> of <code>foo&lt;short{0}&gt;</code>, the compiler will generate <code>template&lt;&gt; void foo&lt;0&gt;();</code> for both. The explicit types will be ignored. (Thats why its really important that they are <code>constexpr</code>-s.)</p>\n<p><strong>Update</strong>\nAs T.C. pointed out in his comment, in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">standard</a> (413rd page in the PDF) there is a very similar example:</p>\n<blockquote>\n<p id=\"so_28876228_28879996_0\">[Example: In the following example, assuming a signed char cannot\n  represent the value 1000, a narrowing conversion (8.5.4) would be\n  required to convert the template-argument of type int to signed char,\n  therefore substitution fails for the second template (14.3.2).</p>\n<pre><code> template &lt;int&gt; int f(int);\n template &lt;signed char&gt; int f(int);\n int i1 = f&lt;1000&gt;(0); // OK\n int i2 = f&lt;1&gt;(0); // ambiguous; not narrowing\n</code></pre>\n<p id=\"so_28876228_28879996_1\">\u2014end example]</p>\n</blockquote>\n<hr>\n<p>*The error message is completely correct. Might not be particularly intuitive, but it reflects the procedure specified in the standard. \u2013  T.C.</p>\n</hr>", "OwnerUserId": "3580498", "LastEditorUserId": "3580498", "LastEditDate": "2015-03-05T22:39:24.667", "Id": "28879996", "Score": "5", "CreationDate": "2015-03-05T14:19:46.457", "LastActivityDate": "2015-03-05T22:39:24.667"}, "28876228": {"CommentCount": "4", "AcceptedAnswerId": "28882171", "CreationDate": "2015-03-05T10:57:59.733", "LastActivityDate": "2015-03-06T15:25:37.740", "Title": "Overloaded non-type template is ambiguous while non-templated function is ok", "ViewCount": "262", "FavoriteCount": "1", "PostTypeId": "1", "Id": "28876228", "OwnerUserId": "499359", "Body": "<p>If we have a template function which takes a non-type parameter of type <code>int</code> or <code>short</code> the compiler complains about the ambiguity of the following call:</p>\n<pre><code>// Definition\ntemplate &lt;int I&gt;   void foo() { std::cout &lt;&lt; \"I: \" &lt;&lt; I &lt;&lt; '\\n'; }\ntemplate &lt;short S&gt; void foo() { std::cout &lt;&lt; \"S: \" &lt;&lt; S &lt;&lt; '\\n'; }\n\n// Usage\nfoo&lt;0&gt;(); // Ambiguous, int or short?\n</code></pre>\n<p>At first I wasn't surprised with this behaviour, the literal <code>0</code> could be an <code>int</code> or a <code>short</code>, but if we try this:</p>\n<pre><code>// Definition\nvoid foo(int i)   { std::cout &lt;&lt; \"i: \" &lt;&lt; i &lt;&lt; '\\n'; }\nvoid foo(short s) { std::cout &lt;&lt; \"s: \" &lt;&lt; s &lt;&lt; '\\n'; }\n\n// Usage\nfoo(0); // \"i: 0\"!\n</code></pre>\n<p>The call to <code>foo</code> is unambiguous! it takes the <code>int</code> overload (even when the template version did not). Well, after thinking a little, this isn't a surprising behaviour, after all there's no way to specify a <code>short</code> literal so the compiler thinks that <code>0</code> is an <code>int</code> (this is the default behaviour AFAIK), in order to unambiguously call the <code>short</code> version of non-templated <code>foo</code> we can explicitly instantiate a <code>short</code>:</p>\n<pre><code>foo(0);        // \"i: 0\"\nfoo(short{0}); // \"s: 0\"\n</code></pre>\n<p>So i thought that this would unambiguate the templated version, but it did not:</p>\n<pre><code>foo&lt;int{0}&gt;();   // Ambiguous call, candidates are int and short versions\nfoo&lt;short{0}&gt;(); // Ambiguous call, candidates are int and short versions\n</code></pre>\n<blockquote id=\"so_28876228_28876228_0\">\n<pre><code>call of overloaded 'foo()' is ambiguous\n foo&lt;int{0}&gt;();\nnote: candidates are:\nvoid foo() [with int I = 0]\nvoid foo() [with short int S = 0]\n\ncall of overloaded 'foo()' is ambiguous\n foo&lt;short{0}&gt;();\nnote: candidates are:\nvoid foo() [with int I = 0]\nvoid foo() [with short int S = 0]\n</code></pre>\n</blockquote>\n<p>The last thing I've tried was to use instances instead of literals:</p>\n<pre><code>template &lt;int I&gt;   void foo() { std::cout &lt;&lt; \"I: \" &lt;&lt; I &lt;&lt; '\\n'; }\ntemplate &lt;short S&gt; void foo() { std::cout &lt;&lt; \"S: \" &lt;&lt; S &lt;&lt; '\\n'; }\n\nvoid foo(int i)   { std::cout &lt;&lt; \"i: \" &lt;&lt; i &lt;&lt; '\\n'; }\nvoid foo(short s) { std::cout &lt;&lt; \"s: \" &lt;&lt; s &lt;&lt; '\\n'; }\n\nconstexpr int i{1};\nconstexpr short s{5};\n\nint main()\n{\n    foo(i); // \"i: 1\"\n    foo(s); // \"s: 5\"\n    foo&lt;i&gt;(); // Ambiguous! (expected \"I: 1\")\n    foo&lt;s&gt;(); // Ambiguous! (expected \"S: 5\")\n    return 0;\n}\n</code></pre>\n<p>Without success, as you can se... So, what's the question?</p>\n<ul>\n<li>Why the call to templated <code>foo</code> is ambiguous? (note that the no templated <code>foo</code> takes <code>int</code> version so is unambiguous).</li>\n<li>Why the call to templated <code>foo</code> remains ambiguous even after specifying the type on the call? (note that the no templated <code>foo</code> <em>works fine</em>).</li>\n</ul>\n<p>Thanks.</p>\n", "Tags": "<c++><templates><non-type>", "Score": "12", "AnswerCount": "3"}, "28878970": {"ParentId": "28876228", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Template function here is parametrized by value, and only by value, not by type! <strong>update: now I am not sure.</strong>\nAt the other hand, not templated version is parametrized by type, (and one can enjoy polymorphic calls). </p>\n<p><strong>update:</strong>\nWell, looks like instantiated functions mangled name actually depends on type of numerical template parameter.</p>\n", "OwnerUserId": "4094574", "LastEditorUserId": "4094574", "LastEditDate": "2015-03-06T15:25:37.740", "Id": "28878970", "Score": "0", "CreationDate": "2015-03-05T13:28:57.157", "LastActivityDate": "2015-03-06T15:25:37.740"}, "28882171": {"ParentId": "28876228", "CommentCount": "2", "Body": "<p>Here's what happens when you write <code>f&lt;0&gt;()</code>.</p>\n<ol>\n<li><p>The compiler looks up <code>f</code>, and finds two function template declarations:</p>\n<pre><code>template &lt;int I&gt;   void foo();\ntemplate &lt;short S&gt; void foo();\n</code></pre></li>\n<li><p>The compiler sees the explicit template argument list and attempts to substitute it into each function template declaration:</p>\n<pre><code>template &lt;int I&gt;   void foo(); // with I = 0\ntemplate &lt;short S&gt; void foo(); // with S = 0\n</code></pre>\n<p>Substitution succeeds in both cases because <code>0</code> is an <code>int</code>, and can be converted to <code>short</code>, and the conversion is an allowed conversion in this context.</p></li>\n<li><p>After substitution, two candidate function specializations are produced. Both are viable. Overload resolution is then performed - and since the signature is identical and no tiebreaker applies, overload resolution fails and the call is ambiguous.</p></li>\n</ol>\n<p>The point here is that the normal overload resolution rules do not apply to template arguments. The conversions for template arguments are applied in an earlier stage, before the regular overload resolution takes place.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "28882171", "Score": "5", "CreationDate": "2015-03-05T15:57:11.367", "LastActivityDate": "2015-03-05T15:57:11.367"}, "bq_ids": {"n4659": {"so_28876228_28879996_0": {"section_id": 308, "quality": 0.8888888888888888, "length": 24}}}});