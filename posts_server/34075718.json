post_cb({"bq_ids": {"n4140": {"so_34075718_34075797_1": {"length": 8, "quality": 1.0, "section_id": 7104}, "so_34075718_34075797_0": {"length": 36, "quality": 1.0, "section_id": 7104}}, "n3337": {"so_34075718_34075797_1": {"length": 8, "quality": 1.0, "section_id": 6848}, "so_34075718_34075797_0": {"length": 36, "quality": 1.0, "section_id": 6848}}, "n4659": {"so_34075718_34075797_1": {"length": 8, "quality": 1.0, "section_id": 8605}, "so_34075718_34075797_0": {"length": 36, "quality": 1.0, "section_id": 8605}}}, "34075797": {"Id": "34075797", "PostTypeId": "2", "Body": "<p>Because <code>std::allocator&lt;T&gt;</code> is used as a template type argument, the <code>std</code> namespace is an associated namespace for ADL.</p>\n<p><a href=\"http://eel.is/c++draft/basic.lookup.argdep#2\">[basic.lookup.argdep]/2</a>, bullet 2, emphasis mine:</p>\n<blockquote>\n<p id=\"so_34075718_34075797_0\">Furthermore, if <code>T</code> is a class template specialization, its associated\n  namespaces and classes also include: <strong>the namespaces and classes\n  associated with the types of the template arguments provided for\n  template type parameters</strong> (excluding template template parameters);\n  the namespaces of which any template template arguments are members;\n  and the classes of which any member templates used as template\n  template arguments are members.</p>\n</blockquote>\n<p>...and pointers have the same set of associated namespaces/classes as the type they point to:</p>\n<blockquote>\n<p id=\"so_34075718_34075797_1\">If <code>T</code> is a pointer to <code>U</code> or an array of <code>U</code>, its associated namespaces and\n  classes are those associated with <code>U</code>.</p>\n</blockquote>\n", "LastActivityDate": "2015-12-03T20:45:19.507", "CommentCount": "0", "CreationDate": "2015-12-03T20:45:19.507", "ParentId": "34075718", "Score": "17", "OwnerUserId": "2756719"}, "34075718": {"ViewCount": "1002", "Body": "<p>The following program</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;utility&gt;\n#include &lt;memory&gt;\n\nnamespace my_namespace\n{\n\n\ntemplate&lt;class T&gt;\nvoid swap(T&amp; a, T&amp; b)\n{\n  T tmp = std::move(a);\n  a = std::move(b);\n  b = std::move(tmp);\n}\n\ntemplate&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt;\nclass foo {};\n\n}\n\nint main()\n{\n  my_namespace::foo&lt;int&gt; *a, *b;\n\n  using my_namespace::swap;\n\n  swap(a,b);\n\n  return 0;\n}\n</code></pre>\n<p>causes both <code>g++</code> and <code>clang</code> to issue the following compiler error on my system:</p>\n<pre><code>$ clang -std=c++11 swap_repro.cpp -I.\nswap_repro.cpp:28:3: error: call to 'swap' is ambiguous\n  swap(a,b);\n  ^~~~\n/usr/bin/../lib/gcc/x86_64-linux-gnu/5.2.1/../../../../include/c++/5.2.1/bits/algorithmfwd.h:571:5: note: candidate function [with _Tp = my_namespace::foo&lt;int, std::allocator&lt;int&gt; &gt; *]\n    swap(_Tp&amp;, _Tp&amp;)\n    ^\nswap_repro.cpp:10:6: note: candidate function [with T = my_namespace::foo&lt;int, std::allocator&lt;int&gt; &gt; *]\nvoid swap(T&amp; a, T&amp; b)\n     ^\n1 error generated.\n\n$ g++ -std=c++11 swap_repro.cpp -I.\nswap_repro.cpp: In function \u2018int main()\u2019:\nswap_repro.cpp:28:11: error: call of overloaded \u2018swap(my_namespace::foo&lt;int&gt;*&amp;, my_namespace::foo&lt;int&gt;*&amp;)\u2019 is ambiguous\n   swap(a,b);\n           ^\nswap_repro.cpp:28:11: note: candidates are:\nswap_repro.cpp:10:6: note: void my_namespace::swap(T&amp;, T&amp;) [with T = my_namespace::foo&lt;int&gt;*]\n void swap(T&amp; a, T&amp; b)\n      ^\nIn file included from /usr/include/c++/4.9/bits/stl_pair.h:59:0,\n                 from /usr/include/c++/4.9/utility:70,\n                 from /usr/include/c++/4.9/algorithm:60,\n                 from swap_repro.cpp:1:\n/usr/include/c++/4.9/bits/move.h:166:5: note: void std::swap(_Tp&amp;, _Tp&amp;) [with _Tp = my_namespace::foo&lt;int&gt;*]\n     swap(_Tp&amp; __a, _Tp&amp; __b)\n     ^\n</code></pre>\n<p>I don't understand why <code>std::swap</code> is being considered as a candidate overload, but it has something to do with <code>foo</code>'s use of <code>std::allocator&lt;T&gt;</code>.</p>\n<p>Eliminating <code>foo</code>'s second template parameter allows the program to compile without error.</p>\n", "AcceptedAnswerId": "34075797", "Title": "Why is this call to swap() ambiguous?", "CreationDate": "2015-12-03T20:39:16.283", "Id": "34075718", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-12-08T11:13:24.430", "LastEditorUserId": "963864", "LastActivityDate": "2015-12-08T11:13:24.430", "Score": "23", "OwnerUserId": "722294", "Tags": "<c++><namespaces><argument-dependent-lookup><name-lookup><class-template>", "AnswerCount": "2"}, "34075846": {"Id": "34075846", "PostTypeId": "2", "Body": "<p>The set of associated namespaces is determined based on various types visible from the argument types. Notably, for class templates the associated namespaces include the associated namespaces of all template arguments. When looking up unqualified functions using argument dependent look-up all associated namespaces are searched.</p>\n<p>The template argument list of <code>foo&lt;int&gt;</code> is actually <code>foo&lt;int, std::allocator&lt;int&gt;&gt;</code>, thereby dragging namespace <code>std</code> into the picture and there is already a general overload for <code>swap()</code> available from there.</p>\n", "LastActivityDate": "2015-12-03T20:48:46.633", "CommentCount": "0", "CreationDate": "2015-12-03T20:48:46.633", "ParentId": "34075718", "Score": "10", "OwnerUserId": "1120273"}});