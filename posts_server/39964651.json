post_cb({"39965201": {"Id": "39965201", "PostTypeId": "2", "Body": "<p>Speaking to the C side of the problem,</p>\n<blockquote id=\"so_39964651_39965201_0\">\n<ol>\n<li>Is my reasoning correct, and is this a legitimate problem in theory?</li>\n</ol>\n</blockquote>\n<p>It is a problem that I had not considered before, but I agree with your analysis.  C defines the behavior of the <code>&lt;&lt;</code> operator in terms of the type of the <em>promoted</em> left operand, and it it conceivable that the integer promotions result in that being (signed) <code>int</code> when the original type of that operand is <code>uint32_t</code>.  I don't expect to see that in practice on any modern machine, but I'm all for programming to the actual standard as opposed to my personal expectations.</p>\n<blockquote id=\"so_39964651_39965201_1\">\n<ol start=\"2\">\n<li>Is this problem safe to ignore because on every platform the next integer type is double the width?</li>\n</ol>\n</blockquote>\n<p>C does not require such a relationship between integer types, though it is ubiquitous in practice.  If you are determined to rely only on the standard, however -- that is, if you are taking pains to write strictly conforming code -- then you cannot rely on such a relationship.</p>\n<blockquote id=\"so_39964651_39965201_2\">\n<ol start=\"3\">\n<li>Is a good idea to correctly defend against this pathological situation by pre-masking the input like this?: b = (a &amp; 1) &lt;&lt; 31;.\n  (This will necessarily be correct on every platform. But this could\n  make a speed-critical crypto algorithm slower than necessary.)</li>\n</ol>\n</blockquote>\n<p>The type <code>unsigned long</code> is guaranteed to have at least 32 value bits, and it is not subject to promotion to any other type under the integer promotions.  On many common platforms it has exactly the same representation as <code>uint32_t</code>, and may even be the same type.  Thus, I would be inclined to write the expression like this:</p>\n<pre><code>uint32_t a = (...);\nuint32_t b = (unsigned long) a &lt;&lt; 31;\n</code></pre>\n<p>Or if you need <code>a</code> only as an intermediate value in the computation of <code>b</code>, then declare it as an <code>unsigned long</code> to begin with.</p>\n", "LastEditorUserId": "2402272", "LastActivityDate": "2016-10-10T19:48:43.950", "Score": "23", "CreationDate": "2016-10-10T19:13:51.283", "ParentId": "39964651", "CommentCount": "5", "OwnerUserId": "2402272", "LastEditDate": "2016-10-10T19:48:43.950"}, "39964651": {"ViewCount": "3976", "Body": "<p>This question is motivated by me implementing cryptographic algorithms (e.g. SHA-1) in C/C++, writing portable platform-agnostic code, and thoroughly avoiding <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\">undefined behavior</a>.</p>\n<p>Suppose that a standardized crypto algorithm asks you to implement this:</p>\n<pre><code>b = (a &lt;&lt; 31) &amp; 0xFFFFFFFF\n</code></pre>\n<p>where <code>a</code> and <code>b</code> are unsigned 32-bit integers. Notice that in the result, we discard any bits above the least significant 32 bits.</p>\n<hr>\n<p>As a first naive approximation, we might assume that <code>int</code> is 32 bits wide on most platforms, so we would write:</p>\n<pre><code>unsigned int a = (...);\nunsigned int b = a &lt;&lt; 31;\n</code></pre>\n<p>We know this code won't work everywhere because <code>int</code> is 16 bits wide on some systems, 64 bits on others, and possibly even 36 bits. But using <code>stdint.h</code>, we can improve this code with the <code>uint32_t</code> type:</p>\n<pre><code>uint32_t a = (...);\nuint32_t b = a &lt;&lt; 31;\n</code></pre>\n<p>So we are done, right? That's what I thought for years. ... Not quite. Suppose that on a certain platform, we have:</p>\n<pre><code>// stdint.h\ntypedef unsigned short uint32_t;\n</code></pre>\n<p>The rule for performing arithmetic operations in C/C++ is that if the type (such as <code>short</code>) is narrower than <code>int</code>, then it gets widened to <code>int</code> if all values can fit, or <code>unsigned int</code> otherwise.</p>\n<p>Let's say that the compiler defines <code>short</code> as 32 bits (signed) and <code>int</code> as 48 bits (signed). Then these lines of code:</p>\n<pre><code>uint32_t a = (...);\nuint32_t b = a &lt;&lt; 31;\n</code></pre>\n<p>will effectively mean:</p>\n<pre><code>unsigned short a = (...);\nunsigned short b = (unsigned short)((int)a &lt;&lt; 31);\n</code></pre>\n<p>Note that <code>a</code> is promoted to <code>int</code> because all of <code>ushort</code> (i.e. <code>uint32</code>) fits into <code>int</code> (i.e. <code>int48</code>).</p>\n<p>But now we have a problem: <strong>shifting non-zero bits left into the sign bit of a signed integer type is undefined behavior</strong>. This problem happened because our <code>uint32</code> was promoted to <code>int48</code> - instead of being promoted to <code>uint48</code> (where left-shifting would be okay).</p>\n<hr>\n<p>Here are my questions:</p>\n<ol>\n<li><p>Is my reasoning correct, and is this a legitimate problem in theory?</p></li>\n<li><p>Is this problem safe to ignore because on every platform the next integer type is double the width?</p></li>\n<li><p>Is a good idea to correctly defend against this pathological situation by pre-masking the input like this?: <code>b = (a &amp; 1) &lt;&lt; 31;</code>. (This will necessarily be correct on every platform. But this could make a speed-critical crypto algorithm slower than necessary.)</p></li>\n</ol>\n<p>Clarifications/edits:</p>\n<ul>\n<li><p>I'll accept answers for C or C++ or both. I want to know the answer for at least one of the languages.</p></li>\n<li><p>The pre-masking logic may hurt bit rotation. For example, GCC will compile <code>b = (a &lt;&lt; 31) | (a &gt;&gt; 1);</code> to a 32-bit bit-rotation instruction in assembly language. But if we pre-mask the left shift, it is possible that the new logic is not translated into bit rotation, which means now 4 operations are performed instead of 1.</p></li>\n</ul>\n</hr></hr>", "AcceptedAnswerId": "39969562", "Title": "Is masking before unsigned left shift in C/C++ too paranoid?", "CreationDate": "2016-10-10T18:36:03.917", "Id": "39964651", "CommentCount": "22", "FavoriteCount": "13", "PostTypeId": "1", "LastEditDate": "2016-10-10T18:51:08.613", "LastEditorUserId": "4774918", "LastActivityDate": "2016-10-11T02:21:03.433", "Score": "67", "OwnerUserId": "839689", "Tags": "<c++><c><language-lawyer><undefined-behavior><integer-arithmetic>", "AnswerCount": "5"}, "39965008": {"Id": "39965008", "PostTypeId": "2", "Body": "<p>Q1: Masking <em>before</em> the shift does prevent undefined behavior that OP has concern.</p>\n<p>Q2: \"... because on every platform the next integer type is double the width?\" --&gt; no.  The \"next\" integer type could be less than 2x or even the same size.</p>\n<p>The following is well defined for all compliant C compilers that have <code>uint32_t</code>.</p>\n<pre><code>uint32_t a; \nuint32_t b = (a &amp; 1) &lt;&lt; 31;\n</code></pre>\n<p>Q3: <code>uint32_t a; uint32_t b = (a &amp; 1) &lt;&lt; 31;</code> is not expected to incur code that performs a mask - it is not needed in the executable - just in the source.  If a mask does occur, get a better compiler should speed be an issue.</p>\n<p>As <a href=\"https://stackoverflow.com/questions/39964651/is-masking-before-unsigned-left-shift-in-c-c-too-paranoid/39965008#comment67209263_39964651\">suggested</a>, better to emphasize the unsigned-ness with these shifts.</p>\n<pre><code>uint32_t b = (a &amp; 1U) &lt;&lt; 31;\n</code></pre>\n<hr>\n<p><a href=\"https://stackoverflow.com/a/39965201/2410359\">@John Bollinger</a> good answer well details how to handle OP's specific problem.  </p>\n<p>The <em>general</em> problem is how to form a number that is of at least <code>n</code> bits, a certain sign-ness <em>and</em>  not subject to surprising integer promotions - the core of OP's dilemma.  The below fulfills this by invoking an <code>unsigned</code> operation that does not change the value - effective a no-op other than type concerns.  The product will be <em>at least</em> the width of <code>unsigned</code> or <code>uint32_t</code>.   Casting, in general, may narrow the type.  Casting needs to be avoided unless narrowing is certain to not occur.  An optimization compiler will not create unnecessary code.</p>\n<pre><code>uint32_t a;\nuint32_t b = (a + 0u) &lt;&lt; 31;\nuint32_t b = (a*1u) &lt;&lt; 31;\n</code></pre>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-10-10T19:52:06.003", "Score": "18", "CreationDate": "2016-10-10T18:59:26.310", "ParentId": "39964651", "CommentCount": "2", "OwnerUserId": "2410359", "LastEditDate": "2017-05-23T12:17:23.060"}, "39964956": {"Id": "39964956", "PostTypeId": "2", "Body": "<p>For this segment of code:</p>\n<pre><code>uint32_t a = (...);\nuint32_t b = a &lt;&lt; 31;\n</code></pre>\n<p>To promote <code>a</code> to a unsigned type instead of signed type, use:</p>\n<pre><code>uint32_t b = a &lt;&lt; 31u;\n</code></pre>\n<p>When both sides of <code>&lt;&lt;</code> operator is an unsigned type, then this line in 6.3.1.8 (C standard draft n1570) applies:</p>\n<blockquote>\n<p id=\"so_39964651_39964956_0\">Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank. </p>\n</blockquote>\n<hr>\n<p>The problem you are describing is caused you use <code>31</code> which is <code>signed int type</code> so another line in 6.3.1.8</p>\n<blockquote>\n<p id=\"so_39964651_39964956_1\">Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, then the operand with unsigned integer type is converted to the type of the operand with signed integer type. </p>\n</blockquote>\n<p>forces <code>a</code> to promoted to a signed type</p>\n<hr>\n<p><strong>Update:</strong></p>\n<p>This answer is not correct because 6.3.1.1(2) (emphasis mine):</p>\n<blockquote>\n<p id=\"so_39964651_39964956_2\">...</p>\n<p id=\"so_39964651_39964956_3\">If an int can represent all values of the original type (as restricted\n  by the width, for a bit-field), the value is converted to an <strong>int</strong>;\n  otherwise, it is converted to an <strong>unsigned int</strong>. These are called the\n  integer promotions.58) All other types are unchanged by the <strong>integer</strong>\n<strong>promotions</strong>.</p>\n</blockquote>\n<p>and footnote 58 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_39964651_39964956_4\">58) The integer promotions are applied only: as part of the usual arithmetic conversions, to certain argument expressions, to the operands of the unary +, -, and ~ operators, and to <strong>both operands of the shift operators</strong>, as specified by their respective subclauses. </p>\n</blockquote>\n<p>Since only integer promotion is happening and not common arithmetic conversion, using <code>31u</code> does not guarantee <code>a</code> to be converted to <code>unsigned int</code> as stated above.</p>\n</hr></hr>", "LastEditorUserId": "3528438", "LastActivityDate": "2016-10-10T19:42:11.723", "Score": "-1", "CreationDate": "2016-10-10T18:55:19.120", "ParentId": "39964651", "CommentCount": "9", "OwnerUserId": "3528438", "LastEditDate": "2016-10-10T19:42:11.723"}, "bq_ids": {"n4140": {"so_39964651_39964956_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 5943}, "so_39964651_39964956_0": {"length": 23, "quality": 1.0, "section_id": 5943}}, "n3337": {"so_39964651_39964956_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 5714}, "so_39964651_39964956_0": {"length": 23, "quality": 1.0, "section_id": 5714}}, "n4659": {"so_39964651_39964956_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 7428}, "so_39964651_39964956_0": {"length": 23, "quality": 1.0, "section_id": 7428}}}, "39969562": {"Id": "39969562", "PostTypeId": "2", "Body": "<p>Taking a clue from <a href=\"https://stackoverflow.com/questions/27001604/32-bit-unsigned-multiply-on-64-bit-causing-undefined-behavior\">this question</a> about possible UB in <code>uint32 * uint32</code> arithmetic, the following simple approach should work in C and C++:</p>\n<pre><code>uint32_t a = (...);\nuint32_t b = (uint32_t)((a + 0u) &lt;&lt; 31);\n</code></pre>\n<p>The integer constant <code>0u</code> has type <code>unsigned int</code>. This promotes the addition <code>a + 0u</code> to <code>uint32_t</code> or <code>unsigned int</code>, whichever is wider. Because the type has rank <code>int</code> or higher, no more promotion occurs, and the shift can be applied with the left operand being <code>uint32_t</code> or <code>unsigned int</code>.</p>\n<p>The final cast back to <code>uint32_t</code> will just suppress potential warnings about a narrowing conversion (say if <code>int</code> is 64 bits).</p>\n<p>A decent C compiler should be able to see that adding zero is a no-op, which is less onerous than seeing that a pre-mask has no effect after an unsigned shift.</p>\n", "LastActivityDate": "2016-10-11T02:21:03.433", "CommentCount": "0", "CreationDate": "2016-10-11T02:21:03.433", "ParentId": "39964651", "Score": "11", "OwnerUserId": "839689"}, "39964955": {"Id": "39964955", "PostTypeId": "2", "Body": "<p>To avoid unwanted promotion, you may use the <em>greater</em> type with some typedef, as</p>\n<pre><code>using my_uint_at_least32 = std::conditional_t&lt;(sizeof(std::uint32_t) &lt; sizeof(unsigned)),\n                                              unsigned,\n                                              std::uint32_t&gt;;\n</code></pre>\n", "LastActivityDate": "2016-10-10T18:55:14.470", "CommentCount": "2", "CreationDate": "2016-10-10T18:55:14.470", "ParentId": "39964651", "Score": "9", "OwnerUserId": "2684539"}});