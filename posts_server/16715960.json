post_cb({"bq_ids": {"n3337": {"so_16715960_16716069_0": {"section_id": 5286, "quality": 0.9523809523809523, "length": 20}}}, "16716069": {"LastActivityDate": "2013-05-23T14:10:18.510", "LastEditorUserId": "1760345", "ParentId": "16715960", "LastEditDate": "2013-05-23T14:10:18.510", "Id": "16716069", "Score": "3", "Body": "<p>You can certainly do that, an example is presented in C++11 standard N3485 Section 7.3.3.11</p>\n<p>Quoted below.</p>\n<blockquote>\n<p id=\"so_16715960_16716069_0\">The entity declared by a using-declaration shall be known in the\n  context using it according to its definition at the point of the\n  using-declaration. Definitions added to the namespace after the\n  using-declaration are not considered when a use of the name is made. </p>\n<p id=\"so_16715960_16716069_1\">[ Example: </p>\n<pre><code>namespace A \n{ \n    void f(int); \n} \nusing A::f; // f is a synonym for A::f; \n            // that is, for A::f(int). \nnamespace A \n{ \n    void f(char); \n}\n\nvoid foo() \n{ \n   f(\u2019a\u2019); // calls f(int), \n}         // even though f(char) exists.\n\nvoid bar() \n{ \n    sing A::f; // f is a synonym for A::f; \n               // that is, for A::f(int) and A::f(char). \n    f(\u2019a\u2019); // calls f(char) \n}\n</code></pre>\n<p id=\"so_16715960_16716069_2\">\u2014end example ]</p>\n</blockquote>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "1760345", "CreationDate": "2013-05-23T14:05:00.750"}, "16716003": {"LastActivityDate": "2013-05-23T14:09:58.273", "LastEditorUserId": "1919155", "ParentId": "16715960", "LastEditDate": "2013-05-23T14:09:58.273", "Id": "16716003", "Score": "2", "Body": "<p>Yes, you can split the contents of a namespace over several sections. </p>\n<p>If you compile using <code>gcc</code> and use <code>-ansi</code> and <code>-pedantic</code> will give you warnings for non-standard code. </p>\n<p>A typical use-case of this is of course when you declared a set of things in a header file, and then implement these in a source file. </p>\n<pre><code>// header.h\n\nnamespace somename\n{\n   class A\n   {\n      // stuff goes here \n      void func();\n      // more stuff. \n   }\n }\n</code></pre>\n<hr>\n<pre><code>// source.cpp\n\n#include \"header.h\"\n\nnamespace somename\n{\n\n   void A::func()\n   {\n      // whatever A::func() is supposed to do goes here. \n   }\n}\n</code></pre>\n</hr>", "CommentCount": "2", "PostTypeId": "2", "OwnerUserId": "1919155", "CreationDate": "2013-05-23T14:02:13.500"}, "16715960": {"AcceptedAnswerId": "16716069", "Tags": "<c++><namespaces>", "AnswerCount": "2", "OwnerUserId": "2282011", "Body": "<p>I was wondering wether namespaces can be splitted or if a definition of a namespace has to be in a single block. To illustrate what I mean:</p>\n<pre><code>namespace test\n{\n    //declare a bunch of stuff here\n    int a;\n}\n</code></pre>\n<p>Here we do something else like declaring a class or whatever</p>\n<pre><code>class T\n{\n};\n</code></pre>\n<p>and here continues the namespace from above, extending it</p>\n<pre><code>namespace test\n{\n    //declare a bunch of additional stuff here\n    int b;\n    T val;\n}\n</code></pre>\n<p>In this example the namespace <code>test</code> has been used twice, so does this mean that <code>test</code> is extended by the second defintion? When I used it like this in gcc it works as expected. I can access all variables with <code>test::...</code> as if it were defined in a single namespace. Of course this doesn't make it standard, so I would like to know if this is according to the standard.</p>\n<p>I was also surprised that I didn't even get a warning or such. But wouldn't this mean that you can accidently use a name which is already used without begin aware of it thus extending it?</p>\n", "CommentCount": "3", "PostTypeId": "1", "CreationDate": "2013-05-23T14:00:30.537", "ViewCount": "287", "LastActivityDate": "2013-05-23T14:10:18.510", "Id": "16715960", "LastEditorUserId": "1594913", "Title": "C++ Split namespace declarations", "Score": "2", "LastEditDate": "2013-05-23T14:02:42.263"}});