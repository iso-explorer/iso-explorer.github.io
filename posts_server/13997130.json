post_cb({"13997130": {"CommentCount": "3", "AcceptedAnswerId": "13997196", "PostTypeId": "1", "LastEditorUserId": "52251", "CreationDate": "2012-12-21T21:01:36.300", "LastActivityDate": "2013-01-12T14:49:34.553", "LastEditDate": "2012-12-21T21:12:58.480", "ViewCount": "254", "FavoriteCount": "1", "Title": "Are comparisons on out-of-range pointers well-defined?", "Id": "13997130", "Score": "13", "Body": "<p>Given the following code:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>char buffer[1024];\nchar * const begin = buffer;\nchar * const end = buffer + 1024;\nchar *p = begin + 2000;\nif (p &lt; begin || p &gt; end)\n    std::cout &lt;&lt; \"pointer is out of range\\n\";\n</code></pre>\n<p>Are the comparisons performed (<code>p &lt; begin</code> and <code>p &gt; end</code>) well-defined? Or does this code have undefined behaviour because the pointer has been advanced past the end of the array?</p>\n<p>If the comparisons are well defined, what is that definition?</p>\n<p>(extra credit: is the evaluation of <code>begin + 2000</code> itself undefined behaviour?)</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "52251", "AnswerCount": "3"}, "13997196": {"CommentCount": "5", "CreationDate": "2012-12-21T21:09:13.873", "CommunityOwnedDate": "2013-01-12T14:49:34.553", "LastEditorUserId": "635608", "LastActivityDate": "2013-01-12T14:49:34.553", "ParentId": "13997130", "PostTypeId": "2", "LastEditDate": "2013-01-12T14:49:34.553", "Id": "13997196", "Score": "6", "Body": "<p>The evaluation of <code>begin+2000</code> is undefined, it's going past the end of the array - you can go up to one past the end, but not further.</p>\n<p>From C++11 \u00a75.7/5 <em>Additive operators</em>:</p>\n<blockquote>\n<p id=\"so_13997130_13997196_0\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integral expression. [...] If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; <strong>otherwise, the behavior is\n  undefined</strong>.</p>\n</blockquote>\n<p>For pointer comparisons to be specified, assuming you have valid pointers to start with, they essentially need to be pointers to the same array (or one past the end), or pointers to non-static data members of the same access control of the same object (unless it's an union...). </p>\n<p>The details are in \u00a75.9/2 <em>Relational operators</em>:</p>\n<blockquote>\n<p id=\"so_13997130_13997196_1\">Pointers to objects or functions of the same type (after pointer conversions) can be compared, with a result defined as follows:</p>\n<ul>\n<li>If two pointers p and q of the same type point to the same object or function, or both point one past\n  the end of the same array, or are both null, then p&lt;=q and p&gt;=q both yield true and p&lt;q and p&gt;q\n  both yield false.</li>\n<li>If two pointers p and q of the same type point to different objects that are not members of the same\n  object or elements of the same array or to different functions, or if only one of them is null, the results\n  of p&lt;q, p&gt;q, p&lt;=q, and p&gt;=q are unspecified.</li>\n<li>If two pointers point to non-static data members of the same object, or to subobjects or array elements\n  of such members, recursively, the pointer to the later declared member compares greater provided the\n  two members have the same access control (Clause 11) and provided their class is not a union.</li>\n<li>If two pointers point to non-static data members of the same object with different access control\n  (Clause 11) the result is unspecified.\n  \u2014 If two pointers point to non-static data members of the same union object, they compare equal (after\n  conversion to void*, if necessary). If two pointers point to elements of the same array or one beyond\n  the end of the array, the pointer to the object with the higher subscript compares higher.</li>\n<li>Other pointer comparisons are unspecified.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "635608"}, "13997210": {"ParentId": "13997130", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I'll assume the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">C++11</a> standard.  According to section 5.7 (Additive Operands) paragraph 5, the behavior of <code>*p = begin + 2000</code> is undefined first, before you even get to the comparison:</p>\n<blockquote>\n<p id=\"so_13997130_13997210_0\">If both the pointer operand and the result point to elements of the\n  same array object, or one past the last element of the array object,\n  the evaluation shall not produce an over\ufb02ow; otherwise, the behavior\n  is unde\ufb01ned.</p>\n</blockquote>\n", "OwnerUserId": "384803", "LastEditorUserId": "384803", "LastEditDate": "2012-12-21T21:22:51.593", "Id": "13997210", "Score": "10", "CreationDate": "2012-12-21T21:10:39.177", "LastActivityDate": "2012-12-21T21:22:51.593"}, "bq_ids": {"n4140": {"so_13997130_13997196_0": {"section_id": 6142, "quality": 1.0, "length": 57}, "so_13997130_13998100_0": {"section_id": 6142, "quality": 1.0, "length": 32}, "so_13997130_13997210_0": {"section_id": 6142, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_13997130_13997196_1": {"section_id": 5913, "quality": 1.0, "length": 13}, "so_13997130_13997196_0": {"section_id": 5906, "quality": 1.0, "length": 57}, "so_13997130_13998100_0": {"section_id": 5906, "quality": 1.0, "length": 32}, "so_13997130_13997210_0": {"section_id": 5906, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_13997130_13997196_1": {"section_id": 7709, "quality": 0.5384615384615384, "length": 7}, "so_13997130_13998100_0": {"section_id": 7638, "quality": 0.625, "length": 20}}}, "13998100": {"ParentId": "13997130", "CommentCount": "1", "Body": "<p>Your program's behavior is undefined, but not because of the comparison.</p>\n<p>The evaluation of the expression <code>begin + 2000</code> has undefined behavior because the result would point more than one element past the end of the 1024-element array.</p>\n<p>Quoting C++11 (actually the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">N3485</a> draft), 5.7p4 [expr.add]:</p>\n<blockquote>\n<p id=\"so_13997130_13998100_0\">When an expression that has integral type is added to or subtracted\n  from a pointer, the result has the type of the pointer operand. [...]\n  If both the pointer operand and the result point to elements of the\n  same array object, or one past the last element of the array object,\n  the evaluation shall not produce an overflow; otherwise, the behavior\n  is undefined.</p>\n</blockquote>\n<p>In short, just computing an out-of-bounds pointer has undefined behavior; it doesn't matter what operations you perform on that pointer after that.</p>\n", "OwnerUserId": "827263", "PostTypeId": "2", "Id": "13998100", "Score": "3", "CreationDate": "2012-12-21T22:39:50.627", "LastActivityDate": "2012-12-21T22:39:50.627"}});