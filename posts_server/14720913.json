post_cb({"14720913": {"CommentCount": "2", "ViewCount": "553", "CreationDate": "2013-02-06T03:18:43.303", "LastActivityDate": "2013-02-06T05:12:43.903", "Title": "Is \"if (getline(fin, str)) {}\" conforming to the C++11 standard?", "AcceptedAnswerId": "14721483", "PostTypeId": "1", "Id": "14720913", "Score": "7", "Body": "<p>I checked the C++11 standard and found the following facts:</p>\n<ol>\n<li><p><code>std::getline(fin, str)</code> returns a <code>basic_ios</code> object, whose class has a member function <code>explicit operator bool() const;</code></p></li>\n<li><p>The class <code>basic_ios</code> doesn't have a member function <code>operator void*() const;</code> as pre-C++11.</p></li>\n</ol>\n<p>So, I think <code>if (getline(fin, str)) {}</code> is not standard conforming. It should be written as</p>\n<p><code>if (bool(getline(fin, str)){}</code>. (However, VC++ 2012 gives a warning on this usage. i.e. force void* to bool)</p>\n<p>Am I correct?</p>\n", "Tags": "<c++><c++11><type-conversion><iostream><explicit-conversion>", "OwnerUserId": "508343", "AnswerCount": "3"}, "14720925": {"ParentId": "14720913", "CommentCount": "0", "Body": "<p>The code is conforming. The explicit conversion operator to <code>bool</code> will be called when the object is used as a <em>condition</em> automatically. The change in the standard was meant to maintain that same usage while making it a bit safer.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "14720925", "Score": "12", "CreationDate": "2013-02-06T03:20:23.337", "LastActivityDate": "2013-02-06T03:20:23.337"}, "14721483": {"ParentId": "14720913", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>David is correct, and here are the quotes to back him up. In \u00a712.3.2/2, the Standard says</p>\n<blockquote>\n<p id=\"so_14720913_14721483_0\">A conversion function may be explicit (7.1.2), in which case it is only considered as a\n  user-defined conversion for direct-initialization (8.5). Otherwise, user-defined conversions \n  are not restricted to use in assignments and initializations. [ <em>Example</em>:</p>\n<pre><code>class Y { };\nstruct Z {\n    explicit operator Y() const;\n};\n\nvoid h(Z z) {\n    Y y1(z); // OK: direct-initialization\n    Y y2 = z; // ill-formed: copy-initialization\n    Y y3 = (Y)z; // OK: cast notation\n}\n</code></pre>\n<p id=\"so_14720913_14721483_1\">\u2014 <em>end example</em>]</p>\n</blockquote>\n<p>Some places where this contextual conversion happens is in the operand to <code>!</code>, the operands to <code>&amp;&amp;</code>, and the condition of an <code>if</code>.</p>\n<p>So <strong>direct initialisation can make use of explicit conversion operators</strong>, and in \u00a74/3,</p>\n<blockquote>\n<p id=\"so_14720913_14721483_2\">An expression e can be implicitly converted to a type <code>T</code> if and only if\n  the declaration <code>T t=e;</code> is well-formed, for some invented temporary\n  variable t (8.5). <strong>Certain language constructs require that an\n  expression be converted to a Boolean value. An expression e appearing\n  in such a context is said to be contextually converted to bool and is\n  well-formed if and only if the declaration <code>bool t(e);</code> is well-formed</strong>,\n  for some invented temporary variable <code>t</code> (8.5)...</p>\n</blockquote>\n<p>So as you can see, the standard specifies as-if direct initialisation for contextual conversions, so that's why explicit conversions work in <code>if</code> conditions.</p>\n", "OwnerUserId": "726361", "LastEditorUserId": "726361", "LastEditDate": "2013-02-06T05:12:43.903", "Id": "14721483", "Score": "6", "CreationDate": "2013-02-06T04:20:35.903", "LastActivityDate": "2013-02-06T05:12:43.903"}, "bq_ids": {"n4140": {"so_14720913_14721483_0": {"section_id": 392, "quality": 0.8823529411764706, "length": 15}, "so_14720913_14721483_2": {"section_id": 3, "quality": 0.6571428571428571, "length": 23}}, "n3337": {"so_14720913_14721483_0": {"section_id": 383, "quality": 0.8823529411764706, "length": 15}, "so_14720913_14721483_2": {"section_id": 2, "quality": 0.9428571428571428, "length": 33}}, "n4659": {"so_14720913_14721483_0": {"section_id": 409, "quality": 0.8823529411764706, "length": 15}, "so_14720913_14721483_2": {"section_id": 3, "quality": 0.6571428571428571, "length": 23}}}, "14721494": {"ParentId": "14720913", "CommentCount": "0", "Body": "<p><code>explicit operator bool</code> (and <em>only</em> <code>explicit operator bool</code>) has special language that allows it to be implicitly converted to a <code>bool</code> in <em>certain</em> circumstances. The specification language for this conversion is \"contextually converted to <code>bool</code>\".</p>\n<p>These are the places where the language does boolean testing. The conditional expression used by an <code>if/while/for</code> is \"contextually converted to <code>bool</code>\". As are the logical operators and the conditional operator (<code>?:</code>).</p>\n<p>So while you can't do these:</p>\n<pre><code>bool b = std::getline(fin, str);\nvoid func(bool) {}\nfunc(std::getline(fin, str));\n</code></pre>\n<p>You can do these:</p>\n<pre><code>while(std::getline(fin, str)) {...}\nfor(;std::getline(fin, str);) {...}\nif(std::getline(fin, str) &amp;&amp; somethingElse) {...}\n</code></pre>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "14721494", "Score": "8", "CreationDate": "2013-02-06T04:21:06.523", "LastActivityDate": "2013-02-06T04:21:06.523"}});