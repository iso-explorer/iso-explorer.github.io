post_cb({"bq_ids": {"n4140": {"so_34522504_34522520_0": {"length": 22, "quality": 0.7333333333333333, "section_id": 7210}}, "n3337": {"so_34522504_34522520_0": {"length": 20, "quality": 0.6666666666666666, "section_id": 6954}}, "n4659": {"so_34522504_34522520_0": {"length": 27, "quality": 0.9, "section_id": 8719}}}, "34522520": {"Id": "34522520", "PostTypeId": "2", "Body": "<p>No, reading from that bool after the memset is (at least, see below) unspecified behaviour so there is no guarantee as to what value will be returned.</p>\n<p>It might turn out that in the particular architecture, the value representation of a <code>bool</code> consists only of the high-order bit, in which case the value produced by broadcasting 123 over the byte(s) of the <code>bool</code> would be turn out to be a representation of <code>false</code>.</p>\n<p>The C++ standard does not specify what the actual bit patterns representing the values <code>true</code> and <code>false</code> are. An implementation may use any or all of the bits in the object representation of a <code>bool</code> -- which must be at least one byte, but might be longer -- and it may map more than one bit pattern to the same value:</p>\n<p>\u00a73.9.1 [basic.fundamental]/1:</p>\n<blockquote>\n<p id=\"so_34522504_34522520_0\">\u2026For narrow character types, all bits of the object representation participate in the value representation. For unsigned narrow character types, each possible bit pattern of the value representation represents a distinct number. These requirements do not hold for other types. </p>\n</blockquote>\n<p>Paragraph 6 of the same section requires values of type <code>bool</code> to be either <code>true</code> or <code>false</code>, but a footnote points out that in the face of undefined behaviour a <code>bool</code> \"might behave as if it is neither true nor false.\" (That's obviously within the bounds of undefined behaviour; if a program exhibits UB, there are no requirements whatsoever on its execution, even before the UB is evidenced.)</p>\n<p>Nothing in the standard permits using low-level memory copying operations on objects other than arrays of narrow chars, except for the case in which the object is trivially copyable and the object representation is saved by copying it to a buffer and later restored by copying it back. Any other use of C library functions which overwrite arbitrary bytes in an object representation should be undefined by the general definition of undefined behaviour (\"[the standard] omits any explicit definition of behavior\"). But I'm forced to agree that there is no explicit statement that <code>memset</code> is UB, and so I'll settle on unspecified behaviour, which seems quite clear since the representation of <code>bool</code> is certainly unspecified.</p>\n", "LastEditorUserId": "1566221", "LastActivityDate": "2015-12-30T05:58:45.317", "Score": "4", "CreationDate": "2015-12-30T03:27:11.007", "ParentId": "34522504", "CommentCount": "10", "OwnerUserId": "1566221", "LastEditDate": "2015-12-30T05:58:45.317"}, "34522504": {"ViewCount": "160", "Body": "<p>Bools are supposed to convert to 1 for true values and to 0 otherwise. However, that says nothing on how they may actually be stored in memory. What happens if I store an arbitrary non-zero value in a bool? Does the standard guarantee correct behavior when casting those to ints?</p>\n<p>For example, given the following program,</p>\n<pre><code>#include &lt;string.h&gt;\n\nint main()\n{\n  bool b;\n  memset( &amp;b, 123, sizeof( b ) );\n\n  return b;\n}\n</code></pre>\n<p>Does the standard guarantee the program would return 1?</p>\n", "AcceptedAnswerId": "34522520", "Title": "Should a compiler interpret an arbitrary non-zero value in bool as true correctly?", "CreationDate": "2015-12-30T03:24:31.830", "Id": "34522504", "CommentCount": "11", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-12-30T05:58:45.317", "Score": "6", "OwnerUserId": "882478", "Tags": "<c++><boolean><language-lawyer>", "AnswerCount": "1"}});