post_cb({"17437594": {"ParentId": "17437073", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Yes, <code>A</code> is a regular unqualified name lookup per 3.4.1, successively searching the scopes enclosing the nested-name-specifier, with the exception that only classes and namespace names are found. For example, you could have this:</p>\n<pre><code>int main()\n{\n    int X;\n    X::i = 42; // OK, int X not found.\n}\n</code></pre>\n<p><a href=\"http://ideone.com/NaEIVd\" rel=\"nofollow\">http://ideone.com/NaEIVd</a></p>\n<p>Actually using this loophole is not recommended; if <code>X</code> were an object of class type then <code>X::i</code> and <code>X.i</code> could be completely different things.</p>\n<hr>\n<p>To arrive at this conclusion from the Standard, start at 3.4.3 (qualified lookup, which is the high-level construct we're ultimately analyzing), which says in paragraph 1,</p>\n<blockquote>\n<p id=\"so_17437073_17437594_0\">The name of a class or namespace member or enumerator can be referred to after the :: scope resolution operator (5.1) applied to a nested-name-specifier that denotes its class, namespace, or enumeration. <strong>If a :: scope resolution operator in a nested-name-specifier is not preceded by a decltype-specifier, lookup of the name preceding that :: considers only namespaces, types, and templates whose specializations are types.</strong> If the name found does not designate a namespace or a class, enumeration, or dependent type, the program is ill-formed.</p>\n</blockquote>\n<p>Reading on to paragraph 2, it doesn't apply because the qualified-id isn't being declared. The remaining paragraphs likewise specify inapplicable exceptions. So, what is the thing preceding the <code>::</code>? Refer to the grammar.</p>\n<pre><code>nested-name-specifier:\n    ::\n    type-name ::\n    namespace-name ::\n    decltype-specifier ::\n    nested-name-specifier identifier ::\n    nested-name-specifier templateopt simple-template-id ::\n</code></pre>\n<p>Only <code>type-name ::</code> and <code>namespace-name ::</code> match our a priori criteria. Also these overlap with what we've found so far. How is a <code>type-name</code> or <code>namespace-name</code> usually resolved in a particular context? Unqualified lookup. Proceed to 3.4.1.</p>\n<p>First, 3.4.1/1 is a general rule to bear in mind:</p>\n<blockquote>\n<p id=\"so_17437073_17437594_1\">In all the cases listed in 3.4.1, the scopes are searched for a declaration in the order listed in each of the respective categories; name lookup ends as soon as a declaration is found for the name. If no declaration is found, the program is ill-formed.</p>\n</blockquote>\n<p>The next applicable paragraph is 6:</p>\n<blockquote>\n<p id=\"so_17437073_17437594_2\">A name used in the definition of a function following the function\u2019s declarator-id that is a member of namespace N (where, only for the purpose of exposition, N could represent the global scope) shall be declared before its use in the block in which it is used or in one of its enclosing blocks (6.3) or, shall be declared before its use in namespace N or, if N is a nested namespace, shall be declared before its use in one of N\u2019s enclosing namespaces.</p>\n</blockquote>\n<p>This rule doesn't tell us to <em>actually</em> search in the global namespace for the name, but it does mention the function's enclosing namespace (in this case the global one) in a list, and paragraph 1 says to search listed namespaces. So that's sufficient to construct a name lookup.</p>\n<p>What it surprisingly doesn't do is mention a recursive search prioritizing inner, enclosed namespaces, but you don't actually have such a thing in your example so I'll stop here :) . It's much faster to leave compiling to the compiler, and work manually only in case of a problem.</p>\n</hr>", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2013-07-03T01:09:10.183", "Id": "17437594", "Score": "4", "CreationDate": "2013-07-02T23:49:19.123", "LastActivityDate": "2013-07-03T01:09:10.183"}, "17437397": {"ParentId": "17437073", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In the example you gave, <code>X</code> would be considered an unqualified name lookup.  And as such it does follow the rules in 3.4.1</p>\n<p>In this case the namespaces searched are as follows:</p>\n<ol>\n<li>The local namespace of the <code>main()</code> function prior to the definition. (In which a namespace may not be defined per 7.3.1.4.)</li>\n<li>The global namespace.</li>\n</ol>\n<p>I'm afraid I can't point to a place in the standard where it specifically says namespace names are the same as any other name.  But they are.  The name lookup doesn't know that's a namespace name (it could be a class name or a struct name) until it actually finds a namespace with that name.</p>\n", "OwnerUserId": "483486", "LastEditorUserId": "483486", "LastEditDate": "2013-07-02T23:35:34.340", "Id": "17437397", "Score": "1", "CreationDate": "2013-07-02T23:26:07.593", "LastActivityDate": "2013-07-02T23:35:34.340"}, "bq_ids": {"n4140": {"so_17437073_17437594_0": {"section_id": 7107, "quality": 0.9777777777777777, "length": 44}, "so_17437073_17437594_1": {"section_id": 7087, "quality": 0.9545454545454546, "length": 21}, "so_17437073_17437594_2": {"section_id": 7092, "quality": 1.0, "length": 38}}, "n3337": {"so_17437073_17437594_0": {"section_id": 6851, "quality": 0.9777777777777777, "length": 44}, "so_17437073_17437594_1": {"section_id": 6831, "quality": 0.9545454545454546, "length": 21}, "so_17437073_17437594_2": {"section_id": 6836, "quality": 1.0, "length": 38}}, "n4659": {"so_17437073_17437594_0": {"section_id": 8608, "quality": 0.9777777777777777, "length": 44}, "so_17437073_17437594_1": {"section_id": 8588, "quality": 0.9545454545454546, "length": 21}, "so_17437073_17437594_2": {"section_id": 8593, "quality": 0.7105263157894737, "length": 27}}}, "17437073": {"CommentCount": "7", "ViewCount": "433", "PostTypeId": "1", "LastEditorUserId": "1131467", "CreationDate": "2013-07-02T22:49:11.610", "LastActivityDate": "2013-07-03T01:09:10.183", "Title": "Name lookup of first namespace name in nested-name-specifier?", "AcceptedAnswerId": "17437594", "LastEditDate": "2013-07-03T00:15:06.450", "Id": "17437073", "Score": "4", "Body": "<p>Given a nested-name-specifier <code>A::</code> in a translation unit that doesn't have any classes, templates, enumerations, or typedefs, if well-formed, the identifier <code>A</code> must refer to a namespace.</p>\n<p>For example:</p>\n<pre><code>namespace X\n{\n    int i;\n}\n\nint main()\n{\n    X::i = 42; // Here X:: is a nested-name-specifier\n               // and X is a namespace-name\n               // i is looked up qualified w.r.t. X\n}\n</code></pre>\n<p>In the above example <code>A</code> is <code>X</code>, however my question is about the general case.</p>\n<p>How does name lookup proceed for a namespace-name <code>A</code> in <code>A::</code>?</p>\n<p>The name lookup rules are summarized in 3.4, but it isn't clear to me how (or which ones) that apply in such a situation.</p>\n<p>For example, is the lookup of <code>A</code> an unqualified name lookup?  Does 3.4.1 apply to it?</p>\n<p>Put another way: Which namespaces are searched for a namespace named <code>A</code>, and in what order?  How did you conclude this from the standard?</p>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "1131467", "AnswerCount": "2"}});