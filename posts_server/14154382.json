post_cb({"bq_ids": {"n4140": {"so_14154382_14154812_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 5800}}, "n3337": {"so_14154382_14154812_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 5573}}, "n4659": {"so_14154382_14154812_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 7259}}}, "14154382": {"ViewCount": "270", "Body": "<p>In a response to my comment to some <a href=\"https://stackoverflow.com/a/1633537/91757\">answer in another question</a> somebody suggests that something like</p>\n<pre><code>void C::f() const\n{\n  const_cast&lt;C *&gt;( this )-&gt;m_x = 1;\n}\n</code></pre>\n<p>invokes undefined behaviour since a const object is modified. Is this true? If it isn't, please quote the C++ standard (please mention which standard you quote from) which permits this.</p>\n<p>For what it's worth, I've always used this approach to avoid making a member variable <code>mutable</code> if just one or two methods need to write to it (since using <code>mutable</code> makes it writeable to <em>all</em> methods).</p>\n", "AcceptedAnswerId": "14155034", "Title": "Does casting away constness from \"this\" and then changing a member value invoke undefined behaviour?", "CreationDate": "2013-01-04T09:26:48.677", "Id": "14154382", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:27:41.760", "LastEditorUserId": "-1", "LastActivityDate": "2013-01-04T10:43:18.880", "Score": "6", "OwnerUserId": "91757", "Tags": "<c++><const><standards-compliance><const-cast>", "AnswerCount": "3"}, "14154470": {"Id": "14154470", "PostTypeId": "2", "Body": "<p>There are two rules:</p>\n<ol>\n<li><p>You cannot modify a const object.</p></li>\n<li><p>You cannot modify an object through a const pointer or reference.</p></li>\n</ol>\n<p>You break neither rule if the underlying object is not const. There is a common <a href=\"http://ideone.com/3NzrYK\">misunderstanding</a> that the presence of a const pointer or const reference to an object somehow stops that object from changing or being changed. That is simply a misunderstanding. For example:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n// 'const' means *you* can't change the value through that reference\n// It does not mean the value cannot change\n\nvoid f(const int&amp; x, int* y)\n{\n    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; endl;\n    *y = 5;\n    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; endl;\n}\n\nint main()\n{\n    int x = 10;\n    f(x, &amp;x);\n}\n</code></pre>\n<p>Notice no casts, nothing funny. Yet an object that a function has a const reference to is modified by that function. That is allowed. Your code is the same, it just does it by casting away constness.</p>\n<p>However, if the underlying object is const, this is illegal. For example, <a href=\"http://ideone.com/52Ismp\">this code</a> segfaults on my machine:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconst int i = 5;\n\nvoid cast(const int *j)\n{\n    *const_cast&lt;int *&gt;(j) = 1;\n}\n\nint main(void)\n{\n    cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl;\n    cast(&amp;i);\n    cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl;\n}\n</code></pre>\n<p>See section 3.4.3 (CV qualifiers) and 5.2.7 (casting away constness).</p>\n", "LastEditorUserId": "721269", "LastActivityDate": "2013-01-04T09:56:14.237", "Score": "8", "CreationDate": "2013-01-04T09:32:07.640", "ParentId": "14154382", "CommentCount": "14", "LastEditDate": "2013-01-04T09:56:14.237", "OwnerUserId": "721269"}, "14155034": {"Id": "14155034", "PostTypeId": "2", "Body": "<p>It is undefined behavior to (attempt to) modify a const object (7.1.6.1/4 in C++11).</p>\n<p>So the important question is, what is a const object, and is <code>m_x</code> one? If it is, then you have UB. If it is not, then there's nothing here to indicate that it would be UB -- of course it might be UB for some other reason not indicated here (for example, a data race).</p>\n<p>If the function <code>f</code> is called on a const instance of the class <code>C</code>, then <code>m_x</code> <em>is</em> a const object, and hence behavior is undefined (7.1.6.1/5):</p>\n<pre><code>const C c;\nc.f(); // UB\n</code></pre>\n<p>If the function <code>f</code> is called on a non-const instance of the class <code>C</code>, then <code>m_x</code> is not a const object, and hence behavior is defined as far as we know:</p>\n<pre><code>C c;\nconst C *ptr = &amp;c;\nc-&gt;f(); // OK\n</code></pre>\n<p>So, if you write this function then you are at the mercy of your user not to create a const instance of <code>C</code> and call the function on it. Perhaps instances of <code>C</code> are created only by some factory, in which case you would be able to prevent that.</p>\n<p>If you want a data member to be modifiable even if the complete object is <code>const</code>, then you should mark it <code>mutable</code>. That's what <code>mutable</code> is for, and it gives you defined behavior even if <code>f</code> is called on a const instance of <code>C</code>.</p>\n<p>As of C++11, <code>const</code> member functions and operations on <code>mutable</code> data members should be thread-safe. Otherwise you violate guarantees provided by standard library, when your type is used with standard library functions and containers.</p>\n<p>So in C++11 you would need to either make <code>m_x</code> an atomic type, or else synchronize the modification some other way, or as a last resort document that even though it is marked const, the function <code>f</code> is not thread-safe. If you don't do any of those things, then again you create an opportunity for a user to write code that they reasonably believe ought to work but that actually has UB.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2013-01-04T10:43:18.880", "Score": "11", "CreationDate": "2013-01-04T10:09:33.640", "ParentId": "14154382", "CommentCount": "3", "LastEditDate": "2013-01-04T10:43:18.880", "OwnerUserId": "13005"}, "14154812": {"Id": "14154812", "PostTypeId": "2", "Body": "<p>Without searching any further, \u00a7 1.9/4 in the C++11 Standard reads:</p>\n<blockquote>\n<p id=\"so_14154382_14154812_0\">Certain other operations are described in this International Standard\n  as undefined (for example, the effect of attempting to modify a const\n  object).</p>\n</blockquote>\n<p>And this is what you are trying to do here. It does not matter that you are casting away constness (if you didn't do it, the behaviour is well defined: your code would fail to compile). You are attempting to modify a <code>const</code> object, so you are running into undefined behaviour.</p>\n<p>Your code will appear to work in many cases. But it won't if the object you are calling it on is really <code>const</code> and the runtime decided to store it in read-only memory. Casting away constness is dangerous unless you are really sure that this object was not <code>const</code> originally.</p>\n", "LastActivityDate": "2013-01-04T09:54:45.053", "Score": "-1", "CreationDate": "2013-01-04T09:54:45.053", "ParentId": "14154382", "CommentCount": "9", "OwnerUserId": "25824"}});