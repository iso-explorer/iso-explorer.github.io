post_cb({"37481993": {"Id": "37481993", "PostTypeId": "2", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/lambda\">http://en.cppreference.com/w/cpp/language/lambda</a>:</p>\n<blockquote>\n<p id=\"so_37481767_37481993_0\">The lambda expression constructs an unnamed prvalue temporary object of unique unnamed non-union non-aggregate class type, <strong>known as closure type</strong>, which is declared (for the purposes of ADL) in the smallest block scope, class scope, or namespace scope that contains the lambda expression.</p>\n<p id=\"so_37481767_37481993_1\"><strong>If the lambda-expression captures anything by copy</strong> (either implicitly with capture clause [=] or explicitly with a capture that does not include the character &amp;, e.g. [a, b, c]), <strong>the closure type includes unnamed non-static data members</strong>, declared in unspecified order, that hold copies of all entities that were so captured.</p>\n<p id=\"so_37481767_37481993_2\">For the entities that are <strong>captured by reference</strong> (with the default capture [&amp;] or when using the character &amp;, e.g. [&amp;a, &amp;b, &amp;c]), it is <strong>unspecified if additional data members are declared</strong> in the closure type</p>\n</blockquote>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/language/sizeof\">http://en.cppreference.com/w/cpp/language/sizeof</a></p>\n<blockquote>\n<p id=\"so_37481767_37481993_3\">When applied to an empty class type, always returns 1.</p>\n</blockquote>\n", "LastEditorUserId": "6271671", "LastActivityDate": "2016-05-27T11:17:08.923", "Score": "7", "CreationDate": "2016-05-27T11:10:21.953", "ParentId": "37481767", "CommentCount": "0", "OwnerUserId": "6271671", "LastEditDate": "2016-05-27T11:17:08.923"}, "37481943": {"Id": "37481943", "PostTypeId": "2", "Body": "<p>A lambda is not a function pointer.</p>\n<p>A lambda is an instance of a class. Your code is approximately equivalent to:</p>\n<pre><code>class f_lambda {\npublic:\n\n  auto operator() { return 17; }\n};\n\nf_lambda f;\nstd::cout &lt;&lt; f() &lt;&lt; std::endl;\nstd::cout &lt;&lt; &amp;f &lt;&lt; std::endl;\nstd::cout &lt;&lt; sizeof(f) &lt;&lt; std::endl;\n</code></pre>\n<p>The internal class that represents a lambda has no class members, hence its <code>sizeof()</code> is 1 (it cannot be 0, for reasons adequately stated <a href=\"https://stackoverflow.com/questions/2632021/can-sizeof-return-0-zero\">elsewhere</a>).</p>\n<p>If your lambda were to capture some variables, they'll be equivalent to class members, and your <code>sizeof()</code> will indicate accordingly.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-05-27T16:36:18.733", "Score": "46", "CreationDate": "2016-05-27T11:08:09.307", "ParentId": "37481767", "CommentCount": "2", "OwnerUserId": "3943312", "LastEditDate": "2017-05-23T12:10:22.357"}, "37486796": {"Id": "37486796", "PostTypeId": "2", "Body": "<p>The lambda in question actually has <em>no state</em>.</p>\n<p>Examine:</p>\n<pre><code>struct lambda {\n  auto operator()() const { return 17; }\n};\n</code></pre>\n<p>And if we had <code>lambda f;</code>, it is an empty class.  Not only is the above <code>lambda</code> functionally similar to your lambda, it is (basically) how your lambda is implemented!  (It also needs an implicit cast to function pointer operator, and the name <code>lambda</code> is going to be replaced with some compiler-generated pseudo-guid)</p>\n<p>In C++, objects are not pointers.  They are actual things.  They only use up the space required to store the data in them.  A pointer to an object can be larger than an object.</p>\n<p>While you might think of that lambda as a pointer to a function, it isn't.  You cannot reassign the <code>auto f = [](){ return 17; };</code> to a different function or lambda!</p>\n<pre><code> auto f = [](){ return 17; };\n f = [](){ return -42; };\n</code></pre>\n<p>the above is <em>illegal</em>.  There is no room in <code>f</code> to store <em>which</em> function is going to be called -- that information is stored in the <em>type</em> of <code>f</code>, not in the value of <code>f</code>!</p>\n<p>If you did this:</p>\n<pre><code>int(*f)() = [](){ return 17; };\n</code></pre>\n<p>or this:</p>\n<pre><code>std::function&lt;int()&gt; f = [](){ return 17; };\n</code></pre>\n<p>you are no longer storing the lambda directly.  In both of these cases, <code>f = [](){ return -42; }</code> is legal -- so in these cases, we are storing <em>which</em> function we are invoking in the value of <code>f</code>.  And <code>sizeof(f)</code> is no longer <code>1</code>, but rather <code>sizeof(int(*)())</code> or larger (basically, be pointer sized or larger, as you expect.  <code>std::function</code> has a min size implied by the standard (they have to be able to store \"inside themselves\" callables up to a certain size) which is at least as large as a function pointer in practice).</p>\n<p>In the <code>int(*f)()</code> case, you are storing a function pointer to a function that behaves as-if you called that lambda.  This only works for stateless lambdas (ones with an empty <code>[]</code> capture list).</p>\n<p>In the <code>std::function&lt;int()&gt; f</code> case, you are creating a type-erasure class <code>std::function&lt;int()&gt;</code> instance that (in this case) uses placement new to store a copy of the size-1 lambda in an internal buffer (and, if a larger lambda was passed in (with more state), would use heap allocation).</p>\n<p>As a guess, something like these is probably what you think is going on.  That a lambda is an object whose type is described by its signature.  In C++, it was decided to make lambdas <em>zero cost</em> abstractions over the manual function object implementation.  This lets you pass a lambda into a <code>std</code> algorithm (or similar) and have its contents be fully visible to the compiler when it instantiates the algorithm template.  If a lambda had a type like <code>std::function&lt;void(int)&gt;</code>, its contents would not be fully visible, and a hand-crafted function object might be faster.</p>\n<p>The goal of C++ standardization is high level programming with zero overhead over hand-crafted C code.</p>\n<p>Now that you understand that your <code>f</code> is in fact stateless, there should be another question in your head: the lambda has no state.  Why does it not size have <code>0</code>?</p>\n<hr>\n<p>There is the short answer.</p>\n<p>All objects in C++ must have a minimium size of 1 under the standard, and two objects of the same type cannot have the same address.  These are connected, because an array of type <code>T</code> will have the elements placed <code>sizeof(T)</code> apart.</p>\n<p>Now, as it has no state, sometimes it can take up no space.  This cannot happen when it is \"alone\", but in some contexts it can happen.  <code>std::tuple</code> and similar library code exploits this fact.  Here is how it works:</p>\n<p>As a lambda is equivalent to a class with <code>operator()</code> overloaded, stateless lambdas (with a <code>[]</code> capture list) are all empty classes.  They have <code>sizeof</code> of <code>1</code>.  In fact, if you inherit from them (which is allowed!), they will take up no space <em>so long as it doesn't cause a same-type address collision</em>.  (This is known as the empty base optimization).</p>\n<pre><code>template&lt;class T&gt;\nstruct toy:T {\n  toy(toy const&amp;)=default;\n  toy(toy &amp;&amp;)=default;\n  toy(T const&amp;t):T(t) {}\n  toy(T &amp;&amp;t):T(std::move(t)) {}\n  int state = 0;\n};\n\ntemplate&lt;class Lambda&gt;\ntoy&lt;Lambda&gt; make_toy( Lambda const&amp; l ) { return {l}; }\n</code></pre>\n<p>the <code>sizeof(make_toy( []{std::cout &lt;&lt; \"hello world!\\n\"; } ))</code> is <code>sizeof(int)</code> (well, the above is illegal because you cannot create a lambda in a non-evaluated context: you have to create a named <code>auto toy = make_toy(blah);</code> then do <code>sizeof(blah)</code>, but that is just noise).  <code>sizeof([]{std::cout &lt;&lt; \"hello world!\\n\"; })</code> is still <code>1</code> (similar qualifications).</p>\n<p>If we create another toy type:</p>\n<pre><code>template&lt;class T&gt;\nstruct toy2:T {\n  toy2(toy2 const&amp;)=default;\n  toy2(T const&amp;t):T(t), t2(t) {}\n  T t2;\n};\ntemplate&lt;class Lambda&gt;\ntoy2&lt;Lambda&gt; make_toy2( Lambda const&amp; l ) { return {l}; }\n</code></pre>\n<p>this has <em>two copies</em> of the lambda.  As they cannot share the same address, <code>sizeof(toy2(some_lambda))</code> is <code>2</code>!</p>\n</hr>", "LastEditorUserId": "1774667", "LastActivityDate": "2016-05-31T20:05:38.030", "Score": "100", "CreationDate": "2016-05-27T15:06:37.273", "ParentId": "37481767", "CommentCount": "2", "OwnerUserId": "1774667", "LastEditDate": "2016-05-31T20:05:38.030"}, "37482103": {"Id": "37482103", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_37481767_37482103_0\">Shouldn't the lambda be, at mimumum, a pointer to its implementation? </p>\n</blockquote>\n<p>Not necessarily. According to the standard, the size of the unique, unnamed class is <em>implementation-defined</em>. Excerpt from <strong>[expr.prim.lambda]</strong>, C++14 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_37481767_37482103_1\">The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed nonunion class type \u2014 called the closure type \u2014 whose properties are described below.</p>\n<p id=\"so_37481767_37482103_2\">[ ... ]</p>\n<p id=\"so_37481767_37482103_3\"><strong>An implementation may define the closure type differently from what is described below</strong> provided this does not alter the observable behavior of the program <strong>other than by changing</strong>:</p>\n<p id=\"so_37481767_37482103_4\"><strong>\u2014 the size and/or alignment of the closure type</strong>,</p>\n<p id=\"so_37481767_37482103_5\">\u2014 whether the closure type is trivially copyable (Clause 9),</p>\n<p id=\"so_37481767_37482103_6\">\u2014 whether the closure type is a standard-layout class (Clause 9), or</p>\n<p id=\"so_37481767_37482103_7\">\u2014 whether the closure type is a POD class (Clause 9)</p>\n</blockquote>\n<p>In your case -- for the compiler you use -- you get a size of 1, which doesn't mean it's fixed. It can vary between different compiler implementations.</p>\n", "LastActivityDate": "2016-05-27T11:16:01.620", "CommentCount": "4", "CreationDate": "2016-05-27T11:16:01.620", "ParentId": "37481767", "Score": "12", "OwnerUserId": "183120"}, "bq_ids": {"n4140": {"so_37481767_37482103_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 5962}, "so_37481767_37481993_3": {"length": 5, "quality": 0.7142857142857143, "section_id": 589}, "so_37481767_37482103_6": {"length": 6, "quality": 1.0, "section_id": 5962}, "so_37481767_37482103_7": {"length": 6, "quality": 1.0, "section_id": 5962}, "so_37481767_37482103_5": {"length": 6, "quality": 1.0, "section_id": 5962}, "so_37481767_37481993_0": {"length": 16, "quality": 0.5333333333333333, "section_id": 5962}, "so_37481767_37482103_3": {"length": 17, "quality": 1.0, "section_id": 5962}, "so_37481767_37482103_4": {"length": 5, "quality": 1.0, "section_id": 5962}}, "n3337": {"so_37481767_37482103_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 5731}, "so_37481767_37481993_3": {"length": 5, "quality": 0.7142857142857143, "section_id": 579}, "so_37481767_37482103_6": {"length": 6, "quality": 1.0, "section_id": 5731}, "so_37481767_37482103_7": {"length": 6, "quality": 1.0, "section_id": 5731}, "so_37481767_37482103_5": {"length": 6, "quality": 1.0, "section_id": 5731}, "so_37481767_37481993_0": {"length": 16, "quality": 0.5333333333333333, "section_id": 5731}, "so_37481767_37482103_3": {"length": 17, "quality": 1.0, "section_id": 5731}, "so_37481767_37482103_4": {"length": 5, "quality": 1.0, "section_id": 5731}}, "n4659": {"so_37481767_37482103_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 7451}, "so_37481767_37481993_3": {"length": 5, "quality": 0.7142857142857143, "section_id": 612}, "so_37481767_37482103_6": {"length": 6, "quality": 1.0, "section_id": 7452}, "so_37481767_37482103_7": {"length": 6, "quality": 1.0, "section_id": 7452}, "so_37481767_37482103_5": {"length": 6, "quality": 1.0, "section_id": 7452}, "so_37481767_37482103_3": {"length": 17, "quality": 1.0, "section_id": 7452}, "so_37481767_37482103_4": {"length": 5, "quality": 1.0, "section_id": 7452}}}, "37481930": {"Id": "37481930", "PostTypeId": "2", "Body": "<p>Your compiler more or less translates the lambda to the following struct type:</p>\n<pre><code>struct _SomeInternalName {\n    int operator()() { return 17; }\n};\n\nint main()\n{\n     _SomeInternalName f;\n     std::cout &lt;&lt; f() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Since that struct has no non-static members, it has the same size as an empty struct, which is <code>1</code>.</p>\n<p>That changes as soon as you add a non-empty capture list to your lambda:</p>\n<pre><code>int i = 42;\nauto f = [i]() { return i; };\n</code></pre>\n<p>Which will translate to</p>\n<pre><code>struct _SomeInternalName {\n    int i;\n    _SomeInternalName(int outer_i) : i(outer_i) {}\n    int operator()() { return i; }\n};\n\n\nint main()\n{\n     int i = 42;\n     _SomeInternalName f(i);\n     std::cout &lt;&lt; f() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Since the generated struct now needs to store a non-static <code>int</code> member for the capture, its size will grow to <code>sizeof(int)</code>. The size will keep growing as you capture more stuff.</p>\n<p>(Please take the struct analogy with a grain of salt. While it's a nice way to reason about how lambdas work internally, this is not a literal translation of what the compiler will do)</p>\n", "LastEditorUserId": "577603", "LastActivityDate": "2016-05-27T12:28:58.590", "Score": "25", "CreationDate": "2016-05-27T11:07:46.653", "ParentId": "37481767", "CommentCount": "0", "OwnerUserId": "577603", "LastEditDate": "2016-05-27T12:28:58.590"}, "37481767": {"ViewCount": "5743", "Body": "<p>I am working with the memory of some lambdas in C++, but I am a bit puzzled by their size. </p>\n<p>Here is my test code: </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n  auto f = [](){ return 17; };\n  std::cout &lt;&lt; f() &lt;&lt; std::endl;\n  std::cout &lt;&lt; &amp;f &lt;&lt; std::endl;\n  std::cout &lt;&lt; sizeof(f) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>You can run it here: <a href=\"http://fiddle.jyt.io/github/b13f682d1237eb69ebdc60728bb52598\" rel=\"nofollow noreferrer\">http://fiddle.jyt.io/github/b13f682d1237eb69ebdc60728bb52598</a></p>\n<p>The ouptut is:</p>\n<pre><code>17\n0x7d90ba8f626f\n1\n</code></pre>\n<p>This suggests that the size of my lambda is 1. </p>\n<ul>\n<li><p>How is this possible? </p></li>\n<li><p>Shouldn't the lambda be, at minimum, a pointer to its implementation? </p></li>\n</ul>\n", "AcceptedAnswerId": "37486796", "Title": "Why does a lambda have a size of 1 byte?", "CreationDate": "2016-05-27T11:00:22.357", "Id": "37481767", "CommentCount": "6", "FavoriteCount": "15", "PostTypeId": "1", "LastEditDate": "2017-06-16T15:17:06.263", "LastEditorUserId": "3980929", "LastActivityDate": "2017-06-16T15:17:06.263", "Score": "81", "OwnerUserId": "1256041", "Tags": "<c++><c++11><lambda><c++14><sizeof>", "AnswerCount": "5"}});