post_cb({"46460970": {"Id": "46460970", "PostTypeId": "2", "Body": "<p>Many compilers allow arrays of size <code>0</code>. The alignment remains the same as the alignment of the sole element.</p>\n<p>(Among other things, this is useful for forcing a particular alignment in cases when you can't use a bitfield)</p>\n", "LastActivityDate": "2017-09-28T04:26:10.280", "CommentCount": "2", "CreationDate": "2017-09-28T04:26:10.280", "ParentId": "46457449", "Score": "7", "OwnerUserId": "1405588"}, "46458123": {"Id": "46458123", "PostTypeId": "2", "Body": "<p>According to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">c++ 11 standard</a> that introduced the <code>alignof</code> operator, <code>sizeof</code> is defined as following (see 5.3.3 expr.sizeof):</p>\n<blockquote>\n<p id=\"so_46457449_46458123_0\">The sizeof operator yields the number of bytes in the object representation of its operand</p>\n</blockquote>\n<p>Whereas <code>alignof</code> definition is (see 5.3.6 expr.alignof):</p>\n<blockquote>\n<p id=\"so_46457449_46458123_1\">An alignof expression yields the alignment requirement of its operand type.</p>\n</blockquote>\n<p>Since the defintion of <code>alignof</code> specifies a requirement, possibly made by the user, rather than a specification of the language, we can manipulate the compiler:</p>\n<pre><code>typedef uint32_t __attribute__ ((aligned (64))) aligned_uint32_t;\nstd::cout &lt;&lt; sizeof(aligned_uint32_t) &lt;&lt; \" -&gt; \" &lt;&lt; alignof(aligned_uint32_t);\n// Output: 4 -&gt; 64\n</code></pre>\n<p><strong>Edited</strong></p>\n<p>As others have pointed out, such types cannot be used in arrays, e.g trying to compile the following:</p>\n<pre><code>aligned_uint32_t arr[2];\n</code></pre>\n<p>Results in <code>error: alignment of array elements is greater than element size</code></p>\n<p>Since arrays require the specified type to conform with the condition: <code>sizeof(T) &gt;= alignof(T)</code></p>\n", "LastEditorUserId": "1030410", "LastActivityDate": "2017-09-27T22:36:40.200", "Score": "7", "CreationDate": "2017-09-27T22:22:30.703", "ParentId": "46457449", "CommentCount": "2", "OwnerUserId": "1030410", "LastEditDate": "2017-09-27T22:36:40.200"}, "bq_ids": {"n4140": {"so_46457449_46458123_1": {"length": 8, "quality": 1.0, "section_id": 6117}, "so_46457449_46458123_0": {"length": 9, "quality": 0.9, "section_id": 6076}}, "n3337": {"so_46457449_46458123_1": {"length": 8, "quality": 1.0, "section_id": 5881}, "so_46457449_46458123_0": {"length": 9, "quality": 0.9, "section_id": 5844}}, "n4659": {"so_46457449_46458123_1": {"length": 8, "quality": 1.0, "section_id": 7614}, "so_46457449_46458123_0": {"length": 9, "quality": 0.9, "section_id": 7572}}}, "46457449": {"ViewCount": "1689", "Body": "<p>For any object type <code>T</code> is it always the case that <code>sizeof(T)</code> is at least as large as <code>alignof(T)</code>?</p>\n<p>Intuitively it seems so, since even when you adjust the alignment of objects like: </p>\n<pre><code>struct small {\n  char c;\n};\n</code></pre>\n<p>above what it would normally be, their \"size\" is also adjusted upwards so that the relationship between objects in an array makes sense while maintaining alignment (at least in my <a href=\"http://coliru.stacked-crooked.com/a/d27a419d81c12f2d\" rel=\"noreferrer\">testing</a>. For example:</p>\n<pre><code>struct alignas(16) small16 {\n  char c;\n};\n</code></pre>\n<p>Has both a size and alignment of 16.</p>\n", "AcceptedAnswerId": "46457636", "Title": "Is it always the case that sizeof(T) >= alignof(T) for all object types T?", "CreationDate": "2017-09-27T21:23:27.950", "Id": "46457449", "CommentCount": "26", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2017-09-28T17:55:35.283", "LastEditorUserId": "149138", "LastActivityDate": "2017-10-12T02:55:18.460", "Score": "39", "OwnerUserId": "149138", "Tags": "<c++><c++11><memory-alignment><alignof>", "AnswerCount": "4"}, "46457954": {"Id": "46457954", "PostTypeId": "2", "Body": "<pre><code>#include &lt;iostream&gt;\n\ntypedef double foo __attribute__ ((aligned (64)));\nalignas(64) double bar;\ndouble baz __attribute__ ((aligned (64)));\n\nint main(int argc, char *argv[]) {\n    std::cout &lt;&lt; \"foo sizeof: \" &lt;&lt; sizeof(foo) &lt;&lt; \" alignof: \" &lt;&lt; alignof(foo) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"bar sizeof: \" &lt;&lt; sizeof(bar) &lt;&lt; \" alignof: \" &lt;&lt; alignof(decltype(bar)) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"baz sizeof: \" &lt;&lt; sizeof(baz) &lt;&lt; \" alignof: \" &lt;&lt; alignof(decltype(baz)) &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Compile with:</p>\n<pre><code>clang++ -std=c++11 alignof_test.cpp -o alignof_test &amp;&amp; ./alignof_test\n</code></pre>\n<p>Output:</p>\n<pre><code>foo sizeof: 8 alignof: 64\nbar sizeof: 8 alignof: 8\nbaz sizeof: 8 alignof: 8\n</code></pre>\n<p>So strictly speaking, no, but the above argument re: arrays has to be preserved.</p>\n", "LastEditorUserId": "3877787", "LastActivityDate": "2017-09-27T22:11:16.563", "Score": "12", "CreationDate": "2017-09-27T22:07:25.513", "ParentId": "46457449", "CommentCount": "8", "OwnerUserId": "3877787", "LastEditDate": "2017-09-27T22:11:16.563"}, "46457636": {"Id": "46457636", "PostTypeId": "2", "Body": "<p>At least in standard C++, for anything you can make an array of (with length &gt; 1), this will have to be true. If you have</p>\n<pre><code>Foo arr[2];\n</code></pre>\n<p>and <code>alignof(Foo) &gt; sizeof(Foo)</code>, then <code>arr[0]</code> and <code>arr[1]</code> can't both be aligned.</p>\n<p>As <a href=\"https://stackoverflow.com/a/46457954\">Zalman Stern's example</a> shows, though, at least some compilers will allow you to declare a type with alignment greater than its size, with the result that the compiler simply won't let you declare an array of that type. This is not standards-compliant C++ (it uses type attributes, which <a href=\"https://gcc.gnu.org/onlinedocs/gcc-7.2.0/gcc/Common-Type-Attributes.html\" rel=\"nofollow noreferrer\">are a GCC extension</a>), but it means that you can have <code>alignof(T) &gt; sizeof(T)</code> in practice.</p>\n<p>The array argument assumes <code>sizeof(Foo) &gt; 0</code>, which is true for any type supported by the standard, but <a href=\"https://stackoverflow.com/a/46460970\">o11c shows</a> an example where compiler extensions break that guarantee: some compilers allow 0-length arrays, with 0 <code>sizeof</code> and positive <code>alignof</code>.</p>\n", "LastEditorUserId": "2357112", "LastActivityDate": "2017-10-12T02:55:18.460", "Score": "30", "CreationDate": "2017-09-27T21:39:14.610", "ParentId": "46457449", "CommentCount": "6", "OwnerUserId": "2357112", "LastEditDate": "2017-10-12T02:55:18.460"}});