post_cb({"8401385": {"ParentId": "8400791", "CommentCount": "0", "CreationDate": "2011-12-06T14:21:12.513", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "8401385", "Score": "1", "Body": "<p>The quoted text is simply wrong, and always has been.  Static variables\ncan be initialized with any expression you want (provided that the\nexpression itself is legal, and doesn't use other variables which\nhaven't been initialized yet).  Things like:</p>\n<pre><code>int i = f();\n</code></pre>\n<p>are quite frequent, even at namespace scope, and of course, static\nvariables with class type and a user defined constructor are even more\nfrequent. </p>\n", "LastActivityDate": "2011-12-06T14:21:12.513"}, "8401075": {"ParentId": "8400791", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-12-06T13:59:04.433", "Score": "3", "LastEditorUserId": "964135", "LastEditDate": "2011-12-06T14:05:44.477", "Id": "8401075", "OwnerUserId": "964135", "Body": "<p>Static initialization (technically constant initialization) requires constant expressions, but static storage duration variables do not.</p>\n<pre><code>int x;                        // 0 initialized\nint y = 49;                   // statically initialized\nint z = 2 * sizeof(int) + 1;  // statically initialized\nint m = 2 * z;                // dynamically or statically initialized\n</code></pre>\n<blockquote>\n<p id=\"so_8400791_8401075_0\">3.6.2 Together, zero-initialization and constant initialization are called static initialization; all other initialization is\n  dynamic initialization. Static initialization shall be performed before any dynamic initialization takes place.</p>\n</blockquote>\n<p>Dynamic initialization can rely on functions and other things that can't be decided at compile time. The compiler is allowed to perform static initialization if it can determine the result.</p>\n<p>The example you posted will work, although it can lead to trouble with more complicated initialization, as some variables can be initialized dynamically or statically:</p>\n<pre><code>inline double fd() { return 1.0; }\nextern double d1;\ndouble d2 = d1; // unspeci\ufb01ed:\n// may be statically initialized to 0.0 or\n// dynamically initialized to 1.0\ndouble d1 = fd(); // may be initialized statically to 1.0\n</code></pre>\n", "LastActivityDate": "2011-12-06T14:05:44.477"}, "8400849": {"ParentId": "8400791", "CommentCount": "1", "CreationDate": "2011-12-06T13:41:59.223", "OwnerUserId": "174614", "PostTypeId": "2", "Id": "8400849", "Score": "0", "Body": "<p>The only reason I can think of for this would be the that <code>static</code> variables are stored in the <code>.rdata</code> segment of your executable, and since it is a <strong>readonly</strong> section of the executable, putting something there which changes, wouldn't make any sense.</p>\n<p>I might be wrong with this, however.</p>\n", "LastActivityDate": "2011-12-06T13:41:59.223"}, "8401267": {"ParentId": "8400791", "CommentCount": "0", "CreationDate": "2011-12-06T14:13:11.283", "OwnerUserId": "953054", "PostTypeId": "2", "Id": "8401267", "Score": "0", "Body": "<p>I think you example is valid. From 14882:2011, </p>\n<blockquote>\n<p id=\"so_8400791_8401267_0\">Constant expressions can be evaluated during translation.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_8400791_8401267_1\">Variables\n  with ordered initialization defined within a single translation unit shall be initialized in the order of their\n  definitions in the translation unit.</p>\n</blockquote>\n<p>In you example, z and m are in a same translation unit. So I think m is initialized by a constant expression.</p>\n", "LastActivityDate": "2011-12-06T14:13:11.283"}, "8400791": {"CommentCount": "2", "ViewCount": "1343", "PostTypeId": "1", "LastEditorUserId": "878339", "CreationDate": "2011-12-06T13:38:00.007", "LastActivityDate": "2011-12-07T07:18:46.157", "Title": "Why initialization of a static variable is restricted to constant expressions?", "AcceptedAnswerId": "8401075", "LastEditDate": "2011-12-07T07:18:46.157", "Id": "8400791", "Score": "2", "Body": "<p>From \"C++ Primer, 5th Edition\", page 407:</p>\n<blockquote>\n<p id=\"so_8400791_8400791_0\">All static duration variables share the following two initialization\n  features:</p>\n<ul>\n<li><p id=\"so_8400791_8400791_1\">An uninitialized static variable has all its bits set to 0.</p></li>\n<li><p id=\"so_8400791_8400791_2\">A static variable can be initialized only with a constant expression.</p></li>\n</ul>\n<p id=\"so_8400791_8400791_3\">A constant expression can use literal constants, const and enum\n  constants, and the sizeof operator. The following code fragment\n  illustrates these points:</p>\n<pre><code>int x;                        // x set to 0\nint y = 49;                   // 49 is a constant expression\nint z = 2 * sizeof(int) + 1;  // also a constant expression\nint m = 2 * z;                // invalid, z not a constant\nint main() {...}\n</code></pre>\n</blockquote>\n<p>My question is - WHY is this the standard? What is the (practical) reason for this.</p>\n<p>What harm would have befallen us otherwise? </p>\n<p>Especially, I find it hard to come up with a reason for the invalidity of: </p>\n<p><code>int m = 2 * z;                // invalid, z not a constant</code></p>\n<p>since <code>z</code> itself is already known at compilation time.</p>\n<p><strong>Answer:</strong></p>\n<p>Simply put, according to the standard it is not guaranteed that instructions before the first statement of <code>main</code> will be done in order.\nIt is guaranteed though that all static storage will be zero-initialized before any other initialization.\nThis means that in the example I gave: <code>int m = 2 * z;</code> is an undefined behavior and m might either evaluate to <code>2*0=0</code> or it might be evaluated to `2*(2 * sizeof(int) + 1).</p>\n<p>Out of the \"C++ Standard - ANSI ISO IEC 14882 2003\" 3.6.2 (p.44):</p>\n<blockquote>\n<p id=\"so_8400791_8400791_4\">Objects with static storage duration (3.7.1) shall be zero-initialized\n  (8.5) before any other initialization takes place.</p>\n<p id=\"so_8400791_8400791_5\">...</p>\n<p id=\"so_8400791_8400791_6\">An implementation is permitted to perform the initialization of an\n  object of namespace scope with static storage duration as a static\n  initialization even if such initialization is not required to be done\n  statically...</p>\n<p id=\"so_8400791_8400791_7\">...</p>\n</blockquote>\n<p>And the important bit:</p>\n<blockquote>\n<p id=\"so_8400791_8400791_8\">As a consequence, if the initialization of an object obj1 refers to an\n  object obj2 of namespace scope with static storage duration\n  potentially requiring dynamic initialization and defined later in the\n  same translation unit, it is unspecified whether the value of obj2\n  used will be the value of the fully initialized obj2 (because obj2 was\n  statically initialized) or will be the value of obj2 merely\n  zero-initialized.`</p>\n</blockquote>\n<p>Further reading about problems of this sort:</p>\n<p><a href=\"http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.14\" rel=\"nofollow\">http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.14</a></p>\n<p>Edit: Put in answer. Pubby's was the correct answer (and got accepted) but I really missed the \"As a consequence..\" part. Also, I think the link I added might be useful.</p>\n", "Tags": "<c++><static>", "OwnerUserId": "878339", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_8400791_8401075_0": {"section_id": 7151, "quality": 0.8571428571428571, "length": 18}, "so_8400791_8400791_6": {"section_id": 7152, "quality": 0.8333333333333334, "length": 15}, "so_8400791_8400791_2": {"section_id": 206, "quality": 0.6666666666666666, "length": 4}, "so_8400791_8400791_4": {"section_id": 3289, "quality": 0.8181818181818182, "length": 9}, "so_8400791_8401267_1": {"section_id": 7151, "quality": 1.0, "length": 14}, "so_8400791_8401267_0": {"section_id": 6184, "quality": 1.0, "length": 6}, "so_8400791_8400791_1": {"section_id": 252, "quality": 0.5714285714285714, "length": 4}, "so_8400791_8400791_8": {"section_id": 7152, "quality": 0.925, "length": 37}}, "n3337": {"so_8400791_8401075_0": {"section_id": 6895, "quality": 0.8571428571428571, "length": 18}, "so_8400791_8400791_6": {"section_id": 6896, "quality": 0.8333333333333334, "length": 15}, "so_8400791_8400791_2": {"section_id": 5680, "quality": 0.6666666666666666, "length": 4}, "so_8400791_8400791_4": {"section_id": 3159, "quality": 0.8181818181818182, "length": 9}, "so_8400791_8401267_1": {"section_id": 6895, "quality": 1.0, "length": 14}, "so_8400791_8401267_0": {"section_id": 5945, "quality": 1.0, "length": 6}, "so_8400791_8400791_1": {"section_id": 3082, "quality": 0.5714285714285714, "length": 4}, "so_8400791_8400791_8": {"section_id": 6896, "quality": 0.925, "length": 37}}, "n4659": {"so_8400791_8401075_0": {"section_id": 8652, "quality": 0.6666666666666666, "length": 14}, "so_8400791_8400791_6": {"section_id": 8653, "quality": 0.8333333333333334, "length": 15}, "so_8400791_8400791_2": {"section_id": 214, "quality": 0.6666666666666666, "length": 4}, "so_8400791_8400791_4": {"section_id": 4051, "quality": 0.8181818181818182, "length": 9}, "so_8400791_8401267_1": {"section_id": 8655, "quality": 0.5714285714285714, "length": 8}, "so_8400791_8401267_0": {"section_id": 7686, "quality": 1.0, "length": 6}, "so_8400791_8400791_1": {"section_id": 259, "quality": 0.5714285714285714, "length": 4}, "so_8400791_8400791_8": {"section_id": 8653, "quality": 0.925, "length": 37}}}, "8400872": {"ParentId": "8400791", "CommentCount": "2", "CreationDate": "2011-12-06T13:44:15.367", "OwnerUserId": "280222", "PostTypeId": "2", "Id": "8400872", "Score": "4", "Body": "<p><code>z</code> is initialized to <code>2 * sizeof(int) + 1</code> but it can be changed later to another value. By making it an explicit requirement to have a const expression as initializer, it is clear what value you will get. If you would allow non-constant expressions you could end up with different values depending on initialization order. With the const requirement it is clear what you get.</p>\n", "LastActivityDate": "2011-12-06T13:44:15.367"}});