post_cb({"27432621": {"CommentCount": "2", "ViewCount": "168", "PostTypeId": "1", "LastEditorUserId": "619570", "CreationDate": "2014-12-11T21:23:29.437", "LastActivityDate": "2015-02-28T16:03:03.463", "Title": "compiler reordering and load operation", "LastEditDate": "2014-12-11T21:28:58.917", "Id": "27432621", "Score": "2", "Body": "<p>I'm starting lock free programming and I encounter some difficulties for basic stuff. I have found the following example :</p>\n<pre><code>#define COMPILER_BARRIER() asm volatile(\"\" ::: \"memory\")\n\nint Value;\nint IsPublished = 0;\n\nvoid sendValue(int x)\n{\n    Value = x;\n    COMPILER_BARRIER();          // prevent reordering of stores\n    IsPublished = 1;\n}\n\nint tryRecvValue()\n{\n    if (IsPublished)\n    {\n        COMPILER_BARRIER();      // prevent reordering of loads\n        return Value;\n    }\n    return -1;  // or some other value to mean not yet received\n}\n</code></pre>\n<p>What kind of reordering a compiler can perform in <code>tryRecvValue</code>  function ?</p>\n", "Tags": "<c++><atomic>", "OwnerUserId": "619570", "AnswerCount": "1"}, "28783749": {"ParentId": "27432621", "CommentCount": "0", "Body": "<h1>Answer</h1>\n<p>Without the inline asm*, the compiler is able to load the value from <code>Value</code> first, then <code>IsPublished</code>, then perform the check and return.</p>\n<p><em>Always check the assembly output if you're not sure what the compiler is doing. This is especially true of lock free programming techniques.</em></p>\n<h1>More Information</h1>\n<p>* NOTE: Inline asm is not a required part of the C++ standard, but is implemented by all major compilers. It is only mentioned in section 7.4:</p>\n<blockquote>\n<p id=\"so_27432621_28783749_0\">The asm declaration is conditionally-supported; its meaning is implementation-defined. [ Note: Typically it\n  is used to pass information through the implementation to an assembler. \u2014 end note ]</p>\n</blockquote>\n<p>Generally speaking, compilers cannot reorder reads and writes around inline assembly because the compiler cannot make assumptions about what the assembly does. </p>\n<p>The use of <code>COMPILER_BARRIER()</code> above will not act as any kind of read/write barrier, it just has the side affect of not allowing reordering of assembly instructions around the statement. </p>\n<p>Assuming the above code is called from different threads, it will only work as-is on x86, since the architecture guarantees that writes are never (observably) reordered by the cpu. (reference: 8.2.3.2 in volume 3A of the <a href=\"http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html\" rel=\"nofollow\">Intel Manuals</a>)</p>\n<p>For use on other architectures with relaxed memory models, (like PowerPc and ARM) you'll need hardware barriers that prevent these types of reorders. For a good breakdown, check out <a href=\"http://preshing.com/20130922/acquire-and-release-fences/\" rel=\"nofollow\">Jeff Preshing's articles</a>.</p>\n", "OwnerUserId": "947030", "PostTypeId": "2", "Id": "28783749", "Score": "1", "CreationDate": "2015-02-28T16:03:03.463", "LastActivityDate": "2015-02-28T16:03:03.463"}, "bq_ids": {"n4140": {"so_27432621_28783749_0": {"section_id": 5516, "quality": 0.6875, "length": 11}}, "n3337": {"so_27432621_28783749_0": {"section_id": 5302, "quality": 0.6875, "length": 11}}, "n4659": {"so_27432621_28783749_0": {"section_id": 6951, "quality": 0.6875, "length": 11}}}});