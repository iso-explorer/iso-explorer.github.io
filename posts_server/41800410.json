post_cb({"41800410": {"CommentCount": "3", "ViewCount": "452", "PostTypeId": "1", "LastEditorUserId": "6764663", "CreationDate": "2017-01-23T06:28:58.150", "LastActivityDate": "2017-01-23T10:35:52.557", "Title": "segmentation fault for deleting a pointer", "AcceptedAnswerId": "41800482", "LastEditDate": "2017-01-23T10:35:52.557", "Id": "41800410", "Score": "3", "Body": "<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass c1 {};\nclass c2 : public c1 {};\nclass c3 : public c1 {};\nclass c4 : public c2, public c3 {};\n\nint main () {\n  c4 *x1 = new c4;\n  c3 *x2 = x1;\n  delete x2; // segmentation fault\n}\n</code></pre>\n<p>Hi, i am trying to understand typecasting and inheritance, i found this issue. I have a pointer to the most derived class, and typecasted (implicit) to middle any class, while deleting, i thought it should be able to delete the allocated space by the first new. In some compilers, it seem fine, but in linux gcc version 4.7.2 (Debian 4.7.2-5), it is giving segmentation fault. Not able to figure out, why? Any help/pointer/suggestion will be appreciated.</p>\n<p>Note - Class is derived in the form of diamond problem.</p>\n", "Tags": "<c++><pointers><segmentation-fault><language-lawyer><delete-operator>", "OwnerUserId": "1080000", "AnswerCount": "3"}, "41800569": {"ParentId": "41800410", "CommentCount": "0", "Body": "<p>To add to the previous answer, the <code>undefined</code> behaviour comes from the fact that casting the pointer to a base class means (most of the time, but not in your example) <em>slicing</em>: the pointer is adjusted (i.e. incremented) to point to the beginning of the embedded class.</p>\n<p>So upon calling <code>delete</code> on the incremented pointer, you risk freeing part of memory and let some of it <em>dangling</em>.</p>\n", "OwnerUserId": "2667536", "PostTypeId": "2", "Id": "41800569", "Score": "1", "CreationDate": "2017-01-23T06:41:51.320", "LastActivityDate": "2017-01-23T06:41:51.320"}, "41800528": {"ParentId": "41800410", "CommentCount": "0", "Body": "<p>Attempting to delete a pointer that was not returned by <code>new</code>. For solution use <code>virtual destructor</code> for the base classes. When you delete an object through a pointer to a base class, the base class needs a <code>virtual</code> destructor.</p>\n", "OwnerUserId": "6935629", "PostTypeId": "2", "Id": "41800528", "Score": "2", "CreationDate": "2017-01-23T06:37:57.443", "LastActivityDate": "2017-01-23T06:37:57.443"}, "bq_ids": {"n4140": {"so_41800410_41800482_0": {"section_id": 6107, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_41800410_41800482_0": {"section_id": 5873, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_41800410_41800482_0": {"section_id": 7604, "quality": 0.9629629629629629, "length": 26}}}, "41800482": {"ParentId": "41800410", "LastEditDate": "2017-01-23T06:40:51.717", "CommentCount": "0", "CreationDate": "2017-01-23T06:34:16.853", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "PostTypeId": "2", "Id": "41800482", "Score": "3", "Body": "<p>This is undefined behavior. Just as you've seen, for some situations it might seem work well, for some situations it won't.</p>\n<p>At least the base class <code>c3</code> (or <code>c1</code> and <code>c2</code>) should have a <strong>virtual</strong> destructor. e.g.</p>\n<pre><code>class c3 : public c1 {\npublic:\n    virtual ~c3() {}\n};\n</code></pre>\n<p>According to the standard, <a href=\"http://eel.is/c++draft/expr.delete#3\" rel=\"nofollow noreferrer\">$5.3.5/3 Delete [expr.delete]</a>:</p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_41800410_41800482_0\">In the first alternative (<em>delete object</em>), if the static type of the\n  object to be deleted is different from its dynamic type, the static\n  type shall be a base class of the dynamic type of the object to be\n  deleted and <strong>the static type shall have a virtual destructor or the\n  behavior is undefined</strong>.</p>\n</blockquote>\n", "LastActivityDate": "2017-01-23T06:40:51.717"}});