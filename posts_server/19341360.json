post_cb({"bq_ids": {"n4140": {"so_19341360_19341402_1": {"length": 58, "quality": 0.5523809523809524, "section_id": 233}, "so_19341360_19341623_0": {"length": 42, "quality": 0.9767441860465116, "section_id": 234}, "so_19341360_19341623_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 241}, "so_19341360_19341402_0": {"length": 24, "quality": 0.8, "section_id": 5907}}, "n3337": {"so_19341360_19341402_1": {"length": 58, "quality": 0.5523809523809524, "section_id": 226}, "so_19341360_19341623_0": {"length": 42, "quality": 0.9767441860465116, "section_id": 227}, "so_19341360_19341402_0": {"length": 24, "quality": 0.8, "section_id": 5679}, "so_19341360_19341623_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 233}}, "n4659": {"so_19341360_19341623_0": {"length": 41, "quality": 0.9534883720930233, "section_id": 244}, "so_19341360_19341402_0": {"length": 24, "quality": 0.8, "section_id": 7389}, "so_19341360_19341623_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 55}}}, "19341360": {"ViewCount": "775", "Body": "<p>Is static member variable initialized in a template class if the static member is not used? I use it to register the type.</p>\n<pre><code>template&lt;class T&gt;\nclass A\n{\n    static bool d;\n};\n\ntemplate&lt;class T&gt; bool A&lt;T&gt;::d = [](){regist&lt;A&lt;T&gt;&gt;(); return true;}();\n\nint main()\n{\n   A&lt;int&gt; a;\n   return 0;\n}\n</code></pre>\n<p>I find a way to test it. It prints 1 other than 2. The regist() is not called abd the static member is not initialized. My testing is on VC110 compilter. And I also test it <a href=\"http://ideone.com/r9fVCW\" rel=\"nofollow\">online</a></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint i = 1;\n\ntemplate&lt;class T&gt;\nvoid regist()\n{\n    ++i;\n}\n\ntemplate&lt;class T&gt;\nclass A\n{\n    static bool d;\n};\n\ntemplate&lt;class T&gt; bool A&lt;T&gt;::d = [](){regist&lt;A&lt;T&gt;&gt;(); return true;}();\n\nint main()\n{\n    A&lt;int&gt; a;\n    cout &lt;&lt; i &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n", "Title": "Is static member variable initialized in a template class if the static menber is not used?", "CreationDate": "2013-10-13T02:53:39.167", "LastActivityDate": "2013-10-14T01:53:37.220", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-10-14T01:53:37.220", "LastEditorUserId": "1708801", "Id": "19341360", "Score": "3", "OwnerUserId": "1899020", "Tags": "<c++><templates><static-members><class-template>", "AnswerCount": "2"}, "19341623": {"Id": "19341623", "PostTypeId": "2", "Body": "<p>The relevant section of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">C++ draft standard</a> comes under <code>14</code> <em>Templates</em> which is <code>14.7.1</code> <em>Implicit instantiation</em> paragraph <em>2</em> which says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19341360_19341623_0\">Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist; in particular, <strong>the initialization (and any associated side-effects) of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist.</strong></p>\n</blockquote>\n<p>We can also see paragraph <em>8</em> which says:</p>\n<blockquote>\n<p id=\"so_19341360_19341623_1\">The implicit instantiation of a class template does not cause any static data members of that class to be implicitly instantiated.</p>\n</blockquote>\n<p>However if you add an <em>explicit instantiation</em> to the second case as follows you will see <code>2</code> as the results:</p>\n<pre><code>template&lt;&gt; bool A&lt;int&gt;::d = [](){regist&lt;A&lt;int&gt;&gt;(); return true;}();\n</code></pre>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-10-13T03:58:16.587", "Score": "2", "CreationDate": "2013-10-13T03:41:22.253", "ParentId": "19341360", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2013-10-13T03:58:16.587"}, "19341402": {"Id": "19341402", "PostTypeId": "2", "Body": "<p>Yes it is initialized run this sample program, but only because it is forced to exist.  </p>\n<pre><code>template &lt;class T&gt;                                                                 \nstruct A                                                                           \n{                                                                                  \n    static int b;                                                                  \n};                                                                                 \ntemplate &lt;class T&gt; int A&lt;T&gt;::b = 10;                                               \n#include &lt;iostream&gt;                                                                \nusing namespace std;                                                               \nint main() {                                                                       \n    cout &lt;&lt; A&lt;int&gt;::b &lt;&lt; endl;                                                     \n    return 0;                                                                      \n}   \n</code></pre>\n<p>I believe this quote from the standard may clarify any doubts</p>\n<blockquote>\n<p id=\"so_19341360_19341402_0\">[Note: Once the static data member has been defined, it exists even if no objects of its class have been created. [ Example: in the example above, run_chain and running exist even if no objects of class process are created by the program. \u2014 end example ] \u2014 end note ]   </p>\n</blockquote>\n<p>Here is a  relavent part of the standard that confirms your suspicisions. </p>\n<blockquote>\n<p id=\"so_19341360_19341402_1\">Unless a class template specialization has been explicitly instantiated (14.7.2) or explicitly specialized (14.7.3), the class template specialization is implicitly instantiated when the specialization is referenced in a context that requires a completely-defined object type or when the completeness of the class type affects the se- mantics of the program. The implicit instantiation of a class template specialization causes the implicit instantiation of the declarations, but not of the definitions or default arguments, of the class member func- tions, member classes, <strong>static data members</strong> and member templates; and it causes the implicit instantiation of the definitions of member anonymous unions. Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly in- stantiated when the specialization is referenced in a context that requires the member definition to exist; in particular, <strong>the initialization (and any associated side-effects)</strong> of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist.   </p>\n</blockquote>\n<p>The two parts I highlighted in bold I think clear up your issue. Clearly the reason for this behavior is that if no explicit specialization is given the compiler has no way to decide how many times the code should be executed (infinite possible types)</p>\n", "LastEditorUserId": "2167655", "LastActivityDate": "2013-10-13T04:05:42.380", "Score": "2", "CreationDate": "2013-10-13T02:59:26.597", "ParentId": "19341360", "CommentCount": "12", "OwnerUserId": "2167655", "LastEditDate": "2013-10-13T04:05:42.380"}});