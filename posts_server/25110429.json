post_cb({"25110429": {"ViewCount": "873", "Body": "<p>When I try to compile this test program:</p>\n<pre><code>struct comma_guard\n{\n    template&lt;class T&gt;\n    const comma_guard&amp; operator,(T&amp;&amp;) const\n    {\n        return *this;\n    }\n};\n\nstruct foo {};\ntemplate&lt;class T&gt; T operator,(T x, foo)\n{\n    return x;\n}\n\nint main()\n{\n    (comma_guard(), foo());\n}\n</code></pre>\n<p>I get a compile error on clang:</p>\n<pre><code>comma_guard.cpp:20:19: error: use of overloaded operator ',' is ambiguous (with operand types 'comma_guard' and 'foo')\n    (comma_guard(), foo());\n     ~~~~~~~~~~~~~^ ~~~~~\ncomma_guard.cpp:6:24: note: candidate function [with T = foo]\n    const comma_guard&amp; operator,(T&amp;&amp;) const\n                       ^\ncomma_guard.cpp:13:21: note: candidate function [with T = comma_guard]\ntemplate&lt;class T&gt; T operator,(T x, foo)\n                    ^\n</code></pre>\n<p>This compiles fine on gcc. From my understanding of ADL lookup, the member function in <code>comma_guard</code> should be preferred and so therefore shouldn't be ambiguous. Is this correct? Is this a bug in clang? Also, is there a workaround so that the operator in <code>comma_guard</code> will always be preferred?</p>\n<p><strong>Update</strong>: So it seems clang doesn't consider it a class member when its templated. So if I define the <code>comma_guard</code> like this, it will work:</p>\n<pre><code>struct comma_guard\n{\n    struct any\n    {\n        template&lt;class T&gt;\n        any(T&amp;&amp;);\n    };\n    const comma_guard&amp; operator,(any) const;\n};\n</code></pre>\n<p>Which is correct according to C++?</p>\n", "AcceptedAnswerId": "25110733", "Title": "Ambiguous operator overload on clang", "CreationDate": "2014-08-04T00:47:20.260", "Id": "25110429", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-08-04T01:24:25.497", "LastEditorUserId": "375343", "LastActivityDate": "2014-08-04T01:47:52.643", "Score": "12", "OwnerUserId": "375343", "Tags": "<c++><c++11><clang><language-lawyer>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25110429_25110733_3": {"length": 33, "quality": 0.8918918918918919, "section_id": 571}, "so_25110429_25110733_2": {"length": 23, "quality": 0.8846153846153846, "section_id": 571}, "so_25110429_25110733_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 566}}, "n3337": {"so_25110429_25110733_3": {"length": 27, "quality": 0.7297297297297297, "section_id": 562}, "so_25110429_25110733_2": {"length": 23, "quality": 0.8846153846153846, "section_id": 562}, "so_25110429_25110733_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 557}}, "n4659": {"so_25110429_25110733_3": {"length": 33, "quality": 0.8918918918918919, "section_id": 594}, "so_25110429_25110733_2": {"length": 23, "quality": 0.8846153846153846, "section_id": 594}, "so_25110429_25110733_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 589}}}, "25110733": {"Id": "25110733", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_25110429_25110733_0\">From my understanding of ADL lookup, the member function in comma_guard should be preferred and so therefore shouldn't be ambiguous. Is this correct?</p>\n</blockquote>\n<hr>\n<p><strong>Answer:</strong> During overload resolution and according to the standard <em>\u00a7 13.3.1/2 &amp; 7 Candidate functions and argument lists [over.match.funcs]:</em></p>\n<blockquote>\n<p id=\"so_25110429_25110733_1\"><em><code>2</code> The set of candidate functions can contain both member and non-member functions to be resolved against the same argument list.</em></p>\n<p id=\"so_25110429_25110733_2\"><em><code>7</code> In each case where a candidate is a function template, candidate function template specializations are generated using template argument deduction (14.8.3, 14.8.2). Those candidates are then handled as candidate functions in the usual way [126].</em></p>\n<p id=\"so_25110429_25110733_3\"><em>[footnote <code>126</code>] The process of argument deduction fully determines the parameter types of the function template specializations, i.e., the parameters of function template specializations contain no template parameter types. Therefore, except where specified\n  otherwise, function template specializations and non-template functions (8.3.5) are treated equivalently for the remainder of overload resolution.</em></p>\n</blockquote>\n<p>Consequently, the template member overloaded operator hasn't have greater priority in terms of overload resolution picking than the template free overloaded operator.</p>\n<p>Even if it had GCC picks the free template overloaded operator <a href=\"http://coliru.stacked-crooked.com/a/46614d2ff1ecc1a8\" rel=\"noreferrer\"><kbd>LIVE DEMO</kbd></a>.</p>\n<p>So in my humble opinion, here is GCC that shows a non standard compliant behaviour and Clang rightfully complains about overload resolution ambiguity. </p>\n<hr>\n<blockquote>\n<p id=\"so_25110429_25110733_4\">Also, is there a workaround so that the operator in comma_guard will always be preferred?</p>\n</blockquote>\n<hr>\n<p><strong>Answer:</strong> Yes although kinda ugly: <code>(comma_guard().operator,(foo()));</code> <a href=\"http://coliru.stacked-crooked.com/a/e9e82be9a037ef4c\" rel=\"noreferrer\"><kbd>LIVE DEMO</kbd></a></p>\n</hr></hr></hr>", "LastEditorUserId": "2352671", "LastActivityDate": "2014-08-04T01:47:52.643", "Score": "13", "CreationDate": "2014-08-04T01:41:05.363", "ParentId": "25110429", "CommentCount": "0", "LastEditDate": "2014-08-04T01:47:52.643", "OwnerUserId": "2352671"}});