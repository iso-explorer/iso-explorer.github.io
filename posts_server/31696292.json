post_cb({"bq_ids": {"n4140": {"so_31696292_31696559_0": {"length": 17, "quality": 1.0, "section_id": 7055}}, "n3337": {"so_31696292_31696559_0": {"length": 17, "quality": 1.0, "section_id": 6799}}, "n4659": {"so_31696292_31696559_0": {"length": 17, "quality": 1.0, "section_id": 8552}}}, "31696292": {"ViewCount": "182", "Body": "<p>I noticed that <strong>prepending the <code>class</code> or <code>struct</code> keyword to a type that would otherwise need be forward declared</strong> works as if that type was forward declared: </p>\n<pre><code>// struct Test; forward declaration commented\n\nvoid* foo(struct Test* t) // C style function parameter - This works !\n{\n    return t; \n}\n</code></pre>\n<p>I wasn't aware of that. I wonder if it's standard C++ or an extension and whether the <code>struct</code> keyword before the parameter works as a forward declaration or another mechanism kicks in. </p>\n<p>Furthermore, after such a usage the \"next\" function can use the type without prepending any keywords : </p>\n<pre><code>void* oof(Test* t);\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/b413aa43472ff59d\"><kbd>Demo</kbd></a></p>\n", "AcceptedAnswerId": "31696559", "Title": "Alternative to forward declaration", "CreationDate": "2015-07-29T09:21:45.183", "Id": "31696292", "CommentCount": "3", "LastEditDate": "2015-07-29T09:23:39.793", "PostTypeId": "1", "LastEditorUserId": "2567683", "LastActivityDate": "2015-07-29T09:50:33.033", "Score": "10", "OwnerUserId": "2567683", "Tags": "<c++>", "AnswerCount": "1"}, "31696559": {"Id": "31696559", "PostTypeId": "2", "Body": "<p>This is legal, but probably not a good idea.</p>\n<p>From <strong>[basic.scope.pdecl]</strong>/6:</p>\n<blockquote>\n<p id=\"so_31696292_31696559_0\">[...] \u2014 for an <em>elaborated-type-specifier</em> of the form<br/>\n<em>class-key</em> <em>identifier</em><br/>\n  if the <em>elaborated-type-specifier</em> is used in the <em>decl-specifier-seq</em> or <em>parameter-declaration-clause</em> of a\n  function defined in namespace scope, <strong>the <em>identifier</em> is declared as a <em>class-name</em> in the namespace that\n  contains the declaration</strong> [...]</p>\n</blockquote>\n<p>For example:</p>\n<pre><code>namespace mine {\n    struct T* foo(struct S *);\n//  ^^^^^^^^^---------------- decl-specifier-seq\n//                ^^^^^^^^^^--- parameter-declaration-clause\n}\n</code></pre>\n<p>This introduces <code>T</code> and <code>S</code> as class-names and <code>foo</code> as a function name into <code>namespace mine</code>.</p>\n<hr>\n<p>Note that the behavior is different in C; the struct name is only valid within the scope of the function.</p>\n<blockquote>\n<h3>6.2.1 Scopes of identifiers</h3>\n<p id=\"so_31696292_31696559_1\">4 - [...] If the declarator or type specifier that\n  declares the identifier appears [...] within the list of parameter declarations in\n  a function definition, the identifier has <em>block scope</em>, which terminates at the end of the\n  associated block. If the declarator or type specifier that declares the identifier appears\n  within the list of parameter declarations in a function prototype (not part of a function\n  definition), the identifier has <em>function prototype scope</em>, which terminates at the end of the\n  function declarator.</p>\n</blockquote>\n<p>gcc gives an appropriate warning for this usage in C code:</p>\n<pre><code>a.c:3:18: warning: \u2018struct Test\u2019 declared inside parameter list\n void* foo(struct Test* t)\n                  ^\na.c:3:18: warning: its scope is only this definition or declaration, which is probably not what you want\n</code></pre>\n</hr>", "LastEditorUserId": "567292", "LastActivityDate": "2015-07-29T09:50:33.033", "Score": "6", "CreationDate": "2015-07-29T09:33:54.140", "ParentId": "31696292", "CommentCount": "0", "OwnerUserId": "567292", "LastEditDate": "2015-07-29T09:50:33.033"}});