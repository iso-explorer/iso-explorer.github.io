post_cb({"9733432": {"CommentCount": "1", "ViewCount": "1840", "LastActivityDate": "2012-03-16T07:59:28.973", "Body": "<p>I have some question about behavior of <code>std::async</code> function with <code>std::launch::async</code> policy &amp; <code>std::future</code> object returned from async.</p>\n<p>In following code, main thread waits for the completion of <code>foo()</code> on the thread created by <code>async</code> call.</p>\n<pre><code>#include &lt;thread&gt;\n#include &lt;future&gt;\n#include &lt;iostream&gt;\n\nvoid foo()\n{\n  std::cout &lt;&lt; \"foo:begin\" &lt;&lt; std::endl;\n  std::this_thread::sleep_for(std::chrono::seconds(10));\n  std::cout &lt;&lt; \"foo:done\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n  std::cout &lt;&lt; \"main:begin\" &lt;&lt; std::endl;\n  {\n    auto f = std::async(std::launch::async, foo);\n    // dtor f::~f blocks until completion of foo()... why??\n  }\n  std::this_thread::sleep_for(std::chrono::seconds(2));\n  std::cout &lt;&lt; \"main:done\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>And I know <a href=\"http://www.stdthread.co.uk/doc/headers/future/async.html\" rel=\"noreferrer\">http://www.stdthread.co.uk/doc/headers/future/async.html</a> says </p>\n<blockquote>\n<p id=\"so_9733432_9733432_0\">The destructor of the last future object associated with the\n  asynchronous state of the returned std::future shall block until the\n  future is ready.</p>\n</blockquote>\n<p>My question is:</p>\n<ul>\n<li>Q1. Does this behavior conform to the current C++ standard?</li>\n<li>Q2. If Q1's answer is yes, which statements say that?</li>\n</ul>\n", "PostTypeId": "1", "AcceptedAnswerId": "9733751", "FavoriteCount": "3", "Title": "the behavior of std::async with std::launch::async policy", "Id": "9733432", "Score": "17", "CreationDate": "2012-03-16T07:24:20.073", "Tags": "<c++><multithreading><c++11>", "OwnerUserId": "684921", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_9733432_9733751_0": {"section_id": 3163, "quality": 0.9565217391304348, "length": 22}}, "n3337": {"so_9733432_9733751_0": {"section_id": 3036, "quality": 0.9565217391304348, "length": 22}}, "n4659": {"so_9733432_9733751_0": {"section_id": 3925, "quality": 0.9565217391304348, "length": 22}}}, "9733751": {"ParentId": "9733432", "CommentCount": "4", "Body": "<p>Yes, this is required by the C++ Standard. 30.6.8 [futures.async] paragraph 5, final bullet:</p>\n<blockquote>\n<p id=\"so_9733432_9733751_0\">\u2014 the associated thread completion synchronizes with (1.10) the return from the first function that successfully detects the ready status of the shared state or with the return from the last function that releases the shared state, whichever happens first.</p>\n</blockquote>\n<p>The destructor of the one and only <code>std:future</code> satisfies that condition, and so has to wait for the completion of the thread.</p>\n", "OwnerUserId": "5597", "PostTypeId": "2", "Id": "9733751", "Score": "16", "CreationDate": "2012-03-16T07:59:28.973", "LastActivityDate": "2012-03-16T07:59:28.973"}});