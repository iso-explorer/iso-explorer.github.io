post_cb({"13170246": {"ParentId": "13170189", "CommentCount": "0", "Body": "<p>You're entering the realm of undefined behaviour since you're accessing an object through a pointer / reference to a type that is not the actual type of the object.</p>\n<p><code>3.10 [basic.lval] p10</code></p>\n<blockquote>\n<p id=\"so_13170189_13170246_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>the dynamic type of the object</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>The dynamic type of <code>pB</code> is <code>Base*</code>, obviously, but the dynamic type of <code>pD</code> is <em>still</em> <code>Base*</code>.</p>\n", "OwnerUserId": "500104", "PostTypeId": "2", "Id": "13170246", "Score": "5", "CreationDate": "2012-11-01T02:48:30.790", "LastActivityDate": "2012-11-01T02:48:30.790"}, "13170236": {"ParentId": "13170189", "CommentCount": "7", "Body": "<pre><code>D *pD = static_cast&lt;D*&gt;(pB);\n</code></pre>\n<p>With this statement, you gave up the right to having sane program behavior. C++ does not <em>require</em> this operation to work if what <code>static_cast</code> is given is not actually of type <code>D</code> or one of <code>D</code>'s derived classes (which it isn't).</p>\n<p>So it's not optimizations that are thwarting you, just bad code.</p>\n<p>There's a reason why <code>dynamic_cast</code> exists; a proper <code>dynamic_cast</code> would have quickly failed on this, returning <code>nullptr</code> for an illegal cast.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "13170236", "Score": "11", "CreationDate": "2012-11-01T02:47:11.397", "LastActivityDate": "2012-11-01T02:47:11.397"}, "13170189": {"CommentCount": "9", "ViewCount": "207", "PostTypeId": "1", "ClosedDate": "2012-11-02T15:02:31.500", "LastEditorUserId": "-1", "CreationDate": "2012-11-01T02:38:10.383", "LastActivityDate": "2012-11-02T07:03:43.683", "Title": "Compiler added optimization causes different behavior for \"final\" methods", "LastEditDate": "2017-05-23T12:12:13.727", "Id": "13170189", "Score": "2", "Body": "<pre><code>struct B { \n  virtual void foo ()\n  { cout &lt;&lt; \"B::foo()\\n\"; }\n};\n\nstruct D : B { \n  void foo () //final\n  { cout &lt;&lt; \"D::foo()\\n\"; }\n};\n\nint main ()\n{\n  B *pB = new B;\n  D *pD = static_cast&lt;D*&gt;(pB);\n  pB-&gt;foo();\n  pD-&gt;foo();\n}\n</code></pre>\n<p>Outputs expected behavior:</p>\n<pre><code>B::foo()\nB::foo()\n</code></pre>\n<p>If we make the <code>D::foo()</code> final, then the output is pleasantly different:</p>\n<pre><code>B::foo()\nD::foo()\n</code></pre>\n<p>Which means that <code>virtual</code> functionality is not kicked-in when the method is invoked with pointer/reference of a class which has that method declared as <code>final</code>.<br>\nAlso it means that, <code>final</code> isn't just a compile-time check but also contributes to runtime behavior.</br></p>\n<p>Is it a standard behavior for all compilers. I have tested with g++4.7.</p>\n<p><strong>Edit</strong>:<br>\nSpawned a <a href=\"https://stackoverflow.com/questions/13190743/compiler-added-optimization-causes-different-behavior-for-final-methods\">new question</a> with clarification. Closing this question.</br></p>\n", "Tags": "<c++><optimization><c++11><final>", "OwnerUserId": "514235", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_13170189_13170246_0": {"section_id": 7239, "quality": 1.0, "length": 14}}, "n3337": {"so_13170189_13170246_0": {"section_id": 6983, "quality": 1.0, "length": 14}}, "n4659": {"so_13170189_13170246_0": {"section_id": 8748, "quality": 1.0, "length": 14}}}, "13170226": {"ParentId": "13170189", "CommentCount": "0", "Body": "<p>You're invoking undefined behavior here. You can't just downcast a pointer arbitrarily.</p>\n", "OwnerUserId": "224286", "PostTypeId": "2", "Id": "13170226", "Score": "3", "CreationDate": "2012-11-01T02:43:50.227", "LastActivityDate": "2012-11-01T02:43:50.227"}});