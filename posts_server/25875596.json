post_cb({"25876175": {"ParentId": "25875596", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The rule for this situation changed between 2011 and 2014. The compiler should now treat <code>localB</code> as an rvalue.</p>\n<p>The applicable rule for <code>return</code> statements is found in \u00a712.8 [class.copy]/p32, which reads in C++14 (quoting N3936, emphasis mine):</p>\n<blockquote>\n<p id=\"so_25875596_25876175_0\">When the criteria for elision of a copy/move operation are met, but\n  not for an <em>exception-declaration</em>, and the object to be copied is\n  designated by an lvalue, or <strong>when the expression in a return\n  statement is a (possibly parenthesized) <em>id-expression</em> that names an\n  object with automatic storage duration declared in the body or\n  <em>parameter-declaration-clause</em> of the innermost enclosing function or <em>lambda-expression</em></strong>, overload resolution to select the constructor for the copy is first performed as if the object were designated by an\n  rvalue. If the first overload resolution fails or was not performed,\n  or if the type of the first parameter of the selected constructor is\n  not an rvalue reference to the object\u2019s type (possibly cv-qualified),\n  overload resolution is performed again, considering the object as an\n  lvalue.</p>\n</blockquote>\n<p>The bolded clause was added by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1579\" rel=\"nofollow noreferrer\">CWG issue 1579</a>, expressly to require the converting move constructor <code>A::A(B&amp;&amp;)</code> to be called here. This is implemented in GCC 5 and Clang 3.9.</p>\n<p>Back in 2011, this \"try rvalue first\" rule was closely tied to the criteria for copy elision (quoting N3337):</p>\n<blockquote>\n<p id=\"so_25875596_25876175_1\">When the criteria for elision of a copy operation are met or would be\n  met save for the fact that the source object is a function parameter,\n  and the object to be copied is designated by an lvalue, overload\n  resolution to select the constructor for the copy is first performed\n  as if the object were designated by an rvalue.</p>\n</blockquote>\n<p>Since copy elision necessarily requires the two to have the same type, this paragraph didn't apply, and the compiler had to use the <code>A::A(B&amp;)</code> constructor.</p>\n<p>Note that as CWG 1579 is considered a DR against C++11, compilers should implement its resolution even in C++11 mode. </p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2017-04-17T19:17:32.260", "Id": "25876175", "Score": "30", "CreationDate": "2014-09-16T18:41:09.987", "LastActivityDate": "2017-04-17T19:17:32.260"}, "25875596": {"CommentCount": "5", "AcceptedAnswerId": "25876175", "PostTypeId": "1", "LastEditorUserId": "3747990", "CreationDate": "2014-09-16T18:03:13.390", "LastActivityDate": "2017-04-17T19:17:32.260", "LastEditDate": "2014-09-16T19:49:39.803", "ViewCount": "1266", "FavoriteCount": "3", "Title": "Can returning a local variable by value in C++11/14 result in the return value being constructed by rvalue when no copy/move is involved?", "Id": "25875596", "Score": "28", "Body": "<p>I know that in the following situation that the compiler is free to move-construct the return value from <code>makeA</code> (but is also free to elide the copy or move altogether):</p>\n<pre><code>struct A\n{\n    A(A&amp;);\n    A(A&amp;&amp;);\n};\n\nA makeA()\n{\n    A localA;\n    return localA;\n}\n</code></pre>\n<p>What I wonder is whether the compiler is allowed to construct an object of type <code>A</code> from a local object of type <code>B</code> by rvalue reference if it is being constructed in the return statement. In other words, in the following example, is the compiler allowed to select <code>A</code>'s constructor 4 for the return value?</p>\n<pre><code>struct B { };\nstruct A {\n    A(A&amp;);  // (1)\n    A(A&amp;&amp;); // (2)\n    A(B&amp;);  // (3)\n    A(B&amp;&amp;); // (4)\n};\n\nA makeA()\n{\n    B localB;\n    return localB;\n}\n</code></pre>\n<p>I ask this because it would seem to me that the same logic that allows a local object of type <code>A</code> to be treated as an rvalue in the return statement should also allow a local of any type to be treated as an rvalue, but I cannot find any examples or questions of this nature.</p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "2044020", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25875596_25876175_1": {"section_id": 481, "quality": 0.6896551724137931, "length": 20}, "so_25875596_25876175_0": {"section_id": 481, "quality": 0.9848484848484849, "length": 65}}, "n3337": {"so_25875596_25876175_1": {"section_id": 472, "quality": 1.0, "length": 29}, "so_25875596_25876175_0": {"section_id": 472, "quality": 0.6212121212121212, "length": 41}}, "n4659": {"so_25875596_25876175_1": {"section_id": 504, "quality": 0.5517241379310345, "length": 16}, "so_25875596_25876175_0": {"section_id": 504, "quality": 0.8181818181818182, "length": 54}}}});