post_cb({"28875810": {"CommentCount": "2", "AcceptedAnswerId": "28876101", "PostTypeId": "1", "LastEditorUserId": "1305516", "CreationDate": "2015-03-05T10:38:30.947", "LastActivityDate": "2015-03-05T14:07:31.570", "LastEditDate": "2015-03-05T14:07:31.570", "ViewCount": "492", "FavoriteCount": "2", "Title": "Throw a temporary argument passed by reference", "Id": "28875810", "Score": "16", "Body": "<pre><code>inline void my_assert( bool cond, const std::exception &amp;e = my_assert_failed() ) \n{ \n    if ( !cond ) \n      throw e;\n}\n</code></pre>\n<p>The standard ensures that:</p>\n<blockquote>\n<p id=\"so_28875810_28875810_0\">A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full expression containing the call.</p>\n</blockquote>\n<p>And for a thrown temporary object:</p>\n<blockquote>\n<p id=\"so_28875810_28875810_1\">The temporary persists as long as there is a handler being executed for that exception.</p>\n</blockquote>\n<p>Can I infer that a temporary that is passed to <code>my_assert</code> survives until the catch block finishes?</p>\n", "Tags": "<c++><exception-handling>", "OwnerUserId": "857731", "AnswerCount": "1"}, "28876101": {"ParentId": "28875810", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>From N4296 (first draft after final C++14) [15.1p3]:</p>\n<blockquote>\n<p id=\"so_28875810_28876101_0\">Throwing an exception copy-initializes (8.5, 12.8) a temporary object,\n  called the exception object. The  temporary is an lvalue and is used\n  to initialize the variable declared in the matching handler (15.3).</p>\n</blockquote>\n<p>So you can't assume that your temporary \"survives the throw\". If throwing, the copy constructor of an exception object of type <code>std::exception</code> will be called with <code>e</code> as the argument. The temporary that <code>e</code> is bound to will be destroyed when control leaves the full expression containing the call to <code>my_assert</code> (either after a normal return or as part of stack unwinding, since you're conditionally throwing the exception).</p>\n<p>There are circumstances when the copy construction of the exception object can be elided, but this is not one of them, according to [12.8p31.2]:</p>\n<blockquote>\n<p id=\"so_28875810_28876101_1\">\u2014 in a throw-expression (5.17), when the operand is the name of a\n  non-volatile automatic object (<em>other than a function or catch-clause\n  parameter</em>) whose scope does not extend beyond the end of the innermost\n  enclosing try-block (if there is one), the copy/move operation from\n  the operand to the exception object (15.1) can be omitted by\n  constructing the automatic object directly into the exception object</p>\n</blockquote>\n<p>(emphasis mine)</p>\n", "OwnerUserId": "4326278", "LastEditorUserId": "4326278", "LastEditDate": "2015-03-05T11:02:01.043", "Id": "28876101", "Score": "9", "CreationDate": "2015-03-05T10:52:30.793", "LastActivityDate": "2015-03-05T11:02:01.043"}, "bq_ids": {"n4140": {"so_28875810_28876101_0": {"section_id": 3336, "quality": 0.7222222222222222, "length": 13}, "so_28875810_28876101_1": {"section_id": 480, "quality": 0.9230769230769231, "length": 36}, "so_28875810_28875810_0": {"section_id": 382, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_28875810_28876101_1": {"section_id": 471, "quality": 0.9230769230769231, "length": 36}, "so_28875810_28875810_0": {"section_id": 373, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_28875810_28876101_0": {"section_id": 4103, "quality": 0.7222222222222222, "length": 13}, "so_28875810_28876101_1": {"section_id": 502, "quality": 0.9487179487179487, "length": 37}, "so_28875810_28875810_0": {"section_id": 397, "quality": 0.7857142857142857, "length": 11}}}});