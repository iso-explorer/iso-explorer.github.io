post_cb({"bq_ids": {"n4140": {"so_28875810_28876101_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 3336}, "so_28875810_28875810_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 382}, "so_28875810_28876101_1": {"length": 36, "quality": 0.9230769230769231, "section_id": 480}}, "n3337": {"so_28875810_28876101_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 3206}, "so_28875810_28875810_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 373}, "so_28875810_28876101_1": {"length": 36, "quality": 0.9230769230769231, "section_id": 471}}, "n4659": {"so_28875810_28876101_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 4103}, "so_28875810_28875810_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 397}, "so_28875810_28876101_1": {"length": 37, "quality": 0.9487179487179487, "section_id": 502}}}, "28875810": {"ViewCount": "492", "Body": "<pre><code>inline void my_assert( bool cond, const std::exception &amp;e = my_assert_failed() ) \n{ \n    if ( !cond ) \n      throw e;\n}\n</code></pre>\n<p>The standard ensures that:</p>\n<blockquote>\n<p id=\"so_28875810_28875810_0\">A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full expression containing the call.</p>\n</blockquote>\n<p>And for a thrown temporary object:</p>\n<blockquote>\n<p id=\"so_28875810_28875810_1\">The temporary persists as long as there is a handler being executed for that exception.</p>\n</blockquote>\n<p>Can I infer that a temporary that is passed to <code>my_assert</code> survives until the catch block finishes?</p>\n", "AcceptedAnswerId": "28876101", "Title": "Throw a temporary argument passed by reference", "CreationDate": "2015-03-05T10:38:30.947", "Id": "28875810", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-03-05T14:07:31.570", "LastEditorUserId": "1305516", "LastActivityDate": "2015-03-05T14:07:31.570", "Score": "16", "OwnerUserId": "857731", "Tags": "<c++><exception-handling>", "AnswerCount": "1"}, "28876101": {"Id": "28876101", "PostTypeId": "2", "Body": "<p>From N4296 (first draft after final C++14) [15.1p3]:</p>\n<blockquote>\n<p id=\"so_28875810_28876101_0\">Throwing an exception copy-initializes (8.5, 12.8) a temporary object,\n  called the exception object. The  temporary is an lvalue and is used\n  to initialize the variable declared in the matching handler (15.3).</p>\n</blockquote>\n<p>So you can't assume that your temporary \"survives the throw\". If throwing, the copy constructor of an exception object of type <code>std::exception</code> will be called with <code>e</code> as the argument. The temporary that <code>e</code> is bound to will be destroyed when control leaves the full expression containing the call to <code>my_assert</code> (either after a normal return or as part of stack unwinding, since you're conditionally throwing the exception).</p>\n<p>There are circumstances when the copy construction of the exception object can be elided, but this is not one of them, according to [12.8p31.2]:</p>\n<blockquote>\n<p id=\"so_28875810_28876101_1\">\u2014 in a throw-expression (5.17), when the operand is the name of a\n  non-volatile automatic object (<em>other than a function or catch-clause\n  parameter</em>) whose scope does not extend beyond the end of the innermost\n  enclosing try-block (if there is one), the copy/move operation from\n  the operand to the exception object (15.1) can be omitted by\n  constructing the automatic object directly into the exception object</p>\n</blockquote>\n<p>(emphasis mine)</p>\n", "LastEditorUserId": "4326278", "LastActivityDate": "2015-03-05T11:02:01.043", "Score": "9", "CreationDate": "2015-03-05T10:52:30.793", "ParentId": "28875810", "CommentCount": "1", "OwnerUserId": "4326278", "LastEditDate": "2015-03-05T11:02:01.043"}});