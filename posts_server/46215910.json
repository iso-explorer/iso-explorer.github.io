post_cb({"46217058": {"Id": "46217058", "PostTypeId": "2", "Body": "<p>From the most recent standards draft, <a href=\"http://eel.is/c++draft/dcl.constexpr#6\" rel=\"nofollow noreferrer\">[dcl.constexpr]/6</a> (my emphasis):</p>\n<blockquote>\n<p id=\"so_46215910_46217058_0\">If the instantiated template specialization of a constexpr function template or member function of a class template would fail to satisfy the requirements for a constexpr function or constexpr constructor, that specialization is still a constexpr function or constexpr constructor, even though a call to such a function cannot appear in a constant expression. <strong>If no specialization of the template would satisfy the requirements for a constexpr function or constexpr constructor when considered as a non-template function or constructor, the template is ill-formed, no diagnostic required.</strong></p>\n</blockquote>\n<hr>\n<p>Your function plainly fails to satisfy the requirements for a constexpr function, since its return type is not a literal type. This, combined with the clauses quoted above, would lead you to believe that your code is in fact ill-formed, <em>no diagnostic required</em> (which is pretty much what happens). I would expect any constexpr use of the member function to result in a diagnostic, though.</p>\n<p>See also <a href=\"https://stackoverflow.com/a/26598013/147845\">the accepted answer</a> to the question <em><a href=\"https://stackoverflow.com/q/26568820/147845\">Why do templates allow constexpr function members with non-constexpr constructors?</a></em> which deals with exactly the same case, except the function happens to be a free function as opposed to a member function.</p>\n</hr>", "LastActivityDate": "2017-09-14T10:48:07.140", "CommentCount": "4", "CreationDate": "2017-09-14T10:48:07.140", "ParentId": "46215910", "Score": "4", "OwnerUserId": "147845"}, "bq_ids": {"n4140": {"so_46215910_46217058_0": {"length": 50, "quality": 1.0, "section_id": 5422}}, "n3337": {"so_46215910_46217058_0": {"length": 34, "quality": 0.68, "section_id": 5217}}, "n4659": {"so_46215910_46217058_0": {"length": 50, "quality": 1.0, "section_id": 6844}}}, "46215910": {"ViewCount": "78", "Body": "\n<p>So is this a bug or intentional (using VS2017 update 15.3.4)?</p>\n<p>The following does not compile because <code>CustomType</code> is a nonliteral.</p>\n<pre><code>class A\n{\npublic:\n    // ... some constructors\n    inline constexpr auto Value() const { return _value; }\nprivate:\n    const CustomType _value;\n}\n</code></pre>\n<p>But this is totally fine:</p>\n<pre><code>template&lt; //... some templates\n    &gt;\nclass A\n{\npublic:\n    // ... some constructors\n    inline constexpr auto Value() const { return _value; }\nprivate:\n    const CustomType _value;\n}\n</code></pre>\n<p>Why!? Is there any benefit I am missing out on in the first instance by not using a constexpr? Is there any benefit I am receiving in the second instance by using constexpr or is the compiler simply being lazy and completely ignores the mistake? Or is all this intentionally done because there is some difference between a generic class and a non-generic class that I don't know about.</p>\n<p>Currently, I can only assume that this is intentional because it provides meta-programming functionality using template parameters, which is simply unnecessary in my current situation. So why can't nonliteral types be returned in constexpr in the first place? I know there are many questions in this thread, but perhaps a single answer will suffice for all of them.</p>\n<p>For the sake of clarity, run the following:</p>\n<pre><code>class CustomType\n{\npublic:\n    inline CustomType(const int&amp; val)\n        : _value(val) {}\n\n    inline constexpr auto Value() const { return _value; }\n\nprivate:\n    int _value;\n};\n\ntemplate&lt;int N&gt;\nclass A\n{\npublic:\n    inline constexpr A(const CustomType&amp; Val)\n        : _value(Val) {}\n    inline ~A() {}\n\n    inline constexpr A(const A&amp; rhs)\n        : _value(rhs._value) {}\n    inline constexpr const A&amp; operator=(const A&amp; rhs) const { return rhs; }\n\n    inline constexpr auto Value() const { return _value; }\nprivate:\n    const CustomType _value;\n};\n</code></pre>\n<p>If you remove <code>template&lt;int N&gt;</code> the code will no longer compile.</p>\n", "AcceptedAnswerId": "46217058", "Title": "Why is a constexpr member function only valid when returning a custom type in a generic class?", "CreationDate": "2017-09-14T09:52:30.740", "LastActivityDate": "2017-09-14T10:48:07.140", "CommentCount": "6", "LastEditDate": "2017-09-14T10:07:27.883", "PostTypeId": "1", "Tags": "<c++><c++14><c++1z><constexpr>", "Id": "46215910", "AnswerCount": "2", "Score": "0", "OwnerUserId": "8411980", "ClosedDate": "2017-09-14T12:54:39.270", "LastEditorUserId": "8411980"}, "46216451": {"Id": "46216451", "PostTypeId": "2", "Body": "<p>The method in your template class isn't really instantiated until you actually use it. Maybe the compiler checks its syntax sanity but never the semantics.</p>\n", "LastEditorUserId": "4667032", "LastActivityDate": "2017-09-14T10:31:27.427", "Score": "0", "CreationDate": "2017-09-14T10:17:00.107", "ParentId": "46215910", "CommentCount": "6", "OwnerUserId": "4667032", "LastEditDate": "2017-09-14T10:31:27.427"}});