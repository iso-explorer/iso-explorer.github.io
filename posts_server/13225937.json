post_cb({"13225937": {"CommentCount": "1", "AcceptedAnswerId": "13226082", "CreationDate": "2012-11-05T04:29:49.357", "LastActivityDate": "2012-11-05T05:32:05.743", "PostTypeId": "1", "ViewCount": "4873", "FavoriteCount": "0", "Title": "C++ error: was not declared in this scope with private after public", "Id": "13225937", "Score": "5", "Body": "<p>Attempting to modify the code from <a href=\"http://kbokonseriousstuff.blogspot.com/2011/09/using-reverse-iterators-with-c11-range.html\">this page</a>.</p>\n<p>Here's the problem code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\ntemplate&lt;class T&gt;\nclass const_reverse_wrapper\n{\npublic:\n    const_reverse_wrapper (const T&amp; cont)\n        : container_(cont)\n    {\n    }\n\n    decltype( container_.rbegin() ) begin() const\n    {\n        return container_.rbegin();\n    }\n\n    decltype( container_.rend() ) end()\n    {\n        return container_.rend();\n    }\n\nprivate:\n    const T &amp; container_;\n};\n\ntemplate&lt;class T&gt;\nclass reverse_wrapper\n{\npublic:\n    reverse_wrapper (T &amp; cont)\n        : container_(cont)\n    {\n    }\n\n    decltype( container_.rbegin() ) begin()\n    {\n        return container_.rbegin();\n    }\n\n    decltype( container_.rend() ) end()\n    {\n        return container_.rend();\n    }\nprivate:\n    T &amp; container_;\n};\n\ntemplate&lt;class T&gt;\nconst_reverse_wrapper&lt;T&gt; reversed (const T &amp; cont)\n{\n    return const_reverse_wrapper&lt;T&gt;(cont);\n}\n\ntemplate&lt;class T&gt;\nreverse_wrapper&lt;T&gt; reverse (T &amp; cont)\n{\n    return reverse_wrapper&lt;T&gt;(cont);\n}\n\nint main (int argc, char * argv[])\n{\n    std::array&lt;int,4&gt; a = { 1, 2, 3, 4 };\n    for (int i : a)\n        std::cout &lt;&lt; i;\n    return 0;\n}\n</code></pre>\n<p>When I compile it, I get these errors:</p>\n<pre><code>&gt; g++ -std=c++0x test2.cpp\ntest2.cpp:13:15: error: 'container_' was not declared in this scope\ntest2.cpp:13:15: error: 'container_' was not declared in this scope\ntest2.cpp:18:15: error: 'container_' was not declared in this scope\ntest2.cpp:18:15: error: 'container_' was not declared in this scope\ntest2.cpp:36:15: error: 'container_' was not declared in this scope\ntest2.cpp:36:15: error: 'container_' was not declared in this scope\ntest2.cpp:41:15: error: 'container_' was not declared in this scope\ntest2.cpp:41:15: error: 'container_' was not declared in this scope\n</code></pre>\n<p>When I move the private sections before the public sections in each class, the errors go away.</p>\n<pre><code>template&lt;class T&gt;\nclass const_reverse_wrapper\n{\nprivate:                    // &lt;-----\n    const T &amp; container_;   // &lt;-----\npublic:\n    const_reverse_wrapper (const T&amp; cont)\n        : container_(cont)\n    {\n    }\n\n    decltype( container_.rbegin() ) begin() const\n    {\n        return container_.rbegin();\n    }\n\n    decltype( container_.rend() ) end()\n    {\n        return container_.rend();\n    }\n};\n\ntemplate&lt;class T&gt;\nclass reverse_wrapper\n{\nprivate:              // &lt;-----\n    T &amp; container_;   // &lt;-----\npublic:\n    reverse_wrapper (T &amp; cont)\n        : container_(cont)\n    {\n    }\n\n    decltype( container_.rbegin() ) begin()\n    {\n        return container_.rbegin();\n    }\n\n    decltype( container_.rend() ) end()\n    {\n        return container_.rend();\n    }\n};\n</code></pre>\n<p>I've tried compiling with MinGW GCC 4.6.2 and 4.7.0 and get the same results. Is this a bug, or is there something else going on?</p>\n", "Tags": "<c++><gcc><c++11><gcc4.7>", "OwnerUserId": "1594322", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_13225937_13226082_0": {"section_id": 5862, "quality": 1.0, "length": 37}}, "n3337": {"so_13225937_13226082_0": {"section_id": 5632, "quality": 1.0, "length": 37}}, "n4659": {"so_13225937_13226082_0": {"section_id": 7345, "quality": 0.8648648648648649, "length": 32}}}, "13226082": {"ParentId": "13225937", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>You had the same problem before C++11:</p>\n<pre><code>struct X{\n  Foo f(){ return 42; } // error: 'Foo' does not name a type\n\n  typedef int Foo;\n};\n</code></pre>\n<p>The reason for this is that only the <em>body</em> of a member function is treated as if it was defined out-of-class with regards to member availability.</p>\n<p><code>\u00a79.2 [class.mem] p2</code></p>\n<blockquote>\n<p id=\"so_13225937_13226082_0\">A class is considered a completely-defined object type (3.9) (or complete type) at the closing <code>}</code> of the <em>class-specifier</em>. <strong>Within the class <em>member-specification</em>, the class is regarded as complete within function bodies</strong>, default arguments, <em>exception-specifications</em>, and <em>brace-or-equal-initializers</em> for non-static data members (including such things in nested classes). <strong>Otherwise it is regarded as incomplete within its own class <em>member-specification</em>.</strong></p>\n</blockquote>\n<p>As such, only names previously seen inside of the class <em>member-specification</em> (as the standard calls it) can be used.</p>\n<p>I see two possible fixes, one for your specific use-case and a general one. For your specific case, just use <code>typename T::const_reverse_iterator</code>. For the general case, use <code>std::declval</code> to obtain an object of a certain type for <code>decltype</code> and call the method on that:</p>\n<pre><code>#include &lt;functional&gt;\n\ndecltype(std::declval&lt;T const&amp;&gt;().rbegin()) rbegin() const{ ... }\n</code></pre>\n", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2012-11-05T05:32:05.743", "Id": "13226082", "Score": "5", "CreationDate": "2012-11-05T04:49:48.820", "LastActivityDate": "2012-11-05T05:32:05.743"}});