post_cb({"48538291": {"Id": "48538291", "PostTypeId": "2", "Body": "<p><code>reserve</code> changes the capacity, while <code>resize</code> changes the <code>size</code>.</p>\n<p><code>capacity</code> is the number of elements that the container has currently allocated space for.</p>\n<p><code>size</code> is the number of elements in the container.</p>\n<p>When you allocate an empty vector you get a default <code>capacity</code> (AKA space). The size is still 0, and when you add elements into the vector, its size increment. When size is equal to capacity and you add more item the capacity must grow (usually double itself). </p>\n<p>The problem with vector is that it ensures sequential memory, meaning each new allocation growth will need also a copy of the previous allocation to the new one, in case there was no space for the new allocation size in the old allocated memory area.</p>\n<p>Here the <code>reserve</code> can help, if you know the max elements in the vector. When you use <code>reserve</code>, there will be only one allocation and no memory copy, unless you pass the reserved items.</p>\n<p>When you tell the exact reserved count, you get the exact memory you asked. When you just add elements (even with resize, you don't say you wouldn't add more items.</p>\n", "LastEditorUserId": "63550", "LastActivityDate": "2018-01-31T12:42:07.363", "Score": "1", "CreationDate": "2018-01-31T09:05:56.247", "ParentId": "48537812", "CommentCount": "3", "OwnerUserId": "2852165", "LastEditDate": "2018-01-31T12:42:07.363"}, "48537812": {"ViewCount": "1766", "Body": "<p>I just found out that <code>std::vector&lt;T&gt;::resize</code> \"doubles\" its capacity even when resizing to one element above the current size:</p>\n<pre><code>std::vector&lt;int&gt; v(50);\nv.resize(51);\nstd::cout &lt;&lt; v.capacity() &lt;&lt; std::endl;\n</code></pre>\n<p>This program outputs 100 with GCC and Clang, and 75 with Visual C++. However, when I switch from <code>resize</code> to <code>reserve</code>:</p>\n<pre><code>std::vector&lt;int&gt; v(50);\nv.reserve(51);\nstd::cout &lt;&lt; v.capacity() &lt;&lt; std::endl;\n</code></pre>\n<p>The output is 51 with all three compilers.</p>\n<p>I wonder why implementations use a different expansion strategy for <code>resize</code> and <code>reserve</code>. It seems inconsistent, and I would expect the same behavior here.</p>\n<hr>\n<p>I am just adding a link to a motivation for my question, where the impact on performance is reported: <em><a href=\"https://stackoverflow.com/questions/48535727/c-stl-vectors-1000x-slower-when-doing-many-reserves\">Why are C++ STL vectors 1000x slower when doing many reserves?</a></em></p>\n<hr>\n<p>Adding a quote from C++11 Standard to clarify requirements for <code>reserve</code>; \u00a723.3.6.3(2):</p>\n<blockquote>\n<p id=\"so_48537812_48537812_0\">After <code>reserve()</code>, <code>capacity()</code> is <strong>greater or equal</strong> to the argument of <code>reserve</code> if reallocation happens...</p>\n</blockquote>\n<hr>\n<p>Some additional thoughts: From C++11 Standard:</p>\n<blockquote>\n<p id=\"so_48537812_48537812_1\">Complexity: The complexity is linear in the number of elements inserted plus the distance to the end of the vector.</p>\n</blockquote>\n<p>Which, effectively, implies constant (amortized) complexity for inserting a single element at the end. However, this applies only for <strong>vector modifiers</strong>, such as <code>push_back</code> or <code>insert</code> (\u00a723.3.6.5).</p>\n<p><code>resize</code> is not listed among modifiers. It's listed in \u00a723.3.6.3 <code>vector</code> capacity section. And, there are no complexity requirements for <code>resize</code>.</p>\n<p>However, in the <code>vector</code> overview section (\u00a723.3.6.1), there is written:</p>\n<blockquote>\n<p id=\"so_48537812_48537812_2\">it (<em><code>vector</code></em>) supports (amortized) constant time insert and erase operations at the end</p>\n</blockquote>\n<p>The question is whether <code>resize(size()+1)</code> is considered to be <em>\"insertion at the end\"</em>. </p>\n</hr></hr></hr>", "AcceptedAnswerId": "48538793", "Title": "Why does std::vector reserve not \"double\" its capacity, while resize does?", "CreationDate": "2018-01-31T08:38:45.057", "LastActivityDate": "2018-02-01T09:40:55.893", "CommentCount": "5", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2018-02-01T09:40:55.893", "LastEditorUserId": "580083", "Id": "48537812", "Score": "22", "OwnerUserId": "580083", "Tags": "<c++><vector><resize><capacity>", "AnswerCount": "5"}, "48538793": {"Id": "48538793", "PostTypeId": "2", "Body": "<p>As far as I can tell, neither <code>resize</code> nor <code>reserve</code> is required to have the demonstrated behaviour. Both are however allowed such behaviour although both could either allocate the exact amount, and both could multiply the previous allocation as far as the standard is concerned.</p>\n<p>Each allocation strategies have their advantages. The advantage of allocating exact amount is that it has no memory overhead when the maximum allocation is known beforehand. The advantage of multiplying is that it maintains the constant amortized property when mixed with end-insertion operations.</p>\n<p>The approach chosen by the tested implementations has the advantage that it allows both strategies when resizing. To use one strategy, one can reserve and then resize. To use the other, just resize. Of course, one has to be aware of the unspecified behaviour to take advantage of this. This advantage may or might not be the reasoning behind the choice of these implementations.</p>\n<p>One might consider it a failure of the vector API, as specified in the standard, that expressing the intended reallocation behaviour is not possible.</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2018-01-31T09:42:01.563", "Score": "13", "CreationDate": "2018-01-31T09:34:42.873", "ParentId": "48537812", "CommentCount": "10", "OwnerUserId": "2079303", "LastEditDate": "2018-01-31T09:42:01.563"}, "bq_ids": {"n4140": {"so_48537812_48537812_2": {"length": 9, "quality": 1.0, "section_id": 955}, "so_48537812_48537812_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 987}, "so_48537812_48537812_0": {"length": 9, "quality": 1.0, "section_id": 969}}, "n3337": {"so_48537812_48537812_2": {"length": 9, "quality": 1.0, "section_id": 943}, "so_48537812_48537812_0": {"length": 9, "quality": 1.0, "section_id": 958}, "so_48537812_48537812_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 972}}, "n4659": {"so_48537812_48537812_2": {"length": 9, "quality": 1.0, "section_id": 1016}, "so_48537812_48537812_0": {"length": 9, "quality": 1.0, "section_id": 1031}, "so_48537812_48537812_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 1050}}}, "48547277": {"Id": "48547277", "PostTypeId": "2", "Body": "<p><code>resize</code> is required to follow an exponential reallocation strategy to fulfil its complexity guarantee (linear in the number of elements <em>inserted</em>). This can be seen by considering that <code>resize(size() + 1)</code> is required to have amortized constant complexity, so must follow exponential growth for the same reason that <code>push_back</code> (amortized constant complexity) must grow exponentially.</p>\n<p>An implementation of <code>reserve</code> is permitted to follow whatever allocation strategy it likes, since its only complexity requirement is that it be linear in the number of elements <em>present</em>. However, if an implementation were e.g. to round up to the next power of two, this would be space-inefficient (and surprising) in the case where the user knows exactly how much memory is required, and could complicate porting if the user comes to rely on this behavior. The latitude in the Standard is better exercised in cases where there is no space inefficiency e.g. by rounding up allocations to the word size, if the allocator operates at that granularity.</p>\n", "LastActivityDate": "2018-01-31T16:47:59.810", "CommentCount": "3", "CreationDate": "2018-01-31T16:47:59.810", "ParentId": "48537812", "Score": "4", "OwnerUserId": "567292"}, "48537901": {"Id": "48537901", "PostTypeId": "2", "Body": "<p>When you <code>resize</code> more than there is capacity you already \"demonstrate\" that you don't want to reserve just the right capacity. On the other hand, if you use <code>reserve</code> you explicitly ask for the right capacity. If <code>reserve</code> would use the same strategy as <code>resize</code> there would be no way to reserve just the right amount. </p>\n<p>In this sense <code>resize</code> without <code>reserve</code> is for the lazy ones or in case you don't know the exact amount to reserve. You call <code>reserve</code> if you know what capacity you need. That's two different scenarios.</p>\n<p>PS: As StoryTeller pointed out, also <code>reserve</code> is not required to reserve the exact amount that is asked for as per the standard. Nevertheless I think my main argument still holds: <code>resize</code> (without <code>reserve</code>) and <code>reserve</code> are meant for different scenarios, where you either give a hint of how much you want to reserve or don't care about the actual capacity and just want to have the container sized to what you ask for.</p>\n", "LastEditorUserId": "63550", "LastActivityDate": "2018-01-31T12:39:04.503", "Score": "8", "CreationDate": "2018-01-31T08:44:28.097", "ParentId": "48537812", "CommentCount": "8", "OwnerUserId": "4117728", "LastEditDate": "2018-01-31T12:39:04.503"}, "48541723": {"Id": "48541723", "PostTypeId": "2", "Body": "<p>Why would you expect them to behave the same? <code>reserve</code> is used to preallocate space you will use later, with the expectation that the user has a decent handle on the expected final size of the container. <code>resize</code> is simply a normal allocation, and so it follows the normal, speed efficient, approach of geometrically increasing the container's allocated space.</p>\n<p>Containers increase in size by multiplicative steps to reduce the number of allocations needed and thus maintain speed and reduce memory fragmentation. Doubling is the most common, but some implementations use steps of 1.5 (e.g. MSVC) which trade increased allocations for lower wasted space within each container.</p>\n<p>But, if the user has already told the library how big they think the container will get - by causing <code>reserve</code> - there's no need to allocate excess space, they can instead trust the user to have called it with the correct number. It is <code>reserve</code> that has the unusual behaviour, not <code>resize</code>.</p>\n", "LastEditorUserId": "1502345", "LastActivityDate": "2018-01-31T14:58:51.743", "Score": "5", "CreationDate": "2018-01-31T12:04:04.057", "ParentId": "48537812", "CommentCount": "15", "OwnerUserId": "1502345", "LastEditDate": "2018-01-31T14:58:51.743"}});