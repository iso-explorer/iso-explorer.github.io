post_cb({"bq_ids": {"n4140": {"so_48163655_48163948_1": {"length": 17, "quality": 0.7727272727272727, "section_id": 6857}, "so_48163655_48163948_0": {"length": 84, "quality": 0.9230769230769231, "section_id": 6092}, "so_48163655_48163948_4": {"length": 14, "quality": 0.7777777777777778, "section_id": 6155}, "so_48163655_48163948_3": {"length": 4, "quality": 0.8, "section_id": 6859}}, "n3337": {"so_48163655_48163948_1": {"length": 17, "quality": 0.7727272727272727, "section_id": 6603}, "so_48163655_48163948_0": {"length": 84, "quality": 0.9230769230769231, "section_id": 5859}, "so_48163655_48163948_4": {"length": 17, "quality": 0.9444444444444444, "section_id": 5917}, "so_48163655_48163948_3": {"length": 4, "quality": 0.8, "section_id": 6605}}, "n4659": {"so_48163655_48163948_1": {"length": 17, "quality": 0.7727272727272727, "section_id": 8349}, "so_48163655_48163948_0": {"length": 85, "quality": 0.9340659340659341, "section_id": 7588}, "so_48163655_48163948_4": {"length": 11, "quality": 0.6111111111111112, "section_id": 7652}, "so_48163655_48163948_3": {"length": 4, "quality": 0.8, "section_id": 8351}}}, "48166209": {"Id": "48166209", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48163655_48166209_0\">Can I assume <code>(void*)t == (void*)p</code>?</p>\n</blockquote>\n<p>Not necessarily.</p>\n<p>If the author of the class overloads <code>CLASS::operator new(size_t, unsigned char*)</code>, for example, that operator can return anything other than the second argument, e.g.:</p>\n<pre><code>struct CLASS\n{\n    static void* operator new(size_t, unsigned char* p) { return p + 1; }\n};\n</code></pre>\n<p>If you would like this <em>new expression</em> to call <a href=\"http://en.cppreference.com/w/cpp/memory/new/operator_new\" rel=\"nofollow noreferrer\"><em>the standard non-allocating placement new operator</em></a> the code needs to</p>\n<ol>\n<li>Include header <code>&lt;new&gt;</code>.</li>\n<li>Make sure to pass it a <code>void*</code> argument.</li>\n<li>Prefix it with scope resolution operator <code>::</code> to bypass <code>CLASS::operator new</code>, if any.</li>\n</ol>\n<p>E.g.:</p>\n<pre><code>#include &lt;new&gt; \n#include &lt;cassert&gt; \n\nunsigned char p[sizeof(CLASS)];\nCLASS* t = ::new (static_cast&lt;void*&gt;(p)) CLASS;\nassert(t == static_cast&lt;void*&gt;(p));\n</code></pre>\n<p>In this case <code>t == static_cast&lt;void*&gt;(p)</code> indeed.</p>\n<p>This is, in fact, what GNU C++ standard library does:</p>\n<pre><code>template&lt;typename _T1, typename... _Args&gt;\ninline void _Construct(_T1* __p, _Args&amp;&amp;... __args) { \n    ::new(static_cast&lt;void*&gt;(__p)) _T1(std::forward&lt;_Args&gt;(__args)...); \n}\n</code></pre>\n", "LastEditorUserId": "412080", "LastActivityDate": "2018-01-10T10:51:09.573", "Score": "8", "CreationDate": "2018-01-09T10:33:09.523", "ParentId": "48163655", "CommentCount": "0", "OwnerUserId": "412080", "LastEditDate": "2018-01-10T10:51:09.573"}, "48163655": {"ViewCount": "420", "Body": "<p>Please see the below code:    </p>\n<pre><code>unsigned char* p = new unsigned char[x];\nCLASS* t = new (p) CLASS;\nassert((void*)t == (void*)p);\n</code></pre>\n<p>Can I assume <code>(void*)t == (void*)p</code>?</p>\n", "Title": "After placement-new into buffer, do buffer and instance have same void* address?", "CreationDate": "2018-01-09T07:57:44.303", "LastActivityDate": "2018-01-10T10:51:09.573", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2018-01-09T10:35:40.167", "LastEditorUserId": "2757035", "Id": "48163655", "Score": "14", "OwnerUserId": "3968307", "Tags": "<c++><c++11><language-lawyer><placement-new>", "AnswerCount": "2"}, "48163948": {"Id": "48163948", "PostTypeId": "2", "Body": "<p>Yes you may. I believe it's guaranteed by several provisions.</p>\n<ol>\n<li><p><a href=\"https://timsong-cpp.github.io/cppwp/n3337/expr.new#10\" rel=\"noreferrer\">[expr.new]/10</a> - Emphasis mine</p>\n<blockquote>\n<p id=\"so_48163655_48163948_0\">A new-expression passes the amount of space requested to the\n  allocation function as the first argument of type std::size_t. <strong>That\n  argument shall be no less than the size of the object being created;\n  it may be greater than the size of the object being created only if\n  the object is an array</strong>. For arrays of char and unsigned char, the\n  difference between the result of the new-expression and the address\n  returned by the allocation function shall be an integral multiple of\n  the strictest fundamental alignment requirement ([basic.align]) of any\n  object type whose size is no greater than the size of the array being\n  created. [ Note: Because allocation functions are assumed to return\n  pointers to storage that is appropriately aligned for objects of any\n  type with fundamental alignment, this constraint on array allocation\n  overhead permits the common idiom of allocating character arrays into\n  which objects of other types will later be placed.  \u2014 end note ]</p>\n</blockquote>\n<p>Which to me reads like the new expression must create an object (assuming it's not of array type) at the exact address returned by the allocation function. Since you are using the built-in placement new, this take us to the following</p></li>\n<li><p><a href=\"https://timsong-cpp.github.io/cppwp/n3337/new.delete.placement\" rel=\"noreferrer\">[new.delete.placement]</a></p>\n<blockquote>\n<p id=\"so_48163655_48163948_1\">These functions are reserved, a C++ program may not define functions\n  that displace the versions in the Standard C++ library\n  ([constraints]). The provisions of ([basic.stc.dynamic]) do not apply\n  to these reserved placement forms of operator new and operator delete.</p>\n<pre><code>void* operator new(std::size_t size, void* ptr) noexcept;\n</code></pre>\n<p id=\"so_48163655_48163948_2\">Returns: ptr.</p>\n<p id=\"so_48163655_48163948_3\">Remarks: Intentionally performs no other action.</p>\n</blockquote>\n<p>Which guarantees the address you pass to the expression is the exact address of the character array object you allocated. That's because conversions to <code>void*</code> do not change the source address.</p></li>\n</ol>\n<p>I think it's enough to promise the addresses are the same, even if the pointers are not interchangeable in general. So according to <a href=\"https://timsong-cpp.github.io/cppwp/n3337/expr.eq#1\" rel=\"noreferrer\">[expr.eq]/1</a> (thanks to @T.C.):</p>\n<blockquote>\n<p id=\"so_48163655_48163948_4\">Two pointers of the same type compare equal if and only if they are\n  both null, both point to the same function, or <strong>both represent the same\n  address</strong> ([basic.compound]).</p>\n</blockquote>\n<p>The comparison must yield true, again because the addresses are the same.</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2018-01-09T10:26:48.657", "Score": "12", "CreationDate": "2018-01-09T08:19:46.590", "ParentId": "48163655", "CommentCount": "6", "OwnerUserId": "817643", "LastEditDate": "2018-01-09T10:26:48.657"}});