post_cb({"29467822": {"ParentId": "29467795", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Arrays do not have separate cv-qualification from their elements, so you are asking for something that does not exist. Quoth the standard,</p>\n<blockquote>\n<p id=\"so_29467795_29467822_0\">Any cv-qualifiers applied to an array type affect the array element type, not the array type (8.3.4).</p>\n</blockquote>\n<p>([basic.type.qualifier]/2 in N3936)</p>\n<p>However, it goes on to say that when the element type is qualified, the array type is considered to be qualified too:</p>\n<blockquote>\n<p id=\"so_29467795_29467822_1\">... An array type whose elements are\n  cv-qualified is also considered to have the same cv-qualifications as its elements.</p>\n</blockquote>\n<p>([basic.type.qualifier]/5)</p>\n<p>And the code you wrote can indeed be rewritten without a typedef. The declarator syntax is</p>\n<pre><code>void f(const int (&amp;a)[3]);\n</code></pre>\n<p>The <code>const</code> still attaches to the element type, but the array type is also <code>const</code>, so the reference is an lvalue reference to a <code>const</code> type. So that's why it can bind to a temporary.</p>\n", "OwnerUserId": "481267", "LastEditorUserId": "481267", "LastEditDate": "2015-04-09T19:09:52.850", "Id": "29467822", "Score": "5", "CreationDate": "2015-04-06T08:28:41.967", "LastActivityDate": "2015-04-09T19:09:52.850"}, "29467862": {"ParentId": "29467795", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This was subject of core issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1059\" rel=\"nofollow\"><strong>#1059</strong></a>:</p>\n<blockquote>\n<p id=\"so_29467795_29467862_0\">There does not appear to be a definitive normative statement answering\n  the question of whether an array with a const-qualified element type\n  is itself const-qualified; [...]</p>\n</blockquote>\n<p>... which was resolved just after C++11 was ratified. Now [basic.type.qualifier]/5 reads:</p>\n<blockquote>\n<p id=\"so_29467795_29467862_1\">Cv-qualifiers applied to an array type attach to the underlying\n  element type, so the notation \u201c<em>cv</em> <code>T</code>,\u201d where <code>T</code> is an array type, refers\n  to an array whose elements are so-qualified. <strong>An array type whose\n  elements are cv-qualified is also considered to have the same\n  cv-qualifications as its elements.</strong></p>\n</blockquote>\n<p>Thus it's impossible to make the array elements <code>const</code> but not the enclosing array itself, and vice versa.<br>\nE.g.</br></p>\n<pre><code>const int arr[2];\n</code></pre>\n<p>Here, <code>arr</code> is (top-level) <code>const</code> (<code>std::is_const&lt;decltype(arr)&gt;{}</code> is <code>true</code>) and so are its elements. And in</p>\n<pre><code>void f(const (&amp;a)[3]) {...}\n</code></pre>\n<p><code>a</code> refers to a <code>const</code> array with <code>const</code> elements.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-04-06T08:46:21.543", "Id": "29467862", "Score": "1", "CreationDate": "2015-04-06T08:32:23.967", "LastActivityDate": "2015-04-06T08:46:21.543"}, "bq_ids": {"n4140": {"so_29467795_29467822_1": {"section_id": 7229, "quality": 1.0, "length": 11}, "so_29467795_29467822_0": {"section_id": 7226, "quality": 0.8333333333333334, "length": 10}, "so_29467795_29467862_1": {"section_id": 7229, "quality": 1.0, "length": 28}}, "n3337": {"so_29467795_29467862_1": {"section_id": 6973, "quality": 0.6428571428571429, "length": 18}, "so_29467795_29467822_0": {"section_id": 6970, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_29467795_29467862_1": {"section_id": 8740, "quality": 1.0, "length": 28}, "so_29467795_29467822_0": {"section_id": 8736, "quality": 0.6666666666666666, "length": 8}, "so_29467795_29467822_1": {"section_id": 8740, "quality": 1.0, "length": 11}}}, "29467795": {"CommentCount": "0", "AcceptedAnswerId": "29467822", "CreationDate": "2015-04-06T08:25:55.757", "LastActivityDate": "2015-04-09T19:09:52.850", "PostTypeId": "1", "ViewCount": "159", "FavoriteCount": "1", "Title": "Syntax for defining const array type", "Id": "29467795", "Score": "4", "Body": "<p>Be warned, I'm just interested in the possibility of C++ syntax, not in any practical use.</p>\n<p>It easy to define an array type. As an example, <code>int a[3];</code> defines an array type of 3 <code>int</code>, while <code>const int a[3];</code> or <code>int const a[3];</code> defines an array type of 3 <code>const int</code>. None of the three forms actually defines a <strong>const array</strong> of some type <code>T</code> (which itself can be const-modified, of course). Consequently, the following code will not compile:</p>\n<pre><code>void f(int (&amp;a)[3]) {...}\n\nf({1, 2, 3});\n</code></pre>\n<p>The reason is simple: a non-const lval reference cannot be bound to an rval temporary. One way to correct the code would be:</p>\n<pre><code>typedef int ArrOfInt[3];\n\nvoid f(const ArrOfInt&amp; a) {...}\n\nf({1, 2, 3});\n</code></pre>\n<p>My question is: does C++ have syntax for an inline definition of const array type, so that there is no need for a <code>typedef</code> in the first place?</p>\n", "Tags": "<c++><arrays><syntax><const><language-lawyer>", "OwnerUserId": "1348273", "AnswerCount": "2"}});