post_cb({"28087336": {"ParentId": "28085847", "LastEditDate": "2015-01-22T12:13:24.500", "CommentCount": "10", "CreationDate": "2015-01-22T11:12:09.787", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "PostTypeId": "2", "Id": "28087336", "Score": "12", "Body": "<p>The C++14 FD defines <code>is_constructible</code> as follows: </p>\n<blockquote>\n<p id=\"so_28085847_28087336_0\">Given the following function declaration:</p>\n<pre><code>template &lt;class T&gt;\nadd_rvalue_reference_t&lt;T&gt; create() noexcept;\n</code></pre>\n<p id=\"so_28085847_28087336_1\">the predicate condition for a template specialization\n  <code>is_constructible&lt;T, Args...&gt;</code> shall be satisfied if and only if the\n  following variable definition would be well-formed for some invented\n  variable <code>t</code>:</p>\n<pre><code>T t(create&lt;Args&gt;()...);\n</code></pre>\n<p id=\"so_28085847_28087336_2\"><strong>Access checking is performed as if in a context unrelated to <code>T</code>\n  and any of the <code>Args</code>. Only the validity of the immediate context of\n  the variable initialization is considered.</strong> [ <em>Note</em>: The evaluation\n  of the initialization can result in side effects such as the\n  instantiation of class template specializations and function template\n  specializations, the generation of implicitly-defined functions, and\n  so on. Such side effects are not in the \u201cimmediate context\u201d and can\n  result in the program being ill-formed. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Now the question essentially reduces to \"Is the destructor call in the immediate context of the variable initialization?\" [class.dtor]/11:</p>\n<blockquote>\n<p id=\"so_28085847_28087336_3\">A destructor is invoked implicitly</p>\n<ul>\n<li>for a constructed object with static storage duration (3.7.1) at program termination (3.6.3),</li>\n<li>for a constructed object with automatic storage duration (3.7.3) when the block in which an object is created exits (6.7),</li>\n<li>for a constructed temporary object when its lifetime ends (12.2).</li>\n</ul>\n<p id=\"so_28085847_28087336_4\"><strong>In each case, the context of the invocation is the context of the\n  construction of the object.</strong></p>\n</blockquote>\n<p>Thus the destructor invocation is in the context of the construction (which is presumably synonymous to initialization here), which implies that it is considered and causes the trait to return <code>false</code>.<br>\nI believe this to be underspecified (e.g. immediate vs not-explicitly-immediate context?), but intuitively I expect a conforming implementation to mark the expression <code>NotDestructible()</code> as ill-formed - either SFINAE-friendly or not (preferably the former). Never well-formed, though.<br>\n<a href=\"http://coliru.stacked-crooked.com/a/0d4c16ec2739d5dc\" rel=\"noreferrer\">Clang with libc++, libstdc++ and GCC do say that it's invalid, SFINAE-friendly</a>.</br></br></p>\n<hr>\n<blockquote>\n<p id=\"so_28085847_28087336_5\">If so, is there any way to check whether the type has a specific\n  constructor, regardless of the access specifier on the destructor?</p>\n</blockquote>\n<p>What about using <code>new</code>?</p>\n<pre><code>template &lt;typename T, typename... Args&gt;\nclass is_only_constructible\n{\n    template &lt;typename, typename=void&gt; struct test : std::false_type {};\n    template &lt;typename U&gt;\n    struct test&lt;U, decltype(void(new U(std::declval&lt;Args&gt;()...)))&gt; : std::true_type {};\n\npublic:\n    static constexpr bool value = test&lt;T&gt;::value;\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/d5c68c8b14fc653e\" rel=\"noreferrer\"><strong>Demo</strong></a>. Consistent traits can be easily established: Take the <code>is_only_constructible</code> trait and combine it with <code>is_destructible</code> (clearly the latter returns <code>false</code> when combined with private destructors).</p>\n</hr>", "LastActivityDate": "2015-01-22T12:13:24.500"}, "28085847": {"CommentCount": "2", "ViewCount": "479", "CreationDate": "2015-01-22T10:01:20.663", "LastActivityDate": "2015-01-22T12:13:24.500", "Title": "std::is_constructible on type with non-public destructor", "AcceptedAnswerId": "28087336", "PostTypeId": "1", "Id": "28085847", "Score": "11", "Body": "<p>What is the expected result for <a href=\"http://en.cppreference.com/w/cpp/types/is_constructible\"><code>std::is_constructible</code></a> on a type with a private or protected destructor? </p>\n<p>For instance, I can still construct such an object on the heap even though only a friend can free it:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nclass Foo\n{\n    friend void freeFoo(Foo*);\npublic:\n    Foo()\n    {}\nprivate:\n    // Destructor is private!\n    ~Foo()\n    {}\n};\n\nvoid freeFoo(Foo* f)\n{\n    delete f;  // deleting a foo is fine here because of friendship\n}\n\nint main()\n{\n    Foo* f = new Foo();\n    // delete f;   // won't compile: ~Foo is private\n    freeFoo(f);    // fine because of friendship\n\n\n    if(!std::is_constructible&lt;Foo&gt;::value)\n    {\n        std::cout &lt;&lt; \"is_constructible failed\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>The final check for <code>is_constructible</code> will fail on both gcc and Visual C++ (<a href=\"http://coliru.stacked-crooked.com/a/09e361eabcdf1553\">gcc demo on coliru</a>).</p>\n<p>Is that the required behavior by the standard? If so, is there any way to check whether the type has a specific constructor, regardless of the access specifier on the destructor?</p>\n", "Tags": "<c++><c++11><language-lawyer><typetraits>", "OwnerUserId": "577603", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28085847_28086046_0": {"section_id": 4710, "quality": 1.0, "length": 4}, "so_28085847_28087336_1": {"section_id": 4710, "quality": 1.0, "length": 15}, "so_28085847_28087336_4": {"section_id": 407, "quality": 1.0, "length": 7}, "so_28085847_28087336_2": {"section_id": 4710, "quality": 0.8809523809523809, "length": 37}, "so_28085847_28087336_0": {"section_id": 4710, "quality": 1.0, "length": 4}, "so_28085847_28086046_1": {"section_id": 4710, "quality": 1.0, "length": 15}}, "n3337": {"so_28085847_28086046_0": {"section_id": 4518, "quality": 1.0, "length": 4}, "so_28085847_28087336_1": {"section_id": 4518, "quality": 1.0, "length": 15}, "so_28085847_28087336_2": {"section_id": 4518, "quality": 0.8809523809523809, "length": 37}, "so_28085847_28087336_0": {"section_id": 4518, "quality": 1.0, "length": 4}, "so_28085847_28086046_1": {"section_id": 4518, "quality": 1.0, "length": 15}}, "n4659": {"so_28085847_28086046_0": {"section_id": 6496, "quality": 1.0, "length": 4}, "so_28085847_28087336_1": {"section_id": 6107, "quality": 1.0, "length": 15}, "so_28085847_28087336_4": {"section_id": 425, "quality": 1.0, "length": 7}, "so_28085847_28087336_2": {"section_id": 6107, "quality": 0.8809523809523809, "length": 37}, "so_28085847_28087336_0": {"section_id": 6496, "quality": 1.0, "length": 4}, "so_28085847_28086046_1": {"section_id": 6107, "quality": 1.0, "length": 15}}}, "28086046": {"ParentId": "28085847", "CommentCount": "5", "Body": "<p>Quoting paragraph [meta.unary.prop]/7 of the C++ Standard (Draft N4296):</p>\n<blockquote>\n<p id=\"so_28085847_28086046_0\">Given the following function declaration:</p>\n<pre><code>template &lt;class T&gt;\nadd_rvalue_reference_t&lt;T&gt; create() noexcept;\n</code></pre>\n<p id=\"so_28085847_28086046_1\">the predicate condition for a template specialization <code>is_constructible&lt;T, Args...&gt;</code> shall be satisfied if and only if the following variable definition would be well-formed for some invented variable <code>t</code>:</p>\n<pre><code>T t(create&lt;Args&gt;()...);\n</code></pre>\n</blockquote>\n<p>In other words, <code>is_constructible&lt;T, Args...&gt;::value</code> yields <code>false</code> if the destructor is not accessible.</p>\n", "OwnerUserId": "1932150", "PostTypeId": "2", "Id": "28086046", "Score": "5", "CreationDate": "2015-01-22T10:09:22.700", "LastActivityDate": "2015-01-22T10:09:22.700"}});