post_cb({"12504634": {"LastActivityDate": "2012-09-20T05:47:19.937", "LastEditorUserId": "1490355", "ParentId": "5360501", "LastEditDate": "2012-09-20T05:47:19.937", "Id": "12504634", "Score": "1", "Body": "<p>This is what I think happens.</p>\n<p><code>a-&gt;foo();</code>\nworks because you are just calling <code>A::foo(a).</code></p>\n<p><code>a</code> is a pointer type variable that is in main's call stack. <code>foo()</code> function may throw a segmentation error when location <code>a</code> is accessed, but if it does not, then <code>foo()</code> just jumps some locations from a and overwrites 4 bytes of memory with the value 5. It then reads out the same value. </p>\n<p>Am I right or wrong? Please let me know, I am learning about call stacks and would appreciate any feedback on my answer. </p>\n<p>Also look at the following code</p>\n<pre><code>#include&lt;iostream&gt;\nclass A {\n    int num;\n    public:\n        void foo(){ num=5; std::cout&lt;&lt; \"num=\"; std::cout&lt;&lt;num;}\n};\n\nint main() {\n\n    A* a;\n    std::cout&lt;&lt;\"sizeof A is \"&lt;&lt;sizeof(A*)&lt;&lt;std::endl;\n    std::cout&lt;&lt;\"sizeof int is \"&lt;&lt;sizeof(int)&lt;&lt;std::endl;\n    int buffer=44;\n    std::cout&lt;&lt;\"buffer is \"&lt;&lt;buffer&lt;&lt;std::endl;\n    a=(A*)&amp;buffer;\n\n    a-&gt;foo();\n    std::cout&lt;&lt;\"\\nbuffer is \"&lt;&lt;buffer&lt;&lt;std::endl;\n    return 0;\n}\n</code></pre>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "1684517", "CreationDate": "2012-09-20T00:24:34.057"}, "5360501": {"ViewCount": "2008", "AcceptedAnswerId": "5360531", "Tags": "<c++><pointers><object><initialization>", "AnswerCount": "7", "OwnerUserId": "604857", "Body": "<p>Why does the following code run?</p>\n<pre><code>#include &lt;iostream&gt;\nclass A {\n    int num;\n    public:\n        void foo(){ num=5; std::cout&lt;&lt; \"num=\"; std::cout&lt;&lt;num;}\n};\n\nint main() {\n    A* a;\n    a-&gt;foo();\n    return 0;\n}\n</code></pre>\n<p>The output is </p>\n<pre><code>num=5\n</code></pre>\n<p>I compile this using gcc and I get only the following compiler warning at line 10:  </p>\n<p>(<em><strong>warning: 'a' is used uninitialized in this function</strong></em>)  </p>\n<p>But as per my understanding, shouldn't this code not run at all? And how come it's assigning the value 5 to num when num doesn't exist because no object of type A has been created yet? </p>\n", "CommentCount": "9", "PostTypeId": "1", "CreationDate": "2011-03-19T06:09:28.973", "FavoriteCount": "2", "LastActivityDate": "2012-09-20T05:47:19.937", "Id": "5360501", "LastEditorUserId": "604857", "Title": "C++ function called without object initialization", "Score": "5", "LastEditDate": "2011-03-19T06:18:44.657"}, "5360524": {"LastActivityDate": "2011-03-19T06:15:42.393", "ParentId": "5360501", "Id": "5360524", "Score": "2", "Body": "<p><code>A* a;</code> is an uninitialized pointer.</p>\n<p>the value you see is garbage, and you are luck you did not end up with a crash.</p>\n<p>there is no initialization here.</p>\n<p>there is no assignment here.</p>\n<p>your class happens to be simple enough that more serious issues are not exhibited.</p>\n<p><code>A* a(0);</code> would lead to a crash. an uninitialized pointer would lead to a crash in some cases, and is more easily reproduced with more complex types.</p>\n<p>this is the consequence of dealing with uninitialized pointers and objects, and it points out the importance of compiler warnings.</p>\n", "CommentCount": "6", "PostTypeId": "2", "OwnerUserId": "191596", "CreationDate": "2011-03-19T06:15:42.393"}, "bq_ids": {"n3337": {"so_5360501_5360520_0": {"section_id": 5, "quality": 0.8333333333333334, "length": 30}}}, "5360520": {"LastActivityDate": "2011-03-19T06:26:42.003", "LastEditorUserId": "-1", "ParentId": "5360501", "LastEditDate": "2017-05-23T11:53:13.470", "Id": "5360520", "Score": "1", "Body": "<pre><code>A* a;\na-&gt;foo();\n</code></pre>\n<p>That invokes <strong>undefined behaviour</strong>. Most commonly it crashes the program.</p>\n<p>The section \u00a74.1/1 from the C++03 Standard says,</p>\n<blockquote>\n<p id=\"so_5360501_5360520_0\">An lvalue (3.10) of a\n  non-function, non-array type T can be\n  converted to an rvalue. If T is an\n  incomplete type, a program that\n  necessitates this conversion is\n  ill-formed. If the object to which the\n  lvalue refers is not an object of type\n  T and is not an object of a type\n  derived from T, or <strong>if the object is\n  uninitialized, a program that\n  necessitates this conversion has\n  undefined behavior</strong>. If T is a\n  non-class type, the type of the rvalue\n  is the cv-unqualified version of T.\n  Otherwise, the type of the rvalue is\n  T.</p>\n</blockquote>\n<p>See this similar topic: <a href=\"https://stackoverflow.com/questions/4285895/where-exactly-does-c-standard-say-dereferencing-an-uninitialized-pointer-is-und\">Where exactly does C++ standard say dereferencing an uninitialized pointer is undefined behavior?</a></p>\n<hr>\n<blockquote>\n<p id=\"so_5360501_5360520_1\">And how come it's assigning the value 5 to num when num doesn't exist because no object of type A has been created yet.</p>\n</blockquote>\n<p>It's called being lucky. But it wouldn't happen <strong>always</strong>.</p>\n</hr>", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "415784", "CreationDate": "2011-03-19T06:14:42.507"}, "5360531": {"LastActivityDate": "2011-03-19T06:36:31.567", "LastEditorUserId": "365102", "ParentId": "5360501", "LastEditDate": "2011-03-19T06:36:31.567", "Id": "5360531", "Score": "2", "Body": "<p>You haven't initialized <code>*a</code>.</p>\n<p>Try this:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\n    int num;\n    public:\n        void foo(){ std::cout&lt;&lt; \"num=\"; num=5; std::cout&lt;&lt;num;}\n};\n\nint main()\n{\n    A* a = new A();\n    a-&gt;foo();\n    return 0;\n}\n</code></pre>\n<hr>\n<p>Not initializing pointers (properly) can lead to undefined behavior. If you're lucky, your pointer points to a location in the heap which is up for initialization*. (Assuming no exception is thrown when you do this.) If you're unlucky, you'll overwrite a portion of the memory being used for other purposes. If you're really unlucky, this will go unnoticed.</p>\n<p>This is not safe code; a \"hacker\" could probably exploit it.</p>\n<p>*Of course, even when you access that location, there's no guarantee it won't be \"initialized\" later.</p>\n<hr>\n<p>\"Lucky\" (actually, being \"lucky\" makes it more difficult to debug your program):</p>\n<pre><code>// uninitialized memory 0x00000042 to 0x0000004B\nA* a;\n// a = 0x00000042;\n*a = \"lalalalala\";\n// \"Nothing\" happens\n</code></pre>\n<hr>\n<p>\"Unlucky\" (makes it easier to debug your program, so I don't consider it \"unlucky\", really):</p>\n<pre><code>void* a;\n// a = &amp;main;\n*a = \"lalalalala\";\n// Not good. *Might* cause a crash.\n// Perhaps someone can tell me exactly what'll happen?\n</code></pre>\n</hr></hr></hr>", "CommentCount": "2", "PostTypeId": "2", "OwnerUserId": "365102", "CreationDate": "2011-03-19T06:17:25.763"}, "5360539": {"LastActivityDate": "2011-03-19T06:19:16.210", "ParentId": "5360501", "Id": "5360539", "Score": "0", "Body": "<p>Upon object creation, the class members are allocated for that particular object even if you don't use the keyword <code>new</code>, since the object is pointer to class. So your code runs fine and gives you the value of <code>num</code>, but GCC issues a warning because you've not instantiated the object explicitly.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "414749", "CreationDate": "2011-03-19T06:19:16.210"}, "5360548": {"LastActivityDate": "2011-03-19T06:21:33.037", "ParentId": "5360501", "Id": "5360548", "Score": "4", "Body": "<p>The code produces undefined behavior, because it attempts to dereference an uninitialized pointer. Undefined behavior is unpredictable and follows no logic whatsoever. For this reason, any questions about why your code does something or doesn't do something make no sense.</p>\n<p>You are asking why it runs? It doesn't run. It produces <strong>undefined behavior</strong>.</p>\n<p>You are asking how it is assigning 5 to a non-existing member? It doesn't assign anything to anything. It produces <strong>undefined behavior</strong>.</p>\n<p>You are saying the output is <code>5</code>? Wrong. The output is not <code>5</code>. There's no meaningful output. The code produces <strong>undefined behavior</strong>. Just because it somehow happened to print <code>5</code> in your experiment means absolutely nothing and has no meaningful explanation.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "187690", "CreationDate": "2011-03-19T06:21:33.037"}, "5360572": {"LastActivityDate": "2011-03-19T06:31:08.210", "LastEditorUserId": "-1", "ParentId": "5360501", "LastEditDate": "2017-05-23T11:45:30.347", "Id": "5360572", "Score": "0", "Body": "<p>I'll point (hehe) you to a previous answer of mine to a very similar question: <a href=\"https://stackoverflow.com/questions/3382851/tiny-crashing-program/3385137#3385137\">Tiny crashing program</a></p>\n<p>Basically you're overwriting the <code>envs</code> stack variable with your pointer because you haven't added <code>envs</code> to the <code>main</code> declaration. </p>\n<p>Since <code>envs</code> is an array of arrays (strings), it's actually very much allocated, and you're overwriting the first pointer in that list with your <code>5</code>, then reading it again to print with <code>cout</code>.</p>\n<p>Now this is an answer to <strong>why</strong> it happens. You should obviously not <strong>rely</strong> on this.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "108796", "CreationDate": "2011-03-19T06:31:08.210"}});