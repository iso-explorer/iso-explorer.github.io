post_cb({"33971318": {"CommentCount": "6", "AcceptedAnswerId": "33971961", "PostTypeId": "1", "LastEditorUserId": "2692339", "CreationDate": "2015-11-28T12:28:57.043", "LastActivityDate": "2015-11-28T13:58:37.200", "LastEditDate": "2015-11-28T13:58:37.200", "ViewCount": "5244", "FavoriteCount": "1", "Title": "The correct way of returning std::unique_ptr to an object of polymorphic class", "Id": "33971318", "Score": "13", "Body": "<p>Let's say I have the following hierarchy of classes:</p>\n<pre><code>struct Base \n{\n};\n\nstruct Derived : public Base \n{ \n    void DoStuffSpecificToDerivedClass() \n    {\n    } \n};\n</code></pre>\n<p>And the following factory method:</p>\n<pre><code>std::unique_ptr&lt;Base&gt; factoryMethod()\n{\n    auto derived = std::make_unique&lt;Derived&gt;();\n    derived-&gt;DoStuffSpecificToDerivedClass();\n    return derived; // does not compile\n}\n</code></pre>\n<p>The problem is, the <code>return</code> statement does not compile, because <code>std::unique_ptr</code> does not have a copy constructor with covariance support (which makes sense since it does not have any copy constructors), it only has a move constructor with covariance support.</p>\n<p>What is the best way to make solve this problem? I can think of two ways:</p>\n<pre><code>return std::move(derived); // this compiles\nreturn std::unique_ptr&lt;Base&gt;(derived.release()); // and this compiles too\n</code></pre>\n<p><strong>EDIT 1:</strong> I'm using Visual C++ 2013 as my compiler. The original error message for <code>return derived</code> looks like this:</p>\n<pre><code>Error   1   error C2664: 'std::unique_ptr&lt;Base,std::default_delete&lt;_Ty&gt;&gt;::unique_ptr(const std::unique_ptr&lt;_Ty,std::default_delete&lt;_Ty&gt;&gt; &amp;)' : cannot convert argument 1 from 'std::unique_ptr&lt;Derived,std::default_delete&lt;Derived&gt;&gt;' to 'std::unique_ptr&lt;Derived,std::default_delete&lt;Derived&gt;&gt; &amp;&amp;'\n</code></pre>\n<p><strong>EDIT 2:</strong> It is a freshly created console app from a standard VS 2013 template. I haven't tweaked any compiler settings. Compiler command line looks like this:</p>\n<p>Debug:</p>\n<pre><code>/Yu\"stdafx.h\" /GS /analyze- /W3 /Zc:wchar_t /ZI /Gm /Od /sdl /Fd\"Debug\\vc120.pdb\" /fp:precise /D \"WIN32\" /D \"_DEBUG\" /D \"_CONSOLE\" /D \"_LIB\" /D \"_UNICODE\" /D \"UNICODE\" /errorReport:prompt /WX- /Zc:forScope /RTC1 /Gd /Oy- /MDd /Fa\"Debug\\\" /EHsc /nologo /Fo\"Debug\\\" /Fp\"Debug\\CppApplication1.pch\" \n</code></pre>\n<p>Release:</p>\n<pre><code>/Yu\"stdafx.h\" /GS /GL /analyze- /W3 /Gy /Zc:wchar_t /Zi /Gm- /O2 /sdl /Fd\"Release\\vc120.pdb\" /fp:precise /D \"WIN32\" /D \"NDEBUG\" /D \"_CONSOLE\" /D \"_LIB\" /D \"_UNICODE\" /D \"UNICODE\" /errorReport:prompt /WX- /Zc:forScope /Gd /Oy- /Oi /MD /Fa\"Release\\\" /EHsc /nologo /Fo\"Release\\\" /Fp\"Release\\CppApplication1.pch\" \n</code></pre>\n", "Tags": "<c++><smart-pointers><unique-ptr>", "OwnerUserId": "2623942", "AnswerCount": "2"}, "33972072": {"ParentId": "33971318", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-11-28T13:49:29.560", "Score": "5", "LastEditorUserId": "2328763", "LastEditDate": "2015-11-28T13:56:02.993", "Id": "33972072", "OwnerUserId": "2328763", "Body": "<p>As stated in the question, the problem is, the return statement does not compile, <code>std::unique_ptr</code> does not have a copy constructor with covariance support, it only has a move constructor with covariance support, however, compiler still doesn't move from <code>std::unique_ptr&lt;Derived&gt;</code>.</p>\n<p>It is because conditions for moving from an object returned from a function are tied closely to the criteria for copy elision, which strictly requires that type of the object being returned need to be same as the return type of the function.</p>\n<p>[class.copy]/32:</p>\n<blockquote>\n<p id=\"so_33971318_33972072_0\">When the criteria for elision of a copy operation are met or would be\n  met save for the fact that the source object is a function parameter,\n  and the object to be copied is designated by an lvalue, overload\n  resolution to select the constructor for the copy is first performed\n  as if the object were designated by an rvalue.</p>\n</blockquote>\n<p>Therefore, I prefer,</p>\n<pre><code>return std::move(derived);\n</code></pre>\n<p>However, there is rule change in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1579\" rel=\"nofollow\">DR-9R5</a> so that the return value will be treated as an rvalue even when the types are not the same, gcc-5 implemented the rule and you don't need to change your code for gcc-5 as shown <a href=\"https://goo.gl/Jdel6g\" rel=\"nofollow\">here</a>.</p>\n", "LastActivityDate": "2015-11-28T13:56:02.993"}, "33971961": {"ParentId": "33971318", "CommentCount": "2", "Body": "<p>You can do this:</p>\n<pre><code>return std::move(derived);\n</code></pre>\n<p>That way you tell the compiler no copy is needed, which satisfies the requirements of <code>unique_ptr</code>.  If the types matched perfectly you should not need to explicitly specify <code>move</code>, but in this case you do.</p>\n", "OwnerUserId": "4323", "PostTypeId": "2", "Id": "33971961", "Score": "8", "CreationDate": "2015-11-28T13:37:39.763", "LastActivityDate": "2015-11-28T13:37:39.763"}, "bq_ids": {"n4140": {"so_33971318_33972072_0": {"section_id": 481, "quality": 0.6896551724137931, "length": 20}}, "n3337": {"so_33971318_33972072_0": {"section_id": 472, "quality": 1.0, "length": 29}}, "n4659": {"so_33971318_33972072_0": {"section_id": 504, "quality": 0.5517241379310345, "length": 16}}}});