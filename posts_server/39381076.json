post_cb({"40426887": {"ParentId": "39381076", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From n4140</p>\n<p>\u00a7 9.2.2 [class.mem] (<strong>Emphasis</strong> mine)</p>\n<blockquote>\n<p id=\"so_39381076_40426887_0\">A class is considered a completely-defined object type (3.9) (or\n  complete type) at the closing <code>}</code> of the <em>class-specifier</em>. Within the\n  class <em>member-specification</em>, the class is regarded as complete within\n  function bodies, default arguments, using-declarations introducing\n  inheriting constructors (12.9), <em>exception-specifications</em>, and\n  <em>brace-or-equal-initializers</em> for non-static data members (including\n  such things in nested classes). <strong>Otherwise it is regarded as incomplete\n  within its own class <em>member-specification</em></strong>.</p>\n</blockquote>\n<p>Clang and GCC are correct. The class is not considered complete when you are declaring your <code>static constexpr</code> member, so you cannot construct it. This is why moving the definition of <code>Bar</code> out or removing the <code>static constexpr</code> works (because it <em>is</em> considered complete when defining non-static members)</p>\n<hr>\n<p>To clarify, especially considering this question: <a href=\"https://stackoverflow.com/questions/45841822/static-constexpr-member-of-an-inner-class\">Static constexpr member of an inner class</a></p>\n<p>The standardese I quoted above basically means that <em>unless otherwise specified</em> a class is regarded incomplete within itself <sup>*</sup>. A <code>static</code>, <code>constexpr</code>, or <code>static constexpr</code> initializer does not fall under the <em>otherwise specified</em> portion, and therefore we can not use <strong>anything</strong> declared within the class, which includes a nested class type.</p>\n<p><sup>*meaning you can't use it or members of it within the class declaration. The most well known exception to that is within a member function.</sup></p>\n</hr>", "OwnerUserId": "27678", "LastEditorUserId": "27678", "LastEditDate": "2017-08-23T14:56:43.807", "Id": "40426887", "Score": "2", "CreationDate": "2016-11-04T15:51:40.610", "LastActivityDate": "2017-08-23T14:56:43.807"}, "bq_ids": {"n4140": {"so_39381076_40426887_0": {"section_id": 5862, "quality": 0.9761904761904762, "length": 41}, "so_39381076_39381076_1": {"section_id": 6185, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_39381076_40426887_0": {"section_id": 5632, "quality": 0.8809523809523809, "length": 37}, "so_39381076_39381076_1": {"section_id": 5946, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_39381076_40426887_0": {"section_id": 7345, "quality": 0.7619047619047619, "length": 32}, "so_39381076_39381076_0": {"section_id": 180, "quality": 0.5714285714285714, "length": 4}, "so_39381076_39381076_1": {"section_id": 7687, "quality": 0.7142857142857143, "length": 5}}}, "39381076": {"CommentCount": "3", "AcceptedAnswerId": "40426887", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-09-08T01:01:36.070", "LastActivityDate": "2017-08-23T14:56:43.807", "LastEditDate": "2017-05-23T11:54:27.820", "ViewCount": "192", "FavoriteCount": "3", "Title": "Static templated constexpr nested class member", "Id": "39381076", "Score": "10", "Body": "<p>I have the following sample class <code>Foo</code> with nested class <code>Bar</code> and everything is <code>constexpr</code>:</p>\n<pre><code>class Foo\n{\nprivate:\n    template &lt;typename T&gt;\n    struct Bar\n    {\n        constexpr Bar(){}\n        constexpr int DoTheThing() const\n        {\n            return 1;\n        }\n    };\n\npublic:\n    constexpr static auto b = Bar&lt;int&gt;{};\n    constexpr Foo() {}\n    constexpr int DoTheThing() const\n    {\n        return b.DoTheThing();\n    }\n};\n</code></pre>\n<p>And I want to test that calling <code>Foo::DoTheThing</code> returns 1:</p>\n<pre><code>int main()\n{\n   constexpr Foo f;\n   static_assert(f.DoTheThing() == 1, \"DoTheThing() should return 1\");\n}\n</code></pre>\n<p>GCC and Clang both complain here, but MSVC does not</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/8d6a220874473466\" rel=\"nofollow noreferrer\">GCC</a> says:</p>\n<blockquote>\n<p id=\"so_39381076_39381076_0\">error: <code>constexpr Foo::Bar&lt;T&gt;::Bar() [with T = int]</code> used before its definition</p>\n<pre><code>constexpr static auto b = Bar&lt;int&gt;{};\n</code></pre>\n</blockquote>\n<p>And <a href=\"http://coliru.stacked-crooked.com/a/03017f6307e9a89b\" rel=\"nofollow noreferrer\">Clang</a>:</p>\n<blockquote>\n<p id=\"so_39381076_39381076_1\">error: constexpr variable <code>b</code> must be initialized by a constant expression</p>\n<pre><code>constexpr static auto b = Bar&lt;int&gt;{};\n</code></pre>\n</blockquote>\n<p>I cannot tell if the standard disallows this, but my guess is that somehow <code>b</code> is an incomplete type.</p>\n<p>What makes things more interesting is that I can get GCC and Clang to behave if I remove the <code>constexpr</code>, or if I move the definition of <code>Bar</code> outside of <code>Foo</code>.</p>\n<h2>Which of these compilers is correct?</h2>\n<p>Note that this question was inspired by the following:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/39368547/27678\">Simple constexpr LookUpTable in C++14</a> (my problem is one part of this unanswered question's problem)</li>\n<li><a href=\"https://stackoverflow.com/q/16554867/27678\">Nested struct breaks constexpr despite being identical to global ones</a> (this seems to provide some insight into what's going on)</li>\n</ul>\n", "Tags": "<c++><templates><c++14><language-lawyer><constexpr>", "OwnerUserId": "27678", "AnswerCount": "1"}});