post_cb({"bq_ids": {"n4140": {"so_16732788_16732864_5": {"length": 20, "quality": 0.9090909090909091, "section_id": 5804}, "so_16732788_16732864_1": {"length": 33, "quality": 0.8918918918918919, "section_id": 5797}, "so_16732788_16733903_0": {"length": 14, "quality": 1.0, "section_id": 5435}, "so_16732788_16732864_2": {"length": 4, "quality": 0.8, "section_id": 5804}, "so_16732788_16732864_3": {"length": 9, "quality": 1.0, "section_id": 5804}, "so_16732788_16732864_4": {"length": 17, "quality": 1.0, "section_id": 5804}}, "n3337": {"so_16732788_16732864_5": {"length": 20, "quality": 0.9090909090909091, "section_id": 5577}, "so_16732788_16732864_1": {"length": 33, "quality": 0.8918918918918919, "section_id": 5570}, "so_16732788_16733903_0": {"length": 14, "quality": 1.0, "section_id": 5230}, "so_16732788_16732864_2": {"length": 4, "quality": 0.8, "section_id": 5577}, "so_16732788_16732864_3": {"length": 9, "quality": 1.0, "section_id": 5577}, "so_16732788_16732864_4": {"length": 17, "quality": 1.0, "section_id": 5577}}, "n4659": {"so_16732788_16732864_5": {"length": 20, "quality": 0.9090909090909091, "section_id": 7262}, "so_16732788_16732864_1": {"length": 33, "quality": 0.8918918918918919, "section_id": 7256}, "so_16732788_16733903_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 6862}, "so_16732788_16732864_2": {"length": 4, "quality": 0.8, "section_id": 7262}, "so_16732788_16732864_3": {"length": 7, "quality": 0.7777777777777778, "section_id": 7262}, "so_16732788_16732864_4": {"length": 17, "quality": 1.0, "section_id": 7262}}}, "16732864": {"Id": "16732864", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_16732788_16732864_0\">So according to the C++ standard, can compiler eliminates the volatile int c?</p>\n</blockquote>\n<p><strong>No</strong>. <code>volatile</code>-qualified objects are used for reading from or writing to the hardware, and the side-effects of assigning a <code>volatile</code> object are observable.</p>\n<p>Therefore, in compliance with the constraints on optimizations placed by the so-called <a href=\"https://stackoverflow.com/questions/15718262/what-exactly-is-the-as-if-rule\">\"as-if\" rule</a>, conforming implementations are not allowed to optimize away <code>c</code>. The \"<em>as-if</em>\" rule is formally introduced in Paragraph 1.9/1 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16732788_16732864_1\">The semantic descriptions in this International Standard define a parameterized nondeterministic abstract\n  machine. This International Standard places no requirement on the structure of conforming implementations.\n  In particular, they need not copy or emulate the structure of the abstract machine. Rather, conforming\n  implementations are required to emulate (only) the <strong>observable behavior</strong> of the abstract machine as explained\n  below</p>\n</blockquote>\n<p>And the concept of \"<em>observable behavior</em>\" is defined in paragraph 1.9/8:</p>\n<blockquote>\n<p id=\"so_16732788_16732864_2\">The least requirements on a conforming implementation are:</p>\n<p id=\"so_16732788_16732864_3\">\u2014 <strong>Access to volatile objects are evaluated strictly according to the rules of the abstract machine</strong>.</p>\n<p id=\"so_16732788_16732864_4\">\u2014 At program termination, all data written into files shall be identical to one of the possible results that\n  execution of the program according to the abstract semantics would have produced.</p>\n<p id=\"so_16732788_16732864_5\">\u2014 The input and output dynamics of interactive devices shall take place in such a fashion that prompting\n  output is actually delivered before a program waits for input. What constitutes an interactive device\n  is implementation-defined.</p>\n<p id=\"so_16732788_16732864_6\"><strong>These collectively are referred to as the <em>observable behavior</em> of the program</strong>. [...]</p>\n</blockquote>\n<p>Since access to <code>volatile</code> objects must be evaluated strictly according to the rules of the abstract machine, compilers are not allowed to optimize away <code>c</code> and the corresponding assignment operation.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-05-24T10:32:50.360", "Score": "4", "CreationDate": "2013-05-24T10:27:25.363", "ParentId": "16732788", "CommentCount": "0", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T11:50:53.520"}, "16732788": {"ViewCount": "318", "Body": "<p>Say, I have this code:</p>\n<pre><code>int f() {\n  volatile int c;\n  c=34;\n  return abc();\n}\n</code></pre>\n<p>The <strong>volatile int c</strong> is never read.  But it is marked as <strong>volatile</strong>, can the compiler eliminate it altogether?  My testing in Visual C++ 2010 shows contradictory results.  In VC++, if I enable optimization (maximizing speed) the above function contains a local variable called c (by looking at the generated assembly listing).  But, instead of using assignment operator, I also tried to initialize the variable by a compiler intrinsic function like memset() (and enable using compiler intrinsic functions), the variable is eliminated.</p>\n<pre><code>int f() {\n  volatile int c;\n  memset((void*)&amp;c,34, 1); \n  return abc();\n}\n</code></pre>\n<p>So according to the C++ standard, can compiler eliminate the volatile int c? I'm thinking probably there is some inconsistent behaviour in VC++ related to how intrinsic functions optimize volatile variable.</p>\n", "AcceptedAnswerId": "16732864", "Title": "Can a C++ Compiler Eliminate a Volatile Local Var that is not Read", "CreationDate": "2013-05-24T10:23:01.123", "Id": "16732788", "CommentCount": "5", "LastEditDate": "2013-11-29T10:59:48.717", "PostTypeId": "1", "LastEditorUserId": "237575", "LastActivityDate": "2013-11-29T10:59:48.717", "Score": "4", "OwnerUserId": "237575", "Tags": "<c++><visual-c++><c++11><volatile><intrinsics>", "AnswerCount": "2"}, "16733903": {"Id": "16733903", "PostTypeId": "2", "Body": "<p><code>memset((void*)&amp;c,34, 1);</code> has undefined behaviour (\u00a77.1.6.1/6). The compiler is therefore allowed to produce any result.</p>\n<blockquote>\n<p id=\"so_16732788_16733903_0\">If an attempt is made to refer to an object defined with a volatile-qualified type through the use of a glvalue with a non-volatile-qualified type, the program behavior is undefined.</p>\n</blockquote>\n<p>Please, do not use casts like that, much less C-style casts. When one does not know what the correct C++ cast is for a certain situation, it is likely a situation where one should not be casting anything.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-05-24T11:39:59.593", "Score": "7", "CreationDate": "2013-05-24T11:26:51.383", "ParentId": "16732788", "CommentCount": "0", "OwnerUserId": "46642", "LastEditDate": "2013-05-24T11:39:59.593"}});