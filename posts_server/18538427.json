post_cb({"18538525": {"ParentId": "18538427", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2013-08-30T17:34:53.843", "Score": "6", "LastEditorUserId": "1670129", "LastEditDate": "2013-08-30T17:47:43.440", "Id": "18538525", "OwnerUserId": "1670129", "Body": "<p><code>std::string</code> has several constructors capable of being called with one parameter - e.g. one taking <code>const string&amp;</code>, and another taking <code>const char*</code>. What should <code>T</code> resolve to, then?</p>\n<p>From the C++ standard:</p>\n<blockquote>\n<p id=\"so_18538427_18538525_0\">5.2.9p4 Otherwise, an expression e can be explicitly converted to a type <code>T</code> using a <code>static_cast</code> of the form <code>static_cast&lt;T&gt;(e)</code> if the declaration <code>T t(e);</code> is well-formed, for some invented temporary variable <code>t</code>.</p>\n</blockquote>\n<p>In your case, the declaration <code>std::string t(val);</code> is ill-formed.</p>\n", "LastActivityDate": "2013-08-30T17:47:43.440"}, "18538926": {"ParentId": "18538427", "CommentCount": "2", "CreationDate": "2013-08-30T18:01:48.807", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "18538926", "Score": "5", "Body": "<p>Following works with std::string (if you can return a reference).</p>\n<pre><code>static_cast&lt;const std::string&amp;&gt;(val);\n</code></pre>\n", "LastActivityDate": "2013-08-30T18:01:48.807"}, "18538854": {"ParentId": "18538427", "CommentCount": "0", "CreationDate": "2013-08-30T17:57:19.417", "OwnerUserId": "1180785", "PostTypeId": "2", "Id": "18538854", "Score": "6", "Body": "<p>Igor explained the problem. Here's my suggested solution:</p>\n<p>Your class is obviously only intended to store one type of object at a time, so make that explicit. Replace the conversion functions with a real function:</p>\n<pre><code>template &lt;typename T&gt;\nT get() const;\n</code></pre>\n<p>Now call it like this:</p>\n<pre><code>std::string myString = myValue.get&lt;std::string&gt;( );\n</code></pre>\n<p>No ambiguity. No chance of the wrong function being called and messing everything up. And I'd argue that it is now more readable.</p>\n", "LastActivityDate": "2013-08-30T17:57:19.417"}, "bq_ids": {"n4140": {"so_18538427_18538427_1": {"section_id": 3296, "quality": 0.7, "length": 7}, "so_18538427_18538525_0": {"section_id": 6030, "quality": 0.8823529411764706, "length": 15}}, "n3337": {"so_18538427_18538427_1": {"section_id": 3166, "quality": 0.7, "length": 7}, "so_18538427_18538525_0": {"section_id": 5798, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_18538427_18538427_1": {"section_id": 4058, "quality": 0.7, "length": 7}, "so_18538427_18538525_0": {"section_id": 2, "quality": 0.5882352941176471, "length": 10}}}, "18538427": {"CommentCount": "7", "ViewCount": "3700", "CreationDate": "2013-08-30T17:28:24.133", "LastActivityDate": "2013-08-30T18:01:48.807", "Title": "Why is this cast ambiguous?", "AcceptedAnswerId": "18538854", "PostTypeId": "1", "Id": "18538427", "Score": "5", "Body": "<p>I have a class that I have written which does type erasure.  The public interface is:</p>\n<pre><code>template &lt;typename T&gt;\nvalue(const T &amp;t);\n\nvalue(value &amp;&amp;v);\n\ntemplate &lt;typename T&gt;\noperator T() const;\n</code></pre>\n<p>When I create a value instance from a std::string I have no problems, everything works as expected.  When I try to get the std::string back out, using <code>static_cast&lt;std::string&gt;(val)</code>, where <code>val</code> is an instance of value that is holding a std::string, I get the following error from VS2012:</p>\n<blockquote>\n<p id=\"so_18538427_18538427_0\">error C2440: 'static_cast' : cannot convert from 'value' to std::string'</p>\n<p id=\"so_18538427_18538427_1\">No constructor could take the source type, or constructor overload resolution was ambiguous</p>\n</blockquote>\n<p>If I comment out the templated cast operator and add <code>operator std::string() const</code> then it compiles.  I figure that something between the std::string constructors and the templated cast operator have the same goodness of match.  Could anyone suggest what is happening and how to fix it?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "2012007", "AnswerCount": "3"}});