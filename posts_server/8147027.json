post_cb({"39364663": {"ParentId": "8147027", "CommentCount": "1", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass A : public std::enable_shared_from_this&lt;A&gt;\n{\nprivate:\n    A(){}\n    explicit A(int a):m_a(a){}\npublic:\n    template &lt;typename... Args&gt;\n    static std::shared_ptr&lt;A&gt; create(Args &amp;&amp;... args)\n    {\n        class make_shared_enabler : public A\n        {\n        public:\n            make_shared_enabler(Args &amp;&amp;... args):A(std::forward&lt;Args&gt;(args)...){}\n        };\n        return std::make_shared&lt;make_shared_enabler&gt;(std::forward&lt;Args&gt;(args)...);\n    }\n\n    int val() const\n    {\n        return m_a;\n    }\nprivate:\n    int m_a=0;\n};\n\nint main(int, char **)\n{\n    std::shared_ptr&lt;A&gt; a0=A::create();\n    std::shared_ptr&lt;A&gt; a1=A::create(10);\n    std::cout &lt;&lt; a0-&gt;val() &lt;&lt; \" \" &lt;&lt; a1-&gt;val() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "2715075", "PostTypeId": "2", "Id": "39364663", "Score": "-2", "CreationDate": "2016-09-07T08:18:10.807", "LastActivityDate": "2016-09-07T08:18:10.807"}, "25069711": {"ParentId": "8147027", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Possibly the simplest solution. Based on the previous <a href=\"https://stackoverflow.com/a/20961251/850484\">answer</a> by Mohit Aron and incorporating dlf's suggestion.</p>\n<pre><code>#include &lt;memory&gt;\n\nclass A\n{\npublic:\n    static std::shared_ptr&lt;A&gt; create()\n    {\n        struct make_shared_enabler : public A {};\n\n        return std::make_shared&lt;make_shared_enabler&gt;();\n    }\n\nprivate:\n    A() {}  \n};\n</code></pre>\n", "OwnerUserId": "850484", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:40.127", "Id": "25069711", "Score": "38", "CreationDate": "2014-07-31T22:04:49.840", "LastActivityDate": "2014-07-31T22:04:49.840"}, "8147326": {"ParentId": "8147027", "PostTypeId": "2", "CommentCount": "10", "Body": "<p><a href=\"https://stackoverflow.com/questions/8147027/how-do-i-call-stdmake-shared-on-a-class-with-only-protected-or-private-const/8147213#8147213\">This answer</a> is probably better, and the one I'll likely accept. But I also came up with a method that's uglier, but does still let everything still be inline and doesn't require a derived class:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;string&gt;\n\nclass A {\n protected:\n   struct this_is_private;\n\n public:\n   explicit A(const this_is_private &amp;) {}\n   A(const this_is_private &amp;, ::std::string, int) {}\n\n   template &lt;typename... T&gt;\n   static ::std::shared_ptr&lt;A&gt; create(T &amp;&amp;...args) {\n      return ::std::make_shared&lt;A&gt;(this_is_private{0},\n                                   ::std::forward&lt;T&gt;(args)...);\n   }\n\n protected:\n   struct this_is_private {\n       explicit this_is_private(int) {}\n   };\n\n   A(const A &amp;) = delete;\n   const A &amp;operator =(const A &amp;) = delete;\n};\n\n::std::shared_ptr&lt;A&gt; foo()\n{\n   return A::create();\n}\n\n::std::shared_ptr&lt;A&gt; bar()\n{\n   return A::create(\"George\", 5);\n}\n\n::std::shared_ptr&lt;A&gt; errors()\n{\n   ::std::shared_ptr&lt;A&gt; retval;\n\n   // Each of these assignments to retval properly generates errors.\n   retval = A::create(\"George\");\n   retval = new A(A::this_is_private{0});\n   return ::std::move(retval);\n}\n</code></pre>\n<p><strong>Edit 2017-01-06:</strong> I changed this to make it clear that this idea is clearly and simply extensible to constructors that take arguments because other people were providing answers along those lines and seemed confused about this.</p>\n", "OwnerUserId": "167958", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:40.127", "Id": "8147326", "Score": "83", "CreationDate": "2011-11-16T05:53:25.057", "LastActivityDate": "2017-01-06T17:37:24.283"}, "31919820": {"ParentId": "8147027", "CommentCount": "1", "Body": "<p>I realise this thread is rather old, but I found an answer that does not require inheritance or extra arguments to the constructor that I couldn't see elsewhere. It is not portable though:</p>\n<pre><code>#include &lt;memory&gt;\n\n#if defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L\n#define ALLOW_MAKE_SHARED(x) friend void __gnu_cxx::new_allocator&lt;test&gt;::construct&lt;test&gt;(test*);\n#elif defined(_WIN32) || defined(WIN32)\n#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1800\n#define ALLOW_MAKE_SHARED(x) friend class std::_Ref_count_obj;\n#else\n#error msc version does not suport c++11\n#endif\n#else\n#error implement for platform\n#endif\n\nclass test {\n    test() {}\n    ALLOW_MAKE_SHARED(test);\npublic:\n    static std::shared_ptr&lt;test&gt; create() { return std::make_shared&lt;test&gt;(); }\n\n};\nint main() {\n    std::shared_ptr&lt;test&gt; t(test::create());\n}\n</code></pre>\n<p>I have tested on windows and linux, it may need tweaking for different platforms.</p>\n", "OwnerUserId": "274249", "PostTypeId": "2", "Id": "31919820", "Score": "1", "CreationDate": "2015-08-10T12:39:28.217", "LastActivityDate": "2015-08-10T12:39:28.217"}, "41485014": {"ParentId": "8147027", "CommentCount": "0", "Body": "<p>If you also want to enable a constuctor that takes arguments, this may help a bit.</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;utility&gt;\n\ntemplate&lt;typename S&gt;\nstruct enable_make : public S\n{\n    template&lt;typename... T&gt;\n    enable_make(T&amp;&amp;... t)\n        : S(std::forward&lt;T&gt;(t)...)\n    {\n    }\n};\n\nclass foo\n{\npublic:\n    static std::unique_ptr&lt;foo&gt; create(std::unique_ptr&lt;int&gt; u, char const* s)\n    {\n        return std::make_unique&lt;enable_make&lt;foo&gt;&gt;(std::move(u), s);\n    }\nprotected:\n    foo(std::unique_ptr&lt;int&gt; u, char const* s)\n    {\n    }\n};\n\nvoid test()\n{\n    auto fp = foo::create(std::make_unique&lt;int&gt;(3), \"asdf\");\n}\n</code></pre>\n", "OwnerUserId": "4882811", "PostTypeId": "2", "Id": "41485014", "Score": "2", "CreationDate": "2017-01-05T12:22:27.080", "LastActivityDate": "2017-01-05T12:22:27.080"}, "11344174": {"ParentId": "8147027", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Since I didn't like the already provided answers I decided to search on and found a solution that is not as generic as the previous answers but I like it better(tm). In retrospect it is not much nicer than the one provided by Omnifarius but there could be other people who like it too :)</p>\n<p>This is not invented by me, but it is the idea of Jonathan Wakely (GCC developer). </p>\n<p>Unfortunately it does not work with all the compilers because it relies on a small change in std::allocate_shared implementation. But this change is now a proposed update for the standard libraries, so it might get supported by all the compilers in the future. It works on GCC 4.7.</p>\n<p>C++ standard Library Working Group change request is here:\n<a href=\"http://lwg.github.com/issues/lwg-active.html#2070\" rel=\"noreferrer\">http://lwg.github.com/issues/lwg-active.html#2070</a></p>\n<p>The GCC patch with an example usage is here:\n<a href=\"http://old.nabble.com/Re%3A--v3--Implement-pointer_traits-and-allocator_traits-p31723738.html\" rel=\"noreferrer\">http://old.nabble.com/Re%3A--v3--Implement-pointer_traits-and-allocator_traits-p31723738.html</a></p>\n<p>The solution works on the idea to use std::allocate_shared (instead of std::make_shared) with a custom allocator that is declared friend to the class with the private constructor.</p>\n<p>The example from the OP would look like this:</p>\n<pre><code>#include &lt;memory&gt;\n\ntemplate&lt;typename Private&gt;\nstruct MyAlloc : std::allocator&lt;Private&gt;\n{\n    void construct(void* p) { ::new(p) Private(); }\n};\n\nclass A {\n    public:\n        static ::std::shared_ptr&lt;A&gt; create() {\n            return ::std::allocate_shared&lt;A&gt;(MyAlloc&lt;A&gt;());\n        }\n\n    protected:\n        A() {}\n        A(const A &amp;) = delete;\n        const A &amp;operator =(const A &amp;) = delete;\n\n        friend struct MyAlloc&lt;A&gt;;\n};\n\nint main() {\n    auto p = A::create();\n    return 0;\n}\n</code></pre>\n<p>A more complex example that is based on the utility I'm working on. With this I could not use Luc's solution. But the one by Omnifarius could be adapted. Not that while in the previous example everybody can create an A object using the MyAlloc in this one there is not way to create A or B besides the create() method.</p>\n<pre><code>#include &lt;memory&gt;\n\ntemplate&lt;typename T&gt;\nclass safe_enable_shared_from_this : public std::enable_shared_from_this&lt;T&gt;\n{\n    public:\n    template&lt;typename... _Args&gt;\n        static ::std::shared_ptr&lt;T&gt; create(_Args&amp;&amp;... p_args) {\n            return ::std::allocate_shared&lt;T&gt;(Alloc(), std::forward&lt;_Args&gt;(p_args)...);\n        }\n\n    protected:\n    struct Alloc : std::allocator&lt;T&gt;\n    {  \n        template&lt;typename _Up, typename... _Args&gt;\n        void construct(_Up* __p, _Args&amp;&amp;... __args)\n        { ::new((void *)__p) _Up(std::forward&lt;_Args&gt;(__args)...); }\n    };\n    safe_enable_shared_from_this(const safe_enable_shared_from_this&amp;) = delete;\n    safe_enable_shared_from_this&amp; operator=(const safe_enable_shared_from_this&amp;) = delete;\n};\n\nclass A : public safe_enable_shared_from_this&lt;A&gt; {\n    private:\n        A() {}\n        friend struct safe_enable_shared_from_this&lt;A&gt;::Alloc;\n};\n\nclass B : public safe_enable_shared_from_this&lt;B&gt; {\n    private:\n        B(int v) {}\n        friend struct safe_enable_shared_from_this&lt;B&gt;::Alloc;\n};\n\nint main() {\n    auto a = A::create();\n    auto b = B::create(5);\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "338725", "LastEditorUserId": "338725", "LastEditDate": "2012-07-05T12:34:30.447", "Id": "11344174", "Score": "6", "CreationDate": "2012-07-05T12:16:24.807", "LastActivityDate": "2012-07-05T12:34:30.447"}, "27832765": {"ParentId": "8147027", "PostTypeId": "2", "CommentCount": "2", "Body": "<pre><code>struct A {\npublic:\n  template&lt;typename ...Arg&gt; std::shared_ptr&lt;A&gt; static create(Arg&amp;&amp;...arg) {\n    struct EnableMakeShared : public A {\n      EnableMakeShared(Arg&amp;&amp;...arg) :A(std::forward&lt;Arg&gt;(arg)...) {}\n    };\n    return std::make_shared&lt;EnableMakeShared&gt;(std::forward&lt;Arg&gt;(arg)...);\n  }\n  void dump() const {\n    std::cout &lt;&lt; a_ &lt;&lt; std::endl;\n  }\nprivate:\n  A(int a) : a_(a) {}\n  A(int i, int j) : a_(i + j) {}\n  A(std::string const&amp; a) : a_(a.size()) {}\n  int a_;\n};\n</code></pre>\n", "OwnerUserId": "3480968", "LastEditorUserId": "3480968", "LastEditDate": "2015-01-08T06:24:17.563", "Id": "27832765", "Score": "6", "CreationDate": "2015-01-08T04:07:44.300", "LastActivityDate": "2015-01-08T06:24:17.563"}, "33037214": {"ParentId": "8147027", "CommentCount": "1", "Body": "<p>You can use this:</p>\n<pre><code>class CVal\n{\n    friend std::shared_ptr&lt;CVal&gt;;\n    friend std::_Ref_count&lt;CVal&gt;;\npublic:\n    static shared_ptr&lt;CVal&gt; create()\n    {\n        shared_ptr&lt;CVal&gt; ret_sCVal(new CVal());\n        return ret_sCVal;\n    }\n\nprotected:\n    CVal() {};\n    ~CVal() {};\n};\n</code></pre>\n", "OwnerUserId": "5427377", "PostTypeId": "2", "Id": "33037214", "Score": "-3", "CreationDate": "2015-10-09T11:31:11.140", "LastActivityDate": "2015-10-09T11:31:11.140"}, "bq_ids": {"n4140": {"so_8147027_8147213_0": {"section_id": 4438, "quality": 0.7916666666666666, "length": 19}}, "n3337": {"so_8147027_8147213_0": {"section_id": 4275, "quality": 0.7916666666666666, "length": 19}}, "n4659": {"so_8147027_8147213_0": {"section_id": 5703, "quality": 0.8333333333333334, "length": 20}}}, "20230035": {"ParentId": "8147027", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There's a more hairy and interesting problem that happens when you have two strictly related classes A and B that work together.</p>\n<p>Say A is the \"master class\" and B its \"slave\".  If you want to restrict instantiation of B only to A, you'd make B's constructor private, and friend B to A like this</p>\n<pre><code>class B\n{\npublic:\n    // B your methods...\n\nprivate:\n    B();\n    friend class A;\n};\n</code></pre>\n<p>Unfortunately calling <code>std::make_shared&lt;B&gt;()</code> from a method of <code>A</code> will make the compiler complain about <code>B::B()</code> being private.</p>\n<p>My solution to this is to create a public <code>Pass</code> dummy class (just like <code>nullptr_t</code>) inside <code>B</code> that has private constructor and is friend with <code>A</code> and make <code>B</code>'s constructor public and add <code>Pass</code> to its arguments, like this.</p>\n<pre><code>class B\n{\npublic:\n  class Pass\n  {\n    Pass() {}\n    friend class A;\n  };\n\n  B(Pass, int someArgument)\n  {\n  }\n};\n\nclass A\n{\npublic:\n  A()\n  {\n    // This is valid\n    auto ptr = std::make_shared&lt;B&gt;(B::Pass(), 42);\n  }\n};\n\nclass C\n{\npublic:\n  C()\n  {\n    // This is not\n    auto ptr = std::make_shared&lt;B&gt;(B::Pass(), 42);\n  }\n};\n</code></pre>\n", "OwnerUserId": "1191954", "LastEditorUserId": "1191954", "LastEditDate": "2013-11-26T23:24:01.570", "Id": "20230035", "Score": "1", "CreationDate": "2013-11-26T23:18:02.790", "LastActivityDate": "2013-11-26T23:24:01.570"}, "20961251": {"ParentId": "8147027", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Here's a neat solution for this:</p>\n<pre><code>#include &lt;memory&gt;\n\nclass A {\n   public:\n     static shared_ptr&lt;A&gt; Create();\n\n   private:\n     A() {}\n\n     struct MakeSharedEnabler;   \n };\n\nstruct A::MakeSharedEnabler : public A {\n    MakeSharedEnabler() : A() {\n    }\n};\n\nshared_ptr&lt;A&gt; A::Create() {\n    return make_shared&lt;MakeSharedEnabler&gt;();\n}\n</code></pre>\n", "OwnerUserId": "3167241", "LastEditorUserId": "398248", "LastEditDate": "2017-06-23T14:21:26.947", "Id": "20961251", "Score": "12", "CreationDate": "2014-01-06T23:30:21.623", "LastActivityDate": "2017-06-23T14:21:26.947"}, "8147101": {"ParentId": "8147027", "CommentCount": "3", "Body": "<p>How about this?</p>\n<pre><code>static std::shared_ptr&lt;A&gt; create()\n{\n    std::shared_ptr&lt;A&gt; pA(new A());\n    return pA;\n}\n</code></pre>\n", "OwnerUserId": "609263", "PostTypeId": "2", "Id": "8147101", "Score": "5", "CreationDate": "2011-11-16T05:21:52.200", "LastActivityDate": "2011-11-16T05:21:52.200"}, "8147213": {"ParentId": "8147027", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Looking at the requirements for <code>std::make_shared</code> in 20.7.2.2.6 shared_ptr creation [util.smartptr.shared.create], paragraph 1:</p>\n<blockquote>\n<p id=\"so_8147027_8147213_0\"><em>Requires:</em> The expression <code>::new (pv) T(std::forward&lt;Args&gt;(args)...)</code>, where <code>pv</code> has type <code>void*</code> and points to storage suitable to hold an object of type <code>T</code>, shall be well formed. <code>A</code> shall be an allocator (17.6.3.5). The copy constructor and destructor of <code>A</code> shall not throw exceptions.</p>\n</blockquote>\n<p>Since the requirement is unconditionally specified in terms of that expression and things like scope aren't taken into account, I think tricks like friendship are right out.</p>\n<p>A simple solution is to derive from <code>A</code>. This needn't require making <code>A</code> an interface or even a polymorphic type.</p>\n<pre><code>// interface in header\nstd::shared_ptr&lt;A&gt; make_a();\n\n// implementation in source\nnamespace {\n\nstruct concrete_A: public A {};\n\n} // namespace\n\nstd::shared_ptr&lt;A&gt;\nmake_a()\n{\n    return std::make_shared&lt;concrete_A&gt;();\n}\n</code></pre>\n", "OwnerUserId": "726300", "LastEditorUserId": "743382", "LastEditDate": "2015-01-08T07:04:42.413", "Id": "8147213", "Score": "53", "CreationDate": "2011-11-16T05:39:40.447", "LastActivityDate": "2015-01-08T07:04:42.413"}, "8147027": {"CommentCount": "2", "AcceptedAnswerId": "8147326", "CreationDate": "2011-11-16T05:11:36.480", "LastActivityDate": "2017-08-22T16:18:01.713", "PostTypeId": "1", "ViewCount": "32872", "FavoriteCount": "37", "Title": "How do I call ::std::make_shared on a class with only protected or private constructors?", "Id": "8147027", "Score": "111", "Body": "<p>I have this code that doesn't work, but I think the intent is clear:</p>\n<p><em>testmakeshared.cpp</em></p>\n<pre><code>#include &lt;memory&gt;\n\nclass A {\n public:\n   static ::std::shared_ptr&lt;A&gt; create() {\n      return ::std::make_shared&lt;A&gt;();\n   }\n\n protected:\n   A() {}\n   A(const A &amp;) = delete;\n   const A &amp;operator =(const A &amp;) = delete;\n};\n\n::std::shared_ptr&lt;A&gt; foo()\n{\n   return A::create();\n}\n</code></pre>\n<p>But I get this error when I compile it:</p>\n<pre><code>g++ -std=c++0x -march=native -mtune=native -O3 -Wall testmakeshared.cpp\nIn file included from /usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr.h:52:0,\n                 from /usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/memory:86,\n                 from testmakeshared.cpp:1:\ntestmakeshared.cpp: In constructor \u2018std::_Sp_counted_ptr_inplace&lt;_Tp, _Alloc, _Lp&gt;::_Sp_counted_ptr_inplace(_Alloc) [with _Tp = A, _Alloc = std::allocator&lt;A&gt;, __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u]\u2019:\n/usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr_base.h:518:8:   instantiated from \u2018std::__shared_count&lt;_Lp&gt;::__shared_count(std::_Sp_make_shared_tag, _Tp*, const _Alloc&amp;, _Args&amp;&amp; ...) [with _Tp = A, _Alloc = std::allocator&lt;A&gt;, _Args = {}, __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u]\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr_base.h:986:35:   instantiated from \u2018std::__shared_ptr&lt;_Tp, _Lp&gt;::__shared_ptr(std::_Sp_make_shared_tag, const _Alloc&amp;, _Args&amp;&amp; ...) [with _Alloc = std::allocator&lt;A&gt;, _Args = {}, _Tp = A, __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u]\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr.h:313:64:   instantiated from \u2018std::shared_ptr&lt;_Tp&gt;::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&amp;, _Args&amp;&amp; ...) [with _Alloc = std::allocator&lt;A&gt;, _Args = {}, _Tp = A]\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr.h:531:39:   instantiated from \u2018std::shared_ptr&lt;_Tp&gt; std::allocate_shared(const _Alloc&amp;, _Args&amp;&amp; ...) [with _Tp = A, _Alloc = std::allocator&lt;A&gt;, _Args = {}]\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr.h:547:42:   instantiated from \u2018std::shared_ptr&lt;_Tp1&gt; std::make_shared(_Args&amp;&amp; ...) [with _Tp = A, _Args = {}]\u2019\ntestmakeshared.cpp:6:40:   instantiated from here\ntestmakeshared.cpp:10:8: error: \u2018A::A()\u2019 is protected\n/usr/lib/gcc/x86_64-redhat-linux/4.6.1/../../../../include/c++/4.6.1/bits/shared_ptr_base.h:400:2: error: within this context\n\nCompilation exited abnormally with code 1 at Tue Nov 15 07:32:58\n</code></pre>\n<p>This message is basically saying that some random method way down in the template instantiation stack from <code>::std::make_shared</code> can't access the constructor because it's protected.</p>\n<p>But I really want to use both <code>::std::make_shared</code> and prevent anybody from making an object of this class that isn't pointed at by a <code>::std::shared_ptr</code>. Is there any way to accomplish this?</p>\n", "Tags": "<c++><c++11><shared-ptr>", "OwnerUserId": "167958", "AnswerCount": "13"}, "45822653": {"ParentId": "8147027", "CommentCount": "1", "Body": "<p>I've come up with this kind of template which overcomes problem of protected constructors quite nicely:</p>\n<pre><code>// helper template not used directly in code:\ntemplate&lt;typename T&gt;\nstruct CHelpExposeProtectedConstructor : public T\n{\n    template&lt;typename...Args&gt;\n    CHelpExposeProtectedConstructor(Args...args)\n        : T(std::forward&lt;Args&gt;(args)...)\n    {}\n};\n\n/**\n * this uses std::make_shared on classes which have protected constructors\n */\ntemplate&lt;typename T, typename...Args&gt;\nauto MakeSharedFromProtected(Args...args) -&gt; std::shared_ptr&lt;T&gt;\n{\n    return std::make_shared&lt;CHelpExposeProtectedConstructor&lt;T&gt;&gt;(std::forward&lt;Args&gt;(args)...);\n}\n</code></pre>\n<p>Than just use <code>MakeSharedFromProtected</code> instead <code>make_shared</code> and problem solved.</p>\n<p>Sadly this doesn't help in case of private constructors.</p>\n", "OwnerUserId": "1387438", "PostTypeId": "2", "Id": "45822653", "Score": "0", "CreationDate": "2017-08-22T16:18:01.713", "LastActivityDate": "2017-08-22T16:18:01.713"}});