post_cb({"bq_ids": {"n4140": {"so_38443403_38443541_1": {"length": 22, "quality": 0.9166666666666666, "section_id": 37}}, "n3337": {"so_38443403_38443541_1": {"length": 22, "quality": 0.9166666666666666, "section_id": 34}}, "n4659": {"so_38443403_38443541_1": {"length": 20, "quality": 0.8333333333333334, "section_id": 37}}}, "38443490": {"Id": "38443490", "PostTypeId": "2", "Body": "<p>On a 64 but platform gcc gives long 64 bits, and visual studio gives it 32 bits.</p>\n", "LastActivityDate": "2016-07-18T18:18:48.360", "CommentCount": "0", "CreationDate": "2016-07-18T18:18:48.360", "ParentId": "38443403", "Score": "-1", "OwnerUserId": "362589"}, "38443403": {"ViewCount": "61", "Body": "<p>For the following code <code>lval</code> is computed to be a different value on VS and gcc. </p>\n<p><strong>Code :</strong> </p>\n<pre><code>const double val = std::numeric_limits&lt;double&gt;::max();\nconst unsigned long lval = (std::numeric_limits&lt;decltype(val)&gt;::infinity() == val || (static_cast&lt;unsigned long&gt;(val) &gt;= 2)) ?\n    std::numeric_limits&lt;unsigned long&gt;::max() :\n    999;\ncout &lt;&lt; lval;\n</code></pre>\n<p><strong>On Visual Studio</strong></p>\n<p><code>lval</code> is computed to be 999</p>\n<p><a href=\"http://rextester.com/EMFL77801\" rel=\"nofollow\">http://rextester.com/EMFL77801</a></p>\n<p><strong>On g++</strong></p>\n<p><code>lval</code> is computed to be 18446744073709551615</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/682c81bbe498ddc5\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/682c81bbe498ddc5</a></p>\n<p><strong>Question</strong></p>\n<p>Why are these two values different?</p>\n<p><strong>Furthermore</strong></p>\n<p>I tried the same code in stand-alone gcc, and put a breakpoint in gdb. I saw that <code>static_cast&lt;unsigned long&gt;(val) &gt;= 2</code> evaluated to <code>true</code> on gdb, but the same expression evaluated to be <code>false</code> in VS </p>\n", "AcceptedAnswerId": "38443541", "Title": "Different value computed on VS and gcc", "CreationDate": "2016-07-18T18:13:43.133", "Id": "38443403", "CommentCount": "1", "LastEditDate": "2016-07-18T18:30:44.340", "PostTypeId": "1", "LastEditorUserId": "3670482", "LastActivityDate": "2016-07-18T18:30:44.340", "Score": "1", "OwnerUserId": "3670482", "Tags": "<c++><c++11><gcc><visual-c++>", "AnswerCount": "2"}, "38443541": {"Id": "38443541", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_38443403_38443541_0\">\u00a7 4.9.1 Floating-integral conversions</p>\n<p id=\"so_38443403_38443541_1\">A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates;\n  that is, the fractional part is discarded. <strong>The behavior is undefined if the truncated value cannot be\n  represented in the destination type.</strong></p>\n</blockquote>\n<p><code>std::numeric_limits&lt;double&gt;::max()</code> can't fit into an <code>unsigned long</code> so the behavior is undefined and the compiler can do whatever it wants. </p>\n<p>Apparently in the visual studio case <code>static_cast&lt;unsigned long&gt;(val) &gt;= 2</code> returns false.</p>\n", "LastEditorUserId": "1020484", "LastActivityDate": "2016-07-18T18:27:07.460", "Score": "4", "CreationDate": "2016-07-18T18:21:29.943", "ParentId": "38443403", "CommentCount": "0", "OwnerUserId": "1020484", "LastEditDate": "2016-07-18T18:27:07.460"}});