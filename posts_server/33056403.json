post_cb({"bq_ids": {"n4140": {"so_33056403_33056605_3": {"length": 43, "quality": 0.9148936170212766, "section_id": 5913}, "so_33056403_33056605_2": {"length": 43, "quality": 0.9148936170212766, "section_id": 5913}}, "n3337": {"so_33056403_33056605_3": {"length": 34, "quality": 0.723404255319149, "section_id": 5685}, "so_33056403_33056605_2": {"length": 34, "quality": 0.723404255319149, "section_id": 5685}}, "n4659": {"so_33056403_33056605_3": {"length": 26, "quality": 0.5531914893617021, "section_id": 7405}, "so_33056403_33056605_2": {"length": 26, "quality": 0.5531914893617021, "section_id": 7405}}}, "33056605": {"Id": "33056605", "PostTypeId": "2", "Body": "<p>All members of a union must reside at the same address, that is guaranteed by the standard. What you are doing is indeed <em>well-defined</em> behavior, but it shall be noted that you cannot read from an <em>inactive</em> member of a union using the same approach.</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/11373203/1090079\">Accessing inactive union member - undefined behavior?</a></li>\n</ul>\n<blockquote>\n<p id=\"so_33056403_33056605_0\"><sub><strong>Note</strong>: Do not use c-style casts, prefer <code>reinterpret_cast</code> in this case.</sub></p>\n</blockquote>\n<hr>\n<p>As long as all you do is <strong>write</strong> to the other data-member of the <code>union</code>, the behavior is well-defined; but as stated this changes which is considered to be the <em>active</em> member of the <code>union</code>; meaning that you can later only read from that you just wrote to.</p>\n<pre><code>union U {\n    int a;\n    float b;\n};\n\nint main () {\n    U u;\n    int *p = &amp;u.a;\n    reinterpret_cast&lt;float*&gt; (p) = 1.0f; // ok, well-defined\n}\n</code></pre>\n<blockquote>\n<p id=\"so_33056403_33056605_1\"><sub><strong>Note</strong>: There is an exception to the above rule when it comes to <em>layout-compatible</em> types.</sub></p>\n</blockquote>\n<hr>\n<p>The question can be rephrased into the following snippet which is semantically equivalent to a boiled down version of the \"problem\".</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n\nint main () {\n  using union_storage_t = std::aligned_storage&lt;\n    std::max ( sizeof(int),   sizeof(float)),\n    std::max (alignof(int),  alignof(float))\n  &gt;::type;\n\n  union_storage_t u;\n\n  int   * p1 = reinterpret_cast&lt;  int*&gt; (&amp;u);\n  float * p2 = reinterpret_cast&lt;float*&gt; (p1);\n  float * p3 = reinterpret_cast&lt;float*&gt; (&amp;u);\n\n  assert (p2 == p3); // will never fire\n}\n</code></pre>\n<hr>\n<h3>What does the Standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\"><code>n3797</code></a>) say?</h3>\n<blockquote>\n<pre><code>9.5/1    <b>Unions</b>    [class.union]</code></pre>\n<blockquote>\n<p id=\"so_33056403_33056605_3\">In a union, at most one of the non-static data members can be\n    active at any time, that is, the value of at most one of the \n    non-static dat amembers ca nbe stored in a union at any time.\n    [...] The size of a union is sufficient to contain the largest of\n    its non-static data members. Each non-static data member is\n    allocated as if it were the sole member of a struct. All non-static data members of a union object have the same address.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p id=\"so_33056403_33056605_4\"><sub><strong>Note</strong>: The wording in C++11 (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\"><strong>n3337</strong></a>) was underspecified, even though the intent has always been that of C++14.</sub></p>\n</blockquote>\n</hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-10T17:58:09.020", "Score": "5", "CreationDate": "2015-10-10T17:03:04.997", "ParentId": "33056403", "CommentCount": "8", "OwnerUserId": "1090079", "LastEditDate": "2017-05-23T11:46:36.667"}, "33056579": {"Id": "33056579", "PostTypeId": "2", "Body": "<p>Yes, it is legal.  Using explicit casts, you can do almost anything.</p>\n<p>As other comments have stated, all members in a <code>union</code> start at the same address / location so casting a pointer to a different member is pointless.  </p>\n<p>The assembly language will be the same.  You want to make the code easy to read so I don't recommend the practice.  It is confusing and there is no benefit.  </p>\n<p>Also, I recommend a \"type\" field so that you know when the data is in <code>float</code> format versus <code>int</code> format.</p>\n", "LastActivityDate": "2015-10-10T17:00:55.093", "CommentCount": "0", "CreationDate": "2015-10-10T17:00:55.093", "ParentId": "33056403", "Score": "3", "OwnerUserId": "225074"}, "33056403": {"ViewCount": "426", "Body": "<p>Consider following code:</p>\n<pre><code>union U\n{\n    int a;\n    float b;\n};\n\nint main()\n{\n    U u;\n    int *p = &amp;u.a;\n    *(float *)p = 1.0f; // &lt;-- this line\n}\n</code></pre>\n<p>We all know that addresses of union fields are usually same, but I'm not sure is it well-defined behavior to do something like this.</p>\n<p>So, question is: <strong>Is it legal and well-defined behavior to cast and dereference a pointer to union field like in the code above?</strong></p>\n<hr>\n<p>P.S. I know that it's more C than C++, but I'm trying to understand if it's legal in C++, not C.</p>\n</hr>", "AcceptedAnswerId": "33056605", "Title": "Is it legal to use address of one field of a union to access another field?", "CreationDate": "2015-10-10T16:44:31.470", "Id": "33056403", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-10-10T17:58:09.020", "Score": "9", "OwnerUserId": "2752075", "Tags": "<c++>", "AnswerCount": "2"}});