post_cb({"38677337": {"Id": "38677337", "PostTypeId": "2", "Body": "<p>The reference you cited is pretty clear: you can't move reads before this load. In your example:</p>\n<pre><code>static std::atomic&lt;int&gt; X;\nstatic int L;\n\n\nvoid thread_func() \n{\n    int local1 = L;  // (1)\n    int x_local = X.load(std::memory_order_acquire);  // (2)\n    int local2 = L;  // (3)\n}\n</code></pre>\n<p><code>memory_order_acquire</code> means that (3) cannot happen before (2) (the load in (2) is sequenced before thr load in (3)). It says nothing about the relationship between (1) and (2).</p>\n", "LastActivityDate": "2016-07-30T18:40:40.243", "CommentCount": "7", "CreationDate": "2016-07-30T18:40:40.243", "ParentId": "38677061", "Score": "3", "OwnerUserId": "2069064"}, "bq_ids": {"n4140": {"so_38677061_38680364_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 1149}}, "n3337": {"so_38677061_38680364_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 1146}}, "n4659": {"so_38677061_38680364_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 1243}}}, "38680364": {"Id": "38680364", "PostTypeId": "2", "Body": "<p>I believe this is the correct way to reason about your example within the C++ standard:</p>\n<ol>\n<li><code>X.load(std::memory_order_acquire)</code> (let's call it \"operation <code>(A)</code>\") may synchronize with a certain release operation on <code>X</code> (operation <code>(R)</code>) - roughly, the operation that assigned the value to <code>X</code> that <code>(A)</code> is reading.</li>\n</ol>\n<blockquote>\n<p id=\"so_38677061_38680364_0\"><strong>[atomics.order]/2</strong> An atomic operation <code>A</code> that performs a release operation on an atomic object <code>M</code> synchronizes with an atomic\n  operation <code>B</code> that performs an acquire operation on <code>M</code> and takes its value from any side effect in the release sequence headed by <code>A</code>.</p>\n</blockquote>\n<ol start=\"2\">\n<li><p>This synchronizes-with relationship may help establish a happens-before relationship between some modification of <code>L</code> and the assignment <code>local2 = L</code>. If that modification of <code>L</code> happens-before <code>(R)</code>, then, due to the fact that <code>(R)</code> synchronizes-with <code>(A)</code> and <code>(A)</code> is sequenced-before the read of <code>L</code>, that modification of <code>L</code> happens-before this read of <code>L</code>.</p></li>\n<li><p>But <code>(A)</code> has no effect whatsoever on the assignment <code>local1 = L</code>. It neither causes data races involving this assignment, nor helps prevent them. If the program is race-free, then it must necessarily employ some other mechanism to ensure that modifications of <code>L</code> are synchronized with this read (and if it's not race-free, then it exhibits undefined behavior and the standard has nothing further to say about it).</p></li>\n</ol>\n<hr>\n<p>It is meaningless to talk about \"instruction reordering\" within the four corners of the C++ standard. One may talk about machine instructions generated by a particular compiler, or the way those instructions are executed by a particular CPU. But from the standard's standpoint, these are merely irrelevant implementation details, as long as that compiler and that CPU produce observable behavior consistent with one possible execution path of an abstract machine described by the standard (<a href=\"https://en.wikipedia.org/wiki/As-if_rule\" rel=\"nofollow\">the As-If rule</a>).</p>\n</hr>", "LastActivityDate": "2016-07-31T03:02:21.603", "CommentCount": "0", "CreationDate": "2016-07-31T03:02:21.603", "ParentId": "38677061", "Score": "3", "OwnerUserId": "1670129"}, "38677061": {"ViewCount": "155", "Body": "<p>As known in since C++11 there are 6 memory orders, and in documentation written about <code>std::memory_order_acquire</code>:</p>\n<ul>\n<li><a href=\"http://en.cppreference.com/w/cpp/atomic/memory_order\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/atomic/memory_order</a></li>\n</ul>\n<blockquote>\n<p id=\"so_38677061_38677061_0\">memory_order_acquire  </p>\n<p id=\"so_38677061_38677061_1\">A load operation with this memory order performs the acquire operation\n  on the affected memory location: no memory accesses in the current\n  thread can be reordered before this load. This ensures that all writes\n  in other threads that release the same atomic variable are visible in\n  the current thread.</p>\n</blockquote>\n<p><strong>1. Non-atomic-load can be reordered after atomic-acquire-load:</strong></p>\n<p>I.e. it does not guarantee that non-atomic-load can not be reordered after acquire-atomic-load.</p>\n<pre><code>static std::atomic&lt;int&gt; X;\nstatic int L;\n...\n\nvoid thread_func() \n{\n    int local1 = L;  // load(L)-load(X) - can be reordered with X ?\n\n    int x_local = X.load(std::memory_order_acquire);  // load(X)\n\n    int local2 = L;  // load(X)-load(L) - can't be reordered with X\n}\n</code></pre>\n<p>Can load <code>int local1 = L;</code> be reordered after <code>X.load(std::memory_order_acquire);</code>?</p>\n<p><strong>2. We can think that non-atomic-load can not be reordered after atomic-acquire-load:</strong></p>\n<p>Some articles contained a picture showing the essence of acquire-release semantics. That is easy to understand, but can cause confusion.</p>\n<p><a href=\"https://i.stack.imgur.com/a4Zxw.jpg\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/a4Zxw.jpg\"/></a></p>\n<p><a href=\"https://i.stack.imgur.com/GkGi8.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/GkGi8.png\"/></a></p>\n<p>For example, we may think that <code>std::memory_order_acquire</code> can't reorder any series of Load-Load operations, even non-atomic-load can't be reordered after atomic-acquire-load. </p>\n<p><strong>3. Non-atomic-load can be reordered after atomic-acquire-load:</strong></p>\n<p>Good thing that there is clarified: Acquire semantics prevent memory reordering of the read-acquire with any <strong>read</strong> or write operation <strong>which follows it in program order</strong>. <a href=\"http://preshing.com/20120913/acquire-and-release-semantics/\" rel=\"nofollow noreferrer\">http://preshing.com/20120913/acquire-and-release-semantics/</a></p>\n<p>But also <a href=\"http://en.cppreference.com/w/cpp/atomic/memory_order\" rel=\"nofollow noreferrer\">known, that</a>: On strongly-ordered systems (<strong>x86</strong>, SPARC TSO, IBM mainframe), <strong>release-acquire ordering is automatic</strong> for the majority of operations. </p>\n<p>And Herb Sutter on page 34 shows: <a href=\"https://onedrive.live.com/view.aspx?resid=4E86B0CF20EF15AD!24884&amp;app=WordPdf&amp;authkey=!AMtj_EflYn2507c\" rel=\"nofollow noreferrer\">https://onedrive.live.com/view.aspx?resid=4E86B0CF20EF15AD!24884&amp;app=WordPdf&amp;authkey=!AMtj_EflYn2507c</a></p>\n<p><a href=\"https://i.stack.imgur.com/RNc9M.jpg\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/RNc9M.jpg\"/></a></p>\n<p><strong>4. I.e. again, we can think that non-atomic-load can not be reordered after atomic-acquire-load:</strong></p>\n<p>I.e. for x86:</p>\n<ul>\n<li>release-<strong>acquire</strong> ordering is automatic for the majority of operations</li>\n<li>Reads are not reordered with <strong>any</strong> reads. (any - i.e. regardless of older or not) </li>\n</ul>\n<p>So can non-atomic-load be reordered after atomic-acquire-load in C++11?</p>\n", "AcceptedAnswerId": "38677337", "Title": "Can non-atomic-load be reordered after atomic-acquire-load?", "CreationDate": "2016-07-30T18:13:24.803", "Id": "38677061", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-07-31T03:02:21.603", "Score": "1", "OwnerUserId": "1558037", "Tags": "<c++><multithreading><c++11><concurrency><memory-fences>", "AnswerCount": "2"}});