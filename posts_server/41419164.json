post_cb({"41419564": {"ParentId": "41419164", "CommentCount": "0", "Body": "<p>Type aliasing (use of more then one type for essentially the same data) is a huge problem in C++. If you keep member functions out of structs and maintain them as PODs, things ought to work. But</p>\n<pre><code>  static_assert(sizeof(vec) == sizeof(float) * 3);\n</code></pre>\n<p>can't make accessing one type as another technically legal. In practice of course there will be no padding, but C++ isn't clever enough to realise that vec is an array of floats and an array of vecs is an array of floats constrained to be a multiple of three, and the casting &amp;vecasarray[0] to a vec * is legal but casting &amp;vecasarray[1] is illegal.</p>\n", "OwnerUserId": "3310281", "PostTypeId": "2", "Id": "41419564", "Score": "1", "CreationDate": "2017-01-01T22:24:14.313", "LastActivityDate": "2017-01-01T22:24:14.313"}, "41419196": {"ParentId": "41419164", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>How about storing the data member as array and access them by names?</p>\n<pre><code>struct vec {\n    float p[3];\n\n    float&amp; x() { return p[0]; }\n    float&amp; y() { return p[1]; }\n    float&amp; z() { return p[2]; }\n\n    float&amp; operator[](std::size_t i)\n    {\n        assert(i &lt; 3);\n        return p[i];\n    }\n};\n</code></pre>\n<p>EDIT: For the original approach, if x, y and z are all the member variables you have, then the struct will always be the size of 3 floats, so <code>static_assert</code> can be used for checking that <code>operator[]</code> will access within bounded size.</p>\n<p>See also: <a href=\"https://stackoverflow.com/questions/28526585/c-struct-member-memory-allocation#28526625\">C++ struct member memory allocation</a></p>\n<p>EDIT 2: Like Brian said in another answer, <code>(&amp;x)[i]</code> itself is undefined behaviors in the standard. However, given that the 3 floats are the only data members, the code in this context should be safe.</p>\n<p>To be pedantic on syntax correctness:</p>\n<pre><code>struct vec {\n  float x, y, z;\n  float* const p = &amp;x;\n\n  float&amp; operator[](std::size_t i) {\n    assert(i &lt; 3);\n    return p[i];\n  }\n};\n</code></pre>\n<p>Although this will increase each vec by the size of a pointer.</p>\n", "OwnerUserId": "4509057", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:25.167", "Id": "41419196", "Score": "-3", "CreationDate": "2017-01-01T21:29:02.693", "LastActivityDate": "2017-01-01T22:09:17.977"}, "41427056": {"ParentId": "41419164", "CommentCount": "1", "Body": "<p>According to the standard, it is clearly Undefined Behaviour, because you either do pointer arithmetics outside of an array or alias the content of a struct and an array.</p>\n<p>The problem is that math3D code can be used intensively, and low level optimization makes sense. The C++ conformant way would be to directly store the array, and use accessors or references to individual members of the array. And neither of those 2 options are perfectly fine:</p>\n<ul>\n<li><p>accessors:</p>\n<pre><code>struct vec {\nprivate:\n    float arr[3];\npublic:\n    float&amp; operator[](std::size_t i)\n    {\n        assert(i &lt; 3);\n        return arr[i];\n    }\n    float&amp; x() { return arr[0];}\n    float&amp; y() { return arr[0];}\n    float&amp; z() { return arr[0];}\n};\n</code></pre>\n<p>The problem is that using a function as a lvalue is not natural for old C programmers: <code>v.x() = 1.0;</code> is indeed correct but I'd rather avoid a library that would force me to write that. Of course we could use setters, but if possible, I prefere to write <code>v.x = 1.0;</code> than <code>v.setx(1.0);</code>, because of the common idiom <code>v.x = v.z = 1.0; v.y = 2.0;</code>. It is only my opinion, but I find it neater than <code>v.x() = v.z() = 1.0; v.y() = 2.0;</code> or <code>v.setx(v.sety(1.0))); v.setz(2.0);</code>.</p></li>\n<li><p>references</p>\n<pre><code>struct vec {\nprivate:\n    float arr[3];\npublic:\n    float&amp; operator[](std::size_t i)\n    {\n        assert(i &lt; 3);\n        return arr[i];\n    }\n    float&amp; x;\n    float&amp; y;\n    float&amp; z;\n    vec(): x(arr[0]), y(arr[1]), z(arr[2]) {}\n};\n</code></pre>\n<p>Nice! We can write <code>v.x</code> and <code>v[0]</code>, both representing the same memory... unfortunately, the compilers are still not smart enough to see that the refs are just aliases for an in struct array and the size of the struct is twice the size of the array!</p></li>\n</ul>\n<p>For those reasons, the incorrect aliasing is still commonly used...</p>\n", "OwnerUserId": "3545273", "PostTypeId": "2", "Id": "41427056", "Score": "2", "CreationDate": "2017-01-02T12:41:42.117", "LastActivityDate": "2017-01-02T12:41:42.117"}, "41419271": {"ParentId": "41419164", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>You can never be sure that this will work</strong></p>\n<p>There is no guarantee of contiguity of subsequent members, even if this will frequently work perfectly in practice thanks to usual float alignment properties and permissive pointer arithmetic.</p>\n<p>There is no way to make this legal using <code>static_assert</code> nor <code>alignas</code> constraints.  All you can do is to prevent the compilation, when the elements are not contiguous, using the property that the address of each object is unique:  </p>\n<pre><code>    static_assert (&amp;y==&amp;x+1 &amp;&amp; &amp;z==&amp;y+1, \"PADDING in vector\"); \n</code></pre>\n<p><strong>But you can reimplement the operator to make it standard compliant</strong></p>\n<p>A safe alternative, would be to reimplement <code>operator[]</code> to get rid of the contiguity requirement for the three members:  </p>\n<pre><code>struct vec {\n    float x,y,z; \n\n    float&amp; operator[](size_t i)\n    {\n        assert(i&lt;3); \n        if (i==0)     // optimizing compiler will make this as efficient as your original code\n            return x; \n        else if (i==1) \n            return y; \n        else return z;\n    }\n};\n</code></pre>\n<p>Note that an optimizing compiler will generate very similar code for both the reimplementation and for your original version (see <a href=\"https://godbolt.org/g/ntQM3C\" rel=\"nofollow noreferrer\">an example here</a>).  So rather choose the compliant version. </p>\n", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "LastEditDate": "2017-01-01T22:32:33.767", "Id": "41419271", "Score": "3", "CreationDate": "2017-01-01T21:40:51.473", "LastActivityDate": "2017-01-01T22:32:33.767"}, "41419216": {"ParentId": "41419164", "CommentCount": "9", "Body": "<p>No, it is not legal because when adding an integer to a pointer, the following applies ([expr.add]/5):</p>\n<blockquote>\n<p id=\"so_41419164_41419216_0\">If both the pointer operand and the result point to elements of the same array object, or one past\n  the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is\n  undefined.</p>\n</blockquote>\n<p><code>y</code> occupies the memory location one past the end of <code>x</code> (considered as an array with one element) so adding 1 to <code>&amp;x</code> is defined, but adding 2 to <code>&amp;x</code> is undefined.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "41419216", "Score": "6", "CreationDate": "2017-01-01T21:32:36.357", "LastActivityDate": "2017-01-01T21:32:36.357"}, "41419164": {"CommentCount": "4", "AcceptedAnswerId": "41419216", "ClosedDate": "2017-08-27T12:15:37.653", "CreationDate": "2017-01-01T21:24:24.197", "LastActivityDate": "2017-01-02T12:41:42.117", "PostTypeId": "1", "ViewCount": "213", "Title": "Reinterpret struct with members of the same type as an array in a standard compliant way", "Id": "41419164", "Score": "7", "Body": "<p>In various 3d math codebases I sometimes encounter something like this:</p>\n<pre><code>struct vec {\n    float x, y, z;\n\n    float&amp; operator[](std::size_t i)\n    {\n        assert(i &lt; 3);\n        return (&amp;x)[i];\n    }\n};\n</code></pre>\n<p>Which, AFAIK is illegal because implementations are allowed to spuriously add padding between members, even if they are of the same type, though none will do so in practice.</p>\n<p>Can this be made legal by imposing constraints via <code>static_assert</code>s? </p>\n<pre><code>static_assert(sizeof(vec) == sizeof(float) * 3);\n</code></pre>\n<p>I.e. does <code>static_assert</code> not being triggered implies <code>operator[]</code> does what is expected and doesn't invoke UB at runtime?</p>\n", "Tags": "<c++><language-lawyer><strict-aliasing><type-punning><structure-packing>", "OwnerUserId": "1554020", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_41419164_41419216_0": {"section_id": 6142, "quality": 1.0, "length": 21}}, "n3337": {"so_41419164_41419216_0": {"section_id": 5906, "quality": 1.0, "length": 21}}, "n4659": {"so_41419164_41419216_0": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}}}});