post_cb({"15148087": {"CommentCount": "0", "ViewCount": "202", "PostTypeId": "1", "LastEditorUserId": "1932150", "CreationDate": "2013-03-01T00:06:41.567", "LastActivityDate": "2013-03-01T00:48:48.533", "Title": "Templates with same signature not causing a compiler error", "AcceptedAnswerId": "15148532", "LastEditDate": "2013-03-01T00:20:14.027", "Id": "15148087", "Score": "2", "Body": "<p>The following program defines two function templates, <code>A::foo&lt;&gt;()</code> and <code>B::foo&lt;&gt;()</code>, in two separate namespaces (<code>A</code> and <code>B</code>). The two function templates are <em>identical in signature</em>, and differ only in the default argument assigned to their second template parameter. Eventually, their names are brought into the scope of <code>main()</code> by a corresponding pair of <code>using</code> declarations:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nnamespace A\n{\n    template&lt;\n        typename T,\n        typename = typename std::enable_if&lt;\n            std::is_same&lt;T, int&gt;::value        // Let this be condition C\n            &gt;::type\n        &gt;\n    void foo(T) { }\n}\n\nnamespace B\n{\n    template&lt;\n        typename T,\n        typename = typename std::enable_if&lt;\n            !std::is_same&lt;T, int&gt;::value       // This is the negation of C\n            &gt;::type\n        &gt;\n    void foo(T) { }\n}\n\nint main() {\n    using A::foo;\n    using B::foo; // COMPILES: Is this legal?\n\n    foo(42); // Invokes A::foo(), non-ambiguous because of SFINAE\n}\n</code></pre>\n<p>I would expect the second <code>using</code> declaration to cause a compilation error here: after all, that is what I get when I try to define those two templates in the same namespace. </p>\n<p>To my surprise, every compiler I tried this on (GCC 4.7.2, GCC 4.8.0 beta, ICC 13.0.1, Clang 3.2) compiles the program and invokes <code>A::foo()</code>.</p>\n<p><strong>QUESTION #1: Is this correct?</strong> Is it perhaps a case of \"<em>no diagnostic required</em>\"? References to the C++11 Standard are encouraged.</p>\n<hr>\n<p>Consider now this variation of the above program, that basically achieves the same effect using classes rather than namespaces:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct X\n{\n    template&lt;\n        typename T,\n        typename = typename std::enable_if&lt;\n            std::is_same&lt;T, int&gt;::value        // Here is condition C again\n            &gt;::type\n        &gt;\n    static void foo(T) { }\n};\n\nstruct Y\n{\n    template&lt;\n        typename T,\n        typename = typename std::enable_if&lt;\n            !std::is_same&lt;T, int&gt;::value       // And the negation of C again\n            &gt;::type\n        &gt;\n    static void foo(T) { }\n};\n\nstruct Z : X, Y\n{\n   using X::foo;\n   using Y::foo; // COMPILES: Is this legal?\n};\n\nint main() {\n    Z::foo(42); // Invokes X::foo(), non-ambiguous because of SFINAE\n}\n</code></pre>\n<p>This program too compiles on all the above mentioned compilers, while I would expect a compiler error to be caused by the second <code>using</code> declaration.</p>\n<p><strong>QUESTION #2: Is this correct?</strong> Is it perhaps a case of \"<em>no diagnostic required</em>\"? References to the C++11 Standard are encouraged.</p>\n</hr>", "Tags": "<c++><templates><c++11><using-declaration>", "OwnerUserId": "1932150", "AnswerCount": "1"}, "15148532": {"ParentId": "15148087", "CommentCount": "2", "CreationDate": "2013-03-01T00:48:48.533", "OwnerUserId": "585729", "PostTypeId": "2", "Id": "15148532", "Score": "4", "Body": "<p>For question #1: it appears that this is allowed, because there is no rule to disallow it. The C++11 standard mentions this in a note, next to the rule to disallow this, if the function introduced by the using declaration conflicts with a function that is declared directly in the namespace into which the using declaration introduces the name.</p>\n<p>It says in <em>\u00a77.3.3[namespace.udecl]/14</em>:</p>\n<blockquote>\n<p id=\"so_15148087_15148532_0\">If a function declaration in namespace scope or block scope has the\n  same name and the same parameter types as a function introduced by a\n  using-declaration, and the declarations do not declare the same\n  function, the program is ill-formed. [...]</p>\n</blockquote>\n<p>This is the normative text that designates a certain kind of conflict as invalid.</p>\n<p>There is no normative text that two using declarations don't conflict in the same way, but a note that a similar conflict between two using declaractions is not invalid at the point of declaraction. The same paragraph continues: </p>\n<blockquote>\n<p id=\"so_15148087_15148532_1\">[...] [ Note: Two using-declarations may introduce functions with \n  the same name and the same parameter types. If, for a call to an unqualified\n  function name, function overload resolution selects the functions\n  introduced by such using-declarations, the function call is\n  ill-formed. \n  [ Example:</p>\n<pre><code> namespace B { \n   void f(int); \n   void f(double); \n }\n namespace C { \n   void f(int);\n   void f(double); \n   void f(char);\n } \n\n void h() {\n   using B::f;    // B::f(int) and B::f(double)\n   using C::f;    // C::f(int), C::f(double), and C::f(char)\n   f(\u2019h\u2019);        // calls C::f(char)\n   f(1);          // error: ambiguous: B::f(int) or C::f(int)?\n   void f(int);   // f(int) conflicts with C::f(int) and B::f(int)\n }\n</code></pre>\n<p id=\"so_15148087_15148532_2\">\u2014 end example ] \u2014 end note ]</p>\n</blockquote>\n<p>For question #2, the analogous normative text that describes the case of a conflict between a class member declaration and a class-level using declaration is in the following paragraph, <em>\u00a77.3.3/15</em>:</p>\n<blockquote>\n<p id=\"so_15148087_15148532_3\">When a using-declaration brings names from a base class into a derived\n  class scope, member functions and member function templates in the\n  derived class override and/or hide member functions and member\n  function templates with the same name, parameter-type-list (8.3.5),\n  cv-qualification, and ref-qualifier (if any) in a base class (rather\n  than conflicting). [ Note: For using-declarations that name a\n  constructor, see 12.9. \u2014 end note ]</p>\n</blockquote>\n<p>Again there is no text about conflicts between using declaractions, but analogous to the note in the preceding case, having two using declarations that potentially designate conflicting functions is not ill-formed, because there is no text that disallows coexistence of these declaration. And as in the preceding case: if, for a function call, overload resolution selects both these functions the call is ill-formed.</p>\n<p>In your example SFINAE will always eliminate one of the potentially conflicting functions from the overload set, so in neither case is there a problem.</p>\n", "LastActivityDate": "2013-03-01T00:48:48.533"}, "bq_ids": {"n4140": {"so_15148087_15148532_0": {"section_id": 5503, "quality": 0.8947368421052632, "length": 17}, "so_15148087_15148532_3": {"section_id": 5504, "quality": 0.8666666666666667, "length": 39}, "so_15148087_15148532_1": {"section_id": 5503, "quality": 0.8518518518518519, "length": 23}}, "n3337": {"so_15148087_15148532_0": {"section_id": 5289, "quality": 1.0, "length": 19}, "so_15148087_15148532_3": {"section_id": 5290, "quality": 0.8666666666666667, "length": 39}, "so_15148087_15148532_1": {"section_id": 5289, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_15148087_15148532_0": {"section_id": 6937, "quality": 0.8947368421052632, "length": 17}, "so_15148087_15148532_3": {"section_id": 6938, "quality": 0.7111111111111111, "length": 32}, "so_15148087_15148532_1": {"section_id": 6937, "quality": 0.8518518518518519, "length": 23}}}});