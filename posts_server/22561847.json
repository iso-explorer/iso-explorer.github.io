post_cb({"22561847": {"CommentCount": "1", "ViewCount": "166", "CreationDate": "2014-03-21T14:42:00.767", "LastActivityDate": "2014-03-21T15:05:18.033", "Title": "Mentality behind GNU _M_ prefixing", "AcceptedAnswerId": "22562039", "PostTypeId": "1", "Id": "22561847", "Score": "4", "Body": "<p>If we take a look at GNU's implementation of libstdc++, I've noticed that in the implementations of the standard classes that <strong>private</strong> member functions of various classes are prefixed with <code>_M_</code>. For example, <code>std::basic_string&lt;&gt;</code> has among others a member called <code>bool _M_is_shared() const;</code>.</p>\n<p>I understand the motivation to have some sort of naming convention for private member variables. This helps is distinguishing between class members and function local variables visually. But I don't get why the <code>_M_</code> prefix is preferred for private member functions.</p>\n<p>If I see some code that called for example: <code>is_shared();</code> there is essentially only a few options:</p>\n<ol>\n<li>it's a member function of this class</li>\n<li>it's a member function of a parent class</li>\n<li>it's a global function.</li>\n</ol>\n<p>The first two, would both have the prefix so it's no help. The last one <strong>wont happen in any sane implementation</strong> because of namespace pollution concerns. The only globals the library should introduce are ones prescribed by the standard. So here's the crux of the question...</p>\n<p>Since private member functions aren't publicly accessible. Can't effect derived classes in any way. I don't think that name collisions are really a concern here... and basically these are nothing more than a private implementation detail. Why bother with the (IMO) ugly <code>_M_</code> prefixing? Is there something in the standard that disallows introducing extra private members? If so that would strike me as silly unless there is something I am missing.</p>\n", "Tags": "<c++><naming-conventions><gnu><libstdc++>", "OwnerUserId": "13430", "AnswerCount": "2"}, "22562263": {"ParentId": "22561847", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-03-21T14:59:48.023", "Score": "3", "LastEditorUserId": "158049", "LastEditDate": "2014-03-21T15:05:18.033", "Id": "22562263", "OwnerUserId": "158049", "Body": "<p>The standard specifies that names starting with double underscores, or an underscore followed by a capital letter, are reserved for internal compiler or library symbols.</p>\n<p>You pointed out that these private symbols won't be accessible, but don't forget about macros and defines. Basically, the idea is as simple as \"Let's replace <code>m_member</code> with <code>_M_member</code>\".</p>\n<p>The relevant part of the standard is 17.4.3.1.2 Global names</p>\n<blockquote>\n<p id=\"so_22561847_22562263_0\">Each name the contains a double underscore <code>__</code> or begins with an\n  underscore followed by an uppercase letter is reserved to the\n  implementation for any use.</p>\n</blockquote>\n", "LastActivityDate": "2014-03-21T15:05:18.033"}, "bq_ids": {"n4140": {"so_22561847_22562263_0": {"section_id": 6307, "quality": 1.0, "length": 13}}, "n3337": {"so_22561847_22562263_0": {"section_id": 6064, "quality": 1.0, "length": 13}}, "n4659": {"so_22561847_22562263_0": {"section_id": 6756, "quality": 0.9230769230769231, "length": 12}}}, "22562039": {"ParentId": "22561847", "CommentCount": "5", "CreationDate": "2014-03-21T14:50:09.773", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "22562039", "Score": "5", "Body": "<p>Identifiers beginning with an underscore and then a capital letter, or beginning with two underscores, are \"reserved for the implementation in all contexts\".</p>\n<p>This means it would be illegal according to the Standard for someone's program to <code>#define _M_is_shared false</code> and break the library header file.  If they used more ordinary identifiers, there would be greater risk of such a name collision in otherwise valid programs.</p>\n", "LastActivityDate": "2014-03-21T14:50:09.773"}});