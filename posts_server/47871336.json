post_cb({"bq_ids": {"n4140": {"so_47871336_47873166_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 5448}, "so_47871336_47873166_3": {"length": 4, "quality": 0.8, "section_id": 5451}, "so_47871336_47873166_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5445}}, "n3337": {"so_47871336_47873166_2": {"length": 12, "quality": 0.8, "section_id": 5242}}, "n4659": {"so_47871336_47873166_3": {"length": 5, "quality": 1.0, "section_id": 6890}, "so_47871336_47873166_2": {"length": 15, "quality": 1.0, "section_id": 6875}, "so_47871336_47873166_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 6872}}}, "47871336": {"ViewCount": "349", "Body": "<p>The following code <a href=\"http://coliru.stacked-crooked.com/a/877293523244614b\" rel=\"noreferrer\">compiles successfully both with <em>clang++ 3.8.0</em> and <em>g++ 7.2.0</em></a> (the compilation flags are <code>-std=c++14 -O0 -Wall -Wextra -Werror -pedantic-errors</code>):</p>\n<pre><code>#include &lt;iostream&gt;\n\n\nint foo_int(int)\n{\n    std::cout &lt;&lt; \"int foo(int)\" &lt;&lt; std::endl;\n\n    return 0;\n}\n\nvoid foo_void(int)\n{\n    std::cout &lt;&lt; \"void foo(int)\" &lt;&lt; std::endl;\n}\n\nauto foo_auto_int(int)\n{\n    std::cout &lt;&lt; \"auto foo(int), auto == int\" &lt;&lt; std::endl;\n\n    return 0;\n}\n\nauto foo_auto_void(int)\n{\n    std::cout &lt;&lt; \"auto foo(int), auto == void\" &lt;&lt; std::endl;\n\n    return void();\n}\n\n\nint main()\n{\n    auto (*fi)(int) = foo_int;\n    auto (*fv)(int) = foo_void;\n    auto (*fai)(int) = foo_auto_int;\n    auto (*fav)(int) = foo_auto_void;\n\n    (void)fi(0);\n    fv(0);\n    (void)fai(0);\n    fav(0);\n}\n</code></pre>\n<p>Is it a valid C++ code?</p>\n<p>Note that the <code>decltype(auto)</code> is <a href=\"http://coliru.stacked-crooked.com/a/3ad435aa8653f0e5\" rel=\"noreferrer\">rejected both by <em>clang++</em> and <em>g++</em> in the same situation</a>.</p>\n", "Title": "Is it possible to use the `auto` keyword as a return type in a function pointer declaration with initialization?", "CreationDate": "2017-12-18T15:15:59.557", "LastActivityDate": "2017-12-19T14:57:11.447", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-12-19T14:57:11.447", "LastEditorUserId": "3043539", "Id": "47871336", "Score": "15", "OwnerUserId": "3043539", "Tags": "<c++><initialization><language-lawyer><function-pointers><auto>", "AnswerCount": "1"}, "47873166": {"Id": "47873166", "PostTypeId": "2", "Body": "<p>The compilers are behaving correctly.</p>\n<p>From <a href=\"https://timsong-cpp.github.io/cppwp/dcl.spec.auto\" rel=\"noreferrer\">[dcl.spec.auto]</a></p>\n<blockquote>\n<p id=\"so_47871336_47873166_0\">The <code>auto</code> and <code>decltype(auto)</code> type-specifiers are used to designate a placeholder type that will be replaced later by deduction from an <em>initializer</em>.</p>\n<p id=\"so_47871336_47873166_1\">[...]</p>\n<p id=\"so_47871336_47873166_2\"><code>auto</code> or <code>decltype(auto)</code> shall appear as one of the <em>decl-specifiers</em> in the <em>decl-specifier-seq</em> and the <em>decl-specifier-seq</em> shall be followed by one or more <em>declarators</em>, each of which shall be followed by a non-empty <em>initializer</em>.</p>\n</blockquote>\n<p>Which is saying <code>auto</code> and <code>decltype(auto)</code> can only be written with the specifiers you write in the front of a declaration (<code>static</code>, <code>virtual</code> etc), with their types deduced from the immediately following <em>declarators</em> with <em>initializers</em>.</p>\n<h2>The case of <code>auto</code></h2>\n<p>The <em>declarator</em> in the case of <code>auto (*fi)(int) = foo_int;</code> is <code>(*fi)(int)</code> which is of the form</p>\n<pre><code>( ptr-operator declarator-id ) ( parameter-declaration-clause )\n</code></pre>\n<p>Hence <code>auto (*fi)(int) = foo_int;</code> is valid, provided the <a href=\"https://timsong-cpp.github.io/cppwp/dcl.spec.auto#dcl.type.auto.deduct-4\" rel=\"noreferrer\">deduction succeeds</a>, which it does. Likewise for the other few.</p>\n<h2>The case of <code>decltype(auto)</code></h2>\n<p>From <a href=\"https://timsong-cpp.github.io/cppwp/dcl.spec.auto#dcl.type.auto.deduct-5\" rel=\"noreferrer\">[dcl.spec.auto.deduct]</a>, given a type <code>T</code> containing a placeholder type</p>\n<blockquote>\n<p id=\"so_47871336_47873166_3\">If the placeholder is the <code>decltype(auto)</code> <em>type-specifier</em>, <code>T</code> shall be the placeholder alone.</p>\n</blockquote>\n<p>Which means adding anything else is illegal</p>\n<pre><code>int i;\ndecltype(auto)* p = &amp;i;  // error, declared type is not plain decltype(auto)\n</code></pre>\n<p>Hence <code>decltype(auto) (*fi)(int) = foo_int;</code> is illegal.</p>\n", "LastEditorUserId": "4832499", "LastActivityDate": "2017-12-18T18:38:40.857", "Score": "10", "CreationDate": "2017-12-18T17:05:35.020", "ParentId": "47871336", "CommentCount": "4", "OwnerUserId": "4832499", "LastEditDate": "2017-12-18T18:38:40.857"}});