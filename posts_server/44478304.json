post_cb({"bq_ids": {"n4140": {"so_44478304_44478424_0": {"length": 27, "quality": 1.0, "section_id": 557}}, "n3337": {"so_44478304_44478424_0": {"length": 27, "quality": 1.0, "section_id": 548}}, "n4659": {"so_44478304_44478424_0": {"length": 27, "quality": 1.0, "section_id": 580}}}, "44478304": {"ViewCount": "325", "Body": "<p>Why can't we implement both methods <code>getAB() &amp;&amp;</code> and <code>getAB()</code>, but can implement any one of these?</p>\n<ol>\n<li>Works: <a href=\"http://ideone.com/4EgObJ\" rel=\"nofollow noreferrer\">http://ideone.com/4EgObJ</a></li>\n</ol>\n<p>Code:</p>\n<pre><code>struct Beta {\n  Beta_ab ab;\n  Beta_ab &amp;&amp; getAB() &amp;&amp; { cout &lt;&lt; \"1\"; return move(ab); }\n};\n\nint main() {    \n    Beta_ab ab = Beta().getAB();\n\n    return 0;\n}\n</code></pre>\n<hr>\n<ol start=\"2\">\n<li>Works: <a href=\"http://ideone.com/m9d0Tz\" rel=\"nofollow noreferrer\">http://ideone.com/m9d0Tz</a></li>\n</ol>\n<p>Code:</p>\n<pre><code>struct Beta {\n  Beta_ab ab;\n  Beta_ab &amp;&amp; getAB() { cout &lt;&lt; \"2\"; return move(ab); }\n};\n\nint main() {\n    Beta b;\n    Beta_ab ab = b.getAB();\n\n    return 0;\n}\n</code></pre>\n<hr>\n<ol start=\"3\">\n<li><strong>Doen't</strong> works: <a href=\"http://ideone.com/QIQtZ5\" rel=\"nofollow noreferrer\">http://ideone.com/QIQtZ5</a></li>\n</ol>\n<p>Code:</p>\n<pre><code>struct Beta {\n  Beta_ab ab;\n  Beta_ab &amp;&amp; getAB() &amp;&amp; { cout &lt;&lt; \"1\"; return move(ab); }\n  Beta_ab &amp;&amp; getAB() { cout &lt;&lt; \"2\"; return move(ab); }\n};\n\nint main() {\n    Beta b;\n    Beta_ab ab1 = b.getAB();\n\n    Beta_ab ab2 = Beta().getAB();\n\n    return 0;\n}\n</code></pre>\n<p>Why are the first two examples of code works, but the last example does not work?</p>\n</hr></hr>", "AcceptedAnswerId": "44478424", "Title": "Why can't we implement both methods `getAB() &&` and `getAB()`?", "CreationDate": "2017-06-10T21:36:24.823", "Id": "44478304", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-06-11T03:47:23.417", "LastEditorUserId": "2069064", "LastActivityDate": "2017-06-11T03:47:23.417", "ClosedDate": "2017-06-11T03:57:06.223", "Score": "6", "OwnerUserId": "1558037", "Tags": "<c++><c++11><c++14><move-semantics><rvalue-reference>", "AnswerCount": "1"}, "44478424": {"Id": "44478424", "PostTypeId": "2", "Body": "<p>Standard section [over.load]/2.3:</p>\n<blockquote>\n<p id=\"so_44478304_44478424_0\">Member function declarations with the same name and the same <em>parameter-type-list</em> as well as member function template declarations with the same name, the same <em>parameter-type-list</em>, and the same template parameter lists cannot be overloaded if any of them, but not all, have a <em>ref-qualifier</em>.</p>\n<p id=\"so_44478304_44478424_1\">[Example:</p>\n</blockquote>\n<pre><code>class Y {\n  void h() &amp;;\n  void h() const &amp;;    // OK\n  void h() &amp;&amp;;         // OK, all declarations have a ref-qualifier\n  void i() &amp;;\n  void i() const;      // ill-formed, prior declaration of i\n                       // has a ref-qualifier\n};\n</code></pre>\n<blockquote>\n<p id=\"so_44478304_44478424_2\">-- end example ]</p>\n</blockquote>\n<p>It's not entirely clear to me exactly why we have this rule, but that's what it is.  (Though I guess the alternative of trying to work something into the overload resolution rules would take some work, at least.)</p>\n<p>The solution is obvious: add an lvalue (<code>&amp;</code>) ref-qualifier to your <code>\"2\"</code> overload so that one only takes rvalues and one only takes lvalues.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-06-11T03:45:24.233", "Score": "8", "CreationDate": "2017-06-10T21:54:03.950", "ParentId": "44478304", "CommentCount": "0", "OwnerUserId": "459640", "LastEditDate": "2017-06-11T03:45:24.233"}});