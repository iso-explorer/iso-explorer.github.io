post_cb({"bq_ids": {"n4140": {"so_23629856_23630403_0": {"length": 31, "quality": 0.5849056603773585, "section_id": 5432}}, "n3337": {"so_23629856_23630403_0": {"length": 31, "quality": 0.5849056603773585, "section_id": 5227}}, "n4659": {"so_23629856_23630403_0": {"length": 31, "quality": 0.5849056603773585, "section_id": 6860}}}, "23630454": {"Id": "23630454", "PostTypeId": "2", "Body": "<p>I spent a fair deal reading and re-reading that loop, but I think the problem is this:</p>\n<p>That C++ class <code>String</code> owns the memory pointed to by its private member <code>str</code>. Once an external piece of code uses the type conversion operator to get a copy of that pointer, it has <em>no</em> way of telling when the underlying buffer has been <code>delete[]</code>ed.</p>\n<p>Changing the memory that <code>str</code> points to may also invalidate any other outstanding pointers to the same buffer. Shortening the string could make it so those other pointers are already pointing past the NULL terminator of the string. (Though in this specific example, the original '\\0' still exists).</p>\n<p>Once the <code>String</code> has been deleted, a different allocation on the heap may reuse that piece of memory. Calling <code>remove_blanks()</code> afterwards would lead to a difficult-to-debug disaster.</p>\n<p>This could be avoided by making a new copy of the string with <code>strcpy()</code> directly afterwards, using a <code>std::shared_ptr&lt;char *&gt;</code>, or making <code>remove_blanks()</code> a member function of <code>String</code> and doing away with these pointers altogether.</p>\n", "LastActivityDate": "2014-05-13T11:49:31.320", "CommentCount": "0", "CreationDate": "2014-05-13T11:49:31.320", "ParentId": "23629856", "Score": "0", "OwnerUserId": "773"}, "23629856": {"ViewCount": "197", "Body": "<p>I'm reading the book \"C++ Strategies and Tactics\" and was puzzled by the following code. The author says that the operation may not be safe. However, I haven't got the reason yet. Can you help me?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n\nvoid remove_blanks(char* cp)\n{\n    char*p = cp;\n    while(*p)\n    {\n        if(*p != ' ')\n            *cp++ = *p;\n        ++p;\n    }\n    *cp = '\\0';\n}\nclass String\n{\npublic:\n    String(char* p = \" \"):str(new char[strlen(p) + 1])\n    {\n        strcpy(str,p);\n    }\n    ~String()\n    {\n        delete []str;\n    }\n    operator const char* () const\n    {\n        return (const char*)str;\n    }\nprivate:\n    char* str;\n\n};\nint main()\n{\n    String s(\"hello world\");\n    remove_blanks((char*)(const char*)s);\n    std::cout &lt;&lt; s &lt;&lt; \".\\n\";\n}\n</code></pre>\n", "AcceptedAnswerId": "23630454", "Title": "A quiz from the book \"C++ Strategies and Tactics\"", "CreationDate": "2014-05-13T11:22:22.383", "Id": "23629856", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-05-13T11:47:29.123", "LastEditorUserId": "912144", "LastActivityDate": "2014-05-13T13:46:43.623", "ClosedDate": "2014-05-13T19:56:30.897", "Score": "0", "OwnerUserId": "2709741", "Tags": "<c++>", "AnswerCount": "3"}, "23633045": {"Id": "23633045", "PostTypeId": "2", "Body": "<p>Thank you for your answer.\nAt the beginning,I consider the problem is that the former <code>str</code> is <code>\"hello world\\0\"</code> and the later <code>str</code> is <code>\"helloworld\\0\\0\"</code>,and if <code>delete []str</code> doesn't stop freeing memory until the first <code>'\\0'</code>,it will cause <code>memory leak</code>.\nBug when I find out that <code>\"delete operator\"</code> will  free the memory <code>str</code> point to according to the \"<code>4 byte int</code>\" before that memory,I realized that I've thought too much.\nNow I think the problem is that it may cause <code>re-delete</code> the memory str point to.</p>\n", "LastActivityDate": "2014-05-13T13:46:43.623", "CommentCount": "0", "CreationDate": "2014-05-13T13:46:43.623", "ParentId": "23629856", "Score": "0", "OwnerUserId": "2709741"}, "23630403": {"Id": "23630403", "PostTypeId": "2", "Body": "<p>It is plain undefined behavior to modify the string (after the chained casts) in remove_blanks:</p>\n<p>From The 7.1.6.1 cv-qualifiers\nA pointer or reference to a cv-qualified type need not actually point or refer </p>\n<blockquote>\n<p id=\"so_23629856_23630403_0\">to a cv-qualified object, but it is treated as if it does; a\n  const-qualified access path cannot be used to modify an object even if\n  the object referenced is a non-const object and can be modified\n  through some other access path. [ Note: Cv-qualifiers are supported by\n  the type system so that they cannot be subverted without casting\n  (5.2.11). \u2014 end note ] Except that any class member declared mutable\n  (7.1.1) can be modified, <strong>any attempt to modify a const object during\n  its lifetime (3.8) results in undefined behavior.</strong></p>\n</blockquote>\n", "LastEditorUserId": "2249683", "LastActivityDate": "2014-05-13T11:57:48.840", "Score": "6", "CreationDate": "2014-05-13T11:47:19.747", "ParentId": "23629856", "CommentCount": "0", "OwnerUserId": "2249683", "LastEditDate": "2014-05-13T11:57:48.840"}});