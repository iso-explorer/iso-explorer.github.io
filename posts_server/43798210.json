post_cb({"43825509": {"ParentId": "43798210", "CommentCount": "0", "Body": "<p>The previous answers are perfectly valid. I just want to add a potential motivation why it may sometimes be useful to return const objects. \nIn the following example, <code>class A</code> gives a view on internal data from <code>class C</code>, which in some cases shall not be modifyable (Disclaimer, for brevity some essential parts are left out -- also there are likely easier ways to implement this behavior):</p>\n<pre><code>class A {\n    int *data;\n    friend class C; // allow C to call private constructor\n    A(int* x) : data(x) {}\n    static int* clone(int*) {\n        return 0; /* should actually clone data, with reference counting, etc */\n    }\npublic:\n    // copy constructor of A clones the data\n    A(const A&amp; other) : data(clone(other.data)) {}\n    // accessor operators:\n    const int&amp; operator[](int idx) const { return data[idx]; }\n    // allows modifying data\n    int&amp; operator[](int idx) { return data[idx]; }\n};\n\nclass C {\n    int* internal_data;\npublic:\n    C() : internal_data(new int[4]) {} // actually, requires proper implementation of destructor, copy-constructor and operator=\n    // Making A const prohibits callers of this method to modify internal data of C:\n    const A getData() const { return A(internal_data); }\n    // returning a non-const A allows modifying internal data:\n    A getData() { return A(internal_data); }\n};\n\nint main()\n{\n    C c1;\n    const C c2;\n\n    c1.getData()[0] = 1; // ok, modifies value in c1\n    int x = c2.getData()[0]; // ok, reads value from c2\n    // c2.getData()[0] = 2;  // fails, tries to modify data from c2\n    A a = c2.getData(); // ok, calls copy constructor of A\n    a[0] = 2; // ok, works on a copy of c2's data\n}\n</code></pre>\n", "OwnerUserId": "6870253", "PostTypeId": "2", "Id": "43825509", "Score": "2", "CreationDate": "2017-05-06T21:21:46.603", "LastActivityDate": "2017-05-06T21:21:46.603"}, "43798210": {"CommentCount": "9", "AcceptedAnswerId": "43798432", "PostTypeId": "1", "LastEditorUserId": "4850040", "CreationDate": "2017-05-05T06:43:33.643", "LastActivityDate": "2017-05-08T16:53:58.010", "LastEditDate": "2017-05-05T07:59:16.300", "ViewCount": "1988", "FavoriteCount": "7", "Title": "Why do primitive and user-defined types act differently when returned as 'const' from a function?", "Id": "43798210", "Score": "36", "Body": "<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nvoid f(T&amp;&amp;) { cout &lt;&lt; \"f(T&amp;&amp;)\" &lt;&lt; endl; }\n\ntemplate&lt;typename T&gt;\nvoid f(const T&amp;&amp;) { cout &lt;&lt; \"f(const T&amp;&amp;)\" &lt;&lt; endl; }\n\nstruct A {};\nconst A g1() { return {}; }\nconst int g2() { return {}; }\n\nint main()\n{\n    f(g1()); // outputs \"f(const T&amp;&amp;)\" as expected.\n    f(g2()); // outputs \"f(T&amp;&amp;)\" not as expected.\n}\n</code></pre>\n<p>The issue description is embedded in the code. My compiler is <code>clang 5.0</code>.</p>\n<p>I just wonder:</p>\n<p><strong>Why does C++ treat built-in types and custom types differently in such a case?</strong></p>\n", "Tags": "<c++><c++11><overloading><standards><overload-resolution>", "OwnerUserId": "508343", "AnswerCount": "4"}, "43798800": {"ParentId": "43798210", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Quotes from the standard, </p>\n<p><a href=\"http://eel.is/c++draft/expr#6\" rel=\"nofollow noreferrer\">\u00a78/6 Expressions [expr]</a></p>\n<blockquote>\n<p id=\"so_43798210_43798800_0\">If a prvalue initially has the type \u201ccv T\u201d, where T is a\n  cv-unqualified non-class, non-array type, the type of the expression\n  is adjusted to T prior to any further analysis.</p>\n</blockquote>\n<p>and <a href=\"http://eel.is/c++draft/expr#9\" rel=\"nofollow noreferrer\">\u00a78/9 Expressions [expr]</a></p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_43798210_43798800_1\">Whenever a glvalue expression appears as an operand of an operator\n  that expects a prvalue for that operand, the lvalue-to-rvalue,\n  array-to-pointer, or function-to-pointer standard conversions are\n  applied to convert the expression to a prvalue. <strong>[\u2009Note: Because\n  cv-qualifiers are removed from the type of an expression of non-class\n  type when the expression is converted to a prvalue, an lvalue\n  expression of type <code>const int</code> can, for example, be used where a prvalue\n  expression of type <code>int</code> is required. \u2014\u2009end note\u2009]</strong></p>\n</blockquote>\n<p>So for <code>g2()</code>, <code>int</code> is a non-class type, and (the return value of) <code>g2()</code> is a <a href=\"http://en.cppreference.com/w/cpp/language/value_category#prvalue\" rel=\"nofollow noreferrer\">prvalue expression</a>, then <code>const</code> qualifier is removed, so the return type is not <code>const int</code>, but <code>int</code>. That's why <code>f(T&amp;&amp;)</code> is called.</p>\n", "OwnerUserId": "3309790", "LastEditorUserId": "2756719", "LastEditDate": "2017-05-05T20:23:55.563", "Id": "43798800", "Score": "13", "CreationDate": "2017-05-05T07:17:19.873", "LastActivityDate": "2017-05-05T20:23:55.563"}, "43798620": {"ParentId": "43798210", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_43798210_43798620_0\">Why do primitive and user-defined types act differently when returned as 'const' from a function?</p>\n</blockquote>\n<p>Because <code>const</code> part is removed from primitive types returned from functions. Here's why:</p>\n<p>In <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">C++11</a> from <code>\u00a7 5 Expressions [expr]</code> (p. 84):</p>\n<blockquote>\n<p id=\"so_43798210_43798620_1\">8</p>\n<p id=\"so_43798210_43798620_2\">Whenever a glvalue expression appears as an operand of an operator that\n  expects a prvalue for that operand, the lvalue-to-rvalue (4.1),\n  array-to-pointer (4.2), or function-to-pointer (4.3) standard conversions are\n  applied to convert the expression to a prvalue. [Note: because cv-quali\ufb01ers\n  are removed from the type of an expression of non-class type when the\n  expression is converted to a prvalue, an lvalue expression of type\n  const int can, for example, be used where a prvalue expression of type\n  int is required. \u2014end note]</p>\n</blockquote>\n<p>And similarly from <code>\u00a7 5.2.3 Explicit type conversion (functional notation) [expr.type.conv]</code> (p. 95):</p>\n<blockquote>\n<p id=\"so_43798210_43798620_3\">2</p>\n<p id=\"so_43798210_43798620_4\">The expression T(), where T is a simple-type-speci\ufb01er or\n  typename-speci\ufb01er for a non-array complete object type or the\n  (possibly cv-quali\ufb01ed) void type, creates a prvalue of the speci\ufb01ed\n  type,which is valueinitialized (8.5; no initialization is done for the\n  void() case). [Note: if T is a non-class type that is cv-quali\ufb01ed, the\n  cv-quali\ufb01ers are ignored when determining the type of the resulting\n  prvalue (3.10). \u2014end note]</p>\n</blockquote>\n<p>What that means is that <code>const int</code> <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow noreferrer\">prvalue</a> returned by <code>g2()</code> is effectively treated as <code>int</code>.</p>\n", "OwnerUserId": "468725", "LastEditorUserId": "468725", "LastEditDate": "2017-05-08T16:53:58.010", "Id": "43798620", "Score": "21", "CreationDate": "2017-05-05T07:06:58.650", "LastActivityDate": "2017-05-08T16:53:58.010"}, "bq_ids": {"n4140": {"so_43798210_43798800_0": {"section_id": 5939, "quality": 1.0, "length": 14}, "so_43798210_43798800_1": {"section_id": 5942, "quality": 0.9090909090909091, "length": 40}, "so_43798210_43798620_4": {"section_id": 6000, "quality": 0.6111111111111112, "length": 22}, "so_43798210_43798620_2": {"section_id": 5942, "quality": 0.9090909090909091, "length": 40}}, "n3337": {"so_43798210_43798800_1": {"section_id": 5713, "quality": 0.9090909090909091, "length": 40}, "so_43798210_43798620_4": {"section_id": 5768, "quality": 0.6944444444444444, "length": 25}, "so_43798210_43798620_2": {"section_id": 5713, "quality": 0.9090909090909091, "length": 40}}, "n4659": {"so_43798210_43798800_0": {"section_id": 7423, "quality": 1.0, "length": 14}, "so_43798210_43798800_1": {"section_id": 7426, "quality": 0.9318181818181818, "length": 41}, "so_43798210_43798620_2": {"section_id": 7426, "quality": 0.8863636363636364, "length": 39}}}, "43798432": {"ParentId": "43798210", "CommentCount": "7", "Body": "<p>I don't have a quote from the standard, but <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"noreferrer\">cppreference</a> confirms my suspicions:</p>\n<blockquote>\n<p id=\"so_43798210_43798432_0\">A non-class non-array prvalue cannot be cv-qualified. (Note: a function call or cast expression may result in a prvalue of non-class cv-qualified type, but the cv-qualifier is immediately stripped out.)</p>\n</blockquote>\n<p>The returned <code>const int</code> is just a normal <code>int</code> prvalue, and makes the non-const overload a better match than the <code>const</code> one.</p>\n", "OwnerUserId": "4756309", "PostTypeId": "2", "Id": "43798432", "Score": "30", "CreationDate": "2017-05-05T06:57:22.600", "LastActivityDate": "2017-05-05T06:57:22.600"}});