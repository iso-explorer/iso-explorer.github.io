post_cb({"12447678": {"ParentId": "12447557", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Most likely you are not able to execute it because you can't compile it. Also if it would compile correctly, it would always return 1. Did you mean <code>(n==1)? 1 : n * pr(n-1)</code>.</p>\n<p>Macros can't be recursive. According to chapter 16.3.4.2 (thanks Loki Astari), if the current macro is found in the replacement list, it is left as is, thus your <code>pr</code> in the definition will not be changed:</p>\n<blockquote>\n<p id=\"so_12447557_12447678_0\">If  the  name of the macro being replaced is found during this scan of\n  the replacement list (not including the rest of the source file's pre-\n  processing  tokens),  it  is  not  replaced.   Further,  if any nested\n  replacements encounter the name of the macro being replaced, it is not\n  replaced.   These  nonreplaced  macro name preprocessing tokens are no\n  longer available for  further  replacement  even  if  they  are  later\n  (re)examined  in contexts in which that macro name preprocessing token\n  would otherwise have been replaced.</p>\n</blockquote>\n<p>Your call:</p>\n<pre><code>cout&lt;&lt;\"result: \"&lt;&lt; pr(5) &lt;&lt;endl;\n</code></pre>\n<p>was converted by preprocessor into:</p>\n<pre><code>cout&lt;&lt;\"result: \"&lt;&lt; (5==1)? 1 : pr(5-1) &lt;&lt;endl;\n</code></pre>\n<p>During this, the definition of <code>pr</code> macro is 'lost', and compiler shows an error like \"\u2018pr\u2019 was not declared in this scope (fact)\" because there is no function named <code>pr</code>.</p>\n<p>Use of macros is not encouraged in C++. Why don't you just write a function?</p>\n<p>In this case you could even write a template function so it will be resolved in compile time, and will behave as a constant value:</p>\n<pre><code>template &lt;int n&gt;\nint pr() {  pr&lt;n-1&gt;(); }\n\ntemplate &lt;&gt;\nint pr&lt;1&gt;() { return 1; }\n</code></pre>\n", "OwnerUserId": "1663919", "LastEditorUserId": "1663919", "LastEditDate": "2012-09-16T15:30:28.817", "Id": "12447678", "Score": "8", "CreationDate": "2012-09-16T14:27:00.163", "LastActivityDate": "2012-09-16T15:30:28.817"}, "12447557": {"CommentCount": "4", "AcceptedAnswerId": "12447616", "PostTypeId": "1", "LastEditorUserId": "1709587", "CreationDate": "2012-09-16T14:11:08.263", "LastActivityDate": "2017-11-27T13:13:16.370", "LastEditDate": "2017-11-27T13:13:16.370", "ViewCount": "23326", "FavoriteCount": "16", "Title": "Can we have recursive macros?", "Id": "12447557", "Score": "34", "Body": "<p>I want to know if we can have recursive macros in C/C++? If yes, please provide a sample example.</p>\n<p>Second thing: why am I not able to execute the below code? What is the mistake I am doing? Is it because of recursive macros?</p>\n<pre><code># define pr(n) ((n==1)? 1 : pr(n-1))\nvoid main ()\n{\n    int a=5;\n    cout&lt;&lt;\"result: \"&lt;&lt; pr(5) &lt;&lt;endl;\n    getch();\n}\n</code></pre>\n", "Tags": "<c++><c><macros><c-preprocessor>", "OwnerUserId": "1367292", "AnswerCount": "5"}, "12540675": {"ParentId": "12447557", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Macros don't directly expand recursively, but there are workarounds. When the preprocessor scans and expands <code>pr(5)</code>:</p>\n<pre><code>pr(5)\n^\n</code></pre>\n<p>it creates a disabling context, so that when it sees <code>pr</code> again:</p>\n<pre><code>((5==1)? 1 : pr(5-1))\n             ^\n</code></pre>\n<p>it becomes painted blue, and can no longer expand, no matter what we try. But we can prevent our macro from becoming painted blue by using deferred expressions and some indirection:</p>\n<pre><code># define EMPTY(...)\n# define DEFER(...) __VA_ARGS__ EMPTY()\n# define OBSTRUCT(...) __VA_ARGS__ DEFER(EMPTY)()\n# define EXPAND(...) __VA_ARGS__\n\n# define pr_id() pr\n# define pr(n) ((n==1)? 1 : DEFER(pr_id)()(n-1))\n</code></pre>\n<p>So now it will expand like this:</p>\n<pre><code>pr(5) // Expands to ((5==1)? 1 : pr_id ()(5 -1))\n</code></pre>\n<p>Which is perfect, because <code>pr</code> was never painted blue. We just need to apply another scan to make it expand further:</p>\n<pre><code>EXPAND(pr(5)) // Expands to ((5==1)? 1 : ((5 -1==1)? 1 : pr_id ()(5 -1 -1)))\n</code></pre>\n<p>We can apply two scans to make it expand further:</p>\n<pre><code>EXPAND(EXPAND(pr(5))) // Expands to ((5==1)? 1 : ((5 -1==1)? 1 : ((5 -1 -1==1)? 1 : pr_id ()(5 -1 -1 -1))))\n</code></pre>\n<p>However, since there is no termination condition, we can never apply enough scans. I'm not sure what you want to accomplish, but if you are curious on how to create recursive macros, here is an example of how to create a recursive repeat macro. </p>\n<p>First a macro to apply a lot of scans:</p>\n<pre><code>#define EVAL(...)  EVAL1(EVAL1(EVAL1(__VA_ARGS__)))\n#define EVAL1(...) EVAL2(EVAL2(EVAL2(__VA_ARGS__)))\n#define EVAL2(...) EVAL3(EVAL3(EVAL3(__VA_ARGS__)))\n#define EVAL3(...) EVAL4(EVAL4(EVAL4(__VA_ARGS__)))\n#define EVAL4(...) EVAL5(EVAL5(EVAL5(__VA_ARGS__)))\n#define EVAL5(...) __VA_ARGS__\n</code></pre>\n<p>Next, a concat macro which is useful for pattern matching:</p>\n<pre><code>#define CAT(a, ...) PRIMITIVE_CAT(a, __VA_ARGS__)\n#define PRIMITIVE_CAT(a, ...) a ## __VA_ARGS__\n</code></pre>\n<p>Increment and decrement counters:</p>\n<pre><code>#define INC(x) PRIMITIVE_CAT(INC_, x)\n#define INC_0 1\n#define INC_1 2\n#define INC_2 3\n#define INC_3 4\n#define INC_4 5\n#define INC_5 6\n#define INC_6 7\n#define INC_7 8\n#define INC_8 9\n#define INC_9 9\n\n#define DEC(x) PRIMITIVE_CAT(DEC_, x)\n#define DEC_0 0\n#define DEC_1 0\n#define DEC_2 1\n#define DEC_3 2\n#define DEC_4 3\n#define DEC_5 4\n#define DEC_6 5\n#define DEC_7 6\n#define DEC_8 7\n#define DEC_9 8\n</code></pre>\n<p>Some macros useful for conditionals:</p>\n<pre><code>#define CHECK_N(x, n, ...) n\n#define CHECK(...) CHECK_N(__VA_ARGS__, 0,)\n\n#define NOT(x) CHECK(PRIMITIVE_CAT(NOT_, x))\n#define NOT_0 ~, 1,\n\n#define COMPL(b) PRIMITIVE_CAT(COMPL_, b)\n#define COMPL_0 1\n#define COMPL_1 0\n\n#define BOOL(x) COMPL(NOT(x))\n\n#define IIF(c) PRIMITIVE_CAT(IIF_, c)\n#define IIF_0(t, ...) __VA_ARGS__\n#define IIF_1(t, ...) t\n\n#define IF(c) IIF(BOOL(c))\n\n#define EAT(...)\n#define EXPAND(...) __VA_ARGS__\n#define WHEN(c) IF(c)(EXPAND, EAT)\n</code></pre>\n<p>Putting it all together we can create a repeat macro:</p>\n<pre><code>#define REPEAT(count, macro, ...) \\\n    WHEN(count) \\\n    ( \\\n        OBSTRUCT(REPEAT_INDIRECT) () \\\n        ( \\\n            DEC(count), macro, __VA_ARGS__ \\\n        ) \\\n        OBSTRUCT(macro) \\\n        ( \\\n            DEC(count), __VA_ARGS__ \\\n        ) \\\n    )\n#define REPEAT_INDIRECT() REPEAT\n\n//An example of using this macro\n#define M(i, _) i\nEVAL(REPEAT(8, M, ~)) // 0 1 2 3 4 5 6 7\n</code></pre>\n<p>So, yes with some workarounds you can have recursive macros in C/C++.</p>\n", "OwnerUserId": "375343", "LastEditorUserId": "375343", "LastEditDate": "2013-06-17T06:07:46.037", "Id": "12540675", "Score": "75", "CreationDate": "2012-09-22T04:20:23.877", "LastActivityDate": "2013-06-17T06:07:46.037"}, "12447616": {"ParentId": "12447557", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Your compiler probably provides an option to only pre-process, not actually compile. This is useful if you are trying to find a problem in a macro. For example using <code>g++ -E</code>:</p>\n<pre><code>&gt; g++ -E recursiveMacro.c\n\n# 1 \"recursiveMacro.c\"\n# 1 \"&lt;built-in&gt;\"\n# 1 \"&lt;command line&gt;\"\n# 1 \"recursiveMacro.c\"\n\nvoid main ()\n{\n    int a=5;\n    cout&lt;&lt;\"result: \"&lt;&lt; ((5==1)? 1 : pr(5 -1)) &lt;&lt;endl;\n    getch();\n}\n</code></pre>\n<p>As you can see, it is not recursive. <code>pr(x)</code> is only replaced once during pre-processing. The important thing to remember is that all the pre-processor does is blindly replace one text string with another, it doesn't actually evaluate expressions like <code>(x == 1)</code>.</p>\n<p>The reason your code will not compile is that <code>pr(5 -1)</code> was not replaced by the pre-processor, so it ends up in the source as a call to an undefined function.</p>\n", "OwnerUserId": "285951", "LastEditorUserId": "285951", "LastEditDate": "2012-09-16T14:25:20.300", "Id": "12447616", "Score": "12", "CreationDate": "2012-09-16T14:20:11.590", "LastActivityDate": "2012-09-16T14:25:20.300"}, "12447601": {"ParentId": "12447557", "CommentCount": "2", "Body": "<p>You can't have recursive macros in C or C++.</p>\n", "OwnerUserId": "56338", "PostTypeId": "2", "Id": "12447601", "Score": "0", "CreationDate": "2012-09-16T14:18:06.103", "LastActivityDate": "2012-09-16T14:18:06.103"}, "bq_ids": {"n4140": {"so_12447557_12447678_0": {"section_id": 531, "quality": 0.92, "length": 46}, "so_12447557_12447739_0": {"section_id": 531, "quality": 0.9795918367346939, "length": 48}}, "n3337": {"so_12447557_12447678_0": {"section_id": 522, "quality": 0.92, "length": 46}, "so_12447557_12447739_0": {"section_id": 522, "quality": 0.9795918367346939, "length": 48}}, "n4659": {"so_12447557_12447739_0": {"section_id": 552, "quality": 0.9795918367346939, "length": 48}, "so_12447557_12447678_0": {"section_id": 552, "quality": 0.92, "length": 46}}}, "12447739": {"ParentId": "12447557", "CommentCount": "0", "Body": "<p>You're not <strong>supposed</strong> to have recursive macros in C or C++.</p>\n<p>The relevant language from the C++ standard, section 16.3.4 paragraph 2:</p>\n<blockquote>\n<p id=\"so_12447557_12447739_0\">If the name of the macro being replaced is found during this scan of the replacement list (not including the rest of the source file\u2019s preprocessing tokens), it is not replaced. Furthermore, if any nested replacements encounter the name of the macro being replaced, it is not replaced. These nonreplaced macro name preprocessing tokens are no longer available for further replacement even if they are later (re)examined in contexts in which that macro name preprocessing token would otherwise have been replaced.</p>\n</blockquote>\n<p>There's some wiggle room in this language. With multiple macros that invoke one another, there's a grey area where that wording doesn't quite say what should be done. There is an active issue against the C++ standard regarding this language lawyer problem; see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#268\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#268</a> .</p>\n<p>Ignoring that language lawyer issue, every compiler vendor understands the intent:</p>\n<p>Recursive macros are not allowed in C or in C++.</p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "12447739", "Score": "16", "CreationDate": "2012-09-16T14:34:26.310", "LastActivityDate": "2012-09-16T14:34:26.310"}});