post_cb({"25691533": {"CommentCount": "8", "ViewCount": "418", "PostTypeId": "1", "LastEditorUserId": "2756719", "CreationDate": "2014-09-05T18:03:03.007", "LastActivityDate": "2014-09-08T04:06:29.193", "Title": "How check properly, if a `double` or `long double` fits into a `long long`?", "AcceptedAnswerId": "25717310", "LastEditDate": "2014-09-06T04:12:13.393", "Id": "25691533", "Score": "1", "Body": "<p>It seems quite simple at the first thought, but I couldn't find any good descriptions covering this case. </p>\n<p>I have a method which returns a 64bit value. The value is internally calculated using <code>long double</code> values. At the end of the method I would like to check, if the <code>long double</code> is in the range of the <code>long long</code> value, and otherwise just assign the maximum <code>long long</code> value.</p>\n<p>I use the following code, which only checks the positive range, because there are no negative results:</p>\n<pre><code>long long calculateSomething()\n{\n    long double calculatedValue = ...;\n\n    long long result;\n    if (calculatedValue &gt; static_cast&lt;long double&gt;(std::numeric_limits&lt;long long&gt;::max())) {\n        result = std::numeric_limits&lt;long long&gt;::max();\n    } else {\n        result = static_cast&lt;long long&gt;(std::floor(calculatedValue));\n    }\n\n    return result;\n}\n</code></pre>\n<p>Now I wonder, <code>long double</code> can equal to a <code>double</code>. Will the conversion <code>static_cast&lt;long double&gt;(std::numeric_limits&lt;long long&gt;::max())</code> always work correctly?</p>\n<p>Or is there another better way to check the range?</p>\n", "Tags": "<c++><visual-c++><c++11><type-conversion><numeric-limits>", "OwnerUserId": "3370480", "AnswerCount": "1"}, "25717310": {"ParentId": "25691533", "CommentCount": "5", "Body": "<p>The conversion between floating point and integral types are specified in \u00a74.9 [conv.fpint] of the C++ standard:</p>\n<blockquote>\n<p id=\"so_25691533_25717310_0\">1 A prvalue of a floating point type can be converted to a prvalue of\n  an integer type. The conversion truncates; that is, the fractional\n  part is discarded. The behavior is undefined if the truncated value\n  cannot be represented in the destination type. [ <em>Note</em>: If the\n  destination type is <code>bool</code>, see 4.12. \u2014<em>end note</em> ]</p>\n<p id=\"so_25691533_25717310_1\">2 A prvalue of an integer type or of an unscoped enumeration type can\n  be converted to a prvalue of a floating point type. The result is\n  exact if possible. If the value being converted is in the range of\n  values that can be represented but the value cannot be represented\n  exactly, it is an implementation-defined choice of either the next\n  lower or higher representable value. [ <em>Note</em>: Loss of precision\n  occurs if the integral value cannot be represented exactly as a value\n  of the floating type. \u2014<em>end note</em> ] If the value being converted is\n  outside the range of values that can be represented, the behavior is\n  undefined. If the source type is <code>bool</code>, the value <code>false</code> is\n  converted to zero and the value <code>true</code> is converted to one.</p>\n</blockquote>\n<p>A typical <code>long long</code> is 64 bits, so <code>std::numeric_limits&lt;long long&gt;::max()</code> is 2<sup>63</sup>-1. This is much smaller than the smallest possible value for <code>LDBL_MAX</code>, which is <code>1E+37</code>. Thus, we are safely within the representable range for a <code>long double</code>. However, if the <code>long double</code> is 64 bits, 2<sup>63</sup>-1 is highly unlikely to be exactly representable, and you run into trouble because the standard says that the result is \"an implementation-defined choice of either the next lower or higher representable value\". In other words, it can go either way, and there you have a problem.</p>\n<p>If the compiler picked the next lower representable value for the conversion, then all is well. Even if <code>calculatedValue  == static_cast&lt;long double&gt;(std::numeric_limits&lt;long long&gt;::max())</code>, it's still in the representable range of <code>long long</code> and the conversion is well-defined.</p>\n<p>If the compiler picked the next higher representable value for the conversion (and round-to-nearest, the typical rounding used, will likely go this way since 2<sup>63</sup> is exactly representable), and <code>calculatedValue  == static_cast&lt;long double&gt;(std::numeric_limits&lt;long long&gt;::max())</code>, then <code>calculatedValue</code> is actually outside the representable range of a <code>long long</code>, but in your code you still try to cast it to a <code>long long</code>. So, per the first paragraph above, you have undefined behavior. Ouch.</p>\n<p>The simplest fix is to test for <code>calculatedValue &gt;= static_cast&lt;long double&gt;(std::numeric_limits&lt;long long&gt;::max())</code> instead of <code>calculatedValue &gt; static_cast&lt;long double&gt;(std::numeric_limits&lt;long long&gt;::max())</code>. In the unlikely event that the compiler rounds down, you'll miss one case. Another possible fix is to test for <code>calculatedValue &gt;= static_cast&lt;long double&gt;(std::numeric_limits&lt;long long&gt;::max() + 1ULL)</code>, taking advantage of the fact that 2<sup>n</sup> for reasonable <code>n</code>s are exactly representable in floating point.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "25717310", "Score": "0", "CreationDate": "2014-09-08T04:06:29.193", "LastActivityDate": "2014-09-08T04:06:29.193"}, "bq_ids": {"n4140": {"so_25691533_25717310_0": {"section_id": 37, "quality": 0.8125, "length": 26}, "so_25691533_25717310_1": {"section_id": 38, "quality": 0.9295774647887324, "length": 66}}, "n3337": {"so_25691533_25717310_0": {"section_id": 34, "quality": 0.8125, "length": 26}, "so_25691533_25717310_1": {"section_id": 35, "quality": 0.9295774647887324, "length": 66}}, "n4659": {"so_25691533_25717310_0": {"section_id": 37, "quality": 0.75, "length": 24}, "so_25691533_25717310_1": {"section_id": 38, "quality": 0.9014084507042254, "length": 64}}}});