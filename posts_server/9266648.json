post_cb({"9266648": {"ViewCount": "486", "Body": "<p>I was just browsing through the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\">draft of the C++11 standard</a> and found the following puzzling statement (\u00a713.6/8):</p>\n<blockquote>\n<p id=\"so_9266648_9266648_0\">For every type <code>T</code> there exist candidate operator functions of the form</p>\n<pre><code>T* operator+(T*);\n</code></pre>\n</blockquote>\n<p>How should this \"unary +\" operator on pointer be understood? Is this just a no-op in the normal case, which can nevertheless be overloaded? Or is there some deeper point I am missing here?</p>\n", "AcceptedAnswerId": "9266914", "Title": "Unary + on pointers", "CreationDate": "2012-02-13T19:26:30.777", "Id": "9266648", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-02-13T19:32:57.363", "LastEditorUserId": "636019", "LastActivityDate": "2012-02-13T22:21:01.090", "Score": "12", "OwnerUserId": "663957", "Tags": "<c++><c++11><operator-overloading>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_9266648_9266648_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 677}, "so_9266648_9266914_0": {"length": 117, "quality": 0.9435483870967742, "section_id": 675}}, "n3337": {"so_9266648_9266648_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 667}, "so_9266648_9266914_0": {"length": 117, "quality": 0.9435483870967742, "section_id": 665}}, "n4659": {"so_9266648_9266648_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 706}, "so_9266648_9266914_0": {"length": 117, "quality": 0.9435483870967742, "section_id": 703}}}, "9266914": {"Id": "9266914", "PostTypeId": "2", "Body": "<p>The answer to your question is just a page above the quote you cited \u2014 \u00a713.6/1:</p>\n<blockquote>\n<p id=\"so_9266648_9266914_0\">The candidate operator functions that represent the built-in operators defined in Clause 5 are specified in this subclause. <strong>These candidate functions participate in the operator overload resolution process as described in 13.3.1.2 and are used for no other purpose.</strong> [ <em>Note:</em> Because built-in operators take only operands with non-class type, and operator overload resolution occurs only when an operand expression originally has class or enumeration type, operator overload resolution can resolve to a built-in operator only when an operand has a class type that has a user-defined conversion to a non-class type appropriate for the operator, or when an operand has an enumeration type that can be converted to a type appropriate for the operator. Also note that some of the candidate operator functions given in this subclause are more permissive than the built-in operators themselves. As described in 13.3.1.2, after a built-in operator is selected by overload resolution the expression is subject to the requirements for the built-in operator given in Clause 5, and therefore to any additional semantic constraints given there. If there is a user-written candidate with the same name and parameter types as a built-in candidate operator function, the built-in operator function is hidden and is not included in the set of candidate functions. <em>\u2014end note</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2012-02-13T19:42:11.947", "CommentCount": "6", "CreationDate": "2012-02-13T19:42:11.947", "ParentId": "9266648", "Score": "8", "OwnerUserId": "636019"}, "9268862": {"Id": "9268862", "PostTypeId": "2", "Body": "<p>The <code>+</code> on pointers is a noop except for turning things to rvalues. It sometimes is handy if you want to decay arrays or functions</p>\n<pre><code>int a[] = { 1, 2, 3 };\nauto &amp;&amp;x = +a;\n</code></pre>\n<p>Now <code>x</code> is an <code>int*&amp;&amp;</code> and not an <code>int(&amp;)[3]</code>. If you want to pass <code>x</code> or <code>+a</code> to templates, this difference might become important. <code>a + 0</code> is not always equivalent, consider</p>\n<pre><code>struct forward_decl;\nextern forward_decl a[];\nauto &amp;&amp;x = +a; // well-formed\nauto &amp;&amp;y = a + 0; // ill-formed\n</code></pre>\n<p>The last line is ill-formed, because adding anything to a pointer requires the pointer's pointed-to class type to be completely defined (because it advances by <code>sizeof(forward_decl) * N</code> bytes). </p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2012-02-13T22:21:01.090", "Score": "8", "CreationDate": "2012-02-13T22:15:39.053", "ParentId": "9266648", "CommentCount": "4", "OwnerUserId": "34509", "LastEditDate": "2012-02-13T22:21:01.090"}, "9266798": {"Id": "9266798", "PostTypeId": "2", "Body": "<p>Well, you could overload it do do whatever you want, but it's just there for symmetry with the unary - operator.  As you mention, it's just a no-op most of the time.</p>\n", "LastActivityDate": "2012-02-13T19:35:42.473", "CommentCount": "1", "CreationDate": "2012-02-13T19:35:42.473", "ParentId": "9266648", "Score": "0", "OwnerUserId": "116908"}});