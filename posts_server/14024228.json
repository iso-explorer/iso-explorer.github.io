post_cb({"14411408": {"ParentId": "14024228", "CommentCount": "0", "Body": "<p>Which one should you use? Depends on what you are using it for. Because the swap only works for objects, swapping two independent integers or strings or doubles. But the iter_swap works well for arrays and lists, in which you can swap numbers in two different lists as demonstrated on <a href=\"http://www.cplusplus.com/reference/algorithm/iter_swap/\" rel=\"nofollow\">cplusplus.com</a></p>\n", "OwnerUserId": "1992303", "PostTypeId": "2", "Id": "14411408", "Score": "0", "CreationDate": "2013-01-19T05:25:40.673", "LastActivityDate": "2013-01-19T05:25:40.673"}, "14494007": {"ParentId": "14024228", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The standard itself has very few mentions of <code>iter_swap</code>:</p>\n<ul>\n<li>It should have the effect of <code>swap(*a, *b)</code>, although there is no stipulation that it must be implemented that way.</li>\n<li>The dereferenced values <code>*a</code> and <code>*b</code> must be \"swappable\", which implies that <code>swap(*a, *b)</code> must be valid, and thus the dereferenced types must be identical, although the iterator types do not have to be.</li>\n<li><code>iter_swap</code> is required to be used in the implementation of <code>std::reverse</code>.  No such requirement is placed on any other algorithm, so this seems to be an oddity.</li>\n</ul>\n<p>To borrow <a href=\"https://stackoverflow.com/a/13991936/1435577\">what <em>sehe</em> had found</a> from the <em><a href=\"http://www.sgi.com/tech/stl/iter_swap.html\" rel=\"nofollow noreferrer\">SGI docs</a></em>:</p>\n<blockquote>\n<p id=\"so_14024228_14494007_0\">Strictly speaking, <code>iter_swap</code> is redundant. It exists only for technical reasons: in some circumstances, some compilers have difficulty performing the type deduction required to interpret <code>swap(*a, *b)</code>.</p>\n</blockquote>\n<p>All of these seem to suggest that it is an artifact of the past.</p>\n", "OwnerUserId": "440302", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:26:00.830", "Id": "14494007", "Score": "20", "CreationDate": "2013-01-24T04:32:21.700", "LastActivityDate": "2013-01-24T11:18:23.547"}, "14500519": {"ParentId": "14024228", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Yes, they both do the same thing, <em>when used properly</em>. No, <code>std::iter_swap</code> is not deprecated (by being placed in the Standard's \u00a7D <em>Compatibility features</em> section). MSDN's quote is misleadingly dismissive. The issue is that it's inconvenient to use <code>std::swap</code> properly.</p>\n<p>You should use <code>iter_swap</code> for the simple reason that it's a higher abstraction.</p>\n<p><code>swap</code> is commonly overloaded for user-defined types. The proper way to call it is</p>\n<pre><code>using std::swap;\nswap( blah, bleh );\n</code></pre>\n<p>not simply</p>\n<pre><code>std::swap( blah, bleh );\n</code></pre>\n<p>This is ensconced in \u00a717.6.3.2, in particular \u00b63:</p>\n<blockquote>\n<p id=\"so_14024228_14500519_0\">The context in which <code>swap(t, u)</code> and <code>swap(u, t)</code> are evaluated shall ensure that a binary non-member function named \u201cswap\u201d is selected via overload resolution (13.3) on a candidate set that includes:</p>\n<p id=\"so_14024228_14500519_1\">\u2014 the two <code>swap</code> function templates defined in <code>&lt;utility&gt;</code> (20.2) and</p>\n<p id=\"so_14024228_14500519_2\">\u2014 the lookup set produced by argument-dependent lookup (3.4.2).</p>\n</blockquote>\n<p><code>iter_swap</code> is not such a special overloaded name, and customizing its functionality requires adding a template specialization to <code>namespace std {}</code>.</p>\n<hr>\n<p>Therefore, <code>iter_swap</code> usefully encapsulates the part of the Swappable interface which you would otherwise implement every time.</p>\n<p>It is actually a more friendly interface, regardless of whether there's ever a semantic difference for your implementation and its particular arguments. (Not that potential optimizations of it should be overlooked. MSDN may give their opinion, but they can't anticipate what library authors might provide using \"backwards compatibility interfaces.\")</p>\n<hr>\n<p>As for a specialization of <code>iter_swap</code> with an observably different result from <code>swap( *a, *b )</code>, that would seem to be nonconformant with the requirement \u00a725.3.3/5,</p>\n<blockquote>\n<p id=\"so_14024228_14500519_3\">Effects: <code>swap(*a, *b)</code>.</p>\n</blockquote>\n<p>The example you cite does sound like an observable difference, since pointers to <code>*a</code> and <code>*b</code> are both valid before and after the operation. That's unfortunately a bug in the library implementation.</p>\n</hr></hr>", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2013-05-23T22:54:54.443", "Id": "14500519", "Score": "7", "CreationDate": "2013-01-24T11:40:12.707", "LastActivityDate": "2013-05-23T22:54:54.443"}, "16754598": {"ParentId": "14024228", "CommentCount": "0", "Body": "<p>You have hit on the key distinction.</p>\n<p><code>swap(*a, *b)</code> is a global function that resets all pointers pointing to <code>*a</code> to point to what was the contents of <code>*b</code> and vice versa.  It's the old tmp = a, a = b, b = tmp swap.</p>\n<p><code>iter_swap</code> is for the more limited case of modifying the underlying objects being iterated over to affect the structures of which they were a part.  If <code>*a</code> and <code>*b</code> were part of the same linked list, it was sufficient for <code>iter_swap</code> to simply swap their positions in the list. This is an <em>advantage</em> for when you want to simply sort a list without invalidating/changing external pointers to objects in the list.  If I have a pointer to a <code>user</code> object I don't care if you sort the <code>list</code> of <code>user</code> objects, I don't want my idea of who is the \"current\" user to change, so list sort better not use <code>swap</code>.</p>\n", "OwnerUserId": "712765", "PostTypeId": "2", "Id": "16754598", "Score": "3", "CreationDate": "2013-05-25T22:48:03.063", "LastActivityDate": "2013-05-25T22:48:03.063"}, "14024228": {"CommentCount": "6", "AcceptedAnswerId": "14494007", "CreationDate": "2012-12-24T17:42:13.977", "LastActivityDate": "2013-05-28T19:13:47.233", "PostTypeId": "1", "ViewCount": "5627", "FavoriteCount": "6", "Title": "iter_swap() versus swap() -- what's the difference?", "Id": "14024228", "Score": "30", "Body": "<p><a href=\"http://msdn.microsoft.com/en-us/library/f1863z4b.aspx\" rel=\"noreferrer\">MSDN says</a>:</p>\n<blockquote>\n<p id=\"so_14024228_14024228_0\"><code>swap</code> should be used in preference to <code>iter_swap</code>, which was included in the C++ Standard for backward compatibility.</p>\n</blockquote>\n<p>But <a href=\"https://groups.google.com/forum/?fromgroups=#!topic/comp.std.c++/AMH7TXg5EsI\" rel=\"noreferrer\">comp.std.c++ says</a>:</p>\n<blockquote>\n<p id=\"so_14024228_14024228_1\">Most STL algorithms operate on iterator ranges. It therefore makes sense to\n  use <code>iter_swap</code> when swapping elements within those ranges, since that is its\n  intended purpose --- swapping the elements pointed to by two iterators. This\n  allows optimizations for node-based sequences such as <code>std::list</code>, whereby the\n  nodes are just relinked, rather than the data actually being swapped.</p>\n</blockquote>\n<p>So which one is correct? Should I use <code>iter_swap</code>, or should I use <code>swap</code>? (Is <code>iter_swap</code> only for backwards compatibility?) Why?</p>\n", "Tags": "<c++><swap>", "OwnerUserId": "541686", "AnswerCount": "6"}, "16764680": {"ParentId": "14024228", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Reading the laws carefully:</p>\n<hr>\n<p>20.2.2 swap [utility.swap]</p>\n<ul>\n<li><p>template void swap(T&amp; a, T&amp; b)\nnoexcept(is_nothrow_move_constructible::value &amp;&amp;\nis_nothrow_move_assignable::value);</p>\n<p>2 Requires: Type T shall be MoveConstructible and MoveAssignable.\n(Table 20) and (Table 22)</p>\n<p>3 Effects: Exchanges values stored in two locations.</p></li>\n<li><p>template void swap(T (&amp;a)[N], T (&amp;b)[N])\nnoexcept(noexcept(swap(*a, *b)));</p>\n<p>4 Requires: a[i] shall be swappable with b[i] for all i in the range\n[0,N). (17.6.3.2)</p>\n<p>5 Effects: swap_ranges(a, a + N, b)</p></li>\n</ul>\n<p>25.3.3 swap [alg.swap]</p>\n<ul>\n<li><p>template void\niter_swap(ForwardIterator1 a, ForwardIterator2 b);</p>\n<p>5 Effects: swap(*a, *b).</p>\n<p>6 Requires: a and b shall be dereferenceable. *a shall be swappable\nwith *b. (17.6.3.2)</p></li>\n</ul>\n<hr>\n<p>Thus iter_swap is required to exchange the values stored in two dereferenced locations or ranges of dereferenced locations, and any attempt to exchange the references or locations themselves is fighting against conformance. That clearly disables speculating about optimizations being the reason lying behind std::iter_swap. Instead, as Potatoswatter was properly pointing out, encapsulation and abstraction are the main reasons of its existence. std::iter_swap and std::swap each belong to diferent abstraction layers, the same way std::swap itself and any binary non-member function named \"swap\" selected via overload resolution differ.</p>\n<p>Swap developer and designer roles to understand achieving the same result does not mean being the same, as in \"even declaring a typedef from a fundamental type is just noise for a compiler, it is not noise for the reader\". Take it as a joke, but we could argue whole C++ is just a deprecatable artifact wraping C, since both do the same thing while in the lowest level, and so on with any code block representing abstraction from another by means of a wrapper. Specially when the line is so thin as in the case of std::iter_swap, \"swap\" and std::swap. Maybe \"using std::swap\" has only a few caracters and it disappears once compiled, but means injecting an identifier and building a whole overload resolution mechanism. Injected over and over, built over and over, replaced over and over, discarded over and over. Far from an abstract, encapsulated and recycled approach.</p>\n<p>Exposing the inner work trought the upper layer gives and aditional potential chance of failure on maintenance. In the swap domain, missing (or messing) a \"using std::swap\" on a deep metaprogramming containment design will silently wait inside your template function, waiting for a trivially swappable, fundamental or c-array type to break the build, if lucky, or even StackOverflow(TM) by means of infinite recursion. Obviously implementation of an extensible mechanism has to be published, but also has to be respected. About trivially swappable, mind anything moveconstructible and moveassignable is swappable against its own type even if it lacks of an overloaded swap resolution hook, and indeed there are obscure techniques to disable unwanted swappable behaviors.</p>\n<p>With that on mind, maybe it all can be resumed in an unproper interpretation of the std::iter_swap identifier itself: it does not stand for \"iterator swapping\", but \"iterable swapping\". Don't be fooled by the standard requirements on arguments being forward iterators: in essence, a pointer is a random access iterator, thus satisfying the requirements. Phisically u pass by pointer, logically u pass by iterator. The commission usually tries to specify the minimal requirements for a facility to work with defined and expected behavior, nothing more. The \"iterable swapping\" name rightly exposes the goal and powers of the mechanism. the \"std::iter_swap\" identifier seems not due to confusion generated, but it is too late to change it and undo all the codebase relying on.</p>\n<p>Feel free to swap as u wish as long as it works, but please not on my watch. Mixing abstraction layers won't make the compiler cry, but interfaces are just too cool to avoid. Instead, here is a snippet to help guidance in the future:</p>\n<pre><code>//#include &lt;utility&gt; // std::swap is not required here\n#include &lt;algorithm&gt; // std::iter_swap is\n\nnamespace linker {\n\n    class base {\n    };\n\n    class member {\n    };\n\n    template&lt;class M = member, class B = base&gt; // requires swappable base and member\n    class link : B {\n    public:\n        void swap(link &amp;other) { // using iterable swapping\n            std::iter_swap(static_cast&lt;B*&gt;(this), static_cast&lt;B*&gt;(&amp;other));\n            std::iter_swap(&amp;_member, &amp;other._member);\n        }\n    private:\n        M _member;\n    };\n\n    template&lt;class base, class member&gt;\n    void swap(link&lt;base,member&gt;&amp; left, link&lt;base,member&gt;&amp; right) { // extending iterable swapping\n        left.swap(right);\n    }\n\n}\n\nnamespace processor {\n\n    template&lt;class A, class B&gt;\n    void process(A &amp;a, B &amp;b) { // using iterable swapping\n        std::iter_swap(&amp;a, &amp;b);\n    }\n\n}\n\nint main() {\n#if !defined(PLEASE_NO_WEIRDNESS)\n    typedef\n        linker::link&lt;\n            linker::link&lt;\n                linker::link&lt; int[1] &gt;,\n                linker::link&lt; void*, linker::link&lt;&gt; &gt;\n            &gt;[2],\n            linker::link&lt;\n                linker::member[3]\n            &gt;\n        &gt;\n    swappable[4]; // just an array of n-ary hierarchies\n#else\n    typedef linker::link&lt;&gt; swappable;\n#endif\n    swappable a, b;\n    processor::process(a, b);\n}\n</code></pre>\n<p>Some points of interest as aditional guidance:</p>\n<ul>\n<li><p>Swapping means thrown exceptions. Statement seems stupid, but it isn't once u know swap idiom is not focused on performance but on extreme safety and robustness.</p></li>\n<li><p>std::iter_swap showcase one of the many lovely but overlooked features of metaprogramming: a template not only does overload resolution but also namespace resolution, allowing its use as the first in a chain of unknown and unrelated namespaces. Thanks, one thing less to worry about.</p></li>\n<li><p>Swappable requirements allows u to use std::swap directly if (and\nONLY IF) u can afford making the assumption of both targets being of\nfundamental or c-array to fundamental types, thus allowing the\ncompiler to bypass any overload resolution. Sadly that rules out the\nparameters of almost every template. Using std::swap directly implies\nboth targets are of the same type (or forced to be of the same type).</p></li>\n<li><p>Don't waste efforts on declaring swapable capabilities on a type wich\nalready is trivially swappable with itself, just like our link template\nclass (try removing linker::swap, behavior won't change at all).<br>\n\u201cswap\u201d was designed to be extensible to swap from diferent types,<br>\nautomatic for same types. Mind a type is not \"swappable\" or<br>\n\"non-swappable\" by itself, but \"swappable-with\" or<br>\n\"non-swappable-with\" another type.</br></br></br></br></p></li>\n</ul>\n<p>Finally, I wonder how many readers will notice</p>\n<ul>\n<li><p>20.2.2 swap [utility.swap]</p></li>\n<li><p>25.3.3 swap [alg.swap]</p></li>\n</ul>\n<p>and recognize an utility is not an algorithm. In the Microsoft-Dinkumware implementation, among others, std::iter_swap just lives in the wrong header for convenience, wich isn't wrong. Maybe just it's identifier is.</p>\n<hr>\n<p>Edit: After being faced with some more related mistakes, tought i could sumarize them like this: an algorithm is a concept so generic and specific, every time someone is about to specialize one of them, a designer cries somewhere else. In the case of std::iter_swap, since commitee clearly gives no freedom, any attempt to tweak the algorithm as in the relinking speculations would deserve a different meaning and identifier. Also maybe someone missed containers do have a swap member function, where optimizations do apply.</p>\n<p>Better refactor so your final layer objects are nondata, fundamental, or represent hidden heavier objects (streamed if heavy enough). Embrace that resource adquisition should be initialization (<a href=\"https://www.google.com/search?hl=en&amp;q=raii\" rel=\"nofollow\" title=\"RAII\">RAII</a>) and both new-delete overloads and container allocators have a <a href=\"https://www.google.com/search?hl=en&amp;q=boost%20pool\" rel=\"nofollow\" title=\"use\">use</a>, to unleash true swap benefits with zero aditional effort. Optimize resources so u move data only on readquisition, then let C++ design your types easy, safe and fast by default.</p>\n<p>Motto: Back in the old days, people struggled with data that was too fat on memory, too slow on disk. Nowadays, iterator vectors are filtered from storage pools, and streamed to be processed in parallel pipes. Tomorrow cars will drive alone. Deserves a PostIt.</p>\n</hr></hr></hr>", "OwnerUserId": "2421456", "LastEditorUserId": "2421456", "LastEditDate": "2013-05-28T19:13:47.233", "Id": "16764680", "Score": "0", "CreationDate": "2013-05-26T23:39:32.343", "LastActivityDate": "2013-05-28T19:13:47.233"}, "bq_ids": {"n4140": {"so_14024228_14500519_0": {"section_id": 6279, "quality": 0.8947368421052632, "length": 17}, "so_14024228_14500519_2": {"section_id": 6279, "quality": 0.8333333333333334, "length": 5}, "so_14024228_14500519_1": {"section_id": 6279, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_14024228_14500519_0": {"section_id": 6039, "quality": 0.8947368421052632, "length": 17}, "so_14024228_14500519_2": {"section_id": 6039, "quality": 0.8333333333333334, "length": 5}, "so_14024228_14500519_1": {"section_id": 6039, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_14024228_14500519_0": {"section_id": 7786, "quality": 0.8947368421052632, "length": 17}, "so_14024228_14500519_2": {"section_id": 7786, "quality": 0.8333333333333334, "length": 5}, "so_14024228_14500519_1": {"section_id": 7786, "quality": 0.8571428571428571, "length": 6}}}, "14494228": {"ParentId": "14024228", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>This seems to be one of those scenarios in which the internet produces a host of conflicting information.</p>\n<ul>\n<li><p><a href=\"http://www.cplusplus.com/reference/algorithm/iter_swap/\" rel=\"noreferrer\">cplusplus.com says that <code>iter_swap</code> is identical to <code>swap</code></a> and, by that logic, MSDN would be correct in saying that one ought to simply stick to <code>swap</code>.</p></li>\n<li><p><a href=\"http://en.cppreference.com/w/cpp/algorithm/iter_swap\" rel=\"noreferrer\">cppreference.com tells us that calling <code>swap</code> is merely <em>a possible implementation</em> for <code>iter_swap</code></a>, opening the door for possible optimisations in <code>iter_swap</code> for certain specialisations, as long as the function's constant complexity guarantee is upheld.</p></li>\n</ul>\n<p>The standard, under <code>[C++11: 25.3.3/5]</code>, says only that <code>iter_swap(a,b)</code> has the result <code>swap(*a,*b)</code> (and requires that \"<code>a</code> and <code>b</code> shall be dereferenceable\", and that \"<code>*a</code> shall be swappable with <code>*b</code>\") which would at first glance correlate with MSDN's interpretation.</p>\n<p>However, I believe Microsoft have neglected to consider the as-if rule, which should allow an implementation to make <code>iter_swap</code> faster than <code>swap</code> in certain cases (e.g. elements of a linked list).</p>\n<p><strong>I would therefore trust that the <code>comp.std.c++</code> quote is the more technically accurate of the two.</strong></p>\n<p>That being said, there is a fairly strict limit on the optimisation that may be performed. Consider, for example, an implementation of <code>iter_swap</code> over linked list elements that simply re-links nodes rather than physically swapping the element values \u2014 this is <em>not</em> a valid implementation, because the requirement that <code>iter_swap</code>'s observable behaviour match <code>swap</code>'s is violated.</p>\n<p><strong>I would therefore suggest that <em>in practice</em> there can be little if any benefit to preferring <code>iter_swap</code> over <code>swap</code></strong>, and I'd recommend sticking to the latter for simplicity and consistency. C++11 move semantics ought to make <code>swap</code> a cinch in many cases anyway.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2013-05-25T08:11:28.547", "Id": "14494228", "Score": "13", "CreationDate": "2013-01-24T04:54:52.653", "LastActivityDate": "2013-05-25T08:11:28.547"}});