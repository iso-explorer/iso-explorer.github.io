post_cb({"39563992": {"Id": "39563992", "PostTypeId": "2", "Body": "<p>If you checkout <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/operator_bool\" rel=\"nofollow\"><code>std::shared_ptr</code></a>'s bool conversion operator, you will see that it's declared as:</p>\n<pre><code>explicit operator bool() const;\n</code></pre>\n<p>The use of <code>explicit</code> simply tells the compiler to forbid <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion\" rel=\"nofollow\">implicit conversion</a>, which is what would have taken place because the return type of your function is different from the object type you are returning. However, this doesn't affect <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion#Contextual_conversions\" rel=\"nofollow\"><em>contextual conversions</em></a>.</p>\n<p>which occurs in the context of any:</p>\n<blockquote id=\"so_39563948_39563992_0\">\n<ul>\n<li>controlling expression of <code>if</code>, <code>while</code>, <code>for</code>;</li>\n<li>the logical operators <code>!</code>, <code>&amp;&amp;</code> and <code>||</code>;</li>\n<li>the conditional operator <code>?:</code>;</li>\n<li><code>static_assert</code>;</li>\n<li><code>noexcept</code>.</li>\n</ul>\n</blockquote>\n<p><em>above quote cited from cppreference</em></p>\n", "LastEditorUserId": "1621391", "LastActivityDate": "2016-09-19T01:02:15.493", "Score": "6", "CreationDate": "2016-09-19T00:51:27.920", "ParentId": "39563948", "CommentCount": "2", "OwnerUserId": "1621391", "LastEditDate": "2016-09-19T01:02:15.493"}, "39564002": {"Id": "39564002", "PostTypeId": "2", "Body": "<h2>Why the code doesn't compile.</h2>\n<p><code>std::shared_ptr</code>'s conversion-to-<code>bool</code> operator is declared <code>explicit</code> and so will generally not be invoked for an implicit conversion.</p>\n<p>In particular it will not be invoked in the context of a <code>return</code> statement.</p>\n<p>And it will not be considered for choosing a function overload, i.e. <code>foo(p)</code> will not resolve to an overload of <code>foo</code> that takes a <code>bool</code> argument.</p>\n<p>There are however umpteen ways to express the conversion explicitly, including:</p>\n<pre><code>!!ptr\n\nptr != nullptr\n\nptr.get() != nullptr\n\nstatic_cast&lt;bool&gt;( ptr )\n\nptr.operator bool()\n</code></pre>\n<hr>\n<h2>The general case for implicit conversion to <code>bool</code>.</h2>\n<p>There are some cases where <code>explicit</code> on an <code>operator bool()</code> is <em>ignored</em>, in order to make things work mainly as in C++03. That is, to make things work as with the schemes employed before <code>explicit</code> was allowed on conversion operators in C++11. These exceptions are</p>\n<ul>\n<li><p>use as a (grammar production) <em>condition</em> in an <code>if</code>, <code>while</code> or <code>for</code>, but not in a <code>switch</code>,</p></li>\n<li><p>use as condition in <code>:?</code> choice, <code>static_assert</code> or <code>noexcept</code>,</p></li>\n<li><p>use as argument to the built-in boolean operators <code>&amp;&amp;</code>, <code>||</code> and <code>!</code>, or their equivalents <code>and</code>, <code>or</code> and <code>not</code>.</p></li>\n</ul>\n<p>Notably, again, these exceptions that allow implicit conversion to <code>bool</code> in spite of <code>explicit</code>, known as <strong>contextual conversions</strong>, do not include a <code>return</code> statement expression.</p>\n<hr>\n<h2>Can <code>explicit</code> be ignored also in other cases?</h2>\n<p>In what other cases, if any, can <code>explicit</code> on a conversion operator be ignored?</p>\n<p>Well, none. But a non-<code>explicit</code> conversion operator, that is, an implicit conversion operator, can be invoked implicitly where the exact type to be converted to is not specified by the context.</p>\n<i>C++11 \u00a74/5 (conv):</i>\n<blockquote>\n<p id=\"so_39563948_39564002_0\"><strong>\u201d</strong> Certain language constructs require conversion to a value having one of a specified set of types appropriate\n  to the construct. An expression <code>e</code> of class type <code>E</code> appearing in such a context is said to be <strong><em>contextually implicitly converted</em></strong> to a specified type <code>T</code> and is well-formed if and only if <code>e</code> can be implicitly converted to\n  a type <code>T</code> that is determined as follows: <code>E</code> is searched for conversion functions whose return type is <em>cv</em> <code>T</code> or reference to <em>cv</em> <code>T</code> such that <code>T</code> is allowed by the context. There shall be exactly one such <code>T</code>.</p>\n</blockquote>\n<p>For example,</p>\n<i>C++11 \u00a75.3.5/1 (expr.delete):</i>\n<blockquote>\n<p id=\"so_39563948_39564002_1\"><strong>\u201d</strong>  If of class type, the operand [of <code>delete</code>] is contextually\n  implicitly converted (Clause 4) to a pointer to object type.</p>\n</blockquote>\n<p>\u2026 and so, a bit counter-intuitive to me!, the following should compile with a conforming compiler:</p>\n<pre><code>struct Foo\n{\n    operator int*() const { return nullptr; }\n};\n\nauto main()\n    -&gt; int\n{\n    delete Foo();\n}\n</code></pre>\n</hr></hr>", "LastEditorUserId": "464581", "LastActivityDate": "2016-09-19T12:46:11.043", "Score": "1", "CreationDate": "2016-09-19T00:52:40.930", "ParentId": "39563948", "CommentCount": "0", "OwnerUserId": "464581", "LastEditDate": "2016-09-19T12:46:11.043"}, "39563948": {"ViewCount": "160", "Body": "<p>I'm using g++ and write a simple function:</p>\n<pre><code>#include &lt;memory&gt;\n\nstd::shared_ptr&lt;char&gt; ptr;\n\nbool fails_compiling()\n{\n    return ptr;\n}\n</code></pre>\n<p>From what I can see in the interface, the <code>shared_ptr</code> implementation includes a <code>bool</code> operator and I can even apply a quick fix like this:</p>\n<pre><code>    return static_cast&lt;bool&gt;(ptr);\n</code></pre>\n<p>And it now compiles.</p>\n<p>Why would the return algorithm not attempt an auto-conversion to <code>bool</code> like the <code>if()</code> and <code>while()</code> do?</p>\n", "AcceptedAnswerId": "39563992", "Title": "Why can't I return a shared pointer in C++14 when the function return type is bool?", "CreationDate": "2016-09-19T00:42:22.067", "Id": "39563948", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2016-09-19T12:46:11.043", "Score": "7", "OwnerUserId": "212378", "Tags": "<c++><return><return-value><smart-pointers><boolean-expression>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_39563948_39564002_0": {"length": 46, "quality": 1.0, "section_id": 4}, "so_39563948_39564002_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6105}}, "n3337": {"so_39563948_39564002_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 5872}}, "n4659": {"so_39563948_39564002_0": {"length": 45, "quality": 0.9782608695652174, "section_id": 4}, "so_39563948_39564002_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7602}}}, "39563995": {"Id": "39563995", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_39563948_39563995_0\">Why would the return algorithm not attempt an auto-conversion to <code>bool</code> like the <code>if()</code> and <code>while()</code> do?</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/operator_bool\" rel=\"nofollow\">std::shared_ptr::operator bool</a> is <code>explicit</code> conversion function, so implicit conversion is not allowed, but <code>static_cast</code> (explicit conversion) works well.</p>\n<p>When used for <code>if</code> or <code>while</code>, <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion#Contextual_conversions\" rel=\"nofollow\">contextual conversions</a> takes effect, then the explicit user-defined conversion function will be considered. In this case, <code>std::shared_ptr</code> is <em>contextually convertible to <code>bool</code></em>. </p>\n<blockquote>\n<p id=\"so_39563948_39563995_1\">In the following five contexts, the type <code>bool</code> is expected and the implicit conversion sequence is built if the declaration <code>bool t(e);</code> is well-formed. that is, the explicit user-defined conversion function such as <code>explicit T::operator bool() const;</code> is considered. Such expression e is said to be <em>contextually convertible to bool</em>. </p>\n<ul>\n<li>controlling expression of if, while, for;</li>\n<li>the logical operators !, &amp;&amp; and ||;</li>\n<li>the conditional operator ?:;</li>\n<li>static_assert;</li>\n<li>noexcept.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2016-09-19T01:02:39.267", "Score": "2", "CreationDate": "2016-09-19T00:51:45.453", "ParentId": "39563948", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2016-09-19T01:02:39.267"}});