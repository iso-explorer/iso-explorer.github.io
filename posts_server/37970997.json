post_cb({"bq_ids": {"n4140": {"so_37970997_37971922_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 1537}, "so_37970997_37971922_2": {"length": 10, "quality": 0.5555555555555556, "section_id": 472}, "so_37970997_37971922_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 467}}, "n3337": {"so_37970997_37971922_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 1531}, "so_37970997_37971922_2": {"length": 13, "quality": 0.7222222222222222, "section_id": 463}, "so_37970997_37971922_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 447}}, "n4659": {"so_37970997_37971922_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 1687}, "so_37970997_37971922_2": {"length": 12, "quality": 0.6666666666666666, "section_id": 495}, "so_37970997_37971922_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 490}}}, "37970997": {"ViewCount": "84", "Body": "<p>I have the following code:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n\nstruct S {\n    const std::string str;\n};\n\nint main() {\n    std::vector&lt;S&gt; v;\n    const std::string test(\"test\");\n    S s;\n    v.push_back(s);\n}\n</code></pre>\n<p>It compiles fine with g++ 4.8.5:</p>\n<pre><code>$ g++ --version\ng++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-4)\nCopyright (C) 2015 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n</code></pre>\n<p>But when I tried to compile it with g++ 4.6.2, I got the following errors:</p>\n<pre><code>In file included from /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/vector:70:0,\n                 from compilerTest.cpp:2:\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/vector.tcc: In member function \u2018void std::vector&lt;_Tp, _Alloc&gt;::_M_insert_aux(std::vector&lt;_Tp, _Alloc&gt;::iterator, _Args&amp;&amp; ...) [with _Args = {const S&amp;}, _Tp = S, _Alloc = std::allocator&lt;S&gt;, std::vector&lt;_Tp, _Alloc&gt;::iterator = __gnu_cxx::__normal_iterator&lt;S*, std::vector&lt;S&gt; &gt;, typename std::_Vector_base&lt;_Tp, _Alloc&gt;::_Tp_alloc_type::pointer = S*]\u2019:\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_vector.h:834:4:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::push_back(const value_type&amp;) [with _Tp = S, _Alloc = std::allocator&lt;S&gt;, std::vector&lt;_Tp, _Alloc&gt;::value_type = S]\u2019\ncompilerTest.cpp:12:14:   instantiated from here\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/vector.tcc:319:4: error: use of deleted function \u2018S&amp; S::operator=(const S&amp;)\u2019\ncompilerTest.cpp:4:8: error: \u2018S&amp; S::operator=(const S&amp;)\u2019 is implicitly deleted because the default definition would be ill-formed:\ncompilerTest.cpp:4:8: error: passing \u2018const string {aka const std::basic_string&lt;char&gt;}\u2019 as \u2018this\u2019 argument of \u2018std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; std::basic_string&lt;_CharT, _Traits, _Alloc&gt;::operator=(const std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;, _Alloc = std::allocator&lt;char&gt;, std::basic_string&lt;_CharT, _Traits, _Alloc&gt; = std::basic_string&lt;char&gt;]\u2019 discards qualifiers [-fpermissive]\nIn file included from /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/char_traits.h:41:0,\n                 from /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/string:42,\n                 from compilerTest.cpp:1:\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_algobase.h: In static member function \u2018static _BI2 std::__copy_move_backward&lt;true, false, std::random_access_iterator_tag&gt;::__copy_move_b(_BI1, _BI1, _BI2) [with _BI1 = S*, _BI2 = S*]\u2019:\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_algobase.h:581:18:   instantiated from \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2) [with bool _IsMove = true, _BI1 = S*, _BI2 = S*]\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_algobase.h:590:34:   instantiated from \u2018_BI2 std::__copy_move_backward_a2(_BI1, _BI1, _BI2) [with bool _IsMove = true, _BI1 = S*, _BI2 = S*]\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_algobase.h:661:15:   instantiated from \u2018_BI2 std::move_backward(_BI1, _BI1, _BI2) [with _BI1 = S*, _BI2 = S*]\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/vector.tcc:313:4:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::_M_insert_aux(std::vector&lt;_Tp, _Alloc&gt;::iterator, _Args&amp;&amp; ...) [with _Args = {const S&amp;}, _Tp = S, _Alloc = std::allocator&lt;S&gt;, std::vector&lt;_Tp, _Alloc&gt;::iterator = __gnu_cxx::__normal_iterator&lt;S*, std::vector&lt;S&gt; &gt;, typename std::_Vector_base&lt;_Tp, _Alloc&gt;::_Tp_alloc_type::pointer = S*]\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_vector.h:834:4:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::push_back(const value_type&amp;) [with _Tp = S, _Alloc = std::allocator&lt;S&gt;, std::vector&lt;_Tp, _Alloc&gt;::value_type = S]\u2019\ncompilerTest.cpp:12:14:   instantiated from here\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_algobase.h:546:6: error: use of deleted function \u2018S&amp; S::operator=(const S&amp;)\u2019\n</code></pre>\n<p>Why <code>S&amp; S::operator=(const S&amp;)</code> is \"deleted\"?</p>\n<p>I was using the command to compile:</p>\n<pre><code>g++ -Wall compilerTest.cpp -o compilerTest -std=c++0x\n</code></pre>\n<p>Even I uses emplace_back(), it gives me similar error:</p>\n<pre><code>In file included from /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/x86_64-redhat-linux/bits/c++allocator.h:34:0,\n                 from /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/allocator.h:48,\n                 from /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/string:43,\n                 from compilerTest.cpp:1:\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/ext/new_allocator.h: In member function \u2018void __gnu_cxx::new_allocator&lt;_Tp&gt;::construct(__gnu_cxx::new_allocator&lt;_Tp&gt;::pointer, _Args&amp;&amp; ...) [with _Args = {std::basic_string&lt;char&gt;&amp;}, _Tp = S, __gnu_cxx::new_allocator&lt;_Tp&gt;::pointer = S*]\u2019:\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/vector.tcc:97:6:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::emplace_back(_Args&amp;&amp; ...) [with _Args = {std::basic_string&lt;char&gt;&amp;}, _Tp = S, _Alloc = std::allocator&lt;S&gt;]\u2019\ncompilerTest.cpp:11:18:   instantiated from here\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/ext/new_allocator.h:114:4: error: no matching function for call to \u2018S::S(std::basic_string&lt;char&gt;&amp;)\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/ext/new_allocator.h:114:4: note: candidates are:\ncompilerTest.cpp:4:8: note: S::S()\ncompilerTest.cpp:4:8: note:   candidate expects 0 arguments, 1 provided\ncompilerTest.cpp:4:8: note: S::S(const S&amp;)\ncompilerTest.cpp:4:8: note:   no known conversion for argument 1 from \u2018std::basic_string&lt;char&gt;\u2019 to \u2018const S&amp;\u2019\nIn file included from /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/vector:70:0,\n                 from compilerTest.cpp:2:\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/vector.tcc: In member function \u2018void std::vector&lt;_Tp, _Alloc&gt;::_M_insert_aux(std::vector&lt;_Tp, _Alloc&gt;::iterator, _Args&amp;&amp; ...) [with _Args = {std::basic_string&lt;char&gt;&amp;}, _Tp = S, _Alloc = std::allocator&lt;S&gt;, std::vector&lt;_Tp, _Alloc&gt;::iterator = __gnu_cxx::__normal_iterator&lt;S*, std::vector&lt;S&gt; &gt;, typename std::_Vector_base&lt;_Tp, _Alloc&gt;::_Tp_alloc_type::pointer = S*]\u2019:\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/vector.tcc:102:4:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::emplace_back(_Args&amp;&amp; ...) [with _Args = {std::basic_string&lt;char&gt;&amp;}, _Tp = S, _Alloc = std::allocator&lt;S&gt;]\u2019\ncompilerTest.cpp:11:18:   instantiated from here\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/vector.tcc:319:4: error: no matching function for call to \u2018S::S(std::basic_string&lt;char&gt;&amp;)\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/vector.tcc:319:4: note: candidates are:\ncompilerTest.cpp:4:8: note: S::S()\ncompilerTest.cpp:4:8: note:   candidate expects 0 arguments, 1 provided\ncompilerTest.cpp:4:8: note: S::S(const S&amp;)\ncompilerTest.cpp:4:8: note:   no known conversion for argument 1 from \u2018std::basic_string&lt;char&gt;\u2019 to \u2018const S&amp;\u2019\nIn file included from /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/char_traits.h:41:0,\n                 from /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/string:42,\n                 from compilerTest.cpp:1:\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_algobase.h: In static member function \u2018static _BI2 std::__copy_move_backward&lt;true, false, std::random_access_iterator_tag&gt;::__copy_move_b(_BI1, _BI1, _BI2) [with _BI1 = S*, _BI2 = S*]\u2019:\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_algobase.h:581:18:   instantiated from \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2) [with bool _IsMove = true, _BI1 = S*, _BI2 = S*]\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_algobase.h:590:34:   instantiated from \u2018_BI2 std::__copy_move_backward_a2(_BI1, _BI1, _BI2) [with bool _IsMove = true, _BI1 = S*, _BI2 = S*]\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_algobase.h:661:15:   instantiated from \u2018_BI2 std::move_backward(_BI1, _BI1, _BI2) [with _BI1 = S*, _BI2 = S*]\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/vector.tcc:313:4:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::_M_insert_aux(std::vector&lt;_Tp, _Alloc&gt;::iterator, _Args&amp;&amp; ...) [with _Args = {std::basic_string&lt;char&gt;&amp;}, _Tp = S, _Alloc = std::allocator&lt;S&gt;, std::vector&lt;_Tp, _Alloc&gt;::iterator = __gnu_cxx::__normal_iterator&lt;S*, std::vector&lt;S&gt; &gt;, typename std::_Vector_base&lt;_Tp, _Alloc&gt;::_Tp_alloc_type::pointer = S*]\u2019\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/vector.tcc:102:4:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::emplace_back(_Args&amp;&amp; ...) [with _Args = {std::basic_string&lt;char&gt;&amp;}, _Tp = S, _Alloc = std::allocator&lt;S&gt;]\u2019\ncompilerTest.cpp:11:18:   instantiated from here\n/usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_algobase.h:546:6: error: use of deleted function \u2018S&amp; S::operator=(const S&amp;)\u2019\ncompilerTest.cpp:4:8: error: \u2018S&amp; S::operator=(const S&amp;)\u2019 is implicitly deleted because the default definition would be ill-formed:\ncompilerTest.cpp:4:8: error: passing \u2018const string {aka const std::basic_string&lt;char&gt;}\u2019 as \u2018this\u2019 argument of \u2018std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; std::basic_string&lt;_CharT, _Traits, _Alloc&gt;::operator=(const std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;, _Alloc = std::allocator&lt;char&gt;, std::basic_string&lt;_CharT, _Traits, _Alloc&gt; = std::basic_string&lt;char&gt;]\u2019 discards qualifiers [-fpermissive]\n</code></pre>\n", "AcceptedAnswerId": "37971922", "Title": "Signature of Generated operator=()?", "CreationDate": "2016-06-22T14:26:44.850", "Id": "37970997", "CommentCount": "6", "LastEditDate": "2016-06-22T14:50:36.027", "PostTypeId": "1", "LastEditorUserId": "2206057", "LastActivityDate": "2016-06-22T15:25:36.080", "Score": "2", "OwnerUserId": "2206057", "Tags": "<c++><c++11><g++>", "AnswerCount": "2"}, "37971886": {"Id": "37971886", "PostTypeId": "2", "Body": "<p>Copy assignment is implicitly deleted when you have a non static const member</p>\n<p>That's because the object that you copy into is not re-initialized, so you have an existing const that you can't reassign into.</p>\n<p>In your case there's not full support of C++11, which requires vector members to have copy assignment</p>\n", "LastActivityDate": "2016-06-22T15:05:27.150", "CommentCount": "0", "CreationDate": "2016-06-22T15:05:27.150", "ParentId": "37970997", "Score": "2", "OwnerUserId": "5281853"}, "37971922": {"Id": "37971922", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_37970997_37971922_0\">Why S&amp; S::operator=(const S&amp;) is \"deleted\"?</p>\n</blockquote>\n<p>Because <code>S</code> has a <code>const</code> member <code>str</code> which makes the defaulted copy assignment operator is defined as <a href=\"http://en.cppreference.com/w/cpp/language/copy_assignment#Deleted_implicitly-declared_copy_assignment_operator\" rel=\"nofollow\">deleted</a>.</p>\n<blockquote>\n<p id=\"so_37970997_37971922_1\">A defaulted copy assignment operator for class <code>T</code> is defined as deleted if any of the following is true:</p>\n<p id=\"so_37970997_37971922_2\"><code>T</code> has a non-static data member or a direct or virtual base class that cannot be copy-assigned (overload resolution for the copy assignment fails, or selects a deleted or inaccessible function); </p>\n</blockquote>\n<p>It's impossible to call <code>operator=</code> on a <code>const string</code>, it's a non-const member function.</p>\n<p>And the type requirements of <a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"nofollow\"><code>std::vector</code></a> changed from C++11:</p>\n<blockquote>\n<p id=\"so_37970997_37971922_3\"><code>T</code> must meet the requirements of CopyAssignable and CopyConstructible.\n    (until C++11)</p>\n<p id=\"so_37970997_37971922_4\">The requirements that are imposed on the elements depend on the actual\n  operations performed on the container. Generally, it is required that\n  element type is a complete type and meets the requirements of\n  Erasable, but many member functions impose stricter requirements.\n    (since C++11)</p>\n</blockquote>\n<p>So from C++11 the requirment depends on the operation you performed. In fact, <a href=\"http://en.cppreference.com/w/cpp/container/vector/push_back\" rel=\"nofollow\"><code>std::vector::push_back</code></a> doesn't need type <code>T</code> to be <a href=\"http://en.cppreference.com/w/cpp/concept/CopyAssignable\" rel=\"nofollow\">CopyAssignable</a>, <a href=\"http://en.cppreference.com/w/cpp/concept/CopyInsertable\" rel=\"nofollow\">CopyInsertable</a> would be fine.</p>\n<blockquote>\n<p id=\"so_37970997_37971922_5\">Type requirements<br>\n  - T must meet the requirements of CopyInsertable in order to use overload (1).</br></p>\n</blockquote>\n<p>That's why it compiles with gcc4.8.5, but gcc4.6.2 complains the copy assignment operator is deleted. (AFAIK gcc supported C++11 from 4.8.1)</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2016-06-22T15:25:36.080", "Score": "4", "CreationDate": "2016-06-22T15:07:00.820", "ParentId": "37970997", "CommentCount": "7", "OwnerUserId": "3309790", "LastEditDate": "2016-06-22T15:25:36.080"}});