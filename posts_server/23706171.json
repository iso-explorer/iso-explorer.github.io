post_cb({"bq_ids": {"n4140": {"so_23706171_23706272_0": {"length": 19, "quality": 0.7916666666666666, "section_id": 757}, "so_23706171_23706272_1": {"length": 13, "quality": 0.7647058823529411, "section_id": 761}}, "n3337": {"so_23706171_23706272_1": {"length": 13, "quality": 0.7647058823529411, "section_id": 748}, "so_23706171_23706272_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 745}}, "n4659": {"so_23706171_23706272_1": {"length": 13, "quality": 0.7647058823529411, "section_id": 821}, "so_23706171_23706272_0": {"length": 19, "quality": 0.7916666666666666, "section_id": 817}}}, "23706284": {"Id": "23706284", "PostTypeId": "2", "Body": "<p>Elements with the same key will end up in the same bucket, but other elements may also end up in the same bucket.  You cannot infer that all elements in the same bucket have equivelent keys.</p>\n<p>I don't think the spec says this explicitly, but the way the unordered_map works is that it uses the hash of the key to determine which bucket the element goes in.  Two keys can hash to the same value, which would mean both keys would be put into the same bucket.  However, two elements with the same key will have the same hash, and thus <em>always</em> be in the same bucket.  Additionally Since the number of buckets can be set in the constructor, then each bucket must therefore contain a range of keys, though the ranges will change as the number of buckets changes.</p>\n<p>You could, have an unordered_multimap that attempted to use one bucket per 100 elements on average, which would be conforming (and rediculously silly), but if you had less than 100 elements it would be putting all of the elements into a single bucket.</p>\n", "LastEditorUserId": "845092", "LastActivityDate": "2014-05-17T00:39:37.360", "Score": "2", "CreationDate": "2014-05-17T00:09:38.220", "ParentId": "23706171", "CommentCount": "0", "OwnerUserId": "845092", "LastEditDate": "2014-05-17T00:39:37.360"}, "23706171": {"ViewCount": "692", "Body": "<p>On www.CPlusPlus.com, it states the following for unordered_multimap,</p>\n<blockquote>\n<p id=\"so_23706171_23706171_0\">Elements with equivalent keys are grouped together in the same bucket and in such a way that an iterator (see equal_range) can iterate through all of them.</p>\n</blockquote>\n<p>I know we cannot infer this from that statement, but I'd like to know if a given bucket <strong>only</strong> contains elements with the equivalent keys?</p>\n", "AcceptedAnswerId": "23706272", "Title": "Does std::unordered_multimap's bucket only contain elements with equivalent keys", "CreationDate": "2014-05-16T23:52:43.110", "Id": "23706171", "CommentCount": "1", "LastEditDate": "2014-05-17T00:39:54.700", "PostTypeId": "1", "LastEditorUserId": "1774667", "LastActivityDate": "2014-05-17T00:40:18.667", "Score": "3", "OwnerUserId": "2017206", "Tags": "<c++><std><unordered-map>", "AnswerCount": "2"}, "23706272": {"Id": "23706272", "PostTypeId": "2", "Body": "<p>Here are the only pertinent requirements:</p>\n<blockquote>\n<p id=\"so_23706171_23706272_0\"><code>[C++11: 23.2.5/5]:</code> Two values <code>k1</code> and <code>k2</code> of type <code>Key</code> are considered equivalent if the container\u2019s <code>key_equal</code> function object returns true when passed those values. If <code>k1</code> and <code>k2</code> are equivalent, the hash function shall return the same value for both. <em>[..]</em></p>\n<p id=\"so_23706171_23706272_1\"><code>[C++11: 23.2.5/8]:</code> The elements of an unordered associative container are organized into buckets. Keys with the same hash code appear in the same bucket. <em>[..]</em></p>\n</blockquote>\n<p>There is nothing prohibiting <em>all</em> elements with key hash <code>a</code> and <em>all</em> elements with key hash <code>b</code> from being stored in the same bucket. It is up to the standard library implementation that you use as to whether or not this fact is used.</p>\n<p>No standard wording exists to make this explicit; it's defined by omission.</p>\n", "LastActivityDate": "2014-05-17T00:08:01.330", "CommentCount": "6", "CreationDate": "2014-05-17T00:08:01.330", "ParentId": "23706171", "Score": "5", "OwnerUserId": "560648"}});