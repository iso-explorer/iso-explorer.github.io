post_cb({"24580747": {"Id": "24580747", "PostTypeId": "2", "Body": "<p>Short answer: there are no <code>constexpr</code> function parameters in <code>C++11/14</code>.</p>\n<p>Longer answer: in <code>test1()</code>, if <code>i</code> is not a compile-time constant, the function is still usable at run-time. But in <code>test2()</code>, it cannot be known to the compiler whether <code>i</code> is a compile-time constant, and yet it is required for the function to compile.</p>\n<p>E.g. the following code for <code>test1</code> will compile</p>\n<pre><code>int i = 0;    \nchar a = test1(\"Test\", i); // OK, runtime invocation of test1()\n\nconstexpr int i = 0;\nconstexpr char a = test1(\"Test\", i); // also OK, compile time invocation of test1()\n</code></pre>\n<p>Let's simply your <code>test2()</code> to </p>\n<pre><code>constexpr char test3(unsigned i)\n{\n    return t&lt;i&gt;::value;\n}\n</code></pre>\n<p>This will not compile for <code>test3(0)</code> because inside <code>test3()</code>, it cannot be proven that <code>i</code> is an <strong>unconditional</strong> compile-time expression. You would need <code>constexpr</code> function parameters to be able to express that.</p>\n<h2>Quote from the Standard</h2>\n<p><strong>5.19 Constant expressions [expr.const]</strong></p>\n<blockquote>\n<p id=\"so_24580714_24580747_0\">2 A conditional-expression e is a core constant expression unless the\n  evaluation of e, following the rules of the abstract machine (1.9),\n  would evaluate one of the following expressions:</p>\n<p id=\"so_24580714_24580747_1\">\u2014 an id-expression that refers to a variable or data member of\n  reference type unless the reference has a preceding initialization and\n  either<br>\n   \u2014 it is initialized with a constant expression or</br></p>\n<p id=\"so_24580714_24580747_2\">\u2014 it is a non-static data member of an object whose lifetime began within the evaluation of e;</p>\n</blockquote>\n<p>This section has the following code example corresponding to your question:</p>\n<pre><code>constexpr int f1(int k) {\n    constexpr int x = k; // error: x is not initialized by a\n                         // constant expression because lifetime of k\n                         // began outside the initializer of x\n    return x;\n}\n</code></pre>\n<p>Because <code>x</code> in the above example is not a constant expression, it means that you can't instantiate templates with either <code>x</code> or <code>k</code> inside <code>f1</code>.</p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2014-07-04T21:36:18.957", "Score": "19", "CreationDate": "2014-07-04T21:08:45.960", "ParentId": "24580714", "CommentCount": "4", "OwnerUserId": "819272", "LastEditDate": "2014-07-04T21:36:18.957"}, "24580714": {"ViewCount": "21631", "Body": "<p>In this trivial example, <code>test2</code> fails to compile even though <code>test1</code> succeeds, and I don't see why that is the case. If <code>arr[i]</code> is suitable for a return value from a function marked <code>constexpr</code> then why can it not be used as a non-type template argument?</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>template&lt;char c&gt;\nstruct t\n{ \n    static const char value = c;\n};\n\ntemplate &lt;unsigned N&gt;\nconstexpr char test1(const char (&amp;arr)[N], unsigned i)\n{\n    return arr[i];\n}\n\ntemplate &lt;unsigned N&gt;\nconstexpr char test2(const char (&amp;arr)[N], unsigned i)\n{\n    return t&lt;arr[i]&gt;::value;\n}\n\nint main()\n{\n   char a = test1(\"Test\", 0); //Compiles OK\n   char b = test2(\"Test\", 0); //error: non-type template argument \n                              //is not a constant expression\n}\n</code></pre>\n<p>Edit: This makes no difference:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>template&lt;char c&gt;\nstruct t\n{ \n    static const char value = c;\n};\n\ntemplate &lt;unsigned N&gt;\nconstexpr char test1(const char (&amp;arr)[N])\n{\n    return arr[0];\n}\n\ntemplate &lt;unsigned N&gt;\nconstexpr char test2(const char (&amp;arr)[N])\n{\n    return t&lt;arr[0]&gt;::value;\n}\n\nint main()\n{\n   char a = test1(\"Test\"); //Compiles OK\n   char b = test2(\"Test\"); //error: non-type template argument \n                           //is not a constant expression\n}\n</code></pre>\n", "AcceptedAnswerId": "24580747", "Title": "Why is this not a constant expression?", "CreationDate": "2014-07-04T21:04:20.780", "Id": "24580714", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-07-04T21:16:01.873", "LastEditorUserId": "897778", "LastActivityDate": "2014-07-04T21:39:39.100", "Score": "15", "OwnerUserId": "897778", "Tags": "<c++><templates><c++11><constexpr><c++14>", "AnswerCount": "4"}, "24580791": {"Id": "24580791", "PostTypeId": "2", "Body": "<p>Because <code>arr[i]</code> is not compile-time constant expression. It can be different at run-time.</p>\n", "LastActivityDate": "2014-07-04T21:13:37.437", "CommentCount": "3", "CreationDate": "2014-07-04T21:13:37.437", "ParentId": "24580714", "Score": "1", "OwnerUserId": "1742529"}, "24580956": {"Id": "24580956", "PostTypeId": "2", "Body": "<p>The problem here is that calling <code>arr[i]</code> evokes the subscript operator <code>operator[]</code>. <strong>This operator doesn't return a constant expression.</strong></p>\n<p>It's not a problem of <code>constexpr</code> actually, is a problem of template argument deduction. A Non type template argument must be a constant expression which the return argument of subscript operator is not.</p>\n<p>Therefore, the compiler rightfully complains that <code>arr[i]</code> is not a constant expression.</p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2014-07-04T21:39:39.100", "Score": "2", "CreationDate": "2014-07-04T21:33:41.667", "ParentId": "24580714", "CommentCount": "0", "OwnerUserId": "2352671", "LastEditDate": "2014-07-04T21:39:39.100"}, "bq_ids": {"n4140": {"so_24580714_24580747_1": {"length": 14, "quality": 1.0, "section_id": 6185}, "so_24580714_24580747_2": {"length": 9, "quality": 1.0, "section_id": 6185}, "so_24580714_24580747_0": {"length": 14, "quality": 1.0, "section_id": 6185}}, "n3337": {"so_24580714_24580747_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 5946}, "so_24580714_24580747_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 5759}}, "n4659": {"so_24580714_24580747_1": {"length": 14, "quality": 1.0, "section_id": 7687}, "so_24580714_24580747_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 7687}, "so_24580714_24580747_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 7687}}}, "24580943": {"Id": "24580943", "PostTypeId": "2", "Body": "<p>There's a misconception of what <code>constexpr</code> does here. It indicates that a function must be evaluatable at compile time for suitable arguments, but it does <em>not</em> remove the requirement still to compile in the general case.</p>\n<p>Let's take the first version:</p>\n<pre><code>template &lt;unsigned N&gt;\nconstexpr char test1(const char (&amp;arr)[N], unsigned i) {\n    return arr[i];\n}\n</code></pre>\n<p>Now, this is clearly a compile-time evaluation:</p>\n<pre><code>enum { CompileTimeConstant = test1(\"Test\", 0) };\n</code></pre>\n<p>your example <em>may</em> be, but it's an optimizer/QoI issue:</p>\n<pre><code>char MayBeCompileTimeConstant = test1(\"Test\", 0);\n</code></pre>\n<p>and this example obviously isn't, but is <em>still required to be evaluatable</em></p>\n<pre><code>char arr[10];\nint i;\nstd::cin &gt;&gt; i;\nstd::cin &gt;&gt; arr;\nchar b = test1(arr, i);\nstd::cout &lt;&lt; \"'\" &lt;&lt; arr &lt;&lt; \"'[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; b &lt;&lt; '\\n';\n</code></pre>\n<p>Since <code>test2</code> can't possibly compile in for the last case, it can't compile at all. (Please note I'm not suggesting that code is <em>good</em>).</p>\n", "LastActivityDate": "2014-07-04T21:32:18.767", "CommentCount": "0", "CreationDate": "2014-07-04T21:32:18.767", "ParentId": "24580714", "Score": "7", "OwnerUserId": "212858"}});