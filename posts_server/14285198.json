post_cb({"14285294": {"ParentId": "14285198", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>It's disallowed by the language:</p>\n<blockquote>\n<p id=\"so_14285198_14285294_0\"><code>[C++11: 7.1.6.4]:</code></p>\n<p id=\"so_14285198_14285294_1\"><sup>1</sup> The <code>auto</code> <em>type-specifier</em> signifies that the type of a variable being declared shall be deduced from its initializer or that a function declarator shall include a <em>trailing-return-type</em>.</p>\n<p id=\"so_14285198_14285294_2\"><sup>2</sup> The <code>auto</code> <em>type-specifier</em> may appear with a function declarator with a <em>trailing-return-type</em> (8.3.5) in any context where such a declarator is valid.</p>\n<p id=\"so_14285198_14285294_3\"><sup>3</sup> Otherwise, the type of the variable is deduced from its initializer. The name of the variable being declared shall not appear in the initializer expression. This use of <code>auto</code> is allowed when declaring variables in a block (6.3), in namespace scope (3.3.6), and in a <em>for-init-statement</em> (6.5.3). <code>auto</code> shall appear as one of the <em>decl-specifiers</em> in the <em>decl-specifier-seq</em> and the <em>decl-specifier-seq</em> shall be followed by one or more <em>init-declarators</em>, each of which shall have a non-empty <em>initializer</em>.</p>\n<p id=\"so_14285198_14285294_4\"><sup>4</sup> <strong>The <code>auto</code> <em>type-specifier</em> can also be used</strong> in declaring a variable in the <em>condition</em> of a selection statement (6.4) or an iteration statement (6.5), in the <em>type-specifier-seq</em> in the <em>new-type-id</em> or <em>type-id</em> of a <em>new-expression</em> (5.3.4), in a for-range-declaration, and <strong>in declaring a static data member with a <em>brace-or-equal-initializer</em> that appears within the <em>member-specification</em> of a class definition</strong> (9.4.2).</p>\n<p id=\"so_14285198_14285294_5\"><sup>5</sup> <strong>A program that uses <code>auto</code> in a context not explicitly allowed in this section is ill-formed.</strong></p>\n</blockquote>\n<p>It's hard to prove a negative, but there's simply no explicit rule in the standard to allow <code>auto</code> in your case.</p>\n<p>However, the same rules mean that the following <em>is</em> valid:</p>\n<pre><code>struct Foo {\n   static constexpr auto constant_string = \"foo\";\n};\n\nint main() {}\n</code></pre>\n<p>(Note that the type of <code>Foo::constant_string</code> is <code>char const* const</code> rather than, say, <code>char const[3]</code>; <a href=\"https://stackoverflow.com/questions/12016757/auto-with-string-literals\">this is an effect of using <code>auto</code></a>.)</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:44.080", "Id": "14285294", "Score": "10", "CreationDate": "2013-01-11T19:28:27.727", "LastActivityDate": "2013-01-12T02:15:02.687"}, "14285198": {"CommentCount": "2", "AcceptedAnswerId": "14285294", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2013-01-11T19:22:53.420", "LastActivityDate": "2015-07-31T14:52:07.977", "LastEditDate": "2013-01-16T19:56:58.033", "ViewCount": "6475", "FavoriteCount": "5", "Title": "Why doesn't the C++11 'auto' keyword work for static members?", "Id": "14285198", "Score": "11", "Body": "<pre><code>class Foo {\n public:\n  static const char *constant_string;\n};\n\nauto Foo::constant_string = \"foo\";\n\nint main(void) {\n};\n</code></pre>\n<p>Compiled with: gcc (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3 like this:</p>\n<pre><code>gcc -std=c++0x ./foo.cc \n./foo.cc:6:11: error: conflicting declaration \u2018auto Foo::constant_string\u2019\n./foo.cc:3:22: error: \u2018Foo::constant_string\u2019 has a previous declaration as \u2018const char* Foo::constant_string\u2019\n./foo.cc:6:11: error: declaration of \u2018const char* Foo::constant_string\u2019 outside of class is not definition [-fpermissive]\n</code></pre>\n<p>Is this intended behavior of the <code>auto</code> keyword, or a bug in gcc+</p>\n", "Tags": "<c++><c++11><auto>", "OwnerUserId": "66289", "AnswerCount": "2"}, "31749159": {"ParentId": "14285198", "CommentCount": "0", "Body": "<p>Visual C++ accepts</p>\n<pre><code>decltype(Foo::constant_string) Foo::constant_string = \"foo\";\n</code></pre>\n", "OwnerUserId": "65569", "PostTypeId": "2", "Id": "31749159", "Score": "2", "CreationDate": "2015-07-31T14:52:07.977", "LastActivityDate": "2015-07-31T14:52:07.977"}, "bq_ids": {"n4140": {"so_14285198_14285294_2": {"section_id": 5446, "quality": 0.6428571428571429, "length": 9}, "so_14285198_14285294_3": {"section_id": 5448, "quality": 0.6585365853658537, "length": 27}, "so_14285198_14285294_4": {"section_id": 5449, "quality": 0.6206896551724138, "length": 18}, "so_14285198_14285294_5": {"section_id": 5450, "quality": 1.0, "length": 7}}, "n3337": {"so_14285198_14285294_5": {"section_id": 5244, "quality": 1.0, "length": 7}, "so_14285198_14285294_3": {"section_id": 5242, "quality": 0.8780487804878049, "length": 36}, "so_14285198_14285294_4": {"section_id": 5243, "quality": 0.6551724137931034, "length": 19}, "so_14285198_14285294_1": {"section_id": 5240, "quality": 0.9333333333333333, "length": 14}, "so_14285198_14285294_2": {"section_id": 5241, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_14285198_14285294_5": {"section_id": 6877, "quality": 1.0, "length": 7}, "so_14285198_14285294_2": {"section_id": 6873, "quality": 0.6428571428571429, "length": 9}}}});