post_cb({"30047021": {"CommentCount": "2", "AcceptedAnswerId": "30047063", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2015-05-05T07:46:51.250", "LastActivityDate": "2017-04-13T22:41:30.467", "LastEditDate": "2016-01-07T20:25:36.260", "ViewCount": "3488", "FavoriteCount": "2", "Title": "Scope of enum in C vs C++", "Id": "30047021", "Score": "18", "Body": "<p>Why are enum values accessible outside the block in which enum is defined in C, but not in C++?</p>\n<p>Consider the following C program.</p>\n<pre><code>#include &lt;stdio.h&gt;\nstruct mystruct\n{\n    enum {INT, FLOAT, STRING} type;\n    int integer;\n    float floating_point;\n} tu;\n\n/* Why is INT accessible here? */\nint main()\n{\n    tu.type = INT;\n    tu.integer = 100;\n    return 0;\n}\n</code></pre>\n<p>It compiles and runs fine in C.</p>\n<p>But in C++ it fails in compilation.</p>\n<pre><code>#include &lt;iostream&gt;\nstruct mystruct\n{\n    enum {INT, FLOAT, STRING} type;\n    int integer;\n    float floating_point;\n} tu;\n\n/* Why is INT accessible here? */\nint main()\n{\n    tu.type = INT;\n    tu.integer = 100;\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_30047021_30047021_0\">[Error] 'INT' was not declared in this scope</p>\n</blockquote>\n<p>Are enum and scope rules different in C and C++?</p>\n", "Tags": "<c++><c><enums>", "OwnerUserId": "3777958", "AnswerCount": "3"}, "30047063": {"ParentId": "30047021", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In C, there is simply no rule for scope for enums and struct. The place where you define your enum doesn't have any importance.</p>\n<p>In C++, define something inside another something (like an enum in a class) make this something belong to the another something.</p>\n<p>If you want to make your enum global in C++, you will have to define it outside your class, or access from your struct path:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct mystruct\n{\n    enum {INT, FLOAT, STRING} type;\n    int integer;\n    float floating_point;\n} tu;\n\nint main()\n{\n    tu.type = mystruct::INT; // INT is not in global scope, I have to precise it.\n    tu.integer = 100;\n    return 0;\n}\n</code></pre>\n<p><strong>Note:</strong> This works in this exemple, because you are using a <code>struct</code>, where everything is <code>public</code> by default. Be careful; you can access your enum type and values from outside your struct or your class only if the enum is in a <code>public</code> scope, as any field or function.</p>\n", "OwnerUserId": "4745527", "LastEditorUserId": "63550", "LastEditDate": "2016-01-07T20:27:27.290", "Id": "30047063", "Score": "23", "CreationDate": "2015-05-05T07:48:59.413", "LastActivityDate": "2016-01-07T20:27:27.290"}, "30051459": {"ParentId": "30047021", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The answers given by Vlad and Arachtor are good as far as they go, but there is a question they do not address: why C++ does it differently. If someone is familiar with Stroustrup's book, they may be able to improve this, but I suppose:</p>\n<ul>\n<li>C was designed long ago to be fairly easy to compile, while C++ aims to make programming more reliable by using OO, whose main ideal is \u201cin one place, tell the user of a construct all they need to know to use it and no more\u201d; this has the often unspoken benefit of bringing together what belongs together.</li>\n<li>This leads to the decisions to use type definitions to limit the scope of some definitions, and to place constructs within a hierarchy of namespaces.</li>\n<li>By restricting the scope of a nested enum it is possible to use shorter names without risk of ambiguity or clashes.</li>\n</ul>\n", "OwnerUserId": "4847772", "LastEditorUserId": "4847772", "LastEditDate": "2017-04-13T22:41:30.467", "Id": "30051459", "Score": "5", "CreationDate": "2015-05-05T11:15:09.480", "LastActivityDate": "2017-04-13T22:41:30.467"}, "bq_ids": {"n4140": {"so_30047021_30048451_1": {"section_id": 7070, "quality": 0.9487179487179487, "length": 37}, "so_30047021_30048451_4": {"section_id": 7071, "quality": 0.9166666666666666, "length": 11}, "so_30047021_30048451_7": {"section_id": 5861, "quality": 1.0, "length": 9}, "so_30047021_30048451_5": {"section_id": 7071, "quality": 0.9166666666666666, "length": 11}, "so_30047021_30048451_6": {"section_id": 7071, "quality": 1.0, "length": 12}, "so_30047021_30048451_3": {"section_id": 7071, "quality": 1.0, "length": 10}, "so_30047021_30048451_2": {"section_id": 7071, "quality": 0.8, "length": 4}}, "n3337": {"so_30047021_30048451_1": {"section_id": 6814, "quality": 0.8717948717948718, "length": 34}, "so_30047021_30048451_4": {"section_id": 6815, "quality": 0.9166666666666666, "length": 11}, "so_30047021_30048451_7": {"section_id": 5631, "quality": 1.0, "length": 9}, "so_30047021_30048451_5": {"section_id": 6815, "quality": 0.9166666666666666, "length": 11}, "so_30047021_30048451_6": {"section_id": 6815, "quality": 1.0, "length": 12}, "so_30047021_30048451_3": {"section_id": 6815, "quality": 1.0, "length": 10}, "so_30047021_30048451_2": {"section_id": 6815, "quality": 0.8, "length": 4}}, "n4659": {"so_30047021_30048451_1": {"section_id": 8567, "quality": 0.7435897435897436, "length": 29}, "so_30047021_30048451_4": {"section_id": 8572, "quality": 0.9166666666666666, "length": 11}, "so_30047021_30048451_7": {"section_id": 7340, "quality": 1.0, "length": 9}, "so_30047021_30048451_5": {"section_id": 8572, "quality": 0.9166666666666666, "length": 11}, "so_30047021_30048451_6": {"section_id": 8572, "quality": 1.0, "length": 12}, "so_30047021_30048451_3": {"section_id": 8572, "quality": 1.0, "length": 10}, "so_30047021_30048451_2": {"section_id": 8572, "quality": 0.8, "length": 4}}}, "30048451": {"ParentId": "30047021", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The main difference is that opposite to C, C++ has a class scope.</p>\n<p>In C (6.2.1 Scopes of identifiers)</p>\n<blockquote>\n<p id=\"so_30047021_30048451_0\">4 Every other identifier has scope determined by the placement of its\n  declaration (in a declarator or type specifier). If the declarator or\n  type specifier that declares the identifier appears outside of any\n  block or list of parameters, the identifier has <strong>file scope</strong>, which\n  terminates at the end of the translation unit.</p>\n</blockquote>\n<p>Thus in this program</p>\n<pre><code>#include &lt;stdio.h&gt;\nstruct mystruct\n{\n    enum {INT, FLOAT, STRING} type;\n    int integer;\n    float floating_point;\n} tu;\n\n/* Why is INT accessible here? */\nint main()\n{\n    tu.type = INT;\n    tu.integer = 100;\n    return 0;\n}\n</code></pre>\n<p>Enumerators INT, FLOAT, STRING are declared outside any block scope and therefore have the file scope.</p>\n<p>In C++ there is defined a separate scope - class scope:</p>\n<p>3.3.7 Class scope</p>\n<blockquote>\n<p id=\"so_30047021_30048451_1\">1 The following rules describe the scope of names declared in classes.\n  1) The potential scope of a name declared in a class consists not only\n  of the declarative region following the name\u2019s point of declaration,\n  but also of all function bodies, default arguments,\n  exception-specifications, and brace-or-equal-initializers of\n  non-static data members in that class (including such things in nested\n  classes).</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_30047021_30048451_2\">2 <strong>The name of a class member shall only be used as follows:</strong></p>\n<p id=\"so_30047021_30048451_3\">\u2014 in the scope of its class (as described above) or a class derived\n  (Clause 10) from its class,</p>\n<p id=\"so_30047021_30048451_4\">\u2014 after the . operator applied to an expression of the type of its\n  class (5.2.5) or a class derived from its class,</p>\n<p id=\"so_30047021_30048451_5\">\u2014 after the -&gt; operator applied to a pointer to an object of its class\n  (5.2.5) or a class derived from its class,</p>\n<p id=\"so_30047021_30048451_6\">\u2014 after the :: scope resolution operator (5.1) applied to the name of\n  its class or a class derived from its class.</p>\n</blockquote>\n<p>Take into account that (9.2 Class members)</p>\n<blockquote>\n<p id=\"so_30047021_30048451_7\">1 ...Members of a class are data members, member functions (9.3),\n  nested types, and <strong>enumerators</strong>.</p>\n</blockquote>\n<p>Thus in this program</p>\n<pre><code>#include &lt;iostream&gt;\nstruct mystruct\n{\n    enum {INT, FLOAT, STRING} type;\n    int integer;\n    float floating_point;\n} tu;\n\n/* Why is INT accessible here? */\nint main()\n{\n    tu.type = INT;  // Invalid access of class member\n    tu.integer = 100;\n    return 0;\n}\n</code></pre>\n<p>You shall access class member <code>INT</code> in one of the following ways.</p>\n<pre><code>    tu.type = mystruct::INT;\n</code></pre>\n<p>or</p>\n<pre><code>    tu.type = tu.INT;\n</code></pre>\n<p>or even like</p>\n<pre><code>    tu.type = ( &amp;tu )-&gt;INT;\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "63550", "LastEditDate": "2016-01-07T20:28:59.753", "Id": "30048451", "Score": "12", "CreationDate": "2015-05-05T08:59:26.537", "LastActivityDate": "2016-01-07T20:28:59.753"}});