post_cb({"bq_ids": {"n4140": {"so_34861283_34863387_1": {"length": 57, "quality": 0.890625, "section_id": 6291}}, "n3337": {"so_34861283_34863387_1": {"length": 57, "quality": 0.890625, "section_id": 6051}}, "n4659": {"so_34861283_34863387_1": {"length": 57, "quality": 0.890625, "section_id": 7798}}}, "34861283": {"ViewCount": "269", "Body": "<p><code>std::allocator_traits</code> works its magic automatically when I provide an STL-style container with an allocator that has a single template parameter but it doesn't when I provide an STL-style container with an allocator that has two template parameters but is otherwise similar.</p>\n<p>What do I need to do to tell <code>std::allocator_traits</code> how to interact with an allocator that has more than one template parameter? Is it possible to get <code>std::allocator_traits</code> to provide reasonable defaults in this case?</p>\n<p>As an example, if I take the simple allocator Howard Hinnant provides in <a href=\"https://howardhinnant.github.io/allocator_boilerplate.html\" rel=\"nofollow\">Allocator Boilerplate</a> and feed it to a <code>std::vector&lt;&gt;</code> then all is well. If I add a dummy <code>int</code> parameter to the <code>allocator</code> template (and make slight modifications as needed) then I get compiler errors because the compiler couldn't find <code>rebind</code>, among other things.</p>\n<p>Here's that description in code:</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/173c57264137a351\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/173c57264137a351</a></p>\n<p>If I have to specialize <code>std::allocator_traits</code> myself in this case, is there a way to still get the defaults?</p>\n", "AcceptedAnswerId": "34863387", "Title": "std::allocator_traits defaults with allocator that has more than one template parameter", "CreationDate": "2016-01-18T18:08:38.440", "Id": "34861283", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-01-18T18:25:34.263", "LastEditorUserId": "1128289", "LastActivityDate": "2016-01-18T20:30:06.937", "Score": "2", "OwnerUserId": "1128289", "Tags": "<c++><templates><c++11><c++14><allocator>", "AnswerCount": "1"}, "34863387": {"Id": "34863387", "PostTypeId": "2", "Body": "<p>The Standard only provides a default <code>rebind</code> for allocators with multiple template <strong>type</strong> parameters:</p>\n<blockquote>\n<p id=\"so_34861283_34863387_0\"><strong>17.6.3.5 Allocator requirements [allocator.requirements]</strong></p>\n<p id=\"so_34861283_34863387_1\">3 Note A: The member class template <code>rebind</code> in the table above is\n  effectively a typedef template. [ Note: In general, if the name\n  <code>Allocator</code> is bound to <code>SomeAllocator&lt;T&gt;</code>, then\n  <code>Allocator::rebind&lt;U&gt;::other</code> is the same type as <code>SomeAllocator&lt;U&gt;</code>,\n  where <code>SomeAllocator&lt;T&gt;::value_type</code> is <code>T</code> and <code>SomeAllocator&lt;U&gt;::\n  value_type</code> is <code>U</code>. \u2014 end note ] If <code>Allocator</code> is a class template\n  instantiation of the form <code>SomeAllocator&lt;T, Args&gt;</code>, <strong>where <code>Args</code> is zero\n  or more type arguments</strong>, and <code>Allocator</code> does not supply a <code>rebind</code> member\n  template, the standard allocator_traits template uses <code>SomeAllocator&lt;U, Args&gt;</code> &gt; in place of <code>Allocator:: rebind&lt;U&gt;::other</code> by default. <strong>For\n  allocator types that are not template instantiations of the above\n  form, no default is provided.</strong></p>\n</blockquote>\n<p>Since you have a non-type (<code>int</code>) parameter, there is no default provided. The fix is simple: just add your own rebind to your allocator.</p>\n<pre><code>template&lt;class T, int I&gt;\nclass allocator_w_int\n{\n    // as before\n\n    template&lt;class U&gt;\n    struct rebind { using other = allocator_w_int&lt;U, I&gt;; };    \n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/75d830130d1bd453\"><strong>Live Example</strong></a></p>\n<p>As to the rationale of allowing for allocators of the form <code>Allocator&lt;T, Args...&gt;</code> but not for allocators of the form <code>Alloc&lt;T, Ns...&gt;</code>, one can only guess, but then it would also lead to the plethora of <code>Alloc&lt;T, Args.., Ns...&gt;</code> etc. etc.. This is why template-metaprogramming libraries (such as Boost.MPL) always wrap their non-type parameters <code>N</code> of type <code>T</code> inside things like <code>integral_constant&lt;T, N&gt;</code>. This would also be a route for you, by defining </p>\n<pre><code>template&lt;class T, class Arg&gt;\nclass allocator_w_int; // leave undefined\n\ntemplate&lt;int N&gt;\nusing int_ = std::integral_constant&lt;int, N&gt;;\n\ntemplate&lt;class T, int I&gt;\nclass allocator_w_int&lt;T, int_&lt;I&gt;&gt;\n{\n    // replace all occurances of I, J --&gt; int_&lt;I&gt;, int_&lt;J&gt;\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/b31f87ae18654417\"><strong>Live Example</strong></a></p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2016-01-18T20:30:06.937", "Score": "5", "CreationDate": "2016-01-18T20:20:57.183", "ParentId": "34861283", "CommentCount": "0", "OwnerUserId": "819272", "LastEditDate": "2016-01-18T20:30:06.937"}});