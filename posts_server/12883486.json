post_cb({"bq_ids": {"n4140": {"so_12883486_12883770_0": {"length": 19, "quality": 0.7307692307692307, "section_id": 7114}}, "n3337": {"so_12883486_12883770_0": {"length": 19, "quality": 0.7307692307692307, "section_id": 6858}}, "n4659": {"so_12883486_12883770_0": {"length": 19, "quality": 0.7307692307692307, "section_id": 8615}}}, "12883510": {"Id": "12883510", "PostTypeId": "2", "Body": "<p>You cannot pass constructor pointer as stored type.</p>\n<p>Instead of</p>\n<pre><code>std::vector&lt;Obstacle::Obstacle*&gt; obstacles;\n</code></pre>\n<p>try</p>\n<pre><code>std::vector&lt;Obstacle*&gt; obstacles;\n</code></pre>\n", "LastActivityDate": "2012-10-14T15:15:35.717", "CommentCount": "9", "CreationDate": "2012-10-14T15:15:35.717", "ParentId": "12883486", "Score": "1", "OwnerUserId": "969373"}, "12883486": {"ViewCount": "679", "Body": "<p>First off, my code compiles and runs fine on Mac OS X with compiler</p>\n<pre><code>i686-apple-darwin11-llvm-g++-4.2 (GCC) 4.2.1\n</code></pre>\n<p>but on Ubuntu with compiler</p>\n<pre><code>g++ (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3\n</code></pre>\n<p>it won't compile.</p>\n<p>In my header I have</p>\n<pre><code>std::vector&lt;Obstacle::Obstacle*&gt; obstacles;\n</code></pre>\n<p>which gives the following compilation error in Ubuntu:</p>\n<pre><code>error: \u2018Obstacle::Obstacle\u2019 cannot appear in a constant-expression\n</code></pre>\n<p>Any ideas of what I need to change to make it work?\nIs there some magical compile flag I should use on Ubuntu to make it work just as on OS X?</p>\n<p>Thank you</p>\n<p>EDIT: <code>Obstacle</code> is a class.</p>\n", "AcceptedAnswerId": "12883510", "Title": "std::vector<T> compile error \"T cannot appear in a constant-expression\"", "CreationDate": "2012-10-14T15:12:44.320", "Id": "12883486", "CommentCount": "3", "LastEditDate": "2012-10-14T16:01:00.963", "PostTypeId": "1", "LastEditorUserId": "251666", "LastActivityDate": "2012-10-14T18:26:24.643", "Score": "0", "OwnerUserId": "251666", "Tags": "<c++><g++><llvm>", "AnswerCount": "2"}, "12883770": {"Id": "12883770", "PostTypeId": "2", "Body": "<p>Apparently <code>Obstacle</code> is just a class.</p>\n<p>Amazingly, the following also works, tested in g++ 4.2, g++ 4.3, g++ 4.4, clang++ 2.9, and clang++ 3.1:</p>\n<pre><code>std::vector&lt;Obstacle::Obstacle::Obstacle::Obstacle::Obstacle*&gt; obstacles;\n</code></pre>\n<p>Multiple versions of g++ and multiple versions of clang compiled the above.</p>\n<p><strike>g++ 4.5 and 4.6 have problems with this construct. This looks like a g++ bug, versions 4.5 and higher. So why should this be legal?</strike></p>\n<p>This is a bug in pre 4.5 g++, clang, and apparently other compilers. The relevant portion of the standard is 3.4.3.1, para 1a:</p>\n<blockquote>\n<p id=\"so_12883486_12883770_0\">If the nested-name-specifier nominates a class C, and the name specified after the nested-name-specifier, when looked up in C, is the injected-class-name of C (clause 9), the name is instead considered to name the constructor of class C. Such a constructor name shall be used only in the declarator-id of a constructor definition that appears outside of the class definition.</p>\n</blockquote>\n<p>In other words, <code>Obstacle::Obstacle</code> is illegal except when used in an out of line definition of a constructor for class <code>Obstacle</code>.</p>\n<p>So how are these compilers parsing this? Those compilers are treating <code>Obstacle::Obstacle</code> as having special meaning only in the case of an out of line definition of a constructor. Otherwise, <code>Obstacle::Obstacle</code> follows the injected name rules, but ignore the fact that that rule does not apply here. <code>Obstacle::Obstacle*</code> isn't a pointer to the constructor because constructors don't have names. <code>Obstacle::Obstacle*</code> instead means whatever <code>Obstacle*</code> means when evaluated from within the context of the class <code>Obstacle</code>. But inside the class, <code>Obstacle*</code> is still a pointer to an instance of class <code>Obstacle</code>. <code>Obstacle::Obstacle*</code> is just an <code>Obstacle*</code>, as is <code>Obstacle::Obstacle::Obstacle*</code>, and so on. Pile on as many <code>Obstacle</code>s you want and it's still just an <code>Obstacle*</code>.</p>\n", "LastEditorUserId": "774499", "LastActivityDate": "2012-10-14T18:26:24.643", "Score": "4", "CreationDate": "2012-10-14T15:42:36.440", "ParentId": "12883486", "CommentCount": "3", "OwnerUserId": "774499", "LastEditDate": "2012-10-14T18:26:24.643"}});