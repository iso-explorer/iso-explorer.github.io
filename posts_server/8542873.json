post_cb({"8543161": {"PostTypeId": "2", "ParentId": "8542873", "Body": "<p>The rule is simple : it is how you declare it.</p>\n<pre><code>int i = 5;\nauto a1 = i;    // value\nauto &amp; a2 = i;  // reference\n</code></pre>\n<p>Next example proves it :</p>\n<pre><code>#include &lt;typeinfo&gt;\n#include &lt;iostream&gt;    \n\ntemplate&lt; typename T &gt;\nstruct A\n{\n    static void foo(){ std::cout&lt;&lt; \"value\" &lt;&lt; std::endl; }\n};\ntemplate&lt; typename T &gt;\nstruct A&lt; T&amp;&gt;\n{\n    static void foo(){ std::cout&lt;&lt; \"reference\" &lt;&lt; std::endl; }\n};\n\nfloat&amp; bar()\n{\n    static float t=5.5;\n    return t;\n}\n\nint main()\n{\n    int i = 5;\n    int &amp;r = i;\n\n    auto a1 = i;\n    auto a2 = r;\n    auto a3 = bar();\n\n    A&lt;decltype(i)&gt;::foo();       // value\n    A&lt;decltype(r)&gt;::foo();       // reference\n    A&lt;decltype(a1)&gt;::foo();      // value\n    A&lt;decltype(a2)&gt;::foo();      // value\n    A&lt;decltype(bar())&gt;::foo();   // reference\n    A&lt;decltype(a3)&gt;::foo();      // value\n}\n</code></pre>\n<p>The output:</p>\n<pre><code>value\nreference\nvalue\nvalue\nreference\nvalue\n</code></pre>\n", "CreationDate": "2011-12-17T06:44:27.850", "Score": "57", "LastEditDate": "2016-09-26T15:04:35.143", "CommentCount": "1", "Id": "8543161", "OwnerUserId": "476681", "LastEditorUserId": "214671", "LastActivityDate": "2016-09-26T15:04:35.143"}, "bq_ids": {"n3337": {"so_8542873_8544417_0": {"quality": 0.9, "length": 18, "section_id": 5245}}}, "8544417": {"PostTypeId": "2", "ParentId": "8542873", "Body": "<p><code>\u00a77.1.6.4 [dcl.spec.auto] p6</code></p>\n<blockquote>\n<p id=\"so_8542873_8544417_0\">Once the type of a <em>declarator-id</em> has been determined according to 8.3, the type of the declared variable using the <em>declarator-id</em> is determined from the type of its initializer using the rules for template argument deduction.</p>\n</blockquote>\n<p>This means nothing else than that <code>auto</code> models template argument deduction during a function call.</p>\n<pre><code>template&lt;class T&gt;\nvoid f(T){} // #1, will also be by-value\n\ntemplate&lt;class T&gt;\nvoid g(T&amp;){} // #2, will always be by-reference\n</code></pre>\n<p>Note that #1 will always copy the passed argument, no matter if you pass a reference or anything else. (Unless you specifically specify the template argument like <code>f&lt;int&amp;&gt;(intref);</code>.)</p>\n", "CreationDate": "2011-12-17T11:30:59.363", "Score": "12", "CommentCount": "2", "Id": "8544417", "OwnerUserId": "500104", "LastActivityDate": "2011-12-17T11:30:59.363"}, "8542873": {"LastEditDate": "2011-12-17T05:55:14.640", "Body": "<p>When I use C++11 <code>auto</code>, what are the rules of type deduction with regards to whether it will resolve to a value or a reference?</p>\n<p>E.g, sometimes it is clear:</p>\n<pre><code>auto i = v.begin(); // Copy, begin() returns an iterator by value\n</code></pre>\n<p>These are less clear:</p>\n<pre><code>const std::shared_ptr&lt;Foo&gt;&amp; get_foo();\nauto p = get_foo(); // Copy or reference?\n\nstatic std::shared_ptr&lt;Foo&gt; s_foo;\nauto sp = s_foo; // Copy or reference?\n\nstd::vector&lt;std::shared_ptr&lt;Foo&gt;&gt; c;\nfor (auto foo: c) { // Copy for every loop iteration?\n</code></pre>\n", "CreationDate": "2011-12-17T05:46:20.657", "Score": "51", "AcceptedAnswerId": "8543161", "CommentCount": "0", "OwnerUserId": "23643", "Title": "C++11 \"auto\" semantics", "LastActivityDate": "2017-11-06T09:22:43.673", "PostTypeId": "1", "Tags": "<c++><c++11>", "AnswerCount": "3", "FavoriteCount": "13", "Id": "8542873", "ViewCount": "20605", "LastEditorUserId": "23643"}, "20435077": {"PostTypeId": "2", "ParentId": "8542873", "Body": "<p>Whatever you get from right side ( of \"=\" ) is never a reference. More specifically the result of an expression is never a reference. In this light, note the difference between results in the example.</p>\n<pre><code>#include &lt;typeinfo&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt; typename T &gt;\nstruct A\n{\n    static void foo(){ std::cout&lt;&lt; \"value\" &lt;&lt; std::endl; }\n};\n\ntemplate&lt; typename T &gt;\nstruct A&lt; T&amp;&gt;\n{\n    static void foo(){ std::cout&lt;&lt; \"reference\" &lt;&lt; std::endl; }\n};\n\nfloat&amp; bar()\n{\n    static float t=5.5;\n    return t;\n}\n\nint main()\n{\n   auto a3 = bar();\n\n   A&lt;decltype(bar())&gt;::foo(); // reference\n   A&lt;decltype(a3)&gt;::foo();    // value\n}\n</code></pre>\n", "CreationDate": "2013-12-06T22:57:51.947", "Score": "7", "LastEditDate": "2017-11-06T09:22:43.673", "CommentCount": "1", "Id": "20435077", "OwnerUserId": "1135237", "LastEditorUserId": "2702193", "LastActivityDate": "2017-11-06T09:22:43.673"}});