post_cb({"6967179": {"CommentCount": "4", "ViewCount": "1045", "PostTypeId": "1", "LastEditorUserId": "635608", "CreationDate": "2011-08-06T13:39:39.020", "LastActivityDate": "2015-05-04T10:23:31.167", "Title": "What's a \"recursive_init_error\" exception?", "AcceptedAnswerId": "6967246", "LastEditDate": "2015-05-04T10:23:31.167", "Id": "6967179", "Score": "8", "Body": "<p>I decided to do a test with computed gotos and local statics</p>\n<pre><code>void g() { std::cout &lt;&lt; \"init \"; } \nvoid f() { \n  int z = 0; \n  y: z++; \n  static int x = \n    (g(), z == 1 ? ({ goto *&amp;&amp;y; 0; }) : 0); \n}\n\nint main() { f(); std::cout &lt;&lt; \"!\"; f(); }\n</code></pre>\n<p>I wanted to see whether the output would be \"init init !\". But to my surprise I didn't get that output, but instead GCC handled it gracefully, outputting at runtime:</p>\n<pre><code>init terminated by recursive_init_error: exception\n</code></pre>\n<p>What's that exception? Is it a Standard exception? C++03 or C++0x? Thanks for any explanation.</p>\n", "Tags": "<c++><exception><initialization><g++>", "OwnerUserId": "34509", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_6967179_6967246_2": {"section_id": 3919, "quality": 0.9230769230769231, "length": 12}, "so_6967179_6967246_0": {"section_id": 3919, "quality": 0.9069767441860465, "length": 39}, "so_6967179_6967246_3": {"section_id": 3919, "quality": 0.875, "length": 7}}, "n3337": {"so_6967179_6967246_2": {"section_id": 3779, "quality": 0.9230769230769231, "length": 12}, "so_6967179_6967246_0": {"section_id": 3779, "quality": 0.9069767441860465, "length": 39}, "so_6967179_6967246_3": {"section_id": 3779, "quality": 0.875, "length": 7}}, "n4659": {"so_6967179_6967246_0": {"section_id": 4805, "quality": 0.8372093023255814, "length": 36}, "so_6967179_6967246_2": {"section_id": 4805, "quality": 0.9230769230769231, "length": 12}, "so_6967179_6967246_3": {"section_id": 4805, "quality": 0.875, "length": 7}}}, "6967246": {"ParentId": "6967179", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It's caused by what is stated in C++03 \u00a76.7/4:</p>\n<blockquote>\n<p id=\"so_6967179_6967246_0\">... Otherwise such an object is initialized the first time control passes through its declaration; such an object is considered initialized upon the completion of its initialization. If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration. If control re-enters the declaration (recursively) while the object is being initialized, the behavior is undefined. [Example:</p>\n</blockquote>\n<pre><code>int foo(int i)\n{\n  static int s = foo(2*i);    // recursive call \u2013 undefined\n  return i+1;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_6967179_6967246_1\">--end example]</p>\n</blockquote>\n<p>GCC throws an exception in that case. Here's <a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-api-4.5/a00069.html\" rel=\"nofollow\">some documentation</a> about it.</p>\n<hr>\n<p>C++11 update: The following wording was added in C++11, just before the text about the recursive case:</p>\n<blockquote>\n<p id=\"so_6967179_6967246_2\">If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.<sup>88</sup></p>\n<p id=\"so_6967179_6967246_3\"><sub><sup>88</sup> The implementation must not introduce any deadlock around execution of the initializer.</sub></p>\n</blockquote>\n<p>Doesn't change the problem here, but does make this construct thread-safe when there is no recursion.</p>\n</hr>", "OwnerUserId": "635608", "LastEditorUserId": "635608", "LastEditDate": "2013-09-12T13:25:15.227", "Id": "6967246", "Score": "16", "CreationDate": "2011-08-06T13:51:23.253", "LastActivityDate": "2013-09-12T13:25:15.227"}});