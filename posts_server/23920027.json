post_cb({"bq_ids": {"n4140": {"so_23920027_23920027_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 261}}, "n3337": {"so_23920027_23920027_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 252}}, "n4659": {"so_23920027_23920027_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 268}}}, "23920027": {"ViewCount": "93", "Body": "<p>The C++ standard states the following in note 14.7.2/12 [temp.explicit]:</p>\n<blockquote>\n<p id=\"so_23920027_23920027_0\">The usual access checking rules do not apply to names used to specify\n  explicit instantiations. [ Note: In particular, the template arguments\n  and names used in the function declarator (including parameter types,\n  return types and exception speci\ufb01cations) may be private types or objects\n  which would normally not be accessible and the template may be a member\n  template or member function which would not normally be accessible. \u2014 end note ]</p>\n</blockquote>\n<p>I would expect to be allowed to use a template if I can instantiate it.</p>\n<p>I tried with gcc-4.8.2 and I get the expected behaviour when I access private members of explicitly named classes. However, the access checking rules do apply when I access private members through template parameters. Is this a bug in gcc, or am I missing something?</p>\n<p>In the code below, the only difference between 'succeeds' and 'fails' is that the former accesses the private member directly via 'A', while the latter accesses it via the template parameter 'T'. The compiler complains that privateFoobar is private in that context.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct A\n{\nprivate:\n    std::string privateFoobar() {return \"private foobar!\";}\n};\n\ntypedef std::string (A::*Foobar)();\n\ntemplate &lt;class Type, Type value&gt;\nstruct Access\n{\n    static Type getValue() {return value;}\n};\n\ntemplate &lt;class T&gt;\nstruct IndirectAccess\n{\n    static Foobar succeeds() {return Access&lt;Foobar, &amp;A::privateFoobar&gt;::getValue();}\n    static Foobar fails() {return Access&lt;Foobar, &amp;T::privateFoobar&gt;::getValue();}\n};\n\ntemplate class Access&lt;Foobar, &amp;A::privateFoobar&gt;;\n\nint main() {\n    std::cout &lt;&lt; (A().*Access&lt;Foobar,&amp;A::privateFoobar&gt;::getValue())() &lt;&lt; std::endl;\n    std::cout &lt;&lt; (A().*IndirectAccess&lt;A&gt;::succeeds())() &lt;&lt; std::endl;\n    std::cout &lt;&lt; (A().*IndirectAccess&lt;A&gt;::fails())() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>In case you are wondering what is the use case for such a sackable offence: creating a framework that would automate the configuration of an application based on implementation choices for the selected components.</p>\n", "AcceptedAnswerId": "23922329", "Title": "Why do the usual access control checking applies to names used to specify explicit instantiation when accessed through template parameters?", "CreationDate": "2014-05-28T19:13:32.463", "Id": "23920027", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-05-28T21:35:26.533", "LastEditorUserId": "2362671", "LastActivityDate": "2014-05-28T22:02:06.380", "Score": "3", "OwnerUserId": "2362671", "Tags": "<c++><templates><gcc>", "AnswerCount": "1"}, "23922329": {"Id": "23922329", "PostTypeId": "2", "Body": "<p>Explicit instantiations have to be at namespace scope, which means private members of classes would not normally be accessible. Without the rule you quote, this would be impossible:</p>\n<pre><code>class Foo\n{\nprivate:\n  struct Bar;\n\n  template&lt;typename T&gt; class Baz { };\n\npublic:\n  void f();  // does things with Baz&lt;Bar&gt;\n};\n\n// explicit instantiation declaration\nextern template class Foo::Baz&lt;Foo::Bar&gt;;\n</code></pre>\n<p>Without that rule, I would not be able to name <code>Foo::Bar</code> or even <code>Foo::Baz</code> at namespace scope, because those names are private to <code>Foo</code>.</p>\n<p>Since I'm not actually <em>using</em> <code>Foo::Bar</code> or <code>Foo::Baz</code> here, just referring to their names to tell the compiler I'm instantiating the template somewhere else, there is no real access violation (although it is possible to use this rule to perform a very <a href=\"https://gist.github.com/dabrahams/1528856\">sneaky trick</a> not possible otherwise).</p>\n<p>Similarly, when I write the explicit instantiation definition in some other file, I need to be able to refer to the private names again at namespace scope.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2014-05-28T22:02:06.380", "Score": "5", "CreationDate": "2014-05-28T21:39:51.417", "ParentId": "23920027", "CommentCount": "4", "OwnerUserId": "981959", "LastEditDate": "2014-05-28T22:02:06.380"}});