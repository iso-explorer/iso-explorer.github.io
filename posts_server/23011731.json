post_cb({"bq_ids": {"n4140": {"so_23011731_23013769_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 3345}}, "n3337": {"so_23011731_23013769_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3215}}}, "23013508": {"PostTypeId": "2", "Body": "<p>To deal with resources, C used to focus on managing the execution paths. the programmer had to make sure that for every possible path, the resources were freed.</p>\n<p>So it was normal to end with code like that :\nNotice that most of the code is there to handle error(s).</p>\n<pre><code>HRESULT \nCreateNotifyIcon(NotifyIcon** ppResult) \n{ \n    NotifyIcon*      icon = 0; \n    Icon*            inner = 0; \n    const wchar_t *  tmp1 = 0; \n    HRESULT          hr = S_OK; \n\n    if ( SUCCEEDED(hr) ) { \n        icon = new (nothrow) NotifyIcon(); \n        if ( !icon ) hr = E_OUTOFMEM; \n    } \n\n    if ( SUCCEEDED(hr) ) \n        hr = icon-&gt;set_text(\"Blah blah blah\"); \n\n    if ( SUCCEEDED(hr) ) { \n        inner = new (nothrow) Icon(...); \n        if ( !inner ) \n            hr = E_OUTOFMEM; \n        else { \n            Info info; \n            hr = GetInfo( &amp;info ); \n\n            if ( SUCCEEDED(hr) ) \n                hr = icon-&gt;set_icon(inner, info); \n            if ( SUCCEEDED(hr) ) \n                inner = NULL; \n        } \n    } \n    if ( SUCCEEDED(hr) ) \n        hr = icon-&gt;set_visible(true); \n\n    if ( SUCCEEDED(hr) ) { \n        *ppResult = icon; \n        icon = NULL; \n    } else { \n        *ppResult = NULL; \n    } \n\n    cleanup: \n    if ( inner ) delete inner; \n    if ( icon ) delete icon; \n    return hr; \n}\n</code></pre>\n<p>In C++, this is not the right way because you have exceptions. For instance :</p>\n<pre><code>  String EvaluateSalaryAndReturnName( Employee e )\n  {\n    if( e.Title() == \"CEO\" || e.Salary() &gt; 100000 )\n    {\n      cout &lt;&lt; e.First() &lt;&lt; \" \" &lt;&lt; e.Last()\n           &lt;&lt; \" is overpaid\" &lt;&lt; endl;\n    }\n    return e.First() + \" \" + e.Last();\n  }\n</code></pre>\n<p>There are <strong>23</strong> <a href=\"http://www.gotw.ca/gotw/020.htm\" rel=\"nofollow\">different execution</a> paths in that snippet of code. </p>\n<p>So C++ chose to focus on the resources instead. Each function (should) handle a limited number of resources. Roughly speaking, you put a watchdog on each resource to make sure they are properly released/freed. This watch dog is <strong>RAII</strong>. Indeed, whatever the execution path may be, you are 100% sure the destructor of all objects allocated on the stack will be called. That way, by putting your resources into RAII object (STL containers, std::unique_ptr,...), you can deal with exceptions without any problem of  leaked resource.</p>\n<p>Look at the difference :\n<strong>BAD WAY</strong> </p>\n<pre><code>void function(int n){\n  int* p = 0;\n  int* c = 0;\n\n  try{\n    p = new int[n];\n    c = new int[n*2];\n  }\n  catch(std::exception const&amp; e){\n    delete[] c;\n    delete[] p;\n    throw;\n  }\n\n  delete[] c;\n  delete[] p;\n}\n\nint main(){\n  try{\n    function(1000);\n  } catch (std::exception const&amp; e){\n    std::cerr&lt;&lt;e.what()&lt;&lt;std::endl;\n  }\n}\n</code></pre>\n<p><strong>GOOD WAY</strong></p>\n<pre><code>void function(int n){\n  std::unique_ptr&lt;int[]&gt; p(new int[n]); //or std::vector\n  std::unique_ptr&lt;int[]&gt; c(new int[n*2]);\n}\nint main(){\n  try{\n    function(1000);\n  } catch (std::exception const&amp; e){\n    std::cerr&lt;&lt;e.what()&lt;&lt;std::endl;\n  }\n}\n</code></pre>\n", "LastActivityDate": "2014-04-11T13:08:49.893", "Id": "23013508", "CommentCount": "1", "CreationDate": "2014-04-11T13:08:49.893", "ParentId": "23011731", "Score": "2", "OwnerUserId": "2503039"}, "23012669": {"PostTypeId": "2", "Body": "<p>The problem is, that you have to delete the array in all possible ways to leave the function. This may be easy if you have only one or two ways, but gets confusing with more. Even in your code you have one delete already outside the function, what it makes hard to find.</p>\n<p>Use smart pointers to target that issue. They deallocate their content when they get out of scope. That way you don't have to bother for the destruction of the array. As soon as the function is done, the array will be destroyed.</p>\n<p>Here is some documentation for smart pointers:\n<a href=\"http://www.cplusplus.com/reference/memory/unique_ptr/?kw=unique_ptr\" rel=\"nofollow\">unique_ptr</a>\n<a href=\"http://www.cplusplus.com/reference/memory/shared_ptr/?kw=shared_ptr\" rel=\"nofollow\">shared_ptr</a></p>\n", "LastActivityDate": "2014-04-11T12:32:28.127", "Id": "23012669", "CommentCount": "0", "CreationDate": "2014-04-11T12:32:28.127", "ParentId": "23011731", "Score": "2", "OwnerUserId": "2988020"}, "23011731": {"ViewCount": "131", "Body": "<p>I was told that putting all pointers in the catch block is bad OO programming. Cleanup occurs in the catch block. How does it violate every rule of OO design? </p>\n<p>Here is a sample code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nclass Error\n{\n  friend int main();\n  public:\n    Error(int* p, string m) : arr(p), msg(m) { }\n  private:\n    int*   arr;\n    string msg;\n};\n\nvoid initialize();\n\n\nint main()\n{\n  try {\n    initialize();\n  }\n  catch(Error&amp; err) {\n    cout&lt;&lt;endl&lt;&lt; \"Error! \"&lt;&lt; err.msg &lt;&lt;endl&lt;&lt;endl;\n    delete [] err.arr;\n  }\n  return 0;\n}\n\nvoid initialize()\n{\n  int size;\n\n  cout&lt;&lt;\"Enter the number of elements: \";\n  cin &gt;&gt; size;\n\n  int* myArray = new int[size];\n\n  cout&lt;&lt;\"Enter the elements: \" &lt;&lt;endl;\n  for (int i=0; i&lt;size; ++i)\n    cin &gt;&gt; myArray[i];\n\n  if (!cin.good())\n    throw Error(myArray, (string)\"bad input!\");\n\n  cout&lt;&lt;endl&lt;&lt;\"You entered:\"&lt;&lt;endl;\n\n  for (int i=0; i&lt;size; ++i)\n    cout &lt;&lt; myArray[i] &lt;&lt; \" \";\n  cout&lt;&lt;endl;\n\n  delete [] myArray;\n\n}\n</code></pre>\n<p>Please ignore this line. I'm just trying to get this question posted.</p>\n", "AcceptedAnswerId": "23013508", "Title": "Stack unwinding", "CreationDate": "2014-04-11T11:47:09.720", "LastActivityDate": "2014-04-11T13:42:04.130", "CommentCount": "3", "PostTypeId": "1", "Tags": "<c++><exception-handling>", "Id": "23011731", "Score": "-1", "OwnerUserId": "3450695", "ClosedDate": "2017-01-30T21:56:54.217", "AnswerCount": "3"}, "23013769": {"PostTypeId": "2", "Body": "<p>The C++ Standard n3337 <strong>\u00a7</strong> 15.2/3 says:</p>\n<blockquote>\n<p id=\"so_23011731_23013769_0\">The process of calling destructors for automatic objects constructed\n  on the path from a try block to a throw-expression is called \u201cstack\n  unwinding. (...)\u201d</p>\n</blockquote>\n<p>The problem with your code is that pointer to array is allocated inside try block, so it is no longer alive when control reaches catch block. You cannot do</p>\n<p>To correct this you should declare a pointer before try block:</p>\n<pre><code>  int* myArray;\n\n  try{\n    function(1000); // allocate an array and point myArray to it\n  } catch (std::exception const&amp; e){\n    delete [] myArray;  // OK, myArray pointer is valid here\n  }\n</code></pre>\n<p>This will delete the objects and return memory to the system. Such approach is taken for example in <code>std::uninitialized_fill</code>. But you got the better possibility. To free yourself from the burden of deallocating memory you can consider using <em>smart pointer</em> or a <em>handle</em> to an array (a class that wraps around a resource): representing each resource as a class is the foundation of approach called <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"nofollow\">RAII</a>.</p>\n<pre><code>  try{\n    MyArray myArray(1000); // allocate an array in constructor\n  } catch (std::exception const&amp; e){\n    // destructor for myArray has deleted ints &amp; returned memory already\n  }\n</code></pre>\n", "LastActivityDate": "2014-04-11T13:42:04.130", "LastEditorUserId": "1141471", "Id": "23013769", "CommentCount": "1", "CreationDate": "2014-04-11T13:18:37.883", "ParentId": "23011731", "Score": "0", "OwnerUserId": "1141471", "LastEditDate": "2014-04-11T13:42:04.130"}});