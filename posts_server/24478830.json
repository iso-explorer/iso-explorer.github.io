post_cb({"bq_ids": {"n4140": {"so_24478830_24480354_0": {"length": 87, "quality": 0.9666666666666667, "section_id": 7204}, "so_24478830_24480354_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 11}, "so_24478830_24480354_1": {"length": 23, "quality": 0.92, "section_id": 6064}}, "n3337": {"so_24478830_24480354_1": {"length": 21, "quality": 0.84, "section_id": 5832}, "so_24478830_24480354_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 8}, "so_24478830_24480354_0": {"length": 87, "quality": 0.9666666666666667, "section_id": 6948}}, "n4659": {"so_24478830_24480354_1": {"length": 22, "quality": 0.88, "section_id": 7560}, "so_24478830_24480354_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 12}, "so_24478830_24480354_0": {"length": 84, "quality": 0.9333333333333333, "section_id": 8713}}}, "24479791": {"Id": "24479791", "PostTypeId": "2", "Body": "<p>I think a compiler should accept it (irrespective of the -O setting) because a definition of the static can be provided by another compilation unit. (This is perhaps a pragmatic deviation from the standard - I'm not an C++ expert.) The posted snippet can be compiled, but it is incomplete and cannot be brought to execution without a definition of the static member.</p>\n<p>File c.h:</p>\n<pre><code>struct C {\n    static int v[];\n};\n</code></pre>\n<p>File x.cpp</p>\n<pre><code>#include \"c.h\"\n#include &lt;iostream&gt;\nint main(){\n    int (*p)[] = &amp;C::v; // works in C++ if 'v' isn't defined (only declared)\n    std::cout &lt;&lt; *((int*)p) &lt;&lt; std::endl; \n    return 0;\n}\n</code></pre>\n<p>File y.cpp</p>\n<pre><code>#include \"c.h\"\nint C::v[3] = {1,2,3};\n</code></pre>\n<p>Compiled and linked using (dont-tell-me-it's-old) g++ 4.3.3. Prints 1.</p>\n<p>And: yes I know it's a C cast.</p>\n", "LastActivityDate": "2014-06-29T20:05:34.033", "Score": "2", "CreationDate": "2014-06-29T20:05:34.033", "ParentId": "24478830", "CommentCount": "2", "OwnerUserId": "2107876"}, "24480354": {"Id": "24480354", "PostTypeId": "2", "Body": "<p>Such a pointer cannot participate in pointer arithmetic, potentially useful things that still can be done are to get its type with <code>decltype</code> or <code>reinterpret_cast</code> it to another pointer type or <code>intptr_t</code>.  This is because section 3.9p6 says:</p>\n<blockquote>\n<p id=\"so_24478830_24480354_0\">A class type (such as \"<code>class X</code>\") might be incomplete at one point in a translation unit and complete later on; the type \"<code>class X</code>\" is the same type at both points.  The declared type of an array object might be an array of incomplete class type and therefore incomplete;  if the class type is completed later on in the translation unit, the array type becomes complete; the array type at those two points is the same type.  The declared type of an array object might be an array of unknown size and therefore be incomplete at one point in a translation unit and complete later on; the array types at those two points (\"array of unknown bound of <code>T</code>\" and \"array of <code>N</code> <code>T</code>\") are different types.  <strong>The type of a pointer to array of unknown size, or of a type defined by a typedef declaration to be an array of unknown size, cannot be completed.</strong></p>\n</blockquote>\n<p>5.3.1 says:</p>\n<blockquote>\n<p id=\"so_24478830_24480354_1\">Note:  indirection through a pointer to an incomplete type (other than <em><code>cv</code></em> <code>void</code>) is valid.  The lvalue thus obtained can be used in limited ways (to initialize a reference, for example); this lvalue must not be converted to a prvalue, see 4.1.</p>\n</blockquote>\n<p>Since array-to-pointer decay can be performed on array lvalues without prior conversion to rvalue, the code dyp left in a comment is correct:</p>\n<pre><code>(*p)[i]\n</code></pre>\n<p>Relevant rule, from 4.2:</p>\n<blockquote>\n<p id=\"so_24478830_24480354_2\">An <strong>lvalue</strong> or rvalue of type 'array of <code>N</code> <code>T</code>\" or <strong>\"array of unknown bound of <code>T</code>\"</strong> can be converted to a prvalue of type \"pointer to <code>T</code>\". The result is a pointer to the first element of the array.</p>\n</blockquote>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-06-29T21:33:20.513", "Score": "11", "CreationDate": "2014-06-29T21:15:39.810", "ParentId": "24478830", "CommentCount": "5", "LastEditDate": "2014-06-29T21:33:20.513", "OwnerUserId": "103167"}, "24478830": {"ViewCount": "1015", "Body": "<p>Consider following code:</p>\n<pre><code>int main() {\n    int (*p)[]; // pointer to array with unspecified bounds\n\n    int a[] = {1};\n    int b[] = {1,2};\n\n    p = &amp;a; // works in C but not in C++\n    p = &amp;b; // works in C but not in C++\n\n    return 0;\n}\n</code></pre>\n<p>In pure C you can assign a pointer to this type of address of an array of any dimension. But in C++ you can't. I found one case when compiler allows assign value to such pointer:</p>\n<pre><code>struct C\n{\n    static int v[];\n};\n\nint main() \n{\n    int (*p)[] = &amp;C::v; // works in C++ if 'v' isn't defined (only declared)\n    return 0;\n}\n</code></pre>\n<p>But could not find any useful case of this code. </p>\n<p>Can anyone give an useful example (in C++) of pointer to array with unspecified bounds?\nOr is it only vestige remaining from C?</p>\n", "AcceptedAnswerId": "24480354", "Title": "Usable case of pointer to array with unspecified bounds in C++ (not in C)", "CreationDate": "2014-06-29T18:12:55.080", "Id": "24478830", "CommentCount": "4", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2014-06-29T18:17:33.177", "LastEditorUserId": "15168", "LastActivityDate": "2014-06-30T01:49:22.537", "Score": "31", "OwnerUserId": "3240681", "Tags": "<c++><arrays><pointers><backwards-compatibility>", "AnswerCount": "2"}});