post_cb({"bq_ids": {"n4140": {"so_39530837_39536077_0": {"length": 27, "quality": 0.9, "section_id": 233}}, "n3337": {"so_39530837_39536077_0": {"length": 27, "quality": 0.9, "section_id": 226}}, "n4659": {"so_39530837_39536077_0": {"length": 27, "quality": 0.9, "section_id": 242}}}, "39536077": {"Id": "39536077", "PostTypeId": "2", "Body": "<p>It looks like this is a gcc bug. Here's an MCVE (4 lines):</p>\n<pre><code>struct X;\ntemplate&lt;int&gt; struct A { friend constexpr A f(X*) { return {}; } };\n// In instantiation of 'constexpr A&lt;0&gt; f(X*)':\n// error: return type 'struct A&lt;0&gt;' is incomplete\nstruct X { friend constexpr A&lt;0&gt; f(X*); };\nauto&amp;&amp; a = f((X*)0);\n</code></pre>\n<p>This is accepted by clang and MSVC.</p>\n<p>As you have observed, gcc accepts the same program without <code>constexpr</code>, or if you explicitly instantiate <code>A&lt;0&gt;</code> (e.g. with <code>template struct A&lt;0&gt;;</code>) before <code>auto&amp;&amp; a = f((X*)0);</code>. This suggests that the problem gcc is having is in class template implicit instantiation <strong>[temp.inst]</strong>:</p>\n<blockquote>\n<p id=\"so_39530837_39536077_0\">1 - Unless a class template specialization has been explicitly instantiated (14.7.2) or explicitly specialized (14.7.3),\n  the class template specialization is implicitly instantiated when the specialization is referenced in a context\n  that requires a completely-defined object type or when the completeness of the class type affects the semantics\n  of the program.</p>\n</blockquote>\n<p>The class template <code>A&lt;0&gt;</code> is required at the <code>return</code> statement of <code>constexpr A&lt;0&gt; f(X*)</code>, so should be implicitly instantiated at that point. Although the friend function definition is lexically within the class <code>A</code>, the class should not be considered to be incomplete within the definition of the friend function; e.g. the following non-template program is universally accepted:</p>\n<pre><code>struct Y;\nstruct B { friend constexpr B f(Y*) { return {}; } };\nstruct Y { friend constexpr B f(Y*); };\nauto&amp;&amp; b = f((Y*)0);\n</code></pre>\n<p>Interestingly, both gcc <em>and</em> clang (though not MSVC) have trouble with the following program (again, fixed by removing <code>constexpr</code> or explicitly instantiating with <code>template struct C&lt;0&gt;;</code>):</p>\n<pre><code>struct Z;\ntemplate&lt;int&gt; struct C { friend constexpr C* f(Z*) { return 0; } };\nstruct Z { friend constexpr C&lt;0&gt;* f(Z*); };\n// error: inline function 'constexpr C&lt;0&gt;* f(Z*)' used but never defined\nauto&amp;&amp; c = f((Z*)0);\n</code></pre>\n<p>I would suggest using the explicit-instantiation workaround. In your case that would be:</p>\n<pre><code>template class Options_proxy&lt;File_options_impl&gt;;\n</code></pre>\n", "LastActivityDate": "2016-09-16T16:20:21.060", "CommentCount": "0", "CreationDate": "2016-09-16T16:20:21.060", "ParentId": "39530837", "Score": "1", "OwnerUserId": "567292"}, "39530837": {"ViewCount": "174", "Body": "<p>This is a mcve of my code: (if it matters, <code>Options_proxy</code> and <code>Options</code> have constexpr ctors). I am aware it's still far from simple, but couldn't simplify it more while still exhibiting the error:</p>\n<pre><code>template &lt;class Impl&gt;\nstruct Options_proxy : Impl {\n  using Flag = typename Impl::Flag;\n\n  friend constexpr auto operator!(Flag f) -&gt; Options_proxy {\n    return {}; // &lt;-- error here\n  };\n};\n\ntemplate &lt;class Impl&gt;\nstruct Options : Impl {\n  using Flag = typename Impl::Flag;\n};\n\nstruct File_options_impl {\n  enum class Flag : unsigned { nullflag, read, write  };\n\n  friend constexpr auto operator!(Flag f) -&gt; Options_proxy&lt;File_options_impl&gt;;\n};\n\nusing File_options = Options&lt;File_options_impl&gt;;\n\nauto foo()\n{\n  !File_options::Flag::write; // &lt;-- required from here\n}\n</code></pre>\n<p>gcc 6 and 7 give this error:</p>\n<pre><code>In instantiation of 'constexpr Options_proxy&lt;File_options_impl&gt; operator!(Options_proxy&lt;File_options_impl&gt;::Flag)':\nrequired from ... etc etc...\nerror: return type 'struct Options_proxy&lt;File_options_impl&gt;' is incomplete\n</code></pre>\n<p>clang compiles it OK.</p>\n<p>The code complies in gcc if:</p>\n<ul>\n<li>I remove the <code>constexpr</code> of the <code>operator!</code></li>\n</ul>\n<p>or</p>\n<ul>\n<li>add an object of type <code>Options_proxy&lt;File_options_impl&gt;</code> before the operator call:</li>\n</ul>\n<p>like this:</p>\n<pre><code>auto foo()\n{\n  Options_proxy&lt;File_options_impl&gt; o;\n  !File_options::Flag::write; // &lt;-- now OK in gcc also\n}\n</code></pre>\n<p>Is this a gcc bug or is some Undefined Behavior in the code, something like unspecified or no diagnostics required?</p>\n<hr>\n<p>As for motivation of writing such code:</p>\n<p>I want to create (for fun mostly) a type safe flag/options system (without macros):</p>\n<p>Library black magic:</p>\n<pre><code>template &lt;class Impl&gt;\n  requires Options_impl&lt;Impl&gt;\nstruct Options : Impl {\n   // go crazy\n};\n</code></pre>\n<p>User code:</p>\n<pre><code>struct File_options_impl {\n  // create a system where here the code\n  // needs to be as minimal as possible to avoid repetition and user errors\n\n  // this is what the user actually cares about\n  enum class Flag : unsigned { nullflag = 0, read = 1, write = 2, create = 4};\n\n  // would like not to need to write this,\n  // but can't find a way around it\n  friend constexpr auto operator!(Flag f1) -&gt; Options_proxy&lt;File_options_impl&gt;;\n  friend constexpr auto operator+(Flag f1, Flag f2) -&gt; Options_proxy&lt;File_options_impl&gt;;\n  friend constexpr auto operator+(Flag f1, Options_proxy&lt;File_options_impl&gt; f2) -&gt; Options_proxy&lt;File_options_impl&gt;;\n};\n\nusing File_options = Options&lt;File_options_impl&gt;;\n</code></pre>\n<p>and then:</p>\n<pre><code>auto open(File_options opts);\n\nusing F_opt = File_options::Flag;\nopen(F_opt::write + !F_opt::create);\n</code></pre>\n</hr>", "AcceptedAnswerId": "39536077", "Title": "Incomplete type in friend function", "CreationDate": "2016-09-16T11:52:48.063", "Id": "39530837", "CommentCount": "0", "LastEditDate": "2016-09-16T12:08:24.727", "PostTypeId": "1", "LastEditorUserId": "2805305", "LastActivityDate": "2016-09-16T16:20:21.060", "Score": "6", "OwnerUserId": "2805305", "Tags": "<c++><templates><language-lawyer><friend><incomplete-type>", "AnswerCount": "2"}, "39531972": {"Id": "39531972", "PostTypeId": "2", "Body": "<p>One problem I see with your code is that multiple implementations may have the same ::Flag member, meaning your friend operator potentially gets defined multiple times, violating the one definition rule.</p>\n<p>Also Options_proxy does not have any private members, so you don't need to make the operator a friend (I think you're abusing friend to define an external function inline).</p>\n<p>You need an unambiguous definition for your operator and I don't think it's possible with the current signature.</p>\n<hr>\n<p>Given a guarantee that Flags are unique, you could try to move the operator outside of Options_proxy.</p>\n<pre><code>template &lt;class Impl&gt;\nstruct Options_proxy : Impl {\n  using Flag = typename Impl::Flag;\n};\n\ntemplate &lt;class Impl, typename Flag = Impl::Flag&gt;\nconstexpr Options_proxy&lt;Impl&gt; operator!(Flag f) {\n  return {};\n}\n\ntemplate &lt;class Impl&gt;\nstruct Options : Impl {\n  using Flag = typename Impl::Flag;\n};\n\nstruct File_options_impl {\n  enum class Flag : unsigned { nullflag, read, write  };\n\n  friend constexpr Options_proxy&lt;File_options_impl&gt; operator!(Flag f);\n  // Or if that doesn't work:\n  friend constexpr Options_proxy&lt;File_options_impl&gt; operator!&lt;File_options_impl&gt;(Flag f);\n};\n</code></pre>\n</hr>", "LastEditorUserId": "5410505", "LastActivityDate": "2016-09-16T15:12:37.930", "Score": "0", "CreationDate": "2016-09-16T12:51:06.453", "ParentId": "39530837", "CommentCount": "1", "OwnerUserId": "5410505", "LastEditDate": "2016-09-16T15:12:37.930"}});