post_cb({"23938354": {"CommentCount": "1", "ViewCount": "51", "PostTypeId": "1", "LastEditorUserId": "157525", "CreationDate": "2014-05-29T16:38:13.060", "LastActivityDate": "2014-05-29T17:01:30.097", "Title": "C++ type coercion deduction", "AcceptedAnswerId": "23938813", "LastEditDate": "2014-05-29T16:47:08.353", "Id": "23938354", "Score": "1", "Body": "<p>I'm playing around with the Colvin-Gibbons trick for implementing move semantics in C++03 and I've got the following:</p>\n<pre><code>#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntemplate &lt;typename T&gt;\nclass buffer {\n    struct buffer_ref {\n        buffer_ref(T* data) : data_(data) {}\n        T* data_;\n    };\n\npublic:\n    buffer() : data_(NULL) {}\n    //explicit buffer(T* data) : data_(data)        {}\n    buffer(size_t size)      : data_(new T[size]) {}\n    buffer(buffer_ref other) : data_(other.data_) { other.data_ = NULL; } \n    buffer(buffer    &amp;other) : data_(other.data_) { other.data_ = NULL; }\n   ~buffer()                                      { delete [] data_;    }\n\n    operator buffer_ref() { buffer_ref ref(data_); data_ = NULL; return ref; }\n    operator T*()         { return data_;                                    }\n\nprivate:\n    T* data_;\n};\n\n\nint main() {\n    buffer&lt;float&gt; data(buffer&lt;float&gt;(128));\n    printf(\"ptr: %p\\n\", (float*)data);\n\n}   \n</code></pre>\n<p>Edit: formatting</p>\n<p>I'd like to be able to use my buffer as a pointer to the base type when convenient, so I've added a casting operator to the pointer type, which works just as expected.  However, if I uncomment my constructor that takes a pointer, then the the conversion deduction gets confused and complains about ambiguous conversion (because it can go buffer-&gt;T*-&gt;buffer or buffer-&gt;buffer_ref-&gt;buffer).  I would expect an explicit modifier on the pointer constructor to fix this, but it doesn't.  Can someone who understands the C++ conversion deduction better than me explain what the compilers thinking?</p>\n", "Tags": "<c++>", "OwnerUserId": "157525", "AnswerCount": "1"}, "23938813": {"ParentId": "23938354", "CommentCount": "1", "Body": "<p>This is a direct result of 13.3.1.3 <strong>[over.match.ctor]</strong>:</p>\n<blockquote>\n<p id=\"so_23938354_23938813_0\">When objects of class type are direct-initialized (8.5), or copy-initialized from an expression of the same or a derived class type (8.5), overload resolution selects the constructor. For direct-initialization, the candidate functions are all the constructors of the class of the object being initialized. For copy-initialization, the candidate functions are all the converting constructors (12.3.1) of that class. [...]</p>\n</blockquote>\n<p>Because <code>buffer&lt;float&gt; data(buffer&lt;float&gt;(128));</code> is a direct-initialization, you have explicitly requested that <code>explicit</code> constructors be considered.</p>\n<p>If you write:</p>\n<pre><code>buffer&lt;float&gt; data = buffer&lt;float&gt;(128);\n</code></pre>\n<p>then there is no ambiguity.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "23938813", "Score": "2", "CreationDate": "2014-05-29T17:01:30.097", "LastActivityDate": "2014-05-29T17:01:30.097"}, "bq_ids": {"n4140": {"so_23938354_23938813_0": {"section_id": 592, "quality": 0.9117647058823529, "length": 31}}, "n3337": {"so_23938354_23938813_0": {"section_id": 582, "quality": 0.9117647058823529, "length": 31}}, "n4659": {"so_23938354_23938813_0": {"section_id": 615, "quality": 0.9117647058823529, "length": 31}}}});