post_cb({"bq_ids": {"n4140": {"so_32983539_32983625_0": {"length": 27, "quality": 0.9, "section_id": 703}}, "n3337": {"so_32983539_32983625_1": {"length": 4, "quality": 0.8, "section_id": 1427}, "so_32983539_32983625_0": {"length": 27, "quality": 0.9, "section_id": 693}}, "n4659": {"so_32983539_32983625_0": {"length": 25, "quality": 0.8333333333333334, "section_id": 732}}}, "32983539": {"ViewCount": "69", "Body": "<p>The C++ standard doesn't mandate time complexity of memory allocation since that falls outside its domain (usually depends on however the OS behaves) but then does that mean anything with a specified complexity cannot dynamically allocate memory?</p>\n<p>For example, most of the containers in the standard library are required to have a constant time complexity default constructor so any implementation that pre-emptively dynamically allocates memory would violate the standard. (Whether that specific behavior is desirable is beside the point -- it's just an example that's meant to sound somewhat reasonable.) Is that right?</p>\n", "AcceptedAnswerId": "32983625", "Title": "Can operations with a time complexity mandated by the C++ standard dynamically allocate memory?", "CreationDate": "2015-10-07T03:55:03.813", "Id": "32983539", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2015-10-07T04:10:04.340", "Score": "2", "OwnerUserId": "1128289", "Tags": "<c++><standards><language-lawyer>", "AnswerCount": "1"}, "32983625": {"Id": "32983625", "PostTypeId": "2", "Body": "<p>The standard explicitly states what is included in \"time complexity\" it mandates: </p>\n<p><code>23.2.1[container.requirements.general]/2</code></p>\n<blockquote>\n<p id=\"so_32983539_32983625_0\">All of the complexity requirements in this Clause are stated solely in terms of the number of operations on the contained objects. [ Example: the copy constructor of type <code>vector &lt;vector&lt;int&gt; &gt;</code> has linear complexity, even though the complexity of copying each contained <code>vector&lt;int&gt;</code> is itself linear. \u2014 end example ]</p>\n</blockquote>\n<p>And for the functions outside that clause, complexity requirements are spelled out explicitly, e.g.</p>\n<p><code>25.4.3.1[lower.bound]/3</code> (that's <code>std::lower_bound</code>)</p>\n<blockquote>\n<p id=\"so_32983539_32983625_1\">Complexity: At most <code>log2(last - first) + O(1)</code> comparisons. </p>\n</blockquote>\n<p>(note that only comparisons are counted: lower_bound can, and, for forward iterators, will perform a linear scan)</p>\n<p>So yes, algorithms whose complexity is mandated by the standard can dynamically allocate memory, or do whatever else they feel like, as long as they satisfy the actual constraint.</p>\n", "LastEditorUserId": "273767", "LastActivityDate": "2015-10-07T04:10:04.340", "Score": "4", "CreationDate": "2015-10-07T04:04:49.423", "ParentId": "32983539", "CommentCount": "2", "OwnerUserId": "273767", "LastEditDate": "2015-10-07T04:10:04.340"}});