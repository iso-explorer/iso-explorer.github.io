post_cb({"bq_ids": {"n4140": {"so_40932844_40933634_1": {"length": 16, "quality": 0.6153846153846154, "section_id": 435}, "so_40932844_40933118_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 482}, "so_40932844_40933634_2": {"length": 8, "quality": 1.0, "section_id": 435}, "so_40932844_40933118_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 592}, "so_40932844_40933634_0": {"length": 56, "quality": 0.9032258064516129, "section_id": 489}}, "n3337": {"so_40932844_40933634_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 427}, "so_40932844_40933118_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 473}, "so_40932844_40933634_2": {"length": 8, "quality": 1.0, "section_id": 427}, "so_40932844_40933118_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 582}, "so_40932844_40933634_0": {"length": 56, "quality": 0.9032258064516129, "section_id": 480}}, "n4659": {"so_40932844_40933634_2": {"length": 7, "quality": 0.875, "section_id": 454}, "so_40932844_40933634_1": {"length": 16, "quality": 0.6153846153846154, "section_id": 454}, "so_40932844_40933118_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 615}}}, "40933634": {"Id": "40933634", "PostTypeId": "2", "Body": "<p>The gcc does not satisfy the C++ Standard. The inherited constructor of the class Derived should call the Base constructor in its mem-initializer list with the argument specified for the Derived inherited constructor.</p>\n<p>There is written in the C++ Standard (12.9 Inheriting constructor)</p>\n<blockquote>\n<p id=\"so_40932844_40933634_0\">8 An inheriting constructor for a class is implicitly de\ufb01ned when it\n  is odr-used (3.2) to create an object of its class type (1.8). An\n  implicitly-de\ufb01ned inheriting constructor performs the set of\n  initializations of the class that would be performed by a user-written\n  inline constructor for that class <strong>with a mem-initializer-list whose\n  only mem-initializer has a mem-initializer-id that names the base\n  class denoted in the nested-name-speci\ufb01er of the using-declaration and\n  an expression-list as speci\ufb01ed below</strong>, and where the\n  compound-statement in its function body is empty (12.6.2). If that\n  user-written constructor would be ill-formed, the program is\n  ill-formed. Each expression in the expression-list is of the form\n  static_cast(p), where p is the name of the corresponding\n  constructor parameter and T is the declared type of p.</p>\n</blockquote>\n<p>Also according to the section (12.6.2 Initializing bases and members)</p>\n<blockquote>\n<p id=\"so_40932844_40933634_1\">8 In a non-delegating constructor, if a given non-static data member\n  or base class is not designated by a mem-initializer-id (including the\n  case where there is no mem-initializer-list because the constructor\n  has noctor-initializer) and the entity is not a virtual base class of\n  an abstract class (10.4), then</p>\n<p id=\"so_40932844_40933634_2\">\u2014 if the entity is a non-static data member that has a\n  brace-or-equal-initializer, the entity is initialized as specified in\n  8.5;</p>\n</blockquote>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2016-12-02T16:19:51.697", "Score": "10", "CreationDate": "2016-12-02T13:44:06.880", "ParentId": "40932844", "CommentCount": "2", "OwnerUserId": "2877241", "LastEditDate": "2016-12-02T16:19:51.697"}, "40932844": {"ViewCount": "697", "Body": "<p>I am trying to use a combination of the C++ 11 direct data member initialisation and the \"using\" syntax to inherit the constructors of a base class. Now with gcc 5.4.0 (on Ubuntu 16.04) I observe a strange error, if the data member type has no default constructor. It is probably easiest to understand when looking on the following minimal example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo {\n  Foo(int arg) { std::cout &lt;&lt; \"Foo::Foo(\" &lt;&lt; arg &lt;&lt; \")\" &lt;&lt; std::endl; }\n};\n\nstruct Base {\n  Base(int arg) { std::cout &lt;&lt; \"Base::Base(\" &lt;&lt; arg &lt;&lt; \")\" &lt;&lt; std::endl; }\n};\n\nstruct Derived : public Base {\n  using Base::Base;\n  Foo foo{42};\n};\n\nint main() {\n  Derived derived{120};\n}\n</code></pre>\n<p>This code compiles and executes with the expected behaviour with clang. With gcc it does not compile, because the compiler deletes the constructor <code>Derived::Derived(int)</code>:</p>\n<pre><code>ttt.cpp: In function \u2018int main()\u2019:\nttt.cpp:17:22: error: use of deleted function \u2018Derived::Derived(int)\u2019\n   Derived derived{120};\n                      ^\nttt.cpp:12:15: note: \u2018Derived::Derived(int)\u2019 is implicitly deleted because the default definition would be ill-formed:\n   using Base::Base;\n               ^\nttt.cpp:12:15: error: no matching function for call to \u2018Foo::Foo()\u2019\nttt.cpp:4:3: note: candidate: Foo::Foo(int)\n   Foo(int arg) { std::cout &lt;&lt; \"Foo::Foo(\" &lt;&lt; arg &lt;&lt; \")\" &lt;&lt; std::endl; }\n   ^\nttt.cpp:4:3: note:   candidate expects 1 argument, 0 provided\nttt.cpp:3:8: note: candidate: constexpr Foo::Foo(const Foo&amp;)\n struct Foo {\n        ^\nttt.cpp:3:8: note:   candidate expects 1 argument, 0 provided\nttt.cpp:3:8: note: candidate: constexpr Foo::Foo(Foo&amp;&amp;)\nttt.cpp:3:8: note:   candidate expects 1 argument, 0 provided\n</code></pre>\n<p>If I add a default constructor to Foo like this:</p>\n<pre><code>  Foo() { std::cout &lt;&lt; \"Foo::Foo()\" &lt;&lt; std::endl; };\n</code></pre>\n<p>also gcc can compile it. The code behaves exactly in the same way, in particular the added default constructor of Foo never gets executed.</p>\n<p>So my question is now, is this valid C++ 11? If yes, I probably have found a bug in gcc. Otherwise, shouldn't both gcc and clang give me an error message that this is not valid C++ 11?</p>\n<p>Edit after the question was nicely answered by @vlad-from-moscow: This bug seems to be present also in gcc 6.2, so I will file a bug report.</p>\n<p>2nd edit: There already is a bug, which I didn't find in the first search: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67054\" rel=\"noreferrer\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67054</a></p>\n", "AcceptedAnswerId": "40933634", "Title": "Constructor inheritance and direct member initialisation", "CreationDate": "2016-12-02T13:00:21.387", "Id": "40932844", "CommentCount": "1", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2016-12-02T14:34:07.887", "LastEditorUserId": "5998125", "LastActivityDate": "2016-12-02T16:19:51.697", "ClosedDate": "2017-05-23T08:39:47.793", "Score": "22", "OwnerUserId": "5998125", "Tags": "<c++><c++11><gcc><constructor>", "AnswerCount": "2"}, "40933118": {"Id": "40933118", "PostTypeId": "2", "Body": "<p>It looks like you're right, there's a bug in gcc</p>\n<p>From \u00a712.9 [class.inhctor]:</p>\n<blockquote>\n<p id=\"so_40932844_40933118_0\">A <em>using-declaration</em> (7.3.3) that names a constructor implicitly declares a set of <em>inheriting constructors</em>. The\n  candidate set of <em>inherited constructors</em> from the class <code>X</code> named in the <em>using-declaration</em> consists of actual\n  constructors and notional constructors that result from the transformation of defaulted parameters as follows:<br/></p>\n<ul>\n<li>all non-template constructors of <code>X</code></li>\n</ul>\n</blockquote>\n<p>So this means that your <code>Derived</code> class should definnitely get a constructor from its base that accepts an <code>int</code>. Following the normal rules of in-class member initialization, constructing an instance of <code>Derived</code> shouldn't be a problem without a default constructor for <code>Foo</code> because it's not being used. Hence, there's a bug in gcc:</p>\n<p>\u00a713.3.1.3 Initialization by constructor [over.match.ctor]</p>\n<blockquote>\n<p id=\"so_40932844_40933118_1\">When objects of class type are direct-initialized (8.5) [...], overload resolution selects the constructor. For direct-initialization, <strong>the candidate\n  functions are all the constructors of the class of the object being initialized</strong>.</p>\n</blockquote>\n<p>So the constructor <code>Foo::Foo(int)</code> should have been selected, which it clearly wasn't in gcc.</p>\n<hr>\n<p>One question I had after reading this was \"Does this cause the default constructor for <code>Derived</code> to be deleted?\" The answer is no.</p>\n<p>Conveniently, the standard provides an example below this excerpt (I'm excising what's not needed):</p>\n<pre><code>struct B1 {\n   B1(int);\n};\n\nstruct D1 : B1 {\n   using B1::B1;\n};\n</code></pre>\n<blockquote>\n<p id=\"so_40932844_40933118_2\">The set of constructors present in <code>D1</code> is [<strong>Emphasis</strong> mine]</p>\n<ul>\n<li><strong><code>D1()</code>, implicitly-declared default constructor, ill-formed if odr-used</strong></li>\n<li><code>D1(const D1&amp;)</code>, implicitly-declared copy constructor, not inherited</li>\n<li><code>D1(D1&amp;&amp;)</code>, implicitly-declared move constructor, not inherited</li>\n<li><code>D1(int)</code>, implicitly-declared inheriting constructor</li>\n</ul>\n</blockquote>\n</hr>", "LastEditorUserId": "27678", "LastActivityDate": "2016-12-02T13:46:29.423", "Score": "5", "CreationDate": "2016-12-02T13:16:29.247", "ParentId": "40932844", "CommentCount": "4", "OwnerUserId": "27678", "LastEditDate": "2016-12-02T13:46:29.423"}});