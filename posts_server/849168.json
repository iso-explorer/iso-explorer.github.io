post_cb({"849190": {"Id": "849190", "PostTypeId": "2", "Body": "<p>This was missed from C++98 standard proper but later added as part of a TR. The forthcoming C++0x standard will of course contain this as a requirement.</p>\n<p>From n2798 (draft of C++0x):</p>\n<blockquote>\n<p id=\"so_849168_849190_0\"><strong>23.2.6 Class template vector [vector]</strong></p>\n<p id=\"so_849168_849190_1\">1 A vector is a sequence container that supports random access iterators. In addition, it supports (amortized)\n  constant time insert and erase operations at the end; insert and erase in the middle take linear time. Storage\n  management is handled automatically, though hints can be given to improve efficiency. The elements of a\n  vector are stored contiguously, meaning that if v is a vector where T is some type other\n  than bool, then it obeys the identity &amp;v[n] == &amp;v[0] + n for all 0 &lt;= n &lt; v.size().</p>\n</blockquote>\n", "LastActivityDate": "2009-05-11T17:42:47.057", "CommentCount": "8", "CreationDate": "2009-05-11T17:42:47.057", "ParentId": "849168", "Score": "76", "OwnerUserId": "66692"}, "851020": {"Id": "851020", "PostTypeId": "2", "Body": "<p>As other's have already said, <code>vector</code> internally uses a contiguous array of objects. Pointers into that array should be treated as invalid whenever any non-const member function is called IIRC.</p>\n<p>However, there is an exception!!</p>\n<p><code>vector&lt;bool&gt;</code> has a specialised implementation designed to save space, so that each bool only uses one bit. The underlying array is not a contiguous array of bool and array arithmetic on <code>vector&lt;bool&gt;</code> doesn't work like <code>vector&lt;T&gt;</code> would.</p>\n<p>(I suppose it's also possible that this may be true of any specialisation of vector, since we can always implement a new one. However, <code>std::vector&lt;bool&gt;</code> is the only, err, standard specialisation upon which simple pointer arithmetic won't work.)</p>\n", "LastActivityDate": "2009-05-12T03:23:10.167", "CommentCount": "1", "CreationDate": "2009-05-12T03:23:10.167", "ParentId": "849168", "Score": "5", "OwnerUserId": "93331"}, "849188": {"Id": "849188", "PostTypeId": "2", "Body": "<p>As other answers have pointed out, the contents of a vector is guaranteed to be continuous (excepting bool's weirdness).</p>\n<p>The comment that I wanted to add, is that if you do an insertion or a deletion on the vector, which could cause the vector to reallocate it's memory, then you will cause all of your saved pointers and iterators to be invalidated.</p>\n", "LastEditorUserId": "47453", "LastActivityDate": "2013-08-31T07:05:07.570", "Score": "11", "CreationDate": "2009-05-11T17:42:11.723", "ParentId": "849168", "CommentCount": "7", "OwnerUserId": "47453", "LastEditDate": "2013-08-31T07:05:07.570"}, "849168": {"ViewCount": "24374", "Body": "<p>My question is simple: are std::vector elements guaranteed to be contiguous?  In order word, can I use the pointer to the first element of a std::vector as a C-array?</p>\n<p>If my memory serves me well, the C++ standard did not make such guarantee.  However, the std::vector requirements were such that it was virtually impossible to meet them if the elements were not contiguous.</p>\n<p>Can somebody clarify this?</p>\n<p>Example:</p>\n<pre><code>std::vector&lt;int&gt; values;\n// ... fill up values\n\nif( !values.empty() )\n{\n    int *array = &amp;values[0];\n    for( int i = 0; i &lt; values.size(); ++i )\n    {\n        int v = array[i];\n        // do something with 'v'\n    }\n}\n</code></pre>\n", "AcceptedAnswerId": "849190", "Title": "Are std::vector elements guaranteed to be contiguous?", "CreationDate": "2009-05-11T17:38:05.037", "Id": "849168", "CommentCount": "6", "FavoriteCount": "27", "PostTypeId": "1", "LastEditDate": "2010-02-24T22:15:04.543", "LastEditorUserId": "33732", "LastActivityDate": "2013-08-31T07:05:07.570", "Score": "70", "OwnerUserId": "9936", "Tags": "<c++><vector><standards>", "AnswerCount": "7"}, "849173": {"Id": "849173", "PostTypeId": "2", "Body": "<p>Yes, the elements of a std::vector are guaranteed to be contiguous.</p>\n", "LastEditorUserId": "31640", "LastActivityDate": "2009-05-11T18:23:56.710", "Score": "2", "CreationDate": "2009-05-11T17:39:18.263", "ParentId": "849168", "CommentCount": "1", "OwnerUserId": "31640", "LastEditDate": "2009-05-11T18:23:56.710"}, "bq_ids": {"n4140": {"so_849168_849190_1": {"length": 48, "quality": 0.96, "section_id": 955}}, "n3337": {"so_849168_849190_1": {"length": 48, "quality": 0.96, "section_id": 943}}, "n4659": {"so_849168_849190_1": {"length": 27, "quality": 0.54, "section_id": 1016}}}, "849183": {"Id": "849183", "PostTypeId": "2", "Body": "<p>The standard does in fact guarantee that a <code>vector</code> is continuous in memory and that <code>&amp;a[0]</code> can be passed to a <code>C</code> function that expects an array.</p>\n<p>The exception to this rule is <code>vector&lt;bool&gt;</code> which only uses one bit per <code>bool</code> thus although it does have continuous memory it can't be used as a <code>bool*</code> (this is widely considered to be a false optimization and a mistake). </p>\n<p>BTW, why don't you use iterators? That's what they're for.</p>\n", "LastEditorUserId": "3848", "LastActivityDate": "2009-05-11T17:47:17.423", "Score": "6", "CreationDate": "2009-05-11T17:40:56.873", "ParentId": "849168", "CommentCount": "4", "OwnerUserId": "3848", "LastEditDate": "2009-05-11T17:47:17.423"}, "13781269": {"Id": "13781269", "PostTypeId": "2", "Body": "<p>I found this thread because I have a use case where vectors using contiguous memory is an advantage.</p>\n<p>I am learning how to use vertex buffer objects in OpenGL. I created a wrapper class to contain the buffer logic, so all I need to do is pass an array of floats and a few config values to create the buffer.\nI want to be able to generate a buffer from a function based on user input, so the length is not known at compile time. Doing something like this would be the easiest solution:</p>\n<pre><code>void generate(std::vector&lt;float&gt; v)\n{\n  float f = generate_next_float();\n  v.push_back(f);\n}\n</code></pre>\n<p>Now I can pass the vector's floats as an array to OpenGL's buffer-related functions. This also removes the need for sizeof to determine the length of the array.</p>\n<p>This is far better than allocating a huge array to store the floats and hoping I made it big enough, or making my own dynamic array with contiguous storage.</p>\n", "LastActivityDate": "2012-12-08T19:52:12.697", "CommentCount": "1", "CreationDate": "2012-12-08T19:52:12.697", "ParentId": "849168", "Score": "3", "OwnerUserId": "1888341"}, "849186": {"Id": "849186", "PostTypeId": "2", "Body": "<p><a href=\"http://www.cplusplus.com/reference/stl/vector/\" rel=\"nofollow noreferrer\">cplusplus.com:</a></p>\n<blockquote>\n<p id=\"so_849168_849186_0\">Vector containers are implemented as dynamic arrays; Just as regular arrays, vector containers have their elements stored in contiguous storage locations, which means that their elements can be accessed not only using iterators but also using offsets on regular pointers to elements.</p>\n</blockquote>\n", "LastActivityDate": "2009-05-11T17:41:47.403", "CommentCount": "0", "CreationDate": "2009-05-11T17:41:47.403", "ParentId": "849168", "Score": "1", "OwnerUserId": "44673"}});