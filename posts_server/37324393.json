post_cb({"bq_ids": {"n4140": {"so_37324393_37325450_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 464}}, "n3337": {"so_37324393_37325450_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 455}}, "n4659": {"so_37324393_37325450_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 487}}}, "37325450": {"Id": "37325450", "PostTypeId": "2", "Body": "<p>The rule, from [class.copy], is:</p>\n<blockquote>\n<p id=\"so_37324393_37325450_0\">The implicitly-defined copy/move constructor for a non-union class <code>X</code> performs a memberwise copy/move\n  of its bases and members. </p>\n</blockquote>\n<p>So in this case, it will move-construct/assign both <code>x_</code> and <code>y_</code>. from the <code>A</code> that you're move-construct/assigning from.</p>\n<hr/>\n<p>Note that a defaulted move constructor can <em>still perform copies</em> if one of its members has the move constructor not implicitly defined:</p>\n<pre><code>struct A {\n    A() { }\n    A(A const&amp; ) { }\n    // A(A&amp;&amp; ) not implicitly defined because of the copy ctor\n};\n\nstruct B {\n    B() = default;\n    B(B&amp;&amp; ) = default;\n    B&amp; operator=(B&amp;&amp; ) = default;\n\n    A a;\n};\n\nB b;\nB c = std::move(b); // copy-constructs c.a from b.a\n</code></pre>\n", "LastActivityDate": "2016-05-19T13:55:55.967", "CommentCount": "0", "CreationDate": "2016-05-19T13:55:55.967", "ParentId": "37324393", "Score": "3", "OwnerUserId": "2069064"}, "37324393": {"ViewCount": "211", "Body": "<p>I have a simple data class in which I want to save some typing and let the compiler generate the move constructor and assignment operator:</p>\n<pre><code>class A\n{\npublic:\n  A(int x, std::string&amp;&amp; y) : x_(x), y_(std::move(y)) {}\n  A(A &amp;&amp; a) = default;\n  A&amp; operator= (A &amp;&amp; a) = default;\nprivate:\n  int x_;\n  std::string y_;\n};\n</code></pre>\n<p>Assuming my compiler is 100% C++11 compliant, will it do the right thing with the <code>std::string y_</code> attribute? Will it apply move semantics to it?</p>\n", "AcceptedAnswerId": "37325450", "Title": "Default move constructor behavior with std::string attributes", "CreationDate": "2016-05-19T13:17:19.067", "Id": "37324393", "CommentCount": "5", "LastEditDate": "2016-05-19T13:43:39.880", "PostTypeId": "1", "LastEditorUserId": "485343", "LastActivityDate": "2016-05-19T13:55:55.967", "Score": "2", "OwnerUserId": "485343", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "37324575": {"Id": "37324575", "PostTypeId": "2", "Body": "<p>Yes, it will, that's the whole point of generating special member functions.</p>\n<p>However, you forgot to move the parameter of the constructor into the member:</p>\n<pre><code>A(int x, std::string&amp;&amp; y) : x_(x), y_(std::move(y)) {}\n//                                    ^^^^^^^^^^ ^\n</code></pre>\n", "LastActivityDate": "2016-05-19T13:23:48.723", "CommentCount": "1", "CreationDate": "2016-05-19T13:23:48.723", "ParentId": "37324393", "Score": "1", "OwnerUserId": "3233393"}});