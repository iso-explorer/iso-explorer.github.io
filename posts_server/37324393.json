post_cb({"37324393": {"CommentCount": "5", "ViewCount": "211", "PostTypeId": "1", "LastEditorUserId": "485343", "CreationDate": "2016-05-19T13:17:19.067", "LastActivityDate": "2016-05-19T13:55:55.967", "Title": "Default move constructor behavior with std::string attributes", "AcceptedAnswerId": "37325450", "LastEditDate": "2016-05-19T13:43:39.880", "Id": "37324393", "Score": "2", "Body": "<p>I have a simple data class in which I want to save some typing and let the compiler generate the move constructor and assignment operator:</p>\n<pre><code>class A\n{\npublic:\n  A(int x, std::string&amp;&amp; y) : x_(x), y_(std::move(y)) {}\n  A(A &amp;&amp; a) = default;\n  A&amp; operator= (A &amp;&amp; a) = default;\nprivate:\n  int x_;\n  std::string y_;\n};\n</code></pre>\n<p>Assuming my compiler is 100% C++11 compliant, will it do the right thing with the <code>std::string y_</code> attribute? Will it apply move semantics to it?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "485343", "AnswerCount": "2"}, "37325450": {"ParentId": "37324393", "CommentCount": "0", "Body": "<p>The rule, from [class.copy], is:</p>\n<blockquote>\n<p id=\"so_37324393_37325450_0\">The implicitly-defined copy/move constructor for a non-union class <code>X</code> performs a memberwise copy/move\n  of its bases and members. </p>\n</blockquote>\n<p>So in this case, it will move-construct/assign both <code>x_</code> and <code>y_</code>. from the <code>A</code> that you're move-construct/assigning from.</p>\n<hr/>\n<p>Note that a defaulted move constructor can <em>still perform copies</em> if one of its members has the move constructor not implicitly defined:</p>\n<pre><code>struct A {\n    A() { }\n    A(A const&amp; ) { }\n    // A(A&amp;&amp; ) not implicitly defined because of the copy ctor\n};\n\nstruct B {\n    B() = default;\n    B(B&amp;&amp; ) = default;\n    B&amp; operator=(B&amp;&amp; ) = default;\n\n    A a;\n};\n\nB b;\nB c = std::move(b); // copy-constructs c.a from b.a\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "37325450", "Score": "3", "CreationDate": "2016-05-19T13:55:55.967", "LastActivityDate": "2016-05-19T13:55:55.967"}, "bq_ids": {"n4140": {"so_37324393_37325450_0": {"section_id": 464, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_37324393_37325450_0": {"section_id": 455, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_37324393_37325450_0": {"section_id": 487, "quality": 0.9166666666666666, "length": 11}}}, "37324575": {"ParentId": "37324393", "CommentCount": "1", "Body": "<p>Yes, it will, that's the whole point of generating special member functions.</p>\n<p>However, you forgot to move the parameter of the constructor into the member:</p>\n<pre><code>A(int x, std::string&amp;&amp; y) : x_(x), y_(std::move(y)) {}\n//                                    ^^^^^^^^^^ ^\n</code></pre>\n", "OwnerUserId": "3233393", "PostTypeId": "2", "Id": "37324575", "Score": "1", "CreationDate": "2016-05-19T13:23:48.723", "LastActivityDate": "2016-05-19T13:23:48.723"}});