post_cb({"39885551": {"ParentId": "39885423", "CommentCount": "6", "Body": "<p>The standard seems to indicate that:</p>\n<pre><code>R\"\"\"line 1\nline 2\nline3\"\"\"\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code>\"line 1\\nline 2\\nline3\"\n</code></pre>\n<p>From <strong>2.14.5 String literals</strong> of the C++11 standard:</p>\n<blockquote>\n<p id=\"so_39885423_39885551_0\">4 [ <em>Note:</em> A source-file new-line in a raw string literal results in a new-line in the resulting execution <em>string literal</em>. Assuming no whitespace at the beginning of lines in the following example, the assert will succeed:</p>\n<pre><code>const char *p = R\"(a\\\nb\nc)\";\nassert(std::strcmp(p, \"a\\\\\\nb\\nc\") == 0);\n</code></pre>\n<p id=\"so_39885423_39885551_1\">\u2014<em>end note</em> ]</p>\n<p id=\"so_39885423_39885551_2\">5 [ <em>Example:</em> The raw string</p>\n<pre><code>R\"a(\n)\\\na\"\n)a\"\n</code></pre>\n<p id=\"so_39885423_39885551_3\">is equivalent to <code>\"\\n)\\\\\\na\\\"\\n\"</code>.</p>\n</blockquote>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "39885551", "Score": "15", "CreationDate": "2016-10-06T00:11:02.553", "LastActivityDate": "2016-10-06T00:11:02.553"}, "39885423": {"CommentCount": "15", "CreationDate": "2016-10-05T23:54:20.120", "PostTypeId": "1", "AcceptedAnswerId": "39886017", "LastEditorUserId": "116", "LastActivityDate": "2016-10-07T05:05:34.960", "LastEditDate": "2016-10-06T23:24:46.807", "ViewCount": "1786", "FavoriteCount": "1", "Title": "C++: Is there a standard definition for end-of-line in a multi-line string constant?", "Id": "39885423", "Score": "37", "Body": "<p>If I have a multi-line string C++11 string constant such as</p>\n<pre><code>R\"\"\"line 1\nline 2\nline3\"\"\"\n</code></pre>\n<p>Is it defined what character(s) the line terminator/separator consist of?</p>\n", "Tags": "<c++><c++11><portability>", "OwnerUserId": "116", "AnswerCount": "3"}, "39885473": {"ParentId": "39885423", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2016-10-06T00:00:02.127", "Score": "9", "LastEditorUserId": "464581", "LastEditDate": "2016-10-07T05:05:34.960", "Id": "39885473", "OwnerUserId": "464581", "Body": "<p><sup>Note: the question has changed substantially since the answers were posted. Only half of it remains, namely the pure C++ aspect. The network focus in this answer addresses the original question's \u201csending a multi-line string to a server with well-defined end-of-line requirements\u201d. I do not chase question evolution in general.</sup></p>\n<p>Internally in the program, the C++ standard for newline is <code>\\n</code>. This is used also for newline in a raw literal. There is no special convention for raw literals.</p>\n<p>Usually <code>\\n</code> maps to ASCII linefeed, which is the value 10.</p>\n<p>I'm not sure what it maps to in EBCDIC, but you can check that if needed.</p>\n<p>On the wire, however, it's my impression that most protocols use ASCII carriage return plus linefeed, i.e. 13 followed by 10. This is sometimes called <strong>CRLF</strong>, after the ASCII abbreviations CR for carriage return and LF for linefeed. When the C++ escapes are mapped to ASCII this is simply <code>\\r\\n</code> in C++.</p>\n<p>You need to abide by the requirements of the protocol you're using.</p>\n<p>For ordinary file/stream i/o the C++ standard library takes care of mapping the internal <code>\\n</code> to whatever convention the host environment uses. This is called <em>text mode</em>, as opposed to <em>binary mode</em> where no mapping is performed.</p>\n<p>For network i/o, which is not covered by the standard library, the application code must do this itself, either directly or via some library functions.</p>\n<hr>\n<p>There is an <em>active issue</em> about this, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1655\" rel=\"nofollow\">core language defect report #1655</a> \u201cLine endings in raw string literals\u201d, submitted by Mike Miller 2013-04-26, where he asks,</p>\n<blockquote>\n<p id=\"so_39885423_39885473_0\"><strong>\u201d</strong> is it intended that, for example, a CRLF in the source of a raw string literal is to be represented as a newline character or as the original characters?</p>\n</blockquote>\n<p>Since line ending values differ depending on the encoding of the original file, and considering that in some file systems there <em>is not</em> an encoding of line endings, but instead lines as records, it's clear that the intention is not to represent the file contents as-is  \u2013  since that's impossible to do in all cases. But as far as I can see this DR is not yet resolved.</p>\n</hr>", "LastActivityDate": "2016-10-07T05:05:34.960"}, "39886017": {"ParentId": "39885423", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-10-06T01:15:52.020", "Score": "27", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:33:29.757", "Id": "39886017", "OwnerUserId": "827263", "Body": "<p>The intent is that a newline in a raw string literal maps to a single\n<code>'\\n'</code> character.  This intent is not expressed as clearly as it\nshould be, which has led to some confusion.</p>\n<p>Citations are to the 2011 ISO C++ standard.</p>\n<p>First, here's the evidence that it maps to a single <code>'\\n'</code> character.</p>\n<p>A note in section 2.14.5 [lex.string] paragraph 4 says:</p>\n<blockquote>\n<p id=\"so_39885423_39886017_0\">[ <em>Note:</em> A source-file new-line in a raw string literal results in a\n  new-line in the resulting execution <em>string-literal</em>. Assuming no\n  whitespace at the beginning of lines in the following example, the\n  assert will succeed:</p>\n</blockquote>\n<pre><code>    const char *p = R\"(a\\\n    b\n    c)\";\n    assert(std::strcmp(p, \"a\\\\\\nb\\nc\") == 0);\n</code></pre>\n<blockquote>\n<p id=\"so_39885423_39886017_1\">\u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>This clearly states that a newline is mapped to a single <code>'\\n'</code>\ncharacter.  It also matches the observed behavior of g++ 6.2.0 and\nclang++ 3.8.1 (tests done on a Linux system using source files with\nUnix-style and Windows-style line endings).</p>\n<p>Given the clearly stated intent in the note and the behavior of two\npopular compilers, I'd say it's safe to rely on this -- though it\nwould be interesting to see how other compilers actually handle this.</p>\n<p>However, a literal reading of the <em>normative</em> wording of the\nstandard could easily lead to a different conclusion, or at least\nto some uncertainty.</p>\n<p>Section 2.5 [lex.pptoken] paragraph 3 says (emphasis added):</p>\n<blockquote>\n<p id=\"so_39885423_39886017_2\">Between the initial and final double quote characters of the\n  raw string, <strong>any</strong> transformations performed in phases 1 and 2\n  <strong>(trigraphs, universal-character-names, and line splicing)</strong>\n  are reverted; this reversion shall apply before any <em>d-char</em>,\n  <em>r-char</em>, or delimiting parenthesis is identified.</p>\n</blockquote>\n<p>The phases of translation are specified in 2.2 [lex.phases]. In phase 1:</p>\n<blockquote>\n<p id=\"so_39885423_39886017_3\">Physical source file characters are mapped, in an\n  implementation-defined manner, to the basic source character set\n  (introducing new-line characters for end-of-line indicators) if\n  necessary.</p>\n</blockquote>\n<p>If we assume that the mapping of physical source file characters to the\nbasic character set and the introduction of new-line characters are\n\"<em>tranformations</em>\", we might reasonably conclude that, for example,\na newline in the middle of a raw string literal in a Windows-format\nsource file should be equivalent to a <code>\\r\\n</code> sequence.  (I can imagine\nthat being useful for Windows-specific code.)</p>\n<p>(This interpretation does lead to problems with systems where the\nend-of-line indicator is not a sequence of characters, for example\nwhere each line is a fixed-width record.  Such systems are rare\nthese days.)</p>\n<p>As <a href=\"https://stackoverflow.com/a/39885473/827263\">\"Cheers and hth. - Alf\"'s answer</a>\npoints out, there is an open\n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1655\" rel=\"nofollow noreferrer\">Defect Report</a>\nfor this issue.  It was submitted in 2013 and has not yet been\nresolved.</p>\n<p>Personally, I think the root of the confusion is the word \"any\"\n(emphasis added as before):</p>\n<blockquote>\n<p id=\"so_39885423_39886017_4\">Between the initial and final double quote characters of the raw\n  string, <strong>any</strong> transformations performed in phases 1 and 2 <strong>(trigraphs,\n  universal-character-names, and line splicing)</strong> are reverted; this\n  reversion shall apply before any <em>d-char</em>, <em>r-char</em>, or delimiting\n  parenthesis is identified.</p>\n</blockquote>\n<p>Surely the mapping of physical source file characters to\nthe basic source character set can reasonably be thought of\nas a <em>transformation</em>. The parenthesized clause \"(trigraphs,\nuniversal-character-names, and line splicing)\" seems to be intended\nto specify <em>which</em> transformations are to be reverted, but that\neither attempts to change the meaning of the word \"transformations\"\n(which the standard does not formally define) or contradicts the use\nof the word \"any\".</p>\n<p>I suggest that changing the word \"any\" to \"certain\" would express\nthe apparent intent much more clearly:</p>\n<blockquote>\n<p id=\"so_39885423_39886017_5\">Between the initial and final double quote characters of the raw\n  string, certain transformations performed in phases 1 and 2 (trigraphs,\n  universal-character-names, and line splicing) are reverted; this\n  reversion shall apply before any <em>d-char</em>, <em>r-char</em>, or delimiting\n  parenthesis is identified.</p>\n</blockquote>\n<p>This wording would make it much clearer that \"trigraphs,\nuniversal-character-names, and line splicing\" are the only\ntransformations that are to be reverted. (Not everything done\nin translation phases 1 and 2 is reverted, just those specific\nlisted transformations.)</p>\n", "LastActivityDate": "2016-10-06T02:45:47.467"}, "bq_ids": {"n4140": {"so_39885423_39885551_0": {"section_id": 5352, "quality": 0.8571428571428571, "length": 18}, "so_39885423_39886017_5": {"section_id": 5322, "quality": 0.96, "length": 24}, "so_39885423_39886017_0": {"section_id": 5352, "quality": 0.9, "length": 18}, "so_39885423_39885473_0": {"section_id": 5313, "quality": 0.5833333333333334, "length": 7}, "so_39885423_39886017_2": {"section_id": 5322, "quality": 1.0, "length": 24}, "so_39885423_39886017_3": {"section_id": 5313, "quality": 0.9411764705882353, "length": 16}, "so_39885423_39886017_4": {"section_id": 5322, "quality": 1.0, "length": 24}}, "n3337": {"so_39885423_39885551_0": {"section_id": 5149, "quality": 0.8571428571428571, "length": 18}, "so_39885423_39886017_4": {"section_id": 5119, "quality": 1.0, "length": 24}, "so_39885423_39886017_0": {"section_id": 5149, "quality": 0.9, "length": 18}, "so_39885423_39885473_0": {"section_id": 5110, "quality": 0.5833333333333334, "length": 7}, "so_39885423_39886017_2": {"section_id": 5119, "quality": 1.0, "length": 24}, "so_39885423_39886017_3": {"section_id": 5110, "quality": 0.9411764705882353, "length": 16}, "so_39885423_39886017_5": {"section_id": 5119, "quality": 0.96, "length": 24}}, "n4659": {"so_39885423_39885551_0": {"section_id": 6777, "quality": 0.9523809523809523, "length": 20}, "so_39885423_39886017_5": {"section_id": 6743, "quality": 0.92, "length": 23}, "so_39885423_39886017_0": {"section_id": 6777, "quality": 0.9, "length": 18}, "so_39885423_39885473_0": {"section_id": 6737, "quality": 0.5833333333333334, "length": 7}, "so_39885423_39886017_4": {"section_id": 6743, "quality": 0.9583333333333334, "length": 23}, "so_39885423_39886017_3": {"section_id": 6737, "quality": 0.9411764705882353, "length": 16}, "so_39885423_39886017_2": {"section_id": 6743, "quality": 0.9583333333333334, "length": 23}}}});