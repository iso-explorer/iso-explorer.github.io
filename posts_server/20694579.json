post_cb({"bq_ids": {"n4140": {"so_20694579_20694693_0": {"length": 14, "quality": 1.0, "section_id": 6185}, "so_20694579_20694693_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 5768}}, "n3337": {"so_20694579_20694693_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 5541}}, "n4659": {"so_20694579_20694693_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 7687}, "so_20694579_20694693_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 7225}}}, "20694579": {"ViewCount": "401", "Body": "<p>There are 11 references to the expression <code>core constant expression</code> in the latest draft of the C++11 Standard (N3690), and none of them defines what this entity is.</p>\n<p>One can also find that the expression <code>core constant expression</code> is pretty well defined <a href=\"http://en.cppreference.com/w/cpp/language/constant_expression\" rel=\"nofollow\">here</a> , basically in the same terms that the Standard uses to define the expression <code>conditional-expression</code>.</p>\n<p>Therefore, I would like to get some input on this issue, which seems to me, to be wrong in the Standard.</p>\n<p>Now, assuming the definition in <a href=\"http://en.cppreference.com/w/cpp/language/constant_expression\" rel=\"nofollow\">cppreference</a> is correct I would also like to know why the following snippet compiles in <a href=\"http://coliru.stacked-crooked.com/\" rel=\"nofollow\">Coliru</a> and in <a href=\"http://ideone.com/em6ygf\" rel=\"nofollow\">Ideone</a>, despite item (10) in the alluded definition?</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    const double x = 2.;\n    constexpr double y = x;\n    std::cout &lt;&lt; y &lt;&lt; std::endl;\n}\n</code></pre>\n<p>I'm specifically thinking in terms of the <code>lvalue to rvalue implicit conversion</code> of variable <code>x</code> in the expression <code>constexpr double y = x;</code>, which is not covered by any of the clauses (a), (b) and (c) in item (10) referred above.</p>\n<p>Thanks for the help.</p>\n", "AcceptedAnswerId": "20694693", "Title": "What is a core constant expression in the C++11 Standard?", "CreationDate": "2013-12-20T00:59:09.977", "Id": "20694579", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2013-12-20T22:55:41.960", "Score": "2", "OwnerUserId": "2548699", "Tags": "<c++><c++11><language-lawyer><constant-expression>", "AnswerCount": "1"}, "20694693": {"Id": "20694693", "PostTypeId": "2", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\" rel=\"nofollow\">N3690</a> <em>does</em> define the term \"core constant expression in 5.19p2 [expr.const]:</p>\n<blockquote>\n<p id=\"so_20694579_20694693_0\">A <em>conditional-expression</em> <strong>e</strong> is a <em>core constant expression</em> unless the\n  evaluation of <strong>e</strong>, following the rules of the abstract machine (1.9),\n  would evaluate one of the following expressions:</p>\n<p id=\"so_20694579_20694693_1\">[list omitted]</p>\n</blockquote>\n<p>The released ISO C++ 2011 standard defines it in the same section.</p>\n<p>As for whether that's actually a definition, see also section 1.3, paragraph 3:</p>\n<blockquote>\n<p id=\"so_20694579_20694693_2\">Terms that are used only in a small portion of this International\n  Standard are defined where they are used and italicized where they are\n  defined.</p>\n</blockquote>\n<p>The standard also uses italics for syntactic categories such as <em>conditional-expression</em>, but \"core constant expression\" is a defined term, not a syntactic category (it's subtle, but you can tell by the use of spaces rather than hyphens to separate the words).</p>\n<p>As for the sample code:</p>\n<pre><code>const double x = 2.;\nconstexpr double y = x;\n</code></pre>\n<p>my reading of the standard is that this is invalid, because <code>x</code> is <em>not</em> a <em>core constant expression</em>. It would be valid if <code>x</code> and <code>y</code> were of some integer or enumeration type, but there's no such permission for floating-point. An lvalue-to-rvalue conversion (converting the name of the object <code>x</code> to its value <code>2.0</code>) is not permitted in a <em>core constant expression</em> unless it meets one of three listed criteria (see C11 5.19, 9th bullet, three sub-bullets).</p>\n<p>This implies that the compilers that accept the above code without a diagnostic are non-conforming (i.e., buggy). (Unless I'm missing something, which is entirely possible.)</p>\n<p>Which implies that <a href=\"http://en.cppreference.com/w/cpp/language/constant_expression\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/constant_expression</a> is wrong. It says that a core constant expression may contain an lvalue-to-rvalue conversion of an lvalue that \"has literal type and refers to an object defined with a constant expression (or to its subobject)\". The actual standard has a stronger requirement: the object must be defined with <code>constexpr</code>. (Perhaps cppreference.com was based on an earlier draft?)</p>\n<p>So the sample code could be made valid by changing it to:</p>\n<pre><code>constexpr double x = 2.;\nconstexpr double y = x;\n</code></pre>\n", "LastEditorUserId": "827263", "LastActivityDate": "2013-12-20T22:55:41.960", "Score": "5", "CreationDate": "2013-12-20T01:13:19.627", "ParentId": "20694579", "CommentCount": "10", "OwnerUserId": "827263", "LastEditDate": "2013-12-20T22:55:41.960"}});