post_cb({"34153950": {"ParentId": "33829101", "CommentCount": "1", "Body": "<p>This is mainly a compilation of comments to question.</p>\n<p>It appears that old MSVC versions used to incorrectly process conversions of 64 bits integers to 64 bits double precision number.</p>\n<p>The bug in present in versions below 2008.</p>\n<p>MSCV 2010 is wrong using 32 bits mode and correct in 64 bits mode</p>\n<p>All versions starting with 2012 are correct.</p>\n", "OwnerUserId": "3545273", "PostTypeId": "2", "Id": "34153950", "Score": "1", "CreationDate": "2015-12-08T10:51:58.530", "LastActivityDate": "2015-12-08T10:51:58.530"}, "33829101": {"CommentCount": "17", "ViewCount": "495", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-11-20T14:26:37.987", "LastActivityDate": "2015-12-08T10:51:58.530", "Title": "Incorrect double to long conversion", "AcceptedAnswerId": "34153950", "LastEditDate": "2017-05-23T10:28:44.217", "Id": "33829101", "Score": "11", "Body": "<p>This is mainly a followup to <a href=\"https://stackoverflow.com/q/33824954/3545273\">this other question</a>, that was about a <em>weird</em> conversion from long to double and back again to long for big values.</p>\n<p>I already know that converting a float to an integral type does truncate, if that is the truncated value cannot be represented in target type, the behaviour is undefined:</p>\n<blockquote>\n<p id=\"so_33829101_33829101_0\">4.9 Floating-integral conversions [conv.fpint]</p>\n<p id=\"so_33829101_33829101_1\">A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates;\n  that is, the fractional part is discarded. The behavior is undefined if the truncated value cannot be\n  represented in the destination type.</p>\n</blockquote>\n<p>But here is my code to demonstrate the problem, assuming a little endian architecture, where both long long and long double use 64 bits:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\nint main()\n{\n  unsigned long long ull = 0xf000000000000000;\n  long double d = static_cast&lt;long double&gt;(ull);\n  // dump the IEE-754 number for a little endian system\n  unsigned char * pt = reinterpret_cast&lt;unsigned char *&gt;(&amp;d);\n  for (int i = sizeof(d) -1; i&gt;= 0; i--) {\n      cout &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; static_cast&lt;unsigned int&gt;(pt[i]); \n  }\n  cout &lt;&lt; endl;\n  unsigned long long ull2 = static_cast&lt;unsigned long long&gt;(d);\n  cout &lt;&lt; ull &lt;&lt; endl &lt;&lt; d &lt;&lt; endl &lt;&lt; ull2 &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p>The output is (using MSVC 2008 32bits on a old XP 32 box):</p>\n<pre class=\"lang-none prettyprint-override\"><code>43ee000000000000\nf000000000000000\n1.72938e+019\n8000000000000000\n</code></pre>\n<p>Explainations for values:</p>\n<ul>\n<li>0xf000000000000000 is 17293822569102704640 in decimal, so the conversion to double is correct.</li>\n<li>43ee000000000000 : mantissa part is e000000000000 adding the implied 1 it correctly represents 4 bits with <code>1</code> followed with <code>0</code> - exponent is 43e after removing the 3ff bias it gives a binary representation of 1.111 2<sup>63</sup> so the exact representation of 0xf000000000000000 or 17293822569102704640 (<a href=\"https://en.wikipedia.org/wiki/Floating_point\" rel=\"nofollow noreferrer\">ref</a>)</li>\n</ul>\n<p>As that value can be represented as an unsigned long long, I expected that its conversion to an unsigned long long gives original value, and MSVC gives 0x8000000000000000 or 9223372036854775808</p>\n<p>The question is: is that conversion caused by undefined behaviour as suggested by the accepted answer to the other question or is it really a MSVC bug?</p>\n<p>(Note: same code on CLang compiler on a FreeBSD 10.1 box gives correct results)</p>\n<p>For references, I could find the generated code:</p>\n<pre><code>  unsigned long long ull2 = static_cast&lt;unsigned long long&gt;(d);\n0041159E  fld         qword ptr [d] \n004115A1  call        @ILT+490(__ftol2) (4111EFh) \n004115A6  mov         dword ptr [ull2],eax \n004115A9  mov         dword ptr [ebp-40h],edx \n</code></pre>\n<p>And the code for _ftol2 seems to be (got from debugger at execution time):</p>\n<pre><code>00411C66  push        ebp  \n00411C67  mov         ebp,esp \n00411C69  sub         esp,20h \n00411C6C  and         esp,0FFFFFFF0h \n00411C6F  fld         st(0) \n00411C71  fst         dword ptr [esp+18h] \n00411C75  fistp       qword ptr [esp+10h] \n00411C79  fild        qword ptr [esp+10h] \n00411C7D  mov         edx,dword ptr [esp+18h] \n00411C81  mov         eax,dword ptr [esp+10h] \n00411C85  test        eax,eax \n00411C87  je          integer_QnaN_or_zero (411CC5h) \n00411C89  fsubp       st(1),st \n00411C8B  test        edx,edx \n00411C8D  jns         positive (411CADh) \n00411C8F  fstp        dword ptr [esp] \n00411C92  mov         ecx,dword ptr [esp] \n00411C95  xor         ecx,80000000h \n00411C9B  add         ecx,7FFFFFFFh \n00411CA1  adc         eax,0 \n00411CA4  mov         edx,dword ptr [esp+14h] \n00411CA8  adc         edx,0 \n00411CAB  jmp         localexit (411CD9h) \n00411CAD  fstp        dword ptr [esp] \n00411CB0  mov         ecx,dword ptr [esp] \n00411CB3  add         ecx,7FFFFFFFh \n00411CB9  sbb         eax,0 \n00411CBC  mov         edx,dword ptr [esp+14h] \n00411CC0  sbb         edx,0 \n00411CC3  jmp         localexit (411CD9h) \n00411CC5  mov         edx,dword ptr [esp+14h] \n00411CC9  test        edx,7FFFFFFFh \n00411CCF  jne         arg_is_not_integer_QnaN (411C89h) \n00411CD1  fstp        dword ptr [esp+18h] \n00411CD5  fstp        dword ptr [esp+18h] \n00411CD9  leave            \n00411CDA  ret \n</code></pre>\n", "Tags": "<c++><visual-c++>", "OwnerUserId": "3545273", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33829101_33829101_1": {"section_id": 37, "quality": 0.9166666666666666, "length": 22}}, "n3337": {"so_33829101_33829101_1": {"section_id": 34, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_33829101_33829101_1": {"section_id": 37, "quality": 0.8333333333333334, "length": 20}}}});