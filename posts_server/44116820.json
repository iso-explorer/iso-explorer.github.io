post_cb({"44119380": {"ParentId": "44116820", "CommentCount": "0", "Body": "<p>Though - as mentioned by others - the integral division behaves as you expect, may be the following solution looks \"less wired\" (still opinion based).</p>\n<p>Concerning a solution that converts an int to a double: I personally feel that this is to expensive just for the sake of rounding, but maybe someone can convince me that my feeling is wrong;</p>\n<p>Anyway, by using just integral operators, the following solution makes the discussion on whether a <code>double</code>'s mantissa can always hold every <code>int</code> superfluous:</p>\n<pre><code>int RoundToMultiple(int toRound, int multiple) {\n    toRound += multiple / 2;\n    return toRound - (toRound%multiple);\n}\n</code></pre>\n<p>If you also wanted to include negative values, the code could be slightly adapted as follows (including tests):</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint RoundToMultiple(int toRound, int multiple) {\n    toRound += toRound &lt; 0 ? -multiple / 2 : multiple / 2;\n    return toRound - (toRound%multiple);\n}\n\nint main(int argc, char const *argv[])\n{\n    int tests[] = { 36,99,123,164,-36,-99,-123,-164,0 };\n    int expectedResults[] = { 0,100,100,200,0,-100,-100,-200,0 };\n\n    int i=0;\n    int test=0, result=0, expectedResult=0;\n    do {\n        test = tests[i];\n        result = RoundToMultiple(test, 100);\n        expectedResult = expectedResults[i];\n        printf(\"test %d: %d==%d ? %s\\n\", test, result, expectedResult, (expectedResult==result ? \"OK\" : \"NOK!\"));\n        i++;\n    }\n    while(test != 0);\n}\n</code></pre>\n", "OwnerUserId": "2630032", "PostTypeId": "2", "Id": "44119380", "Score": "0", "CreationDate": "2017-05-22T18:06:40.650", "LastActivityDate": "2017-05-22T18:06:40.650"}, "44116820": {"CommentCount": "4", "AcceptedAnswerId": "44116971", "PostTypeId": "1", "LastEditorUserId": "6730520", "CreationDate": "2017-05-22T15:30:29.417", "LastActivityDate": "2017-05-22T20:45:04.277", "LastEditDate": "2017-05-22T15:38:40.570", "ViewCount": "378", "FavoriteCount": "0", "Title": "Rounding integer to nearest multiple of another integer", "Id": "44116820", "Score": "6", "Body": "<p>I need to round integers to be the nearest multiple of another integer. Examples for results in the case of multiples of 100:</p>\n<ul>\n<li>36-&gt;0</li>\n<li>99-&gt;100</li>\n<li>123-&gt;100</li>\n<li>164-&gt;200</li>\n</ul>\n<p>and so on.</p>\n<p>I came up with the following code, that works, but feels \"dirty\":</p>\n<pre><code>int RoundToMultiple(int toRound, int multiple)\n{\n    return (toRound + (multiple / 2)) / multiple * multiple;\n}\n</code></pre>\n<p>This counts on the truncating properties of integer division to make it work.\nCan I count on this code to be portable? Are there any compiler setups where this will fail to give me the desired result? If there are, how can I achieve the same results in a portable way?</p>\n<p>If needed for a better answer, it can be assumed that multiples will be powers of 10 (including multiples of 1). Numbers can also be assumed to all be positive.</p>\n", "Tags": "<c++>", "OwnerUserId": "6730520", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_44116820_44116935_1": {"section_id": 6137, "quality": 0.9, "length": 9}, "so_44116820_44116971_0": {"section_id": 6137, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_44116820_44116935_1": {"section_id": 5901, "quality": 0.9, "length": 9}, "so_44116820_44116971_0": {"section_id": 5901, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_44116820_44116935_1": {"section_id": 7634, "quality": 0.9, "length": 9}, "so_44116820_44116971_0": {"section_id": 7634, "quality": 0.8235294117647058, "length": 14}}}, "44116935": {"ParentId": "44116820", "CommentCount": "0", "Body": "<p>The C++ standard explicitly specifies the behavior of integer division thusly:</p>\n<blockquote>\n<p id=\"so_44116820_44116935_0\">[expr.mul]</p>\n<p id=\"so_44116820_44116935_1\">For integral operands the / operator yields the algebraic\n  quotient with any fractional part discarded.</p>\n</blockquote>\n<p>A.k.a. truncation towards zero. This is as portable as it gets.</p>\n", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "44116935", "Score": "2", "CreationDate": "2017-05-22T15:38:09.530", "LastActivityDate": "2017-05-22T15:38:09.530"}, "44116971": {"ParentId": "44116820", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Yes, you can count on this code to be portable.  <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">N4296</a> (which is the latest open draft of C++14) says in section 5.6 [expr.mul]:</p>\n<blockquote>\n<p id=\"so_44116820_44116971_0\">For\n  integral operands the / operator yields the algebraic quotient with any fractional part discarded.  [Footnote: This is often called truncation towards zero]</p>\n</blockquote>\n<p>This is not a new feature of the latest C++, it could be relied on in C89 too.</p>\n<p>The only caveat, is that if <code>toRound</code> is <em>negative</em>, you need to subtract the offset.</p>\n<p>An alternative approach is:</p>\n<pre><code>int RoundToMultiple(int toRound, int multiple)\n{\n    const auto ratio = static_cast&lt;double&gt;(toRound) / multiple;\n    const auto iratio = std::lround(ratio);\n    return iratio * multiple;\n}\n</code></pre>\n<p>This avoid messy +/- offsets, but performance will be worse, and there are problems if <code>toRound</code> is so large that it can't be held precisely in a double.  (OTOH, if this is for output, then I suspect <code>multiple</code> will be similarly large in this case, so you will be alright.)</p>\n", "OwnerUserId": "771073", "LastEditorUserId": "771073", "LastEditDate": "2017-05-22T20:45:04.277", "Id": "44116971", "Score": "4", "CreationDate": "2017-05-22T15:39:44.583", "LastActivityDate": "2017-05-22T20:45:04.277"}});