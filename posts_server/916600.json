post_cb({"916600": {"CommentCount": "7", "AcceptedAnswerId": "916691", "PostTypeId": "1", "LastEditorUserId": "142", "CreationDate": "2009-05-27T16:06:14.330", "LastActivityDate": "2009-05-27T17:18:39.253", "LastEditDate": "2009-05-27T17:18:39.253", "ViewCount": "6733", "FavoriteCount": "3", "Title": "Can a C++ compiler re-order elements in a struct", "Id": "916600", "Score": "8", "Body": "<p>Can a C++ compiler (specifically g++) re-order the internal elements of a struct?</p>\n<p>I'm seeing some strange behaviour where I have a structure that contains something like the following:</p>\n<pre><code>Struct SomeStruct{\n   ...\n   ...\n   long someLong;\n   long someLongArray[25];\n   unsigned long someUnsignedLong;\n   unsigned long someUnsignedLongArray[8];\n   unsigned long int someUnsignedLongInt;\n   ...\n   ...\n};\n</code></pre>\n<p>When I write output this to file, the order of <em>someUnsignedLongArray</em> and <em>someLongArray</em> seem to be reversed (i.e. the elements in <em>someLongArray[]</em> appear after <em>someUnsignedLong</em> and the elements of <em>someUnsignedLongArray[]</em> appear after <em>someLong</em>). Is this possible??</p>\n<p>Thanks</p>\n<hr>\n<p>Update:\nAs requested, I am writing out the structure using the following:</p>\n<pre><code>int fd = open(fspec,O_RDWR|O_CREAT|O_TRUNC,0666);\nint writeRes =  write(fd,(char *)&amp;someStruct,sizeof(SomeStruct));\n</code></pre>\n<p>For completeness, here is the full struct:</p>\n<pre><code>struct SomeStruct{\nbyte someByte;\nbyte someByteArray[6];\nchar someChar;\nchar someCharArray[5];\nchar someCharArrayArray[3][5];\nshort someShort;\nsigned short someShortArray[2];\nunsigned short someUnsignedShort;\nunsigned short someUnsignedShortArray[8];\nint someInt;\nint someIntArray[3];\nint someIntArrayArrayArrayArray[4][3][2][6];\nint *pSomeInt;\nunsigned int someUnsignedInt;\nunsigned int someUnsignedIntArray[9];\nlong someLong;\nlong someLongArray[25];\nunsigned long someUnsignedLong;\nunsigned long someUnsignedLongArray[8];\nunsigned long int someUnsignedLongInt;\nlong long someLongLong;\nlong long someLongLongArray[5];\nbool someBool;\nbool someBoolArray[3];\nunsigned long long someUnsignedLongLong;\nunsigned long long someUnsignedLongLongArray[5];\nunsigned long long someUnsignedLongLongArrayArray[5][2];\nunsigned long long int *pSomeUnsignedLongLongInt;\n};\n</code></pre>\n</hr>", "Tags": "<c++><struct><order><element>", "OwnerUserId": "142", "AnswerCount": "2"}, "916651": {"ParentId": "916600", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It can't, see <a href=\"https://stackoverflow.com/questions/867471/automated-field-re-ordering-in-c-structs-to-avoid-padding\">Automated field re-ordering in C structs to avoid padding</a> and <a href=\"https://stackoverflow.com/questions/118068/why-doesnt-gcc-optimize-structs\">Why doesn't GCC optimize structs?</a> for further information.  </p>\n<p>I don't know what you mean with \"reversed\", perhaps you should add some code and the output.</p>\n", "OwnerUserId": "73299", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:32:14.287", "Id": "916651", "Score": "6", "CreationDate": "2009-05-27T16:13:12.863", "LastActivityDate": "2009-05-27T16:13:12.863"}, "916691": {"ParentId": "916600", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It normally can't reorder elements, no. </p>\n<p>An exception is if there's an access specifier separating them:</p>\n<pre><code>struct Foo {    \n  A a;\n  B b;\n  C c;\nprivate:\n  D d;\n  E e;\n  F f;\n};\n</code></pre>\n<p>a, b and c are guaranteed to be stored in this order, and d, e and f are guaranteed to be stored in order. But there is no guarantees about where a, b and c are stored relative to d, e and f.</p>\n<p>Another thing to keep in mind is that the compiler can insert as much padding as it likes, even if it doesn't reorder anything.</p>\n<p>Here's the relevant part of the standard:</p>\n<p>Section 9.2.12:</p>\n<blockquote>\n<p id=\"so_916600_916691_0\">Nonstatic data members of a\n  (non-union) class declared without an\n  intervening access-specifier are\n  allocated so that later members have\n  higher addresses within a class\n  object. The order of allocation of\n  nonstatic data members separated by an\n  access-specifier is unspecified\n  (11.1)\"</p>\n</blockquote>\n", "OwnerUserId": "33213", "LastEditorUserId": "33213", "LastEditDate": "2009-05-27T16:54:58.770", "Id": "916691", "Score": "26", "CreationDate": "2009-05-27T16:20:24.490", "LastActivityDate": "2009-05-27T16:54:58.770"}, "bq_ids": {"n4140": {"so_916600_916691_0": {"section_id": 5873, "quality": 0.7407407407407407, "length": 20}}, "n3337": {"so_916600_916691_0": {"section_id": 5644, "quality": 0.7407407407407407, "length": 20}}, "n4659": {"so_916600_916691_0": {"section_id": 7356, "quality": 0.7407407407407407, "length": 20}}}});