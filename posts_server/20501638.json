post_cb({"bq_ids": {"n4140": {"so_20501638_20501979_5": {"length": 29, "quality": 0.8529411764705882, "section_id": 6955}}, "n3337": {"so_20501638_20501979_5": {"length": 29, "quality": 0.8529411764705882, "section_id": 6702}}, "n4659": {"so_20501638_20501979_5": {"length": 29, "quality": 0.8529411764705882, "section_id": 8452}}}, "20502351": {"Id": "20502351", "PostTypeId": "2", "Body": "<p>Because you have two elements there.</p>\n", "LastActivityDate": "2013-12-10T18:23:18.087", "CommentCount": "4", "CreationDate": "2013-12-10T18:23:18.087", "ParentId": "20501638", "Score": "1", "OwnerUserId": "560648"}, "20501638": {"ViewCount": "779", "Body": "<p>Why when I init std::vector with braces</p>\n<pre><code>std::vector&lt;TS&gt; vec {ts1, ts2};\n</code></pre>\n<p>Compiler call twice copy constructor operator? On the other hand - with push_back it called only once.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TS{\n    TS(){\n        cout&lt;&lt;\"default constructor\\n\";\n    }\n\n    TS(const TS &amp;other) {\n        cout&lt;&lt;\"Copy constructor\\n\";\n    }\n\n    TS(TS &amp;&amp;other) noexcept{\n        cout&lt;&lt;\"Move constructor\\n\";\n    }\n\n    TS&amp; operator=(TS const&amp; other)\n    {\n        cout&lt;&lt;\"Copy assigment\\n\";\n        return *this;\n    }\n\n    TS&amp; operator=(TS const&amp;&amp; other) noexcept\n    {\n        cout&lt;&lt;\"Move assigment\\n\";\n        return *this;\n    }\n\n    ~TS(){\n        cout&lt;&lt;\"destructor\\n\";\n    }\n\n};\n\nint main() {\n    TS ts1;\n    TS ts2;\n    cout&lt;&lt;\"-----------------------------------------\\n\";\n    std::vector&lt;TS&gt; vec {ts1, ts2};\n    //vec.push_back(ts1);\n    //vec = {ts1, ts2};\n    cout&lt;&lt;\"-----------------------------------------\\n\";\n\n\n\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/qcPG7X\" rel=\"nofollow\">http://ideone.com/qcPG7X</a></p>\n", "AcceptedAnswerId": "20501979", "Title": "std::vector init with braces call copy constructor twice", "CreationDate": "2013-12-10T17:48:02.497", "Id": "20501638", "CommentCount": "11", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-12-10T19:17:09.493", "LastEditorUserId": "1559666", "LastActivityDate": "2013-12-10T19:17:09.493", "Score": "2", "OwnerUserId": "1559666", "Tags": "<c++><stdvector><curly-braces><brace-initialization>", "AnswerCount": "2"}, "20501979": {"Body": "<p>From what I understand, <code>initializer_list</code>s pass everything by const-reference. It is probably not safe to <code>move</code> from one. The <code>initializer_list</code> constructor of a <code>vector</code> will copy each of the elements. </p>\n<p>Here are some links:\n<a href=\"https://stackoverflow.com/questions/8193102/initializer-list-and-move-semantics\">initializer_list and move semantics</a></p>\n<blockquote>\n<p id=\"so_20501638_20501979_0\">No, that won't work as intended; you will still get copies. I'm pretty\n  surprised by this, as I'd thought that initializer_list existed to\n  keep an array of temporaries until they were move'd.</p>\n<p id=\"so_20501638_20501979_1\">begin and end for initializer_list return const T *, so the result of\n  move in your code is T const &amp;&amp; \u2014 an immutable rvalue reference. Such\n  an expression can't meaningfully be moved from. It will bind to an\n  function parameter of type T const &amp; because rvalues do bind to const\n  lvalue references, and you will still see copy semantics.</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/13957166/is-it-safe-to-move-elements-of-a-initializer-list?rq=1\">Is it safe to move elements of a initializer list?</a></p>\n<blockquote>\n<p id=\"so_20501638_20501979_2\">initializer_list only provides const access to its elements. You could\n  use const_cast to make that code compile, but then the moves might end\n  up with undefined behaviour (if the elements of the initializer_list\n  are truly const). So, no it is not safe to do this moving. There are\n  workarounds for this, if you truly need it.</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/8468774/can-i-list-initialize-a-vector-of-move-only-type?rq=1\">Can I list-initialize a vector of move-only type?</a></p>\n<blockquote>\n<p id=\"so_20501638_20501979_3\">The synopsis of  in 18.9 makes it reasonably clear\n  that elements of an initializer list are always passed via\n  const-reference. Unfortunately, there does not appear to be any way of\n  using move-semantic in initializer list elements in the current\n  revision of the language.</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/17623098/questions-regarding-the-design-of-stdinitializer-list/17623839#17623839\">questions regarding the design of std::initializer_list</a></p>\n<blockquote>\n<p id=\"so_20501638_20501979_4\">From section 18.9 of the C++ Standard:</p>\n<p id=\"so_20501638_20501979_5\">An object of type initializer_list provides access to an array of objects of type const E. [ Note: A pair of pointers or a pointer plus\n  a length would be obvious representations for initializer_list.\n  initializer_list is used to implement initializer lists as specified\n  in 8.5.4. Copying an initializer list does not copy the underlying\n  elements. \u2014 end note ]</p>\n<p id=\"so_20501638_20501979_6\">I think the reason for most of these things is that\n  std::initializer_list isn't actually a container. It doesn't have\n  value semantics, it has pointer semantics. Which is made obvious by\n  the last portion of the quote: Copying an initializer list does not\n  copy the underlying elements. Seeing as they were intended solely for\n  the purpose of initializing things, I don't think it's that surprising\n  that you don't get all the niceties of more robust containers such as\n  tuples.</p>\n</blockquote>\n<p><strike>If I understand the last part correctly, it means that two sets of copies are needed since <code>initializer_list</code> does not copy the underlying elements.</strike> (The previous quote is only relevant if you attempt to use an <code>initializer_list</code> without copying out the elements.)</p>\n<p><a href=\"https://stackoverflow.com/questions/16894566/what-is-the-underlying-structure-of-stdinitializer-list\">What is the underlying structure of std::initializer_list?</a></p>\n<blockquote>\n<p id=\"so_20501638_20501979_7\">No, you can't move from the elements of an initializer_list, since\n  elements of an initializer_list are supposed to be immutable (see the\n  first sentence of the paragraph quoted above). That's also the reason\n  why only const-qualified member functions give you access to the\n  elements.</p>\n</blockquote>\n<hr/>\n<p>If you want, you can use <code>emplace_back</code>:</p>\n<pre><code>vec.emplace_back(TS());\nvec.emplace_back(TS());\nvec.push_back(std::move(ts1));\nvec.push_back(std::move(ts2));\n</code></pre>\n", "CreationDate": "2013-12-10T18:04:12.397", "ParentId": "20501638", "CommentCount": "1", "LastEditDate": "2017-05-23T11:50:30.543", "PostTypeId": "2", "LastEditorDisplayName": "user1508519", "OwnerDisplayName": "user1508519", "LastEditorUserId": "-1", "LastActivityDate": "2013-12-10T18:20:42.410", "Id": "20501979", "Score": "2"}});