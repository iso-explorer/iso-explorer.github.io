post_cb({"5015089": {"ParentId": "5014061", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The non-zero constant is there because the macro does not work with null pointers. We know that the value of a null pointer is a null pointer constant which evaluates to <code>0</code>:</p>\n<blockquote>\n<p id=\"so_5014061_5015089_0\"><strong>C++ Standard 4.10/1 Pointer conversions [conv.ptr]:</strong></p>\n<p id=\"so_5014061_5015089_1\">A null pointer constant is an integral\n  constant expression (5.19) rvalue of\n  integer type that evaluates to zero. A\n  null pointer constant can be converted\n  to a pointer type; the result is the\n  null pointer value of that type and is\n  distinguishable from every other value\n  of pointer to object or pointer to\n  function type....</p>\n</blockquote>\n<p>This is the relevant clause with respect to converting from a derived class to a base class pointer type:</p>\n<blockquote>\n<p id=\"so_5014061_5015089_2\"><strong>C++ Standard 4.10/3 Pointer conversions [conv.ptr]:</strong></p>\n<p id=\"so_5014061_5015089_3\">An rvalue of type \u201cpointer to cv D,\u201d\n  where D is a class type, can be\n  converted to an rvalue of type\n  \u201cpointer to cv B,\u201d where B is a base\n  class (clause 10) of D. If B is an\n  inaccessible (clause 11) or ambiguous\n  (10.2) base class of D, a program that\n  necessitates this conversion is\n  ill-formed. The result of the\n  conversion is a pointer to the base\n  class sub-object of the derived class\n  object. <strong>The null pointer value is\n  converted to the null pointer value of\n  the destination type.</strong></p>\n</blockquote>\n<p>Basically null pointers prevent pointer arithmetic from kicking in during a derived-to-base conversion; you will just get another null pointer. The arithmetic is used to \"fix\" non-null pointers during such conversions so that it points to the proper subobject. The <code>offsetofclass</code> macro depends on this arithmetic to determine the offset.</p>\n<p>The number <code>8</code> used is arbitrary. You could've used any number there like <code>1</code> or <code>4</code>, as long as it wasn't zero.</p>\n", "OwnerUserId": "308661", "LastEditorUserId": "308661", "LastEditDate": "2011-02-16T10:34:46.103", "Id": "5015089", "Score": "2", "CreationDate": "2011-02-16T10:12:36.573", "LastActivityDate": "2011-02-16T10:34:46.103"}, "bq_ids": {"n4140": {"so_5014061_5015089_1": {"section_id": 39, "quality": 0.6666666666666666, "length": 22}, "so_5014061_5015089_3": {"section_id": 41, "quality": 0.8409090909090909, "length": 37}}, "n3337": {"so_5014061_5015089_1": {"section_id": 36, "quality": 0.8181818181818182, "length": 27}, "so_5014061_5015089_3": {"section_id": 38, "quality": 0.8409090909090909, "length": 37}}, "n4659": {"so_5014061_5015089_1": {"section_id": 39, "quality": 0.6666666666666666, "length": 22}, "so_5014061_5015089_3": {"section_id": 41, "quality": 0.8409090909090909, "length": 37}}}, "5014061": {"CommentCount": "0", "ViewCount": "558", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-02-16T08:21:41.620", "LastActivityDate": "2011-02-16T10:34:46.103", "Title": "What's the use of _ATL_PACKING constant when computing distance from the start of object?", "AcceptedAnswerId": "5015089", "LastEditDate": "2017-05-23T12:20:39.183", "Id": "5014061", "Score": "0", "Body": "<p>ATL features <a href=\"http://msdn.microsoft.com/en-us/library/xfb1zk2x(v=vs.80).aspx\" rel=\"nofollow noreferrer\">a set of macros for so-called COM maps</a>. COM map is a table that associates an interface GUID with an offset that is to be added to <code>this</code> pointer to get to the corresponding subobject - the whole stuff works as replacement to <a href=\"https://stackoverflow.com/q/1742848/57428\">explicit <code>static_cast</code> for the upcast inside <code>IUnknown::QueryInterface()</code></a>.</p>\n<p>The map entries are built by using <code>offsetofclass</code> macro:</p>\n<pre><code>#define _ATL_PACKING 8\n#define offsetofclass(base, derived)\\\n    ((DWORD_PTR)(static_cast&lt;base*&gt;((derived*)_ATL_PACKING))-_ATL_PACKING)\n</code></pre>\n<p>which I'll rewrite as the following pseudocode \"function\" for readability in this question:</p>\n<pre><code>derived* derivedPointer = (derived*)_ATL_PACKING;\nbase* basePointer = static_cast&lt;base*&gt;(derivedPointer);\nDWORD_PTR offset = (DWORD_PTR)(basePointer)-_ATL_PACKING;\n</code></pre>\n<p>Looks reasonable - it obtains a pointer to an imaginary derived object, then does an explicit <code>static_cast</code> to shift the pointer, then computes distance between those imaginary objects.</p>\n<p>The question is why is the constant 8 there? Why do we need that constant and why is it chosen to be 8?</p>\n", "Tags": "<c++><com><macros><casting><atl>", "OwnerUserId": "57428", "AnswerCount": "1"}});