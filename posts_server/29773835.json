post_cb({"bq_ids": {"n4140": {"so_29773835_29774235_0": {"length": 36, "quality": 1.0, "section_id": 243}}, "n3337": {"so_29773835_29774235_0": {"length": 36, "quality": 1.0, "section_id": 235}}, "n4659": {"so_29773835_29774235_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 250}}}, "29773835": {"ViewCount": "299", "Body": "<p>We all know a C++ class template does not generate member functions that are not used, as illustrated below:</p>\n<pre><code>template&lt;typename T&gt;\nclass A\n{\n    public:\n    void WrongFunction(T t);\n    void RightFunction(T t);\n};\n\ntemplate&lt;typename T&gt;\nvoid A&lt;T&gt;::WrongFunction(T t)\n{\n    std::vector&lt;T&gt; v;\n    auto a = \"abc\" - v;\n}\n\ntemplate&lt;typename T&gt;\nvoid A&lt;T&gt;::RightFunction(T t)\n{\n    std::cout &lt;&lt; \"Success\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n    A&lt;int&gt; a;\n    a.RightFunction(2);\n    //a.WrongFunction(1);\n    return 0;\n}\n</code></pre>\n<p>Since the WrongFunction is not called in main, there's no actual code generated for it and therefore no compilation error occurs.</p>\n<p>Now, let's introduce an abstract base class that defines the interface for class A(basically, template inheritance):</p>\n<pre><code>template&lt;typename T&gt;\nclass Base\n{\n    public:\n    virtual void RightFunction(T t) = 0;\n    virtual void WrongFunction(T t) = 0;\n};\n\ntemplate&lt;typename T&gt;\nclass A : Base&lt;T&gt;\n{\n    public:\n    void WrongFunction(T t) override;\n    void RightFunction(T t) override;\n};\n\ntemplate&lt;typename T&gt;\nvoid A&lt;T&gt;::WrongFunction(T t)\n{\n    std::vector&lt;T&gt; v;\n    auto a = \"abc\" - v;\n}\n\ntemplate&lt;typename T&gt;\nvoid A&lt;T&gt;::RightFunction(T t)\n{\n    std::cout &lt;&lt; \"Success\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n    A&lt;int&gt; a;\n    a.RightFunction(2);\n    //a.WrongFunction(1);\n    return 0;\n}\n</code></pre>\n<p>Suddenly, the compiler refuses to work:</p>\n<blockquote>\n<p id=\"so_29773835_29773835_0\">prog.cc: In instantiation of 'void A::WrongFunction(T) [with T =\n  int]': prog.cc:39:1:   required from here prog.cc:24:20: error: no\n  match for 'operator-' (operand types are 'const char [4]' and\n  'std::vector &gt;')\n       auto a = \"abc\" - v;</p>\n</blockquote>\n<p>My understanding of the work flow is, in main, I say create an instance of A. Fine, the compiler then finds the template declaration for A(note that A is not a class; <code>A&lt;SomeType&gt;</code> is.). Wow, it depends on <code>Base&lt;int&gt;</code>. Fine, the compiler then finds the template declaration for Base, plugs int into the position held by T - now we have the declaration for the class <code>Base&lt;int&gt;</code>, but no definition is generated - after all, we did not provide a template for definition generation for <code>Base&lt;SomeType&gt;</code>, and no one has ever created any instance of <code>Base&lt;int&gt;</code> or has called a function on the instance. That's fine. Then the compiler extends the declaration of <code>Base&lt;int&gt;</code> and generates the declaration of <code>A&lt;int&gt;</code>. Wait, on the next line, RightFunction is called. So the compiler finds the template definition for RightFunction for A and plugs in the specific type int and generates the member function definition for A.</p>\n<p><strong>Since WrongFunction is never called(no specialization involved either; no explicit instantiation either), the compiler shouldn't even try to generate the code for <code>A&lt;int&gt;</code>::WrongFunction --- my question is, what the heck is going on?</strong></p>\n<p>Compiler: gcc 4.9.2</p>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "29774235", "Title": "Full template instantiation forced in C++ template inheritance?", "CreationDate": "2015-04-21T13:37:48.980", "Id": "29773835", "CommentCount": "1", "LastEditDate": "2015-04-21T13:52:56.887", "PostTypeId": "1", "LastEditorUserId": "241631", "LastActivityDate": "2015-04-21T13:59:42.093", "Score": "3", "OwnerUserId": "1190955", "Tags": "<c++><templates><c++11><inheritance><instantiation>", "AnswerCount": "1"}, "29774235": {"Id": "29774235", "PostTypeId": "2", "Body": "<p>From N3337, <em>\u00a714.7.1/10 [temp.inst]</em></p>\n<blockquote>\n<p id=\"so_29773835_29774235_0\">An implementation shall not implicitly instantiate a function template, a member template, a non-virtual member function, a member class, or a static data member of a class template that does not require instantiation. <strong>It is unspecified whether or not an implementation implicitly instantiates a virtual member function of a class template if the virtual member function would not otherwise be instantiated.</strong> ...</p>\n</blockquote>\n<p>So it's legal for an implementation to instantiate the virtual member function even though you never call it. </p>\n<p>In practice, this is likely to always be the case because when instantiating a class template the compiler also needs to instantiate the vtable for that class which must be filled with the addresses of virtual member functions.</p>\n", "LastEditorUserId": "241631", "LastActivityDate": "2015-04-21T13:59:42.093", "Score": "4", "CreationDate": "2015-04-21T13:52:42.560", "ParentId": "29773835", "CommentCount": "5", "OwnerUserId": "241631", "LastEditDate": "2015-04-21T13:59:42.093"}});