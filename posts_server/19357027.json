post_cb({"19436896": {"Id": "19436896", "PostTypeId": "2", "Body": "<p>The standard description of <code>partial</code> return code of <code>codecvt::do_out</code> says exactly this:</p>\n<p>in Table 83:</p>\n<blockquote>\n<p id=\"so_19357027_19436896_0\"><code>partial</code> not all source characters converted</p>\n</blockquote>\n<p>In 22.4.1.4.2[locale.codecvt.virtuals]/5:</p>\n<blockquote>\n<p id=\"so_19357027_19436896_1\"><em>Returns:</em> An enumeration value, as summarized in Table 83. A return value of <code>partial</code>, if <code>(from_next==from_end)</code>, indicates that either the destination sequence\n  has not absorbed all the available destination elements, or that additional source elements are needed before another destination element can be produced.</p>\n</blockquote>\n<p>In your case, not all (zero) source characters were converted, which technically says nothing of the contents of the output sequence (the 'if' clause in the sentence is not entered), but speaking generally, \"the destination sequence has not absorbed all the available destination elements\" here talks about valid multibyte characters. They are the <em>elements</em> of the multibyte character sequence produced by <code>codecvt_utf8</code>.</p>\n<p>It would be nice to have a more explicit standard wording, but here are two circumstantial pieces of evidence:</p>\n<p>One: the old C's wide-to-multibyte conversion function <code>std::wcsrtombs</code> (whose locale-specific variants are usually called by the existing implementations of <code>codecvt::do_out</code> for system-supplied locales) is defined as follows:</p>\n<blockquote>\n<p id=\"so_19357027_19436896_2\">Conversion stops [...] when the next multibyte character would exceed the limit of len total bytes to be stored into the array pointed to by dst.</p>\n</blockquote>\n<p>And two, look at the existing implementations of <code>codecvt_utf8</code>: you've already explored Microsoft's, and here's what's in libc++: <code>codecvt_utf8::do_out</code> here calls <code>ucs2_to_utf8</code> on Windows and <code>ucs4_to_utf8</code> on other systems, and ucs2_to_utf8 <a href=\"http://llvm.org/svn/llvm-project/libcxx/trunk/src/locale.cpp\" rel=\"nofollow\">does the following</a> (comments mine):</p>\n<pre><code>        else if (wc &lt; 0x0800)\n        {\n            // not relevant\n        }\n        else // if (wc &lt;= 0xFFFF)\n        {\n            if (to_end-to_nxt &lt; 3)\n                return codecvt_base::partial; // &lt;- look here\n            *to_nxt++ = static_cast&lt;uint8_t&gt;(0xE0 |  (wc &gt;&gt; 12));\n            *to_nxt++ = static_cast&lt;uint8_t&gt;(0x80 | ((wc &amp; 0x0FC0) &gt;&gt; 6));\n            *to_nxt++ = static_cast&lt;uint8_t&gt;(0x80 |  (wc &amp; 0x003F));\n        }\n</code></pre>\n<p>nothing is written to the output sequence if it cannot fit a multibyte character that results from consuming one input wide character.</p>\n", "LastActivityDate": "2013-10-17T20:44:11.160", "CommentCount": "3", "CreationDate": "2013-10-17T20:44:11.160", "ParentId": "19357027", "Score": "4", "OwnerUserId": "273767"}, "bq_ids": {"n4140": {"so_19357027_19436896_0": {"length": 5, "quality": 1.0, "section_id": 5313}, "so_19357027_19436896_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 6519}}, "n3337": {"so_19357027_19436896_0": {"length": 5, "quality": 1.0, "section_id": 5110}, "so_19357027_19436896_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 6274}}, "n4659": {"so_19357027_19436896_0": {"length": 5, "quality": 1.0, "section_id": 6737}, "so_19357027_19436896_1": {"length": 25, "quality": 0.8928571428571429, "section_id": 8001}}}, "19357027": {"ViewCount": "2117", "Body": "<p>Here is a snippet of a code that is using <code>std::codecvt_utf8&lt;&gt;</code> facet to convert from <code>wchar_t</code> to UTF-8. With Visual Studio 2012, my expectations are not met (see the condition at the end of the code). Are my expectations wrong? Why? Or is this a Visual Studio 2012 library issue?</p>\n<pre><code>#include &lt;locale&gt;\n#include &lt;codecvt&gt;\n#include &lt;cstdlib&gt;\n\nint main ()\n{\n    std::mbstate_t state = std::mbstate_t ();\n    std::locale loc (std::locale (), new std::codecvt_utf8&lt;wchar_t&gt;);\n    typedef std::codecvt&lt;wchar_t, char, std::mbstate_t&gt; codecvt_type;\n    codecvt_type const &amp; cvt = std::use_facet&lt;codecvt_type&gt; (loc);\n\n    wchar_t ch = L'\\u5FC3';\n    wchar_t const * from_first = &amp;ch;\n    wchar_t const * from_mid = &amp;ch;\n    wchar_t const * from_end = from_first + 1;\n\n    char out_buf[1];\n    char * out_first = out_buf;\n    char * out_mid = out_buf;\n    char * out_end = out_buf + 1;\n\n    std::codecvt_base::result cvt_res\n        = cvt.out (state, from_first, from_end, from_mid,\n            out_first, out_end, out_mid);\n\n    // This is what I expect:\n    if (cvt_res == std::codecvt_base::partial\n        &amp;&amp; out_mid == out_end\n        &amp;&amp; state != 0)\n        ;\n    else\n        abort ();\n}\n</code></pre>\n<p>The expectation here is that the <code>out()</code> function output one byte of the UTF-8 conversion at a time but the middle of the <code>if</code> conditional above is false with Visual Studio 2012.</p>\n<h1>UPDATE</h1>\n<p>What fails is the <code>out_mid == out_end</code> and <code>state != 0</code> conditions. Basically, I expect at least one byte to be produced and the necessary state, for next byte of the UTF-8 sequence to be producible, to be stored in the <code>state</code> variable.</p>\n", "AcceptedAnswerId": "19436896", "Title": "trouble with std::codecvt_utf8 facet", "CreationDate": "2013-10-14T09:18:52.357", "Id": "19357027", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-10-18T08:36:55.777", "LastEditorUserId": "341065", "LastActivityDate": "2013-10-18T08:36:55.777", "Score": "4", "OwnerUserId": "341065", "Tags": "<c++><visual-studio><utf-8><locale><codecvt>", "AnswerCount": "2"}, "19434879": {"Id": "19434879", "PostTypeId": "2", "Body": "<p>Although there is no direct reference of it, I'd think that is most logical behavior of <code>std::codecvt::out</code>. Consider following scenario:</p>\n<ul>\n<li>You use <code>std::codecvt::out</code> in the same manner as you did - not translating any characters (possibly without knowing) into your <code>out_buf</code>.</li>\n<li>You now want to translate another string into your <code>out_buf</code> (again using <code>std::codecvt::out</code>) such that it appends the content which is already inside</li>\n<li>To do so, you decide to use your <code>buf_mid</code> as you know it points directly after your string that you translated in the first step.</li>\n<li>Now, if <code>std::codecvt::out</code> worked according to your expectations (<code>buf_mid</code> pointing to the character after first) then the first character of your <code>out_buf</code> would never be written which would not be exactly what you would want/expect in this case.</li>\n</ul>\n<p>In essence, <code>extern_type*&amp; to_next</code> (last parameter of <code>std::codecvt::out</code>) is here for you as a reference of where you left of - so you know where to continue - which is in your case indeed the same position as where you started (<code>extern_type* to</code>) parameter. </p>\n<ul>\n<li><p><a href=\"http://en.cppreference.com/w/cpp/locale/codecvt/out\" rel=\"nofollow\">cppreferece.com on std::codecvt::out</a></p></li>\n<li><p><a href=\"http://www.cplusplus.com/reference/locale/codecvt/out/\" rel=\"nofollow\">cpulusplus.com on std::codecvt::out</a></p></li>\n</ul>\n", "LastEditorUserId": "2885815", "LastActivityDate": "2013-10-17T19:10:49.430", "Score": "2", "CreationDate": "2013-10-17T18:55:11.787", "ParentId": "19357027", "CommentCount": "3", "OwnerUserId": "2885815", "LastEditDate": "2013-10-17T19:10:49.430"}});