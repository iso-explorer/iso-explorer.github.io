post_cb({"bq_ids": {"n4140": {"so_33251441_33251720_0": {"section_id": 6146, "quality": 0.9285714285714286, "length": 13}, "so_33251441_33255763_4": {"section_id": 6147, "quality": 0.9285714285714286, "length": 13}, "so_33251441_33255763_6": {"section_id": 6147, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_33251441_33251720_0": {"section_id": 5909, "quality": 0.9285714285714286, "length": 13}, "so_33251441_33255763_4": {"section_id": 5910, "quality": 0.9285714285714286, "length": 13}, "so_33251441_33255763_6": {"section_id": 5910, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_33251441_33251720_0": {"section_id": 7642, "quality": 0.9285714285714286, "length": 13}, "so_33251441_33255763_4": {"section_id": 7643, "quality": 0.9285714285714286, "length": 13}, "so_33251441_33255763_6": {"section_id": 7643, "quality": 0.9285714285714286, "length": 13}}}, "33251720": {"ParentId": "33251441", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Regarding left and right shift operators, from the C++ standard section 5.8:</p>\n<blockquote>\n<p id=\"so_33251441_33251720_0\">The behavior is undefined if the right operand is negative, or greater\n  than or equal to the length in bits of the promoted left operand.</p>\n</blockquote>\n<p>Then it says that the left shift operator E1 &lt;&lt; E2 results in an undefined behavior when all of the following conditions are satisfied:</p>\n<ul>\n<li>The left operand has a signed type.</li>\n<li>Either the left operand has a negative value or it has a non-negative value such that E1 \u00d7 2^E2 is not representable in the resulting type.</li>\n</ul>\n<p>Also regarding the right shift operator  E1 &gt;&gt; E2, the behavior is implementation-dependent if the left operand has signed type and a negative value.</p>\n<p>The bitwise AND, XOR and OR operators are well-defined for all integral types. This is specified in sections 5.11, 5.12 and 5.13, respectively.</p>\n<p>However, note that the the representation of signed integral values can be either Two's complement, Ones' complement or signed magnitude. Most compilers use the Two's complement representation though. These include gcc, VC++, icl and Clang.</p>\n", "OwnerUserId": "4230618", "LastEditorUserId": "4230618", "LastEditDate": "2015-10-21T05:55:38.007", "Id": "33251720", "Score": "1", "CreationDate": "2015-10-21T05:40:46.950", "LastActivityDate": "2015-10-21T05:55:38.007"}, "33255763": {"ParentId": "33251441", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The results of bitwise and, bitwise or and bitwise xor are currently underspecified in the standard, in particular the term <em>bitwise</em> is never defined. We have <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1857\" rel=\"nofollow\">defect report 1857: Additional questions about bits </a> that covers this issue and says:</p>\n<blockquote>\n<p id=\"so_33251441_33255763_0\">The specification of the bitwise operations in 5.11 [expr.bit.and],\n  5.12 [expr.xor], and 5.13 [expr.or] uses the undefined term \u201cbitwise\u201d in describing the operations, without specifying whether it is the\n  value or object representation that is in view.</p>\n<p id=\"so_33251441_33255763_1\">Part of the resolution of this might be to define \u201cbit\u201d (which is otherwise currently undefined in C++) as a value of a given power of 2.</p>\n</blockquote>\n<p>and the resolution was:</p>\n<blockquote>\n<p id=\"so_33251441_33255763_2\">CWG decided to reformulate the description of the operations\n  themselves to avoid references to bits, splitting off the larger\n  questions of defining \u201cbit\u201d and the like to issue 1943 for further\n  consideration.</p>\n</blockquote>\n<p>Which resulted in a consolidated <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1943\" rel=\"nofollow\">defect report 1943: Unspecified meaning of \u201cbit\u201d</a>.</p>\n<p>The result of left shifting a signed type is going to depend on the underlying representation. We can see this from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1457\" rel=\"nofollow\">defect report 1457: Undefined behavior in left-shift</a> which made it well defined to left shift into the sign bit and says:</p>\n<blockquote>\n<p id=\"so_33251441_33255763_3\">The current wording of 5.8 [expr.shift] paragraph 2 makes it undefined\n  behavior to create the most-negative integer of a given type by\n  <strong>left-shifting a (signed) 1 into the sign bit, even though this is not\n  uncommonly done and works correctly on the majority of\n  (twos-complement) architectures</strong>:</p>\n<blockquote>\n<p id=\"so_33251441_33255763_6\">...if E1 has a signed type and non-negative value, and E1 \u2a2f 2E2 is representable in the result type, then that is the resulting value;\n    otherwise, the behavior is undefined.</p>\n</blockquote>\n<p id=\"so_33251441_33255763_5\">As a result, this technique cannot be used in a constant expression,\n  which will break a significant amount of code.</p>\n</blockquote>\n<p>Noting the emphasis on the statement <em>works correctly on the majority of\n(twos-complement) architectures</em>. So it is dependent on the underlying representation for example twos-complement.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-12-17T14:07:49.573", "Id": "33255763", "Score": "3", "CreationDate": "2015-10-21T09:36:50.717", "LastActivityDate": "2015-12-17T14:07:49.573"}, "33251850": {"ParentId": "33251441", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Operators <code>&amp;</code>, <code>|</code> and <code>^</code> are bitwise, and deal with individual bits, so they will do exactly what you written: apply the <code>mask</code>.</p>\n<p>Left shift <code>&lt;&lt;</code> operator is a bit trickier. It will lead to undefined behavior if you shift negative value or if you shift 1 to sign bit position or beyond.</p>\n<p><code>static_cast&lt;integer&gt;(1)&lt;&lt;static_cast&lt;integer&gt;(bits-1);</code></p>\n<p>It seems you shift <code>1</code> to sign bit position there, and it is undefined behavior.</p>\n", "OwnerUserId": "194635", "LastEditorUserId": "194635", "LastEditDate": "2015-10-21T06:13:45.080", "Id": "33251850", "Score": "1", "CreationDate": "2015-10-21T05:49:33.453", "LastActivityDate": "2015-10-21T06:13:45.080"}, "33251441": {"CommentCount": "1", "ViewCount": "257", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-10-21T05:15:05.133", "LastActivityDate": "2015-12-17T14:07:49.573", "Title": "Are the result of bitwise operations on signed integral types well-defined?", "AcceptedAnswerId": "33255763", "LastEditDate": "2015-10-21T14:05:54.457", "Id": "33251441", "Score": "7", "Body": "<p>Consider this code:</p>\n<pre><code>using integer = int; // or any other fundamental integral type\nusing unsigned_integer = typename std::make_unsigned&lt;integer&gt;::type;\nconstexpr integer bits = std::numeric_limits&lt;unsigned_integer&gt;::digits;\ninteger value = -42; // or any value\ninteger mask = static_cast&lt;integer&gt;(1)&lt;&lt;static_cast&lt;integer&gt;(bits-1);\nbool result_and = value &amp; mask;\nbool result_or = value | mask;\nbool result_xor = value ^ mask;\n</code></pre>\n<p>I am wondering how well are these operations defined according to the standard. Do I have the guarantee to end up with the same results on all architectures? I am sure to operate on the sign bit on all architectures where this sign bit is <code>0</code> for positive numbers and <code>1</code> for negative numbers?</p>\n", "Tags": "<c++><bit-manipulation><standards><c++14><signed>", "OwnerUserId": "882932", "AnswerCount": "3"}});