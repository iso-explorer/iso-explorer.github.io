post_cb({"36475910": {"ParentId": "36475497", "PostTypeId": "2", "CommentCount": "27", "Body": "<pre><code>barmap=foo();\n</code></pre>\n<p>is allowed to require a move-assignment into the map's <code>value_type</code>.</p>\n<p>Reasoning:</p>\n<p>from \u00a723.4.4.1</p>\n<blockquote>\n<p id=\"so_36475497_36475910_0\">For a <code>map&lt;Key,T&gt;</code> the key_type is Key and the value_type is pair&lt;<strong>const\n  Key</strong>,T&gt;.</p>\n</blockquote>\n<p>\u00a7 23.2.3</p>\n<blockquote>\n<p id=\"so_36475497_36475910_1\">5 For set and multiset the value type is the same as the key type. For map and multimap it is equal to <code>pair&lt;const Key, T&gt;</code>.</p>\n<p id=\"so_36475497_36475910_2\">7 The associative containers meet all the requirements of Allocator-aware containers (23.2.1), except that\n  for map and multimap, the requirements placed on value_type in Table 95 apply instead to key_type\n  and mapped_type. [ Note: For example, in some cases key_type and mapped_type are required to be\n  CopyAssignable even though the associated value_type, pair, is not\n  CopyAssignable. \u2014 end note ]</p>\n</blockquote>\n<p>From Table 95:</p>\n<blockquote>\n<p id=\"so_36475497_36475910_3\">Expression :</p>\n<p id=\"so_36475497_36475910_4\">a = rv </p>\n<p id=\"so_36475497_36475910_5\">Return type :</p>\n<p id=\"so_36475497_36475910_6\">X&amp; </p>\n<p id=\"so_36475497_36475910_7\">Operational semantics:</p>\n<p id=\"so_36475497_36475910_8\"><strong>All existing elements of a are either move assigned to</strong> or destroyed</p>\n<p id=\"so_36475497_36475910_9\">Assertion/note pre-/post-condition:</p>\n<p id=\"so_36475497_36475910_10\">a shall be equal to the value that rv had before this assignment</p>\n<p id=\"so_36475497_36475910_11\">Complexity:</p>\n<p id=\"so_36475497_36475910_12\">linear</p>\n</blockquote>\n<p>so you would need to provide a const Key&amp;&amp; move-assignment to make it portable.</p>\n<p>like this:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;map&gt;\n\nstruct key {\n\n  key(key&amp;&amp;);\n  key(const key&amp;&amp;);\n  key&amp; operator=(key&amp;&amp;);\n  key&amp; operator=(const key&amp;&amp;);\n};\nbool operator&lt;(const key&amp; l, const key&amp; r);\n\nstruct value {\n\n};\n\nusing map_type = std::map&lt;key, value&gt;;\n\nmap_type foo();\nmap_type foo2();\n\nint main(){\n  auto barmap=foo();\n  barmap = foo2();\n  return 0;\n}\n</code></pre>\n<p>see it compile here: <a href=\"https://godbolt.org/g/XAQxjt\" rel=\"nofollow\">https://godbolt.org/g/XAQxjt</a></p>\n<p>link to 2015 draft standard I have used (I know there is a later one, but the line remains in the most recent draft, now in table 100)</p>\n<p><a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf</a></p>\n<p>My apologies to anyone who finds the answer unacceptable, but the words really are there.</p>\n", "OwnerUserId": "2015579", "LastEditorUserId": "2015579", "LastEditDate": "2016-04-07T15:04:22.453", "Id": "36475910", "Score": "1", "CreationDate": "2016-04-07T12:16:22.643", "LastActivityDate": "2016-04-07T15:04:22.453"}, "36478025": {"ParentId": "36475497", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>I believe this is a <s>bug</s> quality of implementation issue in libstdc++. If we look in the container requirements table (now <a href=\"http://eel.is/c++draft/container.requirements#tab:containers.container.requirements\" rel=\"nofollow\">table 100</a>), one of the requirements is:</p>\n<pre><code>a = rv\n</code></pre>\n<p>where <code>a</code> is a value of type <code>X</code> (the container class) and <code>rv</code> denotes a non-const rvalue of type <code>X</code>. The operational semantics are described as:</p>\n<blockquote>\n<p id=\"so_36475497_36478025_0\">All existing elements of <code>a</code> are either move assigned to or destroyed</p>\n</blockquote>\n<p>It is stated in <a href=\"http://eel.is/c++draft/map#map.overview-2\" rel=\"nofollow\">[map.overview]</a> that:</p>\n<blockquote>\n<p id=\"so_36475497_36478025_1\">A <code>map</code> satisfies all of the requirements of a container</p>\n</blockquote>\n<p>One of those requirements is move assignment. Now apparently libstdc++'s approach is to move assign elements even in the case where <code>Key</code> is non-copyable (which would make <code>pair&lt;const Key, T&gt;</code> non-moveable - note that it's only <code>Key</code>'s noncopyability that is relevant here). But there is no mandate that move assignment happens, it is merely an option. Note that the code compiles fine with libc++. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-04-07T14:55:34.557", "Id": "36478025", "Score": "1", "CreationDate": "2016-04-07T13:42:31.067", "LastActivityDate": "2016-04-07T14:55:34.557"}, "36492111": {"ParentId": "36475497", "CommentCount": "0", "Body": "<p>To me this looks like a fundamental failure of the specification in the C++ standard.  The specification goes too far in \"do not repeat yourself\", as to become unreadable and ambiguous (imho).</p>\n<p>If you read further to the table <strong>Allocator-aware container requirements</strong> this same row says (for <code>a = rv</code>):</p>\n<blockquote>\n<p id=\"so_36475497_36492111_0\"><em>Requires:</em> If <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</code> is <code>false</code>, <code>T</code> is <code>MoveInsertable</code> into <code>X</code> and <code>MoveAssignable</code>. All existing elements of <code>a</code> are either move assigned to or destroyed. post: <code>a</code> shall be equal to the value that <code>rv</code> had before this assignment.</p>\n</blockquote>\n<p>I think everyone can agree that <code>std::map&lt;std::unique_ptr&lt;char&gt;, std::unique_ptr&lt;int&gt;&gt;</code> is an allocator-aware container.  Then the question becomes:  What are the requirements on its move assignment operator?</p>\n<p>If we look only at the <em>Allocator-aware container requirements</em>, then <code>MoveInsertable</code> and <code>MoveAssignable</code> are only required if <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</code> is <code>false</code>.  And this is a weaker requirement than stated by the <em>Container requirements</em> table which states that <strong>all</strong> elements must be <code>MoveAssignable</code> regardless of the properties of the allocator.  So must allocator-aware containers also meet the stricter requirements of containers?</p>\n<p>Let's unwind this to what the standard <em>should</em> say if it wasn't trying so hard to not repeat itself.</p>\n<p><em>What does the implementation require?</em></p>\n<p>If <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</code> is <code>true</code> then all ownership of memory resources can be transferred from the rhs to the lhs during move assignment.  This means that <code>map</code> move assignment can do nothing but O(1) pointer twiddling to accomplish move assignment (when memory ownership can be transferred).  Pointer twiddling does not require any operations on the objects that the pointers point to.</p>\n<p>Here is the libc++ implementation of <code>map</code> assignment when <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</code> is <code>true</code>:</p>\n<p><a href=\"https://github.com/llvm-mirror/libcxx/blob/master/include/__tree#L1531-L1551\" rel=\"noreferrer\">https://github.com/llvm-mirror/libcxx/blob/master/include/__tree#L1531-L1551</a></p>\n<p>One can see that <em>absolutely no requirements</em> need to be placed on the <code>key_type</code> or <code>value_type</code>.</p>\n<p>Should we artificially place requirements on these types?</p>\n<p>What purpose would that serve?  Would it help or hurt clients of <code>std::map</code>?</p>\n<p>My personal opinion is that making requirements on client types that aren't needed will only serve to frustrate the clients.</p>\n<p>I also believe that the current style of specification of the C++ standard is so convoluted that even experts can't agree on what the specification says.  This isn't because the experts are idiots.  It is because making a correct, unambiguous specification (on this scale) is truly a very difficult problem.</p>\n<p>Finally I believe that the intent is (or should be) that the Allocator-aware container requirements supersede the Container requirements when a specification conflict arises.</p>\n<p>One final complication:  In C++11: </p>\n<pre><code>allocator_traits&lt;allocator&lt;T&gt;&gt;::propagate_on_container_move_assignment{} is false_type\n</code></pre>\n<p>where as in C++14:</p>\n<pre><code>allocator_traits&lt;allocator&lt;T&gt;&gt;::propagate_on_container_move_assignment{} is true_type\n</code></pre>\n<p>So the libstdc++ behavior is conforming in C++11, and the libc++ behavior is conforming in C++14.  <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#2103\" rel=\"noreferrer\">LWG issue 2103</a> made this change.</p>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "36492111", "Score": "5", "CreationDate": "2016-04-08T05:21:45.173", "LastActivityDate": "2016-04-08T05:21:45.173"}, "bq_ids": {"n4140": {"so_36475497_36475910_10": {"section_id": 705, "quality": 1.0, "length": 5}, "so_36475497_36475910_2": {"section_id": 743, "quality": 0.7837837837837838, "length": 29}, "so_36475497_36475910_8": {"section_id": 705, "quality": 1.0, "length": 7}, "so_36475497_36475910_1": {"section_id": 741, "quality": 0.8571428571428571, "length": 12}, "so_36475497_36478025_1": {"section_id": 1001, "quality": 1.0, "length": 5}, "so_36475497_36475910_0": {"section_id": 1001, "quality": 0.8571428571428571, "length": 6}, "so_36475497_36492111_0": {"section_id": 716, "quality": 0.8947368421052632, "length": 17}, "so_36475497_36478025_0": {"section_id": 705, "quality": 1.0, "length": 7}}, "n3337": {"so_36475497_36475910_10": {"section_id": 695, "quality": 1.0, "length": 5}, "so_36475497_36475910_2": {"section_id": 732, "quality": 0.7837837837837838, "length": 29}, "so_36475497_36475910_8": {"section_id": 695, "quality": 1.0, "length": 7}, "so_36475497_36475910_1": {"section_id": 730, "quality": 0.8571428571428571, "length": 12}, "so_36475497_36478025_0": {"section_id": 695, "quality": 1.0, "length": 7}, "so_36475497_36475910_0": {"section_id": 986, "quality": 0.8571428571428571, "length": 6}, "so_36475497_36492111_0": {"section_id": 705, "quality": 0.8947368421052632, "length": 17}, "so_36475497_36478025_1": {"section_id": 986, "quality": 1.0, "length": 5}}, "n4659": {"so_36475497_36475910_10": {"section_id": 734, "quality": 1.0, "length": 5}, "so_36475497_36475910_2": {"section_id": 801, "quality": 0.7837837837837838, "length": 29}, "so_36475497_36475910_8": {"section_id": 734, "quality": 1.0, "length": 7}, "so_36475497_36475910_1": {"section_id": 799, "quality": 0.8571428571428571, "length": 12}, "so_36475497_36478025_1": {"section_id": 1065, "quality": 1.0, "length": 5}, "so_36475497_36492111_0": {"section_id": 746, "quality": 0.8421052631578947, "length": 16}, "so_36475497_36478025_0": {"section_id": 734, "quality": 1.0, "length": 7}, "so_36475497_36475910_0": {"section_id": 1065, "quality": 0.8571428571428571, "length": 6}}}, "36475497": {"CommentCount": "6", "AcceptedAnswerId": "36478025", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-04-07T11:57:44.053", "LastActivityDate": "2016-04-08T05:21:45.173", "LastEditDate": "2017-05-23T11:52:43.660", "ViewCount": "368", "FavoriteCount": "2", "Title": "error by move assignment of map with non-copyable (but movable) key", "Id": "36475497", "Score": "8", "Body": "<p>Why does this doesn't work:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;map&gt;\n\nstd::map&lt;std::unique_ptr&lt;char&gt;, std::unique_ptr&lt;int&gt;&gt; foo();\nstd::map&lt;std::unique_ptr&lt;char&gt;, std::unique_ptr&lt;int&gt;&gt; barmap;\n\nint main(){\n  barmap=foo();\n  return 0;\n}\n</code></pre>\n<p>while this does:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;map&gt;\n\nstd::map&lt;std::unique_ptr&lt;char&gt;, std::unique_ptr&lt;int&gt;&gt; foo();\nstd::map&lt;std::unique_ptr&lt;char&gt;, std::unique_ptr&lt;int&gt;&gt; barmap;\n\nint main(){\n\n  std::map&lt;std::unique_ptr&lt;char&gt;, std::unique_ptr&lt;int&gt;&gt; tmp(foo());\n  using std::swap;\n  swap(barmap, tmp);\n  return 0;\n}\n</code></pre>\n<p>This has to do with the fact that key type in the map is not copyable (does std::map require that?). Relevant error lines when compiling with <code>g++ -std=c++14</code>:</p>\n<pre><code>/usr/include/c++/4.9/ext/new_allocator.h:120:4: error: use of deleted function \u2018constexpr std::pair&lt;_T1, _T2&gt;::pair(std::pair&lt;_T1, _T2&gt;&amp;&amp;) [with _T1 = const std::unique_ptr&lt;char&gt;; _T2 = std::unique_ptr&lt;int&gt;]\u2019\n  { ::new((void *)__p) _Up(std::forward&lt;_Args&gt;(__args)...); }\n    ^\nIn file included from /usr/include/c++/4.9/bits/stl_algobase.h:64:0,\n                 from /usr/include/c++/4.9/memory:62,\n                 from pairMove.cpp:1:\n/usr/include/c++/4.9/bits/stl_pair.h:128:17: note: \u2018constexpr std::pair&lt;_T1, _T2&gt;::pair(std::pair&lt;_T1, _T2&gt;&amp;&amp;) [with _T1 = const std::unique_ptr&lt;char&gt;; _T2 = std::unique_ptr&lt;int&gt;]\u2019 is implicitly deleted because the default definition would be ill-formed:\n       constexpr pair(pair&amp;&amp;) = default;\n                 ^\n/usr/include/c++/4.9/bits/stl_pair.h:128:17: error: use of deleted function \u2018std::unique_ptr&lt;_Tp, _Dp&gt;::unique_ptr(const std::unique_ptr&lt;_Tp, _Dp&gt;&amp;) [with _Tp = char; _Dp = std::default_delete&lt;char&gt;]\u2019\nIn file included from /usr/include/c++/4.9/memory:81:0,\n                 from pairMove.cpp:1:\n/usr/include/c++/4.9/bits/unique_ptr.h:356:7: note: declared here\n       unique_ptr(const unique_ptr&amp;) = delete;\n</code></pre>\n<p>Entire error message to be seen <a href=\"https://ideone.com/q8uIGB\" rel=\"nofollow noreferrer\">at ideone</a>.</p>\n<p>It seems to me that defaulted move constructor of <code>std::pair</code> attempts to use a copy constructor of <code>std::unique_ptr</code>. I presume that map assignment operator uses move assignments of new map contents over the old ones, and <code>std::swap</code> cannot do this since it needs to keep old contents intact, so it just swaps internal data pointers, so it avoids problems.</p>\n<p>The necessity to (at least  be able to) move assign might come from <a href=\"https://stackoverflow.com/questions/17603666/copy-move-requirements-for-the-key-value-types-in-a-stdmap\">problems</a> with <code>allocator_traits&lt;M::allocator_type&gt;::propagate_on_container_move_assignment</code> in C++11, but I was under impression that in C++14 the whole thing was fixed. I am not sure why STL would choose to move-assign elements instead of just exchanging data pointers between containers in move-assignment operator.</p>\n<p>And all of the above doesn't explain why move-assignment of pairs contained in moved map fails - IMHO it shouldn't.</p>\n<p>Btw: <code>g++ -v</code>:</p>\n<pre><code>gcc version 4.9.2 (Ubuntu 4.9.2-0ubuntu1~14.04) \n</code></pre>\n", "Tags": "<c++><c++14><move-semantics><stdmap>", "OwnerUserId": "455304", "AnswerCount": "3"}});