post_cb({"20020878": {"ParentId": "20019791", "LastEditDate": "2017-05-23T10:25:38.393", "CommentCount": "2", "CreationDate": "2013-11-16T16:32:56.460", "OwnerUserId": "341970", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "20020878", "Score": "1", "Body": "<ol>\n<li><p>If <code>my_class</code> is as expensive to copy as copying an <code>int</code>, the\ncompiler isn't motivated to eliminate the copies, in fact, it is\nmotivated to do copies. Don't forget that your <code>get(int c)</code> function\ncan be completely inlined!  <a href=\"https://stackoverflow.com/q/19262009/341970\">It can lead to a very confusing\noutput.</a> You need to motivate the compiler to do its best to\neliminate the copies by adding a big, heavy payload to your class\nthat is expensive to copy.</p></li>\n<li><p>Furthermore, instead of relying on undefined behavior, try to write\ncode that tells you in a well-defined manner whether a move or a\ncopy occurred or not.</p></li>\n<li><p>There are 2 more interesting cases: (<em>i</em>) when you apply <code>move</code> on\nboth arguments of the ternary conditional operator and (<em>ii</em>) when you\nreturn through <code>if</code>-<code>else</code> instead of the conditional operator.</p></li>\n</ol>\n<hr>\n<p>I rearranged your code: I gave <code>my_class</code> a heavy payload that is really expensive to copy; I added a member function that tells you in a well-defined manner if the class has been copied or not; I added the 2 other interesting cases.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nclass weight {\npublic:  \n    weight() : v(1024, 0) { };\n    weight(const weight&amp; ) : v(1024, 1) { }\n    weight(weight&amp;&amp; other) { v.swap(other.v); }\n    weight&amp; operator=(const weight&amp; ) = delete;\n    weight&amp; operator=(weight&amp;&amp; ) = delete;\n    bool has_been_copied() const { return v.at(0); }\nprivate:\n    std::vector&lt;int&gt; v;\n};\n\nstruct my_class {\n    weight w;\n};\n\nmy_class A(int c) {\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    my_class m1;\n    my_class m2;\n    return (c == 1) ? m1 : m2;\n}\n\nmy_class B(int c) {\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    my_class m1;\n    my_class m2;\n    return (c == 1) ? std::move(m1) : m2;\n}\n\nmy_class C(int c) {\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    my_class m1;\n    my_class m2;\n    return (c == 1) ? m1 : std::move(m2);\n}\n\nmy_class D(int c) {\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    my_class m1;\n    my_class m2;\n    return (c == 1) ? std::move(m1) : std::move(m2);\n}\n\nmy_class E(int c) {\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    my_class m1;\n    my_class m2;\n    if (c==1) \n      return m1;\n    else\n      return m2;\n}\n\nint main(int argc, char* argv[]) {\n\n    if (argc==1) {\n      return 1; \n    }\n\n    int i = std::stoi(argv[1]);\n\n    my_class a = A(i);\n    std::cout &lt;&lt; a.w.has_been_copied() &lt;&lt; std::endl;\n\n    my_class b = B(i);\n    std::cout &lt;&lt; b.w.has_been_copied() &lt;&lt; std::endl;\n\n    my_class c = C(i);\n    std::cout &lt;&lt; c.w.has_been_copied() &lt;&lt; std::endl;\n\n    my_class d = D(i);\n    std::cout &lt;&lt; d.w.has_been_copied() &lt;&lt; std::endl;\n\n    my_class e = E(i);\n    std::cout &lt;&lt; e.w.has_been_copied() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output with <code>./a.out 0</code></p>\n<pre><code>my_class A(int)\n1\nmy_class B(int)\n1\nmy_class C(int)\n0\nmy_class D(int)\n0\nmy_class E(int)\n0\n</code></pre>\n<p>Output with <code>./a.out 1</code></p>\n<pre><code>my_class A(int)\n1\nmy_class B(int)\n0\nmy_class C(int)\n1\nmy_class D(int)\n0\nmy_class E(int)\n0\n</code></pre>\n<hr>\n<p>As to what happens and why, others have already answered it as I was writing up this answer. If you go through the conditional operator, you lose the eligibility to copy elision. You can still get away with a move construction if you apply <code>move</code>. If you look at the output, that's exactly what happens. I have tested it with both clang 3.4 trunk and gcc 4.7.2 at optimization level <code>-O3</code>; the same output is obtained.</p>\n</hr></hr>", "LastActivityDate": "2013-11-16T16:39:38.127"}, "20020185": {"ParentId": "20019791", "CommentCount": "5", "Body": "<p>the compiler doesn't HAVE to move, the point of move is to be a lot faster than a copy and destruct. BUT the two yield the same result. </p>\n", "OwnerUserId": "2112028", "PostTypeId": "2", "Id": "20020185", "Score": "-1", "CreationDate": "2013-11-16T15:30:56.713", "LastActivityDate": "2013-11-16T15:30:56.713"}, "20020084": {"ParentId": "20019791", "LastEditDate": "2013-11-16T15:42:25.110", "CommentCount": "3", "CreationDate": "2013-11-16T15:22:24.330", "OwnerUserId": "952747", "LastEditorUserId": "952747", "PostTypeId": "2", "Id": "20020084", "Score": "2", "Body": "<h2>Conditional operator effect!</h2>\n<p>You're returning through  a conditional operator</p>\n<pre><code>return (c == 1) ? m1 : m2;\n</code></pre>\n<blockquote>\n<p id=\"so_20019791_20020084_0\">The second and third operands have the same type; the result is of that type. If the operands have class type, the result is a prvalue temporary of the result type, which is <strong>copy-initialized</strong> from either the second operand or the third operand depending on the value of the first operand. [\u00a7 5.16/6]</p>\n</blockquote>\n<p>Then you have a copy. This code has the your expected result.</p>\n<pre><code>if (c==1)\n   return m1;\nelse\n   return m2;\n</code></pre>\n", "LastActivityDate": "2013-11-16T15:42:25.110"}, "20020230": {"ParentId": "20019791", "LastEditDate": "2013-11-16T16:04:28.867", "CommentCount": "3", "CreationDate": "2013-11-16T15:34:56.520", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "PostTypeId": "2", "Id": "20020230", "Score": "4", "Body": "<p>Where is the surprise...? You are returning local objects but you are not directly returning them. If you'd return a local variable directly, you'll get move construction:</p>\n<pre><code>my_class f() {\n    my_class variable;\n    return variable;\n}\n</code></pre>\n<p>The relevant clause is, I think, 12.8 [class.copy] paragraph 32:</p>\n<blockquote>\n<p id=\"so_20019791_20020230_0\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. [...]</p>\n</blockquote>\n<p>However, choosing a named object to be selected from a conditional operator isn't eligible for copy elision: the compiler can't know until after the objects are constructed which of the objects to return and copy elision is based on constructing the object readily in the location where it needs to go. </p>\n<p>When you have a condition operator, there are two fundamental situations:</p>\n<ol>\n<li>Both branches produce exactly the same type and the result will be a reference to the result.</li>\n<li>The branches differ somehow and the result will be a temporary constructed from the selected branch.</li>\n</ol>\n<p>That is, when returning <code>c == 1? m1: m2</code> you get a <code>my_class&amp;</code> which is an lvalue and it is, thus, copied to produce the return value. You probably want to use <code>std::move(c == 1? m1: m2)</code> to move the selected local variable.</p>\n<p>When you use <code>c == 1? std::move(m1): m2</code> or <code>c == 1? m1: std::move(m2)</code> the types differ and you get the result of</p>\n<pre><code>return c == 1? my_class(std::move(m1)): my_class(m2);\n</code></pre>\n<p>or</p>\n<pre><code>return c == 1? my_class(m1): my_class(std::move(m2));\n</code></pre>\n<p>That is, depending on how the expression is formulated the temporary is copy constructed in one branch and move constructed on the other branch. Which branch is chosen depends entirely on the value of <code>c</code>. In both cases the result of the conditional expression is eligible for copy elision and the copy/move used to construct the actual result is likely to be elided.</p>\n", "LastActivityDate": "2013-11-16T16:04:28.867"}, "20019791": {"CommentCount": "7", "ViewCount": "432", "PostTypeId": "1", "LastEditorUserId": "985292", "CreationDate": "2013-11-16T14:52:50.337", "LastActivityDate": "2013-11-16T16:39:38.127", "Title": "Compiler's choice between move and copy constructor", "AcceptedAnswerId": "20020230", "LastEditDate": "2013-11-16T16:38:14.533", "Id": "20019791", "Score": "3", "Body": "<p>Minimal example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct my_class\n{\n    int i;\n    my_class() : i(0) { std::cout &lt;&lt; \"default\" &lt;&lt; std::endl; }\n    my_class(const my_class&amp;) { std::cout &lt;&lt; \"copy\" &lt;&lt; std::endl; }\n    my_class(my_class&amp;&amp; other) { std::cout &lt;&lt; \"move\" &lt;&lt; std::endl; }\n    my_class(const my_class&amp;&amp; other) { std::cout &lt;&lt; \"move\" &lt;&lt; std::endl; }\n};\n\nmy_class get(int c)\n{\n    my_class m1;\n    my_class m2;\n    return (c == 1) ? m1 : m2; // A\n    //return (c == 1) ? std::move(m1) : m2; // B\n    //return (c == 1) ? m1 : std::move(m2); // C\n}\n\nint main()\n{\n    bool c;\n    std::cin &gt;&gt; c;\n    my_class m = get(c);\n    std::cout &lt;&lt; m.i &lt;&lt; std::endl; // nvm about undefinedness\n    return 0;\n}\n</code></pre>\n<p>Compiled:</p>\n<pre><code>g++ -std=c++11 -Wall -O3 ctor.cpp -o ctor # g++ v 4.7.1\n</code></pre>\n<p>Input:</p>\n<pre><code>1\n</code></pre>\n<p>Output:</p>\n<pre><code>default\ndefault\ncopy\n-1220217339\n</code></pre>\n<p>This is the In/Output with line A or line C. If I use line B, instead, I get <code>std::move</code> for some strange reason. In all versions, the output does not depend on my input (except for the value of i).</p>\n<p>My questions:</p>\n<ul>\n<li>Why do versions B and C differ?</li>\n<li>Why, at all, does the compiler make a copy in cases A and C?</li>\n</ul>\n", "Tags": "<c++><c++11><copy-constructor><move-constructor>", "OwnerUserId": "985292", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_20019791_20020230_0": {"section_id": 481, "quality": 0.6896551724137931, "length": 20}, "so_20019791_20020084_0": {"section_id": 6172, "quality": 0.9310344827586207, "length": 27}}, "n3337": {"so_20019791_20020230_0": {"section_id": 472, "quality": 1.0, "length": 29}, "so_20019791_20020084_0": {"section_id": 5933, "quality": 0.9310344827586207, "length": 27}}, "n4659": {"so_20019791_20020230_0": {"section_id": 504, "quality": 0.5517241379310345, "length": 16}, "so_20019791_20020084_0": {"section_id": 7667, "quality": 0.5172413793103449, "length": 15}}}});