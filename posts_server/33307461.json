post_cb({"33307803": {"Id": "33307803", "PostTypeId": "2", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">C11 standard</a> requires at least one enumerator in an enum declaration (section 6.7.2.2), the salient parts copied below:</p>\n<p><i>enum-specifier</i>:<br/>\n\u00a0<b>enum</b> <i>identifier<sub>opt</sub></i> <b>{</b> <i>enumerator-list</i> <b>}</b><br/>\n\u00a0<b>enum</b> <i>identifier<sub>opt</sub></i> <b>{</b> <i>enumerator-list</i> <b>}</b><br/>\n\u00a0<b>enum</b> <i>identifier</i></p>\n<p><i>enumerator-list</i>:<br>\n\u00a0<i>enumerator</i><br/>\n\u00a0<i>enumerator-list</i><b>,</b> <i>enumerator</i></br></p>\n<p>Sorry for the somewhat wonky formatting, I tried to recreate the passage from the (proposed) standard as close as I could.</p>\n", "LastActivityDate": "2015-10-23T17:01:56.043", "CommentCount": "0", "CreationDate": "2015-10-23T17:01:56.043", "ParentId": "33307461", "Score": "1", "OwnerUserId": "34771"}, "33307596": {"Id": "33307596", "PostTypeId": "2", "Body": "<p>You are right. You cannot have an empty enumerator list in C. But you can have it in C++. See <a href=\"http://en.cppreference.com/w/c/language/enum\" rel=\"nofollow\">http://en.cppreference.com/w/c/language/enum</a> and <a href=\"http://en.cppreference.com/w/cpp/language/enum\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/enum</a></p>\n", "LastActivityDate": "2015-10-23T16:49:06.453", "CommentCount": "0", "CreationDate": "2015-10-23T16:49:06.453", "ParentId": "33307461", "Score": "2", "OwnerUserId": "1517864"}, "33307769": {"Id": "33307769", "PostTypeId": "2", "Body": "<p>In C++ the size is 4 bytes because your compiler chose <code>int</code> as the underlying integer type for the enum. Apparently <code>sizeof(int)</code> is 4 on your platform. It is very popular in the compiler world to default to <code>int</code> for enum representation (unless a larger type is required).</p>\n<p>As for why it isn't allowed in C... Well, it isn't allowed in C because it isn't allowed in C. C is a completely different language with its own syntactic rules.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2015-10-23T18:19:20.620", "Score": "1", "CreationDate": "2015-10-23T16:59:00.493", "ParentId": "33307461", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2015-10-23T18:19:20.620"}, "33307583": {"Id": "33307583", "PostTypeId": "2", "Body": "<p>C++ is not C. For C++, from [dcl.enum]:</p>\n<blockquote>\n<p id=\"so_33307461_33307583_0\">For an enumeration whose underlying type is not fixed, the underlying type is an integral type that can\n  represent all the enumerator values defined in the enumeration. [...] It is implementation-defined which integral type is used\n  as the underlying type except that the underlying type shall not be larger than <code>int</code> unless the value of an\n  enumerator cannot fit in an <code>int</code> or <code>unsigned int</code>. If the <em>enumerator-list</em> is empty, the underlying type is <strong>as if the enumeration had a single enumerator with value 0</strong>.</p>\n</blockquote>\n<p>So the underlying type of the enumerator (which determines its size) is as if it had a single 0 in it, though the actual type is implementation-defined. It could be 1 (<code>int8_t</code> certainly can hold 0), but definitely isn't larger than 4. In this case, you get 4, which is perfectly reasonable. </p>\n<p>For C, the grammar simply requires having an enumerator. </p>\n", "LastActivityDate": "2015-10-23T16:48:24.527", "CommentCount": "7", "CreationDate": "2015-10-23T16:48:24.527", "ParentId": "33307461", "Score": "11", "OwnerUserId": "2069064"}, "bq_ids": {"n4140": {"so_33307461_33307603_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 5466}, "so_33307461_33307583_0": {"length": 42, "quality": 0.9545454545454546, "section_id": 5466}, "so_33307461_33307603_0": {"length": 9, "quality": 1.0, "section_id": 5466}}, "n3337": {"so_33307461_33307603_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 5252}, "so_33307461_33307603_0": {"length": 9, "quality": 1.0, "section_id": 5252}, "so_33307461_33307583_0": {"length": 42, "quality": 0.9545454545454546, "section_id": 5252}}, "n4659": {"so_33307461_33307603_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6900}, "so_33307461_33307603_0": {"length": 9, "quality": 1.0, "section_id": 6900}, "so_33307461_33307583_0": {"length": 42, "quality": 0.9545454545454546, "section_id": 6900}}}, "33307603": {"Id": "33307603", "PostTypeId": "2", "Body": "<p>As opposed to C, C++ does allow empty enumerations. [dcl.enum]/7:</p>\n<blockquote>\n<p id=\"so_33307461_33307603_0\">If the <em>enumerator-list</em> is empty, the underlying type is as if the\n  enumeration had a single enumerator with value <code>0</code>.</p>\n</blockquote>\n<p>The underlying type (whose size is commonly also the enumerations size) is actually implementation-defined in your case, although most compilers will presumably choose <code>int</code> (and aren't allowed to chose anything larger here):</p>\n<blockquote>\n<p id=\"so_33307461_33307603_1\">It is implementation-defined which integral type is used as the\n  underlying type except that the underlying type shall not be larger\n  than <code>int</code> unless the value of an enumerator cannot fit in an <code>int</code> or\n  <code>unsigned int</code>.</p>\n</blockquote>\n<hr>\n<p>C has the same requirements for the \"underlying type\" (although that exact notion doesn't exist in C), but its grammar does not allow for empty enumerations in the first place - \u00a76.7.2.2/1:</p>\n<blockquote>\n<p id=\"so_33307461_33307603_2\"><em>enumerator-list</em>:<br> \u00a0\u00a0\u00a0\u00a0\u00a0<em>enumerator</em> <br>\u00a0\u00a0\u00a0\u00a0\u00a0<em>enumerator-list</em> , <em>enumerator</em></br></br></p>\n</blockquote>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-10-23T17:04:30.497", "Score": "4", "CreationDate": "2015-10-23T16:49:38.157", "ParentId": "33307461", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2015-10-23T17:04:30.497"}, "33307461": {"ViewCount": "174", "Body": "<p>Consider following program (See live demo <a href=\"http://melpon.org/wandbox/permlink/sZXb5EVKqRjgYZCD\" rel=\"nofollow\">here</a>)</p>\n<pre><code>#include &lt;iostream&gt;\nint main()\n{\n    enum days{}d;\n    std::cout&lt;&lt;sizeof(d);\n}\n</code></pre>\n<p>It prints 4 as an output on my local machine when compiling using g++ 4.8.1. How it occupies 4 bytes here? On gcc 6.0 in the given link I used `-pedantic-option also but still it compiles fine.</p>\n<p>Then why it isn't allowed in C? I tried following program in gcc 4.8.1. (See live demo <a href=\"http://ideone.com/pkSxOG\" rel=\"nofollow\">here</a> )</p>\n<pre><code>#include &lt;stdio.h&gt;\nint main(void)\n{\n    enum days{}d;\n    printf(\"sizeof enum is %u\",sizeof(d));\n}\n</code></pre>\n<p>Compiler gives following errors:</p>\n<pre><code>4   12  [Error] expected identifier before '}' token\n\n5   36  [Error] 'd' undeclared (first use in this function)\n\n5   36  [Note] each undeclared identifier is reported only once for each function it appears in\n</code></pre>\n<p>Is it allowed to have empty enum in C++ but not in C? </p>\n", "AcceptedAnswerId": "33307583", "Title": "how sizeof empty enum is 4 in C++?", "CreationDate": "2015-10-23T16:41:39.217", "Id": "33307461", "CommentCount": "2", "LastEditDate": "2015-10-23T17:20:28.203", "PostTypeId": "1", "LastEditorUserId": "1858225", "LastActivityDate": "2015-10-23T18:19:20.620", "Score": "3", "OwnerUserId": "3777958", "Tags": "<c++><c><gcc><enums>", "AnswerCount": "5"}});