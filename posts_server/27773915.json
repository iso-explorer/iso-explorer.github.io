post_cb({"bq_ids": {"n4140": {"so_27773915_27773915_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 566}, "so_27773915_27773915_0": {"length": 9, "quality": 1.0, "section_id": 558}}, "n3337": {"so_27773915_27773915_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 557}, "so_27773915_27773915_0": {"length": 9, "quality": 1.0, "section_id": 549}}, "n4659": {"so_27773915_27773915_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 589}, "so_27773915_27773915_0": {"length": 9, "quality": 1.0, "section_id": 581}}}, "27773915": {"ViewCount": "50", "Body": "<p>I was a bit confused by the fact that the functions differ in presence/absence <code>cv</code>-qualifiers are equiavalent <code>N4296::13.1/3.4 [over.load]</code>:</p>\n<blockquote>\n<p id=\"so_27773915_27773915_0\">Parameter declarations that differ only in the presence or absence of\n  const and/or volatile are equivalent.</p>\n</blockquote>\n<p>Example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid foo(int){ }\n\nvoid foo(const int){ } //error: redifinition\n\nint main(){ }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/c33a21da2084e484\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>Now, let me provide an example with member-functions.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    A(){ }\n    void foo(){ std::cout &lt;&lt; \"foo()\" &lt;&lt; std::endl; }\n    void foo() const{ std::cout &lt;&lt; \"foo() const\" &lt;&lt; std::endl; }\n};\n\nA aa;\nconst A a;\nint main(){ aa.foo(); a.foo(); }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/34fc633fe2782124\" rel=\"nofollow\">DEMO</a></strong></p>\n<p><code>N4296::13.3.1/2 [over.match.funcs]</code></p>\n<blockquote>\n<p id=\"so_27773915_27773915_1\">member function is considered to have an extra parameter, called the\n  implicit object parameter, which represents the object for which the\n  member function has been called</p>\n</blockquote>\n<p>So, the member function declarations are different only in presence of the <code>const</code>-qualifier, but they are still overloadable. Doesn't it contradict to the quote from <code>N4296::13.1/3.4 [over.load]</code> I provided before?</p>\n", "AcceptedAnswerId": "27774055", "Title": "Array and pointer appeared as a function parameter and just as a declaration", "CreationDate": "2015-01-05T05:31:27.780", "Id": "27773915", "CommentCount": "4", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastActivityDate": "2015-01-05T05:46:46.883", "Score": "0", "Tags": "<c++><arrays>", "AnswerCount": "2"}, "27774055": {"Id": "27774055", "PostTypeId": "2", "Body": "<p>The quoted passage (disclaimer: I haven't checked the quote or attribution, but anyway, this property of C++) is about top level <code>const</code> (and <code>volatile</code>) for a formal argument.</p>\n<p>For example,</p>\n<pre><code>void foo( const int x );\n</code></pre>\n<p>is equivalent to</p>\n<pre><code>void foo( int x );\n</code></pre>\n<p>with respect to calling, checking its type, and so on. This is because there is no way it can matter to a caller whether a formal argument is <code>const</code> or not. That <code>const</code>-ness is only a restriction on what the function itself can do, not what callers can do.</p>\n<p>And so for <code>void foo( int )</code> you can provide an implementation with <code>const</code>:</p>\n<pre><code>void foo( const int x ) { cout &lt;&lt; x &lt;&lt; endl; }\n</code></pre>\n<p>It implements <code>void foo( int )</code> because they're equivalent.</p>\n<p>With a <code>const</code> member function you're instead saying that the referent for <code>this</code> is <code>const</code>. That's not a top level <code>const</code>. Adding that <code>const</code> is roughly equivalent to changing</p>\n<pre><code>void bar( int* p );\n</code></pre>\n<p>into</p>\n<pre><code>void bar( const int* p );\n</code></pre>\n<p>which are two different functions.</p>\n", "LastActivityDate": "2015-01-05T05:46:46.883", "CommentCount": "2", "CreationDate": "2015-01-05T05:46:46.883", "ParentId": "27773915", "Score": "2", "OwnerUserId": "464581"}, "27773970": {"Id": "27773970", "PostTypeId": "2", "Body": "<p>There is huge difference.Const member function means you can't modify data in that function.<strong>It includes in function signature</strong> and thats how compiler differentiates.Also accroding to <a href=\"http://www.parashift.com/c++-faq/const-member-fns.html\" rel=\"nofollow\">C++ FAQ</a></p>\n<blockquote>\n<p id=\"so_27773915_27773970_0\">The trailing const on foo() member function means that the\n  abstract (client-visible) state of the object isn't going to change.\n  This is slightly different from promising that the \"raw bits\" of the\n  object's struct aren't going to change. C++ compilers aren't allowed\n  to take the \"bitwise\" interpretation unless they can solve the\n  aliasing problem, which normally can't be solved (i.e., a non-const\n  alias could exist which could modify the state of the object).</p>\n</blockquote>\n<pre><code>    #include &lt;iostream&gt;\n\n    struct A\n    {\n        A(){var=0; }\n        void foo(){ std::cout &lt;&lt; \"foo()\" &lt;&lt; std::endl; }\n        void foo() const{ std::cout &lt;&lt; \"foo() const\" &lt;&lt; std::endl;var=5; } //this will generate error\n\n        private:\n        int var;\n    };\n\n\n\nA aa;\nconst A a;\nint main(){ aa.foo(); a.foo(); }\n</code></pre>\n<p>we will get <strong>error: read-only variable is not assignable</strong></p>\n<p>see this <a href=\"http://coliru.stacked-crooked.com/\" rel=\"nofollow\">http://coliru.stacked-crooked.com/</a></p>\n", "LastEditorUserId": "825844", "LastActivityDate": "2015-01-05T05:42:17.153", "Score": "0", "CreationDate": "2015-01-05T05:36:49.030", "ParentId": "27773915", "CommentCount": "0", "OwnerUserId": "825844", "LastEditDate": "2015-01-05T05:42:17.153"}});