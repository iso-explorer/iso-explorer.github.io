post_cb({"6211198": {"CommentCount": "0", "AcceptedAnswerId": "6211981", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2011-06-02T06:27:15.307", "LastActivityDate": "2012-07-18T06:04:31.957", "LastEditDate": "2012-07-18T06:04:31.957", "ViewCount": "311", "FavoriteCount": "1", "Title": "3.4.2 Argument-dependent name lookup from n3290 Draft", "Id": "6211198", "Score": "9", "Body": "<p>A point from ISO draft n3290 section 3.4.2 paragraph 1:</p>\n<blockquote>\n<p id=\"so_6211198_6211198_0\">When the <em>postfix-expression</em> in a function call is an <em>unqualified-id</em>, other namespaces not considered during the usual unqualified lookup may be searched, and in those namespaces, namespace-scope friend function declarations not otherwise visible may be found. These modifications to the search depend on the types of the arguments (and for template template arguments, the namespace of the template argument).</p>\n</blockquote>\n<p>Here  they said aboout  \"these modifications to the search depend on the types of the arguments / template template  arguments / namespace of the template argument  \" ...Can any one expalin with an example please? I tried with argumetn types..please expalin with template template argument types &amp; namespace of the template argument type</p>\n", "Tags": "<c++><c++11><argument-dependent-lookup><name-lookup>", "OwnerUserId": "751747", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_6211198_6211198_0": {"section_id": 7103, "quality": 0.9714285714285714, "length": 34}}, "n3337": {"so_6211198_6211198_0": {"section_id": 6847, "quality": 0.9714285714285714, "length": 34}}, "n4659": {"so_6211198_6211198_0": {"section_id": 8604, "quality": 0.9714285714285714, "length": 34}}}, "6211981": {"ParentId": "6211198", "CommentCount": "0", "Body": "<p>Consider a simple unqualified function call:</p>\n<pre><code>foo(x);\n</code></pre>\n<p>ADL means that <code>foo</code> is looked up not just in the enclosing scope, and the namespace that the call is in, but also the namespace of the type of <code>x</code>. e.g. if <code>x</code> is a <code>std::vector&lt;int&gt;</code> then namespace <code>std</code> is also searched. Thus:</p>\n<pre><code>int main() {\n    std::vector&lt;int&gt; x,y;\n    swap(x,y);\n}\n</code></pre>\n<p>is OK, and will call <code>std::swap()</code>.</p>\n<p>The lookup also depends on the namespace of any template arguments too, so if <code>x</code> is <code>std::vector&lt;mynamespace::myclass&gt;</code> then <code>mynamespace</code> is also included in the lookup. Thus</p>\n<pre><code>namespace mynamespace {\n    struct myclass {};\n    void foo(std::vector&lt;mynamespace::myclass&gt; const&amp;){}\n}\n\nint main() {\n    std::vector&lt;mynamespace::myclass&gt; x;\n    foo(x);\n}\n</code></pre>\n<p>will call <code>mynamespace::foo()</code>.</p>\n<p>Finally, the lookup also extends to the namespaces of any templates used as template template parameters. e.g.</p>\n<pre><code>namespace mynamespace {\n    template&lt;typename T&gt;\n    struct mytemplate\n    {};\n\n    template&lt;typename T&gt;\n    void bar(T const&amp;) {}\n}\n\ntemplate&lt;template&lt;typename&gt; class T&gt;\nstruct wrapper {};\n\nint main() {\n    wrapper&lt;mynamespace::mytemplate&gt; x;\n    bar(x);\n}\n</code></pre>\n<p>Even though <code>wrapper</code> is in the global namespace, <code>mynamespace::bar</code> will be found, because the template template parameter used for <code>x</code> is <code>mynamespace::mytemplate</code>.</p>\n", "OwnerUserId": "5597", "PostTypeId": "2", "Id": "6211981", "Score": "17", "CreationDate": "2011-06-02T08:05:46.700", "LastActivityDate": "2011-06-02T08:05:46.700"}});