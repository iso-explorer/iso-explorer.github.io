post_cb({"bq_ids": {"n4140": {"so_15583021_15583021_1": {"length": 16, "quality": 1.0, "section_id": 531}, "so_15583021_15583021_2": {"length": 9, "quality": 1.0, "section_id": 531}, "so_15583021_15583021_0": {"length": 16, "quality": 0.8, "section_id": 530}, "so_15583021_15583021_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 531}}, "n3337": {"so_15583021_15583021_2": {"length": 9, "quality": 1.0, "section_id": 522}, "so_15583021_15583021_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 522}, "so_15583021_15583021_0": {"length": 16, "quality": 0.8, "section_id": 521}, "so_15583021_15583021_1": {"length": 16, "quality": 1.0, "section_id": 522}}, "n4659": {"so_15583021_15583021_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 552}, "so_15583021_15583021_2": {"length": 9, "quality": 1.0, "section_id": 552}, "so_15583021_15583021_0": {"length": 16, "quality": 0.8, "section_id": 551}, "so_15583021_15583021_1": {"length": 16, "quality": 1.0, "section_id": 552}}}, "15584518": {"Id": "15584518", "PostTypeId": "2", "Body": "<p><code>g(x)</code> is always replaced by <code>2 x</code>. In the second nested replacement of g, you call <code>g(x)</code> with <code>x=3</code>, so this produces the result <code>2 3</code>. My understanding is that the compiler doesn't replace the macro with it's value, in case this produces an infinite loop:</p>\n<pre><code>#define g( x ) f( x )\n#define f( x ) g( x )\n\ng( 1 ) -- &gt; f( 1 ) --&gt; stop \n</code></pre>\n", "LastActivityDate": "2013-03-23T07:43:32.640", "CommentCount": "0", "CreationDate": "2013-03-23T07:43:32.640", "ParentId": "15583021", "Score": "0", "OwnerUserId": "1341622"}, "15672301": {"Id": "15672301", "PostTypeId": "2", "Body": "<p>This explains the original intent, and why no clarifications have been added to the standard about this subject:</p>\n<p><a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#268\" rel=\"noreferrer\">http://open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#268</a></p>\n<hr>\n<blockquote>\n<h2>268. Macro name suppression in rescanned replacement text</h2>\n<p id=\"so_15583021_15672301_0\"><strong>Section</strong>: 16.3.4  [cpp.rescan] \u00a0 \u00a0 <strong>Status</strong>: open \u00a0 \u00a0 <strong>Submitter</strong>: Bjarne Stroustrup \u00a0 \u00a0 <strong>Date</strong>: 18 Jan 2001</p>\n<p id=\"so_15583021_15672301_1\">It is not clear from the Standard what the result of the following example should be:</p>\n<pre><code>#define NIL(xxx) xxx\n#define G_0(arg) NIL(G_1)(arg)\n#define G_1(arg) NIL(arg)\nG_0(42)\n</code></pre>\n<p id=\"so_15583021_15672301_2\">The relevant text from the Standard is found in 16.3.4 [cpp.rescan] paragraph 2:</p>\n<blockquote>\n<p id=\"so_15583021_15672301_9\">[snipped] </p>\n</blockquote>\n<p id=\"so_15583021_15672301_4\">The sequence of expansion of <code>G0(42)</code> is as follows:</p>\n<pre><code>G0(42)\nNIL(G_1)(42)\nG_1(42)\nNIL(42)\n</code></pre>\n<p id=\"so_15583021_15672301_5\">The question is whether the use of <code>NIL</code> in the last line of this sequence qualifies for non-replacement under the cited text. If it does, the result will be <code>NIL(42)</code>. If it does not, the result will be simply <code>42</code>.</p>\n<p id=\"so_15583021_15672301_6\"><strong>The original intent of the J11 committee in this text was that the result should be <code>42</code>, as demonstrated by the original pseudo-code description of the replacement algorithm provided by Dave Prosser, its author.</strong> The English description, however, omits some of the subtleties of the pseudo-code and thus arguably gives an incorrect answer for this case.</p>\n<p id=\"so_15583021_15672301_7\"><em>Suggested resolution (Mike Miller)</em>: [snipped]</p>\n<h3>Notes (via Tom Plum) from April, 2004 WG14 Meeting:</h3>\n<p id=\"so_15583021_15672301_8\">Back in the 1980's it was understood by several WG14 people that there were tiny differences between the \"non-replacement\" verbiage and the attempts to produce pseudo-code. <strong>The committee's decision was that no realistic programs \"in the wild\" would venture into this area, and trying to reduce the uncertainties is not worth the risk of changing conformance status of implementations or programs.</strong></p>\n</blockquote>\n</hr>", "LastEditorUserId": "224671", "LastActivityDate": "2013-05-22T08:38:15.517", "Score": "6", "CreationDate": "2013-03-28T00:45:11.890", "ParentId": "15583021", "CommentCount": "5", "OwnerUserId": "1150292", "LastEditDate": "2013-05-22T08:38:15.517"}, "16686941": {"Id": "16686941", "PostTypeId": "2", "Body": "<p>Because it mentions \"(not including the rest of the source file\u2019s preprocessing tokens).\" The first replacement of <code>g</code> only sees <code>f</code>. Now <code>f</code> is eligible for replacement with the preprocessing tokens taken from the rest of the file, but nowhere does the program record that <code>f</code> was produced by <code>g</code>. The replacement of <code>f(g)</code> produces a <code>g</code> which is likewise untainted by recursion.</p>\n<p>A nested replacement is one that is enclosed by another replacement, not one whose tokens were sourced from another replacement. By the latter definition, a replacement could have several mutually exclusive nesting parents.</p>\n", "LastActivityDate": "2013-05-22T08:26:26.027", "CommentCount": "13", "CreationDate": "2013-05-22T08:26:26.027", "ParentId": "15583021", "Score": "0", "OwnerUserId": "153285"}, "15583021": {"ViewCount": "3344", "Body": "<p>It says in C++ std 16.3.4:</p>\n<blockquote>\n<p id=\"so_15583021_15583021_0\">The resulting preprocessing token sequence [from a macro invocation replacement]\n  is rescanned, along with all subsequent preprocessing tokens of the source file, for more macro names to\n  replace.</p>\n<p id=\"so_15583021_15583021_1\">If the name of the macro being replaced is found during this scan of the replacement list (not including the\n  rest of the source file\u2019s preprocessing tokens), it is not replaced.</p>\n<p id=\"so_15583021_15583021_2\">Furthermore, if <strong>any nested replacements</strong> encounter the name of the macro being replaced, it is not replaced.</p>\n<p id=\"so_15583021_15583021_3\">These nonreplaced macro name preprocessing tokens are no longer available for further replacement even if they are later (re)examined in contexts\n  in which that macro name preprocessing token would otherwise have been replaced.</p>\n</blockquote>\n<p><strong>What exactly is a nested macro replacement?</strong></p>\n<p>Specifically consider:</p>\n<pre><code>#define f(x) 1 x\n#define g(x) 2 x\n\ng(f)(g)(3)\n</code></pre>\n<p>I would have expected the following:</p>\n<pre><code>g(f)(g)(3)    &lt;-- first replacement of g, ok\n2 f(g)(3)     &lt;-- nested replacement of f, ok\n2 1 g(3)      &lt;-- second nested replacement of g, don't replace, stop\n</code></pre>\n<p>However gcc unexpectedly goes ahead with the second replacement of g, producing:</p>\n<pre><code>2 1 2 3\n</code></pre>\n<p>Any ideas?</p>\n<p><strong>Update:</strong></p>\n<p>After much research, let me clear up this issue with a simpler example:</p>\n<pre><code>#define A(x) B\n#define B(x) A(x)\n\nA(i)(j)\n</code></pre>\n<p>This expands as follows:</p>\n<pre><code>A(i)(j)\nB(j)\nA(j)\n</code></pre>\n<p>The standard does not specify whether <code>A(j)</code> should be expanded to <code>B</code> or not.  The committee decided to leave it this way because real world programs are not expected to depend on this behavior, so both leaving <code>A(j)</code> unexpanded and expanding <code>A(j)</code> to <code>B</code> are considered conformant.</p>\n", "AcceptedAnswerId": "15672301", "Title": "C++11 nested macro invocation?", "CreationDate": "2013-03-23T03:28:23.937", "Id": "15583021", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-05-24T04:16:02.160", "LastEditorUserId": "1131467", "LastActivityDate": "2013-05-24T04:16:02.160", "Score": "15", "OwnerUserId": "1131467", "Tags": "<c++><c><c++11><macros>", "AnswerCount": "3"}});