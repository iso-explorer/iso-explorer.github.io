post_cb({"bq_ids": {"n4140": {"so_34986335_34986391_3": {"length": 18, "quality": 0.72, "section_id": 7212}, "so_34986335_34986391_2": {"length": 5, "quality": 0.625, "section_id": 45}, "so_34986335_34986350_4": {"length": 12, "quality": 0.5714285714285714, "section_id": 7043}, "so_34986335_34986350_1": {"length": 5, "quality": 0.625, "section_id": 45}}, "n3337": {"so_34986335_34986391_3": {"length": 18, "quality": 0.72, "section_id": 6956}, "so_34986335_34986391_2": {"length": 5, "quality": 0.625, "section_id": 42}, "so_34986335_34986350_4": {"length": 12, "quality": 0.5714285714285714, "section_id": 6788}, "so_34986335_34986350_1": {"length": 5, "quality": 0.625, "section_id": 42}}, "n4659": {"so_34986335_34986391_3": {"length": 18, "quality": 0.72, "section_id": 8721}, "so_34986335_34986391_1": {"length": 5, "quality": 0.625, "section_id": 7709}, "so_34986335_34986391_2": {"length": 5, "quality": 0.625, "section_id": 46}, "so_34986335_34986350_4": {"length": 12, "quality": 0.5714285714285714, "section_id": 8540}, "so_34986335_34986350_1": {"length": 5, "quality": 0.625, "section_id": 46}}}, "34986335": {"ViewCount": "415", "Body": "<p>\nRecently, I found out there are some cases that will absolutely violate the ODR of C++ but will be compiled OK in C compiler.</p>\n<p>For example, this wierd scenario (with me):</p>\n<p><strong>Source 1</strong></p>\n<pre class=\"lang-cpp prettyprint-override\"><code>int var_global=-3;\n</code></pre>\n<p><strong>Source 2</strong></p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;stdio.h&gt;\n#include &lt;conio.h&gt;\n\nunsigned int var_global;\n\nint main() {    \n\n printf(\"%d \\n\",var_global);\n getch();\n return 0;\n\n}\n</code></pre>\n<p>I have the printed result is <code>-3</code> (even though in <strong>Source 2</strong> <code>var_global</code> is <code>unsigned</code>) and there is no error about the <strong>redefined</strong> of <code>var_global</code>.</p>\n<p>I knew that C have different rules with C++ but I don't think it's so different like that.</p>\n<p>I have google and read a lot of results but there is no official result <a href=\"https://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"nofollow\">like this</a> of C++.</p>\n<p>So question is:</p>\n<p><strong>Does C have One Definition Rule like C++ ?</strong></p>\n<p>and:</p>\n<p><strong>What is it called officially?</strong></p>\n<p>I need it to compare with the rule of C++ so that I can understand both languages deeper.</p>\n<p>p/s: I used Visual Studio 2010 for compiling the code above.</p>\n", "AcceptedAnswerId": "34986350", "Title": "Does C have One Definition Rule like C++?", "CreationDate": "2016-01-25T06:25:31.510", "Id": "34986335", "CommentCount": "7", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-03-14T04:23:12.230", "LastEditorUserId": "4439794", "LastActivityDate": "2016-03-14T04:23:12.230", "Score": "13", "OwnerUserId": "4439794", "Tags": "<c++><c><global-variables><language-lawyer><variable-declaration>", "AnswerCount": "2"}, "34986350": {"Id": "34986350", "PostTypeId": "2", "Body": "<p>I think what you're looking for is chapter \u00a76.2.7 from the <code>C11</code> standard, <em>Compatible type and composite type</em>, (<em>emphasis mine</em>)</p>\n<blockquote>\n<p id=\"so_34986335_34986350_0\">All declarations that refer to the <strong>same object or function</strong> shall have <strong>compatible type</strong>;\n  otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>and related to compatible type,</p>\n<blockquote>\n<p id=\"so_34986335_34986350_1\">Two types have compatible type if their types are the same.</p>\n</blockquote>\n<p>In your case, <code>int</code> and <code>unsigned int</code> are not compatible types. Hence <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\">undefined behavior</a>.</p>\n<p>Just to add a bit of clarity, in your <em>source 2</em>, <code>unsigned int var_global;</code> is a declaration, and it does not match the other declatation (and definition), so, this is UB.</p>\n<p>That said, a statement like</p>\n<pre><code> printf(\"%d \\n\",var_global);\n</code></pre>\n<p>will always consider the argument to <code>%d</code> to be of type <code>int</code>. In case the type and the format specifier does not match, you'll again invoke <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\">undefined behavior</a>.</p>\n<hr>\n<p><strong>EDIT:</strong></p>\n<p>After the edit, the answer is, use <code>-fno-common</code> to get the desired error. (<em>missing <code>extern</code> is what you're bothered with, I believe</em>).</p>\n<p>Quoting from online GCC manual,</p>\n<blockquote>\n<p id=\"so_34986335_34986350_2\"><code>-fno-common</code></p>\n<p id=\"so_34986335_34986350_3\">In C code, controls the placement of <strong>uninitialized global variables. Unix C compilers have traditionally permitted multiple definitions of such variables in different compilation units by placing the variables in a common block. This is the behavior specified by -fcommon, and is the default for GCC on most targets.</strong> On the other hand, this behavior is not required by ISO C, and on some targets may carry a speed or code size penalty on variable references. The -fno-common option specifies that the compiler should place uninitialized global variables in the data section of the object file, rather than generating them as common blocks. <strong>This has the effect that if the same variable is declared (without <code>extern</code>) in two different compilations, you get a multiple-definition error when you link them.</strong> In this case, you must compile with -fcommon instead. Compiling with -fno-common is useful on targets for which it provides better performance, or if you wish to verify that the program will work on other systems that always treat uninitialized variable declarations this way. </p>\n</blockquote>\n<hr>\n<p>I don't know of any mention of the wordings \"one definition rule\" in the C standard, but along the line, you can look  into annex \u00a7J.5.11, <em>Multiple external definitions</em>,</p>\n<blockquote>\n<p id=\"so_34986335_34986350_4\">There may be more than one external definition for the identifier of an object, with or\n  without the explicit use of the keyword <code>extern</code>; if the definitions disagree, or more than\n  one is initialized, the behavior is undefined.</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "2173917", "LastActivityDate": "2016-01-25T07:31:48.360", "Score": "12", "CreationDate": "2016-01-25T06:26:30.507", "ParentId": "34986335", "CommentCount": "10", "LastEditDate": "2016-01-25T07:31:48.360", "OwnerUserId": "2173917"}, "34986391": {"Id": "34986391", "PostTypeId": "2", "Body": "<p>What you're seeing has nothing to do with a one-definition rule. It has to do with the fact that <code>%d</code> expects a signed value and therefore will almost certainly just be treating it as a signed value in your implementation.</p>\n<p>However, this is not something you should rely on. As per the C standard <code>7.19.6.1 The fprintf function /9</code> (I'm referencing C99 but C11 is pretty much the same in term of the aspects shown here):</p>\n<blockquote>\n<p id=\"so_34986335_34986391_0\">If any argument is not the correct type for the corresponding conversion specification, the behaviour is undefined.</p>\n</blockquote>\n<p>Since you're using undefined behaviour, the implementation is free to do whatever it wants. In addition, the standard also specifically states that it's undefined behaviour if (from Annex J):</p>\n<blockquote>\n<p id=\"so_34986335_34986391_1\">two declarations of the same object or function specify types that are not compatible.</p>\n</blockquote>\n<p>In your case, those two declarations do specify the same object since they both have external linkage.</p>\n<p>Now you might <em>think</em> that signed and unsigned integers would be compatible but you would be wrong: <code>6.2.7 Compatible and composite type</code>, and <code>6.2.5 Types</code> makes it clear that signed and unsigned variants are not compatible:</p>\n<blockquote>\n<p id=\"so_34986335_34986391_2\">Two types have compatible type if their types are the <em>same</em>.</p>\n<p id=\"so_34986335_34986391_3\">For each of the signed integer types, there is a corresponding (but <em>different</em>) unsigned integer type (designated with the keyword unsigned) that uses the same amount of storage (including sign information) and has the same alignment requirements.</p>\n</blockquote>\n", "LastEditorUserId": "14860", "LastActivityDate": "2016-01-25T08:18:33.507", "Score": "2", "CreationDate": "2016-01-25T06:30:13.593", "ParentId": "34986335", "CommentCount": "2", "LastEditDate": "2016-01-25T08:18:33.507", "OwnerUserId": "14860"}});