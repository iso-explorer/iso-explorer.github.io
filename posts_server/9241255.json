post_cb({"bq_ids": {"n4140": {"so_9241255_9241363_0": {"length": 16, "quality": 0.8, "section_id": 5398}, "so_9241255_9241363_2": {"length": 29, "quality": 0.90625, "section_id": 3245}, "so_9241255_9241363_3": {"length": 27, "quality": 0.84375, "section_id": 5991}}, "n3337": {"so_9241255_9241363_0": {"length": 16, "quality": 0.8, "section_id": 5193}, "so_9241255_9241363_2": {"length": 29, "quality": 0.90625, "section_id": 3118}, "so_9241255_9241363_3": {"length": 27, "quality": 0.84375, "section_id": 5759}}, "n4659": {"so_9241255_9241363_0": {"length": 16, "quality": 0.8, "section_id": 6823}, "so_9241255_9241363_3": {"length": 28, "quality": 0.875, "section_id": 7491}}}, "9241363": {"Id": "9241363", "PostTypeId": "2", "Body": "<h3>Function declaration</h3>\n<p>There doesn't appear to be anything directly addressing this. It may be that it's allowed because it is not disallowed.</p>\n<p><code>7.1.1/9</code> tells us that it's ok for an <code>extern</code> declaration (which is semantically similar to a member function declaration), and shows us non-normatively that types in such declarations may be incomplete:</p>\n<blockquote>\n<p id=\"so_9241255_9241363_0\"><code>[C++11: 7.1.1/9]:</code> The name of a declared but undefined class can be used in an <code>extern</code> declaration. Such a declaration can only be used in ways that do not require a complete class type. [ <em>Example:</em></p>\n<pre><code>struct S;\nextern S a;\nextern S f();\nextern void g(S);\nvoid h() {\n  g(a); // error: S is incomplete\n  f(); // error: S is incomplete\n}\n</code></pre>\n<p id=\"so_9241255_9241363_1\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<h3>Function definition (thanks litb)</h3>\n<blockquote>\n<p id=\"so_9241255_9241363_2\"><code>[C++11: 8.3.5/9]:</code> Types shall not be defined in return or parameter types. <strong>The type of a parameter or the return type for a function definition shall not be an incomplete class type</strong> (possibly cv-qualified) unless the function definition is nested within the member-specification for that class (including definitions in nested classes defined within\n  the class).</p>\n</blockquote>\n<h3>Function call</h3>\n<blockquote>\n<p id=\"so_9241255_9241363_3\"><code>[C++11: 5.2.2/4]:</code> [..] <strong>When a function is called, the parameters that have object type shall have completely-defined object type.</strong> [ <em>Note:</em> this still allows a parameter to be a pointer or reference to an incomplete class type. However, it prevents a passed-by-value parameter to have an incomplete class type. <em>\u2014end note</em> ] [..]</p>\n</blockquote>\n", "LastActivityDate": "2012-02-11T15:28:29.097", "Score": "0", "CreationDate": "2012-02-11T15:28:29.097", "ParentId": "9241255", "CommentCount": "0", "OwnerUserId": "560648"}, "9241300": {"Id": "9241300", "PostTypeId": "2", "Body": "<p>See 8.3.5p9, which lays down the exact rules. For a <code>= delete</code> definition, implementations are <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1394\" rel=\"noreferrer\">likely to accept incomplete parameter types</a> too, retroactively (as was determined in a DR resolution by the C++ committee).</p>\n<p>In particular, there is no action done on parameters or return values in a non-defining function declaration. Copying of arguments to parameters is done in the context of the caller. And destruction of parameters is done in the context of the callee, in the function <em>definition</em>. Destruction of the return value is done in the context of the caller in a <em>function call</em> except if the call is the topmost expression or right operand of a topmost comma operator in a <code>decltype</code>. Then no destruction happens because no temporary is created as a special case (to help SFINAE libraries). </p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2012-02-11T15:29:17.147", "Score": "5", "CreationDate": "2012-02-11T15:19:13.900", "ParentId": "9241255", "CommentCount": "9", "LastEditDate": "2012-02-11T15:29:17.147", "OwnerUserId": "34509"}, "9241255": {"ViewCount": "650", "Body": "<p>I recently found out that the types of parameters in a non-defining function declaration may be of incomplete types. This is very exciting.</p>\n<pre><code>class A;\nclass B {\n   B(A a);      // Legal! Wow!\n};\n</code></pre>\n<p>The type is required to be complete only for the definition:</p>\n<pre><code>B::B(A a) {};   // error: \u2018a\u2019 has incomplete type\n</code></pre>\n<p>I've been trying to pin down the legalese for this, but my searches through C++11 for \"[in]complete type\" have yielded nothing of much interest, leading me to assume that these semantics are defined through an enigmatic maze of constructions.</p>\n<p>Can you help me pin down the standard text that defines the above requirements for the types of function parameters being complete or otherwise, in function declarations vs definitions?</p>\n<p><sup>(<code>9.2/10</code> and <code>9.4.2/2</code> give us the requirements for <code>static</code> data member declarations and non-<code>static</code> data member definitions in class definitions.)</sup></p>\n", "AcceptedAnswerId": "9241363", "Title": "Where is the standard wording allowing incomplete types in function declarations, but requiring complete types in function definitions?", "CreationDate": "2012-02-11T15:12:37.070", "Id": "9241255", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-02-11T15:29:17.147", "Score": "1", "OwnerUserId": "560648", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}});