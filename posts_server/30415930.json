post_cb({"bq_ids": {"n4140": {"so_30415930_30416005_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 236}, "so_30415930_30416005_0": {"length": 27, "quality": 0.9, "section_id": 233}}, "n3337": {"so_30415930_30416005_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 229}, "so_30415930_30416005_0": {"length": 27, "quality": 0.9, "section_id": 226}}, "n4659": {"so_30415930_30416005_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 246}, "so_30415930_30416005_0": {"length": 27, "quality": 0.9, "section_id": 242}}}, "30416005": {"Id": "30416005", "PostTypeId": "2", "Body": "<p>You assuredly saw this quote from \u00a714.7.1/1:</p>\n<blockquote>\n<p id=\"so_30415930_30416005_0\">Unless a class template specialization has been explicitly\n  instantiated (14.7.2) or explicitly specialized (14.7.3), the class\n  template specialization is implicitly instantiated <strong>when the\n  specialization is referenced in a context that requires a\n  completely-defined object type or when the completeness of the class\n  type affects the semantics of the program.</strong></p>\n</blockquote>\n<p>Pointer types do not require their pointee to be a complete type (e.g. <code>void*</code> is an example of this). Thus the first line will not instantiate the specialization, but the second one needs to, hence the assertion fires only on that one.</p>\n<p>This is also addressed by an example three paragraphs further down: </p>\n<blockquote>\n<p id=\"so_30415930_30416005_1\">[ <em>Example</em>:</p>\n<pre><code>template&lt;class T&gt; struct Z {\n  void f();\n  void g();\n};\n\nvoid h() {\n  Z&lt;int&gt; a;      // instantiation of class Z&lt;int&gt; required\n  Z&lt;double&gt;* q;  // instantiation of class Z&lt;double&gt; not required\n  //[\u2026]\n}\n</code></pre>\n<p id=\"so_30415930_30416005_2\">Nothing in this example requires class <code>Z&lt;double&gt;</code> [\u2026] to be implicitly instantiated. \u2014 <em>end example</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2015-05-23T18:07:20.783", "CommentCount": "2", "CreationDate": "2015-05-23T18:07:20.783", "ParentId": "30415930", "Score": "6", "OwnerUserId": "3647361"}, "30415930": {"ViewCount": "231", "Body": "<pre><code>template &lt;size_t N&gt;\nclass Foo\n{\n    static_assert(N &gt; 0, \"WRONG\");\n    //void Something() = 0; //my original implementation\n};\n\nint main() {\n\n    Foo&lt;0&gt; *p2 = nullptr;   //no error\n    Foo&lt;0&gt; p;   //gives an error\n\n    return 0;\n}\n</code></pre>\n<p>I've tested both the lines separately. static_assert is not called when p2 is initialized but it is called and does indeed fail on p. Is this intended? (I've tried it on gcc, clang and VC)</p>\n<p>What are the workarounds? Since I'm using abstract templated classes, it would be a nightmare if the assertion is only performed when a non-pointer object is instantiated. I can use a factory but that isn't exactly a proper solution.</p>\n", "AcceptedAnswerId": "30416005", "Title": "static_assert fails check on templated object pointer", "CreationDate": "2015-05-23T17:59:37.883", "Id": "30415930", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-05-23T18:07:20.783", "Score": "2", "OwnerUserId": "1214085", "Tags": "<c++><templates><c++11><assertions><static-assert>", "AnswerCount": "1"}});