post_cb({"35730655": {"ParentId": "35729956", "CommentCount": "3", "Body": "<p>The <code>&amp;&amp;</code> operator forces left-to-right evaluation and a introduces a sequence point (as does the function call itself); the LHS is fully evaluated (and all side effects applied) before deciding if the RHS needs to be evaluated at all.  </p>\n<p>Thus, <code>if(f(a, b, &amp;c) &amp;&amp; c &lt; 10)</code> will work as you expect; if <code>c &lt; 10</code> is evaluated at all, it will be with the value written to <code>c</code> by the function <code>f</code>.   </p>\n<p>Having said that, this is not great style.  Just because C and C++ allow certain constructs doesn't mean it's a good idea to use them.  Anyone having to maintain your code would probably appreciate you writing it as</p>\n<pre><code>if ( f( a, b, &amp;c ) )\n{\n  if ( c &lt; 10 )\n  {\n    // do stuff\n  }\n}\n</code></pre>\n<p>instead.  </p>\n<p>Yes, it takes a bit more space on the page, but the logic is more obvious.  </p>\n", "OwnerUserId": "134554", "PostTypeId": "2", "Id": "35730655", "Score": "0", "CreationDate": "2016-03-01T18:31:22.827", "LastActivityDate": "2016-03-01T18:31:22.827"}, "35730675": {"ParentId": "35729956", "CommentCount": "3", "Body": "<p>IMHO the code you show is not OK at all. Let me change the function in your example just a little bit:</p>\n<pre><code>int f(int a, int b, int&amp; c) {\n    c = a + b;\n    return c &gt; 0;\n}\n</code></pre>\n<p>Now assume you are given only the following piece of code:</p>\n<pre><code>void check(int a, int b) {\n    int a = 3;\n    int b = 10;\n    int c = 7;\n    std::cout &lt;&lt; c &lt;&lt; std::endl;\n    if(f(a, b, c) || c &lt; 10) {\n        std::cout &lt;&lt; \"moo\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>what do expect it to print? \nOf course, once you know <code>f</code>, there is no problem, whereas, if you write </p>\n<pre><code>    /*...*/\n    int result = f(a,b,c);\n    std::cout &lt;&lt; c &lt;&lt; std::endl;\n    if(result || c &lt; 10) {\n        std::cout &lt;&lt; \"moo\" &lt;&lt; std::endl;\n    }\n</code></pre>\n<p>the code is much easier to read (and to debug) even if you have no knowledge of <code>f</code>.</p>\n", "OwnerUserId": "4117728", "PostTypeId": "2", "Id": "35730675", "Score": "-1", "CreationDate": "2016-03-01T18:32:36.150", "LastActivityDate": "2016-03-01T18:32:36.150"}, "35729983": {"ParentId": "35729956", "CommentCount": "0", "Body": "<p>Yes the expression will be evaluated from left to right and the value of <code>c</code> will be updated accordingly. Execution of the program will step into the function and anything that executes in the function will execute before <code>c &lt; 10</code> will.</p>\n<p>This behavior shouldn't change from <code>C</code> to <code>C++</code></p>\n", "OwnerUserId": "4544684", "PostTypeId": "2", "Id": "35729983", "Score": "4", "CreationDate": "2016-03-01T17:56:47.997", "LastActivityDate": "2016-03-01T17:56:47.997"}, "35729956": {"CommentCount": "5", "ViewCount": "114", "CreationDate": "2016-03-01T17:55:24.140", "LastActivityDate": "2016-03-01T18:32:36.150", "Title": "Is is safe to use result of side effect in expression inside the same expression?", "AcceptedAnswerId": "35730019", "PostTypeId": "1", "Id": "35729956", "Score": "3", "Body": "<p>Consider the following code:</p>\n<pre><code>int f(int a, int b, int *c) {\n    *c = a + b;\n    return *c &gt; 0;\n}\n\nvoid check(int a, int b) {\n    int c;\n    if(f(a, b, &amp;c) &amp;&amp; c &lt; 10) {\n        puts(\"sum is in range [1, 9]\");\n    }\n}\n</code></pre>\n<p>If the second part of <code>&amp;&amp;</code> is ever evaluated, is <code>c</code> guaranteed to hold the value assigned to it by function call <code>f(a, b, &amp;c)</code>? Does this behavior changes from C to C++?</p>\n", "Tags": "<c++><c><language-lawyer>", "OwnerUserId": "578749", "AnswerCount": "5"}, "35730019": {"ParentId": "35729956", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-03-01T17:58:39.003", "Score": "7", "LastEditorUserId": "2410359", "LastEditDate": "2016-03-01T18:07:51.007", "Id": "35730019", "OwnerUserId": "2410359", "Body": "<p>It is safe if a sequence point occurs that controls the order of evaluation.</p>\n<pre><code>// bad: evaluation order of f() and (c &lt; 10) is not specified by C\nif(f(a, b, &amp;c) &amp; c &lt; 10) {\n// OK,  left half of &amp;&amp; must occur first.\nif(f(a, b, &amp;c) &amp;&amp; c &lt; 10) {\n</code></pre>\n<p>With simple <code>&amp;&amp;</code> expressions, there is no C,C++ difference.  With C/C++ the left side is evaluated and the right is evaluated if the left is not false.</p>\n<p>Behavior on this point is more complex when in C++, the <code>&amp;&amp;</code> operator can be overloaded and then both sides of <code>&amp;&amp;</code> are always evaluated.</p>\n", "LastActivityDate": "2016-03-01T18:07:51.007"}, "bq_ids": {"n4140": {"so_35729956_35730320_1": {"section_id": 6163, "quality": 0.896551724137931, "length": 26}, "so_35729956_35730320_0": {"section_id": 5808, "quality": 0.6666666666666666, "length": 4}, "so_35729956_35730320_2": {"section_id": 6164, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_35729956_35730320_1": {"section_id": 5924, "quality": 0.896551724137931, "length": 26}, "so_35729956_35730320_0": {"section_id": 5581, "quality": 0.6666666666666666, "length": 4}, "so_35729956_35730320_2": {"section_id": 5925, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_35729956_35730320_1": {"section_id": 7660, "quality": 0.896551724137931, "length": 26}, "so_35729956_35730320_0": {"section_id": 7269, "quality": 0.6666666666666666, "length": 4}, "so_35729956_35730320_2": {"section_id": 7661, "quality": 0.9583333333333334, "length": 23}}}, "35730320": {"ParentId": "35729956", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_35729956_35730320_0\">is <code>c</code> guaranteed to hold the value assigned to it by function call <code>f(a, b, &amp;c)</code></p>\n</blockquote>\n<p>Yes. This is pretty clearly expressed in [expr.log.and]:</p>\n<blockquote>\n<p id=\"so_35729956_35730320_1\">The <code>&amp;&amp;</code> operator groups left-to-right. The operands are both contextually converted to <code>bool</code> (Clause 4).\n  The result is <code>true</code> if both operands are <code>true</code> and <code>false</code> otherwise. Unlike <code>&amp;</code>, <code>&amp;&amp;</code> guarantees left-to-right\n  evaluation: <strong>the second operand is not evaluated if the first operand is <code>false</code></strong>.</p>\n<p id=\"so_35729956_35730320_2\">The result is a <code>bool</code>. <strong>If the second expression is evaluated, every value computation and side effect associated\n  with the first expression is sequenced before every value computation and side effect associated with the\n  second expression.</strong></p>\n</blockquote>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "35730320", "Score": "3", "CreationDate": "2016-03-01T18:13:58.927", "LastActivityDate": "2016-03-01T18:13:58.927"}});