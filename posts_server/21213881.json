post_cb({"21214761": {"ParentId": "21213881", "CommentCount": "2", "Body": "<p>This is a bit of a mind-bender, but here is what I think is at the core of these issues. Here are the \"problematic\" examples:</p>\n<pre><code>int *ptrarr[1];\nint const * (&amp;rptrarr)[1] = ptrarr;   // error (1)\nint const * const (&amp;why)[1] = ptrarr; // error (2)\n</code></pre>\n<p><strong>Case (1)</strong></p>\n<p>First, I'll tackle the example given in the comment by Dan Nissenbaum, which is this:</p>\n<pre><code>int const * (&amp;rptrarr)[1]\n</code></pre>\n<p>This is actually covered in section 4.4/4 of the standard, which describes the acceptable cv-qualification conversions when you have multiple layers of pointers or types. The important requirement stated is the following:</p>\n<blockquote>\n<p id=\"so_21213881_21214761_0\">if the cv 1,j and cv 2,j are different, then const is in every cv2,k for 0 &lt; k &lt; j.</p>\n</blockquote>\n<p>What this states is that as you peel off the layers of types, there must always be all-consts in the outer layers before you reach a cv-conversion (i.e. cv1,j and cv2,j are different). This is true for pointer conversions beyond the first layer (which is covered by pointer-conversions, not cv-conversions). In other words, this is OK:</p>\n<pre><code>int* p_a;\nint const * p_b = p_a;  // OK\n</code></pre>\n<p>because the first conversion being done is a pointer-conversion (copies the address value), and the second conversion is a cv-conversion. While this is <strong>not</strong> correct:</p>\n<pre><code>int** p_a;\nint const ** p_b = p_a;  // BAD\n</code></pre>\n<p>because here, the first conversion is still a pointer-conversion, which is only OK if the pointee type are compatible (have a valid cv-conversion between them). In this case, it requires are cv-conversion of this non-const pointer to a non-const int, to a non-const pointer to a const int, and that is forbidden by the quoted rule of section 4.4/4 because the first layer is not const while the second layer requires a cv-conversion (from non-const int to const int).</p>\n<p>I know that this is all confusing, but think about it for a while and it will become clear. Now, the reason why this rule exists in section 4.4/4 is because if you were allowed to do this, then I could do this:</p>\n<pre><code>int** pp_a;\nint const ** pp_b = pp_a;  // let's say, the compiler accepted this..\n\nint const * p_c;  // I have some pointer to a const int (that is really const).\npp_b[0] = p_c;    // the compiler would have to accept this too!!!\n</code></pre>\n<p>Clearly, the last line of this example cannot be acceptable in any way because it would be in complete violation of the cv-qualifications, i.e., it is a silent and implicit const-cast, while the whole purpose of these cv-conversion rules is to make sure that this is impossible.</p>\n<p>At this point, it should be pretty obvious why <code>int const * (&amp;rptrarr)[1] = ptrarr;</code> is not allowed, because the first layer is a reference, which obey essentially the same conversion rules as pointers, the second layer is a cv-conversion from a non-const array-of-pointers into a non-const array-of-pointers, and the last layer adds a const qualifier to the <code>int</code> type. And that is in direct violation of the rule that I quoted above.</p>\n<p><strong>Case (2)</strong></p>\n<p>Now, to the main question, which is much less clear, but I think it must have to do with the same argument, somehow. Just to restate, here is the case in question:</p>\n<pre><code>int const * const (&amp;why)[1] = ptrarr; // error\n</code></pre>\n<p>The way I described the first case might be wrong by one layer, but I'm not sure, or maybe the compiler adds one layer too many. As I described it, the second <code>const</code> is needed because any conversion that comes before a non-const-to-const conversion must have a const type as a destination, that's the rule. Case (1) did not work because of those 3 layers of conversion. Here, if I apply the same logic with the layers of conversion, I get three \"conversions\": (1) from lvalue (ptrarr) to an lvalue-reference (why); (2) from non-const array-of-pointers to const array-of-pointers; and, (3) from non-const int to const int.</p>\n<p>But here is the problem. What if the \"array-of-pointers\" cv-conversion is not just a single layer conversion step. If the compiler needs to split that into two layers, as in: (2-a) from non-const array to non-const array; and, (2-b) from non-const pointer to const pointer. Then, it is pretty obvious why this would, again, be in contraction with the rules in section 4.4/4. And under that hypothesis, all the cases you described and the 2 treated here are perfectly explained.</p>\n<p>The problem now is that I couldn't find a place in the standard that would explain why this conversion needs to be split. The standard is pretty clear, in section 3.9.3/2, that cv-qualifiers do not apply to array types, and are, instead, carried over to the element type of the array. In other words, according to the standard, there is no difference between a \"const array of T\" and an \"array of const T\". And, therefore, this seems to contradict the standard.</p>\n<p>It is possible that GCC and Clang take a bit of a short-cut and make an \"array-reference\" the same as a \"pointer\" (because it sort of is), or that they messed up a bit in the ordering of the conversions (which is unlikely). In any case, I could not find a definitive justification for this behavior in the standard. I hope someone does.</p>\n<p>Another possible thing that could be at play here is alignment. As you probably know, elements of an array have to obey the alignment rules that pertain to them. If the alignment rules for <code>int *</code> are not the same as for <code>int const * const</code> (either because of the first or second <code>const</code>), then there is an obvious incompatibility, and hence, an error. Again, the standard says indeed that if the alignment rule is different there is a problem, but I could not find anything that suggests that a const pointer type would have a stricter (or different) alignment rule compared to a non-const pointer type, but it is not entirely impossible that there is such an incompatibility (knowing some of the archaic baggage that the C++ standard carries).</p>\n<p>Anyways, this is my best shot at explaining this. I hope it can be at least somewhat enlightening.</p>\n", "OwnerUserId": "491645", "PostTypeId": "2", "Id": "21214761", "Score": "1", "CreationDate": "2014-01-19T08:45:31.703", "LastActivityDate": "2014-01-19T08:45:31.703"}, "21213881": {"CommentCount": "18", "AcceptedAnswerId": "21214761", "PostTypeId": "1", "LastEditorUserId": "962089", "CreationDate": "2014-01-19T06:22:37.823", "LastActivityDate": "2014-04-17T16:15:35.423", "LastEditDate": "2014-04-17T16:15:35.423", "ViewCount": "149", "FavoriteCount": "1", "Title": "How do I enforce not modifying any part of a referred to variable?", "Id": "21213881", "Score": "6", "Body": "<p>When making a reference to something, it's possible to add extra <code>const</code> qualifiers so that the referred variable cannot be modified, like this:</p>\n<pre><code>int *ptr;\nint const * const &amp;rptr = ptr;\n//ptr can't be changed and *ptr can't be changed\n</code></pre>\n<p>Or like this, with an array:</p>\n<pre><code>int arr[1];\nint const (&amp;rarr)[1] = arr;\n//arr[0] can't be changed\n</code></pre>\n<p>Or even like this, with an array of pointers:</p>\n<pre><code>int *ptrarr[1];\nint * const (&amp;rptrarr)[1] = ptrarr;\n//ptrarr[0] cannot be changed, but *ptrarr[0] can be\n</code></pre>\n<p>Why, then, can I not combine these and do this?</p>\n<pre><code>int *ptrarr[1];\nint const * const (&amp;why)[1] = ptrarr; //error\n</code></pre>\n<p>When attempting this, <a href=\"http://coliru.stacked-crooked.com/a/efbbdb72c757b7d9\" rel=\"nofollow\" title=\"Sample combining all of the above\">Clang 3.5 produces the following error</a>, and GCC 4.8.1 a similar one:</p>\n<blockquote>\n<p id=\"so_21213881_21213881_0\">error: reference to type <code>const int *const [1]</code> could not bind to an lvalue of type <code>int *[1]</code></p>\n</blockquote>\n<p>What is the correct way to protect all parts of a referred to array of pointers with <code>const</code>?</p>\n<p><sub>Note: This is an artificial example, but I hope this results in knowledge about the language that could come in useful later.</sub></p>\n", "Tags": "<c++><arrays><pointers><reference><const>", "OwnerUserId": "962089", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21213881_21214761_0": {"section_id": 17, "quality": 0.8, "length": 4}, "so_21213881_21213881_0": {"section_id": 3321, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_21213881_21214761_0": {"section_id": 14, "quality": 0.8, "length": 4}, "so_21213881_21213881_0": {"section_id": 3191, "quality": 0.5454545454545454, "length": 6}}, "n4659": {"so_21213881_21214761_0": {"section_id": 18, "quality": 0.8, "length": 4}, "so_21213881_21213881_0": {"section_id": 4087, "quality": 0.5454545454545454, "length": 6}}}});