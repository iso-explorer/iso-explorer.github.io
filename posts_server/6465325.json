post_cb({"6465761": {"Id": "6465761", "PostTypeId": "2", "Body": "<p>Technically, as Maxim points out, linkage applies to symbols, not to the\nentities they denote.  But the linkage of a symbol is partially\ndetermined by what it denotes: symbols which name classes defined at\nnamespace scope have external linkage, and <code>w</code> denotes the same entity\nin both <code>A.cpp</code> and <code>B.cpp</code>.</p>\n<p>C++ has two different sets of rules concerning the definition of\nentities: some entities, like functions or variables, may only be\ndefined once in the entire program.  Defining them more than once will\nresult in undefined behavior; most implementations will (most of the\ntime, anyway) give a multiple definition error, but this is not required\nor guaranteed.  Other entities, such as classes or templates, are\nrequired to be defined in each translation unit which uses them, with\nthe further requirement that every definition be identical: same\nsequence of tokens, and all symbols binding to the same entity, with a\nvery limited exception for symbols in constant expressions, provided the\naddress is never taken.  Violating these requirements is also undefined\nbehavior, but in this case, most systems will not even warn. </p>\n", "LastActivityDate": "2011-06-24T09:12:58.273", "CommentCount": "2", "CreationDate": "2011-06-24T09:12:58.273", "ParentId": "6465325", "Score": "4", "OwnerUserId": "649665"}, "26052100": {"Id": "26052100", "PostTypeId": "2", "Body": "<p>The correct answer is yes, the name of a class may have external linkage. The previous answers are wrong and misleading. The code you show is legal and common.</p>\n<p>The name of a class in C++03 can either have external linkage or no linkage. In C++11 the name of a class may additionally have internal linkage.</p>\n<p>C++03</p>\n<p>\u00a73.5 [basic.link]</p>\n<blockquote>\n<p id=\"so_6465325_26052100_0\">A name is said to have linkage when it might denote the same object,\n  reference, function, <strong>type</strong>, template, namespace or value as a name\n  introduced by a declaration in another scope</p>\n</blockquote>\n<p>Class names can have external linkage.</p>\n<blockquote>\n<p id=\"so_6465325_26052100_1\">A name having namespace scope has external linkage if it is the name\n  of</p>\n<p id=\"so_6465325_26052100_2\">[...]</p>\n<p id=\"so_6465325_26052100_3\">\u2014 a named class (clause 9), or an unnamed class defined in a typedef declaration in which the class has the typedef name for linkage\n  purposes (7.1.3)</p>\n</blockquote>\n<p>Class names can have no linkage.</p>\n<blockquote>\n<p id=\"so_6465325_26052100_4\">Names not covered by these rules have no linkage. Moreover, except as\n  noted, a name declared in a local scope (3.3.2) has no linkage. A name\n  with no linkage (notably, the name of a class or enumeration declared\n  in a local scope (3.3.2)) shall not be used to declare an entity with\n  linkage.</p>\n</blockquote>\n<p>In C++11 the first quote changes and class names at namespace scope may now have external or internal linkage.</p>\n<blockquote>\n<p id=\"so_6465325_26052100_5\">An unnamed namespace or a namespace declared directly or indirectly\n  within an unnamed namespace has internal linkage. All other namespaces\n  have external linkage. A name having namespace scope that has not been\n  given internal linkage above [class names were not] has the same linkage\n  as the enclosing namespace if it is the name of</p>\n<p id=\"so_6465325_26052100_6\">[...]</p>\n<p id=\"so_6465325_26052100_7\">\u2014 a named class (Clause 9), or an unnamed class defined in a typedef\n  declaration in which the class has the typedef name for linkage\n  purposes (7.1.3);</p>\n</blockquote>\n<p>The second quote also changes but the conclusion is the same, class names may have no linkage.</p>\n<blockquote>\n<p id=\"so_6465325_26052100_8\">Names not covered by these rules have no linkage. Moreover, except as\n  noted, a name declared at block scope (3.3.3) has no linkage. A type\n  is said to have linkage if and only if:</p>\n<p id=\"so_6465325_26052100_9\">\u2014 it is a class or enumeration type that is named (or has a name for\n  linkage purposes (7.1.3)) and the name has linkage; or</p>\n<p id=\"so_6465325_26052100_10\">\u2014 it is an unnamed class or enumeration member of a class with linkage;</p>\n</blockquote>\n<p>Some of the answers here conflate the abstract notion of linkage in the C++ Standard with the computer program known as a linker. The C++ Standard does not give special meaning to the word symbol. A symbol is what a linker resolves when combining object files into an executable. Formally, this is irrelevant to the notion of linkage in the C++ Standard. The document only ever addresses linkers in a footnote regarding character encoding.</p>\n<p>Finally, your example is legal C++ and <strong>is not an ODR violation</strong>. Consider the following.</p>\n<pre><code>C.h\n----------\nclass w\n{\npublic:\n    w();\n};\n\n\nA.cpp\n-----------\n#include \"C.h\"\n\n\nB.cpp\n-----------\n#include \"C.h\"\n</code></pre>\n<p>Perhaps this looks familiar. After preprocessor directives are evaluated we are left with the original example. The Wikipedia link provided by Alok Save even states this as an exception.</p>\n<blockquote>\n<p id=\"so_6465325_26052100_11\">Some things, like types, templates, and extern inline functions, can\n  be defined in more than one translation unit. For a given entity, each\n  definition must be the same.</p>\n</blockquote>\n<p>The ODR rule takes content into consideration. What you show is in fact required in order for a translation unit to use a class as a complete type.</p>\n<p>\u00a73.5 [basic.def.odr]</p>\n<blockquote>\n<p id=\"so_6465325_26052100_12\">Exactly one definition of a class is required in a translation unit if\n  the class is used in a way that requires the class type to be\n  complete.</p>\n</blockquote>\n<p><em>edit - The second half of James Kanze's answer got this right.</em></p>\n", "LastEditorUserId": "1128289", "LastActivityDate": "2014-09-26T04:58:40.370", "Score": "14", "CreationDate": "2014-09-26T04:32:23.543", "ParentId": "6465325", "CommentCount": "1", "OwnerUserId": "1128289", "LastEditDate": "2014-09-26T04:58:40.370"}, "29381992": {"Id": "29381992", "PostTypeId": "2", "Body": "<p>The class <em>declaration</em></p>\n<pre><code>class w\n{\npublic:\n    w();\n};\n</code></pre>\n<p>does not produce any code or symbols, so there is nothing that could be linked and have \"linkage\". However, when your constructor w() is <em>defined</em> ...</p>\n<pre><code>w::w()\n{\n  // object initialization goes here\n}\n</code></pre>\n<p>it will have external linkage. If you define it in both A.cpp and B.cpp, there will be a name collision; what happens then depends on your linker. MSVC linkers e.g. will terminate with an error LNK2005 \"function already defined\" and/or LNK1169 \"one or more multiply defined symbols found\". The GNU g++ linker will behave similar. (For duplicate <a href=\"http://en.cppreference.com/w/cpp/language/templates\" rel=\"nofollow\">template</a> methods, they will instead eliminate all but one instance; GCC docs call this the \"<a href=\"http://en.wikipedia.org/wiki/Borland\" rel=\"nofollow\">Borland</a> model\").</p>\n<p>There are four ways to resolve this problem:</p>\n<ol>\n<li>If both classes are identical, put the definitions only into one .cpp file.</li>\n<li>If you need two different, externally linked implementations of <code>class w</code>, put them into different <a href=\"http://en.cppreference.com/w/cpp/language/namespace\" rel=\"nofollow\">namespaces</a>.</li>\n<li>Avoid external linkage by putting the definitions into an <em>anonymous namespace</em>.</li>\n</ol>\n<pre><code>namespace\n{\n  w::w()\n  {\n    // object initialization goes here\n  }\n}\n</code></pre>\n<p>Everying in an anonymous namespace has internal linkage, so you may also use it as a replacement for <code>static</code> declarations (which are not possible for class methods).</p>\n<ol start=\"4\">\n<li>Avoid creating symbols by defining the methods inline:</li>\n</ol>\n<pre><code>inline w::w()\n{\n  // object initialization goes here\n}\n</code></pre>\n<p>No 4 will only work if your class has no static fields (class variables), and it will duplicate the code of the inline methods for each function call.</p>\n", "LastEditorUserId": "1620190", "LastActivityDate": "2015-04-01T02:47:15.500", "Score": "0", "CreationDate": "2015-04-01T02:41:35.883", "ParentId": "6465325", "CommentCount": "1", "OwnerUserId": "1620190", "LastEditDate": "2015-04-01T02:47:15.500"}, "6465416": {"Id": "6465416", "PostTypeId": "2", "Body": "<p>Classes have no linkage to be pedantic.</p>\n<p>Linkage only applies to <code>symbols</code>, that is, functions and variables, or code and data.</p>\n", "LastActivityDate": "2011-06-24T08:45:24.567", "CommentCount": "1", "CreationDate": "2011-06-24T08:45:24.567", "ParentId": "6465325", "Score": "0", "OwnerUserId": "412080"}, "bq_ids": {"n4140": {"so_6465325_26052100_5": {"length": 31, "quality": 0.9117647058823529, "section_id": 7137}, "so_6465325_26052100_8": {"length": 17, "quality": 0.9444444444444444, "section_id": 7141}, "so_6465325_26052100_12": {"length": 13, "quality": 1.0, "section_id": 7042}, "so_6465325_26052100_9": {"length": 9, "quality": 0.9, "section_id": 7141}, "so_6465325_26052100_10": {"length": 6, "quality": 1.0, "section_id": 7141}, "so_6465325_26052100_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 7136}, "so_6465325_26052100_7": {"length": 13, "quality": 0.9285714285714286, "section_id": 7137}, "so_6465325_26052100_4": {"length": 19, "quality": 0.7037037037037037, "section_id": 7141}, "so_6465325_26052100_0": {"length": 19, "quality": 0.95, "section_id": 7135}, "so_6465325_26052100_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 7137}}, "n3337": {"so_6465325_26052100_5": {"length": 31, "quality": 0.9117647058823529, "section_id": 6881}, "so_6465325_26052100_8": {"length": 17, "quality": 0.9444444444444444, "section_id": 6885}, "so_6465325_26052100_12": {"length": 13, "quality": 1.0, "section_id": 6787}, "so_6465325_26052100_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 6881}, "so_6465325_26052100_10": {"length": 6, "quality": 1.0, "section_id": 6885}, "so_6465325_26052100_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6880}, "so_6465325_26052100_7": {"length": 13, "quality": 0.9285714285714286, "section_id": 6881}, "so_6465325_26052100_4": {"length": 19, "quality": 0.7037037037037037, "section_id": 6885}, "so_6465325_26052100_0": {"length": 19, "quality": 0.95, "section_id": 6879}, "so_6465325_26052100_9": {"length": 9, "quality": 0.9, "section_id": 6885}}, "n4659": {"so_6465325_26052100_5": {"length": 31, "quality": 0.9117647058823529, "section_id": 8638}, "so_6465325_26052100_8": {"length": 17, "quality": 0.9444444444444444, "section_id": 8642}, "so_6465325_26052100_12": {"length": 13, "quality": 1.0, "section_id": 8539}, "so_6465325_26052100_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 8638}, "so_6465325_26052100_10": {"length": 6, "quality": 1.0, "section_id": 8642}, "so_6465325_26052100_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 8637}, "so_6465325_26052100_7": {"length": 13, "quality": 0.9285714285714286, "section_id": 8638}, "so_6465325_26052100_4": {"length": 18, "quality": 0.6666666666666666, "section_id": 8642}, "so_6465325_26052100_0": {"length": 19, "quality": 0.95, "section_id": 8636}, "so_6465325_26052100_9": {"length": 9, "quality": 0.9, "section_id": 8642}}}, "6465394": {"Id": "6465394", "PostTypeId": "2", "Body": "<p><em><strong>External linkage</strong></em></p> means the symbol (function or global variable) is accessible throughout your program and <strong><em>Internal linkage</em></strong> means that it's only accessible in one translation unit. you explicitly control the linkage of a symbol by using the extern and static keywords and the default linkage is extern for non-const symbols and static (internal) for const symbols.\n<p>A name with external linkage denotes an entity that can be referenced via names declared in the same scope or in other scopes of the same translation unit (just as with internal linkage), or additionally in other translation units.</p>\n<p>The program actually violates the <strong><a href=\"http://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"nofollow\">One Definition Rule</a></strong> but it is hard for the compiler to detect the error, because they are in different compilation units. And even the linker seems cannot detect it as an error.  </p>\n<p>C++ allows a workaround to bypass the One Definition Rule by making use of <strong><em>namespace.</em></strong> </p>\n<p>[UPDATE] <strong><em>From C++03 Standard</em></strong><br>\n<strong><em>\u00a7 3.2 One definition rule, section 5 states:</em></strong> </br></p>\n<p><em>There can be more than one definition of a class type ... in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one translation unit, then each definition of D shall consist of the same sequence of tokens.</em></p>\n", "LastEditorUserId": "452307", "LastActivityDate": "2011-06-24T09:06:14.213", "Score": "1", "CreationDate": "2011-06-24T08:43:34.190", "ParentId": "6465325", "CommentCount": "6", "OwnerUserId": "452307", "LastEditDate": "2011-06-24T09:06:14.213"}, "6465325": {"ViewCount": "2768", "Body": "<p>I have 2 files A.cpp and B.cpp which look something like </p>\n<pre><code>A.cpp\n----------\nclass w\n{\npublic:\n    w();\n};\n\n\nB.cpp\n-----------\nclass w\n{\npublic:\n    w();\n};\n</code></pre>\n<p>Now I read somewhere (<a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=/com.ibm.xlcpp8a.doc/language/ref/cplr082.htm\" rel=\"nofollow\">http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Fcplr082.htm</a>) that classes have external linkage. So while building I was expecting a multiple definition error but on the contrary it worked like charm. However when I defined class w in A.cpp, I got the redefinition error which makes me believe that classes have internal linkage.</p>\n<p>Am I missing something here? </p>\n", "AcceptedAnswerId": "6465394", "Title": "Do classes have external linkage?", "CreationDate": "2011-06-24T08:37:09.487", "Id": "6465325", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2011-06-24T08:41:43.503", "LastEditorUserId": "142822", "LastActivityDate": "2015-04-01T02:47:15.500", "Score": "5", "OwnerUserId": "813734", "Tags": "<c++><external><linkage>", "AnswerCount": "5"}});