post_cb({"bq_ids": {"n4140": {"so_26137325_26137910_1": {"length": 6, "quality": 1.0, "section_id": 599}}, "n3337": {"so_26137325_26137910_1": {"length": 6, "quality": 1.0, "section_id": 589}}, "n4659": {"so_26137325_26137910_1": {"length": 6, "quality": 1.0, "section_id": 622}}}, "26138072": {"Id": "26138072", "PostTypeId": "2", "Body": "<p>If <code>Foo(int)</code> is <code>explicit</code>, then this won't compile also:</p>\n<pre><code>Foo foo = 42;\n</code></pre>\n<p>So for \"people who have been used to the form with <code>=</code> for decades\" it won't be a surprise that the form with <code>{}</code> doesn't compile either.</p>\n", "LastActivityDate": "2014-10-01T09:22:05.240", "CommentCount": "2", "CreationDate": "2014-10-01T09:22:05.240", "ParentId": "26137325", "Score": "11", "OwnerUserId": "3959454"}, "26137917": {"Id": "26137917", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26137325_26137917_0\"><strong>widget w = {x};</strong></p>\n<p id=\"so_26137325_26137917_1\">This is called \u201ccopy list initialization.\u201d It means the same as widget w{x}; except that explicit constructors cannot be used. It\u2019s guaranteed that only a single constructor is called.</p>\n</blockquote>\n<p>From <a href=\"http://herbsutter.com/2013/05/09/gotw-1-solution/\">http://herbsutter.com/2013/05/09/gotw-1-solution/</a></p>\n<p>See the rest of the article for a more detailed discussion on the various ways you can initialise an object.</p>\n", "LastActivityDate": "2014-10-01T09:13:30.597", "CommentCount": "0", "CreationDate": "2014-10-01T09:13:30.597", "ParentId": "26137325", "Score": "7", "OwnerUserId": "4098128"}, "26137910": {"Id": "26137910", "PostTypeId": "2", "Body": "<p>I can't explain the rationale behind this, but I can repeat the obvious.</p>\n<blockquote>\n<p id=\"so_26137325_26137910_0\">I found this surprising. Is it really the intention of the C++11\n  standard that this code doesn't compile?</p>\n</blockquote>\n<p>\u00a713.3.1.7</p>\n<blockquote>\n<p id=\"so_26137325_26137910_1\">In copy-list-initialization, if an explicit constructor is chosen, the\n  initialization is ill-formed.</p>\n</blockquote>\n<hr/>\n<blockquote>\n<p id=\"so_26137325_26137910_2\">Removing the = fixes it: <code>Foo foo { 42 };</code> but I personally find this\n  harder to explain to people who have been used to the form with = for\n  decades, and since the standard refers to a\n  \"brace-or-equal-initializer\" it's not obvious why the good old way\n  doesn't work in this scenario.</p>\n</blockquote>\n<p><code>Foo foo { 42 }</code> is <a href=\"http://en.cppreference.com/w/cpp/language/direct_initialization\" rel=\"noreferrer\">direct initialization</a>, whereas the equal sign (with braces) makes it <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"noreferrer\">copy-list-initialization</a>. Another answer reasons that because compilation fails for <a href=\"http://en.cppreference.com/w/cpp/language/copy_initialization\" rel=\"noreferrer\">copy-initialization</a> (equal sign without braces), then it shouldn't be surprising that it also fails for copy-list-initialization, but the two fail for different reasons. </p>\n<p>cppreference:</p>\n<blockquote>\n<p id=\"so_26137325_26137910_3\">Direct-initialization is more permissive than copy-initialization:\n  copy-initialization only considers non-explicit constructors and\n  user-defined conversion functions, while direct-initialization\n  considers all constructors and implicit conversion sequences.</p>\n</blockquote>\n<p>And their page on the <a href=\"http://en.cppreference.com/w/cpp/language/explicit\" rel=\"noreferrer\">explicit specifier</a>:</p>\n<blockquote>\n<p id=\"so_26137325_26137910_4\">Specifies constructors and <sup>(since C++11)</sup> conversion\n  operators that don't allow implicit conversions or\n  copy-initialization.</p>\n</blockquote>\n<p>On the other hand, for copy-list-initialization:</p>\n<blockquote>\n<p id=\"so_26137325_26137910_5\"><em>T object</em> = {<em>arg1</em>, <em>arg2</em>, <em>...</em>};     (10) </p>\n<p id=\"so_26137325_26137910_6\">10) on the right-hand-side of the equals sign (similar to copy-initialization)</p>\n<ul>\n<li><p id=\"so_26137325_26137910_7\">Otherwise, the constructors of T are considered, in two phases: </p>\n<ul>\n<li>If the previous stage does not produce a match, all constructors of T participate in overload resolution against the set of arguments that\n  consists of the elements of the braced-init-list, with the restriction\n  that only non-narrowing conversions are allowed. <strong>If this stage\n  produces an explicit constructor as the best match for a\n  copy-list-initialization, compilation fails (note, in simple\n  copy-initialization, explicit constructors are not considered at all)</strong></li>\n</ul></li>\n</ul>\n</blockquote>\n<p>As discussed in <a href=\"https://stackoverflow.com/questions/9157041/what-could-go-wrong-if-copy-list-initialization-allowed-explicit-constructors\">What could go wrong if copy-list-initialization allowed explicit constructors?</a>, the compilation fails because the explicit constructor is selected but is not allowed to be used.</p>\n", "LastEditorDisplayName": "user3920237", "OwnerDisplayName": "user3920237", "LastActivityDate": "2014-10-01T12:06:52.137", "Score": "12", "CreationDate": "2014-10-01T09:13:12.410", "ParentId": "26137325", "CommentCount": "0", "LastEditDate": "2014-10-01T12:06:52.137"}, "26137325": {"ViewCount": "955", "Body": "<p>In C++11 we can do in-class initialization using a \"brace-or-equal-initializer\" (words from the standard) like this:</p>\n<pre><code>struct Foo\n{\n  /*explicit*/ Foo(int) {}\n};\n\nstruct Bar\n{\n  Foo foo = { 42 };\n};\n</code></pre>\n<p>But if we un-comment <code>explicit</code>, it no longer compiles.  GCC 4.7 and 4.9 say this:</p>\n<pre><code>error: converting to \u2018Foo\u2019 from initializer list would use explicit constructor \u2018Foo::Foo(int)\u2019\n</code></pre>\n<p>I found this surprising.  Is it really the intention of the C++11 standard that this code doesn't compile?</p>\n<p>Removing the <code>=</code> fixes it: <code>Foo foo { 42 };</code> but I personally find this harder to explain to people who have been used to the form with <code>=</code> for decades, and since the standard refers to a \"brace-or-equal-initializer\" it's not obvious why the good old way doesn't work in this scenario.</p>\n", "AcceptedAnswerId": "26137910", "Title": "C++11: in-class initializaton with \"= {}\" doesn't work with explicit constructor", "CreationDate": "2014-10-01T08:37:10.903", "Id": "26137325", "CommentCount": "14", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-10-01T12:06:52.137", "Score": "18", "OwnerUserId": "4323", "Tags": "<c++><c++11><initializer-list><explicit-constructor><in-class-initialization>", "AnswerCount": "3"}});