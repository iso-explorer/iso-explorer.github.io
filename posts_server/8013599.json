post_cb({"bq_ids": {"n4140": {"so_8013599_8014673_3": {"length": 28, "quality": 0.9333333333333333, "section_id": 738}, "so_8013599_8014673_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 1393}, "so_8013599_8014673_1": {"length": 43, "quality": 0.9555555555555556, "section_id": 1394}, "so_8013599_8014548_1": {"length": 15, "quality": 0.9375, "section_id": 3}, "so_8013599_8014673_2": {"length": 19, "quality": 0.95, "section_id": 737}}, "n3337": {"so_8013599_8014673_3": {"length": 28, "quality": 0.9333333333333333, "section_id": 727}, "so_8013599_8014673_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 1387}, "so_8013599_8014548_1": {"length": 15, "quality": 0.9375, "section_id": 2}, "so_8013599_8014673_1": {"length": 43, "quality": 0.9555555555555556, "section_id": 1388}, "so_8013599_8014673_2": {"length": 19, "quality": 0.95, "section_id": 726}}, "n4659": {"so_8013599_8014673_3": {"length": 28, "quality": 0.9333333333333333, "section_id": 796}, "so_8013599_8014673_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 1511}, "so_8013599_8014548_1": {"length": 15, "quality": 0.9375, "section_id": 3}, "so_8013599_8014673_1": {"length": 43, "quality": 0.9555555555555556, "section_id": 1512}, "so_8013599_8014673_2": {"length": 19, "quality": 0.95, "section_id": 795}}}, "8013599": {"ViewCount": "1743", "Body": "<p>I am playing around with the new <code>explicit</code> for cast-operators. If you write something like</p>\n<pre><code>struct Data {\n    explicit operator string(); \n};\n</code></pre>\n<p>It is not possible to accidentally convert <code>Data</code> to <code>string</code>. The darget data type <code>bool</code> is an exception: In certain cases the implicit conversion is allowed even if it is marked <code>explicit</code> -- <em>contextual conversion</em>. So, you can use this data types in an <code>if(...)</code> for example:</p>\n<pre><code>struct Ok {\n    explicit operator bool(); // allowed in if(...) anyway\n};\n</code></pre>\n<p>The paragraph <em>\"25.4.(2) Sorting and related operations\"</em> seems to allow this for the <code>Compare</code> functor of <strong>standard containers</strong> like <code>set</code> as well. But my tries with gcc-4.7.0 fail, and I am note sure if it is my mis-understanding or a bug in gcc?</p>\n<pre><code>#include &lt;set&gt;\n\nstruct YesNo { // Return value type of Comperator\n    int val_;\n    explicit YesNo(int y) : val_{y} {}\n    /* explicit */ operator bool() { return val_!=0; }\n};\n\nstatic const YesNo yes{1};\nstatic const YesNo no{0};\n\nstruct LessYesNo {  // Comperator with special return values\n    YesNo operator()(int a, int b) const {\n        return a&lt;b ? yes : no;\n    }\n};\n\nint main() {\n    std::set&lt;int,LessYesNo&gt; data {2,3,4,1,2};\n}\n</code></pre>\n<p>Without the <code>explicit</code> before <code>operator bool()</code> the example compiles. And my understanding of \"25.4.(2)\" is, that this should also compile <strong>with</strong> the `explicit.</p>\n<p><strong>Did I understand the Std correctly that for <code>set</code> also <code>explicit</code> <code>bool</code> conversions should work?</strong> And might this be a bug in gcc then, or did I understand something wrong?</p>\n", "AcceptedAnswerId": "8014673", "Title": "Implicit conversion to explicit bool-types for sorting containers?", "CreationDate": "2011-11-04T17:44:00.000", "Id": "8013599", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-11-04T20:04:06.983", "Score": "10", "OwnerUserId": "472245", "Tags": "<c++><c++11><boolean><explicit>", "AnswerCount": "2"}, "8014673": {"Id": "8014673", "PostTypeId": "2", "Body": "<p>My reading of the standard is a little different - \nsection 25.4 deals with sorting algorithms rather than for sorted containers; the context established in 25.4.(1) means that the property of the compare object specified in 25.4.(2) applies to the algorithms in 25.4, not to sorted containers</p>\n<blockquote>\n<p id=\"so_8013599_8014673_0\">1 \n  All the operations in 25.4 have two versions: one that takes a\n  function object of type Compare and one that uses an operator.</p>\n<p id=\"so_8013599_8014673_1\">2\n  Compare is a function object type (20.8). The return value of the\n  function call operation applied to an object of type Compare, when\n  contextually converted to bool (4), yields true if the first argument\n  of the call is less than the second, and false otherwise. Compare comp\n  is used throughout for algorithms assuming an ordering relation. It is\n  assumed that comp will not apply any non-constant function through the\n  dereferenced iterator.</p>\n</blockquote>\n<p>I don't know whether your example should work or not, but I don't think section 25.4 is applicable here.</p>\n<p>A quick test with a vector and std::sort works:</p>\n<pre><code>#include &lt;list&gt;\n#include &lt;algorithm&gt;\n\nstruct YesNo { // Return value type of Comperator\n    int val_;\n    explicit YesNo(int y) : val_{y} {}\n    explicit operator bool() { return val_!=0; }\n};\n\nstatic const YesNo yes{1};\nstatic const YesNo no{0};\n\nstruct LessYesNo {  // Comperator with special return values\n    YesNo operator()(int a, int b) const {\n        return a&lt;b ? yes : no;\n    }\n};\n\nint main() {\n    std::vector&lt;int&gt; data {2,3,4,1,2};\n    std::sort(std::begin(data), std::end(data), LessYesNo());\n}\n</code></pre>\n<hr>\n<p>Edit:</p>\n<p>The associative container's Compare parameter is defined in terms of secion 25.4:</p>\n<blockquote>\n<p id=\"so_8013599_8014673_2\">1 Associative containers provide fast retrieval of data based on keys. The library provides four basic kinds of associative containers: set, multiset, map and multimap.</p>\n<p id=\"so_8013599_8014673_3\">2 Each associative container is parameterized on Key and an ordering relation Compare that \n  induces a strict weak ordering (25.4) on elements of Key. In addition, map and multimap associate an arbitrary type T with the Key. The object of type Compare is called the comparison object of a container.</p>\n</blockquote>\n<p>and 23. has no other conditions on the type of Compare as far as I can see, so it does seem reasonable to assume that a type satisfying the constraints of 25.4 are equally applicable.</p>\n</hr>", "LastEditorUserId": "1030301", "LastActivityDate": "2011-11-04T20:04:06.983", "Score": "3", "CreationDate": "2011-11-04T19:22:10.090", "ParentId": "8013599", "CommentCount": "5", "OwnerUserId": "1030301", "LastEditDate": "2011-11-04T20:04:06.983"}, "8014548": {"Id": "8014548", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_8013599_8014548_0\">Did I understand the Std correctly that for set also explicit bool conversions should work?</p>\n</blockquote>\n<p>This is sort of a grey area of the specification. The return value from the comparison function is required to be \"convertible to bool\". But what that means in light of <code>explicit operator bool()</code> is unclear.</p>\n<p>For example, one could write <code>std::set</code>'s comparison usage as this:</p>\n<pre><code>CompFunc functor;\nif(functor(input, currVal))\n  ...\n</code></pre>\n<p>Or, one could do this:</p>\n<pre><code>CompFunc functor;\nbool test = functor(input, currVal);\nif(test)\n  ...\n</code></pre>\n<p>Are both of these technically legal under C++11? No idea. Obviously the second one fails if <code>operator bool()</code> is <code>explicit</code>.</p>\n<p>I looked at the definition of <code>std::shared_ptr</code>, and it has an <code>explicit operator bool()</code> as well. It also says that <code>std::shared_ptr</code> is \"convertible to bool\", in section 20.7.2.2, paragraph 2.</p>\n<p>So I'm guessing that the second version <em>should</em> be implemented as follows:</p>\n<pre><code>CompFunc functor;\nbool test = static_cast&lt;bool&gt;(functor(input, currVal));\nif(test)\n  ...\n</code></pre>\n<p>The fact that it's not explicitly stated anywhere in the spec means that it should be filed as a defect report. But it should probably also be filed as a GCC/libstdc++ bug.</p>\n<p>Personally, to be safe, I wouldn't rely on it.</p>\n<hr>\n<h3>On Contextual Conversion</h3>\n<p>Section 4, paragraph 3 states:</p>\n<blockquote>\n<p id=\"so_8013599_8014548_1\">An expression e appearing in such a context is said to be contextually converted to bool and is well-formed if and only if the declaration bool t(e); is well-formed, for some invented temporary variable t</p>\n</blockquote>\n<p>So operations which are \"contextually convertible to bool\" means that <code>explicit operator bool()</code> will work. Since <code>std::set</code>'s \"Compare\" functor must fall under the requirements of 25.4, and these requirements include \"contextually converted to bool\", it looks like a GCC/libstdc++ bug.</p>\n<p>I'd still avoid doing it when you can help it, though.</p>\n</hr>", "LastEditorUserId": "734069", "LastActivityDate": "2011-11-04T19:45:44.270", "Score": "2", "CreationDate": "2011-11-04T19:11:25.613", "ParentId": "8013599", "CommentCount": "3", "OwnerUserId": "734069", "LastEditDate": "2011-11-04T19:45:44.270"}});