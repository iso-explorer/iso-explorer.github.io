post_cb({"5392074": {"Id": "5392074", "PostTypeId": "2", "Body": "<p>g++ version 4.3.4 accepts this code (see <a href=\"http://ideone.com/UbF97\" rel=\"nofollow\">this link</a>). But g++ version 4.4.0 rejects it.</p>\n", "LastActivityDate": "2011-03-22T13:31:56.420", "CommentCount": "0", "CreationDate": "2011-03-22T13:31:56.420", "ParentId": "5391973", "Score": "2", "OwnerUserId": "428857"}, "bq_ids": {"n4140": {"so_5391973_5392050_0": {"length": 23, "quality": 0.71875, "section_id": 5908}}, "n3337": {"so_5391973_5392050_0": {"length": 23, "quality": 0.71875, "section_id": 5680}}, "n4659": {"so_5391973_5392050_0": {"length": 19, "quality": 0.59375, "section_id": 7390}}}, "5391973": {"ViewCount": "21714", "Body": "<p>I ran into an interesting issue today.  Consider this simple example:</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(const T &amp; a) { /* code */ }\n\n// This would also fail\n// void foo(const int &amp; a) { /* code */ }\n\nclass Bar\n{\npublic:\n   static const int kConst = 1;\n   void func()\n   {\n      foo(kConst);           // This is the important line\n   }\n};\n\nint main()\n{\n   Bar b;\n   b.func();\n}\n</code></pre>\n<p>When compiling I get an error:</p>\n<pre><code>Undefined reference to 'Bar::kConst'\n</code></pre>\n<p>Now, I'm pretty sure that this is because the <code>static const int</code> is not defined anywhere, which is intentional because according to my understanding the compiler should be able to make the replacement at compile-time and not need a definition.  However, since the function takes a <code>const int &amp;</code> parameter, it seems to be not making the substitution, and instead preferring a reference.  I can resolve this issue by making the following change:</p>\n<pre><code>foo(static_cast&lt;int&gt;(kConst));\n</code></pre>\n<p>I believe this is now forcing the compiler to make a temporary int, and then pass a reference to that, which it can successfully do at compile time.</p>\n<p>I was wondering if this was intentional, or am I expecting too much from gcc to be able to handle this case?  Or is this something I shouldn't be doing for some reason?</p>\n", "AcceptedAnswerId": "5392050", "Title": "Undefined reference to static const int", "CreationDate": "2011-03-22T13:24:02.327", "Id": "5391973", "CommentCount": "7", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2011-03-22T13:30:42.490", "LastEditorUserId": "507606", "LastActivityDate": "2017-11-18T22:44:45.363", "Score": "53", "OwnerUserId": "507606", "Tags": "<c++><gcc>", "AnswerCount": "7"}, "46296720": {"Id": "46296720", "PostTypeId": "2", "Body": "<p>Simple trick: use <code>+</code> before the <code>kConst</code> passed down the function. This will prevent the constant from being taken a reference from, and this way the code will not generate a linker request to the constant object, but it will go on with the compiler-time constant value instead.</p>\n", "LastActivityDate": "2017-09-19T09:27:27.850", "CommentCount": "1", "CreationDate": "2017-09-19T09:27:27.850", "ParentId": "5391973", "Score": "1", "OwnerUserId": "657412"}, "47371865": {"Id": "47371865", "PostTypeId": "2", "Body": "<p>You can also replace it by a constexpr member function:</p>\n<pre><code>class Bar\n{\n  static constexpr int kConst() { return 1; };\n};\n</code></pre>\n", "LastActivityDate": "2017-11-18T22:44:45.363", "CommentCount": "0", "CreationDate": "2017-11-18T22:44:45.363", "ParentId": "5391973", "Score": "0", "OwnerUserId": "868331"}, "5392134": {"Id": "5392134", "PostTypeId": "2", "Body": "<p>If you're writing static const variable with initializer inside class declaration it's just like as if you've written </p>\n<pre><code>class Bar\n{\n      enum { kConst = 1 };\n}\n</code></pre>\n<p>and GCC will treat it the same way, meaning that it does not have an address.</p>\n<p>The correct code should be</p>\n<pre><code>class Bar\n{\n      static const int kConst;\n}\nconst int Bar::kConst = 1;\n</code></pre>\n", "LastActivityDate": "2011-03-22T13:36:28.067", "CommentCount": "1", "CreationDate": "2011-03-22T13:36:28.067", "ParentId": "5391973", "Score": "16", "OwnerUserId": "624766"}, "5392050": {"Id": "5392050", "PostTypeId": "2", "Body": "<p>It's intentional, 9.4.2/4 says:</p>\n<blockquote>\n<p id=\"so_5391973_5392050_0\">If a static data member is of const integral or const enumeration type,\n  its declaration in the class\n  definition can specify a\n  constant-initializer which shall be an\n  integral constant expression (5.19) In\n  that case, the member can appear in\n  integral constant expressions. The\n  member shall still be defined in a\n  namespace scope if it is used in the\n  program</p>\n</blockquote>\n<p>When you pass the static data member by const reference, you \"use\" it, 3.2/2:</p>\n<blockquote>\n<p id=\"so_5391973_5392050_1\">An expression is potentially evaluated\n  unless it appears where an integral\n  constant expression is required (see\n  5.19), is the operand of the sizeof operator (5.3.3), or is the operand of\n  the typeid operator and the expression\n  does not designate an lvalue of\n  polymorphic class type (5.2.8). An\n  object or non-overloaded function is\n  used if its name appears in a\n  potentially-evaluated expression.</p>\n</blockquote>\n<p>So in fact, you \"use\" it when you pass it by value too, or in a <code>static_cast</code>. It's just that GCC has let you off the hook in one case but not the other.</p>\n<p>[Edit: gcc is applying the rules from C++0x drafts: \"A variable or non-overloaded function whose name appears as a potentially-evaluated expression is odr-used unless it is an object that satisfies the requirements for appearing in a constant expression (5.19) and the lvalue-to-rvalue conversion (4.1) is immediately applied.\". The static cast performs lvalue-rvalue conversion immediately, so in C++0x it's not \"used\".]</p>\n<p>The practical problem with the const reference is that <code>foo</code> is within its rights to take the address of its argument, and compare it for example with the address of the argument from another call, stored in a global. Since a static data member is a unique object, this means if you call <code>foo(kConst)</code> from two different TUs, then the address of the object passed must be the same in each case. AFAIK GCC can't arrange that unless the object is defined in one (and only one) TU.</p>\n<p>OK, so in this case <code>foo</code> is a template, hence the definition is visible in all TUs, so perhaps the compiler could in theory rule out the risk that it does anything with the address. But in general you certainly shouldn't be taking addresses of or references to non-existent objects ;-)</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2011-03-26T23:38:52.403", "Score": "51", "CreationDate": "2011-03-22T13:30:22.377", "ParentId": "5391973", "CommentCount": "5", "OwnerUserId": "13005", "LastEditDate": "2011-03-26T23:38:52.403"}, "5392048": {"Id": "5392048", "PostTypeId": "2", "Body": "<p>I think this artefact of C++ means that any time that <code>Bar::kConst</code> is referred to, its literal value is used instead.</p>\n<p>This means that in practise there is no variable to make a reference point to.</p>\n<p>You may have to do this:</p>\n<pre><code>void func()\n{\n  int k = kConst;\n  foo(k);\n}\n</code></pre>\n", "LastEditorUserId": "4834", "LastActivityDate": "2015-10-08T19:44:02.880", "Score": "1", "CreationDate": "2011-03-22T13:30:10.857", "ParentId": "5391973", "CommentCount": "1", "OwnerUserId": "4834", "LastEditDate": "2015-10-08T19:44:02.880"}, "27825124": {"Id": "27825124", "PostTypeId": "2", "Body": "<p>This is a really valid case. Especially because <strong>foo</strong> could be a function from the STL like <strong>std::count</strong> which takes a <strong>const T&amp;</strong> as its third argument.</p>\n<p>I spent much time trying to understand why the linker had problems with such a basic code.</p>\n<p>The error message </p>\n<blockquote>\n<p id=\"so_5391973_27825124_0\">Undefined reference to 'Bar::kConst'</p>\n</blockquote>\n<p>tells us that the linker cannot find a symbol.</p>\n<pre><code>$nm -C main.o\n0000000000000000 T main\n0000000000000000 W void foo&lt;int&gt;(int const&amp;)\n0000000000000000 W Bar::func()\n0000000000000000 U Bar::kConst\n</code></pre>\n<p>We can see from the 'U' that Bar::kConst is undefined. Hence, when the linker tries to do its job, it has to find the symbol. But you only <strong>declare</strong> kConst and don't define it.</p>\n<p>The solution in C++ is also to define it as follows:</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(const T &amp; a) { /* code */ }\n\nclass Bar\n{\npublic:\n   static const int kConst = 1;\n   void func()\n   {\n      foo(kConst);           // This is the important line\n   }\n};\n\nconst int Bar::kConst;       // Definition &lt;--FIX\n\nint main()\n{\n   Bar b;\n   b.func();\n}\n</code></pre>\n<p>Then, you can see that the compiler will put the definition in the generated object file:</p>\n<pre><code>$nm -C main.o\n0000000000000000 T main\n0000000000000000 W void foo&lt;int&gt;(int const&amp;)\n0000000000000000 W Bar::func()\n0000000000000000 R Bar::kConst\n</code></pre>\n<p>Now, you can see the 'R' saying that it is defined in the data section.</p>\n", "LastEditorUserId": "3337570", "LastActivityDate": "2015-04-23T13:09:30.903", "Score": "7", "CreationDate": "2015-01-07T17:29:58.500", "ParentId": "5391973", "CommentCount": "4", "OwnerUserId": "3337570", "LastEditDate": "2015-04-23T13:09:30.903"}});