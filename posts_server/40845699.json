post_cb({"41022846": {"ParentId": "40845699", "CommentCount": "3", "Body": "<p>The short answer is that it depends on the types and what does <code>process</code> do instead of <code>get</code>. By itself, <code>get</code> merely retrieve the address of the object and return it as a reference. Retrieving the address is mostly just reading the contents of integers. It does not raise race conditions. Roughly speaking, the code snippet in your question is thread-safe if and only if the following is thread-safe,</p>\n<pre><code>T1 t1;\nT2 t2;\nT3 t3;\n\nstd::thread{[&amp;]{process(t1);}}.detach();\nstd::thread{[&amp;]{process(t2);}}.detach();\nstd::thread{[&amp;]{process(t3);}}.detach();\n</code></pre>\n", "OwnerUserId": "794424", "PostTypeId": "2", "Id": "41022846", "Score": "-1", "CreationDate": "2016-12-07T16:41:42.147", "LastActivityDate": "2016-12-07T16:41:42.147"}, "40915515": {"ParentId": "40845699", "PostTypeId": "2", "CommentCount": "29", "Body": "<p>Since <code>std::get</code> has no explicit statements in the specification about its data race properties, we fall back to the default behavior defined in [res.on.data.races]. Specifically, paragraphs 2 and 3 tell the story:</p>\n<blockquote>\n<p id=\"so_40845699_40915515_0\">A C++ standard library function shall not directly or indirectly access objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s arguments,\n  including <code>this</code>.</p>\n<p id=\"so_40845699_40915515_1\">A C ++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s non-<code>const</code> arguments, including <code>this</code>.</p>\n</blockquote>\n<p>These provide protection from data races only for uses that are not the same object provided by a function's arguments. A template parameter is not technically a function's arguments, so it doesn't qualify.</p>\n<p>Your case involves multiple threads passing the same object to different <code>get</code> calls. Since you are passing a non-<code>const</code> parameter, <code>get</code> will be assumed to be modifying its <code>tuple</code> argument. Therefore, calling <code>get</code> on the same object counts as modifying the object from multiple threads. And therefore, calling it can legally provoke a data race on the <code>tuple</code>.</p>\n<p>Even though, technically speaking, it's just extracting a subobject from the <code>tuple</code> and therefore should not disturb the object itself or its other subobjects. The standard does not know this.</p>\n<p><em>However</em>, if the parameter were <code>const</code>, then <code>get</code> would not be considered to provoke a data race with other <code>const</code> calls to <code>get</code>. These would simply be viewing the same object from multiple threads, which is allowed in the standard library. It would provoke a data race with non-<code>const</code> uses of <code>get</code> or with other non-<code>const</code> uses of the <code>tuple</code> object. But not with <code>const</code> uses of it.</p>\n<p>So you can \"access\" them, but not \"<em>modify</em>\" them.</p>\n", "OwnerUserId": "734069", "LastEditorUserId": "734069", "LastEditDate": "2016-12-01T16:26:49.647", "Id": "40915515", "Score": "8", "CreationDate": "2016-12-01T16:20:51.127", "LastActivityDate": "2016-12-01T16:26:49.647"}, "40845699": {"CommentCount": "10", "AcceptedAnswerId": "40915515", "PostTypeId": "1", "LastEditorUserId": "598696", "CreationDate": "2016-11-28T13:40:07.957", "LastActivityDate": "2016-12-07T16:41:42.147", "LastEditDate": "2016-12-01T17:04:42.353", "ViewCount": "564", "FavoriteCount": "3", "Title": "Is using `std::get<I>` on a `std::tuple` guaranteed to be thread-safe for different values of `I`?", "Id": "40845699", "Score": "27", "Body": "<p>Let's say I have </p>\n<pre><code>std::tuple&lt;T0, T1, T2&gt; my_tuple{x0, x1, x2};\n</code></pre>\n<p>where <code>T0</code>, <code>T1</code> and <code>T2</code> are value types <em>(i.e. no aliasing is possible)</em>.</p>\n<p><strong>Is it safe to access <code>my_tuple</code>'s elements and mutate them concurrently from multiple threads using <code>std::get</code>, as long as every thread accesses a different element?</strong></p>\n<p>Example:</p>\n<pre><code>template &lt;typename T&gt;\nvoid process(T&amp; x) { /* mutate `x` */ }\n\n// ...\n\nstd::thread{[&amp;]{ process(std::get&lt;0&gt;(my_tuple)); }}.detach();\nstd::thread{[&amp;]{ process(std::get&lt;1&gt;(my_tuple)); }}.detach();\nstd::thread{[&amp;]{ process(std::get&lt;2&gt;(my_tuple)); }}.detach();\n</code></pre>\n<p>Instinctively I would say it is safe, as <code>my_tuple</code> can be thought of as <code>struct { T0 x0; T1 x1; T2 x2; };</code>... but is it guaranteed by the standard?</p>\n", "Tags": "<c++><multithreading><c++11><thread-safety><stdtuple>", "OwnerUserId": "598696", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_40845699_40915515_0": {"section_id": 6347, "quality": 0.9523809523809523, "length": 20}, "so_40845699_40915515_1": {"section_id": 6348, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_40845699_40915515_0": {"section_id": 6104, "quality": 0.9523809523809523, "length": 20}, "so_40845699_40915515_1": {"section_id": 6105, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_40845699_40915515_0": {"section_id": 7856, "quality": 0.9523809523809523, "length": 20}, "so_40845699_40915515_1": {"section_id": 7857, "quality": 0.9545454545454546, "length": 21}}}});