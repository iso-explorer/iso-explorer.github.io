post_cb({"45960387": {"CommentCount": "16", "AcceptedAnswerId": "45971285", "PostTypeId": "1", "LastEditorUserId": "1465553", "CreationDate": "2017-08-30T12:25:49.277", "LastActivityDate": "2017-08-31T17:13:07.627", "LastEditDate": "2017-08-30T12:50:16.073", "ViewCount": "3792", "FavoriteCount": "8", "Title": "Why don't compilers merge redundant std::atomic writes?", "Id": "45960387", "Score": "44", "Body": "<p>I'm wondering why no compilers are prepared to merge consecutive writes of the same value to a single atomic variable, e.g.:</p>\n<pre><code>#include &lt;atomic&gt;\nstd::atomic&lt;int&gt; y(0);\nvoid f() {\n  auto order = std::memory_order_relaxed;\n  y.store(1, order);\n  y.store(1, order);\n  y.store(1, order);\n}\n</code></pre>\n<p>Every compiler I've tried will issue the above write three times. What legitimate, race-free observer could see a difference between the above code and an optimized version with a single write (i.e. doesn't the 'as-if' rule apply)?</p>\n<p>If the variable had been volatile, then obviously no optimization is applicable. What's preventing it in my case?</p>\n<p>Here's the code in <a href=\"https://godbolt.org/g/BLoH1x\" rel=\"noreferrer\" title=\"compiler explorer\">compiler explorer</a>.</p>\n", "Tags": "<c++><multithreading><c++11><stdatomic>", "OwnerUserId": "2504674", "AnswerCount": "9"}, "bq_ids": {"n4140": {"so_45960387_45962130_1": {"section_id": 5818, "quality": 1.0, "length": 15}, "so_45960387_45962130_0": {"section_id": 5834, "quality": 0.7142857142857143, "length": 10}}, "n3337": {"so_45960387_45962130_1": {"section_id": 5589, "quality": 1.0, "length": 15}, "so_45960387_45962130_0": {"section_id": 5605, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_45960387_45962130_1": {"section_id": 7279, "quality": 1.0, "length": 15}, "so_45960387_45962130_0": {"section_id": 7296, "quality": 0.7142857142857143, "length": 10}}}, "45962130": {"ParentId": "45960387", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>NB: I was going to comment this but it's a bit too wordy.</p>\n<p>One interesting fact is that this behavior isn't in the terms of C++ a data race.</p>\n<p>Note 21 on p.14 is interesting: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf</a> (my emphasis):</p>\n<blockquote>\n<p id=\"so_45960387_45962130_0\">The execution of a program contains a data race if it contains two\n  conflicting actions in different threads, at least <strong>one of which is\n  not atomic</strong></p>\n</blockquote>\n<p>Also on p.11 note 5 :</p>\n<blockquote>\n<p id=\"so_45960387_45962130_1\">\u201cRelaxed\u201d atomic operations are not synchronization operations even\n  though, like synchronization operations, they cannot contribute to\n  data races.</p>\n</blockquote>\n<p>So a conflicting action on an atomic is never a data race - in terms of the C++ standard.</p>\n<p>These operations are all atomic (and specifically relaxed) but no data race here folks!</p>\n<p>I agree there's no reliable/predictable difference between these two on any (reasonable) platform:</p>\n<pre><code>include &lt;atomic&gt;\nstd::atomic&lt;int&gt; y(0);\nvoid f() {\n  auto order = std::memory_order_relaxed;\n  y.store(1, order);\n  y.store(1, order);\n  y.store(1, order);\n}\n</code></pre>\n<p>and </p>\n<pre><code>include &lt;atomic&gt;\nstd::atomic&lt;int&gt; y(0);\nvoid f() {\n  auto order = std::memory_order_relaxed;\n  y.store(1, order);\n}\n</code></pre>\n<p>But within the definition provided C++ memory model it isn't a data race.</p>\n<p>I can't easily understand why that definition is provided but it does hand the developer a few cards to engage in haphazard communication between threads that they may know (on their platform) will statistically work.</p>\n<p>For example, setting a value 3 times then reading it back will show some degree of contention for that location. Such approaches aren't deterministic but many effective concurrent algorithms aren't deterministic. \nFor example, a timed-out <code>try_lock_until()</code> is always a race condition but remains a useful technique.</p>\n<p>What it appears the C++ Standard is providing you with certainty around 'data races' but permitting certain fun-and-games with race conditions which are on final analysis different things.</p>\n<p>In short the standard appears to specify that where other threads may see the 'hammering' effect of a value being set 3 times, other threads must be able to see that effect (even if they sometimes may not!). \nIt's the case where pretty much all modern platforms that other thread may under some circumstances see the hammering.</p>\n", "OwnerUserId": "4213662", "LastEditorUserId": "4213662", "LastEditDate": "2017-08-30T13:59:48.923", "Id": "45962130", "Score": "5", "CreationDate": "2017-08-30T13:43:32.053", "LastActivityDate": "2017-08-30T13:59:48.923"}, "45970805": {"ParentId": "45960387", "CommentCount": "0", "Body": "<p>The compiler writer cannot just perform the optimisation. They must also convince themselves that the optimisation is valid in the situations where the compiler writer intends to apply it, that it will not be applied in situations where it is not valid, that it doesn't break code that is in fact broken but \"works\" on other implementations. This is probably more work than the optimisation itself. </p>\n<p>On the other hand, I could imagine that in practice (that is in programs that are supposed to do a job, and not benchmarks), this optimisation will save very little in execution time. </p>\n<p>So a compiler writer will look at the cost, then look at the benefit and the risks, and probably will decide against it. </p>\n", "OwnerUserId": "3255455", "PostTypeId": "2", "Id": "45970805", "Score": "0", "CreationDate": "2017-08-30T22:45:15.550", "LastActivityDate": "2017-08-30T22:45:15.550"}, "45961718": {"ParentId": "45960387", "CommentCount": "3", "Body": "<p>While you are changing the value of an atomic in one thread, some other thread may be checking it and performing an operation based on the value of the atomic. The example you gave is so specific that compiler developers don't see it worth optimizing. However, if one thread is setting e.g. consecutive values for an atomic: <code>0</code>, <code>1</code>, <code>2</code>, etc., the other thread may be putting something in the slots indicated by the value of the atomic.</p>\n", "OwnerUserId": "1915854", "PostTypeId": "2", "Id": "45961718", "Score": "10", "CreationDate": "2017-08-30T13:25:01.163", "LastActivityDate": "2017-08-30T13:25:01.163"}, "45961233": {"ParentId": "45960387", "PostTypeId": "2", "CommentCount": "25", "Body": "<p>Since variables contained within an std::atomic object are expected to be accessed from multiple threads, one should expect that they behave, at a minimum, as if they were declared with the volatile keyword.  </p>\n<p>That was the standard and recommended practice before CPU architectures introduced cache lines, etc.</p>\n<p>[EDIT2] One could argue that std::atomic&lt;&gt; are the <code>volatile</code> variables of the multicore age.  As defined in C/C++, <code>volatile</code> is only good enough to synchronize atomic reads from <strong>a single thread</strong>, with an ISR modifying the variable (which in this case is effectively an atomic write as seen from the main thread).</p>\n<p>I personally am relieved that no compiler would optimize away writes to an atomic variable.  If the write is optimized away, how can you guarantee that each of these writes could potentially be seen by readers in other threads?  Don't forget that that is also part of the std::atomic&lt;&gt; contract.</p>\n<p>Consider this piece of code, where the result would be greatly affected by wild optimization by the compiler.</p>\n<pre><code>#include &lt;atomic&gt;\n#include &lt;thread&gt;\n\nstatic const int N{ 1000000 };\nstd::atomic&lt;int&gt; flag{1};\nstd::atomic&lt;bool&gt; do_run { true };\n\nvoid write_1()\n{\n    while (do_run.load())\n    {\n        flag = 1; flag = 1; flag = 1; flag = 1;\n        flag = 1; flag = 1; flag = 1; flag = 1;\n        flag = 1; flag = 1; flag = 1; flag = 1;\n        flag = 1; flag = 1; flag = 1; flag = 1;\n    }\n}\n\nvoid write_0()\n{\n    while (do_run.load())\n    {\n        flag = -1; flag = -1; flag = -1; flag = -1;\n    }\n}\n\n\nint main(int argc, char** argv) \n{\n    int counter{};\n    std::thread t0(&amp;write_0);\n    std::thread t1(&amp;write_1);\n\n    for (int i = 0; i &lt; N; ++i)\n    {\n        counter += flag;\n        std::this_thread::yield();\n    }\n\n    do_run = false;\n\n    t0.join();\n    t1.join();\n\n    return counter;\n}\n</code></pre>\n<p>[EDIT] At first, I was not advancing that the <code>volatile</code> was central to the implementation of atomics, but...</p>\n<p>Since there seemed to be doubts as to whether <code>volatile</code> had anything to do with atomics, I investigated the matter. Here's the atomic implementation from the VS2017 stl.  As I surmised, the volatile keyword is everywhere.</p>\n<pre><code>// from file atomic, line 264...\n\n        // TEMPLATE CLASS _Atomic_impl\ntemplate&lt;unsigned _Bytes&gt;\n    struct _Atomic_impl\n    {   // struct for managing locks around operations on atomic types\n    typedef _Uint1_t _My_int;   // \"1 byte\" means \"no alignment required\"\n\n    constexpr _Atomic_impl() _NOEXCEPT\n        : _My_flag(0)\n        {   // default constructor\n        }\n\n    bool _Is_lock_free() const volatile\n        {   // operations that use locks are not lock-free\n        return (false);\n        }\n\n    void _Store(void *_Tgt, const void *_Src, memory_order _Order) volatile\n        {   // lock and store\n        _Atomic_copy(&amp;_My_flag, _Bytes, _Tgt, _Src, _Order);\n        }\n\n    void _Load(void *_Tgt, const void *_Src,\n        memory_order _Order) const volatile\n        {   // lock and load\n        _Atomic_copy(&amp;_My_flag, _Bytes, _Tgt, _Src, _Order);\n        }\n\n    void _Exchange(void *_Left, void *_Right, memory_order _Order) volatile\n        {   // lock and exchange\n        _Atomic_exchange(&amp;_My_flag, _Bytes, _Left, _Right, _Order);\n        }\n\n    bool _Compare_exchange_weak(\n        void *_Tgt, void *_Exp, const void *_Value,\n        memory_order _Order1, memory_order _Order2) volatile\n        {   // lock and compare/exchange\n        return (_Atomic_compare_exchange_weak(\n            &amp;_My_flag, _Bytes, _Tgt, _Exp, _Value, _Order1, _Order2));\n        }\n\n    bool _Compare_exchange_strong(\n        void *_Tgt, void *_Exp, const void *_Value,\n        memory_order _Order1, memory_order _Order2) volatile\n        {   // lock and compare/exchange\n        return (_Atomic_compare_exchange_strong(\n            &amp;_My_flag, _Bytes, _Tgt, _Exp, _Value, _Order1, _Order2));\n        }\n\nprivate:\n    mutable _Atomic_flag_t _My_flag;\n    };\n</code></pre>\n<p>All of the specializations in the MS stl use volatile on the key functions.  </p>\n<p>Here's the declaration of one of such key function:</p>\n<pre><code> inline int _Atomic_compare_exchange_strong_8(volatile _Uint8_t *_Tgt, _Uint8_t *_Exp, _Uint8_t _Value, memory_order _Order1, memory_order _Order2)\n</code></pre>\n<p>You will notice the required <code>volatile uint8_t*</code> holding the value contained in the std::atomic.  This pattern can be observed throughout the MS std::atomic&lt;&gt; implementation, Here is no reason for the gcc team, nor any other stl provider to have done it differently.</p>\n", "OwnerUserId": "2430669", "LastEditorUserId": "2430669", "LastEditDate": "2017-08-30T15:44:30.160", "Id": "45961233", "Score": "-1", "CreationDate": "2017-08-30T13:02:52.050", "LastActivityDate": "2017-08-30T15:44:30.160"}, "45969796": {"ParentId": "45960387", "CommentCount": "2", "Body": "<p>A practical use case for the pattern, if the thread does something important between updates that does not depend on or modify <code>y</code>, might be: *Thread 2 reads the value of <code>y</code> to check how much progress Thread 1 has made.`</p>\n<p>So, maybe Thread 1 is supposed to load the configuration file as step 1, put its parsed contents into a data structure as step 2, and display the main window as step 3, while Thread 2 is waiting on step 2 to complete so it can perform another task in parallel that depends on the data structure.  (Granted, this example calls for acquire/release semantics, not relaxed ordering.)</p>\n<p>I\u2019m pretty sure a conforming implementation allows Thread 1 not to update <code>y</code> at any intermediate step\u2014while I haven\u2019t pored over the language standard, I would be shocked if it does not support hardware on which another thread polling <code>y</code> might never see the value 2.</p>\n<p>However, that is a hypothetical instance where it might be pessimal to optimize away the status updates.  Maybe a compiler dev will come here and say why that compiler chose not to, but one possible reason is letting you shoot yourself in the foot, or at least stub yourself in the toe.</p>\n", "OwnerUserId": "4474419", "PostTypeId": "2", "Id": "45969796", "Score": "2", "CreationDate": "2017-08-30T21:13:58.637", "LastActivityDate": "2017-08-30T21:13:58.637"}, "45961836": {"ParentId": "45960387", "CommentCount": "18", "Body": "<p>In short, because the standard (for example the paragaraphs around and below 20 in <code>[intro.multithread]</code>) disallows for it.</p>\n<p>There are happens-before guarantees which must be fulfilled, and which among other things rule out reordering or coalescing writes (paragraph 19 even says so explicitly about reordering).</p>\n<p>If your thread writes three values to memory (let's say 1, 2, and 3) one after another, a different thread may read the value. If, for example, your thread is interrupted (or even if it runs concurrently) and another thread <em>also</em> writes to that location, then the observing thread must see the operations in exactly the same order as they happen (either by scheduling or coincidence, or whatever reason). That's a guarantee.  </p>\n<p>How is this possible if you only do half of the writes (or even only a single one)? It isn't.</p>\n<p>What if your thread instead writes out 1 -1 -1 but another one sporadically writes out 2 or 3? What if a third thread observes the location and waits for a particular value that just never appears because it's optimized out?</p>\n<p>It is impossible to provide the guarantees that are given if stores (and loads, too) aren't performed as requested. All of them, and in the same order.</p>\n", "OwnerUserId": "572743", "PostTypeId": "2", "Id": "45961836", "Score": "6", "CreationDate": "2017-08-30T13:30:37.623", "LastActivityDate": "2017-08-30T13:30:37.623"}, "45962462": {"ParentId": "45960387", "CommentCount": "7", "Body": "<p>Let's walk a little further away from the pathological case of the three stores being immediately next to each other.   Let's assume there's some non-trivial work being done between the stores, and that such work does not involve <code>y</code> at all (so that data path analysis can determine that the three stores are in fact redundant, at least within this thread), and does not itself introduce any memory barriers (so that something else doesn't force the stores to be visible to other threads).  Now it is quite possible that other threads have an opportunity to get work done between the stores, and perhaps those other threads manipulate <code>y</code> and that this thread has some reason to need to reset it to 1 (the 2nd store).  If the first two stores were dropped, that would change the behaviour.</p>\n", "OwnerUserId": "1987633", "PostTypeId": "2", "Id": "45962462", "Score": "0", "CreationDate": "2017-08-30T13:57:58.050", "LastActivityDate": "2017-08-30T13:57:58.050"}, "45965154": {"ParentId": "45960387", "CommentCount": "10", "Body": "<p>You are referring to dead-stores elimination.  </p>\n<p>It is not forbidden to eliminate an atomic dead store but it is harder to prove that an atomic store qualifies as such.</p>\n<blockquote>\n<p id=\"so_45960387_45965154_0\">Traditional compiler optimizations, such as dead store elimination, can be performed on atomic operations, even sequentially consistent ones.<br>\n  Optimizers have to be careful to avoid doing so across <em>synchronization</em> points because another thread of execution can observe or modify memory, which means that the traditional optimizations have to consider more intervening instructions than they usually would when considering optimizations to atomic operations.<br>\n<strong>In the case of dead store elimination it isn\u2019t sufficient to prove that an atomic store post-dominates and aliases another to eliminate the other store.</strong></br></br></p>\n<p id=\"so_45960387_45965154_1\"><sup>from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4455.html\" rel=\"noreferrer\">N4455 No Sane Compiler Would Optimize Atomics</a></sup></p>\n</blockquote>\n<p>The problem of atomic DSE, in the general case, is that it involves looking for synchronization points, in my understanding this term means points in the code where there is <em>happen-before</em> relationship between an instruction on a thread A and instruction on <em>another</em> thread B.  </p>\n<p>Consider this code executed by a thread A:</p>\n<pre><code>y.store(1, std::memory_order_seq_cst);\ny.store(2, std::memory_order_seq_cst);\ny.store(3, std::memory_order_seq_cst);\n</code></pre>\n<p>Can it be optimised as <code>y.store(3, std::memory_order_seq_cst)</code>?</p>\n<p>If a thread B is waiting to see <code>y = 2</code> (e.g. with a CAS) it would never observe that if the code gets optimised.  </p>\n<p>However, in my understanding, having B looping and CASsing on <code>y = 2</code> is a data race as there is not a total order between the two threads' instructions.<br>\nAn execution where the A's instructions are executed before the B's loop is observable (i.e. allowed) and thus the compiler can optimise to <code>y.store(3, std::memory_order_seq_cst)</code>.</br></p>\n<p>If threads A and B are synchronized, somehow, between the stores in thread A then the optimisation would not be allowed (a partial order would be induced, possibly leading to B potentially observing <code>y = 2</code>).  </p>\n<p>Proving that there is not such a synchronization is hard as it involves considering a broader scope and taking into account all the quirks of an architecture.</p>\n<p>As for my understanding, due to the relatively small age of the atomic operations and the difficulty in reasoning about memory ordering, visibility and synchronization, compilers don't perform all the possible optimisations on atomics until a more robust framework for detecting and understanding the necessary conditions is built.</p>\n<p>I believe your example is a simplification of the counting thread given above, as it doesn't have any other thread or any synchronization point, for what I can see, I suppose the compiler could have optimised the three stores.</p>\n", "OwnerUserId": "5801661", "PostTypeId": "2", "Id": "45965154", "Score": "42", "CreationDate": "2017-08-30T16:09:16.070", "LastActivityDate": "2017-08-30T16:09:16.070"}, "45971285": {"ParentId": "45960387", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The C++11 / C++14 standards <em>as written</em> do allow the three stores to be folded/coalesced into one store of the final value.  Even in a case like this:</p>\n<pre><code>  y.store(1, order);\n  y.store(2, order);\n  y.store(3, order); // inlining + constant-folding could produce this in real code\n</code></pre>\n<p>The standard does <em>not</em> guarantee that an observer spinning on <code>y</code> (with an atomic load or CAS) will ever see <code>y == 2</code>.  A program that depended on this would have a data race bug, but only the garden-variety bug kind of race, not the C++ Undefined Behaviour kind of data race.  (It's UB only with non-atomic variables).  A program that expects to <em>sometimes</em> see it is not necessarily even buggy. (See below re: progress bars.)</p>\n<p><strong>Any ordering that's possible on the C++ abstract machine can be picked (at compile time) as the ordering that will <em>always</em> happen</strong>.  This is the as-if rule in action.  In this case, it's <em>as if</em>  all three stores happened back-to-back in the global order, with no loads or stores from other threads happening between the <code>y=1</code> and <code>y=3</code>.</p>\n<p>It doesn't depend on the target architecture or hardware; just like <a href=\"http://preshing.com/20120625/memory-ordering-at-compile-time/\" rel=\"noreferrer\">compile-time reordering</a> of relaxed atomic operations are allowed even when targeting strongly-ordered x86.  The compiler doesn't have to preserve anything you might expect from thinking about the hardware you're compiling for, so you need barriers.  The barriers may compile into zero asm instructions.</p>\n<hr>\n<h3>So why don't compilers do this optimization?</h3>\n<p>It's a quality-of-implementation issue, and can change observed performance / behaviour on real hardware.</p>\n<p><strong>The most obvious case where it's a problem is a progress bar</strong>.  Sinking the stores out of a loop (that contains no other atomic operations) and folding them all into one would result in a progress bar staying at 0 and then going to 100% right at the end.</p>\n<p>There's no C++11 <code>std::atomic</code> way to <em>stop</em> them from doing it in cases where you don't want it, so for now compilers simply choose never to coalesce multiple atomic operations into one.  (Coalescing them all into one operation doesn't change their order relative to each other.)</p>\n<p>Compiler-writers have correctly noticed that programmers expect that an atomic store will actually happen to memory every time the source does <code>y.store()</code>.  (See most of the other answers to this question, which claim the stores are required to happen separately because of possible readers waiting to see an intermediate value.)  i.e. It violates the <a href=\"https://en.wikipedia.org/wiki/Principle_of_least_astonishment\" rel=\"noreferrer\">principle of least surprise</a>.</p>\n<p>However, there are cases where it would be very helpful, for example avoiding useless <code>shared_ptr</code> ref count inc/dec in a loop.</p>\n<p>Obviously any reordering or coalescing can't violate any other ordering rules.  For example, <code>num++; num--;</code> would still have to be full barrier to runtime and compile-time reordering, even if it no longer touched the memory at <code>num</code>.</p>\n<hr>\n<p><strong>Discussion is under way to extend the <code>std::atomic</code> API</strong> to give programmers control of such optimizations, at which point compilers will be able to optimize when useful, which can happen even in carefully-written code that isn't intentionally inefficient.  Some examples of useful cases for optimization are mentioned in the following working-group discussion / proposal links:</p>\n<ul>\n<li><a href=\"http://wg21.link/n4455\" rel=\"noreferrer\">http://wg21.link/n4455</a>: N4455 No Sane Compiler Would Optimize Atomics</li>\n<li><a href=\"http://wg21.link/p0062\" rel=\"noreferrer\">http://wg21.link/p0062</a>: WG21/P0062R1: When should compilers optimize atomics?</li>\n</ul>\n<p>See also discussion about this same topic on Richard Hodges' answer to <a href=\"https://stackoverflow.com/a/39394173/224132\">Can num++ be atomic for 'int num'?</a> (see the comments).  See also the last section of <a href=\"https://stackoverflow.com/a/39396999/224132\">my answer</a> to the same question, where I argue in more detail that this optimization is allowed.  (Leaving it short here, because those C++ working-group links already acknowledge that the current standard as written does allow it, and that current compilers just don't optimize on purpose.)</p>\n<hr>\n<p>Within the current standard, <strong><code>volatile atomic&lt;int&gt; y</code></strong> would be one way to ensure that stores to it are not allowed to be optimized away.  (As <a href=\"https://stackoverflow.com/a/2479474/224132\">Herb Sutter points out in an SO answer</a>, <code>volatile</code> and <code>atomic</code> already share some requirements, but they are different).  See also <a href=\"http://en.cppreference.com/w/cpp/atomic/memory_order#Relationship_with_volatile\" rel=\"noreferrer\"><code>std::memory_order</code>'s relationship with <code>volatile</code></a> on cppreference.</p>\n<p>Accesses to <code>volatile</code> objects are not allowed to be optimized away (because they could be memory-mapped IO registers, for example).</p>\n<p>Don't change all your <code>atomic</code> variables to <code>volatile atomic</code> yet; the standards committee might pick something else (since <code>volatile atomic</code> is ugly, and abuses the meaning of <code>volatile</code>).  I think we can be confident that compilers won't start doing this optimization until there's a way to control it.  Hopefully it will be some kind of opt-in (like a <code>memory_order_release_coalesce</code>) that doesn't change the behaviour of existing code C++11/14 code when compiled as C++whatever.  But it could be like the proposal in wg21/p0062, to tag don't-optimize cases with <code>[[brittle_atomic]]</code>.</p>\n<p><strong>wg21/p0062 warns that even <code>volatile atomic</code> doesn't solve everything, and discourages its use for this purpose</strong>.  It gives this example:</p>\n<pre><code>if(x) {\n    foo();\n    y.store(0);\n} else {\n    bar();\n    y.store(0);  // release a lock before a long-running loop\n    for() {...} // loop contains no atomics or volatiles\n}\n// A compiler can merge the stores into a y.store(0) here.\n</code></pre>\n<p>Even with <code>volatile atomic&lt;int&gt; y</code>, a compiler is allowed to sink the <code>y.store()</code> out of the <code>if/else</code> and just do it once, because it's still doing exactly 1 store with the same value.  (Which would be after the long loop in the else branch).</p>\n<p><code>volatile</code> does stop the coalescing discussed in the question, but this points out that other optimizations on <code>atomic&lt;&gt;</code> can also be problematic for real performance.</p>\n<hr>\n<p>Other reasons for not optimizing include: nobody's written the complicated code that would allow the compiler to do these optimizations safely (without ever getting it wrong).  This is not sufficient, because N4455 says LLVM already implements or could easily implement several of the optimizations it mentioned.</p>\n<p>The confusing-for-programmers reason is certainly plausible, though.  Lock-free code is hard enough to write correctly in the first place.</p>\n<p>Don't be casual in your use of atomic weapons: they aren't cheap and don't optimize much (currently not at all). It's not always easy easy to avoid redundant atomic operations with <code>std::shared_ptr&lt;T&gt;</code>, though, since there's no non-atomic version of it (although <a href=\"https://stackoverflow.com/questions/15129263/is-there-a-non-atomic-equivalent-of-stdshared-ptr-and-why-isnt-there-one-in\">one of the answers here</a> gives an easy way to define a <code>shared_ptr_unsynchronized&lt;T&gt;</code> for gcc).</p>\n</hr></hr></hr></hr>", "OwnerUserId": "224132", "LastEditorUserId": "224132", "LastEditDate": "2017-08-31T17:13:07.627", "Id": "45971285", "Score": "33", "CreationDate": "2017-08-30T23:50:38.327", "LastActivityDate": "2017-08-31T17:13:07.627"}});