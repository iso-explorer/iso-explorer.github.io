post_cb({"bq_ids": {"n4140": {"so_29841973_29841973_1": {"length": 7, "quality": 0.7, "section_id": 5873}, "so_29841973_29841973_0": {"length": 47, "quality": 0.9038461538461539, "section_id": 5873}}, "n3337": {"so_29841973_29841973_1": {"length": 7, "quality": 0.7, "section_id": 5644}, "so_29841973_29841973_0": {"length": 47, "quality": 0.9038461538461539, "section_id": 5644}}, "n4659": {"so_29841973_29841973_1": {"length": 7, "quality": 0.7, "section_id": 7356}, "so_29841973_29841973_0": {"length": 47, "quality": 0.9038461538461539, "section_id": 7356}}}, "29842188": {"Id": "29842188", "PostTypeId": "2", "Body": "<p>By <em>unspecified</em> means the compiler is:</p>\n<ul>\n<li>free to make any decision it likes </li>\n<li>and is <strong>not</strong> required to document it. </li>\n</ul>\n<p><em>And implementation-defined means, the compiler is free to make any decision, and is required to document it.</em>.</p>\n<hr>\n<p>If you consider this class <em>(slightly modified your version)</em>:</p>\n<pre><code>class X {\nprivate:\n    int b;\n    int z;\n\npublic:\n    char c;\n    int a;\n\nprivate:\n    char e;\n\npublic:\n    int d;\n};\n</code></pre>\n<p>then the text from the spec means:</p>\n<ul>\n<li>It is guaranteed that\n<ul>\n<li><code>&amp;c &lt; &amp;a</code> \u2014 both belong to same access control.</li>\n<li><code>&amp;b &lt; &amp;z</code> \u2014 both belong to same access control.</li>\n</ul></li>\n<li>It is also guaranteed that\n<ul>\n<li><code>&amp;z &lt; &amp;e</code> \u2014 both belong to same access control, with interleaving.</li>\n<li><code>&amp;a &lt; &amp;d</code> \u2014 both belong to same access control, with interleaving.</li>\n</ul></li>\n<li>It is <strong>not</strong> guaranteed that:\n<ul>\n<li><code>&amp;z &lt; &amp;c</code> \u2014 both belong to different access control.</li>\n<li><code>&amp;a &lt; &amp;e</code> \u2014 both belong to different access control.</li>\n</ul></li>\n</ul>\n<p>I've seen code which uses access specifier for each variable, so that the compiler can re-arrange them in order to make the size as smaller as possible.</p>\n</hr>", "LastEditorUserId": "415784", "LastActivityDate": "2015-04-24T08:44:27.400", "Score": "3", "CreationDate": "2015-04-24T08:19:05.520", "ParentId": "29841973", "CommentCount": "12", "OwnerUserId": "415784", "LastEditDate": "2015-04-24T08:44:27.400"}, "29841973": {"ViewCount": "214", "Body": "<p><strong>This is not a duplicate of this</strong> <a href=\"https://stackoverflow.com/questions/25479373/how-memory-is-allocated-for-private-and-public-members-of-the-class\">question</a>,\nI read the answers and I still have some questions about this subject.</p>\n<p>I tested some classes like this one:</p>\n<pre><code>class A {\nprivate:\n    int b;\n\npublic:\n    char c;\n    int a;\n\nprivate:\n    char e;\n};\n</code></pre>\n<p>And I've seen that the fields are stored as if there were no access-specifier,\nthis is not wrong since :</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf\" rel=\"nofollow noreferrer\">N3376</a> (the first post C++11 draft) 9.2 [class.mem]/13:</p>\n<blockquote>\n<p id=\"so_29841973_29841973_0\">Nonstatic data members of a (non-union) class <strong>with the same access control</strong> (Clause 11) are allocated so that later members have higher addresses within a class object. The order of allocation of non-static data members with di\ufb00erent access control is unspeci\ufb01ed. Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other; so might requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).</p>\n</blockquote>\n<p>What I still don't understand is this :</p>\n<blockquote>\n<p id=\"so_29841973_29841973_1\"><strong>The order of allocation of non-static data members with di\ufb00erent access control is unspeci\ufb01ed.</strong></p>\n</blockquote>\n<p>What do they mean by unspecified, GCC certainly have a way of doing this, they don't just do it randomly I guess... They don't want the user to know it ?\nOr there is so many ways depending on the options maybe ?</p>\n<p>Because all the examples I tried, I had the same order as declared in my file (+ padding)</p>\n<p><strong>I am using gcc 4.9.2, Does anyone know if GCC specified their way of doing this ?</strong></p>\n<p>I need to know this because I am creating a program that calculates the padding between all fields, the program works with structures that have no access specifiers for the moment. I will have to find a way to do this when there is different accessibility blocks</p>\n", "AcceptedAnswerId": "29842188", "Title": "Memory allocation for public and private fields - GCC way", "CreationDate": "2015-04-24T08:06:56.630", "Id": "29841973", "CommentCount": "6", "LastEditDate": "2017-05-23T10:24:06.550", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-04-24T08:50:12.597", "Score": "5", "OwnerUserId": "3883676", "Tags": "<c++><c++11><gcc><g++><memory-alignment>", "AnswerCount": "1"}});