post_cb({"32204901": {"CommentCount": "3", "AcceptedAnswerId": "32205061", "PostTypeId": "1", "LastEditorUserId": "2508150", "CreationDate": "2015-08-25T13:08:54.100", "LastActivityDate": "2015-08-25T13:48:55.313", "LastEditDate": "2015-08-25T13:18:48.450", "ViewCount": "242", "FavoriteCount": "2", "Title": "Understanding std::forward", "Id": "32204901", "Score": "8", "Body": "<p>Why the compiler is not able to deduce the template parameter for <code>std::forward</code>?</p>\n<p>I mean:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nstruct X{};\n\nstruct A{\n    A( const X&amp; ) { std::cout &lt;&lt; \"cpy ctor\\n\"; }\n    A( X&amp;&amp; ) { std::cout &lt;&lt; \"move ctor\\n\"; }\n};\n\nX foo() { return {}; }\n\ntemplate&lt;typename T,typename Arg&gt;\nT* factory( Arg&amp;&amp; a )\n{\n    return new T(std::forward(a));\n    // ----------^^^^^^^^^^^^^^^ error: can't deduce template parameter\n}\n\nint main()\n{\n    factory&lt;A&gt;(foo());\n}\n</code></pre>\n<p>I know this is a design choice (due to the <code>std::remove_reference</code> in the definition of <code>std::forward</code>) to avoid the user forget to specify the type. What I can't get is: why the way it's implemented works to prevent deduction? Why the compiler is not just deducing <code>forward</code>'s template parameter as <code>Arg</code>.</p>\n", "Tags": "<c++><c++11><perfect-forwarding>", "OwnerUserId": "2508150", "AnswerCount": "3"}, "32205061": {"ParentId": "32204901", "CommentCount": "2", "Body": "<p><code>std::forward</code> is declared like so:</p>\n<pre><code>template&lt; class T &gt;\nT&amp;&amp; forward( typename std::remove_reference&lt;T&gt;::type&amp; t );\n</code></pre>\n<p><code>typename std::remove_reference&lt;T&gt;::type</code> is a <em>non-deduced context</em>. The compiler has no way of knowing which <code>T</code> should be deduced because it doesn't understand the semantic connection between the <code>type</code> member type and a given <code>T</code>. It would need to search through all types to find a match and be able to somehow disambiguate collisions. This is unreasonable, so the standard doesn't allow it.</p>\n", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "32205061", "Score": "12", "CreationDate": "2015-08-25T13:16:09.077", "LastActivityDate": "2015-08-25T13:16:09.077"}, "32205820": {"ParentId": "32204901", "CommentCount": "0", "Body": "<p>From C++11 standard:</p>\n<blockquote>\n<p id=\"so_32204901_32205820_0\">14.8.2.5 Deducing template arguments from a type </p>\n<p id=\"so_32204901_32205820_1\">The non-deduced contexts are:  </p>\n<p id=\"so_32204901_32205820_2\">\u2014 The nested-name-specifier of a type that was specified using a qualified-id</p>\n<p id=\"so_32204901_32205820_3\">\u2014 The expression of a decltype-specifier. </p>\n<p id=\"so_32204901_32205820_4\">\u2014 A non-type template argument or an array bound in which a\n  subexpression references a template parameter. </p>\n<p id=\"so_32204901_32205820_5\">\u2014 A template parameter used in the parameter type of a function\n  parameter that has a default argument that is being used in the call\n  for which argument deduction is being done.</p>\n<p id=\"so_32204901_32205820_6\">etc...</p>\n</blockquote>\n<p><code>std::forward</code> is declared like this:</p>\n<p><code>template&lt;typename _Tp&gt; \n constexpr _Tp&amp;&amp; forward(typename std::remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept</code></p>\n<p>According to first sentence above:\n<code>typename std::remove_reference&lt;_Tp&gt;::type</code> is non deduced context.</p>\n", "OwnerUserId": "4712648", "PostTypeId": "2", "Id": "32205820", "Score": "0", "CreationDate": "2015-08-25T13:48:55.313", "LastActivityDate": "2015-08-25T13:48:55.313"}, "bq_ids": {"n4140": {"so_32204901_32205820_2": {"section_id": 336, "quality": 0.8571428571428571, "length": 6}, "so_32204901_32205820_5": {"section_id": 336, "quality": 1.0, "length": 14}, "so_32204901_32205820_4": {"section_id": 336, "quality": 1.0, "length": 9}}, "n3337": {"so_32204901_32205820_2": {"section_id": 326, "quality": 0.8571428571428571, "length": 6}, "so_32204901_32205820_5": {"section_id": 326, "quality": 1.0, "length": 14}, "so_32204901_32205820_4": {"section_id": 326, "quality": 1.0, "length": 9}}, "n4659": {"so_32204901_32205820_2": {"section_id": 345, "quality": 0.8571428571428571, "length": 6}, "so_32204901_32205820_5": {"section_id": 345, "quality": 1.0, "length": 14}, "so_32204901_32205820_4": {"section_id": 345, "quality": 1.0, "length": 9}}}, "32205125": {"ParentId": "32204901", "CommentCount": "2", "Body": "<p>The reason you have to specify a type for <code>forward</code>, by design, is what happens to <code>a</code> inside the function:</p>\n<pre><code>template&lt;typename T,typename Arg&gt;\nT* factory( Arg&amp;&amp; a )\n{\n    // 'a' is always an lvalue here\n</code></pre>\n<p>Since <code>a</code> is <em>always</em> an lvalue, there isn't enough information in <code>a</code> itself to be able to determine if it was passed in as an lvalue or rvalue. <em>That</em> information is only available via the type <code>Arg</code>, which will be either <code>X</code> or <code>X&amp;</code>. Without that extra type information, it's impossible to know whether or now <code>a</code> must be forwarded as an lvalue or rvalue... which is why you need to provide it:</p>\n<pre><code>    return new T(std::forward&lt;Arg&gt;(a));\n}\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "32205125", "Score": "6", "CreationDate": "2015-08-25T13:18:53.507", "LastActivityDate": "2015-08-25T13:18:53.507"}});