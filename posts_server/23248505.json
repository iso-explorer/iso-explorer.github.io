post_cb({"23251455": {"ParentId": "23248505", "CommentCount": "0", "Body": "<p>I can't say for sure what was in the committee's minds when they added that restriction to the definition of aggregates. I suspect that it's because they considered that requiring the compiler to also have to set up an instance for virtual function calls (vtable or other) would be sufficiently different from simply initializing values and so added the restriction to simplify the requirements on language implementors.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "23251455", "Score": "1", "CreationDate": "2014-04-23T17:36:08.400", "LastActivityDate": "2014-04-23T17:36:08.400"}, "23248505": {"CommentCount": "15", "ViewCount": "216", "CreationDate": "2014-04-23T15:13:36.113", "LastActivityDate": "2014-04-24T04:20:12.647", "Title": "C++ aggregates have no virtual functions?", "FavoriteCount": "4", "PostTypeId": "1", "Id": "23248505", "Score": "5", "Body": "<p>In C++, an aggregate is (taken from 8.5.1p1 of the language spec)</p>\n<blockquote>\n<p id=\"so_23248505_23248505_0\">an array or a class (Clause 9) with no user-provided constructors (12.1), no private or\n  protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>So, <code>#1</code> is not an aggregate, but <code>#2</code> is an aggregate. Why is <code>#1</code> not an aggregate aswell?</p>\n<pre><code>struct A { virtual void bark() { } int a; }; // #1\nstruct B { A b; }; // #2\n</code></pre>\n", "Tags": "<c++><aggregate>", "OwnerUserId": "34509", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23248505_23248505_0": {"section_id": 3298, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_23248505_23248505_0": {"section_id": 3168, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_23248505_23248505_0": {"section_id": 4063, "quality": 0.6666666666666666, "length": 12}}}, "23249967": {"ParentId": "23248505", "PostTypeId": "2", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_23248505_23249967_0\">Why is #1 not an aggregate aswell?</p>\n</blockquote>\n<p>Because the standard definition of aggregates says that it isn't. The definition says that the class cannot have virtual functions if it is to be considered an aggregate type. That's it. That's the \"captain obvious\" answer.</p>\n<p>Since you quoted the standard definition (and read it, I presume), you know this already, so I must assume that what you are asking is whether there is any fundamental reason why a class with virtual functions cannot be an aggregate type.</p>\n<p>Obviously, a class with virtual functions must have it's virtual table pointer (or other mechanism) initialized as part of the compiler-generated constructor. And the only thing that aggregates really provide (in addition to serving as a base definition for PODs and the like) is the ability to do a curly-braced initialization of its data members. I don't see any reason why the compiler could not simply permit the curly-braced initialization syntax while doing the initialization of the virtual table pointer too.</p>\n<p>As far as <code>B</code> is concerned, it can be an aggregate because the brace-initialization is possible as long as there is a way to construct the data members from whatever is provided (or not provided) in the initialization list, i.e., it needs each data members to have some (compiler-generated or not) default, copy or move constructor. Remember, the definition of aggregates is <em>shallow</em> as opposed to <em>recursive</em> like the POD definitions (trivial, std-layout), meaning that only the top-level class has those restrictions, not its sub-objects.</p>\n<p>The definition of aggregates is obviously very reminiscent of the C struct restrictions, and the brace-initialization for structs is obviously also a feature carried over from C. I believe that for historical reasons, the definition of aggregates was built such that it reflects C structs, and not for reasons of what is or isn't possible for the compiler to do. </p>\n<p>I would certainly be of the opinion that there is no good reason for the restriction on aggregates to not have virtual functions. Maybe a proposal should be made to the standard committee to remove this restriction (as it wouldn't break any existing code). Especially now, with unified initialization syntax, aggregates are nothing more than classes where the compiler can generate a constructor with all the data members as parameters (with default values being default-constructed objects). The only other purpose for aggregates is to lump a few of the restrictions that apply to POD classes (trivial, standard-layout, etc.), for which the restriction on not having virtual functions is justified (AFAIK), but that is just a matter of moving that restriction over to PODs.</p>\n", "OwnerUserId": "491645", "LastEditorUserId": "491645", "LastEditDate": "2014-04-23T16:36:56.890", "Id": "23249967", "Score": "5", "CreationDate": "2014-04-23T16:15:23.180", "LastActivityDate": "2014-04-23T16:36:56.890"}});