post_cb({"11685037": {"ParentId": "11684954", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It is explicitly forbidden for classes and aliases. n3290 \u00a7 14.1.11 states:</p>\n<blockquote>\n<p id=\"so_11684954_11685037_0\">If a template-parameter of a class template or alias template has a default template-argument, each subsequent\n  template-parameter shall either have a default template-argument supplied or be a template parameter\n  pack</p>\n</blockquote>\n<p>For functions the only restriction seems to be related to parameter packs:</p>\n<blockquote>\n<p id=\"so_11684954_11685037_1\">A template parameter pack of a function template shall not be\n  followed by another template parameter unless that template parameter can be deduced or has a default\n  argument</p>\n</blockquote>\n<p>But clearly that doesn't concern this case.</p>\n<p>Given that nothing in \u00a7 14 forbids it for functions it seems we have to assume it is permitted.</p>\n<p>A <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#226\" rel=\"noreferrer\">note from a working group reports</a> seems to confirm that this is the intention. The original proposed wording of that section is:</p>\n<blockquote>\n<p id=\"so_11684954_11685037_2\">If a template-parameter of a class template has a default template-argument, all subsequent template-parameters shall have a default template-argument supplied. [Note: <strong>This is not a requirement for function templates because template arguments might be deduced</strong> (14.8.2 [temp.deduct]).] </p>\n</blockquote>\n<p>I can't see where that note went in the final version though.</p>\n", "OwnerUserId": "168175", "LastEditorUserId": "168175", "LastEditDate": "2012-07-27T10:02:14.450", "Id": "11685037", "Score": "11", "CreationDate": "2012-07-27T09:27:19.507", "LastActivityDate": "2012-07-27T10:02:14.450"}, "11684954": {"CommentCount": "5", "CreationDate": "2012-07-27T09:21:44.517", "PostTypeId": "1", "AcceptedAnswerId": "11685037", "LastEditorUserId": "476681", "LastActivityDate": "2012-07-27T10:02:30.017", "LastEditDate": "2012-07-27T10:02:30.017", "ViewCount": "648", "FavoriteCount": "1", "Title": "Can function default template parameter be put before non-default ones?", "Id": "11684954", "Score": "10", "Body": "<p>The following piece of code does compile on gcc-4.7.1:</p>\n<pre><code>struct X {};\n\ntemplate &lt;class T = X, typename U&gt;\nvoid f(const U&amp; m) {\n}\n\n\nint main() {\n    f&lt;&gt;(0);\n}\n</code></pre>\n<p>However, this one doesn't:</p>\n<pre><code>struct X {};\n\ntemplate &lt;class T = X, typename U&gt;\nvoid f(const U&amp; m) {\n    auto g = [] () {};\n}\n\n\nint main() {\n    f&lt;&gt;(0);\n}\n</code></pre>\n<p>gcc-4.7.1 complains:</p>\n<pre><code>c.cpp: In function 'void f(const U&amp;)':\nc.cpp:5:15: error: no default argument for 'U'\n</code></pre>\n<p>So my question is:  is putting default parameters before non-default parameters correct in function template?  If yes, why doesn't the second one compile?  If no, why does the first one compile?  How does C++11 standard say about this syntax?</p>\n", "Tags": "<c++><templates><c++11>", "OwnerUserId": "875044", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_11684954_11685037_0": {"section_id": 64, "quality": 1.0, "length": 18}, "so_11684954_11685037_1": {"section_id": 64, "quality": 1.0, "length": 15}, "so_11684954_11685037_2": {"section_id": 64, "quality": 0.5416666666666666, "length": 13}}, "n3337": {"so_11684954_11685037_0": {"section_id": 59, "quality": 1.0, "length": 18}, "so_11684954_11685037_1": {"section_id": 59, "quality": 1.0, "length": 15}, "so_11684954_11685037_2": {"section_id": 59, "quality": 0.5416666666666666, "length": 13}}, "n4659": {"so_11684954_11685037_0": {"section_id": 66, "quality": 1.0, "length": 18}, "so_11684954_11685037_1": {"section_id": 66, "quality": 1.0, "length": 15}, "so_11684954_11685037_2": {"section_id": 66, "quality": 0.5416666666666666, "length": 13}}}});