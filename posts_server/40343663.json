post_cb({"40350274": {"ParentId": "40343663", "CommentCount": "1", "Body": "<p>Let's take the most interesting case,</p>\n<pre><code>bar(\"abc\", foo);\n</code></pre>\n<p>The primary question to figure out is, which overload of <code>bar</code> to use.  As always, we first get a set of overloads by name lookup, then do template type deduction for each function template in the overload set, then do overload resolution.</p>\n<p>The really interesting part here is the template type deduction for the declaration</p>\n<pre><code>template&lt;class T&gt; void bar(T* x, void (*f)(T*)) {}\n</code></pre>\n<p>The Standard has this to say in 14.8.2.1/6:</p>\n<blockquote>\n<p id=\"so_40343663_40350274_0\">When <code>P</code> is a function type, pointer to function type, or pointer to member function type:</p>\n<ul>\n<li><p id=\"so_40343663_40350274_1\">If the argument is an overload set containing one or more function templates, the parameter is treated as a non-deduced context.</p></li>\n<li><p id=\"so_40343663_40350274_2\">If the argument is an overload set (not containing function templates), trial argument deduction is attempted using each of the members of the set.  If deduction succeeds for only one of the overload set members, that member is used as the argument value for the deduction.  If deduction succeeds for more than one member of the overload set the parameter is treated as a non-deduced context.</p></li>\n</ul>\n</blockquote>\n<p>(<code>P</code> has already been defined as the function template's function parameter type including template parameters, so here <code>P</code> is <code>void (*)(T*)</code>.)</p>\n<p>So since <code>foo</code> is an overload set containing a function template, <code>foo</code> and <code>void (*f)(T*)</code> don't play a role in template type deduction.  That leaves parameter <code>T* x</code> and argument <code>\"abc\"</code> with type <code>const char[4]</code>.  <code>T*</code> not being a reference, the array type decays to a pointer type <code>const char*</code> and we find that <code>T</code> is <code>const char</code>.</p>\n<p>Now we have overload resolution with these candidates:</p>\n<pre><code>void bar(int x, void (*f)(int)) {}                             // (1)\nvoid bar(double x, void (*f)(double)) {}                       // (2)\nvoid bar(std::string x, void (*f)(std::string)) {}             // (3)\nvoid bar&lt;const char&gt;(const char* x, void (*f)(const char*)) {} // (4)\nvoid bar(A x, void (*f2)(double)) {}                           // (5)\n</code></pre>\n<p>Time to find out which of these are viable functions.  (1), (2), and (5) are not viable because there is no conversion from <code>const char[4]</code> to <code>int</code>, <code>double</code>, or <code>A</code>.  For (3) and (4) we need to figure out if <code>foo</code> is a valid second argument.  In Standard section 13.4/1-6:</p>\n<blockquote>\n<p id=\"so_40343663_40350274_3\">A use of an overloaded function name without arguments is resolved in certain contexts to a function, a pointer to function or a pointer to member function for a specific function from the overload set.  A function template name is considered to name a set of overloaded functions in such contexts.  The function selected is the one whose type is identical to the function type of the target type required in the context.  The target can be</p>\n<ul>\n<li>...</li>\n<li>a parameter of a function (5.2.2),</li>\n<li>...</li>\n</ul>\n<p id=\"so_40343663_40350274_4\">... If the name is a function template, template argument deduction is done (14.8.2.2), and if the argument deduction succeeds, the resulting template argument list is used to generate a single function template specialization, which is added to the set of overloaded functions considered. ...</p>\n<p id=\"so_40343663_40350274_5\">[<em>Note:</em> If <code>f()</code> and <code>g()</code> are both overloaded functions, the cross product of possibilities must be considered to resolve <code>f(&amp;g)</code>, or the equivalent expression <code>f(g)</code>. - <em>end note</em>]</p>\n</blockquote>\n<p>For overload (3) of <code>bar</code>, we first attempt type deduction for</p>\n<pre><code>template&lt;class T&gt; void foo(T* ) {}\n</code></pre>\n<p>with target type <code>void (*)(std::string)</code>.  This fails since <code>std::string</code> cannot match <code>T*</code>.  But we find one overload of <code>foo</code> which has the exact type <code>void (std::string)</code>, so it wins for the overload (3) case, and overload (3) is viable.</p>\n<p>For overload (4) of <code>bar</code>, we first attempt type deduction for the same function template <code>foo</code>, this time with target type <code>void (*)(const char*)</code>  This time type deduction succeeds, with <code>T</code> = <code>const char</code>.  None of the other overloads of <code>foo</code> have the exact type <code>void (const char*)</code>, so the function template specialization is used, and overload (4) is viable.</p>\n<p>Finally, we compare overloads (3) and (4) by ordinary overload resolution.    In both cases, the conversion of argument <code>foo</code> to a pointer to function is an Exact Match, so neither implicit conversion sequence is better than the other.  But the standard conversion from <code>const char[4]</code> to <code>const char*</code> is better than the user-defined conversion sequence from <code>const char[4]</code> to <code>std::string</code>.  So overload (4) of <code>bar</code> is the best viable function (and it uses <code>void foo&lt;const char&gt;(const char*)</code> as its argument).</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "40350274", "Score": "8", "CreationDate": "2016-10-31T20:43:05.220", "LastActivityDate": "2016-10-31T20:43:05.220"}, "40343663": {"CommentCount": "0", "AcceptedAnswerId": "40350274", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-10-31T13:56:26.447", "LastActivityDate": "2016-11-01T09:11:49.177", "LastEditDate": "2017-05-23T11:48:19.090", "ViewCount": "140", "FavoriteCount": "1", "Title": "How does overload resolution work when an argument is an overloaded function?", "Id": "40343663", "Score": "7", "Body": "<h3>Preamble</h3>\n<p>Overload resolution in C++ can be an overly complex process. It takes quite a lot of mental effort to understand all of the C++ rules that govern overload resolution. Recently it occurred to me that the presence of the name of an overloaded function in the argument list can add to the complexity of overload resolution. Since it happened to be a widely used case, I posted <a href=\"https://stackoverflow.com/questions/40322128/how-does-stdcout-stdendl-compile\">a question</a> and received an answer that allowed me to better understand the mechanics of that process. However, the formulation of that question in the context of iostreams seems to have somewhat distracted the focus of the answers from the very essence of the problem being addressed. So I started delving deeper and came up with other examples that ask for more elaborate analysis of the issue. This question is an introductory one and is followed by a <a href=\"https://stackoverflow.com/questions/40356990/how-does-template-argument-deduction-work-when-an-overloaded-function-is-involve\">more sophisticated one</a>.</p>\n<h3>Question</h3>\n<p>Assume that one fully understands how overload resolution works in the absence of arguments that are themselves names of overloaded functions. What amendments must be made to their understanding of overload resolution, so that it also covers cases where overloaded functions are used as arguments?</p>\n<h3>Examples</h3>\n<p>Given these declarations:</p>\n<pre><code>void foo(int) {}\nvoid foo(double) {}\nvoid foo(std::string) {}\ntemplate&lt;class T&gt; void foo(T* ) {}\n\nstruct A {\n    A(void (*)(int)) {}\n};\n\nvoid bar(int x, void (*f)(int)) {}\nvoid bar(double x, void (*f)(double)) {}\nvoid bar(std::string x, void (*f)(std::string)) {}\ntemplate&lt;class T&gt; void bar(T* x, void (*f)(T*)) {}\nvoid bar(A x, void (*f2)(double)) {}\n</code></pre>\n<p>Below expressions result in the following resolution of the name <code>foo</code> (at least with gcc 5.4):</p>\n<pre><code>bar(1, foo); // foo(int)\n             // but if foo(int) is removed, foo(double) takes over\n\nbar(1.0, foo); // foo(double)\n               // but if foo(double) is removed, foo(int) takes over\n\nint i;\nbar(&amp;i, foo); // foo&lt;int&gt;(int*)\n\nbar(\"abc\", foo); // foo&lt;const char&gt;(const char*)\n                 // but if foo&lt;T&gt;(T*) is removed, foo(std::string) takes over\n\nbar(std::string(\"abc\"), foo); // foo(std::string)\n\nbar(foo, foo); // 1st argument is foo(int), 2nd one - foo(double)\n</code></pre>\n<hr>\n<h3>Code to play with:</h3>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n#define PRINT_FUNC  std::cout &lt;&lt; \"\\t\" &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\";\n\nvoid foo(int)                      { PRINT_FUNC; }\nvoid foo(double)                   { PRINT_FUNC; }\nvoid foo(std::string)              { PRINT_FUNC; }\ntemplate&lt;class T&gt; void foo(T* )    { PRINT_FUNC; }\n\nstruct A { A(void (*f)(int)){ f(0); } };\n\nvoid bar(int         x, void (*f)(int)        ) { f(x); }\nvoid bar(double      x, void (*f)(double)     ) { f(x); }\nvoid bar(std::string x, void (*f)(std::string)) { f(x); }\ntemplate&lt;class T&gt; void bar(T* x, void (*f)(T*)) { f(x); }\nvoid bar(A, void (*f)(double)) { f(0); }\n\n#define CHECK(X) std::cout &lt;&lt; #X \":\\n\"; X; std::cout &lt;&lt; \"\\n\";\n\nint main()\n{\n    int i = 0;\n    CHECK( bar(i, foo)                     );\n    CHECK( bar(1.0, foo)                   );\n    CHECK( bar(1.0f, foo)                  );\n    CHECK( bar(&amp;i, foo)                    );\n    CHECK( bar(\"abc\", foo)                 );\n    CHECK( bar(std::string(\"abc\"), foo)    );\n    CHECK( bar(foo, foo)                   );\n}\n</code></pre>\n</hr>", "Tags": "<c++><overload-resolution>", "OwnerUserId": "6394138", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_40343663_40350274_1": {"section_id": 307, "quality": 1.0, "length": 12}, "so_40343663_40350274_3": {"section_id": 641, "quality": 0.9534883720930233, "length": 41}, "so_40343663_40350274_0": {"section_id": 307, "quality": 1.0, "length": 10}, "so_40343663_40350274_2": {"section_id": 307, "quality": 1.0, "length": 36}, "so_40343663_40350274_4": {"section_id": 642, "quality": 0.9583333333333334, "length": 23}, "so_40343663_40350274_5": {"section_id": 646, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_40343663_40350274_1": {"section_id": 298, "quality": 1.0, "length": 12}, "so_40343663_40350274_3": {"section_id": 631, "quality": 0.9534883720930233, "length": 41}, "so_40343663_40350274_0": {"section_id": 298, "quality": 1.0, "length": 10}, "so_40343663_40350274_2": {"section_id": 298, "quality": 1.0, "length": 36}, "so_40343663_40350274_4": {"section_id": 632, "quality": 0.9583333333333334, "length": 23}, "so_40343663_40350274_5": {"section_id": 636, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_40343663_40350274_1": {"section_id": 314, "quality": 1.0, "length": 12}, "so_40343663_40350274_3": {"section_id": 669, "quality": 0.8604651162790697, "length": 37}, "so_40343663_40350274_0": {"section_id": 314, "quality": 0.9, "length": 9}, "so_40343663_40350274_2": {"section_id": 314, "quality": 1.0, "length": 36}, "so_40343663_40350274_4": {"section_id": 670, "quality": 0.9583333333333334, "length": 23}, "so_40343663_40350274_5": {"section_id": 674, "quality": 0.7692307692307693, "length": 10}}}});