post_cb({"47515462": {"ParentId": "47513930", "CommentCount": "0", "CreationDate": "2017-11-27T16:22:26.633", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "47515462", "Score": "2", "Body": "<p>We also have, in <a href=\"http://eel.is/c++draft/iterators#std.iterator.tags-1\" rel=\"nofollow noreferrer\">[std.iterator.tags]</a>:</p>\n<blockquote>\n<p id=\"so_47513930_47515462_0\">It is often desirable for a function template specialization to find out what is the most specific category of its iterator argument, so that the function can select the most efficient algorithm at compile time. To facilitate this, the library introduces category tag classes which are used as compile time tags for algorithm selection. They are: <code>input_\u00aditerator_\u00adtag</code>, <code>output_\u00aditerator_\u00adtag</code>, <code>forward_\u00aditerator_\u00adtag</code>, <code>bidirectional_\u00aditerator_\u00adtag</code> and <code>random_\u00adacces_\u00aditerator_\u00adtag</code>. For every iterator of type <code>Iterator</code>, <code>iterator_\u00adtraits&lt;Iterator&gt;\u200b::\u200biterator_\u00adcategory</code> shall be defined to be the most specific category tag that describes the iterator's behavior.</p>\n<pre><code>namespace std {\n  struct input_iterator_tag { };\n  struct output_iterator_tag { };\n  struct forward_iterator_tag: public input_iterator_tag { };\n  struct bidirectional_iterator_tag: public forward_iterator_tag { };\n  struct random_access_iterator_tag: public bidirectional_iterator_tag { };\n}\n</code></pre>\n</blockquote>\n<p><code>int</code> isn't one of those tags, so <code>iterator_traits&lt;Iter&gt;::iterator_category</code> can't give you back <code>int</code>. I would suggest that having an invalid iterator category is simply violating the preconditions of <code>iterator_traits</code> - this doesn't necessarily mean that the library must fail, but it also doesn't mean that failure is a library bug.</p>\n<p>However, these preconditions aren't spelled out as explicitly in [iterators] as they are in other parts of the library section. So I'd be inclined to suggest that both libraries are correct, but libc++'s approach to not defining any member aliases in <code>iterator_traits&lt;Iter&gt;</code> is likely better. </p>\n", "LastActivityDate": "2017-11-27T16:22:26.633"}, "47513930": {"CommentCount": "1", "ViewCount": "52", "PostTypeId": "1", "LastEditorUserId": "3919155", "CreationDate": "2017-11-27T15:00:24.273", "LastActivityDate": "2017-11-27T16:22:26.633", "Title": "std::iterator_traits divergence between libstdc++ and libc++", "FavoriteCount": "2", "LastEditDate": "2017-11-27T15:35:40.307", "Id": "47513930", "Score": "4", "Body": "<p>Given:</p>\n<pre><code>struct Iter {\n    using value_type = int;\n    using difference_type = int;\n    using reference = int;\n    using pointer = int;\n    using iterator_category = int;\n};\n</code></pre>\n<p>The following works fine with libstc++, but fails to compile against libc++ 5.0.0:</p>\n<pre><code>#include &lt;iterator&gt;\n#include &lt;type_traits&gt;\nstatic_assert(\n    std::is_same&lt;\n        std::iterator_traits&lt;Iter&gt;::iterator_category,\n        Iter::iterator_category\n    &gt;::value, \"\");\n</code></pre>\n<p>With the error:</p>\n<blockquote>\n<p id=\"so_47513930_47513930_0\">error: no member named '<code>iterator_category</code>' in '<code>std::__1::iterator_traits&lt;Iter&gt;</code>'\n          <code>std::is_same&lt;std::iterator_traits&lt;Iter&gt;::iterator_category, Iter::iterator_category&gt;::value, \"\");</code></p>\n</blockquote>\n<p>The static assertion succeeds if <code>Iter::iterator_category</code> is one of the standard input categories, e.g. <code>std::input_iterator_tag</code>.</p>\n<p>IMHO it shouldn't fail, because the C++ draft states in <a href=\"http://eel.is/c++draft/iterator.traits#2\" rel=\"nofollow noreferrer\">[iterator.traits]#2</a>:</p>\n<blockquote>\n<p id=\"so_47513930_47513930_1\">If Iterator has valid (<a href=\"http://eel.is/c++draft/iterator.traits\" rel=\"nofollow noreferrer\">[temp.deduct]</a>) member types <code>difference_\u00adtype</code>, <code>value_\u00adtype</code>, <code>pointer</code>, <code>reference</code>, and <code>iterator_\u00adcategory</code>, <code>iterator_\u00adtraits&lt;Iterator&gt;</code> shall have the following as publicly accessible members:</p>\n<pre><code>using difference_type   = typename Iterator::difference_type;\nusing value_type        = typename Iterator::value_type;\nusing pointer           = typename Iterator::pointer;\nusing reference         = typename Iterator::reference;\nusing iterator_category = typename Iterator::iterator_category;\n</code></pre>\n<p id=\"so_47513930_47513930_2\">Otherwise, <code>iterator_\u00adtraits&lt;Iterator&gt;</code> shall have no members by any of the above names.</p>\n</blockquote>\n<p>Can anybody please explain whether this is an implementation bug, or why my expectations are wrong?</p>\n", "Tags": "<c++><language-lawyer><libc++><compiler-bug><iterator-traits>", "OwnerUserId": "3919155", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_47513930_47515462_0": {"section_id": 5588, "quality": 0.9245283018867925, "length": 49}}, "n3337": {"so_47513930_47515462_0": {"section_id": 5371, "quality": 0.9245283018867925, "length": 49}}, "n4659": {"so_47513930_47515462_0": {"section_id": 7034, "quality": 0.9245283018867925, "length": 49}, "so_47513930_47513930_1": {"section_id": 7031, "quality": 0.9375, "length": 15}, "so_47513930_47513930_2": {"section_id": 7031, "quality": 1.0, "length": 6}}}});