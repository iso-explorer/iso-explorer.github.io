post_cb({"7007003": {"Id": "7007003", "PostTypeId": "2", "Body": "<p>It is called as <strong>Qualified name lookup</strong>.<br>\nThe leading <code>::</code> refers the global namespace. Any qualified identifier starting with a <code>::</code> will always refer to some identifier in the global namespace over the same named identifier in local namespace.</br></p>\n<pre><code>namespace A\n{ \n    namespace B\n    {\n        void doSomething();\n    }\n}\n\nnamespace Z \n{ \n    namespace A\n    {  \n        namespace B\n        {\n            void doSomething();\n        } \n    }\n\n    using namespace A::B // no leading :: refers to local namespace layer\n\n    void doSomethingMore() \n    {\n       doSomething(); // calls Z::A::B::doSomething();\n\n    }\n}\n\nnamespace Z\n{\n   namespace A\n   { \n      namespace B\n      {\n          void doSomething();\n      } \n   }\n\n   using namespace ::A::B // leading :: refers to global namespace A\n   void doSomethingMore() \n   {\n        doSomething(); // calls ::A::B::doSomething();\n   }\n}\n</code></pre>\n", "LastEditorUserId": "452307", "LastActivityDate": "2011-08-10T07:11:32.793", "Score": "5", "CreationDate": "2011-08-10T07:02:07.913", "ParentId": "7006938", "CommentCount": "5", "LastEditDate": "2011-08-10T07:11:32.793", "OwnerUserId": "452307"}, "7006995": {"Id": "7006995", "PostTypeId": "2", "Body": "<p><code>::S</code> is a qualified-id.</p>\n<p>In the qualified-id <code>::S::f</code>, <code>S::</code> is a nested-name-specifier.</p>\n<p>In informal terms, a nested-name-specifier is the part of the id that</p>\n<ul>\n<li>begins either at the very beginning of a qualified-id or after the initial scope resolution operator (::) if one appears at the very beginning of the id and</li>\n<li>ends with the last scope resolution operator in the qualified-id.</li>\n</ul>\n<p>Very informally, an id is either a qualified-id or an unqualified-id. If the id is a qualified-id, it is actually composed of two parts: a nested-name specifier followed by an unqualified-id.</p>\n<p>Given:</p>\n<pre><code>struct  A {\n    struct B {\n        void F();\n    };\n};\n</code></pre>\n<ul>\n<li><code>A</code> is an unqualified-id.</li>\n<li><code>::A</code> is a qualified-id but has no nested-name-specifier.</li>\n<li><code>A::B</code> is a qualified-id and <code>A::</code> is a nested-name-specifier.</li>\n<li><code>::A::B</code> is a qualified-id and <code>A::</code> is a nested-name-specifier.</li>\n<li><code>A::B::F</code> is a qualified-id and both <code>B::</code> and <code>A::B::</code> are nested-name-specifiers.</li>\n<li><code>::A::B::F</code> is a qualified-id and both <code>B::</code> and <code>A::B::</code> are nested-name-specifiers.</li>\n</ul>\n<p>Another example:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint count(0);                   // Used for iteration\n\nclass outer {\npublic:\n    static int count;           // counts the number of outer classes\n    class inner {\n    public:\n        static int count;       // counts the number of inner classes\n    };\n};\n\nint outer::count(42);            // assume there are 42 outer classes\nint outer::inner::count(32768);  // assume there are 2^15 inner classes\n                                 // getting the hang of it?\n\nint main() {\n    // how do we access these numbers?\n    //\n    // using \"count = ?\" is quite ambiguous since we don't explicitly know which\n    // count we are referring to.\n    //\n    // Nested name specifiers help us out here\n\n    cout &lt;&lt; ::count &lt;&lt; endl;        // The iterator value\n    cout &lt;&lt; outer::count &lt;&lt; endl;           // the number of outer classes instantiated\n    cout &lt;&lt; outer::inner::count &lt;&lt; endl;    // the number of inner classes instantiated\n    return 0;\n}\n</code></pre>\n<p>EDIT:</p>\n<p>In response to your comment, I believe that statement simply means that the arguments of a template are handled w.r.t the context and line by which they are declared. For example,</p>\n<p>in <code>f.~foo();</code>, foo is looked up within <code>f.</code>, and within the scope of <code>foo&lt;int&gt;</code>, it is valid to refer to it just with with <code>foo</code>.</p>\n", "LastEditorDisplayName": "user195488", "OwnerDisplayName": "user195488", "LastActivityDate": "2011-08-10T07:11:31.803", "Score": "5", "CreationDate": "2011-08-10T07:01:04.153", "ParentId": "7006938", "CommentCount": "2", "LastEditDate": "2011-08-10T07:11:31.803"}, "bq_ids": {"n4140": {"so_7006938_7006938_0": {"length": 28, "quality": 1.0, "section_id": 7116}, "so_7006938_7006938_1": {"length": 7, "quality": 1.0, "section_id": 7116}}, "n3337": {"so_7006938_7006938_0": {"length": 28, "quality": 1.0, "section_id": 6860}, "so_7006938_7006938_1": {"length": 7, "quality": 1.0, "section_id": 6860}}, "n4659": {"so_7006938_7006938_0": {"length": 20, "quality": 0.7142857142857143, "section_id": 8614}, "so_7006938_7006938_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 8617}}}, "7006938": {"ViewCount": "154", "Body": "<p>A point from the ISO C++ draft (n3290): 3.4.3.2/1 Namespace members</p>\n<blockquote>\n<p id=\"so_7006938_7006938_0\">If the nested-name-specifier of a qualified-id nominates a namespace,\n  the name  specified after the nested-name-specifier is looked up in\n  the scope of the  namespace. <strong>If a qualified-id starts with ::, the\n  name after the :: is looked up in the global namespace. In either\n  case, the names in a template-argument of a template-id are looked up\n  in the context in which the entire postfix-expression occurs.</strong></p>\n</blockquote>\n<p>Here can any one explain about the BOLD part .... and from earlier c++03 draft to c++0x draft he added </p>\n<blockquote>\n<p id=\"so_7006938_7006938_1\"><strong>If a qualified-id starts with ::, the name after the :: is looked up\n  in the global namespace.</strong></p>\n</blockquote>\n<p>can any one explain with an example program please </p>\n", "AcceptedAnswerId": "7006995", "Title": "A point from the ISO C++ draft (n3290): 3.4.3.2/1 Namespace members", "CreationDate": "2011-08-10T06:55:12.537", "Id": "7006938", "CommentCount": "0", "LastEditDate": "2011-08-10T22:40:57.037", "PostTypeId": "1", "LastEditorUserId": "5597", "LastActivityDate": "2011-08-11T10:58:42.997", "Score": "4", "OwnerUserId": "751747", "Tags": "<c++><namespaces><c++11>", "AnswerCount": "4"}, "7007575": {"Id": "7007575", "PostTypeId": "2", "Body": "<p>The bolded text refers to two different situations. The first part is the distinction of using or not using <code>::</code> as a prefix. When a qualified name starts with <code>::</code> the exact namespace is checked starting from the empty namespace, while if it is not present, the search will consider nested namespaces:</p>\n<pre><code>namespace A {\n    void f() { std::cout &lt;&lt; \"::A::f\" &lt;&lt; std::endl; }\n}\nnamespace B {\n    namespace A {\n        void f() { std::cout &lt;&lt; \"::B::A::f\" &lt;&lt; std::endl; }\n    }\n    void g() {\n        A::f();     // ::B::A::f\n        ::A::f();   // ::A::f\n    }\n}\n</code></pre>\n<p>The last sentence in the paragraph refers to the specific of template arguments, and it tells you that the lookup will not start in the namespace that the template was declared, but rather in the namespace where it is being instantiated:</p>\n<pre><code>struct A {\n    static void f() { std::cout &lt;&lt; \"::A::f()\" &lt;&lt; std::endl; }\n};\ntemplate &lt;typename T&gt;\nvoid f() {\n    T::f();\n}\nnamespace N {\n    struct A {\n        static void f() { std::cout &lt;&lt; \"::N::A::f()\" &lt;&lt; std::endl; }\n    };\n    void g() {\n        f&lt;A&gt;();\n    }\n}\n</code></pre>\n<p>If lookup started in the template namespace, the call <code>f&lt;A&gt;()</code> would refer to <code>f&lt;::A&gt;</code>, but that clause in the standard states the lookup will start inside namespace <code>N</code> (<em>where the entire postfix-expression occurs</em>), and will thus call <code>::N::A::f()</code>.</p>\n", "LastActivityDate": "2011-08-10T07:59:16.520", "CommentCount": "0", "CreationDate": "2011-08-10T07:59:16.520", "ParentId": "7006938", "Score": "2", "OwnerUserId": "36565"}, "7024659": {"Id": "7024659", "PostTypeId": "2", "Body": "<pre><code>int a(1);\n\nclass someCls {\n  private:\n    int a;\n  public:\n    // Assigns this-&gt;a with the value of the global variable ::a.\n    void assignFromGlobal() {\n      a = ::a;\n    }\n};\n</code></pre>\n", "LastActivityDate": "2011-08-11T10:58:42.997", "CommentCount": "0", "CreationDate": "2011-08-11T10:58:42.997", "ParentId": "7006938", "Score": "0", "OwnerUserId": "870609"}});