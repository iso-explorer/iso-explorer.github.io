post_cb({"47021238": {"ViewCount": "49", "Body": "<p>As seen in <a href=\"https://stackoverflow.com/questions/47020276/n-0-1-n-1-in-c#47020276\">this</a> question, the OP was trying to make following statement iterate over the numbers.</p>\n<pre><code>for (int n : 10)\n    cout &lt;&lt; n &lt;&lt; endl;\n</code></pre>\n<p>Obviously, wrong syntax, because <code>int</code> has no <code>begin()</code> and <code>end()</code> methods. But it should be possible. Based on documentation of <a href=\"http://en.cppreference.com/w/cpp/language/range-for\" rel=\"nofollow noreferrer\"><em>range-based for loop</em></a> this is important.</p>\n<blockquote>\n<p id=\"so_47021238_47021238_0\"><code>for</code> <code>(</code> <em>range_declaration</em> <code>:</code> <em>range_expression</em> <code>)</code> <em>loop_statement</em></p>\n<p id=\"so_47021238_47021238_1\"><em>range_expression</em> - any expression that represents a suitable sequence \n  (either an array or an object for which begin and end member functions or free functions are defined, see below) or a braced-init-list.</p>\n</blockquote>\n<p>And following</p>\n<blockquote>\n<p id=\"so_47021238_47021238_2\">The above syntax produces code equivalent to the following (<code>__range</code>, <code>__begin</code> and <code>__end</code> are for exposition only):</p>\n<pre><code>{ // until C++17\n    auto &amp;&amp; __range = range_expression ;\n    for (auto __begin = begin_expr, __end = end_expr; __begin != __end; ++__begin) {\n        range_declaration = *__begin;\n        loop_statement\n    }\n}\n</code></pre>\n</blockquote>\n<p>With clarification of <em>begin_expr</em> and <em>end_expr</em> are:</p>\n<blockquote>\n<p id=\"so_47021238_47021238_3\"><em>begin_expr</em> and <em>end_expr</em> are defined as follows:</p>\n<ul>\n<li>If <em>range_expression</em> is an expression of array type, then [...]</li>\n<li>If <em>range_expression</em> is an expression of a class type C [...]</li>\n<li>Otherwise, <em>begin_expr</em> is <code>begin(__range)</code> and <em>end_expr</em> is <code>end(__range)</code>, which are found via argument-dependent lookup (non-ADL lookup is not performed).</li>\n</ul>\n</blockquote>\n<p>In our case <em>range_expression</em> is <code>10</code>, which is not of array type nor of a class type, so last bullet should take effect. So we provide these functions</p>\n<pre><code>auto begin(int) {\n    return boost::counting_iterator&lt;int&gt;(0);\n}\n\nauto end(int n) {\n    return boost::counting_iterator&lt;int&gt;(n);\n}\n</code></pre>\n<p>(<code>boost::counting_iterator</code> could be easily implemented). And it should work, right? However it fails with</p>\n<pre><code>main.cpp: In function 'int main()':\nmain.cpp:17:18: error: 'begin' was not declared in this scope\n     for (int t : 10)\n                  ^~\nmain.cpp:17:18: note: suggested alternatives:\nmain.cpp:5:6: note:   'begin'\n auto begin(int) {\n      ^~~~~\n\nIn file included from /usr/local/include/c++/7.2.0/vector:66:0,\n                 from main.cpp:1:\n/usr/local/include/c++/7.2.0/bits/range_access.h:105:37: note:   'std::begin'\n   template&lt;typename _Tp&gt; const _Tp* begin(const valarray&lt;_Tp&gt;&amp;);\n                                     ^~~~~\n</code></pre>\n<p>(and same message for <code>end</code>). However, if I change the range-based for loop according to description, I get following, which works.</p>\n<pre><code>{\n    auto &amp;&amp; __range = 10;\n    for (auto __begin = begin(__range), __end = end(__range); __begin != __end; ++__begin) {\n        int t = *__begin;\n        std::cout &lt;&lt; t &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/3b26e1d57ea3c376\" rel=\"nofollow noreferrer\">DEMO</a></p>\n", "AcceptedAnswerId": "47021276", "Title": "range based for used for primitive type", "CreationDate": "2017-10-30T17:41:40.303", "Id": "47021238", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-10-30T17:45:06.360", "LastEditorUserId": "2069064", "LastActivityDate": "2017-10-30T18:09:59.023", "Score": "3", "OwnerUserId": "3087601", "Tags": "<c++><c++14><language-lawyer>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_47021238_47021276_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 6279}, "so_47021238_47021276_1": {"length": 9, "quality": 1.0, "section_id": 7104}}, "n3337": {"so_47021238_47021276_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 6039}, "so_47021238_47021276_1": {"length": 9, "quality": 1.0, "section_id": 6848}}, "n4659": {"so_47021238_47021276_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 7786}, "so_47021238_47021276_1": {"length": 9, "quality": 1.0, "section_id": 8605}}}, "47021276": {"Id": "47021276", "PostTypeId": "2", "Body": "<p>The key phrase is:</p>\n<blockquote>\n<p id=\"so_47021238_47021276_0\">which are found via argument-dependent lookup (non-ADL lookup is not performed)</p>\n</blockquote>\n<p><code>int</code> has no namespace. No, not even the <em>global</em> namespace. As such, lookup based on the namespace finds nothing.</p>\n<p>To be more specific to the specification, [basic.lookup.argdep]/2.1 says:</p>\n<blockquote>\n<p id=\"so_47021238_47021276_1\">If T is a fundamental type, its associated sets of namespaces and classes are both empty.</p>\n</blockquote>\n<p>And since there are no associated namespaces or classes, ADL doesn't work.</p>\n<p>This would be better handled by a user-defined literal that returns a counting range. So you would type <code>10_rng</code>, and that would yield a counting range.</p>\n", "LastEditorUserId": "734069", "LastActivityDate": "2017-10-30T17:46:41.280", "Score": "8", "CreationDate": "2017-10-30T17:44:17.623", "ParentId": "47021238", "CommentCount": "2", "LastEditDate": "2017-10-30T17:46:41.280", "OwnerUserId": "734069"}});