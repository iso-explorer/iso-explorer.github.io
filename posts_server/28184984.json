post_cb({"28184984": {"ViewCount": "271", "Body": "<p>Please consider the following code:</p>\n<pre><code>class A {\nprivate:\n  std::string s;\npublic:\n  A() = delete;\n  A(const A&amp;) = delete;\n  A(A&amp;&amp;) = delete;\n  A(const std::string &amp;a) : s(a) {}\n};\n</code></pre>\n<p>Now, I would like to initialize an array of A using list initialization. g++ (4.9.1) could successfully build the following code:</p>\n<pre><code>int main() {\n  A arr[2] = {{\"a\"}, {\"b\"}};\n  return 0;\n}\n</code></pre>\n<p>But, it failed for the following code:</p>\n<pre><code>class Aggr {\nprivate:\n  A arr[2];\npublic:\n  Aggr() : arr{{\"a\"}, {\"b\"}} {}\n};\n</code></pre>\n<p>The error messages are,</p>\n<pre><code>test.cc: In constructor \u2018Aggr::Aggr()\u2019:\ntest.cc:22:28: error: use of deleted function \u2018A::A(A&amp;&amp;)\u2019\n   Aggr() : arr{{\"a\"}, {\"b\"}} {}\n                            ^          \ntest.cc:11:3: note: declared here\n   A(A&amp;&amp;) = delete;\n   ^\n</code></pre>\n<p>That said, a list-initializer tries to call a move constructor for initializing an array inside of a class. That code, however, was successfully built by clang v3.5 without any warnings.\nSo, I would like to know what the C++11 (or later version) specifies rules with respect to list-initialization. Thanks in advance.</p>\n", "Title": "Different behavior of c++11 list-initialization", "CreationDate": "2015-01-28T05:03:49.263", "Id": "28184984", "CommentCount": "7", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-01-28T06:25:43.397", "LastEditorDisplayName": "user3920237", "LastActivityDate": "2015-01-31T17:15:29.320", "Score": "13", "OwnerUserId": "4501419", "Tags": "<c++><c++11><list-initialization>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28184984_28253270_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 3299}, "so_28184984_28253270_2": {"length": 19, "quality": 0.59375, "section_id": 599}}, "n3337": {"so_28184984_28253270_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 3169}, "so_28184984_28253270_2": {"length": 19, "quality": 0.59375, "section_id": 589}}, "n4659": {"so_28184984_28253270_0": {"length": 17, "quality": 0.7083333333333334, "section_id": 4065}, "so_28184984_28253270_2": {"length": 19, "quality": 0.59375, "section_id": 622}}}, "28253270": {"Id": "28253270", "PostTypeId": "2", "Body": "<p>Reading again and again the standard, I think this is a bug. </p>\n<p><strong>What does the standard say ?</strong> </p>\n<blockquote>\n<p id=\"so_28184984_28253270_0\"><strong>8.5.1/2</strong> : When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list are taken\n  as initializers for the members of the aggregate, in increasing\n  subscript or member order. Each member is copy-initialized from the\n  corresponding initializer-clause.</p>\n</blockquote>\n<p>It is explained that: </p>\n<blockquote>\n<p id=\"so_28184984_28253270_1\"><strong>8.5/14</strong> :  (...) is called copy-initialization. [ Note: Copy-initialization may invoke a move (12.8). \u2014end note ]</p>\n</blockquote>\n<p>But I found no evidence in 12.8 that in your specific case a move would be required. </p>\n<blockquote>\n<p id=\"so_28184984_28253270_2\"><strong>8.5.4/3</strong> Otherwise, if T is a class type, constructors are considered. If T has an initializer-list constructor, the argument\n  list consists of the initializer list as a single argument; otherwise,\n  the argument list consists of the elements of the initializer list.\n  The applicable constructors are enumerated and the best one is chosen\n  through overload resolution (13.3).</p>\n</blockquote>\n<p>So in principle you code should work ! </p>\n<p><strong>Is it a bug ?  Trying the experimental way</strong></p>\n<p>I commented out the delete of the move constructor, to benefit from the implicit move constructor.  Strangely,  I then got the following error message: </p>\n<pre><code>    Compilation error   time: 0 memory: 3232 signal:0\n\nprog.cpp: In constructor 'Aggr::Aggr()':\nprog.cpp:19:28: error: use of deleted function 'A::A(const A&amp;)'\n   Aggr() : arr{{\"a\"}, {\"b\"}} {}\n                            ^\nprog.cpp:10:3: note: declared here\n   A(const A&amp;) = delete  \n</code></pre>\n<p>So now he complains about a missing copy constructor ! </p>\n<p>Even more strangely, I then provided my own move constructor instead of the implicit one : here it compiled the code successfully !! </p>\n<p>Finally I provided both a copy and a move and added some tracing:  </p>\n<pre><code>class A {\nprivate:\n  std::string s;\npublic:\n  A() = delete;\n  A(const A&amp;)  { std::cout&lt;&lt;\"copy\\n\";} //= delete;\n  A(A&amp;&amp;) { std::cout&lt;&lt;\"move\\n\";} //= delete;\n  A(const std::string &amp;a) : s(a) {  std::cout&lt;&lt;\"string ctor\\n\";}\n};\n</code></pre>\n<p>And when I create an <code>Aggr</code> object, it just displays:</p>\n<pre><code>string ctor \nstring ctor\n</code></pre>\n<p>showing that the array member is initialized form the string constructor using copy elision as we would have expected.  </p>\n<p>All these tests were performed with gcc-9.4.2 on ideone with C++14 option.</p>\n<p><strong>Conclusion</strong></p>\n<p>The fact that the same code fails to compile with implicit move ctor and succeeds with a user-defined move ctor looks very seriously like a bug.  </p>\n<p>The fact that the move constructor is not used when it's available reinforces this impression.  </p>\n<p>Consequently, I've reported <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64887\" rel=\"nofollow\">this bug</a>.</p>\n", "LastEditorUserId": "3723423", "LastActivityDate": "2015-01-31T17:15:29.320", "Score": "2", "CreationDate": "2015-01-31T15:27:46.720", "ParentId": "28184984", "CommentCount": "1", "OwnerUserId": "3723423", "LastEditDate": "2015-01-31T17:15:29.320"}});