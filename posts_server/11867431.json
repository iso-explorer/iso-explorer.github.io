post_cb({"11867431": {"ViewCount": "8049", "Body": "<p>There are sources (books, online materials) that explain the usage of <code>extern</code> as following:</p>\n<pre><code>extern int i;        // declaration - has 'extern'\nint i = 1;           // definition  - specified by the absence of 'extern'\n</code></pre>\n<p>And there are sources that support the following syntax:</p>\n<pre><code>extern int i;        // declaration\nextern int i = 1;    // definition  - specified by the equal sign\n                     // Both marked with 'extern'\n</code></pre>\n<p>My question is - is this a <em>C</em> vs. <em>C++</em> distinction, or is it a <em>pre-ANSI</em> vs. <em>ANSI</em> practice?</p>\n<p>Now, the more practical question:</p>\n<p>Using the second syntax, I want to create a global object (visible from every compilation unit). The constructor takes no parameters, so neither parentheses, nor the equal sign are necessary.</p>\n<pre><code>extern MyClass myobject;\n</code></pre>\n<p>Now how can the compiler make the distinction between a declaration and the definition?</p>\n<p><strong>EDIT:</strong> Back at school, I was used to the first syntax (Borland C). Later I used a compiler (probably some ancient version of GCC) that refused to compile a definition without an 'extern'. That is what made me confused.</p>\n", "AcceptedAnswerId": "11869284", "Title": "Using the 'extern' keyword properly", "CreationDate": "2012-08-08T15:02:30.137", "Id": "11867431", "CommentCount": "1", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2012-08-08T17:38:53.403", "LastEditorUserId": "1062139", "LastActivityDate": "2017-11-01T01:11:07.950", "Score": "9", "OwnerUserId": "1062139", "Tags": "<c++><extern>", "AnswerCount": "6"}, "24234236": {"Id": "24234236", "PostTypeId": "2", "Body": "<p>Ok, so the <code>extern</code> keyword is placed before the name of a variable in an external file. So say you have a separate file in your Project. Say that file is a header file called MyMath.h (as if you were making a portable math file with some useful functions/classes). In your header file you would put all the prototypes, or forward references, for your cool math functions and classes. The actual code, or functions, etc. for this math header file would be in a .cpp file called MyMath.cpp (usually you use the same name to keep it all organized). The <code>extern</code> keyword comes into play here: if you wanted to have a global variable for PI (3.1415) in your math file, you need to define it (in the .cpp file) the same as usual, <code>float PI = 3.1415;</code> and THEN in your .h or header file you would write the prototype, or declaration of the variable, with the prefix <code>extern</code>.</p>\n<p>So the full example could look like this:</p>\n<p>----MyMath.h----</p>\n<pre><code>#ifndef MYMATH_H_INCLUDED\n#define MYMATH_H_INCLUDED\n\nextern float PI;\n\n#endif // MYMATH_H_INCLUDED\n</code></pre>\n<p>----MyMath.cpp----</p>\n<pre><code>#include \"MyMath.h\"\n\nfloat PI = 3.1415;\n</code></pre>\n<p>----main.cpp----</p>\n<pre><code>#include &lt;iostream&gt;\n#include \"MyMath.h\"\n\nusing namespace std;\n\nint main()\n{\n    cout &lt;&lt; \"PI = \" &lt;&lt; PI &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>Hope I explained thoroughly! Remember, this is for variables' use between files!</p>\n", "LastActivityDate": "2014-06-15T21:21:42.570", "CommentCount": "0", "CreationDate": "2014-06-15T21:21:42.570", "ParentId": "11867431", "Score": "2", "OwnerUserId": "3148109"}, "11868086": {"Id": "11868086", "PostTypeId": "2", "Body": "<p>draft n3337, 3.1.2</p>\n<blockquote>\n<p id=\"so_11867431_11868086_0\"><strong>A declaration is a definition unless</strong> it declares a function without\n  specifying the function\u2019s body (8.4), <strong>it contains the extern specifier\n  (7.1.1)</strong> or a linkage-specification25 (7.5) <strong>and neither an initializer</strong>\n  nor a functionbody, it declares a static data member in a class\n  definition (9.2, 9.4), it is a class name declaration (9.1), it is an\n  opaque-enum-declaration (7.2), it is a template-parameter (14.1), it\n  is a parameter-declaration (8.3.5) in a function declarator that is\n  not the declarator of a function-definition, or it is a typedef\n  declaration (7.1.3), an alias-declaration (7.1.3), a using-declaration\n  (7.3.3), a static_assert-declaration (Clause 7), an\n  attributedeclaration (Clause 7), an empty-declaration (Clause 7), or a\n  using-directive (7.3.4). [ Example: all but one of the following are\n  definitions:</p>\n</blockquote>\n<pre><code>int a; // defines a\nextern const int c = 1; // defines c\nint f(int x) { return x+a; } // defines f and defines x\nstruct S { int a; int b; }; // defines S, S::a, and S::b\nstruct X { // defines X\nint x; // defines non-static data member x\nstatic int y; // declares static data member y\nX(): x(0) { } // defines a constructor of X\n};\nint X::y = 1; // defines X::y\nenum { up, down }; // defines up and down\nnamespace N { int d; } // defines N and N::d\nnamespace N1 = N; // defines N1\nX anX; // defines anX\n</code></pre>\n<blockquote id=\"so_11867431_11868086_1\">\n<pre><code>whereas these are just declarations:\n</code></pre>\n</blockquote>\n<pre><code>extern int a; // declares a\nextern const int c; // declares c\nint f(int); // declares f\nstruct S; // declares S\ntypedef int Int; // declares Int\nextern X anotherX; // declares anotherX\nusing N::d; // declares d\n</code></pre>\n<blockquote>\n<p id=\"so_11867431_11868086_2\">\u2014end example ]</p>\n</blockquote>\n", "LastEditorUserId": "1498580", "LastActivityDate": "2012-08-08T15:39:42.833", "Score": "2", "CreationDate": "2012-08-08T15:34:28.113", "ParentId": "11867431", "CommentCount": "0", "OwnerUserId": "1498580", "LastEditDate": "2012-08-08T15:39:42.833"}, "11868227": {"Id": "11868227", "PostTypeId": "2", "Body": "<p>For file-scope variables, whether they are of class type or primitive type:</p>\n<ul>\n<li><code>extern T t;</code> with no initialiser is a declaration;</li>\n<li><code>extern T t = expression;</code> with an initialiser of whatever syntax (assignment, construction, or unified) is a definition;</li>\n<li><code>T t;</code> with no initialiser is a definition, initialised to the default value of <code>T</code>;</li>\n<li><code>T t = expression;</code> with an initialiser of whatever syntax is a definition.</li>\n</ul>\n<p>There is no difference between <code>extern int i = 1;</code> and <code>int i = 1;</code>, and there are arguments to be made for both styles, but in general I'd argue for the second as you should already be aware that a definition at file scope has linkage.</p>\n<p>Historically, it appears that pre-ANSI C the <code>extern</code> keyword was not required; see e.g. <a href=\"http://www.jetcafe.org/jim/c-style.html#Declarations\" rel=\"nofollow\">http://www.jetcafe.org/jim/c-style.html#Declarations</a></p>\n<p>So for a class type, write <code>extern MyClass myobject;</code> for the declaration(s) and <code>MyClass myobject;</code> for the definition.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-08-08T15:49:41.690", "Score": "4", "CreationDate": "2012-08-08T15:42:43.173", "ParentId": "11867431", "CommentCount": "0", "OwnerUserId": "567292", "LastEditDate": "2012-08-08T15:49:41.690"}, "bq_ids": {"n4140": {"so_11867431_11868086_0": {"length": 45, "quality": 0.8181818181818182, "section_id": 7034}}, "n3337": {"so_11867431_11868086_0": {"length": 45, "quality": 0.8181818181818182, "section_id": 6780}}, "n4659": {"so_11867431_11868086_0": {"length": 44, "quality": 0.8, "section_id": 8531}}}, "11869284": {"Id": "11869284", "PostTypeId": "2", "Body": "<p>Specifically for your examples, there's no distinction between C and C++ at work here. The basic rule that works in both languages is this: if your declaration includes an <em>initializer</em>, then it is a <em>definition</em>. Period. It does not matter, whether it has explicit <code>extern</code> in it or not. If it has an initializer, then it is a <em>definition</em>.</p>\n<p>That means that in namespace scope both <code>extern int i = 1</code> and <code>int i = 1</code> are equivalent, i.e. <code>extern</code> in such declaration is redundant. In C++ <code>extern</code> in definitions becomes non-redundant when the declared object is <code>const</code>, since <code>const</code> objects in C++ have internal linkage by default. For example, <code>extern const int c = 42;</code> defines constant <code>c</code> with external linkage.</p>\n<p>If a declaration has no initializer, then (and only then) it begins to depend on the presence of <code>extern</code> keyword. With <code>extern</code> it is a <em>non-defining declaration</em>. Without <code>extern</code> it is a <em>definition</em>. (In C it would be a <em>tentative</em> definition, but that's beside the point in our context).</p>\n<p>Now, for your practical question. In order to create a global object, you have to <em>declare</em> it as</p>\n<pre><code>extern MyClass myobject;\n</code></pre>\n<p>(which will usually be done in a header file), and then <em>define</em> it in some translation unit as</p>\n<pre><code>MyClass myobject;\n</code></pre>\n<p>Since your constructor takes no arguments, this is the only way to define your object. (Starting from C++11 you can also use <code>MyClass myobject{};</code> if you so desire.)</p>\n<p>If you had to supply arguments to the constructor (say, <code>42</code>), you would be able to use both</p>\n<pre><code>MyClass myobject(42);\n</code></pre>\n<p>and</p>\n<pre><code>extern MyClass myobject(42);\n</code></pre>\n<p>as definition, since presence of an initializer ensures that it is indeed interpreted as a <em>definition</em>.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2017-11-01T01:11:07.950", "Score": "9", "CreationDate": "2012-08-08T16:46:43.480", "ParentId": "11867431", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2017-11-01T01:11:07.950"}, "11868230": {"Id": "11868230", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11867431_11868230_0\">I want to create a global object (visible from every compilation unit)</p>\n</blockquote>\n<p><code>extern</code> is not necessary for the definition, because external linkage is the default.</p>\n<p>What you should do is put:</p>\n<pre><code>extern MyClass myobject;\n</code></pre>\n<p>in a header file (this is not a definition) to make the compiler aware of the data type when compiling other compilation units.  Then, in exactly one compilation unit, write:</p>\n<pre><code>MyClass myobject;\n</code></pre>\n<p>which is a definition with external linkage.</p>\n", "LastActivityDate": "2012-08-08T15:42:53.240", "CommentCount": "0", "CreationDate": "2012-08-08T15:42:53.240", "ParentId": "11867431", "Score": "2", "OwnerUserId": "103167"}, "18112246": {"Id": "18112246", "PostTypeId": "2", "Body": "<p>\"initializer\" beats \"extern\". Action beats talk.</p>\n", "LastActivityDate": "2013-08-07T19:34:43.127", "CommentCount": "0", "CreationDate": "2013-08-07T19:34:43.127", "ParentId": "11867431", "Score": "0", "OwnerUserId": "2631678"}});