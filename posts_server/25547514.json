post_cb({"bq_ids": {"n4140": {"so_25547514_26895652_0": {"length": 7, "quality": 1.0, "section_id": 5491}}, "n3337": {"so_25547514_26895652_0": {"length": 7, "quality": 1.0, "section_id": 5277}}, "n4659": {"so_25547514_26895652_0": {"length": 7, "quality": 1.0, "section_id": 6925}}}, "26895652": {"Id": "26895652", "PostTypeId": "2", "Body": "<p>This is indeed a compiler bug -- ICC, CLang, and G++ all accept this code as verified on <a href=\"http://gcc.godbolt.org\" rel=\"nofollow\">Godbolt</a>.</p>\n<p>The most applicable language in the standard I could find is 7.3.3 (namespace.udecl) p2 (quoted from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">N3337</a>)</p>\n<blockquote>\n<p id=\"so_25547514_26895652_0\">Every <em>using-declaration</em> is a <em>declaration</em> and a <em>member-declaration</em> and so can be used \n  in a class definition.</p>\n</blockquote>\n<p>P.S. ICC, CLang, and G++ all accept the typedef version as well.</p>\n", "LastActivityDate": "2014-11-12T20:08:16.453", "CommentCount": "0", "CreationDate": "2014-11-12T20:08:16.453", "ParentId": "25547514", "Score": "0", "OwnerUserId": "3657206"}, "25547514": {"ViewCount": "166", "Body": "<p>Visual Studio 2013 (update 2) throws a compile-time error when compiling a template function who's return type is a nested type name, which has been hidden through multiple inheritance, and made visible again with the <code>using</code> keyword; as in the following code:</p>\n<pre><code>struct Base1\n{\n  typedef int value_type;\n};\n\nstruct Base2\n{\n  typedef double value_type;\n};\n\nstruct Derived : Base1, Base2\n{\n  using Base1::value_type;\n};\n\ntemplate&lt;typename T&gt;\ntypename T::value_type nullary_function() { return 0; }\n\ntemplate&lt;typename T&gt;\ntypename T::value_type unary_function(T t) { return 0; }\n\nint main()\n{\n  nullary_function&lt;Derived&gt;(); // Error: C2770\n  unary_function( Derived() ); // Error: C2893\n  return 0;\n}\n</code></pre>\n<p>(The error numbers vary depending upon whether the function accepts template arguments or not as shown in the comments.)</p>\n<p>G++ 4.7 accepts this code.</p>\n<p>Specifically, I would like to know what the C++ standard has to say on the matter and whether or not this is a VC++ compiler bug. (It would appear to me that it is seeing as making nested types visible with the <code>using</code> keyword makes them visible in every other situation as far as I'm aware.)</p>\n<p>I am also aware that the line with the <code>using</code> keyword may be changed from</p>\n<pre><code>using Base1::value_type;\n</code></pre>\n<p>to</p>\n<pre><code>typedef Base1::value_type value_type;\n</code></pre>\n<p>in order to get the code to compile and function correctly, but it seems bad for portability for some (potentially) valid code to compile on some compilers and not others - hence the desire for clarification.</p>\n", "Title": "Why does VC++2013 refuse to compile nested types, made visibile with the using keyword, when used as a template functions return type?", "CreationDate": "2014-08-28T11:17:12.797", "LastActivityDate": "2015-06-07T01:31:19.990", "CommentCount": "10", "LastEditDate": "2015-06-07T01:31:19.990", "PostTypeId": "1", "LastEditorUserId": "64046", "Id": "25547514", "Score": "7", "OwnerUserId": "3042185", "Tags": "<c++><templates><visual-studio-2013><nested><multiple-inheritance>", "AnswerCount": "1"}});