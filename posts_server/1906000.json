post_cb({"1906096": {"ParentId": "1906000", "CommentCount": "0", "Body": "<p>In many cases, but not all, a reference can be implemented with an 'auto-dereferenced' pointer.  That any particular compiler treats a function with C linkage and a reference parameter this way is not guaranteed in the C++ standard, and you should treat it as an implementation detail.</p>\n<p>It isn't hard to write a forwarding function that takes a pointer and calls your function, if you need to do this without relying on implementation details:</p>\n<pre><code>void real_f(int&amp; n) {\n  n++;\n}\nextern \"C\" void f(int* p) { // called from C code\n  real_f(*p);\n}\n</code></pre>\n", "Id": "1906096", "PostTypeId": "2", "OwnerDisplayName": "Roger Pate", "Score": "11", "CreationDate": "2009-12-15T08:58:56.360", "LastActivityDate": "2009-12-15T08:58:56.360"}, "4224660": {"ParentId": "1906000", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I think you already got some good answers so just pointing out something extra on your question.</p>\n<p>My humble understanding is that extern merely creates a C symbol.</p>\n<p>So your example still \"seems to work\" (gcc/g++) even when I add a class object - I had to try ir to believe it:</p>\n<pre><code>class A {};\n\nextern \"C\" void f(int &amp;i, A a) {\n    i++;\n}\n</code></pre>\n", "OwnerUserId": "495167", "LastEditorUserId": "182705", "LastEditDate": "2013-03-08T00:35:51.540", "Id": "4224660", "Score": "1", "CreationDate": "2010-11-19T11:49:59.463", "LastActivityDate": "2013-03-08T00:35:51.540"}, "1906000": {"CommentCount": "1", "AcceptedAnswerId": "1906168", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2009-12-15T08:40:02.633", "LastActivityDate": "2013-03-08T00:35:51.540", "LastEditDate": "2010-11-19T10:53:54.730", "ViewCount": "1619", "FavoriteCount": "1", "Title": "C++ by-reference argument and C linkage", "Id": "1906000", "Score": "12", "Body": "<p>I have encountered a working (with XLC8 and MSFT9 compilers) piece of code, containing a C++ file with a function defined with C linkage and a reference argument. This bugs me, as references are C++ only. The function in question is called from C code, where it is declared as taking a pointer argument to the same type in place of the reference argument.</p>\n<p><strong>Simplified example</strong>:</p>\n<p><em>C++ file</em>:</p>\n<pre><code>extern \"C\" void f(int &amp;i)\n{\n    i++;\n}\n</code></pre>\n<p><em>C file</em>:</p>\n<pre><code>void f(int *);\n\nint main()\n{\n    int a = 2;\n    f(&amp;a);\n    printf(\"%d\\n\", a);  /* Prints 3 */\n}\n</code></pre>\n<p>Now, the word on the street is that most C++ compilers, under the hood, implement references just like a pointer. Is it like that and just pure luck the reason this code works or does it say somewhere in the C++ specification what the result is when you define a function with a reference argument and C linkage? I haven't been able to find any information on this.</p>\n", "Tags": "<c++><c><pointers><compiler-construction><reference>", "OwnerUserId": "147808", "AnswerCount": "5"}, "1906112": {"ParentId": "1906000", "CommentCount": "1", "Body": "<p>A <em>reference</em> is an alternate name for an object. Technically, there is nothing in C that could map directly to a C++ reference. </p>\n<p>The obvious implementation of a reference is as a (constant) pointer that is dereferenced each time it is used.  So, depending on how your compiler implements references, your code might work. But it is not correct. </p>\n<p>The solution is to write a C function that receives either a real object or a pointer to that object and call the C++ function from this.</p>\n", "OwnerUserId": "133520", "PostTypeId": "2", "Id": "1906112", "Score": "3", "CreationDate": "2009-12-15T09:03:27.723", "LastActivityDate": "2009-12-15T09:03:27.723"}, "1906168": {"CommentCount": "5", "CreationDate": "2009-12-15T09:13:40.480", "CommunityOwnedDate": "2009-12-15T09:13:40.480", "LastEditorUserId": "226621", "LastActivityDate": "2009-12-15T09:36:46.027", "ParentId": "1906000", "PostTypeId": "2", "LastEditDate": "2009-12-15T09:36:46.027", "Id": "1906168", "Score": "4", "Body": "<p>My copy of n3000.pdf (from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/\" rel=\"nofollow noreferrer\">here</a>), has this to say in section 7.5\u2014<em>Linkage specifications</em>:</p>\n<blockquote>\n<p id=\"so_1906000_1906168_0\"><em>9</em>. Linkage from C++ to objects defined in\n  other languages and to objects defined\n  in C++ from other languages is\n  implementation-defined and\n  language-dependent. Only where the\n  object layout strategies of two\n  language implementations are similar\n  enough can such linkage be achieved.</p>\n</blockquote>\n<p>Since C and C++ are different languages, this means that you can't rely on this \"feature\" of common compilers.</p>\n<p>Stronger is note 5 in the same section (emphasis mine):</p>\n<blockquote>\n<p id=\"so_1906000_1906168_1\">If two declarations declare functions\n  with the same name and\n  parameter-type-list (8.3.5) to be\n  members of the same namespace or\n  declare objects with the same name to\n  be members of the same namespace and\n  the declarations give the names\n  different language linkages, the\n  program is ill-formed; <strong>no diagnostic\n  is required if the declarations appear\n  in different translation units</strong>.</p>\n</blockquote>\n<p>So, I would say that what you did is not guaranteed to work according to the standard, and the compiler is not required to print a diagnostic for the example you have given because <em>the declarations are in different translation units</em>.</p>\n<p>FYI, it \"works for me\" with gcc and g++ version 4.2.1 on Snow Leopard.</p>\n", "OwnerUserId": "226621"}, "1906161": {"ParentId": "1906000", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>That's what Bjarne Stroustrup has to say about references:</p>\n<blockquote>\n<p id=\"so_1906000_1906161_0\">\"<strong>Most references are implements are implemented using a pointer variable; that it a reference usually takes up one word of memory. However, a reference that is used purely locally can - and often is - eliminated by the optimizer</strong>\". </p>\n</blockquote>\n<p>For example:</p>\n<pre><code> struct S \n { \n    int a;\n    int b[100]; \n };  // just an example\n\n void do_something(const vector&lt;S&gt;&amp; v)\n {\n    for (int i=0; i&lt;v.size(); ++i)\n    {\n        int(&amp;p)[100] = v[i].b;\n        for (int j=0; j&lt;100; ++j) \n           cout &lt;&lt;p[j];\n    }\n }\n</code></pre>\n<p>In this case, p needs not be stored in memory (maybe it just exists in a register, maybe it disappears into the instructions).</p>\n", "OwnerUserId": "165520", "LastEditorUserId": "165520", "LastEditDate": "2009-12-15T12:25:47.977", "Id": "1906161", "Score": "0", "CreationDate": "2009-12-15T09:11:26.117", "LastActivityDate": "2009-12-15T12:25:47.977"}, "bq_ids": {"n4140": {"so_1906000_1906168_0": {"section_id": 5525, "quality": 0.92, "length": 23}, "so_1906000_1906168_1": {"section_id": 5521, "quality": 0.96875, "length": 31}}, "n3337": {"so_1906000_1906168_0": {"section_id": 5311, "quality": 0.92, "length": 23}, "so_1906000_1906168_1": {"section_id": 5307, "quality": 0.96875, "length": 31}}, "n4659": {"so_1906000_1906168_0": {"section_id": 6960, "quality": 0.92, "length": 23}, "so_1906000_1906168_1": {"section_id": 6956, "quality": 0.96875, "length": 31}}}});