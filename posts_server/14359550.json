post_cb({"14360071": {"LastActivityDate": "2013-01-16T14:03:32.483", "CommentCount": "1", "Body": "<p>If I do understand correctly what you are trying to achieve, <strong>it cannot be done</strong>. Let's consider an even <em>simpler case of <strong>illegal</strong> specialization</em>:</p>\n<pre><code>template &lt;typename T1, typename T2, void (T1::* FUNC)(const T2&amp;)&gt; struct list;\ntemplate &lt;typename T1, typename T2&gt; struct list&lt;T1, T2, 0&gt; { };\n</code></pre>\n<p>Here you always have to supply three arguments to instantiate your template, and you try to specialize the primary template for the case where the last argument is a null pointer.</p>\n<p>Per <strong>\u00a7 14.5.5/8</strong> of the C++ Standard:</p>\n<p><em>\"The type of a template parameter corresponding to a specialized non-type argument shall not be dependent on a parameter of the specialization. [ Example:</em></p>\n<pre><code>template &lt;class T, T t&gt; struct C {};\ntemplate &lt;class T&gt; struct C&lt;T, 1&gt;; // error\n\ntemplate&lt; int X, int (*array_ptr)[X] &gt; class A {};\nint array[5];\ntemplate&lt; int X &gt; class A&lt;X,&amp;array&gt; { }; // error\n</code></pre>\n<p><em>\u2014end example ]</em>\"</p>\n<p>You cannot specialize a non-type argument whose type is dependent on other types in the template parameter list. Thus, the above specialization is illegal.</p>\n<p>Your original design is just a <em>particular case</em> of this specialization, where the last (non-type) parameter has a default argument value, which you omit in the specialization (omitting it is legitimate <em>per se</em>). The reason why this is illegal is <strong>not</strong> related with the presence of a default argument, but rather with the fact that you are trying to specialize a <strong>non-type</strong> argument that <strong>has a dependent type</strong>.</p>\n", "CreationDate": "2013-01-16T13:57:57.020", "LastEditDate": "2013-01-16T14:03:32.483", "ParentId": "14359550", "Id": "14360071", "LastEditorUserId": "1932150", "PostTypeId": "2", "Score": "2", "OwnerUserId": "1932150"}, "bq_ids": {"n4140": {"so_14359550_14359550_0": {"length": 6, "quality": 0.6, "section_id": 142}}, "n3337": {"so_14359550_14359550_0": {"length": 6, "quality": 0.6, "section_id": 136}}}, "14359550": {"CreationDate": "2013-01-16T13:26:57.213", "ViewCount": "960", "Id": "14359550", "AcceptedAnswerId": "14360071", "Score": "1", "Title": "Specialize a template class with a member function pointer", "CommentCount": "4", "Body": "<p>I'm working with VS 2008 (sorry, can't update). I need template specialization for my list class. The argument I want to specialize is a member function pointer.</p>\n<p>In short, how can I make the following code work (I can' use variadic templates):</p>\n<pre><code>// two or three args\ntemplate &lt;typename T1, typename T2, void (T1::* FUNC)(const T2&amp;) = 0&gt; struct list;\n// specialized code for 2 args.\ntemplate &lt;typename T1, typename T2&gt; struct list&lt;T1, T2&gt; { };\n</code></pre>\n<p>The error message is:</p>\n<blockquote>\n<p id=\"so_14359550_14359550_0\">C2754: 'specialization' : a partial specialization cannot have a dependent non-type template parameter</p>\n</blockquote>\n<p>Maybe there is no solution for my problem. But that also an answer.</p>\n<p>Thanks for your help in advance.</p>\n", "Tags": "<c++><templates><visual-c++>", "LastActivityDate": "2013-01-16T14:03:32.483", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "1545267"}});