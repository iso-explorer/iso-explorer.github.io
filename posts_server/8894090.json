post_cb({"8894090": {"ViewCount": "7669", "Body": "<p>It seems to me that Derived class don't inherit base class Assignment operator<br>\nif Derived class inherit Base class assignment operator , can you please explain the following example  </br></p>\n<p>In the following code I am overriding base class operator= in Derived, so that Derived class default assignment operator calls overloaded operator= </p>\n<pre><code>#include &lt;iostream&gt;  \nusing namespace std;      \nclass Base  \n{  \n    public:  \n    Base(int lx = 0):x(lx)  \n    {  \n    }  \n\n    virtual Base&amp; operator=( const Base &amp;rhs)  \n    {  \n        cout &lt;&lt; \"calling Assignment operator in Base\" &lt;&lt; endl;  \n        return *this;  \n    }\n\n    private:  \n    int x;     \n};      \n\n\nclass Derived : public Base  \n{  \n    public:  \n    Derived(int lx, int ly): Base(lx),y(ly)  \n    {  \n    }\n\n    Base&amp; operator=(const Base &amp;rhs)  \n    {  \n        cout &lt;&lt; \"Assignment operator in Derived\"&lt;&lt; endl;  \n        return *this;  \n    }  \n\n    private:  \n    int y;    \n};  \n\n\n\nint main()  \n{  \n    Derived d1(10,20);  \n    Derived d2(30,40);  \n    d1 = d2;  \n}  \n</code></pre>\n<p>It gives the output</p>\n<blockquote>\n<p id=\"so_8894090_8894090_0\">calling Assignment operator in Base</p>\n</blockquote>\n<p>I have re-written base class operator= into derived class, so if derived class inherits base  class operator= then it should be get overridden by operator= (that i have written in derived  class), and now Derived class default operator= should call overridden version and not from  the base class operator=.  </p>\n", "Title": "Derived class inherit base class assignment operator?", "CreationDate": "2012-01-17T11:49:21.830", "LastActivityDate": "2014-10-15T05:36:11.790", "CommentCount": "0", "LastEditDate": "2012-01-17T12:49:02.533", "PostTypeId": "1", "LastEditorUserId": "514235", "Id": "8894090", "Score": "2", "OwnerUserId": "1145292", "Tags": "<c++><inheritance><assignment-operator>", "AnswerCount": "5"}, "8894228": {"Id": "8894228", "PostTypeId": "2", "Body": "<p>The compiler generates a default assignment operator for Derived (which hides the operator of Base). However, the default assignment operator calls all assignment operators of the class' members and base classes.</p>\n", "LastActivityDate": "2012-01-17T11:59:12.190", "CommentCount": "4", "CreationDate": "2012-01-17T11:59:12.190", "ParentId": "8894090", "Score": "4", "OwnerUserId": "597607"}, "8894143": {"Id": "8894143", "PostTypeId": "2", "Body": "<p>Yes it does it is just that the Base class <code>=</code> operator is hidden by the Derived class <code>=</code> operator.</p>\n", "LastActivityDate": "2012-01-17T11:52:30.043", "CommentCount": "1", "CreationDate": "2012-01-17T11:52:30.043", "ParentId": "8894090", "Score": "3", "OwnerUserId": "452307"}, "bq_ids": {"n4140": {"so_8894090_26375167_0": {"length": 54, "quality": 0.9642857142857143, "section_id": 473}}, "n3337": {"so_8894090_26375167_0": {"length": 54, "quality": 0.9642857142857143, "section_id": 464}}, "n4659": {"so_8894090_26375167_0": {"length": 54, "quality": 0.9642857142857143, "section_id": 496}}}, "26375167": {"Id": "26375167", "PostTypeId": "2", "Body": "<p>Quoting from the standard (12.8.24):</p>\n<blockquote>\n<p id=\"so_8894090_26375167_0\">Because a copy/move assignment operator is implicitly declared for a\n  class if not declared by the user, a base class copy/move assignment\n  operator is always hidden by the corresponding assignment operator of\n  a derived class (13.5.3). A using-declaration (7.3.3) that brings in\n  from a base class an assignment operator with a parameter type that\n  could be that of a copy/move assignment operator for the derived class\n  is not considered an explicit declaration of such an operator and does\n  not suppress the implicit declaration of the derived class operator;\n  the operator introduced by the using-declaration is hidden by the\n  implicitly-declared operator in the derived class.</p>\n</blockquote>\n", "LastActivityDate": "2014-10-15T05:36:11.790", "CommentCount": "0", "CreationDate": "2014-10-15T05:36:11.790", "ParentId": "8894090", "Score": "1", "OwnerUserId": "540815"}, "17028139": {"Id": "17028139", "PostTypeId": "2", "Body": "<p>If you wanted to achieve polymorfic behavior, this means to have your base method overriden, you should have written this: </p>\n<pre><code>int main (){\n    Derived * d1 = new Derived (10,20);  \n    Derived * d2 = new Derived (30,40);\n    Base * b1 = d1 ;\n    Base * b2 = d2 ; \n    *b1 = *b2 ;\n    *d1 = *d2 ;\n} \n</code></pre>\n<p>This will produce the following output: </p>\n<pre><code> $&gt; Assignment operator in Derived.\n $&gt; calling Assignment operator in Base. \n</code></pre>\n<p>So what i'm doing here it's using the c++ dynamic casting implicitly. I not completely sure if this works this way, but in order to make my point i think it will be useful. When i \ncall the assignment operator with b1 and b2 dereferenced, the program first look for an overriden method of the function invoked on the derived class if it doesn't find any then it calls the base method class. Now, when i call the assignment operator from d1 the program casts derived to base and there's no way the program could know that *d1 stands for a Derived object, so it calls the base method. </p>\n<p>That's all folks. </p>\n", "LastActivityDate": "2013-06-10T16:02:20.620", "CommentCount": "0", "CreationDate": "2013-06-10T16:02:20.620", "ParentId": "8894090", "Score": "0", "OwnerUserId": "2444139"}, "8894861": {"Id": "8894861", "PostTypeId": "2", "Body": "<p>Unless I misunderstand what you want to achieve, you need an assignment operator for class <code>Derived</code>, i.e. one that takes <code>Derived</code> as the input:</p>\n<pre><code>class Derived : public Base  \n{  \n/* ... */\npublic:\n    Derived&amp; operator=(const Derived &amp;rhs)  \n    {  \n        cout &lt;&lt; \"Assignment operator in Derived\"&lt;&lt; endl;  \n        return *this;  \n    }\n};  \n</code></pre>\n<p>What happened within your code (already explained in the answer of Bo Persson and comments there):\nin <code>Derived</code>, you implemented an assignment operator that takes an instance of <code>Base</code>; but in <code>main()</code> you assign an instance of <code>Derived</code>; the compiler saw no assignment operator for <code>Derived</code> (the one that takes <code>Base</code> does not count), and so it generated one, which calls <code>Base::operator=()</code> and then assignments for <code>Derived</code>'s data members. If you defined the assignment as shown above, it would not happen and your operator would be called; notice that in this case assignments of <code>Base</code> and data members would not happen automatically.</p>\n<hr>\n<p>A different situation is if you really wish to have an assignment from <code>Base</code> to <code>Derived</code>, e.g. to use it with other derivatives of <code>Base</code>. Then the operator you defined will work, but in order to apply it to an instance of <code>Derived</code>, you need to cast this instance to <code>Base</code>:</p>\n<pre><code>Derived d1(10,20);  \nDerived d2(30,40);  \nd1 = static_cast&lt;Base&amp;&gt;(d2);\n</code></pre>\n<p>Needless to say that the operator you defined cannot easily access data members of <code>rhs</code> specific to <code>Derived</code>: e.g. to use <code>rhs.y</code> you would need to \"up-cast\" <code>rhs</code> to <code>Derived</code>:</p>\n<pre><code>Derived&amp; Derived::operator=(const Base&amp; rhs)\n{\n    /* ... */\n    Derived* rhs_d = dynamic_cast&lt;Derived*&gt;(&amp;rhs);\n    if( rhs_d )\n        this-&gt;y = rhs_d-&gt;y;\n}\n</code></pre>\n</hr>", "LastActivityDate": "2012-01-17T12:48:04.000", "CommentCount": "0", "CreationDate": "2012-01-17T12:48:04.000", "ParentId": "8894090", "Score": "0", "OwnerUserId": "654891"}});