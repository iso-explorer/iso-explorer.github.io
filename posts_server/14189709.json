post_cb({"14189720": {"Id": "14189720", "PostTypeId": "2", "Body": "<p>It's the same as not being able to take the address of <code>5</code> even though you can take the address of an <code>int</code> after giving it the value <code>5</code>. It doesn't matter that there's no alternative value for a <code>nullptr_t</code> to have.</p>\n<p>Values don't have addresses; objects do.</p>\n<p>A temporary object is generated when you pass such a value to a <code>const &amp;</code> parameter, or otherwise bind a value to a const reference, such as by <code>static_cast&lt; T const &amp; &gt;( \u2026 )</code> or declaring a named reference <code>T const &amp; foo = \u2026;</code>. The address you're seeing is that of the temporary.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2016-10-17T04:02:02.377", "Score": "78", "CreationDate": "2013-01-07T04:03:29.113", "ParentId": "14189709", "CommentCount": "4", "OwnerUserId": "153285", "LastEditDate": "2016-10-17T04:02:02.377"}, "14189755": {"Id": "14189755", "PostTypeId": "2", "Body": "<p><code>nullptr</code> is a (literal) constant, and these don't have a memory address, like any other literal constant in your code. It's similar to <code>0</code>, but of the special <code>std::nullptr_t</code> type instead of <code>void*</code> to avoid problems with overloading (pointers vs. integers).</p>\n<p>But if you define your own variable with the value <code>nullptr</code>, it has a memory address, so you can take its address.</p>\n<p>The same holds for any other literal constant (which in C++ fall under the category <em>prvalue</em>) of any other type, since literal constants aren't <em>stored</em> in your program (only as parts of expressions where they occur), that's why it doesn't make any sense to talk about addresses. However, constant <em>variables</em> do have addresses, to point out the difference.</p>\n", "LastEditorUserId": "592323", "LastActivityDate": "2013-12-13T23:19:58.847", "Score": "10", "CreationDate": "2013-01-07T04:09:45.443", "ParentId": "14189709", "CommentCount": "0", "OwnerUserId": "592323", "LastEditDate": "2013-12-13T23:19:58.847"}, "14189709": {"ViewCount": "2716", "Body": "<p>In the C++11 standard, I don't understand the reason why taking the address of nullptr is disallowed whereas one <strong>is</strong> allowed to take the address of their own std::nullptr_t instances. Aside from the fact that nullptr is a reserved keyword, is there any designated reasoning for this decision?</p>\n<p>Simply because it amuses me, I attempted to circumnavigate this restriction with the following function:</p>\n<pre><code>decltype(nullptr)* func(const decltype(nullptr) &amp;nref) noexcept\n{\n    return const_cast&lt;decltype(nullptr)*&gt;(reinterpret_cast&lt;const decltype(nullptr)*&gt;(&amp;nref));\n}\n</code></pre>\n<p>I had to use reinterpret_cast on the parameter because without it I was getting the hysterical error:</p>\n<pre><code>error: invalid conversion from 'std::nullptr_t*' to 'std::nullptr_t*' [-fpermissive]\n</code></pre>\n<p>When I call this function by passing <strong>nullptr</strong> directly I get a different address each time. Is nullptr dynamically assigned an address just-in-time for comparisons and such? Or (probably more likely) perhaps is the compiler forcing a temporary copy of the underlying object?</p>\n<p>Of course none of this is vital information, I just find it interesting why this particular restriction was implemented (and subsequently why I am seeing the behavior I am).</p>\n", "AcceptedAnswerId": "14189720", "Title": "Why can't you take the address of nullptr?", "CreationDate": "2013-01-07T04:02:12.157", "Id": "14189709", "CommentCount": "1", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2016-10-17T04:02:02.377", "Score": "41", "OwnerUserId": "1136311", "Tags": "<c++><c++11><std><nullptr>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_14189709_14189818_0": {"length": 12, "quality": 1.0, "section_id": 6711}, "so_14189709_14189818_2": {"length": 20, "quality": 0.8, "section_id": 7230}, "so_14189709_14189818_1": {"length": 7, "quality": 0.875, "section_id": 5366}}, "n3337": {"so_14189709_14189818_0": {"length": 12, "quality": 1.0, "section_id": 6466}, "so_14189709_14189818_2": {"length": 20, "quality": 0.8, "section_id": 6974}, "so_14189709_14189818_1": {"length": 7, "quality": 0.875, "section_id": 5162}}, "n4659": {"so_14189709_14189818_0": {"length": 12, "quality": 1.0, "section_id": 8179}, "so_14189709_14189818_1": {"length": 7, "quality": 0.875, "section_id": 6791}}}, "14189818": {"Id": "14189818", "PostTypeId": "2", "Body": "<p>If you're after a standard answer, \u00a7 18.2/9 puts your observations pretty bluntly:</p>\n<blockquote>\n<p id=\"so_14189709_14189818_0\">Although nullptr\u2019s address cannot be taken, the address of another nullptr_t object that is an lvalue can\n  be taken.</p>\n</blockquote>\n<p>Alternatively, \u00a7 2.14.7 says this about <code>nullptr</code>:</p>\n<blockquote>\n<p id=\"so_14189709_14189818_1\">The pointer literal is the keyword nullptr. It is a prvalue of type std::nullptr_t.</p>\n</blockquote>\n<p>So what is a prvalue? \u00a7 3.10/1 answers that:</p>\n<blockquote>\n<p id=\"so_14189709_14189818_2\">A prvalue (\u201cpure\u201d rvalue) is an rvalue that is not an xvalue. [ Example: The result of calling a function\n  whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is\n  also a prvalue. \u2014 end example ]</p>\n</blockquote>\n<p>Hopefully, trying to take the address of any of those things in the example will make more sense as to why you can't take the address of <code>nullptr</code>. It's part of those examples!</p>\n", "LastActivityDate": "2013-01-07T04:18:33.713", "CommentCount": "6", "CreationDate": "2013-01-07T04:18:33.713", "ParentId": "14189709", "Score": "27", "OwnerUserId": "962089"}, "14193323": {"Id": "14193323", "PostTypeId": "2", "Body": "<p>Both true and false are keywords and as literals they have a type ( bool ). nullptr is a pointer literal of type std::nullptr_t, and it's a prvalue (you cannot take the address of it using &amp;), also nullptr is prvalue so you can't take its address,literal constants are not stored in your program.</p>\n<p><strong>It doesn't make sense to have address.</strong></p>\n", "LastEditorUserId": "1248266", "LastActivityDate": "2013-01-07T21:36:59.560", "Score": "4", "CreationDate": "2013-01-07T09:43:20.257", "ParentId": "14189709", "CommentCount": "0", "OwnerUserId": "1248266", "LastEditDate": "2013-01-07T21:36:59.560"}});