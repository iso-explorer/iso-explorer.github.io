post_cb({"bq_ids": {"n4140": {"so_30011740_30014205_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 7126}, "so_30011740_30014205_3": {"length": 28, "quality": 0.9655172413793104, "section_id": 177}, "so_30011740_30014205_4": {"length": 7, "quality": 0.5833333333333334, "section_id": 195}, "so_30011740_30014205_2": {"length": 37, "quality": 0.9736842105263158, "section_id": 72}}, "n3337": {"so_30011740_30014205_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 6870}, "so_30011740_30014205_2": {"length": 37, "quality": 0.9736842105263158, "section_id": 67}, "so_30011740_30014205_4": {"length": 7, "quality": 0.5833333333333334, "section_id": 189}, "so_30011740_30014205_3": {"length": 28, "quality": 0.9655172413793104, "section_id": 171}}, "n4659": {"so_30011740_30014205_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 8627}, "so_30011740_30014205_4": {"length": 7, "quality": 0.5833333333333334, "section_id": 201}, "so_30011740_30014205_3": {"length": 28, "quality": 0.9655172413793104, "section_id": 182}}}, "30014205": {"Id": "30014205", "PostTypeId": "2", "Body": "<h3>Short version</h3>\n<p>Don't rely on this. Use the <code>template</code> keyword as you're supposed to, don't try such an obscure hack only to avoid a few keystrokes. Your code should definitely not compile according to the standard, and the example you quoted from <a href=\"http://en.cppreference.com/w/cpp/language/dependent_name#The_template_disambiguator_for_dependent_names\" rel=\"nofollow\">cppreference.com</a> may soon become explicitly disallowed as well (I don't think it was valid in the first place). GCC and Clang yield different results for both these examples. Even if they compile today, they may fail tomorrow in the next compiler version.</p>\n<h3>Long version</h3>\n<p>Regarding the example from <a href=\"http://en.cppreference.com/w/cpp/language/dependent_name#The_template_disambiguator_for_dependent_names\" rel=\"nofollow\">cppreference.com</a>, let's first note that Clang 3.6.0 compiles the code, but GCC 5.1.0 rejects both <code>s.set&lt;T&gt;()</code> and <code>s.template set&lt;T&gt;()</code> with the error <code>invalid use of 'class std::set&lt;T&gt;'</code>. I don't think either of the two compilers does the right thing here according to the standard, but, intuitively, GCC's error message makes a lot of sense: what would be the meaning of <code>s.set&lt;T&gt;()</code> with <code>set&lt;T&gt;</code> being a class template specialization?</p>\n<p>With your code, it's the other way around: Clang rejects it (the error message quoted in the question seems to be actually from Clang) and GCC compiles it.</p>\n<p>The examples rely on paragraph [3.4.5p1] in the standard (emphasis mine in all quotes):</p>\n<blockquote>\n<p id=\"so_30011740_30014205_0\">In a class member access expression (5.2.5), if the . or -&gt; token is\n  immediately followed by an identifier followed by a &lt;, the identifier\n  must be looked up to determine whether the &lt; is the beginning of a\n  template argument list (14.2) or a less-than operator. The identifier\n  is first looked up in the class of the object expression. If the\n  identifier is not found, it is then looked up in the context of the\n  entire postfix-expression and shall name a <strong>class</strong> template.</p>\n</blockquote>\n<p>The <em>class template</em> part is the reason for your code being rejected by Clang (your <code>func</code> is a <em>function template</em>). Function templates were removed from there as the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#141\" rel=\"nofollow\">defect 141</a>, included in C++11. It's worth mentioning a comment in the defect report:</p>\n<blockquote>\n<p id=\"so_30011740_30014205_1\">There do not seem to be any circumstances in which use of a non-member\n  template function would be well-formed as the id-expression of a class\n  member access expression.</p>\n</blockquote>\n<p>I think this says something about the intent of this lookup rule: it's supposed to find constructs that are <em>well formed</em>; it's not intended to just make the parser happy about those <code>&lt;&gt;</code> with some temporary match that will later be replaced by something else with entirely different semantics.</p>\n<p>Even with the special lookup rule above, I'm not sure the standard allows you to omit the <code>template</code> in such cases. Paragraph [14.2p4] says:</p>\n<blockquote>\n<p id=\"so_30011740_30014205_2\">When the name of a member template specialization appears after . or\n  -&gt; in a postfix-expression or after a nested-name-specifier in a qualified-id, and the object expression of the postfix-expression is\n  type-dependent or the nested-name-specifier in the qualified-id refers\n  to a dependent type, but the name is not a member of the current\n  instantiation (14.6.2.1), the member template name <strong>must</strong> be prefixed by\n  the keyword <code>template</code>. Otherwise the name is assumed to name a\n  non-template.</p>\n</blockquote>\n<p>Both member templates <code>set</code> and <code>func</code> in the two examples satisfy the conditions in there, respectively. As you can see, there's no mention of an exception to this rule.</p>\n<p>Or, to put it another way, if you want <code>set</code> to be resolved as the name for the member template, it has to have <code>template</code> in front of it. If it doesn't, it can be resolved as the namespace-scope <code>set</code>, but then the <code>set</code> name itself is no longer a name dependent on template parameters (<code>set&lt;T&gt;</code> is still dependent, but <code>set</code> itself is not). And then we get to [14.6p10], which says:</p>\n<blockquote>\n<p id=\"so_30011740_30014205_3\">If a name does not depend on a template-parameter (as defined in\n  14.6.2), a declaration (or set of declarations) for that name shall be in scope at the point where the name appears in the template\n  definition; the name is bound to the declaration (or declarations)\n  found at that point and this binding is not affected by declarations\n  that are visible at the point of instantiation.</p>\n</blockquote>\n<p>Once bound, it's carved in stone and the later switch to the member template is not valid, which makes the <a href=\"http://en.cppreference.com/w/cpp/language/dependent_name#The_template_disambiguator_for_dependent_names\" rel=\"nofollow\">cppreference.com</a> example incorrect.</p>\n<p>Moreover, there's an open issue regarding the applicability of the lookup rule from [3.4.5p1] to such examples - <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1835\" rel=\"nofollow\">issue 1835</a>. Quoting a note in there:</p>\n<blockquote>\n<p id=\"so_30011740_30014205_4\">One possibility might be to limit the lookup to the class of the\n  object expression when the object expression is dependent.</p>\n</blockquote>\n<p>The issue is in <em>drafting</em> status, which means <em>informal consensus has been reached in the working group</em>. Exactly what that consensus was remains to be seen, but I'd say there's a good chance that something will change. Relying on such code doesn't seem like a good idea.</p>\n<hr>\n<p>The quoted paragraphs have remained unchanged since C++11 up to the current working draft (N4431).</p>\n</hr>", "LastEditorUserId": "4326278", "LastActivityDate": "2015-05-04T11:13:03.633", "Score": "3", "CreationDate": "2015-05-03T13:11:44.360", "ParentId": "30011740", "CommentCount": "2", "OwnerUserId": "4326278", "LastEditDate": "2015-05-04T11:13:03.633"}, "30011740": {"ViewCount": "389", "Body": "<p>This issue is based on section <a href=\"http://en.cppreference.com/w/cpp/language/dependent_name\">C++ reference : dependent name - The template disambiguator for dependent name</a>. </p>\n<p>I have understood when invoking the template member function in a template class, the keyword template is necessary to make the compiler know the following bracket is used for indicating template argument.just like the used example in this section.</p>\n<pre><code>template&lt;typename T&gt;\nstruct S {\n    template&lt;typename U&gt; void foo(){}\n};\n\ntemplate&lt;typename T&gt;\nvoid bar()\n{\n    S&lt;T&gt; s;\n    s.foo&lt;T&gt;(); // error: &lt; parsed as less than operator\n    s.template foo&lt;T&gt;(); // OK\n}\n</code></pre>\n<p>However, in the consequent part it describes <strong>when a template name appears in a member access expression (after -&gt; or after .), the disambiguator is unnecessary if there is a template with the same name found by ordinary lookup in the context of the expression.</strong>.</p>\n<p>Then it comes with the following code. Comparing with previous example it defines set function whose name exists in standard library as well. At the meanwhile, <strong>using std::set</strong> is set up to make set template visible in template function.\nIn this condition, even if keyword template is not provided it still works well.</p>\n<pre><code>#include &lt;set&gt;\nusing std::set; // makes 'set' visible to lookup from bar\n\ntemplate&lt;typename T&gt; \nstruct S { \n    template&lt;typename U&gt; void set(){}\n};\n\ntemplate&lt;typename T&gt;\nvoid bar()\n{\n    S&lt;T&gt; s;\n    s.set&lt;T&gt;(); // not an error if ::set is visible:\n                // (and since C++11, this is well-formed)\n    s.template set&lt;T&gt;(); // works with and without ::set\n}\n</code></pre>\n<p>Based on my understanding, I tried my own version </p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt; \nstruct S{\n    template &lt;typename U&gt; void func(){\n        std::cout &lt;&lt; \"In S::func\\n\";\n    }\n};\n\n// In order to make member template function is visible in function test,\n// defining a global template function **func** whose name is same with one \n// member template function in struct S.\ntemplate &lt;typename M&gt;\nvoid func(){\n    std::cout &lt;&lt; \"from ordinary func\\n\";\n}\n\ntemplate &lt;typename M&gt;\nvoid test(){\n    S&lt;M&gt; s;\n    func&lt;M&gt;();     // test func template function is visible in test function\n    s.func&lt;M&gt;();     \n}\nint main(){    \n    test&lt;int&gt;();\n}\n</code></pre>\n<p>The detail error message is listed as follows</p>\n<pre><code>[17:17:50][ryu@C++_test]$ g++ -g typename2.cpp \ntypename2.cpp:61:7: error: use 'template' keyword to treat 'func' as a dependent\n      template name\n    s.func&lt;M&gt;();\n      ^\n      template \n1 error generated.\n</code></pre>\n<p>Any advice is appreciated on how to make my own code works well without keyword template.</p>\n", "AcceptedAnswerId": "30014205", "Title": "The template disambiguator for dependent names", "CreationDate": "2015-05-03T08:28:43.080", "Id": "30011740", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2015-05-04T11:13:03.633", "Score": "7", "OwnerUserId": "2006805", "Tags": "<c++><templates><c++11>", "AnswerCount": "1"}});