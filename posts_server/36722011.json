post_cb({"36722651": {"Id": "36722651", "PostTypeId": "2", "Body": "<p><code>explicit</code> blocks implicit conversion <em>to your type</em>.</p>\n<p>Your <code>=delete</code> technique blocks implicit conversion from <code>long</code> to <code>long long</code>.</p>\n<p>These are almost unrelated.</p>\n<p>There are 4 cases that illustrate the difference:</p>\n<pre><code>Z z = 1L;\nZ z = 1LL;\n</code></pre>\n<p>is an implicit conversion from <code>long</code> and <code>long long</code> to <code>Z</code>.</p>\n<pre><code>Z z = Z(1L);\nZ z = Z(1LL);\n</code></pre>\n<p>is an explicit conversion from <code>long</code> and <code>long long</code> to <code>Z</code>.</p>\n<p><code>explicit Z(long long)</code> blocks:</p>\n<pre><code>Z z = 1L;\nZ z = 1LL;\n</code></pre>\n<p>while <code>Z(long)=delete</code> blocks:</p>\n<pre><code>Z z = 1L;\nZ z = Z(1L);\n</code></pre>\n<p><code>explicit Z(long long)</code> allows <code>Z z = Z(1L)</code> because the conversion from <code>long</code> to <code>long long</code> is implicit, but unrelated to the explicit conversion to <code>Z</code> that happens afterwards.</p>\n<p>Note that a mixture of <code>explicit</code> and <code>=delete</code> leaves only <code>Z z=Z(1LL)</code> as valid among your 4 versions.</p>\n<p>(the above presumes a valid copy or move ctor; if not, replace <code>Z z=Z(...)</code> with <code>Z z(...)</code> and the same conclusions result).</p>\n", "LastActivityDate": "2016-04-19T15:19:15.723", "Score": "5", "CreationDate": "2016-04-19T15:19:15.723", "ParentId": "36722011", "CommentCount": "0", "OwnerUserId": "1774667"}, "36722189": {"Id": "36722189", "PostTypeId": "2", "Body": "<p>No, they're not the same. <code>explicit</code> disallows implicit conversions to that type if that constructor is selected - implicit conversions in arguments don't matter. <code>delete</code> disallows any construction if that constructor is selected, and can be used to disallow implicit <em>argument</em> conversion.</p>\n<p>So for instance:</p>\n<pre><code>struct X {\n    explicit X(int ) { }\n};\n\nvoid foo(X ) { }\n\nfoo(4);      // error, because X's constructor is explicit\nfoo(X{3});   // ok\nfoo(X{'3'}); // ok, this conversion is fine\n</code></pre>\n<p>That is separate from <code>delete</code>ing a constructor:</p>\n<pre><code>struct Y {\n    Y(int ) { }\n    Y(char ) = delete;\n};\n\nvoid bar(Y ) { }\n\nbar(4);      // ok, implicit conversion to Y since this constructor isn't explicit\nbar('4');    // error, this constructor is deleted\nbar(Y{'4'}); // error, doesn't matter that we're explicit\n</code></pre>\n<p>The two techniques are also orthogonal. If you want a type to not be implicitly-convertible <em>and</em> only constructible from exactly an <code>int</code>, you can do both:</p>\n<pre><code>struct W {\n    explicit W(int ) { }\n\n    template &lt;class T&gt;\n    W(T ) = delete;\n};\n\nvoid quux(W );\n\nquux(4);      // error, constructor is explicit\nquux('4');    // error, constructor is deleted\nquux(4L);     // error, constructor is deleted\nquux(W{'4'}); // error, constructor is deleted\nquux(W{5});   // ok\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-04-19T15:09:43.330", "Score": "24", "CreationDate": "2016-04-19T15:00:05.707", "ParentId": "36722011", "CommentCount": "5", "LastEditDate": "2016-04-19T15:09:43.330", "OwnerUserId": "2069064"}, "36722177": {"Id": "36722177", "PostTypeId": "2", "Body": "<p>They're not identical.</p>\n<pre><code>Z z = 1LL;\n</code></pre>\n<p>The above works with the non-explicit version, but not with the explicit version.</p>\n<p>Declaring constructor of <code>Z</code> explicit doesn't prevent conversion of the constructor argument from another type. It prevents the conversion from the argument to <code>Z</code> without calling the constructor explicitly.</p>\n<p>Below is an example of explicit constructor call.</p>\n<pre><code>Z z = Z(1LL);\n</code></pre>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2016-04-19T15:09:26.357", "Score": "17", "CreationDate": "2016-04-19T14:59:47.113", "ParentId": "36722011", "CommentCount": "1", "LastEditDate": "2016-04-19T15:09:26.357", "OwnerUserId": "2079303"}, "bq_ids": {"n4140": {"so_36722011_36722513_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 389}, "so_36722011_36722513_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 388}}, "n3337": {"so_36722011_36722513_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 380}, "so_36722011_36722513_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 379}}, "n4659": {"so_36722011_36722513_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 406}, "so_36722011_36722513_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 405}}}, "36722011": {"ViewCount": "1625", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/language/explicit\">here</a>, <code>explicit</code>:</p>\n<blockquote>\n<p id=\"so_36722011_36722011_0\">Specifies constructors and conversion operators (since C++11) that\n  don't allow implicit conversions or copy-initialization.</p>\n</blockquote>\n<p>Thus, are these two techniques identical?</p>\n<pre><code>struct Z {\n        // ...\n        Z(long long);     // can initialize with a long long\n        Z(long) = delete; // but not anything smaller\n};\n\nstruct Z {\n        // ...\n        explicit Z(long long);     // can initialize ONLY with a long long\n};\n</code></pre>\n", "AcceptedAnswerId": "36722177", "Title": "Prevent undesired conversion in constructor", "CreationDate": "2016-04-19T14:53:40.930", "Id": "36722011", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-04-19T17:30:14.610", "LastEditorUserId": "213685", "LastActivityDate": "2016-04-19T17:30:14.610", "Score": "17", "OwnerUserId": "3758484", "Tags": "<c++><c++11><explicit-constructor>", "AnswerCount": "5"}, "36722315": {"Id": "36722315", "PostTypeId": "2", "Body": "<pre><code>struct Zb {\n        Zb(long long)\n        {};     // can initialize with a long long\n        Zb(long) = delete; // but not anything smaller\n    };\n\nstruct Za {\n        // ...\n        explicit Za(long long)\n        {};     // can initialize ONLY with a long long\n    };\n\nint main()\n{\n    Za((long long)10);  // works\n    Za((long)10);       // works    \n\n    Zb((long long)10);  // works\n    Zb((long)10);       // does not work\n\n    return 0;\n}\n</code></pre>\n<p>Your example requires explicit deleting.</p>\n<p>Live: <a href=\"http://cpp.sh/4sqb\" rel=\"nofollow\">http://cpp.sh/4sqb</a></p>\n", "LastActivityDate": "2016-04-19T15:05:18.567", "Score": "2", "CreationDate": "2016-04-19T15:05:18.567", "ParentId": "36722011", "CommentCount": "0", "OwnerUserId": "4873907"}, "36722513": {"Id": "36722513", "PostTypeId": "2", "Body": "<p>They are not the same.</p>\n<p>From the standard working draft <code>n4296</code>:</p>\n<blockquote>\n<p id=\"so_36722011_36722513_0\"><code>12.3.1 - [class.conv.ctor]:</code><br>\n<sup>1 </sup> A constructor declared <em>without</em> the function-specifier explicit specifies a conversion from the types of its\n  parameters to the type of its class. Such a constructor is called a <em>converting constructor</em>.<br/></br></p>\n<p id=\"so_36722011_36722513_1\"><sup>2</sup> An explicit constructor constructs objects just like non-explicit constructors, but does so only where the\n  direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used. A default constructor\n  may be an explicit constructor; such a constructor will be used to perform default-initialization or valueinitialization\n  (8.5).</p>\n</blockquote>\n<p>Followed by an example of each one respectively:</p>\n<pre><code>struct X {\n    X(int);\n    X(const char*, int =0);\n    X(int, int);\n};\n\nvoid f(X arg) {\n    X a = 1;        // a = X(1)\n    X b = \"Jessie\"; // b = X(\"Jessie\",0)\n    a = 2;          // a = X(2)\n    f(3);           // f(X(3))\n    f({1, 2});      // f(X(1,2))\n}\n</code></pre>\n<p>With explicit constructor:</p>\n<pre><code>struct Z {\n    explicit Z();\n    explicit Z(int);\n    explicit Z(int, int);\n};\n\nZ a;                      // OK: default-initialization performed\nZ a1 = 1;                 // error: no implicit conversion\nZ a3 = Z(1);              // OK: direct initialization syntax used\nZ a2(1);                  // OK: direct initialization syntax used\nZ* p = new Z(1);          // OK: direct initialization syntax used\nZ a4 = (Z)1;              // OK: explicit cast used\nZ a5 = static_cast&lt;Z&gt;(1); // OK: explicit cast used\nZ a6 = { 3, 4 };          // error: no implicit conversion\n</code></pre>\n", "LastEditorUserId": "3677097", "LastActivityDate": "2016-04-19T15:47:54.027", "Score": "1", "CreationDate": "2016-04-19T15:13:33.723", "ParentId": "36722011", "CommentCount": "0", "LastEditDate": "2016-04-19T15:47:54.027", "OwnerUserId": "3677097"}});