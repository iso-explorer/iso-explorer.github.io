post_cb({"30490746": {"ParentId": "30490592", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The primary (perhaps sole) time that floating point promotions are applied is when passing an argument to a variadic function (e.g., <code>printf</code>).</p>\n<p>In this case, the usual arithmetic conversions don't apply (they're for finding a common type between two operands in an expression).</p>\n<p>The relevant part of the standard is [expr.call]/7 (at least as of N4296):</p>\n<blockquote>\n<p id=\"so_30490592_30490746_0\">When there is no parameter for a given argument, the argument is passed in such a way that the receiving function can obtain the value of the argument by invoking va_arg (18.10).\n  <br>[...]<br>\n  If the argument has integral or enumeration type that is subject to the integral promotions (4.5), or a floating point type that is subject to the floating point promotion (4.6), the value of the argument is converted to the promoted type before the call.</br></br></p>\n</blockquote>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2015-05-27T19:11:57.843", "Id": "30490746", "Score": "6", "CreationDate": "2015-05-27T18:47:39.357", "LastActivityDate": "2015-05-27T19:11:57.843"}, "30490592": {"CommentCount": "3", "ViewCount": "333", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-05-27T18:40:00.083", "LastActivityDate": "2016-08-18T05:04:16.227", "Title": "No really, when does floating point promotion actually happen?", "AcceptedAnswerId": "30490916", "LastEditDate": "2017-05-23T12:14:56.743", "Id": "30490592", "Score": "8", "Body": "<p>From this other <a href=\"https://stackoverflow.com/questions/17215484/floating-point-promotion-stroustrup-vs-compiler-who-is-right\">QUESTION</a> they talk about how Bjarne Stroustrup said that just as integral data-types narrower than an <code>int</code>(e.g. <code>short</code>) are promoted to an <code>int</code>, <code>float</code>s are promoted to a <code>double</code>. However, unlike widening of integrals narrower than an <code>int</code>, <strong><em>floating point promotion</em></strong> does not happen in the same way, but instead, occurs elsewhere.</p>\n<p>I know that if you were to compute <code>float + double</code> the <code>float</code> would be converted to a <code>double</code> before the binary operator(<code>+</code>) is applied. However, this is not <strong><em>floating point promotion</em></strong> according to <a href=\"http://www.learncpp.com/cpp-tutorial/44-implicit-type-conversion-coercion/\" rel=\"nofollow noreferrer\">Learncpp.com</a>. This is <strong><em>usual arithmetic conversion</em></strong>.</p>\n<p>When does floating point promotion actually happen?</p>\n", "Tags": "<c++><floating-point><promotions>", "OwnerUserId": "4750730", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_30490592_30490746_0": {"section_id": 5994, "quality": 0.9743589743589743, "length": 38}, "so_30490592_30490916_1": {"section_id": 0, "quality": 0.6666666666666666, "length": 4}, "so_30490592_30490916_0": {"section_id": 28, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_30490592_30490746_0": {"section_id": 5762, "quality": 0.9743589743589743, "length": 38}, "so_30490592_30490916_1": {"section_id": 0, "quality": 0.6666666666666666, "length": 4}, "so_30490592_30490916_0": {"section_id": 25, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_30490592_30490746_0": {"section_id": 7496, "quality": 0.8717948717948718, "length": 34}, "so_30490592_30490916_0": {"section_id": 28, "quality": 0.9090909090909091, "length": 10}}}, "30490916": {"ParentId": "30490592", "CommentCount": "1", "Body": "<p>There is such a thing as \"floating point promotion\" of <code>float</code> to <code>double</code> per [conv.fpprom].</p>\n<blockquote>\n<p id=\"so_30490592_30490916_0\">A prvalue of type <code>float</code> can be converted to a prvalue of type <code>double</code>. The value is unchanged.</p>\n<p id=\"so_30490592_30490916_1\">This conversion is called <em>floating point promotion.</em></p>\n</blockquote>\n<p>The answers to the linked question are correct. This promotion should not occur automatically when adding two <code>float</code>s since the usual arithmetic conversions do not promote floating-point operands.</p>\n<p>Floating point promotion <em>does</em> occur when passing a <code>float</code> as an operand to an ellipsis, like in <code>printf</code>. That's why the <code>%f</code> format specifier prints either a <code>float</code> or a <code>double</code>: if you pass a <code>float</code>, the function actually receives a <code>double</code>, the result of promotion.</p>\n<p>The existence of the floating point promotion is also important in overload resolution, because integral <em>promotions</em> and floating point <em>promotions</em> have better implicit conversion rank than integral <em>conversions</em>, floating point <em>conversions</em>, and floating-integral <em>conversions</em>.</p>\n<p>Example 1:</p>\n<pre><code>void f(double);\nvoid f(long double);\nf(0.0f);\n</code></pre>\n<p>This calls <code>void f(double)</code> since the promotion to <code>double</code> is better than the conversion to <code>long double</code>. In contrast, consider this perhaps surprising example 2:</p>\n<pre><code>void f(long double);\nvoid f(int);\nf(0.0f);\n</code></pre>\n<p>This is ambiguous. The conversion from <code>float</code> to <code>long double</code> is no better than the conversion from <code>float</code> to <code>int</code> since they are both not promotions.</p>\n<p>Example 3:</p>\n<pre><code>struct S {\n    operator float();\n    operator int();\n};\ndouble d = S();\n</code></pre>\n<p>This calls <code>operator float</code> and then promotes the resulting <code>float</code> value to <code>double</code> to initialize <code>d</code>.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "30490916", "Score": "13", "CreationDate": "2015-05-27T18:57:37.953", "LastActivityDate": "2015-05-27T18:57:37.953"}});