post_cb({"bq_ids": {"n4140": {"so_4492062_25157623_0": {"length": 29, "quality": 0.8055555555555556, "section_id": 5485}, "so_4492062_4492524_0": {"length": 27, "quality": 1.0, "section_id": 5485}}, "n3337": {"so_4492062_4492524_0": {"length": 27, "quality": 1.0, "section_id": 5271}}, "n4659": {"so_4492062_4492524_0": {"length": 20, "quality": 0.7407407407407407, "section_id": 6920}, "so_4492062_25157623_0": {"length": 29, "quality": 0.8055555555555556, "section_id": 6920}}}, "25157623": {"Id": "25157623", "PostTypeId": "2", "Body": "<p>Let's take into account these 3 code lines from your sample:</p>\n<pre><code>1. friend class F; // it creates \"friend declaration\", (that's not the same as ordinary forward declaration\n\n2. class F; // without this forward declaration, F can't be friend to A::C &lt;-- this is ordinary forward declaration\n\n3. friend class ::F; // this is qualified lookup (because of ::), so it needs previous declaration, which you provide in line 2.\n</code></pre>\n<p><strong>C++ standard in paragraph 7.3.1.2, point 3 ( Namespace member definitions)</strong> says:</p>\n<blockquote>\n<p id=\"so_4492062_25157623_0\">The friend declaration does not by itself make the name visible to\n  unqualified lookup (3.4.1) or qualified lookup (3.4.3). [ Note: The\n  name of the friend will be visible in its namespace if a matching\n  declaration is provided at namespace scope (either before or after the\n  class definition granting friendship). \u2014end note ]</p>\n</blockquote>\n<p>And line 2 follows exactly what standard requires.</p>\n<p>All confusion is because \"friend declaration\" is <em>weak</em>, you need to provide solid forward declaration for further usage.</p>\n", "LastActivityDate": "2014-08-06T10:08:55.143", "CommentCount": "0", "CreationDate": "2014-08-06T10:08:55.143", "ParentId": "4492062", "Score": "3", "OwnerUserId": "210971"}, "4492062": {"ViewCount": "19011", "Body": "<p>Suppose I have a class <code>F</code> that should be friend to the classes <code>G</code> (in the global namespace) and <code>C</code> (in namespace <code>A</code>).</p>\n<ul>\n<li>to be friend to <code>A::C</code>, <code>F</code> must be forward declared.</li>\n<li>to be friend to <code>G</code>, no forward declaration of <code>F</code> is necessary.</li>\n<li>likewise, a class <code>A::BF</code> can be friend to <code>A::C</code> without forward declaration</li>\n</ul>\n<p>The following code illustrates this and compiles with GCC 4.5, VC++ 10 and at least with one other compiler.</p>\n<pre><code>class G {\n    friend class F;\n    int g;\n};\n\n// without this forward declaration, F can't be friend to A::C\nclass F;\n\nnamespace A {\n\nclass C {\n    friend class ::F;\n    friend class BF;\n    int c;\n};\n\nclass BF {\npublic:\n    BF() { c.c = 2; }\nprivate:\n    C c;\n};\n\n} // namespace A\n\nclass F {\npublic:\n    F() { g.g = 3; c.c = 2; }\nprivate:\n    G g;\n    A::C c;\n};\n\nint main()\n{\n    F f;\n}\n</code></pre>\n<p>To me this seems inconsistent. Is there a reason for this or is it just a design decision of the standard?</p>\n", "AcceptedAnswerId": "4492524", "Title": "Why does a C++ friend class need a forward declaration only in other namespaces?", "CreationDate": "2010-12-20T17:15:01.733", "Id": "4492062", "CommentCount": "0", "FavoriteCount": "20", "PostTypeId": "1", "LastActivityDate": "2014-08-06T10:08:55.143", "Score": "41", "OwnerUserId": "3686", "Tags": "<c++><namespaces><friend><forward-declaration>", "AnswerCount": "3"}, "4492511": {"Id": "4492511", "PostTypeId": "2", "Body": "<p>Because it wouldn't make sense to be able to declare something in the global namespace if you're inside a <code>namespace {}</code> block. The reason <code>friend class BF;</code> works is that it acts like an implicit forward declaration.</p>\n", "LastActivityDate": "2010-12-20T18:11:27.730", "CommentCount": "0", "CreationDate": "2010-12-20T18:11:27.730", "ParentId": "4492062", "Score": "1", "OwnerUserId": "82320"}, "4492524": {"Id": "4492524", "PostTypeId": "2", "Body": "<p><code>C++</code> Standard <code>ISO/IEC 14882:2003(E)</code></p>\n<p><strong>7.3.1.2  Namespace member definitions</strong></p>\n<p><em>Paragraph 3</em></p>\n<blockquote>\n<p id=\"so_4492062_4492524_0\">Every name first declared in a\n  namespace is <strong><em>a member of that\n  namespace</em></strong>.  If a friend declaration in\n  a non-local class first declares a\n  class or function \n  (this implies that the name of the class or function is unqualified) the friend class\n  or function is a member of the\n  innermost enclosing namespace.</p>\n<pre><code>// Assume f and g have not yet been defined.\nvoid h(int);\ntemplate &lt;class T&gt; void f2(T);\nnamespace A {\n   class X {\n   friend void f(X);  //  A::f(X) is a friend\n      class Y {\n         friend void g();  //  A::g is a friend\n         friend void h(int);  //  A::h is a friend\n         //  ::h not considered\n         friend void f2&lt;&gt;(int);  //  ::f2&lt;&gt;(int) is a friend\n      };\n   };\n   //  A::f, A::g and A::h are not visible here\n   X x;\n   void g() { f(x); }  // definition of A::g\n   void f(X) { /* ... */}  // definition of A::f\n   void h(int) { /* ... */ }  // definition of A::h\n   //  A::f, A::g and A::h are visible here and known to be friends\n}\n</code></pre>\n</blockquote>\n<p>Your <code>friend class BF;</code> is a declaration of <code>A::BF</code> in namespace A rather than global namespace. You need the global prior declaration to avoid this new declaration.</p>\n", "LastActivityDate": "2010-12-20T18:12:29.717", "CommentCount": "3", "CreationDate": "2010-12-20T18:12:29.717", "ParentId": "4492062", "Score": "40", "OwnerUserId": "124161"}});