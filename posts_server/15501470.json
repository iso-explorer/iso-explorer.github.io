post_cb({"15502379": {"Id": "15502379", "PostTypeId": "2", "Body": "<p>GCC is correct; that <code>const</code> in VS's template argument list should not be there:</p>\n<blockquote>\n<p id=\"so_15501470_15502379_0\"><code>[C++11: 14.8.2/3]:</code> After this substitution is performed, the function parameter type adjustments described in 8.3.5 are performed. <em>[ Example:</em> A parameter type of <code>\u201cvoid ()(const int, int[5])\u201d</code> becomes <code>\u201cvoid(*)(int,int*)\u201d</code>. <em>\u2014end example ]</em> <strong><em>[ Note:</em> A top-level qualifier in a function parameter declaration does not affect the function\n  type but still affects the type of the function parameter variable within the function. <em>\u2014end note ]</em></strong> <em>[ Example:</em></p>\n<pre><code>template &lt;class T&gt; void f(T t);\ntemplate &lt;class X&gt; void g(const X x);\ntemplate &lt;class Z&gt; void h(Z, Z*);\n\nint main() {\n  // #1: function type is f(int), t is non const\n  f&lt;int&gt;(1);\n\n  // #2: function type is f(int), t is const\n  f&lt;const int&gt;(1);\n\n  // #3: function type is g(int), x is const\n  g&lt;int&gt;(1);\n\n  // #4: function type is g(int), x is const\n  g&lt;const int&gt;(1);\n\n  // #5: function type is h(int, const int*)\n  h&lt;const int&gt;(1,0);\n}\n</code></pre>\n<p id=\"so_15501470_15502379_1\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>(Example 4 is the pertinent one.)</p>\n<blockquote>\n<p id=\"so_15501470_15502379_2\"><code>[C++11: 14.8.2/5]:</code> <strong>The resulting substituted and adjusted function type is used as the type of the function template for template argument deduction.</strong> <em>[..]</em></p>\n</blockquote>\n<p>Also possibly relevant:</p>\n<blockquote>\n<p id=\"so_15501470_15502379_3\"><strong>Deducing template arguments from a function call</strong><br>\n<code>[C++11: 14.8.2.1/2]:</code> If <code>P</code> is not a reference type:</br></p>\n<ul>\n<li>If <code>A</code> is an array type, the pointer type produced by the array-to-pointer standard conversion (4.2) is used in place of <code>A</code> for type deduction; otherwise,</li>\n<li>If <code>A</code> is a function type, the pointer type produced by the function-to-pointer standard conversion (4.3) is used in place of <code>A</code> for type deduction; otherwise,</li>\n<li><strong>If <code>A</code> is a cv-qualified type, the top level <em>cv-qualifiers</em> of <code>A</code>\u2019s type are ignored for type deduction</strong></li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "560648", "LastActivityDate": "2013-03-19T14:45:12.010", "Score": "1", "CreationDate": "2013-03-19T14:35:37.773", "ParentId": "15501470", "CommentCount": "16", "OwnerUserId": "560648", "LastEditDate": "2013-03-19T14:45:12.010"}, "bq_ids": {"n4140": {"so_15501470_15504781_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 7226}, "so_15501470_15504781_0": {"length": 6, "quality": 1.0, "section_id": 304}, "so_15501470_15504781_1": {"length": 12, "quality": 1.0, "section_id": 305}, "so_15501470_15504781_3": {"length": 13, "quality": 0.7222222222222222, "section_id": 3228}, "so_15501470_15502379_3": {"length": 5, "quality": 0.5555555555555556, "section_id": 95}, "so_15501470_15502379_2": {"length": 11, "quality": 0.7857142857142857, "section_id": 297}, "so_15501470_15502379_0": {"length": 35, "quality": 0.7777777777777778, "section_id": 295}}, "n3337": {"so_15501470_15502379_0": {"length": 35, "quality": 0.7777777777777778, "section_id": 286}, "so_15501470_15504781_0": {"length": 6, "quality": 1.0, "section_id": 295}, "so_15501470_15504781_1": {"length": 12, "quality": 1.0, "section_id": 296}, "so_15501470_15502379_3": {"length": 5, "quality": 0.5555555555555556, "section_id": 90}, "so_15501470_15504781_3": {"length": 13, "quality": 0.7222222222222222, "section_id": 3101}, "so_15501470_15504781_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 6970}, "so_15501470_15502379_2": {"length": 11, "quality": 0.7857142857142857, "section_id": 288}}, "n4659": {"so_15501470_15502379_0": {"length": 35, "quality": 0.7777777777777778, "section_id": 302}, "so_15501470_15504781_0": {"length": 6, "quality": 1.0, "section_id": 311}, "so_15501470_15504781_1": {"length": 12, "quality": 1.0, "section_id": 312}, "so_15501470_15502379_3": {"length": 5, "quality": 0.5555555555555556, "section_id": 99}, "so_15501470_15504781_3": {"length": 15, "quality": 0.8333333333333334, "section_id": 3985}, "so_15501470_15504781_2": {"length": 8, "quality": 0.6666666666666666, "section_id": 8736}, "so_15501470_15502379_2": {"length": 11, "quality": 0.7857142857142857, "section_id": 304}}}, "15501470": {"ViewCount": "240", "Body": "<p>Suppose we have the following code:</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(const T&amp;);\n\nint main()\n{\n   foo(\"str\");\n}\n</code></pre>\n<p><a href=\"http://liveworkspace.org/code/4Gagz0%240\">Demonstration</a></p>\n<p><strong>gcc 4.7.2, clang 3.2, icc 13.0.1</strong></p>\n<blockquote>\n<p id=\"so_15501470_15501470_0\">undefined reference to `void foo&lt;<strong>char</strong> [4]&gt;(char const (&amp;) [4])'</p>\n</blockquote>\n<p><strong>MSVC-11.0</strong></p>\n<blockquote>\n<p id=\"so_15501470_15501470_1\">unresolved external symbol \"void __cdecl foo&lt;<strong>char const</strong> [4]&gt;(char\n  const (&amp;)[4])\" (??$foo@$$BY03$$CBD@@YAXAAY03$$CBD@Z)</p>\n</blockquote>\n<p>Notice <code>char[4]</code> in the first output and <code>char const[4]</code> in the second output.</p>\n<p>Why? And who's right? Can you quote the standard, please?</p>\n", "Title": "String literal in templates - different behavior of compilers", "CreationDate": "2013-03-19T13:56:12.457", "LastActivityDate": "2013-03-19T23:29:01.697", "CommentCount": "10", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-03-19T16:21:53.520", "LastEditorUserId": "1932150", "Id": "15501470", "Score": "12", "OwnerUserId": "1608835", "Tags": "<c++><templates><language-lawyer>", "AnswerCount": "2"}, "15504781": {"Id": "15504781", "PostTypeId": "2", "Body": "<p><strong>GCC is right.</strong></p>\n<p>Let's start from a slightly simpler example, and later prove that the original example follows the same pattern:</p>\n<pre><code>template&lt;typename T&gt;\nvoid bar(T const&amp;)\n{\n    // Shall not fire\n    static_assert(std::is_same&lt;T, int&gt;::value, \"Error!\");\n}\n\nint main()\n{\n    int x = 0;\n    bar(x); // 1 - Assertion won't fire\n\n    int const y = 0;\n    bar(y); // 2 - Assertion won't fire\n}\n</code></pre>\n<p>What's happening here? First of all, per \u00a7 14.8.2.1/3:</p>\n<blockquote>\n<p id=\"so_15501470_15504781_0\">[...] If P is a reference type, the type referred to by P is used for type deduction. [...]</p>\n</blockquote>\n<p>This means that type deduction will try to match <code>T const</code> against <code>int</code> (in case 1) and against <code>int const</code> (in case 2). In the second case, substituting <code>int</code> for <code>T</code> will yield a perfect match, so that's easy; in the first case, we have the <code>const</code> getting on our way to have a perfect match. But this is where \u00a7 14.8.2.1/4 comes into play:</p>\n<blockquote>\n<p id=\"so_15501470_15504781_1\">[...] <strong>If the original P is a reference type</strong>, the deduced A (i.e., the type referred to by the reference) <strong>can be\n  more cv-qualified</strong> than the transformed A. [...]</p>\n</blockquote>\n<p>Here, replacing <code>int</code> for <code>T</code> gives us a deduced <code>int const</code>, which is more cv-qualified than <code>int</code> (the type of the argument <code>x</code>). But that is acceptable because of \u00a7 14.8.2.1/4 above, so even in this case <code>T</code> is deduced to be <code>int</code>.</p>\n<p>Let's now tackle your original example (just slightly adjusted, but we'll get to the original version eventually):</p>\n<pre><code>template&lt;typename T&gt;\nvoid bar(T const&amp;)\n{\n    // Does not fire in GCC, fires in VC11. Who's right?\n    static_assert(std::is_same&lt;T, char[4]&gt;::value, \"Error!\");\n}\n\nint main()\n{\n    char x[] = \"foo\";\n    bar(x);\n\n    char const y[] = \"foo\";\n    bar(y);\n}\n</code></pre>\n<p>Apart from the fact that I replaced <code>int</code> with <code>char []</code>, this is example and my first example are identical in structure. To see why this equivalence holds, consider the assertion below (which doesn't fire on <em>any</em> compiler, as expected):</p>\n<pre><code>// Does not fire\nstatic_assert(\n    std::is_same&lt;\n        std::add_const&lt;char [4]&gt;::type,\n        char const[4]\n    &gt;::value, \"Error\");\n</code></pre>\n<p>The C++11 Standard mandates this behavior in Paragraph 3.9.3/2: </p>\n<blockquote>\n<p id=\"so_15501470_15504781_2\">Any cv-qualifiers applied to an array type affect the array element type, not the array type (8.3.4).</p>\n</blockquote>\n<p>Paragraph 8.3.4/1 also specifies:</p>\n<blockquote>\n<p id=\"so_15501470_15504781_3\">[...] Any type of the form \u201ccv-qualifier-seq array of N T\u201d is adjusted to \u201carray\n  of N cv-qualifier-seq T\u201d, and similarly for \u201carray of unknown bound of T\u201d. The optional attribute-specifier-seq\n  appertains to the array. [ Example:</p>\n</blockquote>\n<pre><code>typedef int A[5], AA[2][3];\ntypedef const A CA; // type is \u201carray of 5 const int\u201d\ntypedef const AA CAA; // type is \u201carray of 2 array of 3 const int\u201d\n</code></pre>\n<blockquote>\n<p id=\"so_15501470_15504781_4\">\u2014end example ] [ Note: An \u201carray of N cv-qualifier-seq T\u201d has cv-qualified type; see 3.9.3. \u2014end note ]</p>\n</blockquote>\n<p>Since it is now clear that the two examples exhibit the same pattern, it makes sense to apply the same logic. And that will lead us through the very same reasoning path.</p>\n<p>While performing type deduction, <code>T const</code> is matched against <code>char[4]</code> in the first case and against <code>char const[4]</code> in the second case.</p>\n<p>In the second case, <code>T = char[4]</code> yields a perfect match, because <code>T const</code> becomes <code>char const[4]</code> after the substitution. In the first case, the deduced <code>A</code> is once again more cv-qualified than the original <code>A</code>, in that substituting <code>char[4]</code> for <code>T</code> yields <code>char const[4]</code>. But then again, that is allowed by 14.8.2.1/4, so <code>T</code> should be deduced as <code>char[4]</code>.</p>\n<p>Finally, back to your original example. Since the string literal <code>\"str\"</code> also has type <code>char const[4]</code>, <code>T</code> should be deduced to be <code>char [4]</code>, which means that <strong>GCC is right</strong>:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T const&amp;)\n{\n    // Shall not fire\n    static_assert(std::is_same&lt;T, char[4]&gt;::value, \"Error!\");\n}\n\nint main()\n{\n    foo(\"str\"); // Shall not trigger the assertion\n}\n</code></pre>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-03-19T23:29:01.697", "Score": "5", "CreationDate": "2013-03-19T16:15:37.907", "ParentId": "15501470", "CommentCount": "3", "OwnerUserId": "1932150", "LastEditDate": "2013-03-19T23:29:01.697"}});