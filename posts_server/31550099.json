post_cb({"31550099": {"CommentCount": "9", "ViewCount": "658", "PostTypeId": "1", "LastEditorUserId": "4774918", "CreationDate": "2015-07-21T21:39:24.333", "LastActivityDate": "2015-07-21T22:11:02.267", "Title": "memory overhead of malloc() vs new[]", "LastEditDate": "2015-07-21T21:41:40.570", "Id": "31550099", "Score": "3", "Body": "<p>I want to reserve a block of memory (1GB) to load data into it for analysis. Each record is about 10K bytes and there is at least 100k records. Originally I was going to use malloc in c++ code but I was advised against it.</p>\n<p>Now, will using char * block = new char[1000000000] require additional memory to store the pointers to each of the 1,000,000,000 elements in the array? Will using char * block = malloc(1000000000 * sizeof(char)) require less additional memory to create than new[]?</p>\n<p>My goal is to use the least amount of memory possible and don't want to be swamping records in and out of memory. </p>\n<p>Thanks :)</p>\n", "Tags": "<c++><memory><malloc>", "OwnerUserId": "1886067", "AnswerCount": "5"}, "31550355": {"ParentId": "31550099", "CommentCount": "2", "Body": "<p>In order for <code>operator delete[]</code> to work correctly with non-PODs, the size of the array (a single <code>size_t</code>) is usually placed at the beginning of the whole block, and the first object at the first appropriately-aligned address.</p>\n<p>For PODs, <code>operator new[]</code> (without an initializer) is generally the same as a <code>malloc</code>.</p>\n<p>With an initializer (again, with a POD type), the results depend on the compiler: It could translate to a loop over the elements, or reduce to a <code>memset</code>.</p>\n<p>Given the large amount of memory you intend to allocate, the results of <code>malloc</code> depend on the runtime - some implementations have a hard upper limit on the block size.</p>\n<p>If you are targeting Windows, you can use <code>VirtualAlloc</code> for something this size. Likewise, use <code>mmap</code> on *nix.</p>\n", "OwnerUserId": "368519", "PostTypeId": "2", "Id": "31550355", "Score": "2", "CreationDate": "2015-07-21T21:59:15.440", "LastActivityDate": "2015-07-21T21:59:15.440"}, "31550359": {"ParentId": "31550099", "CommentCount": "0", "Body": "<p><code>new[N]</code> is reserving a little bit more than asked. It stores counter [N] at the beginning (to know how much destructors it needs to call with delete[])  and returns a memory block just after it. </p>\n", "OwnerUserId": "4029982", "PostTypeId": "2", "Id": "31550359", "Score": "0", "CreationDate": "2015-07-21T21:59:34.180", "LastActivityDate": "2015-07-21T21:59:34.180"}, "31550398": {"ParentId": "31550099", "CommentCount": "0", "Body": "<p>You asked:</p>\n<blockquote>\n<p id=\"so_31550099_31550398_0\">Now, will using <code>char * block = new char[1000000000]</code> require additional memory to store the pointers to each of the 1,000,000,000 elements in the array?</p>\n</blockquote>\n<p>Definitely not.</p>\n<p>From the C++11 Standard (Section 5.3.4 New)</p>\n<blockquote>\n<p id=\"so_31550099_31550398_1\">5 When the allocated object is an array (that is, the <em>noptr-new-declarator</em> syntax is used or the <em>new-type-id</em> or <em>type-id</em> denotes an array type), the new-expression yields a pointer to the initial element (if any) of the array.</p>\n</blockquote>\n<p>The key piece from that is that you get back <strong>a pointer to the initial element (if any) of the array</strong></p>\n<p>You also asked:</p>\n<blockquote>\n<p id=\"so_31550099_31550398_2\">Will using <code>char * block = malloc(1000000000 * sizeof(char))</code> require less additional memory to create than <code>new[]</code>?</p>\n</blockquote>\n<p>The standard does not specify anything about the overhead associated with using either allocation methods. In most implementations, the memory overhead associated with the two methods should be about the same if not exactly the same. I will be surprised if that is not true.</p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "31550398", "Score": "1", "CreationDate": "2015-07-21T22:01:33.457", "LastActivityDate": "2015-07-21T22:01:33.457"}, "31550380": {"ParentId": "31550099", "CommentCount": "0", "Body": "<p>If you use <code>new</code> to allocate an array of characters you will get an array of characters. There will not be additional pointers for each element.  You just get a large contiguious area of memory similar to what you would get with <code>malloc()</code>.</p>\n<p>What <code>new</code> will do is allocate the memory and then call the constructor which in your case will do nothing of any consequence since this is just an array of Plain Old Data.</p>\n<p>I ran a quick check using Visual Studio 2013 with a debug compile and looking at the memory allocation in Windows Task Manager as I stepped over first the <code>new</code> and then the <code>malloc()</code> and the numbers looked about the same for the memory allocation at each step.</p>\n<p>With such a large memory area you may run into page faults as the operating system pages your large memory area in and out as various parts of the memory area are accessed. Not sure that you can really do anything about that nor am I sure that it is a big worry.  Partly any swapping behavior will depend on the amount of physical memory you have along with the mix of additional services and applications and their memory usage.</p>\n", "OwnerUserId": "1466970", "PostTypeId": "2", "Id": "31550380", "Score": "0", "CreationDate": "2015-07-21T22:01:00.457", "LastActivityDate": "2015-07-21T22:01:00.457"}, "31550341": {"ParentId": "31550099", "LastEditDate": "2015-07-21T22:11:02.267", "CommentCount": "2", "CreationDate": "2015-07-21T21:58:35.290", "OwnerUserId": "1084774", "LastEditorUserId": "1084774", "PostTypeId": "2", "Id": "31550341", "Score": "2", "Body": "<p>On my Linux machine:</p>\n<h1>Malloc</h1>\n<pre><code>//malloc.cc\n#include &lt;cstdlib&gt;\nint main() { char* block = (char*) malloc(1000000000); }\n</code></pre>\n<h3>Runtime:</h3>\n<pre><code>$ make malloc\n$ valgrind ./malloc 2&gt;&amp;1|grep total\n==23855==   total heap usage: 1 allocs, 0 frees, 1,000,000,000 bytes allocated\n</code></pre>\n<h1>New</h1>\n<pre><code>//new.cc\nint main() { char* block = new char[1000000000]; }\n</code></pre>\n<h3>Runtime:</h3>\n<pre><code>$ make new\n$ valgrind ./new 2&gt;&amp;1|grep total\n  ==24460==   total heap usage: 2 allocs, 0 frees, 1,000,072,704 bytes allocated\n</code></pre>\n<p>The 72,704B overhead remains constant for different values.</p>\n", "LastActivityDate": "2015-07-21T22:11:02.267"}, "bq_ids": {"n4140": {"so_31550099_31550398_1": {"section_id": 6086, "quality": 1.0, "length": 17}}, "n3337": {"so_31550099_31550398_1": {"section_id": 5854, "quality": 1.0, "length": 17}}, "n4659": {"so_31550099_31550398_1": {"section_id": 7582, "quality": 1.0, "length": 17}}}});