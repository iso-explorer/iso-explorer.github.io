post_cb({"11934478": {"ParentId": "11933999", "CommentCount": "4", "Body": "<p>Workaround:</p>\n<pre><code>typedef  bool (A::*MemFn)(void) const;\n\nbool A::hasGrandChild() const {\n    MemFn f = &amp;A::hasChild;\n    return any_of(childs_.begin(), childs_.end(), [=](A const &amp;a) {\n            return (a.*f)();\n    });\n}\n</code></pre>\n", "OwnerUserId": "148897", "PostTypeId": "2", "Id": "11934478", "Score": "3", "CreationDate": "2012-08-13T12:41:57.473", "LastActivityDate": "2012-08-13T12:41:57.473"}, "11933999": {"CommentCount": "7", "AcceptedAnswerId": "12086873", "PostTypeId": "1", "LastEditorUserId": "426288", "CreationDate": "2012-08-13T12:06:19.767", "LastActivityDate": "2015-05-29T07:11:12.563", "LastEditDate": "2014-01-20T08:33:29.270", "ViewCount": "4895", "FavoriteCount": "2", "Title": "Why is it not possible to use private method in a lambda?", "Id": "11933999", "Score": "19", "Body": "<p>Having a class like this:</p>\n<pre><code>class A {\npublic:\n    bool hasGrandChild() const;\n\nprivate:\n    bool hasChild() const;\n    vector&lt;A&gt; children_;\n};\n</code></pre>\n<p>Why is it not possible to use a private method <code>hasChild()</code> in a lambda expression defined in the method <code>hasGrandChild()</code> like this?</p>\n<pre><code>bool A::hasGrandChild() const {\n    return any_of(children_.begin(), children_.end(), [](A const &amp;a) {\n        return a.hasChild();\n    });\n}\n</code></pre>\n<p>Compiler issues an error that the method <code>hasChild()</code> is private within the context. Is there any workaround?</p>\n<p><strong>Edit:</strong>\nIt seems that the code as I posted it originally works. I thought that it is equivalent, but the code that <a href=\"http://ideone.com/zKUsF\" rel=\"noreferrer\">does not work on GCC</a> is more like this:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass Foo;\n\nclass BaseA {\nprotected:\n    bool hasChild() const { return !children_.empty(); }\n    std::vector&lt;Foo&gt; children_;\n};\n\nclass BaseB {\nprotected:\n    bool hasChild() const { return false; }\n};\n\nclass Foo : public BaseA, public BaseB {\npublic:\n  bool hasGrandChild() const {\n    return std::any_of(children_.begin(), children_.end(), [](Foo const &amp;foo) {\n        return foo.BaseA::hasChild();\n      });\n  }  \n};\n\nint main()\n{\n  Foo foo;\n  foo.hasGrandChild();\n  return 0;\n}\n</code></pre>\n<p>Seems that there is a problem with fully qualified names as <a href=\"http://ideone.com/DJezf\" rel=\"noreferrer\">this does not work</a>, but <a href=\"http://ideone.com/zGtYI\" rel=\"noreferrer\">this works</a>.</p>\n", "Tags": "<c++><c++11><lambda>", "OwnerUserId": "426288", "AnswerCount": "5"}, "12086873": {"ParentId": "11933999", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It seems to be just a GCC bug in a special case when the lambda tries to access a protected member from parent class using fully qualified name. <a href=\"http://ideone.com/DJezf\" rel=\"noreferrer\">This does not work</a>:</p>\n<pre><code>class Base {\nprotected:\n    bool hasChild() const { return !childs_.empty(); }\n    std::vector&lt;Foo&gt; childs_;\n};\n\nclass Foo : public Base {\npublic:\n  bool hasGrandChild() const {\n    return std::any_of(childs_.begin(), childs_.end(), [](Foo const &amp;foo) {\n      return foo.Base::hasChild();\n    });\n  }  \n};\n</code></pre>\n<p>, but <a href=\"http://ideone.com/zGtYI\" rel=\"noreferrer\">this works</a>:</p>\n<pre><code>class Foo : public Base {\npublic:\n  bool hasGrandChild() const {\n    return std::any_of(childs_.begin(), childs_.end(), [](Foo const &amp;foo) {\n      return foo.hasChild();\n    });\n  }  \n};\n</code></pre>\n<p>According to C++11, 5.1.2/3:</p>\n<blockquote>\n<p id=\"so_11933999_12086873_0\">The type of the lambda-expression (which is also the type of the\n  closure object) is a unique, unnamed non-union class type \u2014 called the\n  closure type \u2014 whose properties are described below. This class type\n  is not an aggregate (8.5.1). <strong>The closure type is declared in the\n  smallest block scope, class scope, or namespace scope that contains\n  the corresponding lambda-expression</strong>.</p>\n</blockquote>\n<p>And then C++11, 11.7/1:</p>\n<blockquote>\n<p id=\"so_11933999_12086873_1\">A nested class is a member and as such has the same access rights as\n  any other member.</p>\n</blockquote>\n<p>So the mentioned function-local lambda should have the same access rights as any other member of the class. Therefore it should be able to call a protected method from a parent class.</p>\n", "OwnerUserId": "426288", "LastEditorUserId": "426288", "LastEditDate": "2015-05-29T07:11:12.563", "Id": "12086873", "Score": "27", "CreationDate": "2012-08-23T07:38:02.560", "LastActivityDate": "2015-05-29T07:11:12.563"}, "11934015": {"ParentId": "11933999", "CommentCount": "0", "Body": "<p>It isn't possible because the lambda is not a part of the class. It's the same as making an out-of-class function, and calling it instead of creating a lambda. Of course it doesn't have access to private members.</p>\n", "OwnerUserId": "1490355", "PostTypeId": "2", "Id": "11934015", "Score": "0", "CreationDate": "2012-08-13T12:07:57.697", "LastActivityDate": "2012-08-13T12:07:57.697"}, "11934046": {"ParentId": "11933999", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The standard (C++11, \u00a75.1.2/3) states that</p>\n<blockquote>\n<p id=\"so_11933999_11934046_0\">The type of the lambda-expression (which is also the type of the\n  closure object) is a unique, unnamed non-union class type \u2014 called\n  the <em>closure type</em>.</p>\n</blockquote>\n<p>Since it's a unique class type that is not a <code>friend</code> of <code>A</code>, it doesn't have access to <code>A</code>'s private members.</p>\n<p>What the compiler does here is create a class type that has appropriate members to store any captured variables, an appropriate <code>operator()</code> etc -- which is exactly what you would write yourself if you wanted to emulate lambdas in C++03. This type would certainly not have access to <code>private</code> members, which might make it easier to visualize why the limitation exists <strike>and why there is no workaround</strike>.</p>\n<p><strong>Update</strong> regarding possible workarounds:</p>\n<p>It would be better to say \"there are no workarounds using a lambda\", because in general workarounds do exist although they require that you forgo the convenient lambda syntax. For example, you could:</p>\n<ol>\n<li>Write a local class type that explicitly captures <code>this</code> along with any other locals it requires (inspired by Bj\u00f6rn Pollex's comment below).</li>\n<li>Write a <code>private</code> method instead of a lambda and pass that as the callback (e.g. using <code>std::bind</code> for convenience). If you want to capture locals in addition to <code>this</code> you can use more <code>std::bind</code> at the call site to do so.</li>\n</ol>\n", "OwnerUserId": "50079", "LastEditorUserId": "50079", "LastEditDate": "2012-08-13T12:31:50.557", "Id": "11934046", "Score": "9", "CreationDate": "2012-08-13T12:10:05.710", "LastActivityDate": "2012-08-13T12:31:50.557"}, "12117178": {"ParentId": "11933999", "CommentCount": "0", "Body": "<p>You can capture <code>this</code> explicitly and make it a \"member lambda\" that has access to private members.</p>\n<p>For example, consider the following sample:</p>\n<pre><code>#include &lt;iostream&gt;\nclass A {\nprivate:\n    void f() { std::cout &lt;&lt; \"Private\"; }\npublic:\n    void g() { \n        [this] { \n            f(); \n            // doesn't need qualification \n        }(); \n    }\n};\nclass B {\nprivate:\n    void f() { std::cout &lt;&lt; \"Private\"; }\npublic:\n    void g() { [] { f(); }(); } // compiler error\n};\nint main() {\n    A a;\n    a.g();\n}\n</code></pre>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "12117178", "Score": "3", "CreationDate": "2012-08-24T21:58:47.123", "LastActivityDate": "2012-08-24T21:58:47.123"}, "bq_ids": {"n4140": {"so_11933999_12086873_0": {"section_id": 5962, "quality": 0.868421052631579, "length": 33}, "so_11933999_12086873_1": {"section_id": 6700, "quality": 1.0, "length": 9}, "so_11933999_11934046_0": {"section_id": 5962, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_11933999_12086873_0": {"section_id": 5731, "quality": 0.868421052631579, "length": 33}, "so_11933999_12086873_1": {"section_id": 6455, "quality": 1.0, "length": 9}, "so_11933999_11934046_0": {"section_id": 5731, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_11933999_12086873_1": {"section_id": 8174, "quality": 1.0, "length": 9}, "so_11933999_11934046_0": {"section_id": 7451, "quality": 0.8666666666666667, "length": 13}}}});