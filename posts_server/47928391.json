post_cb({"bq_ids": {"n4140": {"so_47928391_47928555_2": {"length": 72, "quality": 0.9863013698630136, "section_id": 223}, "so_47928391_47928555_1": {"length": 54, "quality": 0.9818181818181818, "section_id": 219}}, "n3337": {"so_47928391_47928555_2": {"length": 72, "quality": 0.9863013698630136, "section_id": 216}, "so_47928391_47928555_1": {"length": 54, "quality": 0.9818181818181818, "section_id": 212}}, "n4659": {"so_47928391_47928555_2": {"length": 73, "quality": 1.0, "section_id": 231}, "so_47928391_47928555_1": {"length": 54, "quality": 0.9818181818181818, "section_id": 227}}}, "47928547": {"Id": "47928547", "PostTypeId": "2", "Body": "<p>If you read a little closer, the problem is with the <em>deletion</em> of the contained <code>Data</code> object. The</p>\n<blockquote id=\"so_47928391_47928547_0\">\n<pre><code>get_deleter()(__ptr)\n</code></pre>\n</blockquote>\n<p>part is the big hint.</p>\n<p>What happens here is that the unique pointer object <code>m</code> goes out of scope at the end of the <code>main</code> function, so the data pointed to needs to be deleted. However, since there is no destructor the default deleter can not handle it.</p>\n<p>To solve it you can add a definition of the structure, which will make it defined and the default deleter will be able to know the type. <em>Or</em> you could add a new deleter for the pointer, one which (in this case) might do nothing:</p>\n<pre><code>auto null_deleter = [](Data*){ /* Do nothing */ };\n...\nstd::unique_ptr&lt;Data, decltype(null_deleter)&gt; m = make_me();\n</code></pre>\n<p>Of course, if you want to actually delete the data, then either define the structure or modify the deleter so it <code>delete</code> the pointer (which makes it <em>need</em> the full structure definition anyway, but then the deleter could be defined in another tranaslation-unit, probably the same where <code>make_me</code> is defined).</p>\n", "LastActivityDate": "2017-12-21T15:59:12.120", "CommentCount": "1", "CreationDate": "2017-12-21T15:59:12.120", "ParentId": "47928391", "Score": "5", "OwnerUserId": "440558"}, "47928391": {"ViewCount": "730", "Body": "<p>Code:</p>\n<pre><code>#include &lt;memory&gt;\n\nstruct Data;\nstd::unique_ptr&lt;Data&gt; make_me();\n\nint main()\n{\n    std::unique_ptr&lt;Data&gt; m = make_me();\n    return 0;\n}\n</code></pre>\n<p>Which of course fails:</p>\n<pre><code>In file included from &lt;source&gt;:1:\nIn file included from /opt/compiler-explorer/gcc-7.1.0/lib/gcc/x86_64-linux-gnu/7.1.0/../../../../include/c++/7.1.0/memory:80:\n/opt/compiler-explorer/gcc-7.1.0/include/c++/7.1.0/bits/unique_ptr.h:76:16: error: invalid application of 'sizeof' to an incomplete type 'Data'\n        static_assert(sizeof(_Tp)&gt;0,\n                      ^~~~~~~~~~~\n/opt/compiler-explorer/gcc-7.1.0/include/c++/7.1.0/bits/unique_ptr.h:268:4: note: in instantiation of member function 'std::default_delete&lt;Data&gt;::operator()' requested here\n          get_deleter()(__ptr);\n          ^\n8 : &lt;source&gt;:8:31: note: in instantiation of member function 'std::unique_ptr&lt;Data, std::default_delete&lt;Data&gt; &gt;::~unique_ptr' requested here\n    std::unique_ptr&lt;Data&gt; m = make_me();\n                              ^\n3 : &lt;source&gt;:3:8: note: forward declaration of 'Data'\nstruct Data;\n       ^\n1 error generated.\nCompiler returned: 1\n</code></pre>\n<p>But adding below line at the end of above code compiles fine:</p>\n<pre><code>struct Data {};\n</code></pre>\n<p>My question is why this code compiles and works when Data is declared after point of instantiation of std::unique_ptr? Seemingly, both cases should fail with the same/similar error..</p>\n<p>Whole example on godbolt: <a href=\"https://godbolt.org/g/FQqxwN\" rel=\"nofollow noreferrer\">https://godbolt.org/g/FQqxwN</a></p>\n", "AcceptedAnswerId": "47928555", "Title": "Why construction of std::unique_ptr for incomplete type compiles?", "CreationDate": "2017-12-21T15:49:27.340", "LastActivityDate": "2017-12-21T17:20:36.003", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-12-21T17:12:29.793", "LastEditorUserId": "598696", "Id": "47928391", "Score": "15", "OwnerUserId": "8556993", "Tags": "<c++><c++11><templates><c++14><language-lawyer>", "AnswerCount": "2"}, "47928555": {"Id": "47928555", "PostTypeId": "2", "Body": "<p>This works because the <a href=\"http://eel.is/c++draft/temp.point\" rel=\"noreferrer\">point of instantiation</a> of a <code>template</code> is located after the definition of <code>Data</code>. From the Standard:</p>\n<blockquote>\n<p id=\"so_47928391_47928555_0\"><a href=\"http://eel.is/c++draft/temp.point\" rel=\"noreferrer\">[temp.point]</a></p>\n<p id=\"so_47928391_47928555_1\"><strong>For a class template specialization</strong>, a class member template specialization, or a specialization for a class member of a class template, if the specialization is implicitly instantiated because it is referenced from within another template specialization, if the context from which the specialization is referenced depends on a template parameter, and if the specialization is not instantiated previous to the instantiation of the enclosing template, the point of instantiation is immediately before the point of instantiation of the enclosing template. Otherwise, <strong>the point of instantiation for such a specialization immediately precedes the namespace scope declaration or definition that refers to the specialization.</strong></p>\n<p id=\"so_47928391_47928555_2\"><strong>A specialization for a function template, a member function template, or of a member function or static data member of a class template may have multiple points of instantiations within a translation unit, and in addition to the points of instantiation described above, for any such specialization that has a point of instantiation within the translation unit, the end of the translation unit is also considered a point of instantiation.</strong> A specialization for a class template has at most one point of instantiation within a translation unit. A specialization for any template may have points of instantiation in multiple translation units. <strong>If two different points of instantiation give a template specialization different meanings according to the one-definition rule, the program is ill-formed, no diagnostic required.</strong></p>\n</blockquote>\n<p>Note that this is <em>probably</em> ill-formed (NDR) due to the last sentence in the quote. I am not confident enough to tell whether this is certainly ill-formed or not.</p>\n", "LastEditorUserId": "598696", "LastActivityDate": "2017-12-21T17:20:36.003", "Score": "11", "CreationDate": "2017-12-21T15:59:58.173", "ParentId": "47928391", "CommentCount": "6", "OwnerUserId": "598696", "LastEditDate": "2017-12-21T17:20:36.003"}});