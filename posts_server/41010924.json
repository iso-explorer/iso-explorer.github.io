post_cb({"41011027": {"ParentId": "41010924", "CommentCount": "6", "Body": "<p>I believe GCC and MSVC are correct, and Clang is incorrect. The <code>static_assert</code> should not fire, because according to the Standard at [temp.inst]/3:</p>\n<blockquote>\n<p id=\"so_41010924_41011027_0\">Unless a function template specialization has been explicitly instantiated or explicitly specialized, the function template specialization is implicitly instantiated when the specialization is referenced in a context that\n  requires a function definition to exist.</p>\n</blockquote>\n<p>Inside an unevaluated context such as <code>decltype</code>, it is valid to have a call to a function that is left undefined, so this is not such a context in which the function definition is required to exist. Therefore the <code>static_assert</code> declaration in the body of the specialization is not instantiated.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "41011027", "Score": "6", "CreationDate": "2016-12-07T06:44:05.267", "LastActivityDate": "2016-12-07T06:44:05.267"}, "41010924": {"CommentCount": "5", "AcceptedAnswerId": "41011027", "PostTypeId": "1", "LastEditorUserId": "2013747", "CreationDate": "2016-12-07T06:35:50.343", "LastActivityDate": "2016-12-07T12:20:50.927", "LastEditDate": "2016-12-07T12:20:50.927", "ViewCount": "201", "FavoriteCount": "3", "Title": "Is static_assert supposed to work when invoked via decltype expression?", "Id": "41010924", "Score": "9", "Body": "<p>I expect the following code to fail with a <code>static_assert</code> check on the final line. However in MSVC2015 and gcc 6.2, it compiles sucessfully. It does fail to compile as expected in clang 3.9. Is this a compiler bug or does <code>static_assert</code> not work inside <code>decltype()</code>?</p>\n<pre><code>#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n\ntemplate&lt;typename T&gt;\nstruct Wrapper {};\n\ntemplate&lt;typename T, typename U&gt;\nconstexpr std::tuple&lt;T, U&gt; operator|(Wrapper&lt;T&gt;, Wrapper&lt;U&gt;)\n{\n    static_assert(std::is_same&lt;T,U&gt;::value == false, \"can't combine two of the same type\");\n    return std::tuple&lt;T, U&gt; {};\n}\n\nstruct A {};\nstruct B {};\nconstexpr Wrapper&lt;A&gt; aaa = {};\nconstexpr Wrapper&lt;B&gt; bbb = {};\n\nconstexpr auto shouldPass1 = aaa | bbb;\n//constexpr auto shouldFail1 = aaa | aaa; // fails static assert as expected\nusing shouldFail2 = decltype(aaa | aaa);\n// ^ doesn't fail in MSVC2015, or gcc 6.2. does fail in clang 3.9\n</code></pre>\n<p><strong>Update #1: Additional Question</strong></p>\n<p>Brian suggested that the <code>static_assert</code> would not fire in the <code>decltype</code> context because the value has not been explicitly instantiated. So I added an additional test below to explicitly instantiate the <code>shouldFail2</code> type <s>, which I think by Brian's logic should cause the <code>static_assert</code> to fail.</s> However, the code below does not fail in MSVC2015 or gcc 6.2. <s>Is this one a bug, or have I overlooked something?</s> Edit: It appears that once <code>decltype</code> has extracted the type, we are free to use <code>shouldFail2</code> without further reference to the definition of <code>operator|</code>.</p>\n<pre><code>shouldFail2 shouldFail3 = {}; // instantiate shouldFail2.\n// ^ doesn't fail in MSVC2015 or gcc 6.2.\n</code></pre>\n<p><strong>Update #2</strong></p>\n<p>If I change the definition of <code>operator|</code> to use an <code>auto</code> (or <code>decltype(auto)</code>) with no trailing return type, then the <code>decltype</code> expression correctly fails the <code>static_assert</code> in gcc 6.2. However this version fails to compile in MSVC2015 (errors C3779, C2088). Edit: as W.F. points out below, omitting the trailing return type is a C++14 feature.</p>\n<pre><code>template&lt;typename T, typename U&gt;\nconstexpr auto operator|(Wrapper&lt;T&gt;, Wrapper&lt;U&gt;)\n{\n    static_assert(std::is_same&lt;T,U&gt;::value == false, \"can't combine two of the same type\");\n    return std::tuple&lt;T, U&gt; {};\n}\n\n...\n\nusing shouldFail2 = decltype(aaa | aaa);\n// ^ now this correctly fails the static_assert in gcc 6.2\n</code></pre>\n", "Tags": "<c++><c++11><decltype><static-assert>", "OwnerUserId": "2013747", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41010924_41011027_0": {"section_id": 235, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_41010924_41011027_0": {"section_id": 228, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_41010924_41011027_0": {"section_id": 245, "quality": 0.9545454545454546, "length": 21}}}});