post_cb({"bq_ids": {"n4140": {"so_40094929_40094963_2": {"length": 31, "quality": 1.0, "section_id": 7003}}, "n3337": {"so_40094929_40094963_2": {"length": 31, "quality": 1.0, "section_id": 6749}}, "n4659": {"so_40094929_40094963_2": {"length": 31, "quality": 1.0, "section_id": 8500}}}, "40094929": {"ViewCount": "82", "Body": "<p>Imagine I have a super class A in C++ that has a virtual method. If I want to override it on my class B and still keep it virtual is it recommended to keep the virtual keyword on the class B on can I ignore it because I already said that method is virtual on the super class?</p>\n<p>For example what is the correct way to do the following.</p>\n<p><strong>Method A:</strong></p>\n<pre><code>class A{ \n    public:\n        virtual void hello(){\n            std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n        };\n};\nclass B: public A{\n    public:\n        virtual void hello() override{\n            std::cout &lt;&lt; \"Hello Sun!\" &lt;&lt; std::endl;\n        };\n\n};\nclass C: public B{\n    public:\n        virtual void hello() override{\n            std::cout &lt;&lt; \"Hello Moon!\" &lt;&lt; std::endl;\n        };\n\n};\n</code></pre>\n<p>Or declaring the function as virtual only on the first class.</p>\n<p><strong>Method B:</strong></p>\n<pre><code>class A{ \n    public:\n        virtual void hello(){\n            std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n        };\n};\nclass B: public A{\n    public:\n        void hello() override{\n            std::cout &lt;&lt; \"Hello Sun!\" &lt;&lt; std::endl;\n        };\n\n};\nclass C: public B{\n    public:\n        void hello() override{\n            std::cout &lt;&lt; \"Hello Moon!\" &lt;&lt; std::endl;\n        };\n\n}; \n</code></pre>\n<p>I want to use late biding in all situations. So I need the hello() method to be virtual in the three classes. Both ways worked on CodeBlocks but I don\u00b4t know what is the best way or even if there is any difference between them.</p>\n", "AcceptedAnswerId": "40094963", "Title": "C++ virtual class method", "CreationDate": "2016-10-17T20:16:48.893", "Id": "40094929", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-10-17T20:46:49.327", "Score": "0", "OwnerUserId": "3902100", "Tags": "<c++><class><virtual>", "AnswerCount": "1"}, "40094963": {"Id": "40094963", "PostTypeId": "2", "Body": "<p><code>virtual</code> is superfluous for <code>B</code> and <code>C</code>, and the effect is exactly the same. The important thing is to always mark your methods with <code>override</code><sup>1</sup> if they're meant to override a virtual method. While this is not strictly necessary, it is a good practice. You're doing that correctly in both examples.</p>\n<p>Pertinent standardese:</p>\n<blockquote>\n<p id=\"so_40094929_40094963_0\">n4140</p>\n<p id=\"so_40094929_40094963_1\">\u00a7 10.3 [class.virtual] / 2</p>\n<p id=\"so_40094929_40094963_2\">If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in\n  a class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a\n  member function <code>vf</code> with the same name, parameter-type-list,\n  cv-qualification, and refqualifier (or absence of same) as <code>Base::vf</code>\n  is declared, then <code>Derived::vf</code> is also virtual (<em>whether or not it is</em>\n<em>so declared</em>) and it overrides <code>Base::vf</code>.</p>\n</blockquote>\n<hr>\n<p><sup>1</sup> <sub><code>override</code> as a specifier is available since C++11.</sub></p>\n</hr>", "LastEditorUserId": "1413395", "LastActivityDate": "2016-10-17T20:46:49.327", "Score": "4", "CreationDate": "2016-10-17T20:18:56.903", "ParentId": "40094929", "CommentCount": "10", "OwnerUserId": "2456565", "LastEditDate": "2016-10-17T20:46:49.327"}});