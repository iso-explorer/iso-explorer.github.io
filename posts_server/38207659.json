post_cb({"bq_ids": {"n4140": {"so_38207659_38208127_2": {"length": 25, "quality": 0.6097560975609756, "section_id": 6299}, "so_38207659_38207659_1": {"length": 15, "quality": 0.6521739130434783, "section_id": 6299}, "so_38207659_38208127_1": {"length": 7, "quality": 1.0, "section_id": 6300}}, "n3337": {"so_38207659_38208127_1": {"length": 7, "quality": 1.0, "section_id": 6057}, "so_38207659_38207659_1": {"length": 15, "quality": 0.6521739130434783, "section_id": 6056}, "so_38207659_38208127_2": {"length": 25, "quality": 0.6097560975609756, "section_id": 6056}}, "n4659": {"so_38207659_38208127_1": {"length": 7, "quality": 1.0, "section_id": 7809}, "so_38207659_38207659_1": {"length": 15, "quality": 0.6521739130434783, "section_id": 7808}, "so_38207659_38208127_2": {"length": 25, "quality": 0.6097560975609756, "section_id": 7808}}}, "38207659": {"ViewCount": "92", "Body": "<p>I'm trying to overload operator[] for an std::map instance, and seriously puzzled by the compilation errors from GCC.</p>\n<p>The following example will not compile:</p>\n<pre><code>typedef std::map&lt; int*, int &gt;           mymap;    \nnamespace std {\ntemplate &lt;&gt;\nint &amp; mymap::operator[]( const int* &amp; k) {\n    return begin()-&gt;second;\n};\n};\n</code></pre>\n<p>This one fails with: </p>\n<blockquote>\n<p id=\"so_38207659_38207659_0\">error: template-id 'operator[]&lt;&gt;' for 'int&amp; std::map, std::allocator &gt; &gt;::operator[](const int*&amp;)' does not match any template declaration</p>\n</blockquote>\n<p>But if you replace <code>int*</code> with <code>myintp</code> (<code>typedef int* myintp</code>) it will compile just fine.</p>\n<p>It's also interesting why template&lt;&gt; and namespace are needed here.</p>\n<p><strong>Update:</strong>\nI oversimplified the example.</p>\n<blockquote>\n<p id=\"so_38207659_38207659_1\">It is allowed to add template specializations for any standard library\n  template to the namespace std only if the declaration depends on a\n  user-defined type and the specialization satisfies all requirements\n  for the original template, except where such specializations are\n  prohibited.</p>\n</blockquote>\n<pre><code>typedef std::map&lt; myclass*, int &gt;           mymap; \nnamespace std {\ntemplate &lt;&gt;\nint &amp; mymap::operator[]( myclass* const &amp; k) {\n    return begin()-&gt;second;\n};\n};\n</code></pre>\n<p>Would that example provide a legal and predictable behavior?</p>\n", "AcceptedAnswerId": "38207857", "Title": "Overloading of operator[] in a template", "CreationDate": "2016-07-05T15:47:26.210", "Id": "38207659", "CommentCount": "5", "LastEditDate": "2016-07-05T17:58:53.120", "PostTypeId": "1", "LastEditorUserId": "1501572", "LastActivityDate": "2016-07-05T18:44:33.213", "Score": "-1", "OwnerUserId": "1501572", "Tags": "<c++><templates><operator-overloading>", "AnswerCount": "3"}, "38208127": {"Id": "38208127", "PostTypeId": "2", "Body": "<p>From 17.6.4.2.1/2:</p>\n<blockquote>\n<p id=\"so_38207659_38208127_0\">The behavior of a C++ program is undefined if it declares</p>\n<p id=\"so_38207659_38208127_1\">\u2014 an\n  explicit specialization of any member function of a standard library\n  class template, or</p>\n</blockquote>\n<p>So right there all bets are off and the compiler has no obligation to compile your code (other answers show why the compiler appears to accept the code that uses the typedef, but that still doesn't make it legal).</p>\n<p>C++98 is slightly less explicit, in 17.4.3.1/1:</p>\n<blockquote>\n<p id=\"so_38207659_38208127_2\">It is undefined for a C++ program to add declarations or definitions\n  to namespace std or namespaces within namespace std unless otherwise\n  specified. A program may add template specializations for any standard\n  library template to namespace std. Such a specialization (complete or\n  partial) of a standard library template results in undefined behavior\n  unless the declaration depends on a user-defined name of external\n  linkage and unless the specialization meets the standard library\n  requirements for the original template.</p>\n</blockquote>\n<p>Now, it's somewhat unclear if this strictly prohibits specializing a member of a template of <code>std</code> namespace (vs a full  or partial specialization of the container template itself) but your particular code is certainly undefined because it doesn't specialize on a user-defined name of external linkage.</p>\n", "LastEditorUserId": "251738", "LastActivityDate": "2016-07-05T18:44:33.213", "Score": "6", "CreationDate": "2016-07-05T16:14:55.617", "ParentId": "38207659", "CommentCount": "3", "OwnerUserId": "251738", "LastEditDate": "2016-07-05T18:44:33.213"}, "38208067": {"Id": "38208067", "PostTypeId": "2", "Body": "<p>Let's analyze your code:</p>\n<pre><code>int&amp; mymap::operator[](const int* &amp;k)\n{\n    return begin ()-&gt;second;\n};\n</code></pre>\n<p>This is wrong since the parameter is a reference to a pointer to a const int, <em>not</em> a reference to a const pointer to an int.</p>\n<p>The position of <code>const</code> have confused you, so rewrite it as:</p>\n<pre><code>int&amp; mymap::operator[](int *const &amp;k)\n{\n    return begin ()-&gt;second;\n};\n</code></pre>\n", "LastActivityDate": "2016-07-05T16:11:39.660", "CommentCount": "1", "CreationDate": "2016-07-05T16:11:39.660", "ParentId": "38207659", "Score": "0", "OwnerUserId": "5186897"}, "38207857": {"Id": "38207857", "PostTypeId": "2", "Body": "<p>The key type is <code>int*</code>.</p>\n<p>In order to match</p>\n<pre><code>T&amp; operator[]( const Key&amp; key );\n</code></pre>\n<p>you need to use:</p>\n<pre><code>int &amp; mymap::operator[]( int* const &amp; k) {\n</code></pre>\n<p>Unfortunately, use of <code>const</code> before the type is confusing. Had the declaration been</p>\n<pre><code>T&amp; operator[]( Key const&amp; key );\n</code></pre>\n<p>it would have been easier to come up with the right argument declaration for what you are trying.</p>\n", "LastActivityDate": "2016-07-05T15:58:44.020", "CommentCount": "0", "CreationDate": "2016-07-05T15:58:44.020", "ParentId": "38207659", "Score": "2", "OwnerUserId": "434551"}});