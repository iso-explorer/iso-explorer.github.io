post_cb({"6383639": {"CommentCount": "3", "AcceptedAnswerId": "6383733", "PostTypeId": "1", "LastEditorUserId": "75889", "CreationDate": "2011-06-17T09:09:33.410", "LastActivityDate": "2011-06-17T09:55:15.063", "LastEditDate": "2011-06-17T09:30:19.047", "ViewCount": "887", "FavoriteCount": "1", "Title": "Conditions for copy elision?", "Id": "6383639", "Score": "10", "Body": "<p>I wanted to verify the if the following optimizations work as expected:</p>\n<ul>\n<li>RVO</li>\n<li>Named RVO</li>\n<li>Copy elision when passing an argument by value</li>\n</ul>\n<p>So I wrote this little program:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;cstddef&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct Foo {\n    Foo(std::size_t length, char value) : data(length, value) { }\n\n    Foo(const Foo &amp; rhs) : data(rhs.data) { std::cout &lt;&lt; \"*** COPY ***\" &lt;&lt; std::endl; }\n\n    Foo &amp; operator= (Foo rhs) {\n        std::cout &lt;&lt; \"*** ASSIGNMENT ***\" &lt;&lt; std::endl;\n        std::swap(data, rhs.data); // probably expensive, ignore this please\n        return *this;\n    }\n\n    ~Foo() { }\n\n    std::vector&lt;char&gt; data;\n};\n\nFoo TestRVO() { return Foo(512, 'r'); }\n\nFoo TestNamedRVO() { Foo result(512, 'n'); return result; }\n\nvoid PassByValue(Foo inFoo) {}\n\nint main()\n{\n    std::cout &lt;&lt; \"\\nTest RVO: \" &lt;&lt; std::endl;\n    Foo rvo = TestRVO();\n\n    std::cout &lt;&lt; \"\\nTest named RVO: \" &lt;&lt; std::endl;\n    Foo named_rvo = TestNamedRVO();\n\n    std::cout &lt;&lt; \"\\nTest PassByValue: \" &lt;&lt; std::endl;\n    Foo foo(512, 'a');\n    PassByValue(foo);\n\n    std::cout &lt;&lt; \"\\nTest assignment: \" &lt;&lt; std::endl;\n    Foo f(512, 'f');\n    Foo g(512, 'g');\n    f = g;\n}\n</code></pre>\n<p>And I compiled it with optimizations enabled:</p>\n<pre><code>$ g++ -o test -O3 main.cpp ; ./test\n</code></pre>\n<p>This is output:</p>\n<pre><code>Test RVO: \n\nTest named RVO: \n\nTest PassByValue: \n*** COPY ***\n\nTest assignment: \n*** COPY ***\n*** ASSIGNMENT ***\n</code></pre>\n<p>According to the output RVO and named RVO work as expected. However, copy elision is not performed for the assignment operator and when calling <code>PassByValue</code>.</p>\n<p>Is copy elision not allowed on user defined copy-constructors? (I know that RVO is explicitly allowed by the standard but I don't know about copy elision when passing by value.) Is there a way to verify copy elision without defining copy constructors?</p>\n", "Tags": "<c++>", "OwnerUserId": "75889", "AnswerCount": "2"}, "6383710": {"ParentId": "6383639", "CommentCount": "1", "CreationDate": "2011-06-17T09:15:47.983", "OwnerUserId": "160206", "PostTypeId": "2", "Id": "6383710", "Score": "10", "Body": "<p>The standard says (in paragraph 12.8.15):</p>\n<blockquote>\n<p id=\"so_6383639_6383710_0\">This elision of copy operations is\n  permitted in the following\n  circumstances (which may be combined\n  to eliminate multiple copies): </p>\n<ul>\n<li><p id=\"so_6383639_6383710_1\">in a\n  return statement in a function with a\n  class return type, when the expression\n  is the name of a non-volatile\n  automatic object with the same\n  cv-unqualified type as the function\n  return type, the copy operation can be\n  omitted by constructing the automatic\n  object directly into the function\u2019s\n  return value </p></li>\n<li><p id=\"so_6383639_6383710_2\">when a temporary class\n  object that has not been bound to a\n  reference (12.2) would be copied to a\n  class object with the same\n  cv-unqualified type, the copy\n  operation can be omitted by\n  constructing the tempo- rary object\n  directly into the target of the\n  omitted copy</p></li>\n</ul>\n</blockquote>\n<p>Neither of these cases applies here, so the elision is not allowed. The first on is obvious (no return). The second is not allowed, because the object you pass in is not a temporary.</p>\n<p>Note that your code is still fine, because you would have to create the copy anyway. To make away with that copy, you would have to use C++0x's move-semantics.</p>\n", "LastActivityDate": "2011-06-17T09:15:47.983"}, "6383733": {"ParentId": "6383639", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-06-17T09:17:58.450", "Score": "9", "LastEditorUserId": "476681", "LastEditDate": "2011-06-17T09:55:15.063", "Id": "6383733", "OwnerUserId": "597607", "Body": "<p>The way you use the copy constructor it can not be elided, as the copied object still exists after the call.</p>\n<p>If you try it this way, it might work better:</p>\n<pre><code>PassByValue(Foo(512, 'a')); \n</code></pre>\n<p>All optimizations are allowed but not required, so it is up to each compiler to decide what it can and will do.</p>\n", "LastActivityDate": "2011-06-17T09:55:15.063"}, "bq_ids": {"n4140": {"so_6383639_6383710_0": {"section_id": 480, "quality": 0.8333333333333334, "length": 10}, "so_6383639_6383710_2": {"section_id": 480, "quality": 0.8214285714285714, "length": 23}, "so_6383639_6383710_1": {"section_id": 480, "quality": 0.9666666666666667, "length": 29}}, "n3337": {"so_6383639_6383710_0": {"section_id": 471, "quality": 0.8333333333333334, "length": 10}, "so_6383639_6383710_2": {"section_id": 471, "quality": 0.8214285714285714, "length": 23}, "so_6383639_6383710_1": {"section_id": 471, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_6383639_6383710_0": {"section_id": 502, "quality": 0.8333333333333334, "length": 10}, "so_6383639_6383710_2": {"section_id": 502, "quality": 0.6071428571428571, "length": 17}, "so_6383639_6383710_1": {"section_id": 502, "quality": 0.8666666666666667, "length": 26}}}});