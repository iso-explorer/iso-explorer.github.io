post_cb({"10360343": {"ParentId": "10321856", "CommentCount": "11", "CreationDate": "2012-04-28T03:36:35.680", "OwnerUserId": "518287", "PostTypeId": "2", "Id": "10360343", "Score": "0", "Body": "<p>@jpalcek answered my question. However, my actual problem (as hinted at in the examples) can be solved without recursive aliases like this:</p>\n<pre><code>// core combinators\nstruct unit;\nstruct point;\ntemplate&lt;class T,class U&gt; struct fix;\ntemplate&lt;class T, class U&gt; struct tup2;\ntemplate&lt;class T, class U&gt; struct var2;\n\ntemplate &lt;&gt; struct   \n  fix&lt;\n    point,\n    var2&lt;unit, tup2&lt;int,point&gt; &gt; \n  &gt; \n{ \n  // definition goes here\n};\n</code></pre>\n<p>using the fix and point types to represent recursion. I happen not to require any of the templates to be defined, I only need to define the specialisations. What I needed was a <em>name</em> that would be the same in two distinct translation units for external linkage: the name had to be a function of the type structure.</p>\n<p>@Ex0du5 prompted thinking about this. The actual solution is also related to a correspondence from Gabriel des Rois many years ago. I want to thank everyone that contributed.</p>\n", "LastActivityDate": "2012-04-28T03:36:35.680"}, "10321856": {"CommentCount": "20", "AcceptedAnswerId": "10322052", "PostTypeId": "1", "LastEditorUserId": "518287", "CreationDate": "2012-04-25T18:43:32.140", "LastActivityDate": "2012-04-28T03:36:35.680", "LastEditDate": "2012-04-25T20:07:35.473", "ViewCount": "2155", "FavoriteCount": "5", "Title": "Does C++11 support types recursion in templates?", "Id": "10321856", "Score": "4", "Body": "<p>I want to explain the question in detail. In many languages with strong type systems (like Felix, Ocaml, Haskell) you can define a polymorphic list by composing type constructors. Here's the Felix definition:</p>\n<pre><code>typedef list[T] = 1 + T * list[T];\ntypedef list[T] = (1 + T * self) as self;\n</code></pre>\n<p>In Ocaml:</p>\n<pre class=\"lang-ml prettyprint-override\"><code>type 'a list = Empty | Cons ('a, 'a list)\n</code></pre>\n<p>In C, this is recursive but neither polymorphic nor compositional:</p>\n<pre><code>struct int_list { int elt; struct int_list *next; };\n</code></pre>\n<p>In C++ it would be done like this, if C++ supported type recursion:</p>\n<pre><code>struct unit {};\ntemplate&lt;typename T&gt;\n    using list&lt;T&gt; = variant&lt; unit, tuple&lt;T, list&lt;T&gt;&gt; &gt;;\n</code></pre>\n<p>given a suitable definition for tuple (aka pair) and variant (but not the broken one used in Boost). Alternatively:</p>\n<pre><code>    using list&lt;T&gt; = variant&lt; unit, tuple&lt;T, &amp;list&lt;T&gt;&gt; &gt;;\n</code></pre>\n<p>might be acceptable given a slightly different definition of variant. It was not possible to even write this in C++ &lt; C++11 because without template typedefs, there's no way to get polymorphism, and without a sane syntax for typedefs, there's no way to get the target type in scope. The using syntax above solves both these problems, however this does not imply recursion is permitted.</p>\n<p>In particular please note that allowing recursion has a major impact on the ABI, i.e. on name mangling (it can't be done unless the name mangling scheme allows for representation of fixpoints).</p>\n<p>My question: is required to work in C++11?\n[Assuming the expansion doesn't result in an infinitely large struct]</p>\n<hr>\n<p>Edit: just to be clear, the requirement is for general structural typing. Templates provide precisely that, for example</p>\n<pre><code>pair&lt;int, double&gt;\npair&lt;int, pair &lt;long, double&gt; &gt;\n</code></pre>\n<p>are anonymously (structurally) typed, and pair is clearly polymorphic. However recursion in C++ &lt; C++11 cannot be stated, not even with a pointer. In C++11 you can state the recursion, albeit with a template typedef (with the new using syntax the expression on the LHS of the = sign is in scope on the RHS).</p>\n<p>Structural (anonymous) typing with polymorphism and recursion are minimal requirements for a type system. </p>\n<p>Any modern type system must support polynomial type functors or the type system is too clumbsy to do any kind of high level programming. The combinators required for this are usually stated by type theoreticians like:</p>\n<pre><code>1 | * | + | fix\n</code></pre>\n<p>where 1 is the unit type, * is tuple formation, + is variant formation, and fix is recursion. The idea is simply that:</p>\n<p>if t is a type and u is a type then t + u and t * u are also types</p>\n<p>In C++, struct unit{} is 1, tuple  is *, variant  is + and fixpoints might be obtained with the using = syntax. It's not quite anonymous typing because the fixpoint would require a template typedef.</p>\n<hr>\n<p>Edit: Just an example of polymorphic type constructor in C:</p>\n<pre><code>T*          // pointer formation\nT (*)(U)    // one argument function type\nT[2]        // array\n</code></pre>\n<p>Unfortunately in C, function values aren't compositional, and pointer formation is subject to lvalue constraint, and the syntactic rules for type composition are not themselves compositional, but here we can say:</p>\n<pre><code>if T is a type T* is a type\nif T and U are types, T (*)(U) is a type\nif T is a type T[2] is a type\n</code></pre>\n<p>so these type constuctors (combinators) can be applied recursively to get new types without having to create a new intermediate type. In C++ we can easily fix the syntactic problem:</p>\n<pre><code>template&lt;typename T&gt; using ptr&lt;T&gt; = T*;\ntemplate&lt;typename T, typename U&gt; using fun&lt;T,U&gt; = T (*)(U);\ntemplate&lt;typename T&gt; using arr2&lt;T&gt; = T[2];\n</code></pre>\n<p>so now you can write:</p>\n<pre><code>arr2&lt;fun&lt;double, ptr&lt;int&gt;&gt;&gt;\n</code></pre>\n<p>and the syntax is compositional, as well as the typing.</p>\n</hr></hr>", "Tags": "<c++><types><c++11><type-theory>", "OwnerUserId": "518287", "AnswerCount": "5"}, "10322356": {"ParentId": "10321856", "CommentCount": "4", "CreationDate": "2012-04-25T19:22:19.287", "OwnerUserId": "1166087", "PostTypeId": "2", "Id": "10322356", "Score": "0", "Body": "<p>C++ does have the \"curiously recurring template pattern\", or CRTP. It's not specific to C++11, however. It means you can do the following (shamelessly copied from <a href=\"http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\" rel=\"nofollow\">Wikipedia</a>):</p>\n<pre><code>template &lt;typename T&gt;\nstruct base\n{\n    // ...\n};\nstruct derived : base&lt;derived&gt;\n{\n    // ...\n};\n</code></pre>\n", "LastActivityDate": "2012-04-25T19:22:19.287"}, "10322052": {"ParentId": "10321856", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2012-04-25T18:57:27.800", "Score": "8", "LastEditorUserId": "51831", "LastEditDate": "2012-04-25T21:45:00.470", "Id": "10322052", "OwnerUserId": "51831", "Body": "<p>No, that is not possible. Even indirect recursion through alias templates is forbidden.</p>\n<p>C++11, 4.5.7/3:</p>\n<blockquote>\n<p id=\"so_10321856_10322052_0\">The type-id in an alias template declaration shall not refer to the alias template being declared. The type produced by an alias template specialization shall not directly or indirectly make use of that specialization. [ Example:</p>\n<pre><code>template &lt;class T&gt; struct A;\ntemplate &lt;class T&gt; using B = typename A&lt;T&gt;::U;\ntemplate &lt;class T&gt; struct A {\ntypedef B&lt;T&gt; U;\n};\nB&lt;short&gt; b; // error: instantiation of B&lt;short&gt; uses own type via A&lt;short&gt;::U\n</code></pre>\n<p id=\"so_10321856_10322052_1\">\u2014 end example ]</p>\n</blockquote>\n", "LastActivityDate": "2012-04-25T21:45:00.470"}, "10323510": {"ParentId": "10321856", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2012-04-25T20:47:03.040", "Score": "8", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:07:31.310", "Id": "10323510", "OwnerUserId": "46642", "Body": "<p>If you want this, stick to your Felix, Ocaml, or Haskell. You will easily realize that very few (none?) sucessful languages have type systems as rich as those three. And in my opinion, if all languages were the same, learning new ones wouldn't be worth it. </p>\n<pre><code>template&lt;typename T&gt;\nusing list&lt;T&gt; = variant&lt; unit, tuple&lt;T, list&lt;T&gt;&gt; &gt;;\n</code></pre>\n<p>In C++ doesn't work because an alias template doesn't define a new type. It's purely an alias, a synonym, and it <em>is equivalent to its substitution</em>. <a href=\"https://stackoverflow.com/a/6623089/46642\">This is a <em>feature</em>, btw</a>.</p>\n<p>That alias template is equivalent to the following piece of Haskell:</p>\n<pre class=\"lang-hs prettyprint-override\"><code>type List a = Either () (a, List a)\n</code></pre>\n<p>GHCi rejects this because \"[cycles] in type synonym declarations\" are not allowed. I'm not sure if this is outright banned in C++, or if it is allowed but causes infinite recursion when substituted. Either way, it doesn't work.</p>\n<p>The way to define new types in C++ is with the <code>struct</code>, <code>class</code>, <code>union</code>, and <code>enum</code> keywords. If you want something like the following Haskell (I insist on Haskell examples, because I don't know the other two languages), then you need to use those keywords.</p>\n<pre class=\"lang-hs prettyprint-override\"><code>newtype List a = List (Either () (a, List a))\n</code></pre>\n", "LastActivityDate": "2012-04-25T21:22:33.477"}, "bq_ids": {"n4140": {"so_10321856_10322052_0": {"section_id": 167, "quality": 0.8636363636363636, "length": 19}}, "n3337": {"so_10321856_10322052_0": {"section_id": 161, "quality": 0.8636363636363636, "length": 19}}, "n4659": {"so_10321856_10322052_0": {"section_id": 172, "quality": 0.8636363636363636, "length": 19}}}, "10325777": {"ParentId": "10321856", "PostTypeId": "2", "CommentCount": "11", "CreationDate": "2012-04-26T00:41:00.843", "Score": "2", "LastEditorUserId": "800081", "LastEditDate": "2012-04-27T16:09:21.800", "Id": "10325777", "OwnerUserId": "800081", "Body": "<p>I think you may need to review your type theory, as several of your assertions are incorrect.</p>\n<p>Let's address your main question (and backhanded point) - as others have pointed out type recursion <em>of the type you requested</em> is not allowed.  This does <strong>not</strong> mean that c++ does not support type recursion.  It supports it perfectly well.  The type recursion you requested is type <em>name</em> recursion, which is a syntactic flair that actually has no consequence on the actual type system.</p>\n<p>C++ allows tuple membership recursion by proxy.  For instance, c++ allows</p>\n<pre><code>class A\n{\n    A * oneOfMe_;\n};\n</code></pre>\n<p>That is type recursion that has real consequences.  (And obviously no language can do this without internal proxy representation because size is infinitely recursive otherwise).</p>\n<p>Also C++ allows translationtime polymorphism, which allow for the creation of objects that act like any type you may create using name recursion.  The name recursion is only used to unload types to members or provide translationtime behavior assignments in the type system.  Type tags, type traits, etc. are well known c++ idioms for this.</p>\n<p>To prove that type name recursion does not add functionality to a type system, it only needs to be pointed out that c++'s type system allows a fully Turing Complete type calculation, using metaprogramming on compiletime constants (and typelists of them), through simple mapping of names to constants.  This means there is a function MakeItC++:YourIdeaOfPrettyName-&gt;TypeParametrisedByTypelistOfInts that makes any Turing computible typesystem you want.</p>\n<p>As you know, being a student of type theory, variants are dual to tuple products.  In the type category, any property of variants has a dual property of tuple products with arrows reversed.  If you work consistently with the duality, you do not get properties with \"new capabilities\" (in terms of type calculations).  So on the level of type calculations, you obviously don't <em>need</em> variants.  (This should also be obvious from the Turing Completeness.)</p>\n<p>However, in terms of runtime behavior in an imperative language, you do get different behavior.  And it is bad behavior.  Whereas products restrict semantics, variants relax semantics.  You should never want this, as it <em>provably</em> destroys code correctness.  The history of statically typed programming languages has been moving towards greater and greater expression of the semantics in the type system, with the goal that the compiler should be able to understand when the program does not mean what you want it to.  The goal has been to turn the compiler into the program verification system.</p>\n<p>For instance, with type units, you can express that a particular value isn't just an <code>int</code> but is actually an acceleration measured in meters per square seconds.  Assigning a value that is a velocity expressed in feet per hour divided by a timespan of minutes shouldn't just divide the two values - it should note that a conversion is necessary (and either perform it or fail compilation or... do the right thing).  Assinging a force should fail compilation.  Doing these kinds of checks on program meaning could have given us potentially more martian exploration, for instance.</p>\n<p>Variants are the opposite direction.  Sure, \"if you code correctly, they work correctly\", but that's not the point with code verification.  They provably add code loci where a different engineer, unfamiliar with current type usage, can introduce the incorrect semantic assumption without translation failure.  And, there is always a code transformation that changes an imperative code section from one that uses Variants unsafely to one that use semantically validated non-variant types, so their use is also \"always suboptimal\".</p>\n<p>The majority of runtime uses for variants are typically those that are better encapsulated in runtime polymorphism.  Runtime polymorphism has a statically verified semantics that may have associated runtime invariant checking and unlike variants (where the sum type is universally declared in one code locus) actually supports the Open-Closed principle.  By needing to declare a variant in one location, you must change that location everytime you add a new functional type to the sum.  This means that code never closes to change, and therefore may have bugs introduced.  Runtime polymorphism, though, allows new behaviors to be added in separate code loci from the other behaviors.</p>\n<p>(And besides, most real language type systems are not distributive anyway.  (a, b | c) =/= (a, b) | (a, c) so what is the point here?)</p>\n<p>I would be careful making blanket statements about what makes a type system good without getting some experience in the field, particularly if your point is to be provocative and political and enact change.  I do not see anything in your post that actually points to healthy changes for any computer language.  I do not see features, safety, or any of the other actual real-world concerns being addressed.  I totally get the love of type theory.  I think every computer scientist should know Cateogry Theory and the denotational semantics of programming languages (domain theory, cartesian categories, all the good stuff).  I think if more people understood the Curry-Howard isomorphism as an ontological manifesto, constructivist logics would get more respect.</p>\n<p>But none of that provides reasons to attack the c++ type system.  There are legitimate attacks for nearly every language - type name recursion and variant availability are not them.</p>\n<hr>\n<p>EDIT: Since my point about Turing completeness does not seem to be understood, nor my comment about the c++ way of using type tags and traits to offload type calculations, maybe an example is in order.</p>\n<p>Now the OP claims to want this in a usage case for lists, which my earlier point on the layout easily handles.  Better, just use std::list.  But from other comments and elsewhere, I think they really want this to work on the Felix-&gt;C++ translation.</p>\n<p>So, what I think the OP thinks they want is something like</p>\n<pre><code>template &lt;typename Type&gt;\nclass SomeClass\n{\n    // ...\n};\n</code></pre>\n<p>and then be able to build a type</p>\n<pre><code>SomeClass&lt; /*insert the SomeClass&lt;...&gt; type created here*/ &gt;\n</code></pre>\n<p>I've mentioned this is just a naming convention wanted.  Nobody wants typenames - they are transients of the translation process.  What is actually wanted is what you will do with Type later on in the structural composition of the type.  It will be used in typename calculations to produce member data and method signatures.</p>\n<p>So, what can be done in c++ is</p>\n<pre><code>struct SelfTag {};\n</code></pre>\n<p>Then, when you want to refer to self, just put this type tag there.</p>\n<p>When it's meaningful to do the type calculation, you have a template specialisation on <code>SelfTag</code> that will substitute <code>SomeClass&lt;SelfTag&gt;</code> instead of substituting <code>SelfTag</code> in the appropriate place of the type calculation.</p>\n<p>My point here is that the c++ type system is Turing Complete - and that means a lot more than what I think the OP is reading everytime I've written that.  <strong>Any type calculation may be done</strong> (given constraints of compiler recursion) <strong>and that really does mean that if you have a problem in one type system in a completely different language, you can find a translation here</strong>.  I hope this makes things even clearer about my point.  Coming back and saying \"well you still can't do XYZ in the type system\" would be clearly missing the point.</p>\n</hr>", "LastActivityDate": "2012-04-27T16:09:21.800"}});