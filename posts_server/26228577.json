post_cb({"26228577": {"CommentCount": "4", "ViewCount": "51", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "CreationDate": "2014-10-07T04:31:18.060", "LastActivityDate": "2014-10-07T05:15:17.820", "Title": "Definition fo object representation and operator sizeof", "LastEditorDisplayName": "user2953119", "LastEditDate": "2014-10-07T04:47:28.533", "Id": "26228577", "Score": "2", "Body": "<p>The definition of object representation concept is given in 3.9/4:</p>\n<p>[basic.types]</p>\n<blockquote>\n<p id=\"so_26228577_26228577_0\">The object representation of an object of type T is the sequence of N\n  unsigned char objects taken up by the object of type T, where N equals\n  <code>sizeof(T)</code>.</p>\n</blockquote>\n<p>But <code>sizeof</code> operator's defined as follows:</p>\n<p>[expr.sizeof]</p>\n<blockquote>\n<p id=\"so_26228577_26228577_1\">The sizeof operator yields the number of bytes in the <em>object</em>\n<em>representation</em> of its operand.</p>\n</blockquote>\n<p>In particular:</p>\n<blockquote>\n<p id=\"so_26228577_26228577_2\">When applied to a class, the result is the number of bytes in an\n  object of that class including any padding required for placing\n  objects of that type in an array</p>\n</blockquote>\n<p>I'd like to consider that definition by example:</p>\n<pre><code>struct A {\n    int a;  //sizeof(a) is implementation defined\n    long b; //sizeof(b) is implementation defined\n    char c; //sizeof(c) is 1 by definition \n    // Padding, problbly equals to 3 butes\n}\n</code></pre>\n<p>How is <code>sizeof(A)</code> computed by implementation? We just compute the sum of <code>sizeof(a) + sizeof(b) + sizeof(c) + padding</code>.</p>\n<p>But what is the condition <code>required for placingobjects of that type in an array</code> about?</p>\n", "Tags": "<c++><class><sizeof>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26228577_26228577_2": {"section_id": 6077, "quality": 1.0, "length": 15}, "so_26228577_26228577_0": {"section_id": 7202, "quality": 0.8666666666666667, "length": 13}, "so_26228577_26228577_1": {"section_id": 6076, "quality": 0.9, "length": 9}}, "n3337": {"so_26228577_26228577_2": {"section_id": 5845, "quality": 1.0, "length": 15}, "so_26228577_26228577_0": {"section_id": 6946, "quality": 0.8666666666666667, "length": 13}, "so_26228577_26228577_1": {"section_id": 5844, "quality": 0.9, "length": 9}}, "n4659": {"so_26228577_26228577_2": {"section_id": 7573, "quality": 1.0, "length": 15}, "so_26228577_26228577_0": {"section_id": 8711, "quality": 0.8666666666666667, "length": 13}, "so_26228577_26228577_1": {"section_id": 7572, "quality": 0.9, "length": 9}}}, "26228980": {"ParentId": "26228577", "CommentCount": "0", "Body": "<p>You simple compute the size of struct as:  </p>\n<pre><code>long size = sizeof(struct A);  \n</code></pre>\n<p>And if you want an array of <code>struct A</code>,  </p>\n<pre><code>struct A arr[/* Size of array */];\n</code></pre>\n", "OwnerUserId": "3760899", "PostTypeId": "2", "Id": "26228980", "Score": "0", "CreationDate": "2014-10-07T05:15:17.820", "LastActivityDate": "2014-10-07T05:15:17.820"}});