post_cb({"16738704": {"ParentId": "16726014", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Although GCC 4.7.2 compiles this code it's ill formed. The lambda expression which initializes <code>f</code> is too complex for deducing the return type. Indeed, 5.1.2/4 says</p>\n<blockquote>\n<blockquote>\n<p id=\"so_16726014_16738704_4\">If a lambda-expression does not include a trailing-return-type, it is as if the trailing-return-type denotes the following type:</p>\n<p id=\"so_16726014_16738704_5\">\u2014 if the compound-statement is of the form</p>\n<pre><code>   { attribute-specifier-seq[opt] return expression ; }\n</code></pre>\n<p id=\"so_16726014_16738704_6\">the type of the returned expression after lvalue-to-rvalue conversion (4.1), array-to-pointer conversion (4.2), and function-to-pointer conversion (4.3);</p>\n<p id=\"so_16726014_16738704_7\">\u2014 otherwise, void.</p>\n</blockquote>\n</blockquote>\n<p>Therefore, in this example the return type is <code>void</code> but the lambda is returning something else. The code should not compile.</p>\n<p>I agree that the message given by Visual Studio is misleading.</p>\n<p><strong>Update</strong>: On this question</p>\n<blockquote>\n<blockquote>\n<p id=\"so_16726014_16738704_9\">So would it be correct to say \"In C++11, you cannot define a lambda that returns a stateful lambda\"? </p>\n</blockquote>\n</blockquote>\n<p>No. As per the C++11 quote below, the type returned by a lambda is <code>void</code> unless the body of the lambda contains just a single line with a <code>return expression;</code>. Hence, if you manage to create your stateful lambda in a return expression, then this is fine. For instance, the code below compiles in GCC 4.7.2, Clang 3.2 and Intel compiler 13.1.0: (It doesn't compile in VS2012 due to the aforementioned bug.)</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n  int n = 5;\n  auto f = [=] {\n      return [=]{ return n; }; // creates a stateful lambda and returns it in a single line\n  };\n  std::cout &lt;&lt; f()() &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n", "OwnerUserId": "1137388", "LastEditorUserId": "1137388", "LastEditDate": "2013-05-26T15:47:08.117", "Id": "16738704", "Score": "2", "CreationDate": "2013-05-24T15:37:27.483", "LastActivityDate": "2013-05-26T15:47:08.117"}, "bq_ids": {"n4140": {"so_16726014_16738704_2": {"section_id": 0, "quality": 0.6, "length": 6}, "so_16726014_16738704_6": {"section_id": 0, "quality": 0.6, "length": 6}}, "n3337": {"so_16726014_16738704_0": {"section_id": 5732, "quality": 1.0, "length": 8}, "so_16726014_16738704_4": {"section_id": 5732, "quality": 1.0, "length": 8}, "so_16726014_16738704_2": {"section_id": 5732, "quality": 1.0, "length": 10}, "so_16726014_16738704_6": {"section_id": 5732, "quality": 1.0, "length": 10}}, "n4659": {"so_16726014_16738704_2": {"section_id": 7667, "quality": 0.7, "length": 7}, "so_16726014_16738704_6": {"section_id": 7667, "quality": 0.7, "length": 7}}}, "16726014": {"CommentCount": "5", "ViewCount": "550", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-05-24T00:25:02.757", "LastActivityDate": "2014-11-11T20:02:34.123", "Title": "Lambda returning lambda incorrectly infers return type?", "AcceptedAnswerId": "16738704", "LastEditDate": "2017-05-23T10:24:09.250", "Id": "16726014", "Score": "5", "Body": "<p><em>This question is a continuation of a recent question of mine:<br>\n<a href=\"https://stackoverflow.com/questions/16661981/what-is-this-compiler-error-when-using-a-lambda-as-a-template-parameter\">What is this compiler error when using a lambda as a template parameter?</a></br></em></p>\n<p>Nov. 11, 2014: Microsoft has responded saying the fix for this bug should show up in the next major release of Visual C++.</p>\n<hr>\n<p>This code fails to compile using the VS2012 (Update 2):</p>\n<pre><code>int main(int argc, char* argv[])\n{\n    auto f = []()\n    {\n        int n = 0;\n        auto r = [=]{ return n; };\n        return r;\n    };\n    return 0;\n}\n</code></pre>\n<hr>\n<p>This is the compiler error I get:</p>\n<pre><code>1&gt;  main.cpp\n1&gt;C:\\test\\main.cpp(7): error C2440: 'return' : cannot convert from 'main::&lt;lambda_c5d1d707b91a1ddedc06eb080503550c&gt;::()::&lt;lambda_ac357c309731f4971c3269160ed9c24b&gt;' to 'int (__cdecl *)(void)'\n1&gt;          No user-defined-conversion operator available that can perform this conversion, or the operator cannot be called\n</code></pre>\n<hr>\n<ul>\n<li>Is there a problem with the code according to C++11 specification?</li>\n<li>Is there a problem with the code according to VS2012's defined partial C++11 support?</li>\n<li>Or is this a VS2012 C++ compiler bug?</li>\n</ul>\n<hr>\n<ul>\n<li>Could someone point me to the place in the C++11 specification that talks about how lambdas must be implicitly castable to function pointers?\n\n<ul>\n<li>I recall this only being for <em>stateless</em> lambdas - those with empty capture clauses - which the inner lambda <code>r</code> is <em>not</em></li>\n<li>So why does it appear that the inferred return type of lambda <code>f</code> is a function pointer, namely <code>int (__cdecl *)(void)</code>?</li>\n</ul></li>\n</ul>\n</hr></hr></hr></hr>", "Tags": "<c++><visual-studio-2012><compiler-construction><c++11><lambda>", "OwnerUserId": "1828879", "AnswerCount": "1"}});