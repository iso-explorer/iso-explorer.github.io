post_cb({"bq_ids": {"n4140": {"so_17438792_17438809_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 7210}}, "n3337": {"so_17438792_17438809_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 6954}}, "n4659": {"so_17438792_17438809_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 8719}}}, "17438829": {"Id": "17438829", "PostTypeId": "2", "Body": "<h2>Use <code>memcpy</code> not a cast</h2>\n<pre><code>char buff[4] = {0x17, 0x89, 0x39, 0x40};\nunsigned int* ptr = (unsigned int*)buff;\n</code></pre>\n<p><strong>This is not correct</strong>: <code>buff</code> does not point to an int object or array, so the cast <code>(unsigned int*)buff</code> is not defined.</p>\n<p>The safe way to reinterpret <code>buff</code> as an <code>unsigned int</code> is with <code>memcpy</code>:</p>\n<pre><code>char buff[4] = {0x17, 0x89, 0x39, 0x40};\nunsigned int ui;\nassert (sizeof ui == sizeof buff);\nmemcpy (buff, &amp;ui, sizeof ui);\n</code></pre>\n<p>When using <code>memcpy</code>, you have no make sure the bit representation you copy is valid for the destination type, of course.</p>\n<p>One portable but degenerate way to do that is to check that the representation matches an existing object (beware, the following is silly code):</p>\n<pre><code>char *null_ptr = 0;\nchar null_bytes[sizeof null_ptr] = {0};\nif (memcmp (null_ptr, null_bytes, sizeof null_bytes)==0) {\n    char *ptr2;\n    memcpy (null_bytes, ptr2, sizeof null_bytes);\n    assert (ptr2 == 0);\n}\n</code></pre>\n<p>This code uses <code>memcpy</code> and has fully defined behavior (even if useless). OTOH, the behavior of </p>\n<pre><code>int *ptr3 = (int*)null_bytes;\n</code></pre>\n<p>is not defined, because <code>null_bytes</code> is not the address of an <code>int</code> or <code>unsigned int</code>.</p>\n", "LastEditorUserId": "963864", "LastActivityDate": "2013-07-03T03:49:05.183", "Score": "0", "CreationDate": "2013-07-03T02:40:40.277", "ParentId": "17438792", "CommentCount": "12", "LastEditDate": "2013-07-03T03:49:05.183", "OwnerUserId": "963864"}, "17438792": {"ViewCount": "302", "Body": "<p>As the title says, I get a \"weird\" result when running the following code:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    char buff[4] = {0x17, 0x89, 0x39, 0x40};\n    unsigned int* ptr = (unsigned int*)buff;\n    char a = (char)((*ptr &lt;&lt; (0*8)) &gt;&gt; (3*8));\n    char b = (char)((*ptr &lt;&lt; (1*8)) &gt;&gt; (3*8));\n    char c = (char)((*ptr &lt;&lt; (2*8)) &gt;&gt; (3*8));\n    char d = (char)((*ptr &lt;&lt; (3*8)) &gt;&gt; (3*8));\n\n    printf(\"0x%x\\n\", *ptr);\n    printf(\"0x%x\\n\", a);\n    printf(\"0x%x\\n\", b);\n    printf(\"0x%x\\n\", c);\n    printf(\"0x%x\\n\", d);\n\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>0x40398917\n0x40\n0x39\n0xffffff89\n0x17\n</code></pre>\n<p>Why am I not getting <code>0x89</code> ?</p>\n", "AcceptedAnswerId": "17438809", "Title": "Strange output when printing the value 0x89 (-119)", "CreationDate": "2013-07-03T02:33:58.337", "Id": "17438792", "CommentCount": "0", "LastEditDate": "2013-07-03T02:39:55.477", "PostTypeId": "1", "LastEditorUserId": "1167346", "LastActivityDate": "2013-07-03T03:49:05.183", "Score": "0", "OwnerUserId": "1167346", "Tags": "<c++><c><hex><output>", "AnswerCount": "3"}, "17438808": {"Id": "17438808", "PostTypeId": "2", "Body": "<p>char, by default, is signed - this means that numbers run from -128 to 127. Any number outside of that doesn't fit. If you changed <code>char</code> to <code>unsigned char</code>, you will get the numbers you expect.</p>\n", "LastActivityDate": "2013-07-03T02:36:52.650", "Score": "0", "CreationDate": "2013-07-03T02:36:52.650", "ParentId": "17438792", "CommentCount": "3", "OwnerUserId": "2514521"}, "17438809": {"Id": "17438809", "PostTypeId": "2", "Body": "<p>It's because your <code>char</code> variables are signed and they're undergoing sign extension when being  promoted (upgraded to a wider type in this case). Sign extension is a way of preserving the sign when doing this promotion, so that <code>-119</code> stays as <code>-119</code> whether it's 8-bit, 16-bit or a wider type.</p>\n<p>You can fix it by explicitly using <code>unsigned char</code> since, in C at least, whether <code>char</code> is signed or unsigned is implementation-specific. From <code>C11 6.2.5 Types /15</code>:</p>\n<blockquote>\n<p id=\"so_17438792_17438809_0\">The implementation shall define char to have the same range, representation, and behavior as either signed char or unsigned char.</p>\n</blockquote>\n<p>Sign extension does not come into play for unsigned types because they're, ... well, unsigned :-)</p>\n", "LastEditorUserId": "14860", "LastActivityDate": "2013-07-03T02:49:48.130", "Score": "4", "CreationDate": "2013-07-03T02:36:56.533", "ParentId": "17438792", "CommentCount": "1", "LastEditDate": "2013-07-03T02:49:48.130", "OwnerUserId": "14860"}});