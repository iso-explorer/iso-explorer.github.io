post_cb({"bq_ids": {"n4140": {"so_29834274_29834456_0": {"length": 52, "quality": 0.9454545454545454, "section_id": 458}}, "n3337": {"so_29834274_29834456_0": {"length": 52, "quality": 0.9454545454545454, "section_id": 449}}, "n4659": {"so_29834274_29834456_0": {"length": 52, "quality": 0.9454545454545454, "section_id": 481}}}, "29834456": {"Id": "29834456", "PostTypeId": "2", "Body": "<p>In [class.copy]:</p>\n<blockquote>\n<p id=\"so_29834274_29834456_0\">If the definition of a class <code>X</code> does not explicitly declare a move constructor, one will be implicitly declared\n  as defaulted if and only if<br>\n  (9.1) \u2014 X does not have a user-declared copy constructor,<br>\n  (9.2) \u2014 X does not have a user-declared copy assignment operator,<br>\n  (9.3) \u2014 X does not have a user-declared move assignment operator, and<br>\n<strong>(9.4) \u2014 X does not have a user-declared destructor.</strong><br>\n<em>[ Note:</em> When the move constructor is not implicitly declared or explicitly supplied, expressions that otherwise\n  would have invoked the move constructor may instead invoke a copy constructor. <em>\u2014end note ]</em></br></br></br></br></br></p>\n</blockquote>\n<p><code>Interface</code> does have a user-declared destructor, so <code>Interface</code>'s move constructor will not be implicitly declared as defaulted. But <code>A</code> doesn't fit any of those bullet points - so it <strong>will</strong> have an implicit move constructor that is defaulted. <code>A(A&amp;&amp; )</code>will just copy the <code>Interface</code> part, as per the note. We can verify this by adding members to <code>Interface</code> and <code>A</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;char c&gt;\nstruct Obj {\n    Obj() { std::cout &lt;&lt; \"default ctor\" &lt;&lt; c &lt;&lt; \"\\n\"; }  \n    Obj(const Obj&amp;) { std::cout &lt;&lt; \"copy ctor\" &lt;&lt; c &lt;&lt; \"\\n\"; }\n    Obj(Obj&amp;&amp;) { std::cout &lt;&lt; \"move ctor\" &lt;&lt; c &lt;&lt; \"\\n\"; }\n};\n\nstruct Interface {\n    virtual void myFunction() = 0;\n    virtual ~Interface() {};\n\n    Obj&lt;'I'&gt; base;\n};\n\nstruct A : public Interface {\n    void myFunction() override {};\n\n    Obj&lt;'A'&gt; derived;\n};\n\nint main() {\n    A a1;                      // default I, default A\n    std::cout &lt;&lt; \"---\\n\";\n    A a2(std::move(a1));       // copy I, move A\n    std::cout &lt;&lt; \"---\\n\";\n    A a3(a2);                  // copy I, copy A\n}\n</code></pre>\n", "LastActivityDate": "2015-04-23T21:16:14.687", "CommentCount": "3", "CreationDate": "2015-04-23T21:16:14.687", "ParentId": "29834274", "Score": "10", "OwnerUserId": "2069064"}, "29834274": {"ViewCount": "1364", "Body": "<p>According to \u201cRule Of Five\u201d when I declare one of: copy or move operation or destructor I must write all of them, because the compiler doesn't generate them (some of them) for me. But if my class (<code>A</code>) derives from an abstract class with a virtual destructor, does this mean that the destructor in class <code>A</code> will be considered \"user-defined\"? As a consequence, will move semantics not work with objects of this class <code>A</code> because compiler won't generate a move constructor for me?</p>\n<pre><code>struct Interface {\n    virtual void myFunction() = 0;\n    virtual ~Interface() {};\n};\n\nstruct A : public Interface {\n    void myFunction() override {};\n};\n</code></pre>\n", "AcceptedAnswerId": "29834456", "Title": "Abstract classes and move semantics", "CreationDate": "2015-04-23T21:03:04.553", "Id": "29834274", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-04-23T21:21:46.933", "LastEditorUserId": "2069064", "LastActivityDate": "2016-01-15T08:57:52.853", "Score": "13", "OwnerUserId": "407981", "Tags": "<c++><c++11><move-semantics>", "AnswerCount": "1"}});