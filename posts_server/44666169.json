post_cb({"44666286": {"ParentId": "44666169", "Score": "0", "CreationDate": "2017-06-21T03:17:48.390", "LastActivityDate": "2017-06-21T23:05:33.207", "LastEditDate": "2017-06-21T23:05:33.207", "OwnerUserId": "1944004", "LastEditorUserId": "1944004", "Body": "<p>This syntax is just not supported.  You can only unpack aggregate classes and objects which for which <code>std::get</code> has been overloaded: <a href=\"https://skebanga.github.io/structured-bindings/\" rel=\"nofollow noreferrer\">https://skebanga.github.io/structured-bindings/</a></p>\n<p>Unfortunately, you cannot really make use of the cool deduction guide because you want a reference to <code>a</code> and not to the tuple member.  Thus you have to write out the template parameter list.</p>\n<pre><code>#include &lt;tuple&gt;\n\nint main()\n{\n  int a = 1;\n  int b = 2;\n  const auto&amp; [x, y] = std::tuple&lt;int&amp;,int&amp;&gt;{a, b};\n}\n</code></pre>\n<p>You could also not be as stupid as me and read the docs correctly.</p>\n<pre><code>#include &lt;tuple&gt;\n\nint main()\n{\n  int a = 1;\n  int b = 2;\n  const auto&amp; [x, y] = std::forward_as_tuple(a, b);\n}\n</code></pre>\n<p><code>const auto&amp; [x, y] = std::tie(a, b);</code> works as well.</p>\n", "Id": "44666286", "PostTypeId": "2", "CommentCount": "7"}, "44666452": {"ParentId": "44666169", "Score": "2", "CreationDate": "2017-06-21T03:37:14.520", "LastActivityDate": "2017-06-21T23:28:28.290", "LastEditDate": "2017-06-21T23:28:28.290", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "Body": "<p>Structured binding is, so to speak, for \"unpacking\" things. It's not designed to be a way to combine normal declarations. That <code>const auto&amp;</code> applies to neither <code>a</code> nor <code>b</code>, despite the appearance. </p>\n<p>Your particular attempt violates <a href=\"https://timsong-cpp.github.io/cppwp/dcl.dcl#8\" rel=\"nofollow noreferrer\">[dcl.dcl]/8</a>:</p>\n<blockquote>\n<p id=\"so_44666169_44666452_0\">A <em>simple-declaration</em> with an <em>identifier-list</em> is called a\n  <em>structured binding declaration</em> ([dcl.struct.bind]). [...] The <em>initializer</em> shall be of the form \u201c<code>= <em>assignment-expression</em> </code>\u201d, of the form \u201c<code>{ <em>assignment-expression</em> }</code>\u201d, or\n  of the form \u201c<code>( <em>assignment-expression</em> )</code>\u201d, where the\n  <em>assignment-expression</em> is of array or non-union class type.</p>\n</blockquote>\n<hr>\n<pre><code>int a = 1, b = 2;\nconst auto bitand &lt;:x, y:&gt; = std::tie(a, b);\n</code></pre>\n<p>This structured binding declaration is (very) roughly equivalent to</p>\n<pre><code>const auto bitand __e = std::tie(a, b); // hidden variable\nauto and x = std::get&lt;0&gt;(__e);\nauto and y = std::get&lt;1&gt;(__e);\n</code></pre>\n<p>(The real thing uses <code>tuple_element</code>, not <code>auto</code>.)</p>\n<p>Notes:</p>\n<ul>\n<li>The <code>const auto bitand</code> applies to <em>the hidden variable</em> and only the hidden variable. <code>x</code> and <code>y</code> are always references even if you write just <code>auto</code>; whether their referent is <code>const</code> depends on the <code>const</code> propagation properties of the initializer's type.</li>\n<li>A temporary materialized from a prvalue initializer will have its lifetime extended by the reference binding.</li>\n<li>In this example, both <code>x</code> and <code>y</code> are of type \"reference to int\"; it is valid to write <code>x = 1;</code>.</li>\n<li>There's special treatment for structured bindings in the <code>decltype</code> wording.</li>\n</ul>\n<p>These semantics are unsurprising if we are talking about unpacking a struct, etc., with two \"reference to int\" members; a <code>const</code> on such things doesn't actually affect the referent's constness. OTOH, you are in for a bad surprise if you want to use structured binding declarations for something they aren't designed to do.</p>\n</hr>", "Id": "44666452", "PostTypeId": "2", "CommentCount": "10"}, "44666169": {"Tags": "<c++><c++1z><structured-bindings>", "ViewCount": "171", "LastEditDate": "2017-06-21T05:32:55.327", "CreationDate": "2017-06-21T03:02:15.290", "LastEditorUserId": "4672588", "Title": "Initializer list and structured bindings deduction ambiguity in C++17", "CommentCount": "0", "AnswerCount": "2", "Score": "1", "OwnerUserId": "5501675", "Id": "44666169", "LastActivityDate": "2017-06-21T23:28:28.290", "Body": "<p>I had always avoided initializations like the following</p>\n<pre><code>const auto&amp; x = a, y = b;\nconst int* const x = ptr_1, *const y = ptr_2;  // wot\n</code></pre>\n<p>For the reason that the reference and pointer qualifiers don't apply to both the initializations.  Granted it's one of the first things beginners learn, the ambiguity associated with it makes me feel like the following is clearer and requires less thought on the reader's end</p>\n<pre><code>const auto&amp; x = a;\nconst auto&amp; y = b;\n</code></pre>\n<p>With C++17 and structured bindings I was happy and saw lots of potential.  C++17 outlawed what C++14 and C++11 had failed to fix, <code>auto x {1}</code> is an <code>int</code> and not <code>std::initializer_list&lt;int&gt;</code>.  But why does the following code not work?</p>\n<pre><code>const auto&amp; [x, y] {a, b};\nconst auto&amp; [x, y] = {a, b};\n</code></pre>\n<p>The latter is in line with the new rules for auto deduction and initializer lists, the expression on the right hand side is treated as an initializer list.  But for the former compilation fails with the following error </p>\n<pre><code>initializer for variable '[a, b]' with type 'const auto &amp;' contains multiple expressions\n</code></pre>\n<p>Is there any way I can declare both x and y with the structured bindings syntax without having to resort to tuples, pairs and the like?  Also why is the former in the code example above ill formed code?  Is there an ambiguity in that syntax?</p>\n", "PostTypeId": "1", "FavoriteCount": "1"}, "bq_ids": {"n4659": {"so_44666169_44666452_0": {"length": 18, "section_id": 6808, "quality": 0.8571428571428571}}}});