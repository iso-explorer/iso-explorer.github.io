post_cb({"24627084": {"ParentId": "24626972", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>In this case (converting object pointers), <code>reinterpret_cast</code> is identical to the two nested <code>static_cast</code> via <code>void*</code></p>\n<p><strong>5.2.10 Reinterpret cast [expr.reinterpret.cast]</strong></p>\n<blockquote>\n<p id=\"so_24626972_24627084_0\">7 An object pointer can be explicitly converted to an object pointer\n  of a di\ufb00erent type.72 When a prvalue v of object pointer type is\n  converted to the object pointer type \u201cpointer to cv T\u201d, the result is\n  <strong><code>static_cast&lt;cv T*&gt;(static_cast&lt;cv void*&gt;(v))</code></strong>. Converting a prvalue of\n  type \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are\n  object types and where the alignment requirements of T2 are no\n  stricter than those of T1) and back to its original type yields the\n  original pointer value.</p>\n</blockquote>\n<p>It is better to use <code>reinterpret_cast</code> to <strong>signal your intent</strong> here.</p>\n<p><strong>UPDATE</strong>: as mentioned in the comments, this was apparently added in C++11, although most C++98 compilers already supported it (see also <a href=\"https://stackoverflow.com/a/573345/819272\"><strong>this Q&amp;A</strong></a>)</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:50:19.450", "Id": "24627084", "Score": "13", "CreationDate": "2014-07-08T08:28:19.770", "LastActivityDate": "2014-07-08T09:43:12.357"}, "24626972": {"CommentCount": "0", "AcceptedAnswerId": "24627084", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-07-08T08:22:49.300", "LastActivityDate": "2014-07-08T09:43:12.357", "LastEditDate": "2017-05-23T12:11:01.687", "ViewCount": "527", "FavoriteCount": "1", "Title": "reinterpret_cast vs. static_cast for writing bytes in standard-layout types?", "Id": "24626972", "Score": "8", "Body": "<p>I need to write to individual bytes of some integer types. Should I used <code>reinterpret_cast</code>, or should I use <code>static_cast</code> via <code>void*</code>?</p>\n<p>(a)</p>\n<pre><code>unsigned short v16;\nchar* p = static_cast&lt;char*&gt;(static_cast&lt;void*&gt;(&amp;v16));\np[1] = ... some char value\np[0] = ... some char value\n</code></pre>\n<p>or (b)</p>\n<pre><code>unsigned short v16;\nchar* p = reinterpret_cast&lt;char*&gt;(&amp;v16);\np[1] = ... some char value\np[0] = ... some char value\n</code></pre>\n<p>According to <a href=\"https://stackoverflow.com/questions/19300142/static-cast-and-reinterpret-cast-for-stdaligned-storage\">static_cast and reinterpret_cast for std::aligned_storage</a> 's <a href=\"https://stackoverflow.com/a/19636998/321013\">answer</a> both should be equivalent --</p>\n<blockquote>\n<p id=\"so_24626972_24626972_0\">-- if both T1 and T2 are standard-layout types and the alignment\n  requirements of T2 are no stricter than those of T1</p>\n</blockquote>\n<p>I'm leaning towards <code>reinterpret_cast</code> as that <em>is</em> essentially what I'm doing, isn't it?</p>\n<p>Are there any other things to consider, specifically looking at Visual-C++ and VC8, the version we're currently compiling on? (x86 only atm.)</p>\n", "Tags": "<c++><c++11><reinterpret-cast><visual-c++-2005><standard-layout>", "OwnerUserId": "321013", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24626972_24627084_0": {"section_id": 6046, "quality": 0.9130434782608695, "length": 42}, "so_24626972_24626972_0": {"section_id": 6046, "quality": 0.75, "length": 6}}, "n3337": {"so_24626972_24627084_0": {"section_id": 5814, "quality": 0.8260869565217391, "length": 38}, "so_24626972_24626972_0": {"section_id": 5814, "quality": 1.0, "length": 8}}, "n4659": {"so_24626972_24627084_0": {"section_id": 7545, "quality": 0.8913043478260869, "length": 41}, "so_24626972_24626972_0": {"section_id": 7545, "quality": 0.75, "length": 6}}}});