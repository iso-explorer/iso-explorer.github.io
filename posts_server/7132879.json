post_cb({"7132879": {"CommentCount": "3", "ViewCount": "116", "CreationDate": "2011-08-20T15:56:31.947", "LastActivityDate": "2011-08-20T20:57:09.707", "Title": "C++0x non-ambiguity of Generalized Initializers", "AcceptedAnswerId": "7134630", "PostTypeId": "1", "Id": "7132879", "Score": "1", "Body": "<p>I found a couple of example of the new <strong>Initializer Syntax</strong> using <code>{...}</code>. But the examples are quite old. I just want to cross-check -- is the current situation still as described?</p>\n<p>In every context (especially templates), the following source fragments always are <strong>non-ambiguous</strong> -- no matter what <code>T</code> and <code>v</code> are.</p>\n<ul>\n<li><code>T{v};</code> -- always constructs a temporary of type <code>T</code> and initialized it with value <code>v</code>.</li>\n<li><code>T x{v};</code> -- initialized a variable <code>x</code> of type <code>T</code> with value <code>v</code>.</li>\n<li><code>T x = {v};</code> -- same, because <code>=</code> is just optional here.</li>\n<li><code>T a[] = {v};</code> -- initializes all elements of an array with the value <code>v</code>.</li>\n<li><code>p = new T{v};</code> -- allocates an object of type <code>T</code> on the heap and initializes it with value <code>v</code>.</li>\n</ul>\n<p>Therefore, it is still true, telling people <em>\"Prefer the <code>{}</code>-syntax, and your source code will not have different meanings, depending on what <code>T</code> and <code>v</code> are\"</em>.</p>\n", "Tags": "<c++11><initialization><curly-braces>", "OwnerUserId": "472245", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_7132879_7134630_0": {"section_id": 599, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_7132879_7134630_0": {"section_id": 589, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_7132879_7134630_0": {"section_id": 622, "quality": 0.8181818181818182, "length": 9}}}, "7134630": {"ParentId": "7132879", "CommentCount": "1", "Body": "<ul>\n<li><code>T x{v};</code> -- initialized a variable x of type T with value v.</li>\n<li><code>T x = {v};</code> -- same, because = is just optional here.</li>\n</ul>\n<p>As far as N3291 (the last working draft before the final standard) is concerned, these are not the same for all possible <code>v</code> and <code>T</code>.</p>\n<p>The principle difference is the following. The first is an explicit constructor call, and it therefore may select a constructor declared <code>explicit</code>. The second is <em>not</em> an explicit constructor call (even though it will call a constructor). Therefore it <em>cannot</em> select <code>explicit</code> constructors.</p>\n<p>From 13.3.1.7:</p>\n<blockquote>\n<p id=\"so_7132879_7134630_0\">In copy-list-initialization, the candidate functions are all the constructors of T. However, if an explicit constructor is chosen, the initialization is ill-formed.</p>\n</blockquote>\n<p>The purpose of this is to ensure that you cannot accidentally perform an <code>explicit</code> conversion of a value when using copy initialization, even with <code>{}</code> syntax.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "7134630", "Score": "6", "CreationDate": "2011-08-20T20:57:09.707", "LastActivityDate": "2011-08-20T20:57:09.707"}});