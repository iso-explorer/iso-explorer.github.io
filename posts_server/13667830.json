post_cb({"bq_ids": {"n4140": {"so_13667830_13668172_2": {"length": 26, "quality": 1.0, "section_id": 6126}}, "n3337": {"so_13667830_13668172_2": {"length": 26, "quality": 1.0, "section_id": 5890}}, "n4659": {"so_13667830_13668172_2": {"length": 26, "quality": 1.0, "section_id": 7623}}}, "13667830": {"ViewCount": "410", "Body": "<pre><code>template&lt;typename T&gt;  \nvoid outer(T&amp;&amp; t) {inner(forward&lt;T&gt;(t));}  \n\ntemplate&lt;typename T&gt;  \nvoid outer(T&amp;&amp; t) {inner((T&amp;&amp;)(t));}  \n</code></pre>\n<p>what is the difference?</p>\n", "Title": "what is the difference between forward<T>(a) and (T&&)(a)", "CreationDate": "2012-12-02T09:02:53.313", "LastActivityDate": "2012-12-02T09:57:46.820", "CommentCount": "1", "LastEditDate": "2012-12-02T09:23:16.623", "PostTypeId": "1", "LastEditorUserId": "304839", "Id": "13667830", "Score": "9", "OwnerUserId": "1870044", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "13668172": {"Id": "13668172", "PostTypeId": "2", "Body": "<p>There is no practical difference. <code>std::forward&lt;T&gt;(v)</code> is specified as <code>static_cast&lt;T&amp;&amp;&gt;(v)</code>.</p>\n<p><code>\u00a720.2.3 [forward]</code></p>\n<pre><code>template &lt;class T&gt; T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; t) noexcept;\ntemplate &lt;class T&gt; T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp;&amp; t) noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_13667830_13668172_0\">2 <em>Returns:</em> <code>static_cast&lt;T&amp;&amp;&gt;(t)</code>.</p>\n</blockquote>\n<p>A C-style cast goes through most C++-style casts to determine the first working one. One of them is <code>static_cast</code>, which also is the first one that works in this case.</p>\n<p><code>\u00a75.4 [expr.cast] p4</code></p>\n<blockquote>\n<p id=\"so_13667830_13668172_1\">The conversions performed by</p>\n<ul>\n<li>a <code>const_cast</code> (5.2.11),</li>\n<li>a <code>static_cast</code> (5.2.9),</li>\n<li>a <code>static_cast</code> followed by a <code>const_cast</code>,</li>\n<li>a <code>reinterpret_cast</code> (5.2.10), or</li>\n<li>a <code>reinterpret_cast</code> followed by a <code>const_cast</code>,</li>\n</ul>\n<p id=\"so_13667830_13668172_2\">can be performed using the cast notation of explicit type conversion. [...] If a conversion can be interpreted in more than one of the ways listed above, the interpretation that appears first in the list is used, even if a cast resulting from that interpretation is ill-formed.</p>\n</blockquote>\n<p>I'd advise to stick with <code>std::forward</code>, though. The intent is clear from the name and and people will know what it does much more likely than knowing what a weird <code>static_cast&lt;T&amp;&amp;&gt;</code> (or even <code>(T&amp;&amp;)</code>) does.</p>\n", "LastActivityDate": "2012-12-02T09:53:01.110", "CommentCount": "0", "CreationDate": "2012-12-02T09:53:01.110", "ParentId": "13667830", "Score": "9", "OwnerUserId": "500104"}, "13668053": {"Id": "13668053", "PostTypeId": "2", "Body": "<p>There is no effective difference. Here is how VC++ defines forward&lt;&gt; for rvalue references:</p>\n<pre><code>template&lt;class _Ty&gt; inline\n    _Ty&amp;&amp; forward(typename remove_reference&lt;_Ty&gt;::type&amp;&amp; _Arg) _NOEXCEPT\n    { // forward anything\n        static_assert(!is_lvalue_reference&lt;_Ty&gt;::value, \"bad forward call\");\n        return (static_cast&lt;_Ty&amp;&amp;&gt;(_Arg));\n    }\n</code></pre>\n", "LastEditorUserId": "445296", "LastActivityDate": "2012-12-02T09:57:46.820", "Score": "1", "CreationDate": "2012-12-02T09:38:35.237", "ParentId": "13667830", "CommentCount": "4", "OwnerUserId": "445296", "LastEditDate": "2012-12-02T09:57:46.820"}});