post_cb({"28117353": {"ParentId": "28110699", "LastEditDate": "2015-01-23T20:14:22.270", "CommentCount": "8", "CreationDate": "2015-01-23T19:32:00.950", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "PostTypeId": "2", "Id": "28117353", "Score": "23", "Body": "<p>The short answer is \"it does it not very well\".</p>\n<p>It invokes <code>f</code> on each of the <code>args...</code>, and discards the return value.  But it does so in a way that leads to unexpected behavior in a number of cases, needlessly.</p>\n<p>The code has no ordering guarantees, and if the return value of <code>f</code> for a given <code>Arg</code> has an overloaded <code>operator,</code> it can have unfortunate side effects.</p>\n<p>With some white space:</p>\n<pre><code>[](...){}(\n  (\n    f(std::forward&lt;Args&gt;(args)), 0\n  )...\n);\n</code></pre>\n<p>We will start from the inside.</p>\n<p><code>f(std::forward&lt;Args&gt;(args))</code> is an incomplete statement that can be expanded with a <code>...</code>.  It will invoke <code>f</code> on one of <code>args</code> when expanded.  Call this statement <code>INVOKE_F</code>.</p>\n<p><code>(INVOKE_F, 0)</code> takes the return value of <code>f(args)</code>, applies <code>operator,</code> then <code>0</code>.  If the return value has no overrides, this discards the return value of <code>f(args)</code> and returns a <code>0</code>.  Call this <code>INVOKE_F_0</code>.  If <code>f</code> returns a type with an overriden <code>operator,(int)</code>, bad things happen here, and if that operator returns a non-POD-esque type, you can get \"conditionally supported\" behavior later on.</p>\n<p><code>[](...){}</code> creates a lambda that takes C-style variardics as its only argument.  This isn't the same as C++11 parameter packs, or C++14 variardic lambdas.  It is possibly illegal to pass non-POD-esque types to a <code>...</code> function.  Call this <code>HELPER</code></p>\n<p><code>HELPER(INVOKE_F_0...)</code> is a parameter pack expansion. in the context of invoking <code>HELPER</code>'s <code>operator()</code>, which is a legal context.  The evaluation of arguments is unspecified, and due to the signature of <code>HELPER</code> <code>INVOKE_F_0...</code> probably should only contain plain old data (in C++03 parlance), or more specifically [expr.call]/p7 says: (via @T.C)</p>\n<blockquote>\n<p id=\"so_28110699_28117353_0\">Passing a potentially-evaluated argument of class type (Clause 9) having a nontrivial copy constructor, a non-trivial move constructor, or a non-trivial destructor, with no corresponding parameter, is conditionally-supported with implementation-defined semantics. </p>\n</blockquote>\n<p>So the problems of this code is that the order is unspecified <em>and</em> it relies on well behaved types <em>or</em> specific compiler implementation choices.</p>\n<p>We can fix the <code>operator,</code> problem as follows:  </p>\n<pre><code>template &lt;class F, class... Args&gt; \nvoid for_each_argument(F f, Args&amp;&amp;... args) { \n  [](...){}((void(f(std::forward&lt;Args&gt;(args))), 0)...); \n}\n</code></pre>\n<p>then we can guarantee order by expanding in an initializer:</p>\n<pre><code>template &lt;class F, class... Args&gt; \nvoid for_each_argument(F f, Args&amp;&amp;... args) { \n  int unused[] = {(void(f(std::forward&lt;Args&gt;(args))), 0)...}; \n  void(unused); // suppresses warnings\n}\n</code></pre>\n<p>but the above fails when <code>Args...</code> is empty, so add another <code>0</code>:</p>\n<pre><code>template &lt;class F, class... Args&gt; \nvoid for_each_argument(F f, Args&amp;&amp;... args) { \n  int unused[] = {0, (void(f(std::forward&lt;Args&gt;(args))), 0)...}; \n  void(unused); // suppresses warnings\n}\n</code></pre>\n<p>and there is no good reason for the compiler to NOT eliminate <code>unused[]</code> from existance, while still evaluated <code>f</code> on <code>args...</code> in order.</p>\n<p>My preferred variant is:</p>\n<pre><code>template &lt;class...F&gt;\nvoid do_in_order(F&amp;&amp;... f) { \n  int unused[] = {0, (void(std::forward&lt;F&gt;(f)()), 0)...}; \n  void(unused); // suppresses warnings\n}\n</code></pre>\n<p>which takes nullary lambdas and runs them one at a time, left to right.  (If the compiler can prove that order does not matter, it is free to run them out of order however).</p>\n<p>We can then implement the above with:</p>\n<pre><code>template &lt;class F, class... Args&gt; \nvoid for_each_argument(F f, Args&amp;&amp;... args) { \n  do_in_order( [&amp;]{ f(std::forward&lt;Args&gt;(args)); }... );\n}\n</code></pre>\n<p>which puts the \"strange expansion\" in an isolated function (<code>do_in_order</code>), and we can use it elsewhere.  We can also write <code>do_in_any_order</code> that works similarly, but makes the <code>any_order</code> clear: however, barring extreme reasons, having code run in a predictable order in a parameter pack expansion reduces surprise and keeps headaches to a minimum.</p>\n<p>A downside to the <code>do_in_order</code> technique is that not all compilers like it -- expanding a parameter pack containing statement that contains entire sub-statements is not something they expect to have to do.</p>\n", "LastActivityDate": "2015-01-23T20:14:22.270"}, "28110699": {"CommentCount": "3", "CreationDate": "2015-01-23T13:12:08.567", "PostTypeId": "1", "AcceptedAnswerId": "28117353", "LastEditorUserId": "1774667", "LastActivityDate": "2015-06-17T14:34:40.613", "LastEditDate": "2015-06-17T14:34:40.613", "ViewCount": "978", "FavoriteCount": "9", "Title": "What does this variadic template code do?", "Id": "28110699", "Score": "15", "Body": "<pre><code>template &lt;class F, class... Args&gt; \nvoid for_each_argument(F f, Args&amp;&amp;... args) { \n    [](...){}((f(std::forward&lt;Args&gt;(args)), 0)...); \n}\n</code></pre>\n<p>It was recently featured on isocpp.org without explanation.</p>\n", "Tags": "<c++><templates><c++11><variadic-templates>", "OwnerUserId": "700825", "AnswerCount": "2"}, "28110741": {"ParentId": "28110699", "LastEditDate": "2017-05-23T12:02:17.340", "CommentCount": "7", "CreationDate": "2015-01-23T13:13:54.167", "OwnerUserId": "1498580", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "28110741", "Score": "12", "Body": "<p>Actually it calls function <code>f</code> for each argument in <code>args</code> in unspecified order.</p>\n<pre><code>[](...){}\n</code></pre>\n<p>create lambda function, that does nothing and receives arbitrary number of arguments (va args).</p>\n<pre><code>((f(std::forward&lt;Args&gt;(args)), 0)...)\n</code></pre>\n<p>argument of lambda.</p>\n<pre><code>(f(std::forward&lt;Args&gt;(args)), 0)\n</code></pre>\n<p>call <code>f</code> with forwarded argument, send <code>0</code> to lambda.</p>\n<p>If you want specified order you can use <a href=\"https://stackoverflow.com/a/17340003/256138\">following thing</a>:</p>\n<pre><code>using swallow = int[];\n(void)swallow{0, (f(std::forward&lt;Args&gt;(args)), 0)...};\n</code></pre>\n", "LastActivityDate": "2015-01-23T13:34:52.077"}, "bq_ids": {"n4140": {"so_28110699_28117353_0": {"section_id": 5994, "quality": 0.95, "length": 19}}, "n3337": {"so_28110699_28117353_0": {"section_id": 5762, "quality": 0.95, "length": 19}}, "n4659": {"so_28110699_28117353_0": {"section_id": 7496, "quality": 0.95, "length": 19}}}});