post_cb({"92497": {"Id": "92497", "PostTypeId": "2", "Body": "<p>New variables can be decalared only at block scope. You need to write something like this:</p>\n<pre><code>case VAL:  \n  // This will work\n  {\n  int newVal = 42;  \n  }\n  break;\n</code></pre>\n<p>Of course, newVal only has scope within the braces...</p>\n<p>Cheers, Ralph</p>\n", "OwnerDisplayName": "Ralph Hempel", "LastActivityDate": "2008-09-18T13:24:17.183", "Score": "1", "CreationDate": "2008-09-18T13:24:17.183", "ParentId": "92396", "CommentCount": "0"}, "92408": {"Body": "<p>The whole switch statement is in the same scope. To get around it, do this:</p>\n<pre><code>switch (val)\n{\n    case VAL:\n    {\n        // This **will** work\n        int newVal = 42;\n    }\n    break;\n\n    case ANOTHER_VAL:\n      ...\n    break;\n}\n</code></pre>\n<p><strong>Note</strong> the brackets.</p>\n", "CreationDate": "2008-09-18T13:13:46.523", "ParentId": "92396", "CommentCount": "1", "LastEditDate": "2015-04-26T10:21:36.017", "PostTypeId": "2", "LastEditorDisplayName": "Mark Ingram", "LastActivityDate": "2015-04-26T10:21:36.017", "LastEditorUserId": "63550", "Id": "92408", "OwnerDisplayName": "Mark Ingram", "Score": "33", "OwnerUserId": "986"}, "3654361": {"Id": "3654361", "PostTypeId": "2", "Body": "<p>Interesting that this is fine:</p>\n<pre><code>switch (i)  \n{  \ncase 0:  \n    int j;  \n    j = 7;  \n    break;  \n\ncase 1:  \n    break;\n}\n</code></pre>\n<p>... but this isn't:</p>\n<pre><code>switch (i)  \n{  \ncase 0:  \n    int j = 7;  \n    break;  \n\ncase 1:  \n    break;\n}\n</code></pre>\n<p>I get that a fix is simple enough, but I'm not understanding yet why the first example doesn't bother the compiler. As was mentioned earlier (2 years earlier hehe), <strong>declaration</strong> is not what causes the error, even despite the logic. Initialisation is the problem. If the variable is initialised and declared on the different lines, it compiles.</p>\n", "LastEditorUserId": "507519", "LastActivityDate": "2011-03-23T02:20:02.663", "Score": "3", "CreationDate": "2010-09-06T21:19:43.920", "ParentId": "92396", "CommentCount": "1", "OwnerUserId": "438082", "LastEditDate": "2011-03-23T02:20:02.663"}, "bq_ids": {"n4140": {"so_92396_37368542_7": {"length": 18, "quality": 0.9473684210526315, "section_id": 3918}, "so_92396_37368542_8": {"length": 30, "quality": 0.967741935483871, "section_id": 3918}}, "n3337": {"so_92396_37368542_8": {"length": 30, "quality": 0.967741935483871, "section_id": 3778}, "so_92396_37368542_7": {"length": 18, "quality": 0.9473684210526315, "section_id": 3778}}, "n4659": {"so_92396_37368542_8": {"length": 31, "quality": 1.0, "section_id": 4804}, "so_92396_37368542_7": {"length": 18, "quality": 0.9473684210526315, "section_id": 4804}}}, "212390": {"Body": "<p>I just wanted to emphasize <em>slim</em>'s <a href=\"https://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement#answer-92477\">point</a>. A switch construct creates a whole, first-class-citizen scope. So it is posible to declare (and initialize) a variable in a switch statement before the first case label, <strong>without</strong> an additional bracket pair:</p>\n<pre><code>switch (val) {  \n  /* This *will* work, even in C89 */\n  int newVal = 42;  \ncase VAL:\n  newVal = 1984; \n  break;\ncase ANOTHER_VAL:  \n  newVal = 2001;\n  break;\n}\n</code></pre>\n", "CreationDate": "2008-10-17T14:31:26.943", "ParentId": "92396", "CommentCount": "2", "LastEditDate": "2017-05-23T11:55:02.523", "Id": "212390", "PostTypeId": "2", "LastActivityDate": "2008-10-17T14:31:26.943", "LastEditorUserId": "-1", "CommunityOwnedDate": "2008-10-17T14:31:26.943", "OwnerDisplayName": "VictorH", "Score": "2"}, "37368542": {"Id": "37368542", "PostTypeId": "2", "Body": "<p>I wrote this answer orginally for <a href=\"https://stackoverflow.com/questions/37368137/c-why-can-we-define-a-variable-in-case-of-switch\">this question</a>. However when I finished it I found that answer has been closed. So I posted it here, maybe someone who likes references to standard will find it helpful.</p>\n<p>Original Code in question:</p>\n<pre><code>int i;\ni = 2;\nswitch(i)\n{\n    case 1: \n        int k;\n        break;\n    case 2:\n        k = 1;\n        cout&lt;&lt;k&lt;&lt;endl;\n        break;\n}\n</code></pre>\n<p>There are actually 2 questions:</p>\n<p><strong>1. Why can I declare a variable after <code>case</code> label?</strong></p>\n<p>It's because in C++ label has to be in form:</p>\n<p>N3337 6.1/1</p>\n<blockquote>\n<p id=\"so_92396_37368542_0\">labeled-statement:</p>\n<p id=\"so_92396_37368542_1\">...</p>\n<ul>\n<li><em>attribute-specifier-seqopt</em> <code>case</code> <code>constant-expression</code> : <code>statement</code></li>\n</ul>\n<p id=\"so_92396_37368542_2\">...</p>\n</blockquote>\n<p>And in <code>C++</code> <em>declaration statement</em> is also considered as <em>statement</em> (as opposed to <code>C</code>):</p>\n<p>N3337 6/1:</p>\n<blockquote>\n<p id=\"so_92396_37368542_3\"><em>statement</em>:</p>\n<p id=\"so_92396_37368542_4\">...</p>\n<p id=\"so_92396_37368542_5\"><em>declaration-statement</em></p>\n<p id=\"so_92396_37368542_6\">...</p>\n</blockquote>\n<p><strong>2. Why can I jump over variable declaration and then use it?</strong></p>\n<p>Because:\nN3337 6.7/3</p>\n<blockquote>\n<p id=\"so_92396_37368542_7\">It is possible to transfer into a block, <strong>but not in a way that bypasses declarations with initialization</strong>. A\n  program that jumps\n  (The <strong>transfer from</strong> the condition of a <strong>switch statement to a case label is considered a jump</strong> in this respect.)</p>\n<p id=\"so_92396_37368542_8\"><strong>from a point where a variable with automatic storage duration is not in scope to a point where it is in scope is ill-formed</strong> <strong>unless the variable has scalar type</strong>, class type with a trivial default\n  constructor and a trivial destructor, a cv-qualified version of one of these types, or an array of one of the\n  preceding types and is declared without an initializer (8.5).</p>\n</blockquote>\n<p>Since <code>k</code> is of <em>scalar type</em>, and is not initialized at point of declaration jumping over it's declaration is possible. This is semantically equivalent:</p>\n<pre><code>goto label;\n\nint x;\n\nlabel:\ncout &lt;&lt; x &lt;&lt; endl;\n</code></pre>\n<p>However that wouldn't be possible, if <code>x</code> was initialized at point of declaration:</p>\n<pre><code> goto label;\n\n    int x = 58; //error, jumping over declaration with initialization\n\n    label:\n    cout &lt;&lt; x &lt;&lt; endl;\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-05-21T22:17:37.487", "Score": "3", "CreationDate": "2016-05-21T22:17:37.487", "ParentId": "92396", "CommentCount": "0", "OwnerUserId": "4932834", "LastEditDate": "2017-05-23T12:18:30.023"}, "92421": {"Id": "92421", "PostTypeId": "2", "Body": "<p>I believe the issue at hand is that is the statement was skipped, and you tried to use the var elsewhere, it wouldn't be declared.</p>\n", "OwnerDisplayName": "William Keller", "LastActivityDate": "2008-09-18T13:15:16.800", "Score": "-1", "CreationDate": "2008-09-18T13:15:16.800", "ParentId": "92396", "CommentCount": "0", "OwnerUserId": "17095"}, "92432": {"Id": "92432", "PostTypeId": "2", "Body": "<p>The entire section of the switch is a single declaration context.  You can't declare a variable in a case statement like that.  Try this instead:</p>\n<pre><code>switch (val)  \n{  \ncase VAL:\n{\n  // This will work\n  int newVal = 42;\n  break;\n}\ncase ANOTHER_VAL:  \n  ...\n  break;\n}\n</code></pre>\n", "OwnerDisplayName": "Andrew Eidsness", "LastActivityDate": "2008-09-18T13:16:24.427", "Score": "4", "CreationDate": "2008-09-18T13:16:24.427", "ParentId": "92396", "CommentCount": "2"}, "92414": {"Id": "92414", "PostTypeId": "2", "Body": "<p>Try this:</p>\n<pre><code>switch (val)\n{\n    case VAL:\n    {\n        int newVal = 42;\n    }\n    break;\n}\n</code></pre>\n", "OwnerDisplayName": "Dan Shield", "LastActivityDate": "2008-09-18T13:14:33.073", "Score": "9", "CreationDate": "2008-09-18T13:14:33.073", "ParentId": "92396", "CommentCount": "0", "OwnerUserId": "4633"}, "92788": {"Id": "92788", "PostTypeId": "2", "Body": "<p>Most of the replies so far are wrong in one respect: you <strong>can</strong> declare variables after the case statement, but you <em>can't</em> initialize them:</p>\n<pre><code>case 1:\n    int x; // Works\n    int y = 0; // Error, initialization is skipped by case\n    break;\ncase 2:\n    ...\n</code></pre>\n<p>As previously mentioned, a nice way around this is to use braces to create a scope for your case.</p>\n", "OwnerDisplayName": "MrZebra", "LastActivityDate": "2008-09-18T14:00:31.840", "Score": "16", "CreationDate": "2008-09-18T14:00:31.840", "ParentId": "92396", "CommentCount": "3", "OwnerUserId": "17440"}, "27733339": {"Id": "27733339", "PostTypeId": "2", "Body": "<p>A <code>switch</code> block <strong>isn't the same as a succession of <code>if/else if</code> blocks.</strong> I'm surprised no other answer explains it clearly.</p>\n<p>Consider this <code>switch</code> statement :</p>\n<pre><code>switch (value) {\n    case 1:\n        int a = 10;\n        break;\n    case 2:\n        int a = 20;\n        break;\n}\n</code></pre>\n<p>It may be surprising, but the compiler will not see it as a simple <code>if/else if</code>. It will produce the following code :</p>\n<pre><code>if (value == 1)\n    goto label_1;\nelse if (value == 2)\n    goto label_2;\nelse\n    goto label_end;\n\n{\nlabel_1:\n    int a = 10;\n    goto label_end;\nlabel_2:\n    int a = 20; // Already declared !\n    goto label_end;\n}\n\nlabel_end:\n    // The code after the switch block\n</code></pre>\n<p>The <code>case</code> statements are converted into labels and then called with <code>goto</code>. The brackets create a new scope and it is easy to see now why you can't declare two variables with the same name within a <code>switch</code> block.</p>\n<p>It may look weird, but it is necessary to support <em>fallthrough</em> (that is, not using <code>break</code> to let execution continue to the next <code>case</code>). </p>\n", "LastActivityDate": "2015-01-01T18:17:08.520", "CommentCount": "0", "CreationDate": "2015-01-01T18:17:08.520", "ParentId": "92396", "Score": "1", "OwnerUserId": "533552"}, "92423": {"Body": "<p>You can't do this, because <code>case</code> labels are actually just entry points into the containing block.</p>\n<p>This is most clearly illustrated by <a href=\"http://en.wikipedia.org/wiki/Duff%27s_device\" rel=\"noreferrer\">Duff's device</a>. Here's some code from Wikipedia:</p>\n<pre><code>strcpy(char *to, char *from, size_t count) {\n    int n = (count + 7) / 8;\n    switch (count % 8) {\n    case 0: do { *to = *from++;\n    case 7:      *to = *from++;\n    case 6:      *to = *from++;\n    case 5:      *to = *from++;\n    case 4:      *to = *from++;\n    case 3:      *to = *from++;\n    case 2:      *to = *from++;\n    case 1:      *to = *from++;\n               } while (--n &gt; 0);\n    }\n}\n</code></pre>\n<p>Notice how the <code>case</code> labels totally ignore the block boundaries. Yes, this is evil. But this is why your code example doesn't work. Jumping to a <code>case</code> label is the same as using <code>goto</code>, so you aren't allowed to jump over a local variable with a constructor.</p>\n<p>As several other posters have indicated, you need to put in a block of your own:</p>\n<pre><code>switch (...) {\n    case FOO: {\n        MyObject x(...);\n        ...\n        break; \n    }\n    ...\n }\n</code></pre>\n", "CreationDate": "2008-09-18T13:15:23.587", "ParentId": "92396", "CommentCount": "9", "LastEditDate": "2010-09-05T20:45:12.577", "PostTypeId": "2", "OwnerDisplayName": "emk", "LastEditorUserId": "12089", "LastActivityDate": "2010-09-05T20:45:12.577", "Id": "92423", "Score": "21", "OwnerUserId": "12089"}, "92424": {"Id": "92424", "PostTypeId": "2", "Body": "<p>newVal exists in the entire scope of the switch but is only initialised if the VAL limb is hit. If you create a block around the code in VAL it should be OK.</p>\n", "OwnerDisplayName": "marijne", "LastActivityDate": "2008-09-18T13:15:25.647", "Score": "0", "CreationDate": "2008-09-18T13:15:25.647", "ParentId": "92396", "CommentCount": "0", "OwnerUserId": "7038"}, "92439": {"Body": "<p><code>Case</code> statements are only <strong>labels</strong>. This means the compiler will interpret this as a jump directly to the label. In C++, the problem here is one of scope. Your curly brackets define the scope as everything inside the <code>switch</code> statement. This means that you are left with a scope where a jump will be performed further into the code skipping the initialization. The correct way to handle this is to define a scope specific to that <code>case</code> statement and define your variable within it. </p>\n<pre><code>switch (val)\n{   \ncase VAL:  \n{\n  // This will work\n  int newVal = 42;  \n  break;\n}\ncase ANOTHER_VAL:  \n...\nbreak;\n}\n</code></pre>\n", "CreationDate": "2008-09-18T13:17:14.533", "ParentId": "92396", "CommentCount": "8", "LastEditDate": "2016-10-27T18:12:39.747", "PostTypeId": "2", "OwnerDisplayName": "Thomas", "LastEditorUserId": "5167682", "LastActivityDate": "2016-10-27T18:12:39.747", "Id": "92439", "Score": "892", "OwnerUserId": "3022"}, "11408021": {"Id": "11408021", "PostTypeId": "2", "Body": "<p>C++ Standard has:\nIt is possible to transfer into a block, but not in a way that bypasses declarations with initialization. A program that jumps from a point where a local variable with automatic storage duration is not in scope to a point where it is in scope is ill-formed unless the variable has POD type (3.9) and is declared without an initializer (8.5).</p>\n<p>The code to illustrate this rule:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass X {\n  public:\n    X() \n    {\n     cout &lt;&lt; \"constructor\" &lt;&lt; endl;\n    }\n    ~X() \n    {\n     cout &lt;&lt; \"destructor\" &lt;&lt; endl;\n    }\n};\n\ntemplate &lt;class type&gt;\nvoid ill_formed()\n{\n  goto lx;\nly:\n  type a;\nlx:\n  goto ly;\n}\n\ntemplate &lt;class type&gt;\nvoid ok()\n{\nly:\n  type a;\nlx:\n  goto ly;\n}\n\nvoid test_class()\n{\n  ok&lt;X&gt;();\n  // compile error\n  ill_formed&lt;X&gt;();\n}\n\nvoid test_scalar() \n{\n  ok&lt;int&gt;();\n  ill_formed&lt;int&gt;();\n}\n\nint main(int argc, const char *argv[]) \n{\n  return 0;\n}\n</code></pre>\n<p>The code to show the initializer effect:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint test1()\n{\n  int i = 0;\n  // There jumps fo \"case 1\" and \"case 2\"\n  switch(i) {\n    case 1:\n      // Compile error because of the initializer\n      int r = 1; \n      break;\n    case 2:\n      break;\n  };\n}\n\nvoid test2()\n{\n  int i = 2;\n  switch(i) {\n    case 1:\n      int r;\n      r= 1; \n      break;\n    case 2:\n      cout &lt;&lt; \"r: \" &lt;&lt; r &lt;&lt; endl;\n      break;\n  };\n}\n\nint main(int argc, const char *argv[]) \n{\n  test1();\n  test2();\n  return 0;\n}\n</code></pre>\n", "LastActivityDate": "2012-07-10T06:48:19.453", "CommentCount": "0", "CreationDate": "2012-07-10T06:48:19.453", "ParentId": "92396", "Score": "0", "OwnerUserId": "431698"}, "94483": {"Id": "94483", "PostTypeId": "2", "Body": "<p>My favorite evil switch trick is to use an if(0) to skip over an unwanted case label.</p>\n<pre><code>switch(val)\n{\ncase 0:\n// Do something\nif (0) {\ncase 1:\n// Do something else\n}\ncase 2:\n// Do something in all cases\n}\n</code></pre>\n<p>But very evil.</p>\n", "OwnerDisplayName": "Jeremy", "LastActivityDate": "2008-09-18T17:02:47.783", "Score": "12", "CreationDate": "2008-09-18T17:02:47.783", "ParentId": "92396", "CommentCount": "4", "OwnerUserId": "3657"}, "1368293": {"Id": "1368293", "PostTypeId": "2", "Body": "<p>So far the answers have been for C++.</p>\n<p>For C++, you can't jump over an initialization. You can in C. However, in C, a declaration is not a statement, and case labels have to be followed by statements.</p>\n<p>So, valid (but ugly) C, invalid C++</p>\n<pre><code>switch (something)\n{\n  case 1:; // Ugly hack empty statement\n    int i = 6;\n    do_stuff_with_i(i);\n    break;\n  case 2:\n    do_something();\n    break;\n  default:\n    get_a_life();\n}\n</code></pre>\n<p>Conversly, in C++, a declaration is a statement, so the following is valid C++, invalid C</p>\n<pre><code>switch (something)\n{\n  case 1:\n    do_something();\n    break;\n  case 2:\n    int i = 12;\n    do_something_else();\n}\n</code></pre>\n", "LastActivityDate": "2009-09-02T15:08:23.113", "CommentCount": "1", "CreationDate": "2009-09-02T15:08:23.113", "ParentId": "92396", "Score": "3", "OwnerUserId": "160054"}, "92730": {"Id": "92730", "PostTypeId": "2", "Body": "<p>Ok.  Just to clarify this strictly has nothing to do with the declaration.  It relates only to \"jumping over the initialization\" (ISO C++ '03 6.7/3)</p>\n<p>A lot of the posts here have mentioned that jumping over the declaration may result in the variable \"not being declared\".  This is not true.  An POD object can be declared without an initializer but it will have an indeterminate value.   For example:</p>\n<pre><code>switch (i)\n{\n   case 0:\n     int j; // 'j' has indeterminate value\n     j = 0; // 'j' initialized to 0, but this statement\n            // is jumped when 'i == 1'\n     break;\n   case 1:\n     ++j;   // 'j' is in scope here - but it has an indeterminate value\n     break;\n}\n</code></pre>\n<p>Where the object is a non-POD or aggregate the compiler implicitly adds an initializer, and so it is not possible to jump over such a declaration:</p>\n<pre><code>class A {\npublic:\n  A ();\n};\n\nswitch (i)  // Error - jumping over initialization of 'A'\n{\n   case 0:\n     A j;   // Compiler implicitly calls default constructor\n     break;\n   case 1:\n     break;\n}\n</code></pre>\n<p>This limitation is not limited to the switch statement.  It is also an error to use 'goto' to jump over an initialization:</p>\n<pre><code>goto LABEL;    // Error jumping over initialization\nint j = 0; \nLABEL:\n  ;\n</code></pre>\n<p>A bit of trivia is that this is a difference between C++ and C.  In C, it is not an error to jump over the initialization.</p>\n<p>As others have mentioned, the solution is to add a nested block so that the lifetime of the variable is limited to the individual case label.</p>\n", "OwnerDisplayName": "Richard Corden", "LastActivityDate": "2008-09-18T13:54:04.447", "Score": "123", "CreationDate": "2008-09-18T13:54:04.447", "ParentId": "92396", "CommentCount": "5", "OwnerUserId": "11698"}, "19830820": {"Id": "19830820", "PostTypeId": "2", "Body": "<p>This question is tagged as [C] and [C++] at the same time. The original code is indeed invalid in both C and C++, but for completely different unrelated reasons. I believe this important detail was missed (or obfuscated) by the existing answers.</p>\n<ul>\n<li><p>In C++ this code is invalid because the <code>case ANOTHER_VAL:</code> label jumps into the scope of variable <code>newVal</code> bypassing its initialization. Jumps that bypass initialization of local objects are illegal in C++. This side of the issue is correctly addressed by most answers.</p></li>\n<li><p>However, in C language bypassing variable initialization is not an error. Jumping into the scope of a variable over it initialization is legal in C. It simply means that the variable is left uninitialized. The original code does not compile in C for a completely different reason. Label <code>case VAL:</code> in the original code is attached to the declaration of variable <code>newVal</code>. In C language declarations are not statements. They cannot be labeled. And this is what causes the error when this code is interpreted as C code.</p>\n<pre><code>switch (val)  \n{  \ncase VAL:             /* &lt;- C error is here */\n  int newVal = 42;  \n  break;\ncase ANOTHER_VAL:     /* &lt;- C++ error is here */\n  ...\n  break;\n}\n</code></pre></li>\n</ul>\n<p>Adding an extra <code>{}</code> block fixes both C++ and C problems, even though these problems happen to be very different. On the C++ side it restricts the scope of <code>newVal</code>, making sure that <code>case ANOTHER_VAL:</code> no longer jumps into that scope, which eliminates the C++ issue. On the C side that extra <code>{}</code> introduces a compound statement, thus making the <code>case VAL:</code> label to apply to a statement, which eliminates the C issue.</p>\n<ul>\n<li><p>In C case the problem can be easily solved without the <code>{}</code>. Just add an empty statement after the <code>case VAL:</code> label and the code will become valid</p>\n<pre><code>switch (val)  \n{  \ncase VAL:;            /* Now it works in C! */\n  int newVal = 42;  \n  break;\ncase ANOTHER_VAL:  \n  ...\n  break;\n}\n</code></pre>\n<p>Note that even though it is now valid from C point of view, it remains invalid from C++ point of view.</p></li>\n<li><p>Symmetrically, in C++ case the the problem can be easily solved without the <code>{}</code>. Just remove the initializer from variable declaration and the code will become valid</p>\n<pre><code>switch (val)  \n{  \ncase VAL: \n  int newVal;\n  newVal = 42;  \n  break;\ncase ANOTHER_VAL:     /* Now it works in C++! */\n  ...\n  break;\n}\n</code></pre>\n<p>Note that even though it is now valid from C++ point of view, it remains invalid from C point of view.</p></li>\n</ul>\n", "LastEditorUserId": "187690", "LastActivityDate": "2017-04-10T07:45:11.227", "Score": "161", "CreationDate": "2013-11-07T08:12:16.270", "ParentId": "92396", "CommentCount": "7", "OwnerUserId": "187690", "LastEditDate": "2017-04-10T07:45:11.227"}, "14770979": {"Id": "14770979", "PostTypeId": "2", "Body": "<p>It appears that anonymous objects <em>can</em> be declared or created in a switch case statement for the reason that they cannot be referenced and as such cannot fall through to the next case. Consider this example compiles on GCC 4.5.3 and Visual Studio 2008 (might be a compliance issue tho' so experts please weigh in)</p>\n<pre><code>#include &lt;cstdlib&gt;\n\nstruct Foo{};\n\nint main()\n{\n    int i = 42;\n\n    switch( i )\n    {\n    case 42:\n        Foo();  // Apparently valid\n        break;\n\n    default:\n        break;\n    }\n    return EXIT_SUCCESS;\n}\n</code></pre>\n", "LastActivityDate": "2013-02-08T10:55:29.563", "CommentCount": "3", "CreationDate": "2013-02-08T10:55:29.563", "ParentId": "92396", "Score": "-1", "OwnerUserId": "181783"}, "8550253": {"Id": "8550253", "PostTypeId": "2", "Body": "<p>After reading all answers and some more research I get a few things.</p>\n<pre><code>Case statements are only 'labels'\n</code></pre>\n<p><strong>In C, according to the specification,</strong></p>\n<p>\u00a76.8.1 Labeled Statements:</p>\n<pre><code>labeled-statement:\n    identifier : statement\n    case constant-expression : statement\n    default : statement\n</code></pre>\n<p>In C there isn't any clause that allows for a \"labeled declaration\". It's just not part of the language.</p>\n<p>So</p>\n<pre><code>case 1: int x=10;\n        printf(\" x is %d\",x);\nbreak;\n</code></pre>\n<p>This <strong>will not compile</strong>, see <a href=\"http://codepad.org/YiyLQTYw\" rel=\"noreferrer\">http://codepad.org/YiyLQTYw</a>. GCC is giving an error:</p>\n<pre><code>label can only be a part of statement and declaration is not a statement\n</code></pre>\n<p>Even</p>\n<pre><code>  case 1: int x;\n          x=10;\n            printf(\" x is %d\",x);\n    break;\n</code></pre>\n<p>this is <strong>also not compiling</strong>, see <a href=\"http://codepad.org/BXnRD3bu\" rel=\"noreferrer\">http://codepad.org/BXnRD3bu</a>. Here I am also getting the same error.</p>\n<hr>\n<p><strong>In C++, according to the specification,</strong></p>\n<p>labeled-declaration is allowed but labeled -initialization is not allowed.</p>\n<p>See <a href=\"http://codepad.org/ZmQ0IyDG\" rel=\"noreferrer\">http://codepad.org/ZmQ0IyDG</a>.</p>\n<hr>\n<p><strong>Solution to such condition is two</strong></p>\n<ol>\n<li><p>Either use new scope using {}</p>\n<pre><code>case 1:\n       {\n           int x=10;\n           printf(\" x is %d\", x);\n       }\nbreak;\n</code></pre></li>\n<li><p>Or use dummy statement with label</p>\n<pre><code>case 1: ;\n           int x=10;\n           printf(\" x is %d\",x);\nbreak;\n</code></pre></li>\n<li><p>Declare the variable before switch() and initialize it with different values in case statement if it fulfills your requirement</p>\n<pre><code>main()\n{\n    int x;   // Declare before\n    switch(a)\n    {\n    case 1: x=10;\n        break;\n\n    case 2: x=20;\n        break;\n    }\n}\n</code></pre></li>\n</ol>\n<hr>\n<p><strong>Some more things with switch statement</strong></p>\n<p>Never write any statements in the switch which are not part of any label, because they will never executed:</p>\n<pre><code>switch(a)\n{\n    printf(\"This will never print\"); // This will never executed\n\n    case 1:\n        printf(\" 1\");\n        break;\n\n    default:\n        break;\n}\n</code></pre>\n<p>See <a href=\"http://codepad.org/PA1quYX3\" rel=\"noreferrer\">http://codepad.org/PA1quYX3</a>.</p>\n</hr></hr></hr>", "LastEditorUserId": "5358284", "LastActivityDate": "2016-07-12T12:51:39.830", "Score": "25", "CreationDate": "2011-12-18T06:33:17.943", "ParentId": "92396", "CommentCount": "2", "OwnerUserId": "775964", "LastEditDate": "2016-07-12T12:51:39.830"}, "92422": {"Body": "<p>You can declare variables within a switch statement <em>if</em> you start a new block:</p>\n<pre><code>switch (thing)\n{ \n  case A:\n  {\n    int i = 0;  // Completely legal\n  }\n  break;\n}\n</code></pre>\n<p>The reason is to do with allocating (and reclaiming) space on the stack for storage of the local variable(s).</p>\n", "CreationDate": "2008-09-18T13:15:17.660", "ParentId": "92396", "CommentCount": "1", "LastEditDate": "2009-10-18T06:12:18.553", "PostTypeId": "2", "OwnerDisplayName": "Seb Rose", "LastEditorUserId": "40468", "LastActivityDate": "2009-10-18T06:12:18.553", "Id": "92422", "Score": "6", "OwnerUserId": "12405"}, "92477": {"Id": "92477", "PostTypeId": "2", "Body": "<p>Consider:</p>\n<pre><code>switch(val)\n{\ncase VAL:\n   int newVal = 42;\ndefault:\n   int newVal = 23;\n}\n</code></pre>\n<p>In the absence of break statements, sometimes newVal gets declared twice, and you don't know whether it does until runtime. My guess is that the limitation is because of this kind of confusion. What would the scope of newVal be? Convention would dictate that it would be the whole of the switch block (between the braces).</p>\n<p>I'm no C++ programmer, but in C:</p>\n<pre><code>switch(val) {\n    int x;\n    case VAL:\n        x=1;\n}\n</code></pre>\n<p>Works fine. Declaring a variable inside a switch block is fine. Declaring after a case guard is not.</p>\n", "OwnerDisplayName": "slim", "LastActivityDate": "2008-09-18T13:22:09.483", "Score": "5", "CreationDate": "2008-09-18T13:22:09.483", "ParentId": "92396", "CommentCount": "2", "OwnerUserId": "7512"}, "92473": {"Id": "92473", "PostTypeId": "2", "Body": "<p>If your code says \"int newVal=42\" then you would reasonably expect that newVal is never uninitialised. But if you goto over this statement (which is what you're doing) then that's exactly what happens - newVal is in-scope but has not been assigned.</p>\n<p>If that is what you really meant to happen then the language requires to make it explicit by saying \"int newVal; newVal = 42;\". Otherwise you can limit the scope of newVal to the single case, which is more likely what you wanted.</p>\n<p>It may clarify things if you consider the same example but with \"const int newVal = 42;\"</p>\n", "OwnerDisplayName": "Mike F", "LastActivityDate": "2008-09-18T13:21:36.537", "Score": "3", "CreationDate": "2008-09-18T13:21:36.537", "ParentId": "92396", "CommentCount": "0"}, "92396": {"ViewCount": "191074", "Body": "<p>I've always wondered this - why can't you declare variables after a case label in a switch statement?  In C++ you can declare variables pretty much anywhere (and declaring them close to first use is obviously a good thing) but the following still won't work:</p>\n<pre><code>switch (val)  \n{  \ncase VAL:  \n  // This won't work\n  int newVal = 42;  \n  break;\ncase ANOTHER_VAL:  \n  ...\n  break;\n}  \n</code></pre>\n<p>The above gives me the following error (MSC):</p>\n<blockquote>\n<p id=\"so_92396_92396_0\">initialization of 'newVal' is skipped by 'case' label</p>\n</blockquote>\n<p>This seems to be a limitation in other languages too.  Why is this such a problem?</p>\n", "AcceptedAnswerId": "92439", "Title": "Why can't variables be declared in a switch statement?", "CreationDate": "2008-09-18T13:11:55.467", "Id": "92396", "CommentCount": "3", "FavoriteCount": "215", "PostTypeId": "1", "LastEditDate": "2013-11-07T08:03:18.603", "LastEditorDisplayName": "mark", "OwnerDisplayName": "Rob", "LastEditorUserId": "187690", "LastActivityDate": "2017-04-10T07:45:11.227", "Score": "724", "OwnerUserId": "9236", "Tags": "<c++><c><switch-statement>", "AnswerCount": "23"}});