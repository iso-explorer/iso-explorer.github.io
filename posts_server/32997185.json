post_cb({"32997605": {"Id": "32997605", "PostTypeId": "2", "Body": "<p>Yes, it's well defined for all those cases. The answers do not change if <code>memcpy</code> is replaced by copy assignment (copying for trivially copyable types <em>is</em> byte-wise copy. That's what makes it trivial), and for all trivially copyable types, move construction IS copy construction, so there's no difference there either.</p>\n<p>From [basic.types]:</p>\n<blockquote>\n<p id=\"so_32997185_32997605_0\">For any object (other than a base-class subobject) of trivially copyable type T, <strong>whether or not the object\n  holds a valid value</strong> of type T, the underlying bytes (1.7) making up the object can be copied into an array\n  of char or unsigned char. If the content of the array of char or unsigned char is copied back into the\n  object, the object shall subsequently hold its original value.</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_32997185_32997605_1\">For any trivially copyable type <code>T</code>, if two pointers to <code>T</code> point to distinct <code>T</code> objects <code>obj1</code> and <code>obj2</code>, where\n  neither <code>obj1</code> nor <code>obj2</code> is a base-class subobject, if the underlying bytes (1.7) making up <code>obj1</code> are copied\n  into <code>obj2</code>, <code>obj2</code> shall subsequently hold the same value as <code>obj1</code>. <em>[ Example:</em></p>\n<pre><code>T* t1p;\nT* t2p;\n// provided that t2p points to an initialized object ...\nstd::memcpy(t1p, t2p, sizeof(T));\n// at this point, every subobject of trivially copyable type in *t1p contains\n// the same value as the corresponding subobject in *t2p\n</code></pre>\n<p id=\"so_32997185_32997605_2\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>where:</p>\n<blockquote>\n<p id=\"so_32997185_32997605_3\"><strong>Arithmetic types</strong> (3.9.1), enumeration types, pointer types, pointer to member types (3.9.2), std::nullptr_-\n  t, and cv-qualified versions of these types (3.9.3) are collectively called scalar types. Scalar types, POD classes\n  (Clause 9), arrays of such types and cv-qualified versions of these types (3.9.3) are collectively called POD\n  types. Cv-unqualified <strong>scalar types, trivially copyable class types (Clause 9)</strong>, arrays of such types, and nonvolatile\n  const-qualified versions of these types (3.9.3) are collectively called <strong>trivially copyable types</strong>.</p>\n</blockquote>\n<p>Where, from [class]:</p>\n<blockquote>\n<p id=\"so_32997185_32997605_4\">A <em>trivially copyable class</em> is a class that:<br>\n  (6.1) \u2014 has no non-trivial copy constructors (12.8),<br>\n  (6.2) \u2014 has no non-trivial move constructors (12.8),<br>\n  (6.3) \u2014 has no non-trivial copy assignment operators (13.5.3, 12.8),<br>\n  (6.4) \u2014 has no non-trivial move assignment operators (13.5.3, 12.8), and<br>\n  (6.5) \u2014 has a trivial destructor (12.4).  </br></br></br></br></br></p>\n</blockquote>\n<p>So, <code>char</code>, <code>int</code>, and <code>struct { int data; };</code> are all trivially copyable types. The former two are cv-unqualified scalar types and the latter is a trivially copyable class type. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-10-07T17:05:50.170", "Score": "3", "CreationDate": "2015-10-07T16:27:27.823", "ParentId": "32997185", "CommentCount": "14", "OwnerUserId": "2069064", "LastEditDate": "2015-10-07T17:05:50.170"}, "bq_ids": {"n4140": {"so_32997185_32997605_1": {"length": 30, "quality": 0.9375, "section_id": 7201}, "so_32997185_32997605_4": {"length": 19, "quality": 0.7037037037037037, "section_id": 5850}, "so_32997185_32997605_0": {"length": 40, "quality": 0.975609756097561, "section_id": 7200}, "so_32997185_32997605_3": {"length": 50, "quality": 0.8771929824561403, "section_id": 7207}}, "n3337": {"so_32997185_32997605_1": {"length": 30, "quality": 0.9375, "section_id": 6945}, "so_32997185_32997605_4": {"length": 19, "quality": 0.7037037037037037, "section_id": 5620}, "so_32997185_32997605_0": {"length": 40, "quality": 0.975609756097561, "section_id": 6944}, "so_32997185_32997605_3": {"length": 46, "quality": 0.8070175438596491, "section_id": 6951}}, "n4659": {"so_32997185_32997605_1": {"length": 30, "quality": 0.9375, "section_id": 8710}, "so_32997185_32997605_3": {"length": 44, "quality": 0.7719298245614035, "section_id": 8716}, "so_32997185_32997605_0": {"length": 37, "quality": 0.9024390243902439, "section_id": 8709}}}, "32997822": {"Id": "32997822", "PostTypeId": "2", "Body": "<p>There are a couple things at play here:</p>\n<ul>\n<li>an expression evaluating to an indeterminate value causes undefined behavior, with certain exceptions (8.5p12)</li>\n<li><code>unsigned char</code> (and possibly <code>char</code>, if unsigned) is the exception</li>\n<li>variables with automatic storage duration and whose types have trivial default initialization initially have indeterminate values (5.3.4p17)</li>\n</ul>\n<p>This means that</p>\n<ul>\n<li><code>unsigned char</code> is fine, no matter whether using <code>memcpy</code> or <code>memmove</code> or copy-assignment or copy-constructor</li>\n<li><code>memcpy</code> and <code>memmove</code> is presumably fine for all types, because the result is not \"produced by an evaluation\" (to meet this requirement, an implementation can use <code>unsigned char</code> internally, or take advantage of implementation-specific guarantees made for other types)</li>\n<li>copy-constructor and copy-assignment for other types will fail if the right-hand-side is an indeterminate value</li>\n</ul>\n<p>Of course, even the valid methods for copying an indeterminate value create another indeterminate value.</p>\n<hr>\n<p>Paragraph numbers correspond to draft n4527</p>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2015-10-07T17:19:31.440", "Score": "4", "CreationDate": "2015-10-07T16:38:51.973", "ParentId": "32997185", "CommentCount": "12", "OwnerUserId": "103167", "LastEditDate": "2015-10-07T17:19:31.440"}, "32997185": {"ViewCount": "195", "Body": "<p>For a <strong><em><a href=\"http://en.cppreference.com/w/cpp/concept/TriviallyCopyable\" rel=\"nofollow noreferrer\">trivially copyable</a></em></strong> type T consider:</p>\n<pre><code>void f(T z)\n{\n   T a;\n   T b;\n   std::memcpy(&amp;b, &amp;a, sizeof(T));\n\n   a = z;\n   b = z;\n\n   // ...\n}\n</code></pre>\n<p>Is the behavior of this fragment defined in C++14 if</p>\n<ol>\n<li>T is char,</li>\n<li>T is int, or</li>\n<li>T is struct { int data; }; ?</li>\n</ol>\n<p>Assume that <code>f</code> gets passed an object that holds a valid value.</p>\n<p>Do the answers change if the call to <code>memcpy</code> is replaced by <em>copy assignment</em> <code>b = a</code>?</p>\n<p>Can the results be carried over to <em>copy construction</em> <code>T(a)</code> and <em>move construction/assignment</em>?</p>\n<hr>\n<p><strong>Note</strong>: This question, in contrast to <a href=\"https://stackoverflow.com/questions/4178175\">What are Aggregates and PODs and how/why are they special?</a>, is particularly concerned with the corner case of copying <em>indeterminate values</em>.</p>\n</hr>", "AcceptedAnswerId": "32997822", "Title": "Is copying trivially copyable objects always defined in C++14?", "CreationDate": "2015-10-07T16:05:41.090", "Id": "32997185", "CommentCount": "8", "LastEditDate": "2017-05-23T11:44:48.723", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-07T17:21:13.853", "Score": "2", "OwnerUserId": "3127195", "Tags": "<c++><c++14><undefined-behavior>", "AnswerCount": "2"}});