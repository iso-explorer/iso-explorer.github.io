post_cb({"bq_ids": {"n4140": {"so_20464648_20476142_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 68}}, "n3337": {"so_20464648_20476142_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 63}}, "n4659": {"so_20464648_20476142_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 70}}}, "20464648": {"ViewCount": "173", "Body": "<p>I have a class template which takes a type and a pointer to a variable of that type:</p>\n<pre><code>template &lt;typename arg_t, arg_t* storage&gt;\nclass Value;\n</code></pre>\n<p>I have a second class template which takes a variable number of templates of the first class:</p>\n<pre><code>template &lt;typename... arg_t&gt;\nclass ValueList;\n</code></pre>\n<p>I want to make it so that only types of class template Value can be used as arguments to ValueList by partial specialization.  This is what I'd expect to work:</p>\n<pre><code>template &lt;typename... arg_t, arg_t*... storage&gt;\nclass ValueList&lt;Value&lt;arg_t, storage&gt;...&gt;;\n</code></pre>\n<p>In Visual C++ 2013, I get the error: <code>'arg_t*': parameter pack cannot be expanded in this context</code>.  Note that this kind of expansion works for templates that only take types, IE this...</p>\n<pre><code>template &lt;typename...&gt;\nclass A;\n\ntemplate &lt;template &lt;typename, typename&gt; class B, typename... C, typename... D&gt;\nclass A&lt;B&lt;C, D&gt;...&gt; {};\n</code></pre>\n<p>...is valid.  What makes this case any different, and what is the correct syntax that will achieve the desired effect?</p>\n<p>Usage:</p>\n<pre><code>int a;\nfloat b;\n\nint main(int argc, char** argv) {\n    ValueList&lt;Value&lt;int, &amp;a&gt;, Value&lt;float, &amp;b&gt; &gt; list;\n}\n</code></pre>\n", "AcceptedAnswerId": "20476142", "Title": "Variadic template templates with data pointers", "CreationDate": "2013-12-09T06:41:24.587", "Id": "20464648", "CommentCount": "7", "LastEditDate": "2013-12-09T07:10:12.977", "PostTypeId": "1", "LastEditorUserId": "2228070", "LastActivityDate": "2013-12-09T18:48:52.643", "Score": "2", "OwnerUserId": "2228070", "Tags": "<c++><templates><visual-c++><c++11><variadic-templates>", "AnswerCount": "2"}, "20476142": {"Id": "20476142", "PostTypeId": "2", "Body": "<p>According to \u00a714.1/15 the code in the string</p>\n<pre><code>template &lt;typename... arg_t, arg_t*... storage&gt;\n</code></pre>\n<p>is not allowed:</p>\n<blockquote>\n<p id=\"so_20464648_20476142_0\">A template parameter pack that is a pack expansion shall not expand a\n  parameter pack declared in the same template-parameter-list. [\n  Example:</p>\n<pre><code>// ...\n\ntemplate&lt;class... T, T... Values&gt; struct static_array;// error: Values expands template type parameter\n                                                      // pack T within the same template parameter list\n</code></pre>\n<p id=\"so_20464648_20476142_1\">\u2014end example ]</p>\n</blockquote>\n", "LastActivityDate": "2013-12-09T16:55:52.603", "CommentCount": "0", "CreationDate": "2013-12-09T16:55:52.603", "ParentId": "20464648", "Score": "1", "OwnerUserId": "3043539"}, "20478280": {"Id": "20478280", "PostTypeId": "2", "Body": "<p>One of the comments suggested a nested template check, so here is an implementation for that.  Just for fun, I used an empty struct called <code>MyTag</code> which only <code>class Value&lt;&gt;</code> should inherit from as a marker for being a legal parameter.  I couldn't think of a more concise way to do it.</p>\n<pre><code>using namespace std;\n\nstruct MyTag {};\n\ntemplate &lt;typename arg_t, arg_t* storage&gt;\nclass Value : MyTag {};\n\n//Iterate throught the list, checking each parameter\ntemplate&lt;typename F, typename... T&gt;\nstruct CheckValuePack{\n  static const bool value = is_base_of&lt;MyTag,F&gt;::value &amp;&amp;\n                            CheckValuePack&lt;T...&gt;::value;\n  typedef enable_if&lt;is_base_of&lt;MyTag,F&gt;::value &amp;&amp;\n                     CheckValuePack&lt;T...&gt;::value\n                     &gt; Checked;\n};\n\n//Check the last parameter\ntemplate&lt;typename F&gt;\nstruct CheckValuePack&lt;F&gt;{\n  static const bool value = is_base_of&lt;MyTag,F&gt;::value;\n};\n\ntemplate &lt;typename... T&gt;\nclass ValueList {\n  CheckValuePack&lt;T...&gt; checked; //perform the check\n};\n\nint a;\nfloat b;\n\nint main(int argc, char** argv) {\n      ValueList&lt;Value&lt;int, &amp;a&gt;, Value&lt;float, &amp;b&gt; &gt; list;\n      //ValueList&lt;Value&lt;int, &amp;a&gt;, Value&lt;float, &amp;b&gt;, int &gt; list; //compile time error\n      return 0;\n}\n</code></pre>\n<p>Note that <code>CheckValuePack&lt;T...&gt;</code> in <code>ValueList&lt;&gt;</code> could also be inherited.</p>\n", "LastActivityDate": "2013-12-09T18:48:52.643", "CommentCount": "0", "CreationDate": "2013-12-09T18:48:52.643", "ParentId": "20464648", "Score": "1", "OwnerUserId": "1464336"}});