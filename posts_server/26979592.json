post_cb({"26979592": {"CommentCount": "0", "ViewCount": "55", "CreationDate": "2014-11-17T18:41:40.020", "LastActivityDate": "2014-11-18T09:34:24.393", "Title": "Why an insertion in streams makes its width reset to 0?", "AcceptedAnswerId": "26979891", "PostTypeId": "1", "Id": "26979592", "Score": "3", "Body": "<p>It seems an insertion causes a stream to reset its width to 0. In other words, you need to repeatedly call the width() whenever you want to align your output, which makes me wonder why. I've looked over the c++11 standard and I found a partial answer, which suggests that width(0) is called inside <strong>character inserters</strong> according to the ISO C++ standard \u00a727.7.3.6.4.1. However, they are just a subset of the inserters, which is not a complete answer. Then, what about <strong>arithmetic inserters</strong>? I couldn't find any other references that can explain the behavior of streams.</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "3647351", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26979592_26979891_0": {"section_id": 6549, "quality": 0.9565217391304348, "length": 22}}, "n3337": {"so_26979592_26979891_0": {"section_id": 6304, "quality": 0.9565217391304348, "length": 22}}, "n4659": {"so_26979592_26979891_0": {"section_id": 8031, "quality": 0.9565217391304348, "length": 22}}}, "26979891": {"ParentId": "26979592", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Because that's the way the streams were specified.  In an <code>&lt;&lt;</code> operator,\n<code>width</code> should be reset, the other formatting options no.  I can only\nguess as to why: presumably, for things like:</p>\n<pre><code>std::cout &lt;&lt; std::setw(8) &lt;&lt; someValue &lt;&lt; \" cm\";\n</code></pre>\n<p>You wouldn't want the width to apply to the string <code>\" cm\"</code>, for example.\nBut you would want to be able to write:</p>\n<pre><code>std::cout &lt;&lt; std::setw(8) &lt;&lt; price &lt;&lt; \" | \" &lt;&lt; setw(20) &lt;&lt; article;\n</code></pre>\n<p>where <code>article</code> is a string.</p>\n<p>Except that, of course, for that to work, you'd have to also change the\njustification before the string, and the change in justification would\nbe sticky, affecting the next numeric output.</p>\n<p>In practice, of course, experienced programmers don't write this sort of\ncode.  They'd use something like:</p>\n<pre><code>std::cout &lt;&lt; price(column1Width) &lt;&lt; article.price\n    &lt;&lt; \" | \" &lt;&lt; label(column2Width) &lt;&lt; article.name;\n</code></pre>\n<p>(supposing that they still had to generate tables using a fixed width\nfont).  Where <code>price</code> and <code>label</code> were manipulators which set any number\nof format flags, and restored them in their destructor.  (Since they are\ntemporaries, their destructor will be called at the end of the full\nexpression.)  This way, this particular line of code doesn't say\nanything about the physical formatting, but rather that the first value\nshould be formatted as a price, and the second as a label.  (And of\ncourse, if someone higher up later decides that prices or labels should\nbe formatted differently, you just change the manipulators, rather than\nsearching all of the output statements, and trying to figure out which\nare prices, and which aren't.)</p>\n<p>EDIT (added references to the standard):</p>\n<p>It's important to note that the standard cannot cover everything here,\nsince most of the time, you'll be using custom <code>operator&lt;&lt;</code>, written by\nthe author of the class you're outputting.  Most of the built-in\n<code>operator&lt;&lt;</code> are covered by \u00a722.4.2.2.2, in its description of stage 3:</p>\n<blockquote>\n<p id=\"so_26979592_26979891_0\">If <code>str.width()</code> is nonzero and the number of charT\u2019s in the sequence\n  after stage 2 is less than <code>str.width()</code>, then enough fill characters are\n  added to the sequence at the position indicated for padding to bring the\n  length of the sequence to <code>str.width()</code>.</p>\n<p id=\"so_26979592_26979891_1\"><code>str.width(0)</code> is called.</p>\n</blockquote>\n<p>For characters and C style strings, this is specified (in much the same\nway) in \u00a727.7.3.6.4.  For <code>std::string</code>, see \u00a721.4.8.8.</p>\n<p>For <code>std::complex</code>: the standard defines insertion in terms of other\ninsertion operators.  Any setting of <code>width</code> will thus affect only the\nreal element.  (Practically speaking, I think we can consider this\nbroken.  When I implemented a pre-standard complex class, my <code>&lt;&lt;</code>\nchecked the width, and if it was non-zero, subtracted 3 for the\nnon-numeric fields, then divided by 2 and set it before outputting each\ndouble.  I\"m not sure that this is right, but it's certainly better than\nwhat the standard specifies.  And I also used a semi-colon as separator\nif the decimal was a comma, as it is in most places I've lived.)</p>\n<p>The fact that the other formatting options remain unchanged is because\nthe standard doesn't specify anything, and additional side effects,\nother than those specified, are assumed to be forbidden.</p>\n<p>In all cases, the specification says that <code>stream.width(0)</code> is called.\nBut in the standard, each case is specified separately.  There is no\nspecification (even for intent) of any general rule that I can find.\nTraditionally, however, the rule has always been: reset width, and leave\nthe others unchanged.  The principle of least surprise says that you\nshould do this for user defined <code>&lt;&lt;</code> (and <code>&gt;&gt;</code>) as well.</p>\n", "OwnerUserId": "649665", "LastEditorUserId": "649665", "LastEditDate": "2014-11-18T09:34:24.393", "Id": "26979891", "Score": "2", "CreationDate": "2014-11-17T19:00:28.007", "LastActivityDate": "2014-11-18T09:34:24.393"}});