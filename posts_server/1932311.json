post_cb({"24672871": {"ParentId": "1932311", "CommentCount": "0", "Body": "<p>One should use the <em>inline</em> function qualifier only when the function code is small.If the functions are larger you should prefer the normal functions since the saving in memory space is worth the comparatively small sacrifice in execution speed.</p>\n", "OwnerUserId": "3747978", "PostTypeId": "2", "Id": "24672871", "Score": "0", "CreationDate": "2014-07-10T09:24:59.100", "LastActivityDate": "2014-07-10T09:24:59.100"}, "1932340": {"ParentId": "1932311", "CommentCount": "0", "Body": "<p>The best way to find out is to profile your program and mark small functions that get called lots of times and burn through CPU cycles that as <code>inline</code>. The keyword here is \"small\" - once the function call overhead is negligible compared to the time spent in the function, it's pointless to inline them.</p>\n<p>The other use I'd suggest is if you've got small functions that get called in performance critical code often enough to make a cache miss relevant, you should probably inline those as well. Again, it's something the profiler should be able to tell you.</p>\n", "OwnerUserId": "29068", "PostTypeId": "2", "Id": "1932340", "Score": "4", "CreationDate": "2009-12-19T08:09:54.357", "LastActivityDate": "2009-12-19T08:09:54.357"}, "1933989": {"ParentId": "1932311", "CommentCount": "2", "Body": "<p>Also, an inline method has severe side effects when maintaining large projects.  When the inline code is changed, all files that use it will be rebuild automatically by the compiler (it it is a good compiler).  This could waste a lot of your development time.  </p>\n<p>When an <code>inline</code> method is transferred to a source file and not inlined any more, the whole project must be rebuilt (at least this has been my experience). And also when methods are converted to inline.  </p>\n", "OwnerUserId": "225074", "PostTypeId": "2", "Id": "1933989", "Score": "0", "CreationDate": "2009-12-19T20:05:30.130", "LastActivityDate": "2009-12-19T20:05:30.130"}, "1932467": {"ParentId": "1932311", "CommentCount": "0", "Body": "<p>I often use inline functions not as an optimization but to make the code more readable. Sometimes the code itself is shorter and easier to understand than comments, descriptive names etc. For example:</p>\n<pre><code>void IncreaseCount() { freeInstancesCnt++; }\n</code></pre>\n<p>The reader immediately knows the complete semantics of the code. </p>\n", "OwnerUserId": "19884", "PostTypeId": "2", "Id": "1932467", "Score": "1", "CreationDate": "2009-12-19T09:33:31.857", "LastActivityDate": "2009-12-19T09:33:31.857"}, "1932333": {"ParentId": "1932311", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Inline functions <strong>might</strong> improve your code performance by eliminating the need to push arguments into the stack. \nif the function in question is in a critical part of your code you should make the inline not inline decision in the optimization part of your project, </p>\n<p>you can read more about inlines in the <a href=\"http://www.parashift.com/c++-faq-lite/inline-functions.html\" rel=\"nofollow noreferrer\">c++ faq</a> </p>\n", "OwnerUserId": "207223", "LastEditorUserId": "223391", "LastEditDate": "2010-05-27T17:36:15.293", "Id": "1932333", "Score": "3", "CreationDate": "2009-12-19T08:07:40.557", "LastActivityDate": "2010-05-27T17:36:15.293"}, "1932311": {"CommentCount": "4", "AcceptedAnswerId": "1932371", "PostTypeId": "1", "LastEditorUserId": "759866", "CreationDate": "2009-12-19T08:00:25.660", "LastActivityDate": "2014-07-10T09:24:59.100", "LastEditDate": "2013-12-30T19:01:11.870", "ViewCount": "61483", "FavoriteCount": "92", "Title": "When to use inline function and when not to use it?", "Id": "1932311", "Score": "128", "Body": "<p>I know that inline is a hint or request to compiler and its used to avoid function call overheads.</p>\n<p>So on what basis one can determine whether a function is a candidate for inlining or not ?\nIn which case one should avoid inlining ?</p>\n", "Tags": "<c++><c><inline>", "OwnerUserId": "303986", "AnswerCount": "13"}, "1932338": {"ParentId": "1932311", "CommentCount": "8", "Body": "<p>Telling the compiler to inline a function is an optimization, and the most important rule of optimization is that premature optimization is the root of all evil.  Always write clear code (using efficient algorithms), then profile your program and only optimize functions that are taking too long.</p>\n<p>If you find a particular function is very short and simple, and it's getting called tens of thousands of times in a tight inner loop, it might be a good candidate.</p>\n<p>You might be surprised, though - many C++ compilers will automatically inline small functions for you - and they might ignore your request to inline, too.</p>\n", "OwnerUserId": "7193", "PostTypeId": "2", "Id": "1932338", "Score": "8", "CreationDate": "2009-12-19T08:09:08.167", "LastActivityDate": "2009-12-19T08:09:08.167"}, "1932378": {"ParentId": "1932311", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>When deciding on whether to use inline, I usually keep the following idea in mind: On modern machines memory latency can be a bigger bottleneck than raw calculations. Inlining functions that are called often is known to grow the executable size. Furthermore, such a function could be stored in the CPU's code cache which will decrease the number of cache misses when that code needs to be accessed. </p>\n<p>Hence, you have to decide for yourself: Does inlining increase or decrease the size of the generated machine code? How likely is it that calling the function will cause a cache miss? If it is peppered throughout the code, then I would say the likelihood is high. If it is restricted to a single tight loop then the likelihood is hopefully low.</p>\n<p>I typically use inlining in the cases I list bellow. However, where you are genuinely concerned about performance, profiling is essential. Furthermore, you might want to check whether the compiler actually takes the hint.</p>\n<ul>\n<li>Short routines that are called in a tight loop.</li>\n<li>Very basic accessors  (get / set)  and wrapper functions.</li>\n<li>Template code in header files unfortunately automatically obtain the inline hint.</li>\n<li>Short code that is used like a macro. (E.g. min() / max())</li>\n<li>Short math routines.</li>\n</ul>\n", "OwnerUserId": "167485", "LastEditorUserId": "167485", "LastEditDate": "2009-12-19T08:50:54.197", "Id": "1932378", "Score": "0", "CreationDate": "2009-12-19T08:45:13.523", "LastActivityDate": "2009-12-19T08:50:54.197"}, "1932580": {"ParentId": "1932311", "CommentCount": "4", "Body": "<p><code>inline</code> has very little to do with optimization. <code>inline</code> is an instruction to the compiler not to produce an error if the function given definition occurs multiple times in the program and a promise that the definition will occur in every translation that it is used and everywhere it does appear it will have exactly the same definition.</p>\n<p>Given the above rules, <code>inline</code> is suitable for short functions whose body doesn't necessitate including extra dependencies over what just a declaration would need. Every time the defintion is encountered it must be parsed and code for its body may be generated so it implies some compiler overhead over a function defined only once in a single source file.</p>\n<p>A compiler may <em>inline</em> (i.e. replace a call to the function with code that performs that action of that function) any function call that it chooses. It used to be the case that it \"obviously\" couldn't inline a function that wasn't declared in the same translation unit as the call but with the increasing use of link time optimization even this isn't true now. Equally true is the fact that functions marked <code>inline</code> may not be inlined.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "1932580", "Score": "50", "CreationDate": "2009-12-19T10:40:27.353", "LastActivityDate": "2009-12-19T10:40:27.353"}, "1932330": {"ParentId": "1932311", "CommentCount": "0", "Body": "<p>I generally follow a thumb rule where I make a function with 3-4 simple statements as inline. But it is good to remember that it is just a hint to the compiler. The final call to make it inline or not is taken by the compiler only. If there are more than these many statements I will not declare inline as with a stupid compiler it may lead to code bloat. </p>\n", "OwnerUserId": "39742", "PostTypeId": "2", "Id": "1932330", "Score": "0", "CreationDate": "2009-12-19T08:07:26.333", "LastActivityDate": "2009-12-19T08:07:26.333"}, "1932371": {"CommentCount": "12", "CreationDate": "2009-12-19T08:38:49.077", "CommunityOwnedDate": "2009-12-20T14:51:06.243", "LastEditorUserId": "216063", "LastActivityDate": "2009-12-20T18:26:01.140", "ParentId": "1932311", "PostTypeId": "2", "LastEditDate": "2009-12-20T18:26:01.140", "Id": "1932371", "Score": "155", "Body": "<p>Avoiding the cost of a function call is only half the story.</p>\n<p>do:</p>\n<ul>\n<li>use <code>inline</code> instead of <code>#define</code></li>\n<li><strong>very small</strong> functions are good candidates for <code>inline</code>: faster code and smaller executables (more chances to stay in the code cache)</li>\n<li>the function is small <strong>and</strong> called very often</li>\n</ul>\n<p>don't:</p>\n<ul>\n<li>large functions: leads to larger executables, which significantly impairs performance regardless of the faster execution that results from the calling overhead</li>\n<li>inline functions that are I/O bound</li>\n<li>the function is seldom used</li>\n<li>constructors and destructors: even when empty, the compiler generates code for them</li>\n<li>breaking binary compatibility when developing libraries:\n\n<ul>\n<li>inline an existing function</li>\n<li>change an inline function or make an inline function non-inline: prior version of the library call the old implementation</li>\n</ul></li>\n</ul>\n<p>when developing a library, in order to make a class extensible in the future you should:</p>\n<ul>\n<li>add non-inline virtual destructor even if the body is empty</li>\n<li>make all constructors non-inline</li>\n<li>write non-inline implementations of the copy constructor and assignment operator unless the class cannot be copied by value</li>\n</ul>\n<p>Remember that the <code>inline</code> keyword is a hint to the compiler: the compiler may decide not to inline a function and it can decide to inline functions that were not marked <code>inline</code> in the first place. I generally avoid marking function <code>inline</code> (apart maybe when writing very very small functions). </p>\n<p>About performance, the wise approach is (as always) to profile the application, then eventually <code>inline</code> a set of functions representing a bottleneck.</p>\n<p>References:</p>\n<ul>\n<li><a href=\"http://www.ddj.com/architect/184405660\" rel=\"noreferrer\">To Inline or Not To Inline</a></li>\n<li><a href=\"http://www.parashift.com/c++-faq-lite/inline-functions.html\" rel=\"noreferrer\">[9] Inline functions</a></li>\n<li><a href=\"http://techbase.kde.org/Policies/Binary_Compatibility_Issues_With_C++\" rel=\"noreferrer\">Policies/Binary Compatibility Issues With C++</a></li>\n<li><a href=\"http://www.gotw.ca/gotw/033.htm\" rel=\"noreferrer\">GotW #33: Inline</a></li>\n<li><a href=\"http://www.ddj.com/cpp/184403879\" rel=\"noreferrer\">Inline Redux</a></li>\n<li>Effective C++ - Item 33:  Use inlining judiciously</li>\n</ul>\n<hr>\n<p>EDIT: Bjarne Stroustrup, The C++ Programming Language:</p>\n<blockquote>\n<p id=\"so_1932311_1932371_0\">A function can be defined to be <code>inline</code>. For example: </p>\n</blockquote>\n<pre><code>inline int fac(int n)\n{\n  return (n &lt; 2) ? 1 : n * fac(n-1);\n}\n</code></pre>\n<blockquote>\n<p id=\"so_1932311_1932371_1\">The <code>inline</code> specifier is a hint to the compiler that it should attempt to generate code for a call of <code>fac()</code> inline rather than laying down the code for the function once and then calling through the usual function call mechanism. A clever compiler can generate the constant <code>720</code> for a call <code>fac(6)</code>. The possibility of mutually recursive inline functions, inline functions that recurse or not depending on input, etc., makes it impossible to guarantee that every call of an <code>inline</code> function is actually inlined. The degree of cleverness of a compiler cannot be legislated, so one compiler might generate <code>720</code>, another <code>6 * fac(5)</code>, and yet another an un-inlined call <code>fac(6)</code>. </p>\n<p id=\"so_1932311_1932371_2\">To make inlining possible in the absence of unusually clever compilation and linking facilities, the definition\u2013and not just the declaration\u2013of an inline function must be in scope (\u00a79.2). An <code>inline</code> especifier does not affect the semantics of a function. In particular, an inline function still has a unique address and so has <code>static</code> variables (\u00a77.1.2) of an inline function.</p>\n</blockquote>\n<p>EDIT2: ISO-IEC 14882-1998, 7.1.2 Function specifiers</p>\n<blockquote>\n<p id=\"so_1932311_1932371_3\">A function declaration (8.3.5, 9.3, 11.4) with an <code>inline</code> specifier declares an inline function. The inline specifier indicates to the implementation that inline substitution of the function body at the point of call is to be preferred to the usual function call mechanism. An implementation is not required to perform this inline substitution at the point of call; however, even if this inline substitution is omitted, the other rules for inline functions defined by 7.1.2 shall still be respected.</p>\n</blockquote>\n</hr>", "OwnerUserId": "216063"}, "18793111": {"ParentId": "1932311", "CommentCount": "3", "Body": "<p>I have read some answers and see that there some stuff missing.</p>\n<p>The rule I use is not to use inline, unless I want it to be inline. Looks silly, now explanation.</p>\n<p>Compilers are smart enough and short functions always makes inline. And never makes long function as inline, unless programmer said to do that.</p>\n<blockquote>\n<p id=\"so_1932311_18793111_0\">I know that inline is a hint or request to compiler</p>\n</blockquote>\n<p>Actually <code>inline</code> is an order for compiler, it has no choices and after <code>inline</code> keyword makes all code inline. So you can never use <code>inline</code> keyword and compiler will design shortest code.</p>\n<p>So when to use <code>inline</code>?</p>\n<p>To use if you want to have some code inline. I know only one example, because I use it in only one situation. It is user authentication. </p>\n<p>For example I have this function:</p>\n<pre><code>inline bool ValidUser(const std::string&amp; username, const std::string&amp; password)\n{\n    //here it is quite long function\n}\n</code></pre>\n<p>No matter how big this function is I want to have it as inline because it makes my software harder to crack.</p>\n", "OwnerUserId": "1237747", "PostTypeId": "2", "Id": "18793111", "Score": "-1", "CreationDate": "2013-09-13T18:42:05.827", "LastActivityDate": "2013-09-13T18:42:05.827"}, "bq_ids": {"n4140": {"so_1932311_1932371_0": {"section_id": 5812, "quality": 0.6666666666666666, "length": 4}, "so_1932311_1932371_3": {"section_id": 5402, "quality": 0.8888888888888888, "length": 40}}, "n3337": {"so_1932311_1932371_0": {"section_id": 5585, "quality": 0.6666666666666666, "length": 4}, "so_1932311_1932371_3": {"section_id": 5197, "quality": 0.8888888888888888, "length": 40}}, "n4659": {"so_1932311_1932371_0": {"section_id": 7275, "quality": 0.6666666666666666, "length": 4}, "so_1932311_1932371_3": {"section_id": 6849, "quality": 0.8666666666666667, "length": 39}}}, "1932348": {"ParentId": "1932311", "CommentCount": "0", "Body": "<p>The best way would be to examine and compare the generated instructions for inlined and not inlined.  However, it is always safe to omit <code>inline</code>.  Using <code>inline</code> could lead to trouble you don't want.</p>\n", "OwnerUserId": "198536", "PostTypeId": "2", "Id": "1932348", "Score": "0", "CreationDate": "2009-12-19T08:15:26.003", "LastActivityDate": "2009-12-19T08:15:26.003"}, "1932373": {"ParentId": "1932311", "CommentCount": "0", "Body": "<p>Premature optimization is the root of all evil!</p>\n<p>As a rule of thumb I usually inline only \"getters\" and \"setters\". Once the code is working and is stable, profiling can show which functions could benefit from inlining. </p>\n<p>On the other hand, most modern compilers have quite good optimization algorithms, and will inline what you should have inlined for you. </p>\n<p>Reasuming -- write inline one-liner functions, and worry about others later.</p>\n", "OwnerUserId": "233522", "PostTypeId": "2", "Id": "1932373", "Score": "5", "CreationDate": "2009-12-19T08:39:59.747", "LastActivityDate": "2009-12-19T08:39:59.747"}});