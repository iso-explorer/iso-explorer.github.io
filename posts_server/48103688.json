post_cb({"bq_ids": {"n4140": {"so_48103688_48104597_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 4692}, "so_48103688_48104597_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 4694}, "so_48103688_48104597_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 4693}}, "n3337": {"so_48103688_48104597_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 4501}, "so_48103688_48104597_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 4503}, "so_48103688_48104597_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 4502}}, "n4659": {"so_48103688_48104597_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6087}, "so_48103688_48104597_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 6089}, "so_48103688_48104597_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 6088}}}, "48104597": {"Id": "48104597", "PostTypeId": "2", "Body": "<p>Both your approaches are valid, interchangeable and lead to the same result (deduce the type of the parameter lambda accepts).</p>\n<p>For type traits it is required by the standard (see <em>23.15.1 Requirements</em>) that:</p>\n<blockquote>\n<ol>\n<li><p id=\"so_48103688_48104597_0\">A UnaryTypeTrait describes a property of a type. <strong>It shall be a class template</strong> that takes one template type argument and, optionally, additional arguments that help define the property being described. ...</p></li>\n<li><p id=\"so_48103688_48104597_1\">A BinaryTypeTrait describes a relationship between two types. <strong>It shall be a class template</strong> that takes two template type arguments\n  and, optionally, additional arguments that help define the\n  relationship being described. ...</p></li>\n<li><p id=\"so_48103688_48104597_2\">A TransformationTrait modifies a property of a type. <strong>It shall be a class template</strong> that takes one template type argument and, optionally, additional arguments that help define the modification. ...</p></li>\n</ol>\n</blockquote>\n<p>I suppose that this requirement appeared mostly for historical reasons as <code>decltype</code> functionality was introduced after type traits had been proposed (and these type traits were based on type traits from <em>boost</em> which had been created even earlier, see, for example, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1424.htm\" rel=\"nofollow noreferrer\">this</a>).</p>\n<p>Also, note, that class templates are more flexible for general purpose type traits than the logic based on functions declarations and <code>decltype</code>.</p>\n<p>The main point is that with <em>C++11</em> and later in your particular case you are free to use the way which is the most convenient and reflects the programming logic better.</p>\n", "LastActivityDate": "2018-01-04T22:38:33.547", "Score": "1", "CreationDate": "2018-01-04T22:38:33.547", "ParentId": "48103688", "CommentCount": "0", "OwnerUserId": "5507349"}, "48103688": {"ViewCount": "90", "Body": "<p>I am want a static check of the parameter type of lambdas. I've written this code below and it seems to produce the correct result.</p>\n<pre><code>struct B { };\nauto lamBc = [](B const&amp; b) { std::cout &lt;&lt; \"lambda B const\" &lt;&lt; std::endl; };\n\ntemplate&lt;typename ClosureType, typename R, typename Arg&gt;\nconstexpr auto ArgType(R (ClosureType::*)(Arg) const)-&gt;Arg;\n\ntemplate &lt;typename T&gt;\nusing ArgType_t = decltype(ArgType(&amp;T::operator()));\n\n// ArgType_t&lt;lamBc&gt; is \"reference to B const\"\n</code></pre>\n<p>However, I noticed that, for example, the standard library uses class template specialization to extract the referred-to type from a reference type in <code>std::remove_reference</code>. So I tried that approach and it also seems to produce the correct result.</p>\n<pre><code>template&lt;typename L&gt;\nstruct ArgType2;\n\ntemplate&lt;typename ClosureType, typename R, typename Arg&gt;\nstruct ArgType2&lt;R (ClosureType::*)(Arg) const&gt;\n{\n    typedef Arg type;\n};\n\ntemplate &lt;typename T&gt;\nusing ArgType2_t = typename ArgType2&lt;decltype(&amp;T::operator())&gt;::type;\n\n// ArgType2_t&lt;lamBc&gt; is also \"reference to B const\"\n</code></pre>\n<p>My questions are: Which is the standard way to extract types from a pattern expression? What are the trade-offs in either approach?</p>\n", "AcceptedAnswerId": "48104597", "Title": "C++ template metaprogramming: how to deduce type in expression pattern", "CreationDate": "2018-01-04T21:16:12.163", "Id": "48103688", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2018-01-04T22:42:02.453", "Score": "4", "OwnerUserId": "540815", "Tags": "<c++><c++14><template-meta-programming><type-deduction>", "AnswerCount": "2"}, "48103856": {"Id": "48103856", "PostTypeId": "2", "Body": "<p>They are both \"standard\", the <code>decltype()</code> way is simply available in modern C++ variants, the PTS method was the only way to do this sort of things under the original C++ standard.</p>\n", "LastEditorUserId": "4131059", "LastActivityDate": "2018-01-04T22:42:02.453", "Score": "0", "CreationDate": "2018-01-04T21:29:53.053", "ParentId": "48103688", "CommentCount": "0", "OwnerUserId": "7594711", "LastEditDate": "2018-01-04T22:42:02.453"}});