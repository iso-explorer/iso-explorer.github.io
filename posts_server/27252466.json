post_cb({"27252466": {"CommentCount": "2", "ViewCount": "127", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-12-02T15:02:14.470", "LastActivityDate": "2015-01-09T16:42:21.170", "Title": "Inline namespaces and ambigous declarations", "AcceptedAnswerId": "27252746", "LastEditDate": "2014-12-02T15:36:01.233", "Id": "27252466", "Score": "3", "Body": "<p>I'm wondering if this is allowed:</p>\n<pre><code>namespace A {\n  inline namespace B {\n    int a;\n  }\n  int a;\n}\n\nvoid foo() {\n  A::a = 0; // clang 3.4 compiles, but gcc doesn't\n}\n</code></pre>\n<p>Standard says, that</p>\n<blockquote>\n<p id=\"so_27252466_27252466_0\">Finally, looking up a name in the enclosing namespace via explicit\n  qualification (3.4.3.2) will include members of the inline namespace\n  brought in by the using-directive even if there are declarations of\n  that name in the enclosing namespace.</p>\n</blockquote>\n<p>But I can't get it.</p>\n", "Tags": "<c++><c++11><namespaces><language-lawyer>", "OwnerUserId": "3120079", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27252466_27252466_0": {"section_id": 5480, "quality": 0.9545454545454546, "length": 21}, "so_27252466_27252746_1": {"section_id": 7118, "quality": 0.7777777777777778, "length": 21}, "so_27252466_27252746_0": {"section_id": 7117, "quality": 0.6944444444444444, "length": 25}}, "n3337": {"so_27252466_27252466_0": {"section_id": 5266, "quality": 0.9545454545454546, "length": 21}, "so_27252466_27252746_1": {"section_id": 6862, "quality": 0.7777777777777778, "length": 21}, "so_27252466_27252746_0": {"section_id": 6861, "quality": 0.6944444444444444, "length": 25}}, "n4659": {"so_27252466_27252466_0": {"section_id": 6914, "quality": 0.9545454545454546, "length": 21}, "so_27252466_27252746_1": {"section_id": 8619, "quality": 0.7777777777777778, "length": 21}, "so_27252466_27252746_0": {"section_id": 8618, "quality": 0.6944444444444444, "length": 25}}}, "27252746": {"ParentId": "27252466", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It looks like this was a <a href=\"http://clang.llvm.org/cxx_dr_status.html#812\" rel=\"nofollow\">pre clang 3.5 bug</a> and there are two defect reports on this <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#812\" rel=\"nofollow\">812</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#861\" rel=\"nofollow\">861</a>. The resolution is in 861 and adds the following to <code>3.4.3.2</code> <em>[namespace.qual]</em> (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_27252466_27252746_0\">For a namespace X and name m, the namespace-qualified lookup set S(X,m) is defined as follows: Let S'(X,m) be the set of all declarations of m in X and the inline namespace set of X (7.3.1 [namespace.def]). If S'(X,m) is not empty, S(X,m) is S'(X,m); otherwise, S(X,m) is the union of S(Ni,m) for all non-inline namespaces Ni nominated by using-directives in X and its inline namespace set.</p>\n</blockquote>\n<p>and the also relevant additions:</p>\n<blockquote>\n<p id=\"so_27252466_27252746_1\">if S(X,m) is the empty set, the program is ill-formed. Otherwise, if S(X,m) has exactly one member, or if the context of the reference is a using-declaration (7.3.3 [namespace.udecl]), S(X,m) is the required set of declarations of m. <strong>Otherwise if the use of m is not one that allows a unique declaration to be chosen from S(X,m), the program is ill-formed.</strong></p>\n</blockquote>\n<p>It looks like the change was added pre C++11, this text is present in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">N3337</a>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-01-09T16:42:21.170", "Id": "27252746", "Score": "5", "CreationDate": "2014-12-02T15:16:03.653", "LastActivityDate": "2015-01-09T16:42:21.170"}});