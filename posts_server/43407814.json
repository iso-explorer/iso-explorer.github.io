post_cb({"47039308": {"Id": "47039308", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_43407814_47039308_0\">Is this an oversight in the Standard?</p>\n</blockquote>\n<p>It is considered an open defect in the standard, tracked as <a href=\"http://wg21.link/LWG2089\" rel=\"nofollow noreferrer\">LWG #2089</a>. But a good solution to it is elusive.</p>\n<p>The fundamental problem comes from the fact that you cannot just use braced-init-lists willy-nilly. List initialization of types with constructors can actually <em>hide</em> constructors, such that certain constructors can be impossible to call through list initialization. This is the <code>vector&lt;int&gt; v{1, 2};</code> problem. That creates a 2-element <code>vector</code>, not a 1-element vector whose only element is 2.</p>\n<p>Because of this, you cannot use list initialization in generic contexts like <code>allocator::construct</code>.</p>\n<p>Which brings us to:</p>\n<blockquote>\n<p id=\"so_43407814_47039308_1\">I would think there's be a SFINAE trick to do that if possible, else resort to brace init that also works for aggregates.</p>\n</blockquote>\n<p>That would require an <code>is_aggregate</code> type trait. Which doesn't exist at present, and nobody has proposed its existence. Oh sure, you could make do with <code>is_constructible</code>, as the proposed resolution to the issue states. But there's a problem with that: it effectively creates an alternative to list-initilaization.</p>\n<p>Consider that <code>vector&lt;int&gt;</code> example from before. <code>{1, 2}</code> is interpreted as a two-element <code>initializer_list</code>. But through <code>emplace</code>, it would be interpreted as calling the two-integer constructor, since <code>is_constructible</code> from those two elements would be true. And that causes this problem:</p>\n<pre><code>vector&lt;vector&lt;float&gt;&gt; fvec;\nfvec.emplace(1.0f, 2.0f);\nvector&lt;vector&lt;int&gt;&gt; ivec;\nivec.emplace(1, 2);\n</code></pre>\n<p>These do two <em>completely different things.</em> In the <code>fvec</code> case, it performs list initialization, because <code>vector&lt;float&gt;</code> is not constructible from two floats. In the <code>ivec</code> case, it calls a constructor, because <code>vector&lt;int&gt;</code> is constructible from two integers.</p>\n<p>So you <em>need</em> to limit list initialization in <code>allocator::construct</code> to only work if <code>T</code> is an aggregate.</p>\n<p>And even if you did that, you would then have to propagate this SFINAE trick into <em>all</em> of the places where indirect initialization is used. This includes <code>any/variant/optional</code>'s <code>in_place</code> constructors and emplacements, <code>make_shared/unique</code> calls, and so forth, none of which use <code>allocator::construct</code>.</p>\n<p>And that doesn't count user code where such indirect initialization is needed. If users don't do the same initialization that the C++ standard library does, people will be upset.</p>\n<p>This is a sticky problem to solve in a way that doesn't bifurcate indirect initialization APIs into groups that allow aggregates and groups that don't. There are <a href=\"https://github.com/NicolBolas/Proposal-Ideas/blob/master/Towards%20a%20Fix%20For%20LWG%202089.md\" rel=\"nofollow noreferrer\">many possible solutions</a>, and none of them are ideal.</p>\n", "LastActivityDate": "2017-10-31T15:42:01.603", "CommentCount": "0", "CreationDate": "2017-10-31T15:42:01.603", "ParentId": "43407814", "Score": "2", "OwnerUserId": "734069"}, "bq_ids": {"n4140": {"so_43407814_43408612_0": {"length": 11, "quality": 1.0, "section_id": 715}, "so_43407814_43408612_2": {"length": 22, "quality": 0.8461538461538461, "section_id": 715}}, "n3337": {"so_43407814_43408612_0": {"length": 11, "quality": 1.0, "section_id": 704}, "so_43407814_43408612_2": {"length": 22, "quality": 0.8461538461538461, "section_id": 704}}, "n4659": {"so_43407814_43408612_0": {"length": 11, "quality": 1.0, "section_id": 745}, "so_43407814_43408612_2": {"length": 21, "quality": 0.8076923076923077, "section_id": 745}}}, "43407814": {"ViewCount": "203", "Body": "<p>It seems like <a href=\"http://coliru.stacked-crooked.com/a/eaaba108fb9a610e\" rel=\"nofollow noreferrer\">this code</a>:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n\nstruct bla\n{\n    std::string a;\n    int b;\n};\n\nint main()\n{\n    std::vector&lt;bla&gt; v;\n    v.emplace_back(\"string\", 42);\n}\n</code></pre>\n<p>could be made to work properly in this case, but it doesn't (and I understand why). Giving <code>bla</code> a constructor solves this, but removes the aggregateness of the type, which can have far-reaching consequences.</p>\n<p>Is this an oversight in the Standard? Or am I missing certain cases where this will blow up in my face, or is it just not as useful as I think?</p>\n", "Title": "Why can an aggreggate struct be brace-initialized, but not emplaced using the same list of arguments as in the brace initialization?", "CreationDate": "2017-04-14T08:18:17.673", "LastActivityDate": "2017-10-31T15:42:01.603", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-10-31T15:20:39.533", "LastEditorUserId": "734069", "Id": "43407814", "Score": "5", "OwnerUserId": "256138", "Tags": "<c++><c++11><aggregate><emplace>", "AnswerCount": "2"}, "43408612": {"Id": "43408612", "PostTypeId": "2", "Body": "<p>23.2.1/15.5</p>\n<blockquote>\n<p id=\"so_43407814_43408612_0\">T is EmplaceConstructible into X from args, for zero or more arguments\n  args, means that the following expression is well-formed:</p>\n<p id=\"so_43407814_43408612_1\"><code>allocator_traits&lt;A&gt;::construct(m, p, args)</code></p>\n</blockquote>\n<p>23.2.1/15</p>\n<blockquote>\n<p id=\"so_43407814_43408612_2\">[Note: A container calls <code>allocator_traits&lt;A&gt;::construct(m, p, args)</code> to construct an element at p using args. The default construct in <code>std::allocator</code> will call <code>::new((void*)p) T(args)</code>, but specialized allocators may choose a different definition. \u2014end note ]</p>\n</blockquote>\n<p>So, default allocator uses a constuctor, changing this behavior could cause backward compatibility loss. You could read more in this answer <a href=\"https://stackoverflow.com/a/8783004/4759200\">https://stackoverflow.com/a/8783004/4759200</a>. </p>\n<p>Also there is an issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4462.html\" rel=\"nofollow noreferrer\">\"Towards more perfect forwarding\"</a> and some random <a href=\"https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/k5aVvGzig8Y\" rel=\"nofollow noreferrer\">discussion</a> about it's future. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-14T09:12:14.673", "Score": "4", "CreationDate": "2017-04-14T09:12:14.673", "ParentId": "43407814", "CommentCount": "4", "OwnerUserId": "4759200", "LastEditDate": "2017-05-23T11:46:46.447"}});