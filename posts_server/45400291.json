post_cb({"45400331": {"ParentId": "45400291", "Score": "1", "CreationDate": "2017-07-30T13:30:53.033", "LastActivityDate": "2017-07-30T18:12:39.073", "LastEditDate": "2017-07-30T18:12:39.073", "OwnerUserId": "6654077", "LastEditorUserId": "6654077", "Body": "<p>When you do <code>userInput = \"Hello\";</code> you actually reassign your variable <code>userInput</code> to the string <code>\"Hello\"</code>.</p>\n<p>But the string <code>\"Hello\"</code> is not copied within your buffer <code>new char[7]</code>, variable <code>userInput</code> is <strong>reassigned</strong>.</p>\n<p>So your buffer stays untouched.</p>\n<p>Because <strong>string literals</strong> (strings written in your code with quotes <code>\"</code>) are stored in a read-only portion of the program, you cannot rewrite any character of them: this is why you have your error.</p>\n<p>And here, worst: you are trying to write out of bound of the string in the read-only memory. This is not the cause of the error (as stated by some others) because there are other padding data there, the cause being the region is write protected.</p>\n<p>Use a function such as <code>strcpy()</code> to perform a copy from a string to another buffer.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n\nusing namespace std;\n\nint main() {\n  char* userInput = new char[7];\n\n  strcpy(userInput, \"Hello\");\n  *(userInput + 6) = 'W';\n  cout &lt;&lt; userInput &lt;&lt; \"\\n\";\n}\n</code></pre>\n", "Id": "45400331", "PostTypeId": "2", "CommentCount": "2"}, "45400291": {"Tags": "<c++><string>", "ViewCount": "60", "LastEditDate": "2017-07-30T13:29:34.200", "CreationDate": "2017-07-30T13:26:08.540", "LastEditorUserId": "8202288", "Title": "C++ NULL character and memory allocation", "CommentCount": "4", "AcceptedAnswerId": "45400331", "Score": "1", "OwnerUserId": "8379323", "Id": "45400291", "LastActivityDate": "2017-07-30T18:12:39.073", "Body": "<p>I have a mini C++ programs as follows,</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nvoid main() {\n\n    char* userInput = new char[7];\n    userInput = \"Hello\";\n    *(userInput + 6) = 'W';\n    cout &lt;&lt; userInput &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>I just want to confirm that the 'W' will not be outputted cause of the NULL character after the \"Hello\" string. However, this programs shows run-time error as follows:</p>\n<blockquote>\n<p id=\"so_45400291_45400291_0\">Unhandled exception thrown: write access violation.\n  <strong>userInput</strong> was 0xBD9BD8. occurred</p>\n</blockquote>\n<p>Any advice or comments? Thanks a lot.</p>\n", "PostTypeId": "1", "AnswerCount": "3"}, "45400364": {"ParentId": "45400291", "Score": "0", "CreationDate": "2017-07-30T13:35:11.727", "Id": "45400364", "OwnerUserId": "6784509", "LastActivityDate": "2017-07-30T13:35:11.727", "Body": "<p>When you write that :</p>\n<pre><code>userInput = \"Hello\";\n</code></pre>\n<p>the pointer <code>userInput</code> will be assigned point to the \"Hello\" string, which is 6 bytes long, the 5 character + a null terminator. ( and making your <code>new char[7]</code> useless, by the way )</p>\n<p>And here :</p>\n<pre><code>*(userInput + 6) = 'W';\n</code></pre>\n<p>You write AFTER the null terminator, in memory which have not been allocated.\nWhat happen when you read/write in not allocated memory is undefined behavior, it can for example result in a seg fault, which you had</p>\n", "PostTypeId": "2", "CommentCount": "0"}, "45400400": {"ParentId": "45400291", "Score": "0", "CreationDate": "2017-07-30T13:38:26.223", "Id": "45400400", "OwnerUserId": "2877241", "LastActivityDate": "2017-07-30T13:38:26.223", "Body": "<p>There are several problems with the program. </p>\n<p>For starters there is a memory leak.</p>\n<pre><code>char* userInput = new char[7];\nuserInput = \"Hello\";\n</code></pre>\n<p>at first the pointer <code>userInput</code>  is initialized by the address of the allocated memory extent and then the pointer is reassigned with the address of the first character of the string literal <code>\"Hello\"</code>.</p>\n<p>Though the program tries to write in the memory beyond the string literal nevertheless it should be mentioned that according to the C++ Standard (2.13.5 String literals)</p>\n<blockquote>\n<p id=\"so_45400291_45400400_0\">16 Evaluating a string-literal results in a string literal object with\n  static storage duration, initialized from the given characters as\n  specified above. Whether all string literals are distinct (that is,\n  are stored in nonoverlapping objects) and whether successive\n  evaluations of a string-literal yield the same or a different object\n  is unspecified. [ Note: <strong>The effect of attempting to modify a string\n  literal is undefined</strong>. \u2014end note ]</p>\n</blockquote>\n<p>To demonstrate your concept there is no need to allocate the memory dynamically. You could just write</p>\n<pre><code>char userInput[7] = \"Hello\";\n*(userInput + 6) = 'W';\n</code></pre>\n<p>Or using dynamic memory allocation you could write</p>\n<pre><code>#include &lt;cstring&gt;\n\n//...\n\nchar* userInput = new char[7];\n\nstd::strcpy( userInput, \"Hello\" );\n*(userInput + 6) = 'W';\n//...\ndelete [] userInput;\n</code></pre>\n<p>Pay attention to that though some compilers (as far as I know the MS VC++ allows to do this) allows to declare the function main as having the return type void nevertheless according to the C++ Standard the function main shall have the return type int.</p>\n<pre><code>int main()\n</code></pre>\n", "PostTypeId": "2", "CommentCount": "2"}, "bq_ids": {"n4659": {"so_45400291_45400400_0": {"length": 37, "section_id": 6789, "quality": 0.9024390243902439}}}});