post_cb({"11734861": {"CommentCount": "13", "CreationDate": "2012-07-31T07:06:01.537", "PostTypeId": "1", "AcceptedAnswerId": "11735045", "LastEditorUserId": "396571", "LastActivityDate": "2017-04-14T05:07:37.270", "LastEditDate": "2012-07-31T08:31:54.883", "ViewCount": "5098", "FavoriteCount": "12", "Title": "When can outer braces be omitted in an initializer list?", "Id": "11734861", "Score": "42", "Body": "<p>I've got error C2078 in VC2010 when compiling the code below.</p>\n<pre><code>struct A\n  {\n  int foo;\n  double bar;\n  };\n\nstd::array&lt;A, 2&gt; a1 = \n  // error C2078: too many initializers\n  {\n    {0, 0.1},\n    {2, 3.4}\n  };\n\n// OK\nstd::array&lt;double, 2&gt; a2 = {0.1, 2.3};\n</code></pre>\n<p>I found out that the correct syntax for <code>a1</code> is</p>\n<pre><code>std::array&lt;A, 2&gt; a1 = \n  {{\n    {0, 0.1},\n    {2, 3.4}\n  }};\n</code></pre>\n<p>The question is: why extra braces are required for <code>a1</code> but not required for <code>a2</code>?</p>\n<p><strong>Update</strong></p>\n<p>The question seems to be not specific to std::array. Some examples:</p>\n<pre><code>struct B\n  {\n  int foo[2];\n  };\n\n// OK\nB meow1 = {1,2};\nB bark1 = {{1,2}};\n\nstruct C\n  {\n  struct \n    { \n    int a, b; \n    } foo;\n  };\n\n// OK\nC meow2 = {1,2};\nC bark2 = {{1,2}};\n\nstruct D\n  {\n  struct \n    { \n    int a, b; \n    } foo[2];\n  };\n\nD meow3 = {{1,2},{3,4}};  // error C2078: too many initializers\nD bark3 = {{{1,2},{3,4}}};\n</code></pre>\n<p>I still don't see why <code>struct D</code> gives the error but B and C don't.</p>\n", "Tags": "<c++><c++11><visual-c++-2010>", "OwnerUserId": "1345960", "AnswerCount": "1"}, "11735045": {"ParentId": "11734861", "LastEditDate": "2017-04-14T05:07:37.270", "CommentCount": "4", "CreationDate": "2012-07-31T07:18:35.877", "OwnerUserId": "415784", "LastEditorUserId": "523124", "PostTypeId": "2", "Id": "11735045", "Score": "55", "Body": "<p>The extra braces are needed because <code>std::array</code> is an aggregate and POD, unlike other containers in the standard library. <code>std::array</code> doesn't have a user-defined constructor. Its first data member is an array of size <code>N</code> (which you pass as a template argument), and this member is directly initialized with an initializer. The extra braces are needed for the <em>internal</em> array which is being directly initialized.</p>\n<p>The situation is same as:</p>\n<pre><code>//define this aggregate - no user-defined constructor\nstruct Aarray\n{\n   A data[2];  //data is an internal array\n};\n</code></pre>\n<p>How would you initialize this? If you do this:</p>\n<pre><code>Aarray a1 =\n{\n   {0, 0.1},\n   {2, 3.4}\n};\n</code></pre>\n<p>it gives a <a href=\"http://ideone.com/z0ky3\" rel=\"nofollow noreferrer\">compilation error</a>:</p>\n<blockquote>\n<p id=\"so_11734861_11735045_0\">error: too many initializers for 'Aarray'</p>\n</blockquote>\n<p>This is the <em>same</em> error which you get in the case of a <code>std::array</code> (if you use GCC).</p>\n<p>So the correct thing to do is to use <em>braces</em> as follows:</p>\n<pre><code>Aarray a1 =\n{\n  {  //&lt;--this tells the compiler that initialization of `data` starts\n\n        { //&lt;-- initialization of `data[0]` starts\n\n           0, 0.1\n\n        }, //&lt;-- initialization of `data[0]` ends\n\n       {2, 3.4}  //initialization of data[1] starts and ends, as above\n\n  } //&lt;--this tells the compiler that initialization of `data` ends\n};\n</code></pre>\n<p>which <a href=\"http://ideone.com/t7AdR\" rel=\"nofollow noreferrer\">compiles fine</a>. Once again, the extra braces are needed because you're initializing the <em>internal</em> array.</p>\n<p>--</p>\n<p>Now the question is why are extra braces not needed in case of <code>double</code>? </p>\n<p><strike>It is because <code>double</code> is not an aggregate, while <code>A</code> is. In other words, <code>std::array&lt;double, 2&gt;</code> is an aggregate of aggregate, while <code>std::array&lt;A, 2&gt;</code> is an aggregate of aggregate of aggregate<sup>1</sup>.</strike></p>\n<p><sup>1. I think that extra braces are still needed in the case of double also (like <a href=\"http://ideone.com/wZkeo\" rel=\"nofollow noreferrer\">this</a>), to be completely conformant to the Standard, but the code works without them. It seems I need to dig through the spec again!</sup>.\n</p>\n<h1>More on braces and extra braces</h1>\n<p>I dug through the spec. This section (\u00a78.5.1/11 from C++11) is interesting and applies to this case:</p>\n<blockquote>\n<p id=\"so_11734861_11735045_1\">In a declaration of the form</p>\n</blockquote>\n<pre><code>T x = { a };\n</code></pre>\n<blockquote>\n<p id=\"so_11734861_11735045_2\"><strong>braces can be elided in an initializer-list as follows</strong>. If the initializer-list begins with a left brace, then the succeeding comma-separated list of initializer-clauses initializes the members of a subaggregate; it is erroneous for there to be more initializer-clauses than members. If, however, the initializer-list for a subaggregate\n  does not begin with a left brace, then only enough initializer-clauses from the list are taken to initialize the members of the subaggregate; any remaining initializer-clauses are left to initialize the next member of the aggregate of which the current subaggregate is a member. [ Example:</p>\n</blockquote>\n<pre><code>float y[4][3] = {\n{ 1, 3, 5 },\n{ 2, 4, 6 },\n{ 3, 5, 7 },\n};\n</code></pre>\n<blockquote>\n<p id=\"so_11734861_11735045_3\">is a completely-braced initialization: 1, 3, and 5 initialize the first row of the array <code>y[0]</code>, namely <code>y[0][0]</code>, <code>y[0][1]</code>, and <code>y[0][2]</code>. Likewise the next two lines initialize <code>y[1]</code> and <code>y[2]</code>. The initializer ends early and therefore <code>y[3]s</code> elements are initialized as if explicitly initialized with an expression of the form float(), that is, are initialized with 0.0. In the following example, braces in the initializer-list are elided; however the initializer-list has the same effect as the completely-braced initializer-list of the above example,</p>\n</blockquote>\n<pre><code>float y[4][3] = {\n1, 3, 5, 2, 4, 6, 3, 5, 7\n};\n</code></pre>\n<blockquote>\n<p id=\"so_11734861_11735045_4\">The initializer for y begins with a left brace, but the one for <code>y[0]</code> does not, therefore three elements from the list are used. Likewise the next three are taken successively for <code>y[1]</code> and <code>y[2]</code>. \u2014end example ]</p>\n</blockquote>\n<p>Based on what I understood from the above quote, I can say that the following should be allowed:</p>\n<pre><code>//OKAY. Braces are completely elided for the inner-aggregate\nstd::array&lt;A, 2&gt; X =   \n{\n  0, 0.1,\n  2, 3.4\n};\n\n//OKAY. Completely-braced initialization\nstd::array&lt;A, 2&gt; Y = \n{{\n   {0, 0.1},\n   {2, 3.4}\n}};\n</code></pre>\n<p>In the first one, braces for the inner-aggregate are completely elided, while the second has fully-braced initialization. In your case (the case of <code>double</code>), the initialization uses the first approach (braces are <em>completely</em> elided for the inner aggregate).</p>\n<p>But this should be disallowed:</p>\n<pre><code>//ILL-FORMED : neither braces-elided, nor fully-braced\nstd::array&lt;A, 2&gt; Z = \n{\n  {0, 0.1},\n  {2, 3.4}\n};\n</code></pre>\n<p>It is neither braces-elided, nor are there enough braces to be completely-braced initialization. Therefore, it is ill-formed.</p>\n", "LastActivityDate": "2017-04-14T05:07:37.270"}, "bq_ids": {"n4140": {"so_11734861_11735045_3": {"section_id": 3308, "quality": 0.9761904761904762, "length": 41}, "so_11734861_11735045_2": {"section_id": 3308, "quality": 0.9591836734693877, "length": 47}, "so_11734861_11735045_4": {"section_id": 3308, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_11734861_11735045_3": {"section_id": 3178, "quality": 0.9761904761904762, "length": 41}, "so_11734861_11735045_2": {"section_id": 3178, "quality": 0.9795918367346939, "length": 48}, "so_11734861_11735045_4": {"section_id": 3178, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_11734861_11735045_3": {"section_id": 4074, "quality": 0.9761904761904762, "length": 41}, "so_11734861_11735045_2": {"section_id": 4074, "quality": 0.8571428571428571, "length": 42}, "so_11734861_11735045_4": {"section_id": 4074, "quality": 0.8421052631578947, "length": 16}}}});