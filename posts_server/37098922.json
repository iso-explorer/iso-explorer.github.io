post_cb({"37099162": {"Id": "37099162", "PostTypeId": "2", "Body": "<p>N3337 8.5.1/7</p>\n<blockquote>\n<p id=\"so_37098922_37099162_0\"><strong>If there are fewer initializer-clauses in the list than there are members in the aggregate</strong>, then each member\n  not explicitly initialized <strong>shall be initialized from an empty initializer list</strong> (8.5.4). </p>\n</blockquote>\n<pre><code>struct S { int a; const char* b; int c; };\nS ss = { 1, \"asdf\" };\n</code></pre>\n<blockquote>\n<p id=\"so_37098922_37099162_1\">initializes ss.a with 1, ss.b with \"asdf\", and ss.c with the value of an expression of the form <strong>int(),\n  that is, 0</strong>.</p>\n</blockquote>\n<p>So in your example first 5 elements are initialized with <code>rand()</code> other with <code>int()</code> which is <code>0</code>.</p>\n", "LastActivityDate": "2016-05-08T11:12:12.423", "CommentCount": "3", "CreationDate": "2016-05-08T11:12:12.423", "ParentId": "37098922", "Score": "3", "OwnerUserId": "4932834"}, "bq_ids": {"n4140": {"so_37098922_37099162_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 3304}, "so_37098922_37099162_1": {"length": 9, "quality": 1.0, "section_id": 3304}}, "n3337": {"so_37098922_37099162_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 3174}, "so_37098922_37099162_1": {"length": 9, "quality": 1.0, "section_id": 3174}}, "n4659": {"so_37098922_37099162_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 4070}, "so_37098922_37099162_1": {"length": 9, "quality": 1.0, "section_id": 4070}}}, "37099207": {"Id": "37099207", "PostTypeId": "2", "Body": "<p>GCC 4.8.4 will compile the code fine.\nNot every compiler does, MSVC++ 14 (VS 2015) doesn't compile</p>\n<pre><code>LayerData in({rand(),rand(),rand(),rand(),rand()});\n</code></pre>\n<p>But it does compile</p>\n<pre><code>LayerData in{{rand(),rand(),rand(),rand(),rand()}};\n</code></pre>\n<p>Using C++ 11 Universal notation</p>\n<p>Looking at the reason GCC permits this, it seems to be because it allocates the type on the stack and then uses XMM to move 32 bits (64 when compiled against x64) at a time into the memory location. Maybe this changes with the size of the type, but generally I'd say if you need to enforce the same length you shouldn't be exposing the type like this anyways. Do note that universal notation can actually be used to your advantage and with templates you can form something that looks a lot similar to what you're trying to do and enforces the same amount of arguments:</p>\n<pre><code>#include &lt;cstdint&gt;\n\ntemplate &lt;int N&gt;\nclass LayerData\n{\n    static_assert(N &gt; 0, \"Number must be greater than 0\");\npublic:\n    uint32_t d[N];\n    template&lt;typename... Args&gt;\n    LayerData(Args&amp;&amp;... args) : d{uint32_t(args)...}\n    {\n        static_assert(sizeof...(Args) == N, \"Invalid number of constructor arguments.\");\n    }\n};\n\nint main()\n{\n    LayerData&lt;4&gt; in1{1, 2, 3, 4}; //Fine\n    LayerData&lt;60&gt; in2{1, 2, 3, 4}; //Causes error \"Invalid number of constructor arguments.\"\n}\n</code></pre>\n<p>Hastily written, but you should get the idea.</p>\n", "LastActivityDate": "2016-05-08T11:17:14.097", "CommentCount": "0", "CreationDate": "2016-05-08T11:17:14.097", "ParentId": "37098922", "Score": "0", "OwnerUserId": "5369164"}, "37099121": {"Id": "37099121", "PostTypeId": "2", "Body": "<p>There is compile-time checking. This will not compile:</p>\n<pre><code>struct A\n{\n  int b[3];\n};\n\nint main()\n{\n  A a { 1, 2 };       // no problem here. equivalent to 1, 2, 0\n  A b { 1, 2, 3, 4 }; // problem here. too many initializers\n}\n</code></pre>\n<p>Because:</p>\n<pre><code>/tmp/gcc-explorer-compiler11648-73-eh15v1/example.cpp: In function 'int main()':\n10 : error: too many initializers for 'A'\nA b { 1, 2, 3, 4 };\n^\nCompilation failed\n</code></pre>\n<p>An array may be initialised with fewer items than it contains. In this case the remaining elements are value initialised (i.e. zero).</p>\n", "LastActivityDate": "2016-05-08T11:08:48.843", "CommentCount": "0", "CreationDate": "2016-05-08T11:08:48.843", "ParentId": "37098922", "Score": "2", "OwnerUserId": "2015579"}, "37098922": {"ViewCount": "135", "Body": "<p>I've found that when a simple data struct with default constructors contains an array, the default constructor can be called with a different number of arguments, ie:</p>\n<pre><code>struct LayerData\n{\n    uint32_t d[60];\n};\n</code></pre>\n<p>Can be initialized by:</p>\n<pre><code>LayerData in({rand(),rand(),rand(),rand(),rand()});\n</code></pre>\n<p>And it compiles properly.</p>\n<p>Is this the expected behaviour in C++11? Is there no compile-time checking of sizes in the implicit constructor?</p>\n", "AcceptedAnswerId": "37099162", "Title": "C++11 initializer list length is not checked in implicit constructor", "CreationDate": "2016-05-08T10:44:11.157", "Id": "37098922", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-05-08T11:17:14.097", "Score": "3", "OwnerUserId": "4542928", "Tags": "<c++><c++11><constructor><initializer-list>", "AnswerCount": "3"}});