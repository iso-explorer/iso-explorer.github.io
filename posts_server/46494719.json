post_cb({"bq_ids": {"n4140": {"so_46494719_46494893_0": {"length": 9, "quality": 0.9, "section_id": 5446}, "so_46494719_46494893_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 5457}}, "n4659": {"so_46494719_46494893_0": {"length": 9, "quality": 0.9, "section_id": 6873}, "so_46494719_46494893_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 6883}}}, "46494719": {"ViewCount": "84", "LastEditDate": "2017-09-29T18:37:10.203", "AcceptedAnswerId": "46494893", "Title": "Clash between trailing return type and return type deduction", "CreationDate": "2017-09-29T18:13:08.397", "LastActivityDate": "2017-09-29T18:37:10.203", "CommentCount": "3", "Body": "<p>I'm writing some code where the return type of a function is rather complicated. I'd like to make use of <code>auto</code> for deducing from the return type, but that's obviously not possible in a forward declaration. So I was hoping to at least only duplicate the contents of the return statement and do the following,</p>\n<pre><code>int q = 5; // veeery complicated type\n\n/* Declaration - the best we can do */\nauto f() -&gt; decltype(q);\n\n/* Later, in a different file */    \nauto f() {\n  return q;\n}\n</code></pre>\n<p>This produces the following error in GCC 7,</p>\n<pre><code>error: ambiguating new declaration of \u2018auto f()\u2019\nnote: old declaration \u2018int f()\u2019\n</code></pre>\n<p>Of course I could repeat</p>\n<pre><code>auto f() -&gt; decltype(q) {\n  return q;\n}\n</code></pre>\n<p>in the definition (which works) but why should I need to when the return type is already uniquely given by the <code>return</code> statement? How is the type of <code>f</code> in my definition ultimately any more ambiguous than <code>int f()</code>?</p>\n", "PostTypeId": "1", "LastEditorUserId": "4342498", "Id": "46494719", "Score": "4", "OwnerUserId": "1537925", "Tags": "<c++><function><return-type><auto><trailing-return-type>", "AnswerCount": "1"}, "46494893": {"Id": "46494893", "PostTypeId": "2", "LastEditDate": "2017-09-29T18:36:32.247", "CommentCount": "0", "LastEditorUserId": "4342498", "LastActivityDate": "2017-09-29T18:36:32.247", "CreationDate": "2017-09-29T18:25:57.913", "ParentId": "46494719", "Score": "7", "Body": "<p>The problem here is that a trailing return is not the same as purely deduced return type.  In [dcl.spec.auto]/2</p>\n<blockquote>\n<p id=\"so_46494719_46494893_0\">[...]If the function declarator includes a <em>trailing-return-type</em> (8.3.5), that specifies the declared return type of the function</p>\n</blockquote>\n<p>So </p>\n<pre><code>auto f() -&gt; decltype(q);\n</code></pre>\n<p>is really</p>\n<pre><code>int f();\n</code></pre>\n<p>which is different from </p>\n<pre><code>auto f()\n</code></pre>\n<p>There is also [dcl.spec.auto]/13</p>\n<blockquote>\n<p id=\"so_46494719_46494893_1\">Redeclarations or specializations of a function or function template with a declared return type that uses a placeholder type shall also use that placeholder, not a deduced type.  [ Example:</p>\n<pre><code>auto f();\nauto f() { return 42; }  // return type is int\nauto f();                // OK\nint f();                 // error, cannot be overloaded with auto f()\ndecltype(auto) f();      // error, auto and decltype(auto) don\u2019t match\n</code></pre>\n</blockquote>\n<p>Which is kind of opposite of what is going on here but it does further exemplify that this is not allowed</p>\n", "OwnerUserId": "4342498"}});