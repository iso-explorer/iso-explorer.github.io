post_cb({"bq_ids": {"n4140": {"so_46994594_46994931_0": {"length": 13, "quality": 1.0, "section_id": 61}}, "n3337": {"so_46994594_46994931_0": {"length": 13, "quality": 1.0, "section_id": 56}}, "n4659": {"so_46994594_46994931_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 63}}}, "46994931": {"Id": "46994931", "PostTypeId": "2", "Body": "<p>Basically, what's going on is this:</p>\n<pre><code>Stage2&lt;FuncType&gt;::foobar&lt;func&gt;();\n</code></pre>\n<p>contains a dependent name (depending on FuncType), therefore you have to follow the correct C++-syntax for calling member templates (thus the syntax error messages), which is</p>\n<pre><code>Stage2&lt;FuncType&gt;::template foobar&lt;func&gt;();\n</code></pre>\n<p>Note that this does not apply for <code>Stage2&lt;void()&gt;::foobar&lt;func&gt;();</code> as there is no dependent name involved.</p>\n<p>The same applies to <code>Stage2&lt;decltype(func)&gt;::foobar&lt;func&gt;();</code>, but this alone still won't fix it as there is some tricky obstacle. According to \u00a714.1.8 [temp.param],</p>\n<blockquote>\n<p id=\"so_46994594_46994931_0\">A non-type template-parameter of type \u201carray of T\u201d or \u201cfunction returning T\u201d is adjusted to be of type \u201cpointer to T\u201d or \u201cpointer to function returning T\u201d, respectively.</p>\n</blockquote>\n<p><code>decltype(func)</code> will be <code>void(*)()</code> instead of <code>void()</code> (even though <code>FuncType</code> was specified to be <code>void()</code>), so no function type but pointer to function type will be passed as template parameter to <code>Stage2</code> for which there is no specialization provided (as <code>Stage2&lt;Ret (Args...)&gt;</code> and <code>Stage2&lt;Ret (*)(Args...)&gt;</code> are not the same), thus falling back to the default template declaration, finally yielding a \"use of incomplete type\" error.</p>\n", "LastEditorUserId": "7703564", "LastActivityDate": "2017-10-28T22:26:01.033", "Score": "2", "CreationDate": "2017-10-28T22:02:16.300", "ParentId": "46994594", "CommentCount": "1", "LastEditDate": "2017-10-28T22:26:01.033", "OwnerUserId": "7703564"}, "46994594": {"ViewCount": "45", "Body": "<p>Consider the following, minimal example (compiles without <code>#1</code> and <code>#2</code>):</p>\n<pre><code>void foo(void)\n{ }\n\ntemplate&lt;typename T&gt; class Stage2;\n\ntemplate&lt;typename Ret, typename... Args&gt;\nstruct Stage2&lt;Ret (Args...)&gt;\n{\n    template&lt;Ret (*func)(Args...)&gt;\n    static void foobar(void)\n    { /* Do something */ }\n};\n\ntemplate&lt;typename FuncType&gt;\nstruct Stage1\n{\n    template&lt;FuncType func&gt;\n    static void bar(void)\n    {\n        Stage2&lt;FuncType&gt;::foobar&lt;func&gt;();       // #1, Not working\n        Stage2&lt;decltype(func)&gt;::foobar&lt;func&gt;(); // #2, Not working\n        Stage2&lt;void()&gt;::foobar&lt;func&gt;();         // #3, Working\n    }\n};\n\nint main(void)\n{\n    Stage1&lt;decltype(foo)&gt;::bar&lt;foo&gt;();\n    return 0;\n}\n</code></pre>\n<p>Why does it not compile with <code>#1</code> and <code>#2</code>, whereas it compiles just fine with <code>#3</code>? In my opinion, <code>#3</code> should be equivalent to the others as long as foo has the signature <code>void()</code>, which it does in this example. Even the compiler tells me, that <code>FuncType</code> is in fact <code>void()</code> (see below).</p>\n<p>Error message (the same for <code>#1</code> and <code>#2</code>):</p>\n<pre><code>main.cpp: In static member function \u2018static void Stage1&lt;FuncType&gt;::bar()\u2019:\nmain.cpp:21:40: error: expected primary-expression before \u2018)\u2019 token\n         Stage2&lt;FuncType&gt;::foobar&lt;func&gt;();       // #1, Not working\n                                        ^\nmain.cpp: In instantiation of \u2018static void Stage1&lt;FuncType&gt;::bar() [with FuncType func = foo; FuncType = void()]\u2019:\nmain.cpp:29:37:   required from here\nmain.cpp:21:33: error: invalid operands of types \u2018&lt;unresolved overloaded function type&gt;\u2019 and \u2018void (*)()\u2019 to binary \u2018operator&lt;\u2019\n         Stage2&lt;FuncType&gt;::foobar&lt;func&gt;();       // #1, Not working\n         ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n</code></pre>\n<p>What am I missing here? I'm using g++ 7.2.0.</p>\n<p>Note: I'm not really interested if this is useful in any way, I'd just like to know why it doesn't compile because it makes no sense to me.</p>\n", "AcceptedAnswerId": "46994931", "Title": "C++ template not compiling when passing through function signature", "CreationDate": "2017-10-28T21:19:29.927", "Id": "46994594", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-10-28T22:26:01.033", "Score": "3", "OwnerUserId": "7421666", "Tags": "<c++><templates>", "AnswerCount": "1"}});