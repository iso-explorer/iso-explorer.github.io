post_cb({"36594847": {"ParentId": "36594569", "CommentCount": "3", "Body": "<p>All standard library header files have the same definition; it does not matter which one you include in your own code. On my computer, I have the following declaration in <code>_stddef.h</code>. This file is included by every file you listed.</p>\n<pre><code>/*\n   Define the size_t type in the std namespace if in C++ or globally if in C.\n   If we're in C++, make the _SIZE_T macro expand to std::size_t\n*/\n\n#if !defined(_SIZE_T) &amp;&amp; !defined(_SIZE_T_DEFINED)\n#  define _SIZE_T_DEFINED\n#if defined(_WIN64)\n   typedef unsigned __int64 size_t;\n#else\n   typedef unsigned int size_t;\n#endif\n#  if defined(__cplusplus)\n#    define _SIZE_T std::size_t\n#  else\n#    define _SIZE_T size_t\n#  endif\n#endif\n</code></pre>\n", "OwnerUserId": "5489178", "PostTypeId": "2", "Id": "36594847", "Score": "9", "CreationDate": "2016-04-13T09:56:47.090", "LastActivityDate": "2016-04-13T09:56:47.090"}, "36594669": {"ParentId": "36594569", "PostTypeId": "2", "CommentCount": "51", "Body": "<p>You could do without a header:</p>\n<pre><code>using size_t = decltype(sizeof(int));\nusing size_t = decltype(sizeof 1); //  The shortest is my favourite.\nusing size_t = decltype(sizeof \"anything\");\n</code></pre>\n<p>This is because the C++ standard requires:</p>\n<blockquote>\n<p id=\"so_36594569_36594669_0\">The result of <code>sizeof</code> and <code>sizeof...</code> is a constant of type <code>std::size_t</code>. [ Note: <code>std::size_t</code> is defined in the standard header <code>&lt;cstddef&gt;</code> (18.2). \u2014 end note ]</p>\n</blockquote>\n<p>In other words, the standard requires:</p>\n<pre><code>static_assert(std::is_same&lt;decltype(sizeof(int)), std::size_t&gt;::value,\n              \"This never fails.\");\n</code></pre>\n<hr>\n<p>Also note, that it is perfectly fine to make this <code>typedef</code> declaration in the global and in <code>std</code> namespace, as long as it matches all other <code>typedef</code> declarations of the same <em>typedef-name</em> (a compiler error is issued on non-matching declarations).</p>\n<p>This is because:</p>\n<ul>\n<li><p>\u00a77.1.3.1 A <em>typedef-name</em> does not introduce a new type the way a class declaration (9.1) or enum declaration does.</p></li>\n<li><p>\u00a77.1.3.3 In a given non-class scope, a <code>typedef</code> specifier can be used to redefine the name of any type declared in that scope to refer to the type to which it already refers.</p></li>\n</ul>\n<hr>\n<p>To sceptics saying that this constitutes an addition of a new type into namespace <code>std</code>, and such an act is explicitly prohibited by the standard, and this is UB and that is all there to it; I have to say that this attitude amounts to ignoring and denying deeper understanding of the underlying issues.</p>\n<p>The standard bans adding new declarations and definitions into namespace <code>std</code> because by doing so the user may make a mess of the standard library and shoot his entire leg off. For the standard writers it was easier to let the user specialize a few specific things and ban doing anything else for good measure, rather than ban every single thing which the user should not do and risk missing something important (and that leg). They did it in the past when requiring that no standard container shall be instantiated with an incomplete type, while in fact some containers could well do (see <a href=\"http://www.drdobbs.com/the-standard-librarian-containers-of-inc/184403814\" rel=\"nofollow\">The Standard Librarian: Containers of Incomplete Types by Matthew H. Austern</a>):</p>\n<blockquote>\n<p id=\"so_36594569_36594669_1\">... In the end, it all seemed too murky and too poorly understood; the standardization committee didn't think there was any choice except to say that STL containers aren't supposed to work with incomplete types. For good measure, we applied that prohibition to the rest of the standard library too.</p>\n<p id=\"so_36594569_36594669_2\">... In retrospect, now that the technology is better understood, that decision still seems basically right. Yes, in some cases it's possible to implement some of the standard containers so that they can be instantiated with incomplete types \u2014 but it's also clear that in other cases it would be difficult or impossible. It was mostly chance that the first test we tried, using <code>std::vector</code>, happened to be one of the easy cases.</p>\n</blockquote>\n<p>Given that the language rules require <code>std::size_t</code> to be exactly <code>decltype(sizeof(int))</code>, doing <code>namespace std { using size_t = decltype(sizeof(int)); }</code> is one of those things that do not break anything.</p>\n<p>Prior to C++11 there was no <code>decltype</code> and thus no way to declare the type of <code>sizeof</code> result in one simple statement without getting a good deal of templates involved. <code>size_t</code> aliases different types on different target architectures, however, it would not be an elegant solution to add a new built-in type just for the result of <code>sizeof</code>, and there are no standard built-in typedefs. Hence, the most portable solution at the time was to put <code>size_t</code> type alias in some specific header and document that.</p>\n<p>In C++11 there is now a way to write down that exact requirement of the standard as one simple declaration. </p>\n</hr></hr>", "OwnerUserId": "412080", "LastEditorUserId": "412080", "LastEditDate": "2016-04-14T22:46:17.717", "Id": "36594669", "Score": "1", "CreationDate": "2016-04-13T09:49:48.740", "LastActivityDate": "2016-04-14T22:46:17.717"}, "36594716": {"ParentId": "36594569", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>Assuming I wanted to minimize the functions and types I was importing I'd go with <code>cstddef</code> as it doesn't declare any functions and only declares 6 types. The others focus on particular domains (strings, time, IO) that may not matter to you.</p>\n<p>Note that <code>csttddef</code> only guarantees to define <code>std::size_t</code>, that is, defining <code>size_t</code> in namespace <code>std</code>, although it <em>may</em> provide this name also in the global namespace (effectively, plain <code>size_t</code>).</p>\n<p>In contrast, <code>stddef.h</code> (which is also a header available in C) guarantees to define <code>size_t</code> in the global namespace, and <em>may</em> also provide <code>std::size_t</code>.</p>\n", "OwnerUserId": "26095", "LastEditorUserId": "464581", "LastEditDate": "2016-09-27T06:30:30.090", "Id": "36594716", "Score": "49", "CreationDate": "2016-04-13T09:51:46.437", "LastActivityDate": "2016-09-27T06:30:30.090"}, "36596739": {"ParentId": "36594569", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>In fact the synopsis (included in the C++ standard) of several headers specifially include <code>size_t</code> as well as further headers define the type <code>size_t</code> (based on the C standard as the <code>&lt;cX&gt;</code> headers are just ISO C <code>&lt;X.h&gt;</code> headers with noted changes where removal of <code>size_t</code> is not indicated).</p>\n<p><strong>The C++ standard</strong> however, <strong>refers to <code>&lt;cstddef&gt;</code> for the definition of <code>std::size_t</code></strong> </p>\n<ul>\n<li>in <em>18.2 Types</em>, </li>\n<li>in <em>5.3.3 Sizeof</em>, </li>\n<li>in <em>3.7.4.2 Deallocation functions</em> (which refers to 18.2) and</li>\n<li>in <em>3.7.4.1 Allocation functions</em> (also refers to 18.2).</li>\n</ul>\n<p>Therefore and because of the fact that <code>&lt;cstddef&gt;</code> only introduces types and no functions, I'd stick to this header to make <code>std::size_t</code> available.</p>\n<hr>\n<p><strong>Note a few things :</strong></p>\n<ol>\n<li><p><strong>The type of <code>std::size_t</code> is obtainable using <code>decltype</code> without including a header</strong></p>\n<p>If you're planning to introduce a typedef in your code anyway (i.e. because you write a container and want to provide a <code>size_type</code> typedef) you can use the global <code>sizeof</code>, <code>sizeof...</code> or <code>alignof</code> operators to define your type without including any headers at all since theose operators return <code>std::size_t</code> per standard definition and you can use <code>decltype</code> on them:</p>\n<pre><code>using size_type = decltype(alignof(char));\n</code></pre></li>\n<li><p><strong><code>std::size_t</code> is not per se globally visible although functions with <code>std::size_t</code> arguments are.</strong></p>\n<p>The implicitly declared global allocation and deallocation functions </p>\n<pre><code>void* operator new(std::size_t);\nvoid* operator new[](std::size_t);\nvoid operator delete(void*);\nvoid operator delete[](void*);\n</code></pre>\n<p>do NOT introduce <code>size_t</code>, <code>std</code> or <code>std::size_t</code> and </p>\n<blockquote>\n<p id=\"so_36594569_36596739_0\">referring to <code>std</code> or <code>std::size_t</code> is ill-formed unless the name has been declared by including the appropriate header.</p>\n</blockquote></li>\n<li><p><strong>The user may not redefine <code>std::size_t</code> although it is possible to have multiple typedefs referring to the same type in the same namespace.</strong></p>\n<p>Although, the occurrence of multiple definitions of <code>size_t</code> within <code>std</code> is perfectly valid as per <em>7.1.3 / 3</em>, it is not allowed to add any declarations to <code>namespace std</code> as per <em>17.6.4.2.1 / 1</em>:</p>\n<blockquote>\n<p id=\"so_36594569_36596739_1\">The behavior of a C++ program is undefined if it adds declarations or definitions to namespace std or to a namespace within namespace std unless otherwise specified.</p>\n</blockquote>\n<p>Adding a proper typedef for <code>size_t</code> to the namespace does not violate <em>7.1.3</em> but it does violate <em>17.6.4.2.1</em> and leads to undefined behaviour.</p>\n<p><em><sub>Clarification: Try not to misinterpret <strong>7.1.3</strong> and do not add declarations or definitions to <code>std</code> (except a few template specialization cases where a typedef is not a template specialization). <a href=\"http://en.cppreference.com/w/cpp/language/extending_std\" rel=\"noreferrer\">Extending the <code>namespace std</code></a></sub></em></p></li>\n</ol>\n</hr>", "OwnerUserId": "951423", "LastEditorUserId": "366904", "LastEditDate": "2016-04-13T15:37:01.263", "Id": "36596739", "Score": "36", "CreationDate": "2016-04-13T11:18:20.137", "LastActivityDate": "2016-04-13T15:37:01.263"}, "bq_ids": {"n4140": {"so_36594569_36596739_0": {"section_id": 7174, "quality": 1.0, "length": 10}, "so_36594569_36594669_0": {"section_id": 6081, "quality": 0.6666666666666666, "length": 10}, "so_36594569_36596739_1": {"section_id": 6299, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_36594569_36596739_0": {"section_id": 6918, "quality": 1.0, "length": 10}, "so_36594569_36594669_0": {"section_id": 5849, "quality": 0.6666666666666666, "length": 10}, "so_36594569_36596739_1": {"section_id": 6056, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_36594569_36596739_0": {"section_id": 8682, "quality": 1.0, "length": 10}, "so_36594569_36594669_0": {"section_id": 7577, "quality": 0.6666666666666666, "length": 10}, "so_36594569_36596739_1": {"section_id": 7808, "quality": 0.9285714285714286, "length": 13}}}, "36594569": {"CommentCount": "14", "AcceptedAnswerId": "36594716", "PostTypeId": "1", "LastEditorUserId": "3747990", "CreationDate": "2016-04-13T09:45:44.433", "LastActivityDate": "2016-09-27T06:30:30.090", "LastEditDate": "2016-04-13T10:02:34.020", "ViewCount": "6312", "FavoriteCount": "3", "Title": "Which header should I include for `size_t`?", "Id": "36594569", "Score": "49", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/types/size_t\">cppreference.com</a> <code>size_t</code> is defined in several headers, namely</p>\n<pre><code>&lt;cstddef&gt;\n&lt;cstdio&gt;\n&lt;cstring&gt;\n&lt;ctime&gt;\n</code></pre>\n<p>And, since C++11, also in</p>\n<pre><code>&lt;cstdlib&gt;\n&lt;cwchar&gt; \n</code></pre>\n<p>First of all I wonder why this is the case. Isn't this in contradiction to the <a href=\"https://en.wikipedia.org/wiki/Don't_repeat_yourself\">DRY</a> principle? However, my question is: </p>\n<p><strong>Which one of the above headers should I include to use <code>size_t</code>? Does it matter at all?</strong></p>\n", "Tags": "<c++><typedef>", "OwnerUserId": "4117728", "AnswerCount": "4"}});