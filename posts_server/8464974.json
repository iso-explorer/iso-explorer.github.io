post_cb({"8464996": {"ParentId": "8464974", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yep, you're safe. What you're doing is covered by the \"Except that converting...\" case.</p>\n<p>The reason that it's called out is to let you pass function pointers through another type of function pointer. So you could define something like:</p>\n<pre><code>enum CallbackType {\n    eFuncPtrVoidReturningVoid,\n    eFuncPtrVoidReturningInt,\n    // ... more as needed ...\n};\n\nclass CallbackRecord\n{\npublic:\n    CallbackRecord(void (*cb)()): cbType(eFuncPtrVoidReturningVoid), cbFunc(cb) \n        {}\n    CallbackRecord(int (*cb)()): cbType(eFuncPtrVoidReturningInt), \n        cbFunc(reinterpret_cast&lt;void (*)()&gt;(cb)) {}\n    void operator()() const;\nprotected:\n    CallbackType cbType;\n    void (*cbFunc)();\n};\n\nvoid CallbackRecord::operator()() const\n{\n    switch(cbType)\n    {\n    case eFuncPtrVoidReturningVoid:\n        (*cbFunc)();\n        break;\n\n    case eFuncPtrVoidReturningInt:\n        while((*reinterpret_cast&lt;int (*)()&gt;(cbFunc))())\n            ;\n        break;\n    }\n}\n</code></pre>\n<p>While you could just say \"make all the callbacks return <code>int</code>\", this would require you to write wrappers for anything not conforming to the calling convention if the number of callback types gets beyond two.  Allowing these function pointer typecasts gives you an alternate means of supporting multiple callback types, and keeps us from needing to turn <code>CallbackRecord</code> into a template. It also allows subclassing or marshaling to replace the <code>switch</code> statement above without requiring the use of <code>virtual</code> methods.</p>\n", "OwnerUserId": "2624511", "LastEditorUserId": "2624511", "LastEditDate": "2011-12-11T15:26:54.337", "Id": "8464996", "Score": "4", "CreationDate": "2011-12-11T15:10:32.747", "LastActivityDate": "2011-12-11T15:26:54.337"}, "8464998": {"ParentId": "8464974", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes it is safe.<br>\n<code>reinterpret_cast</code> just allows you to cast one pointer to another but it does not guarantee any safety and the result of using such an pointer is unspecified unless it is typecast-ed back to its original type.  </br></p>\n<p>The standard quote mentioned specifies that if you typecast a function pointer of one type to another type and try to call a function through it then the result is undefined.</p>\n<p>However,<br>\n<code>reinterpret_cast</code> guarantees you that if you cast the typecast-ed pointer back to the original type then the pointer is well formed.    </br></p>\n<p>Your code tries to do the second and hence it is safe.</p>\n", "OwnerUserId": "452307", "LastEditorUserId": "430766", "LastEditDate": "2011-12-11T15:27:00.413", "Id": "8464998", "Score": "5", "CreationDate": "2011-12-11T15:10:57.983", "LastActivityDate": "2011-12-11T15:27:00.413"}, "8464974": {"CommentCount": "0", "CreationDate": "2011-12-11T15:07:00.323", "PostTypeId": "1", "AcceptedAnswerId": "8465066", "LastEditorUserId": "963864", "LastActivityDate": "2011-12-11T17:38:56.467", "LastEditDate": "2011-12-11T17:38:56.467", "ViewCount": "103", "FavoriteCount": "1", "Title": "Result of converting a pointer to function to different pointer to function type ", "Id": "8464974", "Score": "2", "Body": "<blockquote>\n<p id=\"so_8464974_8464974_0\">(5.2.10/6) C++03 A pointer to a function can be explicitly converted to a pointer to a function of a different type. The effect of calling a function\n  through a pointer to a function type (8.3.5) that is not the same as\n  the type used in the definition of the function is undefined. Except\n  that converting an rvalue of type \"pointer to T1\" to the type \"pointer\n  to T2\" (where T1 and T2 are function types) and back to its original\n  type yields the original pointer value, the result of such a pointer\n  conversion is unspecified. [Note: see also 4.10 for more details of\n  pointer conversions.]</p>\n</blockquote>\n<p>The following is what I'm trying to do, while it is clear that the result of converting <code>fp1</code> to <code>fp2</code> will produce a original pointer but at the same point the wording in standard goes <code>\"The result of such a pointer conversion is unspecified\"</code> What does it mean by that?</p>\n<pre><code>int f() { return 42; }\n\nint main()\n{\n    void(*fp1)() = reinterpret_cast&lt;void(*)()&gt;(f);\n\n    int(*fp2)() = reinterpret_cast&lt;int(*)()&gt;(fp1);\n\n    // Safe to call the function ?\n    fp2();\n}\n</code></pre>\n", "Tags": "<c++><function-pointers><reinterpret-cast>", "OwnerUserId": "1086635", "AnswerCount": "3"}, "8465066": {"ParentId": "8464974", "CommentCount": "3", "Body": "<p>You are misreading the standard, the \"unspecified\" part only applies to other conversions:</p>\n<blockquote>\n<p id=\"so_8464974_8465066_0\">Except [special case] the result of such a pointer conversion is unspecified.</p>\n</blockquote>\n<p>That [special case] is the one where you convert back to the original function pointer type, like in your example. In this special case the conversions yield the original pointer value, so it's ok to use it like in your example.</p>\n<p>Only for other conversions the result is unspecified.</p>\n", "OwnerUserId": "56338", "PostTypeId": "2", "Id": "8465066", "Score": "5", "CreationDate": "2011-12-11T15:18:41.743", "LastActivityDate": "2011-12-11T15:18:41.743"}, "bq_ids": {"n4140": {"so_8464974_8465066_0": {"section_id": 6045, "quality": 0.75, "length": 6}, "so_8464974_8464974_0": {"section_id": 6045, "quality": 0.8392857142857143, "length": 47}}, "n3337": {"so_8464974_8465066_0": {"section_id": 5813, "quality": 0.75, "length": 6}, "so_8464974_8464974_0": {"section_id": 5813, "quality": 0.8392857142857143, "length": 47}}, "n4659": {"so_8464974_8465066_0": {"section_id": 7544, "quality": 0.75, "length": 6}, "so_8464974_8464974_0": {"section_id": 7544, "quality": 0.8214285714285714, "length": 46}}}});