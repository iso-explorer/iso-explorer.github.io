post_cb({"6974037": {"Id": "6974037", "PostTypeId": "2", "Body": "<p>You can use posix_memalign/_aligned_malloc to allocate a piece of memory and then using the special 'new' operator syntax to initialize an object in that memory region. Something like this:</p>\n<pre><code>// Allocate raw memory for a Foo object.\nvoid *mem;\nsize_t alignment = 0x1000;\nsize_t size = ?;\nposix_memalign(&amp;mem, alignment, size);\n// Call the constructor on the allocated memory.\nFoo *foo = new (mem) Foo(...);\n\n// Now you have a useable object.\nfoo-&gt;some_method();\n\n// Call destructor without freeing object memory.\nfoo-&gt;~Foo();\n// Free raw memory.\nfree(foo);\n</code></pre>\n", "LastEditorUserId": "364818", "LastActivityDate": "2014-10-09T23:30:01.140", "Score": "8", "CreationDate": "2011-08-07T16:26:18.307", "ParentId": "6973995", "CommentCount": "3", "OwnerUserId": "20816", "LastEditDate": "2014-10-09T23:30:01.140"}, "23693421": {"Id": "23693421", "PostTypeId": "2", "Body": "<p>Intel's <a href=\"https://software.intel.com/en-us/node/468120\" rel=\"nofollow\">TBB</a> provides a portable <code>cache_aligned_allocator</code>, which I think you might be what you're looking for.</p>\n", "LastActivityDate": "2014-05-16T05:49:03.040", "CommentCount": "0", "CreationDate": "2014-05-16T05:49:03.040", "ParentId": "6973995", "Score": "0", "OwnerUserId": "3288910"}, "19291957": {"Id": "19291957", "PostTypeId": "2", "Body": "<p>For aligned memory allocated on heap I use align() implementation from <a href=\"http://code.google.com/p/c-plus/source/browse/src/util.h#57\" rel=\"nofollow\">http://code.google.com/p/c-plus/source/browse/src/util.h#57</a>, because my gcc4.8 seems to not support it. Here is a sample code:</p>\n<pre><code>typedef float TItem;\nstatic const int SIZE = 100;\nstatic const int ALIGNMENT = 16;\n\n// allocate heap storage larger then SIZE\nTItem* storage = new TItem[SIZE + (ALIGNMENT / sizeof(TItem))];\nvoid* storage_ptr = (void*)storage;\nsize_t storage_size = sizeof(TItem) * (SIZE + 1);\n// aligned_array should be properly aligned\nTItem* aligned_array = (TItem*) align(MEM_ALIGNMENT, sizeof(TItem) * SIZE, storage_ptr, storage_size);\nif (!aligned_array) { throw std::bad_alloc(); }\n</code></pre>\n", "LastActivityDate": "2013-10-10T09:28:03.360", "CommentCount": "0", "CreationDate": "2013-10-10T09:28:03.360", "ParentId": "6973995", "Score": "1", "OwnerUserId": "1341914"}, "11044358": {"Id": "11044358", "PostTypeId": "2", "Body": "<p>Take a look at <code>std::aligned_storage</code> and the <code>alignas()</code> operator.  They're part of C++11, and seem to be exactly what you're looking for.</p>\n", "LastEditorUserId": "93652", "LastActivityDate": "2012-06-15T06:06:49.007", "Score": "4", "CreationDate": "2012-06-15T03:53:31.170", "ParentId": "6973995", "CommentCount": "2", "OwnerUserId": "1457749", "LastEditDate": "2012-06-15T06:06:49.007"}, "bq_ids": {"n4140": {"so_6973995_16510895_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7177}, "so_6973995_16510895_1": {"length": 27, "quality": 0.9, "section_id": 6092}}, "n3337": {"so_6973995_16510895_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6921}, "so_6973995_16510895_1": {"length": 27, "quality": 0.9, "section_id": 5859}}, "n4659": {"so_6973995_16510895_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 8685}, "so_6973995_16510895_1": {"length": 27, "quality": 0.9, "section_id": 7588}}}, "6974010": {"Id": "6974010", "PostTypeId": "2", "Body": "<p>C++03 and C++0x have <code>operator new</code>.</p>\n<p><code>new T</code> or <code>new T[]</code> guarantees to return properly aligned memory for object of type T.</p>\n<p><code>new char[]</code>, <code>new signed char[]</code> and <code>new unsigned char[]</code> guarantee to return memory properly aligned for <strong><em>any</em></strong> object, so that you can use placement new on it.</p>\n", "LastActivityDate": "2011-08-07T16:21:28.103", "CommentCount": "3", "CreationDate": "2011-08-07T16:21:28.103", "ParentId": "6973995", "Score": "4", "OwnerUserId": "469935"}, "6974009": {"Id": "6974009", "PostTypeId": "2", "Body": "<p>The C++ Standard has always guaranteed suitable alignment for <em>any</em> object from heap allocations- that is,</p>\n<pre><code>template&lt;typename T&gt; T* func() {\n    char* buf = new char[sizeof(T)];\n    return new(buf) T();\n}\n</code></pre>\n<p>is guaranteed not to fail for alignment reasons.</p>\n", "LastActivityDate": "2011-08-07T16:21:27.470", "CommentCount": "5", "CreationDate": "2011-08-07T16:21:27.470", "ParentId": "6973995", "Score": "-1", "OwnerUserId": "298661"}, "6973995": {"ViewCount": "18212", "Body": "<p><code>posix_memalign</code> and <code>_aligned_malloc</code> on Windows allow to dynamically allocate an aligned chunk of memory. Is there anything similar in C++11? As far as I know, the <code>alignas</code> keyword only works with statically allocated objects.</p>\n", "Title": "Dynamic aligned memory allocation in C++11", "CreationDate": "2011-08-07T16:18:48.593", "LastActivityDate": "2017-08-08T17:34:34.750", "CommentCount": "7", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2017-08-08T17:34:34.750", "LastEditorUserId": "3885376", "Id": "6973995", "Score": "34", "OwnerUserId": "882903", "Tags": "<c++><c++11>", "AnswerCount": "7"}, "16510895": {"Id": "16510895", "PostTypeId": "2", "Body": "<p>It depends on what alignment you require. For anything &lt;= to <code>alignof(std::max_align_t)</code>, <code>new</code> works as per n3242 3.7.4.1/2:</p>\n<blockquote>\n<p id=\"so_6973995_16510895_0\">The pointer returned shall be suitably aligned so that it can be\n  converted to a pointer of any complete object type with a fundamental\n  alignment requirement</p>\n</blockquote>\n<p><code>std::max_align_t</code> is a complete object type with the strictest fundamental alignment.</p>\n<p>Note that allocation of arrays of <code>char</code> or <code>unsigned char</code> but not <code>signed char</code> have a different rule in 5.3.4/10:</p>\n<blockquote>\n<p id=\"so_6973995_16510895_1\">For arrays of char and unsigned char, the di\ufb00erence between the result\n  of the new-expression and the address returned by the allocation\n  function shall be an integral multiple of the strictest fundamental\n  alignment requirement (3.11) of any object type whose size is no\n  greater than the size of the array being created.</p>\n</blockquote>\n<p>So <code>new char[1];</code> can have an alignment of 1.</p>\n<p>As for allocating memory with an alignment greater than <code>alignof(std::max_align_t)</code>, C++11 provides no direct way to do this. The only reliable way is to allocate at least <code>size + alignment</code> bytes and use <a href=\"http://en.cppreference.com/w/cpp/memory/align\">std::align</a> to get a correctly aligned location in this buffer.</p>\n<p>This can waste a lot of memory, so if you need a lot of these, you could create an allocator that allocates a chunk large enough for all of them and use std::align on that. Your overhead is then amortized across all of the allocations.</p>\n<p>Your other option is to wait for <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2012/n3396.htm\">http://open-std.org/JTC1/SC22/WG21/docs/papers/2012/n3396.htm</a> to make it into the standard.</p>\n<p>Personally I would just write an abstraction layer over the OS provided APIs for allocating aligned memory.</p>\n", "LastEditorUserId": "190158", "LastActivityDate": "2014-05-16T04:55:50.473", "Score": "27", "CreationDate": "2013-05-12T18:52:01.087", "ParentId": "6973995", "CommentCount": "1", "OwnerUserId": "190158", "LastEditDate": "2014-05-16T04:55:50.473"}});