post_cb({"27025639": {"ParentId": "27025553", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-11-19T19:46:34.493", "Score": "0", "LastEditorUserId": "2380830", "LastEditDate": "2014-11-19T19:56:58.730", "Id": "27025639", "OwnerUserId": "2380830", "Body": "<p>You'll get undefined behaviour in both cases if you attempt to dereference the converted pointer.</p>\n<p>Informally, this is because the alignments of the types might be different.</p>\n<p>Using a union; with a longer type and an array of the shorter type is one safe way of converting data.</p>\n", "LastActivityDate": "2014-11-19T19:56:58.730"}, "27025662": {"ParentId": "27025553", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-11-19T19:47:35.373", "Score": "2", "LastEditorUserId": "3647361", "LastEditDate": "2014-11-19T20:28:48.583", "Id": "27025662", "OwnerUserId": "3647361", "Body": "<p>Casting a pointer to another (arbitrary) pointer type, as long as it's not ill-formed, doesn't constitute a violation; But accessing the pointees value after dereferencing that pointer would be.</p>\n<p>Your cast is equivalent to a <code>reinterpret_cast</code>, [expr.reinterpret.cast]/7:</p>\n<blockquote>\n<p id=\"so_27025553_27025662_0\">An object pointer can be explicitly converted to an object pointer of\n  a different type. When a prvalue v of type \u201cpointer to <code>T1</code>\u201d is\n  converted to the type \u201cpointer to <em>cv</em> <code>T2</code>\u201d, the result is <code>static_cast&lt;</code><em>cv</em>\n<code>T2*&gt;(static_cast&lt;</code><em>cv</em> <code>void*&gt;(v))</code> if both <code>T1</code> and <code>T2</code> are standard-layout\n  types (3.9) and the alignment requirements of <code>T2</code> are no stricter than\n  those of <code>T1</code>, or if either type is void.</p>\n</blockquote>\n", "LastActivityDate": "2014-11-19T20:28:48.583"}, "27025553": {"CommentCount": "4", "AcceptedAnswerId": "27026009", "PostTypeId": "1", "ClosedDate": "2014-11-19T21:17:41.130", "LastEditorUserId": "2551229", "CreationDate": "2014-11-19T19:42:02.537", "LastActivityDate": "2014-11-19T21:04:20.820", "LastEditDate": "2014-11-19T21:04:20.820", "ViewCount": "152", "FavoriteCount": "1", "Title": "Strict aliasing rule in array", "Id": "27025553", "Score": "1", "Body": "<p>Is this fragment of code a violation of strict aliasing rule:</p>\n<pre><code>int main()\n{\n    short tab[] = {1,2,3,4};\n    int* ps = (int*)(&amp;tab[0]);\n    int i = *ps;\n}\n</code></pre>\n<p>I do know that if this was in the opposite way it would be a violation</p>\n<pre><code>int main()\n{\n    int tab[] = {1,2,3,4};\n    short* ps = (short*)(&amp;tab[0]);\n    short s = *ps;\n}\n</code></pre>\n", "Tags": "<c++><strict-aliasing>", "OwnerUserId": "2551229", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_27025553_27025662_0": {"section_id": 6046, "quality": 0.7741935483870968, "length": 24}}, "n3337": {"so_27025553_27025662_0": {"section_id": 5814, "quality": 0.9354838709677419, "length": 29}}, "n4659": {"so_27025553_27025662_0": {"section_id": 7545, "quality": 0.7419354838709677, "length": 23}}}, "27026009": {"ParentId": "27025553", "CommentCount": "2", "CreationDate": "2014-11-19T20:06:21.863", "OwnerUserId": "13422", "PostTypeId": "2", "Id": "27026009", "Score": "2", "Body": "<p>Of course that violates strict aliasing. The code is accessing values through a pointer of a different type, and it isn't <code>char*</code>.</p>\n<pre><code>int main()\n{\n    short tab[] = {1,2,3,4};\n    int* ps = (int*)(&amp;tab[0]);\n    *ps = 3;\n    if(tab[0] == 1) return 1;\n    return 0;\n}\n</code></pre>\n<p>The code is allowed to return 1 there. Because a write to *ps is a write to an <code>int</code> and according to strict aliasing rules an <code>int</code> pointer cannot possibly point to a <code>short</code>. Therefore the optimizer is allowed to see that the <code>tab</code> array is not modified, optimize out the <code>if</code> statement because it is always true, and rewrite the entire function to simply return 1.</p>\n", "LastActivityDate": "2014-11-19T20:06:21.863"}});