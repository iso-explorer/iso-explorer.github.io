post_cb({"9345146": {"CommentCount": "9", "ViewCount": "123", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-02-18T23:29:10.577", "LastActivityDate": "2012-02-19T00:33:01.163", "Title": "Is there anythig incorrect when using placement new on global vars?", "OwnerDisplayName": "user34537", "LastEditDate": "2017-05-23T11:56:41.650", "Id": "9345146", "Score": "1", "Body": "<p>I was playing with an idea where i can have variables in global scope but <a href=\"https://stackoverflow.com/questions/9344346/how-do-i-cancel-not-call-the-constructor-in-a-global-variable/9344459#comment11795868_9344459\">not construct them</a>. Note that there IS a placement new being ran. However i'd like to know what is undefined or incorrect about this code</p>\n<pre><code>#include &lt;new&gt;\n#include &lt;cstdio&gt;\n#include &lt;typeinfo&gt;\n\n//#define AlignAs alignas(T)\n#define AlignAs\n\ntemplate&lt;class T&gt;struct BlockOf {\n    AlignAs char t[sizeof(T)];\n    operator T&amp;() { return reinterpret_cast&lt;T&amp;&gt;(*this); }\n    ~BlockOf(){((T*)&amp;t)-&gt;~T(); }\n};\nstruct B{ \n    virtual void v(){} \n    ~B() { printf(\"B\\n\"); } \n};\nstruct A: B{ \n    A(){printf(\"a\\n\");} \n    int regularDots; \n    void v() { printf(\"A virtual\\n\"); } \n};\n\nBlockOf&lt;A&gt; _a;\nA&amp;a=_a;\n\nvoid init(){\n    new(&amp;a) A;\n}\n\nint main() {\n    init();\n    A aa;\n    a.regularDots=9;\n    printf(\"%s %s %d %d\\n\", \n        typeid(a).name(),\n        typeid(aa).name(),\n        typeid(a).hash_code()==typeid(aa).hash_code(),\n        sizeof(a) == sizeof(aa)\n        );\n    B *b = &amp;a;\n    b-&gt;v();\n}\n</code></pre>\n", "Tags": "<c++>", "AnswerCount": "1"}, "9345202": {"ParentId": "9345146", "CommentCount": "4", "Body": "<p>This isn't clear</p>\n<pre><code>operator T&amp;() { return *reinterpret_cast&lt;T*&gt;(this); }\n</code></pre>\n<p>Instead use</p>\n<pre><code>operator T&amp;() { return reinterpret_cast&lt;T&amp;&gt;(t[0]); }\n</code></pre>\n<p>I think that <code>this</code> is required to point at the first member, but using the array explicitly seems safer to me.</p>\n<hr>\n<p>To answer your main question, 3.8p8 contains the restrictions on reusing memory belonging to a variable with static storage duration, and since the original type has a trivial destructor, you should be ok.</p>\n<blockquote>\n<p id=\"so_9345146_9345202_0\">If a program ends the lifetime of an object of type <code>T</code> with static (3.7.1), thread (3.7.2), or automatic (3.7.3) storage duration and if <code>T</code> has a non-trivial destructor,\n  the program must ensure that an object of the original type occupies that same storage location when the implicit destructor call takes place; otherwise the behavior of the program is undefined.</p>\n</blockquote>\n</hr>", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "9345202", "Score": "1", "CreationDate": "2012-02-18T23:35:59.863", "LastActivityDate": "2012-02-18T23:35:59.863"}, "bq_ids": {"n4140": {"so_9345146_9345202_0": {"section_id": 7196, "quality": 0.90625, "length": 29}}, "n3337": {"so_9345146_9345202_0": {"section_id": 6940, "quality": 0.90625, "length": 29}}, "n4659": {"so_9345146_9345202_0": {"section_id": 8705, "quality": 0.90625, "length": 29}}}});