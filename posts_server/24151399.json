post_cb({"bq_ids": {"n4140": {"so_24151399_24151550_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3228}, "so_24151399_24151550_2": {"length": 30, "quality": 0.6382978723404256, "section_id": 6088}}, "n3337": {"so_24151399_24151550_1": {"length": 41, "quality": 0.9318181818181818, "section_id": 5855}, "so_24151399_24151550_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 3101}, "so_24151399_24151550_2": {"length": 43, "quality": 0.9148936170212766, "section_id": 5856}}, "n4659": {"so_24151399_24151550_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3985}, "so_24151399_24151550_2": {"length": 29, "quality": 0.6170212765957447, "section_id": 7584}}}, "24151399": {"ViewCount": "282", "Body": "<p>I am trying to avoid adding an explicit specialization for my class template for the case that the length of an array becomes 0. It turns out that <code>std::swap()</code> cannot handle it:</p>\n<pre><code>#include &lt;algorithm&gt;\n\nint main() {\n    int a[0], b[0];\n\n    std::swap(a, b);   // g++-4.8 compile error\n}\n</code></pre>\n<p>I thought that there should be some SFINAE in place to prevent such an error, no? Clearly, doing nothing is the right thing in this case.</p>\n<p>If the standard forces <code>std::swap()</code> to raise a compiler error, can I manually add a compile-time <code>if</code> that checks if a non-type template parameter <code>std::size_t N</code> is 0?</p>\n<p><em>Edit</em></p>\n<p>Indeed, <code>std::array&lt;T, 0&gt;</code> is a specialized template that avoids declaring a zero-size array. From <code>gcc-4.8.2/libstdc++-v3/include/std/array</code>:</p>\n<pre><code>template&lt;typename _Tp, std::size_t _Nm&gt;\n    struct __array_traits\n    {\n      typedef _Tp _Type[_Nm];\n\n      static constexpr _Tp&amp;\n      _S_ref(const _Type&amp; __t, std::size_t __n) noexcept\n      { return const_cast&lt;_Tp&amp;&gt;(__t[__n]); }\n    };\n\n template&lt;typename _Tp&gt;\n   struct __array_traits&lt;_Tp, 0&gt;\n   {\n     struct _Type { };\n\n     static constexpr _Tp&amp;\n     _S_ref(const _Type&amp;, std::size_t) noexcept\n     { return *static_cast&lt;_Tp*&gt;(nullptr); }\n   };\n</code></pre>\n", "AcceptedAnswerId": "24152076", "Title": "Compile error for std::swap() with zero-size arrays?", "CreationDate": "2014-06-10T21:47:22.447", "Id": "24151399", "CommentCount": "13", "LastEditDate": "2014-06-10T22:48:48.973", "PostTypeId": "1", "LastEditorUserId": "1209253", "LastActivityDate": "2014-06-10T22:48:48.973", "Score": "1", "OwnerUserId": "1209253", "Tags": "<c++><templates><c++11><std><sfinae>", "AnswerCount": "2"}, "24151550": {"Id": "24151550", "PostTypeId": "2", "Body": "<p>This is undefined behavior in C++ to define zero sized array.</p>\n<p>C++ Standard n3337 <strong>\u00a7</strong> 8.3.4/1 </p>\n<blockquote>\n<p id=\"so_24151399_24151550_0\">If the constant-expression (5.19) is present, it shall be an integral\n  constant expression and its value shall be greater than zero.</p>\n</blockquote>\n<p>It is valid however to create zero-sized array dynamically with <em>array new</em>: <code>new[]</code>:</p>\n<p>C++ Standard n3337 <strong>\u00a7</strong> 5.3.4/6</p>\n<blockquote>\n<p id=\"so_24151399_24151550_1\">Every constant-expression in a noptr-new-declarator shall be an\n  integral constant expression (5.19) and evaluate to a strictly\n  positive value. The expression in a noptr-new-declarator shall be of\n  integral type, unscoped enumeration type, or a class type for which a\n  single non-explicit conversion function to integral or unscoped\n  enumeration type exists (12.3). If the expression is of class type,\n  the expression is converted by calling that conversion function, and\n  the result of the conversion is used in place of the original\n  expression.</p>\n</blockquote>\n<p>C++ Standard n3337 <strong>\u00a7</strong> 5.3.4/7</p>\n<blockquote>\n<p id=\"so_24151399_24151550_2\"><strong>When the value of the expression in a noptr-new-declarator is zero</strong>,\n  <strong>the allocation function is called to allocate an array with no\n  elements.</strong> If the value of that expression is less than zero or such\n  that the size of the allocated object would exceed the\n  implementation-defined limit, or if the new-initializer is a braced-\n  init-list for which the number of initializer-clauses exceeds the\n  number of elements to initialize, no storage is obtained and the\n  new-expression terminates by throwing an exception of a type that\n  would match a handler (15.3) of type std::bad_array_new_length\n  (18.6.2.2).</p>\n</blockquote>\n", "LastEditorUserId": "1141471", "LastActivityDate": "2014-06-10T22:24:15.053", "Score": "3", "CreationDate": "2014-06-10T21:59:07.647", "ParentId": "24151399", "CommentCount": "2", "OwnerUserId": "1141471", "LastEditDate": "2014-06-10T22:24:15.053"}, "24152076": {"Id": "24152076", "PostTypeId": "2", "Body": "<p><em>Disclaimer:</em> It's already been explained that C++ doesn't allow zero-length arrays, so creating/swapping them is undefined behavior. Zero-length arrays are supported by gcc as an extension. <strong>So everything that follows may only apply to gcc, and no other compiler.</strong></p>\n<hr>\n<p>The compilation error says nothing about arrays of zero-length. There are warnings about them if you enable <code>-pedantic</code> but they're not rejected outright. Instead the compiler is complaining about an invalid assignment. The reason for that is quite interesting.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/algorithm/swap\" rel=\"nofollow\"><code>std::swap</code></a> has an overload for array types. However, because a zero-length array is not considered a valid array type, this overload is not the one selected when you pass in a zero-length array. This can be demonstrated with the following code:</p>\n<pre><code>template&lt;typename T, std::size_t N&gt;\nvoid foo(T const (&amp;)[N])\n{\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n}\n\ntemplate&lt;typename T&gt;\nvoid foo(T const&amp;)\n{\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Pass a non-zero length array to <code>foo</code> and the output is </p>\n<pre><code>void foo(const T (&amp;)[N]) [with T = int; long unsigned int N = 10ul]\n</code></pre>\n<p>Now pass a zero-length array to <code>foo</code> and the output changes</p>\n<pre><code>void foo(const T&amp;) [with T = int [0]]\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/5530318b6a7ce101\" rel=\"nofollow\">Live demo</a></p>\n<hr>\n<p>Now, back to the reason for the error. The <code>std::swap</code> implementation for non-arrays will move/copy one argument to a local variable, then the second argument to the first, and finally the local variable to the second argument. It is this series of move/copy initialization and assignments that goes wrong.</p>\n<pre><code>T temp = move(arg1);\narg2 = move(arg2);\narg1 = move(temp);\n</code></pre>\n<p>None of the above statements are valid when <code>T=int[0]</code>, hence the error.</p>\n<hr>\n<p>The easiest way to work around this problem is to <strong>use <code>std::array</code></strong>. It has special support for zero-length arrays and swapping them will work correctly.</p>\n<p>Otherwise, if you want to continue to rely on the non-portable gcc extension, I'd make a wrapper for <code>swap</code> that has an overload accepting zero-length arrays. The wrapper would call <code>std::swap</code> in all other cases.</p>\n<pre><code>template&lt;typename T&gt;\nvoid my_swap(T&amp; arg1, T&amp; arg2)\n{\n    using std::swap;\n    swap(arg1, arg2);\n}\n\ntemplate&lt;typename T, std::size_t N&gt;\nvoid my_swap(T (&amp;arg1)[N], T (&amp;arg2)[N])\n{\n    using std::swap;\n    swap(arg1, arg2);\n}\n\ntemplate&lt;typename T&gt;\nvoid my_swap(T (&amp;)[0], T (&amp;)[0])\n{\n    // do nothing\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/341e24daab7e8e01\" rel=\"nofollow\">Live demo</a></p>\n</hr></hr></hr>", "LastActivityDate": "2014-06-10T22:47:01.043", "CommentCount": "3", "CreationDate": "2014-06-10T22:47:01.043", "ParentId": "24151399", "Score": "1", "OwnerUserId": "241631"}});