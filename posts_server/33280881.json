post_cb({"33281202": {"Id": "33281202", "PostTypeId": "2", "Body": "<p>Yes. <code>int * volatile</code>.</p>\n<p>In C++, keywords according to type/pointer/reference go after the token, like <code>int * const</code> is constant pointer to integer, <code>int const *</code> is pointer to constant integer, <code>int const * const</code> is constant pointer to constant integer e.t.c. You can write keyword before the type only if it's for the first token: <code>const int x</code> is equal to <code>int const x</code>.</p>\n", "LastActivityDate": "2015-10-22T12:35:54.477", "CommentCount": "0", "CreationDate": "2015-10-22T12:35:54.477", "ParentId": "33280881", "Score": "2", "OwnerUserId": "4324545"}, "33281182": {"Id": "33281182", "PostTypeId": "2", "Body": "<p>Yes, you can of course have a volatile pointer.</p>\n<p>Volatile means none more and none less than that every access on the volatile object (of whatever type) is treated as a visible side-effect, and is therefore exempted from optimization (in particular, this means that accesses may not be reordered or collapsed or optimized out alltogether). That's true for reading or writing a value, for calling member functions, and of course for dereferencing, too.  </p>\n<p>Note that when the previous paragraph says \"reordering\", a <em>single thread of execution</em> is assumed. Volatile is no substitute for atomic operations or mutexes/locks.</p>\n<p>In more simple words, <code>volatile</code> generally translates to roughly \"Don't optimize, just do exactly as I say\".</p>\n<p>In the context of a <em>pointer</em>, refer to the exemplary usage pattern given by Chris Lattner's well-known \"What every programmer needs to know about Undefined Behavior\" <a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html\">article</a> (yes, that article is about C, not C++, but the same applies):</p>\n<blockquote>\n<p id=\"so_33280881_33281182_0\">If you're using an LLVM-based compiler, you can dereference a \"volatile\" null pointer to get a crash if that's what you're looking for, since volatile loads and stores are generally not touched by the optimizer.</p>\n</blockquote>\n", "LastActivityDate": "2015-10-22T12:34:54.533", "CommentCount": "0", "CreationDate": "2015-10-22T12:34:54.533", "ParentId": "33280881", "Score": "11", "OwnerUserId": "572743"}, "33280881": {"ViewCount": "5682", "Body": "<p>Consider the following code:</p>\n<pre><code>int square(volatile int *p)\n{\n    return *p * *p;\n}\n</code></pre>\n<p>Now, the <code>volatile</code> keyword indicates that the value in a\nmemory location can be altered in ways unknown to the compiler or have\nother unknown side effects (e.g. modification via a signal interrupt,\nhardware register, or memory mapped I/O) even though nothing in the\nprogram code modifies the contents.</p>\n<p>So what exactly happens when we declare a pointer as volatile?</p>\n<p>Will the above mentioned code always work, or is it any different from this:</p>\n<pre><code>int square(volatile int *p)\n{\n    int a = *p;\n    int b = *p\n    return a*b;\n}\n</code></pre>\n<p>Can we end up multiplying different numbers, as pointers are volatile?</p>\n<p>Or is there better way to do so?</p>\n", "AcceptedAnswerId": "33281653", "Title": "Can a pointer be volatile?", "CreationDate": "2015-10-22T12:18:34.957", "Id": "33280881", "CommentCount": "6", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2015-10-22T21:24:55.227", "LastEditorUserId": "63550", "LastActivityDate": "2015-10-22T22:13:33.460", "Score": "21", "OwnerUserId": "3483291", "Tags": "<c++><pointers><volatile>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_33280881_33281221_0": {"length": 37, "quality": 0.925, "section_id": 5436}}, "n3337": {"so_33280881_33281221_0": {"length": 25, "quality": 0.625, "section_id": 5231}}, "n4659": {"so_33280881_33281221_0": {"length": 37, "quality": 0.925, "section_id": 6863}}}, "33281221": {"Id": "33281221", "PostTypeId": "2", "Body": "<p>The <code>volatile</code> keyword is a hint for the compiler (7.1.6.1/7):</p>\n<blockquote>\n<p id=\"so_33280881_33281221_0\">Note:\n  volatile\n  is a hint to the implementation to avoid aggressive optimization involving the object\n  because the value of the object might be changed by means undetectable by an implementation. Furthermore,\n  for some implementations,\n  volatile\n  might indicate that special hardware instructions are required to access\n  the object. See\n   1.9\n   for detailed semantics. In general, the semantics of\n  volatile\n  are intended to be the\n  same in C\n  ++\n  as they are in C.\n  \u2014 end note\n  ]</p>\n</blockquote>\n<p>What does it mean? Well, take a look at this code:</p>\n<pre><code>bool condition = false;\nwhile(!condition)\n{\n    ...\n}\n</code></pre>\n<p>by default, the compiler will easilly optimize the condition out (it doesn't change, so there is no need to check it at every iteration). If you, however, declare the condition as <code>volatile</code>, the optimization will not be made.</p>\n<p>So of course you can have a volatile pointer, and it is possible to write code that will crash because of it, but the fact that a variable is <code>volative</code> doesn't mean that it is necessarily going to be changed due to some external interference.</p>\n", "LastActivityDate": "2015-10-22T12:36:41.550", "CommentCount": "2", "CreationDate": "2015-10-22T12:36:41.550", "ParentId": "33280881", "Score": "2", "OwnerUserId": "1490355"}, "33281653": {"Id": "33281653", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_33280881_33281653_0\">Can a pointer be <code>volatile</code>?</p>\n</blockquote>\n<p>Absolutely; any type, excluding function and references, may be <code>volatile</code>-qualified.</p>\n<p>Note that a volatile pointer is declared <strong><code>T *volatile</code></strong>, not <code>volatile T*</code>, which instead declares a <strong>pointer-<em>to</em>-volatile</strong>.</p>\n<p>A volatile pointer means that the pointer value, that is its address and not the value pointed to by, may have side-effects that are not visible to the compiler when it's accessed; therefore, optimizations deriving from the \"as-if rule\" may not be taken into account for those accesses.</p>\n<hr>\n<blockquote>\n<p id=\"so_33280881_33281653_1\"><code>int square(volatile int *p) { return *p * *p; }</code></p>\n</blockquote>\n<p>The compiler cannot assume that reading <code>*p</code> fetches the same value, so caching its value in a variable is not allowed. As you say, the result may vary and not be the square of <code>*p</code>.</p>\n<p>Concrete example: let's say you have two arrays of <code>int</code>s</p>\n<pre><code>int a1 [] = { 1, 2, 3, 4, 5 };\nint a2 [] = { 5453, -231, -454123, 7565, -11111 };\n</code></pre>\n<p>and a pointer to one of them</p>\n<pre><code>int * /*volatile*/ p = a1;\n</code></pre>\n<p>with some operation on the pointed elements</p>\n<pre><code>for (int i = 0; i &lt; sizeof(a1)/sizeof(a1[0]); ++i) \n       *(p + i) *= 2;\n</code></pre>\n<p>here <code>p</code> has to be read each iteration if you make it <code>volatile</code> because, perhaps, it may actually point to <code>a2</code> due to external events.</p>\n</hr>", "LastEditorUserId": "2692339", "LastActivityDate": "2015-10-22T22:13:33.460", "Score": "10", "CreationDate": "2015-10-22T12:59:07.460", "ParentId": "33280881", "CommentCount": "6", "OwnerUserId": "2692339", "LastEditDate": "2015-10-22T22:13:33.460"}, "33281194": {"Id": "33281194", "PostTypeId": "2", "Body": "<p>You may be end up multiplying different numbers because it's volatile and could be changed unexpectedly. So, you can try something like this:</p>\n<pre><code>int square(volatile int *p)\n{\nint a = *p;\nreturn a*a;\n}\n</code></pre>\n", "OwnerDisplayName": "user5473178", "LastActivityDate": "2015-10-22T12:35:30.273", "Score": "1", "CreationDate": "2015-10-22T12:35:30.273", "ParentId": "33280881", "CommentCount": "0"}, "33281476": {"Id": "33281476", "PostTypeId": "2", "Body": "<p>Yes, a pointer can be volatile if the variable that it points to can change unexpectedly even though how this might happen is not evident from the code.</p>\n<p>An example is an object that can be modified by something that is external to the controlling thread and that the compiler should not optimize. </p>\n<p>The most likely place to use the volatile specifier is in low-level code that deals directly with the hardware and where unexpected changes might occur.</p>\n", "LastEditorUserId": "4411577", "LastActivityDate": "2015-10-22T13:00:40.087", "Score": "1", "CreationDate": "2015-10-22T12:50:21.470", "ParentId": "33280881", "CommentCount": "1", "OwnerUserId": "4411577", "LastEditDate": "2015-10-22T13:00:40.087"}});