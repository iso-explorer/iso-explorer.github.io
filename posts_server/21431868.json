post_cb({"21431949": {"ParentId": "21431868", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is because <code>0</code> is a <em>null pointer constant</em> and can be converted to <em>unsigned long</em> or a pointer and therefore it is ambiguous which to choose. The draft C++ standard section <code>4.10</code> <em>Pointer conversions</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_21431868_21431949_0\">A null pointer constant is an integral constant expression (5.19) prvalue of integer type that evaluates to zero or a prvalue of type std::nullptr_t. <strong>A null pointer constant can be converted to a pointer type; the result is the null pointer value</strong> of that type and is distinguishable from every other value of object pointer or function pointer type.</p>\n</blockquote>\n<p>While <code>1</code> is not a <em>null pointer constant</em>. Although <code>0UL</code> can be converted to a pointer as well it is a better match for the <em>unsigned long</em> constructor since no conversion is needed.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-01-29T13:23:48.900", "Id": "21431949", "Score": "4", "CreationDate": "2014-01-29T13:04:02.587", "LastActivityDate": "2014-01-29T13:23:48.900"}, "bq_ids": {"n4140": {"so_21431868_21431949_0": {"section_id": 39, "quality": 0.75, "length": 27}}, "n3337": {"so_21431868_21431949_0": {"section_id": 36, "quality": 0.9166666666666666, "length": 33}}, "n4659": {"so_21431868_21431949_0": {"section_id": 39, "quality": 0.75, "length": 27}}}, "21432022": {"ParentId": "21431868", "CommentCount": "0", "Body": "<p>A literal <code>0</code> is often used to initialise a pointer to null (modern C++ should admittedly be using <code>nullptr</code> instead). However, it is comparatively uncommon to initialise pointers directly with any other integer literal (except in e.g. embedded systems which use memory mapping).</p>\n<p>As such, the compiler is treating <code>0</code> as though it could be a pointer or an integer, meaning it could call either constructor. In contrast, it treats <code>1</code> simply as an integer.</p>\n", "OwnerUserId": "2500951", "PostTypeId": "2", "Id": "21432022", "Score": "0", "CreationDate": "2014-01-29T13:07:10.393", "LastActivityDate": "2014-01-29T13:07:10.393"}, "21431868": {"CommentCount": "1", "ViewCount": "106", "PostTypeId": "1", "LastEditorUserId": "3073460", "CreationDate": "2014-01-29T12:59:56.527", "LastActivityDate": "2014-02-07T10:42:54.210", "Title": "automatic integer conversion of a 0 value fails", "AcceptedAnswerId": "21431949", "LastEditDate": "2014-02-07T10:42:54.210", "Id": "21431868", "Score": "2", "Body": "<p>I have this source file:</p>\n<pre><code>#include &lt;ctime&gt;\n\nclass A\n{\n  public:\n    A(unsigned long i){};\n    A(const tm*){};\n};\n\nint main(int argc, char** argv)\n{\n  A tit(1);\n  A tat(0);\n  return 0;\n}\n</code></pre>\n<p>When I compile this using gcc 3.4.2 I get the following:</p>\n<blockquote>\n<p id=\"so_21431868_21431868_0\">autoCast.cpp: In function <code>int main(int, char**)':<br>\n  autoCast.cpp:13: error: call of overloaded</br></code>A(int)' is ambiguous<br>\n  autoCast.cpp:4: note: candidates are: A::A(const A&amp;)<br>\n  autoCast.cpp:7: note:                 A::A(const tm*)<br>\n  autoCast.cpp:6: note:                 A::A(long unsigned int)  </br></br></br></p>\n</blockquote>\n<p>My question is: why does the creation of <code>A tit(1)</code> (line 12) succeed while <code>A tat(0)</code> (line 13) fails? I tried different argument types in those lines (e.g. 0ULL and 1ULL) but it always fails when the argument value is 0, while it succeeds when the argument value is 1. The only 0 value for which no error is raised is 0UL (because no conversion is needed I guess). Why in this case does an integer with value 0 get different treatment from an integer with value 1? Does it have to do with the tm struct defined in time.h?</p>\n", "Tags": "<c++><integer><implicit-conversion>", "OwnerUserId": "3073460", "AnswerCount": "2"}});