post_cb({"12843893": {"CommentCount": "1", "ViewCount": "182", "PostTypeId": "1", "ClosedDate": "2012-10-11T16:29:28.033", "LastEditorUserId": "-1", "CreationDate": "2012-10-11T16:06:33.723", "LastActivityDate": "2012-10-11T16:14:15.387", "LastEditDate": "2017-05-23T11:56:17.980", "FavoriteCount": "2", "Title": "Is it OK to specify a duplicate C++ class scope?", "Id": "12843893", "Score": "9", "Body": "<blockquote>\n<p id=\"so_12843893_12843893_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/12135498/why-are-redundant-scope-qualifications-supported-by-the-compiler-and-is-it-lega\">Why are redundant scope qualifications supported by the compiler, and is it legal?</a> </br></p>\n</blockquote>\n<p>I wouldn't expect this to compile but it does. Could this be a compiler bug, or does it have some correct meaning?</p>\n<pre><code>$ g++ -c scopes.cpp\n$ cat scopes.cpp\nclass Log {\npublic:\n    Log() { }\n    static void fn() { }\n};\n\nvoid test() {\n    Log::Log::Log::Log::Log::Log::fn();\n}\n\n$ g++ --version\ng++ (Ubuntu 4.4.3-4ubuntu5.1) 4.4.3\n</code></pre>\n", "Tags": "<c++><g++>", "OwnerUserId": "1623317", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_12843893_12844039_1": {"section_id": 7114, "quality": 0.7307692307692307, "length": 19}, "so_12843893_12844039_0": {"section_id": 5846, "quality": 0.9, "length": 18}}, "n3337": {"so_12843893_12844039_1": {"section_id": 6858, "quality": 0.7307692307692307, "length": 19}, "so_12843893_12844039_0": {"section_id": 5616, "quality": 0.9, "length": 18}}, "n4659": {"so_12843893_12844039_0": {"section_id": 7325, "quality": 0.9, "length": 18}, "so_12843893_12844039_1": {"section_id": 8615, "quality": 0.7307692307692307, "length": 19}}}, "12844039": {"ParentId": "12843893", "CommentCount": "5", "Body": "<p>Yes, it's legal.  A class's name is inserted into its own namespace, which is called the <em>injected-class-name</em>.  From C++03 \u00a79/2:</p>\n<blockquote>\n<p id=\"so_12843893_12844039_0\">[...] The <em>class-name</em> is also inserted into the scope of the class itself; this is known as the <em>injected-class-name</em>.\n  For purposes of access checking, the <em>injected-class-name</em> is treated as if it were a public member name.</p>\n</blockquote>\n<p>Note that <code>Log::Log</code> names the class constructor, which is only allowed in certain contexts, but as long as you end the chain of <code>Log::Log::...</code> with something other than <code>Log</code> (such as <code>fn</code>), then it doesn't name the constructor.  Specifically, \u00a73.4.3.1/1a says:</p>\n<blockquote>\n<p id=\"so_12843893_12844039_1\">If the <em>nested-name-specifier</em> nominates a class <code>C</code>, and the name specified after the <em>nested-name-specifier</em>,\n  when looked up in <code>C</code>, is the injected-class-name of <code>C</code> (clause 9), the name is instead considered to name the\n  constructor of class <code>C</code>. Such a constructor name shall be used only in the <em>declarator-id</em> of a constructor definition\n  that appears outside of the class definition.</p>\n</blockquote>\n", "OwnerUserId": "9530", "PostTypeId": "2", "Id": "12844039", "Score": "9", "CreationDate": "2012-10-11T16:14:15.387", "LastActivityDate": "2012-10-11T16:14:15.387"}});