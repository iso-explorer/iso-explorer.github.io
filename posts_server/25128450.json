post_cb({"bq_ids": {"n4140": {"so_25128450_25128825_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 292}}, "n3337": {"so_25128450_25128825_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 283}}, "n4659": {"so_25128450_25128825_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 299}}}, "25128450": {"ViewCount": "540", "Body": "<p>I'm working on some shorthand functional programming methods to aid in data analysis in C++ and I ran into a situation where I feel like my implmentation should work but g++ disagrees with me. See the following code:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;valarray&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n//generates a list of [from,to] in increments of step. last is &lt;= to with precision of step\ntemplate&lt;typename T&gt; std::valarray&lt;T&gt; range(T from, T to, T step = 1) {\n    size_t elems = (size_t)floor((to-from)/step) + 1;\n    std::valarray&lt;T&gt; result(elems);\n    for (int i = 0; i &lt; elems; i++) {\n        result[i] = from+step*i;\n    }\n    return result;\n}\n\n//map over multiple lists as arguments to the provided function\ntemplate&lt;typename T, typename... Ts&gt; void mapthreadv(std::function&lt;void(T,Ts...)&gt; func, std::valarray&lt;T&gt; &amp;in, std::valarray&lt;Ts&gt;&amp;... rest) {\n    for (int i = 0; i &lt; in.size(); i++) {\n        func(in[i],rest[i]...);\n    }\n}\n\nint main(int argc, char **argv) {  \n    auto first = range(0.0,1.0,0.1);\n    auto second = range(0.0,10.0,1.0);\n    auto third = range(0.0,100.0,10.0);\n    mapthreadv&lt;double,double,double&gt;([](double a, double b, double c) { cout &lt;&lt; '{' &lt;&lt; a &lt;&lt; ',' &lt;&lt; b &lt;&lt; ',' &lt;&lt; c &lt;&lt; \"},\"; },first,second,third);\n}   \n</code></pre>\n<p>Expected output would be: </p>\n<pre><code>{0,0,0},{0.1,1,10},{0.2,2,20},{0.3,3,30},{0.4,4,40},{0.5,5,50},{0.6,6,60},{0.7,7,70},{0.8,8,80},{0.9,9,90},{1,10,100},\n</code></pre>\n<p>Which is achievable by directly specifying <code>&lt;void(double,double,double)&gt;</code> instead of <code>&lt;void(T,Ts...)&gt;</code> to <code>std::function</code>, however this is obviously not a useful fix. The code fails to compile as written, and the error is related to template argument deduction/substitution:</p>\n<pre><code>\u2018main(int, char**)::&lt;lambda(double, double, double)&gt;\u2019 is not derived from \u2018std::function&lt;void(double, Ts ...)&gt;\u2019\n</code></pre>\n<p>So my gut feeling is that for some reason Ts is not being expanded... any pointers or obvious oversights on my part? I'm quite new to template functions in general so any help is appreciated.</p>\n", "AcceptedAnswerId": "25128825", "Title": "Expand parameter pack in std::function template", "CreationDate": "2014-08-04T22:16:36.860", "Id": "25128450", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-08-04T23:44:58.280", "LastEditorUserId": "3908286", "LastActivityDate": "2014-08-04T23:44:58.280", "Score": "2", "OwnerUserId": "3908286", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "25128825": {"Id": "25128825", "PostTypeId": "2", "Body": "<p>The problem is that template argument deduction is still performed when you use a template parameter pack, even if you explicitly specify the types (\u00a7 14.8.1 [temp.arg.explicit]/p9):</p>\n<blockquote>\n<p id=\"so_25128450_25128825_0\">Template argument deduction can extend the sequence of template\n  arguments corresponding to a template parameter pack, even when the\n  sequence contains explicitly specified template arguments. [\n  <em>Example</em>:</p>\n<pre><code>template&lt;class ... Types&gt; void f(Types ... values);\nvoid g() {\n    f&lt;int*, float*&gt;(0, 0, 0);\n}\n// Types is deduced to the sequence int*, float*, int\n</code></pre>\n<p id=\"so_25128450_25128825_1\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>And, since a lambda closure type is not a <code>std::function</code>, template argument deduction will fail.</p>\n<p>There is no reason to use <code>std::function</code> here anyway; you can simply take the functor as a template parameter:</p>\n<pre><code>template&lt;typename F, typename T, typename... Ts&gt; void mapthreadv(F func, std::valarray&lt;T&gt; &amp;in, std::valarray&lt;Ts&gt;&amp;... rest) {\n    for (int i = 0; i &lt; in.size(); i++) {\n        func(in[i],rest[i]...);\n    }\n}\n</code></pre>\n<p>which also obviates the need to explicitly specify template arguments:</p>\n<pre><code>mapthreadv([](double a, double b, double c) { std::cout &lt;&lt; '{' &lt;&lt; a &lt;&lt; ',' &lt;&lt; b &lt;&lt; ',' &lt;&lt; c &lt;&lt; \"},\"; },first,second,third);\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/ddb8830706b8f0a3\" rel=\"nofollow\">Demo</a>.</p>\n", "LastActivityDate": "2014-08-04T22:57:12.520", "CommentCount": "4", "CreationDate": "2014-08-04T22:57:12.520", "ParentId": "25128450", "Score": "2", "OwnerUserId": "2756719"}});