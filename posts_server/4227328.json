post_cb({"4227328": {"CommentCount": "2", "CreationDate": "2010-11-19T16:50:12.597", "PostTypeId": "1", "AcceptedAnswerId": "4227337", "LastEditorUserId": "241536", "LastActivityDate": "2010-11-20T15:56:15.090", "LastEditDate": "2010-11-20T15:39:58.143", "ViewCount": "7237", "FavoriteCount": "3", "Title": "FAQ: Why does dynamic_cast only work if a class has at least 1 virtual method?", "Id": "4227328", "Score": "14", "Body": "<p>This does not compile in C++:</p>\n<pre><code>class A\n{\n};\n\nclass B : public A\n{\n};\n\n...\n\nA *a = new B();\nB *b = dynamic_cast&lt;B*&gt;(a);\n</code></pre>\n", "Tags": "<c++><dynamic-cast><c++-faq>", "OwnerUserId": "21704", "AnswerCount": "3"}, "4227378": {"ParentId": "4227328", "CommentCount": "0", "Body": "<p>From 5.2.7 (Dynamic cast) :</p>\n<blockquote>\n<p id=\"so_4227328_4227378_0\">The result of the expression\n  <code>dynamic_cast&lt;T&gt;(v)</code> is the result of\n  converting the expression v to type T.</p>\n<p id=\"so_4227328_4227378_1\">[ ... multiple lines which refer to other cases ... ]</p>\n<p id=\"so_4227328_4227378_2\">Otherwise v shall be a\n  pointer to or an lvalue of a\n  polymorphic type (10.3).</p>\n</blockquote>\n<p>From 10.3 (Virtual functions) :</p>\n<blockquote>\n<p id=\"so_4227328_4227378_3\">A class that declares or inherits a\n  virtual function is called a\n  polymorphic class.</p>\n</blockquote>\n", "OwnerUserId": "451980", "PostTypeId": "2", "Id": "4227378", "Score": "8", "CreationDate": "2010-11-19T16:55:15.123", "LastActivityDate": "2010-11-19T16:55:15.123"}, "4227337": {"ParentId": "4227328", "LastEditDate": "2017-05-23T11:46:36.667", "CommentCount": "16", "CreationDate": "2010-11-19T16:51:21.757", "OwnerUserId": "241536", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "4227337", "Score": "25", "Body": "<p>Because <code>dynamic_cast</code> can only downcast polymorphic types, so sayeth the Standard.</p>\n<p>You can make your class polymoprphic by adding a <code>virtual</code> destructor to the base class.  In fact, you probably should anyway (See Footnote).  Else if you try to delete a <code>B</code> object through an <code>A</code> pointer, you'll evoke <a href=\"https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior\">Undefined Behavior</a>.</p>\n<pre><code>class A\n{\npublic:\n  virtual ~A() {};\n};\n</code></pre>\n<p>et voila!</p>\n<h2>Footnote</h2>\n<p>There are exceptions to the \"rule\" about needing a virtual destructor in polymorphic types.<br>\nOne such exception is when using <code>boost::shared_ptr</code> as pointed out by Steve Jessop in the comments below.  For more information about when you need a virtual destructor, read this <a href=\"http://www.gotw.ca/publications/mill18.htm\" rel=\"nofollow noreferrer\">Herb Sutter</a> article.</br></p>\n", "LastActivityDate": "2010-11-20T15:56:15.090"}, "bq_ids": {"n4140": {"so_4227328_4227378_2": {"section_id": 6016, "quality": 0.6666666666666666, "length": 4}, "so_4227328_4227378_0": {"section_id": 6011, "quality": 0.875, "length": 7}, "so_4227328_4227378_3": {"section_id": 7002, "quality": 0.875, "length": 7}}, "n3337": {"so_4227328_4227378_2": {"section_id": 5784, "quality": 0.8333333333333334, "length": 5}, "so_4227328_4227378_0": {"section_id": 5779, "quality": 0.875, "length": 7}, "so_4227328_4227378_3": {"section_id": 6748, "quality": 0.875, "length": 7}}, "n4659": {"so_4227328_4227378_2": {"section_id": 7515, "quality": 0.6666666666666666, "length": 4}, "so_4227328_4227378_0": {"section_id": 7510, "quality": 0.875, "length": 7}, "so_4227328_4227378_3": {"section_id": 8499, "quality": 0.875, "length": 7}}}, "4227691": {"ParentId": "4227328", "CommentCount": "1", "Body": "<p>As the other stated: The standard says so.</p>\n<p>So why does the standard says so?</p>\n<p>Because if the type isn't polymorphic it may (or is? Question to the standard gurus) be a plain type. And for plain types there are many assumptions coming from the C backwards compatibility.\nOne of those is that the type only consists of it's members as the developer declared + necessary alignment bytes. So there cannot be any extra (hidden) fields.\nSo there is no way to store in the memory space conserved by A the information that it really is a B.</p>\n<p>This is only possible when it is polymorphic as then it is allowed to add such hidden stuff.\n(In most implementations this is done via the vtable).</p>\n", "OwnerUserId": "44086", "PostTypeId": "2", "Id": "4227691", "Score": "8", "CreationDate": "2010-11-19T17:29:12.417", "LastActivityDate": "2010-11-19T17:29:12.417"}});