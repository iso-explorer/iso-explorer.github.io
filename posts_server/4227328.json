post_cb({"bq_ids": {"n4140": {"so_4227328_4227378_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 6016}, "so_4227328_4227378_3": {"length": 8, "quality": 1.0, "section_id": 7002}, "so_4227328_4227378_0": {"length": 7, "quality": 0.875, "section_id": 6011}}, "n3337": {"so_4227328_4227378_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 5784}, "so_4227328_4227378_3": {"length": 8, "quality": 1.0, "section_id": 6748}, "so_4227328_4227378_0": {"length": 7, "quality": 0.875, "section_id": 5779}}, "n4659": {"so_4227328_4227378_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 7515}, "so_4227328_4227378_3": {"length": 8, "quality": 1.0, "section_id": 8499}, "so_4227328_4227378_0": {"length": 7, "quality": 0.875, "section_id": 7510}}}, "4227378": {"Id": "4227378", "PostTypeId": "2", "Body": "<p>From 5.2.7 (Dynamic cast) :</p>\n<blockquote>\n<p id=\"so_4227328_4227378_0\">The result of the expression\n  <code>dynamic_cast&lt;T&gt;(v)</code> is the result of\n  converting the expression v to type T.</p>\n<p id=\"so_4227328_4227378_1\">[ ... multiple lines which refer to other cases ... ]</p>\n<p id=\"so_4227328_4227378_2\">Otherwise v shall be a\n  pointer to or an lvalue of a\n  polymorphic type (10.3).</p>\n</blockquote>\n<p>From 10.3 (Virtual functions) :</p>\n<blockquote>\n<p id=\"so_4227328_4227378_3\">A class that declares or inherits a\n  virtual function is called a\n  polymorphic class.</p>\n</blockquote>\n", "LastActivityDate": "2010-11-19T16:55:15.123", "CommentCount": "0", "CreationDate": "2010-11-19T16:55:15.123", "ParentId": "4227328", "Score": "8", "OwnerUserId": "451980"}, "4227691": {"Id": "4227691", "PostTypeId": "2", "Body": "<p>As the other stated: The standard says so.</p>\n<p>So why does the standard says so?</p>\n<p>Because if the type isn't polymorphic it may (or is? Question to the standard gurus) be a plain type. And for plain types there are many assumptions coming from the C backwards compatibility.\nOne of those is that the type only consists of it's members as the developer declared + necessary alignment bytes. So there cannot be any extra (hidden) fields.\nSo there is no way to store in the memory space conserved by A the information that it really is a B.</p>\n<p>This is only possible when it is polymorphic as then it is allowed to add such hidden stuff.\n(In most implementations this is done via the vtable).</p>\n", "LastActivityDate": "2010-11-19T17:29:12.417", "CommentCount": "1", "CreationDate": "2010-11-19T17:29:12.417", "ParentId": "4227328", "Score": "8", "OwnerUserId": "44086"}, "4227328": {"ViewCount": "7237", "Body": "<p>This does not compile in C++:</p>\n<pre><code>class A\n{\n};\n\nclass B : public A\n{\n};\n\n...\n\nA *a = new B();\nB *b = dynamic_cast&lt;B*&gt;(a);\n</code></pre>\n", "AcceptedAnswerId": "4227337", "Title": "FAQ: Why does dynamic_cast only work if a class has at least 1 virtual method?", "CreationDate": "2010-11-19T16:50:12.597", "Id": "4227328", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2010-11-20T15:39:58.143", "LastEditorUserId": "241536", "LastActivityDate": "2010-11-20T15:56:15.090", "Score": "14", "OwnerUserId": "21704", "Tags": "<c++><dynamic-cast><c++-faq>", "AnswerCount": "3"}, "4227337": {"Id": "4227337", "PostTypeId": "2", "Body": "<p>Because <code>dynamic_cast</code> can only downcast polymorphic types, so sayeth the Standard.</p>\n<p>You can make your class polymoprphic by adding a <code>virtual</code> destructor to the base class.  In fact, you probably should anyway (See Footnote).  Else if you try to delete a <code>B</code> object through an <code>A</code> pointer, you'll evoke <a href=\"https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior\">Undefined Behavior</a>.</p>\n<pre><code>class A\n{\npublic:\n  virtual ~A() {};\n};\n</code></pre>\n<p>et voila!</p>\n<h2>Footnote</h2>\n<p>There are exceptions to the \"rule\" about needing a virtual destructor in polymorphic types.<br>\nOne such exception is when using <code>boost::shared_ptr</code> as pointed out by Steve Jessop in the comments below.  For more information about when you need a virtual destructor, read this <a href=\"http://www.gotw.ca/publications/mill18.htm\" rel=\"nofollow noreferrer\">Herb Sutter</a> article.</br></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-11-20T15:56:15.090", "Score": "25", "CreationDate": "2010-11-19T16:51:21.757", "ParentId": "4227328", "CommentCount": "16", "OwnerUserId": "241536", "LastEditDate": "2017-05-23T11:46:36.667"}});