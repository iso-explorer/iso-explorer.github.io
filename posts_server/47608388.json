post_cb({"47608388": {"CommentCount": "9", "ViewCount": "105", "PostTypeId": "1", "LastEditorUserId": "7703564", "CreationDate": "2017-12-02T13:28:07.570", "LastActivityDate": "2017-12-02T17:48:10.657", "Title": "overloading std::initializer_list confusion", "LastEditDate": "2017-12-02T17:48:10.657", "Id": "47608388", "Score": "5", "Body": "<p>I always thought that when I use initializer list C++ syntax like:\nsomething({ ... });\nit's always clear to compiler that I want to call std::initializer_list overloaded version, but... it seems it's not so clear for MSVC 2015 :/</p>\n<p>I tested this simple code:</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;initializer_list&gt;\n\nnamespace testing {\n  template&lt;typename T&gt;\n  struct Test {\n    Test() {\n      printf(\"Test::Test()\\n\");\n    }\n\n    explicit Test(size_t count) {\n      printf(\"Test::Test(int)\\n\");\n    }\n\n    Test(std::initializer_list&lt;T&gt; init) {\n      printf(\"Test::Test(std::initializer_list)\\n\");\n    }\n\n    T* member;\n  };\n\n  struct IntSimilar {\n    int val;\n\n    IntSimilar() : val(0) {}\n    IntSimilar(int v) : val(v) {}\n\n    operator int() {\n      return val;\n    }\n  };\n}\n\nint main() {\n    testing::Test&lt;testing::IntSimilar&gt; obj({ 10 });\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://%20ideone.com/fj4NvT\" rel=\"nofollow noreferrer\" title=\"Run\">Run</a></p>\n<p>and in gcc6.3 it works as expected: Test::Test(std::initializer_list)\nbut in MSVC 2015 this code evaluates: Test::Test(int), it seems MSVC can somehow ignore {} and choose invalid/unexcepted version to call.</p>\n<p>What does standard says about this situation? Which version is valid? So where is the evil?\nDoes anybody can test this and confirm or not this issue in MSVC 2017?</p>\n", "Tags": "<c++><c++11><stl><language-lawyer>", "OwnerUserId": "1561413", "AnswerCount": "3"}, "47609344": {"ParentId": "47608388", "CommentCount": "2", "Body": "<p>I better explain my thoughts in an answer, hoping to help the OP to dissipate his (righteous) confusion:</p>\n<p>Behaviour of <strong>gcc</strong>: Test has a constructor that take <code>std::initializer_list</code> as the only argument, let's use it.</p>\n<p>Behaviour of <strong>VS</strong>: let's build something from <code>{10}</code> and see if Test has a constructor for it.</p>\n<p>Given <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow noreferrer\">this</a>, gcc is right.</p>\n", "OwnerUserId": "8873508", "PostTypeId": "2", "Id": "47609344", "Score": "1", "CreationDate": "2017-12-02T15:17:57.970", "LastActivityDate": "2017-12-02T15:17:57.970"}, "47610648": {"ParentId": "47608388", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_47608388_47610648_0\">Which version is valid?</p>\n</blockquote>\n<p>According to my understanding of the standard, <strong>the GCC is <em>right</em>.</strong></p>\n<blockquote>\n<p id=\"so_47608388_47610648_1\">What does standard says about this situation?</p>\n</blockquote>\n<p>What you do when you are writing <code>Test obj1({10});</code> is <a href=\"http://en.cppreference.com/w/cpp/language/direct_initialization\" rel=\"nofollow noreferrer\"><em>direct-initializing</em></a> an object of type <code>Test</code> with the expression <code>{ 10 }</code>. During overload resolution, the compiler has to decide which constructor to call. According to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"nofollow noreferrer\">16.3.3.2 \u00a7 3 (3.1.1) [over.ics.rank]</a>:</p>\n<blockquote>\n<p id=\"so_47608388_47610648_2\"><em>list-initialization</em> sequence <code>L1</code> is a better conversion sequence than list-initialization sequence <code>L2</code> if <code>L1</code> converts to\n  <code>std::initializer_list&lt;X&gt;</code> for some <code>X</code> and <code>L2</code> does not [...]</p>\n</blockquote>\n<p>The standard also provides the example</p>\n<pre><code>void f1(int);                                 // #1\nvoid f1(std::initializer_list&lt;long&gt;);         // #2\nvoid g1() { f1({42}); }                       // chooses #2\n</code></pre>\n<p>This is the point where VS &amp; clang differ from GCC: while all three will yield the same result in this particular example, changing it to</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A { A(int) { } };\nvoid f1(int) { std::cout &lt;&lt; \"int\\n\"; }                                // #1\nvoid f1(std::initializer_list&lt;A&gt;) { std::cout &lt;&lt; \"list\\n\"; }          // #2\n\nint main() {\n    f1({42});\n}\n</code></pre>\n<p>will let <a href=\"https://wandbox.org/permlink/1p9MpmsK43eTrWht\" rel=\"nofollow noreferrer\">clang chose the <code>int</code>-constructor</a>, moaning about the unnecessary braces around the literal <code>42</code> (which seems to be just in the standard for legacy reasons, see <a href=\"https://stackoverflow.com/questions/14232184/initializing-scalars-with-braces\">here</a>) rather than checking if the <code>{ 42 }</code> list sequence really cannot be converted to <code>std::initializer_list&lt;A&gt;</code>.</p>\n<p>Note however that writing <code>Test obj1{ 10 };</code> will lead to a different evaluation: According to the rules of <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow noreferrer\"><em>list-initialization</em></a>:</p>\n<blockquote id=\"so_47608388_47610648_3\">\n<ul>\n<li>Otherwise, the constructors of T are considered, in two phases:\n  \n  <ul>\n<li>All constructors that take std::initializer_list as the only argument, or as the first argument if the remaining arguments have default values, are examined, and matched by overload resolution against a single argument of type std::initializer_list </li>\n</ul></li>\n</ul>\n</blockquote>\n<p>So the <code>initializer_list</code> constructor is taken for a special overload resolution stage considering only <code>initializer_list</code> constructors before the normal overload resolution is applied, as demonstrated in the famous <code>std::vector</code>-gotcha:</p>\n<pre><code>// will be a vector with elements 2, 0 rather than a vector of size 2 with values 0, 0\nstd::vector&lt;int&gt; v{ 2, 0 };\n</code></pre>\n<p>The fact that in both cases the standard decides to use the <code>initializer_list</code> constructor is a consistent choice, but technically, the reason for chosing it is quite different under the hood.</p>\n", "OwnerUserId": "7703564", "LastEditorUserId": "7703564", "LastEditDate": "2017-12-02T17:45:20.317", "Id": "47610648", "Score": "2", "CreationDate": "2017-12-02T17:38:59.237", "LastActivityDate": "2017-12-02T17:45:20.317"}, "bq_ids": {"n4140": {"so_47608388_47610648_2": {"section_id": 639, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_47608388_47610648_2": {"section_id": 629, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_47608388_47610648_2": {"section_id": 667, "quality": 0.9166666666666666, "length": 11}}}, "47608977": {"ParentId": "47608388", "CommentCount": "0", "Body": "<ul>\n<li>VS2017(v141, <code>_MSC_FULL_VER</code> = <code>191125547</code>): <code>size_t</code> version selected</li>\n<li>gcc 7.2.0(<code>-std=c++11</code>/<code>-std=c++1z</code>): <code>std::initializer_list&lt;IntSimilar&gt;</code> version selcted</li>\n<li>clang 6.0.0 HEAD(<code>-std=c++11</code>/<code>-std=c++1z</code>): <code>size_t</code> version selected</li>\n</ul>\n<p>Hmm...\nThere is a possibility of Undefined Behavior...</p>\n", "OwnerUserId": "6277384", "PostTypeId": "2", "Id": "47608977", "Score": "0", "CreationDate": "2017-12-02T14:35:43.747", "LastActivityDate": "2017-12-02T14:35:43.747"}});