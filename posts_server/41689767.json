post_cb({"41689767": {"CommentCount": "0", "AcceptedAnswerId": "41691028", "CreationDate": "2017-01-17T05:42:01.263", "LastActivityDate": "2017-01-17T08:27:00.187", "PostTypeId": "1", "ViewCount": "522", "FavoriteCount": "3", "Title": "Partial template specialization triggering static_asserts", "Id": "41689767", "Score": "13", "Body": "<p>Consider this code</p>\n<pre><code>template &lt;typename T&gt;\nstruct delay : std::false_type{};\n\ntemplate &lt;typename T&gt;\nstruct my_typelist {\n    static_assert(delay&lt;T&gt;{}, \"\");\n};\n\ntemplate &lt;typename Tuple&gt;\nstruct test;\n\ntemplate &lt;typename T&gt;\nstruct test&lt;my_typelist&lt;T&gt;&gt; {\n    void pass(){}\n};\n\ntemplate &lt;typename T&gt;\nvoid fail(const test&lt;T&gt; &amp;){}\n\nint main()\n{\n    test&lt;my_typelist&lt;int&gt;&gt; t;\n    t.pass();\n    fail(t);\n}\n</code></pre>\n<p>Without calling <code>fail()</code> the code compiles and runs fine. However, using <code>t</code> in any function seems to trigger the <code>static_assert</code> in the <code>my_typelist</code> class, even though the class is never instantiated. Though the example is contrived, I ran into the same issue using incomplete types inside a <code>std::tuple</code>, even though I simply used <code>std::tuple</code> as a type list and never instantiated it.</p>\n<p>Why does the <code>static_assert</code> only trigger once I use the variable as a parameter, and not when I call a member function? In what contexts is <code>my_typelist</code> instantiated and when is it not?</p>\n<p>Note that I would have used variadic template but the error occurs regardless of this so I opted in to using the lowest common denominator.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "975989", "AnswerCount": "2"}, "41690334": {"ParentId": "41689767", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>So, let us go this way:</p>\n<p>First change your <code>static_assert</code> from this <a href=\"http://coliru.stacked-crooked.com/a/568ce7e649e6f611\" rel=\"nofollow noreferrer\">working code</a>:</p>\n<pre><code>template &lt;typename T&gt;\nstruct my_typelist {\n    static_assert(delay&lt;T&gt;{}, \"\");\n};\n</code></pre>\n<p>to this:</p>\n<pre><code>template &lt;typename T&gt;\nstruct my_typelist {\n    static_assert(false, \"\");\n};\n</code></pre>\n<p>It is going to <a href=\"http://coliru.stacked-crooked.com/a/1d03a18bff4a6b51\" rel=\"nofollow noreferrer\">fire immediately</a>. Note that the <code>false</code> expression doesn't depend on any type.</p>\n<hr>\n<p>Now, change it to a <code>delay&lt;T&gt;</code> type that doesn't depend on any template parameter, say, <code>char</code>, <code>int</code>, etc:</p>\n<pre><code>template &lt;typename T&gt;\nstruct my_typelist {\n    static_assert(delay&lt;int&gt;{}, \"\");\n};\n</code></pre>\n<p>It is still going to <a href=\"http://coliru.stacked-crooked.com/a/715c8a6f44b0073b\" rel=\"nofollow noreferrer\">fire immediately</a>.</p>\n<hr>\n<p>So what's happening here?</p>\n<p>class templates are not implicitly instantiated even when used, unless its used in contexts that requires completely defined types.</p>\n<p><a href=\"http://eel.is/c++draft/temp#inst-1\" rel=\"nofollow noreferrer\">temp.inst/1</a></p>\n<blockquote>\n<p id=\"so_41689767_41690334_0\">Unless a class template specialization has been explicitly\n  instantiated ([temp.explicit]) or explicitly specialized\n  ([temp.expl.spec]), the class template specialization is implicitly\n  instantiated when the specialization is referenced in a context that\n  requires a completely-defined object type or when the completeness of\n  the class type affects the semantics of the program.</p>\n</blockquote>\n<p>See, <a href=\"https://stackoverflow.com/a/41691028/1621391\">@cpplearner's answer</a> to understand why calling the function <code>fail(...)</code> instantiates <code>my_typelist&lt;int&gt;</code>. Basically ADL kicks in which forces such instantiation, you can suppress using a qualified name <code>::foo</code> or parenthesis.</p>\n<p>For completeness: In one of the <a href=\"http://eel.is/c++draft/basic.lookup.argdep#2\" rel=\"nofollow noreferrer\">rules</a> among <a href=\"http://eel.is/c++draft/basic.lookup.argdep\" rel=\"nofollow noreferrer\">others for ADL</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_41689767_41690334_1\"><a href=\"http://eel.is/c++draft/basic.lookup.argdep#2\" rel=\"nofollow noreferrer\">basic.lookup.argdep/2</a>: For each argument type T in the function call, there is a set of zero or more associated namespaces and a set of zero or more associated classes to be <strong>considered</strong>.</p>\n<ul>\n<li><p id=\"so_41689767_41690334_2\">....</p></li>\n<li><p id=\"so_41689767_41690334_3\"><a href=\"http://eel.is/c++draft/basic.lookup.argdep#2.2\" rel=\"nofollow noreferrer\">basic.lookup.argdep/2.2</a>: If T is a class type (including unions), its associated classes are:    the class itself; the class of which it is a member, if any;\n  and its direct and indirect base classes. Its associated namespaces\n  are the innermost enclosing namespaces of its associated classes. Furthermore, <strong>if T is a class template specialization, its associated namespaces and classes also include: the namespaces and classes associated with the types of the template arguments provided for template type parameters (excluding template template parameters); the namespaces of which any template template arguments are members; and the classes of which any member templates used as template template arguments are members.</strong> [\u2009Note: Non-type template arguments do not contribute to the set of associated namespaces.\u2009\u2014\u2009end note\u2009]</p></li>\n<li><p id=\"so_41689767_41690334_4\">....</p></li>\n</ul>\n</blockquote>\n</hr></hr>", "OwnerUserId": "1621391", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:16:45.263", "Id": "41690334", "Score": "7", "CreationDate": "2017-01-17T06:26:35.773", "LastActivityDate": "2017-01-17T08:27:00.187"}, "41691028": {"ParentId": "41689767", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In the case of <code>fail(t)</code>, if <code>my_typelist&lt;int&gt;</code> declares a friend function named <code>fail</code> in its class definition, that function will be found by <a href=\"http://en.cppreference.com/w/cpp/language/adl\">argument-dependent lookup</a> (because <code>my_typelist&lt;int&gt;</code> is an associated class of <code>test&lt;my_typelist&lt;int&gt;&gt;</code>). In certain cases, that friend, instead of the global function <code>fail</code>, may get selected by overload resolution (<a href=\"http://coliru.stacked-crooked.com/a/6b464a6cbeb78c8c\">demo</a>). Therefore, the definition of <code>my_typelist&lt;int&gt;</code> must be instantiated and examined to see whether that happens. Adding parentheses around <code>fail</code> will suppress argument-dependent lookup and remove the need to instantiate <code>my_typelist&lt;int&gt;</code>, and in that case, <code>static_assert</code> is not triggered (<a href=\"http://coliru.stacked-crooked.com/a/3932415276d3f87f\">demo</a>).</p>\n<p>In the case of <code>t.pass()</code>, <code>my_typelist&lt;int&gt;</code> is not instantiated because it is known that <code>t.pass()</code> will always call a member function of <code>test&lt;my_typelist&lt;int&gt;&gt;</code>, and that won't be affected by the completeness of <code>my_typelist&lt;int&gt;</code>. </p>\n", "OwnerUserId": "4672588", "LastEditorUserId": "4672588", "LastEditDate": "2017-01-17T07:22:10.950", "Id": "41691028", "Score": "9", "CreationDate": "2017-01-17T07:15:07.017", "LastActivityDate": "2017-01-17T07:22:10.950"}, "bq_ids": {"n4140": {"so_41689767_41690334_1": {"section_id": 7104, "quality": 0.8888888888888888, "length": 16}, "so_41689767_41690334_0": {"section_id": 233, "quality": 0.9, "length": 27}, "so_41689767_41690334_3": {"section_id": 7104, "quality": 0.9444444444444444, "length": 68}}, "n3337": {"so_41689767_41690334_1": {"section_id": 6848, "quality": 0.8888888888888888, "length": 16}, "so_41689767_41690334_0": {"section_id": 226, "quality": 0.9, "length": 27}, "so_41689767_41690334_3": {"section_id": 6848, "quality": 0.9166666666666666, "length": 66}}, "n4659": {"so_41689767_41690334_1": {"section_id": 8605, "quality": 0.6666666666666666, "length": 12}, "so_41689767_41690334_3": {"section_id": 8605, "quality": 0.9444444444444444, "length": 68}, "so_41689767_41690334_0": {"section_id": 242, "quality": 0.9, "length": 27}}}});