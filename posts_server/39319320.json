post_cb({"bq_ids": {"n4140": {"so_39319320_39319650_1": {"length": 15, "quality": 1.0, "section_id": 5988}}, "n3337": {"so_39319320_39319650_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 5756}}, "n4659": {"so_39319320_39319650_1": {"length": 15, "quality": 1.0, "section_id": 7488}}}, "39319320": {"ViewCount": "117", "Body": "<p>When compiling VTK 7.0.0 from source using GCC 6, I came across the following build error:</p>\n<blockquote>\n<p id=\"so_39319320_39319320_0\">error: expected primary-expression before \u2018(\u2019 token</p>\n<p id=\"so_39319320_39319320_1\">radioButton_Min-&gt;setGeometry(QRect(10, 20, , 17));</p>\n</blockquote>\n<p>The code used to build fine with GCC 5 that came bundled with the previous Fedora version. I realize that this may be a mistake by the VTK authors, but given the fact that the code used to build, here are two questions:</p>\n<ul>\n<li>Is this code valid C++?</li>\n<li>Is this code valid for GCC and / or other compilers given some loose settings, while not being valid by the standard? At the moment my warning and error settings are pretty tight.</li>\n</ul>\n<p><strong>Important edit:</strong></p>\n<p>Just found out that this code has been generated with Qt UIC (interface compiler) that produces C++ code based on .ui interface definition files. Probably the previous version of UIC handled this differently. But, for me, the question still remains: Could you quote the standard to be positively sure this is illegal C++?</p>\n", "AcceptedAnswerId": "39319650", "Title": "C++: Is it valid to omit a parameter value in a function call?", "CreationDate": "2016-09-04T16:53:32.073", "Id": "39319320", "CommentCount": "8", "LastEditDate": "2016-09-04T17:41:16.440", "PostTypeId": "1", "LastEditorUserId": "342384", "LastActivityDate": "2016-09-04T17:41:16.440", "Score": "4", "OwnerUserId": "342384", "Tags": "<c++><gcc><compiler-errors><language-lawyer>", "AnswerCount": "1"}, "39319650": {"Id": "39319650", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_39319320_39319650_0\">5.2.2 Function call</p>\n<p id=\"so_39319320_39319650_1\">A function call is a postfix expression followed by parentheses\n  containing a possibly empty, comma-separated list of\n  initializer-clauses which constitute the arguments to the function.</p>\n</blockquote>\n<p>Note that this only says that the list of parameters to a function call can be \"possibly empty\". Obviously. But otherwise each parameter in the list of parameters is an <code>initializer-clause</code>.</p>\n<p>An <code>initializer-clause</code> is defined in <code>8.5 Initializers</code> as follows:</p>\n<pre><code>initializer-clause:\n    assignment-expression\n    braced-init-list\n</code></pre>\n<p>So, each parameter to a function call is either an <code>assignment-expression</code> or a <code>braced-init-list</code>.</p>\n<p>A <code>braced-init-list</code> always begins, unsurprisingly, with a <code>{</code>:</p>\n<pre><code>braced-init-list:\n   { initializer-list , opt }\n   {}\n</code></pre>\n<p>That excludes that. So, in order for an individual parameter to a function call to possibly be empty, the <code>assignment-expression</code> must be able to resolve to an empty rule, in some way. Going down the rabbit hole:</p>\n<pre><code>assignment-expression:\n    conditional-expression\n    logical-or-expression assignment-operator initializer-clause\n    throw-expression\n</code></pre>\n<p>The <code>conditional-expression</code> leads further down the rabbit hole of arithmetical expressions:</p>\n<pre><code>conditional-expression:\n  logical-or-expression\n  logical-or-expression ? expression : assignment-expression\n</code></pre>\n<p>This cannot be empty. Resolving <code>logical-or-expression</code> further is going to get real old. The bottom line is that there's going to be an operator here, somewhere, so this cannot be empty.</p>\n<pre><code>assignment-operator: one of = *= /= %= += -= &gt;&gt;= &lt;&lt;=\n</code></pre>\n<p>This eliminates the second possible form of <code>assignment-expression</code> as being empty. It's guaranteed to have an operator.</p>\n<p>That leaves <code>throw-expression</code>:</p>\n<pre><code>throw-expression:\n    throw assignment-expression opt\n</code></pre>\n<p>This might seem bizarre, but section 15 defines that: \"A throw-expression is of type void\". This is just an expression of the type <code>void</code>. The bottom line is that this grammar rule cannot be empty, either.</p>\n<p>This conclusively precludes the possibility of a parameter to a function call being empty. The grammar rules specified by the C++ standard preclude that.</p>\n", "LastActivityDate": "2016-09-04T17:31:55.177", "CommentCount": "7", "CreationDate": "2016-09-04T17:31:55.177", "ParentId": "39319320", "Score": "3", "OwnerUserId": "3943312"}});