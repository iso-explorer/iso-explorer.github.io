post_cb({"28366572": {"CommentCount": "11", "ViewCount": "109", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2015-02-06T13:10:28.903", "LastActivityDate": "2015-02-06T17:16:50.413", "Title": "C++11: convert lambdas to function-objects in source", "LastEditDate": "2015-02-06T13:12:28.507", "Id": "28366572", "Score": "1", "Body": "<p>I have a library of C++11 code that I need to build on an older compiler that has no support for lambdas. It is not practical to manually change all the lambdas into hand-crafted function-objects.</p>\n<p>Does anyone know of a tool that I can run as a precompilation step, that will automatically extract all the lambdas into their equivalent function-classes? I was wondering if I could use clang's front end perhaps.</p>\n", "Tags": "<c++><c++11><lambda><function-object>", "OwnerUserId": "811244", "AnswerCount": "2"}, "28371034": {"ParentId": "28366572", "CommentCount": "0", "Body": "<p>There isn't such a tool already built as far as I know, but if you were to try to implement one, your best choices of infrastructure would be <a href=\"http://clang.llvm.org/\" rel=\"nofollow\">Clang</a> and <a href=\"http://rosecompiler.org\" rel=\"nofollow\">ROSE</a>.</p>\n", "OwnerUserId": "90002", "PostTypeId": "2", "Id": "28371034", "Score": "-1", "CreationDate": "2015-02-06T17:08:32.607", "LastActivityDate": "2015-02-06T17:08:32.607"}, "28371192": {"ParentId": "28366572", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_28366572_28371192_0\">Does anyone know of a tool that I can run as a precompilation step, that will automatically extract all the lambdas into their equivalent function-classes?</p>\n</blockquote>\n<p>Well, such tool might theoretically exist, but even if it did it would be more practical to simply switch to newer compiler in the first place.</p>\n<p>Let's consider following code:</p>\n<pre><code>template &lt;class F&gt;\nauto apply_0(F f) -&gt; decltype(f(0)) {\n    auto g = [f] (int x) { return f(x); };\n    return g(0);\n}\n</code></pre>\n<p>In this case, our tool would need to either generate function object, that returns <code>auto</code> type (which implies, that generated code would need to be compilable using C++14) or instantiate template to detect all possible return types, that appear in code (at this point it would be easier to switch to C++14).</p>\n<p>But, let's consider even most optimistic situation: all lambda expressions throughout project define their return types using <code>-&gt;</code> and they don't appear in template functions - in this case theoretically you could convert lambda expression to equivalent struct with <code>operator()</code> and constructor, that captures variables as struct members - would it give you code, that behaves the same way? Answer is: <strong>it's implementation-defined</strong>.</p>\n<p>Consider even smallest possible lambda:</p>\n<pre><code>auto f = [] { return 0; };\ncout &lt;&lt; is_pod&lt;decltype(f)&gt;::value &lt;&lt; endl;\n</code></pre>\n<p>When compiled with g++ - this code will write '0', with clang++ - it will write '1'. If we converted this lambda to function object - resulting struct would be POD type in both gcc and clang. Another example:</p>\n<pre><code>int x = 42;\nauto f = [x] { return x; };\ncout &lt;&lt; is_pod&lt;decltype(f)&gt;::value &lt;&lt; endl;\n</code></pre>\n<p>g++ will still give '0', clang++ will still give '1'. During conversion to struct we would need to write some initializer (constructor or other) for binded member <code>x</code> of our function object - depending on implementation it could be POD or non-POD, either way - it may be different than what compiler does when creating anonymous closure object for lambda.</p>\n<p>Other things, that may change are listed by C++11 standard, \u00a7 5.1.2.3:</p>\n<blockquote>\n<p id=\"so_28366572_28371192_1\">An implementation may define the closure type differently from what is described below provided this does not alter the observable behavior of the\n  program other than by changing:</p>\n<ul>\n<li>the size and/or alignment of the closure type,</li>\n<li>whether the closure type is trivially copyable (Clause 9),</li>\n<li>whether the closure type is a standard-layout class (Clause 9), or</li>\n<li>whether the closure type is a POD class (Clause 9).</li>\n</ul>\n</blockquote>\n<p>As always, your code shouldn't depend on implementation-defined parts of language - so this is not such a big deal, but it may lead to unexpected consequences nonetheless.</p>\n", "OwnerUserId": "2033752", "PostTypeId": "2", "Id": "28371192", "Score": "2", "CreationDate": "2015-02-06T17:16:50.413", "LastActivityDate": "2015-02-06T17:16:50.413"}, "bq_ids": {"n4140": {"so_28366572_28371192_1": {"section_id": 5962, "quality": 1.0, "length": 17}}, "n3337": {"so_28366572_28371192_1": {"section_id": 5731, "quality": 1.0, "length": 17}}, "n4659": {"so_28366572_28371192_1": {"section_id": 7452, "quality": 1.0, "length": 17}}}});