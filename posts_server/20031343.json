post_cb({"bq_ids": {"n4140": {"so_20031343_20031372_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}}, "n3337": {"so_20031343_20031372_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 18}}, "n4659": {"so_20031343_20031372_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}}}, "20031343": {"ViewCount": "107", "Body": "<p>I have done some tests in VC++2010 mixing operands of different sizes that cause overflow in add operation:</p>\n<pre><code>int _tmain(int argc, _TCHAR* argv[])\n{\n    __int8 a=127;\n    __int8 b=1;\n    __int16 c=b+a;\n    __int8  d=b+a;\n    printf(\"c=%d,d=%d\\n\",c,d);\n\n    return 0;\n}\n\n//result is: c=128, d=-128\n</code></pre>\n<p>I don't understand why c==128!  My understanding is that in both additions, b+a are still considered addition of 2 signed <strong>8 bit</strong> variables. So the result is an overflow i.e. -128.  <strong>After that</strong>, the result is then promoted to 16 bit signed int for the first assignment operation and c should still get a 16 bit -128 value.  Is my understanding correct?  The c++ standard is a bit difficult to read. Chapter 4 seems talking about integeral promotion but I can't find anything related to this specific example.</p>\n", "AcceptedAnswerId": "20031408", "Title": "C++ Arithmetic With Mixed Integral Types That Causes Overflow", "CreationDate": "2013-11-17T13:40:46.717", "Id": "20031343", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-11-17T14:11:59.447", "Score": "2", "OwnerUserId": "237575", "Tags": "<c++><integer-overflow><type-promotion>", "AnswerCount": "3"}, "20031645": {"Id": "20031645", "PostTypeId": "2", "Body": "<p>In twos-complement integer representation, a signed value is represented by setting the highest bit.  This allows the machine to add and subtract binary integers with the same instructions, regardless of whether the integer is signed.</p>\n<pre><code>  a = 127 == 0x7F == 0b01111111\n+ b =   1 == 0x01 == 0b00000001\n-------------------------------\n  c = 128 == 0x80 == 0b10000000\n  d =-128 == 0x80 == 0b10000000\n</code></pre>\n<p>The variables <code>c</code> and <code>d</code> may have different types, but different types of integers are merely different interpretations of a single binary value.  As you can see above, the binary value fits in 8 bits just fine.  Since the standard requires terms of a mathematical expression to be zero- or sign-extended (promoted) to the size of a machine word <em>before</em> any math is done and neither operand will be sign-extended, the result is always <code>0b10000000</code> no matter what type the operands are.</p>\n<p>In summary, the difference between the results is that, to a 16 bit integer the sign bit is <code>0b1000000000000000</code> (which <code>a+b</code> doesn't have), and to an 8 bit integer the sign bit is <code>0b10000000</code> (which <code>a+b</code> does have).</p>\n", "LastActivityDate": "2013-11-17T14:11:59.447", "CommentCount": "0", "CreationDate": "2013-11-17T14:11:59.447", "ParentId": "20031343", "Score": "0", "OwnerUserId": "929845"}, "20031372": {"Id": "20031372", "PostTypeId": "2", "Body": "<h2>It's integral promotion.</h2>\n<blockquote>\n<p id=\"so_20031343_20031372_0\"><sup>1</sup> A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer conversion rank (4.13) is less than the rank of int can be converted to a prvalue of type int if int can represent all the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned int. [\u00a7 4.5]</p>\n</blockquote>\n<p>In this statement</p>\n<pre><code> __int16 c=b+a;\n</code></pre>\n<blockquote>\n<p id=\"so_20031343_20031372_1\">First, all <code>char</code> and <code>short int</code> values are automatically elevated to <code>int</code>. This process is called <strong>integral promotion</strong>. Next, all operands are converted up to the type of the largest operand, which is called <strong>type promotion</strong>. [Herbert Schildt]</p>\n</blockquote>\n<p>The <em>values</em> of variables <code>b</code> and <code>a</code> will be promoted to <code>int</code> and then the operation applies on them.</p>\n", "LastEditorUserId": "952747", "LastActivityDate": "2013-11-17T13:49:14.493", "Score": "1", "CreationDate": "2013-11-17T13:44:02.267", "ParentId": "20031343", "CommentCount": "0", "OwnerUserId": "952747", "LastEditDate": "2013-11-17T13:49:14.493"}, "20031408": {"Id": "20031408", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_20031343_20031408_0\">My understanding is that in both additions, b+a are still considered addition of 2 signed 8 bit variables. So the result is an overflow i.e. -128.</p>\n</blockquote>\n<p>No, the promotion happens before the <code>+</code> is evaluated, not after it. The addition happens when both <code>a</code> and <code>b</code> are positive. Both numbers are promoted to <code>int</code>s for an addition, added as two positive numbers, and then converted to a 16-bit short. At no point in the process does the result become negative due to an overflow, hence the end result of 128.</p>\n<p>Arguably, this makes sense: the behavior of <code>a</code> and <code>b</code> matches that of two numbers in mathematics, making it more intuitive to language practitioners.</p>\n", "LastActivityDate": "2013-11-17T13:47:16.113", "CommentCount": "0", "CreationDate": "2013-11-17T13:47:16.113", "ParentId": "20031343", "Score": "2", "OwnerUserId": "335858"}});