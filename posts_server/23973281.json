post_cb({"bq_ids": {"n4140": {"so_23973281_23973320_0": {"length": 11, "quality": 1.0, "section_id": 7047}, "so_23973281_23976676_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 554}, "so_23973281_23976394_0": {"length": 14, "quality": 1.0, "section_id": 7038}}, "n3337": {"so_23973281_23973320_0": {"length": 11, "quality": 1.0, "section_id": 6792}, "so_23973281_23976394_0": {"length": 14, "quality": 1.0, "section_id": 6784}, "so_23973281_23976676_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 545}}, "n4659": {"so_23973281_23973320_0": {"length": 11, "quality": 1.0, "section_id": 8544}, "so_23973281_23976394_0": {"length": 14, "quality": 1.0, "section_id": 8535}, "so_23973281_23976676_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 577}}}, "23976676": {"Id": "23976676", "PostTypeId": "2", "Body": "<p>The actual reason in the current case is ODR as rightly observed by <em>david.pfx</em>.\nBut consider the following example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n\nextern int a;\nextern char a;\n\nint main(){ std::cout &lt;&lt; a;}\n</code></pre>\n<p>The actual reason is not the violation of 3.3. Actually in the 13/1 said:</p>\n<blockquote>\n<p id=\"so_23973281_23976676_0\">When two or more different declarations are specified for a single\n  name in the same scope, that name is said to be overloaded. By\n  extension, two declarations in the same scope that declare <strong>the same\n  name but with different types</strong> are called overloaded declarations. Only\n  function and function template declarations can be overloaded;\n  variable and type declarations cannot be overloaded.</p>\n</blockquote>\n<p>Hence, I'm just trying to overload non-function declaration.</p>\n", "OwnerDisplayName": "user2953119", "LastActivityDate": "2014-06-01T04:06:28.383", "Score": "0", "CreationDate": "2014-06-01T04:06:28.383", "ParentId": "23973281", "CommentCount": "6"}, "23973320": {"Id": "23973320", "PostTypeId": "2", "Body": "<p>C++11 \u00a73.3.1 \u00b64</p>\n<blockquote>\n<p id=\"so_23973281_23973320_0\">Given a set of declarations in a single declarative region, each of which specifies the same unqualified name,</p>\n<ul>\n<li>they shall all refer to the same entity, or all refer to functions and function templates; or</li>\n<li>exactly one declaration shall declare a class name or enumeration name that is not a typedef name\n  and the other declarations shall all refer to the same variable or enumerator, or all refer to functions\n  and function templates; in this case the class name or enumeration name is hidden (3.3.10). [ Note: A\n  namespace name or a class template name must be unique in its declarative region (7.3.2, Clause 14).\n  \u2014 end note ]</li>\n</ul>\n</blockquote>\n<p>Neither of these conditions is met in your case, so your program is ill-formed.</p>\n", "LastActivityDate": "2014-05-31T17:40:53.220", "CommentCount": "7", "CreationDate": "2014-05-31T17:40:53.220", "ParentId": "23973281", "Score": "7", "OwnerUserId": "214671"}, "23976394": {"Id": "23976394", "PostTypeId": "2", "Body": "<p>This is a simple violation of the One Definition Rule (ODR). See n3797 S3.2/1.</p>\n<blockquote>\n<p id=\"so_23973281_23976394_0\">No translation unit shall contain more than one definition of any variable, function, class type, enumeration type, or template.</p>\n</blockquote>\n<p>There really is no more to be said. Each of those lines is a <em>definition</em> of <code>a</code> (not a <em>declaration</em>). The program is ill-formed.</p>\n<p>If these declarations were in different translation units the program would still be ill-formed, but the applicable rule is different. See S3.5/10.</p>\n", "LastActivityDate": "2014-06-01T03:02:52.170", "CommentCount": "2", "CreationDate": "2014-06-01T03:02:52.170", "ParentId": "23973281", "Score": "0", "OwnerUserId": "1105562"}, "23973281": {"ViewCount": "126", "Body": "<p>The following code does not compile:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n\nint a=5;\nchar a='a';\n\nint main(){ std::cout &lt;&lt; a;}\n</code></pre>\n<p>It is because:</p>\n<pre><code>test.cpp:5:6: error: conflicting declaration \u2018char a\u2019\ntest.cpp:4:5: error: \u2018a\u2019 has a previous declaration as \u2018int a\u2019\n</code></pre>\n<p>But where does this restriction specified in the standard? I can't find it. Please give me a reference.</p>\n", "AcceptedAnswerId": "23976394", "Title": "Why does declaration of the same name inside the same declarative region is denied?", "CreationDate": "2014-05-31T17:35:33.473", "Id": "23973281", "CommentCount": "0", "LastEditDate": "2014-05-31T17:42:34.247", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastEditorUserId": "214671", "LastActivityDate": "2014-06-01T04:06:28.383", "Score": "1", "Tags": "<c++><language-lawyer>", "AnswerCount": "3"}});