post_cb({"35004935": {"ParentId": "35004633", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>No. The C++ Standard guarantees there are no false negatives. (i.e., <code>std::vector</code>, <code>std::string</code>, <code>std::array</code>, and basic arrays are promised to be stored contiguously).</p>\n<p>However, the C++ Standard <em>doesn't</em> guarantee there are no false positives.</p>\n<pre><code>int main() {\n   std::unique_ptr&lt;Node&gt; n1(new Node);\n   std::unique_ptr&lt;Node&gt; n2(new Node);\n   n1-&gt;next = n2; // n1 and n2 might be contiguous, but might not be\n}\n</code></pre>\n<p>Thus, your type trait could be wrong some of the time. If it's wrong some of the time, it's not a type trait; rather, it's an instance trait.</p>\n", "OwnerUserId": "2883245", "LastEditorUserId": "2883245", "LastEditDate": "2016-01-26T00:47:50.683", "Id": "35004935", "Score": "6", "CreationDate": "2016-01-26T00:17:20.693", "LastActivityDate": "2016-01-26T00:47:50.683"}, "35008842": {"ParentId": "35004633", "PostTypeId": "2", "CommentCount": "8", "Body": "<p><strong>No</strong>, there is not compiletime trait for this.</p>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf\" rel=\"noreferrer\"><strong>draft C++1z Standard</strong></a> defines contiguity as a <strong>runtime property</strong> of an iterator range. Note there is no compiletime <code>std::contiguous_iterator_tag</code> corresponding to this iterator category.</p>\n<blockquote>\n<p id=\"so_35004633_35008842_0\"><strong>24.2 Iterator requirements [iterator.requirements]</strong></p>\n<p id=\"so_35004633_35008842_1\"><strong>24.2.1 In general [iterator.requirements.general]</strong></p>\n<p id=\"so_35004633_35008842_2\">5 Iterators that further satisfy the requirement that, for integral\n  values <code>n</code> and dereferenceable iterator values <code>a</code> and <code>(a + n), *(a + n)</code>\n  is equivalent to <code>*(addressof(*a) + n)</code>, are called contiguous\n  iterators. [ Note: For example, the type \u201cpointer to int\u201d is a\n  contiguous iterator, but <code>reverse_iterator&lt;int *&gt;</code> is not. For a valid\n  iterator range <code>[a,b)</code> with dereferenceable <code>a</code>, the corresponding range\n  denoted by pointers is <code>[addressof(*a),addressof(*a) + (b - a));</code> <code>b</code>\n  might not be dereferenceable. \u2014 end note ]</p>\n</blockquote>\n<p>One way to test for this at runtime would be</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;deque&gt;\n#include &lt;list&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\n\ntemplate&lt;class I&gt;\nauto is_contiguous(I first, I last)\n{ \n    auto test = true;\n    auto const n = std::distance(first, last);\n    for (auto i = 0; i &lt; n &amp;&amp; test; ++i) {\n        test &amp;= *(std::next(first, i)) == *(std::next(std::addressof(*first), i));\n    }        \n    return test;        \n}\n\nint main()\n{\n    auto l = std::list&lt;int&gt; { 1, 2, 3 };\n    auto m = std::map&lt;int, int&gt;  { {1, 1}, {2,2}, {3,3} };\n    auto u = std::unordered_multiset&lt;int&gt; { 1, 1, 1 };\n    auto d = std::deque&lt;int&gt;(4000);\n    int c[] = { 1, 2, 3 };\n    auto a = std::array&lt;int, 3&gt; {{ 1, 2, 3 }};\n    auto s = std::string {\"Hello world!\"};\n    auto v = std::vector&lt;int&gt; { 1, 2, 3, };\n\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; is_contiguous(l.begin(), l.end()) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; is_contiguous(m.begin(), m.end()) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; is_contiguous(u.begin(), u.end()) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; is_contiguous(d.begin(), d.end()) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; is_contiguous(d.begin(), d.begin() + 1000) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; is_contiguous(std::begin(c), std::end(c)) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; is_contiguous(a.begin(), a.end()) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; is_contiguous(s.begin(), s.end()) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; is_contiguous(v.begin(), v.end()) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; is_contiguous(v.rbegin(), v.rend()) &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/e0e37d9aa7f8c305\" rel=\"noreferrer\"><strong>Live Example</strong></a>. This prints <code>false</code> for the <code>list</code>, <code>map</code> and <code>unordered_multimap</code>, and <code>true</code> for the C-array, and the <code>std::array</code>, <code>string</code> and <code>vector</code>. It prints <code>true</code> for small subranges within a <code>deque</code> and <code>false</code> for large subranges. It also prints <code>false</code> for an iterator range consisting of reverse iterators.</p>\n<p><strong>UPDATE</strong>: as commented by @T.C. the original <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3884.pdf\" rel=\"noreferrer\"><strong>N3884</strong></a> proposal did have a </p>\n<pre><code>struct contiguous_iterator_tag : random_access_iterator_tag {};\n</code></pre>\n<p>so that tag-dispatching on iterator categories would not break. However, this would have broken non-idiomatic code with class template specializations on <code>random_access_iterator_tag</code>. The current draft hence does not contain a new iterator category tag.</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2016-01-26T12:28:14.823", "Id": "35008842", "Score": "11", "CreationDate": "2016-01-26T07:35:23.970", "LastActivityDate": "2016-01-26T12:28:14.823"}, "35004633": {"CommentCount": "8", "AcceptedAnswerId": "35008842", "LastEditDate": "2016-01-26T10:18:00.720", "LastEditorUserId": "2970186", "CreationDate": "2016-01-25T23:47:02.777", "LastActivityDate": "2016-01-26T12:28:14.823", "PostTypeId": "1", "ViewCount": "1153", "FavoriteCount": "2", "Title": "Checking if a sequence container is contiguous in memory", "Id": "35004633", "OwnerUserId": "2970186", "Body": "<p>Is there a way to check if a sequence container is contiguous in memory? Something like:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;deque&gt;\n#include &lt;array&gt;\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; is_contiguous&lt;std::vector&lt;int&gt;&gt;::value   &lt;&lt; '\\n'  // true\n    std::cout &lt;&lt; is_contiguous&lt;std::deque&lt;int&gt;&gt;::value    &lt;&lt; '\\n'; // false\n    std::cout &lt;&lt; is_contiguous&lt;std::array&lt;int, 3&gt;&gt;::value &lt;&lt; '\\n'; // true\n}\n</code></pre>\n<p><strong>Clarification</strong></p>\n<p>This question is referring to type traits, rather than the properties of a specific instance of a type.</p>\n", "Tags": "<c++><c++11><containers><c++14><typetraits>", "Score": "12", "AnswerCount": "3"}, "bq_ids": {"n4659": {"so_35004633_35008842_2": {"section_id": 7005, "quality": 0.8157894736842105, "length": 31}}}, "35004753": {"ParentId": "35004633", "CommentCount": "6", "Body": "<p>No.\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "35004753", "Score": "0", "CreationDate": "2016-01-25T23:59:14.170", "LastActivityDate": "2016-01-25T23:59:14.170"}});