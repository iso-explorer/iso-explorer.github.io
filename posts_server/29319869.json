post_cb({"29319975": {"ParentId": "29319869", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_29319869_29319975_0\">i think my teacher told me it is possible to create a variable of void type . He told he will teach us later </p>\n</blockquote>\n<p>We can not have void objects, most likely what your teacher meant was that you can have a void expression or a void pointer. void expressions are very useful for templates when a function return different types, for example see the question: <a href=\"https://stackoverflow.com/q/20478193/1708801\">Returning a void?</a> which provides the following code:</p>\n<pre><code>template &lt;class T&gt;\nstruct Test\n{\n    static constexpr T f() {return T();} \n};\n\nint main()\n{\n    Test&lt;void&gt; test;\n    test.f(); // Why not an error?\n    return 0;\n}\n</code></pre>\n<p>For reference the draft C++ standard says the following (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_29319869_29319975_1\">An <strong>object type</strong> is a (possibly cv-qualified) type that is not a function type, not a reference type, and <strong>not a\n  void type.</strong></p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_29319869_29319975_2\">The void type has an empty set of values. The <strong>void type is an incomplete type that cannot be completed</strong>. It\n  is used as the return type for functions that do not return a value. Any expression can be explicitly converted\n  to type cv void (5.4). An <strong>expression of type void shall be used only</strong> as an expression statement (6.2), as an\n  operand of a comma expression (5.18), as a second or third operand of ?: (5.16), as the operand of typeid\n  or decltype, as the expression in a return statement (6.6.3) for a function with the return type void, or as\n  the operand of an explicit conversion to type cv void</p>\n</blockquote>\n<p>The other possibility is your teacher was referring to void pointers, which is used when you need a pointer that can point to any type. Most likely for using C APIs, see <a href=\"https://stackoverflow.com/q/17330777/1708801\">when to use void* in c++</a>:</p>\n<blockquote>\n<p id=\"so_29319869_29319975_3\">Compound types can be constructed in the following ways:</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_29319869_29319975_4\">pointers to void or objects or functions (including static members of classes) of a given type</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:50:53.607", "Id": "29319975", "Score": "2", "CreationDate": "2015-03-28T17:01:24.063", "LastActivityDate": "2015-03-28T17:24:12.277"}, "29319869": {"CommentCount": "12", "ViewCount": "195", "OwnerDisplayName": "user4682149", "CreationDate": "2015-03-28T16:52:25.403", "LastActivityDate": "2015-03-28T19:21:44.343", "PostTypeId": "1", "FavoriteCount": "1", "Title": "C++ : Using void to create variables", "Id": "29319869", "Score": "3", "Body": "<p>I am learning C++ on my own from the internet. I was wondering if you can create a variable of the <code>void</code> type. If so , how can you? Also what will be these variables used for? </p>\n<p><strong>This does not work:</strong></p>\n<pre><code>void b;\ncout&lt;&lt;b;\n</code></pre>\n<p><strong>Error:</strong></p>\n<blockquote>\n<p id=\"so_29319869_29319869_0\">Size of b is unknown or zero</p>\n</blockquote>\n<p>Thanks :)</p>\n", "Tags": "<c++>", "AnswerCount": "6"}, "29320029": {"ParentId": "29319869", "CommentCount": "0", "Body": "<p>Here's the deal (and folks, this is a legit beginner question, jaysus, lay off the guy.)</p>\n<p>The <code>void</code> type in C and C++ is a tag or label for \"thing of no type at all.\" Now, when we talk about the \"type\" of something, we're really saying two things:</p>\n<ul>\n<li>how much memory does it occupy?</li>\n<li>what operations can we perform on that thing?</li>\n</ul>\n<p>So, for example, when we declare something like <code>int x;</code> we're saying that <code>x</code></p>\n<ul>\n<li>is <code>sizeof(int)</code> \u00d7 8 bits of memory</li>\n<li>has arithmetic operations like <code>*</code> and <code>+</code>.</li>\n</ul>\n<p>Now, an object of <em>no</em> type would have neither one, so the compiler tells you the size is unknown or 0.</p>\n<p>But what <strong>is</strong> useful is to have an <em>address</em> that doesn't have a type associated with it.  When you declare something as <code>int * xp;</code> you're saying thet <code>xp</code> is the address of something that we agree to treat as an <code>int</code> -- but it's just an agreement because we can, eg with a typecast, change or minds later.</p>\n<p>When we declare something <code>void * vp;</code>, we're saying \"this is the address of something, type of that something to be determined later.\"</p>\n", "OwnerUserId": "35092", "PostTypeId": "2", "Id": "29320029", "Score": "2", "CreationDate": "2015-03-28T17:06:21.960", "LastActivityDate": "2015-03-28T17:06:21.960"}, "29320208": {"ParentId": "29319869", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><strong><code>void</code> is not valid for variable types other than <code>void*</code>s in C++, never for an actual value type.</strong></p>\n<p><a href=\"http://www.cplusplus.com\" rel=\"nofollow\">http://www.cplusplus.com</a> has a good section on <code>void*</code>s: <a href=\"http://www.cplusplus.com/doc/tutorial/pointers/#void\" rel=\"nofollow\">http://www.cplusplus.com/doc/tutorial/pointers/#void</a></p>\n<p>Note that the lines:</p>\n<blockquote>\n<p id=\"so_29319869_29320208_0\">The data pointed by them cannot be directly dereferenced (which is logical, since we have no type to dereference to), and for that reason, any address in a void pointer needs to be transformed into some other pointer type that points to a concrete data type before being dereferenced.</p>\n</blockquote>\n<p>A <code>void*</code> is typically used to reference values of an <em>unknown</em> type. Other information is used to determine the type, the <code>void*</code> is cast to that type and only then can be dereferenced.</p>\n<p>This behavior was very common in C, however with the advent of C++ it is vastly preferable to use templates to determine the value type of anything that is known at compile-time, <code>void*</code>s are used only in the special case that a value type must be determined at run-time.</p>\n<hr>\n<p>I've been learning about aliasing a lot lately, and it may be further evidence of <code>void*</code>'s fall from grace that it is not listed as a supported type while <code>char*</code> and <code>unsigned char*</code> are: <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast#Type_aliasing\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/reinterpret_cast#Type_aliasing</a></p>\n</hr>", "OwnerUserId": "2642059", "LastEditorUserId": "2642059", "LastEditDate": "2015-03-28T19:02:24.160", "Id": "29320208", "Score": "0", "CreationDate": "2015-03-28T17:22:47.857", "LastActivityDate": "2015-03-28T19:02:24.160"}, "29319911": {"ParentId": "29319869", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_29319869_29319911_0\"><em>\"I was wondering if you can create a variable of the void type.\"</em></p>\n</blockquote>\n<p>No, the compiler already told you.</p>\n<blockquote>\n<p id=\"so_29319869_29319911_1\"><em>If so , how can you?\"</em> </p>\n</blockquote>\n<p>See above.</p>\n<blockquote>\n<p id=\"so_29319869_29319911_2\"><em>\"Also what will be these variables used for?\"</em></p>\n</blockquote>\n<p>It won't be useful, because <code>void</code> explicitly designates <em>no type</em>.</p>\n<hr>\n<blockquote>\n<p id=\"so_29319869_29319911_3\"><em>\"so wat is a void pointer used for?\"</em></p>\n</blockquote>\n<p>As for your comment:</p>\n<p>It's used to store the address of an object of any type. Unless you don't know the exact original type, it's pretty useless as well.</p>\n</hr>", "OwnerUserId": "1413395", "PostTypeId": "2", "Id": "29319911", "Score": "5", "CreationDate": "2015-03-28T16:56:17.737", "LastActivityDate": "2015-03-28T16:56:17.737"}, "29320001": {"ParentId": "29319869", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can use <strong>void</strong> pointers to achieve that.\nCheck here: </p>\n<p><a href=\"http://www.learncpp.com/cpp-tutorial/613-void-pointers/\" rel=\"nofollow\">http://www.learncpp.com/cpp-tutorial/613-void-pointers/</a></p>\n<pre><code>int nValue;\nfloat fValue;\n\nstruct Something\n{\n    int nValue;\n    float fValue;\n};\n\nSomething sValue;\n\nvoid *pVoid;\npVoid = &amp;nValue; // valid\npVoid = &amp;fValue; // valid\npVoid = &amp;sValue; // valid\n</code></pre>\n<p>Using void pointers usually is a <strong>bad practice</strong>. It's a valid practice (in pre-C++11 standards) only for function pointers. \nStay with hard typed pointers, because the compilers can perform optimizations on them.</p>\n", "OwnerUserId": "2369389", "LastEditorUserId": "2369389", "LastEditDate": "2015-03-28T18:13:05.583", "Id": "29320001", "Score": "0", "CreationDate": "2015-03-28T17:03:43.113", "LastActivityDate": "2015-03-28T18:13:05.583"}, "bq_ids": {"n4140": {"so_29319869_29319975_1": {"section_id": 7206, "quality": 0.9090909090909091, "length": 10}, "so_29319869_29319975_2": {"section_id": 7218, "quality": 0.8888888888888888, "length": 48}, "so_29319869_29319975_3": {"section_id": 7221, "quality": 1.0, "length": 6}, "so_29319869_29319975_4": {"section_id": 7221, "quality": 0.9, "length": 9}}, "n3337": {"so_29319869_29319975_1": {"section_id": 6950, "quality": 0.9090909090909091, "length": 10}, "so_29319869_29319975_2": {"section_id": 6962, "quality": 0.8888888888888888, "length": 48}, "so_29319869_29319975_3": {"section_id": 6965, "quality": 1.0, "length": 6}, "so_29319869_29319975_4": {"section_id": 6965, "quality": 0.9, "length": 9}}, "n4659": {"so_29319869_29319975_1": {"section_id": 4058, "quality": 0.8181818181818182, "length": 9}, "so_29319869_29319975_2": {"section_id": 8727, "quality": 0.7037037037037037, "length": 38}, "so_29319869_29319975_3": {"section_id": 8730, "quality": 1.0, "length": 6}, "so_29319869_29319975_4": {"section_id": 8730, "quality": 0.9, "length": 9}}}, "29321511": {"ParentId": "29319869", "CommentCount": "0", "Body": "<p>An example of use of void* in modern C++, which is ok (says our local C++ guru):</p>\n<p>When creating portable code you sometimes want to know if your code was compiled as 32bit or 64bit, one way of determining this is to check the size of a void* as it represents the size of an address in bytes.\nWhen</p>\n<pre><code>sizeof(void*)==8\n</code></pre>\n<p>you know your code is compiled as 64bit (8bytes). And When</p>\n<pre><code>sizeof(void*)==4\n</code></pre>\n<p>you know your code is compiled as 32bit </p>\n", "OwnerUserId": "18000", "PostTypeId": "2", "Id": "29321511", "Score": "0", "CreationDate": "2015-03-28T19:21:44.343", "LastActivityDate": "2015-03-28T19:21:44.343"}});