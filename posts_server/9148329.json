post_cb({"9148342": {"Id": "9148342", "PostTypeId": "2", "Body": "<p>No, it's a declaration, of a pointer to B. You are not declaring B here, only a pointer to it, and there's nothing forward about it.</p>\n<p><strong>Edit</strong>: I was wrong, sorry. See other answer.</p>\n", "LastEditorUserId": "1016716", "LastActivityDate": "2012-02-05T10:04:33.567", "Score": "1", "CreationDate": "2012-02-05T09:56:32.913", "ParentId": "9148329", "CommentCount": "3", "OwnerUserId": "1016716", "LastEditDate": "2012-02-05T10:04:33.567"}, "9148329": {"ViewCount": "177", "Body": "<p>This is related to <a href=\"https://stackoverflow.com/questions/9148258/pointer-to-a-structure-that-has-not-been-declared\">a recent question</a>.</p>\n<p>Basically the following code:</p>\n<pre><code>class A\n{\n    class B* b;\n    B* c;\n};\n</code></pre>\n<p>compiles although <code>class B</code> is not declared or forward-declared. Is this syntax equivalent to a forward declaration? Are there any differences?</p>\n", "AcceptedAnswerId": "9148358", "Title": "Is the following equivalent to a forward declaration?", "CreationDate": "2012-02-05T09:54:28.283", "Id": "9148329", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:27:29.383", "LastEditorUserId": "-1", "LastActivityDate": "2012-02-05T11:05:26.473", "Score": "3", "OwnerUserId": "673730", "Tags": "<c++><forward-declaration>", "AnswerCount": "3"}, "9148358": {"Id": "9148358", "PostTypeId": "2", "Body": "<p>You can declare a type and an object in the same declaration.</p>\n<pre><code>class B* b;\n</code></pre>\n<p>Declares a type, <code>B</code> and an object <code>b</code> which has type pointer to <code>B</code>. The type is incomplete and is looked up in the scope in which it occurs, if the lookup fails to find an existing declaration for the class then the type names a type in the nearest enclosing namespace scope (strictly non-class non-function-prototype scope, which is usually a namespace). The object is a member of the scope in which the declaration appears (in this case, <code>class A</code>).</p>\n<p>In most cases it's more common to declare a complete type and an object together, in this case the type is sometimes left anonymous. E.g.</p>\n<pre><code>struct { int a; int b; } x;\n</code></pre>\n<p>The relevant parts of the standard for the name scoping rules are 7.1.5.3 [dcl.type.elab] Elaborated type specifiers / 2 and the referenced sections in 3.4.4 and 3.3.1 :</p>\n<blockquote>\n<p id=\"so_9148329_9148358_0\">3.4.4 describes how name lookup proceeds for the <em>identifier</em> in an <em>elaborated-type-specifier</em>. If the <em>identifier</em> resolves to a <em>class-name</em> or <em>enum-name</em>, the <em>elaborated-type-specifier</em> introduces it into the declaration the same way a <em>simple-type-specifier</em> introduces its <em>type-name</em>. If the <em>identifier</em> resolves to a <em>typedef-name</em> or a template <em>type-parameter</em>, the <em>elaborated-type-specifier</em> is ill-formed. [ ... ] If name lookup does not find a declaration for the name, the <em>elaborated-type-specifier</em> is ill-formed unless it is of the simple form <em>class-key identifier</em> in which case the <em>identifier</em> is declared as described in 3.3.1.</p>\n</blockquote>\n", "LastEditorUserId": "19563", "LastActivityDate": "2012-02-05T10:45:05.530", "Score": "9", "CreationDate": "2012-02-05T10:01:04.147", "ParentId": "9148329", "CommentCount": "5", "OwnerUserId": "19563", "LastEditDate": "2012-02-05T10:45:05.530"}, "bq_ids": {"n4140": {"so_9148329_9148358_0": {"length": 28, "quality": 0.6086956521739131, "section_id": 5443}}, "n3337": {"so_9148329_9148358_0": {"length": 28, "quality": 0.6086956521739131, "section_id": 5238}}, "n4659": {"so_9148329_9148358_0": {"length": 28, "quality": 0.6086956521739131, "section_id": 6870}}}, "9148618": {"Id": "9148618", "PostTypeId": "2", "Body": "<p>I would like to add few details to answer of <a href=\"https://stackoverflow.com/users/19563/charles-bailey\">Charles Bailey</a>:</p>\n<pre><code>class A\n{\npublic:\n    class B * b;\n    class C {} *c;\n    int d;\n} a;\n\nB* globalB;\n// C* globalC;  identifier \"C\" is undefined here\n\nint main(int argc, char *argv[])\n{\n    a.d = 1;\n    cout &lt;&lt; a.d;\n}\n</code></pre>\n<p>Yes, it defines incomplete type <code>B</code> and <code>b</code> as a pointer to <code>B</code> at once. But here comes the fun:<br>\n<em>\"An exception to the scope visibility of a nested class declaration is when a type name is declared together with a forward declaration. In this case, the class name declared by the forward declaration is visible outside the enclosing class, with its scope defined to be the smallest enclosing non-class scope.\"</em> (<a href=\"http://msdn.microsoft.com/en-us/library/x23h0937(v=vs.80).aspx\" rel=\"nofollow noreferrer\">Nested Class Declarations</a>)</br></p>\n<p>Which means that type <code>B</code> is defined out of scope <code>A</code> which allows you to define variable <code>globalB</code>. If you don't want <code>B</code> to be defined out of scope <code>A</code>, you can use <code>{}</code> just like it is used with type <code>C</code> in my example.</p>\n<p>By the way, this example is correct and its output is: <code>1</code></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-02-05T11:05:26.473", "Score": "1", "CreationDate": "2012-02-05T10:49:26.530", "ParentId": "9148329", "CommentCount": "1", "OwnerUserId": "1168156", "LastEditDate": "2017-05-23T12:20:02.143"}});