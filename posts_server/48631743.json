post_cb({"bq_ids": {"n4140": {"so_48631743_48632723_2": {"length": 14, "quality": 0.7368421052631579, "section_id": 641}, "so_48631743_48632723_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 311}, "so_48631743_48632723_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 641}}, "n3337": {"so_48631743_48632723_2": {"length": 14, "quality": 0.7368421052631579, "section_id": 631}, "so_48631743_48632723_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 302}, "so_48631743_48632723_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 631}}, "n4659": {"so_48631743_48632723_2": {"length": 14, "quality": 0.7368421052631579, "section_id": 669}, "so_48631743_48632723_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 319}, "so_48631743_48632723_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 669}}}, "48631743": {"ViewCount": "190", "Body": "<p>Another \"who's right between g++ and clang++ ?\" question for C++ standard gurus.</p>\n<p>The code is the following</p>\n<pre><code>template &lt;typename ...&gt;\nstruct bar\n { };\n\ntemplate &lt;typename ... Ts&gt;\nvoid foo (bar&lt;Ts...&gt; const &amp;)\n { }\n\nint main ()\n {\n   foo&lt;int&gt;(bar&lt;int, long&gt;{});     // g++ and clang++ compile\n\n   (*(&amp;foo&lt;int&gt;))(bar&lt;int, long&gt;{});  // g++ and clang++ give error\n\n   (&amp;foo&lt;int&gt;)(bar&lt;int, long&gt;{});  // clang++ compiles; g++ gives error\n }\n</code></pre>\n<p>The template function <code>foo()</code> receive a variadic template parameter <code>bar</code>.</p>\n<p>The first call </p>\n<pre><code>   foo&lt;int&gt;(bar&lt;int, long&gt;{});     // g++ and clang++ compile\n</code></pre>\n<p>works for both clang++ ang g++.</p>\n<p>If I understand correctly, with <code>foo&lt;int&gt;</code> is explicated <strong>only</strong> the first template parameter and this doesn't complete the list of <code>Ts...</code> parameters. So the compiler look at the argument (a <code>bar&lt;int, long&gt;</code> object) and deduce the full list.</p>\n<p>The second call is different </p>\n<pre><code>     (*(&amp;foo&lt;int&gt;))(bar&lt;int, long&gt;{});  // g++ and clang++ give error\n</code></pre>\n<p>If I understand correctly, with <code>(&amp;foo&lt;int&gt;)</code> we get the pointer to the instantiation of <code>foo</code> where <code>Ts...</code> is exactly <code>int</code> (not only the first type of the list but the whole list) and dereferencing it (<code>*(&amp;foo&lt;int&gt;)</code>) and calling it with a wrong argument (a <code>bar&lt;int, long&gt;</code> object) we get (clang++ and g++) a compilation error.</p>\n<p>So far, so good.</p>\n<p>The problem arises with the third call</p>\n<pre><code>   (&amp;foo&lt;int&gt;)(bar&lt;int, long&gt;{});  // clang++ compiles; g++ gives error\n</code></pre>\n<p>that I was convinced (maybe I was wrong) equivalent the second one (we fix all template types in <code>Ts...</code>, then we call the function with a wrong parameter) but g++ seems agree (and gives error) where clang++ disagree (and compile without problem).</p>\n<p>The question, as usual, is: who's right ?</p>\n", "AcceptedAnswerId": "48632723", "Title": "g++ and clang++ different behaviour with pointer to variadic template functions", "CreationDate": "2018-02-05T21:25:49.517", "Id": "48631743", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2018-02-05T22:45:03.387", "Score": "11", "OwnerUserId": "6022656", "Tags": "<c++><c++11><templates><variadic-templates><template-deduction>", "AnswerCount": "1"}, "48632723": {"Id": "48632723", "PostTypeId": "2", "Body": "<p>Let's examine a simpler case:</p>\n<pre><code>template &lt;class A, class B&gt;void foo(B) {};\n\nint main()\n{\n    (&amp;foo&lt;char&gt;)(1);\n}\n</code></pre>\n<p>clang++ compiles this, while g++ fails with the following message:</p>\n<blockquote>\n<p id=\"so_48631743_48632723_0\">error: address of overloaded function with no contextual type information</p>\n</blockquote>\n<p>Same message is given for e.g. this program:</p>\n<pre><code>void moo(int) {};\nvoid moo(int*){};\n\nint main()\n{\n    &amp;moo != nullptr;\n}\n</code></pre>\n<p>Apparently, the intent is to refer to [over.over], which talks about taking the address of an overloaded function. This place in the standard specifies in what contexts an overloaded function name can be used (RHS of an assignment, an argument in a function call etc). However it says</p>\n<blockquote>\n<p id=\"so_48631743_48632723_1\">An overloaded function name shall not be used <em>without arguments</em> in contexts other than those listed. (emphasis mine)</p>\n</blockquote>\n<p>Now, is <code>foo</code> in <code>(&amp;foo&lt;char&gt;)(1)</code> used <em>without arguments</em>? g++ seems to sink so. However it happily compiles</p>\n<pre><code>(&amp;moo)(1);\n</code></pre>\n<p>from the second example. So we have at least some inconsistency here. The same rules govern taking an address of a function template and an overloaded set, so <code>(&amp;foo&lt;char&gt;)(1)</code> and <code>(&amp;moo)(1)</code> should be either both valid or both invalid. The standard itself seems to indicate that hey should both be valid:</p>\n<blockquote>\n<p id=\"so_48631743_48632723_2\">The overloaded function name can be preceded by the &amp; operator [...] [<em>Note</em>:  Any redundant set of parentheses surrounding the overloaded function name is ignored (5.1). \u2014 <em>end note</em>]</p>\n</blockquote>\n", "LastActivityDate": "2018-02-05T22:45:03.387", "Score": "3", "CreationDate": "2018-02-05T22:45:03.387", "ParentId": "48631743", "CommentCount": "1", "OwnerUserId": "775806"}});