post_cb({"36936908": {"CommentCount": "2", "ViewCount": "228", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2016-04-29T11:15:06.483", "LastActivityDate": "2016-04-29T11:55:17.523", "Title": "RAII char buffer", "AcceptedAnswerId": "36936985", "LastEditDate": "2016-04-29T11:22:30.157", "Id": "36936908", "Score": "0", "Body": "<p>I'd like to wrap few C functions for safe C++ usage. There is a C function which takes raw pointer to array and its size, like -</p>\n<pre><code>void function(char* bufferToFill, size_t bufsize)\n</code></pre>\n<p>And now, I am having trouble finding C++ object which can expose a raw pointer to be passed to such function. I would like to avoid using new[] and keeping in mind to delete[] it every time I throw an exception.</p>\n<p>std::string obviously cant expose its char*, std::vector similar, the only thing that comes to my mind is std::unique_ptr but it feels kinda odd (because its usually used to own an object, not array?)</p>\n<p>Whats the proper C++ way to solve such problem?\nThanks in advance</p>\n", "Tags": "<c++><raii>", "OwnerUserId": "5720907", "AnswerCount": "2"}, "36936985": {"ParentId": "36936908", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_36936908_36936985_0\">std::string obviously cant expose its char*, std::vector similar</p>\n</blockquote>\n<p>Of course they can; C++11 guarantees the storage for both <code>std::string</code><sup>1</sup> and <code>std::vector</code> to be contiguous, so you can do <code>&amp;str[0]</code> to obtain a pointer to the underlying data (<em>edit</em>: actually for <code>std::vector</code> <code>&amp;str[0]</code> is not ok if <code>str.size()==0</code>, however the <code>data()</code> method is guaranteed to work always).</p>\n<p>The validity of the pointer is subject to the usual references invalidation rules (i.e. it's valid as long as you don't perform any potentially reallocating operation).</p>\n<h3>Corner case: empty containers</h3>\n<p>While empty containers in this case are not an issue (why would someone pass a zero-length buffer to fill?) it's still useful to know that:</p>\n<ul>\n<li><p>for <code>std::string</code>, it's always safe to ask for <code>&amp;str[0]</code>, even if the string is empty; in facts, the standard says explicitly (at [string.access]):</p>\n<blockquote>\n<p id=\"so_36936908_36936985_1\"><em>Returns:</em> <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>, otherwise a reference to an object of type <code>T</code> with value <code>charT()</code>; the referenced value shall not be modified.</p>\n</blockquote></li>\n<li><p>for <code>std::vector</code>, probably it's not ok to call <code>&amp;str[0]</code> if the vector is empty; <code>operator[]</code> is specified in the general requirements for sequence containers, with operational semantic <code>*a.begin()</code>, which is undefined behavior if <code>size()</code> is 0; however, C++11 does provide the <code>data()</code> method, which always returns some kind of valid pointer (although to an empty valid range in the case of an empty vector)</p></li>\n</ul>\n<p>Unfortunately, you cannot just remember that <code>data()</code> is correct for both containers, as for <code>std::string</code> it returns a <code>const</code> pointer exactly as <code>c_str()</code>.</p>\n<hr>\n<ol>\n<li>In all the answer, where I say <code>std::string</code> I actually refer to any specialization of <code>std::basic_string</code>.</li>\n</ol>\n</hr>", "OwnerUserId": "214671", "LastEditorUserId": "214671", "LastEditDate": "2016-04-29T11:55:17.523", "Id": "36936985", "Score": "5", "CreationDate": "2016-04-29T11:18:40.710", "LastActivityDate": "2016-04-29T11:55:17.523"}, "bq_ids": {"n4140": {"so_36936908_36936985_1": {"section_id": 1617, "quality": 0.6428571428571429, "length": 9}}, "n3337": {"so_36936908_36936985_1": {"section_id": 1613, "quality": 0.6428571428571429, "length": 9}}, "n4659": {"so_36936908_36936985_1": {"section_id": 1770, "quality": 0.7142857142857143, "length": 10}}}, "36937057": {"ParentId": "36936908", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_36936908_36937057_0\">the only thing that comes to my mind is std::unique_ptr but it feels kinda odd (because its usually used to own an object, not array?)</p>\n</blockquote>\n<p>Another misconception here.</p>\n<p>An array is an object, and <a href=\"https://stackoverflow.com/q/16711697/560648\">the language specifically allows for <code>std::unique_ptr</code> of arrays</a>:</p>\n<pre><code>std::unique_ptr&lt;int[]&gt; p(new int[10]);\n</code></pre>\n", "OwnerUserId": "560648", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:16:10.220", "Id": "36937057", "Score": "3", "CreationDate": "2016-04-29T11:22:05.437", "LastActivityDate": "2016-04-29T11:22:05.437"}});