post_cb({"47321247": {"Id": "47321247", "PostTypeId": "2", "Body": "<p>Okay, based on a comment, I looked more deeply into the standard and what the class hierarchy is.</p>\n<p>I believe this is covered by the <code>basic_regex</code> constructors, in <code>C++11 28.8.2</code>, which are used by the higher levels. All of those constructors, such as:</p>\n<pre><code>basic_regex(const charT* p, flag_type f = regex_constants::ECMAScript);\n</code></pre>\n<p>use ECMAScript as the default engine.</p>\n<hr>\n<p>And, for what it's worth, the ECMAScript syntax explicitly calls out the <code>.*?</code> behaviour that sent me on this quest in the first place. The <code>?</code> is treated differently (i.e., is <em>not</em> the zero-or-one quantifier) when it immediately follows a quantifier (<code>*</code>, <code>+</code>, <code>?</code>, <code>{exact}</code>, <code>{min,}</code> and <code>{min,max}</code>) in that it makes the matching non-greedy:</p>\n<blockquote>\n<p id=\"so_47320905_47321247_0\">By default, all these quantifiers are greedy (i.e., they take as many characters that meet the condition as possible). This behavior can be overridden to ungreedy (i.e., take as few characters that meet the condition as possible) by adding a question mark, <code>?</code>, after the quantifier.</p>\n<p id=\"so_47320905_47321247_1\">For example, matching <code>\"(a+).*\"</code> against <code>\"aardvark\"</code> succeeds and yields <code>aa</code> as the first submatch, while matching <code>\"(a+?).*\"</code> against it also succeeds, but yields <code>a</code> as the first submatch.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2017-11-16T03:46:48.510", "CommentCount": "0", "CreationDate": "2017-11-16T03:46:48.510", "ParentId": "47320905", "Score": "1", "OwnerUserId": "14860"}, "bq_ids": {"n4140": {"so_47320905_47320905_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5057}}, "n3337": {"so_47320905_47320905_0": {"length": 15, "quality": 1.0, "section_id": 4854}}, "n4659": {"so_47320905_47320905_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6478}}}, "47320905": {"ViewCount": "68", "Body": "<p>Having seen a regex from one of my colleagues of <code>&lt;.*?&gt;</code> for stripping HTML tags, it didn't make sense to me to have zero-or-one occurrences (<code>?</code>) of zero-or-more characters (<code>.*</code>). Additionally, it appeared that it wouldn't work since<code>.*</code> is greedy so would strip out data <em>between</em> tags as well.</p>\n<p>But on testing this in an online regex, it appeared my colleague was correct in his assertion that it makes it non-greedy so I decided to go and check <em>why.</em></p>\n<p>In any case, that's just the background. Looking at the C++11 standard, I finally found out that there were multiple possible regex engines that were allowed, as per <code>28.5.2</code> and <code>table 128</code>, and that:</p>\n<blockquote>\n<p id=\"so_47320905_47320905_0\">A valid value of type <code>syntax_option_type</code> shall have exactly one of the\n  elements <code>ECMAScript</code>, <code>basic</code>, <code>extended</code>, <code>awk</code>, <code>grep</code>, <code>egrep</code>, set.</p>\n</blockquote>\n<p>However, that same section shows that the default used if not specified, <code>match_default</code>, is defined as zero, which clearly does <em>not</em> have one of the bits set.</p>\n<p>Nowhere in the standard can I find where the default engine is specified so I'm wondering whether that's implementation defined or whether I've just missed it.</p>\n", "Title": "What's the default regex engine in C++11?", "CreationDate": "2017-11-16T03:07:25.340", "LastActivityDate": "2017-11-16T03:46:48.510", "CommentCount": "2", "LastEditDate": "2017-11-16T03:19:36.287", "PostTypeId": "1", "LastEditorUserId": "4672588", "Id": "47320905", "Score": "3", "OwnerUserId": "14860", "Tags": "<c++><regex><c++11>", "AnswerCount": "1"}});