post_cb({"628675": {"Body": "<p>Be very very careful.</p>\n<p>For POD types these are shortcut operators.</p>\n<p>But if you define these operators for your own classes they are not shortcut. Because of this semantic difference in their usage under these different circumstances it is recommended that you do not define these operators.</p>\n<p>For the operator &amp;&amp; and operator || for POD types the evaluation order is left to right (otherwise short cutting would be hard :-) But for overloaded operators that you define, these are basically syntactic sugar to defining a method and thus the order of evaluation of the parameters is undefined.</p>\n", "CreationDate": "2009-03-10T02:05:38.840", "ParentId": "628526", "CommentCount": "6", "LastEditDate": "2009-03-10T02:17:49.513", "PostTypeId": "2", "LastEditorDisplayName": "Martin York", "LastActivityDate": "2009-03-10T02:17:49.513", "LastEditorUserId": "14065", "Id": "628675", "OwnerDisplayName": "Martin York", "Score": "4", "OwnerUserId": "14065"}, "40628563": {"Id": "40628563", "PostTypeId": "2", "Body": "<p>Your question comes down to <a href=\"http://en.cppreference.com/w/cpp/language/operator_precedence\" rel=\"nofollow noreferrer\">C++ operator precedence</a> and associativity. Basically, in expressions with multiple operators and no parentheses, the compiler constructs the expression tree by following these rules.</p>\n<p>For precedence, when you have something like <code>A op1 B op2 C</code>, you could group things as either <code>(A op1 B) op2 C</code> or <code>A op1 (B op2 C)</code>. If <code>op1</code> has higher precedence than <code>op2</code>, you'll get the first expression. Otherwise, you'll get the second one.</p>\n<p>For associativity, when you have something like <code>A op B op C</code>, you could again group thins as <code>(A op B) op C</code> or <code>A op (B op C)</code>. If <code>op</code> has left associativity, we end up with the first expression. If it has right associativity, we end up with the second one. This also works for operators at the same precedence level.</p>\n<p>In this particular case, <code>&amp;&amp;</code> has higher precedence than <code>||</code>, so the expression will be evaluated as <code>(a != \"\" &amp;&amp; it == seqMap.end()) || isEven</code>.</p>\n<p>The order itself is \"left-to-right\" on the expression-tree form. So we'll first evaluate <code>a != \"\" &amp;&amp; it == seqMap.end()</code>. If it's true the whole expression is true, otherwise we go to <code>isEven</code>. The procedure repeats itself recursively inside the left-subexpression of course.</p>\n<hr>\n<p>Interesting tidbits, but the concept of precedence has its roots in mathematic notation. The same thing happens in <code>a*b + c</code>, where <code>*</code> has higher precedence than <code>+</code>.</p>\n<p>Even more interesting/obscure, for a unparenthasiszed expression <code>A1 op1 A2 op2 ... opn-1 An</code>, where all operators have the same precedence, the number of binary expression trees we could form is given by the so called <a href=\"https://en.wikipedia.org/wiki/Catalan_number\" rel=\"nofollow noreferrer\">Catalan numbers</a>. For large <code>n</code>, these grow extremely fast. \nd</p>\n</hr>", "LastActivityDate": "2016-11-16T09:38:42.687", "CommentCount": "0", "CreationDate": "2016-11-16T09:38:42.687", "ParentId": "628526", "Score": "0", "OwnerUserId": "5910563"}, "628526": {"ViewCount": "26054", "Body": "<p>Does the ANSI standard <em>mandate</em> the logical operators to be short-circuited, in either C or C++?</p>\n<p>I'm confused for I recall the K&amp;R book saying your code shouldn't depend on these operations being short circuited, for they may not. Could someone please point out where in the standard it's said logic ops are always short-circuited? I'm mostly interested on C++, an answer also for C would be great.</p>\n<p>I also remember reading (can't remember where) that evaluation order isn't strictly defined, so your code shouldn't depend or assume functions within an expression would be executed in a specific order: by the end of a statement all referenced functions will have been called, but the compiler has freedom in selecting the most efficient order.</p>\n<p>Does the standard indicate the evaluation order of this expression?</p>\n<pre><code>if( functionA() &amp;&amp; functionB() &amp;&amp; functionC() ) cout&lt;&lt;\"Hello world\";\n</code></pre>\n", "AcceptedAnswerId": "628554", "Title": "Is short-circuiting logical operators mandated? And evaluation order?", "CreationDate": "2009-03-10T00:23:39.303", "Id": "628526", "CommentCount": "4", "FavoriteCount": "27", "PostTypeId": "1", "LastEditDate": "2017-05-22T06:58:34.460", "LastEditorDisplayName": "&#211;lafur Waage", "OwnerDisplayName": "Joe Pineda", "LastEditorUserId": "584518", "LastActivityDate": "2017-05-22T06:58:34.460", "Score": "110", "OwnerUserId": "21258", "Tags": "<c++><c><logical-operators><short-circuiting>", "AnswerCount": "7"}, "628532": {"Id": "628532", "PostTypeId": "2", "Body": "<p>If you trust Wikipedia:</p>\n<blockquote>\n<p id=\"so_628526_628532_0\">[<code>&amp;&amp;</code> and <code>||</code>] are semantically distinct from the bit-wise operators &amp; and | because they will never evaluate the right operand if the result can be determined from the left alone</p>\n</blockquote>\n<p><a href=\"http://en.wikipedia.org/wiki/C_(programming_language)#Characteristics\" rel=\"nofollow noreferrer\">http://en.wikipedia.org/wiki/C_(programming_language)#Characteristics</a></p>\n", "OwnerDisplayName": "Ben Alpert", "LastActivityDate": "2009-03-10T00:27:38.733", "Score": "0", "CreationDate": "2009-03-10T00:27:38.733", "ParentId": "628526", "CommentCount": "2", "OwnerUserId": "49485"}, "628538": {"Body": "<p>Short circuit evaluation, and order of evaluation, is a mandated semantic standard in both C and C++.</p>\n<p>If it wasn't, code like this would not be a common idiom</p>\n<pre><code>   char* pChar = 0;\n   // some actions which may or may not set pChar to something\n   if ((pChar != 0) &amp;&amp; (*pChar != '\\0')) {\n      // do something useful\n\n   }\n</code></pre>\n<p>Section <strong>6.5.13 Logical AND operator</strong> of the C99 specification <a href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf\" rel=\"noreferrer\">(PDF link)</a> says</p>\n<blockquote>\n<p id=\"so_628526_628538_0\">(4). Unlike the bitwise binary &amp; operator, the &amp;&amp; operator guarantees\n  left-to-right evaluation; there is a\n  sequence point after the evaluation of\n  the first operand. If the first\n  operand compares equal to 0, the\n  second operand is not evaluated.</p>\n</blockquote>\n<p>Similarly, section <strong>6.5.14 Logical OR operator</strong> says</p>\n<blockquote>\n<p id=\"so_628526_628538_1\">(4) Unlike the bitwise | operator, the ||\n  operator guarantees left-to-right\n  evaluation; there is a sequence point\n  after the evaluation of the first\n  operand. If the first operand compares\n  unequal to 0, the second operand is\n  not evaluated.</p>\n</blockquote>\n<p>Similar wording can be found in the C++ standards, <a href=\"http://www.csci.csusb.edu/dick/c++std/cd2/index.html\" rel=\"noreferrer\">check section 5.14 in this draft copy</a>. As checkers notes in another answer, if you override &amp;&amp; or ||, then both operands must be evaluated as it becomes a regular function call.</p>\n", "CreationDate": "2009-03-10T00:28:49.073", "ParentId": "628526", "CommentCount": "5", "LastEditDate": "2009-03-10T00:53:14.943", "PostTypeId": "2", "LastEditorDisplayName": "Paul Dixon", "LastActivityDate": "2009-03-10T00:53:14.943", "LastEditorUserId": "6521", "Id": "628538", "OwnerDisplayName": "Paul Dixon", "Score": "66", "OwnerUserId": "6521"}, "bq_ids": {"n4140": {"so_628526_628533_0": {"length": 24, "quality": 0.8, "section_id": 6163}, "so_628526_628533_1": {"length": 27, "quality": 0.8709677419354839, "section_id": 6165}}, "n3337": {"so_628526_628533_0": {"length": 25, "quality": 0.8333333333333334, "section_id": 5924}, "so_628526_628533_1": {"length": 27, "quality": 0.8709677419354839, "section_id": 5926}}, "n4659": {"so_628526_628533_0": {"length": 24, "quality": 0.8, "section_id": 7660}, "so_628526_628533_1": {"length": 27, "quality": 0.8709677419354839, "section_id": 7662}}}, "628554": {"Body": "<p>Yes, short-circuiting and evaluation order are required for operators <code>||</code> and <code>&amp;&amp;</code> in both C and C++ standards.</p>\n<p>C++ standard says (there should be an equivalent clause in the C standard):</p>\n<blockquote>\n<p id=\"so_628526_628554_0\"><strong>1.9.18</strong></p>\n<p id=\"so_628526_628554_1\"><em>In the evaluation of the following expressions</em></p>\n<pre><code>a &amp;&amp; b\na || b\na ? b : c\na , b\n</code></pre>\n<p id=\"so_628526_628554_2\"><em>using the built-in meaning of the operators in these expressions, <strong>there is a sequence point after the evaluation of the first expression</strong> (12).</em></p>\n</blockquote>\n<p>In C++ there is an extra trap: short-circuiting does <strong>NOT</strong> apply to types that overload operators <code>||</code> and <code>&amp;&amp;</code>.</p>\n<blockquote>\n<p id=\"so_628526_628554_3\"><em>Footnote 12: The operators indicated in this paragraph are the built-in operators, as described in clause 5. When one of these operators is overloaded (clause 13) in a valid context, thus designating a user-defined operator function, the expression designates a function invocation, and the operands form an argument list, <strong>without an implied sequence point between them.</strong></em></p></blockquote>\n<p>It is usually not recommended to overload these operators in C++ unless you have a very specific requirement. You can do it, but it may break expected behaviour in other people's code, especially if these operators are used indirectly via instantiating templates with the type overloading these operators.</p>\n", "CreationDate": "2009-03-10T00:37:18.570", "ParentId": "628526", "CommentCount": "11", "LastEditDate": "2011-09-23T15:07:58.563", "PostTypeId": "2", "LastEditorDisplayName": "Checkers", "LastActivityDate": "2011-09-23T15:07:58.563", "LastEditorUserId": "23643", "Id": "628554", "OwnerDisplayName": "Checkers", "Score": "120", "OwnerUserId": "23643"}, "628537": {"Body": "<p>Straight from good old K&amp;R:</p>\n<blockquote>\n<p id=\"so_628526_628537_0\">C guarantees that <code>&amp;&amp;</code> and <code>||</code> are evaluated left to right \u2014 we shall soon see cases where this matters.</p>\n</blockquote>\n", "CreationDate": "2009-03-10T00:28:49.027", "ParentId": "628526", "CommentCount": "2", "LastEditDate": "2015-05-20T06:55:16.007", "PostTypeId": "2", "OwnerDisplayName": "John T", "LastEditorUserId": "183120", "LastActivityDate": "2015-05-20T06:55:16.007", "Id": "628537", "Score": "11", "OwnerUserId": "36457"}, "628533": {"Body": "<p>Yes, it mandates that (both evaluation order and short circuit). In your example if all functions return true, the order of the calls are strictly from functionA then functionB and then functionC. Used for this like</p>\n<pre><code>if(ptr &amp;&amp; ptr-&gt;value) { \n    ...\n}\n</code></pre>\n<p>Same for the comma operator:</p>\n<pre><code>// calls a, then b and evaluates to the value returned by b\n// which is used to initialize c\nint c = (a(), b()); \n</code></pre>\n<p>One says between the left and right operand of <code>&amp;&amp;</code>, <code>||</code>, <code>,</code> and between the first and second/third operand of <code>?:</code> (conditional operator) is a \"sequence point\". Any side effects are evaluated completely before that point. So, this is safe:</p>\n<pre><code>int a = 0;\nint b = (a++, a); // b initialized with 1, and a is 1\n</code></pre>\n<p>Note that the comma operator is not to be confused with the syntactical comma used to separate things:</p>\n<pre><code>// order of calls to a and b is unspecified!\nfunction(a(), b());\n</code></pre>\n<p>The C++ Standard says in <code>5.14/1</code>:</p>\n<blockquote>\n<p id=\"so_628526_628533_0\">The &amp;&amp; operator groups left-to-right. The operands are both implicitly converted to type bool (clause 4).\n  The result is true if both operands are true and false otherwise. Unlike &amp;, &amp;&amp; guarantees left-to-right\n  evaluation: the second operand is not evaluated if the first operand is false.</p>\n</blockquote>\n<p>And in <code>5.15/1</code>:</p>\n<blockquote>\n<p id=\"so_628526_628533_1\">The || operator groups left-to-right. The operands are both implicitly converted to bool (clause 4). It returns true if either of its operands is true, and false otherwise. Unlike |, || guarantees left-to-right evaluation; moreover, the second operand is not evaluated if the first operand evaluates to true.</p>\n</blockquote>\n<p>It says for both next to those:</p>\n<blockquote>\n<p id=\"so_628526_628533_2\">The result is a bool. All side effects of the first expression except for destruction of temporaries (12.2) happen before the second expression is evaluated.</p>\n</blockquote>\n<p>In addition to that, <code>1.9/18</code> says</p>\n<blockquote>\n<p id=\"so_628526_628533_3\">In the evaluation of each of the expressions</p>\n<ul>\n<li><code>a &amp;&amp; b</code></li>\n<li><code>a || b</code></li>\n<li><code>a ? b : C</code></li>\n<li><code>a , b</code></li>\n</ul>\n<p id=\"so_628526_628533_4\">using the built-in meaning of the operators in these expressions (5.14, 5.15, 5.16, 5.18), there is a sequence point after the evaluation of the first expression.</p>\n</blockquote>\n", "CreationDate": "2009-03-10T00:27:53.397", "ParentId": "628526", "CommentCount": "0", "LastEditDate": "2009-03-10T00:51:54.727", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2009-03-10T00:51:54.727", "LastEditorUserId": "34509", "Id": "628533", "OwnerDisplayName": "litb", "Score": "17", "OwnerUserId": "34509"}});