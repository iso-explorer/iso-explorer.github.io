post_cb({"16362551": {"CommentCount": "0", "ViewCount": "64", "CreationDate": "2013-05-03T15:31:06.600", "LastActivityDate": "2013-05-03T15:51:21.607", "Title": "Order of evaluation of names declared in class", "AcceptedAnswerId": "16362795", "PostTypeId": "1", "Id": "16362551", "Score": "0", "Body": "<p>There is this code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nconst int c = 3;\n\nstruct A {\n   static int f() { return c; }\n   static const int c = 2;\n};\n\nint main() {\n   std::cout &lt;&lt; A::f() &lt;&lt; std::endl; // 2\n   return 0;\n}\n</code></pre>\n<p>How does it happen that variable <code>c</code> defined <strong>inside</strong> class <code>A</code> is used in function <code>f</code> instead of variable <code>c</code> defined in global scope although global variable <code>c</code> is declared first?</p>\n", "Tags": "<c++><scope>", "OwnerUserId": "738811", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_16362551_16362649_0": {"section_id": 7044, "quality": 0.9305555555555556, "length": 67}}, "n3337": {"so_16362551_16362649_0": {"section_id": 6789, "quality": 0.9305555555555556, "length": 67}}, "n4659": {"so_16362551_16362649_0": {"section_id": 8541, "quality": 0.9305555555555556, "length": 67}}}, "16362795": {"ParentId": "16362551", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Is not a question of declaring order but of variable scope, the used variable are searched before in the current method/function after in the class/struct and a the and in the global context,\nexample:</p>\n<pre><code>#include &lt;iostream&gt;\n\nconst int c = 3;\n\nstruct A {\n   static void print() { \n      int c = 4\n      std::cout &lt;&lt;\"Method Scope:\"&lt;&lt; c &lt;&lt; std::endl; // 4\n      std::cout &lt;&lt;\"Class/Struct Scope:\"&lt;&lt; A::c &lt;&lt; std::endl; // 2 here you can use alse ::A::c\n      std::cout &lt;&lt;\"Global Scope:\"&lt;&lt; ::c &lt;&lt; std::endl; // 3\n   }\n   static const int c = 2;\n};\n\nstruct B {\n   static void print() { \n      std::cout &lt;&lt;\"Method Scope:\"&lt;&lt; c &lt;&lt; std::endl; // 2\n      std::cout &lt;&lt;\"Class/Struct Scope:\"&lt;&lt; B::c &lt;&lt; std::endl; // 2 here you can use alse ::A::c\n      std::cout &lt;&lt;\"Global Scope:\"&lt;&lt; ::c &lt;&lt; std::endl; // 3\n   }\n   static const int c = 2;\n};\n\nstruct C {\n   static void print() { \n      std::cout &lt;&lt;\"Method Scope:\"&lt;&lt; c &lt;&lt; std::endl; // 3\n      //std::cout &lt;&lt;\"Class/Struct Scope:\"&lt;&lt; C::c &lt;&lt; std::endl; //is inpossible ;)\n      std::cout &lt;&lt;\"Global Scope:\"&lt;&lt; ::c &lt;&lt; std::endl; // 3\n   }\n};\n\nint main() {\n   A::print();\n   B::print();\n   C::print();\n   return 0;\n}\n</code></pre>\n", "OwnerUserId": "810633", "LastEditorUserId": "810633", "LastEditDate": "2013-05-03T15:51:21.607", "Id": "16362795", "Score": "1", "CreationDate": "2013-05-03T15:43:36.787", "LastActivityDate": "2013-05-03T15:51:21.607"}, "16362649": {"ParentId": "16362551", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>imagine that you have long code which uses many variables, do you want them to be called instead these from a class to which function belongs? stating:</p>\n<p><code>a</code> or <code>b</code> </p>\n<p>in class means</p>\n<p><code>this-&gt;a</code></p>\n<p><code>this-&gt;b</code> </p>\n<p>and if you want global variable to be visible you have to use it like</p>\n<p><code>::a</code> or  <code>::b</code> inside this function, so via:</p>\n<pre><code>static int f() { return ::c; }\n</code></pre>\n<p>From the standard docs, <em>Sec 3.3.1</em></p>\n<blockquote>\n<p id=\"so_16362551_16362649_0\">Every name is introduced in some portion of program text called a declarative region, which is the largest part of the\n  program in which that name is valid, that is, in which that name may be used as an unqualified name to refer to the\n  same entity. In general, each particular name is valid only within some possibly discontiguous portion of program text\n  called its scope. To determine the scope of a declaration, it is sometimes convenient to refer to the potential scope of\n  a declaration. The scope of a declaration is <em>the same</em> as its potential scope <strong>unless the potential scope contains another\n  declaration of the same name.</strong> In that case, the potential scope of the declaration in <strong>the inner (contained) declarative\n  region is excluded from the scope of the declaration in the outer (containing) declarative region.</strong></p>\n</blockquote>\n<p>this means that the potential scope is same as the scope of the declaration unless another (inner) declaration occurs. If occurred, the potential scope of the outer declaration is <em>removed</em> and <strong>just</strong> the inner declaration's holds, so your global variable is hidden.</p>\n", "OwnerUserId": "1141471", "LastEditorUserId": "1141471", "LastEditDate": "2013-05-03T15:41:50.853", "Id": "16362649", "Score": "0", "CreationDate": "2013-05-03T15:36:47.750", "LastActivityDate": "2013-05-03T15:41:50.853"}, "16362588": {"ParentId": "16362551", "CommentCount": "0", "Body": "<p>It does not matter which variable is declared first: if a class has a variable with the same name in it, that variable trumps the global variable. Otherwise you could get existing code in a lot of trouble simply by declaring a global variable with a name of one of its member variables!</p>\n<p>Of course your class can use scope resolution operator to reference the global <code>c</code> directly:</p>\n<pre><code>static int f() { return ::c; }\n</code></pre>\n<p>Now <a href=\"http://ideone.com/qhsfA6\" rel=\"nofollow\">your program will print <code>3</code> instead of <code>2</code></a>.</p>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "16362588", "Score": "3", "CreationDate": "2013-05-03T15:33:31.103", "LastActivityDate": "2013-05-03T15:33:31.103"}});