post_cb({"3524167": {"ParentId": "3524053", "CommentCount": "4", "Body": "<p>Better would be</p>\n<pre><code>char four[] = \"four\";\n</code></pre>\n", "OwnerUserId": "182774", "PostTypeId": "2", "Id": "3524167", "Score": "2", "CreationDate": "2010-08-19T16:55:30.150", "LastActivityDate": "2010-08-19T16:55:30.150"}, "3524053": {"CommentCount": "2", "ViewCount": "894", "PostTypeId": "1", "LastEditorUserId": "116908", "CreationDate": "2010-08-19T16:42:43.600", "LastActivityDate": "2010-08-19T17:06:52.093", "Title": "char four[4] = \"four\"; What are the correct semantics for this statement?", "AcceptedAnswerId": "3524071", "LastEditDate": "2010-08-19T17:06:52.093", "Id": "3524053", "Score": "7", "Body": "<pre><code>int main(void)\n{\n    char four[4] = \"four\";\n    return 0;\n}\n</code></pre>\n<p>When compiled as a C++ program, G++ reports</p>\n<p><strong>xxx.cpp: In function int main():</strong></p>\n<p><strong>xxx.cpp:3: error: initializer-string for array of chars is too long</strong></p>\n<p>When compiled a a C program, GCC reports no error.</p>\n<p>It appears to me, that the assignment is correctly copying all 4 bytes into the variable, as I expected.</p>\n<p>So my question boils down to.....</p>\n<p><strong>Is the observed behavior in C correct or am I touching an undefined behavior somewhere,\nor is it something else altogether?</strong></p>\n", "Tags": "<c++><c><arrays><initialization><string-literals>", "OwnerUserId": "7734", "AnswerCount": "4"}, "3524071": {"ParentId": "3524053", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Short answer: your code is valid C, but not valid C++.</p>\n<p>Long Aswer:</p>\n<p><code>\"four\"</code> is actually 5 characters long - there is a <code>\\0</code> added there for you.  In section <strong>6.7.8 Initialization</strong>, paragraph 13, the C standard says:</p>\n<blockquote>\n<p id=\"so_3524053_3524071_0\">An array of character type may be initialized by a character string literal, optionally enclosed in braces. Successive characters of the character string literal (including the terminating null character if there is room or if the array is of unknown size) initialize the elements of the array.</p>\n</blockquote>\n<p>So the <code>\\0</code> is just ignored in your program when it is compiled as C. C++ is treating it differently.  In fact, this particular case is called out <em>explicitly</em> in the C++ spec (Section <strong>8.5.2 Character arrays</strong>, paragraph 2):</p>\n<blockquote>\n<p id=\"so_3524053_3524071_1\">There shall not be more initializers than there are array elements. [ <em>Example:</em> </p>\n<pre><code>char cv[4] = \"asdf\";  // error\n</code></pre>\n<p id=\"so_3524053_3524071_2\">is ill-formed since there is no space for the implied trailing <code>\u2019\\0\u2019</code>. \u2014 <em>end example</em> ]</p>\n</blockquote>\n", "OwnerUserId": "116908", "LastEditorUserId": "116908", "LastEditDate": "2010-08-19T16:58:29.257", "Id": "3524071", "Score": "22", "CreationDate": "2010-08-19T16:44:03.163", "LastActivityDate": "2010-08-19T16:58:29.257"}, "3524258": {"ParentId": "3524053", "CommentCount": "5", "Body": "<p>What you're seeing is a difference between C and C++. C allows you to have extra initializers, which are ignored. C++ prohibits this -- if you specify a size for a string (or array) it <em>must</em> be large enough to accommodate all the initializers (including the NUL terminator, in the case of a string), or the code is ill-formed (standardese for \"it's not allowed -- expect the compiler to reject it\").</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "3524258", "Score": "1", "CreationDate": "2010-08-19T17:04:20.847", "LastActivityDate": "2010-08-19T17:04:20.847"}, "bq_ids": {"n4140": {"so_3524053_3524071_1": {"section_id": 3315, "quality": 0.875, "length": 7}, "so_3524053_3524071_0": {"section_id": 3314, "quality": 0.5357142857142857, "length": 15}, "so_3524053_3524071_2": {"section_id": 3315, "quality": 0.75, "length": 6}}, "n3337": {"so_3524053_3524071_1": {"section_id": 3185, "quality": 0.875, "length": 7}, "so_3524053_3524071_2": {"section_id": 3185, "quality": 0.75, "length": 6}}, "n4659": {"so_3524053_3524071_1": {"section_id": 4081, "quality": 0.875, "length": 7}, "so_3524053_3524071_2": {"section_id": 4081, "quality": 0.75, "length": 6}, "so_3524053_3524071_0": {"section_id": 4080, "quality": 0.5357142857142857, "length": 15}}}, "3524093": {"ParentId": "3524053", "CommentCount": "0", "Body": "<p>The string \"four\" actually contains five bytes: the four letters plus a zero byte (\\0) as a string terminator. It's been a while since I've written C or C++, but I would guess the C compiler is silently ignoring it for whatever reason.</p>\n", "OwnerUserId": "222372", "PostTypeId": "2", "Id": "3524093", "Score": "2", "CreationDate": "2010-08-19T16:46:12.923", "LastActivityDate": "2010-08-19T16:46:12.923"}});