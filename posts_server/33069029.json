post_cb({"33069029": {"CommentCount": "9", "ViewCount": "855", "CreationDate": "2015-10-11T19:11:49.583", "LastActivityDate": "2015-10-30T21:34:49.443", "Title": "Why does operator() change for std::function in C++17?", "FavoriteCount": "4", "PostTypeId": "1", "Id": "33069029", "Score": "25", "Body": "<p>The following code is supposedly illegal in C++14 but legal in C++17:</p>\n<pre><code>#include &lt;functional&gt;\n\nint main()\n{\n    int x = 1729;\n    std::function&lt;void (int&amp;)&gt; f(\n        [](int&amp; r) { return ++r; });\n    f(x);\n}\n</code></pre>\n<p>Don't bother testing it, you'll get inconsistent results making it difficult to suss whether it's a bug or intentional behavior. However, comparing two drafts (N4140 vs N4527, both can be found on github.com/cplusplus/draft), there's one significant difference in [func.wrap.func.inv]. Paragraph 2:</p>\n<blockquote>\n<p id=\"so_33069029_33069029_0\">Returns: Nothing if R is void, otherwise the return value of INVOKE (f, std::forward(args)..., R).</p>\n</blockquote>\n<p>The above was removed between drafts. The implication is that the return value of the lambda is now <strong>silently discarded</strong>. This seems like a misfeature. Can anyone explain the reasoning?</p>\n", "Tags": "<c++><c++14><c++1z>", "OwnerUserId": "5434082", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33069029_33069029_0": {"section_id": 4681, "quality": 0.625, "length": 5}}, "n3337": {"so_33069029_33069029_0": {"section_id": 4490, "quality": 0.625, "length": 5}}, "n4659": {"so_33069029_33069029_0": {"section_id": 823, "quality": 0.625, "length": 5}}}, "33441564": {"ParentId": "33069029", "LastEditDate": "2017-05-23T12:02:14.477", "CommentCount": "0", "CreationDate": "2015-10-30T17:22:22.190", "OwnerUserId": "1774667", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "33441564", "Score": "16", "Body": "<p>There was a <a href=\"https://stackoverflow.com/q/25395605/1774667\">ridiculous defect in the standard</a> about <code>std::function&lt;void(Args...)&gt;</code>.  By the wording of the standard, no (non-trivial)<sup>1</sup> use of <code>std::function&lt;void(Args...)&gt;</code> was legal, because nothing can be \"implicitly converted to\" <code>void</code> (not even <code>void</code>).</p>\n<p><code>void foo() {}  std::function&lt;void()&gt; f = foo;</code> was not legal in C++14.  Oops.</p>\n<p>Some compilers took the bad wording that made <code>std::function&lt;void(Args...)&gt;</code> completely useless, and applied the logic only to passed-in callables where the return value was <em>not</em> <code>void</code>.  Then they concluded it was illegal to pass a function returning <code>int</code> to <code>std::function&lt;void(Args...)&gt;</code> (or any other non-<code>void</code> type).  They did not take it to the logical end and ban functions returning <code>void</code> as well (the <code>std::function</code> requirements make no special case for signatures that match exactly: the same logic applies.)</p>\n<p>Other compilers just ignored the bad wording in the <code>void</code> return type case.</p>\n<p>The defect was basically that the return type of the invocation expression has to be implicitly convertible-to the return type of the <code>std::function</code>'s signature (see link above for more details).  And under the standard, <code>void</code> cannot be implicitly converted to <code>void</code><sup>2</sup>.</p>\n<p>So the defect was resolved.  <code>std::function&lt;void(Args...)&gt;</code> now accepts anything that can be invoked with <code>Args...</code>, and discards the return value, as many existing compilers implemented.  I presume this is because (A) the restriction was not ever intended by the language designers, or (B) having a way for a <code>std::function</code> that discards return values was desired.</p>\n<p><code>std::function</code> has <em>never</em> required exact match of arguments or return values, just compatibility.  If the incoming arguments can implicitly convert-from the signature arguments, and the return type can implicitly convert-to the return type, it was happy.</p>\n<p>And a function of type <code>int(int&amp;)</code> is, under many intuitive definitions, compatible with the signature <code>void(int&amp;)</code>, in that you can run it in a \"void context\".</p>\n<hr>\n<p><sup>1</sup> Basically, anything that makes <code>operator()</code> legal to call was not allowed.  You can create it, you can destroy it, you can test it (and know it is empty).  You cannot give it a function, even one that matches its signature exactly, or a function object or lambda.  Ridiculous.</p>\n<p><sup>2</sup> For <code>void</code> to be impliclty converted to <code>void</code> under the standard, it requires that the statement <code>void x = blah;</code>, where <code>blah</code> is an expression of type void, be valid; that statement is not valid, as you cannot create a variable of type <code>void</code>.</p>\n</hr>", "LastActivityDate": "2015-10-30T21:34:49.443"}});