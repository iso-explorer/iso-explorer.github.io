post_cb({"30747254": {"ParentId": "29090692", "CommentCount": "0", "Body": "<p>Ambiguity is determined by the ranking:</p>\n<ol>\n<li>Exact match: no conversion required, lvalue-to-rvalue conversion, qualification conversion, user-defined conversion of class type to the same class</li>\n<li>Promotion: integral promotion, floating-point promotion</li>\n<li>Conversion: integral conversion, floating-point conversion, floating-integral conversion, pointer conversion, pointer-to-member conversion, boolean conversion, user-defined conversion of a derived class to its base</li>\n</ol>\n<p>Exact match wins vs Promotion which wins vs Conversion.</p>\n<p>In the example:</p>\n<pre><code>void func(int, bool, float, int){cout &lt;&lt; \"int,bool,float,int\" &lt;&lt; endl;}\nvoid func(int, bool, int, int){cout &lt;&lt; \"int,int,int,int\" &lt;&lt; endl;}\n\nint main()\n{\n    func(1,1,3.4,4);\n}\n</code></pre>\n<p>Argument 1(<code>1</code>) is an exact match on both<br>\nArgument 2(<code>1</code>) is an exact match on both<br>\nArgument 3(<code>3.4</code>) can be converted into float and int - <strong>Ambiguity</strong> Neither is <em>better</em>.<br>\nArgument 4(<code>4</code>) is an exact match on both<br/></br></br></br></p>\n<p>But if we did this: <code>func(1,1,3.4f,4);</code> <br>(<code>3.4f</code>) is now an exact match!<br>\n<code>void func(int, bool, float, int)</code> then wins the battle.</br></br></p>\n", "OwnerUserId": "3677097", "PostTypeId": "2", "Id": "30747254", "Score": "0", "CreationDate": "2015-06-10T04:42:40.067", "LastActivityDate": "2015-06-10T04:42:40.067"}, "29090692": {"CommentCount": "5", "AcceptedAnswerId": "29090792", "PostTypeId": "1", "LastEditorUserId": "285235", "CreationDate": "2015-03-17T03:12:09.153", "LastActivityDate": "2015-07-11T18:42:43.230", "LastEditDate": "2015-03-17T13:12:12.030", "ViewCount": "1752", "FavoriteCount": "14", "Title": "How is ambiguity determined in the overload resolution algorithm?", "Id": "29090692", "Score": "60", "Body": "<p>I'm trying to understand the overloading resolution method.</p>\n<p>Why is this ambiguous:</p>\n<pre><code>void func(double, int, int, double) {}\nvoid func(int, double, double, double) {}\n\nvoid main()\n{\n    func(1, 2, 3, 4);\n}\n</code></pre>\n<p>but this isn't?</p>\n<pre><code>void func(int, int, int, double) {}\nvoid func(int, double, double, double) {}\n\nvoid main()\n{\n    func(1, 2, 3, 4);\n}\n</code></pre>\n<p>In the first case there are 2 exact parameters matches and 2 conversions against 1 exact match and 3 conversions, and in the second case there are 3 exact matches and 1 conversion against 1 exact matches and 3 conversions. </p>\n<p>So why is one ambiguous and one is not? What is the logic here?</p>\n", "Tags": "<c++><overload-resolution>", "OwnerUserId": "4013034", "AnswerCount": "3"}, "29090895": {"ParentId": "29090692", "CommentCount": "0", "Body": "<p>The wording from the standard (\u00a7[over.match.best]/1) is:</p>\n<blockquote>\n<p id=\"so_29090692_29090895_0\">[...] let ICS<em>i</em>(F) denote the implicit conversion sequence that converts the <em>i</em>-th argument in the list to the type of the <em>i</em>-th parameter of viable function F.<br>\n  [...] a viable function F1 is defined to be a better function than another viable function F2 if for all arguments <em>i</em>, ICS<em>i</em>(F1) is not a worse conversion sequence than ICS<em>i</em>(F2), and then<br>\n  \u2014 for some argument <em>j</em>, ICS<em>j</em>(F1) is a better conversion sequence than ICS<em>j</em>(F2)</br></br></p>\n</blockquote>\n<p>In your first case, the two functions fail the first test. For the first argument, the first function (taking <code>double</code>) has a worse conversion sequence than the second. For the second argument, the second function has a worse conversion sequence than the first (again, the <code>int</code> has to be promoted to <code>double</code> in one case, but not the other).</p>\n<p>Therefore, neither function passes the first rule, and the call is ambiguous.</p>\n<p>Between the second pair of functions, every argument to the the first function has at least as good of a conversion as the matching argument to the second function. We then go on to the second rule, and find that there is at least one argument (two, as a matter of fact) for which the first function has a better conversion (identity instead of promotion) than the second.</p>\n<p>Therefore, the first function is a better match, and will be selected.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "29090895", "Score": "13", "CreationDate": "2015-03-17T03:38:38.967", "LastActivityDate": "2015-03-17T03:38:38.967"}, "29090792": {"ParentId": "29090692", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The overload resolution rules only define a partial order on the set of all matches - if an overload <code>F1</code> is not a better match than <code>F2</code>, it does not imply that <code>F2</code> is a better match than <code>F1</code>. The exact partial order can be thought of as comparing two points in <code>k</code> dimensions, where the number of arguments is <code>k</code>. Lets define this partial order on points in <code>k</code>-dim space - <code>(x_1, x_2,..., x_k) &lt; (y_1, y_2,..., y_k) if x_i &lt;= y_i for all i and x_j &lt; y_j for at least one j</code>. This is exactly the partial order on candidate non-template functions defined by the standard.</p>\n<p>Lets look at your examples : </p>\n<pre><code>void func(double, int,    int,    double) {}\n                  vvv     vvv       vvv\n                 better  better    equal\nvoid func(int,    double, double, double) {}\n          vvv                       vvv\n         better                    equal\n</code></pre>\n<p>So neither overload is strictly better than the other.</p>\n<p>In your second example:</p>\n<pre><code>void func(int,   int,   int,   double) {}\n          vvv    vvv    vvv     vvv\n         equal  better better  equal\nvoid func(int, double, double, double) {}\n          vvv\n         equal\n</code></pre>\n<p>Now, the first overload is better than the second in all but one argument AND is never worse than the second. Thus, there is no ambiguity - the partial order does indeed declare the first one better.</p>\n<p>(The above description does not consider function templates. You can find more details at <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow\">cppreference</a>.)</p>\n", "OwnerUserId": "862351", "LastEditorUserId": "862351", "LastEditDate": "2015-07-11T18:42:43.230", "Id": "29090792", "Score": "53", "CreationDate": "2015-03-17T03:24:45.027", "LastActivityDate": "2015-07-11T18:42:43.230"}, "bq_ids": {"n4140": {"so_29090692_29090895_0": {"section_id": 603, "quality": 0.8048780487804879, "length": 33}}, "n3337": {"so_29090692_29090895_0": {"section_id": 593, "quality": 0.8048780487804879, "length": 33}}, "n4659": {"so_29090692_29090895_0": {"section_id": 629, "quality": 0.8048780487804879, "length": 33}}}});