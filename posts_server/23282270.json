post_cb({"23282270": {"CommentCount": "0", "AcceptedAnswerId": "23400769", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2014-04-25T00:39:40.840", "LastActivityDate": "2015-02-01T01:23:37.817", "LastEditDate": "2015-02-01T01:23:37.817", "ViewCount": "243", "FavoriteCount": "1", "Title": "C++ inheritance of methods but wrong return types (automatic casting? typeid(*this) ?)", "Id": "23282270", "Score": "3", "Body": "<p>I have a BaseClass with a method that returns a class object, and i have a DerivedClass. Now when I have a DerivedClass object and call the method defined in the BaseClass, the returning value is ob type BaseClass, and unfortunately not of type DerivedClass.</p>\n<pre><code>class BaseClass {\npublic:\n  typeof(*this) myMethod1() {return *this;} // nice if that would work\n  BaseClass&amp; myMethod2() {return *this;}\n  BaseClass myMethod3() {return BaseClass();}\n};\nclass DerivedClass : public BaseClass {};\n\nDerivedClass tmp;\ntmp.myMethod1();\ntmp.myMethod2();\ntmp.myMethod3();\n// all three methods should return an object of type DerivedClass,\n// but really they return an object of type BaseClass\n</code></pre>\n<p>So what I wish to achieve is to use methods of the superclass, but with return types of the derived class(automatic casting?). myMethod1() was the only thing I could think of, but it doesn't work.</p>\n<p>I've searched but didn't find anything satisfying.</p>\n", "Tags": "<c++><inheritance><casting><return><return-type>", "OwnerUserId": "3078330", "AnswerCount": "3"}, "23400769": {"ParentId": "23282270", "CommentCount": "1", "Body": "<p>Thanks for the answers. Maybe my question was not clear enough, but I could solve my problem myself by just adding another Constructor.</p>\n<p>To clarify: I had the BaseClass with a member method operator+() and the DerivedClass (without that member method). Now when I called the DerivedClass' operator+(), the return type was of BaseClass. I could simply add the operator+() to the DerivedClass, but instead, adding the Copy-Constructor which accepts a argument of the super-type (here BaseClass) solved the problem and the return types became correct automatically:</p>\n<pre><code>DerivedClass(const BaseClass&amp; src) : BaseClass(src) {}\n</code></pre>\n", "OwnerUserId": "3078330", "PostTypeId": "2", "Id": "23400769", "Score": "-1", "CreationDate": "2014-05-01T01:25:31.607", "LastActivityDate": "2014-05-01T01:25:31.607"}, "23282403": {"ParentId": "23282270", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Just use covariant return type rule, and be done.</p>\n<p>To restate it: If you return by pointer or reference, your override can explicitly have a return type derived from the type returned in the base class, and it is a valid virtual override.</p>\n<blockquote>\n<h3>10.3 Virtual functions \u00a77</h3>\n<p id=\"so_23282270_23282403_0\">The return type of an overriding function shall be either identical to the return type of the overridden\n  function or covariant with the classes of the functions. If a function D::f overrides a function B::f, the\n  return types of the functions are covariant if they satisfy the following criteria:<br>\n  \u2014 both are pointers to classes, both are lvalue references to classes, or both are rvalue references to\n  classes112<br>\n  \u2014 the class in the return type of B::f is the same class as the class in the return type of D::f, or is an\n  unambiguous and accessible direct or indirect base class of the class in the return type of D::f<br>\n  \u2014 both pointers or references have the same cv-qualification and the class type in the return type of D::f\n  has the same cv-qualification as or less cv-qualification than the class type in the return type of B::f.</br></br></br></p>\n</blockquote>\n<p>If you do not actually want to make it virtual, you can just define the functions in the derived class and call back to the base class.</p>\n<p>If you have multiple derived classes, you might consider using the CRTP to make that go faster:</p>\n<pre><code>template &lt;class X&gt;\nstruct CRTP : BaseClass {\n  X&amp; myMethod1() {return static_cast&lt;X&amp;&gt;(*this;)} // covariant maybe-virtual\n  X&amp; myMethod2() {return static_cast&lt;X&amp;&gt;(*this;)} // covariant maybe-virtual\n  X myMethod3() {return X();} // Not virtual\n};\nstruct DerivedClass1 : CRTP&lt;DerivedClass1&gt; {};\nstruct DerivedClass2 : CRTP&lt;DerivedClass2&gt; {};\nstruct DerivedClass3 : CRTP&lt;DerivedClass3&gt; {};\n</code></pre>\n", "OwnerUserId": "3204551", "LastEditorUserId": "3204551", "LastEditDate": "2014-04-25T01:11:09.757", "Id": "23282403", "Score": "2", "CreationDate": "2014-04-25T00:55:31.917", "LastActivityDate": "2014-04-25T01:11:09.757"}, "23282301": {"ParentId": "23282270", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You would like to use the CRTP (<a href=\"http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern</a>) pattern :</p>\n<pre><code>template &lt;class Derived&gt;\nclass BaseClass {\npublic:\n  Derived *myMethod1() {return static_cast&lt;Derived *&gt;(this);}\n  Derived&amp; myMethod2() {return static_cast&lt;Derived&amp;&gt;(*this);}\n};\nclass DerivedClass : public BaseClass&lt;DerivedClass&gt; {};\n\nDerivedClass tmp;\ntmp.myMethod1();\ntmp.myMethod2();\n</code></pre>\n", "OwnerUserId": "2687712", "LastEditorUserId": "2687712", "LastEditDate": "2014-04-25T00:54:58.893", "Id": "23282301", "Score": "5", "CreationDate": "2014-04-25T00:43:32.200", "LastActivityDate": "2014-04-25T00:54:58.893"}, "bq_ids": {"n4140": {"so_23282270_23282403_0": {"section_id": 7008, "quality": 0.9583333333333334, "length": 69}}, "n3337": {"so_23282270_23282403_0": {"section_id": 6754, "quality": 0.9583333333333334, "length": 69}}, "n4659": {"so_23282270_23282403_0": {"section_id": 8505, "quality": 0.9583333333333334, "length": 69}}}});