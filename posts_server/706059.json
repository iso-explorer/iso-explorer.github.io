post_cb({"706073": {"Id": "706073", "PostTypeId": "2", "Body": "<p>Is <code>const int * const x</code> not the same like <code>const int * x</code> becouse u already maked const?</p>\n", "OwnerDisplayName": "Stupid2.de", "LastActivityDate": "2009-04-01T15:33:15.177", "CommunityOwnedDate": "2009-04-01T15:33:15.177", "CommentCount": "2", "CreationDate": "2009-04-01T15:33:15.177", "ParentId": "706059", "Score": "0", "OwnerUserId": "81909"}, "706059": {"ViewCount": "750", "Body": "<p>I had the following C++ code, where the argument to my constructor in the declaration had different constness than the definition of the constructor.</p>\n<pre><code>//testClass.hpp\nclass testClass {\n  public:\n     testClass(const int *x);\n};\n\n//testClass.cpp\ntestClass::testClass(const int * const x) {}\n</code></pre>\n<p>I was able to compile this with no warnings using g++, should this code compile or at least give some warnings?  It turns out that the built-in C++ compiler on 64 bit solaris gave me a linker error, which is how I noticed that there was an issue.  </p>\n<p>What is the rule on matching arguments in this case?  Is it up to compilers?</p>\n", "AcceptedAnswerId": "706071", "Title": "Mismatch between constructor definition and declaration", "CreationDate": "2009-04-01T15:29:54.153", "Id": "706059", "CommentCount": "0", "LastEditDate": "2009-04-01T15:50:27.443", "PostTypeId": "1", "LastEditorDisplayName": "MikeT", "LastEditorUserId": "49514", "LastActivityDate": "2015-10-15T09:59:24.047", "Score": "5", "OwnerUserId": "49514", "Tags": "<c++><g++><solaris>", "AnswerCount": "4"}, "706070": {"Body": "<p>Think of it as the same difference between </p>\n<pre><code>//testClass.hpp\nclass testClass {\n  public:\n     testClass(const int x);\n};\n\n//testClass.cpp\ntestClass::testClass(int x) {}\n</code></pre>\n<p>Which also compiles.  You can't overload based on the const-ness of a pass-by-value parameter.  Imagine this case:</p>\n<pre><code>void f(int x) { }\nvoid f(const int x) { } // Can't compile both of these.\n\nint main()\n{\n   f(7); // Which gets called?\n}\n</code></pre>\n<p>From the standard:</p>\n<blockquote>\n<p id=\"so_706059_706070_0\">Parameter declarations that differ\n  only in the presence or absence of\n  const and/or volatile are equivalent.\n  That is, the const and volatile\n  type-specifiers for each parameter\n  type are ignored when determining\n  which function is being declared,\n  defined, or called. [Example:</p>\n</blockquote>\n<pre><code>typedef const int cInt;\nint f (int);\nint f (const int); // redeclaration of f(int)\nint f (int) { ... } // definition of f(int)\nint f (cInt) { ... } // error: redefinition of f(int)\n</code></pre>\n<blockquote>\n<p id=\"so_706059_706070_1\">\u2014end example] Only the const and\n  volatile type-specifiers at the\n  outermost level of the parameter type\n  specification are ignored in this\n  fashion; const and volatile\n  type-specifiers buried within a\n  parameter type specification are\n  significant and can be used to\n  distinguish overloaded function\n  declarations.112) In particular, \n  for any type T, \u201cpointer to T,\u201d\n  \u201cpointer to const T,\u201d and \u201cpointer to\n  volatile T\u201d are considered distinct\n  parameter types, as are \u201creference to\n  T,\u201d \u201creference to const T,\u201d and\n  \u201creference to volatile T.\u201d</p>\n</blockquote>\n", "CreationDate": "2009-04-01T15:32:39.687", "ParentId": "706059", "CommentCount": "0", "LastEditDate": "2009-04-01T15:40:57.123", "PostTypeId": "2", "LastEditorDisplayName": "Josh", "LastActivityDate": "2009-04-01T15:40:57.123", "LastEditorUserId": "8701", "Id": "706070", "OwnerDisplayName": "Josh", "Score": "4", "OwnerUserId": "8701"}, "706071": {"Body": "<p>In cases like this, the const specifier is allowed to be ommitted from the <em>declaration</em> because it doesn't change anything for the caller.  </p>\n<p>It matters only to the context of the implementation details.  So that's why it is on the <em>definition</em> but not the <em>declaration</em>.</p>\n<p>Example:</p>\n<pre><code>//Both f and g have the same signature\nvoid f(int x);\nvoid g(const int x);\n\nvoid f(const int x)//this is allowed\n{\n}\n\nvoid g(const int x)\n{\n}\n</code></pre>\n<p>Anyone calling f won't care that you are going to treat it as const because it is your own copy of the variable. </p>\n<p>With int * const x, it is the same, it is your copy of the pointer.  Whether you can point to something else doesn't matter to the caller. </p>\n<p>If you ommitted the first const though in const int * const, then that would make a difference because it matters to the caller if you change the data it is pointing to.  </p>\n<p><strong>Reference: <em>The C++ Standard</em>, 8.3.5 para 3:</strong></p>\n<blockquote>\n<p id=\"so_706059_706071_0\">\"Any cv-qualifier modifying a\n  parameter type is deleted ... Such\n  cv-qualifiers affect only the\n  definition of the parameter with the\n  body of the function; they do not\n  affect the function type\"</p>\n</blockquote>\n", "CreationDate": "2009-04-01T15:32:47.550", "ParentId": "706059", "CommentCount": "3", "LastEditDate": "2009-04-01T15:50:53.323", "PostTypeId": "2", "LastEditorDisplayName": "Brian R. Bondy", "LastActivityDate": "2009-04-01T15:50:53.323", "LastEditorUserId": "3153", "Id": "706071", "OwnerDisplayName": "Brian R. Bondy", "Score": "7", "OwnerUserId": "3153"}, "706100": {"Body": "<p>This example is covered explicitly in the overload resolution section, 13.1/3b4:</p>\n<blockquote>\n<p id=\"so_706059_706100_0\">Parameter declarations that differ only in the presence or absence of const and/or volatile are\n  equivalent. That is, the const and volatile type-specifiers for each parameter type are ignored\n  when determining which function is being declared, defined, or called.</p>\n<p id=\"so_706059_706100_1\">[Example:</p>\n<pre><code>typedef const int cInt;\nint f (int);\nint f (const int); // redeclaration of f(int)\nint f (int) { ... } // definition of f(int)\nint f (cInt) { ... } // error: redefinition of f(int)\n</code></pre>\n<p id=\"so_706059_706100_2\">\u2014end example]</p>\n</blockquote>\n<p>So, it is definitely OK.</p>\n", "CreationDate": "2009-04-01T15:39:04.680", "ParentId": "706059", "CommentCount": "0", "LastEditDate": "2015-10-15T09:59:24.047", "PostTypeId": "2", "OwnerDisplayName": "Richard Corden", "LastEditorUserId": "3982001", "LastActivityDate": "2015-10-15T09:59:24.047", "Id": "706100", "Score": "5", "OwnerUserId": "11698"}, "bq_ids": {"n4140": {"so_706059_706070_1": {"length": 38, "quality": 0.9047619047619048, "section_id": 558}, "so_706059_706070_0": {"length": 23, "quality": 0.92, "section_id": 558}, "so_706059_706100_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 558}}, "n3337": {"so_706059_706070_1": {"length": 38, "quality": 0.9047619047619048, "section_id": 549}, "so_706059_706100_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 549}, "so_706059_706070_0": {"length": 23, "quality": 0.92, "section_id": 549}}, "n4659": {"so_706059_706070_1": {"length": 38, "quality": 0.9047619047619048, "section_id": 581}, "so_706059_706100_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 581}, "so_706059_706070_0": {"length": 23, "quality": 0.92, "section_id": 581}}}});