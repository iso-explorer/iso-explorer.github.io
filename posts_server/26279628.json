post_cb({"26279717": {"ParentId": "26279628", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You can not rely on identical <em>string literals</em> having the same memory location, it is an implementation decision. The <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow\">C99 draft standard</a> tells us that it is unspecified whether the same string literal are distinct, from section <code>6.4.5</code> <em>String literals</em>:</p>\n<blockquote>\n<p id=\"so_26279628_26279717_0\">It is unspecified whether these arrays are distinct provided their\n  elements have the appropriate values. If the program attempts to\n  modify such an array, the behavior is undefined.</p>\n</blockquote>\n<p>For C++ this covered in the draft standard section <code>2.14.5</code> <em>String literals</em> which says:</p>\n<blockquote>\n<p id=\"so_26279628_26279717_1\">Whether all string literals are distinct (that is, are stored in\n  nonoverlapping objects) is implementation defined. The effect of\n  attempting to modify a string literal is undefined.</p>\n</blockquote>\n<p>The compiler is allowed to <em>pool</em> string literals but you would have to understand how it works from compiler to compiler and so this would not be portable and could potentially change. Visual Studio includes an <a href=\"http://msdn.microsoft.com/en-us/library/69ze775t.aspx\" rel=\"nofollow\">option for string literal pooling</a></p>\n<blockquote>\n<p id=\"so_26279628_26279717_2\">In some cases, identical string literals may be pooled to save space\n  in the executable file. In string-literal pooling, the compiler causes\n  all references to a particular string literal to point to the same\n  location in memory, instead of having each reference point to a\n  separate instance of the string literal. To enable string pooling, use\n  the /GF compiler option.</p>\n</blockquote>\n<p>Note that it does qualify with <em>In some cases</em>.</p>\n<p><code>gcc</code> does support pooling and across compilation units and you can turn it on via <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-fmerge-constants-847\" rel=\"nofollow\">-fmerge-constants</a>:</p>\n<blockquote>\n<p id=\"so_26279628_26279717_3\">Attempt to merge identical constants (string constants and\n  floating-point constants) across compilation units.</p>\n<p id=\"so_26279628_26279717_4\">This option is the default for optimized compilation if the assembler\n  and linker support it. Use -fno-merge-constants to inhibit this\n  behavior.</p>\n</blockquote>\n<p>note, the use of <em>attempt</em> and <em>if ... support it</em>.</p>\n<p>As for a rationale at least for C for not requiring <em>string literals</em> to be pooled we can see from this <a href=\"http://yarchive.net/comp/string_literals.html\" rel=\"nofollow\">archived comp.std.c discussion on string literals</a> that the rationale was due to the wide variety of implementation at the time:</p>\n<blockquote>\n<p id=\"so_26279628_26279717_5\">GCC might have served as an example but not as motivation. Partly the\n  desire to have string literals in ROMmable data was to support, er,\n  ROMming.  I vaguely recall having used a couple of C implementations\n  (before the X3J11 decision was made) where string literals were either\n  automatically pooled or stored in a constant data program section. \n  Given the existing variety of practice and the availability of an easy\n  work-around when the original UNIX properties were wanted, it seemed\n  best to not try to guarantee uniqueness and writability of string\n  literals.</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-02-11T19:37:32.393", "Id": "26279717", "Score": "10", "CreationDate": "2014-10-09T13:30:06.827", "LastActivityDate": "2015-02-11T19:37:32.393"}, "26279904": {"ParentId": "26279628", "CommentCount": "0", "Body": "<p><strong>No</strong>, you can't expect the same address. If it happens, happens. But there's nothing enforcing it.</p>\n<p>\u00a7 2.14.5/p12</p>\n<blockquote>\n<p id=\"so_26279628_26279904_0\">Whether all string literals are distinct (that is, are stored in\n  nonoverlapping objects) is implementation defined. The effect of\n  attempting to modify a string literal is undefined.</p>\n</blockquote>\n<p>The compiler can do as it pleases. They can be stored in different addresses if they are in different translation units or even if they are in the same translation unit, regardless of the fact that they're read-only memory.</p>\n<p>On MSVC, for instance, the addresses are totally different in both cases, but again: nothing prevents the compiler from merging the pointers' values (not even <em>where</em>, as far as the read-only section constraint is obliged).</p>\n", "OwnerUserId": "1938163", "PostTypeId": "2", "Id": "26279904", "Score": "3", "CreationDate": "2014-10-09T13:37:17.507", "LastActivityDate": "2014-10-09T13:37:17.507"}, "bq_ids": {"n4140": {"so_26279628_26279717_1": {"section_id": 5361, "quality": 0.8235294117647058, "length": 14}, "so_26279628_26279904_0": {"section_id": 5361, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_26279628_26279717_1": {"section_id": 5157, "quality": 0.8235294117647058, "length": 14}, "so_26279628_26279904_0": {"section_id": 5157, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_26279628_26279717_1": {"section_id": 6789, "quality": 0.8235294117647058, "length": 14}, "so_26279628_26279904_0": {"section_id": 6789, "quality": 0.8235294117647058, "length": 14}}}, "26279628": {"CommentCount": "11", "AcceptedAnswerId": "26279717", "PostTypeId": "1", "ClosedDate": "2016-12-25T18:46:09.627", "LastEditorUserId": "1708801", "CreationDate": "2014-10-09T13:26:03.423", "LastActivityDate": "2015-02-11T19:37:32.393", "LastEditDate": "2014-10-09T14:46:10.097", "ViewCount": "547", "FavoriteCount": "3", "Title": "String Literal address across translation units", "Id": "26279628", "Score": "6", "Body": "<p>I'd like to ask if is it portable to rely on string literal address across translation units? I.e:</p>\n<p>A given file <code>foo.c</code> has a reference to a string literal <code>\"I'm a literal!\"</code>, is it correct and portable to rely that in other given file, <code>bar.c</code> in instance, that the <strong>same string literal</strong> <code>\"I'm a literal!\"</code> will have the <strong>same memory address</strong>? Considering that each file will be translated to a individual <code>.o</code> file.</p>\n<p>For better illustration, follows an example code:</p>\n<pre><code># File foo.c\n/* ... */\nconst char * x = \"I'm a literal!\"\n\n# File bar.c\n/* ... */\nconst char * y = \"I'm a literal!\"\n\n# File test.c\n/* ... */\nextern const char * x;\nextern const char * y;\nassert (x == y); //Is this assertion going to fail?\n</code></pre>\n<p>And a gcc example command lines:</p>\n<pre><code>gcc -c -o foo.o -Wall foo.c\ngcc -c -o bar.o -Wall bar.c\ngcc -c -o test.o -Wall test.c\ngcc -o test foo.o bar.o test.o\n</code></pre>\n<p>What about in the same translation unit? Would this be reliable if the strings literals are in the <strong>same</strong> translation unit?</p>\n", "Tags": "<c++><c><string><string-literals><pooling>", "OwnerUserId": "2002198", "AnswerCount": "2"}});