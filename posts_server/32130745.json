post_cb({"32130883": {"ParentId": "32130745", "PostTypeId": "2", "CommentCount": "17", "Body": "<p><code>auto</code> mostly follows the same type deduction rules as template argument deduction. The only difference is that <code>auto</code> will deduce <code>std::initializer_list</code> from a <em>braced-init-list</em> in some cases, while template argument deduction doesn't do this.</p>\n<p>From N3337, <em>\u00a77.1.6.4 [dcl.spec.auto]</em></p>\n<blockquote>\n<p id=\"so_32130745_32130883_0\">6 \u00a0\u00a0... The type deduced for the variable <code>d</code> is then\n  the deduced <code>A</code> determined using the rules of template argument deduction from a function call (14.8.2.1), ...</p>\n</blockquote>\n<p>The behavior you're observing is the same as what template argument deduction would do when deducing types from a function call</p>\n<p><em>\u00a714.8.2.1 [temp.deduct.call]</em></p>\n<blockquote>\n<p id=\"so_32130745_32130883_1\">2 \u00a0\u00a0If <code>P</code> is not a reference type:<br/>\n  \u00a0\u00a0\u00a0\u00a0\u2014 ...<br/>\n  \u00a0\u00a0\u00a0\u00a0\u2014 If <code>A</code> is a cv-qualified type, <strong>the top level cv-qualifiers of <code>A</code>\u2019s type are ignored for type deduction</strong>.</p>\n</blockquote>\n<p>Thus, in </p>\n<pre><code>auto i = ci;\n</code></pre>\n<p>the top level <code>const</code> qualifier is ignored and <code>i</code> is deduced as <code>int</code>.</p>\n<p>When you write</p>\n<pre><code>auto&amp; i = ci;\n</code></pre>\n<p>then <code>i</code> is no longer not a reference type and the above rule doesn't apply, so the <code>const</code> qualifier is retained.</p>\n", "OwnerUserId": "241631", "LastEditorUserId": "2756719", "LastEditDate": "2015-08-21T01:15:34.667", "Id": "32130883", "Score": "5", "CreationDate": "2015-08-21T01:11:43.797", "LastActivityDate": "2015-08-21T01:15:34.667"}, "32131498": {"ParentId": "32130745", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><code>auto</code> by itself means that you want a new, locally-owned variable with a copy of the given value. <code>const</code>-ness is not part of value. An <code>int</code> is an <code>int</code> whether it's specified using a literal, a named constant, an expression, or a non-<code>const</code> variable.</p>\n<pre><code>auto i = 3,\n     j = i,\n     k = ci,\n     m = 3 + 4; // All these variables are type int.\n</code></pre>\n<p>To get a constant of deduced type, you can still use <code>auto const</code>. This expresses within the declaration how the variable may be used.</p>\n<pre><code>const auto i = 3;\n</code></pre>\n<p>Since C++14, there is also the <code>decltype(auto)</code> specifier which applies <code>decltype</code> to the initializer, to make a carbon copy of the given variable. Perhaps that's really what you expected:</p>\n<pre><code>decltype(auto) i = ci; // i receives type const int.\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/28a91215ff98ccf6\" rel=\"nofollow\">Live demo</a>.</p>\n<p><code>decltype(auto)</code> is a bit tricky, though, and it has few use cases aside from its original purpose relating to deciding the return type of function call wrappers. Unless there's a good reason, choose <code>const auto</code> or <code>const int</code> instead.</p>\n<p>Another alternative is to use a <em>forwarding reference</em>, spelled <code>auto &amp;&amp;</code>. This refers to the variable or value that initializes it, whatever that may be.</p>\n<pre><code>auto &amp;&amp; i = ci; // i receives type const int &amp; and aliases ci.\n</code></pre>\n<p>This is less expressive and specific, but reliably declares <code>i</code> as an alias to <code>ci</code>. The other thing you tried was <code>auto &amp;</code>, which is similar but only allows forming a reference to a preexisting variable.</p>\n<pre><code>auto &amp; i = ci; // i receives type const int &amp; and aliases ci.\n</code></pre>\n<p>A reference to a <code>const int</code> variable must be of type <code>const int &amp;</code>, because otherwise it would permit illegal modification.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2015-08-21T03:08:05.540", "Id": "32131498", "Score": "3", "CreationDate": "2015-08-21T02:33:24.240", "LastActivityDate": "2015-08-21T03:08:05.540"}, "32130745": {"CommentCount": "10", "ViewCount": "374", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2015-08-21T00:54:02.590", "LastActivityDate": "2015-08-21T05:31:24.730", "Title": "why auto i = same_const_variable could not deduce \"const\"?", "AcceptedAnswerId": "32130883", "LastEditDate": "2015-08-21T01:15:35.813", "Id": "32130745", "Score": "3", "Body": "<pre><code>const int ci = 10;\nauto i = ci;  // i will be \"int\" instead of \"const int\"\ni = 20;\n</code></pre>\n<p>I am wondering why auto is designed for this kind of behaviour?</p>\n<p>why the type i is \"int\" instead of \"const int\" ? </p>\n<p>what is the concern here?</p>\n<p>I think understand why will help us to remember it</p>\n", "Tags": "<c++><c++11><auto><type-deduction>", "OwnerUserId": "440403", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32130745_32130883_0": {"section_id": 5451, "quality": 0.8, "length": 12}, "so_32130745_32130883_1": {"section_id": 303, "quality": 1.0, "length": 11}}, "n3337": {"so_32130745_32130883_0": {"section_id": 5245, "quality": 0.8666666666666667, "length": 13}, "so_32130745_32130883_1": {"section_id": 294, "quality": 1.0, "length": 11}}, "n4659": {"so_32130745_32130883_0": {"section_id": 6889, "quality": 0.6, "length": 9}, "so_32130745_32130883_1": {"section_id": 310, "quality": 0.8181818181818182, "length": 9}}}});