post_cb({"bq_ids": {"n4140": {"so_32894748_32895274_0": {"length": 15, "quality": 1.0, "section_id": 5977}, "so_32894748_32895274_1": {"length": 30, "quality": 0.967741935483871, "section_id": 5978}, "so_32894748_32895274_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 5974}, "so_32894748_32895274_4": {"length": 14, "quality": 1.0, "section_id": 5970}, "so_32894748_32894748_0": {"length": 41, "quality": 0.9111111111111111, "section_id": 5974}}, "n3337": {"so_32894748_32895274_0": {"length": 15, "quality": 1.0, "section_id": 5745}, "so_32894748_32895274_1": {"length": 30, "quality": 0.967741935483871, "section_id": 5746}, "so_32894748_32895274_3": {"length": 8, "quality": 0.6153846153846154, "section_id": 5742}, "so_32894748_32894748_0": {"length": 37, "quality": 0.8222222222222222, "section_id": 5742}}, "n4659": {"so_32894748_32895274_0": {"length": 15, "quality": 1.0, "section_id": 7474}, "so_32894748_32895274_1": {"length": 30, "quality": 0.967741935483871, "section_id": 7477}, "so_32894748_32895274_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 7473}, "so_32894748_32895274_4": {"length": 14, "quality": 1.0, "section_id": 7469}, "so_32894748_32894748_0": {"length": 38, "quality": 0.8444444444444444, "section_id": 7473}}}, "32895274": {"Id": "32895274", "PostTypeId": "2", "Body": "<p>The way name lookup works inside lambda-expressions is a bit peculiar: <em>id-expressions</em> which refer to entities <em>captured by copy</em> are transformed from accesses to the captured entities to accesses to the stored data members of the closure type -- <strong>but only if these accesses constitute <em>odr-uses</em></strong>. Note that due to implicit capture, if there's no odr-use, there is possibly no such data member.</p>\n<p><code>decltype</code> does not constitute an odr-use, hence it will always refer to the captured entity (the original), not the data member (the copy).</p>\n<p>C++11 [expr.prim.lamba]p17</p>\n<blockquote>\n<p id=\"so_32894748_32895274_0\">Every id-expression that is an <em>odr-use</em> of an entity captured by\n  copy is transformed into an access to the corresponding unnamed data\n  member of the closure type.</p>\n</blockquote>\n<p>and furthermore, p18 even displays this weird effect in an example:</p>\n<blockquote>\n<p id=\"so_32894748_32895274_1\">Every occurrence of <code>decltype((x))</code> where <code>x</code> is a possibly parenthesized\n  <em>id-expression</em> that names an entity of automatic storage duration is\n  treated as if <code>x</code> were transformed into an access to a corresponding\n  data member of the closure type that would have been declared if <code>x</code>\n  were an odr-use of the denoted entity. [ <em>Example:</em></p>\n<pre><code>void f3() {\n    float x, &amp;r = x;\n    [=] { // x and r are not captured (appearance in a decltype operand is not an odr-use)\n        decltype(x) y1;        // y1 has type float\n        decltype((x)) y2 = y1; // y2 has type float const&amp; because this lambda\n                               // is not mutable and x is an lvalue\n        decltype(r) r1 = y1;   // r1 has type float&amp; (transformation not considered)\n        decltype((r)) r2 = y2; // r2 has type float const&amp;\n    };\n}\n</code></pre>\n<p id=\"so_32894748_32895274_2\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<hr>\n<p>The C++14 <em>init-captures</em> are also considered <em>capture by copy</em>, since C++14 [expr.prim.lambda]p15</p>\n<blockquote>\n<p id=\"so_32894748_32895274_3\">An entity is <em>captured by copy</em> if it is implicitly captured and the\n  <em>capture-default</em> is <code>=</code> or if it is explicitly captured with a capture\n  that is not of the form <code>&amp;</code> <em>identifier</em> or <code>&amp;</code> <em>identifier initializer</em>.</p>\n</blockquote>\n<p>However, as <a href=\"https://stackoverflow.com/users/2756719/t-c\">T.C.</a> has pointed out, they do not capture the entity they've been initialized with, but rather a \"dummy variable\" which is also used for type deduction [expr.prim.lambda]p11</p>\n<blockquote>\n<p id=\"so_32894748_32895274_4\">An <em>init-capture</em> behaves as if it declares and explicitly captures a\n  variable of the form \u201c<code>auto</code> init-capture <code>;</code>\u201d whose declarative region is\n  the <em>lambda-expression</em>\u2019s compound-statement [...]</p>\n</blockquote>\n<p>The type deduction alters the type of this variable, e.g. <code>char const[N]</code> -&gt; <code>char const*</code>, and the original entity might not even have a type, e.g. <code>[i = {1,2,3}]{}</code>.</p>\n<p>Therefore, the <em>id-expression</em> <code>j</code> in the lambda <code>[j=j]{ decltype(j) x; }</code> refers to this dummy variable and its type is <code>int</code>, not <code>int&amp;</code>.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-01T21:35:08.967", "Score": "9", "CreationDate": "2015-10-01T19:21:01.567", "ParentId": "32894748", "CommentCount": "5", "OwnerUserId": "420683", "LastEditDate": "2017-05-23T12:14:47.643"}, "32894748": {"ViewCount": "268", "Body": "<p>Consider the simple program:</p>\n<pre><code>int i = 0;\nint&amp; j = i;\n\nauto lambda = [=]{\n    std::cout &lt;&lt; &amp;j &lt;&lt; std::endl; //odr-use j\n};\n</code></pre>\n<p>According to [expr.prim.lambda], the closure member variable <code>j</code> should have type <code>int</code>:</p>\n<blockquote>\n<p id=\"so_32894748_32894748_0\">An entity is <em>captured by copy</em> if it is implicitly captured and the <em>capture-default</em> is <code>=</code> or if it is explicitly captured with a capture that is not of the form <em>&amp; identifier</em> or <em>&amp; identifier initializer</em>. For each entity captured by copy, an unnamed non-static data member is declared in the closure type. The declaration order of these members is unspecified. <strong>The type of such a data member</strong> is the type of the corresponding captured entity if the entity is not a reference to an object, <strong>or the referenced type otherwise</strong>.</p>\n</blockquote>\n<p>So what I'm printing is the address of some <code>int</code> unrelated to the outer-scope <code>i</code> or <code>j</code>. This is all well and good. However, when I throw in <code>decltype</code>:</p>\n<pre><code>auto lambda = [j] {\n    std::cout &lt;&lt; &amp;j &lt;&lt; std::endl;\n    static_assert(std::is_same&lt;decltype(j), int&gt;::value, \"!\"); // error: !\n};\n</code></pre>\n<p>That fails to compile because <code>decltype(j)</code> evaluates as <code>int&amp;</code>. Why? <code>j</code> in that scope should refer to the data member, should it not?</p>\n<p>As a related followup, if the lambda capture were instead an <em>init-capture</em> with <code>[j=j]{...}</code>, <em>then</em> clang would report <code>decltype(j)</code> as <code>int</code> and not <code>int&amp;</code>. Why the difference? </p>\n", "AcceptedAnswerId": "32895274", "Title": "Lambda capture reference by copy and decltype", "CreationDate": "2015-10-01T18:48:48.947", "Id": "32894748", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-10-01T21:35:08.967", "Score": "5", "OwnerUserId": "2069064", "Tags": "<c++><c++11><lambda>", "AnswerCount": "1"}});