post_cb({"27135791": {"ParentId": "27135677", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_27135677_27135791_0\">I thought that <code>static_cast&lt;TYPE&gt;(variable)</code> was equivalent (or better/safer) than <code>TYPE(variable)</code>.</p>\n</blockquote>\n<p>It's just a subset. Some conversions can be performed by both, but some can only be performed by the latter. For function-style casts the standard specifies in [expr.type.conv]:</p>\n<blockquote>\n<p id=\"so_27135677_27135791_1\">If the expression list is a single expression, the type conversion expression is equivalent (in definedness, and if defined in meaning) to the corresponding cast expression (5.4).</p>\n</blockquote>\n<p>That is, <code>TYPE(variable)</code> is equivalent to <code>(TYPE)variable</code>. Now for the latter the standard specifies</p>\n<blockquote>\n<p id=\"so_27135677_27135791_2\">The conversions performed by</p>\n<ul>\n<li>a <code>const_cast</code> (5.2.11),</li>\n<li>a <code>static_cast</code> (5.2.9),</li>\n<li>a <code>static_cast</code> followed by a const_cast,</li>\n<li>a <code>reinterpret_cast</code> (5.2.10), or</li>\n<li>a <code>reinterpret_cast</code> followed by a <code>const_cast</code>,</li>\n</ul>\n<p id=\"so_27135677_27135791_3\">can be performed using the cast notation of explicit type conversion.</p>\n</blockquote>\n<p><sub>(Note that there is an additional text explaining some differences concerning class hierarchies, which is not quite relevant here.)</sub><br>\nIn your case, <code>static_cast</code> does not suffice. <code>reinterpret_cast</code> would, since it can convert integers to pointers and vice versa. One of the reasons why <code>reinterpret_cast</code> should then be preferred is e.g. the ability of being found by a search for potentially dangerous casts. For further queries on when to use both, see <a href=\"https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used\"><strong>this question</strong></a>.</br></p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:26:27.763", "Id": "27135791", "Score": "5", "CreationDate": "2014-11-25T20:11:15.923", "LastActivityDate": "2014-11-25T21:14:16.257"}, "bq_ids": {"n4140": {"so_27135677_27135791_3": {"section_id": 6126, "quality": 1.0, "length": 8}, "so_27135677_27135791_1": {"section_id": 5999, "quality": 1.0, "length": 14}}, "n3337": {"so_27135677_27135791_3": {"section_id": 5890, "quality": 1.0, "length": 8}, "so_27135677_27135791_1": {"section_id": 5767, "quality": 1.0, "length": 14}}, "n4659": {"so_27135677_27135791_3": {"section_id": 7623, "quality": 1.0, "length": 8}, "so_27135677_27135791_1": {"section_id": 7500, "quality": 0.8571428571428571, "length": 12}}}, "27135677": {"CommentCount": "3", "ViewCount": "165", "PostTypeId": "1", "LastEditorUserId": "902497", "CreationDate": "2014-11-25T20:05:19.630", "LastActivityDate": "2014-11-25T21:14:16.257", "Title": "I thought static_cast<TYPE>() was equivalent to TYPE(variable) in C++?", "AcceptedAnswerId": "27135791", "LastEditDate": "2014-11-25T20:12:54.110", "Id": "27135677", "Score": "2", "Body": "<p>I just came across something I don't quite understand. I thought that <code>static_cast&lt;TYPE&gt;(variable)</code> was equivalent (or better/safer) than <code>TYPE(variable)</code>. However, the following code DOES not work</p>\n<pre><code>HMENU hMenu = CreateMenu();\nHMENU hSubMenu = CreatePopupMenu();\n\n// File\nAppendMenu(hSubMenu, MF_STRING, WndClass_main::ID_FILE_EXIT, \"&amp;Quit\");\nAppendMenu(hMenu, MF_STRING | MF_POPUP, static_cast&lt;intptr_t&gt;(hSubMenu), \"&amp;File\");\n</code></pre>\n<p>My compiler says that it can't convert from <code>HMENU</code> to <code>intptr_t</code>. I have a 64-bit system btw, which interfers with the casting between <code>void*</code> and <code>int</code>? However, from what I understand the type <code>intptr_t</code> (defined in cstdint) is guaranteed to be big enough for a <code>void*</code>.</p>\n<p>The interesting part is that the following (note the different cast) works:</p>\n<pre><code>HMENU hMenu = CreateMenu();\nHMENU hSubMenu = CreatePopupMenu();\n\n// File\nAppendMenu(hSubMenu, MF_STRING, WndClass_main::ID_FILE_EXIT, \"&amp;Quit\");\nAppendMenu(hMenu, MF_STRING | MF_POPUP, (intptr_t)(hSubMenu), \"&amp;File\");\n</code></pre>\n<p>What am I missing?</p>\n", "Tags": "<c++><casting>", "OwnerUserId": "3367091", "AnswerCount": "2"}, "27135822": {"ParentId": "27135677", "CommentCount": "0", "Body": "<p>It is safer.  It is also weaker.  It is safer, because it is weaker.</p>\n<p>A <code>static_cast</code> will do implicit casting, plus it will cast a pointer <em>down</em> a class hierarchy.</p>\n<p>It will also cast a pointer to/from <code>void*</code> with the same <code>const</code> <code>volatile</code> qualifications.  (from I believe is implicit in C -- it is not in C++).</p>\n<p>These are the \"safer\" set of casts in C/C++.</p>\n<p><code>const_cast</code> and <code>reinterpret_cast</code> gets the more dangerous ones.  These include converting a pointer value to an integer, even if the integer is big enough.</p>\n<p>My advice is to write this function:</p>\n<pre><code>intptr_t ptr_to_intptr( void* p ) { return reinterpret_cast&lt;intptr_t&gt;(p); }\n</code></pre>\n<p>which makes the operation clear, then use it.</p>\n<p>Unlike <code>(intptr_t)</code> it will only work on pointers -- so if you accidentally fed it something that isn't a pointer.  Or a pointer you cannot store in an <code>intptr_t</code> like a pointer-to-member.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "27135822", "Score": "2", "CreationDate": "2014-11-25T20:13:12.267", "LastActivityDate": "2014-11-25T20:13:12.267"}});