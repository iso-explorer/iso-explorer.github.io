post_cb({"23438041": {"CommentCount": "8", "ViewCount": "177", "CreationDate": "2014-05-02T22:44:42.607", "LastActivityDate": "2014-05-03T12:14:53.547", "Title": "unique_ptr deleter pointer to pointer", "AcceptedAnswerId": "23438554", "PostTypeId": "1", "Id": "23438041", "Score": "4", "Body": "<p>I am trying to map a third-party API using a unique_ptr custom deleter. The problem is that the API is as such:</p>\n<pre><code>x *x_alloc_x(void);\n\nvoid x_free_x(x **p);\n</code></pre>\n<p>The API wants me to provide a pointer to a pointer for it to set to NULL. I have been writing my deleter functor as taking a reference-to-pointer, which I convert to pointer-to-pointer with the \"&amp;\" operator.</p>\n<pre><code>struct XDeleter {\n    void operator(x *&amp;p) { x_free_x(&amp;p); }\n};\n</code></pre>\n<p>This has worked with GCC 4.6, but is this actually permitted by the standard? If not, is there a standard-compliant way to map this API to a deleter?</p>\n", "Tags": "<c++><c++-standard-library>", "OwnerUserId": "2363399", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_23438041_23438554_1": {"section_id": 4334, "quality": 1.0, "length": 4}, "so_23438041_23438554_2": {"section_id": 4290, "quality": 0.9333333333333333, "length": 28}, "so_23438041_23438554_0": {"section_id": 4318, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_23438041_23438554_1": {"section_id": 4175, "quality": 1.0, "length": 4}, "so_23438041_23438554_2": {"section_id": 4131, "quality": 0.9333333333333333, "length": 28}, "so_23438041_23438554_0": {"section_id": 4159, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_23438041_23438554_1": {"section_id": 5591, "quality": 1.0, "length": 4}, "so_23438041_23438554_2": {"section_id": 5548, "quality": 0.8666666666666667, "length": 26}, "so_23438041_23438554_0": {"section_id": 5575, "quality": 0.6666666666666666, "length": 4}}}, "23438554": {"ParentId": "23438041", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The code is not well-formed. n3797 [unique.ptr.single.dtor]/1 requires in the destructor of <code>unique_ptr</code>:</p>\n<blockquote>\n<p id=\"so_23438041_23438554_0\"><em>Requires:</em> The expression <code>get_deleter()(get())</code> shall be well formed [...]</p>\n</blockquote>\n<p>Where [unique.ptr.single] specifies:</p>\n<blockquote id=\"so_23438041_23438554_1\">\n<pre><code>pointer get() const noexcept;\n</code></pre>\n</blockquote>\n<p>That is, <code>get()</code> is a prvalue.</p>\n<p>Additionally, [unique.ptr.single]/1</p>\n<blockquote>\n<p id=\"so_23438041_23438554_2\">A client-supplied template argument <code>D</code> [the deleter type]\n  shall be a function object type, lvalue-reference to function, or lvalue-reference to function object type\n  for which, given a value <code>d</code> of type <code>D</code> and a value <code>ptr</code> of type <code>unique_ptr&lt;T, D&gt;::pointer</code>, the expression\n  <code>d(ptr)</code> is valid and has the effect of disposing of the pointer as appropriate for that deleter.</p>\n</blockquote>\n<p>A <em>value</em> is a prvalue.</p>\n<hr>\n<p>The solution has been given in the comments by <a href=\"https://stackoverflow.com/users/845092/mooing-duck\">Mooing Duck</a>:</p>\n<pre><code>struct XDeleter {\n    void operator(x *p)\n    { x_free_x(&amp;p); }\n};\n</code></pre>\n<p>The destructor of <code>unique_ptr</code> however is not required to assign <code>nullptr</code> to the stored pointer.</p>\n</hr>", "OwnerUserId": "420683", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:28:36.143", "Id": "23438554", "Score": "2", "CreationDate": "2014-05-02T23:41:19.867", "LastActivityDate": "2014-05-03T12:14:53.547"}});