post_cb({"bq_ids": {"n4140": {"so_46938763_46938811_1": {"length": 37, "quality": 0.9487179487179487, "section_id": 72}}, "n3337": {"so_46938763_46938811_1": {"length": 37, "quality": 0.9487179487179487, "section_id": 67}}}, "46938763": {"CreationDate": "2017-10-25T17:38:17.880", "ViewCount": "30", "Id": "46938763", "AcceptedAnswerId": "46938811", "Score": "0", "Title": "Error when passing template parameters to inner structure", "CommentCount": "2", "Body": "<p>I try to compile the following C++ code:</p>\n<pre><code>struct A {\n    template&lt; bool x &gt;\n    bool fun() {\n        return x;\n    }\n};\n\ntemplate&lt; typename T &gt;\nstruct B {\n    struct A2 {\n        template&lt; bool x &gt;\n        bool fun() {\n            return x;\n        }\n    };\n\n    void test() {\n        A a;\n        A2 a2;\n        a.fun&lt; true &gt;();\n        a2.fun&lt; true &gt;();\n    }\n};\n</code></pre>\n<p>The compiler complains that:</p>\n<pre><code>source_file.cpp: In member function \u2018void B&lt;T&gt;::test()\u2019:\nsource_file.cpp:22:24: error: expected primary-expression before \u2018)\u2019 token\n         a2.fun&lt; true &gt;();\n                        ^\n</code></pre>\n<p>However the line just above (<code>a.fun&lt; true &gt;()</code>) compiles just fine. Interestingly, if I remove the line <code>template&lt; typename T &gt;</code>, then compilation succeeds. However that line is required for reasons that do not appear from the minimal (not) working example. What is wrong here?</p>\n", "Tags": "<c++><templates>", "LastActivityDate": "2017-10-25T17:51:37.190", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "807307"}, "46938811": {"LastActivityDate": "2017-10-25T17:51:37.190", "CommentCount": "0", "Body": "<p>In this context <code>A2</code> is actually a shorthand for <code>B&lt;T&gt;::A2</code>. Since <code>A2</code> is a type dependent on the template parameter <code>T</code>, you have to refer to its member templates with an explicit <code>template</code> keyword</p>\n<pre><code>a2.template fun&lt; true &gt;();\n</code></pre>\n<p><code>A</code> is not a dependent type and its member templates can be referred to with \"plain\" syntax without that extra <code>template</code> keyword.</p>\n<p>See 14.2/4 and a similar example there</p>\n<blockquote>\n<p id=\"so_46938763_46938811_0\"><strong>14.2 Names of template specializations [temp.names]</strong> </p>\n<p id=\"so_46938763_46938811_1\"><strong>4</strong> When the name of a member template specialization appears after <code>.</code> or <code>-&gt;</code> in a <em>postfix-expression</em> or after a <em>nested-name-specifier</em> in a <em>qualified-id</em>, and the object expression of the <em>postfix-expression</em> is type-dependent or the <em>nested-name-specifier</em> in the <em>qualified-id</em> refers to a dependent type, but the name is not a member of the current instantiation (14.6.2.1), the member template name must be prefixed by the keyword <code>template</code>.\n  Otherwise the name is assumed to name a non-template. [ Example:  </p>\n<pre><code>struct X { \n   template&lt;std::size_t&gt; X* alloc();\n   template&lt;std::size_t&gt; static X* adjust();\n };\n template&lt;class T&gt; void f(T* p) {\n   T* p1 = p-&gt;alloc&lt;200&gt;();          // ill-formed: &lt; means less than\n   T* p2 = p-&gt;template alloc&lt;200&gt;(); // OK: &lt; starts template argument list\n   T::adjust&lt;100&gt;();                 // ill-formed: &lt; means less than\n   T::template adjust&lt;100&gt;();        // OK: &lt; starts template argument list\n }\n</code></pre>\n<p id=\"so_46938763_46938811_2\">\u2014end example ]</p>\n</blockquote>\n", "CreationDate": "2017-10-25T17:41:03.277", "LastEditDate": "2017-10-25T17:51:37.190", "ParentId": "46938763", "Id": "46938811", "LastEditorUserId": "187690", "PostTypeId": "2", "Score": "2", "OwnerUserId": "187690"}});