post_cb({"bq_ids": {"n4140": {"so_46224119_46224187_0": {"length": 31, "quality": 1.0, "section_id": 7043}}, "n3337": {"so_46224119_46224187_0": {"length": 31, "quality": 1.0, "section_id": 6788}}, "n4659": {"so_46224119_46224187_0": {"length": 31, "quality": 1.0, "section_id": 8540}}}, "46224157": {"Id": "46224157", "PostTypeId": "2", "Body": "<p>You cannot define a class twice. It breaks the <a href=\"https://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"nofollow noreferrer\">One Definition Rule</a> (ODT). <code>MyLibrary</code> does that, unfortunately.</p>\n<blockquote>\n<p id=\"so_46224119_46224157_0\">they're never passed to the compiler</p>\n</blockquote>\n<p>They will. Members of a class must be known at compile time, so that the compiler can determine the class's size.</p>\n", "LastEditorUserId": "2411320", "LastActivityDate": "2017-09-14T16:50:29.480", "Score": "3", "CreationDate": "2017-09-14T16:27:03.823", "ParentId": "46224119", "CommentCount": "0", "OwnerUserId": "2411320", "LastEditDate": "2017-09-14T16:50:29.480"}, "46224119": {"ViewCount": "127", "Body": "<p>What I mean is my real header file can look like this:</p>\n<pre><code>#include \"some_internal_class.h\"\n\nclass MyLibrary {\n    Type private_member;\n\n    void private_function();\npublic:\n\n    MyLibrary();\n    void function_to_be_called_by_library_users();\n};\n</code></pre>\n<p>Now I want to produce a dynamic library containing all the necessary definitions. and I want to ship with it a single header instead of shipping every single header I have in my library.</p>\n<p>So I was thinking I could create a slim version of my header like so:</p>\n<pre><code>class MyLibrary {\npublic:     \n    MyLibrary();\n    void function_to_be_called_by_library_users();\n};\n</code></pre>\n<p>Headers are just declarations anyway right? they're never passed to the compiler. And I've declared what the user will be using.</p>\n<p>Is that possible? If not, why not?</p>\n", "AcceptedAnswerId": "46224418", "Title": "Can I use a slim version of my header to be included with the library?", "CreationDate": "2017-09-14T16:24:30.060", "Id": "46224119", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-09-14T16:34:28.783", "LastEditorUserId": "3659011", "LastActivityDate": "2017-09-15T05:11:49.550", "Score": "6", "OwnerUserId": "3659011", "Tags": "<c++><oop>", "AnswerCount": "3"}, "46224418": {"Id": "46224418", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46224119_46224418_0\">Header are just declarations anyway right? they're never passed to the\n  compiler. And I've declared what the user will be using.</p>\n</blockquote>\n<p>No. Headers are part of source code and are compiled together with source files. They contain the information necessary for a compiler to understand how to work with code (in your case, with class <code>MyLibrary</code>).</p>\n<p>As an example, you want library users to be able to create objects of class <code>MyLibrary</code>, so you export the constructor. However, this is not sufficient: the compiler needs to know the <em>size</em> of the object to be created, which is impossible unless you specify all the fields.</p>\n<p>In practice, deciding what to expose to library users and what to hide as implementation details is a hard question, which requires detailed inspection of the library usage and semantics. If you really want to hide the class internals as implementation detail, here are some common options:</p>\n<ul>\n<li>The <a href=\"https://en.wikibooks.org/wiki/C%2B%2B_Programming/Idioms#Pointer_To_Implementation_.28pImpl.29\" rel=\"nofollow noreferrer\">pimpl</a> idiom is a common solution. It enables you to work with the class as it is usually done, but the implementation details are nicely hidden.</li>\n<li>Extract the interface into an <a href=\"https://en.wikibooks.org/wiki/C%2B%2B_Programming/Classes/Abstract_Classes\" rel=\"nofollow noreferrer\">abstract class</a> with virtual functions, and use pointers (preferably <a href=\"https://www.meetingcpp.com/blog/items/an-overview-on-smart-pointers.html\" rel=\"nofollow noreferrer\">smart pointers</a>) to work with the objects.</li>\n</ul>\n", "LastEditorUserId": "2315602", "LastActivityDate": "2017-09-14T16:52:19.583", "Score": "1", "CreationDate": "2017-09-14T16:41:48.427", "ParentId": "46224119", "CommentCount": "0", "OwnerUserId": "2315602", "LastEditDate": "2017-09-14T16:52:19.583"}, "46224187": {"Id": "46224187", "PostTypeId": "2", "Body": "<p>This is a One Definition Rule violation. The moment you deviate by a single token.</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.def.odr#6\" rel=\"nofollow noreferrer\">[basic.def.odr]/6</a></p>\n<blockquote>\n<p id=\"so_46224119_46224187_0\">There can be more than one definition of a class type, [...] in a\n  program provided that each definition appears in a different\n  translation unit, and provided the definitions satisfy the following\n  requirements. Given such an entity named D defined in more than one\n  translation unit, then</p>\n<ul>\n<li>each definition of D shall consist of the same sequence of tokens; and</li>\n</ul>\n</blockquote>\n<p>Your program may easily break if you violate the ODR like that. And your build system isn't at all obligated to even warn you about it.</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-09-15T05:11:49.550", "Score": "7", "CreationDate": "2017-09-14T16:28:45.297", "ParentId": "46224119", "CommentCount": "0", "OwnerUserId": "817643", "LastEditDate": "2017-09-15T05:11:49.550"}});