post_cb({"8208023": {"ViewCount": "325", "Body": "<p>Consider the following code to set all bits of <strong>x</strong></p>\n<pre><code>unsigned int x = -1;\n</code></pre>\n<p>Is this portable ?  It seems to work on at least Visual Studio 2005-2010 </p>\n", "AcceptedAnswerId": "8209275", "Title": "converting -1 to unsigned types", "CreationDate": "2011-11-21T06:23:16.950", "Id": "8208023", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2011-11-21T08:59:11.497", "Score": "9", "OwnerUserId": "764882", "Tags": "<c++>", "AnswerCount": "4"}, "8208058": {"Id": "8208058", "PostTypeId": "2", "Body": "<p>Apparently it is: </p>\n<blockquote>\n<p id=\"so_8208023_8208058_0\">(4.7) If the destination type is unsigned, the resulting value is the least\n  unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n is\n  the number of bits used to represent the unsigned type). [Note: In a\n  two\u2019s complement representation, this conversion is conceptual and\n  there is no change in the bit pattern (if there is no truncation).</p>\n</blockquote>\n<p>It is guaranteed to be the largest amount possible for that type due to the properties of modulo.</p>\n<p>C99 also allows it:</p>\n<blockquote>\n<p id=\"so_8208023_8208058_1\">Otherwise, if the newtype is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that\n  can be represented in the newtype until the value is in the range of\n  the newtype. 49)</p>\n</blockquote>\n<p>Which wold also be the largest amount possible.</p>\n<hr>\n<p>Largest amount possible may not be all bits set. Use <code>~static_cast&lt;unsigned int&gt;(0)</code> for that.</p>\n</hr>", "LastEditorUserId": "968261", "LastActivityDate": "2011-11-21T08:54:02.450", "Score": "6", "CreationDate": "2011-11-21T06:27:50.377", "ParentId": "8208023", "CommentCount": "11", "OwnerUserId": "964135", "LastEditDate": "2011-11-21T08:54:02.450"}, "bq_ids": {"n4140": {"so_8208023_8209275_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 7216}, "so_8208023_8209275_0": {"length": 18, "quality": 0.9, "section_id": 6073}, "so_8208023_8208058_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 31}, "so_8208023_8209275_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 7216}, "so_8208023_8209275_1": {"length": 14, "quality": 0.875, "section_id": 7213}}, "n3337": {"so_8208023_8209275_0": {"length": 18, "quality": 0.9, "section_id": 5841}, "so_8208023_8209275_1": {"length": 16, "quality": 1.0, "section_id": 6957}, "so_8208023_8208058_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 28}, "so_8208023_8209275_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 6960}, "so_8208023_8209275_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 6960}}, "n4659": {"so_8208023_8209275_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 8725}, "so_8208023_8209275_1": {"length": 14, "quality": 0.875, "section_id": 8722}, "so_8208023_8208058_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 31}, "so_8208023_8209275_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 8725}, "so_8208023_8209275_0": {"length": 18, "quality": 0.9, "section_id": 7569}}}, "8208592": {"Id": "8208592", "PostTypeId": "2", "Body": "<p>I was sloppy in reading the question, and made several comments that might be misleading because of that.  I'll try to clear up the confusion in this answer.</p>\n<p>The declaration</p>\n<pre><code>unsigned int x = -1;\n</code></pre>\n<p>is guaranteed to set <code>x</code> to <code>UINT_MAX</code>, the maximum value of type <code>unsigned int</code>.  The expression <code>-1</code> is of type <code>int</code>, and it's implicitly converted to <code>unsigned int</code>.  The conversion (which is defined in terms of values, not representations) results in the maximum value of the target unsigned type.</p>\n<p>(It happens that the semantics of the conversion are optimized for two's-complement systems; for other schemes, the conversion might involve something more than just copying the bits.)</p>\n<p>But the question referred to setting all bits of <code>x</code>.  So, is <code>UINT_MAX</code> represented as all-bits-one?</p>\n<p>There are several possible representations for signed integers (two's-complement is most common, but ones'-complement and sign-and-magnitude are also possible).  But we're dealing with an <em>unsigned</em> integer type, so the way that <em>signed</em> integers are represented is irrelevant.</p>\n<p>Unsigned integers are required to be represented in a pure binary format.  Assuming that all the bits of the representation contribute to the value of an <code>unsigned int</code> object, then yes, <code>UINT_MAX</code> must be represented as all-bits-one.</p>\n<p>On the other hand, integer types are allowed to have <em>padding bits</em>, bits that don't contribute to the representation.  For example, it's legal for <code>unsigned int</code> to be 32 bits, but for only 24 of those bits to be value bits, so <code>UINT_MAX</code> would be 2*<em>24-1 rather than 2</em>*32-1.  So in the most general case, all you can say is that</p>\n<pre><code>unsigned int x = -1;\n</code></pre>\n<p>sets all the <em>value</em> bits of <code>x</code> to 1.</p>\n<p>In practice, very very few systems have padding bits in integer types.  So on the vast majority of systems, <code>unsigned int</code> has a size of N bits, and a maximum value of 2**N-1, and the above declaration <em>will</em> set all the bits of <code>x</code> to 1.</p>\n<p>This:</p>\n<pre><code>unsigned int x = ~0U;\n</code></pre>\n<p>will also set <code>x</code> to UINT_MAX, since bitwise complement for unsigned types is defined in terms of subtraction.</p>\n", "LastEditorUserId": "827263", "LastActivityDate": "2011-11-21T08:35:09.350", "Score": "5", "CreationDate": "2011-11-21T07:36:37.147", "ParentId": "8208023", "CommentCount": "2", "OwnerUserId": "827263", "LastEditDate": "2011-11-21T08:35:09.350"}, "8209275": {"Id": "8209275", "PostTypeId": "2", "Body": "<p><strong>The citation-heavy answer:</strong></p>\n<p>I know there are plenty of correct answers in here, but I'd like to add a few citations to the mix.  I'll cite two standards: C99 n1256 draft (freely available) and C++ n1905 draft (also freely available).  There's nothing special about these particular standards, they're just both freely available and whatever happened to be easiest to find at the moment.</p>\n<p><strong>The C++ version:</strong></p>\n<p>\u00a75.3.2 \u00b69: According to this paragraph, the value <code>~(type)0</code> is guaranteed to have all bits set, if <code>(type)</code> is an unsigned type. </p>\n<blockquote>\n<p id=\"so_8208023_8209275_0\">The operand of ~ shall have integral or enumeration type; the result is the one\u2019s complement of its operand. Integral promotions are performed. The type of the result is the type of the promoted operand.</p>\n</blockquote>\n<p>\u00a73.9.1 \u00b64: This explains how overflow works with unsigned numbers.</p>\n<blockquote>\n<p id=\"so_8208023_8209275_1\">Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2<sup>n</sup> where n is the number of bits in the value representation of that particular size of integer.</p>\n</blockquote>\n<p>\u00a73.9.1 \u00b67, plus footnote 49: This explains that numbers must be binary.  From this, we can infer that <code>~(type)0</code> must be the largest number representable in <code>type</code> (since it has all bits turned on, and each bit is additive).</p>\n<blockquote>\n<p id=\"so_8208023_8209275_2\">The representations of integral types shall define values by use of a pure\n    binary numeration system<sup>49</sup>.</p>\n<p id=\"so_8208023_8209275_3\">49) A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin\n  with 1, and are multiplied by successive integral power of 2, except perhaps for the bit with the highest position. (Adapted from the <em>American National\n  Dictionary for Information Processing Systems</em>.)</p>\n</blockquote>\n<p>Since arithmetic is done modulo 2<sup>n</sup>, it is guaranteed that <code>(type)-1</code> is the largest value representable in that type.  It is also guaranteed that <code>~(type)0</code> is the largest value representable in that type.  They must therefore be equal.</p>\n<p><strong>The C99 version:</strong></p>\n<p>The C99 version spells it out in a much more compact, explicit way.</p>\n<p>\u00a76.5.3 \u00b63:</p>\n<blockquote>\n<p id=\"so_8208023_8209275_4\">The result of the ~ operator is the bitwise complement of its (promoted) operand (that is,\n  each bit in the result is set if and only if the corresponding bit in the converted operand is\n  not set). The integer promotions are performed on the operand, and the result has the\n  promoted type. If the promoted type is an unsigned type, the expression ~E is equivalent\n  to the maximum value representable in that type minus E.</p>\n</blockquote>\n<p>As in C++, unsigned arithmetic is guaranteed to be modular (I think I've done enough digging through standards for now), so the C99 standard definitely guarantees that <code>~(type)0 == (type)-1</code>, and we know from \u00a76.5.3 \u00b63 that <code>~(type)0</code> must have all bits set.</p>\n<p><strong>The summary:</strong></p>\n<p>Yes, it is portable.  <code>unsigned type x = -1;</code> is guaranteed to have all bits set according to the standard.</p>\n<p><strong>Footnote:</strong> Yes, we are talking about <em>value bits</em> and not <em>padding bits</em>.  I doubt that you need to set padding bits to one, however.  You can see from a recent Stack Overflow question (<a href=\"https://stackoverflow.com/questions/8007825/rephrased-list-of-platforms-supported-by-the-c-standard/8115542#8115542\">link</a>) that GCC was ported to the PDP-10 where the <code>long long</code> type has a single padding bit.  On such a system, <code>unsigned long long x = -1;</code> may not set that padding bit to 1.  However, you would only be able to discover this if you used pointer casts, which isn't usually portable anyway.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-11-21T08:59:11.497", "Score": "6", "CreationDate": "2011-11-21T08:51:18.943", "ParentId": "8208023", "CommentCount": "0", "OwnerUserId": "82294", "LastEditDate": "2017-05-23T12:19:08.340"}, "8208057": {"Id": "8208057", "PostTypeId": "2", "Body": "<p><strong>Beware!</strong></p>\n<p>This is implementation-defined, as how a negative integer shall be represented, whether two's complement or what, is not defined by the C++ Standard. It is up to the compiler which makes the decision, and has to document it properly.</p>\n<p>In short, it is not portable. It may not <em>set all bits of x</em>.</p>\n", "LastEditorUserId": "827263", "LastActivityDate": "2011-11-21T07:13:15.633", "Score": "2", "CreationDate": "2011-11-21T06:27:46.387", "ParentId": "8208023", "CommentCount": "13", "OwnerUserId": "415784", "LastEditDate": "2011-11-21T07:13:15.633"}});