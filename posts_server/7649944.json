post_cb({"7649944": {"CommentCount": "7", "AcceptedAnswerId": "7650075", "PostTypeId": "1", "LastEditorUserId": "88829", "CreationDate": "2011-10-04T15:01:40.133", "LastActivityDate": "2011-10-04T23:19:02.130", "LastEditDate": "2011-10-04T22:11:24.750", "ViewCount": "2427", "FavoriteCount": "1", "Title": "How do I imitate the Microsoft version of __FUNCTION__ using gcc?", "Id": "7649944", "Score": "8", "Body": "<p>When I use the <code>__FUNCTION__</code> macro/variable to print out debugging information, there seems to be a difference in what it outputs when using the Microsoft C++ compiler and gcc. For example, using the following trivial code:</p>\n<pre><code>class Foo \n{\n    public:\n       void Bar(int a, int b, int c)\n       {\n           printf (\"__FUNCTION__ = %s\\n\", __FUNCTION__);\n       }\n};\n\nint main (void)\n{\n    Foo MyFoo;\n\n    MyFoo.Bar();\n\n    return 0;\n}\n</code></pre>\n<p>Using the Microsoft Visual C++ compiler, I get</p>\n<pre><code>__FUNCTION__ = Foo::Bar\n</code></pre>\n<p>whereas when compiling using gcc (in this case on the Mac), I get</p>\n<pre><code>__FUNCTION__ = Bar\n</code></pre>\n<p>The second example is not ideal because I quite often have several classes with, say, <code>Init()</code> and <code>Uninit()</code> methods and in a debug output trace its virtually impossible to tell which one of these has been called as the class name will be missing. Now, I know you can use the <code>__PRETTY_FUNCTION__</code> in place of <code>__FUNCTION__</code> to get something like</p>\n<pre><code>__PRETTY_FUNCTION__ = void Foo::Bar(int, int, int)\n</code></pre>\n<p>Which is fine, but its a bit too verbose for what I need and gets a bit long for functions with a lot of parameters. </p>\n<p>So my question is (at last), is there any way to get the output to look like simply <code>Foo::Bar</code> using gcc, as in the example above?</p>\n", "Tags": "<c++><windows><osx><gcc><compiler-construction>", "OwnerUserId": "88829", "AnswerCount": "2"}, "7650075": {"ParentId": "7649944", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-10-04T15:10:57.167", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:58:30.853", "Id": "7650075", "OwnerUserId": "839436", "Body": "<p>If you are using it for tracing, you can always use <code>typeid(T).name()</code> and just conditionally compile per platform.  Certainly not as convenient as the macro, but it could work.</p>\n<p>Vaguely similar to <a href=\"https://stackoverflow.com/questions/1666802/class-macro-in-c\">__CLASS__ macro in C++</a></p>\n", "LastActivityDate": "2011-10-04T23:19:02.130"}, "bq_ids": {"n4140": {"so_7649944_7650065_0": {"section_id": 3269, "quality": 0.7241379310344828, "length": 21}}, "n3337": {"so_7649944_7650065_0": {"section_id": 3141, "quality": 0.7241379310344828, "length": 21}}, "n4659": {"so_7649944_7650065_0": {"section_id": 4027, "quality": 0.7241379310344828, "length": 21}}}, "7650065": {"ParentId": "7649944", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-10-04T15:10:19.243", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:51:18.263", "Id": "7650065", "OwnerUserId": "76722", "Body": "<p>The function-name sanctioned by the standard is defined as follows:</p>\n<pre><code>static const char __func__[] = \"function-name \";\n</code></pre>\n<p>Example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace meh {\n    void foobar() { std::cout &lt;&lt; __func__ &lt;&lt; std::endl; }\n};\n\nstruct Frob {\n    void foobar() { std::cout &lt;&lt; __func__ &lt;&lt; std::endl; }\n    static void barfoo() { std::cout &lt;&lt; __func__ &lt;&lt; std::endl; }\n};\n\nint main () {\n    std::cout &lt;&lt; __func__ &lt;&lt; std::endl;\n    meh::foobar();\n    Frob().foobar();\n    Frob::barfoo();\n}\n</code></pre>\n<p>However, output with g++:</p>\n<pre><code>main\nfoobar\nfoobar\nbarfoo\n</code></pre>\n<p>However, that is valid C++ behaviour:</p>\n<blockquote>\n<p id=\"so_7649944_7650065_0\">\u00a7 8.4.1, 8: The function-local predefined variable <code>__func__</code> is defined as if a definition of the form <code>static const char __func__[] = \"function-name \";</code>\n  had been provided, where function-name is an implementation-defined string. It is unspecified whether such a variable has an address distinct from that of any other object in the program</p>\n</blockquote>\n<p>I.e., you may not trust in its value. If you want to use non-portable extensions, have a look at a similar question: <a href=\"https://stackoverflow.com/questions/4384765/whats-the-difference-between-pretty-function-function-func\">What's the difference between __PRETTY_FUNCTION__, __FUNCTION__, __func__?</a> .</p>\n", "LastActivityDate": "2011-10-04T19:11:44.697"}});