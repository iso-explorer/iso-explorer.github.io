post_cb({"42753585": {"CommentCount": "3", "ViewCount": "340", "PostTypeId": "1", "LastEditorUserId": "1816262", "CreationDate": "2017-03-12T21:46:15.683", "LastActivityDate": "2017-03-13T20:09:06.147", "Title": "What is the proper usage of a constexpr standard functor?", "AcceptedAnswerId": "42754529", "LastEditDate": "2017-03-13T20:09:06.147", "Id": "42753585", "Score": "11", "Body": "<p>Take the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\ntemplate &lt;template&lt;typename&gt; class Op&gt;\nauto applyOp(const uint8_t lhs, const uint8_t rhs) {\n    constexpr Op&lt;uint8_t&gt; op;\n\n    return op(lhs, rhs);\n}\n\nint main() {\n    std::cout &lt;&lt; +applyOp&lt;std::bit_and&gt;(19, 180) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>When using <code>g++</code>, this compiles and runs just fine. However <code>clang++</code> yields an error:</p>\n<pre><code>test.cpp:5:27: error: default initialization of an object of const type 'const bit_and&lt;uint8_t&gt;' (aka 'const bit_and&lt;unsigned char&gt;') without a user-provided default constructor\n    constexpr Op&lt;uint8_t&gt; op;\n                          ^\n                            {}\ntest.cpp:11:19: note: in instantiation of function template specialization 'applyOp&lt;std::bit_and&gt;' requested here\n    std::cout &lt;&lt; +applyOp&lt;std::bit_and&gt;(19, 180) &lt;&lt; std::endl;\n                  ^\n1 error generated.\n</code></pre>\n<p>So I took a look at the source code for bit_and:</p>\n<pre><code> // Copyright (C) 2001-2016 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n // terms of the GNU General Public License as published by the\n // Free Software Foundation; either version 3, or (at your option)\n // any later version.\n\n // This library is distributed in the hope that it will be useful,\n // but WITHOUT ANY WARRANTY; without even the implied warranty of\n // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n // GNU General Public License for more details.\n\n // Under Section 7 of GPL version 3, you are granted additional\n // permissions described in the GCC Runtime Library Exception, version\n // 3.1, as published by the Free Software Foundation.\n\n // You should have received a copy of the GNU General Public License and\n // a copy of the GCC Runtime Library Exception along with this program;\n // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n // &lt;http://www.gnu.org/licenses/&gt;.\n\n /*\n  *\n  * Copyright (c) 1994\n  * Hewlett-Packard Company\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n  * and its documentation for any purpose is hereby granted without fee,\n  * provided that the above copyright notice appear in all copies and\n  * that both that copyright notice and this permission notice appear\n  * in supporting documentation.  Hewlett-Packard Company makes no\n  * representations about the suitability of this software for any\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n  * Copyright (c) 1996-1998\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n  * and its documentation for any purpose is hereby granted without fee,\n  * provided that the above copyright notice appear in all copies and\n  * that both that copyright notice and this permission notice appear\n  * in supporting documentation.  Silicon Graphics makes no\n  * representations about the suitability of this software for any\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  */\n\n[ ... content omitted ... ]\n\ntemplate&lt;typename _Arg1, typename _Arg2, typename _Result&gt;\n     struct binary_function\n     {\n       /// @c first_argument_type is the type of the first argument\n       typedef _Arg1     first_argument_type;\n\n       /// @c second_argument_type is the type of the second argument\n       typedef _Arg2     second_argument_type;\n\n       /// @c result_type is the return type\n       typedef _Result   result_type;\n     };\n\n[ ... content omitted ... ]\n\n#if __cplusplus &gt; 201103L\n   template&lt;typename _Tp = void&gt;\n     struct bit_and;\n\n   [ ... content omitted ... ]\n\n#endif\n\n   [ ... content omitted ... ]\n\n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // DR 660. Missing Bitwise Operations.\n   template&lt;typename _Tp&gt;\n     struct bit_and : public binary_function&lt;_Tp, _Tp, _Tp&gt;\n     {\n       _GLIBCXX14_CONSTEXPR\n       _Tp\n       operator()(const _Tp&amp; __x, const _Tp&amp; __y) const\n       { return __x &amp; __y; }\n     };\n\n  [ ... content omitted ... ]\n</code></pre>\n<p>For what I can tell, a default constructor should be generated here.\nInterestingly, the error message specifically asks for a \"user-provided default constructor\" rather than just a \"default constructor\".</p>\n<p>Changing the offending line to use uniform initialization leads the code to work with both compilers:</p>\n<pre><code>- constexpr Op&lt;uint8_t&gt; op;\n+ constexpr Op&lt;uint8_t&gt; op { };\n</code></pre>\n<p>My question is, is <code>clang++</code> correct in demanding these extra braces, or is <code>g++</code> correct in not?</p>\n<p><strong>Extra info</strong></p>\n<p>Compiling with <code>g++</code> command:</p>\n<pre><code>g++ test.cpp -Werror -Wall -pedantic -std=c++14\n</code></pre>\n<p>Compiling with <code>clang++</code> command:</p>\n<pre><code>clang++ test.cpp -Werror -Wall -pedantic -std=c++14\n</code></pre>\n<p>Running the application command:</p>\n<pre><code>./a.out\n</code></pre>\n<p>Location of <code>bit_and</code> definition:</p>\n<pre><code>/usr/include/c++/6.2.0/bits/stl_function.h\n</code></pre>\n<p><sub>Regarding the <a href=\"https://stackoverflow.com/questions/7411515/why-does-c-require-a-user-provided-default-constructor-to-default-construct-a\">possible duplicate</a> flag, I don't believe this is a duplicate because that question is asking why this rule exists, whilst my question was more about finding out about the rule in the first place and which compiler is correct in its enforcement. Furthermore, the answers to the alleged duplicate do not answer my question.</sub></p>\n", "Tags": "<c++><templates><c++14><language-lawyer><constexpr>", "OwnerUserId": "1816262", "AnswerCount": "1"}, "42754529": {"ParentId": "42753585", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The original C++14 wording in [dcl.init] required that:</p>\n<blockquote>\n<p id=\"so_42753585_42754529_0\">If a program calls for the default-initialization of an object of a <code>const</code>-qualified type <code>T</code>, <strong><code>T</code> shall be a class type with a user-provided default constructor.</strong></p>\n</blockquote>\n<p>Hence, simply having a default constructor is insufficient. It also needed to have been user-provided. Clang implemented this rule, which required <code>constexpr Op&lt;uint8_t&gt; op{};</code>, but gcc did not - allowing default-initialization in this case. </p>\n<p><em>However</em>, this wording was revised just recently in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0490r0.html\" rel=\"noreferrer\">p0490</a>. The new wording, retroactively applied to C++14, reads:</p>\n<blockquote>\n<p id=\"so_42753585_42754529_1\">A class type <code>T</code> is <em>const-default-constructible</em> if default-initialization of <code>T</code> would invoke a user-provided constructor of <code>T</code> (not inherited from a base class) or if<br>\n  \u2014 each direct non-variant non-static data member <code>M</code> of <code>T</code> has a default member initializer or, if <code>M</code> is of class type <code>X</code> (or array thereof), <code>X</code> is const-default-constructible,<br>\n  \u2014 if <code>T</code> is a union with at least one non-static data member, exactly one variant member has a default member initializer,<br>\n  \u2014 if <code>T</code> is a not a union, for each anonymous union member with at least one non-static data member (if any), exactly one non-static data member has a default member initializer, and each potentially constructed base class of <code>T</code> is const-default-constructible.</br></br></br></p>\n<p id=\"so_42753585_42754529_2\">If a program calls for the default-initialization of an object of a const-qualified type T, T shall be a const-default-constructible class type or array thereof.</p>\n</blockquote>\n<p><code>Op&lt;uint8_t&gt;</code> is <em>const-default-constructible</em> (for the trivial reason that it has no non-static data members), so you can default-initialize it. Now, C++14 will allow:</p>\n<pre><code>constexpr Op&lt;uint8_t&gt; op;\n</code></pre>\n<p>Effectively, we went from a gcc bug (allowing default-initialization) to a clang bug (disallowing it). </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-03-13T01:17:58.107", "Id": "42754529", "Score": "9", "CreationDate": "2017-03-12T23:39:08.457", "LastActivityDate": "2017-03-13T01:17:58.107"}, "bq_ids": {"n4140": {"so_42753585_42754529_0": {"section_id": 3286, "quality": 0.9, "length": 9}, "so_42753585_42754529_2": {"section_id": 369, "quality": 0.6, "length": 6}}, "n3337": {"so_42753585_42754529_0": {"section_id": 3156, "quality": 0.9, "length": 9}, "so_42753585_42754529_2": {"section_id": 359, "quality": 0.6, "length": 6}}, "n4659": {"so_42753585_42754529_0": {"section_id": 4048, "quality": 0.7, "length": 7}, "so_42753585_42754529_1": {"section_id": 4048, "quality": 0.9838709677419355, "length": 61}, "so_42753585_42754529_2": {"section_id": 4048, "quality": 1.0, "length": 10}}}});