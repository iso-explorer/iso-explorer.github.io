post_cb({"49075006": {"Id": "49075006", "PostTypeId": "2", "Body": "<p>A name of a class is inserted into the scope of itself as a public member. This is so-called <a href=\"https://stackoverflow.com/questions/25549652/why-is-there-an-injected-class-name\"><em>injected-class-name</em></a>. Name lookup for <code>Base</code> in the derived class <code>Derived_from_Private</code> will find its injected-class-name instead of the normal one. Because the injected-class-name of <code>Base</code> is treated as a public member of <code>Base</code>, thus is treated as a private number of <code>Priv_Derv</code>, it is inaccessible in <code>Derived_from_Private</code>.</p>\n<p>Quoted from <a href=\"http://www.eel.is/c++draft/class.access.spec#5\" rel=\"nofollow noreferrer\">[class.access.spec] paragraph 5</a>:</p>\n<blockquote>\n<p id=\"so_49060458_49075006_0\">[\u2009<em>Note:</em> In a derived class, the lookup of a base class name will find the injected-class-name instead of the name of the base class in the scope in which it was declared. The injected-class-name might be less accessible than the name of the base class in the scope in which it was declared. \u2014\u2009<em>end note</em>\u2009] [\u2009<em>Example:</em></p>\n<pre><code>class A { };\nclass B : private A { };\nclass C : public B {\n  A* p;             // error: injected-class-name A is inaccessible\n  ::A* q;           // OK\n};\n</code></pre>\n<p id=\"so_49060458_49075006_1\">\u2014\u2009<em>end example</em>\u2009]</p>\n</blockquote>\n", "LastActivityDate": "2018-03-02T18:12:08.520", "Score": "0", "CreationDate": "2018-03-02T18:12:08.520", "ParentId": "49060458", "CommentCount": "0", "OwnerUserId": "5376789"}, "49060458": {"ViewCount": "82", "Body": "<p>Why the derived class Derived_from_Private is illegal?\ni noticed the member function has an reference to Base, but why it cannot have an reference to Base class?</p>\n<pre><code>class Base {\npublic:\n  void pub_mem(); // public member\nprotected:\n  int prot_mem; // protected member\nprivate:\n  char priv_mem; // private member\n};\n\nstruct Pub_Derv : public Base {\n  // legal\n  void memfcn(Base &amp;b) { b = *this; }\n};\n\nstruct Priv_Derv : private Base {\n  // legal\n  void memfcn(Base &amp;b) { b = *this; }\n};\n\nstruct Prot_Derv : protected Base {\n  // legal\n  void memfcn(Base &amp;b) { b = *this; }\n};\n\nstruct Derived_from_Public : public Pub_Derv {\n  // legal\n  void memfcn(Base &amp;b) { b = *this; }\n};\n\nstruct Derived_from_Private : public Priv_Derv {\n  // illegal\n  void memfcn(Base &amp;b) { b = *this; }\n};\n\nstruct Derived_from_Protected : public Prot_Derv {\n  // legal\n  void memfcn(Base &amp;b) { b = *this; }\n};\n</code></pre>\n", "Title": "why this definition of a derived class is illegal?", "CreationDate": "2018-03-01T23:32:49.373", "LastActivityDate": "2018-03-02T18:12:08.520", "CommentCount": "2", "PostTypeId": "1", "Id": "49060458", "Score": "3", "OwnerUserId": "8763596", "Tags": "<c++><class><c++11><inheritance>", "AnswerCount": "4"}, "49065024": {"Id": "49065024", "PostTypeId": "2", "Body": "<p>Inheritance can provide both <strong>subtyping</strong> and <strong>structural extension</strong>.</p>\n<p>When you inherits privately from a base class you have no subtyping, only structural extension. Then (in your problematic case) when you write <code>b = *this</code> alas <code>*this</code> is <strong>not</strong> of the type <code>Base</code> because you have used private inheritance of it.</p>\n<p>Private inheritance is usually used (that doesn't mean it's a good practice) to easily construct very simple composition (<strong>has a</strong> base, but not <strong>is a</strong> base).</p>\n", "LastActivityDate": "2018-03-02T08:06:37.960", "Score": "0", "CreationDate": "2018-03-02T08:06:37.960", "ParentId": "49060458", "CommentCount": "4", "OwnerUserId": "719263"}, "49060573": {"Id": "49060573", "PostTypeId": "2", "Body": "<p>The expression</p>\n<pre><code>b = *this;\n</code></pre>\n<p>needs to invoke an implicit conversion from <code>*this</code> to an lvalue of type <code>Base</code> in order to call the implicitly declared <code>Base::operator=(const Base&amp;)</code>. This conversion goes through the path <code>Derived_from_Private -&gt; Priv_Derv -&gt; Base</code>. Since <code>Priv_Derv</code> has <code>Base</code> as a private base, <code>Derived_from_Private</code> does not have access to the second link.</p>\n", "LastActivityDate": "2018-03-01T23:44:00.480", "Score": "3", "CreationDate": "2018-03-01T23:44:00.480", "ParentId": "49060458", "CommentCount": "2", "OwnerUserId": "481267"}, "49060600": {"Id": "49060600", "PostTypeId": "2", "Body": "<p><code>Priv_Derv</code> inherits privately <code>Base</code>.  This means that only the class itself knows that it's also a <code>Base</code> and only the member functions of <code>Priv_Derv</code> can use members of <code>Base</code>. </p>\n<p>You can later let <code>Derived_from_Private</code> inherit publicly from <code>Priv_Derv</code>.  It's legal. But unfortunately, due to the former private inheritance, it's as if  <code>Derived_from_Private</code> doesn't have <code>Base</code> as base class.    </p>\n<p>Therefore your member function will fail to compile:  </p>\n<pre><code>    void memfcn(Base &amp;b) { b = *this; }\n</code></pre>\n<p><code>*this</code> is a <code>Derived_from_Private</code>,  but it's illegal to convert it to a <code>Base</code> class, because there is no known relation with that class due to the private inheritance.   </p>\n", "LastActivityDate": "2018-03-01T23:46:50.103", "Score": "2", "CreationDate": "2018-03-01T23:46:50.103", "ParentId": "49060458", "CommentCount": "3", "OwnerUserId": "3723423"}, "bq_ids": {"n4140": {"so_49060458_49075006_0": {"length": 27, "quality": 0.84375, "section_id": 6677}}, "n3337": {"so_49060458_49075006_0": {"length": 27, "quality": 0.84375, "section_id": 6432}}, "n4659": {"so_49060458_49075006_0": {"length": 27, "quality": 0.84375, "section_id": 8152}}}});