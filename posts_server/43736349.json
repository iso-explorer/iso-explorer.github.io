post_cb({"43736576": {"ParentId": "43736349", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This is undefined behavior, because the two definitions of the same inline function with external linkage break C++ requirement for objects that can be defined in several places, known as <em>One Definition Rule</em>:</p>\n<blockquote>\n<h3>3.2 One definition rule</h3>\n<p id=\"so_43736349_43736576_0\">...</p>\n<ol start=\"6\">\n<li>There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with external linkage (7.1.2), class template (Clause 14),[...] in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one translation unit, then</li>\n</ol>\n<p id=\"so_43736349_43736576_1\">6.1 each definition of D shall consist of the same sequence of tokens; [...]</p>\n</blockquote>\n<p>This is not an issue with <code>static</code> functions, because one definition rule does not apply to them: C++ considers <code>static</code> functions defined in different translation units to be independent of each other.</p>\n", "OwnerUserId": "335858", "LastEditorUserId": "335858", "LastEditDate": "2017-05-02T11:52:30.420", "Id": "43736576", "Score": "40", "CreationDate": "2017-05-02T11:19:06.820", "LastActivityDate": "2017-05-02T11:52:30.420"}, "43739466": {"ParentId": "43736349", "CommentCount": "3", "Body": "<p>POINT OF CLARIFICATION:</p>\n<p>Although the answer rooted in C++ inline rule is correct, it only applies if both sources are compiled together.  If they are compiled separately, then, as one commentator noted, each resulting object file would contain its own 'foo()'.  HOWEVER: If these two object files are then linked together, then because both 'foo()'-s are non-static, the name 'foo()' appears in the exported symbol table of both object files; then <em>the linker</em> has to coalesce the two table entries, hence all internal calls are re-bound to one of the two routines (presumably the one in the first object file processed, since it is already bound [i.e the linker would treat the second record as 'extern' regardless of binding]).</p>\n", "OwnerUserId": "7952370", "PostTypeId": "2", "Id": "43739466", "Score": "-3", "CreationDate": "2017-05-02T13:42:02.730", "LastActivityDate": "2017-05-02T13:42:02.730"}, "43736349": {"CommentCount": "1", "CreationDate": "2017-05-02T11:07:17.723", "PostTypeId": "1", "AcceptedAnswerId": "43736576", "LastEditorUserId": "4973224", "LastActivityDate": "2017-05-03T06:55:58.797", "LastEditDate": "2017-05-03T06:55:58.797", "ViewCount": "2481", "FavoriteCount": "6", "Title": "Why does defining inline global function in 2 different cpp files cause a magic result?", "Id": "43736349", "Score": "29", "Body": "<p>Suppose I have two .cpp files <code>file1.cpp</code> and <code>file2.cpp</code>:</p>\n<pre><code>// file1.cpp\n#include &lt;iostream&gt;\n\ninline void foo()\n{\n    std::cout &lt;&lt; \"f1\\n\";\n}\n\nvoid f1()\n{\n    foo();\n}\n</code></pre>\n<p>and </p>\n<pre><code>// file2.cpp\n#include &lt;iostream&gt;\n\ninline void foo()\n{\n   std::cout &lt;&lt; \"f2\\n\";\n}\n\nvoid f2()\n{\n    foo();\n}\n</code></pre>\n<p>And in <code>main.cpp</code> I have forward declared the <code>f1()</code> and <code>f2()</code>:</p>\n<pre><code>void f1();\nvoid f2();\n\nint main()\n{\n    f1();\n    f2();\n}\n</code></pre>\n<p>Result (<em>doesn't depend on build, same result for debug/release builds</em>):</p>\n<pre><code>f1\nf1\n</code></pre>\n<p>Whoa: Compiler somehow picks only the definition from <code>file1.cpp</code> and uses it also in <code>f2()</code>. What is the exact explanation of this behavior?.</p>\n<p>Note, that changing <code>inline</code> to <code>static</code> is a solution for this problem. Putting the inline definition inside an unnamed namespace also solves the problem and the program prints:</p>\n<pre><code>f1\nf2\n</code></pre>\n", "Tags": "<c++><inline><translation-unit>", "OwnerUserId": "3552478", "AnswerCount": "4"}, "43739699": {"ParentId": "43736349", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>As others have noted, the compilers are in compliance with the C++ standard because the <strong>One definition rule</strong> states that you shall have only one definition of a function, except if the function is inline then the definitions must be the same.</p>\n<p>In practice, what happens is that the function is flagged as inline, and at linking stage if it runs into multiple definitions of an inline flagged token, the linker silently discards all but one.  If it runs into multiple definitions of a token not flagged inline, it instead generates an error.</p>\n<p>This property is called <code>inline</code> because, prior to LTO (link time optimization), taking the body of a function and \"inlining\" it at the call site required that the compiler have the body of the function.  <code>inline</code> functions could be put in header files, and each cpp file could see the body and \"inline\" the code into the call site.</p>\n<p>It doesn't mean that the code is <em>actually</em> going to be inlined; rather, it makes it easier for compilers to inline it.</p>\n<p>However, I am unaware of a compiler that checks that the definitions are identical before discarding duplicates.  This includes compilers that otherwise check definitions of function bodies for being identical, such as MSVC's COMDAT folding.  This makes me sad, because it is a reall subtle set of bugs.</p>\n<p>The proper way around your problem is to place the function in an anonymous namespace.  In general, you should consider putting <em>everything</em> in a source file in an anonymous namespace.</p>\n<p>Another really nasty example of this:</p>\n<pre><code>// A.cpp\nstruct Helper {\n  std::vector&lt;int&gt; foo;\n  Helper() {\n    foo.reserve(100);\n  }\n};\n// B.cpp\nstruct Helper {\n  double x, y;\n  Helper():x(0),y(0) {}\n};\n</code></pre>\n<p>methods defined in the body of a class are <em>implicitly inline</em>.  The ODR rule applies.  Here we have two different <code>Helper::Helper()</code>, both inline, and they differ.</p>\n<p>The sizes of the two classes differ.  In one case, we initialize two <code>sizeof(double)</code> with <code>0</code> (as the zero float is zero bytes in most situations).</p>\n<p>In another, we first initialize <em>three</em> <code>sizeof(void*)</code> with zero, then call <code>.reserve(100)</code> on those bytes interpreting them as a vector.</p>\n<p>At link time, one of these two implementations is discarded and used by the other.  What more, which one is discarded is likely to be pretty determistic in a full build.  In a partial build, it could change order.</p>\n<p>So now you have code that might build and work \"fine\" in a full build, but a partial build causes memory corruption.  And changing the order of files in makefiles could cause memory corruption, or even changing the order lib files are linked, or upgrading your compiler, etc.</p>\n<p>If both cpp files had a <code>namespace {}</code> block containing everything except the stuff you are exporting (which can use fully qualified namespace names), this could not happen.</p>\n<p>I've caught exactly this bug in production multiple times.  Given how subtle it is, I do not know how many times it slipped through, waiting for its moment to pounce.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2017-05-02T15:43:07.863", "Id": "43739699", "Score": "11", "CreationDate": "2017-05-02T13:52:30.640", "LastActivityDate": "2017-05-02T15:43:07.863"}, "43736480": {"ParentId": "43736349", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The compiler may assume that all definitions of the same <code>inline</code> function are identical across all translation units because the standard says so. So it can choose any definition it wants. In your case, that happened to be the one with <code>f1</code>. </p>\n<p>Note that you cannot rely on the compiler always picking the same definition, violating the aforementioned rule makes the program ill-formed. The compiler could also diagnose that and error out.</p>\n<p>If the function is <code>static</code> or in an anonymous namespace, you have two distinct functions called <code>foo</code> and the compiler must pick the one from the right file. </p>\n<hr>\n<p>Relevant standardese for reference:</p>\n<blockquote>\n<p id=\"so_43736349_43736480_0\">An inline function shall be defined in every translation unit in which it is odr-used <strong>and shall have exactly\n  the same definition in every case (3.2)</strong>. [...]</p>\n</blockquote>\n<p>7.1.2/4 in N4141, emphasize mine.</p>\n</hr>", "OwnerUserId": "3002139", "LastEditorUserId": "3002139", "LastEditDate": "2017-05-02T13:59:05.767", "Id": "43736480", "Score": "31", "CreationDate": "2017-05-02T11:14:27.273", "LastActivityDate": "2017-05-02T13:59:05.767"}, "bq_ids": {"n4140": {"so_43736349_43736576_1": {"section_id": 7043, "quality": 1.0, "length": 6}, "so_43736349_43736480_0": {"section_id": 5404, "quality": 1.0, "length": 13}}, "n3337": {"so_43736349_43736576_1": {"section_id": 6788, "quality": 1.0, "length": 6}, "so_43736349_43736480_0": {"section_id": 5199, "quality": 1.0, "length": 13}}, "n4659": {"so_43736349_43736480_0": {"section_id": 6853, "quality": 1.0, "length": 13}, "so_43736349_43736576_1": {"section_id": 8540, "quality": 1.0, "length": 6}}}});