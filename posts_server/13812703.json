post_cb({"13812747": {"ParentId": "13812703", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>You can use the <code>{}</code> syntax to initialize the new element:</p>\n<pre><code>V.emplace_back(T{42, 3.14, \"foo\"});\n</code></pre>\n<p>This may or may not be optimized, but it should be.</p>\n<p>You have to define a constructor for this to work, note that with your code you can't even do:</p>\n<pre><code>T a(42, 3.14, \"foo\");\n</code></pre>\n<p>But this is what you need to have emplace work.</p>\n<p>so just:</p>\n<pre><code>struct T { \n  ...\n  T(int a_, double b_, string c_) a(a_), b(b_), c(c_) {}\n}\n</code></pre>\n<p>will make it work the desired way.</p>\n", "OwnerUserId": "390913", "LastEditorUserId": "390913", "LastEditDate": "2017-09-22T07:08:22.470", "Id": "13812747", "Score": "-3", "CreationDate": "2012-12-11T02:33:56.347", "LastActivityDate": "2017-09-22T07:08:22.470"}, "bq_ids": {"n4140": {"so_13812703_13813460_1": {"section_id": 715, "quality": 0.9230769230769231, "length": 12}, "so_13812703_13813460_2": {"section_id": 715, "quality": 0.875, "length": 21}, "so_13812703_13813460_0": {"section_id": 715, "quality": 1.0, "length": 20}}, "n3337": {"so_13812703_13813460_1": {"section_id": 704, "quality": 0.9230769230769231, "length": 12}, "so_13812703_13813460_2": {"section_id": 704, "quality": 0.875, "length": 21}, "so_13812703_13813460_0": {"section_id": 704, "quality": 1.0, "length": 20}}, "n4659": {"so_13812703_13813460_1": {"section_id": 745, "quality": 0.9230769230769231, "length": 12}, "so_13812703_13813460_2": {"section_id": 745, "quality": 0.8333333333333334, "length": 20}, "so_13812703_13813460_0": {"section_id": 745, "quality": 0.9, "length": 18}}}, "13812759": {"ParentId": "13812703", "CommentCount": "6", "Body": "<p>you have to define a constructor for your type <code>T</code> because it contains an <code>std::string</code> which is not trivial.</p>\n<p>moreover, it would be better to define (possible defaulted) move ctor/assign (because you have a movable <code>std::string</code> as member) -- this would help to move your <code>T</code> much more efficient...</p>\n<p>or, just use <code>T{...}</code> to call overloaded <code>emplace_back()</code> as recommended in neighboug response... everything depends on your typical use cases...</p>\n", "OwnerUserId": "1655064", "PostTypeId": "2", "Id": "13812759", "Score": "-2", "CreationDate": "2012-12-11T02:34:53.037", "LastActivityDate": "2012-12-11T02:34:53.037"}, "13813460": {"ParentId": "13812703", "CommentCount": "0", "Body": "<p>This seems to be covered in 23.2.1/13.</p>\n<p>First, definitions:</p>\n<blockquote>\n<p id=\"so_13812703_13813460_0\">Given a container type X having an allocator_type identical to A and a\n  value_type identical to T and given an lvalue m of type A, a pointer p\n  of type T*, an expression v of type T, and an rvalue rv of type T, the\n  following terms are defined.</p>\n</blockquote>\n<p>Now, what makes it emplace-constructible:</p>\n<blockquote>\n<p id=\"so_13812703_13813460_1\">T is EmplaceConstructible into X from args , for zero or more\n  arguments args, means that the following expression is well-formed:\n  allocator_traits::construct(m, p, args);</p>\n</blockquote>\n<p>And finally a note about the default implementation of the construct call:</p>\n<blockquote>\n<p id=\"so_13812703_13813460_2\">Note: A container calls allocator_traits::construct(m, p, args) to\n  construct an element at p using args. The default construct in\n  std::allocator will call ::new((void*)p) T(args), but specialized\n  allocators may choose a different definition.</p>\n</blockquote>\n<p>This pretty much tells us that for a default (and potentially the only) allocator scheme you <em>must</em> have defined a constructor with the proper number of arguments for the thing you're trying to emplace-construct into a container.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "13813460", "Score": "3", "CreationDate": "2012-12-11T04:05:56.840", "LastActivityDate": "2012-12-11T04:05:56.840"}, "13812902": {"ParentId": "13812703", "CommentCount": "3", "Body": "<p>Of course, this is not an answer, but it shows an interesting feature of tuples:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nusing T = tuple &lt;\n    int,\n    double,\n    string\n&gt;;\n\nvector&lt;T&gt; V;\n\nint main()\n{\n    V.emplace_back(42, 3.14, \"foo\");\n}\n</code></pre>\n", "OwnerUserId": "1566221", "PostTypeId": "2", "Id": "13812902", "Score": "12", "CreationDate": "2012-12-11T02:51:58.633", "LastActivityDate": "2012-12-11T02:51:58.633"}, "13813268": {"ParentId": "13812703", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>You need to explicitly define a ctor for the class:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct T\n{\n    int a;\n    double b;\n    string c;\n\n    T(int a, double b, string &amp;&amp;c) : a(a), b(b), c(c) {}\n};\n\nvector&lt;T&gt; V;\n\nint main()\n{\n    V.emplace_back(42, 3.14, \"foo\");\n}\n</code></pre>\n<p>The point of using <code>emplace_back</code> is to avoid creating a temporary object, which is then copied (or moved) to the destination. While it is also possible to create a temporary object, then pass that to <code>emplace_back</code>, it defeats (at least most of) the purpose. What you want to do is pass individual arguments, then let <code>emplace_back</code> invoke the ctor with those arguments to create the object in place.</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2016-11-23T03:44:13.977", "Id": "13813268", "Score": "45", "CreationDate": "2012-12-11T03:41:14.417", "LastActivityDate": "2016-11-23T03:44:13.977"}, "13845075": {"ParentId": "13812703", "CommentCount": "2", "Body": "<p>If you do not want to (or cannot) add a constructor, specialize allocator for T (or create your own allocator).</p>\n<pre><code>namespace std {\n    template&lt;&gt;\n    struct allocator&lt;T&gt; {\n        typedef T value_type;\n        value_type* allocate(size_t n) { return static_cast&lt;value_type*&gt;(::operator new(sizeof(value_type) * n)); }\n        void deallocate(value_type* p, size_t n) { return ::operator delete(static_cast&lt;void*&gt;(p)); }\n        template&lt;class U, class... Args&gt;\n        void construct(U* p, Args&amp;&amp;... args) { ::new(static_cast&lt;void*&gt;(p)) U{ std::forward&lt;Args&gt;(args)... }; }\n    };\n}\n</code></pre>\n<p>Note: Member function construct shown above cannot compile with clang 3.1(Sorry, I don't know why).\nTry next one if you will use clang 3.1 (or other reasons).</p>\n<pre><code>void construct(T* p, int a, double b, const string&amp; c) { ::new(static_cast&lt;void*&gt;(p)) T{ a, b, c }; }\n</code></pre>\n", "OwnerUserId": "1873224", "PostTypeId": "2", "Id": "13845075", "Score": "2", "CreationDate": "2012-12-12T17:15:28.070", "LastActivityDate": "2012-12-12T17:15:28.070"}, "13812703": {"CommentCount": "5", "AcceptedAnswerId": "13812747", "CreationDate": "2012-12-11T02:29:49.493", "LastActivityDate": "2017-09-22T07:08:22.470", "PostTypeId": "1", "ViewCount": "18177", "FavoriteCount": "6", "Title": "C++11 emplace_back on vector<struct>?", "Id": "13812703", "Score": "48", "Body": "<p>Consider the following program:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct T\n{\n    int a;\n    double b;\n    string c;\n};\n\nvector&lt;T&gt; V;\n\nint main()\n{\n    V.emplace_back(42, 3.14, \"foo\");\n}\n</code></pre>\n<p>It doesn't work:</p>\n<pre><code>$ g++ -std=gnu++11 ./test.cpp\nIn file included from /usr/include/c++/4.7/x86_64-linux-gnu/bits/c++allocator.h:34:0,\n                 from /usr/include/c++/4.7/bits/allocator.h:48,\n                 from /usr/include/c++/4.7/string:43,\n                 from ./test.cpp:1:\n/usr/include/c++/4.7/ext/new_allocator.h: In instantiation of \u2018void __gnu_cxx::new_allocator&lt;_Tp&gt;::construct(_Up*, _Args&amp;&amp; ...) [with _Up = T; _Args = {int, double, const char (&amp;)[4]}; _Tp = T]\u2019:\n/usr/include/c++/4.7/bits/alloc_traits.h:253:4:   required from \u2018static typename std::enable_if&lt;std::allocator_traits&lt;_Alloc&gt;::__construct_helper&lt;_Tp, _Args&gt;::value, void&gt;::type std::allocator_traits&lt;_Alloc&gt;::_S_construct(_Alloc&amp;, _Tp*, _Args&amp;&amp; ...) [with _Tp = T; _Args = {int, double, const char (&amp;)[4]}; _Alloc = std::allocator&lt;T&gt;; typename std::enable_if&lt;std::allocator_traits&lt;_Alloc&gt;::__construct_helper&lt;_Tp, _Args&gt;::value, void&gt;::type = void]\u2019\n/usr/include/c++/4.7/bits/alloc_traits.h:390:4:   required from \u2018static void std::allocator_traits&lt;_Alloc&gt;::construct(_Alloc&amp;, _Tp*, _Args&amp;&amp; ...) [with _Tp = T; _Args = {int, double, const char (&amp;)[4]}; _Alloc = std::allocator&lt;T&gt;]\u2019\n/usr/include/c++/4.7/bits/vector.tcc:97:6:   required from \u2018void std::vector&lt;_Tp, _Alloc&gt;::emplace_back(_Args&amp;&amp; ...) [with _Args = {int, double, const char (&amp;)[4]}; _Tp = T; _Alloc = std::allocator&lt;T&gt;]\u2019\n./test.cpp:17:32:   required from here\n/usr/include/c++/4.7/ext/new_allocator.h:110:4: error: no matching function for call to \u2018T::T(int, double, const char [4])\u2019\n/usr/include/c++/4.7/ext/new_allocator.h:110:4: note: candidates are:\n./test.cpp:6:8: note: T::T()\n./test.cpp:6:8: note:   candidate expects 0 arguments, 3 provided\n./test.cpp:6:8: note: T::T(const T&amp;)\n./test.cpp:6:8: note:   candidate expects 1 argument, 3 provided\n./test.cpp:6:8: note: T::T(T&amp;&amp;)\n./test.cpp:6:8: note:   candidate expects 1 argument, 3 provided\n</code></pre>\n<p>What is the correct way to do this and why?</p>\n<p>(Also tried single and double braces)</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1131467", "AnswerCount": "6"}});