post_cb({"30352638": {"Id": "30352638", "PostTypeId": "2", "Body": "<p>This function declaration</p>\n<pre><code>void fa( const A a );\n</code></pre>\n<p>is equivalent to</p>\n<pre><code>void fa( const char a[8] );\n</code></pre>\n<p>that in turn is equivalent to</p>\n<pre><code>void fa( const char *a );\n</code></pre>\n<p>and all of them declare the same one function  Within the function the parameter has type <code>const char *</code> as in the last function declaration.</p>\n<p>On the other hand string literals have types of constant character arrays that in expressions are also implicitly converted to pointers to their first elements.</p>\n<p>Thus in thsi assignment</p>\n<pre><code>a = \"qwe\"; // ok\n</code></pre>\n<p>string literal \"qwe\" that has type <code>const char[4]</code> is implicitly converted to type const <code>char *</code>.</p>\n<p>So the left side of the assignment has type <code>const char *</code> and the right side of the assignment has the same type <code>const char *</code>.</p>\n<p>So there is no problem.</p>\n<p>Take into account that in this declaration</p>\n<pre><code>const A a\n</code></pre>\n<p>typedef name is substituted for the original type and you get</p>\n<pre><code>const char[8]\n</code></pre>\n<p>Take into account that according to the C++ Standard (3.9.3 CV-qualifiers)</p>\n<blockquote>\n<p id=\"so_30352301_30352638_0\">2 ... Any cv-qualifiers applied to an array type affect the array \n  element type, not the array type (8.3.4).</p>\n</blockquote>\n<p>On the other hand in this declaration</p>\n<pre><code>const P p\n</code></pre>\n<p>P is substituted to <code>char *</code> and you get <code>char * const</code> that is you get constant pointer that may not change its value.</p>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2015-05-20T14:39:34.260", "Score": "1", "CreationDate": "2015-05-20T14:28:30.600", "ParentId": "30352301", "CommentCount": "0", "LastEditDate": "2015-05-20T14:39:34.260", "OwnerUserId": "2877241"}, "30379168": {"Id": "30379168", "PostTypeId": "2", "Body": "<p>Arrays inside parameter lists are weird.</p>\n<pre><code>void foo(char a[10], char b) {\n    char c[10];\n    char d;\n}\n</code></pre>\n<p>As you might expect, <code>sizeof(d)</code> and <code>sizeof(b)</code> are both <code>1</code>. And <code>sizeof(c)==10</code>, as expected.</p>\n<p>But <code>sizeof(a)</code> will be either or 4 or 8, depending on the number of bits of your platform. It will be the size of a pointer.</p>\n<p>So basically, an array inside a parameter list is different from an array anywhere else.</p>\n<p>So <code>c</code> really is an array, and you cannot do <code>c = \"hi\";</code>.</p>\n<p>But the compiler will silently replace arrays in parameters with a pointer. So <code>void foo(char a[10], char b)</code> is rewritten as <code>void foo(char *a, char b)</code>.</p>\n<p>And the <code>const</code> is applied to the array before it is rewritten as a pointer - so you get a non-const pointer to const characters.</p>\n<p>The lesson here is that arrays in parameters are basically useless. All size information is lost. The compiler won't stop you passing an array of large size to an array parameter of smaller size.</p>\n<p>The only useful way to have an array in a parameter list is as a reference.</p>\n<pre><code>void foo(char (&amp;a)[10], b) {\n}\n</code></pre>\n<p>In this case, you will get an error message if you pass an array that doesn't have exactly 10 elements. And you will get the behaviour you expect if you assign to the array or to an element of the array.</p>\n<p>And you can use templates to 'remember' the size of the array if you need to know.</p>\n<pre><code>template&lt;size_t N&gt;\nvoid foo(char (&amp;a)[N]) {\n     ....\n}\n</code></pre>\n", "LastEditorUserId": "146041", "LastActivityDate": "2015-05-21T16:21:57.523", "Score": "0", "CreationDate": "2015-05-21T16:15:50.920", "ParentId": "30352301", "CommentCount": "0", "LastEditDate": "2015-05-21T16:21:57.523", "OwnerUserId": "146041"}, "30352301": {"ViewCount": "66", "Body": "<p>Is the handling of constness in <code>fa</code> being turned inside out intentional, or does it look like a bug (compiler or the standard)? I can see how this can happen, but it still feels pretty weird (at the very least I would expect <code>a = \"qwe\"</code> to be treated as an error, too---like in <code>fs</code>).</p>\n<pre><code>typedef char A[8];\ntypedef char *P;\ntypedef std::string S;\n\nvoid fa( const A a ) {\n    a = \"qwe\"; // ok\n    // *a = 'Q'; // error\n}\n\nvoid fp( const P p ) {\n    // p = \"qwe\"; // error\n    *p = 'Q'; // ok\n}\n\nvoid fs( const S s ) {\n    // s = \"qwe\"; // error\n    // *s = 'Q'; // error\n}\n</code></pre>\n<p>[MinGW 4.9.1]</p>\n<p>CLARIFICATION: I understand the general way this conversion works, hence the \"I can see how this can happen\" part. What this question is about, is (a) std references (thanks to those who provided them), and (b) if there is an actual rationale for this quirk (which is pretty counter-intuitive).</p>\n", "AcceptedAnswerId": "30352621", "Title": "Const vs. array-to-pointer conversions", "CreationDate": "2015-05-20T14:15:25.513", "Id": "30352301", "CommentCount": "2", "LastEditDate": "2015-05-20T15:23:10.320", "PostTypeId": "1", "LastEditorUserId": "1558356", "LastActivityDate": "2015-05-21T16:21:57.523", "Score": "0", "OwnerUserId": "1558356", "Tags": "<c++><arrays><type-conversion><const><language-lawyer>", "AnswerCount": "4"}, "30352621": {"Id": "30352621", "PostTypeId": "2", "Body": "<p>This is correct: the parameter type of <code>fa</code> is <code>const char *</code>, not <code>char * const</code>. This a subtlety of the meaning of an array declaration, and the adjustment of an array type to a pointer type as a function argument.</p>\n<p>First the array type itself is adjusted:</p>\n<blockquote>\n<p id=\"so_30352301_30352621_0\">C++11 8.3.4/1: Any type of the form \u201ccv-qualifier-seq array of N T\u201d is adjusted to \u201carray of N cv-qualifier-seq T\u201d</p>\n</blockquote>\n<p>so initially, the type becomes \"array of <code>const char</code>\". Then, since it's a function parameter, the type is further adjusted:</p>\n<blockquote>\n<p id=\"so_30352301_30352621_1\">C++11 8.3.5/5: any parameter of type \u201carray of T\u201d [...] is\n  adjusted to be \u201cpointer to T\u201d</p>\n</blockquote>\n<p>So the final type is \"pointer to <code>const char</code>\", or <code>const char *</code>. Hence, as your example shows, you can modify the pointer, but not the data it point to.</p>\n<p>For the other examples, the parameter types are themselves <code>const</code>: for <code>fp</code> it's <code>char * const</code>, allowing modification of the data but not the pointer; and for <code>fp</code> it's <code>const string</code>, allowing no modification at all.</p>\n", "LastActivityDate": "2015-05-20T14:28:09.050", "Score": "2", "CreationDate": "2015-05-20T14:28:09.050", "ParentId": "30352301", "CommentCount": "1", "OwnerUserId": "204847"}, "bq_ids": {"n4140": {"so_30352301_30352621_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 558}, "so_30352301_30352638_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 7226}}, "n3337": {"so_30352301_30352621_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 549}, "so_30352301_30352638_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6970}}, "n4659": {"so_30352301_30352621_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 63}, "so_30352301_30352621_0": {"length": 7, "quality": 0.7, "section_id": 3985}, "so_30352301_30352638_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 8736}}}, "30352492": {"Id": "30352492", "PostTypeId": "2", "Body": "<p><code>A</code> has type <code>char[8]</code>. <code>const A</code> is <code>const char[8]</code>. The parameter of <code>fa</code> is therefore <code>const char[8]</code>, which decays to a pointer <code>const char*</code>, so everything is fine in <code>fa</code>, as you are assigning a string literal (of type <code>const char[SIZE]</code>) to the pointer <code>a</code>).</p>\n<p><code>P</code> has type <code>char*</code>. <code>const P</code> has type <code>char* const</code> (not <code>const char*</code>), as the const is applied to the pointer. So you cannot assign <code>p</code> to some other pointer. <code>*p = 'Q'</code> is OK since you are assigning to the location the pointer points to. Hence the second function <code>fb</code> also behaves as expected.</p>\n", "LastActivityDate": "2015-05-20T14:23:01.800", "Score": "3", "CreationDate": "2015-05-20T14:23:01.800", "ParentId": "30352301", "CommentCount": "0", "OwnerUserId": "3093378"}});