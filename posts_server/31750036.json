post_cb({"31750036": {"CommentCount": "3", "ViewCount": "414", "PostTypeId": "1", "LastEditorUserId": "31818", "CreationDate": "2015-07-31T15:36:27.580", "LastActivityDate": "2015-08-03T00:17:08.163", "Title": "Does std::unique_lock::try_lock_until() busy wait?", "LastEditDate": "2015-08-03T00:17:08.163", "Id": "31750036", "Score": "0", "Body": "<p>I'm thinking of using the following code:</p>\n<pre><code>auto now = std::chrono::high_resolution_clock::now();\n\nstd::unique_lock&lt;std::mutex&gt; lock(mutex, std::defer_lock);\nif(lock.try_lock_until(now + std::chrono::milliseconds(15))\n{\n    // swap some buffer pointers...\n    lock.unlock();\n}\n</code></pre>\n<p>However, it's not clear to me from the documentation if <code>try_lock_until()</code> is implemented as a busy wait or if the thread will yield/sleep in between tries (which is my desired behavior). Is this the best way to query a lock while minimizing thread resource usage?</p>\n", "Tags": "<c++><multithreading><c++11><locking>", "OwnerUserId": "4052030", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31750036_31753894_0": {"section_id": 2774, "quality": 1.0, "length": 23}}, "n3337": {"so_31750036_31753894_0": {"section_id": 2735, "quality": 1.0, "length": 23}}, "n4659": {"so_31750036_31753894_0": {"section_id": 3512, "quality": 1.0, "length": 23}}}, "31753894": {"ParentId": "31750036", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The <a href=\"http://en.cppreference.com/w/cpp/thread/unique_lock/try_lock_until\" rel=\"nofollow\">CppReference page for <code>std::unique_lock::try_lock_until</code></a> indeed only states it \"Blocks until specified <code>timeout_time</code> has been reached or the lock is acquired\". This is not just a shortcoming of the website though. The standard (I used <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">the November 2014 working draft</a>) carefully steers clear of specifying whether a <code>thread</code> has to <code>yield</code> while blocking on any kind of <code>mutex</code>, talking only about acquiring ownership.</p>\n<p>For <code>std::mutex</code>, for instance, section 30.4.1.2.1 states</p>\n<blockquote>\n<p id=\"so_31750036_31753894_0\">If one thread owns a <code>mutex</code> object, attempts by another thread to acquire ownership of that object will fail (for <code>try_lock()</code>) or block (for <code>lock()</code>) until the owning thread has released ownership with a call to unlock().</p>\n</blockquote>\n<p>No mention of scheduling or <code>yield</code>ing is made at all, though.</p>\n<p>Furthermore, even if it did mention <code>yield</code> explicitly, that wouldn't help that much, as <code>this_thread::yield</code> (section 30.3.2) merely \"Offers the implementation the opportunity to reschedule\".</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/thread/yield\" rel=\"nofollow\">CppReference</a> makes this more concrete, stating</p>\n<blockquote>\n<p id=\"so_31750036_31753894_1\">The exact behavior of this function depends on the implementation, in particular on the mechanics of the OS scheduler in use and the state of the system. For example, a first-in-first-out realtime scheduler (SCHED_FIFO in Linux) would suspend the current thread and put it on the back of the queue of the same-priority threads that are ready to run (and if there are no other threads at the same priority, yield has no effect).</p>\n</blockquote>\n<p>So I'm afraid the question of how <code>try_lock_until</code> is implemented <em>in C++</em> cannot be answered. Perhaps you can ask a new question targeting a specific platform. For your second question (\"Is this the best way to query a lock while minimizing thread resource usage?\") the answer is yes, the best option your platform offers should be invoked using this API (though, as T.C. commented, <code>try_lock_for</code> seems like a better fit).</p>\n", "OwnerUserId": "1879192", "LastEditorUserId": "1879192", "LastEditDate": "2015-08-02T23:50:32.390", "Id": "31753894", "Score": "2", "CreationDate": "2015-07-31T19:35:31.963", "LastActivityDate": "2015-08-02T23:50:32.390"}});