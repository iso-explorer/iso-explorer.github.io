post_cb({"14615671": {"CommentCount": "2", "ViewCount": "4851", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-01-30T23:15:59.007", "LastActivityDate": "2013-04-23T12:02:18.387", "Title": "What's the real reason to not use the EOF bit as our stream extraction condition?", "FavoriteCount": "4", "LastEditDate": "2017-05-23T12:09:23.757", "Id": "14615671", "Score": "8", "Body": "<p><sup>Inspired by my <a href=\"https://stackoverflow.com/q/14591203/150634\">previous question</a></sup></p>\n<p>A common mistake for new C++ programmers is to read from a file with something along the lines of:</p>\n<pre><code>std::ifstream file(\"foo.txt\");\nstd::string line;\nwhile (!file.eof()) {\n  file &gt;&gt; line;\n  // Do something with line\n}\n</code></pre>\n<p>They will often report that the last line of the file was read twice. The common explanation for this problem (one that I have given before) goes something like:</p>\n<blockquote>\n<p id=\"so_14615671_14615671_0\">The extraction will only set the EOF bit on the stream if you attempt to extract the end-of-file, not if your extraction just stops at the end-of-file. <code>file.eof()</code> will only tell you if the previous read hit the end-of-file and not if the next one will. After the last line has been extracted, the EOF bit is still not set and the iteration occurs one more time. However, on this last iteration, the extraction fails and <code>line</code> still has the same content as before, i.e. the last line is duplicated.</p>\n</blockquote>\n<p>However, the first sentence of this explanation is wrong and so the explanation of what the code is doing is also wrong.</p>\n<p>The definition of formatted input functions (which <code>operator&gt;&gt;(std::string&amp;)</code> is) defines extraction as using <code>rdbuf()-&gt;sbumpc()</code> or <code>rdbuf()-&gt;sgetc()</code> to obtain input characters. It states that if either of these functions returns <code>traits::eof()</code>, then the EOF bit is set:</p>\n<blockquote>\n<p id=\"so_14615671_14615671_1\">If <code>rdbuf()-&gt;sbumpc()</code> or <code>rdbuf()-&gt;sgetc()</code> returns <code>traits::eof()</code>, then the input function, except as explicitly noted otherwise, completes its actions and does <code>setstate(eofbit)</code>, which may throw <code>ios_base::failure</code> (27.5.5.4), before returning.</p>\n</blockquote>\n<p>We can see this with the simple example that uses a <code>std::stringstream</code> rather than a file (they are both input streams and behave the same way when extracting):</p>\n<pre><code>int main(int argc, const char* argv[])\n{\n  std::stringstream ss(\"hello\");\n  std::string result;\n  ss &gt;&gt; result;\n  std::cout &lt;&lt; ss.eof() &lt;&lt; std::endl; // Outputs 1\n  return 0;\n}\n</code></pre>\n<p>It's clear here that the single extraction obtains <code>hello</code> from the string <em>and</em> sets the EOF bit to 1.</p>\n<p>So what's wrong with the explanation? What's different about files that causes <code>!file.eof()</code> to cause the last line to be duplicated? What's the real reason we shouldn't use <code>!file.eof()</code> as our extraction condition?</p>\n", "Tags": "<c++><iostream><eof><language-lawyer>", "OwnerUserId": "150634", "AnswerCount": "2"}, "14615673": {"ParentId": "14615671", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Yes, extracting from an input stream will set the EOF bit if the extraction stops at the end-of-file, as demonstrated by the <code>std::stringstream</code> example. If it were this simple, the loop with <code>!file.eof()</code> as its condition would work just fine on a file like:</p>\n<pre><code>hello\nworld\n</code></pre>\n<p>The second extraction would eat <code>world</code>, stopping at the end-of-file, and consequently setting the EOF bit. The next iteration wouldn't occur.</p>\n<p>However, many text editors have a dirty secret. They're lying to you when you save a text file even as simple as that. What they don't tell you is that there's a hidden <code>\\n</code> at the end of the file. Every line in the file ends with a <code>\\n</code>, including the last one. So the file actually contains:</p>\n<pre><code>hello\\nworld\\n\n</code></pre>\n<p>This is what causes the last line to be duplicated when using <code>!file.eof()</code> as the condition. Now that we know this, we can see that the second extraction will eat <code>world</code> stopping at <code>\\n</code> and <em>not</em> setting the EOF bit (because we haven't gotten there yet). The loop will iterate for a third time but the next extraction will fail because it doesn't find a string to extract, only whitespace. The string is left with its previous value still hanging around and so we get the duplicated line.</p>\n<p>You don't experience this with <code>std::stringstream</code> because what you stick in the stream is exactly what you get. There's no <code>\\n</code> at the end of <code>std::stringstream ss(\"hello\")</code>, unlike in the file. If you were to do <code>std::stringstream ss(\"hello\\n\")</code>, you'd experience the same duplicate line issue.</p>\n<p>So of course, we can see that we should never use <code>!file.eof()</code> as the condition when extracting from a text file - but what's the real issue here? Why should we really never use that as our condition, regardless of whether we're extracting from a file or not?</p>\n<p>The real problem is that <strong><code>eof()</code> gives us no idea whether the next read will fail or not</strong>. In the above case, we saw that even though <code>eof()</code> was 0, the next extraction failed because there was no string to extract. The same situation would happen if we didn't associate a file stream with any file or if the stream was empty. The EOF bit wouldn't be set but there's nothing to read. We can't just blindly go ahead and extract from the file just because <code>eof()</code> isn't set.</p>\n<p>Using <code>while (std::getline(...))</code> and related conditions works perfectly because just before the extraction starts, the formatted input function checks if any of the bad, fail, or EOF bits are set. If any of them are, it immediately ends, setting the fail bit in the process. It will also fail if it finds the end-of-file before it finds what it wants to extract, setting both the eof and fail bits.</p>\n<hr>\n<p>Note: You can save a file without the extra <code>\\n</code> in vim if you do <code>:set noeol</code> and <code>:set binary</code> before saving.</p>\n</hr>", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2013-01-31T00:13:31.840", "Id": "14615673", "Score": "16", "CreationDate": "2013-01-30T23:15:59.007", "LastActivityDate": "2013-01-31T00:13:31.840"}, "bq_ids": {"n4140": {"so_14615671_14615671_1": {"section_id": 2171, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_14615671_14615671_1": {"section_id": 2159, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_14615671_14615671_1": {"section_id": 2444, "quality": 0.9545454545454546, "length": 21}}}, "16160375": {"ParentId": "14615671", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your question has some bogus conceptions.  You give an explanation:</p>\n<blockquote>\n<p id=\"so_14615671_16160375_0\">\"The extraction will only set the EOF bit on the stream if you attempt to extract the end-of-file, not if your extraction just stops at the end-of-file.\"</p>\n</blockquote>\n<p>Then claim it \"is wrong and so the explanation of what the code is doing is also wrong.\"</p>\n<p>Actually, it's right.  Let's look at an example....</p>\n<p>When reading into a <code>std::string</code>...</p>\n<pre><code>std::istringsteam iss('abc\\n');\nstd::string my_string;\niss &gt;&gt; my_string;\n</code></pre>\n<p>...by default and as in your question <code>operator&gt;&gt;</code> is reading characters until it finds whitespace <em>or</em> EOF.  So:</p>\n<ul>\n<li>reading from <code>'abc\\n'</code> -&gt; once the <code>'\\n'</code> is encountered it doesn't \"attempt to extract the end-of-file\", rather it \"just stops at [EOF]\", and <code>eof()</code> won't return <code>true</code>,</li>\n<li>reading from <code>'abc'</code> instead -&gt; it's the attempt to extract the end-of-file that discovers the end of the the <code>string</code> content, so <code>eof()</code> will return <code>true</code>.</li>\n</ul>\n<p>Similarly, parsing <code>'123'</code> into an <code>int</code> sets <code>eof()</code> because the parsing doesn't know if there will be another digit and tries to keep reading them, hitting <code>eof()</code>.  Parsing <code>'123 '</code> to an <code>int</code> won't set <code>eof()</code>.</p>\n<p>Crucially, parsing 'a' into a <code>char</code> won't set <code>eof()</code> because trailing whitespace isn't needed to know that the parsing is complete - once a character is read no attempt is made to find another character and the <code>eof()</code> isn't encountered.  (Of course further parsing from the same stream hits <code>eof</code>).</p>\n<blockquote>\n<p id=\"so_14615671_16160375_1\">It's clear [for stringstream \"hello\" &gt;&gt; std::string] that the single extraction obtains hello from the string and sets the EOF bit to 1.\n  So what's wrong with the explanation? What's different about files that causes !file.eof() to cause the last line to be duplicated? What's the real reason we shouldn't use !file.eof() as our extraction condition?</p>\n</blockquote>\n<p>The reason is as above... that files tend to be terminated by a '\\n' character, and when they are means getline or <code>&gt;&gt; std::string</code> return the last non-whitespace token without needing to \"attempt to extract the end-of-file\" (to use your phrase).</p>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2013-04-23T12:02:18.387", "Id": "16160375", "Score": "4", "CreationDate": "2013-04-23T03:25:02.787", "LastActivityDate": "2013-04-23T12:02:18.387"}});