post_cb({"26689307": {"ViewCount": "488", "Body": "<p>When studying function templates, I see specializations declared in different ways:</p>\n<pre><code>template&lt;&gt; void f(argtype) {}\ntemplate&lt;&gt; void f&lt;&gt;(argtype) {}\ntemplate&lt;&gt; void f&lt;argtype&gt;(argtype) {}\n</code></pre>\n<p>... and I wonder about the differences between these. Given the below example with template functions with and without parameter, I have a few questions.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\n//Function print1 WITH function parameter---------------------------------------------\ntemplate&lt;class T&gt;\nvoid print1(T) { std::cout &lt;&lt; \"Primary template for print1() with type \" &lt;&lt; typeid(T).name() &lt;&lt;  std::endl; }\n\ntemplate&lt;&gt;\nvoid print1&lt;int&gt;(int) { std::cout &lt;&lt; \"Specialization for print1&lt;int&gt;(int)\" &lt;&lt; std::endl; }\n\n//Not allowed, deduced to be the same as print1&lt;int&gt;(int)\n/*template&lt;&gt;\nvoid print1&lt;&gt;(int) { std::cout &lt;&lt; \"Specialization for print1&lt;&gt;(int)\" &lt;&lt; std::endl; }*/\n\n//Not allowed, deduced to be the same as print1&lt;int&gt;(int)\n/*template&lt;&gt;\nvoid print1(int) { std::cout &lt;&lt; \"Specialization for print1(int)\" &lt;&lt; std::endl; }*/\n\n//Function print2 WITHOUT function parameter------------------------------------------\n/*Not allowed together with print&lt;&gt;(); compiler complains: \n    t2.cpp:29:6: error: template-id 'print2&lt;&gt;' for 'void print2()' does not match any template declaration*/\n/*template&lt;class T&gt;\nvoid print2() { std::cout &lt;&lt; \"Primary template for print2()\" &lt;&lt; std::endl; }*/\n\ntemplate&lt;class T = short&gt; //Declaration of print2&lt;&gt;() now ok in conjunction with print2&lt;&gt;()\nvoid print2() { std::cout &lt;&lt; \"Primary template for print2()\" &lt;&lt; std::endl; }\n\ntemplate&lt;&gt;\nvoid print2&lt;int&gt;() { std::cout &lt;&lt; \"Specialization for print2&lt;int&gt;()\" &lt;&lt; std::endl; }\n\ntemplate&lt;&gt;\nvoid print2&lt;&gt;() { std::cout &lt;&lt; \"Specialization for print2&lt;&gt;()\" &lt;&lt; std::endl; }\n\nint main() {\n    //These three work in the same way, no matter which call method we use, so far so good\n    print1(10);\n    print1&lt;&gt;(10);\n    print1&lt;int&gt;(10);\n    print1(true);\n    print1&lt;&gt;(true);\n    print1&lt;bool&gt;(true);\n\n    print2(); //Triggers print2&lt;&gt;(), a bit unexpectedly, should trigger print2&lt;short&gt;() (primary template)\n    print2&lt;&gt;(); //Triggers print2&lt;&gt;(), a bit unexpectedly, should trigger print2&lt;short&gt;() (primary template)\n    print2&lt;bool&gt;(); //Triggers print2&lt;bool&gt;() primary template\n    print2&lt;short&gt;(); //Triggers print2&lt;&gt;(), should definately trigger primary template for print2()\n    print2&lt;int&gt;(); //Triggers print2&lt;int&gt;() specialization\n    return 0;\n}\n</code></pre>\n<p>outputs:</p>\n<pre><code>Specialization for print1&lt;int&gt;(int)\nSpecialization for print1&lt;int&gt;(int)\nSpecialization for print1&lt;int&gt;(int)\nPrimary template for print1() with type b\nPrimary template for print1() with type b\nPrimary template for print1() with type b\nSpecialization for print2&lt;&gt;()\nSpecialization for print2&lt;&gt;()\nPrimary template for print2()\nSpecialization for print2&lt;&gt;()\nSpecialization for print2&lt;int&gt;()\n</code></pre>\n<ul>\n<li>What special meaning is derived from leaving the template specialization argument empty, non-existent or with the specialized type and how does it effect the outcome?\nIt seems that with a function argument, this specification is superfluous and the compiler deduces it no matter how it's specified (with the result that equivalent explicit specifications become unallowed redeclarations).</li>\n<li>I understand that given a function without parameters, the specialized template argument is needed explicitly in declaration to specify for which instantiation the defined function\napplies to (since it can't be deduced otherwise). But the meaning seems to imply something more in this case and the \"empty\" specialization (&lt;&gt;) is triggered in a somewhat unforeseen ways. How come?</li>\n<li>Why do I have to have a default template parameter when specializing print2 with print2&lt;&gt;() but not without it?</li>\n</ul>\n", "AcceptedAnswerId": "26689568", "Title": "C++ function template specialization declarations and template arguments; none vs. <> vs. <type>", "CreationDate": "2014-11-01T12:28:25.790", "Id": "26689307", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-11-01T13:33:55.737", "Score": "3", "OwnerUserId": "440472", "Tags": "<c++><function><templates><template-specialization>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_26689307_26689568_1": {"length": 38, "quality": 0.8837209302325582, "section_id": 353}, "so_26689307_26689568_2": {"length": 19, "quality": 0.95, "section_id": 354}}, "n3337": {"so_26689307_26689568_1": {"length": 38, "quality": 0.8837209302325582, "section_id": 343}, "so_26689307_26689568_2": {"length": 19, "quality": 0.95, "section_id": 344}}, "n4659": {"so_26689307_26689568_1": {"length": 38, "quality": 0.8837209302325582, "section_id": 363}, "so_26689307_26689568_2": {"length": 19, "quality": 0.95, "section_id": 364}}}, "26689568": {"Id": "26689568", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26689307_26689568_0\">What special meaning is derived from leaving the template\n  specialization argument empty, non-existent or with the specialized\n  type and how does it effect the outcome?</p>\n</blockquote>\n<p>If you do provide a template argument list completely then you're simply explicitly specializing the function template for a <strong>given</strong> set of template arguments.</p>\n<p>If you provide arguments for a (possibly empty) subset of the template parameters then you are explicitly specializing the function template for a set of arguments that has to be <strong>deduced</strong>. According to [temp.deduct.decl]:</p>\n<blockquote>\n<p id=\"so_26689307_26689568_1\">In a declaration whose <em>declarator-id</em> refers to a specialization of a\n  function template, template argument deduction is performed to\n  identify the specialization to which the declaration refers.\n  Specifically, this is done for explicit instantiations (14.7.2),\n  explicit specializations (14.7.3), and certain friend declarations\n  (14.5.4). [\u2026]. In all these cases, <code>P</code> is the type of the function\n  template being considered as a potential match and <code>A</code> is [\u2026] the\n  function type from the declaration [\u2026]. <br> The deduction is done as\n  described in 14.8.2.5.</br></p>\n<p id=\"so_26689307_26689568_2\">If, for the set of function templates so considered, there is either\n  no match or more than one match after partial ordering has been\n  considered (14.5.6.2), deduction fails and, in the declaration cases,\n  the program is ill-formed.</p>\n</blockquote>\n<p>So for every parameter for which no argument was given, or in the case where no list is specified at all, template argument deduction is done for each corresponding parameter of the specialization and its counterpart from the primary template. The process is described in \u00a714.8.2.5 and works just as if we called the primary template with the provided template argument list as the template arguments and objects of the types of the parameters in the specialization as the function arguments.<br><br> You should be familiar with the fact that one can call a function template with some of the template arguments specified, e.g. </br></br></p>\n<pre><code>template &lt;typename A, typename B&gt; void foo(A, B);\n\nfoo(7684, 48.);\nfoo&lt;int&gt;(7684, 48.);\nfoo&lt;int, double&gt;(7684, 48.);\n</code></pre>\n<p>That works equivalently for explicit specializations:</p>\n<pre><code>template &lt;typename T, typename U&gt;\nvoid foo(T, U) {}\n\n// Both template arguments have to be deduced.\ntemplate&lt;&gt; void foo(double, float);\n\n// The *exact* same as above.\n// template&lt;&gt; void foo&lt;&gt;(double, float);\n\n// Second template argument has to be deduced by type.\n// If we call foo&lt;int&gt;(int(), float()) then the deduced specialization is\n// foo&lt;int, float&gt;, thus U=float.\ntemplate&lt;&gt; void foo&lt;int&gt;(int, float);\n\ntemplate&lt;&gt; void foo&lt;int, int&gt;(int, int);\n</code></pre>\n<p>This can also be applied to overloads of a function template. In an attempt to find the primary template a specialization is corresponding to, the most specialized one is chosen.</p>\n<pre><code>template &lt;typename T, typename U&gt;\nvoid foo(T&amp;, U&amp;) {}\n\ntemplate &lt;typename T, typename U&gt;\nvoid foo(T const&amp;, U&amp;) {}\n\n// Specializes the second overload because it is more specialized.\ntemplate &lt;&gt;\nvoid foo(int const&amp;, float&amp;);\n</code></pre>\n<p>Note that while looking for a primary template, the arguments provided (i.e. not to be deduced) are used to check the resulting function parameter of the primary template against the resulting function parameter of the specialization. They have to be equal.</p>\n<pre><code>template &lt;typename T, typename U&gt;\nvoid foo(T&amp;, U&amp;) {}\n\n// Error - no matching primary template found.\ntemplate &lt;&gt;\nvoid foo&lt;int, int&gt;(float&amp;, int&amp;);\n\n// Dito:\ntemplate &lt;&gt;\nvoid foo&lt;int&gt;(int, int&amp;);\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_26689307_26689568_3\">It seems that with a function argument, this specification is\n  superfluous and the compiler deduces it no matter how it's specified\n  (with the result that equivalent explicit specifications become\n  unallowed redeclarations).</p>\n</blockquote>\n<p>Yes, that is indeed the case. Consider that if you specify a template argument invalidly that results in an error:</p>\n<blockquote>\n<p id=\"so_26689307_26689568_4\">But the meaning seems to imply something more in this case and the\n  \"empty\" specialization (&lt;&gt;) is triggered in a somewhat unforeseen\n  ways. How come?</p>\n</blockquote>\n<p>For a call, the template arguments are deduced first. Then the specialization with those template arguments is called. </p>\n<p>If you explicitly specialized a function template for this particular specialization, here that is <code>print2&lt;&gt;</code> which is <code>print2&lt;short&gt;</code>, then that explicit specialization is thus called. <br>In what way is that unforeseen?</br></p>\n<blockquote>\n<p id=\"so_26689307_26689568_5\">Why do I have to have a default template parameter when specializing\n  <code>print2</code> with <code>print2&lt;&gt;()</code> but not without it?</p>\n</blockquote>\n<p>Because the compiler cannot deduce the argument. If you provide a default argument he doesn't <em>have</em> to deduce it in the first place.</p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-01T13:33:55.737", "Score": "3", "CreationDate": "2014-11-01T13:02:13.830", "ParentId": "26689307", "CommentCount": "4", "OwnerUserId": "3647361", "LastEditDate": "2014-11-01T13:33:55.737"}, "26689561": {"Id": "26689561", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26689307_26689561_0\">What special meaning is derived from leaving the template specialization argument empty</p>\n</blockquote>\n<p>Missing arguments are deduced if possible; an empty argument list means that all arguments are to be deduced.</p>\n<blockquote>\n<p id=\"so_26689307_26689561_1\">non-existent</p>\n</blockquote>\n<p>That means you're declaring the primary template, not an explicit specialisation.</p>\n<blockquote>\n<p id=\"so_26689307_26689561_2\">or with the specialized type</p>\n</blockquote>\n<p>That means you're declaring an explicit specialisation for that type.</p>\n<blockquote>\n<p id=\"so_26689307_26689561_3\">the \"empty\" specialization (&lt;&gt;) is triggered in a somewhat unforeseen ways. How come?</p>\n</blockquote>\n<p>In both cases, the template argument is deduced. In <code>print1</code>, the primary template declares that <code>T</code> is the same type as the function parameter; so it's deduced from the function parameter. In <code>print2</code>, it's declared with a default type of <code>short</code>, so that is used. So your surprise at seeing <code>print2&lt;&gt;</code> when you think it should be <code>print2&lt;short&gt;</code> is explained: <code>print2&lt;&gt;</code> <em>is</em> <code>print2&lt;short&gt;</code>.</p>\n<blockquote>\n<p id=\"so_26689307_26689561_4\">Why do I have to have a default template parameter when specializing print2 with print2&lt;&gt;() but not without it?</p>\n</blockquote>\n<p>If there were neither a default argument nor a function parameters from which to deduce an argument, then it would be impossible to deduce a type for the specialisation, so <code>&lt;&gt;</code> couldn't be used. I don't know what you mean by \"without it\"; if you mean \"without <code>&lt;&gt;</code>\", then you're declaring the primary template, not a specialisation, and the parameter is generic.</p>\n", "LastActivityDate": "2014-11-01T13:01:29.793", "CommentCount": "4", "CreationDate": "2014-11-01T13:01:29.793", "ParentId": "26689307", "Score": "2", "OwnerUserId": "204847"}});