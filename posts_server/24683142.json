post_cb({"24683142": {"CommentCount": "1", "ViewCount": "230", "PostTypeId": "1", "LastEditorUserId": "19405", "CreationDate": "2014-07-10T17:49:04.253", "LastActivityDate": "2014-07-11T05:32:33.917", "Title": "Linux memory management overhead", "AcceptedAnswerId": "24683752", "LastEditDate": "2014-07-10T19:00:26.947", "Id": "24683142", "Score": "4", "Body": "<p>I was trying to explain the memory that has been taken to my application in Linux. I did a basic test and figured out that if we new some memory, it allocated at least 32 bytes for a single new.</p>\n<p>This is my code.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n\nusing namespace std;\n\nint main(int argc, const char** argv)\n{\n        int iBlockSize = atoi(argv[1]);\n        int iBlockCount = atoi(argv[2]);\n\n        for (int i = 0 ; i &lt; iBlockCount ; i++)\n        {\n                cout &lt;&lt; (int*)(new char[iBlockSize]) &lt;&lt; endl;\n        }\n        return 0;\n};\n</code></pre>\n<p>When I execute the <code>./a.out 8 100</code> it gave following result.</p>\n<pre><code>....\n....\n....\n0xf6db10\n0xf6db30\n0xf6db50\n0xf6db70\n0xf6db90\n0xf6dbb0\n0xf6dbd0\n0xf6dbf0\n0xf6dc10\n0xf6dc30\n0xf6dc50\n0xf6dc70\n</code></pre>\n<p>All the memory I got was having 32 bytes gap.</p>\n<p>Till 24 (BlockSize) it was the same. If it goes beyond 24 it is 48 bytes.</p>\n<p>./a.out 25 100</p>\n<pre><code>....\n....\n....\n0x18b30c0\n0x18b30f0\n0x18b3120\n0x18b3150\n0x18b3180\n0x18b31b0\n0x18b31e0\n0x18b3210\n0x18b3240\n0x18b3270\n0x18b32a0\n</code></pre>\n<p>When I was testing this for larger sizes; figured out that the memory we are getting is increased by 16 bytes chunks keeping at least 8 byte overhead.</p>\n<p>My questions are,</p>\n<ol>\n<li>Is my test correct?</li>\n<li>Is it the correct behaviour of linux memory management?</li>\n<li>If we new 8 bytes, we get 32. What happened to other 24? Reused or fragmenting overhead?</li>\n</ol>\n", "Tags": "<c++><linux><memory>", "OwnerUserId": "2878256", "AnswerCount": "3"}, "24690658": {"ParentId": "24683142", "CommentCount": "0", "Body": "<p>I found this article</p>\n<p><a href=\"https://software.intel.com/en-us/articles/align-and-organize-data-for-better-performance\" rel=\"nofollow\">https://software.intel.com/en-us/articles/align-and-organize-data-for-better-performance</a></p>\n<p>It says \"If the data will be accessed with vector instruction loads and stores, align the data on 16-byte boundaries.\"</p>\n<p>So looks like it's an alignment decision made by glibc </p>\n", "OwnerUserId": "2227672", "PostTypeId": "2", "Id": "24690658", "Score": "1", "CreationDate": "2014-07-11T05:32:33.917", "LastActivityDate": "2014-07-11T05:32:33.917"}, "24684529": {"ParentId": "24683142", "CommentCount": "0", "Body": "<p>Few lines from C++ Standard related to the subject; I think it briefly describes that it is not wrong behaviour.</p>\n<blockquote>\n<p id=\"so_24683142_24684529_0\">Any allocation and/or deallocation functions defined in a C++ program,\n  including the default versions in the library, shall conform to the\n  semantics specified in 3.7.4.1 and 3.7.4.2. ...</p>\n<p id=\"so_24683142_24684529_1\"><strong>3.7.4.1 Allocation functions</strong> ... The pointer returned shall be suitably aligned so that it can be converted to a pointer of any\n  complete object type with a fundamental alignment requirement (3.11)\n  and ...</p>\n<p id=\"so_24683142_24684529_2\"><strong>3.11 Alignment</strong> Object types have alignment requirements (3.9.1, 3.9.2) which place restrictions on the addresses at which an object of that type may be allocated. An alignment is an implementation-defined\n  integer value representing the number of bytes between successive\n  addresses at which a given object can be allocated. ...</p>\n</blockquote>\n", "OwnerUserId": "2328763", "PostTypeId": "2", "Id": "24684529", "Score": "2", "CreationDate": "2014-07-10T19:15:00.700", "LastActivityDate": "2014-07-10T19:15:00.700"}, "24683752": {"ParentId": "24683142", "CommentCount": "3", "Body": "<p>Memory allocation in C like languages must return memory suitably aligned [0] for all primitive types.\nThis means memory allocation will usually give you at least 8 byte aligned memory so you can store <code>doubles</code> in them.</p>\n<p>So when you request 1 byte of memory you will use at least 8 bytes due to the alignment requirement.\nOn 64 bit systems memory allocation often gives you 16 byte aligned memory as these systems often have 16 byte large types (SSE vectors)</p>\n<p>Additionally the memory allocator needs some space for its management data, like the size of the allocation.\nDepending on the implementation this data can be placed before or after the user allocated block of memory.</p>\n<p>[0] Memory is aligned when the address/pointer is a multiple of the size it is accessed in, some cpus do not support unaligned access (e.g. sparc), others (like x86) can have performance penalties if you do so.</p>\n", "OwnerUserId": "1633169", "PostTypeId": "2", "Id": "24683752", "Score": "6", "CreationDate": "2014-07-10T18:25:41.433", "LastActivityDate": "2014-07-10T18:25:41.433"}, "bq_ids": {"n4140": {"so_24683142_24684529_1": {"section_id": 7177, "quality": 0.7222222222222222, "length": 13}, "so_24683142_24684529_0": {"section_id": 7175, "quality": 0.8, "length": 12}, "so_24683142_24684529_2": {"section_id": 7240, "quality": 0.7666666666666667, "length": 23}}, "n3337": {"so_24683142_24684529_1": {"section_id": 6921, "quality": 0.7222222222222222, "length": 13}, "so_24683142_24684529_0": {"section_id": 6919, "quality": 0.8, "length": 12}, "so_24683142_24684529_2": {"section_id": 6984, "quality": 0.7666666666666667, "length": 23}}, "n4659": {"so_24683142_24684529_1": {"section_id": 8685, "quality": 0.5555555555555556, "length": 10}, "so_24683142_24684529_2": {"section_id": 8749, "quality": 0.7333333333333333, "length": 22}, "so_24683142_24684529_0": {"section_id": 8683, "quality": 0.8, "length": 12}}}});