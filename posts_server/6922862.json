post_cb({"6922862": {"CommentCount": "0", "AcceptedAnswerId": "6926482", "PostTypeId": "1", "LastEditorUserId": "308661", "CreationDate": "2011-08-03T07:12:05.380", "LastActivityDate": "2011-08-03T13:21:29.397", "LastEditDate": "2011-08-03T07:41:17.873", "ViewCount": "213", "FavoriteCount": "2", "Title": "ISO C++ draft - 3.4.2/3 - Argument Dependant Name Lookup", "Id": "6922862", "Score": "5", "Body": "<p>A point from the ISO C++ draft (n3290):</p>\n<blockquote>\n<p id=\"so_6922862_6922862_0\"><strong>3.4.2/3 Argument Dependant Name Lookup:</strong></p>\n<p id=\"so_6922862_6922862_1\">Let <code>X</code> be the lookup set produced by unquali\ufb01ed lookup (3.4.1) and\n  let <code>Y</code> be the lookup set produced by argument dependent lookup\n  (de\ufb01ned as follows). If <code>X</code> contains</p>\n<ul>\n<li>a declaration of a class member (#1) or  </li>\n<li>a block-scope function\n  declaration that is not a using-declaration (#2) or </li>\n<li>a declaration\n  that is neither a function or a function template (#3)</li>\n</ul>\n<p id=\"so_6922862_6922862_2\">then <code>Y</code> is empty. Otherwise <code>Y</code> is the set of declarations found in\n  the namespaces associated with the argument types as described below.\n  The set of declarations found by the lookup of the name is the union\n  of <code>X</code> and <code>Y</code>.</p>\n</blockquote>\n<p>Is there an example code snippet that demonstrates ADL involving #1, #2 and #3?</p>\n", "Tags": "<c++><c++11><name-lookup>", "OwnerUserId": "751747", "AnswerCount": "3"}, "6926482": {"ParentId": "6922862", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I think this code covers all the cases (also available at <a href=\"http://ideone.com/CbyJv\" rel=\"nofollow\">http://ideone.com/CbyJv</a>). If you don't select C++0x in ideone, then case #2 is allowed (but gcc 4.5.2 catches it).</p>\n<pre><code>#include &lt;iostream&gt;\n\n// ::f\nvoid f (int i) { std::cout &lt;&lt; \"::f\\n\" ; }\n\n// Simple case\nvoid OK1() {\n  f (99) ; // Calls ::f\n}\n\n// Argument-dependend lookup\nnamespace MyNamespace {\nstruct S { int i ; } ;\nvoid f (S&amp; s) { std::cout &lt;&lt; \"MyNamespace::f\\n\" ; }\n}\n\nvoid OK2() {\n  MyNamespace::S s ;\n  f (99) ;   // Calls ::f\n  f (s) ;    // Calls MyNamespace::f because the type of s is declared in MyNamespace\n}\n\n// Declaration of a class member (#1)\nstruct C {\n  static void ERROR1() {\n    MyNamespace::S s ;\n    f (s) ;        // Error: MyNamespace::f not matched, because Y is empty (#1)\n  }\n  static void f() { // Declaration of a class member (#1)\n    std::cout &lt;&lt; \"C::f\\n\" ;\n  }\n} ;\n\n// Block-scope function declaration (#2)\nvoid ERROR2() {\n  void f() ; // Block-scope function declaration (#2)\n  MyNamespace::S s ;\n  f (s) ;    // Error: MyNamespace::f not matched, because Y is empty (#2)\n}\n\n// Declaration that is neither a function or a function template (#3)\nvoid ERROR3() {\n  MyNamespace::S s ;\n  f (s) ;            // OK: MyNamespace::f called\n  typedef int f[3] ; // Declaration that is neither a function or a function template (#3)\n  f (s) ;            // Error: MyNamespace::f not matched, because Y is empty (#3). This is an initialiser\n}\n</code></pre>\n", "OwnerUserId": "428857", "LastEditorUserId": "428857", "LastEditDate": "2011-08-03T13:21:29.397", "Id": "6926482", "Score": "3", "CreationDate": "2011-08-03T12:31:45.993", "LastActivityDate": "2011-08-03T13:21:29.397"}, "6923238": {"ParentId": "6922862", "CommentCount": "0", "Body": "<p>Number 1 is pretty simple - if you look for a name N inside a class, and the class has a member N, that's it! You don't have to go looking anywhere else.</p>\n<p>Number 2 I believe is similar, but inside a block </p>\n<pre><code>{\n    void f(double);\n\n    f(42);\n}\n</code></pre>\n<p>the code will try to call the function f declared there, if possible, and give up otherwise.</p>\n<p>Number 3 is again similar. If you look for the name N and find something with that name that is not a function, you don't have to go looking for overloads.</p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "6923238", "Score": "1", "CreationDate": "2011-08-03T07:50:05.990", "LastActivityDate": "2011-08-03T07:50:05.990"}, "bq_ids": {"n4140": {"so_6922862_6922862_2": {"section_id": 7105, "quality": 0.9473684210526315, "length": 18}, "so_6922862_6922862_1": {"section_id": 7105, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_6922862_6922862_2": {"section_id": 6849, "quality": 0.9473684210526315, "length": 18}, "so_6922862_6922862_1": {"section_id": 6849, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_6922862_6922862_2": {"section_id": 8606, "quality": 0.9473684210526315, "length": 18}, "so_6922862_6922862_1": {"section_id": 8606, "quality": 0.8235294117647058, "length": 14}}}, "6923396": {"ParentId": "6922862", "CommentCount": "0", "Body": "<p>For what it's worth, this is also called a Koenig Lookup. I don't have examples for all 3 to hand, but Bo Persson has already provided some.</p>\n", "OwnerUserId": "406859", "PostTypeId": "2", "Id": "6923396", "Score": "0", "CreationDate": "2011-08-03T08:06:54.177", "LastActivityDate": "2011-08-03T08:06:54.177"}});