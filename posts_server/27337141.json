post_cb({"bq_ids": {"n4140": {"so_27337141_27337319_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 7216}}, "n3337": {"so_27337141_27337319_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 6960}}, "n4659": {"so_27337141_27337319_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 8725}}}, "27337141": {"ViewCount": "306", "Body": "<p>The following questions (and answers) indicate that a bool's value when converted to int will be 0 or 1.</p>\n<ol>\n<li><p><a href=\"https://stackoverflow.com/questions/4276207/is-c-c-bool-type-always-guaranteed-to-be-0-or-1-when-typecasted-to-int\">Is C/C++ bool type always guaranteed to be 0 or 1 when typecast'ed to int?</a></p></li>\n<li><p><a href=\"https://stackoverflow.com/questions/5189072/c-bool-question\">c++ bool question</a></p></li>\n</ol>\n<p>My question is whether <em>the compiler can represent the value as something else internally</em> (up to the conversion).  I vaguely recalling the MSVC debugger show the numeric value of the byte representing the bool if it isn't 0 or 1, and I seem to recall seeing 255 sometimes (0xFF).</p>\n<p>Said differently, <em>could the following code return something other than 0 or 1?</em></p>\n<pre><code>int boolval(bool z) {\n  return *(unsigned char *)&amp;z;\n}\n</code></pre>\n<p>I am currently working with a binary format that uses <code>bool</code>'s in the structure and am seeing 255's instead of 0's and 1's.</p>\n<p>EDIT: I just found an almost identical questions a moment ago so I am linking it here for more information.\n<a href=\"https://stackoverflow.com/questions/19351483/how-is-a-bool-represented-in-memory\">How is a bool represented in memory?</a>\nThanks for the answers.</p>\n", "AcceptedAnswerId": "27337255", "Title": "Can a C++ compiler represent bool internally with something other than 0 or 1?", "CreationDate": "2014-12-06T22:09:46.457", "Id": "27337141", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:27:18.513", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-07T21:12:36.430", "Score": "2", "OwnerUserId": "799829", "Tags": "<c++>", "AnswerCount": "3"}, "27337319": {"Id": "27337319", "PostTypeId": "2", "Body": "<p>[basic.fundamental]/6:</p>\n<blockquote>\n<p id=\"so_27337141_27337319_0\">Types <code>bool</code>, [\u2026] are collectively called integral types. A synonym\n  for integral type is integer type. <br><strong>The representations of integral\n  types shall define values by use of a pure binary numeration system.</strong></br></p>\n</blockquote>\n<p>This is vague. In no way does the standard require <code>false</code> and <code>true</code> to correspond to <code>0</code> or <code>1</code> in memory (it could be the other way around). What we do know is that the representation obviously doesn't change, so you will get consistent results.</p>\n<p>However, the following rules apply to the <a href=\"http://refspecs.linuxfoundation.org/elf/x86_64-abi-0.95.pdf\" rel=\"nofollow\">x86_64 processor specific ABI</a>:</p>\n<blockquote>\n<p id=\"so_27337141_27337319_1\">Booleans, when stored in a memory object, are stored as single byte\n  objects the value of which is always 0 (false) or 1 (true). <strong>When\n  stored in integer registers or passed as arguments on the stack, all 8\n  bytes of the register are significant; any nonzero value is considered\n  true.</strong></p>\n</blockquote>\n<p>The value will for that ABI then be <code>0</code> for <code>false</code> and anything for <code>true</code>. It's not guaranteed which value will be returned from your function in that case.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-12-06T22:42:43.837", "Score": "4", "CreationDate": "2014-12-06T22:29:14.290", "ParentId": "27337141", "CommentCount": "5", "OwnerUserId": "3647361", "LastEditDate": "2014-12-06T22:42:43.837"}, "27337255": {"Id": "27337255", "PostTypeId": "2", "Body": "<p>The compiler can represent true however it likes as long as <code>1==(int)true</code> and <code>0==(int)false</code></p>\n<p>The simplest way for the compiler to meet those requirements is to represent <code>false</code> as all zero bits and <code>true</code> as the least significant bit set, because then the \"conversion\" to <code>int</code> doesn't involve changing anything.</p>\n<p>But the compiler is free to represent <code>true</code> as all bits set, and issue instructions to convert that to <code>1</code> when converted to <code>int</code>, or even to represent <code>true</code> as all zero bits and <code>false</code> as all bits set or any other odd representation, as long it meets the requirements.</p>\n", "LastActivityDate": "2014-12-06T22:22:12.890", "CommentCount": "0", "CreationDate": "2014-12-06T22:22:12.890", "ParentId": "27337141", "Score": "7", "OwnerUserId": "981959"}, "27337398": {"Id": "27337398", "PostTypeId": "2", "Body": "<p>There are 2 parts of this question:</p>\n<p>1) What do compilers actually do?</p>\n<ul>\n<li>All major compiler currently represents false as 0</li>\n<li>Some compilers however do not represent true always as 1,<br>\nbut rather whatever value the source had, so that in <br>\n<code>bool ok = res;</code> ok will have whatever value res had.</br></br></li>\n</ul>\n<p>2) What do the standard say?</p>\n<ul>\n<li>No guarantees!</li>\n</ul>\n", "LastEditorUserId": "3202093", "LastActivityDate": "2014-12-06T23:19:37.257", "Score": "0", "CreationDate": "2014-12-06T22:38:27.427", "ParentId": "27337141", "CommentCount": "2", "OwnerUserId": "3202093", "LastEditDate": "2014-12-06T23:19:37.257"}});