post_cb({"25121295": {"CommentCount": "6", "ViewCount": "1115", "PostTypeId": "1", "LastEditorUserId": "1822700", "CreationDate": "2014-08-04T14:41:05.420", "LastActivityDate": "2014-08-04T15:36:53.953", "Title": "New/delete operator overload and base class", "AcceptedAnswerId": "25121986", "LastEditDate": "2014-08-04T15:36:53.953", "Id": "25121295", "Score": "3", "Body": "<p>whI have a big headache at the moment.</p>\n<p>Basically I have this :</p>\n<pre><code>Class A -&gt; Class B\nClass A -&gt; Class C\nClass A -&gt; Class D\n\nClass E with constructor with declaration E(int, A *objptr, bool IsObjPtrOwner = true)\n</code></pre>\n<p>As you see B C and D inherit from A, A being the base class. Class D must have a specific alignment (because SSE2 is used inside it), hence why I overloaded new/delete inside it, providing an aligned block of memory each time the object is dynamically allcated. Should also I mention since A B C and D differ, I would pretty much guess B C A and D do not have the same size at all.</p>\n<p>So I would like to be able to do that:</p>\n<pre><code>E eobj(12, new D(2.001), true);\n</code></pre>\n<p>Because the parameter IsObjPtrOwner would be true, I programmed my class E so that, if the member m_IsObjPtrOwner is true, the pointer m_objptr is deleted inside the destructor of E.</p>\n<p>This would be very convenient for me to be able to dynamically allocate one of the derived classes of A directly while constructing the object E, and not have to care about it later. The reason for this is that I will be making a lot of instances of class E throughout my program, each time with a different B/C/D instance. So I would like not to have to keep a copy of each pointer I create each time I construct an instance of E.</p>\n<p>So I tried to make new/delete operators pure virtual, but it just won't work. The damn functions must be static, very bothering. So I tried to circumvent this as much as I could, but I ended up discovering I cannot use \"this\" inside static functions.</p>\n<p>What can I do? How can I realize this dream? I have a dream...</p>\n<hr>\n<p>EDIT: For some reasons people do not understand at all what I'm trying to say.</p>\n<p>I have a base class A and a set of derived classes B/C/D from A. I have a class E taking as an argument in its constructor a pointer of class A, which is then stored in a member, say m_bcdobj, so I have this :</p>\n<pre><code>class B : public A {\n    B(double x) : m_x(x) { bla bla bla}\n    void *operator new(size_t size)   { return Util_MemAlign(size, 4); }\n    void  operator delete(void* ptr)  { Util_AlignFree(ptr); }\n}\nclass C : public A {\n    C(double x) : m_x(x) { bla bla bla}\n    void *operator new(size_t size)   { return malloc(size); }\n    void  operator delete(void* ptr)  { free(ptr); }\n}\nclass D : public A {\n    D(double x) : m_x(x) { bla bla bla}\n    void *operator new(size_t size)   { return Util_MemAlign(size, 16); }\n    void  operator delete(void* ptr)  { Util_AlignFree(ptr); }\n}\n</code></pre>\n<p>As you see, each of em have different alignment requirements.</p>\n<p>Now I have a class E:</p>\n<pre><code>class E {\n    public:\n        E(int z, A *bcdobj, bool IsObjPtrOwner = true) : m_z(z), m_bcdobj(bcdobj), m_freebcd(IsObjPtrOwner) { bla bla bla }\n\n        ~E() { if (m_freebcd) { delete m_bcdobj; } }\n\n    private:\n        A *m_bcdobj;\n        int m_z;\n        bool m_freebcd;\n}\n</code></pre>\n<p>So I want to be able to do that:</p>\n<pre><code>E einst(2, new D(2.001));\n</code></pre>\n<p>i.e. I don't keep a copy of the D object allocated. The allocated D object would be freed while \"einst\" is destroyed. The problem is that this code will not work. When deleting m_bcdobj inside ~E(), the overloaded delete operator inside D will not be called.</p>\n<p>Thanks!</p>\n</hr>", "Tags": "<c++><oop><operator-overloading><new-operator><delete-operator>", "OwnerUserId": "1822700", "AnswerCount": "1"}, "25121986": {"ParentId": "25121295", "CommentCount": "1", "Body": "<p><code>operator delete</code> is special in that despite being a static member, if the class has a virtual destructor it is dynamically dispatched. \u00a712.5 [class.free]/p4:</p>\n<blockquote>\n<p id=\"so_25121295_25121986_0\">If the delete-expression is used to deallocate a class object whose\n  static type has a virtual destructor, the deallocation function is the\n  one selected at the point of definition of the dynamic type\u2019s virtual\n  destructor (12.4).</p>\n</blockquote>\n<p>For example,</p>\n<pre><code>struct B {\n    virtual ~B() = default;\n    void operator delete(void* ptr) { \n        std::cout &lt;&lt; \"B's operator delete\" &lt;&lt; std::endl; ::operator delete(ptr); \n    }\n};\nstruct D : B {\n    void operator delete(void* ptr) { \n        std::cout &lt;&lt; \"D's operator delete\" &lt;&lt; std::endl; ::operator delete(ptr); \n    }\n};\nint main() {\n    B* bp = new D;\n    delete bp; //1: uses D::operator delete(void*)\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/81002d5d464cf29b\" rel=\"nofollow\">prints</a>:</p>\n<pre><code>D's operator delete\n</code></pre>\n<p>Thus, give <code>A</code> a virtual destructor and you should see the correct <code>operator delete</code> called :).</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "25121986", "Score": "4", "CreationDate": "2014-08-04T15:16:00.927", "LastActivityDate": "2014-08-04T15:16:00.927"}, "bq_ids": {"n4140": {"so_25121295_25121986_0": {"section_id": 416, "quality": 0.95, "length": 19}}, "n3337": {"so_25121295_25121986_0": {"section_id": 407, "quality": 0.95, "length": 19}}, "n4659": {"so_25121295_25121986_0": {"section_id": 434, "quality": 0.95, "length": 19}}}});