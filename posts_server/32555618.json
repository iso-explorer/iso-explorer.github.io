post_cb({"32555618": {"CommentCount": "1", "AcceptedAnswerId": "32559162", "CreationDate": "2015-09-13T23:46:22.713", "LastActivityDate": "2015-09-14T07:19:50.887", "PostTypeId": "1", "ViewCount": "255", "FavoriteCount": "1", "Title": "Explicit instantiation of function template using incomplete type", "Id": "32555618", "Score": "3", "Body": "<p>The following:</p>\n<pre><code>template&lt; typename &gt;\nstruct S;\n\ntemplate&lt; typename T &gt;\nS&lt; T &gt;&amp; f (S&lt; T &gt;&amp; s) {\n    const typename S&lt; T &gt;::nested ignore;\n    return s;\n}\n\ntemplate S&lt; char &gt;&amp; f (S&lt; char &gt;&amp;);\n\ntemplate&lt; typename &gt;\nstruct S {\n    struct nested { };\n};\n</code></pre>\n<p>compiles with gcc, but not with clang:</p>\n<pre><code>$ clang -c /tmp/t.cpp\n/tmp/t.cpp:6:20: error: implicit instantiation of undefined template 'S&lt;char&gt;'\n    const typename S&lt; T &gt;::nested ignore;\n                   ^\n/tmp/t.cpp:10:21: note: in instantiation of function template specialization 'f&lt;char&gt;' requested here\ntemplate S&lt; char &gt;&amp; f (S&lt; char &gt;&amp;);\n                    ^\n/tmp/t.cpp:2:8: note: template is declared here\nstruct S;\n       ^\n1 error generated.\n</code></pre>\n<p>I believe clang to be right in that, at the point of instantiation, the function f refers an incomplete definition of S. OTOH, a later specialization of S might provide the correct definition that makes the dependent 'nested' well-formed. Any opinions?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "5329006", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32555618_32559162_1": {"section_id": 223, "quality": 1.0, "length": 45}, "so_32555618_32559162_0": {"section_id": 221, "quality": 1.0, "length": 10}}, "n3337": {"so_32555618_32559162_1": {"section_id": 216, "quality": 1.0, "length": 45}, "so_32555618_32559162_0": {"section_id": 214, "quality": 1.0, "length": 10}}, "n4659": {"so_32555618_32559162_1": {"section_id": 231, "quality": 0.9555555555555556, "length": 43}, "so_32555618_32559162_0": {"section_id": 229, "quality": 1.0, "length": 10}}}, "32559162": {"ParentId": "32555618", "CommentCount": "1", "Body": "<p>Both compilers are correct.</p>\n<p>[temp.point]/p6, 8:</p>\n<blockquote>\n<p id=\"so_32555618_32559162_0\">6 An explicit instantiation definition is an instantiation point for\n  the specialization or specializations specified by the explicit\n  instantiation.</p>\n<p id=\"so_32555618_32559162_1\">8 A specialization for a function template [...] may\n  have multiple points of instantiations within a translation unit, and\n  in addition to the points of instantiation described above, for any\n  such specialization that has a point of instantiation within the\n  translation unit, the end of the translation unit is also considered a\n  point of instantiation. [...] If two different points of instantiation\n  give a template specialization different meanings according to the one\n  definition rule (3.2), the program is ill-formed, no diagnostic\n  required.</p>\n</blockquote>\n<p>There are two points of instantiation for <code>f&lt;char&gt;</code>: at the explicit instantiation definition, and at the end of the TU. Because those two points of instantiation would result in different meanings (as lookup for <code>S&lt;T&gt;::nested</code> would yield different results), the program is ill-formed NDR. </p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "32559162", "Score": "2", "CreationDate": "2015-09-14T07:19:50.887", "LastActivityDate": "2015-09-14T07:19:50.887"}});