post_cb({"14049059": {"ParentId": "14048919", "CommentCount": "1", "Body": "<p>Probably an oversight (in the same way as rvalue refs can't be used) of sorts and an artifact of the way lambdas are conceptually implemented.</p>\n<pre><code>int   a;\nint*  b;\nfloat c;\n\nauto lambda1 = [&amp;a, b, c](int d) mutable -&gt; void {};\n\nclass lambda1 {\npublic:\n    void operator()(int d) {}\nprivate:\n    int&amp;  a_;\n    int*  b_;\n    float c_;\n};\n\nauto lambda2 = [&amp;a, b, c](int d) -&gt; void {};\n\nclass lambda2 {\npublic:\n    void operator()(int d) const {}\nprivate:\n    int&amp;  a_;\n    int*  b_;\n    float c_;\n};\n</code></pre>\n", "OwnerUserId": "1837688", "PostTypeId": "2", "Id": "14049059", "Score": "6", "CreationDate": "2012-12-27T03:36:10.917", "LastActivityDate": "2012-12-27T03:36:10.917"}, "14049072": {"ParentId": "14048919", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The <code>mutable</code> keyword applies to the object generated by the lambda expression and not to individually captured items so that it can be implemented by the compiler using a <code>const</code> modifier on the <code>operator()</code> method as described in section 5.1.2, paragraph 5 of the standard.</p>\n<blockquote>\n<p id=\"so_14048919_14049072_0\">This function call operator is declared const (9.3.1) if and only if\n  the lambdaexpression\u2019s parameter-declaration-clause is not followed by\n  mutable.</p>\n</blockquote>\n<p>In your example, the class generated by the lambda expression could look like this:</p>\n<pre><code>class lambda\n{\n  int a, b;\n\npublic:\n\n  lambda( int a, int b ) : a( a ), b( b ) {}\n\n  void operator()() // non-const due to mutable keyword\n  {\n    a = 7;\n  }\n};\n</code></pre>\n", "OwnerUserId": "484307", "LastEditorUserId": "484307", "LastEditDate": "2012-12-27T03:59:27.513", "Id": "14049072", "Score": "5", "CreationDate": "2012-12-27T03:38:25.723", "LastActivityDate": "2012-12-27T03:59:27.513"}, "14050538": {"ParentId": "14048919", "CommentCount": "1", "Body": "<p>The <code>mutable</code> keyword isn't used like the <code>mutable</code> keyword is normally used: It is meant to be the opposite of <code>const</code> in this case and applies to the constness of the function call operator the implicit function object. However, it was intentional that the function call operator of the implicit function object is <code>const</code> by default while normally member functions are non-<code>const</code> (\"mutable\") but default. The introduction of lambda functions predated the use of contextual keywords (<code>override</code> and <code>final</code>) and the <code>mutable</code> keyword seemed to be a better choices than <code>not const</code>.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "14050538", "Score": "0", "CreationDate": "2012-12-27T06:42:31.090", "LastActivityDate": "2012-12-27T06:42:31.090"}, "14049344": {"ParentId": "14048919", "CommentCount": "6", "Body": "<p>There is a mention about your suggestion in <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2651.pdf\">n2651</a>:</p>\n<blockquote>\n<p id=\"so_14048919_14049344_0\">The syntax for lambda expressions could be extended to allow declaring\n  whether the closure members should be declared mutable or not. </p>\n<p id=\"so_14048919_14049344_1\"><strong>This approach could be confusing to programmers, as the mutability is not a\n  property of the closure object, but rather the variables stored in the\n  closure.</strong></p>\n</blockquote>\n<p>I don't know if this is the only reason, but it does seem like it was considered.\nHowever, in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3424.pdf\">Herb Sutter's proposal</a>, he suggests getting rid of <code>mutable</code> and not making the capture copies implicitly <code>const</code>, so we might see changes again.</p>\n", "OwnerUserId": "906773", "PostTypeId": "2", "Id": "14049344", "Score": "17", "CreationDate": "2012-12-27T04:23:55.213", "LastActivityDate": "2012-12-27T04:23:55.213"}, "14048919": {"CommentCount": "0", "AcceptedAnswerId": "14049344", "CreationDate": "2012-12-27T03:10:54.527", "LastActivityDate": "2012-12-27T06:42:31.090", "PostTypeId": "1", "ViewCount": "3306", "FavoriteCount": "2", "Title": "Why is 'mutable' a lambda function attribute, instead of being a capture type?", "Id": "14048919", "Score": "40", "Body": "<p>Why does c++11 require us to write:</p>\n<pre><code>[a,b]() mutable { a=7; } // b is needlessly mutable, potential source of bugs\n</code></pre>\n<p>Instead of:</p>\n<pre><code>[mutable a,b]() { a=7; } // no problems here\n</code></pre>\n<p>Is this an oversight, considered not important enough, or is there a specific technical reason?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "29701", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_14048919_14049072_0": {"section_id": 5964, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_14048919_14049072_0": {"section_id": 5733, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_14048919_14049072_0": {"section_id": 7454, "quality": 0.8181818181818182, "length": 9}}}});