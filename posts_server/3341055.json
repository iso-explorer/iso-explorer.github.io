post_cb({"3341173": {"Id": "3341173", "PostTypeId": "2", "Body": "<p>extern \"C\" is used to change symbol name of C++ function in order to use them from a C program.</p>\n<p>In C++, function prototype is \"coded\" in symbol name, this is a requirement for overloading.\nBut in C, you don't have a such feature.</p>\n<p>extern \"C\" allow to call C++ function from a C program.</p>\n<p>extern \"C\" is not what you are looking for.</p>\n<p>Could you please explain what do you want to do ?</p>\n", "LastActivityDate": "2010-07-27T06:22:06.550", "Score": "2", "CreationDate": "2010-07-27T06:22:06.550", "ParentId": "3341055", "CommentCount": "2", "OwnerUserId": "278284"}, "3341707": {"Id": "3341707", "PostTypeId": "2", "Body": "<p>Just by reading carefully the quote you wrote you will notice that, except non-member function templates that might have internal linkage, all other templates have external linkage. There is no need to add keywords, nor keywords can be added there.</p>\n<p>The description of what linkage means is in \u00a73.5/2, in particular <em>external linkage</em> is defined as:</p>\n<blockquote>\n<p id=\"so_3341055_3341707_0\">When a name has external linkage, the entity it denotes can be referred to by names from scopes of other translation units or from other scopes of the same translation unit.</p>\n</blockquote>\n<p>To force internal linkage of a template non-member function you can use the <code>static</code> keyword, but you cannot do the same with other templates:</p>\n<pre><code>template &lt;typename T&gt;\nstatic void foo( T ) {}\n</code></pre>\n<p>Note that you can achieve a somehow similar effect as <em>internal linkage</em> by using anonymous namespaces.</p>\n<p>Internal linkage: \u00a73.5/2</p>\n<blockquote>\n<p id=\"so_3341055_3341707_1\">When a name has internal linkage, the entity it denotes can be referred to by names from other scopes in the same translation unit. </p>\n</blockquote>\n<p>Note that the difference is that it cannot be referred from other translation units.</p>\n<pre><code>namespace {\n   template &lt;typename T&gt;\n   class test {};\n}\n</code></pre>\n<p>While the unnamed namespace does not make the linkage internal, it ensures that there will be no name collision as it will be in a <em>unique</em> namespace. This uniqueness guarantees that the code is not accessible from other translation units. Unnamed namespaces are considered to be a better alternative to the <code>static</code> keyword \u00a77.3.1.1/2</p>\n<blockquote>\n<p id=\"so_3341055_3341707_2\">The use of the static keyword is deprecated when declaring objects in a namespace scope (see annex D); the unnamed-namespace provides a superior alternative</p>\n</blockquote>\n<p>On the other hand, when you say that you:</p>\n<blockquote>\n<p id=\"so_3341055_3341707_3\">know about external linkage using the keyword <code>extern \"C\"</code></p>\n</blockquote>\n<p>You don't. <code>extern \"C\"</code> is not a request for external linkage. Reread the spec. <code>extern \"C\"</code> is a <em>linkage-specification</em> and instructs the compiler to use \"C\" style linkage within the block to interact with C code or libraries that already work that way, like <code>dlopen</code> and family. This is described in \u00a77.5</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2010-12-01T09:02:01.187", "Score": "7", "CreationDate": "2010-07-27T08:08:18.077", "ParentId": "3341055", "CommentCount": "0", "LastEditDate": "2010-12-01T09:02:01.187", "OwnerUserId": "36565"}, "3432119": {"Id": "3432119", "PostTypeId": "2", "Body": "<p>The answer to the updated question is, as I already said in the answer that applies to the original question, that you are misunderstanding what <code>extern \"C\"</code> means.</p>\n<p>The sequence <code>extern \"X\"</code> allows you to change the <em>language linkage</em> of the following function or block to language <code>X</code>. It <strong>does not</strong> mean external linkage, so your original premise:</p>\n<blockquote>\n<p id=\"so_3341055_3432119_0\">I know about external linkage using the keyword <code>extern \"C\"</code></p>\n</blockquote>\n<p>is <strong>false</strong>. You don't know what it means. Refer to 7.5 in the standard. Language linkage affects how the compiler processes parameters and whether it applies (and potentially how) name mangling to the symbols.</p>\n<p>Taking aside your insistence in that particular error, the compiler is complaining about your code because it is invalid according to the standard. In particular \u00a714[temp]/4:</p>\n<blockquote>\n<p id=\"so_3341055_3432119_1\">A template name has linkage (3.5). A non-member function template can have internal linkage; any other template name shall have external linkage. Entities generated from a template with internal linkage are distinct from all entities generated in other translation units. <strong>A template, a template explicit specialization (14.7.3), or a class template partial specialization shall not have C linkage</strong>. If the linkage of one of these is something other than C or C++, the behavior is implementation-defined. Template definitions shall obey the one definition rule (3.2). [Note: default arguments for function templates and for member functions of class templates are considered definitions for the purpose of template instantiation (14.5) and must also obey the one definition rule.]</p>\n</blockquote>\n<p>I really think that before trying to evaluate how different compilers comply with the standard you should take your time to understand the standard. It is quite fine to have questions, and there is people making an effort to answer them. Showing that you have read the answers and tried to grasp what they mean is just a sign of respect. What part of the last paragraph in the previous answer <a href=\"https://stackoverflow.com/questions/3341055/template-external-linkage-can-anyone-explain-this/3341707#3341707\">here</a> is unclear? Did you read it? Did you understand it? If you didn't, why did you not ask in a comment to the answer?</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-08-07T21:32:05.733", "Score": "2", "CreationDate": "2010-08-07T21:32:05.733", "ParentId": "3341055", "CommentCount": "0", "LastEditDate": "2017-05-23T12:07:57.990", "OwnerUserId": "36565"}, "bq_ids": {"n4140": {"so_3341055_3341055_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 51}, "so_3341055_3341707_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 7135}, "so_3341055_3432119_1": {"length": 59, "quality": 0.8194444444444444, "section_id": 51}, "so_3341055_3341707_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 7135}}, "n3337": {"so_3341055_3341055_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 46}, "so_3341055_3341707_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6879}, "so_3341055_3432119_1": {"length": 59, "quality": 0.8194444444444444, "section_id": 46}, "so_3341055_3341707_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 6879}}, "n4659": {"so_3341055_3341707_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 8636}, "so_3341055_3341707_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 8636}, "so_3341055_3432119_1": {"length": 42, "quality": 0.5833333333333334, "section_id": 52}}}, "3436336": {"Id": "3436336", "PostTypeId": "2", "Body": "<p><code>extern \"C\"</code> declares something to have <strong>C language linkage</strong>. This is different from <strong>external linkage</strong> and <strong>internal linkage</strong>. By default, everything in a C++ program has C++ language linkage, though you can reiterate that by specifying <code>extern \"C++\"</code>.</p>\n<p><strong>external linkage</strong> means that the name is visible to other source files compiled separately, assuming you include the right headers or provide the right declarations. This is what allows you to define a function <code>foo</code> in <code>a.cpp</code>, and call it from <code>b.cpp</code>. Most names at namespace scope in a C++ program have external linkage. The exceptions are those that have <strong>internal linkage</strong>, and those that have <strong>no linkage</strong>. You can explicitly mark something as having external linkage by specifying <code>extern</code>. This is distinct from <code>extern \"C\"</code>.</p>\n<p><strong>internal linkage</strong> means that the name is unique to the current compilation unit, and you cannot access the variable or function from another source file. File scope variables and functions declared <code>static</code> have internal linkage. Also, <code>const</code> integer variables at namespace scope that are initialized with a constant expression have internal linkage by default, though you can override it with an explicit <code>extern</code>.</p>\n<p>Finally, local variables and classes have <strong>no linkage</strong>. The names are local to the function they are declared in, and cannot be accessed from outside that function. You can use <code>extern</code> to indicate that you really want to access a variable at namespace scope.</p>\n<p>Templates cannot be defined at local scope, but may have either internal or external linkage.</p>\n<pre><code>int i; // namespace scope variable has external linkage\nextern int j; // explicitly mark j with external linkage\nstatic int k; // k has internal linkage\nint const n=42; // internal linkage\nextern int const m=99; // external linkage\n\nvoid foo(); // foo has external linkage; it may be defined in this source file or another\nextern void foo(); // explicitly mark foo with external linkage\nstatic void bar(); // bar has internal linkage, and must be defined in this source file\n\nvoid foo(){} // definition of foo, visible from other source files\nvoid bar(){} // definition of bar, not visible from other source files (internal linkage)\n\nstatic void baz(){} // declare and define baz with internal linkage\n\ntemplate&lt;typename T&gt; void foobar(){} // foobar has external linkage\ntemplate&lt;typename T&gt;\nstatic void foobaz(){} // foobaz has internal linkage\n\nvoid wibble()\n{\n    int i; // local, no linkage\n    extern int i; // references i, declared above with external linkage\n}\n\nextern \"C\"\n{\n    int i2; // namespace scope variable has external linkage, and \"C\" linkage\n    extern int j2; // explicitly mark j2 with external linkage and \"C\" linkage\n    static int k2; // k2 has internal linkage and \"C\" linkage\n    int const n2=42; // internal linkage and \"C\" linkage\n    extern int const m2=99; // external linkage and \"C\" linkage\n\n    void foo2(); // foo2 has external linkage and \"C\" linkage\n    static void bar2(); // bar2 has internal linkage and \"C\" linkage\n\n    void foo2(){} // definition of foo2, still with external linkage and \"C\" linkage\n    void bar2(){} // definition of bar2, still with internal linkage and \"C\" linkage\n\n    static void baz(){} // declare and define baz with internal linkage\n}\n</code></pre>\n<p>The error message is correct --- templates cannot have <code>extern \"C\"</code> linkage.</p>\n<p>At the basic level, templates cannot have <code>extern \"C\"</code> linkage because they are not compatible with C. In particular, a template doesn't just define a single class or function, but a family of classes or functions that share the same name, but are distinguished by their template parameters.</p>\n<p>Only one function with a given name may be declared <code>extern \"C\"</code>. This makes sense when you think about the name mangling --- in C, a function <code>foo</code> is typically called either <code>foo</code> or <code>_foo</code> in the symbol table. In C++ there may be many overloads of <code>foo</code>, so the signature is incorporated in the \"mangled\" name in the symbol table, and you might get <code>$3fooV</code> or <code>foo$void</code> or something else to distinguish <code>foo(void)</code> from <code>foo(int)</code> and so forth. In C++, the single overload that is marked <code>extern \"C\"</code> gets mangled according to the C scheme for the given platform, whereas the other overloads keep their normal mangled name.</p>\n<p>Declaring a template <code>extern \"C\"</code> would require all instantiations to be <code>extern \"C\"</code>, which thus contradicts the \"only one function with a given name can be <code>extern \"C\"</code>\" rule.</p>\n<p>Though C doesn't have name mangling for <code>struct</code>s, there can only be one <code>struct</code> with a given name. The ban on <code>extern \"C\"</code> for class templates thus also makes sense --- a template defines a family of classes with the same name, so which one corresponds to the C <code>struct</code>?</p>\n", "LastEditorUserId": "5597", "LastActivityDate": "2010-08-11T08:46:28.527", "Score": "21", "CreationDate": "2010-08-08T22:29:49.393", "ParentId": "3341055", "CommentCount": "0", "LastEditDate": "2010-08-11T08:46:28.527", "OwnerUserId": "5597"}, "3341055": {"ViewCount": "5253", "Body": "<blockquote>\n<p id=\"so_3341055_3341055_0\">A template name has linkage (3.5). A non-member function template can have internal linkage; any other template name shall have external linkage. Entities generated from a template with internal linkage are distinct from all entities generated in other translation units.</p>\n</blockquote>\n<p>I know about external linkage using the keyword </p>\n<pre><code>extern \"C\"\n</code></pre>\n<p>EX :</p>\n<pre><code>extern \"C\" {   template&lt;class T&gt;  class X { };   }\n</code></pre>\n<p>but they gave  <strong>template shall not have a C linkage</strong></p>\n<p>what actually meant for the above statement?</p>\n<p>can any one explain this ?</p>\n", "Title": "template External Linkage ?can anyone Explain this?", "CreationDate": "2010-07-27T05:50:13.050", "LastActivityDate": "2012-12-29T18:55:25.390", "CommentCount": "3", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2012-12-29T18:55:25.390", "LastEditorDisplayName": "BE Student", "OwnerDisplayName": "BE Student", "LastEditorUserId": "241631", "Id": "3341055", "Score": "5", "Tags": "<c++><templates><extern><linkage>", "AnswerCount": "4"}});