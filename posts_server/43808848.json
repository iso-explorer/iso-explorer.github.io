post_cb({"43808848": {"ViewCount": "62", "Body": "<pre><code>template&lt;typename T&gt;\nstruct A\n{\n    template&lt;typename U&gt;\n    A() {}\n\n    template&lt;typename U&gt;\n    static void f() {}\n};\n\nint main()\n{\n    A&lt;int&gt;::f&lt;int&gt;(); // ok\n    auto a = A&lt;int&gt;&lt;double&gt;(); // error C2062: type 'double' unexpected\n}\n</code></pre>\n<p>The issue is self-evident in the code.</p>\n<p>My question is:</p>\n<p><strong>How to call a template ctor of a template class?</strong></p>\n", "AcceptedAnswerId": "43808929", "Title": "How to call a template ctor of a template class?", "CreationDate": "2017-05-05T15:37:54.947", "Id": "43808848", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-05-05T20:24:30.757", "Score": "3", "OwnerUserId": "508343", "Tags": "<c++><templates><syntax><constructor><type-deduction>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_43808848_43809035_1": {"length": 31, "quality": 0.9117647058823529, "section_id": 114}, "so_43808848_43809035_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 235}}, "n3337": {"so_43808848_43809035_1": {"length": 31, "quality": 0.9117647058823529, "section_id": 109}, "so_43808848_43809035_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 228}}, "n4659": {"so_43808848_43809035_1": {"length": 31, "quality": 0.9117647058823529, "section_id": 118}, "so_43808848_43809035_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 245}}}, "43809035": {"Id": "43809035", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_43808848_43809035_0\">How to call a template ctor of a template class?</p>\n</blockquote>\n<p>Unfortunately it's impossible; You can't specify template arguments explicitly for constructor templates. </p>\n<p><a href=\"http://eel.is/c++draft/temp.mem#5\" rel=\"nofollow noreferrer\">\u00a717.5.2/5 Member templates [temp.mem]</a></p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_43808848_43809035_1\">[\u2009Note: Because the explicit template argument list follows the\n  function template name, and because conversion member function\n  templates and <strong>constructor member function templates are called without\n  using a function name, there is no way to provide an explicit template\n  argument list for these function templates.</strong> \u2014\u2009end note\u2009]</p>\n</blockquote>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2017-05-05T20:24:30.757", "Score": "3", "CreationDate": "2017-05-05T15:47:32.033", "ParentId": "43808848", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2017-05-05T20:24:30.757"}, "43808929": {"Id": "43808929", "PostTypeId": "2", "Body": "<p>You cannot <strong>directly</strong> call a constructor of a class. If you cannot deduce the constructor's template arguments from the call, then that particular constructor is impossible to invoke.</p>\n<p>What you can do is create some sort of <em>type wrapper</em> that can be used for zero-overhead deduction:</p>\n<pre><code>template &lt;typename T&gt;\nstruct type_wrapper { };\n\ntemplate&lt;typename T&gt;\nstruct A\n{\n    template&lt;typename U&gt;\n    A(type_wrapper&lt;U&gt;) {}\n};\n\nint main()\n{\n    auto a = A&lt;int&gt;(type_wrapper&lt;double&gt;{});\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/gmlTHG5Y4ks4pg5i\" rel=\"noreferrer\"><strong>live example on wandbox</strong></a></p>\n", "LastActivityDate": "2017-05-05T15:42:16.597", "CommentCount": "0", "CreationDate": "2017-05-05T15:42:16.597", "ParentId": "43808848", "Score": "5", "OwnerUserId": "598696"}});