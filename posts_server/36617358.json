post_cb({"36619948": {"ParentId": "36617358", "CommentCount": "1", "Body": "<p>By using reference wrapper, you should avoid the heap allocation:</p>\n<pre><code>auto f = std::bind(foo, 1, 2);\nrunThisFunction(std::ref(f));\n</code></pre>\n<p>This because <code>reference_wrapper</code> is a small object and <code>std::function</code> is encouraged to avoid allocation for small (see [func.wrap.func.con]):</p>\n<blockquote>\n<p id=\"so_36617358_36619948_0\">Note: Implementations are encouraged to avoid the use of dynamically\n  allocated memory for small callable objects, for example, where f\u2019s\n  target is an object holding only a\n  pointer or reference to an object and a member function pointer.</p>\n</blockquote>\n<p>It will only work if <code>runThisFunction()</code> is not storing the value of the <code>std::function</code> for calling after the lifetime of <code>f</code>.</p>\n", "OwnerUserId": "637866", "PostTypeId": "2", "Id": "36619948", "Score": "1", "CreationDate": "2016-04-14T10:08:38.833", "LastActivityDate": "2016-04-14T10:08:38.833"}, "36617585": {"ParentId": "36617358", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_36617358_36617585_0\">Is it possible to replace <code>std::function</code> with some other declaration that would would receive the output of <code>std::bind</code> directly by value, thereby avoiding the dynamic memory allocation?</p>\n</blockquote>\n<p>Yes it is; but the type returned by <code>std::bind</code> is unspecified, so you will need to use a template to capture the type;</p>\n<pre><code>template &lt;typename F&gt;\nvoid runThisFunction(F func);\n</code></pre>\n<p>On the memory allocation...</p>\n<blockquote>\n<p id=\"so_36617358_36617585_1\">In this invocation, the output of <code>std::bind</code> is converted into an <code>std::function</code>, and dynamic memory allocation occurs as part of this process.</p>\n</blockquote>\n<p>Dynamic memory may be used (but not <a href=\"https://stackoverflow.com/a/13503614/3747990\">always</a>), it depends on the size of the functor being bound into the <code>std::function</code> and the quality of implementation.</p>\n<p>Further, the C++ spec has this <a href=\"http://eel.is/c++draft/func.wrap.func.con#11\" rel=\"nofollow noreferrer\">\u00a720.12.12.2.1/11</a>;</p>\n<blockquote>\n<p id=\"so_36617358_36617585_2\">[Note: Implementations are encouraged to avoid the use of dynamically allocated memory for small callable objects, for example, where <code>f</code> is an object holding only a pointer or reference to an object and a member function pointer.\n  \u2014 end note ]</p>\n</blockquote>\n<p>I would not be too concerned about the memory allocation even if there is one. Unless the code is performance critical and you have measured it as such, the indirection required should not be a problem.</p>\n<p>Bear in mind that for your case, the <code>foo</code> being bound in the <code>bind</code> is a pointer and it is likely that there would be no dynamic memory allocation anyway.</p>\n<hr>\n<blockquote>\n<p id=\"so_36617358_36617585_3\">I started looking at this because I measured cache misses on the conversion due to unexpected slowness detected through instrumentation</p>\n</blockquote>\n<p>So you have some measured concerns about the performance... there are alternatives to using <code>std::bind</code> paired with <code>std::function</code>. <code>std::bind</code> is useful general purpose binder, but that doesn't mean it will also be performant enough - make your own. A custom functor could be more performant. A lambda based implementation would also be good to look at. Don't forget either that the function <code>foo</code> can be used with <code>std::function</code> as well and then you forgo the functor/binder completely (caveat, the signatures need to match).</p>\n<hr>\n<p><em>A side note on how \"small\" the object needs to be</em> before the \"small object\" optimisations mentioned in the quote above kick in seems to vary between the library implementations quiet a bit.</p>\n<p>Here on <a href=\"http://coliru.stacked-crooked.com/a/e05f6c18aa667d3d\" rel=\"nofollow noreferrer\">coliru</a> (libstdc++), the size of the argument for <code>std::function</code> needs to be 16 bytes or less, on <a href=\"http://webcompiler.cloudapp.net\" rel=\"nofollow noreferrer\">MSVC</a>, the limit is 32 bytes (both of these look to be 32-bit platforms). With a clang++ (libc++) 64-bit compile, this limit is 24 bytes... It really is up to the implementation how much space they will allow for before <code>new</code> allocations need to be made.</p>\n<p>I'm not sure how critical the performance is, but calculating this limit for your targets could also be done and then optimisations applied such that the arguments for the <code>std::function</code> are kept below these limits; e.g. using a pointer or reference (also <code>std::ref</code>) to a <code>struct</code> for arguments (but care must be taken that these are not left dangling).</p>\n</hr></hr>", "OwnerUserId": "3747990", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:24:07.900", "Id": "36617585", "Score": "4", "CreationDate": "2016-04-14T08:27:30.570", "LastActivityDate": "2016-04-14T14:11:38.450"}, "36619346": {"ParentId": "36617358", "CommentCount": "5", "Body": "<p>If performance is important but you still want a concrete interface, consider binding to a lambda rather than a binder object (via std::bind).</p>\n<p>I ran this test on gcc 5.3 (libstdc++, -O2)</p>\n<pre><code>#include &lt;functional&gt;\n\nvoid foo(int, int);\n\nvoid runThisFunction(std::function&lt;void()&gt; func);\n\nvoid test()\n{\n  runThisFunction(std::bind(&amp;foo, 1, 2));\n}\n\nvoid test1()\n{\n  runThisFunction([]{ foo(1, 2); });\n}\n</code></pre>\n<p><code>test()</code> results in a call to <code>new</code>. However, the small function optimisation in <code>std::function</code> is able to detect that the lambda in <code>test1()</code> is small enough and a call to <code>new</code> is not emitted into the code:</p>\n<p>(note: exception handling code removed for clarity):</p>\n<pre><code>std::_Function_base::_Base_manager&lt;test1()::{lambda()#1}&gt;::_M_manager(std::_Any_data&amp;, std::_Function_base::_Base_manager&lt;test1()::{lambda()#1}&gt; const&amp;, std::_Manager_operation):\n        testl   %edx, %edx\n        je      .L3\n        cmpl    $1, %edx\n        jne     .L2\n        movq    %rsi, (%rdi)\n.L2:\n        xorl    %eax, %eax\n        ret\n.L3:\n        movq    typeinfo for test1()::{lambda()#1}, (%rdi)\n        xorl    %eax, %eax\n        ret\nstd::_Function_handler&lt;void (), test1()::{lambda()#1}&gt;::_M_invoke(std::_Any_data const&amp;):\n        movl    $2, %esi\n        movl    $1, %edi\n        jmp     foo(int, int)\ntest1():\n        subq    $40, %rsp\n        movq    %rsp, %rdi\n        movq    std::_Function_handler&lt;void (), test1()::{lambda()#1}&gt;::_M_invoke(std::_Any_data const&amp;), 24(%rsp)\n        movq    std::_Function_base::_Base_manager&lt;test1()::{lambda()#1}&gt;::_M_manager(std::_Any_data&amp;, std::_Function_base::_Base_manager&lt;test1()::{lambda()#1}&gt; const&amp;, std::_Manager_operation), 16(%rsp)\n        call    runThisFunction(std::function&lt;void ()&gt;)\n        movq    16(%rsp), %rax\n        testq   %rax, %rax\n        je      .L7\n        movl    $3, %edx\n        movq    %rsp, %rsi\n        movq    %rsp, %rdi\n        call    *%rax\n.L7:\n        addq    $40, %rsp\n        ret\ntypeinfo for test1()::{lambda()#1}:\ntypeinfo name for test1()::{lambda()#1}:\n</code></pre>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "36619346", "Score": "1", "CreationDate": "2016-04-14T09:44:09.813", "LastActivityDate": "2016-04-14T09:44:09.813"}, "36620610": {"ParentId": "36617358", "CommentCount": "0", "Body": "<p>very simple (at least for gcc):</p>\n<pre><code>int someFunc(int a, int b) { return a+b; }\n//....\nint b = (std::bind(someFunc,3,4))(); // returns 7\n</code></pre>\n", "OwnerUserId": "2027606", "PostTypeId": "2", "Id": "36620610", "Score": "-1", "CreationDate": "2016-04-14T10:38:26.440", "LastActivityDate": "2016-04-14T10:38:26.440"}, "36617358": {"CommentCount": "5", "ViewCount": "244", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-04-14T08:17:54.197", "LastActivityDate": "2016-04-14T14:11:38.450", "Title": "Is it possible to accept the output of `std::bind` directly as a value, without conversion to std::function?", "AcceptedAnswerId": "36617585", "LastEditDate": "2017-05-23T12:07:40.070", "Id": "36617358", "Score": "3", "Body": "<p><a href=\"https://stackoverflow.com/a/25403584/391161\">This answer</a> states that <code>std::bind</code> returns an object by value, and <a href=\"https://stackoverflow.com/questions/36614574/where-in-the-source-does-gccs-stdbind-copy-arguments-into-a-data-structure#comment60828444_36614574\">this comment</a> implies that assigning to <code>std::function</code> will cause a heap allocation to store the value returned by <code>std::bind</code>. </p>\n<p>Is there a way to avoid this heap allocation and pass the return value of <code>std::bind</code> to another function directly by value?</p>\n<p>If so, what would the method signature replace <code>std::function</code> with?</p>\n<hr>\n<p>To be more explicit, I have a function like the following.</p>\n<pre><code>void runThisFunction(std::function&lt;void()&gt; func);\n</code></pre>\n<p>Suppose there is a function <code>foo</code> with the following signature.</p>\n<pre><code>void foo(int a, int b);\n</code></pre>\n<p>Now, I would invoke <code>runThisFunction</code> as follows.</p>\n<pre><code>runThisFunction(std::bind(foo, 1, 2));\n</code></pre>\n<p>In this invocation, the output of <code>std::bind</code> is converted into an <code>std::function</code>, and dynamic memory allocation occurs as part of this process.</p>\n<p>Is it possible to replace <code>std::function</code> with some other declaration that would would receive the output of <code>std::bind</code> directly by value, thereby avoiding the dynamic memory allocation?</p>\n</hr>", "Tags": "<c++><c++11><std-function><stdbind>", "OwnerUserId": "391161", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_36617358_36617585_2": {"section_id": 4657, "quality": 0.8695652173913043, "length": 20}, "so_36617358_36619948_0": {"section_id": 4657, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_36617358_36617585_2": {"section_id": 4468, "quality": 0.8695652173913043, "length": 20}, "so_36617358_36619948_0": {"section_id": 4468, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_36617358_36617585_2": {"section_id": 6026, "quality": 0.8695652173913043, "length": 20}, "so_36617358_36619948_0": {"section_id": 6026, "quality": 0.9545454545454546, "length": 21}}}});