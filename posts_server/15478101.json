post_cb({"bq_ids": {"n4140": {"so_15478101_15479358_1": {"length": 29, "quality": 1.0, "section_id": 5862}, "so_15478101_15479358_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 3245}}, "n3337": {"so_15478101_15479358_1": {"length": 29, "quality": 1.0, "section_id": 5632}, "so_15478101_15479358_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 3118}}, "n4659": {"so_15478101_15479358_1": {"length": 24, "quality": 0.8275862068965517, "section_id": 7345}, "so_15478101_15479358_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 4003}}}, "15479358": {"Id": "15479358", "PostTypeId": "2", "Body": "<p>In most contexts, you're correct that you couldn't define a function returning an incomplete type. However, the rules have some exceptions to allow the use of a class within its own definition.</p>\n<p>It's fine to declare a return type of <code>B</code> for one of its member functions even though <code>B</code> is incomplete at that point, as specified by C++11 8.3.5/9:</p>\n<blockquote>\n<p id=\"so_15478101_15479358_0\">The type of a parameter or the return type for a function definition shall not be an incomplete class type (possibly cv-qualified) <strong>unless the function definition\n  is nested within the <em>member-specification</em> for that class</strong></p>\n</blockquote>\n<p>It's also fine to instantiate an object of type <code>B</code> to return in the function body; within a class definition, the class is regarded as complete in various contexts including function bodies, as specified by C++11 9.2/2:</p>\n<blockquote>\n<p id=\"so_15478101_15479358_1\">Within the class <em>member-specification</em>, the class is <strong>regarded as complete within function bodies</strong>, default arguments, <em>exception-specifications</em>, and <em>brace-or-equal-initializers</em> for non-static data members (including such things in nested classes). Otherwise it is regarded as incomplete within its own class\n  <em>member-specification</em>.</p>\n</blockquote>\n", "LastActivityDate": "2013-03-18T14:33:17.157", "CommentCount": "1", "CreationDate": "2013-03-18T14:33:17.157", "ParentId": "15478101", "Score": "2", "OwnerUserId": "204847"}, "15478101": {"ViewCount": "176", "Body": "<p>As far as I know when defining a function with an object return type, while the class is only in its forward declaration state like this:</p>\n<pre><code>class A; \n</code></pre>\n<p>// forward declaration, which set <strong>A</strong> as an incomplete type</p>\n<pre><code>A foo(){...} \n</code></pre>\n<p>//error: A is an incomplete type\nI know it works fine when it has a return type of a pointer or reference to that object.</p>\n<p>But when I define a method with a return type as its class:</p>\n<pre><code>class B{\n  public:\n    B foo(){...}\n}\n</code></pre>\n<p>It works perfectly fine.</p>\n<p>I think when defining a method within the definition of class, the class is still an incomplete type.\nSo I think it will prompt error similar to the former, but it didn't.\nDoes anyone know why?</p>\n<p>I have searched for quite some time before asking for help here.\n(I'm not good at English, so my description may get you confused. Sorry for that.)</p>\n", "AcceptedAnswerId": "15479358", "Title": "why defining a method with a return type as its class won't get me an 'incomplete type' error", "CreationDate": "2013-03-18T13:32:04.607", "Id": "15478101", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2013-03-18T14:54:48.563", "Score": "2", "OwnerUserId": "1916464", "Tags": "<c++><incomplete-type>", "AnswerCount": "2"}, "15478178": {"Id": "15478178", "PostTypeId": "2", "Body": "<p>When defining methods inside a class the class is treated as if it were a complete type, or else we would not be able to define inline methods. Also, if your class A were an incomplete type then the curiously recurring template pattern would not work either. Consider the following code:</p>\n<pre><code>template &lt;typename T&gt; struct base {};\n\nstruct derived : base&lt;derived&gt; {};  // We can use derived here\n                                    // without any \"incomplete type\"\n                                    // errors.\n</code></pre>\n<p>In other words: it's just the way the language works.</p>\n<p>EDIT: See Mike Seymour's below for the relevant section of the C++ standard that mentions this behaviour.</p>\n", "LastEditorUserId": "154744", "LastActivityDate": "2013-03-18T14:54:48.563", "Score": "3", "CreationDate": "2013-03-18T13:35:39.160", "ParentId": "15478101", "CommentCount": "5", "OwnerUserId": "154744", "LastEditDate": "2013-03-18T14:54:48.563"}});