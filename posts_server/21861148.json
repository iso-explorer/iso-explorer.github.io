post_cb({"bq_ids": {"n4140": {"so_21861148_21861190_2": {"length": 8, "quality": 1.0, "section_id": 568}, "so_21861148_21861190_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 5893}, "so_21861148_21861190_1": {"length": 7, "quality": 0.7, "section_id": 568}}, "n3337": {"so_21861148_21861190_2": {"length": 8, "quality": 1.0, "section_id": 559}, "so_21861148_21861190_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 5664}, "so_21861148_21861190_1": {"length": 7, "quality": 0.7, "section_id": 559}}, "n4659": {"so_21861148_21861190_2": {"length": 8, "quality": 1.0, "section_id": 591}, "so_21861148_21861190_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 7376}, "so_21861148_21861190_1": {"length": 7, "quality": 0.7, "section_id": 591}}}, "21861576": {"Id": "21861576", "PostTypeId": "2", "Body": "<p>A function without a ref-qualifier can be called for both rvalue and lvalues. A function with a <code>&amp;&amp;</code> ref-qualifier can only be called for rvalues. A function with a <code>&amp;</code> ref-qualifier can only be called for lvalues.</p>\n<pre><code>class No { void foo(); };\nclass L { void foo() &amp;; };\nclass R { void foo() &amp;&amp;; };\n\nNo().foo(); // valid\nNo no; no.foo(); // valid\nL().foo(); // invalid\nL l; l.foo(); // valid\nR().foo(); // valid\nR r; r.foo(); // invalid\n</code></pre>\n<p>Unfortunately, I can only find this rule in 5.5/6, which applies only to pointer-to-member dereference expressions. I know it applies otherwise too.</p>\n<p>Furthermore, you cannot overload on ref-qualifier vs no ref-qualifier, see 13.1/2 bullet 3. You can overload on <code>&amp;</code> vs <code>&amp;&amp;</code>.</p>\n<p>(And due to my fruitless search of the standard, LRiO's answer now has all that info too.)</p>\n", "LastActivityDate": "2014-02-18T17:50:44.737", "CommentCount": "3", "CreationDate": "2014-02-18T17:50:44.737", "ParentId": "21861148", "Score": "9", "OwnerUserId": "8922"}, "21861148": {"ViewCount": "2726", "Body": "<p>From the answer <a href=\"https://stackoverflow.com/questions/10758664/move-semantics-for-a-conversion-operator/10758725#10758725\">here</a>.</p>\n<pre><code>class wrap {\npublic:\n   operator obj() const &amp; { ... }   //Copy from me.\n   operator obj() &amp;&amp; { ... }  //Move from me.\nprivate:\n   obj data_;\n};\n</code></pre>\n<p>I know the <code>&amp;&amp;</code> means that the member will be invoked when the object is an rvalue reference. But what does the single ampersand mean? How is it different than without the ampersand?</p>\n", "AcceptedAnswerId": "21861190", "Title": "What does the single ampersand mean here?", "CreationDate": "2014-02-18T17:31:24.793", "LastActivityDate": "2014-11-17T10:08:54.760", "CommentCount": "0", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:10:21.310", "OwnerDisplayName": "user2005303", "LastEditorUserId": "-1", "Id": "21861148", "Score": "43", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "21861190": {"Id": "21861190", "PostTypeId": "2", "Body": "<p>It means the member will be invoked when the object is an lvalue reference.</p>\n<blockquote>\n<p id=\"so_21861148_21861190_0\"><code>[C++11: 9.3.1/5]:</code> A non-static member function may be declared with a <em>ref-qualifier</em> (8.3.5); see 13.3.1.</p>\n<p id=\"so_21861148_21861190_1\"><code>[C++11: 13.3.1/4]:</code> For non-static member functions, the type of the implicit object parameter is</p>\n<ul>\n<li>\u201clvalue reference to <em>cv</em> <code>X</code>\u201d for functions declared without a <em>ref-qualifier</em> or with the <code>&amp;</code> <em>ref-qualifier</em></li>\n<li>\u201crvalue reference to <em>cv</em> <code>X</code>\u201d for functions declared with the <code>&amp;&amp;</code> ref-qualifier</li>\n</ul>\n<p id=\"so_21861148_21861190_2\">where <code>X</code> is the class of which the function is a member and <em>cv</em> is the <em>cv-qualification</em> on the member function declaration. <em>[..]</em></p>\n<p id=\"so_21861148_21861190_3\"><em>(and some more rules that I can't find)</em></p>\n</blockquote>\n<p>Without a <em>ref-qualifier</em>, the function can always be invoked, regardless of the value category of the expression through which you're invoking it:</p>\n<pre><code>struct foo\n{\n    void bar() {}\n    void bar1() &amp; {}\n    void bar2() &amp;&amp; {}\n};\n\nint main()\n{\n    foo().bar();  // (always fine)\n    foo().bar1(); // doesn't compile because bar1() requires an lvalue\n    foo().bar2();\n\n    foo f;\n    f.bar();      // (always fine)\n    f.bar1();\n    f.bar2();     // doesn't compile because bar2() requires an rvalue\n}\n</code></pre>\n<h3><a href=\"http://coliru.stacked-crooked.com/a/6c39d2e81f0acfa6\">Live demo</a> <sup>(thanks Praetorian)</sup></h3>\n", "LastEditorUserId": "560648", "LastActivityDate": "2014-11-17T10:08:54.760", "Score": "44", "CreationDate": "2014-02-18T17:33:00.820", "ParentId": "21861148", "CommentCount": "8", "OwnerUserId": "560648", "LastEditDate": "2014-11-17T10:08:54.760"}, "21861569": {"Id": "21861569", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_21861148_21861569_0\">But what does the single ampersand mean? </p>\n</blockquote>\n<p>The function can <em>only</em> be called on an lvalue, not on an rvalue.</p>\n<blockquote>\n<p id=\"so_21861148_21861569_1\">How is it different than without the ampersand?</p>\n</blockquote>\n<p>Without a ref-qualifier you can invoke the function on an lvalue <em>or</em> an rvalue.</p>\n<p>With a ref-qualifier you can only call the function on the corresponding value category.</p>\n", "LastActivityDate": "2014-02-18T17:50:32.607", "CommentCount": "1", "CreationDate": "2014-02-18T17:50:32.607", "ParentId": "21861148", "Score": "20", "OwnerUserId": "981959"}});