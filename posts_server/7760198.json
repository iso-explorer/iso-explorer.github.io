post_cb({"7760220": {"Id": "7760220", "PostTypeId": "2", "Body": "<p>This is implementation-dependent.</p>\n<p>The standard explicitly allows the Empty Base Optimization, but does not require it.  In fact, the standard doesn't require much of anything about the layout of classes in memory, only that certain classes will be layout-compatible with each other (but not what the common layout is).  Order of members is also specified (when there is no intervening accessibility specifier), but padding, headers, footers, and all manner of weirder stuff is allowed.</p>\n", "LastActivityDate": "2011-10-13T20:45:47.667", "Score": "4", "CreationDate": "2011-10-13T20:45:47.667", "ParentId": "7760198", "CommentCount": "0", "OwnerUserId": "103167"}, "7771024": {"Id": "7771024", "PostTypeId": "2", "Body": "<p>There are good explanations in this thread. I just wanted to add that to work around this structure bloat issue you can simply make <code>empty</code> class a template, so that instantiating it with a different template argument makes it a different class:</p>\n<pre><code>template&lt;class T&gt;\nstruct empty { };\nstruct member: empty&lt;member&gt; { };\nstruct derived: empty&lt;derived&gt; { member m; };\n\nint main(void)\n{\n    printf(\"%d\\n\", sizeof(derived));\n    return 0;\n}\n</code></pre>\n<p>Outputs <code>1</code>. </p>\n<p>This is the reason to avoid using <code>boost::noncopyable</code> in large projects.</p>\n", "LastActivityDate": "2011-10-14T17:01:07.903", "Score": "1", "CreationDate": "2011-10-14T17:01:07.903", "ParentId": "7760198", "CommentCount": "0", "OwnerUserId": "412080"}, "bq_ids": {"n4140": {"so_7760198_7760516_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 5795}, "so_7760198_7760198_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 5795}}, "n3337": {"so_7760198_7760516_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 5568}, "so_7760198_7760198_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 5568}}, "n4659": {"so_7760198_7760516_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 7254}, "so_7760198_7760198_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 7254}}}, "7770707": {"Id": "7770707", "PostTypeId": "2", "Body": "<p>Expanding on my earlier comment:</p>\n<p>An object is identified by its address. If you compare the addresses (like pointers) of two objects of the same type and they compare equal, the pointers are considerd to point to the same object.</p>\n<p>Objects of different types cannot be compared directly this way, so they are allowed to have the same address. One example is a struct and its first member. They cannot be of the same type. Neither can a base class and a derived class, so they could possibly have the same address if the base class is empty.</p>\n<p>However, a base class and the first member of the derived class <em>can</em> be of the same type. This is not a problem unless the base class is also empty and the compiler tries the empty base class optimization. In that case we could have pointers to two different objects of the same type compare equal, and therefore believe that they were the same object.</p>\n<p>So, if the members have different types (empty and char) they can have the same address. If they are of the same type they cannot, because that would break tests for object identity like <code>if (this != &amp;that)</code>, sometimes used to test for things like self assignment.</p>\n<p>By the way, Microsoft agrees that this is a bug in their compiler but have other, more urgent, things to fix first.</p>\n", "LastEditorUserId": "597607", "LastActivityDate": "2011-10-14T16:41:50.607", "Score": "5", "CreationDate": "2011-10-14T16:32:09.840", "ParentId": "7760198", "CommentCount": "1", "LastEditDate": "2011-10-14T16:41:50.607", "OwnerUserId": "597607"}, "7760198": {"ViewCount": "382", "Body": "<p>The C++ standard (quoting from draft n3242) says the following about subobjects [intro.object]:</p>\n<blockquote>\n<p id=\"so_7760198_7760198_0\">Unless an object is a bit-field or a base class subobject of zero\n  size, the address of that object is the address of the first byte it\n  occupies. Two distinct objects that are neither bit-fields nor base\n  class subobjects of zero size shall have distinct addresses.</p>\n</blockquote>\n<p>Now, given the following snippet:</p>\n<pre><code>struct empty { };\nstruct member: empty { };\nstruct derived: empty { member m; };\n\nint main(void)\n{\n    printf(\"%d\", sizeof(derived));\n    return 0;\n}\n</code></pre>\n<p>gcc I believe prints out <code>2</code>, and Visual C++ 2010 prints out <code>1</code>. I suspect gcc is taking the standard to mean you can't alias the storage of types if they represent different objects. And I bet MSVC is taking the standard to mean if one subobject is zero sized, you can do whatever you want.</p>\n<p>Is this unspecified behavior?</p>\n", "AcceptedAnswerId": "7770707", "Title": "Should an empty base class affect the layout of the derived class?", "CreationDate": "2011-10-13T20:43:23.943", "Id": "7760198", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2011-10-14T17:01:07.903", "Score": "5", "OwnerUserId": "6210", "Tags": "<c++><standards><unspecified-behavior>", "AnswerCount": "4"}, "7760516": {"Id": "7760516", "PostTypeId": "2", "Body": "<p>In the final version of the C++11 standard, that paragraph was revised to read:</p>\n<blockquote>\n<p id=\"so_7760198_7760516_0\">Unless an object is a bit-field or a base class subobject of zero\n  size, the address of that object is the address of the first byte it\n  occupies. Two objects that are not bit-fields may have the same\n  address if one is a subobject of the other or if at least one is a\n  base class subobject of zero size and they are of different types;\n  otherwise, they shall have distinct addresses.</p>\n</blockquote>\n<p>Although I am not sure I understand what this has to do with the sizes of the objects.</p>\n", "LastActivityDate": "2011-10-13T21:15:08.450", "Score": "3", "CreationDate": "2011-10-13T21:15:08.450", "ParentId": "7760198", "CommentCount": "1", "OwnerUserId": "768469"}});