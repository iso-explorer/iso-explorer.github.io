post_cb({"28453118": {"CommentCount": "0", "ViewCount": "114", "PostTypeId": "1", "LastEditorUserId": "440558", "CreationDate": "2015-02-11T11:24:11.797", "LastActivityDate": "2015-02-11T11:58:35.127", "Title": "Understanding Qualified name lookup for namespace", "AcceptedAnswerId": "28453623", "LastEditDate": "2015-02-11T11:33:48.927", "Id": "28453118", "Score": "0", "Body": "<p>I would like to understand the namespace qualified name lookup. I am trying to leverage the following </p>\n<blockquote>\n<p id=\"so_28453118_28453118_0\">3.4.3.2.2: For a namespace X and name m, the namespace-qualified lookup set S(X,m) is defined as follows: Let S'(X,m) be the set of all\n  declarations of m in X and the inline namespace set of X (7.3.1). If\n  S'(X,m) is not empty, S(X,m) is S'(X,m); otherwise, S(X,m) is the\n  union of S(N_i,m) for all namespaces N_i nominated by using-directives\n  in X and its inline namespace set.</p>\n</blockquote>\n<p>to provide a fallback mechanism for a name iff it does not exist in the standard namespace. The following program exemplifies what I am envisaging to achieve</p>\n<pre><code>#include &lt;type_traits&gt;\nnamespace foo\n{\n    template&lt;class Ty&gt;\n    struct remove_extent\n        {\n        typedef Ty type;\n        };\n}\nnamespace fallback\n{\n    using namespace std;\n}\nnamespace fallback\n{\n    using namespace foo;\n}\ntemplate&lt;typename Ty&gt;\nstruct Bar\n{\n    typename fallback::remove_extent&lt;Ty&gt;::type var;\n};\nint main()\n{\n   Bar&lt;int[]&gt; var;\n}\n</code></pre>\n<p>For the first declaration</p>\n<pre><code>namespace fallback\n{\n    using namespace std;\n}\n</code></pre>\n<p><code>S'(fallback, remove_extent)</code> is an empty set so <code>S(fallback, remove_extent)</code> is the union of <code>S(std, remove_extent).</code></p>\n<p>For the second declaration</p>\n<pre><code>namespace fallback\n{\n    using namespace foo;\n}\n</code></pre>\n<p><code>S'(fallback, remove_extent)</code> is non-empty so <code>S(fallback, remove_extent) = S'(fallback, remove_extent) = S(std, remove_extent)</code></p>\n<p>but my compiler thinks otherwise and complains </p>\n<pre><code>1&gt;source.cpp(21): error C2872: 'remove_extent' : ambiguous symbol\n1&gt;          could be 'source.cpp(6) : foo::remove_extent'\n1&gt;          or       'c:\\program files (x86)\\microsoft visual studio 11.0\\vc\\include\\type_traits(331) : std::remove_extent'\n</code></pre>\n<p>So obviously my understanding is wrong. Why does the compiler includes the name <code>remove_extent</code> from foo?</p>\n", "Tags": "<c++><c++11><namespaces><language-lawyer>", "OwnerUserId": "977038", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28453118_28453118_0": {"section_id": 7117, "quality": 0.7222222222222222, "length": 26}}, "n3337": {"so_28453118_28453118_0": {"section_id": 6861, "quality": 0.7222222222222222, "length": 26}}, "n4659": {"so_28453118_28453118_0": {"section_id": 8618, "quality": 0.7222222222222222, "length": 26}}}, "28453623": {"ParentId": "28453118", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_28453118_28453623_0\">For the second declaration ... <code>S'(fallback, remove_extent)</code> is non-empty</p>\n</blockquote>\n<p>No, it isn't:</p>\n<pre><code>namespace fallback\n{\n    using namespace std;\n}\n</code></pre>\n<p>After this point, <code>S'(fallback, remove_extent)</code> is empty, so <code>S</code> is <code>S(std, remove_extent)</code>.</p>\n<pre><code>namespace fallback\n{\n    using namespace foo;\n}\n</code></pre>\n<p>After this point, <code>S'(fallback, remove_extent)</code> is <em>still</em> empty (i.e. there's still no declaration of a <code>remove_extent</code> <em>directly in</em> <code>fallback</code>), so <code>S</code> is now the union of <code>S(std, remove_extent)</code> and <code>S(foo, remove_extent)</code>.</p>\n<pre><code>template&lt;typename Ty&gt;\nstruct Bar\n{\n    typename fallback::remove_extent&lt;Ty&gt;::type var;\n};\n</code></pre>\n<p>When we get to this point, there are two entities named <code>remove_extent</code> in <code>fallback</code> (one from <code>std</code> and one from <code>foo</code>, neither declared directly in <code>fallback</code>), so the compiler correctly tells you that the name is ambiguous.</p>\n", "OwnerUserId": "636019", "LastEditorUserId": "636019", "LastEditDate": "2015-02-11T11:53:33.733", "Id": "28453623", "Score": "4", "CreationDate": "2015-02-11T11:48:31.770", "LastActivityDate": "2015-02-11T11:53:33.733"}});