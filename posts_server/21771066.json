post_cb({"bq_ids": {"n4140": {"so_21771066_21771741_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 7151}}, "n3337": {"so_21771066_21771741_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 6895}}}, "21771608": {"PostTypeId": "2", "Body": "<p>There may be many ways to do that. See the snippet below where the constructor of class A called before main because we have declared an object of class A at global scope: (I have expanded the example to demonstrate how a thread can be created before main executes)</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;pthread.h&gt;\nusing namespace std;\n\nvoid *fun(void *x)\n{\n    while (true) {\n        cout &lt;&lt; \"Thread\\n\";\n        sleep(2);\n    }\n}\n\npthread_t t_id;\nclass A\n{\n    public: \n        A() \n        { \n            cout &lt;&lt; \"Hello before main \\n \" ;\n            pthread_create(&amp;t_id, 0, fun, 0);\n            sleep(6);\n        }\n};\n\nA a;\nint main()\n{\n    cout &lt;&lt; \"I am main\\n\";\n    sleep(40);\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2014-02-14T05:44:52.473", "LastEditorUserId": "1898070", "Id": "21771608", "CommentCount": "2", "CreationDate": "2014-02-14T05:36:48.883", "ParentId": "21771066", "Score": "0", "OwnerUserId": "1898070", "LastEditDate": "2014-02-14T05:44:52.473"}, "21771066": {"ViewCount": "365", "Body": "<p>I have this object that contains a thread. I want the fate of the object and the fate of the thread to be one in the same. So the constructor creates a thread (with <code>pthread_create</code>) and the destructor performs actions to cause the thread to return in a reasonable amount of time and then joins the thread. This is working fine as long as I don't instantiate one of these objects with static storage duration. If I instantiate one of these objects at global or namespace or static class scope the program compiles fine (gcc 4.8.1) but immediately segfaults upon running. With print statements I have determined that the main thread doesn't even enter main() before the segfault. Any ideas?</p>\n<p>Update: Also added a print statement to the first line of the constructor (so before <code>pthread_create</code> is called), and not even that gets printed before the segfault BUT the constructor does use an initialization list so it is possible something there is causing it?</p>\n<p>Here is the constructor:</p>\n<pre><code>worker::worker(size_t buffer_size):\nm_head(nullptr),m_tail(nullptr),\nm_buffer_A(operator new(buffer_size)),\nm_buffer_B(operator new(buffer_size)),\nm_next(m_buffer_A),\nm_buffer_size(buffer_size),\nm_pause_gate(true),\nm_worker_thread([this]()-&gt;void{ thread_func(); }),\nm_running(true)\n{\n    print(\"this wont get printed b4 segfault\");\n    scoped_lock lock(worker_lock);\n    m_worker_thread.start();\n    all_workers.push_back(this);\n}\n</code></pre>\n<p>And destructor:</p>\n<pre><code>worker::~worker()\n{\n    {\n        scoped_lock lock(worker_lock);\n        auto w=all_workers.begin();\n        while(w!=all_workers.end())\n        {\n            if(*w==this)\n            {\n                break;\n            }\n            ++w;\n        }\n        all_workers.erase(w);\n    }\n\n    {\n        scoped_lock lock(m_lock);\n        m_running=false;\n    }\n\n    m_sem.release();\n    m_pause_gate.open();\n\n    m_worker_thread.join();\n\n    operator delete(m_buffer_A);\n    operator delete(m_buffer_B);\n}\n</code></pre>\n<p>Update 2:</p>\n<p>Okay I figured it out. My print function is atomic and likewise protects <code>cout</code> with an extern namespace scope mutex defined elsewhere. I changed to just plain <code>cout</code> and it printed at the beginning of the ctor. Apparently none of these static storage duration mutexes are getting initialized before things are trying to access them. So yeah it is probably Casey's answer.</p>\n<p>I'm just not going to bother with complex objects and static storage duration. It's no big deal anyway.</p>\n", "AcceptedAnswerId": "21771741", "Title": "Is the main thread allowed to spawn a POSIX thread before it enters main()?", "CreationDate": "2014-02-14T04:48:15.773", "Id": "21771066", "CommentCount": "7", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-02-14T06:05:37.657", "LastEditorUserId": "2066982", "LastActivityDate": "2014-02-14T06:05:37.657", "Score": "13", "OwnerUserId": "2066982", "Tags": "<c++><multithreading><c++11><segmentation-fault><pthreads>", "AnswerCount": "3"}, "21771741": {"PostTypeId": "2", "Body": "<p>Initialization of non-local variables is described in C++11 \u00a73.6.2, there's a ton of scary stuff in paragraph 2 that has to do with threads:</p>\n<blockquote>\n<p id=\"so_21771066_21771741_0\">If a program starts a thread (30.3), the subsequent initialization of a variable is unsequenced with respect to the initialization of a variable defined in a different translation unit. Otherwise, the initialization of a variable is indeterminately sequenced with respect to the initialization of a variable defined in a different translation unit. If a program starts a thread, the subsequent unordered initialization of a variable is unsequenced with respect to every other dynamic initialization.</p>\n</blockquote>\n<p>I interpret \"the subsequent unordered initialization of a variable is unsequenced with respect to every other dynamic initialization\" to mean that the spawned thread cannot access any variable with dynamic initialization that was not initialized before the thread was spawned without causing a data race. If that thread doesn't somehow synchronize with <code>main</code>, you're basically dancing through a minefield with your hands over your eyes.</p>\n<p>I'd strongly suggest you read through and understand all of 3.6; even without threads it's a huge PITA to do much before <code>main</code> starts.</p>\n", "LastActivityDate": "2014-02-14T05:53:59.830", "LastEditorUserId": "923854", "Id": "21771741", "CommentCount": "2", "CreationDate": "2014-02-14T05:48:27.903", "ParentId": "21771066", "Score": "6", "OwnerUserId": "923854", "LastEditDate": "2014-02-14T05:53:59.830"}, "21771488": {"PostTypeId": "2", "Body": "<p>What happens before entering main will be platform specific, but here is a link on how main() executes on Linux</p>\n<p><a href=\"http://linuxgazette.net/84/hawk.html\" rel=\"nofollow\">http://linuxgazette.net/84/hawk.html</a></p>\n<p>The useful snipet is </p>\n<blockquote>\n<p id=\"so_21771066_21771488_0\">__libc_start_main initializes necessary stuffs, especially C library(such as malloc) and thread environment and calls our main.</p>\n</blockquote>\n<p>For more information look up __libc_start_main</p>\n<p>Not sure how this behaves on Windows, but it seems like any standard C library call before entering main is not a good idea</p>\n", "LastActivityDate": "2014-02-14T05:27:18.263", "Id": "21771488", "CommentCount": "1", "CreationDate": "2014-02-14T05:27:18.263", "ParentId": "21771066", "Score": "0", "OwnerUserId": "1516456"}});