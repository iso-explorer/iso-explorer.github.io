post_cb({"31672427": {"ParentId": "31672057", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Given the current wording; I think it is specified in these terms (\u00a712.9/1 of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">C++ WD n4527</a>) for few reasons (but principally to avoid potential ambiguity);</p>\n<ol>\n<li><strong>Avoid ambiguity</strong>. I.e. if you start to provide your own constructors with matching parameters, this will then allow for these constructors to not conflict (be ambiguous) with the inherited constructors</li>\n<li>Maintain the effect thereof. I.e. what would the client code look like</li>\n</ol>\n<p>The <a href=\"http://en.cppreference.com/w/cpp/language/using_declaration#Inheriting_constructors\" rel=\"nofollow\">inheriting constructors</a> is a technique akin to code generation (\"I want what my base has\"). There is no way to specify which constructors you are getting, you basically get them all hence the compiler much take care to not generate ambiguous constructors.</p>\n<p>By way of example;</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nstruct Base {\n    Base (int a = 0, int b = 1) { cout &lt;&lt; \"Base\" &lt;&lt; a &lt;&lt; b &lt;&lt; endl; }\n};\nstruct Derived : Base {\n    // This would be ambiguous if the inherited constructor was Derived(int=0,int=1)\n    Derived(int c) { cout &lt;&lt; \"Derived\" &lt;&lt; c &lt;&lt; endl; }\n    using Base::Base;\n};\nint main()\n{\n    Derived d1(3);\n    Derived d2(4,5);\n}\n</code></pre>\n<p>Outputs;</p>\n<blockquote>\n<p id=\"so_31672057_31672427_0\">Base01<br>\n  Derived3<br>\n  Base45</br></br></p>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/83c7c69c92ab78cb\" rel=\"nofollow\">Sample code</a>.</p>\n<hr>\n<p>There is a proposal out <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4429.html\" rel=\"nofollow\">n4429</a> (as noted by Jonathan Wakely) for a change in the wording around the inheriting constructors and the using declaration for classes.</p>\n<p>Given the intent of the proposal;</p>\n<blockquote>\n<p id=\"so_31672057_31672427_1\">... this proposal makes inheriting a constructor act just like inheriting any other base class member, to the extent possible.</p>\n</blockquote>\n<p>There is the following change (new wording);</p>\n<blockquote>\n<p id=\"so_31672057_31672427_2\">Change in 7.3.3 namespace.udecl paragraph 15:</p>\n<p id=\"so_31672057_31672427_3\">When a <em>using-declaration</em> brings declarations from a base class into a derived class... Such hidden or overridden declarations are excluded from the set of declarations introduced by the using-declaration.</p>\n</blockquote>\n<p>And immediately follows this with an example that deals directly the constructors (although without default arguments);</p>\n<pre><code>struct B1 {\n  B1(int);\n};\n\nstruct B2 {\n  B2(int);\n};\n\nstruct D1 : B1, B2 {\n  using B1::B1;\n  using B2::B2;\n};\nD1 d1(0);    // ill-formed: ambiguous\n\nstruct D2 : B1, B2 {\n  using B1::B1;\n  using B2::B2;\n  D2(int);   // OK: D2::D2(int) hides B1::B1(int) and B2::B2(int)\n};\nD2 d2(0);    // calls D2::D2(int)\n</code></pre>\n<p>In short, whilst probably not the final wording, it seems that the intent is to allow the constructors to be used with their default arguments and explicitly excludes hidden and overridden declarations thus I believe taking care of any ambiguity. The wording does seem to simplify the standard, yet yielding the same result w.r.t. it being used in client code.</p>\n</hr>", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2015-07-28T14:22:38.470", "Id": "31672427", "Score": "8", "CreationDate": "2015-07-28T09:30:22.343", "LastActivityDate": "2015-07-28T14:22:38.470"}, "31673058": {"ParentId": "31672057", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_31672057_31673058_0\">What is the reasoning behind this rule?</p>\n</blockquote>\n<p>It could prevent from the changes of the default argument from base class influencing the behaviour of all the derived class (inside the derived class scope), which will be a <em>surprise</em> for the derived class creators.</p>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2015-07-28T10:17:11.587", "Id": "31673058", "Score": "2", "CreationDate": "2015-07-28T10:00:49.873", "LastActivityDate": "2015-07-28T10:17:11.587"}, "31672901": {"ParentId": "31672057", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Default arguments are not part of a function's signature, and can be added later, and in a restricted scope, which would not be able to change the already-defined constructors of a derived class e.g.</p>\n<pre><code>// in A.h\nstruct A {\n    A(int, int);\n};\n\n// in B.h\n#include \"A.h\"\nstruct B : A {\n    using A::A;\n};\n\n// in A.cc\n#include \"A.h\"\nA::A(int, int = 0) { }\n</code></pre>\n<p>In the file <code>A.cc</code> you can construct an <code>A</code> with a single parameter, because the default argument is visible, but when <code>B</code> was declared the default argument was not visible, so cannot be considered when inheriting the constructors. I believe this is one reason that default arguments get special treatment.</p>\n<p>Although apparently how inheriting constructors work might be going to change, and default arguments would not get this special handling, see <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4429.html\">http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4429.html</a></p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2015-07-28T10:14:32.730", "Id": "31672901", "Score": "6", "CreationDate": "2015-07-28T09:53:27.510", "LastActivityDate": "2015-07-28T10:14:32.730"}, "bq_ids": {"n4659": {"so_31672057_31672427_3": {"section_id": 6938, "quality": 0.8888888888888888, "length": 16}}}, "31672057": {"CommentCount": "4", "ViewCount": "1610", "CreationDate": "2015-07-28T09:14:12.573", "LastActivityDate": "2015-07-28T14:22:38.470", "Title": "Why shouldn't the inherited constructor inherit the default arguments?", "FavoriteCount": "2", "PostTypeId": "1", "Id": "31672057", "OwnerUserId": "2725810", "Body": "<p><strong>C++ Primer</strong> (5th edition) on page 629 states:</p>\n<blockquote id=\"so_31672057_31672057_0\">\n<ul>\n<li>If a base class constructor has default arguments, those arguments are not inherited. Instead, the derived class gets multiple inherited constructors in which each parameter with a default argument is successively omitted.</li>\n</ul>\n</blockquote>\n<p>What is the reasoning behind this rule?</p>\n", "Tags": "<c++><c++11><inheritance>", "Score": "12", "AnswerCount": "3"}});