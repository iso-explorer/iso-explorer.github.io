post_cb({"16827131": {"ParentId": "16827034", "LastEditDate": "2013-05-30T02:56:02.167", "CommentCount": "3", "CreationDate": "2013-05-30T02:44:34.313", "Score": "10", "LastEditorUserId": "777186", "PostTypeId": "2", "Id": "16827131", "OwnerUserId": "777186", "Body": "<p>The proposals for C++14 include one (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3638.html\" rel=\"noreferrer\">N3638</a>, by Jason Merrill) that defines a special declaration to accomplish this, using <code>decltype(auto)</code> instead of <code>auto</code>:</p>\n<pre><code>template &lt;class A&gt;\nstruct C{\n  decltype(auto) func()\n    {\n        return a.func();\n    }\n\n    A a;\n};\n</code></pre>\n<p>GCC implements this in the <a href=\"http://gcc.gnu.org/gcc-4.9/changes.html\" rel=\"noreferrer\">4.9 snapshot</a>, see the C++ section.</p>\n<p>When changing the final parts of your code to</p>\n<pre><code>static_assert(std::is_same&lt;decltype(c1.func()), int&gt;::value, \"true\");\nstatic_assert(std::is_same&lt;decltype(c2.func()), int&amp;&gt;::value, \"true\");\nstatic_assert(std::is_same&lt;decltype(c3.func()), const int&amp;&gt;::value, \"true\");\nstatic_assert(std::is_same&lt;decltype(c4.func()), int&amp;&amp;&gt;::value, \"true\");\n</code></pre>\n<p>the GCC 4.9 snapshot compiles it, while 4.8 does not.</p>\n<p>(Note: Both compilers will crash on an internal compiler error if you use the <code>-g</code> option when compiling. This is due to <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56014\" rel=\"noreferrer\">Bug 56014</a>.)</p>\n<hr>\n<p>For the sake of completeness, here is the most relevant section from the proposal:</p>\n<blockquote>\n<p id=\"so_16827034_16827131_0\">If the placeholder is the decltype(auto) type-specifier, the declared type of the variable or return type of the function shall be the placeholder alone. The type deduced for the variable or return type is determined as described in 7.1.6.2, as though the initializer had been the operand of the decltype. [ Example:</p>\n<pre><code>int i;\nint&amp;&amp; f();\nauto           x3a = i;        // decltype(x3a) is int\ndecltype(auto) x3d = i;        // decltype(x3d) is int\nauto           x4a = (i);      // decltype(x4a) is int\ndecltype(auto) x4d = (i);      // decltype(x4d) is int&amp;\nauto           x5a = f();      // decltype(x5a) is int\ndecltype(auto) x5d = f();      // decltype(x5d) is int&amp;&amp;\nauto           x6a = { 1, 2 }; // decltype(x6a) is std::initializer_list&lt;int&gt;\ndecltype(auto) x6d = { 1, 2 }; // error, { 1, 2 } is not an expression\nauto          *x7a = &amp;i;       // decltype(x7a) is int*\ndecltype(auto)*x7d = &amp;i;       // error, declared type is not plain decltype(auto)\n</code></pre>\n<p id=\"so_16827034_16827131_1\">\u2014 end example ]</p>\n</blockquote>\n</hr>", "LastActivityDate": "2013-05-30T02:56:02.167"}, "16827034": {"CommentCount": "2", "ViewCount": "488", "PostTypeId": "1", "LastEditorUserId": "1760345", "CreationDate": "2013-05-30T02:32:59.507", "LastActivityDate": "2013-05-30T03:48:19.310", "Title": "How to keep cv qualifier or reference in return type deduction in c++1y?", "AcceptedAnswerId": "16827131", "LastEditDate": "2013-05-30T03:48:19.310", "Id": "16827034", "Score": "5", "Body": "<p>First I construct four structs each of which returns value, l-value reference, const l-value reference, r-value reference. And I use them in the wrapper(<code>B</code> or <code>C</code>), in the method <code>func()</code> of those wrapper, \nI want to keep the references and cv qualifiers of <code>func()</code> of  <code>A</code>. </p>\n<p>In c++11, I used trailing return type. But with the arrival of the normal return type deduction in c++14, I guessed I can skip the trailing part, but only with <code>auto</code>, the return type ignores qualifiers and references just like ordinary <code>auto</code>. </p>\n<p>Then, my question is what is the best way to achieve it in c++14 which behaves just like class <code>B</code> below? \nIt is sometimes depressive to write trailing part(usually decltype(return expression)) when it is trivial.</p>\n<pre><code>struct A1 {\n    int func(){\n        return x;\n    }\n    int x{3};\n};\n\nstruct A2 {\n    int&amp; func(){\n        return x;\n    }\n    int x{3};\n};\n\nstruct A3 {\n    const int&amp; func(){\n        return x;\n    }\n    int x{3};\n};\n\nstruct A4 {\n    int&amp;&amp; func(){\n        return std::move(x);\n    }\n    int x{3};\n};\n\ntemplate &lt;class A&gt;\nstruct B{\n    auto func() -&gt; decltype(std::declval&lt;A&gt;().func())\n    {\n        return a.func();\n    }\n\n    A a;\n};\n\ntemplate &lt;class A&gt;\nstruct C{\n    auto func()\n    {\n        return a.func();\n    }\n\n    A a;\n};\n\nint main(){\n    std::cout &lt;&lt; std::boolalpha;\n\n    B&lt;A1&gt; b1;   \n    B&lt;A2&gt; b2;   \n    B&lt;A3&gt; b3;   \n    B&lt;A4&gt; b4;\n\n    static_assert(std::is_same&lt;decltype(b1.func()), int&gt;::value, \"true\");\n    static_assert(std::is_same&lt;decltype(b2.func()), int&amp;&gt;::value, \"true\");\n    static_assert(std::is_same&lt;decltype(b3.func()), const int&amp;&gt;::value, \"true\");\n    static_assert(std::is_same&lt;decltype(b4.func()), int&amp;&amp;&gt;::value, \"true\");\n\n    C&lt;A1&gt; c1;   \n    C&lt;A2&gt; c2;   \n    C&lt;A3&gt; c3;   \n    C&lt;A4&gt; c4;\n\n    static_assert(std::is_same&lt;decltype(c1.func()), int&gt;::value, \"true\");\n    static_assert(std::is_same&lt;decltype(c2.func()), int&gt;::value, \"true\");\n    static_assert(std::is_same&lt;decltype(c3.func()), int&gt;::value, \"true\");\n    static_assert(std::is_same&lt;decltype(c4.func()), int&gt;::value, \"true\");\n}\n</code></pre>\n<p>Note that this programs compiles without problem in gcc 4.8 with -std=c++1y option. </p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "1120977", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_16827034_16827131_0": {"section_id": 5451, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_16827034_16827131_0": {"section_id": 6890, "quality": 0.5185185185185185, "length": 14}}}});