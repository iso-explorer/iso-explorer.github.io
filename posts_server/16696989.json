post_cb({"16699194": {"ParentId": "16696989", "CommentCount": "0", "CreationDate": "2013-05-22T18:33:41.530", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "16699194", "Score": "2", "Body": "<p>This is not an issue of lookup at all. The key point is that lookup completes <strong>before</strong> overload resolution kicks in. When the compiler sees <code>do_something</code> it performs lookup to figure out what it means, it finds that it is a function, which in turn activates ADL to find other potential overloads. Then lookup completes and overload resolution starts. When overload resolution fails.</p>\n", "LastActivityDate": "2013-05-22T18:33:41.530"}, "16697520": {"ParentId": "16696989", "CommentCount": "8", "CreationDate": "2013-05-22T16:56:38.187", "OwnerUserId": "363751", "PostTypeId": "2", "Id": "16697520", "Score": "4", "Body": "<p>The further a language goes out of its way to find a valid interpretation for a construct, the more likely it is that a typo or other such mistake will result in the compiler finding a meaning which is valid but <em>wrong</em>.  The compiler is assuming that if <code>foo</code> is defined within some scope, and code within that scope uses <code>foo</code>, the programmer intends for the code to use the <code>foo</code> that is defined within the scope.  If the programmer tries to do something with <code>foo</code> that is not permitted by its inner scope definition, odds are very good that one of the following is true:</p>\n<ul>\n<li>The programmer meant to do some other slightly different operation, which would have been valid on the inner foo.  A compiler could not be expected to know what the programmer intends unless the programmer specifies it.</li>\n<li>The programmer meant to do the indicated operation, not realizing that the inner <code>foo</code> can't support it, and will thus have to find some other operation or sequence of operations the inner <code>foo</code> can support.  Again, a compiler can't be expected to generate good code unless the programmer indicates how to use <code>foo</code> properly.</li>\n<li>The programmer meant to do the operation in question on the outer foo, but declined to explicitly say so.  If the compiler wanted to guess that this is what the programmer meant, it could generate code which would behave this way.</li>\n</ul>\n<p>Only if the programmer's intention was #3 could a compiler possibly generate code which would behave as intended.  It's far more likely, however, that a programmer really intended #1 or #2.  If the compiler refuses to compile code even when assuming #3 would produce <em>valid</em> code, then any of the above mistakes will be found and can thus be corrected.  By contrast, if compiler assumed #3 whenever it could, then if the programmer really intended #1 or #2 problems would not manifest themselves until the code was run and behaved contrary to design.</p>\n<p>BTW, if I had my druthers, I would apply this principle to case-sensitivity in .NET languages, forbidding not only the writing of any identifier in a fashion inconsistent with the definition (as is done by C# but not vb.net), but the use of any identifier which differs only in upper/lower-casing from one in an inner scope.  For example:</p>\n<pre><code>class foo\n{\n  int x;\n  void bar()\n  {\n    int X=2;\n    x=4; // ****\n    return X;\n  }\n}\n</code></pre>\n<p>Given the above code, C# would guess that the line with the asterisks was intended to write the field; given similar code, vb.net would assume it was intended to write the local variable.  Personally, I dislike both assumptions; the principle of \"say exactly what you mean\" would suggest to me that a compiler should require the programmer to either say <code>this.x=4;</code> or <code>X=4;</code>, neither of which could possibly be read as having the wrong meaning.</p>\n", "LastActivityDate": "2013-05-22T16:56:38.187"}, "16698562": {"ParentId": "16696989", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-05-22T17:55:41.463", "Score": "6", "LastEditorUserId": "981959", "LastEditDate": "2013-05-22T18:03:02.297", "Id": "16698562", "OwnerUserId": "981959", "Body": "<blockquote>\n<p id=\"so_16696989_16698562_0\">My question is: <strong>are these compilers confirming to the standard?</strong></p>\n</blockquote>\n<p>Yes.  Before overload resolution decides which functions are <em>viable</em> candidates (which includes checking the number of parameters) the compiler first has to do name lookup, to find all candidates, viable and non-viable.  In your example name lookup stops after finding the member <code>do_something()</code> so overload resolution never gets a chance to decide whether the namespace-scope one is viable.</p>\n<blockquote>\n<p id=\"so_16696989_16698562_1\">3.4.1 [basic.lookup.unqual]/1: \"In all the cases listed in 3.4.1, the scopes are searched for a declaration in the order listed in each of the respective categories; name lookup ends as soon as a declaration is found for the name.\"</p>\n</blockquote>\n<p>3.4.1 [basic.lookup.unqual] paragraph 8 lists the contexts searched for the name and even has an example that answers your question exactly.  The scope of <code>Test</code> is searched before the enclosing namespace, and as paragraph 1 says <strong>\"name lookup ends as soon as a declaration is found for the name\"</strong>.</p>\n", "LastActivityDate": "2013-05-22T18:03:02.297"}, "16696989": {"CommentCount": "3", "ViewCount": "336", "PostTypeId": "1", "LastEditorUserId": "2368", "CreationDate": "2013-05-22T16:26:49.247", "LastActivityDate": "2013-05-22T18:33:41.530", "Title": "Why don't the compiler take the namespace name when the inner scope ones don't work?", "FavoriteCount": "1", "LastEditDate": "2013-05-22T16:39:53.840", "Id": "16696989", "Score": "7", "Body": "<p>I thought I understood name lookup very well (after having watched several videos about it and read a lot) but I just hit this case:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace test{\n\n  struct Id\n  {};\n\n  void do_something( const Id&amp; ){  std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; }\n\n  class Test\n  {\n  public:\n\n    void do_something() { std::cout &lt;&lt; \"WTF!\" &lt;&lt; std::endl;  }\n\n    void run()\n    {\n      Id id;\n      do_something( id ); // doesn't compile\n    }\n\n  };\n\n}\n\nint main()\n{\n    test::Test my_test;\n  my_test.run();\n}\n</code></pre>\n<p>The pointed line don't compile (on GCC4.8 and VC11U2) because it tries to use the member function  <code>test::Test::do_something()</code> instead of the namespace-scoped <code>test::do_something( const Id&amp; )</code> which seem like the only possible candidate.</p>\n<p>Apparently the member function name hides the namespace-scoped names which is surprising to me because I remember using almost similar code in other context without this problem spawning (but the conditions might have be very different in the end).</p>\n<p>My question is: <strong>are these compilers confirming to the standard?</strong></p>\n<p>(Name lookup is very hard to understand by reading the standard document unfortunately, so I need expert confirmations)</p>\n", "Tags": "<c++><visual-c++><gcc><c++11>", "OwnerUserId": "2368", "AnswerCount": "5"}, "16697114": {"ParentId": "16696989", "CommentCount": "10", "CreationDate": "2013-05-22T16:33:18.227", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "16697114", "Score": "1", "Body": "<p>The compiler will gather up all \"candidate names\", which will be from the same scope unless ADL is involved, and then try to pick the best match if one is available. Under no circumstances will a failed match cause it to attempt to find additional candidate names from alternate scopes.</p>\n<p>This is very similar to how compilers do overload resolution first and THEN check the public/private of the member to see if it's actually accessible.</p>\n<p>g++ has a handy <code>-Wshadow</code> option to hunt down shadows (I'm not sure it would warn about this one specifically though).</p>\n", "LastActivityDate": "2013-05-22T16:33:18.227"}, "16697511": {"ParentId": "16696989", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-05-22T16:56:01.953", "Score": "1", "LastEditorUserId": "420683", "LastEditDate": "2013-05-22T17:16:46.280", "Id": "16697511", "OwnerUserId": "420683", "Body": "<blockquote>\n<p id=\"so_16696989_16697511_0\">Name lookup is very hard to understand by reading the standard document unfortunately, so I need expert confirmations</p>\n</blockquote>\n<p>I'm not an expert by any means, but here's how I understand the name lookup rules of the Standard.</p>\n<p>Two examples:</p>\n<pre><code>void foo(int);\n\nnamespace associated\n{\n    struct bee {};\n    void flower(bee);\n}\n\nnamespace bar\n{\n    void foo();\n    void flower();\n\n    void test()\n    {\n        foo(42);                   // (A)\n        flower(associated::bee()); // (B)\n    }\n}\n\nint main()\n{\n    bar::test();\n}\n</code></pre>\n<p>(A) does not compile, because of [basic.lookup.unqual]: \"name lookup ends as soon as a declaration is found for the name\"</p>\n<p>(B) does compile, because of ADL; <code>associated</code> is an associated namespace.</p>\n<p>However, there's [basic.lookup.argdep]/3:</p>\n<blockquote>\n<p id=\"so_16696989_16697511_1\">Let X be the lookup set produced by unqualified lookup (3.4.1) and let Y be the lookup set produced by argument dependent lookup (defined as follows). If X contains</p>\n<ul>\n<li>a declaration of a class member, or</li>\n<li>a block-scope function declaration that is not a using-declaration, or</li>\n<li>a declaration that is neither a function or a function template</li>\n</ul>\n<p id=\"so_16696989_16697511_2\">then Y is empty. Otherwise Y is the set of declarations found in the namespaces associated with the argument types as described below. The set of declarations found by the lookup of the name is the union of X and Y.</p>\n</blockquote>\n<p>The first point applies in your example. Therefore, I think yes, the compilers that reject your example comply with the Standard.</p>\n", "LastActivityDate": "2013-05-22T17:16:46.280"}, "bq_ids": {"n4140": {"so_16696989_16697511_2": {"section_id": 7105, "quality": 0.9473684210526315, "length": 18}, "so_16696989_16698562_1": {"section_id": 7087, "quality": 0.8571428571428571, "length": 18}, "so_16696989_16697511_1": {"section_id": 7105, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_16696989_16697511_2": {"section_id": 6849, "quality": 0.9473684210526315, "length": 18}, "so_16696989_16698562_1": {"section_id": 6831, "quality": 0.8571428571428571, "length": 18}, "so_16696989_16697511_1": {"section_id": 6849, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_16696989_16697511_1": {"section_id": 8606, "quality": 0.9411764705882353, "length": 16}, "so_16696989_16698562_1": {"section_id": 8588, "quality": 0.8571428571428571, "length": 18}, "so_16696989_16697511_2": {"section_id": 8606, "quality": 0.9473684210526315, "length": 18}}}});