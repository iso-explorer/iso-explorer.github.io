post_cb({"5195657": {"ParentId": "5195512", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2011-03-04T15:24:20.770", "Score": "31", "LastEditorUserId": "251738", "LastEditDate": "2011-03-04T17:29:43.760", "Id": "5195657", "OwnerUserId": "251738", "Body": "<p>Since <code>Test</code> is within namespace <code>B</code> the compile sees the operator in that namespace and notes that it doesn't have a matching signature. It also attempts to find the operator in namespace A which contains the class but can't find it there either. Because there's already such an operator (with the wrong signature) in namespace <code>B</code> it won't go and attempt to find one at global scope.</p>\n<p>The reason it doesn't search for the global one is roughly as follows. I'm first going to quote the standard and then try to explain it.</p>\n<p>From 3.4/1:</p>\n<blockquote>\n<p id=\"so_5195512_5195657_0\">...Name lookup may associate more than\n  one declaration with a name if it\n  finds the name to be a function name;\n  the declarations are said to form a\n  set of overloaded functions (13.1).\n  Overload resolution (13.3) takes place\n  after name lookup has succeeded.</p>\n</blockquote>\n<p>As I read this, when the compiler is trying to find a function (which your operators is in this context) it first tries to do name lookup to find the function first. Then next it tries to pick the right function from the set of overloads.</p>\n<p>Now from 3.4.1/6:</p>\n<blockquote>\n<p id=\"so_5195512_5195657_1\">A name used in the definition of a\n  function(26) that is a member of\n  namespace N (where, only for the\n  purpose of exposition, N could\n  represent the global scope) shall be\n  declared before its use in the block\n  in which it is used or in one of its\n  enclosing blocks (6.3) or, shall be\n  declared before its use in namespace N\n  or, if N is a nested namespace, shall\n  be declared before its use in one of\n  N\u2019s enclosing namespaces.</p>\n</blockquote>\n<p>Let's break this down. You're using the <code>operator&lt;&lt;</code> in a namespace level function so this section applies. It's going to try to find that operator using the precedence in the described above. Your operator isn't declared in the current block or enclosing blocks (this is referring to nested <code>{}</code> within your function). However the next part matches \"...shall be declared before its use in namespace N...\". There <em>is</em> in fact an <code>operator&lt;&lt;</code> in the current namespace (<code>B</code>) so it adds that operator to its list of matches. There aren't any more matches in <code>B</code>, and because same-namespace scope is considered the best possible match-closeness, it won't look into any other scopes.</p>\n<p>The reason it works when you put the operator into namespace A is that since the item being printed is a member of <code>A</code>, that namespace is actually considered because it's included in the namespaces of the expression. Since namespace <code>A</code> <em>is</em> considered it finds the appropriate match in that namespace and compiles correctly.</p>\n<p>Now that it has a list of possible operators, it tries to do overload resolution on them. Unfortunately the one in found in namespace B is the only one it considers and it doesn't match the required arguments.</p>\n<p>In general you should have the insertion operators in the same namespace as the class upon which it operates.</p>\n", "LastActivityDate": "2011-03-04T17:29:43.760"}, "5196150": {"ParentId": "5195512", "CommentCount": "0", "CreationDate": "2011-03-04T15:58:14.733", "OwnerUserId": "625981", "PostTypeId": "2", "Id": "5196150", "Score": "7", "Body": "<p>My answer is very similar to the others but in particular, the compiler is trying to find A::operator&lt;&lt;() because it's operating on something in the A namespace. If you want to invoke the one outside the namespace, you can call it explicitly by using </p>\n<pre><code>::operator&lt;&lt;(std::cout, A::MyClass();\n</code></pre>\n<p>For smoother syntactic use, put it in the namespace.</p>\n", "LastActivityDate": "2011-03-04T15:58:14.733"}, "5195624": {"ParentId": "5195512", "CommentCount": "1", "CreationDate": "2011-03-04T15:21:37.737", "OwnerUserId": "642148", "PostTypeId": "2", "Id": "5195624", "Score": "0", "Body": "<p>It's because your first <code>operator&lt;&lt;()</code> is defined outside the namespace A. </p>\n", "LastActivityDate": "2011-03-04T15:21:37.737"}, "5195512": {"CommentCount": "1", "ViewCount": "8530", "CreationDate": "2011-03-04T15:12:34.567", "LastActivityDate": "2016-07-19T06:47:05.867", "Title": "Namespaces and operator resolution", "FavoriteCount": "10", "PostTypeId": "1", "Id": "5195512", "Score": "29", "Body": "<p>I am using a library that defines output stream operators (operator&lt;&lt;) in the global namespace. In my own namespace, I was always declaring such operators in the global namespace, and never had problems with them. But now for various reasons I need to declare those operators in my own namespace, and suddenly, the compiler can't seem to find the operators declared in the library anymore.</p>\n<p>Here's a simple example that illustrates my problem: </p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace A\n{\n   struct MyClass {};\n}\n\nstd::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, const A::MyClass &amp; )\n   { os &lt;&lt; \"namespace A\"; return os; }\n\nnamespace B\n{\n   struct MyClass {};\n\n   std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, const B::MyClass &amp; )\n      { os &lt;&lt; \"namespace B\"; return os; }\n}\n\nnamespace B\n{\n   void Test()\n   {\n      std::cout &lt;&lt; A::MyClass() &lt;&lt; std::endl;\n      std::cout &lt;&lt; B::MyClass() &lt;&lt; std::endl;\n   }\n}\n\nint main()\n{\n   B::Test();\n   return 1;\n}\n</code></pre>\n<p>I am getting the following error:</p>\n<pre><code>error: no match for \u2018operator&lt;&lt;\u2019 in \u2018std::cout &lt;&lt; A::MyClass()\u2019\n</code></pre>\n<p>Note that if both operators are within the namespaces, or alternatively if they are both in the global namespace, the code compiles and executes correctly.</p>\n<p>I'd really like to understand what's going on and also what the \"good practice\" for defining such operators with namespaces.</p>\n<p>Thanks! </p>\n", "Tags": "<c++><namespaces><operator-keyword>", "OwnerUserId": "644951", "AnswerCount": "4"}, "32822359": {"ParentId": "5195512", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-09-28T11:54:03.907", "Score": "5", "LastEditorUserId": "1915854", "LastEditDate": "2016-07-19T06:47:05.867", "Id": "32822359", "OwnerUserId": "1915854", "Body": "<p>The problem has been explained in the answer by @Mark B.\nThe following solves the problem. In the namespace where you want to use the global <code>operator&lt;&lt;</code>, type the following code:</p>\n<pre><code>using ::operator&lt;&lt;;\n</code></pre>\n<p>In the OP's code example that line of code would go to the location along the other code which declares/defines <code>operator&lt;&lt;</code> for <code>namespace B</code>:</p>\n<pre><code>namespace B\n{\n   struct MyClass {};\n\n   std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, const B::MyClass &amp; )\n      { os &lt;&lt; \"namespace B\"; return os; }\n\n   using ::operator&lt;&lt;;\n}\n</code></pre>\n", "LastActivityDate": "2016-07-19T06:47:05.867"}, "bq_ids": {"n4140": {"so_5195512_5195657_1": {"section_id": 7092, "quality": 0.9714285714285714, "length": 34}, "so_5195512_5195657_0": {"section_id": 7083, "quality": 0.9310344827586207, "length": 27}}, "n3337": {"so_5195512_5195657_1": {"section_id": 6836, "quality": 0.9714285714285714, "length": 34}, "so_5195512_5195657_0": {"section_id": 6827, "quality": 0.9310344827586207, "length": 27}}, "n4659": {"so_5195512_5195657_1": {"section_id": 8593, "quality": 0.7428571428571429, "length": 26}, "so_5195512_5195657_0": {"section_id": 8584, "quality": 0.5862068965517241, "length": 17}}}});