post_cb({"22451444": {"Id": "22451444", "PostTypeId": "2", "Body": "<p>This is a language rule, in The C++ Programmin Language 4th edition, you can read:</p>\n<blockquote>\n<p id=\"so_22446891_22451444_0\">Return types are not considered in overload resolution. The reason is\n  to keep resolution for an individual operator (\u00a718.2.1, \u00a718.2.5) or\n  function call context-independent.</p>\n</blockquote>\n<p>but looking at your example its preety clear which function should be called:</p>\n<pre><code>f(); // calls (1)\nint x = f(); // calls (2)\n</code></pre>\n<p>in (1) a void version, while in (2) non void version. You can read in this answer <a href=\"https://stackoverflow.com/questions/442026/function-overloading-by-return-type\">Function overloading by return type?</a> that there are languages that allow overloading on return types.</p>\n<p>In c++ you can achive that with some tricks, like with conversion operators, the problem is with how to call function that return void type. Below is my approach to solve this (or rather abuse language rules). I dont like the fact that void version is called in destructor - I suppose it should not be allowed to throw then. Any way this is only for fun, I would never use such code. I have compiled and run it with success on VS2005,g++4.8,clang (from <a href=\"http://rextester.com/runcode\" rel=\"nofollow noreferrer\">http://rextester.com/runcode</a> - not sure which version). Also I though that return value optimization would remove all the destructor calls, but it looks like it actually is not doing this.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/6e052cc7c1bb56ca\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/6e052cc7c1bb56ca</a></p>\n<pre><code>#include&lt;iostream&gt;\n\nstruct SomeClass {\n  int nonVoidFunc() {\n    std::cout &lt;&lt; \"nonVoidFunc()\" &lt;&lt; std::endl;\n    return 0;\n  }\n  void voidFunc() {\n    std::cout &lt;&lt; \"voidFunc()\" &lt;&lt; std::endl;\n  }\n};\n\nclass Proxy {\n  SomeClass&amp; sc;\n  bool callVoid;\n\n  Proxy(Proxy&amp; p_sc) : sc(p_sc.sc), callVoid(false) { }\n  Proxy&amp; operator=(const Proxy&amp; pr) { return *this;}\npublic:\n\n  Proxy(SomeClass&amp; p_sc) : sc(p_sc), callVoid(1) {}\n  ~Proxy() {\n    if ( callVoid) sc.voidFunc();          \n  }\n\n  template&lt;typename T&gt; operator T() {\n    callVoid = false;\n    return sc.nonVoidFunc();\n  }\n\npublic:\n  Proxy func() { return *this; }\n};\n\nint main() {\n  SomeClass sc;\n  Proxy p1(sc);\n\n  int n = p1.func();  // prints nonVoidFunc()\n  (void)n; \n\n  p1.func();   // prints voidFunc()\n  return 0;\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-17T10:05:53.007", "Score": "2", "CreationDate": "2014-03-17T10:05:53.007", "ParentId": "22446891", "CommentCount": "1", "OwnerUserId": "471160", "LastEditDate": "2017-05-23T12:27:08.600"}, "22446891": {"ViewCount": "571", "Body": "<p>Is there any particular reason why C++ disallows overloading based on the presence or absence of a return-value?  Like this:</p>\n<pre><code>void f();  //(1)\nint f();  //(2)\n\nint main(){\n    f(); // calls (1)\n    int x = f(); // calls (2)\n    return x;\n}\n</code></pre>\n<p>The void-variant is called whenever the return-value is ignored, so there shouldn't be any problem with overload-resolution.  Could be useful even in the standard library, for things like <code>vector::pop_back()</code>.  So why is this not allowed?</p>\n<p><strong>Edit:</strong> It has been noted that the non-void function can be called in a void context as well.  I'm aware of this.  I just want the compiler to prefer the void function if there is one.  </p>\n", "Title": "C++ overload return void vs. non-void", "CreationDate": "2014-03-17T04:19:01.000", "LastActivityDate": "2014-03-17T10:05:53.007", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-03-17T04:31:33.917", "LastEditorUserId": "2961244", "Id": "22446891", "Score": "1", "OwnerUserId": "2961244", "Tags": "<c++><overloading>", "AnswerCount": "5"}, "22447045": {"Id": "22447045", "PostTypeId": "2", "Body": "<p>yes there is. In C++ or Java a method in any given class are recognized by the method signature, the signature here is defined as name of the method and type and number of parameters the method accepts. The return type is not part of the method signature and therefore having a method overloaded that differs only by their return type is not acceptable in these programming languages. In your example: <code> int x = f(); </code> you are assuming that the user will type <code> int x </code> however the programmer doesn't really have to do that! With the preamble I explained about method signature when the user calls <code> f() </code> there is no way for the compiler to recognize if you re calling the first one or the second one. That being said some modern programming languages allow overloading based on the return type. You can find a more thorough explanation <a href=\"https://stackoverflow.com/a/442291/2458971\">here</a> </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-17T04:34:20.007", "Score": "0", "CreationDate": "2014-03-17T04:34:20.007", "ParentId": "22446891", "CommentCount": "0", "OwnerUserId": "2458971", "LastEditDate": "2017-05-23T10:31:48.050"}, "bq_ids": {"n4140": {"so_22446891_22447103_0": {"length": 7, "quality": 1.0, "section_id": 557}}, "n3337": {"so_22446891_22447103_0": {"length": 7, "quality": 1.0, "section_id": 548}}, "n4659": {"so_22446891_22447103_0": {"length": 7, "quality": 1.0, "section_id": 580}}}, "22447103": {"Id": "22447103", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_22446891_22447103_0\">Function declarations that differ only in the return type cannot be overloaded.</p>\n</blockquote>\n<p>Your example with <code>void f()</code> and <code>int f()</code> is just a particular case of this rule.</p>\n<p>In theory there's no reason I can think of for why the C++ standard couldn't make a special exception and allow overloading between <code>void</code> and non-<code>void</code> returning functions with the same parameter list with overload resolution along the same lines as what you proposed. However, it is unlikely that such an exception would be approved unless it were deemed reasonably useful...</p>\n<p>(BTW, if you think this would be quite useful, and are prepared to defend that position, consider posting to the std-proposals mailing list.)</p>\n", "LastActivityDate": "2014-03-17T04:40:01.560", "CommentCount": "6", "CreationDate": "2014-03-17T04:40:01.560", "ParentId": "22446891", "Score": "0", "OwnerUserId": "481267"}, "22447086": {"Id": "22447086", "PostTypeId": "2", "Body": "<p>In <code>C++</code>, the return type of functions is not a part of the mangled name which is generated by the compiler for uniquely identifying each function. The  </p>\n<ul>\n<li>No. of arguments  </li>\n<li>Type of arguments</li>\n<li>Sequence of arguments   </li>\n</ul>\n<p>are the parameters which are used to generate the unique mangled name for each function. It is on the basis of these unique mangled names that compiler can understand which function to call even if the names are same (overloading).</p>\n<hr>\n<p><strong>Edit:</strong> It would be possible once name mangling have included the return type by the standard and at the same time not allowing to call a function without ignoring its return type.</p>\n</hr>", "LastEditorUserId": "2589776", "LastActivityDate": "2014-03-17T04:43:17.240", "Score": "0", "CreationDate": "2014-03-17T04:37:41.810", "ParentId": "22446891", "CommentCount": "2", "OwnerUserId": "2589776", "LastEditDate": "2014-03-17T04:43:17.240"}, "22446950": {"Id": "22446950", "PostTypeId": "2", "Body": "<p>A function that retuns a non-void type can be called in a context where the return value is ignored. For instance, the C function <code>printf()</code> has a return value of type <code>int</code>, but it's rarely used in practice.</p>\n<p>In other words, you can call the function <code>int f()</code> with:</p>\n<pre><code>f();\n</code></pre>\n<p>where the return value is ignored, only the side effect is used.</p>\n", "LastActivityDate": "2014-03-17T04:24:29.550", "CommentCount": "1", "CreationDate": "2014-03-17T04:24:29.550", "ParentId": "22446891", "Score": "2", "OwnerUserId": "1009479"}});