post_cb({"4295661": {"CommentCount": "0", "ViewCount": "1113", "CreationDate": "2010-11-28T06:18:07.770", "LastActivityDate": "2010-11-28T16:59:17.570", "Title": "How to prevent instantiation of a C++ template class method when a specific condition is met?", "AcceptedAnswerId": "4296545", "PostTypeId": "1", "Id": "4295661", "Score": "6", "Body": "<p>I'm currently writing a generic vector template class (the geometric entity, not the container) with the following signature...</p>\n<pre><code>\ntemplate&lt; typename T, unsigned N &gt;\nclass vector\n{...}\n</code></pre>\n<p>... where T is an arithmetic type and N, the dimension. I would like to define the cross product as an overload of operator ^ (located inside class definition) and enable it only when N == 3. What I've have now is:</p>\n<pre><code>\ntypename boost::lazy_enable_if_c&lt; (N == 3), vector &gt;::type\ninline operator ^(const vector &amp;rhs;) const\n{\n    vector ret;\n    ret(0) = val_[1] * rhs(2) - val_[2] * rhs(1);\n    ret(1) = val_[2] * rhs(0) - val_[0] * rhs(2);\n    ret(2) = val_[0] * rhs(1) - val_[1] * rhs(0);\n    return ret;\n}\n</code></pre>\n<p>Unfortunately, instantiating this template with N != 3, even though operator ^ isn't referenced, yields the following error:</p>\n<pre><code>\nerror: no type named \u2018type\u2019 in \u2018struct boost::lazy_enable_if_c &lt; false, flare::math::vector &lt; flare::math::fixed &lt; short int, 8u &gt;, 2u &gt; &gt;\u2019\n</code></pre>\n<p>What am I doing wrong? Is there an alternative to boost::enable_if in such case?</p>\n<p>Thank you very much.</p>\n", "Tags": "<c++><template-specialization>", "OwnerUserId": "522742", "AnswerCount": "2"}, "4295697": {"ParentId": "4295661", "CommentCount": "0", "CreationDate": "2010-11-28T06:30:08.093", "OwnerUserId": "90848", "PostTypeId": "2", "Id": "4295697", "Score": "2", "Body": "<p>I believe your problem is \"located inside class definition\". I think you'd have less trouble if you overload the operator via a function rather than via a method.</p>\n<p>I think it may also be possible to get by with just plain old specialization rather than boost magic once you switch to a function, but I'm less sure about that.</p>\n", "LastActivityDate": "2010-11-28T06:30:08.093"}, "bq_ids": {"n4140": {"so_4295661_4296545_0": {"section_id": 233, "quality": 0.9259259259259259, "length": 50}}, "n3337": {"so_4295661_4296545_0": {"section_id": 226, "quality": 0.9259259259259259, "length": 50}}, "n4659": {"so_4295661_4296545_0": {"section_id": 242, "quality": 0.6481481481481481, "length": 35}}}, "4296545": {"ParentId": "4295661", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-11-28T11:37:57.203", "Score": "4", "LastEditorUserId": "47984", "LastEditDate": "2010-11-28T16:59:17.570", "Id": "4296545", "OwnerUserId": "47984", "Body": "<p>The proximal cause of the error message is that, according to <a href=\"http://www.boost.org/doc/libs/1_45_0/libs/utility/enable_if.html\" rel=\"nofollow\">the docs</a>, \"The second argument of <code>lazy_enable_if</code> must be a class type that defines a nested type named <code>type</code> whenever the first parameter (the condition) is true.\"  That's clearly not satisfied here (unless your <code>vector</code> type just happens to contain <code>typedef something type;</code>).</p>\n<p>You don't need <code>lazy_...</code> here.  According to the docs, that's only needed if the 2nd arg could be undefined (e.g. if the 2nd arg was <code>typename foo&lt;T&gt;::bar</code>, and the <code>bar</code> type is not defined for all types <code>T</code>).  <code>vector</code> (which here means <code>vector&lt;T, N&gt;</code>) will always be defined.</p>\n<p>So definitely try getting rid of <code>lazy_</code>, or alternatively create a do-nothing traits class <code>template &lt;typename T&gt; struct nop { typedef T type; };</code> and replace the 2nd arg to <code>lazy_enable_if_c</code> with <code>nop&lt;vector&gt;</code>.  But my guess is you've already tried the former at least. :)</p>\n<p><strong>And now I see why that won't work.</strong>  According to the standard 14.7.1/1:</p>\n<blockquote>\n<p id=\"so_4295661_4296545_0\">Unless  a  class  template \n  specialization  has  been  explicitly \n  instantiated  (14.7.2)  or  explicitly\n  specialized (14.7.3), the class\n  template specialization is implicitly\n  instantiated when the specialization\n  is referenced in a context that\n  requires a completely-defined object\n  type or when the completeness of the\n  class type affects the semantics of\n  the program.  The implicit\n  instantiation of a class template\n  specialization causes the implicit\n  instantiation of the declarations, but\n  not of the definitions or default\n  arguments, of the class member\n  functions, member classes, static data\n  members and member templates;</p>\n</blockquote>\n<p>So anything that causes the class to be instantiated will try to instantiate declarations for all methods, which will fail when <code>N != 3</code>.  So it looks like you'll need to use an always-present method that hands off to a function template instead.  Don't worry, any decent compiler will still be able to inline through this:</p>\n<pre><code>template&lt; typename T, unsigned N &gt; class vector;   // Fwd decl.\n\ntemplate&lt; typename T, unsigned N &gt;\ninline boost::enable_if_c&lt; (N == 3), vector&lt;T, N&gt; &gt;::type\nmagic(const vector&lt;T, N&gt;&amp; lhs, const vector&lt;T, N&gt;&amp; rhs) {\n    /* Do the calculation as before... */\n    return ret;\n}\n\ntemplate&lt; typename T, unsigned N &gt;\nclass vector {\n    ...\n    inline vector operator ^(const vector &amp;rhs) const {\n        return magic(*this, rhs);\n    }\n};\n</code></pre>\n<p>This will work because the member function <em>definitions</em> are not instantiated unless they are actually called (or their addresses are taken etc.).</p>\n", "LastActivityDate": "2010-11-28T16:59:17.570"}});