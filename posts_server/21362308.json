post_cb({"bq_ids": {"n4140": {"so_21362308_21365420_0": {"length": 89, "quality": 0.9368421052631579, "section_id": 5994}}, "n3337": {"so_21362308_21365420_0": {"length": 89, "quality": 0.9368421052631579, "section_id": 5762}}, "n4659": {"so_21362308_21365420_0": {"length": 80, "quality": 0.8421052631578947, "section_id": 7496}}}, "21365420": {"Id": "21365420", "PostTypeId": "2", "Body": "<p>The sane thing here would be to use the three functions you have directly. If you absolutely must have the syntax:</p>\n<pre><code>fill(Solid, Brush(1.0, 0.0, 0.0));\nfill(Gradient1, Color(1.0, 0.0, 0.0), Color(1.0, 1.0, 0.0));\nfill(Gradient2, Color(1.0, 0.0, 0.0), Color(1.0, 1.0, 0.0));\n</code></pre>\n<p>You can get it from two overloads:</p>\n<pre><code>void fill(TypeFill t, Brush b) {\n    assert(t == Solid);\n    fillSolid(b);\n}\n\nvoid fill(TypeFill t, Color c1,  Color c2) {\n  switch(t) {\n  case Gradient1:\n    fillGradient1(c1, c2);\n    break;\n  case Gradient2:\n    fillGradient2(c1, c2);\n    break;\n  default:\n    assert(false);\n    break;\n  }\n}\n</code></pre>\n<p>and if you want a single function badly enough to throw out type-safety along with any possibility of debugging errors, you can use C-style varargs:</p>\n<pre><code>void fill(TypeFill t, ...) {\n  va_list ap;\n  va_start(ap, t);\n  switch(t) {\n  case Gradient1:\n    fillGradient1(va_arg(ap, Color), va_arg(ap, Color));\n    break;\n  case Gradient2:\n    fillGradient2(va_arg(ap, Color), va_arg(ap, Color));\n    break;\n  case Solid:\n    fillSolid(va_arg(ap, Brush));\n    break;\n  default:\n    assert(false);\n    break;\n  }\n  va_end(ap);\n}\n</code></pre>\n<p>Be careful that you do not fall afoul of the <code>va_arg</code> requirements as detailed in C++11 \u00a75.2.2/7:</p>\n<blockquote>\n<p id=\"so_21362308_21365420_0\">When there is no parameter for a given argument, the argument is passed in such a way that the receiving function can obtain the value of the argument by invoking <code>va_arg</code> (18.10). The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the argument expression. An argument that has (possibly cv-qualified) type <code>std::nullptr_t</code> is converted to type <code>void*</code> (4.10). After these conversions, if the argument does not have arithmetic, enumeration, pointer, pointer to member, or class type, the program is ill-formed. Passing a potentially-evaluated argument of class type (Clause 9) having a nontrivial copy constructor, a non-trivial move contructor, or a non-trivial destructor, with no corresponding parameter, is conditionally-supported with implementation-defined semantics. If the argument has integral or enumeration type that is subject to the integral promotions (4.5), or a floating point type that is subject to the floating point promotion (4.6), the value of the argument is converted to the promoted type before the call. These promotions are referred to as the <em>default argument promotions</em>.</p>\n</blockquote>\n", "LastActivityDate": "2014-01-26T15:40:13.377", "Score": "0", "CreationDate": "2014-01-26T15:40:13.377", "ParentId": "21362308", "CommentCount": "0", "OwnerUserId": "923854"}, "21362368": {"Id": "21362368", "PostTypeId": "2", "Body": "<p>It boils down to having several overloads, so the simplest way would be to define:</p>\n<ul>\n<li><code>fillSolid(Brush b)</code></li>\n<li><code>fillGradient(Color c1, Color c2)</code></li>\n</ul>\n<p>In this design you'd need the enum value to be known at compile time anyway in each particular call, so there's not much to gain.</p>\n<p>OTOH you'd probably want to redesign your code so that instead of an enum you'd have an actual abstraction for <code>Fill</code> with different implementations like <code>Solid</code>, <code>Gradient1</code>, <code>Gradient2</code>, etc, each with its own data set.</p>\n<hr>\n<p>Follow-up: This is an example of a syntax that you COULD get with templates:</p>\n<pre><code>fill&lt;Solid&gt;::call(Brush(1.0, 0.0, 0.0));               \nfill&lt;Gradient1&gt;::call(Color(1.0, 0.0, 0.0), Color(1.0, 1.0, 0.0));\nfill&lt;Gradient2&gt;::call(Color(1.0, 0.0, 0.0), Color(1.0, 1.0, 0.0));\n</code></pre>\n<p>The enumerator now is a class template parameter, not a function argument, so it's resolved at compile-time and the (member) function signature is able to depend on it.</p>\n</hr>", "LastEditorUserId": "399317", "LastActivityDate": "2014-01-26T12:20:09.053", "Score": "2", "CreationDate": "2014-01-26T10:38:36.380", "ParentId": "21362308", "CommentCount": "13", "OwnerUserId": "399317", "LastEditDate": "2014-01-26T12:20:09.053"}, "21362308": {"ViewCount": "184", "Body": "<p>Is it possible to somehow make functions (C++11) which will accept different parameters depending on the first one?\nLets say, I need the following behavior:</p>\n<pre><code>enum TypeFill{Solid, Gradient1, Gradient2};\n\nvoid fill(const TypeFill t,  Type1 param1 = NULL, Type2 param2 = NULL){\n  if (t == Solid){\n       fillSolid(param1);\n  } else if (t == Gradient1){\n       fillGradient1(param1, param2);\n  } else if (t == Gradient2){\n       fillGradient2(param1, param2);\n  }\n}\n\nprivate:\nfillSolid(Brush b){};                \nfillGradient1(Color c1, Color c2){};\nfillGradient2(Color c1, Color c2){};\n</code></pre>\n<p>Call example:</p>\n<pre><code>fill(Solid, Brush(1.0, 0.0, 0.0)){};                \nfill(Gradient1, Color(1.0, 0.0, 0.0), Color(1.0, 1.0, 0.0)){};\nfill(Gradient2, Color(1.0, 0.0, 0.0), Color(1.0, 1.0, 0.0)){};\n</code></pre>\n<p>Just wonder if this possible. I feel that may be something possible to do with enable_if and template specializations, but may be not...</p>\n", "AcceptedAnswerId": "21365420", "Title": "C++11 function parameters", "CreationDate": "2014-01-26T10:30:59.490", "Id": "21362308", "CommentCount": "6", "LastEditDate": "2014-01-26T11:19:35.717", "PostTypeId": "1", "LastEditorUserId": "1559666", "LastActivityDate": "2014-01-26T15:40:13.377", "Score": "0", "OwnerUserId": "1559666", "Tags": "<c++><templates><c++11><sfinae><enable-if>", "AnswerCount": "2"}});