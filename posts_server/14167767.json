post_cb({"14185300": {"Id": "14185300", "PostTypeId": "2", "Body": "<p>Several pertinent references:</p>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">the C++11 draft standard</a> (PDF, see clauses 1, 29 and 30);</li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2480.html\" rel=\"nofollow noreferrer\">Hans-J. Boehm's overview of concurrency in C++</a>;</li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2664.htm\" rel=\"nofollow noreferrer\">McKenney, Boehm and Crowl on concurrency in C++</a>;</li>\n<li><a href=\"http://gcc.gnu.org/wiki/Atomic/GCCMM\" rel=\"nofollow noreferrer\">GCC's developmental notes on concurrency in C++</a>;</li>\n<li><a href=\"http://www.kernel.org/doc/Documentation/memory-barriers.txt\" rel=\"nofollow noreferrer\">the Linux kernel's notes on concurrency</a>;</li>\n<li><a href=\"https://stackoverflow.com/q/12346487/1275653\">a related question with answers here on Stackoverflow</a>;</li>\n<li><a href=\"https://stackoverflow.com/q/14161049/1275653\">another related question with answers</a>;</li>\n<li><a href=\"http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/index.html\" rel=\"nofollow noreferrer\">Cppmem,</a> a sandbox in which to experiment with concurrency;</li>\n<li><a href=\"http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/help.html\" rel=\"nofollow noreferrer\">Cppmem's help page</a>;</li>\n<li><a href=\"http://spinroot.com/spin/Man/Manual.html\" rel=\"nofollow noreferrer\">Spin,</a> a tool for analyzing the logical consistency of concurrent systems;</li>\n<li><a href=\"http://irl.cs.ucla.edu/~yingdi/web/paperreading/whymb.2010.06.07c.pdf\" rel=\"nofollow noreferrer\">an overview of memory barriers from a hardware perspective</a> (PDF).</li>\n</ul>\n<p>Some of the above may interest you and other readers.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-01-07T16:44:36.037", "Score": "10", "CreationDate": "2013-01-06T18:25:53.547", "ParentId": "14167767", "CommentCount": "3", "OwnerUserId": "1275653", "LastEditDate": "2017-05-23T12:17:43.453"}, "43390924": {"Id": "43390924", "PostTypeId": "2", "Body": "<p>The race in the first example is between the publication of the pointer, and the stuff that it points to. The reason is, that you have the creation and initialization of the pointer <strong>after</strong> the fence (= on the same side as the publication of the pointer):</p>\n<pre><code>int* ptr;    //noop\nstd::atomic_thread_fence(std::memory_order_release);    //fence between noop and interesting stuff\nptr = new int(-4);    //object creation, initalization, and publication\n</code></pre>\n<p><strong>If we assume that CPU accesses to properly aligned pointers are atomic</strong>, the code can be corrected by writing this:</p>\n<pre><code>int* ptr;    //noop\nint* newPtr = new int(-4);    //object creation &amp; initalization\nstd::atomic_thread_fence(std::memory_order_release);    //fence between initialization and publication\nptr = newPtr;    //publication\n</code></pre>\n<p>Note that even though this may work fine on many machines, there is absolutely no guarantee within the C++ standard on the atomicity of the last line. So better use <code>atomic&lt;&gt;</code> variables in the first place.</p>\n", "LastActivityDate": "2017-04-13T11:22:50.500", "CommentCount": "0", "CreationDate": "2017-04-13T11:22:50.500", "ParentId": "14167767", "Score": "0", "OwnerUserId": "2445184"}, "14183048": {"Id": "14183048", "PostTypeId": "2", "Body": "<p>I believe the code has a race. Case 1 and case 2 are not equivalent.</p>\n<p><strong>29.8 [atomics.fences]</strong></p>\n<blockquote>\n<p id=\"so_14167767_14183048_0\">-2- A release fence <em>A</em> synchronizes with an acquire fence <em>B</em> if there exist atomic operations <em>X</em> and <em>Y</em>, both operating on some atomic object <em>M</em>, such that <em>A</em> is sequenced before <em>X</em>, <em>X</em> modifies <em>M</em>, <em>Y</em> is sequenced before <em>B</em>, and <em>Y</em> reads the value written by <em>X</em> or a value written by any side effect in the hypothetical release sequence <em>X</em> would head if it were a release operation.</p>\n</blockquote>\n<p>In case 1 your release fence does not synchronize with your acquire fence because <code>ptr</code> is not an atomic object and the store and load on <code>ptr</code> are not atomic operations.</p>\n<p>Case 2 and case 3 are equivalent (<strong>actually, not quite, see LWimsey's comments and answer</strong>), because <code>ptr</code> is an atomic object and the store is an atomic operation. (Paragraphs 3 and 4 of [atomic.fences] describe how a fence synchronizes with an atomic operation and vice versa.)</p>\n<p>The semantics of fences are defined only with respect to atomic objects and atomic operations. Whether your target platform and your implementation offer stronger guarantees (such as treating any pointer type as an atomic object) is implementation-defined at best.</p>\n<p>N.B. for both of case 2 and case 3 the acquire operation on <code>ptr</code> could happen before the store, and so would read garbage from the uninitialized <code>atomic&lt;int*&gt;</code>. Simply using acquire and release operations (or fences) doesn't ensure that the store happens before the load, it only ensures that <em>if</em> the load reads the stored value then the code is correctly synchronized.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2017-04-16T21:07:54.840", "Score": "10", "CreationDate": "2013-01-06T14:26:03.757", "ParentId": "14167767", "CommentCount": "10", "OwnerUserId": "981959", "LastEditDate": "2017-04-16T21:07:54.840"}, "18584591": {"Id": "18584591", "PostTypeId": "2", "Body": "<p>The memory backing an atomic variable can only ever be used for the contents of the atomic.  However, a plain variable, like ptr in case 1, is a different story.  Once a compiler has the right to write to it, it can write anything to it, even the value of a temporary value when you run out of registers.</p>\n<p>Remember, your example is pathologically clean.  Given a slightly more complex example:</p>\n<pre><code>std::string* p  = new std::string(\"Hello\");\ndata($) = 42;\nrl::atomic_thread_fence(rl::memory_order_release);\nstd::string* p2 = new std::string(\"Bye\");\nptr($) = p;\n</code></pre>\n<p>it is totally legal for the compiler to choose to reuse your pointer</p>\n<pre><code>std::string* p  = new std::string(\"Hello\");\ndata($) = 42;\nrl::atomic_thread_fence(rl::memory_order_release);\nptr($) = new std::string(\"Bye\");\nstd::string* p2 = ptr($);\nptr($) = p;\n</code></pre>\n<p>Why would it do so?  I don't know, perhaps some exotic trick to keep a cache line or something.  The point is that, since ptr is not atomic in case 1, there is a race case between the write on line 'ptr($) = p' and the read on 'std::string* p2 = ptr($)', yielding undefined behavior.  In this simple test case, the compiler may not choose to exercise this right, and it may be safe, but in more complicated cases the compiler has the right to abuse ptr however it pleases, and Relacy catches this.</p>\n<p>My favorite article on the topic: <a href=\"http://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong\" rel=\"nofollow\">http://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong</a></p>\n", "LastActivityDate": "2013-09-03T05:18:57.797", "CommentCount": "1", "CreationDate": "2013-09-03T05:18:57.797", "ParentId": "14167767", "Score": "1", "OwnerUserId": "2728148"}, "bq_ids": {"n4140": {"so_14167767_14183048_0": {"length": 35, "quality": 1.0, "section_id": 1227}}, "n3337": {"so_14167767_14183048_0": {"length": 35, "quality": 1.0, "section_id": 1225}}, "n4659": {"so_14167767_14183048_0": {"length": 35, "quality": 1.0, "section_id": 1316}}}, "43429224": {"Id": "43429224", "PostTypeId": "2", "Body": "<p>Although various answers cover bits and pieces of what the potential problem is and/or provide useful information, no answer correctly describes the potential issues for all three cases.  </p>\n<p>In order to synchronize memory operations between threads, release and acquire barriers are used to specify ordering.<br>\nIn the diagram, memory operations A in thread 1 cannot move down across the (one-way) release barrier (regardless whether that is a release operation on an atomic store,\nor a standalone release fence followed by a relaxed atomic store). Hence memory operations A are guaranteed to happen before the atomic store.\nSame goes for memory operations B in thread 2 which cannot move up across the acquire barrier; hence the atomic load happens before memory operations B.</br></p>\n<p><a href=\"https://i.stack.imgur.com/DjEtX.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/DjEtX.png\"/></a></p>\n<p>The atomic <code>ptr</code> itself provides inter-thread ordering based on the guarantee that it has a single modification order. As soon as thread 2 sees a value for <code>ptr</code>, \nit is guaranteed that the store (and thus memory operations A) happened before the load. Because the load is guaranteed to happen before memory operations B, \nthe rules for transitivity say that memory operations A happen before B and synchronization is complete.</p>\n<p>With that, let's look at your 3 cases.</p>\n<p><strong>Case 1 is broken</strong> because <code>ptr</code>, a non-atomic type, is modified in different threads. That is a classical example of a data race and it causes undefined behavior.</p>\n<p><strong>Case 2 is correct.</strong> As an argument, the integer allocation with <code>new</code> is sequenced before the release operation. This is equivalent to:</p>\n<pre><code>// Case 2: atomic var, automatic fence\nstd::atomic&lt;int*&gt; ptr;\n// ...\nint *tmp = new int(-4);\nptr.store(tmp, std::memory_order_release);\n</code></pre>\n<p><strong>Case 3 is broken</strong>, albeit in a subtle way. The problem is that even though the <code>ptr</code> assignment is correctly sequenced after the standalone fence,\nthe integer allocation (<code>new</code>) is also sequenced after the fence, causing a data race on the integer memory location.</p>\n<p>the code is equivalent to:</p>\n<pre><code>// Case 3: atomic var, manual fence\nstd::atomic&lt;int*&gt; ptr;\n// ...\nstd::atomic_thread_fence(std::memory_order_release);\n\nint *tmp = new int(-4);\nptr.store(tmp, std::memory_order_relaxed);\n</code></pre>\n<p>If you map that to the diagram above, the <code>new</code> operator is supposed to be part of memory operations A. Being sequenced below the release fence,\nordering guarantees no longer hold and the integer allocation may actually be reordered with memory operations B in thread 2.\nTherefore, a <code>load()</code> in thread 2 may return garbage or cause other undefined behavior.</p>\n", "LastEditorUserId": "6651824", "LastActivityDate": "2017-04-15T17:44:26.347", "Score": "3", "CreationDate": "2017-04-15T17:38:52.557", "ParentId": "14167767", "CommentCount": "1", "OwnerUserId": "6651824", "LastEditDate": "2017-04-15T17:44:26.347"}, "14167767": {"ViewCount": "5673", "Body": "<p>Assuming that aligned pointer loads and stores are naturally atomic on the target platform, what is the difference between this:</p>\n<pre><code>// Case 1: Dumb pointer, manual fence\nint* ptr;\n// ...\nstd::atomic_thread_fence(std::memory_order_release);\nptr = new int(-4);\n</code></pre>\n<p>this:</p>\n<pre><code>// Case 2: atomic var, automatic fence\nstd::atomic&lt;int*&gt; ptr;\n// ...\nptr.store(new int(-4), std::memory_order_release);\n</code></pre>\n<p>and this:</p>\n<pre><code>// Case 3: atomic var, manual fence\nstd::atomic&lt;int*&gt; ptr;\n// ...\nstd::atomic_thread_fence(std::memory_order_release);\nptr.store(new int(-4), std::memory_order_relaxed);\n</code></pre>\n<p>I was under the impression that they were all equivalent, however <a href=\"http://www.1024cores.net/home/relacy-race-detector\" rel=\"noreferrer\">Relacy</a> detects a data race in\nthe first case (only):</p>\n<pre><code>struct test_relacy_behaviour : public rl::test_suite&lt;test_relacy_behaviour, 2&gt;\n{\n    rl::var&lt;std::string*&gt; ptr;\n    rl::var&lt;int&gt; data;\n\n    void before()\n    {\n        ptr($) = nullptr;\n        rl::atomic_thread_fence(rl::memory_order_seq_cst);\n    }\n\n    void thread(unsigned int id)\n    {\n        if (id == 0) {\n            std::string* p  = new std::string(\"Hello\");\n            data($) = 42;\n            rl::atomic_thread_fence(rl::memory_order_release);\n            ptr($) = p;\n        }\n        else {\n            std::string* p2 = ptr($);        // &lt;-- Test fails here after the first thread completely finishes executing (no contention)\n            rl::atomic_thread_fence(rl::memory_order_acquire);\n\n            RL_ASSERT(!p2 || *p2 == \"Hello\" &amp;&amp; data($) == 42);\n        }\n    }\n\n    void after()\n    {\n        delete ptr($);\n    }\n};\n</code></pre>\n<p>I contacted the author of Relacy to find out if this was expected behaviour; he says that there is indeed a data race in my test case.\nHowever, I'm having trouble spotting it; can someone point out to me what the race is?\nMost importantly, what are the differences between these three cases?</p>\n<p><strong>Update</strong>: It's occurred to me that Relacy may simply be complaining about the <em>atomicity</em> (or lack thereof, rather) of the variable being accessed across threads... after all, it doesn't know that I <em>intend</em> only to use this code on platforms where aligned integer/pointer access is naturally atomic.</p>\n<p><strong>Another update</strong>: Jeff Preshing has written an excellent blog post <a href=\"http://preshing.com/20131125/acquire-and-release-fences-dont-work-the-way-youd-expect/\" rel=\"noreferrer\">explaining the difference between explicit fences and the built-in ones</a> (\"fences\" vs \"operations\"). Cases 2 and 3 are apparently not equivalent! (In certain subtle circumstances, anyway.)</p>\n", "AcceptedAnswerId": "14183048", "Title": "What is the difference between using explicit fences and std::atomic?", "CreationDate": "2013-01-05T01:58:35.983", "Id": "14167767", "CommentCount": "9", "FavoriteCount": "13", "PostTypeId": "1", "LastEditDate": "2014-01-28T02:42:23.053", "LastEditorUserId": "21475", "LastActivityDate": "2017-04-16T21:07:54.840", "Score": "22", "OwnerUserId": "21475", "Tags": "<c++><c++11><atomic><memory-fences>", "AnswerCount": "5"}});