post_cb({"bq_ids": {"n4140": {"so_14815998_14815999_1": {"length": 15, "quality": 1.0, "section_id": 4710}, "so_14815998_14815999_3": {"length": 37, "quality": 0.8809523809523809, "section_id": 4710}, "so_14815998_14815999_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 4710}, "so_14815998_14815999_0": {"length": 4, "quality": 1.0, "section_id": 4710}}, "n3337": {"so_14815998_14815999_1": {"length": 15, "quality": 1.0, "section_id": 4518}, "so_14815998_14815999_3": {"length": 37, "quality": 0.8809523809523809, "section_id": 4518}, "so_14815998_14815999_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 4518}, "so_14815998_14815999_0": {"length": 4, "quality": 1.0, "section_id": 4518}}, "n4659": {"so_14815998_14815999_1": {"length": 15, "quality": 1.0, "section_id": 6107}, "so_14815998_14815999_3": {"length": 37, "quality": 0.8809523809523809, "section_id": 6107}, "so_14815998_14815999_2": {"length": 5, "quality": 0.5555555555555556, "section_id": 6107}}}, "14820170": {"Id": "14820170", "PostTypeId": "2", "Body": "<p><code>foo2</code> is your <code>foo</code>.  <code>foo1</code> is a foo that does what you want your <code>foo</code> to do.</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n\nstruct foo1 {\n  template&lt;typename T,typename=typename std::enable_if&lt; !std::is_same&lt;int, T&gt;::value &gt;::type&gt;\n  foo1(T) {\n    static_assert(not std::is_same&lt;int, T&gt;(), \"no ints please\");\n  }\n};\nstruct foo2 {\n  template&lt;typename T&gt;\n  foo2(T) {\n    static_assert(not std::is_same&lt;int, T&gt;(), \"no ints please\");\n  }\n};\n\n#include &lt;iostream&gt;    \nint main() {\n  std::cout &lt;&lt; std::is_constructible&lt;foo1, int&gt;();\n  std::cout &lt;&lt; std::is_constructible&lt;foo2, int&gt;();\n}\n</code></pre>\n", "LastActivityDate": "2013-02-11T20:22:11.947", "CommentCount": "1", "CreationDate": "2013-02-11T20:22:11.947", "ParentId": "14815998", "Score": "5", "OwnerUserId": "1774667"}, "14815998": {"ViewCount": "1276", "Body": "<p>The following program, when compiled with either GCC 4.7 and clang 3.2, produces \"1\" as output.</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct foo {\n    template&lt;typename T&gt;\n    foo(T) {\n        static_assert(not std::is_same&lt;int, T&gt;(), \"no ints please\");\n    }\n};\n\n#include &lt;iostream&gt;    \nint main() {\n    std::cout &lt;&lt; std::is_constructible&lt;foo, int&gt;();\n}\n</code></pre>\n<p>This is confusing. <code>foo</code> is quite clearly not constructible from <code>int</code>! If I change <code>main</code> to the following, both compilers reject it due to the static assertion failing:</p>\n<pre><code>int main() {\n    foo(0);\n}\n</code></pre>\n<p>How come both compilers say it is constructible?</p>\n", "AcceptedAnswerId": "14815999", "Title": "Why does is_constructible claim something is constructible when it isn't?", "CreationDate": "2013-02-11T16:06:45.040", "Id": "14815998", "CommentCount": "1", "LastEditDate": "2015-08-21T14:28:10.640", "PostTypeId": "1", "LastEditorUserId": "1774667", "LastActivityDate": "2015-08-21T14:28:10.640", "Score": "13", "OwnerUserId": "46642", "Tags": "<c++><templates><c++11><constructor><typetraits>", "AnswerCount": "2"}, "14815999": {"Id": "14815999", "PostTypeId": "2", "Body": "<p>This is what the standard has to say (\u00a720.9.5/6), with my emphasis: </p>\n<blockquote>\n<p id=\"so_14815998_14815999_0\">Given the following function prototype:</p>\n<pre><code>template &lt;class T&gt;\ntypename add_rvalue_reference&lt;T&gt;::type create();\n</code></pre>\n<p id=\"so_14815998_14815999_1\">the predicate condition for a template specialization\n  <code>is_constructible&lt;T, Args...&gt;</code> shall be satisfied if and only if the\n  following variable definition would be well-formed for some invented\n  variable <code>t</code>:</p>\n<pre><code>T t(create&lt;Args&gt;()...);\n</code></pre>\n<p id=\"so_14815998_14815999_2\">[ <em>Note:</em> These tokens are never interpreted as a function\n  declaration. <em>\u2014end note</em> ] </p>\n<p id=\"so_14815998_14815999_3\">Access checking is performed as if in a context unrelated to <code>T</code> and\n  any of the <code>Args</code>. <strong>Only the validity of the immediate context of the\n  variable initialization is considered.</strong> [ <em>Note:</em> The evaluation of the\n  initialization can result in side effects such as the instantiation of\n  class template specializations and function template specializations,\n  the generation of implicitly-defined functions, and so on. Such side\n  effects are not in the \u201cimmediate context\u201d and can result in the\n  program being ill-formed. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>The assertion only fails when the template constructor is instantiated. However, as cleared up in the note, that assertion is not in the immediate context of the variable definition that is considered, and thus does not affect its \"validity\". So the compilers can count that definition as valid, and thus claim that <code>foo</code> is indeed constructible from <code>int</code>, even if actually attempting to construct a <code>foo</code> from an <code>int</code> results in an ill-formed program.</p>\n<p>Note that the compilers are also allowed to, instead of having <code>is_constructible</code> yield false, just reject the original program based on the assertion, even though neither one does.</p>\n", "LastActivityDate": "2013-02-11T16:06:45.040", "CommentCount": "1", "CreationDate": "2013-02-11T16:06:45.040", "ParentId": "14815998", "Score": "21", "OwnerUserId": "46642"}});