post_cb({"5380358": {"ViewCount": "603", "Body": "<p>My question sounds like a contradiction, but I don't know how else to refer to the new literal syntax other than <code>user-defined-literal</code>.</p>\n<pre><code>std::string operator \"\" s ( const char* str, size_t len )\n{\n   return std::string( str, len );\n}\n\nassert( \"foo\"s == \"bar\"s );\n</code></pre>\n<p>I remember hearing that user defined literals should start with an <code>_</code> prefix.  That would imply that the library defines some non-prefixed literals for us.</p>\n<p>Does the standard provide some UDLs in the the standard library?<br>\nIf yes, what are they?</br></p>\n", "AcceptedAnswerId": "5380507", "Title": "Which user-defined-literals are predefined by the standard?", "CreationDate": "2011-03-21T16:10:46.080", "Id": "5380358", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2011-12-19T00:01:33.297", "LastEditorUserId": "500104", "LastActivityDate": "2011-12-19T00:01:33.297", "Score": "10", "OwnerUserId": "28817", "Tags": "<c++><c++11><user-defined-literals>", "AnswerCount": "4"}, "5380507": {"Id": "5380507", "PostTypeId": "2", "Body": "<p>The language already use regular literals suffixes, for example <code>1U</code>.</p>\n<p>It would become ambiguous if you were to use <code>U</code> as a user-defined-literal, thus the recommendation.</p>\n<p><em>integer-suffix</em>: <code>u</code>, <code>U</code>, <code>l</code>, <code>L</code>, <code>ll</code>, <code>LL</code></p>\n<p><em>floating-suffix</em>: <code>f</code>, <code>F</code>, <code>l</code>, <code>L</code></p>\n", "LastEditorUserId": "147192", "LastActivityDate": "2011-03-21T16:49:13.157", "Score": "5", "CreationDate": "2011-03-21T16:23:07.147", "ParentId": "5380358", "CommentCount": "0", "OwnerUserId": "147192", "LastEditDate": "2011-03-21T16:49:13.157"}, "5684246": {"Id": "5684246", "PostTypeId": "2", "Body": "<p>In contrast to @Matthieu's answer, the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3290.pdf\" rel=\"nofollow\">FIDS</a> says the following under 2.14.8 [lex.ext] p1:</p>\n<blockquote>\n<p id=\"so_5380358_5684246_0\">If a token matches both <em>user-defined-literal</em> and another literal kind, it is treated as the latter.<br>\n  [ <em>Example:</em>\n<strong>123_km</strong> is a <em>user-defined-literal</em>, but <strong>12LL</strong> is an <em>integer-literal</em>. \u2014 <em>end example</em> ]</br></p>\n</blockquote>\n<p>So even if you define those literals, the predefined ones are taken and there is no ambiguity.</p>\n", "LastActivityDate": "2011-04-16T03:12:16.890", "CommentCount": "0", "CreationDate": "2011-04-16T03:12:16.890", "ParentId": "5380358", "Score": "2", "OwnerUserId": "500104"}, "5380880": {"Id": "5380880", "PostTypeId": "2", "Body": "<p>The standard library actually defines <strong>no</strong> user defined literals. We would perhaps have expected complex numbers, but no.</p>\n<p>On the other hand, there is also a proposal to remove them again</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3250.html\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3250.html</a></p>\n<p>so we don't yet know what happens.</p>\n", "LastActivityDate": "2011-03-21T16:51:34.610", "CommentCount": "1", "CreationDate": "2011-03-21T16:51:34.610", "ParentId": "5380358", "Score": "6", "OwnerUserId": "597607"}, "bq_ids": {"n4140": {"so_5380358_5684246_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 5367}}, "n3337": {"so_5380358_5684246_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 5163}}, "n4659": {"so_5380358_5684246_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 6792}}}, "7906741": {"Id": "7906741", "PostTypeId": "2", "Body": "<p>No standard library components have staked a claim on a user-defined literal.  @Bo mentioned complex as a possibility.</p>\n<p>Another is bitset:</p>\n<pre><code>template&lt;char... Bits&gt;\n  inline constexpr std::bitset&lt;sizeof...(Bits)&gt;\n  operator\"\" bits()\n  {\n    return std::bitset&lt;sizeof...(Bits)&gt;((char []){Bits..., '\\0'});\n  }\n</code></pre>\n<p>I predict there will be proposals for literal operators for various library components in the upcoming library TR2 enhancements.</p>\n<p>I anticipate some collisions over the suffix namespace.  You can declare literal operators in a namespace and prevent multiple ambiguous definitions but you can't distinguish the actual suffixes by namespace in an actual literal.  We'll see.</p>\n", "LastEditorUserId": "680359", "LastActivityDate": "2011-10-27T02:33:04.407", "Score": "1", "CreationDate": "2011-10-26T17:51:59.550", "ParentId": "5380358", "CommentCount": "1", "OwnerUserId": "680359", "LastEditDate": "2011-10-27T02:33:04.407"}});