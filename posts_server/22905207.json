post_cb({"22905207": {"ViewCount": "1661", "Body": "<p>Learning C++ multi-threading.<br>\nIn my example, thread <code>helper1</code> and <code>helper2</code> have finished executing before the <code>main</code> thread finished. However, program crashes. I specifically, took out <code>.join()</code> statements, to see how program would behave, expecting no errors, since <code>main()</code> calls <code>std::terminate</code> after two other threads have finished.</br></p>\n<pre><code>void foo()\n{\n    // simulate expensive operation\n    std::this_thread::sleep_for(std::chrono::seconds(5));\n    std::cout &lt;&lt; \"t1\\n\";\n}\n\nvoid bar()\n{\n    // simulate expensive operation\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::cout &lt;&lt; \"t2\\n\";\n}\n\nint main()\n{\n\n    std::cout &lt;&lt; \"starting first helper...\\n\";\n    std::thread helper1(foo);\n\n    std::cout &lt;&lt; \"starting second helper...\\n\";\n    std::thread helper2(bar);\n\n\n    std::this_thread::sleep_for(std::chrono::seconds(10));\n\n    std::cout &lt;&lt; \"waiting for helpers to finish...\" &lt;&lt; std::endl;\n    //helper1.join();\n    //helper2.join();\n\n    std::cout &lt;&lt; \"done!\\n\";\n}\n</code></pre>\n", "AcceptedAnswerId": "22905440", "Title": "Why .join is still necessary when all other thread have finished before the main thread?", "CreationDate": "2014-04-07T06:38:59.273", "Id": "22905207", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-04-07T06:54:39.767", "Score": "5", "OwnerUserId": "465292", "Tags": "<c++><multithreading>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_22905207_22905277_0": {"length": 37, "quality": 0.925, "section_id": 2717}}, "n3337": {"so_22905207_22905277_0": {"length": 37, "quality": 0.925, "section_id": 2678}}, "n4659": {"so_22905207_22905277_0": {"length": 35, "quality": 0.875, "section_id": 3457}}}, "22905440": {"Id": "22905440", "PostTypeId": "2", "Body": "<p>I'd say that your question doesn't make sense, because it's based on a false assumption. The only way to know <em>that</em> a thread has finished is when the thread's <code>join()</code> returns. Before <code>join()</code> returns, it is not the case that \"the thread has finished\". It may be true that some statement within the thread's execution has completed (e.g. the printing of a message, or better, the writing of an atomic variable), but the completion of the thread function itself is not <em>measurable</em> in any way other than by joining.</p>\n<p>So <em>none</em> of the threads \"have finished\" until you join them.</p>\n", "LastActivityDate": "2014-04-07T06:54:39.767", "CommentCount": "2", "CreationDate": "2014-04-07T06:54:39.767", "ParentId": "22905207", "Score": "5", "OwnerUserId": "596781"}, "22905351": {"Id": "22905351", "PostTypeId": "2", "Body": "<p>The CPU can schedule the three threads ( <code>main</code> / <code>thread1</code> / <code>thread2</code> ) in any order. It might happen that your <code>main</code> doesn't get a time to run and your threads exit. So, you need to keep  keep <code>join</code> in <code>main</code> to take care of this case. Scheduling of threads is unpredictable, unless you are using an <code>RTOS</code>.</p>\n", "LastActivityDate": "2014-04-07T06:49:35.243", "CommentCount": "0", "CreationDate": "2014-04-07T06:49:35.243", "ParentId": "22905207", "Score": "3", "OwnerUserId": "1755108"}, "22905314": {"Id": "22905314", "PostTypeId": "2", "Body": "<p>Based on the <a href=\"http://en.cppreference.com/w/cpp/thread/thread\" rel=\"nofollow\">reference</a>, <strong>underlying thread must be joined or detached</strong> at the time the destructor is called. The destructor is invoked when <code>main</code> exits, and probably assumes that <code>join</code> or <code>detach</code> has been called.</p>\n<p>The code should also not crash, as long as the following two lines are somewhere after <code>helper1</code> and <code>helper2</code> are constructed. </p>\n<pre><code>helper1.detach()\nhelper2.detach()\n</code></pre>\n", "LastActivityDate": "2014-04-07T06:46:57.167", "CommentCount": "0", "CreationDate": "2014-04-07T06:46:57.167", "ParentId": "22905207", "Score": "2", "OwnerUserId": "391161"}, "22905277": {"Id": "22905277", "PostTypeId": "2", "Body": "<p>Because <code>std::~thread</code> calls <code>terminate</code> if the associated thread is still joinable:</p>\n<blockquote>\n<h3><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">30.3.1.3 thread destructor [thread.thread.destr]</a></h3>\n<pre><code>~thread();\n</code></pre>\n<p id=\"so_22905207_22905277_0\">If <code>joinable()</code>, calls <code>std::terminate()</code>. Otherwise, has no effects. [\n  Note: Either implicitly detaching or joining a <code>joinable()</code> thread in its destructor could result in difficult to debug correctness (for detach) or performance (for join) bugs encountered only when an exception is raised. Thus the programmer must ensure that the destructor is never executed while the thread is still joinable. \u2014end note]</p>\n</blockquote>\n<p>You <em>need to</em> call either <code>.detach()</code> or <code>.join()</code>. Other than that, since you cannot be sure how the operating system schedules your threads, you could end up interrupting your threads any way, so better use <code>.join()</code> from the beginning.</p>\n", "LastActivityDate": "2014-04-07T06:44:13.203", "CommentCount": "0", "CreationDate": "2014-04-07T06:44:13.203", "ParentId": "22905207", "Score": "4", "OwnerUserId": "1139697"}});