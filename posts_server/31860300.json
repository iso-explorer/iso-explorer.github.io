post_cb({"bq_ids": {"n4140": {"so_31860300_31860548_0": {"section_id": 5908, "quality": 0.9285714285714286, "length": 39}, "so_31860300_31860540_0": {"section_id": 3228, "quality": 0.9333333333333333, "length": 14}, "so_31860300_31860540_1": {"section_id": 6076, "quality": 0.875, "length": 7}}, "n3337": {"so_31860300_31860548_0": {"section_id": 5680, "quality": 0.9285714285714286, "length": 39}, "so_31860300_31860540_0": {"section_id": 3101, "quality": 0.9333333333333333, "length": 14}, "so_31860300_31860540_1": {"section_id": 5844, "quality": 0.875, "length": 7}}, "n4659": {"so_31860300_31860548_0": {"section_id": 7390, "quality": 0.6666666666666666, "length": 28}, "so_31860300_31860540_0": {"section_id": 3985, "quality": 0.9333333333333333, "length": 14}, "so_31860300_31860540_1": {"section_id": 7572, "quality": 0.875, "length": 7}}}, "31860300": {"CommentCount": "7", "ViewCount": "627", "CreationDate": "2015-08-06T15:49:34.723", "LastActivityDate": "2015-08-06T16:46:39.377", "Title": "Sizeof() function not working over a constant array C++", "FavoriteCount": "1", "PostTypeId": "1", "Id": "31860300", "Score": "1", "Body": "<p>Before starting, I am compiling the program using VS2015 C++ language. The problem is a compiling error when I try to determine the size of two constant arrays. Class involved in the issue:</p>\n<p>Header file:</p>\n<pre><code>#ifndef RACE_H_\n#define RACE_H_\nclass Race\n{\n    private:\n        static const int PILOT_POINTS[];\n        static const double TEAM_AWARDS[];\n}\n#endif\n</code></pre>\n<p>Source file:</p>\n<pre><code>#include \"Race.h\"\nconst int PILOT_POINTS[] = { 25, 18, 15, 12, 10, 8, 6, 4, 2, 1 };\nconst double TEAM_AWARDS[] = { 100000, 75000, 50000, 25000, 15000, 10000 };\n</code></pre>\n<p>Part of the errors:</p>\n<pre><code>sizeof(TEAM_AWARDS) / sizeof(TEAM_AWARDS[0]))\nsizeof(PILOT_POINTS) / sizeof(PILOT_POINTS[0]))\n</code></pre>\n<p>The compiler says:</p>\n<blockquote>\n<p id=\"so_31860300_31860300_0\">Error 2070 const int[] operand sizeof not valid.</p>\n<p id=\"so_31860300_31860300_1\">An incomplete type is not allowed.</p>\n<p id=\"so_31860300_31860300_2\">Error 2070 const double[] operand sizeof not valid.</p>\n<p id=\"so_31860300_31860300_3\">An incomplete type is not allowed.</p>\n</blockquote>\n<p>Could I use extern to solve the problem? If so, how should I use it?</p>\n", "Tags": "<c++><arrays><const><sizeof>", "OwnerUserId": "4355521", "AnswerCount": "3"}, "31860540": {"ParentId": "31860300", "CommentCount": "0", "CreationDate": "2015-08-06T16:00:20.783", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "31860540", "Score": "1", "Body": "<p>You need to just provide the size in the declaration. From [dcl.array]:</p>\n<blockquote>\n<p id=\"so_31860300_31860540_0\">Except as noted below, if the constant expression is omitted, the type of the\n  identifier of D is \u201cderived-declarator-type-list array of unknown bound of T\u201d, an <strong>incomplete object type</strong>.</p>\n</blockquote>\n<p>And [expr.sizeof]:</p>\n<blockquote>\n<p id=\"so_31860300_31860540_1\">The <code>sizeof</code>\n  operator shall not be applied to an expression that has function or incomplete type [...]</p>\n</blockquote>\n<p>The exceptions for arrays without the constant expression size are when you provide an initializer (e.g. <code>int a[] = {1, 2}</code>) or when the array was previously declared with a size. So in this case, you could either provide the size or the initializer the header:</p>\n<pre><code>static const int PILOT_POINTS[10];    \nstatic const int PILOT_POINTS[] = { 25, 18, 15, 12, 10, 8, 6, 4, 2, 1 };\n</code></pre>\n<p>or simply just use a <code>vector</code>, so you can initialize it in the source, and get all the other nice advantages of <code>vector</code> over raw C arrays:</p>\n<pre><code>static const std::vector&lt;int&gt; PILOT_POINTS;\n</code></pre>\n", "LastActivityDate": "2015-08-06T16:00:20.783"}, "31860548": {"ParentId": "31860300", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-08-06T16:00:45.733", "Score": "3", "LastEditorUserId": "1830736", "LastEditDate": "2015-08-06T16:23:14.673", "Id": "31860548", "OwnerUserId": "1830736", "Body": "<p>The problem is that you have <em>declared</em> the arrays, but you have not <em>defined</em> them at the point you are invoking the <code>sizeof</code> operator.</p>\n<p>Furthermore, you can't just move your definition to the header, because only integral types may be defined this way:</p>\n<blockquote>\n<p id=\"so_31860300_31860548_0\">If a non-volatile const static data member is of integral or enumeration type, its declaration in the class definition can specify a brace-or-equal-initializer in which every initializer-clause that is an assignment- expression is a constant expression. A static data member of literal type can be declared in the class definition with the constexpr specifier; if so, its declaration shall specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-expression is a constant expression... (\u00a79.4.2/3)</p>\n</blockquote>\n<p>C-style variable length arrays are not integral, because their length isn't known until they are defined.</p>\n<p>To solve this problem, you need to use a length-specifier in the array:</p>\n<pre><code>#ifndef RACE_H_\n#define RACE_H_\nclass Race\n{\n    private:\n        static const int PILOT_POINTS[10];\n        static const double TEAM_AWARDS[6];\n}\n#endif\n</code></pre>\n<p>This is extra hassle, because now you must change the lengths if the array changes sizes, but it's necessary.</p>\n<p>Alternately, you can use <code>constexpr</code>, and put the entire definition in the header. This way, you can omit the array lengths.</p>\n<pre><code>#ifndef RACE_H_\n#define RACE_H_\nclass Race\n{\n    private:\n        static constexpr int PILOT_POINTS[]\n                = { 25, 18, 15, 12, 10, 8, 6, 4, 2, 1 };\n        static constexpr double TEAM_AWARDS[]\n                = { 100000, 75000, 50000, 25000, 15000, 10000 };\n}\n#endif\n</code></pre>\n<p>Also, you might try what @CoryKramer suggests in a comment, and use a <code>vector</code>.  You'll have a very small run-time cost to initialize it and to look up the size, but that shouldn't matter much.</p>\n", "LastActivityDate": "2015-08-06T16:23:14.673"}, "31861409": {"ParentId": "31860300", "CommentCount": "0", "CreationDate": "2015-08-06T16:46:39.377", "OwnerUserId": "2549876", "PostTypeId": "2", "Id": "31861409", "Score": "1", "Body": "<p>Other answers have addressed the fact that you need to define the array. For the sake of completeness, I would mention that your way of getting the size of the array is \"<a href=\"http://www.cplusplus.com/forum/general/103284/\" rel=\"nofollow\">the C version</a>\". C++ has a better way <a href=\"http://en.cppreference.com/w/cpp/types/extent\" rel=\"nofollow\">std::extent</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nstruct Race\n{\n    static const int PILOT_POINTS[];\n    static const double TEAM_AWARDS[];\n};\n\nconst int Race::PILOT_POINTS[] = { 25, 18, 15, 12, 10, 8, 6, 4, 2, 1 };\nconst double Race::TEAM_AWARDS[] = { 100000, 75000, 50000, 25000, 15000, 10000 };\n\nint main()\n{\n    ::std::wcout &lt;&lt; ( sizeof( Race::PILOT_POINTS ) / sizeof( Race::PILOT_POINTS[ 0 ] ) ) &lt;&lt; L' '\n        &lt;&lt; ( sizeof( Race::TEAM_AWARDS ) / sizeof( Race::TEAM_AWARDS[ 0 ] ) ) &lt;&lt; L'\\n'\n        &lt;&lt; std::extent&lt; decltype( Race::PILOT_POINTS ) &gt;::value &lt;&lt; L' '\n        &lt;&lt; std::extent&lt; decltype( Race::TEAM_AWARDS ) &gt;::value;\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2015-08-06T16:46:39.377"}});