post_cb({"bq_ids": {"n4140": {"so_37706380_37706473_1": {"length": 9, "quality": 0.9, "section_id": 798}}, "n3337": {"so_37706380_37706473_1": {"length": 9, "quality": 0.9, "section_id": 787}}, "n4659": {"so_37706380_37706473_1": {"length": 7, "quality": 0.7, "section_id": 856}}}, "37706380": {"ViewCount": "71", "Body": "<p>The other iterator types surely don't have the implication that they point to continuous data, but I'm wondering if I can treat RandomAccessIterators as if they point to a buffer of continuous data \u2013 i.e. they could be converted to pointers to data. </p>\n<p>Is this assumption correct? Can I always safely use <code>&amp;*it</code> and get a pointer not just to one element, but to a continuous buffer, if <code>it</code> is a RandomAccessIterator?</p>\n", "AcceptedAnswerId": "37706473", "Title": "Does RandomAccessIterator imply that the data is continuous in memory?", "CreationDate": "2016-06-08T15:08:28.073", "Id": "37706380", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-06-08T15:15:34.953", "LastEditorUserId": "481061", "LastActivityDate": "2016-06-28T22:43:01.380", "Score": "3", "OwnerUserId": "481061", "Tags": "<c++><iterator><random-access>", "AnswerCount": "1"}, "37706473": {"Id": "37706473", "PostTypeId": "2", "Body": "<p>No, it is not a valid assumption. The standard library itself has a counterexample in <code>std::deque</code>:</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/container/deque\" rel=\"nofollow\">from cppreference</a>:</p>\n<blockquote>\n<p id=\"so_37706380_37706473_0\">As opposed to <code>std::vector</code>, the elements of a deque are not stored contiguously: typical implementations use a sequence of individually allocated fixed-size arrays. </p>\n</blockquote>\n<p><code>std::deque</code>'s <code>iterator</code> is a RandomAccessIterator:</p>\n<p><a href=\"http://eel.is/c++draft/deque#deque.overview-1\" rel=\"nofollow\">[deque.overview]/1</a></p>\n<blockquote>\n<p id=\"so_37706380_37706473_1\">A deque is a sequence container that, like a vector (<a href=\"http://eel.is/c++draft/vector\" rel=\"nofollow\">[vector]</a>), supports random access iterators.</p>\n</blockquote>\n<p>If you want a guarantee of contiguous memory, you don't need to wait long: the guarantee will be provided by the ContiguousIterator in C++17.<sup>1</sup></p>\n<hr>\n<p><sup>the ContiguousIterator concept was proposed in a sequence of documents ending in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4284.html\" rel=\"nofollow\">N4284</a>, and adopted in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/#mailing2014-07\" rel=\"nofollow\">November 2014</a></sup></p>\n</hr>", "LastEditorUserId": "4892076", "LastActivityDate": "2016-06-28T22:43:01.380", "Score": "5", "CreationDate": "2016-06-08T15:12:34.173", "ParentId": "37706380", "CommentCount": "2", "LastEditDate": "2016-06-28T22:43:01.380", "OwnerUserId": "4892076"}});