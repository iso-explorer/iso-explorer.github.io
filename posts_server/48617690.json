post_cb({"bq_ids": {"n4140": {"so_48617690_48617786_7": {"length": 50, "quality": 0.9615384615384616, "section_id": 632}, "so_48617690_48617786_6": {"length": 27, "quality": 0.9, "section_id": 630}, "so_48617690_48617786_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 629}, "so_48617690_48617786_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 3296}, "so_48617690_48617786_1": {"length": 23, "quality": 0.92, "section_id": 3296}, "so_48617690_48617786_4": {"length": 6, "quality": 1.0, "section_id": 3296}}, "n3337": {"so_48617690_48617786_7": {"length": 50, "quality": 0.9615384615384616, "section_id": 622}, "so_48617690_48617786_6": {"length": 28, "quality": 0.9333333333333333, "section_id": 621}, "so_48617690_48617786_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 620}, "so_48617690_48617786_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 3166}, "so_48617690_48617786_1": {"length": 23, "quality": 0.92, "section_id": 3166}, "so_48617690_48617786_4": {"length": 6, "quality": 1.0, "section_id": 3166}}, "n4659": {"so_48617690_48617786_7": {"length": 50, "quality": 0.9615384615384616, "section_id": 660}, "so_48617690_48617786_6": {"length": 27, "quality": 0.9, "section_id": 658}, "so_48617690_48617786_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 655}, "so_48617690_48617786_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 4058}, "so_48617690_48617786_1": {"length": 23, "quality": 0.92, "section_id": 4058}, "so_48617690_48617786_4": {"length": 6, "quality": 1.0, "section_id": 4058}}}, "48617786": {"Id": "48617786", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48617690_48617786_0\">Is this behavior written in some part of the standard?</p>\n</blockquote>\n<p>Of course. It's all dictated by the rules in <a href=\"https://timsong-cpp.github.io/cppwp/n3337/dcl.init#16\" rel=\"noreferrer\">[dcl.init]/16</a>, emphasis mine to match your initializer:</p>\n<blockquote>\n<p id=\"so_48617690_48617786_1\">The semantics of initializers are as follows. The destination type is\n  the type of the object or reference being initialized and the source\n  type is the type of the initializer expression. If the initializer is\n  not a single (possibly parenthesized) expression, the source type is\n  not defined.</p>\n<ul>\n<li><p id=\"so_48617690_48617786_2\">If the initializer is a (<strong>non-parenthesized</strong>) braced-init-list, the object or reference is list-initialized ([dcl.init.list]).</p></li>\n<li><p id=\"so_48617690_48617786_3\">[...]</p></li>\n<li><p id=\"so_48617690_48617786_4\">If the destination type is a (possibly cv-qualified) class type:</p>\n<ul>\n<li><strong>If the initialization is direct-initialization</strong>, or if it is copy-initialization where the cv-unqualified version of the source\n  type is the same class as, or a derived class of, the class of the\n  destination, <strong>constructors are considered</strong>. The applicable constructors\n  are enumerated ([over.match.ctor]), and the best one is chosen through\n  overload resolution ([over.match]). The constructor so selected is\n  called to initialize the object, with the initializer expression or\n  expression-list as its argument(s). If no constructor applies, or the\n  overload resolution is ambiguous, the initialization is ill-formed.</li>\n<li>[...]</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>You supply a parenthesized empty brace-init-list, so only the later bullet applies. Constructors are considered, and in the first case we end up doing a copy-initialization from a default initialized <code>X</code>. In the latter case, the <code>initializer_list</code> c'tor is chosen as a better match. The rule for choosing this overload is specified in <a href=\"https://timsong-cpp.github.io/cppwp/n3337/over.ics.list\" rel=\"noreferrer\">[over.ics.list]</a>:</p>\n<blockquote>\n<p id=\"so_48617690_48617786_5\">When an argument is an initializer list ([dcl.init.list]), it is not\n  an expression and special rules apply for converting it to a parameter\n  type.</p>\n<p id=\"so_48617690_48617786_6\">If the parameter type is std::initializer_list or \u201carray of X\u201d and\n  all the elements of the initializer list can be implicitly converted\n  to X, the implicit conversion sequence is the worst conversion\n  necessary to convert an element of the list to X. This conversion can\n  be a user-defined conversion even in the context of a call to an\n  initializer-list constructor.</p>\n<p id=\"so_48617690_48617786_7\">Otherwise, if the parameter is a non-aggregate class X and overload\n  resolution per [over.match.list] chooses a single best constructor of\n  X to perform the initialization of an object of type X from the\n  argument initializer list, the implicit conversion sequence is a\n  user-defined conversion sequence. If multiple constructors are viable\n  but none is better than the others, the implicit conversion sequence\n  is the ambiguous conversion sequence. User-defined conversions are\n  allowed for conversion of the initializer list elements to the\n  constructor parameter types except as noted in [over.best.ics].</p>\n</blockquote>\n", "LastEditorUserId": "817643", "LastActivityDate": "2018-02-05T07:43:56.597", "Score": "7", "CreationDate": "2018-02-05T07:39:42.933", "ParentId": "48617690", "CommentCount": "3", "OwnerUserId": "817643", "LastEditDate": "2018-02-05T07:43:56.597"}, "48617690": {"ViewCount": "600", "Body": "<pre><code>struct X\n{\n    X() { std::cout &lt;&lt; \"default ctor\" &lt;&lt; std::endl; }\n\n};\n\nint main()\n{\n    X({});\n}\n</code></pre>\n<p>This prints out</p>\n<pre><code>default ctor\n</code></pre>\n<p>and that makes sense because empty brace value-initializes the object (I think).\nHowever,</p>\n<pre><code>struct X\n{\n    X() { std::cout &lt;&lt; \"default ctor\" &lt;&lt; std::endl; }\n    X(std::initializer_list&lt;int&gt;) { std::cout &lt;&lt; \"list initialization\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    X({});\n}\n</code></pre>\n<p>For this, I got</p>\n<pre><code>initializer list\n</code></pre>\n<p>I don't find this behavior so strange, but I'm not fully convinced. What is the rule for this?</p>\n<p>Is this behavior written in some part of the standard?</p>\n", "AcceptedAnswerId": "48617786", "Title": "Direct initialization with empty initializer list", "CreationDate": "2018-02-05T07:33:02.967", "LastActivityDate": "2018-02-05T07:59:58.667", "CommentCount": "1", "LastEditDate": "2018-02-05T07:36:10.523", "PostTypeId": "1", "LastEditorUserId": "440558", "Id": "48617690", "Score": "5", "OwnerUserId": "7609476", "Tags": "<c++><c++11><language-lawyer><initializer-list>", "AnswerCount": "2"}, "48618021": {"Id": "48618021", "PostTypeId": "2", "Body": "<p>To see what's really going on, declare copy and move constructors, compile in C++14 mode or earlier, and disable copy elision.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/0285e8b07a9dc8b6\" rel=\"noreferrer\">Coliru link</a></p>\n<p>Output: </p>\n<pre><code>default ctor\nmove ctor\n</code></pre>\n<p>In the first snippet, the compiler looks for constructors of <code>X</code> that take a single argument, since you've provided a single argument. These are the copy and move constructor, <code>X::X(const X&amp;)</code> and <code>X::X(X&amp;&amp;)</code>, which the compiler will implicitly declare for you if you do not declare them yourself. The compiler then converts <code>{}</code> to an <code>X</code> object using the default constructor, and passes that <code>X</code> object to the move constructor. (You must use <code>fno-elide-constructors</code> to see this otherwise the compiler will elide the move, and in C++17 copy elision became mandatory.)</p>\n<p>In the second snippet, the compiler now has a choice of converting <code>{}</code> to <code>X</code> (then calling the move constructor), or converting <code>{}</code> to <code>std::initializer_list&lt;int&gt;</code> (then calling the initializer list constructor). According to [over.ics.list]/6.2, the conversion from <code>{}</code> to <code>X</code>, which calls the default constructor, is a user-defined conversion, while according to [over.ics.list]/4, the conversion from <code>{}</code> to <code>std::initializer_list&lt;int&gt;</code> is the identity conversion. The identity conversion is better than a user-defined conversion, so the compiler calls the initializer list constructor.</p>\n", "LastActivityDate": "2018-02-05T07:59:58.667", "CommentCount": "1", "CreationDate": "2018-02-05T07:59:58.667", "ParentId": "48617690", "Score": "10", "OwnerUserId": "481267"}});