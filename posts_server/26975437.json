post_cb({"26976017": {"ParentId": "26975437", "CommentCount": "1", "CreationDate": "2014-11-17T15:26:20.563", "PostTypeId": "2", "Id": "26976017", "Score": "3", "Body": "<blockquote>\n<p id=\"so_26975437_26976017_0\"><strong>21.4.1.7</strong> <code>basic_string</code> accessors</p>\n<p id=\"so_26975437_26976017_1\"><code>const charT* c_str() const noexcept;</code></p>\n<p id=\"so_26975437_26976017_2\"><code>const charT* data() const noexcept;</code></p>\n<p id=\"so_26975437_26976017_3\"><em>1</em> Returns: A pointer <code>p</code> such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.</p>\n<p id=\"so_26975437_26976017_4\"><em>2</em> Complexity: constant time.</p>\n</blockquote>\n<p>This effectively requires that the terminating <code>NUL</code> be stored contiguously together with the character sequence (it forces an additional requirement on <code>operator[]</code> that <code>s[s.size()]</code> not do anything fancy, though the plain text of <strong>21.4.5</strong> appears to give it some latitude).</p>\n<p>It also explicitly requires that <code>s.c_str() == &amp;s[0]</code>, which in turn means that <code>s.c_str() == &amp;s.front()</code> (<code>front()</code> is defined as <code>operator[](0)</code>).</p>\n", "OwnerUserId": "1670129", "LastActivityDate": "2014-11-17T15:26:20.563"}, "bq_ids": {"n3337": {"so_26975437_26976017_2": {"section_id": 1836, "quality": 0.8, "length": 4}, "so_26975437_26976017_1": {"section_id": 1836, "quality": 0.8, "length": 4}}, "n4659": {"so_26975437_26976017_2": {"section_id": 1984, "quality": 0.8, "length": 4}, "so_26975437_26976017_1": {"section_id": 1984, "quality": 0.8, "length": 4}}}, "26975437": {"CommentCount": "1", "AcceptedAnswerId": "26976017", "LastActivityDate": "2014-11-17T15:26:20.563", "Body": "<p>After reading through the description about <code>std::basic_string</code> on cppreference, I'm uncertain about the following two questions regarding the underlying storage of <code>std::basic_string</code>:</p>\n<p>1) Since C++11, does the contiguity of <code>std::basic_string</code> extends to the terminating null character? Note that <code>str[str.size()]</code> returns a reference to a terminating null character. But I want to make sure whether this is the one after <code>str[str.size() - 1]</code>.</p>\n<p>2) Since C++11, <code>data()</code> and <code>c_str()</code> become equivalent. But does it hold that <code>data() == c_str() == &amp;front()</code>?</p>\n<p>Any quotation from the standard would be appreciated.</p>\n", "PostTypeId": "1", "ViewCount": "51", "Title": "About the underlying storage of std::basic_string", "Id": "26975437", "Score": "1", "CreationDate": "2014-11-17T14:57:38.970", "Tags": "<c++11><memory><stdstring>", "OwnerUserId": "1348273", "AnswerCount": "1"}});