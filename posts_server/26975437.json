post_cb({"26976017": {"LastActivityDate": "2014-11-17T15:26:20.563", "ParentId": "26975437", "CommentCount": "1", "Score": "3", "Body": "<blockquote>\n<p id=\"so_26975437_26976017_0\"><strong>21.4.1.7</strong> <code>basic_string</code> accessors</p>\n<p id=\"so_26975437_26976017_1\"><code>const charT* c_str() const noexcept;</code></p>\n<p id=\"so_26975437_26976017_2\"><code>const charT* data() const noexcept;</code></p>\n<p id=\"so_26975437_26976017_3\"><em>1</em> Returns: A pointer <code>p</code> such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.</p>\n<p id=\"so_26975437_26976017_4\"><em>2</em> Complexity: constant time.</p>\n</blockquote>\n<p>This effectively requires that the terminating <code>NUL</code> be stored contiguously together with the character sequence (it forces an additional requirement on <code>operator[]</code> that <code>s[s.size()]</code> not do anything fancy, though the plain text of <strong>21.4.5</strong> appears to give it some latitude).</p>\n<p>It also explicitly requires that <code>s.c_str() == &amp;s[0]</code>, which in turn means that <code>s.c_str() == &amp;s.front()</code> (<code>front()</code> is defined as <code>operator[](0)</code>).</p>\n", "Id": "26976017", "CreationDate": "2014-11-17T15:26:20.563", "OwnerUserId": "1670129", "PostTypeId": "2"}, "26975437": {"AcceptedAnswerId": "26976017", "Tags": "<c++11><memory><stdstring>", "AnswerCount": "1", "OwnerUserId": "1348273", "Body": "<p>After reading through the description about <code>std::basic_string</code> on cppreference, I'm uncertain about the following two questions regarding the underlying storage of <code>std::basic_string</code>:</p>\n<p>1) Since C++11, does the contiguity of <code>std::basic_string</code> extends to the terminating null character? Note that <code>str[str.size()]</code> returns a reference to a terminating null character. But I want to make sure whether this is the one after <code>str[str.size() - 1]</code>.</p>\n<p>2) Since C++11, <code>data()</code> and <code>c_str()</code> become equivalent. But does it hold that <code>data() == c_str() == &amp;front()</code>?</p>\n<p>Any quotation from the standard would be appreciated.</p>\n", "Id": "26975437", "CreationDate": "2014-11-17T14:57:38.970", "PostTypeId": "1", "LastActivityDate": "2014-11-17T15:26:20.563", "Title": "About the underlying storage of std::basic_string", "CommentCount": "1", "Score": "1", "ViewCount": "51"}, "bq_ids": {"n4659": {"so_26975437_26976017_2": {"section_id": 1984, "quality": 0.8, "length": 4}, "so_26975437_26976017_1": {"section_id": 1984, "quality": 0.8, "length": 4}}, "n3337": {"so_26975437_26976017_2": {"section_id": 1836, "quality": 0.8, "length": 4}, "so_26975437_26976017_1": {"section_id": 1836, "quality": 0.8, "length": 4}}}});