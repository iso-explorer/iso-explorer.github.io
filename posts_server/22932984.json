post_cb({"22933160": {"PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_22932984_22933160_0\"><code>std::vector</code> fragments memory as it grows because C++ has no equivalent of <code>realloc</code>. </p>\n</blockquote>\n<p><code>realloc</code> will fragment the memory in the same way, since it's doing the same thing - allocating a new block and copying the contents, if the old block wasn't large enough.</p>\n<blockquote>\n<p id=\"so_22932984_22933160_1\">With great care, couldn't you write something that works just like <code>std::vector</code> but using C allocation functions, which has the possibility to grow its memory without moving its address and copying existing elements, making it as good or better in terms of fragmentation and performance?</p>\n</blockquote>\n<p>That's just what <code>vector</code> does. You can control the <em>capacity</em> independently of the <em>size</em>, and it will only reallocate when the capacity is exceeded. <code>realloc</code> is similar, but with no means to control the capacity - making <code>vector</code> better in terms of fragmentation and performance.</p>\n<blockquote>\n<p id=\"so_22932984_22933160_2\">why doesn't C++ have an equivalent to <code>realloc</code>? </p>\n</blockquote>\n<p>Because it has <code>std::vector</code>, which does the same thing with more flexibility. As well as allowing you to control exactly how and when memory is allocated, it works with any movable type, while <code>realloc</code> will go horribly wrong when used with non-trivial types.</p>\n", "LastActivityDate": "2014-04-08T09:38:59.050", "Id": "22933160", "CommentCount": "6", "CreationDate": "2014-04-08T09:38:59.050", "ParentId": "22932984", "Score": "2", "OwnerUserId": "204847"}, "22932984": {"ViewCount": "1303", "Body": "<p>From <a href=\"http://www.stroustrup.com/bs_faq2.html#realloc\" rel=\"nofollow noreferrer\">Bjarne Stroustrup's FAQ</a>:</p>\n<blockquote>\n<p id=\"so_22932984_22932984_0\">If you feel the need for realloc() - and many do - then consider using\n  a standard library vector.</p>\n</blockquote>\n<p>I'll preface my question by agreeing that <code>std::vector</code> is better for many reasons, and I personally would always choose to use it over writing my own dynamic arrays with C memory allocation.</p>\n<p><em>But</em>, <code>std::vector</code> fragments memory as it grows because C++ has no equivalent of <code>realloc</code> (<strong>edit</strong> To clarify, I know that <code>std::vector</code>'s storage is contiguous and won't get fragmented, I mean fragmentation of the memory space caused by allocating and deallocating, which <code>realloc</code> can avoid by extending an existing allocation). So is it fair to always recommend it over <code>realloc</code>? With great care, couldn't you write something that works just like <code>std::vector</code> but using C allocation functions, which has the possibility to grow its memory without moving its address and copying existing elements, making it as good or better in terms of fragmentation and performance?</p>\n<p>And relatedly (bonus question!), <em>why</em> doesn't C++ have an equivalent to <code>realloc</code>? It seems like an odd thing to omit in a language that is so focused on performance. The section in Bjarne's FAQ has exactly that title (minus emphasis), but the answer doesn't address the 'why'. Was it just an accidental omission? Is there some fundamental incompatibility with how <code>new</code>/<code>delete</code> work? Does it not really give the benefits it seems to in practice?</p>\n<p><strong>Edit</strong>: ok, so I had neglected to consider the C nastiness of <code>realloc</code> - <code>std::vector</code> can't be rewritten using <code>realloc</code> because it only works with PODs, doesn't throw and so on. Perhaps a POD-only container written to deal with the nastiness would be a good idea for some situations. In any case though, the more interesting question becomes: would <code>std::vector</code> benefit from a C++ equivalent of <code>realloc</code>, which has (more or less) been answered here:</p>\n<p><a href=\"https://stackoverflow.com/questions/8003233/does-stdvector-have-to-move-objects-when-growing-capacity-or-can-allocator?lq=1\">Does std::vector *have* to move objects when growing capacity? Or, can allocators \"reallocate\"?</a></p>\n<p>Sadly, the answer seems to be \"yes, but the standards committee didn't vote it in\". Here's hoping.</p>\n", "AcceptedAnswerId": "22933125", "Title": "Is it fair to always recommend std::vector over realloc?", "CreationDate": "2014-04-08T09:31:45.787", "Id": "22932984", "CommentCount": "13", "LastEditDate": "2017-05-23T12:07:50.497", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-04-08T14:42:55.893", "Score": "2", "OwnerUserId": "40834", "Tags": "<c++><realloc>", "AnswerCount": "4"}, "22933870": {"PostTypeId": "2", "Body": "<p><code>new</code>/<code>new[]</code> and <code>delete</code>/<code>delete[]</code> are typically layered atop the C library allocation functions (ala <code>malloc</code>/<code>realloc</code>/<code>free</code>), possibly with an extra layer for small-object optimisations that use one <code>malloc</code>-ed region for quickly satisfying many small <code>new</code> requests.  This layering meant supporting <code>new</code> and <code>delete</code> took very little implementation effort on the part of early C++ library authors.</p>\n<p>To utilise the in-place resizing functionality in <code>realloc</code> for C++, though, invasive changes to the <code>realloc</code> library function are needed so that if movement to a new memory region <em>is</em> required, the C++ library code gets the chance to copy-construct/destruct the objects being moved.  This could be done as:</p>\n<ul>\n<li><p>a callback happening after <code>realloc</code> realised a move was necessary, asking the C++ library to do the actual data movement instead of doing a <code>memcpy()</code> style bytewise copy, or</p></li>\n<li><p>as an additional resize-in-place-or-fail-without-moving function so the C++ library code could try that, then fall back on a <code>malloc</code> and proper/safe copy before deleteing the original objects and deallocating the original memory.</p></li>\n</ul>\n<p>As most C library <code>realloc</code> functions lack any such hook/query facility, the C++ Standard - and Standard library - don't require it.  As Mehrdad points out, <a href=\"https://stackoverflow.com/questions/3105001/why-is-there-no-reallocation-functionality-in-c-allocators/3105769#3105769\">this answer</a> documents SGI's acknowledgement of this issue.</p>\n<p>Given the extensive use of C++ these days, it would - IMHO - make sense to ship a <code>malloc</code>/<code>realloc</code>/<code>free</code> implementation in the C++ library itself that does provide such a hook/query, so that C++ library authors who see utility in <code>realloc</code> can utilise it freely; that'd be a worthy candidate for inclusion in a future Standard.</p>\n<blockquote>\n<p id=\"so_22932984_22933870_0\">With great care, couldn't you write something that works just like std::vector but using C allocation functions, which has the possibility to grow its memory without moving its address and copying existing elements, making it as good or better in terms of fragmentation and performance?</p>\n</blockquote>\n<p>As above - no - it's not possible to copy-construct/destruct objects with any amount of care without changes to the <code>realloc</code> API.</p>\n", "LastActivityDate": "2014-04-08T14:42:55.893", "LastEditorUserId": "-1", "Id": "22933870", "CommentCount": "24", "CreationDate": "2014-04-08T10:10:39.663", "ParentId": "22932984", "Score": "3", "OwnerUserId": "410767", "LastEditDate": "2017-05-23T12:31:11.777"}, "bq_ids": {"n4140": {"so_22932984_22933125_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 955}}, "n3337": {"so_22932984_22933125_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 943}}}, "22933280": {"PostTypeId": "2", "Body": "<p>There is a good reason why C++ doesn't have <code>realloc</code>; instead of repeating it, I'll point you to the answer <a href=\"https://stackoverflow.com/a/3105769/541686\">here</a>.</p>\n<p>And for the record, a proper <code>vector</code> implementation mitigates the fragmentation issue to some extent, <a href=\"http://crntaylor.wordpress.com/2011/07/15/optimal-memory-reallocation-and-the-golden-ratio/\" rel=\"nofollow noreferrer\"><strong>by choosing a growth factor close to the golden ratio</strong></a>, so it's not completely a lost cause.</p>\n", "LastActivityDate": "2014-04-08T09:57:15.900", "LastEditorUserId": "-1", "Id": "22933280", "CommentCount": "6", "CreationDate": "2014-04-08T09:43:37.807", "ParentId": "22932984", "Score": "2", "OwnerUserId": "541686", "LastEditDate": "2017-05-23T11:50:28.563"}, "22933125": {"PostTypeId": "2", "Body": "<h2>Direct comparison</h2>\n<pre><code>                        |  std::vector     | C memory functions\n------------------------+------------------+------------------------\ndefault capacity        | undefined        | undefined\ndefault grow            | towards capacity | undefined\ndeterministic capacity  | available        | no\ndeterministic grow      | available        | no\ndeterministic mem.-move | available        | no\nnon-POD types           | yes              | f***ing no (*)\nno-throw                | no               | yes\n</code></pre>\n<p><code>deterministic mem.-move</code> follows from <code>deterministic capacity/grow</code>. It is when <code>realloc</code> and <code>std::vector</code> have to move their stored elements to a new memory location.</p>\n<p>I think the (available) determinism with regards to memory moving is doubly important when you consider moving (smart) references of any kind.</p>\n<p><sub>NOTE: In this respect, I use the term \"deterministic\" with respect to my source codes lifetime, i.e. its lifetime across different versions of different libraries with different compile flags, etc..</sub></p>\n<hr>\n<h2>Source</h2>\n<p>It does fragment memory as much as <code>realloc</code> does:</p>\n<blockquote>\n<h3>Class template vector overview [vector.overview]</h3>\n<p id=\"so_22932984_22933125_0\">The elements of a\n  vector are stored contiguously, meaning that if <code>v</code> is a <code>vector&lt;T, Allocator&gt;</code> where <code>T</code> is some type other than <code>bool</code>, then it obeys the identity <code>&amp;v[n] == &amp;v[0] + n</code> for all <code>0 &lt;= n &lt; v.size()</code></p>\n</blockquote>\n<p>In other words, the memory used is in one piece.</p>\n<p>The one big difference is that <code>realloc</code> can actually increase allocated memory portions without having ordered it to do so, however, it is not required to do so (<code>man 3 realloc</code>):</p>\n<blockquote>\n<h3>man 3 realloc</h3>\n<p id=\"so_22932984_22933125_1\">The  realloc() function changes the size of the memory block pointed to by ptr to size bytes.  The contents will\n         be unchanged in the range from the start of the region up to the minimum of the old and new sizes.  If  the  new\n         size  is  larger  than the old size, the added memory will not be initialized.  If ptr is NULL, then the call is\n         equivalent to malloc(size), for all values of size; if size is equal to zero, and ptr is not NULL, then the call\n         is equivalent to free(ptr).  Unless ptr is NULL, it must have been returned by an earlier call to malloc(), cal\u2010\n         loc() or realloc().  <strong>If the area pointed to was moved, a free(ptr) is done.</strong></p>\n</blockquote>\n<p>So it can increase the size, but is not required to.</p>\n<p>A <code>std::vector</code> carries not only a <code>size</code>, but also a <code>capacity</code>. If you know beforehand you will need a big <code>vector</code>, yet you cannot initialize everything right now, you are entitled to increase the capacity of your vector like so:</p>\n<pre><code>std::vector&lt;T&gt; vec(32);\nvec.reserve(1024);\n// vec has size 32, but reserved a memory region of 1024 elements\n</code></pre>\n<p>So, unlike <code>realloc</code>, the moment when reallocations occur can be deterministic with <code>std::vector</code>.</p>\n<p>To answer your question: Because there is <code>std::vector</code>, <code>realloc</code> is not needed. And, <code>realloc</code> is not allowed for non-POD types; attempts to use <code>malloc</code>, <code>free</code> and <code>realloc</code> directly on non-PODs yields undefined behaviour.</p>\n</hr>", "LastActivityDate": "2014-04-08T10:45:56.163", "LastEditorUserId": "76722", "Id": "22933125", "CommentCount": "15", "CreationDate": "2014-04-08T09:37:13.363", "ParentId": "22932984", "Score": "3", "OwnerUserId": "76722", "LastEditDate": "2014-04-08T10:45:56.163"}});