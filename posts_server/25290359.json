post_cb({"25290990": {"Id": "25290990", "PostTypeId": "2", "Body": "<p>Depends on the memory order which you can specify for the <code>load()</code> operation.</p>\n<p>By default, it is <code>std::memory_order_seq_cst</code> and the answer is yes, it guarantees the current value stored by another thread (if stored at all, i.e. it must use <code>std::memory_order_release</code> memory order at least, otherwise the store visibility is not guaranteed).</p>\n<p>But if you specify <code>std::memory_order_relaxed</code> for the load operation the <a href=\"http://en.cppreference.com/w/cpp/atomic/memory_order\" rel=\"nofollow\">documentation</a> says <code>Relaxed ordering: there are no synchronization or ordering constraints, only atomicity is required of this operation</code>. I.e. the program could end up not reading from the memory at all.</p>\n", "LastEditorUserId": "2527797", "LastActivityDate": "2014-08-13T18:39:15.600", "Score": "0", "CreationDate": "2014-08-13T16:05:09.607", "ParentId": "25290359", "CommentCount": "2", "OwnerUserId": "2527797", "LastEditDate": "2014-08-13T18:39:15.600"}, "bq_ids": {"n4140": {"so_25290359_25290974_1": {"length": 18, "quality": 1.0, "section_id": 5831}, "so_25290359_43506604_2": {"length": 15, "quality": 1.0, "section_id": 1158}, "so_25290359_43506604_1": {"length": 11, "quality": 1.0, "section_id": 1159}}, "n3337": {"so_25290359_25290974_1": {"length": 18, "quality": 1.0, "section_id": 5602}, "so_25290359_43506604_2": {"length": 15, "quality": 1.0, "section_id": 1156}, "so_25290359_43506604_1": {"length": 11, "quality": 1.0, "section_id": 1157}}, "n4659": {"so_25290359_25290974_1": {"length": 18, "quality": 1.0, "section_id": 7293}, "so_25290359_43506604_2": {"length": 15, "quality": 1.0, "section_id": 1252}, "so_25290359_43506604_1": {"length": 11, "quality": 1.0, "section_id": 1253}}}, "25290359": {"ViewCount": "108", "Body": "<p>It is known that the modifications on a single atomic variable form a total order. Suppose we have an atomic read operation on some atomic variable <code>v</code> at wall-clock time T. Then, is this read guaranteed to acquire the current value of <code>v</code> that is wrote by the last one in the modification order of <code>v</code> at time T? To put it in another way, if an atomic write is done before an atomic read in natural time, and there is no other writes in between, then is the read guaranteed to return the value just written?</p>\n<p>My accepted answer is the 6th comment made by Cubbi to his answer.</p>\n", "AcceptedAnswerId": "25290974", "Title": "Is a read on an atomic variable guaranteed to acquire the current value of it in C++11?", "CreationDate": "2014-08-13T15:35:18.630", "Id": "25290359", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-08-13T18:54:12.443", "LastEditorUserId": "1348273", "LastActivityDate": "2017-04-19T21:43:45.297", "Score": "1", "OwnerUserId": "1348273", "Tags": "<memory><c++11><synchronization><order><atomic>", "AnswerCount": "3"}, "25290974": {"Id": "25290974", "PostTypeId": "2", "Body": "<p>Wall-clock time is irrelevant. However, what you're describing sounds like the write-read coherence guarantee:</p>\n<blockquote>\n<p id=\"so_25290359_25290974_0\"><code>$1.10[intro.multithread]/20</code></p>\n<p id=\"so_25290359_25290974_1\">If a side effect <code>X</code> on an atomic object <code>M</code> happens before a value computation <code>B</code> of <code>M</code>, then the evaluation <code>B</code> shall take its value from <code>X</code> or from a side effect <code>Y</code> that follows <code>X</code> in the modification order of <code>M</code>.</p>\n</blockquote>\n<p>(translating the standardese, \"value computation\" is a read, and \"side effect\" is a write)</p>\n<p>In particular, if your relaxed write and your relaxed read are in different statements of the same function, they are connected by a sequenced-before relationship, therefore they are connected by a happens-before relationship, therefore the guarantee holds.</p>\n", "LastEditorUserId": "273767", "LastActivityDate": "2014-08-13T17:30:41.830", "Score": "0", "CreationDate": "2014-08-13T16:04:12.857", "ParentId": "25290359", "CommentCount": "8", "OwnerUserId": "273767", "LastEditDate": "2014-08-13T17:30:41.830"}, "43506604": {"Id": "43506604", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_25290359_43506604_0\">Is a read on an atomic variable guaranteed to acquire the current value of it</p>\n</blockquote>\n<p>No</p>\n<p>Even though each atomic variable has a single modification order (which is observed by all threads), that does not mean that all threads observe modifications at the same time scale.  </p>\n<p>Consider this code:</p>\n<pre><code>std::atomic&lt;int&gt; g{0};\n\n// thread 1\ng.store(42);\n\n// thread 2\nint a = g.load();\n// do stuff with a\nint b = g.load();\n</code></pre>\n<p>A possible outcome is (see diagram):  </p>\n<ul>\n<li>thread 1: 42 is stored at time T1</li>\n<li>thread 2: the first load returns 0 at time T2</li>\n<li>thread 2: the store from thread 1 becomes visible at time T3</li>\n<li>thread 2: the second load returns 42 at time T4.</li>\n</ul>\n<p><a href=\"https://i.stack.imgur.com/IlCmh.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/IlCmh.png\"/></a></p>\n<p>This outcome is possible even though the first load at time T2 occurs <em>after</em> the store at T1 (in clock time).</p>\n<p>The standard says:</p>\n<blockquote>\n<p id=\"so_25290359_43506604_1\">Implementations should make atomic stores visible to atomic loads within a reasonable amount of time.</p>\n</blockquote>\n<p>It does not require a store to become visible right away and it even allows room for a store to remain invisible (e.g. on systems without cache-coherency).\nIn that case, an atomic read-modify-write (RMW) is required to access the last value.</p>\n<blockquote>\n<p id=\"so_25290359_43506604_2\">Atomic read-modify-write operations shall always read the last value (in the modification order) written\n  before the write associated with the read-modify-write operation.  </p>\n</blockquote>\n<p>Needless to say, RMW's are more expensive to execute (they lock the bus) and that is why a regular atomic load is allowed to return an older (cached) value.<br>\nIf a regular load was required to return the last value, performance would be horrible while there would be hardly any benefit.</br></p>\n", "LastActivityDate": "2017-04-19T21:43:45.297", "CommentCount": "0", "CreationDate": "2017-04-19T21:43:45.297", "ParentId": "25290359", "Score": "0", "OwnerUserId": "6651824"}});