post_cb({"bq_ids": {"n4140": {"so_35666354_35669885_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5433}}, "n3337": {"so_35666354_35669885_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5228}}, "n4659": {"so_35666354_35669885_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6861}}}, "35667571": {"Id": "35667571", "PostTypeId": "2", "Body": "<p>The point of having a const object is to guarantee that it won't be changed over the course of some routine. This is entirely about communicating to other developers your intent and providing the optimizer with information since const doesn't exist at an machine code level. </p>\n<p>Const objects only allow calling const methods, otherwise an object that's declared const might have its value changed by calling one of its methods which defeats the point of it being const in the first place. It is therefor good practice to label methods as const whenever possible when you are writing a class, so that const objects of that class can call those methods.</p>\n<p>There are a few implementations that will give you what you want. Here is one design that should work for you, given what little I know about your current requirements. This creates the string in the constructor since the constructor can modify the object even if the object is declared const. Then it retrieves the pre-populated string whenever toString() is called and there is no need for the mutable keyword (more on this in the second example). I hope you don't mind the liberties I've taken with what sort of string to construct and what should actually go into it.</p>\n<pre><code>class ImmutableClass\n{\nprivate:\n    std::string strTextRepresentation;\n\npublic:\n\n    int nValue1, nValue2, nValue3; //variables that are to be used in the string\n\n    ImmutableClass(int nValue1, int nValue2, int nValue3): \n        nValue1(nValue1), nValue2(nValue2), nValue3(nValue3)\n    {\n        std::stringstream ss;\n        ss &lt;&lt; nValue1 &lt;&lt; ',' &lt;&lt; nValue2 &lt;&lt; ',' &lt;&lt; nValue3;\n\n        strTextRepresentation = ss.str();\n    }\n\n    const std::string&amp; toString() const\n    {\n        return strTextRepresentation;\n    }\n};\n</code></pre>\n<p>As Chris Dodd mentioned in a comment above, you can also get what you want using the mutable keyword. The advantage would be that you could 'lazy-load' the string. This is a good choice if the overhead of constructing the string at the time your class is instantiated is too much to bear (perhaps because you need a lot of these classes and very few of them will ever have their toString() methods called).</p>\n<pre><code>class ImmutableClass\n{\nprivate:\n    mutable std::string strTextRepresentation;\n\npublic:\n\n    int nValue1, nValue2, nValue3; //variables that are to be used in the string\n\n    ImmutableClass(int nValue1, int nValue2, int nValue3): \n        nValue1(nValue1), nValue2(nValue2), nValue3(nValue3)\n    {\n    }\n\n    const std::string&amp; toString() const\n    {\n        //NOTE: consider using another kind of check for if the string\n        //has been set. I recommend an optional&lt;T&gt; wrapper (easy to implement, or see the boost library)\n        if (strTextRepresentation.size() == 0)\n        {\n            std::stringstream ss;\n            ss &lt;&lt; nValue1 &lt;&lt; ',' &lt;&lt; nValue2 &lt;&lt; ',' &lt;&lt; nValue3;\n\n            strTextRepresentation = ss.str();\n        }\n\n        return strTextRepresentation;\n    }\n};\n</code></pre>\n<p>Either of those should work and honestly there are a few others but those others are not good for various reasons even if they technically work. Your idea of const_cast-ing the object is one of those other methods because you are declaring that an object be constant and then at that same level of abstraction saying that it isn't really constant in one case. const_cast should virtually never be used if there is any other choice.</p>\n", "LastActivityDate": "2016-02-27T08:37:20.673", "CommentCount": "0", "CreationDate": "2016-02-27T08:37:20.673", "ParentId": "35666354", "Score": "2", "OwnerUserId": "4160393"}, "35666354": {"ViewCount": "100", "Body": "<p>Lets say I have an immutable class <code>C</code>.  From a user perspective, we can never change the functional behavior of any <code>C</code> object.</p>\n<p>However, for performance reasons, lets say we have a <code>toString</code> method that converts the object into a string and returns it.  I don't want to have to do this computation each time, so I store the result in a member variable so if the user calls <code>toString</code> again, it will be fast.</p>\n<p>Do I make the <code>toString</code> function <code>const</code> (and just use <code>const_cast</code> to store the result), because as long as we separate interface from implementation, <code>toString</code> should be treated as not modifying the object, or should I make it non-const, because it will help the compiler catch errors?</p>\n", "AcceptedAnswerId": "35667571", "Title": "Is const supposed to be used to catch errors or for documentation?", "CreationDate": "2016-02-27T06:04:42.330", "Id": "35666354", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2016-02-27T12:38:22.827", "Score": "4", "OwnerUserId": "1887231", "Tags": "<c++><const>", "AnswerCount": "3"}, "35669885": {"Id": "35669885", "PostTypeId": "2", "Body": "<p>Const has multiple usages, first of all, const is important for documentation. I know people disagree on this, though it clearly shows the intent of the member function or the parameters of a function.</p>\n<p>Secondly, it prevents errors, when you have indicated the intent and you happen to call the wrong function (non-const) this will give compilation error. So either your intent is wrong or the function should not be called.</p>\n<p>Finally, there are exceptions to the rule. Whenever you have some lazy implementation, you should use mutable, as adapting a mutable member is allowed (known in all translation units because in header file) while adapting a const-casted is undefined behavior (hidden in a single function implementation). Personally, I have mixed feeling about using mutable as you have to be careful in multithreading. (So you need either correct locking, std::call_once ... OR you need to know that this ain't called in multithreaded code)</p>\n<p>More details on const-cast and mutable can be found in the standard in 7.1.6.1 and 5.2.11</p>\n<blockquote>\n<p id=\"so_35666354_35669885_0\">Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a const object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n<p>Often people refer to optimization via const. Though this is actually harder than you would expect. I've been following the clang-compiler on this: <a href=\"http://lists.llvm.org/pipermail/llvm-dev/2015-October/091178.html\" rel=\"nofollow\">http://lists.llvm.org/pipermail/llvm-dev/2015-October/091178.html</a>\nwhere you can see that currently only a proof-of-concept is implemented. (I'm not familiar with other implementations)</p>\n<p>So in conclusion:</p>\n<ul>\n<li>Const is used for both documentation and to prevent errors.</li>\n<li>Use mutable over const_cast.</li>\n</ul>\n", "LastActivityDate": "2016-02-27T12:38:22.827", "CommentCount": "0", "CreationDate": "2016-02-27T12:38:22.827", "ParentId": "35666354", "Score": "1", "OwnerUserId": "2466431"}, "35667288": {"Id": "35667288", "PostTypeId": "2", "Body": "<p>Why on earth corect answers end up in the comments...</p>\n<p>It's OK to do have such a function. That approach is given in <a href=\"https://isocpp.org/wiki/faq/const-correctness#const-member-fns\" rel=\"nofollow\">C++ FAQ</a> \"The trailing const on inspect() member function should be used to mean the method won\u2019t change the object\u2019s abstract (client-visible) state\". Just dont use const_cast but mutable, see <a href=\"https://isocpp.org/wiki/faq/const-correctness#mutable-data-members\" rel=\"nofollow\">https://isocpp.org/wiki/faq/const-correctness#mutable-data-members</a>.</p>\n", "LastActivityDate": "2016-02-27T08:05:42.337", "CommentCount": "0", "CreationDate": "2016-02-27T08:05:42.337", "ParentId": "35666354", "Score": "0", "OwnerUserId": "4359761"}});