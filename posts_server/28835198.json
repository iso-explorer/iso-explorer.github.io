post_cb({"28835198": {"CommentCount": "9", "AcceptedAnswerId": "28836383", "PostTypeId": "1", "LastEditorUserId": "1033581", "CreationDate": "2015-03-03T15:08:24.607", "LastActivityDate": "2017-06-18T15:10:50.417", "LastEditDate": "2017-06-18T15:10:50.417", "ViewCount": "282", "FavoriteCount": "1", "Title": "Extern function pointer declaration and type inferred definition", "Id": "28835198", "Score": "11", "Body": "<p>I recently received a code that is accepted by clang++ but not by g++ and I would like to know which one is right.</p>\n<p>The minimalist code reproducing the behavior is very short and talk by itself so I think an explanation would be unnecessarily complicated.</p>\n<p>Here is a header containing an extern pointer declaration :</p>\n<pre><code>//(guards removed for simplicity) :\n#include &lt;type_traits&gt;\n\nusing ptr_func = std::add_pointer&lt;void()&gt;::type;\n\nextern ptr_func pointer;\n</code></pre>\n<p>And here is the source implementing the needed pointed function :</p>\n<pre><code>#include \"function.hh\"\n\nvoid foo() {}\n\nauto pointer = &amp;foo;\n</code></pre>\n<p>The error generated by gcc is as follows :</p>\n<pre><code>g++ -c function.cc -std=c++14\nfunction.cc:5:6: error: conflicting declaration \u2018auto pointer\u2019\n auto pointer = &amp;foo;\n      ^\nIn file included from function.cc:1:0:\nfunction.hh:5:17: note: previous declaration as \u2018void (* pointer)()\u2019\n extern ptr_func pointer;\n                 ^\n</code></pre>\n<p>Clang accepts this code without any error/warning. And replacing the pointer definition by :</p>\n<pre><code>decltype(foo)* pointer = &amp;foo;\n</code></pre>\n<p>is accepted by gcc.</p>\n<p>In my opinion, clang is right, but I am not sure so I would like to know if clang is too permissive or if gcc should accept it.</p>\n", "Tags": "<c++><c++11><function-pointers>", "OwnerUserId": "4628125", "AnswerCount": "1"}, "28836383": {"ParentId": "28835198", "CommentCount": "6", "Body": "<p>This is definitely a bug in gcc. Here's a minimal example:</p>\n<pre><code>int foo;\nextern int* ptr;\nauto ptr = &amp;foo;\n</code></pre>\n<p>Interestingly, gcc is happy if the <code>extern</code> and <code>auto</code> declarations are reversed.</p>\n<p>This seems to be the same as <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60352\" rel=\"noreferrer\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60352</a>, reported last year.</p>\n<p>The relevant clause is <strong>[basic.link]</strong>/10:</p>\n<blockquote>\n<p id=\"so_28835198_28836383_0\">After all adjustments of types (during which typedefs (7.1.3) are replaced by their definitions), the types\n  specified by all declarations referring to a given variable or function shall be identical, except that declarations\n  for an array object can specify array types that differ by the presence or absence of a major array\n  bound (8.3.4). A violation of this rule on type identity does not require a diagnostic.</p>\n</blockquote>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "28836383", "Score": "5", "CreationDate": "2015-03-03T16:05:42.193", "LastActivityDate": "2015-03-03T16:05:42.193"}, "bq_ids": {"n4140": {"so_28835198_28836383_0": {"section_id": 7143, "quality": 0.9512195121951219, "length": 39}}, "n3337": {"so_28835198_28836383_0": {"section_id": 6887, "quality": 0.9512195121951219, "length": 39}}, "n4659": {"so_28835198_28836383_0": {"section_id": 8644, "quality": 0.9512195121951219, "length": 39}}}});