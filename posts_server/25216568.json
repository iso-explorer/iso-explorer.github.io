post_cb({"25216858": {"ParentId": "25216568", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>A garbage-collecting implementation needs to track pointers. In practice this has often been done by using the memory map as a key, so any pointer-sized words in memory within a certain numeric range are treated as bona fide pointers, and as such prevent garbage collection of an allocation block including the given address-value. This strategy is imprecise and C++ aims to do better, yet also supporting existing GC programs.</p>\n<p>Contrary to your intuition, the bullet <em>does</em> effectively enable \"pointer arithmetic on <code>void*</code>.\" An integer (<code>std::intptr_t</code>) obtained from a pointer by <code>reinterpret_cast</code> must also be tracked as a pointer, and the object continues to affect garbage collection as such even if it is modified by addition or bitwise operations.</p>\n<pre><code>std::uintptr_t handle1 = reinterpret_cast&lt; std::uintptr_t &gt;( new foo );\nstd::uintptr_t handle2 = reinterpret_cast&lt; std::uintptr_t &gt;( new foo );\n// handle1 and handle2 won't be collected, despite no pointer-type references.\n\nstd::uintptr_t diff = handle2 - handle1; // not a pointer\n\nstd::uintptr_t sum = handle1 + diff; // sum refers to handle2\nhandle2 = 0; // Invalidate original reference to handle2\n\n// At this point, the second foo is still reachable via sum.\n</code></pre>\n<p>Strict pointer safety improves the status quo, but false positives are still possible, when operations that satisfy the rule do not generate an actual pointer representation. For example, it's not clear from the standard text whether <code>diff</code> is traceable, because it's the result of a difference operation with two safely-derived operands, as opposed to an addition with exactly one safely-derived operand. (Whether or not is somewhat immaterial, false positives are going to occur anyway.)</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2014-08-09T09:06:01.057", "Id": "25216858", "Score": "0", "CreationDate": "2014-08-09T08:53:03.363", "LastActivityDate": "2014-08-09T09:06:01.057"}, "bq_ids": {"n4140": {"so_25216568_25216568_0": {"section_id": 6138, "quality": 0.9545454545454546, "length": 21}, "so_25216568_25216568_1": {"section_id": 7186, "quality": 1.0, "length": 22}}, "n3337": {"so_25216568_25216568_0": {"section_id": 5902, "quality": 0.9545454545454546, "length": 21}, "so_25216568_25216568_1": {"section_id": 6930, "quality": 1.0, "length": 22}}, "n4659": {"so_25216568_25216568_0": {"section_id": 7635, "quality": 0.9545454545454546, "length": 21}, "so_25216568_25216568_1": {"section_id": 8694, "quality": 1.0, "length": 22}}}, "25216568": {"CommentCount": "13", "ViewCount": "208", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-08-09T08:09:49.317", "LastActivityDate": "2014-08-09T09:06:01.057", "LastEditDate": "2017-05-23T10:28:34.477", "AcceptedAnswerId": "25216858", "OwnerDisplayName": "user2953119", "Title": "Example of safely derived pointer value", "Id": "25216568", "Score": "3", "Body": "<p>I'm using N3797 working draft.</p>\n<p>Section 5.7/1 says:</p>\n<blockquote>\n<p id=\"so_25216568_25216568_0\">[...] For addition, either both operands shall have arithmetic or\n  unscoped enumeration type, or one operand shall be a pointer to a\n  <strong>completely-defined object</strong> type and the other shall have integral or\n  unscoped enumeration type.</p>\n</blockquote>\n<p>Ok. But consider the rule from the section 3.7.4.3/3:</p>\n<blockquote>\n<p id=\"so_25216568_25216568_1\">\u2014 the result of an additive or bitwise operation, one of whose\n  operands is an integer representation of a safely-derived pointer\n  value <code>P</code>, if that result converted by <code>reinterpret_cast&lt;void*&gt;</code> would\n  compare equal to a safely-derived pointer computable from\n  <code>reinterpret_cast&lt;void*&gt;(P)</code>.</p>\n</blockquote>\n<p>That is, we cannot apply pointer arithmetic to a pointer to <code>void</code>. Could you possibly provide an example reflecting the rule from <strong>3.7.4.3</strong>?</p>\n<p>The similiar <a href=\"https://stackoverflow.com/q/25174236/390913\">question</a> doesn't provide  a suitable example, because the pointer to void arithmetic appers here.</p>\n", "Tags": "<c++><pointers>", "AnswerCount": "2"}, "25216812": {"ParentId": "25216568", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>All that 3.7.4.3/3 is saying is that if you have an \"integer representation of a safely derived pointer\", and do math with it, the result is only a valid \"integer representation of a safely derived pointer\" if you could have come to the same result with pointer arithmetic and casting alone.</p>\n<p>Although you are not allowed to do arithmetic operations on <code>void*</code> directy, there are various other ways of obtaining a valid pointer from <code>void*</code>.  Although I'm too lazy to back every step with quotes from the standard, the following example should be valid:</p>\n<pre><code>double arr[10];\ndouble* P = &amp;arr[0]; // safely derived pointer\nintptr_t N = reinterpret_cast&lt;intptr_t&gt;(P); // valid integer repr\n\nvoid* V = reinterpret_cast&lt;void*&gt;(P);\n\n// Compute &amp;a[1] from V\nvoid* V2 = reinterpret_cast&lt;void*&gt;(\n    static_cast&lt;char*&gt;(V) + sizeof(double));\n\n// Do the same with N\nintptr_t N2 = N + sizeof(double);\n\nassert(reinterpret_cast&lt;void*&gt;(N2) == V2);\n</code></pre>\n<ul>\n<li>V2 is a <em>safely-derived pointer computable from <code>reinterpret_cast&lt;void*&gt;(P)</code></em></li>\n<li>N2 is <em>the result of an additive or bitwise operation, one of whose operands (N) is an integer representation of a safely-derived pointer value P</em></li>\n</ul>\n<p>Since V2 and N2 compare equal, N2 is a an \"integer representation of a safely derived pointer\" as well.</p>\n", "OwnerUserId": "34855", "LastEditorUserId": "34855", "LastEditDate": "2014-08-09T08:54:24.147", "Id": "25216812", "Score": "2", "CreationDate": "2014-08-09T08:46:38.300", "LastActivityDate": "2014-08-09T08:54:24.147"}});