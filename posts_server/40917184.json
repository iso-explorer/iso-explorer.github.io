post_cb({"bq_ids": {"n4140": {"so_40917184_40923625_4": {"length": 9, "quality": 1.0, "section_id": 6168}}, "n3337": {"so_40917184_40923625_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 5929}, "so_40917184_40923625_4": {"length": 9, "quality": 1.0, "section_id": 5929}}, "n4659": {"so_40917184_40923625_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 7667}, "so_40917184_40923625_4": {"length": 9, "quality": 1.0, "section_id": 7665}}}, "40923625": {"Id": "40923625", "PostTypeId": "2", "Body": "<p>Before C++14, the standard provided that the result of an expression of the form <code>false ? throw 1 : x</code> is a copy of <code>x</code> rather than <code>x</code> itself (technically, it applies the lvalue-to-rvalue, array-to-pointer, and function-to-pointer conversions on <code>x</code> to yield a prvalue). <a href=\"https://timsong-cpp.github.io/cppwp/n3337/expr.cond#2\" rel=\"nofollow noreferrer\">N3337 [expr.cond]/2</a>:</p>\n<blockquote>\n<p id=\"so_40917184_40923625_0\">If either the second or the third operand has type <code>void</code>, then the\n  lvalue-to-rvalue ([conv.lval]), array-to-pointer ([conv.array]), and\n  function-to-pointer ([conv.func]) standard conversions are performed\n  on the second and third operands, and one of the following shall hold:</p>\n<ul>\n<li>The second or the third operand (but not both) is a <em>throw-expression</em> ([except.throw]); the result is of the type of the other and is a prvalue.</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>This was changed by <a href=\"http://wg21.link/CWG1560\" rel=\"nofollow noreferrer\">Core issue 1560</a>:</p>\n<blockquote>\n<p id=\"so_40917184_40923625_1\">A glvalue appearing as one operand of a conditional-expression in\n  which the other operand is a throw-expression is converted to a\n  prvalue, regardless of how the conditional-expression is used:</p>\n<p id=\"so_40917184_40923625_2\">[...]</p>\n<p id=\"so_40917184_40923625_3\">This seems to be gratuitous and surprising.</p>\n</blockquote>\n<p>and the paragraph <a href=\"https://timsong-cpp.github.io/cppwp/expr.cond#2\" rel=\"nofollow noreferrer\">now reads</a>:</p>\n<blockquote>\n<p id=\"so_40917184_40923625_4\">If either the second or the third operand has type <code>void</code>, one of the\n  following shall hold:</p>\n<ul>\n<li>The second or the third operand (but not both) is a (possibly parenthesized) <em>throw-expression</em> ([expr.throw]); the result is of the\n  type and value category of the other. The <em>conditional-expression</em> is\n  a bit-field if that operand is a bit-field.</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>MSVC simply hasn't gotten around to implementing the fix yet. Clang 3.5+ does have it implemented.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2016-12-02T02:13:58.670", "Score": "2", "CreationDate": "2016-12-02T02:06:06.480", "ParentId": "40917184", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2016-12-02T02:13:58.670"}, "40917891": {"Id": "40917891", "PostTypeId": "2", "Body": "<p><strong>Standard writes in 8.5.4.1: List-initialization</strong></p>\n<p>Note: List-initialization can be used</p>\n<ul>\n<li>as the initializer in a variable definition (8.5)</li>\n<li>as the initializer in a new expression (5.3.4)</li>\n<li>in a return statement (6.6.3)</li>\n<li>as a function argument (5.2.2)</li>\n<li>as a subscript (5.2.1)</li>\n<li>as an argument to a constructor invocation (8.5, 5.2.3)</li>\n<li>as an initializer for a non-static data member (9.2)</li>\n<li>in a mem-initializer (12.6.2)</li>\n<li>on the right-hand side of an assignment (5.17)</li>\n</ul>\n<p>The more minimalistic <code>return 1?{}:{};</code> is invalid too, what you want is impossible.</p>\n", "LastActivityDate": "2016-12-01T18:29:25.147", "CommentCount": "4", "CreationDate": "2016-12-01T18:29:25.147", "ParentId": "40917184", "Score": "1", "OwnerUserId": "5088532"}, "40917184": {"ViewCount": "67", "Body": "<p>For some reason, the second method will not work. </p>\n<pre><code>concurrency::event&lt;void( event_data&amp; ), codec_cvt&gt; &amp;get_event( const string_type &amp;event )\n{\n        auto it = events_.find( event );\n        if ( it == events_.end( ) )\n            throw /* exception */;\n        return *it-&gt;second;\n}\n</code></pre>\n<p>However, this method using my preffered syntax is returning an address of a temporary. When it should be exactly, correct?</p>\n<pre><code>concurrency::event&lt;void( event_data&amp; ), codec_cvt&gt; &amp;get_event( const string_type &amp;event )\n{\n    auto it = events_.find( event );\n    return it != events_.end( ) ?\n        *it-&gt;second :\n        throw;\n }\n</code></pre>\n", "AcceptedAnswerId": "40923625", "Title": "Returning reference using a ternery expression causes runtime error", "CreationDate": "2016-12-01T17:48:04.420", "Id": "40917184", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2016-12-02T02:13:58.670", "Score": "2", "OwnerUserId": "6827464", "Tags": "<c++><c++11><visual-c++>", "AnswerCount": "2"}});