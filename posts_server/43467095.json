post_cb({"43467095": {"ViewCount": "3165", "Body": "<p>Consider the following example:</p>\n<pre><code>#include &lt;cstdlib&gt;\n\nint main() {\n    const int m = 42;\n    [] { m; }(); // OK\n\n    const int n = std::rand();\n    [] { n; }(); // error: 'n' is not captured\n}\n</code></pre>\n<p>Why do I need to capture <code>n</code> in the second lambda but not <code>m</code> in the first lambda? I checked section 5.1.2 (<em>Lambda expressions</em>) in the C++14 standard but I was unable to find a reason. Can you point me to a paragraph in which this is explained?</p>\n<p>Update: I observed this behavior with both GCC 6.3.1 and 7 (trunk). Clang 4.0 and 5 (trunk) fails with an error in both cases (<code>variable 'm' cannot be implicitly captured in a lambda with no capture-default specified</code>).</p>\n", "AcceptedAnswerId": "43468519", "Title": "Why is a const variable sometimes not required to be captured in a lambda?", "CreationDate": "2017-04-18T08:19:03.827", "Id": "43467095", "CommentCount": "7", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2017-04-18T09:32:22.340", "LastEditorUserId": "2079303", "LastActivityDate": "2017-04-18T11:06:41.550", "Score": "61", "OwnerUserId": "2580955", "Tags": "<c++><lambda><const><language-lawyer>", "AnswerCount": "3"}, "43468519": {"Id": "43468519", "PostTypeId": "2", "Body": "<p>For a lambda at block scope, variables meeting certain criteria in the <em>reaching scope</em> may be used in limited ways inside the lambda, even if they are not captured.</p>\n<p>Roughly speaking, <em>reaching scope</em> includes any variable local to the function containing the lambda, that would be in scope at the point the lambda was defined.  So this includes <code>m</code> and <code>n</code> in the above examples.</p>\n<p>The \"certain criteria\" and \"limited ways\" are specifically (as of C++14):</p>\n<ul>\n<li>Inside the lambda, the variable must not be <em>odr-used</em>, which means it must not undergo any operation except for:\n\n<ul>\n<li>appearing as a discarded-value expression  (<code>m;</code> is one of these), or</li>\n<li>having its value retrieved.</li>\n</ul></li>\n<li>The variable must either be:\n\n<ul>\n<li>A <code>const</code>, non-<code>volatile</code> integer or enum whose initializer was a <em>constant expression</em>, or</li>\n<li>A <code>constexpr</code>, non-<code>volatile</code> variable (or a sub-object of such)</li>\n</ul></li>\n</ul>\n<p>References to C++14: [expr.const]/2.7, [basic.def.odr]/3 (first sentence), [expr.prim.lambda]/12, [expr.prim.lambda]/10.</p>\n<p>The rationale for these rules, as suggested by other comments/answers, is that the compiler needs to be able to \"synthesize\" a no-capture lambda as a free function independent of the block (since such things can be converted to a pointer-to-function); it can do this despite referring to the variable if it knows that the variable would always have the same value, or it can repeat the procedure for obtaining the variable's value independent of the context.  But it can't do this if the variable could differ from time to time, or if the variable's address is needed for example.</p>\n<hr>\n<p>In your code, <code>n</code> was initialized by a non-constant expression.  Therefore <code>n</code> cannot be used in a lambda without being captured. </p>\n<p><code>m</code> was initialized by a constant expression <code>42</code>, so it does meet the \"certain criteria\". A discarded-value expression does not odr-use the expression, so <code>m;</code> can be used without <code>m</code> being captured.  gcc is correct.</p>\n<hr>\n<p>I would say that the difference between the two compilers is that clang considers <code>m;</code> to odr-use <code>m</code>, but gcc does not.  The first sentence of [basic.def.odr]/3 is quite complicated:</p>\n<blockquote>\n<p id=\"so_43467095_43468519_0\">A variable <code>x</code> whose name appears as a potentially-evaluated expression <code>ex</code> is <em>odr-used</em> by <code>ex</code> unless applying the lvalue-to-rvalue conversion to <code>x</code> yields a constant expression that does not invoke any non-trivial functions and, if <code>x</code> is an object, <code>ex</code> is an element of the set of potential results of an expression <code>e</code>, where either the lvalue-to-rvalue conversion is applied to <code>e</code>, or <code>e</code> is a discarded-value expression.</p>\n</blockquote>\n<p>but upon reading closely it does specifically mention that a discarded-value expression does not <em>odr-use</em> the expression.</p>\n<p>C++11's version of [basic.def.odr] originally did not include the discarded-value expression case, so clang's behaviour would be correct under the published C++11. However the text that appears in C++14 was accepted as a Defect against C++11 (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#712\" rel=\"noreferrer\">Issue 712</a>), so compilers should update their behaviour even in C++11 mode.</p>\n</hr></hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2017-04-18T11:00:23.337", "Score": "44", "CreationDate": "2017-04-18T09:33:48.933", "ParentId": "43467095", "CommentCount": "4", "LastEditDate": "2017-04-18T11:00:23.337", "OwnerUserId": "1505939"}, "43467280": {"Id": "43467280", "PostTypeId": "2", "Body": "<p>EDIT: The previous version of my answer was wrong. Beginner's is correct, here is relevant standard quote:</p>\n<p><a href=\"http://eel.is/c++draft/basic.def.odr#3\" rel=\"nofollow noreferrer\">[basic.def.odr]</a></p>\n<blockquote id=\"so_43467095_43467280_0\">\n<ol start=\"3\">\n<li>A variable x whose name appears as a potentially-evaluated expression ex is <strong>odr-used</strong> by ex unless applying the <a href=\"http://eel.is/c++draft/conv.lval\" rel=\"nofollow noreferrer\">lvalue-to-rvalue</a> conversion to x yields a <a href=\"http://eel.is/c++draft/expr.const\" rel=\"nofollow noreferrer\">constant expression</a> that does not invoke any non-trivial functions and, if x is an object, ex is an element of the set of potential results of an expression e, where either the lvalue-to-rvalue conversion is applied to e, or e is a discarded-value expression. ...</li>\n</ol>\n</blockquote>\n<p>Since <code>m</code> is a constant expression, it is not odr-used and therefore does not need to be captured.</p>\n<p>It appears that clangs behaviour is not compliant with the standard.</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2017-04-18T09:27:55.290", "Score": "2", "CreationDate": "2017-04-18T08:28:27.480", "ParentId": "43467095", "CommentCount": "10", "LastEditDate": "2017-04-18T09:27:55.290", "OwnerUserId": "2079303"}, "bq_ids": {"n4140": {"so_43467095_43467268_0": {"length": 19, "quality": 1.0, "section_id": 5972}, "so_43467095_43467280_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 7040}, "so_43467095_43467268_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 7040}, "so_43467095_43468519_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 7040}}, "n3337": {"so_43467095_43467268_0": {"length": 13, "quality": 0.6842105263157895, "section_id": 5740}, "so_43467095_43467268_1": {"length": 10, "quality": 0.6666666666666666, "section_id": 6785}}, "n4659": {"so_43467095_43467268_0": {"length": 19, "quality": 1.0, "section_id": 7471}, "so_43467095_43467280_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 8537}, "so_43467095_43467268_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 8537}, "so_43467095_43468519_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 8537}}}, "43467268": {"Id": "43467268", "PostTypeId": "2", "Body": "<p>Its because it is a constant expression, the compiler treats is as if it were <code>[] { 42; }();</code> </p>\n<p>The rule in [<a href=\"https://timsong-cpp.github.io/cppwp/expr.prim.lambda.capture#4\" rel=\"noreferrer\">expr.prim.lambda</a>] is:</p>\n<blockquote>\n<p id=\"so_43467095_43467268_0\">If a lambda-expression or an instantiation of the function call\n  operator template of a generic lambda odr-uses (3.2) this or a\n  variable with automatic storage duration from its reaching scope,\n  that entity shall be captured by the lambda-expression.</p>\n</blockquote>\n<p>Here a quote from the standard [<a href=\"http://eel.is/c++draft/basic.def.odr#3\" rel=\"noreferrer\">basic.def.odr</a>]: </p>\n<blockquote>\n<p id=\"so_43467095_43467268_1\">A variable x whose name\n  appears as a potentially-evaluated expression ex is odr-used unless\n  applying the lvalue-to-rvalue conversion to x yields a constant expression (...) or e is a discarded-value expression.</p>\n</blockquote>\n<p>(Removed not so important part to keep it short)</p>\n<p>My simple understanding is: the compiler knows that <code>m</code> is constant at compile-time, whereas <code>n</code> will change at run-time and therefore <code>n</code> has to be captured. <code>n</code> would be odr-used, because you have to actually take a look at what is inside <code>n</code> at run time. In other words the fact that \"there can be only one\" definition of <code>n</code> is relevant.</p>\n<p>This is from a comment by M.M: </p>\n<blockquote>\n<p id=\"so_43467095_43467268_2\">m is a constant expression because it's a const automatic variable\n  with constant expression initializer, but n is not a constant\n  expression because its initializer was not a constant expression. This\n  is covered in [expr.const]/2.7. The constant expression is not\n  ODR-used, according to first sentence of [basic.def.odr]/3</p>\n</blockquote>\n<p>See here for a <a href=\"http://ideone.com/o8WIO1\" rel=\"noreferrer\">demo</a>.</p>\n", "LastEditorUserId": "3867787", "LastActivityDate": "2017-04-18T11:06:41.550", "Score": "30", "CreationDate": "2017-04-18T08:28:01.603", "ParentId": "43467095", "CommentCount": "5", "LastEditDate": "2017-04-18T11:06:41.550", "OwnerUserId": "3867787"}});