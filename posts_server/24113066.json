post_cb({"24113446": {"ParentId": "24113066", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>First off, trying to use a deleted object in any form results in undefined behavior: whatever result you see could happen!</p>\n<p>The reason of the observed behavior is simply that an object changes type during destruction: from being an object of the concrete type it change through all of the types in the hierarchy. At each point the virtual functions change and the vtable (or similar) gets replaced. The <code>dynamic_cast&lt;...&gt;()</code> simply detects this change in the bytes strored at the location of the object.</p>\n<p>In case you feel like wanting to show that this technique doesn't reliably work you can just set the content of deleted memory to a random bit pattern or the bit pattern of an object of the most derived type: a random bit pattern probably yields a crash and <code>memcpy()</code> probably claims that the object is still life. Of course, since it is undefined behavior anything can happen.</p>\n<p>One relevant section on this 3.8 [basic.life] paragraph 5:</p>\n<blockquote>\n<p id=\"so_24113066_24113446_0\">Before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways. For an object under construction or destruction, see 12.7. Otherwise, such a pointer refers to allocated storage (3.7.4.2), and using the pointer as if the pointer were of type <code>void*</code>,\n  is well-defined. Indirection through such a pointer is permitted but the resulting lvalue may only be used in limited ways, as described below. The program has undefined behavior if:</p>\n<ul>\n<li>...</li>\n<li>the pointer is used as the operand of a dynamic_cast (5.2.7). ...</li>\n</ul>\n</blockquote>\n<p>Oddly, the example on the last bullet on <code>dynamic_cast</code> doesn't use <code>dynamic_cast</code>.</p>\n<p>Of course, the object is also probably released in which case the above guarantees don't even apply. </p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2014-06-09T04:10:54.690", "Id": "24113446", "Score": "6", "CreationDate": "2014-06-09T03:53:04.880", "LastActivityDate": "2014-06-09T04:10:54.690"}, "bq_ids": {"n4140": {"so_24113066_24113446_0": {"section_id": 7193, "quality": 0.9444444444444444, "length": 68}}, "n3337": {"so_24113066_24113446_0": {"section_id": 6937, "quality": 0.8888888888888888, "length": 64}}, "n4659": {"so_24113066_24113446_0": {"section_id": 8702, "quality": 0.9305555555555556, "length": 67}}}, "24113066": {"CommentCount": "5", "AcceptedAnswerId": "24113446", "PostTypeId": "1", "LastEditorUserId": "119527", "CreationDate": "2014-06-09T02:54:52.090", "LastActivityDate": "2014-06-09T04:10:54.690", "LastEditDate": "2014-06-09T02:57:51.467", "ViewCount": "592", "FavoriteCount": "4", "Title": "How is the deletion of a pointer detected using dynamic cast", "Id": "24113066", "Score": "8", "Body": "<p>As shown <a href=\"http://www.devx.com/tips/Tip/28143\" rel=\"noreferrer\">here</a>, one can use <code>dynamic_cast</code> to detect a deleted pointer:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass A\n{\npublic:\n   A() {}\n   virtual ~A() {}\n};\n\nclass B : public A\n{\npublic:\n   B() {}\n};\n\nint main()\n{\n   B* pB =  new B;\n\n   cout &lt;&lt; \"dynamic_cast&lt;B*&gt;( pB) \";\n   cout &lt;&lt; ( dynamic_cast&lt;B*&gt;(pB) ? \"worked\" : \"failed\") &lt;&lt; endl;  \n\n   cout &lt;&lt; \"dynamic_cast&lt;B*&gt;( (A*)pB) \";\n   cout &lt;&lt; ( dynamic_cast&lt;B*&gt;( (A*)pB) ? \"worked\" : \"failed\") &lt;&lt; endl;  \n\n   delete pB; \n\n   cout &lt;&lt; \"dynamic_cast&lt;B*&gt;( pB) \";\n   cout &lt;&lt; ( dynamic_cast&lt;B*&gt;(pB) ? \"worked\" : \"failed\") &lt;&lt; endl;  \n\n   cout &lt;&lt; \"dynamic_cast&lt;B*&gt;( (A*)pB) \";\n   cout &lt;&lt; ( dynamic_cast&lt;B*&gt;( (A*)pB) ? \"worked\" : \"failed\") &lt;&lt; endl;  \n\n}\n</code></pre>\n<p><em>the output:</em></p>\n<pre class=\"lang-none prettyprint-override\"><code>dynamic_cast&lt;B*&gt;( pB) worked\ndynamic_cast&lt;B*&gt;( (A*)pB) worked\ndynamic_cast&lt;B*&gt;( pB) worked\ndynamic_cast&lt;B*&gt;( (A*)pB) failed\n</code></pre>\n<p>It explains that the deletion of the vtable is detected. </p>\n<p>But I am wondering how is that possible since we do not overwrite the freed memory?</p>\n<p>And is that solution fully portable ?</p>\n<p>Thanks</p>\n", "Tags": "<c++><vtable><dynamic-cast>", "OwnerUserId": "1271079", "AnswerCount": "1"}});