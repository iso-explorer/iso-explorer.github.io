post_cb({"32788961": {"ParentId": "32788663", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2015-09-25T19:01:30.857", "Score": "3", "LastEditorUserId": "4342498", "LastEditDate": "2015-09-25T19:09:54.940", "Id": "32788961", "OwnerUserId": "4342498", "Body": "<p>C++14 standard \u00a714.7(3) has</p>\n<blockquote>\n<p id=\"so_32788663_32788961_0\">An explicit specialization may be declared for a function template, a class template, a member of a class template or a member template. An explicit specialization declaration is introduced by template&lt;&gt;. In an explicit specialization declaration for a class template, a member of a class template or a class member template, the name of the class that is explicitly specialized shall be a simple-template-id. In the explicit specialization declaration for a function template or a member function template, the name of the function or member function explicitly specialized may be a template-id.</p>\n</blockquote>\n<p>And then demonstrates</p>\n<blockquote id=\"so_32788663_32788961_1\">\n<pre><code>template&lt;class U&gt; void g(U) { }\ntemplate&lt;&gt; void g(char) { }       //specialize for U == char\n                                  // U is deduced from the parameter type\n</code></pre>\n</blockquote>\n<p>And then we have \u00a714.7.3(10)</p>\n<blockquote>\n<p id=\"so_32788663_32788961_2\">A trailing template-argument can be left unspecified in the template-id naming an explicit function template specialization provided it can be deduced from the function argument type. [ Example:</p>\n<pre><code>template&lt;class T&gt; class Array { / ... / };\ntemplate&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v);\n\n// explicit specialization for sort(Array&lt;int&gt;&amp;)\n// with deduced template-argument of type int\ntemplate&lt;&gt; void sort(Array&lt;int&gt;&amp;);\n</code></pre>\n<p id=\"so_32788663_32788961_3\">\u2014end example ]</p>\n</blockquote>\n", "LastActivityDate": "2015-09-25T19:09:54.940"}, "32788663": {"CommentCount": "4", "ViewCount": "89", "PostTypeId": "1", "LastEditorUserId": "176922", "CreationDate": "2015-09-25T18:41:13.830", "LastActivityDate": "2015-09-25T19:39:00.027", "Title": "Syntax for explicit template specializations", "AcceptedAnswerId": "32788961", "LastEditDate": "2015-09-25T19:39:00.027", "Id": "32788663", "Score": "4", "Body": "<p>The following is accepted by both gcc-4.9.2 and clang-3.8 when compiling as C++98 or C++11,</p>\n<pre><code>#include &lt;cstdio&gt;\n\ntemplate &lt;typename T&gt; void f(T) { printf(\"T\\n\"); }\ntemplate &lt;&gt; void f&lt;int&gt;(int) { printf(\"int\\n\"); }    // explicit specialization\ntemplate &lt;&gt; void f&lt;&gt;(double) { printf(\"double\\n\"); } // explicit specialization -- 14.7.2(7)\ntemplate &lt;&gt; void f(float) { printf(\"float\\n\"); }     // HERE\n\nint main() {\n  f(1L);    // T\n  f(10);    // int\n  f(10.0);  // double\n  f(10.0F); // float\n}\n</code></pre>\n<p>I see that in the C++11 standard \u00a714.7.2(7) deducing trailing template arguments in explicit template specializations is permitted, but I cannot find whether or how the terser form marked <code>HERE</code> is allowed.</p>\n<p>Are these compilers conformant or is this some extension?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "176922", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32788663_32788961_2": {"section_id": 272, "quality": 0.9444444444444444, "length": 17}, "so_32788663_32788961_0": {"section_id": 229, "quality": 1.0, "length": 50}}, "n3337": {"so_32788663_32788961_2": {"section_id": 263, "quality": 0.9444444444444444, "length": 17}, "so_32788663_32788961_0": {"section_id": 222, "quality": 1.0, "length": 50}}, "n4659": {"so_32788663_32788961_2": {"section_id": 279, "quality": 0.9444444444444444, "length": 17}, "so_32788663_32788961_0": {"section_id": 237, "quality": 1.0, "length": 50}}}});