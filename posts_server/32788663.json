post_cb({"bq_ids": {"n4140": {"so_32788663_32788961_0": {"length": 50, "quality": 1.0, "section_id": 229}, "so_32788663_32788961_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 272}}, "n3337": {"so_32788663_32788961_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 263}, "so_32788663_32788961_0": {"length": 50, "quality": 1.0, "section_id": 222}}, "n4659": {"so_32788663_32788961_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 279}, "so_32788663_32788961_0": {"length": 50, "quality": 1.0, "section_id": 237}}}, "32788961": {"Id": "32788961", "PostTypeId": "2", "Body": "<p>C++14 standard \u00a714.7(3) has</p>\n<blockquote>\n<p id=\"so_32788663_32788961_0\">An explicit specialization may be declared for a function template, a class template, a member of a class template or a member template. An explicit specialization declaration is introduced by template&lt;&gt;. In an explicit specialization declaration for a class template, a member of a class template or a class member template, the name of the class that is explicitly specialized shall be a simple-template-id. In the explicit specialization declaration for a function template or a member function template, the name of the function or member function explicitly specialized may be a template-id.</p>\n</blockquote>\n<p>And then demonstrates</p>\n<blockquote id=\"so_32788663_32788961_1\">\n<pre><code>template&lt;class U&gt; void g(U) { }\ntemplate&lt;&gt; void g(char) { }       //specialize for U == char\n                                  // U is deduced from the parameter type\n</code></pre>\n</blockquote>\n<p>And then we have \u00a714.7.3(10)</p>\n<blockquote>\n<p id=\"so_32788663_32788961_2\">A trailing template-argument can be left unspecified in the template-id naming an explicit function template specialization provided it can be deduced from the function argument type. [ Example:</p>\n<pre><code>template&lt;class T&gt; class Array { / ... / };\ntemplate&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v);\n\n// explicit specialization for sort(Array&lt;int&gt;&amp;)\n// with deduced template-argument of type int\ntemplate&lt;&gt; void sort(Array&lt;int&gt;&amp;);\n</code></pre>\n<p id=\"so_32788663_32788961_3\">\u2014end example ]</p>\n</blockquote>\n", "LastEditorUserId": "4342498", "LastActivityDate": "2015-09-25T19:09:54.940", "Score": "3", "CreationDate": "2015-09-25T19:01:30.857", "ParentId": "32788663", "CommentCount": "6", "LastEditDate": "2015-09-25T19:09:54.940", "OwnerUserId": "4342498"}, "32788663": {"ViewCount": "89", "Body": "<p>The following is accepted by both gcc-4.9.2 and clang-3.8 when compiling as C++98 or C++11,</p>\n<pre><code>#include &lt;cstdio&gt;\n\ntemplate &lt;typename T&gt; void f(T) { printf(\"T\\n\"); }\ntemplate &lt;&gt; void f&lt;int&gt;(int) { printf(\"int\\n\"); }    // explicit specialization\ntemplate &lt;&gt; void f&lt;&gt;(double) { printf(\"double\\n\"); } // explicit specialization -- 14.7.2(7)\ntemplate &lt;&gt; void f(float) { printf(\"float\\n\"); }     // HERE\n\nint main() {\n  f(1L);    // T\n  f(10);    // int\n  f(10.0);  // double\n  f(10.0F); // float\n}\n</code></pre>\n<p>I see that in the C++11 standard \u00a714.7.2(7) deducing trailing template arguments in explicit template specializations is permitted, but I cannot find whether or how the terser form marked <code>HERE</code> is allowed.</p>\n<p>Are these compilers conformant or is this some extension?</p>\n", "AcceptedAnswerId": "32788961", "Title": "Syntax for explicit template specializations", "CreationDate": "2015-09-25T18:41:13.830", "Id": "32788663", "CommentCount": "4", "LastEditDate": "2015-09-25T19:39:00.027", "PostTypeId": "1", "LastEditorUserId": "176922", "LastActivityDate": "2015-09-25T19:39:00.027", "Score": "4", "OwnerUserId": "176922", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}});