post_cb({"bq_ids": {"n4140": {"so_12811426_12814921_1": {"length": 4, "quality": 0.8, "section_id": 3123}, "so_12811426_12814921_0": {"length": 4, "quality": 0.8, "section_id": 3122}}, "n3337": {"so_12811426_12814921_1": {"length": 4, "quality": 0.8, "section_id": 3000}, "so_12811426_12814921_0": {"length": 4, "quality": 0.8, "section_id": 2999}}, "n4659": {"so_12811426_12814921_1": {"length": 4, "quality": 0.8, "section_id": 3885}, "so_12811426_12814921_0": {"length": 4, "quality": 0.8, "section_id": 3884}}}, "12811426": {"ViewCount": "225", "Body": "<p>I am writing a DCPU-16 emulator and I am calculating the real time clock speed of the CPU by launching a thread that calls the function getRealTimeCPUClock() in a separate thread.  The problem is it seems that the future object's \"valid\" attribute is true even when it has not returned a value.  As a result, when calling futureObj.get(), it then waits for getRealTimeCPUClock() to return.  </p>\n<p>With a launch policy of async (as opposed to deferred) isn't it supposed to launch the function into the background and then when it returns set the valid attribute to true?  </p>\n<p>Is this the wrong usage?</p>\n<pre><code>int getRealTimeCPUClock() {\n    int cyclesBeforeTimer = totalCycles;\n    sleep(1);\n\n    return totalCycles - cyclesBeforeTimer;\n}\n\nvoid startExecutionOfProgram(char *programFileName)\n{\n    size_t lengthOfProgramInWords = loadProgramIntoRAM(programFileName);\n    auto futureRealTimeClockSpeed = std::async(std::launch::async, getRealTimeCPUClock);\n\n    while(programCounter &lt; lengthOfProgramInWords) {\n\n        if(futureRealTimeClockSpeed.valid()) {\n            realTimeClockSpeed = futureRealTimeClockSpeed.get();\n            futureRealTimeClockSpeed = std::async(std::launch::async, getRealTimeCPUClock);\n        }\n        step(); \n    }\n}\n</code></pre>\n", "AcceptedAnswerId": "12814921", "Title": "std::async doesn't seem to spawn thread with std::launch::async", "CreationDate": "2012-10-10T03:09:30.697", "Id": "12811426", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2012-10-10T07:45:23.993", "LastEditorUserId": "743214", "LastActivityDate": "2012-10-10T09:13:52.663", "Score": "1", "OwnerUserId": "1431074", "Tags": "<c++><multithreading><stdasync>", "AnswerCount": "1"}, "12814921": {"Id": "12814921", "PostTypeId": "2", "Body": "<p><code>valid()</code> does not what you think it does (although the entry in <a href=\"http://en.cppreference.com/w/cpp/thread/future\" rel=\"nofollow\">cppreference</a> suggests otherwise).</p>\n<p>Here is what the Standard says about <code>valid()</code>:</p>\n<blockquote>\n<p id=\"so_12811426_12814921_0\">(\u00a7 30.6.6/18)\n  bool valid() const noexcept;</p>\n<p id=\"so_12811426_12814921_1\">Returns: true only if *this refers to a shared state.</p>\n</blockquote>\n<p>The value returned by <code>valid()</code> will be <code>true</code> as long as long as the <code>future</code> object is associated with a valid shared state, which is generally the case after you launched it using <code>std::async</code> and before you retrieve the result (using <code>get()</code>). The <code>future</code> will also be invalidated when you use the <code>share()</code> method to create a <code>shared_future</code>. None of this is related to what you are trying to do, i.e. checking whether the result is available.</p>\n<p>To determine whether the result of a <code>future</code> is ready, I suggest using the <code>wait_for()</code> function with a delay of 0:</p>\n<pre><code>if (futureRealTimeClockSpeed.wait_for(std::chrono::seconds(0))\n          == std::future_status::ready)\n   /*...*/\n</code></pre>\n", "LastEditorUserId": "743214", "LastActivityDate": "2012-10-10T09:13:52.663", "Score": "3", "CreationDate": "2012-10-10T08:16:41.420", "ParentId": "12811426", "CommentCount": "2", "LastEditDate": "2012-10-10T09:13:52.663", "OwnerUserId": "777186"}});