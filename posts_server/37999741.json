post_cb({"bq_ids": {"n4140": {"so_37999741_38000200_0": {"length": 4, "quality": 1.0, "section_id": 7042}}, "n3337": {"so_37999741_38000200_0": {"length": 4, "quality": 1.0, "section_id": 6787}}, "n4659": {"so_37999741_38000200_0": {"length": 4, "quality": 1.0, "section_id": 8539}}}, "38000200": {"Id": "38000200", "PostTypeId": "2", "Body": "<p>Your code is well-defined:</p>\n<p>N4594 3.2/5</p>\n<blockquote>\n<p id=\"so_37999741_38000200_0\">[...]<strong>A class type T must be complete if</strong>:</p>\n<ul>\n<li>(5.1)\n  an object of type T is defined (3.1), or</li>\n<li>(5.2)\n  a non-static class data member of type T is declared (9.2), or</li>\n<li>(5.3)\n  T is used as the object type or array element type in a new-expression (5.3.4), or</li>\n<li>(5.4)\n  an lvalue-to-rvalue conversion is applied to a glvalue referring to an object of type T (4.1), or</li>\n<li>(5.5)\n  an expression is converted (either implicitly or explicitly) to type T (Clause 4, 5.2.3, 5.2.7, 5.2.9, 5.4), or</li>\n<li>(5.6)\n  an expression that is not a null pointer constant, and has type other than cv void*, is converted to the\n  type pointer to T or reference to T using a standard conversion (Clause 4), a dynamic_cast (5.2.7) or a\n  static_cast (5.2.9), or</li>\n<li>(5.7)\n  a class member access operator is applied to an expression of type T (5.2.5), or</li>\n<li>(5.8)\n  the typeid operator (5.2.8) or the sizeof operator (5.3.3) is applied to an operand of type T, or</li>\n<li>(5.9)\n  a function with a return type or argument type of type T is defined (3.1) or called (5.2.2), or</li>\n<li>(5.10)\n  a class with a base class of type T is defined (Clause 10), or</li>\n<li>(5.11)\n  an lvalue of type T is assigned to (5.18), or</li>\n<li>(5.12)\n  the type T is the subject of an alignof expression (5.3.6), or</li>\n<li>(5.13)\n  an exception-declaration has type T, reference to T, or pointer to T (15.3).</li>\n</ul>\n</blockquote>\n<p>None of them says that <code>T</code> needs to be complete in order to declare <em>pointer-to-member</em> of <code>T</code>.</p>\n", "LastEditorUserId": "4932834", "LastActivityDate": "2016-06-23T19:33:31.010", "Score": "5", "CreationDate": "2016-06-23T19:27:18.873", "ParentId": "37999741", "CommentCount": "2", "OwnerUserId": "4932834", "LastEditDate": "2016-06-23T19:33:31.010"}, "37999741": {"ViewCount": "190", "Body": "<p>Is the following code well-defined in C++? (*)</p>\n<p>I'm having a hard time figuring out where to even look in the standard, and searching the web hasn't turned up anything concrete.</p>\n<pre><code>struct S;\nstruct T {\n    constexpr T() = default;\n    bool S::* a = nullptr;\n    int b       = 42;\n};\nconst T t{};\n// Test. Compiled using: cl /W4 /WX /FAs filename.cpp\n#include &lt;stdlib.h&gt;\nint main() {\n    if (t.b != 42) abort();\n}\n</code></pre>\n<p>The reason I'm asking is because it works (or seems to) with newer versions of GCC and Clang (x86/x86_64), but fails(**) with Visual Studio 2015 Update 2 and Update 3 RC.</p>\n<p>Before reporting a bug I'd like to be sure I'm not relying on undefined behavior or just not searching for the right terms.</p>\n<p>I've also tried using <code>/vmg</code> and <code>/vmb</code> as mentioned in <a href=\"https://stackoverflow.com/questions/30923296/pointer-to-member-function-of-incomplete-type\">this post</a>.</p>\n<p>(*): I mostly care about C++14 and later, but I don't see any reason the answer shouldn't apply to C++11.<br>\n(**): If the code is well-defined it looks like a codegen bug where it isn't allocation room for the pointer. Changing <code>struct S</code> to <code>struct S{}</code> seems to make the code \"work\".</br></p>\n", "AcceptedAnswerId": "38000200", "Title": "Pointer to data member of incomplete type", "CreationDate": "2016-06-23T19:00:20.563", "Id": "37999741", "CommentCount": "5", "LastEditDate": "2017-05-23T11:52:30.993", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-06-23T19:33:31.010", "Score": "7", "OwnerUserId": "786653", "Tags": "<c++><c++11><visual-c++>", "AnswerCount": "1"}});