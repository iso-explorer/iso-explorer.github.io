post_cb({"6030785": {"ParentId": "6030763", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You can't call constructors like that. Well you can, but what happens is a nameless temporary  object gets created. Write your copy constructor without reference to the other constructor. Also, if you use std::string instead of char *, you won't need a copy constructor. If you persist in using char  *, you will also need a destructor and an assignment operator.</p>\n", "OwnerUserId": "2100815", "LastEditorUserId": "2100815", "LastEditDate": "2011-05-17T12:35:52.217", "Id": "6030785", "Score": "10", "CreationDate": "2011-05-17T12:30:19.600", "LastActivityDate": "2011-05-17T12:35:52.217"}, "6030810": {"ParentId": "6030763", "CommentCount": "0", "Body": "<p>First of all, the constructor is not just any method, you can't just use at as a mutator method. </p>\n<p>that said,\nAm I right in thinking that your class had two fields, imie and wiek?</p>\n<p>just do the init code again, this time with x.imie and x.wiek as input</p>\n", "OwnerUserId": "750186", "PostTypeId": "2", "Id": "6030810", "Score": "0", "CreationDate": "2011-05-17T12:33:06.130", "LastActivityDate": "2011-05-17T12:33:06.130"}, "bq_ids": {"n4140": {"so_6030763_6030880_0": {"section_id": 447, "quality": 0.5172413793103449, "length": 45}}, "n3337": {"so_6030763_6030880_0": {"section_id": 438, "quality": 0.5172413793103449, "length": 45}}, "n4659": {"so_6030763_6030880_0": {"section_id": 469, "quality": 0.5172413793103449, "length": 45}}}, "6030800": {"ParentId": "6030763", "CommentCount": "0", "Body": "<p>You have to initialize the members of <code>Osoba</code>, the same way as you are doing in the other constructor.</p>\n<p>You can only reuse constructors (with other syntax) in C++2011.</p>\n", "OwnerUserId": "212063", "PostTypeId": "2", "Id": "6030800", "Score": "3", "CreationDate": "2011-05-17T12:32:10.953", "LastActivityDate": "2011-05-17T12:32:10.953"}, "6030763": {"CommentCount": "3", "ViewCount": "326", "PostTypeId": "1", "LastEditorUserId": "78054", "CreationDate": "2011-05-17T12:28:19.690", "LastActivityDate": "2011-05-17T17:36:53.457", "Title": "c++ self in initialisation list", "AcceptedAnswerId": "6030880", "LastEditDate": "2011-05-17T12:31:41.283", "Id": "6030763", "Score": "0", "Body": "<p>i have this code snippet</p>\n<pre><code>class Osoba{\n         Osoba(char* imie,int wiek){                         \n                     this-&gt;imie=new char[strlen(imie)+1];\n                     strcpy(this-&gt;imie,imie);\n                     this-&gt;wiek=wiek;\n                     cout&lt;&lt;\"Utworzono Osobe \"&lt;&lt;this-&gt;imie&lt;&lt;endl;\n         }\n         Osoba(Osoba&amp; x){\n                 Osoba(x.imie,x.wiek);\n         }\n[...]\n</code></pre>\n<p>and when i call the copy constructor it doesnt work (creates and destroyes object).</p>\n<p>Edit:\nif i use</p>\n<pre><code>         Osoba(Osoba&amp; x): Osoba(x.imie,x.wiek){\n</code></pre>\n<p>i get <code>type 'class Osoba' is not a direct base of 'Osoba'</code></p>\n<p>how is this done ?</p>\n", "Tags": "<c++><initialization-list>", "OwnerUserId": "78054", "AnswerCount": "4"}, "6030880": {"ParentId": "6030763", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You cannot call a constructor except for creating another different object.</p>\n<p>If you need to have some code in common between constructors you can place it in a separate method and call that method. Note that in the constructor you can call methods of the object but <code>virtual</code> methods are not going to dispatch do derived classes.</p>\n<p>In other words if you have</p>\n<pre><code>struct Foo\n{\n    virtual void doit() { ... }\n    Foo() {\n        doit();\n    }\n};\n\nstruct Bar : Foo\n{\n    virtual void doit() { ... }\n};\n</code></pre>\n<p>during the constructor of <code>Bar</code> the implementation of <code>doit</code> called will be the one defined in <code>Foo</code> because during the constructor of the base part of the derived object, the object is only a \"base\" object. Only at the <strong>end of the constructor</strong> it becomes a \"derived\" object right before executing any eventually present code in the \"derived\" constructor.</p>\n<p>Be careful that other object oriented languages use a different approach...</p>\n<p>For an explanation of what happens exactly in C++ <a href=\"http://www.artima.com/cppsource/nevercall.html\" rel=\"nofollow\">see this article</a>.</p>\n<p>If you like instead a legalese description this is what is stated in the C++ standard at 12.7.4:</p>\n<blockquote>\n<p id=\"so_6030763_6030880_0\">Member functions, including virtual\n  functions (10.3), can be called during\n  construction or destruction (12.6.2).\n  When a virtual function is called\n  directly or indirectly from a\n  constructor (including from the\n  mem-initializer for a data member) or\n  from a destructor, and the object to\n  which the call applies is the object\n  under construction or destruction, the\n  function called is the one defined in\n  the constructor or destructor\u2019s own\n  class or in one of its bases, but not\n  a function overriding it in a class\n  derived from the constructor or\n  destructor\u2019s class, or overriding it\n  in one of the other base classes of\n  the most derived object (1.8). If the\n  virtual function call uses an explicit\n  class member access (5.2.5) and the\n  object-expression refers to the object\n  under construction or destruction but\n  its type is neither the constructor or\n  destructor\u2019s own class or one of its\n  bases, the result of the call is\n  undefined.</p>\n</blockquote>\n", "OwnerUserId": "320726", "LastEditorUserId": "320726", "LastEditDate": "2011-05-17T17:36:53.457", "Id": "6030880", "Score": "1", "CreationDate": "2011-05-17T12:39:46.037", "LastActivityDate": "2011-05-17T17:36:53.457"}});