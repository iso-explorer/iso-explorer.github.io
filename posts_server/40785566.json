post_cb({"40785566": {"ViewCount": "244", "Body": "<p>I have spent some time trawling this site; in particular this question: <a href=\"https://stackoverflow.com/questions/40751662/is-a-b-255-255-the-same-as-a-b-255\">Is ((a + (b &amp; 255)) &amp; 255) the same as ((a + b) &amp; 255)?</a></p>\n<p>In doing so, I've been led to the conclusion that</p>\n<pre><code>int main()\n{\n    unsigned short i = std::numeric_limits&lt;unsigned short&gt;::max();\n    unsigned short j = i;\n    auto y = i * j;\n}\n</code></pre>\n<p>can lead to undefined behaviour due to a type promotion of <code>i</code> and <code>j</code> to <code>int</code> which subsequently overflows upon the multiplication! Perhaps <code>i</code> and <code>j</code> need not to even be this large.</p>\n<p><strong>My conclusion is that, for example, on a system where <code>unsigned short</code> is 16 bits and <code>int</code> is 32 bits, the behaviour can be <em>undefined</em>.</strong></p>\n<p>Am I correct here?</p>\n", "AcceptedAnswerId": "40785774", "Title": "Can the multiplication of two unsigned shorts really lead to undefined behaviour?", "CreationDate": "2016-11-24T11:45:08.327", "Id": "40785566", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:24:48.537", "LastEditorUserId": "-1", "LastActivityDate": "2016-11-24T11:59:37.700", "Score": "11", "OwnerUserId": "6448768", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_40785566_40785774_3": {"length": 13, "quality": 1.0, "section_id": 5937}, "so_40785566_40785774_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 21}}, "n3337": {"so_40785566_40785774_3": {"length": 13, "quality": 1.0, "section_id": 5709}, "so_40785566_40785774_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 18}}, "n4659": {"so_40785566_40785774_3": {"length": 13, "quality": 1.0, "section_id": 7421}, "so_40785566_40785774_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 21}}}, "40785774": {"Id": "40785774", "PostTypeId": "2", "Body": "<p>Yes, it's possible, and your example is likely to be undefined on most desktop architectures.</p>\n<p>For the sake of this example, let's assume that <code>int</code> is 32-bit 2's complement type and <code>unsigned short</code> is 16-bit.</p>\n<p>I'm using N4140 for the quotes.</p>\n<p>Before multiplication, both values are promoted to <code>int</code>:</p>\n<blockquote>\n<p id=\"so_40785566_40785774_0\">\u00a7 4.5 [conv.prom] / 1</p>\n<p id=\"so_40785566_40785774_1\">A prvalue of an integer type other than bool, char16_t, char32_t, or\n  wchar_t whose integer conversion rank (4.13) is less than the rank of\n  int can be converted to a prvalue of type int if int can represent all\n  the values of the source type;</p>\n</blockquote>\n<p>Then:</p>\n<blockquote>\n<p id=\"so_40785566_40785774_2\">\u00a7 5 [expr] / 4</p>\n<p id=\"so_40785566_40785774_3\">If during the evaluation of an expression, the result is not\n  mathematically defined or not in the range of representable values for\n  its type, the behavior is undefined.</p>\n</blockquote>\n<p>Since the result of 65535 * 65535 (4294836225) is not defined in our 32-bit <code>int</code> (with value range [-2147483648,2147483647]), the behaviour is undefined.</p>\n", "LastEditorUserId": "2456565", "LastActivityDate": "2016-11-24T11:59:37.700", "Score": "12", "CreationDate": "2016-11-24T11:55:29.330", "ParentId": "40785566", "CommentCount": "6", "OwnerUserId": "2456565", "LastEditDate": "2016-11-24T11:59:37.700"}});