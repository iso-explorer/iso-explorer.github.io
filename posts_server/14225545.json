post_cb({"14225545": {"CommentCount": "0", "AcceptedAnswerId": "14225556", "PostTypeId": "1", "ClosedDate": "2013-01-09T12:04:25.633", "LastEditorUserId": "-1", "CreationDate": "2013-01-08T23:00:26.403", "LastActivityDate": "2013-01-09T09:32:46.880", "LastEditDate": "2017-05-23T12:27:42.213", "ViewCount": "841", "FavoriteCount": "1", "Title": "Array initialization using {0} fails except for first element in some compilers", "Id": "14225545", "Score": "4", "Body": "<blockquote>\n<p id=\"so_14225545_14225545_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/10828294/c-and-c-partial-initialization-of-automatic-structure\">C and C++ : Partial initialization of automatic structure</a> </br></p>\n</blockquote>\n<p>For a long time I have been using</p>\n<pre><code>char array[100] = {0};\n</code></pre>\n<p>to initialize all the elements of the array to 0.\nHowever, I recently stumbled on a compiler (Code Composer Studio by Texas Instruments) where this didn't work. The statement had the effect of initializing only the first element to 0.</p>\n<p>Could this behavior be a C vs C++ difference, a compiler difference, or is this a bug in the implementation?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "1628786", "AnswerCount": "3"}, "14225556": {"ParentId": "14225545", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2013-01-08T23:01:16.687", "Score": "11", "LastEditorUserId": "87234", "LastEditDate": "2013-01-08T23:11:00.740", "Id": "14225556", "OwnerUserId": "87234", "Body": "<p>It's just a bug. In both C and C++, <code>array</code> should be filled with zeroes.</p>\n<hr>\n<p>Since this is a small answer, might as well go overboard:</p>\n<p>C++11 \u00a78.5.1/7:</p>\n<blockquote>\n<p id=\"so_14225545_14225556_0\">If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from an empty initializer list (8.5.4). [Example:<br>\n<code>struct S { int a; const char* b; int c; };</code><br>\n<code>S ss = { 1, \"asdf\" };</code><br>\n  initializes <code>ss.a</code> with <code>1</code>, <code>ss.b</code> with <code>\"asdf\"</code>, and <code>ss.c</code> with the value of an expression of the form <code>int()</code>, that is, <code>0</code>. \u2014end example ] </br></br></br></p>\n</blockquote>\n<p>C99 \u00a76.7.8/21 (sorry, don't have C11 off-hand):</p>\n<blockquote>\n<p id=\"so_14225545_14225556_1\">If there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array,the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2013-01-08T23:11:00.740"}, "14225586": {"ParentId": "14225545", "CommentCount": "6", "CreationDate": "2013-01-08T23:04:18.067", "OwnerUserId": "25324", "PostTypeId": "2", "Id": "14225586", "Score": "5", "Body": "<p>In C, there is no partial initialization (see 6.7.9/19 in the <a href=\"http://www.open-std.org/JTC1/sc22/wg14/www/docs/n1570.pdf\">C11 Standard</a>). An object either is fully initialized (all its bytes) or is completely uninitialized.</p>\n<p>Your compiler is not C-conformant.</p>\n<blockquote>\n<p id=\"so_14225545_14225586_0\">The initialization shall occur in initializer list order, each initializer provided for a\n  particular subobject overriding any previously listed initializer for the same subobject;\n  all subobjects that are not initialized explicitly shall be initialized implicitly the same as\n  objects that have static storage duration.</p>\n</blockquote>\n", "LastActivityDate": "2013-01-08T23:04:18.067"}, "bq_ids": {"n4140": {"so_14225545_14225556_0": {"section_id": 3304, "quality": 0.7222222222222222, "length": 26}}, "n3337": {"so_14225545_14225556_0": {"section_id": 3174, "quality": 0.7222222222222222, "length": 26}}, "n4659": {"so_14225545_14225556_0": {"section_id": 4070, "quality": 0.6666666666666666, "length": 24}}}, "14225589": {"ParentId": "14225545", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-01-08T23:04:24.860", "Score": "3", "LastEditorUserId": "1119701", "LastEditDate": "2013-01-08T23:41:13.023", "Id": "14225589", "OwnerUserId": "1119701", "Body": "<p>Check your compiler documentation. A conforming C or C++ compiler is required to initialize all elements to <code>0</code> but some compilers, particularly in the embedded world, have non-ISO options (sometimes set by default!) to tweak the implementation for performance reasons.</p>\n<p>Specifically for your compiler check if you are in <em>COFF ABI mode</em>:</p>\n<blockquote>\n<p id=\"so_14225545_14225589_0\"><strong>6.13 Initializing Static and Global Variables in COFF ABI Mode</strong></p>\n<p id=\"so_14225545_14225589_1\">The ANSI/ISO C standard specifies that global (extern) and static variables without explicit initializations\n  must be initialized to 0 before the program begins running. This task is typically done when the program is\n  loaded. Because the loading process is heavily dependent on the specific environment of the target\n  application system, in COFF ABI mode the compiler itself makes no provision for initializing to 0 otherwise\n  uninitialized static storage class variables at run time. It is up to your application to fulfill this requirement.</p>\n<p id=\"so_14225545_14225589_2\">Initialize Global Objects</p>\n<p id=\"so_14225545_14225589_3\">NOTE: You should explicitly initialize all global objects which you expected the compiler would set to\n  zero by default.\n  In C6000 EABI mode the uninitialized variables are zero initialized automatically</p>\n</blockquote>\n<p>from \"TMS320C6000 Optimizing Compiler v7.4\nUser's Guide\"</p>\n<p><a href=\"http://www.ti.com/lit/ug/spru187u/spru187u.pdf\" rel=\"nofollow\">http://www.ti.com/lit/ug/spru187u/spru187u.pdf</a></p>\n", "LastActivityDate": "2013-01-08T23:41:13.023"}});