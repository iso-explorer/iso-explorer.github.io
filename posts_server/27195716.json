post_cb({"27195773": {"ParentId": "27195716", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If the compiler can't prove the object pointed to is actually <code>const</code>, nothing in the standard allows it to assume that it is - so it can't optimise away the reads.</p>\n<p>(If it could see more of the code - e.g. if the functions are inline or whole program optimisation is in use - then it might be able to skip a read when it can tell there have been no writes.)</p>\n", "OwnerUserId": "212870", "LastEditorUserId": "212870", "LastEditDate": "2014-11-28T21:00:42.143", "Id": "27195773", "Score": "1", "CreationDate": "2014-11-28T20:55:26.160", "LastActivityDate": "2014-11-28T21:00:42.143"}, "27195716": {"CommentCount": "5", "ViewCount": "105", "CreationDate": "2014-11-28T20:49:27.550", "LastActivityDate": "2014-11-28T21:08:14.630", "Title": "c++: Is object pointed to by a \"pointer to const\" considered unchanging or just unmodifiable?", "AcceptedAnswerId": "27195905", "PostTypeId": "1", "Id": "27195716", "Score": "2", "Body": "<p>In the following situation a \"pointer to const bool\" parameter <code>pbAbort</code> makes sense because the worker function does not modify the bool object. However, I'm worried the compiler might optimize away multiple checks on the value of the bool unless I use a normal \"pointer to bool.\"  The bool is a flag that can be set by the manager thread.</p>\n<pre><code>void runWorkManager(DataSet&amp; data)\n{\n    bool bAbort = false;\n    callWorkerFuncFromNewThread(data, &amp;bAbort);\n    while(!(data.isWorkCompleted || data.isWorkAborted))\n    {\n        updateGuiWithProgress(data.progress);\n        if(userWantsToAbort())\n            bAbort = true;\n    }\n}\nvoid workerFunc(DataSet&amp; data, bool const *const pbAbort)\n{\n    data.doPreWork();\n    if(*pbAbort) //Check #1\n    {\n        data.isWorkAborted = true;\n        return;\n    }\n\n    for(int i = 0; i &lt; 100; ++i)\n    {\n        data.doWorkN(i);\n        if(*pbAbort) //Check #2\n        {\n            data.isWorkAborted = true;\n            return;\n        }\n    }\n    data.isWorkCompleted = true;\n}\n</code></pre>\n<p>If <code>*pbAbort</code> is assumed to never change, then the compiler could remove the Check #2 block.</p>\n<p>The c++ 11 standard at 7.1.6.1.3 states:</p>\n<blockquote>\n<p id=\"so_27195716_27195716_0\">A pointer or reference to a cv-qualified type need not actually point or refer to a cv-qualified object, but it is treated as if it does; a const-qualified access path cannot be used to modify an object even if the object referenced is a non-const object and can be modified through some other access path.</p>\n</blockquote>\n<p>Unfortunately, this statement doesn't quite answer my question.</p>\n", "Tags": "<c++><pointers><const><compiler-optimization>", "OwnerUserId": "4304844", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27195716_27195716_0": {"section_id": 5432, "quality": 1.0, "length": 31}}, "n3337": {"so_27195716_27195716_0": {"section_id": 5227, "quality": 1.0, "length": 31}}, "n4659": {"so_27195716_27195716_0": {"section_id": 6860, "quality": 1.0, "length": 31}}}, "27195905": {"ParentId": "27195716", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>To answer your question, if the compiler doesn't believe the variable is being modified, it can optimize away multiple reads whether or not the object is const. This is fairly likely to happen in your code considering the code path in the reading thread does not write to the variable.</p>\n<p>It is important to note here that your program actually contains undefined behavior; reading an writing variables across threads is not atomic by default. To safely do this, you need an <code>atomic&lt;bool&gt;</code>. See also <a href=\"https://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g\">this question</a>. Also, don't use <code>volatile</code>. It will fix your reordering problem, but access to <code>volatile</code> variables are still not atomic (and so still UB).</p>\n<p>The reason the standards statement doesn't answer your question is that it's talking about reads and writes within one thread.</p>\n", "OwnerUserId": "603688", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:12:46.213", "Id": "27195905", "Score": "2", "CreationDate": "2014-11-28T21:08:14.630", "LastActivityDate": "2014-11-28T21:08:14.630"}});