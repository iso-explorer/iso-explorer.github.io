post_cb({"16900842": {"ParentId": "16900498", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes, this will work like you expect.</p>\n<p>The Standard guarantees that for any container type, <code>some_container::iterator</code> can be implicitly converted to <code>some_container::const_iterator</code>.</p>\n<p>The first table in 23.2.1 [container.requirements.general], after defining <code>X</code> as a container type which contains objects of type <code>T</code>, has:</p>\n<blockquote>\n<p id=\"so_16900498_16900842_0\">Expression: <code>X::iterator</code></p>\n<p id=\"so_16900498_16900842_1\">Return type: iterator type whose value type is <code>T</code></p>\n<p id=\"so_16900498_16900842_2\">Note: any iterator category that meets the forward iterator requirements. convertible to <code>X::const_iterator</code>.</p>\n<hr>\n<p id=\"so_16900498_16900842_3\">Expression: <code>X::const_iterator</code></p>\n<p id=\"so_16900498_16900842_4\">Return type: constant iterator type whose value type is <code>T</code></p>\n<p id=\"so_16900498_16900842_5\">Note: any iterator category that meets the forward iterator requirements.</p>\n</hr></blockquote>\n<p>(These aren't really expressions, and are types, rather than having \"return types\", but that's how they're squeezed into the table that is mostly expressions.)</p>\n<p>So when you have <code>ciObject2==iObject1</code>, the compiler notices that the best <code>operator==</code> is <code>ciObject2==some_container::const_iterator(iObject1)</code>.  And <code>operator==</code> on two <code>const_iterator</code> tells you if they refer to the same element.</p>\n<p>(I don't see anything explicitly saying that the result of this conversion refers to the same object as the original <code>iterator</code>.  I guess that's just understood.)</p>\n", "OwnerUserId": "459640", "LastEditorUserId": "459640", "LastEditDate": "2013-06-03T16:06:00.610", "Id": "16900842", "Score": "12", "CreationDate": "2013-06-03T15:53:11.423", "LastActivityDate": "2013-06-03T16:06:00.610"}, "16900844": {"ParentId": "16900498", "CommentCount": "0", "Body": "<p>IIRC <code>iterator</code> implicitly converts to <code>const_iterator</code>. And the result must point to the same position. </p>\n<p>If so the mixed compare will do the conversion then compare the now compatible const_iterators.</p>\n", "OwnerUserId": "2422194", "PostTypeId": "2", "Id": "16900844", "Score": "1", "CreationDate": "2013-06-03T15:53:31.933", "LastActivityDate": "2013-06-03T15:53:31.933"}, "16900498": {"CommentCount": "6", "AcceptedAnswerId": "16900842", "PostTypeId": "1", "LastEditorUserId": "473798", "CreationDate": "2013-06-03T15:35:50.913", "LastActivityDate": "2013-06-04T18:18:00.913", "LastEditDate": "2013-06-04T18:18:00.913", "ViewCount": "1388", "FavoriteCount": "2", "Title": "const to non-const iterator comparisons, are they valid", "Id": "16900498", "Score": "14", "Body": "<p>I have two iterators into a container, one const and one non-const. Is there an issue with comparing them to see if they both refer to the same object in the container? This is a general C++11 iterator question: </p>\n<blockquote>\n<p id=\"so_16900498_16900498_0\">Can a const and non-const iterator be legitimately compared to see if\n  they both refer to the same object, independent of the type of\n  container (i.e., they are both iterators that are guaranteed to refer\n  to objects in the same container or that container's end(), but one is\n  const and the other is not)?</p>\n</blockquote>\n<p>For example, consider the following code:</p>\n<pre><code>some_c++11_container container;\n\n// Populate container\n...\n\nsome_c++11_container::iterator iObject1=container.begin();\nsome_c++11_container::const_iterator ciObject2=container.cbegin();\n\n// Some operations that move iObject1 and ciObject2 around the container\n...\n\nif (ciObject2==iObject1) // Is this comparison allowed by the C++11 standard?\n  ...; //Perform some action contingent on the equality of the two iterators\n</code></pre>\n", "Tags": "<c++><c++11>", "OwnerUserId": "473798", "AnswerCount": "4"}, "16900635": {"ParentId": "16900498", "CommentCount": "3", "Body": "<p>I don't think it is possible for there to be an issue comparing them. If you have a const iterator when you check for it being the end the iterator <code>end()</code> returns is not const.</p>\n", "OwnerUserId": "2167655", "PostTypeId": "2", "Id": "16900635", "Score": "1", "CreationDate": "2013-06-03T15:42:00.897", "LastActivityDate": "2013-06-03T15:42:00.897"}, "bq_ids": {"n4140": {"so_16900498_16900842_5": {"section_id": 705, "quality": 0.8571428571428571, "length": 6}, "so_16900498_16901637_0": {"section_id": 5568, "quality": 0.8666666666666667, "length": 13}, "so_16900498_16900842_4": {"section_id": 705, "quality": 0.875, "length": 7}, "so_16900498_16900842_2": {"section_id": 705, "quality": 0.8888888888888888, "length": 8}, "so_16900498_16900842_1": {"section_id": 705, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_16900498_16900842_5": {"section_id": 695, "quality": 0.8571428571428571, "length": 6}, "so_16900498_16901637_0": {"section_id": 5350, "quality": 0.8666666666666667, "length": 13}, "so_16900498_16900842_4": {"section_id": 695, "quality": 0.875, "length": 7}, "so_16900498_16900842_2": {"section_id": 695, "quality": 0.8888888888888888, "length": 8}, "so_16900498_16900842_1": {"section_id": 695, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_16900498_16900842_5": {"section_id": 734, "quality": 0.8571428571428571, "length": 6}, "so_16900498_16901637_0": {"section_id": 7015, "quality": 0.8666666666666667, "length": 13}, "so_16900498_16900842_4": {"section_id": 734, "quality": 0.875, "length": 7}, "so_16900498_16900842_2": {"section_id": 734, "quality": 0.8888888888888888, "length": 8}, "so_16900498_16900842_1": {"section_id": 734, "quality": 0.8571428571428571, "length": 6}}}, "16901637": {"ParentId": "16900498", "CommentCount": "0", "Body": "<p>From <em>\u00a724.2.3/1</em></p>\n<blockquote>\n<p id=\"so_16900498_16901637_0\">A class or pointer type <code>X</code> satisfies the requirements of an input iterator for the value type <code>T</code> if <code>X</code> satisfies the <code>Iterator</code> (24.2.2) and <code>EqualityComparable</code> (<em>Table 17</em>) requirements ...</p>\n</blockquote>\n<p>Thus input iterators are required to be <em>EqualityComparable</em>. </p>\n<p>All standard library container iterators must satisfy forward iterator requirements (<em>\u00a723.2.1 - Table 96</em>). Since those requirements are a superset of input iterator requirements, it follows these iterators must satisfy the <em>EqualityComparable</em> concept.</p>\n<p>Also, from <em>\u00a723.2.1 - Table 96</em>, <code>X::iterator</code> is required to be convertible to\n<code>X::const_iterator</code>.</p>\n<p>Adding the two together answers your question that it is indeed required by the standard that comparing a <code>Container::const_iterator</code> to a <code>Container::iterator</code> is well-defined (as long as both are valid iterators pointing to the same container).</p>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "16901637", "Score": "1", "CreationDate": "2013-06-03T16:40:32.910", "LastActivityDate": "2013-06-03T16:40:32.910"}});