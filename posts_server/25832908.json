post_cb({"25832908": {"CommentCount": "3", "ViewCount": "86", "CreationDate": "2014-09-14T11:51:59.943", "LastActivityDate": "2014-09-14T12:15:48.757", "Title": "Copy constructor call methods", "FavoriteCount": "1", "PostTypeId": "1", "Id": "25832908", "Score": "1", "Body": "<pre><code>#include&lt;iostream&gt;\nusing namespace std ; \nclass Foo{\n    int a , b ;\npublic:\n    Foo(int x, int y){\n        a = x ;\n        b = y  ;\n    }\n    Foo(Foo&amp; obj){\n        a = obj.a ;\n        b = obj.b ;\n    }\n};\n\nint main(){\n    Foo obj(2,3) ;\n    Foo obj1(obj) ;\n    Foo obj2 = obj ;\n}\n</code></pre>\n<p>If I am right, both <code>Foo obj2 = obj ;</code> and <code>Foo obj1(obj) ;</code> call the copy constructor.</p>\n<p>What are the pros and cons of using one over the other ?</p>\n", "Tags": "<c++><initialization><copy-constructor>", "OwnerUserId": "3834059", "AnswerCount": "1"}, "25832969": {"ParentId": "25832908", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><code>Foo obj1(obj);</code> is direct initialization, <code>Foo obj2 = obj;</code> is copy-initialization.</p>\n<p>The only difference here is that the first can call <code>explicit</code> constructors while the second cannot.</p>\n<p>However, no sane person would make the copy constructor <code>explicit</code>, so assuming that you are working with sane code it should make no difference. A class with an explicit copy constructor doesn't satisfy <code>CopyConstructible</code> requirements (required for a number of standard container operations). Both function return and argument passing uses copy-initialization, so a class with an explicit copy constructor would not be usable in those contexts.</p>\n<hr>\n<p>Just to make things crystal clear. N3936 \u00a78.5 [dcl.init]/p15-16:</p>\n<blockquote>\n<p id=\"so_25832908_25832969_0\">15 The initialization that occurs in the form</p>\n<pre><code>T x = a;\n</code></pre>\n<p id=\"so_25832908_25832969_1\">as well as in argument passing, function return, throwing an exception\n  (15.1), handling an exception (15.3), and aggregate member\n  initialization (8.5.1) is called <em>copy-initialization</em>. [ <em>Note</em>:\n  Copy-initialization may invoke a move (12.8). \u2014<em>end note</em> ]</p>\n<p id=\"so_25832908_25832969_2\">16 The initialization that occurs in the forms</p>\n<pre><code>T x(a);\nT x{a};\n</code></pre>\n<p id=\"so_25832908_25832969_3\">as well as in <code>new</code> expressions (5.3.4), <code>static_cast</code> expressions\n  (5.2.9), functional notation type conversions (5.2.3), and base and\n  member initializers (12.6.2) is called <em>direct-initialization</em>.</p>\n</blockquote>\n</hr>", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-09-14T12:15:48.757", "Id": "25832969", "Score": "5", "CreationDate": "2014-09-14T12:00:32.423", "LastActivityDate": "2014-09-14T12:15:48.757"}, "bq_ids": {"n4140": {"so_25832908_25832969_1": {"section_id": 3294, "quality": 0.68, "length": 17}, "so_25832908_25832969_3": {"section_id": 3295, "quality": 0.7777777777777778, "length": 14}}, "n3337": {"so_25832908_25832969_1": {"section_id": 3164, "quality": 0.68, "length": 17}, "so_25832908_25832969_3": {"section_id": 3165, "quality": 0.7777777777777778, "length": 14}}, "n4659": {"so_25832908_25832969_3": {"section_id": 4057, "quality": 0.5555555555555556, "length": 10}, "so_25832908_25832969_1": {"section_id": 4056, "quality": 0.68, "length": 17}}}});