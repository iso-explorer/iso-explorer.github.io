post_cb({"26420073": {"ParentId": "26419786", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-10-17T07:31:36.870", "Score": "13", "LastEditorUserId": "186193", "LastEditDate": "2014-10-18T19:02:00.160", "Id": "26420073", "OwnerUserId": "186193", "Body": "<p>Just a historical note, not an answer to this question (there are plenty of good answers)... a long long time ago when dinosaurs roamed the earth and Turbo C++ was ruling the world of C++ programmers, <code>new</code> actually returned <code>NULL</code>. Quote from a book of those days (0bj3ct-0r13nt3d Pr0gr4mm1ng with ANSI and Turbo C++ - title intentionally obfuscated so that <strong>no one by mistake reads it anymore</strong>) page 115.</p>\n<blockquote>\n<p id=\"so_26419786_26420073_0\">If the new operator fails to allocate memory it returns NULL which can be used to detect failure or success of new operator.</p>\n</blockquote>\n<p>because of this legacy code is full with a lot of NULL checking ... a real nightmare to bring them up to the current standard...</p>\n<p>However, here is a tiny piece of the C++ standard 5.3.4/13:</p>\n<blockquote>\n<p id=\"so_26419786_26420073_1\">[ Note: unless an allocation function is declared with a non-throwing exception-specification (15.4), it indicates\n  failure to allocate storage by throwing a std::bad_alloc exception (Clause 15, 18.6.2.1); it returns a\n  non-null pointer otherwise. If the allocation function is declared with a non-throwing exception-specification,\n  it returns null to indicate failure to allocate storage and a non-null pointer otherwise. \u2014end note ] If the\n  allocation function returns null, initialization shall not be done, the deallocation function shall not be called,\n  and the value of the new-expression shall be null.</p>\n</blockquote>\n<p>which tells you that in some special cases, <code>new</code> can return <code>NULL</code></p>\n", "LastActivityDate": "2014-10-18T19:02:00.160"}, "26422143": {"ParentId": "26419786", "CommentCount": "0", "Body": "<p>in C++, operator <code>new</code> is not only to allocate a chunk of memory, it is also class construction. thus, in semantic, operator <code>new</code> is much richer than function <code>malloc</code>. via exceptions, we get better informations and we can handle construction failures better.</p>\n", "OwnerUserId": "1889584", "PostTypeId": "2", "Id": "26422143", "Score": "7", "CreationDate": "2014-10-17T09:37:03.243", "LastActivityDate": "2014-10-17T09:37:03.243"}, "26419786": {"CommentCount": "11", "ViewCount": "6255", "PostTypeId": "1", "LastEditorUserId": "635608", "CreationDate": "2014-10-17T07:12:59.680", "LastActivityDate": "2016-11-08T01:00:54.660", "Title": "Why doesn't new in C++ return NULL on failure", "FavoriteCount": "4", "LastEditDate": "2014-10-17T10:00:47.100", "Id": "26419786", "Score": "28", "Body": "<p>Why doesn't <code>new</code> return <code>NULL</code> on failure? Why does it throw an exception only on failure?</p>\n<p>As it returns a pointer to the object on successes, why not on failure? Is there any specific reason for this behaviour?</p>\n", "Tags": "<c++>", "OwnerUserId": "1716427", "AnswerCount": "8"}, "26419805": {"ParentId": "26419786", "CommentCount": "1", "Body": "<p>It is by design. In C++ every kind of failure is notified by throwing an exception by default \u2014 streams, however, are exception, which does <strong>not</strong> throw exception (pun intended) <em>by default</em>.</p>\n<p>You can use nothrow version as:</p>\n<pre><code>T *p = new (std::nothrow) T(args);\n\nif ( p == nullptr ) //must check for nullity\n{\n     std::cout &lt;&lt; \"memory allocation failed\" &lt;&lt; std::endl;\n}\n</code></pre>\n", "OwnerUserId": "415784", "PostTypeId": "2", "Id": "26419805", "Score": "26", "CreationDate": "2014-10-17T07:14:09.160", "LastActivityDate": "2014-10-17T07:14:09.160"}, "bq_ids": {"n4140": {"so_26419786_26420073_1": {"section_id": 6096, "quality": 0.8958333333333334, "length": 43}}, "n3337": {"so_26419786_26420073_1": {"section_id": 5862, "quality": 0.8958333333333334, "length": 43}}, "n4659": {"so_26419786_26420073_1": {"section_id": 7593, "quality": 0.8125, "length": 39}}}, "26420011": {"ParentId": "26419786", "CommentCount": "1", "Body": "<p>Before exceptions were introduced in C++:</p>\n<ul>\n<li><p>A failing <code>new</code>-expression produced a nullpointer.</p></li>\n<li><p>In a failing constructor one assigned a nullpointer to <code>this</code>.</p></li>\n</ul>\n<p>After exceptions were introduced:</p>\n<ul>\n<li><p>A failing ordinary <code>new</code>-expression throws an exception.</p></li>\n<li><p>In a failing constructor one throws an exception.</p></li>\n</ul>\n<p>One difference is that failure reporting for constructors now works also for creation of objects without dynamic allocation.</p>\n<p>Another difference is that code using <code>new</code>-expressions now can be simpler since the error handling can be moved out of each such code place, and centralized.</p>\n<p>The old nullpointer-result behavior is still available via <code>std::nothrow</code> (include the <code>&lt;new&gt;</code> header). This implies checking at each place using <code>new</code>. Thus nullpointer results are in conflict with the DRY principle, <em>don't repeat yourself</em> (the redundancy offers an endless stream of opportunities to introduce errors).</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "26420011", "Score": "45", "CreationDate": "2014-10-17T07:27:58.113", "LastActivityDate": "2014-10-17T07:27:58.113"}, "26419860": {"ParentId": "26419786", "CommentCount": "0", "Body": "<p>you can specify that you want new to return 0 instead of throwing <code>std::bad_alloc</code> using the <code>std::nothrow parameter:</code></p>\n<pre><code>SomeType *p = new(std::nothrow) SomeType;\n</code></pre>\n", "OwnerUserId": "2723943", "PostTypeId": "2", "Id": "26419860", "Score": "1", "CreationDate": "2014-10-17T07:17:28.550", "LastActivityDate": "2014-10-17T07:17:28.550"}, "26430938": {"ParentId": "26419786", "CommentCount": "0", "Body": "<p>In the comments, you emphasized that you wanted to know <em>why</em> <code>new</code> is designed this way.  In my mind, it's all about object composition.</p>\n<p>Consider a class Foo which contains (among other things) a std::vector.</p>\n<pre><code>class Foo {\n  public:\n    explicit Foo(std::size_t n) : m_vec(n, 'A') {}\n    ...\n  private:\n    std::vector&lt;char&gt; m_vec;\n    ...\n};\n</code></pre>\n<p>When you construct a Foo in dynamic memory, there are two memory allocations:  one of the Foo itself, and one for the contents of its vector.  If either one fails, you need to be assured that there are no leaks and that the problem is reported to the caller.</p>\n<pre><code>Foo * pfoo = new Foo(desired_size);\n</code></pre>\n<p>Suppose <code>new</code> did return a null pointer upon failure.  If the allocation for the Foo fails, <code>pfoo</code> will be set to a null pointer, and you could rely on that to do your error detection.  Terrific.  You then have some error handling code like:</p>\n<pre><code>if (pfoo == nullptr) { ... }\n</code></pre>\n<p>Now consider the nested object.  If the allocation for the contents of <code>m_vec</code> fails, you'd have to detect that and report it to the calling code, but there's no way for you to get a null pointer to propagate out to the assignment to <code>pfoo</code>.  The only way to do that is to have std::vector throw an exception (for <em>any</em> kind of construction problem), so the error handling code we just added would be useless because it's looking for null pointer instead of exceptions.</p>\n<p>Having <code>new</code> throw a <code>std::bad_alloc</code> allows you to treat nested dynamic memory allocation failures the same way you treat outer ones.  That's a powerful way to avoid code duplication and errors.</p>\n<p>The C++ committee could have let <code>new</code> return a null pointer on an allocation failure, but every constructor that used <code>new</code> for internal memory would have to detect the failure and turn it into an exception anyway.  So having <code>new</code> throw by default simplifies everyone's code.</p>\n<p>For those cases where your constructor can do something reasonable even in the face of an allocation failure, you can explicitly ask for the null pointer with <code>std::nothrow</code> and then handle the error (or you can catch the <code>std::bad_alloc</code>).</p>\n<h2>Aside</h2>\n<p>Also consider what happens if we stack allocate a Foo.</p>\n<pre><code>Foo foo(desired_size, 'B');\n</code></pre>\n<p>If we had somehow managed to make construction problems return a null pointer, how would the calling code detect it?</p>\n", "OwnerUserId": "1386054", "PostTypeId": "2", "Id": "26430938", "Score": "6", "CreationDate": "2014-10-17T18:07:24.490", "LastActivityDate": "2014-10-17T18:07:24.490"}, "26419989": {"ParentId": "26419786", "CommentCount": "0", "Body": "<p>By default, when the new operator is used to attempt to allocate memory and the handling function is unable to do so, a bad_alloc exception is thrown. But when nothrow is used as argument for new, it returns a null pointer instead.</p>\n<p>The nothrow constant is a value of type nothrow_t, with the only purpose of triggering an overloaded version of the function operator new (or operator new[]) that takes an argument of this type. The value itself is not used, but that version of operator new shall return a null pointer in case of failure instead of throwing an exception.</p>\n", "OwnerUserId": "4108963", "PostTypeId": "2", "Id": "26419989", "Score": "1", "CreationDate": "2014-10-17T07:26:12.740", "LastActivityDate": "2014-10-17T07:26:12.740"}, "26432264": {"ParentId": "26419786", "CommentCount": "0", "Body": "<p>In C, all requests for dynamic memory are made by function calls; it's necessary that code check any allocation requests to see if they return <code>null</code>, but there is a well-defined place where such checks can be made (i.e. right after the call).  In C++, while it is possible for code to construct objects by calling <code>new</code>, most objects are created by creating an object in which they play a part.</p>\n<p>Given:</p>\n<pre><code>class Story\n{\n  Potter harry;\n  Weasley ron,ginny,george,fred;\n  Grainger hermione;\n  Longbottom neville;\n  Creevy colin;\n  Story()\n  {\n  }\n}\n</code></pre>\n<p>If the constructor for <code>harry</code> tries to create a <code>new</code> object and fails, the only way to prevent the system from trying uselessly to create objects for all the other fields would be to have the constructor throw an exception.  Even though the constructor for <code>harry</code> failed, the other constructors might <em>succeed</em> in creating those objects if they require less memory than a <code>Potter</code> object; since the failure to create <code>harry</code> would render the <code>Story</code> object useless, however, any effort spent creating objects for the remaining fields would not only be wasted, but would require the system to expend even more effort destroying those uselessly-created objects.</p>\n<p>Since in most cases the only thing the system would be able to do when <code>new</code> fails is to throw an exception, it's easier to have <code>new</code> throw the exception itself and have code catch the exception if necessary, than to require that all code which calls <code>new</code> must check whether it succeeded and throw an exception if it didn't.</p>\n", "OwnerUserId": "363751", "PostTypeId": "2", "Id": "26432264", "Score": "3", "CreationDate": "2014-10-17T19:38:33.323", "LastActivityDate": "2014-10-17T19:38:33.323"}});