post_cb({"bq_ids": {"n4140": {"so_5912689_5912745_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 231}, "so_5912689_5912745_1": {"length": 5, "quality": 1.0, "section_id": 231}, "so_5912689_5912745_2": {"length": 29, "quality": 1.0, "section_id": 268}}, "n3337": {"so_5912689_5912745_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 224}, "so_5912689_5912745_1": {"length": 5, "quality": 1.0, "section_id": 224}, "so_5912689_5912745_2": {"length": 29, "quality": 1.0, "section_id": 259}}, "n4659": {"so_5912689_5912745_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 239}, "so_5912689_5912745_1": {"length": 5, "quality": 1.0, "section_id": 239}, "so_5912689_5912745_2": {"length": 29, "quality": 1.0, "section_id": 275}}}, "5912745": {"Id": "5912745", "PostTypeId": "2", "Body": "<p>I think that's <em>undefined behavior</em> according to the standard.  There are no restrictions on what a toolchain can do in cases of UB, generating a compiler error is one of the friendlier possibilities.</p>\n<hr>\n<p>Section <code>[temp.spec]</code>, 14.7p5 says</p>\n<blockquote>\n<p id=\"so_5912689_5912745_0\">For a given template and a given set of <em>template-arguments</em>,</p>\n<ul>\n<li>an explicit instantiation de\ufb01nition shall appear at most once in a program,</li>\n<li>an explicit specialization shall be de\ufb01ned at most once in a program (according to 3.2), and</li>\n<li>both an explicit instantiation and a declaration of an explicit specialization shall not appear in a\n  program unless the explicit instantiation follows a declaration of the explicit specialization.</li>\n</ul>\n<p id=\"so_5912689_5912745_1\">An implementation is not required to diagnose a violation of this rule.</p>\n</blockquote>\n<p>Section <code>[temp.expl.spec]</code> 14.7.3p6 says:</p>\n<blockquote>\n<p id=\"so_5912689_5912745_2\">If a template, a member template or a member of a class template is explicitly specialized then <strong>that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place</strong>, in every translation unit in which such a use occurs; no diagnostic is required.</p>\n</blockquote>\n<hr>\n<p>Your program violates these requirements.</p>\n</hr></hr>", "LastEditorUserId": "103167", "LastActivityDate": "2011-05-06T14:27:58.397", "Score": "10", "CreationDate": "2011-05-06T14:19:52.320", "ParentId": "5912689", "CommentCount": "2", "OwnerUserId": "103167", "LastEditDate": "2011-05-06T14:27:58.397"}, "5912689": {"ViewCount": "839", "Body": "<p>Consider next example :</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt; int a &gt;\nvoid foo();\n\nint main(int argn, char* argv[])\n{\n    foo&lt;1&gt;();\n}\n\ntemplate&lt;&gt;\nvoid foo&lt;1&gt;()\n{\n    std::cout&lt;&lt;1&lt;&lt;std::endl;\n}\n</code></pre>\n<p>The compilation fails with next error messages :</p>\n<pre><code>rg.cpp:12: error: specialization of \u2018void foo() [with int a = 1]\u2019 after instantiation\n</code></pre>\n<p>What paragraph in the standard explains this error?</p>\n<p>PS :I know that if I move the function definition in front of main will make the error go away.</p>\n", "AcceptedAnswerId": "5912745", "Title": "Specialization of template function after point of use will break the compilation", "CreationDate": "2011-05-06T14:14:31.637", "Id": "5912689", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2011-05-06T14:27:58.397", "Score": "5", "OwnerUserId": "476681", "Tags": "<c++><specialization><language-lawyer><template-function>", "AnswerCount": "1"}});