post_cb({"46736040": {"ParentId": "46735324", "LastEditDate": "2017-10-14T10:02:12.370", "CommentCount": "5", "CreationDate": "2017-10-13T18:30:57.570", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "PostTypeId": "2", "Id": "46736040", "Score": "2", "Body": "<h3>1) Your approach works:</h3>\n<p>Working with <code>const</code> pointers ensure that constness is not casted away:  </p>\n<blockquote>\n<p id=\"so_46735324_46736040_0\"><strong>5.2.10/2</strong> The reinterpret_cast operator shall not cast away constness.</p>\n</blockquote>\n<p>The pointer conversion is safe, because <code>char</code> has not a stricter alignment requirement than <code>some_type</code>, so that you may convert <code>rep</code> back to a <code>some_type*</code>:</p>\n<blockquote>\n<p id=\"so_46735324_46736040_1\"><strong>5.2.10/7</strong> An object pointer can be explicitly converted to an object pointer of a different type. (...) Converting a prvalue of type\n  \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are\n  object types and where the alignment requirements of T2 are no\n  stricter than those of T1) and back to its original type yields the\n  original pointer value.</p>\n</blockquote>\n<p><strong>Edit:</strong> In my understanding, there is no doubt about inter-convertibility between the pointer to an object and the pointer to its representation:</p>\n<blockquote>\n<p id=\"so_46735324_46736040_2\"><strong>1.8/6:</strong> Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the first\n  byte it occupies.</p>\n<p id=\"so_46735324_46736040_3\"><strong>3.9/4:</strong> The object representation of an object of type T <strong>is the sequence</strong> of N unsigned char objects <strong>taken up by the object</strong> of type T,\n  where N equals sizeof(T).</p>\n</blockquote>\n<p>I understand that \"taken up\" is a synonym of \"occupies\". Note also that, the <code>&amp;</code> operator guarantees that:    </p>\n<blockquote>\n<p id=\"so_46735324_46736040_4\"><strong>5.3.1/3:</strong> (...) if the type of the expression is T, the result has type \u201cpointer to T\u201d and is a prvalue that is the address of the\n  designated object</p>\n</blockquote>\n<h3>2) The object representation is initialized with the object:</h3>\n<p>This is induced from the definition of the value representation, taken together with the memory model and the object lifecylcle. </p>\n<p>However, your example is more complex:  </p>\n<ul>\n<li><code>rep[0]</code> may despite this property remain an undetermined value, if it is composed solely of padding bits. This is the case in your example, because the object has at least a size of 1, but as you have no member in it, the value representation is empty.  </li>\n<li><code>rep[1]</code> can be undefined behavior, if <code>sizeof(some_type)&lt;2</code> because dereferencing a pointer passed the last element of an array is UB.      </li>\n</ul>\n<h3>3) What is the object representation (in plain language) ?</h3>\n<p>Let's take a simple example: </p>\n<pre><code>class some_other_type {\n    int a;\n    std::string s;\n};\n</code></pre>\n<p>There is an ambiguity when speaking about the memory occupied by an object:</p>\n<ul>\n<li>is it only the fixed size contiguous memory corresponding to the its type (i.e. an <code>int</code>, some <code>size_t</code> for the string's length and some pointer to the chars in the string, like it would be done in C) ? </li>\n<li>or is it all the values stored in memory for the object, including at some values stored in memory places allocated somewhere else (e.g. also the bytes required to store the value of our string) ? </li>\n</ul>\n<p>The <em>object representation</em>  corresponds to the first part. For objects that are not trivially copiable, the object representation is not self sufficient (i.e. in our example, the bytes stored in the string are not necessarily part of the object representation).</p>\n<p>The <em>value representation</em> corresponds to the second part (and would include the bytes required to store the value of the string).</p>\n<p>In plain words, this means that the address of an object <em>is</em> the address of its representation, but the object representation may contain padding and may not be sufficient to hold every data that belongs to the object. </p>\n", "LastActivityDate": "2017-10-14T10:02:12.370"}, "46735324": {"CommentCount": "18", "CreationDate": "2017-10-13T17:41:06.503", "PostTypeId": "1", "AcceptedAnswerId": "46736040", "LastEditorUserId": "3723423", "LastActivityDate": "2017-10-14T10:02:12.370", "LastEditDate": "2017-10-13T18:15:03.847", "ViewCount": "68", "FavoriteCount": "1", "Title": "How to access an object representation according to the c++ standard?", "Id": "46735324", "Score": "1", "Body": "<p>How to access <a href=\"http://eel.is/c++draft/basic.types#4\" rel=\"nofollow noreferrer\">object representation</a>?  To answer this question I divide it in 2 questions:</p>\n<h3>1. How to get a pointer to object representation?</h3>\n<p>According to the standard I can not see any way to get a pointer to an <em>object-representation</em>. It is often proposed to get it this way:</p>\n<pre><code>some_type obj{};\nconst char * rep = reinterpret_cast&lt;const unsigned char*&gt;(&amp;obj);\n</code></pre>\n<p>Nevertheless, it is not said in the standard that an <em>object</em> and its <em>object-representation</em> are <em>pointer-interconvertible</em>. Why is this code allowed by the standard?</p>\n<h3>2. Can we consider that the object-representation is initialized when the object is initialized?</h3>\n<pre><code>some_type obj{};\nconst char * rep = reinterpret_cast&lt;const unsigned char*&gt;(&amp;obj);\nchar x = rep[0] + rep[1];\n</code></pre>\n<p>Here <code>obj</code> is default initialized. How the compiler interpret <code>rep[0]</code>, is it an <em>indeterminate-value</em>, or may be it depends on what bytes of memory have been initialized during <code>obj</code> initialization?</p>\n", "Tags": "<c++><pointers><object><language-lawyer><undefined-behavior>", "OwnerUserId": "5632316", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46735324_46736040_2": {"section_id": 5795, "quality": 0.8666666666666667, "length": 13}, "so_46735324_46736040_0": {"section_id": 6041, "quality": 0.7142857142857143, "length": 5}, "so_46735324_46736040_1": {"section_id": 6046, "quality": 0.9696969696969697, "length": 32}, "so_46735324_46736040_4": {"section_id": 6066, "quality": 0.9, "length": 9}, "so_46735324_46736040_3": {"section_id": 7202, "quality": 0.8125, "length": 13}}, "n3337": {"so_46735324_46736040_2": {"section_id": 5568, "quality": 0.8666666666666667, "length": 13}, "so_46735324_46736040_0": {"section_id": 5809, "quality": 0.7142857142857143, "length": 5}, "so_46735324_46736040_1": {"section_id": 5814, "quality": 0.9696969696969697, "length": 32}, "so_46735324_46736040_4": {"section_id": 5834, "quality": 0.9, "length": 9}, "so_46735324_46736040_3": {"section_id": 6946, "quality": 0.8125, "length": 13}}, "n4659": {"so_46735324_46736040_2": {"section_id": 7254, "quality": 0.8666666666666667, "length": 13}, "so_46735324_46736040_0": {"section_id": 7540, "quality": 0.7142857142857143, "length": 5}, "so_46735324_46736040_1": {"section_id": 7545, "quality": 0.9696969696969697, "length": 32}, "so_46735324_46736040_4": {"section_id": 7562, "quality": 0.9, "length": 9}, "so_46735324_46736040_3": {"section_id": 8711, "quality": 0.8125, "length": 13}}}});