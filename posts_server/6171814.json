post_cb({"6171926": {"ParentId": "6171814", "CommentCount": "0", "Body": "<p>IMHO this has to do with <strong>limitation of arrays to deal with constructor/destructor</strong>. Note that, when <code>new[]</code> is called, compiler forces to instantiate only <strong>default constructor</strong>. In the same way when <code>delete[]</code> is called, compiler <strong>might</strong> look for only the destructor of calling pointer's static type.</p>\n<p>Now in the case of <code>virtual</code> destructor, Derived class destructor should be called first followed by the Base class. Since for arrays compiler <strong>might</strong> see the static type of calling object (here Base) type, it might end up calling just Base destructor; which is UB.</p>\n<p>Having said that, it's not necessarily UB for all compilers; say <a href=\"http://www.ideone.com/1jbVP\" rel=\"nofollow\">for example gcc</a> calls destructor in proper order.</p>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "6171926", "Score": "0", "CreationDate": "2011-05-30T03:02:06.293", "LastActivityDate": "2011-05-30T03:02:06.293"}, "6172025": {"ParentId": "6171814", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It's wrong to treat an array-of-derived as an array-of-base, not only when deleting items. For example even just accessing the elements will usually cause disaster:</p>\n<pre><code>B *b = new D[10];\nb[5].foo();\n</code></pre>\n<p><code>b[5]</code> will use the size of <code>B</code> to calculate which memory location to access, and if <code>B</code> and <code>D</code> have different sizes, this will not lead to the intended results.</p>\n<p>Just like a <code>std::vector&lt;D&gt;</code> can't be converted to a <code>std::vector&lt;B&gt;</code>, a pointer to <code>D[]</code> shouldn't be convertible to a <code>B*</code>, but for historic reasons it compiles anyway. If a <code>std::vector</code> would be used instead, it would produce a compile time error.</p>\n<p>This is also explained in the <a href=\"http://www.parashift.com/c++-faq-lite/proper-inheritance.html#faq-21.4\" rel=\"noreferrer\">C++ FAQ Lite answer on this topic</a>.</p>\n<p>So <code>delete</code> causes undefined behavior in this case because it's already wrong to treat an array in this way, even though the type system can't catch the error.</p>\n", "OwnerUserId": "56338", "LastEditorUserId": "56338", "LastEditDate": "2013-12-28T17:17:54.113", "Id": "6172025", "Score": "11", "CreationDate": "2011-05-30T03:26:04.040", "LastActivityDate": "2013-12-28T17:17:54.113"}, "6171991": {"ParentId": "6171814", "CommentCount": "13", "Body": "<p><code>Base* p = new Base[n]</code> creates an <code>n</code>-sized array of <code>Base</code> elements, of which <code>p</code> then points to the first element. <code>Base* p = new Derived[n]</code> however, creates an <code>n</code>-sized array of <code>Derived</code> elements. <code>p</code> then points to the <code>Base</code> <em>subobject of the first element</em>. <code>p</code> does <strong>not</strong> however refer to the first <em>element</em> of the array, which is what a valid <code>delete[] p</code> expression requires.</p>\n<p>Of course it would be possible to mandate (and then implement) that <code>delete [] p</code> Does The Right Thing\u2122 in this case. But what would it take? An implementation would have to take care to somehow retrieve the element type of the array, and then morally <code>dynamic_cast</code> <code>p</code> to this type. Then it's a matter of doing a plain <code>delete[]</code> like we already do.</p>\n<p>The problem with that is that this would be needed <em>every time</em> an array of polymorphic element type, regardless of whether the polymorphism is used on not. In my opinion, this doesn't fit with the C++ philosophy of not paying for what you don't use. But worse: a polymorphic-enabled <code>delete[] p</code> is simply useless because <code>p</code> is almost useless in your question. <code>p</code> is a pointer to a subobject of an element and no more; it's otherwise completely unrelated to the array. You certainly can't do <code>p[i]</code> (for <code>i &gt; 0</code>) with it. So it's not unreasonable that <code>delete[] p</code> doesn't work.</p>\n<p><strong>To sum up:</strong></p>\n<ul>\n<li><p>arrays already have plenty of legitimate uses. By not allowing arrays to behave polymorphically (either as a whole or only for <code>delete[]</code>) this means that arrays with a polymorphic element type are not penalized for those legitimate uses, which is in line with the philosophy of C++.</p></li>\n<li><p>if on the other hand an array with polymorphic behaviour is needed, it's possible to implement one in terms of what we have already.</p></li>\n</ul>\n", "OwnerUserId": "726300", "PostTypeId": "2", "Id": "6171991", "Score": "27", "CreationDate": "2011-05-30T03:17:45.303", "LastActivityDate": "2011-05-30T03:17:45.303"}, "46765071": {"ParentId": "6171814", "CommentCount": "0", "Body": "<p>Just to add to the excellent answer of <strong><em>sth</em></strong> - I have written a short example to illustrate this issue with different offsets.</p>\n<p>Note that if you comment out the m_c member of the Derived class, the delete operation will work well.</p>\n<p>Cheers,</p>\n<p>Guy.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Base \n{\n\n    public:\n        Base(int a, int b)\n        : m_a(a)\n        , m_b(b)    \n        {\n           cout &lt;&lt; \"Base::Base - setting m_a:\" &lt;&lt; m_a &lt;&lt; \" m_b:\" &lt;&lt; m_b &lt;&lt; endl;\n        }\n\n        virtual ~Base()\n        {\n            cout &lt;&lt; \"Base::~Base\" &lt;&lt; endl;\n        }\n\n        protected:\n            int m_a;\n            int m_b;\n};\n\n\nclass Derived : public Base\n{\n    public:\n    Derived() \n    : Base(1, 2) , m_c(3)   \n    {\n\n    }\n\n    virtual ~Derived()\n    {\n        cout &lt;&lt; \"Derived::Derived\" &lt;&lt; endl;\n    }\n\n    private:    \n    int m_c;\n};\n\nint main(int argc, char** argv)\n{\n    // create an array of Derived object and point them with a Base pointer\n    Base* pArr = new Derived [3];\n\n    // now go ahead and delete the array using the \"usual\" delete notation for an array\n    delete [] pArr;\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "1971003", "PostTypeId": "2", "Id": "46765071", "Score": "1", "CreationDate": "2017-10-16T07:30:58.230", "LastActivityDate": "2017-10-16T07:30:58.230"}, "6171814": {"CommentCount": "10", "AcceptedAnswerId": "6171991", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2011-05-30T02:35:40.393", "LastActivityDate": "2017-10-16T07:30:58.230", "LastEditDate": "2015-07-31T19:16:57.417", "ViewCount": "5557", "FavoriteCount": "20", "Title": "Why is it undefined behavior to delete[] an array of derived objects via a base pointer?", "Id": "6171814", "Score": "30", "Body": "<p>I found the following snippet in the C++03 Standard under <code>5.3.5 [expr.delete] p3</code>:</p>\n<blockquote>\n<p id=\"so_6171814_6171814_0\">In the first alternative (<em>delete object</em>), if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined. <strong>In the second alternative (<em>delete array</em>) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</strong></p>\n</blockquote>\n<hr>\n<p>Quick review on static and dynamic types:</p>\n<pre><code>struct B{ virtual ~B(){} };\nstruct D : B{};\n\nB* p = new D();\n</code></pre>\n<p>Static type of <code>p</code> is <code>B*</code>, while the dynamic type of <code>*p</code> is <code>D</code>, <code>1.3.7 [defns.dynamic.type]</code>:</p>\n<blockquote>\n<p id=\"so_6171814_6171814_1\">[<em>Example</em>: if a pointer <code>p</code> whose static type is \u201cpointer to <code>class B</code>\u201d is pointing to an object of <code>class D</code>, derived from <code>B</code>, the dynamic type of the expression <code>*p</code> is \u201c<code>D</code>.\u201d]</p>\n</blockquote>\n<hr>\n<p>Now, looking at the quote at the top again, this would mean that the follwing code invokes undefined behaviour if I got that right, regardless of the presence of a <code>virtual</code> destructor:</p>\n<pre><code>struct B{ virtual ~B(){} };\nstruct D : B{};\n\nB* p = new D[20];\ndelete [] p; // undefined behaviour here\n</code></pre>\n<p>Did I misunderstand the wording in the standard somehow? Did I overlook something? Why does the standard specify this as undefined behaviour?</p>\n</hr></hr>", "Tags": "<c++><undefined-behavior><dynamic-arrays><delete-operator>", "OwnerUserId": "500104", "AnswerCount": "5"}, "6171897": {"ParentId": "6171814", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I <em>think</em> it all comes down to the zero-overhead principle. i.e. the language doesn't allow storing information about the dynamic type of elements of the array.</p>\n", "OwnerUserId": "127893", "LastEditorUserId": "127893", "LastEditDate": "2011-05-30T03:02:23.780", "Id": "6171897", "Score": "0", "CreationDate": "2011-05-30T02:57:12.987", "LastActivityDate": "2011-05-30T03:02:23.780"}, "bq_ids": {"n4140": {"so_6171814_6171814_0": {"section_id": 6107, "quality": 0.925, "length": 37}, "so_6171814_6171814_1": {"section_id": 5768, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_6171814_6171814_0": {"section_id": 5873, "quality": 0.925, "length": 37}, "so_6171814_6171814_1": {"section_id": 5541, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_6171814_6171814_0": {"section_id": 7604, "quality": 0.925, "length": 37}, "so_6171814_6171814_1": {"section_id": 7225, "quality": 0.9285714285714286, "length": 13}}}});