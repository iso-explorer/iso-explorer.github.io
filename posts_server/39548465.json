post_cb({"bq_ids": {"n4140": {"so_39548465_39625214_3": {"length": 24, "quality": 0.8, "section_id": 5313}, "so_39548465_39548869_0": {"length": 8, "quality": 1.0, "section_id": 7214}, "so_39548465_39552788_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 5344}, "so_39548465_39625214_2": {"length": 15, "quality": 0.9375, "section_id": 5364}, "so_39548465_39552788_1": {"length": 15, "quality": 0.9375, "section_id": 5364}, "so_39548465_39548869_1": {"length": 4, "quality": 0.8, "section_id": 5768}, "so_39548465_39548465_2": {"length": 8, "quality": 0.5333333333333333, "section_id": 551}, "so_39548465_39548465_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 7214}}, "n3337": {"so_39548465_39625214_3": {"length": 24, "quality": 0.8, "section_id": 5110}, "so_39548465_39548869_0": {"length": 8, "quality": 1.0, "section_id": 6958}, "so_39548465_39548465_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 6958}, "so_39548465_39548869_1": {"length": 4, "quality": 0.8, "section_id": 5541}, "so_39548465_39552788_1": {"length": 15, "quality": 0.9375, "section_id": 5160}, "so_39548465_39625214_2": {"length": 15, "quality": 0.9375, "section_id": 5160}, "so_39548465_39548465_2": {"length": 8, "quality": 0.5333333333333333, "section_id": 542}, "so_39548465_39552788_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 5141}}, "n4659": {"so_39548465_39625214_3": {"length": 24, "quality": 0.8, "section_id": 6737}, "so_39548465_39548869_0": {"length": 8, "quality": 1.0, "section_id": 8723}, "so_39548465_39548465_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 8723}, "so_39548465_39625214_2": {"length": 15, "quality": 0.9375, "section_id": 6788}, "so_39548465_39552788_1": {"length": 15, "quality": 0.9375, "section_id": 6788}, "so_39548465_39548869_1": {"length": 4, "quality": 0.8, "section_id": 7225}, "so_39548465_39548465_2": {"length": 8, "quality": 0.5333333333333333, "section_id": 572}, "so_39548465_39552788_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 6769}}}, "39625214": {"Id": "39625214", "PostTypeId": "2", "Body": "<p>Let's start from first principles:</p>\n<blockquote>\n<p id=\"so_39548465_39625214_0\"><em>(\u00a73.7.3)</em> <strong>wide character:</strong> bit representation that fits in an object of type\n  wchar_t, capable of representing any character in the current locale</p>\n<p id=\"so_39548465_39625214_1\"><em>(\u00a73.7)</em> <strong>character:</strong> \u3008abstract\u3009 member of a set of elements used for the\n  organization, control, or representation of data</p>\n</blockquote>\n<p>That, right away, discards full Unicode as a character set (a set of elements/characters) representable on 16-bit <code>wchar_t</code>.</p>\n<p>But wait, <a href=\"https://stackoverflow.com/a/39552788/371250\">Nicol Bolas quoted the following</a>:</p>\n<blockquote>\n<p id=\"so_39548465_39625214_2\">The size of a char32_t or wide string literal is the total number of\n  escape sequences, universal-character-names, and other characters,\n  plus one for the terminating U\u2019\\0\u2019 or L\u2019\\0\u2019.</p>\n</blockquote>\n<p>and then wondered about the behavior for characters outside the execution character set. Well, C99 has the following to say about this issue:</p>\n<blockquote>\n<p id=\"so_39548465_39625214_3\"><em>(\u00a75.1.1.2)</em> Each source character set member and escape sequence in character\n  constants and string literals is converted to the corresponding member\n  of the execution character set; if there is no corresponding member,\n  it is converted to an implementation- defined member other than the\n  null (wide) character.8)</p>\n</blockquote>\n<p>and further clarifies in a footnote that not all source characters need to map to the same execution character.</p>\n<p>Armed with this knowledge, you can declare that your wide execution character set is the Basic Multilingual Plane, and that you consider surrogates as proper characters themselves, not as mere surrogates for other characters. AFAICT, this means you are in the clear as far as Clause 6 (Language) of ISO C99 cares.</p>\n<p>Of course, don't expect Clause 7 (Library) to play along nicely with you. As an example, consider <code>iswalpha(wint_t)</code>. You cannot pass astral characters (characters outside the BMP) to that function, you can only pass it the two surrogates. And you'd get some nonsensical result, but that's fine because you declared the surrogate themselves to be proper members of the execution character set.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-21T19:40:48.543", "Score": "0", "CreationDate": "2016-09-21T19:40:48.543", "ParentId": "39548465", "CommentCount": "1", "OwnerUserId": "371250", "LastEditDate": "2017-05-23T12:15:03.633"}, "39552788": {"Id": "39552788", "PostTypeId": "2", "Body": "<p><code>wchar_t</code> is not now and never was a Unicode character/code point. The C++ standard does not declare that a wide-string literal will contain Unicode characters. The C++ standard does not declare that a wide-character literal will contain a Unicode character. Indeed, the standard doesn't say <em>anything</em> about what <code>wchar_t</code> will contain.</p>\n<p><code>wchar_t</code> can be used with locale-aware APIs, but those are only relative to the implementation-defined encoding, not any particular Unicode encoding. The standard library functions that take these use their knowledge of the implementation's encoding to do their jobs.</p>\n<p>So, is a 16-bit <code>wchar_t</code> legal? Yes; the standard does not require that <code>wchar_t</code> be sufficiently large to hold a Unicode codepoint.</p>\n<p>Is a string of <code>wchar_t</code> permitted to hold UTF-16 values (or variable width in general)? Well, you are permitted to make strings of <code>wchar_t</code> that store whatever you want (so long as it fits). So for the purposes of the standard, the question is whether standard-provided means for generating <code>wchar_t</code> characters and strings are permitted to use UTF-16.</p>\n<p>Well, the standard library can do whatever it wants to; the standard offers no guarantee that a conversion from any particular character encoding to <code>wchar_t</code> will be a 1:1 mapping. Even <code>char</code>-&gt;<code>wchar_t</code> conversion via <code>wstring_convert</code> is not required anywhere in the standard to produce a 1:1 character mapping.</p>\n<p>If a compiler wishes to declare that the wide character set consists of the Base Multilingual Plane of Unicode, then a declaration like this <code>L'\\U0001F000'</code> will produce a single <code>wchar_t</code>. But the value is implementation-defined, per [lex.ccon]/2:</p>\n<blockquote>\n<p id=\"so_39548465_39552788_0\">The value of a wide-character literal containing a single c-char has value equal to the numerical value of the encoding of the c-char in the execution wide-character set, unless the c-char has no representation in the execution wide-character set, in which case the value is implementation-defined.</p>\n</blockquote>\n<p>And of course, C++ doesn't allow to use surrogate pairs as a <em>c-char</em>; <code>\\uD800</code> is a compile error.</p>\n<p>Where things get murky in the standard is the treatment of <em>strings</em> that contain characters outside of the character set. The above text would suggest that implementations can do what they want. And yet, [lex.string]\\16 says this:</p>\n<blockquote>\n<p id=\"so_39548465_39552788_1\">The size of a <code>char32_t</code> or wide string literal is the total number of escape sequences, universal-character-names, and other characters, plus\n  one for the terminating U\u2019\\0\u2019 or L\u2019\\0\u2019.</p>\n</blockquote>\n<p>I say this is murky because nothing says what the behavior should be if a <em>c-char</em> in a string literal is outside the range of the destination character set.</p>\n<p>Windows compilers (both VS and GCC-on-Windows) do indeed cause <code>L\"\\U0001F000\"</code> to have an array size of 3 (two surrogate pairs and a single NUL terminator). Is that legal C++ standard behavior? What does it mean to provide a <em>c-char</em> to a string literal that is outside of the valid range for a character set?</p>\n<p>I would say that this is a hole in the standard, rather than a deficiency in those compilers. It should make it more clear what the conversion behavior in this case ought to be.</p>\n<hr>\n<p>In any case, <code>wchar_t</code> is not an appropriate tool for processing Unicode-encoded text. It is not \"formally valid\" for representing <em>any form</em> of Unicode. Yes, many compilers implement wide-string literals as a Unicode encoding. But since the standard doesn't require this, you cannot rely on it.</p>\n<p>Now obviously, you can stick whatever will fit inside of a <code>wchar_t</code>. So even on platforms where <code>wchar_t</code> is 32-bits, you could shove UTF-16 data into them, with each 16-bit word taking up 32-bits. But you couldn't pass such text to any API function that expects the wide character encoding unless you knew that this was the expected encoding for that platform.</p>\n<p>Basically, never use <code>wchar_t</code> if you want to work with a Unicode encoding.</p>\n</hr>", "LastEditorUserId": "734069", "LastActivityDate": "2016-09-19T20:12:10.993", "Score": "2", "CreationDate": "2016-09-17T23:47:52.783", "ParentId": "39548465", "CommentCount": "7", "OwnerUserId": "734069", "LastEditDate": "2016-09-19T20:12:10.993"}, "39548869": {"Id": "39548869", "PostTypeId": "2", "Body": "<p>After clarifying what the question is i will do an edit.\nQ: Is the width of 16 bits for wchar_t in Windows conformant to the standard?</p>\n<p>A: Well, lets see. We will start with the definition of wchar_t from c99 draft.</p>\n<blockquote>\n<p id=\"so_39548465_39548869_0\">... largest extended character set specified among the <strong>supported</strong> locales.</p>\n</blockquote>\n<p>So, we should look what are the supported locales. For that there are Three steps:</p>\n<ol>\n<li>We check the documentation for <a href=\"https://msdn.microsoft.com/en-us/library/x99tb11d.aspx\" rel=\"nofollow\">setlocale</a></li>\n<li><p>We quickly open the documentation for the <a href=\"https://msdn.microsoft.com/en-us/library/hzz3tw78.aspx\" rel=\"nofollow\">locale string</a>. We see the format of the string</p>\n<pre><code>locale :: \"locale_name\"\n        | \"language[_country_region[.code_page]]\"\n        | \".code_page\"\n        | \"C\"\n        | \"\"\n        | NULL\n</code></pre></li>\n<li><p>We see the list of supported <a href=\"https://msdn.microsoft.com/library/windows/desktop/dd317756.aspx\" rel=\"nofollow\">Code pages</a> and we see UTF-8, UTF-16, UTF-32 and what not. We're in a dead end.</p></li>\n</ol>\n<p>If we start with the C99 definition, it ends with</p>\n<blockquote>\n<p id=\"so_39548465_39548869_1\">... corresponds to a member of the extended character set.</p>\n</blockquote>\n<p>The word \"character set\" is used. But if we say UTF-16 code units are our character set, then all is OK. Otherwise, it's not. It's kinda vague, and one should not care much. The standards were defined many years ago, when Unicode was not popular.</p>\n<p>At the end of the day, we now have C++11 and C11 that define use cases for UTF-8, 16 and 32 with the additional types char16_t and char32_t.</p>\n<hr>\n<p>You need yo read about Unicode and you will answer the question yourself.</p>\n<p>Unicode is a character set. Set of characters, it's about 200000 characters. Or more precisely it is a mapping, mapping between numbers and characters. Unicode by itself does not mean this or that bit width.</p>\n<p>Then there are 4 encodings, UTF-7, UTF-8, UTF-16 and UTF-32. UTF stands for Unicode transformation format.\nEach format defines a code point and a code unit. Code point is an actual charter from Unicode and can consists of one or more units. Only UTF-32 has one unit per point.</p>\n<p>On the other hand, each unit fits into a fixed size integer. So UTF-7 units are at most 7 bits, UTF-16 units are at most 16 bits etc.</p>\n<p>Therefore, in a 16 bit wchar_t string we can hold Unicode text encoded in UTF-16. Particularly in UTF-16 each point takes one or two units.</p>\n<p>So the final answer, in a single wchar_t you can not store all Unicode char, only the single unit ones, but in a string of wchar_t you can store any Unicode text.</p>\n</hr>", "LastEditorUserId": "4556696", "LastActivityDate": "2016-09-17T19:02:40.767", "Score": "-1", "CreationDate": "2016-09-17T16:02:24.880", "ParentId": "39548465", "CommentCount": "6", "OwnerUserId": "4556696", "LastEditDate": "2016-09-17T19:02:40.767"}, "39548465": {"ViewCount": "506", "Body": "<p>In the \u00b9comp.lang.c++ Usenet group I recently asserted, based on what I thought I knew, that Windows' 16-bit <code>wchar_t</code>, with UTF-16 encoding where sometimes two such values (called a \u201csurrogate pair\u201d) is needed for a single Unicode code point, is invalid for representing Unicode.</p>\n<p>It's certainly inconvenient and in conflict with the assumption of the C and C++ standard libraries (e.g. character classification) that each code point is represented as a single value, although the Unicode consortium's \u00b2Technical Note 12 from 2004 makes a good case for using UTF-16 for internal processing, with an impressive list of software that does.</p>\n<p>And certainly it seems as if the original <em>intent</em> was to have one <code>wchar_t</code> value per code point, consistent with the assumptions of the C and C++ standard libraries. E.g. in the web page \u201cISO C Amendment 1 (MSE)\u201d over at \u00b3unix.org, about the amendment that brought <code>wchar_t</code> into the C standard in 1995, the authors maintain that</p>\n<blockquote>\n<p id=\"so_39548465_39548465_0\"><strong>\u201d</strong> The primary advantage to the one byte/one character model is that it is very easy to process data in fixed-width chunks. For this reason, the concept of the wide character was invented. A wide character is an abstract data type large enough to contain the largest character that is supported on a particular platform. </p>\n</blockquote>\n<p>But as it turned out, the C and C++ standards seem to not talk about the largest supported character, but only about the largest <em>extended character sets</em> in the supported <em>locales</em>: that <code>wchar_t</code> must be large enough to represent every code point in the largest such extended character set \u2013 but not Unicode, when there is no Unicode locale.</p>\n<i>C99 \u00a77.17/2 (from the N869 draft):</i>\n<blockquote>\n<p id=\"so_39548465_39548465_1\"><strong>\u201d</strong> [the <code>wchar_t</code> type] is an integer type whose range of values can represent distinct codes for all members of the largest extended character set specified among the supported locales.</p>\n</blockquote>\n<p>This is almost identically the same wording as in the C++ standard. And it seems to mean that with a restricted set of supported locales, <code>wchar_t</code> can be smallish indeed, down to a single byte with UTF-8 encoding (a nightmare possibility where e.g. no standard library character classification function would work outside of ASCII's A through Z, but hey). Possibly the following is a requirement to be wider than that:</p>\n<i>C99 \u00a77.1.1/4:</i>\n<blockquote>\n<p id=\"so_39548465_39548465_2\"><strong>\u201d</strong> A <em>wide character</em> is a code value (a binary encoded integer) of an object of type <code>wchar_t</code>  that corresponds to a member of the extended character set.</p>\n</blockquote>\n<p>\u2026 since it refers to <em>the</em> extended character set, but that term seems to not be further defined anywhere.</p>\n<p>And at least with Microsoft's C and C++ runtime there is no Unicode locale: with that implementation <code>setlocale</code> is restricted to character encodings that have at most 2 bytes per character:</p>\n<i>MSDN \u2074documentation of <code>setlocale</code>:</i>\n<blockquote>\n<p id=\"so_39548465_39548465_3\"><strong>\u201d</strong> The set of available locale names, languages, country/region codes, and code pages includes all those supported by the Windows NLS API except code pages that require more than two bytes per character, such as UTF-7 and UTF-8. If you provide a code page value of UTF-7 or UTF-8, <code>setlocale</code> will fail, returning <code>NULL</code>.</p>\n</blockquote>\n<p>So it seems that contrary to what I thought I knew, and contrary to my assertion, Windows' 16-bit <code>wchar_t</code> is formally OK. And mainly due to Microsoft's ingenious lack of support for UTF-8 locales, or any locale with more than 2 bytes per character. But is it really so, is 16-bit <code>wchar_t</code> OK?</p>\n<hr>\n<p><sup>\n<strong>Links:</strong><br>\n\u00b9 news:comp.lang.c++<br>\n\u00b2 <a href=\"http://unicode.org/notes/tn12/#Software_16\">http://unicode.org/notes/tn12/#Software_16</a><br>\n\u00b3 <a href=\"http://www.unix.org/version2/whatsnew/login_mse.html\">http://www.unix.org/version2/whatsnew/login_mse.html</a><br>\n\u2074 <a href=\"https://msdn.microsoft.com/en-us/library/x99tb11d.aspx\">https://msdn.microsoft.com/en-us/library/x99tb11d.aspx</a>\n</br></br></br></br></sup></p>\n</hr>", "Title": "Is 16-bit wchar_t formally valid for representing full Unicode?", "CreationDate": "2016-09-17T15:21:55.120", "LastActivityDate": "2016-09-21T19:40:48.543", "CommentCount": "42", "FavoriteCount": "1", "PostTypeId": "1", "Id": "39548465", "Score": "7", "OwnerUserId": "464581", "Tags": "<c++><c><winapi><unicode><encoding>", "AnswerCount": "3"}});