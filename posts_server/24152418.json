post_cb({"bq_ids": {"n4140": {"so_24152418_24361568_0": {"length": 14, "quality": 1.0, "section_id": 6185}, "so_24152418_24361568_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5418}}, "n3337": {"so_24152418_24361568_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5213}}, "n4659": {"so_24152418_24361568_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 7687}, "so_24152418_24361568_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 6839}}}, "24361568": {"Id": "24361568", "PostTypeId": "2", "Body": "<p>The place you define a <code>constexpr</code> function affects how you can use it. In particular:</p>\n<p>C++14[expr.const]p2:</p>\n<blockquote>\n<p id=\"so_24152418_24361568_0\">A conditional-expression <code>e</code> is a core constant expression unless the evaluation of <code>e</code>, following the rules of the abstract machine (1.9), would evaluate one of the following expressions:</p>\n<ul>\n<li>\u2026</li>\n<li>an invocation of an undefined <code>constexpr</code> function or an undefined <code>constexpr</code> constructor;</li>\n</ul>\n</blockquote>\n<p>So you can't use a <code>constexpr</code> function in a constant expression (template argument, <code>constexpr</code> variable initializer, global variable initializer that needs to be evaluated statically, array bound expression, maybe others) if it's only been declared but not defined yet.</p>\n<p>Similarly, as dyp commented,</p>\n<p>C++14[dcl.constexpr]p2</p>\n<blockquote>\n<p id=\"so_24152418_24361568_1\">\u2026 <code>constexpr</code> functions and <code>constexpr</code> constructors are implicitly <code>inline</code> (7.1.2).</p>\n</blockquote>\n<p>That implies the answer to your first question: defining the <code>constexpr</code> function in a header won't cause duplicate symbols. It also means that if you declare a constexpr function in a header, and then call it in a translation unit, even only at runtime, \"An inline function shall be defined in every translation unit in which it is odr-used.\" from C++14[basic.def.odr]p4.</p>\n<p>Note that the rules for constant expressions and calls in general are different: calls in general require the definition to be <em>somewhere</em> in the translation unit: constant expressions require the definition to be <em>before</em> the constant expression.</p>\n", "LastActivityDate": "2014-06-23T08:34:35.767", "CommentCount": "0", "CreationDate": "2014-06-23T08:34:35.767", "ParentId": "24152418", "Score": "3", "OwnerUserId": "943619"}, "24152418": {"ViewCount": "1144", "Body": "<p>I was wondering if there was any restrictions on where constexpr functions and methods have to be declared, like there are for inline functions and methods.</p>\n<p>I know that inline functions or methods must be written in header files, to give the compiler access to their definition where they are called. It would make sense if there was something similar for constexpr, but I can't manage to find anything on that point...</p>\n<p>So basically my questions are:</p>\n<ul>\n<li><p>Can I write the definitions of constexpr functions in a header file without taking the risk of having a duplicate symbol?</p></li>\n<li><p>Can I separate the declaration and definition of constexpr functions or methods?</p></li>\n</ul>\n", "AcceptedAnswerId": "24361568", "Title": "Declaring constexpr functions or methods", "CreationDate": "2014-06-10T23:24:33.987", "Id": "24152418", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2014-06-23T08:34:35.767", "Score": "8", "OwnerUserId": "3600266", "Tags": "<c++><c++11><constexpr>", "AnswerCount": "1"}});