post_cb({"34357636": {"CommentCount": "8", "AcceptedAnswerId": "34386075", "PostTypeId": "1", "LastEditorUserId": "2053436", "CreationDate": "2015-12-18T14:16:33.657", "LastActivityDate": "2015-12-21T21:31:45.397", "LastEditDate": "2015-12-21T21:31:45.397", "ViewCount": "175", "FavoriteCount": "1", "Title": "G++ Can't Inline Polymorphic Method?", "Id": "34357636", "Score": "2", "Body": "<p>It appears G++ with optimization can't inline a trivial function call from a translation-unit static variable. Code and compiled output example below. Notice that the function <strong>can_inline_local</strong> perfectly inlines the call by using a local instance of <em>DerivedType</em>, however <strong>cant_inline_static</strong> is a considerably longer call.</p>\n<p>Before you call the police on me for pre-mature optimization I'd like to defend myself in saying polymorphic inheritance would very clearly describe my kernel-level serial driver interrupt service routines. And if G++ could only inline the virtual calls away for me (using what I feel it should know at compile time) then I'd have clear+testable code that compiles to C performance.</p>\n<p>I'm Using arm-none-eabi-g++ -v\ngcc version 4.9.3 20150529 (prerelease) (15:4.9.3+svn227297-1) </p>\n<p><strong>arm-none-eabi-g++ -std=gnu++11 -O3 -c -o inline.o inline.cpp &amp;&amp; arm-none-eabi-objdump inline.o -S &gt; inline.dump</strong></p>\n<p><strong>inline.cpp:</strong></p>\n<pre><code>extern \"C\"{\n    int * const MEMORY_MAPPED_IO_A = (int*)0x40001000;\n    int * const MEMORY_MAPPED_IO_B = (int*)0x40002000;\n}\n\nnamespace{\n    /** Anon namespace should make these\n        typedefs static to this translation unit */\n    struct BaseType{\n        void* data;\n        virtual void VirtualMethod(int parameter){\n            *MEMORY_MAPPED_IO_A = parameter;\n        }\n\n        void VirtualCaller(int parameter){\n            this-&gt;VirtualMethod(parameter);\n        }\n    };\n\n    struct DerivedType : BaseType{\n        void VirtualMethod(int parameter) final {\n            *MEMORY_MAPPED_IO_B = parameter;\n        }\n    };\n\n    /** static keyword here may be superfluous */\n    static BaseType basetype;\n    static DerivedType derivedtype;\n\n    extern \"C\"{\n        void cant_inline_static(int parameter){\n            derivedtype.VirtualCaller(1);\n        }\n\n        void can_inline_local(int parameter){\n            DerivedType localobj;\n            localobj.VirtualCaller(1);\n        }\n    }\n}\n</code></pre>\n<p><strong>inline.dump</strong></p>\n<pre><code>inline.o:     file format elf32-littlearm\n\n\nDisassembly of section .text:\n\n00000000 &lt;_ZN12_GLOBAL__N_18BaseType13VirtualMethodEi&gt;:\n   0:   e59f3004    ldr r3, [pc, #4]    ; c &lt;_ZN12_GLOBAL__N_18BaseType13VirtualMethodEi+0xc&gt;\n   4:   e5831000    str r1, [r3]\n   8:   e12fff1e    bx  lr\n   c:   40001000    .word   0x40001000\n\n00000010 &lt;_ZN12_GLOBAL__N_111DerivedType13VirtualMethodEi&gt;:\n  10:   e59f3004    ldr r3, [pc, #4]    ; 1c &lt;_ZN12_GLOBAL__N_111DerivedType13VirtualMethodEi+0xc&gt;\n  14:   e5831000    str r1, [r3]\n  18:   e12fff1e    bx  lr\n  1c:   40002000    .word   0x40002000\n\n00000020 &lt;cant_inline_static&gt;:\n  20:   e59f0028    ldr r0, [pc, #40]   ; 50 &lt;cant_inline_static+0x30&gt;\n  24:   e5903000    ldr r3, [r0]\n  28:   e59f2024    ldr r2, [pc, #36]   ; 54 &lt;cant_inline_static+0x34&gt;\n  2c:   e5933000    ldr r3, [r3]\n  30:   e1530002    cmp r3, r2\n  34:   1a000003    bne 48 &lt;cant_inline_static+0x28&gt;\n  38:   e3a02001    mov r2, #1\n  3c:   e59f3014    ldr r3, [pc, #20]   ; 58 &lt;cant_inline_static+0x38&gt;\n  40:   e5832000    str r2, [r3]\n  44:   e12fff1e    bx  lr\n  48:   e3a01001    mov r1, #1\n  4c:   e12fff13    bx  r3\n    ...\n  58:   40002000    .word   0x40002000\n\n0000005c &lt;can_inline_local&gt;:\n  5c:   e3a02001    mov r2, #1\n  60:   e59f3004    ldr r3, [pc, #4]    ; 6c &lt;can_inline_local+0x10&gt;\n  64:   e5832000    str r2, [r3]\n  68:   e12fff1e    bx  lr\n  6c:   40002000    .word   0x40002000\n\nDisassembly of section .text.startup:\n\n00000000 &lt;_GLOBAL__sub_I_cant_inline_static&gt;:\n   0:   e59f3014    ldr r3, [pc, #20]   ; 1c &lt;_GLOBAL__sub_I_cant_inline_static+0x1c&gt;\n   4:   e59f2014    ldr r2, [pc, #20]   ; 20 &lt;_GLOBAL__sub_I_cant_inline_static+0x20&gt;\n   8:   e2831008    add r1, r3, #8\n   c:   e2833018    add r3, r3, #24\n  10:   e5821008    str r1, [r2, #8]\n  14:   e5823000    str r3, [r2]\n  18:   e12fff1e    bx  lr\n    ...\n</code></pre>\n<p><strong>UPDATE</strong></p>\n<p>Simply commenting out the <strong>void* data;</strong> field in BaseType allows aggressive optimization of trivial virtual calls. Below is the objdump. It appears that G++ may not trust using static instance methods if the class has data members that could possibly be uninitialized. Is there any way I can specify that a class is what it appears to be and needs no construction or initialization? If a compiler were to assume such things would all of C++ be invalidated due to some over-designed/esoteric feature I'm not aware of? I feel I'm grasping at straws but it's worth one more ask.</p>\n<pre><code>inline.o:     file format elf32-littlearm\n\n\nDisassembly of section .text.cant_inline_static:\n\n00000000 &lt;cant_inline_static&gt;:\n  0:    2201        movs    r2, #1\n  2:    4b01        ldr r3, [pc, #4]    ; (8 &lt;cant_inline_static+0x8&gt;)\n  4:    601a        str r2, [r3, #0]\n  6:    4770        bx  lr\n  8:    40002000    .word   0x40002000\n\nDisassembly of section .text.can_inline_local:\n\n00000000 &lt;can_inline_local&gt;:\n  0:    2201        movs    r2, #1\n  2:    4b01        ldr r3, [pc, #4]    ; (8 &lt;cant_inline_static+0x8&gt;)\n  4:    601a        str r2, [r3, #0]\n  6:    4770        bx  lr\n  8:    40002000    .word   0x40002000\n</code></pre>\n<p><strong>FINAL UPDATE</strong></p>\n<p>I've worked out the book-keeping code that occurs at the begining of <em>cant_inline_static</em>. It is simply taking the static instance <em>derivedtype</em>, de-referencing its vtable, looking up the <em>VirtualMethod</em> entry, then comparing it to the .text address of DerivedType::VirtualMethod. If they match: the inlined procedure is run. If they differ: the instance's vtable method is called.</p>\n<p>It appears that G++ expects the virtual call to ultimately be DerivedType::VirtualMethod but it is concerned that the <em>static DerivedType derivedtype</em> variable's vtable may point to a different method. If you initialize all member (and inherited member) variables of DerivedType then G++ then it gains the confidence it needs to fully inline 'VirtualMethod'. As @rici explains, it very likely has to do with the 'derivedtype' instance being palced .data (explicitly initialized) instead of .bss.</p>\n<p>An interesting point to add: If both <em>derivedtype</em> AND <em>basetype</em> instances invoke <em>VirtualCaller</em> then G++ adds book-keeping code regardless of member initialization.</p>\n<p>At this point I'm playing archaeologist by discovering how some bloke wrote this portion of the G++ optimizer. It was a fun ride. I had some really good help on here. And I learned a lot about virtual method performance in the process.</p>\n", "Tags": "<c++><c++11><gcc><arm><compiler-optimization>", "OwnerUserId": "2053436", "AnswerCount": "2"}, "34386075": {"ParentId": "34357636", "CommentCount": "1", "Body": "<p><strong>TL;DR</strong>:</p>\n<p>Replace <code>void* data;</code> with <code>void* data = 0;</code>. (If there were more data members, you would have to initialize each of them to some compile-time constant value.)</p>\n<p>Once you do that, g++ will pre-initialize <code>derivedtype</code> in the object file, rather than doing so at runtime.</p>\n<hr>\n<p><strong>Disclaimers</strong>:</p>\n<p>This is not a language-lawyer question so I didn't write a language-lawyer answer. Most of the following is <em>implementation-dependent</em>, which means that it may not apply to any particular compiler, version or phase of the moon that differ from the ones I tried. It specifically refers to GCC, and more specifically to ELF object files; that covers Intel and ARM architectures, but I make no claims about generalizing it.</p>\n<p>Static initialization in C++ is full of (some would say \"plagued by\") devil-occupied details and corner cases. The presentation below is over-simplified because (1) in this case, most of the details don't matter; and (2) I don't know all the details of the ELF loader, particularly on the ARM platform. But I think it more or less corresponds to reality.</p>\n<hr>\n<p><strong>Static initialization and the C++ standard</strong>:</p>\n<p>As I said above, this is not a language-lawyer answer so I'm not going to provide long quotes from the standard. You can read \u00a73.6.2 ([basic.start.init]) in the standard itself. In essence, if the initializers are well-behaved and free of side-effects, the compiler can arrange for a global variable to be initialized at any time it wants to but no later than is strictly necessary. To be clear about the latter, here is the only standard quote:</p>\n<blockquote>\n<p id=\"so_34357636_34386075_0\">If the initialization is deferred to some point in time after the first statement of main, it shall occur before the first odr-use of any function or variable defined in the same translation unit as the variable to be initialized. (\u00a73.6.2, para. 4).</p>\n</blockquote>\n<p>The main reason to allow deferral of initialization is to allow for dynamic loading. Dynamic (or on-demand) loading allows a program to start running before all modules are actually loaded and linked into the executable. That can speed start-up (so that the executable can immediately draw a splash-screen, for example) by overlapping it with the slow disk access needed to read in all the libraries needed by the program, some of which may not be needed at all, depending on the specific user request to the program.</p>\n<p>So the standard allows (but does not require) a form of \"on-demand\" initialization; to implement that, it might insert an initialization check prior to an \"odr-use of any function or variable\" which might be the first such use. And that's precisely the code you see prior to the (inlined) call of <code>cant_inline_static</code>.</p>\n<p><strong>Initialization and polymorphic objects</strong></p>\n<p>It's important that <code>derivedtype</code> is an instance of a polymorphic class. Every instance of a polymorphic class has an extra hidden data member which includes a pointer (the \"vptr\") to a vector of function pointers (and other information), commonly called the \"vtable\". This is how virtual function calls are implemented: at runtime, the virtual function call is indirected through the object's vtable. [Note 1] There's lots more which could be said about this, but the point here is that every instance of a polymorphic class has a vptr whose value needs to be initialized.</p>\n<p>So it is not the case that \"the object does not need to be initialized\". Every instance of a polymorphic class needs to be initialized. However, the (symbolic) address of the vtable is known at compile-time, so this <em>could be</em> performed as a constant initialization. Or not, as the compiler sees fit, because vtables and vptrs are implementation details, and not mandated by the C++ standard. (That's a polite fiction. I don't believe there exists an implementation which doesn't use vtables and vptrs. The precise layout and contents of the vtable do differ from implementation to implementation.)</p>\n<p><strong>Initialization and loaders</strong></p>\n<p>Between the compilation (\"translation\") of a program (collection of translation units) and the start of the execution of <code>main()</code>, the various translated translation units (object files) need to be read into memory and combined into a program image. In the course of doing so, names defined in one translation unit and used in another one need to be assigned addresses and the addresses need to be inserted where they are used. Even within a single translation unit, it is usually necessary to modify references to names to take into account the actual address assigned to the name.</p>\n<p>These various processes -- loading, linking, relocating -- are not defined in detail (or at all) by the C++ standard, which treats the <em>entire</em> execution of the program -- including the above steps -- as part of the program's execution.  So some of what is described as happening \"before the first statement of main\" actually happens during the linking and loading steps.</p>\n<p>On Intel/ARM platforms, gcc compiles translation units into <a href=\"https://en.wikipedia.org/wiki/Executable_and_Linkable_Format\" rel=\"nofollow\">ELF</a> object files. There is also a linker which combines ELF object files into a single ELF executable (possibly with references to external libraries). An ELF file consists of a number of \"sections\", each with different characteristics.</p>\n<p>ELF defines a huge number of section types and options, but there are really three main classes of sections, which are commonly and confusingly described as text, data and bss.</p>\n<ul>\n<li><p>text sections represent read-only memory. (The restriction might or might not be enforced by the OS). That includes the program itself, and also static constant objects initialized to compile-time constant values. The object file contains the actual bit representation of these sections, along with some indication of where to insert symbolic addresses at link time. [Note 2]</p></li>\n<li><p>data sections represent initialized read-write memory. That includes static objects whose values can be computed by the compiler, but which may be modified at run-time. Again, the object file contains the actual bit representation of the initial values.</p></li>\n<li><p>bss sections (the name is a historical curiosity, see <a href=\"https://en.wikipedia.org/wiki/.bss#Origin\" rel=\"nofollow\">Wikipedia</a> for details) represent zero-initialized read-write memory. This is used for static objects whose initial values will be computed at run-time when (and if) necessary. The object file contains only the sizes of these objects; no bit representation is provided. The loader arranges for the initial value of these sections to be zero, either by explicitly clearing the memory allocated or by using the virtual memory system to map the memory to a page which will be zeroed on first reference.</p></li>\n</ul>\n<p>ELF also allows the compiler to provide initialization sections, which is executable code to be executed at the end of the load process, that is, before the actual main executable starts. [Note 3]</p>\n<p>A read-write object whose initial value is intended to be mostly zeros could be placed in either a data section, with explicit zeros, or a bss section along with code to run-time initialize the non-zero elements. If it is in a bss section, the initialization code could be in an initialization section, or it could be in a lazily-executed constructor. Gcc will choose one of the above strategies, based on its own heuristics and optimization flags.</p>\n<p>I don't know all the heuristics that gcc uses, but I believe that it will normally prefer a bss section, which is logical because it is usually faster to zero-initialize memory in a loop than to copy a bunch of zeros from a disk file, as well as saving the bytes in the disk file itself. However, if you explicitly zero-initialize data, gcc will use a data section unless the entire object is zero-initialized (and even then, if you specified <code>-fno-zero-initialized-in-bss</code>). So you can observe the difference between:</p>\n<pre><code>struct S {\n  int one = 1;\n  int zeros[1000000] = {0};\n};\nS s;\n</code></pre>\n<p>and </p>\n<pre><code>struct S {\n  int one = 1;\n  int zeros[1000000];\n};\nS s;\n</code></pre>\n<p>On my system, the sizes of the object files produced is 4,000,962 vs. 2,184 bytes.</p>\n<p><strong>Returning to the OP</strong></p>\n<p>So, in the code in the question we have a static object, <code>derivedtype</code>, with an (inherited) default-initialized data member. Since it is an instance of a polymorphic object, it also has an internal vptr data member, which needs to be initialized. So it looks like a mixed data object, and gcc therefore puts it in a bss section and inserts code to (lazily) initialize it when needed.</p>\n<p>Explicitly initializing the data member (even to 0) causes gcc to put the object in a data section, making it statically initialized; this avoids the lazy initialization code.</p>\n<p><strong>But the object actually doesn't <em>need</em> to be initialized</strong></p>\n<p>As it happens, in this particular case, it is impossible for a virtual member function to be called through a pointer to <code>derivedtype</code>. So in some sense, it really wouldn't matter if the vptr member were never initialized. But it is completely unreasonable to expect the compiler to even think about checking for that scenario. If you create a polymorphic class, it can only be because you <em>intend</em> to call member functions polymorphically. Doing full escape analysis on an instance of that class in order to determine whether or not a polymorphic call could happen would almost always be a total waste of time, so there is no reason why anyone should bother to include that check in a compiler. (That's a personal opinion. You're free to disagree. :-) )</p>\n<p>If you really truly want to tell the compiler that a particular member function call is not polymorphic, you are free to do so using an explicit call:</p>\n<pre><code>derivedtype.DerivedType::VirtualMethod(p);\n</code></pre>\n<p>Going even further out on a limb, you might be able to get away with calling a polymorphic method which does not use <code>this</code> (i.e., which could have been <code>static</code> had it not been polymorphic) using something like:</p>\n<pre><code>((DerivedType)nullptr)-&gt;DerivedType::VirtualMethod(p);\n</code></pre>\n<p>Or even:</p>\n<pre><code>((decltype(derivedtype)*)(nullptr)-&gt;decltype(derivedtype)::VirtualMethod(p);\n</code></pre>\n<p>But in your code, that won't work because you actually call <code>VirtualCaller</code>, which explicitly uses <code>this</code>. (To be honest, I don't really understand the logic there). However, the hack above -- which I would <em>never</em> accept in a code review -- does avoid odr-using <code>derivedtype</code>, thereby avoiding the need to initialize it. <a href=\"http://goo.gl/i6kOFZ\" rel=\"nofollow\">See it here</a> on the <a href=\"http://gcc.godbolt.org/\" rel=\"nofollow\">Godbolt Interactive GCC compiler</a></p>\n<hr>\n<h3>Notes</h3>\n<ol>\n<li><p>This is an oversimplification (see disclaimer). The vtable is really a kind of object descriptor, not just a vector of function pointers, and there might be more than one vptr in an object in the case of virtual inheritance. For the purpose of this answer, none of that is relevant.</p></li>\n<li><p>Read-only data sections are usually called <code>.rodata</code> but they are still generically described as \"text\" sections. That's one of the oversimplifications I warned about.</p></li>\n<li><p>In the case of dynamically-loaded libraries, initialization code will be executed by the dynamic loader after it has loaded the module into memory, before returning to execution of the program. That will typically be long after <code>main()</code> was started. But again, that's not relevant here.</p></li>\n</ol>\n</hr></hr></hr>", "OwnerUserId": "1566221", "PostTypeId": "2", "Id": "34386075", "Score": "3", "CreationDate": "2015-12-20T21:31:09.757", "LastActivityDate": "2015-12-20T21:31:09.757"}, "34358283": {"ParentId": "34357636", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I know almost nothing about ARM assembly programming, so I am at risk of embarassing myself thoroughly :) but it looks like it is indeed inlined. In both functions you can find:</p>\n<pre><code>e3a02001    mov r2, #1         ; put 1 to register r2\ne59f3014    ldr r3, [pc, #20]  ; put address 0x40002000 to r3\ne5832000    str r2, [r3]       ; store value of r1 to adress in r3\n</code></pre>\n<p>In both cases there is no call to method (I would expect <code>bl</code> instruction).\nIn case of static variable there is obviously some bookkeeping code which I don't understand, but it doesn't seem related to inlining. If I have to guess, I would say that it is loading the address of the static object from some table to check whether it is instantiated, while in another case local object seems to be completely optimized away, thus resulting in shorter code.</p>\n", "OwnerUserId": "1663919", "LastEditorUserId": "1663919", "LastEditDate": "2015-12-18T15:56:15.137", "Id": "34358283", "Score": "3", "CreationDate": "2015-12-18T14:52:42.630", "LastActivityDate": "2015-12-18T15:56:15.137"}, "bq_ids": {"n4140": {"so_34357636_34386075_0": {"section_id": 7153, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_34357636_34386075_0": {"section_id": 6897, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_34357636_34386075_0": {"section_id": 8657, "quality": 0.6086956521739131, "length": 14}}}});