post_cb({"16922652": {"ParentId": "16922121", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>If you're really curious, check out section 13.3.3 of the C++03 standard, which describes how the \"best viable function\" is determined. Here are some important points:</p>\n<blockquote>\n<p id=\"so_16922121_16922652_0\">The selection criteria for the best function are the number of arguments, how well the arguments\n  match the types of the parameters of the candidate function, how well (for nonstatic member functions) the\n  object matches the implied object parameter, and certain other properties of the candidate function. [Note:\n  the function selected by overload resolution is not guaranteed to be appropriate for the context. Other\n  restrictions, such as the accessibility of the function, can make its use in the calling context ill-formed. ]</p>\n</blockquote>\n<p>And later:</p>\n<blockquote>\n<p id=\"so_16922121_16922652_1\">If there is exactly one viable function that is a better function than all other viable functions, then it is the\n  one selected by overload resolution</p>\n</blockquote>\n<p>Note that the return type of the function is not mentioned in this criteria. So the non-const method is selected as most valid, because its \"implied object parameter\" (essentially the \"this\" pointer) is non-const. This all happens before the conflict with the return type is detected.</p>\n<p>To solve this problem, I would either:</p>\n<ul>\n<li>Change your design so that <code>ConstTestObjectPair</code> isn't needed, and you can just use <code>const TestObjectPair</code> (preferred solution)</li>\n<li>Cast your non-const objects to const ones when needed</li>\n</ul>\n", "OwnerUserId": "2387403", "LastEditorUserId": "2387403", "LastEditDate": "2013-06-05T13:44:40.347", "Id": "16922652", "Score": "5", "CreationDate": "2013-06-04T16:12:04.020", "LastActivityDate": "2013-06-05T13:44:40.347"}, "16922121": {"CommentCount": "1", "ViewCount": "690", "CreationDate": "2013-06-04T15:45:38.897", "LastActivityDate": "2013-06-05T13:44:40.347", "Title": "Wrong function prototype used by compiler?", "AcceptedAnswerId": "16922652", "PostTypeId": "1", "Id": "16922121", "Score": "6", "Body": "<p>I faced a compilation problem that I do not understand, I have simplified it a bit for explanation below.</p>\n<p>Basically, it involves having 2 different getters (a const and non-const one) that return a container (a map in this example) with const, respectively non-const value_type.</p>\n<p>What puzzles me is that in the example below, the compiler seems unable to use the const getter on a non-const object:</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;utility&gt;\n#include &lt;map&gt;\n\nclass TestObject\n{\npublic:\n\n    TestObject() {}\n    virtual ~TestObject() {}\n};\n\ntypedef std::pair&lt;const TestObject*, const TestObject*&gt; ConstTestObjectPair;\ntypedef std::pair&lt;TestObject*, TestObject*&gt; TestObjectPair;\n\nclass Test\n{\n    TestObject* m_pObject;\n\npublic:\n\n    Test() {m_pObject = new TestObject();}\n    virtual ~Test() {delete m_pObject;}\n\n    std::map&lt;unsigned, ConstTestObjectPair&gt; GetObject() const\n    {\n        std::map&lt;unsigned, ConstTestObjectPair&gt; map;\n        map.insert(std::make_pair(0, std::make_pair(m_pObject, m_pObject)));\n        return map;\n    }\n\n    std::map&lt;unsigned, TestObjectPair&gt; GetObject()\n    {\n        std::map&lt;unsigned, TestObjectPair&gt; map;\n        map.insert(std::make_pair(0, std::make_pair(m_pObject, m_pObject)));\n        return map;\n    }\n};\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    Test* pTest = new Test();\n    const Test* pConstTest = pTest;\n\n    std::map&lt;unsigned, ConstTestObjectPair&gt; CTO = pTest-&gt;GetObject(); // Not compiling, I don't get why!!!\n    CTO = pConstTest-&gt;GetObject();\n\n    std::map&lt;unsigned, TestObjectPair&gt; TO = pTest-&gt;GetObject();\n    //TO = pConstTest-&gt;GetObject(); // Not working, this is expected\n\n    return 0;\n}\n</code></pre>\n<p>I tried with both VS2010 and gcc and neither accepts to compile this code. Here is the compilation error returned by VS2010:</p>\n<pre><code>1&gt;c:\\test.cpp(48): error C2440: 'initializing' : cannot convert from 'std::map&lt;_Kty,_Ty&gt;' to 'std::map&lt;_Kty,_Ty&gt;'\n1&gt;          with\n1&gt;          [\n1&gt;              _Kty=unsigned int,\n1&gt;              _Ty=TestObjectPair\n1&gt;          ]\n1&gt;          and\n1&gt;          [\n1&gt;              _Kty=unsigned int,\n1&gt;              _Ty=ConstTestObjectPair\n1&gt;          ]\n1&gt;          No constructor could take the source type, or constructor overload resolution was ambiguous\n</code></pre>\n<p>Could someone explain me why the compiler cannot find/use the correct prototype on the non-const object?</p>\n<p>Thanks a lot!</p>\n", "Tags": "<c++><map><stl><const>", "OwnerUserId": "1996364", "AnswerCount": "4"}, "16922935": {"ParentId": "16922121", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>C++ compiler will choose the explicit overrided method, so here pTest is a non-const viable and pConstTest is const one.</p>\n<pre><code>Test* pTest = new Test();\nconst Test* pConstTest = pTest;\n</code></pre>\n<p>pTest-&gt;GetObject will choose the non-const GetObject:</p>\n<pre><code>std::map&lt;unsigned, TestObjectPair&gt; GetObject()\n{\n    std::map&lt;unsigned, TestObjectPair&gt; map;\n    map.insert(std::make_pair(0, std::make_pair(m_pObject, m_pObject)));\n    return map;\n}\n</code></pre>\n<p>pConstTest-&gt;GetObject() will choose the const GetObject:</p>\n<pre><code>std::map&lt;unsigned, ConstTestObjectPair&gt; GetObject() const\n{\n    std::map&lt;unsigned, ConstTestObjectPair&gt; map;\n    map.insert(std::make_pair(0, std::make_pair(m_pObject, m_pObject)));\n    return map;\n}\n</code></pre>\n<p>the first error happened when you assign a returned </p>\n<pre><code>std::map&lt;unsigned, TestObjectPair&gt; value \n</code></pre>\n<p>to a </p>\n<pre><code>std::map&lt;unsigned, ConstTestObjectPair&gt; viable\n</code></pre>\n", "OwnerUserId": "1394117", "LastEditorUserId": "1394117", "LastEditDate": "2013-06-04T16:31:50.650", "Id": "16922935", "Score": "0", "CreationDate": "2013-06-04T16:26:13.183", "LastActivityDate": "2013-06-04T16:31:50.650"}, "16922989": {"ParentId": "16922121", "CommentCount": "0", "Body": "<p>The problem is quite simple. <code>pTest</code> is a pointer to an object of type <code>Test</code>, which is <strong>not const</strong>. Hence in the call <code>pTest-&gt;GetObject()</code> the non-const member function is selected, that is</p>\n<pre><code>std::map&lt;unsigned, TestObjectPair&gt; GetObject()\n</code></pre>\n<p>As you see, this function returns a value of type <code>std::map&lt;unsigned, TestObjectPair&gt;</code>. But then you try to initialize the variable <code>CTO</code> of type</p>\n<pre><code>std::map&lt;unsigned, ConstTestObjectPair&gt;\n</code></pre>\n<p>with this value. To do that, the compiler needs to convert the returned value to this type. But there is no conversion constructor to do that. And that is what the compiler error tells you.</p>\n", "OwnerUserId": "1770418", "PostTypeId": "2", "Id": "16922989", "Score": "1", "CreationDate": "2013-06-04T16:29:00.533", "LastActivityDate": "2013-06-04T16:29:00.533"}, "16922479": {"ParentId": "16922121", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_16922121_16922479_0\">What puzzles me is that in the example below, the compiler seems unable to use the const getter on a non-const object</p>\n</blockquote>\n<p>It is not \"unable\" but <em>required</em> to chose the other one. </p>\n<p>Overloading is selected using the passed actual parameters. For member function including the hidden param used for <code>this</code>.  For T* the non-const overload is selected, if you want the other you must use a const T* by cast or other means.</p>\n<p>Actually it is a common mistake to think the return type will be used some way and the function that returns what you want to use in the expression gets selected. It is just not so. </p>\n", "OwnerUserId": "2422194", "PostTypeId": "2", "Id": "16922479", "Score": "4", "CreationDate": "2013-06-04T16:03:31.757", "LastActivityDate": "2013-06-04T16:03:31.757"}, "bq_ids": {"n4140": {"so_16922121_16922652_0": {"section_id": 562, "quality": 0.9, "length": 45}, "so_16922121_16922652_1": {"section_id": 604, "quality": 1.0, "length": 17}}, "n3337": {"so_16922121_16922652_0": {"section_id": 553, "quality": 0.9, "length": 45}, "so_16922121_16922652_1": {"section_id": 594, "quality": 1.0, "length": 17}}, "n4659": {"so_16922121_16922652_0": {"section_id": 585, "quality": 0.9, "length": 45}, "so_16922121_16922652_1": {"section_id": 630, "quality": 1.0, "length": 17}}}});