post_cb({"bq_ids": {"n4140": {"so_44232434_44232513_2": {"length": 27, "quality": 0.8709677419354839, "section_id": 7151}, "so_44232434_44232513_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 7151}}, "n3337": {"so_44232434_44232513_2": {"length": 26, "quality": 0.8387096774193549, "section_id": 6895}}, "n4659": {"so_44232434_44232513_2": {"length": 25, "quality": 0.8064516129032258, "section_id": 8652}, "so_44232434_44232513_0": {"length": 24, "quality": 0.8275862068965517, "section_id": 8652}}}, "44232513": {"Id": "44232513", "PostTypeId": "2", "Body": "<p>The key here is the difference between \"<code>static</code> initialization\" (formally known using the language of the Standard as <em>dynamic initialization of objects with static storage duration</em> which has the ordering fiasco) and <em>static initialization</em>.</p>\n<p>The Standard says (section <code>[basic.start.static]</code>) that</p>\n<blockquote>\n<p id=\"so_44232434_44232513_0\">A constant initializer for an object <code>o</code> is an expression that is a constant expression, except that it may also invoke <code>constexpr</code> constructors for <code>o</code> and its subobjects even if those objects are of non-literal class types.  [ Note: Such a class may have a non-trivial destructor \u2014 end note ] </p>\n<p id=\"so_44232434_44232513_1\">Constant initialization is performed:</p>\n<ul>\n<li>if each full-expression (including implicit conversions) that appears in the initializer of a reference with static or thread storage duration is a constant expression and the reference is bound to a glvalue designating an object with static storage duration, to a temporary object or subobject thereof, or to a function;</li>\n<li>if an object with static or thread storage duration is initialized by a constructor call, and if the initialization full-expression is a constant initializer for the object;</li>\n<li>if an object with static or thread storage duration is not initialized by a constructor call and if either the object is value-initialized or every full-expression that appears in its initializer is a constant expression.</li>\n</ul>\n<p id=\"so_44232434_44232513_2\">If constant initialization is not performed, a variable with static storage duration or thread storage duration is zero-initialized. <strong>Together, zero-initialization and constant initialization are called static initialization; all other initialization is dynamic initialization. Static initialization shall be performed before any dynamic initialization takes place.</strong></p>\n</blockquote>\n<p>Your <code>c</code>, <code>d</code>, <code>e</code>, and <code>f</code> objects have constant initializers, so their initialization is completed during the static initialization phase (even though <code>c</code> and <code>d</code> are NOT themselves constant), and their values are available during all dynamic initialization, even those that came lexically before.</p>\n", "LastActivityDate": "2017-05-28T22:12:29.493", "CommentCount": "3", "CreationDate": "2017-05-28T22:12:29.493", "ParentId": "44232434", "Score": "2", "OwnerUserId": "103167"}, "44232434": {"ViewCount": "102", "Body": "<p>I know about the <a href=\"https://isocpp.org/wiki/faq/ctors#static-init-order\" rel=\"nofollow noreferrer\">static initialization order fiasco</a> in C++ and the\n<a href=\"https://isocpp.org/wiki/faq/ctors#static-init-order-on-first-use\" rel=\"nofollow noreferrer\">construct on first use idiom</a> to avoid it.  Thus in the code below\nthe global assignment of <code>a</code> may happen before that of <code>foo::a</code> and so\nthe value of <code>a</code> is undefined.  One the other hand, the global\nassignment of <code>b</code> is OK, since it invoked the function <code>foo::b()</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n// foo.hpp\n\nclass foo {\npublic:\n  static const string a;\n  static const string&amp; b();\n  static const char* const c;\n  static const char* const d[2];\n  static const int e;\n  static const int f[2];\n};\n\n// foo.cpp\n\nconst string foo::a(\"astr\");\nconst string&amp; foo::b() {\n  static const string t(\"bstr\");\n  return t;\n}\nconst char* const foo::c = \"cstr\";\nconst char* const foo::d[2] = {\"dstr1\", \"dstr2\"};\nconst int foo::e = 5;\nconst int foo::f[2] = {6, 7};\n\n// main.cpp\n\n// global initializations\nstring a = foo::a;              // dangerous, might be \"\" or \"astr\"\nstring b = foo::b();            // safe, guaranteed to be \"bstr\"\nconst char* c = foo::c;         // what about these...?\nconst char* d = foo::d[0];\nint e = foo::e;\nint f = foo::f[0];\n\nint main() {\n  cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; \"\\n\"\n       &lt;&lt; c &lt;&lt; \" \" &lt;&lt; d &lt;&lt; \"\\n\"\n       &lt;&lt; e &lt;&lt; \" \" &lt;&lt; f &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>(Imagine I've combined <code>foo.hpp</code>, <code>foo.cpp</code>, and <code>main.cpp</code> here.)\nHowever what about variables which are built-in types or arrays of them?\nThus are global assignments of <code>c</code>, <code>d</code>, <code>e</code>, and <code>f</code> safe in this code?\nIt seems possible that the linker can set the memory for these variables\nso no initialization needs to take place at run time.  But can I rely on\nthis?</p>\n<p>I know I shouldn't be using global variables.  However, I'm the author\nof a library (foo.cpp and foo.hpp) and I have no control over what a\nuser of my library (the author of main.cpp) does.</p>\n", "AcceptedAnswerId": "44232513", "Title": "In C++ are simple initializations of built-in type immune to the static initialization order fiasco?", "CreationDate": "2017-05-28T22:00:41.413", "Id": "44232434", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-29T13:40:35.580", "LastEditorUserId": "837055", "LastActivityDate": "2017-05-30T00:05:39.650", "Score": "0", "OwnerUserId": "837055", "Tags": "<c++><static-initialization><static-order-fiasco>", "AnswerCount": "1"}});