post_cb({"1767822": {"ParentId": "1767679", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2009-11-20T01:46:39.997", "Score": "1", "LastEditorUserId": "187646", "LastEditDate": "2009-11-20T01:54:00.450", "Id": "1767822", "OwnerUserId": "187646", "Body": "<p>In g++, the warning could be reproduced too using following code:</p>\n<pre><code>class A;\n\nvoid func(A *p)\n{\n        delete p;\n}\n\nint main(int argc, char **argv)\n{\n        return 0;\n}\n</code></pre>\n<p>Warnings but no any errors:</p>\n<pre><code>test.cpp: In function void func(A*):\ntest.cpp:6: warning: possible problem detected in invocation \n  of delete operator:\ntest.cpp:4: warning: A has incomplete type\ntest.cpp:2: warning: forward declaration of struct A\ntest.cpp:6: note: neither the destructor nor the class-specific\n  operator delete will be called, even if they are declared\n  when the class is defined.\n</code></pre>\n<p>While g++ states very clear here that destructor will not be called because it doesn't know whether needs a destructor or not, or where is the destructor.</p>\n<p>In this case delete() downgrates to the C call free(), that is, it just free the object memory itself, but any heap data allocated by the object itself internally (e.g., in constructor) will be keeped, the same behavior as free(p).</p>\n<p>I think it would be a similar way if in MS VC/++; and a correct way is you to include the interface headers of A.</p>\n", "LastActivityDate": "2009-11-20T01:54:00.450"}, "1767770": {"ParentId": "1767679", "CommentCount": "0", "CreationDate": "2009-11-20T01:27:43.420", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "1767770", "Score": "6", "Body": "<p>Per the C++ Standard (ISO/IEC 14882:2003 5.3.5/5):</p>\n<blockquote>\n<p id=\"so_1767679_1767770_0\">If the object being deleted has incomplete class type at the point of deletion and the complete class has a non-trivial destructor or a deallocation function, the behavior is undefined.</p>\n</blockquote>\n<p>So, if your class has a non-trivial destructor, don't do this, regardless of how Visual C++ handles this situation.</p>\n", "LastActivityDate": "2009-11-20T01:27:43.420"}, "1767679": {"CommentCount": "3", "AcceptedAnswerId": "1769296", "PostTypeId": "1", "LastEditorUserId": "151292", "CreationDate": "2009-11-20T00:59:41.977", "LastActivityDate": "2009-11-20T09:22:44.647", "LastEditDate": "2009-11-20T01:32:40.493", "ViewCount": "3948", "FavoriteCount": "3", "Title": "Incomplete Type memory leaks?", "Id": "1767679", "Score": "5", "Body": "<p>Microsoft Visual Studio 2008 is giving me the following warning:</p>\n<p>warning C4150: deletion of pointer to incomplete type 'GLCM::Component'; no destructor called</p>\n<p>This is probably because I have defined Handles to forward declared types in several places, so now the Handle class is claiming it won't call the destructor on the given object.</p>\n<p>I have VLD running and I'm not seeing any leaks. Is this literally not calling the destructor for this object or is this a \"may not call destructor for object\" warning?</p>\n<p>Yet another memory leak question from me, haha.</p>\n", "Tags": "<c++><visual-c++><memory-leaks>", "OwnerUserId": "208358", "AnswerCount": "5"}, "1767763": {"ParentId": "1767679", "CommentCount": "5", "Body": "<p>It sounds like you're not following the <a href=\"http://www.gotw.ca/gotw/024.htm\" rel=\"nofollow noreferrer\">p-impl</a> <a href=\"http://en.wikipedia.org/wiki/Opaque_pointer\" rel=\"nofollow noreferrer\">idiom</a> correctly.</p>\n<p>Brief example:</p>\n<pre><code>// header\nstruct Other; // declare to use a pointer to it\n\nstruct Handle {\n  Handle();\n  ~Handle();\n\n  void f();\n\nprivate:\n  Other* _obj;\n};\n\n// implementation (.cpp)\n#include \"header\"\n\nstruct Other {\n  void f();\n};\n\nHandle() : _obj(new Other()) {}\n~Handle() { delete _obj; }\n\nvoid Handle::f() { _obj-&gt;f(); }\n</code></pre>\n<p>Since using delete is now after the definition of class Other, the type will be complete.  Without a complete type, the compiler can't know how to properly destroy it.  (E.g. the dtor could be virtual or non-virtual, or even might be non-public.)</p>\n", "Id": "1767763", "PostTypeId": "2", "OwnerDisplayName": "Roger Pate", "Score": "0", "CreationDate": "2009-11-20T01:27:11.030", "LastActivityDate": "2009-11-20T01:27:11.030"}, "1768956": {"ParentId": "1767679", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2009-11-20T07:52:33.763", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:26:44.200", "Id": "1768956", "OwnerUserId": "57428", "Body": "<p>You may have no leaks even with the destructor not called if the object being deleted doesn't contain pointers to heap-allocated objects. However don't try this - as James McNellis  mentions in <a href=\"https://stackoverflow.com/questions/1767679/incomplete-type-memory-leaks/1767770#1767770\">his answer</a> it's undefined behaviour according to the C++ standard.</p>\n<p>When <em>delete</em> is called (explicitly or from a smart pointer) first the object destructor is run and then memory is deallocated. VC++ basically tells you that it has no idea of what destructor to run and so will not run any but instead will just deallocate memory. If the object is a POD type or it has no pointers set to heap-allocated objects (either contains no pointers or contains pointers set to null or to objects owned by someone else and therefore not needed to deallocate) there's no reason for a leak.</p>\n<p>So perhaps VC++ will produce the same behaviour as it would with first casting the object to <code>void*</code>. But again don't rely on this - at best you will have unportable code, at worst your code will break apart as soon as you change version of or patch your VC++ compiler.</p>\n", "LastActivityDate": "2009-11-20T07:52:33.763"}, "bq_ids": {"n4140": {"so_1767679_1767770_0": {"section_id": 6109, "quality": 1.0, "length": 16}}, "n3337": {"so_1767679_1767770_0": {"section_id": 5875, "quality": 1.0, "length": 16}}, "n4659": {"so_1767679_1767770_0": {"section_id": 7606, "quality": 1.0, "length": 16}}}, "1769296": {"ParentId": "1767679", "CommentCount": "0", "CreationDate": "2009-11-20T09:22:44.647", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "1769296", "Score": "6", "Body": "<p>It often happen when using Pimpl, so I'll focus on the solution there:</p>\n<pre><code>class FooImpl;\n\nclass Foo\n{\npublic:\n  // stuff\nprivate:\n  Pimpl&lt;FooImpl&gt; m_impl;\n};\n</code></pre>\n<p>The problem here is that unless you declare a destructor, it will be automatically generated, inline, by the compiler. But of course, the compiler will have no idea of the complete type of <code>FooImpl</code> there.</p>\n<p>You thus have to explicitly define the destructor, even if empty, and put the definition somewhere where the complete type of <code>FooImpl</code> is visible.</p>\n<pre><code>// cpp file\nclass FooImpl\n{\n};\n\nFoo::~Foo() {} // Empty, but now correctly generated\n               // because FooImpl complete at this point.\n</code></pre>\n<p>Also, if like me you defined your <code>Pimpl</code> class to be pretty smart (regarding construction, copy and assignment), then those will also need to be defined in the .cpp file.</p>\n<p>It's really a hassle, but then you have nicely encapsulated your implementation details, so I suppose it's worth it.</p>\n", "LastActivityDate": "2009-11-20T09:22:44.647"}});