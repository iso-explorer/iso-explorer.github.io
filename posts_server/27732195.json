post_cb({"bq_ids": {"n4140": {"so_27732195_27734079_0": {"section_id": 5455, "quality": 0.9655172413793104, "length": 28}}, "n4659": {"so_27732195_27734079_0": {"section_id": 6881, "quality": 0.9655172413793104, "length": 28}}}, "27732195": {"CommentCount": "6", "ViewCount": "302", "PostTypeId": "1", "LastEditorUserId": "1934349", "CreationDate": "2015-01-01T15:46:10.770", "LastActivityDate": "2015-06-29T15:11:23.367", "LastEditDate": "2015-01-01T17:13:42.610", "AcceptedAnswerId": "27734079", "FavoriteCount": "1", "Title": "How to make a SFINAE-based Y combinator in C++?", "Id": "27732195", "Score": "3", "Body": "<p>I was thinking about the implicit templates of C++14, and I'm trying to declare a function to match an specific argument type (SFINAE and traits <strong>still</strong> give me headaches). I'm not sure how to explain what I want, but I'm trying to make a <a href=\"http://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator\" rel=\"nofollow\">Y combinator</a> (just to see if it's possible, not intended for production).</p>\n<p>I'm trying to declare a function:</p>\n<pre><code>template&lt;typename T&gt;\nmy_traits&lt;T&gt;::return_type Y(T t) {\n  // ...\n};\n</code></pre>\n<p>Such that <code>T</code> is a function (or a functor) that matches</p>\n<pre><code>std::function&lt;R(F, Args...)&gt;\n\n// where F (and above return_type) will be\nstd::function&lt;R(Args...)&gt;\n</code></pre>\n<p>Which would take any number of arguments, but the first should be a function with the same return type and the same arguments (except this function itself). The first parameter to the <code>operator ()</code> of the functor is a template.</p>\n<p>The usage I want to achieve:</p>\n<pre><code>auto fib = [](auto myself, int x) {\n  if(x &lt; 2)\n    return 1;\n  return myself(x - 1) + myself(x - 2);\n};\n\n// The returned type of fib should be assignable to std::function&lt;int(int)&gt;\n</code></pre>\n<p>I wasn't able to take the return type of the <code>T</code> type (because of the overloaded <code>operator ()</code>). What I'm trying to make is possible? How could I make it?</p>\n<hr>\n<p><strong>Edit:</strong></p>\n<p>Seeing it from a different angle, I'm trying to make this work:</p>\n<pre><code>struct my_functor {\n  template&lt;typename T&gt;\n  char operator () (T t, int x, float y) { /* ... */ };\n};\n\ntemplate&lt;typename T&gt;\nstruct my_traits {\n  typedef /* ... */ result_type;\n\n  /* ... */\n};\n\n// I want this to be std::function&lt;char(int, float)&gt;, based on my_functor\nusing my_result =\nmy_traits&lt;my_functor&gt;::result_type;\n</code></pre>\n</hr>", "Tags": "<c++><templates><c++14><sfinae><typetraits>", "OwnerUserId": "1934349", "AnswerCount": "2"}, "27733247": {"ParentId": "27732195", "LastEditDate": "2017-05-23T10:26:42.363", "CommentCount": "3", "CreationDate": "2015-01-01T18:05:21.207", "Score": "3", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "27733247", "OwnerUserId": "2756719", "Body": "<p>It's a really hacky approach, and has severe limitations, but here it goes:</p>\n<p>First, we need a class that pretends to support every possible operation (as far as possible), such as the <a href=\"https://stackoverflow.com/a/25704767/2756719\"><code>fake_anything</code></a> class. Note that this isn't perfect since at a minimum <code>.</code> and <code>::</code> won't work. To fake a functor, we give it a function call operator:</p>\n<pre><code>template&lt;class... Ts&gt; fake_anything operator()(Ts&amp;&amp;...) const;\n</code></pre>\n<p>Knowing that the lambda has only one <code>operator()</code>, and that <code>operator()</code> has only one template parameter allows us to extract its signature with <code>decltype(&amp;T::operator()&lt;fake_anything&gt;)</code>. \nFor this to work, the lambda's return type must be explicitly specified; it can't use deduction, since otherwise the deduced return types will probably conflict.</p>\n<p>Finally we can obtain the other arguments to the lambda and the return type using the standard partial specialization approach:</p>\n<pre><code>template&lt;class T&gt;\nstruct extract_signature;\n\ntemplate&lt;class T, class R, class FA, class...Args&gt;\nstruct extract_signature&lt;R (T::*)(FA, Args...)&gt; {\n    static_assert(std::is_same&lt;fake_anything, std::decay_t&lt;FA&gt;&gt;::value, \"Unexpected signature\");\n    using type = std::function&lt;R(Args...)&gt;;\n};\n\ntemplate&lt;class T, class R, class FA, class...Args&gt;\nstruct extract_signature&lt;R (T::*)(FA, Args...) const&gt; {\n    static_assert(std::is_same&lt;fake_anything, std::decay_t&lt;FA&gt;&gt;::value, \"Unexpected signature\");\n    using type = std::function&lt;R(Args...)&gt;;\n};\n// other cv- and ref-qualifier versions omitted - not relevant to lambdas\n// we can also static_assert that none of Args is fake_anything, or reference to it, etc.\n</code></pre>\n<p>And add an alias template to hide all the ugliness of the hack:</p>\n<pre><code>template&lt;class T&gt;\nusing signature_t = typename extract_signature&lt;decltype(&amp;T::template operator()&lt;fake_anything&gt;)&gt;::type;\n</code></pre>\n<p>And finally we can check that</p>\n<pre><code>static_assert(std::is_same&lt;signature_t&lt;decltype(fib)&gt;,\n                           std::function&lt;int(int)&gt;&gt;::value, \"Oops\");\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/9d88358b901a5dc7\" rel=\"nofollow noreferrer\">Demo</a>.</p>\n<p>The limitations:</p>\n<ul>\n<li>The return type of <code>operator()</code> must be explicitly specified. You cannot use automatic return type deduction, unless all of the <code>return</code> statements return the same type regardless of the return type of the functor.</li>\n<li>The faking is very imperfect.</li>\n<li>This works for <code>operator()</code> of a particular form only: <code>template&lt;class T&gt; R operator()(T, argument-types...)</code> with or without <code>const</code>, where the first parameter is <code>T</code> or a reference to possibly cv-qualified <code>T</code>.</li>\n</ul>\n", "LastActivityDate": "2015-01-01T18:05:21.207"}, "27734079": {"ParentId": "27732195", "LastEditDate": "2015-06-29T15:11:23.367", "CommentCount": "1", "CreationDate": "2015-01-01T19:48:46.690", "Score": "2", "LastEditorUserId": "540815", "PostTypeId": "2", "Id": "27734079", "OwnerUserId": "540815", "Body": "<p>It is not possible in C++14 return type deduction to deduce <code>int(int)</code> out of <code>int(T, int)</code> as OP desires.</p>\n<p>However, we can mask the first parameter of the result using the following approach. The <code>struct YCombinator</code> is instantiated with a non-recursive function object member, whose first argument is a version of itself without the first argument. <code>YCombinator</code> provides a call operator that receives the arguments of the non-recursive function and then returns its function object member after substituting itself for the first argument. This technique allows the programmer to avoid the messiness of <code>myself(myself, ...)</code> calls within the definition of the recursive function.</p>\n<pre><code>template&lt;typename Functor&gt;\nstruct YCombinator\n{\n    Functor functor;\n\n    template&lt;typename... Args&gt;\n    decltype(auto) operator()(Args&amp;&amp;... args)\n    {\n        return functor(*this, std::forward&lt;Args&gt;(args)...);\n    }\n};\n</code></pre>\n<p>A <code>make_YCombinator</code> utility template allows for a streamlined usage pattern. This compiles run runs in GCC 4.9.0.</p>\n<pre><code>template&lt;typename Functor&gt;\ndecltype(auto) make_YCombinator(Functor f) { return YCombinator&lt;Functor&gt; { f }; }\n\nint main()\n{\n    auto fib = make_YCombinator([](auto self, int n) -&gt; int { return n &lt; 2 ? 1 : self(n - 1) + self(n - 2); });\n\n    for (int i = 0; i &lt; 10 ; ++i)\n        cout &lt;&lt; \"fib(\" &lt;&lt; i &lt;&lt; \") = \" &lt;&lt; fib(i) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Since the non-recursive function is not defined at time that the recursive function is defined, in general the recursive function must have an explicit return type.</p>\n<p><strong>Edit:</strong></p>\n<p>However, it may be possible for the compiler to deduce the return type in certain cases if the programmer takes care to indicate the return type of the recursive function before use of the non-recursive function. While the above construction requires an explicit return type, in the following GCC 4.9.0 has no problem deducing the return type:</p>\n<pre><code>    auto fib = make_YCombinator([](auto self, int n) { if (n &lt; 2) return 1; return self(n - 1) + self(n - 2); });\n</code></pre>\n<p>To pin this down just a bit further, here is a quote from the draft C++14 standard on return type deduction [7.1.6.4.11]:</p>\n<blockquote>\n<p id=\"so_27732195_27734079_0\">If the type of an entity with an undeduced placeholder type is needed\n  to determine the type of an expression, the program is ill-formed.\n  Once a return statement has been seen in a function, however, the\n  return type deduced from that statement can be used in the rest of the\n  function, including in other return statements. [ Example:</p>\n<pre><code>auto n = n; // error, n\u2019s type is unknown\nauto f();\nvoid g() { &amp;f; } // error, f\u2019s return type is unknown\nauto sum(int i) {\nif (i == 1)\n    return i; // sum\u2019s return type is int\nelse\n    return sum(i-1)+i; // OK, sum\u2019s return type has been deduced\n}\n</code></pre>\n<p id=\"so_27732195_27734079_1\">\u2014end example ]</p>\n</blockquote>\n", "LastActivityDate": "2015-06-29T15:11:23.367"}});