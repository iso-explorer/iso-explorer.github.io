post_cb({"bq_ids": {"n4140": {"so_47964986_47965042_1": {"length": 13, "quality": 0.8125, "section_id": 7213}, "so_47964986_47965037_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 5943}, "so_47964986_47965042_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 7213}}, "n3337": {"so_47964986_47965042_1": {"length": 15, "quality": 0.9375, "section_id": 6957}, "so_47964986_47965037_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 5714}, "so_47964986_47965042_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 6957}}, "n4659": {"so_47964986_47965042_1": {"length": 13, "quality": 0.8125, "section_id": 8722}, "so_47964986_47965037_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 7428}, "so_47964986_47965042_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 8722}}}, "47965037": {"Id": "47965037", "PostTypeId": "2", "Body": "<p>For <code>(unsigned int)0-1</code>, the operands of <code>operator-</code> is <code>unsigned int</code> <code>0</code> and <code>int</code> <code>1</code>. Then the type of the result (i.e. the <a href=\"http://en.cppreference.com/w/cpp/language/operator_arithmetic#Conversions\" rel=\"nofollow noreferrer\">common type</a>) would be <code>unsigned int</code>.</p>\n<blockquote>\n<p id=\"so_47964986_47965037_0\">Otherwise, if the unsigned operand's conversion rank is greater or equal to the conversion rank of the signed operand, the signed operand is converted to the unsigned operand's type.</p>\n</blockquote>\n<p>For <code>unsigned int</code>, it couldn't be <code>0-1</code>, but</p>\n<blockquote>\n<p id=\"so_47964986_47965037_1\">Unsigned integer arithmetic is always performed <em>modulo 2<sup>n</sup></em>\n   where n is the number of bits in that particular integer. E.g. for <code>unsigned int</code>, adding one to <a href=\"http://en.cppreference.com/w/cpp/types/climits\" rel=\"nofollow noreferrer\">UINT_MAX</a> gives \u200b<code>0</code>\u200b, and subtracting one from <code>\u200b0</code>\u200b gives <a href=\"http://en.cppreference.com/w/cpp/types/climits\" rel=\"nofollow noreferrer\">UINT_MAX</a>.</p>\n</blockquote>\n<p>That means <code>if(((unsigned int)0-1)&gt;0)</code> is equivalent to <code>if(UINT_MAX&gt;0)</code>, which is <code>true</code>.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2017-12-25T01:23:42.063", "Score": "3", "CreationDate": "2017-12-25T01:14:39.247", "ParentId": "47964986", "CommentCount": "2", "OwnerUserId": "3309790", "LastEditDate": "2017-12-25T01:23:42.063"}, "47965042": {"Id": "47965042", "PostTypeId": "2", "Body": "<blockquote id=\"so_47964986_47965042_0\">\n<pre><code>if(((unsigned int)0-1)&gt;0)\n</code></pre>\n</blockquote>\n<p>With ordinary arithmetic, 0-1 is negative one, which is not greater than zero. We're not dealing with ordinary arithmetic here.</p>\n<p>The C++ (and also C) precedence rules says that casting has precedence over subtraction, so <code>(unsigned int)0-1</code> is equivalent to <code>((unsigned int) 0)-1</code>. In other words, the <code>0</code> is treated as an <code>unsigned int</code>.</p>\n<p>Next in line we have an <code>unsigned int</code> minus a signed <code>int</code>. The C++ (and C) rules regarding such operations is that the signed value is treated as if it were unsigned. The C++ (and C) rules with regard to unsigned operations is to perform the computation modulo 2<sup>N</sup>, where N is the number of bits in the common type (typically 32 for an <code>int</code>, but no guarantee of that). <code>0-1</code> modulo 2<sup>N</sup> is 2<sup>N</sup>-1, which is a (large) positive number.</p>\n<p>Quoting from the standard, [basic.fundamental] paragraph 4,</p>\n<blockquote>\n<p id=\"so_47964986_47965042_1\">Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2<sup><em>n</em></sup> where <em>n</em> is the number of bits in the value representation of that particular size of integer.<sup>46</sup></p>\n</blockquote>\n<p>and the footnote:</p>\n<blockquote>\n<p id=\"so_47964986_47965042_2\">46) This implies that unsigned arithmetic does not overflow because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer type.</p>\n</blockquote>\n", "LastEditorUserId": "298225", "LastActivityDate": "2017-12-25T01:41:48.487", "Score": "1", "CreationDate": "2017-12-25T01:16:40.333", "ParentId": "47964986", "CommentCount": "1", "OwnerUserId": "774499", "LastEditDate": "2017-12-25T01:41:48.487"}, "47964986": {"ViewCount": "210", "Body": "<p>I came across some c++ code which was like</p>\n<pre><code>if(((unsigned int)0-1)&gt;0)\n{\n//do something\n}\n</code></pre>\n<p>and the program executed the statements in the if block. Being curious, I tried the same in c, which did the same. My understanding is that the statements in the if block get executed if the expression in the if condition returns a bool value true. This means that ((unsigned int)0-1)&gt;0 must be returning true. Why is this happening?</p>\n", "Title": "returns true for ((unsigned int)0-1)>0", "CreationDate": "2017-12-25T00:58:19.337", "LastActivityDate": "2017-12-25T01:41:48.487", "CommentCount": "5", "LastEditDate": "2017-12-25T01:00:25.250", "PostTypeId": "1", "LastEditorUserId": "6622587", "Id": "47964986", "Score": "0", "OwnerUserId": "8555635", "Tags": "<c++><if-statement>", "AnswerCount": "2"}});