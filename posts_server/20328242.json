post_cb({"bq_ids": {"n4140": {"so_20328242_20328676_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 744}}, "n3337": {"so_20328242_20328676_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 733}}, "n4659": {"so_20328242_20328676_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 802}}}, "20328242": {"ViewCount": "509", "Body": "<p>The standard \"map\" containers in C++ allow you to insert an rvalue:</p>\n<pre><code>T x;\n\nstd::map&lt;int, T&gt; m;\n\n// m[1];  // populate \"1\"\n\nauto it = m.insert(std::make_pair(1, std::move(x)));\n</code></pre>\n<p>The question is what happens when the element already exists, i.e. <code>it-&gt;second == false</code>. Has the element <code>x</code> already been \"moved-from\"? For instance, if it is a unique pointer, will <code>x</code> have been reset to null?</p>\n<p>Patently the answer in the above case is \"yes\", because the moving-from happens already at the point of creating the pair. But suppose now I want to update the existing value, but still retain the information of whether the value already existed or not (so I can't just say <code>m[1] = std::move(x);</code>). Is it possible to \"not move from\" the object in that case?</p>\n<p>I discovered in GCC that the following works [Update: works in GCC 4.6, does <em>not</em> work in GCC 4.8]:</p>\n<pre><code>auto it = m.insert(std::pair&lt;const int, T &amp;&amp;&gt;(1, std::move(x)));\n</code></pre>\n<p>But is this guaranteed to not move?</p>\n", "AcceptedAnswerId": "20328676", "Title": "Does map move-insertion guarantee that elements are or are not moved from?", "CreationDate": "2013-12-02T12:21:41.730", "Id": "20328242", "CommentCount": "7", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2013-12-02T13:44:24.230", "LastEditorUserId": "596781", "LastActivityDate": "2013-12-02T14:24:56.263", "Score": "11", "OwnerUserId": "596781", "Tags": "<c++><c++11><move-semantics>", "AnswerCount": "1"}, "20328676": {"Id": "20328676", "PostTypeId": "2", "Body": "<p>Though <code>std::move</code> does not actually perform any move, and neither does <code>std::make_pair</code>, <code>std::make_pair</code> forwards its arguments to the <code>std::pair</code> constructor, which initialises its two value members from those arguments.</p>\n<p>As such, the move is performed at that point, before the <code>std::map</code> has a chance to do anything. So, yes, you end up with a \"broken\" move for no good reason.</p>\n<p>You should be able to take advantage of <code>emplace</code> (in order to skip the pair construction). From Table 102:</p>\n<blockquote>\n<p id=\"so_20328242_20328676_0\">Effects: Inserts a <code>T</code> object <code>t</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code> if and only if there is no element in the container with key equivalent to the key of <code>t</code>.</p>\n</blockquote>\n<p>Clearly, the library is still \"forwarding\" at this point so it's pre-move, and in your case no emplace shall take place so the entire expression ought to be an effective no-op.</p>\n<p><strong>However</strong>, <em>libstdc++</em> from <a href=\"http://coliru.stacked-crooked.com/a/e6721d6afd140c18\" rel=\"noreferrer\">GCC 4.8.0 appears to have a bug</a> in this regard: <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.8.0/libstdc++/api/a01557_source.html#l00540\" rel=\"noreferrer\"><code>emplace</code></a> invokes <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.8.0/libstdc++/api/a01568_source.html#l01617\" rel=\"noreferrer\"><code>_M_emplace_unique</code> on the internal tree</a>, which forwards the arguments to <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.8.0/libstdc++/api/a01568_source.html#l00401\" rel=\"noreferrer\"><code>_M_create_node</code></a>, which forwards the arguments to <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.8.0/libstdc++/api/a01032_source.html#l00391\" rel=\"noreferrer\"><code>allocator_traits&lt;_Node_allocator&gt;::construct</code></a>, which forwards the arguments to <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.8.0/libstdc++/api/a01032_source.html#l00253\" rel=\"noreferrer\"><code>_S_construct</code></a>, which forwards the arguments to <code>__a.construct</code> which, with the default allocator, is <code>std::allocator&lt;std::pair&lt;const _Key, _Tp&gt; &gt;::construct</code>, which is the pair constructor you were trying to avoid... all before the collision check in <code>_M_emplace_unique</code>.</p>\n<p>It could be claimed that the standard is ambiguous in this regard, but I'd call it a violation of intent. Then again, <a href=\"http://coliru.stacked-crooked.com/a/3efde78ebbc7f873\" rel=\"noreferrer\">clang v3.4 with <em>libc++</em> exhibits this behaviour too</a>, as does Visual Studio 2012. So if my standard interpretation is correct, this fails on all three of the mainstream toolchains.</p>\n<p>I guess they all decided that the \"if and only if\" applied to the insertion, rather than the insertion <em>and</em> the construction.</p>\n<p>I have posted a question on <a href=\"http://isocpp.org/forums/iso-c-standard-discussion?place=msg%2Fstd-discussion%2FYQ4BGAvxIhw%2FjTfn1RIm9IkJ\" rel=\"noreferrer\"><em>std-discussion</em></a> aiming to provoke an improvement to the passage from Table 102 to authoritatively answer this once and for all.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2013-12-02T14:24:56.263", "Score": "16", "CreationDate": "2013-12-02T12:43:35.937", "ParentId": "20328242", "CommentCount": "9", "OwnerUserId": "560648", "LastEditDate": "2013-12-02T14:24:56.263"}});