post_cb({"4300911": {"Id": "4300911", "PostTypeId": "2", "Body": "<p>Yes, your understanding is correct. This is nothing by copy initialization and involves the use of a copy constructor. There is no way to avoid this copy as this is what is being requested by the code snippet you have shown.</p>\n<p>Even if you wreak havoc on the copy, don't worry. The original is still safe. The concern is only if the process of creating a copy can wreak havoc, but then that's a different issue.</p>\n<p>C++ 03 relevant references:</p>\n<blockquote>\n<p id=\"so_4300869_4300911_0\">$8.5/12- \"The initialization that\n  occurs in argument passing, function\n  return, throwing an exception (15.1),\n  handling an exception (15.3), and\n  brace-enclosed initializer lists\n  (8.5.1) is called copy-initialization\n  and is equivalent to the form T x =\n  a;\"</p>\n<p id=\"so_4300869_4300911_1\">$8.5/14- \"If the initialization is\n  direct-initialization, or if it is\n  copy-initialization where the\n  cv-unqualified version of the source\n  type is the same class as, or a\n  derived class of, the class of the\n  destination, constructors are\n  considered. The applicable\n  constructors are enumerated\n  (13.3.1.3), and the best one is chosen\n  through overload resolution (13.3).\n  The constructor so selected is called\n  to initialize the object, with the\n  initializer expression(s) as its\n  argument(s). If no constructor\n  applies, or the overload resolution is\n  ambiguous, the initialization is\n  ill-formed.\"</p>\n</blockquote>\n", "LastEditorUserId": "418110", "LastActivityDate": "2010-11-29T04:49:01.480", "Score": "1", "CreationDate": "2010-11-29T04:41:41.103", "ParentId": "4300869", "CommentCount": "1", "OwnerUserId": "418110", "LastEditDate": "2010-11-29T04:49:01.480"}, "4300910": {"Id": "4300910", "PostTypeId": "2", "Body": "<pre><code>std::map&lt;int, int&gt; s = f.getStuff();\n</code></pre>\n<p>This invokes the <code>std::map&lt;int, int&gt;</code> copy constructor and makes a copy of the object.  The contents of the <code>stuff</code> map are copied into the new map <code>s</code>.</p>\n<p>You can't wreak havoc with the original object because <code>s</code> is a new object completely unrelated to the original object, aside from the fact that the original object and the new object have the same contents.</p>\n<p>It is impossible to legitimately wreak havoc with the <code>stuff</code> map via the const reference returned by <code>foo::getStuff()</code>.  The only way you could modify the map would be through a <code>const_cast</code>, and modifying an object via a pointer or reference obtained through a <code>const_cast</code> may yield undefined behavior.</p>\n", "LastActivityDate": "2010-11-29T04:41:30.213", "CommentCount": "4", "CreationDate": "2010-11-29T04:41:30.213", "ParentId": "4300869", "Score": "4", "OwnerUserId": "151292"}, "4300934": {"Id": "4300934", "PostTypeId": "2", "Body": "<p>Short answer: no, you can't prevent it. The client can't modify the original, but if you give the client read-access to the map, then the client is responsible for not doing stupid things with the information; the class can't possibly prevent that.</p>\n<p>Longer answer: maybe, but not really. If you really want to make copying difficult, you can wrap the map in a class with private copy constructor and assignment operator. That way the <code>s</code> assignment will be illegal (rejected by the compiler). The client will still be able to read the elements of the map piecemeal and populate a new map with them -- a manual copy --  but the only way to prevent that is to restrict the read-access in the wrapper class, which kind of defeats the purpose of <code>getStuff</code>.</p>\n", "LastActivityDate": "2010-11-29T04:48:24.223", "CommentCount": "1", "CreationDate": "2010-11-29T04:48:24.223", "ParentId": "4300869", "Score": "5", "OwnerUserId": "128940"}, "bq_ids": {"n4140": {"so_4300869_4300911_1": {"length": 39, "quality": 0.8666666666666667, "section_id": 3296}}, "n3337": {"so_4300869_4300911_1": {"length": 39, "quality": 0.8666666666666667, "section_id": 3166}}, "n4659": {"so_4300869_4300911_1": {"length": 39, "quality": 0.8666666666666667, "section_id": 4058}}}, "4300869": {"ViewCount": "1064", "Body": "<p>I am a little confused right now regarding C++ reference semantics. Suppose I have a class that returns a const reference:</p>\n<pre><code>class foo\n{\nprivate:\n    std::map&lt;int, int&gt; stuff;\npublic:\n    const std::map&lt;int, int&gt;&amp; getStuff()\n    {\n        return stuff;\n    }\n};\n</code></pre>\n<p>And I use it as follows:</p>\n<pre><code>foo f;\nconst std::map&lt;int, int&gt;&amp; s = f.getStuff();\n</code></pre>\n<p>which is fine, but if I were to use it as follows:</p>\n<pre><code>foo f;\nstd::map&lt;int, int&gt; s = f.getStuff();\n</code></pre>\n<p>What happens exactly?</p>\n<p>If I understand correctly, a const reference to <code>stuff</code> was returned and a copy created into <code>s</code> on which I can wreak havoc. Would there be any way to avoid this?</p>\n<p>edit:</p>\n<p>So there is no way to avoid the copy constructor being called here, for std::map anyways...</p>\n", "AcceptedAnswerId": "4300934", "Title": "Prevent copying when initializing an non-const object from a const reference", "CreationDate": "2010-11-29T04:27:57.213", "Id": "4300869", "CommentCount": "9", "LastEditDate": "2010-11-29T05:02:05.507", "PostTypeId": "1", "LastEditorUserId": "217197", "LastActivityDate": "2010-11-29T05:02:05.507", "Score": "9", "OwnerUserId": "217197", "Tags": "<c++><reference><const>", "AnswerCount": "4"}, "4300925": {"Id": "4300925", "PostTypeId": "2", "Body": "<p>Yep, this will create a copy of the map.</p>\n<p>As for your question - depends just how much you want to avoid. In general, if this is a class you declared yourself, you can make the copy constructor or <code>operator =</code> private to prevent it from being used, but obviously, this will prohibit you from quite a few things.</p>\n", "LastActivityDate": "2010-11-29T04:46:08.330", "CommentCount": "0", "CreationDate": "2010-11-29T04:46:08.330", "ParentId": "4300869", "Score": "0", "OwnerUserId": "345717"}});