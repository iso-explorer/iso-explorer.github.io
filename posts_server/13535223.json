post_cb({"bq_ids": {"n4140": {"so_13535223_13535253_0": {"length": 17, "quality": 1.0, "section_id": 272}, "so_13535223_13535223_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 263}}, "n3337": {"so_13535223_13535253_0": {"length": 17, "quality": 1.0, "section_id": 263}, "so_13535223_13535223_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 254}}, "n4659": {"so_13535223_13535253_0": {"length": 17, "quality": 1.0, "section_id": 279}, "so_13535223_13535223_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 270}}}, "13535253": {"Id": "13535253", "PostTypeId": "2", "Body": "<p>Either are allowed.  In the specialization</p>\n<pre><code>template &lt;&gt;\nvoid foo(int) {}\n</code></pre>\n<p>the compiler infers the template argument <code>T = int</code> from the function arguments. From 14.7.3p10:</p>\n<blockquote>\n<p id=\"so_13535223_13535253_0\">A trailing <em>template-argument</em> can be left unspecified in the <em>template-id</em> naming an explicit function template specialization provided it can be deduced from the function argument type.</p>\n</blockquote>\n<p>The example given involves a deduction from a class template, but it's just as applicable to deduction from a type used directly:</p>\n<pre><code>template&lt;class T&gt; class Array { /\u2217 ... \u2217/ };\ntemplate&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v);\n// explicit specialization for sort(Array&lt;int&gt;&amp;)\n// with deduced template-argument of type int\ntemplate&lt;&gt; void sort(Array&lt;int&gt;&amp;);\n</code></pre>\n", "LastActivityDate": "2012-11-23T20:17:34.873", "CommentCount": "0", "CreationDate": "2012-11-23T20:17:34.873", "ParentId": "13535223", "Score": "2", "OwnerUserId": "567292"}, "13535223": {"ViewCount": "58", "Body": "<p>Is it</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(T) {}\n\ntemplate &lt;&gt;\nvoid foo(int) {}\n</code></pre>\n<p>explicit specialization or function overloading, and for the explicit initialization compiler want to see the following code?</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(T) {}\n\ntemplate &lt;&gt;\nvoid foo&lt;int&gt;(int) {}\n</code></pre>\n<p>I think that standard accepts both of these:</p>\n<p><strong>ISO/IEC 14882:2011</strong></p>\n<blockquote id=\"so_13535223_13535223_0\">\n<pre><code>14.7.3 Explicit specialization [temp.expl.spec]\n\n1 ...\n\ncan be declared by a declaration introduced by template&lt;&gt;; that is:\nexplicit-specialization:\ntemplate &lt; &gt; declaration\n</code></pre>\n</blockquote>\n", "Title": "explicit specialization syntax", "CreationDate": "2012-11-23T20:14:16.353", "LastActivityDate": "2012-11-23T20:17:34.873", "CommentCount": "0", "PostTypeId": "1", "Id": "13535223", "Score": "1", "OwnerUserId": "1608835", "Tags": "<c++>", "AnswerCount": "1"}});