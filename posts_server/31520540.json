post_cb({"31520780": {"ParentId": "31520540", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There's an additional rule when it comes to resolving ambiguity between function overloads that are instantiations of a function template: <em>partial ordering of overloaded function templates</em> (<strong>[temp.func.order]</strong>).</p>\n<p>This is usually used to resolve ambiguity in favor of more specialized overloaded function templates:</p>\n<pre><code>template&lt;typename T&gt; void f(T) { ... }\ntemplate&lt;typename T&gt; void f(T*) { ... } // specialization for pointers\nvoid g() { int i; f(&amp;i); }   // calls f&lt;int&gt;(int*), not f&lt;int*&gt;(int*)\n</code></pre>\n<p>However, because of the way the rules are set out (<strong>[over.match.best]</strong>/1) function template partial ordering applies even when the template parameter (here <code>T := A</code>) was not deduced from the arguments by template argument deduction, even if it was supplied by explicit specialization:</p>\n<blockquote>\n<p id=\"so_31520540_31520780_0\">[...]<br/>\n  \u2014 <code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized\n  than the template for <code>F2</code> according to the partial ordering rules described in 14.5.6.2.</p>\n</blockquote>\n<p>Here <code>bar(A::value_type *)</code> is considered more specialized than <code>bar(A *)</code> (under <strong>[temp.func.order]</strong>), so the former is preferred and there is no ambiguity.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2015-07-20T15:53:12.377", "Id": "31520780", "Score": "0", "CreationDate": "2015-07-20T15:43:16.380", "LastActivityDate": "2015-07-20T15:53:12.377"}, "bq_ids": {"n4140": {"so_31520540_31520780_0": {"section_id": 603, "quality": 0.9333333333333333, "length": 14}, "so_31520540_31520796_0": {"section_id": 603, "quality": 0.8857142857142857, "length": 31}}, "n3337": {"so_31520540_31520780_0": {"section_id": 593, "quality": 0.9333333333333333, "length": 14}, "so_31520540_31520796_0": {"section_id": 593, "quality": 0.8857142857142857, "length": 31}}, "n4659": {"so_31520540_31520780_0": {"section_id": 629, "quality": 0.9333333333333333, "length": 14}, "so_31520540_31520796_0": {"section_id": 629, "quality": 0.8857142857142857, "length": 31}}}, "31520796": {"ParentId": "31520540", "CommentCount": "1", "Body": "<p>The rules for determining which overload is the best viable candidate as the last tiebreaker include, from [over.match.best]:</p>\n<blockquote>\n<p id=\"so_31520540_31520796_0\">Given these definitions, a viable function F1 is defined to be a better function than another viable function\n  F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then<br>\n  \u2014 [...]<br>\n  \u2014 F1 and F2 are function template specializations, and the function template for F1 is more specialized\n  than the template for F2 according to the partial ordering rules described in 14.5.6.2.</br></br></p>\n</blockquote>\n<p>That bullet point is reached only if we have two functions with identical conversion sequences in which either both are or both aren't function templates. For <code>foo</code>, both our overload candidates have identical conversion sequences, neither are function templates, and this last bullet point doesn't apply - so it's ambiguous. </p>\n<p>For <code>bar</code> though, we can try to see if one or the other of </p>\n<pre><code>template&lt;typename T&gt; void bar (T*) // (1)\ntemplate&lt;typename T&gt; void bar (typename T::value_type *) // (2)\n</code></pre>\n<p>is more partially specialized than the other. The rules for that are basically to try to see if you can call one function with the other's argument. In this case, any <code>typename T::value_type*</code> is still a pointer, so you could call the <code>T*</code> overload with it. However, in the other direction, template deduction would fail as <code>typename T::value_type</code> is a non-deduced context. So <code>(2)</code> is considered more partially specialized and so it's chosen as the best viable candidate. No ambiguity. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "31520796", "Score": "1", "CreationDate": "2015-07-20T15:43:49.583", "LastActivityDate": "2015-07-20T15:43:49.583"}, "31520540": {"CommentCount": "3", "ViewCount": "303", "PostTypeId": "1", "ClosedDate": "2015-07-20T15:44:39.260", "LastEditorUserId": "2069064", "CreationDate": "2015-07-20T15:31:20.950", "LastActivityDate": "2015-07-20T15:53:12.377", "LastEditDate": "2015-07-20T15:44:58.050", "FavoriteCount": "2", "Title": "Why is function overload ambiguous, but template overloads not ambiguous?", "Id": "31520540", "Score": "5", "Body": "<p>Why, in the below, is the call to an instantiation of <code>bar</code> not ambiguous, while the non-template overloaded function <code>foo</code> is ambiguous. It is the same for <code>nullptr</code> instead of <code>NULL</code></p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid bar (T*)\n{\n  std::cout &lt;&lt; \"bar(T*)\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;typename T&gt;\nvoid bar (typename T::value_type *)\n{\n  std::cout &lt;&lt; \"bar(T::value_type*)\" &lt;&lt; std::endl;\n}\n\nstruct A\n{\n  using value_type = int;\n};\n\nvoid foo (A::value_type*)\n{\n  std::cout &lt;&lt; \"foo(A::value_type *)\" &lt;&lt; std::endl; \n}\n\nvoid foo (A*)\n{\n  std::cout &lt;&lt; \"foo(A *)\" &lt;&lt; std::endl; \n}\n\nint main ()\n{\n  bar&lt;A&gt; (NULL);\n  foo (NULL); // ambigous\n}\n</code></pre>\n<p>EDIT: To be clear. I expect the <code>foo</code> overload to be ambiguous. I don't understand why the <code>bar</code> overloads generated when I instantiate <code>bar&lt;A&gt;</code> are not equally ambiguous.</p>\n", "Tags": "<c++><templates><overload-resolution>", "OwnerUserId": "3184917", "AnswerCount": "2"}});