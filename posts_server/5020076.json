post_cb({"5020076": {"CommentCount": "0", "AcceptedAnswerId": "5020268", "CreationDate": "2011-02-16T17:47:10.343", "LastActivityDate": "2011-02-16T18:03:45.613", "PostTypeId": "1", "ViewCount": "2103", "FavoriteCount": "2", "Title": "Passing a C++ complex array to C", "Id": "5020076", "Score": "6", "Body": "<p>I must pass complex data to a C function from C++. In C++ the data is naturally stored in a \n<code>std::vector&lt;std::complex&gt; c</code>. The C function expects the data as an array of double, <code>double a[]</code> such that a[0]=Re(c[0]), a[1]=Im(c[0]), a[2]=Re(c[1]), etc.</p>\n<p>What is the best safe way to pass such data? Is casting like</p>\n<pre><code>(double*) (&amp;c[0])\n</code></pre>\n<p>asking for trouble?</p>\n<p>Sorry if this is duplicate, I could only find information on the related problem of passing C++ complex to C99 complex.</p>\n", "Tags": "<c++><c>", "OwnerUserId": "611697", "AnswerCount": "3"}, "5020268": {"ParentId": "5020076", "CommentCount": "4", "Body": "<p>The C++0x standard went to lengths to guarantee that such conversions will work (\u00a726.4):</p>\n<blockquote>\n<p id=\"so_5020076_5020268_0\">Moreover, if a is an expression of type <code>cv std::complex&lt;T&gt;*</code> and the expression <code>a[i]</code> is well-defined for an integer expression <code>i</code>, then:</p>\n<p id=\"so_5020076_5020268_1\">\u2014 <code>reinterpret_cast&lt;cv T*&gt;(a)[2*i]</code> shall designate the real part of <code>a[i]</code>, and</p>\n<p id=\"so_5020076_5020268_2\">\u2014 <code>reinterpret_cast&lt;cv T*&gt;(a)[2*i + 1]</code> shall designate the imaginary part of <code>a[i]</code>.</p>\n</blockquote>\n<p>and (\u00a723.3.6):</p>\n<blockquote>\n<p id=\"so_5020076_5020268_3\">The elements of a vector are stored contiguously, meaning that if <code>v</code> is a <code>vector&lt;T, Allocator&gt;</code> where <code>T</code> is some type other than bool, then it obeys the identity <code>&amp;v[n] == &amp;v[0] + n</code> for all <code>0 &lt;= n &lt; v.size()</code>.</p>\n</blockquote>\n<p>The layout of the complex value is <em>not</em> guaranteed by the prevailing C++03 standard (though the vector layout is), but I would be surprised to find an implementation for which it does not hold.</p>\n", "OwnerUserId": "142434", "PostTypeId": "2", "Id": "5020268", "Score": "15", "CreationDate": "2011-02-16T18:02:43.237", "LastActivityDate": "2011-02-16T18:02:43.237"}, "5020126": {"ParentId": "5020076", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Use the <a href=\"http://www.cplusplus.com/reference/algorithm/copy/\" rel=\"nofollow\">copy</a> algorithm to copy the vector contents into a new (not vector backed) array.  This will guarantee a C required memory layout while the C++99 standard doesn't guarantee any memory layout for vectors (unlike the C++03 standard, which guarantees a C compatible memory layout).</p>\n<p>You cannot cast a std::vector into an array, and std::vector has no extending \"getArray()\" method.  You will have to write a routine that creates an array based on the vector's current size, walks the vector and copies each element into the created array.</p>\n", "OwnerUserId": "302139", "LastEditorUserId": "302139", "LastEditDate": "2011-02-16T18:01:46.340", "Id": "5020126", "Score": "0", "CreationDate": "2011-02-16T17:51:17.057", "LastActivityDate": "2011-02-16T18:01:46.340"}, "bq_ids": {"n4140": {"so_5020076_5020268_3": {"section_id": 955, "quality": 0.9473684210526315, "length": 18}, "so_5020076_5020268_2": {"section_id": 3402, "quality": 1.0, "length": 5}, "so_5020076_5020268_0": {"section_id": 3402, "quality": 1.0, "length": 9}, "so_5020076_5020268_1": {"section_id": 3402, "quality": 1.0, "length": 5}}, "n3337": {"so_5020076_5020268_3": {"section_id": 943, "quality": 0.9473684210526315, "length": 18}, "so_5020076_5020268_2": {"section_id": 3271, "quality": 1.0, "length": 5}, "so_5020076_5020268_0": {"section_id": 3271, "quality": 1.0, "length": 9}, "so_5020076_5020268_1": {"section_id": 3271, "quality": 1.0, "length": 5}}, "n4659": {"so_5020076_5020268_2": {"section_id": 4159, "quality": 0.8, "length": 4}, "so_5020076_5020268_0": {"section_id": 4159, "quality": 0.8888888888888888, "length": 8}, "so_5020076_5020268_1": {"section_id": 4159, "quality": 0.8, "length": 4}}}, "5020146": {"ParentId": "5020076", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The current standard do not specify the memory layout of a <code>std::complex</code>, so I suppose that your method is not portable. If it was guaranteed that it's two <code>double</code>s without extra padding, then it should work (the memory of the <code>vector</code> is guaranteed to be contiguous by the C++03 standard).</p>\n<p>If you want to be really safe you have to walk your vector and copy explicitly the elements.</p>\n<p><hr/>\n<strong>Edit</strong> in C++0x, instead, this is guaranteed, see @Stephen Canon answer.</p>\n", "OwnerUserId": "214671", "LastEditorUserId": "214671", "LastEditDate": "2011-02-16T17:59:56.703", "Id": "5020146", "Score": "0", "CreationDate": "2011-02-16T17:52:54.587", "LastActivityDate": "2011-02-16T17:59:56.703"}});