post_cb({"34536328": {"Id": "34536328", "PostTypeId": "2", "Body": "<p>No data copy is taken automatically.</p>\n<p>You must return a <code>const char*</code> too. The behaviour on casting away the <code>const</code> and attempting to modify the original character string through that pointer is undefined if the original data were originally <code>const</code>: such as a string literal.</p>\n<p>Take a deep copy outside the function if you need a <code>char*</code> pointer.</p>\n<p>Better still, bin all this and pass <code>std::string</code> either by <code>const</code> pointer if <code>nullptr</code> is still allowed or by <code>const</code> reference if it isn't.</p>\n", "LastEditorUserId": "2380830", "LastActivityDate": "2015-12-31T10:13:27.547", "Score": "2", "CreationDate": "2015-12-30T19:55:13.830", "ParentId": "34536203", "CommentCount": "2", "OwnerUserId": "2380830", "LastEditDate": "2015-12-31T10:13:27.547"}, "34536567": {"Id": "34536567", "PostTypeId": "2", "Body": "<p>I would use one boolean flag to avoid code duplicate and make it less prone:</p>\n<pre><code>bool secondIsEmpty = second == nullptr || *second == '\\0';\nif( first == nullptr || *first == '\\0' )\n    return secondIsEmpty ? nullptr : second;\nelse\n    if( secondIsEmpty )\n        return first;\n</code></pre>\n<p>For <code>char *</code>, you should change return type to <code>const char *</code> and remove C cast from your code (you should use const_cast&lt;&gt; instead anyway). If you do need to return mutable string from that function that makes it more complicated. You either have to accept mutable strings as parameters, or create buffer somewhere. In that case you probably should return smart pointer to string, allocated by <code>new</code> or even better use <code>std::string</code> and return it by value.</p>\n", "LastEditorUserId": "432358", "LastActivityDate": "2015-12-30T20:19:00.787", "Score": "0", "CreationDate": "2015-12-30T20:12:05.657", "ParentId": "34536203", "CommentCount": "0", "OwnerUserId": "432358", "LastEditDate": "2015-12-30T20:19:00.787"}, "34536203": {"ViewCount": "648", "Body": "<p>I have the following function which initially performs some validation on function parameters.</p>\n<pre><code>char *doSomething(const char* first, const char* second) {\n\n    if((first == nullptr || *first == '\\0') &amp;&amp; (second == nullptr || *second == '\\0')) {\n        return nullptr;\n    } else if (first == nullptr || *first == '\\0') {\n        return (char *) second;\n    } else if (second == nullptr || *second == '\\0') {\n        return (char *) first;\n    }\n    //doSomething\n}\n</code></pre>\n<p>Does casting the function parameter return a new <code>char*</code> that points to a different area in memory? I don't want to allow someone using this function to manipulate the value that the constant parameters are pointing to. I would like a new <code>char*</code> to be returned with the same value as one of the parameters if one is <code>nullptr</code> or empty.</p>\n<p>Follow-up: Would a boolean variable be better here? I realize I'm performing the same check for each variable twice, but I wouldn't be utilizing this boolean anywhere else in this function's code.</p>\n", "AcceptedAnswerId": "34536287", "Title": "c++ const char* to char*", "CreationDate": "2015-12-30T19:47:50.810", "Id": "34536203", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-12-30T19:51:34.043", "LastEditorUserId": "3313438", "LastActivityDate": "2016-01-03T17:43:41.517", "Score": "2", "OwnerUserId": "1553248", "Tags": "<c++><pointers><casting><constants><nullptr>", "AnswerCount": "7"}, "34537736": {"Id": "34537736", "PostTypeId": "2", "Body": "<p>(This answer is mainly about a side-question on how to make the code better)</p>\n<p>As people here noted, you probably want to return <code>const char*</code>:</p>\n<pre><code>const char *doSomething(const char* first, const char* second)\n{\n    ...\n}\n</code></pre>\n<p>This will let you get rid of casts:</p>\n<pre><code>const char *doSomething(const char* first, const char* second)\n{\n    if (...)\n    {\n        return nullptr;\n    }\n    else if (...)\n    {\n        return second;\n    }\n    else if (...)\n    {\n        return first;\n    }\n}\n</code></pre>\n<p>Your code's idea is roughly:</p>\n<blockquote>\n<p id=\"so_34536203_34537736_0\">Find and return the non-empty string, with preference to <code>second</code> one; if there is none, return <code>nullptr</code>.</p>\n</blockquote>\n<p>It may be more easily represented like this:</p>\n<pre><code>const char *FindNonEmpty(const char* first, const char* second)\n{\n    if (second &amp;&amp; *second)\n        return second;\n    else if (first &amp;&amp; *first)\n        return first;\n    else\n        return nullptr;\n}\n</code></pre>\n<p>I used pointers and bytes here in boolean context. This is a matter of taste; you probably want to use explicit comparisons; however, some people argue that using a pointer as a boolean is more readable than comparing it to <code>nullptr</code>.</p>\n", "LastActivityDate": "2015-12-30T21:46:39.307", "CommentCount": "0", "CreationDate": "2015-12-30T21:46:39.307", "ParentId": "34536203", "Score": "0", "OwnerUserId": "509868"}, "34536421": {"Id": "34536421", "PostTypeId": "2", "Body": "<p>Casting a value will not copy it. If you want to copy it you will have to pass by value, passing by pointer or reference will allow the user to manipulate the returned value (unless it's <code>const</code>).</p>\n<p>I don't see why you're worried about the user manipulating the parameters as they are effectively constant.</p>\n<p>And as for the null checks, using a <code>bool</code> is unnecessary. Null checks are cheap to use (performance wise).</p>\n", "LastActivityDate": "2015-12-30T20:01:57.993", "CommentCount": "0", "CreationDate": "2015-12-30T20:01:57.993", "ParentId": "34536203", "Score": "0", "OwnerUserId": "3376221"}, "34536531": {"Id": "34536531", "PostTypeId": "2", "Body": "<p>The 2011 standard says (5.2.11/3):</p>\n<blockquote>\n<p id=\"so_34536203_34536531_0\">The result of a pointer const_cast refers to the original object.</p>\n</blockquote>\n<p>That is pretty straightforward and answers your original question.</p>\n<p>It also says (5.2.11/7):</p>\n<blockquote>\n<p id=\"so_34536203_34536531_1\">[ Note: Depending on the type of the object, a write operation through\n  the pointer, lvalue or pointer to data member resulting from a\n  const_cast that casts away a const-qualifier may produce undefined\n  behavior (7.1.6.1). \u2014end note ]</p>\n</blockquote>\n<p>This means that it is sometimes ok to even write to the object through the new pointer. Examples where it isn't ok are pointers to objects which reside in read-only memory. This has bitten people using pointers to string literals, and happens frequently with constants in embedded systems. The cast itself is, as far as I can see, never undefined behaviour.</p>\n<p>Concerning your code review question: </p>\n<ul>\n<li>As the others said, by all means return a const char.</li>\n<li>Does the caller do anything with the result? If not, return a bool indicating success or failure, or an int for several failure modes.</li>\n<li>If the caller uses the returned char pointer, what do you return to indicate success? The three possible error cases use up the immediately available return values. Consider returning an error code and passing the actual char pointer result in an \"out parameter\" (a pointer to a char pointer).</li>\n</ul>\n", "LastEditorUserId": "3150802", "LastActivityDate": "2016-01-03T17:43:41.517", "Score": "2", "CreationDate": "2015-12-30T20:09:20.523", "ParentId": "34536203", "CommentCount": "0", "OwnerUserId": "3150802", "LastEditDate": "2016-01-03T17:43:41.517"}, "34536336": {"Id": "34536336", "PostTypeId": "2", "Body": "<p>You are possibly returning pointer to first or second param so the caller of your function can modify the data which it points to. You are technically returning new pointer (copy of it) but because of pointer nature caller can modify data with it. </p>\n<p>If it is bad for you can return const char *, so caller can't modify it or don't return it at all.</p>\n<p>Boolean variable can make your code more clear and avoid code duplication.</p>\n", "LastActivityDate": "2015-12-30T19:55:51.227", "CommentCount": "0", "CreationDate": "2015-12-30T19:55:51.227", "ParentId": "34536203", "Score": "0", "OwnerUserId": "4247443"}, "bq_ids": {"n4140": {"so_34536203_34536531_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 6053}, "so_34536203_34536531_1": {"length": 20, "quality": 0.8333333333333334, "section_id": 6057}}, "n3337": {"so_34536203_34536531_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5821}, "so_34536203_34536531_1": {"length": 20, "quality": 0.8333333333333334, "section_id": 5825}}, "n4659": {"so_34536203_34536531_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 7553}, "so_34536203_34536531_1": {"length": 20, "quality": 0.8333333333333334, "section_id": 7555}}}, "34536287": {"Id": "34536287", "PostTypeId": "2", "Body": "<p>No it doesn't make any new object it simple casts away <code>const</code> to the area of memory you declared to be immutable.  Which <em>normally</em> results in the dreaded Undefined Behavior but if they come from non-<code>const</code> pointer you'll be ok (EDIT - thanks to @anatolyg).</p>\n", "LastEditorUserId": "1312406", "LastActivityDate": "2015-12-30T21:49:20.980", "Score": "5", "CreationDate": "2015-12-30T19:52:14.200", "ParentId": "34536203", "CommentCount": "7", "OwnerUserId": "1312406", "LastEditDate": "2015-12-30T21:49:20.980"}});