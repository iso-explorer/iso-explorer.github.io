post_cb({"bq_ids": {"n4140": {"so_19737929_19738076_1": {"length": 28, "quality": 1.0, "section_id": 3329}, "so_19737929_19737945_0": {"length": 95, "quality": 0.8962264150943396, "section_id": 3329}, "so_19737929_19738076_2": {"length": 15, "quality": 1.0, "section_id": 44}, "so_19737929_19738076_0": {"length": 4, "quality": 1.0, "section_id": 3329}, "so_19737929_19738076_3": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_19737929_19738076_4": {"length": 25, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_19737929_19738076_1": {"length": 25, "quality": 0.8928571428571429, "section_id": 3199}, "so_19737929_19737945_0": {"length": 106, "quality": 1.0, "section_id": 3199}, "so_19737929_19738076_2": {"length": 15, "quality": 1.0, "section_id": 41}, "so_19737929_19738076_0": {"length": 4, "quality": 1.0, "section_id": 3199}, "so_19737929_19738076_3": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_19737929_19738076_4": {"length": 19, "quality": 0.76, "section_id": 3195}}, "n4659": {"so_19737929_19738076_1": {"length": 28, "quality": 1.0, "section_id": 4095}, "so_19737929_19737945_0": {"length": 95, "quality": 0.8962264150943396, "section_id": 4095}, "so_19737929_19738076_2": {"length": 15, "quality": 1.0, "section_id": 45}, "so_19737929_19738076_0": {"length": 4, "quality": 1.0, "section_id": 4095}, "so_19737929_19738076_3": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_19737929_19738076_4": {"length": 25, "quality": 1.0, "section_id": 4091}}}, "19738076": {"Id": "19738076", "PostTypeId": "2", "Body": "<p>It looks like:</p>\n<pre><code>bool b = {2} ;\n</code></pre>\n<p>is indeed a <em>narrowing conversion</em> if we look at the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>8.5.4</code> <em>List-initialization</em> paragraph <em>7</em> says:</p>\n<blockquote>\n<p id=\"so_19737929_19738076_0\">A narrowing conversion is an implicit conversion</p>\n</blockquote>\n<p>and include the following bullet (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19737929_19738076_1\">from an integer type or unscoped enumeration type <strong>to an integer type\n  that cannot represent all the values of the original type</strong>, except\n  where the source is a constant expression whose value after integral\n  promotions will fit into the target type.</p>\n</blockquote>\n<p><code>bool</code> can not represent the value <code>2</code> so this is a narrowing conversion in the strictest sense.  Which makes sense the whole point of <code>{}</code> initialization is to <a href=\"http://www.stroustrup.com/C++11FAQ.html#narrowing\" rel=\"nofollow\">prevent implicit conversions</a> and increase <em>type safety</em>. Which the <em>old style</em> that you refer to here relies on:</p>\n<pre><code>bool b = 2\n</code></pre>\n<p>which depends on the section <code>4.12</code> <em>Boolean conversions</em> which says:</p>\n<blockquote>\n<p id=\"so_19737929_19738076_2\">[...] A zero value, null pointer value, or null member pointer value\n  is converted to false; any other value is converted to true. [...]</p>\n</blockquote>\n<p>Of course the whole premise that <code>{2}</code> would be a <em>narrowing conversion</em> relies the assumption that the value of <em>true</em> and <em>false</em> is <code>1</code> and <code>0</code>, which as far as I can tell is not guaranteed in the standard. Although it is implied the only thing the standard promises in <em>conversions</em> but if we are going to use a <em>literal</em> we don't need to rely on this assumption we have two perfectly good <em>boolean literals</em> for this <code>true</code> and <code>false</code> which is what you should be using.</p>\n<p>For completeness sake, this <em>narrowing conversion</em> is <em>ill-formed</em>, it requires a diagnostic, so either a <em>warning</em> or an <em>error</em> is acceptable. if we look at paragraph <em>3</em>, it says:</p>\n<blockquote>\n<p id=\"so_19737929_19738076_3\">List-initialization of an object or reference of type T is defined as\n  follows:</p>\n</blockquote>\n<p>and include the following bullet (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19737929_19738076_4\">Otherwise, if the initializer list has a single element of type E and either T is not a reference type or its referenced type is reference-related to E, the object or reference is initialized from that element; <strong>if a narrowing conversion (see below) is required to convert the element to T, the program is ill-formed</strong>.</p>\n</blockquote>\n<p>and includes the following example:</p>\n<pre><code>[ Example:\n  int x1 {2}; // OK\n  int x2 {2.0}; // error: narrowing\n\u2014end example ]\n</code></pre>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2016-01-13T16:37:53.137", "Score": "4", "CreationDate": "2013-11-02T01:43:08.330", "ParentId": "19737929", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2016-01-13T16:37:53.137"}, "19737945": {"Id": "19737945", "PostTypeId": "2", "Body": "<p>Narrowing a data type in an initialization-list makes your c++11 program ill formed, in this situation the compiler can either give a warning or keep going. </p>\n<p>Interestingly enough you can actually change it to <code>bool b = {1}</code> and there is no warning, I'm assuming because the value of a bool is guaranteed to convert to 0 and 1 in integral types.  </p>\n<p>Here is a standard quote confirming the error.  </p>\n<blockquote>\n<p id=\"so_19737929_19737945_0\">A narrowing conversion is an implicit conversion<br>\n  \u2014 from a floating-point type to an integer type, or<br>\n  \u2014 from long double to double or float, or from double to float, except where the source is a constant expression and the actual value after conversion is within the range of values  that can be represented (even if it cannot be represented exactly), or<br>\n  \u2014 from an integer type or unscoped enumeration type to a floating-point type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will produce the original value when converted back to the original type, or<br>\n  \u2014 from an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will produce the original value when converted back to the original type.<br>\n  As indicated above, such conversions are not allowed at the top level in list-initializations</br></br></br></br></br></p>\n</blockquote>\n", "LastEditorUserId": "2167655", "LastActivityDate": "2013-11-02T02:04:54.993", "Score": "8", "CreationDate": "2013-11-02T01:19:29.763", "ParentId": "19737929", "CommentCount": "19", "OwnerUserId": "2167655", "LastEditDate": "2013-11-02T02:04:54.993"}, "19737929": {"ViewCount": "428", "Body": "<p>Using the <code>{}</code> initializer in <code>C++11</code> to initialize <code>bool b = {2}</code> yields the following warning message:</p>\n<pre><code>warning: narrowing conversion of \u20182\u2019 from \u2018int\u2019 to \u2018bool\u2019 inside { } [-Wnarrowing]\n</code></pre>\n<p>However, using the old style <code>bool b = 2</code> has no such problem. What is the reason behind this?</p>\n<hr>\n<p>Update: I compiled the code using <code>g++ -std=c++11</code> and it gave me the warning. If I add the option <code>-pedantic-errors</code>, the warning becomes an error.</p>\n</hr>", "AcceptedAnswerId": "19737945", "Title": "Why does `bool b = 2` work well but `bool b = {2}` yield a warning of narrowing conversion?", "CreationDate": "2013-11-02T01:16:36.547", "Id": "19737929", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-11-03T18:49:39.397", "LastEditorUserId": "1708801", "LastActivityDate": "2016-01-13T16:37:53.137", "Score": "7", "OwnerUserId": "1675168", "Tags": "<c++><c++11><type-conversion><narrowing>", "AnswerCount": "2"}});