post_cb({"37480778": {"CommentCount": "1", "CreationDate": "2016-05-27T10:13:35.093", "PostTypeId": "1", "AcceptedAnswerId": "37481069", "LastEditorUserId": "4742570", "LastActivityDate": "2016-05-27T14:09:15.090", "LastEditDate": "2016-05-27T13:59:36.883", "ViewCount": "1356", "FavoriteCount": "1", "Title": "declval expression (for SFINAE) with std::ostream", "Id": "37480778", "Score": "16", "Body": "<p>I'm trying to create a type traits class to determine if a particular type <code>T</code> can be streamed via the <code>&lt;&lt;</code> operator of an <code>std::ostream</code>.  I'm using a straightforward SFINAE technique.</p>\n<p>Ultimately, the expression I attempt to evaluate for substitution failure is:</p>\n<pre><code>decltype(std::declval&lt;std::ostream&gt;() &lt;&lt; std::declval&lt;T&gt;()) ;\n</code></pre>\n<p>My expectation is that, given an instance <code>t</code> of type <code>T</code> and an <code>std::ostream</code> instance <code>os</code>, if the expression  <code>os &lt;&lt; t</code> is ill-formed, a substitution failure should occur.  </p>\n<p>But apparently substitution failure never occurs here regardless of the type <code>T</code>.  And even if I just declare a <code>typedef</code> using the above <code>decltype</code> expression, outside the context of SFINAE, it happily compiles, even if <code>T</code> cannot be used with <code>std::ostream</code>.</p>\n<p>For example:</p>\n<pre><code>struct Foo  { };\n\nint main()\n{\n    // This compiles fine using GCC 4.9.2\n    //\n    typedef decltype(\n        std::declval&lt;std::ostream&gt;() &lt;&lt; std::declval&lt;Foo&gt;()\n    ) foo_type;\n}\n</code></pre>\n<p>The above will compile fine using GCC 4.9.2, which is not what I expected since the <code>&lt;&lt;</code> operator is not overloaded to work with a type <code>Foo</code>.  And of course, if I say:</p>\n<pre><code>std::cout &lt;&lt; Foo();\n</code></pre>\n<p>... I get a compiler error.  So why does the <code>decltype</code> expression above even compile at all?</p>\n", "Tags": "<c++><sfinae>", "OwnerUserId": "2923952", "AnswerCount": "3"}, "37481069": {"ParentId": "37480778", "LastEditDate": "2016-05-27T14:09:15.090", "CommentCount": "4", "CreationDate": "2016-05-27T10:27:53.910", "OwnerUserId": "496161", "LastEditorUserId": "496161", "PostTypeId": "2", "Id": "37481069", "Score": "15", "Body": "<p>C++11 added the following <code>operator&lt;&lt;</code> overload:</p>\n<pre><code>template&lt; class CharT, class Traits, class T &gt;\nbasic_ostream&lt; CharT, Traits &gt;&amp; operator&lt;&lt;( basic_ostream&lt;CharT,Traits&gt;&amp;&amp; os, \n                                            const T&amp; value );\n</code></pre>\n<p>This forwards on to the standard insertion operators, which can't bind rvalue references to <code>std::ostream</code>s because they take non-const references. Since <code>std::declval&lt;std::ostream&gt;</code> returns <code>std::ostream&amp;&amp;</code>, this overload is selected, then due to the very permissive interface (i.e. this isn't SFINAEd out if there is no valid underlying insertion operator), your <code>decltype</code> specifier works.</p>\n<p>The simple fix is to use <code>std::declval&lt;std::ostream&amp;&gt;()</code>. This will return a <code>std::ostream&amp;</code>, so the template overload will not be selected by your <code>decltype</code> specifier and a normal insertion operator overload will be required for it to compile:</p>\n<pre><code>typedef decltype(\n    std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;Foo&gt;()\n) foo_type;\n</code></pre>\n<p>Clang outputs this:</p>\n<pre><code>main.cpp:8:39: error: invalid operands to binary expression ('std::basic_ostream&lt;char&gt;' and 'Foo')\n        std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;Foo&gt;()\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/d9bf5bca68b3b2a0\" rel=\"nofollow noreferrer\"><kbd>Live Demo</kbd></a></p>\n<hr>\n<p>Here's a simpler example which exhibits the same problem:</p>\n<pre><code>#include &lt;string&gt;\n\nvoid foo (int&amp;,int){}\nvoid foo (int&amp;,float){}\n\ntemplate &lt;typename T&gt;\nvoid foo (int&amp;&amp; a, T b) {\n    foo(a, b);\n}\n\nint main()\n{\n    std::string s;\n    typedef decltype(foo(1,s)) foo_type;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/64e3d642d25773d6\" rel=\"nofollow noreferrer\"><kbd>Live Demo</kbd></a></p>\n<hr>\n<p>Here are the relevant standards quotes (N4140):</p>\n<p>The declaration must be instantiated because overload resolution is involved:</p>\n<blockquote>\n<p id=\"so_37480778_37481069_0\"><code>[temp.inst]/10:</code> If a function template or a member function template specialization is used in a way that involves overload\n  resolution, a declaration of the specialization is implicitly instantiated (14.8.3).</p>\n</blockquote>\n<p>Only the declaration needs to be instantiated:</p>\n<blockquote>\n<p id=\"so_37480778_37481069_1\"><code>[temp.over]/5:</code> Only the signature of a function template specialization is needed to enter the specialization in a set of\n  candidate functions. Therefore only the function template declaration is needed to resolve a call for which\n  a template specialization is a candidate.</p>\n</blockquote>\n<p>And the implementation is not allowed to instantiate the function body:</p>\n<blockquote>\n<p id=\"so_37480778_37481069_2\"><code>[temp.inst]/11:</code> An implementation shall not implicitly instantiate a function template, a variable template, a member template, a non-virtual member function, a member class, or a static data member of a class template that does not require instantiation.</p>\n</blockquote>\n</hr></hr>", "LastActivityDate": "2016-05-27T14:09:15.090"}, "37481132": {"ParentId": "37480778", "LastEditDate": "2016-05-27T10:36:09.343", "CommentCount": "0", "CreationDate": "2016-05-27T10:30:39.480", "OwnerUserId": "6255513", "LastEditorUserId": "6255513", "PostTypeId": "2", "Id": "37481132", "Score": "1", "Body": "<p>If you look at the header file <code>ostream</code>, you will find that because <code>std::declval</code> produces rvlaue references, there is actually a matching generic <code>operator&lt;&lt;</code>:</p>\n<pre><code>#if __cplusplus &gt;= 201103L\n  /** \n   *  @brief  Generic inserter for rvalue stream\n   *  @param  __os  An input stream.\n   *  @param  __x  A reference to the object being inserted.\n   *  @return  os  \n   *   \n   *  This is just a forwarding function to allow insertion to\n   *  rvalue streams since they won't bind to the inserter functions\n   *  that take an lvalue reference.\n  */  \n  template&lt;typename _CharT, typename _Traits, typename _Tp&gt;\n    inline basic_ostream&lt;_CharT, _Traits&gt;&amp;\n    operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp;&amp; __os, const _Tp&amp; __x)\n    {   \n      __os &lt;&lt; __x;\n      return __os;\n    }   \n#endif // C++11\n</code></pre>\n<p>This explains why you get no substition failure. However, this can't actually be matched against the <code>std::cout &lt;&lt; Foo()</code> call. Here is the relevant part of the compilation error:</p>\n<pre><code>/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:628:5: note: candidate function [with _CharT = char, _Traits = std::char_traits&lt;char&gt;, _Tp = Foo] not viable: no known conversion from 'ostream' (aka 'basic_ostream&lt;char&gt;') to 'basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt; &amp;&amp;' for 1st argument\n    operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp;&amp; __os, const _Tp&amp; __x)\n    ^\n</code></pre>\n<p>The problem here is that the lhs can only be an rvalue reference, but you're (obviously) using an lvalue (i.e. <code>std::cout</code>) in the call.</p>\n", "LastActivityDate": "2016-05-27T10:36:09.343"}, "bq_ids": {"n4140": {"so_37480778_37481069_1": {"section_id": 359, "quality": 0.9090909090909091, "length": 20}, "so_37480778_37481069_0": {"section_id": 242, "quality": 0.875, "length": 14}, "so_37480778_37481069_2": {"section_id": 243, "quality": 0.9565217391304348, "length": 22}}, "n3337": {"so_37480778_37481069_1": {"section_id": 349, "quality": 0.9090909090909091, "length": 20}, "so_37480778_37481069_0": {"section_id": 234, "quality": 0.875, "length": 14}, "so_37480778_37481069_2": {"section_id": 235, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_37480778_37481069_1": {"section_id": 369, "quality": 0.9090909090909091, "length": 20}, "so_37480778_37481069_0": {"section_id": 249, "quality": 0.875, "length": 14}, "so_37480778_37481069_2": {"section_id": 250, "quality": 0.8695652173913043, "length": 20}}}, "37481353": {"ParentId": "37480778", "CommentCount": "0", "Body": "<p>Doesn't really answer why this is happening but if you replace with <code>std::stream&amp;</code> as below:</p>\n<pre><code>template&lt;typename T, typename Enable = std::ostream&amp;&gt;\nstruct can_be_streamed : std::false_type {};\ntemplate&lt;typename T&gt;\nstruct can_be_streamed&lt;T, \n         decltype(std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;())&gt; : std::true_type {};\n</code></pre>\n<p>seems to work.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/abddc0a873804362\" rel=\"nofollow\"><strong>Live Demo</strong></a></p>\n", "OwnerUserId": "2352671", "PostTypeId": "2", "Id": "37481353", "Score": "2", "CreationDate": "2016-05-27T10:41:19.220", "LastActivityDate": "2016-05-27T10:41:19.220"}});