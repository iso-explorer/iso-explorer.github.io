post_cb({"1117905": {"CommentCount": "3", "Body": "<p>Stand alone functions are const by definition. Hence there is no difference between a const and a non-const function pointer.</p>\n", "CreationDate": "2009-07-13T06:11:19.147", "ParentId": "1117873", "Id": "1117905", "LastActivityDate": "2009-07-13T06:11:19.147", "PostTypeId": "2", "Score": "6", "OwnerUserId": "39742"}, "1117968": {"LastActivityDate": "2009-07-13T06:42:10.520", "CommentCount": "0", "Body": "<p>As an interesting aside, the const specifier does not seem to have an effect even when used on pointers to <em>member</em> functions.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Foo {\npublic:\n  int sum( int x, int y ) {\n    _x = x;\n    _y = y;\n    return x + y;\n  }\nprivate:\n  int _x;\n  int _y;\n};\n\ntypedef int (Foo::*sum_func)(int,int);\n\nint main()\n{\n    Foo f;\n    const sum_func sum_func_cptr = &amp;Foo::sum; // const pointer\n    sum_func sum_func_ptr = &amp;Foo::sum;        // non-const pointer\n\n    int x = (f.*sum_func_cptr)( 2, 2 );\n    cout &lt;&lt; x &lt;&lt; endl;\n\n    int y = (f.*sum_func_ptr)( 2, 2 );\n    cout &lt;&lt; y &lt;&lt; endl;\n\n    const sum_func* sum_func_cptr_cptr = &amp;sum_func_cptr;\n    sum_func* sum_func_ptr_ptr = &amp;sum_func_ptr;\n\n    x = (f.**sum_func_cptr_cptr)( 2, 2 );\n    cout &lt;&lt; x &lt;&lt; endl;\n\n    y = (f.**sum_func_ptr_ptr)( 2, 2 );\n    cout &lt;&lt; y &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n", "CreationDate": "2009-07-13T06:39:20.027", "LastEditDate": "2009-07-13T06:42:10.520", "ParentId": "1117873", "Id": "1117968", "LastEditorUserId": "89847", "PostTypeId": "2", "Score": "0", "OwnerUserId": "9822"}, "1118283": {"LastActivityDate": "2009-07-13T09:17:23.810", "CommentCount": "7", "Body": "<p>Your code is <strong>ill-formed</strong> with regard to C++03. You can <strong>not</strong> ever construct a const (or volatile) qualified function type. Whenever you do, your program becomes ill-formed.</p>\n<p>This rule <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#295\" rel=\"noreferrer\">has been changed</a> for C++1x, to make the compiler ignore the <code>const</code> / <code>volatile</code>. C++ compilers will usually already implement this rule even in C++03 mode. Thus, the following two will define the same function twice, and results in a compilation error. </p>\n<pre><code>typedef void Ft();\n\n\nvoid f(Ft const*) { }\nvoid f(Ft *) { } // another definition!\n</code></pre>\n<p>Here is the proof of my claim. C++03, <code>8.3.5/1</code></p>\n<blockquote>\n<p id=\"so_1117873_1118283_0\">A cv-qualifier-seq shall only be part of the function type for a nonstatic member function, the function type to which a pointer to member refers, or the top-level function type of a function typedef declaration. The effect of a cv-qualifier-seq in a function declarator is not the same as adding cv-qualification on top of the function type, i.e., it does not create a cv-qualified function type. In fact, if at any time in the determination of a type a cv-qualified function type is formed, the program is ill-formed. </p>\n</blockquote>\n<p>Here is that text for C++1x, <code>8.3.5/7</code> n2914:</p>\n<blockquote>\n<p id=\"so_1117873_1118283_1\">A cv-quali\ufb01er-seq shall only be part of the function type for a non-static member function, the function type to which a pointer to member refers, or the top-level function type of a function typedef declaration. The e\ufb00ect of a cv-quali\ufb01er-seq in a function declarator is not the same as adding cv-quali\ufb01cation on top of the function type. In the latter case, the cv-quali\ufb01ers are ignored. </p>\n</blockquote>\n<p>The above says that the below is valid, though, and creates the function type for a function that can declare a const member function. </p>\n<pre><code>typedef void Ft() const;\nstruct X { Ft cMemFn; };\nvoid X::cMemFn() const { }\n</code></pre>\n", "CreationDate": "2009-07-13T08:32:04.603", "LastEditDate": "2009-07-13T09:17:23.810", "ParentId": "1117873", "Id": "1118283", "LastEditorUserId": "34509", "PostTypeId": "2", "Score": "12", "OwnerUserId": "34509"}, "1117873": {"CreationDate": "2009-07-13T05:55:17.883", "ViewCount": "3471", "FavoriteCount": "2", "Id": "1117873", "AcceptedAnswerId": "1118283", "Score": "5", "Title": "pointer to const vs usual pointer (for functions)", "LastEditorUserId": "123111", "CommentCount": "0", "Body": "<p>Is there any difference between pointer to const and usual pointer for functions? When it is suitable to use const qualifier for stand alone functions?</p>\n<p>I wrote short sample to illustrate my question:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint sum( int x, int y ) { return x + y; }\ntypedef int sum_func( int, int );\n\nint main()\n{\n    const sum_func* sum_func_cptr = &amp;sum; // const function\n    sum_func* sum_func_ptr = &amp;sum;        // non-const function ?\n\n    // What is the difference between sum_func_cptr and sum_func_ptr\n\n    int x = sum_func_cptr( 2, 2 );\n    cout &lt;&lt; x &lt;&lt; endl;\n\n    int y = sum_func_ptr( 2, 2 );\n    cout &lt;&lt; y &lt;&lt; endl;\n\n    sum_func_cptr = 0;\n    sum_func_ptr = 0;\n\n    return 0;\n}</code></pre>\n<p>g++ gives no warnings. That's why I ask.</p>\n", "Tags": "<c++><function-pointers>", "LastEditDate": "2009-07-13T06:44:28.160", "LastActivityDate": "2009-07-15T13:12:55.180", "PostTypeId": "1", "AnswerCount": "5", "OwnerUserId": "123111"}, "bq_ids": {"n4140": {"so_1117873_1118283_1": {"length": 26, "quality": 0.7878787878787878, "section_id": 3242}, "so_1117873_1118283_0": {"length": 32, "quality": 0.7441860465116279, "section_id": 3242}}, "n3337": {"so_1117873_1118283_1": {"length": 27, "quality": 0.8181818181818182, "section_id": 3115}, "so_1117873_1118283_0": {"length": 33, "quality": 0.7674418604651163, "section_id": 3115}}}, "1117899": {"LastActivityDate": "2009-07-13T06:12:22.390", "CommentCount": "5", "Body": "<p>I think you meant,<br>\n<code>sum_func* const sum_func_cptr</code> instead of  <code>const sum_func* sum_func_cptr</code>.</br></p>\n<pre><code>sum_func* const sum_func_cptr = &amp;sum;\nsum_func* const sum_func_cptr = &amp;sum_new; // will not compile.\n// whereas,\nconst sum_func* sum_func_cptr = &amp;sum;  // will compile\nconst sum_func* sum_func_cptr = &amp;sum_new; // will compile.\nsum_func* sum_func_cptr = &amp;sum;  // will compile\nsum_func* sum_func_cptr = &amp;sum_new; // will compile.\n</code></pre>\n<p>-Jagannath.</p>\n", "CreationDate": "2009-07-13T06:09:21.163", "LastEditDate": "2009-07-13T06:12:22.390", "ParentId": "1117873", "Id": "1117899", "LastEditorUserId": "108130", "PostTypeId": "2", "Score": "1", "OwnerUserId": "124797"}, "1131317": {"CommentCount": "2", "Body": "<p>I think there has been a basic misunderstanding in the previous replies.</p>\n<pre><code>    const sum_func sum_func_cptr = &amp;Foo::sum; // const pointer\n</code></pre>\n<p>That means that <code>sum_func_cptr</code> is a constant pointer to a function, that is you can initialize it with a non-const member function, but you can't change it later to point to another function, because <code>const</code> refers to the variable.\nThat's equivalent to:</p>\n<pre><code>    sum_func const sum_func_cptr = &amp;Foo::sum; // const pointer\n</code></pre>\n<p>Don't you agree? :-)</p>\n<p>-Paolo</p>\n", "CreationDate": "2009-07-15T13:12:55.180", "ParentId": "1117873", "Id": "1131317", "LastActivityDate": "2009-07-15T13:12:55.180", "PostTypeId": "2", "Score": "0", "OwnerUserId": "138713"}});