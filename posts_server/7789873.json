post_cb({"bq_ids": {"n4140": {"so_7789873_7809890_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 3919}}, "n3337": {"so_7789873_7809890_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 3779}}, "n4659": {"so_7789873_7809890_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 4805}}}, "7809890": {"Id": "7809890", "PostTypeId": "2", "Body": "<p>The code will do what you expect.  See \u00a76.7.4</p>\n<p>static local variables are:</p>\n<blockquote>\n<p id=\"so_7789873_7809890_0\">... initialized the first time control passes over its declaration ...\n  If control enters the declaration concurrently while the variable is\n  being initialized, the concurrent execution shall wait for completion\n  of the initialization.</p>\n</blockquote>\n<p>In other words the compiler ensures your threads cooperate on the initialization of the static locals.  They will each be initialized once and each thread will only have access to the object after it's been fully initialized.</p>\n<p>The compiler will only create a thread local variable when explicitly requested with the <code>thread_local</code> keyword.</p>\n", "LastActivityDate": "2011-10-18T15:37:17.593", "CommentCount": "0", "CreationDate": "2011-10-18T15:37:17.593", "ParentId": "7789873", "Score": "8", "OwnerUserId": "28817"}, "7789873": {"ViewCount": "1467", "Body": "<p>I have the following bit of C++11 code that uses threads and static variable initialisations. My question is:</p>\n<p>What guarantees or assurances does the C++ language make about the single initialisation of static variables - the code below displays the correct values, however I can't seem to find the passage in the new standard that mentions how the memory model should interact with threads. When if ever do the variables become thread-local?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nclass theclass\n{\npublic:\n   theclass(const int&amp; n)\n   :n_(n)\n   { printf(\"aclass(const int&amp; n){}\\n\"); }\n   int n() const { return n_; } \nprivate:\n   int n_;\n};\n\nint operator+(const theclass&amp; c, int n)\n{\n   return c.n() + n;\n}\n\nvoid foo()\n{\n   static theclass x = 1;\n   static theclass y = x + 1;\n   printf(\"%d %d\\n\",x.n(),y.n());\n}\n\nint main()\n{\n   std::thread t1(&amp;foo);\n   std::thread t2(&amp;foo);\n   t1.join();\n   t2.join();\n   return 0; \n}\n</code></pre>\n", "Title": "C++ static variable inialization and threads", "CreationDate": "2011-10-17T05:56:07.623", "LastActivityDate": "2011-10-18T15:37:17.593", "CommentCount": "0", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2011-10-18T01:00:27.430", "LastEditorUserId": "755004", "Id": "7789873", "Score": "5", "OwnerUserId": "755004", "Tags": "<multithreading><initialization><c++11><static-members><memory-model>", "AnswerCount": "1"}});