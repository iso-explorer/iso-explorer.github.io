post_cb({"11581231": {"ParentId": "11581174", "CommentCount": "7", "Body": "<p>The proper way to do this would be to use <a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=/com.ibm.xlcpp8a.doc/language/ref/keyword_const_cast.htm\" rel=\"nofollow\">const_cast</a>.</p>\n<p>For example,</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid f(int* p) {\n  cout &lt;&lt; *p &lt;&lt; endl;\n}\n\nint main(void) {\n  const int a = 10;\n  const int* b = &amp;a;\n\n  // Function f() expects int*, not const int*\n  //   f(b);\n  int* c = const_cast&lt;int*&gt;(b);\n  f(c);\n\n  // Lvalue is const\n  //  *b = 20;\n\n  // Undefined behavior\n  //  *c = 30;\n\n  int a1 = 40;\n  const int* b1 = &amp;a1;\n  int* c1 = const_cast&lt;int*&gt;(b1);\n\n  // Integer a1, the object referred to by c1, has\n  // not been declared const\n  *c1 = 50;\n\n  return 0;\n}\n</code></pre>\n", "Id": "11581231", "PostTypeId": "2", "OwnerDisplayName": "user195488", "Score": "3", "CreationDate": "2012-07-20T14:18:48.420", "LastActivityDate": "2012-07-20T14:18:48.420"}, "11581174": {"CommentCount": "8", "ViewCount": "240", "PostTypeId": "1", "LastEditorUserId": "168175", "CreationDate": "2012-07-20T14:15:41.727", "LastActivityDate": "2012-07-20T15:33:38.093", "Title": "Why can I create cast operator to every class except self", "AcceptedAnswerId": "11582064", "LastEditDate": "2012-07-20T15:29:12.790", "Id": "11581174", "Score": "-3", "Body": "<pre><code>struct B \n{\n\n};\n\nstruct A\n{\n    operator A&amp;() const;\n    operator B&amp;() const;\n};\n\n\nint main()\n{\n    const A a;\n    B&amp; br = a;\n    A&amp; ar = a;  \n}\n</code></pre>\n<p>Why can I create cast operator to <code>B&amp;</code>, but not to <code>A&amp;</code>.</p>\n<p>May be it does not have much sense (one can use it to erase <code>const</code> modifier, as in example), but it at least inconsistent!</p>\n", "Tags": "<c++>", "OwnerUserId": "774651", "AnswerCount": "3"}, "11581937": {"ParentId": "11581174", "CommentCount": "0", "Body": "<p>Declaring a conversion to a reference to self is not ill-formed. Your problem comes at the time where your reference is initialized. As the type of the reference and the type of the initialization expression are the same, the reference is <code>bound directly</code> and your user defined conversion operator is never considered. Thus normal conversion rules apply and const conversion makes the code ill-formed.</p>\n<p>Anyway, what your are doing is basically asking yourself to get shot in the foot. If you don't like <code>constness</code>, <strong>don't use it</strong>. If you do it consistently, it will never bother you, but it is not going to make you new friends.</p>\n", "OwnerUserId": "105672", "PostTypeId": "2", "Id": "11581937", "Score": "3", "CreationDate": "2012-07-20T15:03:35.127", "LastActivityDate": "2012-07-20T15:03:35.127"}, "bq_ids": {"n4140": {"so_11581174_11582064_0": {"section_id": 391, "quality": 0.9772727272727273, "length": 43}, "so_11581174_11582064_1": {"section_id": 391, "quality": 0.6923076923076923, "length": 9}}, "n3337": {"so_11581174_11582064_0": {"section_id": 382, "quality": 0.9772727272727273, "length": 43}, "so_11581174_11582064_1": {"section_id": 382, "quality": 0.6923076923076923, "length": 9}}, "n4659": {"so_11581174_11582064_0": {"section_id": 408, "quality": 0.7954545454545454, "length": 35}, "so_11581174_11582064_1": {"section_id": 408, "quality": 0.6923076923076923, "length": 9}}}, "11582064": {"ParentId": "11581174", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can't do this because it's explicitly forbidden. N3290 \u00a7 12.3.2 states:</p>\n<blockquote>\n<p id=\"so_11581174_11582064_0\">Such functions are called\n  conversion functions. No return type can be specified. If a conversion function is a member function, the\n  type of the conversion function (8.3.5) is \u201cfunction taking no parameter returning conversion-type-id\u201d. <strong>A\n  conversion function is never used to convert a (possibly cv-qualified) object to the (possibly cv-qualified)\n  same object type (or a reference to it)</strong>, to a (possibly cv-qualified) base class of that type (or a reference to\n  it), or to (possibly cv-qualified) void.</p>\n</blockquote>\n<p>(Emphasis mine)</p>\n<p>This is discussed further in a note:</p>\n<blockquote>\n<p id=\"so_11581174_11582064_1\">These conversions are considered as standard conversions for the purposes of overload resolution (13.3.3.1, 13.3.3.1.4) and\n  therefore initialization (8.5) and explicit casts (5.2.9).</p>\n</blockquote>\n<p>Which explains this decision - it would interfere with the built-in mechanics too much. (For little gain).</p>\n<p>If you really want something non-<code>const</code> from a <code>const</code> object the only smart way to do this is constructing a new instance using the copy constructor.</p>\n<p>As a work around you could introduce a lightweight intermediary (like a smart pointer):</p>\n<pre><code>struct B {};\n\nstruct A {};\n\nnamespace {\n  B b_inst;\n  A a_inst;\n}\n\nstruct A_wrapper {\n  A&amp; inst;\n  // This is perfectly fine: const alters the reference, not what it refers to\n  operator A&amp;() const { return inst; }\n  operator B&amp;() const { return b_inst; }\n  A_wrapper() : inst(a_inst) {}\n};\n\nint main() {\n  const A_wrapper a;\n  B&amp; br = a;\n  A&amp; ar = a;\n}\n</code></pre>\n<p>But really, wanting to do this in the first place looks like a code smell.</p>\n", "OwnerUserId": "168175", "LastEditorUserId": "168175", "LastEditDate": "2012-07-20T15:33:38.093", "Id": "11582064", "Score": "4", "CreationDate": "2012-07-20T15:11:06.043", "LastActivityDate": "2012-07-20T15:33:38.093"}});