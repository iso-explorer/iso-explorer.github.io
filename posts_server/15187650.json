post_cb({"15188066": {"ParentId": "15187650", "CommentCount": "1", "Body": "<p>I think <a href=\"https://en.wikipedia.org/wiki/Dynamic_cast%20dynamic_cast\" rel=\"nofollow\"><code>dynamic_cast</code></a> is exactly what you want.</p>\n", "OwnerUserId": "1019990", "PostTypeId": "2", "Id": "15188066", "Score": "-1", "CreationDate": "2013-03-03T16:54:46.500", "LastActivityDate": "2013-03-03T16:54:46.500"}, "15188284": {"ParentId": "15187650", "CommentCount": "1", "Body": "<p>If you look at the specification for C-style casts in the C++ spec you'll find that cast notation is defined in terms of the other type conversion operators (<code>dynamic_cast</code>, <code>static_cast</code>, <code>reinterpret_cast</code>, <code>const_cast</code>), and in this case <code>reinterpret_cast</code> is used.</p>\n<p>Additionally, <code>reinterpret_cast</code> gives more guarantees than is indicated by the answer you link to. The one you care about is:</p>\n<blockquote>\n<p id=\"so_15187650_15188284_0\">\u00a7 9.2/20: A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa.</p>\n</blockquote>\n<p>If you want to use a cast notation I think using the C++ type conversion operators explicitly is best. However rather than littering casts all over the code you should probably write a function for each conversion (implemented using <code>reinterpret_cast</code>) and then use that.</p>\n<pre><code>derived_object *downcast_to_derived(base_object *b) {\n    return reinterpret_cast&lt;derived_object*&gt;(b);\n}\n</code></pre>\n", "OwnerUserId": "365496", "PostTypeId": "2", "Id": "15188284", "Score": "2", "CreationDate": "2013-03-03T17:13:45.407", "LastActivityDate": "2013-03-03T17:13:45.407"}, "15187650": {"CommentCount": "3", "ViewCount": "569", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-03-03T16:13:55.670", "LastActivityDate": "2013-03-03T17:24:10.023", "Title": "C++ casting for C-style downcasting", "AcceptedAnswerId": "15188284", "LastEditDate": "2017-05-23T12:21:31.850", "Id": "15187650", "Score": "2", "Body": "<p>When working with a C API that uses C-style inheritance, (taking advantage of the standard layout of C-structs), such as <a href=\"http://en.wikipedia.org/wiki/Glib\" rel=\"nofollow noreferrer\">GLib</a>, we usually use C-style casts to downcast:</p>\n<pre><code>struct base_object\n{\n    int x;\n    int y;\n    int z;\n};\n\nstruct derived_object\n{\n    base_object base;\n    int foo;\n    int bar;\n};\n\nvoid func(base_object* b)\n{\n    derived_object* d = (derived_object*) b; /* Downcast */\n}\n</code></pre>\n<p><br>\nBut if we're writing new C++ code that uses a C-API like this, should we continue to use C-style casts, or should we prefer C++ casts?  If the latter, what type of C++ casts should we use to emulate C downcasting?</br></p>\n<p>At first, I thought <code>reinterpret_cast</code> would be suitable:</p>\n<pre><code>derived_object* d = reinterpret_cast&lt;derived_object*&gt;(b);\n</code></pre>\n<p>However, I'm always wary of <code>reinterpret_cast</code> because the C++ standard <a href=\"https://stackoverflow.com/a/332086/469408\">guarantees very little</a> about what will happen.  It may be safer to use <code>static_cast</code> to <code>void*</code>:</p>\n<pre><code>derived_object* d = static_cast&lt;derived_object*&gt;(static_cast&lt;void*&gt;(b))\n</code></pre>\n<p>Of course, this is really cumbersome, making me think it's better to just use C-style casts in this case.</p>\n<p>So what is the best practice here?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "469408", "AnswerCount": "4"}, "15187771": {"ParentId": "15187650", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_15187650_15187771_0\">new C++ code that uses a C-API like this</p>\n</blockquote>\n<p>Don't write new C++ code in a C style, it doesn't make use of the C++ language features, and it also forces the user of your wrapper to use this same \"C\" style.  Instead, create a proper C++ class that wraps the C API interface details and hides them behind a C++ class.</p>\n<blockquote>\n<p id=\"so_15187650_15187771_1\">should we continue to use C-style casts</p>\n</blockquote>\n<p>No</p>\n<blockquote>\n<p id=\"so_15187650_15187771_2\">or should we prefer C++ casts</p>\n</blockquote>\n<p>Yes, but only when you have to.</p>\n<p>Use C++ inheritance and virtual accessor functions (probably).  Please show how you plan to use the derived object in func, this may provide a better answer for you.</p>\n<p>If func expects to use the methods of the derived object, then it should receive a derived object.  If it expects to use the methods of a base_object, but the methods are somehow changed because the pointer is to a derived_object, then virtual functions are the C++ way to do this.</p>\n<p>Also, you want to pass a reference to func, not a pointer.</p>\n<p>dynamic_cast, requires certain conditions to be met:</p>\n<p><a href=\"http://www.cplusplus.com/doc/tutorial/typecasting/\" rel=\"nofollow\">http://www.cplusplus.com/doc/tutorial/typecasting/</a></p>\n<p>If you are just converting struct ptrs to struct ptrs and you know what you want, then static_cast, or reinterpret_cast may be the best?</p>\n<p>However, if you truly are interested in writing C++ code, then the casts should be your last and final resort, since there are better patterns.  The two common situations I would consider casting are:</p>\n<ul>\n<li><p>You are interfacing with some event passing mechanism that passes a generic base class to an event handler.</p></li>\n<li><p>You have a container of objects.  The container requires it to contain homogenous types (i.e every element contains the same \"thing\"), but you want to store different types in the container.</p></li>\n</ul>\n", "OwnerUserId": "1131254", "LastEditorUserId": "1131254", "LastEditDate": "2013-03-03T17:24:10.023", "Id": "15187771", "Score": "2", "CreationDate": "2013-03-03T16:26:00.017", "LastActivityDate": "2013-03-03T17:24:10.023"}, "bq_ids": {"n4140": {"so_15187650_15188114_9": {"section_id": 6126, "quality": 0.9444444444444444, "length": 17}, "so_15187650_15188114_7": {"section_id": 6126, "quality": 1.0, "length": 8}}, "n3337": {"so_15187650_15188114_9": {"section_id": 5890, "quality": 0.9444444444444444, "length": 17}, "so_15187650_15188284_0": {"section_id": 5650, "quality": 0.95, "length": 19}, "so_15187650_15188114_7": {"section_id": 5890, "quality": 1.0, "length": 8}}, "n4659": {"so_15187650_15188114_9": {"section_id": 7623, "quality": 0.9444444444444444, "length": 17}, "so_15187650_15188114_7": {"section_id": 7623, "quality": 1.0, "length": 8}}}, "15188114": {"ParentId": "15187650", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_15187650_15188114_0\">However, I'm always wary of reinterpret_cast because the C++ standard\n  guarantees very little about what will happen.</p>\n</blockquote>\n<p>C++-style casts are no less safe than C-style casts, because C-style cast is defined in terms of C++-style casts.</p>\n<blockquote>\n<p id=\"so_15187650_15188114_1\">5.4.4 The conversions performed by</p>\n<p id=\"so_15187650_15188114_2\">\u2014 a const_cast (5.2.11),</p>\n<p id=\"so_15187650_15188114_3\">\u2014 a static_cast (5.2.9),</p>\n<p id=\"so_15187650_15188114_4\">\u2014 a static_cast followed by a const_cast,</p>\n<p id=\"so_15187650_15188114_5\">\u2014 a reinterpret_cast (5.2.10), or</p>\n<p id=\"so_15187650_15188114_6\">\u2014 a reinterpret_cast followed by a const_cast,</p>\n<p id=\"so_15187650_15188114_7\">can be performed using the cast notation of explicit type conversion.</p>\n<p id=\"so_15187650_15188114_8\">[...]</p>\n<p id=\"so_15187650_15188114_9\">If a conversion can be interpreted in more than one of the ways listed above, the interpretation that\n  appears \ufb01rst in the list is used, even if a cast resulting from that interpretation is ill-formed.</p>\n</blockquote>\n<p>The sad answer is that you can't avoid casts in code like you written, because the compiler knows very little about relations between classes. Some way or another, you may want to refactor it (casts or classes or the code that uses them).</p>\n<p>The bottom line is:</p>\n<p>If you can, use proper inheritance.</p>\n<p>If you can't, use reinterpret_cast.</p>\n", "OwnerUserId": "1012936", "LastEditorUserId": "1012936", "LastEditDate": "2013-03-03T17:14:47.957", "Id": "15188114", "Score": "2", "CreationDate": "2013-03-03T16:59:38.433", "LastActivityDate": "2013-03-03T17:14:47.957"}});