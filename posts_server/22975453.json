post_cb({"22975453": {"CommentCount": "0", "ViewCount": "401", "PostTypeId": "1", "LastEditorUserId": "166620", "CreationDate": "2014-04-09T22:53:03.057", "LastActivityDate": "2014-04-10T04:51:14.213", "Title": "What are the benefits and risks, if any, of using std::move with std::shared_ptr", "AcceptedAnswerId": "22975572", "LastEditDate": "2014-04-10T00:02:36.507", "Id": "22975453", "Score": "4", "Body": "<p>I am in the process of learning C++11 features and as part of that I am diving head first into the world of <code>unique_ptr</code> and <code>shared_ptr</code>.</p>\n<p>When I started, I wrote some code that used <code>unique_ptr</code> exclusively, and as such when I was passing my variables around I needed to accomplish that with <code>std::move</code> (or so I was made to understand).</p>\n<p>I realized after some effort that I really needed <code>shared_ptr</code> instead for what I was doing. A quick find/replace later and my pointers were switched over to shared but I lazily just left the <code>move()</code> calls in.</p>\n<p>To my surprise, not only did this compile, but it behaved perfectly well in my program and I got every ounce of functionality I was expecting... particularly, I was able to \"move\" a <code>shared_ptr</code> from ObjectA to ObjectB, and both objects had access to it and could manipulate it. Fantastic.</p>\n<p>This raised the question for me though... is the <code>move()</code> call actually doing anything at all now that I am on <code>shared_ptr</code>? And if so, what, and what are the ramifications of it?</p>\n<p>Code Example</p>\n<pre><code>shared_ptr&lt;Label&gt; lblLevel(new Label());\n\n//levelTest is shared_ptr&lt;Label&gt; declared in the interface of my class, undefined to this point\nlevelTest = lblLevel;\n\n//Configure my label with some redacted code\n\n//Pass the label off to a container which stores the shared_ptr in an std::list\n//That std::list is iterated through in the render phase, rendering text to screen\nthis-&gt;guiView.AddSubview(move(lblLevel));\n</code></pre>\n<p>At this point, I can make important changes to levelTest like changing the text, and those changes are reflected on screen.</p>\n<p>This to me makes it appear as though both <code>levelTest</code> and the shared_ptr in the list are the same pointer, and <code>move()</code> really hasn't done much. This is my amateur interpretation. Looking for insight. Using MinGW on Windows. </p>\n", "Tags": "<c++><c++11><shared-ptr><move-semantics><unique-ptr>", "OwnerUserId": "166620", "AnswerCount": "3"}, "22975575": {"ParentId": "22975453", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If you <em>copy</em> a shared_ptr, the reference count to the pointer target is incremented (in a thread-safe way).</p>\n<p>Instead, when you <em>move</em> a shared_ptr from A to B, B contains the copy of the state of A before the move, and A is empty. There was no thread-safe reference count increment/decrement, but some very simple and inexpensive pointer exchange between the internal bits of A and B.</p>\n<p>You can think of a move as an efficient way of <em>\"stealing resources\"</em> from the source of the move to the destination of the move.</p>\n", "OwnerUserId": "1629821", "LastEditorUserId": "1629821", "LastEditDate": "2014-04-09T23:09:35.793", "Id": "22975575", "Score": "2", "CreationDate": "2014-04-09T23:03:11.283", "LastActivityDate": "2014-04-09T23:09:35.793"}, "22978899": {"ParentId": "22975453", "CommentCount": "1", "Body": "<p>ecatmur's answer explains the why of things behaving as you're seeing in a general sense.</p>\n<p>Specifically to your case, <code>levelTest</code> is a <em>copy</em> of <code>lblTest</code> which creates an additional owning reference to the shared resource. You moved from <code>lblTest</code> so <code>levelTest</code> is completely unaffected and its ownership of the resource stays intact.</p>\n<p>If you looked at <code>lblTest</code> I'm sure you'd see that it's been set to an empty value. Because you made a copy of the <code>shared_ptr</code> before you moved from it, both of the existing live instances of the pointer (<code>levelTest</code> and the value in <code>guiView</code>) should reference the same underlying pointer (their <code>get</code> method returns the same value) and there should be at least two references (their <code>use_count</code> method should return <code>2</code>, or more if you made additional copies).</p>\n<p>The whole point of <code>shared_ptr</code> is to enable things like you're seeing while still allowing automatic cleanup of resources when all the <code>shared_ptr</code> instances are destructed.</p>\n", "OwnerUserId": "720860", "PostTypeId": "2", "Id": "22978899", "Score": "4", "CreationDate": "2014-04-10T04:51:14.213", "LastActivityDate": "2014-04-10T04:51:14.213"}, "bq_ids": {"n4140": {"so_22975453_22975572_0": {"section_id": 4399, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_22975453_22975572_0": {"section_id": 4236, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_22975453_22975572_0": {"section_id": 5664, "quality": 0.8333333333333334, "length": 5}}}, "22975572": {"ParentId": "22975453", "CommentCount": "8", "Body": "<p>When you move-construct or move-assign from a shared pointer of convertible type, the source pointer becomes empty, per 20.7.2.2.1:</p>\n<blockquote>\n<p id=\"so_22975453_22975572_0\">22 - <em>Postconditions</em>: <code>*this</code> shall contain the old value of <code>r</code>. <code>r</code> shall be <em>empty</em>. <code>r.get() == 0</code>.</p>\n</blockquote>\n<p>So if you are observing that the source pointer is still valid after a move-construct or move-assignment, then either your compiler is incorrect or you are using <code>std::move</code> incorrectly.</p>\n<p>For example:</p>\n<pre><code>std::shared_ptr&lt;int&gt; p = std::make_shared&lt;int&gt;(5);\nstd::shared_ptr&lt;int&gt; q = std::move(p);\nassert(p.get() == nullptr);\n</code></pre>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "22975572", "Score": "3", "CreationDate": "2014-04-09T23:02:49.813", "LastActivityDate": "2014-04-09T23:02:49.813"}});