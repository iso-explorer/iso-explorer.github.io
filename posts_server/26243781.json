post_cb({"26244105": {"ParentId": "26243781", "CommentCount": "0", "Body": "<p>The bit you're quoting covers the lookup of <code>S</code> in the expression <code>t.S::pure2()</code>. It doesn't apply to the name <code>pure2</code> at all.</p>\n<p>The relevant ruling here is 10.3/15:</p>\n<blockquote>\n<p id=\"so_26243781_26244105_0\">Explicit qualification with the scope operator (5.1) suppresses the virtual call mechanism. [ <em>Example:</em></p>\n<pre><code>class B { public: virtual void f(); };\nclass D : public B { public: void f(); };\nvoid D::f() { /* ... */ B::f(); }\n</code></pre>\n<p id=\"so_26243781_26244105_1\">Here, the function call in <code>D::f</code> really does call <code>B::f</code> and not <code>D::f</code>. <em>\u2014end example</em> ]</p>\n</blockquote>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "26244105", "Score": "2", "CreationDate": "2014-10-07T19:52:05.170", "LastActivityDate": "2014-10-07T19:52:05.170"}, "26243781": {"CommentCount": "3", "ViewCount": "131", "PostTypeId": "1", "LastEditorUserId": "1782465", "CreationDate": "2014-10-07T19:33:47.287", "LastActivityDate": "2014-10-07T19:53:52.103", "Title": "How does the Standard support this call of a pure virtual function in the base class S?", "LastEditDate": "2014-10-07T19:53:52.103", "Id": "26243781", "Score": "3", "Body": "<p>Consider this snippet:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct S {\n    virtual void pure1() = 0;\n    virtual void pure2() = 0;\n};\n\nstruct T : S {\n    void pure1() { std::cout &lt;&lt; \"T::pure1\" &lt;&lt; '\\n'; }\n    void pure2() { std::cout &lt;&lt; \"T::pure2\" &lt;&lt; '\\n'; }\n};\n\n\nvoid S::pure2() { std::cout &lt;&lt; \"S::pure2\" &lt;&lt; '\\n';}\n\nint main()\n{\n    T t;\n    t.S::pure2();\n}\n</code></pre>\n<p>It prints <code>S::pure2</code>.</p>\n<p>Looking at the C++11 Standard, I don't know exactly how does that happen. I believe it has to do with \u00a73.4.5/4:</p>\n<blockquote>\n<p id=\"so_26243781_26243781_0\">If the <em>id-expression</em> in a class member access is a <em>qualified-id</em> of\n  the form</p>\n<p id=\"so_26243781_26243781_1\">class-name-or-namespace-name::...</p>\n<p id=\"so_26243781_26243781_2\">the <em>class-name-or-namespace-name</em> following the . or -&gt; operator is first looked up in the class of the object expression and the name, if\n  found, is used. Otherwise it is looked up in the context of the entire\n  <em>postfix-expression</em>.</p>\n</blockquote>\n<p>But I don't understand how the pure virtual function <code>pure2()</code> is found in the base class <code>S</code> with the expression <code>t.S::pure2();</code> above.</p>\n", "Tags": "<c++><c++11><lookup><language-lawyer>", "OwnerUserId": "3694387", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_26243781_26244105_0": {"section_id": 7016, "quality": 0.8888888888888888, "length": 8}, "so_26243781_26243781_0": {"section_id": 7129, "quality": 1.0, "length": 6}, "so_26243781_26244000_1": {"section_id": 7019, "quality": 0.8679245283018868, "length": 46}, "so_26243781_26243781_2": {"section_id": 7129, "quality": 1.0, "length": 15}, "so_26243781_26244105_1": {"section_id": 7016, "quality": 0.75, "length": 6}}, "n3337": {"so_26243781_26244105_0": {"section_id": 6762, "quality": 0.8888888888888888, "length": 8}, "so_26243781_26243781_0": {"section_id": 5724, "quality": 1.0, "length": 6}, "so_26243781_26244000_1": {"section_id": 6765, "quality": 0.8679245283018868, "length": 46}, "so_26243781_26243781_2": {"section_id": 6873, "quality": 1.0, "length": 15}, "so_26243781_26244105_1": {"section_id": 6762, "quality": 0.75, "length": 6}}, "n4659": {"so_26243781_26244105_0": {"section_id": 8513, "quality": 0.8888888888888888, "length": 8}, "so_26243781_26243781_0": {"section_id": 8630, "quality": 1.0, "length": 6}, "so_26243781_26244000_1": {"section_id": 8516, "quality": 0.8679245283018868, "length": 46}, "so_26243781_26243781_2": {"section_id": 8630, "quality": 1.0, "length": 15}, "so_26243781_26244105_1": {"section_id": 8513, "quality": 0.75, "length": 6}}}, "26244000": {"ParentId": "26243781", "CommentCount": "4", "Body": "<p>It is OK for a pure virtual function to be implemented in the base class. The standard specifies that to be valid (emphasis mine):</p>\n<blockquote>\n<p id=\"so_26243781_26244000_0\"><strong>10.4 Abstract classes</strong></p>\n<p id=\"so_26243781_26244000_1\">2 An abstract class is a class that can be used only as a base class of some other class; no objects of an abstract class can be created except as subobjects of a class derived from it. A class is abstract if it has at least one pure virtual function. [ Note: Such a function might be inherited: see below. \u2014end note ] A virtual function is specified pure by using a pure-specifier (9.2) in the function declaration in the class definition. <strong>A pure virtual function need be defined only if called with, or as if with (12.4), the qualified-id syntax (5.1).</strong></p>\n</blockquote>\n<p>If you didn't call</p>\n<pre><code>t.S::pure2();\n</code></pre>\n<p>then, it will be OK to omit implementation of <code>S::pure2()</code>. It will be a link time error if you didn't implement <code>S::pure2()</code> but still called</p>\n<pre><code>t.S::pure2();\n</code></pre>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "26244000", "Score": "5", "CreationDate": "2014-10-07T19:46:24.040", "LastActivityDate": "2014-10-07T19:46:24.040"}});