post_cb({"bq_ids": {"n4140": {"so_26243781_26243781_2": {"length": 15, "quality": 1.0, "section_id": 7129}, "so_26243781_26244105_1": {"length": 6, "quality": 0.75, "section_id": 7016}, "so_26243781_26243781_0": {"length": 6, "quality": 1.0, "section_id": 7129}, "so_26243781_26244000_1": {"length": 49, "quality": 0.9245283018867925, "section_id": 7019}, "so_26243781_26244105_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 7016}}, "n3337": {"so_26243781_26244105_1": {"length": 6, "quality": 0.75, "section_id": 6762}, "so_26243781_26243781_2": {"length": 15, "quality": 1.0, "section_id": 6873}, "so_26243781_26244000_1": {"length": 49, "quality": 0.9245283018867925, "section_id": 6765}, "so_26243781_26244105_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 6762}, "so_26243781_26243781_0": {"length": 6, "quality": 1.0, "section_id": 5724}}, "n4659": {"so_26243781_26243781_2": {"length": 15, "quality": 1.0, "section_id": 8630}, "so_26243781_26244105_1": {"length": 6, "quality": 0.75, "section_id": 8513}, "so_26243781_26243781_0": {"length": 6, "quality": 1.0, "section_id": 8630}, "so_26243781_26244000_1": {"length": 49, "quality": 0.9245283018867925, "section_id": 8516}, "so_26243781_26244105_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 8513}}}, "26244105": {"Id": "26244105", "PostTypeId": "2", "Body": "<p>The bit you're quoting covers the lookup of <code>S</code> in the expression <code>t.S::pure2()</code>. It doesn't apply to the name <code>pure2</code> at all.</p>\n<p>The relevant ruling here is 10.3/15:</p>\n<blockquote>\n<p id=\"so_26243781_26244105_0\">Explicit qualification with the scope operator (5.1) suppresses the virtual call mechanism. [ <em>Example:</em></p>\n<pre><code>class B { public: virtual void f(); };\nclass D : public B { public: void f(); };\nvoid D::f() { /* ... */ B::f(); }\n</code></pre>\n<p id=\"so_26243781_26244105_1\">Here, the function call in <code>D::f</code> really does call <code>B::f</code> and not <code>D::f</code>. <em>\u2014end example</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2014-10-07T19:52:05.170", "CommentCount": "0", "CreationDate": "2014-10-07T19:52:05.170", "ParentId": "26243781", "Score": "2", "OwnerUserId": "1782465"}, "26243781": {"ViewCount": "131", "Body": "<p>Consider this snippet:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct S {\n    virtual void pure1() = 0;\n    virtual void pure2() = 0;\n};\n\nstruct T : S {\n    void pure1() { std::cout &lt;&lt; \"T::pure1\" &lt;&lt; '\\n'; }\n    void pure2() { std::cout &lt;&lt; \"T::pure2\" &lt;&lt; '\\n'; }\n};\n\n\nvoid S::pure2() { std::cout &lt;&lt; \"S::pure2\" &lt;&lt; '\\n';}\n\nint main()\n{\n    T t;\n    t.S::pure2();\n}\n</code></pre>\n<p>It prints <code>S::pure2</code>.</p>\n<p>Looking at the C++11 Standard, I don't know exactly how does that happen. I believe it has to do with \u00a73.4.5/4:</p>\n<blockquote>\n<p id=\"so_26243781_26243781_0\">If the <em>id-expression</em> in a class member access is a <em>qualified-id</em> of\n  the form</p>\n<p id=\"so_26243781_26243781_1\">class-name-or-namespace-name::...</p>\n<p id=\"so_26243781_26243781_2\">the <em>class-name-or-namespace-name</em> following the . or -&gt; operator is first looked up in the class of the object expression and the name, if\n  found, is used. Otherwise it is looked up in the context of the entire\n  <em>postfix-expression</em>.</p>\n</blockquote>\n<p>But I don't understand how the pure virtual function <code>pure2()</code> is found in the base class <code>S</code> with the expression <code>t.S::pure2();</code> above.</p>\n", "Title": "How does the Standard support this call of a pure virtual function in the base class S?", "CreationDate": "2014-10-07T19:33:47.287", "LastActivityDate": "2014-10-07T19:53:52.103", "CommentCount": "3", "LastEditDate": "2014-10-07T19:53:52.103", "PostTypeId": "1", "LastEditorUserId": "1782465", "Id": "26243781", "Score": "3", "OwnerUserId": "3694387", "Tags": "<c++><c++11><lookup><language-lawyer>", "AnswerCount": "2"}, "26244000": {"Id": "26244000", "PostTypeId": "2", "Body": "<p>It is OK for a pure virtual function to be implemented in the base class. The standard specifies that to be valid (emphasis mine):</p>\n<blockquote>\n<p id=\"so_26243781_26244000_0\"><strong>10.4 Abstract classes</strong></p>\n<p id=\"so_26243781_26244000_1\">2 An abstract class is a class that can be used only as a base class of some other class; no objects of an abstract class can be created except as subobjects of a class derived from it. A class is abstract if it has at least one pure virtual function. [ Note: Such a function might be inherited: see below. \u2014end note ] A virtual function is specified pure by using a pure-specifier (9.2) in the function declaration in the class definition. <strong>A pure virtual function need be defined only if called with, or as if with (12.4), the qualified-id syntax (5.1).</strong></p>\n</blockquote>\n<p>If you didn't call</p>\n<pre><code>t.S::pure2();\n</code></pre>\n<p>then, it will be OK to omit implementation of <code>S::pure2()</code>. It will be a link time error if you didn't implement <code>S::pure2()</code> but still called</p>\n<pre><code>t.S::pure2();\n</code></pre>\n", "LastActivityDate": "2014-10-07T19:46:24.040", "CommentCount": "4", "CreationDate": "2014-10-07T19:46:24.040", "ParentId": "26243781", "Score": "5", "OwnerUserId": "434551"}});