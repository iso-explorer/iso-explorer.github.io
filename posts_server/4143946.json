post_cb({"4144086": {"ParentId": "4143946", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes, it is UB for inline functions with external linkage (I think that's what the OP intends).</p>\n<p>$3.2/5- </p>\n<blockquote>\n<p id=\"so_4143946_4144086_0\">There can be more than one definition\n  of a class type (clause 9),\n  enumeration type (7.2), inline\n  function with external linkage\n  (7.1.2), class template (clause 14),\n  non-static function template (14.5.5),\n  static data member of a class template\n  (14.5.1.3), member function of a class\n  template (14.5.1.1), or template\n  specialization for which some template\n  parameters are not specified (14.7,\n  14.5.4) in a program provided that each definition appears in a different\n  translation unit, and provided the\n  definitions satisfy the following\n  requirements.</p>\n<p id=\"so_4143946_4144086_1\">Given such an entity named D defined\n  in more than one translation unit,\n  then </p>\n<p id=\"so_4143946_4144086_2\"><strong>\u2014 each definition of D shall\n  consist of the same sequence of\n  tokens; and</strong></p>\n</blockquote>\n<p>The same paragraph at the end states that failure to meet these requirements leads to UB</p>\n", "OwnerUserId": "418110", "LastEditorUserId": "418110", "LastEditDate": "2010-11-10T12:10:38.577", "Id": "4144086", "Score": "6", "CreationDate": "2010-11-10T11:41:14.023", "LastActivityDate": "2010-11-10T12:10:38.577"}, "bq_ids": {"n4140": {"so_4143946_4144086_1": {"section_id": 7043, "quality": 1.0, "length": 11}, "so_4143946_4144086_0": {"section_id": 7043, "quality": 0.8518518518518519, "length": 46}, "so_4143946_4144086_2": {"section_id": 7043, "quality": 1.0, "length": 6}}, "n3337": {"so_4143946_4144086_1": {"section_id": 6788, "quality": 1.0, "length": 11}, "so_4143946_4144086_0": {"section_id": 6788, "quality": 0.8518518518518519, "length": 46}, "so_4143946_4144086_2": {"section_id": 6788, "quality": 1.0, "length": 6}}, "n4659": {"so_4143946_4144086_1": {"section_id": 8540, "quality": 1.0, "length": 11}, "so_4143946_4144086_0": {"section_id": 8540, "quality": 0.8518518518518519, "length": 46}, "so_4143946_4144086_2": {"section_id": 8540, "quality": 1.0, "length": 6}}}, "4143946": {"CommentCount": "1", "ViewCount": "275", "CreationDate": "2010-11-10T11:25:01.247", "LastActivityDate": "2010-11-10T12:10:38.577", "Title": "How is a situation when different implementations of an inline function are linked into one executable classified?", "AcceptedAnswerId": "4144086", "PostTypeId": "1", "Id": "4143946", "Score": "7", "Body": "<p>According to One Definition Rule (ODR) I can't have a function</p>\n<pre><code>void function()\n{\n}\n</code></pre>\n<p>defined more than once in one executable - linker will object. However ODR is ignored for inline functions:</p>\n<pre><code>inline void function()\n{\n}\n</code></pre>\n<p>can be defined in a header file that will be #included into multiple .cpp files and so when resulting .obj files are linked together the linker sees that there're several instances of that function and intentionally ignores that. It <strong><em>assumes it is the very same function</em></strong> and just uses one of the instances. Since the program behavior is preserved noone cares.</p>\n<p>But if thanks to any reason, <a href=\"http://blogs.msdn.com/b/aszego/archive/2010/05/12/override-atlthrow-with-care.aspx\" rel=\"nofollow\">use of preprocessor included</a>, those instances happen to have different implementations the linker will again pick one of the functions and the developer won't even know which one is picked until he thoroughly tests his program.</p>\n<p>How is the latter situation when the linker picks one of the functions and they happen to have different implementations classified? Is this undefined behavior or any other kind of situation?</p>\n", "Tags": "<c++><compiler-construction><linker><inline>", "OwnerUserId": "57428", "AnswerCount": "1"}});