post_cb({"14407138": {"ParentId": "14407044", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Initializing with the return value from a non-<code>constexpr</code> function is dynamic initialization. Order of dynamic initialization is defined as follows (leaving out some details I think are irrelevant to your question):</p>\n<p>\u00a73.6.2/2: </p>\n<blockquote>\n<p id=\"so_14407044_14407138_0\">Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5) before any other initialization takes place.</p>\n</blockquote>\n<p>[...]</p>\n<blockquote>\n<p id=\"so_14407044_14407138_1\">Variables with ordered initialization defined within a single translation unit shall be initialized in the order of their definitions in the translation unit. If a program starts a thread (30.3), the subsequent initialization of a variable is unsequenced with respect to the initialization of a variable defined in a different translation unit. Otherwise, the initialization of a variable is indeterminately sequenced with respect to the initialization of a variable defined in a different translation unit.</p>\n</blockquote>\n<p>\u00a73.6.2/3: </p>\n<blockquote>\n<p id=\"so_14407044_14407138_2\">An implementation is permitted to perform the initialization of a non-local variable with static storage duration as a static initialization even if such initialization is not required to be done statically, provided that [Jerry's summary: it produces the same result as if it had been done dynamically.]</p>\n</blockquote>\n<p>\u00a73.6.2/4: </p>\n<blockquote>\n<p id=\"so_14407044_14407138_3\">It is implementation-defined whether the dynamic initialization of a non-local variable with static storage duration is done before the first statement of main. If the initialization is deferred to some point in time after the first statement of main, it shall occur before the first odr-use (3.2) of any function or variable defined in the same translation unit as the variable to be initialized</p>\n</blockquote>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2013-01-18T20:38:14.807", "Id": "14407138", "Score": "4", "CreationDate": "2013-01-18T20:32:06.517", "LastActivityDate": "2013-01-18T20:38:14.807"}, "14407077": {"ParentId": "14407044", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The language specification states that the initializing functions will be executed before <em>any</em> function from that translation unit is called or any object defined in that translation unit is accessed. So, in general case it really depends on how your definitions are spread across translation units.</p>\n<p>The initialization is carried out in top-to-bottom order, so, given your order of definitions, <code>bar_func</code> should see already initialized <code>foo</code>, but <code>foo_func</code> should see \"uninitialized\" (i.e. zero-initialized) <code>bar</code>.</p>\n<p>Note, that if your <code>main</code> resides in another translation unit, it means that the initialization does not have to happen before <code>main()</code>. Yet, if you attempt to access <code>foo</code> or <code>bar</code> from <code>main</code> (or from anywhere else), that should guarantee that the initialization process is triggered for the entire translation unit that defined these variables.</p>\n<p>Also, if your initializers are constant expressions (<code>constexpr</code> functions), then the whole initialization can be performed statically, which typically means that the variables will begin their lifetimes in already initialized (compile-time initialized) states.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2013-01-18T20:39:28.463", "Id": "14407077", "Score": "4", "CreationDate": "2013-01-18T20:27:31.143", "LastActivityDate": "2013-01-18T20:39:28.463"}, "bq_ids": {"n4140": {"so_14407044_14407138_0": {"section_id": 7151, "quality": 0.8666666666666667, "length": 13}, "so_14407044_14407138_3": {"section_id": 7153, "quality": 0.9714285714285714, "length": 34}, "so_14407044_14407138_2": {"section_id": 7152, "quality": 0.7777777777777778, "length": 21}, "so_14407044_14407138_1": {"section_id": 7151, "quality": 0.975, "length": 39}}, "n3337": {"so_14407044_14407138_0": {"section_id": 6895, "quality": 0.8666666666666667, "length": 13}, "so_14407044_14407138_3": {"section_id": 6897, "quality": 0.9714285714285714, "length": 34}, "so_14407044_14407138_2": {"section_id": 6896, "quality": 0.7777777777777778, "length": 21}, "so_14407044_14407138_1": {"section_id": 6895, "quality": 0.975, "length": 39}}, "n4659": {"so_14407044_14407138_0": {"section_id": 4051, "quality": 0.6, "length": 9}, "so_14407044_14407138_3": {"section_id": 8657, "quality": 0.6571428571428571, "length": 23}, "so_14407044_14407138_2": {"section_id": 8653, "quality": 0.7407407407407407, "length": 20}}}, "14407044": {"CommentCount": "1", "ViewCount": "80", "CreationDate": "2013-01-18T20:23:57.107", "LastActivityDate": "2013-01-18T20:39:28.463", "Title": "When exactly is a function used to initialize a global variable executed?", "AcceptedAnswerId": "14407077", "PostTypeId": "1", "Id": "14407044", "Score": "2", "Body": "<p>At the top of some file in my program, outside all functions, I have these variables:</p>\n<pre><code>namespace {\n  int foo = foo_func();\n}\n\nint bar = bar_func();\n</code></pre>\n<p>As you know, <code>foo</code> is a variable local only to that file, but <code>bar</code> is accessible to every file.</p>\n<p>...but question: When are the functions <code>foo_func()</code> and <code>bar_func()</code> actually run? Does this happen before <code>main()</code> runs, or possibly sometime later (say just before those values are actually needed)?</p>\n", "Tags": "<c++>", "OwnerUserId": "1859852", "AnswerCount": "2"}});