post_cb({"40176585": {"CommentCount": "1", "ViewCount": "167", "PostTypeId": "1", "LastEditorUserId": "2777063", "CreationDate": "2016-10-21T12:22:43.577", "LastActivityDate": "2016-10-21T13:01:35.247", "Title": "What is the deduced type of a constexpr?", "AcceptedAnswerId": "40177373", "LastEditDate": "2016-10-21T12:46:18.917", "Id": "40176585", "Score": "8", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nvoid foo(int&amp; k) { std::cout &lt;&lt; \"int&amp;\\n\"; }\nvoid foo(int&amp;&amp; k) { std::cout &lt;&lt; \"int&amp;&amp;\\n\"; }\nvoid foo(const int&amp; k) { std::cout &lt;&lt; \"const int&amp;\\n\"; }\nvoid foo(const int&amp;&amp; k) { std::cout &lt;&lt; \"const int&amp;&amp;\\n\"; }    \nint main() {\n  static  constexpr int k = 1;\n  foo(k);\n  foo(1);\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>const int&amp;\nint&amp;&amp;\n</code></pre>\n<p>What exactly is a constexpr variable treated as?\nThe overload for <code>foo</code> gives <code>const int&amp;</code>.</p>\n<p>Edit: Moving on with constexpr being deduced as <code>const T&amp;</code>;</p>\n<p><strong>Why does a constexpr at class scope fail to be passed to a function taking universal reference?!</strong></p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename T&gt;\nvoid goo(T&amp;&amp; k) {\n  static_assert(std::is_same&lt;decltype(k), const int&amp;&gt;::value, \"k is const int&amp;\");\n}\n\nclass F {\n  static  constexpr int k = 1;\npublic:\n  void kk2 () { goo(k); }\n};\n\nint main () {\n  F a;\n  a.kk2();\n}\n</code></pre>\n<p>The above fails to compile giving error <code>undefined reference to F::k</code>\nHowever the below passes:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename T&gt;\nvoid goo(T&amp;&amp; k) {\n  static_assert(std::is_same&lt;decltype(k), const int&amp;&gt;::value, \"k is const int&amp;\");\n}\n\nint main() {\n  static  constexpr int k = 1;\n  goo(k);\n}\n</code></pre>\n", "Tags": "<c++><c++11><templates><overloading><constexpr>", "OwnerUserId": "2777063", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_40176585_40176800_0": {"section_id": 5425, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_40176585_40176800_0": {"section_id": 5220, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_40176585_40176800_0": {"section_id": 6847, "quality": 0.7777777777777778, "length": 7}}}, "40177373": {"ParentId": "40176585", "CommentCount": "0", "Body": "<pre><code>foo(1);\n</code></pre>\n<p>In this case a temporary variable with the value <code>1</code> is passed to the function <code>foo</code>, hence non-const rvalue.</p>\n<pre><code>/*static*/ constexpr int k = 1;\nfoo(k);\n</code></pre>\n<p>Here a named const variable with the value <code>1</code> is passed to the function <code>foo</code>, hence const lvalue. The <code>static</code> keyword has no effect on a <code>constexpr</code> variable at function scope.</p>\n<blockquote>\n<p id=\"so_40176585_40177373_0\">What exactly is a constexpr variable treated as?</p>\n</blockquote>\n<p>When used in an expression that is not a constant expression, a <code>constexpr</code> variable is just a <code>const</code> variable.</p>\n<blockquote>\n<p id=\"so_40176585_40177373_1\">Why does a constexpr at class scope fail to be passed to a function taking universal reference?!</p>\n</blockquote>\n<p>You are getting a linker error because you odr-used the variable without defining it. You need a definition of <code>F::k</code> at namespace scope in exactly one translation unit, just like you did for <code>static const</code> member variables in C++98.</p>\n", "OwnerUserId": "1639256", "PostTypeId": "2", "Id": "40177373", "Score": "1", "CreationDate": "2016-10-21T13:01:35.247", "LastActivityDate": "2016-10-21T13:01:35.247"}, "40176800": {"ParentId": "40176585", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_40176585_40176800_0\"><code>N3337 [dcl.constexpr]/9:</code> A <code>constexpr</code> specifier used in an object declaration declares the object as <code>const</code>. [...]</p>\n</blockquote>\n<p>Since you declared <code>k</code> as <code>constexpr</code>, it is also declared as <code>const</code>, so the <code>const int&amp;</code> is selected in overload resolution. </p>\n", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "40176800", "Score": "2", "CreationDate": "2016-10-21T12:33:31.720", "LastActivityDate": "2016-10-21T12:33:31.720"}});