post_cb({"24943093": {"CommentCount": "18", "CreationDate": "2014-07-24T20:12:30.547", "PostTypeId": "1", "AcceptedAnswerId": "24943784", "LastEditorUserId": "3747990", "LastActivityDate": "2016-06-09T07:29:29.393", "LastEditDate": "2016-06-09T07:29:29.393", "ViewCount": "485", "FavoriteCount": "0", "Title": "Does `const &&` bind to all prvalues (and xvalues)?", "Id": "24943093", "Score": "5", "Body": "<p>The C++ standard defines the following functions deleted;</p>\n<pre><code>template &lt;class T&gt;\nvoid ref(const T&amp;&amp;) = delete;\n\ntemplate &lt;class T&gt;\nvoid cref(const T&amp;&amp;) = delete;\n</code></pre>\n<p>This is to aid in ensuring that the functions are not misused by disallowing them from binding to temporary values (rvalues).</p>\n<ul>\n<li>Does <code>const &amp;&amp;</code> bind to all rvalues, specifically prvalues?</li>\n<li>Would <code>const &amp;&amp;</code> bind to all \"moved objects\" (xvalues; basically something returned from <code>std::move</code> or similar)?</li>\n</ul>\n<p>I can reason that it should, but I don't have any \"proof\" for this.</p>\n<ul>\n<li>Or conversely, are there cases where an rvalue (prvalue or xvalue) will not bind to <code>const &amp;&amp;</code>?\n\n<ul>\n<li>If so, how so?</li>\n</ul></li>\n</ul>\n<p>Note: some clarity from the comments, this question is heavily swayed to classic rvalues, the prvalue value category. </p>\n", "Tags": "<c++><c++11><language-lawyer><rvalue-reference><rvalue>", "OwnerUserId": "3747990", "AnswerCount": "2"}, "24943784": {"ParentId": "24943093", "LastEditDate": "2014-07-24T21:46:06.993", "CommentCount": "1", "CreationDate": "2014-07-24T20:55:28.117", "OwnerUserId": "567292", "LastEditorUserId": "567292", "PostTypeId": "2", "Id": "24943784", "Score": "4", "Body": "<p><code>T const&amp;&amp;</code> can bind to rvalues of type <code>T</code> or <code>const T</code>.</p>\n<p>From 8.5.3 <strong>[dcl.init.ref]</strong> paragraph 5:</p>\n<blockquote>\n<p id=\"so_24943093_24943784_0\">5 - A reference to type \"cv1 T1\" is initialized by an expression of type \"cv2 T2\" as follows: [...]<br/>\n  \u2014 Otherwise, [...] the reference shall be an rvalue reference. [...]<br/>\n  \u2014 If the initializer expression <br/>\n  \u2014 is an xvalue, class prvalue, array prvalue or function lvalue and \"cv1 T1\" is reference-compatible with \"cv2 T2\" [...]\n  then the reference is bound to the value of the initializer expression [...]</p>\n</blockquote>\n<p>If the initializer expression is a prvalue of non-class type, then a temporary copy is created for reference binding (ibid).</p>\n<p>Reference-compatibility is defined in 8.5.3p4; it requires a same-or-base-class relationship and same-or-greater cv qualification.</p>\n<p>So for an rvalue to bind to <code>T const&amp;&amp;</code>, its cv-qualification must be no greater than <code>const</code>.</p>\n", "LastActivityDate": "2014-07-24T21:46:06.993"}, "24956188": {"ParentId": "24943093", "LastEditDate": "2014-10-05T19:31:19.790", "CommentCount": "1", "CreationDate": "2014-07-25T12:48:40.123", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "PostTypeId": "2", "Id": "24956188", "Score": "3", "Body": "<p>I want to add some empirical evidence here supporting the answer.</p>\n<pre><code>template &lt;class T&gt;\nvoid ref(T&amp;) {}\n\ntemplate &lt;class T&gt;\nvoid ref(volatile T&amp;) {}\n\ntemplate &lt;class T&gt;\nvoid ref(volatile const T&amp;) {}\n\ntemplate &lt;class T&gt;\nvoid ref(const T&amp;) {}\n\ntemplate &lt;class T&gt;\nvoid ref(const T&amp;&amp;) = delete;\n\n// xvalues\nint&amp;&amp; ax();\nconst int&amp;&amp; bx();\nvolatile int&amp;&amp; cx();\nvolatile const int&amp;&amp; dx();\n\n// prvalues\nint ap();\nconst int bp();\nvolatile int cp();\nvolatile const int dp();\n\nvoid test()\n{\n    ref(ax());\n    ref(bx());\n    ref(cx());\n    ref(dx());\n\n    ref(ap());\n    ref(bp());\n    ref(cp());\n    ref(dp());\n}\n</code></pre>\n<p>All the calls to <code>ref</code> in this case fail to compile, both xvalues and prvalues with the cv-qualified variations; msvc, <a href=\"http://coliru.stacked-crooked.com/a/fbde438e870f8461\" rel=\"nofollow\" title=\"Code sample\">gcc and clang</a> all fail the compilation with the appropriate \"attempting to reference a deleted function\" error.</p>\n", "LastActivityDate": "2014-10-05T19:31:19.790"}, "bq_ids": {"n4140": {"so_24943093_24943784_0": {"section_id": 3321, "quality": 0.8666666666666667, "length": 26}}, "n3337": {"so_24943093_24943784_0": {"section_id": 3191, "quality": 0.8666666666666667, "length": 26}}, "n4659": {"so_24943093_24943784_0": {"section_id": 4087, "quality": 0.6666666666666666, "length": 20}}}});