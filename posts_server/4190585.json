post_cb({"4190689": {"ParentId": "4190585", "CommentCount": "1", "CreationDate": "2010-11-16T02:31:29.937", "OwnerUserId": "418110", "PostTypeId": "2", "Id": "4190689", "Score": "2", "Body": "<p>You are attempting to declare a copy constructor. However it is not correct.</p>\n<p>A copy constructor is declared as per the below quote from the Standard</p>\n<blockquote>\n<p id=\"so_4190585_4190689_0\">$12.8/2 - \"A non-template constructor\n  for class X is a copy constructor if\n  its first parameter is of type X&amp;,\n  const X&amp;, volatile X&amp; or const\n  volatile X&amp;, and either there are no\n  other parameters or else all other\n  parameters have default arguments\n  (8.3.6).\"</p>\n</blockquote>\n<p>The parameter of the 'supposed to be copy constructor' has type 'pointer to reference'. This is disallowed by the Standard as per the quote below</p>\n<blockquote>\n<p id=\"so_4190585_4190689_1\">$8.3.2/5- \"There shall be no\n  references to references, no arrays of\n  references, and no pointers to\n  references.\"</p>\n</blockquote>\n", "LastActivityDate": "2010-11-16T02:31:29.937"}, "4190585": {"CommentCount": "0", "ViewCount": "2146", "PostTypeId": "1", "LastEditorUserId": "223391", "CreationDate": "2010-11-16T02:05:23.067", "LastActivityDate": "2011-05-05T12:47:45.500", "Title": "cannot declare pointer to \u2018const class FOO&\u2019 error", "LastEditDate": "2010-11-16T02:13:32.690", "Id": "4190585", "Score": "2", "Body": "<p>I can't understand why my compiler is giving me these errors:</p>\n<pre><code>brain.cpp:16: error: cannot declare pointer to \u2018const class FACT&amp;\u2019\nbrain.cpp: In constructor \u2018FACT::FACT(const FACT*)\u2019:\nbrain.cpp:20: error: cannot convert \u2018FACT**\u2019 to \u2018FACT*\u2019 in assignment\nbrain.cpp: In member function \u2018void FACT::AddRelation(FACT*)\u2019:\nbrain.cpp:29: error: expected type-specifier before \u2018*\u2019 token\nbrain.cpp:29: error: cannot convert \u2018int**\u2019 to \u2018FACT*\u2019 in initialization\nbrain.cpp:29: error: expected \u2018,\u2019 or \u2018;\u2019 before \u2018FACT\u2019\nbrain.cpp:35: error: expected type-specifier before \u2018*\u2019 token\nbrain.cpp:35: error: cannot convert \u2018int**\u2019 to \u2018FACT*\u2019 in assignment\nbrain.cpp:35: error: expected \u2018;\u2019 before \u2018FACT\u2019\nbrain.cpp: At global scope:\nbrain.cpp:47: error: expected unqualified-id before \u2018=\u2019 token\nbrain.cpp:48: error: expected type-specifier before \u2018*\u2019 token\nbrain.cpp:48: error: cannot convert \u2018int**\u2019 to \u2018FACT*\u2019 in initialization\nbrain.cpp:48: error: expected \u2018,\u2019 or \u2018;\u2019 before \u2018FACT\u2019\nbrain.cpp: In function \u2018void AddFact(FACT*)\u2019:\nbrain.cpp:52: error: cannot convert \u2018FACT**\u2019 to \u2018FACT*\u2019 in initialization\nbrain.cpp:58: error: expected type-specifier before \u2018*\u2019 token\nbrain.cpp:58: error: cannot convert \u2018int**\u2019 to \u2018FACT*\u2019 in assignment\nbrain.cpp:58: error: expected \u2018;\u2019 before \u2018FACT\u2019`\n</code></pre>\n<hr>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass FACT\n{\n    public:\n        FACT(string f)\n        {\n            fact=f;\n            relations=NULL;\n            num_relations=0;\n        };\n        ~FACT()\n        {\n            delete[] relations;\n        };\n        FACT(const FACT&amp; *copy)\n        {\n            num_relations=copy-&gt;num_relations;\n            delete[] relations;\n            relations=new FACT*[num_relations];\n            for (int x=0; x&lt;=num_relations; x++)\n            {\n                relations[x]=copy-&gt;relations[x];\n            }\n            fact=copy-&gt;fact;\n        };\n        void AddRelation(FACT *fact)\n        {\n            FACT *copy=new *FACT[num_relations];\n            for (int x=0; x&lt;=num_relations; x++)\n            {\n                copy[x]=relations[x];\n            }\n            delete[] relations;\n            relations=new *FACT[num_relations+1];\n            for (int x=0; x&lt;=num_relations; x++)\n            {\n                relations[x]=copy[x];\n            }\n            relations[num_relations+1]=fact;\n            num_relations++;\n        };\n        string fact;\n        FACT *relations;\n        int num_relations;\n};\nFACT *facts=new *FACT[0];\nint num_facts=0;\nvoid AddFact(FACT *new_item)\n{\n    FACT *copy=new FACT*[num_facts];\n    for (int x=0; x&lt;=num_facts; x++)\n    {\n        copy[x]=facts[x];\n    }\n    delete[] facts;\n    facts=new *FACT[num_facts+1];\n    for (int x=0; x&lt;=num_facts; x++)\n    {\n        facts[x]=copy[x];\n    }\n    delete[] copy;\n    num_facts++;\n    facts[num_facts]=new_item;\n}\nint main()\n{\n    FACT *new_item=new FACT(\"linux is secure\");\n    AddFact(new_item);\n    delete[] facts;\n    return 0;\n}\n</code></pre>\n<p>I'm using g++ 4.4.3 I can't understand why it doesn't consider \"FACT\" to be a data type</p>\n</hr>", "Tags": "<c++><pointers><object>", "OwnerUserId": "424568", "AnswerCount": "4"}, "4190605": {"ParentId": "4190585", "CommentCount": "0", "CreationDate": "2010-11-16T02:09:54.610", "OwnerUserId": "1053", "PostTypeId": "2", "Id": "4190605", "Score": "1", "Body": "<p>Well, your first error is here:</p>\n<pre><code>FACT(const FACT&amp; *copy)\n</code></pre>\n<p>Can't do that, you want a reference</p>\n<pre><code>FACT(const FACT&amp; copy)\n</code></pre>\n", "LastActivityDate": "2010-11-16T02:09:54.610"}, "5897668": {"ParentId": "4190585", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-05-05T12:31:18.397", "Score": "1", "LastEditorUserId": "466339", "LastEditDate": "2011-05-05T12:47:45.500", "Id": "5897668", "OwnerUserId": "466339", "Body": "<p>Hey, people. It is not all the truth.</p>\n<p>Of course @noah can't declare </p>\n<blockquote>\n<p id=\"so_4190585_5897668_0\">a pointer to a reference</p>\n</blockquote>\n<p>but the inverse, a reference to a pointer, is allowed.</p>\n<pre><code>FACT(const FACT *&amp;copy)\n</code></pre>\n<p>is a valid syntax and very useful in some situations. Although, it is still a wrong copy constructor.</p>\n<p>There are couples of good pages teaching this:</p>\n<p><a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Fcplr390.htm\" rel=\"nofollow\">http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Fcplr390.htm</a>\nhttp://www.fredosaurus.com/notes-cpp/oop-condestructors/copyconstructors.html\n<a href=\"http://cplus.about.com/od/learning1/ss/constructors.htm\" rel=\"nofollow\">http://cplus.about.com/od/learning1/ss/constructors.htm</a></p>\n", "LastActivityDate": "2011-05-05T12:47:45.500"}, "4190600": {"ParentId": "4190585", "CommentCount": "2", "CreationDate": "2010-11-16T02:08:43.577", "OwnerUserId": "56338", "PostTypeId": "2", "Id": "4190600", "Score": "4", "Body": "<p>You can't declare a pointer to a reference, like you try to do here:</p>\n<pre><code>FACT(const FACT&amp; *copy)\n</code></pre>\n<p>There is no such thing as pointers to a reference. Probably you just wanted a reference, without a pointer:</p>\n<pre><code>FACT(const FACT&amp; copy)\n</code></pre>\n", "LastActivityDate": "2010-11-16T02:08:43.577"}, "bq_ids": {"n4140": {"so_4190585_4190689_1": {"section_id": 3222, "quality": 0.875, "length": 7}, "so_4190585_4190689_0": {"section_id": 451, "quality": 0.9230769230769231, "length": 24}}, "n3337": {"so_4190585_4190689_1": {"section_id": 3096, "quality": 0.875, "length": 7}, "so_4190585_4190689_0": {"section_id": 442, "quality": 0.9230769230769231, "length": 24}}, "n4659": {"so_4190585_4190689_1": {"section_id": 3979, "quality": 0.875, "length": 7}, "so_4190585_4190689_0": {"section_id": 474, "quality": 0.9230769230769231, "length": 24}}}});