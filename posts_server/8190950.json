post_cb({"8190950": {"CommentCount": "7", "AcceptedAnswerId": "8191356", "CreationDate": "2011-11-19T00:45:02.590", "LastActivityDate": "2012-12-28T22:36:13.767", "PostTypeId": "1", "ViewCount": "2770", "FavoriteCount": "9", "Title": "May std::vector make use of small buffer optimization?", "Id": "8190950", "Score": "43", "Body": "<p>I was wondering with my colleague today whether std::vector can be implemented to make use of small buffer optimization. By looking into the C++11 draft, I read at 23.3.1p8 </p>\n<blockquote>\n<p id=\"so_8190950_8190950_0\">The expression a.swap(b), for containers a and b of a standard container type other than array, shall exchange the values of a and b without invoking any move, copy, or swap operations on the individual container elements. </p>\n</blockquote>\n<p>That at first seems to outlaw small buffer optimization, but under the as-if rule, we would be allowed to still do small buffer optimization for non-class types (since we cannot observe the copy being done). The next text appears to be harder to \"fool\"</p>\n<blockquote>\n<p id=\"so_8190950_8190950_1\">Every iterator referring to an element in one container before the swap shall refer to the same element in the other container after the swap. </p>\n</blockquote>\n<p>Is this sufficient to prevent implementing the small buffer optimization for std::vector? Are there any other road-blocks or is it eventually possible to have a std::vector with SBO?</p>\n", "Tags": "<c++><c++11><stdvector>", "OwnerUserId": "34509", "AnswerCount": "2"}, "14076648": {"ParentId": "8190950", "CommentCount": "2", "Body": "<p>In addition to the problem with iterator invalidation, there's a security argument for avoiding the small buffer optimization.</p>\n<p>If writes overrun a <code>std::vector</code>, you get heap corruption, which is quite difficult to predict what gets overwritten and very difficult to leverage for arbitrary code execution.</p>\n<p>If the buffer is instead embedded in a local variable, an overrun trashes the stack and the attacker will probably gain control over the return address, which is far more useful (return-to-libc attacks, for example).</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "14076648", "Score": "1", "CreationDate": "2012-12-28T22:36:13.767", "LastActivityDate": "2012-12-28T22:36:13.767"}, "bq_ids": {"n4140": {"so_8190950_8191356_2": {"section_id": 1567, "quality": 0.6428571428571429, "length": 9}, "so_8190950_8190950_0": {"section_id": 710, "quality": 0.9473684210526315, "length": 18}, "so_8190950_8191356_1": {"section_id": 1567, "quality": 1.0, "length": 13}, "so_8190950_8190950_1": {"section_id": 710, "quality": 1.0, "length": 15}}, "n3337": {"so_8190950_8191356_2": {"section_id": 1562, "quality": 0.6428571428571429, "length": 9}, "so_8190950_8190950_0": {"section_id": 699, "quality": 0.9473684210526315, "length": 18}, "so_8190950_8191356_1": {"section_id": 1562, "quality": 1.0, "length": 13}, "so_8190950_8190950_1": {"section_id": 699, "quality": 1.0, "length": 15}}, "n4659": {"so_8190950_8191356_2": {"section_id": 1716, "quality": 0.6428571428571429, "length": 9}, "so_8190950_8190950_0": {"section_id": 739, "quality": 0.9473684210526315, "length": 18}, "so_8190950_8191356_1": {"section_id": 1716, "quality": 1.0, "length": 13}, "so_8190950_8190950_1": {"section_id": 739, "quality": 1.0, "length": 15}}}, "8191356": {"ParentId": "8190950", "CommentCount": "3", "Body": "<p>23.2.1 / p10 / b6:</p>\n<blockquote>\n<p id=\"so_8190950_8191356_0\">Unless otherwise specified ...</p>\n<ul>\n<li>no swap() function invalidates any references, pointers, or iterators referring to the elements of the containers being swapped.\n  ...</li>\n</ul>\n</blockquote>\n<p>Nowhere does it \"specify otherwise\" for <code>vector</code>.  So this outlaws the SBO for <code>vector</code>.</p>\n<p><code>string</code> is not bound by this rule because it does \"specify otherwise\" in 21.4.1/p6:</p>\n<blockquote>\n<p id=\"so_8190950_8191356_1\">References, pointers, and iterators referring to the elements of a\n  basic_string sequence may be invalidated by the following uses of that\n  basic_string object:</p>\n<ul>\n<li>as an argument to any standard library function taking a reference to non-const basic_string as an argument.^234</li>\n</ul>\n<p id=\"so_8190950_8191356_2\">234) For example, as an argument to non-member functions swap()\n  (21.4.8.8), operator&gt;&gt;() (21.4.8.9), and getline() (21.4.8.9), or as\n  an argument to basic_string::swap()</p>\n</blockquote>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "8191356", "Score": "40", "CreationDate": "2011-11-19T02:14:40.017", "LastActivityDate": "2011-11-19T02:14:40.017"}});