post_cb({"27633297": {"CommentCount": "0", "AcceptedAnswerId": "27633488", "PostTypeId": "1", "LastEditorUserId": "1932452", "CreationDate": "2014-12-24T07:36:52.520", "LastActivityDate": "2014-12-25T06:50:56.863", "LastEditDate": "2014-12-25T06:50:56.863", "ViewCount": "502", "FavoriteCount": "5", "Title": "Can we use the return value optimization when possible and fall back on move, not copy, semantics when not?", "Id": "27633297", "Score": "7", "Body": "<p>Is it possible to write C++ code where we rely on the return value optimization (RVO) when possible, but fall back on move semantics when not?  For example, the following code can not use the RVO due to the conditional, so it copies the result back:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo {\n    Foo() {\n        std::cout &lt;&lt; \"constructor\" &lt;&lt; std::endl;\n    }\n    Foo(Foo &amp;&amp; x) {\n        std::cout &lt;&lt; \"move\" &lt;&lt; std::endl;\n    }\n    Foo(Foo const &amp; x) {\n        std::cout &lt;&lt; \"copy\" &lt;&lt; std::endl;\n    }\n    ~Foo() {\n        std::cout &lt;&lt; \"destructor\" &lt;&lt; std::endl;\n    }\n};\n\nFoo f(bool b) {\n    Foo x;\n    Foo y;\n    return b ? x : y;  \n}\n\nint main() {\n   Foo x(f(true));\n   std::cout &lt;&lt; \"fin\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This yields</p>\n<pre><code>constructor\nconstructor\ncopy\ndestructor\ndestructor\nfin\ndestructor\n</code></pre>\n<p>which makes sense.  Now, I could force the move constructor to be called in the above code by changing the line</p>\n<pre><code>    return b ? x : y;  \n</code></pre>\n<p>to</p>\n<pre><code>    return std::move(b ? x : y);\n</code></pre>\n<p>This gives the output</p>\n<pre><code>constructor\nconstructor\nmove\ndestructor\ndestructor\nfin\ndestructor\n</code></pre>\n<p>However, I don't really like to call std::move directly.</p>\n<p>Really, the issue is that I'm in a situation where I absolutely, positively, can not call the copy constructor even when the constructor exists.  In my use case, there's too much memory to copy and although it'd be nice to just delete the copy constructor, it's not an option for a variety of reasons.  At the same time, I'd like to return these objects from a function and would prefer to use the RVO.  Now, I don't really want to have to remember all of the nuances of the RVO when coding and when it's applied an when it's not applied.  Mostly, I want the object to be returned and I don't want the copy constructor called.  Certainly, the RVO is better, but the move semantics are fine.  Is there a way to the RVO when possible and the move semantics when not?</p>\n<hr>\n<h2>Edit 1</h2>\n<p>The following <a href=\"https://stackoverflow.com/questions/11914691/copy-elision-move-constructor-not-called-when-using-ternary-expression-in-retur\">question</a> helped me figure out what's going on.  Basically, 12.8.32 of the standard states:</p>\n<blockquote>\n<p id=\"so_27633297_27633297_0\">When the criteria for elision of a copy operation are met or would be\n  met save for the fact that the source object is a function parameter,\n  and the object to be copied is designated by an lvalue, overload\n  resolution to select the constructor for the copy is first performed\n  as if the object were designated by an rvalue. If overload resolution\n  fails, or if the type of the first parameter of the selected\n  constructor is not an rvalue reference to the object\u2019s type (possibly\n  cv-qualified), overload resolution is performed again, considering the\n  object as an lvalue. [ Note: This two-stage overload resolution must\n  be performed regardless of whether copy elision will occur. It\n  determines the constructor to be called if elision is not performed,\n  and the selected constructor must be accessible even if the call is\n  elided. \u2014end note ]</p>\n</blockquote>\n<p>Alright, so to figure out what the criteria for a copy elison are, we look at 12.8.31</p>\n<blockquote>\n<p id=\"so_27633297_27633297_1\">in a return statement in a function with a class return type, when the\n  expression is the name of a non-volatile automatic object (other than\n  a function or catch-clause parameter) with the same cvunqualified type\n  as the function return type, the copy/move operation can be omitted by\n  constructing the automatic object directly into the function\u2019s return\n  value</p>\n</blockquote>\n<p>As such, if we define the code for f as:</p>\n<pre><code>Foo f(bool b) {\n    Foo x;\n    Foo y;\n    if(b) return x;\n    return y;\n}\n</code></pre>\n<p>Then, each of our return values is an automatic object, so 12.8.31 says that it qualifies for copy elison.  That kicks over to 12.8.32 which says that the copy is performed as if it were an rvalue.  Now, the RVO doesn't happen because we don't know a priori which path to take, but the move constructor is called due to the requirements in 12.8.32.  Technically, one move constructor is avoided when copying into x.  Basically, when running, we get:</p>\n<pre><code>constructor\nconstructor\nmove\ndestructor\ndestructor\nfin\ndestructor\n</code></pre>\n<p>Turning off elide on constructors generates:</p>\n<pre><code>constructor\nconstructor\nmove\ndestructor\ndestructor\nmove\ndestructor\nfin\ndestructor\n</code></pre>\n<p>Now, say we go back to</p>\n<pre><code>Foo f(bool b) {\n    Foo x;\n    Foo y;\n    return b ? x : y;\n}\n</code></pre>\n<p>We have to look at the semantics for the conditional operator in 5.16.4</p>\n<blockquote>\n<p id=\"so_27633297_27633297_2\">If the second and third operands are glvalues of the same value\n  category and have the same type, the result is of that type and value\n  category and it is a bit-field if the second or the third operand is a\n  bit-field, or if both are bit-fields.</p>\n</blockquote>\n<p>Since both x and y are lvalues, the conditional operator is an lvalue, but not an automatic object.  Therefore, 12.8.32 doesn't kick in and we treat the return value as an lvalue and not an rvalue.  This requires that the copy constructor be called.  Hence, we get</p>\n<pre><code>constructor\nconstructor\ncopy\ndestructor\ndestructor\nfin\ndestructor\n</code></pre>\n<p>Now, since the conditional operator in this case is basically copying out the value category, that means that the code</p>\n<pre><code>Foo f(bool b) {\n    return b ? Foo() : Foo();\n}\n</code></pre>\n<p>will return an rvalue because both branches of the conditional operator are rvalues.  We see this with:</p>\n<pre><code>constructor\nfin\ndestructor\n</code></pre>\n<p>If we turning off elide on constructors, we see the moves</p>\n<pre><code>constructor\nmove\ndestructor\nmove\ndestructor\nfin\ndestructor\n</code></pre>\n<p>Basically, the idea is that if we return an rvalue we'll call the move constructor.  If we return an lvalue, we'll call the copy constructor.  When we return a non-volatile automatic object whose type matches that of the return type, we return an rvalue.  If we have a decent compiler, these copies and moves may be elided with the RVO.  However, at the very least, we know what constructor is called in case the RVO can't be applied.</p>\n</hr>", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "1932452", "AnswerCount": "2"}, "27633488": {"ParentId": "27633297", "CommentCount": "0", "Body": "<p>When the expression in the return statement is a non-volatile automatic duration object, and not a function or catch-clause parameter, with the same cv-unqualified type as the function return type, the resulting copy/move is eligible for copy elision. The standard also goes on to say that, if the only reason copy elision was forbidden was that the source object was a function parameter, and if the compiler is unable to elide a copy, the overload resolution for the copy should be done as if the expression was an rvalue. Thus, it would prefer the move constructor.</p>\n<p>OTOH, since you are using the ternary expression, none of the conditions hold and you are stuck with a regular copy. Changing your code to </p>\n<pre><code>if(b)\n  return x;\nreturn y;\n</code></pre>\n<p>calls the move constructor.</p>\n<p>Note that there is a distinction between RVO and copy elision - copy elision is what the standard allows, while RVO is a technique commonly used to elide copies in a subset of the cases where the standard allows copy elision.</p>\n", "OwnerUserId": "862351", "PostTypeId": "2", "Id": "27633488", "Score": "10", "CreationDate": "2014-12-24T07:52:50.470", "LastActivityDate": "2014-12-24T07:52:50.470"}, "27633460": {"ParentId": "27633297", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, there is.  Don't return the result of a ternary operator; use <code>if</code>/<code>else</code> instead. When you return a local variable directly, <a href=\"https://stackoverflow.com/q/9532608/501250\">move semantics are used when possible</a>. However, in your case you're not returning a local directly -- you're returning the result of an expression.</p>\n<p>If you change your function to read like this:</p>\n<pre><code>Foo f(bool b) {\n    Foo x;\n    Foo y;\n    if (b) { return x; }\n    return y;\n}\n</code></pre>\n<p>Then you should note that <a href=\"http://ideone.com/0eV9NS\" rel=\"nofollow noreferrer\">your move constructor is called instead of your copy constructor</a>.</p>\n<p>If you stick to returning a single local value per return statement then move semantics will be used if supported by the type.</p>\n<p>If you don't like this approach then I would suggest that you stick with <code>std::move</code>. You may not like it, but you have to pick your poison -- the language is the way that it is.</p>\n", "OwnerUserId": "501250", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:16.147", "Id": "27633460", "Score": "6", "CreationDate": "2014-12-24T07:51:08.040", "LastActivityDate": "2014-12-24T07:51:08.040"}, "bq_ids": {"n4140": {"so_27633297_27633297_1": {"section_id": 480, "quality": 1.0, "length": 35}, "so_27633297_27633297_2": {"section_id": 6170, "quality": 1.0, "length": 21}, "so_27633297_27633297_0": {"section_id": 481, "quality": 0.8311688311688312, "length": 64}}, "n3337": {"so_27633297_27633297_1": {"section_id": 471, "quality": 1.0, "length": 35}, "so_27633297_27633297_2": {"section_id": 5931, "quality": 1.0, "length": 21}, "so_27633297_27633297_0": {"section_id": 472, "quality": 0.948051948051948, "length": 73}}, "n4659": {"so_27633297_27633297_1": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}, "so_27633297_27633297_2": {"section_id": 7668, "quality": 1.0, "length": 21}, "so_27633297_27633297_0": {"section_id": 504, "quality": 0.7792207792207793, "length": 60}}}});