post_cb({"17834838": {"CommentCount": "6", "AcceptedAnswerId": "17835094", "PostTypeId": "1", "LastEditorUserId": "2149111", "CreationDate": "2013-07-24T13:02:43.350", "LastActivityDate": "2017-09-06T13:25:52.887", "LastEditDate": "2013-07-24T14:03:17.483", "ViewCount": "3379", "FavoriteCount": "3", "Title": "3-byte int and 5-byte long?", "Id": "17834838", "Score": "9", "Body": "<p>Does each of C and C++ standards allow <code>sizeof</code> of numeric types <em>not</em> to be a power of two?</p>\n<p>The following constraints are known: </p>\n<ul>\n<li><code>16 &lt;= CHAR_BIT * sizeof(int) &lt;=  CHAR_BIT * sizeof(long)</code></li>\n<li><code>32  &lt;=  CHAR_BIT * sizeof(long) &lt;= CHAR_BIT * sizeof(long long)</code> </li>\n<li>and a dozen of others, which on a typical 8-bit byte architecture means <code>2 &lt;= sizeof(int) &amp;&amp; 4 &lt;= sizeof(long)</code></li>\n</ul>\n<p>Does that mean that <code>sizeof(int) == 3 &amp;&amp; sizeof(long) == 5</code> is a valid behaviour?</p>\n<p>If yes - is there any known compiler/architecture behaving in a similar way?</p>\n", "Tags": "<c++><c><sizeof>", "OwnerUserId": "2149111", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_17834838_17835094_0": {"section_id": 7211, "quality": 0.9487179487179487, "length": 37}, "so_17834838_28352310_2": {"section_id": 7211, "quality": 0.6363636363636364, "length": 28}}, "n3337": {"so_17834838_17835094_0": {"section_id": 6955, "quality": 0.9487179487179487, "length": 37}, "so_17834838_28352310_2": {"section_id": 6955, "quality": 0.6363636363636364, "length": 28}}, "n4659": {"so_17834838_17835094_0": {"section_id": 8720, "quality": 0.9230769230769231, "length": 36}, "so_17834838_28352310_2": {"section_id": 8720, "quality": 0.6136363636363636, "length": 27}}}, "17839690": {"ParentId": "17834838", "CommentCount": "9", "Body": "<p>Definitely there are platforms with 24-bit ints. This is still used today for certain embedded applications. You could check Wikipedia for further information: <a href=\"http://en.wikipedia.org/wiki/24-bit\" rel=\"nofollow\">http://en.wikipedia.org/wiki/24-bit</a></p>\n", "OwnerUserId": "63832", "PostTypeId": "2", "Id": "17839690", "Score": "1", "CreationDate": "2013-07-24T16:26:17.273", "LastActivityDate": "2013-07-24T16:26:17.273"}, "17835094": {"ParentId": "17834838", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I think 3.9.1/2 (C++98) sums this up nicely (immediately followed by analogous information for the unsigned types):</p>\n<blockquote>\n<p id=\"so_17834838_17835094_0\">There are four signed integer types: \u201csigned char\u201d, \u201cshort int\u201d,\n  \u201cint\u201d, and \u201clong int.\u201d In this list, each type provides at least as\n  much storage as those preceding it in the list. Plain ints have the\n  natural size suggested by the architecture of the execution\n  environment39) ; the other signed integer types are provided to meet\n  special needs.</p>\n</blockquote>\n<p>Basically all we know is that <code>sizeof(char) == 1</code> and that each \"larger\" type is at least that large, with <code>int</code> being a \"natural\" size for an architecture (where as far as I can tell \"natural\" is up to the compiler writer). We don't know anything like <code>CHAR_BIT * sizeof(int) &lt;= 32</code> etc. Also keep in mind that <code>CHAR_BIT</code> doesn't have to be 8 either.</p>\n<p>It seems fairly safe to say that three byte <code>int</code> and five byte <code>long</code> would be allowed for hardware where those sizes were natively used. I am however not aware of any such hardware/architectures.</p>\n<p>EDIT: As pointed out in @Nigel Harper comment we do know that <code>int</code> has to be at least 16 bits and <code>long</code> at least 32 bits to satisfy range requirements. Otherwise we don't have any specific size restrictions other than as seen above.</p>\n", "OwnerUserId": "251738", "LastEditorUserId": "251738", "LastEditDate": "2013-07-24T17:44:44.723", "Id": "17835094", "Score": "10", "CreationDate": "2013-07-24T13:13:20.250", "LastActivityDate": "2013-07-24T17:44:44.723"}, "28352310": {"ParentId": "17834838", "PostTypeId": "2", "CommentCount": "0", "Body": "<h1>TL;DR</h1>\n<p>The behavior is valid and such compilers/architectures do exist</p>\n<ul>\n<li>TI DSPs with 4-byte <code>int</code>, 5-byte <code>long</code></li>\n<li>Motorola DSP5600x/3xx series with 2-byte <code>short</code>, 3-byte <code>int</code>, 6-byte <code>long</code></li>\n<li>x86 with 8-byte <code>double</code>, 10-byte <code>long double</code></li>\n</ul>\n<blockquote>\n<p id=\"so_17834838_28352310_0\">The number of bits used to represent the type <code>long</code> is not always the same as, or an integer multiple of, the number of bits in the type <code>int</code>. The ability to represent a greater range of values (than is possible in the type int) may be required, but processor costs may also be a consideration</p>\n</blockquote>\n<p><a href=\"http://c0x.coding-guidelines.com/5.2.4.2.1.pdf\" rel=\"nofollow noreferrer\">Derek M. Jones' The New C Standard (Excerpted material) - An Economic and Cultural Commentary</a></p>\n<hr>\n<p>The other answer have already recapped C++ standard requirements. Similarly C standard also doesn't constrain the type (floating-point or integer) sizes in bytes to powers of 2. The most common example is <code>long double</code>, which is most often 10 bytes in x86 (with padding to 12 or 16 bytes in many modern compilers).</p>\n<blockquote>\n<p id=\"so_17834838_28352310_1\"><sub><strong>ISO/IEC 9899:1999 (E)</strong></sub> </p>\n<h2>5.2.4.2.1  Sizes of integer types </h2>\n<ol>\n<li>The values given below shall be replaced by constant expressions suitable for use in <code>#if</code> preprocessing directives. Moreover, except for <code>CHAR_BIT</code> and <code>MB_LEN_MAX</code>, the following shall be replaced by expressions that have the same type as would an expression that is an object of the corresponding type converted according to the integer promotions. <strong>Their implementation-defined values shall be equal or greater in magnitude (absolute value) to those shown, with the same sign.</strong> [...]</li>\n</ol>\n<h2>6.2.5 Types</h2>\n<ol start=\"4\">\n<li><p id=\"so_17834838_28352310_2\">There are five standard signed integer types, designated as <code>signed char</code>, <code>short int</code>, <code>int</code>, <code>long int</code>, and <code>long long int</code>. (These and other types may be designated in several additional ways, as described in 6.7.2.) There may also be implementation-defined extended signed integer types.<sup>28)</sup><br>\n  The standard and extended signed integer types are collectively called signed integer types.<sup>29)</sup></br></p></li>\n<li><p id=\"so_17834838_28352310_3\">For any two integer types with the same signedness and different integer conversion rank (see 6.3.1.1), <strong>the range of values of the type with smaller integer conversion rank is a subrange of the values of the other type</strong>.</p></li>\n</ol>\n</blockquote>\n<p>Odd-sized integer types are much rarer, but still exist. Many DSPs have standard-conforming compilers with <strong>non-power-or-2 types</strong> where <code>int</code> has 32 bits, <code>long</code> has <strong>40 bits</strong>.</p>\n<blockquote>\n<ul>\n<li><code>long</code> is\n  \n  <ul>\n<li>40 bits or 5 bytes for C6000 COFF. <strong><em>This is fully compliant with any major C/C++ standard as those standards are all defining a minimum requirement of 4 byte for long (aka. long int)</em></strong>. Programmers are often falsely assuming this type having a size of exactly 4 bytes.</li>\n<li>32 bits or 4 bytes for C6000 EABI/ELF. See the C6000 EABI migration page for a discussion of the impact when porting code that was coded with 40-bit long in mind but only sees 32-bit on the migration target platform.</li>\n</ul></li>\n</ul>\n<p id=\"so_17834838_28352310_4\"><sub><em>Emphasis mine</em></sub><br>\n<a href=\"http://processors.wiki.ti.com/index.php/C89_Support_in_TI_Compilers#Misunderstandings_about_TI_C\" rel=\"nofollow noreferrer\"><em>C89 Support in TI Compilers#Misunderstandings about TI C</em></a></br></p>\n</blockquote>\n<p><sub>Offside note: <em>On some targets even <code>long long</code> is also a 32 or 40-bit type, which is valid in C89 as an extension but violates C99</em></sub></p>\n<blockquote>\n<p id=\"so_17834838_28352310_5\"><sub>Some targets have <code>long long</code> (an extension from C99), but not a conforming one. C99 requires at least 64 bits, but C2700 has 32-bit <code>long long</code>, and C5500 has 40-bit <code>long long</code>. C2800, C6000, and ARM have 64-bit <code>long long</code>, and C5400 and MSP430 do not support <code>long long</code>. This is not technically a violation of C89, since this is actually an extension, but if we start supporting C99, this would be a violation of C99 (C99 5.2.4.2.1 \"Sizes of integer types \" para 1).</sub></p>\n</blockquote>\n<p>The wider type's size doesn't even have to be a multiple of its preceding type's size</p>\n<blockquote>\n<p id=\"so_17834838_28352310_6\">The number of bits used to represent the type <code>long</code> is not always the same as, or an integer multiple of, the number of bits in the type <code>int</code>. The ability to represent a greater range of values (than is possible in the type <code>int</code>) may be required, but processor costs may also be a consideration. For instance, the Texas Instruments TMS320C6000, a DSP processor, uses 32 bits to represent the type <code>int</code> and 40 bits to represent the type <code>long</code> (this choice is not uncommon). Those processors (usually DSP) that use 24 bits to represent the type <code>int</code>, often use 48 bits to represent the type <code>long</code>. The use of 24/48 bit integer type representations can be driven by application requirements where a 32/64-bit integer type representation are not cost effective.</p>\n<p id=\"so_17834838_28352310_7\"><a href=\"http://c0x.coding-guidelines.com/5.2.4.2.1.pdf\" rel=\"nofollow noreferrer\"><em>Derek M. Jones' The New C Standard (Excerpted material): An Economic and Cultural Commentary</em></a></p>\n</blockquote>\n<p>In all 24-bit DSPs I knew before, <code>CHAR_BIT == 24</code> and all types have sizes as multiples of 24 bits, but I've just found out that the <a href=\"http://www.tasking.com/products/dsp56xxx/dsp56xxx-ds.pdf\" rel=\"nofollow noreferrer\">Motorola DSP5600x/3xx series</a> have a really \"strange\" type system</p>\n<pre><code>Data Type           size in bits\n(un)signed char     8\n(un)signed short    16\n(un)signed int      24\n(un)signed long     48\n(long)_fract        24 (48)\npointer             16/24\nfloat/double        24+8\nenum                24\n</code></pre>\n<p>So in this case <code>sizeof(char) == 1 &amp;&amp; sizeof(short) == 2</code> but <code>sizeof(int) == 3</code> and <code>sizeof(long) == 6</code></p>\n<p>Unfortunately GCC calls it (<code>long</code> or <code>long long</code>) <a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.5.1/gcc/Long-Long.html#Long-Long\" rel=\"nofollow noreferrer\">double-word integers</a>, and so do most people, making a big misunderstanding, although it doesn't necessarily be double the size.</p>\n</hr>", "OwnerUserId": "995714", "LastEditorUserId": "995714", "LastEditDate": "2017-09-06T13:25:52.887", "Id": "28352310", "Score": "4", "CreationDate": "2015-02-05T19:23:13.613", "LastActivityDate": "2017-09-06T13:25:52.887"}, "17835118": {"ParentId": "17834838", "CommentCount": "4", "Body": "<p>The C++ standard (and almost certainly the C standard, but I haven't looked at it for a very long time) does not have a rule that says anything about the NUMBER of bits that a type should be. I know for a fact that 9-bit <code>char</code> is allowed, and there are machines with 36-bit integers. Last time I checked, neither 9 or 36 are powers of 2. </p>\n", "OwnerUserId": "1919155", "PostTypeId": "2", "Id": "17835118", "Score": "1", "CreationDate": "2013-07-24T13:14:21.747", "LastActivityDate": "2013-07-24T13:14:21.747"}});