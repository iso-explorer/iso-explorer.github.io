post_cb({"26331170": {"ParentId": "26331035", "CommentCount": "7", "Body": "<p>The relevant issue is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1457\">CWG 1457</a>, where the justification is that the change allows <code>1 &lt;&lt; 31</code> to be used in constant expressions:</p>\n<blockquote>\n<p id=\"so_26331035_26331170_0\">The current wording of 5.8 [expr.shift] paragraph 2 makes it undefined\n  behavior to create the most-negative integer of a given type by\n  left-shifting a (signed) 1 into the sign bit, even though this is not\n  uncommonly done and works correctly on the majority of\n  (twos-complement) architectures:</p>\n<blockquote>\n<p id=\"so_26331035_26331170_3\">...if E1 has a signed type and non-negative value, and E1 * 2<sup>E2</sup> is\n    representable in the result type, then that is the resulting value;\n    otherwise, the behavior is undefined. </p>\n</blockquote>\n<p id=\"so_26331035_26331170_2\">As a result, this technique\n  cannot be used in a constant expression, which will break a\n  significant amount of code.</p>\n</blockquote>\n<p>Constant expressions can't contain undefined behavior, which means that using an expression containing UB in a context requiring a constant expression makes the program ill-formed. libstdc++'s <code>numeric_limits::min</code>, for example, <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=52119\">once failed to compile in clang</a> due to this.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "26331170", "Score": "16", "CreationDate": "2014-10-12T23:45:54.020", "LastActivityDate": "2014-10-12T23:45:54.020"}, "bq_ids": {"n4140": {"so_26331035_26331035_0": {"section_id": 6147, "quality": 0.782608695652174, "length": 18}, "so_26331035_26331170_1": {"section_id": 6147, "quality": 0.9285714285714286, "length": 13}, "so_26331035_26331035_2": {"section_id": 32, "quality": 0.9285714285714286, "length": 13}, "so_26331035_26331035_1": {"section_id": 6147, "quality": 0.9333333333333333, "length": 28}, "so_26331035_26331170_3": {"section_id": 6147, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_26331035_26331035_0": {"section_id": 5910, "quality": 0.782608695652174, "length": 18}, "so_26331035_26331170_1": {"section_id": 5910, "quality": 0.9285714285714286, "length": 13}, "so_26331035_26331035_2": {"section_id": 29, "quality": 0.9285714285714286, "length": 13}, "so_26331035_26331035_1": {"section_id": 5910, "quality": 0.7, "length": 21}, "so_26331035_26331170_3": {"section_id": 5910, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_26331035_26331035_0": {"section_id": 7643, "quality": 0.782608695652174, "length": 18}, "so_26331035_26331170_1": {"section_id": 7643, "quality": 0.9285714285714286, "length": 13}, "so_26331035_26331035_2": {"section_id": 32, "quality": 0.7857142857142857, "length": 11}, "so_26331035_26331035_1": {"section_id": 7643, "quality": 0.9333333333333333, "length": 28}, "so_26331035_26331170_3": {"section_id": 7643, "quality": 0.9285714285714286, "length": 13}}}, "26331035": {"CommentCount": "2", "AcceptedAnswerId": "26331170", "CreationDate": "2014-10-12T23:24:21.623", "LastActivityDate": "2014-10-12T23:45:54.020", "PostTypeId": "1", "ViewCount": "2054", "FavoriteCount": "8", "Title": "Why was 1 << 31 changed to be implementation-defined in C++14?", "Id": "26331035", "Score": "28", "Body": "<p>In all versions of C and C++ prior to 2014, writing</p>\n<pre><code>1 &lt;&lt; (CHAR_BIT * sizeof(int) - 1)\n</code></pre>\n<p>caused undefined behaviour, because left-shifting is defined as being equivalent to successive multiplication by <code>2</code>, and this shift causes signed integer overflow:</p>\n<blockquote>\n<p id=\"so_26331035_26331035_0\">The result of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions; vacated bits are filled with zeros. [...] If <code>E1</code> has a signed type and nonnegative value, and <code>E1</code> \u00d7 2<sup>E2</sup> is representable in the result type, then that is the resulting value; otherwise, <strong>the behavior is undefined</strong>.</p>\n</blockquote>\n<p>However in C++14 the text has changed for <code>&lt;&lt;</code> but not for multiplication:</p>\n<blockquote>\n<p id=\"so_26331035_26331035_1\">The value of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions; vacated bits are zero-filled. [...] Otherwise, if <code>E1</code> has a signed type and non-negative value, and <code>E1</code> \u00d7 2<sup>E2</sup> is representable in the <strong>corresponding unsigned type</strong> of the result type, then that value, <strong>converted to the result type</strong>, is the resulting value; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>The behaviour is now the same as for out-of-range assignment to signed type, i.e. as covered by [conv.integral]/3: </p>\n<blockquote>\n<p id=\"so_26331035_26331035_2\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, <strong>the value is implementation-defined</strong>.</p>\n</blockquote>\n<p>This means it's still non-portable to write <code>1 &lt;&lt; 31</code> (on a system with 32-bit int). So why was this change made in C++14?</p>\n", "Tags": "<c++><bit-shift><c++14>", "OwnerUserId": "1505939", "AnswerCount": "1"}});