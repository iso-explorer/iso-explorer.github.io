post_cb({"35151573": {"ParentId": "35140997", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It is known that:</p>\n<ul>\n<li><p><code>static const</code> integral type members can be initialized in class definition.</p></li>\n<li><p><code>static constexpr</code> members can be initialized in class definition</p></li>\n</ul>\n<p><code>double</code> is not an integral type and should be marked as a <code>constexpr</code>.</p>\n<p>Executables produced in a  machine can run in other machines where floating point representation computation is different. <a href=\"https://www.cs.auckland.ac.nz/references/unix/digital/AQTLTBTE/DOCU_066.HTM\" rel=\"nofollow noreferrer\">Integral Constant Expressions</a> do not change.</p>\n<p>Marking an object <code>static</code> says that it can be known by all observers, and making it <code>const</code> is saying that the value does not change. The compiler can generate a value (e.g. 314 ) and put it in the read-only section, because the range is defined in the standard.</p>\n<p>On the other hand <code>double</code> is not in the standard and cannot have its ranged check and the value stored at compile-time, in class definitions. One could easily end up with having different object files with objects having a different value for that <code>static const double</code>, thus breaking ODR.</p>\n<p>Here is a simple example:</p>\n<pre><code>struct foo\n{\nstatic char const a = 1/11; // everyone gets 0 at compile-time\n};\n</code></pre>\n<p>You would say then , but this can happen for doubles and at first look, something like this</p>\n<pre><code>struct foo\n{\nstatic double const y=1.0/11.0; // the true value is 0.090909... \n};\n</code></pre>\n<p>seems verifiable, but the representation in double in one machine will be <code>0.09091</code> in another <code>0.090909091</code> .</p>\n<p>Using <code>constexpr</code> permits to say to the compiler that the input necessary to verify this is available at <em>compile-time</em> . However, actual evaluation can happen at <em>run-time</em>.</p>\n<p><em>Since object files produced by C++ compilers can move to machines with different floating point representations , you have to tell that this checking must be made during compile time to ensure that consistency.</em></p>\n<p>The question is a typical example of an <a href=\"https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem\">XY-problem</a>. Instead of asking , \"<em>why do I have to mark anything with <code>constexpr</code>?</em>\" a puzzle <code>char</code>-vs-<code>float</code> is given. Now the question is, \"<em>why do we have to use <code>constexpr</code> for non-integral types</em>?\", and <a href=\"https://stackoverflow.com/questions/19575258/why-must-non-integral-static-data-members-initialized-in-the-class-be-constexpr\">here you can find your answer</a> .</p>\n", "OwnerUserId": "4345926", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:17:56.830", "Id": "35151573", "Score": "0", "CreationDate": "2016-02-02T10:58:49.020", "LastActivityDate": "2016-02-02T10:58:49.020"}, "bq_ids": {"n4140": {"so_35140997_35142328_0": {"section_id": 5908, "quality": 0.975609756097561, "length": 40}}, "n3337": {"so_35140997_35142328_0": {"section_id": 5680, "quality": 0.975609756097561, "length": 40}}, "n4659": {"so_35140997_35142328_0": {"section_id": 7390, "quality": 0.7073170731707317, "length": 29}}}, "35142288": {"ParentId": "35140997", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I don't believe that there is a good reason for this except that it has grown historically.</p>\n<p>The exception for integral types was desirable in pre-C++11 because people wanted to use them as array sizes. This goes along with the other exception for integral <code>const</code>ants being treated as constant expressions. An exception that doesn't exist for floating-point types.</p>\n<pre><code>const int    ni = 10;\nconst float  nf = 10.0f;\nint numbers1[(unsigned) ni];  // perfectly fine in all versions of C++\nint numbers2[(unsigned) nf];  // error in all versions of C++\n</code></pre>\n<p>When C++11 introduced <code>constexpr</code>, it could do anything the special-casing for <code>const</code> integral types could do and much more. And it works the same way for any literal type. So, given a superior tool, there was no need to dilate the existing rules for integral types to floating-point.</p>\n<p>Today, the special-casing of integral types is mostly a left-over from the earlier darker days. It cannot be removed from the language because doing so would break existing code that relies on this special-casing but there would be little gains from complicating the language even further by adding more exceptions that would be entirely unneeded today thanks to <code>constexpr</code>. People should be expected to migrate to <code>constexpr</code> and not worry about the old cruft any more. I believe that this was a very reasonable decision but you could certainly argue that another decision should have been made.</p>\n<h3>Addendum</h3>\n<p>As <a href=\"https://stackoverflow.com/users/2756719/t-c\">T.C.</a> has commented, there has been a (non)-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1826\" rel=\"noreferrer\">defect report</a> about this issue where the committee confirmed that the behavior won't be changed and people are supposed to start using <code>constexpr</code>.</p>\n<blockquote>\n<p id=\"so_35140997_35142288_0\"><strong>1826. <code>const</code> floating-point in constant expressions</strong></p>\n<p id=\"so_35140997_35142288_1\">Section: 5.20  [expr.const]     Status: NAD     Submitter: Ville Voutilainen     Date: 2014-01-04</p>\n<p id=\"so_35140997_35142288_2\">A <code>const</code> integer initialized with a constant can be used in constant expressions, but a <code>const</code> floating point variable initialized with a constant cannot. This was intentional, to be compatible with C++03 while encouraging the consistent use of <code>constexpr</code>. Some people have found this distinction to be surprising, however.</p>\n<p id=\"so_35140997_35142288_3\">It was also observed that allowing <code>const</code> floating point variables as constant expressions would be an ABI-breaking change, since it would affect lambda capture.</p>\n<p id=\"so_35140997_35142288_4\">One possibility might be to deprecate the use of <code>const</code> integral variables in constant expressions.</p>\n<p id=\"so_35140997_35142288_5\"><strong>Additional note, April, 2015:</strong></p>\n<p id=\"so_35140997_35142288_6\">EWG requested CWG to allow use of <code>const</code> floating-point variables in constant expressions.</p>\n<p id=\"so_35140997_35142288_7\"><strong>Rationale (May, 2015):</strong></p>\n<p id=\"so_35140997_35142288_8\">CWG felt that the current rules should not be changed and that programmers desiring floating point values to participate in constant expressions should use <code>constexpr</code> instead of <code>const</code>.</p>\n</blockquote>\n", "OwnerUserId": "1392132", "LastEditorUserId": "1392132", "LastEditDate": "2016-02-02T00:28:26.077", "Id": "35142288", "Score": "13", "CreationDate": "2016-02-01T23:17:40.327", "LastActivityDate": "2016-02-02T00:28:26.077"}, "35140997": {"CommentCount": "5", "ViewCount": "1242", "PostTypeId": "1", "LastEditorUserId": "893254", "CreationDate": "2016-02-01T21:47:56.097", "LastActivityDate": "2016-02-02T13:14:37.417", "Title": "C++ Why can I initialize a static const char but not a static const double in a class definition?", "FavoriteCount": "2", "LastEditDate": "2016-02-02T13:14:37.417", "Id": "35140997", "Score": "12", "Body": "<p>Here are two line of code:</p>\n<pre><code>static const double RYDBERG_CONST_EV = 13.6056953;\nstatic const char CHAR_H_EDGE = '-';\n</code></pre>\n<p>The second line compiles without errors, the first line does not compile. (Error: <code>'constexpr' needed for in-class initialization of static data member...</code>)</p>\n<p>The solution is apparently to add the keyword <code>constexpr</code> before the type. This is required because <code>double</code> is not an \"integral type\". But why does the behaviour differ between integer and floating point types?</p>\n", "Tags": "<c++><c++11><static-members><constexpr>", "OwnerUserId": "893254", "AnswerCount": "3"}, "35142328": {"ParentId": "35140997", "CommentCount": "1", "Body": "<p>For the wording, \u00a7 [class.static.data]/3 says:</p>\n<blockquote id=\"so_35140997_35142328_0\">\n<ol start=\"3\">\n<li><strong>If a non-volatile const static data member is of integral or enumeration type, its declaration in the class\n  definition <em>can</em> specify a brace-or-equal-initializer</strong> in which every initializer-clause that is an assignment-expression is a constant expression (5.20). <strong>A static data member of literal type can be declared in the class definition with the constexpr specifier</strong>; if so, its declaration shall specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-expression is a constant expression.</li>\n</ol>\n</blockquote>\n<p>(emph mine). Note how in case of integral types the static data member <em>can</em>, not <em>must</em>, have an initialization (you can always put it outside the class definition). Plus, the only other way to have an initaliation inside a class definition is by means of constexpr.</p>\n<p>The reasoning (IMHO) about allowing integral types (also in C++98) to be initialized in the class definition is in order to enable very simple patterns like this:</p>\n<pre><code>class Foo {\n    static const size_t arrayLen = 42;\n    int foo[arrayLen];\n};\n</code></pre>\n<p>which without an in-body initialization would become impossible to implement.</p>\n", "OwnerUserId": "1873944", "PostTypeId": "2", "Id": "35142328", "Score": "2", "CreationDate": "2016-02-01T23:21:22.393", "LastActivityDate": "2016-02-01T23:21:22.393"}});