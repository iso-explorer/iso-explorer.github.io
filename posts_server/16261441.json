post_cb({"bq_ids": {"n4140": {"so_16261441_16261488_1": {"length": 30, "quality": 0.9090909090909091, "section_id": 739}}, "n3337": {"so_16261441_16261488_1": {"length": 30, "quality": 0.9090909090909091, "section_id": 728}}, "n4659": {"so_16261441_16261488_1": {"length": 30, "quality": 0.9090909090909091, "section_id": 797}}}, "16261441": {"ViewCount": "795", "Body": "<p>This definitions are inside of <code>OuterClass</code>:</p>\n<pre><code>struct Compare\n{\n    bool operator ()(const T&amp;, const T&amp;);\n};\ntypedef set&lt;T, Compare&gt; MySet;\n</code></pre>\n<p>My problem is that the compare function <code>operator ()</code> depends on the state of <code>OuterClass</code>. (<code>MySet</code> instances are used during an algorithm for an optimization and they have to sort differently at different stages.)</p>\n<p>Is there any way/workaround to access nonstatic members of <code>OuterClass</code> from within the compare function <code>operator ()</code>?</p>\n", "AcceptedAnswerId": "16261488", "Title": "C++ STL set: Compare object with extrinsic state", "CreationDate": "2013-04-28T09:24:28.157", "Id": "16261441", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-04-28T09:38:30.493", "Score": "5", "OwnerUserId": "999007", "Tags": "<c++><stl><compare><set>", "AnswerCount": "1"}, "16261488": {"Id": "16261488", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_16261441_16261488_0\">Is there any way/workaround to access nonstatic members of OuterClass from within the compare function operator ()?</p>\n</blockquote>\n<p>There is. Just write a user-defined constructor for <code>Compare</code> that accepts and stores a reference to <code>OuterClass</code>, this way:</p>\n<pre><code>struct Compare\n{\n    Compare(OuterClass&amp; o) : oc(o) { }\n    bool operator ()(const T&amp;, const T&amp;)\n    {\n        // Uses oc somehow...\n    }\nprivate:\n    OuterClass&amp; oc;\n};\n</code></pre>\n<p>Then, when you create your set, you can do something like:</p>\n<pre><code>int main()\n{\n    typedef std::set&lt;T, Compare&gt; MySet;\n\n    OuterClass oc; // &lt;== Construct an object of type Outerclass somehow...\n\n    MySet ms(Compare(oc)); // &lt;== Construct your comparator and pass it\n                           //     in input to the constructor of std::set\n}\n</code></pre>\n<p>Beware though: the ordering criterion should remain stable. Elements must always compare the same for the same set. Per paragraph 23.2.4/3 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16261441_16261488_1\">The phrase \u201cequivalence of keys\u201d means the equivalence relation imposed by the comparison and not the\n  <code>operator==</code> on keys. That is, two keys <code>k1</code> and <code>k2</code> are considered to be equivalent if for the comparison\n  object <code>comp</code>, <code>comp(k1, k2) == false &amp;&amp; comp(k2, k1) == false</code>. <strong>For any two keys k1 and k2 in the\n  same container, calling <code>comp(k1, k2)</code> shall always return the same value</strong>.</p>\n</blockquote>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-04-28T09:38:30.493", "Score": "5", "CreationDate": "2013-04-28T09:29:54.107", "ParentId": "16261441", "CommentCount": "2", "OwnerUserId": "1932150", "LastEditDate": "2013-04-28T09:38:30.493"}});