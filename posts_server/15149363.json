post_cb({"15149371": {"ParentId": "15149363", "CommentCount": "3", "Body": "<p>No, it does not have to have code. In fact, in most languages you can leave it out and it will construct the class properly.</p>\n", "OwnerUserId": "431369", "PostTypeId": "2", "Id": "15149371", "Score": "0", "CreationDate": "2013-03-01T02:19:39.773", "LastActivityDate": "2013-03-01T02:19:39.773"}, "15149403": {"ParentId": "15149363", "LastEditDate": "2013-03-01T05:41:00.573", "CommentCount": "7", "CreationDate": "2013-03-01T02:22:20.847", "OwnerUserId": "1204143", "LastEditorUserId": "1204143", "PostTypeId": "2", "Id": "15149403", "Score": "1", "Body": "<p>Your class has only simple data members, so you don't even need (or should want) a destructor.</p>\n<p>You should, however, initialize your data members in the constructor:</p>\n<pre><code>Transaction::Transaction()\n  : no(0), dollar('$') {\n    cout &lt;&lt; \"Entering constructor\" &lt;&lt; endl;\n}\n</code></pre>\n<p>Otherwise, they will not be initialized, and may contain random values (C++ doesn't guarantee initialization of primitive non-static members to any particular value if you don't initialize them in the constructor). This can be particularly insidious if you have pointer members.</p>\n", "LastActivityDate": "2013-03-01T05:41:00.573"}, "15149482": {"ParentId": "15149363", "LastEditDate": "2013-03-01T03:57:07.077", "CommentCount": "0", "CreationDate": "2013-03-01T02:30:37.787", "OwnerUserId": "103167", "LastEditorUserId": "103167", "PostTypeId": "2", "Id": "15149482", "Score": "5", "Body": "<p>Each subobject will be default initialized, if you provide a constructor without specifying initializers for said subobject.</p>\n<p>Section 8.5 of the Standard provides that:</p>\n<blockquote>\n<p id=\"so_15149363_15149482_0\">If no initializer is speci\ufb01ed for an object, the object is default-initialized; if no initialization is performed, an object with automatic or dynamic storage duration has indeterminate value. [ Note: Objects with static or thread storage duration are zero-initialized, see 3.6.2. \u2014 end note ]</p>\n</blockquote>\n<p>and that</p>\n<blockquote>\n<p id=\"so_15149363_15149482_1\">To <em>default-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a (possibly <em>cv-qualified</em>) class type, the default constructor for <code>T</code> is called (and the initialization is ill-formed if T has no accessible default constructor);</li>\n<li>if T is an array type, each element is default-initialized;</li>\n<li>otherwise, no initialization is performed.</li>\n</ul>\n<p id=\"so_15149363_15149482_2\">If a program calls for the default initialization of an object of a const-quali\ufb01ed type <code>T</code>, <code>T</code> shall be a class type with a user-provided default constructor.</p>\n</blockquote>\n<p>There are two ways to initialize subobjects: in the <em>ctor-initializer-list</em>, and in a <em>brace-or-equal-initializer</em> in the member declaration (for non-static members the latter is new in C++11).</p>\n<p>In practice, this means that when you don't provide an initializer, variables of primitive type, such as <code>int</code> and <code>char</code>, retain whatever value was left in memory previously.  In most cases it's extremely hard to predict what value that will be, but you should be aware that it could be a leftover sensitive datum such as a password.</p>\n<p>In the case of initialization of variables of static storage duration (such as objects at namespace scope and their members), the Standard further provides (same section) that:</p>\n<blockquote>\n<p id=\"so_15149363_15149482_3\">Every object of static storage duration is zero-initialized at program startup before any other initialization takes place.</p>\n</blockquote>\n<p>This is subtly different from what happens during <em>value-initialization</em> if you did not define a constructor:</p>\n<blockquote>\n<p id=\"so_15149363_15149482_4\">To value-initialize an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a (possibly <em>cv-qualified</em>) class type with a user-provided constructor, then the\n  default constructor for T is called (and the initialization is ill-formed if T has no accessible default constructor);</li>\n<li>if <code>T</code> is a (possibly <em>cv-qualified</em>) non-union class type without a user-provided constructor, then the object is zero-initialized and, if <code>T</code>\u2019s implicitly-declared default constructor is non-trivial, that constructor is called.</li>\n<li>if <code>T</code> is an array type, then each element is value-initialized;</li>\n<li>otherwise, the object is zero-initialized.</li>\n</ul>\n</blockquote>\n<p>but the effect is the same -- primitive members are set to zero and all others have their zero-argument constructor invoked.</p>\n<p>nneonneo's advice to initialize all members explicitly is good, since having zero-initialization only for variables of static storage duration often leads to difficult-to-find bugs.  But it's perfectly viable to use the <em>brace-or-equal-initializer</em> technique:</p>\n<pre><code>class Transaction\n{\n    int no = 0;\n    char dollar = 0;\npublic:\n\n    Transaction();\n    ~Transaction();\n}\n</code></pre>\n", "LastActivityDate": "2013-03-01T03:57:07.077"}, "bq_ids": {"n4140": {"so_15149363_15149482_1": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_15149363_15149482_0": {"section_id": 3291, "quality": 0.72, "length": 18}, "so_15149363_15149482_4": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_15149363_15149482_3": {"section_id": 3289, "quality": 1.0, "length": 12}, "so_15149363_15149482_2": {"section_id": 3286, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_15149363_15149482_1": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_15149363_15149482_0": {"section_id": 3161, "quality": 0.8, "length": 20}, "so_15149363_15149482_4": {"section_id": 3157, "quality": 1.0, "length": 4}, "so_15149363_15149482_3": {"section_id": 3159, "quality": 1.0, "length": 12}, "so_15149363_15149482_2": {"section_id": 3156, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_15149363_15149482_0": {"section_id": 4053, "quality": 0.72, "length": 18}, "so_15149363_15149482_3": {"section_id": 4051, "quality": 1.0, "length": 12}, "so_15149363_15149482_2": {"section_id": 4049, "quality": 0.6363636363636364, "length": 7}}}, "15149363": {"CommentCount": "1", "ViewCount": "272", "CreationDate": "2013-03-01T02:18:54.393", "LastActivityDate": "2013-03-01T05:41:00.573", "Title": "Does a constructor / destructor have to have code, or is the function enough?", "AcceptedAnswerId": "15149403", "PostTypeId": "1", "Id": "15149363", "Score": "1", "Body": "<p>So if I have a class</p>\n<pre><code>class Transaction {\n\nint no;\nchar dollar;\n\npublic:\n\n    Transaction();\n    ~Transaction();\n}\n</code></pre>\n<p>And in my constructor / destructor</p>\n<pre><code>Transaction::Transaction {\n    cout &lt;&lt; \"Entering constructor\" &lt;&lt; endl;\n}\n\nTransaction::~Transaction {\n    cout &lt;&lt; \"Leaving program\" &lt;&lt; endl;\n}\n</code></pre>\n<p>is that code enough for my constructor and destructor to work? Will it set the data members in my class to a safe state even though I declare nothing in my constructor?</p>\n", "Tags": "<c++>", "OwnerUserId": "1895783", "AnswerCount": "3"}});