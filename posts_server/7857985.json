post_cb({"bq_ids": {"n4140": {"so_7857985_7858222_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 302}}, "n3337": {"so_7857985_7858222_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 293}}, "n4659": {"so_7857985_7858222_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 309}}}, "7857985": {"ViewCount": "1655", "Body": "<p>I have a processing pipeline implemented, but I would like to improve it like this :  </p>\n<pre><code>#include &lt;iostream&gt;\n\n// buffers\nstruct src{}; struct b1{}; struct snk{};\n// filters\nstruct f1\n{\n    f1( const src &amp;, b1 &amp; ) { std::cout &lt;&lt; \"f1( src, b1 )\" &lt;&lt; std::endl; }\n};\nstruct f2\n{\n    f2( const b1 &amp;, snk &amp; ) { std::cout &lt;&lt; \"f2( b1, snk )\" &lt;&lt; std::endl; }\n};\n// the pipeline\ntemplate&lt; typename... Filters &gt;\nstruct pipeline\n{\n    template&lt; typename LastB &gt;\n    pipeline( const LastB &amp; )\n    {}\n};\ntemplate &lt; typename T1, typename... T &gt;\nstruct pipeline&lt; T1, T... &gt; : pipeline&lt; T... &gt;\n{\n    template&lt; typename... Buffs, typename Bin, typename Bout &gt;\n    pipeline( Buffs &amp;... buffs, Bin &amp; bin, Bout &amp; bout ) :\n        pipeline&lt; T... &gt;( buffs..., bin ),\n        filter( bin, bout )\n    {\n    }\n\n    T1 filter;\n};\n\nint main()\n{\n    src ba; b1  bb; snk bc;\n\n    pipeline&lt; f1 &gt; p1( ba, bb );\n    pipeline&lt; f1, f2 &gt; p2( ba, bb, bc ); // the problem is in this line!\n}\n</code></pre>\n<p>Unfortunately, the example above produces next errors :  </p>\n<pre><code>sda_variadic.cpp: In function 'int main()':\nsda_variadic.cpp:40:39: error: no matching function for call to 'pipeline&lt;f1, f2&gt;::pipeline(src&amp;, b1&amp;, snk&amp;)'\nsda_variadic.cpp:40:39: note: candidates are:\nsda_variadic.cpp:26:5: note: template&lt;class ... Buffs, class Bin, class Bout&gt; pipeline&lt;T1, T ...&gt;::pipeline(Buffs&amp; ..., Bin&amp;, Bout&amp;)\nsda_variadic.cpp:23:8: note: constexpr pipeline&lt;f1, f2&gt;::pipeline(const pipeline&lt;f1, f2&gt;&amp;)\nsda_variadic.cpp:23:8: note:   candidate expects 1 argument, 3 provided\nsda_variadic.cpp:23:8: note: constexpr pipeline&lt;f1, f2&gt;::pipeline(pipeline&lt;f1, f2&gt;&amp;&amp;)\nsda_variadic.cpp:23:8: note:   candidate expects 1 argument, 3 provided\n</code></pre>\n<p>What is the reason for this error?<br>\nHow to fix it?</br></p>\n<p>Just a small explanation. I expect that the example above will first create an object of the unspecialized <code>pipeline&lt;&gt;( snk )</code>, then the specialized object <code>pipeline&lt; f1 &gt;(b1,snk)</code>, and then the specialized object <code>pipeline&lt; f1, f2 &gt;(src,b1,snk)</code>.<br>\nbtw take a note that the above example works for 1 filter (<code>pipeline&lt; f1</code>).</br></p>\n", "AcceptedAnswerId": "7858222", "Title": "Why is this constructor with variadic template arguments not a match?", "CreationDate": "2011-10-22T07:14:59.300", "Id": "7857985", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2011-10-22T08:15:36.233", "Score": "1", "OwnerUserId": "476681", "Tags": "<c++><constructor><c++11><variadic-templates>", "AnswerCount": "1"}, "7858222": {"Id": "7858222", "PostTypeId": "2", "Body": "<pre><code>template&lt; typename... Buffs, typename Bin, typename Bout &gt;\npipeline( Buffs &amp;... buffs, Bin &amp; bin, Bout &amp; bout ) :\n    pipeline&lt; T... &gt;( buffs..., bin ),\n    filter( bin, bout )\n{\n}\n</code></pre>\n<p>Since the function parameter pack (<code>Buffs</code>) is not in the last position, it cannot be deduced. From 14.8.2.1 Deducing template arguments from a function call [temp.deduct.call] paragraph 1:</p>\n<blockquote id=\"so_7857985_7858222_0\">\n<ol>\n<li>[...] For a function parameter pack that does not occur at the end of the parameter-declaration-list, the type of the parameter pack is a non-deduced context. [...]</li>\n</ol>\n</blockquote>\n<p>Since you can't explicitly pass template parameters to a constructor, it can't be called at all (not that it matters for your problem though).</p>\n<p>I'd recommend using <code>std::tuple</code> to manipulate the variadic arguments, such that you call the constructor like so: <code>pipeline(std::forward_as_tuple(b0, b1, b2), in, out)</code> and an empty tuple would be passed to the last stage.</p>\n", "LastEditorUserId": "726300", "LastActivityDate": "2011-10-22T08:15:36.233", "Score": "4", "CreationDate": "2011-10-22T08:10:35.550", "ParentId": "7857985", "CommentCount": "0", "OwnerUserId": "726300", "LastEditDate": "2011-10-22T08:15:36.233"}});