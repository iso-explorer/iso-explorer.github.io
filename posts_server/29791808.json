post_cb({"29791808": {"CommentCount": "6", "ViewCount": "286", "PostTypeId": "1", "LastEditorUserId": "3552770", "CreationDate": "2015-04-22T08:29:16.750", "LastActivityDate": "2017-06-23T07:43:03.483", "Title": "Visual C++ - call conversion operator on a primitive type explicitly", "AcceptedAnswerId": "29792779", "LastEditDate": "2017-06-23T07:43:03.483", "Id": "29791808", "Score": "11", "Body": "<p>I was playing around with a class <code>Foo</code>, that defined an implicit <code>operator bool()</code>. I used <code>Foo</code> as a return type for several functions, so I could get an information about what had been done and call the <code>Foo::operator bool()</code> to get whether the operation had performed successfully.</p>\n<p>Out of curiosity, I also tried an explicit call of the conversion operator while using <code>Foo</code>:</p>\n<pre><code>if(!func().operator bool()) // func returned Foo\n    throw std::logic_error(\"operation was not successful\");\n</code></pre>\n<p>That worked fine. Then, I suddenly decided to dump the <code>Foo</code> class and go with simple <code>bool</code> but I forgot to remove <code>.operator bool()</code> call on the function return value. And so I discovered a set of strange behaviors of Visual C++ 12.0 compiler (Visual Studio 2013).</p>\n<hr>\n<p>None of the explicit calls of conversion operators to <code>bool</code> are valid in GCC:<br>\n<code>request for member \u2018operator bool\u2019 in \u2018true\u2019, which is of non-class type \u2018bool\u2019</code></br></p>\n<p>Now, the behavior I get with Visual Studio:</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\nbool func()\n{\n    return true;\n}\n\nint main()\n{\n    bool b = true.operator bool();\n    cout &lt;&lt; b &lt;&lt; endl; // error C4700: uninitialized local variable 'b' used\n\n    // evaluates to true (probably like b would do if it compiled)\n    if(false.operator bool())\n        cout &lt;&lt; \"a\" &lt;&lt; endl;\n\n    cout &lt;&lt; func().operator bool() &lt;&lt; endl; // prints nothing\n\n    int m = 10;\n    cout &lt;&lt; m.operator int() &lt;&lt; endl; // prints nothing\n\n    // correctly gives error: left of '.&lt;' must have class/struct/union\n    cout &lt;&lt; m.operator &lt;(10) &lt;&lt; endl;\n}\n</code></pre>\n<p>Even the intellisense is right and shows <code>Error: expression must have a class type</code>.\nIs there an explanation to all this? A bug? An (unwanted) extension? What is it?</p>\n</hr>", "Tags": "<c++><visual-c++><visual-studio-2013><operators>", "OwnerUserId": "3552770", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29791808_29792779_0": {"section_id": 6004, "quality": 0.64, "length": 16}}, "n3337": {"so_29791808_29792779_0": {"section_id": 5772, "quality": 0.64, "length": 16}}, "n4659": {"so_29791808_29792779_0": {"section_id": 7503, "quality": 0.64, "length": 16}}}, "29792779": {"ParentId": "29791808", "LastEditDate": "2015-12-19T16:16:38.627", "CommentCount": "0", "CreationDate": "2015-04-22T09:09:58.293", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "PostTypeId": "2", "Id": "29792779", "Score": "8", "Body": "<p>Nice find! The standard definitely makes this ill-formed with a diagnostic required, [expr.ref]:</p>\n<blockquote>\n<p id=\"so_29791808_29792779_0\">A postfix expression followed by a dot <code>.</code> or an arrow <code>-&gt;</code>,\n  optionally followed by the keyword <code>template</code> (14.2), and then\n  followed by an <em>id-expression</em>, is a postfix expression. [..] <strong>For\n  the first option (dot) the first expression shall have complete class\n  type.</strong></p>\n</blockquote>\n<p>Also, not an extension: Would be one hell of a nonsensical extension. It seems that VC++ implements <code>bool</code> with some <a href=\"https://msdn.microsoft.com/en-us/library/tf4dy80a.aspx\" rel=\"nofollow\">internal (class-like?) type</a>:</p>\n<blockquote>\n<p id=\"so_29791808_29792779_1\">In Visual C++ 5.0 and later, <code>bool</code> is implemented as a built-in type\n  with a size of 1 byte.</p>\n</blockquote>\n<p>That type's class-like semantics are apparently not fully suppressed. Even</p>\n<pre><code>bool b;\nb.operator std::string();\n</code></pre>\n<p>compiles (<a href=\"http://rextester.com/ARSUL10396\" rel=\"nofollow\">giving a seemingly empty <code>string</code></a>), implying that the internal class has a conversion operator template.</p>\n", "LastActivityDate": "2015-12-19T16:16:38.627"}});