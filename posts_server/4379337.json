post_cb({"4379387": {"Id": "4379387", "PostTypeId": "2", "Body": "<p>Short Answer: Its should work as you have coded it. See Ben Voigt  Answer</p>\n<p>Long Answer:</p>\n<p>Do something like this:<br>\nRather than let the compiler decide when globals are created, create them via static methods (with static function variables). This means that they will be deterministically created on first use (and destroyed in the reverse order of creation).</br></p>\n<p>Even if one global uses another during its construction using this method gurantees that they will be created in the order required and thus be available for usage by the other (watch out for loops).</p>\n<pre><code>struct A\n{\n    // Rather than an explicit global use\n    // a static method thus creation of the value is on first use\n    // and not at all if you don't want it.\n    static A&amp; getGlobalA()\n    {\n        static A instance;  // created on first use (destroyed on application exit)\n     // ^^^^^^ Note the use of static here.\n        return instance;    // return a reference.\n    }\n  private:\n    A() \n        :b_ref(B::getGlobalB())     // Do the same for B\n    {}                              // If B has not been created it will be\n                                    // created by this call, thus guaranteeing\n                                    // it is available for use by this object\n    }\n    B&amp;  b_ref;\n  public:\n    void f() { b_ref.do_something(); }\n};\n\nint main() {\n    a::getGlobalA().f();\n}\n</code></pre>\n<p>Though a word of warning.</p>\n<ul>\n<li>Globals are an <em>indication</em> of bad  design.</li>\n<li>Globals that depend on other globals is another code smell (especially during construction/destruction).</li>\n</ul>\n", "LastEditorUserId": "14065", "LastActivityDate": "2010-12-07T17:52:01.853", "Score": "2", "CreationDate": "2010-12-07T17:02:28.380", "ParentId": "4379337", "CommentCount": "3", "OwnerUserId": "14065", "LastEditDate": "2010-12-07T17:52:01.853"}, "4379612": {"Id": "4379612", "PostTypeId": "2", "Body": "<p>Yes, the standard allows this.</p>\n<p>There are a number of paragraphs in section <code>[basic.life]</code> which start out</p>\n<blockquote>\n<p id=\"so_4379337_4379612_0\"><strong>Before the lifetime of an object has\n  started but after the storage which\n  the object will occupy has been\n  allocated</strong> or, after the lifetime of an\n  object has ended and before the\n  storage which the object occupied is\n  reused or released, any pointer that\n  refers to the storage location where\n  the object will be or was located may\n  be used but only in limited ways.</p>\n</blockquote>\n<p>and there is a footnote which indicates that this specifically applies to your situation</p>\n<blockquote>\n<p id=\"so_4379337_4379612_1\">For example, before the construction of a global object of non-POD class type</p>\n</blockquote>\n", "LastActivityDate": "2010-12-07T17:26:03.830", "CommentCount": "3", "CreationDate": "2010-12-07T17:26:03.830", "ParentId": "4379337", "Score": "5", "OwnerUserId": "103167"}, "4381191": {"Id": "4381191", "PostTypeId": "2", "Body": "<p>Ah, but the idea that static variables are \"not initialised\" is quite wrong. They're always initialised, just not necessarily with your initialiser. In particular, all static variables are created with value zero before any other initialisation. For class objects, the members are zero. Therefore global_a.b_ptr above will always be a valid pointer, initially NULL and later &amp;global_b. The effect of this is that use of non-pointers is unspecified, not undefined, in particular this code is well defined (in C):</p>\n<pre><code>// unit 1\nint a = b + 1;\n\n// unit 2\nint b = a + 1;\n\nmain ... printf(\"%d\\n\", a + b); // 3 for sure\n</code></pre>\n<p>The zero initialisation guarantee is used with this pattern:</p>\n<pre><code>int get_x() {\n  static int init;\n  static int x;\n  if(init) return x;\n  else { x = some_calc(); init = 1; return x; }\n}\n</code></pre>\n<p>which assures either a non-return due to infinite recursion, or, correctly initialised value.</p>\n", "LastActivityDate": "2010-12-07T20:22:30.797", "CommentCount": "1", "CreationDate": "2010-12-07T20:22:30.797", "ParentId": "4379337", "Score": "1", "OwnerUserId": "518287"}, "4379556": {"Id": "4379556", "PostTypeId": "2", "Body": "<p>If B has a constructor, like A has, then the order that they are called is undefined. So your code won't work unless you are lucky. But if B doesn't require any code to initialise it, then your code will work. It's not implementation-defined.</p>\n", "LastActivityDate": "2010-12-07T17:20:25.563", "CommentCount": "2", "CreationDate": "2010-12-07T17:20:25.563", "ParentId": "4379337", "Score": "1", "OwnerUserId": "428857"}, "bq_ids": {"n4140": {"so_4379337_4379612_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 7193}, "so_4379337_4379612_0": {"length": 35, "quality": 1.0, "section_id": 7193}}, "n3337": {"so_4379337_4379612_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 6937}, "so_4379337_4379612_0": {"length": 35, "quality": 1.0, "section_id": 6937}}, "n4659": {"so_4379337_4379612_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 8702}, "so_4379337_4379612_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 8702}}}, "4379369": {"Id": "4379369", "PostTypeId": "2", "Body": "<p>Yes. All are located in <code>.data</code> section, that is allocated at once (and it's not heap).</p>\n<p>Putting it another way: if you are able to take its address, then it's OK, because it surely won't change.</p>\n", "LastEditorUserId": "395626", "LastActivityDate": "2010-12-07T17:19:40.453", "Score": "1", "CreationDate": "2010-12-07T17:01:16.437", "ParentId": "4379337", "CommentCount": "1", "OwnerUserId": "395626", "LastEditDate": "2010-12-07T17:19:40.453"}, "4379337": {"ViewCount": "2687", "Body": "<p>If I have two static variables in different compilation units, then their initialization order is not defined. This lesson is well learned.</p>\n<p>The question I have: are all the static variables already allocated, when the first one is being initialized. In other words:</p>\n<pre><code>static A global_a; // in compilation unit 1\nstatic B global_b; // in compilation unit 2\n\nstruct A {\n    A() { b_ptr = &amp;global_b; }\n    B *b_ptr;\n\n    void f() { b_ptr-&gt;do_something(); }\n}\n\nint main() {\n    global_a.f();\n}\n</code></pre>\n<p>Will b_ptr point to a valid piece of memory, where B is allocated and initialized at the time of the execution of the main function? On all the platforms?</p>\n<p><strong>Longer story:</strong></p>\n<p>The compilation unit 1 is Qt library.\nThe other one is my application. I have couple QObject derived classes, that I need to be able to instantiate by the class name string. For this I came up with a templated factory class:</p>\n<pre><code>class AbstractFactory {\npublic:\n    virtual QObject *create() = 0;\n    static QMap&lt;const QMetaObject *, AbstractFactory *&gt; m_Map;\n}\nQMap&lt;const QMetaObject *, AbstractFactory *&gt; AbstractFactory::m_Map; //in .cpp\n\ntemplate &lt;class T&gt;\nclass ConcreteFactory: public AbstractFactory {\npublic:   \n    ConcreteFactory() { AbstractFactory::m_Map[&amp;T::staticMetaObject] = this; }\n    QObject *create() { return new T(); }\n}\n\n#define FACTORY(TYPE) static ConcreteFactory &lt; TYPE &gt; m_Factory;\n</code></pre>\n<p>Then I add this macro on every QObject subclass definition:</p>\n<pre><code>class Subclass : public QObject {\n   Q_OBJECT;\n   FACTORY(Subclass);\n}\n</code></pre>\n<p>Finally I can instantiate a class by the type name:</p>\n<pre><code>QObject *create(const QString &amp;type) {\n    foreach (const QMetaObect *meta, AbstractFactory::m_Map.keys() {\n        if (meta-&gt;className() == type) {\n           return AbstractFactory::m_Map[meta]-&gt;create();\n        }\n    }\n    return 0;\n}\n</code></pre>\n<p>So the class gets a static <code>QMetaObject</code> instance: <code>Subclass::staticMetaObject</code> from the Qt library - it is auto-generated in <code>Q_OBJECT</code> macro I think. And then the <code>FACTORY</code> macro creates a static <code>ConcreteFactory&lt; Subclass &gt;</code> instance. ConcreteFactory in its constructor tries to reference of Subclass::staticMetaObject.</p>\n<p>And I was pretty happy with this implementation on linux (gcc), until I compiled it with Visual Studio 2008. For some reason AbstractFactory::m_Map was empty on  the runtime, and the debugger would not break at the factory constructor.</p>\n<p>So this is where the smell of static vars referencing other static vars is coming from.</p>\n<p>How can I optimize this code to avoid all these traps?</p>\n", "AcceptedAnswerId": "4379612", "Title": "C++ Initialization of static variables (Once again)", "CreationDate": "2010-12-07T16:57:51.167", "Id": "4379337", "CommentCount": "2", "LastEditDate": "2010-12-07T17:57:21.687", "PostTypeId": "1", "LastEditorUserId": "151186", "LastActivityDate": "2010-12-07T20:22:30.797", "Score": "5", "OwnerUserId": "151186", "Tags": "<c++><variables><static><initialization>", "AnswerCount": "5"}});