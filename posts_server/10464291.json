post_cb({"10464291": {"CommentCount": "2", "AcceptedAnswerId": "10464390", "PostTypeId": "1", "LastEditorUserId": "1085251", "CreationDate": "2012-05-05T17:32:55.713", "LastActivityDate": "2012-05-05T18:35:07.603", "LastEditDate": "2012-05-05T18:35:07.603", "ViewCount": "1447", "FavoriteCount": "1", "Title": "Why does gcc not warn when an enum or int value is passed on as a function's argument which is bool?", "Id": "10464291", "Score": "8", "Body": "<p>I have following code:</p>\n<pre class=\"lang-c prettyprint-override\"><code>typedef enum\n{\n    FOO,\n    BAR,\n    BAZ\n} foo_t;\n\nstatic void afunc(bool is_it_on)\n{\n    /* do the job */\n}\n\nint main(void)\n{\n    afunc(BAZ);\n    return 0;\n}\n</code></pre>\n<p>Compiling this code does not generate any warning message, even with <code>-Wall -Wextra</code> options given to the compiler. I have even tried with <code>-Wconversion</code> option, which took no effect because <code>bool</code> and <code>enum</code> seemed to be of same size for g++. (the size of <code>enum</code> type is not defined in specification as far as I know)</p>\n<p>I have combed through gcc manual and found nothing about it.</p>\n<p>Questions:</p>\n<ul>\n<li>Is there a way to force the compiler to generate a warning in cases like this?</li>\n<li>Or is it that this implicit casting is legal by c++ specification?</li>\n</ul>\n<p>Compiler that I am using: gcc 4.1.2</p>\n<hr>\n<p><strong>Editted</strong></p>\n<p>Conclusion:</p>\n<p>The only viable solution to this seems to define a new type to represent 0 or 1, and use it instead of <code>bool</code>.</p>\n<p>The code would be like following, and g++ complains about type conversion:</p>\n<pre class=\"lang-c prettyprint-override\"><code>typedef enum\n{\n    FOO1,\n    FOO2\n} foo_t;\n\ntypedef enum\n{\n    MY_FALSE,\n    MY_TRUE\n} my_bool_t;\n\nvoid foo(my_bool_t a)\n{\n}\n\nint main(void)\n{\n     /* \n      * gcc generates an error.\n      * error: cannot convert \u2018foo_t\u2019 to \u2018my_bool_t\u2019 \n      * for argument \u20181\u2019 to \u2018void foo(my_bool_t)\u2019\n      */\n    foo(FOO1);\n    return 0;\n}\n</code></pre>\n</hr>", "Tags": "<c++><gcc><g++><gcc-warning>", "OwnerUserId": "1085251", "AnswerCount": "1"}, "10464390": {"ParentId": "10464291", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Yes, those implicit conversions are perfectly legal.</p>\n<p>C++11 draft n3290, \u00a74.12 <em>Boolean conversions</em>:</p>\n<blockquote>\n<p id=\"so_10464291_10464390_0\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a\n  prvalue of type bool. A zero value, null pointer value, or null member pointer value is converted to false;\n  any other value is converted to true. A prvalue of type std::nullptr_t can be converted to a prvalue of\n  type bool; the resulting value is false.</p>\n</blockquote>\n<p>Warnings on these conversions (for arithmetic types) would probably lead to huge numbers of warnings all over the place, I don't think it would be manageable.</p>\n<p>In C++11, you can use <em>scoped enums</em> to prevent that implicit conversion:</p>\n<p>This fails to compile for lack of a conversion from <code>Foo</code> to <code>bool</code>:</p>\n<pre><code>enum class Foo { ONE };\n\nvoid tryit(bool b) { }\n\nint main()\n{\n    tryit(Foo::ONE);\n}\n</code></pre>\n", "OwnerUserId": "635608", "LastEditorUserId": "925381", "LastEditDate": "2012-05-05T17:57:14.300", "Id": "10464390", "Score": "9", "CreationDate": "2012-05-05T17:42:59.307", "LastActivityDate": "2012-05-05T17:57:14.300"}, "bq_ids": {"n4140": {"so_10464291_10464390_0": {"section_id": 44, "quality": 1.0, "length": 39}}, "n3337": {"so_10464291_10464390_0": {"section_id": 41, "quality": 1.0, "length": 39}}, "n4659": {"so_10464291_10464390_0": {"section_id": 45, "quality": 1.0, "length": 39}}}});