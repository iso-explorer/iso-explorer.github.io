post_cb({"11745681": {"Id": "11745681", "PostTypeId": "2", "Body": "<p>This is clearly implementation specific. In practice there are a relatively small number of sensible ways to implement things. Conceptually there are a few problems here:</p>\n<ol>\n<li><p>You need to be able to get a pointer to the most derived object, that is the object that (conceptually) encompasses all of the other types.</p>\n<p>In standard C++ you can do this with a <code>dynamic_cast</code>:</p>\n<pre><code>void *derrived = dynamic_cast&lt;void*&gt;(some_ptr);\n</code></pre>\n<p>Which gets the <code>C*</code> back from just a <code>B*</code>, for example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    unsigned a;\n    virtual ~A() { }\n};\n\nstruct B\n{\n    unsigned b;\n    virtual ~B() { }\n};\n\nstruct C : public A, public B\n{\n    unsigned c;\n};\n\nint main() {\n  C* c = new C;\n  std::cout &lt;&lt; static_cast&lt;void*&gt;(c) &lt;&lt; \"\\n\";\n  B* b = c;\n  std::cout &lt;&lt; static_cast&lt;void*&gt;(b) &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; dynamic_cast&lt;void*&gt;(b) &lt;&lt; \"\\n\";\n\n  delete b;\n}\n</code></pre>\n<p>Gave the following on my system</p>\n<pre>\n0x912c008\n0x912c010\n0x912c008\n</pre></li>\n<li><p>Once that's done it then becomes a standard memory allocation tracking problem. Usually that's done in one of two ways, either a) record the size of the allocation just before the allocated memory, finding the size is just a pointer subtraction then or b) record allocations and free memory in a data structure of some sort. For more details see <a href=\"https://stackoverflow.com/a/851976/168175\">this question</a>, which has a good reference.</p>\n<p>With glibc you can query the size of a given allocation fairly sensibly:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;malloc.h&gt;\n\nint main() {\n  char *test = (char*)malloc(50);\n  std::cout &lt;&lt; malloc_usable_size(test) &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>That information is available to free/delete similarly and used to figure out what to do with the returned chunk of memory.</p></li>\n</ol>\n<p>The exact details of the implementation of <code>malloc_useable_size</code> are given in the libc source code, in malloc/malloc.c:</p>\n<blockquote>\n<p id=\"so_11745527_11745681_0\">(The following includes lightly edited explanations by Colin Plumb.)</p>\n<p id=\"so_11745527_11745681_1\">Chunks of memory are maintained using a `boundary tag' method as\n  described in e.g., Knuth or Standish.  (See the paper by Paul Wilson\n  <a href=\"ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps\" rel=\"nofollow noreferrer\">ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps</a> for a survey of such\n  techniques.)  Sizes of free chunks are stored both in the front of\n  each chunk and at the end.  This makes consolidating fragmented chunks\n  into bigger chunks very fast.  The size fields also hold bits\n  representing whether chunks are free or in use.</p>\n<p id=\"so_11745527_11745681_2\">An allocated chunk looks like this:</p>\n<pre>\n    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of previous chunk, if allocated            | |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of chunk, in bytes                       |M|P|\n      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \n            |             User data starts here...                          .  \n            .                                                               .  \n            .             (malloc_usable_size() bytes)                      .  \n            .                                                               |   \nnextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     \n            |             Size of chunk                                     |  \n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \n</pre>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-31T17:49:21.650", "Score": "13", "CreationDate": "2012-07-31T17:24:33.083", "ParentId": "11745527", "CommentCount": "4", "OwnerUserId": "168175", "LastEditDate": "2017-05-23T11:53:25.143"}, "bq_ids": {"n4140": {"so_11745527_11747027_0": {"length": 8, "quality": 0.8, "section_id": 416}}, "n3337": {"so_11745527_11747027_0": {"length": 8, "quality": 0.8, "section_id": 407}}, "n4659": {"so_11745527_11747027_0": {"length": 8, "quality": 0.8, "section_id": 434}}}, "11745673": {"Id": "11745673", "PostTypeId": "2", "Body": "<p>Destroying a base class pointer requires that you've implemented a virtual destructor. If you didn't do that, all bets are off.</p>\n<p>The first destructor called will be the one for the most derived object as determined by the virtual mechanism (vtable). This destructor knows the size of the object! It can squirrel that information away someplace, or pass it down the chain of destructors.</p>\n", "LastActivityDate": "2012-07-31T17:23:58.437", "CommentCount": "0", "CreationDate": "2012-07-31T17:23:58.437", "ParentId": "11745527", "Score": "10", "OwnerUserId": "5987"}, "11745527": {"ViewCount": "2568", "Body": "<p>I would like to know how the delete operator figures out the memory location that needs to be freed when it is given a base class pointer that is different from the true memory location of the object.</p>\n<p>I want to duplicate this behavior in my own custom allocator/deallocator.</p>\n<p>Consider the following hierarchy:</p>\n<pre><code>struct A\n{\n    unsigned a;\n    virtual ~A() { }\n};\n\nstruct B\n{\n    unsigned b;\n    virtual ~B() { }\n};\n\nstruct C : public A, public B\n{\n    unsigned c;\n};\n</code></pre>\n<p>I want to allocate an object of type C and delete it through a pointer of type B. As far as I can tell this is a valid use of operator delete, and it works under Linux/GCC:</p>\n<pre><code>C* c = new C;\nB* b = c;\n\ndelete b;\n</code></pre>\n<p>The interesting thing is that the pointers 'b' and 'c' actually point to different addresses because of how the object is laid out in memory, and the delete operator \"knows\" how to find and free the correct memory location.</p>\n<p>I know that, in general, it is not possible to find the size of a polymorphic object given a base class pointer: <a href=\"https://stackoverflow.com/questions/8122763/find-out-the-size-of-a-polymorphic-object\">Find out the size of a polymorphic object</a>. I suspect that it is not generally possible to find the true memory location of the object either.</p>\n<p>Notes:</p>\n<ul>\n<li>My question is not related to how new[] and delete[] work. I am interested in the single object allocation case. <a href=\"https://stackoverflow.com/questions/197675/how-does-delete-know-the-size-of-the-operand-array\">How does delete[] \"know\" the size of the operand array?</a>.</li>\n<li>I am not concerned about how the destructor is called either. I am interested in the deallocation of the memory itself. <a href=\"https://stackoverflow.com/questions/10229481/how-delete-works-when-i-delete-a-pointer-of-base-class\">How 'delete' works when I delete a pointer of base class</a></li>\n<li>I tested using -fno-rtti and -fno-exceptions, so G++ should not have access to runtime type information.</li>\n</ul>\n", "AcceptedAnswerId": "11745681", "Title": "How does the C++ delete operator find the memory location of a polymorphic object?", "CreationDate": "2012-07-31T17:15:01.960", "Id": "11745527", "CommentCount": "6", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:56:59.470", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-31T18:54:25.423", "Score": "27", "OwnerUserId": "41704", "Tags": "<c++><memory-management><g++>", "AnswerCount": "7"}, "11745712": {"Id": "11745712", "PostTypeId": "2", "Body": "<p>Its implementation defined, but one common implementation technique is that <code>operator delete</code> is actually called by the destructor (rather than the code with the <code>delete</code> in it), and there's a hidden parameter to the destructor that controls whether <code>operator delete</code> is called.</p>\n<p>With this implementation, most calls to the destructor (all explicit dtor calls, calls for auto and static variables, and calls to base destructors from derived destructors) will have that extra hidden arg set to false (so operator delete will not be called).  When there's a delete expression, however, it calls the top-level destructor for the object with the hidden arg true.  In your example, this will be C::~C(), so it will know to reclaim the memory for the entire object</p>\n", "LastActivityDate": "2012-07-31T17:26:03.633", "CommentCount": "4", "CreationDate": "2012-07-31T17:26:03.633", "ParentId": "11745527", "Score": "6", "OwnerUserId": "16406"}, "11745688": {"Id": "11745688", "PostTypeId": "2", "Body": "<p>a pointer to a polymorphic object is usually implemented as a pointer to the object and the virtual table, which contains information about the underlying class of the object. delete will know these implementation details and find the right destructor</p>\n", "LastActivityDate": "2012-07-31T17:24:53.733", "CommentCount": "0", "CreationDate": "2012-07-31T17:24:53.733", "ParentId": "11745527", "Score": "0", "OwnerUserId": "170521"}, "11747027": {"Id": "11747027", "PostTypeId": "2", "Body": "<p>When compiling the <code>delete</code> operator, the compiler needs to determines a 'deallocation' function to call after the destructor is executed. Note that the destructor doesn't have anything directly to do with the deallocation call, but it does have an effect on how the deallocation function is looked up by the compiler.</p>\n<p>In the usual case, there is no type-specific deallocation function for the object, in which case the global deallocation function is used and which is always implicitly declared (C++03 3.7.3/2):</p>\n<pre><code>void operator delete(void*) throw();\n</code></pre>\n<p>Note that this function doesn't even take a size argument. It needs to determine the allocation size based on nothing but the pointer's value.  That might be done by storing the allocation's size just prior to the address (is there an implementation that does it some other way?).</p>\n<p>However, before deciding to use that deallocation function, the compiler performs a lookup to see if a type-specific deallocation function should be used.  That function can have either single parameter (a <code>void*</code>) or two parameters (a <code>void*</code> and a <code>size_t</code>).</p>\n<p>When looking up the deallocation function, if the static type of the pointer used as the operand to <code>delete</code> has a virtual destructor, then (C++03 12.5/4):</p>\n<blockquote>\n<p id=\"so_11745527_11747027_0\">the deallocation function is the one found by the lookup in the definition of the dynamic\n  type\u2019s virtual destructor </p>\n</blockquote>\n<p>In effect, any <code>operator delete()</code> deallocation function is virtual for types that have a virtual destructor, even though the actual function must be <code>static</code> (the standard notes this in 12.5/7).  In this case, the compiler can pass the size of object if it needs to because it has access to the object's dynamic type (any necessary adjustment to the object pointer can be found the same way).</p>\n<p>If the static type of the operand to <code>delete</code> is static, then the the lookup for the <code>operator delete()</code> deallocation function follows the usual rules.  Again, if the compiler selects a deallocation function that needs a size parameter, it can do so because the it knows the static type of the object at compile time.</p>\n<p>The final situation is one that results in undefined behavior: if the pointer's static type doesn't have a virtual destructor but points to a derived type object, then the compiler will potentially lookup the wrong deallocation function and pass the wrong size. But since that's the result of undefined behavior, it doesn't matter.</p>\n", "LastActivityDate": "2012-07-31T18:54:25.423", "CommentCount": "0", "CreationDate": "2012-07-31T18:54:25.423", "ParentId": "11745527", "Score": "1", "OwnerUserId": "12711"}, "11745728": {"Id": "11745728", "PostTypeId": "2", "Body": "<p>It can do this the same way malloc does.  Some mallocs record the size just preceding the object itself.  Most modern mallocs are a lot more sophisticated.  See <a href=\"http://goog-perftools.sourceforge.net/doc/tcmalloc.html\" rel=\"nofollow\">tcmalloc</a>, a fast allocator that keeps objects of the same size together on pages so that it need only keep size information on a page granularity.</p>\n", "LastActivityDate": "2012-07-31T17:27:10.830", "CommentCount": "0", "CreationDate": "2012-07-31T17:27:10.830", "ParentId": "11745527", "Score": "0", "OwnerUserId": "180090"}, "11746017": {"Id": "11746017", "PostTypeId": "2", "Body": "<p>The usual implementation (theoretically, there can be others, I doubt there are in practice) is that there is a vtable per base object (if not, base objects aren't polymorph and can't be used for deleting). That vtable contains not only pointer to virtual functions, but also what is needed for the whole RTTI, included offset from the current object to the most derived one.</p>\n<p>In order to explain (there are probably differences in any true implementation and I may have made some errors), here is what is really used:</p>\n<pre><code>struct A_VTable_Desc {\n   int offset;\n   void* (destructor)();\n} AVTable = { 0, A::~A };\n\nstruct A_impl {\n   unsigned a;\n   A_VTable_Desc* vptr;\n};\n\nstruct B_VTable_Desc {\n   int offset;\n   void* (destructor)();\n} BVtable = { 0, &amp;B::~B };\n\nstruct B_impl {\n   unsigned b;\n   B_VTable_Desc* __vptr;\n};\n\nA_VTable_Desc CAVtable = { 0, &amp;C::~C_as_A };\nB_VTable_Desc CBVtable = { -8, &amp;C::~C_as_B };\n\nstruct C {\n   A_impl __aimpl;\n   B_impl __bimpl;\n   unsigned c;\n};\n</code></pre>\n<p>and the constructors of C implicitly do something like</p>\n<pre><code>this-&gt;__aimpl-&gt;__vptr = &amp;CAVtable;\nthis-&gt;__bimpl-&gt;__vptr = &amp;CBVtable;\n</code></pre>\n", "LastActivityDate": "2012-07-31T17:45:06.967", "CommentCount": "0", "CreationDate": "2012-07-31T17:45:06.967", "ParentId": "11745527", "Score": "1", "OwnerUserId": "136208"}});