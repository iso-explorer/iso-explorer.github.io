post_cb({"25764681": {"CommentCount": "1", "ViewCount": "381", "PostTypeId": "1", "LastEditorUserId": "3953367", "CreationDate": "2014-09-10T11:50:11.347", "LastActivityDate": "2014-09-10T15:17:51.343", "Title": "Weird overload function situation with QT/C++ types", "AcceptedAnswerId": "25765295", "LastEditDate": "2014-09-10T15:17:51.343", "Id": "25764681", "Score": "3", "Body": "<p>I'm having a weird problem with an overloaded function one of my work colleagues made, but we're both C++/QT newbies and can't figure out the reason for such a situation.</p>\n<p>The situation is as follows:</p>\n<p>We have an overloaded function:</p>\n<pre><code>foo(bool arg1 = false);\nfoo(const QVariant &amp;arg1, const QString &amp;arg2 = NULL, bool arg3 = false);\n</code></pre>\n<p>On the first one we have only one optional bool argument passed as value;\nOn the second we have one QVariant reference, an optional qstring reference and a bool.</p>\n<p>What happens on runtime is the when I call for example:</p>\n<pre><code>foo(\"some_c++_string\");\n</code></pre>\n<p>instead of using the 2nd one and casting the string to QVariant, it uses the first one and probably ignores the argument! The weird thing is that it doesn't even complain about not existing an overload for foo(char *) on compile time for example!\nBut if we do:</p>\n<pre><code> foo(QString(\"some_qt_string\"));\n</code></pre>\n<p>it goes to the second overload as expected.</p>\n<p>So, the question is: Why in the world does it decide to go for an overload which accepts one optional argument not even of the same type instead of using the second one and trying to use the string argument as a QVariant?</p>\n<p>It probably has something to do with passing the arguments as reference and giving them default values, but I've tried several combinations and always went wrong.</p>\n<p>Thanks for your time</p>\n", "Tags": "<c++><qt><method-overloading>", "OwnerUserId": "3953367", "AnswerCount": "3"}, "25765214": {"ParentId": "25764681", "CommentCount": "0", "Body": "<p>The second overload takes a <code>QVariant</code> by reference as it's first argument. You did not pass a <code>QVariant</code>, so this overload can never be taken. In fact, when you pass a <code>QString</code> as first argument, the second overload is still not viable and you should get a compiler error. My guess is that you are compiling with Microsoft VC and what you are observing is non-standard behavior that allows you to take an l-value reference of a temporary.</p>\n", "OwnerUserId": "1741297", "PostTypeId": "2", "Id": "25765214", "Score": "2", "CreationDate": "2014-09-10T12:14:12.793", "LastActivityDate": "2014-09-10T12:14:12.793"}, "25765295": {"ParentId": "25764681", "CommentCount": "10", "Body": "<p>That's because of the ordering of implicit conversions. Converting a string literal to a <code>bool</code> requires only a standard conversion sequence: an array-to-pointer conversion (obtaining <code>const char*</code>) and a boolean conversion (obtaining <code>bool</code>).</p>\n<p>On the other hand, converting a string literal to a <code>QVariant</code> requires a user-defined conversion sequence, since it involves a class (<code>QVariant</code>).</p>\n<p>And per C++11 13.3.3.2/2,</p>\n<blockquote>\n<p id=\"so_25764681_25765295_0\">When comparing the basic forms of implicit conversion sequences (as defined in 13.3.3.1)</p>\n<ul>\n<li>a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion\n  sequence or an ellipsis conversion sequence</li>\n</ul>\n</blockquote>\n<p>Which means that the first overload is strictly better and is thus chosen.</p>\n<hr>\n<p>I'd wager you're building with Visual Studio, by the way. Otherwise, the construct</p>\n<pre><code>foo(QString(\"some_qt_string\"));\n</code></pre>\n<p>wouldn't even compile. That's because <code>QString(\"some_qt_string\")</code> creates a temporary object, and in standard C++, temporaries cannot bind to non-const lvalue references (which your second overload takes). However, Visual Studio allows that as an extension.</p>\n</hr>", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "25765295", "Score": "4", "CreationDate": "2014-09-10T12:18:13.953", "LastActivityDate": "2014-09-10T12:18:13.953"}, "bq_ids": {"n4140": {"so_25764681_25765295_0": {"section_id": 638, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_25764681_25765295_0": {"section_id": 628, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_25764681_25765295_0": {"section_id": 666, "quality": 0.8888888888888888, "length": 8}}}, "25764980": {"ParentId": "25764681", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_25764681_25764980_0\">Why in the world does it decide to go for an overload which accepts one optional argument not even of the same type instead of using the second one and trying to use the string argument as a QVariant?</p>\n</blockquote>\n<p>Looking at the functions signature :</p>\n<p>foo(bool arg1 = false);\nfoo(QVariant &amp;arg1, QString &amp;arg2 = NULL, bool arg3 = false);</p>\n<p>The 2nd overload takes an lvalue. If you pass a <code>const char*</code>, it would require creating a QVariant rvalue.</p>\n<p>On the other hand, there is a function overload that takes a bool value, which is a better match, and is called.</p>\n<p>You also said that if you do this :</p>\n<pre><code>foo(QString(\"some_qt_string\"));  \n</code></pre>\n<p>the second is called. But it shouldn't even compile. You are passing rvalue to a function which takes a lvalue. I am not sure which compiler you use, but that is certainly wrong. Put maximum possible warning level and see what happens. I do hope you are not ignoring compiler warnings ;)</p>\n<p>The simplest solution (and maybe the best) is NOT to overload the function. Or at least not to give default arguments.</p>\n", "OwnerUserId": "476681", "LastEditorUserId": "476681", "LastEditDate": "2014-09-10T12:17:38.433", "Id": "25764980", "Score": "3", "CreationDate": "2014-09-10T12:04:16.023", "LastActivityDate": "2014-09-10T12:17:38.433"}});