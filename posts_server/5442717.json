post_cb({"5444149": {"ParentId": "5442717", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The other answers describe the POD rules pretty well. If you want to get a similar initialization style to a constructor for a POD you can use a <code>make_</code>-style function, for example:</p>\n<pre><code>struct A\n{\n    int i_;\n};\n\nA make_A(int i = 0) \n{\n    A a = { i }; \n    return a; \n}\n</code></pre>\n<p>now you can get initialized POD instances like:</p>\n<pre><code>A a = make_A();\n</code></pre>\n", "OwnerUserId": "158259", "LastEditorUserId": "296460", "LastEditDate": "2014-06-24T18:01:23.007", "Id": "5444149", "Score": "2", "CreationDate": "2011-03-26T17:59:25.767", "LastActivityDate": "2014-06-24T18:01:23.007"}, "5442717": {"CommentCount": "11", "AcceptedAnswerId": "5442736", "PostTypeId": "1", "LastEditorUserId": "246776", "CreationDate": "2011-03-26T13:48:40.277", "LastActivityDate": "2014-06-24T18:01:23.007", "LastEditDate": "2011-03-26T14:43:47.720", "ViewCount": "6545", "FavoriteCount": "0", "Title": "Can't C++ POD type have any constructor?", "Id": "5442717", "Score": "16", "Body": "<p>I have a class and a const variable.</p>\n<pre><code>struct A \n{\n    int b;\n};\n\nA const a;\n</code></pre>\n<p>The class <code>A</code> is POD and can be initialized like this.</p>\n<pre><code>A const a = { 3 };\n</code></pre>\n<p>IMHO, it looks fine to have a constructor like this.</p>\n<pre><code>struct A \n{\n    int b;\n\n    A(int newB) : b(newB)\n    {\n    }\n};\n</code></pre>\n<p>But Clang assumes <code>A</code> as non-aggregate type. Why I can't have constructor like that? Or should I do something else?</p>\n<hr>\n<p>I modified question to present my original meaning. I had wrote the <code>struct</code> as <code>class</code> by mistake, and sorry for @Johannes about confusing :)</p>\n</hr>", "Tags": "<c++><constructor><pod>", "OwnerUserId": "246776", "AnswerCount": "3"}, "5442736": {"ParentId": "5442717", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><code>POD</code> means Plain Old Data type which by definition cannot have user-defined constructor.</p>\n<p>POD is actually an aggregate type (see the next quotation). So what is aggregate? The C++ Standard says in section \u00a78.5.1/1,</p>\n<blockquote>\n<p id=\"so_5442717_5442736_0\">An aggregate is an array or a class\n  (clause 9) with <strong>no user-declared\n  constructors</strong> (12.1), no private or\n  protected nonstatic data members\n  (clause 11), no base classes (clause\n  10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>And section \u00a79/4 from the C++ Standard says,</p>\n<blockquote>\n<p id=\"so_5442717_5442736_1\">[....] A POD-struct is <strong>an aggregate class</strong> that has no non-static data\n  members of type non-POD-struct,\n  non-POD-union (or array of such types)\n  or reference, and has <strong>no user-defined\n  copy assignment operator</strong> and <strong>no\n  user-defined destructor</strong>. Similarly, a\n  POD-union is an aggregate union that\n  has no non-static data members of type\n  non-POD-struct, non-POD-union (or\n  array of such types) or reference, and\n  has <strong>no user-defined copy assignment\n  operator</strong> and <strong>no user-defined\n  destructor</strong>. A POD class is a class\n  that is either a POD-struct or a\n  POD-union.</p>\n</blockquote>\n<p>From this, its also clear that POD class/struct/union though cannot have <em>user-defined assignment operator</em> and <strong>user-defined destructor</strong> also.</p>\n<hr>\n<p>There are however other types of POD. The section \u00a73.9/10 says,</p>\n<blockquote>\n<p id=\"so_5442717_5442736_2\">Arithmetic types (3.9.1),\n  enumeration types, pointer types, and\n  pointer to member types (3.9.2), and\n  cv-qualified versions of these types\n  (3.9.3) are collectively called scalar\n  types. Scalar types, POD-struct types,\n  POD-union types (clause 9), arrays of\n  such types and cv-qualified versions\n  of these types (3.9.3) <strong>are\n  collectively called POD types</strong>.</p>\n</blockquote>\n<p>Read this FAQ : <a href=\"http://www.parashift.com/c++-faq-lite/intrinsic-types.html#faq-26.7\">What is a \"POD type\"?</a></p>\n</hr>", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-03-26T14:15:03.740", "Id": "5442736", "Score": "17", "CreationDate": "2011-03-26T13:51:07.683", "LastActivityDate": "2011-03-26T14:15:03.740"}, "5442746": {"ParentId": "5442717", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_5442717_5442746_0\">The class A is POD and can be initialized like this</p>\n</blockquote>\n<p>Sorry, that is wrong. Because <code>b</code> is private, the class is not a POD.  </p>\n<blockquote>\n<p id=\"so_5442717_5442746_1\">But Clang assumes A as non-aggregate type. Why I can't have constructor like that? Or should I do something else?</p>\n</blockquote>\n<p>This is a limitation of C++ as it exists currently. C++0x will not have this limitation anymore. While in C++0x your type is not a POD either, your initialization will work (assuming that you make that constructor <code>public</code>).</p>\n<p>(Also, I think a better term for you to use here is \"aggregate\". The requirement for using <code>{ ... }</code> is that your class is an aggregate. It doesn't have to be a POD). </p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "5442746", "Score": "5", "CreationDate": "2011-03-26T13:52:24.260", "LastActivityDate": "2011-03-26T13:52:24.260"}, "bq_ids": {"n4140": {"so_5442717_5442736_0": {"section_id": 3298, "quality": 0.631578947368421, "length": 12}, "so_5442717_5442736_2": {"section_id": 7207, "quality": 0.7837837837837838, "length": 29}}, "n3337": {"so_5442717_5442736_0": {"section_id": 3168, "quality": 0.631578947368421, "length": 12}, "so_5442717_5442736_2": {"section_id": 6951, "quality": 0.7567567567567568, "length": 28}}, "n4659": {"so_5442717_5442736_2": {"section_id": 8716, "quality": 0.7837837837837838, "length": 29}}}});