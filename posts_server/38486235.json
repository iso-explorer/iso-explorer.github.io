post_cb({"bq_ids": {"n4140": {"so_38486235_38486324_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5770}, "so_38486235_38486324_0": {"length": 8, "quality": 1.0, "section_id": 433}}, "n3337": {"so_38486235_38486324_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5543}, "so_38486235_38486324_0": {"length": 8, "quality": 1.0, "section_id": 425}}, "n4659": {"so_38486235_38486324_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7227}, "so_38486235_38486324_0": {"length": 8, "quality": 1.0, "section_id": 451}}}, "38486324": {"Id": "38486324", "PostTypeId": "2", "Body": "<p>From C++11, [class.base.init]\u00b66:</p>\n<blockquote>\n<p id=\"so_38486235_38486324_0\">If a constructor delegates to itself directly or indirectly, the program is ill-formed; no diagnostic is required.</p>\n</blockquote>\n<p>All compilers are right \u2013 the code is broken, and the compiler isn't required to tell you so. At this point you have UB; from [intro.compliance]\u00b62:</p>\n<blockquote>\n<p id=\"so_38486235_38486324_1\">If a program contains a violation of a rule for which no diagnostic is required, this International Standard places no requirement on implementations with respect to that program.</p>\n</blockquote>\n", "LastEditorUserId": "636019", "LastActivityDate": "2016-07-20T17:02:06.450", "Score": "8", "CreationDate": "2016-07-20T16:47:01.347", "ParentId": "38486235", "CommentCount": "1", "OwnerUserId": "636019", "LastEditDate": "2016-07-20T17:02:06.450"}, "38486235": {"ViewCount": "228", "Body": "<p>Consider following program. I accidentally made a mistake in it.</p>\n<pre><code>struct T {\n    int s;\n    T() : T() {\n        s=9;\n    }\n};\nint main() {\n    T t;\n}\n</code></pre>\n<p>The above code compiles &amp; runs fine in some versions of g++ like g++ 4.8.1 (See live demo <a href=\"http://melpon.org/wandbox/permlink/ROkKdTDJ3xUUPBhw\" rel=\"nofollow\">here</a> ) &amp; clang++ 3.6.0 (see live demo <a href=\"http://melpon.org/wandbox/permlink/oEza0NM8EC90C4GY\" rel=\"nofollow\">here</a> ) &amp; in MSVC++ 2015 but crashes at runtime. It gives me <strong>segmentation fault</strong> error. I think it is due to recursion I mean recursively call the constructor. But most recent versions of g++ &amp; clang++ fails to compile this code by giving following error:</p>\n<p>g++ 4.9.2 gives following error (See live demo <a href=\"http://melpon.org/wandbox/permlink/xoKqjuUdZRunkwWS\" rel=\"nofollow\">here</a> )</p>\n<pre><code>prog.cc: In constructor 'T::T()':\nprog.cc:3:10: error: constructor delegates to itself\n  T() : T() {\n</code></pre>\n<p>clang++ gives following error (See live demo <a href=\"http://coliru.stacked-crooked.com/a/ce1d74059f654f51\" rel=\"nofollow\">here</a> )</p>\n<pre><code>main.cpp:4:8: error: constructor for 'T' creates a delegation cycle [-Wdelegating-ctor-cycles]\n        T() : T() {\n              ^\n1 error generated.\n</code></pre>\n<p>So, the question here is which compiler is right here according to standard ? Is it bug in one of these compilers ? What exactly is happening here in above program? Correct me If I am wrong somewhere in my understanding. Why same program exhibits different behaviour in different versions of these compilers ?</p>\n", "AcceptedAnswerId": "38486324", "Title": "constructor delegates to itself in g++ & clang++", "CreationDate": "2016-07-20T16:42:33.697", "Id": "38486235", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-07-20T17:02:06.450", "Score": "3", "OwnerUserId": "3777958", "Tags": "<c++><c++11><constructor><language-lawyer><delegating-constructor>", "AnswerCount": "1"}});