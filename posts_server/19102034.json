post_cb({"19102034": {"CommentCount": "4", "AcceptedAnswerId": "19102344", "PostTypeId": "1", "LastEditorUserId": "2052436", "CreationDate": "2013-09-30T19:17:26.087", "LastActivityDate": "2016-01-18T11:43:09.387", "LastEditDate": "2013-09-30T19:57:47.683", "ViewCount": "2019", "FavoriteCount": "2", "Title": "shared_ptr aliasing constructor", "Id": "19102034", "Score": "9", "Body": "<p>Question about following <code>shared_ptr</code> constructor:</p>\n<pre><code>template&lt; class Y &gt;\nshared_ptr( const shared_ptr&lt;Y&gt;&amp; r, T *ptr );\n</code></pre>\n<p>Am I correct that if <code>r</code> was created using user-provided deleter, then aliasing <code>shared_ptr</code> knows that. So if aliasing <code>shared_ptr</code> is last in the group and (when going out of scope) destructs resources originally managed by <code>r</code>, it will use that user-provided deleter?</p>\n", "Tags": "<c++><c++11><shared-ptr>", "OwnerUserId": "2052436", "AnswerCount": "2"}, "34853918": {"ParentId": "19102034", "CommentCount": "0", "Body": "<p>Yes, because a deleter is stored in the shared_ptr's counter (the 'pn' member <code>boost::detail::shared_count</code>) and aliasing actually shares the counter.</p>\n", "OwnerUserId": "3825739", "PostTypeId": "2", "Id": "34853918", "Score": "0", "CreationDate": "2016-01-18T11:43:09.387", "LastActivityDate": "2016-01-18T11:43:09.387"}, "bq_ids": {"n4140": {"so_19102034_19102344_0": {"section_id": 4390, "quality": 0.7142857142857143, "length": 5}, "so_19102034_19102344_3": {"section_id": 4386, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_19102034_19102344_0": {"section_id": 4227, "quality": 0.7142857142857143, "length": 5}, "so_19102034_19102344_3": {"section_id": 4223, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_19102034_19102344_0": {"section_id": 5655, "quality": 0.8571428571428571, "length": 6}, "so_19102034_19102344_3": {"section_id": 5651, "quality": 0.8571428571428571, "length": 6}}}, "19102344": {"ParentId": "19102034", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nstruct some_type\n{\n    int i;\n};\n\nvoid my_deleter(some_type* p)\n{\nstd::cout &lt;&lt; \"my_deleter called!\" &lt;&lt; std::endl;\n    delete p;\n}\n\n#include &lt;memory&gt;\nint main()\n{\n    std::shared_ptr&lt;int&gt; pm;\n\n    {\n        // Note: better use make_shared\n        auto x = new some_type;\n        // create a shared_ptr that owns x and a deleter\n        std::shared_ptr&lt;some_type&gt; r(x, &amp;my_deleter);\n        std::cout &lt;&lt; r.use_count() &lt;&lt; std::endl;\n\n        // share ownership of x and the deleter with pm\n        pm = std::shared_ptr&lt;int&gt;(r, &amp;r-&gt;i);\n        std::cout &lt;&lt; r.use_count() &lt;&lt; std::endl;\n\n        // r gets destroyed\n    }\n    std::cout &lt;&lt; pm.use_count() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"get_deleter == 0? \" &lt;&lt; std::boolalpha\n              &lt;&lt; (nullptr == std::get_deleter&lt;decltype(&amp;my_deleter)&gt;(pm))\n              &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output:</p>\n<pre>\n1\n2\n1\nget_deleter == 0? false\nmy_deleter called!\n</pre>\n<p>N.B. I can't compile this example with a free function <code>my_deleter</code>, there's some casting error for the free <code>get_deleter</code> function (trying to cast from <code>void*</code> to a function pointer type with a <code>static_cast</code>).</p>\n<hr>\n<p>Aliasing ctor:\n[util.smartptr.shared.const]/13-14</p>\n<blockquote>\n<pre><code>template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, T *p) noexcept;\n</code></pre>\n<p id=\"so_19102034_19102344_0\">13 <em>Effects:</em> Constructs a <code>shared_ptr</code> instance that stores <code>p</code> and <em>shares ownership</em> with <code>r</code>.</p>\n<p id=\"so_19102034_19102344_1\">14 <em>Postconditions:</em> <code>get() == p &amp;&amp; use_count() == r.use_count()</code></p>\n</blockquote>\n<p>Ctor with user-provided deleter:\n[util.smartptr.shared.const]/9</p>\n<blockquote>\n<p id=\"so_19102034_19102344_2\">template shared_ptr(Y* p, D d);</p>\n<p id=\"so_19102034_19102344_3\"><em>Effects:</em> Constructs a <code>shared_ptr</code> object that <em>owns</em> the object <code>p</code> and the deleter <code>d</code>.</p>\n</blockquote>\n<p>Dtor:\n[util.smartptr.shared.dest]/1</p>\n<blockquote>\n<p id=\"so_19102034_19102344_4\">~shared_ptr();</p>\n<p id=\"so_19102034_19102344_5\">1 <em>Effects:</em></p>\n<ul>\n<li>If <code>*this</code> is <em>empty</em> or shares ownership with another <code>shared_ptr</code> instance (<code>use_count() &gt; 1</code>), there are no side effects.</li>\n<li>Otherwise, if <code>*this</code> <em>owns</em> an object <code>p</code> and a deleter <code>d</code>, <code>d(p)</code> is called.</li>\n<li>Otherwise, <code>*this</code> <em>owns</em> a pointer <code>p</code>, and <code>delete p</code> is called.</li>\n</ul>\n</blockquote>\n<p>Combining those (let's skip the assignment operators):</p>\n<ul>\n<li>The <code>shared_ptr</code> instance <code>r</code> <em>owns</em> both the object and the deleter.</li>\n<li>The aliasing ctor lets the new <code>shared_ptr</code> instance <em>share ownership</em> with <code>r</code> (i.e. for both, the object and the deleter).</li>\n<li>When the dtor of this new instance is called (or an assignment operator),\n<ul>\n<li>If <code>use_count &gt; 1</code>, no effects.</li>\n<li>Else, this instance <em>owns</em> the object which <code>r</code> pointed to <em>and</em> the deleter (if any) and will either use this deleter (if it exists) or <code>delete</code> on the object pointed to.</li>\n</ul></li>\n</ul>\n</hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2013-09-30T20:04:12.100", "Id": "19102344", "Score": "5", "CreationDate": "2013-09-30T19:36:03.783", "LastActivityDate": "2013-09-30T20:04:12.100"}});