post_cb({"bq_ids": {"n4140": {"so_36821049_36821822_0": {"length": 8, "quality": 1.0, "section_id": 5886}}, "n3337": {"so_36821049_36821822_0": {"length": 8, "quality": 1.0, "section_id": 5657}}, "n4659": {"so_36821049_36821822_0": {"length": 8, "quality": 1.0, "section_id": 7369}}}, "36821822": {"Id": "36821822", "PostTypeId": "2", "Body": "<p>After a bit of digging, I think this is what  you are looking for:</p>\n<p><strong>\u00a79.3 [class.mfct]:</strong></p>\n<blockquote>\n<p id=\"so_36821049_36821822_0\"><sup>7</sup> Previously declared member functions may be mentioned in friend declarations.</p>\n</blockquote>\n<p>So (as far as I understand the standard), your code is valid when you declare the member function before your nested class.</p>\n", "LastActivityDate": "2016-04-24T10:15:06.447", "CommentCount": "1", "CreationDate": "2016-04-24T10:15:06.447", "ParentId": "36821049", "Score": "1", "OwnerUserId": "2666289"}, "36822042": {"Id": "36822042", "PostTypeId": "2", "Body": "<p>Here's a stripped down example which perfectly compiles even with gcc-4.7 from Debian 7:</p>\n<pre><code>class B;\n\nclass C {\n    inline auto f() const -&gt; B&amp;;\n    class In {\n        friend auto C::f() const -&gt; B&amp;;\n        int i;\n    };\n};\n\nclass B {\n    int b;\n};\n\nauto C::f() const -&gt; B&amp; {\n    static B b;\n    return b;\n};\n</code></pre>\n<p>So I guess the problem is in nesting classes.</p>\n", "LastEditorUserId": "3159253", "LastActivityDate": "2016-04-24T10:45:52.333", "Score": "0", "CreationDate": "2016-04-24T10:40:44.633", "ParentId": "36821049", "CommentCount": "3", "OwnerUserId": "3159253", "LastEditDate": "2016-04-24T10:45:52.333"}, "36821049": {"ViewCount": "111", "Body": "<p>The following code, where the nested class <code>Info</code> designates two member functions of the outer class <code>Impl</code> as friends, compiles nicely with Visual C++ and g++, with the code as given below.</p>\n<p>But, if the member functions aren't declared before <code>Info</code>, then g++ complains about <em>incomplete</em> class rather than missing declaration:</p>\n<pre>\nIn file included from ../console_io.hpp:6:0,\n                 from console_io.cpp:1:\n../console_io.impl.windows.hpp:69:47: error: invalid use of incomplete type 'class console::Display::Impl'\n         friend auto Impl::api_info() const -&gt; Ref_&lt;const Api_info&gt;;\n                                               ^\n../console_io.impl.windows.hpp:62:20: note: definition of 'class console::Display::Impl' is not complete until the closing brace\n     class Display::Impl\n                    ^\n../console_io.impl.windows.hpp:70:47: error: invalid use of incomplete type 'class console::Display::Impl'\n</pre>\n<p>Minimal example:</p>\n<pre><code>struct Foo\n{\n    class Bar\n    {\n        friend void Foo::m();\n    };\n\n    void m(){}\n};\n</code></pre>\n<pre>\nfoo.cpp:5:28: error: invalid use of incomplete type 'struct Foo'\n         friend void Foo::m();\n                            ^\nfoo.cpp:1:8: note: definition of 'struct Foo' is not complete until the closing brace\n struct Foo\n        ^\n</pre>\n<p>And so by association I wonder about the formal validity of making a member function of <code>T</code> a <code>friend</code>, at a point where <code>T</code> is not yet complete.</p>\n<hr>\n<p>I present the actual original code that compiles, so that, if it's formally invalid, reasonable alternatives for this use case can be suggested. I think that I, as the one who's asking, am possibly the least competent to decide what's relevant or not for answers. Notation: <code>Ref_&lt;T&gt;</code> means <code>T&amp;</code>.</p>\n<pre><code>class Display::Impl\n{\nprivate:\n    using Api_info = impl::winapi::Console_screen_buffer_info;\n\n    inline auto api_info() const -&gt; Ref_&lt;const Api_info&gt;;   // Def. after class.\n    inline void invalidate_api_info();                      // Def. after class.\n\n    class Info\n    {\n    friend auto Impl::api_info() const -&gt; Ref_&lt;const Api_info&gt;;\n    friend void Impl::invalidate_api_info();\n    private:\n        bool        is_valid_   = false;\n        Api_info    api_info_   = {};\n    };\n\n    // State:\n    impl::winapi::Handle    text_buffer_;\n    mutable Info            info_;\n\n    Impl( Ref_&lt;const Impl&gt; ) = delete;\n    auto operator=( Ref_&lt;const Impl&gt; ) -&gt; Ref_&lt;Impl&gt; = delete;\n\npublic:\n    auto size() const\n        -&gt; Point\n    {\n        auto const api_size = api_info().dwSize;\n        return Point{ api_size.x, api_size.y };\n    }\n\n    ~Impl()\n    {}      // TODO:\n\n    Impl( const Point size )\n        : text_buffer_( impl::winapi::CreateConsoleScreenBuffer(\n            impl::winapi::flag_GENERIC_READ | impl::winapi::flag_GENERIC_WRITE,\n            0,              // No sharing\n            nullptr,        // Default security.\n            impl::winapi::flag_CONSOLE_TEXTMODE_BUFFER, // The allowed value.\n            nullptr         // Reserved.\n            ) )\n    {\n        hopefully( text_buffer_ != impl::winapi::invalid_handle_value )\n            || fail( \"console::Display: CreateConsoleScreenBuffer failed\" );\n    }\n};\n\nauto Display::Impl::api_info() const\n    -&gt; Ref_&lt;const Api_info&gt;\n{\n    if( not info_.is_valid_ )\n    {\n        impl::winapi::GetConsoleScreenBufferInfo( text_buffer_, &amp;info_.api_info_ )\n            || fail( \"GetConsoleScreenBufferInfo failed\" );\n        info_.is_valid_ = true;\n    }\n    return info_.api_info_;\n}\n\nvoid Display::Impl::invalidate_api_info()\n{ info_.is_valid_ = false; }\n</code></pre>\n</hr>", "Title": "Member function of incomplete class as friend = formally valid?", "CreationDate": "2016-04-24T08:50:34.087", "LastActivityDate": "2016-04-24T10:45:52.333", "CommentCount": "6", "LastEditDate": "2016-04-24T09:24:08.413", "PostTypeId": "1", "LastEditorUserId": "464581", "Id": "36821049", "Score": "2", "OwnerUserId": "464581", "Tags": "<c++><friend><friend-function>", "AnswerCount": "2"}});