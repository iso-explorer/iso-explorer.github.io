post_cb({"30558757": {"ParentId": "30558722", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to the C++ Standard (5.8 Shift operators)</p>\n<blockquote id=\"so_30558722_30558757_0\">\n<ol>\n<li>...<strong>The behavior is undefined</strong> if the right operand is negative, or  greater than or <strong>equal to</strong> the length in bits of the promoted\n  left operand</li>\n</ol>\n</blockquote>\n<p>The same is written in the C Standard (6.5.7 Bitwise shift operators)</p>\n<blockquote>\n<p id=\"so_30558722_30558757_1\">3 The integer promotions are performed on each of the operands. The\n  type of the result is that of the promoted left operand. If the value\n  of the right operand is negative or <strong>is greater than or equal to the\n  width of the promoted left operand, the behavior is undefined</strong>.</p>\n</blockquote>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2015-05-31T14:55:48.050", "Id": "30558757", "Score": "5", "CreationDate": "2015-05-31T14:47:06.260", "LastActivityDate": "2015-05-31T14:55:48.050"}, "30558722": {"CommentCount": "1", "ViewCount": "87", "ClosedDate": "2015-07-17T23:41:03.783", "CreationDate": "2015-05-31T14:44:21.063", "LastActivityDate": "2015-05-31T14:55:48.050", "Title": "Is right-shifting an unsigned integer by its total number of bits UB ?", "PostTypeId": "1", "Id": "30558722", "Score": "0", "Body": "<p>I wanted to check that some big calculated memory needs (stored in an <code>unsigned long long</code>) would be roughly compatible with the memory model used to compile my code.  </p>\n<p>I assumed that right-shifting the needs by the number of bits in a pointer would result in 0 if and only if memory needs would fit in the virtual address space (independently of practical OS limitations).   </p>\n<p>Unfortunately, I found out some unexpected results when shifting a 64 bit number by 64 bits on some compilers. </p>\n<p>Small demo:  </p>\n<pre><code>const int ubits =  sizeof (unsigned)*8;  // number of bits, assuming 8 per byte\nconst int ullbits =  sizeof (unsigned long long)*8; \ncout &lt;&lt; ubits &lt;&lt; \" bits for an unsigned\\n\"; \ncout &lt;&lt; ullbits &lt;&lt; \" bits for a unsigned long long \\n\";\n\nunsigned  utest=numeric_limits&lt;unsigned&gt;::max();  // some big numbers\nunsigned long long ulltest=numeric_limits&lt;unsigned long long&gt;::max();\n\ncout &lt;&lt; \"unsigned \"&lt;&lt;utest &lt;&lt; \" rshift by \" &lt;&lt; ubits &lt;&lt; \" = \"\n    &lt;&lt; (utest&gt;&gt;ubits)&lt;&lt;endl; \ncout &lt;&lt; \"unsigned long long \"&lt;&lt;ulltest &lt;&lt; \" rshift by \" &lt;&lt; ullbits &lt;&lt; \" = \"\n    &lt;&lt; (ulltest&gt;&gt;ullbits)&lt;&lt;endl; \n</code></pre>\n<p>I expected both displayed rshit results be 0.  </p>\n<p>This <a href=\"http://ideone.com/zgS3nw\" rel=\"nofollow\">works as expected with gcc</a>. </p>\n<p>But with MSVC 13 :  </p>\n<ul>\n<li>in 32 bits debug:  the 32 bit rshift on unsigned has NO EFFECT ( displays the original number) but the 64 bit shift of the unsigned long long is 0 as expected. </li>\n<li>in 64 bits debug: the rshift has NO EFFECT in both cases.  </li>\n<li>in 32 and 64 bits release: the rshif is 0 as expected in both cases.  </li>\n</ul>\n<p>I'd like to know if this is a compiler bug, or if this is undefined behaviour.  </p>\n", "Tags": "<c++><bit-shift>", "OwnerUserId": "3723423", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_30558722_30558757_0": {"section_id": 6146, "quality": 0.9285714285714286, "length": 13}, "so_30558722_30558757_1": {"section_id": 6146, "quality": 0.64, "length": 16}}, "n3337": {"so_30558722_30558757_0": {"section_id": 5909, "quality": 0.9285714285714286, "length": 13}, "so_30558722_30558757_1": {"section_id": 5909, "quality": 0.64, "length": 16}}, "n4659": {"so_30558722_30558757_0": {"section_id": 7642, "quality": 0.9285714285714286, "length": 13}, "so_30558722_30558757_1": {"section_id": 7642, "quality": 0.64, "length": 16}}}});