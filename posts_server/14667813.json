post_cb({"14667830": {"Id": "14667830", "PostTypeId": "2", "Body": "<p>As to what you're <em>trying</em> to do: the value of <code>j</code> is indeterminate.  It's just whatever happens to be on the stack when it's declared, so the assertion does <em>not necessarily</em> hold.</p>\n<hr>\n<p><strong>edit</strong>: it was pointed out that, since <code>j</code> is likely on the same place on the stack every time it's allocated, what is the expected behavior of the value?</p>\n<p>The fact that it's the same is just a fact of the implementation.  The standard states:</p>\n<blockquote>\n<p id=\"so_14667813_14667830_0\"><strong>6.2.4</strong> For such an object that does not have a variable length array type, its lifetime extends from entry into the block with which\n  it is associated until execution of that block ends in any way.\n  (Entering an enclosed block or calling a function suspends, but does\n  not end, execution of the current block.) If the block is entered\n  recursively, a new instance of the object is created each time. <strong>The\n  initial value of the object is indeterminate. If an initialization is\n  specified for the object, it is performed each time the declaration is\n  reached in the execution of the block; otherwise, the value becomes\n  indeterminate each time the declaration is reached.</strong></p>\n</blockquote>\n<p>It's indeterminate.</p>\n<p><strong>edit 2</strong>: that was the C standard.  From C++:</p>\n<blockquote>\n<p id=\"so_14667813_14667830_1\"><strong>6.7</strong> Variables with automatic storage duration (3.7.2) are initialized each\n  time their <em>declaration-statement</em> is executed. Variables with\n  automatic storage duration declared in the block are destroyed on exit\n  from the block (6.6).</p>\n</blockquote>\n</hr>", "LastEditorUserId": "2015270", "LastActivityDate": "2013-02-02T23:57:46.350", "Score": "3", "CreationDate": "2013-02-02T23:48:29.957", "ParentId": "14667813", "CommentCount": "7", "OwnerUserId": "2015270", "LastEditDate": "2013-02-02T23:57:46.350"}, "bq_ids": {"n4140": {"so_14667813_14667830_1": {"length": 19, "quality": 0.95, "section_id": 3917}}, "n3337": {"so_14667813_14667830_1": {"length": 19, "quality": 0.95, "section_id": 3777}}, "n4659": {"so_14667813_14667830_1": {"length": 19, "quality": 0.95, "section_id": 4803}}}, "14667813": {"ViewCount": "431", "Body": "<p>Consider the following piece of code:</p>\n<pre><code>int l;\nint k;\nfor (int i=0; i &lt; 2; ++i)\n{\n    int j;\n    if (i == 0) l = j;\n    if (i == 1) k = j;\n}\nassert (l == k);\n</code></pre>\n<p>Does the assertion hold? The interesting piece is if the uninitialized variable can take different values in different iterations.</p>\n<p>Some playing around with LLVM suggests that the assertion actually does hold: <em>is this actually guaranteed by the standard or if it is undefined and that it happens the way the LLVM compiler implements it?</em></p>\n", "AcceptedAnswerId": "14667830", "Title": "Will an uninitialized local variable in a loop have the same value each iteration?", "CreationDate": "2013-02-02T23:46:28.450", "Id": "14667813", "CommentCount": "8", "LastEditDate": "2013-02-03T00:18:25.207", "PostTypeId": "1", "LastEditorDisplayName": "user166390", "LastActivityDate": "2013-02-03T00:18:25.207", "Score": "-3", "OwnerUserId": "1541340", "Tags": "<c++>", "AnswerCount": "1"}});