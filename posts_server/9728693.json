post_cb({"9728764": {"ParentId": "9728693", "PostTypeId": "2", "CommentCount": "28", "Body": "<p>It's a bug.</p>\n<p>You've decided to provide <code>operator!=</code> for <em>all types ever</em> which is obviously going to cause conflicts with types which already have such an operator defined.</p>\n<p>Argument Dependent Lookup during the resolution of a call to <code>operator!=</code> between two <code>std::allocator&lt;Test&gt;</code>s inside your library implementation <sup>[1]</sup> allows the namespace of <code>Test</code> to be searched (as well as <code>std</code>) when trying to find the <code>operator!=</code> to use <sup>[2]</sup>.</p>\n<p>So:</p>\n<ul>\n<li><p>in your broken case, that namespace is the global namespace, which also contains a <code>operator!=</code> that matches. Now, this shouldn't matter, because the function in namespace <code>std</code> is a better match <sup>[3]</sup>; <strong>the VS bug is that an ambiguity is raised instead.</strong></p></li>\n<li><p>but when <code>Test</code> is instead in namespace <code>XXX</code> (despite the <code>typedef</code>), the namespace searched due to the above rule is instead the namespace <code>XXX</code>, which contains no conflicting definition for <code>operator!=</code>.</p></li>\n</ul>\n<p>Best not define operators for <em>all types ever</em> like that, in any case.</p>\n<hr>\n<p>[1] <sup> Some part of the implementation for your line <code>std::vector&lt;Test&gt; vt2 = std::move(vt);</code> on your compiler/library impl is invoking <code>bool operator!=&lt;std::allocator&lt;Test&gt;&gt;(const std::allocator&lt;Test&gt;&amp;, const std::allocator&lt;Test&gt;&amp;)</code>.</sup></p>\n<p>[2] <sup>Citations follow:</sup></p>\n<blockquote>\n<p id=\"so_9728693_9728764_0\"><sup><code>[C++11: 3.4.2/1]:</code> <strong>When the <em>postfix-expression</em> in a function call (5.2.2) is an <em>unqualified-id</em>, other namespaces not considered during the usual unqualified lookup (3.4.1) may be searched</strong>, and in those namespaces, namespace-scope friend function declarations (11.3) not otherwise visible may be found. <strong>These modifications to the search\n  depend on the types of the arguments</strong> (and for template template arguments, the namespace of the template argument).</sup></p>\n<p id=\"so_9728693_9728764_1\"><sup><code>[C++11: 3.4.2/2]:</code> <strong>For each argument type <code>T</code> in the function call, there is a set of zero or more associated namespaces</strong> and a set of zero or more associated classes <strong>to be considered</strong>. <strong>The sets of namespaces and classes is determined entirely by the types of the function arguments</strong> (and the namespace of any template template argument). Typedef names and <em>using-declarations</em> used to specify the types do not contribute to this set. <strong>The sets of namespaces and classes are determined in the following way:</strong></sup></p>\n<ul>\n<li><sup>[..]</sup></li>\n<li><sup>If <code>T</code> is a class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and its direct and indirect base classes. Its associated namespaces are the namespaces of which its associated classes are members. Furthermore, <strong>if <code>T</code> is a class template specialization, its associated namespaces and classes also include: the namespaces and classes associated with the types of the template arguments provided for template type parameters</strong> (excluding template template parameters); the namespaces of which any template template arguments are members; and the classes of which any member templates used as template template arguments are members. [ <em>Note:</em> Non-type template arguments do not contribute to the set of associated namespaces. <em>\u2014end note</em> ]</sup></li>\n<li><sup>[..]</sup></li>\n</ul>\n</blockquote>\n<p>[3] <sup>Citations follow:</sup></p>\n<blockquote>\n<p id=\"so_9728693_9728764_2\"><sup><code>[C++11: 13.3.3/1]:</code> Given these definitions, a viable function <code>F1</code> is defined to be a better function than another viable function <code>F2</code> if for all arguments <code>i</code>, <code>ICSi(F1)</code> is not a worse conversion sequence than <code>ICSi(F2)</code>, and then:</sup></p>\n<ul>\n<li><sup>[..]</sup></li>\n<li><sup><code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized than the template for <code>F2</code> according to the partial ordering rules described in 14.5.6.2.</sup></li>\n</ul>\n<p id=\"so_9728693_9728764_3\"><sup><code>[C++11: 14.5.6.2/2]:</code> Partial ordering selects which of two function templates is more specialized than the other by transforming each template in turn (see next paragraph) and performing template argument deduction using the function type. The deduction process determines whether one of the templates is more specialized than the other. If so, the more specialized template is the one chosen by the partial ordering process.</sup></p>\n</blockquote>\n<p><sup>My interpretation is that this process determines that the function in <code>std</code> is \"more specialised\" than the one in the global namespace, so there in fact should not be an ambiguity.</sup></p>\n<hr>\n<p><sub>Thanks @BoPersson and @DavidRodr\u00edguez for your valuable contributions to this kick-ass answer.</sub></p>\n</hr></hr>", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2012-03-15T23:33:24.373", "Id": "9728764", "Score": "10", "CreationDate": "2012-03-15T21:54:00.693", "LastActivityDate": "2012-03-15T23:33:24.373"}, "bq_ids": {"n4140": {"so_9728693_9728764_0": {"section_id": 7103, "quality": 0.85, "length": 34}, "so_9728693_9728764_2": {"section_id": 603, "quality": 0.7727272727272727, "length": 17}, "so_9728693_9728764_3": {"section_id": 161, "quality": 0.9333333333333333, "length": 42}, "so_9728693_9728764_1": {"section_id": 7104, "quality": 0.8913043478260869, "length": 41}}, "n3337": {"so_9728693_9728764_0": {"section_id": 6847, "quality": 0.85, "length": 34}, "so_9728693_9728764_2": {"section_id": 593, "quality": 0.7727272727272727, "length": 17}, "so_9728693_9728764_3": {"section_id": 155, "quality": 0.9333333333333333, "length": 42}, "so_9728693_9728764_1": {"section_id": 6848, "quality": 0.8913043478260869, "length": 41}}, "n4659": {"so_9728693_9728764_0": {"section_id": 8604, "quality": 0.85, "length": 34}, "so_9728693_9728764_2": {"section_id": 629, "quality": 0.7727272727272727, "length": 17}, "so_9728693_9728764_3": {"section_id": 165, "quality": 0.9333333333333333, "length": 42}, "so_9728693_9728764_1": {"section_id": 8605, "quality": 0.8043478260869565, "length": 37}}}, "9728693": {"CommentCount": "8", "CreationDate": "2012-03-15T21:47:57.203", "PostTypeId": "1", "AcceptedAnswerId": "9728764", "LastEditorUserId": "151292", "LastActivityDate": "2012-03-22T07:17:32.690", "LastEditDate": "2012-03-22T07:17:32.690", "ViewCount": "716", "FavoriteCount": "1", "Title": "Is this a VC++2010 compiler bug?", "Id": "9728693", "Score": "6", "Body": "<p>Using Visual Studio 2010 SP1:</p>\n<pre><code>#include &lt;vector&gt;\n\n//namespace XXX {\n  struct Test\n  {\n    bool operator==(const Test&amp; r) const  { return true; }\n  };\n//}\n//typedef XXX::Test Test;\n\ntemplate &lt;typename T&gt; inline bool operator!=(const T&amp; l,const T&amp; r) \n{ return !(l==r); }\n\nint main()\n{\n  std::vector&lt;Test&gt; vt;\n  std::vector&lt;Test&gt; vt2 = std::move(vt);\n  return 0;\n}\n</code></pre>\n<p>If I compile the code above as is, it fails with this error:</p>\n<pre><code>1&gt;C:\\apps\\MVS10\\VC\\include\\vector(609): error C2593: 'operator !=' is ambiguous\n1&gt;          C:\\apps\\MVS10\\VC\\include\\xmemory(268): could be 'bool std::operator !=&lt;_Ty,_Ty&gt;(const std::allocator&lt;_Ty&gt; &amp;,const std::allocator&lt;_Ty&gt; &amp;) throw()'\n1&gt;          with\n1&gt;          [\n1&gt;              _Ty=Test\n1&gt;          ]\n1&gt;          test.cpp(11): or       'bool operator !=&lt;std::allocator&lt;_Ty&gt;&gt;(const T &amp;,const T &amp;)' [found using argument-dependent lookup]\n1&gt;          with\n1&gt;          [\n1&gt;              _Ty=Test,\n1&gt;              T=std::allocator&lt;Test&gt;\n1&gt;          ]\n1&gt;          while trying to match the argument list '(std::allocator&lt;_Ty&gt;, std::allocator&lt;_Ty&gt;)'\n1&gt;          with\n1&gt;          [\n1&gt;              _Ty=Test\n1&gt;          ]\n1&gt;          C:\\apps\\MVS10\\VC\\include\\vector(606) : while compiling class template member function 'void std::vector&lt;_Ty&gt;::_Assign_rv(std::vector&lt;_Ty&gt; &amp;&amp;)'\n1&gt;          with\n1&gt;          [\n1&gt;              _Ty=Test\n1&gt;          ]\n</code></pre>\n<p>... where <code>vector(609)</code> resolves to this line:</p>\n<pre><code>        else if (get_allocator() != _Right.get_allocator())\n</code></pre>\n<p>OTOH, if I uncomment the <code>namespace XXX</code>-related lines, it compiles without complaint.</p>\n<p>I have to think this is a compiler bug but I'm looking for some independent verification.</p>\n<p><strong>EDIT:</strong>  Just by way of explanation, I came across this situation when recompiling some old code with VS2010 for the first time.  The global operator was some cruft from years past (now removed).  I just couldn't understand why some code failed and others didn't.  The code above is my distillation of the failed case (obviously, old code would not contain calls to <code>std::move()</code>).</p>\n<p><strong>UPDATE:</strong> I logged a bug with MS and they responded that this has been fixed \"in the next release of the compiler\" - which I presume means Visual C++ 11.  See: <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/731692/regression-involving-global-operator-and-std-vector\" rel=\"nofollow\">http://connect.microsoft.com/VisualStudio/feedback/details/731692/regression-involving-global-operator-and-std-vector</a></p>\n", "Tags": "<c++><visual-studio-2010><visual-c++><c++11><visual-c++-2010>", "OwnerUserId": "583604", "AnswerCount": "1"}});