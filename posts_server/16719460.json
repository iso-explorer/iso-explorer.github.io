post_cb({"16719460": {"CommentCount": "2", "ViewCount": "3175", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2013-05-23T16:43:04.843", "LastActivityDate": "2017-09-19T16:15:31.337", "Title": "Calling a virtual function from the constructor", "AcceptedAnswerId": "16719549", "LastEditDate": "2017-09-19T16:15:31.337", "Id": "16719460", "Score": "6", "Body": "<p>I'm reading <em><a href=\"https://en.wikipedia.org/wiki/Scott_Meyers\" rel=\"nofollow noreferrer\">Effective C++</a></em>, and there is the \"Item 9: Never call virtual functions during construction or destruction\". And I'm wondering if my code is fine even if it breaks this rule:</p>\n<pre><code>using namespace std;\n\nclass A{\n    public:\n        A(bool doLog){\n            if(doLog)\n               log();\n        }\n\n        virtual void log(){\n            cout &lt;&lt; \"logging A\\n\";\n        }\n};\n\n\nclass B: public A{\npublic:\n    B(bool doLog) : A(false){\n        if(doLog)\n            log();\n    }\n\n    virtual void log(){\n        cout &lt;&lt; \"logging B\\n\";\n    }\n};\n\n\nint main() {\n    A a(true);\n    B b(true);\n}\n</code></pre>\n<p>Is there something wrong with this approach? May I get in trouble when I do something more complicated?</p>\n<p>It seams to me that most answers didn't get what I did there, and they simply explained again why is calling virtual function from constructor potentially dangerous.</p>\n<p>I would like to stress out that output of my program looks like this:</p>\n<pre><code>logging A\nlogging B\n</code></pre>\n<p>So I get A logged when it is constructed and B logged when it is constructed. And that is what I <strong>want</strong>! But I'm asking if You find anything wrong(potentially dangerous) with my \"hack\" to overcome the problem with calling virtual function in constructor.</p>\n", "Tags": "<c++><constructor><virtual-functions>", "OwnerUserId": "1258071", "AnswerCount": "3"}, "16719549": {"ParentId": "16719460", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_16719460_16719549_0\">And I'm wondering if mine code is fine even if it breaks this rule:</p>\n</blockquote>\n<p>It depends on what you mean by \"fine\". Your program is well-formed, and its behavior is well-defined, so it won't invoke undefined behavior and stuff like that.</p>\n<p>However, one may expect, when seeing a call to a virtual function, that the call is resolved by invoking the implementation provided by the most derived type which overrides that function. </p>\n<p>Except that during construction, the corresponding sub-object has not been constructed yet, so the most derived subobject is the one currently being constructed. Result: the call is dispatched as if the function were not virtual. </p>\n<p>This is counter-intuitive, and your program should not rely on this behavior. Therefore, as a literate programmer, you should get used to avoid such a pattern and follow Scott Meyer's guideline.</p>\n", "OwnerUserId": "1932150", "PostTypeId": "2", "Id": "16719549", "Score": "11", "CreationDate": "2013-05-23T16:48:28.897", "LastActivityDate": "2013-05-23T16:48:28.897"}, "16719791": {"ParentId": "16719460", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It's \"fine\" in the sense of being well-defined. It may not be \"fine\" in the sense of doing what you expect.</p>\n<p>You will call the override from the class currently being constructed (or destroyed), not the final override; since the final derived class has not yet been constructed (or has already been destroyed) and so can't be accessed. So you may get in trouble if you wanted the final override to be called here.</p>\n<p>Since this behaviour is potentially confusing, it's best to avoid having to do it. I would recommend adding behaviour to a class by aggregation rather than subclassing in that situation; the class members are constructed before the constructor body, and last until after the destructor, and so are available in both those places.</p>\n<p>One thing you mustn't do is call a virtual function from the constructor or destructor if it's pure virtual in that class; that's undefined behaviour.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2013-05-23T17:07:34.853", "Id": "16719791", "Score": "4", "CreationDate": "2013-05-23T17:00:56.803", "LastActivityDate": "2013-05-23T17:07:34.853"}, "bq_ids": {"n4140": {"so_16719460_16719531_1": {"section_id": 447, "quality": 0.8, "length": 4}}, "n3337": {"so_16719460_16719531_1": {"section_id": 438, "quality": 0.8, "length": 4}}, "n4659": {"so_16719460_16719531_1": {"section_id": 469, "quality": 0.8, "length": 4}}}, "16719531": {"ParentId": "16719460", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_16719460_16719531_0\"><strong>Is there something wrong with this approach?</strong></p>\n</blockquote>\n<p>Answer from Bjarne Stroustrup:</p>\n<blockquote>\n<p id=\"so_16719460_16719531_1\"><strong>Can I call a virtual function from a constructor?</strong></p>\n<p id=\"so_16719460_16719531_2\">Yes, but be careful. It may not do what you expect. In a constructor,\n  the virtual call mechanism is disabled because overriding from derived\n  classes hasn't yet happened. Objects are constructed from the base up,\n  \"base before derived\". Consider:</p>\n<pre><code>    #include&lt;string&gt;\n    #include&lt;iostream&gt;\n    using namespace std;\n\nclass B {\npublic:\n    B(const string&amp; ss) { cout &lt;&lt; \"B constructor\\n\"; f(ss); }\n    virtual void f(const string&amp;) { cout &lt;&lt; \"B::f\\n\";}\n};\n\nclass D : public B {\npublic:\n    D(const string &amp; ss) :B(ss) { cout &lt;&lt; \"D constructor\\n\";}\n    void f(const string&amp; ss) { cout &lt;&lt; \"D::f\\n\"; s = ss; }\nprivate:\n    string s;\n};\n\nint main()\n{\n    D d(\"Hello\");\n}\n</code></pre>\n<p id=\"so_16719460_16719531_3\">the program compiles and produce</p>\n<pre><code>B constructor\nB::f\nD constructor\n</code></pre>\n<p id=\"so_16719460_16719531_4\">Note not D::f. Consider what would happen if the rule were different so that D::f() was called from B::B(): Because the constructor D::D() hadn't yet been run, D::f() would try to assign its argument to an uninitialized string s. The result would most likely be an immediate crash.\n  Destruction is done \"derived class before base class\", so virtual functions behave as in constructors: Only the local definitions are used - and no calls are made to overriding functions to avoid touching the (now destroyed) derived class part of the object.</p>\n<p id=\"so_16719460_16719531_5\">For more details see D&amp;E 13.2.4.2 or TC++PL3 15.4.3.</p>\n<p id=\"so_16719460_16719531_6\">It has been suggested that this rule is an implementation artifact. It is not so. In fact, it would be noticeably easier to implement the unsafe rule of calling virtual functions from constructors exactly as from other functions. However, that would imply that no virtual function could be written to rely on invariants established by base classes. That would be a terrible mess.</p>\n</blockquote>\n", "OwnerUserId": "1760345", "PostTypeId": "2", "Id": "16719531", "Score": "15", "CreationDate": "2013-05-23T16:47:33.957", "LastActivityDate": "2013-05-23T16:47:33.957"}});