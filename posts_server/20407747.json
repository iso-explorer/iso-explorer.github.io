post_cb({"20407747": {"CommentCount": "2", "AcceptedAnswerId": "20407779", "PostTypeId": "1", "LastEditorUserId": "3923281", "CreationDate": "2013-12-05T18:24:52.197", "LastActivityDate": "2017-06-28T02:17:49.947", "LastEditDate": "2015-06-04T21:12:12.250", "ViewCount": "2261", "FavoriteCount": "13", "Title": "Declaring type of pointers?", "Id": "20407747", "Score": "42", "Body": "<p>I just read that we need to give the type of pointers while declaring them in C (or C++)  i.e.:</p>\n<pre><code>int *point ;\n</code></pre>\n<p>As far as I know, pointers store the address of variables, and address occupies same amount of memory whatever may be the type.\nSo, why do we need to declare its type?</p>\n", "Tags": "<c++><c><pointers>", "OwnerUserId": "3067211", "AnswerCount": "10"}, "20409545": {"ParentId": "20407747", "CommentCount": "9", "Body": "<p>Lots of aforesaid statement but apan is purely right.\nNow your question \n<strong>why we define type of pointers?</strong>\nFirst definition of pointer\nA pointer which can hold the address of another variable.\nThe above definition is partial. The exact definition is \npointer is a variable which can hold the address of a variable and if we de-reference(fetch the value) it, it will returns the value of the present on that address. If a pointer is fails to returns a value on dereferencing then it is not a pointer.\nYou can try that even in gcc compiler a simple variable can also hold the address of another variable but at dereference it will give you error.\nNow the size \nIrrespective of data types the size of pointer is always equal to the size of integer on that specific compiler. So the size of pointer in gcc compiler is 4bytes(size of integer) and in turboc its size is 2bytes(size of integer). \n  Now question is why equal to size of integer.\nWhat will be the address of any variable it may be int, char, float etc the address is always a whole integer number and where the whole integer number is stores in int. That's why the size of pointer is equal to the size of int because it also stores the address which is always a pure integer data.\n Then what is the difference between an int and char of any other data types pointer. At the time of retrieval your compiler will fetch the number of bytes according to your data types other wise you will get error or not an error but for you some unpredictable result but not for me.\nSame rule apply for increment and decrement the pointer it always increment and decrement according to pointer data types.\n The size of pointer doesn't depend on the data type and hence the reason that your link list come into picture because if you try to declare the structure inside same variable then you will get compile time error because your compiler doesn't the size of structure before its complete declaration but self referential pointer of same structure are allowed why? The only answer because the size of pointer doesn't depend the size of data type. If you any query then please ask me.\nThanks\nasif aftab  </p>\n", "OwnerUserId": "2673577", "PostTypeId": "2", "Id": "20409545", "Score": "-5", "CreationDate": "2013-12-05T20:04:02.593", "LastActivityDate": "2013-12-05T20:04:02.593"}, "20407804": {"ParentId": "20407747", "CommentCount": "0", "Body": "<p>We actually don't <strong>need</strong> (see below) to declare the type, but we <strong>should</strong>. The pointer stores information about the objects location, while the type defines how much space it takes in memory.</p>\n<p>The size of the object stored at the pointed memory is needed in various cases - array creation, assigment, copying the memory, and finally - creating the object using <code>new</code>.</p>\n<p>However you can still define a <code>void</code> pointer, if you want to hide (for any reason) the type:</p>\n<pre><code>void* dontKnowWhatTypeIsHere;\n</code></pre>\n<p>A void pointer is considered an universal one. It can point to any object, and when we want to use it with a type, we'll just do <code>reinterpret_cast</code>.</p>\n", "OwnerUserId": "2180870", "PostTypeId": "2", "Id": "20407804", "Score": "0", "CreationDate": "2013-12-05T18:28:03.357", "LastActivityDate": "2013-12-05T18:28:03.357"}, "20407915": {"ParentId": "20407747", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The type of pointer comes to play while dereferencing and pointer arithmetic.\nFor example</p>\n<pre><code>int x=10;     //Lets suppose the address of x=100\nint *ptr=&amp;x;   //ptr has value 100\nprintf(\"The value of x is %d\", *ptr);\nptr++;  // ptr has value 104(if int is 4bytes)\n</code></pre>\n<p>In the above example the pointer type is int so the compiler will start looking for the values stored in the next 4 bytes(if int is 4bytes) starting from memory address 100. So the type of pointer tell the compilers that how many bytes its should look for while dereferencing. If the pointer type was not there how would the compiler would have known that how many bytes to look while dereferencing. And when we did <strong>ptr++</strong> the type of pointer tells by how much the ptr should be incremented. Here ptr is incremented by 4. </p>\n<pre><code>char c='a';   //Lets suppose the address of c = 200\nchar* ptr=&amp;c;   //ptr has value 200\nptr++;   //ptr has value 201(char assumed to be 1 byte) \n</code></pre>\n<p>The pointer type tells that ptr is incremented by 1 byte.</p>\n", "OwnerUserId": "2412529", "LastEditorUserId": "2412529", "LastEditDate": "2017-06-28T02:17:49.947", "Id": "20407915", "Score": "5", "CreationDate": "2013-12-05T18:35:02.347", "LastActivityDate": "2017-06-28T02:17:49.947"}, "bq_ids": {"n4140": {"so_20407747_20407956_3": {"section_id": 7223, "quality": 0.7777777777777778, "length": 7}, "so_20407747_20407956_1": {"section_id": 6138, "quality": 0.9230769230769231, "length": 12}, "so_20407747_20407779_0": {"section_id": 7212, "quality": 0.5714285714285714, "length": 4}, "so_20407747_20407956_4": {"section_id": 7223, "quality": 0.8, "length": 16}}, "n3337": {"so_20407747_20407956_3": {"section_id": 6967, "quality": 0.7777777777777778, "length": 7}, "so_20407747_20407956_4": {"section_id": 6967, "quality": 0.8, "length": 16}, "so_20407747_20407779_0": {"section_id": 6956, "quality": 0.5714285714285714, "length": 4}, "so_20407747_20407956_1": {"section_id": 5902, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_20407747_20407956_3": {"section_id": 8732, "quality": 0.7777777777777778, "length": 7}, "so_20407747_20407956_4": {"section_id": 8732, "quality": 0.65, "length": 13}, "so_20407747_20407779_0": {"section_id": 8721, "quality": 0.5714285714285714, "length": 4}, "so_20407747_20407956_1": {"section_id": 7635, "quality": 0.9230769230769231, "length": 12}}}, "20407786": {"ParentId": "20407747", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>One reason is in pointer arithmetic. You cannot do <code>p+1</code> unless you know the size of the element to which <code>p</code> points -- that is the size of the type to which <code>p</code> is a pointer. If you'd try <code>p+1</code> on a <code>void *p</code> you're likely to get a bad answer (it is the same as if done on a <code>char *</code> but maybe you didn't want that; it is caught by <code>-pedantic</code> as a warning and by <code>-pedantic-errors</code> as an error).</p>\n<p>Another reason is type safety. If a function receives as argument an <code>int *</code> you cannot pass a pointer to <code>char</code> (a string) there. You'd get a warning (an error with <code>-Werror</code> / <code>-pedantic-errors</code>). Consider this (dummy) code:</p>\n<pre><code>void test(int *x)\n{\n}\n\nint main()\n{\n    char *x = \"xyz\";\n    test(x);\n    return 0;\n}\n</code></pre>\n<p>Compiling (using <code>gcc (GCC) 4.8.2 20131017 (Red Hat 4.8.2-1)</code>) gives:</p>\n<pre><code>1.c: In function \u2018main\u2019:\n1.c:8:2: warning: passing argument 1 of \u2018test\u2019 from incompatible pointer type [enabled by default]\n  test(x);\n  ^\n1.c:1:6: note: expected \u2018int *\u2019 but argument is of type \u2018char *\u2019\n void test(int *x)\n      ^\n</code></pre>\n", "OwnerUserId": "371834", "LastEditorUserId": "371834", "LastEditDate": "2013-12-05T19:21:34.787", "Id": "20407786", "Score": "13", "CreationDate": "2013-12-05T18:27:11.230", "LastActivityDate": "2013-12-05T19:21:34.787"}, "20411356": {"ParentId": "20407747", "CommentCount": "0", "Body": "<p>While processors often have different instructions for \"load a byte from an address\", \"load a 16-bit halfword from an address\", and \"load a 32-bit word from an address\", and likewise for \"store\" operations, C uses the same syntax to load a byte from an address as to load any other size value.  Given the statement:</p>\n<pre><code>int n = *p;\n</code></pre>\n<p>the compiler may generate code which loads a byte, halfword, or word from the address in p and store it into n; if p is a *float, it may generate a more complicated code sequence to load a floating-point value in c, truncate it, convert to int, and store the converted value into n.  Without knowing the type of p, the compiler can't know which operation would be appropriate.</p>\n<p>Likewise, the statement <code>p++</code> may increase the address in <code>p</code> by one, two, four, or some other number.  The amount by which the address is increased will upon the declared type of p.  If the compiler doesn't know the type of p, it won't know how to adjust the address.</p>\n<p>It is possible to declare a pointer without specifying the type of the thing to which it points.  The type of such a pointer is <code>void*</code>.  One must convert a <code>void*</code> to a real pointer type before doing anything useful with it, however; the primary usefulness of <code>void*</code> lies in the fact that if a pointer is converted to <code>void*</code>, it may be passed around as a <code>void*</code> by code which knows nothing about the pointer's actual type.  If the pointer is eventually given to code which <em>does</em> know its type, and that code casts the pointer back to that type, the result will be the same as the pointer that had been converted to <code>void*</code>.</p>\n<p>Code which will have to handle pointers to things it knows nothing about can often usefully employ <code>void*</code> for such purposes, but code which does know about the things to which pointers point should generally declare pointers of the proper type.</p>\n", "OwnerUserId": "363751", "PostTypeId": "2", "Id": "20411356", "Score": "5", "CreationDate": "2013-12-05T21:41:12.387", "LastActivityDate": "2013-12-05T21:41:12.387"}, "20407896": {"ParentId": "20407747", "CommentCount": "0", "Body": "<p>So that it can perform arithmetic and other operations.\nConsider these two examples:</p>\n<pre><code>int* p; /* let the address of the memory location p pointing to be 1000*/\np++;\nprintf(\"%u\",p); /* prints 1004 since it is an integer pointer*/\n\n\nchar *p; /* let the address of the memory location p pointing to be 1000*/\np++;\nprintf(\"%u\",p); /* prints 1001 since it is an char pointer*/\n</code></pre>\n<p>I hope this helps you !</p>\n", "OwnerUserId": "2078385", "PostTypeId": "2", "Id": "20407896", "Score": "3", "CreationDate": "2013-12-05T18:33:34.840", "LastActivityDate": "2013-12-05T18:33:34.840"}, "20407830": {"ParentId": "20407747", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Because:</p>\n<ol>\n<li>addresses to different types <strong>don't need to have the same size</strong>. The standard explicitly specifies so (<a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow noreferrer\">C 2011 standard</a> (online draft), 6.2.5/28).</li>\n<li>type-safety: this allows the compiler to detect when you provide an incompatible pointer to a function, or in an assignment. This in turn prevents ugly situations where you mess up the argument order to a function.</li>\n<li>the compiler needs to know the type when the pointer is dereferenced.</li>\n<li>to do pointer arithmetic the size of the object pointed to needs to be known and thus its type.</li>\n</ol>\n<p>The last two points don't apply to <code>void</code> pointers, which is why they cannot by dereferenced and no pointer arithmetic may be done on them. The standard specifies that a <code>void</code> pointer must be big enough to hold any kind of pointer (except function pointers, which are a different story altogether) and that assignment to and from <code>void</code> pointers may be made without casts <strong>(at least in C, in C++ casts are always needed)</strong>.</p>\n", "OwnerUserId": "249237", "LastEditorUserId": "249237", "LastEditDate": "2013-12-26T14:08:25.020", "Id": "20407830", "Score": "34", "CreationDate": "2013-12-05T18:29:37.237", "LastActivityDate": "2013-12-26T14:08:25.020"}, "20407811": {"ParentId": "20407747", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You need to specify the type as the standard demands so.\nMoreover, so that there are no issues when you try to perform pointer arithmetic like addition or subtraction.</p>\n", "OwnerUserId": "2485685", "LastEditorUserId": "2485685", "LastEditDate": "2013-12-07T14:23:22.577", "Id": "20407811", "Score": "8", "CreationDate": "2013-12-05T18:28:34.860", "LastActivityDate": "2013-12-07T14:23:22.577"}, "20407779": {"ParentId": "20407747", "CommentCount": "4", "Body": "<p>Type-safety. If you don't know what <code>p</code> is supposed to point to, then there'd be nothing to prevent category errors like</p>\n<pre><code>*p = \"Nonsense\";\nint i = *p;\n</code></pre>\n<p>Static type checking is a very powerful tool for preventing all kinds of errors like that.</p>\n<p>C and C++ also support <em>pointer arithmetic</em>, which only works if the size of the target type is known.</p>\n<blockquote>\n<p id=\"so_20407747_20407779_0\">address occupies same amount of memory whatever my be the type</p>\n</blockquote>\n<p>That's true for today's popular platforms. But there have been platforms for which that wasn't the case. For example, a pointer to a multi-byte word could be smaller than a pointer to a single byte, since it doesn't need to represent the byte's offset within the word.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "20407779", "Score": "69", "CreationDate": "2013-12-05T18:26:47.990", "LastActivityDate": "2013-12-05T18:26:47.990"}, "20407956": {"ParentId": "20407747", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_20407747_20407956_0\">So, why do we need to declare its type?</p>\n</blockquote>\n<p>You want to know the type of the pointer so you can do <a href=\"http://en.wikipedia.org/wiki/Type_system#Static_type-checking\">static type checking</a>.</p>\n<p>We also need to know the type in order for <a href=\"http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/BitOp/pointer.html\">pointer arithmetic</a> to work, for example when we index into an array(<em>which is equivalent to pointer arithmetic</em>) of different size types the pointer will be adjusted by a type dependent amount. If we look at the draft C99 standard section <code>6.5.6</code> <em>Additive operators</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_20407747_20407956_1\">For addition, either both operands shall have arithmetic type, or one operand <strong>shall be a\n  pointer to an object type</strong> [...]</p>\n</blockquote>\n<p>So the pointer needs to be an <em>object type</em>, which means not incomplete or void.</p>\n<p>You also said:</p>\n<blockquote>\n<p id=\"so_20407747_20407956_2\">address occupies same amount of memory whatever may be the type. So, why do we need to declare its type?</p>\n</blockquote>\n<p>This is not always true in <em>C++</em> the size of pointers to member functions can change depending on the class type, one of the good articles that covers this is <a href=\"http://blogs.msdn.com/b/oldnewthing/archive/2004/02/09/70002.aspx\">Pointers to member functions are very strange animals</a>.</p>\n<p>Furthermore we can see that both the C99 draft standard section section <code>6.2.5</code> <em>Types</em> paragraph <em>27</em> which says:</p>\n<blockquote>\n<p id=\"so_20407747_20407956_3\">[...] Pointers to other types need not have the same representation or alignment requirements.</p>\n</blockquote>\n<p>and the draft C++ standard section <code>3.9.2</code> <em>Compound types</em> paragraph <em>3</em> says:</p>\n<blockquote>\n<p id=\"so_20407747_20407956_4\">[...] The value representation of pointer types is implementation-defined. Pointers to cv-qualified and cv-unqualified versions (3.9.3) of layout-compatible types shall have the same value representation and alignment requirements (3.11). [...]</p>\n</blockquote>\n<p>do not require <em>pointers</em> to have the same <em>representation</em> except in specific cases.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2013-12-05T22:08:23.150", "Id": "20407956", "Score": "11", "CreationDate": "2013-12-05T18:37:22.097", "LastActivityDate": "2013-12-05T22:08:23.150"}});