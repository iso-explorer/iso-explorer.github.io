post_cb({"48613156": {"Id": "48613156", "PostTypeId": "2", "Body": "<p>I'll try an answer here, open for corrections:</p>\n<blockquote>\n<p id=\"so_48612401_48613156_0\">Unsigned integers shall obey the laws of arithmetic modulo 2<sup>n</sup> where n is the number of bits in the value representation of that particular size of integer.</p>\n</blockquote>\n<p>This implies that the ranges of unsigned integers are <code>[0, 2^n - 1]</code>, I don't see how you could enforce this otherwise.</p>\n<p><a href=\"http://eel.is/c++draft/basic.types#basic.fundamental-3\" rel=\"nofollow noreferrer\">[basic.fundamental]#3</a> \u2014 Emphasis is mine</p>\n<blockquote>\n<p id=\"so_48612401_48613156_1\">For each of the standard signed integer types, there exists a corresponding (but different) standard unsigned integer type: \u201cunsigned char\u201d, \u201cunsigned short int\u201d, \u201cunsigned int\u201d, \u201cunsigned long int\u201d, and \u201cunsigned long long int\u201d, each of which occupies <strong>the same amount of storage</strong> and has the same alignment requirements as the corresponding signed integer type; that is, each signed integer type has the same object representation as its corresponding unsigned integer type. [...]\n  <strong>The range of non-negative values of a signed integer type is a subrange of the corresponding unsigned integer type</strong>, <strong>the representation of the same value in each of the two types is the same</strong>, and the value representation of each corresponding signed/unsigned type shall be the same. [...]</p>\n</blockquote>\n<p>As far as I know, these are the only constraints linking signed and unsigned integers:</p>\n<ul>\n<li>first point is that related unsigned and signed integers are represented using the same number of bits <code>n</code>;</li>\n<li>second point is that any positive value of a signed integer has the same representation in the related unsigned type.</li>\n</ul>\n<p>The three following methods of representing signed integers fullfil these constraints: <a href=\"https://en.wikipedia.org/wiki/Signed_number_representations#Signed_magnitude_representation\" rel=\"nofollow noreferrer\">Sign &amp; Amplitude</a>, <a href=\"https://en.wikipedia.org/wiki/Ones%27_complement\" rel=\"nofollow noreferrer\">Ones' complement</a>, <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" rel=\"nofollow noreferrer\">Two's complement</a>.</p>\n<p>As I read it, there are not enough constraints in  the standard to enforce two's complement representation for signed integers.</p>\n", "LastActivityDate": "2018-02-04T21:25:14.477", "Score": "2", "CreationDate": "2018-02-04T21:25:14.477", "ParentId": "48612401", "CommentCount": "0", "OwnerUserId": "2666289"}, "bq_ids": {"n4140": {"so_48612401_48612401_0": {"length": 14, "quality": 1.0, "section_id": 7213}, "so_48612401_48613156_1": {"length": 68, "quality": 0.8831168831168831, "section_id": 7212}, "so_48612401_48613156_0": {"length": 14, "quality": 1.0, "section_id": 7213}}, "n3337": {"so_48612401_48612401_0": {"length": 14, "quality": 1.0, "section_id": 6957}, "so_48612401_48613156_1": {"length": 68, "quality": 0.8831168831168831, "section_id": 6956}, "so_48612401_48613156_0": {"length": 14, "quality": 1.0, "section_id": 6957}}, "n4659": {"so_48612401_48612401_0": {"length": 14, "quality": 1.0, "section_id": 8722}, "so_48612401_48613156_1": {"length": 75, "quality": 0.974025974025974, "section_id": 8721}, "so_48612401_48613156_0": {"length": 14, "quality": 1.0, "section_id": 8722}}}, "48612401": {"ViewCount": "166", "Body": "<p>This question is about what the C++ standard imposes to the range of the fundamental integer types. In the C++17 standard, the point <code>6.9.1</code> on fundamental types has a point <code>4</code> where it says that:</p>\n<blockquote>\n<p id=\"so_48612401_48612401_0\">Unsigned integers shall obey to the laws of arithmetic modulo <code>2^n</code>\n  where <code>n</code> is the number of bits in the value representation of that\n  particular size of integer.</p>\n</blockquote>\n<p>In the C standard, it only says that if <code>[0, max]</code> is the range that can be represented by an unsigned integer, all operations that goes out of this range is reduced modulo <code>range + 1</code>. It never says that <code>range + 1</code> should be a power of 2.</p>\n<p>Does this quote of the C++ standard means that all unsigned integers have a range of the kind <code>[0, 2^n - 1]</code> ? Can we infer from that point that all signed integers have a range of the form <code>[-2^(n/2), 2^(n/2) - 1]</code>?</p>\n<p>I see nothing in the standard that say that, but the previous quote of the standard seems to imply that kind of things.</p>\n<hr>\n<p>PS: This question is different from the one which is given here as a duplicate. The question linked is about why two's complement is not enforced in the standard. My question is about what is in the actual standard.</p>\n</hr>", "Title": "Range of integers imposed by the C++ standard", "CreationDate": "2018-02-04T19:57:40.320", "LastActivityDate": "2018-02-04T21:25:14.477", "CommentCount": "4", "LastEditDate": "2018-02-04T21:21:09.150", "PostTypeId": "1", "LastEditorUserId": "3313064", "Id": "48612401", "Score": "6", "OwnerUserId": "3763545", "Tags": "<c++>", "AnswerCount": "1"}});