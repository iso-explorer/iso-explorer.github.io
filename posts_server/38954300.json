post_cb({"bq_ids": {"n4140": {"so_38954300_38954300_4": {"length": 52, "quality": 0.9285714285714286, "section_id": 5806}, "so_38954300_38954300_2": {"length": 34, "quality": 0.5230769230769231, "section_id": 381}}, "n3337": {"so_38954300_38954300_4": {"length": 43, "quality": 0.7678571428571429, "section_id": 5579}, "so_38954300_38954300_2": {"length": 34, "quality": 0.5230769230769231, "section_id": 372}}, "n4659": {"so_38954300_38954300_4": {"length": 32, "quality": 0.5714285714285714, "section_id": 7267}, "so_38954300_38954300_2": {"length": 52, "quality": 0.8, "section_id": 396}}}, "38954300": {"ViewCount": "335", "Body": "<p>As known, that standard C++11 guarantees that temporary object passed to a function will have been created before function call: <a href=\"https://stackoverflow.com/questions/38837592/does-standard-c11-guarantee-that-temporary-object-passed-to-a-function-will-ha\">Does standard C++11 guarantee that temporary object passed to a function will have been created before function call?</a></p>\n<p>But, does standard C++11 guarantee that temporary object passed to a function will have been destroyed after the end of the function (not before)?</p>\n<p>Working Draft, Standard for Programming Language C++ 2016-07-12: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf</a></p>\n<blockquote>\n<p id=\"so_38954300_38954300_0\">\u00a7 12.2 Temporary objects</p>\n<p id=\"so_38954300_38954300_1\">\u00a7 12.2 / 5</p>\n<p id=\"so_38954300_38954300_2\"><strong>There are three contexts in which temporaries are destroyed at a\n  different point than the end of the full expression.</strong> The first context\n  is when a default constructor is called to initialize an element of an\n  array with no corresponding initializer (8.6). The second context is\n  when a copy constructor is called to copy an element of an array while\n  the entire array is copied (5.1.5, 12.8). In either case, if the\n  constructor has one or more default arguments, the destruction of\n  every temporary created in a default argument is sequenced before the\n  construction of the next array element, if any. The third context is\n  when a reference is bound to a temporary.</p>\n</blockquote>\n<p>Also:</p>\n<blockquote>\n<p id=\"so_38954300_38954300_3\">\u00a7 1.9 / 10</p>\n<p id=\"so_38954300_38954300_4\">A <strong>full-expression</strong> is an expression that is not a subexpression of\n  another expression. [ Note: in some contexts, such as unevaluated\n  operands, a syntactic subexpression is considered a full-expression\n  (Clause 5). \u2014 end note ] If a language construct is defined to produce\n  an implicit call of a function, a use of the language construct is\n  considered to be an expression for the purposes of this definition. A\n  call to a destructor generated at the end of the lifetime of an object\n  other than a temporary object is an implicit full-expression.\n  Conversions applied to the result of an expression in order to satisfy\n  the requirements of the language construct in which the expression\n  appears are also considered to be part of the full-expression.</p>\n</blockquote>\n<p>Does it mean that standard C++11 guarantees that temporary object passed to a function will have been destroyed not before the function will end - and exactly at the end of the full expression?</p>\n<p><a href=\"http://ideone.com/GbEPaK\" rel=\"nofollow noreferrer\">http://ideone.com/GbEPaK</a></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct T { \n    T() { std::cout &lt;&lt; \"T created \\n\"; }\n    int val = 0;\n    ~T() { std::cout &lt;&lt; \"T destroyed \\n\"; }\n};\n\nvoid function(T t_obj, T &amp;&amp;t, int &amp;&amp;val) {\n    std::cout &lt;&lt; \"func-start \\n\";\n    std::cout &lt;&lt; t_obj.val &lt;&lt; \", \" &lt;&lt; t.val &lt;&lt; \", \" &lt;&lt; val &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"func-end \\n\";\n}\n\nint main() {\n\n    function(T(), T(), T().val);\n\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>T created \nT created \nT created \nfunc-start \n0, 0, 0\nfunc-end \nT destroyed \nT destroyed \nT destroyed \n</code></pre>\n<p>Can we say that the <code>T destroyed</code>  will always be after the <code>func-end</code>?</p>\n<p>And this:</p>\n<pre><code>function(T(), T(), T().val);\n</code></pre>\n<p>Is <strong>always</strong> equal to this:</p>\n<pre><code>{\n    T tmp1; T tmp2; T tmp3;\n    function(tmp1, tmp2, tmp3.val);\n}\n</code></pre>\n", "AcceptedAnswerId": "38954467", "Title": "Does standard C++11 guarantee that temporary object passed to a function will have been destroyed after the end of the function?", "CreationDate": "2016-08-15T11:34:16.063", "Id": "38954300", "CommentCount": "7", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:01:06.053", "LastEditorUserId": "-1", "LastActivityDate": "2016-08-15T12:56:58.393", "Score": "6", "OwnerUserId": "1558037", "Tags": "<c++><c++11><standards><lazy-sequences><sequence-points>", "AnswerCount": "1"}, "38954467": {"Id": "38954467", "PostTypeId": "2", "Body": "<p>Well, you already quoted all the text that tells us the temporary's lifetime ends at the end of the <em>full-expression</em>. So, yes, \"<code>T destroyed</code>\" will always come last.</p>\n<p>If the destruction had no observable side-effects then, per the as-if rule, it could <em>actually</em> happen at any time afterwards\u2026 but that's moot because, well, it wouldn't be observable.</p>\n<p>However, the final two snippets you presented are not <em>generally</em> equivalent, because you fixed the order of construction/initialisation in a way that it wasn't before. Function arguments have an unspecified evaluation order. Again, though, for this particular <code>T</code> the difference is not observable.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2016-08-15T11:58:18.667", "Score": "6", "CreationDate": "2016-08-15T11:46:36.620", "ParentId": "38954300", "CommentCount": "4", "OwnerUserId": "560648", "LastEditDate": "2016-08-15T11:58:18.667"}});