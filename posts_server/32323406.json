post_cb({"32323406": {"CommentCount": "1", "ViewCount": "2493", "PostTypeId": "1", "LastEditorUserId": "4671213", "CreationDate": "2015-09-01T04:12:27.750", "LastActivityDate": "2015-09-01T18:00:30.273", "Title": "What happens if a constructor throws an exception?", "AcceptedAnswerId": "32323458", "LastEditDate": "2015-09-01T04:15:59.637", "Id": "32323406", "Score": "6", "Body": "<p>Will we get UB then? I tried this:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct B\n{\n    B(){ std::cout &lt;&lt; \"B()\" &lt;&lt; std::endl; }\n    ~B(){ std::cout &lt;&lt; \"~B()\" &lt;&lt; std::endl; }\n};\n\nstruct A\n{\n    B b;\n    A(){ std::cout &lt;&lt; \"A()\" &lt;&lt; std::endl; throw std::exception(); }\n    ~A(){ std::cout &lt;&lt; \"~A()\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    A a;\n}\n</code></pre>\n<p>the desctructor was not called for netither <code>A</code> nor <code>B</code>. The actual output:</p>\n<pre><code>B()\nA()\nterminate called after throwing an instance of 'std::exception'\n  what():  std::exception\nbash: line 7: 21835 Aborted                 (core dumped) ./a.out\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/9658b14c73253700\">http://coliru.stacked-crooked.com/a/9658b14c73253700</a></p>\n<p>So any time the constructor throws during initialization of block scope variables, do we get UB?</p>\n", "Tags": "<c++><initialization>", "OwnerUserId": "4671213", "AnswerCount": "2"}, "32323458": {"ParentId": "32323406", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2015-09-01T04:17:48.293", "Score": "15", "LastEditorUserId": "3598119", "LastEditDate": "2015-09-01T18:00:30.273", "Id": "32323458", "OwnerUserId": "3598119", "Body": "<p>No, throwing an exception is the best way to signal an error during object construction. (Since there's no return value, there's no other way, other than constructing a headless object, which is bad style in C++.)</p>\n<p>From the man himself, Bjarne Stroustrup: <a href=\"http://www.stroustrup.com/bs_faq2.html#ctor-exceptions\">http://www.stroustrup.com/bs_faq2.html#ctor-exceptions</a></p>\n<p>Re: \"But my destructor was not called\"</p>\n<p>Indeed.\nIn C++ the lifetime of an object is said to begin when the constructor runs to completion. And it ends right when the destructor is called. If the ctor throws, then the dtor is not called.</p>\n<p>(But dtors of any member variable objects, whose ctors already ran to completion before <em>this</em> ctor ran, are called.)</p>\n<p>You should consult the standard, or a <em>good</em> textbook for more details, esp. related to what happens when inheritance is involved. As a general rule of thumb, destructors are called in the reverse order of construction.</p>\n<p>Your question about why \"~B\" was not called in your specific code, it's because you do not catch the exception in main. If you change your code so that main catches the exception, then \"~B()\" will be called. But, when an exception is thrown which has no catch, the implementation is free to terminate the program without calling destructors or destroying statically initialized objects.</p>\n<p>Reference in C++11 standard (emphasis mine):</p>\n<blockquote>\n<p id=\"so_32323406_32323458_0\">15.5.1 <strong>The std::terminate() function</strong> [except.terminate]</p>\n<p id=\"so_32323406_32323458_1\"><em>1</em>\n  In some situations exception handling must be abandoned for less subtle error handling techniques.</p>\n<p id=\"so_32323406_32323458_2\">...</p>\n<p id=\"so_32323406_32323458_3\"><em>2</em> \n  In such cases, std::terminate() is called (18.8.3). <strong>In the situation where no matching handler is found, it is implementation-defined whether or not the stack is unwound before std::terminate() is called.</strong></p>\n</blockquote>\n", "LastActivityDate": "2015-09-01T18:00:30.273"}, "bq_ids": {"n4140": {"so_32323406_32323458_1": {"section_id": 3382, "quality": 1.0, "length": 11}, "so_32323406_32323458_3": {"section_id": 3383, "quality": 0.8823529411764706, "length": 15}}, "n3337": {"so_32323406_32323458_1": {"section_id": 3251, "quality": 1.0, "length": 11}, "so_32323406_32323458_3": {"section_id": 3252, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_32323406_32323458_1": {"section_id": 4142, "quality": 1.0, "length": 11}, "so_32323406_32323458_3": {"section_id": 4143, "quality": 0.8823529411764706, "length": 15}}}, "32323466": {"ParentId": "32323406", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-09-01T04:18:28.173", "Score": "3", "LastEditorUserId": "1609614", "LastEditDate": "2015-09-01T04:20:18.993", "Id": "32323466", "OwnerUserId": "1609614", "Body": "<p>Throwing exceptions in the constructor is standard way of the error handling and is not an undefined behavior. If you throw in constructor it is assumed that an object was not initialized properly, so its destructor is not called.</p>\n", "LastActivityDate": "2015-09-01T04:20:18.993"}});