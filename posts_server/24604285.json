post_cb({"bq_ids": {"n4140": {"so_24604285_24604504_0": {"length": 11, "quality": 1.0, "section_id": 6325}}, "n3337": {"so_24604285_24604504_0": {"length": 11, "quality": 1.0, "section_id": 6082}}, "n4659": {"so_24604285_24604504_0": {"length": 11, "quality": 1.0, "section_id": 7835}}}, "24604504": {"Id": "24604504", "PostTypeId": "2", "Body": "<p>\u00a717.6.4.9 [res.on.arguments]:</p>\n<blockquote>\n<p id=\"so_24604285_24604504_0\">Each of the following applies to all arguments to functions defined in the C++ standard library, unless explicitly stated otherwise.</p>\n<ul>\n<li>[...]</li>\n<li>If a function argument binds to an rvalue reference parameter, the implementation may assume that\n  this parameter is a unique reference to this argument. [ Note: If the parameter is a generic parameter of the form <code>T&amp;&amp;</code> and an lvalue of type <code>A</code> is bound, the argument binds to an lvalue reference (14.8.2.1) and thus is not covered by the previous sentence. \u2014 end note ] [ Note: If a program casts an lvalue to an xvalue while passing that lvalue to a library function (e.g. by calling the function with the argument <code>move(x)</code>), the program is effectively asking that function to treat that lvalue as a temporary. The implementation is free to optimize away aliasing checks which might be needed if the argument was an lvalue. \u2014 end note ]</li>\n</ul>\n</blockquote>\n<p>Since \"the implementation may assume that this parameter is a unique reference to this argument\", and self-move-assignment would violate this assumption, it has undefined behavior.</p>\n<p>See also <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204\" rel=\"nofollow\">LWG issue 1204</a>.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-03T09:25:01.960", "Score": "4", "CreationDate": "2014-07-07T06:49:58.640", "ParentId": "24604285", "CommentCount": "15", "LastEditDate": "2014-08-03T09:25:01.960", "OwnerUserId": "2756719"}, "24604285": {"ViewCount": "677", "Body": "<p>Example code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{   \n    std::vector&lt;int&gt; w(20, 123), x;\n    w = std::move(w);\n    std::cout &lt;&lt; w.size() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output on g++ 4.8.3: <code>0</code></p>\n<p>Of course, the standard says that the move-assignment operator leaves the operand in an unspecified state. For example if the code were <code>x = std::move(w);</code> then we would expect <code>w.size()</code> to be zero.</p>\n<p>However, is there a specified ordering or other clause that covers the self-move case?  Is it unspecified whether size is <code>0</code> or <code>20</code>, or something else, or undefined behaviour? Do the standard containers have any defined semantics here?</p>\n<p>Related: <a href=\"https://stackoverflow.com/questions/9322174/move-assignment-operator-and-if-this-rhs\">this thread</a> talks about whether you should care about self-move in your own classes, but does not discuss whether standard containers' move-assignment operators do, and doesn't provide Standard references.</p>\n<p>NB. Is this exactly identical to <code>w = static_cast&lt; std::vector&lt;int&gt; &amp;&amp; &gt;(w);</code> or does the fact that <code>std::move</code> is a function make a difference?</p>\n", "AcceptedAnswerId": "24604504", "Title": "Behaviour of move-assignment to self", "CreationDate": "2014-07-07T06:32:56.793", "Id": "24604285", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:05:44.470", "LastEditorUserId": "-1", "LastActivityDate": "2014-08-03T09:25:01.960", "ClosedDate": "2014-07-07T07:44:18.990", "Score": "5", "OwnerUserId": "1505939", "Tags": "<c++><move-semantics>", "AnswerCount": "1"}});