post_cb({"28326974": {"Id": "28326974", "PostTypeId": "2", "Body": "<p><code>a&lt;b</code> is a compile time constant only if both <code>a</code> and <code>b</code> are compile time constants.</p>\n<p>This works for me:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;bool&gt;\nvoid foo(){ };\n\nconst int a = 4;\nconst int b = 5;\nint main(){ foo&lt;a&lt;b&gt;();}\n</code></pre>\n", "LastActivityDate": "2015-02-04T16:53:09.497", "CommentCount": "0", "CreationDate": "2015-02-04T16:53:09.497", "ParentId": "28326857", "Score": "2", "OwnerUserId": "434551"}, "28326857": {"ViewCount": "70", "Body": "<p>I thought the following programm is well-formed:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;bool&gt;\nvoid foo(){ };\n\nint a = 4;\nint b = 5;\nint main(){ foo&lt;a&lt;b&gt;(); }\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/e05c636ebe48eaf3\" rel=\"nofollow\"><strong>DEMO</strong></a></p>\n<p>The reason I was thinking that way was (<code>N4296::14.2/3 [temp.names]</code>):</p>\n<blockquote>\n<p id=\"so_28326857_28326857_0\">After name lookup (3.4) finds that a name is a <code>template-name</code> or that\n  an <code>operator-function-id</code> or a <code>literal operator-id</code> refers to a set of\n  overloaded functions any member of which is a function template, if\n  this is followed by a <code>&lt;</code>, the <code>&lt;</code> is always taken as the delimiter of a\n  <code>template-argument-list</code> and never as the less-than operator. When\n  parsing a <code>template-argument-list</code>, the first non-nested <code>&gt;</code> is taken\n  as the ending delimiter rather than a greater-than operator.</p>\n</blockquote>\n<p>In that example we can see that the first <code>&lt;</code> in the <code>foo&lt;a&lt;b&gt;()</code> expression is being treated as a start point of the template arguments. The template arguments is up to the first <code>&gt;</code>, so <code>a&lt;b</code> should be considered as just an argument. But it wasn't, what's wrong?</p>\n", "Title": "Is it possible to pass an expression containing lt or gt operators as a template parameter?", "CreationDate": "2015-02-04T16:47:52.987", "LastActivityDate": "2015-02-04T16:57:28.493", "CommentCount": "7", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "Id": "28326857", "Score": "0", "Tags": "<c++><templates>", "AnswerCount": "2"}, "28326963": {"Id": "28326963", "PostTypeId": "2", "Body": "<p>Yes, this is possible, as long as the expression is a compile-time constant expression.</p>\n<p>All you need to do is to make your <code>int</code> a <code>constexpr</code>. You may want to add parentheses around your expression for the human readers of your code (compiler will have no problem parsing <code>foo&lt;a&lt;b&gt;</code> correctly, while humans would think there's a missing <code>&gt;</code> at the end):</p>\n<pre><code>constexpr int a = 4;\nconstexpr int b = 5;\nint main(){ foo&lt;(a&lt;b)&gt;(); return 0;}\n</code></pre>\n<p><a href=\"http://ideone.com/4grxGp\" rel=\"nofollow\">Demo.</a></p>\n", "LastEditorUserId": "434551", "LastActivityDate": "2015-02-04T16:57:28.493", "Score": "7", "CreationDate": "2015-02-04T16:52:47.723", "ParentId": "28326857", "CommentCount": "0", "OwnerUserId": "335858", "LastEditDate": "2015-02-04T16:57:28.493"}, "bq_ids": {"n4140": {"so_28326857_28326857_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 71}}, "n3337": {"so_28326857_28326857_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 66}}, "n4659": {"so_28326857_28326857_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 73}}}});