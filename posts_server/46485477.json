post_cb({"46485781": {"ParentId": "46485477", "CommentCount": "0", "Body": "<p>The syntax</p>\n<pre><code>d-&gt;Derived::foo();\n</code></pre>\n<p>will suppress virtual dispatch and guarantee that the function <code>Derived::foo</code> is the one called, even in the presence of overriding functions.</p>\n<p>This is rarely what you want, but I cannot suggest alternative solutions unless you explain why you're trying to do this. For example, in the code snippet given, there is no reason why the <code>Derived</code> should be dynamically allocated at all. You could just write this instead:</p>\n<pre><code>Derived d;\nd.foo();\n</code></pre>\n<p>Here, the compiler knows for sure that the dynamic type is <code>Derived</code>, so no virtual dispatch is needed.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "46485781", "Score": "5", "CreationDate": "2017-09-29T09:23:46.183", "LastActivityDate": "2017-09-29T09:23:46.183"}, "46485531": {"ParentId": "46485477", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_46485477_46485531_0\">does a call to a member function declared as virtual in a base class (but not in the deverived class)...</p>\n</blockquote>\n<p>I've stopped to read here, because if <code>Base</code> declare <code>foo</code> as virtual, <code>Derived</code> can only override <code>foo</code>, <code>Derived::foo</code> (supposedly signature match) <strong>is implicitly <code>virtual</code></strong>.</p>\n<p>The following definitions of <code>Derived::foo</code> are <em>identical</em>:</p>\n<pre><code>class Derived: public Base {\n  void foo() {}; \n};\n\nclass Derived: public Base {\n  virtual void foo() {}; \n};\n</code></pre>\n<hr>\n<p>This mechanism is called implicit virtual propagation, and <a href=\"https://stackoverflow.com/a/39087242/5470596\">this SO answer tries and explain why id was conceived that way</a>. Here is the rationale about it:</p>\n<blockquote>\n<p id=\"so_46485477_46485531_1\"><strong>10.3 Virtual functions</strong></p>\n<p id=\"so_46485477_46485531_2\">2 If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a member function <code>vf</code> with the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (or absence of same) as <code>Base::vf</code> is declared, then <code>Derived::vf</code> is also virtual (<strong>whether or not it is so declared</strong>) and it overrides <code>Base::vf</code>.</p>\n</blockquote>\n</hr>", "OwnerUserId": "5470596", "PostTypeId": "2", "Id": "46485531", "Score": "2", "CreationDate": "2017-09-29T09:10:30.843", "LastActivityDate": "2017-09-29T09:10:30.843"}, "46485477": {"CommentCount": "7", "ViewCount": "61", "PostTypeId": "1", "LastEditorUserId": "5470596", "CreationDate": "2017-09-29T09:07:08.430", "LastActivityDate": "2017-09-29T19:52:47.720", "Title": "Calling a virtual function from a derived pointer without paying the vtable price", "AcceptedAnswerId": "46485781", "LastEditDate": "2017-09-29T19:52:47.720", "Id": "46485477", "Score": "0", "Body": "<p>Considering this simple example:</p>\n<pre><code>class Base {\n    virtual void foo() {};  \n};\n\nclass Derived: public Base {\n    void foo() {}; \n}; \n\nBase    *b = new Derived;\nDerived *d = new Derived;\nb-&gt;foo();\nd-&gt;foo();\n</code></pre>\n<p>My question is: does a call to a member function declared as virtual in a base class (but not in the derived class) through a derived class pointer uses (and pay the price for) the vtable mechanism ? In the example <code>b-&gt;foo()</code> uses the vtable mechanism to call the <code>Derived::foo()</code>, but <code>d-&gt;foo()</code>?</p>\n<p>If yes, how circumvent this behavior: when using explicitly a <code>Derived</code> pointer, I would like to directly call the <code>Derived::foo()</code> method without paying the cost of the vtable, as if the base class does not exist?</p>\n", "Tags": "<c++><performance><polymorphism><vtable>", "OwnerUserId": "956486", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_46485477_46485531_0": {"section_id": 447, "quality": 0.6363636363636364, "length": 7}, "so_46485477_46485531_2": {"section_id": 7003, "quality": 0.9375, "length": 30}}, "n3337": {"so_46485477_46485531_0": {"section_id": 438, "quality": 0.6363636363636364, "length": 7}, "so_46485477_46485531_2": {"section_id": 6749, "quality": 0.9375, "length": 30}}, "n4659": {"so_46485477_46485531_0": {"section_id": 469, "quality": 0.6363636363636364, "length": 7}, "so_46485477_46485531_2": {"section_id": 8500, "quality": 0.9375, "length": 30}}}});