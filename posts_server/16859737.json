post_cb({"16859807": {"ParentId": "16859737", "CommentCount": "1", "Body": "<p>Here's a simple set of guidelines for when you should make your destructor virtual</p>\n<p><a href=\"http://www.parashift.com/c++-faq/virtual-dtors.html\" rel=\"nofollow\">http://www.parashift.com/c++-faq/virtual-dtors.html</a></p>\n<p>If you intend to prevent objects of the derived class from being constructed, then make the constructors private, not the <code>new</code> operator.</p>\n", "OwnerUserId": "2406758", "PostTypeId": "2", "Id": "16859807", "Score": "2", "CreationDate": "2013-05-31T14:34:34.900", "LastActivityDate": "2013-05-31T14:34:34.900"}, "16859905": {"ParentId": "16859737", "CommentCount": "2", "Body": "<p>You can use a class with a non-virtual destructor as a base class regardless of how you override <code>operator new</code> in the derived classes.</p>\n<p>The one thing that you have to be sure to avoid is using <code>delete</code> with a pointer to base if the instance being destroyed is of any derived type because this causes <em>undefined behavior</em>. Overriding <code>operator new</code> in a derived class doesn't change this fact.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "16859905", "Score": "4", "CreationDate": "2013-05-31T14:40:44.287", "LastActivityDate": "2013-05-31T14:40:44.287"}, "16860058": {"ParentId": "16859737", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The C++ language does not <em>require</em> that a base class have a <code>virtual</code> destructor.  So, the direct answer to your question is \"Yes,\"  You <strong>can</strong> have a base class that doesn't have a virtual destructor.  </p>\n<p>However, you can't instantiate a derived object and <code>delete</code> is through a base class pointer without invoking Undefined Behavior.</p>\n<pre><code>class Base\n{\n};\n\nclass Derived\n:\n  public Base\n{\n  public:\n    std::string mString;\n};\n\nBase* p = new Derived;\ndelete p;\n</code></pre>\n<p>You are <code>delete</code>ing a <code>Base</code> pointer, but the the dynamic type of <code>*p</code> is <code>Derived</code> and <code>Base</code> has no <code>virtual</code> destructor, so this invokes UB:</p>\n<h2>5.3.5/3 Delete</h2>\n<blockquote>\n<p id=\"so_16859737_16860058_0\">In the first alternative (delete object), if the static type of the\n  operand is different from its dynamic type, the static type shall be a\n  base class of the operand\u2019s dynamic type and the static type shall\n  have a virtual  destructor or the behavior is undefined. In the second\n  alternative (delete array) if the dynamic type of the object to be\n  deleted differs from its static type, the behavior is undefined.73)</p>\n</blockquote>\n<p>You also can't employ trickery like this:</p>\n<pre><code>Base* p = new Derived;\nDerived* d = dynamic_cast &lt;Derived*&gt; (p);\ndelete d;\n</code></pre>\n<p>...because you can only cast down the tree with <code>dynamic_cast</code> if the target is polymorphic -- meaning, has at least 1 <code>virtual</code> member -- which <code>Base</code> does not.</p>\n<p>So, even though the direct answer to your question is \"Yes,\" the <em>real</em> answer is, \"Don't do that.\"</p>\n", "OwnerUserId": "241536", "LastEditorUserId": "241536", "LastEditDate": "2013-05-31T15:20:08.190", "Id": "16860058", "Score": "2", "CreationDate": "2013-05-31T14:48:35.730", "LastActivityDate": "2013-05-31T15:20:08.190"}, "16860053": {"ParentId": "16859737", "CommentCount": "0", "Body": "<p>Virtual dtor is not a requirement for a base class, you certainly can do it with all defined results. And no need to using op new or anything.</p>\n<p>The problem case related to the guideline is when delete is used on a pointer to base that points to instance of derived. </p>\n<p>If your design ensures that deletion never happens that way, you can go ahead. Though it's a good idea to properly document this so future developers don't rush to \"fix\" the situation, or not break the rule.</p>\n", "OwnerUserId": "2422194", "PostTypeId": "2", "Id": "16860053", "Score": "0", "CreationDate": "2013-05-31T14:48:16.773", "LastActivityDate": "2013-05-31T14:48:16.773"}, "16859813": {"ParentId": "16859737", "CommentCount": "1", "Body": "<p>You can still say <code>Base * p = ::new Derived;</code> and thus create a dangerous situation.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "16859813", "Score": "3", "CreationDate": "2013-05-31T14:34:54.120", "LastActivityDate": "2013-05-31T14:34:54.120"}, "16859737": {"CommentCount": "7", "ViewCount": "1048", "PostTypeId": "1", "LastEditorUserId": "2257436", "CreationDate": "2013-05-31T14:30:37.157", "LastActivityDate": "2013-05-31T15:20:08.190", "Title": "How about a base class with a non-virtual destructor?", "AcceptedAnswerId": "16859813", "LastEditDate": "2013-05-31T14:40:34.130", "Id": "16859737", "Score": "0", "Body": "<p>Can I use a class without a virtual destructor as a base class, if I declare the \"operator new\" in the child class private?</p>\n<p>Can the following code cause runtime problems:</p>\n<pre><code>class B {\npublic:\n    ~B() { }\n};\n\nclass D: public B {\nprivate:\n    void* operator new(size_t);\n}\n</code></pre>\n", "Tags": "<c++><new-operator><destructor>", "OwnerUserId": "2257436", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_16859737_16860058_0": {"section_id": 6107, "quality": 0.8717948717948718, "length": 34}}, "n3337": {"so_16859737_16860058_0": {"section_id": 5873, "quality": 0.8717948717948718, "length": 34}}, "n4659": {"so_16859737_16860058_0": {"section_id": 7604, "quality": 0.8717948717948718, "length": 34}}}});