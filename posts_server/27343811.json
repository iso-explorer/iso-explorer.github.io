post_cb({"bq_ids": {"n4140": {"so_27343811_27343880_0": {"length": 11, "quality": 1.0, "section_id": 175}, "so_27343811_27343811_2": {"length": 7, "quality": 0.7, "section_id": 5382}, "so_27343811_27343811_1": {"length": 7, "quality": 0.7, "section_id": 5382}}, "n3337": {"so_27343811_27343880_0": {"length": 11, "quality": 1.0, "section_id": 169}, "so_27343811_27343811_2": {"length": 7, "quality": 0.7, "section_id": 5176}, "so_27343811_27343811_1": {"length": 7, "quality": 0.7, "section_id": 5176}}, "n4659": {"so_27343811_27343880_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 180}, "so_27343811_27343811_2": {"length": 7, "quality": 0.7, "section_id": 6806}, "so_27343811_27343811_1": {"length": 7, "quality": 0.7, "section_id": 6806}}}, "27343811": {"ViewCount": "70", "Body": "<p>Consider the following template:</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo() {\n  static_assert(sizeof(T) == 0, \"Now what?\");\n}\n</code></pre>\n<blockquote>\n<p id=\"so_27343811_27343811_0\">The standard (\u00a77.4) says:</p>\n<blockquote>\n<p id=\"so_27343811_27343811_2\">[If the condition to static_assert is false] the program is ill-formed, and the resulting diagnostic message (1.4) shall include\n    the text of the string-literal, [\u2026]</p>\n</blockquote>\n</blockquote>\n<p>(Reference taken from <a href=\"https://stackoverflow.com/a/11048906/560450\">https://stackoverflow.com/a/11048906/560450</a>)</p>\n<p>In practice, the <code>static_assert</code> will not fail until we instantiate the function template <code>foo</code>, because the use othe the template parameter forces the compiler to evalute the condition only during two-phase lookup. Therefore, the code snippet above is not deemed ill-formed unless the function template is instantiated.</p>\n<p>On the other hand, sizeof(T) &gt; 0 in C++ <a href=\"https://stackoverflow.com/a/2632075/560450\"><em>by definition</em></a>. Therefore, the value of the condition is in fact independent of any template parameter! Is a \"malicious\" compiler allowed to take advantage of this fact, and reject the program as ill-formed, regardless whether <code>foo</code> is actually instantiated or not?</p>\n", "AcceptedAnswerId": "27343880", "Title": "static_assert with dependent expression that is actually independent", "CreationDate": "2014-12-07T14:46:54.850", "Id": "27343811", "CommentCount": "0", "LastEditDate": "2017-05-23T12:21:27.580", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-07T15:00:10.437", "Score": "0", "OwnerUserId": "560450", "Tags": "<c++><templates><c++11><language-lawyer><static-assert>", "AnswerCount": "1"}, "27343880": {"Id": "27343880", "PostTypeId": "2", "Body": "<p>Yes, the compiler is allowed, but not required, to reject this.</p>\n<p>\u00a714.6 [temp.res]/p8:</p>\n<blockquote>\n<p id=\"so_27343811_27343880_0\">If no valid specialization can be generated for a template, and that\n  template is not instantiated, the template is ill-formed, no\n  diagnostic required.</p>\n</blockquote>\n<p>An easy workaround:</p>\n<pre><code>template &lt;typename T&gt;\nstruct foo_protector : std::false_type {};\n\ntemplate &lt;typename T&gt;\nvoid foo() {\n  static_assert(foo_protector&lt;T&gt;::value, \"Now what?\");\n}\n</code></pre>\n<p>The compiler is not allowed to reject <code>foo()</code>'s definition because there might be a specialization of <code>foo_protector</code>, not yet seen, such that its <code>value</code> member is <code>true</code>. As long as you don't actually write such a specialization, the <code>static_assert</code> will fire as expected.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-12-07T15:00:10.437", "Score": "6", "CreationDate": "2014-12-07T14:53:20.633", "ParentId": "27343811", "CommentCount": "2", "OwnerUserId": "2756719", "LastEditDate": "2014-12-07T15:00:10.437"}});