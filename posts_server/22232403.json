post_cb({"22233386": {"ParentId": "22232403", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>\u00a7 23.3.6.5/1 [vector.modifiers]</p>\n<blockquote>\n<p id=\"so_22232403_22233386_0\">Causes reallocation if the new size is greater than the old capacity. If no reallocation happens,\n  all the iterators and references before the insertion point remain valid.</p>\n</blockquote>\n<p>It's not stated explicitly, but this means that all iterators, references at and after the insertion point are invalidated.  This includes the <code>end</code> iterator.  This section is specifically about insert/push_back, but is still more or less accurate when it comes to erases and such as well.</p>\n<p>\u00a7 23.3.6.3/5 [vector.capacity]</p>\n<blockquote>\n<p id=\"so_22232403_22233386_1\">Reallocation invalidates all the references, pointers, and iterators referring to the elements\n  in the sequence. It is guaranteed that no reallocation takes place during insertions that happen after\n  a call to reserve() until the time when an insertion would make the size of the vector greater than\n  the value of capacity().</p>\n</blockquote>\n", "OwnerUserId": "845092", "LastEditorUserId": "845092", "LastEditDate": "2014-03-06T19:04:31.990", "Id": "22233386", "Score": "1", "CreationDate": "2014-03-06T18:52:29.947", "LastActivityDate": "2014-03-06T19:04:31.990"}, "22232447": {"ParentId": "22232403", "PostTypeId": "2", "CommentCount": "10", "Body": "<p><strong>No.</strong></p>\n<p>After you <strong>push</strong> something into a <code>std::vector</code> the <code>end()</code> iterator is <strong>always</strong> invalidated.</p>\n<p>All <strong>other</strong> iterators are valid <strong>unless</strong></p>\n<blockquote>\n<p id=\"so_22232403_22232447_0\">the new container size is greater than the previous capacity</p>\n</blockquote>\n<hr>\n<p>However there are containers whose iterators do not get invalidated after pushing. Refer to the excellent answers to <a href=\"https://stackoverflow.com/q/6438086/1097451\">this question</a>.</p>\n<hr>\n<p>If you want to remember the locations within a vector <strong>using iterators</strong> while <strong>pushing</strong> new elements, you can ensure that the new size is not greater than the old capacity using the <code>reserve()</code> member.</p>\n<pre><code>std::vector&lt;int&gt; numbers = {1,2,3};\nnumbers.reserve(4);\nint capacity = numbers.capacity();  // capacity &gt;= 4\nstd::vector&lt;int&gt;::iterator pos = numbers.begin() + 2 // any iterator before\n                                                     // the point of insertion\nnumbers.push_back(4); // new size is 4, old capacity is &gt;= 4, \n                      // therefore pos is still valid. \n</code></pre>\n</hr></hr>", "OwnerUserId": "1097451", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:28:44.717", "Id": "22232447", "Score": "6", "CreationDate": "2014-03-06T18:04:01.403", "LastActivityDate": "2014-03-06T19:03:55.010"}, "bq_ids": {"n4140": {"so_22232403_22233386_0": {"section_id": 986, "quality": 1.0, "length": 18}, "so_22232403_22232447_0": {"section_id": 986, "quality": 0.7142857142857143, "length": 5}, "so_22232403_22233386_1": {"section_id": 972, "quality": 0.9354838709677419, "length": 29}}, "n3337": {"so_22232403_22233386_0": {"section_id": 971, "quality": 1.0, "length": 18}, "so_22232403_22232447_0": {"section_id": 971, "quality": 0.7142857142857143, "length": 5}, "so_22232403_22233386_1": {"section_id": 961, "quality": 1.0, "length": 31}}, "n4659": {"so_22232403_22233386_0": {"section_id": 1049, "quality": 1.0, "length": 18}, "so_22232403_22232447_0": {"section_id": 1049, "quality": 0.7142857142857143, "length": 5}, "so_22232403_22233386_1": {"section_id": 1034, "quality": 0.9354838709677419, "length": 29}}}, "22232403": {"CommentCount": "1", "ViewCount": "82", "CreationDate": "2014-03-06T18:01:52.940", "LastActivityDate": "2014-03-06T19:04:31.990", "Title": "Can we safely rely on the location of v.end() of iterators?", "AcceptedAnswerId": "22232447", "PostTypeId": "1", "Id": "22232403", "Score": "2", "Body": "<p>For a vector <code>v</code> in STL, is it safe to store <code>v.end()</code> (eg. vector::iterator) for later use? Will I be guaranteed that when I later use the stored iterator, it will still point at the same location?</p>\n<p>Consider the following vector <code>v</code>:<br>\n<code>1, 2, 3, 4, 5</code></br></p>\n<p>I now store away <code>std::vector&lt;int&gt;::iterator it = v.end()</code>. Later, I push in 2 new elements into the vector, after which it looks like:<br>\n<code>1, 2, 3, 4, 5, 6, 7</code>.</br></p>\n<p>Can I now be assured that <code>*it == 6</code>?</p>\n", "Tags": "<c++><vector><stl><iterator>", "OwnerUserId": "3155503", "AnswerCount": "2"}});