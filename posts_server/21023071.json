post_cb({"bq_ids": {"n4140": {"so_21023071_21023071_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 3287}, "so_21023071_21023071_3": {"length": 20, "quality": 0.9523809523809523, "section_id": 3287}, "so_21023071_21023071_2": {"length": 4, "quality": 1.0, "section_id": 3287}, "so_21023071_21023071_0": {"length": 4, "quality": 1.0, "section_id": 3287}}, "n3337": {"so_21023071_21023071_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 3157}, "so_21023071_21023071_3": {"length": 20, "quality": 0.9523809523809523, "section_id": 3157}, "so_21023071_21023071_2": {"length": 4, "quality": 1.0, "section_id": 3157}, "so_21023071_21023071_0": {"length": 4, "quality": 1.0, "section_id": 3157}}}, "21027827": {"Id": "21027827", "PostTypeId": "2", "Body": "<p>The program in the OP cannot distinguish if <code>d.j</code> is being initialized to 0 or if it is uninitialized and coincidentally happens to be 0. This would be clear if the Derived object in question were to be created in memory that is already initialized to a known non-zero value, say with placement new:</p>\n<pre><code> Derived d{42};        // d.i and d.j are both 42.\n ::new (&amp;d) Derived{}; // d.i is 0, d.j is 0 per N3797 or 42 per N3337.\n</code></pre>\n<p>As <a href=\"https://stackoverflow.com/questions/21023071/need-someone-to-tell-me-the-compiler-flags-for-clang-or-g-that-would-replica?noredirect=1#comment31605116_21023071\">dyp says in his comment</a>, compilers typically track changes due to defects in the standard (as opposed to new features) and include them in their support for a particular standard revision. There is likely no compiler that compiles <em>exactly</em> the language as specified in any given standard document given that the standards are constantly in flux. When you tell, e.g., clang 3.4 to compile C++11 the language it actually implements is \"the portion of C++11 plus pertinent defect resolutions that we had implemented (IIRC all of it for 3.4) in time for the 3.4 release.\"</p>\n<p>The particular change to the <em>value-initialization</em> wording that the OP asks about happened in the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1301\" rel=\"nofollow noreferrer\" title=\"CWG DR1301\">Core Working Group (CWG) Defect Report (DR) number 1301</a> which also addressed <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1324\" rel=\"nofollow noreferrer\" title=\"CWG DR1324\">DR1324</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1368\" rel=\"nofollow noreferrer\" title=\"CWG DR1368\">DR1368</a>. As a defect resolution, compilers would then have reason to implement the change.</p>\n<p>Analysis with various compilers and versions (mostly performed by the OP) demonstrates:</p>\n<ul>\n<li><a href=\"http://rextester.com/IMELZ32973\" rel=\"nofollow noreferrer\">VS2013 has not implemented DR1301.</a></li>\n<li><a href=\"http://coliru.stacked-crooked.com/a/cd896f7a0de6a7d2\" rel=\"nofollow noreferrer\">GCC 4.6.4 also has not.</a></li>\n<li><a href=\"http://coliru.stacked-crooked.com/a/c1595f187ec9d9f2\" rel=\"nofollow noreferrer\">GCC 4.7.3 has implemented DR1301.</a></li>\n<li><a href=\"http://coliru.stacked-crooked.com/a/d5c9626788ff0912\" rel=\"nofollow noreferrer\">GCC 4.8.1 implements DR1301 as well.</a></li>\n</ul>\n<p>In summary, there's no way to force a compiler to perform <em>exactly</em> as specified, but we can usually determine what's going on anyway with some careful analysis.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-09T18:05:33.183", "CommentCount": "1", "CreationDate": "2014-01-09T18:05:33.183", "ParentId": "21023071", "Score": "3", "OwnerUserId": "923854", "LastEditDate": "2017-05-23T12:21:28.453"}, "21023071": {"ViewCount": "171", "Body": "<p>I'm trying to nail down the differences between N3337 \u00a78.5p7 (C++11) and N3797 \u00a78.5p8 (post C++11) that deal with value-initialization.</p>\n<p><strong>N3337 \u00a78.5p7</strong>:</p>\n<blockquote>\n<p id=\"so_21023071_21023071_0\">To value-initialize an object of type T means:</p>\n<ul>\n<li>if T is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the default constructor for T\n  is called (and the initialization is ill-formed if T has no accessible\n  default constructor);</li>\n<li>if T is a (possibly cv-qualified) non-union class type without a user-provided constructor, then the object is zero-initialized and, if\n  T\u2019s implicitly-declared default constructor is non-trivial, that\n  constructor is called.</li>\n<li>if T is an array type, then each element is value-initialized;</li>\n<li>otherwise, the object is zero-initialized.</li>\n</ul>\n<p id=\"so_21023071_21023071_1\">An object that is value-initialized is deemed to be constructed and thus subject to\n  provisions of this International Standard applying to \u201cconstructed\u201d\n  objects, objects \u201cfor which the constructor has completed,\u201d etc., even\n  if no constructor is invoked for the object\u2019s initialization.</p>\n</blockquote>\n<p><strong>N3797 \u00a78.5p8:</strong></p>\n<blockquote>\n<p id=\"so_21023071_21023071_2\">To value-initialize an object of type T means:</p>\n<ul>\n<li>if T is a (possibly cv-quali\ufb01ed) class type (Clause 9) with either no default constructor (12.1) or a default constructor that is\n  user-provided or deleted, then the object is default-initialized;</li>\n<li>if T is a (possibly cv-quali\ufb01ed) class type without a user-provided or deleted default constructor, then the object is zero-initialized\n  and the semantic constraints for default-initialization are checked,\n  and if T has a non-trivial default constructor, the object is\n  default-initialized;</li>\n<li>if T is an array type, then each element is value-initialized;</li>\n<li>otherwise, the object is zero-initialized.</li>\n</ul>\n<p id=\"so_21023071_21023071_3\">An object that is value-initialized is deemed to be constructed and\n  thus subject to provisions of this International Standard applying to\n  \u201cconstructed\u201d objects, objects \u201cfor which the constructor has\n  completed,\u201d etc., even if no constructor is invoked for the object\u2019s\n  initialization.</p>\n</blockquote>\n<p>Given these two rules the snippet below should give different results:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct Base {\n    int i;\n\n    Base(int i):i(i) {}\n    Base():i(10) {}\n};\n\nstruct Derived : public Base {\n    int j;\n\n    Derived(int j):Base(j), j(j) {}\n    Derived()=default;\n};\n\nint main() {\n    Derived d{};\n    std::cout &lt;&lt; \"d.i = \" &lt;&lt; d.i &lt;&lt; \"  \" &lt;&lt; \"d.j = \" &lt;&lt; d.j &lt;&lt; '\\n';\n}\n</code></pre>\n<p>as follows:</p>\n<ol>\n<li>According to N3337, the default constructor for <code>Derived</code> is called, as <code>Derived</code> has a user-provided constructor. The default constructor for <code>Derived</code> calls <code>Base</code> default constructor, which initializes <code>Derived::i = 10</code>, leaving <code>Derived::j</code> unitialized.</li>\n<li>From N3797, as <code>Derived</code> has no user-provided default constructor, nor a deleted default constructor, the second bullet point applies. That is, <code>Derived</code> is zero-initialized, i.e., both <code>Derived::i</code> and <code>Derived::j</code> are initialized with 0 and the object <code>d</code> is default-initialized, which leaves <code>Derived::i = 10</code>.</li>\n</ol>\n<p>Although my knowledge of Unixes is minimum, I've been trying to replicate these two cases, using different flags for the compilers clang++ and g++, by trial and error, in Coliru, to no avail. The results so far, all printed <code>d.i = 10  d.j = 0</code> <strong>without warnings</strong>. </p>\n", "AcceptedAnswerId": "21027827", "Title": "How to invoke clang++ or g++ to exactly replicate the requirements in two different standard versions", "CreationDate": "2014-01-09T14:34:06.553", "Id": "21023071", "CommentCount": "19", "LastEditDate": "2014-01-09T18:08:37.823", "PostTypeId": "1", "LastEditorUserId": "923854", "LastActivityDate": "2014-01-09T18:08:37.823", "Score": "4", "OwnerUserId": "2548699", "Tags": "<c++><c++11><compiler-warnings><language-lawyer><value-initialization>", "AnswerCount": "1"}});