post_cb({"28029980": {"CommentCount": "2", "AcceptedAnswerId": "28030363", "PostTypeId": "1", "LastEditorUserId": "3777958", "CreationDate": "2015-01-19T17:07:51.690", "LastActivityDate": "2016-06-15T14:01:03.143", "LastEditDate": "2016-06-15T14:01:03.143", "ViewCount": "115", "FavoriteCount": "1", "Title": "new operator allocation function order contiguity & initial values", "Id": "28029980", "Score": "2", "Body": "<p>C++ standard section 3.7.3.1 says that </p>\n<blockquote>\n<p id=\"so_28029980_28029980_0\">\"The order, contiguity, and initial value of storage allocated by\n  successive calls to an allocation function is unspecified.\"</p>\n</blockquote>\n<p>What is the meaning of order &amp; contiguity? Why it is unspecified? Why initial value is also unspecified?</p>\n", "Tags": "<c++><new-operator><dynamic-memory-allocation>", "OwnerUserId": "3777958", "AnswerCount": "2"}, "28030363": {"ParentId": "28029980", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-01-19T17:30:06.713", "Score": "6", "LastEditorUserId": "572743", "LastEditDate": "2015-01-19T17:40:42.647", "Id": "28030363", "OwnerUserId": "572743", "Body": "<p><strong>order</strong><br>\nMeans that the allocator is not constrained to returning addresses that are steadily increasing or decreasing (or any other pattern). This makes sense as memory is usually recycled and reused many times during a program's lifetime. It would be possible to ask from an allocator that the order of storage is defined in some way, but there would be very little gain (if any) opposed to considerable overhead, both in code execution and memory efficiency.</br></p>\n<p>In other words, if B is allocated after A, and C is allocated after B, then A, B, and C may appear in any ordering (ABC, BAC, CAB, CBA, ...) in memory. You know that each of the addresses of A, B, and C is valid, but nothing more.</p>\n<p>As pointed out by @Deduplicator, there exists a well-known issue in concurrent programming called \"the ABA problem\". This is, indirectly, a consequence of the fact that a newly allocated object could in principle have <em>any</em> address (note that this is somewhat advanced).<br>\nThe ABA problem occurs when you use a compare-exchange instruction to atomically modify memory locations, for example in a lockfree list or queue. Your <em>assumption</em> is that the compare-exchange detects when someone else has concurrently modified the pointer that you're trying to modify. However, <em>the truth</em> is that it only detects whether <em>the bit pattern of the address is different</em>. Now it may happen that you free an object and push another object (asking the allocator for storage) to the container and the allocator gives you back the exact same address -- this is absolutely legal. Another thread uses the compare-exchange instruction, and it passes just fine. Bang!<br>\nTo guard against this, lockfree structures often use pointers with built-in reference numbers.</br></br></p>\n<p><strong>contiguity</strong><br>\nThis is a similar constraint, which basically says that there may or may not be \"holes\" between whatever the allocator returns in subsequent allocations.</br></p>\n<p>This means, if you allocate an object of size 8, and then allocate another object, the allocator might return address <code>A</code> and address <code>A+8</code>. But it might also return address <code>A+10</code> instead for the second allocation <em>at its own discretion</em>.<br>\nThis is something that regularly happens with almost every allocation because allocators often store metadata in addition to the actual object, and usually organize memory in terms of \"buckets\" down to a particular size (most often 16 bytes).<br>\nSo if you allocate an integer (usually 4 bytes) or a pointer (usually 4 or 8 bytes), then there will be a \"hole\" between this and the next thing you allocate.</br></br></p>\n<p>Again, it would be <em>possible</em> to require that an allocator returns objects in a contiguous manner, but this would mean a serious performance impact compared to something that is relatively cheap.</p>\n<p><strong>initial value</strong><br>\nThis means no more and no less than you must properly initialize your objects and cannot assume that they have any particular value. No, memory will <strong>not</strong> be zero-initialized automatically<sup>[1]</sup>.</br></p>\n<p>Requiring from the allocator to zero-initialize memory would be possible, but it would be less efficient than possible (although not as devastating as the other two constraints).</p>\n<p><hr>\n<sup>[1]</sup> Well, in some cases, it will be. The operating system will normally zero out all pages before giving a new page to a process for the first time. This is done for security, so no secret/confidential data is leaked. That is, however, an implementation detail which is out of the scope of the C++ standard.</hr></p>\n", "LastActivityDate": "2015-01-19T17:40:42.647"}, "28030079": {"ParentId": "28029980", "CommentCount": "1", "CreationDate": "2015-01-19T17:12:57.250", "OwnerUserId": "3987536", "PostTypeId": "2", "Id": "28030079", "Score": "1", "Body": "<p>It essentially means that the <code>new</code> operator can allocate memory from wherever in the system it deems necessary, and to not rely on any ordering of allocation for your program.</p>\n", "LastActivityDate": "2015-01-19T17:12:57.250"}, "bq_ids": {"n4140": {"so_28029980_28029980_0": {"section_id": 7177, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_28029980_28029980_0": {"section_id": 6921, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_28029980_28029980_0": {"section_id": 8685, "quality": 0.9166666666666666, "length": 11}}}});