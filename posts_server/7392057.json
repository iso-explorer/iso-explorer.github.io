post_cb({"7392057": {"CreationDate": "2011-09-12T18:14:59.677", "ViewCount": "3169", "FavoriteCount": "5", "Id": "7392057", "AcceptedAnswerId": "7393666", "Score": "28", "Title": "Why can't a constant pointer be a constant expression?", "LastEditorUserId": "469935", "CommentCount": "4", "Body": "<p>The following program compiles:</p>\n<pre><code>template &lt;const int * P&gt;\nclass Test{};\n\nextern const int var = 42; //extern needed to force external linkage\n\nint main()\n{\n    Test&lt;&amp;var&gt; test;\n}\n</code></pre>\n<p>This one, however, doesn't, which is a surprise for me:</p>\n<pre><code>template &lt;const int * P&gt;\nclass Test{};\n\nextern const int var = 42; //extern needed to force external linkage\nextern const int * const ptr = &amp;var; //extern needed to force external linkage\nint main()\n{\n    Test&lt;ptr&gt; test; //FAIL! Expected constant expression.\n}\n</code></pre>\n<p>Alternative example:</p>\n<pre><code>int main()\n{\n   const int size = 42;\n   int ok[*&amp;size]; //OK\n\n   const int * const pSize = &amp;size;\n   int fail[*pSize]; //FAIL\n}\n</code></pre>\n<p>I have concluded that a pointer just can't be a constant expression regardless of whether it's const and initialized with a constant expression. </p>\n<p>Questions: </p>\n<ol>\n<li>Is my conclusion true?</li>\n<li>If so, why can't a pointer be a constant expression? If not, why don't the above programs compile?</li>\n<li>Does C++0x(C++11, if you will) change anything?</li>\n</ol>\n<p>Thanks for any insights!</p>\n", "Tags": "<c++><pointers><c++11><constant-expression>", "LastEditDate": "2011-09-12T18:19:42.343", "LastActivityDate": "2011-09-12T20:41:11.097", "PostTypeId": "1", "AnswerCount": "3", "OwnerUserId": "469935"}, "7392179": {"LastActivityDate": "2011-09-12T19:55:44.067", "CommentCount": "10", "Body": "<p>It's still not allowed in C++0x.  <code>temp.arg.nontype</code> requires:</p>\n<blockquote>\n<p id=\"so_7392057_7392179_0\">A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<ul>\n<li>for  a  non-type  template-parameter  of  integral  or  enumeration  type,  a  converted  constant  expression (5.19) of the type of the template-parameter; or</li>\n<li>the name of a non-type template-parameter; or</li>\n<li>a constant expression (5.19) that designates the address of an object with static storage duration and\n  external or internal linkage or a function with external or internal linkage, including function templates\n  and function template-ids but excluding non-static class members, <strong>expressed (ignoring parentheses) as\n  <code>&amp;</code> <em><code>id-expression</code></em></strong>, except that the &amp; may be omitted if the name refers to a function or array and shall\n  be omitted if the corresponding template-parameter is a reference; or</li>\n<li>a constant expression that evaluates to a null pointer value (4.10); or</li>\n<li>a constant expression that evaluates to a null member pointer value (4.11); or</li>\n<li>a pointer to member expressed as described in 5.3.1.</li>\n</ul>\n</blockquote>\n<hr>\n<p>original answer:</p>\n<ol>\n<li>In C++03, only integral expressions can be constant expressions.</li>\n<li>Because the standard says so (naturally).</li>\n<li>In C++0x, n3290 includes examples using <code>constexpr</code> on a pointer.  So what you are trying should now be possible, although you must now use the <code>constexpr</code> keyword instead of top-level <code>const</code>.</li>\n</ol>\n<p>There's also a gcc bug involved, <a href=\"http://ideone.com/hSPrJ\" rel=\"nofollow\">g++ rejects the standard draft's own examples of valid <code>constexpr</code> usage</a>.</p>\n</hr>", "CreationDate": "2011-09-12T18:25:20.310", "LastEditDate": "2011-09-12T19:55:44.067", "ParentId": "7392057", "Id": "7392179", "LastEditorUserId": "103167", "PostTypeId": "2", "Score": "2", "OwnerUserId": "103167"}, "7392500": {"LastActivityDate": "2011-09-12T19:04:31.757", "CommentCount": "9", "Body": "<p>The problem is because your C++ program can be loaded at any point in memory, and so the address of a global <code>var</code> may be different each time you run the program.  What happens if you run your program twice?  <code>var</code> is obviously in two different locations then.</p>\n<p>Even worse, in your example, you take the address of a variable on the stack!  look at this:  </p>\n<pre><code>void myfunction( unsigned int depth) {\n     const int myvar = depth;\n     const int * const myptr = &amp;myvar;\n     if (depth)\n         myfunction(depth-1);\n}\n</code></pre>\n<p>If main calls myfunction(3), then 3 myvars are created at seperate locations.  There's no way for the compile time to even know how <em>many</em> myvars are created, much less there exact locations.</p>\n<p>Finally: declaring a variable to be <code>const</code> means: \"I promise\", and does <em>not</em> mean that is a compile time constant.  See this example:</p>\n<pre><code>int main(int argc, char** argv) {\n    const int cargc = argc;\n    char* myargs[cargc]; //the size is constant, but not a _compile time_ constant.\n}\n</code></pre>\n", "CreationDate": "2011-09-12T18:51:56.370", "LastEditDate": "2011-09-12T19:04:31.757", "ParentId": "7392057", "Id": "7392500", "LastEditorUserId": "845092", "PostTypeId": "2", "Score": "1", "OwnerUserId": "845092"}, "7393666": {"LastActivityDate": "2011-09-12T20:41:11.097", "CommentCount": "4", "Body": "<p>It's a bit more complicated. In C++03 and C++11, <code>&amp;var</code> is a constant expression if <code>var</code> is a local static / class static or namespace scope variable. This is called an address constant expression. Initializing a class static or namespace scope pointer variable with that constant expression is guaranteed to be done before any code is run (static initialization phase), because of it being a constant expression.</p>\n<p>However only in C++11, a <em>constexpr</em> pointer variable that stores the address <code>&amp;var</code> can also be used as an address constant expression and only in C++11, you can dereference an address constant expression (actually, you can dereference even more - even local array element addresses, but let's keep it ontopic) and if it refers to a constant integral variable initialized prior to the dereference or a constexpr variable, you again get a constant expression (depending on the type and value category, the kind of constant expression may vary). As such, the following is valid C++11:</p>\n<pre><code>int const x = 42;\nconstexpr int const *px = &amp;x;\n\n// both the value of \"px\" and the value of \"*px\" are prvalue constant expressions\nint array[*px];\nint main() { return sizeof(array); }\n</code></pre>\n<blockquote>\n<p id=\"so_7392057_7393666_0\">If so, why can't a pointer be a constant expression? If not, why don't the above programs compile?</p>\n</blockquote>\n<p>This is a known limitation in the Standard's wording - it currently only allows other template parameters as arguments or <code>&amp; object</code>, for a template parameter of pointer type. Even though the compiler should be capable of doing much more.</p>\n", "CreationDate": "2011-09-12T20:33:45.983", "LastEditDate": "2011-09-12T20:41:11.097", "ParentId": "7392057", "Id": "7393666", "LastEditorUserId": "34509", "PostTypeId": "2", "Score": "10", "OwnerUserId": "34509"}, "bq_ids": {"n4140": {"so_7392057_7392179_0": {"length": 5, "quality": 1.0, "section_id": 87}}, "n3337": {"so_7392057_7392179_0": {"length": 5, "quality": 1.0, "section_id": 82}}}});