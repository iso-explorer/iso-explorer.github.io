post_cb({"bq_ids": {"n4140": {"so_6052857_6054646_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 3921}}, "n3337": {"so_6052857_6054646_1": {"length": 20, "quality": 0.7692307692307693, "section_id": 3781}}, "n4659": {"so_6052857_6054646_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 4807}}}, "6053196": {"Id": "6053196", "PostTypeId": "2", "Body": "<p>The problem is that the X::foo() method is declared as const - that means that it will not mutate (change) the object.  </p>\n<p>The ScopedLock() constructor doesn't have a overload that accepts a immutable (const) reference to a Mutex object.</p>\n<p>Fixing this requires you declare m_mutex as mutable, or provide an appropriate overloaded ScopedLock() constructor.  I'm thinking the former is preferable.</p>\n", "LastActivityDate": "2011-05-19T02:39:22.973", "CommentCount": "0", "CreationDate": "2011-05-19T02:39:22.973", "ParentId": "6052857", "Score": "0", "OwnerUserId": "389833"}, "6052975": {"Id": "6052975", "PostTypeId": "2", "Body": "<p>I'm pretty sure your problem is line 26: <code>ScopedLock(m_mutex);</code></p>\n<p>Instead, that should be something like  <code>ScopedLock a_variable_name(m_mutex);</code></p>\n<p>When I make that change, I get the expected errors:</p>\n<pre><code>constCorrectness.cpp: In member function \u2018void X::foo() const\u2019:\nconstCorrectness.cpp:26: error: no matching function for call to \u2018ScopedLock::ScopedLock(const Mutex&amp;)\u2019\nconstCorrectness.cpp:18: note: candidates are: ScopedLock::ScopedLock(const ScopedLock&amp;)\nconstCorrectness.cpp:11: note:                 ScopedLock::ScopedLock(Mutex&amp;)\nconstCorrectness.cpp:10: note:                 ScopedLock::ScopedLock()\n</code></pre>\n<p><strike> Perhaps somebody can interpret <code>ScopedLock(m_mutex)</code> for us? Does it declare a function or something? Instead of calling a constructor as expected by the questioner? </strike> <strong>Update:</strong> Striking this out. I think it's just a variable declaration (i.e. the brackets are ignored.) </p>\n", "LastEditorUserId": "146041", "LastActivityDate": "2011-05-19T02:00:29.423", "Score": "1", "CreationDate": "2011-05-19T01:54:09.970", "ParentId": "6052857", "CommentCount": "4", "OwnerUserId": "146041", "LastEditDate": "2011-05-19T02:00:29.423"}, "6052857": {"ViewCount": "291", "Body": "<p>Here is the example of the \"scoped lock\" idiom with common mistake: no local variable is created, so lock is not in effect. This code compiles flawlessly both with VC++ 2010 and Comeau C++ online:</p>\n<pre><code>class Mutex\n{\npublic:\n    void lock() {}\n};\n\nclass ScopedLock\n{\npublic:\n    ScopedLock() : m_pm(0) {}\n    ScopedLock(Mutex&amp; m) : m_pm(&amp;m) { m_pm-&gt;lock(); }\n\nprivate:\n    Mutex* m_pm;\n\nprivate:\n    ScopedLock&amp; operator =(const ScopedLock&amp;);\n    ScopedLock(const ScopedLock&amp;);\n};\n\nclass X\n{\npublic:\n    void foo() const\n    {\n        ScopedLock(m_mutex);\n    }\n\nprivate:\n    Mutex m_mutex;\n};\n\n\nint main()\n{\n    X x1;\n    x1.foo();\n}\n</code></pre>\n<p>If default constructor for ScopedLock is commented out, then both compilers give an error:</p>\n<blockquote>\n<p id=\"so_6052857_6052857_0\">error C2512: 'ScopedLock' : no appropriate default constructor available</p>\n</blockquote>\n<p>(When <code>ScopedLock</code> used correctly, i.e. local variable is created: <code>ScopedLock guard(m_mutex);</code>, then compilation fails as expected. Declaring <code>m_mutex</code> as mutable fixes the problem.)</p>\n<p>I have two questions:</p>\n<ol>\n<li><p>Why <code>X::foo</code> compiles? It seems that compiler was able to cast <code>const Mutex&amp;</code> to <code>Mutex&amp;</code> somehow.</p></li>\n<li><p>What role plays <code>ScopedLock</code> default constructor, so the compilation succeeds?</p></li>\n</ol>\n<p>Thanks.</p>\n<p><strong>Update:</strong> I found the answer. It appears that <code>ScopedLock(m_mutex);</code> statement creates a local variable <code>m_mutex</code> of type <code>ScopedLock</code>. Not a temporary. That's why <code>ScopedLock::ScopedLock</code> default constructor is required.</p>\n", "AcceptedAnswerId": "6054646", "Title": "Const correctness with temporary instances", "CreationDate": "2011-05-19T01:34:12.230", "Id": "6052857", "CommentCount": "0", "LastEditDate": "2011-05-19T01:59:26.683", "PostTypeId": "1", "LastEditorUserId": "365492", "LastActivityDate": "2011-05-19T06:25:28.383", "Score": "6", "OwnerUserId": "365492", "Tags": "<c++>", "AnswerCount": "3"}, "6054646": {"Id": "6054646", "PostTypeId": "2", "Body": "<p>You answered the question yourself. </p>\n<blockquote>\n<p id=\"so_6052857_6054646_0\">It appears that ScopedLock(m_mutex); statement creates a local variable m_mutex of type ScopedLock</p>\n</blockquote>\n<p>The explanation is to be found in the Standard's Section 6.8 Ambiguity Resolution:</p>\n<blockquote>\n<p id=\"so_6052857_6054646_1\">There is an ambiguity in the grammar involving expression-statements and declarations: An expression-statement with a function-style explicit type conversion [5.2.3] as its leftmost subexpression can be indistinguishable from a declaration where the first declarator starts with a (. <strong>In those cases the statement is a declaration</strong>.</p>\n</blockquote>\n<p>The Standard then lists <code>T(a);</code> as an example of a statement that is really a declaration. It is equivalent to <code>T a;</code></p>\n<p>This is one variation of the infamous C++ \"most vexing parse\".</p>\n", "LastActivityDate": "2011-05-19T06:25:28.383", "CommentCount": "1", "CreationDate": "2011-05-19T06:25:28.383", "ParentId": "6052857", "Score": "4", "OwnerUserId": "632030"}});