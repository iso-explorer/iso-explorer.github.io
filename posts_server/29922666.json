post_cb({"29923113": {"Id": "29923113", "PostTypeId": "2", "Body": "<p>Yes, it is valid.</p>\n<p>You can have multiple (plain) pointers pointing to the same object. The question is how long those pointers are valid or when the object pointed to is deleted.</p>\n<p>A <code>unique_ptr</code> stores one more plain pointer and takes ownership, meaning it is responsible for when the object is destroyed. Moving it to another <code>unique_ptr</code> just transfers ownership, the object itself is still the same and all plain pointers pointing to it remain valid.</p>\n<p>Only when the ownership is not transferred (or released) and the owning <code>unique_ptr</code> is destroyed, it also destroys the object. This would be the moment where all plain pointers pointing to the object become dangling pointers and dereferencing them would be illegal.</p>\n", "LastActivityDate": "2015-04-28T15:09:03.037", "CommentCount": "8", "CreationDate": "2015-04-28T15:09:03.037", "ParentId": "29922666", "Score": "8", "OwnerUserId": "2073257"}, "bq_ids": {"n4140": {"so_29922666_42990870_0": {"length": 15, "quality": 0.9375, "section_id": 4279}}, "n3337": {"so_29922666_42990870_0": {"length": 15, "quality": 0.9375, "section_id": 4120}}, "n4659": {"so_29922666_42990870_0": {"length": 15, "quality": 0.9375, "section_id": 5535}}}, "42990870": {"Id": "42990870", "PostTypeId": "2", "Body": "<p>Yes, the C++11 specification <strong>guarantees</strong> that transferring ownership of an object from one <code>unique_ptr</code> to another <code>unique_ptr</code> does not change the  location of the object itself, and that <code>get()</code> on the second <code>unique_ptr</code> returns the same as it would have on the first <code>unique_ptr</code> before the transfer.</p>\n<p>Looking at N3337, section 20.7.1:</p>\n<blockquote>\n<ol start=\"4\">\n<li><p id=\"so_29922666_42990870_0\">Additionally, <code>u</code> can, upon request, <em>transfer ownership</em> to another unique pointer <code>u2</code>. Upon completion of such a transfer, the following\n  postconditions hold:</p>\n<ul>\n<li><code>u2.p</code> is equal to the pre-transfer <code>u.p</code>,</li>\n<li><code>u.p</code> is equal to <code>nullptr</code>, and</li>\n<li>if the pre-transfer <code>u.d</code> maintained state, such state has been transferred to <code>u2.d</code>.</li>\n</ul></li>\n</ol>\n</blockquote>\n<p>where <code>u</code> is a <code>unique_ptr</code> object that stores a pointer <code>u.p</code>.</p>\n<p>The first bullet answers the question directly, since <code>get()</code> is specified as returning the <code>u.p</code>.</p>\n", "LastActivityDate": "2017-03-24T03:24:25.987", "CommentCount": "0", "CreationDate": "2017-03-24T03:24:25.987", "ParentId": "29922666", "Score": "3", "OwnerUserId": "1327867"}, "29922666": {"ViewCount": "908", "Body": "<p>Consider the following code snippet:</p>\n<pre><code>class Owner {\npublic:\n Owner(std::unique_ptr&lt;int&gt; ptr) : owned_pointer&lt;int&gt;(std:move(ptr)) {}\nprivate:\n std::unique_ptr&lt;int&gt; owned_pointer;\n};\n\n\nstd::unique_ptr&lt;int&gt; ptr(new int);\nint* ptr1 = ptr.get();\nOwner new_owner(std::move(ptr));\n</code></pre>\n<p>Is it safe to assume that ptr1 is valid as long as new_owner stays in scope? It seems to work, but I can't find a specification that states that explicitly  - is it undefined behavior/implementation specific and just happen to work for me, or the code posted above is valid (ptr1 is guaranteed to point to moved pointer as long as it stays alive)?</p>\n", "AcceptedAnswerId": "42990870", "Title": "Is value returned by std::unique_ptr::get valid after moving unique_ptr?", "CreationDate": "2015-04-28T14:53:57.550", "Id": "29922666", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-03-24T03:24:25.987", "Score": "7", "OwnerUserId": "1935008", "Tags": "<c++11><move><unique-ptr>", "AnswerCount": "2"}});