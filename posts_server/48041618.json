post_cb({"48041618": {"ViewCount": "313", "Body": "<p>Why does cppreference define type_traits xxx_v shortcuts as <code>inline constexpr</code> and not just <code>constexpr</code>? </p>\n<p>For example, see <a href=\"http://en.cppreference.com/w/cpp/types/is_integral\" rel=\"noreferrer\"><code>is_integral_v</code></a>:</p>\n<pre><code>template&lt; class T &gt;\ninline constexpr bool is_integral_v = is_integral&lt;T&gt;::value;\n</code></pre>\n<p>Is this just a matter of style or is there some difference in behavior? As far as I know <code>constexpr</code> variables are implicitly <code>inline</code>.</p>\n<p>Edit: Looking at the draft of the latest standard, it also uses <code>inline constexpr</code>. The question actually applies to the standard, then.</p>\n", "AcceptedAnswerId": "48078494", "Title": "Why does cppreference define type_traits xxx_v shortcuts as inline constexpr and not just constexpr?", "CreationDate": "2017-12-31T10:13:55.373", "LastActivityDate": "2018-01-03T13:33:54.823", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-12-31T10:20:02.957", "LastEditorUserId": "125997", "Id": "48041618", "Score": "14", "OwnerUserId": "125997", "Tags": "<c++><language-lawyer><c++17><inline-variable>", "AnswerCount": "2"}, "48041749": {"Id": "48041749", "PostTypeId": "2", "Body": "<p><a href=\"http://eel.is/c++draft/dcl.constexpr#9\" rel=\"nofollow noreferrer\">[dcl.constexpr]/9</a></p>\n<blockquote>\n<p id=\"so_48041618_48041749_0\">A constexpr specifier used in an object declaration declares the object as const.</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/basic.link#3.2\" rel=\"nofollow noreferrer\">[basic.link]/3.2</a></p>\n<blockquote>\n<p id=\"so_48041618_48041749_1\">A name having namespace scope has <em>internal linkage</em> if it is the name of</p>\n<p id=\"so_48041618_48041749_2\">-a <strong>non-inline</strong> variable of non-volatile <strong>const-qualified</strong> type that is neither explicitly declared extern nor previously declared to have external linkage</p>\n</blockquote>\n<p>Without <code>inline</code> specifier, <code>is_integral_v</code> would have internal linkage. This could be problematic if you compared two pointers to this same variable name taken in different translation unit.</p>\n<hr>\n<p>Nota Bene: the inline specifier is redundant with constexpr only if the variable is a class static data member.</p>\n<hr>\n<p>Following an exemple of easy violation of the <a href=\"http://eel.is/c++draft/basic.def.odr\" rel=\"nofollow noreferrer\">one definition rule</a> that could happen if <code>is_integral_v</code> where not inline.</p>\n<p>bad_type_trait.h</p>\n<pre><code>template&lt;class T&gt;\nconstexpr auto bad_is_integral_v=std::is_integral&lt;T&gt;::value;\n</code></pre>\n<p>my_header.h</p>\n<pre><code>#include \"bad_type_trait.h\"\nvoid f(const bool&amp; x);\n\ninline void g()\n  {\n  f(bad_is_integral_v&lt;int&gt;);\n  //g ODR use the static variable bad_is_integral_v.\n  //\"ODR use\" approximate definition is: \n  //     the variable is refered by its memory address.\n  }\n</code></pre>\n<p>source1.cpp</p>\n<pre><code>#include \"my_header.h\"\nvoid my_func1(){\n   g(); //the definition of g in this translation unit.\n   }\n</code></pre>\n<p>source2.cpp</p>\n<pre><code>#include \"my_header.h\"\nvoid my_func2(){\n   g(); //is not the same as the definition of g in this translation unit.\n   }\n</code></pre>\n<p>In the two translation units, the variable <code>bad_is_integral_v</code> is instantiated as separate static variables. The inline function <code>g()</code> is defined in these two translation units. Inside the definition of <code>g()</code>, the variable <code>bad_is_integral_v</code> is ODR used, so the two definitions of <code>g()</code> are different, which is a violation of the one definition rule.</p>\n</hr></hr>", "LastEditorUserId": "65863", "LastActivityDate": "2017-12-31T17:56:29.563", "Score": "12", "CreationDate": "2017-12-31T10:35:39.373", "ParentId": "48041618", "CommentCount": "11", "OwnerUserId": "5632316", "LastEditDate": "2017-12-31T17:56:29.563"}, "bq_ids": {"n4140": {"so_48041618_48041749_2": {"length": 12, "quality": 0.8, "section_id": 7136}, "so_48041618_48041749_1": {"length": 7, "quality": 1.0, "section_id": 7136}, "so_48041618_48041749_0": {"length": 7, "quality": 1.0, "section_id": 5425}}, "n3337": {"so_48041618_48041749_2": {"length": 11, "quality": 0.7333333333333333, "section_id": 6880}, "so_48041618_48041749_1": {"length": 7, "quality": 1.0, "section_id": 6880}, "so_48041618_48041749_0": {"length": 7, "quality": 1.0, "section_id": 5220}}, "n4659": {"so_48041618_48041749_2": {"length": 15, "quality": 1.0, "section_id": 8637}, "so_48041618_48041749_1": {"length": 7, "quality": 1.0, "section_id": 8637}, "so_48041618_48041749_0": {"length": 7, "quality": 1.0, "section_id": 6847}}}, "48078494": {"Id": "48078494", "PostTypeId": "2", "Body": "<p>[basic.link]/3.2 applies to names of \"a non-inline <em>variable</em> of non-volatile const-qualified type\". A variable template isn't a variable, just like a class template isn't a class, a function template isn't a function, and a cookie cutter isn't a cookie. So that rule doesn't apply to the variable template <code>is_integral_v</code> itself.</p>\n<p>A variable template <em>specialization</em> is a variable, however, so there are some questions about whether that rule gives it internal linkage. This is <a href=\"https://wg21.link/CWG1713\" rel=\"nofollow noreferrer\">core issue 1713</a>, the direction of which is that the rule is not applicable.</p>\n<p>Core issue 1713, however, wasn't resolved in time for C++17. So LWG decided to simply plaster <code>inline</code> all over the variable templates just to be safe, because they don't hurt, either.</p>\n", "LastActivityDate": "2018-01-03T13:33:54.823", "Score": "4", "CreationDate": "2018-01-03T13:33:54.823", "ParentId": "48041618", "CommentCount": "0", "OwnerUserId": "2756719"}});