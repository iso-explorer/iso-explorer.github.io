post_cb({"25708892": {"CommentCount": "0", "ViewCount": "46", "CreationDate": "2014-09-07T09:35:33.970", "LastActivityDate": "2014-09-07T10:48:52.730", "Title": "Glvalue refers to a base class subobject", "PostTypeId": "1", "Id": "25708892", "Score": "0", "Body": "<p>There is one restriction:</p>\n<blockquote>\n<p id=\"so_25708892_25708892_0\">Similarly, before the lifetime of an object has started but after the\n  storage which the object will occupy has been allocated or, after the\n  lifetime of an object has ended and before the storage which the\n  object occupied is reused or released, any <strong>glvalue that refers to the</strong>\n<strong>original object</strong> may be used but only in limited ways. For an object\n  under construction or destruction, see 12.7. Otherwise, such a glvalue\n  refers to allocated storage (3.7.4.2), and using the properties of the\n  glvalue that do not depend on its value is well-defined. The program\n  has undefined behavior if:</p>\n<p id=\"so_25708892_25708892_1\">[...]</p>\n<p id=\"so_25708892_25708892_2\">\u2014 the glvalue <strong><em>is</em></strong> bound to a reference to a virtual base class (8.5.3),</p>\n<p id=\"so_25708892_25708892_3\">[...]</p>\n</blockquote>\n<p>How it is even possible that glvalue is bound to a reference to a virtual base class and refers to the original object simultaneously? Could you provide an example?</p>\n", "Tags": "<c++><lvalue>", "OwnerUserId": "2786156", "AnswerCount": "3"}, "25709090": {"ParentId": "25708892", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The following seems like a demonstration of the problem:</p>\n<pre><code>struct Base {};\nstruct X : virtual Base {};\n\nint main()\n{\n    X * p = static_cast&lt;X *&gt;(operator new(sizeof X));\n\n    Base &amp; r = *p;        // *p is an lvalue in the restricted sense\n                          // binding it to a Base &amp; has undefined behaviour\n\n    operator delete(p);\n}\n</code></pre>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2014-09-07T10:09:31.227", "Id": "25709090", "Score": "1", "CreationDate": "2014-09-07T10:04:15.040", "LastActivityDate": "2014-09-07T10:09:31.227"}, "25709124": {"ParentId": "25708892", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Think of a reference to a non-trivial <code>Derived</code> object: you destroy the object with an explicit destructor call and you use a reference to that object to access some functions which don't use/modify any state (<em>properties of the glvalue that do not depend on its value</em>). Since nothing has changed the memory contents, that is still a valid operation (only the cleanup for the object has been performed).</p>\n<p>Anyway the same isn't true if the glvalue is bound to an object <strong>before</strong> its creation (lifetime begins when initialization ends): if you had a <code>Base&amp;</code> reference and <code>Base</code> was a virtual class, that would be different: <strong>you would be calling methods/functions through the vtable and that hasn't been initialized yet</strong>. Undefined behavior.</p>\n<p>e.g.</p>\n<pre><code>class Base {\n    public:\n    virtual void hello() { cout &lt;&lt; \"hello base\"; }\n};\nclass Derived : public Base {\n    public:\n    virtual void hello() { cout &lt;&lt; \"hello derived\"; }\n};\nint main()\n{\n    Derived* p = static_cast&lt;Derived*&gt;(operator new(sizeof(Derived)));\n\n    Base&amp; r = *p;\n    r.hello(); // invalid vtable\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/af7d1fa12719b532\" rel=\"nofollow\"><em>A possible outcome from coliru</em></a></p>\n", "OwnerUserId": "1938163", "LastEditorUserId": "1938163", "LastEditDate": "2014-09-07T10:48:52.730", "Id": "25709124", "Score": "1", "CreationDate": "2014-09-07T10:09:48.623", "LastActivityDate": "2014-09-07T10:48:52.730"}, "bq_ids": {"n4140": {"so_25708892_25709019_0": {"section_id": 7193, "quality": 0.875, "length": 7}, "so_25708892_25708892_0": {"section_id": 7194, "quality": 0.9272727272727272, "length": 51}, "so_25708892_25708892_2": {"section_id": 7194, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_25708892_25709019_0": {"section_id": 40, "quality": 0.75, "length": 6}, "so_25708892_25708892_0": {"section_id": 6938, "quality": 0.9272727272727272, "length": 51}, "so_25708892_25708892_2": {"section_id": 359, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_25708892_25709019_0": {"section_id": 8702, "quality": 0.875, "length": 7}, "so_25708892_25708892_0": {"section_id": 8703, "quality": 0.9272727272727272, "length": 51}, "so_25708892_25708892_2": {"section_id": 8703, "quality": 0.8571428571428571, "length": 6}}}, "25709019": {"ParentId": "25708892", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You are reading that sentence wrong. The direct analog of the bullet point you quoted, for pointers to an object whose lifetime has ended is (\u00a73.8 [basic.life]/p5): </p>\n<blockquote id=\"so_25708892_25709019_0\">\n<ul>\n<li>the pointer is implicitly converted (4.10) to a pointer to a virtual\n  base class</li>\n</ul>\n</blockquote>\n<p>So it's talking about something like this:</p>\n<pre><code>struct A { };\nstruct B : virtual A { ~B() {} };\nint main() {\n    B* pb = new B;\n    B&amp; rb = *pb;\n    A&amp; ra1 = rb; \n\n    pb-&gt;~B();    // ends lifetime of *pb\n    &amp;rb;         // OK\n    A&amp; ra2 = rb; // Undefined behavior. The glvalue rb, referring to an object whose lifetime\n                 // has ended, is bound to a reference to its virtual base class A\n    A* pa = pb;  // Equally undefined\n}\n</code></pre>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-09-07T10:09:13.360", "Id": "25709019", "Score": "1", "CreationDate": "2014-09-07T09:54:55.573", "LastActivityDate": "2014-09-07T10:09:13.360"}});