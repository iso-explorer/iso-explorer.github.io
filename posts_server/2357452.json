post_cb({"7050528": {"Id": "7050528", "PostTypeId": "2", "Body": "<p>This is either a compiler bug or your compiler doesn't support std::initializer_list. Tested on GCC 4.5.1 and it compiles fine.</p>\n", "LastActivityDate": "2011-08-13T12:52:21.063", "CommentCount": "0", "CreationDate": "2011-08-13T12:52:21.063", "ParentId": "2357452", "Score": "1", "OwnerUserId": "762809"}, "2357452": {"ViewCount": "15405", "Body": "<p>For some reason I thought C++0x allowed <code>std::initializer_list</code> as function argument for functions that expect types that can be constructed from such, for example <code>std::vector</code>. But apparently, it does not work. Is this just my compiler, or will this never work? Is it because of potential overload resolution problems?</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n\nvoid function(std::vector&lt;std::string&gt; vec)\n{\n}\n\nint main()\n{\n    // ok\n    std::vector&lt;std::string&gt; vec {\"hello\", \"world\", \"test\"};\n\n    // error: could not convert '{\"hello\", \"world\", \"test\"}' to 'std::vector...'\n    function( {\"hello\", \"world\", \"test\"} );\n}\n</code></pre>\n", "AcceptedAnswerId": "2357688", "Title": "std::initializer_list as function argument", "CreationDate": "2010-03-01T16:54:01.890", "Id": "2357452", "CommentCount": "4", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2011-10-01T13:54:04.820", "LastEditorUserId": "34509", "LastActivityDate": "2014-12-07T17:30:55.400", "Score": "31", "OwnerUserId": "252000", "Tags": "<c++><c++11><initializer-list>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_2357452_2357688_5": {"length": 16, "quality": 1.0, "section_id": 3323}, "so_2357452_2357688_9": {"length": 27, "quality": 0.6585365853658537, "section_id": 630}, "so_2357452_2357688_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 629}, "so_2357452_2357688_6": {"length": 23, "quality": 0.8846153846153846, "section_id": 3324}, "so_2357452_2357688_8": {"length": 20, "quality": 0.6896551724137931, "section_id": 599}, "so_2357452_2357688_3": {"length": 34, "quality": 0.8947368421052632, "section_id": 632}, "so_2357452_2357688_10": {"length": 17, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_2357452_2357688_4": {"length": 31, "quality": 0.8378378378378378, "section_id": 599}, "so_2357452_2357688_5": {"length": 16, "quality": 1.0, "section_id": 3193}, "so_2357452_2357688_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 620}, "so_2357452_2357688_6": {"length": 23, "quality": 0.8846153846153846, "section_id": 3194}, "so_2357452_2357688_9": {"length": 27, "quality": 0.6585365853658537, "section_id": 621}, "so_2357452_2357688_8": {"length": 20, "quality": 0.6896551724137931, "section_id": 589}, "so_2357452_2357688_3": {"length": 34, "quality": 0.8947368421052632, "section_id": 622}, "so_2357452_2357688_10": {"length": 17, "quality": 1.0, "section_id": 3195}}, "n4659": {"so_2357452_2357688_5": {"length": 14, "quality": 0.875, "section_id": 4089}, "so_2357452_2357688_9": {"length": 27, "quality": 0.6585365853658537, "section_id": 658}, "so_2357452_2357688_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 655}, "so_2357452_2357688_6": {"length": 22, "quality": 0.8461538461538461, "section_id": 4090}, "so_2357452_2357688_8": {"length": 19, "quality": 0.6551724137931034, "section_id": 622}, "so_2357452_2357688_10": {"length": 10, "quality": 0.5882352941176471, "section_id": 4091}, "so_2357452_2357688_3": {"length": 34, "quality": 0.8947368421052632, "section_id": 660}, "so_2357452_2357688_7": {"length": 20, "quality": 0.5263157894736842, "section_id": 4091}}}, "2357530": {"Id": "2357530", "PostTypeId": "2", "Body": "<p>Offhand, I'm not sure, but I suspect what's going on here is that converting to an initializer_list is one conversion, and converting that to vector is another conversion. If that's the case, you're exceeding the limit of only one implicit conversion...</p>\n", "LastActivityDate": "2010-03-01T17:02:55.397", "CommentCount": "0", "CreationDate": "2010-03-01T17:02:55.397", "ParentId": "2357452", "Score": "2", "OwnerUserId": "179910"}, "2357992": {"Id": "2357992", "PostTypeId": "2", "Body": "<p>It seems to work this way:</p>\n<pre><code>function( {std::string(\"hello\"), std::string(\"world\"), std::string(\"test\")} );\n</code></pre>\n<p>Perhaps it is a compiler bug, but perhaps you are asking for too many implicit conversions.</p>\n", "LastActivityDate": "2010-03-01T18:15:57.480", "CommentCount": "0", "CreationDate": "2010-03-01T18:15:57.480", "ParentId": "2357452", "Score": "3", "OwnerUserId": "155693"}, "2357688": {"Id": "2357688", "PostTypeId": "2", "Body": "<p>GCC has a bug. The Standard makes this valid. See:</p>\n<p>Notice that there are two sides of this</p>\n<ul>\n<li>How and what initialization is done in general?</li>\n<li>How is initialization used during overload resolution, and what cost does it have?</li>\n</ul>\n<p>The first question is answered in section <code>8.5</code>. The second question is answered in section <code>13.3</code>. For example, reference binding is handled at <code>8.5.3</code> and <code>13.3.3.1.4</code>, while list initialization is handled in <code>8.5.4</code> and <code>13.3.3.1.5</code>.  </p>\n<p><code>8.5/14,16</code>:</p>\n<blockquote>\n<p id=\"so_2357452_2357688_0\">The initialization that occurs in the form</p>\n<pre><code>T x = a;\n</code></pre>\n<p id=\"so_2357452_2357688_1\"><strong>as well as in argument passing</strong>, function return, throwing an exception (15.1), handling an exception (15.3), and aggregate member initialization (8.5.1) is called copy-initialization.<br>\n  .<br>\n  .<br>\n  The semantics of initializers are as follows[...]: If the initializer is a braced-init-list, the object is list-initialized (8.5.4).</br></br></br></p>\n</blockquote>\n<p>When considering the candidate <code>function</code>, the compiler will see an initializer list (which has no type yet - it's just a grammatical construct!) as the argument, and a <code>std::vector&lt;std::string&gt;</code> as the parameter of <code>function</code>. To figure out what the cost of conversion is and whether we <em>can</em> convert these in context of overloading, <code>13.3.3.1/5</code> says</p>\n<p><code>13.3.3.1.5/1</code>:</p>\n<blockquote>\n<p id=\"so_2357452_2357688_2\">When an argument is an initializer list (8.5.4), it is not an expression and special rules apply for converting it to a parameter type.</p>\n</blockquote>\n<p><code>13.3.3.1.5/3</code>:</p>\n<blockquote>\n<p id=\"so_2357452_2357688_3\">Otherwise, if the parameter is a non-aggregate class X and overload resolution per 13.3.1.7 chooses a single best constructor of X to perform the initialization of an object of type X from the argument initializer list, the implicit conversion sequence is a user-de\ufb01ned conversion sequence. User-de\ufb01ned conversions are allowed for conversion of the initializer list elements to the constructor parameter types except as noted in 13.3.3.1.</p>\n</blockquote>\n<p>The non-aggregate class <code>X</code> is <code>std::vector&lt;std::string&gt;</code>, and i will figure out the single best constructor below. The last rule grants us to use user defined conversions in cases like the following:</p>\n<pre><code>struct A { A(std::string); A(A const&amp;); };\nvoid f(A);\nint main() { f({\"hello\"}); }\n</code></pre>\n<p>We are allowed to convert the string literal to <code>std::string</code>, even if this needs a user defined conversion. However, it points to restrictions of another paragraph. What does <code>13.3.3.1</code> say?</p>\n<p><code>13.3.3.1/4</code>, which is the paragraph responsible for forbidding multiple user defined conversions. We will only look at list initializations:</p>\n<blockquote>\n<p id=\"so_2357452_2357688_4\">However, when considering the argument of a user-de\ufb01ned conversion function [(or constructor)] that is a candidate by [...] 13.3.1.7 when passing the initializer list as a single argument or when the initializer list has exactly one element and a conversion to some class X or reference to (possibly cv-quali\ufb01ed) X is considered for the \ufb01rst parameter of a constructor of X, or [...], only standard conversion sequences and ellipsis conversion sequences are allowed.</p>\n</blockquote>\n<p>Notice that this is an important restriction: If it weren't for this, the above can use the copy-constructor to establish an equally well conversion sequence, and the initialization would be ambiguous. (notice the potential confusion of \"A or B and C\" in that rule: It is meant to say \"(A or B) and C\" - so we are restricted <em>only</em> when trying to convert by a constructor of X having a parameter of type <code>X</code>).</p>\n<p>We are delegated to <code>13.3.1.7</code> for collecting the constructors we can use to do this conversion. Let's approach this paragraph from the general side starting from <code>8.5</code> which delegated us to <code>8.5.4</code>:</p>\n<p><code>8.5.4/1</code>:  </p>\n<blockquote>\n<p id=\"so_2357452_2357688_5\">List-initialization can occur in direct-initialization or copy-initialization contexts; list-initialization in a direct-initialization context is called <em>direct-list-initialization</em> and list-initialization in a copy-initialization context is called <em>copy-list-initialization</em>.  </p>\n</blockquote>\n<p><code>8.5.4/2</code>:</p>\n<blockquote>\n<p id=\"so_2357452_2357688_6\">A constructor is an <em>initializer-list constructor</em> if its \ufb01rst parameter is of type <code>std::initializer_list&lt;E&gt;</code> or reference to possibly cv-quali\ufb01ed <code>std::initializer_list&lt;E&gt;</code> for some type E, and either there are no other parameters or else all other parameters have default arguments (8.3.6). </p>\n</blockquote>\n<p><code>8.5.4/3</code>:</p>\n<blockquote>\n<p id=\"so_2357452_2357688_7\">List-initialization of an object or reference of type T is de\ufb01ned as follows: [...]  Otherwise, if T is a class type, constructors are considered. If T has an initializer-list constructor, the argument list consists of the initializer list as a single argument; otherwise, the argument list consists of the elements of the initializer list. The applicable constructors are enumerated (13.3.1.7) and the best one is chosen through overload resolution (13.3).</p>\n</blockquote>\n<p>At this time, <code>T</code> is the class type <code>std::vector&lt;std::string&gt;</code>. We have one argument (which does not have a type yet! We are just in the context of having a grammatical initializer list). Constructors are enumerated as of <code>13.3.1.7</code>:</p>\n<blockquote>\n<p id=\"so_2357452_2357688_8\">[...] If T has an initializer-list constructor (8.5.4), the argument list consists of the initializer list as a single argument; otherwise, the argument list consists of the elements of the initializer list. For copy-list-initialization, the candidate functions are all the constructors of T. However, if an explicit constructor is chosen, the initialization is ill-formed. </p>\n</blockquote>\n<p>We will only consider the initializer list of <code>std::vector</code> as the only candidate, since we already know the others won't win against it or won't fit the argument. It has the following signature:</p>\n<pre><code>vector(initializer_list&lt;std::string&gt;, const Allocator&amp; = Allocator());\n</code></pre>\n<p>Now, the rules of converting an initializer list to an <code>std::initializer_list&lt;T&gt;</code> (to categorize the cost of the argument/parameter conversion) are enumerated in <code>13.3.3.1.5</code>:</p>\n<blockquote>\n<p id=\"so_2357452_2357688_9\">When an argument is an initializer list (8.5.4), it is not an expression and special rules apply for converting it to a parameter type. [...] If the parameter type is <code>std::initializer_list&lt;X&gt;</code> and all the elements of the initializer list can be implicitly converted to X, the implicit conversion sequence is the worst conversion necessary to convert an element of the list to X. <strong>This conversion can be a user-de\ufb01ned conversion</strong> even in the context of a call to an initializer-list constructor.</p>\n</blockquote>\n<p>Now, the initializer list will be successfully converted, and the conversion sequence is a user defined conversion (from <code>char const[N]</code> to <code>std::string</code>). How this is made is detailed at <code>8.5.4</code> again:</p>\n<blockquote>\n<p id=\"so_2357452_2357688_10\">Otherwise, if T is a specialization of <code>std::initializer_list&lt;E&gt;</code>, an initializer_list object is constructed as described below and used to initialize the object according to the rules for initialization of an object from a class of the same type (8.5). (...)</p>\n</blockquote>\n<p>See <code>8.5.4/4</code> how this final step is made :)</p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2010-03-03T16:17:26.383", "Score": "54", "CreationDate": "2010-03-01T17:25:10.337", "ParentId": "2357452", "CommentCount": "5", "OwnerUserId": "34509", "LastEditDate": "2010-03-03T16:17:26.383"}, "27345535": {"Id": "27345535", "PostTypeId": "2", "Body": "<p>You have to specify type of your initializer_list</p>\n<pre><code>function(std::initializer_list&lt;std::string&gt;{\"hello\", \"world\", \"test\"} );\n</code></pre>\n<p>Good luck</p>\n", "LastActivityDate": "2014-12-07T17:30:55.400", "CommentCount": "1", "CreationDate": "2014-12-07T17:30:55.400", "ParentId": "2357452", "Score": "1", "OwnerUserId": "1927176"}});