post_cb({"28291232": {"ParentId": "28291195", "CommentCount": "7", "Body": "<p>Yeah. The easy way to fix it is to write a normal <code>==</code> comparison:</p>\n<pre><code>struct search_t { // because C++\n    k_type_t type;\n    visual_t visual_value;\n    audio_t audio_value;\n    std::string text_value;\n\n    bool operator == (const search_t&amp; in) const {\n        return type == in.type &amp;&amp; visual_value == in.visual_value\n            &amp;&amp; audio_value == in.audio_value &amp;&amp; text_value == in.text_value;\n    }\n}; \n</code></pre>\n<p>If it's really only type based, then I guess you could do:</p>\n<pre><code>bool operator == (const search_t&amp; in) const {\n    if (type != in.type) return false;\n\n    switch (type) {\n    case __VISUAL__: return visual_value == in.visual_value;\n    case __AUDIO__: return audio_value == in.audio_value;\n    case __TEXT__: return text_value == in.text_value;\n    default: return false; // or something\n}\n</code></pre>\n<p>Note that your <code>type</code>s are invalid identifiers, per [global.names]:</p>\n<blockquote>\n<p id=\"so_28291195_28291232_0\">Each name that contains a double underscore __ or begins with an underscore followed by an uppercase\n  letter (2.12) is reserved to the implementation for any use.</p>\n</blockquote>\n<p>Finally, this probably isn't a good data type for storage. Consider using:</p>\n<pre><code>using search_t = boost::variant&lt;visual_t, audio_t, std::string&gt;;\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "28291232", "Score": "3", "CreationDate": "2015-02-03T04:11:32.093", "LastActivityDate": "2015-02-03T04:11:32.093"}, "28291195": {"CommentCount": "5", "ViewCount": "134", "PostTypeId": "1", "LastEditorUserId": "4179338", "CreationDate": "2015-02-03T04:06:21.423", "LastActivityDate": "2015-04-07T00:26:16.613", "Title": "C++ Return Type Deduction Based on Input Parameters", "AcceptedAnswerId": "28291232", "LastEditDate": "2015-04-07T00:26:16.613", "Id": "28291195", "Score": "1", "Body": "<p>I am creating a \"knowledge processor\" which can handle multiple forms of data. The forms of data that I am planning to support are textual, visual, and auditory. Each can be represented via TEXT, VISUAL, and AUDIO, respectively. So every \"knowledge\", or data, is being represented in a structure called \"know_t\".</p>\n<pre><code>#define VISUAL 0\n#define AUDIO  1\n#define TEXT   2\n\nstruct know_t {\n    k_type_t type;\n    text_k_t text_value;\n    visual_k_t visual_value;\n    audio_k_t audio_value;\n};\n</code></pre>\n<p>k_type_t is a type definition from int. It is used to store the \"type\" of the data, which can be represented by the #define'd macros at the beginning of the code snippet.</p>\n<p>Getting to the point, I am writing a search algorithm for the processor. Each of these types, VISUAL, AUDIO, and TEXT, can be represented by a \"prototype\" form. For instance, TEXT data can be represented via a std::string. Such prototype forms of a data will be used to search the knowledge database. To enable easy searching, I created a structure called \"search_t\" to represent the search.</p>\n<pre><code>struct search_t {\n    k_type_t type;\n    visual_t visual_value;\n    audio_t audio_value;\n    std::string text_value;\n\n    bool operator == (const struct __search_t &amp;in);\n};\n</code></pre>\n<p>Now here the structure may look almost exactly the same as the structure above, know_t, they are very different. For instance, while the type \"k_type_t\" contains the data for a string, such as the definition, std::string is a form of the data used to search. The same goes to all the other forms of data.</p>\n<p>I am using C++'s unordered_map to accomplish the search. The ISO C++ standard states that for an unordered_map to work, a hash function and the \"==\" operator is needed for the key type, search_t in this case. For that, I decided to write a get_value function that returns the prototype value of a search structure. The problem is that <strong>as the type of the data changes, the return type changes</strong>.</p>\n<p>I have written the following code so far, for the == operator, but my compiler (GCC 4.8.1 with -std=c++11) doesn't seem to like it.</p>\n<pre><code>#define test(in) in.type == VISUAL ? in.visual_value : \\\n                 in.type == AUDIO  ? in.audio_value  : \\\n                 in.type == TEXT   ? in.text_value   : NULL\n\nbool search_t::operator == (const struct search_t &amp;in) {\n    auto getval_search = [](const search_t &amp;in) -&gt; decltype(test(in)) {\n        if (in.type == __VISUAL__)\n            return in.visual_value;\n        if (in.type == __AUDIO__)\n            return in.audio_value;\n        if (in.type == __TEXT__)\n            return in.text_value;\n    }\n\n    bool equal = (bool)((this-&gt;type) == in.type);\n    if (!equal)\n        return false;\n\n    search_t tmp = *this; // bugfix\n    if (getval_search(tmp) == getval_search(in))\n        return true;\n}\n</code></pre>\n<p>Is there a way to fix this?</p>\n", "Tags": "<c++><c++11><artificial-intelligence>", "OwnerUserId": "4179338", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28291195_28291232_0": {"section_id": 6307, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_28291195_28291232_0": {"section_id": 6064, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_28291195_28291232_0": {"section_id": 6756, "quality": 0.8571428571428571, "length": 12}}}});