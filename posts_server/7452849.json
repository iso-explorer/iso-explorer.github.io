post_cb({"bq_ids": {"n4140": {"so_7452849_7465863_0": {"length": 8, "quality": 1.0, "section_id": 350}, "so_7452849_7452867_0": {"length": 31, "quality": 0.6595744680851063, "section_id": 62}, "so_7452849_7452867_1": {"length": 48, "quality": 0.8135593220338984, "section_id": 62}}, "n3337": {"so_7452849_7465863_0": {"length": 8, "quality": 1.0, "section_id": 340}, "so_7452849_7452867_1": {"length": 48, "quality": 0.8135593220338984, "section_id": 57}, "so_7452849_7452867_0": {"length": 31, "quality": 0.6595744680851063, "section_id": 57}}, "n4659": {"so_7452849_7465863_0": {"length": 8, "quality": 1.0, "section_id": 360}, "so_7452849_7452867_1": {"length": 48, "quality": 0.8135593220338984, "section_id": 64}, "so_7452849_7452867_0": {"length": 31, "quality": 0.6595744680851063, "section_id": 64}}}, "7453064": {"Id": "7453064", "PostTypeId": "2", "Body": "<p>Having said that default arguments for <code>template</code> are not allowed in current standard. Following is a simple work around to solve your problem:</p>\n<pre><code>template &lt;class HANDLER&gt;\nvoid action(HANDLER h) {\n    std::cout &lt;&lt; h.foo() &lt;&lt; std::endl;\n}\nvoid action() {  // wrapper\n  action(DefaultHandler()); // call the desired funciton\n}\n</code></pre>\n<p>Provide a wrapper which makes the effect of default parameter for <code>action()</code>. <a href=\"http://www.ideone.com/n9gtd\" rel=\"nofollow\">Demo</a>.</p>\n", "LastActivityDate": "2011-09-17T06:58:52.507", "CommentCount": "0", "CreationDate": "2011-09-17T06:58:52.507", "ParentId": "7452849", "Score": "3", "OwnerUserId": "514235"}, "7452849": {"ViewCount": "536", "Body": "<p>I have a function which accepts an operator object as an argument. This operator is treated sort of like a callback. The type of this operator object is a template parameter. How can I specify a default parameter for it?</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class IT, class NT&gt;\nclass A\n{\n    public:\n    class DefaultHandler\n    {\n    public:\n        NT foo() { return NT(); }\n    };\n\n    template &lt;class HANDLER&gt;\n    void action(HANDLER h = DefaultHandler()) // This default parameter is accepted by the compiler but appears to have no effect\n    {\n        std::cout &lt;&lt; h.foo() &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    A&lt;int, double&gt; a;\n    // I want this to be legal:\n    a.action(); // error: no matching function for call to \u2018A&lt;int, double&gt;::action()\u2019\n\n    //a.action(A&lt;int, double&gt;::DefaultHandler()); // Works\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "7465863", "Title": "default arguments for templated function", "CreationDate": "2011-09-17T06:10:46.583", "Id": "7452849", "CommentCount": "5", "PostTypeId": "1", "ClosedDate": "2014-06-09T12:54:44.007", "LastActivityDate": "2011-09-19T02:12:19.460", "Score": "3", "OwnerUserId": "321772", "Tags": "<c++><templates>", "AnswerCount": "3"}, "7452867": {"Id": "7452867", "PostTypeId": "2", "Body": "<p>Default parameters for template functions are not allowed in C++03 but are allowed in C++11.  </p>\n<hr>\n<p><strong>References:</strong></p>\n<p><strong>C++03 Standard: 14.1.9:</strong> </p>\n<blockquote>\n<p id=\"so_7452849_7452867_0\">A default template-argument is a template-argument (14.3) specified after = in a template-parameter. Adefault template-argument may be specified for any kind of template-parameter (type, non-type, template).A default template-argument may be specified in a class template declaration or a class template definition. <strong>A default template-argument shall not be specified in a function template declaration or a function template definition, nor in the template-parameter-list of the definition of a member of a class template.  A default template-argument shall not be specified in a friend template declaration.</strong></p>\n</blockquote>\n<p><strong>C++11: 14.1.9:</strong> </p>\n<blockquote>\n<p id=\"so_7452849_7452867_1\">A default template-argument is a template-argument (14.3) speci\ufb01ed after = in a template-parameter. A de-fault template-argument may be speci\ufb01ed for any kind of template-parameter (type, non-type, template) that is not a template parameter pack (14.5.3). A default template-argument may be speci\ufb01ed in a template dec-laration. <strong>A default template-argument shall not be speci\ufb01ed in the template-parameter-lists of the de\ufb01nition of a member of a class template that appears outside of the member\u2019s class. A default template-argument\n  shall not be speci\ufb01ed in a friend class template declaration. If a friend function template declaration speci\ufb01es a default template-argument, that declaration shall be a de\ufb01nition and shall be the only declaration of the function template in the translation unit.</strong></p>\n</blockquote>\n</hr>", "LastEditorUserId": "452307", "LastActivityDate": "2011-09-17T06:36:41.773", "Score": "2", "CreationDate": "2011-09-17T06:13:18.250", "ParentId": "7452849", "CommentCount": "3", "OwnerUserId": "452307", "LastEditDate": "2011-09-17T06:36:41.773"}, "7465863": {"Id": "7465863", "PostTypeId": "2", "Body": "<p>Unfortunately, C++03 14.8.2.4/17 says:<br/></p>\n<blockquote>\n<p id=\"so_7452849_7465863_0\">A template <em>type-parameter</em> cannot be deduced from the type of a\n  function default argument</p>\n</blockquote>\n<p>and provides an example like so:</p>\n<pre><code>template &lt;class T&gt; void f(T = 5, T = 7);\nvoid g()\n{\n    f(1);                   // OK: call f&lt;int&gt;(1,7)\n    f();                    // error: cannot deduce T\n    f&lt;int&gt;();               // OK: call f&lt;int&gt;(5,7)\n}\n</code></pre>\n<p>Because N3290 14.8.2.5/19 states the same specification too,\nthis seems not to change in the new standard...</p>\n", "LastActivityDate": "2011-09-19T02:12:19.460", "CommentCount": "0", "CreationDate": "2011-09-19T02:12:19.460", "ParentId": "7452849", "Score": "0", "OwnerUserId": "547710"}});