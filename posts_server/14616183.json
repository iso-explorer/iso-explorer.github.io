post_cb({"bq_ids": {"n4140": {"so_14616183_14616201_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 5425}, "so_14616183_14616201_0": {"length": 7, "quality": 0.7, "section_id": 7136}}, "n3337": {"so_14616183_14616201_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 5220}, "so_14616183_14616201_0": {"length": 7, "quality": 0.7, "section_id": 6880}}, "n4659": {"so_14616183_14616201_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 6847}, "so_14616183_14616201_0": {"length": 7, "quality": 0.7, "section_id": 8637}}}, "14616201": {"Id": "14616201", "PostTypeId": "2", "Body": "<p><strong>Yes, and no</strong>; you can use <code>extern</code>:</p>\n<blockquote>\n<p id=\"so_14616183_14616201_0\"><code>[C++11: 3.5/3]:</code> <strong>A name having namespace scope</strong> (3.3.6) <strong>has internal linkage if it is the name of</strong></p>\n<ul>\n<li>a variable, function or function template that is explicitly declared <code>static</code>; or,</li>\n<li><strong>a variable that is explicitly declared</strong> <code>const</code> or <strong><code>constexpr</code></strong> and <strong>neither explicitly declared <code>extern</code> nor previously declared to have external linkage</strong>; or</li>\n<li>a data member of an anonymous union.</li>\n</ul>\n</blockquote>\n<p>So:</p>\n<pre><code>namespace foo \n{\n    extern constexpr double bar() { return 1.23456; }\n    extern constexpr double baz = 1.23456;\n}\n</code></pre>\n<p>In your other translation unit, you should now be able to <em>declare</em> the function's name and refer to it:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace foo\n{\n   extern constexpr double bar();\n}\n\nint main()\n{\n   std::cout &lt;&lt; foo::bar() &lt;&lt; '\\n';\n}\n</code></pre>\n<p>However, the rules for <code>constexpr</code> <em>variables</em> state that <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\">you cannot have a declaration that is not also a definition</a>:</p>\n<blockquote>\n<p id=\"so_14616183_14616201_1\"><code>[C++11: 7.1.5/9]:</code> A <code>constexpr</code> specifier used in an object declaration declares the object as <code>const</code>. Such an object shall have literal type and shall be initialized. <em>[..]</em></p>\n</blockquote>\n<p>So, you cannot take the same approach with <code>baz</code>.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2013-01-31T00:14:54.410", "Score": "8", "CreationDate": "2013-01-31T00:04:17.117", "ParentId": "14616183", "CommentCount": "4", "OwnerUserId": "560648", "LastEditDate": "2013-01-31T00:14:54.410"}, "14616183": {"ViewCount": "621", "Body": "<p>I am trying to create a <strong>namespace-scope</strong> constant with <strong>external linkage</strong></p>\n<pre><code>// in some include file:\n\nnamespace foo \n{\n    constexpr double bar() { return 1.23456; } // internal linkage\n    constexpr double baz = 1.23456;            // internal linkage\n    const double bing = 1.23456;               // internal linkage\n}\n</code></pre>\n<p>Is this even possible?</p>\n", "AcceptedAnswerId": "14616201", "Title": "How to define a constant double at namespace scope with external linkage?", "CreationDate": "2013-01-31T00:02:43.687", "Id": "14616183", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-01-31T00:13:28.970", "LastEditorUserId": "955273", "LastActivityDate": "2013-01-31T00:14:54.410", "Score": "3", "OwnerUserId": "955273", "Tags": "<c++><c++11><constexpr>", "AnswerCount": "1"}});