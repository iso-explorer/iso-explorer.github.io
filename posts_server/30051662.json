post_cb({"30051662": {"CommentCount": "7", "ViewCount": "107", "PostTypeId": "1", "LastEditorUserId": "4861595", "CreationDate": "2015-05-05T11:24:08.237", "LastActivityDate": "2015-05-25T11:41:25.140", "Title": "What happens if you call a destructor and use the allocated memory again for other objects?", "AcceptedAnswerId": "30051877", "LastEditDate": "2015-05-05T11:31:21.320", "Id": "30051662", "Score": "2", "Body": "<pre><code>class base\n{\n    virtual ~base();\n};\n\nclass der1 :public base\n{\n    int i;\n}\n\nclass der2 :public base //I used double that der2 is bigger than der1\n{\n    double d;\n}\n\nint main()\n{\n   base* ptr = new der2;\n   ptr-&gt;~base(); //Destructor call just for the\n                 //case that the der2 had a pointer member\n\n   der1* ptr2 = static_cast&lt;der1*&gt;(ptr);\n   *ptr2 = der1();\n\n   delete ptr;\n\n   return 0;\n}\n</code></pre>\n<p>What would happen if you would execute the code shown above?\nWould this produce a memory leak and if yes why?\nIs there a possibility to use the taken memory for different types without releasing it first? (Please no answers like why should you need this, it's just interest)</p>\n<p>Edit:\nThe ~base() does nothing because this is an example.</p>\n", "Tags": "<c++><pointers><memory-leaks>", "OwnerUserId": "4861595", "AnswerCount": "1"}, "30051877": {"ParentId": "30051662", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>It's undefined behaviour since you assign to, and delete an object after its lifetime has ended, which is forbidden by C++11, [basic.life]/5:</p>\n<blockquote>\n<p id=\"so_30051662_30051877_0\">after the lifetime of an object has ended and before the storage which the object occupied is\n  reused or released, any pointer that refers to the storage location where the object will be or was located\n  may be used but only in limited ways. The program has undefined behavior if:</p>\n<ul>\n<li>the object will be or was of a class type with a non-trivial destructor and the pointer is used as the operand of a\n  <em>delete-expression</em></li>\n<li>the pointer is used to [...] call a non-static member function of the object</li>\n</ul>\n</blockquote>\n<p>(plus a few other restrictions.) You try to do both of these things.</p>\n<p>If you were to fix this, by creating a new object in the old memory rather than assigning to it as if there were already an object there:</p>\n<pre><code>der1* ptr2 = new (ptr) der1;\n</code></pre>\n<p>then it's still undefined behaviour, as stated in C++11, [basic.life]/7</p>\n<blockquote>\n<p id=\"so_30051662_30051877_1\">If, after the lifetime of an object has ended and before the storage which the object occupied is reused or\n  released, a new object is created at the storage location which the original object occupied, a pointer that\n  pointed to the original object [...] can\n  be used to manipulate the new object, if [...] the new object is of the same type as the original object</p>\n</blockquote>\n<p>(plus a few other conditions). You use an pointer to the old object to manipulate (specifically, to delete) the new object of a different type.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2015-05-25T11:41:25.140", "Id": "30051877", "Score": "3", "CreationDate": "2015-05-05T11:34:31.370", "LastActivityDate": "2015-05-25T11:41:25.140"}, "bq_ids": {"n4140": {"so_30051662_30051877_1": {"section_id": 7195, "quality": 1.0, "length": 32}, "so_30051662_30051877_0": {"section_id": 7193, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_30051662_30051877_1": {"section_id": 6939, "quality": 1.0, "length": 32}, "so_30051662_30051877_0": {"section_id": 6937, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_30051662_30051877_1": {"section_id": 8704, "quality": 1.0, "length": 32}, "so_30051662_30051877_0": {"section_id": 8702, "quality": 0.9230769230769231, "length": 24}}}});