post_cb({"bq_ids": {"n4140": {"so_42523833_42524024_0": {"length": 23, "quality": 1.0, "section_id": 7244}, "so_42523833_42524024_1": {"length": 18, "quality": 1.0, "section_id": 6119}, "so_42523833_42524024_2": {"length": 7, "quality": 1.0, "section_id": 7245}}, "n3337": {"so_42523833_42524024_0": {"length": 23, "quality": 1.0, "section_id": 6988}, "so_42523833_42524024_1": {"length": 18, "quality": 1.0, "section_id": 5883}, "so_42523833_42524024_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 6989}}, "n4659": {"so_42523833_42524024_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 8753}, "so_42523833_42524024_1": {"length": 18, "quality": 1.0, "section_id": 7616}, "so_42523833_42524024_2": {"length": 7, "quality": 1.0, "section_id": 8754}}}, "42523833": {"ViewCount": "169", "Body": "<p>I'm reading a bit about alignment in C++, and I am not sure why the alignment of a class that contains solely a <code>char</code> array member is not the sizeof of the array, but turns out to be always 1. For example</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo{char m_[16];}; // shouldn't this have a 16 byte alignment?!\n\nint main()\n{\n    std::cout &lt;&lt; sizeof(Foo) &lt;&lt; \" \" &lt;&lt; alignof(Foo);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/8784cdb6fa834107\" rel=\"nofollow noreferrer\"><kbd>Live on Coliru</kbd></a></p>\n<p>in the code above it's clear that the <code>sizeof(Foo)</code> is 16, however its alignment is 1, see the output of the code. </p>\n<p><strong>Why is the <code>alignof(Foo)</code> 1 in this case?</strong>\nNote that if I replace <code>char m_[16];</code> with a fundamental type like <code>int m_;</code>, then <code>alignof(Foo)</code> becomes what I would've expected, i.e. <code>sizeof(int)</code> (on my machine this is 4).</p>\n<p>Same happens if I simply declare an array <code>char arr[16];</code>, then <code>alignof(arr)</code> will be 1.</p>\n", "AcceptedAnswerId": "42524024", "Title": "Why is alignof of a char array always 1?", "CreationDate": "2017-03-01T05:24:32.477", "Id": "42523833", "CommentCount": "13", "LastEditDate": "2017-03-01T05:40:42.760", "PostTypeId": "1", "LastEditorUserId": "3093378", "LastActivityDate": "2017-03-01T12:27:00.637", "Score": "5", "OwnerUserId": "3093378", "Tags": "<c++><arrays><memory-alignment>", "AnswerCount": "1"}, "42524024": {"Id": "42524024", "PostTypeId": "2", "Body": "<p><strong>Note: data alignment has been explained in details in <a href=\"http://www.ibm.com/developerworks/library/pa-dalign/\" rel=\"nofollow noreferrer\">this article</a>. If you want to know what the term means in general and why it is an important issue read the article.</strong></p>\n<p>Aligment is defined in C++ as an implementation-defined integer value representing the number of bytes between successive addresses at which a given object can be allocated <a href=\"http://eel.is/c++draft/basic.align#1\" rel=\"nofollow noreferrer\">[6.11.1] Alignment</a>.</p>\n<p>Moreover alignments must be non-negative integral powers of 2 <a href=\"http://eel.is/c++draft/basic.align#4\" rel=\"nofollow noreferrer\">[6.11.4] Alignment</a>.</p>\n<p>When we calculate the alignment of a struct we have to take into account yet another rule <a href=\"http://eel.is/c++draft/basic.align#5\" rel=\"nofollow noreferrer\">[6.11.5] Alignment</a>:</p>\n<blockquote>\n<p id=\"so_42523833_42524024_0\">Alignments have an order from <em>weaker</em> to <em>stronger</em> or <em>stricter</em>\n  alignments. Stricter alignments have larger alignment values. <strong>An\n  address that satisfies an alignment requirement also satisfies any\n  weaker valid alignment requirement.</strong></p>\n</blockquote>\n<p>It's not directly stated but these rules imply that <strong>struct alignment has to be at least as strict as the alignment of its most strictly aligned member</strong>. It could be bigger but it doesn't have to be and usually isn't.</p>\n<p>So when the alignment of the struct from OP's example is decided the alignment of the struct must be no less than alignment of its only member's type <code>char[16]</code>. Then by the <a href=\"http://eel.is/c++draft/expr.alignof#3\" rel=\"nofollow noreferrer\">8.3.6 [expr.alignof]</a>:</p>\n<blockquote>\n<p id=\"so_42523833_42524024_1\">When alignof is applied to a reference type, the result is the\n  alignment of the referenced type. <strong>When alignof is applied to an array\n  type, the result is the alignment of the element type</strong>.</p>\n</blockquote>\n<p><code>alignof(char[16])</code> equals <code>alignof(char)</code> which will usually be <code>1</code> because of <a href=\"http://eel.is/c++draft/basic.align#6\" rel=\"nofollow noreferrer\">[6.11.6] Alignment</a>:</p>\n<blockquote>\n<p id=\"so_42523833_42524024_2\">(...) narrow character types shall have the weakest alignment requirement.</p>\n</blockquote>\n<p>In this example:</p>\n<pre><code>struct Foo\n{\n    char c[16];\n    double d;\n};\n</code></pre>\n<p><code>double</code> has more strict alignment than <code>char</code> so <code>alignof(Foo)</code> equals <code>alignof(double)</code>. </p>\n", "LastEditorUserId": "7574136", "LastActivityDate": "2017-03-01T12:27:00.637", "Score": "10", "CreationDate": "2017-03-01T05:38:43.770", "ParentId": "42523833", "CommentCount": "8", "OwnerUserId": "7574136", "LastEditDate": "2017-03-01T12:27:00.637"}});