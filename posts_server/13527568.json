post_cb({"bq_ids": {"n4140": {"so_13527568_13527994_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 6000}}, "n3337": {"so_13527568_13527994_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5768}}}, "13527568": {"ViewCount": "1295", "Body": "<blockquote>\n<p id=\"so_13527568_13527568_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/2582529/using-array-as-map-value-cant-see-the-error\">Using array as map value: Cant see the error</a> </br></p>\n</blockquote>\n<p>Assume I have the following data structure:</p>\n<pre><code>std::map&lt;size_t, double[2] &gt; trace;\n</code></pre>\n<p>how can I access its elements with the operator[]?</p>\n<p>Essentially I want to do something like:</p>\n<pre><code>trace[0][0] = 10.0;\ntrace[0][1] = 11.0;\n</code></pre>\n<p>In compiling these lines of code I get the following error:</p>\n<pre><code>/usr/include/c++/4.6/bits/stl_map.h:453:11: error: conversion from \u2018int\u2019 to non-scalar type \u2018std::map&lt;long unsigned int, double [2]&gt;::mapped_type {aka double [2]}\u2019 requested\n</code></pre>\n<p>comments?</p>\n", "AcceptedAnswerId": "13527994", "Title": "c++ access elements of the array in a map", "CreationDate": "2012-11-23T10:51:28.483", "Id": "13527568", "CommentCount": "14", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:18:43.803", "LastEditorUserId": "-1", "LastActivityDate": "2012-11-23T14:21:27.170", "Tags": "<c++><arrays><map>", "Score": "8", "OwnerUserId": "1324610", "ClosedDate": "2012-11-24T09:39:56.037", "AnswerCount": "3"}, "13528032": {"PostTypeId": "2", "Body": "<p>You can wrap an array:</p>\n<pre><code>template&lt;typename T, unsigned int n&gt;\nstruct ArrayWrapper\n{\n    T v[n];\n    T&amp; operator[](unsigned int i) { return v[i]; } // You can also check for out-of-bounds errors\n    const T&amp; operator[](unsigned int i) const { return v[i]; } // You can also check for out-of-bounds errors\n};\n#include &lt;map&gt;\n#include &lt;iostream&gt;\nint main()\n{\n    typedef std::map&lt;size_t, ArrayWrapper&lt;double,2&gt; &gt; Map;\n    Map trace;\n    trace[1][0] = 42;\n    for(Map::const_iterator it = trace.begin(); it != trace.end(); ++it)\n        std::cout &lt;&lt; \"( \" &lt;&lt; (*it).first\n            &lt;&lt; \", \" &lt;&lt; (*it).second[0]\n            &lt;&lt; \", \" &lt;&lt; (*it).second[1]\n            &lt;&lt; \")\\n\";\n}\n</code></pre>\n<p><a href=\"http://ideone.com/JpGQFO\" rel=\"nofollow\">Live example</a>. Else, if you have C++11, you should use <code>std::array</code>; if not, and you have Boost, you can use Boost.Array.</p>\n", "LastActivityDate": "2012-11-23T11:28:03.333", "LastEditorUserId": "1261432", "Id": "13528032", "CommentCount": "0", "CreationDate": "2012-11-23T11:20:55.520", "ParentId": "13527568", "Score": "1", "OwnerUserId": "1261432", "LastEditDate": "2012-11-23T11:28:03.333"}, "13528103": {"PostTypeId": "2", "Body": "<p>Your code compiles till:</p>\n<pre><code>std::map&lt;size_t, double[2]&gt; trace;\n</code></pre>\n<p>because <code>double[2]</code> is a valid type. You can declare a template class object with any valid type. For example:</p>\n<pre><code>template&lt;typename T&gt;\nstruct X {\n  // T t; // this will complain for sure\n  void foo () { T t; } // this won't complain unless invoked !!\n};\nX&lt;void&gt; x;\n</code></pre>\n<p>will compile without any problem.<br>\nIf you call <code>x.foo()</code>, the compiler will complain about it.     </br></p>\n<p>Same thing is happening in case of <code>std::map</code>. When you invoke functions like <code>map::insert()</code>, <code>map::operator []</code> where the value-type <code>double[2]</code> is actually going to be used, the compiler will start complaining as <code>double[2]</code> is not copyable (<em>exception</em>: I have seen an old g++3.x version where arrays were assignable and copyable).</p>\n<p>You can encapsulate your array into a structure.</p>\n<pre><code>struct D { double d[2]; };\n</code></pre>\n<p>If you want to avoid using raw array then <code>std::array</code> is good option as mentioned in comments and other answer.</p>\n", "LastActivityDate": "2012-11-23T11:25:07.103", "Id": "13528103", "CommentCount": "0", "CreationDate": "2012-11-23T11:25:07.103", "ParentId": "13527568", "Score": "1", "OwnerUserId": "514235"}, "13527994": {"PostTypeId": "2", "Body": "<p>Value types for maps must be default-constructible, using an expression <code>value_type()</code>, in order to access them via <code>[]</code>. For some mysterious reason, array types are not, as specified in C++11 5.3.2/2 (with my emphasis):</p>\n<blockquote>\n<p id=\"so_13527568_13527994_0\">The expression T(), where T is a simple-type-specifier or typename-specifier for a <strong>non-array</strong> complete object type ... creates a prvalue of the specified type,which is value-initialized </p>\n</blockquote>\n<p>The compiler gives that strange error when trying to value-initialise an array; the following gives the same error:</p>\n<pre><code>typedef double array[2];\narray();\n</code></pre>\n<p>I suggest using a class type rather than <code>double[2]</code>: <code>std::array&lt;double,2&gt;</code>, <code>std::pair&lt;double,double&gt;</code>, or a <code>struct</code> containing two doubles. Such types are copyable, don't decay into a pointer (losing compile-time knowledge of the size) at the drop of a hat, and are generally easier to deal than a built-in array type.</p>\n<p>If you're stuck with an old library that doesn't provide <code>std::array</code>, then you could use the very similar <a href=\"http://www.boost.org/doc/libs/release/doc/html/array.html\" rel=\"nofollow\">Boost.Array</a>, or write your own simple class template to wrap an array.</p>\n", "LastActivityDate": "2012-11-23T14:21:27.170", "LastEditorUserId": "204847", "Id": "13527994", "CommentCount": "0", "CreationDate": "2012-11-23T11:18:11.147", "ParentId": "13527568", "Score": "5", "OwnerUserId": "204847", "LastEditDate": "2012-11-23T14:21:27.170"}});