post_cb({"24045850": {"CommentCount": "5", "AcceptedAnswerId": "24046172", "PostTypeId": "1", "LastEditorUserId": "2502409", "CreationDate": "2014-06-04T19:23:31.573", "LastActivityDate": "2014-06-05T15:09:33.843", "LastEditDate": "2014-06-04T19:54:17.423", "ViewCount": "1024", "FavoriteCount": "2", "Title": "Why this code produces invalid alignment with MSVC?", "Id": "24045850", "Score": "9", "Body": "<p>I have tested this code on ideone.com and it outputs <code>16</code> as it should. However when I try it in Visual Studio 2013 it shows <code>8</code>. Is it a bug or lack of C++11 support from the compiler?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\nusing namespace std;\nusing float_pack = aligned_storage&lt;4 * sizeof(float), 16&gt;::type;\nint main() {\n\n    cout &lt;&lt; alignment_of&lt;float_pack&gt;::value &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>I have used alignment_of because MSVC doesn't support <code>alignof</code>.</p>\n<p><strong>Edit:</strong> I see that I can't get <code>16</code> alignment with <code>aligned_storage</code>. But why this snippet is ok?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;xmmintrin.h&gt;\nusing namespace std;\n\n__declspec(align(16)) struct float_pack {\n    float x[4];\n};\n\nint main()\n{\n    cout &lt;&lt; alignment_of&lt;float_pack&gt;::value &lt;&lt; endl;\n}\n</code></pre>\n<p>Output is <code>16</code>. Does that mean that compiler can provide larger alignment when using extensions? Why I can't achieve the same result with <code>aligned_storage</code>? Only because MSVC doesn't provide that with <code>aligned_storage</code>?</p>\n", "Tags": "<c++><visual-c++><c++11><memory-alignment>", "OwnerUserId": "2502409", "AnswerCount": "2"}, "24046172": {"ParentId": "24045850", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It looks like <code>std::max_align_t</code> is <code>8</code>, <a href=\"http://rextester.com/TNU94621\" rel=\"nofollow\">see it live</a>:</p>\n<pre><code>std::cout &lt;&lt; alignment_of&lt;std::max_align_t&gt;::value &lt;&lt; '\\n';\n</code></pre>\n<p>In the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>3.11</code> <em>Alignment</em> it says:</p>\n<blockquote>\n<p id=\"so_24045850_24046172_0\">A fundamental alignment is represented by an alignment less than or equal to the greatest alignment sup- ported by the implementation in all contexts, which is equal to alignof(std::max_align_t) (18.2).[...]</p>\n</blockquote>\n<p>Which says that that is the max alignment the implementation supports, this seems to be backed up by this <a href=\"http://www.boost.org/doc/libs/master/doc/html/align/vocabulary.html\" rel=\"nofollow\">boost doc</a> which says:</p>\n<blockquote>\n<p id=\"so_24045850_24046172_1\">An extended alignment is represented by an alignment greater than alignof(std::max_align_t). It is implementation-defined whether any extended alignments are supported and the contexts in which they are supported. A type having an extended alignment requirement is an over-aligned type.</p>\n</blockquote>\n<p><code>max_align_t</code> is by the standard tied to the fundamental alignment which James as informed us is <code>8 bytes</code>. Whereas an extension does not have to stick to this as long as it is documented which if we read the docs for <a href=\"http://msdn.microsoft.com/en-us/library/83ythb65.aspx\" rel=\"nofollow\">__declspec align</a> we see that it says:</p>\n<blockquote>\n<p id=\"so_24045850_24046172_2\">Writing applications that use the latest processor instructions\n  introduces some new constraints and issues. In particular, many new\n  instructions require that data must be aligned to 16-byte boundaries.\n  Additionally, by aligning frequently used data to the cache line size\n  of a specific processor, you improve cache performance. For example,\n  if you define a structure whose size is less than 32 bytes, you may\n  want to align it to 32 bytes to ensure that objects of that structure\n  type are efficiently cached.</p>\n<p id=\"so_24045850_24046172_3\">[...]</p>\n<p id=\"so_24045850_24046172_4\">Without __declspec(align(#)), Visual C++ aligns data on natural\n  boundaries based on the size of the data, for example 4-byte integers\n  on 4-byte boundaries and 8-byte doubles on 8-byte boundaries. Data in\n  classes or structures is aligned within the class or structure at the\n  minimum of its natural alignment and the current packing setting (from #pragma pack or the /Zp compiler option).</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-06-05T15:09:33.843", "Id": "24046172", "Score": "6", "CreationDate": "2014-06-04T19:42:58.743", "LastActivityDate": "2014-06-05T15:09:33.843"}, "24046184": {"ParentId": "24045850", "CommentCount": "0", "Body": "<p><code>std::aligned_storage</code> defines a type of size <code>Len</code>, with the alignment requirement you provide. If you ask for an unsupported alignment, your program is ill-formed.</p>\n<pre><code>template &lt;std::size_t Len, std::size_t Align\n    = default-alignment &gt; struct aligned_storage;\n</code></pre>\n<blockquote>\n<p id=\"so_24045850_24046184_0\">Len shall not be zero. Align shall be equal to <code>alignof(T)</code> for some type <code>T</code> or to <em>default-alignment</em>.</p>\n<p id=\"so_24045850_24046184_1\">The value of <em>default-alignment</em> shall be the most stringent alignment requirement for any C++ object type whose size is no greater than <code>Len</code> (3.9). The member typedef type shall be a POD type suitable for use as uninitialized storage for any object whose size is at most <code>Len</code> and whose alignment is a divisor of <code>Align</code>.</p>\n<p id=\"so_24045850_24046184_2\">[ Note: A typical implementation would define aligned_storage as:</p>\n</blockquote>\n<pre><code>template &lt;std::size_t Len, std::size_t Alignment&gt;\nstruct aligned_storage {\n    typedef struct {\n        alignas(Alignment) unsigned char __data[Len];\n    } type;\n};\n</code></pre>\n<blockquote>\n<p id=\"so_24045850_24046184_3\">\u2014end note ]</p>\n</blockquote>\n<p>And for <code>alignas</code>:</p>\n<blockquote>\n<h3>7.6.2 Alignment specifier [dcl.align]</h3>\n<p id=\"so_24045850_24046184_4\">1 An alignment-specifier may be applied to a variable or to a class data member, but it shall not be applied to a bit-field, a function parameter, the formal parameter of a catch clause (15.3), or a variable declared with the register storage class specifier. An alignment-specifier may also be applied to the declaration of a class or enumeration type. An alignment-specifier with an ellipsis is a pack expansion (14.5.3).<br>\n  2 When the alignment-specifier is of the form alignas( assignment-expression ):<br>\n  \u2014 the assignment-expression shall be an integral constant expression<br>\n  \u2014 if the constant expression evaluates to a fundamental alignment, the alignment requirement of the\n  declared entity shall be the specified fundamental alignment<br>\n  \u2014 if the constant expression evaluates to an extended alignment and the implementation supports that\n  alignment in the context of the declaration, the alignment of the declared entity shall be that alignment<br>\n  \u2014 if the constant expression evaluates to an extended alignment and the implementation does not support<br>\n  that alignment in the context of the declaration, the program is ill-formed\n  \u2014 if the constant expression evaluates to zero, the alignment specifier shall have no effect<br>\n  \u2014 otherwise, the program is ill-formed.</br></br></br></br></br></br></br></p>\n</blockquote>\n", "OwnerUserId": "3204551", "PostTypeId": "2", "Id": "24046184", "Score": "2", "CreationDate": "2014-06-04T19:43:46.493", "LastActivityDate": "2014-06-04T19:43:46.493"}, "bq_ids": {"n4140": {"so_24045850_24046184_4": {"section_id": 5533, "quality": 0.5913978494623656, "length": 55}, "so_24045850_24046172_0": {"section_id": 7241, "quality": 0.7647058823529411, "length": 13}, "so_24045850_24046184_2": {"section_id": 4723, "quality": 0.8333333333333334, "length": 5}, "so_24045850_24046172_1": {"section_id": 7242, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_24045850_24046184_4": {"section_id": 5319, "quality": 0.6129032258064516, "length": 57}, "so_24045850_24046172_0": {"section_id": 6985, "quality": 0.7647058823529411, "length": 13}, "so_24045850_24046184_2": {"section_id": 4530, "quality": 0.8333333333333334, "length": 5}, "so_24045850_24046172_1": {"section_id": 6986, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_24045850_24046184_2": {"section_id": 6122, "quality": 0.8333333333333334, "length": 5}, "so_24045850_24046172_0": {"section_id": 8750, "quality": 0.7647058823529411, "length": 13}, "so_24045850_24046172_1": {"section_id": 8751, "quality": 0.9090909090909091, "length": 20}}}});