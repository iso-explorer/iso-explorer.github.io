post_cb({"bq_ids": {"n4140": {"so_29827028_29827144_0": {"section_id": 6501, "quality": 0.7272727272727273, "length": 8}, "so_29827028_29827190_1": {"section_id": 576, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_29827028_29827144_0": {"section_id": 6256, "quality": 0.7272727272727273, "length": 8}, "so_29827028_29827190_1": {"section_id": 407, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_29827028_29827144_0": {"section_id": 4862, "quality": 0.7272727272727273, "length": 8}, "so_29827028_29827190_1": {"section_id": 599, "quality": 0.5714285714285714, "length": 4}}}, "29827379": {"ParentId": "29827028", "CommentCount": "0", "Body": "<p>C++ <a href=\"http://en.cppreference.com/w/cpp/string/byte/strstr\" rel=\"nofollow\">provides two versions</a> one that takes const arguments and ones that takes non-const.</p>\n<pre><code>const char* strstr( const char* str, const char* target );      \nchar* strstr(       char* str, const char* target );\n</code></pre>\n<p>Since in C we can not overload, we are left with two unpleasant choices: </p>\n<ul>\n<li>Either we take the arguments as non-const but if our sources are indeed const then we need to perform an unpleasant cast to non-const.</li>\n<li>The second option is the one we have which is that we take the arguments as const but we return a non-const. We could return a const char* but then we could never modify the result.</li>\n</ul>\n", "OwnerUserId": "1708801", "PostTypeId": "2", "Id": "29827379", "Score": "2", "CreationDate": "2015-04-23T15:03:07.737", "LastActivityDate": "2015-04-23T15:03:07.737"}, "29827190": {"ParentId": "29827028", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>C allows pointing to memory with const or non-const pointers, regardless if the object was defined with the const qualifier or not. </p>\n<blockquote>\n<p id=\"so_29827028_29827190_0\">6.5 Expressions</p>\n<ol start=\"7\">\n<li>An object shall have its stored value accessed only by an lvalue expression that has one of\n  the following types:</li>\n</ol>\n<p id=\"so_29827028_29827190_1\">\u2014 a qualified version of a type compatible with the effective type of the object,</p>\n</blockquote>\n<p>The prototype of strstr in C is:</p>\n<pre><code>char *strstr(const char *s1, const char *s2);\n</code></pre>\n<p>The returned pointer, if valid, points to string s1. This can be achieved with a cast:</p>\n<pre><code>const char safe = 's' ;\nchar* careful = ( char* )&amp;safe ;\n</code></pre>\n<p>The problem is modifying that memory.</p>\n<blockquote>\n<p id=\"so_29827028_29827190_2\">6.7.3 Type qualifiers</p>\n<ol start=\"6\">\n<li>If an attempt is made to modify an object defined with a const-qualified type through use\n  of an lvalue with non-const-qualified type, <em>the behavior is undefined.</em></li>\n</ol>\n</blockquote>\n<p>Since you created the string, you should know whether you can modify it or not, therefore you can accept the return value with a pointer to const, to avoid any problems:</p>\n<pre><code>const char* find = strstr( ... ) ;\n</code></pre>\n", "OwnerUserId": "4082723", "LastEditorUserId": "4082723", "LastEditDate": "2015-04-23T15:08:15.527", "Id": "29827190", "Score": "13", "CreationDate": "2015-04-23T14:55:57.260", "LastActivityDate": "2015-04-23T15:08:15.527"}, "29827097": {"ParentId": "29827028", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>All the <code>const char *</code> is telling you is that <code>strstr</code> is not going to modify the string you pass into it.</p>\n<p>Whether you modify the returned string or not is up to you as it is your string!</p>\n<p>In C++ this has been changed by overloading the method and having two versions, the <code>const</code> input version has a <code>const</code> output.</p>\n<p>In C it doesn't have quite that level of safety built in for you and assumes you know yourself whether you should be modifying the returned string.</p>\n", "OwnerUserId": "3049628", "LastEditorUserId": "3049628", "LastEditDate": "2015-04-23T14:57:33.767", "Id": "29827097", "Score": "28", "CreationDate": "2015-04-23T14:52:07.453", "LastActivityDate": "2015-04-23T14:57:33.767"}, "29827144": {"ParentId": "29827028", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>According to ISO C++ 21.8(7) <code>strstr</code> returns a <code>const char*</code> or a <code>char*</code> depending on if it gets a <code>const char*</code> or a <code>char*</code>.</p>\n<blockquote id=\"so_29827028_29827144_0\">\n<pre><code>const char* strstr(const char* s1, const char* s2);\n\nchar* strstr( char* s1, const char* s2);\n</code></pre>\n</blockquote>\n", "OwnerUserId": "4342498", "LastEditorUserId": "2069064", "LastEditDate": "2015-04-23T15:00:21.473", "Id": "29827144", "Score": "13", "CreationDate": "2015-04-23T14:54:06.097", "LastActivityDate": "2015-04-23T15:00:21.473"}, "29833426": {"ParentId": "29827028", "CommentCount": "0", "Body": "<p>The <code>strstr</code> function dates back to an era before there was such a thing as a <code>const</code> pointer.  In cases were it would be legal for code to write to memory identified by the first pointer passed to <code>strstr</code>, it would be legal for code to write to memory identified by the returned pointer, and in cases where the returned value would only be used in ways that were legal with a pointer to read-only memory (e.g. a string literal), one could legally pass such a pointer to <code>strstr</code>.</p>\n<p>If a functionality similar to <code>strstr</code> were being defined today, it might be implemented using two methods--one of which could accept any pointer and return a pointer which could not be written by the recipient, and one of which would only accept writable pointers but would return a pointer that the recipient could use as it saw fit.  Because some code which used <code>strstr</code> would need to pass read-only pointers, however, and because some code which used <code>strstr</code> needed to be able to write to the pointers that it would yield when given writable pointers, it was necessary to have one set of pointer qualifications work both ways.  The consequence is a set of pointer qualifications which are not really \"safe\" [since it may return a writable pointer to a read-only area of memory] and which will let code compile in some cases where it really \"shouldn't\", but which will allow code written before the days of <code>const</code> pointers to continue working as intended.</p>\n", "OwnerUserId": "363751", "PostTypeId": "2", "Id": "29833426", "Score": "4", "CreationDate": "2015-04-23T20:13:33.683", "LastActivityDate": "2015-04-23T20:13:33.683"}, "29827028": {"CommentCount": "3", "AcceptedAnswerId": "29827190", "PostTypeId": "1", "LastEditorUserId": "2304215", "CreationDate": "2015-04-23T14:49:19.230", "LastActivityDate": "2015-04-23T20:13:33.683", "LastEditDate": "2015-04-23T15:17:48.047", "ViewCount": "1699", "FavoriteCount": "0", "Title": "How strstr return is not a constant", "Id": "29827028", "Score": "25", "Body": "<p>The standard function <code>strstr</code> is used to find the location of a sub-string in a string. Both the arguments of the function are of <code>const char *</code> type, but the return type is <code>char *</code>.</p>\n<p>I would like to know how a standard function is implemented violating the const-correctness.</p>\n", "Tags": "<c++><c><string>", "OwnerUserId": "2243490", "AnswerCount": "7"}, "29827203": {"ParentId": "29827028", "CommentCount": "0", "Body": "<p>It's done by specifying the signature, and leaving the implementation up to the compiler builders.</p>\n<p>Note that returning a <code>char*</code> which points to a <code>const char[]</code> string is just dangerous, but not yet a violation of any rule. However, any attempt to write to that memory is still Undefined Behavior. </p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "29827203", "Score": "5", "CreationDate": "2015-04-23T14:56:19.160", "LastActivityDate": "2015-04-23T14:56:19.160"}, "29827200": {"ParentId": "29827028", "CommentCount": "1", "Body": "<p>The return value is not the variable that you have passed to the function as parameter. This function returns a pointer to the first occurrence in haystack of any of the entire sequence of characters specified in needle, or a null pointer if the sequence is not present in haystack.</p>\n", "OwnerUserId": "3910951", "PostTypeId": "2", "Id": "29827200", "Score": "1", "CreationDate": "2015-04-23T14:56:11.910", "LastActivityDate": "2015-04-23T14:56:11.910"}});