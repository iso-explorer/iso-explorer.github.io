post_cb({"bq_ids": {"n4140": {"so_19060720_19061195_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 5955}, "so_19060720_19061195_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 7112}, "so_19060720_19061195_1": {"length": 9, "quality": 0.9, "section_id": 5414}}, "n3337": {"so_19060720_19061195_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 5724}, "so_19060720_19061195_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 6856}, "so_19060720_19061195_6": {"length": 6, "quality": 0.75, "section_id": 5724}, "so_19060720_19061195_7": {"length": 6, "quality": 0.75, "section_id": 5724}, "so_19060720_19061195_1": {"length": 9, "quality": 0.9, "section_id": 5209}}, "n4659": {"so_19060720_19061195_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 7443}, "so_19060720_19061195_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 8613}, "so_19060720_19061195_1": {"length": 9, "quality": 0.9, "section_id": 6836}}}, "19061195": {"Id": "19061195", "PostTypeId": "2", "Body": "<p>The destructor call using a <em>qualified-id</em> here must consist of:</p>\n<p><em>postfix-expression</em> <code>-&gt;</code> <em>nested-name-specifier</em> <code>~</code> <em>class-name</em> <code>()</code></p>\n<p>The <em>postfix-expression</em> here is <code>wp</code>, and the part after <code>-&gt;</code> forms a <strong>single</strong> <em>qualified-id</em> (w/o the parens).</p>\n<p>Grammatically, the following is also possible:</p>\n<p><em>postfix-expression</em> <code>-&gt;</code> <em>nested-name-specifier</em> <code>~</code> <em>decltype-specifier</em> <code>()</code></p>\n<p>However, this second form is forbidden explicitly in [expr.prim.general]/9:</p>\n<blockquote>\n<p id=\"so_19060720_19061195_0\">The form <code>~ decltype-specifier</code> also denotes the destructor, but it shall not be used as the <em>unqualified-id</em> in a <em>qualified-id</em>.</p>\n</blockquote>\n<p>The <em>class-name</em> in the first form can also be a <em>typedef-name</em> [class.name]/5:</p>\n<blockquote>\n<p id=\"so_19060720_19061195_1\">A <em>typedef-name</em> (7.1.3) that names a class type, or a <em>cv</em>-qualified version thereof, is also a <em>class-name</em>.</p>\n</blockquote>\n<p>For the lookup of this <em>class-name</em> after the <code>~</code>, there's a special name lookup rule in [basic.lookup.qual]/5:</p>\n<blockquote>\n<p id=\"so_19060720_19061195_2\">Similarly, in a <em>qualified-id</em> of the form:<br/>\n  \u00a0\u00a0\u00a0\u00a0 <em>nested-name-specifier</em><sub>opt</sub> <em>class-name</em> <code>:: ~</code> <em>class-name</em><br/>\n  the second <em>class-name</em> is looked up in the same scope as the first.</p>\n</blockquote>\n<p>This means that the second <code>WeakPtr</code> in <code>A::WeakPtr :: ~WeakPtr</code> should be found. It is a <em>typedef-name</em> naming a class, therefore a <em>class-name</em>, and it's looked up in the scope of <code>A</code>. gcc follows this rule, clang++3.4 does not.</p>\n<p>Therefore, <code>wp-&gt;A::WeakPtr :: ~WeakPtr();</code> as <a href=\"https://stackoverflow.com/a/19061156/420683\">suggested</a> by <a href=\"https://stackoverflow.com/users/2073257/daniel-frey\">Daniel Frey</a> (and my first, deleted comment/guess) should work.</p>\n<hr>\n<p>Alternative approaches:</p>\n<ol>\n<li><p>Using a helper function:</p>\n<pre><code>template&lt;class T&gt;\nvoid destroy(T&amp; t)\n{ t.~T(); }\n</code></pre></li>\n<li><p>Using a <em>decltype-specifier</em> w/o a <em>qualified-id</em>. This one is tricky, as the type of <code>decltype(*wp)</code> is <code>A::WeakPtr&amp;</code>, as <code>*wp</code> yields an lvalue. However, we can convert the the expression to a prvalue to get rid of the reference:</p>\n<pre><code>wp-&gt;~decltype((A::WeakPtr)*wp)();\n// alternatively, w/o explicitly mentioning the type:\nwp-&gt;~decltype((std::remove_pointer&lt;decltype(wp)&gt;::type)*wp)();\n// simpler, using a helper function again:\ntemplate&lt;class T&gt;  T helper(T const&amp;);\nwp-&gt;~decltype(helper(*wp))();\n</code></pre></li>\n</ol>\n<hr>\n<p>Production:</p>\n<p>Begin with the function call [expr.post]/1:</p>\n<blockquote>\n<p id=\"so_19060720_19061195_3\"><em>postfix-expression</em> <code>(</code> <em>expression-list</em><sub>opt</sub> <code>)</code></p>\n</blockquote>\n<p>Where the <em>postfix-expression</em> here is produced via:</p>\n<blockquote>\n<p id=\"so_19060720_19061195_4\"><em>postfix-expression</em> <code>-&gt; template</code><sub>opt</sub> <em>id-expression</em></p>\n</blockquote>\n<p>This <em>postfix-expression</em> here maps to <code>wp</code> (in <code>wp-&gt;~something()</code>).</p>\n<p>The id-expression contains the destructor \"name\" [expr.prim.general]:</p>\n<blockquote>\n<p id=\"so_19060720_19061195_5\"><em>id-expression:</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <em>unqualified-id</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <em>qualified-id</em></p>\n</blockquote>\n<p>We do need a <em>qualified-id</em> here, so [expr.prim.general]/8:</p>\n<blockquote>\n<p id=\"so_19060720_19061195_6\"><em>qualified-id:</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <em>nested-name-specifier</em> <code>template</code><sub>opt</sub> <em>unqualified-id</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <code>::</code> <em>identifier</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <code>::</code> <em>operator-function-id</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <code>::</code> <em>literal-operator-id</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <code>::</code> template-id<br/></p>\n</blockquote>\n<p>Only the first one is of interest, so we look at <em>unqualified-id</em> s:</p>\n<blockquote>\n<p id=\"so_19060720_19061195_7\"><em>unqualified-id:</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <em>identifier</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <em>operator-function-id</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <em>conversion-function-id</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <em>literal-operator-id</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <code>~</code> <em>class-name</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <code>~</code> <em>decltype-specifier</em><br/>\n  \u00a0\u00a0\u00a0\u00a0 <em>template-id</em></p>\n</blockquote>\n<p>Where the two with a <code>~</code> can be used to call a destructor.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-27T23:24:47.383", "Score": "3", "CreationDate": "2013-09-27T22:39:23.740", "ParentId": "19060720", "CommentCount": "2", "OwnerUserId": "420683", "LastEditDate": "2017-05-23T12:15:15.653"}, "19061156": {"Id": "19061156", "PostTypeId": "2", "Body": "<p>Are you looking for</p>\n<pre><code>wp-&gt;A::WeakPtr::~WeakPtr();\n</code></pre>\n<p>?</p>\n", "LastActivityDate": "2013-09-27T22:36:25.523", "CommentCount": "6", "CreationDate": "2013-09-27T22:36:25.523", "ParentId": "19060720", "Score": "4", "OwnerUserId": "2073257"}, "19060720": {"ViewCount": "263", "Body": "\n<p>Suppose a <code>class</code> contains a type defined by a nested <code>using</code> whose destructor needs to be explicitly invoked. Is it necessary to use <code>using</code> to create a local type that doesn't include the namespace separator (<code>::</code>)?</p>\n<p>In this contrived example, I want to call <code>A::WeakPtr</code>'s destructor, like:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>wp-&gt;~A::WeakPtr();\n</code></pre>\n<p>instead of like:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>using AWeakPtr = A::WeakPtr;\nwp-&gt;~AWeakPtr()\n</code></pre>\n<p>Is this doable? Here's a complete example.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nstruct A : std::enable_shared_from_this&lt;A&gt; {\n  using SharedPtr = std::shared_ptr&lt;A&gt;;\n  using WeakPtr = std::weak_ptr&lt;A&gt;;\n\n  A()  { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\"; }\n  ~A() { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\"; }\n};\n\nint\nmain() {\n  {\n    std::unique_ptr&lt;A::WeakPtr, void(*)(void*)&gt;\n        uwp(static_cast&lt;A::WeakPtr*&gt;(std::malloc(sizeof(A::WeakPtr))), std::free);\n    A::WeakPtr* wp = uwp.get();\n\n    {\n      auto sp = std::make_shared&lt;A&gt;();\n      new(wp) A::WeakPtr(sp);\n\n      if (wp-&gt;lock())\n        std::cout &lt;&lt; \"Locked\\n\";\n      else\n        std::cout &lt;&lt; \"Unlocked\\n\";\n    }\n\n    if (wp-&gt;lock())\n      std::cerr &lt;&lt; \"EUNPOSSIBLE\\n\";\n    else\n      std::cout &lt;&lt; \"Unable to obtain lock\\n\";\n\n    // Need the following 'using' statement because the following is invalid syntax:\n    // wp-&gt;~A::WeakPtr();\n    using AWeakPtr = A::WeakPtr;\n    wp-&gt;~AWeakPtr();\n    // Is there a way to call A::WeakPtr without the using statement?\n  }\n  std::cout &lt;&lt; \"memory held by uwp has been free(3)'ed\\n\";\n}\n</code></pre>\n<p>It seems like there should be a way to defeat the <code>::</code> namespace separator with a <code>typename</code> scattered in there somewhere, but it doesn't look like it's possible. Obviously it's not the end of the world if it's not possible, but my curio is getting the better of me.</p>\n<hr>\n<p><strong>UPDATE</strong></p>\n<p>As suggested by @DanielFrey and @DyP's <a href=\"https://stackoverflow.com/a/19061195/736571\">fantastic answer</a>, the correct syntax is indeed</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>wp-&gt;A::WeakPtr::~WeakPtr();\n</code></pre>\n<p>but this doesn't work and is a bug (<a href=\"http://llvm.org/bugs/show_bug.cgi?id=12350\" rel=\"nofollow noreferrer\">#12350</a>) in clang++ (as of 2013-09-28).</p>\n</hr>", "AcceptedAnswerId": "19061195", "Title": "Calling object destructor whose type is nested inside of a class?", "CreationDate": "2013-09-27T21:57:14.860", "Id": "19060720", "CommentCount": "2", "LastEditDate": "2017-05-23T12:23:27.147", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-28T20:30:53.880", "Score": "1", "OwnerUserId": "736571", "Tags": "<c++11><destructor><using><placement-new><typename>", "AnswerCount": "2"}});