post_cb({"20000856": {"CommentCount": "8", "AcceptedAnswerId": "20002356", "PostTypeId": "1", "LastEditorUserId": "1645681", "CreationDate": "2013-11-15T12:14:34.657", "LastActivityDate": "2013-11-15T13:45:05.293", "LastEditDate": "2013-11-15T13:44:39.020", "ViewCount": "788", "FavoriteCount": "1", "Title": "On an example of global inline functions in C++", "Id": "20000856", "Score": "3", "Body": "<p>Considering the following setup, I have ran into a quite strange phenomena, which I can not really explain. Using Visual Studio 2005, the following piece of code results in crash. I would like to really know the reason.</p>\n<p><strong>playground.cpp</strong></p>\n<pre><code>static int local=-1;    \n#include \"common.h\"\n\nint main(int arg)\n{\n\n  setit();     \n  docastorUpdate();\n\n  return 0;\n}\n</code></pre>\n<p><strong>common.h</strong></p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n\nvoid docastorUpdate();\n\nstatic int *gemini;\n\ninline void setit()\n{\n  gemini = &amp;local;\n}\n</code></pre>\n<p><strong>castor.cpp</strong></p>\n<pre><code>static int local = 2;\n\n#include \"common.h\"\n\nvoid docastorUpdate() {\n  setit();\n\n  // crashing here, dereferencing a null pointer\n  std::cout &lt;&lt; \"castor:\" &lt;&lt; *gemini &lt;&lt; std::endl; \n}\n</code></pre>\n<p>The thing is, that the crash disappears when</p>\n<ol>\n<li>I move the inline function setit() to an unnamed namespace</li>\n<li>I make it static</li>\n</ol>\n<p>To put it in a nutshell, I would need help to understand the reasons. Any suggestion is appreciated! (I am aware that, this solution is not one of the best partices, just being curious.)</p>\n", "Tags": "<c++><pointers><static><inline><global>", "OwnerUserId": "1645681", "AnswerCount": "3"}, "20001007": {"ParentId": "20000856", "CommentCount": "1", "Body": "<p>you can avoid using static in all the places, you can use <code>extern</code> in your case:</p>\n<p>common.h:</p>\n<pre><code>extern int *gemini;\n</code></pre>\n<p>common.cpp;</p>\n<pre><code>int *gemini = nullptr;\n</code></pre>\n<p>also avoid using <code>local</code> like that , instead you can do this:</p>\n<pre><code>inline void setit(int * p)\n{\n    gemini = p;\n}\n\nvoid docastorUpdate()\n{\n    static int local = 2;\n    setit(&amp;local);\n    std::cout &lt;&lt; \"castor:\" &lt;&lt; *gemini &lt;&lt; std::endl;\n}\n</code></pre>\n", "OwnerUserId": "498424", "PostTypeId": "2", "Id": "20001007", "Score": "0", "CreationDate": "2013-11-15T12:23:18.133", "LastActivityDate": "2013-11-15T12:23:18.133"}, "20002356": {"ParentId": "20000856", "CommentCount": "0", "Body": "<p>Your code invokes <em>undefined behaviour</em>, in a very subtle way.</p>\n<blockquote>\n<p id=\"so_20000856_20002356_0\"><code>[C++11: 7.1.2/4]:</code> An inline function shall be defined in every translation unit in which it is ODR-used and shall have exactly the same definition in every case. <em>[..]</em></p>\n</blockquote>\n<p>Although the definition looks the same because it's lexically copy-pasted into each translation unit by your <code>#include</code>, it's not because <code>&amp;local</code> isn't taking the address of the same variable, in each case.</p>\n<p>As a result, anything can happen when you run your program, including transferring all your hard-earned savings into my bank account, or taking away all of Jon Skeet's rep.</p>\n<p>This is why making the function non-<code>inline</code> solves the problem; also, putting it in an unnamed namespace makes it a <em>different</em> function in each translation unit.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "20002356", "Score": "5", "CreationDate": "2013-11-15T13:37:19.993", "LastActivityDate": "2013-11-15T13:37:19.993"}, "20002365": {"ParentId": "20000856", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This breaks because you are violating the one-definition rule. The one-definition rule says that in a program, across all translation units, there is only one definition of any given function. <code>inline</code> is sort of an exception to this rule, and it more or less means \"dear compiler, there will be several definitions of this function, but they will all be the same, <em>I promise</em>\".</p>\n<p><code>static</code>, when used here for <code>local</code>, means \"dear compiler, this is an internal detail that only this translation unit will ever see; please do not confuse it with variables named <code>local</code> from other translation units\"</p>\n<p>So you promised the compiler that all definitions of <code>setit</code> will be the same, and asked the compiler to give each translation unit its very own <code>local</code> variable.</p>\n<p>However, since the <code>setit</code> function uses whatever variable named <code>local</code> is in scope, the end result is two different definitions of <code>setit</code>, each one using a different variable. <em>You just broke your promise</em>. The compiler trusted you and the result was a totally messed up program. It thought it could do certain things with the code based on your promises, but since you broke them behind its back, those things it tried to do with the code didn't work at all.</p>\n", "OwnerUserId": "46642", "LastEditorUserId": "46642", "LastEditDate": "2013-11-15T13:45:05.293", "Id": "20002365", "Score": "9", "CreationDate": "2013-11-15T13:37:46.157", "LastActivityDate": "2013-11-15T13:45:05.293"}, "bq_ids": {"n4140": {"so_20000856_20002356_0": {"section_id": 5404, "quality": 0.8, "length": 12}}, "n3337": {"so_20000856_20002356_0": {"section_id": 5199, "quality": 0.8, "length": 12}}, "n4659": {"so_20000856_20002356_0": {"section_id": 6853, "quality": 0.8, "length": 12}}}});