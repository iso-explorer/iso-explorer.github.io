post_cb({"30560064": {"Id": "30560064", "PostTypeId": "2", "Body": "<p>A temporary is still created. \u00a78.5.3/(5.2.2.2) applies<sup>1</sup>:</p>\n<blockquote>\n<p id=\"so_30559817_30560064_0\">Otherwise, a temporary of type \u201c <em>cv1</em> <code>T1</code>\u201d is created and\n  copy-initialized (8.5) from the initializer expression. The reference\n  is then bound to the temporary.</p>\n</blockquote>\n<p>This also applies in your second example. It does not apply for prvalues of class type, or scalar xvalues: Both</p>\n<pre><code>const A&amp; a = A();\n// and\nconst int&amp; i = std::move(myint);\n</code></pre>\n<p>do not introduce a temporary.  However, that isn't changing the final result : In any case, the temporary that is bound to the reference will be destroyed at the end of the <code>return</code> statement - \u00a712.2/(5.2):</p>\n<blockquote>\n<p id=\"so_30559817_30560064_1\">The lifetime of a temporary bound to the returned value in a function <code>return</code> statement (6.6.3) is not extended; the temporary\n  is destroyed at the end of the full-expression in the <code>return</code>\n  statement.</p>\n</blockquote>\n<p><strong>That is, the temporary is destroyed before the function even exits, and thus your program induces undefined behavior.</strong></p>\n<hr>\n<p><sup>1</sup> I could go on and quote the entire list to show why it does, but that would presumably be a waste of answer space.</p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-05-31T17:03:19.923", "Score": "1", "CreationDate": "2015-05-31T16:57:32.400", "ParentId": "30559817", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2015-05-31T17:03:19.923"}, "bq_ids": {"n4140": {"so_30559817_30560064_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 382}, "so_30559817_30561123_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 627}, "so_30559817_30560064_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 3321}}, "n3337": {"so_30559817_30560064_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 373}, "so_30559817_30561123_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 617}, "so_30559817_30560064_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 3191}}, "n4659": {"so_30559817_30560064_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 397}, "so_30559817_30561123_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 653}, "so_30559817_30560064_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 4087}}}, "30561123": {"Id": "30561123", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_30559817_30561123_0\">an implicit conversion from const char* to std::string which creates a temporary</p>\n</blockquote>\n<p>You are conflating the two topics. Implicit conversions are not the only thing that can create temporaries:</p>\n<pre><code>const std::string&amp; test() {\n    return std::string(\"no implicit conversions here.\");\n}\n</code></pre>\n<p>There is no implicit conversion to create the <code>string</code>, but the created <code>string</code> is still temporary, and so you're still returning a reference to a temporary object.</p>\n<p>In your example, <code>2</code> is still a temporary value, temporarily stored somewhere on the stack, and whose location/address is returned so callers can get at the value, but they are not supposed to.</p>\n", "LastActivityDate": "2015-05-31T18:32:36.990", "CommentCount": "0", "CreationDate": "2015-05-31T18:32:36.990", "ParentId": "30559817", "Score": "0", "OwnerUserId": "1566789"}, "30559817": {"ViewCount": "298", "Body": "<p>From <a href=\"https://stackoverflow.com/questions/1339601/warning-returning-reference-to-temporary\">this thread</a> it is clear that a string literal cannot be used for a function that returns const string&amp; since there is an implicit conversion from const char* to std::string which creates a temporary.</p>\n<p>But then why do I get a warning \"warning: returning reference to a temporary\" if my return type match exactly and there is no need for conversion, e.g.:</p>\n<pre><code>include &lt;iostream&gt;\n\nconst int&amp; test(){\n    return 2;\n}\n\nint main(){\n\n    std::cout &lt;&lt; test();\n\n}\n</code></pre>\n<p>No implicit conversion needed to happen on the return value of 2, so why is there a warning? I thought using test() would be pretty much the same as doing</p>\n<pre><code> const int&amp; example = 2;\n</code></pre>\n<p>which is perfectly valid. Additionally if I change 2 to 2.2 (so it is a double) the program still runs (with the same warning) despite the fact there IS a conversion from double to int? Shouldn't I be running in to an issue similar to how const char* was returned to the string reference, if there is a conversion from double to int?</p>\n", "Title": "Returning reference to temporary (built in types)", "CreationDate": "2015-05-31T16:34:23.773", "LastActivityDate": "2015-05-31T18:32:36.990", "CommentCount": "5", "LastEditDate": "2017-05-23T11:58:13.723", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "30559817", "Score": "3", "OwnerUserId": "4338785", "Tags": "<c++><reference><return><temporary>", "AnswerCount": "2"}});