post_cb({"30879994": {"ParentId": "30873671", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>My <a href=\"https://stackoverflow.com/a/30874396/2069064\">other answer</a> on here explains why your approach failed and one possible approach for a solution. I just thought of a much, much simpler one that I thought was worth sharing.</p>\n<p>The problem is that you can't use a trailing return type because the function name itself isn't in scope yet, so you can't use recursion in that way. However, there's nothing to stop you from writing a metafunction to determine what the return type should be. That metafunction is very simple:</p>\n<pre><code>template &lt;typename T1, typename T2&gt;\nstruct nested_common_type :std::common_type&lt;T1, T2&gt; { };\n\ntemplate &lt;typename T1, typename T2&gt;\nstruct nested_common_type&lt;std::vector&lt;T1&gt;, std::vector&lt;T2&gt;&gt; {\n    using type = std::vector&lt;typename nested_common_type&lt;T1,T2&gt;::type&gt;;\n};\n\ntemplate &lt;typename T1, typename T2&gt;\nusing vector_common_type_t = std::vector&lt;typename nested_common_type&lt;T1,T2&gt;::type&gt;;\n</code></pre>\n<p>And once we have the return type, we can just write one normal <code>operator+</code>:</p>\n<pre><code>template &lt;typename T1, typename T2,\n          typename R = vector_common_type_t&lt;T1,T2&gt;&gt;\nR operator+(const std::vector&lt;T1&gt;&amp; l, const std::vector&lt;T2&gt;&amp; r)\n{\n    R ans;\n    std::transform(l.begin(),\n                   l.begin() + std::min(l.size(), r.size()),\n                   r.begin(),\n                   std::back_inserter(ans),\n                   [](const T1&amp; lhs, const T2&amp; rhs){ return lhs + rhs; });\n    return ans;\n}\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:51:17.247", "Id": "30879994", "Score": "1", "CreationDate": "2015-06-16T23:35:39.770", "LastActivityDate": "2015-06-16T23:35:39.770"}, "30874396": {"ParentId": "30873671", "CommentCount": "11", "Body": "<p>The problem you're running into has to do with name lookup. You are doing unqualified name lookup on <code>operator+</code> here:</p>\n<pre><code>template&lt;typename T1, typename T2&gt;\nauto operator+(const std::vector&lt;T1&gt;&amp; l, const std::vector&lt;T2&gt;&amp; r) \n-&gt; std::vector&lt;decltype((l[0] + r[0]))&gt; {\n                        ^^^^^^^^^^^^^\n</code></pre>\n<p>From [basic.scope.pdecl]:</p>\n<blockquote>\n<p id=\"so_30873671_30874396_0\">The <em>point of declaration</em> for a name is immediately after its complete declarator (Clause 8) and before its\n  <em>initializer</em> (if any)</p>\n</blockquote>\n<p>And in that function, the \"complete declarator\" includes the <em>trailing-return-type</em>. So your <code>operator+</code> template will not be in scope until <em>after</em> the declarator. That is, the <code>{</code></p>\n<p>The other problem is <code>std::plus</code>. <code>std::plus</code> will never find your <code>operator+</code> since it won't have existed yet at the time that <code>std::plus</code> is defined. </p>\n<p>The simplest solution, in C++14, is to drop the trailing return type (it'll be deduced correctly anyway) and to replace <code>std::plus</code> with a simple lambda:</p>\n<pre><code>auto plus = [](const type&amp; lhs, const type&amp; rhs) { return lhs + rhs; };\n</code></pre>\n<p>Without C++14, you'll have to forward everything to another function so that name lookup <em>can</em> succeed. You can either use an ADL trick for that, but I think a template is a little easier to understand. Here's a working solution:</p>\n<pre><code>template &lt;typename T1, typename T2&gt;\nstruct Add : std::plus&lt;T1&gt; { };\n\ntemplate &lt;typename T1, typename T2&gt;\nstruct Add&lt;std::vector&lt;T1&gt;, std::vector&lt;T2&gt;&gt;\n{   \n    auto operator()(const std::vector&lt;T1&gt;&amp; l, const std::vector&lt;T2&gt;&amp; r)\n        -&gt; std::vector&lt;decltype(Add&lt;T1,T2&gt;{}(l[0], r[0]))&gt;\n    {\n        using type = decltype(Add&lt;T1,T2&gt;{}(l[0], r[0]));\n        std::vector&lt;type&gt; ans;\n\n        if(l.size() == std::max(l.size(),r.size()))\n            std::transform(r.begin(), r.end(), l.begin(), std::back_inserter(ans), Add&lt;T1,T2&gt;{});\n        else\n            std::transform(l.begin(), l.end(), r.begin(), std::back_inserter(ans), Add&lt;T1,T2&gt;{});\n        return ans;\n    };\n};\n\ntemplate &lt;typename T1, typename T2&gt;\nauto operator+(const std::vector&lt;T1&gt;&amp; lhs, const std::vector&lt;T2&gt;&amp; rhs)\n    -&gt; decltype(Add&lt;std::vector&lt;T1&gt;, std::vector&lt;T2&gt;&gt;{}(lhs, rhs))\n{\n    return Add&lt;std::vector&lt;T1&gt;, std::vector&lt;T2&gt;&gt;{}(lhs, rhs);\n}\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "30874396", "Score": "3", "CreationDate": "2015-06-16T17:34:06.197", "LastActivityDate": "2015-06-16T17:34:06.197"}, "30873671": {"CommentCount": "6", "ViewCount": "161", "PostTypeId": "1", "LastEditorUserId": "4955004", "CreationDate": "2015-06-16T16:53:37.947", "LastActivityDate": "2015-06-16T23:35:39.770", "Title": "decltype does not resolve nested vectors. How can I use templates for nested vectors?", "AcceptedAnswerId": "30879994", "LastEditDate": "2015-06-16T21:46:29.107", "Id": "30873671", "Score": "1", "Body": "<p>I am trying to overload the + operator to deal with nested vectors.  I thought the function would call itself until the nested vectors resolve to basic types, but instead I get a huge list of errors when I compile it.  My vector operations that I have defined work for basic types, but not a variable amount of nested vectors.  The only operation that does work for nested vectors is the &lt;&lt; operator.</p>\n<p>main.cpp</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\ntemplate&lt;typename T1&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, std::vector&lt;T1&gt; r){\n    if(r.size() == 0){\n        return stream;\n    }\n    else{\n        stream &lt;&lt; \"(\";\n        for(int i = 0; i &lt; r.size(); i++){\n            if(i &lt; (r.size() - 1)){\n                stream &lt;&lt; r[i] &lt;&lt; \", \";\n            }\n            else{\n                stream &lt;&lt; r[i] &lt;&lt; \")\";\n            }\n        }\n    }\n    return stream;\n};\n\ntemplate&lt;typename T1, typename T2&gt;\nauto operator+(const std::vector&lt;T1&gt;&amp; l, const std::vector&lt;T2&gt;&amp; r) \n-&gt; std::vector&lt;decltype((l[0] + r[0]))&gt;{\n    typedef decltype((l[0] + r[0])) type;\n    std::vector&lt;type&gt; ans;\n    if(l.size() == std::max(l.size(),r.size()))\n        std::transform(r.begin(), r.end(), l.begin(), std::back_inserter(ans), std::plus&lt;type&gt;());\n    else\n        std::transform(l.begin(), l.end(), r.begin(), std::back_inserter(ans), std::plus&lt;type&gt;());\n    return ans;\n};\n\nint main(){\n\n    std::vector&lt;std::vector&lt;int&gt;&gt; vecvec = {{1,2,3},{4,5,6},{7,8,9}};\n    std::vector&lt;int&gt; vec = {1,2,3};\n\n    //Both output statements compile\n    std::cout &lt;&lt; vec    &lt;&lt; std::endl;\n    std::cout &lt;&lt; vecvec &lt;&lt; std::endl;\n\n    //Does not compile \n    vecvec = vecvec + vecvec;\n\n    //Does compile\n    vec = vec + vec;\n\n    return 0;\n} \n</code></pre>\n<p>Now I am not able to do type promotion with nested vectors.  I think I need std::plus T1 or std::plus T2 depending on promotion rules.</p>\n<pre><code>template &lt;typename T1, typename T2&gt;\nstruct Add : std::plus&lt;T1&gt; { };//&lt;- Here\n\ntemplate &lt;typename T1, typename T2&gt;\nstruct Add&lt;std::vector&lt;T1&gt;, std::vector&lt;T2&gt;&gt;\n{   \n    auto operator()(const std::vector&lt;T1&gt;&amp; l, const std::vector&lt;T2&gt;&amp; r)\n        -&gt; std::vector&lt;decltype(Add&lt;T1,T2&gt;{}(l[0], r[0]))&gt;\n    {\n        using type = decltype(Add&lt;T1,T2&gt;{}(l[0], r[0]));\n        std::vector&lt;type&gt; ans;\n\n        if(l.size() == std::max(l.size(),r.size()))\n            std::transform(r.begin(), r.end(), l.begin(), std::back_inserter(ans), Add&lt;T1,T2&gt;{});\n        else\n            std::transform(l.begin(), l.end(), r.begin(), std::back_inserter(ans), Add&lt;T1,T2&gt;{});\n        return ans;\n    };\n};\n\ntemplate &lt;typename T1, typename T2&gt;\nauto operator+(const std::vector&lt;T1&gt;&amp; lhs, const std::vector&lt;T2&gt;&amp; rhs)\n    -&gt; decltype(Add&lt;std::vector&lt;T1&gt;, std::vector&lt;T2&gt;&gt;{}(lhs, rhs))\n{\n    return Add&lt;std::vector&lt;T1&gt;, std::vector&lt;T2&gt;&gt;{}(lhs, rhs);\n}\n</code></pre>\n<p>I tried this and got an output of 2 instead of 2.5.</p>\n<pre><code>int main(){\n    p(int) e = {1};\n    p(double) q = {1.5};\n    std::cout &lt;&lt; (e + q) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates><vector><nested>", "OwnerUserId": "4955004", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_30873671_30874396_0": {"section_id": 7049, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_30873671_30874396_0": {"section_id": 6794, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_30873671_30874396_0": {"section_id": 8546, "quality": 0.8461538461538461, "length": 11}}}});