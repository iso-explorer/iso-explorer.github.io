post_cb({"24814591": {"ParentId": "24813219", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This is an MSVC bug that has been fixed in VS2012. </p>\n<p>In the statement </p>\n<pre><code>vector&lt;vector&lt;int&gt; &gt; k(2, 3);\n</code></pre>\n<p>you're attempting to construct a 2 element vector, and construct a <code>vector::value_type</code> (i.e. <code>vector&lt;int&gt;</code>) instance with the argument <code>3</code>. However, the <code>vector&lt;int&gt;</code> constructor that takes a count is <code>explicit</code>, which causes the construction to fail.</p>\n<p>C++03 states that if the constructor </p>\n<pre><code>template&lt; class InputIt &gt;\nvector(InputIt first, InputIt last, const Allocator&amp; alloc = Allocator());\n</code></pre>\n<p>is called with integral types for <code>InputIt</code>, the call should behave as if the constructor that takes a count and <code>value_type</code> instance was called.</p>\n<p>From the C++03 standard <em>23.1.1/9 [lib.sequence.reqmts]</em></p>\n<blockquote>\n<p id=\"so_24813219_24814591_0\">For every sequence defined in this clause and in clause 21:<br/>\n  \u2014 the constructor</p>\n<pre><code> template &lt;class InputIterator&gt;\n X(InputIterator f, InputIterator l, const Allocator&amp; a = Allocator())\n</code></pre>\n<p id=\"so_24813219_24814591_1\">shall have the same effect as:</p>\n<pre><code> X(static_cast&lt;typename X::size_type&gt;(f), \n   static_cast&lt;typename X::value_type&gt;(l), a)\n</code></pre>\n<p id=\"so_24813219_24814591_2\">if <code>InputIterator</code> is an integral type.</p>\n</blockquote>\n<p>This proves that the VS2010 behavior is a bug.</p>\n<hr>\n<p>The gcc error messages differ between the C++03 and C++11 standards because C++11 changed the wording of the requirement quoted above.</p>\n<p>From N3337 <em>\u00a723.2.3/14 [sequence.reqmts]</em></p>\n<blockquote>\n<p id=\"so_24813219_24814591_3\">For every sequence container defined in this Clause and in Clause 21:<br/>\n  \u2014 If the constructor</p>\n<pre><code> template &lt;class InputIterator&gt;\n X(InputIterator first, InputIterator last, \n   const allocator_type&amp; alloc = allocator_type())\n</code></pre>\n<p id=\"so_24813219_24814591_4\">is called with a type <code>InputIterator</code> that does not qualify as an input iterator, then the constructor shall not participate in overload resolution.</p>\n</blockquote>\n<p>C++11 doesn't require that the constructor taking count and value be matched, hence the gcc error message states that, given the two integral arguments, no matching constructor was found (because the second argument cannot be implicitly converted to <code>vector&lt;int&gt;</code>).</p>\n</hr>", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2014-07-17T22:35:41.220", "Id": "24814591", "Score": "2", "CreationDate": "2014-07-17T22:30:39.703", "LastActivityDate": "2014-07-17T22:35:41.220"}, "24813219": {"CommentCount": "6", "ViewCount": "215", "CreationDate": "2014-07-17T20:45:35.483", "LastActivityDate": "2014-07-17T22:35:41.220", "Title": "Inconsistent behaviours between VS2010 and GCC4.8.1 when preallocating a 2D vector?", "AcceptedAnswerId": "24814591", "PostTypeId": "1", "Id": "24813219", "Score": "3", "Body": "<p>I normally use the following declaration to preallocate a 2d vector, and it works fine in both VS2010 and GCC4.8.1</p>\n<pre><code>vector&lt;vector&lt;int&gt; &gt; k(2, vector&lt;int&gt;(3, 0));\n</code></pre>\n<p>However, I have recently noticed that another simpler statement:</p>\n<pre><code>vector&lt;vector&lt;int&gt; &gt; k(2, 3); \n</code></pre>\n<p>also achieves the same effect (i.e. defines a 2d vector k where k.size() == 2 and k[i].size() == 3 for i = 0 to 1) in VS2010. However, when I try this declaration with GCC4.8.1 (through Dev C++, with ISO C++ 11 support switched on), the compiler reports an error:</p>\n<blockquote>\n<p id=\"so_24813219_24813219_0\">62    31  D:\\Dev-Cpp\\Projects\\TestProg\\main.cpp [Error] no matching function for call to 'std::vector &lt; std::vector &lt; int &gt; &gt;::vector(int, int)'</p>\n</blockquote>\n<p>If I switch the 'Language Standard' flag from 'ISO C++ 11' to 'ISO C++', then it reports an error in stl_vector.h:</p>\n<blockquote>\n<p id=\"so_24813219_24813219_1\">1166  59  d:\\orwelldevcpp\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\4.8.1\\include\\c++\\bits\\stl_vector.h  [Error]\n  no matching function for call to 'std::vector &lt; std::vector &lt; int &gt; &gt; ::_M_fill_initialize(std::vector &lt; std::vector &lt; int &gt; &gt; ::size_type, int&amp;)'</p>\n</blockquote>\n<p>I also traced the execution of this confusing constructor call in VS2010, and apparently VS matches it to the 'range' constructor:</p>\n<pre><code>template&lt;class _Iter&gt;\n    vector(_Iter _First, _Iter _Last)\n    : _Mybase()\n    {   // construct from [_First, _Last)\n    _Construct(_First, _Last, _Iter_cat(_First));\n    }\n</code></pre>\n<p>The function call that throws an error in GCC without C++11 standard (_M_fill_initialize) is also called by the range constructor. So I think it means GCC also matches the constructor call to the range constructor, but somehow cannot finish the initialization.</p>\n<hr>\n<p>So I am very confused at this point:</p>\n<p>1: Why is this function matched to the range constructor?</p>\n<p>2: Why does C++ 11 seem to disallow such a match?</p>\n<p>3: Why does VS accept this usage while GCC fails on it, even without the C++11 flag? </p>\n<hr>\n<p>Thank you very much for your help!</p>\n</hr></hr>", "Tags": "<c++><gcc><c++11><vector><constructor>", "OwnerUserId": "2676766", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24813219_24814591_0": {"section_id": 733, "quality": 0.5714285714285714, "length": 4}, "so_24813219_24814591_4": {"section_id": 733, "quality": 1.0, "length": 12}, "so_24813219_24814591_3": {"section_id": 733, "quality": 0.875, "length": 7}}, "n3337": {"so_24813219_24814591_0": {"section_id": 722, "quality": 0.5714285714285714, "length": 4}, "so_24813219_24814591_4": {"section_id": 722, "quality": 1.0, "length": 12}, "so_24813219_24814591_3": {"section_id": 722, "quality": 0.875, "length": 7}}, "n4659": {"so_24813219_24814591_0": {"section_id": 763, "quality": 0.5714285714285714, "length": 4}, "so_24813219_24814591_4": {"section_id": 763, "quality": 1.0, "length": 12}, "so_24813219_24814591_3": {"section_id": 763, "quality": 0.875, "length": 7}}}});