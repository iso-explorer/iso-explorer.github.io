post_cb({"48452611": {"ViewCount": "103", "Body": "<p>Here is the code:</p>\n<pre><code>  std::vector&lt;bool&gt; a(req_count_);\n  std::vector&lt;std::future&lt;void&gt;&gt; waits(req_count_);\n\n  for (int i = 0; i &lt; req_count_; i++) {\n    waits[i] = framework::Async([i, &amp;a] { // send into a threadpool implementation\n      a[i] = true; // write true\n    });\n  }\n\n  for (int i = 0; i &lt; req_count_; i++) {\n    waits[i].wait(); // memory barrier?\n  }\n\n  int last_req_count = req_count_;\n  req_count_ = 0;\n\n  for (int i = 0; i &lt; last_req_count; i++) {\n    if (!a[i]) { // read false\n      return false;\n    }\n  }\n</code></pre>\n<p>My question is does <code>std::future::wait</code> serves as a memory barrier? <code>std::future::wait</code> waits for the function call to complete, but does the function <strong>happens before</strong> <code>std::future::wait</code> (e.g., does the state mutation caused by the function call visible from other threads)?</p>\n<p>If <code>std::future::wait</code> does not serves as a memory barrier, how can we implement the threadpool so that a memory barrier is triggered automatically when the future completes?</p>\n<p>Please correct me if you think my understanding of memory barrier is wrong.</p>\n", "AcceptedAnswerId": "48453119", "Title": "Is std::future::wait a memory barrier? (I can not explain this data race)", "CreationDate": "2018-01-25T22:01:39.177", "LastActivityDate": "2018-01-25T22:44:00.773", "CommentCount": "4", "LastEditDate": "2018-01-25T22:09:45.333", "PostTypeId": "1", "LastEditorUserId": "2684539", "Id": "48452611", "Score": "3", "OwnerUserId": "852385", "Tags": "<c++><multithreading><c++11>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_48452611_48453119_1": {"length": 27, "quality": 0.84375, "section_id": 719}, "so_48452611_48453119_0": {"length": 18, "quality": 0.9, "section_id": 718}}, "n3337": {"so_48452611_48453119_1": {"length": 27, "quality": 0.84375, "section_id": 708}, "so_48452611_48453119_0": {"length": 17, "quality": 0.85, "section_id": 707}}, "n4659": {"so_48452611_48453119_1": {"length": 27, "quality": 0.84375, "section_id": 750}, "so_48452611_48453119_0": {"length": 18, "quality": 0.9, "section_id": 749}}}, "48453119": {"Id": "48453119", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48452611_48453119_0\"><strong>[container.requirements.dataraces]/2</strong> Notwithstanding <strong>[res.on.data.races]</strong>, implementations are required to avoid data races when the contents of the contained object in different elements in the same container, <strong>excepting <code>vector&lt;bool&gt;</code></strong>, are modified concurrently.</p>\n<p id=\"so_48452611_48453119_1\"><strong>[container.requirements.dataraces]/3</strong> [ <em>Note:</em> For a <code>vector&lt;int&gt; x</code> with a size greater than one, <code>x[1] = 5</code> and <code>*x.begin() = 10</code> can be executed concurrently without a data race, but <code>x[0] = 5</code> and <code>*x.begin() = 10</code> executed concurrently may result in a data race. As an exception to the general rule, for a <code>vector&lt;bool&gt; y</code>, <code>y[0] = true</code> may race with <code>y[1] = true</code>. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Emphasis mine. The race happens in <code>a[i] = true;</code>. <code>vector&lt;bool&gt;</code> is not a real container, accessing an \"element\" requires bit manipulations that touch neighboring elements.</p>\n", "LastActivityDate": "2018-01-25T22:44:00.773", "Score": "9", "CreationDate": "2018-01-25T22:44:00.773", "ParentId": "48452611", "CommentCount": "0", "OwnerUserId": "1670129"}});