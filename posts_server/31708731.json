post_cb({"31709049": {"ParentId": "31708731", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>From [expr]</p>\n<blockquote>\n<p id=\"so_31708731_31709049_0\">If an expression initially has the type \u201creference to T\u201d (8.3.2, 8.5.3), the type is adjusted to T prior to\n  any further analysis. The expression designates the object or function denoted by the reference, and the\n  expression is an lvalue or an xvalue, depending on the expression.</p>\n</blockquote>\n<p>The expression <code>b</code> initially has type \"reference to <code>Base</code>\", so the type is adjusted to <code>Base</code>. It is an lvalue, which is a glvalue. </p>\n<p>From [class.virtual]:</p>\n<blockquote>\n<p id=\"so_31708731_31709049_1\">A class that declares or inherits a virtual function is called a polymorphic class.</p>\n</blockquote>\n<p><code>Base</code> declares a virtual function, so it is a polymorphic class.</p>\n<p>From [expr.typeid]:</p>\n<blockquote>\n<p id=\"so_31708731_31709049_2\">When <code>typeid</code> is applied to a glvalue expression whose type is a polymorphic class type (10.3), the result refers\n  to a <code>std::type_info</code> object representing the type of the <strong>most derived object</strong> (1.8) (that is, the dynamic\n  type) to which the glvalue refers.</p>\n</blockquote>\n<p>Based on the above, we satisfy the initial conditions (the expression is a glvalue whose type is a polymorphic class type), so we pick the most derived object to which <code>b</code> refers to. That would be <code>d</code>, which has type <code>Derived</code>. </p>\n<p>If <code>b</code> were a <code>Base</code> instead of a <code>Base&amp;</code>, then the most derived object would be <code>b</code> itself. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-07-29T19:39:35.443", "Id": "31709049", "Score": "5", "CreationDate": "2015-07-29T19:04:24.373", "LastActivityDate": "2015-07-29T19:39:35.443"}, "31708731": {"CommentCount": "7", "AcceptedAnswerId": "31709049", "PostTypeId": "1", "LastEditorUserId": "1413395", "CreationDate": "2015-07-29T18:48:04.177", "LastActivityDate": "2015-07-29T19:39:35.443", "LastEditDate": "2015-07-29T18:52:23.677", "ViewCount": "79", "FavoriteCount": "1", "Title": "Why is a reference to a polymorphic class, polymorphic?", "Id": "31708731", "Score": "3", "Body": "<p>It is a well known fact that the snippet below prints <code>Derived</code> or something similar.</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;typeinfo&gt;\nclass Base { public: virtual ~Base(){} };\nclass Derived : public Base{};\nint main()\n{\n     Derived d;    \n     Base&amp; b = d;\n     std::cout &lt;&lt; typeid(b).name() &lt;&lt; '\\n';\n}\n</code></pre>\n<p>But I'd like to understand how could one conclude this, from paragraph \u00a75.2.8/2 in the Standard (N4140). For example, <code>b</code> is certainly a glvalue, but the type <code>Base&amp;</code> is not the same as <code>Base</code>, so I can't say that <code>b</code> is polymorphic. What am I missing?</p>\n", "Tags": "<c++><polymorphism><language-lawyer>", "OwnerUserId": "4470210", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31708731_31709049_2": {"section_id": 6021, "quality": 0.9583333333333334, "length": 23}, "so_31708731_31709049_1": {"section_id": 7002, "quality": 0.875, "length": 7}, "so_31708731_31709049_0": {"section_id": 5938, "quality": 0.8695652173913043, "length": 20}}, "n3337": {"so_31708731_31709049_2": {"section_id": 5789, "quality": 0.9583333333333334, "length": 23}, "so_31708731_31709049_1": {"section_id": 6748, "quality": 0.875, "length": 7}, "so_31708731_31709049_0": {"section_id": 5710, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_31708731_31709049_2": {"section_id": 7520, "quality": 0.9583333333333334, "length": 23}, "so_31708731_31709049_1": {"section_id": 8499, "quality": 0.875, "length": 7}, "so_31708731_31709049_0": {"section_id": 7422, "quality": 0.8695652173913043, "length": 20}}}});