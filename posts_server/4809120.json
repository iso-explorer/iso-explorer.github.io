post_cb({"4809309": {"Id": "4809309", "PostTypeId": "2", "Body": "<p>If your function f is a factory method, it is better to return a pointer, or an initialized smart pointer object such as auto_ptr.</p>\n<pre><code>auto_ptr&lt;Object&gt; f()\n{\n     return auto_ptr&lt;Object&gt;(new Object);\n}\n</code></pre>\n<p>To use:</p>\n<pre><code>{    \n    auto_ptr&lt;Object&gt; myObjPtr = f();\n    //use myObjPtr . . . \n} // the new Object is deleted when myObjPtr goes out of scope\n</code></pre>\n", "LastActivityDate": "2011-01-26T19:53:32.867", "CommentCount": "0", "CreationDate": "2011-01-26T19:53:32.867", "ParentId": "4809120", "Score": "1", "OwnerUserId": "540815"}, "4809174": {"Id": "4809174", "PostTypeId": "2", "Body": "<p>The compiler will optimize it.</p>\n<p>Except in some situations, <a href=\"http://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"nofollow\">such as</a>:</p>\n<blockquote id=\"so_4809120_4809174_0\">\n<pre><code>std::string f(bool cond = false)\n{\n  std::string first(\"first\");\n  std::string second(\"second\");\n  // the function may return one of two named objects\n  // depending on its argument. RVO might not be applied\n  if(cond)\n    return first;\n  else\n    return second;\n}\n</code></pre>\n</blockquote>\n<p>Of course there can be some old compilers, which can call copy constructor. But you shouldn't worry about it with modern compilers.</p>\n", "LastEditorUserId": "511601", "LastActivityDate": "2011-01-26T19:51:59.027", "Score": "2", "CreationDate": "2011-01-26T19:40:47.397", "ParentId": "4809120", "CommentCount": "1", "OwnerUserId": "556049", "LastEditDate": "2011-01-26T19:51:59.027"}, "bq_ids": {"n4140": {"so_4809120_4809146_1": {"length": 55, "quality": 0.9016393442622951, "section_id": 480}}, "n3337": {"so_4809120_4809146_1": {"length": 55, "quality": 0.9016393442622951, "section_id": 471}}, "n4659": {"so_4809120_4809146_1": {"length": 55, "quality": 0.9016393442622951, "section_id": 502}, "so_4809120_4809171_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 394}}}, "4809160": {"Id": "4809160", "PostTypeId": "2", "Body": "<p>In theory what you describe is what should happen. Anyway compilers are often able to optimize it in a way, that the caller's <code>Object</code> is used: <code>f</code> will directly write on caller's object and return null.</p>\n<p>This is called <a href=\"http://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"nofollow\">Return Value Optimization</a> (or RVO)</p>\n", "LastActivityDate": "2011-01-26T19:39:54.987", "CommentCount": "0", "CreationDate": "2011-01-26T19:39:54.987", "ParentId": "4809120", "Score": "2", "OwnerUserId": "300805"}, "4809411": {"Id": "4809411", "PostTypeId": "2", "Body": "<p>Whether the compiler can apply RVO depends on the actual code involved.  A general guideline is to create the returned value as late as possible.  For example:</p>\n<pre><code>std::string no_rvo(bool b) {\n  std::string t = \"true\", f = \"fals\";\n\n  f += t[3];  // Imagine a \"sufficiently smart compiler\" couldn't delay initialization\n  // for some reason, such not noticing only one object is required depending on some\n  // condition.\n\n  //return (b ? t : f);  // or more verbosely:\n  if (b) {\n    return t;\n  }\n  return f;\n}\n\nstd::string probably_rvo(bool b) {\n  // Delay creation until the last possible moment; RVO still applies even though\n  // this is superficially similar to no_rvo.\n  if (b) {\n    return \"true\";\n  }\n  return \"false\";\n}\n</code></pre>\n<p>With C++0x, the compiler is free to make even more assumptions, principally by being able to use move semantics.  How those work is a 'nother can of worms, but move semantics are being designed so that they can apply to the exact code above.  This helps most dramatically in the no_rvo case, but it provides guaranteed semantics in both cases, as a move operation (if possible) is preferred over a copy operation, while RVO is completely optional and not easy to check.</p>\n", "LastActivityDate": "2011-01-26T20:02:56.623", "CommentCount": "0", "CreationDate": "2011-01-26T20:02:56.623", "ParentId": "4809120", "Score": "2", "OwnerUserId": "511601"}, "4809764": {"Id": "4809764", "PostTypeId": "2", "Body": "<p>I don't know why nobody pointed out the obvious solution yet. Just pass the output object by reference:</p>\n<pre><code>void f(Object&amp; result) {\n  result.do_something();\n  result.fill_with_values(/* */);\n};\n</code></pre>\n<p>This way:</p>\n<ul>\n<li><p>you avoid the copy for sure.</p></li>\n<li><p>you avoid using the heap.</p></li>\n<li><p>you avoid leaving the calling code with the responsibility of freeing the dynamically-allocated object (although shared_ptr or unique_ptr would do that too).</p></li>\n</ul>\n<p>Another alternative is to make the function a member of <code>Object</code>, but that might not be appropriate, depending on what <code>f()</code>'s contract is.</p>\n", "LastActivityDate": "2011-01-26T20:38:26.267", "CommentCount": "1", "CreationDate": "2011-01-26T20:38:26.267", "ParentId": "4809120", "Score": "1", "OwnerUserId": "491645"}, "4809146": {"Id": "4809146", "PostTypeId": "2", "Body": "<p>For that specific case, you can take advantage of the fact that compilers nowadays are smart enough to optimize for it. The optimization is called <strong>named <a href=\"http://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"noreferrer\">return value optimization</a> (NRVO)</strong>, so it's okay to return \"big\" objects like that. The compiler can see such opportunities (especially in something as simple as your code snippet) and generate the binary so that no copies are made.</p>\n<p>You can also return unnamed temporaries:</p>\n<pre><code>Object f()\n{\n    return Object();\n}\n</code></pre>\n<p>This invokes <strong>(unnamed) return value optimization (RVO)</strong> on just about all modern C++ compilers. In fact, Visual C++ implements this particular optimization even if all optimizations are turned off.</p>\n<p>These kinds of optimizations are specifically allowed by the C++ standard:</p>\n<blockquote>\n<p id=\"so_4809120_4809146_0\"><strong>ISO 14882:2003 C++ Standard, \u00a712.8 para. 15:\n  Copying Class Objects</strong></p>\n<p id=\"so_4809120_4809146_1\">When certain criteria are met, an\n  implementation is allowed to omit the\n  copy construction of a class object,\n  even if the copy constructor and/or\n  destructor for the object have side\n  effects. In such cases, the\n  implementation treats the source and\n  target of the omitted copy operation\n  as simply two different ways of\n  referring to the same object, and the\n  destruction of that object occurs\n  later of the times when the two\n  objects would have been destroyed\n  without the optimization. This elison\n  of copy operations is permitted in the\n  following circumstances (which may be\n  combined to eliminate multiple\n  copies):</p>\n<ul>\n<li>in a <code>return</code> statement in a function with a class terturn type,\n  when the expression is the name of a\n  non-volatile automatic object with the\n  same cv-unqualified type as the\n  function return type, the copy\n  operation can be omitted by\n  constructing the automatic object\n  directly into the function's return\n  value</li>\n<li>when a temporary class object that has not been bound to a reference\n  would be copied to a class object with\n  the same cv-unqualitied type, the copy\n  operation can be omitted by\n  constructing the temporary object\n  directly into the target of the\n  omitted copy.</li>\n</ul>\n</blockquote>\n<p>Generally, the compiler will always try to implement NRVO and/or RVO, although it may fail to do so in certain circumstances, like multiple return paths. Nevertheless, it's a very useful optimization, and you shouldn't be afraid to use it.</p>\n<p>If in doubt, you can always test your compiler by inserting \"debugging statements\" and see for yourself:</p>\n<pre><code>class Foo\n{\npublic:\n    Foo()                      { ::printf(\"default constructor\\n\"); }\n    // \"Rule of 3\" for copyable objects\n    ~Foo()                     { ::printf(\"destructor\\n\");          }\n    Foo(const Foo&amp;)            { ::printf(\"copy constructor\\n\");    }\n    Foo&amp; operator=(const Foo&amp;) { ::printf(\"copy assignment\\n\");     } \n};\n\nFoo getFoo()\n{\n    return Foo();\n}\n\nint main()\n{\n    Foo f = getFoo();\n}\n</code></pre>\n<p>If the returned object isn't meant to be copyable, or (N)RVO fails (which is probably not likely to happen), then you can try returning a proxy object:</p>\n<pre><code>struct ObjectProxy\n{\nprivate:\n    ObjectProxy() {}\n    friend class Object;    // Allow Object class to grab the resource.\n    friend ObjectProxy f(); // Only f() can create instances of this class.\n};\n\nclass Object\n{\npublic:\n    Object() { ::printf(\"default constructor\\n\"); }\n    ~Object() { ::printf(\"destructor\\n\"); }\n    // copy functions undefined to prevent copies\n    Object(const Object&amp;);\n    Object&amp; operator=(const Object&amp;);\n    // but we can accept a proxy\n    Object(const ObjectProxy&amp;)\n    {\n        ::printf(\"proxy constructor\\n\");\n        // Grab resource from the ObjectProxy.\n    }\n};\n\nObjectProxy f()\n{\n    // Acquire large/complex resource like files\n    // and store a reference to it in ObjectProxy.\n    return ObjectProxy();\n}\n\nint main()\n{\n     Object o = f();\n}\n</code></pre>\n<p>Of course, this isn't exactly obvious so proper documentation would be needed (at least a comment about it).</p>\n<p>You can also return a smart pointer of some kind (like <code>std::auto_ptr</code> or <code>boost::shared_ptr</code> or something similar) to an object allocated on the free-store. This is needed if you need to return instances of derived types:</p>\n<pre><code>class Base {};\nclass Derived : public Base {};\n\n// or boost::shared_ptr or any other smart pointer\nstd::auto_ptr&lt;Base&gt; f()\n{\n    return std::auto_ptr&lt;Base&gt;(new Derived);\n}\n</code></pre>\n", "LastEditorUserId": "308661", "LastActivityDate": "2011-01-26T20:29:31.127", "Score": "18", "CreationDate": "2011-01-26T19:38:13.257", "ParentId": "4809120", "CommentCount": "4", "OwnerUserId": "308661", "LastEditDate": "2011-01-26T20:29:31.127"}, "4809171": {"Id": "4809171", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_4809120_4809171_0\">Do i understand correctly that first\n  Object will be created on a stack (in\n  the function) and then will be copied\n  to object variable?</p>\n</blockquote>\n<p>Yes obj is created on the stack but when you return a process called return value optimisation or RVO can prevent the unnecessary copy.</p>\n<blockquote>\n<p id=\"so_4809120_4809171_1\">If so, is it reasonably to create an\n  object in the function on a heap and\n  to return a pointer to it instead of a\n  copy ?</p>\n</blockquote>\n<p>Yes it is reasonable to create an object on the heap and return a pointer to it as long as you clearly document the client is responsible for cleaning up the memory.</p>\n<p>However, it's better than reasonable to return a smart pointer such as <code>shared_ptr&lt;Object&gt;</code> which alleviates the client from having to remember to explicitly free the memory.</p>\n", "LastEditorUserId": "57465", "LastActivityDate": "2011-01-26T20:49:44.010", "Score": "2", "CreationDate": "2011-01-26T19:40:29.037", "ParentId": "4809120", "CommentCount": "2", "OwnerUserId": "57465", "LastEditDate": "2011-01-26T20:49:44.010"}, "4809120": {"ViewCount": "5233", "Body": "<p>Imagine such situation that I have a function like this:</p>\n<pre><code>Object f()\n{\n    Object obj;\n    return obj;\n}\n</code></pre>\n<p>Where <code>sizeof(Object)</code> is a big value.</p>\n<p>And then I make a call of this function:</p>\n<pre><code>Object object = f();  \n</code></pre>\n<p>Do i understand correctly that first Object will be created on a stack (in the function) and then will be copied to object variable?</p>\n<p>If so, is it reasonably to create an object in the function on a heap and to return a pointer to it instead of a copy ?</p>\n<p>But i mean that the object must be created in the <code>f()</code> function - not passed by a pointer or a reference to this function and initialized.</p>\n<p><strong>EDIT</strong></p>\n<p>I don't mean that f is a very simple function. It can have a really complex routine of object initialization depending on some context. Will the compiler still optimize it as well?</p>\n", "AcceptedAnswerId": "4809146", "Title": "Creating and returning a big object from a function", "CreationDate": "2011-01-26T19:36:17.060", "Id": "4809120", "CommentCount": "5", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2011-01-26T20:59:28.423", "LastEditorUserId": "444088", "LastActivityDate": "2011-01-26T20:59:28.423", "ClosedDate": "2016-12-10T17:25:30.180", "Score": "10", "OwnerUserId": "444088", "Tags": "<c++><c><memory>", "AnswerCount": "7"}});