post_cb({"11359733": {"ParentId": "11359562", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>This is a name hiding issue. The standard says (c++03, 3.3.7/1)</p>\n<blockquote>\n<p id=\"so_11359562_11359733_0\">A name can be hidden by an explicit declaration of that same name in a nested declarative region or derived\n  class (10.2).</p>\n</blockquote>\n<p>The \"name\" on your case would be <code>operator&gt;&gt;</code> and namespaces constitute nested declarative regions.</p>\n<p>The easiest way to fix that would be to use a <code>using</code> declaration where you declare the namespace-local <code>operator&lt;&lt;</code>:</p>\n<pre><code>namespace your_namespece {\n    std::istream&amp; operator&gt;&gt;(std::istream&amp; is, SomeClass&amp; obj) { return is; }; \n    using ::operator&gt;&gt;;\n}\n</code></pre>\n<p>Note that this feature doesn't interfere with Koenig lookup (at least in your case, in principle, it can), so IO operators from <code>std::</code> will still be found.</p>\n<p>PS: Another possibility for working aroud this issue would be defining the operator for <code>SomeClass</code> as an <a href=\"http://ideone.com/EplNj\">inline <code>friend</code></a>. Such functions are declared at the namespace level (outside of \"their\" class), but are not visible from there. They can only be found by Koenig lookup.</p>\n", "OwnerUserId": "51831", "LastEditorUserId": "51831", "LastEditDate": "2012-07-06T10:23:07.347", "Id": "11359733", "Score": "9", "CreationDate": "2012-07-06T09:41:39.427", "LastActivityDate": "2012-07-06T10:23:07.347"}, "11359562": {"CommentCount": "4", "AcceptedAnswerId": "11359733", "PostTypeId": "1", "LastEditorUserId": "1264252", "CreationDate": "2012-07-06T09:31:49.490", "LastActivityDate": "2012-07-06T10:38:14.073", "LastEditDate": "2012-07-06T09:49:15.970", "ViewCount": "2920", "FavoriteCount": "5", "Title": "How does the operator overload resolution work within namespaces?", "Id": "11359562", "Score": "10", "Body": "<p>I found a strange behaviour of C++ resolution of operator-overloading, I can't explain myself. A pointer to some resource describing it would be just as nice as an answer.</p>\n<p>I have 2 translation units. In one (called util.cpp/h) I declare and define two operators (I omit the real implementations for readabilty, the problam occurs anyway):</p>\n<pre><code>// util.h\n#ifndef GUARD_UTIL\n#define GUARD_UTIL\n\n#include &lt;iostream&gt;\n\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; is, const char* str);\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; is, char* str);\n#endif\n</code></pre>\n<p>And:</p>\n<pre><code>//util.cpp\n#include \"util.h\"\n#include &lt;iostream&gt;\n\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; is, const char* str) {\n  return is;  \n}\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; is, char* str) {\n  return is;  \n}\n</code></pre>\n<p>These operators are, if course in global namespace, since they operate on std types and built-in types and should be usable from everywhere. They just work fine from global namespace (e.g. from main()) or with explicitly telling the compiler that they are in global namespace (see code example).</p>\n<p>In another translation unit (called test.cpp/h) I use these operators within a namespace. This works until I put a similar operator into this namespace. As soon as this operator is added, the compiler (e.g. gcc or clang) is not able to find a viable operator&gt;&gt; anymore.</p>\n<pre><code>// test.h\n#ifndef GUARD_TEST\n#define GUARD_TEST\n\n#include &lt;iostream&gt;\n\nnamespace Namespace {\n  class SomeClass {   \n    public:\n      void test(std::istream&amp; is);\n  };\n\n  // without the following line everything compiles just fine\n  std::istream&amp; operator&gt;&gt;(std::istream&amp; is, SomeClass&amp; obj) { return is; }; \n}\n\n#endif\n</code></pre>\n<p>And:</p>\n<pre><code>//test.cpp\n#include \"test.h\"\n#include \"util.h\"\n#include &lt;iostream&gt;\n\nvoid Namespace::SomeClass::test(std::istream&amp; is) {\n  ::operator&gt;&gt;(is, \"c\"); //works\n  is &gt;&gt; \"c\" //fails\n}\n</code></pre>\n<p>Why does the compiler find the correct operator when there is no operator&gt;&gt; in Namespace but fails to find when there is one? Why does the operator affect the ability of the compiler to find the correct one even if it has a different signature?</p>\n<p>One attempt to fix this was to put</p>\n<p>std::istream&amp; operator&gt;&gt;(std::istream&amp; is, const char* str) { ::operator&gt;&gt;(is, str); }</p>\n<p>into Namespace, but than the linker complains about previous definitions. So additional: Why can the linker find something the compiler doesn't find?</p>\n", "Tags": "<c++><operators><overload-resolution>", "OwnerUserId": "1264252", "AnswerCount": "3"}, "11359714": {"ParentId": "11359562", "CommentCount": "0", "Body": "<p>:: is global scope, so, compiler must scan global namespace and find this operator.\nis &gt;&gt; \"C\", trying to find operator &gt;&gt; in Namespace, so, compiler find it and stop searching, then compiler try to choose operator with needed signature, if there is no such operator - compiler fails.\nI think you should read Herb Sutter Exceptional C++.</p>\n", "OwnerUserId": "1498580", "PostTypeId": "2", "Id": "11359714", "Score": "0", "CreationDate": "2012-07-06T09:40:36.963", "LastActivityDate": "2012-07-06T09:40:36.963"}, "11360600": {"ParentId": "11359562", "CommentCount": "3", "Body": "<p>There are several issues here; for starters, you're redefining a\nfunction in global namespace that already exists in <code>std::</code>.  The\nproblem you describe, however, is due to the way name lookup works.\nBasically, in the case of operator overloading, the compiler does two\nname lookups.  The first (used for all symbols, not just operators)\nstarts at the scope where the symbol appears, and works outwards: first \nthe local blocks, then the class, and its base classes (if any), and\nfinally the namespaces, working out to the global namespace.  An\nimportant characteristic of this lookup is that it stops in whatever\nscope it finds the name: if it finds a name in local scope, it doesn't\nlook in any classes; if it finds one in a class, it doesn't look in the\nbase classes or namespaces, and if it finds one in a namespace, it\ndoesn't look in any enclosing namespaces.  As far as this lookup is\nconcerned, all overloads must be in the same scope.  The second lookup\nonly affects functions and operator overloads, and occurs in the context\nof classes or objects used as arguments; thus, if one of the operands is\na class in the standard library (or anything derived from a class in the\nstandard library), the compiler will look for functions in <code>std::</code>, even\nthough the context where the symbol is used doesn't include <code>std::</code>.\nThe problem you're having is that built-in types, like <code>char*</code>, don't\nimply <em>any</em> namespace (not even global): given your overloads, the first\nlookup will stop at the first <code>operator&gt;&gt;</code> it sees, and the second will\n<em>only</em> look in <code>std::</code>.  Your function is in neither.  If you want an\noverloaded operator to be found, you <em>must</em> define it in the scope of\none of its operands.</p>\n<p>Concretely, here: you can't overload <code>std::istream&amp;\noperator&gt;&gt;( std::istream&amp;, char* )</code>, because it is already overloaded in\nthe standard library.  <code>std::istream&amp; operator&gt;&gt;( std::istream&amp;, char\nconst* )</code> is possible, but I'm not sure what it's supposed to do, since\nit can't write to the second operand.  More generally, you should only\noverload this operator for types that you have defined, and you should\nput your overload in the same namespace as the type itself, so that it\nwill be found by the second lookup above (called Argument Dependent\nLookup, or ADL\u2014or earlier, Koenig lookup, after the person who\ninvented it).</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "11360600", "Score": "2", "CreationDate": "2012-07-06T10:38:14.073", "LastActivityDate": "2012-07-06T10:38:14.073"}, "bq_ids": {"n4140": {"so_11359562_11359733_0": {"section_id": 7078, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_11359562_11359733_0": {"section_id": 6822, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_11359562_11359733_0": {"section_id": 8579, "quality": 0.9230769230769231, "length": 12}}}});