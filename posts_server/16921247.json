post_cb({"bq_ids": {"n4140": {"so_16921247_16922211_1": {"length": 9, "quality": 0.75, "section_id": 5961}}, "n3337": {"so_16921247_16922211_1": {"length": 9, "quality": 0.75, "section_id": 5730}}}, "16922118": {"PostTypeId": "2", "Body": "<p><strong>Disclaimer:</strong> my answer is somewhat simplified compared to the reality (I put some details aside) but the big picture is here. Also, the Standard does not fully specify how lambdas or <code>std::function</code> must be implemented internally (the implementation has some freedom) so, like any discussion on implementation details, your compiler may or may not do it exactly this way.</p>\n<p>But again, this is a subject quite similar to VTables: the Standard doesn't mandate much but any sensible compiler is still quite likely to do it this way, so I believe it is worth digging into it a little. :)</p>\n<hr>\n<h1>Lambdas</h1>\n<p>The most straightforward way to implement a lambda is kind of an anonymous <code>struct</code>:</p>\n<pre><code>auto lambda = [](Args...) -&gt; Return { /*...*/ };\n\n// roughly equivalent to:\nstruct {\n    Return operator ()(Args...) { /*...*/ }\n}\nlambda; // instance of the anonymous struct\n</code></pre>\n<p>Just like any other class, when you pass its instances around you never have to copy the code, just the actual data (here, none at all).</p>\n<hr>\n<p>Objects captured by value are copied into the <code>struct</code>:</p>\n<pre><code>Value v;\nauto lambda = [=](Args...) -&gt; Return { /*... use v, captured by value...*/ };\n\n// roughly equivalent to:\nstruct Temporary { // note: we can't make it an anonymous struct any more since we need\n                   // a constructor, but that's just a syntax quirk\n\n    const Value v; // note: capture by value is const by default unless the lambda is mutable\n    Temporary(Value v_) : v(v_) {}\n    Return operator ()(Args...) { /*... use v, captured by value...*/ }\n}\nlambda(v); // instance of the struct\n</code></pre>\n<p>Again, passing it around only means that you pass the data (<code>v</code>) not the code itself.</p>\n<hr>\n<p>Likewise, objects captured by reference are referenced into the <code>struct</code>:</p>\n<pre><code>Value v;\nauto lambda = [&amp;](Args...) -&gt; Return { /*... use v, captured by reference...*/ };\n\n// roughly equivalent to:\nstruct Temporary {\n    Value&amp; v; // note: capture by reference is non-const\n    Temporary(Value&amp; v_) : v(v_) {}\n    Return operator ()(Args...) { /*... use v, captured by reference...*/ }\n}\nlambda(v); // instance of the struct\n</code></pre>\n<p>That's pretty much all when it comes to lambdas themselves (except the few implementation details I ommitted, but which are not relevant to understanding how it works).</p>\n<hr>\n<h1><code>std::function</code></h1>\n<p><code>std::function</code> is a generic wrapper around any kind of functor (lambdas, standalone/static/member functions, functor classes like the ones I showed, ...).</p>\n<p>The internals of <code>std::function</code> are pretty complicated because they must support all those cases. Depending on the exact type of functor this requires at least the following data (give or take implementation details):</p>\n<ul>\n<li>A pointer to a standalone/static function.</li>\n</ul>\n<p>Or,</p>\n<ul>\n<li>A pointer to a copy<sup>[see note below]</sup> of the functor (dynamically allocated to allow any type of functor, as you rightly noted it).</li>\n<li>A pointer to the member function to be called.</li>\n<li>A pointer to an allocator that is able to both copy the functor and itself (since any type of functor can be used, the pointer-to-functor should be <code>void*</code> and thus there has to be such a mechanism -- probably using polymorphism aka. base class + virtual methods, the derived class being generated locally in the <code>template&lt;class Functor&gt; function(Functor)</code> constructors).</li>\n</ul>\n<p>Since it doesn't know beforehand which kind of functor it will have to store (and this is made obvious by the fact that <code>std::function</code> can be reassigned) then it has to cope with all possible cases and make the decision at runtime.</p>\n<p><strong>Note:</strong> I don't know <em>where</em> the Standard mandates it but this is definitely a new copy, the underlying functor is not shared:</p>\n<pre><code>int v = 0;\nstd::function&lt;void()&gt; f = [=]() mutable { std::cout &lt;&lt; v++ &lt;&lt; std::endl; };\nstd::function&lt;void()&gt; g = f;\n\nf(); // 0\nf(); // 1\ng(); // 0\ng(); // 1\n</code></pre>\n<p>So, when you pass a <code>std::function</code> around it involves at least those four pointers (and indeed on GCC 4.7 64 bits <code>sizeof(std::function&lt;void()&gt;</code> is 32 which is four 64 bits pointers) and optionally a dynamically allocated copy of the functor (which, as I already said, <strong>only contains the captured objects, you don't copy the code</strong>).</p>\n<hr>\n<h1>Answer to the question</h1>\n<blockquote>\n<p id=\"so_16921247_16922118_0\"><strong>what is the cost of passing a lambda to a function like this?</strong><sup>[context of the question: <strong>by value</strong>]</sup></p>\n</blockquote>\n<p>Well, as you can see it depends mainly on your functor (either a hand-made <code>struct</code> functor or a lambda) and the variables it contains. The <em>overhead</em> compared to directly passing a <code>struct</code> functor by value is quite negligible, but it is of course much higher than passing a <code>struct</code> functor by reference.</p>\n<blockquote>\n<p id=\"so_16921247_16922118_1\"><strong>Should I have to mark each function object passed with <code>const&amp;</code> so that a copy is not made?</strong></p>\n</blockquote>\n<p>I'm afraid this is very hard to answer in a generic way. Sometimes you'll want to pass by <code>const</code> reference, sometimes by value, sometimes by <em>rvalue</em> reference so that you can move it. It really depends on the semantics of your code.</p>\n<p>The rules concerning which one you should choose are a totally different topic IMO, just remember that they are the same as for any other object.</p>\n<p>Anyway, you now have all the keys to make an informed decision (again, <em>depending on your code and its semantics</em>).</p>\n</hr></hr></hr></hr></hr>", "LastActivityDate": "2013-06-04T18:45:39.713", "LastEditorUserId": "2070725", "Id": "16922118", "CommentCount": "0", "CreationDate": "2013-06-04T15:45:36.367", "ParentId": "16921247", "Score": "30", "OwnerUserId": "2070725", "LastEditDate": "2013-06-04T18:45:39.713"}, "16921247": {"ViewCount": "2062", "Body": "<p>Passing a lambda is really easy in c++11:</p>\n<pre><code>func( []( int arg ) {\n  // code\n} ) ;\n</code></pre>\n<p>But I'm wondering, <em>what is the cost</em> of passing a lambda to a function like this?  What if func passes the lambda to other functions?</p>\n<pre><code>void func( function&lt; void (int arg) &gt; f ) {\n  doSomethingElse( f ) ;\n}\n</code></pre>\n<p>Is the passing of the lambda expensive?  Since a <code>function</code> object <em>can</em> be assigned 0, </p>\n<pre><code>function&lt; void (int arg) &gt; f = 0 ; // 0 means \"not init\" \n</code></pre>\n<p>it leads me to think that function objects kind of act like pointers.  But without use of <code>new</code>, then it means they might be like value-typed <code>struct</code> or classes, which defaults to stack allocation and member-wise copy.</p>\n<p>How is a C++11 \"code body\" and group of captured variables passed when you pass a function object \"by value\"?  Is there a lot of excess copy of the code body?  Should I have to mark each <code>function</code> object passed with <code>const&amp;</code> so that a copy is not made:</p>\n<pre><code>void func( const function&lt; void (int arg) &gt;&amp; f ) {\n}\n</code></pre>\n<p>Or do function objects somehow pass differently than regular C++ structs?</p>\n", "AcceptedAnswerId": "16922118", "Title": "How are C++11 lambdas represented and passed?", "CreationDate": "2013-06-04T15:04:15.813", "Id": "16921247", "CommentCount": "1", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2013-06-05T02:11:00.753", "LastEditorUserId": "1774667", "LastActivityDate": "2013-06-05T02:11:00.753", "Score": "30", "OwnerUserId": "111307", "Tags": "<c++><c++11><lambda><parameter-passing><std-function>", "AnswerCount": "3"}, "16922075": {"PostTypeId": "2", "Body": "<p>If the lambda can be made as a simple function (i.e. it does not capture anything), then it is made exactly the same way. Especially as standard requires it to be compatible with the old-style pointer-to-function with the same signature. [EDIT: it's not accurate, see discussion in comments]</p>\n<p>For the rest it is up to the implementation, but I'd not worry ahead. The most straightforward implementation does nothing but carry the information around. Exactly as much as you asked for in the capture.   So the effect would be the same as if you did it manually creating a class.  Or use some std::bind variant.</p>\n", "LastActivityDate": "2013-06-04T17:06:05.117", "LastEditorUserId": "2422194", "Id": "16922075", "CommentCount": "8", "CreationDate": "2013-06-04T15:43:53.673", "ParentId": "16921247", "Score": "1", "OwnerUserId": "2422194", "LastEditDate": "2013-06-04T17:06:05.117"}, "16922211": {"PostTypeId": "2", "Body": "<p>See also <a href=\"https://stackoverflow.com/questions/12202656/c11-lambda-implementation-and-memory-model\">C++11 lambda implementation and memory model</a></p>\n<p>A lambda-expression is just that: an expression. Once compiled, it results in a closure object at runtime.</p>\n<blockquote>\n<p id=\"so_16921247_16922211_0\"><strong><em>5.1.2 Lambda expressions [expr.prim.lambda]</em></strong></p>\n<p id=\"so_16921247_16922211_1\">The evaluation of a lambda-expression results in a prvalue temporary\n  (12.2). This temporary is called the closure object.</p>\n</blockquote>\n<p>The object itself is implementation-defined and may vary from compiler to compiler. </p>\n<p>Here is the original implementation of lambdas in clang\n<a href=\"https://github.com/faisalv/clang-glambda\" rel=\"nofollow noreferrer\">https://github.com/faisalv/clang-glambda</a></p>\n", "LastActivityDate": "2013-06-04T15:50:22.073", "LastEditorUserId": "-1", "Id": "16922211", "CommentCount": "0", "CreationDate": "2013-06-04T15:50:22.073", "ParentId": "16921247", "Score": "3", "OwnerUserId": "2406758", "LastEditDate": "2017-05-23T12:17:39.870"}});