post_cb({"17529349": {"ParentId": "17529243", "CommentCount": "0", "CreationDate": "2013-07-08T14:34:33.263", "OwnerUserId": "241536", "PostTypeId": "2", "Id": "17529349", "Score": "5", "Body": "<p>The Standard doesn't require it to reserve <em>exactly</em> what you specify, only at least what you specify:</p>\n<h2>21.4.4 basic_string capacity [string.capacity]</h2>\n<blockquote>\n<p id=\"so_17529243_17529349_0\">12/Effects: After reserve(), capacity() is greater or equal to the\n  argument of reserve. [ Note: Calling reserve() with a res_arg argument\n  less than capacity() is in effect a non-binding shrink request. A call\n  with res_arg &lt;= size() is in effect a non-binding shrink-to-fit\n  request. \u2014end note ]</p>\n</blockquote>\n", "LastActivityDate": "2013-07-08T14:34:33.263"}, "17529403": {"ParentId": "17529243", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-07-08T14:37:10.197", "Score": "7", "LastEditorUserId": "1335865", "LastEditDate": "2013-07-08T15:16:31.363", "Id": "17529403", "OwnerUserId": "1335865", "Body": "<h2>The standard allows it</h2>\n<p>The C++ standard allows the implementation to reserve more memory than requested. In the standard (N3690, \u00a721.4.4) it states</p>\n<blockquote>\n<pre><code>void reserve(size_type res_arg=0);\n</code></pre>\n<p id=\"so_17529243_17529403_0\">The member function <code>reserve()</code> is a directive that informs a <code>basic_string</code> object of a planned change in size, so that it can manage the storage allocation accordingly.</p>\n<p id=\"so_17529243_17529403_1\"><em>Effects:</em> After <code>reserve()</code>, <code>capacity()</code> is greater or equal to the argument of <code>reserve</code>. [ <em>Note:</em> Calling <code>reserve()</code> with a <code>res_arg</code> argument less than <code>capacity()</code> is in effect a non-binding shrink request. A call with <code>res_arg &lt;= size()</code> is in effect a non-binding shrink-to-fit request. <em>\u2014 end note</em> ]</p>\n</blockquote>\n<h2>The reason: Alignment on 16-byte boundaries</h2>\n<p>It seems that the reserved size is always a number that is a multiple of 16 minus one character for null termination. Memory reserved on the heap is always automatically 16-byte aligned on a x86 machine. Hence there is no cost in rounding up to the next biggest multiple of 16 for memory allocation. </p>\n<p>The <a href=\"http://msdn.microsoft.com/library/vstudio/6ewkz86d\" rel=\"nofollow\">Microsoft documentation for <code>malloc()</code></a> states that:</p>\n<blockquote>\n<p id=\"so_17529243_17529403_2\">The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object.</p>\n</blockquote>\n<p><a href=\"http://en.wikipedia.org/wiki/SIMD\" rel=\"nofollow\">Objects of SIMD type</a> must be <a href=\"http://en.wikipedia.org/wiki/Data_structure_alignment#x86\" rel=\"nofollow\">16-byte aligned</a> to work best. These are packed types of 4 floats or 2 doubles (or other) that fit into the 128-bit registers of an x86 machine. If the data is not properly aligned, then loading and storing to these memory locations can lead a great loss of performance or even crashes. That's why <code>malloc()</code> does this. Hence the conclusion for the 16-byte alignment. Most memory allocations (including <code>operator new</code>) ultimately call <code>malloc()</code>. Not allocating a multiple of 16 bytes would just be a waste of memory that would otherwise be unused anyways. </p>\n", "LastActivityDate": "2013-07-08T15:16:31.363"}, "17529423": {"ParentId": "17529243", "CommentCount": "0", "CreationDate": "2013-07-08T14:38:40.230", "OwnerUserId": "2554436", "PostTypeId": "2", "Id": "17529423", "Score": "0", "Body": "<p>I would have to look at the source to be 100% certain but it looks like the underlying code is reserving the amount you requested and padding that to the next 16 byte boundary (leaving 1 for null termination)\nThis is just a theory based on the behavior.</p>\n", "LastActivityDate": "2013-07-08T14:38:40.230"}, "bq_ids": {"n4140": {"so_17529243_17529403_0": {"section_id": 1610, "quality": 0.9375, "length": 15}, "so_17529243_17529403_1": {"section_id": 1611, "quality": 0.8620689655172413, "length": 25}, "so_17529243_17529349_0": {"section_id": 1611, "quality": 0.8620689655172413, "length": 25}}, "n3337": {"so_17529243_17529403_0": {"section_id": 1606, "quality": 0.9375, "length": 15}, "so_17529243_17529403_1": {"section_id": 1607, "quality": 0.8620689655172413, "length": 25}, "so_17529243_17529349_0": {"section_id": 1607, "quality": 0.8620689655172413, "length": 25}}, "n4659": {"so_17529243_17529349_0": {"section_id": 1762, "quality": 0.8620689655172413, "length": 25}, "so_17529243_17529403_1": {"section_id": 1762, "quality": 0.8620689655172413, "length": 25}, "so_17529243_17529403_0": {"section_id": 1761, "quality": 0.9375, "length": 15}}}, "17529243": {"CommentCount": "1", "AcceptedAnswerId": "17529403", "CreationDate": "2013-07-08T14:30:08.313", "LastActivityDate": "2013-07-08T15:16:31.363", "PostTypeId": "1", "ViewCount": "519", "FavoriteCount": "2", "Title": "Why doesn't `std::string::reserve()` reserve exact amount of space I specify?", "Id": "17529243", "Score": "3", "Body": "<p><code>std::string::reserve()</code> doesn't allocate the exact amount of space I pass as argument. For example, if I try to reserve space for 100 characters, it reserves for 111 characters. If I pass 200, it reserves for 207. 655 for 650, 1007 for 1000.</p>\n<p>What is the reason behind this?</p>\n<p>Program code:</p>\n<pre><code>std::string mystr;\nstd::cout &lt;&lt; \"After creation   :\" &lt;&lt; mystr.capacity() &lt;&lt; std::endl;\nmystr.reserve(1000);\nstd::cout &lt;&lt; \"After reserve()  :\" &lt;&lt; mystr.capacity() &lt;&lt; std::endl;\nmystr = \"asd\";\nstd::cout &lt;&lt; \"After assignment :\" &lt;&lt; mystr.capacity() &lt;&lt; std::endl;\nmystr.clear();\nstd::cout &lt;&lt; \"After clear()    :\" &lt;&lt; mystr.capacity() &lt;&lt; std::endl;\n</code></pre>\n<p>Code output:</p>\n<pre><code>After creation   :15\nAfter reserve()  :1007\nAfter assignment :1007\nAfter clear()    :1007\n</code></pre>\n<p>(IDE: Visual Studio 2012)</p>\n", "Tags": "<c++><memory-management><stl><stdstring>", "OwnerUserId": "245376", "AnswerCount": "3"}});