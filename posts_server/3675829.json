post_cb({"3675874": {"Id": "3675874", "PostTypeId": "2", "Body": "<p>Consider a <code>mystream</code> which inherits from <code>std::ostream</code>. You would like that your type would support all the <code>&lt;&lt;</code> operators that are defined for <code>std::ostream</code> normally in the std namespace. So base classes are associated classes for ADL. </p>\n<p>I think this also follows from the substitution principle - and functions in a class' namespace are considered part of its interface (see Herb Sutter's \"What's in a class?\"). So an interface that works on the base class should remain working on a derived class.</p>\n<p>You can also work around this by disabling ADL:</p>\n<pre><code>(find)( deq, STest2() );\n</code></pre>\n", "LastActivityDate": "2010-09-09T10:56:33.530", "CommentCount": "1", "CreationDate": "2010-09-09T10:56:33.530", "ParentId": "3675829", "Score": "3", "OwnerUserId": "34509"}, "3675829": {"ViewCount": "1286", "Body": "<p>I've been bitten by this problem a couple of times and so have my colleagues. When compiling</p>\n<pre><code>#include &lt;deque&gt;\n#include &lt;boost/algorithm/string/find.hpp&gt;\n#include &lt;boost/operators.hpp&gt;\n\ntemplate&lt; class Rng, class T &gt;    \ntypename boost::range_iterator&lt;Rng&gt;::type find( Rng&amp; rng, T const&amp; t ) {\n      return std::find( boost::begin(rng), boost::end(rng), t );\n}\n\nstruct STest {\n      bool operator==(STest const&amp; test) const { return true; }\n};\n\nstruct STest2 : boost::equality_comparable&lt;STest2&gt;   {\n      bool operator==(STest2 const&amp; test) const { return true; }\n};\n\nvoid main() {\n      std::deque&lt;STest&gt; deq;\n      find( deq, STest() ); // works\n      find( deq, STest2() ); // C2668: 'find' : ambiguous call to overloaded function\n}\n</code></pre>\n<p>...the VS9 compiler fails when compiling the second find. This is due to the fact that <code>STest2</code> inherits from a type that is defined in boost namespace which triggers the compiler to try ADL which finds <code>boost::algorithm::find(RangeT&amp; Input, const FinderT&amp; Finder)</code>.</p>\n<p>An obvious solution is to prefix the call to <code>find(\u2026)</code> with \"<code>::</code>\" but why is this necessary? There is a perfectly valid match in the global namespace, so why invoke Argument-Dependent Lookup? Can anybody explain the rationale here?</p>\n", "AcceptedAnswerId": "3675881", "Title": "Ambiguous call to templated function due to ADL", "CreationDate": "2010-09-09T10:47:09.503", "Id": "3675829", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-08-06T19:23:57.410", "LastEditorUserId": "2645707", "LastActivityDate": "2013-08-06T19:23:57.410", "Score": "7", "OwnerUserId": "214777", "Tags": "<c++><visual-c++><templates><argument-dependent-lookup>", "AnswerCount": "4"}, "3675881": {"Id": "3675881", "PostTypeId": "2", "Body": "<p>ADL isn't a fallback mechanism to use when \"normal\" overload resolution fails, functions found by ADL are just as viable as functions found by normal lookup.</p>\n<p>If ADL was a fallback solution then you might easily fall into the trap were a function was used even when there was another function that was a better match but only visible via ADL. This would seem especially strange in the case of (for example) operator overloads. You wouldn't want two objects to be compared via an <code>operator==</code> for types that they could be implicitly converted to when there exists a perfectly good <code>operator==</code> in the appropriate namespace.</p>\n", "LastEditorUserId": "19563", "LastActivityDate": "2010-09-09T12:23:57.097", "Score": "7", "CreationDate": "2010-09-09T10:58:38.113", "ParentId": "3675829", "CommentCount": "1", "OwnerUserId": "19563", "LastEditDate": "2010-09-09T12:23:57.097"}, "bq_ids": {"n4140": {"so_3675829_3675851_3": {"length": 18, "quality": 0.5142857142857142, "section_id": 7105}, "so_3675829_3675851_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 7104}, "so_3675829_3675851_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 7104}}, "n3337": {"so_3675829_3675851_3": {"length": 18, "quality": 0.5142857142857142, "section_id": 6849}, "so_3675829_3675851_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 6848}, "so_3675829_3675851_2": {"length": 24, "quality": 1.0, "section_id": 6848}}, "n4659": {"so_3675829_3675851_3": {"length": 18, "quality": 0.5142857142857142, "section_id": 8606}, "so_3675829_3675851_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 8605}, "so_3675829_3675851_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 8605}}}, "3675851": {"Id": "3675851", "PostTypeId": "2", "Body": "<p>I'll add the obvious answer myself because I just did some research on this problem: </p>\n<p>C++03 3.4.2</p>\n<blockquote>\n<p id=\"so_3675829_3675851_0\">\u00a72 For each argument type T in the function call, there is a set of zero or more associated namespaces [...] The sets of namespaces and classes are determined in the following way: </p>\n<p id=\"so_3675829_3675851_1\">[...]</p>\n<p id=\"so_3675829_3675851_2\">\u2014 If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a\n  member, if any; <strong>and its direct and indirect base classes</strong>. Its associated namespaces are the namespaces\n  in which its associated classes are defined.</p>\n<p id=\"so_3675829_3675851_3\">\u00a7 2a <strong>If the ordinary unqualified lookup of the name finds the declaration of a class member function</strong>, the associated\n  namespaces and classes are not considered. Otherwise the set of declarations found by the lookup of\n  the function name is the union of the set of declarations found using ordinary unqualified lookup and the set\n  of declarations found in the namespaces and classes associated with the argument types. </p>\n</blockquote>\n<p>At least it's standard conformant, but I still don't understand the rationale here. </p>\n", "LastActivityDate": "2010-09-09T10:52:23.953", "CommentCount": "0", "CreationDate": "2010-09-09T10:52:23.953", "ParentId": "3675829", "Score": "3", "OwnerUserId": "214777"}, "3676336": {"Id": "3676336", "PostTypeId": "2", "Body": "<p>I think you stated the problem yourself:</p>\n<blockquote>\n<p id=\"so_3675829_3676336_0\">in the global namespace</p>\n</blockquote>\n<p>Functions in the global namespace are considered last. It's the most outer scope <em>by definition</em>. Any function with the same name (not necessarily applicable) that is found in a closer scope (from the call point of view) will be picked up first.</p>\n<pre><code>template &lt;typename Rng, typename T&gt;\ntypename Rng::iterator find( Rng&amp; rng, T const&amp; t );\n\nnamespace foo\n{\n  bool find(std::vector&lt;int&gt; const&amp; v, int);\n\n  void method()\n  {\n    std::deque&lt;std::string&gt; deque;\n    auto it = find(deque, \"bar\");\n  }\n}\n</code></pre>\n<p>Here (unless <code>vector</code> or <code>deque</code> include <code>algorithm</code>, which is allowed), the only method that will be picked up during name look-up will be:</p>\n<pre><code>bool foo::find(std::vector&lt;int&gt; const&amp;, int);\n</code></pre>\n<p>If <code>algorithm</code> is somehow included, there will also be:</p>\n<pre><code>template &lt;typename FwdIt&gt;\nFwdIt std::find(FwdIt begin, FwdIt end,\n                typename std::iterator_traits&lt;FwdIt&gt;::value_type const&amp; value);\n</code></pre>\n<p>And of course, overload resolution will fail stating that there is no match.</p>\n<p>Note that name-lookup is extremely dumb: neither arity nor argument type are considered!</p>\n<p>Therefore, there are only two kinds of free-functions that you should use in C++:</p>\n<ul>\n<li>Those which are part of the interface of a class, declared in the same namespace, picked up by ADL</li>\n<li>Those which are not, and that you should explicitly qualified to avoid issues of this type</li>\n</ul>\n<p>If you fall out of these rules, it might work, or not, depending on what's included, and that's very awkward.</p>\n", "LastActivityDate": "2010-09-09T12:03:33.450", "CommentCount": "2", "CreationDate": "2010-09-09T12:03:33.450", "ParentId": "3675829", "Score": "1", "OwnerUserId": "147192"}});