post_cb({"10271929": {"ViewCount": "2521", "Body": "<p>In the comments of <a href=\"https://stackoverflow.com/a/8568531/1025391\">this answer</a> it is said that it would be undefined behavior to split up an integer into their bytes using a union like follows. The code given at that place is similar though not identical to this, please give a note if have I changed undefined-behavior-relevant aspects of the code.</p>\n<pre><code>union addr {\n uint8_t addr8[4];\n uint32_t addr32;\n};\n</code></pre>\n<p>Up to now I thought this would be a fine approach to do things like <code>addr = {127, 0, 0, 1};</code> and get the corresponding  <code>uint32_t</code> in return. (I acknowledge that this may yield  different results depending on the endianness of my system. The question however remains.)</p>\n<p>Is this undefined behavior? If so, why? (I don't know what means <em>What's UB in C++ is to access inactive union members.</em>)</p>\n<hr>\n<p><strong>C99</strong></p>\n<ul>\n<li>C99 is apparantly pretty close to C++03 in this point.</li>\n</ul>\n<p><strong>C++03</strong></p>\n<ul>\n<li><em>In a union, at most one of the data members can be active at any time, that is, the value of at most one of the data members can be stored in a union at any time.</em> C++03, Section 9.5 (1), page 162</li>\n</ul>\n<p>However</p>\n<ul>\n<li><em>If a POD-union contains several POD-structs that share a common initial sequence [...] it is permitted to inspect the common initial sequence of any of POD-struct members</em> ibid.</li>\n<li><em>Two POD-struct [...] types are layout-compatible if they have the same number of nonstatic data members, and corresponding nonstatic data members (in order) have layout-compatible types</em> C++03, Section 9.2 (14), page 157</li>\n<li><em>If two types T1 and T2 are the same type, then T1 and T2 are layout-compatible types.</em> C++03, Section 3.9 (11), page 53</li>\n</ul>\n<p>Conclusion</p>\n<ul>\n<li>as <code>uint8_t[4]</code> and <code>uint32_t</code> are not the same type (I guess, a <a href=\"https://stackoverflow.com/a/99010/1025391\">strict aliasing thing</a>) (plus both not being POD-structs/union) the above is indeed UB?</li>\n</ul>\n<p><strong>C++11</strong></p>\n<ul>\n<li><em>Note that aggregate type does not include union type because an object with union type can only contain one member at a time.</em> C++11, Footnote 46, page 42</li>\n</ul>\n</hr>", "Title": "union for uint32_t and uint8_t[4] undefined behavior?", "CreationDate": "2012-04-22T20:40:40.860", "LastActivityDate": "2012-07-20T14:59:16.337", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:10:50.663", "Tags": "<c++><c><unions><strict-aliasing><type-punning>", "Id": "10271929", "LastEditorUserId": "-1", "Score": "4", "OwnerUserId": "1025391", "ClosedDate": "2014-07-16T05:00:48.440", "AnswerCount": "4"}, "10271969": {"Id": "10271969", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_10271929_10271969_0\">I don't know what means What's UB in C++ is to access inactive union members.</p>\n</blockquote>\n<p>Basically what it means is that the only member you can read from a union without invoking undefined behavior is the last written one. In other words, if you write to <code>addr32</code>, you can only read from <code>addr32</code>, not <code>addr8</code> and vice versa.</p>\n<p>An example is also available <a href=\"https://stackoverflow.com/a/3071899/477878\">here</a>.</p>\n<p>Edit: Since there has been much discussion if this is UB or not, consider the following (fully valid) C++11 example;</p>\n<pre><code>union olle {\n    std::string str;\n    std::wstring wstr;\n};\n</code></pre>\n<p>Here you can definitely see that activating str and reading wstr may be a problem. You could see this as an extreme example since you even have to activate the member by doing a placement new, but the spec actually covers this case with no mention that it's to be considered a special case in other ways regarding active members.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-04-23T04:55:46.763", "Score": "10", "CreationDate": "2012-04-22T20:46:28.447", "ParentId": "10271929", "CommentCount": "2", "OwnerUserId": "477878", "LastEditDate": "2017-05-23T10:29:46.273"}, "bq_ids": {"n4140": {"so_10271929_10272008_0": {"length": 54, "quality": 0.9473684210526315, "section_id": 5913}}, "n3337": {"so_10271929_10272008_0": {"length": 54, "quality": 0.9473684210526315, "section_id": 5685}}, "n4659": {"so_10271929_10272008_0": {"length": 53, "quality": 0.9298245614035088, "section_id": 7404}}}, "10272008": {"Id": "10272008", "PostTypeId": "2", "Body": "<p>[edit: read my edited section below, as I'm now unsure of whether this is undefined behavior or not; I'll leave the majority of my answer the same, however, until I can confirm further] Yes, this is undefined behavior. The C++ Standard, section 9.5.1, states:</p>\n<blockquote>\n<p id=\"so_10271929_10272008_0\">In a union, at most one of the non-static data members can be active at any time, that is, the value of at\n  most one of the non-static data members can be stored in a union at any time. [ Note: One special guarantee\n  is made in order to simplify the use of unions: If a standard-layout union contains several standard-layout\n  structs that share a common initial sequence (9.2), and if an object of this standard-layout union type\n  contains one of the standard-layout structs, it is permitted to inspect the common initial sequence of any of\n  standard-layout struct members; see 9.2. \u2014 end note ]</p>\n</blockquote>\n<p>This means that only the most recently written to member can validly be read from as well (reading from the others is technically undefined behavior). Only <em>one</em> member of the union can be active at any time. Not two.</p>\n<p>You might ask why? Consider your example. C++ does not mandate the endianness of <code>addr32</code>. It could be big-endian, little-endian, or middle-endian. If you write to <code>addr8</code>, and then read from <code>addr32</code>, C++ cannot guarantee you'll get the right value out because of the endianness in this case. One one computer, it could be one value, and on another, it could be a different value. Hence, doing so (that is, writing to one member and reading a different one) is undefined behavior.</p>\n<p><strong>Edit:</strong> For those wondering what \"active\" means, <a href=\"http://msdn.microsoft.com/en-us/library/5dxy4b7b%28v=vs.90%29.aspx\">the MSDN documentation on Unions</a> states:</p>\n<blockquote>\n<p id=\"so_10271929_10272008_1\">The active member of a union is the one whose value was most recently set, and only that member has a valid value.</p>\n</blockquote>\n<p><strong>Edit Edit:</strong> I had always thought the behavior of doing this was undefined, but now I'm not so sure after R. Martinho Fernandes's comments and answer and after re-reading the quote from MSDN. The value is certainly unspecified/undefined, but now I'm not so sure if the behavior is (undefined value means you might get different results back; undefined behavior means your system might crash, the two being different things). I'm going to consider this further and talk with others I know to see if I can find a more explicit answer.</p>\n<p>I do think it's safe to say, however, that in general reading an inactive member in a union <em>can</em> be undefined behavior (except for the special note in the Standard, of course), but I don't know if it <em>always</em> is (i.e. there may be some exceptions beyond the special note in the section of the C++ Standard I've quoted).</p>\n", "LastEditorUserId": "1287251", "LastActivityDate": "2012-04-22T22:16:34.223", "Score": "7", "CreationDate": "2012-04-22T20:52:12.643", "ParentId": "10271929", "CommentCount": "4", "OwnerUserId": "1287251", "LastEditDate": "2012-04-22T22:16:34.223"}, "10272228": {"Id": "10272228", "PostTypeId": "2", "Body": "<p>Frankly, I can't find any mention in the standard that doing this is undefined behaviour. The standard does define the notion of \"active member\" for unions, but it doesn't seem to use that idea for anything other than explaining how to change the active member (\u00a79.5p4), and to define constant expressions (\u00a75.9p2). Specifically it doesn't seem to make explicit mention of validity of accessing either the active or the non-active members.</p>\n<p>As far as I can see, something like the following can cause a strict aliasing violation, which is undefined behaviour:</p>\n<pre><code>union example0 {\n    short some_other_view[sizeof(double)/sizeof(short)];\n    double value;\n};\n</code></pre>\n<p>This doesn't lead to strict aliasing violations because of some special rule for unions. It happens if you access the same memory location using types that can't be aliased, i.e., a \"normal\" strict aliasing violation.</p>\n<p><em>But</em>, since there's an exception for <code>char</code> when it comes to aliasing rules, the following does not lead to the same kind of violations:</p>\n<pre><code>union example1 {\n    char byte_view[sizeof(double)];\n    double value;\n};\n</code></pre>\n<p>As far as I can see, there is nothing in the standard that leaves the following code with undefined behaviour:</p>\n<pre><code>example1 e;\ne.value = 10.0;\nstd::out &lt;&lt; e.byte_view[0];\n</code></pre>\n", "LastEditorUserId": "46642", "LastActivityDate": "2012-04-22T22:00:57.637", "Score": "5", "CreationDate": "2012-04-22T21:21:46.830", "ParentId": "10271929", "CommentCount": "5", "OwnerUserId": "46642", "LastEditDate": "2012-04-22T22:00:57.637"}, "10271970": {"Id": "10271970", "PostTypeId": "2", "Body": "<p>Basically because in C++ you are allowed to access just the active member of an union.</p>\n<p>This means that if you set <code>addr8</code> then you should access just that one until you set <code>addr32</code>, so that you can access it and so on. Setting one member to access data from another one is what should cause undefined behavior.</p>\n<p>A member is considered <em>active</em> when you set it, and it remains so until another one becomes the <em>active</em> one.</p>\n", "LastActivityDate": "2012-04-22T20:46:46.987", "CommentCount": "2", "CreationDate": "2012-04-22T20:46:46.987", "ParentId": "10271929", "Score": "5", "OwnerUserId": "121747"}});