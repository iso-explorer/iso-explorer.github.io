post_cb({"38044913": {"ParentId": "38044834", "LastEditDate": "2017-05-23T12:02:23.447", "CommentCount": "0", "CreationDate": "2016-06-27T01:57:08.240", "OwnerUserId": "6410484", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "38044913", "Score": "18", "Body": "<p>You need to use <a href=\"http://en.cppreference.com/w/cpp/types/remove_reference\" rel=\"nofollow noreferrer\"><code>std::remove_reference</code></a> for get the value you're looking for.</p>\n<pre><code>std::cout &lt;&lt; std::is_const&lt;std::remove_reference&lt;decltype(ri)&gt;::type&gt;::value &lt;&lt; std::endl;\n</code></pre>\n<p>For more information, see <a href=\"https://stackoverflow.com/questions/30806863/whats-the-equivalent-of-stdis-const-for-references-to-const\">this post</a>.</p>\n", "LastActivityDate": "2016-06-27T02:04:28.003"}, "38045038": {"ParentId": "38044834", "LastEditDate": "2016-06-27T03:43:12.193", "CommentCount": "1", "CreationDate": "2016-06-27T02:18:20.157", "OwnerUserId": "6507836", "LastEditorUserId": "63550", "PostTypeId": "2", "Id": "38045038", "Score": "-5", "Body": "<p>const X&amp; x\u201d means x aliases an X object, but you can\u2019t change that X object via x.</p>\n<p>And see <em><a href=\"http://en.cppreference.com/w/cpp/types/is_const\" rel=\"nofollow\">std::is_const</a></em>.</p>\n", "LastActivityDate": "2016-06-27T03:43:12.193"}, "38060677": {"ParentId": "38044834", "LastEditDate": "2016-06-27T23:29:23.193", "CommentCount": "5", "CreationDate": "2016-06-27T18:21:42.133", "OwnerUserId": "1250772", "LastEditorUserId": "1250772", "PostTypeId": "2", "Id": "38060677", "Score": "5", "Body": "<p>This is a quirk/feature in C++. Although we don't think of references as types, they in fact \"sit\" in the type system. Although this seems awkward (given that when references are used, the reference semantics occurs automatically and the reference \"gets out of the way\"), there are some defensible reasons why references are modeled in the type system instead of as a separate attribute outside of type.</p>\n<p>Firstly, let us consider that not every attribute of a declared name must be in the type system. From the C language, we have \"storage class\", and \"linkage\". A name can be introduced as <code>extern const int ri</code>, where the <code>extern</code> indicates static storage class and the presence of linkage. The type is just <code>const int</code>.</p>\n<p>C++ obviously embraces the notion that expressions have attributes that are outside of the type system. The language now has a concept of \"value class\" which is an attempt to organize the growing number of non-type attributes that an expression can exhibit.</p>\n<p>Yet references are types. Why?</p>\n<p>It used to be explained in C++ tutorials that a declaration like <code>const int &amp;ri</code> introduced <code>ri</code> as having type <code>const int</code>, but reference semantics. That reference semantics was not a type; it was simply a kind of attribute indicating an unusual relationship between the name and the storage location. Furthermore, the fact that references are not types was used to rationalize why you cannot construct types based on references, even though the type construction syntax allows it. For instance, arrays or pointers to references not being possible: <code>const int &amp;ari[5]</code> and <code>const int &amp;*pri</code>.</p>\n<p>But in fact references <em>are</em> types and so <code>decltype(ri)</code> retrieves some reference type node which is unqualified. You must descend past this node in the type tree to get to the underlying type with <code>remove_reference</code>.</p>\n<p>When you use <code>ri</code>, the reference is transparently resolved, so that <code>ri</code> \"looks and feels like <code>i</code>\" and can be called an \"alias\" for it. In the type system, though, <code>ri</code> does in fact have a type which is \"<strong>reference to</strong> <code>const int</code>\".</p>\n<h2><strong>Why are references types?</strong></h2>\n<p>Consider that if references were <strong>not</strong> types, then these functions would be considered to have the same type:</p>\n<pre><code>void foo(int);\nvoid foo(int &amp;);\n</code></pre>\n<p>That simply cannot be for reasons which are pretty much self-evident. If they had the same type, that means either declaration would be suitable for either definition, and so every <code>(int)</code> function would have to be suspected of taking a reference.</p>\n<p>Similarly, if references weren't types, then these two class declarations would be equivalent:</p>\n<pre><code>class foo {\n  int m;\n};\n\nclass foo {\n  int &amp;m;\n};\n</code></pre>\n<p>It would be correct for one translation unit to use one declaration, and another translation unit in the same program to use the other declaration.</p>\n<p>The fact is that <strong>a reference implies a difference in implementation</strong> and it is impossible to separate that from type, because type in C++ has to do with the implementation of an entity: its \"layout\" in bits so to speak. If two functions have the same type, they can be invoked with the same binary calling conventions: the ABI is the same. If two structs or classes have the same type, their layout is the same as well as the semantics of access to all the members.  The presence of references changes these aspects of types, and so it's a straightforward design decision to incorporate them into the type system. (However, note a counterargument here: a struct/class member can be <code>static</code>, which also changes the representation; yet that isn't type!)</p>\n<p>Thus, references are in the type system as \"second class citizens\" (not unlike functions and arrays in ISO C). There are certain things we cannot \"do\" with references, such as declare pointers to references, or arrays of them. But that doesn't mean they aren't types. They just aren't types in a way that it makes sense.  </p>\n<p>Not all these second-class-restrictions are essential. Given that there are structures of references, there could be arrays of references! E.g.</p>\n<pre><code>// fantasy syntax\nint x = 0, y = 0;\nint &amp;ar[2] = { x, y };\n\n// ar[0] is now an alias for x: could be useful!\n</code></pre>\n<p>This just isn't implemented in C++, that's all. Pointers to references do not make sense at all, though, because a pointer lifted from a reference just goes to the referenced object. The likely reason why there are no arrays of references is that the C++ people consider arrays to be a kind of low-level feature inherited from C that is broken in many ways that are irreparable, and they don't want to touch arrays as the basis for anything new.  The existence of arrays of references, though, would make a clear example of how references have to be types.</p>\n<h2>Non-<code>const</code>-qualifiable types: found in ISO C90, too!</h2>\n<p>Some answers are hinting at the fact that references don't take a <code>const</code> qualifier. That is rather a red herring, because the declaration <code>const int &amp;ri = i</code> isn't even <em>attempting</em> to make a <code>const</code>-qualified reference: it's a reference to a const-qualified type (which is itself not <code>const</code>). Just like <code>const in *ri</code> declares a pointer to something <code>const</code>, but that pointer is itself not <code>const</code>.</p>\n<p>That said, it is true that references cannot carry the <code>const</code> qualifier themselves.</p>\n<p>Yet, this is not so bizarre. Even in the ISO C 90 language, not all types can be <code>const</code>. Namely, arrays cannot be.</p>\n<p>Firstly, the syntax doesn't exist for declaring a const array: <code>int a const [42]</code> is erroneous.</p>\n<p>However, what the above declaration is trying to do can be expressed via an intermediate <code>typedef</code>:</p>\n<pre><code>typedef int array_t[42];\nconst array_t a;\n</code></pre>\n<p>But this doesn't do what it looks like it does. In this declaration, it is not <code>a</code> which gets <code>const</code> qualified, but the elements! That is to say, <code>a[0]</code> is a <code>const int</code>, but <code>a</code> is just \"array of int\". Consequently, this doesn't require a diagnostic:</p>\n<pre><code>int *p = a; /* surprise! */\n</code></pre>\n<p>This does:</p>\n<pre><code>a[0] = 1;\n</code></pre>\n<p>Again, this underscores the idea that references are in some sense \"second class\" in the type system, like arrays.</p>\n<p>Note how the analogy holds even more deeply, since arrays also have an \"invisible conversion behavior\", like references.  Without the programmer having to use any explicit operator, the identifier <code>a</code> automatically turns into an <code>int *</code> pointer, as if the expression <code>&amp;a[0]</code> had been used.  This is analogous to how a reference <code>ri</code>, when we use it as a primary expression, magically denotes the object <code>i</code> to which it is bound. It's just another \"decay\" like the \"array to pointer decay\".</p>\n<p>And just like we must not become confused by the \"array to pointer\" decay into wrongly thinking that \"arrays are just pointers in C and C++\", we likewise mustn't think that references are just aliases that have no type of their own.</p>\n<p>When <code>decltype(ri)</code> suppresses the usual conversion of the reference to its referent object, this is not so different from <code>sizeof a</code> suppressing the array-to-pointer conversion, and operating on the <em>array type itself</em> to calculate its size.</p>\n", "LastActivityDate": "2016-06-27T23:29:23.193"}, "38064141": {"ParentId": "38044834", "CommentCount": "0", "Body": "<p>Why are macros not <code>const</code>? Functions? Literals? The names of types?</p>\n<p><strong><code>const</code> things are only a subset of immutable things.</strong></p>\n<p>Since reference types are just that \u2014 types \u2014 it may have made some sense to require the <code>const</code>-qualifier on them all for symmetry with other types (particularly with pointer types), but this would get very tedious very quickly.</p>\n<p>If C++ had immutable objects by default, requiring the <code>mutable</code> keyword on anything you <em>didn't</em> want to be <code>const</code>, then this would have been easy: simply don't allow programmers to add <code>mutable</code> to reference types.</p>\n<p>As it is, they are immutable without qualification.</p>\n<p>And, since they are not <code>const</code>-qualified, it would probably be <em>more</em> confusing for <code>is_const</code> on a reference type to yield true.</p>\n<p>I find this to be a reasonable compromise, especially since the immutability is anyway enforced by the mere fact that no syntax exists to mutate a reference.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "38064141", "Score": "6", "CreationDate": "2016-06-27T22:23:53.440", "LastActivityDate": "2016-06-27T22:23:53.440"}, "38044834": {"CommentCount": "7", "CreationDate": "2016-06-27T01:40:50.690", "PostTypeId": "1", "AcceptedAnswerId": "38044973", "LastEditorUserId": "635608", "LastActivityDate": "2016-06-28T15:40:42.457", "LastEditDate": "2016-06-27T11:13:07.330", "ViewCount": "4740", "FavoriteCount": "13", "Title": "Why are references not \"const\" in C++?", "Id": "38044834", "Score": "81", "Body": "<p>We know that a \"const variable\" indicates that once assigned, you cannot change the variable, like this:</p>\n<pre><code>int const i = 1;\ni = 2;\n</code></pre>\n<p>The program above will fail to compile; gcc prompts with an error:</p>\n<pre><code>assignment of read-only variable 'i'\n</code></pre>\n<p>No problem, I can understand it, but the following example is beyond my understanding:</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    boolalpha(cout);\n    int const i = 1;\n    cout &lt;&lt; is_const&lt;decltype(i)&gt;::value &lt;&lt; endl;\n    int const &amp;ri = i;\n    cout &lt;&lt; is_const&lt;decltype(ri)&gt;::value &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>It outputs</p>\n<pre><code>true\nfalse\n</code></pre>\n<p>Weird. We know that once a reference is bound to a name/variable, we cannot change this binding, we change its bound object. So I suppose the type of <code>ri</code> should be the same as <code>i</code>: when <code>i</code> is an <code>int const</code>, why is <code>ri</code> not <code>const</code>?</p>\n", "Tags": "<c++><reference><const><language-lawyer><decltype>", "OwnerUserId": "6164172", "AnswerCount": "6"}, "38044973": {"ParentId": "38044834", "LastEditDate": "2016-06-28T15:40:42.457", "CommentCount": "19", "CreationDate": "2016-06-27T02:07:50.217", "OwnerUserId": "3807729", "LastEditorUserId": "3807729", "PostTypeId": "2", "Id": "38044973", "Score": "48", "Body": "<p>This may seem counter-intuitive but I think the way to understand this is to realize that, in certain respects, <em>references</em> are treated <em>syntactically</em> like <em>pointers</em>.</p>\n<p>This seems logical for a <em>pointer</em>:</p>\n<pre><code>int main()\n{\n    boolalpha(cout);\n\n    int const i = 1;\n    cout &lt;&lt; is_const&lt;decltype(i)&gt;::value &lt;&lt; endl;\n\n    int const* ri = &amp;i;\n    cout &lt;&lt; is_const&lt;decltype(ri)&gt;::value &lt;&lt; endl;\n}\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code>true\nfalse\n</code></pre>\n<p>This is logical because we know it is not the <em>pointer object</em> that is const (it can be made to point elsewhere) it is the object that is being pointed to.</p>\n<p>So we correctly see the <em>constness</em> of the <em>pointer</em> itself returned as <code>false</code>.</p>\n<p>If we want to make the <em>pointer</em> itself <code>const</code> we have to say:</p>\n<pre><code>int main()\n{\n    boolalpha(cout);\n\n    int const i = 1;\n    cout &lt;&lt; is_const&lt;decltype(i)&gt;::value &lt;&lt; endl;\n\n    int const* const ri = &amp;i;\n    cout &lt;&lt; is_const&lt;decltype(ri)&gt;::value &lt;&lt; endl;\n}\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code>true\ntrue\n</code></pre>\n<p>And so I think we see a syntactic analogy with the <em>reference</em>.</p>\n<p>However <em>references</em> are semantically different to pointers especially in <strong>one</strong> crucial respect, we are not allowed to <em>rebind</em> a reference to another object once bound.</p>\n<p>So even though <em>references</em> share the same syntax as <em>pointers</em> the rules are different and so the language prevents us from declaring the <em>reference</em> itself <code>const</code> like this:</p>\n<pre><code>int main()\n{\n    boolalpha(cout);\n\n    int const i = 1;\n    cout &lt;&lt; is_const&lt;decltype(i)&gt;::value &lt;&lt; endl;\n\n    int const&amp; const ri = i; // COMPILE TIME ERROR!\n    cout &lt;&lt; is_const&lt;decltype(ri)&gt;::value &lt;&lt; endl;\n}\n</code></pre>\n<p>I assume we are not allowed to do this because it doesn't appear to be needed when the language rules prevent the <em>reference</em> from being rebound in the same way a <em>pointer</em> could(if it is not declared <code>const</code>).</p>\n<p>So to answer the question:</p>\n<blockquote>\n<p id=\"so_38044834_38044973_0\"><strong>Q)</strong> Why \u201creference\u201d is not a \u201cconst\u201d in C++?</p>\n</blockquote>\n<p>In your example the syntax makes the thing being referred to <code>const</code> the same way it would if you were declaring a <em>pointer</em>.</p>\n<p>Rightly or wrongly we are not allowed to make the <em>reference</em> itself <code>const</code> but if we were it would look like this:</p>\n<pre><code>int const&amp; const ri = i; // not allowed\n</code></pre>\n<blockquote>\n<p id=\"so_38044834_38044973_1\"><strong>Q)</strong> we know once a reference is bind to a name/variable, we cannot change this binding, we change its binded object. \n  So I suppose the type of <code>ri</code> should be same as <code>i</code>: when <code>i</code> is a <code>int const</code>, why <code>ri</code> is not <code>const</code>?</p>\n</blockquote>\n<p>Why is the <code>decltype()</code> not transferred to the object the <em>referece</em> is bound to?</p>\n<p>I suppose this is for semantic equivalence with <em>pointers</em> and maybe also the function of <code>decltype()</code> (declared type) is to look back at what was <em>declared</em> before the binding took place. </p>\n", "LastActivityDate": "2016-06-28T15:40:42.457"}, "bq_ids": {"n4140": {"so_38044834_38044974_2": {"section_id": 3218, "quality": 0.8235294117647058, "length": 14}, "so_38044834_38044974_1": {"section_id": 1532, "quality": 0.5625, "length": 9}}, "n3337": {"so_38044834_38044974_2": {"section_id": 3092, "quality": 0.7058823529411765, "length": 12}, "so_38044834_38044974_1": {"section_id": 1526, "quality": 0.5625, "length": 9}}, "n4659": {"so_38044834_38044974_1": {"section_id": 1682, "quality": 0.5625, "length": 9}, "so_38044834_38044974_2": {"section_id": 3975, "quality": 0.8235294117647058, "length": 14}}}, "38044974": {"ParentId": "38044834", "LastEditDate": "2016-06-27T03:42:21.563", "CommentCount": "13", "CreationDate": "2016-06-27T02:07:57.210", "OwnerUserId": "3309790", "LastEditorUserId": "63550", "PostTypeId": "2", "Id": "38044974", "Score": "50", "Body": "<blockquote>\n<p id=\"so_38044834_38044974_0\">why is \"ri\" not \"const\"?</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/types/is_const\"><code>std::is_const</code></a> checks whether the type is const-qualified or not.</p>\n<blockquote>\n<p id=\"so_38044834_38044974_1\">If T is a const-qualified type (that is, const, or const volatile), provides the member constant value equal true. For any other type, value is false. </p>\n</blockquote>\n<p>But the reference can't be const-qualified. <a href=\"http://eel.is/c++draft/dcl.ref#1\">$8.3.2/1 References [dcl.ref]</a></p>\n<blockquote>\n<p id=\"so_38044834_38044974_2\">Cv-qualified references are ill-formed except when the cv-qualifiers\n  are introduced through the use of a typedef-name ([dcl.typedef],\n  [temp.param]) or decltype-specifier ([dcl.type.simple]), in which case\n  the cv-qualifiers are ignored.</p>\n</blockquote>\n<p>So <code>is_const&lt;decltype(ri)&gt;::value</code> will return <code>false</code> becuase <code>ri</code> (the reference) is not a const-qualified type. As you said, we can't rebind a reference after initialization, which implies reference is always \"const\", on the other hand, const-qualified reference or const-unqualified reference might not make sense actually.</p>\n", "LastActivityDate": "2016-06-27T03:42:21.563"}});