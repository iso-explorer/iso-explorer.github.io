post_cb({"bq_ids": {"n4140": {"so_21547180_21547181_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 411}, "so_21547180_21547181_0": {"length": 45, "quality": 1.0, "section_id": 6106}}, "n3337": {"so_21547180_21547181_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 402}, "so_21547180_21547181_0": {"length": 45, "quality": 1.0, "section_id": 5872}}, "n4659": {"so_21547180_21547181_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 429}, "so_21547180_21547181_0": {"length": 45, "quality": 1.0, "section_id": 7603}}}, "21547180": {"ViewCount": "250", "Body": "<pre><code>int main()\n{\n    Class_Name t;\n    Class_Name * p = &amp;t;\n\n    delete p;\n    return 0;\n}  \n</code></pre>\n<p>This code executes fine with 2 destructors being called? How does delete work with stack objects? Is the behavior undefined?</p>\n", "Title": "What is the behavior of \"delete\" with stack objects?", "CreationDate": "2014-02-04T06:36:43.607", "LastActivityDate": "2014-05-27T14:56:02.230", "CommentCount": "2", "LastEditDate": "2014-05-27T13:19:19.877", "PostTypeId": "1", "OwnerDisplayName": "sk patra", "LastEditorUserId": "1942027", "Id": "21547180", "Score": "5", "OwnerUserId": "1869280", "Tags": "<c++><memory><memory-management><stack>", "AnswerCount": "1"}, "21547181": {"Body": "<p>You're running into <strong>undefined behavior.</strong></p>\n<p>Standard (N3690) 5.3.5<code>[expr.delete]</code>/2</p>\n<blockquote>\n<p id=\"so_21547180_21547181_0\">If the operand has a class type, the operand is converted to a pointer\n  type by calling the above-mentioned conversion function, and the\n  converted operand is used in place of the original operand for the\n  remainder of this section. <strong>In the first alternative (delete object),\n  the value of the operand of delete may be a null pointer value, a\n  pointer to a non-array object created by a previous new-expression, or\n  a pointer to a subobject (1.8) representing a base class of such an\n  object (Clause 10). If not, the behavior is undefined.<br>\n  ...</br></strong></p>\n</blockquote>\n<p>You don't have a null pointer, nor do you have an Object previously allocated with new, so the behavior is undefined.</p>\n<p><strong>Note:</strong> Even when trying to do</p>\n<pre><code>int main()\n{\n    Class_Name t;\n    t.~Class_Name()\n    return 0;\n}\n</code></pre>\n<p>it would be undefined behavior. Even though it doesn't have a delete in it, simply because it explicitly calls the destructor of an Object with automatic storage duration. Which means that the destructor would be called twice, once when calling it explicitly, the 2nd time when leaving it's scope.</p>\n<p>Standard 12.4<code>[class.dtor]</code>/15</p>\n<blockquote>\n<p id=\"so_21547180_21547181_1\">Once a destructor is invoked for an object, the object no longer\n  exists; the behavior is undefined if the destructor is invoked for an\n  object whose lifetime has ended (3.8). [ <strong>Example: if the destructor\n  for an automatic object is explicitly invoked, and the block is\n  subsequently left in a manner that would ordinarily invoke implicit\n  destruction of the object, the behavior is undefined. \u2014end example</strong> ]</p>\n</blockquote>\n<p>Most of the time trying to do anything like that would (hopefully) lead to a crash. With a trivial deconstructor you might have (bad) luck and nothing happens though.</p>\n<p>Little terminology nitpick here: The C++ standard doesn't talk about stack vs heap objects, it always talks about automatic vs dynamic storage duration respectively. As you can also see in the above quote.</p>\n<hr>\n<p><strong>You should always follow the general guideline:</strong></p>\n<ul>\n<li>For stack allocated objects don't do any explicit freeing/deleting (destructors get called automatically).</li>\n<li>For each <code>new</code> there should be a corresponding <code>delete</code></li>\n<li>For each <code>new[]</code> there should be a corresponding <code>delete[]</code></li>\n<li>For each <code>malloc</code> or <code>calloc</code> there should be a corresponding <code>free</code></li>\n</ul>\n</hr>", "CreationDate": "2014-02-04T07:31:56.237", "ParentId": "21547180", "CommentCount": "5", "LastEditDate": "2014-05-27T14:56:02.230", "PostTypeId": "2", "OwnerDisplayName": "Tribse", "LastEditorUserId": "1942027", "LastActivityDate": "2014-05-27T14:56:02.230", "Id": "21547181", "Score": "11", "OwnerUserId": "1942027"}});