post_cb({"bq_ids": {"n4140": {"so_22711901_22711901_0": {"length": 65, "quality": 0.8666666666666667, "section_id": 3274}}, "n3337": {"so_22711901_22711901_0": {"length": 67, "quality": 0.8933333333333333, "section_id": 3145}}, "n4659": {"so_22711901_22711901_0": {"length": 65, "quality": 0.8666666666666667, "section_id": 4032}}}, "22712452": {"Id": "22712452", "PostTypeId": "2", "Body": "<p>Suppose you have</p>\n<pre><code>// A.h\nstruct A {\n  A();\n};\n</code></pre>\n<p>and</p>\n<pre><code>// A.cc\nA::A() { }\n</code></pre>\n<p>You can change it to</p>\n<pre><code>// A.cc\nA::A() = default;\n</code></pre>\n<p>to not force code using <code>A.h</code> to be recompiled.</p>\n<p>For a default constructor, this doesn't make much sense. <code>= default</code> takes up more characters than <code>{ }</code>. But think of other constructor types: a copy or move constructor may become much shorter if it is no longer necessary to explicitly mention each field, and depending on the compiler and type you're dealing with, the defaulted copy/move constructor may even perform better, for example if the compiler can only detect that a <code>memcpy</code> call will suffice when you use the <code>= default</code> syntax.</p>\n", "LastActivityDate": "2014-03-28T12:09:51.833", "Score": "6", "CreationDate": "2014-03-28T12:09:51.833", "ParentId": "22711901", "CommentCount": "8", "OwnerUserId": "743382"}, "22711901": {"ViewCount": "377", "Body": "<p>In <code>8.4.2 Explicitly-defaulted functions [dcl.fct.def.default]</code> of the standard, </p>\n<blockquote>\n<p id=\"so_22711901_22711901_0\">Explicitly-defaulted functions and implicitly-declared functions are\n  collectively called defaulted functions, and the implementation shall\n  provide implicit definitions for them (12.1 12.4, 12.8), which might\n  mean defining them as deleted. A special member function is\n  user-provided if it is user-declared and not explicitly defaulted or\n  deleted on its first declaration. A user-provided explicitly-defaulted\n  function (i.e., explicitly defaulted after its first declaration) is\n  defined at the point where it is explicitly defaulted; if such a\n  function is implicitly defined as deleted, the program is ill-formed.\n  <strong>[ Note: Declaring a function as defaulted after its first declaration\n  can provide efficient execution and concise definition while enabling\n  a stable binary interface to an evolving code base.\u2014end note ]</strong></p>\n</blockquote>\n<p>What does the note at the end mean?  From what I can see, declaring a function as defaulted after its first declaration will make the function user-provided, thus make the function non-trivial, and thus either make the type having non-trivial default constructor or make the type non-trivially-copyable, and of course make the type non-trivial and non-POD, while still have the implementation to provide the function's actual definition.  But I don't understand how this leads to \"<code>provide efficient execution and concise definition while enabling a stable binary interface to an evolving code base</code>\".  Any thoughts are welcome and real-world examples are highly appreciated.  Thanks.</p>\n<p>An example of such type:</p>\n<pre><code>struct A {\n    A();\n};\nA::A() = default;\n</code></pre>\n", "AcceptedAnswerId": "22712452", "Title": "Declaring a function as defaulted after its first declaration", "CreationDate": "2014-03-28T11:43:54.303", "Id": "22711901", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-03-28T11:50:07.810", "LastEditorUserId": "3237645", "LastActivityDate": "2014-03-28T12:09:51.833", "Score": "7", "OwnerUserId": "3237645", "Tags": "<c++><c++11>", "AnswerCount": "1"}});