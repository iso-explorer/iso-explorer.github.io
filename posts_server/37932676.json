post_cb({"bq_ids": {"n4140": {"so_37932676_37932948_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 4071}}, "n3337": {"so_37932676_37932948_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3921}}, "n4659": {"so_37932676_37932948_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 4975}}}, "37932676": {"ViewCount": "116", "Body": "<p>I noticed that libstdc++'s implementation of <code>std::ignore</code> takes a <code>const T&amp;</code> argument, which can't bind to a volatile rvalue. Hence the following code fails to compile:</p>\n<pre><code>#include &lt;tuple&gt;\n#include &lt;utility&gt;\nstruct C {};\nusing VC = C volatile;\nint main() {\n    std::tuple&lt;VC&gt; t;\n    std::tie(std::ignore) = std::move(t);\n}\n</code></pre>\n<p>(<a href=\"http://coliru.stacked-crooked.com/a/7bfc499c1748e59e\">http://coliru.stacked-crooked.com/a/7bfc499c1748e59e</a>)</p>\n<p>Is this in violation of the standard, or is there a clause that renders this undefined behaviour?</p>\n", "Title": "Is libstdc++ wrong to reject assignment of volatile rvalue to std::ignore?", "CreationDate": "2016-06-20T22:14:02.853", "LastActivityDate": "2016-06-20T23:21:23.527", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "Id": "37932676", "Score": "8", "OwnerUserId": "481267", "Tags": "<c++><c++11><g++><tuples><language-lawyer>", "AnswerCount": "2"}, "37933293": {"Id": "37933293", "PostTypeId": "2", "Body": "<p><strong>Comment:</strong></p>\n<pre><code>// g++ 4.8.4\nint main() {\n    volatile int vi;\n    std::ignore = vi;\n\n    // error: no match for \u2018operator=\u2019 (\n    //     operand types are \u2018const std::_Swallow_assign\u2019\n    //     and \u2018std::remove_reference&lt;volatile int&amp;&gt;::type {aka volatile int}\u2019\n    // )\n    // std::ignore = std::move(vi);\n\n    // However this compiles:\n    volatile int&amp;&amp; vir = std::move(vi);\n    std::ignore = vir;\n}\n</code></pre>\n", "LastActivityDate": "2016-06-20T23:21:23.527", "CommentCount": "1", "CreationDate": "2016-06-20T23:21:23.527", "ParentId": "37932676", "Score": "0", "OwnerUserId": "2249683"}, "37932948": {"Id": "37932948", "PostTypeId": "2", "Body": "<p>I'm not a language lawyer, so I'm going to be answering this question as directly as possible.</p>\n<p><code>ignore</code> is found in the synopsis of <code>tuple</code> in <a href=\"http://eel.is/c++draft/tuple.general\" rel=\"nofollow\"><code>tuple.general</code></a> as such:</p>\n<pre><code>// [tuple.creation], tuple creation functions:\nconst unspecified ignore;\n</code></pre>\n<p>As you noticed, the <a href=\"https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/std/tuple#L1584\" rel=\"nofollow\">libstdc++</a> implementation defines <code>ignore</code> like this:</p>\n<pre><code>  // A class (and instance) which can be used in 'tie' when an element\n  // of a tuple is not required\n  struct _Swallow_assign\n  {\n    template&lt;class _Tp&gt;\n      const _Swallow_assign&amp;\n      operator=(const _Tp&amp;) const\n      { return *this; }\n  };\n</code></pre>\n<p>Whereas the <a href=\"https://github.com/llvm-mirror/libcxx/blob/95526d31cb9688f74106a58a9e8b5d1f663fcf5a/include/tuple#L1068\" rel=\"nofollow\">libc++</a> version defines it like this:</p>\n<pre><code>template &lt;class _Up&gt;\nstruct __ignore_t\n{\n    template &lt;class _Tp&gt;\n        _LIBCPP_INLINE_VISIBILITY\n        const __ignore_t&amp; operator=(_Tp&amp;&amp;) const {return *this;}\n};\n</code></pre>\n<p>As such, it compiles in libc++. Now the definition of <a href=\"http://eel.is/c++draft/tuple.tuple#tuple.creation-7\" rel=\"nofollow\"><code>std::tie</code></a> can be found in [tuple.creation] which says:</p>\n<blockquote>\n<p id=\"so_37932676_37932948_0\">Returns: <code>tuple&lt;Types&amp;...&gt;(t...)</code>. When an argument in <code>t</code> is\n  <code>ignore</code>, assigning any value to the corresponding tuple element has\n  no effect.</p>\n</blockquote>\n<p>This doesn't say anything about <code>ignore</code> itself, so I'm going to chalk this up to <em>unspecified</em> behavior. You can argue it's <em>undefined</em> behavior by omission, but that might be stretching it.</p>\n", "LastActivityDate": "2016-06-20T22:40:01.703", "CommentCount": "4", "CreationDate": "2016-06-20T22:40:01.703", "ParentId": "37932676", "Score": "0", "OwnerUserId": "6292850"}});