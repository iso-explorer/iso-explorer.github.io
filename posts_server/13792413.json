post_cb({"bq_ids": {"n4140": {"so_13792413_13792413_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 733}, "so_13792413_13792413_2": {"length": 12, "quality": 1.0, "section_id": 733}, "so_13792413_13792413_3": {"length": 15, "quality": 0.9375, "section_id": 734}}, "n3337": {"so_13792413_13792413_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 722}, "so_13792413_13792413_2": {"length": 12, "quality": 1.0, "section_id": 722}, "so_13792413_13792413_3": {"length": 15, "quality": 0.9375, "section_id": 723}}, "n4659": {"so_13792413_13792413_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 763}, "so_13792413_13792413_2": {"length": 12, "quality": 1.0, "section_id": 763}, "so_13792413_13792413_3": {"length": 15, "quality": 0.9375, "section_id": 747}}}, "13792413": {"ViewCount": "173", "Body": "<p>I am writing a new container, and trying to comply with <code>N3485 23.2.3 [sequence.reqmts]/14</code>, which states:</p>\n<blockquote>\n<p id=\"so_13792413_13792413_0\">For every sequence container defined in this Clause and in Clause 21:</p>\n<ul>\n<li><p id=\"so_13792413_13792413_1\">If the constructor</p>\n<pre><code>template &lt;class InputIterator&gt;\nX(InputIterator first, InputIterator last, \n     const allocator_type&amp; alloc = allocator_type())\n</code></pre>\n<p id=\"so_13792413_13792413_2\">is called with a type <code>InputIterator</code> that does not qualify as an\n  input iterator, then the constructor shall not participate in overload\n  resolution.</p></li>\n</ul>\n</blockquote>\n<p>(<code>/14</code> repeats this almost verbatim for the member functions taking iterator ranges)</p>\n<p><code>N3485 23.2.3 [sequence.reqmts]/15</code> says:</p>\n<blockquote>\n<p id=\"so_13792413_13792413_3\">The extent to which an implementation determines that a type cannot be an input iterator is unspecified, except that as a minimum integral types shall not qualify as input iterators.</p>\n</blockquote>\n<p>My understanding is that the phrase \"shall not participate in overload resolution\" means that the container implementer is supposed to use SFINAE tricks to disable that constructor or member function during template argument deduction. For the member functions, this is no big deal; as the return type on a function is the normal way to use <code>enable_if</code>. But for the constructor, there is no return type on which <code>enable_if</code> can be applied. This was my first attempt to declare the constructor:</p>\n<pre><code>// The enable_if use below is to comply with 23.2.3 [sequence.reqmts]/14:\n//     ... is called with a type InputIterator that does not qualify as an input iterator\n//     then the constructor shall not participate in overload resolution.\ntemplate &lt;typename InputIterator&gt;\npath(std::enable_if&lt;!std::is_integral&lt;InputIterator&gt;::value, InputIterator&gt;::type first,\n     InputIterator last, Allocator const&amp; allocator = allocator_type());\n</code></pre>\n<p>However, boost's <a href=\"http://www.boost.org/doc/libs/1_52_0/libs/utility/enable_if.html\" rel=\"nofollow\"><code>enable_if</code> docs</a> suggest using a dummy pointer parameter initialized to <code>nullptr</code> instead of using an actual parameter to a function. Is that necessary for correct behavior here or is the preceding declaration of <code>path</code>'s iterator range constructor okay?</p>\n", "AcceptedAnswerId": "13792544", "Title": "Can enable_if be used as a non-extra parameter (e.g. for a constructor)?", "CreationDate": "2012-12-09T22:14:38.973", "Id": "13792413", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2012-12-09T22:34:21.583", "Score": "1", "OwnerUserId": "82320", "Tags": "<c++><stl><template-meta-programming>", "AnswerCount": "1"}, "13792544": {"Id": "13792544", "PostTypeId": "2", "Body": "<p>The Good Robot (R. Martinho Fernandes) discusses the issue with a clean C++11 solution, namely using a default template parameter to apply <code>enable_if</code>, in <strong><a href=\"http://flamingdangerzone.com/cxx11/2012/06/01/almost-static-if.html\" rel=\"nofollow\">his blog</a></strong>.</p>\n<p>However, let me just point out here that doing</p>\n<pre><code>    template&lt; class Type &gt;\n    void foo( typename Something&lt; Type &gt;::T )\n</code></pre>\n<p><em><strong>foils argument deduction</strong></em></p>.\n<p>It's still possible to call the function, by explicitly providing the template argument. But in C++ the compiler will simply refuse to match e.g. a <code>MyType</code> actual argument to formal argument type <code>Something&lt;Blah&gt;::T</code>, because while this can be done in some special cases it cannot always be done (there could be countless choices of <code>Blah</code> where <code>Something&lt;Blah&gt;::T</code> was <code>MyType</code>).</p>\n<p>So, your current approach won't work in general, but the whole problem of the specification's requirement is a C++11 problem, so the C++11 specific solution is OK! :-)</p>\n", "LastEditorUserId": "46642", "LastActivityDate": "2012-12-09T22:34:21.583", "Score": "3", "CreationDate": "2012-12-09T22:30:03.437", "ParentId": "13792413", "CommentCount": "5", "OwnerUserId": "464581", "LastEditDate": "2012-12-09T22:34:21.583"}});