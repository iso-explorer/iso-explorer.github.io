post_cb({"28477129": {"ParentId": "28476393", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_28476393_28477129_0\">How to test by myself the above cases in order to determine if a given\n  type is being moved in a given context?</p>\n</blockquote>\n<p>You can test whether a derived class would define a defaulted move constructor as deleted via SFINAE. This idea does not work for <code>final</code> classes. A rough sketch that seems to work is</p>\n<pre><code>namespace detail {\n  // No copy constructor. Move constructor not deleted if T has an applicable one.\n  template &lt;typename T&gt;\n  struct Test : T { Test(Test&amp;&amp;) = default; };\n}\n\n// TODO: Implement unions\ntemplate &lt;typename T&gt;\nusing is_moveable = std::is_move_constructible&lt;\n    std::conditional_t&lt;std::is_class&lt;T&gt;{}, detail::Test&lt;T&gt;, T&gt;&gt;;\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/d9913da6d7d9aab7\" rel=\"nofollow\"><strong>Demo</strong></a>.</p>\n<p>The move constructor of <code>Test</code> is a defaulted move constructor according to [dcl.fct.def.default]/5. The relevant quote that makes the above work is then in [class.copy]/11:</p>\n<blockquote>\n<p id=\"so_28476393_28477129_1\">A defaulted [..] move constructor for a class <code>X</code> is defined as\n  deleted (8.4.3) if <code>X</code> has:</p>\n<ul>\n<li>a potentially constructed subobject type <code>M</code> (or array thereof) <strong>that cannot be [..] moved because overload resolution (13.3), as\n  applied to <code>M</code>\u2019s corresponding constructor, results in an ambiguity or\n  a function that is deleted or inaccessible from the defaulted\n  constructor,</strong> [..]</li>\n</ul>\n<p id=\"so_28476393_28477129_2\">A defaulted move constructor that is defined as deleted is ignored by overload resolution (13.3, 13.4).</p>\n</blockquote>\n<p>For the initialization </p>\n<pre><code>Test(Test())\n</code></pre>\n<p>to be valid, as the copy ctor is not implicitly declared, a move constructor must be available.  However, according to the above quote, <code>Test</code>'s move constructor will be defined as deleted (and thus ignored by overload resolution) if the base class, our given <code>T</code>, does not have an invokeable move constructor. (I am slightly unsure about the case where <code>T</code> does not have any move constructor, I'd be grateful for clarification on the standard there.)</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-02-12T12:35:18.370", "Id": "28477129", "Score": "1", "CreationDate": "2015-02-12T12:10:09.860", "LastActivityDate": "2015-02-12T12:35:18.370"}, "bq_ids": {"n4140": {"so_28476393_28477129_1": {"section_id": 460, "quality": 0.7142857142857143, "length": 5}, "so_28476393_28477129_2": {"section_id": 460, "quality": 0.8, "length": 8}}, "n3337": {"so_28476393_28477129_1": {"section_id": 451, "quality": 0.7142857142857143, "length": 5}, "so_28476393_28477129_2": {"section_id": 451, "quality": 0.6, "length": 6}}, "n4659": {"so_28476393_28477129_1": {"section_id": 382, "quality": 0.7142857142857143, "length": 5}, "so_28476393_28477129_2": {"section_id": 483, "quality": 0.8, "length": 8}}}, "28476393": {"CommentCount": "7", "ViewCount": "110", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-02-12T11:32:44.273", "LastActivityDate": "2015-02-12T12:35:18.370", "Title": "How to know or test if a given type is going to be moved", "FavoriteCount": "1", "LastEditDate": "2017-05-23T11:43:32.933", "Id": "28476393", "Score": "1", "Body": "<p>I'm not looking for a <a href=\"https://stackoverflow.com/questions/7054952/type-trait-for-moveable-types\">type trait for movable types</a>, nor <a href=\"https://stackoverflow.com/questions/24342941/what-are-the-rules-for-automatic-generation-of-move-operations\">rules for automatic generation of move operations</a>. What I'm looking for is a general guide to know if a given type is going to be moved or copied, or a way to figure it myself with testing.</p>\n<p>In some cases, the moving operation is performed without the user ever noticing, for example:</p>\n<pre><code>void f(std::string) { ... }\nvoid f_c(const std::string) { ... }\n\nvoid g()\n{\n    f(std::string(\"Hello world!\"));   // moved, isn't it?\n    f(\"Hello world!\");                // moved, isn't it?\n    f_c(std::string(\"Hello world!\")); // moved, isn't it?\n    f_c(\"Hello world!\");              // moved, isn't it?\n}\n</code></pre>\n<p>Prior to C++11 the code above would incurr in <code>std::string</code> copy from a temporary value to the one passed to <code>f</code> and <code>f_c</code>, from C++11 onwards the <code>std::basic_string</code> provides a move constructor (see <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/basic_string\" rel=\"nofollow noreferrer\">here (8)</a>) and the temporary created is moved into the parameter passed to <code>f</code> and <code>f_c</code>.</p>\n<p>Sometimes the users were trying to force the move semantics with the <a href=\"http://en.cppreference.com/w/cpp/utility/move\" rel=\"nofollow noreferrer\"><code>std::move</code></a> function:</p>\n<pre><code>std::string return_by_value_1()\n{\n    std::string result(\"result);\n    return std::move(result); // Is this moved or not?\n}\n\nstd::string return_by_value_2()\n{\n    return std::move(std::string(\"result)); // Is this moved or not?\n}\n</code></pre>\n<p>But <code>std::move</code> doesn't move anything<sup>1</sup>: it only converts lvalues into rvalues references, if the target type doesn't implement move semantics: no move operation is performed... and AFAIK <code>std::move</code>ing in the <code>return_by_value_x</code> functions above prevents the compiler from doing RVO (we're worsening the code!).</p>\n<p>So, after the (maybe unnecessary) introduction, I'll ask my questions:</p>\n<h3>How to know or test if a given type is going to be moved or copied?</h3>\n<p>This question is about basic types and complex ones:</p>\n<pre><code>int f_int(int) { ... };\ntemplate &lt;typename F, typename S&gt; void f_pair(std::pair&lt;F, S&gt;) { ... };\n\nstruct weird\n{\n    int i;\n    float f;\n    std::vector&lt;double&gt; vd;\n    using complexmap = std::map&lt;std::pair&lt;std::string, std::uint64_t&gt;, std::pair&lt;std::uint32_t, std::uint32_t&gt;&gt;;\n    complexmap cm;\n};\n\nstruct silly\n{\n    std::vector&lt;std::pair&lt;const std::string, weird::complexmap&gt;&gt; vcm;\n};\n\nf_weird(weird) { ... };\nf_silly(silly) { ... };\n</code></pre>\n<hr>\n<ul>\n<li>A basic type can be moved? there's some calls to <code>f_int</code> which implies a move operation?\n\n<ul>\n<li><code>f_int(1);            // this moves or construct an int in-place?</code></li>\n<li><code>f_int(1 + 2);        // this moves or construct an int in-place?</code></li>\n<li><code>f_int(f_int(1) + 2); // this moves or construct an int in-place?</code></li>\n</ul></li>\n<li>A <em>complex</em> type with const members can't be moved, isn't it?\n\n<ul>\n<li><code>f_pair&lt;std::pair&lt;const std::string, int&gt;&gt;({\"1\", 2});     // unmovable?</code></li>\n<li><code>f_pair&lt;std::pair&lt;std::string, std::string&gt;&gt;({\"1\", \"2\"}); // this moves?</code></li>\n<li><code>f_silly({{{}, {}}});                                     // this moves?</code></li>\n</ul></li>\n<li>The <code>struct weird</code> is moveable?\n\n<ul>\n<li><code>f_weird({1, .0f, {0.d, 1.d}, {{{\"a\", 0ull}, {1u, 2u}}}}) // this moves?</code></li>\n</ul></li>\n<li>How to test by myself the above cases in order to determine if a given type is being moved in a given context?</li>\n</ul>\n<hr>\n<p><sup>1</sup>Wouldn't be better if it was called <code>std::rvalref</code> or something similar?</p>\n</hr></hr>", "Tags": "<c++><c++11><move-semantics>", "OwnerUserId": "499359", "AnswerCount": "1"}});