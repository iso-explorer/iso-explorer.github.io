post_cb({"bq_ids": {"n4140": {"so_32134719_32135786_0": {"section_id": 6044, "quality": 0.75, "length": 12}, "so_32134719_32134719_0": {"section_id": 6046, "quality": 0.6428571428571429, "length": 36}}, "n3337": {"so_32134719_32135786_0": {"section_id": 5812, "quality": 0.75, "length": 12}, "so_32134719_32134719_0": {"section_id": 5814, "quality": 0.9107142857142857, "length": 51}}, "n4659": {"so_32134719_32135786_0": {"section_id": 7543, "quality": 0.75, "length": 12}, "so_32134719_32134719_0": {"section_id": 7545, "quality": 0.6428571428571429, "length": 36}}}, "32136277": {"ParentId": "32134719", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is not allowed by the standard. The correct way to store the pointer would be:</p>\n<pre><code>interface* tmp = new debug_interface;\nvoid* handle = reinterpret_cast&lt;void*&gt;(tmp);\n</code></pre>\n<p>You can of course do it in one line:</p>\n<pre><code>void* handle = reinterpret_cast&lt;void*&gt;(\n    static_cast&lt;interface*&gt;(new debug_interface));\n</code></pre>\n<p>but this is too unwieldy and error-prone to my taste.</p>\n<p>The standard allows you to cast a pointer to <code>void*</code> and back, but you have to cast it back to the exact same pointer type you've started with. Pointer to a base class is no substitute.</p>\n<p>Your code has a good chance to crash and burn if you make <code>debug_interface</code> use multiple or virtual inheritance, but even with plain single inhetitance it's not conforming.</p>\n", "OwnerUserId": "775806", "LastEditorUserId": "775806", "LastEditDate": "2015-08-21T11:40:32.373", "Id": "32136277", "Score": "1", "CreationDate": "2015-08-21T08:56:30.323", "LastActivityDate": "2015-08-21T11:40:32.373"}, "32134719": {"CommentCount": "4", "ViewCount": "661", "PostTypeId": "1", "LastEditorUserId": "2182737", "CreationDate": "2015-08-21T07:30:56.607", "LastActivityDate": "2015-08-21T12:52:26.437", "Title": "Virtual functions and cast to void and back", "FavoriteCount": "0", "LastEditDate": "2015-08-21T08:40:31.050", "Id": "32134719", "Score": "8", "Body": "<p>Currently I am working with a legacy c++ code base. In this codebase pointer to objects are converted to void-pointers and then stored in a c-library.\nConsider the following code:</p>\n<pre><code>class interface {\npublic:\n  virtual void foo() {\n    std::cout &lt;&lt; \"Interface\" &lt;&lt; std::endl;}\n  virtual ~interface(){};\n};\n\nclass debug_interface: public interface {\npublic:\n  virtual void foo() {\n   std::cout &lt;&lt; \"Debug Interface\" &lt;&lt; std::endl;}\n};\n</code></pre>\n<p>The objects <code>interface</code> and <code>debug_interface</code> are allocated on the heap and the address is stored to a void pointer. At some point the pointers are retrieved and then casted back to the base-class <code>interface</code>. Then the virtual function call is invoked. See</p>\n<pre><code>int main(int argc, char *argv[]){\n\n    void *handle = reinterpret_cast&lt;void*&gt;(new interface());\n    void *debug_handle = reinterpret_cast&lt;void*&gt;(new debug_interface());\n\n   //void *handle = new interface();\n   //void *debug_handle = new debug_interface();\n\n   interface *foo1 = reinterpret_cast&lt;interface*&gt;(handle);\n   interface *foo2 = reinterpret_cast&lt;interface*&gt;(debug_handle);\n\n   //interface *foo1 = static_cast&lt;interface*&gt;(handle);\n   //interface *foo2 = static_cast&lt;interface*&gt;(debug_handle);\n\n   foo1-&gt;foo();\n   foo2-&gt;foo();\n\n   return 0;\n}\n</code></pre>\n<p>First of all I don't understand, why reinterpret_cast is used. As far as I know, pointer-to-objects can be implicitly converted to void*. Furthermore, to make this cast explicit, a static_cast would be enough, right?\nBut the more important question: Is it really save to cast the pointer debug_handle to interface* ( not to debug_interface*) and invoke the virtual call?  According to the c++-standard, (5.2.10) this is undefined behavior:</p>\n<blockquote>\n<p id=\"so_32134719_32134719_0\">A pointer to an object can be explicitly converted to a pointer\n  to a different object type.69 When a prvalue v of type \u201cpointer\n  to T1\u201d is converted to the type \u201cpointer to cv T2\u201d, the result is\n  static_cast(static_cast(v)) if both T1 and T2\n  are standard-layout types (3.9) and the alignment requirements of\n  T2 are no stricter than those of T1. Converting a prvalue of type\n  \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are\n  object types and where the alignment requirements of T2 are no\n  stricter than those of T1) and back to its original type yields\n  the original pointer value. The result of any other such pointer\n  conversion is unspecified.</p>\n</blockquote>\n<p>The conversion from <code>handle</code> to <code>foo1</code> should be ok, but I can again use a static_cast?</p>\n<p><strong>Edit</strong>\nMy example source code was wrong. debug_interface is a derived class of interface. </p>\n", "Tags": "<c++><virtual><void><reinterpret-cast><static-cast>", "OwnerUserId": "2182737", "AnswerCount": "4"}, "32135786": {"ParentId": "32134719", "PostTypeId": "2", "CommentCount": "7", "Body": "<p><strong>Disclaimer:</strong> <em>This first part was written when the two interfaces were not related by inheritance.</em> </p>\n<p>The undefined behaviour actually happens here:</p>\n<pre><code>   foo2-&gt;foo();\n</code></pre>\n<p>Here, you are using the <code>interface</code> API on a pointer to an object that is <strong>not</strong> implementing this API.\nThe fact that both <code>interface</code> and <code>debug_interface</code> happen to implement the <code>foo()</code> member as their first method does not change anything: those classes are not related by inheritance, so they are not compatible.</p>\n<p>The extract you are citing treats about cases where the <strong>conversion</strong> itself is allowed. In your case, my understanding is that you can actually convert a pointer to <code>debug_interface</code> to a pointer to <code>interface</code>: yet, the only safe thing you can now do with you pointer to interface is to convert it back to a <code>debug_interface</code> pointer: using it to access <code>interface</code> members is unsafe.</p>\n<hr>\n<p><strong>EDIT:</strong> If <code>debug_interface</code> publicly derives from <code>interface</code>, this is a different problem.</p>\n<p>In this case, it would be totally safe to cast from <code>debug_interface*</code> to <code>interface*</code>: the <em>derived-to-base</em> conversion can even be applied implicitly by the compiler.\nYet to be safe, this cast must be done <strong>directly</strong>, through either:</p>\n<ul>\n<li>a <code>static_cast</code></li>\n<li>a <code>dynamic_cast</code> (which would introduce runtime check, being overkill for an upcast).</li>\n</ul>\n<p>Doing it through two <code>reinterpret_cast</code> is an undefined behaviour: it is likely to work for single inheritance (on some compilers), but it is absolutely not guaranteed by the standard.<br/>\nDoing it through two <code>static_cast</code> would also be an undefined behaviour. The standard guarantees that (emphasis mine):</p>\n<blockquote>\n<p id=\"so_32134719_32135786_0\">A value of type pointer to object converted to \u201cpointer to cv void\u201d and back to the <strong>original pointer</strong> type will have its original value.</p>\n</blockquote>\n<p>In your example, you are not converting back to the original pointer, but to another pointer type: the standard is not giving you any guarantee about the value you will get.</p>\n<h2>Possible solution</h2>\n<p>Knowing that:</p>\n<ol>\n<li>It is safe to directly convert from <code>debug_interface</code> to <code>interface</code></li>\n<li>It is safe to convert from a pointer to object type to <code>void *</code> then back to pointer to the same object type.</li>\n</ol>\n<p>You could assemble that to get a standard guaranteed solution:</p>\n<pre><code>// Safe, see point #1.\n// The new expression returns a debug_interface* and static_cast applies a derived-to-base conversion.\ninterface *debug_handle_interim = static_cast&lt;interface*&gt;(new debug_interface());\n\n// Convert a interface* to void* then back to interface*, see #2\nvoid *type_erased = static_cast&lt;void*&gt;(debug_handle_interim);\ninterface *debug_handle_back = static_cast&lt;interface*&gt;(type_erased);\n</code></pre>\n</hr>", "OwnerUserId": "1027706", "LastEditorUserId": "1027706", "LastEditDate": "2015-08-21T12:52:26.437", "Id": "32135786", "Score": "4", "CreationDate": "2015-08-21T08:31:59.143", "LastActivityDate": "2015-08-21T12:52:26.437"}, "32136159": {"ParentId": "32134719", "CommentCount": "0", "Body": "<p>You are right, it is undefined. When you cast back a <code>void*</code> you should use always the original pointer type. And you should use <code>static_cast</code> instead of <code>dynamic_cast</code>.</p>\n<p>So your code could be safely written as:</p>\n<pre><code>int main(int argc, char *argv[]){\n\n    void *handle = new interface();\n    void *debug_handle = static_cast&lt;interface*&gt;(new debug_interface());\n\n    //Beware! This would be wrong:\n    //void *debug_handle = new debug_interface();\n\n   interface *foo1 = static_cast&lt;interface*&gt;(handle);\n   interface *foo2 = static_cast&lt;interface*&gt;(debug_handle);\n\n   foo1-&gt;foo();\n   foo2-&gt;foo();\n\n   return 0;\n}\n</code></pre>\n<p>And indeed if you happen to have a class such as:</p>\n<pre><code>class weird_interface : something, public interface\n{ /* */};\n</code></pre>\n<p>And then write:</p>\n<pre><code>weird_interface *a = new weird_interface();\ninterface *b = static_cast&lt;interface*&gt;(static_cast&lt;void*&gt;(a));\ninterface *c = a;\nstatic_assert(b == c, \"\");\n</code></pre>\n<p>You'll see why the UB.</p>\n", "OwnerUserId": "865874", "PostTypeId": "2", "Id": "32136159", "Score": "1", "CreationDate": "2015-08-21T08:50:36.230", "LastActivityDate": "2015-08-21T08:50:36.230"}, "32135351": {"ParentId": "32134719", "CommentCount": "0", "Body": "<p>You're right, and this code typically breaks for the second interface of a class.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "32135351", "Score": "0", "CreationDate": "2015-08-21T08:07:16.737", "LastActivityDate": "2015-08-21T08:07:16.737"}});