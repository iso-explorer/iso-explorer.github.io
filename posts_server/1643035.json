post_cb({"1643190": {"Id": "1643190", "PostTypeId": "2", "Body": "<p>I believe that this question is duplicate, but I cannot find it now. C++ Standard says that you should fully qualify name according to 14.6.2/3:</p>\n<blockquote>\n<p id=\"so_1643035_1643190_0\">In the definition of a class template or a member of a class template, if a base class of the class template depends on a template-parameter, the <strong>base class scope is not examined during unqualified name lookup</strong> either at the point of definition of the class template or member or during an instantiation of the class template or member.</p>\n</blockquote>\n<p><strong>UPD:</strong> I found duplicate finally: <a href=\"https://stackoverflow.com/questions/1567730/inheritance-and-templates-in-c-why-are-methods-invisible\">here it is</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2009-10-29T12:38:15.483", "Score": "36", "CreationDate": "2009-10-29T11:54:30.877", "ParentId": "1643035", "CommentCount": "2", "OwnerUserId": "123111", "LastEditDate": "2017-05-23T12:17:57.273"}, "1643153": {"Id": "1643153", "PostTypeId": "2", "Body": "<p>Vec_t is not a dependent name, and the compiler needs to know what it is without instantiating any templates (base class in this case). It is really no different from:</p>\n<pre><code>template &lt;class T&gt;\nclass X\n{\n    std::string s;\n}\n</code></pre>\n<p>Here as well the compiler needs to know about std::string even if X is not instantiated, since the name does not depend on the template argument T (as far as the compiler can assume).</p>\n<p>All in all, typedefs in a template base class seem rather useless for use in derived class. The typedefs are useful for the user, however. </p>\n", "LastActivityDate": "2009-10-29T11:44:13.157", "CommentCount": "1", "CreationDate": "2009-10-29T11:44:13.157", "ParentId": "1643035", "Score": "1", "OwnerUserId": "155693"}, "1643173": {"Id": "1643173", "PostTypeId": "2", "Body": "<p>There is something called dependent and <em>nondependent</em> names in case of templates.</p>\n<p>If name depends on template parameter T its <em>dependent</em> name and others those do not depend on parameter T are <em>independent</em> names.</p>\n<blockquote>\n<p id=\"so_1643035_1643173_0\">Here's the rule: the compiler does not\n  look in dependent base classes (like\n  A) when looking up nondependent\n  names (like Vec_t). As a result,\n  the compiler does not know they even\n  exist let alone are types.</p>\n</blockquote>\n<p>Compiler cannot assume that <code>Vec_t</code> is a type until it knows <code>T</code> because There is a potential specialization of <code>A&lt;T&gt;</code> where <code>A&lt;T&gt;:: Vec_t</code> is a is a data member</p>\n<p>So the solution is use typename </p>\n<pre><code> typename A&lt;T&gt;::Vec_t v;  \u2190 good\n</code></pre>\n<p>I recommend you go through this <a href=\"https://isocpp.org/wiki/faq/templates#nondependent-name-lookup-types\" rel=\"noreferrer\">https://isocpp.org/wiki/faq/templates#nondependent-name-lookup-types</a>.</p>\n<p>Old (broken) link: <a href=\"http://www.parashift.com/c++-faq-lite/templates.html#faq-35.18\" rel=\"noreferrer\">http://www.parashift.com/c++-faq-lite/templates.html#faq-35.18</a></p>\n", "LastEditorUserId": "5757494", "LastActivityDate": "2016-01-07T13:53:56.410", "Score": "24", "CreationDate": "2009-10-29T11:49:09.397", "ParentId": "1643035", "CommentCount": "3", "OwnerUserId": "138604", "LastEditDate": "2016-01-07T13:53:56.410"}, "1643136": {"Id": "1643136", "PostTypeId": "2", "Body": "<p>You need to explicitly qualify the use of <code>Vec_t</code> because the compiler does not know where <code>Vec_t</code> comes from.</p>\n<p>It cannot assume anything about the structure of A, since the class template A may be specialized. The specialization may include a <code>Vec_t</code> which is not a typedef, or it may not even include a member <code>Vec_t</code> at all.</p>\n", "LastActivityDate": "2009-10-29T11:40:21.797", "CommentCount": "0", "CreationDate": "2009-10-29T11:40:21.797", "ParentId": "1643035", "Score": "2", "OwnerUserId": "200783"}, "bq_ids": {"n4140": {"so_1643035_1643190_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 190}}, "n3337": {"so_1643035_1643190_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 184}}, "n4659": {"so_1643035_1643190_0": {"length": 22, "quality": 0.7096774193548387, "section_id": 195}}}, "1643035": {"ViewCount": "20549", "Body": "<p>I'm trying to define base class, which contains typedef's only. </p>\n<pre><code>template&lt;typename T&gt;\nclass A\n{\npublic:\n    typedef std::vector&lt;T&gt; Vec_t;\n};\n\n\ntemplate&lt;typename T&gt;\nclass B : public A&lt;T&gt;\n{\nprivate:\n    Vec_t v;  // fails - Vec_t is not recognized\n};\n</code></pre>\n<p>Why in B I receive an error that Vec_t is not recognized and I need to write it explicitly?</p>\n<pre><code>typename A&lt;T&gt;::Vec_t v;\n</code></pre>\n", "AcceptedAnswerId": "1643190", "Title": "Propagating 'typedef' from based to derived class for 'template'", "CreationDate": "2009-10-29T11:21:15.310", "Id": "1643035", "CommentCount": "3", "FavoriteCount": "16", "PostTypeId": "1", "LastEditDate": "2012-08-16T17:43:04.600", "LastEditorUserId": "963864", "LastActivityDate": "2016-01-07T13:53:56.410", "Score": "45", "OwnerUserId": "135960", "Tags": "<c++><templates><inheritance><typedef><name-lookup>", "AnswerCount": "5"}, "1643127": {"Id": "1643127", "PostTypeId": "2", "Body": "<p>Because the compiler's not certain that <code>Vec_t</code> names a type. For example, <code>A&lt;T&gt;</code> might be specialized for <code>T=int</code> to <em>not</em> have that particular <code>typedef</code>.</p>\n", "LastActivityDate": "2009-10-29T11:38:38.353", "CommentCount": "1", "CreationDate": "2009-10-29T11:38:38.353", "ParentId": "1643035", "Score": "7", "OwnerUserId": "112"}});