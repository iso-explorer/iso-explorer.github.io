post_cb({"8329923": {"Id": "8329923", "PostTypeId": "2", "Body": "<p>Declare the variable <code>static</code> (C and C++):</p>\n<pre><code>static int myGlobalVariable;\n</code></pre>\n<p>or declare it in an anonymous namespace (C++ only):</p>\n<pre><code>namespace {\n    int myGlobalVariable;\n}\n</code></pre>\n", "LastActivityDate": "2011-11-30T17:04:56.627", "CommentCount": "0", "CreationDate": "2011-11-30T17:04:56.627", "ParentId": "8329871", "Score": "2", "OwnerUserId": "1033896"}, "8330020": {"Id": "8330020", "PostTypeId": "2", "Body": "<p>The reason why you get linker errors is because the variables have <em>extern linkage</em>, and are in the same namespace (namely the global one).</p>\n<p>And the usual and recommended remedy is to put them in separate namespaces.</p>\n<p>You can accomplish that by using an <strong>anonymous namespace</strong>, like so:</p>\n<pre><code>namespace {\n    int my_global_variable;\n}\n</code></pre>\n<p>This namespace gets a unique name in each translation unit. Say, in one translation unit the automatic name could be \u201cgorblegorble123\u201d. And this works <em>as if</em> the compiler places the following code after it:</p>\n<pre><code>using namespace gorblegorble123;    // As if this is present.\n</code></pre>\n<p>And ditto in other translation unit, but with different unique names.</p>\n<p>This is the most general technique. In particular it works with class definitions.</p>\n<hr>\n<p>As mentioned in some other answers you <em>can</em> alternatively use <code>static</code> to specify <em>internal linkage</em>, that the variable is not visible to the linker.</p>\n<p>This usage was deprecated for objects in namespace scope in C++98 and C++03, but the deprecation was removed in C++11.</p>\n<p><code>static</code> is a limited special cases notation that can be applied to objects and functions, but not to classes.</p>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2017-02-15T12:41:20.587", "Score": "3", "CreationDate": "2011-11-30T17:10:01.990", "ParentId": "8329871", "CommentCount": "2", "OwnerUserId": "464581", "LastEditDate": "2017-02-15T12:41:20.587"}, "8330016": {"Id": "8330016", "PostTypeId": "2", "Body": "<p><code>why you can not declare a global with the same name in 2 different .cpp files</code></p>\n<p>Because any program that has multiple definitions of a single entity is ill-formed.  In your case, you have two entities named the same thing, therefore the program is ill-formed.</p>\n<p>The preferred method (In C++03 at least) to resolve this is to use unnamed namespaces:</p>\n<h2>file1.cpp</h2>\n<pre><code>namespace\n{\n  int n;\n};\n</code></pre>\n<h2>file2.cpp</h2>\n<pre><code>namespace\n{\n  int n;\n};\n</code></pre>\n<p>Placing a declaration within an unnamed namespace makes that entity visible only within that translation unit.</p>\n", "LastActivityDate": "2011-11-30T17:09:40.930", "CommentCount": "0", "CreationDate": "2011-11-30T17:09:40.930", "ParentId": "8329871", "Score": "1", "OwnerUserId": "241536"}, "8329889": {"Id": "8329889", "PostTypeId": "2", "Body": "<p>To make a global variable (or function) only visible to the file it's declared in,</p>\n<ol>\n<li>declare it <code>static</code>, or </li>\n<li>(the way that is preferred in C++) put the variable in a nameless namespace. It would seem like that would make it inaccessible from outside the namespace, but what it actually does is make it <em>only</em> visible to the file in which it is.</li>\n</ol>\n<p>To access a global variable (that is not <code>static</code> or in an anonymous namespace) that is declared in some other file, use <code>extern</code>.</p>\n<p>The reason why is the same reason why you can't have a function with the same name in two different files. It confuses the linker because global variables by default have external linkage. <code>static</code> or being in an anonymous namespace gives them internal linkage, which makes them like a \"local global variable\".</p>\n", "LastEditorUserId": "726361", "LastActivityDate": "2011-11-30T17:15:46.320", "Score": "7", "CreationDate": "2011-11-30T17:02:08.847", "ParentId": "8329871", "CommentCount": "15", "OwnerUserId": "726361", "LastEditDate": "2011-11-30T17:15:46.320"}, "bq_ids": {"n4140": {"so_8329871_8329930_3": {"length": 18, "quality": 0.9, "section_id": 5482}, "so_8329871_8329930_0": {"length": 14, "quality": 1.0, "section_id": 7038}, "so_8329871_8329930_2": {"length": 4, "quality": 1.0, "section_id": 5482}, "so_8329871_8329930_1": {"length": 27, "quality": 0.75, "section_id": 7041}}, "n3337": {"so_8329871_8329930_3": {"length": 18, "quality": 0.9, "section_id": 5268}, "so_8329871_8329930_0": {"length": 14, "quality": 1.0, "section_id": 6784}, "so_8329871_8329930_2": {"length": 4, "quality": 1.0, "section_id": 5268}, "so_8329871_8329930_1": {"length": 27, "quality": 0.75, "section_id": 6786}}, "n4659": {"so_8329871_8329930_3": {"length": 17, "quality": 0.85, "section_id": 6917}, "so_8329871_8329930_0": {"length": 14, "quality": 1.0, "section_id": 8535}, "so_8329871_8329930_2": {"length": 4, "quality": 1.0, "section_id": 6917}, "so_8329871_8329930_1": {"length": 27, "quality": 0.75, "section_id": 8538}}}, "8329930": {"Id": "8329930", "PostTypeId": "2", "Body": "<p><strong>The Problem:</strong><br>\nGlobal variables have <strong><a href=\"https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage-in-c\">External linkage</a></strong>, i.e: They are visible throughout the program.<br>\nif 2 different files have variable with same symbol name then it breaks the ODR(<strong><a href=\"http://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"nofollow noreferrer\">One Definition Rule</a></strong>).    </br></br></p>\n<p><strong>The One Definition Rule (ODR)</strong>, as the name suggests, requires that an object with external linkage, a non-inline function, a class, an enumeration or a template shall have exactly one definition in the program. </p>\n<hr>\n<p><strong>The Solution:</strong><br>\nYour global variables in the files should have <strong>Internal Linkage</strong> to avoid violation of ODR.\nThere are two ways to achieve this:</br></p>\n<p>Make your global variables in file <code>static</code> Or<br>\nUse <strong>Anonymous/Unnamed namespace</strong>.</br></p>\n<hr>\n<p><strong>Good Read:</strong><br>\n<strong><a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=/com.ibm.xlcpp8a.doc/language/ref/unnamed_namespaces.htm\" rel=\"nofollow noreferrer\">Anonymous/Unnamed namespace</a></strong><br>\n<strong><a href=\"http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=386\" rel=\"nofollow noreferrer\">Speaking Standardese: the One Definition Rule</a></strong> </br></br></p>\n<hr>\n<p><strong>For Standerdese Fans:</strong><br>\n<strong>C++11 3.2 One Definition Rule [basic.def.odr]</strong>:     </br></p>\n<blockquote>\n<p id=\"so_8329871_8329930_0\">No translation unit shall contain more than one definition of any variable, function, class type, enumeration type or template.       </p>\n</blockquote>\n<p>Para 3:     </p>\n<blockquote>\n<p id=\"so_8329871_8329930_1\">Every program shall contain exactly one de\ufb01nition of every non-inline function or variable that is odr-used in that program; no diagnostic required. The de\ufb01nition can appear explicitly in the program, it can be found in the standard or a user-de\ufb01ned library, or (when appropriate) it is implicitly de\ufb01ned (see 12.1, 12.4 and 12.8). An inline function shall be de\ufb01ned in every translation unit in which it is odr-used.</p>\n</blockquote>\n<p><strong>C++11 7.3.1.1 Unnamed namespaces [namespace.unnamed]</strong></p>\n<blockquote>\n<p id=\"so_8329871_8329930_2\">1/ An unnamed-namespace-definition behaves as if it were replaced by</p>\n</blockquote>\n<pre><code>inlineoptnamespace unique { /* empty body */ }    \nusing namespace unique ;      \nnamespace unique { namespace-body }       \n</code></pre>\n<blockquote>\n<p id=\"so_8329871_8329930_3\">where inline appears if and only if it appears in the unnamed-namespace-definition, all occurrences of unique in a translation unit are replaced by the same identifier, and this identifier differs from all other identifiers in the entire program.94</p>\n</blockquote>\n<p><strong>Note:</strong> C++03 deprecated usage of <code>static</code> for declaring objects in namespace scope but this deprecation was removed in C++11.</p>\n</hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2011-11-30T17:36:39.980", "Score": "5", "CreationDate": "2011-11-30T17:05:16.063", "ParentId": "8329871", "CommentCount": "6", "OwnerUserId": "452307", "LastEditDate": "2017-05-23T12:34:01.040"}, "8333469": {"Id": "8333469", "PostTypeId": "2", "Body": "<p>Since the question is also tagged 'c', I'd like to add my 5 cents. In C there is no \"one definition rule\".</p>\n<p>In C (C99 and before, not sure about C1x) an object with file scope and without a storage class specifier constitutes a <em>tentative definition</em>. (section 6.9.2).</p>\n<p>In the subsequent Example 1 on page 144, several examples are listed, concentrating all on definitions/declarations within one file.\nHowever, an <code>extern</code> declaration together with a declaration without storage class specifier (<code>i3</code>) go together well and constitute a definition with external linkage.</p>\n<p>This means that a second file may exist referring to that definition either using <code>extern</code> as well, or again without storage class specifier.</p>\n<p>So in C, you may have two files both with tentative definitions like</p>\n<pre><code>int i3;\n</code></pre>\n<p>and both will refer to one variable of tupe <code>int</code>, and the linker will make sure the both refer to the same memory location.\nAnd even if you have <code>int abc;</code> and <code>char abc</code> in two different files, the regular linker will not produce an error; hopefully it will warn you, though.</p>\n<p>H&amp;S5 has some more details on how various types of linkers will handle such a situation, but using the common memory model, the above is confirmed. At least IMHO.</p>\n<p>For further references, <a href=\"https://stackoverflow.com/questions/2331584/global-variable-implementation\">look here</a>, especially the answer by <a href=\"https://stackoverflow.com/users/226621/alok\">Alok</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-11-30T21:54:01.107", "Score": "1", "CreationDate": "2011-11-30T21:54:01.107", "ParentId": "8329871", "CommentCount": "0", "OwnerUserId": "1029106", "LastEditDate": "2017-05-23T11:45:28.967"}, "8329871": {"ViewCount": "2486", "Body": "<p>I would like to know why you can not declare a global with the same name in 2 different .cpp files. My understanding is considering scope, that it should only be visible to that particular .cpp file and no where else but it is obviously complaining. The reason I'm doing this is for commonality in code and that's it. any ideas?</p>\n<p><strong>Edit for Clarity</strong></p>\n<p><em>a.cpp</em> </p>\n<p>int g_x; </p>\n<p><em>b.cpp</em></p>\n<p>int g_x;</p>\n", "AcceptedAnswerId": "8329889", "Title": "C/C++ Scope in two different .cpp files", "CreationDate": "2011-11-30T17:00:51.110", "Id": "8329871", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-11-30T18:06:40.360", "LastEditorUserId": "968032", "LastActivityDate": "2017-02-15T12:41:20.587", "Score": "5", "OwnerUserId": "968032", "Tags": "<c++><c>", "AnswerCount": "6"}});