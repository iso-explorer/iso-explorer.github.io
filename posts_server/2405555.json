post_cb({"bq_ids": {"n4140": {"so_2405555_2405597_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6141}}, "n3337": {"so_2405555_2405597_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5905}}, "n4659": {"so_2405555_2405597_0": {"length": 11, "quality": 0.5789473684210527, "section_id": 7603}}}, "2405555": {"ViewCount": "289", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main()\n{\n    string myAry[] = \n    {\n        \"Mary\",\n        \"had\", \n        \"a\",\n        \"Little\",\n        \"Lamb\"\n    };\n    const size_t numStrs = sizeof(myStr)/sizeof(myAry[0]);\n\n    vector&lt;string&gt; myVec(&amp;myAry[0], &amp;myAry[numStrs]);\n\n    copy( myVec.begin(), myVec.end(), ostream_iterator&lt;string&gt;(cout, \" \"));\n\n    return 0;\n}\n</code></pre>\n<p>Of interest here is <code>&amp;myAry[numStrs]</code>: numStrs is equal to 5, so <code>&amp;myAry[numStrs]</code> points to something that doesn't exist; the <em>sixth</em> element in the array.  There is another example of this in the above code:  <code>myVec.end()</code>, which points to one-past-the-end of the vector <code>myVec</code>.  It's perfecly legal to take the address of this element that doesn't exist.  We know the size of <code>string</code>, so we know where the address of the 6th element of a C-style array of <code>string</code>s must point to.  So long as we only evaluate this pointer and never dereference it, we're fine.  We can even compare it to other pointers for equality.  The STL does this all the time in algorithms that act on a range of iterators.  The <code>end()</code> iterator points past the end, and the loops keep looping while a counter <code>!= end()</code>.</p>\n<p>So now consider this:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main()\n{\n    string myStr = \"Mary\";\n    string* myPtr = &amp;myStr;\n    vector&lt;string&gt; myVec2(myPtr, &amp;myPtr[1]);\n\n    copy( myVec2.begin(), myVec2.end(), ostream_iterator&lt;string&gt;(cout, \" \"));   \n\n    return 0;\n}\n</code></pre>\n<p>Is this code legal and well-defined?  It is legal and well-defined to take the address of an array element past the end, as in <code>&amp;myAry[numStrs]</code>, so should it be legal and well-defined to pretend that <code>myPtr</code> is also an array?</p>\n", "AcceptedAnswerId": "2405582", "Title": "string s; &s+1; Legal? UB?", "CreationDate": "2010-03-08T23:18:45.783", "Id": "2405555", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2010-03-08T23:31:15.327", "Score": "5", "OwnerUserId": "241536", "Tags": "<c++><undefined-behavior>", "AnswerCount": "2"}, "2405597": {"Id": "2405597", "PostTypeId": "2", "Body": "<p>The C++ standard in 5.6/4 \"Additive operators\" says:</p>\n<blockquote>\n<p id=\"so_2405555_2405597_0\">For the purposes of these operators, a pointer to a nonarray object behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type.</p>\n</blockquote>\n<p>The C99 standard 6.5.6/7 says essentially the same.</p>\n", "LastActivityDate": "2010-03-08T23:31:15.327", "Score": "5", "CreationDate": "2010-03-08T23:31:15.327", "ParentId": "2405555", "CommentCount": "0", "OwnerUserId": "12711"}, "2405582": {"Id": "2405582", "PostTypeId": "2", "Body": "<p>It is legal and not UB to have a pointer to \"one past the end\" of an array, and any single object can be treated as if it were in an array of length 1; however, you need to use <code>ptr + 1</code> instead due to the technicality of <code>&amp;ptr[1]</code> dereferencing and then taking the address.  This also applies to <code>&amp;array[size]</code> becoming <code>array + size</code>.</p>\n<p>What you have will work as you expect on all platforms of which I'm aware, but given how easy it is to use the unambiguously correct form, I see no reason not to do that instead.</p>\n", "OwnerDisplayName": "Roger Pate", "LastActivityDate": "2010-03-08T23:27:26.927", "Score": "12", "CreationDate": "2010-03-08T23:27:26.927", "ParentId": "2405555", "CommentCount": "1"}});