post_cb({"4650974": {"ViewCount": "420", "Body": "<p>I saw a function that looked something like this</p>\n<pre><code>int foo(int array[100])\n{\n...\n}\n</code></pre>\n<p>how is this different from</p>\n<pre><code>int foo(int *array)\n</code></pre>\n<p>Is it different?</p>\n<p>In what places should/can we use the former method.</p>\n", "Title": "What does it mean to have array with size in function parameters", "CreationDate": "2011-01-10T20:06:09.403", "LastActivityDate": "2011-01-11T13:33:37.873", "CommentCount": "0", "PostTypeId": "1", "Id": "4650974", "Score": "1", "OwnerUserId": "11212", "Tags": "<c++><arrays>", "AnswerCount": "4"}, "4651412": {"Id": "4651412", "PostTypeId": "2", "Body": "<p>In C++, you cannot pass an array as an argument to a function. A function declaration that exhibits a parameter of type <code>array of T</code> is converted, according to \u00a78.3.5 to <code>pointer to T</code>. This means that the following declarations are exactly equivalent:</p>\n<pre><code>void f( int a[10] );\nvoid f( int a[] );\nvoid f( int *a );\n</code></pre>\n<p>So in fact, as you point out they are exactly equivalent for the compiler even if the first one might be misleading to developers reading the code, as the given size in the declaration will not be enforced.</p>\n<p>This is different to function parameters that are of type <code>reference to array of T</code>, where the argument does not <em>decay</em> to a pointer, but rather keeps the full type:</p>\n<pre><code>void f( int (&amp;a)[10] ); // takes an array of exactly 10 integers\n</code></pre>\n<p>In this case, the compiler will actually enforce the type of the reference, which is <code>array of 10 int</code> (including size). The code inside the function can assume that there will always be 10 elements, and the compiler will ensure that.</p>\n<p>\u00a78.3.5 [dcl.fct] /3</p>\n<blockquote>\n<p id=\"so_4650974_4651412_0\">[...]After determining the type of each parameter, any parameter of type \u201carray of T\u201d or \u201cfunction returning T\u201d is adjusted to be \u201cpointer to T\u201d or \u201cpointer to function returning T,\u201d respectively.[...]</p>\n</blockquote>\n", "LastActivityDate": "2011-01-10T20:55:04.717", "CommentCount": "0", "CreationDate": "2011-01-10T20:55:04.717", "ParentId": "4650974", "Score": "3", "OwnerUserId": "36565"}, "bq_ids": {"n4140": {"so_4650974_4651412_0": {"length": 16, "quality": 1.0, "section_id": 3241}}, "n3337": {"so_4650974_4651412_0": {"length": 16, "quality": 1.0, "section_id": 3114}}, "n4659": {"so_4650974_4651412_0": {"length": 12, "quality": 0.75, "section_id": 3997}}}, "4651069": {"Id": "4651069", "PostTypeId": "2", "Body": "<p>They are functionally the same. You should use the second method <strong>and pass a parameter for the length of the array</strong>.</p>\n<p>Otherwise, you are asking for trouble:</p>\n<pre><code>// this will compile without warning, even if using -Wall\nint myArray[50] = {0};\nfoo(myArray);\n</code></pre>\n<p>If <code>foo()</code>  assumes that the array is actually 100 elements long, it will overrun the array.</p>\n<p>Better way:</p>\n<pre><code>int foo(int *array, size_t array_len) {\n    // do stuff\n}\n</code></pre>\n<p>Even better, use a <code>vector</code>, which carries its size with it and you cannot (under normal circumstances) access beyond the end of the vector:</p>\n<pre><code>int foo(const std::vector&lt;int&gt;&amp; array) {\n    // do stuff\n}\n</code></pre>\n", "LastActivityDate": "2011-01-10T20:17:34.853", "CommentCount": "2", "CreationDate": "2011-01-10T20:17:34.853", "ParentId": "4650974", "Score": "5", "OwnerUserId": "148146"}, "4651252": {"Id": "4651252", "PostTypeId": "2", "Body": "<p>Nothing, they work in the same way. Here a short example:</p>\n<pre><code>int WithArray(int array[10])\n{\n    return array[1] + array[2];                   // breakpoint 1\n}\n\nint WithPointer(int *pointer)\n{\n    return *(pointer + 1) + *(pointer + 2);       // breakpoint 2\n}\n\nvoid main()\n{\n    int array[] = {0,1,2,3,4,5,6,7,8,9};\n\n    int b = WithPointer(array);\n    int a = WithArray(array);\n\n    printf(\"a = %d\\nb = %d\\n\", a, b);\n}\n</code></pre>\n<p>Ok, I'll call WithPointer() first, just in case WIthArray() copies the array on the stack.\nHere's the stack at the second breakpoint:</p>\n<pre><code>Breakpoint 2, WithPointer (pointer=0xbffff418) at prova.c:10\n10      return *(pointer + 1) + *(pointer + 2);\n(gdb) x/20x ($esp - 8)\n0xbffff404: 0x08049ff4  0xbffff418  0xbffff448  0x0804843b\n0xbffff414: 0xbffff418  0x00000000  0x00000001  0x00000002\n0xbffff424: 0x00000003  0x00000004  0x00000005  0x00000006\n0xbffff434: 0x00000007  0x00000008  0x00000009  0x08048460\n0xbffff444: 0x00000000  0xbffff4c8  0x00144bd6  0x00000001\n</code></pre>\n<p>As expected, there's our pointer (0xbffff418, the first value on the second line) and, right after that, array[] (which is on main()'s stack frame).\nLet's check the stack inside WithArray():</p>\n<pre><code>(gdb) continue\nContinuing.\n\nBreakpoint 1, WithArray (array=0xbffff418) at prova.c:5\n5       return array[1] + array[2];\n(gdb) x/20x ($esp - 8)\n0xbffff404: 0x08049ff4  0xbffff418  0xbffff448  0x08048449\n0xbffff414: 0xbffff418  0x00000000  0x00000001  0x00000002\n0xbffff424: 0x00000003  0x00000004  0x00000005  0x00000006\n0xbffff434: 0x00000007  0x00000008  0x00000009  0x08048460\n0xbffff444: 0x00000003  0xbffff4c8  0x00144bd6  0x00000001\n</code></pre>\n<p>Exactly the same thing! So there's no difference about how they're passed to functions. And they're handled in the same way too, look:</p>\n<pre><code>(gdb) disass WithPointer\nDump of assembler code for function WithPointer:\n   0x080483cc &lt;+0&gt;:  push   %ebp\n   0x080483cd &lt;+1&gt;:  mov    %esp,%ebp\n   0x080483cf &lt;+3&gt;:  mov    0x8(%ebp),%eax         # get base address\n   0x080483d2 &lt;+6&gt;:  add    $0x4,%eax              # compute offset\n   0x080483d5 &lt;+9&gt;:     mov    (%eax),%edx            # dereference and get val.\n   0x080483d7 &lt;+11&gt;:    mov    0x8(%ebp),%eax         # base address\n   0x080483da &lt;+14&gt;:    add    $0x8,%eax              # offset (2 * sizeof(int))\n   0x080483dd &lt;+17&gt;:    mov    (%eax),%eax            # get *eax\n   0x080483df &lt;+19&gt;:    lea    (%edx,%eax,1),%eax     # tricky way to add them\n   0x080483e2 &lt;+22&gt;:    pop    %ebp\n   0x080483e3 &lt;+23&gt;:    ret    \nEnd of assembler dump.\n(gdb) disass WithArray\nDump of assembler code for function WithArray:\n   0x080483b4 &lt;+0&gt;:     push   %ebp\n   0x080483b5 &lt;+1&gt;:     mov    %esp,%ebp\n   0x080483b7 &lt;+3&gt;:     mov    0x8(%ebp),%eax         # first element of array\n   0x080483ba &lt;+6&gt;:     add    $0x4,%eax              # move to the second\n   0x080483bd &lt;+9&gt;:     mov    (%eax),%edx            # and get its value\n   0x080483bf &lt;+11&gt;:    mov    0x8(%ebp),%eax         # base of array\n   0x080483c2 &lt;+14&gt;:    add    $0x8,%eax              # compute address of second\n   0x080483c5 &lt;+17&gt;:    mov    (%eax),%eax            # element and get load it\n   0x080483c7 &lt;+19&gt;:    lea    (%edx,%eax,1),%eax     # compute sum\n   0x080483ca &lt;+22&gt;:    pop    %ebp\n   0x080483cb &lt;+23&gt;:    ret    \nEnd of assembler dump.\n</code></pre>\n<p>Codes are identical. Note that the array is handled as a pointer.</p>\n", "LastEditorUserId": "521776", "LastActivityDate": "2011-01-11T13:33:37.873", "Score": "2", "CreationDate": "2011-01-10T20:35:05.680", "ParentId": "4650974", "CommentCount": "0", "LastEditDate": "2011-01-11T13:33:37.873", "OwnerUserId": "521776"}, "4651116": {"Id": "4651116", "PostTypeId": "2", "Body": "<p>No difference with this declaration</p>\n<pre><code>int foo(int array[100]) //1\nint foo(int array[]) //2\nint foo(int *array) //3\n</code></pre>\n<p>If function can take only fixed sized array, in this case 100 elements, 1 version are more clear to programer which use this function. In all other cases - 3 are good choice</p>\n", "LastEditorUserId": "563732", "LastActivityDate": "2011-01-10T20:47:35.320", "Score": "1", "CreationDate": "2011-01-10T20:21:37.320", "ParentId": "4650974", "CommentCount": "2", "LastEditDate": "2011-01-10T20:47:35.320", "OwnerUserId": "563732"}});