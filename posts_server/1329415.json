post_cb({"1329442": {"ParentId": "1329415", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>You could pass the address of the first element, for example:</p>\n<pre><code>#include &lt;vector&gt;\n\nvoid fun(const double data[])\n{\n\n}\n\nint main()\n{\n    std::vector&lt;std::vector&lt;std::vector&lt;double&gt; &gt; &gt; data3d;\n    ....\n    fun(&amp;data3d[0][0][0]);\n}\n</code></pre>\n<hr>\n<p>The elements of <code>vector</code> are stored contiguously. So this way is standard as I hope :)</p>\n<blockquote>\n<p id=\"so_1329415_1329442_0\"><code>23.2.4 Class template vector</code> </p>\n<p id=\"so_1329415_1329442_1\">1 A vector is a kind of\n  sequence that supports random access\n  iterators. In addition, it supports\n  (amortized) constant time insert and\n  erase operations at the end; insert\n  and erase in the middle take linear\n  time. Storage management is handled\n  automatically, though hints can be\n  given to improve efficiency. The\n  <code>elements of a vector are stored</code>\n<strong>contiguously</strong>, meaning that if <code>v</code> is a\n  vector where T is some\n  type other than bool, then it obeys\n  the identity:</p>\n</blockquote>\n<pre><code>&amp;v[n] == &amp;v[0] + n for\nall 0 &lt;= n &lt; v.size().\n</code></pre>\n</hr>", "OwnerUserId": "127893", "LastEditorUserId": "127893", "LastEditDate": "2009-08-25T16:45:49.807", "Id": "1329442", "Score": "8", "CreationDate": "2009-08-25T16:35:51.747", "LastActivityDate": "2009-08-25T16:45:49.807"}, "1329570": {"ParentId": "1329415", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>This cries out for a general solution.</p>\n<pre><code>template&lt;typename T, typename A&gt;\nT* PointerOf(std::vector&lt;T,A&gt; &amp; vec)\n{\n    return &amp;vec.at(0);\n}\n\ntemplate&lt;typename T, typename A&gt;\nconst T* ConstPointerOf(const std::vector&lt;T,A&gt; &amp; vec)\n{\n    return &amp;vec.at(0);\n}\n\nmyfun(ConstPointerOf(mdata[s][i]));\n</code></pre>\n<p><em>Edit:</em> I added the template parameter for the vector allocator as suggested in the comments; I also used at() instead of [] so I wouldn't have to check for an empty vector, and I added a second version of the function for a const pointer.</p>\n", "OwnerUserId": "5987", "LastEditorUserId": "5987", "LastEditDate": "2009-08-25T19:34:19.467", "Id": "1329570", "Score": "5", "CreationDate": "2009-08-25T16:59:03.743", "LastActivityDate": "2009-08-25T19:34:19.467"}, "1329415": {"CommentCount": "1", "ViewCount": "2850", "PostTypeId": "1", "LastEditorUserId": "152439", "CreationDate": "2009-08-25T16:31:17.573", "LastActivityDate": "2009-09-22T13:31:53.083", "Title": "how to pass a stl vector to a function which takes a const [] (c++)", "AcceptedAnswerId": "1460123", "LastEditDate": "2009-08-25T18:20:52.907", "Id": "1329415", "Score": "2", "Body": "<p>i have a 3d stl vector,</p>\n<pre><code>vector&lt;vector&lt;vector&lt;double&gt; &gt; &gt; mdata;\n</code></pre>\n<p>i also have a function</p>\n<pre><code>myfun(const double ya[]);\n</code></pre>\n<p>to be more precise, it's a function from the GNU Scientific Library,</p>\n<pre><code>gsl_spline_init(gsl_spline * spline, const double xa[], const double ya[], size_t size);\n</code></pre>\n<p>but this is not related to my problem.</p>\n<p>so now i want to pass the 'last' dimension of data to myfun. i've been trying this:</p>\n<pre><code>for (int s = 0; s &lt; msize; s++) {\n    accelerators = new gsl_interp_accel*[msize];\n    splines = new gsl_spline*[msize];\n    for (int i = 0; i &lt; msize; i++) {\n        accelerators[i] = gsl_interp_accel_alloc();\n        splines[i] = gsl_spline_alloc(gsl_interp_cspline_periodic, msize+1);\n        gsl_spline_init(splines[i], &amp;(*mgrid.begin()), &amp;(*mdata[s][i].begin()), msize+1);\n    }\n}\n</code></pre>\n<p>But the compiler (g++, 64bit, Ubuntu), complains:</p>\n<blockquote>\n<p id=\"so_1329415_1329415_0\">In member function\n  \u2018<code>std::vector&lt;std::vector&lt;std::vector&lt;double,\n  std::allocator&lt;double&gt; &gt;,\n  std::allocator&lt;std::vector&lt;double,\n  std::allocator&lt;double&gt; &gt; &gt; &gt;,\n  std::allocator&lt;std::vector&lt;std::vector&lt;double,\n  std::allocator&lt;double&gt; &gt;,\n  std::allocator&lt;std::vector&lt;double,\n  std::allocator&lt;double&gt; &gt; &gt; &gt; &gt; &gt;\n  SimpleAmfCalculator::interp_m(int)</code>\u2019:\n  Calculator.cpp:100: error: cannot\n  convert \u2018<code>std::vector&lt;double,\n  std::allocator&lt;double&gt; &gt;*</code>\u2019 to \u2018<code>const\n  double*</code>\u2019 for argument \u20183\u2019 to \u2018<code>int\n  gsl_spline_init(gsl_spline*, const\n  double*, const double*, size_t)</code>\u2019 make:\n  *** [Calculator.o] Error 1</p>\n</blockquote>\n<p>Any help is greatly apprecitated!</p>\n", "Tags": "<c++><function><vector><const>", "OwnerUserId": "152439", "AnswerCount": "4"}, "1329437": {"ParentId": "1329415", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I think</p>\n<pre><code>&amp;(*mdata[s][i].begin());\n</code></pre>\n<p>is returning a <code>std:vector</code> of type <code>double</code>.</p>\n", "OwnerUserId": "157892", "LastEditorUserId": "157892", "LastEditDate": "2009-08-25T16:47:12.893", "Id": "1329437", "Score": "0", "CreationDate": "2009-08-25T16:34:51.687", "LastActivityDate": "2009-08-25T16:47:12.893"}, "1460123": {"ParentId": "1329415", "CommentCount": "0", "Body": "<p>So, the following seems to work for me:</p>\n<pre><code>#include &lt;vector&gt;\n\nvoid fun(const double data[])\n{\n\n}\n\nint main()\n{\n    std::vector&lt;std::vector&lt;std::vector&lt;double&gt; &gt; &gt; data3d;\n    ....\n    fun(&amp;(data3d[0][0].front()));\n}\n</code></pre>\n", "OwnerUserId": "152439", "PostTypeId": "2", "Id": "1460123", "Score": "0", "CreationDate": "2009-09-22T13:31:53.083", "LastActivityDate": "2009-09-22T13:31:53.083"}, "bq_ids": {"n4140": {"so_1329415_1329442_1": {"section_id": 955, "quality": 0.9375, "length": 45}}, "n3337": {"so_1329415_1329442_1": {"section_id": 943, "quality": 0.9375, "length": 45}}, "n4659": {"so_1329415_1329442_1": {"section_id": 1016, "quality": 0.5416666666666666, "length": 26}}}});