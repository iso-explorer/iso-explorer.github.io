post_cb({"9456754": {"Id": "9456754", "PostTypeId": "2", "Body": "<p>You can catch it like any other exception:</p>\n<pre><code>try {\n  foo();\n}\ncatch (const std::bad_alloc&amp;) {\n  return -1;\n}\n</code></pre>\n<p>Quite what you can usefully do from this point is up to you, but it's definitely feasible technically.</p>\n", "LastEditorUserId": "168175", "LastActivityDate": "2014-05-15T16:50:57.930", "Score": "25", "CreationDate": "2012-02-26T20:15:35.983", "ParentId": "9456728", "CommentCount": "0", "OwnerUserId": "168175", "LastEditDate": "2014-05-15T16:50:57.930"}, "9456728": {"ViewCount": "89057", "Body": "<p>There is a method called <code>foo</code> that sometimes returns the following error:</p>\n<pre class=\"lang-none prettyprint-override\"><code>terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\nAbort\n</code></pre>\n<p>Is there a way that I can use a <code>try</code>-<code>catch</code> block to stop this error from terminating my program (all I want to do is return <code>-1</code>)?</p>\n<p>If so, what is the syntax for it?</p>\n<p>How else can I deal with <code>bad_alloc</code> in C++?</p>\n", "AcceptedAnswerId": "9456754", "Title": "How to deal with bad_alloc in C++?", "CreationDate": "2012-02-26T20:12:50.523", "Id": "9456728", "CommentCount": "4", "FavoriteCount": "17", "PostTypeId": "1", "LastEditDate": "2015-05-14T10:27:31.040", "LastEditorUserId": "608639", "LastActivityDate": "2017-05-03T11:11:04.173", "Score": "39", "OwnerUserId": "1174719", "Tags": "<c++><memory-management><bad-alloc>", "AnswerCount": "6"}, "9456758": {"Id": "9456758", "PostTypeId": "2", "Body": "<p>In general you <em>cannot</em> and <strong>should not try</strong> to respond to this error. <code>bad_alloc</code> indicates that a resource cannot be allocated because not enough memory is available. In most scenarios your program cannot hope to cope with that, and terminating soon is the only meaningful behaviour.</p>\n<p>Worse, modern operating systems often over-allocate: <code>malloc</code> and <code>new</code> will always return a valid pointer, even if there is technically no (or not enough) free memory left \u2013\u00a0so <code>std::bad_alloc</code> will never be thrown, or is at least not a reliable sign of memory exhaustion. Instead, attempts to <em>access</em> the allocated memory will then result in an error, which is not catchable.</p>\n<p>The only thing you could do when catching <code>std::bad_alloc</code> is to perhaps log the error, and try to ensure a safe program termination by freeing outstanding resources (but this is done automatically in the normal course of stack unwinding after the error gets thrown if the program uses RAII appropriately).</p>\n<p>In certain cases the program may attempt to free some memory and try again, or use secondary memory (= disk) instead of RAM but these opportunities only exists in very specific scenarios.</p>\n", "LastEditorUserId": "1968", "LastActivityDate": "2014-08-07T06:44:34.993", "Score": "66", "CreationDate": "2012-02-26T20:15:59.920", "ParentId": "9456728", "CommentCount": "20", "OwnerUserId": "1968", "LastEditDate": "2014-08-07T06:44:34.993"}, "9456753": {"Id": "9456753", "PostTypeId": "2", "Body": "<p>I would not suggest this, since <code>bad_alloc</code> means you are <em>out of memory</em>. It would be best to just give up instead of attempting to recover. However here is is the solution you are asking for:</p>\n<pre><code>try {\n    foo();\n} catch ( const std::bad_alloc&amp; e ) {\n    return -1;\n}\n</code></pre>\n", "LastEditorUserId": "2932052", "LastActivityDate": "2014-05-19T07:57:46.793", "Score": "8", "CreationDate": "2012-02-26T20:15:35.733", "ParentId": "9456728", "CommentCount": "5", "OwnerUserId": "283302", "LastEditDate": "2014-05-19T07:57:46.793"}, "bq_ids": {"n4140": {"so_9456728_9459712_0": {"length": 41, "quality": 0.7592592592592593, "section_id": 7178}}, "n3337": {"so_9456728_9459712_0": {"length": 41, "quality": 0.7592592592592593, "section_id": 6922}}, "n4659": {"so_9456728_9459712_0": {"length": 39, "quality": 0.7222222222222222, "section_id": 8686}}}, "22347228": {"Id": "22347228", "PostTypeId": "2", "Body": "<p>Let your <strong>foo program <a href=\"http://www.cplusplus.com/reference/cstdlib/exit/\" rel=\"nofollow\">exit</a></strong> in a controlled way:</p>\n<pre><code>#include &lt;stdlib.h&gt;     /* exit, EXIT_FAILURE */\n\ntry {\n    foo();\n} catch (const std::bad_alloc&amp;) {\n    exit(EXIT_FAILURE);\n}\n</code></pre>\n<p>Then write a <strong>shell program</strong> that calls the actual program. Since the address spaces are separated, the state of your shell program is always well-defined.</p>\n", "LastActivityDate": "2014-03-12T09:35:20.657", "CommentCount": "0", "CreationDate": "2014-03-12T09:35:20.657", "ParentId": "9456728", "Score": "1", "OwnerUserId": "2932052"}, "9459712": {"Id": "9459712", "PostTypeId": "2", "Body": "<h2>What is the C++ Standard specified behavior of <code>new</code> in c++?</h2>\n<p>The usual notion is that if <code>new</code> operator cannot allocate dynamic memory of the requested size, then it should throw an exception of type <code>std::bad_alloc</code>.<br>\nHowever, something more happens even before a <code>bad_alloc</code> exception is thrown:</br></p>\n<p><strong>C++03 Section 3.7.4.1.3:</strong> says   </p>\n<blockquote>\n<p id=\"so_9456728_9459712_0\">An allocation function that fails to allocate storage can invoke the currently installed new_handler(18.4.2.2), if any. [Note: A program-supplied allocation function can obtain the address of the currently installed new_handler using the set_new_handler function (18.4.2.3).] If an allocation function declared with an empty exception-specification (15.4), throw(), fails to allocate storage, it shall return a null pointer. Any other allocation function that fails to allocate storage shall only indicate failure by throw-ing an exception of class std::bad_alloc (18.4.2.1) or a class derived from std::bad_alloc.</p>\n</blockquote>\n<p>Consider the following code sample:   </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\n// function to call if operator new can't allocate enough memory or error arises\nvoid outOfMemHandler()\n{\n    std::cerr &lt;&lt; \"Unable to satisfy request for memory\\n\";\n\n    std::abort();\n}\n\nint main()\n{\n    //set the new_handler\n    std::set_new_handler(outOfMemHandler);\n\n    //Request huge memory size, that will cause ::operator new to fail\n    int *pBigDataArray = new int[100000000L];\n\n    return 0;\n}\n</code></pre>\n<p>In the above example, <code>operator new</code> (most likely) will be unable to allocate space for 100,000,000 integers, and the function <code>outOfMemHandler()</code> will be called, and the program will abort after <a href=\"http://ideone.com/TsciL\" rel=\"noreferrer\">issuing an error message.</a></p>\n<p>As seen here the default behavior of <code>new</code> operator when unable to fulfill a memory request, is to call the <code>new-handler</code> function repeatedly until it can find enough memory or there is no more new handlers. In the above example, unless we call <code>std::abort()</code>, <code>outOfMemHandler()</code> would be <a href=\"http://www.ideone.com/nF4iy\" rel=\"noreferrer\">called repeatedly</a>. Therefore, the handler should either ensure that the next allocation succeeds, or register another handler, or register no handler, or not return (i.e. terminate the program). If there is no new handler and the allocation fails, the operator will throw an exception.</p>\n<h2>What is the <code>new_handler</code> and <code>set_new_handler</code>?</h2>\n<p><code>new_handler</code> is a typedef for a pointer to a function that takes and returns nothing,  and <code>set_new_handler</code> is a function that takes and returns a <code>new_handler</code>. </p>\n<p>Something like:    </p>\n<pre><code>typedef void (*new_handler)();\nnew_handler set_new_handler(new_handler p) throw();\n</code></pre>\n<p>set_new_handler's parameter is a pointer to the function operator <code>new</code> should call if it can't allocate the requested memory. Its return value is a pointer to the previously registered handler function, or null if there was no previous handler.</p>\n<h2>How to handle out of memory conditions in C++?</h2>\n<p>Given the behavior of <code>new</code>a well designed user program should handle out of memory conditions by providing a proper <code>new_handler</code>which does one of the following:   </p>\n<p><strong>Make more memory available:</strong> This may allows the next memory allocation attempt inside operator new's loop to succeed. One way to implement this is to allocate a large block of memory at program start-up, then release it for use in the program the first time the new-handler is invoked.</p>\n<p><strong>Install a different new-handler:</strong> If the current new-handler can't make any more memory available, and of there is another new-handler that can, then the current new-handler can install the other new-handler in its place (by calling <code>set_new_handler</code>). The next time operator new calls the new-handler function, it will get the one most recently installed.</p>\n<p>(A variation on this theme is for a new-handler to modify its own behavior, so the next time it's invoked, it does something different. One way to achieve this is to have the new-handler modify static, namespace-specific, or global data that affects the new-handler's behavior.)</p>\n<p><strong>Uninstall the new-handler:</strong>  This is done by passing a null pointer to <code>set_new_handler</code>. With no new-handler installed, <code>operator new</code> will throw an exception ((convertible to) <code>std::bad_alloc</code>) when memory allocation is unsuccessful.</p>\n<p><strong>Throw an exception</strong> convertible to <code>std::bad_alloc</code>. Such exceptions are not be caught by <code>operator new</code>, but will propagate to the site originating the request for memory.</p>\n<p><strong>Not return:</strong> By calling <code>abort</code> or <code>exit</code>.  </p>\n", "LastActivityDate": "2012-02-27T03:33:02.473", "CommentCount": "2", "CreationDate": "2012-02-27T03:33:02.473", "ParentId": "9456728", "Score": "35", "OwnerUserId": "452307"}, "24185214": {"Id": "24185214", "PostTypeId": "2", "Body": "<p>I may suggest a more simple (and even faster) solution for this. <code>new</code> operator would return null if memory could not be allocated.</p>\n<pre><code>int fv() {\n    T* p = new (std::nothrow) T[1000000];\n    if (!p) return -1;\n    do_something(p);\n    delete p;\n    return 0;\n}\n</code></pre>\n<p>I hope this could help!</p>\n", "LastEditorUserId": "264325", "LastActivityDate": "2017-05-03T11:11:04.173", "Score": "5", "CreationDate": "2014-06-12T13:06:24.153", "ParentId": "9456728", "CommentCount": "0", "OwnerUserId": "2156952", "LastEditDate": "2017-05-03T11:11:04.173"}});