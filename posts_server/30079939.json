post_cb({"30080084": {"ParentId": "30079939", "CommentCount": "0", "Body": "<p>In this case you can treat char* as an array of chars (C-string). Parenthesis is allowed.</p>\n", "OwnerUserId": "4866970", "PostTypeId": "2", "Id": "30080084", "Score": "-1", "CreationDate": "2015-05-06T14:45:16.833", "LastActivityDate": "2015-05-06T14:45:16.833"}, "30080142": {"ParentId": "30079939", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Array accessors <code>[]</code> are allowed for pointer types, and result in defined and predictable behaviors if the offset inside <code>[]</code> refers to valid memory.</p>\n<pre><code>const char* ptr = str.c_str();\nif (ptr[2] == '2') {\n    ...\n}\n</code></pre>\n<p>Is correct on all platforms <em>if</em> the length of <code>str</code> is 3 characters or more.</p>\n<hr>\n<p>In general, if you are not mutating the <code>char*</code> you are looking at, it best to avoid a <code>const_cast</code> and work with a <code>const char*</code>. Also note that <code>std::string</code> provides <code>operator[]</code> which means that you do not need to call <code>.c_str()</code> on <code>str</code> to be able to index into it and look at a <code>char</code>. This will similarly be correct on all platforms <em>if</em> the length of <code>str</code> is 3 characters or more. If you do not know the length of the string in advance, use <code>std::string::at(size_t pos)</code>, which performs bound checking and throws an <code>out_of_range</code> exception if the check fails.</p>\n</hr>", "OwnerUserId": "864313", "LastEditorUserId": "864313", "LastEditDate": "2015-05-07T13:48:51.003", "Id": "30080142", "Score": "3", "CreationDate": "2015-05-06T14:47:31.407", "LastActivityDate": "2015-05-07T13:48:51.003"}, "30080323": {"ParentId": "30079939", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You can access the ith element in a <code>std::string</code> using its <code>operator[]()</code> like this:</p>\n<pre><code>std::string a_value = \"abcd\";\nif (a_value[2] == 'b')\n{\n  // do stuff\n}\n</code></pre>\n<p>If you use a C++11 conformant <code>std::string</code> implementation you can also use:</p>\n<pre><code>std::string a_value = \"abcd\";\nchar const * p = &amp;a_value[0];\n// or char const * p = a_value.data();\n// or char const * p = a_value.c_str();\n// or char * p = &amp;a_value[0];\n</code></pre>\n<blockquote>\n<p id=\"so_30079939_30080323_0\"><strong>21.4.1/5</strong> </p>\n<p id=\"so_30079939_30080323_1\">The char-like objects in a basic_string object shall be stored contiguously.</p>\n<p id=\"so_30079939_30080323_2\"><strong>21.4.7.1/1: c_str() / data()</strong></p>\n<p id=\"so_30079939_30080323_3\">Returns: A pointer p such that <code>p + i == &amp;operator[](i)</code> for each i in [0,size()].</p>\n</blockquote>\n", "OwnerUserId": "951423", "LastEditorUserId": "951423", "LastEditDate": "2015-05-06T22:46:01.720", "Id": "30080323", "Score": "3", "CreationDate": "2015-05-06T14:53:57.210", "LastActivityDate": "2015-05-06T22:46:01.720"}, "30081049": {"ParentId": "30079939", "CommentCount": "0", "Body": "<p>Everyone explained very well for most how it's safe, but i'd like to extend a bit if that's ok.</p>\n<p>Since you're in C++, and you're using a string, you can simply do the following to access a caracter (and you won't have any trouble, and you still won't have to deal with cstrings in cpp :</p>\n<pre><code>  std::string a_value = \"abcd\";\n  std::cout &lt;&lt; a_value.at(2);\n</code></pre>\n<p>Which is in my opinion a better option rather than going out of the way.\nstring::at will return a char &amp; or a const char&amp;  depending on your string object. (In this case, a const char &amp;)</p>\n", "OwnerUserId": "4117075", "PostTypeId": "2", "Id": "30081049", "Score": "0", "CreationDate": "2015-05-06T15:23:19.420", "LastActivityDate": "2015-05-06T15:23:19.420"}, "30079939": {"CommentCount": "10", "ViewCount": "90", "PostTypeId": "1", "LastEditorUserId": "4264897", "CreationDate": "2015-05-06T14:39:31.137", "LastActivityDate": "2015-05-07T13:48:51.003", "Title": "Character pointer access", "AcceptedAnswerId": "30080142", "LastEditDate": "2015-05-06T14:45:05.470", "Id": "30079939", "Score": "-1", "Body": "<p>I wanted to access character pointer ith element. Below is the sample code</p>\n<pre><code>string a_value = \"abcd\";\nchar *char_p=const_cast&lt;char *&gt;(a_value.c_str());\n\nif(char_p[2] == 'b') //Is this safe to use across all platform?\n{\n  //do soemthing\n}\n</code></pre>\n<p>Thanks in advance</p>\n", "Tags": "<c++><character>", "OwnerUserId": "4264897", "AnswerCount": "5"}, "30080271": {"ParentId": "30079939", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The question is essentially about querying characters in a string safely.</p>\n<pre><code>const char* a = a_value.c_str();\n</code></pre>\n<p>is safe unless some other operation modifies the string after it. If you can guarantee that no other code performs a modification prior to using a, then you have safely retrieved a pointer to a null-terminated string of characters.</p>\n<pre><code>char* a = const_cast&lt;char *&gt;(a_value.c_str());\n</code></pre>\n<p>is never safe. You have yielded a pointer to memory that is writeable. However, that memory was never designed to be written to. There is no guarantee that writing to that memory will actually modify the string (and actually no guarantee that it won't cause a core dump). It's undefined behaviour - absolutely unsafe.\nreference here: <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/c_str\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/string/basic_string/c_str</a></p>\n<p>addressing <code>a[2]</code> is safe provided you can prove that all possible code paths ensure that a represents a pointer to memory longer than 2 chars.</p>\n<p>If you want safety, use either:</p>\n<pre><code>auto ch = a_string.at(2); // will throw an exception if a_string is too short.\n</code></pre>\n<p>or</p>\n<pre><code>if (a_string.length() &gt; 2) {\n    auto ch = a_string[2];\n}\nelse {\n    // do something else\n}\n</code></pre>\n", "OwnerUserId": "2015579", "LastEditorUserId": "2015579", "LastEditDate": "2015-05-06T15:07:01.633", "Id": "30080271", "Score": "1", "CreationDate": "2015-05-06T14:51:45.023", "LastActivityDate": "2015-05-06T15:07:01.633"}, "bq_ids": {"n4140": {"so_30079939_30080323_1": {"section_id": 1566, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_30079939_30080323_1": {"section_id": 1561, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_30079939_30080323_1": {"section_id": 1708, "quality": 0.5714285714285714, "length": 4}}}});