post_cb({"43550283": {"Id": "43550283", "PostTypeId": "2", "Body": "<p>Based on your comments, it seems you want to perform a <em>bona fide</em> conversion -- that is, to produce a distinct, new, separate value of a different type.  This is a very different thing than a <em>reinterpretation</em>, such as the lead-in to your question suggests you wanted.  In particular, you posit variables declared like this:</p>\n<pre><code>uint8x16_t  a;\nuint8x8x2_t b;\n\n// code to set the value of a ...\n</code></pre>\n<p>and you want to know how to set the value of <code>b</code> so that it is in some sense equivalent to the value of <code>a</code>.</p>\n<h2>Speaking to the C language:</h2>\n<p>The strict aliasing rule (<a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.5p7\" rel=\"nofollow noreferrer\">C2011 6.5/7</a>) says,</p>\n<blockquote>\n<p id=\"so_43521206_43550283_0\">An object shall have its stored value accessed only by an lvalue\n  expression that has one of the following types:</p>\n<ul>\n<li>a type compatible with the <em>effective type</em> of the object, [...]</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its members [...], or</li>\n<li>a character type.</li>\n</ul>\n</blockquote>\n<p>(Emphasis added. Other enumerated options involve differently-qualified and differently-signed versions of the of the effective type of the object or compatible types; these are not relevant here.)</p>\n<p>Note that these provisions <em>never</em> interfere with accessing <code>a</code>'s value, including the member value, via variable <code>a</code>, and similarly for <code>b</code>.  But don't overlook overlook the usage of the term \"effective type\" -- this is where things can get bolluxed up under slightly different circumstances.  More on that later.</p>\n<h3>Using a union</h3>\n<p>C certainly permits you to perform a conversion via an intermediate <code>union</code>, or you could rely on <code>b</code> being a union member in the first place so as to remove the \"intermediate\" part:</p>\n<pre><code>union {\n    uint8x16_t  x1;\n    uint8x8_2_t x2;\n} temp;\ntemp.x1 = a;\nb = temp.x2;\n</code></pre>\n<h3>Using a typecast pointer (to produce UB)</h3>\n<p>However, although it's not so uncommon to see it, C does not permit you to type-pun via a pointer:</p>\n<pre><code>// UNDEFINED BEHAVIOR - strict-aliasing violation\n    b = *(uint8x8x2_t *)&amp;a;\n// DON'T DO THAT\n</code></pre>\n<p>There, you are accessing the value of <code>a</code>, whose effective type is <code>uint8x16_t</code>, via an lvalue of type <code>uint8x8x2_t</code>.  Note that it is not the cast that is forbidden, nor even, I'd argue, the dereferencing -- it is <em>reading</em> the dereferenced value so as to apply the side effect of the <code>=</code> operator.</p>\n<h3>Using <code>memcpy()</code></h3>\n<p>Now, what about <code>memcpy()</code>?  This is where it gets interesting.  C permits the stored values of <code>a</code> and <code>b</code> to be accessed via lvalues of character type, and although its arguments are declared to have type <code>void *</code>, this is the only plausible interpretation of how <code>memcpy()</code> works.  Certainly <a href=\"http://port70.net/~nsz/c/c11/n1570.html#7.24.2.1p2\" rel=\"nofollow noreferrer\">its description</a> characterizes it as copying <em>characters</em>.  There is therefore nothing wrong with performing a</p>\n<pre><code>memcpy(&amp;b, &amp;a, sizeof a);\n</code></pre>\n<p>Having done so, you may freely access the value of <code>b</code> via variable <code>b</code>, as already mentioned.  There are aspects of doing so that could be problematic in a more general context, but there's no UB here.</p>\n<p><strong><em>However</em></strong>, contrast this with the superficially similar situation in which you want to put the converted value into dynamically-allocated space:</p>\n<pre><code>uint8x8x2_t *c = malloc(sizeof(*c));\nmemcpy(c, &amp;a, sizeof a);\n</code></pre>\n<p>What could be wrong with that?  Nothing is wrong with it, as far as it goes, but here you have UB if you afterward you try to access the value of <code>*c</code>.  Why?  because the memory to which <code>c</code> points does not have a declared type, therefore its <em>effective type</em> is the effective type of whatever was last stored in it (if that has an effective type), including if that value was copied into it via <code>memcpy()</code> (<a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.5p6\" rel=\"nofollow noreferrer\">C2011 6.5/6</a>).  As a result, the object to which <code>c</code> points has effective type <code>uint8x16_t</code> after the copy, whereas the expression <code>*c</code> has type <code>uint8x8x2_t</code>; the strict aliasing rule says that accessing that object via that lvalue produces UB.</p>\n", "LastEditorUserId": "2402272", "LastActivityDate": "2017-04-24T15:20:10.150", "Score": "6", "CreationDate": "2017-04-21T19:09:52.417", "ParentId": "43521206", "CommentCount": "3", "OwnerUserId": "2402272", "LastEditDate": "2017-04-24T15:20:10.150"}, "bq_ids": {"n4140": {"so_43521206_43549526_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 7200}, "so_43521206_43550283_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 7230}, "so_43521206_43549526_1": {"length": 15, "quality": 0.9375, "section_id": 7200}}, "n3337": {"so_43521206_43549526_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 6944}, "so_43521206_43550283_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 6974}, "so_43521206_43549526_1": {"length": 15, "quality": 0.9375, "section_id": 6944}}, "n4659": {"so_43521206_43549526_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 8709}, "so_43521206_43549526_1": {"length": 14, "quality": 0.875, "section_id": 8709}}}, "43549526": {"Id": "43549526", "PostTypeId": "2", "Body": "<p>It's <em>completely</em> legal in C++ to type pun via pointer casting, as long as you're only doing it to <code>char*</code>. This, not coincidentally, is what <code>memcpy</code> is defined as working on (technically <code>unsigned char*</code> which is good enough).</p>\n<p>Kindly observe the following passage:</p>\n<blockquote>\n<p id=\"so_43521206_43549526_0\">For any object (other than a base-class subobject) of trivially\n  copyable type T, whether or not the object holds a valid value of type\n  T, the underlying bytes (1.7) making up the object can be copied into\n  an array of char or unsigned char.</p>\n<p id=\"so_43521206_43549526_1\">42 If the content of the array of char or unsigned char is copied back\n  into the object, the object shall subsequently hold its original\n  value. [Example:</p>\n<pre><code>#define N sizeof(T)\nchar buf[N];\nT obj;\n// obj initialized to its original value\nstd::memcpy(buf, &amp;obj, N);\n// between these two calls to std::memcpy,\n// obj might be modified \nstd::memcpy(&amp;obj, buf, N);\n// at this point, each subobject of obj of scalar type\n// holds its original value\n</code></pre>\n<p id=\"so_43521206_43549526_2\">\u2014 end example ]</p>\n</blockquote>\n<p>Put simply, copying like this is the intended function of <code>std::memcpy</code>. As long as the types you're dealing with meet the necessary triviality requirements, it's totally legit.</p>\n<p>Strict aliasing does <em>not</em> include <code>char*</code> or <code>unsigned char*</code>- you are free to alias any type with these.</p>\n<p>Note that for unsigned ints specifically, you have some very explicit leeway here. The C++ Standard requires that they meet the requirements of the C Standard. The C Standard mandates the format. The only way that trap representations or anything like that can be involved is if your implementation has any padding bits, but ARM does not have any- 8bit bytes, 8bit and 16bit integers. So for unsigned integers on implementations with zero padding bits, any byte is a valid unsigned integer.</p>\n<blockquote>\n<p id=\"so_43521206_43549526_3\">For  unsigned  integer  types  other  than unsigned  char,  the  bits \n  of  the  object representation  shall  be  divided  into  two groups: \n  value  bits  and  padding  bits  (there  need not  be  any  of  the \n  latter).   If  there  are N value  bits,  each  bit  shall  represent \n  a  different power  of  2  between  1  and  2N\u22121,  so  that  objects \n  of  that  type  shall  be  capable  of representing  values  from  0 \n  to  2N\u22121  using  a  pure  binary  representation;  this  shall  be\n  known as the value representation.  The values of any padding bits are\n  unspecified.</p>\n</blockquote>\n", "LastEditorUserId": "298661", "LastActivityDate": "2017-04-23T10:29:32.627", "Score": "6", "CreationDate": "2017-04-21T18:18:54.470", "ParentId": "43521206", "CommentCount": "10", "OwnerUserId": "298661", "LastEditDate": "2017-04-23T10:29:32.627"}, "43521206": {"ViewCount": "1010", "Body": "<p>I recently discovered about the <a href=\"https://stackoverflow.com/a/43519190/2436175\">vreinterpret{q}_dsttype_srctype casting operator</a>. However this doesn't seem to support conversion in the data type described at <a href=\"http://infocenter.arm.com/help/topic/com.arm.doc.dui0491f/BABFBJAA.html\" rel=\"nofollow noreferrer\">this link</a> (bottom of the page):</p>\n<blockquote>\n<p id=\"so_43521206_43521206_0\">Some intrinsics use an array of vector types of the form:</p>\n<p id=\"so_43521206_43521206_1\"><code>&lt;type&gt;&lt;size&gt;x&lt;number of lanes&gt;x&lt;length of array&gt;_t</code></p>\n<p id=\"so_43521206_43521206_2\">These types are treated as ordinary C structures containing a single\n  element named val.</p>\n<p id=\"so_43521206_43521206_3\">An example structure definition is:</p>\n<pre><code>struct int16x4x2_t    \n{\n    int16x4_t val[2];     \n};\n</code></pre>\n</blockquote>\n<p>Do you know how to convert from <code>uint8x16_t</code> to <code>uint8x8x2_t</code>?</p>\n<p>Note that that the problem <a href=\"https://stackoverflow.com/a/29209307/2436175\">cannot be reliably addressed using union</a> (reading from inactive members leads to undefined behaviour <strong>Edit:</strong> That's only the case for C++, while it turns out that <a href=\"https://stackoverflow.com/a/11640603/2436175\"><strong>C allows type punning</strong></a>), nor by <a href=\"https://stackoverflow.com/q/29253100/2436175\">using pointers to cast</a> (breaks the strict aliasing rule).</p>\n", "AcceptedAnswerId": "43550283", "Title": "ARM Neon: How to convert from uint8x16_t to uint8x8x2_t?", "CreationDate": "2017-04-20T13:38:13.533", "Id": "43521206", "CommentCount": "57", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:10:02.173", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-24T15:20:10.150", "Score": "5", "OwnerUserId": "2436175", "Tags": "<c++><c><arm><vectorization><neon>", "AnswerCount": "3"}, "43561503": {"Id": "43561503", "PostTypeId": "2", "Body": "<p>So there are a bunch of gotchas here.  This reflects C++.</p>\n<p>First you can convert trivially copyable data to <code>char*</code> or <code>unsigned char*</code> or <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b17\" rel=\"tag\" title=\"show questions tagged 'c++17'\">c++17</a> <code>std::byte*</code>, then copy it from one location to another.  The result is defined behavior.  The values of the bytes are <em>unspecified</em>.</p>\n<p>If you do this from a value of one one type to another via something like <code>memcpy</code>, this can result in undefined behaviour upon access of the target type <em>unless the target type has valid values for all byte representations</em>, or if the layout of the two types is specified by your compiler.</p>\n<p>There is the possibility of \"trap representations\" in the target type -- byte combinations that result in machine exceptions or something similar if interpreted as a value of that type.  Imagine a system that doesn't use IEEE floats and where doing math on NaN or INF or the like causes a segfault.</p>\n<p>There are also alignment concerns.</p>\n<p>In C, I believe that type punning via unions is legal, with similar qualifications.</p>\n<p>Finally, note that under a strict reading of the <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> standard, <code>foo* pf = (foo*)malloc(sizeof(foo));</code> is not a pointer to a <code>foo</code> even if <code>foo</code> was plain old data.  You must create an object before interacting with it, and the only way to create an object outside of automatic storage is via <code>new</code> or placement <code>new</code>.  This means you must have data of the target type before you memcpy into it.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2017-04-24T13:55:18.207", "Score": "2", "CreationDate": "2017-04-22T16:14:06.387", "ParentId": "43521206", "CommentCount": "1", "OwnerUserId": "1774667", "LastEditDate": "2017-04-24T13:55:18.207"}});