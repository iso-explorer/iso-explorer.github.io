post_cb({"28770641": {"Id": "28770641", "PostTypeId": "2", "Body": "<p>Like this:</p>\n<pre><code>void (Buf&amp; buf)\n{\n    int len = buf.size();\n    somefunction(&amp;buf[0], &amp;len);\n    // ...\n}\n</code></pre>\n", "LastActivityDate": "2015-02-27T17:14:38.817", "CommentCount": "3", "CreationDate": "2015-02-27T17:14:38.817", "ParentId": "28770352", "Score": "0", "OwnerUserId": "65863"}, "28770712": {"Id": "28770712", "PostTypeId": "2", "Body": "<p>To pass a <code>std::vector&lt;char&gt;</code> to a function that expects a <code>char *</code>, you can</p>\n<p>1) Pass the address of the first element in the vector.  The only caveat is that using this method requires that the vector is not empty.</p>\n<pre><code>if (!buf.empty())\n   somefunction(&amp;buf[0], buf.size());\n</code></pre>\n<p>2) If using <code>C++ 11</code> use the <code>data()</code> method for the vector.  In C++ 11, using <code>data</code> guarantees that it will work with an empty vector.</p>\n<pre><code>   somefunction(buf.data(), buf.size());\n</code></pre>\n", "LastEditorUserId": "3133316", "LastActivityDate": "2015-02-27T17:24:28.483", "Score": "1", "CreationDate": "2015-02-27T17:18:12.013", "ParentId": "28770352", "CommentCount": "0", "OwnerUserId": "3133316", "LastEditDate": "2015-02-27T17:24:28.483"}, "bq_ids": {"n4140": {"so_28770352_28770613_1": {"length": 48, "quality": 0.96, "section_id": 955}}, "n3337": {"so_28770352_28770613_1": {"length": 48, "quality": 0.96, "section_id": 943}}, "n4659": {"so_28770352_28770613_1": {"length": 27, "quality": 0.54, "section_id": 1016}}}, "28770613": {"Id": "28770613", "PostTypeId": "2", "Body": "<pre><code>int len = buf.size();\nsomefunction(&amp;buf[0], &amp;len);\n</code></pre>\n<p>You can do that because (From n2798 (draft of C++0x)):</p>\n<blockquote>\n<p id=\"so_28770352_28770613_0\"><strong>23.2.6 Class template vector [vector]</strong></p>\n<p id=\"so_28770352_28770613_1\">1 A vector is a sequence container that supports random access iterators. In addition, it supports (amortized)\n  constant time insert and erase operations at the end; insert and erase in the middle take linear time. Storage\n  management is handled automatically, though hints can be given to improve efficiency. <strong><em>The elements of a\n  vector are stored contiguously, meaning that if v is a vector where T is some type other\n  than bool, then it obeys the identity &amp;v[n] == &amp;v[0] + n for all 0 &lt;= n &lt; v.size()</em></strong>.</p>\n</blockquote>\n", "LastEditorUserId": "65863", "LastActivityDate": "2015-02-27T17:23:55.337", "Score": "0", "CreationDate": "2015-02-27T17:12:29.773", "ParentId": "28770352", "CommentCount": "0", "OwnerUserId": "238671", "LastEditDate": "2015-02-27T17:23:55.337"}, "28770352": {"ViewCount": "499", "Body": "<p>I have a library function from which I should pass same data types to the main application .</p>\n<p>Thus my question is - how do I pass <code>a std::vector&lt;char&gt;</code> to a C style function that expects <code>char*</code>. Here is what I have tried</p>\n<pre><code>// function to apply on char\nvoid somefunction (char* c_buf, int* c_buf_len)\n// main function \ntypedef std::vector&lt;char&gt; Buf;\nvoid (Buf&amp; buf)\n{\n\n    // first convert `buf` to char and call function \n    somefunction(char_buf, char_buf_len)\n    // Now convert buf to vector and do something with it..\n}\n</code></pre>\n", "Title": "convert std vector to char and viceversa", "CreationDate": "2015-02-27T16:59:38.493", "Id": "28770352", "CommentCount": "7", "LastEditDate": "2015-02-27T17:19:50.800", "PostTypeId": "1", "LastEditorUserId": "238671", "LastActivityDate": "2015-02-27T17:24:28.483", "Tags": "<c++>", "Score": "-3", "OwnerUserId": "4518790", "ClosedDate": "2015-02-27T17:19:16.570", "AnswerCount": "4"}, "28770606": {"Id": "28770606", "PostTypeId": "2", "Body": "<p>You cannot convert a vector to <code>char</code>. They're completely unrelated types. Good news is that you seem to need a pointer to a character buffer and a <code>vector&lt;char&gt;</code> is exactly that. You get the pointer to the begginning of its storage by taking the address of the first element (<code>&amp;buf[0]</code>) or by saying <code>buf.data()</code>. <code>buf.size()</code> will give you (you guessed it!) the size of the buffer. That's all you need to call <code>somefunction</code>.</p>\n", "LastActivityDate": "2015-02-27T17:11:59.950", "CommentCount": "2", "CreationDate": "2015-02-27T17:11:59.950", "ParentId": "28770352", "Score": "2", "OwnerUserId": "947836"}});