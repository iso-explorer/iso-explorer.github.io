post_cb({"bq_ids": {"n4140": {"so_17345680_17843102_0": {"length": 33, "quality": 1.0, "section_id": 1228}}, "n3337": {"so_17345680_17843102_0": {"length": 33, "quality": 1.0, "section_id": 1226}}, "n4659": {"so_17345680_17843102_0": {"length": 33, "quality": 1.0, "section_id": 1317}}}, "17843102": {"Id": "17843102", "PostTypeId": "2", "Body": "<h1>1</h1>\n<p>After pondering over #1 i have been convinced they are not equivalent by this argument <code>\u00a729.8.3</code> in <code>[atomics.fences]</code>:</p>\n<blockquote>\n<p id=\"so_17345680_17843102_0\">A release fence A synchronizes with an atomic operation B that performs an acquire operation on an atomic\n  object M if there exists an atomic operation X such that A is sequenced before X, X modifies M, and B\n  reads the value written by X or a value written by any side effect in the hypothetical release sequence X\n  would head if it were a release operation.</p>\n</blockquote>\n<p>This paragraph says that a release <strong>fence</strong> can be synchronized only with an aquire operation. But release <strong>operation</strong> can be in addition syncronized with consume operation.</p>\n", "LastEditorUserId": "2035105", "LastActivityDate": "2013-07-25T05:40:04.583", "Score": "0", "CreationDate": "2013-07-24T19:25:41.237", "ParentId": "17345680", "CommentCount": "1", "OwnerUserId": "2035105", "LastEditDate": "2013-07-25T05:40:04.583"}, "17345680": {"ViewCount": "1707", "Body": "<p>I read about boost's and std's (c++11) atomic type and operations over and over again and still I'm not sure I understand it right (and at some cases I don't understand it at all). So, I have a few questions about it.</p>\n<p>My sources I use for learning:</p>\n<ul>\n<li>Boost documentation: <a href=\"http://www.boost.org/doc/libs/1_53_0/doc/html/atomic.html\" rel=\"nofollow\">http://www.boost.org/doc/libs/1_53_0/doc/html/atomic.html</a></li>\n<li><a href=\"http://www.developerfusion.com/article/138018/memory-ordering-for-atomic-operations-in-c0x/\" rel=\"nofollow\">http://www.developerfusion.com/article/138018/memory-ordering-for-atomic-operations-in-c0x/</a></li>\n</ul>\n<hr>\n<p>Consider following snippet:</p>\n<pre><code>atomic&lt;bool&gt; x,y;\n\nvoid write_x_then_y()\n{\n    x.store(true, memory_order_relaxed);\n    y.store(true, memory_order_release);\n}\n</code></pre>\n<p>#1: Is it equivalent to this next one?</p>\n<pre><code>atomic&lt;bool&gt; x,y;\n\nvoid write_x_then_y()\n{\n    x.store(true, memory_order_relaxed);\n    atomic_thread_fence(memory_order_release);    // *1\n    y.store(true, memory_order_relaxed);          // *2\n}\n</code></pre>\n<p>#2: Is following statement true?</p>\n<p>Line *1 assures, that when operations done under this line (for example *2) are visible (for other thread using acquire), code above *1 will be visible too (with new values).</p>\n<hr>\n<p>Next snipped extends the ones above:</p>\n<pre><code>void read_y_then_x()\n{\n    if(y.load(memory_order_acquire))\n    {\n        assert(x.load(memory_order_relaxed));\n    }\n}\n</code></pre>\n<p>#3: Is it equivalent to this next one?</p>\n<pre><code>void read_y_then_x()\n{\n    atomic_thread_fence(memory_order_acquire);    // *3\n    if(y.load(memory_order_relaxed))              // *4\n    {\n        assert(x.load(memory_order_relaxed));     // *5\n    }\n}\n</code></pre>\n<p>#4: Are following statements true?</p>\n<ul>\n<li>Line *3 assures that if some operations under release order (in other thread, like *2) is visible, every operation above the release order (for example *1) will be visible as well.</li>\n<li>That means that assert at *5 will never fail (with false as default values).</li>\n<li>But this does not assure that even if physically (in processor) *2 happens before before *3, it will be visible by snipped above (running in different thread) - function read_y_then_x() still can read old values. Only thing which is assured is, that if y is true, x will be also true.</li>\n</ul>\n<hr>\n<p>#5: Incrementing (operation of adding 1) to an atomic integer can be memory_order_relaxed and no data are lost. Only problem is order and time of visibility of result.</p>\n<hr>\n<p>According boost, following snipped is working reference counter:</p>\n<pre><code>#include &lt;boost/intrusive_ptr.hpp&gt;\n#include &lt;boost/atomic.hpp&gt;\n\nclass X {\npublic:\n  typedef boost::intrusive_ptr&lt;X&gt; pointer;\n  X() : refcount_(0) {}\n\nprivate:\n  mutable boost::atomic&lt;int&gt; refcount_;\n  friend void intrusive_ptr_add_ref(const X * x)\n  {\n    x-&gt;refcount_.fetch_add(1, boost::memory_order_relaxed);\n  }\n  friend void intrusive_ptr_release(const X * x)\n  {\n    if (x-&gt;refcount_.fetch_sub(1, boost::memory_order_release) == 1) {\n      boost::atomic_thread_fence(boost::memory_order_acquire);\n      delete x;\n    }\n  }\n};\n</code></pre>\n<p>#6 Why is for decrementing used memory_order_release? How it works (in the context)? If what I wrote earlier is true, what makes returned value the most recent, especially when we use acquire AFTER reading and not before/during?</p>\n<p>#7 Why there is acquire order after reference counter reach zero? We just read that the counter is zero and there is no other atomic variable used (pointer itself is not marked/used as such).</p>\n</hr></hr></hr></hr>", "AcceptedAnswerId": "18756838", "Title": "Understanding atomic variables and operations", "CreationDate": "2013-06-27T14:19:01.533", "Id": "17345680", "CommentCount": "0", "PostTypeId": "1", "OwnerDisplayName": "user1476710", "LastActivityDate": "2013-09-12T19:27:06.703", "Score": "0", "Tags": "<c++><multithreading><atomic><atomicity><memory-fences>", "AnswerCount": "3"}, "18756838": {"Id": "18756838", "PostTypeId": "2", "Body": "<p>1: No.  A release fence synchronizes with all acquire operations and fences.  If there was a third <code>atomic&lt;bool&gt; z</code> which was being manipulated in a third thread, the fence would synchronize with that third thread as well, which is unnecessary.  That being said, they will act the same on x86, but that is because x86 has very strong synchronization.  The architectures used on 1000 core systems tend to be weaker.</p>\n<p>2: Yes, this is correct.  A fence ensures that if you see anything that follows, you also see everything that preceded.</p>\n<p>3: In general they are different, but realistically they will be the same.  The compiler is allowed to reorder two relaxed operations on different variables, but may not introduce spurious operations.  If the compiler has any way of being confident that it is going to need to read x, it may do so before reading y.  In your particular case, this is very difficult for the compiler, but there are many similar cases where such reordering is fair game.</p>\n<p>4: All of those are true.  The atomic operations guarantee consistency.  They do not always guarantee that things happen in an order you wanted, they just prevent pathological orders that ruin your algorithm.</p>\n<p>5: Correct.  Relaxed operations are truly atomic.  They just don't synchronize any additional memory</p>\n<p>6: For any given atomic object <code>M</code>, C++ guarantees that there is an \"official\" order for operations on <code>M</code>.  You don't get to see the \"latest\" value for <code>M</code> so much as C++ and the processor guarantee that all threads will see a consistent series of values for <code>M</code>.  If two threads increment the refcount, then decrement it, there is no guarentee which one will decrement it to 0, but there is a guarentee that one of them will see that it decremented it to 0.  There is no way for both of them to see that they decremented 2-&gt;1 and 2-&gt;1, but somehow the refcount combined them to 0.  One thread will always see 2-&gt;1 and the other will see 1-&gt;0.</p>\n<p>Remember, memory order is more about synchronizing the memory around the atomic.  The atomic gets handled properly no matter what memory order you use.</p>\n<p>7: This one is trickier.  The short version for 7 is that decrement is release order because some thread is going to have to run the destructor for x, and we want to make sure it sees all operations on x made on all threads.  Using release order on the destructor satisfies this need because you can prove that it works.  Whoever is responsible for deleting x acquires all changes before doing so (using a fence to make sure atomics in the deleter don't drift upward).  In all cases where threads release their own references, it is obvious that all threads will have a release-order decrement before the deleter gets called.  In cases where one thread increments the refcount and another decrements it, you can prove that the only valid way to do so is if the threads synchronize with eachother, so that the destructor sees the result of both threads.  Failure to synchronize would create a race case no matter what, so the user is obliged to get it right.</p>\n", "LastActivityDate": "2013-09-12T06:24:42.050", "CommentCount": "0", "CreationDate": "2013-09-12T06:24:42.050", "ParentId": "17345680", "Score": "1", "OwnerUserId": "2728148"}, "18772805": {"Id": "18772805", "PostTypeId": "2", "Body": "<p>Your void read_y_then_x() with the acquire fence has the fence in the wrong place.  It should be placed between the two atomic loads.  An acquire fence essentially makes all the load above the fence act somewhat like acquire loads, with the exception the happens before isn't established until you executed the fence.</p>\n", "LastActivityDate": "2013-09-12T19:27:06.703", "CommentCount": "0", "CreationDate": "2013-09-12T19:27:06.703", "ParentId": "17345680", "Score": "0", "OwnerUserId": "2364204"}});