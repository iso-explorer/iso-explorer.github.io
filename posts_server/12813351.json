post_cb({"12813351": {"CommentCount": "7", "AcceptedAnswerId": "12815815", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-10-10T06:35:49.240", "LastActivityDate": "2012-10-10T12:45:54.800", "LastEditDate": "2017-05-23T12:16:56.393", "ViewCount": "560", "FavoriteCount": "3", "Title": "sfinae with decltype: bug in clang or gcc?", "Id": "12813351", "Score": "10", "Body": "<p>Clang-3.2 can compile and code behave as expected:</p>\n<pre><code>struct have_f { int f(int i) {return 10;} }; \n\nstruct empty {};\n\ntemplate &lt;class T&gt; \nstruct outer {\n        T t; \n\n        // if T have f(), define  outer_f()\n        template&lt;class U=decltype(t.f(1))&gt; \n        int outer_f(int i) { return t.f(i); }\n};\n\nint main() {\n        outer&lt;have_f&gt;  o1;\n        outer&lt;empty&gt;   o2;\n\n        // to silence unused var warning\n        return  o1.outer_f(10) + sizeof(o2); \n}\n</code></pre>\n<p>GCC of any version rejects with:</p>\n<pre><code>t.cc:13:6: error: \u2018struct empty\u2019 has no member named \u2018f\u2019\n  int outer_f(int i) { return t.f(i); }\n      ^\n</code></pre>\n<p>Who is correct? Gcc or Clang?   </p>\n<p>Note, that there was <a href=\"https://stackoverflow.com/questions/11566564/using-sfinae-gives-different-results-on-gcc-and-clang\">similar question</a>, without real answer. </p>\n", "Tags": "<c++><gcc><c++11><clang><sfinae>", "OwnerUserId": "1173542", "AnswerCount": "1"}, "12815815": {"ParentId": "12813351", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I believe the issue is <strong>14.6.3 [temp.nondep]</strong>:</p>\n<blockquote>\n<p id=\"so_12813351_12815815_0\">1 - Non-dependent names used in a template definition are found using the usual name lookup and bound at the point they are used.</p>\n</blockquote>\n<p>The example given describes that an ill-formed expression within the template definition \"<em>could be diagnosed either [in the template definition] or at the point of instantiation</em>\".</p>\n<p>The default <em>template-argument</em> (14.1p9) <code>U=decltype(t.f(1))</code> is a non-dependent name within the context of the instantiation of <code>struct outer</code> (that is, it does not depend on a template argument to its own template) so it is ill-formed for the instantiation of <code>struct outer</code> with <code>T = struct empty</code>.  The standard doesn't explicitly describe where default template-arguments are evaluated, but the only sensible conclusion is that they are treated as any other construct and evaluated at the point they occur (or, in this example, at the point of instantiation of the <code>struct outer</code> template).  I don't see any latitude for the compiler to delay evaluation of non-dependent default template-arguments to contexts where SFINAE applies.</p>\n<p>Fortunately the solution is easy: just make the default template-argument <code>U</code> a dependent name:</p>\n<pre><code>    // if T have f(), define  outer_f()\n    template&lt;class T2 = T, class U=decltype(static_cast&lt;T2 &amp;&gt;(t).f(1))&gt; \n    int outer_f(int i) { return t.f(i); }\n</code></pre>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2012-10-10T12:45:54.800", "Id": "12815815", "Score": "9", "CreationDate": "2012-10-10T09:11:47.620", "LastActivityDate": "2012-10-10T12:45:54.800"}, "bq_ids": {"n4140": {"so_12813351_12815815_0": {"section_id": 214, "quality": 1.0, "length": 12}}, "n3337": {"so_12813351_12815815_0": {"section_id": 208, "quality": 1.0, "length": 12}}, "n4659": {"so_12813351_12815815_0": {"section_id": 222, "quality": 1.0, "length": 12}}}});