post_cb({"bq_ids": {"n4140": {"so_37731401_38060482_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 175}, "so_37731401_38060482_1": {"length": 7, "quality": 1.0, "section_id": 175}, "so_37731401_38060482_2": {"length": 10, "quality": 1.0, "section_id": 175}}, "n3337": {"so_37731401_38060482_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 169}, "so_37731401_38060482_1": {"length": 7, "quality": 1.0, "section_id": 169}, "so_37731401_38060482_2": {"length": 10, "quality": 1.0, "section_id": 169}}, "n4659": {"so_37731401_38060482_3": {"length": 15, "quality": 1.0, "section_id": 180}, "so_37731401_38060482_4": {"length": 12, "quality": 1.0, "section_id": 180}, "so_37731401_37731686_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 180}, "so_37731401_38060482_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 180}, "so_37731401_38060482_1": {"length": 7, "quality": 1.0, "section_id": 180}, "so_37731401_38060482_2": {"length": 10, "quality": 1.0, "section_id": 180}}}, "37731686": {"Id": "37731686", "PostTypeId": "2", "Body": "<p>As for your (original) title</p>\n<blockquote>\n<p id=\"so_37731401_37731686_0\">Can a C++ template be typechecked without instantiating it?</p>\n</blockquote>\n<p>Depends on what exactly is meant with <em>typecheck</em>.</p>\n<hr>\n<blockquote>\n<p id=\"so_37731401_37731686_1\">does the language standard guarantee to detect the error at the time the template is defined?</p>\n</blockquote>\n<p>Regarding the template declaration (!) and definition itself, it will be checked for syntactical correctness before instantiation, as you mentioned in your question.</p>\n<p>There is some <em>type checking</em> done ...</p>\n<pre><code>template&lt;typename T&gt;\nclass Foo {\n     Foo() : x(y) {}\nprivate:\n     int &amp;x;\n     T z;\n};\n\nint main() {\n} \n</code></pre>\n<hr>\n<pre><code>clang =============\nmain.cpp:4:20: error: use of undeclared identifier 'y'\n         Foo() : x(y) {}\n                   ^\n1 error generated.\ngcc =============\nmain.cpp: In constructor 'Foo&lt;T&gt;::Foo()':\nmain.cpp:4:20: error: 'y' was not declared in this scope\n          Foo() : x(y) {}\n                    ^\n</code></pre>\n<p>See the <a href=\"http://coliru.stacked-crooked.com/a/40e18d4731a87382\" rel=\"nofollow noreferrer\"><kbd>Demo</kbd></a></p>\n<hr>\n<p>... but not consistently with </p>\n<pre><code>template&lt;typename T&gt;\nclass Foo {\n     Foo() : x(Foo::y) {}\nprivate:\n     int &amp;x;\n     T z;\n};\n\nint main() {\n}\n</code></pre>\n<hr>\n<pre><code>clang =============\nmain.cpp:4:25: error: no member named 'y' in 'Foo&lt;T&gt;'\n         Foo() : x(Foo::y) {}\n                   ~~~~~^\n1 error generated.\ngcc =============\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/8792b10b0fec35ac\" rel=\"nofollow noreferrer\"><kbd>Demo</kbd></a></p>\n<hr>\n<p>Where GCC also throws an error, when <code>Foo</code> is actually instantiated:</p>\n<pre><code>template&lt;typename T&gt;\nclass Foo {\npublic:\n     Foo() : x(Foo::y) {}\nprivate:\n     int &amp;x;\n     T z;\n};\n\nint main() {\n    Foo&lt;int&gt; foo; // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n}\n</code></pre>\n<hr>\n<pre><code>clang =============\nmain.cpp:5:25: error: no member named 'y' in 'Foo&lt;T&gt;'\n         Foo() : x(Foo::y) {}\n                   ~~~~~^\n1 error generated.\ngcc =============\nmain.cpp: In instantiation of 'Foo&lt;T&gt;::Foo() [with T = int]':\nmain.cpp:12:18:   required from here\nmain.cpp:5:26: error: 'y' is not a member of 'Foo&lt;int&gt;'\n          Foo() : x(Foo::y) {}\n                          ^\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/1ab3dcdcf5ee5963\" rel=\"nofollow noreferrer\"><kbd>Demo</kbd></a></p>\n<blockquote>\n<p id=\"so_37731401_37731686_2\">Or is the error guaranteed to be detected only when the template is instantiated?</p>\n</blockquote>\n<p>So this seems to be true.</p>\n<hr>\n<p>How far that goes seems to be a compiler implementation specific detail.<br>\nSo no, obviously there are no standard guarantees regarding that.</br></p>\n<p>Also as <a href=\"https://stackoverflow.com/users/2684539/jarod42\">@Jarod42</a> has shown in their <a href=\"http://coliru.stacked-crooked.com/a/f0fa7b04afeddf2b\" rel=\"nofollow noreferrer\">Clang/GCC sample</a></p>\n<pre><code>template &lt;typename T&gt;\nvoid foo()\n{\n    int a = \"hello world\";\n    const char* hello = 42;\n}\n\nint main()\n{\n}\n</code></pre>\n<hr>\n<pre><code>clang =============\nmain.cpp:6:9: error: cannot initialize a variable of type 'int' with an lvalue of type 'const char [12]'\n    int a = \"hello world\";\n        ^   ~~~~~~~~~~~~~\nmain.cpp:7:17: error: cannot initialize a variable of type 'const char *' with an rvalue of type 'int'\n    const char* hello = 42;\n                ^       ~~\n2 errors generated.\ngcc =============\n</code></pre>\n<hr>\n<p>So I'm afraid there's nothing more available than can be found in section \u00a714.5 of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf\" rel=\"nofollow noreferrer\">c++ standard specification</a> what is considered valid template declaration/definition syntax.</p>\n<hr>\n<hr>\n<p>Regarding former versions of your question:</p>\n<blockquote>\n<p id=\"so_37731401_37731686_3\">I'd like to know how much type checking can be done with a template definition, before the template is instantiated.</p>\n</blockquote>\n<p>The compiler needs to see the concrete parameter types (and non type parameter values) to apply (and in turn instantiate) the constraint checking templates for these types.</p>\n<p>So the template must be instatiated to do this.</p>\n<hr>\n<blockquote id=\"so_37731401_37731686_4\">\n<ul>\n<li>Perhaps a template is a lot like a macro in Lisp: the compiler checks the syntax, but no typechecking is done until the template is instantiated. And each time the template is instantiated, the compiler runs the typechecker again.</li>\n</ul>\n</blockquote>\n<p>That seems to come closest, though there's nothing like a <em>typechecker</em> that <em>runs</em> during compilation, but mostly instantiating other template classes and let a <a href=\"http://en.cppreference.com/w/cpp/language/static_assert\" rel=\"nofollow noreferrer\"><code>std::static_assert</code></a> decide in the end, if the constraints for the type (or non type) parameter are met or not. </p>\n<hr>\n<p>To see how the c++ standard library deals with that, see <a href=\"http://en.cppreference.com/w/cpp/concept\" rel=\"nofollow noreferrer\">Library Concepts</a> please.</p>\n<hr>\n</hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-06-09T19:36:52.507", "Score": "0", "CreationDate": "2016-06-09T16:37:23.740", "ParentId": "37731401", "CommentCount": "7", "OwnerUserId": "1413395", "LastEditDate": "2017-05-23T11:52:29.250"}, "37731401": {"ViewCount": "194", "Body": "<p>If a C++ template contains a blatant type error, such as a reference to a class member that does not exist, does the language standard guarantee to detect the error at the time the template is defined?  </p>\n<p>Or is the error guaranteed to be detected only when the template is instantiated?</p>\n<ol>\n<li><p>Suppose the error does not involve any of the template parameters?</p></li>\n<li><p>Suppose it does involve one of the template parameters?</p></li>\n</ol>\n", "Title": "Are C++ templates be checked for syntax errors without instantiating them?", "CreationDate": "2016-06-09T16:20:56.080", "LastActivityDate": "2016-06-27T18:09:29.413", "CommentCount": "11", "LastEditDate": "2016-06-27T17:32:47.830", "PostTypeId": "1", "LastEditorUserId": "1677912", "Id": "37731401", "Score": "1", "OwnerUserId": "41661", "Tags": "<c++><templates><typechecking>", "AnswerCount": "2"}, "38060482": {"Id": "38060482", "PostTypeId": "2", "Body": "<p>Checking is allowed, but not required. <a href=\"http://eel.is/c++draft/temp.res#8\" rel=\"nofollow\">[temp.res]/8</a>:</p>\n<blockquote>\n<p id=\"so_37731401_38060482_0\">Knowing which names are type names allows the syntax of every template\n  to be checked. The program is ill-formed, no diagnostic required, if:</p>\n<ul>\n<li><p id=\"so_37731401_38060482_1\">no valid specialization can be generated for a template and that template is not instantiated, or</p></li>\n<li><p id=\"so_37731401_38060482_2\">every valid specialization of a variadic template requires an empty template parameter pack, or</p></li>\n<li><p id=\"so_37731401_38060482_3\">a hypothetical instantiation of a template immediately following its definition would be ill-formed due to a construct that does not depend\n  on a template parameter, or</p></li>\n<li><p id=\"so_37731401_38060482_4\">the interpretation of such a construct in the hypothetical instantiation is different from the interpretation of the\n  corresponding construct in any actual instantiation of the template.</p></li>\n</ul>\n</blockquote>\n<p>Note that two-phase lookup doesn't actually require early checking: various name lookups are required to be done in the template definition context, but they are not actually required to be done at the time of definition.</p>\n", "LastActivityDate": "2016-06-27T18:09:29.413", "CommentCount": "0", "CreationDate": "2016-06-27T18:09:29.413", "ParentId": "37731401", "Score": "0", "OwnerUserId": "2756719"}});