post_cb({"19792135": {"CommentCount": "4", "AcceptedAnswerId": "19792864", "PostTypeId": "1", "LastEditorUserId": "2148672", "CreationDate": "2013-11-05T15:08:23.020", "LastActivityDate": "2013-11-12T11:44:34.793", "LastEditDate": "2013-11-05T16:53:58.233", "ViewCount": "1652", "FavoriteCount": "11", "Title": "Return value optimizations and side-effects", "Id": "19792135", "Score": "25", "Body": "<p>Return value optimization (RVO) is an optimization technique involving copy elision, which eliminates the temporary object created to hold a function's return value in certain situations. I understand the benefit of RVO in general, but I have a couple of questions. </p>\n<p>The standard says the following about it in \u00a712.8, paragraph 32 of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\">this working draft</a> (emphasis mine).</p>\n<blockquote>\n<p id=\"so_19792135_19792135_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, <strong>even if the copy/move constructor and/or destructor for the object have side effects</strong>. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization.</p>\n</blockquote>\n<p>It then lists a number of criteria when the implementation may perform this optimization. </p>\n<hr>\n<p>I have a couple of questions regarding this potential optimization:</p>\n<ol>\n<li><p>I am used to optimizations being constrained such that they cannot change observable behaviour. This restriction does not seem to apply to RVO. <strong>Do I ever need to worry about the side effects mentioned in the standard?</strong> Do corner cases exist where this might cause trouble?</p></li>\n<li><p><strong>What do I as a programmer need to do (or not do) to allow this optimization to be performed?</strong> For example, does the following prohibit the use of copy elision (due to the <code>move</code>):</p></li>\n</ol>\n<pre class=\"lang-c prettyprint-override\"><code>std::vector&lt;double&gt; foo(int bar){\n    std::vector&lt;double&gt; quux(bar,0);\n    return std::move(quux);\n}\n</code></pre>\n<h2>Edit</h2>\n<p>I posted this as a new question because the specific questions I mentioned are not directly answered in other, related questions.</p>\n</hr>", "Tags": "<c++><c++11><compiler-optimization>", "OwnerUserId": "2148672", "AnswerCount": "4"}, "19792277": {"ParentId": "19792135", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>It states it pretty clear, doesn't it? It allows to omit ctor with side effects. So you should <em>never</em> have side effects in ctors or if you insist, you should use techniques which eliminate (N)RVO.\nAs to the second I believe it prohibits NRVO <s>since <code>std::move</code> produces <code>T&amp;&amp;</code> and not <code>T</code> which would be candidate for NRVO(RVO)</s> because <code>std::move</code> removes name and NRVO requires it(thanks to @DyP comment). </p>\n<p>Just tested the following code on MSVC:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\npublic:\n    A()\n    {\n        std::cout &lt;&lt; \"Ctor\\n\";\n    }\n    A(const A&amp;)\n    {\n        std::cout &lt;&lt; \"Copy ctor\\n\";\n    }\n    A(A&amp;&amp;)\n    {\n        std::cout &lt;&lt; \"Move\\n\";\n    }\n\n};\n\nA foo()\n{\n    A a;\n    return a;\n}\n\nint main() \n{\n    A a = foo();\n    return 0;\n}\n</code></pre>\n<p>it produces <code>Ctor</code>, so we have lost side effects for move ctor. And if you add <code>std::move</code> to <code>foo()</code> you will have NRVO eliminated.</p>\n", "OwnerUserId": "643393", "LastEditorUserId": "643393", "LastEditDate": "2013-11-05T16:05:29.290", "Id": "19792277", "Score": "4", "CreationDate": "2013-11-05T15:14:59.283", "LastActivityDate": "2013-11-05T16:05:29.290"}, "19792864": {"ParentId": "19792135", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<blockquote>\n<p id=\"so_19792135_19792864_1\">I am used to optimizations being constrained such that they cannot change observable behaviour.</p>\n</blockquote>\n</blockquote>\n<p>This is correct. As a general rule -- known as the <em>as-if</em> rule -- compilers can change code if the change is not observable.</p>\n<blockquote>\n<blockquote>\n<p id=\"so_19792135_19792864_3\">This restriction does not seem to apply to RVO. </p>\n</blockquote>\n</blockquote>\n<p>Yes. The clause quoted in the OP gives an exception to the <em>as-if</em> rule and allows copy construction to be omitted, even when it has side effects. Notice that the RVO is just one case of copy-elision (the first bullet point in C++11 12.8/31).</p>\n<blockquote>\n<blockquote>\n<p id=\"so_19792135_19792864_5\">Do I ever need to worry about the side effects mentioned in the standard?</p>\n</blockquote>\n</blockquote>\n<p>If the copy constructor has side effects such that copy elision when performed causes a problem, then you should reconsider the design. If this is not your code, you should probably consider a better alternative.</p>\n<blockquote>\n<blockquote>\n<p id=\"so_19792135_19792864_7\">What do I as a programmer need to do (or not do) to allow this optimization to be performed?</p>\n</blockquote>\n</blockquote>\n<p>Basically, if possible, return a local variable (or temporary) with the same cv unqualified type as the function return type. This allows RVO but doens't enforce it (the compiler might not perform RVO).</p>\n<blockquote>\n<blockquote>\n<p id=\"so_19792135_19792864_9\">For example, does the following prohibit the use of copy elision (due to the move):</p>\n</blockquote>\n</blockquote>\n<pre><code>// notice that I fixed the OP's example by adding &lt;double&gt;\nstd::vector&lt;double&gt; foo(int bar){\n    std::vector&lt;double&gt; quux(bar, 0);\n    return std::move(quux);\n}\n</code></pre>\n<p>Yes, it does because you're not returning the name of a local variable. This</p>\n<pre><code>std::vector&lt;double&gt; foo(int bar){\n    std::vector&lt;double&gt; quux(bar,0);\n    return quux;\n}\n</code></pre>\n<p>allows RVO. One might be worried that if RVO is not performed then moving is better than coping (which would explain the use of <code>std::move</code> above). Don't worry about that. All major compilers will do the RVO here (at least in release build). Even if a compiler doesn't do RVO but the conditions for RVO are met then it will try to do a move rather than a copy. In summary, using <code>std::move</code> above will certainly make a move. Not using it will likely neither copy nor move anything and, in the worst (unlikely) case, will move.</p>\n<p>(<strong>Update:</strong> As haohaolee's pointed out (see comments), the following paragraphs are not correct. However, I leave them here because they suggest an idea that might work for classes that don't have a constructor taking a <code>std::initializer_list</code> (see the reference at the bottom). For <code>std::vector</code>, haohaolee found a workaround.)</p>\n<p>In this example you can force the RVO (strict speaking this is no longer RVO but let's keep calling this way for simplicity) by returning a <em>braced-init-list</em> from which the return type can be created:</p>\n<pre><code>std::vector&lt;double&gt; foo(int bar){\n    return {bar, 0}; // &lt;-- This doesn't work. Next line shows a workaround:\n    // return {bar, 0.0, std::vector&lt;double&gt;::allocator_type{}};\n}\n</code></pre>\n<p>See this <a href=\"https://stackoverflow.com/questions/19427196/construction-helper-function-make-xyz-where-xyx-is-a-class-with-noncopy-constrai\">post</a> and <a href=\"https://stackoverflow.com/users/46642/r-martinho-fernandes\">R. Martinho Fernandes</a>'s brilliant <a href=\"https://stackoverflow.com/a/19428052/1137388\">answer</a>.</p>\n<p>Be carefull! Have the return type been <code>std::vector&lt;int&gt;</code> the last code above would have a different behavior from the original. (This is another story.)</p>\n", "OwnerUserId": "1137388", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:58:09.357", "Id": "19792864", "Score": "14", "CreationDate": "2013-11-05T15:42:49.777", "LastActivityDate": "2013-11-12T11:44:34.793"}, "19793661": {"ParentId": "19792135", "CommentCount": "0", "Body": "<ol>\n<li><p>This is probably obvious but if you avoid writing copy/move constructors with side effects (most have no need for them) then the problem is totally moot. Even in simple side effect cases like construction/destruction counting it should still be fine. The only case to possibly worry is complicated side effects and that's a strong design smell to re-examime your code.</p></li>\n<li><p>This sounds like premature optimization to me. Just write the obvious, easily maintainable code, and let the compiler optimize. Only if profiling shows that certain areas are performing poorly should you consider adopting changes to improve performance.</p></li>\n</ol>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "19793661", "Score": "0", "CreationDate": "2013-11-05T16:18:07.117", "LastActivityDate": "2013-11-05T16:18:07.117"}, "19792614": {"ParentId": "19792135", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I highly recommend reading \"Inside the C++ Object Model\" by Stanely B. Lippman for detailed information and some historical backround on how the named return value optimization works.</p>\n<p>For example, in chapter 2.1 he has this to say about named return value optimization:</p>\n<blockquote>\n<p id=\"so_19792135_19792614_0\">In a function such as bar(), where all return statements return the\n  same named value, it is possible for the compiler itself to optimize\n  the function by substituting the result argument for the named return\n  value. For example, given the original definition of bar():</p>\n<pre><code>X bar() \n{ \n   X xx; \n   // ... process xx \n   return xx; \n} \n</code></pre>\n<p id=\"so_19792135_19792614_1\">__result is substituted for xx by the compiler:</p>\n<pre><code>void \nbar( X &amp;__result ) \n{ \n   // default constructor invocation \n   // Pseudo C++ Code \n   __result.X::X(); \n\n   // ... process in __result directly \n\n   return; \n}\n</code></pre>\n<p id=\"so_19792135_19792614_2\">(....)</p>\n<p id=\"so_19792135_19792614_3\">Although the NRV optimization provides significant performance\n  improvement, there are several criticisms of this approach. One is\n  that because the optimization is done silently by the compiler,\n  whether it was actually performed is not always clear (particularly\n  since few compilers document the extent of its implementation or\n  whether it is implemented at all). A second is that as the function\n  becomes more complicated, the optimization becomes more difficult to\n  apply. In cfront, for example, the optimization is applied only if all\n  the named return statements occur at the top level of the function.\n  Introduce a nested local block with a return statement, and cfront\n  quietly turns off the optimization.</p>\n</blockquote>\n", "OwnerUserId": "346587", "LastEditorUserId": "346587", "LastEditDate": "2013-11-05T15:38:39.790", "Id": "19792614", "Score": "5", "CreationDate": "2013-11-05T15:31:05.830", "LastActivityDate": "2013-11-05T15:38:39.790"}, "bq_ids": {"n4140": {"so_19792135_19792135_0": {"section_id": 480, "quality": 0.9795918367346939, "length": 48}}, "n3337": {"so_19792135_19792135_0": {"section_id": 471, "quality": 1.0, "length": 49}}, "n4659": {"so_19792135_19792135_0": {"section_id": 502, "quality": 0.9795918367346939, "length": 48}}}});