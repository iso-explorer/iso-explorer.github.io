post_cb({"20829951": {"PostTypeId": "2", "Body": "<p>The standard C++ library already implements lists, maps, sets, etc. There is no point in C++ to implement these data structures again. If you implement something like one of these data structures you'd implement the same <em>concept</em> (i.e., use the same function names, order of parameters, names of nested types, etc.). There are various concepts for container (sequence, associative containers, etc.). More importantly, you'd expose the content of your structure using the appropriate iterator concepts.</p>\n<p>Note: C++ isn't Java. Don't try to program Java in C++. If you want to program Java, program Java: it works a lot better than trying to do so in C++. If you want to program C++, program C++.</p>\n", "LastActivityDate": "2013-12-29T20:52:25.540", "Id": "20829951", "CommentCount": "6", "CreationDate": "2013-12-29T20:52:25.540", "ParentId": "20829860", "Score": "5", "OwnerUserId": "1120273"}, "31094319": {"PostTypeId": "2", "Body": "<p>In C++, collections (aka containers) and generic algorithms that operate on them are implemented in a way that is completely unaware of inheritance.  Instead, what connects them are iterators: For each container, specify which category of iterators it provides, for each algorithm, state which category of iterators it works with.  So in a way, iterators 'bridge' the other two together and this is how STL affords to keep the number of containers and algorithms to the minimum (N+M instead of N*M).  Containers are further defined as sequence containers (vector, deque, list (double linked list), or forward_list (singly linked list) and associative containers (map, set, hashmap, hashset, etc).  Sequence containers are concerned with performance (i.e. which one is a better choice for a different situation).  Associative containers are concerned with how things get stored in them and its consequence (binary tree vs hashed array).  Similar ideas apply for algorithms.   This is a gist of generic programming as exemplified by STL by being specifically and intentionally not object oriented.  Indeed you would have to distort a pure OO approach to achieve smooth generic programming. Such a paradigm does not ride happily with languages such as Java or Smalltalk</p>\n", "LastActivityDate": "2015-06-27T22:49:28.047", "Id": "31094319", "CommentCount": "0", "CreationDate": "2015-06-27T22:49:28.047", "ParentId": "20829860", "Score": "0", "OwnerUserId": "4509021"}, "20829935": {"PostTypeId": "2", "Body": "<p>The C++ standard library (note: it's not called the STL) has many existing container types: <code>vector</code>, <code>array</code>, <code>deque</code>, <code>forward_list</code>, <code>list</code>, <code>set</code>, <code>map</code>, <code>multiset</code>, <code>multimap</code>, <code>unordered_set</code>, <code>unordered_map</code>, <code>unordered_multiset</code>, <code>unordered_multimap</code>, <code>stack</code>, <code>queue</code>, <code>priority_queue</code>. Chances are, you just want to use one of these directly - you certainly <em>never</em> want to derive from them. However, it's certainly possible that you may need to implement your own special container type at some point, and it would be nice if it matched some interface, right?</p>\n<p>But no, there aren't some abstract base classes that the containers derive from. However, the C++ standard provides <em>requirements</em> for types (sometimes known as <em>concepts</em>). For example, if you look at section \u00a723.2 of the C++11 standard (or <a href=\"http://en.cppreference.com/w/cpp/concept/Container\" rel=\"nofollow\">here</a>), you'll find the requirements for a Container. For example, all containers must have a default constructor that creates an empty container in constant time. There are then more specific requirements for <a href=\"http://en.cppreference.com/w/cpp/concept/SequenceContainer\" rel=\"nofollow\">Sequence Containers</a> (like <code>std::vector</code>) and <a href=\"http://en.cppreference.com/w/cpp/concept/AssociativeContainer\" rel=\"nofollow\">Associative Containers</a> (like <code>std::map</code>). You can code your classes to meet these requirements and then people can safely use your containers as they would expect to.</p>\n<p>Of course, there are requirements for many things other than containers. For example, the standard provides requirements for different types of iterators, random number generators, and so on.</p>\n<hr>\n<p>A number of people on the ISO C++ committee (Study Group 8, in fact) are looking into making these concepts a feature of the language. The proposal would allow you to specify requirements for types that need to be met for them to be used as template type arguments. For example, you would be able to write a template function a little like this:</p>\n<pre><code>template &lt;Sequence_container C&gt;\nvoid foo(C container); // This will only accept sequence containers\n// or even just:\nvoid foo(Sequence_container container);\n</code></pre>\n<p>However, I'm thinking this is currently beyond your understanding of C++.</p>\n</hr>", "LastActivityDate": "2013-12-29T21:08:46.487", "LastEditorUserId": "150634", "Id": "20829935", "CommentCount": "13", "CreationDate": "2013-12-29T20:49:54.620", "ParentId": "20829860", "Score": "2", "OwnerUserId": "150634", "LastEditDate": "2013-12-29T21:08:46.487"}, "bq_ids": {"n4140": {"so_20829860_20829969_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 955}}, "n3337": {"so_20829860_20829969_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 943}}}, "21186552": {"PostTypeId": "2", "Body": "<p><strong>The short answer is: there isn't an equivalent, because C++ does things differently.</strong></p>\n<p>There's no point arguing about this, it's just the way things are. If you don't like this, use a different language.</p>\n<p>The long answer is: there is an equivalent but it's going to make you a little unhappy, because while Java's model of containers and algorithms is heavily based around inheritance, C++'s isn't. C++'s model is heavily based around generic iterators.</p>\n<p>Let's say, to take your example, that you want to implement a set. Ignoring the fact that C++ already has <code>std::set</code>, <code>std::multiset</code>, <code>std::unordered_set</code> and <code>std::unordered_multiset</code>, <em>and</em> that these are all customisable with different comparators and allocators, and the unordered ones have customisable hash functions, of course.</p>\n<p>So let's say you want to reimplement <code>std::set</code>. Perhaps you're a computer science student and you want to compare AVL trees, 2-3 trees, red-black trees and splay trees, for example. </p>\n<p>How would you do this? You would write:</p>\n<pre><code>template&lt;class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;&gt; \nclass set {\n    using key_type = Key;\n    using value_type = Key;\n    using size_type = std::size_t;\n    using difference_type = std::ptrdiff_t;\n    using key_compare = Compare;\n    using value_compare = Compare;\n    using allocator_type = Allocator;\n    using reference = value_type&amp;;\n    using const_reference = const value_type&amp;;\n    using pointer = std::allocator_traits&lt;Allocator&gt;::pointer;\n    using const_pointer = std::allocator_traits&lt;Allocator&gt;::const_pointer;\n    using iterator = /* depends on your implementation */;\n    using const_iterator = /* depends on your implementation */;\n    using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;\n    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;\n\n    iterator begin() const;\n    iterator end() const;\n    const_iterator cbegin() const;\n    const_iterator cend() const;\n    reverse_iterator rbegin() const;\n    reverse_iterator rend() const;\n    const_reverse_iterator crbegin() const;\n    const_reverse_iterator crend() const;\n\n    bool empty() const;\n    size_type size() const;\n    size_type max_size() const;\n\n    void clear();\n\n    std::pair&lt;iterator, bool&gt; insert(const value_type&amp; value);\n    std::pair&lt;iterator, bool&gt; insert(value_type&amp;&amp; value);\n    iterator insert(const_iterator hint, const value_type&amp; value);\n    iterator insert(const_iterator hint, value_type&amp;&amp; value);\n    template &lt;typename InputIterator&gt;\n    void insert(InputIterator first, InputIterator last);\n    void insert(std::initializer_list&lt;value_type&gt; ilist);\n\n    template &lt;class ...Args&gt;\n    std::pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args);\n\n    void erase(iterator pos);\n    iterator erase(const_iterator pos);\n    void erase(iterator first, iterator last);\n    iterator erase(const_iterator first, const_iterator last);\n    size_type erase(const key_type&amp; key);\n\n    void swap(set&amp; other);\n\n    size_type count(const Key&amp; key) const;\n    iterator find(const Key&amp; key);\n    const_iterator find(const Key&amp; key) const;\n\n    std::pair&lt;iterator, iterator&gt; equal_range(const Key&amp; key);\n    std::pair&lt;const_iterator, const_iterator&gt; equal_range(const Key&amp; key) const;\n\n    iterator lower_bound(const Key&amp; key);\n    const_iterator lower_bound(const Key&amp; key) const;\n    iterator upper_bound(const Key&amp; key);\n    const_iterator upper_bound(const Key&amp; key) const;\n\n    key_compare key_comp() const;\n    value_compare value_comp() const;\n}; // offtopic: don't forget the ; if you've come from Java!\n\ntemplate&lt;class Key, class Compare, class Alloc&gt;\nvoid swap(set&lt;Key,Compare,Alloc&gt;&amp; lhs, \n          set&lt;Key,Compare,Alloc&gt;&amp; rhs);\n\ntemplate &lt;class Key, class Compare, class Alloc&gt;\nbool operator==(const set&lt;Key,Compare,Alloc&gt;&amp; lhs,\n                const set&lt;Key,Compare,Alloc&gt;&amp; rhs);\n\ntemplate &lt;class Key, class Compare, class Alloc&gt;\nbool operator!=(const set&lt;Key,Compare,Alloc&gt;&amp; lhs,\n                const set&lt;Key,Compare,Alloc&gt;&amp; rhs);\n\ntemplate &lt;class Key, class Compare, class Alloc&gt;\nbool operator&lt;(const set&lt;Key,Compare,Alloc&gt;&amp; lhs,\n               const set&lt;Key,Compare,Alloc&gt;&amp; rhs);\n\ntemplate &lt;class Key, class Compare, class Alloc&gt;\nbool operator&lt;=(const set&lt;Key,Compare,Alloc&gt;&amp; lhs,\n                const set&lt;Key,Compare,Alloc&gt;&amp; rhs);\n\ntemplate &lt;class Key, class Compare, class Alloc&gt;\nbool operator&gt;(const set&lt;Key,Compare,Alloc&gt;&amp; lhs,\n               const set&lt;Key,Compare,Alloc&gt;&amp; rhs);\n\ntemplate &lt;class Key, class Compare, class Alloc&gt;\nbool operator&gt;=(const set&lt;Key,Compare,Alloc&gt;&amp; lhs,\n                const set&lt;Key,Compare,Alloc&gt;&amp; rhs);\n</code></pre>\n<p>Of course you don't have to write ALL of those, especially if you're just writing something to test parts of them. But if you write all that (and a little bit more I excluded for clarity), then what you will have will be a fully functioning set class. And what is special about that set class?</p>\n<p>You can use it anywhere. Anything that works with a <code>std::set</code> will work with your set. It doesn't have to be programmed specially for it. It doesn't need anything. And anything that works on ANY set type should work on it. And any of Boost's algorithms will work on sets.</p>\n<p>And any algorithms you write to use on sets will work on your sets and boost's sets and lots of other sets. But not just on sets. If they're written competently they'll work on any container that supports a particular type of iterator. If they need random access they'll require RandomAccessIterators, which <code>std::vector</code> provides, but <code>std::list</code> doesn't. If they need BidirectionalIterators, then <code>std::vector</code> and <code>std::list</code> (and others) will work fine, but <code>std::forward_list</code> won't.</p>\n<p>The iterator/algorithm/container thing works really well. Consider the cleanliness of reading a file into a string in C++:</p>\n<pre><code>using namespace std;\n\nifstream file(\"file.txt\");\nstring file_contents(istreambuf_iterator&lt;char&gt;(file),\n                     istreambuf_iterator&lt;char&gt;{});\n</code></pre>\n", "LastActivityDate": "2016-05-09T03:17:25.780", "LastEditorUserId": "2756719", "Id": "21186552", "CommentCount": "8", "CreationDate": "2014-01-17T12:54:01.343", "ParentId": "20829860", "Score": "12", "OwnerUserId": "575229", "LastEditDate": "2016-05-09T03:17:25.780"}, "20829860": {"ViewCount": "2226", "Body": "<p>I've started coding in C++, coming from a Java background (actually I'd studied C++ at my university, but we never got to the STL etc.)</p>\n<p>Anyway, I've gotten to the point where I'm arranging data in all sorts of collections, and I immediately tell myself \"Ok, this is a kind of a Set; and this is a List, or an ArrayList; and this is a map etc.\" In Java, I would simply have whatever class I'm writing implement the Set or Map or List interface; but I would probably not go as far as inheriting ArrayList or HashSet or what-not, the implementations there are kind of involved and I wouldn't want to mess them up.</p>\n<p>Now, what do I do in C++ (with the Standard Library)? There do not seem to be abstract base classes for Sets, Maps, Lists etc - the equivalent of Java interfaces; on the other hand, the implementations for the standard containers look pretty horrid. Ok, maybe they're not so horrid once you get to know them, but suppose I just wanted to write something like a non-virtual class extending AbstractSet in C++? Something I would be able to pass it to any function which takes a Set? How should I go about doing that?</p>\n<p>Just to clarify - I don't necessarily want to do what's common practice in Java. But, on the other hand, if I have an object which, conceptually, is a kind of set, I want to inherit something appropriate, get default implementations gratis, and be guided by my IDE to implement those methods which I should implement.</p>\n", "AcceptedAnswerId": "21186552", "Title": "What is the C++ equivalent of inheriting a Java collection interface (Set, Map, List etc.)? Or extending AbstractCollection?", "CreationDate": "2013-12-29T20:42:31.320", "Id": "20829860", "CommentCount": "12", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-09-15T21:21:27.477", "LastEditorUserId": "1593077", "LastActivityDate": "2016-05-09T03:17:25.780", "Score": "5", "OwnerUserId": "1593077", "Tags": "<java><c++><inheritance><stl><containers>", "AnswerCount": "5"}, "20829969": {"PostTypeId": "2", "Body": "<p>You need to try and let go of the Java mindset. You see, the beauty of STL, is that it separates algorithms from containers through iterators.</p>\n<p>Long story short: Pass around <em>iterators</em> to your algorithms. Don't inherit.</p>\n<p>Here are all the containers: <a href=\"http://en.cppreference.com/w/cpp/container\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/container</a></p>\n<p>And here are all the algorithms: <a href=\"http://en.cppreference.com/w/cpp/algorithm\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/algorithm</a></p>\n<p>There may be two reasons why you may want to inherit:</p>\n<ul>\n<li>You want to reuse implementation (bad idea)</li>\n<li>Reuse existing algorithms by making a behavior available (e.g. inheriting from a base class like AbstractSet)</li>\n</ul>\n<p>To briefly touch upon the first point, if you need to store an array of things (say an array of objects in a game scene), do exactly that, have an array of these objects as a member to the Scene object. There is no need to subclass to fully utilize the container. In other words, <em>prefer composition over inheritance</em>. This has been done to death already, and is accepted in the Java world as doing \"The Right Thing\". <a href=\"http://www.artima.com/lejava/articles/designprinciples4.html\" rel=\"nofollow\">See discussion here</a>, it's in the GoF book! Same thing applies to C++.</p>\n<p><strong>Example:</strong></p>\n<p>To address the second point let's consider a scenario. You are making a 2D sidescroller game, and you have a <code>Scene</code> object, with an array of <code>GameObject</code>s. These <code>GameObjects</code> have positions, and you'd like to sort them by position, and do binary search to find the closest object, as an example.</p>\n<p>In the C++ mindset, the storage of elements and manipulation of containers are two separate things. The container classes provide the bare minimum functionality, for creation/insertion/removal. Anything interesting above that is relegated to Algorithms. And the bridge between them are <em>iterators</em>. The idea is that whether you use <code>std::vector&lt;GameObject&gt;</code> (equivalent to Java's ArrayList I think), or your own implementation is irrelevant as long <em>as access to elements is the same</em>. Here is a contrived example:</p>\n<pre><code>struct GameObject {\n    float x, y;\n\n    // compare just by x position\n    operator &lt; (GameObject const&amp; other)\n    {\n        return x &lt; other.x;\n    }\n};\n\nvoid example() {\n    std::vector&lt;GameObject&gt; objects = {\n        GameObject{8, 2},\n        GameObject{4, 3},\n        GameObject{6, 1}\n    };\n    std::sort(std::begin(objects), std::end(objects));\n    auto nearestObject = std::lower_bound(std::begin(objects), std::end(objects), GameObject{5, 12});\n\n    // nearestObject should be pointing to GameObject{4,3};\n}\n</code></pre>\n<p>Things to note here, the fact that I used <code>std::vector</code> to store my objects, doesn't matter as much as the fact I can perform random access on its elements. The iterators returned by the <code>vector</code> capture that. As a result we can sort and perform binary search.</p>\n<blockquote>\n<p id=\"so_20829860_20829969_0\">The essence of the vector is random access to elements</p>\n</blockquote>\n<p>We can swap out the vector for any other random access structure, <em>without inheritance</em>, and the code still works perfectly fine:</p>\n<pre><code>void example() {\n    // using a raw array this time.\n    GameObject objects[] = {\n        GameObject{8, 2},\n        GameObject{4, 3},\n        GameObject{6, 1}\n    };\n    std::sort(std::begin(objects), std::end(objects));\n    auto nearestObject = std::lower_bound(std::begin(objects), std::end(objects), GameObject{5, 12});\n\n    // nearestObject should be pointing to GameObject{4,3};\n}\n</code></pre>\n<p>For reference, see the functions I have used:</p>\n<ul>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/sort\" rel=\"nofollow\">std::sort</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/lower_bound\" rel=\"nofollow\">std::lower_bound</a></li>\n</ul>\n<p><strong>Why is this a valid alternative to inheritance?</strong></p>\n<p>This approach gives two orthogonal directions for extensibility:</p>\n<ul>\n<li>New containers can be added, without inheritance, just by providing iterator access. <em>All existing algorithms work</em>.</li>\n<li>New algorithms can be added. <em>All containers supporting these iterators will work</em> with these new algorithms, past, present or future.</li>\n</ul>\n", "LastActivityDate": "2013-12-29T21:50:14.300", "LastEditorUserId": "436025", "Id": "20829969", "CommentCount": "10", "CreationDate": "2013-12-29T20:53:54.277", "ParentId": "20829860", "Score": "3", "OwnerUserId": "436025", "LastEditDate": "2013-12-29T21:50:14.300"}});