post_cb({"bq_ids": {"n4140": {"so_30001927_30001987_0": {"length": 36, "quality": 1.0, "section_id": 6090}}, "n3337": {"so_30001927_30001987_0": {"length": 36, "quality": 1.0, "section_id": 5858}}, "n4659": {"so_30001927_30001987_0": {"length": 36, "quality": 1.0, "section_id": 7586}}}, "30001987": {"Id": "30001987", "PostTypeId": "2", "Body": "<p>You can override <code>new</code> for a class, but <code>::new</code> will always seek in global scope. I.e.:</p>\n<pre><code>class A {\n    void* operator new(std::size_t sz) { \n        /* 1 */ }\n};\n\nvoid* operator new(std::size_t sz) { \n        /* 2 */ }\n\nvoid f() {\n    A* a1 = new A;   // calls A::new (1)\n    A* a2 = ::new A; // calls implementation 2 or compiler's new\n}\n</code></pre>\n<p>That is described in \u00a7 5.3.4 New, clause 9:</p>\n<blockquote>\n<p id=\"so_30001927_30001987_0\">If the <em>new-expression</em> begins with a unary <code>::</code> operator, the allocation function\u2019s name is looked up in the global scope. Otherwise, if the allocated type is a class type <code>T</code> or array thereof, the allocation function\u2019s name is looked up in the scope of <code>T</code>. If this lookup fails to find the name, or if the allocated type is not a class type, the allocation function\u2019s name is looked up in the global scope.</p>\n</blockquote>\n<p><sub>(as of N3797 draft)</sub></p>\n<p>Same applies to <code>delete</code> and <code>::delete</code></p>\n", "LastActivityDate": "2015-05-02T11:55:37.570", "CommentCount": "2", "CreationDate": "2015-05-02T11:55:37.570", "ParentId": "30001927", "Score": "9", "OwnerUserId": "2709018"}, "30001946": {"Id": "30001946", "PostTypeId": "2", "Body": "<p><code>::new</code> and <code>::delete</code> are the operators at the global scope. You use this syntax in case you overload <code>new</code> and <code>delete</code> for your class. In the latter case, calling simply <code>new</code> inside your overloaded <code>new</code> leads to infinite recursion, as you end up calling the operator you're just defining.</p>\n", "LastActivityDate": "2015-05-02T11:51:47.373", "CommentCount": "0", "CreationDate": "2015-05-02T11:51:47.373", "ParentId": "30001927", "Score": "6", "OwnerUserId": "3093378"}, "30001927": {"ViewCount": "220", "Body": "<pre><code>new delete\n</code></pre>\n<p>or</p>\n<pre><code>::new ::delete\n</code></pre>\n<p>I'm wondering the uses of that <code>::</code> as it seems works normally if I remove them. </p>\n<p>These are all the codes written in tutorial of auto pointer.</p>\n<pre><code>#include &lt;cstddef&gt;  \nsize_t* alloc_counter(){\n    return ::new size_t;  \n}  \nvoid dealloc_counter(size_t* ptr){\n    ::delete ptr;  \n}  \n</code></pre>\n", "AcceptedAnswerId": "30001987", "Title": "What's the difference between new/delete and ::new/::delete?", "CreationDate": "2015-05-02T11:49:10.203", "Id": "30001927", "CommentCount": "0", "LastEditDate": "2015-05-02T11:52:39.507", "PostTypeId": "1", "LastEditorUserId": "4516316", "LastActivityDate": "2015-05-02T11:55:37.570", "Score": "10", "OwnerUserId": "4013671", "Tags": "<c++><syntax>", "AnswerCount": "2"}});