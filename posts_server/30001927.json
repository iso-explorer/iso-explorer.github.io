post_cb({"30001987": {"ParentId": "30001927", "CommentCount": "2", "Body": "<p>You can override <code>new</code> for a class, but <code>::new</code> will always seek in global scope. I.e.:</p>\n<pre><code>class A {\n    void* operator new(std::size_t sz) { \n        /* 1 */ }\n};\n\nvoid* operator new(std::size_t sz) { \n        /* 2 */ }\n\nvoid f() {\n    A* a1 = new A;   // calls A::new (1)\n    A* a2 = ::new A; // calls implementation 2 or compiler's new\n}\n</code></pre>\n<p>That is described in \u00a7 5.3.4 New, clause 9:</p>\n<blockquote>\n<p id=\"so_30001927_30001987_0\">If the <em>new-expression</em> begins with a unary <code>::</code> operator, the allocation function\u2019s name is looked up in the global scope. Otherwise, if the allocated type is a class type <code>T</code> or array thereof, the allocation function\u2019s name is looked up in the scope of <code>T</code>. If this lookup fails to find the name, or if the allocated type is not a class type, the allocation function\u2019s name is looked up in the global scope.</p>\n</blockquote>\n<p><sub>(as of N3797 draft)</sub></p>\n<p>Same applies to <code>delete</code> and <code>::delete</code></p>\n", "OwnerUserId": "2709018", "PostTypeId": "2", "Id": "30001987", "Score": "9", "CreationDate": "2015-05-02T11:55:37.570", "LastActivityDate": "2015-05-02T11:55:37.570"}, "30001927": {"CommentCount": "0", "ViewCount": "220", "PostTypeId": "1", "LastEditorUserId": "4516316", "CreationDate": "2015-05-02T11:49:10.203", "LastActivityDate": "2015-05-02T11:55:37.570", "Title": "What's the difference between new/delete and ::new/::delete?", "AcceptedAnswerId": "30001987", "LastEditDate": "2015-05-02T11:52:39.507", "Id": "30001927", "Score": "10", "Body": "<pre><code>new delete\n</code></pre>\n<p>or</p>\n<pre><code>::new ::delete\n</code></pre>\n<p>I'm wondering the uses of that <code>::</code> as it seems works normally if I remove them. </p>\n<p>These are all the codes written in tutorial of auto pointer.</p>\n<pre><code>#include &lt;cstddef&gt;  \nsize_t* alloc_counter(){\n    return ::new size_t;  \n}  \nvoid dealloc_counter(size_t* ptr){\n    ::delete ptr;  \n}  \n</code></pre>\n", "Tags": "<c++><syntax>", "OwnerUserId": "4013671", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_30001927_30001987_0": {"section_id": 6090, "quality": 1.0, "length": 36}}, "n3337": {"so_30001927_30001987_0": {"section_id": 5858, "quality": 1.0, "length": 36}}, "n4659": {"so_30001927_30001987_0": {"section_id": 7586, "quality": 1.0, "length": 36}}}, "30001946": {"ParentId": "30001927", "CommentCount": "0", "Body": "<p><code>::new</code> and <code>::delete</code> are the operators at the global scope. You use this syntax in case you overload <code>new</code> and <code>delete</code> for your class. In the latter case, calling simply <code>new</code> inside your overloaded <code>new</code> leads to infinite recursion, as you end up calling the operator you're just defining.</p>\n", "OwnerUserId": "3093378", "PostTypeId": "2", "Id": "30001946", "Score": "6", "CreationDate": "2015-05-02T11:51:47.373", "LastActivityDate": "2015-05-02T11:51:47.373"}});