post_cb({"11139915": {"Id": "11139915", "PostTypeId": "2", "Body": "<h3>C++ 11</h3>\n<p>I think the pertinent part are</p>\n<p>3.9.1/1 In C++11</p>\n<blockquote>\n<p id=\"so_11138188_11139915_0\">For character types, all bits of the object representation participate\n  in the value representation. For unsigned character types, all possible bit patterns of the value representation represent numbers. These requirements do not hold for other types.</p>\n</blockquote>\n<p>Along with 3.9.1/7</p>\n<blockquote>\n<p id=\"so_11138188_11139915_1\">The representations of integral types\n  shall define values by use of a pure binary numeration system.</p>\n</blockquote>\n<h3>C11</h3>\n<p>6.2.6.2 is very explicit</p>\n<blockquote>\n<p id=\"so_11138188_11139915_2\">For unsigned integer types other than unsigned char, the bits of the object\n  representation shall be divided into two groups: value bits and padding bits (there need\n  not be any of the latter). If there are N value bits, each bit shall represent a different\n  power of 2 between 1 and 2<sup>N\u22121</sup>, so that objects of that type shall be capable of\n  representing values from 0 to 2<sup>N \u2212 1</sup> using a pure binary representation; this shall be\n  known as the value representation. The values of any padding bits are unspecified.</p>\n<p id=\"so_11138188_11139915_3\">For signed integer types, the bits of the object representation shall be divided into three\n  groups: value bits, padding bits, and the sign bit. There need not be any padding bits;\n  signed char shall not have any padding bits. There shall be exactly one sign bit.\n  Each bit that is a value bit shall have the same value as the same bit in the object\n  representation of the corresponding unsigned type (if there are M value bits in the signed\n  type and N in the unsigned type, then M \u2264 N). If the sign bit is zero, it shall not affect the resulting value. If the sign bit is one, the value shall be modified in one of the\n  following ways:</p>\n<p id=\"so_11138188_11139915_4\">\u2014 the corresponding value with sign bit 0 is negated (sign and magnitude);</p>\n<p id=\"so_11138188_11139915_5\">\u2014 the sign bit has the value \u2212(2<sup>M</sup>) (two\u2019s complement);</p>\n<p id=\"so_11138188_11139915_6\">\u2014 the sign bit has the value \u2212(2<sup>M \u2212 1</sup>) (ones\u2019 complement).</p>\n<p id=\"so_11138188_11139915_7\">Which of these applies is implementation-defined, as is whether the value with sign bit 1\n  and all value bits zero (for the first two), or with sign bit and all value bits 1 (for ones\u2019 complement), is a trap representation or a normal value. In the case of sign and\n  magnitude and ones\u2019 complement, if this representation is a normal value it is called a\n  negative zero.</p>\n</blockquote>\n<h3>Summmary</h3>\n<p>I think the intend is the same for both standard.</p>\n<ul>\n<li><p><code>char</code>, <code>signed char</code> and <code>unsigned char</code> have all bits participating in the value</p></li>\n<li><p>other integer types may have <em>padding bits</em> which don't participate in the value. A wrong bit pattern in them may imply a not valid value.</p></li>\n<li><p>the interpretation is a pure binary representation, something whose definition is expanded in the C11 citation above.</p></li>\n</ul>\n<p>Two things which may be not clear:</p>\n<ul>\n<li><p>can -0 (for <em>sign and magnitude</em> and _ones' complement) be a trap value in C++</p></li>\n<li><p>can one of the padding bits be a parity bit (i.e. can we modify the representation if we ensure that the padding bits aren't modified or not)</p></li>\n</ul>\n<p>I'd be conservative and assume yes for the both.</p>\n", "LastEditorUserId": "701092", "LastActivityDate": "2013-06-21T19:56:38.207", "Score": "14", "CreationDate": "2012-06-21T14:02:32.813", "ParentId": "11138188", "CommentCount": "1", "OwnerUserId": "136208", "LastEditDate": "2013-06-21T19:56:38.207"}, "11138189": {"Id": "11138189", "PostTypeId": "2", "Body": "<p><strong>Yes, it's guaranteed.</strong></p>\n<p>Turning all bytes/bits of an integer type is guaranteed to make an instance of the type have the value of zero (<code>0</code>), as said by the below snippet(s) from the mentioned standard.</p>\n<hr>\n<blockquote>\n<h3>3.9.1/7   Fundamental types</h3>\n<p id=\"so_11138188_11138189_0\">A synonym for integral type is integer type. <em>The representations of\n  integral types shall define values by use of a pure binary numeration\n  system.</em><sup>49</sup></p>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_11138188_11138189_1\"><sup>49</sup><sub>positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin with 1, and are multiplied by successive integral power of 2, except perhaps for the bit with the highest position. (Adapted from the <em>American National Dictionary for Information Processing Systems</em>.)</sub></p>\n</blockquote>\n</hr>", "LastEditorUserId": "560648", "LastActivityDate": "2013-04-16T10:51:06.980", "Score": "2", "CreationDate": "2012-06-21T12:30:01.163", "ParentId": "11138188", "CommentCount": "6", "OwnerUserId": "1090079", "LastEditDate": "2013-04-16T10:51:06.980"}, "bq_ids": {"n4140": {"so_11138188_11139915_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7216}, "so_11138188_11138189_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 7216}, "so_11138188_11138189_0": {"length": 14, "quality": 0.875, "section_id": 7216}, "so_11138188_11139915_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 7210}, "so_11138188_11138188_4": {"length": 36, "quality": 0.972972972972973, "section_id": 5316}}, "n3337": {"so_11138188_11138189_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 6960}, "so_11138188_11138188_4": {"length": 36, "quality": 0.972972972972973, "section_id": 5113}, "so_11138188_11139915_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6960}, "so_11138188_11139915_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 6954}, "so_11138188_11138189_0": {"length": 14, "quality": 0.875, "section_id": 6960}}, "n4659": {"so_11138188_11138189_0": {"length": 14, "quality": 0.875, "section_id": 8725}, "so_11138188_11139915_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 8725}, "so_11138188_11138188_4": {"length": 24, "quality": 0.6486486486486487, "section_id": 6740}, "so_11138188_11139915_0": {"length": 20, "quality": 0.7407407407407407, "section_id": 8719}, "so_11138188_11138189_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 8725}, "so_11138188_11138188_3": {"length": 7, "quality": 0.5384615384615384, "section_id": 6901}, "so_11138188_17248140_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 6901}}}, "17248140": {"Id": "17248140", "PostTypeId": "2", "Body": "<p>No. I don't believe it's actually guaranteed, but it's rather vague.</p>\n<p>I'd be <em>very</em> surprised if there has ever been a C++ implementation in which all-bits-zero is <em>not</em> a representation of <code>0</code>, but I believe such an implementation could be conforming (though perverse).</p>\n<p>Let's start by considering the C99 standard. (Yes, I know, the question is about C++; bear with me.) It says that the bits of the object representation of an unsigned integer type are divided into two groups: value bits and padding bits (there needn't be any padding bits, and most implementations don't have them). The value bits make up a pure binary representation; the padding bits do not contribute to the value. Some combinations of padding bits might generate a <em>trap representation</em>.</p>\n<p>Signed types are similar, with the addition of a single sign bit. Signed types can be represented using either <em>sign and magnitude</em>, or <em>two's complement</em>, or <em>one's complement</em> -- but again, any padding bits do not contribute to the value, and some combinations of padding bits can generate trap representations.</p>\n<p>This description does not exclude the possibility that, for example, an integer type wider than <code>char</code>  might have a single padding bit that must always be 1; if it's 0, you have a trap representation. Or, perhaps more plausibly, it might have an odd parity bit.</p>\n<p><em>After</em> the C99 standard was published, the second Technical Corrigendum added the following sentence, which also appears in C11.</p>\n<blockquote>\n<p id=\"so_11138188_17248140_0\">For any integer type, the object representation where all the bits are\n  zero shall be a  representation of the value zero in that type.</p>\n</blockquote>\n<p>I'll emphasize that this was added as normative text, not as a footnote, which suggests (but doesn't prove) that the committee members felt that the guarantee wasn't already implicit in the C99 standard.</p>\n<p>(C90 was far less specific about how integer types are represented. It didn't mention padding bits, trap representations or two's-complement et al. I would argue that it gave implementations at least as much flexibility as C99.)</p>\n<p>So starting with C99 TC2, the C language guarantees that all-bits-zero is a representation of zero for any integer type. In C99 and C90, that guarantee is not stated.</p>\n<p>That's C. What about C++?</p>\n<p>The 2011 C++ standard seems to provide only slightly more specificity about integer type representations as the old 1990 C standard. It does require signed types to be represented using either 2's complement, 1's complement, or signed magnitude. It also requires a \"pure binary numeration system\". It <em>doesn't</em> mention \"trap representations\", nor does it discuss padding bits except in the context of bit fields.</p>\n<p>So, in both C90 and pre-TC2 C99 it was at least theoretically possible for all-bits-zero to be a trap representation for an integer type. The C++ standard's requirements for integer types are very similar to those of C90 and C99. It does require a \"pure binary representation\", but I would argue that that applies, as it does in C99, only to the value bits; though C++ doesn't mention padding bits, it doesn't forbid them.</p>\n<p>Again, this is mainly of theoretical interest (thus the \"language-lawyer\" tag). The C committee felt free to impose the requirement that all-bits-zero must be a representation of zero because <em>all</em> implementations already satisfied it. The same almost certainly applies to C++.</p>\n", "LastActivityDate": "2013-06-22T06:51:46.057", "CommentCount": "0", "CreationDate": "2013-06-22T06:51:46.057", "ParentId": "11138188", "Score": "0", "OwnerUserId": "827263"}, "15045894": {"Id": "15045894", "PostTypeId": "2", "Body": "<p>Nope. For example, there's nothing in the Standard banning a bias-based representation, it only mandates that it is binary. </p>\n", "LastActivityDate": "2013-02-23T21:25:11.933", "CommentCount": "0", "CreationDate": "2013-02-23T21:25:11.933", "ParentId": "11138188", "Score": "2", "OwnerUserId": "298661"}, "11138188": {"ViewCount": "2979", "Body": "<blockquote>\n<p id=\"so_11138188_11138188_0\"><sub>This is not a matter of <em>recommended practise</em> (nor <em>undefined behavior</em>), but about what the <em>c++</em>-standard actually guarantees in the matter of turning all bytes of an integer type to the value of <code>(unsigned char)0</code>.</sub></p>\n</blockquote>\n<hr>\n<h2>The Question(s)</h2>\n<p>In the snippet below, is the expression used by the <em>if-statement</em> guaranteed to be evaluated to <em>true</em> in <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a>?</p>\n<pre><code>std::memset (\n  reinterpret_cast&lt;char*&gt; (&amp;a), // int a;\n  (unsigned char)0,\n  sizeof (int)\n);\n\nif (a == 0) {\n  ...\n}\n</code></pre>\n<p>By reading the quotations from the C99 and C++11 standard (further down in this post) we find that C99 explicitly <strong>guarantees</strong> that an integer type with all bits set to <code>0</code> will represent the value <code>0</code> in that type.</p>\n<p><strong>I cannot find this guarantee in the C++11 standard.</strong></p>\n<ul>\n<li><em>Is there no such guarantee?</em></li>\n<li><em>Is the result of the previous snippet really implementation-specific?</em></li>\n</ul>\n<hr>\n<hr>\n<h2>In C99 (ISO/IEC 9899:1999)</h2>\n<blockquote>\n<h3>5.2.1.2/1 Multibyte characters</h3>\n<p id=\"so_11138188_11138188_1\">A byte with all bits zero shall be interpreted as a null character\n  independent of shift state. Such a byte shall not occur as part of any\n  other multibyte character.</p>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<h3>6.2.6.2/1 Integer types</h3>\n<p id=\"so_11138188_11138188_2\">The values of any padding bits are unspeci\ufb01ed.<sup>45)</sup> A valid\n  (non-trap) object representation of a signed integer type where the\n  sign bit is zero is a valid object representation of the corresponding\n  unsigned type, and shall represent the same value.</p>\n<p id=\"so_11138188_11138188_3\"><strong>For any integer\n  type, the object representation where all the bits are zero shall be a\n  representation of the value zero in that type.</strong></p>\n</blockquote>\n<hr>\n<hr>\n<h2>In C++11 (ISO/IEC 14882:2011)</h2>\n<blockquote>\n<h3>2.3/3\u00a0\u00a0\u00a0\u00a0\u00a0Character sets\u00a0\u00a0\u00a0\u00a0 [lex.charset]</h3>\n<p id=\"so_11138188_11138188_4\">The basic execution character set and the basic execution\n  wide-character set shall each contain all the members of the basic\n  source character set, plus control characters representing alert,\n  backspace, and carriage return, plus <strong>a null character</strong> (respectively,\n  null wide character), whose representation <strong>has all zero bits</strong>.</p>\n</blockquote>\n</hr></hr></hr></hr></hr>", "AcceptedAnswerId": "11139915", "Title": "Set all bytes of int to (unsigned char)0, guaranteed to represent zero?", "CreationDate": "2012-06-21T12:30:00.337", "Id": "11138188", "CommentCount": "4", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2013-06-21T19:57:24.503", "LastEditorUserId": "701092", "LastActivityDate": "2013-06-22T06:51:46.057", "Score": "43", "OwnerUserId": "1090079", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "4"}});