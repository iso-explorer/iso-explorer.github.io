post_cb({"10521969": {"ParentId": "10521856", "CommentCount": "0", "Body": "<p>C++ compilers are only allowed, with a few exceptions, to optimize statements to something so long as that something else behaves \"as-if\" it were performing the non-optimized statements.</p>\n<p>Reordering the statements of an if/else tower would not behave \"as-if\" it had not been reordered (unless of course the compiler can prove that it would be, like when some checks are always true or false and have no side effects).</p>\n<p>You absolutely can depend on the ordering of your if/else tower.</p>\n", "OwnerUserId": "301883", "PostTypeId": "2", "Id": "10521969", "Score": "0", "CreationDate": "2012-05-09T18:28:39.583", "LastActivityDate": "2012-05-09T18:28:39.583"}, "10521856": {"CommentCount": "0", "AcceptedAnswerId": "10522106", "PostTypeId": "1", "LastEditorUserId": "149392", "CreationDate": "2012-05-09T18:20:36.303", "LastActivityDate": "2012-05-09T18:56:22.693", "LastEditDate": "2012-05-09T18:35:30.250", "ViewCount": "787", "FavoriteCount": "1", "Title": "Are ifs tested in the order they have been written is a if-else...if-else...if-else block?", "Id": "10521856", "Score": "6", "Body": "<p>Is there any guarantee, that the ifs of a <code>if-else if-else if-else</code> block, are tested in the order in which they have been written.</p>\n<p>I am asking that because I am often trying to optimizing my code by putting the most frequent cases firsts and I want to know if some optimisations done by the compiler could change the order in which the if are tested.</p>\n<p>So, if I am writting a code like that:</p>\n<pre><code>    if (cond1) // First if (for the case I have the most often)\n    {\n            doSomething1();\n    }\n    else if (cond2) // Second if (for the second case I have the most often)\n    {\n            doSomething2();\n    }\n    else if (cond3) // Third if (for the third case I have the most often)\n    {\n            doSomething3();\n    }\n    else\n    {\n            doElse();\n    }\n</code></pre>\n<p><em>Is there any guarantee that after being compiled (for release), the first if will be tested, then the second if, then the third if (and finally the else is executed if none of the condition was true).</em></p>\n<p>I know that when debugging, the ifs are executed in the order I wrote them, but will it stays true when the program is compiled for release (I am mostly using recent version of g++ and visual studio).</p>\n<p>Also, since, the condition can have effect on the environnement (like <code>if (i=a)</code> or <code>if(myfunction())</code>), they should be executed as written, but I wonder if I am missing some optimisation that the compiler could do, that would change the order in which the ifs are tested. Especially, if the condition don't have side effects like that:</p>\n<pre><code>void test(int a)\n{\n    if (a == 1)\n    {\n        doSomething1();\n    }\n    else if (a == 2)\n    {\n        doSomething1();\n    }\n    else if (a == 3)\n    {\n        doSomething1();\n    }\n    else\n    {\n        doSomething1();\n    }\n}\n</code></pre>\n", "Tags": "<c++><if-statement>", "OwnerUserId": "1262104", "AnswerCount": "5"}, "10521979": {"ParentId": "10521856", "CommentCount": "0", "Body": "<p>No.  The only thing that is guaranteed is that the observable behavior\nbe \"as if\" the ifs were evaluated in order.  The evaluation of the\nconditions may even be interleaved, with part of cond2 preceding cond1,\nand another part after cond1 has been evaluated.  On the other hand, the\nguarantee that the results will be \"as if\" the ifs had been evaluated in\norder, if some of the conditions have side effects, those side effects\nwon't occur if one of the earlier ifs was true.</p>\n<p>With regards to optimization, by all means put the most likely \nconditions first.  In practice, the compiler will only move code if it\nknows that the movement will improve things, so if the conditions are\nmore or less independent, and the compiler cannot \"optimize\" them by\nfolding parts of them, then the order will be preserved.  Unless the\ncompiler is exceptionally good, and can determine that your ordering\nwasn't optimal (on the basis of profiler output).</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "10521979", "Score": "5", "CreationDate": "2012-05-09T18:29:17.650", "LastActivityDate": "2012-05-09T18:29:17.650"}, "10521888": {"ParentId": "10521856", "CommentCount": "0", "Body": "<p>yes, the conditions are checked in the order of the if, else if, else structure.\nWithin a given conditional check, things can be tweaked a bit with parentheses.</p>\n", "OwnerUserId": "1345223", "PostTypeId": "2", "Id": "10521888", "Score": "0", "CreationDate": "2012-05-09T18:22:52.507", "LastActivityDate": "2012-05-09T18:22:52.507"}, "10522106": {"ParentId": "10521856", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From C++03, \u00a7 6.4 Selection Statements:</p>\n<blockquote>\n<p id=\"so_10521856_10522106_0\">1 <pre>selection-statement:\n     if ( <i>condition</i> ) <i>statement</i>\n     if ( <i>condition</i> ) <i>statement</i> else <i>statement</i>\n     switch ( <i>condition</i> ) <i>statement</i>\n</pre>\n  [...]\n  If the substatement in a selection-statement is a single statement and not a <i>compound-statement</i>, it is as if it was rewritten to be a compound-statement containing the original substatement. [Example:</p>\n<pre><code>  if (x)\n     int i;\n</code></pre>\n<p id=\"so_10521856_10522106_1\">can be equivalently rewritten as</p>\n<pre><code>  if (x) {\n      int i;\n  }</code></pre>\n<p id=\"so_10521856_10522106_2\">[...]<br/></p>\n<h3>6.4.1 The <code>if</code> statement</h3>\n<p id=\"so_10521856_10522106_3\">1 If the condition (6.4) yields <code>true</code> the first substatement is executed. If the <code>else</code> part of the selection statement is present and the condition yields <code>false</code>, the second substatement is executed. [...]</p>\n</blockquote>\n<p>From 6.4 1, your sample code is equivalent to:</p>\n<pre><code>if (cond1) {\n    doSomething1();\n} else {\n    if (cond2) {\n        doSomething2();\n    } else {\n        if (cond3) {\n            doSomething3();\n        } else {\n            doElse();\n        }\n    }\n}\n</code></pre>\n<p>Note this doesn't mean the code is transformed to the above, but rather that the two must behave the same.</p>\n<p>From 6.4.1, an inner <code>if</code> statement is executed when the condition for the outer <code>if</code> is <code>false</code>. If the condition is <code>true</code>, the first branch is executed. While the standard doesn't explicitly state the second branch isn't executed when the condition is <code>true</code>, it's strongly implied by omission.</p>\n<p>According to \u00a7 1.9 1:</p>\n<blockquote>\n<p id=\"so_10521856_10522106_4\">The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine. This International Standard places no requirement on the structure of conforming implementations. In particular, they need not copy or emulate the structure of the abstract machine. Rather, conforming implementations are required to emulate (only) the observable behavior of the abstract machine as explained below.<sup>5)</sup></p>\n<p id=\"so_10521856_10522106_5\"><sup>5)</sup> This provision is sometimes called the \u201cas-if\u201d rule, because an implementation is free to disregard any requirement of this International Standard as long as the result is <em>as if</em> the requirement had been obeyed, as far as can be determined from the observable behavior of the program. For instance, an actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no side effects affecting the observable behavior of the program are produced.</p>\n</blockquote>\n<p>So part of the <code>else</code> substatement may be executed if it's side-effect free and the results discarded even if the condition turns out to be <code>true</code>. A substatement condition, for example, may be partially executed within the processor <a href=\"http://en.wikipedia.org/wiki/Instruction_pipeline\" rel=\"noreferrer\">pipeline</a> if <a href=\"http://en.wikipedia.org/wiki/Branch_predictor\" rel=\"noreferrer\">branch prediction</a> incorrectly predicts that the condition will be <code>false</code>. However, the affects of this must not be noticeable, so (from your perspective) it's as if the substatements behave as outlined by \u00a7s 6.4 1 and 6.4.1 1.</p>\n", "OwnerUserId": "90527", "LastEditorUserId": "90527", "LastEditDate": "2012-05-09T18:56:22.693", "Id": "10522106", "Score": "6", "CreationDate": "2012-05-09T18:37:55.197", "LastActivityDate": "2012-05-09T18:56:22.693"}, "bq_ids": {"n4140": {"so_10521856_10522106_3": {"section_id": 3888, "quality": 1.0, "length": 17}, "so_10521856_10522106_0": {"section_id": 3882, "quality": 0.8181818181818182, "length": 18}, "so_10521856_10522106_5": {"section_id": 5797, "quality": 0.9285714285714286, "length": 39}, "so_10521856_10522106_4": {"section_id": 5797, "quality": 0.8648648648648649, "length": 32}}, "n3337": {"so_10521856_10522106_3": {"section_id": 3748, "quality": 1.0, "length": 17}, "so_10521856_10522106_4": {"section_id": 5570, "quality": 0.8648648648648649, "length": 32}, "so_10521856_10522106_5": {"section_id": 5570, "quality": 0.9285714285714286, "length": 39}, "so_10521856_10522106_0": {"section_id": 3742, "quality": 0.8181818181818182, "length": 18}}, "n4659": {"so_10521856_10522106_3": {"section_id": 4772, "quality": 1.0, "length": 17}, "so_10521856_10522106_4": {"section_id": 7256, "quality": 0.8648648648648649, "length": 32}, "so_10521856_10522106_5": {"section_id": 7256, "quality": 0.9285714285714286, "length": 39}, "so_10521856_10522106_0": {"section_id": 4771, "quality": 0.8181818181818182, "length": 18}}}, "10521890": {"ParentId": "10521856", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_10521856_10521890_0\">Is there any guarantee that after being compiled (for release), the first if will be tested, then the second if, then the third if (and finally the else is executed if none of the condition was true).</p>\n</blockquote>\n<p>Yes, but not specifically for if statements, for <em>all</em> of your (single threaded) code.</p>\n<p>C++ code is executed top down, from the beginning to the end.  The only time this may not be the case is when you make asynchronous calls or have multiple threads calling the same code simultaneously.</p>\n", "OwnerUserId": "1053", "PostTypeId": "2", "Id": "10521890", "Score": "7", "CreationDate": "2012-05-09T18:23:02.337", "LastActivityDate": "2012-05-09T18:23:02.337"}});