post_cb({"2220266": {"Id": "2220266", "PostTypeId": "2", "Body": "<p>You code has no scene. Returned structure is allocated on stack, so assignment result is immediately will be lost.</p>\n<p>Your function should eiter allocate new instance of A by:</p>\n<pre><code>new A()\n</code></pre>\n<p>In this case better signature </p>\n<pre><code>A* f(){ ...\n</code></pre>\n<p>Or return existing instance, for example:</p>\n<pre><code>static A globalInstance;\nA&amp; f(){ \n  return globalInstance;\n}\n</code></pre>\n", "LastActivityDate": "2010-02-08T08:16:42.500", "Score": "-2", "CreationDate": "2010-02-08T08:16:42.500", "ParentId": "2220230", "CommentCount": "12", "OwnerUserId": "149818"}, "2220672": {"Id": "2220672", "PostTypeId": "2", "Body": "<p>It becomes obvious when you consider that the compiler will generate a default constructor, a default copy constructor, and a default copy assignment operator for you, in case your struct/class does not contain reference members. Then, think of that the standard allows you to call member methods on temporaries, that is, you can call non-const members on non-const temporaries.</p>\n<p>See this example:</p>\n<pre><code>struct Foo {};\nFoo foo () {\n    return Foo();\n}\n\nstruct Bar {\nprivate:\n    Bar&amp; operator = (Bar const &amp;); // forbid\n};\nBar bar () {\n    return Bar();\n}\nint main () {\n    foo() = Foo(); // okay, called operator=() on non-const temporarie\n    bar() = Bar(); // error, Bar::operator= is private\n}\n</code></pre>\n<p>If you write</p>\n<pre><code>struct Foo {};\nconst Foo foo () { // return a const value\n    return Foo();\n}\n\nint main () {\n    foo() = Foo(); // error\n}\n</code></pre>\n<p>i.e. if you let function foo() return a <strong>const</strong> temporary, then a compile error occurs.</p>\n<p>To make the example complete,  here is how to call a member of a const temporarie:</p>\n<pre><code>struct Foo {\n    int bar () const { return 0xFEED; }\n    int frob ()      { return 0xFEED; }\n};\nconst Foo foo () {\n    return Foo();\n}\n\nint main () {\n    foo().bar(); // okay, called const member method\n    foo().frob(); // error, called non-const member of const temporary\n}\n</code></pre>\n<p>You could define the lifetime of a temporary to be within the current expression. And then that's why you can also modify member variables; if you couldn't, than the possibility of being able to call non-const member methods would be led ad absurdum.</p>\n<p>edit: And here are the required citations:</p>\n<p><strong>12.2 Temporary objects:</strong> </p>\n<ul>\n<li>3) [...] Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. [...]</li>\n</ul>\n<p>and then (or better, before)</p>\n<p><strong>3.10 Lvalues and rvalues:</strong></p>\n<ul>\n<li>10) An lvalue for an object is necessary in order to modify the object except that an rvalue of class type can also be used to modify its referent under certain circumstances. [Example: a member function called for an object (9.3) can modify the object. ]</li>\n</ul>\n<p>And an example use: <a href=\"http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Named_Parameter\" rel=\"nofollow noreferrer\">http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Named_Parameter</a></p>\n", "LastEditorUserId": "76722", "LastActivityDate": "2010-02-08T10:15:29.257", "Score": "0", "CreationDate": "2010-02-08T09:52:06.230", "ParentId": "2220230", "CommentCount": "4", "LastEditDate": "2010-02-08T10:15:29.257", "OwnerUserId": "76722"}, "2220254": {"Id": "2220254", "PostTypeId": "2", "Body": "<p>Edit: Ok, I guess I finally have something from the standard:</p>\n<p>Note that <code>v</code> is of type <code>int</code> which has an built-in assignment operator:</p>\n<blockquote>\n<p id=\"so_2220230_2220254_0\"><strong>13.3.1.2 Operators in expressions</strong></p>\n<p id=\"so_2220230_2220254_1\">4 For the built-in assignment operators, conversions of the left operand are restricted as follows:\n  \u2014 no temporaries are introduced to hold the left operand, and [...]</p>\n</blockquote>\n<p><code>fun1()</code> should return a reference. A non-reference/pointer return type of a function is a r-value.</p>\n<blockquote>\n<p id=\"so_2220230_2220254_2\"><strong>3.10 Lvalues and rvalues</strong></p>\n<p id=\"so_2220230_2220254_3\">5 The result of calling a function that does not return an lvalue reference is an rvalue [...]</p>\n</blockquote>\n<p>Thusly, <code>fun1().v</code> is a rvalue.</p>\n<blockquote>\n<p id=\"so_2220230_2220254_4\"><strong>8.3.2 References</strong></p>\n<p id=\"so_2220230_2220254_5\">2 A reference type that is declared\n  using &amp; is called an lvalue reference,\n  and a reference type that is declared\n  using &amp;&amp; is called an rvalue\n  reference. Lvalue references and\n  rvalue references are distinct types.</p>\n</blockquote>\n", "LastEditorUserId": "66692", "LastActivityDate": "2010-02-08T10:44:17.763", "Score": "2", "CreationDate": "2010-02-08T08:12:33.703", "ParentId": "2220230", "CommentCount": "9", "LastEditDate": "2010-02-08T10:44:17.763", "OwnerUserId": "66692"}, "2221470": {"Id": "2221470", "PostTypeId": "2", "Body": "<p>A member of an rvalue expression is an rvalue.</p>\n<p>The standard states in 5.3.5 [expr.ref]:</p>\n<blockquote>\n<p id=\"so_2220230_2221470_0\">If E2 is declared to have type\n  \u201creference to T\u201d, then E1.E2 is an\n  lvalue [...]\n  - If E2 is a non-static data member, and the type of E1 is \u201ccq1 vq1 X\u201d, and\n  the type of E2 is \u201ccq2 vq2 T\u201d, the\n  expression designates the named member\n  of the object designated by the first\n  expression. If E1 is an lvalue, then\n  E1.E2 is an lvalue.</p>\n</blockquote>\n", "LastActivityDate": "2010-02-08T12:20:31.767", "Score": "11", "CreationDate": "2010-02-08T12:20:31.767", "ParentId": "2220230", "CommentCount": "7", "OwnerUserId": "36565"}, "2220278": {"Id": "2220278", "PostTypeId": "2", "Body": "<p>I've noticed that gcc tends to have very few compunctions about using rvalues as lvalues in assignment expressions.  This, for example, compiles just fine:</p>\n<pre><code>class A {\n};\n\nextern A f();\n\nvoid g()\n{\n   A myA;\n   f() = myA;\n}\n</code></pre>\n<p>Why that's legal and this isn't (i.e. it doesn't compile) though really confuses me:</p>\n<pre><code>extern int f();\n\nvoid g()\n{\n   f() = 5;\n}\n</code></pre>\n<p>IMHO, the standard committee has some explaining to do with regards to lvalues, rvalues and where they can be used.  It's one of the reasons I'm so interested in <a href=\"https://stackoverflow.com/questions/2169932/non-class-rvalues-always-have-cv-unqualified-types\">this question about rvalues</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-02-08T08:46:26.920", "Score": "0", "CreationDate": "2010-02-08T08:19:59.200", "ParentId": "2220230", "CommentCount": "7", "LastEditDate": "2017-05-23T12:09:44.893", "OwnerUserId": "167958"}, "43197343": {"Id": "43197343", "PostTypeId": "2", "Body": "<p>This is a good time to learn about what <strong>xvalues</strong> an <strong>glvalues</strong> are.</p>\n<p><strong>Rvalues</strong> can be of two types - <strong>prvalues</strong> and <strong>xvalues</strong>.  According to the new C++17 standard </p>\n<blockquote>\n<p id=\"so_2220230_43197343_0\">A <strong>prvalue</strong> is an expression whose evaluation initializes an object, bit-field, or operand of an operator, as specified by the context in which it appears.</p>\n</blockquote>\n<p>so something like <code>fun()</code> in your example evaluates to an prvalue (which is an rvalue).  This also tells us that <code>fun().v</code> is not a prvalue, since it is not a vanilla initialization.   </p>\n<p><strong>Xvalues</strong> which are also rvalues are defined like so </p>\n<blockquote>\n<p id=\"so_2220230_43197343_1\">An <strong>xvalue</strong> (an \"eXpiring\" value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example). Certain kinds of expressions involving rvalue references (8.3.2) yield xvalues. [ Example: The result of calling a function whose return type is an rvalue reference to an object type is an xvalue (5.2.2). - end example ]</p>\n</blockquote>\n<p>In addition to rvalues, another umbrella value category is a <strong>glvalue</strong> which be of two types <strong>xvalues</strong> and the traditional <strong>lvalues</strong>.  </p>\n<p>We have at this point defined the essential value categories.  This can be visualized like so</p>\n<h2><a href=\"https://i.stack.imgur.com/VNVwl.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/VNVwl.png\"/></a></h2>\n<p>The category <strong>glvalue</strong> can broadly be thought to mean what <strong>lvalues</strong> were supposed to mean before move semantics became a thing - a thing that can be on the left hand side of an expression.  <strong>glvalue</strong> means generalized lvalue. </p>\n<p>If we look at the definition of an <strong>xvalue</strong>, then it says something is an <strong>xvalue</strong> if it is near the end of its lifetime.  In your example, <code>fun().v</code> is near the end of its lifetime.  So its resources can be moved.  And since its resources can be moved it is not an lvalue, therefore your expression fits in the only leaf value category that remains - an <strong>xvalue</strong>.  </p>\n", "LastActivityDate": "2017-04-04T02:36:01.423", "Score": "0", "CreationDate": "2017-04-04T02:36:01.423", "ParentId": "2220230", "CommentCount": "0", "OwnerUserId": "5501675"}, "bq_ids": {"n4140": {"so_2220230_2220254_3": {"length": 6, "quality": 0.6666666666666666, "section_id": 5940}, "so_2220230_2221470_0": {"length": 28, "quality": 1.0, "section_id": 6007}, "so_2220230_43197343_1": {"length": 32, "quality": 0.7804878048780488, "section_id": 7230}, "so_2220230_2220254_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 585}, "so_2220230_2220254_5": {"length": 20, "quality": 1.0, "section_id": 3219}}, "n3337": {"so_2220230_2220254_5": {"length": 20, "quality": 1.0, "section_id": 3093}, "so_2220230_2221470_0": {"length": 28, "quality": 1.0, "section_id": 5775}, "so_2220230_2220254_3": {"length": 6, "quality": 0.6666666666666666, "section_id": 5711}, "so_2220230_2220254_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 575}, "so_2220230_43197343_1": {"length": 31, "quality": 0.7560975609756098, "section_id": 6974}}, "n4659": {"so_2220230_2220254_3": {"length": 6, "quality": 0.6666666666666666, "section_id": 7424}, "so_2220230_43197343_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 8741}, "so_2220230_2220254_5": {"length": 20, "quality": 1.0, "section_id": 3976}, "so_2220230_2221470_0": {"length": 28, "quality": 1.0, "section_id": 7506}, "so_2220230_43197343_1": {"length": 24, "quality": 0.5853658536585366, "section_id": 8741}, "so_2220230_2220254_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 608}}}, "2220230": {"ViewCount": "1710", "Body": "<p>A function call returning a structure is an rvalue expression, but what about its members?<br>\nThis piece of code works well with my g++ compiler, but gcc gives a error saying \"lvalue required as left operand of assignment\":</br></p>\n<pre><code>struct A\n{\n    int v;\n};\n\nstruct A fun()\n{\n    struct A tmp;\n    return tmp;\n}\n\nint main()\n{\n    fun().v = 1;\n}\n</code></pre>\n<p>gcc treats <code>fun().v</code> as rvalue, and I can understand that.<br>\nBut g++ doesn't think the assignment expression is wrong. Does that mean fun1().v is lvalue in C++?<br>\nNow the problem is, I searched the C++98/03 standard, finding nothing telling about whether <code>fun().v</code> is lvalue or rvalue.<br>\nSo, what is it?</br></br></br></p>\n", "AcceptedAnswerId": "2221470", "Title": "Is a member of an rvalue structure an rvalue or lvalue?", "CreationDate": "2010-02-08T08:07:40.000", "Id": "2220230", "CommentCount": "11", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2010-02-08T08:12:30.273", "LastEditorUserId": "87234", "LastActivityDate": "2017-04-04T02:36:01.423", "Score": "24", "OwnerUserId": "154939", "Tags": "<c++><structure><lvalue><rvalue>", "AnswerCount": "6"}});