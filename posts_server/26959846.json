post_cb({"bq_ids": {"n4140": {"so_26959846_26959914_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 480}}, "n3337": {"so_26959846_26959914_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 471}}, "n4659": {"so_26959846_26959914_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 502}}}, "26959914": {"Id": "26959914", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"noreferrer\">Copy elision</a> will do the job just fine. Even a C++03 compiler will elide the temporary.<br>\nIn particular, NRVO (named return value optimization) will, for this code,</br></p>\n<pre><code>MatrixXd foo()\n{\n    MatrixXd huge_matrix(N,N);\n    return huge_matrix; \n}\n\nMatrixXd A = foo();\n</code></pre>\n<p>construct <code>huge_matrix</code> right inside <code>A</code>. The C++03 standard specifies in [class.copy]/15:</p>\n<blockquote>\n<p id=\"so_26959846_26959914_0\">This elision of copy operations is permitted in the following\n  circumstances (<strong>which may be combined to eliminate multiple copies</strong>):</p>\n<ul>\n<li>in a <code>return</code> statement in a function with a class return type, when the expression is the name of a non-volatile automatic object with the same cv-unqualified type as the function return type, the\n  copy operation can be omitted by constructing the automatic object\n  directly into the function\u2019s return value</li>\n<li>when a temporary class object that has not been bound to a reference (12.2) would be copied to a class object with the same\n  cv-unqualified type, the copy operation can be omitted by constructing\n  the temporary object directly into the target of the omitted copy</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2014-11-16T17:30:43.987", "CommentCount": "7", "CreationDate": "2014-11-16T17:30:43.987", "ParentId": "26959846", "Score": "5", "OwnerUserId": "3647361"}, "26959846": {"ViewCount": "1226", "Body": "<p>I have couple of question about Eigen:</p>\n<ol>\n<li><p>Does anyone know if there is any plan to support move semantics in Eigen anytime soon? Couldn't find anything on the TODO list of the Eigen3 web page. Right now I am using the <code>swap</code> trick to get rid of temporaries, like</p>\n<pre><code>MatrixXd foo()\n{\n    MatrixXd huge_matrix(N,N); // size N x N where N is quite large\n    // do something here with huge_matrix\n    return huge_matrix; \n}\n\nMatrixXd A(N, N); \nA.swap(foo());\n</code></pre>\n<p>I'd very much like to write the above <code>swap</code> line in a C++11 style like</p>\n<pre><code>A = foo();\n</code></pre>\n<p>and not to have to worry about the temporary returned by <code>foo()</code>. </p></li>\n<li>Can a C++98/C++03 compiler optimize the code <code>A = foo();</code> to get rid of this temporary? Or the safest bet is to use <code>swap()</code>?</li>\n</ol>\n", "AcceptedAnswerId": "26959914", "Title": "Move semantics in Eigen", "CreationDate": "2014-11-16T17:25:58.373", "Id": "26959846", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-11-16T17:30:43.987", "Score": "6", "OwnerUserId": "3093378", "Tags": "<c++><c++11><move><eigen>", "AnswerCount": "1"}});