post_cb({"bq_ids": {"n4140": {"so_16533295_16533353_0": {"length": 14, "quality": 1.0, "section_id": 380}}, "n3337": {"so_16533295_16533353_0": {"length": 14, "quality": 1.0, "section_id": 371}}, "n4659": {"so_16533295_16533353_0": {"length": 14, "quality": 1.0, "section_id": 395}}}, "16533353": {"Id": "16533353", "PostTypeId": "2", "Body": "<p>I think your question is misleading.</p>\n<pre><code>struct A {\n    int data[3] = { 1, 2, 3 };\n};\n</code></pre>\n<p>A new feature of C++11, see [class.mem]: This syntax initializes the data member <code>data</code> during the construction of an object of type <code>A</code>. It has nothing to do with initializer-lists, it's a language feature (<em>list-initialization</em> using a <em>braced-init-list</em>).</p>\n<p>It's equivalent to:</p>\n<pre><code>struct A {\n    int data[3];\n    inline A() : data{1,2,3}\n    {}\n};\n</code></pre>\n<p>Therefore, <code>data</code> is on the stack if you've created the instance of <code>A</code> on the stack, and it's on the heap if the instance has been created on the heap.</p>\n<p>I guess where the data for initialization resides (= the <code>1,2,3</code>) is implementation-defined.</p>\n<p>As <a href=\"https://stackoverflow.com/users/2368132/michael-crawford\">Michael Crawford</a> points out, there might be issues with calling <code>B(int data[])</code> (which will be decayed to <code>B(int* data)</code>), but those don't necessarily make your program ill-formed (it should still compile).</p>\n<hr>\n<p>As to passing <code>A().data</code> to the ctor of <code>B</code>:</p>\n<p><code>A()</code> creates a temporary object; its lifetime is specified in [class.temporary]/3</p>\n<blockquote>\n<p id=\"so_16533295_16533353_0\">Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created.</p>\n</blockquote>\n<p>Using them in the <em>mem-initializer-list</em> is no exception; the full-expression is <code>B::B( A().data )</code>. As this full-expression includes the ctor of <code>B</code>, the temporary introduced by <code>A()</code> and with it the data member <code>data</code> are destroyed only after the the ctor <code>B::B</code> has been executed.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-05-14T01:15:31.403", "Score": "2", "CreationDate": "2013-05-14T00:38:57.360", "ParentId": "16533295", "CommentCount": "4", "OwnerUserId": "420683", "LastEditDate": "2017-05-23T11:49:16.643"}, "16533295": {"ViewCount": "115", "Body": "<p>In other words, is the following code valid?\n-- It works with gcc 4.7, however, I am not sure is it in the standard or only implementation dependent.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>struct A {\n    int data[3] = { 1, 2, 3 };\n};\n\nstruct B {\n    B(int data[]) \n    ...\n\nstruct C : public B {\n    C() \n        : B(A().data) \n    ...\n</code></pre>\n", "Title": "Do c++ values created in an initialization list go on the stack?", "CreationDate": "2013-05-14T00:32:33.413", "LastActivityDate": "2013-05-14T01:15:31.403", "CommentCount": "1", "LastEditDate": "2013-05-14T01:12:42.393", "PostTypeId": "1", "LastEditorUserId": "198536", "Id": "16533295", "Score": "0", "OwnerUserId": "1860632", "Tags": "<c++><memory-management><standards>", "AnswerCount": "2"}, "16533351": {"Id": "16533351", "PostTypeId": "2", "Body": "<p>the int data[] in B's initialization list is a pointer to the beginning of the array rather than the entire array.  That's probably not what you want.</p>\n<p>However, if data were a Standard Template Library vector, you could use a copy constructor to copy the whole vector in a single initialization list item.</p>\n", "LastActivityDate": "2013-05-14T00:38:54.670", "CommentCount": "2", "CreationDate": "2013-05-14T00:38:54.670", "ParentId": "16533295", "Score": "1", "OwnerUserId": "2368132"}});