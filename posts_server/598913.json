post_cb({"598927": {"Id": "598927", "PostTypeId": "2", "Body": "<p>This question is a bit like \"I'm going to implement most of my library using functions, what are the common mistakes in using functions?\" It's hard to come up with sensible answers to such questions, but here's my advice - read a good book. I recommend \"<a href=\"http://www.josuttis.com/tmplbook/tmplbook.html\" rel=\"nofollow noreferrer\">C++ Templates</a>\" by Vandevoorde &amp; Josuttis,</p>\n", "OwnerDisplayName": "anon", "LastActivityDate": "2009-02-28T23:59:56.393", "Score": "4", "CreationDate": "2009-02-28T23:59:56.393", "ParentId": "598913", "CommentCount": "2"}, "598973": {"Id": "598973", "PostTypeId": "2", "Body": "<p>The <a href=\"http://www.sgi.com/tech/stl/\" rel=\"nofollow noreferrer\">STL</a> is your friend.</p>\n", "OwnerDisplayName": "Glenn", "LastActivityDate": "2009-03-01T00:25:15.133", "Score": "2", "CreationDate": "2009-03-01T00:25:15.133", "ParentId": "598913", "CommentCount": "1", "OwnerUserId": "25191"}, "599062": {"Id": "599062", "PostTypeId": "2", "Body": "<p>I tend to use templates quite a lot to avoid duplication of code, and to increase safety through compile checks.</p>\n<p>In general, it helps to think while typing about what the compiler is going to do, and how the code will be generated for each type.</p>\n<p>Being very iterative in development and building the template complexity little by little has helped me avoiding sinking in compile error messages. Don't forget to keep a simple (or mock) instantiation of the template somewhere, otherwise you might have some nasty surprises when you instantiate a monster template for the first time.</p>\n<p>Finally, when there is no way out, get to read these compile error messages! They might look quite scary at first, but they really are helpful. Maybe at first extracting the first one, copying it in a text editor and making it look pretty will help getting used to them, and it quickly becomes second nature to read through.</p>\n", "OwnerDisplayName": "small_duck", "LastActivityDate": "2009-03-01T01:37:40.730", "Score": "2", "CreationDate": "2009-03-01T01:37:40.730", "ParentId": "598913", "CommentCount": "1", "OwnerUserId": "16877"}, "600311": {"Id": "600311", "PostTypeId": "2", "Body": "<p>Template Tip of the Day:\nDid you know you can specialize chosen functions of template instantiations:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nnamespace std {\n    template&lt;&gt;\n    void vector&lt;int&gt;::clear() {\n    std::cout &lt;&lt; \"Clearing...\" &lt;&lt; std::endl;\n    resize(0);\n    }\n}\n\nint main() {\n    std::vector&lt;int&gt; v;\n    v.push_back(1);\n    v.clear();\n}\n</code></pre>\n<p>ouputs:\nClearing...</p>\n", "OwnerDisplayName": "kyku", "LastActivityDate": "2009-03-01T19:07:50.847", "Score": "3", "CreationDate": "2009-03-01T19:07:50.847", "ParentId": "598913", "CommentCount": "1", "OwnerUserId": "70514"}, "599038": {"Id": "599038", "PostTypeId": "2", "Body": "<p>I'd have to say Coplien's <a href=\"http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern\" rel=\"noreferrer\">Curiously Recurring Template Pattern (CRTP)</a> is the one template trick that I find myself reaching for over &amp; over again.  Essentially it allows you to inject statically customized functionality into a derived class by inheriting from a base class that is parameterized on the derived class name.  Mind boggling, but amazingly useful (some call it static polymorphism).</p>\n<p>Also, I'll second Neil Butterworth's advice to read \"C++ Templates\" and throw in Alexandrescu's <a href=\"http://rads.stackoverflow.com/amzn/click/0201704315\" rel=\"noreferrer\">Modern C++ Design</a>.</p>\n", "OwnerDisplayName": "Drew Hall", "LastActivityDate": "2009-03-01T01:11:01.060", "Score": "5", "CreationDate": "2009-03-01T01:11:01.060", "ParentId": "598913", "CommentCount": "0", "OwnerUserId": "23934"}, "36459298": {"Id": "36459298", "PostTypeId": "2", "Body": "<p>I've used c++ and templates a lot, including more advanced template metaprogramming and my feeling is that their usefulness is overrated.  They were originally added to the c++ language, well after the creation of c++, to tack on a generic programming capability.  This simply allows one to focus on the logic of the code without regard for types, potentially making code clearer and reusable.  </p>\n<p>My programming philosophy is to understand the original purpose and design of the language and it's features in order to really appreciate the language.  I feel template metaprogramming is bastardization of templates and should be avoided.  Templates are however useful for defining higher level generic types such as the case of Tuples.</p>\n", "OwnerDisplayName": "user2074102", "LastActivityDate": "2016-04-06T18:21:06.467", "Score": "0", "CreationDate": "2016-04-06T18:21:06.467", "ParentId": "598913", "CommentCount": "0"}, "604022": {"Body": "<p>One common mistake is that a template constructor or assignment operator will not suppress the compiler generated one:</p>\n<pre><code>template &lt;typename T&gt;\nclass A {\npublic:\n  template &lt;typename S&gt;\n  A(A&lt;S&gt; const &amp;);\n\n  template &lt;typename S&gt;\n  A &amp; operator=(A&lt;S&gt; const &amp;);\n\nprivate:\n  int * i;\n}; \n</code></pre>\n<p>Although these functions look like the copy constructor and copy assignment operator, the compiler does not see it that way and generates the implicit versions anyway.   The result is that any actions performed by these functions (eg. deep copy of a member) will not take place when the object is copied or assigned to from the same type:</p>\n<pre><code>void foo (A&lt;int&gt;);\n\nvoid bar () {\n  A&lt;int&gt; a1;\n  foo (a1);   // Implicitly generated copy ctor called\n\n  A&lt;long&gt; a2;\n  foo (a2);   // Template ctor called.\n\n  A&lt;int&gt; a3;\n  a3 = a1;   // Implicitly generated copy assignment operator called\n\n  a3 = a2;   // Template assignment operator called\n}\n</code></pre>\n<p>The reason for this behaviour is due to a special rule in overload resolution (13.3.3):</p>\n<blockquote>\n<p id=\"so_598913_604022_0\">Given these definitions, a viable\n  function F1 is defined to be a better\n  function than another viable function\n  F2 if for all arguments i, ICSi(F1) is\n  not a worse conversion sequence than\n  ICSi(F2), and then</p>\n</blockquote>\n<p>[...]</p>\n<blockquote>\n<p id=\"so_598913_604022_1\">\u2014 F1 is a non-template function\n  and F2 is a function template\n  specialization, or, if not that,</p>\n</blockquote>\n<p>In the examples above, overload resolution sees two functions with the same signature, one of which is a template.  The non template function (the implicitly generated copy constructor/copy assignment operator) wins and so is called.</p>\n", "CreationDate": "2009-03-02T21:13:04.267", "ParentId": "598913", "CommentCount": "2", "LastEditDate": "2009-03-05T00:00:16.127", "PostTypeId": "2", "LastEditorDisplayName": "Checkers", "LastActivityDate": "2009-03-05T00:00:16.127", "LastEditorUserId": "23643", "Id": "604022", "OwnerDisplayName": "Richard Corden", "Score": "4", "OwnerUserId": "11698"}, "bq_ids": {"n4140": {"so_598913_604022_0": {"length": 18, "quality": 0.9, "section_id": 603}, "so_598913_604022_1": {"length": 5, "quality": 1.0, "section_id": 111}}, "n3337": {"so_598913_604022_0": {"length": 18, "quality": 0.9, "section_id": 593}, "so_598913_604022_1": {"length": 5, "quality": 1.0, "section_id": 106}}, "n4659": {"so_598913_604022_0": {"length": 18, "quality": 0.9, "section_id": 629}, "so_598913_604022_1": {"length": 5, "quality": 1.0, "section_id": 115}}}, "599040": {"Id": "599040", "PostTypeId": "2", "Body": "<p>Read Meyers's Effective STL and C++ books, and Alexandrescu's Modern C++ Design.</p>\n<p>Meyers will give you the basics on easy mistakes to make and how to avoid them.  Alexandrescu introduces you to a template-based programming model that should have you asking \"Is this <em>really</em> a good idea?\" the entire book.</p>\n", "OwnerDisplayName": "Dan Olson", "LastActivityDate": "2009-03-01T01:11:38.797", "Score": "2", "CreationDate": "2009-03-01T01:11:38.797", "ParentId": "598913", "CommentCount": "1", "OwnerUserId": "69283"}, "598913": {"ViewCount": "4200", "Body": "<p>What are most important things you know about templates: hidden features, common mistakes, best and most useful practices, tips...<strong>common mistakes/oversight/assumptions</strong></p>\n<p>I am starting to implement most of my library/API using templates and would like to collect most common patterns, tips, etc., found in practice.</p>\n<p>Let me formalize the question: What is the most important thing you've learned about templates?</p>\n<p>Please try to provide examples -- it would be easier to understand, as opposed to convoluted and overly dry descriptions</p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "599050", "Title": "Most important things about C++ templates\u2026 lesson learned", "CreationDate": "2009-02-28T23:47:18.920", "LastActivityDate": "2016-04-06T18:21:06.467", "CommentCount": "2", "FavoriteCount": "12", "PostTypeId": "1", "LastEditDate": "2009-03-01T01:30:55.817", "LastEditorDisplayName": "strager", "OwnerDisplayName": "Sasha", "LastEditorUserId": "39992", "Id": "598913", "Score": "12", "Tags": "<c++><templates>", "AnswerCount": "12"}, "598918": {"Body": "<p>It's important to understand separate compilation and the possibility of resulting executable size increases. If you instantiate the template with the same type in several C++ files, you will get the type reproduced multiple times, at least on some compilers. </p>\n", "CreationDate": "2009-02-28T23:51:56.710", "ParentId": "598913", "CommentCount": "4", "LastEditDate": "2009-03-01T00:21:59.633", "PostTypeId": "2", "LastEditorDisplayName": "Uri", "LastActivityDate": "2009-03-01T00:21:59.633", "LastEditorUserId": "23072", "Id": "598918", "OwnerDisplayName": "Uri", "Score": "0", "OwnerUserId": "23072"}, "599067": {"Id": "599067", "PostTypeId": "2", "Body": "<p>This may not be popular, but I think it needs to be said.</p>\n<p>Templates are complicated.</p>\n<p>They are awesomely powerful, but use them wisely. Don't go too crazy, don't have too many template arguments... Don't have too many specializations... Remember, other programmers have to read this too.</p>\n<p>And most of all, stay away from template metaprogramming...</p>\n", "OwnerDisplayName": "dicroce", "LastActivityDate": "2009-03-01T01:45:56.343", "Score": "7", "CreationDate": "2009-03-01T01:45:56.343", "ParentId": "598913", "CommentCount": "2", "OwnerUserId": "3886"}, "599050": {"Body": "<p>From <strong>\"Exceptional C++ style\", Item 7:</strong> function overload resolution happens <em>before</em> templates specialization. Do not mix overloaded function and specializations of template functions, or you are in for a nasty surprise at which function actually gets called.</p>\n<pre><code>template&lt;class T&gt; void f(T t) { ... }   // (a)\ntemplate&lt;class T&gt; void f(T *t) { ... }  // (b)\ntemplate&lt;&gt; void f&lt;int*&gt;(int *t) { ... } // (c)\n...\nint *pi; f(pi); // (b) is called, not (c)!\n</code></pre>\n<p>On top of <strong>Item 7</strong>:</p>\n<p>Worse yet, if you omit the type in template specialization, a <em>different</em> function template might get specialized depending on the order of definition and as a result a specialized function may or may not be called.</p>\n<p>Case 1:</p>\n<pre><code>template&lt;class T&gt; void f(T t) { ... }  // (a)\ntemplate&lt;class T&gt; void f(T *t) { ... } // (b)\ntemplate&lt;&gt; void f(int *t) { ... }      // (c) - specializes (b)\n...\nint *pi; f(pi); // (c) is called\n</code></pre>\n<p>Case 2:</p>\n<pre><code>template&lt;class T&gt; void f(T t) { ... }  // (a)\ntemplate&lt;&gt; void f(int *t) { ... }      // (c) - specializes (a)\ntemplate&lt;class T&gt; void f(T *t) { ... } // (b)\n...\nint *pi; f(pi); // (b) is called\n</code></pre>\n", "CreationDate": "2009-03-01T01:22:19.253", "ParentId": "598913", "CommentCount": "3", "LastEditDate": "2009-03-01T23:27:55.307", "PostTypeId": "2", "LastEditorDisplayName": "Checkers", "LastActivityDate": "2009-03-01T23:27:55.307", "LastEditorUserId": "23643", "Id": "599050", "OwnerDisplayName": "Checkers", "Score": "17", "OwnerUserId": "23643"}, "599034": {"Id": "599034", "PostTypeId": "2", "Body": "<p>Here are some rules:</p>\n<ol>\n<li>Don't write any templates unless you're writing a very, very generic library (STL and Boost are two prominent examples).</li>\n<li>Don't instantiate any non-trivial template too many times. Instantiating huge template classes is especially overkill. You should consider using inheritance and polymorphism (the simple way, I mean, using virtual functions).</li>\n<li>If you're writing any templates, knowing when to use <code>const</code>, <code>mutable</code> and <code>volatile</code> will save users of the template both compile and execution time.</li>\n<li>If you're instantiating any templates, use a good compiler.</li>\n</ol>\n", "OwnerDisplayName": "Eduardo Le&#243;n", "LastActivityDate": "2009-03-01T01:08:38.647", "Score": "2", "CreationDate": "2009-03-01T01:08:38.647", "ParentId": "598913", "CommentCount": "0", "OwnerUserId": "46571"}});