post_cb({"bq_ids": {"n4140": {"so_42441791_42441832_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 382}, "so_42441791_42441791_0": {"length": 6, "quality": 0.6, "section_id": 4701}, "so_42441791_42442265_1": {"length": 18, "quality": 0.782608695652174, "section_id": 378}, "so_42441791_42442265_2": {"length": 18, "quality": 0.5806451612903226, "section_id": 382}}, "n3337": {"so_42441791_42441832_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 373}, "so_42441791_42441791_0": {"length": 6, "quality": 0.6, "section_id": 3155}, "so_42441791_42442265_1": {"length": 18, "quality": 0.782608695652174, "section_id": 369}, "so_42441791_42442265_2": {"length": 18, "quality": 0.5806451612903226, "section_id": 373}}, "n4659": {"so_42441791_42441832_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 397}, "so_42441791_42441791_0": {"length": 6, "quality": 0.6, "section_id": 4047}, "so_42441791_42442265_2": {"length": 17, "quality": 0.5483870967741935, "section_id": 397}}}, "42441791": {"ViewCount": "123", "Body": "<p>Following the well accepted answer to this question <a href=\"https://stackoverflow.com/questions/3716277/do-rvalue-references-allow-dangling-references\">Do rvalue references allow dangling references?</a> It would seem that xvalues do not have their lifetime extended when assigned to a rvalue reference lvalue like in the question.  However when I do this</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Something {\npublic:\n    Something() {\n        cout &lt;&lt; \"Something()\" &lt;&lt; endl;\n    }\n    Something(const Something&amp;) {\n        cout &lt;&lt; \"Something(const Something&amp;)\" &lt;&lt; endl;\n    }\n    Something(Something&amp;&amp;) {\n        cout &lt;&lt; \"Something(Something&amp;&amp;)\" &lt;&lt; endl;\n    }\n    ~Something() {\n        cout &lt;&lt; \"~Something()\" &lt;&lt; endl;\n    }\n\n    int a;\n};\n\nSomething make_something() {\n    return Something{};\n}\n\nint main() {\n    auto&amp;&amp; something = make_something().a;\n\n    return 0;\n}\n</code></pre>\n<p>The lifetime of the object returned by a call to <code>make_something</code> is extended, even though <code>make_something().a</code> is an xvalue as per <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/value_category</a> (the third bullet in the xvalues explanation lists the member access I have above as an xvalue,)</p>\n<blockquote>\n<p id=\"so_42441791_42441791_0\">a.m, the member of object expression, where a is an rvalue and m is a\n  non-static data member of non-reference type;</p>\n</blockquote>\n<p>If value categories do not determine when the lifetime of an rvalue will be extended then what does?  I am having a hard time understanding when the lifetime of an rvalue is extended in C++</p>\n", "Title": "Lifetime extension, prvalues and xvalues", "CreationDate": "2017-02-24T15:00:10.980", "LastActivityDate": "2017-02-24T16:21:37.953", "CommentCount": "0", "LastEditDate": "2017-05-23T12:00:16.037", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "42441791", "Score": "1", "OwnerUserId": "5501675", "Tags": "<c++><c++11><xvalue><prvalue><value-categories>", "AnswerCount": "2"}, "42441832": {"Id": "42441832", "PostTypeId": "2", "Body": "<p>Lifetime extension doesn't care about value categories. As stated by [class.temporary]/p6:</p>\n<blockquote>\n<p id=\"so_42441791_42441832_0\">The temporary to which the reference is bound or the temporary that is the complete object of a <strong>subobject to which the reference is bound</strong> persists for the lifetime of the reference</p>\n</blockquote>\n<p>Emphasis added.</p>\n<p>This says nothing here about the value category of the expression being referenced.</p>\n<p>What determines whether a temporary is extended is exactly the above (and a few more rules).</p>\n<hr>\n<blockquote>\n<p id=\"so_42441791_42441832_1\">But that does not explain why adding an <code>std::move()</code> around the temporary to which the reference is being assigned does not extend the lifetime</p>\n</blockquote>\n<p><code>std::move</code> is not a magical, compiler-defined construct in C++. It is a <em>function call</em>, and therefore it behaves no differently from any other C++ function call.</p>\n<p>So, if you have <code>std::move(Type())</code>, what does that mean? It means that you will create a temporary, bind it to the <em>parameter of <code>std::move</code></em>, then call that function, which will return something.</p>\n<p>Binding a temporary to a function parameter, as stated in [class.temporary]/p6, means that the lifetime of the temporary is fixed to be the lifetime of the full expression that created it (if not for that rule, then the temporary would have to be destroyed at the end of the function call, since that's the end of the reference's lifetime).</p>\n<p>It doesn't matter what the function does, says, or implies. It doesn't matter if the compiler could perhaps inline things and determine that the return value is a reference to an argument that came from a temporary. The lifetime of that temporary is fixed to the expression, not extended.</p>\n</hr>", "LastEditorUserId": "734069", "LastActivityDate": "2017-02-24T15:23:02.460", "Score": "3", "CreationDate": "2017-02-24T15:02:08.483", "ParentId": "42441791", "CommentCount": "16", "LastEditDate": "2017-02-24T15:23:02.460", "OwnerUserId": "734069"}, "42442265": {"Id": "42442265", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_42441791_42442265_0\">If value categories do not determine when the lifetime of an rvalue will be extended then what does? I am having a hard time understanding when the lifetime of an rvalue is extended in C++</p>\n</blockquote>\n<p>Note that value categories describe <em>expressions</em> not objects. Value categories ( xvalue, prvalue, or whatever ) won't be extended in any way. Only objects can have a lifetime. </p>\n<p>From the n4296 standard draft:</p>\n<ul>\n<li>\u00a712.2.1\n\n<blockquote>\n<p id=\"so_42441791_42442265_1\">Temporaries of class type are created in various contexts: binding a reference to a prvalue (8.5.3), returning\n  a prvalue (6.6.3), a conversion that creates a prvalue (4.1, 5.2.9, 5.2.11, 5.4), throwing an exception (15.1),\n  and in some initializations (8.5).</p>\n</blockquote></li>\n</ul>\n<p>and </p>\n<ul>\n<li>\u00a712.2.4 \n\n<blockquote>\n<p id=\"so_42441791_42442265_2\">There are two contexts in which temporaries are destroyed at a different point than the end of the full-\n  expression. [...]<br>\n  The second context is when a <em>reference is bound to a temporary</em>. The temporary to which the reference is\n  bound or the <em>temporary that is the complete object of a subobject to which the reference is bound persists\n  for the lifetime of the reference</em></br></p>\n</blockquote></li>\n</ul>\n<p>Note: I didn't quote the first context since it has minor revelance regarding the questions. Italic emphasis added by me.  </p>\n<p>Thus the <em>value category</em> of the function <em>expression</em> <code>makesomething()</code> is a <code>prvalue</code> creating a temporary of class type, according to the first paragraph cited above.<br>\n<code>makesomething().a</code> accesses a temporary, complete <em>subobject</em>.  Binding this temporary to a reference leads, according to the <em>second context</em> quoated above, to an extended lifetime.  </br></p>\n<hr>\n<p>The lifetime of the subobject <code>a</code> is coupled to the lifetime of the previous created temporary making it an <em>expiring value</em> (xvalue). Without extending its lifetime by binding it to a reference it would be destroyed together with the temporary class object. Thus, in this case, after the <code>;</code>. </p>\n</hr>", "LastEditorUserId": "4884487", "LastActivityDate": "2017-02-24T16:21:37.953", "Score": "1", "CreationDate": "2017-02-24T15:23:00.313", "ParentId": "42441791", "CommentCount": "4", "LastEditDate": "2017-02-24T16:21:37.953", "OwnerUserId": "4884487"}});