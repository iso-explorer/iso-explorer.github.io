post_cb({"bq_ids": {"n4140": {"so_47278993_47279278_0": {"section_id": 416, "quality": 0.9375, "length": 30}, "so_47278993_47279232_0": {"section_id": 6111, "quality": 0.6, "length": 6}, "so_47278993_47279278_2": {"section_id": 6110, "quality": 1.0, "length": 15}, "so_47278993_47279278_1": {"section_id": 408, "quality": 0.6585365853658537, "length": 27}}, "n3337": {"so_47278993_47279278_0": {"section_id": 407, "quality": 0.625, "length": 20}, "so_47278993_47279232_0": {"section_id": 36, "quality": 0.6, "length": 6}, "so_47278993_47279278_2": {"section_id": 5876, "quality": 1.0, "length": 15}, "so_47278993_47279278_1": {"section_id": 399, "quality": 0.6585365853658537, "length": 27}}, "n4659": {"so_47278993_47279278_0": {"section_id": 434, "quality": 0.9375, "length": 30}, "so_47278993_47279232_0": {"section_id": 7584, "quality": 0.6, "length": 6}, "so_47278993_47279278_2": {"section_id": 7607, "quality": 1.0, "length": 15}, "so_47278993_47279278_1": {"section_id": 426, "quality": 0.8536585365853658, "length": 35}}}, "47279278": {"ParentId": "47278993", "CommentCount": "0", "Body": "<p>Your code <em>should</em> work, if you just return an address that isn't null pointer value. To quote the C++ standard:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.free#4\" rel=\"nofollow noreferrer\">[class.free]/4</a></p>\n<blockquote>\n<p id=\"so_47278993_47279278_0\">Class-specific deallocation function lookup is a part of general\n  deallocation function lookup ([expr.delete]) and occurs as follows. If\n  the delete-expression is used to deallocate a class object whose\n  static type has a virtual destructor, the deallocation function is the\n  one selected at the point of definition of the dynamic type's virtual\n  destructor ([class.dtor]).</p>\n</blockquote>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.dtor#13\" rel=\"nofollow noreferrer\">[class.dtor]/13</a></p>\n<blockquote>\n<p id=\"so_47278993_47279278_1\">At the point of definition of a virtual destructor (including an\n  implicit definition), the non-array deallocation function is\n  determined as if for the expression delete this appearing in a\n  non-virtual destructor of the destructor's class (see [expr.delete]).\n  If the lookup fails or if the deallocation function has a deleted\n  definition, the program is ill-formed. <strong>[\u2009Note: This assures that a\n  deallocation function corresponding to the dynamic type of an object\n  is available for the delete-expression ([class.free]). \u2009\u2014\u2009end note\u2009]</strong></p>\n</blockquote>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr.delete#6\" rel=\"nofollow noreferrer\">[expr.delete]/6</a></p>\n<blockquote>\n<p id=\"so_47278993_47279278_2\">If the value of the operand of the delete-expression is not a null\n  pointer value, the delete-expression will invoke the destructor (if\n  any) for the object or the elements of the array being deleted.</p>\n</blockquote>\n<p>You just set it up in a way that won't invoke anything at the <code>delete</code> expression. I fixed it up to forward onto the global operators new and delete, and everything works as expected. <a href=\"http://coliru.stacked-crooked.com/a/61333b1ddd494fa6\" rel=\"nofollow noreferrer\">The code is on Coliru Viewer</a>.</p>\n", "OwnerUserId": "817643", "PostTypeId": "2", "Id": "47279278", "Score": "1", "CreationDate": "2017-11-14T06:45:46.570", "LastActivityDate": "2017-11-14T06:45:46.570"}, "47279232": {"ParentId": "47278993", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Deleting a <code>nullptr</code> is always a no-op in C++14 and later. Nothing gets called. To make your example work, you'd need to return a pointer that is not null. For example:</p>\n<pre><code>void* operator new(size_t) throw()\n{\n    std::cout &lt;&lt; \"Overloaded operator new!\\n\";\n    return ::new Test;\n}\n</code></pre>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/language/delete\" rel=\"nofollow noreferrer\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_47278993_47279232_0\">If expression evaluates to a null pointer value, no destructors are called, and <strong>the deallocation function is not called</strong>.</p>\n</blockquote>\n<p>The above is for C++14 and later. Up to C++11, the deallocation function might get called. It's implementation-defined:</p>\n<blockquote>\n<p id=\"so_47278993_47279232_1\">If expression evaluates to a null pointer value, no destructors are called, and <strong>the deallocation function may or may not be called</strong> (it's implementation-defined), but the default deallocation functions are guaranteed to do nothing when handed a null pointer.</p>\n</blockquote>\n", "OwnerUserId": "856199", "LastEditorUserId": "856199", "LastEditDate": "2017-11-14T06:48:23.597", "Id": "47279232", "Score": "2", "CreationDate": "2017-11-14T06:42:46.017", "LastActivityDate": "2017-11-14T06:48:23.597"}, "47278993": {"CommentCount": "2", "ViewCount": "54", "PostTypeId": "1", "LastEditorUserId": "7965754", "CreationDate": "2017-11-14T06:27:03.650", "LastActivityDate": "2017-11-14T16:57:07.733", "Title": "Operator new and delete on Inherited class. Operator delete not executing", "LastEditDate": "2017-11-14T16:57:07.733", "Id": "47278993", "Score": "3", "Body": "<p>I was messing around operator overloading and I've noticed that on inherited object, the overloaded operator delete doesn't seem to execute when the inherited object has an operator new overloaded:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass TestAbs {\npublic:\n  TestAbs (void) {\n  }\n  virtual ~TestAbs (void) noexcept {\n  }\n};\n\nclass Test : public TestAbs {\npublic:\n  Test (void) \n      : TestAbs () {\n  }\n  ~Test (void) noexcept override {\n  } \n  void* operator new (size_t) throw () {\n    std::cout &lt;&lt; \"Overloaded operator new!\\n\";\n    return nullptr;\n  }\n  void operator delete (void*) noexcept {\n    std::cout &lt;&lt; \"Overloaded operator delete in class: Test!\\n\";\n  }\n};\n\nint main() {\n    TestAbs* tp = new Test ();\n    delete tp;\n\n    return 0;\n}\n</code></pre>\n<p>The code above has the following output:</p>\n<pre><code>Overloaded operator new!\n</code></pre>\n<p>What happened to the overloaded operator delete?\nThank you all in advance!</p>\n<p>Update:\nThank you guys for all the help. It seems like the problem was indeed the nullptr return on the overloaded new.</p>\n", "Tags": "<c++><inheritance><operator-overloading><new-operator><delete-operator>", "OwnerUserId": "7965754", "AnswerCount": "2"}});