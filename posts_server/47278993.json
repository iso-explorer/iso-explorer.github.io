post_cb({"bq_ids": {"n4140": {"so_47278993_47279232_0": {"length": 6, "quality": 0.6, "section_id": 6111}, "so_47278993_47279278_2": {"length": 15, "quality": 1.0, "section_id": 6110}, "so_47278993_47279278_0": {"length": 30, "quality": 0.9375, "section_id": 416}, "so_47278993_47279278_1": {"length": 27, "quality": 0.6585365853658537, "section_id": 408}}, "n3337": {"so_47278993_47279232_0": {"length": 6, "quality": 0.6, "section_id": 36}, "so_47278993_47279278_2": {"length": 15, "quality": 1.0, "section_id": 5876}, "so_47278993_47279278_0": {"length": 20, "quality": 0.625, "section_id": 407}, "so_47278993_47279278_1": {"length": 27, "quality": 0.6585365853658537, "section_id": 399}}, "n4659": {"so_47278993_47279232_0": {"length": 6, "quality": 0.6, "section_id": 7584}, "so_47278993_47279278_0": {"length": 30, "quality": 0.9375, "section_id": 434}, "so_47278993_47279278_2": {"length": 15, "quality": 1.0, "section_id": 7607}, "so_47278993_47279278_1": {"length": 35, "quality": 0.8536585365853658, "section_id": 426}}}, "47279232": {"Id": "47279232", "PostTypeId": "2", "Body": "<p>Deleting a <code>nullptr</code> is always a no-op in C++14 and later. Nothing gets called. To make your example work, you'd need to return a pointer that is not null. For example:</p>\n<pre><code>void* operator new(size_t) throw()\n{\n    std::cout &lt;&lt; \"Overloaded operator new!\\n\";\n    return ::new Test;\n}\n</code></pre>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/language/delete\" rel=\"nofollow noreferrer\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_47278993_47279232_0\">If expression evaluates to a null pointer value, no destructors are called, and <strong>the deallocation function is not called</strong>.</p>\n</blockquote>\n<p>The above is for C++14 and later. Up to C++11, the deallocation function might get called. It's implementation-defined:</p>\n<blockquote>\n<p id=\"so_47278993_47279232_1\">If expression evaluates to a null pointer value, no destructors are called, and <strong>the deallocation function may or may not be called</strong> (it's implementation-defined), but the default deallocation functions are guaranteed to do nothing when handed a null pointer.</p>\n</blockquote>\n", "LastEditorUserId": "856199", "LastActivityDate": "2017-11-14T06:48:23.597", "Score": "2", "CreationDate": "2017-11-14T06:42:46.017", "ParentId": "47278993", "CommentCount": "0", "OwnerUserId": "856199", "LastEditDate": "2017-11-14T06:48:23.597"}, "47279278": {"Id": "47279278", "PostTypeId": "2", "Body": "<p>Your code <em>should</em> work, if you just return an address that isn't null pointer value. To quote the C++ standard:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.free#4\" rel=\"nofollow noreferrer\">[class.free]/4</a></p>\n<blockquote>\n<p id=\"so_47278993_47279278_0\">Class-specific deallocation function lookup is a part of general\n  deallocation function lookup ([expr.delete]) and occurs as follows. If\n  the delete-expression is used to deallocate a class object whose\n  static type has a virtual destructor, the deallocation function is the\n  one selected at the point of definition of the dynamic type's virtual\n  destructor ([class.dtor]).</p>\n</blockquote>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.dtor#13\" rel=\"nofollow noreferrer\">[class.dtor]/13</a></p>\n<blockquote>\n<p id=\"so_47278993_47279278_1\">At the point of definition of a virtual destructor (including an\n  implicit definition), the non-array deallocation function is\n  determined as if for the expression delete this appearing in a\n  non-virtual destructor of the destructor's class (see [expr.delete]).\n  If the lookup fails or if the deallocation function has a deleted\n  definition, the program is ill-formed. <strong>[\u2009Note: This assures that a\n  deallocation function corresponding to the dynamic type of an object\n  is available for the delete-expression ([class.free]). \u2009\u2014\u2009end note\u2009]</strong></p>\n</blockquote>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr.delete#6\" rel=\"nofollow noreferrer\">[expr.delete]/6</a></p>\n<blockquote>\n<p id=\"so_47278993_47279278_2\">If the value of the operand of the delete-expression is not a null\n  pointer value, the delete-expression will invoke the destructor (if\n  any) for the object or the elements of the array being deleted.</p>\n</blockquote>\n<p>You just set it up in a way that won't invoke anything at the <code>delete</code> expression. I fixed it up to forward onto the global operators new and delete, and everything works as expected. <a href=\"http://coliru.stacked-crooked.com/a/61333b1ddd494fa6\" rel=\"nofollow noreferrer\">The code is on Coliru Viewer</a>.</p>\n", "LastActivityDate": "2017-11-14T06:45:46.570", "CommentCount": "0", "CreationDate": "2017-11-14T06:45:46.570", "ParentId": "47278993", "Score": "1", "OwnerUserId": "817643"}, "47278993": {"ViewCount": "54", "Body": "<p>I was messing around operator overloading and I've noticed that on inherited object, the overloaded operator delete doesn't seem to execute when the inherited object has an operator new overloaded:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass TestAbs {\npublic:\n  TestAbs (void) {\n  }\n  virtual ~TestAbs (void) noexcept {\n  }\n};\n\nclass Test : public TestAbs {\npublic:\n  Test (void) \n      : TestAbs () {\n  }\n  ~Test (void) noexcept override {\n  } \n  void* operator new (size_t) throw () {\n    std::cout &lt;&lt; \"Overloaded operator new!\\n\";\n    return nullptr;\n  }\n  void operator delete (void*) noexcept {\n    std::cout &lt;&lt; \"Overloaded operator delete in class: Test!\\n\";\n  }\n};\n\nint main() {\n    TestAbs* tp = new Test ();\n    delete tp;\n\n    return 0;\n}\n</code></pre>\n<p>The code above has the following output:</p>\n<pre><code>Overloaded operator new!\n</code></pre>\n<p>What happened to the overloaded operator delete?\nThank you all in advance!</p>\n<p>Update:\nThank you guys for all the help. It seems like the problem was indeed the nullptr return on the overloaded new.</p>\n", "Title": "Operator new and delete on Inherited class. Operator delete not executing", "CreationDate": "2017-11-14T06:27:03.650", "LastActivityDate": "2017-11-14T16:57:07.733", "CommentCount": "2", "LastEditDate": "2017-11-14T16:57:07.733", "PostTypeId": "1", "LastEditorUserId": "7965754", "Id": "47278993", "Score": "3", "OwnerUserId": "7965754", "Tags": "<c++><inheritance><operator-overloading><new-operator><delete-operator>", "AnswerCount": "2"}});