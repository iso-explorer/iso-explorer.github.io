post_cb({"26070916": {"CommentCount": "2", "AcceptedAnswerId": "26071134", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-09-27T03:12:57.827", "LastActivityDate": "2014-09-27T03:54:56.830", "LastEditDate": "2017-05-23T12:06:47.030", "ViewCount": "184", "FavoriteCount": "1", "Title": "Global unnamed namespace ambiguity vs nested unnamed namespace ambiguity", "Id": "26070916", "Score": "3", "Body": "<p>Consider the following two code snippets:</p>\n<p><strong><a href=\"http://ideone.com/lCdcZK\" rel=\"nofollow noreferrer\">Snippet A</a></strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace\n{\n    bool foo = false;\n}\n\nbool foo = true;\n\nint main()\n{\n    std::cout &lt;&lt; foo &lt;&lt; std::endl;\n}\n</code></pre>\n<p><strong><a href=\"http://ideone.com/8fL1RO\" rel=\"nofollow noreferrer\">Snippet B</a></strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace A\n{\n    namespace\n    {\n        bool foo = false;\n    }\n\n    bool foo = true;\n}\n\nint main()\n{\n    std::cout &lt;&lt; A::foo &lt;&lt; std::endl;\n}\n</code></pre>\n<p>In <a href=\"http://ideone.com/lCdcZK\" rel=\"nofollow noreferrer\">Snippet A</a>, <code>foo</code>'s usage inside <code>int main()</code> is ambiguous, whilst in <a href=\"http://ideone.com/8fL1RO\" rel=\"nofollow noreferrer\">Snippet B</a> it is not. Why is this the case?</p>\n<hr>\n<p>Related: <a href=\"https://stackoverflow.com/questions/3673353/anonymous-namespace-ambiguity\">Anonymous Namespace Ambiguity</a></p>\n</hr>", "Tags": "<c++><namespaces><ambiguous>", "OwnerUserId": "1816262", "AnswerCount": "1"}, "26071134": {"ParentId": "26070916", "CommentCount": "0", "CreationDate": "2014-09-27T03:54:56.830", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "26071134", "Score": "5", "Body": "<p>The behavior of unnamed namespaces is specified in \u00a77.3.1.1 [namespace.unnamed]/p1:</p>\n<blockquote>\n<p id=\"so_26070916_26071134_0\">An <em>unnamed-namespace-definition</em> behaves as if it were replaced by</p>\n<pre><code>inline_opt namespace unique { /* empty body */ }\nusing namespace unique ;\nnamespace unique { namespace-body }\n</code></pre>\n<p id=\"so_26070916_26071134_1\">where <code>inline</code> appears if and only if it appears in the\n  <em>unnamed-namespace-definition</em>, all occurrences of <code>unique</code> in a translation unit are replaced by the same identifier, and this\n  identifier differs from all other identifiers in the entire program.</p>\n</blockquote>\n<p>In particular, note that the declarations inside the unnamed namespace is made visible in the surrounding scope via a <em>using-directive</em> <code>using namespace unique;</code>.</p>\n<p>In Snippet A, <code>foo</code> is unqualified, so the compiler performs unqualified name lookup (\u00a73.4.1 [basic.lookup.unqual]). Relevant here is paragraph 2 of the subclause:</p>\n<blockquote>\n<p id=\"so_26070916_26071134_2\">2 The declarations from the namespace nominated by a <em>using-directive</em>\n  become visible in a namespace enclosing the <em>using-directive</em>; see\n  7.3.4. For the purpose of the unqualified name lookup rules described in 3.4.1, the declarations from the namespace nominated by the\n  <em>using-directive</em> are considered members of that enclosing namespace.</p>\n</blockquote>\n<p>Hence, unqualified name lookup finds both declarations of <code>foo</code>, and the name is ambiguous.</p>\n<p>In Snippet B, <code>A::foo</code> is qualified, so qualified name lookup rules apply. Since <code>A</code> is a namespace, the applicable subclause is \u00a73.4.3.2 [namespace.qual]. As relevant here, the rule is specified in paragraph 2 of that subclause:</p>\n<blockquote>\n<p id=\"so_26070916_26071134_3\">For a namespace <code>X</code> and name <code>m</code>, the namespace-qualified lookup set\n  <code>S(X,m)</code> is defined as follows: Let <code>S'(X,m)</code> be the set of all\n  declarations of <code>m</code> in <code>X</code> and the inline namespace set of <code>X</code>\n  (7.3.1). If <code>S'(X,m)</code> is not empty, <code>S(X,m)</code> is <code>S'(X,m)</code>; otherwise,\n  <code>S(X,m)</code> is the union of <code>S(Ni,m)</code> for all namespaces <code>Ni</code> nominated\n  by <em>using-directives</em> in <code>X</code> and its inline namespace set.</p>\n</blockquote>\n<p>In other words, qualified name lookup considers namespaces nominated by <em>using-directives</em> only if the name is not found in the specified namespace and its inline namespace set. Here, the name <code>foo</code> is found in namespace <code>A</code>, so the unnamed namespace nominated by the <em>using-directive</em> is not considered, and there's no ambiguity.</p>\n<p>If you write <code>::foo</code> instead of <code>foo</code> in Snippet A, then qualified lookup rules would apply instead, and there would once again be no ambiguity.</p>\n", "LastActivityDate": "2014-09-27T03:54:56.830"}, "bq_ids": {"n4140": {"so_26070916_26071134_0": {"section_id": 5482, "quality": 1.0, "length": 4}, "so_26070916_26071134_3": {"section_id": 7117, "quality": 0.7352941176470589, "length": 25}, "so_26070916_26071134_2": {"section_id": 7088, "quality": 0.8518518518518519, "length": 23}, "so_26070916_26071134_1": {"section_id": 5482, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_26070916_26071134_0": {"section_id": 5268, "quality": 1.0, "length": 4}, "so_26070916_26071134_3": {"section_id": 6861, "quality": 0.7352941176470589, "length": 25}, "so_26070916_26071134_2": {"section_id": 6832, "quality": 0.8518518518518519, "length": 23}, "so_26070916_26071134_1": {"section_id": 5268, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_26070916_26071134_0": {"section_id": 6917, "quality": 1.0, "length": 4}, "so_26070916_26071134_3": {"section_id": 8618, "quality": 0.7352941176470589, "length": 25}, "so_26070916_26071134_2": {"section_id": 8589, "quality": 0.8518518518518519, "length": 23}, "so_26070916_26071134_1": {"section_id": 6917, "quality": 0.8947368421052632, "length": 17}}}});