post_cb({"3570231": {"Id": "3570231", "PostTypeId": "2", "Body": "<p>The real question is, \"Does myclass allocate any memory itself that must be free/deleted?\"</p>\n<p>If it does not -- if the only memory it uses is it's internal members -- then it exists entirely on the stack.  Once it leaves that function (however it does), the memory on the stack is reclaimed and reused.  <code>myclass</code> is gone.  That's just the way stacks work.</p>\n<p>If myclass does allocate memory that needs to be freed in it's dtor, then you are still in luck, as the dtor will be called as the stack is unwound during the throw. The dtor will have already been called before the exception is declared unhandled and terminate is called.</p>\n<p>The only place you will have a problem is if myclass has a dtor, and the dtor throws as exception of it own.  The second throw occurring during the stack unwind from the first throw will have it call terminate immedaitely without any more dtors being called.</p>\n", "LastEditorUserId": "12725", "LastActivityDate": "2010-08-26T03:14:06.730", "Score": "1", "CreationDate": "2010-08-25T21:10:01.363", "ParentId": "3570119", "CommentCount": "0", "OwnerUserId": "12725", "LastEditDate": "2010-08-26T03:14:06.730"}, "3570203": {"Id": "3570203", "PostTypeId": "2", "Body": "<p>In a hosted environment (e.g. your typical Unix / Windows / Mac OS X, even DOS, machine) when the application terminates all the memory it occupied is automatically reclaimed by the operating system.  Therefore, it doesn't make sense to worry about such memory leaks.</p>\n<p>In some cases, before an application terminates, you may want to release all the dynamic memory you allocated in order to detect potential memory leaks through a leak detector, like <a href=\"http://valgrind.org/\" rel=\"nofollow noreferrer\">valgrind</a>.  However, even in such a case, the example you describe wouldn't be considered a memory leak.</p>\n<p>In general, failing to call a destructor is not the same as causing a memory leak.  Memory leaks stem from memory allocated on the heap (with new or malloc or container allocators).  Memory allocated on the stack is automatically reclaimed when the stack is unwound.  However, if an object holds some other resource (say a file or a window handle), failing to call its destructor will call a resource leak, which can also be a problem.  Again, modern OSs will reclaim their resources when an application terminates.</p>\n", "LastActivityDate": "2010-08-25T21:06:46.620", "CommentCount": "2", "CreationDate": "2010-08-25T21:06:46.620", "ParentId": "3570119", "Score": "5", "OwnerUserId": "20520"}, "3570366": {"Id": "3570366", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3570119_3570366_0\">My understanding is \"When the application terminates (either by abort or by normal exit), it frees all the memory that was allocated for the application\". Thus this cannot be considered as memory leak.</p>\n<p id=\"so_3570119_3570366_1\">Am I correct?</p>\n</blockquote>\n<p>Memory leak is a type of programming error which is ranked somewhat lower on scale of programming errors - compared to the uncaught exception.</p>\n<p>IOW, if program doesn't terminate properly, a.k.a. crashes, then it is too soon to speak about memory leaks.</p>\n<p>On other note, most memory analyzers I have worked with over past decade would not trigger any memory leak alarm in the case - because they do not trigger any alarms when program dumbly crashes. One first has to make program not crashing, only then debug the memory leaks.</p>\n", "LastActivityDate": "2010-08-25T21:30:13.977", "CommentCount": "0", "CreationDate": "2010-08-25T21:30:13.977", "ParentId": "3570119", "Score": "0", "OwnerUserId": "360695"}, "3570149": {"Id": "3570149", "PostTypeId": "2", "Body": "<p>Memory leaks are considered a problem because a long running application will slowly bleed away system memory and may in the worst case make the whole machine unusable due to low memory conditions. In your case, the application terminates and all memory allocated to the application will be given back to the system, so hardly a problem.</p>\n", "LastActivityDate": "2010-08-25T20:59:56.387", "CommentCount": "1", "CreationDate": "2010-08-25T20:59:56.387", "ParentId": "3570119", "Score": "1", "OwnerUserId": "232918"}, "3570148": {"Id": "3570148", "PostTypeId": "2", "Body": "<p>edit: as mentioned by GMan, \"throw;\" re-throws a previously thrown exception, or if there is none, immediately terminates.  Since there is none in this case, immediate termination is the result.</p>\n<p>Terminating a process always cleans up any leftover userland memory in any modern OS, so is not typically considered a \"memory leak\", which is defined as unreferenced memory not deallocated in a running process.  However, it's really up to the OS as to whether such a thing is considered a \"memory leak\".</p>\n", "LastEditorUserId": "194978", "LastActivityDate": "2010-08-25T21:28:23.913", "Score": "4", "CreationDate": "2010-08-25T20:59:30.047", "ParentId": "3570119", "CommentCount": "3", "OwnerUserId": "194978", "LastEditDate": "2010-08-25T21:28:23.913"}, "3570119": {"ViewCount": "400", "Body": "<p>The general rule, only objects allocated in the free store can cause memory leaks.\nBut objects created in the stack doesn't.</p>\n<p>Here is my doubt,</p>\n<pre><code>int main()\n    {\n      myclass x;\n\n      ...\n\n      throw;\n\n      ...\n    }\n</code></pre>\n<p>If throw is not handled, it calls, terminate(), which in turn calls abort() and crashes the application. At this time, the objects in the stack are not destoryed (The destructor is not invoked).</p>\n<p>My understanding is \"When the application terminates (either by abort or by normal exit), it frees all the memory that was allocated for the application\". Thus this cannot be considered as memory leak.</p>\n<p>Am I correct?</p>\n", "AcceptedAnswerId": "3570203", "Title": "Is this considered memory leak?", "CreationDate": "2010-08-25T20:53:58.053", "Id": "3570119", "CommentCount": "7", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2010-08-26T03:28:20.353", "Score": "5", "OwnerUserId": "373215", "Tags": "<c++><memory-management><memory-leaks><throw>", "AnswerCount": "7"}, "bq_ids": {"n4140": {"so_3570119_3571648_2": {"length": 10, "quality": 0.6666666666666666, "section_id": 3354}}, "n3337": {"so_3570119_3571648_2": {"length": 10, "quality": 0.6666666666666666, "section_id": 3224}}, "n4659": {"so_3570119_3571648_2": {"length": 10, "quality": 0.6666666666666666, "section_id": 4121}}}, "3570144": {"Id": "3570144", "PostTypeId": "2", "Body": "<p>The answer is, it depends on the OS. I can't think of a modern OS that does not do it this way. But old systems (I think up to win 3.1 in windows, and some old embedded Linux platforms) if the program closed without releasing its memory requests the OS would hold them until you rebooted.</p>\n", "LastActivityDate": "2010-08-25T20:58:56.777", "CommentCount": "0", "CreationDate": "2010-08-25T20:58:56.777", "ParentId": "3570119", "Score": "2", "OwnerUserId": "80274"}, "3571648": {"Id": "3571648", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3570119_3571648_0\">From OP,</p>\n<p id=\"so_3570119_3571648_1\">If throw is not handled, it calls,\n  terminate(), which in turn calls\n  abort() and crashes the application.\n  At this time, the objects in the stack\n  are not destoryed (The destructor is\n  not invoked).</p>\n</blockquote>\n<p>This is an implementation defined behavior.</p>\n<blockquote>\n<p id=\"so_3570119_3571648_2\">$15.3/9-  \"If no matching handler is\n  found in a program, the function\n  terminate() is called; whether or not\n  the stack is unwound before this call\n  to terminate() is\n  implementation-defined (15.5.1).\"</p>\n</blockquote>\n<p>Therefore, whether this constitues a memory leak or not is also implementation defined behavior, I guess.</p>\n", "LastEditorUserId": "418110", "LastActivityDate": "2010-08-26T03:28:20.353", "Score": "1", "CreationDate": "2010-08-26T02:25:25.543", "ParentId": "3570119", "CommentCount": "1", "OwnerUserId": "418110", "LastEditDate": "2010-08-26T03:28:20.353"}});