post_cb({"bq_ids": {"n4140": {"so_10949863_10950183_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 2772}, "so_10949863_10950183_1": {"length": 7, "quality": 0.875, "section_id": 2758}, "so_10949863_10950183_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 2768}, "so_10949863_10950183_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 2753}}, "n3337": {"so_10949863_10950183_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 2733}, "so_10949863_10950183_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 2714}, "so_10949863_10950183_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 2729}, "so_10949863_10950183_1": {"length": 7, "quality": 0.875, "section_id": 2719}}, "n4659": {"so_10949863_10950183_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 3510}, "so_10949863_10950183_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 3491}, "so_10949863_10950183_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 3506}, "so_10949863_10950183_1": {"length": 7, "quality": 0.875, "section_id": 3496}}}, "10949863": {"ViewCount": "1192", "Body": "<p>I'm currently using openMP to write code running on multi-core nodes. openMP has a specific memory model which guarantees that memory is synchronised between threads running on different cores when a lock is acquired.</p>\n<p>I consider using C++11 constructs (<code>std::thread</code> with <code>std::mutex</code> and <code>std::lock</code>) instead of openMP (because of their larger flexibility) and wonder if/how memory synchronisation between processors is guaranteed here? And if not, how can I enforce it?</p>\n", "AcceptedAnswerId": "10950183", "Title": "Does `std::mutex` and `std::lock` guarantee memory synchronisation in inter-processor code?", "CreationDate": "2012-06-08T13:31:55.630", "Id": "10949863", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2012-06-08T13:52:28.613", "Score": "5", "OwnerUserId": "1023390", "Tags": "<c++><multithreading><c++11><openmp>", "AnswerCount": "1"}, "10950183": {"Id": "10950183", "PostTypeId": "2", "Body": "<p>The standard makes the following guarantees about synchronization of <code>std::mutex</code>, in \u00a730.4.1.2[thread.mutex.requirements.mutex]/6-25</p>\n<blockquote>\n<p id=\"so_10949863_10950183_0\">The expression m.lock() shall be well-formed and have the following semantics</p>\n<p id=\"so_10949863_10950183_1\"><em>Synchronization</em>: Prior unlock() operations on the same object shall synchronize with this operation.</p>\n</blockquote>\n<p>And, likewise,</p>\n<blockquote>\n<p id=\"so_10949863_10950183_2\">The expression m.unlock() shall be well-formed and have the following semantics</p>\n<p id=\"so_10949863_10950183_3\"><em>Synchronization</em>: This operation synchronizes with subsequent lock operations that obtain ownership on the same object.</p>\n</blockquote>\n<p>(Where \"synchronizes with\" is a specific term explained in $1.10, although it's much easier to understand by reading <em>C++ Concurrency In Action</em>)</p>\n", "LastActivityDate": "2012-06-08T13:52:28.613", "CommentCount": "3", "CreationDate": "2012-06-08T13:52:28.613", "ParentId": "10949863", "Score": "9", "OwnerUserId": "273767"}});