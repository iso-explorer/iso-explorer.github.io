post_cb({"10949863": {"CommentCount": "8", "ViewCount": "1192", "CreationDate": "2012-06-08T13:31:55.630", "LastActivityDate": "2012-06-08T13:52:28.613", "Title": "Does `std::mutex` and `std::lock` guarantee memory synchronisation in inter-processor code?", "AcceptedAnswerId": "10950183", "PostTypeId": "1", "Id": "10949863", "Score": "5", "Body": "<p>I'm currently using openMP to write code running on multi-core nodes. openMP has a specific memory model which guarantees that memory is synchronised between threads running on different cores when a lock is acquired.</p>\n<p>I consider using C++11 constructs (<code>std::thread</code> with <code>std::mutex</code> and <code>std::lock</code>) instead of openMP (because of their larger flexibility) and wonder if/how memory synchronisation between processors is guaranteed here? And if not, how can I enforce it?</p>\n", "Tags": "<c++><multithreading><c++11><openmp>", "OwnerUserId": "1023390", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_10949863_10950183_3": {"section_id": 2772, "quality": 0.8181818181818182, "length": 9}, "so_10949863_10950183_2": {"section_id": 2768, "quality": 0.8571428571428571, "length": 6}, "so_10949863_10950183_1": {"section_id": 2813, "quality": 0.875, "length": 7}, "so_10949863_10950183_0": {"section_id": 2753, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_10949863_10950183_3": {"section_id": 2733, "quality": 0.7272727272727273, "length": 8}, "so_10949863_10950183_2": {"section_id": 2729, "quality": 0.8571428571428571, "length": 6}, "so_10949863_10950183_1": {"section_id": 2719, "quality": 0.75, "length": 6}, "so_10949863_10950183_0": {"section_id": 2714, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_10949863_10950183_3": {"section_id": 3510, "quality": 0.8181818181818182, "length": 9}, "so_10949863_10950183_0": {"section_id": 3491, "quality": 0.8571428571428571, "length": 6}, "so_10949863_10950183_2": {"section_id": 3506, "quality": 0.8571428571428571, "length": 6}, "so_10949863_10950183_1": {"section_id": 3551, "quality": 0.875, "length": 7}}}, "10950183": {"ParentId": "10949863", "CommentCount": "3", "Body": "<p>The standard makes the following guarantees about synchronization of <code>std::mutex</code>, in \u00a730.4.1.2[thread.mutex.requirements.mutex]/6-25</p>\n<blockquote>\n<p id=\"so_10949863_10950183_0\">The expression m.lock() shall be well-formed and have the following semantics</p>\n<p id=\"so_10949863_10950183_1\"><em>Synchronization</em>: Prior unlock() operations on the same object shall synchronize with this operation.</p>\n</blockquote>\n<p>And, likewise,</p>\n<blockquote>\n<p id=\"so_10949863_10950183_2\">The expression m.unlock() shall be well-formed and have the following semantics</p>\n<p id=\"so_10949863_10950183_3\"><em>Synchronization</em>: This operation synchronizes with subsequent lock operations that obtain ownership on the same object.</p>\n</blockquote>\n<p>(Where \"synchronizes with\" is a specific term explained in $1.10, although it's much easier to understand by reading <em>C++ Concurrency In Action</em>)</p>\n", "OwnerUserId": "273767", "PostTypeId": "2", "Id": "10950183", "Score": "9", "CreationDate": "2012-06-08T13:52:28.613", "LastActivityDate": "2012-06-08T13:52:28.613"}});