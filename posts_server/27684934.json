post_cb({"27685077": {"Id": "27685077", "PostTypeId": "2", "Body": "<p>The value is preserved if the destination can store the value, else it is reduced modulo <code>CHAR_MAX + 1</code> if the destination is unsigned, otherwise the result is implementation-defined (C allows trapping though).</p>\n<p><code>char</code> might be able to store <code>0xFFFFFFFF</code> anyway, if <code>CHAR_BIT</code> is big enough.</p>\n<hr>\n<p>C++14 (n3936):</p>\n<blockquote>\n<h3>3.9.1 Fundamental types <code>[basic.fundamental]</code></h3>\n<p id=\"so_27684934_27685077_0\">[...] In any particular implementation, a plain <code>char</code> object can take on either the same values as a <code>signed char</code> or an <code>unsigned char</code>; which one is implementation-defined.</p>\n</blockquote>\n<blockquote>\n<h3>4.7 Integral conversions <code>[conv.integral]</code></h3>\n<p id=\"so_27684934_27685077_1\">1 A prvalue of an integer type can be converted to a prvalue of another integer type. A prvalue of an unscoped enumeration type can be converted to a prvalue of an integer type.<br>\n  2 <strong>If the destination type is unsigned</strong>, the resulting value is the least unsigned integer congruent to the source integer (modulo 2n where n is the number of bits used to represent the unsigned type).<br>\n  3 <strong>If the destination type is signed</strong>, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined.\n  4 If the destination type is bool, see 4.12. If the source type is <code>bool</code>, the value <code>false</code> is converted to zero and the value <code>true</code> is converted to one.<br>\n  5 The conversions allowed as integral promotions are excluded from the set of integral conversions.</br></br></br></p>\n</blockquote>\n<hr>\n<p>C has rules which have nearly the same result, though observe that the last case may trap.<br>\nC11 (C99+amendments) (n1570):</br></p>\n<blockquote>\n<h3>6.2.5 Types</h3>\n<p id=\"so_27684934_27685077_2\">15 The three types <code>char</code>, <code>signed char</code>, and <code>unsigned</code> char are collectively called\n  the character types. The implementation shall define <code>char</code> to have the same range,\n  representation, and behavior as either <code>signed char</code> or <code>unsigned char</code>.45)</p>\n</blockquote>\n<blockquote>\n<h3>6.3.1.3 Signed and unsigned integers</h3>\n<p id=\"so_27684934_27685077_3\">1 When a value with integer type is converted to another integer type other than <code>_Bool</code>, if\n  the value can be represented by the new type, it is unchanged.<br>\n  2 Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or\n  subtracting one more than the maximum value that can be represented in the new type\n  until the value is in the range of the new type.60)<br>\n  3 Otherwise, the new type is signed and the value cannot be represented in it; either the\n  result is implementation-defined <strong>or an implementation-defined signal is raised</strong>.</br></br></p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "3204551", "LastActivityDate": "2014-12-29T07:41:32.847", "Score": "3", "CreationDate": "2014-12-29T07:31:54.283", "ParentId": "27684934", "CommentCount": "0", "OwnerUserId": "3204551", "LastEditDate": "2014-12-29T07:41:32.847"}, "bq_ids": {"n4140": {"so_27684934_27685077_2": {"length": 17, "quality": 0.6538461538461539, "section_id": 7210}, "so_27684934_27685077_0": {"length": 15, "quality": 0.9375, "section_id": 7210}}, "n3337": {"so_27684934_27685077_0": {"length": 15, "quality": 0.9375, "section_id": 6954}, "so_27684934_27685077_2": {"length": 15, "quality": 0.5769230769230769, "section_id": 6954}}, "n4659": {"so_27684934_27685077_0": {"length": 15, "quality": 0.9375, "section_id": 8719}, "so_27684934_27685077_2": {"length": 15, "quality": 0.5769230769230769, "section_id": 8719}}}, "27684934": {"ViewCount": "121", "Body": "<p>Just out of curiosity. I want to know what happens when the lvalue has less bits then the assigned value.</p>\n<pre><code>char a = 0xffffFFFF\n</code></pre>\n<p>Moreover lets say</p>\n<pre><code>struct {\nint num:3;\n}testStruct;\n\ntestStruct.num = 0xffffFFFF/2 -1;\n</code></pre>\n<p>what will be the value in char (first case) and 3bit integer (in second case)</p>\n", "AcceptedAnswerId": "27685140", "Title": "assigned value has more bits then lvalue", "CreationDate": "2014-12-29T07:18:41.093", "Id": "27684934", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-12-29T07:42:56.913", "Score": "5", "OwnerUserId": "3884862", "Tags": "<c++><c><struct><compilation><bit-manipulation>", "AnswerCount": "3"}, "27685140": {"Id": "27685140", "PostTypeId": "2", "Body": "<p>You're using the term \"lvalue\" incorrectly. I guess you mean \"variable\" or \"object\".</p>\n<p>In the case <code>sizeof(0xFFFFFFFF) == 1</code> and plain char being <code>unsigned</code>, then <code>char a = 0xffffFFFF;</code> is straightforward, since that value can be represented in <code>char</code>. </p>\n<p>In other cases, it is an <em>out-of-range conversion</em>.  If plain char is unsigned then this means the large positive number <code>0xFFFFFFFF</code> is adjusted modulo <code>UCHAR_MAX+1</code> to fit (on common systems, the plain char gets <code>255</code>). </p>\n<p>If plain char is signed then it is implementation-defined behaviour (and in C, may raise an implementation-defined signal). The most common implementation definition is 2's complement truncation which would give the char the value <code>-1</code> but this is not guaranteed.</p>\n<hr>\n<p>Moving onto the bitfield. <code>0xffffFFFF/2 - 1</code> is <code>0x7FFFFFFE</code>. This is assigned to a bitfield of type <code>int</code> and width <code>3</code>, which requests an out-of-range conversion, just like for the signed <code>char</code> case. As before, this is implementation-defined (and may raise an implementation-defined signal in C).</p>\n<p>Look up your compiler documentation to find out what it specifies here, although I'd expect again that it would use 2's complement truncation, giving <code>-2</code>.</p>\n</hr>", "LastActivityDate": "2014-12-29T07:37:57.303", "CommentCount": "1", "CreationDate": "2014-12-29T07:37:57.303", "ParentId": "27684934", "Score": "6", "OwnerUserId": "1505939"}, "27685083": {"Id": "27685083", "PostTypeId": "2", "Body": "<p>If value does not fit for integral type (int, char, short, long etc):</p>\n<ol>\n<li><p><strong>Signed</strong>: The behaviour is implementation-defined.</p></li>\n<li><p><strong>Unsigned</strong>: Modular value is copied. (i.e. higher bits that can not be stored are ignored while copying)</p></li>\n</ol>\n<p>Please note that <code>char</code> as used in your answer may behave as <code>signed char</code> or <code>unsigned char</code> depending upon your compiler and compilation flags.</p>\n<blockquote>\n<p id=\"so_27684934_27685083_0\">what will be the value in char (first case) and 3bit integer (in\n  second case)</p>\n</blockquote>\n<p>The answer is implementation-dependent. Check your compiler documentation for exact answer that suits your environment.</p>\n", "LastEditorUserId": "2659313", "LastActivityDate": "2014-12-29T07:42:56.913", "Score": "3", "CreationDate": "2014-12-29T07:32:37.810", "ParentId": "27684934", "CommentCount": "0", "OwnerUserId": "2659313", "LastEditDate": "2014-12-29T07:42:56.913"}});