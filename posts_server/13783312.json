post_cb({"13783444": {"Id": "13783444", "PostTypeId": "2", "Body": "<p>This doesn't make much sense as you put it.</p>\n<p>The point of <code>dynamic_cast</code> is to resolve polymorphism at runtime. So the actual interesting scenario would be something like</p>\n<pre><code>void animalhandler(Animal&amp; animal);\n</code></pre>\n<p>which is however <em>not</em> (at least not only) called with instances of <code>Animal</code>, but with any of the subclasses. You often don't even need to know: you can call any virtual members of <code>animal</code> and be sure that C++ calls the correct overload, for whatever derived class <code>*animal</code> actually belongs to.</p>\n<p>But sometimes you wish to do something that's only possible with one particular derived instance. In that case, you use <code>dynamic_cast</code>, like</p>\n<pre><code>void animalhandler(Animal&amp; animal) {\n  if(auto as_bird = dynamic_cast&lt;Bird*&gt;(&amp;animal)) {\n    // bird-specific code\n  }\n}\n</code></pre>\n<p>where the <code>if</code> only fires if <code>animal</code> is in fact a <code>Bird</code> (or derived of <code>Bird</code>), otherwise the <code>dynamic_cast</code> just returns <code>nullptr</code> which the <code>if</code> interprets as <code>false</code>.</p>\n<p>Now, you come up with the idea to do the opposite. Let's see what this would look like:</p>\n<pre><code>  if(auto as_bird = dynamic_cast&lt;Bird*&gt;(&amp;animal)) {\n    if(auto as_animal = dynamic_cast&lt;Animal*&gt;(as_bird)) {\n      // animal-specific code\n    }\n  }\n</code></pre>\n<p>...wait, does it mean anything to be animal-specific? Nope, because <em>all</em> <code>Bird</code>s are <code>Animal</code>s, we know that at compile-time so there's no point checking it dynamically. You can still write it, but you might as well leave it out and use <code>as_bird</code> directly, since it gives access to all members that <code>as_animal</code> would.</p>\n", "LastEditorUserId": "745903", "LastActivityDate": "2012-12-09T00:33:57.577", "Score": "2", "CreationDate": "2012-12-09T00:27:25.573", "ParentId": "13783312", "CommentCount": "0", "OwnerUserId": "745903", "LastEditDate": "2012-12-09T00:33:57.577"}, "13783483": {"Id": "13783483", "PostTypeId": "2", "Body": "<p>I hope this helps:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\nclass A{\npublic:\n    A(){}\n    virtual void write() const = 0;\n};\n\nclass B : public A{\npublic:\n    B(){}\n    void write() const { cout &lt;&lt; \"I'm B\" &lt;&lt; endl; }\n    void iam(){ cout &lt;&lt; \"Yes, I am\" &lt;&lt; endl; }\n};\n\nint main(){\n    B b;\n\n    A* a;\n    a = &amp;b;\n\n    b.write();\n    b.iam();\n\n    a-&gt;write();\n    //a-&gt;iam(); A don't have a method iam\n\n\n    system(\"pause\");\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2012-12-09T00:34:41.597", "CommentCount": "0", "CreationDate": "2012-12-09T00:34:41.597", "ParentId": "13783312", "Score": "0", "OwnerUserId": "1870820"}, "13783312": {"ViewCount": "4577", "Body": "<p>If you had the following:</p>\n<pre><code>class Animal{};\n\nclass Bird : public Animal{};\n\nclass Dog : public Animal{};\n\nclass Penguin : public Bird{};\n\nclass Poodle : public Dog{};\n</code></pre>\n<p>Does dynamic_cast just check if one class is a derived class of another, or if one class is a base class of another?  So if I had:</p>\n<pre><code>Bird* bird;\nAnimal* animal;\n\nbird = dynamic_cast&lt;Animal*&gt;(bird);\nanimal = dynamic_cast&lt;Bird*&gt;(animal);\n</code></pre>\n<p><code>bird</code> would now point to an <code>Animal</code> class, so that I can use <code>bird-&gt;some_function();</code> and it will call the function in <code>Animal</code>?  And <code>animal</code> now points to a <code>Bird</code> class, so I can do <code>animal-&gt;some_function();</code> and it will call <code>some_function();</code> in <code>Bird</code>?</p>\n<p>I've been trying to figure out how the dynamic_cast works, and the resources I've found online haven't been the most helpful.  If someone can offer other insight into the functionality of dynamic_cast and some instances in which it would be useful, I'd highly appreciate it.</p>\n", "AcceptedAnswerId": "13783436", "Title": "How does dynamic_cast work?", "CreationDate": "2012-12-09T00:08:47.940", "Id": "13783312", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2012-12-09T00:47:13.610", "LastEditorUserId": "1741542", "LastActivityDate": "2015-09-09T02:48:03.630", "Score": "9", "OwnerUserId": "1218732", "Tags": "<c++><dynamic><dynamic-cast>", "AnswerCount": "5"}, "13783436": {"Id": "13783436", "PostTypeId": "2", "Body": "<p>The most important thing about dynamic cast is that it should be applied to <code>polymorphic type</code>. Without that dynamic cast works like a static cast.</p>\n<p>What is polymorphic type? Any class that that has at least one virtual method or virtual destructor or  virtual base class is polymorphic. Only those types have <code>virtual method table</code> (VMT) in their data layout. Classes that do not have anything virtual do not have VMT's. Standard is not saying how polymorphysm and virtual methods should be implemented, at the same time all compilers (AFAIK) do this.</p>\n<p>In your examples classes are not polymorphic. In my opinion, it would be better if compilers would issue an error when dynamic cast is applied to non polymorphic type. Nevertheless they do not do this. This adds to the confusion.</p>\n<p>VMT pointers for all classes are different. This means that on the run time looking at:</p>\n<pre><code>Animal* animal;\n</code></pre>\n<p>it is possible to know what the real class of the object is. Is it a <code>Bird</code> or a <code>God</code> or something else. Knowing the real type from the value of VMT, generated code can make an adjustment if this is needed.</p>\n<p>Here is an example:</p>\n<pre><code>class Animal   { virtual ~Animal();   int m1; };\nclass Creature { virtual ~Creature(); int m2; };\n\nclass Bird : public Animal, Creature { };\n\nBird   *bird = new Bird();\nCreature *creature = dynamic_cast&lt;Creature*&gt;(bird);\n</code></pre>\n<p>Note that creature is not the first base class. This means that the pointer will be shifted to point to the right part of the object. Nevertheless the following will still be working:</p>\n<pre><code>Animal *animal = dynamic_cast&lt;Animal*&gt;(creature);   // Case2.\n</code></pre>\n<p>because VMT of Creature when it is part of other class will not be the same to VMT of the object when it is used stand alone:</p>\n<pre><code>Creature *creature1 = new Creature();\n</code></pre>\n<p>This distinction allows proper implementation of dynamic cast. In the example <code>Case2</code> the pointer will be shifted back. I tested this. This works.</p>\n", "LastEditorUserId": "1459996", "LastActivityDate": "2015-09-09T02:48:03.630", "Score": "8", "CreationDate": "2012-12-09T00:26:33.787", "ParentId": "13783312", "CommentCount": "0", "OwnerUserId": "1459996", "LastEditDate": "2015-09-09T02:48:03.630"}, "bq_ids": {"n4140": {"so_13783312_13783510_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 6011}, "so_13783312_13783510_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 6016}, "so_13783312_13783510_3": {"length": 62, "quality": 1.0, "section_id": 6018}}, "n3337": {"so_13783312_13783510_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 5779}, "so_13783312_13783510_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 5784}, "so_13783312_13783510_3": {"length": 62, "quality": 1.0, "section_id": 5786}}, "n4659": {"so_13783312_13783510_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 7510}, "so_13783312_13783510_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 7515}, "so_13783312_13783510_3": {"length": 62, "quality": 1.0, "section_id": 7517}}}, "13783510": {"Id": "13783510", "PostTypeId": "2", "Body": "<p>From the C++ Working Draft</p>\n<blockquote>\n<p id=\"so_13783312_13783510_0\"><strong>Dynamic cast [expr.dynamic.cast]</strong></p>\n<p id=\"so_13783312_13783510_1\">1 The result of the expression dynamic_cast&lt;T&gt;(v) is the result of converting the expression v to type T. T shall be a pointer or reference to a complete class type, or \"pointer to cv void.\u201d The dynamic_cast operator shall not cast away constness (5.2.11).</p>\n<p id=\"so_13783312_13783510_2\">6 Otherwise, v shall be a pointer to or an lvalue of a polymorphic type (10.3).</p>\n<p id=\"so_13783312_13783510_3\">8 If C is the class type to which T points or refers, the run-time check logically executes as follows:<br>\n  - If, in the most derived object pointed (referred) to by v, v points (refers) to a public base class subobject of a C object, and if only one object of type C is derived from the subobject pointed (referred) to by v the result points (refers) to that C object.<br>\n  - Otherwise, if v points (refers) to a public base class subobject of the most derived object, and the type of the most derived object has a base class, of type C, that is unambiguous and public, the result points (refers) to the C subobject of the most derived object.<br>\n  - Otherwise, the run-time check fails.</br></br></br></p>\n</blockquote>\n<p>What you can conclude from these clauses</p>\n<ul>\n<li><code>dynamic_cast</code> works with polymorphic classes</li>\n<li>it looks at <em>runtime</em> at the object pointed (or referred) to</li>\n<li>it decides based on <em>public</em> base classes of the object pointed to, whether the cast succeeds or fails</li>\n</ul>\n", "LastActivityDate": "2012-12-09T00:40:15.663", "CommentCount": "0", "CreationDate": "2012-12-09T00:40:15.663", "ParentId": "13783312", "Score": "0", "OwnerUserId": "1741542"}, "13783454": {"Id": "13783454", "PostTypeId": "2", "Body": "<p>The <code>dynamic_cast</code> operator checks the type of the <em>actual</em> object pointed to by the pointer. This is what makes it different from compile-time <code>static_cast</code>; the result of <code>dynamic_cast</code> depends on runtime data.</p>\n<pre><code>dynamic_cast&lt;Animal*&gt;(bird)\n</code></pre>\n<p>In the above case, <code>Animal</code> is a superclass of <code>Bird</code> so <code>dynamic_cast</code> is not necessary here (and the compiler will treat it the same as a <code>static_cast</code> or no cast at all).</p>\n<pre><code>dynamic_cast&lt;Bird*&gt;(animal)\n</code></pre>\n<p>In this case, when this statement is actually executed, the runtime system will inspect the actual type of whatever kind of object <code>animal</code> actually points to. It might be a <code>Bird</code> or subclass of <code>Bird</code>, in which case the result will be a valid <code>Bird*</code>. If the object is not a <code>Bird</code>, then the result will be <code>NULL</code>.</p>\n<p>Your question is further complicated by the fact that you're assigning the result of these <code>dynamic_cast</code> calls back to the original pointer. This is perhaps where part of the confusion comes from, and I have omitted this aspect from the above discussion.</p>\n", "LastActivityDate": "2012-12-09T00:28:06.500", "CommentCount": "0", "CreationDate": "2012-12-09T00:28:06.500", "ParentId": "13783312", "Score": "2", "OwnerUserId": "893"}});