post_cb({"40746482": {"Tags": "<c++><c++1z>", "ViewCount": "311", "CreationDate": "2016-11-22T16:04:51.063", "FavoriteCount": "1", "Title": "C++ Class template deduction (P0091R0) for function arguments", "CommentCount": "7", "AnswerCount": "1", "Score": "15", "OwnerUserId": "6197447", "Id": "40746482", "LastActivityDate": "2016-11-22T16:20:38.260", "Body": "<p>In C++17 we can do somthing like</p>\n<pre><code>std::pair p = {1,3}; // compiler deduces template parameters to pair&lt;int,int&gt;\n</code></pre>\n<p>From the documentation at <a href=\"http://en.cppreference.com/w/cpp/language/class_template_deduction\" rel=\"nofollow noreferrer\">cppreference</a> I understand that the following will NOT work:</p>\n<pre><code>template&lt;class T1, class T2&gt;\nvoid bar(std::pair&lt;T1,T2&gt;)\n{}\nvoid foo()\n{\n   bar({1,3}); // No deduction of pair template arguments\n}\n</code></pre>\n<p>Can anyone confirm this and give some insight, why this won't work? Technically this should work, right? Has there been any discussion to make this work, or is it kind of an oversight?</p>\n", "PostTypeId": "1"}, "40746805": {"ParentId": "40746482", "Score": "11", "CreationDate": "2016-11-22T16:20:38.260", "Id": "40746805", "OwnerUserId": "2069064", "LastActivityDate": "2016-11-22T16:20:38.260", "Body": "<p>The reference is correct. Template argument deduction for class templates as currently adopted applies <em>solely</em> to declarations (and explicit type conversions - which are defined in terms of declarations), in [dcl.type.class.deduct]:</p>\n<blockquote>\n<p id=\"so_40746482_40746805_0\">If a placeholder for a deduced class type appears as a <em>decl-specifier</em> in the <em>decl-specifier-seq</em> of a <em>simple-declaration</em>, the <em>init-declarator</em> of that declaration shall be of the form</p>\n<p id=\"so_40746482_40746805_1\"><em>declarator-id</em> <em>attribute-specifier-seq</em><sub>opt</sub> <em>initializer</em></p>\n<p id=\"so_40746482_40746805_2\">The placeholder is replaced by the return type of the function selected by overload resolution for class template deduction (13.3.1.8). If the <em>init-declarator-list</em> contains more than one <em>init-declarator</em>, the type that\n  replaces the placeholder shall be the same in each deduction. <em>[ Example:</em></p>\n<pre><code>template&lt;class T&gt; struct container {\n    container(T t) {}\n    template&lt;class Iter&gt; container(Iter beg, Iter end);\n};\n\ntemplate&lt;class Iter&gt;\ncontainer(Iter b, Iter e) -&gt; container&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;;\n\nstd::vector&lt;double&gt; v = { /* ... */};\ncontainer c(7);                          // OK, deduces int for T\nauto d = container(v.begin(), v.end());  // OK, deduces double for T\ncontainer e{5, 6};                       // error, int is not an iterator\n</code></pre>\n<p id=\"so_40746482_40746805_3\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>There was nothing in the proposal or the adopted wording about deducing a class template specialization from a <em>braced-init-list</em>.</p>\n", "PostTypeId": "2", "CommentCount": "0"}, "bq_ids": {"n4659": {"so_40746482_40746805_2": {"length": 21, "section_id": 6891, "quality": 0.8076923076923077}, "so_40746482_40746805_0": {"length": 7, "section_id": 6891, "quality": 0.6363636363636364}}}});