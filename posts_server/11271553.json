post_cb({"11271553": {"CommentCount": "2", "ViewCount": "349", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-06-30T04:58:29.770", "LastActivityDate": "2012-06-30T07:35:12.197", "Title": "Explicit specialization of non-class, non-function members of a class template", "AcceptedAnswerId": "11271636", "LastEditDate": "2017-05-23T11:48:52.487", "Id": "11271553", "Score": "1", "Body": "<p>Look at the code:</p>\n<pre><code>template &lt;class x&gt; struct Foo\n{\n    int getX(x *p) { return(0); }\n    enum E12 { a };\n};\n\ntemplate &lt;&gt; int Foo&lt;int&gt;::getX(int*)\n{\n    return(-15);\n}\n\ntemplate &lt;&gt; enum Foo&lt;int&gt;::E12\n{\n    a, b, c\n}\n</code></pre>\n<p>As it was discussed in <a href=\"https://stackoverflow.com/questions/11268535/cannot-overload-function\">Cannot overload function</a>, the first specialization is legal and even works in MSVC. While the second specialization for <code>enum</code> does not even want to compile, saying \"error C2988: unrecognizable template declaration/definition\".</p>\n<p>It seems to me that C++ is making relaitively unlogical exception for methods. Enum is just an example. The same thing can be applied to member classes, typedefs, etc.</p>\n<p>I will be happy is some body will comment on this.</p>\n", "Tags": "<c++>", "OwnerUserId": "1459996", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_11271553_11271636_1": {"section_id": 263, "quality": 1.0, "length": 5}}, "n3337": {"so_11271553_11271636_1": {"section_id": 254, "quality": 1.0, "length": 5}}, "n4659": {"so_11271553_11271636_1": {"section_id": 270, "quality": 1.0, "length": 5}}}, "11271636": {"ParentId": "11271553", "PostTypeId": "2", "CommentCount": "17", "CreationDate": "2012-06-30T05:15:52.537", "Score": "1", "LastEditorUserId": "153285", "LastEditDate": "2012-06-30T07:33:43.913", "Id": "11271636", "OwnerUserId": "153285", "Body": "<p>This is a very obscure new feature of C++11. File a bug report with Microsoft, although it is unlikely it will be given priority as almost nobody is aware this is allowed. The correct syntax would be</p>\n<pre><code>template &lt;class x&gt; struct Foo\n{\n    int getX(x *p) { return(0); }\n    enum E12 { a };\n};\n\ntemplate &lt;&gt; int Foo&lt;int&gt;::getX(int*)\n{\n    return(-15);\n}\n\ntemplate &lt;&gt; enum Foo&lt;int&gt;::E12\n{\n    a, b, c\n};\n</code></pre>\n<p>I've <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53815\" rel=\"nofollow\">filed a bug</a> with GCC. Can someone test on recent Clang?</p>\n<hr>\n<p>In C++03, only classes and functions may be explicitly specialized. From the standard, C++03 14.7.3/1:</p>\n<blockquote>\n<p id=\"so_11271553_11271636_0\">An explicit specialization of any of the following:</p>\n<ul>\n<li>function template</li>\n<li>class template</li>\n<li>member function of a class template</li>\n<li>static data member of a class template</li>\n<li>member class of a class template</li>\n<li>member class template of a class or class template</li>\n<li>member function template of a class or class template</li>\n</ul>\n<p id=\"so_11271553_11271636_1\">can be declared by a declaration introduced by <code>template&lt;&gt;</code></p>\n</blockquote>\n<p>A member enum is not such a case. (Generally speaking, an <code>enum</code> type is always defined only once at its first declaration.)</p>\n<p>To obtain a templated <code>enum</code> or <code>typedef</code>, you can wrap it in a class template. In your case, it would be a member class template of <code>Foo</code>. Such a construct is called a metafunction.</p>\n<p>C++11 also has alias templates, which are like templated typedefs, but they cannot be explicitly specialized.</p>\n<hr>\n<p>The policy of only allowing classes and functions to be specialized, and then allowing such templates to encapsulate other things like <code>enum</code> and <code>typedef</code>, seems more consistent to me than allowing direct specialization of <code>enum</code>. But, perhaps the language is going in your preferred direction.</p>\n</hr></hr>", "LastActivityDate": "2012-06-30T07:33:43.913"}});