post_cb({"19445070": {"CommentCount": "11", "CreationDate": "2013-10-18T08:33:48.830", "PostTypeId": "1", "AcceptedAnswerId": "19445448", "LastEditorUserId": "1137388", "LastActivityDate": "2013-10-18T12:41:31.290", "LastEditDate": "2013-10-18T12:20:55.593", "ViewCount": "336", "FavoriteCount": "1", "Title": "Not sure to understand the advantage of the move constructor (or how it works or use it)", "Id": "19445070", "Score": "7", "Body": "<p>I recently posted a question on SE regarding the code below, because it generated a compilation error. Someone was kind enough to answer that when you implement a move constructor or move assignment operator then the default copy constructor is deleted. They also suggested that then I needed to use the <code>std::move()</code> to get something like this to work:</p>\n<pre><code>Image src(200, 200);\nImage cpy = std::move(src);\n</code></pre>\n<p>Now that sort of makes sense to me, because the fact that you want to use the move assignment operator or move constructor in this case has to made explicit. <code>src</code> in this example is an lvalue and nothing can tell the compiler than you actually want to move its content to <code>cpy</code> unless you express this explicitly with <code>std::move</code>. However, I have more of a problem with this code:</p>\n<pre><code>Image cpy = src + src\n</code></pre>\n<p>I didn't put the copy for the <code>operator +</code> below but it's a straightforward overload operator of the type:</p>\n<pre><code>Image operator + (const Image &amp;img) const {\n    Image tmp(std::min(w, img.w), std::min(h, img.h));\n    for (int j = 0; j &lt; tmp.h; ++j) {\n        for (int i = 0; i &lt; tmp.w; ++i) {\n            // accumulate the result of the two images\n        }\n    }\n    return tmp; \n}\n</code></pre>\n<p>In this particular case, I would assume the operator returns a temp variable in the form of <code>tmp</code> and that the move assignement operator would be triggered in that case when you get to <code>cpy = src + src</code>. I am not sure it's accurate to say that the result of <code>src + src</code> is a lvalue because in fact what's returns in <code>tmp</code>, but then <code>tmp</code> is copied/assigned to <code>cpy</code>. So before the move operator existed, this would have triggered the default copy constructor. But why isn't it using the move constructor in this case? It seems that I also need to do a:</p>\n<pre><code>Image cpy = std::move(src + src);\n</code></pre>\n<p>to get this to work, which I assume gets an xvalue for the variable returned by the <code>operator +</code> of the class Image?</p>\n<p>Could someone helps me understanding this better please? and tell what I don't get right?</p>\n<p>Thank you.</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;cassert&gt;\n\nclass Image\n{\npublic:\n    Image() : w(512), h(512), d(NULL)\n    {\n        //printf(\"constructor default\\n\");\n        d = new float[w * h * 3];\n        memset(d, 0x0, sizeof(float) * w * h * 3);\n    }\n    Image(const unsigned int &amp;_w, const unsigned int &amp;_h) : w(_w), h(_h), d(NULL)\n    {\n        d = new float[w * h * 3];\n        memset(d, 0x0, sizeof(float) * w * h * 3);\n    }\n    // move constructor\n    Image(Image &amp;&amp;img) : w(0), h(0), d(NULL)\n    {\n        w = img.w;\n        h = img.h;\n        d = img.d;\n        img.d = NULL;\n        img.w = img.h = 0;\n    }\n    // move assignment operator\n    Image&amp; operator = (Image &amp;&amp;img)\n    {\n        if (this != &amp;img) {\n            if (d != NULL) delete [] d;\n            w = img.w, h = img.h;\n            d = img.d;\n            img.d = NULL;\n            img.w = img.h = 0;\n        }\n        return *this;\n    }\n    //~Image() { if (d != NULL) delete [] d; }\n    unsigned int w, h;\n    float *d;\n};\n\nint main(int argc, char **argv)\n{\n    Image sample;// = readPPM(\"./lean.ppm\");\n    Image res = sample;\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><c++11><move-semantics>", "OwnerUserId": "1794325", "AnswerCount": "1"}, "19445448": {"ParentId": "19445070", "LastEditDate": "2013-10-18T12:41:31.290", "CommentCount": "9", "CreationDate": "2013-10-18T08:54:22.580", "OwnerUserId": "1137388", "LastEditorUserId": "1137388", "PostTypeId": "2", "Id": "19445448", "Score": "6", "Body": "<blockquote>\n<blockquote>\n<p id=\"so_19445070_19445448_1\">It seems that I also need to do a:</p>\n<pre><code>Image cpy = std::move(src + src);\n</code></pre>\n</blockquote>\n</blockquote>\n<p>Not in your case. In</p>\n<pre><code>Image operator + (const Image &amp;img) const {\n    Image tmp;\n    // ...\n    return tmp; \n}\n</code></pre>\n<p>You are creating and returning an object of the same type as the return type of the function. This implies that <code>return tmp;</code> will consider <code>tmp</code> as if it was an rvalue as per 12.8/32 (emphasis mine)</p>\n<blockquote>\n<blockquote>\n<p id=\"so_19445070_19445448_3\"><strong>When the criteria for elision of a copy operation are met</strong> or would be met save for the fact that the source object is a function parameter, <strong>and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue.</strong></p>\n</blockquote>\n</blockquote>\n<p>The mentioned criteria are given in 12.8/31, in particular, the first bullet point says (emphasis mine):</p>\n<blockquote>\n<blockquote>\n<p id=\"so_19445070_19445448_5\">\u2014 <strong>in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object</strong> (other than a function or catch-clause parameter) <strong>with the same cv-unqualified type as the function return type, the copy/move operation can be omitted</strong> by constructing the automatic object directly into the function\u2019s return value</p>\n</blockquote>\n</blockquote>\n<p>Actually, a carefull reading of 12.8/31 says that in your case compilers are allowed (and the most popular ones do) to omit the copy or move altogether. This is the so called <em>return value optimization</em> (RVO). Indeed, consider this simplified version of your code:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n\nstruct Image {\n\n    Image() {\n    }\n\n    Image(const Image&amp;) {\n        std::cout &lt;&lt; \"copy\\n\";\n    }\n\n    Image(Image&amp;&amp;) {\n        std::cout &lt;&lt; \"move\\n\";\n    }\n\n    Image operator +(const Image&amp;) const {\n        Image tmp;\n        return tmp;\n    }\n};\n\nint main() {\n    Image src;\n    Image copy = src + src;\n}\n</code></pre>\n<p>Compiled with GCC 4.8.1, this code produces no output, that is, no copy of move operation is performed.</p>\n<p>Let's complicate the code a little bit just to see what happened when RVO cannot be performed.</p>\n<pre><code>    Image operator +(const Image&amp;) const {\n        Image tmp1, tmp2;\n        if (std::rand() % 2)\n            return tmp1;\n        return tmp2;\n    }\n</code></pre>\n<p>Without much of details, RVO cannot be applied here not because the standard forbids so but for other technical reasons. With this implementation of <code>operator +()</code> the code outputs <code>move</code>. That is, there's no copy, only a move operation.</p>\n<p>A last word, based Matthieu M's response to zoska in the OP. As Matthieu M rightly said, it's not advisable to do <code>return std::move(tmp);</code> because it prevents RVO. Indeed, with this implementation</p>\n<pre><code>    Image operator +(const Image&amp;) const {\n        Image tmp;\n        return std::move(tmp);\n    }\n</code></pre>\n<p>The output is <code>move</code>, that is, the move constructor is called, whereas, as we've seen, with <code>return tmp;</code> no copy/move constructor is called. That's the correct behaviour because the expression being return <code>std::move(tmp)</code> is <strong>not</strong> the name of a non-volatile automatic object as required by the RVO rule quoted above.</p>\n<p><strong>Update</strong> In response to user18490 comment. The implementation of <code>operator +()</code> which introduces <code>tmp</code> and <code>tmp2</code> is rather an artificial way to prevent RVO. Let's go back to the initial implementation and consider another way of preventing RVO which also shows the complete picture: compile the code with the option <code>-fno-elide-constructors</code> (also available in clang). The output (in GCC but it might vary in clang) is</p>\n<pre><code>move\nmove\n</code></pre>\n<p>When a function is called stack memory is allocated to build the object to be returned. I emphasize that this is not the variable <code>tmp</code> above. This another unnamed temporary object.</p>\n<p>Then, <code>return tmp;</code> triggers a copy or move from <code>tmp</code> to the unnamed object and the initialization <code>Image cpy = src + src;</code> finally copy/move the unnamed object into <code>cpy</code>. That's the basic semantics.</p>\n<p>Regarding the first copy/move we have the following. Since <code>tmp</code> is an lvalue the copy constructor would normally be used to copy from <code>tmp</code> to the unnamed object. However, the special clause above makes an exception and says that <code>tmp</code> in <code>return tmp;</code> should be considered as if it was an rvalue. Hence the move constructor is called. In addition, when RVO is performed, the move is elided and <code>tmp</code> is actually created on top of the unnamed object.</p>\n<p>Regarding the second copy/move it's even simpler. The unnamed object is an rvalue and therefore the move constructor is selected to move from it to <code>cpy</code>. Now, there's another optimization (which is similar to RVO but AFAIK doesn't have a name) also stated in 12.8/31 (third bullet point) that allows the compiler to avoid the use of the unnamed temporary and use the memory of <code>cpy</code> instead. Therefore, when RVO and this optimization are in place <code>tmp</code>, the unnamed object and <code>cpy</code> are essentially \"the same object\".</p>\n", "LastActivityDate": "2013-10-18T12:41:31.290"}, "bq_ids": {"n4140": {"so_19445070_19445448_3": {"section_id": 481, "quality": 0.6896551724137931, "length": 20}, "so_19445070_19445448_5": {"section_id": 480, "quality": 1.0, "length": 35}, "so_19445070_19445448_4": {"section_id": 480, "quality": 1.0, "length": 35}, "so_19445070_19445448_2": {"section_id": 481, "quality": 0.6896551724137931, "length": 20}}, "n3337": {"so_19445070_19445448_3": {"section_id": 472, "quality": 1.0, "length": 29}, "so_19445070_19445448_5": {"section_id": 471, "quality": 1.0, "length": 35}, "so_19445070_19445448_4": {"section_id": 471, "quality": 1.0, "length": 35}, "so_19445070_19445448_2": {"section_id": 472, "quality": 1.0, "length": 29}}, "n4659": {"so_19445070_19445448_3": {"section_id": 504, "quality": 0.5517241379310345, "length": 16}, "so_19445070_19445448_5": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}, "so_19445070_19445448_4": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}, "so_19445070_19445448_2": {"section_id": 504, "quality": 0.5517241379310345, "length": 16}}}});