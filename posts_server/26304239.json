post_cb({"bq_ids": {"n4140": {"so_26304239_26304339_0": {"length": 50, "quality": 0.9090909090909091, "section_id": 380}}, "n3337": {"so_26304239_26304339_0": {"length": 50, "quality": 0.9090909090909091, "section_id": 371}}, "n4659": {"so_26304239_26304339_0": {"length": 50, "quality": 0.9090909090909091, "section_id": 395}}}, "26305591": {"Id": "26305591", "PostTypeId": "2", "Body": "<p>The answers to your specific problems can be found in both the good answers provided. Since the question title was simply <code>wstring::c_str() contains garbage</code> I'm going to point out a way to get a result that is correct <em>without</em> the <code>decode</code> function. </p>\n<p>Microsoft added a number of <strong>ATL</strong> conversion macros and classes to convert between wide character (Unicode) and MBCS (Ascii). They are available on VS2008. The supported conversions can be found in the <a href=\"http://msdn.microsoft.com/en-us/library/87zae4a3(v=vs.90).aspx\" rel=\"nofollow\">MSDN Documentation</a>:</p>\n<blockquote>\n<p id=\"so_26304239_26305591_0\">ATL 7.0 introduces several new conversion classes and macros, providing significant improvements over the existing macros. The names of the new string conversion classes and macros take the form:\n  <strong>C</strong>SourceType<strong>2</strong>[C]DestinationType[EX]. </p>\n</blockquote>\n<p>[snip]</p>\n<blockquote>\n<p id=\"so_26304239_26305591_1\">SourceType/DestinationType </p>\n<blockquote>\n<p id=\"so_26304239_26305591_6\"><strong>A</strong> = ANSI character string.</p>\n<p id=\"so_26304239_26305591_7\"><strong>W</strong> = Unicode character string.</p>\n<p id=\"so_26304239_26305591_8\"><strong>T</strong> = Generic character string (equivalent to W when _UNICODE is defined, equivalent to A otherwise).</p>\n<p id=\"so_26304239_26305591_9\"><strong>OLE</strong> = OLE character string (equivalent to W).</p>\n</blockquote>\n</blockquote>\n<p>The <code>[EX]</code> is optional and often used if you don't want to specify the size of the default internal buffer that gets used with the macro.</p>\n<p>In your case the conversion macro <code>CA2W</code> (convert Ascii to Widechar) should do what you want. You only need to <code>#include &lt;atlbase.h&gt;</code> to use them. These macros take 2 parameters - the string to be converted and the code page (defaults to CP_ACP if not specified)</p>\n<p>In your case you had:</p>\n<pre><code>std::wstring res = decode(src);\nconst wchar_t *result = res.c_str();\n</code></pre>\n<p>Using the ATL conversion macros you could do it this way:</p>\n<pre><code>std::wstring res = CA2W(src, CP_ACP);\nconst wchar_t *result = res.c_str();\n</code></pre>\n<p>Since the macros default to Ansi Code Page you can also leave off CP_ACP like this:</p>\n<pre><code>std::wstring res = CA2W(src);\nconst wchar_t *result = res.c_str();\n</code></pre>\n<p>Regarding the issue with the <strong>temporary objects</strong> the same thing applies to the class returned by these macros. Microsoft even documents this issue with an incorrect usage example in the link provided earlier:</p>\n<pre><code>// Example 3 \n// Incorrect use of conversion macros. \nvoid ExampleFunction3(LPCWSTR pszW)\n{\n    // Create a temporary instance of CW2A, \n    // save a pointer to it and then delete \n    // the temportary instance.\n    LPCSTR pszA = CW2A(pszW);\n    // The pszA in the following line is an invalid pointer, \n    // as the instance of CW2A has gone out of scope.\n   ExampleFunctionA(pszA);\n}\n</code></pre>\n", "LastEditorUserId": "3857942", "LastActivityDate": "2014-10-10T18:48:13.633", "Score": "1", "CreationDate": "2014-10-10T18:14:22.913", "ParentId": "26304239", "CommentCount": "0", "OwnerUserId": "3857942", "LastEditDate": "2014-10-10T18:48:13.633"}, "26304339": {"Id": "26304339", "PostTypeId": "2", "Body": "<blockquote>\n<h3>12.2 Temporary objects <code>[class.temporary]</code></h3>\n<p id=\"so_26304239_26304339_0\">3 When an implementation introduces a temporary object of a class that has a non-trivial constructor (12.1, 12.8), it shall ensure that a constructor is called for the temporary object. Similarly, the destructor shall be called for a temporary with a non-trivial destructor (12.4). <strong>Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created.</strong> This is true even if that evaluation ends in throwing an exception. The value computations and side effects of destroying a temporary object are associated only with the full-expression, not with any specific subexpression.</p>\n</blockquote>\n<p>So, do not use a temporary after it was destroyed, like in your first example.</p>\n", "LastActivityDate": "2014-10-10T16:52:43.510", "CommentCount": "0", "CreationDate": "2014-10-10T16:52:43.510", "ParentId": "26304239", "Score": "5", "OwnerUserId": "3204551"}, "26304239": {"ViewCount": "829", "Body": "<p>I have a <code>std::wstring decode(const char *s)</code> function.</p>\n<p>I use it like this:</p>\n<pre><code>const char *src = \"some string\";\nconst wchar_t *result = decode(src).c_str();\n</code></pre>\n<p>I always get garbage in <code>result[0]</code>, sometimes in <code>result[1]</code> too.</p>\n<p>I dont get garbage when I use it in another way:</p>\n<pre><code>std::wstring res = decode(src);\nconst wchar_t *result = res.c_str();\n</code></pre>\n<p>My <code>decode</code> function defined as below, and it does it's job. Only problem is calling code(above).</p>\n<pre><code>std::wstring decode(const char *s, UINT cp=CP_ACP)\n{\n    if(s == NULL)\n        return std::wstring();\n    int length = ::MultiByteToWideChar(cp, 0, s, -1, NULL, 0 );\n    wchar_t *buf = new wchar_t[length];\n    ::MultiByteToWideChar(cp, 0, s, -1, buf, length);\n    std::wstring r(buf);\n    delete[] buf;\n    return r;\n}\n</code></pre>\n<p>I use Visual C++ 2008 SP1 to compile.</p>\n", "AcceptedAnswerId": "26304344", "Title": "wstring::c_str() contains garbage", "CreationDate": "2014-10-10T16:46:28.170", "Id": "26304239", "CommentCount": "2", "LastEditDate": "2014-10-10T17:24:08.917", "PostTypeId": "1", "LastEditorUserId": "1307996", "LastActivityDate": "2014-10-10T18:48:13.633", "Score": "1", "OwnerUserId": "1307996", "Tags": "<c++><visual-studio-2008><temporary-objects>", "AnswerCount": "3"}, "26304344": {"Id": "26304344", "PostTypeId": "2", "Body": "<pre><code>const wchar_t *result = decode(src).c_str();\n</code></pre>\n<p>The return value of <code>decode</code> is a temporary value and is destroyed after the call to <code>c_str()</code>. Thus <code>result</code> points to freed memory.</p>\n<p>So either</p>\n<ul>\n<li>extend the lifetime of the return value (assign it to a local variable, for example)</li>\n<li>copy the result</li>\n</ul>\n", "LastActivityDate": "2014-10-10T16:53:21.847", "CommentCount": "2", "CreationDate": "2014-10-10T16:53:21.847", "ParentId": "26304239", "Score": "6", "OwnerUserId": "675646"}});