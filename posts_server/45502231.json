post_cb({"45503131": {"ParentId": "45502231", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Yes, the following two are equivalent where allowed, due to the specific type used.<br>\nThe second one <a href=\"http://coliru.stacked-crooked.com/a/0d3485153a737063\" rel=\"nofollow noreferrer\">is forbidden in <code>constexpr</code>-functions though</a> (<a href=\"https://stackoverflow.com/questions/45502231/confusion-about-auto-deduction-type-in-c?noredirect=1#comment77980079_45502231\">Thanks</a> @<a href=\"https://stackoverflow.com/users/2756719/t-c\">T.C.</a>):</br></p>\n<pre><code>int i = 0;\n\nint i;\ni = 0;\n</code></pre>\n<p>Though they use different means to arrive there (<a href=\"http://en.cppreference.com/w/cpp/language/copy_initialization\" rel=\"nofollow noreferrer\">copy-initialization</a> vs. <a href=\"http://en.cppreference.com/w/cpp/language/default_initialization\" rel=\"nofollow noreferrer\">default-initialization</a> degenerating to no-initialization combined with assignment), the <a href=\"https://stackoverflow.com/questions/15718262/what-exactly-is-the-as-if-rule\">as-if-rule</a> means they are equivalent. If we talked about different non-trivial types, the situation might be different.</p>\n<p>Now, if we substitute <code>auto</code> for <code>int</code>, things get more complicated:<br>\nNo longer do we name the concrete type of our variable, but <a href=\"http://en.cppreference.com/w/cpp/language/auto\" rel=\"nofollow noreferrer\">we let the compiler deduce it</a>.</br></p>\n<p>And the standard states that it will only deduce it from an initializer, which must be part of the declaration.<br>\nIt could easily look slightly further afield, maybe at least <a href=\"http://en.cppreference.com/w/cpp/language/function\" rel=\"nofollow noreferrer\">the way return-type-deduction</a> works for lambdas and C++14 functions, meaning to the first assignment.<br>\nOr it could even try to synthesise a compatible type from all places it is used, like some other languages do it, but that would complicate the rules quite a lot.</br></br></p>\n<p>Anyway, the standard does not allow doing so, and it has the last word on what is and isn't C++, so there we are until and unless someone makes a compelling case to the committee to change it in the next version of the language.</p>\n", "OwnerUserId": "3204551", "LastEditorUserId": "3204551", "LastEditDate": "2017-08-04T14:46:27.473", "Id": "45503131", "Score": "0", "CreationDate": "2017-08-04T09:29:31.713", "LastActivityDate": "2017-08-04T14:46:27.473"}, "45737932": {"ParentId": "45502231", "CommentCount": "0", "Body": "<pre><code>int i;\ni = 0;\n</code></pre>\n<p>and </p>\n<pre><code>int i=0;\n</code></pre>\n<p>give same observable result, but they are <strong>not</strong> equivalent. The former first declares a variable and they <em>assign</em> a value to it, the latter declares a variable and <em>initializes</em> it. So it is in fact equivalent to <code>int i(0);</code></p>\n<p>If you were using more complex classes instead of plain integers, the former code would invoke <code>operator =</code>, while the latter would invoke a copy (or move) constructor.</p>\n<p>That's the reason why <code>auto i=0;</code> makes sense: it defines a variable <code>i</code> of the same type its initializer (here a plain <code>int</code>). But <code>auto i;</code> raises a compilation error because at the time the compiler processes the declaration, it does not know what the type should be.</p>\n", "OwnerUserId": "3545273", "PostTypeId": "2", "Id": "45737932", "Score": "0", "CreationDate": "2017-08-17T14:30:45.213", "LastActivityDate": "2017-08-17T14:30:45.213"}, "45502231": {"CommentCount": "14", "ViewCount": "244", "PostTypeId": "1", "LastEditorUserId": "225647", "CreationDate": "2017-08-04T08:47:54.433", "LastActivityDate": "2017-08-17T14:30:45.213", "Title": "Confusion about 'auto' deduction type", "FavoriteCount": "1", "LastEditDate": "2017-08-17T12:36:26.910", "Id": "45502231", "Score": "2", "Body": "<pre><code>int i = 0;\n</code></pre>\n<p>is equivalent to</p>\n<pre><code>int i;\ni = 0;\n</code></pre>\n<p>Then, </p>\n<pre><code>auto i = 0;\n</code></pre>\n<p>It's OK, working fine. But, </p>\n<pre><code>auto i;\ni = 0;\n</code></pre>\n<p>compiler gives an error.</p>\n<p>So, Why compiler gives an error?</p>\n", "Tags": "<c++><c++11><types><auto>", "OwnerUserId": "7035151", "AnswerCount": "10"}, "45502315": {"ParentId": "45502231", "CommentCount": "0", "Body": "<pre><code>auto i;\ni = 0;\n</code></pre>\n<p>Will not work since <code>auto</code> deduces the type of <code>i</code> from its <em>initializer</em> and in this case you <em>have no initializer</em>.</p>\n<p>On the other hand, this works:</p>\n<pre><code>auto i = 0;\n</code></pre>\n<p>Because now you <em>do have an initializer</em> - <code>0</code> - and since the type of a literal <code>0</code> is <code>int</code> that's what <code>auto</code> deduces the type of <code>i</code> to be.</p>\n", "OwnerUserId": "5910058", "PostTypeId": "2", "Id": "45502315", "Score": "2", "CreationDate": "2017-08-04T08:51:57.030", "LastActivityDate": "2017-08-04T08:51:57.030"}, "45502467": {"ParentId": "45502231", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>It's not equivalent because <a href=\"http://en.cppreference.com/w/cpp/language/auto\" rel=\"nofollow noreferrer\"><code>auto</code></a> is not a type. In both examples, <code>i</code> type is <code>int</code>. <code>auto</code> means that variable type is determined by type of expression it is initialized with (int this case, it's <code>int</code>, as that's the type of literal <code>0</code>). That is,</p>\n<pre><code>auto i = 0;\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code>int i = 0;\n</code></pre>\n<p>The snippet</p>\n<pre><code>auto i;\ni = 0;\n</code></pre>\n<p>does not make sense, because there's no expression that compiler can deduce type from.</p>\n<p>One could argue that compiler could look further to deduce type, but that would be extra effort for little value, so it's unlikely to make way into future C++ standards. And what type would be inferred in the following example:</p>\n<pre><code>auto i;\nif (...)\n    i = 0;\nelse\n    i = \"WAT?\";\n</code></pre>\n<hr>\n<p>BTW, <code>int i = 0;</code> is equivalent to <code>int i; i = 0</code> but is not the same. First is initialization, second is default initialization followed by assignment. For types other than <code>int</code>, namely classes with non-trivial constructors and/or assignment operators, the two snippets may not be equivalent.</p>\n</hr>", "OwnerUserId": "226648", "LastEditorUserId": "226648", "LastEditDate": "2017-08-04T11:34:56.527", "Id": "45502467", "Score": "7", "CreationDate": "2017-08-04T08:59:39.037", "LastActivityDate": "2017-08-04T11:34:56.527"}, "45502292": {"ParentId": "45502231", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>the code</p>\n<pre><code>auto i;\ni = 0;\n</code></pre>\n<p>should not even compile because type of <code>i</code> cannot be determined at compilation time as there's no direct assignment as in your former example, therefore compiler will not know what to substitute <code>auto</code> for <code>i</code> with. In you first example, where you had <code>auto i = 0;</code>, the direct assignment tells the compiler <code>i</code> should be of <code>integer</code> type.</p>\n<p>Docs</p>\n<ul>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/auto\" rel=\"nofollow noreferrer\">auto type</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/template_argument_deduction\" rel=\"nofollow noreferrer\">argument type deduction</a></li>\n</ul>\n", "OwnerUserId": "1235698", "LastEditorUserId": "1235698", "LastEditDate": "2017-08-04T08:58:26.150", "Id": "45502292", "Score": "2", "CreationDate": "2017-08-04T08:50:51.463", "LastActivityDate": "2017-08-04T08:58:26.150"}, "bq_ids": {"n4140": {"so_45502231_45502531_0": {"section_id": 5445, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_45502231_45503777_2": {"section_id": 5242, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_45502231_45502531_0": {"section_id": 6872, "quality": 0.9166666666666666, "length": 11}, "so_45502231_45503777_2": {"section_id": 6875, "quality": 0.5714285714285714, "length": 8}}}, "45506027": {"ParentId": "45502231", "CommentCount": "0", "Body": "<p><code>auto i</code> does not mean \"<code>i</code> can hold anything, so don't worry about what type it is\". C++ requires that the type of any object must be known at the time that the object is created. When you write <code>auto i = something;</code> the compiler looks at the type of <code>something</code> to figure out what the type of <code>i</code> should be. If there is no <code>something</code> there is nothing that tells the compiler what the type of <code>i</code> should be, and you get an error.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "45506027", "Score": "3", "CreationDate": "2017-08-04T11:46:43.790", "LastActivityDate": "2017-08-04T11:46:43.790"}, "45502297": {"ParentId": "45502231", "CommentCount": "0", "Body": "<p>Auto type needs to be deducable by the compiler and once type set it cant be changed. It's a compile time operation. Therefore it needs initialization. This is actually the point in it, ensure variable initialization by moving everything to the right hand side of the =</p>\n", "OwnerUserId": "8382472", "PostTypeId": "2", "Id": "45502297", "Score": "1", "CreationDate": "2017-08-04T08:51:03.937", "LastActivityDate": "2017-08-04T08:51:03.937"}, "45502531": {"ParentId": "45502231", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">draft</a> in section <strong>7.1.6.4 auto specifier</strong> has this entry</p>\n<blockquote>\n<p id=\"so_45502231_45502531_0\">The auto and decltype(auto) type-specifiers are used to designate a\n  placeholder type that will be replaced later by deduction from an\n  initializer.</p>\n</blockquote>\n<p>Hence, <code>auto</code> and <code>decltype(auto)</code> need an <strong>initializer</strong>.</p>\n<pre><code>auto i = 0; // ok, i is of type \"int\" deduced from 0's type\n</code></pre>\n<p>is equivalent to    </p>\n<pre><code>int i = 0;\n</code></pre>\n<p>But</p>\n<pre><code>auto i; // error: no initializer, compiler fails to deduce type\ni = 0;  // error: consequent error, i not declared/defined\n</code></pre>\n<p>will not compile as compiler can not deduce the type of <code>i</code> without the initializer.<br>\nAlso,</br></p>\n<pre><code>int i = 0; // initialized i as 0\n</code></pre>\n<p>is different from </p>\n<pre><code>int i; // default initialized\ni = 0; // invokes copy assignment\n</code></pre>\n", "OwnerUserId": "1389898", "LastEditorUserId": "1389898", "LastEditDate": "2017-08-05T04:06:40.520", "Id": "45502531", "Score": "4", "CreationDate": "2017-08-04T09:02:03.787", "LastActivityDate": "2017-08-05T04:06:40.520"}, "45503777": {"ParentId": "45502231", "CommentCount": "1", "Body": "<p>When a variable is defined with <code>auto</code>, <strong>it must be assigned an initial value</strong>. Otherwise there would be no way to determine its type, because the type of a variable declared <code>auto</code> is <strong>statically</strong> determined by the compiler.</p>\n<p><strong>C++11 standard:</strong></p>\n<blockquote>\n<p id=\"so_45502231_45503777_0\"><strong>7.1.6.4 auto specifier</strong></p>\n<p id=\"so_45502231_45503777_1\">...</p>\n<p id=\"so_45502231_45503777_2\">3 Otherwise, the type of the variable is deduced from its initializer.\n  The name of the variable being declared shall not appear in the\n  initializer expression.</p>\n</blockquote>\n", "OwnerUserId": "6935629", "PostTypeId": "2", "Id": "45503777", "Score": "1", "CreationDate": "2017-08-04T09:57:50.990", "LastActivityDate": "2017-08-04T09:57:50.990"}, "45502310": {"ParentId": "45502231", "CommentCount": "0", "Body": "<p><code>auto</code> just means the compiler will infer the type. You don't give it any information, up until that line, it can use to decide the type and size required. </p>\n", "OwnerUserId": "8340832", "PostTypeId": "2", "Id": "45502310", "Score": "1", "CreationDate": "2017-08-04T08:51:39.680", "LastActivityDate": "2017-08-04T08:51:39.680"}});