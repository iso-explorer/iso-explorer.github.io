post_cb({"bq_ids": {"n4140": {"so_36401999_36404838_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 4317}}, "n3337": {"so_36401999_36404838_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 4158}}, "n4659": {"so_36401999_36404838_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 5572}}}, "36404838": {"Id": "36404838", "PostTypeId": "2", "Body": "<p>The (draft) standard says:</p>\n<pre><code>// 20.8.1.2.1, constructors\n...\ntemplate &lt;class U, class E&gt;\n  unique_ptr(unique_ptr&lt;U, E&gt;&amp;&amp; u) noexcept;\ntemplate &lt;class U&gt;\n  unique_ptr(auto_ptr&lt;U&gt;&amp;&amp; u) noexcept;\n</code></pre>\n<p>Those are constructors from <em>any</em> unique_ptr. The standard further restricts their usage by clauses like this:</p>\n<blockquote>\n<p id=\"so_36401999_36404838_0\">24 <em>Remarks</em>: This constructor shall not participate in overload resolution unless <code>U*</code> is implicitly convertible to <code>T*</code> and <code>D</code> is the same type as <code>default_delete&lt;T&gt;</code></p>\n</blockquote>\n<p>The effect of this remark is that <code>unique_ptr&lt;T&gt;</code> is constructible from <code>unique_ptr&lt;U&gt;</code> precisely <code>U*</code> is convertible to <code>T*</code> (and all deleter requirements are met). In particular, when <code>T</code> is an unambiguous public base class of <code>U</code>.</p>\n<p>Since the constructor is not <code>explicit</code>, it serves as an implicit converter from <code>unique_ptr&lt;U&gt;</code> to <code>unique_ptr&lt;T&gt;</code>.</p>\n", "LastActivityDate": "2016-04-04T14:02:06.320", "CommentCount": "0", "CreationDate": "2016-04-04T14:02:06.320", "ParentId": "36401999", "Score": "2", "OwnerUserId": "775806"}, "36401999": {"ViewCount": "1972", "Body": "<p>I know it is possible that a derived class <code>unique_ptr</code> can take place where base class <code>unique_ptr</code> is required for polymorphic types. For example, while returning from function</p>\n<pre><code>unique_ptr&lt;Base&gt; someFunction()\n{\n     return make_unique&lt;Derived&gt;(new Derived());\n}\n</code></pre>\n<p>or passing to function as argument.</p>\n<pre><code>// Function taking unique pointer\nvoid someOtherFunction(unique_ptr&lt;Base&gt;&amp;&amp; ptr)\n// Code calling this function\nsomeOtherFunction(std::move(ptrToDerived));\n</code></pre>\n<p>My question is: Is this upcasting always automatic? Or do we need to explicitly perform it using <code>dynamic_cast</code>?</p>\n", "AcceptedAnswerId": "36404838", "Title": "Is unique_ptr<Derived> to unique_ptr<Base> up-casting automatic?", "CreationDate": "2016-04-04T11:58:21.667", "Id": "36401999", "CommentCount": "12", "LastEditDate": "2016-04-04T12:00:54.283", "PostTypeId": "1", "LastEditorUserId": "4523099", "LastActivityDate": "2016-04-04T14:02:06.320", "Score": "6", "OwnerUserId": "5031718", "Tags": "<c++11><polymorphism><c++14><unique-ptr>", "AnswerCount": "1"}});