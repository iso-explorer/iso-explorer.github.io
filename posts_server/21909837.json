post_cb({"21909977": {"ParentId": "21909837", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If you are sure that some <code>ptr</code>  is in fact the address of some <code>s-&gt;b</code> (which is not always true) you might try to use <a href=\"http://en.cppreference.com/w/cpp/types/offsetof\" rel=\"nofollow noreferrer\">offsetof</a>:</p>\n<pre><code>Data* getBaseDataPtrFromString(std::string* ptr) {\n   void* ad = (char*)ptr - offsetof(Data,b);\n   return reinterpret_cast&lt;Data*&gt;(ad);\n}\n</code></pre>\n<p>BTW, GCC has a <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Offsetof.html\" rel=\"nofollow noreferrer\">builtin_offsetof</a> to help implementing the <code>offsetof</code> macro (notably in more general cases than those required by the standard). See <a href=\"https://stackoverflow.com/q/400116/841108\">this question</a>.</p>\n", "OwnerUserId": "841108", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:28:29.257", "Id": "21909977", "Score": "1", "CreationDate": "2014-02-20T13:58:12.577", "LastActivityDate": "2014-02-20T14:55:27.880"}, "21909837": {"CommentCount": "7", "ViewCount": "939", "PostTypeId": "1", "LastEditorUserId": "2684539", "CreationDate": "2014-02-20T13:51:50.227", "LastActivityDate": "2014-02-20T14:55:27.880", "Title": "Standard way to find base address of struct from a member", "AcceptedAnswerId": "21910159", "LastEditDate": "2014-02-20T14:29:26.133", "Id": "21909837", "Score": "2", "Body": "<pre><code>struct Data {\n    int a;\n    std::string b;\n    float c;\n};\n\nstd::string* allocateDataAndGetString() {\n    Data* dataPtr(someAllocator.allocate&lt;Data&gt;());\n    return &amp;dataPtr.b;\n}\n\nData* getBaseDataPtrFromString(std::string* mStringMember) {\n    // ???\n}\n\nint main() {\n    std::string* stringPtr(allocateDataAndGetString());\n    Data* dataPtr(getBaseDataPtrFromString\n}\n</code></pre>\n<p>I have a <code>Data</code> instance allocated on the heap, and a pointer to its <code>std::string b;</code> member. How do I get the base address of the <code>Data</code> instance the string is a member of, taking into account offsets and padding, in a standard way?</p>\n<p>I've tried subtracting <code>sizeof(int)</code> and <code>std::offsetof(Data, std::string)</code> from the <code>std::string*</code> pointer, but I couldn't get it to work.</p>\n", "Tags": "<c++><c++11><struct><memory-address><offsetof>", "OwnerUserId": "598696", "AnswerCount": "4"}, "21909971": {"ParentId": "21909837", "CommentCount": "0", "Body": "<p><code>offsetof</code> gives the offset in chars, so you need to cast to <code>mStringMember</code> to <code>char *</code> before doing the pointer arithmetic.</p>\n<pre><code>(Data*)((char*)mStringMember - offsetof(Data, b))\n</code></pre>\n", "OwnerUserId": "3213868", "PostTypeId": "2", "Id": "21909971", "Score": "3", "CreationDate": "2014-02-20T13:58:01.403", "LastActivityDate": "2014-02-20T13:58:01.403"}, "21910987": {"ParentId": "21909837", "CommentCount": "4", "Body": "<p><code>offsetof</code> only works on standard-layout types.</p>\n<p>There is a trick you might be able to use and does not require a standard layout: <code>static_cast</code> knows how to get to a more derived object from a pointer to one of its bases.</p>\n<pre><code>struct Data : private std::string {\nprivate:\n    using b_base = std::string;\npublic:\n    // was int f() const { return b.size(); }\n    int f() const { return b_base::size(); }\n\nprivate:\n    int a;\n    float c;\n    friend Data* getBaseDataPtrFromString(std::string* mStringMember);\n};\n\nData* getBaseDataPtrFromString(std::string* mStringMember) {\n    return static_cast&lt;Data*&gt;(mStringMember);\n}\n</code></pre>\n", "OwnerUserId": "46642", "PostTypeId": "2", "Id": "21910987", "Score": "2", "CreationDate": "2014-02-20T14:39:25.627", "LastActivityDate": "2014-02-20T14:39:25.627"}, "21910159": {"ParentId": "21909837", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Use <code>offsetof</code> from <code>&lt;cstddef&gt;</code>, but beware it is only defined on standard-layout types (<a href=\"http://coliru.stacked-crooked.com/a/bc3f84a73bc570ad\" rel=\"nofollow\">Live at Coliru</a>):</p>\n<pre><code>Data* getBaseDataPtrFromString(std::string* mStringMember) {\n    static_assert(std::is_standard_layout&lt;Data&gt;::value,\n                  \"offsetof() only works on standard-layout types.\");\n    return reinterpret_cast&lt;Data*&gt;(\n      reinterpret_cast&lt;char*&gt;(mStringMember) - offsetof(Data, b)\n    );\n}\n</code></pre>\n<p><code>offsetof</code> is detailed in C++11 18.2/4:</p>\n<blockquote>\n<p id=\"so_21909837_21910159_0\">The macro <code>offsetof</code>(<em>type</em>, <em>member-designator</em>) accepts a restricted set of type arguments in this International Standard. If <em>type</em> is not a standard-layout class (Clause 9), the results are undefined.<sup>195</sup> The expression <code>offsetof</code>(<em>type</em>, <em>member-designator</em>) is never type-dependent (14.6.2.2) and it is value-dependent (14.6.2.3) if and only if <em>type</em> is dependent. The result of applying the <code>offsetof</code> macro to a field that is a static data member or a function member is undefined. No operation invoked by the <code>offsetof</code> macro shall throw an exception and <code>noexcept(offsetof(type, member-designator))</code> shall be <code>true</code>.</p>\n</blockquote>\n<p>and C99 (N1256) 7.17/3:</p>\n<blockquote>\n<p id=\"so_21909837_21910159_1\">The macros are</p>\n<pre><code>NULL\n</code></pre>\n<p id=\"so_21909837_21910159_2\">which expands to an implementation-defined null pointer constant; and</p>\n<pre><code>offsetof(type, member-designator)\n</code></pre>\n<p id=\"so_21909837_21910159_3\">which expands to an integer constant expression that has type <code>size_t</code>, the value of which is the offset in bytes, to the structure member (designated by <em>member-designator</em>), from the beginning of its structure (designated by <em>type</em>). The type and member designator shall be such that given</p>\n<pre><code>static type t;\n</code></pre>\n<p id=\"so_21909837_21910159_4\">then the expression <code>&amp;(t.</code><em>member-designator</em><code>)</code> evaluates to an address constant. (If the specified member is a bit-field, the behavior is undefined.)</p>\n</blockquote>\n<p>The \"restricted set of type arguments in this International Standard\" in the C++ standard is there to draw your attention to the fact that <code>offsetof</code> is more restrictive than is the case for the C standard.</p>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2014-02-20T14:19:32.810", "Id": "21910159", "Score": "5", "CreationDate": "2014-02-20T14:05:30.987", "LastActivityDate": "2014-02-20T14:19:32.810"}, "bq_ids": {"n4140": {"so_21909837_21910159_0": {"section_id": 6706, "quality": 0.7551020408163265, "length": 37}, "so_21909837_21910159_2": {"section_id": 2515, "quality": 0.8, "length": 4}}, "n3337": {"so_21909837_21910159_0": {"section_id": 6461, "quality": 0.7551020408163265, "length": 37}, "so_21909837_21910159_2": {"section_id": 6460, "quality": 0.8, "length": 4}}, "n4659": {"so_21909837_21910159_0": {"section_id": 8181, "quality": 0.6326530612244898, "length": 31}, "so_21909837_21910159_4": {"section_id": 7709, "quality": 0.5454545454545454, "length": 6}}}});