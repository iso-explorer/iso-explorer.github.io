post_cb({"43781464": {"Id": "43781464", "PostTypeId": "2", "Body": "<p>The problem is that <code>Base&lt;T&gt;</code> is a dependent base class, and there may be specializations for it in which <code>Type</code> is not anymore defined. Say for example you have a specialization like</p>\n<pre><code>template&lt;&gt;\nclass Base&lt;int&gt;\n{}; // there's no more Type here\n</code></pre>\n<p>The compiler cannot know this in advance (technically it cannot know until the instantiation of the template), especially if the specialization is defined in a different translation unit. So, the language designers chose to take the easy route: whenever you refer to something that's dependent, you need to explicitly specifify this, like in your case</p>\n<pre><code>using Alias = typename Base&lt;T&gt;::Type;\n</code></pre>\n", "LastActivityDate": "2017-05-04T11:21:01.017", "CommentCount": "0", "CreationDate": "2017-05-04T11:21:01.017", "ParentId": "43781269", "Score": "4", "OwnerUserId": "3093378"}, "43781392": {"Id": "43781392", "PostTypeId": "2", "Body": "<p>Because <code>type</code> is in a \"dependent scope\" you can access it like this:</p>\n<pre><code>typename Base&lt;T&gt;::Type\n</code></pre>\n<p>Your <code>Alias</code> should then be defined like this:</p>\n<pre><code>using Alias = typename Base&lt;T&gt;::Type;\n</code></pre>\n<p>Note that the compiler doesn't, at this point, know if <code>Base&lt;T&gt;::type</code> describes a member variable or a nested type, that is why the keyword <code>typename</code> is required.</p>\n<p><strong>Layers</strong></p>\n<p>You do not need to repeat the definition at <em>every</em> layer, here is an example, <a href=\"http://ideone.com/qaHnBw\" rel=\"nofollow noreferrer\">link</a>:</p>\n<pre><code>template &lt;typename T&gt;\nstruct intermediate : Base&lt;T&gt;\n{\n    // using Type = typename Base&lt;T&gt;::Type; // Not needed\n};\n\ntemplate &lt;typename T&gt;\nstruct Derived : intermediate&lt;T&gt;\n{\n    using Type = typename intermediate&lt;T&gt;::Type;\n};\n</code></pre>\n<p><strong>Update</strong></p>\n<p>You could also use the class it self, this relies on using an <a href=\"http://en.cppreference.com/w/cpp/language/dependent_name#Unknown_specializations\" rel=\"nofollow noreferrer\">unknown specializations</a>.</p>\n<pre><code>template &lt;typename T&gt;\nstruct Derived : Base&lt;T&gt;\n{\n    using Type = typename Derived::Type; // &lt;T&gt; not required here.\n};\n</code></pre>\n", "LastEditorUserId": "2378300", "LastActivityDate": "2017-05-11T08:24:07.773", "Score": "6", "CreationDate": "2017-05-04T11:17:28.763", "ParentId": "43781269", "CommentCount": "7", "OwnerUserId": "2378300", "LastEditDate": "2017-05-11T08:24:07.773"}, "43781574": {"Id": "43781574", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_43781269_43781574_0\">I guess this is something to do with the compiler not being able to check whether or not Type can be pulled in from the base class when it is parsing the definition of Derived outside the context of a specific instantiation of parameter T.</p>\n</blockquote>\n<p>Yes.</p>\n<hr>\n<blockquote>\n<p id=\"so_43781269_43781574_1\">In this case, this is frustrating, as <code>Base</code> always defines <code>Type</code> irrespective of <code>T</code>.</p>\n</blockquote>\n<p>Yes.</p>\n<p>But in general it would be entirely infeasible to detect whether this were true, and extremely confusing if the semantics of the language changed when it were true.</p>\n<hr>\n<blockquote>\n<p id=\"so_43781269_43781574_2\">Perhaps there is a good reason for this.</p>\n</blockquote>\n<p>C++ is a general-purpose programming language, not an optimised-for-the-program-Smeeheey-is-working-on-today programming language. :)</p>\n<hr>\n<blockquote>\n<p id=\"so_43781269_43781574_3\">What is the rule in the standard that states this must happen?</p>\n</blockquote>\n<p>It's this:</p>\n<blockquote>\n<p id=\"so_43781269_43781574_4\"><code>[C++14: 14.6.2/3]:</code> In the definition of a class or class template, if a base class depends on a <em>template-parameter</em>, the base class scope is not examined during unqualified name lookup either at the point of definition of the class template or member or during an instantiation of the class template or member. <em>[..]</em></p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_43781269_43781574_5\">What is a good workaround for precisely this type of problem?</p>\n</blockquote>\n<p>You already know \u2014 qualification:</p>\n<pre><code>using Alias = typename Base&lt;T&gt;::Type;\n</code></pre>\n</hr></hr></hr></hr>", "LastEditorUserId": "560648", "LastActivityDate": "2017-05-04T11:34:46.213", "Score": "3", "CreationDate": "2017-05-04T11:25:46.893", "ParentId": "43781269", "CommentCount": "16", "OwnerUserId": "560648", "LastEditDate": "2017-05-04T11:34:46.213"}, "bq_ids": {"n4140": {"so_43781269_43781574_4": {"length": 27, "quality": 0.9310344827586207, "section_id": 190}}, "n3337": {"so_43781269_43781574_4": {"length": 27, "quality": 0.9310344827586207, "section_id": 184}}, "n4659": {"so_43781269_43781574_4": {"length": 22, "quality": 0.7586206896551724, "section_id": 195}}}, "43781500": {"Id": "43781500", "PostTypeId": "2", "Body": "<p>When defining a template, sometimes things need to be a bit more explicit:</p>\n<pre><code>using Alias = typename Base&lt;T&gt;::Type;\n</code></pre>\n<p>Rougly speaking: a template is a blueprint of sorts. Nothing actually exists until the template get instantiated.</p>\n<p>When doing the same thing, but in a non-template context, a C++ compiler will try to figure out what <code>Type</code> is. It'll try to find it in the base classes, and go from there. Because everything is already declared, and things are pretty much cut-and-dry.</p>\n<p>Here, a base class does not really exist until the template gets instantiated. If you already know about template specialization, that you should realize that the base class may not actually turn out to have a <code>Type</code> member, when the template gets instantiated if there's a specialization for the base class defined later down the road, that's going to override the whole thing, and turn it inside and out.</p>\n<p>As such, when encountering just a plain, old, <code>Type</code> in this context, the compiler can't make a lot of assumptions. It can't assume that it can look in any defined template base classes because those base classes may not actually look anything like the compiler thinks they will look, when things start to solidify; so you have spell everything out, explicitly, for the compiler, and tell the compiler exactly what your are trying to do, here.</p>\n", "LastActivityDate": "2017-05-04T11:22:26.447", "CommentCount": "5", "CreationDate": "2017-05-04T11:22:26.447", "ParentId": "43781269", "Score": "2", "OwnerUserId": "3943312"}, "43785069": {"Id": "43785069", "PostTypeId": "2", "Body": "<p>You cannot use your base class types in a non-deduced context.  C++ refuses to assume unbound names refer to things in your base class.</p>\n<pre><code>template &lt;typename T&gt;\nstruct Base {\n  using Type = int;\n};\ntemplate&lt;&gt;\nstruct Base&lt;int&gt; {};\n\nusing Type=std::string;\n\ntemplate &lt;typename T&gt;\nstruct Derived : Base&lt;T&gt; {\n  using Alias = Type;\n};\n</code></pre>\n<p>Now let us look at what is going on here.  <code>Type</code> is visible in <code>Derived</code> -- a global one.  Should <code>Derived</code> use that or not?</p>\n<p>Under the rule of \"parse nothing until instantiated\", we use the global <code>Type</code> if and only if <code>T</code> is <code>int</code>, due to the <code>Base</code> specialization that removes <code>Type</code> from it.</p>\n<p>Following that rule we run into the problem that we can diagnose basically no errors in the template prior to it being instantiated, because the base class could replace the meaning of almost anything!  Call <code>abs</code>?  Could be a member of the parent!  Mention a type?  Could be from the parent!</p>\n<p>That would force templates to basically be macros; no meaningful parsing could be done prior to instantiating them.  Minor typos could result in massively different behavior.  Almost any incorrectness in a template would be impossible to diagnose without creating test instances.</p>\n<p>Having templates that can be checked for correctness means that when you want to use your parent class types and members, you have to say you are doing so.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2017-05-04T14:26:49.267", "Score": "2", "CreationDate": "2017-05-04T14:01:32.823", "ParentId": "43781269", "CommentCount": "0", "OwnerUserId": "1774667", "LastEditDate": "2017-05-04T14:26:49.267"}, "43782070": {"Id": "43782070", "PostTypeId": "2", "Body": "<p>As a partial response about the point</p>\n<blockquote>\n<p id=\"so_43781269_43782070_0\">[T]his is frustrating, as <code>Base</code> always defines <code>Type</code> irrespective of <code>T</code>.</p>\n</blockquote>\n<p>I'd say: no it does not.</p>\n<p>Please consider the following example differing from yours only by the one line definition of <code>Base&lt;void&gt;</code> and of the definition of <code>Alias</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nstruct Base\n{\n    using Type = int;\n};\n\ntemplate &lt;typename T&gt;\nstruct Derived : Base&lt;T&gt;\n{\n    using Alias = typename Base&lt;T&gt;::Type; // error: no type named 'Type' in 'struct Base&lt;void&gt;'\n};\n\ntemplate&lt;&gt; struct Base&lt;void&gt; {};\n\nint main()\n{\n    Derived&lt;void&gt;::Type b = 1;\n    std::cout &lt;&lt; b &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>In the context of <code>template &lt;typename T&gt; struct Derived : Base&lt;T&gt;</code>, there is no guaranty that <code>Type</code> exists. You must <em>explicitly</em> tell your compiler than <code>Base&lt;T&gt;::Type</code> is a type (with <code>typename</code>) and if you ever fail this contract, you'll end up with a compilation error.</p>\n", "LastActivityDate": "2017-05-04T11:48:13.937", "CommentCount": "3", "CreationDate": "2017-05-04T11:48:13.937", "ParentId": "43781269", "Score": "0", "OwnerUserId": "5470596"}, "43781269": {"ViewCount": "777", "Body": "<p>I have the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nstruct Base\n{\n    using Type = int;\n};\n\ntemplate &lt;typename T&gt;\nstruct Derived : Base&lt;T&gt;\n{\n    //uncommmenting the below cause compiler error\n    //using Alias = Type;\n};\n\nint main()\n{\n    Derived&lt;void&gt;::Type b = 1;\n    std::cout &lt;&lt; b &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Now the typename <code>Type</code> is available to <code>Derived</code> if its in a deduced context - as shown by the perfectly valid declaration of <code>b</code>. However, if I try to refer to <code>Type</code> inside the declaration of <code>Derived</code> itself, then I get a compiler error telling me that <code>Type</code> does not name a type (for example if the definition of <code>Alias</code> is uncommented). </p>\n<p>I guess this is something to do with the compiler not being able to check whether or not <code>Type</code> can be pulled in from the base class when it is parsing the definition of <code>Derived</code> outside the context of a specific instantiation of parameter <code>T</code>. In this case, this is frustrating, as <code>Base</code> <em>always</em> defines <code>Type</code> irrespective of <code>T</code>. So my question is twofold:</p>\n<p>1). Why on Earth does this happen? By this I mean why does the compiler bother parsing <code>Derived</code> at all outside of an instantiation context (I guess non-deduced context), when not doing so would avoid these 'bogus' compiler errors? Perhaps there is a good reason for this. What is the rule in the standard that states this must happen?</p>\n<p>2). What is a good workaround for precisely this type of problem? I have a real-life case where I need to use base class types in the definition of a derived class, but am prevented from doing so by this problem. I guess I'm looking for some kind of 'hide behind non-deduced context' solution, where I prevent this compiler 'first-pass' by putting required definitions/typedefs behind templated classes or something along those lines.</p>\n<p><strong>EDIT:</strong> As some answers below point out, I can use <code>using Alias = typename Base&lt;T&gt;::Type</code>. I should have said from the outset, I'm aware this works. However, its not entirely satisfactory for two reasons: 1) It doesn't use the inheritance hierarchy at all (<code>Derived</code> would not have to be derived from <code>Base</code> for this to work), and I'm precisely trying to use types defined in my base class hierarchy and 2) The real-life case actually has several layers of inheritance. If I wanted to pull in something from several layers up this becomes really quite ugly (I either need to refer to a non-direct ancestor, or else repeat the <code>using</code> at every layer until I reach the one I need it at)</p>\n", "AcceptedAnswerId": "43781392", "Title": "Why is using base class definitions in non-deduced context not permitted, and how to get around this?", "CreationDate": "2017-05-04T11:12:21.667", "Id": "43781269", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-04T11:49:55.733", "LastEditorUserId": "6255513", "LastActivityDate": "2017-05-11T08:24:07.773", "Score": "10", "OwnerUserId": "6255513", "Tags": "<c++><templates><struct>", "AnswerCount": "6"}});