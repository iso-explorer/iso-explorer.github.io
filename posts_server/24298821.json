post_cb({"24298821": {"ViewCount": "317", "Body": "<p>To use dynamic_casting, the inheritance hierarchy needs to be polymorphic. But in the below code segment, dynamic_cast works perfectly for upcasting while it fails at compile time for downcasting? What's the reason upcasting works?</p>\n<pre><code>class B{};\nclass C : public B{};\n\nint main()\n{\n    C* pcob = new C();\n\n    B* bp = dynamic_cast&lt;B*&gt;(pcob);     // #1 : Upcasting works\n\n    if(bp)\n        cout &lt;&lt; \"casted\" &lt;&lt; endl;\n    else\n        cout &lt;&lt; \"bp null\" &lt;&lt; endl;\n    delete bp;    \n\n    B* pbob = new B();\n\n    C* pc = dynamic_cast&lt;C*&gt;(pbob);     // #2 : Downcasting gives error\n\n    if(pc)\n        cout &lt;&lt; \"casted\" &lt;&lt; endl;\n    else\n        cout &lt;&lt; \"pc null\" &lt;&lt; endl;\n\n    delete pbob;\n\n    return 0;\n}\n</code></pre>\n<p>The compile time error at #2 is</p>\n<pre><code>main.cpp: In function \u2018int main()\u2019:\nmain.cpp:36:34: error: cannot dynamic_cast \u2018pbob\u2019 (of type \u2018class B*\u2019) to type \u2018class C*\u2019 (source type is not polymorphic)\n C* pc = dynamic_cast&lt;C*&gt;(pbob);\n</code></pre>\n", "AcceptedAnswerId": "24299807", "Title": "Why upcasting works but downcasting gives compile time error?", "CreationDate": "2014-06-19T04:31:14.837", "Id": "24298821", "CommentCount": "4", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-06-19T06:08:54.100", "Score": "1", "OwnerUserId": "2235661", "Tags": "<c++><casting>", "AnswerCount": "4"}, "24298867": {"Id": "24298867", "PostTypeId": "2", "Body": "<ul>\n<li>#1 works - C has all the capabilities of B with some other ones</li>\n<li>#2 fails - B does not have all the capabilities of a C</li>\n</ul>\n<p>Set theory really</p>\n", "LastActivityDate": "2014-06-19T04:35:19.410", "CommentCount": "0", "CreationDate": "2014-06-19T04:35:19.410", "ParentId": "24298821", "Score": "1", "OwnerUserId": "892256"}, "24298847": {"Id": "24298847", "PostTypeId": "2", "Body": "<p>class <code>B</code> needs at least one <code>virtual</code> method. Otherwise the type is not polymorphic and <code>dynamic_cast</code> can not be applied for downcasting. The former case is <em>implicit type conversion</em>.</p>\n<blockquote>\n<p id=\"so_24298821_24298847_0\">But dynamic_cast is used explicitly. How compiler can ignore it?</p>\n</blockquote>\n<p>From standard (5.2.7/5)</p>\n<blockquote>\n<p id=\"so_24298821_24298847_1\">If T is \u201cpointer to cv1 B\u201d and v has type \u201cpointer to cv2 D\u201d such that B is a base class of D, the result is a\n  pointer to the unique B subobject of the D object pointed to by v. Similarly, if T is \u201creference to cv1 B\u201d and\n  v has type cv2 D such that B is a base class of D, the result is the unique B subobject of the D object referred\n  to by v.\n  68\n  The result is an lvalue if T is an lvalue reference, or an xvalue if T is an rvalue reference. In\n  both the pointer and reference cases, the program is ill-formed if cv2 has greater cv-qualification than cv1 or if B is an inaccessible or ambiguous base class of D. [ Example:</p>\n</blockquote>\n<pre><code>struct B { };\nstruct D : B { };\nvoid foo(D* dp) {\n  B* bp = dynamic_cast&lt;B*&gt;(dp); // equivalent to B* bp = dp;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_24298821_24298847_2\">\u2014end example ]</p>\n</blockquote>\n", "LastEditorUserId": "1390091", "LastActivityDate": "2014-06-19T05:57:13.120", "Score": "3", "CreationDate": "2014-06-19T04:33:46.030", "ParentId": "24298821", "CommentCount": "10", "OwnerUserId": "1390091", "LastEditDate": "2014-06-19T05:57:13.120"}, "bq_ids": {"n4140": {"so_24298821_24299050_0": {"length": 6, "quality": 0.75, "section_id": 6011}, "so_24298821_24299050_1": {"length": 14, "quality": 1.0, "section_id": 6015}, "so_24298821_24299050_2": {"length": 4, "quality": 0.8, "section_id": 6016}, "so_24298821_24298847_1": {"length": 48, "quality": 0.96, "section_id": 6015}}, "n3337": {"so_24298821_24299050_0": {"length": 6, "quality": 0.75, "section_id": 5779}, "so_24298821_24299050_1": {"length": 14, "quality": 1.0, "section_id": 5783}, "so_24298821_24299050_2": {"length": 5, "quality": 1.0, "section_id": 5784}, "so_24298821_24298847_1": {"length": 48, "quality": 0.96, "section_id": 5783}}, "n4659": {"so_24298821_24299050_0": {"length": 6, "quality": 0.75, "section_id": 4087}, "so_24298821_24299050_1": {"length": 14, "quality": 1.0, "section_id": 7514}, "so_24298821_24299050_2": {"length": 4, "quality": 0.8, "section_id": 7515}, "so_24298821_24298847_1": {"length": 41, "quality": 0.82, "section_id": 7514}}}, "24299807": {"Id": "24299807", "PostTypeId": "2", "Body": "<p>The Standard's been quoted - praise be.</p>\n<p>To get an idea why the Standard specifies the behaviour it does, it helps to consider what you're asking the compiler to do and how that relates to common implementations of runtime type information....</p>\n<p>Your <code>dynamic_cast&lt;B*&gt;(pcob)</code> only needs to know the offset of a <code>B</code> relative to the containing <code>C</code> - that's a constant amount for every <code>C</code> object, even if that <code>C</code> is embedded in some other object.  There's no reliance on anything unknown until runtime.</p>\n<p>Contrast that with <code>dynamic_cast&lt;C*&gt;(pbob)</code> for <code>B* pbob</code> - the compiler can't generally know whether the pointed-to <code>B</code> is embedded in another object at all, let alone whether that object happens to be - or also be derived from - <code>C</code>, such that the cast can succeed.  In general, it needs to rely on the runtime type information only generated for polymorphic types.</p>\n<p>In your specific code, the compiler knows the actual types of all the objects, and with only a little effort could have supported the downcast, but similar code in a function that gets a <code>B*</code> parameter or calls some opaque factory method returning a <code>B*</code> may sometimes <code>dynamic_cast</code> with a runtime object containing a <code>C</code> and other times not - the compiler can't employ any \"localised\" knowledge of the real types.  In local usage, you can easily create pointers to the actual runtime type, so there's no utility gained from requiring the compilers to support \"localised\" usage, and the Standard simply bans such casts wholesale.</p>\n", "LastActivityDate": "2014-06-19T06:08:54.100", "CommentCount": "0", "CreationDate": "2014-06-19T06:08:54.100", "ParentId": "24298821", "Score": "1", "OwnerUserId": "410767"}, "24299050": {"Id": "24299050", "PostTypeId": "2", "Body": "<p><code>dynamic_cast</code> does not require a polymorphic type for upcasting. </p>\n<p>Some basics from 5.2.7/1 [expr.dynamic.cast] </p>\n<blockquote>\n<p id=\"so_24298821_24299050_0\">The result of the expression dynamic_cast(v) is the result of converting the expression v to type T.</p>\n</blockquote>\n<p>However this does not cover why the type does not have to be polymorphic. To get a slightly better understanding the following quotes from 5.2.7/5 and 5.2.7/6 clear it up a bit.</p>\n<blockquote>\n<p id=\"so_24298821_24299050_1\">If T is \"pointer to cv1 B\" and v has type \"pointer to cv2 D\" such that B is a base class of D, the result is a pointer to the unique B sub-object of the D object pointed to by v.</p>\n</blockquote>\n<pre><code>struct B { };\nstruct D : B { };\nvoid foo(D* dp) {\n    B* bp = dynamic_cast&lt;B*&gt;(dp); // equivalent to B* bp = dp;\n}\n</code></pre>\n<p>The above provides the specific instance of upcasting from D to B with compatible <em>cv</em> qualifiers (const-volatile).</p>\n<p>The next part 5.2.7/6 sheds a little more light on why the source type does not have to be polymorphic</p>\n<blockquote>\n<p id=\"so_24298821_24299050_2\">Otherwise, v shall be a pointer to or an lvalue of a polymorphic type.</p>\n</blockquote>\n<p>the key here is the use of \"Otherwise\". To look at this from the other direction If D is not implicitly convertible to B then D must be polymorphic <em>otherwise</em> a polymorphic type is not required.</p>\n", "LastEditorUserId": "845568", "LastActivityDate": "2014-06-19T05:03:39.057", "Score": "1", "CreationDate": "2014-06-19T04:57:08.923", "ParentId": "24298821", "CommentCount": "0", "OwnerUserId": "845568", "LastEditDate": "2014-06-19T05:03:39.057"}});