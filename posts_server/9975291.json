post_cb({"9975741": {"Id": "9975741", "PostTypeId": "2", "Body": "<p>What is probably happening is that the template instantiation is happening separately for class <code>A</code> and <code>B</code>, thus ending in two <code>void f(int)</code> functions.</p>\n<p>This does not happen in <code>D</code> since  there the compiler knows about the <code>void f(int)</code> function as a specialization and therefore does not specialize <code>T</code> for <code>int</code>.</p>\n", "LastActivityDate": "2012-04-02T11:40:44.963", "Score": "0", "CreationDate": "2012-04-02T11:40:44.963", "ParentId": "9975291", "CommentCount": "0", "OwnerUserId": "551045"}, "9975528": {"Id": "9975528", "PostTypeId": "2", "Body": "<p>A compiler doesn't know which method to call from the C class because templated method will be transormed in void f(int) in case of int type so you have two methods with the same name and same arguments but members of different parent classes.</p>\n<pre><code>template&lt;typename T&gt; void f(T x) {} \n</code></pre>\n<p>or </p>\n<pre><code>void f(int)\n</code></pre>\n<p>try this:</p>\n<pre><code>c.B::f&lt;int&gt;(3);\n</code></pre>\n<p>or this for the A class:</p>\n<pre><code>c.A::f(3);\n</code></pre>\n", "LastActivityDate": "2012-04-02T11:25:10.103", "Score": "0", "CreationDate": "2012-04-02T11:25:10.103", "ParentId": "9975291", "CommentCount": "9", "OwnerUserId": "1000930"}, "9975686": {"Id": "9975686", "PostTypeId": "2", "Body": "<p>I believe the compiler prefers <code>A::f</code> (non-template function) over <code>B::f</code> for no reason.<br>\nThis seems to be a compiler <strong>implementation bug</strong> more than a implementation dependent detail.</br></p>\n<p>If you add following line, then <a href=\"http://ideone.com/bGtqF\" rel=\"nofollow\">compilation goes fine</a> and the correct function <code>B::f&lt;&gt;</code> is selected:</p>\n<pre><code>struct C : public A, public B { \n  using A::f; // optional\n  using B::f;\n};\n</code></pre>\n<p>[Funny part is that until the <code>::f</code> are not brought into the scope of <code>C</code>, they are treated as alien functions.]</p>\n", "LastActivityDate": "2012-04-02T11:36:57.133", "Score": "1", "CreationDate": "2012-04-02T11:36:57.133", "ParentId": "9975291", "CommentCount": "4", "OwnerUserId": "514235"}, "bq_ids": {"n4140": {"so_9975291_9975452_3": {"length": 5, "quality": 1.0, "section_id": 111}, "so_9975291_9975452_2": {"length": 49, "quality": 0.9607843137254902, "section_id": 571}}, "n3337": {"so_9975291_9975452_3": {"length": 5, "quality": 1.0, "section_id": 106}, "so_9975291_9975452_2": {"length": 49, "quality": 0.9607843137254902, "section_id": 562}}, "n4659": {"so_9975291_9975452_3": {"length": 5, "quality": 1.0, "section_id": 115}, "so_9975291_9975452_2": {"length": 49, "quality": 0.9607843137254902, "section_id": 594}}}, "9975452": {"Id": "9975452", "PostTypeId": "2", "Body": "<p>The first part is due to member name lookup, that's why it fails. </p>\n<p>I would refer you to: <code>10.2/2 Member name lookup</code></p>\n<blockquote>\n<p id=\"so_9975291_9975452_0\">The following steps define the result of name lookup in a class scope,\n  C. First, every declaration for the name in the class and in each of\n  its base class sub-objects is considered. A member name f in one\n  sub-object B hides a member name f in a sub-object A if A is a base\n  class sub-object of B. Any declarations that are so hidden are\n  eliminated from consideration. Each of these declarations that was\n  introduced by a using-declaration is considered to be from each\n  sub-object of C that is of the type containing the declaration\n  designated by the using-declaration.</p>\n<p id=\"so_9975291_9975452_1\"><strong>If the resulting set of declarations are not all from sub-objects of\n  the same type, or the set has a nonstatic member and includes members\n  from distinct sub-objects, there is an ambiguity and the program is\n  ill-formed</strong>. Otherwise that set is the result of the lookup.</p>\n</blockquote>\n<p>Now, for the matter with template functions.</p>\n<p>As per <code>13.3.1/7 Candidate functions and argument list</code></p>\n<blockquote>\n<p id=\"so_9975291_9975452_2\">In each case where a candidate is a function template, candidate\n  function template specializations are generated using template\n  argument deduction (14.8.3, 14.8.2). Those candidates are then handled\n  as candidate functions in the usual way. A given name can refer to one\n  or more function templates and also to a set of overloaded\n  non-template functions. In such a case, the candidate functions\n  generated from each function template are combined with the set of\n  non-template candidate functions.</p>\n</blockquote>\n<p>And if you continue reading <code>13.3.3/1 Best viable function</code></p>\n<p>F1 is considered to be a <em>better</em> function, if:</p>\n<blockquote>\n<p id=\"so_9975291_9975452_3\">F1 is a non-template function and F2 is a function template\n  specialization</p>\n</blockquote>\n<p>That's why the following snippet compiles and runs the non-template function without error:</p>\n<pre><code>D c;\nc.f(1);\n</code></pre>\n", "LastEditorUserId": "58961", "LastActivityDate": "2012-04-02T12:13:30.643", "Score": "11", "CreationDate": "2012-04-02T11:19:40.590", "ParentId": "9975291", "CommentCount": "10", "LastEditDate": "2012-04-02T12:13:30.643", "OwnerUserId": "58961"}, "9975291": {"ViewCount": "3143", "Body": "<pre><code>struct A {\n    void f(int x) {}\n};\n\nstruct B {\n    template&lt;typename T&gt; void f(T x) {}\n};\n\nstruct C : public A, public B {};\n\nstruct D {\n    void f(int x){}\n    template&lt;typename T&gt; void f(T x) {} \n};\n\n\nint main(int argc, char **argv) {\n    C c;\n    c.f&lt;int&gt;(3);\n    D d;\n    d.f&lt;int&gt;(3);\n}\n</code></pre>\n<p>What is the reason for which calling <code>d.f</code> is fine, but <code>c.f</code> gives </p>\n<pre><code>error: request for member \u2018f\u2019 is ambiguous\nerror: candidates are: template&lt;class T&gt; void B::f(T)\nerror:                 void A::f(int)\n</code></pre>\n", "AcceptedAnswerId": "9975452", "Title": "Ambiguous when two superclasses have a  member function with the same name, but different signatures", "CreationDate": "2012-04-02T11:08:14.590", "Id": "9975291", "CommentCount": "5", "FavoriteCount": "12", "PostTypeId": "1", "LastEditDate": "2012-04-03T05:11:10.700", "LastEditorUserId": "1296119", "LastActivityDate": "2012-04-03T05:11:10.700", "Score": "27", "OwnerUserId": "1296119", "Tags": "<c++><templates><class-hierarchy>", "AnswerCount": "5"}, "9975708": {"Id": "9975708", "PostTypeId": "2", "Body": "<p>Consider this simpler example:</p>\n<pre><code>struct A{\n void f(int x){}\n};\n\nstruct B{\n void f(float t){}\n};\n\n\nstruct C:public A,public B{\n};\n\nstruct D{\n void f(float n){}\n void f(int n){}\n};\n\n\nint main(){\n C c;\n c.f(3);\n\n D d;\n d.f(3);\n}\n</code></pre>\n<p>In this example, same as yours, <code>D</code> compiles but <code>C</code> does not. <br>\nIf a class is a derived one, member lookup mechanism behaves different. It checks each base class and merges them: In the case of <code>C</code>; Each base class matches the lookup ( A::f(int) and B::f(float) ). Upon merging them <code>C</code> decides they are ambiguous. <br/></br></p>\n<p>For the case class <code>D</code>: <code>int</code> version is selected instead of <code>float</code> because parameter is an integer. </p>\n", "LastActivityDate": "2012-04-02T11:38:21.063", "Score": "0", "CreationDate": "2012-04-02T11:38:21.063", "ParentId": "9975291", "CommentCount": "5", "OwnerUserId": "2632003"}});