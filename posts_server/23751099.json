post_cb({"23751631": {"ParentId": "23751099", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_23751099_23751631_0\"><code>virtual ~basic_filebuf();</code></p>\n<p id=\"so_23751099_23751631_1\"><strong>27.9.1.2/5</strong> Effects: Destroys an object of class\n  <code>basic_filebuf&lt;charT,traits&gt;</code>. Calls <code>close()</code>. If an exception occurs\n  during the destruction of the object, including the call to close(),\n  the exception is <strong>caught but not rethrown</strong> (see 17.6.5.12).</p>\n</blockquote>\n<p>Emphasis mine.</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "23751631", "Score": "3", "CreationDate": "2014-05-20T05:27:09.207", "LastActivityDate": "2014-05-20T05:27:09.207"}, "23751698": {"ParentId": "23751099", "CommentCount": "0", "Body": "<p>The behavior you observed is standard. The <code>basic_ifstream</code> class contains a <code>basic_filebuf</code> object (<em>\u00a727.9.1.6</em>). The destructor of the <code>basic_filebuf</code> object calls <code>basic_filebuf::close</code> but suppresses any exceptions that are thrown.</p>\n<p>Quoting <em>\u00a727.9.1.2/5 [filebuf.cons]</em> (emphasis added)</p>\n<blockquote>\n<p id=\"so_23751099_23751698_0\"><code>virtual ~basic_filebuf();</code><br/><em>Effects:</em> Destroys an object of class\n  <code>basic_filebuf&lt;charT,traits&gt;</code>. Calls <code>close()</code>. If an exception occurs\n  during the destruction of the object, including the call to <code>close()</code>,\n  <strong>the exception is caught but not rethrown</strong> (see 17.6.5.12).</p>\n</blockquote>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "23751698", "Score": "1", "CreationDate": "2014-05-20T05:31:08.817", "LastActivityDate": "2014-05-20T05:31:08.817"}, "23751099": {"CommentCount": "0", "ViewCount": "93", "CreationDate": "2014-05-20T04:37:36.527", "LastActivityDate": "2014-05-20T05:31:08.817", "Title": "What is std::ios::exceptions expected behavior in destructor?", "AcceptedAnswerId": "23751631", "PostTypeId": "1", "Id": "23751099", "Score": "1", "Body": "<p>Consider this snippet:</p>\n<pre><code>// Case 1: Explicitly calling close() does throw, as expected.\n{\n    std::ifstream f;\n    f.exceptions ( std::ifstream::failbit | std::ifstream::badbit );\n    f.close();  // This will throw std::ifstream::failure, as close() on unopened file sets the failbit\n}\n\n// Case 2: close() will be called by destructor of object 'g', but does not throw.\n{\n    std::ifstream g;\n    g.exceptions ( std::ifstream::failbit | std::ifstream::badbit );\n} // Does not throw, even though \"g's\" destructor will call close() method\n</code></pre>\n<p>Now I do understand that destructors should never leak exceptions in C++ (and that is perhaps the reason for the observed behavior in Case 2). My question is: Is the above observed behavior guaranteed to be so by C++ standards, or is it just an artifact (and if yes, is there any difference between C++03 &amp; C++11 in this regard ? Any relevant citation to C++ standards will be very helpful).</p>\n<p>Also, how is this special case of not throwing inside destructor usually implemented, does the destructor code simply catches exceptions thrown by close(), and ignores them ? Can someone point me to the implementation of this in any of the major compiler source code.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1857518", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23751099_23751631_1": {"section_id": 2420, "quality": 0.8636363636363636, "length": 19}, "so_23751099_23751698_0": {"section_id": 2420, "quality": 0.8636363636363636, "length": 19}}, "n3337": {"so_23751099_23751631_1": {"section_id": 2405, "quality": 0.8636363636363636, "length": 19}, "so_23751099_23751698_0": {"section_id": 2405, "quality": 0.8636363636363636, "length": 19}}, "n4659": {"so_23751099_23751631_1": {"section_id": 2695, "quality": 0.8181818181818182, "length": 18}, "so_23751099_23751698_0": {"section_id": 2695, "quality": 0.8181818181818182, "length": 18}}}});