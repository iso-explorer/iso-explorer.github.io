post_cb({"32700032": {"CommentCount": "3", "ViewCount": "586", "PostTypeId": "1", "LastEditorUserId": "2013747", "CreationDate": "2015-09-21T16:20:19.460", "LastActivityDate": "2015-09-22T02:50:43.200", "Title": "Are members of a POD-struct or standard layout type guaranteed to be aligned according to their alignment requirements?", "AcceptedAnswerId": "32700393", "LastEditDate": "2015-09-21T16:52:54.893", "Id": "32700032", "Score": "13", "Body": "<p>Given a POD-struct (in C++03) or a standard layout type (in C++11), with all members having a fundamental alignment requirement, is it true that every member is guaranteed to be aligned according to its alignment requirement?</p>\n<p>In other words, for all members <code>m_k</code> in { <code>m0</code> ... <code>mn</code> } of standard layout type <code>S</code>, </p>\n<pre><code>  struct S {\n    T0 m0;\n    T1 m1;\n    ...\n    TN mn;\n  };\n</code></pre>\n<p>is the following expression guaranteed to evaluate to <code>true</code>?</p>\n<pre><code>  (offsetof(S,m_k) % alignof(decltype(S::m_k))) == 0\n</code></pre>\n<p>Please give answers for both C++03 and C++11 and cite the relevant parts of the standard. Supporting evidence from C standards would also be helpful.</p>\n<hr>\n<p>My reading of the C++03 standard (ISO/IEC 14882:2003(E)) is that it is silent regarding the alignment of members within a POD-struct, except for the first member. The relevant paragraphs are:</p>\n<p>In the language of the specification, an <strong>object</strong> is a \"region of storage\":</p>\n<blockquote>\n<p id=\"so_32700032_32700032_0\">1.8 The C + + object model [intro.object]</p>\n<p id=\"so_32700032_32700032_1\">1.8/1 The constructs in a C + + program create, destroy, refer to, access, and manipulate objects. An object is a region of storage. ...</p>\n</blockquote>\n<p>Objects are allocated according to their alignment requirement:</p>\n<blockquote>\n<p id=\"so_32700032_32700032_2\">3.9 Types [basic.types]</p>\n<p id=\"so_32700032_32700032_3\">3.9/5 Object types have alignment requirements (3.9.1, 3.9.2). The alignment of a complete object type is an implementation-defined integer value representing a number of bytes; <strong>an object is allocated at an address that meets the alignment requirements of its object type.</strong></p>\n</blockquote>\n<p>Fundamental types have alignment requirements:</p>\n<blockquote>\n<p id=\"so_32700032_32700032_4\">3.9.1 Fundamental types [basic.fundamental] </p>\n<p id=\"so_32700032_32700032_5\">3.9.1/3 For each of the signed integer types, there exists a corresponding (but different) unsigned integer type: \"unsigned char\", \"unsigned short int\", \"unsigned int\", and \"unsigned long int,\" each of which occupies the same amount of storage <strong>and has the same alignment requirements (3.9) as the corresponding signed integer type</strong>;... </p>\n</blockquote>\n<p>Padding <em>may</em> occur due to \"implementation alignment requirements\":</p>\n<blockquote>\n<p id=\"so_32700032_32700032_6\">9.2 Class members [class.mem]</p>\n<p id=\"so_32700032_32700032_7\">9.2/12 Nonstatic data members of a (non-union) class declared without an intervening access-specifier are allocated so that later members have higher addresses within a class object. The order of allocation of nonstatic\n  data members separated by an access-specifier is unspecified (11.1). <strong>Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other</strong>; so might requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).</p>\n</blockquote>\n<p>Does the word \"allocated\" in 9.2/12 have the same meaning as \"allocated\" in 3.9/5? Most uses of \"allocated\" in the spec refer to dynamic storage allocation, not struct-internal layout. The use of <em>may</em> in 9.2/12 seems to imply that the alignment requirements of 3.9/5 and 3.9.1/3 might not be strictly required for struct members.</p>\n<p>The first member of a POD-struct will be aligned according to the alignment requirement of the struct:</p>\n<blockquote>\n<p id=\"so_32700032_32700032_8\">9.2/17 A pointer to a POD-struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [<strong>Note: There might therefore be unnamed padding within a POD-struct object, but not at its beginning, as necessary to achieve appropriate alignment.</strong> ]</p>\n</blockquote>\n<p>[Emphasis added in all of the above quotes.]</p>\n</hr>", "Tags": "<c++><c++11><language-lawyer><memory-alignment><c++03>", "OwnerUserId": "2013747", "AnswerCount": "2"}, "32700393": {"ParentId": "32700032", "PostTypeId": "2", "CommentCount": "16", "Body": "<p>Each element of a POD struct is itself an object, and objects can only be allocated in accordance with the alignment requirements for those objects.  The alignment requirements may change, though, due to the fact that something is a sub-object of another object ([basic.align]/1, 2:</p>\n<blockquote>\n<p id=\"so_32700032_32700393_0\">1 Object types have <em>alignment requirements</em> (3.9.1, 3.9.2) which place restrictions on the addresses at which an object of that type may be allocated. An <em>alignment</em> is an implementation-defined integer value representing the number of bytes between successive addresses at which a given object can be allocated. An object type imposes an alignment requirement on every object of that type; stricter alignment can be requested using the alignment specifier (7.6.2). </p>\n<p id=\"so_32700032_32700393_1\">2 A <em>fundamental alignment</em> is represented by an alignment less than or equal to the greatest alignment supported by the implementation in all contexts, which is equal to <code>alignof(std::max_align_t)</code> (18.2). <strong>The alignment required for a type might be different when it is used as the type of a complete object and when it is used as the type of a subobject</strong>. [<em>Example:</em></p>\n<pre><code>struct B { long double d; };\nstruct D : virtual B { char c; }\n</code></pre>\n<p id=\"so_32700032_32700393_2\">When <code>D</code> is the type of a complete object, it will have a subobject of type <code>B</code>, so it must be aligned appropriately for a <code>long double</code>. If <code>D</code> appears as a subobject of another object that also has <code>B</code> as a virtual base class, the\n  <code>B</code> subobject might be part of a different subobject, reducing the alignment requirements on the <code>D</code> subobject.\u2014<em>end example</em> ] <strong>The result of the <code>alignof</code> operator reflects the alignment requirement of the type in the\n  complete-object case.</strong></p>\n</blockquote>\n<p>[emphasis added]</p>\n<p>Although the examples refer to a sub-object via inheritance, the normative wording just refers to sub-objects in general, so I believe the same rules apply, so on one hand you <em>can</em> assume that each sub-object is aligned so that it can be accessed. On the other hand, no you <em>can't</em> necessarily assume that will be the same alignment that <code>alignof</code> gives you.</p>\n<p>[The reference is from N4296, but I believe the same applies to all recent versions. C++98/03, of course, didn't have <code>alignof</code> at all, but I believe the same basic principle applies--members will be aligned so they can be used, but that alignment requirement isn't necessarily the same as when they're used as independent objects.]</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2015-09-22T02:50:43.200", "Id": "32700393", "Score": "10", "CreationDate": "2015-09-21T16:40:23.973", "LastActivityDate": "2015-09-22T02:50:43.200"}, "bq_ids": {"n4140": {"so_32700032_32700393_0": {"section_id": 7240, "quality": 0.8636363636363636, "length": 38}, "so_32700032_32700393_2": {"section_id": 7241, "quality": 0.926829268292683, "length": 38}, "so_32700032_32700414_1": {"section_id": 7241, "quality": 0.9285714285714286, "length": 39}, "so_32700032_32700032_3": {"section_id": 7240, "quality": 0.5714285714285714, "length": 16}, "so_32700032_32700032_1": {"section_id": 5790, "quality": 0.75, "length": 9}, "so_32700032_32700032_5": {"section_id": 7212, "quality": 0.9444444444444444, "length": 34}, "so_32700032_32700414_0": {"section_id": 7241, "quality": 0.8571428571428571, "length": 12}, "so_32700032_32700393_1": {"section_id": 7241, "quality": 0.8666666666666667, "length": 26}, "so_32700032_32700032_7": {"section_id": 5873, "quality": 0.8076923076923077, "length": 42}}, "n3337": {"so_32700032_32700393_0": {"section_id": 6984, "quality": 0.8636363636363636, "length": 38}, "so_32700032_32700032_8": {"section_id": 5650, "quality": 0.8857142857142857, "length": 31}, "so_32700032_32700414_1": {"section_id": 6985, "quality": 0.9285714285714286, "length": 39}, "so_32700032_32700032_3": {"section_id": 6984, "quality": 0.5714285714285714, "length": 16}, "so_32700032_32700032_1": {"section_id": 5563, "quality": 0.75, "length": 9}, "so_32700032_32700032_5": {"section_id": 6956, "quality": 0.9444444444444444, "length": 34}, "so_32700032_32700414_0": {"section_id": 6985, "quality": 0.8571428571428571, "length": 12}, "so_32700032_32700393_2": {"section_id": 6985, "quality": 0.926829268292683, "length": 38}, "so_32700032_32700393_1": {"section_id": 6985, "quality": 0.8666666666666667, "length": 26}, "so_32700032_32700032_7": {"section_id": 5644, "quality": 0.8076923076923077, "length": 42}}, "n4659": {"so_32700032_32700393_0": {"section_id": 8749, "quality": 0.8409090909090909, "length": 37}, "so_32700032_32700393_2": {"section_id": 8750, "quality": 0.926829268292683, "length": 38}, "so_32700032_32700032_3": {"section_id": 8749, "quality": 0.5357142857142857, "length": 15}, "so_32700032_32700032_1": {"section_id": 7247, "quality": 0.8333333333333334, "length": 10}, "so_32700032_32700414_1": {"section_id": 8750, "quality": 0.9285714285714286, "length": 39}, "so_32700032_32700032_5": {"section_id": 8721, "quality": 0.9444444444444444, "length": 34}, "so_32700032_32700414_0": {"section_id": 8750, "quality": 0.8571428571428571, "length": 12}, "so_32700032_32700393_1": {"section_id": 8750, "quality": 0.8666666666666667, "length": 26}, "so_32700032_32700032_7": {"section_id": 7356, "quality": 0.8076923076923077, "length": 42}}}, "32700414": {"ParentId": "32700032", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There are two distinct alignment requirements for each type. One corresponds to complete objects, the other one to subobjects. [basic.align]/2:</p>\n<blockquote>\n<p id=\"so_32700032_32700414_0\"><strong>The alignment required for a type might be different when it is used\n  as the type of a complete object and when it is used as the type of a\n  subobject.</strong> [ <em>Example</em>:</p>\n<pre><code>struct B { long double d; };\nstruct D : virtual B { char c; };\n</code></pre>\n<p id=\"so_32700032_32700414_1\">When <code>D</code> is the type of a complete object, it will have a subobject of\n  type <code>B</code>, so it must be aligned appropriately for a <code>long double</code>. If\n  <code>D</code> appears as a subobject of another object that also has B as a\n  virtual base class, the <code>B</code> subobject might be part of a different\n  subobject, reducing the alignment requirements on the <code>D</code> subobject.\n  \u2014<em>end example</em> ] <strong>The result of the <code>alignof</code> operator reflects the alignment requirement of the type in the complete-object case</strong>.</p>\n</blockquote>\n<p>I can't think of any specific example for member subobjects - and there assuredly is none! -, but the above paragraph concedes the possibility that a member subobject has weaker alignment than <code>alignof</code> will yield, which would fail your condition.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-09-21T16:57:22.153", "Id": "32700414", "Score": "6", "CreationDate": "2015-09-21T16:41:29.940", "LastActivityDate": "2015-09-21T16:57:22.153"}});