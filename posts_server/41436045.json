post_cb({"41436045": {"CommentCount": "4", "ViewCount": "34", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-01-03T03:34:33.093", "LastActivityDate": "2017-01-03T03:47:47.543", "Title": "Different behavior observed upon doing erase(iterator) on vector and map", "AcceptedAnswerId": "41436134", "LastEditDate": "2017-05-23T10:30:38.347", "Id": "41436045", "Score": "0", "Body": "<p>A simple <a href=\"http://www.cplusplus.com/reference/vector/vector/\" rel=\"nofollow noreferrer\">std::vector</a></p>\n<pre><code>std::vector&lt;int&gt; integers;\nintegers.push_back(10);\nintegers.push_back(11);    \ncout  &lt;&lt; \"Before: \" &lt;&lt; integers.size();  //prints 2\n</code></pre>\n<p>I tried using 3 different versions of code to erase each element one by one C++5.1 and C++14</p>\n<p>Version 1:</p>\n<pre><code>for( std::vector&lt;int&gt;::iterator it = integers.begin() ; it != integers.end() ; )\n{\n  cout &lt;&lt; \"\\nVal: \" &lt;&lt; *it;\n  it = integers.erase(it); \n}\n\ncout &lt;&lt; \"\\nAfter: \" &lt;&lt; integers.size(); \n</code></pre>\n<p>Output: [<strong><a href=\"https://stackoverflow.com/questions/263945/what-happens-if-you-call-erase-on-a-map-element-while-iterating-from-begin-to\">Expected</a></strong>] </p>\n<pre><code>Before: 2\nVal: 10\nVal: 11\nAfter: 0\n</code></pre>\n<p>Version 2 in C++14: </p>\n<pre><code>for( std::vector&lt;int&gt;::iterator it1, it = integers.begin() ; it != integers.end() ; )\n{\n    cout &lt;&lt; \"\\nVal: \" &lt;&lt; *it;\n    it1 = std::next(it);\n    integers.erase(it);\n    it = it1;\n}\n</code></pre>\n<p>Output: [<strong>Unexpected</strong>] </p>\n<pre><code>Before: 2\nVal: 10\nAfter: 1\n</code></pre>\n<p>While for <a href=\"http://www.cplusplus.com/reference/map/map/\" rel=\"nofollow noreferrer\">std::map</a>, version 2 works as expected:</p>\n<pre><code>int main() {\n    std::map&lt;int, int&gt; m;\n    m.insert(make_pair(10, 11));\n    m.insert(make_pair(12, 13));\n    cout  &lt;&lt; \"Before: \" &lt;&lt; m.size();\n\n    for( std::map&lt;int, int&gt;::iterator it1, it = m.begin() ; it != m.end() ; )\n    {\n        cout &lt;&lt; \"\\nVal:  \" &lt;&lt; it-&gt;first &lt;&lt; \", \" &lt;&lt; it-&gt;second;\n        it1 = std::next(it);\n        m.erase(it);\n        it = it1;\n    }\n    cout &lt;&lt; \"\\nAfter: \" &lt;&lt; m.size();\n    return 0;\n}\n</code></pre>\n<p>Outputs:</p>\n<pre><code>Before: 2\nVal:  10, 11\nVal:  12, 13\nAfter: 0\n</code></pre>\n<p>Even this works :</p>\n<pre><code>for( std::map&lt;int, int&gt;::iterator it1, it = m.begin() ; it != m.end() ; )\n{\n    cout &lt;&lt; \"\\nVal:  \" &lt;&lt; it-&gt;first &lt;&lt; \", \" &lt;&lt; it-&gt;second;\n    m.erase(it++);\n}\n</code></pre>\n<p><strong>Why version 2 works on std::map but not on std::vector?</strong></p>\n", "Tags": "<c++><vector><iterator><stdmap><erase>", "OwnerUserId": "1465553", "AnswerCount": "1"}, "41436134": {"ParentId": "41436045", "CommentCount": "4", "Body": "<p>The difference is that <code>std::vector</code> iterators are invalidated after erasing an element while for associative containers (23.2.4 Associative container)</p>\n<blockquote>\n<p id=\"so_41436045_41436134_0\">9 The insert and emplace members shall not a\ufb00ect the validity of\n  iterators and references to the container, and the <strong>erase members\n  shall invalidate only iterators and references to the erased\n  elements</strong>.</p>\n</blockquote>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "41436134", "Score": "1", "CreationDate": "2017-01-03T03:47:47.543", "LastActivityDate": "2017-01-03T03:47:47.543"}, "bq_ids": {"n4140": {"so_41436045_41436134_0": {"section_id": 745, "quality": 0.875, "length": 14}}, "n3337": {"so_41436045_41436134_0": {"section_id": 734, "quality": 0.875, "length": 14}}, "n4659": {"so_41436045_41436134_0": {"section_id": 803, "quality": 0.875, "length": 14}}}});