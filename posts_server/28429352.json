post_cb({"bq_ids": {"n4140": {"so_28429352_28429453_0": {"length": 41, "quality": 0.9534883720930233, "section_id": 5965}}, "n3337": {"so_28429352_28429453_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 5734}}, "n4659": {"so_28429352_28429453_0": {"length": 37, "quality": 0.8604651162790697, "section_id": 7456}}}, "28429616": {"Id": "28429616", "PostTypeId": "2", "Body": "<p>A function pointer is just that: a pointer to some bits of code. No data.</p>\n<p>A lambda with captures also needs the captured data in order to give useful results.</p>\n<p>There's no way that could work automatically. But, depending on how the callback function gets called, you may be able to work around it. Your <code>legacy</code> function doesn't save the callback anywhere, it only calls it during its own execution. Additionally, you're not using threading or anything like that. As long as those assumptions hold, you can work around the problem:</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;functional&gt;\n\ntypedef int (*Callback)();\n\nvoid legacy(Callback callback) {\n    printf(\"%i\\n\", callback());\n}\n\n// Declared as void * outside legacyWrapper, instead of T * inside legacyWrapper,\n// because no more than one variable is needed, no matter how many instantiations of\n// legacyWrapper there are.\nstatic void *legacyWrapperCallback;\n\ntemplate &lt;typename T&gt;\nvoid legacyWrapper(T callback) {\n    legacyWrapperCallback = &amp;callback;\n    legacy([]() -&gt; int { return (*static_cast&lt;T *&gt;(legacyWrapperCallback))(); });\n}\n\nint stdCallback() {    \n    return 1; \n}\n\nint main(int argc, char* argv[]) {\n    int number = 3;    \n\n    // Standard C callback works\n    legacy(stdCallback);\n\n    // Lambda without capturing works\n    legacy([]() { return 2; });    \n\n    // Lambda with capturing doesn't work...\n    //legacy([&amp;]() { return number; });\n\n    // ...unless the C++ wrapper is used\n    legacyWrapper([&amp;]() { return number; });\n\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "743382", "LastActivityDate": "2015-02-10T10:55:04.957", "Score": "5", "CreationDate": "2015-02-10T10:41:25.387", "ParentId": "28429352", "CommentCount": "2", "OwnerUserId": "743382", "LastEditDate": "2015-02-10T10:55:04.957"}, "28429352": {"ViewCount": "259", "Body": "<p>I'm using a C library in a C++11 project and this C library provides a function which expects a function pointer. I want to pass a C++11 lambda to it which works correctly unless I capture variables. Here is a short example:</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;functional&gt;\n\ntypedef int (*Callback)();\n\nvoid legacy(Callback callback) {\n    printf(\"%i\\n\", callback());\n}\n\nint stdCallback() {    \n    return 1; \n}\n\nint main(int argc, char* argv[]) {\n    int number = 3;    \n\n    // Standard C callback works\n    legacy(stdCallback);\n\n    // Lambda without capturing works\n    legacy([]() { return 2; });    \n\n    // Lambda with capturing doesn't work\n    legacy([&amp;]() { return number; });\n\n    return 0;\n}\n</code></pre>\n<p>The GNU C++ compiler gives me the following error message in the third call to the <code>legacy</code> function:</p>\n<pre><code>test.cpp: In function \u2018int main(int, char**)\u2019:\ntest.cpp:24:36: error: cannot convert \u2018main(int, char**)::&lt;lambda()&gt;\u2019 to \u2018Callback {aka int (*)()}\u2019 for argument \u20181\u2019 to \u2018void legacy(Callback)\u2019\n legacy([&amp;]() { return number; });\n</code></pre>\n<p>How can I fix this? Or is it technically not possible to use a capturing lambda as a C function pointer?</p>\n", "Title": "Pass lambdas with capturing to legacy callbacks", "CreationDate": "2015-02-10T10:28:02.883", "LastActivityDate": "2015-02-10T13:04:19.873", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "Id": "28429352", "Score": "7", "OwnerUserId": "274473", "Tags": "<c++><c++11><lambda>", "AnswerCount": "2"}, "28429453": {"Id": "28429453", "PostTypeId": "2", "Body": "<p>No, you can't convert a lamdba to a function pointer if it captures anything.</p>\n<p>C++ Standard, section \u00a7 5.1.2 / 6 : [expr.prim.lambda], emphasis mine :</p>\n<blockquote>\n<p id=\"so_28429352_28429453_0\">The closure type for a non-generic lambda-expression <strong>with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function</strong> with C ++ language linkage (7.5) having the same parameter and return types as the closure type\u2019s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type\u2019s function call operator</p>\n</blockquote>\n", "LastEditorUserId": "3510483", "LastActivityDate": "2015-02-10T13:04:19.873", "Score": "9", "CreationDate": "2015-02-10T10:32:31.977", "ParentId": "28429352", "CommentCount": "0", "OwnerUserId": "3510483", "LastEditDate": "2015-02-10T13:04:19.873"}});