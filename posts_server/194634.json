post_cb({"194634": {"CommentCount": "0", "ViewCount": "31030", "PostTypeId": "1", "LastEditorUserId": "2932052", "FavoriteCount": "20", "CreationDate": "2008-10-11T20:59:19.783", "LastActivityDate": "2014-06-02T11:31:51.727", "AnswerCount": "5", "LastEditDate": "2014-06-02T11:31:51.727", "LastEditorDisplayName": "swilliams", "Title": "string c_str() vs. data()", "Id": "194634", "Score": "68", "Body": "<p>I have read several places that the difference between <code>c_str()</code> and <code>data()</code> (in STL and other implementations) is that <code>c_str()</code> is always null terminated while <code>data()</code> is not.\nAs far as I have seen in actual implementations, they either do the same or <code>data()</code> calls <code>c_str()</code>.</p>\n<p>What am I missing here?\nWhich one is more correct to use in which scenarios?</p>\n", "Tags": "<c++><stl><c-str>", "OwnerDisplayName": "leon"}, "194654": {"CommentCount": "3", "CreationDate": "2008-10-11T21:12:22.267", "LastEditorUserId": "3153", "LastActivityDate": "2008-10-11T21:22:58.830", "ParentId": "194634", "PostTypeId": "2", "LastEditorDisplayName": "Brian R. Bondy", "LastEditDate": "2008-10-11T21:22:58.830", "Id": "194654", "Score": "16", "Body": "<p>Even know you have seen that they do the same, or that .data() calls .c_str(), it is not correct to assume that this will be the case for other compilers.  It is also possible that your compiler will change with a future release.  </p>\n<p><strong>2 reasons to use std::string:</strong></p>\n<p>std::string can be used for both text and arbitrary binary data.</p>\n<pre><code>//Example 1\n//Plain text:\nstd::string s1;\ns1 = \"abc\";\n\n//Example 2\n//Arbitrary binary data:\nstd::string s2;\ns2.append(\"a\\0b\\0b\\0\", 6);\n</code></pre>\n<p>You should use the .c_str() method when you are using your string as example 1. </p>\n<p>You should use the .data() method when you are using your string as example 2. Not because it is dangereous to use .c_str() in these cases, but because it is more explicit that you are working with binary data for others reviewing your code. </p>\n<p><strong>Possible pitfall with using .data()</strong> </p>\n<p>The following code is wrong and could cause a segfault in your program:</p>\n<pre><code>std::string s;\ns = \"abc\";   \nchar sz[512]; \nstrcpy(sz, s.data());//This could crash depending on the implementation of .data()\n</code></pre>\n<p><strong>Why is it common for implementers to make .data() and .c_str() do the same thing?</strong></p>\n<p>Because it is more efficient to do so.  The only way to make .data() return something that is not null terminated, would be to have .c_str() or .data() copy their internal buffer, or to just use 2 buffers.   Having a single null terminated buffer always means that you can always use just one internal buffer when implementing std::string. </p>\n", "OwnerUserId": "3153", "OwnerDisplayName": "Brian R. Bondy"}, "194638": {"CommentCount": "0", "CreationDate": "2008-10-11T21:01:15.550", "LastEditorUserId": "146041", "LastActivityDate": "2013-10-29T11:10:00.990", "ParentId": "194634", "PostTypeId": "2", "LastEditorDisplayName": "Scott Langham", "LastEditDate": "2013-10-29T11:10:00.990", "Id": "194638", "Score": "77", "Body": "<p>The documentation is correct. Use <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/c_str\" rel=\"noreferrer\"><code>c_str()</code></a> if you want a null terminated string.</p>\n<p>If the implementers happend to implement <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/data\" rel=\"noreferrer\"><code>data()</code></a> in terms of <code>c_str()</code> you don't have to worry, still use <code>data()</code> if you don't need the string to be null terminated, in some implementation it may turn out to perform better than c_str().</p>\n<p>strings don't necessarily have to be composed of character data, they could be composed with elements of any type. In those cases <code>data()</code> is more meaningful. <code>c_str()</code> in my opinion is only really useful when the elements of your string are character based.</p>\n<p><em>Extra</em>: In C++11 onwards, both functions are required to be the same. i.e. <code>data</code> is now required to be null-terminated.  According to <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/data\" rel=\"noreferrer\">cppreference</a>: \"The returned array is null-terminated, that is, data() and c_str() perform the same function.\"</p>\n", "OwnerUserId": "11898", "OwnerDisplayName": "Scott Langham"}, "7661733": {"ParentId": "194634", "CommentCount": "0", "Body": "<p>Quote from <code>ANSI ISO IEC 14882 2003</code> (C++03 Standard):</p>\n<pre><code>    21.3.6 basic_string string operations [lib.string.ops]\n\n    const charT* c_str() const;\n\n    Returns: A pointer to the initial element of an array of length size() + 1 whose first size() elements\nequal the corresponding elements of the string controlled by *this and whose last element is a\nnull character specified by charT().\n    Requires: The program shall not alter any of the values stored in the array. Nor shall the program treat the\nreturned value as a valid pointer value after any subsequent call to a non-const member function of the\nclass basic_string that designates the same object as this.\n\n    const charT* data() const;\n\n    Returns: If size() is nonzero, the member returns a pointer to the initial element of an array whose first\nsize() elements equal the corresponding elements of the string controlled by *this. If size() is\nzero, the member returns a non-null pointer that is copyable and can have zero added to it.\n    Requires: The program shall not alter any of the values stored in the character array. Nor shall the program\ntreat the returned value as a valid pointer value after any subsequent call to a non- const member\nfunction of basic_string that designates the same object as this.\n</code></pre>\n", "OwnerUserId": "509233", "PostTypeId": "2", "Id": "7661733", "Score": "1", "CreationDate": "2011-10-05T13:04:42.587", "LastActivityDate": "2011-10-05T13:04:42.587"}, "12399518": {"ParentId": "194634", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In <a href=\"https://stackoverflow.com/questions/7747069/where-can-i-find-the-c11-standard-papers\">C++11/C++0x</a>, <code>data()</code> and <code>c_str()</code> is no longer different. And thus <code>data()</code> is required to have a null termination at the end as well.</p>\n<blockquote>\n<p id=\"so_194634_12399518_0\">21.4.7.1 <code>basic_string</code> accessors [string.accessors] </p>\n<p id=\"so_194634_12399518_1\"><code>const charT* c_str() const noexcept;</code> </p>\n<p id=\"so_194634_12399518_2\"><code>const charT* data() const noexcept;</code> </p>\n<p id=\"so_194634_12399518_3\">1 Returns: A pointer p such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_194634_12399518_4\">21.4.5 basic_string element access [string.access]</p>\n<p id=\"so_194634_12399518_5\"><code>const_reference operator[](size_type pos) const noexcept;</code> </p>\n<p id=\"so_194634_12399518_6\">1 Requires: pos &lt;= size().\n  2 Returns: <code>*(begin() + pos) if pos &lt; size()</code>, otherwise a reference to an object of type T \n  with value <code>charT();</code> the referenced value shall not be modi\ufb01ed.</p>\n</blockquote>\n</hr>", "OwnerUserId": "27048", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:02:20.447", "Id": "12399518", "Score": "19", "CreationDate": "2012-09-13T04:41:20.793", "LastActivityDate": "2013-10-17T22:46:56.990"}, "11280444": {"ParentId": "194634", "CommentCount": "0", "Body": "<p>It has been answered already, some notes on the purpose: Freedom of implementation.</p>\n<p><code>std::string</code> operations - e.g. iteration, concatenation and element mutation - don't need the zero terminator. Unless you pass the <code>string</code> to a function expecting a zero terminated string, it can be omitted.</p>\n<p>This would allow an implementation to have substrings share the actual string data: <code>string::substr</code> could internally hold a reference to shared string data, and the start/end range, avoiding the copy (and additional allocation) of the actual string data. The implementation would defer the copy until you call c_str or modify any of the strings. No copy would ever be made if the strigns involved are just read. </p>\n<p>(copy-on-write implementation aren't much fun in multithreaded environments, plus the typical memory/allocation savings aren't worth the more complex code today, so it's rarely done).</p>\n<hr>\n<p>Similarly, <code>string::data</code> allows a different internal representation, e.g. a rope (linked list of string segments). This can improve insert / replace operations significantly. again, the list of segments would have to be collapsed to a single segment when you call <code>c_str</code> or <code>data</code>.</p>\n</hr>", "OwnerUserId": "31317", "PostTypeId": "2", "Id": "11280444", "Score": "2", "CreationDate": "2012-07-01T08:04:28.317", "LastActivityDate": "2012-07-01T08:04:28.317"}, "bq_ids": {"n4140": {"so_194634_12399518_6": {"section_id": 1617, "quality": 0.5294117647058824, "length": 9}}, "n3337": {"so_194634_12399518_2": {"section_id": 1836, "quality": 0.8, "length": 4}, "so_194634_12399518_1": {"section_id": 1836, "quality": 0.8, "length": 4}, "so_194634_12399518_6": {"section_id": 1613, "quality": 0.5294117647058824, "length": 9}}, "n4659": {"so_194634_12399518_1": {"section_id": 1984, "quality": 0.8, "length": 4}, "so_194634_12399518_2": {"section_id": 1984, "quality": 0.8, "length": 4}, "so_194634_12399518_6": {"section_id": 1770, "quality": 0.5882352941176471, "length": 10}}}});