post_cb({"5814259": {"Id": "5814259", "PostTypeId": "2", "Body": "<p>Sorry about the super late answer.</p>\n<p>The problem is that, in C, <code>register</code> originally meant storing values in a register which is why only <code>int</code> and <code>char</code> can be used for it. But with time and especially standard C++, it broadened to \"fast access\" rather than \"in register of CPU\".\nSo in C++, an array maybe a <code>register</code> type but we know that it is not possible to store arrays in a CPU register. Hence, it is logically okay to address a C++ register (in the above sense), but will still make no sense if the values are actually in a CPU register.</p>\n", "LastEditorUserId": "438971", "LastActivityDate": "2012-11-23T15:39:06.873", "CommentCount": "0", "CreationDate": "2011-04-28T05:57:45.723", "ParentId": "1256246", "Score": "5", "OwnerUserId": "728635", "LastEditDate": "2012-11-23T15:39:06.873"}, "1256267": {"PostTypeId": "2", "Body": "<p>This is an educated guess only, but I doubt that you can take the address of a register in C++ because such a think simply doesn't exist. C++ probably doesn't use a register in your particular case. Notice that the storage class qualifier <code>register</code> is only a hint to the compiler (and most if not all modern compilers happily ignore it completely).</p>\n", "LastActivityDate": "2009-08-10T17:52:23.750", "Id": "1256267", "CommentCount": "0", "CreationDate": "2009-08-10T17:52:23.750", "ParentId": "1256246", "Score": "0", "OwnerUserId": "1968"}, "1256273": {"Id": "1256273", "PostTypeId": "2", "Body": "<p>Here's an excerpt from Section 6.7.1 (footnote 101) of the <a href=\"http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1124.pdf\" rel=\"nofollow noreferrer\">C99 standard (pdf)</a>:</p>\n<blockquote>\n<p id=\"so_1256246_1256273_0\">The implementation may treat any <code>register</code> declaration simply as an <code>auto</code> declaration. However, <strong>whether or not addressable storage is actually used, the address of any part of an object declared with storage-class specifier register cannot be computed</strong>, either explicitly (by use of the unary <code>&amp;</code> operator as discussed in 6.5.3.2) or implicitly (by converting an array name to a pointer as discussed in 6.3.2.1). Thus, the only operator that can be applied to an array declared with storage-class specifier <code>register</code> is <code>sizeof</code>.</p>\n</blockquote>\n<p>And from Section 7.1.1, Paragraph 3 of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow noreferrer\">C++ standard (pdf)</a>:</p>\n<blockquote>\n<p id=\"so_1256246_1256273_1\">A <code>register</code> specifier has the same semantics as an <code>auto</code> specifier together with a hint to the implementation that the object so declared will be heavily used. <strong>[Note: the hint can be ignored and in most implementations it will be ignored if the address of the object is taken. \u2014end note]</strong></p>\n</blockquote>\n<h2>Fun tidbits about <code>register</code></h2>\n<p>The C++ group (WG21) <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#809\" rel=\"nofollow noreferrer\">wants to deprecate <code>register</code></a>:</p>\n<blockquote>\n<p id=\"so_1256246_1256273_2\">The <code>register</code> keyword serves very little function, offering no more than a hint that a note says is typically ignored. It should be deprecated in this version of the standard, freeing the reserved name up for use in a future standard, much like <code>auto</code> has been re-used this time around for being similarly useless.  </p>\n<p id=\"so_1256246_1256273_3\"><strong>Notes from the March, 2009 meeting:</strong></p>\n<p id=\"so_1256246_1256273_4\">The consensus of the CWG was in favor of deprecating <code>register</code>.</p>\n</blockquote>\n<p>Look what the C99 group (WG14) <a href=\"http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1300.pdf\" rel=\"nofollow noreferrer\">said about <code>register</code> (pdf)</a> at a meeting:</p>\n<blockquote>\n<p id=\"so_1256246_1256273_5\">General agreement to deprecate the \u201c<code>auto</code>\u201d keyword. Should we ask WG21 to go back to\n  the previous use of \u201c<code>register</code>\u201d (no address)? No, this will not fly with WG21.</p>\n</blockquote>\n", "LastEditorUserId": "68086", "LastActivityDate": "2015-08-26T17:43:40.037", "CommentCount": "7", "CreationDate": "2009-08-10T17:53:23.470", "ParentId": "1256246", "Score": "30", "OwnerUserId": "68086", "LastEditDate": "2015-08-26T17:43:40.037"}, "1256289": {"Id": "1256289", "PostTypeId": "2", "Body": "<p>The important thing to remember is that \"register\" is just a hint to the compiler (a pointless one at that; I've never seen any speed improvement, and most compilers probably just ignore it). C and C++ are both allowed to ignore your \"advice\" and keep the variable in memory. Of course, if you take the address of the variable, it will force it to assign a spot in memory.</p>\n<p>C and C++ just have different rules about what you can do because they are different languages. The C++ designers decided to allow you to get the address of a register variable because it doesn't hurt anything; C doesn't allow you to do it because it would force it into memory.</p>\n<p>Thinking about it more, C's restriction is probably for the same reason that variables had to be declared at the beginning of the block\u2014the compiler can layout the memory for variables as it encounters them, without regard to how it's used later in the function.</p>\n", "LastEditorUserId": "2214", "LastActivityDate": "2009-08-10T18:10:18.240", "CommentCount": "0", "CreationDate": "2009-08-10T17:55:50.203", "ParentId": "1256246", "Score": "1", "OwnerUserId": "2214", "LastEditDate": "2009-08-10T18:10:18.240"}, "5815245": {"PostTypeId": "2", "Body": "<p>I assume that the keyword wouldn't have even made it into the language if it weren't for C compatibility.  While I can not speak with any authority, if this is so, it seems to me there is a practical reason for it to be legal beyond simply a standard-enforced \"the compiler is smarter than you\" clause: C++ takes addresses of things without permission more readily than C does.  Specifically: member functions, and references. </p>\n<p>Because member functions require an implicit <code>this</code> parameter, it would be impossible to call them from an object declared <code>register</code>.  In C, there is nothing prohibiting you from saying <code>register struct X x;</code>, so such language would have to be allowed in C++ [since C-compatibility is the whole reason the keyword even exists].  But if you prohibit calling member functions as well as taking addresses, that also covers the initial constructor call.  In essence, it would not work on non-POD types.  So you end up with one storage class specifier that is only valid for a small subset of the legal types, when all the rest can be used for anything.  </p>\n<p>You also could not create references to such objects, even though, technically, the compiler does not have to treat references as pointers.  <code>register int i; int&amp; x;</code> is not required to have space for two variables, but if you later do <code>&amp;x</code> you end up with a pointer to <code>i</code>.  So the initial construct has to be rendered illegal.  While this seems like a non-issue, since references don't exist in C anyhow, returning to our previous point, POD types declared with the <code>register</code> specifier can no longer be copied.  The compiler-provided copy constructor is of the form <code>X::X(const X&amp;)</code> or <code>X::X(X&amp;)</code> as appropriate. </p>\n<p>So, in order to maintain C compatibility, they have to make <code>register</code> unique as a storage class specifier in that it does not apply to all types, and modify at least two different parts of the standard elsewhere [to specify that you can not create a reference to a variable declared with the <code>register</code> specifier, and to somehow work around the references for POD copying].  Or, they could just say \"its okay to take the address\" and let compilers decide whether or not to honor the requests.  Something they were planning on doing anyhow.</p>\n", "LastActivityDate": "2011-04-28T07:34:40.333", "Id": "5815245", "CommentCount": "0", "CreationDate": "2011-04-28T07:34:40.333", "ParentId": "1256246", "Score": "3", "OwnerUserId": "293791"}, "bq_ids": {"n4140": {"so_1256246_1256273_1": {"length": 16, "quality": 0.6153846153846154, "section_id": 5393}, "so_1256246_1256293_0": {"length": 16, "quality": 0.6153846153846154, "section_id": 5393}}, "n3337": {"so_1256246_1256293_0": {"length": 16, "quality": 0.6153846153846154, "section_id": 5187}, "so_1256246_1256273_1": {"length": 16, "quality": 0.6153846153846154, "section_id": 5187}}}, "1256263": {"Id": "1256263", "PostTypeId": "2", "Body": "<p>C and C++ are two different languages, with a large common subset.  That's why some things are different between them.</p>\n<p>While I don't understand your question, <code>register</code> is (at least in C++) a hint that a variable might be accessed more frequently, and nothing more.  In C, it means you can't take the address with the <code>&amp;</code> unary operator, which made a certain amount of sense at the time.  In the early days of C, it was expected that the compiler might not bother allocating memory for the variable, and so there would not necessarily be an address to take.</p>\n<p>(Computers normally have registers, which are quick-access parts of the CPU, and hence the fastest storage to access.  A variable might live in a register, rather than in memory, if that caused better performance.)</p>\n<p>Nowadays, almost all compilers are sophisticated enough to do their own allocation better than the programmer can, so using <code>register</code> is almost always pointless.</p>\n", "LastEditorUserId": "14148", "LastActivityDate": "2009-08-10T18:00:02.160", "CommentCount": "0", "CreationDate": "2009-08-10T17:52:03.690", "ParentId": "1256246", "Score": "0", "OwnerUserId": "14148", "LastEditDate": "2009-08-10T18:00:02.160"}, "1256272": {"PostTypeId": "2", "Body": "<p>A register variable doesn't have an address, it's held (at least it's supposed to be held) in a cpu register. Since the register modifier is nothing but a hint, if you force the compiler to generate code to extract it's address, the modifier will be ignored and you'll end up with a regular variable held in memory.</p>\n<p>To directly answer your question, whichever one lets you take a register variable's address (your original post is contradicting itself..) lets you ignore your own hint and should at least issue a warning. IMO the correct implementation would be to disallow taking the address of a register variable.</p>\n", "LastActivityDate": "2009-08-10T17:53:19.413", "Id": "1256272", "CommentCount": "4", "CreationDate": "2009-08-10T17:53:19.413", "ParentId": "1256246", "Score": "1", "OwnerUserId": "108796"}, "1256293": {"PostTypeId": "2", "Body": "<p>The register keyword is a hint only and can be ignored. Most C++ compilers ignore it all of the time, but any C++ compiler will ignore it if you take the address of the variable, or create a reference to it. </p>\n<p>On the other hand, a C++ compiler doesn't <em>have</em> to ignore \"register\" just because you take the variable's address. In theory the compiler could store it in a register and give you some magic pointer value that is somehow mapped to the register behind the scenes, but that would be a lot of work for very little gain, so no compiler (that I know of) does anything like that.</p>\n<p>Since register is ignorable in C as well, I suspect that the explicit proscription against taking addresses of register variables was simply to alleviate C compilers from the burden of checking for this.</p>\n<p>The relevant part of the C++ standard is 7.1.1.3:</p>\n<blockquote>\n<p id=\"so_1256246_1256293_0\">A register specifier has the same semantics as an auto specifier together with a hint to the implementation that the object so declared will be heavily used. [Note: the hint can be ignored and in most implementations it will be ignored if the address of the object is taken. \u2014end note]</p>\n</blockquote>\n", "LastActivityDate": "2009-08-10T17:56:44.647", "Id": "1256293", "CommentCount": "1", "CreationDate": "2009-08-10T17:56:44.647", "ParentId": "1256246", "Score": "5", "OwnerUserId": "39375"}, "1256246": {"ViewCount": "8179", "Body": "<p>In C, we cannot use &amp; to find out the address of a register variable but in C++ we can do the same. Why is it legal in C++ but not in C? Can someone please explain this concept in-depth. </p>\n", "AcceptedAnswerId": "1256273", "Title": "Address of register variable", "CreationDate": "2009-08-10T17:47:38.410", "Id": "1256246", "CommentCount": "3", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-05-27T00:07:42.250", "LastEditorDisplayName": "Anthony Cuozzo", "LastEditorUserId": "31671", "LastActivityDate": "2015-08-26T17:43:40.037", "Score": "15", "OwnerUserId": "122959", "Tags": "<c++><c><keyword><register-allocation>", "AnswerCount": "8"}});