post_cb({"10426714": {"ParentId": "10426428", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You have two options:</p>\n<pre><code>    this-&gt;b.blah::template set&lt;int&gt;(); \n     //     ^^^^^^ Be very explicit what set you want\n</code></pre>\n<p>Alternatively don't use <code>using namespace</code> (the best option).</p>\n", "OwnerUserId": "14065", "LastEditorUserId": "14065", "LastEditDate": "2012-05-03T07:17:56.283", "Id": "10426714", "Score": "3", "CreationDate": "2012-05-03T07:09:36.443", "LastActivityDate": "2012-05-03T07:17:56.283"}, "10426428": {"CommentCount": "12", "ViewCount": "560", "PostTypeId": "1", "LastEditorUserId": "955273", "CreationDate": "2012-05-03T06:46:33.570", "LastActivityDate": "2012-05-06T00:24:00.830", "Title": "Invalid template dependent member function template deduction - thinks I'm trying to use std::set", "AcceptedAnswerId": "10426708", "LastEditDate": "2012-05-03T06:55:53.673", "Id": "10426428", "Score": "6", "Body": "<p>I have a class template which inherits from a base class template.</p>\n<p>The base class template has a data member with a member function template which I want to call from within my super class.</p>\n<p>I know that in order to disambiguate the call to the member function template, I have to use the <code>template</code> keyword, and I have to explicitly refer to <code>this</code> in the super class.</p>\n<p><code>this-&gt;base_member_obj.template member_function&lt;int&gt;();</code></p>\n<p>All this is good and well, except that the codebase I'm using has made the rather unfortunate mistake of importing the entirety of <code>namespace std</code>, and the template member function I'm trying to call is called <code>set</code>. Somewhere in the framework <code>std::set</code> is included, and this causes GCC to think I'm trying to declare a <code>std::set</code> rather than call the member function <code>set</code>.</p>\n<p>GCC 4.7 throws an error <strong>invalid use of 'class std::set'</strong></p>\n<p><strong>See below for an example showing the error</strong>. If you comment out <code>using namespace std</code> the code compiles fine.</p>\n<p>Sadly it is not feasible for me to go through the entire codebase, remove every <code>using namespace std</code> call, and prefix every call to anything inside the std namespace with <code>std::</code></p>\n<p>Is there any other way around this?</p>\n<pre><code>#include &lt;set&gt;\nusing namespace std; // comment this out to compile fine\n\nstruct blah\n{\n    template&lt;typename T&gt;\n    void set()\n    { }\n};\n\ntemplate&lt;typename T&gt;\nstruct base\n{\n    blah b;\n};\n\ntemplate&lt;typename T&gt;\nstruct super : base&lt;super&lt;T&gt;&gt;\n{\n    void fun()\n    {\n        this-&gt;b.template set&lt;int&gt;(); // this line breaks\n    }\n};\n\nint main()\n{\n    super&lt;int&gt; s;\n    s.fun();\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates><stl>", "OwnerUserId": "955273", "AnswerCount": "3"}, "10426769": {"ParentId": "10426428", "CommentCount": "2", "Body": "<p>Try this:</p>\n<pre><code>this-&gt;b.blah::template set&lt;int&gt;(); // this line breaks\n</code></pre>\n", "OwnerUserId": "1350713", "PostTypeId": "2", "Id": "10426769", "Score": "5", "CreationDate": "2012-05-03T07:13:26.923", "LastActivityDate": "2012-05-03T07:13:26.923"}, "10426708": {"ParentId": "10426428", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><s>Well, that's rather embarrassing for us C++ pushers.</s></p>\n<p>This is a bug in G++, which also appears in Comeau Test Drive. It's not a flaw in the language itself. The problem stems from the left-to-right nature of parsing and way C++ grammar skirts ambiguity.</p>\n<p>It is legal to use a non-member, non-base class template in a nested name specifier to a typedef to a base class template. In such a context, a class template with no special relationship to the accessed class can appear after the <code>-&gt;</code>:</p>\n<pre><code>#include &lt;tuple&gt;\n\ntemplate&lt; typename t &gt;\nstruct get_holder\n    { typedef std::tuple&lt; t &gt; type; };\n\ntemplate&lt; typename ... ts &gt;\nstruct inherits\n    : get_holder&lt; ts &gt;::type ... {\n\n    inherits( ts ... v )\n        : get_holder&lt; ts &gt;::type( v ) ...\n        {}\n\n    template&lt; typename tn &gt;\n    void assign_one( inherits &amp;o )\n        { this-&gt;get_holder&lt; tn &gt;::type::operator= ( o ); } // &lt;- here!\n};\n\nint main() {\n    inherits&lt; int, char, long &gt; icl( 3, 'q', 2e8 );\n    icl.assign_one&lt; char &gt;( icl );\n}\n</code></pre>\n<p>Since C++ is parsed left-to-right, when the parser hits the <code>-&gt;</code>, it must resolve <code>get_holder</code> before proceeding. The Standard has a special clause \u00a73.4.5/1 [basic.lookup.classref] for this:</p>\n<blockquote>\n<p id=\"so_10426428_10426708_0\">In a class member access expression (5.2.5), <strong>if the . or -&gt; token is\n  immediately followed by an identifier followed by a &lt;,</strong> the identifier\n  must be looked up to determine whether the &lt; is the beginning of a\n  template argument list (14.2) or a less-than operator. The identifier\n  is first looked up in the class of the object expression. If the\n  identifier is not found, it is then looked up in the context of the\n  entire postfix-expression and shall name a class template. If the\n  lookup in the class of the object expression finds a template, the\n  name is also looked up in the context of the entire postfix-expression\n  and</p>\n<p id=\"so_10426428_10426708_1\">\u2014 if the name is not found, the name found in the class of the object\n  expression is used, otherwise</p>\n<p id=\"so_10426428_10426708_2\">\u2014 if the name is found in the context of the entire postfix-expression\n  and does not name a class template, the name found in the class of the\n  object expression is used, otherwise</p>\n<p id=\"so_10426428_10426708_3\">\u2014 <strong>if the name found is a class template, it shall refer to the same\n  entity as the one found in the class of the object expression,\n  otherwise the program is ill-formed.</strong></p>\n</blockquote>\n<p>Emphasis mine \u2014 it would appear that G++ is following this logic despite the <code>template</code> keyword appearing between the <code>.</code> and the identifier <code>set</code>. Furthermore, assuming it's going down this route, it should have flagged the ambiguity as an error instead of trying to choose the non-member.</p>\n<p>There does appear to be a flaw in the standard's wording of how to proceed when the <code>template</code> keyword <em>does</em> appear, but it shouldn't cause the mayhem you see. \u00a714.2 [temp.names]:</p>\n<blockquote>\n<p id=\"so_10426428_10426708_4\">When the name of a member template specialization appears after . or -&gt; in a postfix-expression, or after a nested-name-specifier in a qualified-id, and the postfix-expression or qualified-id explicitly depends on a template-parameter (14.6.2) but does not refer to a member of the current instantiation (14.6.2.1), the member template name must be prefixed by the keyword template. <strong>Otherwise the name is assumed to name a non-template.</strong></p>\n</blockquote>\n<p>Emphasis mine, that text is in error and should read \"the name is assumed not to name a member template,\" because as in my illustration above it could be part of a nested name specifier. If the text is taken literally as-is, then it could be interpreted to mean the <code>template</code> keyword <em>is</em> required in my illustration, hence could indicate a following non-member template (assuming the language supports such a construct at all), and then your program could be misinterpreted as seen by G++.</p>\n<p>But the design intent is clear, and you do not need to add an artificial nested name specifier <code>blah::</code>, although it is a legal workaround.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2012-05-06T00:24:00.830", "Id": "10426708", "Score": "3", "CreationDate": "2012-05-03T07:09:06.393", "LastActivityDate": "2012-05-06T00:24:00.830"}, "bq_ids": {"n4140": {"so_10426428_10426708_4": {"section_id": 72, "quality": 0.8055555555555556, "length": 29}, "so_10426428_10426708_0": {"section_id": 7126, "quality": 0.7058823529411765, "length": 36}, "so_10426428_10426708_2": {"section_id": 194, "quality": 0.5333333333333333, "length": 8}, "so_10426428_10426708_1": {"section_id": 126, "quality": 0.625, "length": 5}}, "n3337": {"so_10426428_10426708_4": {"section_id": 67, "quality": 0.8055555555555556, "length": 29}, "so_10426428_10426708_0": {"section_id": 6870, "quality": 0.7058823529411765, "length": 36}, "so_10426428_10426708_3": {"section_id": 188, "quality": 0.5714285714285714, "length": 8}, "so_10426428_10426708_2": {"section_id": 188, "quality": 0.5333333333333333, "length": 8}, "so_10426428_10426708_1": {"section_id": 120, "quality": 0.625, "length": 5}}, "n4659": {"so_10426428_10426708_0": {"section_id": 8627, "quality": 0.7058823529411765, "length": 36}, "so_10426428_10426708_1": {"section_id": 131, "quality": 0.625, "length": 5}}}});