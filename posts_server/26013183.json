post_cb({"26013641": {"ParentId": "26013183", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/language/as_if\"><strong>Compilers can't break the as-if rule</strong></a></p>\n<p>As \u00a71.9/1 states:</p>\n<blockquote>\n<p id=\"so_26013183_26013641_0\">The semantic descriptions in this International Standard define a\n  parameterized nondeterministic abstract machine. This International\n  Standard places no requirement on the structure of conforming\n  implementations. In particular, they need not copy or emulate the\n  structure of the abstract machine. Rather, conforming implementations\n  are required to emulate (only) the observable behavior of the abstract\n  machine as explained below</p>\n</blockquote>\n<p>i.e. a compiler can't change the observable behavior of the program. Automatically (even if with no repercussions) converting an assignment to a move assignment would break this statement.</p>\n<p>Copy elisions can slightly alter this behavior, but that is regulated by \u00a712.8/31.</p>\n<p>If you want to use the move version, you'll have to explicitly ask for it as in the latter example.</p>\n", "OwnerUserId": "1938163", "LastEditorUserId": "1938163", "LastEditDate": "2014-09-24T09:49:16.380", "Id": "26013641", "Score": "6", "CreationDate": "2014-09-24T09:42:59.887", "LastActivityDate": "2014-09-24T09:49:16.380"}, "26013542": {"ParentId": "26013183", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Let's look at the next sample (please ignore <code>void</code> return type from <code>operator=</code>):</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct helper\n{\n    void operator=(helper&amp;&amp;){std::cout&lt;&lt;\"move\"&lt;&lt;std::endl;}\n    void operator=(const helper&amp;){std::cout&lt;&lt;\"copy\"&lt;&lt;std::endl;}\n};\n\nvoid fun()\n{\n    helper a;\n    {\n        helper b;\n        a = b;\n    }\n}\n\nvoid gun()\n{\n    helper a;\n    {\n        helper b;\n        a = std::move(b);\n    }\n}\nint main()\n{\n    fun();\n    gun();\n}\n</code></pre>\n<p>The <code>operator=</code> has different behaviour depending on its arguments. The compiler is allowed to optimise the code only if it is able to maintain the observable behaviour the same. </p>\n<p>Considering <code>b</code> from <code>fun</code> an <code>xvalue</code>, while it isn't an <code>xvalue</code> at the moment of the call it will change the observable behaviour of the program and this is not desired nor allowed by the standard.</p>\n", "OwnerUserId": "336578", "LastEditorUserId": "336578", "LastEditDate": "2014-09-24T11:54:18.187", "Id": "26013542", "Score": "5", "CreationDate": "2014-09-24T09:38:27.393", "LastActivityDate": "2014-09-24T11:54:18.187"}, "bq_ids": {"n4140": {"so_26013183_26013641_0": {"section_id": 5797, "quality": 0.8918918918918919, "length": 33}}, "n3337": {"so_26013183_26013641_0": {"section_id": 5570, "quality": 0.8918918918918919, "length": 33}}, "n4659": {"so_26013183_26013641_0": {"section_id": 7256, "quality": 0.8918918918918919, "length": 33}}}, "26013183": {"CommentCount": "8", "AcceptedAnswerId": "26013641", "PostTypeId": "1", "LastEditorUserId": "1938163", "CreationDate": "2014-09-24T09:22:19.637", "LastActivityDate": "2015-07-17T08:45:13.103", "LastEditDate": "2015-07-17T08:45:13.103", "ViewCount": "372", "FavoriteCount": "5", "Title": "Automatic xvalue optimization", "Id": "26013183", "Score": "11", "Body": "<p>Somewhat surprisingly (to me), the following two programs compile to different outputs, with the latter one having much better performance (tested with gcc and clang):</p>\n<pre><code>#include &lt;vector&gt;\nint main()\n{\n    std::vector&lt;int&gt; a(2&lt;&lt;20);\n    for(std::size_t i = 0; i != 1000; ++i) {\n        std::vector&lt;int&gt; b(2&lt;&lt;20);\n        a = b;\n    }\n}\n</code></pre>\n<p>vs.</p>\n<pre><code>#include &lt;vector&gt;\nint main()\n{\n    std::vector&lt;int&gt; a(2&lt;&lt;20);\n    for(std::size_t i = 0; i != 1000; ++i) {\n        std::vector&lt;int&gt; b(2&lt;&lt;20);\n        a = std::move(b);\n    }\n}\n</code></pre>\n<p>Could someone explain to me why the compiler does (or can) not automatically consider <code>b</code> an xvalue in the last assignment and apply move semantics without the explicit <code>std::move</code> cast?</p>\n<p><strong>Edit</strong>: Compiled with <code>(g++|clang++) -std=c++11 -O3 -o test test.cpp</code></p>\n", "Tags": "<c++><c++11><move-semantics><xvalue>", "OwnerUserId": "2658206", "AnswerCount": "2"}});