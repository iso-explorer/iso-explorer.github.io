post_cb({"bq_ids": {"n4140": {"so_34168897_34168959_0": {"length": 23, "quality": 1.0, "section_id": 5811}, "so_34168897_34168982_0": {"length": 22, "quality": 1.0, "section_id": 5811}}, "n3337": {"so_34168897_34168959_0": {"length": 23, "quality": 1.0, "section_id": 5584}, "so_34168897_34168982_0": {"length": 22, "quality": 1.0, "section_id": 5584}}, "n4659": {"so_34168897_34168982_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 7272}}}, "34168959": {"Id": "34168959", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_34168897_34168959_0\">Every evaluation in the calling function (including other function calls) that is not otherwise specifically\n  sequenced before or after the execution of the body of the called function is indeterminately sequenced with\n  respect to the execution of the called function.</p>\n</blockquote>\n<p>([intro.execution]/15)</p>\n<p>Therefore, in an expression of the form <code>g_X + func()</code> or <code>func() + g_X</code>, it's true that the <code>+</code> operator doesn't introduce any sequencing constraint, but nevertheless the access to <code>g_X</code> within <code>main</code> either happens before or after the body of <code>func()</code>, you just can't predict which. This implies that the behaviour is defined, but whether <code>a</code> is 1 or 2 is unpredictable. Likewise, whether <code>b</code> is 1 or 2 is unpredictable.</p>\n", "LastActivityDate": "2015-12-09T00:56:37.287", "CommentCount": "0", "CreationDate": "2015-12-09T00:56:37.287", "ParentId": "34168897", "Score": "2", "OwnerUserId": "481267"}, "34168982": {"Id": "34168982", "PostTypeId": "2", "Body": "<p>At first sight this looks like an undefined behavior because, quoting \u00a71.9/15:</p>\n<blockquote>\n<p id=\"so_34168897_34168982_0\">If a side effect on a scalar\n  object is unsequenced relative to either another side effect on the same scalar object or a value computation\n  using the value of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n<p>and your example seemingly satisfies these conditions:</p>\n<ol>\n<li>Evaluation of operands of + operator are unsequenced relative to each other (but see below).</li>\n<li>There is a side effect on a scalar object (<code>func</code> increments <code>g_X</code>).</li>\n<li>There is a computation using the value of the same scalar object (<code>g_X</code>).</li>\n</ol>\n<p>On the other hand, as pointed out in the Brian's answer, function call does introduce sequencing, although indeterminate. According to this argument this is not an undefined behavior, but merely unspecified.</p>\n", "LastEditorUserId": "471164", "LastActivityDate": "2015-12-09T01:19:21.930", "Score": "2", "CreationDate": "2015-12-09T01:00:25.060", "ParentId": "34168897", "CommentCount": "0", "OwnerUserId": "471164", "LastEditDate": "2015-12-09T01:19:21.930"}, "34168897": {"ViewCount": "88", "Body": "<p>Take the following example:</p>\n<pre><code>int g_X;\nint func() {\n return ++g_X;  // using g_X++ is not an option\n}\nint main() {\n g_X = 0;\n int a = g_X + func();\n g_X = 0;\n int b = func() + g_X;\n g_X = 0; int temp = g_X;\n int c = temp + func();\n\n return 0;\n}\n</code></pre>\n<p>a and b are both 2, c has the expected value 1 (tested with Visual Studio 2010 to 2015). I read that sums are not associated with a sequence point (e.g. <a href=\"https://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow\">https://en.wikipedia.org/wiki/Sequence_point</a>) and therefore the order is not fixed. Yet I thought that the value of g_X gets captured before the function call.\nAm I really in undefined behavior territory or is there some way not having to use the temp var? </p>\n", "AcceptedAnswerId": "34168959", "Title": "c++ evaluation of ambigous sum expression", "CreationDate": "2015-12-09T00:49:58.793", "Id": "34168897", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-12-09T01:19:21.930", "Score": "3", "OwnerUserId": "5656904", "Tags": "<c++>", "AnswerCount": "2"}});