post_cb({"bq_ids": {"n4140": {"so_28976327_28976386_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5986}}, "n3337": {"so_28976327_28976386_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5754}}, "n4659": {"so_28976327_28976386_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7486}}}, "28976387": {"Id": "28976387", "PostTypeId": "2", "Body": "<p>The built-in <code>[]</code> operator is <em>defined</em> in terms of <code>+</code> and <code>*</code>.</p>\n<p>That is, <code>a[b]</code>, where <code>[]</code> is the built-in operator, is exactly equivalent to <code>*(a+b)</code>. This also allows you to write such gems as <code>2[array]</code> or <code>3[\"hello\"]</code> or <code>0[this]</code>.</p>\n<p>Obviously, for overloaded operators, there's no such equivalence.</p>\n", "LastActivityDate": "2015-03-11T00:11:19.350", "CommentCount": "0", "CreationDate": "2015-03-11T00:11:19.350", "ParentId": "28976327", "Score": "4", "OwnerUserId": "2756719"}, "28976327": {"ViewCount": "163", "Body": "<p>I frequently use code like the following to index items out of arrays just to remind myself that the array value is a pointer to the first element of the array.</p>\n<pre><code>int array[] = {0,1,2,3,4,5};\n*(array + 2) = 42;\n</code></pre>\n<p>While it looks a little ugly, from time to time I actually prefer it to the traditional <code>[]</code> operator.</p>\n<pre><code>int array[] = {0,1,2,3,4,5};\narray[2] = 42;\n</code></pre>\n<p>Other than making other people who may read my code in the future a little angry, are there any consequences to using pointer arithmetic to index an array over the <code>[]</code> operator?</p>\n", "AcceptedAnswerId": "28976386", "Title": "What is the difference between the C++ array operator and *(array + index) if any?", "CreationDate": "2015-03-11T00:05:55.753", "Id": "28976327", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2015-03-11T00:30:03.423", "Score": "1", "OwnerUserId": "4450336", "Tags": "<c++><arrays><c++11><indexing>", "AnswerCount": "3"}, "28976365": {"Id": "28976365", "PostTypeId": "2", "Body": "<p>For an array, there is no difference. It doesn't extend well to other containers, though, so refactoring code written with this equivalence in mind to use, for example, a <code>std::vector</code> will require much more effort.</p>\n", "LastActivityDate": "2015-03-11T00:09:18.150", "CommentCount": "0", "CreationDate": "2015-03-11T00:09:18.150", "ParentId": "28976327", "Score": "4", "OwnerUserId": "4562911"}, "28976386": {"Id": "28976386", "PostTypeId": "2", "Body": "<p>Section 5.2.1 [expr.sub] of the C++ spec says:</p>\n<blockquote>\n<p id=\"so_28976327_28976386_0\">... The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code></p>\n</blockquote>\n<p>So they are exactly the same, by definition.</p>\n<p>See <a href=\"http://www.open-std.org/jtc1/sc22/open/n2356/expr.html\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/open/n2356/expr.html</a> for an older version of the spec. The same wording appears in all of them.</p>\n<p>[Update]</p>\n<p>Note that \"the array value is a pointer to the first element of the array\" is not exactly true, as <code>sizeof(array)</code> (among other things) will demonstrate. The array <em>decays</em> to a pointer in many contexts, but that is not the same thing. So I would say your style choice here is simply confusing, to other people and even to yourself... Plus you are violating the very common and useful \"container access\" abstraction, as other commenters point out. That is, you are ruling out replacing the array with a <code>std::vector</code> or <code>std::deque</code> or really any other container. Just poor style, IMO.</p>\n", "LastEditorUserId": "768469", "LastActivityDate": "2015-03-11T00:30:03.423", "Score": "9", "CreationDate": "2015-03-11T00:11:03.977", "ParentId": "28976327", "CommentCount": "0", "OwnerUserId": "768469", "LastEditDate": "2015-03-11T00:30:03.423"}});