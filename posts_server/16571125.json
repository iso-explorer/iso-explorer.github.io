post_cb({"16571198": {"ParentId": "16571125", "CommentCount": "0", "CreationDate": "2013-05-15T17:16:10.187", "OwnerUserId": "1932150", "PostTypeId": "2", "Id": "16571198", "Score": "3", "Body": "<p>Concerning the first question:</p>\n<blockquote>\n<p id=\"so_16571125_16571198_0\">Can the noexcept modifier be applied to a lambda expression? If so, how?</p>\n</blockquote>\n<p>Yes, just add the exception specification after the parameter list:</p>\n<pre><code>[] (int i) noexcept { return i * 1; };\n//         ^^^^^^^^\n</code></pre>\n<p>Per paragraph 5.1.2/5 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16571125_16571198_1\">The closure type for a lambda-expression has a public inline function call operator (13.5.4) whose parameters\n  and return type are described by the lambda-expression\u2019s parameter-declaration-clause and trailingreturn-\n  type respectively. This function call operator is declared const (9.3.1) if and only if the lambda-expression\u2019s\n  parameter-declaration-clause is not followed by mutable. It is neither virtual nor declared\n  volatile. Default arguments (8.3.6) shall not be specified in the parameter-declaration-clause of a lambda-declarator.\n  <strong>Any exception-specification specified on a lambda-expression applies to the corresponding function\n  call operator</strong>. An attribute-specifier-seq in a lambda-declarator appertains to the type of the corresponding\n  function call operator. [ Note: Names referenced in the lambda-declarator are looked up in the context in\n  which the lambda-expression appears. \u2014end note ]</p>\n</blockquote>\n", "LastActivityDate": "2013-05-15T17:16:10.187"}, "16571125": {"CommentCount": "0", "AcceptedAnswerId": "16571207", "PostTypeId": "1", "LastEditorUserId": "1932150", "CreationDate": "2013-05-15T17:11:20.120", "LastActivityDate": "2013-05-15T17:34:55.673", "LastEditDate": "2013-05-15T17:34:55.673", "ViewCount": "2045", "FavoriteCount": "2", "Title": "Using noexcept as a lambda modifier or parameter constraint", "Id": "16571125", "Score": "13", "Body": "<p>Can the <code>noexcept</code> modifier be applied to a lambda expression? If so, how?</p>\n<p>Can <code>noexcept</code> be made a constraint on a function argument? For example, something like in the following code, where the meaning is that the callback function must be <code>noexcept</code>?</p>\n<pre><code>//probably not valid code - I'm just trying to express the idea\nvoid f_async(std::function&lt;void (int) noexcept&gt; callback) noexcept\n{\n    ...\n}\n</code></pre>\n<p>This can <em>almost</em> be accomplished with the following code, but I'm wondering if there is a way to use something like the above alternative.</p>\n<pre><code>void f_async(std::function&lt;void (int)&gt; callback)\n    noexcept(callback(std::declval&lt;int&gt;()))\n{\n    ...\n}\n</code></pre>\n<p>The problem here of course is that <code>f_async</code> can be <code>noexcept(false)</code> if the callback is <code>noexcept(false)</code> - I want to make a stronger statement that <code>f_async</code> is <em>always</em> <code>noexcept</code>, meaning it's only callable if you use a <code>noexcept</code> callback.</p>\n", "Tags": "<c++><c++11><lambda><noexcept>", "OwnerUserId": "1828879", "AnswerCount": "2"}, "16571207": {"ParentId": "16571125", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_16571125_16571207_0\">Can the <code>noexcept</code> modifier be applied to a lambda expression? If so, how?</p>\n</blockquote>\n<p>Add <code>noexcept</code> after the parenthesis:</p>\n<pre><code>[](Args args) noexcept { ... }\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_16571125_16571207_1\">Can <code>noexcept</code> be made a constraint on a function argument?</p>\n</blockquote>\n<p>Yes, use enable_if:</p>\n<pre><code>template &lt;typename F&gt;\nauto f_async(const F&amp; func) noexcept \n        -&gt; typename std::enable_if&lt;noexcept(func(0))&gt;::type {\n    func(0);\n}\n\nint main() {\n    f_async([](int x) noexcept {});\n    f_async([](int x) {}); // &lt;- this line won't compile\n}\n</code></pre>\n<p><strong>However</strong>, this method cannot work directly in g++ 4.7 (it does work in clang++ 3.2), because it cannot mangle <code>noexcept</code> expression yet:</p>\n<blockquote>\n<p id=\"so_16571125_16571207_2\">3.cpp:5:6: sorry, unimplemented: mangling noexcept_expr</p>\n</blockquote>\n<p>You could workaround it using a wrapper struct:</p>\n<pre><code>template &lt;typename F, typename... Args&gt;\nstruct EnableIfNoexcept \n        : std::enable_if&lt;noexcept(std::declval&lt;F&gt;()(std::declval&lt;Args&gt;()...))&gt; {};\n\ntemplate &lt;typename F&gt;\nauto f_async(const F&amp; func) noexcept -&gt; typename EnableIfNoexcept&lt;F, int&gt;::type {\n    func(0);\n}\n</code></pre>\n</hr>", "OwnerUserId": "224671", "LastEditorUserId": "224671", "LastEditDate": "2013-05-15T17:24:40.790", "Id": "16571207", "Score": "15", "CreationDate": "2013-05-15T17:16:33.637", "LastActivityDate": "2013-05-15T17:24:40.790"}, "bq_ids": {"n4140": {"so_16571125_16571198_1": {"section_id": 5964, "quality": 0.7681159420289855, "length": 53}}, "n3337": {"so_16571125_16571198_1": {"section_id": 5733, "quality": 0.8405797101449275, "length": 58}}, "n4659": {"so_16571125_16571198_1": {"section_id": 7454, "quality": 0.5362318840579711, "length": 37}}}});