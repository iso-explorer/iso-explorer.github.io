post_cb({"41732104": {"ParentId": "41732051", "LastEditDate": "2017-01-19T01:22:47.547", "CommentCount": "0", "CreationDate": "2017-01-19T01:03:07.540", "OwnerUserId": "3246555", "LastEditorUserId": "3246555", "PostTypeId": "2", "Id": "41732104", "Score": "2", "Body": "<blockquote>\n<p id=\"so_41732051_41732104_0\">Can I call a virtual function in the destructor of a base class?</p>\n</blockquote>\n<p>Calling virtual functions from destructors or constructors is a bad practice. See the standard (emphasis mine):</p>\n<blockquote>\n<p id=\"so_41732051_41732104_1\"><strong>12.7 Construction and destruction</strong><br>....<br>\n  Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2).\n  When a virtual function is called directly or indirectly from a constructor or from a destructor, including\n  during the construction or destruction of the class\u2019s non-static data members, and the object to which the\n  call applies is the object (call it <code>x</code>) under construction or destruction, <strong><em>the function called is the final overrider\n  in the constructor\u2019s or destructor\u2019s class and not one overriding it in a more-derived class. If the virtual\n  function call uses an explicit class member access (5.2.5) and the object expression refers to the complete\n  object of <code>x</code> or one of that object\u2019s base class subobjects but not <code>x</code> or one of its base class subobjects, the\n  behavior is undefined</em></strong>.</br></br></p>\n</blockquote>\n<p>You can find this recommendation in many sources, including Scott Meyers'<br>\n<strong>Effective C++: 55 Specific Ways to Improve Your Programs and Designs</strong>\n(<em>Item 9: Never call virtual functions during construction or destruction.)</em></br></p>\n<p>or Herb Sutter's<br>\n<strong>C++ Coding Standards: 101 Rules, Guidelines, and Best Practices</strong> (<em>49. Avoid calling virtual functions in constructors and destructors</em>).</br></p>\n", "LastActivityDate": "2017-01-19T01:22:47.547"}, "41735465": {"ParentId": "41732051", "CommentCount": "0", "Body": "<p>Yes, the object will have a pointer to its vtable when you call the destructor.</p>\n<p>The standard explicitly says it is possible to call virtual functions in the destructor, and says what happens.  There is agreement that even though it is allowed it is a bad practice, because it is inherently brittle code that leads to surprises with apparently innocent changes.</p>\n<p>If you have that <code>DerDer</code> inherits from <code>Der</code>, which inherits from <code>Base</code>, all of them override member function <code>void member()</code>, and you are in the destructor of <code>Der</code>, and call <code>member()</code>, you are calling <code>Der::member()</code>, not <code>DerDer::member()</code>, because the <code>DerDer</code> part of your object is GONE, DESTROYED already.  A base class can refer inadvertently to data in a derived class, for example:</p>\n<pre><code>struct Base {\n    int *ip;\n    Base(int *ip): ip(ip) {}\n    virtual void useInt() { std::cout &lt;&lt; *ip &lt;&lt; std::endl; }\n    ~Base() { useInt(); }\n};\nstruct Der: Base {\n    int theInt;\n    Der(): Base(&amp;theInt) {}\n    void useIntPointer() override { std::cout &lt;&lt; theInt &lt;&lt; std::endl; }\n};\n</code></pre>\n<p>When an object of type <code>Der</code> gets deleted, there is \"undefined behavior\":  First the implicit destructor of <code>Der</code> is called, then the explicit destructor of <code>Base</code>, <code>Base::~Base</code>.  At that point <code>Base::ip</code> is referring to a member of <code>Der</code> that has already been destroyed.</p>\n", "OwnerUserId": "4988044", "PostTypeId": "2", "Id": "41735465", "Score": "2", "CreationDate": "2017-01-19T06:48:49.370", "LastActivityDate": "2017-01-19T06:48:49.370"}, "bq_ids": {"n4140": {"so_41732051_41732104_0": {"section_id": 447, "quality": 0.8571428571428571, "length": 6}, "so_41732051_41732104_1": {"section_id": 447, "quality": 0.922077922077922, "length": 71}}, "n3337": {"so_41732051_41732104_0": {"section_id": 438, "quality": 0.8571428571428571, "length": 6}, "so_41732051_41732104_1": {"section_id": 438, "quality": 0.922077922077922, "length": 71}}, "n4659": {"so_41732051_41732104_1": {"section_id": 469, "quality": 0.922077922077922, "length": 71}, "so_41732051_41732104_0": {"section_id": 469, "quality": 0.8571428571428571, "length": 6}}}, "41732051": {"CommentCount": "3", "ViewCount": "99", "PostTypeId": "1", "ClosedDate": "2017-02-15T07:05:08.527", "LastEditorUserId": "3401653", "LastActivityDate": "2017-02-21T22:52:22.780", "Body": "<p>Is calling <strong>a virtual function in the destructor of a base class</strong> is a good practice? And \"<em>Does vtable exist in destruction time? And is calling a virtual function in the destructor recommended?</em>\"</p>\n", "LastEditDate": "2017-02-21T22:52:22.780", "FavoriteCount": "0", "Title": "When is a vtable destroy in C++?", "Id": "41732051", "Score": "-4", "CreationDate": "2017-01-19T00:57:42.130", "Tags": "<c++><inheritance>", "OwnerUserId": "3401653", "AnswerCount": "2"}});