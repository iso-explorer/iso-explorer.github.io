post_cb({"bq_ids": {"n4140": {"so_21290875_21291173_0": {"length": 41, "quality": 0.9111111111111111, "section_id": 7107}}, "n3337": {"so_21290875_21291173_0": {"length": 41, "quality": 0.9111111111111111, "section_id": 6851}}, "n4659": {"so_21290875_21291173_0": {"length": 41, "quality": 0.9111111111111111, "section_id": 8608}}}, "21291104": {"Id": "21291104", "PostTypeId": "2", "Body": "<p>The comments pretty much said it all: if you know the type of the vector, you can use <code>sizeof(std::vector&lt;uint&gt;::value_type)</code>. Otherwise use <code>sizeof(decltype(vecs)::value_type)</code>.</p>\n<p><code>decltype</code> is a magical C++11 construct that evaluates to the type of its argument, so the code</p>\n<pre><code>int i;\nfloat f;\n\ndecltype(i) j;\ndecltype(f) g;\n</code></pre>\n<p>Is the same as </p>\n<pre><code>int i;\nfloat f;\n\nint j;\nfloat g;\n</code></pre>\n<p>Only use the <code>.</code> operator for fields and methods (technically it can be used for static variable as well, but it's considered bad practice). For anything else, such as static variables, inner classes, or class-scope template parameters or typedefs (such as <code>value_type</code>), use the scope-resolution operator <code>::</code>.</p>\n", "LastEditorUserId": "1530508", "LastActivityDate": "2014-01-26T02:36:03.230", "Score": "4", "CreationDate": "2014-01-22T18:32:57.377", "ParentId": "21290875", "CommentCount": "0", "LastEditDate": "2014-01-26T02:36:03.230", "OwnerUserId": "1530508"}, "21290875": {"ViewCount": "3829", "Body": "<p>I want to get <code>sizeof</code> of the type that is contained in a vector. Here is what I tried:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main()\n{\n    std::vector&lt;uint&gt; vecs;\n    std::cout &lt;&lt; sizeof(vecs.value_type) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>From my understanding this should be correct. However, when compiling with GCC 4.8.1 this is what I get:</p>\n<pre>test-sizeof.cpp: In function \u2018int main()\u2019:\ntest-sizeof.cpp:7:27: error: invalid use of \u2018std::vector&lt;unsigned int&gt;::value_type\u2019\n  std::cout &lt;&lt; sizeof(vecs.value_type) &lt;&lt; std::endl;\n                           ^</pre>\n<p>What am I doing wrong? How can I get the size of the contained type?</p>\n", "AcceptedAnswerId": "21291173", "Title": "How can I get sizeof a vector::value_type?", "CreationDate": "2014-01-22T18:21:53.020", "Id": "21290875", "CommentCount": "5", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2014-01-26T02:36:03.230", "Score": "14", "OwnerUserId": "447490", "Tags": "<c++><c++11><vector><sizeof><value-type>", "AnswerCount": "3"}, "21291173": {"Id": "21291173", "PostTypeId": "2", "Body": "<p><strong>3.4.3 Quali\ufb01ed name lookup [basic.lookup.qual]</strong></p>\n<blockquote>\n<p id=\"so_21290875_21291173_0\">1 The name of a class or namespace member or enumerator can be\n  referred to after the :: scope resolution operator (5.1) applied to a\n  nested-name-speci\ufb01er that denotes its class, namespace, or\n  enumeration. If a :: scope resolution operator in a\n  nested-name-speci\ufb01er is not preceded by a decltype-speci\ufb01er, lookup of\n  the name preceding that :: considers only namespaces, types, <strong>and\n  templates whose specializations are types</strong>. If the name found does not\n  designate a namespace or a class, enumeration, or dependent type, the\n  program is ill-formed.</p>\n</blockquote>\n<p>In this case, you are accessing a <code>type</code> member from the class template specialization <code>std::vector&lt;uint&gt;</code>, and you need to do it by writing:</p>\n<pre><code>std::vector&lt;uint&gt;::value_type\n</code></pre>\n<p>In case you are actually inside templated code and want to e.g. access the same nested type, you need to prefix it with the keyword <code>typename</code> like this: </p>\n<pre><code>typename std::vector&lt;T&gt;::value_type\n</code></pre>\n<p>In C++11, you can use <code>sizeof(decltype(vecs)::value_type)</code> or also <code>sizeof(decltype(vecs.back()))</code>, the latter is convenient if you don't know the precise name of the type but know how to access them through a member function like <code>back()</code>.</p>\n<p><strong>Note</strong>: as pointed out by @Casey in the comments, <code>decltype</code> requires stripping references in order to get the type itself, but for sizeof purposes that doesn't matter.</p>\n", "LastEditorUserId": "1135979", "LastActivityDate": "2014-01-22T20:01:51.017", "Score": "9", "CreationDate": "2014-01-22T18:37:26.870", "ParentId": "21290875", "CommentCount": "5", "LastEditDate": "2014-01-22T20:01:51.017", "OwnerUserId": "819272"}, "21291129": {"Id": "21291129", "PostTypeId": "2", "Body": "<p>The member access operator <code>.</code> can only be used to access data members and member functions of classes, not other nested names such as type names. You'll need the scope resolution operator <code>::</code> to access them, and that can only be applied to the class name (or an alias), not an object of class type:</p>\n<pre><code>std::vector&lt;uint&gt;::value_type\n</code></pre>\n<p>In C++11 or later, <code>decltype</code> can give you a type name, if you have an object and no convenient access to the type:</p>\n<pre><code>decltype(vecs)::value_type\n</code></pre>\n", "LastEditorUserId": "204847", "LastActivityDate": "2014-01-22T19:00:59.753", "Score": "8", "CreationDate": "2014-01-22T18:34:40.123", "ParentId": "21290875", "CommentCount": "2", "LastEditDate": "2014-01-22T19:00:59.753", "OwnerUserId": "204847"}});