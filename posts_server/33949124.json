post_cb({"33949180": {"ParentId": "33949124", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2015-11-27T01:37:38.377", "Score": "5", "LastEditorUserId": "1708801", "LastEditDate": "2015-11-27T16:13:15.140", "Id": "33949180", "OwnerUserId": "1708801", "Body": "<p>In the case of <code>ffc(0)</code> T will be deduced as <em>int</em>  since <code>0</code> is a integer literal whose type is <em>int</em> and there is no valid implicit conversion from int to <em>wchar_t *</em> even without the forwarding, so the following case won't work either:</p>\n<pre><code>template&lt;typename T&gt;\nvoid ffc_no_forward(T&amp;&amp; a)\n{\n    ff(a);\n}\n</code></pre>\n<p>whereas in the first case <code>0</code> is a null pointer constant and therefore is perfectly valid conversion to <em>wchar_t *</em>.</p>\n<p>We can see from the draft C++14 standard(<code>N4140</code>) section <code>4.10</code> Pointer conversions [conv.ptr] that an <em>int</em> with zero value is not sufficient it must be an integer literal or must be a prvalue of <em>std::nullptr_t</em>:</p>\n<blockquote>\n<p id=\"so_33949124_33949180_0\">A null pointer constant is an integer literal (2.14.2) with value zero or a prvalue of type std::nullptr_t.\n  A null pointer constant can be converted to a pointer type; the result is the null pointer value of that type\n  and is distinguishable from every other value of object pointer or function pointer type. Such a conversion\n  is called a null pointer conversion.[...]</p>\n</blockquote>\n<p>In C++11 the wording allowed an <em>integral constant expression</em> that evaluated to zero but in this case actually does not matter since as T.C. points out <code>std::forward&lt;T&gt;()</code> could not be a constant expression since the parameter to a function can not be a constant expression either.</p>\n", "LastActivityDate": "2015-11-27T16:13:15.140"}, "bq_ids": {"n4140": {"so_33949124_33949180_0": {"section_id": 39, "quality": 0.9210526315789473, "length": 35}}, "n3337": {"so_33949124_33949180_0": {"section_id": 36, "quality": 0.868421052631579, "length": 33}}, "n4659": {"so_33949124_33949180_0": {"section_id": 39, "quality": 0.9210526315789473, "length": 35}}}, "33949124": {"CommentCount": "1", "ViewCount": "72", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-11-27T01:24:06.717", "LastActivityDate": "2015-11-27T16:13:15.140", "Title": "Why are implicit conversion not allowed in prefect forwarding?", "FavoriteCount": "0", "LastEditDate": "2015-11-27T04:16:19.017", "Id": "33949124", "Score": "4", "Body": "<p>Suppose we have the following code:</p>\n<pre><code>void ff(wchar_t*)\n{\n\n}\n\ntemplate&lt;typename T&gt;\nvoid ffc(T&amp;&amp; a)\n{\n    ff(std::forward&lt;T&gt;(a));\n}\n</code></pre>\n<p>Why is the call <code>ff(0)</code> allowed, but <code>ffc(0)</code> is not? </p>\n", "Tags": "<c++><type-conversion><implicit>", "OwnerUserId": "5590369", "AnswerCount": "1"}});