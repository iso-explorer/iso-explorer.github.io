post_cb({"29542086": {"ParentId": "29541875", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This has to do with two-phase lookup. The short version is that any names that do <em>not</em> depend on the template parameter (like <code>someBoolean</code> here) will be looked up at template definition time. That means that the Solaris compiler is correct in rejecting the code. <code>someBoolean</code> has not been defined before the template is defined.</p>\n<p>Names that do depend on the template parameter (e.g. if you had written something like <code>T::someBoolean = true</code>) will be deferred to template instantiation time - very reasonably, since their validity can't be determined until the compiler knows what <code>T</code> is. MSVC is known for not implementing these two-phase semantics properly (at least historically), which is why your code works there. It is not correct C++ and not portable behaviour, though.</p>\n<p>Section 14.6 of (unknown version of) the C++ standard (probably draft):</p>\n<blockquote>\n<p id=\"so_29541875_29542086_0\">If a name does not depend on a template-parameter (as de\ufb01ned in 14.6.2), a declaration (or set of declarations) for that name shall be in scope at the point where the name appears in the template de\ufb01nition; the name is bound to the declaration (or declarations) found at that point and this binding is not a\ufb00ected by declarations that are visible at the point of instantiation.</p>\n</blockquote>\n<p>(via @BenVoigt comment below)</p>\n", "OwnerUserId": "30579", "LastEditorUserId": "1774667", "LastEditDate": "2015-04-09T15:08:06.100", "Id": "29542086", "Score": "24", "CreationDate": "2015-04-09T15:00:59.340", "LastActivityDate": "2015-04-09T15:08:06.100"}, "29541875": {"CommentCount": "5", "CreationDate": "2015-04-09T14:51:21.517", "PostTypeId": "1", "AcceptedAnswerId": "29542086", "LastEditorUserId": "14089", "LastActivityDate": "2015-04-09T15:08:06.100", "LastEditDate": "2015-04-09T15:02:40.957", "ViewCount": "544", "FavoriteCount": "2", "Title": "Is using an undeclared variable legal in a template function?", "Id": "29541875", "Score": "23", "Body": "<p><em>Note: The original problem heavily uses macros, but it has been simplified for this question.</em></p>\n<h2>The question</h2>\n<pre><code>// header.hpp\ntemplate &lt;typename T&gt;\nvoid foo()\n{\n   someBoolean = true ; // at this point \"someBoolean\" wasn't\n}                       // declared\n</code></pre>\n<p>Then, it is used in the following source:</p>\n<pre><code>// source.cpp\n#include \"header.hpp\"\n\nstatic bool someBoolean = false ;\n\nvoid bar()\n{\n   foo&lt;char&gt;() ; // here, we call/instantiate the function\n}\n</code></pre>\n<p>In some compilers (Windows, previous Solaris) it works. And in the current C++11 enabled Solaris compiler, it fails, saying someBoolean is undefined.</p>\n<p><strong>According to the standard, can a templated code use a variable that will be (we hope!) declared later in the source?</strong></p>\n<h2>The bonus question</h2>\n<p>The template is defined in a header that is expected to be included in multiple sources, each one having its own boolean variable, and instantiating the template.</p>\n<p>It was expected, in each translation unit, the template would affect the static boolean variable of that translation unit.</p>\n<p>Each instantiation of the template on one type (say \"char\") is thus expected to affect different variables.</p>\n<p><strong>Aren't we relying on undefined behavior, there?</strong></p>\n", "Tags": "<c++><templates>", "OwnerUserId": "14089", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29541875_29542086_0": {"section_id": 177, "quality": 0.8620689655172413, "length": 25}}, "n3337": {"so_29541875_29542086_0": {"section_id": 171, "quality": 0.8620689655172413, "length": 25}}, "n4659": {"so_29541875_29542086_0": {"section_id": 182, "quality": 0.8620689655172413, "length": 25}}}});