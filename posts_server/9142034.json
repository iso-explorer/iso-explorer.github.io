post_cb({"9142530": {"Id": "9142530", "PostTypeId": "2", "Body": "<p>It is legal according to $5.2.9/12:</p>\n<blockquote>\n<p id=\"so_9142034_9142530_0\">A prvalue of type \u201cpointer to member of D of type cv1 T\u201d can be\n  converted to a prvalue of type \u201cpointer to member of B\u201d of type cv2 T,\n  where B is a base class (Clause 10) of D, if a valid standard\n  conversion from \u201cpointer to member of B of type T\u201d to \u201cpointer to\n  member of D of type T\u201d exists (4.11), and cv2 is the same\n  cv-quali\ufb01cation as, or greater cv-quali\ufb01cation than, cv1. 69 The null\n  member pointer value (4.11) is converted to the null member pointer\n  value of the destination type. If class B contains the original\n  member, or is a base or derived class of the class containing the\n  original member, the resulting pointer to member points to the\n  original member. Otherwise, the result of the cast is unde\ufb01ned. [Note:\n  although class B need not contain the original member, the dynamic\n  type of the object on which the pointer to member is dereferenced must\n  contain the original member; see 5.5. \u2014end note ]</p>\n</blockquote>\n<p>However if you try to do this with multiple inheritance or virtual inheritance, that's when things start to break, because not all compilers implement member function pointers in a standard compliant way. On MSVC and Intel compilers all member function pointers do not have the same size, so you will lose crucial information on conversions.</p>\n", "LastActivityDate": "2012-02-04T16:47:33.200", "Score": "1", "CreationDate": "2012-02-04T16:47:33.200", "ParentId": "9142034", "CommentCount": "0", "OwnerUserId": "458825"}, "9142425": {"Id": "9142425", "PostTypeId": "2", "Body": "<p>Here's the simpler version of your example:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Arg\n{\n    int i;\n};\n\nclass A;\ntypedef void (A::*fncptr)(Arg&amp;);\n</code></pre>\n<p><code>fncptr</code> is pointer to member function (method) of class <code>A</code> that takes <code>Arg</code> by reference. If someone gives you address of non-static function of this type, you will be able to call it only if you have an object of class <code>A</code> (otherwise it would have to be static function).</p>\n<pre><code>class A\n{\npublic:\n    A(Arg a) : a(a) { }\n    void process(fncptr f){ (this-&gt;*f)(a); }\n\nprotected:\n    Arg a;\n};\n\nclass B : public A\n{\npublic:\n    B(Arg a) : A(a) { } \n    void magic(){ process((fncptr)&amp;B::function); }\n    void function(Arg&amp; a) { cout &lt;&lt; a.i; }\n};\n</code></pre>\n<p>Here's the trick: since you are in function <code>process</code> which is member function of class <code>A</code>, you don't need pointer to an object of class <code>A</code> to call function <code>f</code> because you already have one: <code>this</code>. So you are able to call any function of this class or derived classes and you need only address of that function to do so.</p>\n<p>Here's <code>main()</code>:</p>\n<pre><code>int main()\n{\n    Arg a;\n    a.i = 71;\n\n    B* b = new B(a);\n    b-&gt;magic();\n    delete b;\n}\n</code></pre>\n<p>output: <code>71</code></p>\n", "LastEditorUserId": "1168156", "LastActivityDate": "2012-02-04T16:39:42.580", "Score": "1", "CreationDate": "2012-02-04T16:33:20.780", "ParentId": "9142034", "CommentCount": "0", "LastEditDate": "2012-02-04T16:39:42.580", "OwnerUserId": "1168156"}, "9142034": {"ViewCount": "282", "Body": "<p>What i'm trying to do is somewhat obscure, so let me show on an example (this is not the actual code):</p>\n<pre><code>template &lt;class T&gt;\nclass ArrayStorage {\nprotected:\n    void processStuff(void (ArrayStorage&lt;T&gt;::*procedure)(T *)) {\n        for (int i = 0; i &lt; count; i++)\n            (this-&gt;*procedure)(content[i]);\n    }\n    // No method of type void (ArrayStorage&lt;T&gt;::*)(T *)\n\nprivate:\n    T **content;\n    int count;\n};\n\nclass DrawableStorage : public ArrayStorage&lt;Drawable&gt; {\npublic:\n    void drawStuff() {\n        processStuff((void (ArrayStorage&lt;Drawable&gt;::*)(Drawable *)) &amp;DrawableStorage::drawOne);\n    }\n\nprivate:\n    void drawOne(Drawable *item) {\n        item-&gt;draw();\n    }\n};\n</code></pre>\n<p>Basically, there is a generic container that is able to iterate through its items and use a method on each of them (whose pointer is in the parameter). This method however does not exist in this class, but only in its subclasses. You can see that in the subclass \"drawStuff\" method, i supply a method pointer of the sublass, but typecasted as a method of the base class.</p>\n<p>Suprisingly enough, this has successfully compiled and works just fine.</p>\n<p>My question is, is it just a coincidence that my particular compiler was able to handle it while in fact it is completely invalid and i should get rid of it, or is it correct usage of method pointers?</p>\n<p>Thank you.</p>\n", "AcceptedAnswerId": "9142530", "Title": "Typecasting method pointer to parent class method", "CreationDate": "2012-02-04T15:41:27.383", "Id": "9142034", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-02-04T16:47:33.200", "Score": "3", "OwnerUserId": "1189488", "Tags": "<c++>", "AnswerCount": "4"}, "9142341": {"Id": "9142341", "PostTypeId": "2", "Body": "<p>The base class doesn't <em>have</em> the requested member function, so there's no way around that. However, you can make the base function a <em>template</em> instead:</p>\n<pre><code>template &lt;typename S&gt;\nvoid processStuff(S * s, void (S::*procedure)(T *))\n{\n    for (int i = 0; i &lt; count; i++) { (s-&gt;*procedure)(content[i]); }\n}\n</code></pre>\n<p>Invoke it as follows:</p>\n<pre><code>processStuff(this, &amp;DrawableStorage::drawOne);\n</code></pre>\n", "LastActivityDate": "2012-02-04T16:22:55.663", "Score": "0", "CreationDate": "2012-02-04T16:22:55.663", "ParentId": "9142034", "CommentCount": "2", "OwnerUserId": "596781"}, "bq_ids": {"n4140": {"so_9142034_9142530_0": {"length": 77, "quality": 0.8651685393258427, "section_id": 6038}}, "n3337": {"so_9142034_9142530_0": {"length": 80, "quality": 0.898876404494382, "section_id": 5806}}, "n4659": {"so_9142034_9142530_0": {"length": 71, "quality": 0.797752808988764, "section_id": 7537}}}, "9142143": {"Id": "9142143", "PostTypeId": "2", "Body": "<p>This is one of the tricks possible with pointers.  It works because DrawableStorage is an ArrayStorage, and the function header matches what is expected (takes a pointer to a type matching the objects templated type and returns void).</p>\n<p>Once the parent object has the pointer to the function, it can call it just fine even though it doesn't actually have that function as a member of itself.</p>\n<p>While it may be a little confusing at first to read, it is a perfectly valid use of function pointers.</p>\n", "LastActivityDate": "2012-02-04T15:56:57.260", "Score": "3", "CreationDate": "2012-02-04T15:56:57.260", "ParentId": "9142034", "CommentCount": "0", "OwnerUserId": "658018"}});