post_cb({"26534680": {"Id": "26534680", "PostTypeId": "2", "Body": "<blockquote>\n<h3>5.10 Equality operators <code>[expr.eq]</code></h3>\n<p id=\"so_26533740_26534680_0\">1 The <code>==</code> (equal to) and the <code>!=</code> (not equal to) operators group left-to-right. The operands shall have arithmetic, enumeration, pointer, or pointer to member type, or type <code>std::nullptr_t</code>. The operators <code>==</code> and <code>!=</code> both yield <code>true</code> or <code>false</code>, i.e., a result of type <code>bool</code>. In each case below, the operands <strong>shall have the same type after the specified conversions have been applied</strong>.<br>\n  2 <strong>If at least one of the operands is a pointer, pointer conversions (4.10) and qualification conversions (4.4) are performed on both operands to bring them to their composite pointer type</strong> (Clause 5). Comparing pointers is defined as follows: <strong>Two pointers compare equal if they are both null, both point to the same function, or both represent the same address (3.9.2), otherwise they compare unequal.</strong></br></p>\n</blockquote>\n<p>Let's take the last bit-for-bit:</p>\n<ol>\n<li>Two null pointers compare equal.<br>\nGood for your sanity.</br></li>\n<li>Two pointers to the same function compare equal.<br>\nAnything else would be extremely surprising.<br>\nIt also means that only one out-of-line version of any <code>inline</code>-function may ever have its address taken, unless you want to make function-pointer comparisons prohibitively complicated and expensive.</br></br></li>\n<li>Both represent the same address.<br>\nNow that one is what it's all about. Dropping this and reducing <code>if and only if</code> to a simple <code>if</code> would leave it to interpretation, but that's <strong>a clear mandate to make any two functions identical</strong>, as long as it does not otherwise change observable behavior of a conformant program.</br></li>\n</ol>\n", "LastEditorUserId": "3204551", "LastActivityDate": "2015-01-02T13:43:49.573", "Score": "2", "CreationDate": "2014-10-23T18:18:25.430", "ParentId": "26533740", "CommentCount": "0", "OwnerUserId": "3204551", "LastEditDate": "2015-01-02T13:43:49.573"}, "26533963": {"Id": "26533963", "PostTypeId": "2", "Body": "<p>Yes.  From the standard (\u00a75.10/1): \"Two pointers of the same\ntype compare equal if and only if they are both null, both point\nto the same function, or both represent the same address\"</p>\n<p>Once they have been instantiated, <code>foo&lt;int&gt;</code> and <code>foo&lt;double&gt;</code> are two different functions, so the above applies to them as well.</p>\n", "LastActivityDate": "2014-10-23T17:34:22.143", "CommentCount": "21", "CreationDate": "2014-10-23T17:34:22.143", "ParentId": "26533740", "Score": "10", "OwnerUserId": "649665"}, "bq_ids": {"n4140": {"so_26533740_26535126_2": {"length": 37, "quality": 0.9487179487179487, "section_id": 5795}, "so_26533740_26535126_5": {"length": 19, "quality": 0.95, "section_id": 6155}, "so_26533740_26535126_4": {"length": 8, "quality": 1.0, "section_id": 5790}, "so_26533740_26535126_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 5795}}, "n3337": {"so_26533740_26535126_2": {"length": 37, "quality": 0.9487179487179487, "section_id": 5568}, "so_26533740_26535126_5": {"length": 15, "quality": 0.75, "section_id": 5917}, "so_26533740_26535126_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 5568}, "so_26533740_26535126_4": {"length": 8, "quality": 1.0, "section_id": 5563}}, "n4659": {"so_26533740_26535126_2": {"length": 36, "quality": 0.9230769230769231, "section_id": 7254}, "so_26533740_26535126_5": {"length": 14, "quality": 0.7, "section_id": 7652}, "so_26533740_26535126_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 7254}, "so_26533740_26535126_4": {"length": 8, "quality": 1.0, "section_id": 7247}}}, "26535126": {"Id": "26535126", "PostTypeId": "2", "Body": "<p>It looks like <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3715.html#1400\">defect report 1400: Function pointer equality</a> deals with this issue and seems to me to say that it is okay to do this optimization but as comments indicate, there is disagreement. It says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_26533740_26535126_0\">According to 5.10 [expr.eq] paragraph 2, <strong>two function pointers only\n  compare equal if they point to the same function</strong>. However, as an\n  optimization, <strong>implementations are currently aliasing functions</strong> that\n  have identical definitions. It is not clear whether the Standard needs\n  to deal explicitly with this optimization or not.</p>\n</blockquote>\n<p>and the response was:</p>\n<blockquote>\n<p id=\"so_26533740_26535126_1\">The Standard is clear on the requirements, and <strong>implementations are\n  free to optimize within the constraints of the \u201cas-if\u201d rule</strong>.</p>\n</blockquote>\n<p>The question is asking about two issues:</p>\n<ul>\n<li>Is it okay for these pointers to be considered equal</li>\n<li>Is it okay to coalesce the functions</li>\n</ul>\n<p>Based on comments I see two interpretations of the response:</p>\n<ol>\n<li><p>This optimization is ok, the standard gives the implementation this freedom under the <em>as-if rule</em>. The <em>as-if rule</em> is covered in section <code>1.9</code> and means the implementation only has to emulate the observable behavior with respect to the requirements of the standard. <s>This is still my interpretation of the response.</s></p></li>\n<li><p>The issue is at hand is completely ignored and the statement merely says no adjustment to the standard is required because clearly the <em>as-if rules</em> covers this but the interpretation is left as an exercise to the reader. Although I acknowledge due to the terseness of the response I can not dismiss this view, it ends up being a totally unhelpful response. It also seems inconsistent with the responses in the other <code>NAD</code> issues which as far as I can tell point out issue if they exist.</p></li>\n</ol>\n<p><b>What the draft standard says</b></p>\n<p>Since we know we are dealing with the <em>as-if rule</em>, we can start there and note that section <code>1.8</code> says:</p>\n<blockquote>\n<p id=\"so_26533740_26535126_2\">Unless an object is a bit-field or a base class subobject of zero\n  size, the address of that object is the address of the first byte it\n  occupies. Two objects that are not bit-fields may have the same\n  address if one is a subobject of the other, or if at least one is a\n  base class subobject of zero size and they are of different types;\n  otherwise, they shall have distinct addresses.<sup>4</sup></p>\n</blockquote>\n<p>and note <code>4</code> says:</p>\n<blockquote>\n<p id=\"so_26533740_26535126_3\">Under the \u201cas-if\u201d rule an implementation is allowed to store two\n  objects at the same machine address or not store an object at all if\n  the program cannot observe the difference</p>\n</blockquote>\n<p>but a note from that section says:</p>\n<blockquote>\n<p id=\"so_26533740_26535126_4\">A function is not an object, regardless of whether or not it occupies\n  storage in the way that objects do</p>\n</blockquote>\n<p>although it is not normative, the requirements for an object laid out in paragraph <code>1</code> do not make sense in the context of a function and so it is consistent with this note. So we are explicitly restricted from aliasing objects with some exceptions but not such restriction applies to functions.</p>\n<p>Next we have section <code>5.10</code> <em>Equality operators</em> which says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_26533740_26535126_5\">[...]Two pointers compare equal if they are both null, <strong>both point to\n  the same function, or both represent the same address</strong> (3.9.2),\n  otherwise they compare unequal.</p>\n</blockquote>\n<p>which tells us two pointers are equal if they are:</p>\n<ul>\n<li>Null pointers</li>\n<li>Point to the same function</li>\n<li>Represent the same address</li>\n</ul>\n<p>The <em>or both represent the same address</em> seems to give enough latitude to allow a compiler to alias two different functions and does not require pointers to different functions to compare unequal. </p>\n<p><b>Observations</b></p>\n<p>Keith Thompson has made some great observations that I feel are worth adding to the answer since they get to core issues involved, he says:</p>\n<blockquote>\n<p id=\"so_26533740_26535126_6\">If a program prints the result of <strong>&amp;foo == &amp;bar</strong>, that's observable behavior; the optimization in question changes the observable behavior. </p>\n</blockquote>\n<p>which I agree with and if we could shows that there is a requirement for the pointers to be unequal that would indeed violate the <em>as-if rule</em> but so far we can not show that.</p>\n<p>and:</p>\n<blockquote>\n<p id=\"so_26533740_26535126_7\">[...]consider a program that defines empty function and uses their\n  addresses as unique values (think about <strong>SIG_DFL</strong>, <strong>SIG_ERR</strong>, and <strong>SIG_IGN</strong>\n  in <strong>&lt;signal.h&gt;</strong> / <strong>&lt;csignal&gt;</strong>). Assigning them the same address would\n  break such a program</p>\n</blockquote>\n<p>As I noted in my comment the C standard requires these macros to generate <em>distinct values</em>, from <code>7.14</code> in C11:</p>\n<blockquote>\n<p id=\"so_26533740_26535126_8\">[...]which expand to constant expressions with distinct values that\n  have type compatible with the second argument to, and the return value\n  of, the signal function, and whose values compare unequal to the\n  address of any declarable function[...]</p>\n</blockquote>\n<p>So although this case is covered perhaps there are other cases that would make this optimization dangerous.</p>\n<p><b>Update</b></p>\n<p>Jan Hubi\u010dka a <code>gcc</code> developer wrote a blog post <a href=\"http://hubicka.blogspot.com/2015/04/GCC5-IPA-LTO-news.html\">Link time and inter-procedural optimization improvements in GCC 5</a>, code folding was one of many topics he covered.</p>\n<p>I asked him to comment on whether folding identical functions to the same address was conforming behavior or not and he says it is not conforming behavior and indeed such an optimization would break <code>gcc</code> itself:</p>\n<blockquote>\n<p id=\"so_26533740_26535126_9\">It is not conforming to turn two functions to have same address, so MSVC is quite aggressive here. Doing so, for example, breaks GCC itself because to my surprise address compare is done in the precompiled headers code. It works for many other projects, including Firefox.</p>\n</blockquote>\n<p>In hindsight, after months more of reading defect reports and thinking about optimization issues, I am biased towards a more conservative reading of the committee's response. Taking the address of a function is observable behavior and therefore folding identical functions would violate the <em>as-if rule</em>. </p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-04-14T20:34:11.320", "Score": "27", "CreationDate": "2014-10-23T18:44:39.863", "ParentId": "26533740", "CommentCount": "19", "OwnerUserId": "1708801", "LastEditDate": "2015-04-14T20:34:11.320"}, "26533740": {"ViewCount": "1732", "Body": "<p>Consider these two functions:</p>\n<pre><code>void foo() {}\nvoid bar() {}\n</code></pre>\n<p>is it guaranteed that <code>&amp;foo != &amp;bar</code>?</p>\n<p>Similarly,</p>\n<pre><code>template&lt;class T&gt; void foo() { }\n</code></pre>\n<p>is it guaranteed that <code>&amp;foo&lt;int&gt; != &amp;foo&lt;double&gt;</code>?</p>\n<hr>\n<p>There are two linkers I know of that fold function definitions together.</p>\n<p>MSVC aggressively COMDAT folds functions, so two functions with the same implementation can be turned into one function.  As a side effect, the two functions share the same address.  I was under the impression that this was illegal, but I cannot find where in the standard it is made illegal.</p>\n<p><a href=\"http://research.google.com/pubs/pub36912.html\">The Gold linker</a> also folds functions, with both a <code>safe</code> and <code>all</code> setting.  <code>safe</code> means that if a function address is taken, it is not folded, while <code>all</code> folds even if the address is taken.  So gold's fold <code>safe</code> behaves as-if functions have distinct addresses.</p>\n<p>While folding might be unexpected, and there is code that relies on distinct (identical implementation) functions having different addresses (so it can be dangerous to fold), is it actually illegal under the current C++ standard?  (C++14 at this point)  (Naturally as-if <code>safe</code> folding is legal)</p>\n</hr>", "Title": "Do distinct functions have distinct addresses?", "CreationDate": "2014-10-23T17:21:22.290", "LastActivityDate": "2015-04-14T20:34:11.320", "CommentCount": "19", "FavoriteCount": "14", "PostTypeId": "1", "LastEditDate": "2014-10-24T18:49:45.817", "LastEditorUserId": "1774667", "Id": "26533740", "Score": "50", "OwnerUserId": "1774667", "Tags": "<c++><function-pointers><language-lawyer><one-definition-rule><comdat-folding>", "AnswerCount": "4"}, "26553858": {"Id": "26553858", "PostTypeId": "2", "Body": "<p>So the problematic part is clearly the phrase <strong>or both represent the same address (3.9.2)</strong>.</p>\n<p>IMO this part is clearly there to define the semantics for object pointer types. And only for object pointer types.</p>\n<p>The phrase references section 3.9.2, which means we should look there. 3.9.2 talks (among others) about the addresses that object pointers represent. It does not talk about the addresses that function pointers represent. Which, IMO, leaves just two possible interpretations:</p>\n<p>1) The phrase simply does not apply to function pointers. Which leaves just the two null pointers and two pointers to the same function comparing equal, which is what probably most of us expected.</p>\n<p>2) The phrase does apply. Since it's referring to 3.9.2, which says nothing about the addresses that function pointers represent, we may make <em>any</em> two function pointers compare equal. Which is very unexpected and of course renders comparing function pointers utterly useless.</p>\n<p>So, while technically an argument could be made that (2) is a <em>valid</em> interpretation, IMO it's not a <em>meaningful</em> interpretation and thus should be disregarded. And since not everyone seems to agree on this, I also think that a clarification in the standard is needed.</p>\n", "LastEditorUserId": "454519", "LastActivityDate": "2015-01-12T18:01:13.520", "Score": "5", "CreationDate": "2014-10-24T18:14:43.807", "ParentId": "26533740", "CommentCount": "0", "OwnerUserId": "454519", "LastEditDate": "2015-01-12T18:01:13.520"}});