post_cb({"bq_ids": {"n4140": {"so_42509344_42516715_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 593}, "so_42509344_42516715_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 641}, "so_42509344_42516715_8": {"length": 23, "quality": 0.8214285714285714, "section_id": 641}, "so_42509344_42516715_0": {"length": 49, "quality": 0.8909090909090909, "section_id": 641}}, "n3337": {"so_42509344_42516715_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 631}, "so_42509344_42516715_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 631}, "so_42509344_42516715_8": {"length": 23, "quality": 0.8214285714285714, "section_id": 631}, "so_42509344_42516715_0": {"length": 49, "quality": 0.8909090909090909, "section_id": 631}}, "n4659": {"so_42509344_42516715_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 616}, "so_42509344_42516715_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 669}, "so_42509344_42516715_8": {"length": 23, "quality": 0.8214285714285714, "section_id": 669}, "so_42509344_42516715_0": {"length": 45, "quality": 0.8181818181818182, "section_id": 669}}}, "42509344": {"ViewCount": "93", "Body": "<p>Consider the following code:</p>\n<pre><code>void func(int) {}\ntemplate&lt;typename T&gt; void templatedFunc(T) {}\nint main()\n{\n    void (*p)(int) = func;\n\n    bool test1 = p==func;\n    //bool test2 = p==templatedFunc&lt;int&gt;; // compilation error\n    bool test3 = p==&amp;templatedFunc&lt;int&gt;; // but this works\n}\n</code></pre>\n<p>If you uncomment the <code>test2</code> line and try to compile the code with g++, you'll get the following error:</p>\n<pre><code>test.cpp: In function \u2018int main()\u2019:\ntest.cpp:8:21: error: assuming cast to type \u2018void (*)(int)\u2019 from overloaded function [-fpermissive]\n     bool test2 = p==templatedFunc&lt;int&gt;; // compilation error\n                     ^~~~~~~~~~~~~~~~~~\n</code></pre>\n<p>I get this result on g++ 5.3.0 and 6.2.0. At the same time, compilation with clang++ 3.6.0 succeeds without warnings.</p>\n<p>Which compiler is correct according to the Standard here \u2014 g++, which gives an error or clang++, which doesn't?</p>\n<p>And if g++ is right, then why is there such an asymmetry with normal functions vs templated functions regarding the need of explicit address-of operator?</p>\n", "AcceptedAnswerId": "42516715", "Title": "Why can't one compare a function pointer to a template function without explicit & on function name?", "CreationDate": "2017-02-28T12:56:25.437", "Id": "42509344", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-02-28T19:00:35.517", "Score": "10", "OwnerUserId": "673852", "Tags": "<c++><templates><function-pointers>", "AnswerCount": "1"}, "42516715": {"Id": "42516715", "PostTypeId": "2", "Body": "<p>This is a gcc bug, and you are in a corner case, in the C++ standard, <em>Address of overloaded function</em> \u00a713.4 ([over.over]/1):</p>\n<blockquote>\n<p id=\"so_42509344_42516715_0\">A use of an overloaded function name without arguments is resolved in certain contexts to a function, a\n  pointer to function or a pointer to member function for a specific function from the overload set. A function\n  template name is considered to name a set of overloaded functions in such contexts. The function selected\n  is the one whose type is identical to the function type of the target type required in the context. [ Note:\n  That is, the class of which the function is a member is ignored when matching a pointer-to-member-function\n  type. \u2014 end note ] The target can be:</p>\n<p id=\"so_42509344_42516715_1\">(1.1) \u2014 an object or reference being initialized (8.5, 8.5.3, 8.5.4),</p>\n<p id=\"so_42509344_42516715_2\">(1.2) \u2014 the left side of an assignment (5.18),</p>\n<p id=\"so_42509344_42516715_3\">(1.3) \u2014 a parameter of a function (5.2.2),</p>\n<p id=\"so_42509344_42516715_4\">(1.4) \u2014 a parameter of a user-defined operator (13.5),</p>\n<p id=\"so_42509344_42516715_5\">(1.5) \u2014 the return value of a function, operator function, or conversion (6.6.3),</p>\n<p id=\"so_42509344_42516715_6\">(1.6) \u2014 an explicit type conversion (5.2.3, 5.2.9, 5.4), or</p>\n<p id=\"so_42509344_42516715_7\">(1.7) \u2014 a non-type template-parameter (14.3.2).</p>\n<p id=\"so_42509344_42516715_8\">The overloaded function name can be preceded by the &amp; operator. An overloaded function name shall not\n  be used without arguments in contexts other than those listed. [ Note: Any redundant set of parentheses\n  surrounding the overloaded function name is ignored (5.1). \u2014 end note ]</p>\n</blockquote>\n<p>Do you see what is lacking in the list from (1.1) to (1.7)... built-in operators!</p>\n<p>If you declare an overload of <code>operator ==</code> both gcc will not complain with the comparison, more than that you do not have to explicitly specialize the template function:</p>\n<pre><code>void func(int) {}\ntemplate&lt;class T&gt;\nvoid templatedFunc(T) {}\nstruct s{};\nbool operator==(s, void(*)(int)){return false;}\nint main()\n{\n   void (*p)(int) = templatedFunc;\n\n   bool test1 = p==func;\n   bool test2 = s{} == templatedFunc&lt;int&gt;; // no error - no overload resolution\n   bool test3 = s{} == templatedFunc; // no error - overload resolution\n   bool test4 = p == templatedFunc&lt;int&gt;; // gcc error, but not an error -\n                                         // no overload resolution\n //bool test5 = p == templatedFunc; // error - overload resolution not\n                                 // performed for built-int operators\n\n}\n</code></pre>\n<p><code>test2</code> and <code>test3</code> compiles with gcc. <code>test4</code> does not compile on gcc, but there are no overload resolution, you explicitly specialized the function. It really should compile. <code>test5</code> does not compile as stated in the standard. In this case gcc produces the exact same error message as for <code>test4</code>. This is surely a gcc bug.</p>\n", "LastActivityDate": "2017-02-28T19:00:35.517", "CommentCount": "0", "CreationDate": "2017-02-28T19:00:35.517", "ParentId": "42509344", "Score": "1", "OwnerUserId": "5632316"}});