post_cb({"6677162": {"Id": "6677162", "PostTypeId": "2", "Body": "<p>That's because user defined conversions cannot be chained. To explain with an example:</p>\n<pre><code>struct A {\n  void operator = (const int i);\n};\n\nstruct B {\n  operator int ();\n}\n\nA a;\nB b;\na = b;  // error! because, compiler will not match \"A::operator=\" and \"B::operator int\"\n</code></pre>\n<p>Here is the <a href=\"https://stackoverflow.com/questions/6120240/why-constructor-is-not-called-for-given-casting-operator\">similar question</a>, I asked sometime back.</p>\n<p>In your case, your first user defined conversions are,</p>\n<p>(1) <code>NameType::operator std::string()</code></p>\n<p>(2) <code>operator &lt;&lt;(ostream&amp;, const std::string&amp;)</code> which is somewhat like <code>ostream::operator&lt;&lt;(std::string&amp;)</code>.</p>\n<p>When you write, <code>cout &lt;&lt; p.name;</code> Now two type of <strong>objects</strong> come face to face:</p>\n<pre><code>ostream (LHS) &lt;====&gt; NameType (RHS)\n</code></pre>\n<p>Now, <code>operator &lt;&lt;(ostream&amp;, const string&amp;)</code> is invoked <strong>only</strong> if RHS is <code>string</code>. But here it's <code>NameType</code>; so it's not invoked.</p>\n<p>And, <code>NameType::operator string ()</code> is invoked <strong>only</strong> if, LHS is <code>string</code>. But here it's <code>ostream</code>; so it's not invoked.</p>\n<p>To make this equation true; bot the of the above operator methods should be invoked by compiler. But that's not supported by C++. Why it's not supported, is described in the link I posted above.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-07-13T11:23:00.073", "Score": "-3", "CreationDate": "2011-07-13T10:00:53.887", "ParentId": "6677072", "CommentCount": "9", "LastEditDate": "2017-05-23T10:28:54.423", "OwnerUserId": "514235"}, "6677134": {"Id": "6677134", "PostTypeId": "2", "Body": "<p>It is because it is a template. </p>\n<p>For this to work you would need to instantiate the template first, and use the conversion operator afterwards. That's the wrong order, so it doesn't work.</p>\n<hr>\n<p>It doesn't matter if you have used a specific operator earlier in the program or not. Each use is considered separately</p>\n<p>The overloads considered as candidates are those where all the template parameters can be deduced from std::ostream, or those that are members of that class.</p>\n<hr>\n<p>What if we add a non-template operator?</p>\n<pre><code>#include &lt;string&gt; \n#include &lt;ostream&gt; \n#include &lt;iostream&gt;  \n\nstruct NameType {\n   operator std::string() { return \"wobble\"; } \n};  \n\nstruct Person {\n    NameType name;\n};  \n\nvoid operator&lt;&lt;(std::ostream&amp; os, const std::string&amp; s)   // ** added **\n{ std::operator&lt;&lt;(os, s); }\n\nint main() \n{    \n    std::cout &lt;&lt; std::string(\"bobble\");\n    std::cout &lt;&lt; \"wibble\";\n\n     Person p;\n     std::cout &lt;&lt; p.name; \n}  \n</code></pre>\n<p>Now it works, and outputs</p>\n<pre><code> bobblewibblewobble\n</code></pre>\n</hr></hr>", "LastEditorUserId": "597607", "LastActivityDate": "2011-07-13T12:26:04.637", "Score": "5", "CreationDate": "2011-07-13T09:59:01.140", "ParentId": "6677072", "CommentCount": "6", "LastEditDate": "2011-07-13T12:26:04.637", "OwnerUserId": "597607"}, "7525611": {"Id": "7525611", "PostTypeId": "2", "Body": "<p>The conversion to string is only invoked if some cases:</p>\n<p>a) requested explicitly <code>(string) p.name</code></p>\n<p>b) assignment to a string <code>string a = p.name</code></p>\n<p>c) ...</p>\n<p>If the present case does not fit any, you can force the invokation to <code>ostream&lt;&lt;(ostream&amp;,string)</code> in at least two ways:</p>\n<ol>\n<li><p><a href=\"http://ideone.com/SJe5W\" rel=\"nofollow\">http://ideone.com/SJe5W</a> Making NameType <em>be</em> an string (by public inheritance).</p></li>\n<li><p>go to case <strong>a)</strong>: requesting explicitly the conversion as seen in the example with the conversion to <code>(int)</code>.</p></li>\n</ol>\n<p>I really prefer the option <strong>1</strong>.</p>\n", "LastActivityDate": "2011-09-23T07:24:58.130", "Score": "0", "CreationDate": "2011-09-23T07:24:58.130", "ParentId": "6677072", "CommentCount": "0", "OwnerUserId": "887427"}, "bq_ids": {"n4140": {"so_6677072_7505108_0": {"length": 19, "quality": 0.95, "section_id": 289}}, "n3337": {"so_6677072_7505108_0": {"length": 19, "quality": 0.95, "section_id": 280}}, "n4659": {"so_6677072_7505108_0": {"length": 19, "quality": 0.95, "section_id": 296}}}, "6677145": {"Id": "6677145", "PostTypeId": "2", "Body": "<p>Its because user-defined conversion function isn't consider in ADL. ADL means overload set contains overload function(s) from the namespace in which the <em>argument</em> is defined. Here the <em>type</em> of argument to <code>operator&lt;&lt;</code> is <code>NameType</code> but <code>operator &lt;&lt; (std::ostream&amp;, const NameType&amp;)</code> has not been defined in the namespace in which <code>NameType</code> is defined. Hence the error, as searching for appropriate overload <em>stops</em> right there. That is what ADL is. ADL doesn't go further to look into the definition of <code>NameType</code> to determine if it defines any user-defined conversion function or not.</p>\n<p>You will get <a href=\"http://www.ideone.com/dTBF8\" rel=\"nofollow\">the same error</a> if you do the following:</p>\n<pre><code>NameType name;\nstd::cout &lt;&lt; name ; //error: user-defined conversion not considered.\n</code></pre>\n<p>You need to <a href=\"http://www.ideone.com/XjKFD\" rel=\"nofollow\">cast</a> it:</p>\n<pre><code>std::cout &lt;&lt; (std::string)name &lt;&lt; std::endl; //ok - use std::string()\n</code></pre>\n<p>Also, you might have more than one user-defined conversion functions:</p>\n<pre><code>std::cout &lt;&lt; (int)name &lt;&lt; std::endl; //ok - use int() instead\n</code></pre>\n<p>Output at <a href=\"http://www.ideone.com/C6aHE\" rel=\"nofollow\">ideone</a>:</p>\n<pre><code>wobble\n100\n</code></pre>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-07-13T10:28:12.020", "Score": "2", "CreationDate": "2011-07-13T09:59:48.693", "ParentId": "6677072", "CommentCount": "10", "LastEditDate": "2011-07-13T10:28:12.020", "OwnerUserId": "415784"}, "6677072": {"ViewCount": "1889", "Body": "<p><strong>Disclaimer:</strong> I <em>know</em> that implicit conversion to string should be avoided, and that the proper approach would be an <code>op&lt;&lt;</code> overload for <code>Person</code>.</p>\n<hr>\n<p>Consider the following code:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;ostream&gt;\n#include &lt;iostream&gt;\n\nstruct NameType {\n   operator std::string() { return \"wobble\"; }\n};\n\nstruct Person {\n   NameType name;\n};\n\nint main() {\n   std::cout &lt;&lt; std::string(\"bobble\");\n   std::cout &lt;&lt; \"wibble\";\n\n   Person p;\n   std::cout &lt;&lt; p.name;\n}\n</code></pre>\n<p>It <a href=\"http://www.ideone.com/6t0EA\">yields the following on GCC 4.3.4</a>:</p>\n<pre><code>prog.cpp: In function \u2018int main()\u2019:\nprog.cpp:18: error: no match for \u2018operator&lt;&lt;\u2019 in \u2018std::cout &lt;&lt; p.Person::name\u2019\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:112: note: candidates are: std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp; (*)(std::basic_ostream&lt;_CharT, _Traits&gt;&amp;)) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:121: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(std::basic_ios&lt;_CharT, _Traits&gt;&amp; (*)(std::basic_ios&lt;_CharT, _Traits&gt;&amp;)) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:131: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(std::ios_base&amp; (*)(std::ios_base&amp;)) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:169: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(long int) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:173: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(long unsigned int) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:177: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(bool) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/bits/ostream.tcc:97: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(short int) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:184: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(short unsigned int) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/bits/ostream.tcc:111: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(int) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:195: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(unsigned int) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:204: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(long long int) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:208: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(long long unsigned int) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:213: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(double) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:217: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(float) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:225: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(long double) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/ostream:229: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(const void*) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n/usr/lib/gcc/i686-pc-linux-gnu/4.3.4/include/g++-v4/bits/ostream.tcc:125: note:                 std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::basic_ostream&lt;_CharT, _Traits&gt;::operator&lt;&lt;(std::basic_streambuf&lt;_CharT, _Traits&gt;*) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;]\n</code></pre>\n<p>How come the free <code>op&lt;&lt;(ostream&amp;, string const&amp;)</code> doesn't make it into the overload set? Is this due to a combination of the desired overload being a template instantiation and ... ADL?</p>\n</hr>", "AcceptedAnswerId": "7505108", "Title": "Overload resolution failure when streaming object via implicit conversion to string", "CreationDate": "2011-07-13T09:52:51.370", "Id": "6677072", "CommentCount": "6", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2014-11-20T15:01:26.337", "LastEditorUserId": "560648", "LastActivityDate": "2014-11-20T15:01:26.337", "Score": "18", "OwnerUserId": "560648", "Tags": "<c++><operator-overloading><std><implicit-conversion>", "AnswerCount": "5"}, "7505108": {"Id": "7505108", "PostTypeId": "2", "Body": "<p>14.8.1/4 in C++98</p>\n<blockquote>\n<p id=\"so_6677072_7505108_0\">Implicit conversions (clause 4) will be performed on a function argument to convert it to the type of the corresponding function parameter if the parameter type contains no <em>template-parameters</em> that participate in template argument deduction.</p>\n</blockquote>\n<p>Here you would like an instantiation of</p>\n<pre><code>template &lt;class charT, class traits, class Allocator&gt;\n  basic_ostream&lt;charT, traits&gt;&amp;\n    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;,\n               const basic_string&lt;charT, traits, Allocator&gt;&amp;);\n</code></pre>\n<p>to be deduced without providing explicitly any template arguments. So all of the arguments contain a <em>template-parameter</em> that participates in the template argument deduction and thus none of them can get its value from an implicit conversion.</p>\n", "LastActivityDate": "2011-09-21T18:54:57.037", "Score": "17", "CreationDate": "2011-09-21T18:54:57.037", "ParentId": "6677072", "CommentCount": "2", "OwnerUserId": "136208"}});