post_cb({"35790712": {"ParentId": "35790350", "LastEditDate": "2016-03-04T08:42:17.720", "CommentCount": "9", "CreationDate": "2016-03-04T07:50:04.700", "OwnerUserId": "1830736", "LastEditorUserId": "1830736", "PostTypeId": "2", "Id": "35790712", "Score": "12", "Body": "<p>Your code is legal, even though GCC claims otherwise.  It takes offense at this funny-looking declaration:</p>\n<pre><code>D() noexcept(noexcept(D{42}));\n</code></pre>\n<p>The outermost <code>noexcept</code> is a <a href=\"http://en.cppreference.com/w/cpp/language/noexcept_spec\">noexcept specifier</a>, stating that <code>D::D()</code> is noexcept if and only if its constant-expression argument evaluates to true.  The inner <code>noexcept</code> is a <a href=\"http://en.cppreference.com/w/cpp/language/noexcept\">noexcept operator</a> that checks at compile time whether its argument expression, which is not actually evaluated, throws no exceptions.  Because <code>D::D(int)</code> is noexcept (inherited from B), this should be true.</p>\n<p>cppreference.com explicitly notes that using the operator inside the specifier is allowed (emphasis added):</p>\n<blockquote>\n<p id=\"so_35790350_35790712_0\">The noexcept operator performs a compile-time check that returns true if an expression is declared to not throw any exceptions.</p>\n<p id=\"so_35790350_35790712_1\"><strong>It can be used within a function template's noexcept specifier to declare that the function will throw exceptions for some types but not others.</strong></p>\n</blockquote>\n<p>Now, the class should be considered <em>complete</em> within the noexcept specifier due to \u00a79.2.2 of the Standard (bold emphasis added):</p>\n<blockquote>\n<p id=\"so_35790350_35790712_2\">A class is considered a completely-defined object type (3.9) (or complete type) at the closing <code>}</code> of the <em>class-specifier</em>. <strong>Within the class <em>member-specification</em>, the class is regarded as complete within</strong> function bodies, default arguments, <em>using-declaration</em>s introducing inheriting constructors (12.9), <strong><em>exception-specification</em>s</strong>, and <em>brace-or-equal-initializer</em>s for non-static data members (including such things in nested classes). Otherwise it is regarded as incomplete within its own class <em>member-specification</em>.</p>\n</blockquote>\n<p>\u00a715.4.1 defines an <em>exception-specification</em> as the following grammar:</p>\n<blockquote>\n<p id=\"so_35790350_35790712_3\"><em>exception-specification</em>:</p>\n<ul>\n<li><p id=\"so_35790350_35790712_4\"><em>dynamic-exception-specification</em></p></li>\n<li><p id=\"so_35790350_35790712_5\"><em>noexcept-specification</em></p></li>\n</ul>\n</blockquote>\n<p>So GCC should not reject your code.</p>\n", "LastActivityDate": "2016-03-04T08:42:17.720"}, "35790350": {"CommentCount": "7", "CreationDate": "2016-03-04T07:27:33.973", "PostTypeId": "1", "AcceptedAnswerId": "35790712", "LastEditorUserId": "4987285", "LastActivityDate": "2016-03-08T11:46:33.287", "LastEditDate": "2016-03-08T11:06:03.030", "ViewCount": "309", "FavoriteCount": "1", "Title": "noexcept, inheriting constructors and the invalid use of an incomplete type that is actually complete", "Id": "35790350", "Score": "12", "Body": "<p>I'm not sure if it's a bug of the <em>GCC</em> compiler or the intended behavior of <code>noexcept</code>.<br>\nConsider the following example:</br></p>\n<pre><code>struct B {\n    B(int) noexcept { }\n    virtual void f() = 0;\n};\n\nstruct D: public B {\n    using B::B;\n    D() noexcept(noexcept(D{42})): B{42} { }\n    void f() override { }\n};\n\nint main() {\n    B *b = new D{};\n}\n</code></pre>\n<p>If the <code>noexcept</code> is removed, it compiles.<br>\nAnyway, as it is in the example, I got this error from GCC v5.3.1:</br></p>\n<pre><code>test.cpp:8:31: error: invalid use of incomplete type \u2018struct D\u2019\n     D() noexcept(noexcept(D{42})): B{42} { }\n                               ^\n</code></pre>\n<p>As far as I know, <code>struct D</code> is not an incomplete type, but inheriting constructors are involved in the statement and it looks like the compiler is actually considering the completeness of the base struct <code>B</code> more than of <code>D</code>.</p>\n<p>Is that the intended behavior or is it legal code?</p>\n<p>For the sake of clarity:</p>\n<ul>\n<li><a href=\"http://goo.gl/LzWlya\" rel=\"nofollow\">here</a> the compilation succeeds using <em>clang 3.7.1</em></li>\n<li><a href=\"http://goo.gl/OxkUvU\" rel=\"nofollow\">here</a> the compilation fails using <em>GCC 5.3.0</em></li>\n</ul>\n<p>See <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70077\" rel=\"nofollow\">this link</a> to the <em>bugzilla</em> for the GCC compiler for further details.<br>\nCurrently, the bug is still unconfirmed. I'll update the question as soon as possible.</br></p>\n", "Tags": "<c++><c++11><language-lawyer><noexcept><inheriting-constructors>", "OwnerUserId": "4987285", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_35790350_35790712_2": {"section_id": 5862, "quality": 0.9761904761904762, "length": 41}}, "n3337": {"so_35790350_35790712_2": {"section_id": 5632, "quality": 0.8809523809523809, "length": 37}}, "n4659": {"so_35790350_35790712_2": {"section_id": 7345, "quality": 0.7619047619047619, "length": 32}}}});