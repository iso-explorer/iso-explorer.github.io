post_cb({"20615184": {"Id": "20615184", "PostTypeId": "2", "Body": "<p>It is perfectly valid, standard-conformant code, beyond any doubt.</p>\n<pre><code>Struct(const T&amp; value) : value(value) {}\n                               ^^^^^ this is argument\n                         ^^^^^ this is the member\n</code></pre>\n<p>Now the question is: is this good practice? In my opinion, NO. I prefer my data-members to follow <em>different yet consistent</em> naming convention, such as data-members always start with <code>_</code>. So I would prefer this:</p>\n<pre><code>Struct(const T&amp; value) : _value(value) {}\n</code></pre>\n<p>where <code>_value</code> is data member. You could follow any naming convention \u2014 just make sure that you're consistent. </p>\n<p>Note that in your code variable, functions, classes or any identifier should not start with double underscore such as <code>__value</code>, or single underscore followed by upper case letter such as <code>_Value</code> \u2014 such names are <strong>reserved</strong> for implementations.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2013-12-16T16:11:34.803", "Score": "3", "CreationDate": "2013-12-16T15:59:10.740", "ParentId": "20615156", "CommentCount": "20", "OwnerUserId": "415784", "LastEditDate": "2013-12-16T16:11:34.803"}, "20618028": {"Id": "20618028", "PostTypeId": "2", "Body": "<p>This is indeed valid code and like the rest of the answers I will warn you that this should be used very carefully since it can be confusing and would probably lead to hard to maintain code.</p>\n<p>So why does this work? If we consider your constructor:</p>\n<pre><code>Struct(const T&amp; value) : value(value) {}\n                         ^     ^\n                         1     2    \n</code></pre>\n<p><code>1</code> and <code>2</code> are evaluated in different scopes. So we need to look at the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>12.6.2</code> <em>Initializing bases and members</em> and look at some grammar:</p>\n<pre><code>ctor-initializer:\n    : mem-initializer-list \nmem-initializer-list:\n    mem-initializer ...opt\n    mem-initializer , mem-initializer-list ...opt\nmem-initializer:\n    mem-initializer-id ( expression-listopt )\n    mem-initializer-id braced-init-list\n</code></pre>\n<p>After digesting this we see that <code>1</code> is really a <em>mem-initializer-id</em> and <code>2</code> is a <em>expression-listopt</em> and we can go to paragraph <em>2</em> and <em>12</em> respectively for each of these. Paragraph <em>2</em> says:</p>\n<blockquote>\n<p id=\"so_20615156_20618028_0\">In a mem-initializer-id an initial unqualified identifier is looked up in the scope of the constructor\u2019s class and, if not found in that scope, it is looked up in the scope containing the constructor\u2019s definition. [...]</p>\n</blockquote>\n<p>So <code>1</code> will be looked up in the class first while we can see from paragraph <em>12</em> which says:</p>\n<blockquote>\n<p id=\"so_20615156_20618028_1\">Names in the expression-list or braced-init-list of a mem-initializer are evaluated in the scope of the constructor for which the mem-initializer is specified.</p>\n</blockquote>\n<p><code>2</code> will be looked up in the scope of the constructor. So <code>1</code> will find the member variable first and stop looking while <code>2</code> will look in the constructor and find the parameter. This also means that if you wanted to refer to a member variable in an <em>expression-list</em> you would have to use <em>this-&gt;</em>.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-12-17T05:07:26.850", "Score": "3", "CreationDate": "2013-12-16T18:23:10.410", "ParentId": "20615156", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2013-12-17T05:07:26.850"}, "20615203": {"Id": "20615203", "PostTypeId": "2", "Body": "<p>It's valid but, as evidenced by the need to even ask this, potentially jarring and confusing.</p>\n<p>The perennial problem is coming up with two distinct names for what is kinda the same thing.</p>\n<p>I like to do this (but some people hate it):</p>\n<pre><code>struct Struct {\n  Struct(const T&amp; newValue) : value(newValue) {}\n  T value;\n};\n</code></pre>\n", "LastActivityDate": "2013-12-16T16:00:47.657", "CommentCount": "0", "CreationDate": "2013-12-16T16:00:47.657", "ParentId": "20615156", "Score": "0", "OwnerUserId": "2428400"}, "20615423": {"Id": "20615423", "PostTypeId": "2", "Body": "<p>This is permitted by the C++ standard, but consider the case where, after initializing members, you want to do more work in the function. For example, using <code>3</code> to stand in for some more meaningful calculation:</p>\n<pre><code>class Foo\n{\npublic:\n    int bar;\n    Foo(int bar) : bar(bar) { bar = 3; }\n};\n</code></pre>\n<p>The assignment in the function changes the value of the parameter <code>bar</code>, not the value of the member <code>bar</code>. This cannot happen in your example, because you declared the parameter with <code>const</code>. So, if you are sure to always declare parameters with <code>const</code>, you are protected from this. But consider a more complicated scenario:</p>\n<pre><code>class Foo\n{\npublic:\n    int bar;\n    int baz;\n    void AuxiliaryFunction() { bar = 3; }\n    Foo(const int &amp;bar) : bar(bar)\n    {\n        AuxiliaryFunction();\n        baz = bar;\n    }\n};\n</code></pre>\n<p>In this example, the member <code>bar</code> is given some value through another function called in the constructor. Then the assignment <code>baz = bar;</code> may be intended to copy the member <code>bar</code>, but it actually copies the parameter <code>bar</code>.</p>\n<p>So, while this is legal C++, it should be used judiciously.</p>\n", "LastActivityDate": "2013-12-16T16:11:37.490", "CommentCount": "0", "CreationDate": "2013-12-16T16:11:37.490", "ParentId": "20615156", "Score": "2", "OwnerUserId": "298225"}, "20615397": {"Id": "20615397", "PostTypeId": "2", "Body": "<p>It is valid. However a little warning: Changing the argument name and the code is undefined behavior.</p>\n<pre><code>template &lt;typename T&gt;\nstruct Struct {\n    Struct(const T &amp; argument) : value(value) {}\n    T value;\n};\n</code></pre>\n", "LastActivityDate": "2013-12-16T16:10:35.370", "CommentCount": "0", "CreationDate": "2013-12-16T16:10:35.370", "ParentId": "20615156", "Score": "1", "OwnerUserId": "2249683"}, "bq_ids": {"n4140": {"so_20615156_20618028_1": {"length": 9, "quality": 1.0, "section_id": 440}, "so_20615156_20618028_0": {"length": 15, "quality": 1.0, "section_id": 429}}, "n3337": {"so_20615156_20618028_1": {"length": 9, "quality": 1.0, "section_id": 431}, "so_20615156_20618028_0": {"length": 15, "quality": 1.0, "section_id": 421}}, "n4659": {"so_20615156_20618028_1": {"length": 9, "quality": 1.0, "section_id": 460}, "so_20615156_20618028_0": {"length": 15, "quality": 1.0, "section_id": 447}}}, "20615156": {"ViewCount": "221", "Body": "<p>Is this valid <em>C++</em>, assuming I want to copy the argument variable to the member variable:</p>\n<pre><code>struct Struct {\n  Struct(const T&amp; value) : value(value) {}\n  T value;\n};\n</code></pre>\n<p>(Update: It works in Visual Studio, but still that might be compiler dependent)\n(Expected question: <em>Why do you need this?</em> Answer: <em>Macro-making purposes</em>)</p>\n", "AcceptedAnswerId": "20618028", "Title": "Is using same parameter name and member name valid", "CreationDate": "2013-12-16T15:57:55.970", "Id": "20615156", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-12-18T03:04:58.017", "LastEditorUserId": "1708801", "LastActivityDate": "2013-12-18T03:04:58.017", "Score": "5", "OwnerUserId": "100724", "Tags": "<c++><variables><constructor><language-lawyer><argument-passing>", "AnswerCount": "7"}, "20615333": {"Id": "20615333", "PostTypeId": "2", "Body": "<p>It is valid, but ill-advised in some circles, including my circle.</p>\n<p>It is valid in the sense that the member variable will be properly set by the parameter as you desire.  Following the execution of the initializer list, the member will be hidden.  Any reference to <code>value</code> will access the parameter.  This is likely a bad thing.</p>\n<p>It is ill-advised for two reasons.  First and foremost, maintainability &amp; confusion.  It is unusual to see a parameter and member variable have the same name.  Because of this, most programmers will have to stop and <em>think</em> about what it means.  After all, you did.  Remember that code is written first for <em>programmers</em>, second for compilers.  Code that is easy to understand is much better than code that is hard to understand.  In a code review I would reject this code on these grounds.</p>\n<p>Second, the member hiding will likely be a problem in most scenarios.</p>\n<p>I'd suggest coming up with a sane naming scheme and sticking with it.  \"Sane\" means a parameter can never have the same name as a member variable.  For example in my naming scheme, member variables are always prepended with <code>m</code> -- parameters never prepended.  So in this scheme your code would become:</p>\n<pre><code>struct Struct {\n  Struct(const T&amp; value) : mValue(value) {}\n  T mValue;\n};\n</code></pre>\n<p>Using this scheme, nobody is confused about what's happening here and nobody has to ask StackOverflow \"is this legit?\"</p>\n", "LastEditorUserId": "241536", "LastActivityDate": "2013-12-16T16:26:30.203", "Score": "2", "CreationDate": "2013-12-16T16:07:14.507", "ParentId": "20615156", "CommentCount": "4", "OwnerUserId": "241536", "LastEditDate": "2013-12-16T16:26:30.203"}, "20615209": {"Id": "20615209", "PostTypeId": "2", "Body": "<p>Yes. It does compile. For the compiler, there is no ambiguity of which <code>value</code> is which.</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nstruct Struct {\n    Struct(const T &amp; value) : value(value) {}\n    T value;\n};\n\nint main() {\n\n    Struct&lt;int&gt; T(1);\n    // your code goes here\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/gPyBK6\" rel=\"nofollow\">http://ideone.com/gPyBK6</a></p>\n<p>But at stated multiple times, this is not easy for the programmer to decipher. It does work because for the compiler the parameter mask the member function, so the second <code>value</code> in <code>value(value)</code> is the parameter, but as only member and ancestor class can be on the left part of <code>value(value)</code>, it does refer to the member here. </p>\n<p>Tricky enough to complicate debugging and maintenance.</p>\n", "LastEditorUserId": "2439734", "LastActivityDate": "2013-12-16T16:24:41.247", "Score": "2", "CreationDate": "2013-12-16T16:01:03.320", "ParentId": "20615156", "CommentCount": "13", "OwnerUserId": "2439734", "LastEditDate": "2013-12-16T16:24:41.247"}});