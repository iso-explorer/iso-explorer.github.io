post_cb({"33607284": {"CommentCount": "6", "ViewCount": "1119", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-11-09T10:37:54.797", "LastActivityDate": "2015-11-17T20:14:44.170", "Title": "\"control reaches end of non-void function\" with fully handled case switch over an enum type", "AcceptedAnswerId": "33607345", "LastEditDate": "2017-05-23T12:25:17.053", "Id": "33607284", "Score": "3", "Body": "<p>Why does this code trigger a \"control reaches end of non-void function\" even if all possible values of <code>type_t</code> are handled? What is the best way to take care of this warning? Adding a <code>return -1</code> after the switch?<br/>(Code tested <a href=\"http://coliru.stacked-crooked.com/a/6b5b3e74478b1391\" rel=\"nofollow noreferrer\">here</a>)</p>\n<pre><code>typedef enum {\n    A,\n    B\n} type_t;\n\nint useType(type_t x) {\n    switch (x) {\n        case A:\n            return 0;\n        case B:\n            return 1;\n    }\n}\n</code></pre>\n<p><hr/>\nRelated: <a href=\"https://stackoverflow.com/q/4796015/2436175\">Detecting if casting an int to an enum results into a non-enumerated value</a></p>\n", "Tags": "<c++><g++><compiler-warnings>", "OwnerUserId": "2436175", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33607284_33607345_0": {"section_id": 5467, "quality": 1.0, "length": 7}, "so_33607284_33607345_1": {"section_id": 6036, "quality": 0.8181818181818182, "length": 18}}, "n3337": {"so_33607284_33607345_0": {"section_id": 5253, "quality": 1.0, "length": 7}, "so_33607284_33607345_1": {"section_id": 5804, "quality": 0.8181818181818182, "length": 18}}, "n4659": {"so_33607284_33607345_0": {"section_id": 6901, "quality": 1.0, "length": 7}, "so_33607284_33607345_1": {"section_id": 7535, "quality": 0.9545454545454546, "length": 21}}}, "33607345": {"ParentId": "33607284", "LastEditDate": "2015-11-09T20:01:46.580", "CommentCount": "7", "CreationDate": "2015-11-09T10:41:20.820", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "PostTypeId": "2", "Id": "33607345", "Score": "7", "Body": "<p>In general, <code>enum</code>s are not exclusive. Someone could call your function like <code>useType( (type_t)3 );</code> for example. This is mentioned specifically in C++14 [dcl.enum]/8:</p>\n<blockquote>\n<p id=\"so_33607284_33607345_0\">It is possible to define an enumeration that has values not defined by any of its enumerators.</p>\n</blockquote>\n<p>Now, there are a bunch of rules about exactly which other values are possible for which other sorts of enum.</p>\n<p>There are two categories of enum. The first is  <em>fixed underlying type</em>, e.g. <code>enum type_t : int</code>, or <code>enum class type_t</code> . In those cases all values of the underlying type are valid enumerators.</p>\n<p>The second is <em>not fixed underlying type</em>, which includes pre-C++11 enums such as yours. In this case the rule about values can be summarized by saying: compute the smallest number of bits necessary in order to store all values of the enum; then any number expressible in that number of bits is a valid value.</p>\n<hr>\n<p>So - in your specific case, a single bit can hold both values <code>A</code> and <code>B</code>, so <code>3</code> is not  valid value for the enumerator.</p>\n<p>But if your enum were <code>A,B,C</code>, then even though <code>3</code> is not listed specifically, it is a valid value by the above rule. (So we can see that almost all enums will not be exclusive). </p>\n<p>Now we need to look at the rule for what happens if someone does actually try to convert <code>3</code> to <code>type_t</code>. The conversion rule is C++14 [expr.static.cast]/10, which says that an unspecified value is produced.</p>\n<p>However, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1766\" rel=\"nofollow\">CWG issue 1766</a> recognized that the C++14 text was defective and has replaced it with the following:</p>\n<blockquote>\n<p id=\"so_33607284_33607345_1\">A value of integral or enumeration type can be explicitly converted to a complete enumeration type. The value is unchanged if the original value is within the range of the enumeration values (7.2). <strong>Otherwise, the behavior is undefined.</strong></p>\n</blockquote>\n<p>Therefore, in your specific case of exactly two enumerators with value <code>0</code> and <code>1</code>, no other value is possible unless the program has already triggered undefined behaviour, so the warning could be considered a false positive.</p>\n<hr>\n<p>To remove the warning, add a <code>default:</code> case that does something.  I'd also suggest, in the interest of defensive programming, that it's a good idea to have a default case anyway. In practice it may serve to 'contain' the undefined behaviour: if someone does happen to pass an invalid value then you can throw or abort cleanly.</p>\n<hr>\n<p><strong>NB:</strong> Regarding the warning itself: it's impossible for a compiler to <em>accurately</em> warn if and only if control flow would reach the end of a function , because this would require solving the halting problem. </p>\n<p>They tend to err on the side of caution: the compiler will warn if it is not completely sure, meaning that there are false positives.</p>\n<p>So the presence of this warning does not necessarily indicate that the executable would actually allow entry into the default path.</p>\n</hr></hr></hr>", "LastActivityDate": "2015-11-09T20:01:46.580"}});