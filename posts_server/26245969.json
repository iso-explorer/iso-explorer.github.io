post_cb({"26246189": {"ParentId": "26245969", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The code generated by the compiler does not necessarily <em>literally</em> reproduce C++ language constructs in machine code. Just because your C++ code has an <code>if</code> statement in it does not mean that machine code will be based on a branching instruction. Modern compilers are not required to and do not literally implement the behavior of the abstract C++ machine in the generated machine code.</p>\n<p>For this reason it is impossible to say whether it will be faster or not. C++ code does not have any inherent \"speed\" associated with it. C++ code is never executed directly. It can't be \"faster\" or \"slower\" from the abstract point of view. If you want to analyze the performance of the code by looking at it, you have to look at the machine code generated by your compiler, not at C++ code. But an even better method would be to try both variants and profile them by actually running them on various kinds of typical input data.</p>\n<p>It is quite possible that a smart compiler will generate identical code for both of your variants.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2014-10-08T01:19:20.683", "Id": "26246189", "Score": "4", "CreationDate": "2014-10-07T22:16:06.027", "LastActivityDate": "2014-10-08T01:19:20.683"}, "26246006": {"ParentId": "26245969", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Technically it would, but keep in mind that all values great than <code>0</code> evaluate to <code>true</code>. So the called function might return a value other than <code>1</code>, which would skew the result. Also, the compiler has means to optimize the branch away into a conditional move.</p>\n<p>To expand, there are certainly ways to optimize the branch away in code, but this reduces readability and maintainability as well as the ability to debug the code by eg. placing breakpoints down, and gaining very little since compilers are pretty damn good at optimzing these things on their own.</p>\n", "OwnerUserId": "350272", "LastEditorUserId": "350272", "LastEditDate": "2014-10-07T22:09:30.187", "Id": "26246006", "Score": "6", "CreationDate": "2014-10-07T21:58:53.270", "LastActivityDate": "2014-10-07T22:09:30.187"}, "26246286": {"ParentId": "26245969", "CommentCount": "1", "Body": "<p>So, first, your suggested code is different. So let's look at two equivalent codes:</p>\n<pre><code>template&lt;typename _InputIterator, typename _Predicate&gt;\ntypename iterator_traits&lt;_InputIterator&gt;::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {\n    typename iterator_traits&lt;_InputIterator&gt;::difference_type __n = 0;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__n;\n    return __n;\n}\n</code></pre>\n<p>And:</p>\n<pre><code>template&lt;typename _InputIterator, typename _Predicate&gt;\ntypename iterator_traits&lt;_InputIterator&gt;::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {\n    typename iterator_traits&lt;_InputIterator&gt;::difference_type __n = 0;\n    for (; __first != __last; ++__first)\n        __n += (bool) __pred(*__first);\n    return __n;\n}\n</code></pre>\n<p>Then, we can compile this with our compiler and look at the assembly. Under one compiler that I tried (clang on os x), these produced <strong>identical code</strong>.</p>\n<p>Perhaps your compiler will also produce identical code, or perhaps it might produce different code. </p>\n", "OwnerUserId": "47453", "PostTypeId": "2", "Id": "26246286", "Score": "10", "CreationDate": "2014-10-07T22:24:56.183", "LastActivityDate": "2014-10-07T22:24:56.183"}, "26246172": {"ParentId": "26245969", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The replacement you gave <strong>is not</strong> equivalent, because there are far fewer restrictions on a predicate than you think:</p>\n<ul>\n<li>Anything which can be used in a conditional context (can be contextually converted to <code>bool</code>), is a valid return-type for the predicate (an <code>explicit</code> conversion to <code>bool</code> is enough).</li>\n<li>That return-type can react funny to being added to the iterators difference-type.</li>\n</ul>\n<blockquote>\n<h2>25 Algorithms library <code>[algorithms]</code></h2>\n<h3>25.1 General <code>[algorithms.general]</code></h3>\n<p id=\"so_26245969_26246172_0\">8 The <code>Predicate</code> parameter is used whenever an algorithm expects a function object (20.9) that, when applied to the result of dereferencing the corresponding iterator, returns a value testable as <code>true</code>. In other words, if an algorithm takes <code>Predicate pred</code> as its argument and <code>first</code> as its iterator argument, it <strong>should work correctly in the construct <code>pred(*first)</code> contextually converted to <code>bool</code></strong> <sub>(Clause 4)</sub>. The function object <code>pred</code> shall not apply any non-constant function through the dereferenced iterator.</p>\n</blockquote>\n<p>The most likely return giving your replacement indigestion would be a standard integer-type, and a value neither 0 nor 1.</p>\n<p>Also, keep in mind that compilers can actually optimize really good nowadays (and especially C++ ones need to, with all that template-stuff layered deep).</p>\n", "OwnerUserId": "3204551", "LastEditorUserId": "3204551", "LastEditDate": "2014-10-07T22:20:14.973", "Id": "26246172", "Score": "13", "CreationDate": "2014-10-07T22:14:34.280", "LastActivityDate": "2014-10-07T22:20:14.973"}, "bq_ids": {"n4140": {"so_26245969_26246172_0": {"section_id": 1241, "quality": 0.9387755102040817, "length": 46}}, "n3337": {"so_26245969_26246172_0": {"section_id": 1239, "quality": 0.9387755102040817, "length": 46}}, "n4659": {"so_26245969_26246172_0": {"section_id": 1329, "quality": 0.9387755102040817, "length": 46}}}, "26245969": {"CommentCount": "11", "ViewCount": "901", "CreationDate": "2014-10-07T21:56:24.757", "LastActivityDate": "2014-10-08T01:19:20.683", "Title": "Would std::count_if be faster without an if?", "AcceptedAnswerId": "26246172", "PostTypeId": "1", "Id": "26245969", "Score": "9", "Body": "<p>Here's the gcc <code>std::count_if</code> code</p>\n<pre><code>template&lt;typename _InputIterator, typename _Predicate&gt;\n  typename iterator_traits&lt;_InputIterator&gt;::difference_type\n  count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n {\n  [snip]\n  typename iterator_traits&lt;_InputIterator&gt;::difference_type __n = 0;\n  for (; __first != __last; ++__first)\n    if (__pred(*__first))\n      ++__n;\n  return __n;\n}\n</code></pre>\n<p>My question: would it work better (i.e., faster) to use</p>\n<pre><code>__n += __pred(*__first); // instead of the if statement\n</code></pre>\n<p>This version always does an add, but doesn't do a branch.</p>\n", "Tags": "<c++><performance><gcc><stl>", "OwnerUserId": "717898", "AnswerCount": "4"}});