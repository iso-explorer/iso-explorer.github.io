post_cb({"bq_ids": {"n4140": {"so_22666697_22668909_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 526}}, "n3337": {"so_22666697_22668909_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 517}}, "n4659": {"so_22666697_22668909_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 547}}}, "22668909": {"Id": "22668909", "PostTypeId": "2", "Body": "<p>It's not possible to preserve newlines in the way you want, because the stringise operator explicitly discards them. There's no way to access them in any previous translation phase, and there's no way to recover them in a later one.</p>\n<blockquote>\n<p id=\"so_22666697_22668909_0\">[cpp.stringize]\u00b62 [...] Each occurrence of white space between the argument\u2019s preprocessing tokens becomes a single space character in the character string literal. White space before the first preprocessing token and after the last preprocessing token comprising the argument is deleted. [...]</p>\n</blockquote>\n<p>You might be able to write a <code>constexpr</code> function that builds up a modified string literal by inventing newlines according to some heuristic, but you can never recover the original newlines.</p>\n", "LastActivityDate": "2014-03-26T17:38:06.810", "CommentCount": "0", "CreationDate": "2014-03-26T17:38:06.810", "ParentId": "22666697", "Score": "1", "OwnerUserId": "46642"}, "22668115": {"Id": "22668115", "PostTypeId": "2", "Body": "<p>It's not exactly what you asking for, but as <strong>@R. Martinho Fernandes</strong> suggested you can use raw literals:</p>\n<pre><code>const char *ptr = R\"(\ntext\nhere\n)\"\n</code></pre>\n", "LastActivityDate": "2014-03-26T17:02:39.150", "CommentCount": "1", "CreationDate": "2014-03-26T17:02:39.150", "ParentId": "22666697", "Score": "2", "OwnerUserId": "2752075"}, "22666697": {"ViewCount": "652", "Body": "<p>In the code that I am working on has the macro</p>\n<pre><code>#define STRINGIFY(...) #__VA_ARGS__\n</code></pre>\n<p>is defined.</p>\n<p>This does have the disadvantage that it ignores newlines.</p>\n<p>I would therefore like to define a macro that uses the new <code>R\"literal( ... )literal\"</code> format.</p>\n<p>Given that the macro form already exists, I would like to preserve the use of the <code>STRINGIFY</code> macro</p>\n<p>However given that there are quotes involved, how would you define <code>STRINGIFY</code> to use the new string literal format? </p>\n<p>Also is there anyway to preserve <code>#ifdef</code>s in the <code>STRINGIFY</code> macro?</p>\n<p><strong>Edit</strong> I want a define <strong>macro</strong> that will translate into <code>R\"literal(...)literal\"</code> in C++11</p>\n<p><strong>Edit2</strong>\nThe closest I have been able to get is:</p>\n<pre><code>#define STRINGIFY1(a) #a \n#define STRINGIFY(str) R STRINGIFY1(lit(str)lit) \n</code></pre>\n<p>This puts all the right things in the right place does condense the block into a single line. I am starting to think that macros cannot be used here.</p>\n", "Title": "Stringifying a block of text in C++11", "CreationDate": "2014-03-26T16:02:46.113", "LastActivityDate": "2014-03-27T11:54:22.987", "CommentCount": "12", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-03-27T11:54:22.987", "LastEditorUserId": "232918", "Id": "22666697", "Score": "1", "OwnerUserId": "232918", "Tags": "<c++><c++11><macros>", "AnswerCount": "2"}});