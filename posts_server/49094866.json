post_cb({"49202762": {"PostTypeId": "2", "Body": "<ol>\n<li>C++03 said that the lvalue-to-rvalue conversion doesn't happen for the result of an expression statement, and doesn't explicitly say that a copy occurs when the conversion happens anyway.</li>\n<li>C++11 says, as you stated, that the conversion does happen for volatile objects, and that the conversion involves copying to make a temporary.</li>\n<li>C++14 merely cleans up the wording (to avoid silly things like <code>b ? (x,y) : z</code> not counting if <code>y</code> does) and adds the note about the volatile copy constructor.</li>\n<li>C++17 applies the temporary materialization conversion to preserve the previous meaning.</li>\n</ol>\n<p>So my conclusion is that (as of C++11) you are correct and all the compilers are wrong.  In particular, the <code>S::i</code> load shouldn't happen unless your copy constructor reads it.  The implementation-defined nature of \"access\" is irrelevant to the question of what is well-formed, of course; it only affects whether the load instruction for <code>ai</code> is actually generated.  There is the issue of <code>S_bad</code> being an aggregate, but that is irrelevant since it's not being list-initialized.</p>\n", "LastActivityDate": "2018-03-09T21:56:09.377", "Score": "2", "Id": "49202762", "CreationDate": "2018-03-09T21:56:09.377", "ParentId": "49094866", "CommentCount": "4", "OwnerUserId": "8586227"}, "bq_ids": {"n4140": {"so_49094866_49094866_0": {"length": 17, "quality": 0.6071428571428571, "section_id": 5944}}, "n4659": {"so_49094866_49094866_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 7429}}}, "49094866": {"ViewCount": "199", "LastEditDate": "2018-03-07T12:06:44.287", "Body": "<p>Consider this following piece of code:</p>\n<pre><code>struct S{\n  int i;\n  S(int);\n  S(const volatile S&amp;);\n  };\n\nstruct S_bad{\n  int i;\n  };\n\nvolatile S     as{0};\nvolatile S_bad as_bad{0};\nvolatile int   ai{0};\n\nvoid test(){\n   ai;     //(1)=&gt; a load is always performed\n   as;     //(2)=&gt; Should call the volatile copy constructor\n   as_bad; //(3)=&gt; Should be ill-formed\n   }\n</code></pre>\n<p>The expression <code>ai;</code>, <code>as;</code> and <code>as_bad</code> are discarded value expressions and according to the C++ draft standard <a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr#12\" rel=\"nofollow noreferrer\">N4659/[expr].12</a> I expected that an <a href=\"https://timsong-cpp.github.io/cppwp/n4659/conv.lval\" rel=\"nofollow noreferrer\">lvalue-to-rvalue</a> would have applied in these three cases. For case (2) this should cause a call to the volatile copy constructor (<code>S(const volatile S&amp;)</code>) <a href=\"https://timsong-cpp.github.io/cppwp/n4618/expr#12\" rel=\"nofollow noreferrer\">[expr]/12</a></p>\n<blockquote>\n<p id=\"so_49094866_49094866_0\">[...]If the expression is a prvalue after this optional conversion, the temporary materialization conversion ([conv.rval]) is applied. [ Note: If the expression is an lvalue of class type, it must have a volatile copy constructor to initialize the temporary that is the result object of the lvalue-to-rvalue conversion.  \u2014 end note ] </p>\n</blockquote>\n<p>So the case (3) should be ill-formed.</p>\n<p>Nevertheless, the behavior of compilers seems chaotic:</p>\n<ol>\n<li><p>GCC:</p>\n<ul>\n<li><code>ai;</code> =&gt; loads the value of <code>ai</code>;</li>\n<li><code>as;</code> =&gt; no code generated, no warning;</li>\n<li><code>as_bad;</code> =&gt; loads <code>as_bad.i</code>.</li>\n</ul></li>\n<li><p>Clang does not produce a load for case (2) and generates the warning: <em>expression result unused; assign into a variable to force a volatile load [-Wunused-volatile-lvalue]</em></p>\n<ul>\n<li><code>ai;</code> =&gt; loads the value of <code>ai</code>;</li>\n<li><code>as;</code> =&gt; no code generated; warning <em>expression result unused; assign into a variable to force a volatile load [-Wunused-volatile-lvalue]</em></li>\n<li><code>as_bad;</code> =&gt; same as <code>as;</code>.</li>\n</ul></li>\n<li><p>MSVC performs the load in both cases.</p>\n<ul>\n<li><code>ai;</code> =&gt; loads the value of <code>ai</code>;</li>\n<li><code>as;</code> =&gt; loads <code>as.i</code> (without calling to the volatile copy constructor)</li>\n<li><code>as_bad;</code> =&gt; loads <code>as_bad.i</code>.</li>\n</ul></li>\n</ol>\n<p>Summary of what I expected according to the standard:</p>\n<ul>\n<li><code>ai;</code> =&gt; loads the value of <code>ai</code>;</li>\n<li><code>as;</code> =&gt; call <code>S(const volatile S&amp;)</code> with <code>as</code> as argument;</li>\n<li><code>as_bad;</code> =&gt; generate a compilation error</li>\n</ul>\n<p>Is my interpretation of the standard right? Which compiler is right if any?</p>\n", "Title": "Discarded value expressions of volatile class type behave differently than those of volatile built-in types", "CreationDate": "2018-03-04T11:26:42.653", "LastActivityDate": "2018-03-09T21:56:09.377", "CommentCount": "18", "FavoriteCount": "3", "PostTypeId": "1", "LastEditorUserId": "5632316", "Id": "49094866", "Score": "10", "OwnerUserId": "5632316", "Tags": "<c++><language-lawyer><volatile>", "AnswerCount": "1"}});