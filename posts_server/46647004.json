post_cb({"46647004": {"ViewCount": "438", "Body": "<p>I have a <code>std::shared_ptr</code> with a custom deleter and in that deleter, I would like to take a temporary copy of the original <code>std::shared_ptr</code>. Expressed in code form:</p>\n<pre><code>struct Foo : public std::enable_shared_from_this&lt;Foo&gt;\n{};\n\nvoid deleter(Foo *f)\n{\n  {\n    std::shared_ptr&lt;Foo&gt; tmp = f-&gt;shared_from_this(); // Line A\n  }\n  delete f;\n}\n\nint main()\n{\n  std::shared_ptr&lt;Foo&gt; foo(new Foo, &amp;deleter);\n}\n</code></pre>\n<p>My question is: on line <em>A</em>, can anything be said about the call of <code>shared_from_this()</code>? Is it legal? If so, does the standard say anything about its return value? If we replace <code>enable_shared_from_this</code> with a different <code>weak_ptr</code> or global reference to <code>foo</code>, will the answer be the same?</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/6872a321b79a2e26\" rel=\"noreferrer\">Clang</a> with libc++ and <a href=\"http://coliru.stacked-crooked.com/a/2aa925bd1f20bd42\" rel=\"noreferrer\">gcc</a> with libstdc++ both produce code which terminates on a <code>bad_weak_ptr</code> exception, but I can't seem to trace this as <em>required</em> by the standard. Is this implementation-specific, or am I missing a rule?</p>\n<p>All the relevant rules I found (quoting C++11):</p>\n<blockquote>\n<p id=\"so_46647004_46647004_0\"><strong>20.7.2.2.2 <code>shared_ptr</code> destructor</strong></p>\n<p id=\"so_46647004_46647004_1\">1 ... if <code>*this</code> <em>owns</em> an object <code>p</code> and a deleter <code>d</code>, <code>d(p)</code> is called<br>\n  2 [<em>Note:</em> ... Since the destruction of <code>*this</code> decreases the number of instances that share ownership with <code>*this</code>\n  by one, after <code>*this</code> has been destroyed all <code>shared_ptr</code> instances that shared ownership with <code>*this</code> will\n  report a <code>use_count()</code> that is one less than its previous value. <em>\u2014end note</em>]</br></p>\n<p id=\"so_46647004_46647004_2\"><strong>20.7.2.2.5 <code>shared_ptr</code> observers</strong></p>\n<p id=\"so_46647004_46647004_3\">7 <code>use_count</code> <em>Returns:</em> the number of <code>shared_ptr</code> objects, <code>*this</code> included, that share ownership with <code>*this</code>, or 0\n  when <code>*this</code> is empty.</p>\n</blockquote>\n<p>To me, it seems it's not clear whether the decrement of <code>use_count</code> happens before or after the call of the deleter. Is getting <code>bad_weak_ptr</code> a reliable result, or is this simply unspecified?</p>\n<p>Note that I am intentionally avoiding a situation where a pointer like <code>tmp</code> in my example code would outlive the deleter execution.</p>\n", "Title": "Does shared_ptr still own its object when calling the deleter?", "CreationDate": "2017-10-09T12:53:35.413", "LastActivityDate": "2017-10-15T04:32:45.713", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-10-15T04:32:45.713", "LastEditorUserId": "963864", "Id": "46647004", "Score": "11", "OwnerUserId": "1782465", "Tags": "<c++><language-lawyer><destructor><shared-ptr><weak-ptr>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46647004_46647212_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 4503}, "so_46647004_46647004_3": {"length": 6, "quality": 0.6, "section_id": 4432}, "so_46647004_46647212_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 411}, "so_46647004_46647004_1": {"length": 25, "quality": 0.78125, "section_id": 4413}}, "n3337": {"so_46647004_46647212_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 4334}, "so_46647004_46647212_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 402}, "so_46647004_46647004_3": {"length": 6, "quality": 0.6, "section_id": 4269}, "so_46647004_46647004_1": {"length": 25, "quality": 0.78125, "section_id": 4250}}, "n4659": {"so_46647004_46647004_3": {"length": 8, "quality": 0.8, "section_id": 5696}, "so_46647004_46647212_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 429}, "so_46647004_46647004_1": {"length": 25, "quality": 0.78125, "section_id": 5672}}}, "46647212": {"Id": "46647212", "PostTypeId": "2", "Body": "<p>consider</p>\n<blockquote>\n<p id=\"so_46647004_46647212_0\">[c++14-12.4-15]Once a destructor is invoked for an object, the object no longer exists;</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_46647004_46647212_1\">[c++14-20.8.2.4-7]<strong>shared_from_this</strong>()[...]Requires: enable_shared_from_this shall be an accessible base class of T. *this shall be a subobject of an object t of type T. <strong>There shall be at least one shared_ptr instance p that owns &amp;t</strong>.</p>\n</blockquote>\n<p>so, considering that the deleter is invoked by the shared_ptr destructor, calling shared_from_this() in the deleter of the last shared_ptr owning it results in undefined behaviour.</p>\n<p>EDIT: as pointed out by YSC, in <strong>C++17</strong> shared_from_this() is required to behave as the corresponding weak_ptr conversion call. This complicates matters though, because it's not clear what weak_ptr::expired() should return at deleter call ... anyway, taking the quoted <code>20.7.2.2.2</code> note literally, a bad_weak_ptr should be raised in this case.</p>\n", "LastEditorUserId": "8631381", "LastActivityDate": "2017-10-09T13:40:19.957", "Score": "13", "CreationDate": "2017-10-09T13:04:26.777", "ParentId": "46647004", "CommentCount": "8", "OwnerUserId": "8631381", "LastEditDate": "2017-10-09T13:40:19.957"}});