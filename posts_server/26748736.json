post_cb({"bq_ids": {"n4140": {"so_26748736_26748772_0": {"length": 38, "quality": 0.95, "section_id": 5965}}, "n3337": {"so_26748736_26748772_0": {"length": 38, "quality": 0.95, "section_id": 5734}}, "n4659": {"so_26748736_26748772_0": {"length": 34, "quality": 0.85, "section_id": 7456}}}, "26748792": {"Id": "26748792", "PostTypeId": "2", "Body": "<p>Each lambda expression returns an object with a distinct type. If the lambda expression does <em>not</em> capture any variables, it can be converted to a a function pointer type of an appropriate signature (i.e., the return type and the arguments need to agree with those of the lambda expression). When there is a variable captured, the entity created can't be represented by a plain function. Instead, the lambda expression yields an object of class type with a function call operator. That is, your second code uses a lambda expression yielding an object of a class which is roughly equivalent to this:</p>\n<pre><code>class lambda {\n     int n;\npublic:\n     lambda(int n): n(n) {}\n     double operator()(double x) const { return x + n; }\n};\n</code></pre>\n", "LastActivityDate": "2014-11-05T02:32:31.083", "CommentCount": "0", "CreationDate": "2014-11-05T02:32:31.083", "ParentId": "26748736", "Score": "2", "OwnerUserId": "1120273"}, "26748772": {"Id": "26748772", "PostTypeId": "2", "Body": "<p>A lambda is convertable to a function pointer only if it does not have a capture, we can see this by going to the draft standard section <code>5.1.2</code> <em>Lambda expressions</em> which says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_26748736_26748772_0\">The closure type for a lambda-expression <strong>with no lambda-capture</strong> has a\n  public non-virtual non-explicit const <strong>conversion function to pointer\n  to function</strong> having the same parameter and return types as the closure\n  type\u2019s function call operator. The value returned by this conversion\n  function shall be the address of a function that, when invoked, has\n  the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>This is an alternative solution which does not rely on this conversion:</p>\n<pre><code>template &lt;typename Callable&gt;\ndouble applyFunc(Callable f, double x)\n{\n    return f(x);\n}\n</code></pre>\n<p><b>Update</b></p>\n<p>If you are interested in the difference between using <code>std::function</code> and templates then you should read <a href=\"https://stackoverflow.com/q/14677997/1708801\">std::function vs template</a>. There are many good answers there and a lot of food for thought. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-06T16:17:04.867", "Score": "4", "CreationDate": "2014-11-05T02:29:47.243", "ParentId": "26748736", "CommentCount": "2", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T10:24:15.557"}, "26748736": {"ViewCount": "127", "Body": "<p>I am trying to learn lambdas in C++, but stumbled on something I can't quite understand.</p>\n<p>Here is code: </p>\n<pre><code>#include &lt;iostream&gt;\n\ntypedef double Func(double); \n\ndouble applyFunc(Func f, double x)\n{\n    return f(x);\n}\n\nint main()\n{\n    std::cout &lt;&lt; applyFunc([](double x) {return x + 1;}, 3) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Now this works just fine (prints \"4\"), i.e. type of the lambda expression used is exactly <code>double (*)(double)</code>.</p>\n<p>But if I add closure to the lambda expression, like:</p>\n<pre><code>int main()\n{\n    int n = 5;\n    std::cout &lt;&lt; applyFunc([n](double x) {return x + n;}, 3) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Then I get an error from the compiler:</p>\n<pre><code>In function \u2018int main()\u2019:\nerror: cannot convert \u2018main()::__lambda0\u2019 to \u2018double (*)(double)\u2019 for argument \u20181\u2019 to \u2018double applyFunc(double (*)(double), double)\u2019\n  3) &lt;&lt; std::endl;\n   ^\n</code></pre>\n<p>And I don't understand why is that. I mean, from the point of view of <code>applyFunc()</code> it still receives a pointer to a function taking <code>double</code> argument and returning <code>double</code>, and it doesn't know that we used variable 'n' from context, so the type of lambda expression should be the same, as in the first example, right?</p>\n<p>I would very appreciate help, thank you in advance!</p>\n", "AcceptedAnswerId": "26748772", "Title": "Type of lambdas in C++", "CreationDate": "2014-11-05T02:25:19.237", "Id": "26748736", "CommentCount": "6", "LastEditDate": "2014-11-05T10:26:48.847", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2014-11-06T16:17:04.867", "Score": "2", "OwnerUserId": "3449402", "Tags": "<c++><lambda>", "AnswerCount": "2"}});