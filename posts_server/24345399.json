post_cb({"24346350": {"ParentId": "24345399", "CommentCount": "0", "Body": "<p>This is gcc bug <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57891\">57891</a>. Conversion of the integral constant <code>42</code> to <code>bool</code> involves a narrowing conversion, which is not allowed in non-type template arguments. Hence the <code>enable_if</code> is ill-formed, and the <code>pick</code> specialization should be discarded, as clang correctly does.</p>\n<p><em>\u00a714.3.2/5 [temp.arg.nontype]</em></p>\n<blockquote>\n<p id=\"so_24345399_24346350_0\">The following conversions are performed on each expression used as a\n  non-type <em>template-argument</em>. If a non-type <em>template-argument</em> cannot be\n  converted to the type of the corresponding <em>template-parameter</em> then the\n  program is ill-formed.<br/> \n  \u2014 For a non-type <em>template-parameter</em> of\n  integral or enumeration type, <strong>conversions permitted in a converted\n  constant expression</strong> (5.19) are applied.<br/>\n<code>...</code></p>\n</blockquote>\n<p><em>\u00a75.19/3 [expr.const]</em></p>\n<blockquote>\n<p id=\"so_24345399_24346350_1\"><code>...</code> A <strong>converted constant expression</strong> of type <code>T</code> is an expression, implicitly converted to a prvalue of type <code>T</code>, where the converted expression is a core\n  constant expression and the implicit conversion sequence contains only user-defined conversions, lvalue-to-rvalue conversions (4.1), integral promotions (4.5), and <strong>integral conversions</strong> (4.7) <strong>other than narrowing conversions</strong> (8.5.4).</p>\n</blockquote>\n<p><em>\u00a78.5.4/7 [dcl.init.list]</em></p>\n<blockquote>\n<p id=\"so_24345399_24346350_2\">A <em>narrowing conversion</em> is an implicit conversion<br/>\n<code>...</code><br/>\n  \u2014 from an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, except where the source is a constant expression whose value after integral promotions will fit into the target type.</p>\n</blockquote>\n<hr>\n<p>This <a href=\"http://coliru.stacked-crooked.com/a/2a3bd2cd7fc52ef7\">minimal example</a> demonstrates the gcc bug:</p>\n<pre><code>template&lt;bool&gt;\nstruct foo{};\nfoo&lt;10&gt; f;\n\nint main() {}\n</code></pre>\n<p>gcc-4.9 accepts the code while clang-3.4 rejects it with the following error:</p>\n<blockquote>\n<p id=\"so_24345399_24346350_3\">error: non-type template argument evaluates to 10, which cannot be narrowed to type 'bool' [-Wc++11-narrowing]</p>\n<pre><code> foo&lt;10&gt; f;\n     ^\n</code></pre>\n</blockquote>\n<hr>\n<p>The fix to your particular problem is easy. Make sure the non-type template argument to <code>enable_if</code> evaluates to a <code>bool</code></p>\n<pre><code>template&lt;class T&gt;\nstruct pick&lt;T, typename std::enable_if&lt; is_nice&lt;T&gt;::value != 0 &gt;::type &gt;\n//                                                       ^^^^^^\n{\n    typedef std::integral_constant&lt;int, is_nice&lt;T&gt;::value &gt; type;\n};\n</code></pre>\n</hr></hr>", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "24346350", "Score": "9", "CreationDate": "2014-06-21T22:17:08.117", "LastActivityDate": "2014-06-21T22:17:08.117"}, "24345399": {"CommentCount": "3", "ViewCount": "307", "PostTypeId": "1", "LastEditorUserId": "666785", "CreationDate": "2014-06-21T20:03:28.590", "LastActivityDate": "2014-06-21T22:17:08.117", "Title": "Narrowing int to bool in SFINAE, different output between gcc and clang", "AcceptedAnswerId": "24346350", "LastEditDate": "2014-06-21T20:13:39.793", "Id": "24345399", "Score": "10", "Body": "<p>Consider the following example:</p>\n<pre><code>template&lt;int i&gt;\nstruct nice_type;\n\ntemplate&lt;class T&gt;\nstruct is_nice : std::false_type {};\n\ntemplate&lt;int i&gt;\nstruct is_nice&lt; nice_type&lt;i&gt; &gt; : std::integral_constant&lt;int, i&gt; {};\n\ntemplate&lt;class T, class = void&gt;\nstruct pick\n{\n    typedef std::integral_constant&lt;int, -1&gt; type;\n};\n\ntemplate&lt;class T&gt;\nstruct pick&lt;T, typename std::enable_if&lt; is_nice&lt;T&gt;::value &gt;::type &gt;\n{\n    typedef std::integral_constant&lt;int, is_nice&lt;T&gt;::value &gt; type;\n};\n\nint main()\n{\n    std::cout &lt;&lt; pick&lt;int&gt;::type::value &lt;&lt; \", \";\n    std::cout &lt;&lt; pick&lt; nice_type&lt;42&gt; &gt;::type::value &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Clang (3.4.1) outputs \"-1, -1\", while GCC(4.9.0) outputs \"-1, 42\". </p>\n<p>The problem lays in the specialization of <code>pick</code>. While Gcc seems happy to convert <code>is_nice&lt;T&gt;::value</code> (42) to <code>bool(true)</code>, clang does not do so, and discards the specialization. Both examples compiled with <code>-std=c++11</code>.</p>\n<p>Which compiler is right?</p>\n", "Tags": "<c++><gcc><c++11><clang><sfinae>", "OwnerUserId": "666785", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24345399_24346350_1": {"section_id": 6186, "quality": 0.96875, "length": 31}, "so_24345399_24346350_0": {"section_id": 91, "quality": 0.9, "length": 27}, "so_24345399_24346350_2": {"section_id": 3329, "quality": 0.96875, "length": 31}}, "n3337": {"so_24345399_24346350_1": {"section_id": 5947, "quality": 0.8125, "length": 26}, "so_24345399_24346350_0": {"section_id": 86, "quality": 0.9, "length": 27}, "so_24345399_24346350_2": {"section_id": 3199, "quality": 0.875, "length": 28}}, "n4659": {"so_24345399_24346350_2": {"section_id": 4095, "quality": 0.96875, "length": 31}, "so_24345399_24346350_1": {"section_id": 7689, "quality": 0.84375, "length": 27}}}});