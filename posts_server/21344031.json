post_cb({"bq_ids": {"n4140": {"so_21344031_21344184_0": {"length": 52, "quality": 0.8125, "section_id": 5908}}, "n3337": {"so_21344031_21344184_0": {"length": 52, "quality": 0.8125, "section_id": 5680}}}, "21344031": {"ViewCount": "391", "Body": "<p>I am working on a project, and it seems that clang is unable to generate a valid bytecode (as the linker fail to link, some <code>static constexpr</code> in a template class is not found at link time)\nI can fix it with a static getter in the class, but this lead to some really ugly/overloaded code.</p>\n<p>Here is a \"minimal\" sample of code that makes the <em>bug</em> (is it a bug ?) appear.\nUnfortunately, here, g++ will produce the same link error.</p>\n<p>I'm asking if this is a compiler bug, or I am simply doing something wrong, and if there's a solution to avoid this error.\n(And if I am doing something wrong, <em>why</em> the <em>same</em> construct works in my bigger project ??)</p>\n<p><em><strong>NOTE</strong>: The bigger project is named <code>yaggler</code> on github, but is still at the early beginning of its life</em></p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n\n// exemple vector classes\nstruct vector2\n{\n  constexpr vector2(unsigned int _x = 0, unsigned int _y = 0) : x(_x), y(_y) {} // for clang\n\n  unsigned int x;\n  unsigned int y;\n};\nstruct vector3 : public vector2 // uh ;)\n{\n  constexpr vector3(unsigned int _x = 0, unsigned int _y = 0, unsigned int _z = 0) : vector2(_x, _y), z(_z) {} // for clang\n  unsigned int z;\n};\n\n// simple templated generic vector type\n// we could make a more generic one, but this would require something like a tuple.\ntemplate&lt;unsigned int... Vals&gt;\nstruct vector\n{\n    static_assert(!(sizeof...(Vals) + 1), \"[...]\");\n};\ntemplate&lt;unsigned int X&gt;\nstruct vector&lt;X&gt;\n{\n  using vec_type = unsigned int;\n  static constexpr unsigned int value = X;\n};\ntemplate&lt;unsigned int X, unsigned int Y&gt;\nstruct vector&lt;X, Y&gt;\n{\n  using vec_type = vector2;\n  static constexpr vector2 value = vector2(X, Y);\n};\ntemplate&lt;unsigned int X, unsigned int Y, unsigned int Z&gt;\nstruct vector&lt;X, Y, Z&gt;\n{\n  using vec_type = vector3;\n  static constexpr vector3 value = vector3(X, Y, Z);\n};\n\n// a simple wrapper\ntemplate&lt;typename V&gt;\nstruct some_wrapper\n{\n  static constexpr typename V::vec_type value = V::value;\n};\n\n// a dummy function that print something to stdout.\nvoid do_something(int32_t id, const vector3 &amp;value)\n{\n  std::cout &lt;&lt; id &lt;&lt; \" \" &lt;&lt; value.z &lt;&lt; std::endl;\n}\nvoid do_something(int32_t id, const vector2 &amp;value)\n{\n  std::cout &lt;&lt; id &lt;&lt; \" \" &lt;&lt; value.y &lt;&lt; std::endl;\n}\nvoid do_something(int32_t id, int value)\n{\n  std::cout &lt;&lt; id &lt;&lt; \" \" &lt;&lt; value &lt;&lt; std::endl;\n}\n\n// the class used to create the error\ntemplate&lt; typename... Args&gt;\nclass exemple\n{\n  private:\n    // an initialisation that recurse over the Args... template arguments\n    template&lt;typename Current, typename... Others&gt;\n    void __rec_init() const\n    {\n      do_something(0, Current::value);\n      __rec_init&lt;Others...&gt;();\n    }\n\n    // end of recursion\n    template&lt;size_t = 0&gt;\n    void __rec_init() const {}\n\n    // launch the recursion\n    void tpl_init() const\n    {\n      __rec_init&lt;Args...&gt;();\n    }\n\n  public:\n    exemple()\n    {\n      tpl_init();\n    }\n};\n\nint main()\n{\n  // and here, we get a linker error.\n  exemple&lt;some_wrapper&lt;vector&lt;4, 4, 5&gt;&gt;, some_wrapper&lt;vector&lt;4, 1&gt;&gt;, some_wrapper&lt;vector&lt;9&gt;&gt;&gt;();\n}\n</code></pre>\n<p><strong>EDIT</strong>: just to mention gcc and clang versions: gcc 4.7.3/4.8.2 and clang 3.2/3.3 </p>\n", "AcceptedAnswerId": "21344184", "Title": "link error while compiling this \"simple\" program with clang and g++", "CreationDate": "2014-01-24T22:58:16.810", "Id": "21344031", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-01-24T23:25:25.350", "Score": "2", "OwnerUserId": "1457433", "Tags": "<c++><c++11><g++><constexpr><clang++>", "AnswerCount": "1"}, "21344184": {"PostTypeId": "2", "Body": "<p>The specializations of <code>vector</code> class template for 2 and 3 template arguments have got <code>static constexpr</code> data member <code>value</code> of literal type (<code>vector2</code> and <code>vector3</code>, respectively) that don't have namespace scope definitions.</p>\n<p>You'll need them because you odr-use <code>value</code> when it binds to the reference parameter when passed to <code>do_something</code> function.</p>\n<p><strong>\u00a79.4.2/3 [class.static.mfct]</strong></p>\n<blockquote>\n<p id=\"so_21344031_21344184_0\">If a non-volatile <code>const static</code> data member is of integral or enumeration type, its declaration in the class\n  de\ufb01nition can specify a <code>brace-or-equal-initializer</code> in which every <code>initializer-clause</code> that is an <code>assignment-\n  expression</code> is a constant expression (5.19). A <code>static</code> data member of literal type can be declared in the\n  class de\ufb01nition with the <code>constexpr</code> speci\ufb01er; if so, its declaration shall specify a <code>brace-or-equal-initializer</code>\n  in which every <code>initializer-clause</code> that is an <code>assignment-expression</code> is a constant expression. [Note: In both\n  these cases, the member may appear in constant expressions. \u2014end note ] <strong>The member shall still be de\ufb01ned\n  in a namespace scope if it is odr-used (3.2) in the program and the namespace scope de\ufb01nition shall not\n  contain an initializer.</strong></p>\n</blockquote>\n<p>EDIT: Correcting myself, it's actualy <code>some_wrapper&lt;T&gt;::value</code> that needs this definition (for the reason mentioned above, nonetheless). So what you need is this in namespace scope after the definition of <code>some_wrapper</code>:</p>\n<pre><code>template&lt;typename V&gt;\nconstexpr typename V::vec_type some_wrapper&lt;V&gt;::value;\n</code></pre>\n<p>After that, your code <a href=\"http://coliru.stacked-crooked.com/a/5713511c14e79e32\" rel=\"nofollow\"><strong>compiles and runs</strong></a>.</p>\n", "LastActivityDate": "2014-01-24T23:25:25.350", "LastEditorUserId": "947836", "Id": "21344184", "CommentCount": "1", "CreationDate": "2014-01-24T23:11:39.397", "ParentId": "21344031", "Score": "2", "OwnerUserId": "947836", "LastEditDate": "2014-01-24T23:25:25.350"}});