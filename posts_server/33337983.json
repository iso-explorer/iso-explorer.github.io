post_cb({"33338281": {"Id": "33338281", "PostTypeId": "2", "Body": "<p>It looks like you are running into an interesting corner case with decltype, this is covered in the clang bug report <a href=\"https://llvm.org/bugs/show_bug.cgi?id=13517\" rel=\"nofollow\"> Static constexpr definitions used inside template</a> which has the following example with a similar error as yours:</p>\n<blockquote>\n<p id=\"so_33337983_33338281_0\">This compiles fine, but when I make the class A, a template like this:</p>\n<pre><code>struct L\n{\n    void operator()() const\n    {}\n};\n\ntemplate&lt;class X&gt;\nstruct A\n{\n    static constexpr auto F = L();\n};\n\ntemplate&lt;class X&gt;\nconstexpr decltype(A&lt;X&gt;::F) A&lt;X&gt;::F;\n\nint main()\n{\n    A&lt;void&gt;::F();\n    return 0;\n}\n</code></pre>\n<p id=\"so_33337983_33338281_1\">Clang crashes, if I change the definition line for F to this:</p>\n<pre><code>template&lt;class X&gt;\nconstexpr typename std::remove_const&lt;decltype(A&lt;X&gt;::F)&gt;::type A&lt;X&gt;::F;\n</code></pre>\n<p id=\"so_33337983_33338281_2\">Then clang produces this error:</p>\n<pre><code>error: redefinition of 'F' with a different type\nconstexpr typename std::remove_const&lt;decltype(A&lt;X&gt;::F)&gt;::type A&lt;X&gt;::F;\n                                                                    ^\nnote: previous definition is here\n    static constexpr auto F = L();\n                          ^\n</code></pre>\n</blockquote>\n<p>and Richard Smith's reply was as follows:</p>\n<blockquote>\n<p id=\"so_33337983_33338281_3\">This error is correct. 'constexpr' and 'auto' are red herrings here.\n  Reduced testcase:</p>\n<pre><code>template&lt;class X&gt; struct A { static int F; };\ntemplate&lt;class X&gt; decltype(A&lt;X&gt;::F) A&lt;X&gt;::F;\n</code></pre>\n<p id=\"so_33337983_33338281_4\">Per C++11 [temp.type]p2, \"If an expression e involves a template\n  parameter, decltype(e) denotes a unique dependent type.\" Therefore the\n  type of A::F does not match the type in the template.</p>\n</blockquote>\n<p>the full quote for that from the C++14 draft is as follows:</p>\n<blockquote>\n<p id=\"so_33337983_33338281_5\">If an expression e involves a template parameter, decltype(e) denotes\n  a unique dependent type. Two such decltype-specifiers refer to the\n  same type only if their expressions are equivalent (14.5.6.1). [ Note:\n  however, it may be aliased, e.g., by a typedef-name. \u2014end note ]</p>\n</blockquote>\n<p>The only obvious way I can see to get this work is:</p>\n<pre><code>template&lt;int n&gt;\nconstexpr decltype(make_tuple(2, \"test\", 3.4)) Test&lt;n&gt;::invoke;\n</code></pre>\n<p>No work around was offered in the bug report.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-05T21:05:38.960", "Score": "3", "CreationDate": "2015-10-26T04:01:57.637", "ParentId": "33337983", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2015-11-05T21:05:38.960"}, "bq_ids": {"n4140": {"so_33337983_33338281_5": {"length": 22, "quality": 0.8461538461538461, "section_id": 96}, "so_33337983_33338281_4": {"length": 10, "quality": 0.5555555555555556, "section_id": 96}}, "n3337": {"so_33337983_33338281_5": {"length": 22, "quality": 0.8461538461538461, "section_id": 91}, "so_33337983_33338281_4": {"length": 10, "quality": 0.5555555555555556, "section_id": 91}}, "n4659": {"so_33337983_33338281_5": {"length": 18, "quality": 0.6923076923076923, "section_id": 100}}}, "33337983": {"ViewCount": "308", "Body": "<p>I got some problem with a static constexpr member of a template struct. The code compiles but I get linking error. Here's what I'm trying to do:</p>\n<pre><code>template&lt;int n&gt;\nstruct Test {\n    static constexpr auto invoke = make_tuple(2, \"test\", 3.4);\n};\n\ntemplate&lt;typename T&gt;\nvoid test(T&amp;&amp; t) {\n    cout &lt;&lt; t &lt;&lt; endl;\n}\n\nint main() {\n    test(get&lt;0&gt;(Test&lt;2&gt;::invoke));\n    return 0;\n}\n</code></pre>\n<p>I got linking errors with that, so I tried this:</p>\n<pre><code>template&lt;int n&gt;\nstruct Test {\n    static constexpr auto invoke = make_tuple(2, \"test\", 3.4);\n};\n\n// declare it outside the class\ntemplate&lt;int n&gt;\nconstexpr decltype(Test&lt;n&gt;::invoke) Test&lt;n&gt;::invoke;\n\ntemplate&lt;typename T&gt;\nvoid test(T&amp;&amp; t) {\n    cout &lt;&lt; t &lt;&lt; endl;\n}\n\nint main() {\n    test(get&lt;0&gt;(Test&lt;2&gt;::invoke));\n    return 0;\n}\n</code></pre>\n<p>But instead I got this strange error:</p>\n<pre><code>error: redefinition of 'invoke' with a different type: 'const decltype(Test&lt;n&gt;::invoke)' vs 'const std::tuple&lt;int, const char *, double&gt;'\n</code></pre>\n<p>A different type??\nObviously, the non-template version works just fine:</p>\n<pre><code>struct Test {\n    static constexpr auto invoke = make_tuple(2, \"test\", 3.4);\n};\n\nconstexpr decltype(Test::invoke) Test::invoke;\n\ntemplate&lt;typename T&gt;\nvoid test(T&amp;&amp; t) {\n    cout &lt;&lt; t &lt;&lt; endl;\n}\n\nint main() {\n    test(get&lt;0&gt;(Test::invoke));\n    return 0;\n}\n</code></pre>\n<p>How can I get the template version to work? Thank you very much</p>\n", "AcceptedAnswerId": "33338063", "Title": "Undefined reference, template struct and constexpr static member", "CreationDate": "2015-10-26T03:20:48.283", "Id": "33337983", "CommentCount": "1", "LastEditDate": "2015-10-26T04:02:13.127", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-05T21:05:38.960", "Score": "5", "OwnerUserId": "2104697", "Tags": "<c++><templates><c++14><static-members><constexpr>", "AnswerCount": "2"}, "33338063": {"Id": "33338063", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_33337983_33338063_0\">How can I get the template version to work?</p>\n</blockquote>\n<p>FWIW, your method works fine on my desktop, which uses g++ 4.8.4.</p>\n<p>You can use:</p>\n<pre><code>template&lt;int n&gt;\nconstexpr decltype(make_tuple(2, \"test\", 3.4)) Test&lt;n&gt;::invoke;\n</code></pre>\n<p>The following also works on my desktop:</p>\n<pre><code>template&lt;int n&gt;\nstruct Test {\n    static constexpr auto invoke = make_tuple(2, \"test\", 3.4);\n    typedef decltype(invoke) invoke_t;\n};\n\ntemplate&lt;int n&gt;\nconstexpr typename Test&lt;n&gt;::invoke_t Test&lt;n&gt;::invoke;\n</code></pre>\n", "LastEditorUserId": "434551", "LastActivityDate": "2015-10-26T03:38:18.240", "Score": "1", "CreationDate": "2015-10-26T03:32:27.507", "ParentId": "33337983", "CommentCount": "2", "OwnerUserId": "434551", "LastEditDate": "2015-10-26T03:38:18.240"}});