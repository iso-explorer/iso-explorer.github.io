post_cb({"29437739": {"CommentCount": "7", "ViewCount": "238", "CreationDate": "2015-04-03T18:29:16.407", "LastActivityDate": "2015-04-03T18:57:36.540", "Title": "Passing a dummy lock to std::condition_variable_any::wait", "FavoriteCount": "1", "PostTypeId": "1", "Id": "29437739", "Score": "3", "Body": "<p>Suppose there are three threads A, B, and C. B and C suspend at a certain point, waiting for A to signal them to continue. Among the thread synchronization facilities provided by standard C++, <code>std::condition_variable</code> seems to best fit in here (though still bad). Since <code>std::condition_variable</code> must be used with a lock, the code for B and C may contain lines like:</p>\n<pre><code>{\n  std::mutex mut;\n  std::unique_lock&lt;std::mutex&gt; lock(mut);\n  cond_var.wait(lock);  // cond_var is a global variable of type std::condition_variable`\n}\n</code></pre>\n<p>Note that <code>mut</code> is used here not for synchronization purposes at all, but just to fit the signature of <code>std::condition_variable::wait</code>. With this observation, I'm thinking that maybe we can do better by implementing a dummy lock class, let's say <code>dummy_lock</code>, and replace <code>std::condition_variable</code> with <code>std::condition_variable_any</code>. <code>dummy_lock</code> meets the <a href=\"http://en.cppreference.com/w/cpp/concept/BasicLockable\" rel=\"nofollow\">BasicLockable</a> requirements with all its methods essentially doing nothing. Thereby, we get code similar to the following:</p>\n<pre><code>{\n  dummy_lock lock;\n  cond_var.wait(lock);  // cond_var is a global variable of type std::condition_variable_any`\n}\n</code></pre>\n<p>This, if works at all, should be of higher efficiency than the original one. But the question is, does it even work <strong>according to the standard (language-lawyers are apt here)</strong>? Even if it works, this is by-no-means an elegant solution. So, do any of you folks have better ideas?</p>\n", "Tags": "<c++><multithreading><locking><language-lawyer><condition-variable>", "OwnerUserId": "1348273", "AnswerCount": "2"}, "29438098": {"ParentId": "29437739", "CommentCount": "1", "CreationDate": "2015-04-03T18:57:36.540", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "29438098", "Score": "0", "Body": "<p>What you're suggesting would be undefined behavior. The section on <code>condition_variable_any</code> leads with, emphasis mine:</p>\n<blockquote>\n<p id=\"so_29437739_29438098_0\">A <code>Lock</code> type shall meet the <code>BasicLockable</code> requirements (30.2.5.2). [ Note: All of the standard mutex types\n  meet this requirement. If a Lock type other than one of the standard mutex types or a unique_lock wrapper\n  for a standard mutex type is used with condition_variable_any, <strong>the user must ensure that any necessary\n  synchronization is in place with respect to the predicate associated with the <code>condition_variable_any</code>\n  instance.</strong> \u2014end note ]</p>\n</blockquote>\n<p>The <code>BasicLockable</code> requirements themselves don't just describe the interface, they also describe the required semantics:</p>\n<blockquote>\n<p id=\"so_29437739_29438098_1\">A type <code>L</code> meets the <code>BasicLockable</code> requirements if the following expressions are well-formed <strong>and have the\n  specified semantics</strong> (m denotes a value of type L).</p>\n<p id=\"so_29437739_29438098_2\"><code>m.lock()</code><br>\n  2 Effects: Blocks until a lock can be acquired for the current execution agent. If an exception is thrown\n  then a lock shall not have been acquired for the current execution agent.</br></p>\n</blockquote>\n<p>If your <code>dummy_lock</code> doesn't actually acquire a lock, it isn't a <code>BasicLockable</code>, and so you fail to meet the premise for <code>condition_variable_any</code>. At that point, all bets are off, and you cannot expect <code>wait()</code> to do anything reasonable. </p>\n", "LastActivityDate": "2015-04-03T18:57:36.540"}, "bq_ids": {"n4140": {"so_29437739_29438098_1": {"section_id": 2673, "quality": 1.0, "length": 13}, "so_29437739_29438098_2": {"section_id": 2674, "quality": 0.9, "length": 18}, "so_29437739_29438098_0": {"section_id": 3030, "quality": 0.8918918918918919, "length": 33}}, "n3337": {"so_29437739_29438098_1": {"section_id": 2636, "quality": 1.0, "length": 13}, "so_29437739_29438098_2": {"section_id": 2637, "quality": 0.9, "length": 18}, "so_29437739_29438098_0": {"section_id": 2902, "quality": 0.8918918918918919, "length": 33}}, "n4659": {"so_29437739_29438098_1": {"section_id": 3413, "quality": 1.0, "length": 13}, "so_29437739_29438098_2": {"section_id": 3414, "quality": 0.9, "length": 18}, "so_29437739_29438098_0": {"section_id": 3789, "quality": 0.8918918918918919, "length": 33}}}, "29437918": {"ParentId": "29437739", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-04-03T18:43:27.143", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:27:27.587", "Id": "29437918", "OwnerUserId": "2015579", "Body": "<p>You are working on a false premise.</p>\n<p>The mutex does not only protect the condition predicate, it also protects the condition_variable itself.</p>\n<p>So the mutex should be at the same scope as the condition_variable and all locks should lock that same mutex.</p>\n<p>like this:</p>\n<pre><code>// global scope\nstd::mutex mut;\nstd::condition_variable cond_var;\n\n// thread scope\n{\n  std::unique_lock&lt;std::mutex&gt; lock(mut);\n  cond_var.wait(lock);\n}\n</code></pre>\n<p>see here: <a href=\"https://stackoverflow.com/questions/2763714/why-do-pthreads-condition-variable-functions-require-a-mutex\">Why do pthreads\u2019 condition variable functions require a mutex?</a></p>\n", "LastActivityDate": "2015-04-03T18:43:27.143"}});