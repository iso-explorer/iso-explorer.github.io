post_cb({"27365910": {"ParentId": "27365839", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Table 53 in [meta.trans.ref] - definition of <code>add_lvalue_reference</code>:</p>\n<blockquote>\n<p id=\"so_27365839_27365910_0\">If <code>T</code> names an object or function type then the member typedef type\n  shall name <code>T&amp;</code>; otherwise, if <code>T</code> names a type \u201crvalue reference to\n  <code>T1</code>\u201d then the member typedef type shall name <code>T1&amp;</code>; otherwise, type\n  shall name <code>T</code>.</p>\n</blockquote>\n<p>Now recall the rules for reference collapsing:</p>\n<blockquote>\n<p id=\"so_27365839_27365910_1\">If [\u2026] a type <em>template-parameter</em> (14.3.1) [\u2026] denotes a type <code>TR</code> that\n  is a reference to a type <code>T</code>, <strong>an attempt to create the type \u201clvalue\n  reference to <em>cv</em> <code>TR</code>\u201d creates the type \u201clvalue reference to <code>T</code>\u201d</strong> [\u2026]</p>\n</blockquote>\n<p>So the answer is yes:</p>\n<ul>\n<li><p>For objects or functions the condition is trivially met. It's just <code>T&amp;</code>, no reference collapsing involved.</p></li>\n<li><p>For rvalue references, an lvalue reference to the type referred-to, <code>T1</code>, is created. </p></li>\n<li><p>For lvalue references the exact reference type is preserved.</p></li>\n</ul>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-12-08T20:23:05.240", "Id": "27365910", "Score": "6", "CreationDate": "2014-12-08T20:02:55.280", "LastActivityDate": "2014-12-08T20:23:05.240"}, "bq_ids": {"n4140": {"so_27365839_27365910_1": {"section_id": 3223, "quality": 0.8125, "length": 13}}, "n3337": {"so_27365839_27365910_1": {"section_id": 3097, "quality": 0.9375, "length": 15}}, "n4659": {"so_27365839_27365910_1": {"section_id": 3980, "quality": 0.8125, "length": 13}}}, "27365839": {"CommentCount": "1", "AcceptedAnswerId": "27365910", "PostTypeId": "1", "ClosedDate": "2014-12-09T02:28:22.947", "LastEditorUserId": "3647361", "CreationDate": "2014-12-08T19:58:11.607", "LastActivityDate": "2014-12-08T20:32:56.840", "LastEditDate": "2014-12-08T20:32:56.840", "ViewCount": "271", "FavoriteCount": "3", "Title": "What does T& mean for some template argument T?", "Id": "27365839", "Score": "9", "Body": "<p>For example</p>\n<pre><code>template&lt;class T&gt;\nstruct Ref\n{\n    using type = T&amp;;\n};\n</code></pre>\n<p>Is <code>Ref&lt;T&gt;::type</code> the same as <code>std::add_lvalue_reference&lt;T&gt;::type</code> for all possible template arguments? E.g. <code>int</code>, <code>int&amp;</code>, and <code>int&amp;&amp;</code>?</p>\n<p>I just read the source code for <code>std::add_lvalue_reference&lt;T&gt;</code>. Quite sure they are equivalent.<br> If they are, we can save some space by simply writing <code>T&amp;</code> instead.</br></p>\n", "Tags": "<c++><templates><c++11><reference><typetraits>", "OwnerUserId": "1899020", "AnswerCount": "1"}});