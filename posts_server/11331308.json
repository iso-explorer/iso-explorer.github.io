post_cb({"bq_ids": {"n4140": {"so_11331308_11331662_0": {"length": 20, "quality": 0.5714285714285714, "section_id": 8}}, "n3337": {"so_11331308_11331662_0": {"length": 35, "quality": 1.0, "section_id": 5}}, "n4659": {"so_11331308_11331662_0": {"length": 20, "quality": 0.5714285714285714, "section_id": 8}}}, "11331662": {"Id": "11331662", "PostTypeId": "2", "Body": "<p>Section <code>[conv.lval]</code> of the Standard decrees that:</p>\n<blockquote>\n<p id=\"so_11331308_11331662_0\">A glvalue of a non-function, non-array type <code>T</code> can be converted to a prvalue.  If <code>T</code> is an incomplete type, a program that necessitates this conversion is ill-formed. If the object to which the glvalue refers is not an object of type <code>T</code> and is not an object of a type derived from <code>T</code>, <strong>or if the object is uninitialized, a program that necessitates this conversion has undefined behavior</strong>. If <code>T</code> is a non-class type, the type of the prvalue is the cv-unqualified version of <code>T</code>. Otherwise, the type of the prvalue is <code>T</code>.</p>\n</blockquote>\n<p>Inside <code>print</code>, the expression <code>cout &lt;&lt; content[i++]</code> uses an lvalue-to-rvalue conversion.  When you call <code>print(b)</code> or <code>print(c)</code>, the conversion takes place on an object that has never been initialized, so you have undefined behavior.</p>\n<p>Trying to characterize undefined behavior is an exercise in futility.</p>\n<hr>\n<p>NOTE: Objects <code>b</code> and <code>c</code> are initialized by the copy constructor.  The copy constructor does not initialize the subobject <code>b.content</code> or <code>c.content</code>, meaning that these arrays, and all their member elements, are formally <em>uninitialized</em>.</p>\n<p>The code doesn't actually move from <code>a</code> when initializing <code>c</code>.  <code>std::move</code> creates an rvalue-reference, which makes moving possible, but there is no matching constructor accepting an rvalue-reference, so the copy constructor is used, <code>a</code> is copied and not moved.</p>\n</hr>", "LastActivityDate": "2012-07-04T15:08:48.293", "CommentCount": "9", "CreationDate": "2012-07-04T15:08:48.293", "ParentId": "11331308", "Score": "6", "OwnerUserId": "103167"}, "11331308": {"ViewCount": "589", "Body": "<p>Let's consider following class template of custom array in Microsoft Visual C++ (Microsoft Visual Studio 2012 RC, version 11.0.50522.1 RCREL).</p>\n<pre><code>/*C++11 switch-on*/\n\n#include &lt;iostream&gt;\n\ntemplate &lt;typename element, unsigned int size&gt;\nclass array\n{\n    private:\n        element data[size];\n    public:\n        array(){}\n        ~array(){}\n        array(const array &amp; other)(){}\n        element &amp; operator [](unsigned int i)\n        {\n            if(i&lt;size)\n                return data[i];\n            else\n                throw std::runtime_error(\"Out of boundary\");\n        }\n}\n</code></pre>\n<p>Note that constructor, destructor and copy constructor are defined to do nothing. A trivial printing function is defined as following</p>\n<pre><code>/*printing*/\n\ntemplate &lt;typename element, unsigned int size&gt;\nvoid print(test::array&lt;element, size&gt; &amp; content)\n{\n    unsigned int i=0;\n    for(std::cout&lt;&lt;\"[\"&lt;&lt;content[i++];i&lt;size;std::cout&lt;&lt;content[i++])\n        std::cout&lt;&lt;\",\";\n    std::cout&lt;&lt;\"]\"&lt;&lt;std::endl;\n}\n</code></pre>\n<p>When program runs the following main</p>\n<pre><code>int main(int argc, char * argv[])\n{\n    array&lt;int, 3&gt; a;\n\n    /* uniform initialization is not supported yet\n     * so we bother iterating to assign to initialize\n     * a to [1,2,3]\n    */\n\n    for(int i=0;i&lt;3;i++)\n        a[i]=i+1;\n\n    /*copy*/\n    auto b=a;\n\n    /*move*/\n    auto c=std::move(a);\n\n    /*change in a*/\n    a[0]=0;\n\n    print&lt;int, 3&gt;(a);\n    print&lt;int, 3&gt;(b);\n    print&lt;int, 3&gt;(c);\n\n    return 0;\n}\n</code></pre>\n<p>the outputs turn out to be different depending on compiling optimization. Particularly, if I compile and run</p>\n<ul>\n<li><p>with /Od switch on</p>\n<p><em>a</em>=[0,2,3]</p>\n<p><em>b</em>=[1470797225,-2,9185596]</p>\n<p><em>c</em>=[0,2620008,9186761]</p></li>\n<li><p>with /O1, /O2 or /Ox switch on</p>\n<p><em>a</em>=[0,2,3]</p>\n<p><em>b</em>=[0,2,3]</p>\n<p><em>c</em>=[0,2,3]</p></li>\n</ul>\n<p>Now I understand that</p>\n<ul>\n<li>with /Od switch on\n<ul>\n<li><em>b</em> is different from <em>a</em> because copy constructor does nothing when called</li>\n<li><em>c</em> is different from <em>a</em> because copy constructor does nothing when called. But according to move semantic, change of element in array data in <em>a</em> also reflects to <em>c</em>. So a[0]==c[0]==0.</li>\n</ul></li>\n</ul>\n<p>But I don't understand why <em>a</em>, <em>b</em> and <em>c</em> are all equal with optimization switch on. I might think that Microsoft C++ compiler replaces copy constructor that does nothing with one that does move, but I'm just not sure about it.</p>\n", "AcceptedAnswerId": "11331662", "Title": "C++11 move semantics and Microsoft Visual C++ compiling optimization", "CreationDate": "2012-07-04T14:46:02.800", "Id": "11331308", "CommentCount": "10", "LastEditDate": "2012-07-04T15:54:01.280", "PostTypeId": "1", "LastEditorUserId": "103167", "LastActivityDate": "2012-07-04T15:54:01.280", "Score": "2", "OwnerUserId": "1386923", "Tags": "<c++><visual-c++><c++11><visual-studio-2012><move-semantics>", "AnswerCount": "1"}});