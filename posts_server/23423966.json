post_cb({"23423966": {"CommentCount": "7", "ViewCount": "291", "CreationDate": "2014-05-02T08:34:54.887", "LastActivityDate": "2014-05-02T10:57:48.903", "Title": "gcc *sometimes* resolves overload ambiguity in a strange way", "AcceptedAnswerId": "23424604", "PostTypeId": "1", "Id": "23423966", "Score": "3", "Body": "<p>Before answering: This is not a question about how to get this code to do what I want. I already know how to do that (see the end of this question). This is a question about understanding why the compiler does what it does.</p>\n<p>Please consider the following (simplified) code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid operator&gt;&gt;( std::istream &amp;stream, char chr )\n{\n    std::cout&lt;&lt;\"Called \"&lt;&lt;chr&lt;&lt;\"\\n\";\n}\n\nint main()\n{\n    char c='b';\n    std::cin&gt;&gt;c;\n\n    return 0;\n}\n</code></pre>\n<p>Compiled with gcc 4.8.2 with -Wall -Wextra produces one irrelevant warning (stream is unused). When run, however, prints \"Called b\".</p>\n<p>I expected one of two things to happen. Either the program would read one character from the standard input, or the code would not compile because the compiler finds my operator and the operator defined by the standard library to be ambiguous. The operator defined by the standard library is, according to my understanding, equivalent to:</p>\n<pre><code>std::istream &amp;operator&gt;&gt;( std::istream &amp;stream, char &amp;c )\n</code></pre>\n<p>Either way, I did not expect my operator to be called.</p>\n<p>What's even stranger, the following code does not compile because of the ambiguity mentioned above:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid function(char &amp;chr)\n{\n    std::cout&lt;&lt;\"1 \"&lt;&lt;chr&lt;&lt;\"\\n\";\n}\n\nvoid function(char chr)\n{\n    std::cout&lt;&lt;\"2 \"&lt;&lt;chr&lt;&lt;\"\\n\";\n}\n\nint main()\n{\n    char c='a';\n    function(c);\n\n    return 0;\n}\n</code></pre>\n<p>Aside from using functions rather than operators, I don't see any difference between the compiler's decision on both cases.</p>\n<p>Note: I fully realize that what the standard library defines is not exactly the same as the prototype I wrote above. I would think that, when it comes to resolving functions, at least in this use case, there is no difference that matters. Bear in mind that the std definition cannot have default arguments, as this is an operator overload.</p>\n<p>Also, as I wrote in the beginning of the question, I already know how to make the code do the right thing. Defining my operator with \"const char &amp;\" instead of \"char\" causes the compiler to choose the correct overload.</p>\n", "Tags": "<c++><gcc>", "OwnerUserId": "1510211", "AnswerCount": "2"}, "23424604": {"ParentId": "23423966", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>For the call <code>std::cin&gt;&gt;c;</code> there are two viable functions. The one you declared</p>\n<pre><code>void operator&gt;&gt;( std::istream &amp;stream, char chr );\n</code></pre>\n<p>and the one defined in the streams library (as a specialization of a function template):</p>\n<pre><code>template&lt; class CharT, class Traits &gt;\nbasic_istream&lt;CharT,Traits&gt;&amp; operator&gt;&gt;( basic_istream&lt;CharT,Traits&gt;&amp; st, CharT&amp; ch );\n</code></pre>\n<p>Selecting the best viable function that ultimately wins the overload resolution is done as described in <code>13.3.3 [over.match.best]</code>:</p>\n<blockquote>\n<p id=\"so_23423966_23424604_0\">1 De\ufb01ne ICSi(F) as follows:</p>\n<blockquote>\n<p id=\"so_23423966_23424604_9\">\u2014 if F is a static member function, ICS1\n    (F) is de\ufb01ned such that ICS1 (F) is neither better nor worse than ICS1\n    (G) for any function G, and, symmetrically, ICS1 (G) is neither better\n    nor worse than ICS1 (F); otherwise,</p>\n<p id=\"so_23423966_23424604_10\">\u2014 let ICSi(F) denote the\n    implicit conversion sequence that converts the i-th argument in the\n    list to the type of the i-th parameter of viable function F. 13.3.3.1\n    de\ufb01nes the implicit conversion sequences and\n    13.3.3.2 de\ufb01nes what it means for one implicit conversion sequence to be a better conversion sequence or worse conversion sequence than\n    another.</p>\n</blockquote>\n<p id=\"so_23423966_23424604_3\">Given these de\ufb01nitions, <strong>a viable function F1 is de\ufb01ned to be a better\n  function than another viable function F2 if for all arguments i,\n  ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</strong></p>\n<blockquote>\n<p id=\"so_23423966_23424604_11\">\u2014 for some argument j, ICSj(F1) is a better conversion sequence than\n    ICSj(F2), or, if not that,  </p>\n<p id=\"so_23423966_23424604_12\">\u2014 the context is an initialization by\n    user-de\ufb01ned conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the\n    standard conversion sequence from the return type of F1 to the\n    destination type (i.e., the type of the entity being initialized) is a\n    better conversion sequence than the standard conversion sequence from\n    the return type of F2 to the destination type.<br>\n    [ Example: <em>omitted</em> ] or, if not that,</br></p>\n<p id=\"so_23423966_23424604_13\">\u2014 <strong>F1 is a non-template function\n    and F2 is a function template specialization</strong>, or, if not that,</p>\n<p id=\"so_23423966_23424604_14\">\u2014 F1 and F2 are function template specializations, and the function\n    template for F1 is more specialized than the template for F2 according\n    to the partial ordering rules described in 14.5.6.2.</p>\n</blockquote>\n<p id=\"so_23423966_23424604_8\">2 If there is exactly one viable function that is a better function\n  than all other viable functions, then it is the one selected by\n  overload resolution; otherwise the call is ill-formed.</p>\n</blockquote>\n<p>To simplify it - all else being equal, the non-template is a better match than a template specialization.</p>\n<p>In the example with <code>function</code>, there is no such distinction between the candidates. Both implicit conversion sequences required for the call (<code>char</code>-&gt;<code>char&amp;</code> and <code>char</code>-&gt;<code>char</code>) are Identity conversion and are ambiguous.</p>\n", "OwnerUserId": "947836", "LastEditorUserId": "947836", "LastEditDate": "2014-05-02T09:18:08.420", "Id": "23424604", "Score": "5", "CreationDate": "2014-05-02T09:12:04.320", "LastActivityDate": "2014-05-02T09:18:08.420"}, "bq_ids": {"n4140": {"so_23423966_23424604_14": {"section_id": 603, "quality": 0.9333333333333333, "length": 14}, "so_23423966_23424604_5": {"section_id": 603, "quality": 0.8275862068965517, "length": 24}, "so_23423966_23424604_9": {"section_id": 603, "quality": 0.7391304347826086, "length": 17}, "so_23423966_23424604_6": {"section_id": 111, "quality": 1.0, "length": 5}, "so_23423966_23424604_2": {"section_id": 603, "quality": 0.8055555555555556, "length": 29}, "so_23423966_23424604_11": {"section_id": 603, "quality": 0.75, "length": 6}, "so_23423966_23424604_10": {"section_id": 603, "quality": 0.8055555555555556, "length": 29}, "so_23423966_23424604_1": {"section_id": 603, "quality": 0.7391304347826086, "length": 17}, "so_23423966_23424604_12": {"section_id": 603, "quality": 0.8275862068965517, "length": 24}, "so_23423966_23424604_13": {"section_id": 111, "quality": 1.0, "length": 5}, "so_23423966_23424604_3": {"section_id": 603, "quality": 0.75, "length": 15}, "so_23423966_23424604_8": {"section_id": 604, "quality": 1.0, "length": 20}, "so_23423966_23424604_4": {"section_id": 603, "quality": 0.75, "length": 6}, "so_23423966_23424604_7": {"section_id": 603, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_23423966_23424604_14": {"section_id": 593, "quality": 0.9333333333333333, "length": 14}, "so_23423966_23424604_5": {"section_id": 593, "quality": 0.8275862068965517, "length": 24}, "so_23423966_23424604_12": {"section_id": 593, "quality": 0.8275862068965517, "length": 24}, "so_23423966_23424604_6": {"section_id": 106, "quality": 1.0, "length": 5}, "so_23423966_23424604_2": {"section_id": 593, "quality": 0.8055555555555556, "length": 29}, "so_23423966_23424604_11": {"section_id": 593, "quality": 0.75, "length": 6}, "so_23423966_23424604_10": {"section_id": 593, "quality": 0.8055555555555556, "length": 29}, "so_23423966_23424604_1": {"section_id": 593, "quality": 0.7391304347826086, "length": 17}, "so_23423966_23424604_9": {"section_id": 593, "quality": 0.7391304347826086, "length": 17}, "so_23423966_23424604_13": {"section_id": 106, "quality": 1.0, "length": 5}, "so_23423966_23424604_3": {"section_id": 593, "quality": 0.75, "length": 15}, "so_23423966_23424604_8": {"section_id": 594, "quality": 1.0, "length": 20}, "so_23423966_23424604_4": {"section_id": 593, "quality": 0.75, "length": 6}, "so_23423966_23424604_7": {"section_id": 593, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_23423966_23424604_14": {"section_id": 629, "quality": 0.9333333333333333, "length": 14}, "so_23423966_23424604_5": {"section_id": 629, "quality": 0.8275862068965517, "length": 24}, "so_23423966_23424604_12": {"section_id": 629, "quality": 0.8275862068965517, "length": 24}, "so_23423966_23424604_6": {"section_id": 115, "quality": 1.0, "length": 5}, "so_23423966_23424604_2": {"section_id": 629, "quality": 0.8055555555555556, "length": 29}, "so_23423966_23424604_11": {"section_id": 629, "quality": 0.75, "length": 6}, "so_23423966_23424604_10": {"section_id": 629, "quality": 0.8055555555555556, "length": 29}, "so_23423966_23424604_1": {"section_id": 629, "quality": 0.7391304347826086, "length": 17}, "so_23423966_23424604_9": {"section_id": 629, "quality": 0.7391304347826086, "length": 17}, "so_23423966_23424604_13": {"section_id": 115, "quality": 1.0, "length": 5}, "so_23423966_23424604_3": {"section_id": 629, "quality": 0.75, "length": 15}, "so_23423966_23424604_8": {"section_id": 630, "quality": 1.0, "length": 20}, "so_23423966_23424604_4": {"section_id": 629, "quality": 0.75, "length": 6}, "so_23423966_23424604_7": {"section_id": 629, "quality": 0.9333333333333333, "length": 14}}}, "23424096": {"CommentCount": "10", "CreationDate": "2014-05-02T08:43:15.837", "CommunityOwnedDate": "2014-05-02T10:57:48.903", "LastEditorUserId": "775806", "LastActivityDate": "2014-05-02T10:57:48.903", "ParentId": "23423966", "PostTypeId": "2", "LastEditDate": "2014-05-02T10:57:48.903", "Id": "23424096", "Score": "3", "Body": "<p>The standard <code>operator &gt;&gt;</code> is a template. A non-template wins over a template (13.3.3/1) <em>provided the argument conversions are of equal quality</em> (13.3.3.2/3) (there are other conditions but they do not apply here).</p>\n<p>Since neither of <code>char lvalue -&gt; char</code> and <code>char lvalue -&gt; char&amp;</code> is better than the other, the non-template wins.</p>\n<p>If you declare a non-templae with <code>const char&amp;</code>, then it becomes worse than the standard <code>&gt;&gt;</code>, because <code>const char&amp;</code> has more qualifiers than <code>char&amp;</code>. So <code>std::operator&gt;&gt;</code> wins.</p>\n<p><s>There's another reason: Koenig lookup. The standard <code>operator&gt;&gt;</code> is a member of namespace std, it is only found if \"normal\" lookup fails. Koenig lookup would not be a factor if you have used <code>using namespace std</code>.</s> The preceding is incorrect.</p>\n", "OwnerUserId": "775806"}});