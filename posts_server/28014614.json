post_cb({"28014614": {"CommentCount": "10", "ViewCount": "515", "CreationDate": "2015-01-18T20:42:31.053", "LastActivityDate": "2015-01-18T22:18:16.640", "Title": "Why path comparison is case-sensitive in latest filesystem draft (C++)?", "FavoriteCount": "1", "PostTypeId": "1", "Id": "28014614", "OwnerUserId": "1997715", "Body": "<p>A quote from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf\" rel=\"nofollow\">Programming Languages \u2014 C++ \u2014 File System Technical Specification draft N4100</a>:</p>\n<blockquote>\n<p id=\"so_28014614_28014614_0\">8.4.8 pathcompare [path.compare]</p>\n<p id=\"so_28014614_28014614_1\">1 int compare(const path&amp; p) const noexcept;</p>\n<p id=\"so_28014614_28014614_2\">2 Returns: A value less than 0 if native() for the elements\n  of *this are lexicographically less than native() for the elements of p,\n  otherwise a value greater than 0 if native()for the elements of *this are\n  lexicographically greater than native() for the elements of p, otherwise 0.</p>\n</blockquote>\n<p>Why the file path comparison is defined as case-sensitive if there are file systems that are case-insensitive (NTFS, etc)? Shouldn't comparison be done according to specific file system rules?</p>\n", "Tags": "<c++><filesystems>", "Score": "4", "AnswerCount": "1"}, "bq_ids": {"n4659": {"so_28014614_28014614_1": {"section_id": 1984, "quality": 0.8, "length": 4}, "so_28014614_28014614_2": {"section_id": 2873, "quality": 0.9130434782608695, "length": 21}, "so_28014614_28015070_1": {"section_id": 2926, "quality": 0.9583333333333334, "length": 23}, "so_28014614_28015070_0": {"section_id": 3134, "quality": 0.875, "length": 14}, "so_28014614_28015070_2": {"section_id": 2926, "quality": 1.0, "length": 20}}}, "28015070": {"ParentId": "28014614", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You have additionally <code>equivalent()</code> function specified in 15.13, which checks if two paths resolve to the same file. </p>\n<pre><code>bool equivalent(const path&amp; p1, const path&amp; p2)\n</code></pre>\n<blockquote id=\"so_28014614_28015070_0\">\n<ol start=\"4\">\n<li>Returns: <code>true</code>, if <code>s1 == s2</code> and <code>p1</code> and <code>p2</code> resolve to the same\n  file system entity, else <code>false</code>. The signature with argument <code>ec</code>\n  returns <code>false</code> if an error occurs.</li>\n</ol>\n</blockquote>\n<p><code>compare()</code> function will use iterators and <code>path::operator==</code> to compare elements. In 8.6.13 you have written:</p>\n<pre><code>bool operator==(const path&amp; lhs, const path&amp; rhs) noexcept;\n</code></pre>\n<blockquote>\n<ol start=\"17\">\n<li><p id=\"so_28014614_28015070_1\">Equivalence is determined by the equivalent() non-member function,\n  which determines if two paths resolve to the same file system entity.\n  Thus equivalent(\"foo\", \"bar\") will be true when both paths resolve to\n  the same file</p></li>\n<li><p id=\"so_28014614_28015070_2\">Programmers wishing to determine if two paths are \"the same\" must\n  decide if \"the same\" means \"the same representation\" or \"resolve to\n  the same actual file\", and choose the appropriate function accordingly</p></li>\n</ol>\n</blockquote>\n<p>So, <code>equivalent()</code> comparison is done according to system specific rules, while <code>compare()</code> checks if you have used \"the same representation\" to describe path.</p>\n", "OwnerUserId": "205955", "LastEditorUserId": "205955", "LastEditDate": "2015-01-18T22:18:16.640", "Id": "28015070", "Score": "2", "CreationDate": "2015-01-18T21:34:17.487", "LastActivityDate": "2015-01-18T22:18:16.640"}});