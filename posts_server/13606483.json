post_cb({"13606483": {"CreationDate": "2012-11-28T13:43:32.233", "ViewCount": "343", "FavoriteCount": "2", "Id": "13606483", "AcceptedAnswerId": "13607061", "Score": "5", "Title": "C++ nontype template argument taking inherited class", "LastEditorUserId": "466339", "CommentCount": "0", "Body": "<p>I want to be able to pass references of objects inherited from <code>DBMetaData</code> as a nontype template argument of another class, <code>DBVar</code>:</p>\n<pre><code>#include    &lt;iostream&gt;\n\nclass   DBMetaData\n{\npublic:\n    virtual const char  *description( ) const   = 0;\n};\n\nclass   DBMetaData_NT\n:   public  DBMetaData\n{\npublic:\n    const char  *description( ) const\n    {   return  \"Useless description.\"; }\n};\n\n#if DO_WHAT_I_WANT\ntemplate&lt; const DBMetaData &amp;Metadata &gt;\n#else\ntemplate&lt; typename MetadataType,\n    const MetadataType &amp;Metadata &gt;\n#endif  // DO_WHAT_I_WANT\nclass DBVar\n{\npublic:\n    /// Descri\u00e7\u00e3o da variavel.\n    const char  *description( ) const\n    {   return  Metadata.description( ); }\n};\n\nDBMetaData_NT       _md_u1;\n\n#if DO_WHAT_I_WANT\nDBVar&lt; _md_u1 &gt; _u1;\n#else\nDBVar&lt; DBMetaData_NT, _md_u1 &gt;  _u1;\n#endif  // DO_WHAT_I_WANT\n\nint main( )\n{\n    std::cout &lt;&lt; \"_md_u1.description( ) = \" &lt;&lt; _md_u1.description( ) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"_u1.description( ) = \"    &lt;&lt; _u1.description( ) &lt;&lt; std::endl;\n\n    return  0;\n}\n</code></pre>\n<p>I can compile and run the above example <em>but</em> I need to explicitly specify teh inherited type.</p>\n<p>If I try to compile it defining <code>DO_WHAT_I_WANT</code> (I want to pass a reference - or pointer - of type <code>DBMetaData</code> to an object of any inherited class), I get the error:</p>\n<pre><code>templ_inh_arg.cpp:36:15: error: could not convert template argument \u2018_md_u1\u2019 to \u2018const DBMetaData&amp;\u2019\ntempl_inh_arg.cpp:36:20: error: invalid type in declaration before \u2018;\u2019 token\n</code></pre>\n<p>Why can't I pass <code>_u1</code>, that is of type <code>DBMetaData_NT</code> that inherits from <code>DBMetaData</code> as parameter for <code>DBVar&lt; _md_u1 &gt;   _u1;</code>?</p>\n<p>Is there any way to get what I want?</p>\n<p>Thanks!</p>\n<hr>\n<p>EDIT:</p>\n<p>Replacing the template parameter with a function pointer, as suggested by @ecatmur solved my problem and, I must note, turned my code a little more readable.</p>\n<pre><code>#include    &lt;iostream&gt;\n\nclass   DBMetaData\n{\npublic:\n    /// Descri\u00e7\u00e3o da variavel.\n    virtual const char  *description( ) const   = 0;\n};\n\nclass   DBMetaData_NT\n:   public  DBMetaData\n{\npublic:\n    const char  *description( ) const\n    {   return  \"Useless description.\"; }\n};\n\n\ntypedef     const DBMetaData &amp;( *metadata )( );\n\ntemplate&lt; metadata Metadata &gt;\nclass DBVar\n{\npublic:\n    /// Descri\u00e7\u00e3o da variavel.\n    const char  *description( ) const\n    {   return  Metadata( ).description( ); }\n};\n\nconst DBMetaData &amp; _md_u1_metadata( )\n{\n    static const DBMetaData_NT      _md_u1;\n\n    return  _md_u1;\n}\n\nDBVar&lt; _md_u1_metadata &gt;    _u1;\n\nint main( )\n{\n    std::cout &lt;&lt; \"_md_u1_metadata( ).description( ) = \" &lt;&lt; _md_u1_metadata( ).description( ) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"_u1.description( ) = \"    &lt;&lt; _u1.description( ) &lt;&lt; std::endl;\n\n    return  0;\n}\n</code></pre>\n</hr>", "Tags": "<c++><templates><inheritance><template-specialization>", "LastEditDate": "2012-11-28T16:33:34.000", "LastActivityDate": "2012-11-28T16:33:34.000", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "466339"}, "bq_ids": {"n4140": {"so_13606483_13607061_0": {"length": 5, "quality": 1.0, "section_id": 87}, "so_13606483_13607061_1": {"length": 23, "quality": 0.8846153846153846, "section_id": 91}}, "n3337": {"so_13606483_13607061_0": {"length": 5, "quality": 1.0, "section_id": 82}, "so_13606483_13607061_1": {"length": 23, "quality": 0.8846153846153846, "section_id": 86}}}, "13607061": {"LastActivityDate": "2012-11-28T14:34:21.307", "CommentCount": "2", "Body": "<p>Unfortunately not.  Per 14.3.2 <strong>Template non-type arguments</strong>, paragraph 1:</p>\n<blockquote>\n<p id=\"so_13606483_13607061_0\">A <em>template-argument</em> for a non-type, non-template <em>template-parameter</em> shall be one of: [...]<br/></p>\n<ul>\n<li>a constant expression that designates the address of an object with static storage duration [...], expressed (ignoring parentheses) as <code>&amp;</code> <em>id-expression</em>, except that the <code>&amp;</code> [...] shall be omitted if the corresponding <em>template-parameter</em> is a reference.</li>\n</ul>\n</blockquote>\n<p>Derived-to-base conversions are <em>not</em> permitted, per paragraph 5 of the same section:</p>\n<blockquote id=\"so_13606483_13607061_1\">\n<ul>\n<li>For a non-type <em>template-parameter</em> of type reference to object, no conversions apply. The type referred to by the reference may be more cv-qualified than the (otherwise identical) type of the <em>template-argument</em>. The <em>template-parameter</em> is bound directly to the <em>template-argument</em>, which shall be an lvalue.</li>\n</ul>\n</blockquote>\n<p>This also means that a cast is not permitted, as this is not of the form [<code>&amp;</code>] <em>id-expression</em>, and does not yield an lvalue.</p>\n<p>Depending on what you're trying to accomplish, you may be able to achieve a similar result through manually simulating polymorphism e.g. having <code>_md_u1</code> initialised as the return value of a function which sets up an appropriate vtable pointer or table.</p>\n", "CreationDate": "2012-11-28T14:12:55.840", "LastEditDate": "2012-11-28T14:34:21.307", "ParentId": "13606483", "Id": "13607061", "LastEditorUserId": "567292", "PostTypeId": "2", "Score": "4", "OwnerUserId": "567292"}, "13607549": {"CommentCount": "0", "Body": "<p>You can do it with C++11's <code>decltype</code> and a macro like following:</p>\n<pre><code>#define DBVAR(metadata) DBVar&lt;decltype(metadata), metadata&gt;\n</code></pre>\n<p>Now, to define a variable:</p>\n<pre><code>DBVAR(_md_u1) _u1;\n</code></pre>\n<p>Hope this helps.</p>\n<p>EDIT: To be honest I don't like your approach. I'd rather go with static metadata member functions or non-template based polymorphism.</p>\n", "CreationDate": "2012-11-28T14:36:29.453", "ParentId": "13606483", "Id": "13607549", "LastActivityDate": "2012-11-28T14:36:29.453", "PostTypeId": "2", "Score": "1", "OwnerUserId": "461632"}});