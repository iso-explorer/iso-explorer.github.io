post_cb({"bq_ids": {"n4140": {"so_13196528_13197252_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 2189}, "so_13196528_13197252_4": {"length": 7, "quality": 0.7777777777777778, "section_id": 6536}, "so_13196528_13197252_0": {"length": 10, "quality": 0.625, "section_id": 2330}, "so_13196528_13197252_2": {"length": 7, "quality": 0.875, "section_id": 1959}, "so_13196528_13197147_0": {"length": 16, "quality": 0.8, "section_id": 6536}, "so_13196528_13197252_1": {"length": 10, "quality": 0.625, "section_id": 2330}}, "n3337": {"so_13196528_13197252_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 2177}, "so_13196528_13197252_4": {"length": 7, "quality": 0.7777777777777778, "section_id": 6291}, "so_13196528_13197252_0": {"length": 10, "quality": 0.625, "section_id": 2318}, "so_13196528_13197252_2": {"length": 7, "quality": 0.875, "section_id": 1948}, "so_13196528_13197147_0": {"length": 16, "quality": 0.8, "section_id": 6291}, "so_13196528_13197252_1": {"length": 10, "quality": 0.625, "section_id": 2318}}, "n4659": {"so_13196528_13197252_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 2462}, "so_13196528_13197252_4": {"length": 7, "quality": 0.7777777777777778, "section_id": 8018}, "so_13196528_13197252_0": {"length": 10, "quality": 0.625, "section_id": 2605}, "so_13196528_13197252_2": {"length": 7, "quality": 0.875, "section_id": 2230}, "so_13196528_13197147_0": {"length": 16, "quality": 0.8, "section_id": 8018}, "so_13196528_13197252_1": {"length": 10, "quality": 0.625, "section_id": 2605}}}, "13197252": {"Id": "13197252", "PostTypeId": "2", "Body": "<p>Let's start with \u00a727.6.3, \"Standard manipulators\", \u00b65, \"<code>smanip setbase(int base)</code>\": </p>\n<blockquote>\n<blockquote>\n<p id=\"so_13196528_13197252_1\">Returns: An object <code>s</code> of unspecified type such that if <code>in</code> is an (instance of) <code>basic_istream</code> then the\n    expression <code>in&gt;&gt;s</code> behaves as if <code>f(s)</code> were called. Where <code>f</code> can be defined as:</p>\n<pre><code>ios_base&amp; f(ios_base&amp; str, int base)\n{\n  // set basefield\n  str.setf(base == 8 ? ios_base::oct :\n    base == 10 ? ios_base::dec :\n    base == 16 ? ios_base::hex :\n    ios_base::fmtflags(0), ios_base::basefield);\n  return str;\n}\n</code></pre>\n</blockquote>\n</blockquote>\n<p>We continue our quest with \u00a727.4.2.2 <code>ios_base fmtflags</code> state functions, \u00b66 <code>fmtflags setf(fmtflags fmtfl, fmtflags mask);</code></p>\n<blockquote>\n<p id=\"so_13196528_13197252_2\">Effects: Clears <code>mask</code> in <code>flags()</code>, sets <code>fmtfl &amp; mask</code> in <code>flags()</code>.</p>\n</blockquote>\n<p>So, what is the effect of setting <code>0&amp;basefield</code> in <code>flags()</code>? </p>\n<p>Consider \u00a727.6.1.2.2 Arithmetic Extractors, which describes, among others, <code>operator&gt;&gt;(int&amp; val);</code>:</p>\n<blockquote>\n<p id=\"so_13196528_13197252_3\">these extractors depend on the locale\u2019s num_get&lt;&gt; (22.2.2.1) object to\n  perform parsing the input stream data.</p>\n</blockquote>\n<p>\u00a722.2.2.1, \u00b64, Table 55 describes the conversion specifier selected in this case:</p>\n<pre><code>basefield == 0, `%i`\n</code></pre>\n<p>Finally, \u00b611 says:</p>\n<blockquote>\n<p id=\"so_13196528_13197252_4\">A sequence of chars ... is converted (according to the rules of\n  <code>scanf</code>) to a value of the type of val.</p>\n</blockquote>\n<hr>\n<p>So, the C++ Standard, 2003, says that <code>std::cin &gt;&gt; setbase(0) &gt;&gt; i</code> is equivalent to <code>scanf(..., \"%i\", &amp;i)</code>.</p>\n<p>For what <strong>that</strong> means, you need to consult the C Standard.</p>\n</hr>", "LastEditorUserId": "743214", "LastActivityDate": "2012-11-02T14:37:48.610", "Score": "2", "CreationDate": "2012-11-02T14:30:01.900", "ParentId": "13196528", "CommentCount": "1", "OwnerUserId": "8747", "LastEditDate": "2012-11-02T14:37:48.610"}, "13197147": {"Id": "13197147", "PostTypeId": "2", "Body": "<p>\u00a722.4.2.1.2/3, Table 85:</p>\n<blockquote>\n<p id=\"so_13196528_13197147_0\">For conversion to an integral type, the function determines the integral conversion specifier as indicated in Table 85. The table is ordered. That is, the first line whose condition is true applies.</p>\n</blockquote>\n<pre><code>Table 85 \u2014 Integer conversions\nState                    stdio equivalent\nbasefield == oct         %o\nbasefield == hex         %X\nbasefield == 0           %i\nsigned integral type     %d\nunsigned integral type   %u\n</code></pre>\n<p>The <code>%i</code> conversion format for <code>scanf</code> and company does prefix-dependent conversion.</p>\n", "LastActivityDate": "2012-11-02T14:24:47.467", "CommentCount": "1", "CreationDate": "2012-11-02T14:24:47.467", "ParentId": "13196528", "Score": "3", "OwnerUserId": "179910"}, "13196528": {"ViewCount": "662", "Body": "<p>I have a simple test program (error checks removed):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string line;\n    while(std::cin &gt;&gt; line) {\n        int value;\n        std::stringstream stream(line);\n\n        stream &gt;&gt; std::setbase(0) &gt;&gt; value;\n\n        std::cout &lt;&lt; \"You typed: \" &lt;&lt; value &lt;&lt; std::endl;\n    }\n\n}\n</code></pre>\n<p>Which works great for prefix-dependent integer parsing. It'll parse strings starting with <code>\"0x\"</code> or <code>\"0X\"</code> as hexadecimal and strings starting with <code>'0'</code> as octal. This is explained in several <a href=\"http://en.cppreference.com/w/cpp/io/manip/setbase\" rel=\"nofollow noreferrer\">resources</a> that I use and have seen. What I haven't been able to find though, is an indication in the C++ standard that this is guaranteed to work.</p>\n<p>Section 7.20.1.4.3 on <code>strtol</code> in the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf\" rel=\"nofollow noreferrer\">C standard</a> says (6.4.4.1 is the syntax for integer constants) I imagine the extraction operators use this under the hood:</p>\n<blockquote>\n<p id=\"so_13196528_13196528_0\">If the value of base is zero, the expected form of the subject sequence is that of an\n  integer constant as described in 6.4.4.1, optionally preceded by a plus or minus sign, but\n  not including an integer suf\ufb01x.</p>\n</blockquote>\n<p>This works on the couple of versions of GCC that I've tried, but is it safe to use generally?</p>\n", "AcceptedAnswerId": "13197199", "Title": "Where is prefix-dependent integer parsing defined?", "CreationDate": "2012-11-02T13:48:29.610", "Id": "13196528", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2012-11-02T13:58:53.583", "LastEditorUserId": "224286", "LastActivityDate": "2012-11-02T20:27:37.687", "Score": "9", "OwnerUserId": "224286", "Tags": "<c++><language-lawyer>", "AnswerCount": "3"}, "13197199": {"Id": "13197199", "PostTypeId": "2", "Body": "<p><code>setbase</code> is defined in C++98 [lib.std.manip]/5, paraphrasing slightly</p>\n<pre><code>smanip setbase(int base);\n</code></pre>\n<p><strong>Returns:</strong> An object <em><code>s</code></em> of unspecified type such that [inserting or extracting <code>s</code> from a stream behaves as if the following function were called on that stream:]</p>\n<pre><code>ios_base&amp; f(ios_base&amp; str, int base)\n{\n    str.setf(n == 8 ? ios_base::oct :\n             n == 10 ? ios_base::dec :\n             n == 16 ? ios_base::hex :\n             ios_base::fmtflags(0), ios_base::basefield);\n    return str;\n}\n</code></pre>\n<p>Okay, so, if <code>base</code> is not 8, 10, or 16, then the <code>basefield</code> flags are cleared.  The <em>effect</em> of a cleared <code>basefield</code> for input is defined in [lib.facet.num.get.virtuals], table 55 (\"Integer conversions\") as equivalent to <code>sscanf(\"%i\")</code> on the sequence of characters next available.</p>\n<p>C++98 refers to C89 for the definition of <code>*scanf</code>, naturally enough.  I don't have a PDF copy of C89, but I do have C99, in which section 7.19.6.2 paragraph 12 [the C standard does not have the nice symbolic section names that the C++ standard has] defines <code>\"%i\"</code> to behave the same as <code>strtol</code> with base argument 0.</p>\n<p>So the good news is, prefix-dependent integer scanning is guaranteed by the standard after <code>setbase(0)</code>.  The <em>bad</em> news is, iostream formatted input is defined in terms of <code>*scanf</code>, which means the dreadful sentence at the end of C99 7.19.6.2p10 applies:</p>\n<blockquote>\n<p id=\"so_13196528_13197199_0\">If [the object that receives the result of scanning] does not have an appropriate type, or if <em>the result of the conversion cannot be represented in the object</em>, the <strong><em>behavior is undefined</em></strong>.</p>\n</blockquote>\n<p>(Emphasis mine.)  Clearer version of that sentence: <em>input overflow triggers undefined behavior</em>.  The C(++) runtime is allowed to <em>crash the program</em> if input to <code>*scanf</code> has too many digits!  This is (one of several reasons) why I and others keep saying <code>*scanf</code> should never be used, and now I have to start saying it about <code>istream &gt;&gt; int</code> as well. :-(</p>\n<p>The advice that holds for C is even easier to apply in C++: Read entire lines with <code>std::getline</code> and parse them by hand.  Use the <code>strtol</code> family of functions to convert numeric input to machine numbers.  (Those functions have predictable behavior on overflow.)</p>\n", "LastEditorUserId": "388520", "LastActivityDate": "2012-11-02T20:27:37.687", "Score": "5", "CreationDate": "2012-11-02T14:27:26.453", "ParentId": "13196528", "CommentCount": "0", "OwnerUserId": "388520", "LastEditDate": "2012-11-02T20:27:37.687"}});