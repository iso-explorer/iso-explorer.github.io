post_cb({"15258991": {"Id": "15258991", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15258525_15258991_0\">What exactly does it mean for a call to be \"ill-formed\"</p>\n</blockquote>\n<p>Formally, ill-formed is defined by [defns.ill.formed] as not well-formed, and a well-formed program is defined by [defns.well.formed] as:</p>\n<blockquote>\n<p id=\"so_15258525_15258991_1\">C++ program constructed according to the syntax rules, diagnosable semantic rules, and the One Definition Rule (3.2).</p>\n</blockquote>\n<p>So an ill-formed call is one with invalid syntax or a diagnosable error such as passing the wrong number of arguments, or arguments which cannot be converted to the parameter types, or an overload ambiguity.</p>\n<blockquote>\n<p id=\"so_15258525_15258991_2\">how would an ill-formed call be selected by the lookup?</p>\n</blockquote>\n<p>I think it's saying \"if (the call would be ill-formed || would find a better match) had the lookup within the associated namespaces considered all the function declarations with external linkage ...\", which means you have undefined behaviour if considering other functions would have found equal or better matches. Equally good matches would make the call ambiguous, i.e. ill-formed, and better matches would have resulted in a different function being called.</p>\n<p>So <em>if</em> in another context the call would have been ambiguous or caused another sort of error, but succeeds due to only considering a limited set of names in the instantiation and definition contexts, it's undefined. And <em>if</em> in another context the call would have chosen a better match, that's also undefined.</p>\n<blockquote>\n<p id=\"so_15258525_15258991_3\">Also, why does it matter that a better match would be found if all translation units were considered?</p>\n</blockquote>\n<p>I think the reason for the rule is to disallow situations where instantiating the same template specialization in two different contexts results in it calling two different functions, e.g. if in one translation unit the call finds one function, and in another translation unit it finds a different function, you'll get two different instantiations of the same template, which violates the ODR, and only one instantiation will be kept by the linker, so the instantiation that's not kept by the linker will get replaced by one which calls a function that wasn't even visible where the template was instantiated.</p>\n<p>That's similar (if not already covered by) the last sentence of the previous paragraph:</p>\n<blockquote>\n<p id=\"so_15258525_15258991_4\">A specialization for any template may have points of instantiation in multiple translation units. If two different points of instantiation give a template specialization different meanings according to the one definition rule (3.2), the program is ill-formed, no diagnostic required.</p>\n</blockquote>\n<p>Page 426 of the C++ ARM (Ellis &amp; Stroustrup) gives a bit of context for that text (and I believe for 14.6.4.2 as well) and explains it more concisely and clearly than I did above:</p>\n<blockquote>\n<p id=\"so_15258525_15258991_5\">This would seem to imply that a global name used from within a template could be bound to different objects or functions in different compilation units or even at different points within a compilation unit. However, should that happen, the resulting template function or class is rendered illegal by the \"one-definition\" rule (\u00a77.1.2).</p>\n</blockquote>\n<p>There's another related formulation of the same rules in [basic.def.odr]/6</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-03-06T22:23:22.570", "Score": "13", "CreationDate": "2013-03-06T22:03:05.373", "ParentId": "15258525", "CommentCount": "0", "OwnerUserId": "981959", "LastEditDate": "2013-03-06T22:23:22.570"}, "15260095": {"Id": "15260095", "PostTypeId": "2", "Body": "<p>The problem is that namespaces can be defined piecemeal, so there is no <strong>one</strong> place that is guaranteed to define all of the members of a namespace. As a result, different translation units can see different sets of namespace members. What this section says is that if the part that isn't seen would affect lookup, the behavior is undefined. For example:</p>\n<pre><code>namespace mine {\n    void f(double);\n}\n\nmine::f(2); // seems okay...\n\nnamespace mine {\n    void f(char);\n}\n\nmine::f(2); // ambiguous, therefore ill-formed\n</code></pre>\n<p>The rule says that the first call to <code>f(2)</code> produces undefined behavior because it would have been ill-formed if all of the overloads in <code>mine</code> had been visible at that point.</p>\n", "LastEditorUserId": "1593860", "LastActivityDate": "2013-03-07T04:39:17.310", "Score": "7", "CreationDate": "2013-03-06T23:17:48.087", "ParentId": "15258525", "CommentCount": "0", "OwnerUserId": "1593860", "LastEditDate": "2013-03-07T04:39:17.310"}, "bq_ids": {"n4140": {"so_15258525_15258525_0": {"length": 36, "quality": 1.0, "section_id": 224}, "so_15258525_15258991_1": {"length": 10, "quality": 1.0, "section_id": 5768}, "so_15258525_15258991_4": {"length": 25, "quality": 1.0, "section_id": 223}}, "n3337": {"so_15258525_15258525_0": {"length": 36, "quality": 1.0, "section_id": 217}, "so_15258525_15258991_1": {"length": 10, "quality": 1.0, "section_id": 5541}, "so_15258525_15258991_4": {"length": 25, "quality": 1.0, "section_id": 216}}, "n4659": {"so_15258525_15258525_0": {"length": 36, "quality": 1.0, "section_id": 232}, "so_15258525_15258991_1": {"length": 7, "quality": 0.7, "section_id": 7225}, "so_15258525_15258991_4": {"length": 23, "quality": 0.92, "section_id": 231}}}, "15259397": {"Id": "15259397", "PostTypeId": "2", "Body": "<p>Building on <a href=\"https://stackoverflow.com/a/15259162/1424877\">@tletnes' partial answer</a>, I think I've come up with a simple program that triggers this particular undefined behavior. Of course it uses multiple translation units.</p>\n<pre><code>cat &gt;alpha.cc &lt;&lt;EOF\n#include &lt;stdio.h&gt;\nvoid customization_point(int,int) { puts(\"(int,int)\"); }\n#include \"beta.h\"\nextern void gamma();\nint main() {\n    beta(42);\n    gamma();\n}\nEOF\n\ncat &gt;gamma.cc &lt;&lt;EOF\n#include &lt;stdio.h&gt;\nvoid customization_point(int,double) { puts(\"(int,double)\"); }\n#include \"beta.h\"\nvoid gamma() { beta(42); }\nEOF\n\ncat &gt;beta.h &lt;&lt;EOF\ntemplate&lt;typename T&gt;\nvoid beta(T t) {\n    customization_point(t, 3.14);\n}\nEOF\n</code></pre>\n<p>Compiling this program with different optimization levels changes its behavior. This is all right, according to the Standard, because the call in \"alpha.cc\" invokes undefined behavior.</p>\n<pre><code>$ clang++ alpha.cc gamma.cc -O1 -w ; ./a.out\n(int,int)\n(int,int)\n$ clang++ alpha.cc gamma.cc -O2 -w ; ./a.out\n(int,int)\n(int,double)\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-05T10:00:54.270", "Score": "4", "CreationDate": "2013-03-06T22:29:27.267", "ParentId": "15258525", "CommentCount": "0", "OwnerUserId": "1424877", "LastEditDate": "2017-05-23T12:21:29.253"}, "15258525": {"ViewCount": "1608", "Body": "<p>\u00a7 14.6.4.2 from N3485 states the following about dependent candidate function lookup:</p>\n<blockquote>\n<p id=\"so_15258525_15258525_0\">If the call would be ill-formed or would find a better match had the lookup within the associated namespaces considered all the function declarations with external linkage introduced in those namespaces in all translation units, not just considering those declarations found in the template definition and template instantiation contexts, then the program has undefined behavior.</p>\n</blockquote>\n<p>What exactly does it mean for a call to be \"ill-formed\", and how would an ill-formed call be selected by the lookup? Also, why does it matter that a better match would be found if all translation units were considered?</p>\n", "AcceptedAnswerId": "15258991", "Title": "C++11: ill-formed calls are undefined behavior?", "CreationDate": "2013-03-06T21:33:46.373", "Id": "15258525", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-03-06T21:51:25.600", "LastEditorUserId": "341371", "LastActivityDate": "2014-03-05T10:00:54.270", "Score": "12", "OwnerUserId": "341371", "Tags": "<c++><templates><c++11><language-lawyer>", "AnswerCount": "4"}, "15259162": {"Id": "15259162", "PostTypeId": "2", "Body": "<p>When I read this rule I imagine the code similar to the following is at least part of what was being considered:</p>\n<pre><code>int foo(int a; int b){ printf(\"A\"); }\n\nint main(){\n   foo(1, 1.0);\n}\n\nint foo(int a, double b){ printf(\"B\"); }\n</code></pre>\n<p>or</p>\n<pre><code>int foo(int a);\n\nint main(){\n   foo(1);\n}\n\nint foo(int a, double b){ printf(\"B\"); }\n</code></pre>\n", "LastActivityDate": "2013-03-06T22:13:54.670", "CommentCount": "0", "CreationDate": "2013-03-06T22:13:54.670", "ParentId": "15258525", "Score": "1", "OwnerUserId": "141642"}});