post_cb({"11893100": {"Id": "11893100", "PostTypeId": "2", "Body": "<p>On libstdc++'s <code>cmath</code> you will see this:</p>\n<pre><code>using ::log;\n</code></pre>\n<p>So it's bringing in the math.h functions from the global namespace into <code>std</code>. Unfortunately you are supplying an implementation for <code>double log(double)</code>, so the linker will not use the one from the math lib. <strike>So definitely a bug in libstdc++</strike>.</p>\n<p>EDIT: I claim it's a bug in libstdc++ because <code>std::log</code> should not suffer from interferences with the C library when you are explicitly asking for the <code>std::</code> versions. Of course, this way to override standard library functions is an old \"feature\" from the C language.</p>\n<p>EDIT 2: I found out that the standard doesn't actually forbid bringing names from the global namespace into <code>std</code>. So not a bug after all, only a consequence of the implementation details.</p>\n", "LastEditorUserId": "1484212", "LastActivityDate": "2012-08-09T22:58:18.370", "Score": "8", "CreationDate": "2012-08-09T22:47:21.983", "ParentId": "11892976", "CommentCount": "2", "OwnerUserId": "1484212", "LastEditDate": "2012-08-09T22:58:18.370"}, "11893237": {"Id": "11893237", "PostTypeId": "2", "Body": "<p>C++ Standard 17.6.1.2 paragraph 4 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_11892976_11893237_0\">Except as noted in Clauses 18 through 30 and Annex D, the contents of each header <code>cname</code> shall be the same as that of the corresponding header <code>name.h</code>, as specified in the C Standard library (1.2) or the C Unicode TR, as appropriate, as if by inclusion.  In the C++ standard library, however, the declarations (except for names which are defined as macros in C) are within namespace scope (3.3.6) of the namespace <code>std</code>.  <strong>It is unspecified whether these names are first declared within the global namespace scope and are then injected into namespace <code>std</code> by explicit <em>using-declarations</em> (7.3.3).</strong></p>\n</blockquote>\n<p>g++ does it the latter way so that some of the same header files can be reused for C and C++.  So g++ is allowed to declare and define <code>double log(double)</code> in the global namespace.</p>\n<p>Section 17.6.4.3.3 paragraphs 3 and 4:</p>\n<blockquote>\n<p id=\"so_11892976_11893237_1\">Each name from the Standard C library declared with external linkage is reserved to the implementation for use as a name with <code>extern \"C\"</code> linkage, both in namespace <code>std</code> and in the global namespace.</p>\n<p id=\"so_11892976_11893237_2\">Each function signature from the Standard C library declared with external linkage is reserved to the implementation for use as a function signature with both <code>extern \"C\"</code> and <code>extern \"C++\"</code>linkage, or as a name of namespace scope in the global namespace.</p>\n</blockquote>\n<p>And up at the top of Section 17.6.4.3 paragraph 2:</p>\n<blockquote>\n<p id=\"so_11892976_11893237_3\">If a program declares or defines a name in a context where it is reserved, other than as explicitly allowed by this Clause, its behavior is undefined.</p>\n</blockquote>\n<p>You, on the other hand, may <em>not</em> declare or define <code>::log</code> in any way.</p>\n<p>It's too bad the g++ toolchain doesn't give you any error messages, though.</p>\n", "LastActivityDate": "2012-08-09T23:02:46.230", "CommentCount": "1", "CreationDate": "2012-08-09T23:02:46.230", "ParentId": "11892976", "Score": "53", "OwnerUserId": "459640"}, "11892976": {"ViewCount": "1867", "Body": "<p>In the code below, I define a trivial <code>log</code> function. In <code>main</code> I try <em>not</em> to call it; I call <code>std::log</code>. Nevertheless, my own <code>log</code> is called; and I see \"log!\" on screen. Does anyone know why? I use G++ 4.7 and clang++ 3.2.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\ndouble log(const double x) { std::cout &lt;&lt; \"log!\\n\"; return x; }\n\nint main(int argc, char *argv[])\n{\n  std::log(3.14);\n  return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "11893237", "Title": "Why is my log in the std namespace?", "CreationDate": "2012-08-09T22:33:56.230", "Id": "11892976", "CommentCount": "7", "FavoriteCount": "14", "PostTypeId": "1", "LastEditDate": "2012-08-09T22:41:31.810", "LastEditorUserId": "2023370", "LastActivityDate": "2015-05-06T01:51:41.337", "Score": "64", "OwnerUserId": "2023370", "Tags": "<c++><namespaces><overloading>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_11892976_11893237_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 6311}, "so_11892976_11893237_0": {"length": 44, "quality": 0.8979591836734694, "section_id": 6259}, "so_11892976_11893237_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6310}, "so_11892976_11893270_0": {"length": 40, "quality": 0.8163265306122449, "section_id": 6259}, "so_11892976_11893237_3": {"length": 14, "quality": 1.0, "section_id": 6304}}, "n3337": {"so_11892976_11893237_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6067}, "so_11892976_11893237_0": {"length": 44, "quality": 0.8979591836734694, "section_id": 6019}, "so_11892976_11893237_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 6068}, "so_11892976_11893270_0": {"length": 40, "quality": 0.8163265306122449, "section_id": 6019}, "so_11892976_11893237_3": {"length": 14, "quality": 1.0, "section_id": 6061}}, "n4659": {"so_11892976_11893237_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 7820}, "so_11892976_11893237_0": {"length": 41, "quality": 0.8367346938775511, "section_id": 7763}, "so_11892976_11893237_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 7821}, "so_11892976_11893270_0": {"length": 37, "quality": 0.7551020408163265, "section_id": 7763}, "so_11892976_11893237_3": {"length": 14, "quality": 1.0, "section_id": 7814}}}, "11893270": {"Id": "11893270", "PostTypeId": "2", "Body": "<p>In C++, the compiler is free to implement the C library in the global namespace and delegate to it (this is implementation defined).</p>\n<blockquote>\n<p id=\"so_11892976_11893270_0\">17.6.1.2.4 Except as noted in Clauses 18 through 30 and Annex D, the contents of each header cname shall be the same\n  as that of the corresponding header name.h, as speci\ufb01ed in the C standard library (1.2) or the C Unicode\n  TR, as appropriate, as if by inclusion. In the C++ standard library, however, the declarations (except for\n  names which are de\ufb01ned as macros in C) are within namespace scope (3.3.6) of the namespace std. <strong>It is\n  unspeci\ufb01ed whether these names are \ufb01rst declared within the global namespace scope and are then injected\n  into namespace std by explicit using-declarations</strong> (7.3.3).</p>\n</blockquote>\n<p>In general, I'd avoid making a function with the same signature as one of the C standard library's. The C++ standard certainly gives compilers the freedom to be using these signatures if it so chooses, which means you may be fighting your compiler if you try to use the same signatures. Hence, you get weird results.</p>\n<p>I would expect a linker error or warning though, and I think it may be worth reporting this.</p>\n<p>[edit]</p>\n<p>Wow, ninja'd.</p>\n", "LastActivityDate": "2012-08-09T23:06:29.897", "CommentCount": "1", "CreationDate": "2012-08-09T23:06:29.897", "ParentId": "11892976", "Score": "6", "OwnerUserId": "1287251"}, "30066138": {"Id": "30066138", "PostTypeId": "2", "Body": "<p>Because you've overridden it in the global namespace. Using a namespace avoids that danger if you don't want to move on to a safer, cleaner language like <a href=\"http://nim-lang.org/\" rel=\"nofollow\">Nim</a> for example.</p>\n<p><a href=\"http://ideone.com/vSU5tD\" rel=\"nofollow\">Proper use of namespace demo</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;  // Uses ::log, which would be the log() here if it were not in a namespace, see http://stackoverflow.com/questions/11892976/why-is-my-log-in-the-std-namespace\n\n// Silently overrides std::log\n//double log(double d) { return 420; }\n\nnamespace uniquename {\n    using namespace std;  // So we don't have to waste space on std:: when not needed.\n\n    double log(double d) {\n        return 42;\n    }\n\n    int main() {\n        cout &lt;&lt; \"Our log: \" &lt;&lt; log(4.2) &lt;&lt; endl;\n        cout &lt;&lt; \"Standard log: \" &lt;&lt; std::log(4.2);\n        return 0;\n    }\n}\n\n// Global wrapper for our contained code.\nint main() {\n    return uniquename::main();\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Our log: 42\nStandard log: 1.43508\n</code></pre>\n", "LastActivityDate": "2015-05-06T01:51:41.337", "CommentCount": "0", "CreationDate": "2015-05-06T01:51:41.337", "ParentId": "11892976", "Score": "0", "OwnerUserId": "819417"}, "11893089": {"Id": "11893089", "PostTypeId": "2", "Body": "<p>What happens, I expect, is that <code>std::log</code> simply delegates to <code>::log</code>. Unfortunately, <code>::log</code> only provides a <code>float</code> overload, and you kindly provide a <code>double</code> overload, making yours a better match. But I still don't see how it even gets considered in the overload set.</p>\n", "LastActivityDate": "2012-08-09T22:46:28.593", "CommentCount": "4", "CreationDate": "2012-08-09T22:46:28.593", "ParentId": "11892976", "Score": "8", "OwnerUserId": "298661"}});