post_cb({"2598327": {"ParentId": "2598178", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>A close approximation of an anonymous struct is a tuple.  <a href=\"http://www.boost.org/doc/libs/1_42_0/libs/tuple/doc/tuple_users_guide.html\" rel=\"nofollow noreferrer\">Boost::Tuple</a> is available anywhere now, and there's another in TR1 [which I assume is distributed with VS2008] with a near identical interface.</p>\n<pre><code>#include &lt;boost/tuple/tuple.hpp&gt;\n\ntemplate&lt;typename T&gt;\nboost::tuple&lt;T, T&gt;* func(boost::tuple&lt;T, T&gt;* t, float a, float b ) {\n    if(!t) {\n      t = new boost::tuple&lt;T, T&gt;(a, b);\n    } else {\n      boost::get&lt;0&gt;(*t) += a;\n      boost::get&lt;1&gt;(*t) += b;\n    }\n    return t;\n}\n\nboost::tuple&lt;float, float&gt;* foo(float a, float b) {\n    if(a==0) return 0;\n    return func(foo(a-1,b), a, b);\n}\n</code></pre>\n<p>As others have said, the overall scheme is pretty flimsy, but I wanted to focus on the tuple rather than the design.</p>\n", "OwnerUserId": "293791", "LastEditorUserId": "293791", "LastEditDate": "2010-04-08T08:06:35.603", "Id": "2598327", "Score": "1", "CreationDate": "2010-04-08T07:57:57.537", "LastActivityDate": "2010-04-08T08:06:35.603"}, "2598276": {"ParentId": "2598178", "CommentCount": "3", "Body": "<p>I can't think of any reasonable usage. Apart the memory leaks, this is a very unreadable way of achieving the goal you want. It makes your reader think a lot what the code is doing. And also it is not known who should delete 'f' in the main(). And should it be deleted with delete[] or delete?</p>\n<p>I would use a class taking the 'a' and 'b' in the constructor.  It will have two methods for getting the two calculated struct members. And inside the class there will be private mehotds, using plain loops to calculate the things you want. Then your API will look like this:</p>\n<pre><code>void main()\n{\n   MyCalculator myCalc(5, 6);\n   double sumOfAllNumbers = myCalc.getSumOfAllNumbers();\n   double product = myCalc.getProduct();\n}\n</code></pre>\n", "OwnerUserId": "446104", "PostTypeId": "2", "Id": "2598276", "Score": "1", "CreationDate": "2010-04-08T07:40:59.643", "LastActivityDate": "2010-04-08T07:40:59.643"}, "2598178": {"CommentCount": "5", "AcceptedAnswerId": "2598272", "PostTypeId": "1", "LastEditorUserId": "995926", "CreationDate": "2010-04-08T07:18:06.170", "LastActivityDate": "2012-05-02T18:39:19.990", "LastEditDate": "2012-05-02T18:39:19.990", "ViewCount": "899", "FavoriteCount": "2", "Title": "Is there any reasonable use of a function returning an anonymous struct?", "Id": "2598178", "Score": "7", "Body": "<p>Here is an (artificial) example of using a function that returns an anonymous struct and does \"something\" useful:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nT* func(T* t, float a, float b) {\n    if(!t) {\n        t = new T;\n        t-&gt;a = a;\n        t-&gt;b = b;\n    } else {\n        t-&gt;a += a;\n        t-&gt;b += b;\n    }\n    return t;\n}\n\nstruct {\n    float a, b;\n}* foo(float a, float b) {\n    if(a==0) return 0;\n    return func(foo(a-1,b), a, b);\n}\n\nint main() {\n    std::cout &lt;&lt; foo(5,6)-&gt;a &lt;&lt; std::endl;\n    std::cout &lt;&lt; foo(5,6)-&gt;b &lt;&lt; std::endl;\n\n    void* v = (void*)(foo(5,6));\n    //[1] delete f now because I know struct is floats only.\n    float* f = (float*)(v);\n\n    std::cout &lt;&lt; f[0] &lt;&lt; std::endl;\n    std::cout &lt;&lt; f[1] &lt;&lt; std::endl;\n\n    delete[] f;\n\n    return 0;\n}\n</code></pre>\n<p>There are a few points I would like to discuss:</p>\n<ol>\n<li>As is apparent, this code leaks, is there anyway I can NOT leak without knowing what the underlying struct definition is? see Comment [1].</li>\n<li>I have to return a pointer to an anonymous struct so I can create an instance of the object within the templatized function <code>func</code>, can I do something similar without returning a pointer?</li>\n<li>I guess the most important, is there ANY (real-world) use for this at all? As the example given above leaks and is admittedly contrived.</li>\n</ol>\n<p>By the way, what the function <code>foo(a,b)</code> does is, to return a struct containing two numbers, the sum of all numbers from 1 to a and the product of a and b. </p>\n<p>Maybe the line <code>new T</code> could use a boost::shared_ptr somehow to avoid leaks, but I haven't tried that. Would that work? </p>\n<p>I think I was just trying to delete the anonymous struct as an array of floats, something like float* f = new float[2]. Which might be wrong, as the comment below suggests, so what can be done? can I delete at all?</p>\n<p>I can compile and run this code \"as-is\" on VS2008, maybe some non-standard extensions might be being used by VS, but it does run and gives 15 and 30 as the answer. </p>\n<p>From the answers I believe this contraption is a VS2008 specific entity, it is not standards compliant and thus not portable. Too bad though, I would have liked to see what voodoo the Stackoverflow or Boost people came up with if this was in their arsenal :). Thanks all.</p>\n", "Tags": "<c++><templates><memory-leaks><anonymous-types>", "OwnerUserId": "294864", "AnswerCount": "5"}, "2598300": {"ParentId": "2598178", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>What you are doing is not possible in standard C++ - type definitions are not allowed in return types as per <em>\u00a78.3.5/6</em> (function declarators, C++03):</p>\n<blockquote>\n<p id=\"so_2598178_2598300_0\">Types shall not be defined in return or parameter types.</p>\n</blockquote>\n<p>Visual Studio is non-compliant in this case.</p>\n", "OwnerUserId": "168225", "LastEditorUserId": "168225", "LastEditDate": "2010-04-08T07:53:29.673", "Id": "2598300", "Score": "5", "CreationDate": "2010-04-08T07:48:06.460", "LastActivityDate": "2010-04-08T07:53:29.673"}, "2598273": {"ParentId": "2598178", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>C++ Standard does not allow anonymous structures.</p>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2010-04-08T07:51:23.517", "Id": "2598273", "Score": "3", "CreationDate": "2010-04-08T07:40:01.843", "LastActivityDate": "2010-04-08T07:51:23.517"}, "bq_ids": {"n4140": {"so_2598178_2598300_0": {"section_id": 3245, "quality": 1.0, "length": 5}, "so_2598178_2598272_0": {"section_id": 7141, "quality": 0.6153846153846154, "length": 8}}, "n3337": {"so_2598178_2598300_0": {"section_id": 3118, "quality": 1.0, "length": 5}, "so_2598178_2598272_0": {"section_id": 6885, "quality": 0.6153846153846154, "length": 8}}, "n4659": {"so_2598178_2598300_0": {"section_id": 4003, "quality": 1.0, "length": 5}, "so_2598178_2598272_0": {"section_id": 8642, "quality": 0.6153846153846154, "length": 8}}}, "2598272": {"ParentId": "2598178", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>For now, your code is not portable; it will, for example, not build with <code>gcc</code>.</p>\n<p>Section 14.3.1/2 of the standard says:</p>\n<blockquote>\n<p id=\"so_2598178_2598272_0\">A  local  type,  a  type  with  no \n  linkage, <strong>an unnamed type</strong> or a type<br>\n  compounded from any of these types\n  <strong>shall not be used  as  a  template-<br>\n  argument</br></strong> for a template\n  type-parameter.</br></p>\n</blockquote>\n<p>See item 488 in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#488\" rel=\"nofollow noreferrer\">C++ Standard Core Language Defect Reports, Revision 69</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2657.htm\" rel=\"nofollow noreferrer\">Paper N2657</a> for one possible evolution.</p>\n<h3>UPDATE 1</h3>\n<p>Assuming that your code were well-formed, then:</p>\n<ol>\n<li><p>you may be able to rewrite:</p>\n<pre><code>std::cout &lt;&lt; foo(5,6)-&gt;a &lt;&lt; std::endl;\n</code></pre>\n<p>as</p>\n<pre><code>std::cout &lt;&lt; std::auto_ptr(foo(5,6))-&gt;a &lt;&lt; std::endl;\n</code></pre></li>\n<li><p>you may return an anonymous <code>struct</code> by-value provided that the anonymous struct had a constructor taking another type (anonymous or not, that you'd be able to initialize inside the body of your method) -- except, of course, how do you specify a constructor for an anonymous struct? :)</p></li>\n<li><p>no real-world use that I can see other than an extremely convoluted way of trying not to assign an explicit name to the structure; one would typically use anonymous structs (not technically legal in C++, but supported by various compilers as extensions) in order to not pollute the namespace, typically by instantiating one right away (you may for example see one-shot functors being instantiated and passed down as anonymous structs -- again, technically not legal C++.)</p></li>\n</ol>\n<h3>UPDATE 2</h3>\n<p>Thank you <code>gf</code> for the link to the relevant portion of the C++ standard concerning new types which may not be defined in a return type.</p>\n<h3>UPDATE 3</h3>\n<p>Bringing this one out here from the comments: calling <code>delete[]</code> on memory allocated with <code>new</code> (as opposed to <code>new[]</code>) is an invitation to heap corruption.  Calling <code>delete</code> on a pointer whose type you do not know is technically undefined (which destructor should get called?) but in the case of PODs (your anonymous struct being one) you can get away with it in this <strong>horrible</strong> hackish way:</p>\n<pre><code> delete (int*)f;\n</code></pre>\n<p>Of course, were your code magically well-formed, <code>std::auto_ptr</code> would have been able to retain the anonymous type and would have taken care of calling <code>delete</code> for you correctly and gracefully.</p>\n", "OwnerUserId": "66516", "LastEditorUserId": "66516", "LastEditDate": "2010-04-08T08:27:54.490", "Id": "2598272", "Score": "9", "CreationDate": "2010-04-08T07:39:59.643", "LastActivityDate": "2010-04-08T08:27:54.490"}});