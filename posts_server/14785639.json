post_cb({"14789387": {"Id": "14789387", "PostTypeId": "2", "Body": "<p>You're right, he's wrong. Accesses to distinct volatile variables cannot be reordered by the compiler as long as they occur in separate full expressions i.e. are separated by what C++98 called a sequence point, or in C++11 terms one access is sequenced before the other. </p>\n<p>Chisnall seems to be trying to explain why <code>volatile</code> is useless for writing thread-safe code, by showing a simple mutex implementation relying on <code>volatile</code> that would be broken by compiler reorderings.  He's right that <code>volatile</code> is useless for thread-safety, but not for the reasons he gives. It's not because the compiler might reorder accesses to <code>volatile</code> objects, but because the CPU might reorder them. Atomic operations and memory barriers prevent the compiler <em>and</em> the CPU from reordering things across the barrier, as needed for thread-safety.</p>\n<p>See the bottom right cell of Table 1 at Sutter's informative <a href=\"http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484\" rel=\"nofollow\">volatile vs volatile</a> article.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-02-09T15:10:53.547", "Score": "2", "CreationDate": "2013-02-09T15:03:19.243", "ParentId": "14785639", "CommentCount": "9", "OwnerUserId": "981959", "LastEditDate": "2013-02-09T15:10:53.547"}, "14785661": {"Id": "14785661", "PostTypeId": "2", "Body": "<p>Looks like it can happen.</p>\n<p>There is a discussion on this page:</p>\n<p><a href=\"http://gcc.gnu.org/ml/gcc/2003-11/msg01419.html\" rel=\"nofollow\">http://gcc.gnu.org/ml/gcc/2003-11/msg01419.html</a></p>\n", "LastActivityDate": "2013-02-09T06:39:36.113", "CommentCount": "1", "CreationDate": "2013-02-09T06:39:36.113", "ParentId": "14785639", "Score": "0", "OwnerUserId": "2052947"}, "14785753": {"Id": "14785753", "PostTypeId": "2", "Body": "<p>It depends on your compiler. For example, MSVC++ as of Visual Studio 2005 guarantees* volatiles will not be reordered (actually, what Microsoft did is give up and assume programmers will forever abuse <code>volatile</code> - MSVC++ now adds a memory barrier around certain usages of <code>volatile</code>). Other versions and other compilers may not have such guarantees.</p>\n<p>Long story short: don't bet on it. Design your code properly, and don't misuse volatile. Use memory barriers instead or full-blown mutexes as necessary. C++11's <code>atomic</code> types will help.</p>\n", "LastActivityDate": "2013-02-09T06:56:23.413", "CommentCount": "2", "CreationDate": "2013-02-09T06:56:23.413", "ParentId": "14785639", "Score": "0", "OwnerUserId": "17027"}, "14785760": {"Id": "14785760", "PostTypeId": "2", "Body": "<p>For the moment, I'm going to assume your <code>a=3</code>s are just a mistake in copying and pasting, and you really meant them to be <code>c=3</code>.</p>\n<p>The real question here is one of the difference between evaluation, and how things become visible to another processor. The standards describe order of evaluation. From that viewpoint, you're entirely correct -- given assignments to <code>a</code>, <code>b</code> and <code>c</code> in that order, the assignments must be evaluated in that order.</p>\n<p>That may <em>not</em> correspond to the order in which those values become visible to other processors though. On a typical (current) CPU, that evaluation will only write values out to the cache. The hardware can reorder things from there though, so (for example) writes out to main memory happen in an entirely different order. Likewise, if another processor attempts to use the values, it may see them as changing in a different order.</p>\n<p>Yes, this is entirely allowable -- the CPU is still evaluating the assignments in exactly the order prescribed by the standard, so the requirements are met. The standard simply doesn't place any requirements on what happens after evaluation, which is what happens here.</p>\n<p>I should add: on some hardware it is sufficient though. For example, the x86 uses cache snooping, so if another processor tries to read a value that's been updated by one processor (but is still only in the cache) the processor that has the current value will put a hold on the read by the other processor until the current value can be written out so the other processor will see the current value.</p>\n<p>That's not the case with all hardware though. While maintaining that strict model keeps things simple, it's also fairly expensive both in terms of extra hardware to ensure consistency and in simple speed when/if you have a lot of processors.</p>\n<p>Edit: if we ignore threading for a moment, the question gets a little simpler -- but not much. According to C++11, \u00a71.9/12:</p>\n<blockquote>\n<p id=\"so_14785639_14785760_0\">When a call to a library I/O function returns or an access to a volatile object is evaluated the side effect is considered complete, even though some external actions implied by the call (such as the I/O itself) or by the volatile access may not have completed yet.</p>\n</blockquote>\n<p>As such, the accesses to volatile objects must be <em>initiated</em> in order, but not necessarily <em>completed</em> in order. Unfortunately, it's often the completion that's externally visible. As such, we pretty much come back to the usual as-if rule: the compiler can rearrange things as much as it wants, as long it produces no externally visible change.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2013-02-09T07:45:09.207", "Score": "0", "CreationDate": "2013-02-09T06:57:38.550", "ParentId": "14785639", "CommentCount": "1", "OwnerUserId": "179910", "LastEditDate": "2013-02-09T07:45:09.207"}, "bq_ids": {"n4140": {"so_14785639_14785639_1": {"length": 10, "quality": 1.0, "section_id": 5797}, "so_14785639_14785639_2": {"length": 9, "quality": 1.0, "section_id": 5804}, "so_14785639_14785760_0": {"length": 27, "quality": 1.0, "section_id": 5808}}, "n3337": {"so_14785639_14785639_1": {"length": 10, "quality": 1.0, "section_id": 5570}, "so_14785639_14785639_2": {"length": 9, "quality": 1.0, "section_id": 5577}, "so_14785639_14785760_0": {"length": 27, "quality": 1.0, "section_id": 5581}}, "n4659": {"so_14785639_14785639_1": {"length": 10, "quality": 1.0, "section_id": 7256}, "so_14785639_14785639_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 7262}, "so_14785639_14785760_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 7269}}}, "14785639": {"ViewCount": "659", "Body": "<p>Consider the following sequence of writes to <code>volatile</code> memory, which I've taken from <a href=\"http://www.informit.com/articles/article.aspx?p=1832575\" rel=\"noreferrer\">David Chisnall's article at InformIT</a>, \"Understanding C11 and C++11 Atomics\":</p>\n<pre><code>volatile int a = 1;\nvolatile int b = 2;\n             a = 3;\n</code></pre>\n<p>My understanding from C++98 was that these operations could not be reordered, per C++98 1.9:</p>\n<blockquote>\n<p id=\"so_14785639_14785639_0\">conforming\n  implementations are required to emulate (only) the observable behavior of the abstract machine as\n  explained below\n  ...\n  The observable behavior of the abstract machine is its sequence of reads and writes to volatile data and\n  calls to library I/O functions</p>\n</blockquote>\n<p>Chisnall says that the constraint on order preservation applies only to individual variables, writing that a conforming implementation could generate code that does this:</p>\n<pre><code>a = 1;\na = 3;\nb = 2;\n</code></pre>\n<p>Or this:</p>\n<pre><code>b = 2;\na = 1;\na = 3;\n</code></pre>\n<p>C++11 repeats the C++98 wording that</p>\n<blockquote>\n<p id=\"so_14785639_14785639_1\">conforming\n  implementations are required to emulate (only) the observable behavior of the abstract machine as explained\n  below.</p>\n</blockquote>\n<p>but says this about <code>volatile</code>s (1.9/8):</p>\n<blockquote>\n<p id=\"so_14785639_14785639_2\">Access to volatile objects are evaluated strictly according to the rules of the abstract machine.</p>\n</blockquote>\n<p>1.9/12 says that accessing a <code>volatile</code> glvalue (which includes the variables <code>a</code>, <code>b</code>, and <code>c</code> above) is a side effect, and 1.9/14 says that the side effects in one full expression (e.g., a statement) must precede the side effects of a later full expression in the same thread.  This leads me to conclude that the two reorderings Chisnall shows are invalid, because they do not correspond to the ordering dictated by the abstract machine.  </p>\n<p>Am I overlooking something, or is Chisnall mistaken?</p>\n<p>(Note that this is not a threading question.  The question is whether a compiler is permitted to reorder accesses to different <code>volatile</code> variables in a single thread.)</p>\n", "AcceptedAnswerId": "14787771", "Title": "May accesses to volatiles be reordered?", "CreationDate": "2013-02-09T06:37:16.147", "Id": "14785639", "CommentCount": "1", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2013-02-09T07:15:29.753", "LastEditorUserId": "1426649", "LastActivityDate": "2013-02-10T22:16:15.727", "Score": "10", "OwnerUserId": "1426649", "Tags": "<c++><c++11><volatile>", "AnswerCount": "6"}, "14787771": {"Id": "14787771", "PostTypeId": "2", "Body": "<p>IMO Chisnalls interpretation (as presented by you) is clearly wrong. The simpler case is C++98. The <code>sequence of reads and writes to volatile data</code> needs to be preserved and that applies to the ordered sequence of reads and writes of any volatile data, not to a single variable.</p>\n<p>This becomes obvious, if you consider the original motivation for volatile: memory-mapped I/O. In mmio you typically have several related registers at different memory location and the protocol of an I/O device requires a specific sequence of reads and writes to its set of registers - order between registers is important.</p>\n<p>The C++11 wording avoids talking about an absolute <code>sequence of reads and writes</code>, because in multi-threaded environments there is not one single well-defined sequence of such events across threads - and that is not a problem, if these accesses go to independent memory locations. But I believe the intent is that for any sequence of volatile data accesses with a well-defined order the rules remain the same as for C++98 - the order must be preserved, no matter how many different locations are accessed in that sequence.</p>\n<p>It is an entirely separate issue what that entails for an implementation. How (and even <strong>if</strong>) a volatile data access is observable from outside the program and how the access order of the program maps to externally observable events is unspecified. An implementation should probably give you a reasonable interpretation and reasonable guarantees, but what is reasonable depends on the context.</p>\n<p>The C++11 standard leaves room for data races between unsynchronized volatile accesses, so there is nothing that requires surrounding these by full memory fences or similar constructs. If there are parts of memory that are truly used as external interface - for memory-mapped I/O or DMA - then it may be reasonable for the implementation to give you guarantees for how volatile accesses to these parts are exposed to consuming devices.</p>\n<p>One guarantee can probably be inferred from the standard (see [into.execution]): values of type <code>volatile std::sigatomic_t</code> must have values compatible with the order of writes to them even in a signal handler - at least in a single-threaded program.</p>\n", "LastEditorUserId": "585729", "LastActivityDate": "2013-02-09T12:05:41.860", "Score": "4", "CreationDate": "2013-02-09T11:45:51.217", "ParentId": "14785639", "CommentCount": "3", "OwnerUserId": "585729", "LastEditDate": "2013-02-09T12:05:41.860"}, "14785726": {"Id": "14785726", "PostTypeId": "2", "Body": "<p>C++98 doesn't say the instructions cannot be re-ordered.</p>\n<blockquote>\n<p id=\"so_14785639_14785726_0\">The observable behavior of the abstract machine is its sequence of reads and writes to volatile data and calls to library I/O functions</p>\n</blockquote>\n<p>This says it's the actual sequence of the reads and writes themselves, not the instructions that generate them. Any argument that says that the instructions must reflect the reads and writes in program order could equally argue that the reads and writes to the RAM itself must occur in program order, and clearly that's an absurd interpretation of the requirement.</p>\n<p>Simply put, this doesn't mean anything. There is no \"one right place\" to observe the orders of reads and writes (The RAM bus? The CPU bus? Between the L1 and L2 caches? From another thread? From another core?), so this requirement is essentially meaningless.</p>\n<p>Versions of C++ prior to any references to threads clearly don't specify the behavior of volatile variables as seen from another thread. And C++11 (wisely, IMO) <a href=\"https://stackoverflow.com/a/12878500/721269\">didn't change this</a> but instead introduced sensible atomic operations with well-defined inter-thread semantics.</p>\n<p>As for memory-mapped hardware, that's always going to be platform-specific. The C++ standard doesn't even pretend to address how that might be done properly. For example, the platform might be such that only a subset of memory operations are legal in that context, say ones that bypass a write posting buffer that can reorder, and the C++ standard certainly doesn't compel the compiler to emit the right instructions for that particular hardware device -- how could it?</p>\n<p><strong>Update</strong>: I see some downvotes because people don't like this truth. Unfortunately, it is true. </p>\n<p>If the C++ standard prohibits the compiler from reordering accesses to distinct volatiles, on the theory that the order of such accesses is part of the program's observable behavior, then it also requires the compiler to emit code that prohibits the CPU from doing so. The standard does not differentiate between what the compiler does and what the compiler's generated code makes the CPU do.</p>\n<p>Since nobody believes the standard requires the compiler to emit instructions to keep the CPU from reordering accesses to volatile variables, and modern compilers don't do this, nobody should believe the C++ standard prohibits the compiler from reordering accesses to distinct volatiles.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-10T22:16:15.727", "Score": "-2", "CreationDate": "2013-02-09T06:52:38.017", "ParentId": "14785639", "CommentCount": "8", "OwnerUserId": "721269", "LastEditDate": "2017-05-23T12:02:34.313"}});