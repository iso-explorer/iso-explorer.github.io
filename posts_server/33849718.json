post_cb({"33849718": {"CommentCount": "5", "AcceptedAnswerId": "33849802", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-11-21T23:11:05.793", "LastActivityDate": "2017-02-05T22:17:46.547", "LastEditDate": "2017-05-23T10:29:29.537", "ViewCount": "237", "FavoriteCount": "3", "Title": "how is this lambda with an empty capture list able to refer to reaching-scope name?", "Id": "33849718", "Score": "6", "Body": "<p>In the C++14 standard \u00a7 5.1.2/12 it shows an example of a lambda expression that apparently seems to be able to refer to a reaching scope's variable <code>x</code>, even though:</p>\n<ol>\n<li>the capture list is empty, i.e. no capture-default</li>\n<li>the comment says that it \"does not capture <code>x</code>\"</li>\n</ol>\n<p>Here's the example:</p>\n<pre><code>void f(int, const int (&amp;)[2] = {}) { } // #1\nvoid test() {\n  const int x = 17;\n  auto g = [](auto a) {\n    f(x); // OK: calls #1, does not capture x\n  };\n}\n</code></pre>\n<p>See that it <a href=\"https://ideone.com/eglPPs\" rel=\"nofollow noreferrer\">does compile</a>. It seems to hinge on <code>x</code> being <code>const</code>; if the <code>const</code> is removed, it no longer compiles for the reasons one would expect (capture list is empty). It happens even if I make the parameter be <code>int</code> so that it's no longer a generic lambda.</p>\n<p>How is it possible for the lambda to refer to <code>x</code> even though the capture list is empty? And how is this possible while at the same time apparently <em>not</em> capturing <code>x</code> (as the comment says)?</p>\n<p>The closest thing I found on this subject was someone else tangentially <a href=\"https://stackoverflow.com/questions/28141403/generic-lambda-with-stdfunction-does-not-capture-variables#comment44655433_28141551\">noticing</a> this in a comment.</p>\n<p>Here's the full section 5.1.2/12 from the standard:</p>\n<blockquote>\n<p id=\"so_33849718_33849718_0\">A <em>lambda-expression</em> with an associated <em>capture-default</em> that does not explicitly capture <code>this</code> or a variable with automatic storage duration (this excludes any <em>id-expression</em> that has been found to refer to an <em>init-capture</em>\u2019s associated non-static data member), is said to <em>implicitly capture</em> the entity (i.e., <code>this</code> or a variable) if the <em>compound-statement</em>:</p>\n<ul>\n<li>odr-uses (3.2) the entity, or</li>\n<li>names the entity in a potentially-evaluated expression (3.2) where the enclosing full-expression depends on a generic lambda parameter declared within the reaching scope of the <em>lambda-expression</em>.</li>\n</ul>\n<p id=\"so_33849718_33849718_1\">[ <em>Example:</em></p>\n<pre><code>void f(int, const int (&amp;)[2] = {}) { } // #1\nvoid f(const int&amp;, const int (&amp;)[1]) { } // #2\nvoid test() {\n  const int x = 17;\n  auto g = [](auto a) {\n    f(x); // OK: calls #1, does not capture x\n  };\n\n  auto g2 = [=](auto a) {\n    int selector[sizeof(a) == 1 ? 1 : 2]{};\n    f(x, selector); // OK: is a dependent expression, so captures x\n  };\n}\n</code></pre>\n<p id=\"so_33849718_33849718_2\">\u2014<em>end example</em> ] All such implicitly captured entities shall be declared within the reaching scope of the lambda expression. [ <em>Note</em>: The implicit capture of an entity by a nested <em>lambda-expression</em> can cause its implicit capture by the containing <em>lambda-expression</em> (see below). Implicit odr-uses of this can result in implicit capture. \u2014<em>end note</em> ]</p>\n</blockquote>\n", "Tags": "<c++><lambda><c++14><language-lawyer>", "OwnerUserId": "101090", "AnswerCount": "1"}, "33849802": {"ParentId": "33849718", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You have the right quote. A variable needs to be captured if it is <em>odr-used</em>. <a href=\"http://en.cppreference.com/w/cpp/language/definition\">ODR-use</a> means basically that the variable is used in a context where it needs a definition. So either its address is taken, or a reference is taken to it, etc. One key exception is, from [basic.def.odr]:</p>\n<blockquote>\n<p id=\"so_33849718_33849802_0\">A variable <code>x</code> whose name appears as a potentially-evaluated expression <code>ex</code> is <em>odr-used</em> by <code>ex</code> <strong>unless applying\n  the lvalue-to-rvalue conversion (4.1) to <code>x</code> yields a constant expression (5.20)</strong> that does not invoke any nontrivial\n  functions and, if <code>x</code> is an object, <code>ex</code> is an element of the set of potential results of an expression <code>e</code>, where either the lvalue-to-rvalue conversion (4.1) is applied to e, or e is a discarded-value expression (Clause\n  5).</p>\n</blockquote>\n<p>So in your example, applying lvalue-to-rvalue conversion on <code>x</code> yields a constant expression (since <code>x</code> is a constant integral), so it's not odr-used. Since it's not odr-used, it doesn't have to be captured.</p>\n<p>On the other hand, if <code>x</code> were bound to a reference (e.g. <code>f</code> took its argument as <code>const int&amp;</code>), then it <em>would</em> be odr-used, and so would have to be captured. In the second example presented, <code>x</code>'s \"odr-use-ness\" is <em>dependent</em> on what the generic lambda argument is, so that is considered captured anyway for sanity's sake. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-11-21T23:54:45.143", "Id": "33849802", "Score": "10", "CreationDate": "2015-11-21T23:20:15.337", "LastActivityDate": "2015-11-21T23:54:45.143"}, "bq_ids": {"n4140": {"so_33849718_33849802_0": {"section_id": 7040, "quality": 0.9375, "length": 30}, "so_33849718_33849718_2": {"section_id": 5971, "quality": 0.8378378378378378, "length": 31}, "so_33849718_33849718_0": {"section_id": 5971, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_33849718_33849718_2": {"section_id": 5739, "quality": 0.7567567567567568, "length": 28}}, "n4659": {"so_33849718_33849802_0": {"section_id": 8537, "quality": 0.9375, "length": 30}, "so_33849718_33849718_2": {"section_id": 7470, "quality": 0.8378378378378378, "length": 31}, "so_33849718_33849718_0": {"section_id": 7470, "quality": 0.9230769230769231, "length": 24}}}});