post_cb({"3368191": {"ParentId": "3368129", "LastEditDate": "2010-07-30T02:04:42.347", "CommentCount": "1", "CreationDate": "2010-07-30T01:38:20.167", "OwnerUserId": "39375", "LastEditorUserId": "39375", "PostTypeId": "2", "Id": "3368191", "Score": "10", "Body": "<p>When the standard says \"no diagnostic required\", that means that the compiler does not have to produce an error or warning about the invalid code, but that the code's behavior is still undefined according to the standard and so it won't necessarily have predictable results. This is intended to make things easier on compiler-writers so that they are not obligated to detect relatively rare or particularly troublesome-to-detect sorts of programmer errors. </p>\n<p>However, when a rule with \"no diagnostic required\" is violated, the compiler is not <em>prohibited</em> from detecting the invalid code and producing an error as a courtesy to the user. So in the example given, gcc is producing a courtesy diagnostic for one particular sort of invalid code, and Comeau is producing a courtesy diagnostic for a similar sort of invalid code. But neither diagnostic is required, so in neither case is the other compiler in violation of the standard by not producing an error message. The behavior of the code remains undefined in any case.</p>\n<p>Several relevant standards quotations regarding class names and template names:</p>\n<p>3.4/1</p>\n<blockquote>\n<p id=\"so_3368129_3368191_0\">The name lookup rules apply uniformly\n  to all names (including typedef-names\n  (7.1.3), namespace-names (7.3) and\n  class-names (9.1)) wherever the\n  grammar allows such names in the\n  context discussed by a particular\n  rule. Name lookup associates the use\n  of a name with a declaration (3.1) of\n  that name. Name lookup shall find an\n  unambiguous declaration for the name\n  (see 10.2). [...]</p>\n</blockquote>\n<p>7.1.3/3</p>\n<blockquote>\n<p id=\"so_3368129_3368191_1\">In a given scope, a typedef specifier\n  shall not be used to redefine the name\n  of any type declared in that scope to\n  refer to a different type. [Example:</p>\n</blockquote>\n<pre><code>class complex { /* ... */ }; \ntypedef int complex; // error: redefinition\n</code></pre>\n<blockquote>\n<p id=\"so_3368129_3368191_2\">\u2014end example] Similarly, in a given\n  scope, a class or enumeration shall\n  not be declared with the same name as\n  a typedef-name that is declared in\n  that scope and refers to a type other\n  than the class or enumeration itself. [...]</p>\n</blockquote>\n<p>9.1/2</p>\n<blockquote>\n<p id=\"so_3368129_3368191_3\">A class definition introduces the\n  class name into the scope where it is\n  defined and hides any class, object,\n  function, or other declaration of that\n  name in an enclosing scope (3.3). If a\n  class name is declared in a scope\n  where an object, function, or\n  enumerator of the same name is also\n  declared, then when both declarations\n  are in scope, the class can be\n  referred to only using an\n  elaborated-type-specifier (3.4.4).</p>\n</blockquote>\n<p>14/5</p>\n<blockquote>\n<p id=\"so_3368129_3368191_4\">A class template shall not have the\n  same name as any other template,\n  class, function, object, enumeration,\n  enumerator, namespace, or type in the\n  same scope (3.3), except as specified\n  in (14.5.4). Except that a function\n  template can be overloaded either by\n  (non-template) functions with the same\n  name or by other function templates\n  with the same name (14.8.3), a\n  template name declared in namespace\n  scope or in class scope shall be\n  unique in that scope.</p>\n</blockquote>\n<p>14.5.4/1</p>\n<blockquote>\n<p id=\"so_3368129_3368191_5\">A primary class template declaration\n  is one in which the class template\n  name is an identifier. A template\n  declaration in which the class\n  template name is a template-id, is a\n  partial specialization of the class\n  template named in the template-id. A\n  partial specialization of a class\n  template provides an alternative\n  definition of the template that is\n  used instead of the primary definition\n  when the arguments in a specialization\n  match those given in the partial\n  specialization (14.5.4.1). [...]</p>\n</blockquote>\n<p>So, in summary:</p>\n<ul>\n<li><code>typedef</code>s cannot change the meaning of an existing type</li>\n<li><code>class</code> names can conflict with certain sorts of names, but not other class names</li>\n<li><code>template</code> class names do not include the template parameter, and cannot conflict with anything, even things that normal class names are allowed to conflict with</li>\n<li>template specializations are considered to have the same <em>template-id</em> (name) as their corresponding generalized template, but they are (obviously) not the same type.</li>\n</ul>\n<p>So there's a conflict in both directions here. The <code>template</code> name is not allowed to conflict with anything, and the <code>typedef</code> is not allowed to change <code>A</code> from a template class type to a specialization of a template class type. </p>\n", "LastActivityDate": "2010-07-30T02:04:42.347"}, "bq_ids": {"n4140": {"so_3368129_3368191_2": {"section_id": 5413, "quality": 0.9, "length": 18}, "so_3368129_3368191_5": {"section_id": 135, "quality": 0.8780487804878049, "length": 36}, "so_3368129_3368191_3": {"section_id": 5857, "quality": 0.8780487804878049, "length": 36}, "so_3368129_3368191_0": {"section_id": 7083, "quality": 0.918918918918919, "length": 34}, "so_3368129_3368191_1": {"section_id": 5412, "quality": 0.9230769230769231, "length": 12}, "so_3368129_3368191_4": {"section_id": 52, "quality": 0.9318181818181818, "length": 41}}, "n3337": {"so_3368129_3368191_2": {"section_id": 5208, "quality": 0.9, "length": 18}, "so_3368129_3368191_5": {"section_id": 129, "quality": 0.8780487804878049, "length": 36}, "so_3368129_3368191_3": {"section_id": 5627, "quality": 0.8780487804878049, "length": 36}, "so_3368129_3368191_0": {"section_id": 6827, "quality": 0.918918918918919, "length": 34}, "so_3368129_3368191_1": {"section_id": 5207, "quality": 0.9230769230769231, "length": 12}, "so_3368129_3368191_4": {"section_id": 47, "quality": 0.9318181818181818, "length": 41}}, "n4659": {"so_3368129_3368191_2": {"section_id": 6835, "quality": 0.9, "length": 18}, "so_3368129_3368191_5": {"section_id": 139, "quality": 0.8780487804878049, "length": 36}, "so_3368129_3368191_3": {"section_id": 7336, "quality": 0.8780487804878049, "length": 36}, "so_3368129_3368191_0": {"section_id": 8584, "quality": 0.7567567567567568, "length": 28}, "so_3368129_3368191_1": {"section_id": 6834, "quality": 0.9230769230769231, "length": 12}, "so_3368129_3368191_4": {"section_id": 53, "quality": 0.9318181818181818, "length": 41}}}, "3368129": {"CommentCount": "0", "ViewCount": "2012", "CreationDate": "2010-07-30T01:16:44.153", "LastActivityDate": "2010-07-30T02:04:42.347", "Title": "Declaring types and templates with the same name in C++", "AcceptedAnswerId": "3368191", "PostTypeId": "1", "Id": "3368129", "Score": "4", "Body": "<p>This is an academic question.</p>\n<p>In the report for <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38764\" rel=\"nofollow noreferrer\">GCC bug 38764</a>, there are the following examples:</p>\n<pre><code>template &lt; class T &gt; struct A {};\ntypedef A&lt; float &gt; A; // Accepted by Comeau, but not GCC\ntypedef ::A&lt; float &gt; A; // Accepted by GCC but not Comeau\n</code></pre>\n<p>I see why the code may be invalid, but I have trouble with one of the comments:</p>\n<blockquote>\n<p id=\"so_3368129_3368129_0\"><em>This code is invalid but the standard says for this case no diagnostic is required so both compilers are correct according to the standard.</em></p>\n</blockquote>\n<p>Why is the code that is \"invalid\" accepted by the standard as valid? What does the standard say about this case in particular (template + type with the same name) and, in general, about namespaces for various entities (types, templates, functions, variables)?</p>\n", "Tags": "<c++>", "OwnerUserId": "23643", "AnswerCount": "2"}, "3368187": {"ParentId": "3368129", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_3368129_3368187_0\">Why is the code that is \"invalid\" accepted by the standard as valid?</p>\n</blockquote>\n<p>It isn't.  If the code is invalid, then it is invalid.</p>\n<p>The phrase <em>no diagnostic required</em> when applied to a syntax or semantic rule means that if your program violates the rule, the compiler doesn't have to issue an error message and it can continue compiling the program (or it can do anything else, really; the standard imposes no requirements on a compiler if you give it a program that violates such a rule).</p>\n<p>In a sense, <em>no diagnostic required</em> is sort of like the <em>undefined behavior</em> of semantic rules:  if you violate a rule for which no diagnostic is required, all bets are off.</p>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "3368187", "Score": "4", "CreationDate": "2010-07-30T01:37:19.547", "LastActivityDate": "2010-07-30T01:37:19.547"}});