post_cb({"45972392": {"CommentCount": "10", "AcceptedAnswerId": "45973336", "CreationDate": "2017-08-31T02:39:58.323", "LastActivityDate": "2017-09-07T05:11:42.833", "PostTypeId": "1", "ViewCount": "82", "FavoriteCount": "1", "Title": "Does std::atomic provide atomic behavior, regardless of ordering?", "Id": "45972392", "Score": "3", "Body": "<p>If a variable is declared with the <code>std::atomic</code> template, such as <code>std::atomic&lt;int&gt;</code>, is it guaranteed that access via the methods in <code>std::atomic</code> will result in a <em>consistent</em> value (that is, one written by a write through the <code>std::atomic</code> methods) regardless of ordering?</p>\n<p>As far as I know, this equivalent to asking whether <em>reads</em> or <em>writes</em> can be \"torn\" - that is, written or real in multiple parts visible at the ISA level.</p>\n", "Tags": "<c++><concurrency><memory-model><stdatomic>", "OwnerUserId": "149138", "AnswerCount": "1"}, "45973336": {"ParentId": "45972392", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Atomic, <a href=\"https://en.wiktionary.org/wiki/atom#Etymology_2\" rel=\"nofollow noreferrer\">from the Greek <em>atom</em> meaning <em>indivisible</em></a>, is synonymous with \"no tearing\".  It means that the entire operation happens indivisbly. \n Everything you can do with a <code>std::atomic</code> type is always atomic (no tearing).</p>\n<p><a href=\"https://stackoverflow.com/a/4653479/224132\">C++14 draft N4140</a> section <em>29.3 Order and consistency</em> is the first part of that chapter that gets down to details.  One of the very first points is (1.4):</p>\n<blockquote>\n<p id=\"so_45972392_45973336_0\">[ Note: Atomic operations specifying <code>memory_order_relaxed</code> are relaxed with respect to memory ordering.\n  <strong>Implementations must still guarantee that any given atomic access to a particular atomic object be indivisible\n  with respect to all other atomic accesses to that object</strong>. \u2014 end note ]</p>\n</blockquote>\n<p>As far as technical language that lays out the atomicity requirement, every operation (like <code>.store()</code>, <code>.load()</code>, <code>.fetch_add()</code>) is defined with language like:</p>\n<blockquote>\n<p id=\"so_45972392_45973336_1\">\u00a7 <strong>29.6.5 Requirements for operations on atomic types</strong></p>\n<pre><code>void atomic_store(volatile A * object, C desired) noexcept;\nvoid atomic_store(A * object, C desired) noexcept;\nvoid atomic_store_explicit(volatile A * object, C desired, memory_order order) noexcept;\nvoid atomic_store_explicit(A * object, C desired, memory_order order) noexcept;\nvoid A ::store(C desired, memory_order order = memory_order_seq_cst) volatile noexcept;\nvoid A ::store(C desired, memory_order order = memory_order_seq_cst) noexcept;\n</code></pre>\n<ol start=\"9\">\n<li>Requires: The order argument shall not be <code>memory_order_consume</code>, <code>memory_order_acquire</code>, nor\n  <code>memory_order_acq_rel</code>.</li>\n<li>Effects: <strong>Atomically replaces the value</strong> pointed to by object or by this with the value of desired.\n  Memory is affected according to the value of order.</li>\n</ol>\n</blockquote>\n<p>And so on, using the word <em>Atomically</em> in every case it applies.</p>\n<p>Instead of repeating themselves for <code>add</code>/<code>+</code>,  <code>sub</code>/<code>-</code>, and so for <code>|</code>, <code>&amp;</code>, and <code>^</code>, they have a key/op table that applies to this block:</p>\n<blockquote id=\"so_45972392_45973336_2\">\n<pre><code>C atomic_fetch_key (volatile A * object, M operand) noexcept;\nC atomic_fetch_key (A * object, M operand) noexcept;\nC atomic_fetch_key _explicit(volatile A * object, M operand, memory_order order) noexcept;\nC atomic_fetch_key _explicit(A * object, M operand, memory_order order) noexcept;\nC A ::fetch_key (M operand, memory_order order = memory_order_seq_cst) volatile noexcept;\nC A ::fetch_key (M operand, memory_order order = memory_order_seq_cst) noexcept;\n</code></pre>\n<ul>\n<li>28 <strong>Effects: Atomically replaces the value</strong> pointed to by object or by\n  this with the result of the computation applied to the value pointed\n  to by object or by this and the given operand. Memory is affected\n  according to the value of order. These operations are atomic\n  read-modify-write operations (1.10).</li>\n<li>29 <strong>Returns: Atomically, the value\n  pointed to</strong> by object or by this immediately before the effects.</li>\n<li>30\n  Remark: For signed integer types, arithmetic is defined to use two\u2019s\n  complement representation. There are no undefined results. For address\n  types, the result may be an undefined address, but the operations\n  otherwise have no undefined behavior.</li>\n</ul>\n</blockquote>\n<hr>\n<p>The only thing that's optional is ordering / synchronization with loads/stores in other threads (for atomicity without synchronization, use <code>memory_order_relaxed</code>).</p>\n<p>In fact, there's no way to \"turn off\" atomicity for loading a wide type where that's expensive (e.g. before <a href=\"https://stackoverflow.com/questions/38984153/how-can-i-implement-aba-counter-with-c11-cas/38991835#38991835\">a CAS on <code>atomic&lt;pointer_and_ABAcounter&gt;</code> which compiles to <code>lock cmpxchg16b</code></a> on x86). I used a union hack in that answer to efficiently load the struct.</p>\n<p>And more importantly, the union is a workaround for gcc not optimizing <code>ptr_and_counter.ptr</code> to a load of just the pointer, which I think is safe at least on x86.  Instead gcc insists on atomically loading the whole struct and <em>then</em> getting the pointer from the result.  That's very bad when it's a 16-byte struct on x86-64, and fairly bad on x86-32.  (See <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80835\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80835</a>)</p>\n</hr>", "OwnerUserId": "224132", "LastEditorUserId": "224132", "LastEditDate": "2017-09-07T05:11:42.833", "Id": "45973336", "Score": "5", "CreationDate": "2017-08-31T04:39:25.270", "LastActivityDate": "2017-09-07T05:11:42.833"}, "bq_ids": {"n4140": {"so_45972392_45973336_0": {"section_id": 1148, "quality": 0.8928571428571429, "length": 25}}, "n3337": {"so_45972392_45973336_0": {"section_id": 1145, "quality": 0.8928571428571429, "length": 25}}, "n4659": {"so_45972392_45973336_0": {"section_id": 1242, "quality": 0.8928571428571429, "length": 25}}}});