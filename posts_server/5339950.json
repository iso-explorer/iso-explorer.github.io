post_cb({"5340149": {"Id": "5340149", "PostTypeId": "2", "Body": "<p>You could always use boost::array, which will be in C++0x.\nOtherwise, any solution will be awkward at best: arrays are\nbroken in C, and C++ maintains compatilibity with C in this\nrespect.  Fred Overflow offered one solution; even easier (but\nsyntactically noisy) would be to wrap the array in a struct:\n    struct A { int arr[3]; };\nand allocate and manipulate this.</p>\n", "LastActivityDate": "2011-03-17T14:06:44.373", "CommentCount": "2", "CreationDate": "2011-03-17T14:06:44.373", "ParentId": "5339950", "Score": "2", "OwnerUserId": "649665"}, "5340075": {"Id": "5340075", "PostTypeId": "2", "Body": "<p>To get a pointer to an array from <code>new</code>, you have to dynamically allocate a two-dimensional array:</p>\n<pre><code>int (*p)[3] = new int[1][3];\n</code></pre>\n", "LastActivityDate": "2011-03-17T14:01:21.277", "CommentCount": "1", "CreationDate": "2011-03-17T14:01:21.277", "ParentId": "5339950", "Score": "11", "OwnerUserId": "252000"}, "bq_ids": {"n4140": {"so_5339950_5340164_0": {"length": 15, "quality": 1.0, "section_id": 6082}}, "n3337": {"so_5339950_5340164_0": {"length": 15, "quality": 1.0, "section_id": 5850}}, "n4659": {"so_5339950_5340164_0": {"length": 15, "quality": 1.0, "section_id": 7578}}}, "5339976": {"Id": "5339976", "PostTypeId": "2", "Body": "<p>You just do </p>\n<pre><code>int *p = new unsigned int [3]\n</code></pre>\n<p>You can then use <code>*p</code> as a pointer or an array i.e. <code>*(p+1) or p[1]</code></p>\n", "LastEditorUserId": "214671", "LastActivityDate": "2011-03-17T14:01:19.967", "Score": "-2", "CreationDate": "2011-03-17T13:54:23.190", "ParentId": "5339950", "CommentCount": "1", "OwnerUserId": "10897", "LastEditDate": "2011-03-17T14:01:19.967"}, "5340164": {"Id": "5340164", "PostTypeId": "2", "Body": "<p>The reason you can't do it is that <code>new int[3]</code> already allocates exactly what you want, an object of type <code>int[3]</code>. It's just that what the new-expression <em>returns</em>, is a pointer to its first element. 5.3.4/1:</p>\n<blockquote>\n<p id=\"so_5339950_5340164_0\">If the entity is a non-array object,\n  the new-expression returns a pointer\n  to the object created. If it is an\n  array, the new-expression returns a\n  pointer to the initial element of the\n  array.</p>\n</blockquote>\n<p>Returning a pointer to the first element is what allows the <code>3</code> to be unknown until runtime, so I suppose that by knowing it in advance, you've tripped over flexibility that you aren't using.</p>\n<p>I guess the ways around this are to reinterpret_cast back to the pointer type you want (not necessarily portable), or to allocate a struct containing an <code>int[3]</code> (and use a pointer to its data member).</p>\n<p>[Edit: er, yeah, or FredOverflow's idea, which has neither disadvantage, but requires use of <code>delete[]</code> instead of <code>delete</code>.]</p>\n<p>I guess the moral is, if you write templates that naively allocate some unknown type <code>T</code> with <code>new</code>, then the template won't work when someone passes an array type as <code>T</code>. You'll be assigning it to the wrong pointer type, and if you fix that (perhaps with <code>auto</code>), you'll be deleting it wrongly.</p>\n<p>Edit in answer to j_kubik's question:</p>\n<p>Here's one way to distinguish between array and non-array types. If you write a function like this, that returns an object that holds the pointer and is capable of correctly deleting it, then you have a generic new/delete for any type T.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nvoid make_thing_helper(T *) {\n    std::cout &lt;&lt; \"plain version\\n\";\n}\n\ntemplate &lt;typename T, int N&gt;\nvoid make_thing_helper(T (*)[N]) {\n    std::cout &lt;&lt; \"array version\\n\";\n}\n\ntemplate &lt;typename T&gt;\nvoid make_thing() {\n    make_thing_helper((T*)0);\n}\n\nint main() {\n    typedef int T1;\n    typedef int T2[3];\n    make_thing&lt;T1&gt;();\n    make_thing&lt;T2&gt;();\n}\n</code></pre>\n", "LastEditorUserId": "13005", "LastActivityDate": "2011-09-06T07:41:33.980", "Score": "10", "CreationDate": "2011-03-17T14:08:06.253", "ParentId": "5339950", "CommentCount": "4", "OwnerUserId": "13005", "LastEditDate": "2011-09-06T07:41:33.980"}, "5339950": {"ViewCount": "616", "Body": "<p>First of all, I want to reassure you all that I am asking this question out of curiosity. I mean, don't tell me that if I need this then my design has problems because I don't need this in real code. Hope I convinced you :) Now to the question:</p>\n<p>For most types T we can write</p>\n<pre><code>T* p = new T;\n</code></pre>\n<p>now what if T is an array type?</p>\n<pre><code>int (*p)[3] =  new ???; //pointer to array of 3 = new ???\n</code></pre>\n<p>I tried this:</p>\n<pre><code>typedef int arr[3];\narr* p = new arr;\n</code></pre>\n<p>but this doesn't work.</p>\n<p>Is there any valid syntax for this or it is impossible in C++. If it is impossible, then why? Thanks</p>\n<p><em><strong>Edit</strong></em></p>: i am guessing I wasn't clear enough. I want to be able to use it in this situation:\n<pre><code>void f(int(&amp;)[3]);\nint (*p)[3] = new ???;\nf(*p);\n</code></pre>\n", "AcceptedAnswerId": "5340164", "Title": "Is it possible to dynamically create an array of constant size in C++?", "CreationDate": "2011-03-17T13:52:23.310", "Id": "5339950", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2011-03-17T13:59:34.757", "LastEditorUserId": "469935", "LastActivityDate": "2011-09-06T07:41:33.980", "Score": "17", "OwnerUserId": "469935", "Tags": "<c++><arrays><new-operator>", "AnswerCount": "4"}});