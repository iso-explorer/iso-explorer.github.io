post_cb({"bq_ids": {"n4140": {"so_27678342_27678509_0": {"length": 40, "quality": 0.9302325581395349, "section_id": 135}, "so_27678342_27678509_2": {"length": 15, "quality": 0.7894736842105263, "section_id": 137}, "so_27678342_27678509_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 142}}, "n3337": {"so_27678342_27678509_0": {"length": 40, "quality": 0.9302325581395349, "section_id": 129}, "so_27678342_27678509_2": {"length": 15, "quality": 0.7894736842105263, "section_id": 131}, "so_27678342_27678509_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 136}}, "n4659": {"so_27678342_27678509_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 139}, "so_27678342_27678509_2": {"length": 15, "quality": 0.7894736842105263, "section_id": 141}, "so_27678342_27678509_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 146}}}, "27678509": {"Id": "27678509", "PostTypeId": "2", "Body": "<p>It's not an error because it's valid. </p>\n<blockquote>\n<p id=\"so_27678342_27678509_0\"><code>[C++11: 14.5.5/1]:</code> A primary class template declaration is one in which the class template name is an identifier. A template declaration in which the class template name is a <em>simple-template-id</em> is a partial specialization of the class template named in the <em>simple-template-id</em>. A partial specialization of a class template provides an alternative definition of the template that is used instead of the primary definition when the arguments in a specialization match those given in the partial specialization (14.5.5.1). <em>[..]</em></p>\n</blockquote>\n<p>There's simply no rule to prohibit it and, in fact, the standard contains an example of precisely this scenario:</p>\n<blockquote>\n<p id=\"so_27678342_27678509_1\"><code>[C++11: 14.5.5/3]:</code> <em>[ Example:</em></p>\n<pre><code>template&lt;class T1, class T2, int I&gt; class A { };             // #1\ntemplate&lt;class T, int I&gt;            class A&lt;T, T*, I&gt; { };   // #2\ntemplate&lt;class T1, class T2, int I&gt; class A&lt;T1*, T2, I&gt; { }; // #3\ntemplate&lt;class T&gt;                   class A&lt;int, T*, 5&gt; { }; // #4\ntemplate&lt;class T1, class T2, int I&gt; class A&lt;T1, T2*, I&gt; { }; // #5\n</code></pre>\n<p id=\"so_27678342_27678509_2\">The first declaration declares the primary (unspecialized) class template. The second and subsequent declarations declare partial specializations of the primary template. <em>\u2014end example ]</em></p>\n</blockquote>\n<p>The only restriction that is even marginally related is, ironically, <em>closer</em> (though not precisely) to the opposite of what you claim:</p>\n<blockquote>\n<p id=\"so_27678342_27678509_3\"><code>[C++11: 14.5.5/8]:</code> Within the argument list of a class template partial specialization, the following restrictions apply:</p>\n<ul>\n<li><em>[..]</em></li>\n<li>The argument list of the specialization shall not be identical to the implicit argument list of the primary template.</li>\n<li><em>[..]</em></li>\n</ul>\n</blockquote>\n<p>You would use the primary and template and partial specialisation like so:</p>\n<pre><code>int main()\n{\n    rank&lt;char&gt;   a;   // uses the primary\n    rank&lt;int[5]&gt; b;   // uses the partial spec.\n}\n</code></pre>\n", "LastActivityDate": "2014-12-28T16:49:25.003", "CommentCount": "1", "CreationDate": "2014-12-28T16:49:25.003", "ParentId": "27678342", "Score": "4", "OwnerUserId": "560648"}, "27678486": {"Id": "27678486", "PostTypeId": "2", "Body": "<p>Specialisations can have template parameters themselves. Specialisations with template parameters are called partial specialisations.</p>\n<pre><code>template&lt;class T&gt;\nstruct rank { ...1 };\n</code></pre>\n<p>means <code>rank&lt;T&gt;</code> is a class, and unless otherwise specified, <code>...1</code> is the class's definition.</p>\n<pre><code>template&lt;class U, size_t N&gt;\nstruct rank&lt;U[N]&gt; { ...2 };\n</code></pre>\n<p>is the \"otherwise specified\": it means that if the <code>T</code> in <code>rank&lt;T&gt;</code> can be written as <code>U[N]</code> for some type <code>U</code> and some constant <code>N</code>, then <code>...2</code> is the class's definition.</p>\n<p>You'd use it like <code>rank&lt;int[2]&gt;</code>, which would use the second class definition with <code>U = int</code> and <code>N = 2</code>.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2014-12-28T16:52:52.930", "Score": "10", "CreationDate": "2014-12-28T16:47:15.620", "ParentId": "27678342", "CommentCount": "1", "OwnerUserId": "743382", "LastEditDate": "2014-12-28T16:52:52.930"}, "27678342": {"ViewCount": "96", "Body": "<p>I was watching <a href=\"https://www.youtube.com/watch?v=Am2is2QCvxY\" rel=\"nofollow\">this</a> lecture, where the following example (@29.43) is presented as a specialization : </p>\n<pre><code>template&lt;class T&gt;\nstruct rank\n{\n    static const size_t value = 0u; \n}\n\n// partial specialization\ntemplate&lt;class U, size_t N&gt;\nstruct rank&lt;U[N]&gt;\n{\n    static const size_t value = 1 + rank&lt;U&gt;::value; \n}\n</code></pre>\n<p>I would expect a compile error, complaining about the declarations of the structs being incombatible and the second one having too many template parameters. <strong>How is the above not an error?</strong></p>\n", "AcceptedAnswerId": "27678486", "Title": "How is this a specialization?", "CreationDate": "2014-12-28T16:29:29.000", "Id": "27678342", "CommentCount": "7", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-12-28T16:52:52.930", "Score": "3", "OwnerUserId": "4224575", "Tags": "<c++><template-meta-programming>", "AnswerCount": "2"}});