post_cb({"25299756": {"ParentId": "25299622", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2014-08-14T03:51:35.373", "Score": "7", "LastEditorUserId": "1670129", "LastEditDate": "2014-08-14T11:54:02.720", "Id": "25299756", "OwnerUserId": "1670129", "Body": "<p>When a class would be moved but for the fact that no move constructor is declared, the compiler falls back to copy constructor. In the same situation, if move constructor is declared as deleted, the program would be ill-formed. Thus, if move constructor were implicitly declared as deleted, a lot of reasonable code involving existing pre-C++11 classes would fail to compile. Things like <code>myVector.push_back(MyClass())</code></p>\n<p>This explains why move constructor cannot be implicitly declared deleted when copy constructor is defined. This leaves the question of why copy constructor is implicitly declared deleted when move constructor is defined.</p>\n<p>I don't know the exact motivation of the committee, but I have a guess. If adding a move constructor to existing C++03-style class were to remove a (previously implicitly defined) copy constructor, then existing code using this class may change meaning in subtle ways, due to overload resolution picking unexpected overloads that used to be rejected as worse matches.</p>\n<p>Consider:</p>\n<pre><code>struct C {\n  C(int) {}\n  operator int() { return 42; }\n};\n\nC a(1);\nC b(a);  // (1)\n</code></pre>\n<p>This is a legacy C++03 class. (1) invokes an (implicitly defined) copy constructor. <code>C b((int)a);</code> is also viable, but is a worse match.</p>\n<p>Imagine that, for whatever reason, I decide to add an explicit move constructor to this class. If the presence of move constructor were to suppress the implicit declaration of copy constructor, then a seemingly unrelated piece of code at (1) would still compile, but silently change its meaning: it would now invoke <code>operator int()</code> and <code>C(int)</code>. That would be bad.</p>\n<p>On the other hand, if copy constructor is implicitly declared as deleted, then (1) would fail to compile, alerting me to the problem. I would examine the situation and decide whether I still want a default copy constructor; if so, I would add <code>C(const C&amp;)=default;</code></p>\n", "LastActivityDate": "2014-08-14T11:54:02.720"}, "25299622": {"CommentCount": "0", "AcceptedAnswerId": "25299756", "CreationDate": "2014-08-14T03:34:28.680", "LastActivityDate": "2014-08-14T14:14:32.420", "PostTypeId": "1", "ViewCount": "547", "FavoriteCount": "1", "Title": "Why are copy operations deleted when move operations are declared?", "Id": "25299622", "Score": "8", "Body": "<p>When a class explicitly declares a copy operation (i.e., a copy constructor or copy assignment operator), move operations are not declared for the class. But when a class explicitly declares a move operation, the copy operations are declared as deleted. Why does this asymmetry exist? Why not just specify that if a move operation is declared, no copy operations will be declared? From what I can tell, there would not be any behavioral difference, and there would be no need for the asymmetric treatment of move and copy operations.</p>\n<p>[For people who like citations of the standard, the lack of declaration of move operations for classes with copy operation declarations is specified in 12.8/9 and 12.8/20, and the deleted copy operations for classes with move operation declarations are specified in 12.8/7 and 12.8/18.]</p>\n", "Tags": "<c++><c++11><copy-constructor><move-semantics>", "OwnerUserId": "1426649", "AnswerCount": "3"}, "25310189": {"ParentId": "25299622", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-08-14T14:09:22.003", "Score": "2", "LastEditorUserId": "981959", "LastEditDate": "2014-08-14T14:14:32.420", "Id": "25310189", "OwnerUserId": "981959", "Body": "<blockquote>\n<p id=\"so_25299622_25310189_0\">Why does this asymmetry exist?</p>\n</blockquote>\n<p>Backward compatibility, and because the relationship between copying and moving is already asymmetrical. The definition of MoveConstructible is a special case of CopyConstructible, meaning that all CopyConstructible types are also MoveConstructible types. That's true because a copy constructor taking a reference-to-const will handle rvalues as well as lvalues.</p>\n<p>A copyable type can be initialized from rvalues without a move constructor (it just might not be as efficient as it could be with a move constructor).</p>\n<p>A copy constructor can also used to perform a \"move\" in implicitly-defined move constructors of derived classes when moving the base sub-object.</p>\n<p>So a copy constructor can be seen as a \"degenerate move constructor\", so if a type has a copy constructor it doesn't strictly <em>need</em> a move constructor, it is already MoveConstructible, so simply not declaring the move constructor is acceptable.</p>\n<p>The opposite is not true, a movable type is not necessarily copyable, e.g. move-only types. In those cases, making the copy constructor and assignment deleted provides better diagnostics than just not declaring them and getting errors about binding lvalues to rvalue references.</p>\n<blockquote>\n<p id=\"so_25299622_25310189_1\">Why not just specify that if a move operation is declared, no copy operations will be declared?</p>\n</blockquote>\n<p>Better diagnostics and more explicit semantics. \"Defined as deleted\" is the C++11 way to clearly say \"this operation is not allowed\", rather than just happening to be omitted by mistake or missing for some other reason.</p>\n<p>The special case of \"not declared\" for move constructors and move assignment operators is unusual and is special because of the asymmetry described above, but special cases are usually best kept for a few narrow cases (it's worth noting here that \"not declared\" can also apply to the default constructor).</p>\n<p>Also worth noting is that one of the paragraphs you refer to, [class.copy] p7, says (emphasis mine):</p>\n<blockquote>\n<p id=\"so_25299622_25310189_2\">If the class definition does not explicitly declare a copy constructor, one is declared <em>implicitly</em>. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted; otherwise, it is defined as defaulted (8.4). <strong>The latter case is deprecated if the class has a user-declared copy assignment operator or a user-declared destructor.</strong></p>\n</blockquote>\n<p>\"The latter case\" refers to the \"otherwise, it is defined as defaulted\" part. Paragraph 18 has similar wording for the copy assignment operator.</p>\n<p>So the intention of the committee is that in some future version of C++ other types of special member function will also cause the copy constructor and copy assignment operator to be deleted. The reasoning is that if your class needs a user-defined destructor then the implicitly-defined copy behaviour is probably not going to do the right thing. That change hasn't been made for C++11 or C++14 for backward compatibility reasons, but the idea is that in some future version to prevent the copy constructor and copy assignment operator being deleted you will need to declare them explicitly and define them as defaulted.</p>\n<p>So deleting copy constructors if they might not do the right thing is the general case, and \"not declared\" is a special case just for move constructors, because the copy constructor can provide the degenerate move anyway.</p>\n", "LastActivityDate": "2014-08-14T14:14:32.420"}, "bq_ids": {"n4140": {"so_25299622_25310189_2": {"section_id": 456, "quality": 0.9473684210526315, "length": 36}}, "n3337": {"so_25299622_25310189_2": {"section_id": 447, "quality": 0.9473684210526315, "length": 36}}, "n4659": {"so_25299622_25310189_2": {"section_id": 479, "quality": 0.9473684210526315, "length": 36}}}, "25308799": {"ParentId": "25299622", "CommentCount": "5", "CreationDate": "2014-08-14T13:07:13.610", "OwnerUserId": "924727", "PostTypeId": "2", "Id": "25308799", "Score": "0", "Body": "<p>It is essentially to avoid migrated code to perform unexpected different actions.</p>\n<p>Copy and move require a certain level of coherence, so C++11 -if you declare just one- suppress the other.</p>\n<p>Consider this:</p>\n<pre><code>C a(1); //init\nC b(a); //copy\nC c(C(1)); //copy from temporary (03) or move(11).\n</code></pre>\n<p>Suppose you write this in C++03.</p>\n<p>Suppose I compile it later in C++11.\nIf no ctor are declared, the default move does a copy (so the final behavior is the same as C++03).</p>\n<p>If copy is declared, move is deleted, and sine <code>C&amp;&amp;</code> decays into <code>C const&amp;</code> The third statement result in a copy from a temporary. This is still a C++03 identical behavior.</p>\n<p>Now, if I'm adding later a move ctor, it means I'm changing the behavior of C (something you did not plan when defining C in C++03), and since a movable object does not need to be copyable (and vice versa), The compiler assumes that by making it movable, the dafault copy may be not anymore adequate. It's up to me to implementing it in coherence with the move or -if I found it adequate- restore the <code>C(const C&amp;)=default;</code></p>\n", "LastActivityDate": "2014-08-14T13:07:13.610"}});