post_cb({"30230036": {"ParentId": "30227277", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I'll provide some formal explanation from the Standard for that fact for standard-reference-searchers.:</p>\n<p>The section <code>N4296::7.1.6.4/7 [dcl.spec.auto]</code></p>\n<blockquote>\n<p id=\"so_30227277_30230036_0\">If the placeholder is the auto type-specifier, the deduced type is\n  determined using the rules for template argument deduction.</p>\n</blockquote>\n<p>Now, the template argument dedcution <code>N4296::14.8.2/3 [temp.deduct]</code>:</p>\n<blockquote>\n<p id=\"so_30227277_30230036_1\">[...] the function parameter type adjustments described in 8.3.5 are\n  performed.</p>\n</blockquote>\n<p>And finally <code>N4296::8.3.5/5 [dcl.fct]</code></p>\n<blockquote>\n<p id=\"so_30227277_30230036_2\">After determining the type of each parameter, any parameter of type\n  \u201carray of T\u201d or \u201cfunction returning T\u201d is adjusted to be \u201cpointer to\n  T\u201d or \u201cpointer to function returning T,\u201d respectively. After producing\n  the list of parameter types, <strong><em>any top-level cv-qualifiers modifying\n  a parameter type are deleted when forming the function type</em></strong>.</p>\n</blockquote>\n<p>In short, yes, CV-qualifiers are just ignored in that case.</p>\n", "Id": "30230036", "LastEditDate": "2015-05-14T05:57:19.770", "OwnerDisplayName": "user2953119", "Score": "3", "CreationDate": "2015-05-14T05:40:48.393", "LastActivityDate": "2015-05-14T05:57:19.770", "LastEditorDisplayName": "user2953119"}, "30227449": {"ParentId": "30227277", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>When you write</p>\n<pre><code>auto temp = rhs;\n</code></pre>\n<p>type deduction works as follows:</p>\n<ul>\n<li><p>if <code>rhs</code> is a reference, then the reference is ignored</p></li>\n<li><p>the <em>top-level cv(const-volatile)-qualifiers</em> of <code>rhs</code> are also ignored (they are not ignored however if you do <code>auto&amp; temp = rhs;</code>; in this case the compiler pattern-matches the type)</p></li>\n</ul>\n<p>In your case, the type of the right hand side is </p>\n<pre><code>const int* const\n           ^^^^^\n           top-level cv qualifier\n</code></pre>\n<p>i.e. <code>const</code> pointer to <code>const</code>-<code>int</code>. The pointer is like any other variable, so it's <code>const</code>-ness will be discarded (technically, the top-level cv qualifier is <code>const</code> and it is discarded), hence you end up with the type of <code>temp</code> being deduced as</p>\n<pre><code>const int*\n</code></pre>\n<p>i.e. a non-<code>const</code> pointer to <code>const</code>-<code>int</code>, so it can be re-assigned. If you want to enforce the <code>const</code>-ness, then you have to declare the left hand side as</p>\n<pre><code>const auto temp = myClass.test();\n^^^^^\nneed this\n</code></pre>\n<p>Scott Meyers has an <a href=\"http://www.aristeia.com/TalkNotes/C++TypeDeductionandWhyYouCareCppCon2014.pdf\" rel=\"nofollow\">excellent introduction</a> to the subject (also available on his <a href=\"http://rads.stackoverflow.com/amzn/click/1491903996\" rel=\"nofollow\"><em>Effective Modern C++</em></a> book, Items 1 and 2 free to browse <a href=\"https://www.safaribooksonline.com/library/view/effective-modern-c/9781491908419/ch01.html#understand_template_type_deduction\" rel=\"nofollow\">here</a>), in which he explains how <code>template</code> type deduction works. Once you understand that, understanding <code>auto</code> is a breeze, since really <code>auto</code> type deduction mimic very closely the template type deduction system (with the notable exception of <code>std::initializer_list&lt;&gt;</code>).</p>\n<p><strong>EDIT</strong></p>\n<p>There is an additional rule for</p>\n<pre><code>auto&amp;&amp; temp = rhs;\n</code></pre>\n<p>but to understand it you need to understand <a href=\"https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers\" rel=\"nofollow\">how forwarding (universal) references work and how reference collapsing works</a>.</p>\n", "OwnerUserId": "3093378", "LastEditorUserId": "3093378", "LastEditDate": "2015-05-14T01:40:42.943", "Id": "30227449", "Score": "4", "CreationDate": "2015-05-14T00:33:20.527", "LastActivityDate": "2015-05-14T01:40:42.943"}, "30227277": {"CommentCount": "2", "AcceptedAnswerId": "30227743", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2015-05-14T00:14:18.963", "LastActivityDate": "2015-05-14T05:57:19.770", "LastEditDate": "2015-05-14T01:06:29.380", "ViewCount": "1164", "FavoriteCount": "1", "Title": "Returning a const pointer to a const data member and the 'auto' keyword. A bit confused", "Id": "30227277", "Score": "16", "Body": "<p>I've recently been learning C++ and just today have been introduced to <em>const</em> and the concept of const correctness. In an attempt to better understand the theory, I've been writing a series of simple programs to make sure that I understand the concept correctly. I thought I understood everything, but then when using the <em>auto</em> keyword in one of the programs, I seem to have got a bit stuck.</p>\n<p>In order to test that I understood how const pointers work I wrote a simple program. I won't bother posting the whole thing since there's only two parts of it that are relevant. I have a class with a const data member of type int:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>const int tryToChangeMe;\n</code></pre>\n<p>Within this class I also have a member function that returns a const pointer to the above const int:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>const int* const MyClass::test()\n{\n    return &amp;tryToChangeMe;\n}\n</code></pre>\n<p>In my main function I then call the above function, making use of the <em>auto</em> keyword. In order to test that what I think I know about <em>const</em> is correct I then attempt to reassign the <em>tryToChangeMe</em> variable through the pointer. Like so:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>auto temp = myClass.test();\n*temp = 100;\n</code></pre>\n<p>As I expected, the program wouldn't compile due to the error that I caused when trying to assign a value to a <em>const</em> variable. However, I didn't just return a pointer to <em>const</em>, I returned a <em>const</em> pointer to a <em>const</em> (at least that's what I thought I did). So to test this, I attempted to reassign the pointer to a new memory address, quite confident that I'd get a similar compilation error:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>temp = new int;\n</code></pre>\n<p>But quite confusingly the program compiled without any issue. Stepping through with the debugger revealed that sure enough, the pointer was losing its original address and being assigned a brand new one. Wondering what was going on, I just happened by chance to remove the <em>auto</em> keyword and replace it with the variable's full type:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>const int* const temp = myClass.test();\n</code></pre>\n<p>Upon testing everything again, the results were as expected and this time I was not able to reassign the pointer to a new address.</p>\n<p>So after all that I guess my question is, why? Why does the <em>auto</em> keyword allow you to bypass the <em>const</em> qualifier of pointers? Did I do something wrong?</p>\n<p>By the way, I'm not sure if it matters but I'm using Visual Studio 2015 preview</p>\n", "Tags": "<c++><pointers><c++11><const><auto>", "OwnerUserId": "4897727", "AnswerCount": "4"}, "30227362": {"ParentId": "30227277", "CommentCount": "8", "Body": "<p>The reason is that <code>auto</code> variables are not by default <code>const</code>. The fact that you return <code>const</code> value does not mean it has to be assigned to a <code>const</code> variable; the value is <em>copied</em> after all (eventhough the value is a pointer). You can try it easily with explicit type specification as well. The value stored in <code>myClass</code> won't be changed when changing the variable <code>temp</code> and the pointer target is still <code>const</code> so constness is still honored.</p>\n", "OwnerUserId": "4538344", "PostTypeId": "2", "Id": "30227362", "Score": "5", "CreationDate": "2015-05-14T00:22:44.367", "LastActivityDate": "2015-05-14T00:22:44.367"}, "bq_ids": {"n4140": {"so_30227277_30230036_1": {"section_id": 295, "quality": 0.8571428571428571, "length": 6}, "so_30227277_30230036_0": {"section_id": 5451, "quality": 1.0, "length": 11}, "so_30227277_30227743_0": {"section_id": 641, "quality": 0.625, "length": 5}, "so_30227277_30230036_2": {"section_id": 3241, "quality": 1.0, "length": 31}}, "n3337": {"so_30227277_30230036_1": {"section_id": 286, "quality": 0.8571428571428571, "length": 6}, "so_30227277_30230036_0": {"section_id": 5245, "quality": 0.7272727272727273, "length": 8}, "so_30227277_30227743_0": {"section_id": 631, "quality": 0.625, "length": 5}, "so_30227277_30230036_2": {"section_id": 3114, "quality": 1.0, "length": 31}}, "n4659": {"so_30227277_30230036_1": {"section_id": 302, "quality": 0.8571428571428571, "length": 6}, "so_30227277_30230036_0": {"section_id": 6889, "quality": 1.0, "length": 11}, "so_30227277_30230036_2": {"section_id": 3997, "quality": 0.8387096774193549, "length": 26}, "so_30227277_30227743_0": {"section_id": 669, "quality": 0.625, "length": 5}}}, "30227743": {"ParentId": "30227277", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>As already mentioned, <code>auto</code> ignores top level cv-qualifiers. Read <a href=\"http://thbecker.net/articles/auto_and_decltype/section_01.html\">this article</a> to learn the details of how <code>auto</code> and <code>decltype</code> work.</p>\n<p>Now, even if <code>auto</code> didn't ignore the <code>const</code>, in your case, <code>temp</code> would still not be <code>const</code> because top level cv-qualifiers on return types are <a href=\"https://stackoverflow.com/a/12051274/241631\">ignored</a> if the type being returned is of non-class type.</p>\n<p>g++ even produces the following warning with <code>-Wextra</code></p>\n<blockquote>\n<p id=\"so_30227277_30227743_0\">warning: type qualifiers ignored on function return type [-Wignored-qualifiers]</p>\n</blockquote>\n<p>This can be demonstrated by using C++14's <code>decltype(auto)</code>. Unlike <code>auto</code>, <code>decltype(auto)</code> doesn't discard references and top level cv-qualifiers. If you modify your example by adding the following lines the code will still compile, proving that <code>temp</code> is not a <code>const</code> pointer.</p>\n<pre><code>decltype(auto) temp = myClass.test();\nstatic_assert(std::is_same&lt;const int*, decltype(temp)&gt;{}, \"\");\n</code></pre>\n<p>On the other hand, if <code>test()</code> returns an object of class type with a top level cv-qualifier, then <code>auto</code> would still discard <code>const</code>, but <code>decltype(auto)</code> wouldn't.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/c74a5e3d5de7c76a\">Live demo</a></p>\n", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2015-05-14T01:19:11.747", "Id": "30227743", "Score": "7", "CreationDate": "2015-05-14T01:17:15.157", "LastActivityDate": "2015-05-14T01:19:11.747"}});