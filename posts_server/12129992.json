post_cb({"12130012": {"Id": "12130012", "PostTypeId": "2", "Body": "<p>The compiler does not allocate or delete memory, it is OS-dependent what happens if you call free on a pointer value that you did not get from new.  The only thing that is guaranteed is that it is wrong.</p>\n", "LastActivityDate": "2012-08-26T12:12:01.100", "CommentCount": "3", "CreationDate": "2012-08-26T12:12:01.100", "ParentId": "12129992", "Score": "1", "OwnerUserId": "1216776"}, "12129992": {"ViewCount": "164", "Body": "<p>I have this small piece of code in the middle of a larger code:</p>\n<pre><code>int *p = new int[100];\np += 50;\ndelete []p;\n</code></pre>\n<p>Will the compiler delete only the memory from the 51<sup>st</sup> location? I think it does. However, in the case of array pointers, the compiler holds an additional item which tells the number of objects allocated. So, in that case, shouldn't it go ahead and delete memory beyond the allocated size?\nOr does it delete the 51<sup>st</sup>\u2013100<sup>th</sup> elements and keep the 1<sup>st</sup>\u201350<sup>th</sup> in the memory, in which case a memory leak can happen.</p>\n", "AcceptedAnswerId": "12130028", "Title": "Memory leak or not?", "CreationDate": "2012-08-26T12:09:07.687", "Id": "12129992", "CommentCount": "2", "LastEditDate": "2012-08-26T12:13:00.367", "PostTypeId": "1", "LastEditorUserId": "240733", "LastActivityDate": "2012-08-26T12:14:39.867", "Score": "3", "OwnerUserId": "1176304", "Tags": "<c++><arrays><pointers><memory-leaks>", "AnswerCount": "3"}, "12130003": {"Id": "12130003", "PostTypeId": "2", "Body": "<p>It's actually undefined behavior. You can only <code>delete</code> / <code>delete[]</code> what you got from <code>new</code> / <code>new[]</code>.</p>\n", "LastActivityDate": "2012-08-26T12:10:06.937", "CommentCount": "0", "CreationDate": "2012-08-26T12:10:06.937", "ParentId": "12129992", "Score": "6", "OwnerUserId": "714501"}, "bq_ids": {"n4140": {"so_12129992_12130028_2": {"length": 11, "quality": 0.6470588235294118, "section_id": 7183}, "so_12129992_12130028_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 7182}}, "n3337": {"so_12129992_12130028_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 6927}, "so_12129992_12130028_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 6926}}, "n4659": {"so_12129992_12130028_2": {"length": 11, "quality": 0.6470588235294118, "section_id": 8671}}}, "12130028": {"Id": "12130028", "PostTypeId": "2", "Body": "<p>It's undefined behavior. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\">The C++ standard says</a>:</p>\n<blockquote>\n<p id=\"so_12129992_12130028_0\"><strong>3.7.4.2 Deallocation functions</strong></p>\n<p id=\"so_12129992_12130028_1\">3 ... Otherwise, the behavior is unde\ufb01ned\n  if the value supplied to <strong><code>operator delete(void*)</code></strong> in the standard library is not one of the values returned\n  by a previous invocation of either <strong><code>operator new(std::size_t)</code></strong> or <strong><code>operator new(std::size_t, const\n  std::nothrow_t&amp;)</code></strong> in the standard library, and the behavior is unde\ufb01ned if the value supplied to <strong><code>operator\n  delete[](void*)</code></strong> in the standard library is not one of the values returned by a previous invocation of\n  either <strong><code>operator new[](std::size_t)</code></strong> or <strong><code>operator new[](std::size_t, const std::nothrow_t&amp;)</code></strong> in the\n  standard library.</p>\n<p id=\"so_12129992_12130028_2\">4 ... The e\ufb00ect of using an invalid pointer value\n  (including passing it to a deallocation function) is unde\ufb01ned. (On some implementations, it causes a system-generated runtime fault.)</p>\n</blockquote>\n", "LastActivityDate": "2012-08-26T12:14:39.867", "CommentCount": "2", "CreationDate": "2012-08-26T12:14:39.867", "ParentId": "12129992", "Score": "5", "OwnerUserId": "216063"}});