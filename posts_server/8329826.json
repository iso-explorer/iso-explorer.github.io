post_cb({"8329826": {"CommentCount": "9", "AcceptedAnswerId": "8333633", "PostTypeId": "1", "LastEditorUserId": "153285", "CreationDate": "2011-11-30T16:57:51.583", "LastActivityDate": "2011-11-30T22:06:50.097", "LastEditDate": "2011-11-30T20:32:05.703", "ViewCount": "1428", "FavoriteCount": "1", "Title": "Can standard container templates be instantiated with incomplete types?", "Id": "8329826", "Score": "16", "Body": "<p>Sometimes it's useful to instantiate a standard container with an incomplete type to obtain a recursive structure:</p>\n<pre><code>struct multi_tree_node { // Does work in most implementations\n    std::vector&lt; multi_tree_node &gt; child;\n};\n\nstruct trie_node { // Does not work in most implementations\n    std::map&lt; char, trie_node &gt; next;\n};\n</code></pre>\n<p>This tends to work because containers don't have members of type <code>value_type</code> or member functions that pass or return any <code>value_type</code> objects by value. The Standard doesn't seem to say very much about incomplete template arguments, but there is one bit under C++11 \u00a717.6.4.8 [lib.res.on.functions], \"requirements on other functions\":</p>\n<blockquote>\n<p id=\"so_8329826_8329826_0\">In particular, the effects are undefined in the following cases: \u2026 if an incomplete type (3.9) is used as a template argument when instantiating a template component, unless specifically allowed for that component.</p>\n</blockquote>\n<p>Does this make the above constructs illegal, even though the instantiations are not in block scope? Does this fall under \"operations on types used to instantiate standard library template components\" (also 17.6.4.8)? Or is a library implementation forbidden to incur template instantiations that might fail for incomplete types when all specifically required instantiations succeed?</p>\n<p><strong>Edit:</strong> Since only functions may call and instantiate other functions, restricting \"operations on types\u2026\" to those in block scope would seem to hold the contents of member functions to a stricter requirement than the contents of signatures and member class definitions. After all, it certainly doesn't make sense to <em>do anything</em> with a <code>multi_tree_node</code> until the type is complete. And this extends to the <code>std::unique_ptr</code> which explicitly supports an incomplete type argument, <em>even when used in block scope</em>.</p>\n<p><strong>Edit 2:</strong> Serves me right for not bothering to test the <code>trie_node</code> example \u2014 and I've even tried it before. It's the same as the example of breakage in <a href=\"http://drdobbs.com/184403814\" rel=\"noreferrer\">the article</a> that @Ise linked. However, while the article seems to take for granted that \"nothing like that could work,\" the solution seems simple to me \u2014 <code>std::map</code>'s internal <code>tree_node</code> class should be a non-member template, not a member non-template class.</p>\n<p>Anyway, that article establishes design intent pretty well, so I guess my nitpick about being under the subheading of \"requirements on functions\" is only just that.</p>\n", "Tags": "<c++><templates><stl><incomplete-type>", "OwnerUserId": "153285", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_8329826_8329826_0": {"section_id": 6324, "quality": 1.0, "length": 16}}, "n3337": {"so_8329826_8329826_0": {"section_id": 6081, "quality": 1.0, "length": 16}}, "n4659": {"so_8329826_8329826_0": {"section_id": 7834, "quality": 1.0, "length": 16}}}, "8333633": {"ParentId": "8329826", "CommentCount": "0", "Body": "<p>Personally, I feel the wording <em>instantiating</em> in 17.6.4.8/2 is a little\nambiguous, but according to \n<a href=\"http://drdobbs.com/184403814\" rel=\"nofollow\">this article</a>,\nthe standard's intent seems not to allow recursive data type using\nstandard containers.</p>\n<p>On a related note, VC2005 issues an error for\n<code>class C { std::deque&lt; C &gt; x; };</code>, while it compiles\n<code>class C { std::vector&lt; C &gt; x; };</code>...<br>\nHowever, in my understanding, this restriction is just for expanding the\nfreedom of the implementation of standard containers.\nSo as <em>Kerrek SB</em> mentioned, there can be containers which allow\nrecursive data structure, and\n<a href=\"http://www.boost.org/doc/libs/1_48_0/doc/html/container/containers_of_incomplete_types.html\" rel=\"nofollow\">Boost.Container</a>\nseems to provide this facility.</br></p>\n", "OwnerUserId": "547710", "PostTypeId": "2", "Id": "8333633", "Score": "4", "CreationDate": "2011-11-30T22:06:50.097", "LastActivityDate": "2011-11-30T22:06:50.097"}, "8330131": {"ParentId": "8329826", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Here's my attempt at an interpretation:</p>\n<p>The standard simply says you mustn't do this, even though any given concrete implementation may have no problem supporting such a construction. But imagine for example if someone wanted to write a \"small vector\" optimization by which a vector always contains space for, say, five elements. Immediately you'd be in trouble because you'd have a self-referential type. This would be a problem even if the vector employed some sort of static branching depending on the size of the value type.</p>\n<p>Therefore, in order to not preclude implementations from including such constructions, the standard simply says that you must only use complete types. In other words, the fact that most containers only contain references or pointers to the value type is an implementation detail rather than a standard requirement.</p>\n<p><sub>Just to clarify this: if you define your <em>own</em> class template, it is perfectly possible to design it in such a way that it explicitly supports incomplete types. An example from the standard is <code>std::unique_ptr</code>, which is perfectly happy with the incomplete type parameter <code>T[]</code> (or even <code>void</code>).</sub></p>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2011-11-30T17:24:44.187", "Id": "8330131", "Score": "10", "CreationDate": "2011-11-30T17:18:09.140", "LastActivityDate": "2011-11-30T17:24:44.187"}});