post_cb({"34272949": {"ParentId": "34272899", "LastEditDate": "2015-12-14T20:58:24.090", "CommentCount": "9", "CreationDate": "2015-12-14T17:20:17.757", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "PostTypeId": "2", "Id": "34272949", "Score": "10", "Body": "<p>Two paragraphs later, in [dcl.constexpr]/5:</p>\n<blockquote>\n<p id=\"so_34272899_34272949_0\">For a non-template, non-defaulted <code>constexpr</code> function or a non-template, non-defaulted, non-inheriting\n  constexpr constructor, if no argument values exist such that an invocation of the function or constructor\n  could be an evaluated subexpression of a core constant expression (5.20), or, for a constructor, a constant\n  initializer for some object (3.6.2), the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>No argument exists such that <code>foo()</code> could be a core constant expression because of <code>incr()</code>, therefore the program is ill-formed (NDR).</p>\n", "LastActivityDate": "2015-12-14T20:58:24.090"}, "34273406": {"ParentId": "34272899", "LastEditDate": "2015-12-15T22:43:00.607", "CommentCount": "1", "CreationDate": "2015-12-14T17:46:52.427", "OwnerUserId": "365496", "LastEditorUserId": "365496", "PostTypeId": "2", "Id": "34273406", "Score": "8", "Body": "<p>What you're looking for is \u00a7 5.19:</p>\n<blockquote>\n<p id=\"so_34272899_34273406_0\">A <em>conditional-expression</em> <strong>e</strong> is a core constant expression unless the evaluation of <strong>e</strong>, following the rules of the abstract machine (1.9), would evaluate one of the following expressions:</p>\n</blockquote>\n<p>This applies to the evaluation of an expression that is a <code>constexpr</code> function call. That is, calling a <code>constexpr</code> function will be a 'core constant expression' if evaluating the function, i.e. executing the body of the function according to the rules of the C++ abstract machine, doesn't do any of the things forbidden in the list given in \u00a7 5.19.</p>\n<p>One of items in the list is:</p>\n<blockquote id=\"so_34272899_34273406_1\">\n<ul>\n<li>an invocation of a function other than [...] a constexpr function</li>\n</ul>\n</blockquote>\n<p>So to apply this to your example: evaluating the expression <code>foo()</code> evaluates a call to a function <code>incr()</code> which is not a constexpr function, which means that the expression <code>foo()</code> is not a core constant expression.</p>\n<p>Further, since the above is true for all possible invocations of your function <code>foo</code>, the rule in \u00a7 7.1.5/5 kicks in and means that your example program is ill-formed, no diagnostic required, even if you never actually call <code>foo()</code>.</p>\n<hr>\n<p>As Ben Voigt points out a constexpr function can contain calls to non-consexpr functions, so long as the particular evaluation of the function does not actually evaluate any such function call (or it appears in a context that does not require a constant expression).</p>\n<p>The restrictions in 5.19 only pertain to what expressions actually end up being evaluated as part of the evaluation of an expression.</p>\n<p>For example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint incr(int &amp;n) { return ++n; }\n\nenum E {be_constexpr, not_constexpr};\n\nconstexpr int foo(E e = be_constexpr) {\n  int n = 0;\n  if (e == not_constexpr) { incr(n); }\n  return n;\n}\n\nint main() {\n  constexpr int a = foo(); // foo() is a constant expression\n  int b = foo(not_constexpr); // may or may not evaluate `foo(non_constexpr)` at runtime. In practice modern C++ compilers will do compile-time evaluation here even though they aren't required to.\n  // constexpr int c = foo(not_constexpr); // Compile error because foo(not_constexpr) is not formally a constant expression, even though modern compilers can evaluate it at compile-time.\n\n  std::cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; '\\n';\n}\n</code></pre>\n</hr>", "LastActivityDate": "2015-12-15T22:43:00.607"}, "34272952": {"ParentId": "34272899", "CommentCount": "3", "Body": "<p>It doesn't.</p>\n<p>The following is allowed, even though it does exactly what you surmise is forbidden:</p>\n<pre><code>int incr(int&amp; n) {\n    return ++n;\n}\n\nconstexpr int foo(bool x) {\n    int n = 0;\n    if (x) incr(n);\n    return n;\n}\n</code></pre>\n<p>The code in your question is disallowed by the rule with Barry quoted in his answer.  But in my variation, there does exist a set of parameters (specifically, <code>false</code>) with which invocation of <code>foo</code> results in a compile-time constant expression.</p>\n<p>Note that a diagnostic isn't required -- a conforming compiler could allow your version to compile as well.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "34272952", "Score": "4", "CreationDate": "2015-12-14T17:20:24.920", "LastActivityDate": "2015-12-14T17:20:24.920"}, "bq_ids": {"n4140": {"so_34272899_34273406_0": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}, "so_34272899_34273406_1": {"section_id": 6185, "quality": 1.0, "length": 6}, "so_34272899_34272899_0": {"section_id": 5419, "quality": 0.9259259259259259, "length": 25}, "so_34272899_34272949_0": {"section_id": 5421, "quality": 0.7575757575757576, "length": 25}, "so_34272899_34272899_1": {"section_id": 5419, "quality": 0.7777777777777778, "length": 14}}, "n3337": {"so_34272899_34272899_0": {"section_id": 5214, "quality": 0.8518518518518519, "length": 23}, "so_34272899_34273406_1": {"section_id": 5946, "quality": 1.0, "length": 6}}, "n4659": {"so_34272899_34272899_0": {"section_id": 6841, "quality": 0.8888888888888888, "length": 24}, "so_34272899_34273406_1": {"section_id": 7687, "quality": 1.0, "length": 6}, "so_34272899_34272949_0": {"section_id": 6843, "quality": 0.7575757575757576, "length": 25}, "so_34272899_34273406_0": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}, "so_34272899_34272899_1": {"section_id": 6841, "quality": 0.7777777777777778, "length": 14}}}, "34272899": {"CommentCount": "3", "ViewCount": "259", "CreationDate": "2015-12-14T17:17:50.213", "LastActivityDate": "2015-12-15T22:43:00.607", "Title": "Where in C++14 Standard does it say that a non-constexpr function cannot be used in a definition of a constexpr function?", "AcceptedAnswerId": "34272949", "PostTypeId": "1", "Id": "34272899", "Score": "7", "Body": "<p>For example the code below doesn't compile unless <code>incr()</code> is declared <code>constexpr</code>:</p>\n<pre><code>int incr(int&amp; n) {\n    return ++n;\n}\n\nconstexpr int foo() {\n    int n = 0;\n    incr(n);\n    return n;\n}\n</code></pre>\n<p>Looking at \u00a77.1.5/3 in C++14 we have:  </p>\n<blockquote>\n<p id=\"so_34272899_34272899_0\">The definition of a constexpr function shall satisfy the following\n  constraints:<br>\n  (3.1) \u2014 it shall not be virtual (10.3);<br>\n  (3.2) \u2014 its return type shall be a literal type;<br>\n  (3.3) \u2014 each of its parameter types shall be a literal type;<br>\n  (3.4) \u2014 its function-body shall be = delete, = default, or a compound-statement that does not contain  </br></br></br></br></p>\n<p id=\"so_34272899_34272899_1\">(3.4.1)  \u2014 an asm-definition,<br>\n  (3.4.2)  \u2014 a goto statement,<br>\n  (3.4.3)  \u2014 a try-block, or<br>\n  (3.4.4)  \u2014 a definition of a variable of\n  non-literal type or of static or thread storage duration or for which\n  no initialization is performed.</br></br></br></p>\n</blockquote>\n", "Tags": "<c++><language-lawyer><c++14><constexpr>", "OwnerUserId": "411165", "AnswerCount": "3"}});