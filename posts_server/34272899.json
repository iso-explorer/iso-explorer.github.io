post_cb({"34273406": {"Id": "34273406", "PostTypeId": "2", "Body": "<p>What you're looking for is \u00a7 5.19:</p>\n<blockquote>\n<p id=\"so_34272899_34273406_0\">A <em>conditional-expression</em> <strong>e</strong> is a core constant expression unless the evaluation of <strong>e</strong>, following the rules of the abstract machine (1.9), would evaluate one of the following expressions:</p>\n</blockquote>\n<p>This applies to the evaluation of an expression that is a <code>constexpr</code> function call. That is, calling a <code>constexpr</code> function will be a 'core constant expression' if evaluating the function, i.e. executing the body of the function according to the rules of the C++ abstract machine, doesn't do any of the things forbidden in the list given in \u00a7 5.19.</p>\n<p>One of items in the list is:</p>\n<blockquote id=\"so_34272899_34273406_1\">\n<ul>\n<li>an invocation of a function other than [...] a constexpr function</li>\n</ul>\n</blockquote>\n<p>So to apply this to your example: evaluating the expression <code>foo()</code> evaluates a call to a function <code>incr()</code> which is not a constexpr function, which means that the expression <code>foo()</code> is not a core constant expression.</p>\n<p>Further, since the above is true for all possible invocations of your function <code>foo</code>, the rule in \u00a7 7.1.5/5 kicks in and means that your example program is ill-formed, no diagnostic required, even if you never actually call <code>foo()</code>.</p>\n<hr>\n<p>As Ben Voigt points out a constexpr function can contain calls to non-consexpr functions, so long as the particular evaluation of the function does not actually evaluate any such function call (or it appears in a context that does not require a constant expression).</p>\n<p>The restrictions in 5.19 only pertain to what expressions actually end up being evaluated as part of the evaluation of an expression.</p>\n<p>For example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint incr(int &amp;n) { return ++n; }\n\nenum E {be_constexpr, not_constexpr};\n\nconstexpr int foo(E e = be_constexpr) {\n  int n = 0;\n  if (e == not_constexpr) { incr(n); }\n  return n;\n}\n\nint main() {\n  constexpr int a = foo(); // foo() is a constant expression\n  int b = foo(not_constexpr); // may or may not evaluate `foo(non_constexpr)` at runtime. In practice modern C++ compilers will do compile-time evaluation here even though they aren't required to.\n  // constexpr int c = foo(not_constexpr); // Compile error because foo(not_constexpr) is not formally a constant expression, even though modern compilers can evaluate it at compile-time.\n\n  std::cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; '\\n';\n}\n</code></pre>\n</hr>", "LastEditorUserId": "365496", "LastActivityDate": "2015-12-15T22:43:00.607", "Score": "8", "CreationDate": "2015-12-14T17:46:52.427", "ParentId": "34272899", "CommentCount": "1", "OwnerUserId": "365496", "LastEditDate": "2015-12-15T22:43:00.607"}, "34272899": {"ViewCount": "259", "Body": "<p>For example the code below doesn't compile unless <code>incr()</code> is declared <code>constexpr</code>:</p>\n<pre><code>int incr(int&amp; n) {\n    return ++n;\n}\n\nconstexpr int foo() {\n    int n = 0;\n    incr(n);\n    return n;\n}\n</code></pre>\n<p>Looking at \u00a77.1.5/3 in C++14 we have:  </p>\n<blockquote>\n<p id=\"so_34272899_34272899_0\">The definition of a constexpr function shall satisfy the following\n  constraints:<br>\n  (3.1) \u2014 it shall not be virtual (10.3);<br>\n  (3.2) \u2014 its return type shall be a literal type;<br>\n  (3.3) \u2014 each of its parameter types shall be a literal type;<br>\n  (3.4) \u2014 its function-body shall be = delete, = default, or a compound-statement that does not contain  </br></br></br></br></p>\n<p id=\"so_34272899_34272899_1\">(3.4.1)  \u2014 an asm-definition,<br>\n  (3.4.2)  \u2014 a goto statement,<br>\n  (3.4.3)  \u2014 a try-block, or<br>\n  (3.4.4)  \u2014 a definition of a variable of\n  non-literal type or of static or thread storage duration or for which\n  no initialization is performed.</br></br></br></p>\n</blockquote>\n", "AcceptedAnswerId": "34272949", "Title": "Where in C++14 Standard does it say that a non-constexpr function cannot be used in a definition of a constexpr function?", "CreationDate": "2015-12-14T17:17:50.213", "Id": "34272899", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2015-12-15T22:43:00.607", "Score": "7", "OwnerUserId": "411165", "Tags": "<c++><language-lawyer><c++14><constexpr>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_34272899_34272949_0": {"length": 25, "quality": 0.7575757575757576, "section_id": 5421}, "so_34272899_34273406_1": {"length": 6, "quality": 1.0, "section_id": 6185}, "so_34272899_34272899_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 5419}, "so_34272899_34272899_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 5419}, "so_34272899_34273406_0": {"length": 14, "quality": 1.0, "section_id": 6185}}, "n3337": {"so_34272899_34273406_1": {"length": 6, "quality": 1.0, "section_id": 5946}, "so_34272899_34272899_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 5214}}, "n4659": {"so_34272899_34273406_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 7687}, "so_34272899_34272949_0": {"length": 25, "quality": 0.7575757575757576, "section_id": 6843}, "so_34272899_34273406_1": {"length": 6, "quality": 1.0, "section_id": 7687}, "so_34272899_34272899_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 6841}, "so_34272899_34272899_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 6841}}}, "34272949": {"Id": "34272949", "PostTypeId": "2", "Body": "<p>Two paragraphs later, in [dcl.constexpr]/5:</p>\n<blockquote>\n<p id=\"so_34272899_34272949_0\">For a non-template, non-defaulted <code>constexpr</code> function or a non-template, non-defaulted, non-inheriting\n  constexpr constructor, if no argument values exist such that an invocation of the function or constructor\n  could be an evaluated subexpression of a core constant expression (5.20), or, for a constructor, a constant\n  initializer for some object (3.6.2), the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>No argument exists such that <code>foo()</code> could be a core constant expression because of <code>incr()</code>, therefore the program is ill-formed (NDR).</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-12-14T20:58:24.090", "Score": "10", "CreationDate": "2015-12-14T17:20:17.757", "ParentId": "34272899", "CommentCount": "9", "OwnerUserId": "2069064", "LastEditDate": "2015-12-14T20:58:24.090"}, "34272952": {"Id": "34272952", "PostTypeId": "2", "Body": "<p>It doesn't.</p>\n<p>The following is allowed, even though it does exactly what you surmise is forbidden:</p>\n<pre><code>int incr(int&amp; n) {\n    return ++n;\n}\n\nconstexpr int foo(bool x) {\n    int n = 0;\n    if (x) incr(n);\n    return n;\n}\n</code></pre>\n<p>The code in your question is disallowed by the rule with Barry quoted in his answer.  But in my variation, there does exist a set of parameters (specifically, <code>false</code>) with which invocation of <code>foo</code> results in a compile-time constant expression.</p>\n<p>Note that a diagnostic isn't required -- a conforming compiler could allow your version to compile as well.</p>\n", "LastActivityDate": "2015-12-14T17:20:24.920", "CommentCount": "3", "CreationDate": "2015-12-14T17:20:24.920", "ParentId": "34272899", "Score": "4", "OwnerUserId": "103167"}});