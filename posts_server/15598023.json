post_cb({"15598100": {"ParentId": "15598023", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>String literals are different from local variables and they remain alive throughout the program lifetime.They have static duration lifetime. You can safely return pointer to a string literal.</p>\n<p><strong>C++11 Standard \u00a72.14.5.8:</strong></p>\n<blockquote>\n<p id=\"so_15598023_15598100_0\">Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow string literal has type \u201carray of n const char\u201d, where n is the size of the string as defined below, and has static storage duration (3.7).</p>\n</blockquote>\n<p><strong>3.7.1 Static storage duration</strong><br>\n<strong>Para 1:</strong> </br></p>\n<blockquote>\n<p id=\"so_15598023_15598100_1\">...The storage for these entities shall last for the duration of the\n  program (3.6.2, 3.6.3)</p>\n</blockquote>\n<hr>\n<p>Just to be clear, The type of the string literal \"1\" is <code>char (*)[2]</code>. This is because, type of \"1\" is char[2] and pointer to an array of 2 characters is declared as <code>char (*)[2]</code>, So If you need to take address of it. When returning a reference your implicit c-style cast devolves in to a <code>reinterpret_cast</code>, which essentially can cast pointer of any type to any other type irrespective of correctness. What it gets you in you case is an Undefined behavior. As mentioned above, What you can safely return is a pointer to a string literal. You need to modify your return type as:     </p>\n<pre><code>char const* ToBoolean(bool val) const;\n</code></pre>\n<hr>\n<p><strong>Answer to Updated Q:</strong></p>\n<p>Your updated solution merely copies a string literal to an array local to the function. The array does not exist beyond the scope of the function. So no it is not okay. It might seem to work but it invokes Undefined behavior. \"true\" and \"false\" themselves have static duration lifetime but you are not returning pointer to them, You are copying them to a local array and returning pointer to the local array.</p>\n</hr></hr>", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2013-03-24T12:08:41.077", "Id": "15598100", "Score": "4", "CreationDate": "2013-03-24T11:52:26.803", "LastActivityDate": "2013-03-24T12:08:41.077"}, "15598110": {"ParentId": "15598023", "CommentCount": "9", "Body": "<p><em>char const*</em> is not the same as <em>char const&amp;</em> (the former is a <em>pointer to char</em> the latter is a reference to a single <em>char</em>. Character string constants are allocated statically so it is safe to return pointers to them from functions.</p>\n<pre><code>inline char const* ToBoolean(bool val) const \n{ \n    return val ? \"1\" : \"0\"; \n}\n</code></pre>\n", "OwnerUserId": "267482", "PostTypeId": "2", "Id": "15598110", "Score": "4", "CreationDate": "2013-03-24T11:53:06.527", "LastActivityDate": "2013-03-24T11:53:06.527"}, "15598023": {"CommentCount": "3", "AcceptedAnswerId": "15598110", "PostTypeId": "1", "LastEditorUserId": "759866", "CreationDate": "2013-03-24T11:45:13.573", "LastActivityDate": "2014-01-29T17:05:40.907", "AnswerCount": "4", "LastEditDate": "2014-01-29T17:05:40.907", "ViewCount": "758", "FavoriteCount": "2", "Title": "Returning a literal by reference and inline", "Id": "15598023", "Score": "3", "Body": "<p>Supposedly, returning a literal <em>by reference</em> in C++ is bad since the literal goes out of scope then leaving the function:</p>\n<pre><code>const char &amp;ToBoolean(bool val) const \n{ \n    return val ? (const char &amp;)\"1\" : (const char &amp;)\"0\"; \n}\n</code></pre>\n<p>, but when using <code>inline</code> I'm guessing this should be ok since the literal's scope is now in the calling function, or no? Example:</p>\n<pre><code>inline const char &amp;ToBoolean(bool val) const \n{ \n    return val ? (const char &amp;)\"1\" : (const char &amp;)\"0\"; \n}\n</code></pre>\n<p>This is how I plan to use it:</p>\n<pre><code>void testToBoolean1()\n{\n     bool val = true;\n     const char *valStr = ToBoolean(val);\n     int result = strcmp(\"1\", valStr);\n     CPPUNIT_ASSERT_EQUAL(0, result);\n}\n</code></pre>\n<p><strong>Update.</strong></p>\n<p>If static strings are ok, then how about this?</p>\n<pre><code>inline const char *ToBoolean(bool val) const { \n    char boolStr[6];\n    if (val) strcpy(boolStr, \"true\");\n    else strcpy(boolStr, \"false\");\n    return &amp;boolStr;\n}\n</code></pre>\n<p>This compiles and runs fine using VC++ 2012.</p>\n", "Tags": "<c++><inline><pass-by-reference>", "OwnerDisplayName": "user152949"}, "15598119": {"ParentId": "15598023", "PostTypeId": "2", "CommentCount": "2", "Body": "<pre><code>inline const char &amp;ToBoolean(bool val) const \n{ \n    return val ? (const char &amp;)\"1\" : (const char &amp;)\"0\"; \n}\n</code></pre>\n<p>You return a string for a <code>char</code>? - also, if you really have to return a <code>const char *</code> then explicitly state it.::</p>\n<pre><code>inline const char *ToBoolean(bool val) const \n{ \n    return val ? \"1\" : \"0\"; \n}\n</code></pre>\n", "OwnerUserId": "1680957", "LastEditorUserId": "1680957", "LastEditDate": "2013-03-24T12:02:23.313", "Id": "15598119", "Score": "1", "CreationDate": "2013-03-24T11:53:59.610", "LastActivityDate": "2013-03-24T12:02:23.313"}, "15598170": {"ParentId": "15598023", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>\"1\"</code> is a string literal of type \"array of 2 <code>const</code> <code>char</code>\". When you cast it with <code>(const char &amp;)\"1\"</code>, this results in a <code>reinterpret_cast&lt;const char&amp;&gt;(\"1\")</code> which ends up giving you undefined behaviour.</p>\n<p>Perhaps you're meaning to do:</p>\n<pre><code>inline const char &amp;ToBoolean(bool val)\n{ \n    return val ? '1' : '0'; \n}\n</code></pre>\n<p>Notice the single quotes. These are character literals, rather than string literals.</p>\n<p>However, because the character literals are prvalues, the binding to the <code>const char&amp;</code> results in a temporary object being made with the corresponding value. The reference is then bound to <em>that</em> temporary object. However, that temporary object will be destroyed at the end of the full expression (the <code>return</code> statement) and the reference will be left dangling.</p>\n<p>And no, <code>inline</code> doesn't affect the scope of variables or the lifetime of objects. That would be silly because it's only a hint to the compiler about what to do. That would mean the compiler could choose to change the meaning of your code if it wanted to.</p>\n<p>So instead, try returning a pointer to the string literal:</p>\n<pre><code>inline const char* ToBoolean(bool val)\n{ \n    return val ? \"1\" : \"0\"; \n}\n</code></pre>\n<p>String literals have static storage duration, which means that they exist for the duration of the program. You can return a pointer to the first element in the string literal and be sure that the object it points to will always be valid.</p>\n", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2013-03-24T12:07:38.027", "Id": "15598170", "Score": "2", "CreationDate": "2013-03-24T11:58:59.543", "LastActivityDate": "2013-03-24T12:07:38.027"}, "bq_ids": {"n4140": {"so_15598023_15598100_1": {"section_id": 7164, "quality": 0.5714285714285714, "length": 4}, "so_15598023_15598100_0": {"section_id": 5356, "quality": 1.0, "length": 26}}, "n3337": {"so_15598023_15598100_1": {"section_id": 6908, "quality": 0.5714285714285714, "length": 4}, "so_15598023_15598100_0": {"section_id": 5153, "quality": 1.0, "length": 26}}, "n4659": {"so_15598023_15598100_1": {"section_id": 8672, "quality": 0.5714285714285714, "length": 4}, "so_15598023_15598100_0": {"section_id": 6781, "quality": 1.0, "length": 26}}}});