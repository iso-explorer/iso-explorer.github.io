post_cb({"9316476": {"CommentCount": "2", "AcceptedAnswerId": "9317141", "PostTypeId": "1", "LastEditorUserId": "44390", "CreationDate": "2012-02-16T17:57:11.237", "LastActivityDate": "2016-05-02T16:55:26.810", "AnswerCount": "5", "LastEditDate": "2012-05-10T13:05:42.563", "ViewCount": "3866", "FavoriteCount": "3", "Title": "How do i use decimal (float) in C++?", "Id": "9316476", "Score": "4", "Body": "<p>According to <a href=\"http://en.wikipedia.org/wiki/IEEE_754-2008\" rel=\"nofollow\">IEEE 754-2008</a> there are</p>\n<blockquote>\n<p id=\"so_9316476_9316476_0\">There are three binary floating-point basic formats (which can be\n  encoded using 32, 64 or 128 bits) and two decimal floating-point basic\n  formats (which can be encoded using 64 or 128 bits).</p>\n</blockquote>\n<p>This chart is under it. In C++ I believe float and double are single and double precision (binary32 and binary64). What class/struct may i use for decimalX and is there something i can use for binary128? Are these classes/structs standard or nonstandard?</p>\n<pre><code>Name        Common name         Base  Digits E min  E max   Digits  E max\nbinary32    Single precision    2     23+1   \u2212126   +127    7.22    38.23\nbinary64    Double precision    2     52+1   \u22121022  +1023   15.95   307.95\nbinary128   Quadruple precision 2     112+1  -16382 +16383  34.02   4931.77\ndecimal32                       10    7      \u221295    +96     7       96\ndecimal64                       10    16     \u2212383   +384    16      384\ndecimal128                      10    34     \u22126143  +6144   34      6144\n</code></pre>\n", "Tags": "<c++><floating-point>", "OwnerDisplayName": "user34537"}, "9316506": {"ParentId": "9316476", "CommentCount": "2", "Body": "<p>C++ does not specify that <code>float</code>s must be 32-bit or that <code>double</code>s must be 64-bit. It does not even require there to be 8 bits in a byte (though there do have to be <em>at least</em> 8).</p>\n<blockquote>\n<p id=\"so_9316476_9316506_0\"><code>[C++11: 3.9.1/8]:</code> There are three floating point types: <code>float</code>, <code>double</code>, and <code>long double</code>. <strong>The type <code>double</code> provides at least as much precision as <code>float</code>, and the type <code>long double</code> provides at least as much precision as <code>double</code>.</strong> The set of values of the type <code>float</code> is a subset of the set of values of the type <code>double</code>; the set of values of the type <code>double</code> is a subset of the set of values of the type <code>long double</code>. <strong>The value representation of floating-point types is implementation-defined</strong>. Integral and floating types are collectively called arithmetic types. Specializations of the standard template <code>std::numeric_limits</code> (18.3) shall specify the maximum and minimum values of each arithmetic type for an implementation.</p>\n</blockquote>\n<p>See the documentation for your toolchain and platform to see what its type sizes are. It might support <code>long double</code>, which in turn might be what you want.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "9316506", "Score": "6", "CreationDate": "2012-02-16T17:59:55.663", "LastActivityDate": "2012-02-16T17:59:55.663"}, "36987620": {"ParentId": "9316476", "CommentCount": "0", "Body": "<p>If you want the convenience of built-in operators, but don't want to write it yourself, I'd recommend checking out <a href=\"https://github.com/bloomberg\" rel=\"nofollow\">Bloomberg Finance's open-source C++ libraries on GitHub</a>. In particular, the <a href=\"https://github.com/bloomberg/bde\" rel=\"nofollow\">BDE</a> package contains a IEEE 754 \"Decimal 32/64/128\" implementation (see <a href=\"https://github.com/bloomberg/bde/blob/master/groups/bdl/bdldfp/bdldfp_decimal.h\" rel=\"nofollow\">bdldfp_decimal.h)</a></p>\n<p>The nice thing about this library is that it supports multiple different IEEE 754 backend implementations, including a C99 reference implementation, the decNumber implementation that comes with GCC, and Intel's open-source IntelDFP library (see <a href=\"https://github.com/bloomberg/bde/blob/37708ef6aec15c8052d137a366925f6caf46fe53/groups/bdl/bdldfp/bdldfp_decimalplatform.h\" rel=\"nofollow\">bdldfp_decimalplatform.h</a> for details). It also supports configurable endian-ness.</p>\n", "OwnerUserId": "434413", "PostTypeId": "2", "Id": "36987620", "Score": "0", "CreationDate": "2016-05-02T16:55:26.810", "LastActivityDate": "2016-05-02T16:55:26.810"}, "9317141": {"ParentId": "9316476", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>In addition to the 32-bit <code>float</code> and 64-bit <code>double</code>, GCC offers <code>__float80</code>, <code>__float128</code>, <code>_Decimal32</code>, <code>_Decimal64</code>, <code>_Decimal128</code>; for ARM targets, it also offers the half-precision <code>__fp16</code>.</p>\n<p>Intel CPUs support 80-bit floats in hardware using the old scalar x87 FPU instructions (but not with the SSE vector instructions). I'm not aware of any mainstream CPUs with hardware support for the decimal FP types.</p>\n<p>It looks like the current crop of Microsoft compilers provide 64-bit for both <code>double</code> and <code>long double</code>, but older ones gave you 80-bit for <code>long double</code>.</p>\n<p>See documentation here:</p>\n<ul>\n<li><a href=\"http://gcc.gnu.org/onlinedocs/gcc/Floating-Types.html\" rel=\"nofollow\">http://gcc.gnu.org/onlinedocs/gcc/Floating-Types.html</a></li>\n<li><a href=\"http://gcc.gnu.org/onlinedocs/gcc/Half_002dPrecision.html\" rel=\"nofollow\">http://gcc.gnu.org/onlinedocs/gcc/Half_002dPrecision.html</a></li>\n<li><a href=\"http://gcc.gnu.org/onlinedocs/gcc/Decimal-Float.html\" rel=\"nofollow\">http://gcc.gnu.org/onlinedocs/gcc/Decimal-Float.html</a></li>\n</ul>\n", "OwnerUserId": "374746", "LastEditorUserId": "374746", "LastEditDate": "2012-11-10T18:16:03.620", "Id": "9317141", "Score": "7", "CreationDate": "2012-02-16T18:42:38.530", "LastActivityDate": "2012-11-10T18:16:03.620"}, "9316772": {"ParentId": "9316476", "CommentCount": "0", "Body": "<p>Intel has a <a href=\"http://software.intel.com/en-us/articles/intel-decimal-floating-point-math-library/\">decimal floating-point library</a> which will work with either ICC or GCC on Mac, Linux, HP/UX, or Solaris; or the ICC or CL compilers on Windows. It's not as useful as using operators on built-in types. If you're using C++, maybe someone has already written helpful classes that override all the necessary operators for that.</p>\n", "OwnerUserId": "25844", "PostTypeId": "2", "Id": "9316772", "Score": "5", "CreationDate": "2012-02-16T18:18:58.053", "LastActivityDate": "2012-02-16T18:18:58.053"}, "9316551": {"ParentId": "9316476", "CommentCount": "2", "Body": "<p>C++ does not provide decimal types; the only floating point types are <code>float</code>, <code>double</code> and <code>long double</code>.</p>\n<p>Neither does C++ specify that these use IEEE754 representations, or that they have any particular size. The only requirement is that <code>double</code> provides at least as much precision as <code>float</code>, and that <code>long double</code> provides at least as much precision as <code>double</code>.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "9316551", "Score": "5", "CreationDate": "2012-02-16T18:03:02.043", "LastActivityDate": "2012-02-16T18:03:02.043"}, "bq_ids": {"n4140": {"so_9316476_9316506_0": {"section_id": 7217, "quality": 0.8611111111111112, "length": 62}}, "n3337": {"so_9316476_9316506_0": {"section_id": 6961, "quality": 0.8472222222222222, "length": 61}}, "n4659": {"so_9316476_9316506_0": {"section_id": 8726, "quality": 0.875, "length": 63}}}});