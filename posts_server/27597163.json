post_cb({"27597299": {"ParentId": "27597163", "CommentCount": "0", "Body": "<p>The whole point of introducing scoped enumerations into the language was to prevent implicit conversions to the underlying type. So in your failing example there's no way to implicitly convert from a <code>C::x</code> to whatever integral type the underlying type of <code>D</code> is.</p>\n<p>Add the appropriate casts, and your code compiles.</p>\n<pre><code>#include &lt;type_traits&gt;\n\nenum struct C { x = 5 };\n\nenum D \n{ \n    y = 0, \n    x = static_cast&lt;std::underlying_type&lt;C&gt;::type&gt;(C::x)\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/4111fb66e589c2cd\" rel=\"nofollow\">Live demo</a></p>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "27597299", "Score": "1", "CreationDate": "2014-12-22T06:04:35.183", "LastActivityDate": "2014-12-22T06:04:35.183"}, "27597163": {"CommentCount": "3", "ViewCount": "65", "OwnerDisplayName": "user2953119", "CreationDate": "2014-12-22T05:48:56.237", "LastActivityDate": "2014-12-22T06:05:09.420", "PostTypeId": "1", "AcceptedAnswerId": "27597304", "Title": "Initializer for the numeration with non-fixed type", "Id": "27597163", "Score": "0", "Body": "<p>The standard says at <code>7.2/5 [dcl.enum]</code>:</p>\n<blockquote>\n<p id=\"so_27597163_27597163_0\">If the underlying type is not fixed, the type of each enumerator prior\n  to the closing brace is determined as follows:</p>\n<p id=\"so_27597163_27597163_1\">(5.1) \u2014 If an initializer is specified for an enumerator, the\n  constant-expression shall be an integral constant expression (5.20).\n  If the expression has unscoped enumeration type, the enumerator has\n  the underlying type of that enumeration type, otherwise it has the\n  same type as the expression.</p>\n<p id=\"so_27597163_27597163_2\">(5.2) \u2014 If no initializer is specified for the first enumerator, its\n  type is an unspecified signed integral type.</p>\n<p id=\"so_27597163_27597163_3\">(5.3) \u2014 Otherwise the type of the enumerator is the same as that of\n  the preceding enumerator unless the incremented value is not\n  representable in that type, in which case the type is an unspecified\n  integral type sufficient to contain the incremented value. If no such\n  type exists, the program is ill-formed.</p>\n</blockquote>\n<p>So, all the following cases are covered by <code>5.1</code> and <code>5.2</code>:</p>\n<p><strong>I.</strong> <code>enum A { x = 4 }; //case 1, initializer was specified</code></p>\n<p><strong>II.</strong> <code>enum B { x, y };  //case 2, initializer was not specified.</code></p>\n<p><strong>III.</strong> </p>\n<pre><code>enum C { x = 5 };\n\nenum D { y = x }; // case 1, y had unscoped enumeration type.\n</code></pre>\n<p><strong>IV.</strong></p>\n<pre><code>enum struct C { x = 5 };\n\nenum D { y = 0, x = C::x }; // even integral constant expression must have integral\n                            // or unscoped enumeration type, not 'C\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/89ccda7dc960346d\" rel=\"nofollow\"><strong>DEMO</strong></a></p>\n<p>I'd like to look at the <code>5.3</code> case in action. Why didn't case <code>IV</code> even compile?</p>\n", "Tags": "<c++><enums>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27597163_27597163_1": {"section_id": 5464, "quality": 0.9523809523809523, "length": 20}, "so_27597163_27597163_3": {"section_id": 5464, "quality": 1.0, "length": 23}, "so_27597163_27597304_0": {"section_id": 5464, "quality": 0.9, "length": 9}, "so_27597163_27597163_2": {"section_id": 5464, "quality": 1.0, "length": 10}, "so_27597163_27597163_0": {"section_id": 5464, "quality": 1.0, "length": 11}, "so_27597163_27597304_1": {"section_id": 6189, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_27597163_27597163_1": {"section_id": 5855, "quality": 0.6190476190476191, "length": 13}, "so_27597163_27597163_3": {"section_id": 5251, "quality": 0.9565217391304348, "length": 22}, "so_27597163_27597304_0": {"section_id": 5251, "quality": 0.9, "length": 9}, "so_27597163_27597163_2": {"section_id": 5251, "quality": 0.8, "length": 8}, "so_27597163_27597163_0": {"section_id": 5251, "quality": 0.8181818181818182, "length": 9}, "so_27597163_27597304_1": {"section_id": 5855, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_27597163_27597163_1": {"section_id": 6898, "quality": 0.9523809523809523, "length": 20}, "so_27597163_27597163_3": {"section_id": 6898, "quality": 1.0, "length": 23}, "so_27597163_27597304_0": {"section_id": 6898, "quality": 0.9, "length": 9}, "so_27597163_27597163_2": {"section_id": 6898, "quality": 1.0, "length": 10}, "so_27597163_27597163_0": {"section_id": 6898, "quality": 1.0, "length": 11}, "so_27597163_27597304_1": {"section_id": 7692, "quality": 0.8888888888888888, "length": 8}}}, "27597304": {"ParentId": "27597163", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_27597163_27597304_0\"><strong>7.2/5</strong> Following the closing brace of an enum-specifier, each enumerator has the type of its enumeration.</p>\n</blockquote>\n<p>So within the definition of <code>D</code>, <code>C::x</code> is of type <code>C</code>.</p>\n<blockquote>\n<p id=\"so_27597163_27597304_1\"><strong>5.19/3</strong> An <em>integral constant expression</em> is an expression of integral or <strong>unscoped</strong> enumeration type...</p>\n</blockquote>\n<p>Emphasis mine. So <code>C::x</code> is not an integral constant expression, and cannot serve as an initialiser for an enumerator.</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "27597304", "Score": "0", "CreationDate": "2014-12-22T06:05:09.420", "LastActivityDate": "2014-12-22T06:05:09.420"}});