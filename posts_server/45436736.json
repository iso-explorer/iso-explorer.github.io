post_cb({"bq_ids": {"n4140": {"so_45436736_45436736_0": {"length": 29, "quality": 0.8055555555555556, "section_id": 7040}}, "n4659": {"so_45436736_45436736_0": {"length": 29, "quality": 0.8055555555555556, "section_id": 8537}}}, "45436736": {"ViewCount": "78", "Body": "<p>Given the code snippet:</p>\n<pre><code>struct S {\n    static const int var = 0; \n}; \n\nint function(const int&amp; rVar){\n    return rVar; \n}\n\nint main()\n{\n    return function(S::var); \n}\n</code></pre>\n<p>Compiled with <code>gcc 5.4.0</code>:</p>\n<pre><code>g++ -std=c++17 main.cpp -o test\n</code></pre>\n<p>results in the following <em>linkage error</em>: </p>\n<p><code>/tmp/ccSeEuha.o: In function `main':\nmain.cpp:(.text+0x15): undefined reference to `S::var'\ncollect2: error: ld returned 1 exit status\n</code></p>\n<p><code>\u00a73.3</code> from the ISO Standard C++17 draft <code>n4296</code> states: </p>\n<blockquote>\n<p id=\"so_45436736_45436736_0\">A variable x whose name appears as a potentially-evaluated expression ex is odr-used by ex unless applying\n  the lvalue-to-rvalue conversion (4.1) to x yields a constant expression (5.20) that does not invoke any non-\n  trivial functions and, <strong>if x is an object, ex is an element of the set of potential results of an expression e,\n  where either the lvalue-to-rvalue conversion (4.1) is applied to e</strong> [<em>bold-type</em> formatting added], or e is a discarded-value expression (Clause 5).</p>\n</blockquote>\n<p><strong>Q:</strong> Why is a definition of the variable <code>var</code> required here? Isn't <code>var</code> denoting an integer object that appears in the <em>potentially-evaluted</em> expression <code>S::var</code> of an outter function call expression, which indeed takes a parameter by reference, but to which finally a lvalue-to-rvalue conversion is applied, and, thus isn't <em>odr-used</em> as stated in the paragraph? </p>\n", "AcceptedAnswerId": "45437642", "Title": "Are variables appearing in function expression taking arguments by reference but returning by value odr-used?", "CreationDate": "2017-08-01T11:36:50.457", "Id": "45436736", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2017-08-01T12:38:01.380", "Score": "3", "OwnerUserId": "4884487", "Tags": "<c++><language-lawyer><c++1z>", "AnswerCount": "2"}, "45437451": {"Id": "45437451", "PostTypeId": "2", "Body": "<p>It is explicit in the example show just above the paragraph you quoted: in <code>function(S::var);</code>, <code>S::var</code> is odr-used.</p>\n<p>The reason is that as <code>function</code> takes its parameter by ref (and not by value), no lvalue to rvalue conversion occurs.</p>\n<p>But if you change <code>function</code> to take its argument by value:</p>\n<pre><code>int function(const int rVar){\n    return rVar; \n}\n</code></pre>\n<p>then the lvalue to rvalue conversion occurs, and <code>S::var</code> is non longer odr-used. And the program no longer exhibit the undefined reference...</p>\n", "Score": "1", "LastActivityDate": "2017-08-01T12:10:49.340", "CreationDate": "2017-08-01T12:10:49.340", "ParentId": "45436736", "CommentCount": "3", "OwnerUserId": "3545273"}, "45437642": {"Id": "45437642", "PostTypeId": "2", "LastEditDate": "2017-08-01T12:38:01.380", "CommentCount": "0", "LastEditorUserId": "2079303", "LastActivityDate": "2017-08-01T12:38:01.380", "CreationDate": "2017-08-01T12:20:55.367", "ParentId": "45436736", "Score": "5", "Body": "<blockquote>\n<p id=\"so_45436736_45437642_0\">but to which finally a lvalue-to-rvalue conversion is applied, and, thus isn't odr-used as stated in the paragraph? </p>\n</blockquote>\n<p>The lvalue-to-rvalue conversion in the other expression is irrelevant I believe. There is no lvalue-to-rvalue conversion applied to subexpression <code>S::var</code> in the expression <code>function(S::var)</code>, thus the exception does not apply.</p>\n<hr>\n<p>Considering from the common sense point of view, rather than analysing the rule: <code>function</code>could be defined in another translation unit, so the compiler cannot necessarily know how the reference would be used. It cannot just send a copy of the value to the function and hope that the function definition won't use the object in a way that would require the definition of the referred object. Likewise, when compiling the function, the compiler cannot assume that all function calls would send anything other than a reference to an object that exists.</p>\n<p>Technically, I suppose that there could be yet more complicated exception for reference arguments of inline functions, but there isn't such exception in the standard. And there shouldn't be since it would make inline expansion mandatory in those cases. In practice, a compiler might behave exactly as such exception would require if it happens to expand the function inline, since odr violations have undefined behaviour.</p>\n</hr>", "OwnerUserId": "2079303"}});