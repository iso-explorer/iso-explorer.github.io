post_cb({"28290792": {"CommentCount": "1", "AcceptedAnswerId": "28290885", "PostTypeId": "1", "LastEditorUserId": "1774667", "CreationDate": "2015-02-03T03:20:11.573", "LastActivityDate": "2015-09-01T14:38:24.447", "LastEditDate": "2015-09-01T14:38:24.447", "ViewCount": "386", "FavoriteCount": "1", "Title": "How do I pass on a variadic argument list while keeping a single argument", "Id": "28290792", "Score": "2", "Body": "<p>Suppose I have a base class that might later be \"extended\" by deriving from it, let's call this class <code>Base</code>, and the extension <code>Derived</code>. <strong>The template signature of the classes is fixed, and cannot be altered</strong> (ie. we cannot change the template arguments to the classes). The writer of the <code>Derived</code> class knows nothing about <code>Base</code>, only that it <em>might</em> take some arguments to its constructor.</p>\n<p>However, the caller of the final derived class knows how many arguments should be passed. How can I write this <code>Derived</code> extension? Here is what I have:</p>\n<pre><code>struct Base\n{\n    Base(int baseArg) {}\n};\n\nstruct Derived : public Base\n{\n    template &lt;typename... Args&gt;\n    Derived(Args&amp;&amp;... args, int derivedArg)\n    :\n        Base(std::forward&lt;Args&gt;(args)...)\n    {\n    }\n};\n</code></pre>\n<p>When I try to <a href=\"http://ideone.com/jw68h6\" rel=\"nofollow\">run this</a> with <code>Derived d(1, 1);</code> I get the following erorr message:</p>\n<pre><code>prog.cpp: In function 'int main()':\nprog.cpp:19:16: error: no matching function for call to 'Derived::Derived(int, int)'\n  Derived d(1, 1);\n                ^\nprog.cpp:19:16: note: candidates are:\nprog.cpp:11:2: note: template&lt;class ... Args&gt; Derived::Derived(Args&amp;&amp; ..., int)\n  Derived(Args&amp;&amp;... args, int myArg)\n  ^\nprog.cpp:11:2: note:   template argument deduction/substitution failed:\nprog.cpp:19:16: note:   candidate expects 1 argument, 2 provided\n  Derived d(1, 1);\n                ^\nprog.cpp:8:8: note: constexpr Derived::Derived(const Derived&amp;)\n struct Derived : public Base\n        ^\nprog.cpp:8:8: note:   candidate expects 1 argument, 2 provided\nprog.cpp:8:8: note: constexpr Derived::Derived(Derived&amp;&amp;)\nprog.cpp:8:8: note:   candidate expects 1 argument, 2 provided\n</code></pre>\n<p>The constructor to <code>Derived</code> should take 2 arguments, using the first to construct itself and passing the 2nd to the base class. Why doesn't this work?</p>\n", "Tags": "<c++><templates><c++11><constructor><variadic-templates>", "OwnerUserId": "1613983", "AnswerCount": "2"}, "28291094": {"ParentId": "28290792", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2015-02-03T03:53:45.017", "Score": "5", "LastEditorUserId": "1774667", "LastEditDate": "2015-02-07T02:06:59.947", "Id": "28291094", "OwnerUserId": "1774667", "Body": "<p><code>nth</code> gets the nth element of some parameters:</p>\n<pre><code>template&lt;size_t n, class...Args&gt;\nauto nth( Args&amp;&amp;... args )\n-&gt;typename std::tuple_element&lt;n,std::tuple&lt;Args&amp;&amp;...&gt;&gt;::type\n{\n  return std::get&lt;n&gt;( std::forward_as_tuple(std::forward&lt;Args&gt;(args)...) );\n}\n</code></pre>\n<p>This uses the above to extract the last, and all-but-last, argument and send them to the appropriate spot:</p>\n<pre><code>struct Derived : public Base {\n  struct tag{};\n  template &lt;typename... Args&gt;\n  Derived(Args&amp;&amp;... args) : Derived(\n    tag{},\n    std::make_index_sequence&lt;sizeof...(Args)-1&gt;{},\n    std::forward&lt;Args&gt;(args)...\n  ){}\n  template&lt;size_t...Is, class...Args&gt;\n  Derived(tag, std::index_sequence&lt;Is...&gt;, Args&amp;&amp;...args ):\n    Base(nth&lt;Is&gt;(std::forward&lt;Args&gt;(args)...)...)\n  {\n    int derivedArg = nth&lt;sizeof...(Args)-1&gt;(std::forward&lt;Args&gt;(args)...);\n  }\n};\n</code></pre>\n<p>We build a sequence for the first n-1 elements, pass them to base, and store the last element for ourselves.</p>\n<p>It is far easier if you put the extra argument first, however.</p>\n", "LastActivityDate": "2015-02-07T02:06:59.947"}, "bq_ids": {"n4140": {"so_28290792_28290885_2": {"section_id": 336, "quality": 1.0, "length": 7}}, "n3337": {"so_28290792_28290885_2": {"section_id": 293, "quality": 1.0, "length": 7}}, "n4659": {"so_28290792_28290885_2": {"section_id": 345, "quality": 1.0, "length": 7}}}, "28290885": {"ParentId": "28290792", "CommentCount": "1", "CreationDate": "2015-02-03T03:29:49.787", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "28290885", "Score": "4", "Body": "<p>The <code>Derived</code> constructor is a non-deduced context. From [temp.deduct.type], \u00a714.8.2.5/5:</p>\n<blockquote>\n<p id=\"so_28290792_28290885_0\">The non-deduced contexts are:</p>\n<p id=\"so_28290792_28290885_1\">\u2014 [ .. ]</p>\n<p id=\"so_28290792_28290885_2\">\u2014 A function parameter pack that does not occur at the end of the <em>parameter-declaration-list</em>.</p>\n</blockquote>\n<p>In your case, the parameter pack isn't at the end - there's one more argument after it, so it's a non-deduced context, which makes your program ill-formed. The simple solution is to just invert the ordering:</p>\n<pre><code>template &lt;typename... Args&gt;\nDerived(int derivedArg, Args&amp;&amp;... args) // totally OK\n:\n    Base(std::forward&lt;Args&gt;(args)...)\n{\n}\n</code></pre>\n", "LastActivityDate": "2015-02-03T03:29:49.787"}});