post_cb({"13952386": {"ParentId": "115703", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2012-12-19T12:21:45.693", "Score": "79", "LastEditorUserId": "510036", "LastEditDate": "2016-08-10T02:15:08.123", "Id": "13952386", "OwnerUserId": "708995", "Body": "<p>For others on this page wondering what the correct syntax is (as did I) for explicit template specialisation (or at least in VS2008), its the following...</p>\n<p>In your .h file...</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>template&lt;typename T&gt;\nclass foo\n{\npublic:\n    void bar(const T &amp;t);\n};\n</code></pre>\n<p>And in your .cpp file</p>\n<pre><code>template &lt;class T&gt;\nvoid foo&lt;T&gt;::bar(const T &amp;t)\n{ }\n\n// Explicit template instantiation\ntemplate class foo&lt;int&gt;;\n</code></pre>\n", "LastActivityDate": "2016-08-10T02:15:08.123"}, "41292751": {"ParentId": "115703", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-12-22T22:48:07.130", "Score": "4", "LastEditorUserId": "4612476", "LastEditDate": "2017-07-06T05:15:23.013", "Id": "41292751", "OwnerUserId": "4612476", "Body": "<p>Your example is correct but not very portable. There is also a slightly cleaner syntax that can be used (as pointed out by @namespace-sid).</p>\n<p>Suppose the templated class is part of some library that is to be shared. Should other versions of the templated class be compiled? Is the library maintainer supposed to anticipate all possible templated uses of the class?</p>\n<p>An alternate approach is a slight variation on what you have: add a third file that is the template implementation/instantiation file.</p>\n<p><strong>foo.h file</strong></p>\n<pre><code>// Standard header file guards omitted\n\ntemplate &lt;typename T&gt;\nclass foo\n{\npublic:\n    void bar(const T&amp; t);\n};\n</code></pre>\n<p><strong>foo.cpp file</strong></p>\n<pre><code>// Always include your headers\n#include \"foo.h\"\n\ntemplate &lt;typename T&gt;\nvoid foo::bar(const T&amp; t)\n{\n    // Do something with t\n}\n</code></pre>\n<p><strong>foo-impl.cpp file</strong></p>\n<pre><code>// Yes, we include the .cpp file\n#include \"foo.cpp\"\ntemplate class foo&lt;int&gt;;\n</code></pre>\n<p>The one caveat is that you need to tell the compiler to compile <code>foo-impl.cpp</code> instead of <code>foo.cpp</code> as compiling the latter does nothing.</p>\n<p>Of course, you can have multiple implementations in the third file or have multiple implementation files for each type you'd like to use.</p>\n<p>This enables much more flexibility when sharing the templated class for other uses.</p>\n<p>This setup also reduces compile times for reused classes because you're not recompiling the same header file in each translation unit.</p>\n", "LastActivityDate": "2017-07-06T05:15:23.013"}, "115703": {"CommentCount": "4", "ViewCount": "206296", "PostTypeId": "1", "LastEditorUserId": "4727", "LastEditorDisplayName": "Leon Timmermans", "CreationDate": "2008-09-22T15:55:52.830", "LastActivityDate": "2017-07-06T05:15:23.013", "AnswerCount": "10", "LastEditDate": "2008-09-29T15:56:38.423", "AcceptedAnswerId": "115735", "FavoriteCount": "138", "Title": "Storing C++ template function definitions in a .CPP file", "Id": "115703", "Score": "326", "Body": "<p>I have some template code that I would prefer to have stored in a CPP file instead of inline in the header.  I know this can be done as long as you know which template types will be used.  For example:</p>\n<p><strong>.h file</strong></p>\n<pre><code>class foo\n{\npublic:\n    template &lt;typename T&gt;\n    void do(const T&amp; t);\n};\n</code></pre>\n<p><strong>.cpp file</strong></p>\n<pre><code>template &lt;typename T&gt;\nvoid foo::do(const T&amp; t)\n{\n    // Do something with t\n}\n\ntemplate void foo::do&lt;int&gt;(const int&amp;);\ntemplate void foo::do&lt;std::string&gt;(const std::string&amp;);\n</code></pre>\n<p>Note the last two lines - the foo::do template function is only used with ints and std::strings, so those definitions mean the app will link.</p>\n<p>My question is - is this a nasty hack or will this work with other compilers/linkers? I am only using this code with VS2008 at the moment but will be wanting to port to other environments.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "9236", "OwnerDisplayName": "Rob"}, "115792": {"ParentId": "115703", "CommentCount": "3", "CreationDate": "2008-09-22T16:07:57.357", "OwnerUserId": "3279", "Id": "115792", "PostTypeId": "2", "OwnerDisplayName": "Ben Collins", "Score": "4", "Body": "<p>There is, in the latest standard, a keyword (<code>export</code>) that would help alleviate this issue, but it isn't implemented in any compiler that I'm aware of, other than Comeau.</p>\n<p>See the <a href=\"http://www.parashift.com/c++-faq-lite/templates.html#faq-35.14\" rel=\"nofollow noreferrer\">FAQ-lite</a> about this.</p>\n", "LastActivityDate": "2008-09-22T16:07:57.357"}, "8030638": {"ParentId": "115703", "CommentCount": "1", "CreationDate": "2011-11-06T21:44:49.250", "OwnerUserId": "339249", "PostTypeId": "2", "Id": "8030638", "Score": "6", "Body": "<p>This is definitely not a nasty hack, but be aware of the fact that you will have to do it (the explicit template specialization) for every class/type you want to use with the given template. In case of MANY types requesting template instantiation there can be A LOT of lines in your .cpp file. To remedy this problem you can have a TemplateClassInst.cpp in every project you use so that you have greater control what types will be instantiated. Obviously this solution will not be perfect (aka silver bullet) as you might end up breaking the ODR :).</p>\n", "LastActivityDate": "2011-11-06T21:44:49.250"}, "15561347": {"ParentId": "115703", "CommentCount": "4", "CreationDate": "2013-03-22T01:48:26.440", "OwnerUserId": "2158015", "PostTypeId": "2", "Id": "15561347", "Score": "-2", "Body": "<p>Time for an update! Create an inline (.inl, or probably any other) file and simply copy all your definitions in it. Be sure to add the template above each function (<code>template &lt;typename T, ...&gt;</code>). Now instead of including the header file in the inline file you do the opposite. Include the inline file <strong>after</strong> the declaration of your class (<code>#include \"file.inl\"</code>).</p>\n<p>I don't really know why no one has mentioned this. I see no immediate drawbacks.</p>\n", "LastActivityDate": "2013-03-22T01:48:26.440"}, "bq_ids": {"n4140": {"so_115703_115821_0": {"section_id": 254, "quality": 0.8260869565217391, "length": 19}}, "n3337": {"so_115703_115821_0": {"section_id": 245, "quality": 0.8260869565217391, "length": 19}}, "n4659": {"so_115703_115821_0": {"section_id": 261, "quality": 0.8260869565217391, "length": 19}}}, "115735": {"CommentCount": "2", "CreationDate": "2008-09-22T16:00:44.317", "LastEditorUserId": "510036", "LastActivityDate": "2016-10-22T01:12:42.037", "ParentId": "115703", "LastEditDate": "2016-10-22T01:12:42.037", "OwnerDisplayName": "Aaron N. Tubbs", "PostTypeId": "2", "Id": "115735", "Score": "143", "Body": "<p>The problem you describe can be solved by defining the template in the header, or via the approach you describe above.</p>\n<p>I recommend reading the following points from the <a href=\"https://isocpp.org/wiki/faq/templates\" rel=\"noreferrer\">C++ FAQ Lite</a>: </p>\n<ul>\n<li><a href=\"https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl\" rel=\"noreferrer\">Why can\u2019t I separate the definition of my templates class from its declaration and put it inside a .cpp file?</a></li>\n<li><a href=\"https://isocpp.org/wiki/faq/templates#separate-template-fn-defn-from-decl\" rel=\"noreferrer\">How can I avoid linker errors with my template functions?</a></li>\n<li><a href=\"https://isocpp.org/wiki/faq/templates#separate-template-fn-defn-from-decl-export-keyword\" rel=\"noreferrer\">How does the C++ keyword export help with template linker errors?</a></li>\n</ul>\n<p>They go into a lot of detail about these (and other) template issues.</p>\n", "OwnerUserId": "4810"}, "240246": {"ParentId": "115703", "CommentCount": "1", "CreationDate": "2008-10-27T15:13:07.860", "OwnerUserId": "31640", "PostTypeId": "2", "Id": "240246", "Score": "0", "Body": "<p>There is nothing wrong with the example you have given. But i must say i believe it's not efficient to store function definitions in a cpp file. I only understand the need to separate the function's declaration and definition.</p>\n<p>When used together with explicit class instantiation, the Boost Concept Check Library (BCCL) can help you generate template function code in cpp files.</p>\n", "LastActivityDate": "2008-10-27T15:13:07.860"}, "115743": {"CommentCount": "0", "CreationDate": "2008-09-22T16:01:49.930", "LastEditorUserId": "11834", "LastActivityDate": "2008-09-22T16:58:14.740", "ParentId": "115703", "PostTypeId": "2", "LastEditorDisplayName": "moonshadow", "LastEditDate": "2008-09-22T16:58:14.740", "Id": "115743", "Score": "9", "Body": "<p>This should work fine everywhere templates are supported. Explicit template instantiation is part of the C++ standard.</p>\n", "OwnerUserId": "11834", "OwnerDisplayName": "moonshadow"}, "115821": {"ParentId": "115703", "CommentCount": "7", "CreationDate": "2008-09-22T16:15:32.190", "OwnerUserId": "1968", "Id": "115821", "PostTypeId": "2", "OwnerDisplayName": "Konrad Rudolph", "Score": "11", "Body": "<p>This code is well-formed. You only have to pay attention that the definition of the template is visible at the point of instantiation. To quote the standard, \u00a7 14.7.2.4:</p>\n<blockquote>\n<p id=\"so_115703_115821_0\">The definition of a non-exported function template, a non-exported member function template, or a non-exported member function or static data member of a class template shall be present in every translation unit in which it is explicitly instantiated.</p>\n</blockquote>\n", "LastActivityDate": "2008-09-22T16:15:32.190"}, "115731": {"CommentCount": "1", "CreationDate": "2008-09-22T16:00:16.907", "LastEditorUserId": "3937", "LastActivityDate": "2008-09-22T18:47:40.390", "ParentId": "115703", "PostTypeId": "2", "LastEditorDisplayName": "Lou Franco", "LastEditDate": "2008-09-22T18:47:40.390", "Id": "115731", "Score": "2", "Body": "<p>Yes, that's the standard way to do <s>specializiation</s> explicit instantiation.  As you stated, you cannot instantiate this template with other types.</p>\n<p>Edit: corrected based on comment.</p>\n", "OwnerUserId": "3937", "OwnerDisplayName": "Lou Franco"}});