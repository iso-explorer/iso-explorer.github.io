post_cb({"23249124": {"CommentCount": "7", "ViewCount": "65", "CreationDate": "2014-04-23T15:37:52.947", "LastActivityDate": "2014-04-23T16:12:42.977", "Title": "How the temporary objects in c++ affect the efficiency?", "AcceptedAnswerId": "23249757", "PostTypeId": "1", "Id": "23249124", "Score": "1", "Body": "<p>I have read an article on CodeProject <a href=\"http://www.codeproject.com/Tips/103648/C-Tip-How-to-eliminate-Temporary-Objects\" rel=\"nofollow\">http://www.codeproject.com/Tips/103648/C-Tip-How-to-eliminate-Temporary-Objects</a>.</p>\n<pre><code>Complex y,z;\nComplex x=y+z; /* initialization instead of assignment */\n</code></pre>\n<p>I confused that why the second statment does not create a temporary object? how does the compiler works?</p>\n", "Tags": "<c++>", "OwnerUserId": "2769188", "AnswerCount": "2"}, "23249757": {"ParentId": "23249124", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><strong>In the first example in the link that you provide, the assignment operator is called:</strong></p>\n<pre><code>Complex x, y, z;\nx=y+z;\n</code></pre>\n<p><strong>In the second example in the link that you provide, the constructor is called:</strong></p>\n<pre><code>Complex y,z;\nComplex x=y+z;\n</code></pre>\n<p>But in both cases, a temporary object (containing the value of <code>x+y</code>) is created.</p>\n<p>So I seriously doubt the correctness of this link.</p>\n<p>I would be happy to read any answer to your question that explains otherwise...</p>\n<hr>\n<p>Temporary objects that we can avoid are usually the ones passed to a function or returned from a function by value instead of by reference.</p>\n<p>For example, in <code>Complex::operator+=</code> below, one temporary object is created on the stack when the function is called, and another temporary object is created on the stack when the function returns:</p>\n<pre><code>Complex Complex::operator+=(Complex num)\n{\n    this-&gt;real += num.real;\n    this-&gt;imag += num.imag;\n    return *this;\n}\n\nvoid func()\n{\n    Complex a(1,2);\n    Complex b(3,4);\n    a += b;\n    ...\n}\n</code></pre>\n<p>In order to eliminate both temporary objects, you can simply pass and return by reference:</p>\n<pre><code>Complex&amp; Complex::operator+=(Complex&amp; num)\n{\n    ...\n}\n</code></pre>\n<p>Please note that <strong>passing</strong> an argument by reference is feasible in member functions as well as in global functions, but <strong>returning</strong> an argument by reference is feasible only in member functions (unless you return a global variable from a global function, but that is rather pointless in most cases).</p>\n</hr>", "OwnerUserId": "1382251", "LastEditorUserId": "1382251", "LastEditDate": "2014-04-23T16:12:42.977", "Id": "23249757", "Score": "1", "CreationDate": "2014-04-23T16:06:02.870", "LastActivityDate": "2014-04-23T16:12:42.977"}, "bq_ids": {"n4140": {"so_23249124_23249559_0": {"section_id": 480, "quality": 0.9441624365482234, "length": 186}}, "n3337": {"so_23249124_23249559_0": {"section_id": 471, "quality": 0.9543147208121827, "length": 188}}, "n4659": {"so_23249124_23249559_0": {"section_id": 502, "quality": 0.8121827411167513, "length": 160}}}, "23249559": {"ParentId": "23249124", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There is a rule in C++, which allows the compiler to ellide temporaries, if they are directly used for initialising.<br>\nAnyway, using its leeway, the compiler could optimize the example without this rule anyway, which has the same effect.</br></p>\n<blockquote>\n<h2>12.8 Copying and moving class objects \u00a732</h2>\n<p id=\"so_23249124_23249559_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class\n  object, even if the copy/move constructor and/or destructor for the object have side effects. In such cases,\n  the implementation treats the source and target of the omitted copy/move operation as simply two different\n  ways of referring to the same object, and the destruction of that object occurs at the later of the times\n  when the two objects would have been destroyed without the optimization.123 This elision of copy/move\n  operations, called copy elision, is permitted in the following circumstances (which may be combined to\n  eliminate multiple copies):<br>\n  \u2014 in a return statement in a function with a class return type, when the expression is the name of a\n  non-volatile automatic object (other than a function or catch-clause parameter) with the same cvunqualified\n  type as the function return type, the copy/move operation can be omitted by constructing\n  the automatic object directly into the function\u2019s return value<br>\n  \u2014 in a throw-expression, when the operand is the name of a non-volatile automatic object (other than\n  a function or catch-clause parameter) whose scope does not extend beyond the end of the innermost\n  enclosing try-block (if there is one), the copy/move operation from the operand to the exception\n  object (15.1) can be omitted by constructing the automatic object directly into the exception object<br>\n  \u2014 when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\n  to a class object with the same cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the omitted copy/move<br>\n  \u2014 when the exception-declaration of an exception handler (Clause 15) declares an object of the same type\n  (except for cv-qualification) as the exception object (15.1), the copy/move operation can be omitted\n  by treating the exception-declaration as an alias for the exception object if the meaning of the program\n  will be unchanged except for the execution of constructors and destructors for the object declared by\n  the exception-declaration.</br></br></br></br></p>\n</blockquote>\n", "OwnerUserId": "3204551", "LastEditorUserId": "3204551", "LastEditDate": "2014-04-23T16:05:55.757", "Id": "23249559", "Score": "2", "CreationDate": "2014-04-23T15:57:36.140", "LastActivityDate": "2014-04-23T16:05:55.757"}});