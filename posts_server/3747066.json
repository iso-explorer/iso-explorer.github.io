post_cb({"3748987": {"ParentId": "3747066", "CommentCount": "0", "Body": "<p>According standard docs,</p>\n<p>Section <em>5.2.9 - 9</em>, for <strong>Static Cast</strong>,</p>\n<blockquote>\n<p id=\"so_3747066_3748987_0\">An rvalue of type \u201cpointer to cv1 B,\u201d where B is a class type, can be converted to an rvalue of type \u201cpointer to cv2\n  D,\u201d where D is a class derived (clause 10) from B, if a valid standard conversion from \u201cpointer to D\u201d to \u201cpointer to B\u201d\n  exists (4.10), cv2 is the same cv-qualification as, or greater cv-qualification than, cv1, and <strong>B is neither a virtual base class\n  of D nor a base class of a virtual base class of D.</strong></p>\n</blockquote>\n<p>Hence, it is not possible and you should use <code>dynamic_cast</code>...</p>\n", "OwnerUserId": "249490", "PostTypeId": "2", "Id": "3748987", "Score": "4", "CreationDate": "2010-09-20T06:01:29.103", "LastActivityDate": "2010-09-20T06:01:29.103"}, "3749251": {"ParentId": "3747066", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>In order to understand the cast system you need to dive in the object model.</p>\n<p>The classic representation of a simple hierarchy model is containment: that if <code>B</code> derives from <code>A</code> then the <code>B</code> object will in fact contain a <code>A</code> subobject alongside its own attributes.</p>\n<p>With this model, downcasting is a simple pointer manipulation, by an offset known at compilation time which depends from the memory layout of <code>B</code>.</p>\n<p>This is what <strong>static_cast</strong> do: a static cast is dubbed static because the computation of what is necessary for the cast is done at compile-time, be it pointer arithmetic or conversions (*).</p>\n<p>However, when <code>virtual</code> inheritance kicks in things tend to become a bit more difficult. The main issue is that with <code>virtual</code> inheritance all subclasses share a same instance of the subobject. In order to do that, <code>B</code> will have a pointer to a <code>A</code>, instead of a <code>A</code> proper, and the <code>A</code> base class object will be instantiated outside of <code>B</code>.</p>\n<p>Therefore, it's impossible at compilation time to be able to deduce the necessary pointer arithmetic: it depends on the runtime type of the object.</p>\n<p>Whenever there is a runtime type dependency, you need RTTI (RunTime Type Information), and making use of RTTI for casts is the job of <strong>dynamic_cast</strong>.</p>\n<p>In summary:</p>\n<ul>\n<li>compile-time downcast: <code>static_cast</code></li>\n<li>run-time downcast: <code>dynamic_cast</code></li>\n</ul>\n<p>The other two are also compile-time casts, but they are so specific that it's easy to remember what they are for... and they are smelly, so better not use them at all anyway.</p>\n<p>(*) <em>As noted by @curiousguy in the comments, this only holds for downcasting. A <code>static_cast</code> allows upcasting regardless of virtual or simple inheritance, though then the cast is also unnecessary.</em></p>\n", "OwnerUserId": "147192", "LastEditorUserId": "147192", "LastEditDate": "2015-12-26T13:58:27.943", "Id": "3749251", "Score": "77", "CreationDate": "2010-09-20T07:02:26.423", "LastActivityDate": "2015-12-26T13:58:27.943"}, "3747074": {"ParentId": "3747066", "CommentCount": "0", "Body": "<p>As far as I know, you need to use <code>dynamic_cast</code> because the inheritance is <code>virtual</code> and you're downcasting.</p>\n", "OwnerUserId": "246886", "PostTypeId": "2", "Id": "3747074", "Score": "11", "CreationDate": "2010-09-19T19:06:38.830", "LastActivityDate": "2010-09-19T19:06:38.830"}, "3751742": {"ParentId": "3747066", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_3747066_3751742_0\">$5.2.9/2- \"An expression e can be\n  explicitly converted to a type T using\n  a static_cast of the form\n  static_cast(e) if the declaration\n  \u201cT t(e);\u201d is well-formed, for some\n  invented temporary variable t (8.5).\"</p>\n</blockquote>\n<p>In your code you are attempting static_cast with 'T = B*' and 'e = A*'</p>\n<p>Now 'B* t(A*)' is not well-formed in C++ (but 'A* t(B*)' is because 'A' is a virtual unambiguous and accessible base of 'B'. Therefore the code gives error.</p>\n", "OwnerUserId": "418110", "PostTypeId": "2", "Id": "3751742", "Score": "1", "CreationDate": "2010-09-20T13:07:15.233", "LastActivityDate": "2010-09-20T13:07:15.233"}, "13418856": {"ParentId": "3747066", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I don't know if this is \"safe\" but.</p>\n<p>Assuming</p>\n<p>B derived from A (and A pure virtual)</p>\n<p>Since I KNOW that a pointer to B still remains a pointer to B.</p>\n<pre><code>    class A\n    {\n            virtual void doSomething(const void* p) const =0;\n    };\n\n    class B\n    {\n    public:\n            int value;\n            virtual void doSomething(const void*p)const\n            {\n            const B * other = reinterpret_cast&lt;const B*&gt;(p);\n            cout&lt;&lt;\"hello!\"&lt;&lt; other-&gt;value &lt;&lt;endl;\n            }\n    };\n\n    int main()\n    {\n            B  foo(1),bar(2);\n            A * p = &amp;foo, q=&amp;bar;\n            p-&gt;doSomething(q);\n            return 0;\n    }\n</code></pre>\n<p>this program executes and correctly return printing \"hello!\" and the value of the other object (in this case \"2\").</p>\n<p>by the way, what I'm doing is highly unsafe (personally I give a different ID to every class and I assert after reinterpret casting that current ID is equal to other ID to be sure we are doing something with 2 equal classes) and as you see I limited myself to \"const\" methods. Thus this will work with \"non-const\" methods, but if you do something wrong catching the bug will be almost unpossible. And even with assertion there's a 1 chance out of 4 billions to succeed assertion even when it is supposed to fail\n(assert(ID== other-&gt;ID);)</p>\n<p>By the way.. A good OO design should not require this kinda of stuff, but in my case I tried to refactor/re-design the code without being able to drop the usage of reinterpret casting. generally speaking you CAN avoid this kind of things.</p>\n", "OwnerUserId": "1829943", "LastEditorUserId": "1829943", "LastEditDate": "2012-11-17T06:43:03.597", "Id": "13418856", "Score": "1", "CreationDate": "2012-11-16T14:45:39.310", "LastActivityDate": "2012-11-17T06:43:03.597"}, "3747140": {"ParentId": "3747066", "CommentCount": "1", "Body": "<p>Yes, you have to use a dynamic_cast, but you'll have to make the base class A polymorphic, e.g. by adding a virtual dtor.</p>\n", "OwnerUserId": "452101", "PostTypeId": "2", "Id": "3747140", "Score": "4", "CreationDate": "2010-09-19T19:28:34.897", "LastActivityDate": "2010-09-19T19:28:34.897"}, "3747066": {"CommentCount": "0", "AcceptedAnswerId": "3749251", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2010-09-19T19:04:29.927", "LastActivityDate": "2015-12-26T13:58:27.943", "LastEditDate": "2015-12-26T03:32:41.817", "ViewCount": "21460", "FavoriteCount": "12", "Title": "C++ cannot convert from base A to derived type B via virtual base A", "Id": "3747066", "Score": "43", "Body": "<p>I have three classes:</p>\n<pre><code>class A {};\n\nclass B : virtual public A {};\nclass C : virtual public A {};\n\nclass D: public B, public C {};\n</code></pre>\n<p>Attempting a static cast from A* to B* I get the below error:</p>\n<pre><code>cannot convert from base A to derived type B via virtual base A\n</code></pre>\n", "Tags": "<c++><casting><downcasting><virtual-inheritance><static-cast>", "OwnerUserId": "376284", "AnswerCount": "7"}, "bq_ids": {"n4140": {"so_3747066_3748987_0": {"section_id": 6037, "quality": 0.8, "length": 32}, "so_3747066_3751742_0": {"section_id": 6030, "quality": 0.875, "length": 14}}, "n3337": {"so_3747066_3748987_0": {"section_id": 5805, "quality": 0.8, "length": 32}, "so_3747066_3751742_0": {"section_id": 5798, "quality": 0.875, "length": 14}}, "n4659": {"so_3747066_3748987_0": {"section_id": 7536, "quality": 0.625, "length": 25}, "so_3747066_3751742_0": {"section_id": 2, "quality": 0.625, "length": 10}}}, "3747117": {"ParentId": "3747066", "CommentCount": "4", "Body": "<p>You can't use <code>static_cast</code> in this situation because the compiler doesn't know the offset of B relative to A at compile time. The offset must be calculated at run-time based on the exact type of the most derived object. Therefore you must use <code>dynamic_cast</code>.</p>\n", "OwnerUserId": "277176", "PostTypeId": "2", "Id": "3747117", "Score": "6", "CreationDate": "2010-09-19T19:20:07.817", "LastActivityDate": "2010-09-19T19:20:07.817"}});