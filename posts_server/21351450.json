post_cb({"21351606": {"ParentId": "21351450", "CommentCount": "0", "Body": "<p>Lets do a quick test here:</p>\n<pre><code>template &lt;typename T&gt;\nstruct OutputType;\n\nint main()\n{\n    OutputType&lt;decltype(true)&gt; a;\n}\n</code></pre>\n<p>Atleast ideone outputs here that <code>true</code> is of type <code>bool</code>: <a href=\"http://ideone.com/Gm653T\" rel=\"nofollow\">http://ideone.com/Gm653T</a></p>\n<p>However: </p>\n<blockquote>\n<p id=\"so_21351450_21351606_0\">The type bool can be converted to int with the value false becoming \u200b0\u200b and true becoming 1.</p>\n</blockquote>\n<p>Source: <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast#Integral_promotion\" rel=\"nofollow\">cppreference</a></p>\n<p>And my guess is that exactly such a promotion happens here</p>\n", "OwnerUserId": "878307", "PostTypeId": "2", "Id": "21351606", "Score": "0", "CreationDate": "2014-01-25T14:12:26.270", "LastActivityDate": "2014-01-25T14:12:26.270"}, "21351589": {"ParentId": "21351450", "CommentCount": "2", "Body": "<p>Type bool is <em>not</em> #defined in C++.  I'm thinking that the comparison promotes to int and requires the int conversion.</p>\n", "OwnerUserId": "544057", "PostTypeId": "2", "Id": "21351589", "Score": "0", "CreationDate": "2014-01-25T14:11:19.443", "LastActivityDate": "2014-01-25T14:11:19.443"}, "bq_ids": {"n4140": {"so_21351450_21351616_2": {"section_id": 26, "quality": 1.0, "length": 14}, "so_21351450_21351606_0": {"section_id": 26, "quality": 0.8181818181818182, "length": 9}, "so_21351450_21351616_0": {"section_id": 686, "quality": 0.9166666666666666, "length": 11}, "so_21351450_21351616_1": {"section_id": 686, "quality": 1.0, "length": 7}}, "n3337": {"so_21351450_21351616_2": {"section_id": 23, "quality": 1.0, "length": 14}, "so_21351450_21351606_0": {"section_id": 23, "quality": 0.8181818181818182, "length": 9}, "so_21351450_21351616_0": {"section_id": 676, "quality": 0.9166666666666666, "length": 11}, "so_21351450_21351616_1": {"section_id": 676, "quality": 1.0, "length": 7}}, "n4659": {"so_21351450_21351616_0": {"section_id": 715, "quality": 0.9166666666666666, "length": 11}, "so_21351450_21351606_0": {"section_id": 26, "quality": 0.8181818181818182, "length": 9}, "so_21351450_21351616_2": {"section_id": 26, "quality": 1.0, "length": 14}, "so_21351450_21351616_1": {"section_id": 715, "quality": 1.0, "length": 7}}}, "21351450": {"CommentCount": "2", "CreationDate": "2014-01-25T13:58:29.973", "PostTypeId": "1", "AcceptedAnswerId": "21351616", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-25T15:19:40.763", "LastEditDate": "2017-05-23T12:21:00.397", "ViewCount": "736", "FavoriteCount": "1", "Title": "Implicit conversion to boolean and comparison with boolean literals", "Id": "21351450", "Score": "4", "Body": "<p>I was answering <a href=\"https://stackoverflow.com/questions/21350924/explicit-bool-operator-cannot-return-test-initialize-bool/\">this question</a>, about the topic of user defined conversions to <code>bool</code> and how to disable other conversions:</p>\n<pre><code>struct foo\n{\n    operator bool() const //Explicit overload for bool\n    {\n       return true; \n    }\n\n  template&lt;typename T&gt;\n  operator T() const = delete; //Everithing which is not a bool (Everithing which  \n                               //does not fit in the explicit overload) would  \n                               //resolve to this operator and will fail.\n};\n\n\nint main()\n{\n    foo f;\n\n    bool b = f; //OK\n    int i = f;  //ERROR\n    char c = f; //ERROR\n    etc...\n}\n</code></pre>\n<p>Later the OP asked me why conditionals like <code>if( f == true )</code> failed (Where <code>f</code> is a <code>foo</code>. I have tried that by myself and that surprises me because that comparison with boolean literals leads to a conversion to <code>int</code> (Which is disabled) instead of <code>bool</code>:</p>\n<pre><code>int main()\n{\n    foo f;\n\n    if( f ); //OK, converts to bool\n    if( f == true ); //ERROR: Conversion to int, which has been disabled\n}  \n</code></pre>\n<blockquote>\n<p id=\"so_21351450_21351450_0\">prog.cpp:20:12: error: use of deleted function \u2018foo::operator T()\n  const [with T = int]\u2019    if( f == true);<br>\n  ..............................................................................................................................................^</br></p>\n</blockquote>\n<p>My question is: <strong>Are boolean literals defined as integers (Like the common C macros <code>#define true 1 #define false 0</code>), and if not, why that comparison lead to an int conversion instead of a <code>bool</code>?</strong></p>\n<p>I'm using GCC4.8.1 with C++11 enabled ( <code>-std=C++11</code> ).</p>\n<p><a href=\"http://ideone.com/8Ch5Jg\" rel=\"nofollow noreferrer\">Here</a> is an example of that behavior at ideone.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1609356", "AnswerCount": "3"}, "21351616": {"ParentId": "21351450", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Since <code>foo</code> is a class type, special rules apply when using an operator that is not specifically defined for that class type, see [over.built]/12</p>\n<blockquote>\n<p id=\"so_21351450_21351616_0\">For every pair of promoted arithmetic types <code>L</code> and <code>R</code>, there exist candidate operator functions of the form</p>\n<pre><code>LR operator*(L, R);\nLR operator/(L, R);\nLR operator+(L, R);\nLR operator-(L, R);\nbool operator&lt;(L, R);\nbool operator&gt;(L, R);\nbool operator&lt;=(L, R);\nbool operator&gt;=(L, R);\nbool operator==(L, R);\nbool operator!=(L, R);\n</code></pre>\n<p id=\"so_21351450_21351616_1\">where <code>LR</code> is the result of the usual arithmetic conversions between types <code>L</code> and <code>R</code>.</p>\n</blockquote>\n<p>Not the usage of the term <em>promoted arithmetic types</em>: This requires a promotion of <code>bool</code>.</p>\n<p>A <code>bool</code> is promoted to an <code>int</code>, see [conv.prom]/6 (integral promotions)</p>\n<blockquote>\n<p id=\"so_21351450_21351616_2\">A prvalue of type bool can be converted to a prvalue of type <code>int</code>, with <code>false</code> becoming zero and <code>true</code> becoming one.</p>\n</blockquote>\n<hr>\n<p>So there are candidate functions of the form</p>\n<pre><code>common_type&lt;L,int&gt; operator==(L, int);\n</code></pre>\n<p>where <code>L</code> is a promoted arithmetic type. However, there are many of them, for example</p>\n<pre><code>common_type&lt;int      , int&gt; operator==(int      , int);\ncommon_type&lt;long     , int&gt; operator==(long     , int);\ncommon_type&lt;long long, int&gt; operator==(long long, int);\n</code></pre>\n<p>Each of which require a user-defined conversion from <code>foo</code> to the promoted type. It is not clear to me why this isn't ambiguous, as <code>foo</code> can be converted to any of them. This is also described in the open issue <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_active.html#954\" rel=\"nofollow\">CWG 954</a>.</p>\n<p>If there are several non-template conversion functions, <a href=\"http://coliru.stacked-crooked.com/a/1ad9c0e69672e0e2\" rel=\"nofollow\">g++4.8.1</a> and <a href=\"http://coliru.stacked-crooked.com/a/ee9c8cc61740f67b\" rel=\"nofollow\">clang++3.5</a> report this ambiguity. (It should be noted that clang might have a bug here, see <a href=\"http://coliru.stacked-crooked.com/a/a336b5d38575b49e\" rel=\"nofollow\">this example</a> which works fine with g++4.8.1.)</p>\n<hr>\n<p>However, there is no candidate of the form</p>\n<pre><code>common_type&lt;bool, int&gt; operator==(bool, int);\n</code></pre>\n<p>as <code>bool</code> is <em>not</em> a promoted arithmetic type. Therefore, the conversion from <code>foo</code> to <code>bool</code> will <em>not</em> be chosen for the expression</p>\n<pre><code>foo x;\nx == true\n</code></pre>\n</hr></hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2014-01-25T15:19:40.763", "Id": "21351616", "Score": "2", "CreationDate": "2014-01-25T14:13:16.103", "LastActivityDate": "2014-01-25T15:19:40.763"}});