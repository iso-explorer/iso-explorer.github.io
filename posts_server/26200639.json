post_cb({"26200639": {"CommentCount": "6", "ViewCount": "94", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "CreationDate": "2014-10-05T07:38:53.570", "LastActivityDate": "2014-10-05T08:50:56.350", "LastEditDate": "2014-10-05T07:51:13.380", "AcceptedAnswerId": "26201073", "LastEditorDisplayName": "user2953119", "Title": "Can two objects of different types with different alingment requirements have the same object representation?", "Id": "26200639", "Score": "1", "Body": "<p>The following definition of the object representation is given (3.9/4):</p>\n<blockquote>\n<p id=\"so_26200639_26200639_0\">The <em>object representation</em> of an object of type T <em>is</em> the sequence of N\n  unsigned char objects taken up by the object of type T, where N equals\n  sizeof(T).</p>\n</blockquote>\n<p>But 3.9.1/1 says:</p>\n<blockquote>\n<p id=\"so_26200639_26200639_1\">A <code>char</code>, a <code>signed char</code>, and an <code>unsigned char</code> occupy the same amount of\n  storage and have <em>the same alignment requirements</em> (3.11); that is, they\n  have the same object representation.</p>\n</blockquote>\n<p>It looks like the object representation depends on alignment requirements. But it isn't mentioned in the definition that I cited. That's two object of the same size may have different object representation, do they?</p>\n<p>Essentially, I'm asking about the following:\nSuppose we have two objects with the same size such that the alignment of one of that objects differs from another. For instance:</p>\n<pre><code>struct A\n{\n    char a;\n    char b;\n    char c;\n    char d;\n};\n\nA a; //Object 1. alignof(a) = 1\nint b; //Object 2. alignof(b) = 4\n</code></pre>\n<p>Do these objects have the same object representation? </p>\n", "Tags": "<c++><language-lawyer><memory-alignment>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_26200639_26201073_0": {"section_id": 6076, "quality": 0.625, "length": 5}, "so_26200639_26200639_0": {"section_id": 7202, "quality": 0.8666666666666667, "length": 13}, "so_26200639_26201073_1": {"section_id": 7202, "quality": 0.7, "length": 7}, "so_26200639_26201073_2": {"section_id": 7240, "quality": 0.8214285714285714, "length": 23}, "so_26200639_26200639_1": {"section_id": 7210, "quality": 0.9473684210526315, "length": 18}, "so_26200639_26201073_3": {"section_id": 7248, "quality": 1.0, "length": 22}}, "n3337": {"so_26200639_26200639_0": {"section_id": 6946, "quality": 0.8666666666666667, "length": 13}, "so_26200639_26201073_0": {"section_id": 5844, "quality": 0.625, "length": 5}, "so_26200639_26201073_1": {"section_id": 6946, "quality": 0.7, "length": 7}, "so_26200639_26201073_2": {"section_id": 6984, "quality": 0.8214285714285714, "length": 23}, "so_26200639_26200639_1": {"section_id": 6954, "quality": 0.9473684210526315, "length": 18}, "so_26200639_26201073_3": {"section_id": 6992, "quality": 1.0, "length": 22}}, "n4659": {"so_26200639_26201073_2": {"section_id": 8749, "quality": 0.7857142857142857, "length": 22}, "so_26200639_26200639_0": {"section_id": 8711, "quality": 0.8666666666666667, "length": 13}, "so_26200639_26201073_0": {"section_id": 6108, "quality": 0.625, "length": 5}, "so_26200639_26200639_1": {"section_id": 8719, "quality": 0.9473684210526315, "length": 18}, "so_26200639_26201073_1": {"section_id": 8711, "quality": 0.7, "length": 7}}}, "26200784": {"ParentId": "26200639", "CommentCount": "2", "Body": "<p>In the case of single byte chars, the alignment is irrelevant (one byte boundaries) so the examples cited hold true. However, in more advanced circumstances this is not the case.</p>\n<p>As a general rule of thumb, n-byte objects need to be stored on n-byte boundaries. At the processor level, attempting an operation on an incorrectly aligned object results in an exception.</p>\n<p>So (without optimization):</p>\n<pre><code>PTR64     *a;\nINT32      b;\nINT16      c;\nBYTE       d;\n</code></pre>\n<p>would be 8+4+2+1 = 15 bytes.\nHowever:</p>\n<pre><code>BYTE       a;\nINT16      b;  // preceded with (1) bytes to 16 bit boundary\nINT32      c;  // Preceded with (2) bytes to 32 bit boundary\nPTR64     *d;  // preceded with (4) bytes to 64 bit boundary\n</code></pre>\n<p>would b 1+(1)+2+(2)+4+(4)+8 = 21 bytes.</p>\n", "OwnerUserId": "2503164", "PostTypeId": "2", "Id": "26200784", "Score": "0", "CreationDate": "2014-10-05T08:04:37.130", "LastActivityDate": "2014-10-05T08:04:37.130"}, "26200941": {"ParentId": "26200639", "CommentCount": "0", "Body": "<p>Yes of course.<br>\nThink of <strong>int</strong> and <strong>char[4]</strong> exact same size, different object representation.</br></p>\n<p>You also have <strong><a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow\">reinterper_cast</a></strong> and <strong><a href=\"http://en.cppreference.com/w/cpp/language/union\" rel=\"nofollow\">union</a></strong> in the language. These help you look at the same bytes as different object types. </p>\n<p>So, working with your example, you could have a union of int, and your struct on the same actual bytes:</p>\n<pre><code>struct A\n{\n    char a;\n    char b;\n    char c;\n    char d;\n};\n\nunion MyUnion\n{\n   A a;\n   int b;\n}\n</code></pre>\n", "OwnerUserId": "536086", "PostTypeId": "2", "Id": "26200941", "Score": "0", "CreationDate": "2014-10-05T08:28:21.803", "LastActivityDate": "2014-10-05T08:28:21.803"}, "26201073": {"ParentId": "26200639", "CommentCount": "1", "Body": "<p>There's some confusion regarding how alignment works.</p>\n<p>You're right that the object representation depends on alignment requirements:</p>\n<blockquote>\n<p id=\"so_26200639_26201073_0\">object representation is the sequence of sizeof(T) objects of type unsigned char</p>\n</blockquote>\n<p>while</p>\n<blockquote>\n<p id=\"so_26200639_26201073_1\">The value representation of an object is the set of bits that hold the value of its type T</p>\n</blockquote>\n<p>If you take for instance the following type:</p>\n<pre><code>struct S {\n    char c;  // 1 byte value\n             // 3 bytes padding\n    float f; // 4 bytes value\n    bool operator==(const S&amp; arg) const { // value-based equality\n        return c == arg.c &amp;&amp; f == arg.f;\n    }\n};\nassert(sizeof(S) == 8); // object representation\n</code></pre>\n<p>the object representation size accounts for 8 bytes but the value representation size accounts only for 5 bytes which determine the object's value with respect to another one. There are alignment requirements which cause the difference and they introduce some padding.</p>\n<p>In your example the types have the same size for the object representation and value representation, plus object representation size is equal to the value representation size.</p>\n<pre><code>struct A\n{\n    char a;\n    char b;\n    char c;\n    char d;\n};\n\nA a; //Object 1. Object representation size = 4, value representation size = 4, alignof(a) = 1\nint b; //Object 2. Object representation size = 4, value representation size = 4, alignof(b) = 4\n</code></pre>\n<p>What is different here is the alignment required <strong>to store and access the objects</strong>.</p>\n<p>On some processors accessing a 4-bytes integer on a non-4-bytes-aligned address yields a fatal error. The <code>alignof</code> keyword used in your snippet says exactly this: <strong>you need to allocate an object of type A on a 1-byte-aligned address (i.e. anywhere) since you're going to access subobjects of single bytes as a maximum single read and they're safe to be accessed anywhere, anyway you need to allocate an integer on a 4-bytes aligned address in order to be safe for me to access it</strong>.</p>\n<p>\u00a73.11/p1</p>\n<blockquote>\n<p id=\"so_26200639_26201073_2\">Object types have alignment requirements (3.9.1, 3.9.2) which place\n  restrictions on the addresses at which an object of that type may be\n  allocated. An alignment is an implementation-defined integer value\n  representing the number of bytes between successive addresses at which\n  a given object can be allocated</p>\n</blockquote>\n<p>That means: you should allocate an integer on a 4-bytes-aligned address, but the bytes necessary from the start of your buffer to the beginning of your object <strong>won't be part of your object</strong>:</p>\n<pre><code>|0x07|0x08|0x09|0x0A|0x0B|..\n     &gt; I can allocate an integer here, on a 4-bytes-aligned address\n&gt; Here the buffer starts\n      |------------------|\n        object rep size == value rep size\n</code></pre>\n<p>notice that what would happen if the alignment requirements aren't honored is system-dependent, i.e. on x86 you get a performance slowdown, with SSE you likely will get a crash, on GPU memory spaces you won't be able to recover your program. The standard only specifies what should happen in regard to alignment allocations requests:</p>\n<blockquote>\n<p id=\"so_26200639_26201073_3\">If a request for a specific extended alignment in a specific context\n  is not supported by an implementation, the program is ill-formed.\n  Additionally, a request for runtime allocation of dynamic storage for\n  which the requested alignment cannot be honored shall be treated as an\n  allocation failure.</p>\n</blockquote>\n", "OwnerUserId": "1938163", "PostTypeId": "2", "Id": "26201073", "Score": "1", "CreationDate": "2014-10-05T08:50:56.350", "LastActivityDate": "2014-10-05T08:50:56.350"}});