post_cb({"bq_ids": {"n4140": {"so_45775764_45776027_1": {"length": 29, "quality": 1.0, "section_id": 21}, "so_45775764_45776027_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 45}, "so_45775764_45776027_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 45}}, "n3337": {"so_45775764_45776027_1": {"length": 29, "quality": 1.0, "section_id": 18}, "so_45775764_45776027_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 42}, "so_45775764_45776027_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 42}}, "n4659": {"so_45775764_45776027_1": {"length": 29, "quality": 1.0, "section_id": 21}, "so_45775764_45776027_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 46}, "so_45775764_45776027_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 46}}}, "45775764": {"ViewCount": "111", "Body": "<p>Consider this program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid f(unsigned char c) {\n  cout &lt;&lt; c &lt;&lt; endl;\n}\n\nvoid f(int c) {\n  cout &lt;&lt; c &lt;&lt; endl;\n}\n\nint main() {\n  f('a');\n}\n</code></pre>\n<p>This prints out <code>97</code>, suggesting that the <code>f()</code> overload that was selected was the one taking an <code>int</code>. I find this weird; wouldn't intuitively an <code>unsigned char</code> be a better match for a <code>char</code>?</p>\n", "AcceptedAnswerId": "45776027", "Title": "Why is the function overload that takes an int preferred over the one taking an unsigned char?", "CreationDate": "2017-08-19T19:55:00.797", "Id": "45775764", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2017-08-19T20:32:14.763", "Score": "5", "OwnerUserId": "1428", "Tags": "<c++><overloading>", "AnswerCount": "1"}, "45776027": {"Id": "45776027", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_45775764_45776027_0\">wouldn't intuitively an <code>unsigned char</code> be a better match for a <code>char</code>?</p>\n</blockquote>\n<p>Well, I guess, but not according to the Standard. According to <a href=\"http://eel.is/c++draft/conv#prom-1\" rel=\"noreferrer\"><code>[conv.prom]p1</code></a>:</p>\n<blockquote>\n<p id=\"so_45775764_45776027_1\">A prvalue of an integer type other than <code>bool</code>, <code>char16_\u00adt</code>, <code>char32_\u00adt</code>, or <code>wchar_\u00adt</code> whose integer conversion rank is less than the rank of int can be converted to a prvalue of type <code>int</code> if <code>int</code> can represent all the values of the source type; [...]</p>\n</blockquote>\n<p>Now, the three character types have the same rank, and a signed type has a rank always less than <code>int</code>. This is a combination of <a href=\"http://eel.is/c++draft/conv.rank#1.6\" rel=\"noreferrer\"><code>[conv.rank]p1.6</code></a> and <a href=\"http://eel.is/c++draft/conv.rank#1.2\" rel=\"noreferrer\"><code>[conv.rank]p1.2</code></a>:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_45775764_45776027_2\">The rank of a signed integer type shall be greater than the rank of any signed integer type with a smaller size.</p></li>\n<li><p id=\"so_45775764_45776027_3\">[...]</p></li>\n<li><p id=\"so_45775764_45776027_4\">The rank of <code>char</code> shall equal the rank of <code>signed char</code> and <code>unsigned char</code>.</p></li>\n</ul>\n</blockquote>\n<p>Basically, every character has always a smaller rank than <code>int</code> and they  can all be represented in an <code>int</code>, and so the overload with <code>unsigned char</code> is not a better match, because it would involve a conversion from <code>char</code> to <code>unsigned char</code>, instead of a promotion.</p>\n<p>If you change your overload to take a <code>char</code>, then there would be an exact match, and so naturally, the \"correct\" overload (in your eyes) would be chosen.</p>\n", "LastActivityDate": "2017-08-19T20:32:14.763", "CommentCount": "1", "CreationDate": "2017-08-19T20:32:14.763", "ParentId": "45775764", "Score": "8", "OwnerUserId": "3980929"}});