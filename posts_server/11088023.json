post_cb({"11088507": {"Id": "11088507", "PostTypeId": "2", "Body": "<p>Yes. See [class.copy] p32</p>\n<blockquote>\n<p id=\"so_11088023_11088507_0\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. If overload resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to\n  the object\u2019s type (possibly cv-qualified), overload resolution is performed again,  considering the object as an lvalue. [ <em>Note:</em> This two-stage overload resolution must be performed regardless of whether copy elision will occur. It determines the constructor to be called if elision is not performed, and the selected constructor must be accessible even if the call is elided. \u2014 <em>end note</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2012-06-18T18:06:16.957", "CommentCount": "1", "CreationDate": "2012-06-18T18:06:16.957", "ParentId": "11088023", "Score": "4", "OwnerUserId": "981959"}, "bq_ids": {"n4140": {"so_11088023_11088507_0": {"length": 64, "quality": 0.8311688311688312, "section_id": 481}, "so_11088023_11088307_0": {"length": 41, "quality": 0.82, "section_id": 481}}, "n3337": {"so_11088023_11088507_0": {"length": 73, "quality": 0.948051948051948, "section_id": 472}, "so_11088023_11088307_0": {"length": 50, "quality": 1.0, "section_id": 472}}, "n4659": {"so_11088023_11088507_0": {"length": 60, "quality": 0.7792207792207793, "section_id": 504}, "so_11088023_11088307_0": {"length": 37, "quality": 0.74, "section_id": 504}}}, "11088239": {"Id": "11088239", "PostTypeId": "2", "Body": "<p>In this case, since the return value has a name (<code>f</code>), it would be NRVO (named return value optimization) that would apply.</p>\n<p>So, the technical answer based only on wording, is that the absence of RVO won't prevent copy elision, since NRVO could still allow it.</p>\n<p>Past that, I believe the selection between move/copy of the return value can/will depend on the definition of Foo -- there are definitely times it'll be copied instead of moved, such as if you've explicitly deleted the move constructor and move assignment operators, or you haven't defined move construction/assignment, and it isn't eligible for them being synthesized implicitly.</p>\n<p>Edit: [responding to edited question]: Having a move constructor still doesn't guarantee that the result will be moved. One obvious example would be if you had deleted the move assignment operator, and were assigning the result (rather than using it to initialize). In this case, the deleted move assignment operator would prevent moving the return value.</p>\n<p>To answer what you may have been getting at, though, the general rule is that moving will be done if possible, and it'll fall back to copying if and only if something prevents the result from being moved.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2012-06-18T17:53:22.830", "Score": "2", "CreationDate": "2012-06-18T17:47:25.127", "ParentId": "11088023", "CommentCount": "2", "OwnerUserId": "179910", "LastEditDate": "2012-06-18T17:53:22.830"}, "11088023": {"ViewCount": "213", "Body": "<p>I know that when passing an object by value to a function, the move constructor is always called if there is one, assuming no copy elision. What about returning an object by value?</p>\n<p>For example, say we have a class <code>Foo</code> which has a move constructor, and we have a function that returns a <code>Foo</code> object.</p>\n<pre><code>Foo g() {\n    Foo f;\n\n    // do something with f\n\n    return f;\n}\n</code></pre>\n<p>If we assume there is no RVO, is the move constructor guaranteed to be called?</p>\n<p>Update: I guess I didn't show my intention clearly. I just want to know I can in the worst case have the object moved not copied. Either RVO or NRVO happens, I am happy. And I should also say that move constructor and move assignment are not deleted and are properly implemented.</p>\n", "AcceptedAnswerId": "11088507", "Title": "Is an object guaranteed to be moved when it is returned?", "CreationDate": "2012-06-18T17:32:32.823", "Id": "11088023", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-06-18T18:04:37.173", "LastEditorUserId": "987077", "LastActivityDate": "2012-06-18T18:08:13.163", "Score": "7", "OwnerUserId": "987077", "Tags": "<c++><c++11><return-value><move-semantics>", "AnswerCount": "3"}, "11088307": {"Id": "11088307", "PostTypeId": "2", "Body": "<p>The rule is that whenever copy elision is allowed but does not occur, the move constructor will be used if it is available, and otherwise the copy constructor will be used.</p>\n<p>The exact behaviour is defined by <code>[class.copy]/32</code>:</p>\n<blockquote>\n<p id=\"so_11088023_11088307_0\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. If overload resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue.</p>\n</blockquote>\n", "LastEditorUserId": "485561", "LastActivityDate": "2012-06-18T18:08:13.163", "Score": "1", "CreationDate": "2012-06-18T17:52:18.970", "ParentId": "11088023", "CommentCount": "0", "OwnerUserId": "485561", "LastEditDate": "2012-06-18T18:08:13.163"}});