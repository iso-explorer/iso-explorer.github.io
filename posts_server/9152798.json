post_cb({"9152883": {"Id": "9152883", "PostTypeId": "2", "Body": "<p>To back up @Seth, here's the relevant paragraph from the standard:</p>\n<p><code>\u00a712.8 [class.copy] p32</code></p>\n<blockquote>\n<p id=\"so_9152798_9152883_0\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, <strong>and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue</strong>. If overload resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue. [ <em>Note:</em> This two-stage overload resolution must be performed regardless of whether copy elision will occur. It determines the constructor to be called if elision is not performed, and the selected constructor must be accessible even if the call is elided. <em>\u2014end note</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2012-02-05T20:49:23.987", "CommentCount": "4", "CreationDate": "2012-02-05T20:49:23.987", "ParentId": "9152798", "Score": "8", "OwnerUserId": "500104"}, "bq_ids": {"n4140": {"so_9152798_9152814_0": {"length": 33, "quality": 0.868421052631579, "section_id": 7230}, "so_9152798_9152883_0": {"length": 64, "quality": 0.8311688311688312, "section_id": 481}, "so_9152798_9152814_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 5940}}, "n3337": {"so_9152798_9152814_0": {"length": 33, "quality": 0.868421052631579, "section_id": 6974}, "so_9152798_9152883_0": {"length": 73, "quality": 0.948051948051948, "section_id": 472}, "so_9152798_9152814_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 5711}}, "n4659": {"so_9152798_9152883_0": {"length": 60, "quality": 0.7792207792207793, "section_id": 504}, "so_9152798_9152814_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 7424}}}, "9152875": {"Id": "9152875", "PostTypeId": "2", "Body": "<p>The \"disambiguation\" is just your old friend, overload resolution:</p>\n<pre><code>Foo y;\n\nFoo x(y);            // copy\nFoo x(std::move(y)); // move\n</code></pre>\n<p>The expression <code>y</code> in the first example is an lvalue of type <code>Foo</code>, which binds to <code>Foo const &amp;</code> (and also <code>Foo &amp;</code> if you have such a constructor); the type of the expression <code>std::move(y)</code> in the second example is <code>Foo &amp;&amp;</code>, so it'll bind to <code>Foo &amp;&amp;</code> (and also <code>Foo const &amp;</code> absent the former).</p>\n<p>In your example, the result of <code>MoveAFoo()</code> is a temporary of type <code>Foo</code>, so it'll bind to the <code>Foo &amp;&amp;</code>-constructor if one is available, and to a const-copy constructor otherwise.</p>\n<p>Finally, in a function returning <code>Foo</code> (by value), the statement <code>return x;</code> is equivalent to <code>return std::move(x);</code> if <code>x</code> is a local variable of type <code>Foo</code> -- this is a special new rule to make the use of move semantics easier.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2012-02-05T21:02:41.480", "Score": "2", "CreationDate": "2012-02-05T20:49:02.173", "ParentId": "9152798", "CommentCount": "3", "OwnerUserId": "596781", "LastEditDate": "2012-02-05T21:02:41.480"}, "9152876": {"Id": "9152876", "PostTypeId": "2", "Body": "<pre><code>Foo MoveAFoo() {\n  Foo f;\n  return f;\n}\n</code></pre>\n<p>This is definition of function <code>MoveAFoo</code> that returns object of type <code>Foo</code>. In its body local <code>Foo f;</code> is created and destructed when it goes out of its scope.</p>\n<p>In this code:</p>\n<pre><code>Foo x = MoveAFoo();\n</code></pre>\n<p>object <code>Foo f;</code> is created inside of <code>MoveAFoo</code> function and directly assigned into <code>x</code>, which means that copy constructor is not called.</p>\n<p>But in this code:</p>\n<pre><code>Foo x;\nx = MoveAFoo();\n</code></pre>\n<p>object <code>Foo f;</code> is created inside of <code>MoveAFoo</code> function, then the copy of <code>f</code> is created and stored into <code>x</code> and original <code>f</code> is destructed.</p>\n", "LastActivityDate": "2012-02-05T20:49:05.440", "CommentCount": "1", "CreationDate": "2012-02-05T20:49:05.440", "ParentId": "9152798", "Score": "2", "OwnerUserId": "1168156"}, "9152814": {"Id": "9152814", "PostTypeId": "2", "Body": "<p>Usually it will be neither due to <a href=\"http://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"noreferrer\">RVO</a>.</p>\n<p>If that optimisation can't be performed, then it will be a move, because the object being returned is going out of scope (and will be destroyed just after). If it can't be moved, then it will be copied. If it can't be copied, it won't compile.</p>\n<p>The whole point of move constructors is that when a copy is going to be made of an object that is just about to be destroyed, it is often unnecessary to make a whole copy, and the resources can be <em>moved</em> from the dying object to the object being created instead.</p>\n<p>You can tell when either the copy or move constructor is going to be called based on what is about to happen to the object being moved/copied. Is it about to go out of scope and be destructed? If so, the move constructor will be called. If not, the copy constructor.</p>\n<p>Naturally, this means you may have both a move constructor and copy constructor in the same class. You can also have a copy assignment operator and a <em>move assignment operator</em> as well.</p>\n<p><strong>Update:</strong> It may be unclear as to exactly when the move constructor/assignment operator is called versus the plain copy constructor/assignment operator. If I understand correctly, the move constructor is called if an object is initialised with an xvalue (eXpiring value). \u00a73.10.1 of the standard says </p>\n<blockquote>\n<p id=\"so_9152798_9152814_0\">An xvalue (an \u201ceXpiring\u201d value) also refers to an object, usually near\n  the end of its lifetime (so that its resources may be moved, for\n  example). An xvalue is the result of certain kinds of expressions\n  involving rvalue references (8.3.2). [ Example: The result of calling\n  a function whose return type is an rvalue reference is an xvalue. \u2014end\n  example ]</p>\n</blockquote>\n<p>And the beginning of \u00a75 of the standard says:</p>\n<blockquote>\n<p id=\"so_9152798_9152814_1\">[ Note: An expression is an xvalue if it is:</p>\n<ul>\n<li>the result of calling a\n  function, whether implicitly or explicitly, whose return type is an\n  rvalue reference to object type,</li>\n<li>a cast to an rvalue reference to\n  object type, </li>\n<li>a class member access expression designating a\n  non-static data member of non-reference type in which the object\n  expression is an xvalue, or</li>\n<li>a .* pointer-to-member expression in\n  which the first operand is an xvalue and the second operand is a\n  pointer to data member.</li>\n</ul>\n<p id=\"so_9152798_9152814_2\">In general, the effect of this rule is that\n  named rvalue references are treated as lvalues and unnamed rvalue\n  references to objects are treated as xvalues; rvalue references to\n  functions are treated as lvalues whether named or not. \u2014end note ]</p>\n</blockquote>\n<hr/>\n<p>As an example, if NRVO can be done, it's like this:</p>\n<pre><code>void MoveAFoo(Foo* f) {\n    new (f) Foo;\n}\n\nFoo myfoo; // pretend this isn't default constructed\nMoveAFoo(&amp;myfoo);\n</code></pre>\n<p>If NRVO can't be done but <code>Foo</code> is moveable, then your example is a little like this:</p>\n<pre><code>void MoveAFoo(Foo* fparam) {\n    Foo f;\n\n    new (fparam) Foo(std::move(f));\n}\n\nFoo f; // pretend this isn't being default constructed\nMoveAFoo(&amp;f);\n</code></pre>\n<p>And if it can't be moved but it can be copied, then it's like this</p>\n<pre><code>void MoveAFoo(Foo* fparam) {\n    Foo f;\n\n    new (fparam) Foo((Foo&amp;)f);\n}\n\nFoo f; // pretend this isn't default constructed\nMoveAFoo(&amp;f);\n</code></pre>\n", "LastEditorUserId": "238030", "LastActivityDate": "2014-11-03T23:01:44.730", "Score": "27", "CreationDate": "2012-02-05T20:39:38.073", "ParentId": "9152798", "CommentCount": "7", "OwnerUserId": "726361", "LastEditDate": "2014-11-03T23:01:44.730"}, "9152798": {"ViewCount": "8659", "Body": "<p>In C++11 we can define copy and move constructors, but are both allowed on the same class? If so, how do you disambiguate their usage? For example:</p>\n<pre><code>Foo MoveAFoo() {\n  Foo f;\n  return f;\n}\n</code></pre>\n<p>Is the above a copy? A move? How do I know?</p>\n", "AcceptedAnswerId": "9152814", "Title": "C++11: Move/Copy construction ambiguity?", "CreationDate": "2012-02-05T20:37:34.270", "Id": "9152798", "CommentCount": "2", "FavoriteCount": "7", "PostTypeId": "1", "LastActivityDate": "2014-12-08T17:03:07.083", "Score": "20", "OwnerUserId": "157971", "Tags": "<c++><c++11>", "AnswerCount": "4"}});