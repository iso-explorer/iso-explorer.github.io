post_cb({"bq_ids": {"n4140": {"so_43694112_43694276_0": {"length": 11, "quality": 0.5789473684210527, "section_id": 3298}, "so_43694112_43694276_2": {"length": 7, "quality": 0.875, "section_id": 3299}}, "n3337": {"so_43694112_43694276_0": {"length": 11, "quality": 0.5789473684210527, "section_id": 3168}, "so_43694112_43694276_2": {"length": 7, "quality": 0.875, "section_id": 3169}}, "n4659": {"so_43694112_43694276_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 4063}, "so_43694112_43694276_2": {"length": 8, "quality": 1.0, "section_id": 4065}, "so_43694112_43694276_1": {"length": 24, "quality": 0.96, "section_id": 4064}}}, "43694112": {"ViewCount": "168", "Body": "<p>Let's say that I want to disable the construction of class, then I can do the following (as per <a href=\"https://stackoverflow.com/questions/14137853/best-style-for-deleting-all-constructors-or-other-function\">Best style for deleting all constructors (or other function)?\n</a>):</p>\n<pre><code>// This results in Example being CopyConstructible:\nstruct Example {\n  Example() = delete;\n};\n</code></pre>\n<p>or</p>\n<pre><code>struct Example {\n  template &lt;typename... Ts&gt;\n  Example(Ts&amp;&amp;...) = delete;\n};\n</code></pre>\n<p>or</p>\n<pre><code>struct Example {\n  Example(const Example&amp;) = delete;\n};\n</code></pre>\n<p>where the first example can still be copied if constructed (which the intention is to disable), but the second two will disable <strong>almost</strong> all methods for creating <code>Example</code>. If I default construct any of the above using an empty braced initializer list, then the instance is successfully constructed. In Meyer's Effective Modern C++ he gives the example (bottom of page 51):</p>\n<pre><code>Widget w3{}; // calls Widget ctor with no args\n</code></pre>\n<p>which I would thus expect to fail for the above <code>Example</code> classes i.e:</p>\n<pre><code>Example e{};\n</code></pre>\n<p>should not construct since it should call the deleted default constructor. However, it does, is usable, and if defined as the first case above, is also copyable. See <a href=\"http://coliru.stacked-crooked.com/a/fb2fa42f83a6f0a0\" rel=\"nofollow noreferrer\">live demo</a>. My question is: Is this correct, and if so, why? Also, if this is correct, how do I <strong>completely</strong> disable the destruction of the class? </p>\n", "AcceptedAnswerId": "43694276", "Title": "Default construction of deleted constructor with braced initializer list", "CreationDate": "2017-04-29T09:46:22.020", "Id": "43694112", "CommentCount": "0", "LastEditDate": "2017-05-23T12:02:18.990", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-29T18:33:59.150", "Score": "1", "OwnerUserId": "5825717", "Tags": "<c++><c++11><delete-operator>", "AnswerCount": "1"}, "43694276": {"Id": "43694276", "PostTypeId": "2", "Body": "<h2>From ground up</h2>\n<p>We will first clarify what it means to initialize an object and how/when/if a constructor is invoked.<br>\nThe following is my laymen's interpretation of the standard, for simplicity's sake some irrelevant details have been omitted or mangled. </br></p>\n<h2>Initializer</h2>\n<p>An initializer is one of the following</p>\n<pre><code>()     // parentheses\n       // nothing\n{}     // braced initializer list\n= expr // assignment expression\n</code></pre>\n<p>The parentheses and braced initializer list may contain further expressions.<br>\nThey are used like this, given <code>struct S</code></br></p>\n<pre><code>new S()        // empty parentheses\nS s(1, 2)      // parentheses with expression list as (1, 2)\nS s            // nothing\nS s{}          // empty braced initializer list\nS s{{1}, {2}}  // braced initializer list with sublists\nS s = 1        // assignment\nS s = {1, 2}   // assignment with braced initializer list\n</code></pre>\n<p><strong>Note that we have not yet mentioned constructors</strong></p>\n<h2>Initialization</h2>\n<p>Initialization is performed according to what initializers are used.</p>\n<pre><code>new S()        // value-initialize\nS s(1, 2)      // direct-initialize\nS s            // default-initialize\nS s{}          // list-initialize\nS s{{1}, {2}}  // list-initialize\nS s = 1        // copy-initialize\nS s = {1, 2}   // list-initialize\n</code></pre>\n<p>Once initialization is performed, the object is considered initialized.</p>\n<p><strong>Note that, again, constructors have not been mentioned</strong></p>\n<h2>List initialize</h2>\n<p>We will be primarily explaining what it means to list initialize something, as this is the question at hand.</p>\n<p>When list initialization occurs, the following is considered <strong>in order</strong></p>\n<ol>\n<li>If the object is an aggregate type and the list has a single element that is the object's type or is derived from the object's type, the object is initialized with that element</li>\n<li>If the object is an aggregate type, the object is aggregate initialized</li>\n<li>If the list is empty, and the object has a default constructor, the object is value-initialized (ends up calling default constructor)</li>\n<li>If the object is a class type, the constructors are considered, performing overload resolution with the elements of the list</li>\n</ol>\n<h2>Aggregate</h2>\n<p>An aggregate type is defined as <a href=\"http://eel.is/c++draft/dcl.init.aggr\" rel=\"nofollow noreferrer\">[dcl.init.aggr]</a></p>\n<blockquote>\n<p id=\"so_43694112_43694276_0\">An aggregate is an array or a class with<br>\n  -- no user-provided, explicit, or inherited constructors<br>\n  -- no private or protected non-static data members<br>\n  -- no virtual functions, and no virtual, private, or protected base classes</br></br></br></p>\n</blockquote>\n<p>Having a deleted constructor does <strong>not</strong> count towards providing a constructor.</p>\n<p>Elements of an aggregate is defined as</p>\n<blockquote>\n<p id=\"so_43694112_43694276_1\">The elements of an aggregate are:<br>\n  -- for an array, the array elements in increasing subscript order, or<br>\n  -- for a class, the direct base classes in declaration order, followed by the direct non-static data members that are not members of an anonymous union, in declaration order.</br></br></p>\n</blockquote>\n<p>Aggregate-initialization is defined as</p>\n<blockquote>\n<p id=\"so_43694112_43694276_2\">[...] the elements of the initializer list are taken as initializers for the elements of the aggregate, in order.</p>\n</blockquote>\n<h2><code>Example e{}</code></h2>\n<p>Following the rules above the question why <code>Example e{}</code> is legal is because</p>\n<pre><code>the initializer is a braced initializer list\nuses list initialization\nsince Example is an aggregate type\nuses aggregate initialization\nand therefore does not invoke any constructor\n</code></pre>\n<p>When you write <code>Example e{}</code>, it is not default constructed. It is aggregate initialized. So, yes it is perfectly fine.</p>\n<p>In fact, the following compiles</p>\n<pre><code>struct S\n{\n    S() = delete;\n    S(const S&amp;) = delete;\n    S(S&amp;&amp;) = delete;\n    S&amp; operator=(const S&amp;) = delete;\n};\n\nS s{};  //perfectly legal\n</code></pre>\n<h2>Turn off construction</h2>\n<p>Make sure that <code>Example</code> is not an aggregate type to stop aggregate initialization and delete its constructors.</p>\n<p>This is often trivial as most classes have private or protected data members. As such, it is often forgotten that aggregate initialization exists in C++.</p>\n<p>The simplest way to make a class non-aggregate would be</p>\n<pre><code>struct S\n{\n    explicit S() = delete;\n};\nS s{};  //illegal, calls deleted default constructor\n</code></pre>\n<p>However, as of 2017 May 30, only gcc 6.1 and above and clang 4.0.0 will reject this, all versions of CL and icc will incorrectly accept this.</p>\n<h2>Other initializations</h2>\n<p>This is one of the craziest corners in C++, and it was <strike>hellish</strike> informative to look through the standard to understand what exactly happened. There have been lots of <a href=\"https://stackoverflow.com/questions/1613341/what-do-the-following-phrases-mean-in-c-zero-default-and-value-initializat\">references</a> already written and I will not attempt to explain them.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-29T18:33:59.150", "Score": "4", "CreationDate": "2017-04-29T10:06:06.970", "ParentId": "43694112", "CommentCount": "11", "OwnerUserId": "4832499", "LastEditDate": "2017-05-23T12:26:01.653"}});