post_cb({"38089779": {"ParentId": "38089644", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-06-29T03:16:59.127", "Score": "17", "LastEditorUserId": "440119", "LastEditDate": "2016-06-29T03:35:06.877", "Id": "38089779", "OwnerUserId": "4151599", "Body": "<p>You're invoking undefined behavior.  <code>(&amp;vec.x)[2]</code> is equivilant to <code>(&amp;vec.x) + 2</code>, and the standard (\u00a7[expr.add]/4) has the following to say about pointer addition (emphasis mine):</p>\n<blockquote>\n<p id=\"so_38089644_38089779_0\">When an expression that has integral type is added to or subtracted\n  from a pointer, the result has the type of the pointer operand. If the\n  pointer operand points to an element of an array object<sup>84</sup>, and the\n  array is large enough, the result points to an element offset from the\n  original element such that the difference of the subscripts of the\n  resulting and original array elements equals the integral expression.\n  In other words, if the expression P points to the i-th element of an\n  array object, the expressions (P)+N (equivalently, N+(P)) and (P)-N\n  (where N has the value n) point to, respectively, the i + n-th and i \u2212\n  n-th elements of the array object, provided they exist. Moreover, if\n  the expression P points to the last element of an array object, the\n  expression (P)+1 points one past the last element of the array object,\n  and if the expression Q points one past the last element of an array\n  object, the expression (Q)-1 points to the last element of the array\n  object. <strong>If both the pointer operand and the result point to elements\n  of the same array object, or one past the last element of the array\n  object, the evaluation shall not produce an overflow; otherwise, the\n  behavior is undefined.</strong></p>\n</blockquote>\n<p>See also note 84 referenced above:</p>\n<blockquote>\n<p id=\"so_38089644_38089779_1\">84) An object that is not an array element is considered to belong to a single-element array for this purpose; see 5.3.1.</p>\n</blockquote>\n<p>Since <code>vec.x</code> is not an array, it is considered to be an element of a single-element array.  Thus <code>vec.x</code> and <code>vec.z</code> are not elements of the same array, and the behavior is undefined.</p>\n", "LastActivityDate": "2016-06-29T03:35:06.877"}, "38089644": {"CommentCount": "5", "ViewCount": "155", "PostTypeId": "1", "LastEditorUserId": "4586499", "CreationDate": "2016-06-29T03:00:52.587", "LastActivityDate": "2016-07-11T11:18:52.893", "Title": "Compiler instruction reordering", "FavoriteCount": "1", "LastEditDate": "2016-06-29T22:05:26.750", "Id": "38089644", "Score": "0", "Body": "<pre class=\"lang-cpp prettyprint-override\"><code>struct Vec\n{\n    double x, y, z;\n};\n\nVec vec;\nvec.x = 1.0;\nvec.y = 2.0;\nvec.z = 3.0;\ndouble res = (&amp;vec.x)[2];    // (&amp;vec.x)[2] should be equal to vec.z\n</code></pre>\n<p>Value of variable <b>res</b> should be equal to 3. But when I turn the optimizations on, the compiler reorders the instructions incorrectly and  <b>res</b> contains some rubbish. Some possible reordering examples:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>vec.x = 1.0;\nvec.y = 2.0;\nvec.z = 3.0;\nres = (&amp;vec.x)[2];    // correct value\n\nvec.x = 1.0;\nvec.y = 2.0;\nres = (&amp;vec.x)[2];    // incorrect value\nvec.z = 3.0;\n\nvec.x = 1.0;\nres = (&amp;vec.x)[2];    // incorrect value\nvec.y = 2.0;\nvec.z = 3.0;\n</code></pre>\n<p>Is this a bug in compiler? Or is it not allowed to access struct data members like this?</p>\n<p><b>EDIT:</b></p>\n<p>I have just realised that the previous code actually works, sorry for that. But this does not work:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>Vec vec;\nvec.x = 1.0;\nvec.y = 2.0;\nvec.z = 3.0;\ndouble res = (&amp;vec.x)[i];    // (&amp;vec.x)[i] should be equal to vec.z when i == 2\n</code></pre>\n<p>When the variable <b>i</b> is not know at compile time, compiler reorders the instructions incorrectly.</p>\n", "Tags": "<c++><optimization>", "OwnerUserId": "4586499", "AnswerCount": "3"}, "38110975": {"ParentId": "38089644", "CommentCount": "3", "CreationDate": "2016-06-29T22:17:25.917", "OwnerUserId": "4586499", "PostTypeId": "2", "Id": "38110975", "Score": "0", "Body": "<p>I have eventually found a solution which prevents instruction reordering and does not increase size of the Vec struct:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>struct Vec\n{\n    union\n    {\n        struct\n        {\n            double x, y, z;\n        };\n        double data[3];\n    };\n};\n\nVec vec;\nvec.x = 1.0;\nvec.y = 2.0;\nvec.z = 3.0;\ndouble res = vec.data[i];\n</code></pre>\n<p>Thank you for your answers.</p>\n", "LastActivityDate": "2016-06-29T22:17:25.917"}, "bq_ids": {"n4140": {"so_38089644_38089779_0": {"section_id": 6142, "quality": 0.9722222222222222, "length": 105}}, "n3337": {"so_38089644_38089779_0": {"section_id": 5906, "quality": 0.9722222222222222, "length": 105}}, "n4659": {"so_38089644_38089779_1": {"section_id": 7638, "quality": 0.8888888888888888, "length": 8}}}, "38092938": {"ParentId": "38089644", "CommentCount": "0", "CreationDate": "2016-06-29T07:23:21.630", "OwnerUserId": "6292621", "PostTypeId": "2", "Id": "38092938", "Score": "2", "Body": "<p>Apart from undefined behavior, note that C++ is not forced to allocate these next to each other. If you want to reference them both by index and name, I suggest doing the other way:</p>\n<pre><code>struct Vec\n{\n    double elems[3];\n    double&amp; x;\n    double&amp; y;\n    double&amp; z;\n\n    Vec()\n    : x( elems[0] ), y( elems[1] ), z( elems[2] )\n    {\n    }\n};\n</code></pre>\n<p>If you can't afford the possible (but not necessary) extra space per object, you might as well declare x, y, z as functions returning reference.</p>\n", "LastActivityDate": "2016-06-29T07:23:21.630"}});