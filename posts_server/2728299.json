post_cb({"2728349": {"ParentId": "2728299", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The only requirement for <code>end()</code> is that <code>++(--end()) == end()</code>. The <code>end()</code> could simply be a special state the iterator is in. There is no reason the <code>end()</code> iterator has to correspond to a pointer of any kind. </p>\n<p>Besides, even if it were a pointer, comparing two pointers doesn't require any sort of dereference anyway. Consider the following:</p>\n<pre><code>char[5] a = {'a', 'b', 'c', 'd', 'e'};\nchar* end = a+5;\nfor (char* it = a; it != a+5; ++it);\n</code></pre>\n<p>That code will work just fine, and it mirrors your vector code.</p>\n", "OwnerUserId": "130717", "LastEditorUserId": "130717", "LastEditDate": "2010-04-28T21:43:04.140", "Id": "2728349", "Score": "24", "CreationDate": "2010-04-28T09:48:32.807", "LastActivityDate": "2010-04-28T21:43:04.140"}, "2728402": {"ParentId": "2728299", "CommentCount": "0", "Body": "<p>Simple. Iterators aren't (necessarily) pointers.</p>\n<p>They have some similarities (i.e. you can dereference them), but that's about it.</p>\n", "OwnerUserId": "1737", "PostTypeId": "2", "Id": "2728402", "Score": "1", "CreationDate": "2010-04-28T09:55:37.053", "LastActivityDate": "2010-04-28T09:55:37.053"}, "2728427": {"ParentId": "2728299", "CommentCount": "4", "Body": "<p>You're right that an invalid pointer can't be used, but you're wrong that a pointer to an element one past the last element in an array is an invalid pointer - it's valid.</p>\n<p>The C standard, section 6.5.6.8 says that it's well defined and valid:</p>\n<blockquote>\n<p id=\"so_2728299_2728427_0\">...if the expression P points to the\n  last element of an array object, the\n  expression (P)+1 points one past the\n  last element of the array object...</p>\n</blockquote>\n<p>but cannot be dereferenced:</p>\n<blockquote>\n<p id=\"so_2728299_2728427_1\">...if the result points one past the\n  last element of the array object, it\n  shall not be used as the operand of a\n  unary * operator that is evaluated...</p>\n</blockquote>\n", "OwnerUserId": "59379", "PostTypeId": "2", "Id": "2728427", "Score": "10", "CreationDate": "2010-04-28T10:00:31.633", "LastActivityDate": "2010-04-28T10:00:31.633"}, "2728351": {"ParentId": "2728299", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The implementation of a standard library's container's <code>end()</code> iterator is, well, implementation-defined, so the implementation can play tricks it knows the platform to support.<br>\nIf you implemented your own iterators, you can do whatever you want - so long as it is standard-conform. For example, your iterator, if storing a pointer, could store a <code>NULL</code> pointer to indicate an end iterator. Or it could contain a boolean flag or whatnot. </br></p>\n", "OwnerUserId": "140719", "LastEditorUserId": "140719", "LastEditDate": "2010-04-28T10:05:24.497", "Id": "2728351", "Score": "1", "CreationDate": "2010-04-28T09:48:38.610", "LastActivityDate": "2010-04-28T10:05:24.497"}, "36087817": {"ParentId": "2728299", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I answer here since other answers are now out-of-date; nevertheless, they were not quite right to the question.</p>\n<p>First, C++14 has changed the rules mentioned in the question. Indirection through an invalid pointer value or passing an invalid pointer value to a deallocation function are still undefined, but other operations are now implemenatation-defined, see <a href=\"https://stackoverflow.com/questions/33395724/documentation-of-invalid-pointer-value-conversion-in-c-implementations\">Documentation of \"invalid pointer value\" conversion in C++ implementations</a>.</p>\n<p>Second, words counts. You can't bypass the definitions while applying the rules. The key point here is the definition of \"invalid\". For iterators, this is defined in <a href=\"http://www.eel.is/c++draft/iterator.requirements\" rel=\"nofollow noreferrer\">[iterator.requirements]</a>. In fact, even it is true that <a href=\"http://www.eel.is/c++draft/iterator.requirements#footnote-265\" rel=\"nofollow noreferrer\">pointers are iterators</a>, meanings of \"invalid\" to them are subtly different. Rules for pointers render \"invalid\" as \"don't indirect through invalid value\", which is a special case of \"not <a href=\"http://www.eel.is/c++draft/iterator.requirements#iterator.requirements.general-6\" rel=\"nofollow noreferrer\">dereferenceable</a>\" to iterators; however, \"not deferenceable\" is <em>not</em> implying \"invalid\" for iterators. \"Invalid\" is explicitly defined as \"<a href=\"http://www.eel.is/c++draft/iterator.requirements#iterator.requirements.general-11\" rel=\"nofollow noreferrer\">may be singular</a>\", while \"singular\" value is defined as \"not associated with any sequence\" (in the same paragraph of definition of \"dereferenceable\"). That paragraph even explicitly defined \"past-the-end values\".</p>\n<p>From the text of the standard in [iterator.requirements], it is clear that:</p>\n<ul>\n<li>Past-the-end values are not assumed to be dereferenceable (at least by the standard library), as the standard states.</li>\n<li>Dereferenceable values are not singular, since they are associated with sequence.</li>\n<li>Past-the-end values are not singular, since they are associated with sequence.</li>\n<li>An iterator is not invalid if it is definitely not singular (by negation on definition of \"invalid iterator\"). In other words, <strong>if an iterator is associated to a sequence, it is not invalid.</strong></li>\n</ul>\n<p>Value of <code>end()</code> is a past-the-end value, which is associated with a sequence before it is invalidated. So <strong>it is actually valid by definition.</strong> Even with misconception on \"invalid\" literally, the rules of pointers are not applicable here.</p>\n<p>The rules allowing <code>==</code> comparison on such values are in <a href=\"http://www.eel.is/c++draft/iterator.requirements#input.iterators-2\" rel=\"nofollow noreferrer\">input iterator requirements</a>, which is inherited by some other category of iterators (forward, bidirectional, etc). More specifically, valid iterators <a href=\"http://www.eel.is/c++draft/iterator.requirements#input.iterators-2\" rel=\"nofollow noreferrer\">are required to be comparable in the <em>domain</em> of the iterator</a> in such way (<code>==</code>). Further, forward iterator requirements specifies <a href=\"http://www.eel.is/c++draft/iterator.requirements#forward.iterators-2\" rel=\"nofollow noreferrer\">the domain is over the underlying sequence</a>. And container requirements specifies the <code>iterator</code> and <code>const_iterator</code> member types <a href=\"http://www.eel.is/c++draft/container.requirements#tab:containers.container.requirements\" rel=\"nofollow noreferrer\">in any iterator category meets forward iterator requirements</a>. Thus, <strong><code>==</code> on <code>end()</code> and iterator over same container is required to be well-defined.</strong> As a standard container, <code>vector&lt;int&gt;</code> also obey the requirements. That's the whole story.</p>\n<p>Third, even when <code>end()</code> is a pointer value (this is likely to happen with optimized implementation of iterator of <code>vector</code> instance), the rules in the question are still not applicable. The reason is mentioned above (and in some other answers): \"invalid\" is concerned with <code>*</code>(indirect through), not comparison. <a href=\"http://www.eel.is/c++draft/expr.eq#2\" rel=\"nofollow noreferrer\">One-past-end value is explicitly allowed to be compared in specified ways by the standard.</a> Also note ISO C++ is not ISO C, they also subtly mismatches (e.g. for <code>&lt;</code> on pointer values not in the same array, unspecified vs. undefined), though they have similar rules here.</p>\n", "OwnerUserId": "2307646", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:16:21.260", "Id": "36087817", "Score": "0", "CreationDate": "2016-03-18T15:06:45.910", "LastActivityDate": "2016-03-18T15:24:49.830"}, "2728418": {"ParentId": "2728299", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>One past the end is not an invalid value (neither with regular arrays or iterators). You can't dereference it but it can be used for comparisons.</p>\n<pre><code>std::vector&lt;X&gt;::iterator it;\n</code></pre>\n<p>This is a singular iterator. You can only assign a valid iterator to it.</p>\n<pre><code>std::vector&lt;X&gt;::iterator it = vec.end();\n</code></pre>\n<p>This is a perfectly valid iterator. You can't dereference it but you can use it for comparisons and decrement it (assuming the container has a sufficient size).</p>\n", "OwnerUserId": "155693", "LastEditorUserId": "155693", "LastEditDate": "2010-04-28T10:13:06.580", "Id": "2728418", "Score": "4", "CreationDate": "2010-04-28T09:58:32.490", "LastActivityDate": "2010-04-28T10:13:06.580"}, "2728328": {"ParentId": "2728299", "CommentCount": "0", "Body": "<p>Huh? There's no rule that says that iterators need to be implemented using nothing but a pointer.</p>\n<p>It could have a boolean flag in there, which gets set when the increment operation sees that it passes the end of the valid data, for instance.</p>\n", "OwnerUserId": "28169", "PostTypeId": "2", "Id": "2728328", "Score": "3", "CreationDate": "2010-04-28T09:46:42.047", "LastActivityDate": "2010-04-28T09:46:42.047"}, "2728299": {"CommentCount": "2", "AcceptedAnswerId": "2728427", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-04-28T09:42:15.047", "LastActivityDate": "2016-03-18T15:24:49.830", "LastEditDate": "2017-05-23T12:08:19.480", "ViewCount": "6370", "FavoriteCount": "1", "Title": "Why is comparing against \"end()\" iterator legal?", "Id": "2728299", "Score": "15", "Body": "<p>According to C++ standard (3.7.3.2/4) <em>using</em> (not only dereferencing, but also copying, casting, whatever else) an invalid pointer is undefined behavior (in case of doubt also see <a href=\"https://stackoverflow.com/questions/1866461/why-should-i-not-try-to-use-this-value-after-delete-this\">this question</a>). Now the typical code to traverse an STL containter looks like this:</p>\n<pre><code>std::vector&lt;int&gt; toTraverse;\n//populate the vector\nfor( std::vector&lt;int&gt;::iterator it = toTraverse.begin(); it != toTraverse.end(); ++it ) {\n    //process( *it );\n}\n</code></pre>\n<p><code>std::vector::end()</code> is an iterator onto the hypothetic element <em>beyond</em> the last element of the containter. There's no element there, therefore using a pointer through that iterator is undefined behavior.</p>\n<p>Now how does the <code>!= end()</code> work then? I mean in order to do the comparison an iterator needs to be constructed wrapping an invalid address and then that invalid address will have to be used in a comparison which again is undefined behavior. Is such comparison legal and why?</p>\n", "Tags": "<c++><stl><pointers><iterator>", "OwnerUserId": "57428", "AnswerCount": "8"}, "bq_ids": {"n4140": {"so_2728299_2728427_0": {"section_id": 6142, "quality": 1.0, "length": 14}, "so_2728299_2728427_1": {"section_id": 6142, "quality": 0.75, "length": 9}}, "n3337": {"so_2728299_2728427_0": {"section_id": 5906, "quality": 1.0, "length": 14}, "so_2728299_2728427_1": {"section_id": 5906, "quality": 0.75, "length": 9}}, "n4659": {"so_2728299_2728427_0": {"section_id": 7638, "quality": 0.5714285714285714, "length": 8}}}, "2728398": {"ParentId": "2728299", "CommentCount": "2", "Body": "<p>Besides what was already said (iterators need not be pointers), I'd like to point out the rule you cite</p>\n<blockquote>\n<p id=\"so_2728299_2728398_0\">According to C++ standard (3.7.3.2/4)\n  using (not only dereferencing, but\n  also copying, casting, whatever else)\n  an invalid pointer is undefined\n  behavior</p>\n</blockquote>\n<p>wouldn't apply to <code>end()</code> iterator anyway. Basically, when you have an array, all the pointers to its elements, plus one pointer past-the-end, plus one pointer before the start of the array, are valid. That means:</p>\n<pre><code>int arr[5];\nint *p=0;\np==arr+4; // OK\np==arr+5; // past-the-end, but OK\np==arr-1; // also OK\np==arr+123456; // not OK, according to your rule\n</code></pre>\n", "OwnerUserId": "51831", "PostTypeId": "2", "Id": "2728398", "Score": "2", "CreationDate": "2010-04-28T09:55:02.450", "LastActivityDate": "2010-04-28T09:55:02.450"}});