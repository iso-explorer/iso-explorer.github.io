post_cb({"19502001": {"ParentId": "19501838", "CommentCount": "1", "CreationDate": "2013-10-21T18:28:43.940", "OwnerUserId": "90002", "PostTypeId": "2", "Id": "19502001", "Score": "2", "Body": "<p>The static type of <code>pd</code> is <code>base *</code>. Thus, when the compiler looks for the member function <code>get_this()</code>, it finds only <code>base::get_this()</code>. The return type of <code>base::get_this()</code> is <code>base&amp;</code>, which is not convertible to <code>derived&amp;</code>. Hence the error.</p>\n", "LastActivityDate": "2013-10-21T18:28:43.940"}, "19502599": {"ParentId": "19501838", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-10-21T19:02:47.413", "Score": "0", "LastEditorUserId": "323547", "LastEditDate": "2013-10-21T19:33:44.900", "Id": "19502599", "OwnerUserId": "323547", "Body": "<p>C++ supports covariant return type.\nWhat it means is that when you call <code>get_this()</code> on a <code>derived</code> object through a <code>base</code> pointer it is the implementation of derived that is going to be called.</p>\n<p>However this does not mean that calling <code>base::get_this</code> will give you a <code>derived&amp;</code>. The return type of <code>base::get_this</code> is <code>base&amp;</code>. if you want to get a <code>derived</code> object you will have to call <code>get_this</code> through a <code>derived</code> pointer (or downcast your <code>base&amp;</code> to a <code>derived&amp;</code>). Note that this is how return type covariance work in Java, C++, D...</p>\n<pre><code>base* pbase = new base();\nbase* pderived = new derived();\nderived* pderived2 = new derived();\n\nbase&amp; a = pbase-&gt;get_this();        // call implementation in base, return base&amp;\nbase&amp; b = pderived-&gt;get_this();     // call implementation in derived, return base&amp;\nderived&amp; c = pderived2-&gt;get_this(); // call implementation in derived, return derived&amp;\n</code></pre>\n", "LastActivityDate": "2013-10-21T19:33:44.900"}, "19502468": {"ParentId": "19501838", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>I would like to add to Novelocrat's answer by referring you to section 10.3, paragraph 8 of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">working draft C++ standard (click here)</a> which explains in which case the returned pointer's static type is Derived* as opposed to Base*. Basically, if you would have called <code>get_this()</code> through a pointer to the dervied class then you would have gotten the right type with no compiler error.</p>\n<p>Here is a quote from the standard along with an example (also from the standard):</p>\n<blockquote>\n<p id=\"so_19501838_19502468_0\">If the return type of D::f di\ufb00ers from the return type of B::f, the\n  class type in the return type of D::f shall be complete at the point\n  of declaration of D::f or shall be the class type D. When the\n  overriding function is called as the \ufb01nal overrider of the overridden\n  function, its result is converted to the type returned by the\n  (statically chosen) overridden function (5.2.2). [Example:</p>\n</blockquote>\n<pre><code>class B { };\nclass D : private B { friend class Derived; };\nstruct Base {\n    virtual void vf1();\n    virtual void vf2();\n    virtual void vf3();\n    virtual B* vf4();\n    virtual B* vf5();\n    void f();\n};\n\nstruct No_good : public Base {\n    D* vf4(); // error: B (base class of D) inaccessible\n};\n\nclass A;\nstruct Derived : public Base {\n    void vf1(); // virtual and overrides Base::vf1()\n    void vf2(int); // not virtual, hides Base::vf2()\n    char vf3(); // error: invalid di\ufb00erence in return type only\n    D* vf4(); // OK: returns pointer to derived class\n    A* vf5(); // error: returns pointer to incomplete class\n    void f();\n};\n\nvoid g() {\n    Derived d;\n    Base* bp = &amp;d; // standard conversion:\n    // Derived* to Base*\n    bp-&gt;vf1(); // calls Derived::vf1()\n    bp-&gt;vf2(); // calls Base::vf2()\n    bp-&gt;f(); // calls Base::f() (not virtual)\n    B* p = bp-&gt;vf4(); // calls Derived::pf() and converts the\n    // result to B*\n    Derived* dp = &amp;d;\n    D* q = dp-&gt;vf4(); // calls Derived::pf() and does not\n    // convert the result to B*\n    dp-&gt;vf2(); // ill-formed: argument mismatch\n}\n</code></pre>\n", "Id": "19502468", "LastEditDate": "2013-10-21T19:19:12.793", "OwnerDisplayName": "user955279", "Score": "1", "CreationDate": "2013-10-21T18:56:42.790", "LastActivityDate": "2013-10-21T19:19:12.793", "LastEditorDisplayName": "user955279"}, "32041665": {"ParentId": "19501838", "CommentCount": "2", "CreationDate": "2015-08-17T01:38:21.043", "OwnerUserId": "5233527", "PostTypeId": "2", "Id": "32041665", "Score": "0", "Body": "<p>I found a simple solution, but if is possible, I would the masters to evaluate:</p>\n<pre><code>class base{ \n    type = 1;\n    virtual int getType() final {\n        return type;\n    }\n}\n\nclass derived1 : public base {\n    derived1(){\n        type = 2;\n    }\n}\n</code></pre>\n<p>This way, you can call the method 'int getType()' of any of derived classes. As the type is set on the constructor, there is no risk of misbehaviour. \nTo enhance the usability, i've created a predefined 'types'. </p>\n<p>I'm using, but I don't know if is MacGyvery! </p>\n", "LastActivityDate": "2015-08-17T01:38:21.043"}, "19501838": {"CommentCount": "3", "AcceptedAnswerId": "19503045", "PostTypeId": "1", "LastEditorUserId": "1598163", "CreationDate": "2013-10-21T18:20:15.597", "LastActivityDate": "2015-08-17T01:38:21.043", "LastEditDate": "2013-10-22T07:18:18.303", "ViewCount": "13943", "FavoriteCount": "1", "Title": "Get derived type via base class virtual function", "Id": "19501838", "Score": "8", "Body": "<p>I am trying to get the derived type of an object via a base class virtual function. I have written this, which does not compile:</p>\n<pre><code>struct base {\n  virtual base&amp; get_this() {\n    return *this;\n  }\n};\n\nstruct derived : base {\n  virtual derived&amp; get_this() override {\n    return *this;\n  }\n\n  void fn();\n};\n\n\nint main () {\n  base* pd = new derived();\n  derived&amp; x = pd-&gt;get_this(); /*ERROR*/\n  x.fn();\n  return 0;\n}\n</code></pre>\n<p>... giving me an error that: I cannot initialize a <code>derived&amp;</code> from a <code>base</code>. Since <code>get_this</code> is virtual, why does <code>pd-&gt;get_this()</code> return a <code>base&amp;</code> instead of a <code>derived&amp;</code>? Thanks in advance!</p>\n<p>EDIT:</p>\n<p>Thanks everyone for their useful answers and apologies for my late reply. I should have specified in the original post that I am also interested in a solution to my problem rather than just figuring out why the above does not compile. My main problem is that <code>fn</code> is unique to the <code>derived</code> class and cannot be called via the base class. Using casts sure solves the problem but I hate writing code with if else constructs just to get the right type (also Scott Meyers advise against casts :)) . The answers seem to indicate that casts are the way to go, which in a way is at least reassuring that I am not neglecting a more 'elegant' solution to my problem. Thanks again!</p>\n", "Tags": "<c++><types><derived>", "OwnerUserId": "1598163", "AnswerCount": "5"}, "19503045": {"ParentId": "19501838", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-10-21T19:27:37.683", "Score": "6", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:36.113", "Id": "19503045", "OwnerUserId": "1413395", "Body": "<p><a href=\"https://stackoverflow.com/questions/3516889/covariant-return-types\">C++ covariant return types</a> support will only work, as long you already know the derived type. To <a href=\"http://en.wikipedia.org/wiki/Downcasting\" rel=\"nofollow noreferrer\">downcast</a> a base class to a possibly derived class, simply use <code>dynamic_cast&lt;derived&gt;(base_ref)</code> to determine if base_ref matches the actual derived type:</p>\n<pre><code>int main () {\n    base* pd = new derived();\n    derived&amp; x = dynamic_cast&lt;derived&amp;&gt;(*pd); // Will throw an exception if pd \n                                          // isn't a 'derived'\n    x.fn();\n    return 0;\n}\n</code></pre>\n<p>Or alternatively:</p>\n<pre><code>int main () {\n    base* pd = new derived();\n    derived* x = dynamic_cast&lt;derived*&gt;(pd); // Will return nullptr if pd isn't\n                                         // a 'derived'\n    if(x) {\n        x-&gt;fn();\n    }\n    else {\n        // dynamic_cast&lt;derived*&gt; failed ...\n    }\n    return 0;\n}\n</code></pre>\n<p><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> supports covariant return types for derived classes, but as the other answers describe you cannot get it via calling the base class (<code>pd-&gt;get_this()</code>) here.</p>\n<p>You might also consider <a href=\"http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern#Static_polymorphism\" rel=\"nofollow noreferrer\">static polymorphism</a> to check type compliance at compile time, if you can't use <a href=\"http://en.wikipedia.org/wiki/Run-time_type_information\" rel=\"nofollow noreferrer\">RTTI</a>, exception handling or want tight type binding (without vtable overhead).</p>\n", "LastActivityDate": "2013-10-21T20:16:35.173"}, "bq_ids": {"n4140": {"so_19501838_19502468_0": {"section_id": 7009, "quality": 0.8181818181818182, "length": 27}}, "n3337": {"so_19501838_19502468_0": {"section_id": 6755, "quality": 0.8787878787878788, "length": 29}}, "n4659": {"so_19501838_19502468_0": {"section_id": 8506, "quality": 0.8181818181818182, "length": 27}}}});