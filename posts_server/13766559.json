post_cb({"13766559": {"ViewCount": "163", "Body": "<p>I've come across this syntactic construct a few times, and I'm wondering:</p>\n<ol>\n<li>What does this do?</li>\n<li>What might the design reasoning be?</li>\n</ol>\n<p>It tends to look something like this:</p>\n<pre><code>struct SubType : public SomeSuperType {\n\n    SubType(int somthing) : SuperType(something), m_foo(*((FooType *)0))\n    {}\n\n    private:\n    FooType m_foo;\n}\n</code></pre>\n<p>To be clear, the code works.  But what's the purpose?  What would be the status of <code>m_foo</code> without that line?</p>\n", "Title": "C++: *((SomeType*) 0 )?", "CreationDate": "2012-12-07T15:57:59.127", "LastActivityDate": "2012-12-07T20:11:56.757", "CommentCount": "15", "LastEditDate": "2012-12-07T16:27:23.403", "PostTypeId": "1", "LastEditorUserId": "489549", "Id": "13766559", "Score": "2", "OwnerUserId": "489549", "Tags": "<c++><pointers><initialization>", "AnswerCount": "3"}, "13770299": {"Id": "13770299", "PostTypeId": "2", "Body": "<p>I don't think the example is necessarily UB. It depends on the definition of <code>FooType</code>. Suppose <code>Foo</code> is an empty class with a constructor that does something:</p>\n<pre><code>class Foo {\n  public:\n    Foo() { std::cout &lt;&lt; \"Hey, world! A new Foo just arrived.\\n\"; }\n    // I think the default copy and assign constructors do nothing\n    // with an empty type, but just in case:\n    Foo(const Foo&amp;) {}\n    Foo&amp; operator=(const Foo&amp;) { return *this; }\n};\n</code></pre>\n<p>Now, suppose I need a Foo, for whatever reason, and I don't want to trigger the constructor. Doing this will not cause any actual dereferencing because <i>operator* does not dereference</i> and the copy constructor doesn't use its reference argument:</p>\n<pre><code>Foo(*static_cast&lt;Foo*&gt;(0));\n</code></pre>\n", "LastActivityDate": "2012-12-07T20:11:56.757", "CommentCount": "0", "CreationDate": "2012-12-07T20:11:56.757", "ParentId": "13766559", "Score": "1", "OwnerUserId": "1566221"}, "13767066": {"Id": "13767066", "PostTypeId": "2", "Body": "<p>The purpose of this construct is to emulate a fake unnamed object of type <code>SomeType</code> in situations when you formally need an object, but don't want or can't declare a real one. It has its valid uses and does not necessarily cause undefined behavior.</p>\n<p>A classic example would be determining the size of some class member</p>\n<pre><code>sizeof (*(SomeClass *) 0).some_member\n</code></pre>\n<p>or a similar application of decltype</p>\n<pre><code>decltype((*(SomeClass *) 0).some_member)\n</code></pre>\n<p>Neither of the above examples causes any undefined behavior. In non-evaluated context expressions like <code>*(SomeClass *) 0</code> are perfectly legal and valid.</p>\n<p>You can also see this technique used for illustrative purposes in the language standard itself, as in 8.3.5/12</p>\n<blockquote>\n<p id=\"so_13766559_13767066_0\">A trailing-return-type is most useful for a type that would be more\n  complicated to specify before the declarator-id: </p>\n<pre><code>template &lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u); \n</code></pre>\n<p id=\"so_13766559_13767066_1\">rather than </p>\n<pre><code>template &lt;class T, class U&gt; decltype((*(T*)0) + (*(U*)0)) add(T t, U u);\n</code></pre>\n</blockquote>\n<p>Observe how the <code>(*(T*)0) + (*(U*)0)</code> expression is used under <code>decltype</code> to perform compile-time prediction of the result type of binary <code>+</code> operator between types <code>T</code> and <code>U</code>.</p>\n<p>Of course, again, such tricks are only valid when used in non-evaluated contexts, as shown above.</p>\n<p>Sometimes it is used as an initializer for \"null references\" as in</p>\n<pre><code>SomeType &amp;r = *(SomeType *) 0;\n</code></pre>\n<p>but this actually crosses the boundary of what's legal and produces undefined behavior.</p>\n<p>What you have in your specific example is invalid, since it attempts to access an invalid \"null lvalue\" in evaluated context.</p>\n<p>P.S. In C language there's also that peculiar part of specification that says that operators <code>&amp;</code> and <code>*</code> cancel each other, meaning that <code>&amp;*(SomeType *) 0</code> is valid and guaranteed to evaluate to null pointer. But it does not extend to C++.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2012-12-07T18:51:32.603", "Score": "6", "CreationDate": "2012-12-07T16:28:49.443", "ParentId": "13766559", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2012-12-07T18:51:32.603"}, "bq_ids": {"n4140": {"so_13766559_13767066_0": {"length": 10, "quality": 1.0, "section_id": 3248}}, "n3337": {"so_13766559_13767066_0": {"length": 10, "quality": 1.0, "section_id": 3121}}, "n4659": {"so_13766559_13767066_0": {"length": 10, "quality": 1.0, "section_id": 4006}}}, "13766643": {"Id": "13766643", "PostTypeId": "2", "Body": "<p>What does this do? Undefined behaviour.</p>\n<p>What might the design reasoning be? A desire to cause undefined behaviour. There's no other rationale.</p>\n", "LastActivityDate": "2012-12-07T16:03:13.017", "CommentCount": "5", "CreationDate": "2012-12-07T16:03:13.017", "ParentId": "13766559", "Score": "5", "OwnerUserId": "298661"}});