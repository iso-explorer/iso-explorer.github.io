post_cb({"27136566": {"ParentId": "27136524", "CommentCount": "4", "Body": "<p><code>X</code> doesn't need to be \"bound\" to a function, because you stated in your code that such function exists. So compiler can safely assume, that the address of this function must not be NULL. For that to be possible, you'd have to declare the function to be a weak symbol, and you didn't. Linker did not protest, because you never call your function (you never use its actual address), so it sees no problem.</p>\n", "OwnerUserId": "157344", "PostTypeId": "2", "Id": "27136566", "Score": "13", "CreationDate": "2014-11-25T20:59:31.897", "LastActivityDate": "2014-11-25T20:59:31.897"}, "27136708": {"ParentId": "27136524", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>What's happening here is that the function pointer is implicitly converted to <code>bool</code>. This is specified by <code>[conv.bool]</code>:</p>\n<blockquote>\n<p id=\"so_27136524_27136708_0\">A zero value, null pointer value, or null member pointer value is converted to <code>false</code>;\n  any other value is converted to <code>true</code></p>\n</blockquote>\n<p>where \"null pointer value\" includes null function pointers. Since the function pointer obtained from decay of a function name cannot be null, this gives <code>true</code>.  You can see this by including <code>&lt;&lt; std::boolalpha</code> in the output command.</p>\n<p>The following does cause a link error in g++: <code>(int)x;</code></p>\n<hr>\n<p>Regarding whether this behaviour is permitted or not, C++14 <code>[basic.odr.ref]/3</code> says:</p>\n<blockquote>\n<p id=\"so_27136524_27136708_1\">A function whose name appears as a potentially-evaluated expression is odr-used if it is\n  the unique lookup result or the selected member of a set of overloaded functions [...]</p>\n</blockquote>\n<p>which does cover this case, since <code>x</code> in the output expression is looked up to the declaration of <code>x</code>  above and that is the unique result.  Then in <code>/4</code> we have:</p>\n<blockquote>\n<p id=\"so_27136524_27136708_2\">Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required.</p>\n</blockquote>\n<p>so the program is ill-formed but no diagnostic is required, meaning that the program's behaviour is completely undefined. </p>\n<p>Incidentally this clause implies that no link error is required for <code>x();</code> either, however from a quality-of-implementation angle; that would be silly.  The course that <code>g++</code> has chosen here seems reasonable to me.</p>\n</hr>", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2014-11-25T21:25:51.480", "Id": "27136708", "Score": "27", "CreationDate": "2014-11-25T21:09:07.227", "LastActivityDate": "2014-11-25T21:25:51.480"}, "27136524": {"CommentCount": "12", "AcceptedAnswerId": "27136708", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2014-11-25T20:56:26.623", "LastActivityDate": "2016-03-18T10:43:15.473", "LastEditDate": "2016-03-18T10:43:15.473", "ViewCount": "1511", "FavoriteCount": "9", "Title": "Why does the C++ linker allow undefined functions?", "Id": "27136524", "Score": "29", "Body": "<p>This C++ code, perhaps surprisingly, prints out <code>1</code>. </p>\n<pre><code>#include &lt;iostream&gt;\n\nstd::string x();\n\nint main() {\n\n    std::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p><code>x</code> is a function prototype, which seems to be viewed as a function pointer, and C++ Standard section 4.12 Boolean conversions says:</p>\n<blockquote>\n<p id=\"so_27136524_27136524_0\">4.12 Boolean conversions [conv.bool] 1 A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be\n  converted to a prvalue of type bool. A zero value, null pointer value,\n  or null member pointer value is converted to false; any other value is\n  converted to true. For direct-initialization (8.5), a prvalue of type\n  std::nullptr_t can be converted to a prvalue of type bool; the\n  resulting value is false.</p>\n</blockquote>\n<p>However, <code>x</code> is never bound to a function. As I would expect, the C linker doesn't allow this. However in C++ this isn't a problem at all. Can anyone explain this behavior?</p>\n", "Tags": "<c++><compilation><linker><language-lawyer><undefined-function>", "OwnerUserId": "349931", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_27136524_27136708_1": {"section_id": 7040, "quality": 1.0, "length": 15}, "so_27136524_27136858_1": {"section_id": 7041, "quality": 1.0, "length": 12}, "so_27136524_27136708_0": {"section_id": 44, "quality": 1.0, "length": 15}, "so_27136524_27136858_0": {"section_id": 7040, "quality": 0.9166666666666666, "length": 22}, "so_27136524_27136524_0": {"section_id": 44, "quality": 0.8888888888888888, "length": 40}, "so_27136524_27136708_2": {"section_id": 7041, "quality": 1.0, "length": 12}}, "n3337": {"so_27136524_27136708_1": {"section_id": 6785, "quality": 0.6666666666666666, "length": 10}, "so_27136524_27136858_1": {"section_id": 6786, "quality": 1.0, "length": 12}, "so_27136524_27136708_0": {"section_id": 41, "quality": 1.0, "length": 15}, "so_27136524_27136858_0": {"section_id": 6785, "quality": 0.7083333333333334, "length": 17}, "so_27136524_27136524_0": {"section_id": 41, "quality": 0.8666666666666667, "length": 39}, "so_27136524_27136708_2": {"section_id": 6786, "quality": 1.0, "length": 12}}, "n4659": {"so_27136524_27136708_1": {"section_id": 8537, "quality": 1.0, "length": 15}, "so_27136524_27136708_0": {"section_id": 45, "quality": 1.0, "length": 15}, "so_27136524_27136858_1": {"section_id": 8538, "quality": 1.0, "length": 12}, "so_27136524_27136858_0": {"section_id": 8537, "quality": 0.9166666666666666, "length": 22}, "so_27136524_27136524_0": {"section_id": 45, "quality": 0.8888888888888888, "length": 40}, "so_27136524_27136708_2": {"section_id": 8538, "quality": 1.0, "length": 12}}}, "27136858": {"ParentId": "27136524", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>[basic.def.odr]/2:</p>\n<blockquote>\n<p id=\"so_27136524_27136858_0\">A function whose name appears\n  as a potentially-evaluated expression is odr-used if it is the unique lookup result or the selected member of a\n  set of overloaded functions (3.4, 13.3, 13.4), unless it is a pure virtual function and its name is not explicitly\n  qualified.</p>\n</blockquote>\n<p>Hence, strictly speaking, the code odr-uses the function and therefore requires a definition. <br>\nBut modern compilers will realize that the functions exact address is not actually relevant for the behavior of the program, and will thus elide the use and not require a definition. </br></p>\n<p>Also note what [basic.def.odr]/3 specifies:</p>\n<blockquote>\n<p id=\"so_27136524_27136858_1\">Every program shall contain exactly one definition of every non-inline\n  function or variable that is odr-used in that program; <strong>no diagnostic\n  required.</strong></p>\n</blockquote>\n<p>An implementation is not obliged to halt compilation and issue an error message (=diagnostic). It can do what it considers best. In other words, any action is allowed and we have UB.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-11-25T21:31:49.800", "Id": "27136858", "Score": "9", "CreationDate": "2014-11-25T21:19:10.080", "LastActivityDate": "2014-11-25T21:31:49.800"}});