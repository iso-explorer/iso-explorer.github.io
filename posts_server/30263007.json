post_cb({"bq_ids": {"n4140": {"so_30263007_30263103_0": {"length": 20, "quality": 1.0, "section_id": 289}}, "n3337": {"so_30263007_30263103_0": {"length": 20, "quality": 1.0, "section_id": 280}}, "n4659": {"so_30263007_30263103_0": {"length": 20, "quality": 1.0, "section_id": 296}}}, "30263007": {"ViewCount": "647", "Body": "<p>The issue is clear with the following code:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n  //std::vector&lt;int&gt; a, b;\n  int a = 0, b = 0;\n  auto refa = std::ref(a);\n  auto refb = std::ref(b);\n  std::cout &lt;&lt; (refa &lt; refb) &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>\n<p>If I use the commented <code>std::vector&lt;int&gt; a, b;</code> instead of <code>int a = 0, b = 0;</code>, then the code does not compile on any of GCC 5.1, clang 3.6, or MSVC'13. In my opinion, <code>std::reference_wrapper&lt;std::vector&lt;int&gt;&gt;</code> is implicitly convertible to <code>std::vector&lt;int&gt;&amp;</code> which is LessThanComparable, and thus it should be LessThanComparable itself. Could someone explain this to me?</p>\n", "AcceptedAnswerId": "30263103", "Title": "Issue with std::reference_wrapper", "CreationDate": "2015-05-15T15:11:02.707", "Id": "30263007", "CommentCount": "17", "PostTypeId": "1", "LastActivityDate": "2015-07-14T18:51:22.630", "Score": "17", "OwnerUserId": "1348273", "Tags": "<c++><c++11><language-lawyer><implicit-conversion><reference-wrapper>", "AnswerCount": "2"}, "31414956": {"Id": "31414956", "PostTypeId": "2", "Body": "<p>Are you certain that </p>\n<blockquote id=\"so_30263007_31414956_0\">\n<pre><code>std::vector&lt;int&gt; a, b;\n</code></pre>\n</blockquote>\n<p>Is doing what it is supposed to?  Take this for example</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n  std::vector&lt;int&gt; a, b;\n  //int a = 0, b = 0;\n  a.push_back(42);\n  a.push_back(6);\n  a.push_back(15);\n  for (int ii=0; ii&lt;43; ii++) {\n    b.push_back(ii);\n  }\n  auto refa = std::ref(a);\n  auto refb = std::ref(b);\n  std::cout&lt;&lt;&amp;refa&lt;&lt;std::endl;\n  std::cout&lt;&lt;&amp;refb&lt;&lt;std::endl;\n  std::cout&lt;&lt;\"Contents of vector A\"&lt;&lt;std::endl;\n  for(auto n : a)\n  {\n    std::cout&lt;&lt;' '&lt;&lt;n;\n  }\n  std::cout&lt;&lt;std::endl&lt;&lt;\"Contents of vector b: \";\n  for (auto n : b){\n    std::cout&lt;&lt;' '&lt;&lt;n;\n  }\n  //std::cout &lt;&lt; (refa &lt; refb) &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>\n<p>Which results in</p>\n<pre><code>0x7fff5fbff0c0\n0x7fff5fbff0b8\nContents of vector A\n 42 6 15\nContents of vector b:  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42\n</code></pre>\n<p>Ultimately</p>\n<pre><code>std::vector&lt;int&gt; a, b;\n</code></pre>\n<p>Creates two separate vectors of integers called a and b, both of which have no contents; this is not how one would declare a single vector with members a and b.</p>\n<pre><code>int a=0, b=0;\n</code></pre>\n<p>Declares two separate integers called a and b, which each have a value of 0.  Those two code snippets declare completely different variables and should not be used interchangeably.  </p>\n", "LastActivityDate": "2015-07-14T18:51:22.630", "CommentCount": "0", "CreationDate": "2015-07-14T18:51:22.630", "ParentId": "30263007", "Score": "0", "OwnerUserId": "5095007"}, "30263103": {"Id": "30263103", "PostTypeId": "2", "Body": "<p>The issue is that the non-member <a href=\"http://en.cppreference.com/w/cpp/container/vector/operator_cmp\"><code>operator&lt;</code></a> for <code>std::vector</code> is a function template:</p>\n<pre><code>template&lt; class T, class Alloc &gt;\nbool operator&lt;( const vector&lt;T,Alloc&gt;&amp; lhs,\n                const vector&lt;T,Alloc&gt;&amp; rhs );\n</code></pre>\n<p>Implicit conversions are <strong>not</strong> considered when doing template type deduction here, [temp.arg.explicit] emphasis on if:</p>\n<blockquote>\n<p id=\"so_30263007_30263103_0\">Implicit conversions (Clause 4) will be performed on a function argument to convert it to the type of the\n  corresponding function parameter <strong>if</strong> the parameter type contains no <em>template-parameters</em> that participate\n  in template argument deduction.</p>\n</blockquote>\n<p>But in this case, the parameter type does participate in deduction. That's why it can't be found. Had we written our own <em>non</em>-template <code>operator&lt;</code>:</p>\n<pre><code>bool operator&lt;(const std::vector&lt;int&gt;&amp; lhs, const std::vector&lt;int&gt;&amp; rhs)\n{\n    return true;\n}\n</code></pre>\n<p>Your code would work as expected. To use the generic one though, you will have to explicitly pull out the reference:</p>\n<pre><code>std::cout &lt;&lt; (refa.get() &lt; refb.get()) &lt;&lt; '\\n';\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-15T15:20:41.860", "Score": "20", "CreationDate": "2015-05-15T15:16:49.730", "ParentId": "30263007", "CommentCount": "8", "OwnerUserId": "2069064", "LastEditDate": "2015-05-15T15:20:41.860"}});