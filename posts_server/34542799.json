post_cb({"34569403": {"Id": "34569403", "PostTypeId": "2", "Body": "<p><strong>The constructor</strong></p>\n<p>Let's start with the constructor (your first line):</p>\n<p>As we both know (just clarifying), <code>decltype(std::forward_as_tuple(9))</code> is <code>std::tuple&lt;int&amp;&amp;&gt;</code>.</p>\n<p>Also note that:</p>\n<pre><code>std::is_constructible&lt;int&amp;, int&amp;&amp;&gt;::value == false\n</code></pre>\n<p>on all compiler platforms.  Therefore, according to the spec you quote, which is consistent with the latest C++1z working draft, the construction in your first line of code should not participate in overload resolution.</p>\n<p>In clang with libc++ it correctly fails to compile according to this spec:</p>\n<p><a href=\"http://melpon.org/wandbox/permlink/7cTyS3luVn1XRXGv\" rel=\"nofollow noreferrer\">http://melpon.org/wandbox/permlink/7cTyS3luVn1XRXGv</a></p>\n<p>With the latest gcc it incorrectly compiles according to this spec:</p>\n<p><a href=\"http://melpon.org/wandbox/permlink/CSoB1BTNF3emIuvm\" rel=\"nofollow noreferrer\">http://melpon.org/wandbox/permlink/CSoB1BTNF3emIuvm</a></p>\n<p>And with the latest VS-2015 it incorrectly compiles according to this spec:</p>\n<p><a href=\"http://webcompiler.cloudapp.net\" rel=\"nofollow noreferrer\">http://webcompiler.cloudapp.net</a></p>\n<p>(this last link doesn't contain the correct code, you have to paste it in).</p>\n<p>In your coliru link, although you are using clang, clang is implicitly using gcc's libstdc++ for the std::lib, so your results are consistent with mine.</p>\n<p>From this survey, it appears that <em>only</em> libc++ is consistent both with the spec, and with your expectations.  But that is not the end of the story.</p>\n<p>The latest working draft spec that you have correctly quoted is different than the C++14 spec which looks like this:</p>\n<blockquote>\n<p id=\"so_34542799_34569403_0\"><code>template &lt;class... UTypes&gt; constexpr tuple(tuple&lt;UTypes...&gt;&amp;&amp; u);</code></p>\n<p id=\"so_34542799_34569403_1\"><em>Requires</em>: <code>sizeof...(Types) == sizeof...(Types)</code>. <code>is_constructible&lt;Ti,\n  Ui&amp;&amp;&gt;::value</code> is <code>true</code> for all <em>i</em>.</p>\n<p id=\"so_34542799_34569403_2\"><em>Effects</em>: For all <em>i</em>, initializes the <em>ith</em> element of <code>*this</code> with\n  <code>std::forward&lt;Ui&gt;(get&lt;i&gt;(u))</code>.</p>\n<p id=\"so_34542799_34569403_3\"><em>Remark</em>: This constructor shall not participate in overload resolution\n  unless each type in <code>UTypes</code> is implicitly convertible to its\n  corresponding type in <code>Types</code>.</p>\n</blockquote>\n<p>It was <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387.html\" rel=\"nofollow noreferrer\">N4387</a> that changed the specification <em>after</em> C++14.</p>\n<p>In C++14 (and in C++11 as well), the onus is on the <em>client</em> to ensure that <code>is_constructible&lt;Ti, Ui&amp;&amp;&gt;::value</code> is <code>true</code> for all <em>i</em>.  And if it is not, you have undefined behavior.</p>\n<p>So your first line of code is undefined behavior in C++11 and C++14, and ill-formed in the C++1z working draft.  With undefined behavior, anything can happen.  So all of libc++, libstdc++ and VS are conforming according to the C++11 and C++14 specification.</p>\n<hr>\n<p><strong>Update</strong> inspired by <a href=\"https://stackoverflow.com/users/2756719/t-c\">T.C.</a>'s comment below:</p>\n<p>Note that the removal of this one constructor from overload resolution might allow the expression to use another constructor such as <code>tuple(const tuple&lt;UTypes...&gt;&amp; u)</code>.  However this constructor is also removed from overload resolution by a similar <em>Remarks</em> clause.</p>\n<pre><code>std::is_constructible&lt;int&amp;, const int&amp;&gt;::value == false\n</code></pre>\n<p>Alas, T.C. may have found a defect in the working draft.  The actual spec says:</p>\n<pre><code>std::is_constructible&lt;int&amp;, int&amp;&gt;::value == true\n</code></pre>\n<p>because the <code>const</code> is applied to the reference, not the <code>int</code>.</p>\n<hr>\n<p>It appears that libstdc++ and VS have not yet implemented the post-C++14 spec, specified by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387.html\" rel=\"nofollow noreferrer\">N4387</a>, and which pretty much specifies what your comments indicate should happen.  libc++ has implemented <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387.html\" rel=\"nofollow noreferrer\">N4387</a> for years, and served as a proof-of-implementation for that proposal.</p>\n<p><strong>The assignment</strong></p>\n<p>This requires:</p>\n<pre><code>std::is_assignable&lt;int&amp;, const int&amp;&gt;::value == true\n</code></pre>\n<p>and this is in fact true in your example assignment.  In this line of code.  However I think an argument could be made that it should instead require:</p>\n<pre><code>std::is_assignable&lt;int&amp;&amp;, const int&amp;&gt;::value == true\n</code></pre>\n<p>which is false.  Now if we only made this change, your assignment would be undefined behavior since this part of the spec is in a <em>Requires</em> clause.  So if you really want to do this right, you need to move the spec into a <em>Remarks</em> clause with the recipe of \"does not participate in overload resolution.\"  And then it would behave as your comments indicate you expect it to.  I would support such a proposal. But you will have to make it, don't ask me to. But I would offer you help in doing that if you would like.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-02T19:22:47.303", "Score": "6", "CreationDate": "2016-01-02T18:42:42.800", "ParentId": "34542799", "CommentCount": "11", "OwnerUserId": "576911", "LastEditDate": "2017-05-23T10:34:05.533"}, "34542799": {"ViewCount": "928", "Body": "<p>It seems like a <code>std::tuple</code> containing one or more references has unexpected behavior with regards to construction and assignment (especially copy/move construction and copy/move assignment). It's different from the behavior of both <code>std::reference_wrapper</code> (changes the referred to object) and a struct with a member reference variable (assignment operator deleted). It allows for the convenient <code>std::tie</code> python like multiple return values, but it also allows obviously incorrect code like the following <a href=\"http://coliru.stacked-crooked.com/a/5bb2f716d8db7af9\" rel=\"nofollow\" title=\"code\">(link here)</a>:</p>\n<pre><code>#include &lt;tuple&gt;\n\nint main()\n{\n    std::tuple&lt;int&amp;&gt; x{std::forward_as_tuple(9)}; // OK - doesn't seem like it should be\n    std::forward_as_tuple(5) = x; // OK - doesn't seem like it should be\n    // std::get&lt;0&gt;(std::forward_as_tuple(5)) = std::get&lt;0&gt;(x); // ERROR - and should be\n    return 0;\n}\n</code></pre>\n<p>The standard seems to require or strongly hint at this behavior in the copy(ish) assignment section <code>20.4.2.2.9</code> of the latest working draft (<code>Ti&amp;</code> will collapse to lvalue ref):</p>\n<blockquote>\n<p id=\"so_34542799_34542799_0\"><code>template &lt;class... UTypes&gt; tuple&amp; operator=(const tuple&lt;UTypes...&gt;&amp; u);</code></p>\n<p id=\"so_34542799_34542799_1\">9 <strong>Requires:</strong> <code>sizeof...(Types) == sizeof...(UTypes)</code> and <strong><code>is_assignable&lt;Ti&amp;, const Ui&amp;&gt;::value</code></strong> is true for all <code>i</code>.</p>\n<p id=\"so_34542799_34542799_2\">10 <strong>Effects:</strong> Assigns each element of u to the corresponding element of *this.</p>\n<p id=\"so_34542799_34542799_3\">11 <strong>Returns:</strong> *this</p>\n</blockquote>\n<p>Although the move(ish) construction section <code>20.4.2.1.20</code> is less clear (<code>is_constructible&lt;int&amp;, int&amp;&amp;&gt;</code> returns <code>false</code>):</p>\n<blockquote>\n<p id=\"so_34542799_34542799_4\"><code>template &lt;class... UTypes&gt; EXPLICIT constexpr tuple(tuple&lt;UTypes...&gt;&amp;&amp; u);</code></p>\n<p id=\"so_34542799_34542799_5\">18 <strong>Requires:</strong> <code>sizeof...(Types) == sizeof...(UTypes)</code>.</p>\n<p id=\"so_34542799_34542799_6\">19 <strong>Effects:</strong> For all <code>i</code>, the constructor initializes the <code>i</code>th element of <code>*this</code> with <code>std::forward&lt;Ui&gt;(get&lt;i&gt;(u))</code>.</p>\n<p id=\"so_34542799_34542799_7\">20 <strong>Remarks:</strong> This constructor shall not participate in overload resolution unless <strong><code>is_constructible&lt;Ti, Ui&amp;&amp;&gt;::value</code></strong> is true for all <code>i</code>. The constructor is <code>explicit</code> if and only if <code>is_convertible&lt;Ui&amp;&amp;, Ti&gt;::value</code> is false for at least one <code>i</code>.</p>\n</blockquote>\n<p>These are not the only affected subsections.</p>\n<p>The question is, why is this behavior desired? Also, if there are other parts of the standard at play, or I'm misunderstanding it, explain where I went wrong.</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "34569403", "Title": "Why does the standard allow a tuple of rvalue references to be assigned to by a tuple of lvalue references?", "CreationDate": "2015-12-31T07:26:17.713", "Id": "34542799", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2016-01-03T04:44:11.040", "LastEditorUserId": "3973558", "LastActivityDate": "2016-01-03T04:44:11.040", "Score": "12", "OwnerUserId": "3973558", "Tags": "<c++><c++11><assignment-operator><stdtuple>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_34542799_34569403_0": {"length": 5, "quality": 1.0, "section_id": 4029}, "so_34542799_34569403_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 4022}, "so_34542799_34542799_0": {"length": 6, "quality": 1.0, "section_id": 4048}, "so_34542799_34569403_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 4026}, "so_34542799_34542799_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 4043}, "so_34542799_34542799_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 4029}, "so_34542799_34542799_1": {"length": 5, "quality": 0.625, "section_id": 4027}}, "n3337": {"so_34542799_34569403_0": {"length": 4, "quality": 0.8, "section_id": 3879}, "so_34542799_34542799_0": {"length": 6, "quality": 1.0, "section_id": 3898}, "so_34542799_34542799_1": {"length": 5, "quality": 0.625, "section_id": 3877}, "so_34542799_34542799_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 3893}, "so_34542799_34569403_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 3872}, "so_34542799_34569403_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 3876}, "so_34542799_34542799_4": {"length": 4, "quality": 0.6666666666666666, "section_id": 3879}}, "n4659": {"so_34542799_34542799_7": {"length": 11, "quality": 0.6111111111111112, "section_id": 4926}, "so_34542799_34569403_0": {"length": 5, "quality": 1.0, "section_id": 4934}, "so_34542799_34542799_0": {"length": 6, "quality": 1.0, "section_id": 4952}, "so_34542799_34542799_1": {"length": 5, "quality": 0.625, "section_id": 4934}, "so_34542799_34542799_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 4946}, "so_34542799_34542799_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 4934}, "so_34542799_34569403_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 4928}}}});