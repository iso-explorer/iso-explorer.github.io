post_cb({"15412921": {"ParentId": "15412570", "CommentCount": "4", "Body": "<p>The most obvious (and probably most effective) way to make this work is to provide copy assignment and copy construction operators to \"do the right thing\", something on this general order:</p>\n<pre><code>struct X {\n    int val;\n    int* pVal;\n\n    X(int v) : val(v), pVal(&amp;val) {}   \n    X(X const &amp;other) : val(other.val), pVal(&amp;val) {} \n\n    // pVal was already set by ctor, so just ignore it:\n    X &amp;operator=(X const &amp;other) { val = other.val; return *this; }\n\n    // and allow assignment directly from an int:\n    X &amp;operator=(int n) { val = n; return *this; }\n};\n</code></pre>\n<p>Then the rest of the code can just copy/assign <code>X</code> objects without jumping through hoops to prevent corruption.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "15412921", "Score": "3", "CreationDate": "2013-03-14T15:07:23.677", "LastActivityDate": "2013-03-14T15:07:23.677"}, "15413320": {"ParentId": "15412570", "LastEditDate": "2013-03-15T11:29:53.250", "CommentCount": "2", "CreationDate": "2013-03-14T15:22:56.047", "OwnerUserId": "396672", "LastEditorUserId": "102441", "PostTypeId": "2", "Id": "15413320", "Score": "-1", "Body": "<p>For me it seems quite acceptable  solution if X's destructor will be called before placement new. It's syntactically allowed even the destructor is not actually specified for the class.</p>\n<pre><code>struct X {\n  int val;\n  int* pVal;\n  X(int v) : val(v), pVal(&amp;val) {}\n};\n\nX x(1);\n\nvoid foo() {\n  doStuffWith(x);\n  x.~X();\n  new (&amp;x) X(2); \n  doStuffWith(x);\n}\n</code></pre>\n<p>In this form it is a correct way to reuse memory for any object (but only if the object's ctor can't throw! otherwise  UB may happen on program shutdown, i.e. double call of the destructor).</p>\n<p>Indeed, the equality of pointers passed and returned from placement new in it non-array form is guaranteed by the standard:</p>\n<blockquote>\n<h3>18.6.1.3 Placement forms</h3>\n<p id=\"so_15412570_15413320_0\">...</p>\n<p id=\"so_15412570_15413320_1\">void* operator new(std::size_t size, void* ptr) noexcept;</p>\n<p id=\"so_15412570_15413320_2\">Returns: ptr.</p>\n<p id=\"so_15412570_15413320_3\">Remarks: Intentionally performs no other action.</p>\n</blockquote>\n<p>(and the result of the conversion to void* and then back to the same\npointer type is also guaranteed to be the same as the source pointer)</p>\n<p>However, to avoid non-proper use of the class it would be more safe either define copy assignment and copy constructor or declare this class as noncopyable (with deleted ones)</p>\n<p>And only the last (noncopyable) case may be regarded as a reason for using placement new.</p>\n<p>Although I'm far from promoting placement new for general use, it express  the intention to reuse object memory directly and doesn't rely on any optimization. Copy constructor and copy assignment are, of course, more safe, but don't express this intention excactly: no \"copy\" actually needed, the new object should be constructed in place of the old one.</p>\n", "LastActivityDate": "2013-03-15T11:29:53.250"}, "15412570": {"CommentCount": "5", "ViewCount": "1062", "PostTypeId": "1", "LastEditorUserId": "102441", "CreationDate": "2013-03-14T14:52:19.540", "LastActivityDate": "2013-03-15T11:29:53.250", "Title": "Placement new to avoid copy constructor", "LastEditDate": "2013-03-14T15:05:57.590", "Id": "15412570", "Score": "2", "Body": "<p>I have a simple class that contains a pointer to one of it's own members:</p>\n<pre><code>struct X {\n    int val;\n    int* pVal;\n    X(int v) : val(v), pVal(&amp;val) {}\n}\n\nX x(1);\n</code></pre>\n<p>I have some code like this:</p>\n<pre><code>void foo() {\n    doStuffWith(x);\n    x = X(2); // completely discard the old value of X, and start again\n    doStuffWith(x);\n}\n</code></pre>\n<p>I'm worried that when x is reassigned, <code>x.pVal</code> will invalidly point to the member of the temporary <code>X(2)</code> if return value optimization does not occur.</p>\n<p>I realize I could write a copy constructor to fix this. However, it seems wasteful to do the copy in the first place, rather than constructing the object in the right spot in memory to begin with.</p>\n<hr>\n<p>Is it reasonable to use the placement new operator here? Or does this have unintented consequences for destructors?</p>\n<pre><code>void foo() {\n    doStuffWith(x);\n    new (&amp;x) X(2); // completely discard the old value of X, and start again\n    doStuffWith(x);\n}\n</code></pre>\n</hr>", "Tags": "<c++><placement-new>", "OwnerUserId": "102441", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_15412570_15413320_1": {"section_id": 6857, "quality": 1.0, "length": 7}, "so_15412570_15413320_3": {"section_id": 6859, "quality": 0.8, "length": 4}}, "n3337": {"so_15412570_15413320_1": {"section_id": 6603, "quality": 1.0, "length": 7}, "so_15412570_15413320_3": {"section_id": 6605, "quality": 0.8, "length": 4}}, "n4659": {"so_15412570_15413320_1": {"section_id": 8349, "quality": 1.0, "length": 7}, "so_15412570_15413320_3": {"section_id": 8351, "quality": 0.8, "length": 4}}}, "15412603": {"ParentId": "15412570", "CommentCount": "7", "Body": "<h3>No</h3>\n<p>It won't destruct the old value of <code>x</code>, but you're right the the default <em>copy assignment</em> operator won't do what you want either.</p>\n", "OwnerUserId": "961353", "PostTypeId": "2", "Id": "15412603", "Score": "1", "CreationDate": "2013-03-14T14:53:54.747", "LastActivityDate": "2013-03-14T14:53:54.747"}});