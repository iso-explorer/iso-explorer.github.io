post_cb({"bq_ids": {"n4140": {"so_11961905_11962016_0": {"length": 10, "quality": 1.0, "section_id": 307}}, "n3337": {"so_11961905_11962016_0": {"length": 10, "quality": 1.0, "section_id": 298}}, "n4659": {"so_11961905_11962016_0": {"length": 9, "quality": 0.9, "section_id": 314}}}, "11961905": {"ViewCount": "113", "Body": "<p>I have the following code :</p>\n<pre><code>template&lt;typename T&gt;\nvoid bar(int x, T y)\n{\n}\n\nvoid baz(int x, int y)\n{\n}\n\ntemplate&lt;typename T0, typename T1&gt;\nvoid foo(void k(T0, T1), T1 t)\n{\n}\n\nint main()\n{\n  foo(baz, 10); // OK\n  foo(bar, 10); // ERROR\n  return 0;\n}\n</code></pre>\n<p>Overload resolution for <code>foo</code> works correctly when passing in <code>baz</code>. However, when passing in the function template <code>bar</code>, the compiler is unable to infer the template argument <code>T0</code> of <code>foo</code>, even though there is only one <code>bar</code> in the scope, and its first argument is completely resolved to <code>int</code>. How do I write the function template <code>foo</code> such that calls like <code>foo(bar, 10)</code> can be resolved by the compiler?</p>\n", "Title": "Overload resolution when passing in a function template to another function", "CreationDate": "2012-08-14T22:47:45.143", "LastActivityDate": "2012-08-16T23:20:19.600", "CommentCount": "0", "LastEditDate": "2012-08-16T23:20:19.600", "PostTypeId": "1", "LastEditorUserId": "963864", "Id": "11961905", "Score": "0", "OwnerUserId": "691733", "Tags": "<c++><templates><function-overloading><template-function>", "AnswerCount": "2"}, "11962016": {"Id": "11962016", "PostTypeId": "2", "Body": "<p>14.8.2.1/6 (<em>Deducing template arguments from a function call</em>) answers this:</p>\n<blockquote>\n<p id=\"so_11961905_11962016_0\">When <code>P</code> is a function type, pointer to function type, or pointer to member function type:</p>\n<ul>\n<li>If the argument is an overload set containing one or more function templates, the parameter is treated as a non-deduced context.</li>\n</ul>\n</blockquote>\n<p>In your case, <code>bar</code> is a function template, and thus the argument <code>k</code> is of function type whose overload set contains function templates. Thus the template argument for <code>bar&lt;T&gt;</code> is not deducible.</p>\n<p>As a practical reasons for this, consider that <code>foo(bar&lt;int&gt;, 10)</code> and <code>foo(bar&lt;long&gt;, 10)</code> are both entirely viable calls, and the choice will not be made for you implicitly. Remember that the type of an integer literal depends on the <em>value</em>, and it would be weird if <code>foo(bar, 10)</code> and <code>foo(bar, 100000000)</code> produced different template specializations.</p>\n", "LastActivityDate": "2012-08-14T22:57:37.040", "CommentCount": "2", "CreationDate": "2012-08-14T22:57:37.040", "ParentId": "11961905", "Score": "0", "OwnerUserId": "596781"}, "11996667": {"Id": "11996667", "PostTypeId": "2", "Body": "<p>You can do:</p>\n<pre><code>  void (&amp;b)(int,int) = bar;\n  foo(b, 10);\n</code></pre>\n", "LastActivityDate": "2012-08-16T23:04:38.023", "CommentCount": "0", "CreationDate": "2012-08-16T23:04:38.023", "ParentId": "11961905", "Score": "0", "OwnerUserId": "963864"}});