post_cb({"33229890": {"CommentCount": "0", "ViewCount": "290", "PostTypeId": "1", "LastEditorUserId": "3953764", "CreationDate": "2015-10-20T06:53:22.170", "LastActivityDate": "2015-10-20T07:11:11.037", "Title": "Error binding make_unique", "AcceptedAnswerId": "33230203", "LastEditDate": "2015-10-20T07:11:11.037", "Id": "33229890", "Score": "2", "Body": "<p>I'm having trouble using <code>std::bind</code> with <code>std::make_unique</code>.</p>\n<p>I have an object to whose constructor I pass factory functions for making <code>std::unique_ptr</code>s of objects of another class type.</p>\n<p>Using VS2013, this works:</p>\n<pre><code>Tester tester( \n    [](){return std::make_unique&lt;AlphaBetaSingleThreadSSE&gt;( 0,7 ); },\n    [](){return std::make_unique&lt;AlphaBetaSingleThread&gt;( 0,7 ); },\n    20 );\n</code></pre>\n<p>This gives me compile errors:</p>\n<pre><code>Tester tester( \n    std::bind( std::make_unique&lt;AlphaBetaSingleThreadSSE&gt;,0,7 ),\n    std::bind( std::make_unique&lt;AlphaBetaSingleThread&gt;,0,7 ),\n    20 );\n</code></pre>\n<p>The error messages state:</p>\n<blockquote>\n<p id=\"so_33229890_33229890_0\">error C2512: 'AlphaBetaSingleThread' : no appropriate default\n  constructor available </p>\n<p id=\"so_33229890_33229890_1\">error C2512: 'AlphaBetaSingleThreadSSE' : no\n  appropriate default constructor available</p>\n</blockquote>\n<p>Why does the <code>std::bind</code> approach fail?</p>\n", "Tags": "<c++><c++11><unique-ptr><stdbind>", "OwnerUserId": "3773305", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33229890_33230203_0": {"section_id": 4351, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_33229890_33230203_0": {"section_id": 457, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_33229890_33230203_0": {"section_id": 5613, "quality": 0.7142857142857143, "length": 5}}}, "33230203": {"ParentId": "33229890", "CommentCount": "1", "Body": "<p><code>std::make_unique</code> is defined as follows:</p>\n<p>\u00a7 20.8.1.4 [unique.ptr.create]</p>\n<blockquote>\n<pre><code>template &lt;class T, class... Args&gt; unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args);\n</code></pre>\n<p id=\"so_33229890_33230203_0\"><sup>1</sup> <em>Remarks</em>: This function shall not participate in overload resolution unless <code>T</code> is not an array.</p>\n<p id=\"so_33229890_33230203_1\"><sup>2</sup> <em>Returns</em>: <code>unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...)).</code></p>\n</blockquote>\n<p>By explicitly instantiating this function template with <code>std::make_unique&lt;AlphaBetaSingleThreadSSE&gt;</code> you end up with the following specialization:</p>\n<pre><code>std::unique_ptr&lt;AlphaBetaSingleThreadSSE&gt; make_unique()\n{\n    return std::unique_ptr&lt;AlphaBetaSingleThreadSSE&gt;(new AlphaBetaSingleThreadSSE());\n}\n</code></pre>\n<p>That is, it won't anymore let you pass additional arguments that would be forwarded to the constructor of <code>AlphaBetaSingleThreadSSE</code>, and instead, will try to use a default constructor of <code>AlphaBetaSingleThreadSSE</code> (which doesn't exist as the error message states).</p>\n<p>You can work around that by specifying also type template parameter <code>Args</code>:</p>\n<pre><code>std::make_unique&lt;AlphaBetaSingleThreadSSE, const int&amp;, const int&amp;&gt;\n</code></pre>\n<p>but then you won't benefit from perfect-forwarding and this is not a portable solultion anyway. A better solution is to stay with a lambda.</p>\n", "OwnerUserId": "3953764", "PostTypeId": "2", "Id": "33230203", "Score": "5", "CreationDate": "2015-10-20T07:10:35.253", "LastActivityDate": "2015-10-20T07:10:35.253"}});