post_cb({"bq_ids": {"n4140": {"so_6138439_6138483_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 149}}, "n3337": {"so_6138439_6138483_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 143}}, "n4659": {"so_6138439_6138483_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 153}}}, "6138483": {"Id": "6138483", "PostTypeId": "2", "Body": "<p>Partial specialization of a function template, whether it is member function template or stand-alone function template, is not allowed by the Standard:</p>\n<pre><code>template&lt;typename T, typename U&gt; void f() {} //okay  - primary template\ntemplate&lt;typename T&gt; void f&lt;T,int&gt;() {}      //error - partial specialization\ntemplate&lt;&gt; void f&lt;unsigned char,int&gt;() {}    //okay  - full specialization\n</code></pre>\n<p>But you can partially specialize the class template itself.  You can do something like this:</p>\n<pre><code>template &lt;class A&gt;\nclass Thing&lt;A,int&gt;  //partial specialization of the class template\n{\n    //..\n    int doSomething();\n};\n\ntemplate &lt;class A&gt;\nint Thing&lt;A,int&gt;::doSomething()  { /* do whatever you want to do here */ }\n</code></pre>\n<p>Note that when you partially specialize a class template, then the template parameter-list of member function (in its definition outside the class), <strong>must match</strong> the template parameter list of the class template partial specialization. That means, for the above partial specialization of the class template, you cannot define this:</p>\n<pre><code>template &lt;class A&gt;\nint Thing&lt;A,double&gt;::doSomething(); //error\n</code></pre>\n<p>Its not allowed, because the template parameter-list in function definition didn't match the template parameter-list of the class template partial specialization. \u00a714.5.4.3/1 from the Standard (2003) says,</p>\n<blockquote>\n<p id=\"so_6138439_6138483_0\">The template parameter list of a member of a class template partial specialization <strong>shall match</strong> the template parameter list of the class template partial specialization.[...]</p>\n</blockquote>\n<p>For more on this, read my answer here:</p>\n<p><a href=\"https://stackoverflow.com/questions/5206080/c-overload-templated-class-method-with-a-partial-specilization-of-that-method/5206117#5206117\">C++ - Overload templated class method with a partial specilization of that method</a></p>\n<hr>\n<p>So what is the solution? Would you partially specialize your class along with all the repetitive work?</p>\n<p>A simple solution would be work delegation, instead of partially specializing the class template. Write a <em>stand-alone</em> function template and specialize this as:</p>\n<pre><code>template &lt;class B&gt;\nB doTheActualSomething(B &amp; b) { return b;  }\n\ntemplate &lt;&gt;\nint doTheActualSomething&lt;int&gt;(int &amp; b) { return b + 1; }\n</code></pre>\n<p>And then call this function template from <code>doSomething()</code> member function as:</p>\n<pre><code>template &lt;class A, class B&gt;\nB Thing&lt;A,B&gt;::doSomething() { return doTheActualSomething&lt;B&gt;(b_); }\n</code></pre>\n<hr>\n<p>Since in your particular case, <code>doTheActualSomething</code> needs to know the value of <em>only one</em> member, namely <code>b_</code>, the above solution is fine, as you can pass the value to the function as argument whose type is the template <em>type</em> argument <code>B</code>, and specialization for <code>int</code> is possible being it full-specialization.</p>\n<p>But imagine if it needs to access multiple members, <em>type</em> of each depends on the template <em>type</em> argument-list, then defining a stand-alone function template wouldn't solve the problem, because now there will be more than one <em>type</em> argument to the function template, and you cannot <em>partially</em> specialize the function for just, say, one <em>type</em> (as its not allowed).</p>\n<p>So in this case you can define a class template instead, which defines a static non-template member function <code>doTheActualSomething</code>. Here is how:</p>\n<pre><code>template&lt;typename A, typename B&gt;\nstruct Worker\n{\n   B doTheActualSomething(Thing&lt;A,B&gt; *thing)\n   {\n      return thing-&gt;b_;\n   }\n};\n\n//partial specialization of the class template itself, for B = int\ntemplate&lt;typename A&gt;\nstruct Worker&lt;A,int&gt;\n{\n   int doTheActualSomething(Thing&lt;A,int&gt; *thing)\n   {\n      return thing-&gt;b_ + 1;\n   }\n};\n</code></pre>\n<p>Notice that you can use <code>thing</code> pointer to access any member of the class. Of course, if it needs to access private members, then you've to make <code>struct Worker</code> a  friend of <code>Thing</code> class template, as:</p>\n<pre><code>//forward class template declaration\ntemplate&lt;typename T, typename U&gt; struct Worker\n\ntemplate &lt;class A, class B&gt;\nclass Thing\n{\n    template&lt;typename T, typename U&gt;  friend struct Worker; //make it friend\n   //...\n};\n</code></pre>\n<p>Now delegate the work to the friend as:</p>\n<pre><code>template &lt;class A, class B&gt;\nB Thing&lt;A,B&gt;::doSomething()\n{\n    return Worker&lt;A,B&gt;::doTheActualSomething(this); //delegate work\n}\n</code></pre>\n<p>Two points to be noted here:</p>\n<ul>\n<li>In this solution, <code>doTheActualSomething</code> is not a member function <em>template</em>. Its not enclosing class which is template. Hence we can <em>partially</em> specialize the class template anytime, to get the desired effect of the <em>partial</em> member function template specialization.</li>\n<li>Since we pass <code>this</code> pointer as argument to the function, we can access any member of the class <code>Thing&lt;A,B&gt;</code>, even private members, as <code>Worker&lt;T,U&gt;</code> is also a friend.</li>\n</ul>\n<p>Complete online demo : <a href=\"http://www.ideone.com/uEQ4S\" rel=\"nofollow noreferrer\">http://www.ideone.com/uEQ4S</a></p>\n<hr>\n<p>Now there is still a chance of improvement. Now all instantiations of <code>Worker</code> class template are friends of all instantiation of <code>Thing</code> class template. So we can restrict this many-to-many friendship as:</p>\n<pre><code>template &lt;class A, class B&gt;\nclass Thing\n{\n    friend struct Worker&lt;A,B&gt;; //make it friend\n   //...\n};\n</code></pre>\n<p>Now only one instantiation of <code>Worker</code> class template is a friend of one instantiation of <code>Thing</code> class template. That is one-to-one friendship. That is, <code>Worker&lt;A,B&gt;</code> is a friend of <code>Thing&lt;A,B&gt;</code>. <code>Worker&lt;A,B&gt;</code> is NOT a friend of <code>Thing&lt;A,C&gt;</code>.  </p>\n<p>This change requires us to write the code in somewhat different order. See the complete demo, with all the ordering of class and function definitions and all: </p>\n<p><a href=\"http://www.ideone.com/6a1Ih\" rel=\"nofollow noreferrer\">http://www.ideone.com/6a1Ih</a></p>\n</hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2011-05-26T16:53:23.047", "Score": "30", "CreationDate": "2011-05-26T12:29:55.737", "ParentId": "6138439", "CommentCount": "20", "OwnerUserId": "415784", "LastEditDate": "2017-05-23T11:54:31.180"}, "6142796": {"Id": "6142796", "PostTypeId": "2", "Body": "<p>This is a very often found problem, and there is a surprisingly <em>simple</em> solution. I will show it in an artificial example, because it's more clearer than to use your code, and you will have to understand it to adapt it to your code</p>\n<pre><code>template&lt;typename A, typename B&gt;\nstruct TwoTypes { };\n\ntemplate&lt;typename A, typename B&gt;\nstruct X {\n  /* forwards ... */\n  void f() { fImpl(TwoTypes&lt;A, B&gt;()); }\n\n  /* special overload for &lt;A, int&gt; */\n  template&lt;typename A1&gt;\n  void fImpl(TwoTypes&lt;A1, int&gt;) {\n    /* ... */\n  }\n\n  /* generic */\n  template&lt;typename A1, typename B1&gt;\n  void fImpl(TwoTypes&lt;A1, B1&gt;) {\n    /* ... */\n  }\n};\n</code></pre>\n<p>Explicitly specializing functions is never (almost never?) the right way. In my work as a programmer, I've never explicitly specialized a function template. Overloading and partial ordering is superior. </p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2011-05-26T18:16:54.730", "Score": "6", "CreationDate": "2011-05-26T17:42:19.087", "ParentId": "6138439", "CommentCount": "2", "OwnerUserId": "34509", "LastEditDate": "2011-05-26T18:16:54.730"}, "6138439": {"ViewCount": "12945", "Body": "<p><strong>Note:</strong> this seems to be a repost of a problem: <a href=\"https://stackoverflow.com/questions/5206080/c-overload-templated-class-method-with-a-partial-specilization-of-that-method/5206117#5206117\">C++ - Overload templated class method with a partial specilization of that method</a></p>\n<p>I have boiled down a problem I am having with C++ template specialization down to a simple case.</p>\n<p>It consists of a simple 2-parameter template class <code>Thing</code>, where I would like to specialize <code>Thing&lt;A,B&gt;::doSomething()</code> for <code>B=int</code>.</p>\n<pre><code>#include &lt;cstdio&gt;\n\n//\n// A 3-parameter template class.\n//\ntemplate &lt;class A, class B&gt;\nclass Thing\n{\npublic:\n    Thing(A a, B b) : a_(a), b_(b) {}\n    B doSomething();\nprivate:\n    A a_;\n    B b_;\n};\n\n//\n// The generic case works as expected.\n//\ntemplate &lt;class A, class B&gt;\nB Thing&lt;A,B&gt;::doSomething()\n{\n    return b_;\n}\n\n//\n// This specialization does not work!\n//\ntemplate &lt;class A&gt;\nint Thing&lt;A,int&gt;::doSomething()\n{\n    return b_+1;\n}\n\nint main( int argc, char** argv )\n{\n    // Setup our thing.\n    Thing&lt;double,int&gt; thing(1.0,2);\n    // This doesn't compile - but works with the generic case.\n    printf(\"Expecting 3, and getting %i\\n\", thing.doSomething());\n    // Clean up.\n    return 0;\n}\n</code></pre>\n<p>Unfortunately, <code>g++</code> exits with the error:</p>\n<pre><code>partial_specialization.cpp:30: error: invalid use of incomplete type \u2018class Thing&lt;A, int&gt;\u2019\npartial_specialization.cpp:8: error: declaration of \u2018class Thing&lt;A, int&gt;\u2019\n</code></pre>\n<p>The <code>clang++</code> compiler is a bit more verbose, but has the same problem:</p>\n<pre><code>partial_specialization.cpp:30:19: error: nested name specifier 'Thing&lt;A, int&gt;::' for declaration does not\n      refer into a class, class template or class template partial specialization\nint Thing&lt;A,int&gt;::doSomething()\n    ~~~~~~~~~~~~~~^\npartial_specialization.cpp:32:12: error: use of undeclared identifier 'b_'\n    return b_+1;\n           ^\n2 errors generated.\n</code></pre>\n<p>I have read and understood that partial template specializations on functions aren't allowed - but I thought I was partially specializing over classes of <code>Thing</code> in this case.</p>\n<p>Any ideas?</p>\n<p><strong>What I did:</strong> A workaround, as determined from the link provided by the accepted answer:</p>\n<pre><code>template&lt; class T &gt;\ninline T foo( T const &amp; v ) { return v; }\n\ntemplate&lt;&gt;\ninline int foo( int const &amp; v ) { return v+1; }\n\n//\n// The generic case works as expected.\n//\ntemplate &lt;class A, class B&gt;\nB Thing&lt;A,B&gt;::doSomething()\n{\n    return foo(b_);\n}\n</code></pre>\n", "AcceptedAnswerId": "6138483", "Title": "Understanding (simple?) C++ Partial Template Specialization", "CreationDate": "2011-05-26T12:27:01.907", "Id": "6138439", "CommentCount": "0", "FavoriteCount": "12", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:47:01.187", "LastEditorUserId": "-1", "LastActivityDate": "2011-05-26T18:16:54.730", "Score": "14", "OwnerUserId": "253072", "Tags": "<c++><templates><template-specialization>", "AnswerCount": "2"}});