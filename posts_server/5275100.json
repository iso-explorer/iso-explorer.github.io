post_cb({"5275100": {"ViewCount": "5011", "Body": "<p>Can a union in C++ have a member function? How do union with data members and member functions exist if an object is created?</p>\n<p>If I suppose yes, then are they feasible any where. If yes then where?</p>\n", "AcceptedAnswerId": "5275191", "Title": "Union in c++ are they feasible", "CreationDate": "2011-03-11T15:48:51.790", "Id": "5275100", "CommentCount": "0", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2012-09-25T23:30:09.037", "LastEditorUserId": "718379", "LastActivityDate": "2015-02-26T12:50:06.773", "Score": "20", "OwnerUserId": "134713", "Tags": "<c++><unions>", "AnswerCount": "5"}, "5275812": {"Id": "5275812", "PostTypeId": "2", "Body": "<p>I just added some more things to @maraguida example. I wrote it as a response just to heve more room.\nIt illustrates that not only member functions, but also static member functions and operators can be added.</p>\n<pre><code>#include    &lt;iostream&gt;\n\nunion x\n {\n    int     t;\n    float   f;\n\n    int k( )        { return t * 42;};\n    static int static_k( )  { return 42;};\n\n    float k_f( )    { return f * 42.0f;};\n\n    unsigned char operator []( unsigned int );\n};\n\nunsigned char x::operator []( unsigned int i )\n{\n    if ( i &gt;= sizeof( x ) )\n        return  0;\n\n    return  ( ( unsigned char * )&amp;t )[ i ];\n}\n\nint main( )\n{\n    x   y;\n    y.t = x::static_k( );\n\n    std::cout &lt;&lt; \"y.t\\t= \" &lt;&lt; y.t &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"y.f\\t= \" &lt;&lt; y.f &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"y.k( )\\t= \" &lt;&lt; y.k( ) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"x::static_k( )\\t= \" &lt;&lt; x::static_k( ) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"y.k_f( )\\t= \" &lt;&lt; y.k_f( ) &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"y[ 0 ]\\t= \" &lt;&lt; ( unsigned int )y[ 0 ] &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"y[ 1 ]\\t= \" &lt;&lt; ( unsigned int )y[ 1 ] &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"y[ 2 ]\\t= \" &lt;&lt; ( unsigned int )y[ 2 ] &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"y[ 3 ]\\t= \" &lt;&lt; ( unsigned int )y[ 3 ] &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It can be compiled with:\n    g++ -Wall union_func.cpp -o union_func</p>\n<p>The output is:</p>\n<pre><code>$ ./union_func \ny.t     = 42\ny.f     = 5.88545e-44\ny.k( )  = 1764\nx::static_k( )  = 42\ny.k_f( )        = 2.47189e-42\ny[ 0 ]  = 42\ny[ 1 ]  = 0\ny[ 2 ]  = 0\ny[ 3 ]  = 0\n</code></pre>\n<p>You can, for example, put a conversion operator to another type of your need, if it make sense to your need.</p>\n", "LastActivityDate": "2011-03-11T16:50:00.837", "CommentCount": "0", "CreationDate": "2011-03-11T16:50:00.837", "ParentId": "5275100", "Score": "0", "OwnerUserId": "466339"}, "5275997": {"Id": "5275997", "PostTypeId": "2", "Body": "<p>You can also make a template union : </p>\n<pre><code>template &lt;typename T&gt;\nunion Foo {\npublic:\n  Foo() {}\n  Foo(const T&amp; value) : _val(value) {}\n\n  const char* data() const {\n    return _tab;\n  }\n\n  std::size_t size() const {\n    return sizeof(T);\n  }\n\n  char operator[](unsigned int index) const {\n      return _tab[index];\n  }\n\nprivate:\n  T _val;\n  char _tab[sizeof(T)];\n}\n</code></pre>\n", "LastEditorUserId": "571332", "LastActivityDate": "2015-02-26T12:50:06.773", "Score": "10", "CreationDate": "2011-03-11T17:07:48.340", "ParentId": "5275100", "CommentCount": "0", "OwnerUserId": "571332", "LastEditDate": "2015-02-26T12:50:06.773"}, "bq_ids": {"n4140": {"so_5275100_5275191_0": {"length": 27, "quality": 0.6, "section_id": 5914}}, "n3337": {"so_5275100_5275191_0": {"length": 26, "quality": 0.5777777777777777, "section_id": 5686}}, "n4659": {"so_5275100_5275191_0": {"length": 27, "quality": 0.6, "section_id": 7406}}}, "5276771": {"Id": "5276771", "PostTypeId": "2", "Body": "<p>The <code>union</code> is a C-structure, and does not work well with C++ types (there are a number of caveats actually). However there already exist a C++ equivalent, which effectively work with all C++ classes and user-defined classes and is even safer than the union!</p>\n<p>Behold <a href=\"http://www.boost.org/doc/libs/1_46_0/doc/html/variant.html\" rel=\"nofollow\">Boost.Variant</a>!</p>\n<p>You can define a <code>boost::variant&lt;std::string, Foo, char&gt;</code> and it'll make sure:</p>\n<ul>\n<li>that the appropriate constructor/destructor/assignment operator is run, when required</li>\n<li>that you only access the lastest value that was set</li>\n</ul>\n<p>And it even comes with the excellent: <code>boost::static_visitor&lt;Result&gt;</code> which let's you apply a method on the union regardless of its type and provide compile-time checking to warn you whenever you have forgotten one of the possible types!</p>\n<pre><code>class MyVisitor: boost::static_visitor&lt;int&gt;\n{\npublic:\n  int operator()(std::string const&amp; s) const {\n    return boost::lexical_cast&lt;int&gt;(s);\n  }\n\n  int operator()(Foo const&amp; f) const { return f.getAsInt(); }\n\n  int operator()(char c) const { return c; }\n};\n\ntypedef boost::variant&lt;std::string, Foo, char&gt; MyVariant;\n\nint main(int argc, char* argv[]) {\n  MyVariant v; // the std::string is constructed\n\n  if (argc % 2) { v = Foo(4); }\n  if (argc % 3) { v = argv[1][0]; }\n  if (argc % 5) { v = argv[1]; }\n\n  std::cout &lt;&lt; boost::apply_visitor(MyVisitor(), v) &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>\n<p>Also... it's as efficient (fast) as a <code>union</code>, and does not involve any dynamic look-up like Boost.Any would.</p>\n", "LastActivityDate": "2011-03-11T18:19:19.850", "CommentCount": "0", "CreationDate": "2011-03-11T18:19:19.850", "ParentId": "5275100", "Score": "1", "OwnerUserId": "147192"}, "5275191": {"Id": "5275191", "PostTypeId": "2", "Body": "<p>9.5/1</p>\n<blockquote>\n<p id=\"so_5275100_5275191_0\">A union can have member functions\n  (including constructors and\n  destructors), but not virtual (10.3)\n  functions. A union shall not have base\n  classes. A union shall not be used as\n  a base class. An object of a class\n  with a non-trivial constructor (12.1),\n  a non-trivial copy constructor (12.8),\n  a non-trivial destructor (12.4), or a\n  non-trivial copy assignment operator\n  (13.5.3, 12.8) cannot be a member of a\n  union, nor can an array of such\n  objects</p>\n</blockquote>\n<p>What do you mean by <strong>How do union with data members and member functions exist if an object is created?</strong> Member functions (non-virtual) take no space in an instance of any class/union.</p>\n", "LastActivityDate": "2011-03-11T15:55:21.740", "CommentCount": "2", "CreationDate": "2011-03-11T15:55:21.740", "ParentId": "5275100", "Score": "31", "OwnerUserId": "616700"}, "5275200": {"Id": "5275200", "PostTypeId": "2", "Body": "<p>I don't know if it's valid. <a href=\"http://codepad.org/xRJZPgyo\" rel=\"nofollow\">Codepad</a> accepts, runs, and gives the expected output from this program</p>\n<pre><code>union x {\n  int t;\n  int k() { return 42;};\n};\n\nint main() {\n  x y;\n  y.t = y.k();\n  std::cout &lt;&lt; y.t &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastActivityDate": "2011-03-11T15:56:01.617", "CommentCount": "0", "CreationDate": "2011-03-11T15:56:01.617", "ParentId": "5275100", "Score": "0", "OwnerUserId": "655353"}});