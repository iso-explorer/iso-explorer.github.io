post_cb({"9985006": {"ParentId": "9984188", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is an answer to the first part of the question, \"Here I managed to prevent the window form popping up\", i.e. how to set the Windows subsystem for an application in Visual C++.</p>\n<p>I will answer the second part of the question, about command line arguments, separately.</p>\n<pre><code>// How to create a Windows GUI or console subsystem app with a standard `main`.\n\n#ifndef _MSC_VER\n#   error Hey, this is Visual C++ specific source code!\n#endif\n\n// Better set this in the project settings, so that it's more easily configured.\n#ifdef  NDEBUG\n#   pragma comment( linker, \"/subsystem:windows /entry:mainCRTStartup\" )\n#else\n#   pragma comment( linker, \"/subsystem:console\" )\n#endif\n\n#undef  UNICODE\n#define UNICODE\n#undef  NOMINMAX\n#define NOMINAX\n#undef  STRICT\n#define STRICT\n#include &lt;windows.h&gt;\n\nint main()\n{\n    MessageBox( 0, L\"Hi!\", L\"This is the app!\", MB_SETFOREGROUND );\n}\n</code></pre>\n<p>The <strong><code>NDEBUG</code></strong> standard C++ macro is designed for suppressing the effect of standard <code>assert</code>, so it\u2019s not required to be globally meaningful. However, in practice it is globally meaningful. And then it provides a bit of portability compared to using a Visual C++ macro such as <code>DEBUG</code>.</p>\n<p>Anyway, in order to make it easier to configure the subsystem, unless you want to <em>enforce</em> that debug builds should be console and release builds should be GUI, then I recommend doing this in the project settings rather than via a <code>#pragma</code> (note also that e.g. the g++ compiler does not support linker pragmas, so using the project settings is more portable).</p>\n<p>If you want you can check the subsystem programmatically instead of just by inspection (i.e. instead of noting whether the above program produces a console or not):</p>\n<pre><code>// How to create a Windows GUI or console subsystem app with a standard `main`.\n\n#ifndef _MSC_VER\n#   error Hey, this is Visual C++ specific source code!\n#endif\n\n// Better set this in the project settings, so that it's more easily configured.\n#ifdef  NDEBUG\n#   pragma comment( linker, \"/subsystem:windows /entry:mainCRTStartup\" )\n#else\n#   pragma comment( linker, \"/subsystem:console\" )\n#endif\n\n#undef  UNICODE\n#define UNICODE\n#undef  NOMINMAX\n#define NOMINAX\n#undef  STRICT\n#define STRICT\n#include &lt;windows.h&gt;\n\n#include &lt;assert.h&gt;         // assert\n#include &lt;string&gt;           // std::wstring\n#include &lt;sstream&gt;          // std::wostringstream\nusing namespace std;\n\ntemplate&lt; class Type &gt;\nwstring stringFrom( Type const&amp; v )\n{\n    wostringstream  stream;\n\n    stream &lt;&lt; v;\n    return stream.str();\n}\n\nclass S\n{\nprivate:\n    wstring     s_;\n\npublic:\n    template&lt; class Type &gt;\n    S&amp; operator&lt;&lt;( Type const&amp; v )\n    {\n        s_ += stringFrom( v );\n        return *this;\n    }\n\n    operator wstring const&amp; () const { return s_; }\n    operator wchar_t const* () const { return s_.c_str(); }\n};\n\nIMAGE_NT_HEADERS const&amp; imageHeaderRef()\n{\n    HMODULE const                   hInstance   =\n        GetModuleHandle( nullptr );\n\n    IMAGE_DOS_HEADER const* const   pImageHeader    =\n        reinterpret_cast&lt; IMAGE_DOS_HEADER const* &gt;( hInstance );\n    assert( pImageHeader-&gt;e_magic == IMAGE_DOS_SIGNATURE );     // \"MZ\"\n\n    IMAGE_NT_HEADERS const* const   pNTHeaders      = reinterpret_cast&lt;IMAGE_NT_HEADERS const*&gt;(\n            reinterpret_cast&lt; char const* &gt;( pImageHeader ) + pImageHeader-&gt;e_lfanew\n            );\n    assert( pNTHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC );    // \"PE\"\n\n    return *pNTHeaders;\n}\n\nint main()\n{\n    IMAGE_NT_HEADERS const&amp; imageHeader = imageHeaderRef();\n    WORD const              subsystem   = imageHeader.OptionalHeader.Subsystem;\n\n    MessageBox(\n        0,\n        S() &lt;&lt; L\"Subsystem \" &lt;&lt; subsystem &lt;&lt; L\" \"\n            &lt;&lt; (0?0\n                : subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI?     L\"GUI\"\n                : subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI?     L\"Console\"\n                : L\"Other\"),\n        L\"Subsystem info:\",\n        MB_SETFOREGROUND );\n}\n</code></pre>\n", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2012-04-02T23:09:00.790", "Id": "9985006", "Score": "4", "CreationDate": "2012-04-02T23:01:52.587", "LastActivityDate": "2012-04-02T23:09:00.790"}, "9986559": {"ParentId": "9984188", "CommentCount": "0", "Body": "<p>Rather than changing your subsystem mode depending on the build type, consider using <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/ms681944%28v=vs.85%29.aspx\" rel=\"nofollow\">AllocConsole</a> to explicitly create a console for your process.</p>\n", "OwnerUserId": "886887", "PostTypeId": "2", "Id": "9986559", "Score": "0", "CreationDate": "2012-04-03T03:02:02.123", "LastActivityDate": "2012-04-03T03:02:02.123"}, "9984519": {"ParentId": "9984188", "CommentCount": "1", "Body": "<p>You can still pass parameters to a regular, non-console Win32 program: they just show up in the single <code>lpCmdLine</code> string, all globbed together into one big command line.  You can use <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/bb776391%28v=vs.85%29.aspx\" rel=\"nofollow\"><code>CommandLineToArgvW</code></a> to parse that into separate arguments, but do note that that function is only available in the Unicode flavor.  For example:</p>\n<pre><code>int wmain(int argc, wchar_t **argv)\n{\n    // Common main function (Unicode args)\n}\n\n#ifndef DEBUG\nint WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)\n{\n    // Forward invocation to wmain\n    int argc;\n    LPWSTR *argv = CommandLineToArgvW(pCmdLine, &amp;argc);\n    int status = wmain(argc, argv);\n    LocalFree(argv);\n    return status;\n}\n#endif\n</code></pre>\n<p>I'd also recommend using your project settings to set the executable's subsystem (console or Windows) depending on the configuration instead of using a <code>#pragma</code> to do it.</p>\n", "OwnerUserId": "9530", "PostTypeId": "2", "Id": "9984519", "Score": "2", "CreationDate": "2012-04-02T22:07:11.457", "LastActivityDate": "2012-04-02T22:07:11.457"}, "9985582": {"ParentId": "9984188", "CommentCount": "0", "Body": "<p>This is an answer to the second part of the question, \u201cbut I can't pass parameters to the program\u201d, i.e. how to obtain the command line arguments in a Visual C++ Windows app.</p>\n<p>The simplest but also most limited way is to use the arguments of a standard C++ <code>main</code>,</p>\n<pre><code>int main( int argc, char* argv[] )\n{\n    // Whatever, e.g.\n    vector&lt;string&gt; const args( argv, argv + argc );\n}\n</code></pre>\n<p>The C++ standard strongly suggests that those arguments should be encoded with some <em>multi-byte character set</em> such as UTF-8,</p>\n<p><strong>C++11 \u00a73.6.1/2</strong>:  </p>\n<blockquote>\n<p id=\"so_9984188_9985582_0\">\u201cIf <code>argc</code> is nonzero these arguments shall be supplied in <code>argv[0]</code>\n  through <code>argv[argc-1]</code> as pointers to the initial characters of null-terminated multibyte strings (NTMBSs) (17.5.2.1.4.2) and <code>argv[0]</code> shall be the pointer to the initial character of a NTMBS that represents the name used to invoke the program or <code>\"\"</code>.\u201d</p>\n</blockquote>\n<p>However, at the time of the first C++ standard, in 1998, neither the *nix world convention, nor the Windows convention, was to do this. Instead the convention was to pass the arguments with some locale-specific character encoding. The Linux world almost immediately started a migration towards UTF-8, while Windows did not, so that still as of 2012 in Windows the standard <code>main</code> arguments are not sufficient to pass e.g. arbitrary filenames\u2026</p>\n<p>Happily, in Windows the <strong>command line</strong> that\u2019s passed to the process, and that is available via the <code>GetCommandLine</code> API function, is UTF-16 encoded, which means that any filename (and indeed any text) can be passed.</p>\n<p>On the third hand, the API function that provides a standard parsing of the command line, <code>CommandLineToArgvW</code>, has <a href=\"http://preview.tinyurl.com/CommandLineToArgvWBug\" rel=\"nofollow\">at least one sillybug</a>, and maybe more\u2026 And presumably the non-standard Visual C++ Unicode C++ startup function <code>wmain</code> has arguments provided by that function. So for best results, until that\u2019s been fixed one should use some proper home-brewed command line parsing, e.g. as illustrated in the program below (I just picked an ad-hoc \u201cpersonal tool\u201d program I made last week, it\u2019s similar to the Windows 2000 Resource Kit\u2019s <code>timethis</code>):</p>\n<pre><code>// A program to measure the execution time of another program.\n// Based vaguely on Jeffrey Richter's \"timep\" program in\n// the 2nd edition of \"Win32 System Programming\".\n//\n// Author: Alf P. Steinbach, 2012. License: Boost license 1.0.\n\n#undef  UNICODE\n#define UNICODE\n#undef  STRICT\n#define STRICT\n#undef  NOMINMAX\n#define NOMINMAX\n#include &lt;windows.h&gt;\n#include &lt;shlwapi.h&gt;            // PathGetCharType\n\n#include    &lt;assert.h&gt;          // assert\n#include    &lt;functional&gt;        // std::function\n#include    &lt;iomanip&gt;           // set::setfill, std::setw\n#include    &lt;iostream&gt;          // std::wcout, std::endl\n#include    &lt;sstream&gt;           // std::wostringstream\n#include    &lt;stddef.h&gt;          // ptrdiff_t\n#include    &lt;stdexcept&gt;         // std::runtime_error, std::exception\n#include    &lt;stdint.h&gt;          // int64_t\n#include    &lt;string&gt;            // std::string\n#include    &lt;type_traits&gt;       // std::is_fundamental\n#include    &lt;utility&gt;           // std::move\nusing namespace std;\n\n#if !defined( CPP_STATIC_ASSERT )\n#   define CPP_STATIC_ASSERT( e )   static_assert( e, #e )\n#endif\n\n#if !defined( CPP_NORETURN )\n#   define CPP_NORETURN             [[noreturn]]\n#endif\n// MSVC  workaround: \"#define CPP_NORETURN __declspec( noreturn )\"\n// clang workaround: \"#define CPP_NORETURN __attribute__(( noreturn ))\"\n\nnamespace cpp {\n    namespace detail {\n        template&lt; class Destination, class Source &gt;\n        class ImplicitCast\n        {\n        public:\n            static Destination value( Source const v )\n            {\n                return static_cast&lt;Destination&gt;( v );\n            }\n        };\n\n        template&lt; class Source &gt;\n        class ImplicitCast&lt; bool, Source &gt;\n        {\n        public:\n            static bool value( Source const v )\n            {\n                return !!v;     // Shuts up Visual C++ sillywarning about performance.\n            }\n        };\n    };\n\n    template&lt; class Destination, class Source &gt;\n    Destination implicitCast( Source const v )\n    {\n        CPP_STATIC_ASSERT( is_fundamental&lt; Destination &gt;::value );\n        CPP_STATIC_ASSERT( is_fundamental&lt; Source &gt;::value );\n\n        return detail::ImplicitCast&lt; Destination, Source &gt;::value( v );\n    }\n\n    typedef ptrdiff_t       Size;\n\n    inline bool hopefully( bool const c ) { return c; }\n\n    inline CPP_NORETURN bool throwX( string const&amp; s )\n    {\n        throw runtime_error( s );\n    }\n\n    inline CPP_NORETURN bool throwX( string const&amp; s, exception const&amp; reasonX )\n    {\n        throwX( s + \"\\n!Because - \" + reasonX.what() );\n    }\n\n    class ScopeGuard\n    {\n    private:\n        function&lt;void()&gt;  cleanup_;\n\n        ScopeGuard( ScopeGuard const&amp; );                // No such.\n        ScopeGuard&amp; operator=( ScopeGuard const&amp; );     // No such.\n\n    public:\n        ~ScopeGuard() { cleanup_(); }\n\n        ScopeGuard( function&lt;void()&gt; const cleanup )\n            : cleanup_( cleanup )\n        {}\n    };\n\n    class SubstringRef\n    {\n    private:\n        wchar_t const*  start_;\n        wchar_t const*  end_;\n\n    public:\n        Size length() const             { return end_ - start_; }\n        wchar_t const* start() const    { return start_; }\n        wchar_t const* end() const      { return end_; }\n\n        SubstringRef( wchar_t const* start, wchar_t const* end )\n            : start_( start )\n            , end_( end )\n        {}\n    };\n\n    inline void skipWhitespace( wchar_t const*&amp; p )\n    {\n        while( *p != L'\\0' &amp;&amp; iswspace( *p ) ) { ++p; }\n    }\n\n    inline wchar_t const* theAfterWhitespacePart( wchar_t const* p )\n    {\n        skipWhitespace( p );\n        return p;\n    }\n\n    inline void invert( bool&amp; b ) { b = !b; }\n}  // namespace cpp\n\nnamespace winapi {\n    using cpp::hopefully;\n    using cpp::invert;\n    using cpp::Size;\n    using cpp::skipWhitespace;\n    using cpp::SubstringRef;\n    using cpp::theAfterWhitespacePart;\n    using cpp::throwX;\n\n    namespace raw {\n        typedef DWORD                   DWord;\n        typedef FILETIME                FileTime;\n        typedef HANDLE                  Handle;\n        typedef PROCESS_INFORMATION     ProcessInformation;\n        typedef SYSTEMTIME              SystemTime;\n        typedef WORD                    Word;\n    }  // namespace raw\n\n    // The following logic is mainly a workaround for a bug in CommandLineToArgvW.\n    // See [http://preview.tinyurl.com/CommandLineToArgvWBug].\n    inline SubstringRef nextArgumentIn( wchar_t const* const commandLine )\n    {\n        wchar_t const*  p   = commandLine;\n\n        skipWhitespace( p );\n        wchar_t const* const    start   = p;\n\n        bool isInQuotedPart = false;\n        while( *p != L'\\0' &amp;&amp; (isInQuotedPart || !iswspace( *p ) ) )\n        {\n            if( *p == L'\\\"' ) { invert( isInQuotedPart ); }\n            ++p;\n        }\n        return SubstringRef( start, p );\n    }\n\n    // This corresponds essentially to the argument of wWinMain(...).\n    inline wchar_t const* commandLineArgPart()\n    {\n        SubstringRef const programSpec = nextArgumentIn( GetCommandLine() );\n        return theAfterWhitespacePart( programSpec.end() );\n    }\n\n    class ProcessInfo\n    {\n    private:\n        raw::ProcessInformation info_;\n\n        ProcessInfo( ProcessInfo const&amp; );              // No such.\n        ProcessInfo&amp; operator=( ProcessInfo const&amp; );   // No such.\n\n    public:\n        raw::ProcessInformation&amp; raw()      { return info_; }\n        raw::Handle handle() const          { return info_.hProcess; }\n\n        ~ProcessInfo()\n        {\n            ::CloseHandle( info_.hThread );\n            ::CloseHandle( info_.hProcess );\n        }\n\n        ProcessInfo(): info_() {}\n\n        ProcessInfo( ProcessInfo&amp;&amp; other )\n            : info_( move( other.info_ ) )\n        {\n            other.info_ = raw::ProcessInformation();      // Zero.\n        }\n    };\n\n    inline ProcessInfo createProcess( wchar_t const commandLine[] )\n    {\n        STARTUPINFO         startupInfo     = { sizeof( startupInfo ) };\n        ProcessInfo         processInfo;\n        wstring             mutableCommandLine( commandLine );\n\n        mutableCommandLine += L'\\0';\n        GetStartupInfo( &amp;startupInfo );\n        bool const  creationSucceeded = !!CreateProcess (\n            nullptr,                // LPCTSTR lpApplicationName,\n            &amp;mutableCommandLine[0], // LPTSTR lpCommandLine,\n            nullptr,                // LPSECURITY_ATTRIBUTES lpProcessAttributes,\n            nullptr,                // LPSECURITY_ATTRIBUTES lpThreadAttributes,\n            true,                   // BOOL bInheritHandles,\n            NORMAL_PRIORITY_CLASS,  // DWORD dwCreationFlags,\n            nullptr,                // LPVOID lpEnvironment,\n            nullptr,                // LPCTSTR lpCurrentDirectory,\n            &amp;startupInfo,           // LPSTARTUPINFO lpStartupInfo,\n            &amp;processInfo.raw()      // LPPROCESS_INFORMATION lpProcessInformation\n            );\n        hopefully( creationSucceeded )\n            || throwX( \"winapi::createProcess: CreateProcess failed\" );\n        return processInfo;\n    }\n\n    inline raw::Handle dup(\n        raw::Handle const       h,\n        raw::DWord const        desiredAccess,\n        bool                    inheritable = false\n        )\n    {\n        raw::Handle result  = 0;\n        bool const wasDuplicated = !!DuplicateHandle(\n            GetCurrentProcess(), h,\n            GetCurrentProcess(), &amp;result,\n            desiredAccess,\n            inheritable,\n            0               // options\n            );\n        hopefully( wasDuplicated )\n            || throwX( \"winapi::dup: DuplicateHandle failed\" );\n        assert( result != 0 );\n        return result;\n    }\n\n    inline int64_t mSecsFromRelative( raw::FileTime const t )\n    {\n        ULARGE_INTEGER  asLargeInt;\n\n        asLargeInt.u.HighPart   = t.dwHighDateTime;\n        asLargeInt.u.LowPart    = t.dwLowDateTime;\n\n        return asLargeInt.QuadPart/10000;\n    }\n\n    SubstringRef filenamePart( SubstringRef const&amp; path )\n    {\n        wchar_t const*  p     = path.end();\n\n        while( p != path.start() &amp;&amp; PathGetCharType( *p ) != GCT_SEPARATOR )\n        {\n            --p;\n        }\n        if( PathGetCharType( *p ) == GCT_SEPARATOR ) { ++p; }\n        return SubstringRef( p, path.end() );\n    }\n}  // namespace winapi\n\nwinapi::ProcessInfo createProcess( wchar_t const commandLine[], char const errMsg[] )\n{\n    try{ return winapi::createProcess( commandLine ); }\n    catch( exception const&amp; x ) { cpp::throwX( errMsg, x ); }\n}\n\nwinapi::raw::Handle run( wchar_t const commandLine[] )\n{\n    namespace raw = winapi::raw;\n    using cpp::hopefully;\n    using cpp::throwX;\n    using winapi::dup;\n    using winapi::ProcessInfo;\n\n    static char const* const createErrMsg = \"Failed to create process\";\n    ProcessInfo const process = createProcess( commandLine, createErrMsg );\n\n    // Early handle duplication ensures that one has the required rights.\n    raw::Handle const   accessibleHandle    =\n        dup( process.handle(), PROCESS_QUERY_INFORMATION | SYNCHRONIZE );\n\n    raw::DWord const waitResult = WaitForSingleObject( process.handle(), INFINITE );\n    hopefully( waitResult == WAIT_OBJECT_0 )\n        || throwX( \"Failed waiting for process termination.\" );\n\n    return accessibleHandle;\n}\n\nclass Interval\n{\nprivate:\n    int     hours_;\n    int     minutes_;\n    int     seconds_;\n    int     milliseconds_;\n\npublic:\n    int msecs() const       { return milliseconds_; }\n    int seconds() const     { return seconds_; }\n    int minutes() const     { return minutes_; }\n    int hours() const       { return hours_; }\n\n    Interval( int msecs, int seconds = 0, int minutes = 0, int hours = 0 )\n        : milliseconds_( msecs )\n        , seconds_( seconds )\n        , minutes_( minutes )\n        , hours_( hours )\n    {\n        assert( unsigned( hours ) &lt; 24 );\n        assert( unsigned( minutes ) &lt; 60 );\n        assert( unsigned( seconds ) &lt; 60 );\n        assert( unsigned( msecs ) &lt; 1000 );\n    }\n\n    static Interval fromMSecs( int msecs )\n    {\n        int const   totalSeconds    = msecs / 1000;\n        int const   totalMinutes    = totalSeconds / 60;\n        int const   totalHours      = totalMinutes / 24;\n\n        return Interval(\n            msecs % 1000, totalSeconds % 60, totalMinutes %60, totalHours\n            );\n    }\n};\n\nwostream&amp; operator&lt;&lt;( wostream&amp; stream, Interval const&amp; t )\n{\n    wostringstream  formatter;\n\n    formatter &lt;&lt; setfill( L'0' );\n    formatter\n        &lt;&lt; setw( 2 ) &lt;&lt; t.hours() &lt;&lt; \":\"\n        &lt;&lt; setw( 2 ) &lt;&lt; t.minutes() &lt;&lt; \":\"\n        &lt;&lt; setw( 2 ) &lt;&lt; t.seconds() &lt;&lt; \".\"\n        &lt;&lt; setw( 3 ) &lt;&lt; t.msecs();\n    return (stream &lt;&lt; formatter.str());\n}\n\nstring narrowStringFrom( cpp::SubstringRef const&amp; s )\n{\n    return string( s.start(), s.end() );    // Non-ANSI characters =&gt; garbage.\n}\n\nvoid cppMain()\n{\n    namespace raw = winapi::raw;\n    using cpp::hopefully;\n    using cpp::implicitCast;\n    using cpp::ScopeGuard;\n    using cpp::SubstringRef;\n    using cpp::throwX;\n    using winapi::commandLineArgPart;\n    using winapi::filenamePart;\n    using winapi::mSecsFromRelative;\n    using winapi::nextArgumentIn;\n\n    SubstringRef const      programSpec         = nextArgumentIn( GetCommandLine() );\n    SubstringRef const      programName         = filenamePart( programSpec );\n    wchar_t const* const    otherCommandLine    = commandLineArgPart();\n\n    hopefully( nextArgumentIn( otherCommandLine ).length() &gt; 0 )\n        || throwX( \"Usage: \" + narrowStringFrom( programName ) + \" command\" );\n\n    raw::DWord const    startMSecs          = GetTickCount(); \n    raw::Handle const   finishedProcess     = run( otherCommandLine );\n    raw::DWord const    endMSecs            = GetTickCount();\n    raw::DWord const    realElapsedMSecs    = endMSecs - startMSecs;\n    ScopeGuard const    closingHandle( [=]() { CloseHandle( finishedProcess ); } );\n\n    Interval const      realElapsedTime = Interval::fromMSecs( realElapsedMSecs );\n\n    static char const* const    commandLineLabel    = \"Command line: \";\n    static char const* const    rElapsedTimeLabel   = \"External elapsed time:   \";\n    static char const* const    pElapsedTimeLabel   = \"In-process elapsed time: \";\n    static char const* const    kernelTimeLabel     = \"In-process kernel time:  \";\n    static char const* const    userTimeLabel       = \"In-process user time:    \";\n\n    wclog &lt;&lt; endl;\n    wclog &lt;&lt; commandLineLabel &lt;&lt; \"[\" &lt;&lt; otherCommandLine &lt;&lt; \"]\" &lt;&lt; endl;\n    wclog &lt;&lt; rElapsedTimeLabel &lt;&lt; realElapsedTime &lt;&lt; endl;\n\n    raw::FileTime   creationTime;\n    raw::FileTime   exitTime;\n    raw::FileTime   kernelTime;\n    raw::FileTime   userTime;\n    bool const  timesWereObtained = !!GetProcessTimes(\n        finishedProcess, &amp;creationTime, &amp;exitTime, &amp;kernelTime, &amp;userTime\n        );\n    hopefully( timesWereObtained )\n        || throwX( \"cppMain: GetProcessTimes failed\" );\n\n    int const   elapsedTimeMSecs= implicitCast&lt;int&gt;(\n        mSecsFromRelative( exitTime ) - mSecsFromRelative( creationTime )\n        );\n    int const   kernelTimeMSecs = implicitCast&lt;int&gt;( mSecsFromRelative( kernelTime ) );\n    int const   userTimeMSecs   = implicitCast&lt;int&gt;( mSecsFromRelative( userTime ) );\n\n    wclog &lt;&lt; pElapsedTimeLabel &lt;&lt; Interval::fromMSecs( elapsedTimeMSecs ) &lt;&lt; endl;\n    wclog &lt;&lt; kernelTimeLabel &lt;&lt; Interval::fromMSecs( kernelTimeMSecs ) &lt;&lt; endl;\n    wclog &lt;&lt; userTimeLabel &lt;&lt; Interval::fromMSecs( userTimeMSecs ) &lt;&lt; endl;\n}\n\nint main()\n{\n    try\n    {\n        cppMain();\n        return EXIT_SUCCESS;\n    }\n    catch( exception const&amp; x )\n    {\n        wcerr &lt;&lt; \"!\" &lt;&lt; x.what() &lt;&lt; endl;\n    }\n    return EXIT_FAILURE;\n}\n</code></pre>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "9985582", "Score": "2", "CreationDate": "2012-04-03T00:24:22.583", "LastActivityDate": "2012-04-03T00:24:22.583"}, "9984188": {"CommentCount": "4", "CreationDate": "2012-04-02T21:35:30.413", "PostTypeId": "1", "AcceptedAnswerId": "9985006", "LastEditorUserId": "464581", "LastActivityDate": "2012-04-03T03:02:02.123", "LastEditDate": "2012-04-02T21:49:39.923", "ViewCount": "2299", "FavoriteCount": "1", "Title": "Do not show console window in release but show in debug", "Id": "9984188", "Score": "3", "Body": "<p>I would like to create a program that will run in background as a final product. For debug purpose I want it to display a console.</p>\n<p>I learned that there is a <strong>ShowWindow( hWnd, SW_HIDE );</strong> function, but if I use it in a 'standard' main function the console window still pops up for a moment. I was trying to work it out like this (yes I know it's crappy):</p>\n<pre><code>#define _WIN32_WINNT 0x0500\n#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;tchar.h&gt;\n\n\n#define DEBUG\n//#undef DEBUG\n\n#ifndef DEBUG\n#pragma comment(linker, \"/SUBSYSTEM:WINDOWS\")\n\nint APIENTRY _tWinMain(HINSTANCE hInstance,\n                     HINSTANCE hPrevInstance,\n                     LPTSTR    lpCmdLine,\n                     int       nCmdShow)\n{\n    HWND hWnd = GetConsoleWindow();\n    ShowWindow( hWnd, SW_HIDE );    \n\n    while(1);\n\n    return 0;\n}\n#else\n#pragma comment(linker, \"/SUBSYSTEM:CONSOLE\")\n    int main(int argc, int **argv)\n    {\n        HWND hWnd = GetConsoleWindow();\n\n        while(1);\n\n        return 0;\n    }\n#endif\n</code></pre>\n<p>Here I managed to prevent the window form popping up, but I can't pass parameters to the program.</p>\n<p>I believe there is a much better solution for this. Can you share?</p>\n<p>PS</p>\n<p>I don't want to use .NET.</p>\n", "Tags": "<c++><windows><visual-c++>", "OwnerUserId": "672018", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_9984188_9985582_0": {"section_id": 7146, "quality": 0.8695652173913043, "length": 20}}, "n3337": {"so_9984188_9985582_0": {"section_id": 6890, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_9984188_9985582_0": {"section_id": 8647, "quality": 0.8695652173913043, "length": 20}}}});