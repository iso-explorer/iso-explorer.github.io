post_cb({"bq_ids": {"n4140": {"so_29076190_29079664_0": {"section_id": 102, "quality": 0.9672131147540983, "length": 59}}, "n3337": {"so_29076190_29079664_0": {"section_id": 97, "quality": 0.9672131147540983, "length": 59}}, "n4659": {"so_29076190_29079664_0": {"section_id": 106, "quality": 0.9672131147540983, "length": 59}}}, "29079664": {"ParentId": "29076190", "CommentCount": "0", "Body": "<p>This doesn't seem to be particularly well-specified by the Standard. The closest I can appear to get is <strong>[temp.class]</strong>:</p>\n<blockquote>\n<p id=\"so_29076190_29079664_0\">3 - When a member function, a member class, a member enumeration, a static data member or a member\n  template of a class template is defined outside of the class template definition, the member definition is\n  defined as a template definition in which the <em>template-parameters</em> are those of the class template. The\n  names of the template parameters used in the definition of the member may be different from the template\n  parameter names used in the class template definition. The template argument list following the class\n  template name in the member definition shall name the parameters in the same order as the one used in the\n  template parameter list of the member. [...]</p>\n</blockquote>\n<p>This implies, though does not exactly state, that an out-of-line class template member definition should refer to the class template by its name, and not via an alias template.</p>\n<p>It should be reasonably easy to see why this is necessary; as an alias template can result in an arbitrarily complex computation, in order to match a use of a class template member against a potential definition the compiler would have to perform that computation on every possible combination of alias template parameters:</p>\n<pre><code>template&lt;class T&gt; struct S { void f(); };\ntemplate&lt;class T&gt; using s_t = std::conditional_t&lt;sizeof(T) % 8 == 0,\n    S&lt;T&gt;, S&lt;T*&gt;&gt;;\ntemplate&lt;class T&gt; void s_t&lt;T&gt;::f() {}\n\nint main() { S&lt;int&gt; s; s.f(); }    // defined?\n</code></pre>\n<p>Interestingly, clang (3.7) allows the use of an alias template in a class template member definition, but only where it is a straight identity calculation:</p>\n<pre><code>template&lt;class&gt; struct T { void f(); };\ntemplate&lt;class C&gt; using id_t = C;\ntemplate&lt;class C&gt; using t_t = T&lt;id_t&lt;C&gt;&gt;;\ntemplate&lt;class C&gt; void t_t&lt;C&gt;::f() {}    // OK??\n</code></pre>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "29079664", "Score": "4", "CreationDate": "2015-03-16T14:43:07.217", "LastActivityDate": "2015-03-16T14:43:07.217"}, "29089103": {"ParentId": "29076190", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>What compiler are you using? With GCC 4.8, I've found no way to make it compile, but on Visual Studio 2015 Preview, if you slightly modify your code, it compiles successfully:</p>\n<pre><code>template &lt;typename charT, typename traits&gt;\nchar_proxy&lt;charT, traits&gt;&amp; lazy_basic_string&lt;charT, traits&gt;::char_proxy::operator=(charT ch)\n{\n    return {};\n}\n</code></pre>\n<p>or, if you prefer:</p>\n<pre><code>template &lt;typename charT, typename traits&gt;\ntypename lazy_basic_string&lt;charT, traits&gt;::char_proxy&amp; char_proxy&lt;charT, traits&gt;::operator=(charT ch)\n{\n    return{};\n}\n</code></pre>\n<p>As you will have noticed, I could use the alias only either as a return type or to access the operator name, but not both.</p>\n<p>I think you've found some kind of dark area in the standard, because the following code has different behaviors on VS and GCC too. It compiles on VS 2015, but not in GCC:</p>\n<pre><code>template&lt;typename T&gt;\nclass A {\n    class B {\n        B&amp; test();\n    };\n};\n\ntemplate&lt;typename T&gt;\nusing B_alias = typename A&lt;T&gt;::B;\n\ntemplate&lt;typename T&gt;\nB_alias&lt;T&gt;&amp; B_alias&lt;T&gt;::test()\n{\n    return{};\n}\n</code></pre>\n<p>In this case, on VS I was able to use the alias both to access the function name and to specify the return type.</p>\n", "OwnerUserId": "2508150", "LastEditorUserId": "2508150", "LastEditDate": "2015-03-17T08:17:55.817", "Id": "29089103", "Score": "1", "CreationDate": "2015-03-17T00:02:40.110", "LastActivityDate": "2015-03-17T08:17:55.817"}, "29076190": {"CommentCount": "0", "AcceptedAnswerId": "29079664", "PostTypeId": "1", "LastEditorUserId": "4676150", "CreationDate": "2015-03-16T11:56:03.820", "LastActivityDate": "2015-03-17T08:17:55.817", "LastEditDate": "2015-03-16T14:05:31.777", "ViewCount": "295", "FavoriteCount": "1", "Title": "Cannot define member of dependent typedef", "Id": "29076190", "Score": "9", "Body": "<p>I am writing custom lazy string class.</p>\n<pre><code>template &lt;typename charT, typename traits = std::char_traits&lt;charT&gt;&gt;\nclass lazy_basic_string\n{\n    class char_proxy\n    {\n        char_proxy&amp; operator=(charT ch);\n    };\n\n    char_proxy operator[](size_type i);\n}\n</code></pre>\n<p>Then i want to define these methods outside of class declaration. </p>\n<pre><code>template &lt;typename charT, typename traits&gt;\nusing char_proxy = typename lazy_basic_string&lt;charT, traits&gt;::char_proxy;\n\ntemplate &lt;typename charT, typename traits&gt;\nchar_proxy&lt;charT, traits&gt;&amp; char_proxy&lt;charT, traits&gt;::operator=(charT ch)\n{\n    ...\n}\n</code></pre>\n<p>But i got compile error:</p>\n<blockquote>\n<p id=\"so_29076190_29076190_0\">cannot define member of dependent typedef char_proxy</p>\n</blockquote>\n<p>So i can't figure out what's problem here. \nWhy compiler can't use shortcut char_proxy instead of lazy_basic_string::char_proxy ?</p>\n", "Tags": "<c++>", "OwnerUserId": "4676150", "AnswerCount": "2"}});