post_cb({"335422": {"ParentId": "335369", "CommentCount": "5", "Body": "<p>The first thing you need to do is make a list of all static objects that have non-trivial constructors.</p>\n<p>Given that, you either need to plug through them one at a time, or simply replace them all with singleton-pattern objects.</p>\n<p>The singleton pattern comes in for a lot of criticism, but the lazy \"as-required\" construction is a fairly easy way to fix the majority of the problems now and in the future.</p>\n<p>old...</p>\n<pre><code>MyObject myObject\n</code></pre>\n<p>new...</p>\n<pre><code>MyObject &amp;myObject()\n{\n  static MyObject myActualObject;\n  return myActualObject;\n}\n</code></pre>\n<p>Of course, if your application is multi-threaded, this can cause you more problems than you had in the first place...</p>\n", "OwnerUserId": "1737", "Id": "335422", "PostTypeId": "2", "OwnerDisplayName": "Roddy", "Score": "0", "CreationDate": "2008-12-02T20:53:14.437", "LastActivityDate": "2008-12-02T20:53:14.437"}, "4658967": {"ParentId": "335369", "CommentCount": "0", "Body": "<p>There is code that essentially \"initializes\" C++ that is generated by the compiler. An easy way to find this code / the call stack at the time is to create a static object with something that dereferences NULL in the constructor - break in the debugger and explore a bit. The MSVC compiler sets up a table of function pointers that is iterated over for static initialization. You should be able to access this table and determine all static initialization taking place in your program.</p>\n", "OwnerUserId": "571424", "PostTypeId": "2", "Id": "4658967", "Score": "5", "CreationDate": "2011-01-11T15:01:16.067", "LastActivityDate": "2011-01-11T15:01:16.067"}, "335414": {"CommentCount": "8", "CreationDate": "2008-12-02T20:51:35.563", "LastEditorUserId": "13430", "LastActivityDate": "2008-12-02T21:52:26.393", "ParentId": "335369", "PostTypeId": "2", "LastEditorDisplayName": "Evan Teran", "LastEditDate": "2008-12-02T21:52:26.393", "Id": "335414", "Score": "5", "Body": "<p>perhaps use valgrind to find usage of uninitialized memory. The nicest solution to the \"static initialization order fiasco\" is to use a static function which returns an instance of the object like this:</p>\n<pre><code>class A {\npublic:\n    static X &amp;getStatic() { static X my_static; return my_static; }\n};\n</code></pre>\n<p>This way you access your static object is by calling getStatic, this will guarantee it is initialized on first use. </p>\n<p>If you need to worry about order of de-initialization, return a new'd object instead of a statically allocated object. </p>\n<p>EDIT: removed the redundant static object, i dunno why but i mixed and matched two methods of having a static together in my original example.</p>\n", "OwnerUserId": "13430", "OwnerDisplayName": "Evan Teran"}, "3402232": {"ParentId": "335369", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I just wrote a bit of code to track down this problem. We have a good size code base (1000+ files) that was working fine on Windows/VC++ 2005, but crashing on startup on Solaris/gcc.\nI wrote the following .h file:</p>\n<pre><code>#ifndef FIASCO_H\n#define FIASCO_H\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n// [WS 2010-07-30] Detect the infamous \"Static initialization order fiasco\"\n// email warrenstevens --&gt; [initials]@[firstnamelastname].com \n// read --&gt; http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.12 if you haven't suffered\n// To enable this feature --&gt; define E-N-A-B-L-E-_-F-I-A-S-C-O-_-F-I-N-D-E-R, rebuild, and run\n#define ENABLE_FIASCO_FINDER\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#ifdef ENABLE_FIASCO_FINDER\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n\ninline bool WriteFiasco(const std::string&amp; fileName)\n{\n    static int counter = 0;\n    ++counter;\n\n    std::ofstream file;\n    file.open(\"FiascoFinder.txt\", std::ios::out | std::ios::app);\n    file &lt;&lt; \"Starting to initialize file - number: [\" &lt;&lt; counter &lt;&lt; \"] filename: [\" &lt;&lt; fileName.c_str() &lt;&lt; \"]\" &lt;&lt; std::endl;\n    file.flush();\n    file.close();\n    return true;\n}\n\n// [WS 2010-07-30] If you get a name collision on the following line, your usage is likely incorrect\n#define FIASCO_FINDER static const bool g_psuedoUniqueName = WriteFiasco(__FILE__);\n\n#else // ENABLE_FIASCO_FINDER\n// do nothing\n#define FIASCO_FINDER\n\n#endif // ENABLE_FIASCO_FINDER\n\n#endif //FIASCO_H\n</code></pre>\n<p>and within <strong>every</strong> .cpp file in the solution, I added this:</p>\n<pre><code>#include \"PreCompiledHeader.h\" // (which #include's the above file)\nFIASCO_FINDER\n#include \"RegularIncludeOne.h\"\n#include \"RegularIncludeTwo.h\"\n</code></pre>\n<p>When you run your application, you will get an output file like so:</p>\n<pre><code>Starting to initialize file - number: [1] filename: [p:\\\\OneFile.cpp]\nStarting to initialize file - number: [2] filename: [p:\\\\SecondFile.cpp]\nStarting to initialize file - number: [3] filename: [p:\\\\ThirdFile.cpp]\n</code></pre>\n<p>If you experience a crash, the culprit should be in the last .cpp file listed. And at the very least, this will give you a good place to set breakpoints, as this code should be the <strong>absolute first</strong> of your code to execute (after which you can step through your code and see all of the globals that are being initialized).</p>\n<p><strong>Notes:</strong></p>\n<ul>\n<li><p>It's important that you put the \"FIASCO_FINDER\" macro as close to the top of your file as possible. If you put it below some other #includes you run the risk of it crashing before identifying the file that you're in.</p></li>\n<li><p>If you're using Visual Studio, and pre-compiled headers, adding this extra macro line to <strong>all</strong> of your .cpp files can be done quickly using the Find-and-replace dialog to replace your existing #include \"precompiledheader.h\" with the same text plus the FIASCO_FINDER line (if you check off \"regular expressions, you can use \"\\n\" to insert multi-line replacement text) </p></li>\n</ul>\n", "OwnerUserId": "398327", "LastEditorUserId": "2436175", "LastEditDate": "2017-05-27T16:42:28.553", "Id": "3402232", "Score": "26", "CreationDate": "2010-08-04T02:42:47.533", "LastActivityDate": "2017-05-27T16:42:28.553"}, "bq_ids": {"n4140": {"so_335369_335746_0": {"section_id": 3919, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_335369_335746_0": {"section_id": 3779, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_335369_335746_0": {"section_id": 4805, "quality": 0.9285714285714286, "length": 13}}}, "335746": {"CommentCount": "17", "CreationDate": "2008-12-02T22:51:35.993", "LastEditorUserId": "366904", "LastActivityDate": "2016-01-15T13:19:51.230", "ParentId": "335369", "LastEditDate": "2016-01-15T13:19:51.230", "OwnerDisplayName": "Martin York", "PostTypeId": "2", "Id": "335746", "Score": "58", "Body": "<h1>Solving order of initialization:</h1>\n<p>First off, this is just a temporary work-around because you have global variables that you are trying to get rid of but just have not had time yet (you are going to get rid of them eventually aren't you? :-)</p>\n<pre><code>class A\n{\n    public:\n        // Get the global instance abc\n        static A&amp; getInstance_abc()  // return a reference\n        {\n            static A instance_abc;\n            return instance_abc;\n        }\n};\n</code></pre>\n<p>This will guarantee that it is initialised on first use and destroyed when the application terminates.</p>\n<h3>Multi-Threaded Problem:</h3>\n<p>C++11 <em>does</em> guarantee that this is thread-safe:</p>\n<blockquote>\n<p id=\"so_335369_335746_0\"><strong>\u00a76.7 [stmt.dcl] p4</strong><br>\n  If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</br></p>\n</blockquote>\n<p>However, C++03 does <em>not</em> officially guarantee that the construction of static function objects is thread safe. So technically the <code>getInstance_XXX()</code> method must be guarded with a critical section. On the bright side, gcc has an explicit patch as part of the compiler that guarantees that each static function object will only be initialized once even in the presence of threads.</p>\n<p>Please note: <em>Do not</em> use the <a href=\"https://en.wikipedia.org/wiki/Double-checked_locking\" rel=\"noreferrer\">double checked locking pattern</a> to try and avoid the cost of the locking. This will not work in C++03.</p>\n<h3>Creation Problems:</h3>\n<p>On creation, there are no problems because we guarantee that it is created before it can be used.</p>\n<h3>Destruction Problems:</h3>\n<p>There is a potential problem of accessing the object after it has been destroyed. This only happens if you access the object from the destructor of another global variable (by global, I am referring to any non-local static variable).</p>\n<p>The solution is to make sure that you force the order of destruction.<br>\nRemember the order of destruction is the exact inverse of the order of construction. So if you access the object in your destructor, you must guarantee that the object has not been destroyed. To do this, you must just guarantee that the object is fully constructed before the calling object is constructed.</br></p>\n<pre><code>class B\n{\n    public:\n        static B&amp; getInstance_Bglob;\n        {\n            static B instance_Bglob;\n            return instance_Bglob;;\n        }\n\n        ~B()\n        {\n             A::getInstance_abc().doSomthing();\n             // The object abc is accessed from the destructor.\n             // Potential problem.\n             // You must guarantee that abc is destroyed after this object.\n             // To guarantee this you must make sure it is constructed first.\n             // To do this just access the object from the constructor.\n        }\n\n        B()\n        {\n            A::getInstance_abc();\n            // abc is now fully constructed.\n            // This means it was constructed before this object.\n            // This means it will be destroyed after this object.\n            // This means it is safe to use from the destructor.\n        }\n};\n</code></pre>\n", "OwnerUserId": "14065"}, "335417": {"ParentId": "335369", "CommentCount": "0", "Body": "<p>Replace all the global objects with global functions that return a reference to an object declared static in the function. This isn't thread-safe, so if your app is multi-threaded you might need some tricks like pthread_once or a global lock. This will ensure that everything is initialized before it is used.</p>\n<p>Now, either your program works (hurrah!) or else it sits in an infinite loop because you have a circular dependency (redesign needed), or else you move on to the next bug.</p>\n", "OwnerUserId": "13005", "Id": "335417", "PostTypeId": "2", "OwnerDisplayName": "onebyone.livejournal.com", "Score": "2", "CreationDate": "2008-12-02T20:52:16.640", "LastActivityDate": "2008-12-02T20:52:16.640"}, "335608": {"CommentCount": "0", "CreationDate": "2008-12-02T21:57:16.307", "LastEditorUserId": "14860", "LastActivityDate": "2015-09-29T02:44:22.707", "ParentId": "335369", "LastEditDate": "2015-09-29T02:44:22.707", "OwnerDisplayName": "Pax", "PostTypeId": "2", "Id": "335608", "Score": "14", "Body": "<p>Depending on your compiler, you can place a breakpoint at the constructor initialization code. In Visual C++, this is the <code>_initterm</code> function, which is given a start and end pointer of a list of the functions to call.</p>\n<p>Then step into each function to get the file and function name (assuming you've compiled with debugging info on). Once you have the names, step out of the function (back up to <code>_initterm</code>) and continue until <code>_initterm</code> exits.</p>\n<p>That gives you <strong><em>all</em></strong> the static initializers, not just the ones in your code - it's the easiest way to get an exhaustive list. You can filter out the ones you have no control over (such as those in third-party libraries).</p>\n<p>The theory holds for other compilers but the name of the function and the capability of the debugger may change.</p>\n", "OwnerUserId": "14860"}, "3305380": {"ParentId": "335369", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>If your project is in Visual Studio (I've tried this with VC++ Express 2005, and with Visual Studio 2008 Pro):</p>\n<ol>\n<li>Open Class View (Main menu-&gt;View-&gt;Class View)</li>\n<li>Expand each project in your solution and Click on \"Global Functions and Variables\"</li>\n</ol>\n<p>This should give you a decent list of all of the globals that are subject to <em>the fiasco</em>.</p>\n<p>In the end, a better approach is to try to remove these objects from your project (easier said than done, sometimes).</p>\n", "OwnerUserId": "398327", "LastEditorUserId": "483113", "LastEditDate": "2011-12-23T15:20:08.650", "Id": "3305380", "Score": "0", "CreationDate": "2010-07-22T02:32:53.537", "LastActivityDate": "2011-12-23T15:20:08.650"}, "827182": {"ParentId": "335369", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_335369_827182_0\"><em>We've run into some problems with the</em>\n<em>static initialization order fiasco,</em>\n<em>and I'm looking for ways to comb</em>\n<em>through a whole lot of code to find</em>\n<em>possible occurrences. Any suggestions</em>\n<em>on how to do this efficiently?</em></p>\n</blockquote>\n<p>It's not a trivial problem but at least it can done following fairly simple steps if you have an easy-to-parse intermediate-format representation of your code.</p>\n<p>1) Find all the globals that have non-trivial constructors and put them in a list.</p>\n<p>2) For each of these non-trivially-constructed objects, generate the entire potential-function-tree called by their constructors.</p>\n<p>3) Walk through the non-trivially-constructor function tree and if the code references any other non-trivially constructed globals (which are quite handily in the list you generated in step one), you have a potential early-static-initialization-order issue.</p>\n<p>4) Repeat steps 2 &amp; 3 until you have exhausted the list generated in step 1.</p>\n<p>Note: you may be able to optimize this by only visiting the potential-function-tree once per object class rather than once per global instance if you have multiple globals of a single class.</p>\n", "OwnerUserId": "14904", "PostTypeId": "2", "Id": "827182", "Score": "4", "CreationDate": "2009-05-05T22:23:19.337", "LastActivityDate": "2009-05-05T22:23:19.337"}, "827211": {"ParentId": "335369", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Gimpel Software (www.gimpel.com) claims that their PC-Lint/FlexeLint static analysis tools will detect such problems.</p>\n<p>I have had good experience with their tools, but not with this specific issue so I can't vouch for how much they would help.</p>\n", "OwnerUserId": "2255470", "LastEditorUserId": "608639", "LastEditDate": "2015-12-07T21:21:54.967", "Id": "827211", "Score": "1", "CreationDate": "2009-05-05T22:34:19.607", "LastActivityDate": "2015-12-07T21:21:54.967"}, "6504305": {"ParentId": "335369", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Other answers are correct, I just wanted to add that the object's getter should be implemented in a .cpp file and it should not be static. If you implement it in a header file, the object will be created in each library / framework you call it from....</p>\n", "OwnerUserId": "714964", "LastEditorUserId": "714964", "LastEditDate": "2011-06-28T09:36:59.140", "Id": "6504305", "Score": "0", "CreationDate": "2011-06-28T09:24:03.687", "LastActivityDate": "2011-06-28T09:36:59.140"}, "335369": {"CommentCount": "1", "ViewCount": "42982", "PostTypeId": "1", "LastEditorUserId": "10077", "FavoriteCount": "43", "CreationDate": "2008-12-02T20:40:00.597", "LastActivityDate": "2017-05-27T16:42:28.553", "AnswerCount": "11", "LastEditDate": "2013-01-08T17:49:56.873", "LastEditorDisplayName": "Fred Larson", "Title": "Finding C++ static initialization order problems", "Id": "335369", "Score": "54", "Body": "<p>We've run into some problems with the <a href=\"http://www.parashift.com/c++-faq-lite/static-init-order.html\" rel=\"noreferrer\">static initialization order fiasco</a>, and I'm looking for ways to comb through a whole lot of code to find possible occurrences.  Any suggestions on how to do this efficiently?</p>\n<p>Edit: I'm getting some good answers on how to SOLVE the static initialization order problem, but that's not really my question.  I'd like to know how to FIND objects that are subject to this problem.  Evan's answer seems to be the best so far in this regard; I don't think we can use valgrind, but we may have memory analysis tools that could perform a similar function.  That would catch problems only where the initialization order is wrong for a given build, and the order can change with each build.  Perhaps there's a static analysis tool that would catch this.  Our platform is IBM XLC/C++ compiler running on AIX.</p>\n", "Tags": "<c++><initialization><static-order-fiasco>", "OwnerUserId": "10077", "OwnerDisplayName": "Fred Larson"}});