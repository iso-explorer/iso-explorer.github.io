post_cb({"13057570": {"Id": "13057570", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13055447_13057570_0\">I can imagine that there is a shorter way to denote that the friend is defined for all possible ClassImplType enum values.</p>\n</blockquote>\n<p>Sadly, there really isn't. You might try with</p>\n<pre><code>template&lt;ClassImplType I&gt; friend class graph&lt;T, I&gt;;\n</code></pre>\n<p>but the standard simply forbids one to befriend partial specializations:</p>\n<p><code>\u00a714.5.4 [temp.friend] p8</code></p>\n<blockquote>\n<p id=\"so_13055447_13057570_1\">Friend declarations shall not declare partial specializations. [ <em>Example:</em></p>\n<pre><code>template&lt;class T&gt; class A { };\nclass X {\n  template&lt;class T&gt; friend class A&lt;T*&gt;; // error\n};\n</code></pre>\n<p id=\"so_13055447_13057570_2\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>You can only either befriend them all:</p>\n<pre><code>template&lt;class U, ClassImplType I&gt;\nfriend class graph;\n</code></pre>\n<p>Or a specific one:</p>\n<pre><code>friend class graph&lt;T /*, optional-second-arg*/&gt;;\n</code></pre>\n<p>I can't see how befriending all possible specializations might cause a problem here, to be honest, but let's assume it does. One workaround I know would be using the <a href=\"https://stackoverflow.com/q/3324898/500104\">passkey pattern</a>, though we'll use a slightly cut-down version (we can't use the <code>allow</code> mechanism here, since it doesn't work well for allowing access to all specializations of a template):</p>\n<pre><code>template&lt;class T&gt;\nclass passkey{    \n  passkey(){}\n  friend T;\n\n  // optional\n  //passkey(passkey const&amp;) = delete;\n  //passkey(passkey&amp;&amp;) = delete;\n};\n\n// Different class implementations\nenum ClassImplType { CIT_CHECK, CIT_FAST, CIT_GPU, CIT_SSE, CIT_NOF_TYPES } ;\n\ntemplate&lt;class&gt; struct vertex;\n\n// Graph class has default template argument CIT_CHECK\ntemplate &lt;typename T, ClassImplType impl_type = CIT_CHECK&gt;\nclass graph {\npublic:\n  void call_f(vertex&lt;T&gt;&amp; v){ v.f(passkey&lt;graph&gt;()); }\n  //...\n};\n\n// Vertex class\ntemplate &lt;typename T&gt;\nclass vertex {\n  //...\npublic:\n  template&lt;ClassImplType I&gt;\n  void f(passkey&lt;graph&lt;T,I&gt;&gt;){}\n};\n</code></pre>\n<p><a href=\"http://liveworkspace.org/code/ec40da8c8e87504dc7ef3daf908ecd82\" rel=\"nofollow noreferrer\">Live example with tests.</a></p>\n<p>You'll note that you need to make all functionality that <code>graph</code> needs to access public, but that's not a problem thanks to the passkeys, which can only ever be created by the specified <code>graph</code> specializations.</p>\n<p>You can also go farther and create a proxy class which can be used to access the vertex functionality (only <code>graph</code> changes):</p>\n<pre><code>// Graph class has default template argument CIT_CHECK\ntemplate &lt;typename T, ClassImplType impl_type = CIT_CHECK&gt;\nclass graph{\n  typedef passkey&lt;graph&gt; key;\n  // proxy for succinct multiple operations\n  struct vertex_access{\n    vertex_access(vertex&lt;T&gt;&amp; v, key k)\n      : _v(v), _key(k){}\n\n    void f(){ _v.f(_key); }\n\n  private:\n    vertex&lt;T&gt;&amp; _v;\n    key _key;\n  };\n\npublic:\n  void call_f(vertex&lt;T&gt;&amp; v){\n    vertex_access va(v, key());\n    va.f(); va.f(); va.f();\n    // or\n    v.f(key());\n  }\n  //...\n};\n</code></pre>\n<p><a href=\"http://liveworkspace.org/code/e6d253da9ae1fbcc12a9f968f8c21367\" rel=\"nofollow noreferrer\">Live example.</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-10-24T21:05:44.203", "Score": "8", "CreationDate": "2012-10-24T20:54:02.567", "ParentId": "13055447", "CommentCount": "3", "OwnerUserId": "500104", "LastEditDate": "2017-05-23T10:34:54.130"}, "13055465": {"Id": "13055465", "PostTypeId": "2", "Body": "<p>You can template the <code>friend</code> statement:</p>\n<pre><code>template&lt;typename U, ClassImplType  V&gt;\nfriend class graph_foo;\n</code></pre>\n<p>I'm trying to figure out how to keep the <code>T</code> - I'll update if I find out.</p>\n", "LastEditorUserId": "964135", "LastActivityDate": "2012-10-24T18:43:02.087", "Score": "6", "CreationDate": "2012-10-24T18:31:01.543", "ParentId": "13055447", "CommentCount": "10", "OwnerUserId": "964135", "LastEditDate": "2012-10-24T18:43:02.087"}, "bq_ids": {"n4140": {"so_13055447_13057570_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 133}}, "n3337": {"so_13055447_13057570_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 127}}, "n4659": {"so_13055447_13057570_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 137}}}, "13056744": {"Id": "13056744", "PostTypeId": "2", "Body": "<p>Class cannot become friend of partial specialization according to this \"non-bug\" explanation: <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=5094\" rel=\"nofollow\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=5094</a> </p>\n<pre><code> What clenches it is that 14.5.3, p9\n explicitly prohibits friend declarations of partial specializations:\n\n   -9- Friend declarations shall not declare partial specializations.\n       [Example:\n           template&lt;class T&gt; class A { };\n           class X {\n               template&lt;class T&gt; friend class A&lt;T*&gt;; // error\n           };\n       \u5bb9nd example]\n</code></pre>\n<p>But I come to the solution, which does not look perfect, neither it is easy to use. The idea is to create intermediate friend inner class, just to forward \"friendship\" to outer class. The disadvantage (or advantage?) is that one has to wrap all function/member variables which shall be available to outer friend:</p>\n<pre><code>// Different class implementations\nenum ClassImplType { CIT_CHECK, CIT_FAST, CIT_GPU, CIT_SSE, CIT_NOF_TYPES } ;\n\ntemplate &lt;typename T&gt;\nclass vertex;\n\n// Graph class has default template argument CIT_CHECK\ntemplate &lt;typename T, ClassImplType impl_type = CIT_CHECK&gt;\nclass graph {\n    typedef typename vertex&lt;T&gt;::template graph_friend&lt;impl_type&gt; graph_friend;\npublic:\n  graph(vertex&lt;T&gt;&amp; a) { graph_friend::foo(a); } // here call private method    \n  //...\n};\n\n// Vertex class\ntemplate &lt;typename T&gt;\nclass vertex {\n  //...\n  int foo() {}\npublic:\n  template &lt;ClassImplType impl_type&gt;\n  class graph_friend {\n     static int foo(vertex&amp; v) { return v.foo(); }\n     friend class graph&lt;T,impl_type&gt;;\n  };\n\n};\nint main() {\n    vertex&lt;int&gt; a;\n    graph&lt;int,CIT_SSE&gt; b(a);\n\n}\n</code></pre>\n", "LastActivityDate": "2012-10-24T19:57:38.473", "CommentCount": "1", "CreationDate": "2012-10-24T19:57:38.473", "ParentId": "13055447", "Score": "2", "OwnerUserId": "1463922"}, "13055447": {"ViewCount": "636", "Body": "<p>To define a friend of a templated class with a default argument, do you need to specify all friends as in the code below (which works)? </p>\n<pre><code>// Different class implementations\nenum ClassImplType { CIT_CHECK, CIT_FAST, CIT_GPU, CIT_SSE, CIT_NOF_TYPES } ;\n\n// Graph class has default template argument CIT_CHECK\ntemplate &lt;typename T, ClassImplType impl_type = CIT_CHECK&gt;\nclass graph {\n  //...\n};\n\n// Vertex class\ntemplate &lt;typename T&gt;\nclass vertex {\n  //...\n  friend class graph&lt;T, CIT_CHECK&gt;;\n  friend class graph&lt;T, CIT_FAST&gt;;\n  friend class graph&lt;T, CIT_GPU&gt;;\n  friend class graph&lt;T, CIT_SSE&gt;;\n};\n</code></pre>\n<p>I can imagine that there is a shorter way to denote that the friend is defined for all possible ClassImplType enum values. Something like <code>friend class graph&lt;T, ClassImplType&gt;</code>, but the latter doesn't work of course. </p>\n<p>Apologies if the terminology I use is incorrect.</p>\n", "AcceptedAnswerId": "13057570", "Title": "C++ How to specify all friends of a templated class with a default argument?", "CreationDate": "2012-10-24T18:29:46.123", "Id": "13055447", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-10-24T18:50:46.603", "LastEditorUserId": "500104", "LastActivityDate": "2012-10-24T21:05:44.203", "Score": "12", "OwnerUserId": "666057", "Tags": "<c++><templates><arguments><friend>", "AnswerCount": "4"}, "13056920": {"Id": "13056920", "PostTypeId": "2", "Body": "<p>I thought of the following way to 'fix it' by using recursive inheritance.</p>\n<p>Inline comments explain what's happening:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\n// Different class implementations\nenum ClassImplType { CIT_CHECK, CIT_FAST, CIT_GPU, CIT_SSE, CIT_NOF_TYPES };\n\ntemplate &lt;typename T, ClassImplType impl_type = CIT_CHECK&gt;\nclass graph;\n\n// Vertex class\nnamespace impl\n{\n    template &lt;typename, ClassImplType, typename enabler = void&gt; struct vertex_impl;\n\n    ///////////////////////////////////////////////////////////////\n    // actual implementation (stop condition of recursion)\n    static const ClassImplType CIT_ENDMARKER = (ClassImplType) -1;\n\n    template &lt;typename T&gt; struct vertex_impl&lt;T, CIT_ENDMARKER&gt; \n    {\n        protected: // make it protected rather than private\n            int secret() const { return 42; }\n    };\n\n    ///////////////////////////////////////////////////////////////\n    // recursion, just to mark friends\n    template &lt;typename T, ClassImplType impl_type&gt;\n        struct vertex_impl&lt;T, impl_type, typename std::enable_if&lt;CIT_ENDMARKER != impl_type&gt;::type&gt;\n            : public vertex_impl&lt;T, ClassImplType(impl_type - 1)&gt;\n        {\n             friend class ::graph&lt;T, impl_type&gt;;\n        };\n}\n\n///////////////////////////////////////////////////////////////\n// Public typedef\n#if 1\n    template &lt;typename T&gt; struct vertex : impl::vertex_impl&lt;T, CIT_NOF_TYPES&gt; { };\n#else // or c++11\n    template &lt;typename T&gt; using vertex = impl::vertex_impl&lt;T, CIT_NOF_TYPES&gt;;\n#endif\n\ntemplate &lt;typename T, ClassImplType impl_type&gt;\nclass graph\n{\n    public:\n        static void TestFriendOf(const vertex&lt;T&gt;&amp; byref)\n        {\n            std::cout &lt;&lt; byref.secret() &lt;&lt; std::endl;\n        }\n};\n\nint main(int argc, const char *argv[])\n{\n    vertex&lt;int&gt; t;\n\n    graph&lt;int, CIT_CHECK&gt;     :: TestFriendOf(t);\n    graph&lt;int, CIT_FAST&gt;      :: TestFriendOf(t);\n    graph&lt;int, CIT_GPU&gt;       :: TestFriendOf(t);\n    graph&lt;int, CIT_SSE&gt;       :: TestFriendOf(t);\n    graph&lt;int, CIT_NOF_TYPES&gt; :: TestFriendOf(t);\n}\n</code></pre>\n<p>This works on gcc and clang.</p>\n<p>See it live on <a href=\"http://liveworkspace.org/code/f03c0e25a566a4ca44500f4aaecdd354\" rel=\"nofollow\">http://liveworkspace.org/code/f03c0e25a566a4ca44500f4aaecdd354</a></p>\n<p>PS. This doesn't exactly solve any verbosity issues at first sight, but you could make the solution more generic, and inherit from a different 'base-case' instead of the hard-coded one, in which case the boileplate could potentially be compensated for (in case you have many classes that need to befriend families of graph types)</p>\n", "LastActivityDate": "2012-10-24T20:11:06.003", "CommentCount": "1", "CreationDate": "2012-10-24T20:11:06.003", "ParentId": "13055447", "Score": "3", "OwnerUserId": "85371"}});