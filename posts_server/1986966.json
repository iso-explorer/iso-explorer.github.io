post_cb({"1987055": {"ParentId": "1986966", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This is generally <em>not</em> safe, regardless of whether the internal string sequence is stored in memory continuously or not. There's might be many other implementation details related to how the controlled sequence is stored by <code>std::string</code> object, besides the continuity.</p>\n<p>A real practical problem with that might be the following. The controlled sequence of <code>std::string</code> is not required to be stored as a zero-terminated string. However, in practice, many (most?) implementations choose to oversize the internal buffer by 1 and store the sequence as a zero-terminated string anyway because it simplifies the implementation of <code>c_str()</code> method: just return a pointer to the internal buffer and you are done. </p>\n<p>The code you quoted in your question does not make any effort to zero-terminate the data it copied into the internal buffer. Quite possibly it simply doesn't know whether zero-termination is necessary in this implementation of <code>std::string</code>. Quite possibly it relies on the internal buffer being filled with zeros after the call to <code>resize</code>, so the extra character allocated for the zero-terminator by the implementation is conveniently pre-set to zero. All this is implementation detail, meaning that this technique depends of some rather fragile assumptions. </p>\n<p>In other words, in some implementations you'd probably have to use <code>strcpy</code>, not <code>memcpy</code> to force the data into the controlled sequence like that. While in some other implementations you'd have to use <code>memcpy</code> and not <code>strcpy</code>.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2009-12-31T21:02:04.300", "Id": "1987055", "Score": "1", "CreationDate": "2009-12-31T20:46:42.910", "LastActivityDate": "2009-12-31T21:02:04.300"}, "28024825": {"ParentId": "1986966", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It is safe to use. I think most answers were correct once, but the standard changed. Quoting from C++11 standard, <em>basic_string general requirements [string.require]</em>, 21.4.1.5, says:</p>\n<blockquote>\n<p id=\"so_1986966_28024825_0\">The char-like objects in a basic_string object shall be stored contiguously. That is, for any basic_string\n  object s, the identity &amp;*(s.begin() + n) == &amp;*s.begin() + n shall hold for all values of n such that 0\n  &lt;= n &lt; s.size().</p>\n</blockquote>\n<p>A bit before that, it says that all iterators are random access iterators. Both bits support the usage of your question. (Additionally, Stroustrup apparently uses it in his newest book ;) )</p>\n<p>It's not unlikely that this change was done in C++11. I seem to remember that the same guarantee was added then for vector, which also got the very useful <em>data()</em> pointer with that release.</p>\n<p>Hope that helps.</p>\n", "OwnerUserId": "4312669", "LastEditorUserId": "4312669", "LastEditDate": "2015-01-19T12:42:03.933", "Id": "28024825", "Score": "6", "CreationDate": "2015-01-19T12:36:39.960", "LastActivityDate": "2015-01-19T12:42:03.933"}, "1987003": {"ParentId": "1986966", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Readers should note that this question was asked in 2009, when the C++03 Standard was the current publication.  This answer is based on that version of the Standard, in which <code>std::string</code>s are <em>not</em> guaranteed to utilize contiguous storage.  Since this question was not asked in the context of a particular platform (like gcc), I make no assumptions about OP's platform -- in particular, weather or not it utilized contigious storage for the <code>string</code>.</p>\n<p>Legal? Maybe, maybe not.  Safe?  Probably, but maybe not.  Good code?  Well, let's not go there...</p>\n<p>Why not just do:</p>\n<pre><code>std::string s = str;\n</code></pre>\n<p>...or: </p>\n<pre><code>std::string s(str);\n</code></pre>\n<p>...or:</p>\n<pre><code>std::string s;\nstd::copy( &amp;str[0], &amp;str[strLen], std::back_inserter(s));\n</code></pre>\n<p>...or:</p>\n<pre><code>std::string s;\ns.assign( str, strLen );\n</code></pre>\n<p>?</p>\n", "OwnerUserId": "241536", "LastEditorUserId": "241536", "LastEditDate": "2014-02-18T19:07:37.643", "Id": "1987003", "Score": "2", "CreationDate": "2009-12-31T20:32:00.387", "LastActivityDate": "2014-02-18T19:07:37.643"}, "1986974": {"ParentId": "1986966", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>A std::string's allocation is not guaranteed to be contiguous under the C++98/03 standard, but C++11 forces it to be. In practice, neither I nor <a href=\"http://herbsutter.wordpress.com/2008/04/07/cringe-not-vectors-are-guaranteed-to-be-contiguous/\" rel=\"noreferrer\">Herb Sutter</a> know of an implementation that does not use contiguous storage.</p>\n<p>Notice that the <code>&amp;s[0]</code> thing is always guaranteed to work by the C++11 standard, even in the 0-length string case. It would not be guaranteed if you did <code>str.begin()</code> or <code>&amp;*str.begin()</code>, but for <code>&amp;s[0]</code> the standard defines <code>operator[]</code> as:</p>\n<blockquote>\n<p id=\"so_1986966_1986974_0\"><em>Returns</em>: <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>, otherwise a reference to an object of type <code>T</code> with value <code>charT()</code>; the referenced value shall not be modified</p>\n</blockquote>\n<p>Continuing on, <code>data()</code> is defined as:</p>\n<blockquote>\n<p id=\"so_1986966_1986974_1\"><em>Returns:</em> A pointer <code>p</code> such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.</p>\n</blockquote>\n<p>(notice the square brackets at both ends of the range)</p>\n<hr>\n<p><em>Notice</em>: pre-standardization C++0x did not guarantee <code>&amp;s[0]</code> to work with zero-length strings (actually, it was explicitly undefined behavior), and an older revision of this answer explained this; this has been fixed in later standard drafts, so the answer has been updated accordingly.</p>\n</hr>", "OwnerUserId": "54858", "LastEditorUserId": "214671", "LastEditDate": "2016-04-30T12:36:05.513", "Id": "1986974", "Score": "33", "CreationDate": "2009-12-31T20:24:04.253", "LastActivityDate": "2016-04-30T12:36:05.513"}, "1986966": {"CommentCount": "3", "CreationDate": "2009-12-31T20:22:16.267", "PostTypeId": "1", "AcceptedAnswerId": "1986974", "LastEditorUserId": "241536", "LastActivityDate": "2016-04-30T12:36:05.513", "LastEditDate": "2014-02-18T19:03:32.383", "ViewCount": "7881", "FavoriteCount": "8", "Title": "Does \"&s[0]\" point to contiguous characters in a std::string?", "Id": "1986966", "Score": "30", "Body": "<p>I'm doing some maintenance work and ran across something like the following: </p>\n<pre><code>std::string s;\ns.resize( strLength );  \n// strLength is a size_t with the length of a C string in it. \n\nmemcpy( &amp;s[0], str, strLength );\n</code></pre>\n<p>I know using &amp;s[0] would be safe if it was a std::vector, but is this a safe use of std::string?</p>\n", "Tags": "<c++><memcpy><stdstring><c++03>", "OwnerUserId": "14069", "AnswerCount": "6"}, "1986975": {"ParentId": "1986966", "CommentCount": "8", "Body": "<p>Technically, no, since <code>std::string</code> is not required to store its contents contiguously in memory.</p>\n<p>However, in almost all implementations (every implementation of which I am aware), the contents are stored contiguously and this would \"work.\"</p>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "1986975", "Score": "6", "CreationDate": "2009-12-31T20:24:05.223", "LastActivityDate": "2009-12-31T20:24:05.223"}, "1987059": {"ParentId": "1986966", "CommentCount": "2", "Body": "<p>The code might work, but more by luck than judgement, it makes assumptions about the implementation that are not guaranteed.  I suggest determining the validity of the code is irrelevant while it is a pointless over complication that is easily reduced to just:</p>\n<pre><code>std::string s( str ) ;\n</code></pre>\n<p>or if assigning to an existing std::string object, just:</p>\n<pre><code>s = str ;\n</code></pre>\n<p>and then let std::string itself determine how to achieve the result.  If you are going to resort to this sort of nonsense, then you may as well not be using std::string and stick to  since you are reintroducing all the dangers associated with C strings.</p>\n", "OwnerUserId": "168986", "PostTypeId": "2", "Id": "1987059", "Score": "0", "CreationDate": "2009-12-31T20:47:07.123", "LastActivityDate": "2009-12-31T20:47:07.123"}, "bq_ids": {"n4140": {"so_1986966_28024825_0": {"section_id": 1566, "quality": 0.7777777777777778, "length": 14}, "so_1986966_1986974_0": {"section_id": 1617, "quality": 0.6428571428571429, "length": 9}}, "n3337": {"so_1986966_28024825_0": {"section_id": 1561, "quality": 0.7777777777777778, "length": 14}, "so_1986966_1986974_0": {"section_id": 1613, "quality": 0.6428571428571429, "length": 9}}, "n4659": {"so_1986966_1986974_0": {"section_id": 1770, "quality": 0.7142857142857143, "length": 10}}}});