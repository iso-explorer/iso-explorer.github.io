post_cb({"20021292": {"CommentCount": "3", "AcceptedAnswerId": "20021356", "PostTypeId": "1", "LastEditorUserId": "1102119", "CreationDate": "2013-11-16T17:12:43.863", "LastActivityDate": "2014-06-15T23:34:04.020", "LastEditDate": "2013-11-19T04:57:50.590", "ViewCount": "4130", "FavoriteCount": "2", "Title": "What is the type of decltype(this) in C++?", "Id": "20021292", "Score": "25", "Body": "<p>Apparently clang thinks <code>decltype(this)</code> is a pointer to the cv-qualified class, while gcc thinks it is a <em>const reference</em> to a pointer to the cv-qualified class. GCC only thinks <code>decltype(&amp;*this)</code> is a pointer to the cv-qualified class. This has some implications when it is used as the typename for a template. Consider a hypothetical example:</p>\n<pre><code>template&lt;typename T&gt;\nclass MyContainer {\n    /* ... */\n    template&lt;typename ContainerPtr&gt;\n    class MyIterator {\n        ContainerPtr container;\n        /* ... */\n    };\n    auto cbegin() const\n        -&gt; MyIterator&lt;decltype(&amp;*this)&gt; { return { /* ... */ }; }\n    auto cend() const\n        -&gt; MyIterator&lt;decltype(this)&gt; { return { /* ... */ }; }\n};\n</code></pre>\n<p>In this example, one implements a custom container of <code>T</code>. Being a container, it supports iterators. In fact, two kinds of iterators: <code>iterator</code>s and <code>const_iterator</code>s. It would not make sense to duplicate the code for these two, so one could write a template iterator class, taking either a pointer to the original class <code>MyContainer&lt;T&gt; *</code> or a pointer to the const version <code>MyContainer&lt;T&gt; const *</code>.</p>\n<p>When <code>cbegin</code> and <code>cend</code> are used together, gcc errors out, saying it deduced conflicting types, while clang just works fine.</p>\n", "Tags": "<c++><c++11><this><decltype>", "OwnerUserId": "1102119", "AnswerCount": "2"}, "20021356": {"ParentId": "20021292", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Okay, here is what I found in the standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">N3337</a>) though:</p>\n<blockquote>\n<p id=\"so_20021292_20021356_0\"><b>7.1.6.2 Simple type specifiers [dcl.type.simple]</b></p>\n<p id=\"so_20021292_20021356_1\">4 \u00a0 The type denoted by <code>decltype(e)</code> is defined as follows:<br>\n  \u00a0 \u2014 if <code>e</code> is an unparenthesized <i>id-expression</i> or an\n  unparenthesized class member access (5.2.5), <code>decltype(e)</code> is the type\n  of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code>\n  names a set of overloaded functions, the program is ill-formed;<br>\n  \u00a0 \u2014 otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where\n  <code>T</code> is the type of <code>e</code>;<br> \u00a0 \u2014 otherwise, if <code>e</code> is an lvalue,\n  <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;<br> \u00a0 \u2014\n  otherwise, <code>decltype(e)</code> is the type of <code>e</code>.<br> The operand of the\n  <code>decltype</code> specifier is an unevaluated operand (Clause 5).</br></br></br></br></br></p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_20021292_20021356_2\"><b>5.1.1 General [expr.prim.general]</b></p>\n<p id=\"so_20021292_20021356_3\">3 \u00a0 If a declaration declares a member function or member function\n  template of a class <code>X</code>, the expression <code>this</code> is a prvalue of type\n  \u201cpointer to <i>cv-qualifier-seq</i> <code>X</code>\u201d between the optional <i>cv-qualifer-seq</i>\n  and the end of the <i>function-definition</i>, <i>member-declarator</i>, or\n  <i>declarator</i>. It shall not appear before the optional <i>cv-qualifier-seq</i>\n  and it shall not appear within the declaration of a static member\n  function (although its type and value category are defined within a\n  static member function as they are within a non-static member\n  function). \u00a0 [ <i>Note:</i> this is because declaration matching does not occur\n  until the complete declarator is known. \u2014 <i>end note</i> ] Unlike the object\n  expression in other contexts, <code>*this</code> is not required to be of complete\n  type for purposes of class member access (5.2.5) outside the member\n  function body. [ <i>Note:</i> only class members declared prior to the\n  declaration are visible. \u2014 <i>end note</i> ]</p>\n</blockquote>\n<p>The previous reference to \u00a79.3.2 is an error, since that deals with the <em>body</em> of a member function, as pointed out below <a href=\"https://stackoverflow.com/questions/20021292/what-is-the-type-of-decltypethis-in-c/20021356?noredirect=1#comment29898712_20021356\">in a comment by MWid</a>.</p>\n<blockquote id=\"so_20021292_20021356_4\">\n<del>\n<b>9.3.2 The `this` pointer [class.this]</b>\n  \n  1 \u00a0 In the body of a non-static (9.3) member function, the\n  keyword `this` is a prvalue expression whose value is the address of\n  the object for which the function is called. The type of `this` in a\n  member function of a class `X` is `X*`. If the member function is\n  declared `const`, the type of `this` is `const X*`, if the member\n  function is declared `volatile`, the type of `this` is `volatile X*`,\n  and if the member function is declared `const volatile`, the type of\n  `this` is `const volatile X*`.\n  </del>\n</blockquote>\n<p>So it looks like gcc is wrong.</p>\n", "OwnerUserId": "1102119", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:52.967", "Id": "20021356", "Score": "16", "CreationDate": "2013-11-16T17:19:00.097", "LastActivityDate": "2013-11-24T13:16:27.173"}, "20021858": {"ParentId": "20021292", "CommentCount": "1", "Body": "<p><code>this</code> is a <em>prvalue</em>, so <code>decltype(this)</code> should always be plain <code>X*</code> (or <code>X <i>cv</i>*</code> / <code><i>cv</i> X*</code>). The addition of <code>const&amp;</code> seems to be a bug in GCC (tested with g++ 4.8.1), which happens only for a class <em>template</em> (not for a \"plain\" class) and only <em>inside the trailing return type</em> (not inside the body of the member function): <a href=\"http://coliru.stacked-crooked.com/a/ede62afe18375385\">demo</a>. This seems to be fixed in GCC 4.9 (experimental), you can test <a href=\"http://gcc.godbolt.org\">here</a>.</p>\n", "OwnerUserId": "688659", "PostTypeId": "2", "Id": "20021858", "Score": "14", "CreationDate": "2013-11-16T18:04:52.533", "LastActivityDate": "2013-11-16T18:04:52.533"}, "bq_ids": {"n4140": {"so_20021292_20021356_3": {"section_id": 5949, "quality": 0.9156626506024096, "length": 76}, "so_20021292_20021356_4": {"section_id": 5895, "quality": 0.8809523809523809, "length": 37}, "so_20021292_20021356_1": {"section_id": 5440, "quality": 0.9333333333333333, "length": 42}}, "n3337": {"so_20021292_20021356_3": {"section_id": 5719, "quality": 0.9156626506024096, "length": 76}, "so_20021292_20021356_4": {"section_id": 5666, "quality": 0.8809523809523809, "length": 37}, "so_20021292_20021356_1": {"section_id": 5235, "quality": 0.9333333333333333, "length": 42}}, "n4659": {"so_20021292_20021356_3": {"section_id": 7435, "quality": 0.9036144578313253, "length": 75}, "so_20021292_20021356_4": {"section_id": 7378, "quality": 0.8809523809523809, "length": 37}, "so_20021292_20021356_1": {"section_id": 6867, "quality": 0.9333333333333333, "length": 42}}}});