post_cb({"16057690": {"CommentCount": "4", "ViewCount": "1962", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-04-17T10:29:40.813", "LastActivityDate": "2013-07-14T00:24:56.170", "Title": "Confusion about constant expressions", "FavoriteCount": "3", "LastEditDate": "2017-05-23T12:28:07.373", "Id": "16057690", "Score": "13", "Body": "<p>This is some kind of follow-up for <a href=\"https://stackoverflow.com/questions/16023262/unexpected-non-constant-stdinitializer-list\">this topic</a> and deals about a little part of it. As with the previous topic, let's consider that our compiler has <code>constexpr</code> functions for <code>std::initializer_list</code> and <code>std::array</code>. Now, let's go straight to the point.</p>\n<p><a href=\"http://ideone.com/uqNVFs\" rel=\"nofollow noreferrer\">This works</a>:</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;initializer_list&gt;\n\nint main()\n{\n    constexpr std::array&lt;int, 3&gt; a = {{ 1, 2, 3 }};\n    constexpr int a0 = a[0];\n    constexpr int a1 = a[1];\n    constexpr int a2 = a[2];\n    constexpr std::initializer_list&lt;int&gt; b = { a0, a1, a2 };\n\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/OOP0rL\" rel=\"nofollow noreferrer\">This does not</a>:</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;initializer_list&gt;\n\nint main()\n{\n    constexpr std::array&lt;int, 3&gt; a = {{ 1, 2, 3 }};\n    constexpr std::initializer_list&lt;int&gt; b = { a[0], a[1], a[2] };\n\n    return 0;\n}\n</code></pre>\n<p>It crashes with this error:</p>\n<pre><code>error: 'const std::initializer_list&lt;int&gt;{((const int*)(&amp;&lt;anonymous&gt;)), 3u}' is not a constant expression\n</code></pre>\n<p>Even though I read some papers about <code>constexpr</code> and constant expressions meanwhile, this behaviour still does not make any sense for me. How come the first example is considered a valid constant expression and not the second one? I would welcome any explanation so that I can rest in peace afterwards.</p>\n<p><strong>NOTE:</strong> I will precise it right away, Clang will not be able to compile the first snippet since it does not implement the <code>constexpr</code> library additions that are planned for C++14. I used GCC 4.7.</p>\n<p><strong>EDIT:</strong> Ok, here comes the big example to show what is rejected and what is not:</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;initializer_list&gt;\n\nconstexpr int foo = 42;\nconstexpr int bar() { return foo; }\nstruct eggs { int a, b; };\n\nint main()\n{\n    constexpr std::array&lt;int, 3&gt; a = {{ 1, 2, 3 }};\n    constexpr int a0 = a[0];\n    constexpr int a1 = a[1];\n    constexpr int a2 = a[2];\n\n    // From Xeo and Andy tests\n    constexpr std::array&lt;int, 1&gt; a = { bar() }; // OK\n    constexpr std::array&lt;int, 3&gt; b = {{ a[0], a[1], a[2] }}; // OK\n    std::initializer_list&lt;int&gt; b = { a[0], a[1], a[2] }; // OK\n    constexpr std::initializer_list&lt;int&gt; b = { a0, a1, a2 }; // OK\n    constexpr std::initializer_list&lt;int&gt; b = { foo }; // OK\n    constexpr std::initializer_list&lt;int&gt; c = { bar() }; // ERROR\n    constexpr std::initializer_list&lt;int&gt; b = { a[0], a[1], a[2] }; // ERROR\n\n    // From Matheus Izvekov and Daniel Kr\u00fcgler\n    constexpr eggs good = { 1, 2 }; // OK\n    constexpr std::initializer_list&lt;eggs&gt; bad = { { 1, 2 }, { 3, 4 } }; // ERROR\n    constexpr std::initializer_list&lt;eggs&gt; bad2 = { good, good }; // ERROR\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><c++11><compile-time><constexpr><constant-expression>", "OwnerUserId": "1364752", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_16057690_16088912_1": {"section_id": 5425, "quality": 0.6666666666666666, "length": 10}, "so_16057690_16088912_0": {"section_id": 5938, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_16057690_16088912_2": {"section_id": 5946, "quality": 0.9230769230769231, "length": 12}, "so_16057690_16088912_1": {"section_id": 5220, "quality": 1.0, "length": 15}, "so_16057690_16088912_0": {"section_id": 5710, "quality": 0.9523809523809523, "length": 20}, "so_16057690_17635408_0": {"section_id": 5947, "quality": 0.6086956521739131, "length": 14}}, "n4659": {"so_16057690_16088912_2": {"section_id": 7687, "quality": 0.5384615384615384, "length": 7}, "so_16057690_16088912_0": {"section_id": 7422, "quality": 0.9523809523809523, "length": 20}, "so_16057690_17635408_0": {"section_id": 7690, "quality": 0.5652173913043478, "length": 13}}}, "17635408": {"ParentId": "16057690", "CommentCount": "0", "Body": "<p><strong>Your examples are all ill-formed.</strong></p>\n<p><em><strong>tl/dr:</strong> The initializer is non-constant because it refers to a different temporary each time the function is evaluated.</em></p>\n<p>The declaration:</p>\n<pre><code>constexpr std::initializer_list&lt;int&gt; b = { a0, a1, a2 };\n</code></pre>\n<p>creates a temporary array of type <code>const int [3]</code> (C++11 <em>[dcl.init.list]p5</em>), then binds the <code>std::initializer_list&lt;int&gt;</code> object to that temporary as if by binding a reference to it (C++11 <em>[dcl.init.list]p6</em>).</p>\n<p>Now, by C++11 <em>[expr.const]p4</em>,</p>\n<blockquote>\n<p id=\"so_16057690_17635408_0\">For a literal constant expression of array or class type, each subobject [...] shall have been initialized by a constant expression. [...] An <em>address constant expression</em> [...] evaluates to the address of an object with <strong>static storage duration</strong>.</p>\n</blockquote>\n<p>Since <code>b</code> has automatic storage duration, when the <code>std::initializer_list&lt;int&gt;</code> object binds to the <code>const int [3]</code> temporary, the temporary is also given automatic storage duration, so the initialization of <code>b</code> is <em>not</em> a constant expression because it refers to the address of an object that does not have static storage duration. So the declaration of <code>b</code> is ill-formed.</p>\n<p><strong>Why GCC accepts some of the <code>constexpr</code> <code>std::initializer_list</code> objects</strong></p>\n<p>In cases where the initializer is suitably trivial, GCC (and Clang) promote the array to global storage rather than creating a new temporary each time around. However, in GCC, this implementation technique leaks through to the language semantics -- GCC treats the array as having static storage duration, and accepts the initialization (as either an accidental or deliberate extension to the C++11 rules).</p>\n<p><strong>Workaround (Clang only)</strong></p>\n<p>You can make your examples valid by giving the <code>std::initializer_list&lt;int&gt;</code> objects static storage duration:</p>\n<pre><code>static constexpr std::initializer_list&lt;int&gt; b = { a0, a1, a2 };\n</code></pre>\n<p>This in turn gives static storage duration to the array temporary, which makes the initialization be a constant expression.</p>\n<p>Using Clang and libc++ (with <code>constexpr</code> added to libc++'s <code>&lt;array&gt;</code> and <code>&lt;initializer_list&gt;</code> in the appropriate places), this tweak of adding <code>static</code> is sufficient for your examples to be accepted.</p>\n<p>Using GCC, the examples are still rejected, with diagnostics such as:</p>\n<pre><code>&lt;stdin&gt;:21:61: error: \u2018const std::initializer_list&lt;int&gt;{((const int*)(&amp; _ZGRZ4mainE1c0)), 1u}\u2019 is not a constant expression\n</code></pre>\n<p>Here, <code>_ZGRZ4mainE1c0</code> is the mangled name of the lifetime-extended array temporary (with static storage duration), and we can see that GCC is implicitly calling the (private) <code>initializer_list&lt;int&gt;(const int*, size_t)</code> constructor. I am not sure why GCC is still rejecting this.</p>\n", "OwnerUserId": "1041090", "PostTypeId": "2", "Id": "17635408", "Score": "1", "CreationDate": "2013-07-14T00:24:56.170", "LastActivityDate": "2013-07-14T00:24:56.170"}, "16088912": {"ParentId": "16057690", "CommentCount": "3", "Body": "<p>I figured out what is going on here:</p>\n<pre><code> constexpr std::initializer_list&lt;int&gt; b = { a[0], a[1], a[2] };\n</code></pre>\n<p><code>a[0]</code> of type <code>const int&amp;</code> implicitly converts to a temporary of type <code>const int</code>.\nThen g++ converts it to <code>const int*</code> to pass into the <code>initializer_list</code> private constructor.\nIn the last step it takes address of a temporary, so it is not a constant expression.</p>\n<p>The problem is in implicit conversion to const int. Example:</p>\n<pre><code>constexpr int v = 1;\nconst int&amp; r = v; // ok\nconstexpr int&amp; r1 = v; // error: invalid initialization of reference of\n                       // type \u2018int&amp;\u2019 from expression of type \u2018const int\u2019\n</code></pre>\n<p>The same behavior is in clang.</p>\n<p>I think this conversion is legal, nothing says the opposite.</p>\n<p>About <code>const int&amp;</code> to <code>const int</code> conversion, [expr] paragraph 5:</p>\n<blockquote>\n<p id=\"so_16057690_16088912_0\">If an expression initially has the type \u201creference to T\u201d , the type is\n  adjusted to T prior to any further analysis. The expression designates\n  the object or function denoted by the reference, and the expression is\n  an lvalue or an xvalue, depending on the expression.</p>\n</blockquote>\n<p>The result of <code>a[0]</code> expression is the temporary xvalue of type <code>const int</code> in that case.</p>\n<p>About implicit conversions in constexpr initializer, [dcl.constexpr] paragraph 9:</p>\n<blockquote>\n<p id=\"so_16057690_16088912_1\">... Each implicit conversion used in converting the initializer\n  expressions and each constructor call used for the initialization\n  shall be one of those allowed in a constant expression.</p>\n</blockquote>\n<p>About taking address of temporary, [expr.const] paragraph 2:</p>\n<blockquote>\n<p id=\"so_16057690_16088912_2\">...an invocation of a constexpr function with arguments that, when\n  substituted by function invocation substitution, do not\n  produce a constant expression; [ Example:</p>\n<pre><code>constexpr const int* addr(const int&amp; ir) { return &amp;ir; } // OK\nstatic const int x = 5;\nconstexpr const int* xp = addr(x); // OK: (const int*)&amp;(const int&amp;)x is an\n                                   // address contant expression\nconstexpr const int* tp = addr(5); // error, initializer for constexpr variable\n                                   // not a constant expression;\n                                   // (const int*)&amp;(const int&amp;)5 is not a\n                                   // constant expression because it takes\n                                   // the address of a temporary\n</code></pre>\n<p id=\"so_16057690_16088912_3\">\u2014 end example ]</p>\n</blockquote>\n", "OwnerUserId": "2292273", "PostTypeId": "2", "Id": "16088912", "Score": "1", "CreationDate": "2013-04-18T16:54:40.053", "LastActivityDate": "2013-04-18T16:54:40.053"}});