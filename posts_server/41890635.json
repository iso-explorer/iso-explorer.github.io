post_cb({"41902202": {"ParentId": "41890635", "LastEditDate": "2017-01-27T20:15:28.033", "CommentCount": "5", "CreationDate": "2017-01-27T20:08:21.363", "Score": "10", "LastEditorUserId": "2069064", "PostTypeId": "2", "Id": "41902202", "OwnerUserId": "2069064", "Body": "<blockquote>\n<p id=\"so_41890635_41902202_0\">May placement <code>new</code> rely on underlying storage value?</p>\n</blockquote>\n<p>No, it may not. From [dcl.init]:</p>\n<blockquote>\n<p id=\"so_41890635_41902202_1\">If no initializer is specified for an object, the object is default-initialized. When storage for an object\n  with automatic or dynamic storage duration is obtained, the object has an indeterminate value, and if no initialization is performed for the object, that object retains an indeterminate value until that value is replaced (5.18).</p>\n</blockquote>\n<p>Indeterminate value means just that, indeterminate. It does not mean that, in the case of a placement new expression, the previous memory is necessarily maintained. The compiler is allowed to do whatever it wants to the memory - which includes, but is not limited to, nothing. </p>\n<blockquote>\n<p id=\"so_41890635_41902202_2\">Under which circumstances may a constructor rely on the previous value stored in its allocated storage?</p>\n</blockquote>\n<p>The subsequent paragraph in [dcl.init] lists cases where the behavior is <em>not</em> undefined when producing an indeterminate value, but they only have to do with unsigned narrow character types.</p>\n<p>So, under no circumstances.</p>\n", "LastActivityDate": "2017-01-27T20:15:28.033"}, "41890635": {"CommentCount": "7", "ViewCount": "1003", "CreationDate": "2017-01-27T09:29:03.527", "LastActivityDate": "2017-02-02T11:05:53.230", "PostTypeId": "1", "AcceptedAnswerId": "41902202", "FavoriteCount": "2", "Title": "May placement `new` rely on underlying storage value?", "Id": "41890635", "Score": "8", "Body": "<p><em>Let's start with some context.</em></p>\n<p>A custom memory pool was using code similar to the following:</p>\n<pre><code>struct FastInitialization {};\n\ntemplate &lt;typename T&gt;\nT* create() {\n    static FastInitialization const F = {};\n\n    void* ptr = malloc(sizeof(T));\n    memset(ptr, 0, sizeof(T));\n    new (ptr) T(F);\n    return reinterpret_cast&lt;T*&gt;(ptr);\n}\n</code></pre>\n<p>The idea is that when called with <code>FastInitialization</code>, a constructor could assume that the storage is already zero-initialized and therefore only initialize those members who need a different value.</p>\n<p>GCC (6.2 and 6.3, at least) however has an \"interesting\" optimization which kicks in.</p>\n<pre><code>struct Memset {\n    Memset(FastInitialization) { memset(this, 0, sizeof(Memset)); }\n\n    double mDouble;\n    unsigned mUnsigned;\n};\n\nMemset* make_memset() {\n    return create&lt;Memset&gt;();\n}\n</code></pre>\n<p>Compiles down to:</p>\n<pre><code>make_memset():\n        sub     rsp, 8\n        mov     edi, 16\n        call    malloc\n        mov     QWORD PTR [rax], 0\n        mov     QWORD PTR [rax+8], 0\n        add     rsp, 8\n        ret\n</code></pre>\n<p>But:</p>\n<pre><code>struct DerivedMemset: Memset {\n    DerivedMemset(FastInitialization f): Memset(f) {}\n\n    double mOther;\n    double mYam;\n};\n\nDerivedMemset* make_derived_memset() {\n    return create&lt;DerivedMemset&gt;();\n}\n</code></pre>\n<p>Compiles down to:</p>\n<pre><code>make_derived_memset():\n        sub     rsp, 8\n        mov     edi, 32\n        call    malloc\n        mov     QWORD PTR [rax], 0\n        mov     QWORD PTR [rax+8], 0\n        add     rsp, 8\n        ret\n</code></pre>\n<p>That is, only the first 16 bytes of the <code>struct</code>, the part corresponding to its base, have been initialized. Debugging information confirm that the call to <code>memset(ptr, 0, sizeof(T));</code> has been completely elided.</p>\n<p>On the other hand, both ICC and Clang both call <code>memset</code> on the full size, here is Clang's result:</p>\n<pre><code>make_derived_memset():               # @make_derived_memset()\n        push    rax\n        mov     edi, 32\n        call    malloc\n        xorps   xmm0, xmm0\n        movups  xmmword ptr [rax + 16], xmm0\n        movups  xmmword ptr [rax], xmm0\n        pop     rcx\n        ret\n</code></pre>\n<p>So the behavior of GCC and Clang differ, and the question becomes: is GCC right and producing better assembly, or is Clang right and GCC buggy?</p>\n<hr>\n<p>Or, in terms of language lawyering:</p>\n<p><strong>Under which circumstances may a constructor rely on the previous value stored in its allocated storage?</strong></p>\n<p>Note: I assume this only matters with placement <code>new</code>, but I am happy to be shown otherwise.</p>\n</hr>", "Tags": "<c++><optimization><language-lawyer>", "OwnerUserId": "147192", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_41890635_41902202_1": {"section_id": 3291, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_41890635_41902202_1": {"section_id": 4053, "quality": 0.9259259259259259, "length": 25}}}, "41891855": {"ParentId": "41890635", "CommentCount": "2", "CreationDate": "2017-01-27T10:31:34.513", "OwnerUserId": "6394138", "PostTypeId": "2", "Id": "41891855", "Score": "1", "Body": "<p>Both GCC and Clang are correct - leaving the (own) data members of <code>DerivedMemset</code> uninitialized will result in undefined behavior as soon as their values are accessed. Therefore the compiler is given the license to leave - right before the constructor is invoked - any bit pattern at the storage range that will be occupied by those fields.</p>\n", "LastActivityDate": "2017-01-27T10:31:34.513"}});