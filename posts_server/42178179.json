post_cb({"42178347": {"ParentId": "42178179", "CommentCount": "23", "Body": "<p>Yes, it's an aliasing violation to do this. So don't. There's no need to <em>ever</em> use <code>sockaddr_storage</code>; it was a historical mistake. But there are a few safe ways to use it:</p>\n<ol>\n<li><code>malloc(sizeof struct sockaddr_storage)</code>. In this case, the pointed-to memory does not have an effective type until you store something to it.</li>\n<li>As part of a union, explicitly accessing the member you want. But in this case just put the actual <code>sockaddr</code> types you want (<code>in</code> and <code>in6</code> and maybe <code>un</code>) in the union rather than <code>sockaddr_storage</code>.</li>\n</ol>\n<p>Of course in modern programming you should never need to create objects of type <code>struct sockaddr_*</code> <strong>at all</strong>. Simply use <code>getaddrinfo</code> and <code>getnameinfo</code> to translate addresses between string representations and <code>sockaddr</code> objects, and treat the latter as <strong>completely opaque objects</strong>.</p>\n", "OwnerUserId": "379897", "PostTypeId": "2", "Id": "42178347", "Score": "4", "CreationDate": "2017-02-11T16:34:03.140", "LastActivityDate": "2017-02-11T16:34:03.140"}, "42178179": {"CommentCount": "2", "AcceptedAnswerId": "42190913", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-02-11T16:19:36.863", "LastActivityDate": "2017-02-12T17:36:57.673", "LastEditDate": "2017-05-23T12:10:24.450", "ViewCount": "1179", "FavoriteCount": "8", "Title": "will casting around sockaddr_storage and sockaddr_in break strict aliasing", "Id": "42178179", "Score": "9", "Body": "<p>Following my previous <a href=\"https://stackoverflow.com/questions/42176962/fill-sockaddr-storage-struct-with-values-of-sockaddr-in\">question</a>, I'm really curious about this code -</p>\n<pre><code>case AF_INET: \n    {\n        struct sockaddr_in * tmp =\n            reinterpret_cast&lt;struct sockaddr_in *&gt; (&amp;addrStruct);\n        tmp-&gt;sin_family = AF_INET;\n        tmp-&gt;sin_port = htons(port);\n        inet_pton(AF_INET, addr, tmp-&gt;sin_addr);\n    }\n    break;\n</code></pre>\n<p>Before asking this question, I've searched across SO about same topic and have got mix responses about this topic. For example, see <a href=\"https://stackoverflow.com/questions/33319224/casting-between-sockaddr-and-sockaddr-in\">this</a>, <a href=\"https://stackoverflow.com/questions/20130415/casting-sockaddr-storage-as-sockaddr-in-for-inet-ntop\">this</a> and <a href=\"https://stackoverflow.com/questions/18609397/whats-the-difference-between-sockaddr-sockaddr-in-and-sockaddr-in6\">this</a> post which say that it is somehow safe to use this kind of code. Also there's another <a href=\"https://stackoverflow.com/questions/1429645/how-to-cast-sockaddr-storage-and-avoid-breaking-strict-aliasing-rules\">post</a> that says to use unions for such task but again the comments on accepted answer beg to differ.</p>\n<hr>\n<p>Microsoft's <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms740504(v=vs.85).aspx\" rel=\"nofollow noreferrer\">documentation</a> on same structure says -</p>\n<blockquote>\n<p id=\"so_42178179_42178179_0\">Application developers normally use only the ss_family member of the SOCKADDR_STORAGE. The remaining members ensure that the SOCKADDR_STORAGE can contain either an IPv6 or IPv4 address and the structure is padded appropriately to achieve 64-bit alignment. Such alignment enables protocol-specific socket address data structures to access fields within a SOCKADDR_STORAGE structure without alignment problems. With its padding, the SOCKADDR_STORAGE structure is 128 bytes in length.</p>\n</blockquote>\n<p>Opengroup's <a href=\"http://pubs.opengroup.org/onlinepubs/009696699/basedefs/sys/socket.h.html\" rel=\"nofollow noreferrer\">documentation</a> states -</p>\n<blockquote>\n<p id=\"so_42178179_42178179_1\">The  header shall define the sockaddr_storage structure. This structure shall be:</p>\n<p id=\"so_42178179_42178179_2\">Large enough to accommodate all supported protocol-specific address structures</p>\n<p id=\"so_42178179_42178179_3\">Aligned at an appropriate boundary so that pointers to it can be cast as pointers to protocol-specific address structures and used to access the fields of those structures without alignment problems</p>\n</blockquote>\n<p>Man page of <a href=\"http://man7.org/linux/man-pages/man7/socket.7.html\" rel=\"nofollow noreferrer\">socket</a> also says same -</p>\n<blockquote>\n<p id=\"so_42178179_42178179_4\">In addition, the sockets API provides the data type struct sockaddr_storage.  This type is suitable to accommodate all supported domain-specific socket address structures; it is large enough and is aligned properly.  (In particular, it is large enough to hold IPv6 socket addresses.)</p>\n</blockquote>\n<hr>\n<p>I've seen multiple implementation using such casts in both <code>C</code> and <code>C++</code> languages in the wild and now I'm uncertain of the fact which one is right since there are some posts that contradict with above claims - <a href=\"https://stackoverflow.com/questions/37661031/why-does-posix-contradict-the-iso-c-standards\">this</a> and <a href=\"https://stackoverflow.com/questions/39425409/is-it-legal-to-type-cast-pointers-of-different-struct-types-e-g-struct-sockadd\">this</a>.</p>\n<p>So which one is the safe and right way to fill up a <code>sockaddr_storage</code> structure? Are these pointer casts safe? or the <a href=\"https://stackoverflow.com/a/1432959/2648679\">union method</a>? I'm also aware of the <code>getaddrinfo()</code> call but that seems a little complicated for the above task of just filling the structs. There is one other <a href=\"https://stackoverflow.com/a/42177009/2648679\">recommended way with memcpy</a>, is this safe?</p>\n</hr></hr>", "Tags": "<c++><c><linux><sockets><strict-aliasing>", "OwnerUserId": "2648679", "AnswerCount": "2"}, "42190913": {"ParentId": "42178179", "CommentCount": "26", "Body": "<p>C and C++ compilers have become much more sophisticated in the past decade than they were when the <code>sockaddr</code> interfaces were designed, or even when C99 was written.  As part of that, the understood <em>purpose</em> of \"undefined behavior\" has changed.  Back in the day, undefined behavior was usually intended to cover disagreement among <em>hardware</em> implementations as to what the semantics of an operation was.  But nowadays, thanks ultimately to a number of organizations who wanted to stop having to write FORTRAN and could afford to pay compiler engineers to make that happen, undefined behavior is a thing that compilers use to <em>make inferences about the code</em>.  Left shift is a good example: C99 6.5.7p3,4 (rearranged a little for clarity) reads</p>\n<blockquote>\n<p id=\"so_42178179_42190913_0\">The result of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions; vacated bits are filled with zeros.  If the value of [<code>E2</code>] is negative or is\n  greater than or equal to the width of the promoted [<code>E1</code>], the behavior is undefined.</p>\n</blockquote>\n<p>So, for instance, <code>1u &lt;&lt; 33</code> is UB on a platform where <code>unsigned int</code> is 32 bits wide.  The committee made this undefined because different CPU architectures' left-shift instructions do different things in this case: some produce zero consistently, some reduce the shift count modulo the width of the type (x86), some reduce the shift count modulo some larger number (ARM), and at least one historically-common architecture would trap (I don't know which one, but that's why it's undefined and not unspecified).  But nowadays, if you write</p>\n<pre><code>unsigned int left_shift(unsigned int x, unsigned int y)\n{ return x &lt;&lt; y; }\n</code></pre>\n<p>on a platform with 32-bit <code>unsigned int</code>, the compiler, knowing the above UB rule, will <em>infer that <code>y</code> must have a value in the range 0 through 32</em> when the function is called.  It will feed that range into interprocedural analysis, and use it to do things like remove unnecessary range checks in the callers.  If the programmer has reason to think they <em>aren't</em> unnecessary, well, now you begin to see why this topic is such a can of worms.</p>\n<p>For more on this change in the purpose of undefined behavior, please see the LLVM people's three-part essay on the subject (<a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html\" rel=\"noreferrer\">1</a> <a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html\" rel=\"noreferrer\">2</a> <a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html\" rel=\"noreferrer\">3</a>).</p>\n<hr>\n<p>Now that you understand that, I can actually answer your question.</p>\n<p>These are the definitions of <code>struct sockaddr</code>, <code>struct sockaddr_in</code>, and <code>struct sockaddr_storage</code>, after eliding some irrelevant complications:</p>\n<pre><code>struct sockaddr {\n    uint16_t sa_family;\n};\nstruct sockaddr_in { \n    uint16_t sin_family;\n    uint16_t sin_port;\n    uint32_t sin_addr;\n};\nstruct sockaddr_storage {\n    uint16_t ss_family;\n    char __ss_storage[128 - (sizeof(uint16_t) + sizeof(unsigned long))];\n    unsigned long int __ss_force_alignment;\n};\n</code></pre>\n<p>This is poor man's subclassing.  It is a ubiquitous idiom in C.  You define a set of structures that all have the same initial field, which is a code number that tells you which structure you've actually been passed.  Back in the day, everyone expected that if you allocated and filled in a <code>struct sockaddr_in</code>, upcast it to <code>struct sockaddr</code>, and passed it to e.g. <code>connect</code>, the implementation of <code>connect</code> could dereference the <code>struct sockaddr</code> pointer safely to retrieve the <code>sa_family</code> field, learn that it was looking at a <code>sockaddr_in</code>, cast it back, and proceed.  The C standard has always said that dereferencing the <code>struct sockaddr</code> pointer triggers undefined behavior\u2014those rules are unchanged since C89\u2014but everyone expected that it would be safe <em>in this case</em> because it would be the same \"load 16 bits\" instruction no matter which structure you were really working with.  That's why POSIX and the Windows documentation talk about alignment; the people who wrote those specs, back in the 1990s, thought that the primary way this could <em>actually</em> be trouble was if you wound up issuing a misaligned memory access.</p>\n<p>But the text of the standard doesn't say anything about load instructions, nor alignment.  This is what it says (C99 \u00a76.5p7 + footnote):</p>\n<blockquote>\n<p id=\"so_42178179_42190913_1\">An object shall have its stored value accessed only by an lvalue expression that has one of the following types:<sup>73)</sup></p>\n<ul>\n<li>a type compatible with the effective type of the object,</li>\n<li>a qualified version of a type compatible with the effective type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the effective type of the\n  object,</li>\n<li>a type that is the signed or unsigned type corresponding to a qualified version of the\n  effective type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its\n  members (including, recursively, a member of a subaggregate or contained union), or</li>\n<li>a character type.</li>\n</ul>\n<hr>\n<p id=\"so_42178179_42190913_2\"><sup>73)</sup> The intent of this list is to specify those circumstances in which an object may or may not be aliased.</p>\n</hr></blockquote>\n<p><code>struct</code> types are \"compatible\" only with themselves, and the \"effective type\" of a declared variable is its declared type.  So the code you showed...</p>\n<pre><code>struct sockaddr_storage addrStruct;\n/* ... */\ncase AF_INET: \n{\n    struct sockaddr_in * tmp = (struct sockaddr_in *)&amp;addrStruct;\n    tmp-&gt;sin_family = AF_INET;\n    tmp-&gt;sin_port = htons(port);\n    inet_pton(AF_INET, addr, tmp-&gt;sin_addr);\n}\nbreak;\n</code></pre>\n<p>... has undefined behavior, and compilers can make inferences from that, <em>even though</em> naive code generation would behave as expected.  What a modern compiler is likely to infer from this is that the <code>case AF_INET</code> <strong>can never be executed</strong>.  It will delete the entire block as dead code, and hilarity will ensue.</p>\n<hr>\n<p>So how do you work with <code>sockaddr</code> safely?  The shortest answer is \"just use <a href=\"https://linux.die.net/man/3/getaddrinfo\" rel=\"noreferrer\"><code>getaddrinfo</code></a> and <a href=\"https://linux.die.net/man/3/getnameinfo\" rel=\"noreferrer\"><code>getnameinfo</code></a>.\"  They deal with this problem for you.</p>\n<p>But maybe you need to work with an address family, such as <code>AF_UNIX</code>, that <code>getaddrinfo</code> doesn't handle.  In most cases you can just declare a variable of the correct type for the address family, and cast it <em>only</em> when calling functions that take a <code>struct sockaddr *</code></p>\n<pre><code>int connect_to_unix_socket(const char *path, int type)\n{\n    struct sockaddr_un sun;\n    size_t plen = strlen(path);\n    if (plen &gt;= sizeof(sun.sun_path)) {\n        errno = ENAMETOOLONG;\n        return -1;\n    }\n    sun.sun_family = AF_UNIX;\n    memcpy(sun.sun_path, path, plen+1);\n\n    int sock = socket(AF_UNIX, type, 0);\n    if (sock == -1) return -1;\n\n    if (connect(sock, (struct sockaddr *)&amp;sun,\n                offsetof(struct sockaddr_un, sun_path) + plen)) {\n        int save_errno = errno;\n        close(sock);\n        errno = save_errno;\n        return -1;\n    }\n    return sock;\n}\n</code></pre>\n<p>The <em>implementation</em> of <code>connect</code> has to jump through some hoops to make this safe, but that is Not Your Problem.</p>\n<p>Contra the other answer, there <em>is</em> one case where you might want to use <code>sockaddr_storage</code>; in conjunction with <code>getpeername</code> and <code>getnameinfo</code>, in a server that needs to handle both IPv4 and IPv6 addresses.  It is a convenient way to know how big of a buffer to allocate.</p>\n<pre><code>#ifndef NI_IDN\n#define NI_IDN 0\n#endif\nchar *get_peer_hostname(int sock)\n{\n    char addrbuf[sizeof(struct sockaddr_storage)];\n    socklen_t addrlen = sizeof addrbuf;\n\n    if (getpeername(sock, (struct sockaddr *)addrbuf, &amp;addrlen))\n        return 0;\n\n    char *peer_hostname = malloc(MAX_HOSTNAME_LEN+1);\n    if (!peer_hostname) return 0;\n\n    if (getnameinfo((struct sockaddr *)addrbuf, addrlen,\n                    peer_hostname, MAX_HOSTNAME_LEN+1,\n                    0, 0, NI_IDN) {\n        free(peer_hostname);\n        return 0;\n    }\n    return peer_hostname;\n}\n</code></pre>\n<p>(I could just as well have written <code>struct sockaddr_storage addrbuf</code>, but I wanted to emphasize that I never actually need to access the contents of <code>addrbuf</code> directly.)</p>\n<p>A final note: if the BSD folks had defined the sockaddr structures just a <em>little</em> bit differently ...</p>\n<pre><code>struct sockaddr {\n    uint16_t sa_family;\n};\nstruct sockaddr_in { \n    struct sockaddr sin_base;\n    uint16_t sin_port;\n    uint32_t sin_addr;\n};\nstruct sockaddr_storage {\n    struct sockaddr ss_base;\n    char __ss_storage[128 - (sizeof(uint16_t) + sizeof(unsigned long))];\n    unsigned long int __ss_force_alignment;\n};\n</code></pre>\n<p>... upcasts and downcasts would have been perfectly well-defined, thanks to the \"aggregate or union that includes one of the aforementioned types\" rule.\nIf you're wondering how you should deal with this problem in new C code, here you go.</p>\n</hr></hr>", "OwnerUserId": "388520", "PostTypeId": "2", "Id": "42190913", "Score": "8", "CreationDate": "2017-02-12T17:36:57.673", "LastActivityDate": "2017-02-12T17:36:57.673"}, "bq_ids": {"n4140": {"so_42178179_42190913_2": {"section_id": 7239, "quality": 0.9, "length": 9}}, "n3337": {"so_42178179_42190913_2": {"section_id": 6983, "quality": 0.9, "length": 9}}, "n4659": {"so_42178179_42190913_2": {"section_id": 8748, "quality": 0.9, "length": 9}}}});