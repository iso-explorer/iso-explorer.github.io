post_cb({"29440617": {"CommentCount": "4", "AcceptedAnswerId": "29441011", "PostTypeId": "1", "LastEditorUserId": "420683", "CreationDate": "2015-04-03T22:38:23.907", "LastActivityDate": "2015-04-03T23:30:32.623", "LastEditDate": "2015-04-03T23:30:32.623", "ViewCount": "222", "FavoriteCount": "1", "Title": "c++11 array initialization won't call copy constructor", "Id": "29440617", "Score": "1", "Body": "<p>I'm making a little class that uses an array templated on its size. Here's some code...</p>\n<p>.hpp</p>\n<pre><code>template &lt;size_t N&gt;\nclass KeyCombinationListener\n{\npublic:\n    KeyCombinationListener(\n        const std::array&lt;sf::Keyboard::Key, N&gt;&amp; sequence,\n        std::function&lt;void (void)&gt; fn\n        );\n\nprivate:\n    std::array&lt;sf::Keyboard::Key, N&gt;  combo;\n    std::function&lt;void (void)&gt;  callback;\n};\n</code></pre>\n<p>.cc</p>\n<pre><code>template &lt;size_t N&gt;\nKeyCombinationListener&lt;N&gt;::KeyCombinationListener(\n    const array&lt;sf::Keyboard::Key, N&gt;&amp; sequence, function&lt;void (void)&gt; fn\n    ) : combo(sequence), progress{begin(combo)}, callback{fn}\n{\n\n}\n</code></pre>\n<p>In the member initialization of the constructor, I can't use <code>combo{sequence}</code> as the initializer because it only accepts <code>sf::Keyboard::Key</code> types. This makes sense if it's asking for an <code>initializer_list</code>, but this seems strange to me. With other standard containers I can call a copy constructor using {} notation just fine. Is this a quirk with <code>std::array</code>? Or maybe a bug in my clang?</p>\n<p>Just in case it helps, here's my clang version:</p>\n<pre><code>Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)\nTarget: x86_64-pc-linux-gnu\nThread model: posix\nFound candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.9\nFound candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.9.2\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/4.9\nFound candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/4.9.2\nSelected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.9\nCandidate multilib: .;@m64\nSelected multilib: .;@m64\n</code></pre>\n", "Tags": "<c++><c++11><constructor><uniform-initialization><stdarray>", "OwnerUserId": "3411571", "AnswerCount": "1"}, "29441011": {"ParentId": "29440617", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You've encountered a defect in C++: list-initialization from a single element. The behaviour specified in the C++11 and C++14 International Standard is surprising. I'll refer to C++14 below.</p>\n<p>Template instantiations of <code>std::array</code> are aggregates <sup>[array.overview]/2</sup>. Therefore, when initializing <code>std::array</code> objects from a <em>braced-init-list</em>, <em>aggregate-initialization</em> will be performed indiscriminately of the number of initializers <sup>[dcl.init.list]/3.1</sup>. Other container classes cannot be aggregates because of the requirements for certain constructions (e.g. from a pair of iterators).</p>\n<p>Aggregate-initialization initializes (potentially recursively) the data members from the initializers. In your case, it will try to initialize the first data member of <code>std::array&lt;sf::Keyboard::Key, N&gt;</code> from the initializer <code>sequence</code> (which is of the same type). For all implementations of <code>std::array</code> I know, the first data member of <code>std::array</code> is a C-style array. List-initialization will then try to initialize the first element of that array from the original initializer: <code>sequence</code>.</p>\n<p>Example:</p>\n<pre><code>struct aggregate\n{\n    int m[2];\n};\n\naggregate x = {0, 1};\nassert(x.m[0] == 0 &amp;&amp; x.m[1] == 1);\n\naggregate y{x}; // error: cannot convert `aggregate` to `int`\n</code></pre>\n<p>The initialization in the last line will try to initialize <code>y.m[0]</code> from <code>x</code>.</p>\n<hr>\n<p><a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1467\" rel=\"nofollow\">CWG issue 1467</a> describes this and a related issue, list-initializing when there are no initializers. The proposed resolution introduces a (yet another) special case for list-initialization that covers the issue in the OP. Quoting a recent github draft, [dcl.init.list]/3.1</p>\n<blockquote>\n<p id=\"so_29440617_29441011_0\">If <code>T</code> is a class type and the initializer list has a single element of\n  type <em>cv</em> <code>U</code>, where <code>U</code> is <code>T</code> or a class derived from <code>T</code>, the object is\n  initialized from that element (by copy-initialization for\n  copy-list-initialization, or by direct-initialization for\n  direct-list-initialization).</p>\n</blockquote>\n<p>Aggregate-initialization in recent drafts has lower \"priority\" (3.3), that is, will only be performed if the condition above is not met.</p>\n<hr>\n<p>Recent versions of g++ (5.0) and clang++ (3.7.0) implement the proposed resolution even in C++11 mode.</p>\n</hr></hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2015-04-03T23:29:36.693", "Id": "29441011", "Score": "2", "CreationDate": "2015-04-03T23:23:55.503", "LastActivityDate": "2015-04-03T23:29:36.693"}, "bq_ids": {"n4140": {"so_29440617_29441011_0": {"section_id": 3325, "quality": 0.5882352941176471, "length": 10}}, "n3337": {"so_29440617_29441011_0": {"section_id": 3166, "quality": 0.5294117647058824, "length": 9}}, "n4659": {"so_29440617_29441011_0": {"section_id": 4091, "quality": 0.9411764705882353, "length": 16}}}});