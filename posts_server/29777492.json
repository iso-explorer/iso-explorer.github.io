post_cb({"29866102": {"ParentId": "29777492", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>C++ does not guarantee for all types that their objects occupy contiguous bytes of storage [intro.object]/5</p>\n<blockquote>\n<p id=\"so_29777492_29866102_0\">An object of trivially copyable or standard-layout type (3.9) shall\n  occupy contiguous bytes of storage.</p>\n</blockquote>\n<p>And indeed, through virtual base classes, you can create non-contiguous objects in major implementations. I have tried to build an example where a base class subobject of an object <code>x</code> is located <em>before <code>x</code>'s starting address</em>. To visualize this, consider the following graph/table, where the horizontal axis is address space, and the vertical axis is the level of inheritance (level 1 inherits from level 0). Fields marked by <code>dm</code> are occupied by <em>direct</em> data members of the class.</p>\n<pre>\nL | 00 08 16\n--+---------\n1 |    dm\n0 | dm\n</pre>\n<p>This is a usual memory layout when using inheritance. However, the location of a virtual base class subobject is not fixed, since it can be relocated by child classes that also inherit from the same base class virtually. This can lead to the situation that the level 1 (base class sub)object reports that it begins at address 8 and is 16 bytes large. If we naively add those two numbers, we'd think it occupies the address space [8, 24) even though it actually occupies [0, 16).</p>\n<p>If we can create such a level 1 object, then we cannot use <code>memcpy</code> to copy it: <code>memcpy</code> would access memory that does not belong to this object (addresses 16 to 24). In my demo, is caught as a stack-buffer-overflow by clang++'s address sanitizer.</p>\n<p>How to construct such an object? By using multiple virtual inheritance, I came up with an object that has the following memory layout (virtual table pointers are marked as <code>vp</code>). It is composed through four layers of inheritance:</p>\n<pre>\nL  00 08 16 24 32 40 48\n3        dm         \n2  vp dm\n1              vp dm\n0           dm\n</pre>\n<p>The issue described above will arise for the level 1 base class subobject. Its starting address is 32, and it is 24 bytes large (vptr, its own data members and level 0's data members).</p>\n<p>Here's the code for such a memory layout under clang++ and g++ @ coliru:</p>\n<pre><code>struct l0 {\n    std::int64_t dummy;\n};\n\nstruct l1 : virtual l0 {\n    std::int64_t dummy;\n};\n\nstruct l2 : virtual l0, virtual l1 {\n    std::int64_t dummy;\n};\n\nstruct l3 : l2, virtual l1 {\n    std::int64_t dummy;\n};\n</code></pre>\n<p>We can produce a stack-buffer-overflow as follows:</p>\n<pre><code>l3  o;\nl1&amp; so = o;\n\nl1 t;\nstd::memcpy(&amp;t, &amp;so, sizeof(t));\n</code></pre>\n<p>Here's a complete demo that also prints some info about the memory layout:</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n\n#define PRINT_LOCATION() \\\n    std::cout &lt;&lt; std::setw(22) &lt;&lt; __PRETTY_FUNCTION__                   \\\n      &lt;&lt; \" at offset \" &lt;&lt; std::setw(2)                                  \\\n        &lt;&lt; (reinterpret_cast&lt;char const*&gt;(this) - addr)                 \\\n      &lt;&lt; \" ; data is at offset \" &lt;&lt; std::setw(2)                        \\\n        &lt;&lt; (reinterpret_cast&lt;char const*&gt;(&amp;dummy) - addr)               \\\n      &lt;&lt; \" ; naively to offset \"                                        \\\n        &lt;&lt; (reinterpret_cast&lt;char const*&gt;(this) - addr + sizeof(*this)) \\\n      &lt;&lt; \"\\n\"\n\nstruct l0 {\n    std::int64_t dummy;\n\n    void report(char const* addr) { PRINT_LOCATION(); }\n};\n\nstruct l1 : virtual l0 {\n    std::int64_t dummy;\n\n    void report(char const* addr) { PRINT_LOCATION(); l0::report(addr); }\n};\n\nstruct l2 : virtual l0, virtual l1 {\n    std::int64_t dummy;\n\n    void report(char const* addr) { PRINT_LOCATION(); l1::report(addr); }\n};\n\nstruct l3 : l2, virtual l1 {\n    std::int64_t dummy;\n\n    void report(char const* addr) { PRINT_LOCATION(); l2::report(addr); }\n};\n\nvoid print_range(void const* b, std::size_t sz)\n{\n    std::cout &lt;&lt; \"[\" &lt;&lt; (void const*)b &lt;&lt; \", \"\n              &lt;&lt; (void*)(reinterpret_cast&lt;char const*&gt;(b) + sz) &lt;&lt; \")\";\n}\n\nvoid my_memcpy(void* dst, void const* src, std::size_t sz)\n{\n    std::cout &lt;&lt; \"copying from \";\n    print_range(src, sz);\n    std::cout &lt;&lt; \" to \";\n    print_range(dst, sz);\n    std::cout &lt;&lt; \"\\n\";\n}\n\nint main()\n{\n    l3 o{};\n    o.report(reinterpret_cast&lt;char const*&gt;(&amp;o));\n\n    std::cout &lt;&lt; \"the complete object occupies \";\n    print_range(&amp;o, sizeof(o));\n    std::cout &lt;&lt; \"\\n\";\n\n    l1&amp; so = o;\n    l1 t;\n    my_memcpy(&amp;t, &amp;so, sizeof(t));\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/27589eb164690906\">Live demo</a></p>\n<p>Sample output (abbreviated to avoid vertical scrolling):</p>\n<pre>l3::report at offset  0 ; data is at offset 16 ; naively to offset <b>48</b>\nl2::report at offset  0 ; data is at offset  8 ; naively to offset 40\nl1::report at offset 32 ; data is at offset 40 ; naively to offset <b>56</b>\nl0::report at offset 24 ; data is at offset 24 ; naively to offset 32\nthe complete object occupies [0x9f0, 0xa20)\ncopying from [0xa10, 0xa28) to [0xa20, 0xa38)\n</pre>\n<p>Note the two emphasized end offsets.</p>\n", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2015-04-29T01:50:02.430", "Id": "29866102", "Score": "14", "CreationDate": "2015-04-25T13:58:36.193", "LastActivityDate": "2015-04-29T01:50:02.430"}, "29797202": {"ParentId": "29777492", "CommentCount": "0", "Body": "<p>memcpy will copy all the bytes, or in your case swap all the bytes, just fine. An overzealous compiler could take the \"undefined behaviour\" as an excuse to to all kinds of mischief, but most compilers won't do that. Still, it is possible. </p>\n<p>However, after these bytes are copied, the object that you copied them to may not be a valid object anymore. Simple case is a string implementation where large strings allocate memory, but small strings just use a part of the string object to hold characters, and keep a pointer to that. The pointer will obviously point to the other object, so things will be wrong. Another example I have seen was a class with data that was used in very few instances only, so that data was kept in a database with the address of the object as a key. </p>\n<p>Now if your instances contain a mutex for example, I would think that moving that around could be a major problem. </p>\n", "OwnerUserId": "3255455", "PostTypeId": "2", "Id": "29797202", "Score": "3", "CreationDate": "2015-04-22T12:12:23.370", "LastActivityDate": "2015-04-22T12:12:23.370"}, "29777706": {"ParentId": "29777492", "CommentCount": "18", "Body": "<p>Because the standard says so.</p>\n<p>Compilers may assume that non-TriviallyCopyable types are only copied via their copy/move constructors/assignment operators.  This could be for optimization purposes (if some data is private, it could defer setting it until a copy / move occurs).</p>\n<p>The compiler is even free to take your <code>memcpy</code> call and have it <em>do nothing</em>, or format your hard drive.  Why?  Because the standard says so.  And doing nothing is definitely faster than moving bits around, so why not optimize your <code>memcpy</code> to an equally-valid faster program?</p>\n<p>Now, in practice, there are many problems that can occur when you just blit around bits in types that don't expect it.  Virtual function tables might not be set up right.  Instrumentation used to detect leaks may not be set up right.  Objects whose identity includes their location get completely messed up by your code.</p>\n<p>The really funny part is that <code>using std::swap; swap(*ePtr1, *ePtr2);</code> should be able to be compiled down to a <code>memcpy</code> for trivially copyable types by the compiler, and for other types be defined behavior.  If the compiler can prove that copy is just bits being copied, it is free to change it to <code>memcpy</code>.  And if you can write a more optimal <code>swap</code>, you can do so in the namespace of the object in question.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "29777706", "Score": "23", "CreationDate": "2015-04-21T16:12:05.463", "LastActivityDate": "2015-04-21T16:12:05.463"}, "29793321": {"ParentId": "29777492", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Many of these answers mention that <code>memcpy</code> could break invariants in the class, which would cause undefined behaviour later (and which in most cases should be reason enough not to risk it), but that doesn't seem to be what you're really asking.</p>\n<p>One reason for why the <code>memcpy</code> call itself is deemed to be undefined behaviour is to give as much room as possible to the compiler to make optimizations based on the target platform. By having the call itself be UB, the compiler is <em>allowed</em> to do weird, platform-dependent things.</p>\n<p>Consider this (very contrived and hypothetical) example: For a particular hardware platform, there might be several different kinds of memory, with some being faster than others for different operations. There might, for instance, be a kind of special memory that allows extra fast memory copies. A compiler for this (imaginary) platform is therefore allowed to place all <code>TriviallyCopyable</code> types in this special memory, and implement <code>memcpy</code> to use special hardware instructions that only work on this memory.</p>\n<p>If you were to use <code>memcpy</code> on non-<code>TriviallyCopyable</code> objects on this platform, there might be some low-level INVALID OPCODE crash <em>in the <code>memcpy</code> call itself</em>.</p>\n<p>Not the most convincing of arguments, perhaps, but the point is that the standard <em>doesn't forbid it</em>, which is only possible through making the <code>memcpy</code> <em>call</em> UB.</p>\n", "OwnerUserId": "30579", "LastEditorUserId": "30579", "LastEditDate": "2015-04-22T12:52:25.317", "Id": "29793321", "Score": "6", "CreationDate": "2015-04-22T09:32:21.067", "LastActivityDate": "2015-04-22T12:52:25.317"}, "29777492": {"CommentCount": "24", "AcceptedAnswerId": "29802229", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2015-04-21T16:03:25.007", "LastActivityDate": "2017-10-25T11:46:53.903", "LastEditDate": "2016-03-18T11:51:59.097", "ViewCount": "3330", "FavoriteCount": "10", "Title": "Why would the behavior of std::memcpy be undefined for objects that are not TriviallyCopyable?", "Id": "29777492", "Score": "60", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/string/byte/memcpy\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/string/byte/memcpy</a>:</p>\n<blockquote>\n<p id=\"so_29777492_29777492_0\">If the objects are not <a href=\"http://en.cppreference.com/w/cpp/concept/TriviallyCopyable\" rel=\"noreferrer\">TriviallyCopyable</a> (e.g. scalars, arrays, C-compatible structs), the behavior is undefined.</p>\n</blockquote>\n<p>At my work, we have used <code>std::memcpy</code> for a long time to bitwise swap objects that are not TriviallyCopyable using:</p>\n<pre><code>void swapMemory(Entity* ePtr1, Entity* ePtr2)\n{\n   static const int size = sizeof(Entity); \n   char swapBuffer[size];\n\n   memcpy(swapBuffer, ePtr1, size);\n   memcpy(ePtr1, ePtr2, size);\n   memcpy(ePtr2, swapBuffer, size);\n}\n</code></pre>\n<p>and never had any issues.</p>\n<p>I understand that it is trivial to abuse <code>std::memcpy</code> with non-TriviallyCopyable objects and cause undefined behavior downstream. However, my question:</p>\n<p>Why would the behavior of <code>std::memcpy</code> itself be undefined when used with non-TriviallyCopyable objects? Why does the standard deem it necessary to specify that?</p>\n<p><strong>UPDATE</strong></p>\n<p>The contents of <a href=\"http://en.cppreference.com/w/cpp/string/byte/memcpy\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/string/byte/memcpy</a> have been modified in response to this post and the answers to the post. The current description says:</p>\n<blockquote>\n<p id=\"so_29777492_29777492_1\">If the objects are not <a href=\"http://en.cppreference.com/w/cpp/concept/TriviallyCopyable\" rel=\"noreferrer\">TriviallyCopyable</a> (e.g. scalars, arrays, C-compatible structs), the behavior is undefined unless the program does not depend on the effects of the destructor of the target object (which is not run by <code>memcpy</code>) and the lifetime of the target object (which is ended, but not started by <code>memcpy</code>) is started by some other means, such as placement-new.</p>\n</blockquote>\n<p><strong>PS</strong></p>\n<p>Comment by @Cubbi:</p>\n<blockquote>\n<p id=\"so_29777492_29777492_2\">@RSahu if something guarantees UB downstream, it renders the entire program undefined. But I agree that it appears to be possible to skirt around UB in this case and modified cppreference accordingly. </p>\n</blockquote>\n", "Tags": "<c++><c++11><language-lawyer><memcpy><object-lifetime>", "OwnerUserId": "434551", "AnswerCount": "9"}, "29778176": {"ParentId": "29777492", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It is easy enough to construct a class where that <code>memcpy</code>-based <code>swap</code> breaks:</p>\n<pre><code>struct X {\n    int x;\n    int* px; // invariant: always points to x\n    X() : x(), px(&amp;x) {}\n    X(X const&amp; b) : x(b.x), px(&amp;x) {}\n    X&amp; operator=(X const&amp; b) { x = b.x; return *this; }\n};\n</code></pre>\n<p><code>memcpy</code>ing such object breaks that invariant.</p>\n<p>This is similar to how the standard file and string streams are implemented. The streams eventually derive from <code>std::basic_ios</code> which contains a pointer to <code>std::basic_streambuf</code>. The streams also contain the specific buffer as a member (or base class sub-object), to which that pointer in <code>std::basic_ios</code> points to.</p>\n", "OwnerUserId": "412080", "LastEditorUserId": "412080", "LastEditDate": "2017-10-25T11:46:53.903", "Id": "29778176", "Score": "22", "CreationDate": "2015-04-21T16:35:16.237", "LastActivityDate": "2017-10-25T11:46:53.903"}, "39021760": {"ParentId": "29777492", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>What I can perceive here is that -- for some practical applications -- the C++ Standard <em>may</em> be to restrictive, or rather, not permittive enough.</p>\n<p>As shown in other answers <code>memcpy</code> breaks down quickly for \"complicated\" types, but IMHO, it actually <em>should</em> work for Standard Layout Types as long as the <code>memcpy</code> doesn't break what the defined copy-operations and destructor of the Standard Layout type do. (Note that a even TC class is <em>allowed</em> to have a non-trivial constructor.) The standard only explicitly calls out TC types wrt. this, however.</p>\n<p>A recent draft quote (N3797):</p>\n<blockquote>\n<p id=\"so_29777492_39021760_0\">3.9 Types</p>\n<p id=\"so_29777492_39021760_1\">...</p>\n<p id=\"so_29777492_39021760_2\"><strong>2</strong> For any object (other than a base-class subobject) of trivially\n  copyable type T, whether or not the object holds a valid value of type\n  T, the underlying bytes (1.7) making up the object can be copied into\n  an array of char or unsigned char. If the content of the array of char\n  or unsigned char is copied back into the object, the object shall\n  subsequently hold its original value. [ Example:</p>\n<pre><code>  #define N sizeof(T)\n  char buf[N];        T obj; // obj initialized to its original value\n  std::memcpy(buf, &amp;obj, N); // between these two calls to std::memcpy,       \n                             // obj might be modified         \n  std::memcpy(&amp;obj, buf, N); // at this point, each subobject of obj of scalar type\n                             // holds its original value \n</code></pre>\n<p id=\"so_29777492_39021760_3\">\u2014end example ]</p>\n<p id=\"so_29777492_39021760_4\"><strong>3</strong> For any trivially copyable type T, if two pointers to T point to\n  distinct T objects obj1 and obj2, where neither obj1 nor obj2 is a\n  base-class subobject, if the underlying bytes (1.7) making up obj1 are\n  copied into obj2, obj2 shall subsequently hold the same value as obj1.\n  [ Example:        </p>\n<pre><code>T* t1p;\nT* t2p;       \n     // provided that t2p points to an initialized object ...         \nstd::memcpy(t1p, t2p, sizeof(T));  \n     // at this point, every subobject of trivially copyable type in *t1p contains        \n     // the same value as the corresponding subobject in *t2p\n</code></pre>\n<p id=\"so_29777492_39021760_5\">\u2014end example ]</p>\n</blockquote>\n<p>The standard here talks about <a href=\"http://en.cppreference.com/w/cpp/concept/TriviallyCopyable\" rel=\"nofollow noreferrer\"><strong>trivially copyable</strong></a> types, but as <a href=\"https://stackoverflow.com/a/29866102/321013\">was observed</a> by @dyp above, there are also <a href=\"http://en.cppreference.com/w/cpp/concept/StandardLayoutType\" rel=\"nofollow noreferrer\"><strong>standard layout types</strong></a> that do not, as far as I can see, necessarily overlap with Trivially Copyable types.</p>\n<p>The standard says:</p>\n<blockquote>\n<p id=\"so_29777492_39021760_6\">1.8 The C++ object model</p>\n<p id=\"so_29777492_39021760_7\">(...)</p>\n<p id=\"so_29777492_39021760_8\"><strong>5</strong> (...) An object of trivially copyable or standard-layout type (3.9) shall occupy contiguous bytes of storage.</p>\n</blockquote>\n<p>So what I see here is that:</p>\n<ul>\n<li>The standard says nothing about non Trivially Copyable types wrt. <code>memcpy</code>. (as already mentioned several times here)</li>\n<li>The standard has a separate concept for Standard Layout types that occupy contiguous storage.</li>\n<li>The standard <strong>does not</strong> explicitly allow nor disallow using <code>memcpy</code> on objects of Standard Layout that are <em>not</em> Trivially Copyable.</li>\n</ul>\n<p>So it does not seem to be <em>explicitly</em> called out UB, but it certainly also isn't what is referred to as <a href=\"https://stackoverflow.com/a/2397995/321013\"><em>unspecified behavior</em></a>, so one could conclude what @underscore_d did in the comment to the accepted answer:</p>\n<blockquote>\n<p id=\"so_29777492_39021760_9\">(...) You can't just say \"well, it\n  wasn't explicitly called out as UB, therefore it's defined\n  behaviour!\", which is what this thread seems to amount to. N3797 3.9\n  points 2~3 do not define what memcpy does for non-trivially-copyable\n  objects, so (...) [t]hat's pretty much functionally\n  equivalent to UB in my eyes as both are useless for writing reliable, i.e. portable code</p>\n</blockquote>\n<p><em>I personally</em> would conclude that it amounts to UB as far as portability goes (oh, those optimizers), but I think that with some hedging and knowledge of the concrete implementation, one can get away with it. (Just make sure it's worth the trouble.)</p>\n<hr>\n<p>Side Note: I also think that the standard really should explicitly incorporate Standard Layout type semantics into the whole <code>memcpy</code> mess, because it's a valid and useful usecase to do bitwise copy of non Trivially Copyable objects, but that's beside the point here.</p>\n<p>Link: <a href=\"https://stackoverflow.com/questions/39026871/can-i-use-memcpy-to-write-to-multiple-adjacent-standard-layout-sub-objects\">Can I use memcpy to write to multiple adjacent Standard Layout sub-objects?</a></p>\n</hr>", "OwnerUserId": "321013", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:54.700", "Id": "39021760", "Score": "0", "CreationDate": "2016-08-18T15:11:32.363", "LastActivityDate": "2016-08-18T23:20:45.107"}, "29793912": {"ParentId": "29777492", "CommentCount": "1", "Body": "<p>Another reason that <code>memcpy</code> is UB (apart from what has been mentioned in the other answers - it might break invariants later on) is that it is very hard for the standard to say exactly <em>what would happen</em>.</p>\n<p>For non-trivial types, the standard says very little about how the object is laid out in memory, in which order the members are placed, where the vtable pointer is, what the padding should be, etc. The compiler has huge amounts of freedom in deciding this.</p>\n<p>As a result, even if the standard wanted to allow <code>memcpy</code> in these \"safe\" situations, it would be impossible to state what situations are safe and which aren't, or when exactly the real UB would be triggered for unsafe cases.</p>\n<p>I suppose that you could argue that the effects should be implementation-defined or unspecified, but I'd personally feel that would be both digging a bit too deep into platform specifics and giving a little bit too much legitimacy to something that in the general case is rather unsafe.</p>\n", "OwnerUserId": "30579", "PostTypeId": "2", "Id": "29793912", "Score": "2", "CreationDate": "2015-04-22T09:55:05.323", "LastActivityDate": "2015-04-22T09:55:05.323"}, "29777728": {"ParentId": "29777492", "PostTypeId": "2", "CommentCount": "12", "Body": "<blockquote>\n<p id=\"so_29777492_29777728_0\">Why would the behavior of <code>std::memcpy</code> itself be undefined when used with non-TriviallyCopyable objects?</p>\n</blockquote>\n<p>It's not! However, once you copy the underlying bytes of one object of a non-trivially copyable type into another object of that type, <strong>the target object is not alive</strong>. We destroyed it by reusing its storage, and haven't revitalized it by a constructor call.  </p>\n<p>Using the target object - calling its member functions, accessing its data members - is clearly undefined<sup>[basic.life]/6</sup>, and so is a subsequent, implicit destructor call<sup>[basic.life]/4</sup> for target objects having automatic storage duration. Note how <strong>undefined behavior is retrospective</strong>. [intro.execution]/5: </p>\n<blockquote>\n<p id=\"so_29777492_29777728_1\">However, if any such execution contains an undefined operation, this\n  International Standard places no requirement on the implementation\n  executing that program with that input (<strong>not even with regard to\n  operations preceding the first undefined operation</strong>).</p>\n</blockquote>\n<p>If an implementation spots how an object is dead and necessarily subject to further operations that are undefined, ... it may react by altering your programs semantics. From the <code>memcpy</code> call onward. And this consideration gets very practical once we think of optimizers and certain assumptions that they make. </p>\n<p>It should be noted that standard libraries are able and allowed to optimize certain standard library algorithms for trivially copyable types, though. <strong><code>std::copy</code> on pointers to trivially copyable types usually calls <code>memcpy</code> on the underlying bytes. So does <code>swap</code></strong>.<br>\nSo simply stick to using normal generic algorithms and let the compiler do any appropriate low-level optimizations - this is partly what the idea of a trivially copyable type was invented for in the first place: Determining the legality of certain optimizations. Also, this avoids hurting your brain by having to worry about contradictory and underspecified parts of the language.</br></p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-10-28T09:47:06.093", "Id": "29777728", "Score": "32", "CreationDate": "2015-04-21T16:12:54.390", "LastActivityDate": "2015-10-28T09:47:06.093"}, "bq_ids": {"n4140": {"so_29777492_39021760_8": {"section_id": 5794, "quality": 1.0, "length": 9}, "so_29777492_39021760_2": {"section_id": 7200, "quality": 0.9523809523809523, "length": 40}, "so_29777492_29866102_0": {"section_id": 5794, "quality": 1.0, "length": 9}, "so_29777492_39021760_4": {"section_id": 7201, "quality": 0.9375, "length": 30}, "so_29777492_29777728_1": {"section_id": 5801, "quality": 0.95, "length": 19}}, "n3337": {"so_29777492_39021760_8": {"section_id": 5567, "quality": 1.0, "length": 9}, "so_29777492_39021760_2": {"section_id": 6944, "quality": 0.9523809523809523, "length": 40}, "so_29777492_29866102_0": {"section_id": 5567, "quality": 1.0, "length": 9}, "so_29777492_39021760_4": {"section_id": 6945, "quality": 0.9375, "length": 30}, "so_29777492_29777728_1": {"section_id": 5574, "quality": 0.95, "length": 19}}, "n4659": {"so_29777492_39021760_8": {"section_id": 7253, "quality": 1.0, "length": 9}, "so_29777492_29866102_0": {"section_id": 7253, "quality": 1.0, "length": 9}, "so_29777492_39021760_2": {"section_id": 8709, "quality": 0.8809523809523809, "length": 37}, "so_29777492_39021760_4": {"section_id": 8710, "quality": 0.9375, "length": 30}, "so_29777492_29777728_1": {"section_id": 7260, "quality": 0.95, "length": 19}}}, "29802229": {"ParentId": "29777492", "CommentCount": "3", "Body": "<p>It turns out that the standard does not say anything about the behavior of <code>std::memcpy</code> for objects that are not TriviallyCopyable. The contents of <a href=\"http://en.cppreference.com/w/cpp/string/byte/memcpy\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/string/byte/memcpy</a> have been modified in response to the original post and the answers to the post. The current description says:</p>\n<blockquote>\n<p id=\"so_29777492_29802229_0\">If the objects are not TriviallyCopyable (e.g. scalars, arrays, C-compatible structs), the behavior is undefined unless the program does not depend on the effects of the destructor of the target object (which is not run by memcpy) and the lifetime of the target object (which is ended, but not started by memcpy) is started by some other means, such as placement-new.</p>\n</blockquote>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "29802229", "Score": "-2", "CreationDate": "2015-04-22T15:29:01.457", "LastActivityDate": "2015-04-22T15:29:01.457"}});