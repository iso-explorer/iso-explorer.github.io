post_cb({"27901673": {"ParentId": "27901367", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In this declaration</p>\n<pre><code>p_to_array p2 = new arr; // incompatible types \n</code></pre>\n<p>type of initializer <code>new arr;</code> does not correspond to the type of variable <code>p2</code></p>\n<p>The type of initializer is <code>int *</code> that is the initializer is pointer to the initial element of the allocated array. The type of variable <code>p2</code> is <code>int (*p_to_array)[80]</code> according to the typedef definition.</p>\n<p>There is no implicit conversion from type <code>int *</code> to type <code>int (*p_to_array)[80]</code> . So the compiler issues an error.</p>\n<p>The correct declaration could look for example the following way</p>\n<pre><code>p_to_array p2 = new arr[1];\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2015-01-12T12:15:51.433", "Id": "27901673", "Score": "1", "CreationDate": "2015-01-12T12:09:08.627", "LastActivityDate": "2015-01-12T12:15:51.433"}, "27902613": {"ParentId": "27901367", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>You can either use the array syntax or a typedef-name to allocate arrays with <code>new</code> - both is allowed and equivalent according to [expr.new]/5:</p>\n<blockquote>\n<p id=\"so_27901367_27902613_0\">When the allocated object is an array (that is, the\n  <em>noptr-new-declarator</em> syntax is used or <strong>the <em>new-type-id</em> or <em>type-id</em>\n  denotes an array type</strong>), the <em>new-expression</em> yields <strong>a pointer to the\n  initial element (if any) of the array</strong>.</p>\n</blockquote>\n<p>As you can see, for arrays, solely a pointer to the initial element is given; Not a pointer to the array object itself. Thus the type yielded is <code>int*</code>, not <code>int (*)[N]</code>.</p>\n<p>The reason why a pointer to the initial element is returned is quite simple: It is the pointer that you want to work with.<br>\nWe want to write</br></p>\n<pre><code>auto p = new int[50];\n// Or\nint* p = new int[50];\n</code></pre>\n<p>So as to be able to use normal subscripting:</p>\n<pre><code>p[49] = 0xDEADBEEF;\n</code></pre>\n<p>That would be nonsensical with <code>p</code> if it was of type <code>int(*)[50]</code> pointing to the array object, because the subscript would add 49*50*4 to the address, not just 49*4 - because of subscript semantics and pointer arithmetics.<br>\nWe would have to either use two subscripts:</br></p>\n<pre><code>p[0][49] = ...;\n</code></pre>\n<p>Which is horrific and unnecessarily redundant. Or we could use a cast:</p>\n<pre><code>int* p = static_cast&lt;int*&gt;(new int[50]); // Or with auto\n</code></pre>\n<p>But that is ugly too.<br>\nTo avoid such hassles, this rule was introduced.</br></p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-01-12T15:34:41.543", "Id": "27902613", "Score": "4", "CreationDate": "2015-01-12T13:01:28.553", "LastActivityDate": "2015-01-12T15:34:41.543"}, "27901627": {"ParentId": "27901367", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><em>I might be totally wrong about this: (i.e. this is little more than an educated guess)</em></p>\n<pre><code>new arr;\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code>new int[80];\n</code></pre>\n<p>which by language rules returns <code>int*</code>.</p>\n<hr>\n<p>From cppreference.com: (thanks to @interjay for pointing out I actually cited the irrelevant part)</p>\n<blockquote>\n<p id=\"so_27901367_27901627_0\">The new-expression returns a prvalue pointer to the constructed object or, if an array of objects was constructed, a pointer to the initial element of the array.</p>\n</blockquote>\n<p>My understanding of that is that when allocating an array, the <code>new[]</code> form will be picked. The only thing your example changes is the syntax; it doesn't make the language treat arrays as non-arrays (regular objects).</p>\n</hr>", "OwnerUserId": "752976", "LastEditorUserId": "752976", "LastEditDate": "2015-01-12T12:24:21.833", "Id": "27901627", "Score": "6", "CreationDate": "2015-01-12T12:07:02.363", "LastActivityDate": "2015-01-12T12:24:21.833"}, "bq_ids": {"n4140": {"so_27901367_27902613_0": {"section_id": 6086, "quality": 1.0, "length": 17}, "so_27901367_27901627_0": {"section_id": 6082, "quality": 0.6, "length": 9}}, "n3337": {"so_27901367_27902613_0": {"section_id": 5854, "quality": 1.0, "length": 17}, "so_27901367_27901627_0": {"section_id": 5850, "quality": 0.6, "length": 9}}, "n4659": {"so_27901367_27902613_0": {"section_id": 7582, "quality": 1.0, "length": 17}, "so_27901367_27901627_0": {"section_id": 7578, "quality": 0.6, "length": 9}}}, "27901367": {"CommentCount": "3", "ViewCount": "594", "CreationDate": "2015-01-12T11:52:49.917", "LastActivityDate": "2015-01-12T15:34:41.543", "Title": "Dynamic array allocation", "FavoriteCount": "1", "PostTypeId": "1", "Id": "27901367", "Score": "7", "Body": "<p>I'm wondering why new doesn't seem to retain the array information and just returns an int*:   </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntypedef int (*p_to_array)[80];\ntypedef int arr[80];\n\n\n\n\nint main() \n{\n   arr a;\n   p_to_array p = &amp;a;  //fine\n\n   p_to_array p2 = new arr; // incompatible types \n\n   return 0;\n}\n</code></pre>\n", "Tags": "<c++><arrays>", "OwnerUserId": "4258454", "AnswerCount": "3"}});