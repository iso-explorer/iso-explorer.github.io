post_cb({"bq_ids": {"n4140": {"so_29614410_29615191_1": {"section_id": 456, "quality": 0.9473684210526315, "length": 36}}, "n3337": {"so_29614410_29615191_1": {"section_id": 447, "quality": 0.9473684210526315, "length": 36}}, "n4659": {"so_29614410_29615191_1": {"section_id": 479, "quality": 0.9473684210526315, "length": 36}}}, "29615191": {"ParentId": "29614410", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The problem is that you are confusing <code>is_move_constructible</code> and \"has a move constructor\". <code>is_move_constructible&lt;T&gt;</code> doesn't test whether T has a move constructor. It tests whether <code>T</code> can be constructed from an rvalue of type <code>T</code>. And <code>const T&amp;</code> can bind to a <code>T</code> rvalue.</p>\n<p>What you are seeing is the autogenerated <em>copy</em> constructor <code>T(const T&amp;)</code> doing its work - and failing miserably. </p>\n<blockquote>\n<p id=\"so_29614410_29615191_0\">I would expect that neither a move constructor nor a copy constructor should be auto-generated.</p>\n</blockquote>\n<p>Your link talks about the move constructor. It doesn't talk about the copy constructor, which is always implicitly declared if you don't declare it.</p>\n<p>Now, if you declared a move operation, the implicitly declared copy constructor would be defined as deleted, but you didn't do that, so it's defined as defaulted and performs a memberwise copy. [class.copy]/p7:</p>\n<blockquote>\n<p id=\"so_29614410_29615191_1\">If the class definition does not explicitly declare a copy\n  constructor, one is declared implicitly. If the class definition\n  declares a move constructor or move assignment operator, the\n  implicitly declared copy constructor is defined as deleted; otherwise,\n  it is defined as defaulted (8.4). The latter case is deprecated if the\n  class has a user-declared copy assignment operator or a user-declared\n  destructor.</p>\n</blockquote>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-04-13T21:43:07.070", "Id": "29615191", "Score": "7", "CreationDate": "2015-04-13T21:11:57.307", "LastActivityDate": "2015-04-13T21:43:07.070"}, "29614410": {"CommentCount": "15", "AcceptedAnswerId": "29615191", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-04-13T20:24:09.877", "LastActivityDate": "2015-04-13T21:43:07.070", "LastEditDate": "2017-05-23T10:26:47.570", "ViewCount": "277", "FavoriteCount": "0", "Title": "Autogenerated move constructors causing illegal behavior", "Id": "29614410", "Score": "6", "Body": "<p>I asked <a href=\"https://stackoverflow.com/q/29504070/1858225\">a question about move constructors</a> for which I haven't accepted an answer yet because I'm feeling more confused about certain aspects of the question even as I'm starting to get a grip on others. In particular, I've found a surprising case in which both g++ and clang++ generate incorrect move-constructors.</p>\n<h1>Question summary</h1>\n<ul>\n<li>g++ and clang++ apparently violate the rule that move-constructors are not generated when destructors are explicitly defined; why? Is this a bug, or am I misunderstanding what's going on?</li>\n<li>For correctness, these (possibly-illegal) move constructors should invalidate RHS pointer members, but they don't. Why not?</li>\n<li>It appears that the only way to avoid the unwanted behavior is to explicitly define a <em>correct</em> move constructor for every class that uses <code>delete</code> in its destructor. Does the Qt library (version 5.4) do this?</li>\n</ul>\n<h1>Part 1: Illegally auto-generated constructors?</h1>\n<p>Consider the following code:</p>\n<pre><code>class NoMove\n{\n  public:\n    ~NoMove() {}\n};\nint main()\n{\n  std::cout &lt;&lt; \"NoMove move-constructible? \" &lt;&lt;\n    std::is_move_constructible&lt;NoMove&gt;::value &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Compiled with both <code>g++</code> 4.9.2 and <code>clang++</code> 3.5.1, this code prints:</p>\n<pre><code>NoMove move-constructible? 1\n</code></pre>\n<p>...But since <code>NoMove</code> has an explicitly defined destructor, I would expect that <a href=\"https://stackoverflow.com/q/8283589/1858225\"><em>neither</em> a move constructor nor a copy constructor should be auto-generated</a>. Note that the unexpected constructor generation is not due to the fact that the destructor is trivial; I get the same behavior when the destructor <code>delete[]</code>s an array (!!), and I am even able to compile code that <em>requires</em> a valid move constructor (!!!!!). (See example below.) What's going on here? Is it legal to auto-generate a move constructor here, and if so, why?</p>\n<h1>Part 2: (Possibly illegal) auto-generated constructors causing undefined behavior?</h1>\n<p>It appears that providing safe move constructors when <code>delete</code> is involved <a href=\"https://stackoverflow.com/a/9026436/1858225\">is fairly simple</a>, but I just want to make sure I understand: when a class contains a pointer member and <em>owns</em> the underlying data, is there <em>any</em> case in which it wouldn't be correct and sufficient for the move constructor to invalidate the RHS pointer after setting the destination pointer to the old value?</p>\n<p>Consider the following example, which is similar to the <code>NoMove</code> example above and is based on my <a href=\"https://stackoverflow.com/q/29504070/1858225\">original question</a>:</p>\n<pre><code>class DataType\n{\n  public:\n    DataType()\n    {\n      val = new int[35];\n    }\n    ~DataType()\n    {\n      delete[] val;\n    }\n  private:\n    int* val;\n};\n\nclass Marshaller\n{\n  public:\n    Marshaller()=default;\n    DataType toDataType() &amp;&amp;\n    {\n      return std::move(data);\n    }\n  private:\n    DataType data;\n};\n\nvoid DoMarshalling()\n{\n  Marshaller marshaller;\n  // ... do some marshalling...\n  DataType marshalled_data{std::move(marshaller).toDataType()};\n}\n</code></pre>\n<p>This compiles just fine--showing that, yes, <code>DataType</code> has an auto-generated move constructor. And of course, when run, it causes a double-deletion error.</p>\n<p>Now, this would be okay, <em>if</em> the auto-generated move constructor invalidated the RHS pointer. So, if it's okay to auto-generate a move constructor here, why isn't that done <em>safely</em>? The move constructor that makes this work is simply:</p>\n<pre><code>DataType(DataType&amp;&amp; rhs) :\n  val{rhs.val}\n{\n  rhs.val = nullptr;\n}\n</code></pre>\n<p>(Right? Am I missing anything? Should it perhaps be <code>val{std::move(rhs.val)}</code>?)</p>\n<p>This seems like it would be a perfectly safe function to auto-generate; the compiler <em>knows</em> that <code>rhs</code> is an r-value because the function prototype says so, and therefore it's entirely acceptable to modify it. So even if <code>DataType</code>'s destructor <em>didn't</em> <code>delete[] val</code>, it seems like there wouldn't be any reason <em>not</em> to invalidate <code>rhs</code> in the auto-generated version, except, I suppose, for the fact that this leads to a trivial performance hit.</p>\n<p>So if the compiler is auto-generating this method--which, again, it <em>shouldn't</em>, especially since we can just as easily get this exact behavior from standard library code using <code>unique_ptr</code>-- <em>why is it auto-generating it <strong>incorrectly</strong>?</em></p>\n<h1>Part 3: Avoiding this behavior in Qt (especially <code>QByteArray</code> in Qt 5.4)</h1>\n<p>Finally, a (hopefully) easy question: do Qt 5.4's heap-allocating classes such as <code>QByteArray</code> (which is what I'm actually using as the <code>DataType</code> in my original question) have correctly implemented move constructors, invalidating any moved-from owning pointer(s)?</p>\n<p>I wouldn't even bother to ask, because Qt seems pretty solid and I haven't seen any double-deletion errors <em>yet</em>, but given that I was taken off guard by these incorrect compiler-generated move constructors, I'm concerned that it's quite easy to end up with incorrect move constructors in an otherwise-well-implemented library.</p>\n<p>Relatedly, what about Qt libraries written before <code>C++11</code> that don't have explicit move-constructors? If I can accidentally coerce an auto-generated move constructor that behaves erroneously in this case, does anyone know if compiling, say, Qt 3 with a C++11-compliant compiler causes undefined destruction behavior in use-cases like this?</p>\n", "Tags": "<c++><qt><pointers><c++11><move-semantics>", "OwnerUserId": "1858225", "AnswerCount": "1"}});