post_cb({"16071154": {"CommentCount": "1", "AcceptedAnswerId": "16071220", "PostTypeId": "1", "LastEditorUserId": "1932150", "CreationDate": "2013-04-17T22:12:34.103", "LastActivityDate": "2013-04-18T08:09:52.740", "LastEditDate": "2013-04-17T22:18:58.177", "ViewCount": "166", "FavoriteCount": "0", "Title": "Reference captured in static variable definition", "Id": "16071154", "Score": "8", "Body": "<pre><code>#include &lt;iostream&gt;\n\nvoid foo(int k) {\n    static auto bar = [&amp;]{\n        std::cout &lt;&lt; k &lt;&lt; std::endl;\n    };\n    bar();\n}\n\nint main () {\n    foo(1); foo(2); foo(3); // output is correct: 1, 2, 3\n}\n</code></pre>\n<p>Check the function <em>foo</em>, an how the static lambda is capturing <em>k</em> by reference. This seems to work, and the same is happening with more complicated datatypes rather than <em>int</em>. </p>\n<p>Is this expected?\nIs there any guarantee that the address of <em>k</em> will be the same for every invocation of <em>foo</em>, or is this <strong>UB</strong>?</p>\n<p>Thanks in advance, and sorry if this was previously answered (I did try to find a similar question without success)</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1207998", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_16071154_16071220_0": {"section_id": 5991, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_16071154_16071220_0": {"section_id": 5759, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_16071154_16071220_0": {"section_id": 7491, "quality": 0.8888888888888888, "length": 16}}}, "16071293": {"ParentId": "16071154", "CommentCount": "3", "Body": "<p>The reason it's probably \"working\" in your example is that the call stack is always lining up the same way.  Try this instead and see if you still get the \"expected\" output.</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid foo(int k) {\n    static auto bar = [&amp;]{\n        std::cout &lt;&lt; k &lt;&lt; std::endl;\n    };\n    bar();\n}\n\nvoid baz(int k) {\n    std::cout &lt;&lt; \"baz: \";\n    foo(k);\n}\n\nint main () {\n    foo(1); baz(2); foo(3);\n}\n</code></pre>\n", "OwnerUserId": "1828879", "PostTypeId": "2", "Id": "16071293", "Score": "1", "CreationDate": "2013-04-17T22:24:06.063", "LastActivityDate": "2013-04-17T22:24:06.063"}, "16071220": {"ParentId": "16071154", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><strong>It is Undefined Behavior</strong>.</p>\n<p>Per Paragraph 5.2.2/4 of the C++11 Standard about function call expressions and the initialization of their parameters:</p>\n<blockquote>\n<p id=\"so_16071154_16071220_0\">[...] <strong>The lifetime of a parameter ends when the function in which it\n  is defined returns</strong>. The initialization and destruction of each parameter occurs within the context of the\n  calling function. [...]</p>\n</blockquote>\n<p>Therefore, your lambda will be storing a reference that becomes dangling as soon as the function call returns.</p>\n<p>In this case, implementations are free (and likely) to create function parameters at the same address for each function call, which is probably the reason why you are observing the expected output. </p>\n<p>However, this behavior is not mandated by the Standard - therefore, you should not rely on it (if this was the case, your code would be legal because of 3.8/7).  </p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-04-18T08:09:52.740", "Id": "16071220", "Score": "4", "CreationDate": "2013-04-17T22:18:43.003", "LastActivityDate": "2013-04-18T08:09:52.740"}});