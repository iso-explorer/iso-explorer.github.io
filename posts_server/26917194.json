post_cb({"bq_ids": {"n4140": {"so_26917194_26917282_2": {"length": 16, "quality": 0.8, "section_id": 7223}, "so_26917194_26917401_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 6047}, "so_26917194_26917282_0": {"length": 13, "quality": 0.6190476190476191, "section_id": 6039}, "so_26917194_26917282_3": {"length": 22, "quality": 0.88, "section_id": 7224}}, "n3337": {"so_26917194_26917282_3": {"length": 22, "quality": 0.88, "section_id": 6968}, "so_26917194_26917282_2": {"length": 16, "quality": 0.8, "section_id": 6967}, "so_26917194_26917282_0": {"length": 13, "quality": 0.6190476190476191, "section_id": 5807}, "so_26917194_26917401_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 5815}}, "n4659": {"so_26917194_26917282_2": {"length": 16, "quality": 0.8, "section_id": 8732}, "so_26917194_26917282_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 7548}, "so_26917194_26917282_3": {"length": 20, "quality": 0.8, "section_id": 8734}, "so_26917194_26917401_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 7546}}}, "26917401": {"Id": "26917401", "PostTypeId": "2", "Body": "<p>Maybe.  Until C++11, they couldn't; but C++11 adds:</p>\n<blockquote>\n<p id=\"so_26917194_26917401_0\">Converting a function pointer to an object pointer type or vice versa is\n  conditionally-supported. The meaning of such a conversion is\n  implementation-defined, except that if an implementation supports\n  conversions in both directions, converting a prvalue of one type to the\n  other type and back, possibly with different cvqualification, shall\n  yield the original pointer value.</p>\n</blockquote>\n<p>This doesn't appear to have made it into C yet.</p>\n<p>The reason why you can't convert between them, of course, is because\nthey may not have the same size or format.  Posix requires that they do\nhave the same size and format, and I would expect all Posix compilers to\nsupport the conversion; most did before anyway, even though it made them\nnon-conformant.</p>\n<p>EDIT:</p>\n<p>A little more information.  After rereading the C standard, I think\nconversions between object pointers and function pointers are undefined\nbehavior: the C standard doesn't seem to require a diagnostic in this\ncase, but it definitely doesn't define any behavior for it.  As\nundefined behavior, an implementation (or Posix) is free to define it.\nOr just do anything it wants, without documenting it.</p>\n<p>On the otherhand, C++, pre C++11, <em>required</em> a diagnostic (although\na number of compilers didn't give one).  In C++11, as per the paragraph\nquoted above, it is implementation defined whether an implementation\nsupports it or not, and if an implementation supports it, they are\nrequired to document its behavior.  So in all cases, an implementation\nis required to document what it does, and if it does not support it, it\nis required to issue a diagnostic if the code tries to do the\nconversion.</p>\n", "LastEditorUserId": "649665", "LastActivityDate": "2014-11-14T12:15:51.290", "Score": "14", "CreationDate": "2014-11-13T20:04:10.053", "ParentId": "26917194", "CommentCount": "4", "OwnerUserId": "649665", "LastEditDate": "2014-11-14T12:15:51.290"}, "26917282": {"Id": "26917282", "PostTypeId": "2", "Body": "<p>No it may not.</p>\n<p>According to the C Standard (6.3.2.3 Pointers)</p>\n<blockquote>\n<p id=\"so_26917194_26917282_0\">1 A pointer to void may be converted to or from a pointer to any\n  <strong>object type</strong>. A pointer to any <strong>object type</strong> may be converted to a pointer to void and back again; the result shall compare equal to\n  the original pointer.</p>\n</blockquote>\n<p>As for function pointers then</p>\n<blockquote>\n<p id=\"so_26917194_26917282_1\">8 A pointer to a function of one type may be converted to a pointer to\n  a function of another type and back again; the result shall compare\n  equal to the original pointer. If a converted pointer is used to call\n  a function whose type is not compatible with the referenced type, the\n  behavior is undefined.</p>\n</blockquote>\n<p>In the C++ Standard there is more detailed definition of pointers (3.9.2 Compound types)</p>\n<blockquote>\n<p id=\"so_26917194_26917282_2\">3 The type of <strong>a pointer to void</strong> or a pointer to an object type is\n  called an <strong>object pointer type</strong>....The type of a pointer that can\n  designate a function is called a <strong>function pointer type</strong>.</p>\n</blockquote>\n<p>And</p>\n<blockquote>\n<p id=\"so_26917194_26917282_3\">4 <strong>A pointer to cv-qualified (3.9.3) or cv-unqualified void</strong> can be used\n  to point to o<strong>bjects</strong> of unknown type. Such a pointer shall be able to\n  hold any object pointer. An object of type cv void* shall have the\n  same representation and alignment requirements as cv char*.</p>\n</blockquote>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2014-11-13T20:07:53.217", "Score": "12", "CreationDate": "2014-11-13T19:56:05.427", "ParentId": "26917194", "CommentCount": "7", "OwnerUserId": "2877241", "LastEditDate": "2014-11-13T20:07:53.217"}, "26917194": {"ViewCount": "1749", "Body": "<p>void* is defined in such a way that it could point any thing. So can it be used to point a function (int send())?</p>\n<pre><code>int send();\nvoid* p = send;\n</code></pre>\n<p>Is it possible? When i use like this it is not showing me errors why? If not, Is there any way to store all pointers in a single variable?</p>\n", "AcceptedAnswerId": "26917282", "Title": "can void* be used to store function pointers?", "CreationDate": "2014-11-13T19:50:37.917", "LastActivityDate": "2014-11-14T12:15:51.290", "CommentCount": "6", "LastEditDate": "2014-11-13T20:50:07.407", "PostTypeId": "1", "Tags": "<c++><c><function-pointers><void-pointers>", "Id": "26917194", "AnswerCount": "2", "Score": "13", "OwnerUserId": "2511361", "ClosedDate": "2014-11-13T20:15:07.017", "LastEditorUserId": "2511361"}});