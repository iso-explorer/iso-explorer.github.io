post_cb({"36152020": {"CommentCount": "4", "ViewCount": "66", "PostTypeId": "1", "ClosedDate": "2016-03-22T19:17:29.257", "LastEditorUserId": "-1", "CreationDate": "2016-03-22T10:33:42.130", "LastActivityDate": "2016-03-22T19:12:56.613", "Title": "Uniform Initialization In Template Code", "LastEditDate": "2017-05-23T10:28:32.590", "Id": "36152020", "Score": "0", "Body": "<p>To the best of my understanding, <a href=\"http://www.stroustrup.com/C++11FAQ.html#uniform-init\" rel=\"nofollow noreferrer\">uniform initialization</a> is the preferred syntax for initializing objects. Herb Sutter <a href=\"http://herbsutter.com/2013/05/09/gotw-1-solution/\" rel=\"nofollow noreferrer\">writes</a></p>\n<blockquote>\n<p id=\"so_36152020_36152020_0\">For one thing, it\u2019s called \u201cuniform initialization\u201d because it\u2019s, well, uniform\u2014the same for all types, including aggregate structs and arrays and std:: containers...</p>\n</blockquote>\n<p>and the accepted answer to <a href=\"https://stackoverflow.com/questions/18222926/why-is-list-initialization-using-curly-braces-better-than-the-alternatives\">this question</a> states</p>\n<blockquote>\n<p id=\"so_36152020_36152020_1\">Prefer {} initialization over alternatives unless you have a strong reason not to.</p>\n</blockquote>\n<p>However, consider this code:</p>\n<pre><code>#define BRACES                                                                                                                                                                                           \n\ntemplate&lt;typename V&gt;\nclass foo {   \npublic:\n    template&lt;typename W&gt;\n    explicit foo(const W &amp;w) : \n#ifdef BRACES\n        m_v{w}\n#else // #ifdef BRACES\n        m_v(w)\n#endif // #ifdef BRACES\n    {}  \n\nprivate:\n    V m_v;\n};  \n\nstruct bar{};  \n\nint main() \n{   \n    bar b;\n\n    foo&lt;bar&gt;{b};\n#ifdef BRACES\n    bar c{b};\n#else // #ifdef BRACES\n    bar c(b);\n#endif // #ifdef BRACES                                                                                                                                                                                  \n}   \n</code></pre>\n<p>If <code>#define BRACES</code> is uncommented, this code fails to build (g++ 4.8.5) with <code>error: too many initializers for \u2018bar\u2019</code> on the line</p>\n<pre><code>    m_v{w}\n</code></pre>\n<p>in the constructor of <code>foo</code>. This makes sense, as the more direct invocation</p>\n<pre><code> bar c{b};\n</code></pre>\n<p>in <code>main</code> fails similarly, and they are essentially the same (although the template code does not know that).</p>\n<p>Conversely, commenting <code>#define BRACES</code> causes everything to build. Is this an indication to avoid this form of initialization in this type of template code?</p>\n<p><strong>Edit</strong></p>\n<p>@melak47 pointed out that this problem does not appear in g++5.1, and gave <a href=\"http://coliru.stacked-crooked.com/a/4b4cc7882c29e485\" rel=\"nofollow noreferrer\">convincing proof</a>. It apparently disappeared somewhere between 4.8.5 and 5.1.</p>\n", "Tags": "<c++><templates><c++11><g++4.8><uniform-initialization>", "OwnerUserId": "3510736", "AnswerCount": "2"}, "36163092": {"ParentId": "36152020", "CommentCount": "1", "Body": "<p>List-initialization didn't quite work when you attempt to initialize an aggregate from something of the same type.</p>\n<p>This is <a href=\"http://wg21.link/cwg1467\" rel=\"nofollow\">CWG 1467</a>, whose resolution (among other things) introduced another bullet to the giant list in <a href=\"http://eel.is/c++draft/dcl.init.list#3\" rel=\"nofollow\">[dcl.init.list]/3</a> to make this work:</p>\n<blockquote>\n<p id=\"so_36152020_36163092_0\">List-initialization of an object or reference of type <code>T</code> is defined\n  as follows:</p>\n<ul>\n<li>If <code>T</code> is a class type and the initializer list has a single element of type <em>cv</em> <code>U</code>, where <code>U</code> is <code>T</code> or a class derived from <code>T</code>, the\n  object is initialized from that element (by copy-initialization for\n  copy-list-initialization, or by direct-initialization for\n  direct-list-initialization).</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "36163092", "Score": "2", "CreationDate": "2016-03-22T19:07:01.287", "LastActivityDate": "2016-03-22T19:07:01.287"}, "bq_ids": {"n4140": {"so_36152020_36163092_0": {"section_id": 3325, "quality": 1.0, "length": 6}}, "n3337": {"so_36152020_36163092_0": {"section_id": 3195, "quality": 1.0, "length": 6}}, "n4659": {"so_36152020_36163092_0": {"section_id": 4091, "quality": 1.0, "length": 6}}}, "36153908": {"ParentId": "36152020", "CommentCount": "4", "Body": "<p>When the overloaded constructor is resolved, braced initialization will match a constructor using std::initializer_list parameters, before considering other overloaded constructors. So</p>\n<pre><code>bar c{b};\n</code></pre>\n<p>will match to a constructor taking std::initializer_list, rather than the generated copy constructor.</p>\n<p>This is discussed in Item 7: <em>Distinguish between () and {} when creating objects</em> of Scott Meyers - Effective Modern C++.</p>\n<p>Also, <a href=\"https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization\" rel=\"nofollow\">Wikipedia - C++11 Uniform initialization</a></p>\n", "OwnerUserId": "6021620", "PostTypeId": "2", "Id": "36153908", "Score": "-1", "CreationDate": "2016-03-22T12:02:28.290", "LastActivityDate": "2016-03-22T12:02:28.290"}});