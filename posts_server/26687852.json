post_cb({"bq_ids": {"n4140": {"so_26687852_26687972_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 3257}}, "n3337": {"so_26687852_26687972_0": {"length": 24, "quality": 0.6486486486486487, "section_id": 3129}}, "n4659": {"so_26687852_26687972_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 4015}}}, "26687955": {"Id": "26687955", "PostTypeId": "2", "Body": "<p>You can overload constructors in the same way as functions. The problem with sample II is that the compiler can't see the difference between </p>\n<pre><code>X::X(const X&amp; x) //The copy constructor \n</code></pre>\n<p>and </p>\n<pre><code>X::X(const X&amp; x, int i = 7) //A normal constructor\n</code></pre>\n<p>in your case : <code>X z = x;</code></p>\n<p>That's because the compiler expands it to <code>X z(x);</code>, which could be the normal or the copy constructor.</p>\n", "LastActivityDate": "2014-11-01T09:41:57.560", "CommentCount": "0", "CreationDate": "2014-11-01T09:41:57.560", "ParentId": "26687852", "Score": "0", "OwnerUserId": "4202254"}, "26687852": {"ViewCount": "344", "Body": "<p>Let's consider the following examples:</p>\n<p>I.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct X {\n    X(){ };\n    X(const X&amp;, int i = 6);\n};\n\nX::X(const X&amp; x, int i) { std::cout &lt;&lt; \"ctor\" &lt;&lt; std::endl; }\n\nX x;\n\nX z = x;\n\nint main()\n{ \n\n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/c663dca3561da29d\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>II.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct X {\n    X(){ };\n    X(const X&amp;, int i);\n};\n\nX::X(const X&amp; x, int i = 7) { std::cout &lt;&lt; \"ctor\" &lt;&lt; std::endl; } //error:\n//addition of default argument on redeclaration makes this constructor a copy constructor\n\nX x;\n\nX z = x;\n\nint main()\n{ \n\n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/eed1a2195429ceba\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>III</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid foo(int i);\nvoid bar(int j = 7);\n\nvoid foo(int i = 7){ }\nvoid bar(int j){ }\n\nint main()\n{ \n\n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/4524a2538f157440\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>Examples I and II are well-formed. But why can't we overload a constructor in the same way as a function (Example II)? How does the Standard prevent it?</p>\n", "AcceptedAnswerId": "26687972", "Title": "Why can't we overload a constructor to add a default argument to it", "CreationDate": "2014-11-01T09:27:45.357", "LastActivityDate": "2014-11-01T09:49:31.483", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "Id": "26687852", "Score": "0", "Tags": "<c++><constructor>", "AnswerCount": "2"}, "26687972": {"Id": "26687972", "PostTypeId": "2", "Body": "<p>The point is that whether a class is trivial, or trivially copyable, etc., should really be decidable based on the class definition and not require knowledge of the whole program. \u00a78.3.6 [dcl.fct.default]/p6 (quoting N4140):</p>\n<blockquote>\n<p id=\"so_26687852_26687972_0\">Except for member functions of class templates, the default arguments\n  in a member function definition that appears outside of the class\n  definition are added to the set of default arguments provided by the\n  member function declaration in the class definition; <strong>the program is\n  ill-formed if a default constructor (12.1), copy or move constructor,\n  or copy or move assignment operator (12.8) is so declared</strong>.</p>\n</blockquote>\n<p>See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1344\" rel=\"nofollow\">CWG issue 1344</a>.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-11-01T09:49:31.483", "Score": "2", "CreationDate": "2014-11-01T09:43:30.400", "ParentId": "26687852", "CommentCount": "2", "OwnerUserId": "2756719", "LastEditDate": "2014-11-01T09:49:31.483"}});