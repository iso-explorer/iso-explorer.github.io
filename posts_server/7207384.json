post_cb({"7207760": {"ParentId": "7207384", "CommentCount": "5", "Body": "<p><code>dynamic_cast</code> performs run-time check (5.2.7/8). </p>\n<p>The runtime check will fail, if <code>Base</code> is inherited as protected or private by <code>Derived</code>. </p>\n<p>The value of failed run-time check when casting to a pointer is a NULL pointer (5.2.7/9).</p>\n<p>So, the code is a workaround for private and protected descendants: if you inherit <code>Derived</code> with <code>protected</code> or <code>private</code>, <code>dynamic_cast</code> will return NULL and the custom check will be performed.</p>\n", "OwnerUserId": "544621", "PostTypeId": "2", "Id": "7207760", "Score": "0", "CreationDate": "2011-08-26T16:24:37.713", "LastActivityDate": "2011-08-26T16:24:37.713"}, "7207478": {"ParentId": "7207384", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><code>IsDerived</code> is a virtual function defined in the base class, and the functions are resolved based on the <em>static</em> type of the object using which you invoke the function. That means, that's not a problem. It will work. (Or maybe, I missed something in your question).</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-08-26T16:06:00.767", "Id": "7207478", "Score": "0", "CreationDate": "2011-08-26T15:59:26.403", "LastActivityDate": "2011-08-26T16:06:00.767"}, "7208378": {"ParentId": "7207384", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_7207384_7208378_0\">I don't get the passage about private and protected inheritance.</p>\n</blockquote>\n<p>The answer is simple. This comment like many, many other comments, is a comment that does not describe the code in any way, shape, or form.</p>\n<p>Example:</p>\n<pre><code>class PrivateDerived : private Derived {\npublic:\n   Base* cast_to_base () {\n      return dynamic_cast&lt;Base*&gt;(this);\n   }   \n};  \n\nvoid check_base (const char * id, Base* pbase) {\n   if (pbase == 0) {\n      std::cout &lt;&lt; id &lt;&lt; \" conversion yields a null pointer.\\n\";\n   }\n   else {\n      std::cout &lt;&lt; id &lt;&lt; \"-&gt;IsDerived() = \"\n                &lt;&lt; pbase-&gt;IsDerived() &lt;&lt; \"\\n\";\n      Derived* pderived = CastToDerived (pbase);\n      std::cout &lt;&lt; \"CastToDerived yields \"\n                &lt;&lt; (pderived ? \"non-null\" : \"null\") &lt;&lt; \" pointer.\\n\";\n      std::cout &lt;&lt; \"pderived-&gt;IsDerived() = \"\n                &lt;&lt; pderived-&gt;IsDerived() &lt;&lt; \"\\n\\n\";\n   }\n}\n\nint main () {\n   PrivateDerived private_derived;\n\n   // Good old c-style cast can convert anything to anything.\n   // Maybe a bit disfunctional, but it works in this case.\n   check_base (\"c_style_cast\", (Base*)&amp;private_derived);\n\n   // The cast_to_base method can see the private inheritance,\n   // and does so without invoking undefined behavior.\n   check_base (\"cast_method\", private_derived.cast_to_base());\n\n   return 0;\n}\n</code></pre>\n<p>Tested with multiple versions of gcc and clang; none of them raised that <code>assert</code> statement.</p>\n<p><strong>Addendum</strong><br>\nI suspect that what happened was that on some particular machine with some particular compiler, the code in question did somehow manage to do what the author thought it should do. I suspect that the author never tested this supposed check to see if it actually worked as advertised.</br></p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "7208378", "Score": "0", "CreationDate": "2011-08-26T17:23:55.493", "LastActivityDate": "2011-08-26T17:23:55.493"}, "7207506": {"ParentId": "7207384", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>If you have a <code>Protected</code> or <code>Private</code> Inheritance, You cannot do:   </p>\n<pre><code>Base *ptr = new Derived();\n</code></pre>\n<p>neither can you do, </p>\n<pre><code>Derived *ptr1 = new Derived();\nBase *ptr = ptr1;\n</code></pre>\n<p>This is because, <code>Base</code> is an inaccessible base of <code>Derived</code></p>\n<p><strike>Since you cannot have a <code>Base</code> class pointer pointing to <code>Derived</code> class object, that check looks redundant.</strike></p>\n<hr>\n<p><strong>EDIT:</strong><br>\nEven if you cannot directly assign an <code>Derived</code> class object to an <code>Base</code> class pointer, It can happen so in some other ways like: If a function of <code>Derived</code> class returns a <code>Base</code> class pointer.   </br></p>\n<p>In short, A <code>Base</code> class pointer may point to a <code>Derived</code> class object even if derivation is <code>protected</code> or <code>private</code>.  </p>\n<p>Given the above,  </p>\n<p>As per C++ standard:<br>\n<strong>5.2.7.8:</strong> </br></p>\n<blockquote>\n<p id=\"so_7207384_7207506_0\">The run-time check logically executes as follows:<br>\n  \u2014  If, in the most derived object pointed (referred) to by v, v points (refers) to a public base class sub- object of a T object, and if only one object of type T is derived from the sub-object pointed (referred) to by v, the result is a pointer (an lvalue referring) to that T object.<br>\n  \u2014 <strong><em>Otherwise, if v points (refers) to a public base class sub-object of the most derived object, and the type of the most derived object has a base class, of type T, that is unambiguous and <code>public</code>, the result is a pointer (an lvalue referring) to the T sub-object of the most derived object</em></strong>.<br>\n  \u2014  Otherwise, the run-time check fails.   </br></br></br></p>\n</blockquote>\n<p>Note that the standard specifically imposes the requirement of the derivation to be, <strong>Public.</strong><br>\nThus <code>dynamic_cast</code> will detect the treat the cast as an improper cast if derivation is <code>protected</code> or <code>private</code> and return a <code>NULL</code>(since you are using a pointer) and the <code>assert</code> will be called.   </br></p>\n<p><strong>So Yes, the code is very much valid. And it indeed does what the comment says</strong> </p>\n<hr>\n<p>This <strong><a href=\"http://www.ideone.com/q0PAh\" rel=\"nofollow\">sample</a></strong>, demonstrates that it works as per the comments:   </p>\n<pre><code>#include&lt;iostream&gt;\nclass Base \n{\n    public:\n        virtual bool IsDerived() const { return false; }\n};\n\nclass Derived : protected Base \n{\n    public:\n        bool IsDerived() const { return true; }\n        Base* getBase() { return this; }\n};\n\nDerived* CastToDerived( Base* base )\n{\n     // private and protected inheritance from Derived is prohibited\n     Derived* derived = dynamic_cast&lt;Derived*&gt;(base);\n     if( derived == 0 ) \n     {\n         std::cout&lt;&lt; \"!base-&gt;IsDerived()\";\n     }\n     return derived;\n}\n\n\nint main()\n{\n    Derived *ptr3 = new Derived();\n    Base *ptr = ptr3-&gt;getBase();\n    Derived *ptr2 = CastToDerived(ptr);\n    return 0;\n}\n</code></pre>\n</hr></hr>", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2011-08-26T18:00:22.223", "Id": "7207506", "Score": "1", "CreationDate": "2011-08-26T16:02:12.340", "LastActivityDate": "2011-08-26T18:00:22.223"}, "7207384": {"CommentCount": "4", "ViewCount": "422", "PostTypeId": "1", "LastEditorUserId": "57428", "CreationDate": "2011-08-26T15:53:02.517", "LastActivityDate": "2011-08-29T07:23:46.703", "Title": "How does this code to forbid inheritance work?", "LastEditDate": "2011-08-29T07:23:46.703", "Id": "7207384", "Score": "3", "Body": "<p>I found some rather strange code:</p>\n<pre><code>class Base {\npublic:\n    virtual bool IsDerived() const { return false; }\n};\n\nclass Derived : public Base {\npublic:\n    bool IsDerived() const { return true; }\n};\n\nDerived* CastToDerived( Base* base )\n{\n    // private and protected inheritance from Derived is prohibited\n    Derived* derived = dynamic_cast&lt;Derived*&gt;(base);\n    if( derived == 0 ) {\n       assert( !base-&gt;IsDerived() );\n    }\n    return derived;\n}\n</code></pre>\n<p>I don't get the passage about private and protected inheritance.</p>\n<p>Suppose, I inherit from <code>Derived</code> with <code>protected</code> modifier:</p>\n<pre><code>class FurtherDerived : protected Derived {\n};\n</code></pre>\n<p>What happens? How will that <code>assert</code> get triggered?</p>\n", "Tags": "<c++><inheritance><hierarchy><access-modifiers>", "OwnerUserId": "57428", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_7207384_7207506_0": {"section_id": 6018, "quality": 0.8387096774193549, "length": 52}}, "n3337": {"so_7207384_7207506_0": {"section_id": 5786, "quality": 0.8387096774193549, "length": 52}}, "n4659": {"so_7207384_7207506_0": {"section_id": 7517, "quality": 0.8387096774193549, "length": 52}}}});