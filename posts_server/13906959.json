post_cb({"bq_ids": {"n4140": {"so_13906959_13907057_0": {"length": 14, "quality": 1.0, "section_id": 5999}, "so_13906959_13907057_1": {"length": 11, "quality": 0.6875, "section_id": 6126}}, "n3337": {"so_13906959_13907057_0": {"length": 14, "quality": 1.0, "section_id": 5767}, "so_13906959_13907057_1": {"length": 11, "quality": 0.6875, "section_id": 5890}}, "n4659": {"so_13906959_13907057_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 7500}, "so_13906959_13907057_1": {"length": 11, "quality": 0.6875, "section_id": 7623}}}, "13907066": {"Id": "13907066", "PostTypeId": "2", "Body": "<p>This has nothing to do with templates, you get the same result if <code>T</code> is just a typedef for <code>std::string&amp;</code> rather than a deduced template parameter:</p>\n<pre><code>#include &lt;string&gt;\n\ntypedef std::string&amp; T;\n\nT Foo(int &amp; i)\n{\n    return T(i);\n}\n\nint main()\n{\n    int a = 1;\n    std::string &amp; s = Foo(a);\n}\n</code></pre>\n<p>Dietmar's answer made me realise this can be further simplified to:</p>\n<pre><code>#include &lt;string&gt;\n\ntypedef std::string&amp; T;\n\nint main()\n{\n    int a = 1;\n    std::string &amp; s = T(a);\n}\n</code></pre>\n<p>where <code>T(a)</code> is the same as the cast <code>(T)a</code> i.e. <code>(std::string&amp;)a</code> which (according to the rules of 5.4 [expr.cast]) will do a <code>const_cast</code> if that's valid (which it isn't) or a <code>static_cast</code> if that's valid (which it isn't) or a <code>static_cast</code> followed by a <code>const_cast</code> if that's valid (which it isn't) or a <code>reinterpret_cast</code> if that's valid (which it <strong>is</strong>) or a <code>reinterpret_cast</code> followed by a <code>const_cast</code> if that's valid, otherwise the expression is ill-formed.</p>\n<p>So as Dietmar said, it's the same as doing a <code>reinterpret_cast</code>, i.e.</p>\n<pre><code>std::string &amp; s = reinterpret_cast&lt;std::string&amp;&gt;(a);\n</code></pre>\n<p>I find it quite surprising that the original code compiles, but as it's the same as that line above, it's allowed to compile. Using the result of the cast is undefined behaviour though.</p>\n<p>To avoid the surprise where <code>T(a)</code> is equivalent to a cast, use the new C++11 uniform initialization syntax, <code>T{a}</code>, which is always an initialization, not a cast expression.</p>\n<p>Great question, investigating and answering it showed me a new gotcha I wasn't previously aware of, thanks to JaredC and Dietmar for the new piece of knowledge!</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2012-12-17T01:18:43.073", "Score": "5", "CreationDate": "2012-12-17T00:58:32.723", "ParentId": "13906959", "CommentCount": "4", "OwnerUserId": "981959", "LastEditDate": "2012-12-17T01:18:43.073"}, "13906959": {"ViewCount": "130", "Body": "<p>In the following example, <code>Foo</code> is not doing what is intended, but I can't figure out why this is allowed to compile.</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\ntypedef std::string&amp; T;\n\nT Foo(int &amp; i)\n{\n    return T(i);\n}\n\nint main()\n{\n    int a = 1;\n    std::string &amp; s = Foo(a);\n}\n</code></pre>\n<p>I discovered this with templates, but the <code>typedef</code> shows that its unrelated to templates.  Needless to say, <code>s</code> is not a valid string here.  I would think that constructing the value in the return of <code>Foo</code> would produce a compile error.</p>\n<p>What am I missing here?</p>\n", "AcceptedAnswerId": "13907057", "Title": "Using reference as template type", "CreationDate": "2012-12-17T00:40:19.990", "Id": "13906959", "CommentCount": "3", "LastEditDate": "2012-12-17T01:06:36.120", "PostTypeId": "1", "LastEditorUserId": "507606", "LastActivityDate": "2012-12-17T01:18:43.073", "Score": "7", "OwnerUserId": "507606", "Tags": "<c++>", "AnswerCount": "2"}, "13907057": {"Id": "13907057", "PostTypeId": "2", "Body": "<p>First of all, it worth nothing that the problem actually has no relationship to templates because this code compiles a well:</p>\n<pre><code>typedef std::string&amp; T;\nT Foo(int&amp; i) {\n    return T(i);\n}\n</code></pre>\n<p>The reason I <em>think</em> this compiles is that the <code>return</code> statement is equivalent to</p>\n<pre><code>return reinterpret_cast&lt;T&gt;(i);\n</code></pre>\n<p>in case <code>T</code> happens to be a reference members. ... and this, of course, compiles: You promised you knew what you were doing and asked the compiler kindly to believe you.</p>\n<p>OK, found it at 5.2.3 [expr.type.conv] paragraph 1:</p>\n<blockquote>\n<p id=\"so_13906959_13907057_0\">... If the expression list is a single expression, the type conversion expression is equivalent (in definedness, and if defined in meaning) to the corresponding cast expression (5.4). ...</p>\n</blockquote>\n<p>... and 5.4 [expr.cast] paragraph 4:</p>\n<blockquote>\n<p id=\"so_13906959_13907057_1\">The conversions performed by [other forms of casts] a reinterpret_cast (5.2.10) [...] can be performed using the cast notation of explicit type conversion. [...]</p>\n</blockquote>\n<p>(the elisions cover cases involving user defined type, built-in type conversions, <code>const</code> conversions, etc.)</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2012-12-17T01:11:42.663", "Score": "6", "CreationDate": "2012-12-17T00:56:59.230", "ParentId": "13906959", "CommentCount": "5", "OwnerUserId": "1120273", "LastEditDate": "2012-12-17T01:11:42.663"}});