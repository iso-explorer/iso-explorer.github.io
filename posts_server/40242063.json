post_cb({"bq_ids": {"n4140": {"so_40242063_40243538_0": {"length": 19, "quality": 1.0, "section_id": 7156}}, "n3337": {"so_40242063_40243538_0": {"length": 19, "quality": 1.0, "section_id": 6900}}, "n4659": {"so_40242063_40243538_0": {"length": 19, "quality": 1.0, "section_id": 8663}}}, "40243538": {"Id": "40243538", "PostTypeId": "2", "Body": "<p>The point of this construct is to impose a construction order (and thus a destruction order).</p>\n<p><strong>Construction</strong></p>\n<p>Since these are local static variables, the order of construction is determined by the order in which their respective <code>Instance</code> functions are called for the first time.  </p>\n<p>Since that is done in <code>main</code>, the construction order is fully specified.</p>\n<p>The only way to make the order unspecified is if you use them in static initialisation in different translation units, for instance if one has</p>\n<pre><code>C&amp; the_c = C::Instance();\n</code></pre>\n<p>and the other has</p>\n<pre><code>D&amp; the_d = D::Instance();\n</code></pre>\n<p><strong>Destruction</strong></p>\n<p>The destruction of objects with static storage is the reverse of the order of construction.</p>\n<p>3.6.3, Termination, paragraph 1:</p>\n<blockquote>\n<p id=\"so_40242063_40243538_0\">If the completion of the constructor or dynamic initialization of an\n  object with static storage duration is sequenced before that of\n  another, the completion of the destructor of the second is sequenced\n  before the initiation of the destructor of the first.</p>\n</blockquote>\n<p>So the destruction order is fully specified by the construction order.</p>\n<p>Note that this singleton construct is well specified even if one of them depends on the other, regardless of translation unit.</p>\n<p>That is, this is perfectly safe, and it doesn't matter where it's defined:</p>\n<pre><code>class C {\npublic:    \n    static C&amp; Instance() {\n       static C c(D::Instance());\n       return c;\n    }\n\n   ~C(){ m_d.doSomething(); } // Yes, this is safe.\nprivate:\n   C(D&amp; d) : m_d(d) { m_d.doSomething(); } // Yes, this is safe.\n   D&amp; m_d;\n};\n</code></pre>\n", "LastEditorUserId": "404970", "LastActivityDate": "2016-10-25T16:04:22.610", "Score": "7", "CreationDate": "2016-10-25T15:10:12.513", "ParentId": "40242063", "CommentCount": "0", "OwnerUserId": "404970", "LastEditDate": "2016-10-25T16:04:22.610"}, "40242530": {"Id": "40242530", "PostTypeId": "2", "Body": "<p>In general, the order of destruction of static objects including static local variables (that are used in your case) is undefined.</p>\n<p>To ensure order of destruction, one pattern I used is to leverage on std::shared_ptr. For instance, if you want to ensure the C singleton remains valid until after the D singleton is destroyed, you could store a shared_ptr&lt; C &gt; in D:</p>\n<pre><code>class C {\n  static shared_ptr&lt;C&gt; Instance() {\n    static auto c = make_shared&lt;C&gt;();\n    return c;\n  }\n};\n\nclass D {\n  static shared_ptr&lt;D&gt; Instance() {\n    static auto d = make_shared&lt;D&gt;();\n    return d;\n  }\n\n  D(): c_(C::Instance()) {}\n\n private:\n  shared_ptr&lt;C&gt; c_;\n};\n</code></pre>\n", "LastActivityDate": "2016-10-25T14:20:34.917", "CommentCount": "1", "CreationDate": "2016-10-25T14:20:34.917", "ParentId": "40242063", "Score": "-1", "OwnerUserId": "6826608"}, "40242063": {"ViewCount": "548", "Body": "<p>To the following code:</p>\n<pre><code>class C {\npublic:    \n    static C&amp; Instance() {\n       static C c;\n       return c;\n    }\n\n   ~C(){std::cout &lt;&lt; \"c destructed\\n\";}\nprivate:\n   C(){}\n};\n\nclass D{//similar to C but prints `d destructed` on destruction\n//...\n\nint main()\n{\n    auto c = C::Instance();\n    auto d = D::Instance();\n}\n//outputs (with gcc)\n//d destructed\n//c destructed\n//d destructed\n//c destructed\n</code></pre>\n<p>I have a couple of questions:</p>\n<ol>\n<li>Is the order of destruction calls well defined? (even if class C and D are defined in different source-files)</li>\n<li>If it is well defined is this behaviour portable?</li>\n</ol>\n", "AcceptedAnswerId": "40243538", "Title": "Destruction Order of Meyers Singletons", "CreationDate": "2016-10-25T13:59:52.797", "Id": "40242063", "CommentCount": "3", "LastEditDate": "2017-07-17T14:00:56.610", "PostTypeId": "1", "LastEditorUserId": "6594576", "LastActivityDate": "2017-07-17T14:00:56.610", "Score": "5", "OwnerUserId": "1235183", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}});