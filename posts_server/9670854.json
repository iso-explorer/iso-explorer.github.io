post_cb({"9670854": {"ViewCount": "2729", "Body": "<p>I was testing a c++11 compiler on my source code and it caught an error in one of my functions that I would have expected my non c++11 compiler to catch as well. I was returning false from a function that has a return type of std::string... Here's the code that demonstrates the problem</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main ( )\n{\n    std::string str = false;\n\n    std::cerr &lt;&lt; \"'\" &lt;&lt; str &lt;&lt; \"'\" &lt;&lt; std::endl;\n\n    return 0;\n}\n\n\n$ g++ test.cpp -W -Wall -Wextra\n$ ./a.out\n\nterminate called after throwing an instance of 'std::logic_error'\n  what():  basic_string::_S_construct NULL not valid\nAborted\n</code></pre>\n<p>I'm very surprised that this code compiles with no problems. I suspect from the exception description is that the compiler is converting a false to 0 and then to NULL and uses that as a char * to try and construct the string..</p>\n<p>However, when I switch false to true, here's what I get:</p>\n<pre><code>$ g++ test.cpp -W -Wall -Wextra\ntest.cpp: In function \u2018int main()\u2019:\ntest.cpp:5: error: conversion from \u2018bool\u2019 to non-scalar type \u2018std::string\u2019 requested\n</code></pre>\n<p>That's a more reasonable result, in my opinion.</p>\n<p>Can someone please clarify why this seemingly inconsistent behaviour happens? That is, <code>std::string a = false</code> compiles, but throws an exception, and <code>std::string a = true</code> doesn't compile.</p>\n<p>EDIT:</p>\n<p>For reference, here's an error generated with g++ 4.7 with -std=c++11 for the false case:</p>\n<pre><code>test.cpp: In function \u2018int main()\u2019:\ntest.cpp:5:23: warning: converting \u2018false\u2019 to pointer type for argument 1 of \u2018std::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string(const _CharT*, const _Alloc&amp;) [with _CharT = char; _Traits = std::char_traits&lt;char&gt;; _Alloc = std::allocator&lt;char&gt;]\u2019 [-Wconversion-null]\n</code></pre>\n<p>It does accept NULL though as CashCow suggests</p>\n", "AcceptedAnswerId": "9670919", "Title": "assigning true/false to std::string: what's going on?", "CreationDate": "2012-03-12T16:23:23.323", "Id": "9670854", "CommentCount": "3", "LastEditDate": "2012-03-12T16:35:11.007", "PostTypeId": "1", "LastEditorUserId": "581566", "LastActivityDate": "2017-03-24T11:31:27.417", "Score": "15", "OwnerUserId": "581566", "Tags": "<c++><string><gcc><g++><std>", "AnswerCount": "4"}, "9670919": {"Id": "9670919", "PostTypeId": "2", "Body": "<p>It's rather a horrible implicit conversion and lack of type-safety.</p>\n<p><code>std::string</code> takes a constructor from a pointer\nfalse degrades to 0 which becomes a null pointer.</p>\n<p>and you cannot pass a null pointer to the constructor of std::string.</p>\n<p>Incidentally whilst you use = it is a constructor not an assignment you are performing here.</p>\n<p>Your \"strict\" g++ C++11 compiler however nicely caught the error for you at compile time.</p>\n<p>And it won't work with true because that is never able to represent a NULL pointer. C++11 has nullptr. If you tried:</p>\n<p><code>std::string str = nullptr;</code></p>\n<p>your C++11 compiler would probably compile it and then you'd get a runtime error.</p>\n", "LastActivityDate": "2012-03-12T16:26:06.083", "CommentCount": "4", "CreationDate": "2012-03-12T16:26:06.083", "ParentId": "9670854", "Score": "6", "OwnerUserId": "442284"}, "bq_ids": {"n4140": {"so_9670854_42998291_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 39}, "so_9670854_9671195_1": {"length": 8, "quality": 0.5333333333333333, "section_id": 39}, "so_9670854_9671195_0": {"length": 14, "quality": 1.0, "section_id": 26}, "so_9670854_42998291_1": {"length": 16, "quality": 1.0, "section_id": 5340}}, "n3337": {"so_9670854_42998291_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 36}, "so_9670854_9671195_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 36}, "so_9670854_9671195_0": {"length": 14, "quality": 1.0, "section_id": 23}}, "n4659": {"so_9670854_42998291_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 39}, "so_9670854_9671195_1": {"length": 8, "quality": 0.5333333333333333, "section_id": 39}, "so_9670854_9671195_0": {"length": 14, "quality": 1.0, "section_id": 26}, "so_9670854_42998291_1": {"length": 15, "quality": 0.9375, "section_id": 6761}}}, "42998291": {"Id": "42998291", "PostTypeId": "2", "Body": "<p><a href=\"https://stackoverflow.com/a/9671195/166389\">Xeo's answer</a> is correct up-to and including C++11.</p>\n<p>In C++ 14, the relevant text in <code>\u00a74.10 Pointer conversions [conv.ptr] p1</code> was changed:</p>\n<blockquote>\n<p id=\"so_9670854_42998291_0\">A <em>null pointer constant</em> is an <strong>integer literal (2.14.2)</strong> with value zero or a prvalue of type <code>std::nullptr_t</code></p>\n</blockquote>\n<p>(Bold emphasis by me)</p>\n<p>So <code>false</code> remains an <strong>integral constant expression</strong> via <code>\u00a74.5 Integral promotions [conv.prom] p4</code>, it is not a <strong>integer literal</strong>:\n<code>\u00a72.14.2 Integer literals [lex.icon] p1</code>:</p>\n<blockquote>\n<p id=\"so_9670854_42998291_1\">An <em>integer literal</em> is a sequence of digits that has no period or exponent part, with optional separating single quotes that are ignored when determining its value.</p>\n</blockquote>\n<hr>\n<p><a href=\"https://godbolt.org/g/H0ebVz\" rel=\"nofollow noreferrer\">gcc 4.5</a> warns about this, and <a href=\"https://godbolt.org/g/GnmHHY\" rel=\"nofollow noreferrer\">gcc 6.1</a> holds this as an error, irrespective of the <code>-std=c++1?</code> flag.</p>\n<p><a href=\"http://webcompiler.cloudapp.net/\" rel=\"nofollow noreferrer\">Visual C++ 19.10.25109.0 from Visual Studio 2017</a> happily compiles it, so that's not C++14-compliant. I couldn't find an open Microsoft Connect issue, so I <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/3130510\" rel=\"nofollow noreferrer\">lodged one</a>.</p>\n<hr>\n<p>This issue was raised to the ISO C++ Standards Committee as <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1448\" rel=\"nofollow noreferrer\">CWG1448</a> in 2012 and fixed as part of the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#903\" rel=\"nofollow noreferrer\">CWG903</a> (raised in 2009 but resolved in 2013).</p>\n<p>The change to the standard wording is visible at <a href=\"https://github.com/cplusplus/draft/commit/878a6dc4bd50b6eee45dc51fc1e38a9b829679ac\" rel=\"nofollow noreferrer\">CWG903 Value-dependent integral null pointer constants</a> which added the following block of text to the list of differences from C++03 to the current standard:\n<code>\u00a7C2.2 Clause 4: standard conversions [diff.cpp03.conv]</code></p>\n<blockquote>\n<p id=\"so_9670854_42998291_2\"><strong>Change:</strong> Only literals are integer null pointer constants</p>\n<p id=\"so_9670854_42998291_3\"><strong>Rationale:</strong> Removing surprising interactions with templates and constant expressions</p>\n<p id=\"so_9670854_42998291_4\"><strong>Effect on original feature:</strong> Valid C++ 2003 code may fail to compile or produce different results in this International Standard, as the following example illustrates:</p>\n<p id=\"so_9670854_42998291_5\"><code>\n  void f(void *); // #1 \n  void f(...); // #2\n  template&lt;int N&gt; void g() {\n   f(0*N); // calls #2; used to call #1\n  }</code></p>\n</blockquote>\n<p>Interestingly, this conversion was noted in-passing as weird in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#97\" rel=\"nofollow noreferrer\">CWG97</a> but wasn't the point of the issue so apparently nothing was done.</p>\n<blockquote>\n<p id=\"so_9670854_42998291_6\">[...] we have the anomalous notion that <code>true</code> and <code>false</code> are not constant expressions.</p>\n<p id=\"so_9670854_42998291_7\">Now, you may argue that you shouldn't be allowed to convert <code>false</code> to a pointer. But [...]</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2017-03-24T11:31:27.417", "Score": "0", "CreationDate": "2017-03-24T11:24:57.120", "ParentId": "9670854", "CommentCount": "0", "OwnerUserId": "166389", "LastEditDate": "2017-05-23T11:46:22.417"}, "9671195": {"Id": "9671195", "PostTypeId": "2", "Body": "<p>It's exactly as you say, <code>false</code> can be converted to a valid null pointer constant (sadly so).</p>\n<p><code>true</code>, however, is not a null pointer constant and can't be converted to one and as such can't be converted to a pointer and fails to compile.</p>\n<p><code>\u00a74.5 Integral promotions [conv.prom] p4</code></p>\n<blockquote>\n<p id=\"so_9670854_9671195_0\">A prvalue of type <code>bool</code> can be converted to a prvalue of type <code>int</code>, <strong>with <code>false</code> becoming zero</strong> and <code>true</code> becoming one.</p>\n</blockquote>\n<p><code>\u00a74.10 Pointer conversions [conv.ptr] p1</code>:</p>\n<blockquote>\n<p id=\"so_9670854_9671195_1\">A <em>null pointer constant</em> is an integral constant expression (5.19) prvalue of integer type <strong>that evaluates to zero</strong> or a prvalue of type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p>Since the <code>false</code> is a literal, it's also an integral constant expression, and after promotion indeed evaluates to zero.</p>\n<p><em><strong>Note that this has not changed in C++11.</strong></em></p> In fact, the above quotes are from the C++11 standard. What you get with GCC 4.7 is just a <em>warning</em>. It's an optional diagnostic that your compiler decided to hint at, since it's always wrong and a bug.\n", "LastEditorUserId": "46642", "LastActivityDate": "2012-03-12T16:47:00.697", "Score": "3", "CreationDate": "2012-03-12T16:44:29.813", "ParentId": "9670854", "CommentCount": "2", "OwnerUserId": "500104", "LastEditDate": "2012-03-12T16:47:00.697"}, "9671226": {"Id": "9671226", "PostTypeId": "2", "Body": "<p>It is a subtle issue that I may not fully understand.</p>\n<p>The basic rule is that anything that has a value of <code>0</code> may be considered a valid null pointer. Therefore, <code>false</code> can be used in contexts requiring a pointer, like <code>char const*</code>.</p>\n<p>However, the <code>std::string</code> constructor from a <code>char const*</code> explicitly requires a non-null pointer (and here you are fortunate to get an exception).</p>\n<p>On the other hand, <code>true</code> is non-<code>0</code>, and so cannot be treated as a pointer. Thus you get a proper diagnostic.</p>\n<hr>\n<p>This issue is compounded by the introduction of <code>constexpr</code> in C++11, which was raised by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1362\" rel=\"nofollow\">Richard Smith</a>:</p>\n<pre><code>struct S { constexpr S(): n() {} int n; };\n</code></pre>\n<p>here, <code>S().n</code> is evaluated to <code>0</code> statically (<code>constexpr</code> requirement) and thus may degenerate into a pointer, while in C++03 it was of type <code>int</code>. This is rather unfortunate and if you have:</p>\n<pre><code>std::true_type buggy(void*);\nstd::false_type buggy(int);\n</code></pre>\n<p>Then <code>decltype(buggy(S().n))</code> returns <code>true_type</code> for C++11 but <code>false_type</code> with C++03, a rather unfortunate change in semantics.</p>\n<p>Richard's proposal is to change this from an implicit conversion to a standard conversion to help in this case, however I don't think that it would help much in yours.</p>\n<p>Clang has warnings available for those weird conversions: <code>-Wbool-conversions</code>.</p>\n</hr>", "LastActivityDate": "2012-03-12T16:46:55.423", "CommentCount": "1", "CreationDate": "2012-03-12T16:46:55.423", "ParentId": "9670854", "Score": "2", "OwnerUserId": "147192"}});