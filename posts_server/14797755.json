post_cb({"bq_ids": {"n4140": {"so_14797755_14797778_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 5403}}, "n3337": {"so_14797755_14797778_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 5198}}, "n4659": {"so_14797755_14797778_1": {"length": 9, "quality": 0.6, "section_id": 7364}}}, "14797778": {"Id": "14797778", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_14797755_14797778_0\"><strong>Are there any differences whatever in these two approaches in the final compiled program or is it guaranteed to be the same?</strong></p>\n</blockquote>\n<p>Both are same.<br>\nMember functions defined inside the class/structure body are implicitly <code>inline</code>.<br>\nHowever, in the first example the function can be <code>inline</code>d in every translation unit where this header will be included. In second example the function can only be inlined in the cpp file which defines the function. This is because the compiler needs to see the defintion of a function at the point of function call to try and make it inline. </br></br></p>\n<p>To answer the Q in comments:    </p>\n<p>Lets say you keep the definition of function marked as <code>inline</code> in a cpp file <code>A.cpp</code> and try to call this function from another cpp file, <code>B.cpp</code>. You will end up getting an <em>\"undefined external symbol\"</em> error, this is because in C and C++ each <a href=\"https://stackoverflow.com/questions/1106149/what-is-a-translation-unit-in-c\">translation unit</a> is compiled separately and the definition of the function located in <code>A.cpp</code> is not available while compiling <code>B.cpp</code>.<br>\nWhile if the function is only called from <code>A.cpp</code> in which it is defined then the definition is available in the same file and the compiler and linker are happy to compile and link to it. </br></p>\n<p><strong>C++03 7.1.2 Function specifiers:</strong><br>\n<strong>Para 3:</strong> </br></p>\n<blockquote>\n<p id=\"so_14797755_14797778_1\">A function defined within a class definition is an inline function. The inline specifier shall not appear on a block scope function declaration.     </p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_14797755_14797778_2\"><strong>Which one should choose and why in terms of good coding practices/experience?</strong> </p>\n</blockquote>\n<p>The class definition is to serve as an interface to the users of the class. The users of this interface do not need to see the implementation details of the functions. All they need to see is how to use this interface.By putting the function definition(<em>a pretty long one as you mention</em>) inside the class you provide unnecessary details to the users thereby making it difficult for them to see what they actually need to see.<br>\nThe best way to go about this is:     </br></p>\n<ul>\n<li>Declare the function in class definition without <code>inline</code> keyword &amp; </li>\n<li>Put the function definition with keyword <code>inline</code> outside the class body.    </li>\n</ul>\n<p>Good Read:<br>\n<a href=\"http://www.parashift.com/c++-faq/where-to-put-inline-keyword.html\" rel=\"nofollow noreferrer\">With inline member functions that are defined outside the class, is it best to put the inline keyword next to the declaration within the class body, next to the definition outside the class body, or both?</a></br></p>\n<hr>\n<blockquote>\n<p id=\"so_14797755_14797778_3\"><strong>AFAIK, most of the boost libs are header-only - why did they do choose to do that?</strong></p>\n</blockquote>\n<p>Most of Boost libraries are template libraries and for template based libraries the compiler needs to see the definitions at the point of usage and hence the template functions need to be inline.<br>\nGood Read:<br>\n<a href=\"https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file\">Why can templates only be implemented in the header file?</a></br></br></p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-10T14:10:49.897", "Score": "8", "CreationDate": "2013-02-10T12:34:11.897", "ParentId": "14797755", "CommentCount": "4", "LastEditDate": "2017-05-23T11:44:10.910", "OwnerUserId": "452307"}, "14797819": {"Id": "14797819", "PostTypeId": "2", "Body": "<p>Those two are equal as far as its functionality is. However the latter will only be possible to inline in the <code>Foo.cpp</code> file.</p>\n", "LastActivityDate": "2013-02-10T12:38:15.773", "Score": "2", "CreationDate": "2013-02-10T12:38:15.773", "ParentId": "14797755", "CommentCount": "0", "OwnerUserId": "440558"}, "14797755": {"ViewCount": "778", "Body": "<p>What's the actual difference between this</p>\n<pre><code>//Foo.h\nstruct Foo {\n  void bar() {\n    //lots of complex statements\n  }\n};\n</code></pre>\n<p>and this</p>\n<pre><code>//Foo.h\nstruct Foo {\n  void bar();\n};\n//Foo.cpp\ninline void Foo::bar() {\n  //lots of complex statements\n}\n</code></pre>\n<p>Are there any differences whatever in these two approaches in the final compiled program or is it guaranteed to be the same?</p>\n<p>Please also make some comments in terms of which one should choose and why in terms of good coding practices/experience. Note the \"lots of complex statements\". Any specific cases where such things should actually be in the header file? AFAIK, most of the boost libs are header-only - why did they do choose to do that?</p>\n", "AcceptedAnswerId": "14797778", "Title": "Implementing inline functions in .h files vs. .cpp files", "CreationDate": "2013-02-10T12:32:08.450", "Id": "14797755", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-02-10T14:10:49.897", "Score": "3", "OwnerUserId": "2015453", "Tags": "<c++><boost>", "AnswerCount": "2"}});