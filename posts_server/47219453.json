post_cb({"47219453": {"CommentCount": "5", "ViewCount": "67", "PostTypeId": "1", "LastEditorUserId": "5470596", "CreationDate": "2017-11-10T09:25:24.367", "LastActivityDate": "2017-11-10T09:38:32.233", "Title": "How to define a non-instantiable template class?", "LastEditDate": "2017-11-10T09:38:32.233", "Id": "47219453", "Score": "1", "Body": "<p>According to <a href=\"http://eel.is/c++draft/temp.inst#1\" rel=\"nofollow noreferrer\"><code>[temp.inst]</code></a>:</p>\n<blockquote>\n<p id=\"so_47219453_47219453_0\">Unless a class template specialization has been explicitly instantiated or explicitly specialized, the class template specialization <strong>is implicitly instantiated when the specialization is referenced in a context that requires a completely-defined object type</strong> or when the completeness of the class type affects the semantics of the program.</p>\n</blockquote>\n<p>So if I get it right, it is possible to define a template class and <em>use</em> it without <em>odr-use</em> it. It then will not be instantiated.</p>\n<p><strong>My question</strong>: what is the more short and/or idiomatic way to define a non instantiable template class?</p>\n<p>(I shouln'd ask two questions in one thread, but when does <em>\"the completeness of the class type [would] affect the semantics of the program\"</em>?)</p>\n", "Tags": "<c++><templates><language-lawyer>", "OwnerUserId": "5470596", "AnswerCount": "0"}, "bq_ids": {"n4140": {"so_47219453_47219453_0": {"section_id": 233, "quality": 0.9642857142857143, "length": 27}}, "n3337": {"so_47219453_47219453_0": {"section_id": 226, "quality": 0.9642857142857143, "length": 27}}, "n4659": {"so_47219453_47219453_0": {"section_id": 242, "quality": 0.9642857142857143, "length": 27}}}});