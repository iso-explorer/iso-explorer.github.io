post_cb({"17660391": {"ParentId": "17658446", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>N3485 contains about \"address constant expression\"</p>\n<blockquote>\n<p id=\"so_17658446_17660391_0\">An address constant expression is a prvalue core constant expression (after conversions as required by the context) of ... pointer type that evaluates to the address of an object with static storage duration ....</p>\n</blockquote>\n<p>The third character object of a string literal is such an object (see the elaborations on 2.14.5), not any less than the first one of it.</p>\n<p>Note that there is no use of <em>variable</em>, but <em>object</em> here (so we are allowed to access array elements aswell as class members to get an address constant expression, provided that the array or class object has static storage duration and the access does not otherwise violate the rules of core constant expressions).</p>\n<p>Technically there is a relocation in the object file that the linker will carry out:</p>\n<pre><code>constexpr const char *x = \"hello\";\nextern constexpr const char *y = x + 2;\n</code></pre>\n<p>We will compile this down to an object file and look what it does</p>\n<pre><code>[js@HOST1 cpp]$ clang++ -std=c++11 -c clangtest.cpp\n[js@HOST1 cpp]$ objdump --reloc ./clangtest.o \n\n./clangtest.o:     file format elf32-i386\n\nRELOCATION RECORDS FOR [.rodata]:\nOFFSET   TYPE              VALUE \n00000000 R_386_32          .L.str\n\n\n[js@HOST1 cpp]$ objdump -s -j .rodata ./clangtest.o \n\n./clangtest.o:     file format elf32-i386\n\nContents of section .rodata:\n 0000 02000000                             ....            \n[js@HOST1 cpp]$ \n</code></pre>\n<p>The linker will take the value what is already in the section, and add it to the value of the symbol (by which is meant its address in the symbol table) referenced by the \"VALUE\" property of the relocation (in our case we added <code>2</code>, so Clang/LLVM hardcoded a <code>2</code> in the section).</p>\n<blockquote>\n<p id=\"so_17658446_17660391_1\">However, p1 has to be declared explicitly using constexpr in order to p2 be a valid statement.</p>\n</blockquote>\n<p>That is because you are relying on its value, rather than its adress, to be constant. In general (see below) you must previously mark it as constexpr so that the compiler at that point can validate that any later read access can definitely rely on getting a constant. You may want to change it as follows and see it working (I THINK since there is a special case for initialized const objects of integral and enumeration types you can even <em>read</em> from the below <code>p1</code> array in a constexpr context, even without it being marked <code>constexpr</code>. However my clang seems to reject it)</p>\n<pre><code>const char p1[] = \"asdf\";\nconstexpr const char *x = p1 + 2; // OK!\nconstexpr char y = p1[2]; // OK!\n</code></pre>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2013-07-15T18:28:19.857", "Id": "17660391", "Score": "3", "CreationDate": "2013-07-15T17:38:49.047", "LastActivityDate": "2013-07-15T18:28:19.857"}, "17658446": {"CommentCount": "0", "CreationDate": "2013-07-15T15:52:00.910", "PostTypeId": "1", "AcceptedAnswerId": "17660391", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-15T18:28:19.857", "LastEditDate": "2017-05-23T11:49:12.920", "ViewCount": "337", "FavoriteCount": "1", "Title": "Address Constant Expressions", "Id": "17658446", "Score": "1", "Body": "<p>I'm delving into address constant expressions while reading \"C++ Programming Language 4th edition\" book. It has a short paragraph which describes address constant expressions:</p>\n<blockquote>\n<p id=\"so_17658446_17658446_0\">The address of a statically allocated object, such as a global\n  variable, is a constant. However, its value is assigned by the linker,\n  rather than the compiler, so the compiler cannot know the value of\n  such an address constant. That limits the range of constant\n  expressions of pointer and reference type. For example:</p>\n<pre><code>constexpr const char* p1 = \"asdf\";\nconstexpr const char* p2 = p1;  //OK\nconstexpr const char* p2 = p1+2;  //error: the compiler does not know the value of p1\nconstexpr char c = p1[2]; //OK, c=='d'; the compiler knows the value pointed to by p1\n</code></pre>\n</blockquote>\n<p>I have two questions.</p>\n<ol>\n<li><p>This one is rather trivial - since the compiler doesn't know that address of a static object, then how can it evaluate the second statement during compile time? After all, the fact that the compiler doesn't know the value of <code>p1+2</code>, implies that <code>p1</code> has to be unknown in the first place, right? g++ 4.8.1 with all the rigorous flags turned on accepts all these statements, though.</p></li>\n<li><p>As exemplified in <a href=\"https://stackoverflow.com/a/14117121/1576085\">this topic</a>:</p></li>\n</ol>\n<blockquote>\n<pre><code>static constexpr int N = 3;\nint main()\n{\n  constexpr const int *NP = &amp;N;\n  return 0;\n}\n</code></pre>\n<p id=\"so_17658446_17658446_1\">Here, NP is declared as an address constant-expression, i.e. an\n  pointer that is itself a constant expression. (This is possible when\n  the address is generated by applying the address operator to a\n  static/global constant expression.)</p>\n</blockquote>\n<p>This would also work if we declared <code>N</code> as simply <code>const</code> without <code>constexpr</code>. However, <code>p1</code> has to be declared explicitly using <code>constexpr</code> in order to <code>p2</code> be a valid statement. Otherwise we get: </p>\n<blockquote>\n<p id=\"so_17658446_17658446_2\">error: the value of \u2018p1\u2019 is not usable in a constant expression</p>\n</blockquote>\n<p>Why is that? <code>\"asdf\"</code> is of <code>const char[]</code> as far as I know.</p>\n", "Tags": "<pointers><c++11><constexpr>", "OwnerUserId": "1576085", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_17658446_17660391_0": {"section_id": 6187, "quality": 0.631578947368421, "length": 12}}, "n3337": {"so_17658446_17660391_0": {"section_id": 5947, "quality": 0.7894736842105263, "length": 15}}, "n4659": {"so_17658446_17660391_0": {"section_id": 7690, "quality": 0.631578947368421, "length": 12}}}});