post_cb({"8987005": {"ParentId": "8986498", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2012-01-24T12:43:51.223", "Score": "2", "LastEditorUserId": "485561", "LastEditDate": "2012-01-24T13:37:28.757", "Id": "8987005", "OwnerUserId": "485561", "Body": "<p>I could be wrong, but I think this is a bug in GCC. Consider the following case:</p>\n<pre><code>template &lt;class T&gt; bool f() {T t = {2}; return t.f &lt; 4;}\n\nstruct abc { int f; };\n\nint main() { f&lt;abc&gt;(); }\n</code></pre>\n<p>I would expect that to compile just fine, but GCC (and Clang) assume that <code>t.f</code> names a template function, and expect a closing <code>&gt;</code>. The relevant part of the standard is <code>\u00a714.2/4</code>.</p>\n<p>That said, I am a bit hesitant to claim that a bug like this could exist in both Clang and GCC without some more evidence. I will get back after some more standard diving.</p>\n", "LastActivityDate": "2012-01-24T13:37:28.757"}, "bq_ids": {"n4140": {"so_8986498_8999649_1": {"section_id": 5522, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_8986498_8999649_1": {"section_id": 5308, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_8986498_8999649_1": {"section_id": 6957, "quality": 0.6666666666666666, "length": 4}}}, "8986498": {"CommentCount": "2", "AcceptedAnswerId": "8999649", "PostTypeId": "1", "LastEditorUserId": "165520", "CreationDate": "2012-01-24T12:03:58.393", "LastActivityDate": "2012-01-26T04:07:21.910", "LastEditDate": "2012-01-26T04:07:21.910", "ViewCount": "463", "FavoriteCount": "5", "Title": "\"template\" keyword not needed? [gcc/clang/Comeau bug?]", "Id": "8986498", "Score": "10", "Body": "<p>Here is the test code</p>\n<pre><code>template &lt;class T&gt; void f()\n{\n  T t;\n  t.f&lt;T&gt;(0); //compiles even without the \"template\" keyword, what am I missing?\n}\n\nclass abc\n{\n  public:\n  template &lt;typename T&gt;\n  void f (int){}\n};\n\nint main()\n{\n  f&lt;abc&gt;();\n}\n</code></pre>\n<p>I am using g++ 4.4.6. Thanks</p>\n<p>P.S: I have edited my question considerably. Please don't mind.</p>\n<p><strong>EDIT</strong>  : I asked this question to EDG people and this is what Mike Herrick had to say</p>\n<blockquote>\n<p id=\"so_8986498_8986498_0\">We do diagnose this as an error in --strict mode as well as any mode that enables dependent name lookup (e.g., --dep_name, --parse_templates).  Dependent name lookup is disabled in GNU emulation modes, so we don't emit this error in that case.</p>\n<p id=\"so_8986498_8986498_1\">Dependent name processing requires that nonclass prototype instantiations\n  be enabled (see below).  As with nonclass prototype instantiations, enabling\n  dependent name lookup is likely to cause compilation errors when compiling\n  code that was not written with the feature in mind.</p>\n<p id=\"so_8986498_8986498_2\">The dependent name lookup rules require that nondependent names be\n  looked up at the point of use in the template definition, and that\n  overload resolution be performed on nondependent calls at that point.\n  For dependent calls, the set of names considered is the set visible\n  at the point of use in the template definition plus any names made\n  visible by argument-dependent lookup at the point of instantiation.\n  Note that built-in types have no associated namespaces, so calls\n  with only built-in types can only resolve to names visible in the\n  template definition.  Furthermore, names from dependent base classes\n  are not visible to unqualified lookups.</p>\n</blockquote>\n<p>The following illustrates some of the most common code problems encountered\nwhen using dependent name lookup:</p>\n<pre><code>template &lt;class T&gt; struct B {\n    void f();\n  };\n\ntemplate &lt;class T&gt; struct A : public B&lt;T&gt; {\n    X x;  // error: X not visible yet (formerly an error in strict mode)\n    void g() {\n      f();        // error: B&lt;T&gt;::f not visible\n      this-&gt;f();  // must be written this way\n      h(1);  // error: h(int) not visible using argument-dependent lookup\n    }\n  };\nstruct X {};\nvoid h(int);\nA&lt;int&gt; ai;\n</code></pre>\n", "Tags": "<c++><templates><g++>", "OwnerUserId": "165520", "AnswerCount": "2"}, "8999649": {"ParentId": "8986498", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2012-01-25T08:24:07.367", "Score": "8", "LastEditorUserId": "151292", "LastEditDate": "2012-01-25T08:34:26.387", "Id": "8999649", "OwnerUserId": "151292", "Body": "<p>The <code>template</code> keyword <em>is</em> required both because <code>t</code> is a dependent name and because <code>f&lt;T&gt;</code> is a dependent member function template specialization.  The relevant specification is scattered throughout clause 14, but starts at \u00a714.2/4 (in both C++03 and C++11).</p>\n<p>The problem is due to incorrect name lookup:  gcc is finding the namespace-scope function template <code>f</code> at the point of declaration, then at the point of instantiation resolves <code>f</code> to the member function template of <code>abc</code>.</p>\n<p>If you rename either the namespace-scope function template or the member function template, you will get the correct behavior from the compiler.</p>\n<p>This is a longstanding gcc bug:</p>\n<blockquote>\n<p id=\"so_8986498_8999649_0\"><a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=11814\" rel=\"noreferrer\">Code with missing \"template\" keyword wrongly accepted</a></p>\n<p id=\"so_8986498_8999649_1\"><a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=10200\" rel=\"noreferrer\">Weird clash with same names in different scopes</a></p>\n</blockquote>\n<p>See also the many duplicate bugs resolved against both of those.  I don't see a Clang bug open for this.</p>\n<p>Name lookup from within a function template was underspecified in C++03; there were many defects reported on the subject and the specification  has undergone major changes in C++11 to clarify details and corner cases and to fix subtle problems.</p>\n", "LastActivityDate": "2012-01-25T08:34:26.387"}});