post_cb({"27411152": {"ParentId": "27410465", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2014-12-10T21:29:10.900", "Score": "5", "LastEditorUserId": "493122", "LastEditDate": "2014-12-10T21:34:32.977", "Id": "27411152", "OwnerUserId": "493122", "Body": "<p>In the case of</p>\n<pre><code>C&lt;h()&gt; oo;\n</code></pre>\n<p>\u00a714.3.2/4 kicks in:</p>\n<blockquote>\n<p id=\"so_27410465_27411152_0\">[Note: Temporaries, <strong>unnamed lvalues</strong>, and named lvalues with no linkage are not acceptable template-\n  arguments when the corresponding template-parameter has reference type.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n", "LastActivityDate": "2014-12-10T21:34:32.977"}, "27411367": {"ParentId": "27410465", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-12-10T21:42:13.597", "Score": "15", "LastEditorUserId": "1708801", "LastEditDate": "2015-01-01T02:49:29.927", "Id": "27411367", "OwnerUserId": "1708801", "Body": "<p>It looks like this restriction was subject to the following proposal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4198.html\" rel=\"noreferrer\">Allow constant evaluation for all non-type template arguments</a>, still trying to determine the status of this proposal. It says:</p>\n<blockquote>\n<p id=\"so_27410465_27411367_0\">The syntactic restrictions for pointers, references, and pointers to\n  members are awkward and prevent reasonable refactorings. For instance:</p>\n<pre><code>template&lt;int *p&gt; struct A {};\nint n;\nA&lt;&amp;n&gt; a; // ok\n\nconstexpr int *p() { return &amp;n; }\nA&lt;p()&gt; b; // error\n</code></pre>\n</blockquote>\n<p>and further says:</p>\n<blockquote>\n<p id=\"so_27410465_27411367_1\">The historical reason for the restriction was most likely that C++\n  previously did not have a sufficiently strong specification for\n  constant expressions of pointer, reference, or pointer-to-member type.\n  However, that is no longer the case. The status quo is that an\n  implementation is required to evaluate such a template argument, but\n  must then discard the result if it turns out to not be null.</p>\n<p id=\"so_27410465_27411367_2\">In addition to the above, the restriction to entities with linkage is\n  an artifact of exported templates, and could have been removed when\n  the linkage restrictions on template type parameters were removed.</p>\n</blockquote>\n<p>and it would remove this section of the note with this restriction:</p>\n<blockquote>\n<p id=\"so_27410465_27411367_3\">unnamed lvalues, and named lvalues with no linkage</p>\n</blockquote>\n<p>the whole note reads:</p>\n<blockquote>\n<p id=\"so_27410465_27411367_4\">Temporaries, unnamed lvalues, and named lvalues with no linkage are\n  not acceptable template-arguments when the corresponding\n  template-parameter has reference type.</p>\n</blockquote>\n<p><b>Update</b></p>\n<p>The revised version of this proposal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4268.html\" rel=\"noreferrer\">N4268</a> was <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4326.html#155\" rel=\"noreferrer\">adopted into the working draft at Urbana</a> and we can see the changes in the latest working draft <a href=\"https://github.com/cplusplus/draft/blob/master/papers/n4296.pdf\" rel=\"noreferrer\">N4296</a>. The new note reads:</p>\n<blockquote>\n<p id=\"so_27410465_27411367_5\">A temporary object is not an acceptable template-argument when the\n  corresponding template-parameter has reference type</p>\n</blockquote>\n<p>The normative section is <code>14.3.2</code> <em>(temp.arg.nontype) paragraph</em> <code>1</code> which with this proposal would say:</p>\n<blockquote>\n<p id=\"so_27410465_27411367_6\">For a non-type template-parameter of reference or pointer type, the\n  value of the constant expression shall not refer to (or for a pointer\n  type, shall not be the address of):</p>\n<ul>\n<li>a subobject (1.8),</li>\n<li>a temporary object (12.2),</li>\n<li>a string literal (2.14.5),</li>\n<li>the result of a typeid expression (5.2.8), or</li>\n<li>a predefined <strong>func</strong> variable (8.4.1).</li>\n</ul>\n</blockquote>\n<p>and we can find this new wording in the latest draft standard <a href=\"https://github.com/cplusplus/draft/blob/master/papers/n4296.pdf\" rel=\"noreferrer\">N4296</a>.</p>\n<p>It looks like this change has actually been implemented in <code>clang HEAD</code> see your code working <a href=\"http://melpon.org/wandbox/permlink/RlPuP2jHhjZIyelS\" rel=\"noreferrer\">live</a>, using the <code>-std=c++1z</code> flag. This implies the change should be part of C++17, assuming no subsequent changes reverses or alters it.</p>\n", "LastActivityDate": "2015-01-01T02:49:29.927"}, "27410465": {"CommentCount": "5", "AcceptedAnswerId": "27411367", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-12-10T20:44:14.813", "LastActivityDate": "2015-01-01T02:49:29.927", "LastEditDate": "2017-05-23T12:25:51.337", "ViewCount": "1036", "FavoriteCount": "4", "Title": "template instantiation with constexpr function failure", "Id": "27410465", "Score": "18", "Body": "<p>I have template class <code>C</code> that has a non-type but reference template parameter to a type <code>P</code>:</p>\n<pre><code>class P {\npublic:\n  int x;\n  int y;\n};\n\ntemplate &lt;const P &amp;x&gt;\nclass C {\npublic:\n  const int &amp;f() { return x.x; }\n};\n</code></pre>\n<p>I declared a global variable of type <code>P</code>:</p>\n<pre><code>P p = {33,44};\n</code></pre>\n<p>I also declared a function that returns a reference to <code>p</code>:</p>\n<pre><code>constexpr const P &amp;h() { return p; }\n</code></pre>\n<p>And then tried to use these in the following :</p>\n<pre><code>C&lt;p&gt; o;    // line 1\nC&lt;h()&gt; oo; // line 2\n</code></pre>\n<p>Of course I have no problem with the first instantiation but the second. My compiler complains:</p>\n<pre><code>error: non-type template argument does not refer to any declaration\n</code></pre>\n<p>Why is so ? I was unable to find an argument against it in the norm. I am not sure that it is exactly the same problem as in <a href=\"https://stackoverflow.com/questions/10721130/calling-constexpr-in-default-template-argument\">Calling constexpr in default template argument</a>, where the discussion was about point of instantiation of <em>nested</em> instanciation. Here it is more a type problem, but which one ? My function <code>h()</code> returns a reference to a well defined variable of the well defined type (<code>const P &amp;</code>). I expected that some inlining would take place a give the right result but it is not the case. Could you tell me why ?</p>\n<p>Declaring the function as inline doesn't change anything to the problem.</p>\n<p>Experiments were done with <code>Apple LLVM version 6.0 (clang-600.0.56) (based on LLVM 3.5svn</code>. I also tried with <code>g++-mp-4.8 (MacPorts gcc48 4.8.3_2) 4.8.3</code> and the error was reported as:</p>\n<pre><code>'h()' is not a valid template argument for type 'const P&amp;' because it is not an object with external linkage\n</code></pre>\n<p>It looks like my call to <code>h()</code> (which is a <code>constexpr</code> so compile-time computable) is not seen as such...</p>\n<hr>\n<p>I forgot to say that the problem is the same if we try with another reference like this:</p>\n<pre><code>const P &amp;pp = p;\n</code></pre>\n<p>and then</p>\n<pre><code>C&lt;pp&gt; oo;\n</code></pre>\n<p>this time the first compiler says:</p>\n<pre><code>non-type template argument of reference type 'const P &amp;' is not an object\n</code></pre>\n<p>and the second:</p>\n<pre><code>error: could not convert template argument 'pp' to 'const P &amp;'\n</code></pre>\n<p><code>pp</code> is not an object? <code>pp</code> is not of type <code>const P&amp;</code>? Well I can use it as is it one... I know it is a reference but indistinguishable from a native reference, or ?</p>\n</hr>", "Tags": "<c++><templates><c++11><language-lawyer><constexpr>", "OwnerUserId": "719263", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27410465_27411367_4": {"section_id": 90, "quality": 1.0, "length": 13}, "so_27410465_27411152_0": {"section_id": 90, "quality": 0.8, "length": 12}, "so_27410465_27411367_5": {"section_id": 90, "quality": 0.6666666666666666, "length": 6}, "so_27410465_27411367_6": {"section_id": 95, "quality": 0.5384615384615384, "length": 7}, "so_27410465_27411367_3": {"section_id": 90, "quality": 1.0, "length": 5}}, "n3337": {"so_27410465_27411367_4": {"section_id": 85, "quality": 1.0, "length": 13}, "so_27410465_27411152_0": {"section_id": 85, "quality": 0.8, "length": 12}, "so_27410465_27411367_5": {"section_id": 85, "quality": 0.6666666666666666, "length": 6}, "so_27410465_27411367_6": {"section_id": 86, "quality": 0.5384615384615384, "length": 7}, "so_27410465_27411367_3": {"section_id": 85, "quality": 1.0, "length": 5}}, "n4659": {"so_27410465_27411367_5": {"section_id": 94, "quality": 1.0, "length": 9}, "so_27410465_27411367_6": {"section_id": 90, "quality": 0.9230769230769231, "length": 12}}}});