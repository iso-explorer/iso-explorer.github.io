post_cb({"20227692": {"ParentId": "20227620", "LastEditDate": "2013-11-26T21:02:28.693", "CommentCount": "33", "CreationDate": "2013-11-26T20:50:35.150", "OwnerUserId": "432358", "LastEditorUserId": "432358", "PostTypeId": "2", "Id": "20227692", "Score": "0", "Body": "<p>If you like behavior of <code>std::find</code> you should use it as <code>std::string</code> is a container:</p>\n<pre><code>s.erase( std::find( s.begin(), s.end(), '#' ), s.end() );\n</code></pre>\n<p>Changing s.find() behavior to return s.length() could make this particular case more elegant, but will make other problems. I think better solution would be to make std::string::erase() to accept std::string::npos as first parameter and do nothing.</p>\n", "LastActivityDate": "2013-11-26T21:02:28.693"}, "20227970": {"ParentId": "20227620", "CommentCount": "4", "Body": "<p>The problem is that many member functions of std::basic_string use default arguments. That makes them more easier to use. For example consider the following constructor </p>\n<pre><code>basic_string(const basic_string&amp; str, size_type pos, size_type n = npos,\nconst Allocator&amp; a = Allocator());\n</code></pre>\n<p>What default argument could you specify for the third parameter n? The C++ Standard does not allow to use non-static members as default arguments:</p>\n<blockquote>\n<p id=\"so_20227620_20227970_0\">Similarly, a non-static member shall not be used in a default\n  argument, even if it is not evaluated, unless it appears as the\n  id-expression of a class member access expression (5.2.5) or unless it\n  is used to form a pointer to member</p>\n</blockquote>\n<p>So npos is more convinient default argument.</p>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "20227970", "Score": "0", "CreationDate": "2013-11-26T21:07:12.813", "LastActivityDate": "2013-11-26T21:07:12.813"}, "20227736": {"ParentId": "20227620", "CommentCount": "15", "Body": "<p>Using <code>std::string::npos</code> makes the result a constant expression unlike <code>std::string::length()</code>. Since <code>npos</code> isn't suitable as an iterator anyway there is value in having a constant expression, e.g., it can be used as default for parameters taking a <code>std::string::size_type</code>.</p>\n<p>Another reason is that the basic interface for <code>std::basic_string</code> was put together before STL was added to the C++ standard library (well, at least, there is a part of the interface which existed then). The original interface was basically an immutable string and I think it didn't support any mutation of the string itself.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "20227736", "Score": "5", "CreationDate": "2013-11-26T20:52:31.810", "LastActivityDate": "2013-11-26T20:52:31.810"}, "20227933": {"ParentId": "20227620", "LastEditDate": "2013-11-26T21:35:19.023", "CommentCount": "3", "CreationDate": "2013-11-26T21:04:55.370", "OwnerUserId": "2249683", "LastEditorUserId": "2249683", "PostTypeId": "2", "Id": "20227933", "Score": "2", "Body": "<p>I am not sure about this: The original std::sting (STL) had no requirement to store the data contiguously. Hence, returning size() on failure in an operation would be an overhead (if the size is not stored). In c++11 strings are contiguous, and I agree to your critique.</p>\n", "LastActivityDate": "2013-11-26T21:35:19.023"}, "20227620": {"CommentCount": "16", "AcceptedAnswerId": "20227933", "ClosedDate": "2013-11-27T03:31:40.910", "CreationDate": "2013-11-26T20:46:14.973", "LastActivityDate": "2013-11-26T22:09:37.337", "PostTypeId": "1", "ViewCount": "988", "Title": "Why does s.find return string::npos instead of s.length() on failure", "Id": "20227620", "Score": "6", "Body": "<p>I recently was annoyed to find that <code>string::find</code> returns <code>string::npos</code> when the needle isn't found in the haystack. This makes the following seemingly-elegant code compile but throw an out-of-range exception:</p>\n<pre><code>s.erase(s.find('#')); // erase everything after a # if one exists\n</code></pre>\n<p>If <code>find</code> returned <code>s.length()</code> on failure, it would work fine. Instead you have to do</p>\n<pre><code>auto pos = s.find('#');\nif (pos != s.npos)\n    s.erase(pos);\n</code></pre>\n<p>This is also inconsistent with <code>std::find</code> which returns the end iterator if the item isn't found.</p>\n<p>I know the standard people are pretty smart so I believe they didn't just come up with this out of nowhere. It must give some elegance somewhere else that I'm not seeing. What is the good reason for this?</p>\n", "Tags": "<c++><string><find>", "OwnerUserId": "2925619", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_20227620_20227970_0": {"section_id": 3260, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_20227620_20227970_0": {"section_id": 3132, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_20227620_20227970_0": {"section_id": 4018, "quality": 0.7647058823529411, "length": 13}}}, "20227845": {"ParentId": "20227620", "LastEditDate": "2013-11-26T22:09:37.337", "CommentCount": "0", "CreationDate": "2013-11-26T20:59:30.087", "OwnerUserId": "529761", "LastEditorUserId": "529761", "PostTypeId": "2", "Id": "20227845", "Score": "8", "Body": "<p>Your question is actually twofold:</p>\n<blockquote>\n<p id=\"so_20227620_20227845_0\">1)  Why does <code>std::string</code> have it's own <code>find</code> function that returns\n  a <code>std::size_t</code> value instead of an iterator?</p>\n</blockquote>\n<p>This is largely due to the fact that <code>std::string</code> was developed separately from much of the rest of the standard library.  It is only in recent standards that it has been embraced by other templates (e.g. iostream).  So when it was added to the standard, it had some functions added to it, but it's orginal functionality was left pretty much as-is (the exception being the common implemention of copy-on-write, which was forbidden in the C++11 standard).  It was left this way largely for backward-compatibility.</p>\n<p>Per your question about why it was that way to begin with:  The original <code>string.h</code> was a very thin wrapper around several C string functions.  It was not at all uncommon to see <code>strlen</code> used as a return value for <code>length()</code>, or <code>strcpy</code> used in the copy constructor.  There was no requirement forcing the use of these functions, so eventually implementers started doing some <em>interesting</em> things (e.g. copy-on-write, non-contiguous memory blocks), but they left the interface the same to preserve backwards-compatibility.  While functions have been added to it, no public functions have been removed from the interface.  So you can trace the design decisions for using a pointer and length for function parameters back to the days when it was merely a wrapper around the C functions.</p>\n<blockquote>\n<p id=\"so_20227620_20227845_1\">2) How can you write an erase sequence on a string without having to\n  check the return value?</p>\n</blockquote>\n<p>This can be done simply by using the find-erase idiom, but not using <code>std::string</code>'s find function:</p>\n<pre><code>s.erase(std::find(s.begin(), s.end(), '#'), s.end());\n</code></pre>\n", "LastActivityDate": "2013-11-26T22:09:37.337"}});