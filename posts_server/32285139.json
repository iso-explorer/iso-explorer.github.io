post_cb({"bq_ids": {"n4140": {"so_32285139_32309138_0": {"length": 15, "quality": 0.9375, "section_id": 6272}, "so_32285139_32309138_1": {"length": 14, "quality": 1.0, "section_id": 6304}}, "n3337": {"so_32285139_32309138_0": {"length": 15, "quality": 0.9375, "section_id": 6032}, "so_32285139_32309138_1": {"length": 14, "quality": 1.0, "section_id": 6061}}, "n4659": {"so_32285139_32309138_0": {"length": 15, "quality": 0.9375, "section_id": 7778}, "so_32285139_32309138_1": {"length": 14, "quality": 1.0, "section_id": 7814}}}, "32286351": {"Id": "32286351", "PostTypeId": "2", "Body": "<p>Your compiler is being helpful by treating printf specially as a built-in.  </p>\n<p>Sample code \"tst.cpp\":</p>\n<pre><code>int printf(char const *format,...);\nint foo(int a, char const *b);\n\nint main() {\n    printf(\"Hello, World!\");\n    foo(42, static_cast&lt;char const *&gt;(\"Hello, World!\"));\n    return 0;\n}\n</code></pre>\n<p>When compiling with Microsoft's cl compiler command \"cl /c tst.cpp\" we can inspect the resulting .obj and find:</p>\n<pre><code>00000000 r $SG2552\n00000010 r $SG2554\n00000000 N .debug$S\n00000000 i .drectve\n00000000 r .rdata\n00000000 t .text$mn\n         U ?foo@@YAHHPBD@Z\n         U ?printf@@YAHPBDZZ\n00e1520d a @comp.id\n80000191 a @feat.00\n00000000 T _main  \n</code></pre>\n<p>Note that both foo() and printf() are mangled.</p>\n<p>But when we compile with /usr/lib/gcc/i686-pc-cygwin/3.4.4/cc1plus.exe via cygwin \"g++ -c tst.cpp\", we get: </p>\n<pre><code>00000000 b .bss\n00000000 d .data\n00000000 r .rdata\n00000000 t .text\n         U __Z3fooiPKc\n         U ___main\n         U __alloca\n00000000 T _main\n         U _printf\n</code></pre>\n<p>Here foo() is mangled and printf() is not, because the cygwin compiler is being helpful.  Most would consider this a compiler defect.  If the cygwin compiler is invoked with \"g++ -fno-builtin -c tst.cpp\" then the problem goes away and both symbols are mangled as they should be.</p>\n<p>A more up-to-date g++ gets it right, compiling with with /usr/libexec/gcc/i686-redhat-linux/4.8.3/cc1plus via \"g++ -c tst.cpp\" we get:</p>\n<pre><code>00000000 T main\n         U _Z3fooiPKc\n         U _Z6printfPKcz\n</code></pre>\n<p>Both foo() and printf() are mangled.</p>\n<p>But if we declare printf such that cygwin g++ does not recognize it:</p>\n<pre><code>char const * printf(char const *format,...);\nint foo(int a, char const *b);\n\nint main() {\n    printf(\"Hello, World!\");\n    foo(42, static_cast&lt;char const *&gt;(\"Hello, World!\"));\n    return 0;\n}\n</code></pre>\n<p>Then both foo() and printf() are mangled:</p>\n<pre><code>00000000 b .bss\n00000000 d .data\n00000000 r .rdata\n00000000 t .text\n         U __Z3fooiPKc\n         U __Z6printfPKcz\n         U ___main\n         U __alloca\n00000000 T _main\n</code></pre>\n", "LastEditorUserId": "1803860", "LastActivityDate": "2015-08-29T13:46:48.370", "Score": "4", "CreationDate": "2015-08-29T13:02:55.427", "ParentId": "32285139", "CommentCount": "4", "OwnerUserId": "1803860", "LastEditDate": "2015-08-29T13:46:48.370"}, "32309138": {"Id": "32309138", "PostTypeId": "2", "Body": "<p>Let's take a look at the relevant standard quotes:</p>\n<blockquote>\n<h3>17.6.2.3 Linkage <em>[using.linkage]</em></h3>\n<p id=\"so_32285139_32309138_0\">2 Whether a name from the C standard library declared with external linkage has <code>extern \"C\"</code> or <code>extern \"C++\"</code> linkage is implementation-defined. It is recommended that an implementation use <code>extern \"C++\"</code> linkage for this purpose.</p>\n</blockquote>\n<blockquote>\n<h3>17.6.4.3 Reserved names <em>[reserved.names]</em></h3>\n<p id=\"so_32285139_32309138_1\">2 If a program declares or defines a name in a context where it is reserved, other than as explicitly allowed by this Clause, its behavior is undefined.</p>\n</blockquote>\n<blockquote>\n<h3>17.6.4.3.3 External linkage <em>[extern.names]</em></h3>\n<p id=\"so_32285139_32309138_2\">1 Each name declared as an object with external linkage in a header is reserved to the implementation to designate that library object with external linkage, both in namespace <code>std</code> and in the global namespace.<br>\n  2 Each global function signature declared with external linkage in a header is reserved to the implementation to designate that function signature with external linkage.<br>\n  3 Each name from the Standard C library declared with external linkage is reserved to the implementation for use as a name with <code>extern \"C\"</code> linkage, both in namespace <code>std</code> and in the global namespace.\n  4 Each function signature from the Standard C library declared with external linkage is reserved to the implementation for use as a function signature with both <code>extern \"C\"</code> and <code>extern \"C++\"</code> linkage, or as a name of namespace scope in the global namespace.</br></br></p>\n</blockquote>\n<p>What we get from this is that the compiler <em>may assume</em> that <code>printf</code> in any of the given instances always refers to the standard-library-function <code>printf</code>, and thus can have any amount of info about them baked in. And if you get the declaration wrong, or indeed simply provide your own, it is free to do whatever it wants, including but not limited to magically correcting it.<br>\nAnyway, you cannot know which language-linkage it expects.</br></p>\n", "LastActivityDate": "2015-08-31T10:26:59.527", "CommentCount": "0", "CreationDate": "2015-08-31T10:26:59.527", "ParentId": "32285139", "Score": "1", "OwnerUserId": "3204551"}, "32285139": {"ViewCount": "177", "Body": "<p>I was going through the article - <a href=\"http://www.geeksforgeeks.org/extern-c-in-c/\">http://www.geeksforgeeks.org/extern-c-in-c/</a></p>\n<p>There are two example given - </p>\n<pre><code>int printf(const char *format,...);\n\nint main()\n{\n    printf(\"GeeksforGeeks\");\n    return 0;\n}\n</code></pre>\n<p>It say this wont compile because the compiler wont be able to find the mangled version of 'printf' function. However, the below give output.</p>\n<pre><code>extern \"C\"\n{\n    int printf(const char *format,...);\n}\n\nint main()\n{\n    printf(\"GeeksforGeeks\");\n    return 0;\n}\n</code></pre>\n<p>This is beacuse extern \"C\" block prevent the name from being mangled. However, the code run and gives output. From where does it get the definition of 'printf'. I read a post which says 'stdio.h' is included by default. If this is true, below code must run. However, it give error that printf is not defined.</p>\n<pre><code>int main()\n{\n    printf(\"GeeksforGeeks\");\n    return 0;\n}\n</code></pre>\n<p>Can somebody explain this?</p>\n", "Title": "Name Mangling in C++", "CreationDate": "2015-08-29T10:43:16.780", "LastActivityDate": "2015-08-31T10:26:59.527", "CommentCount": "16", "LastEditDate": "2015-08-29T10:55:06.057", "PostTypeId": "1", "LastEditorUserId": "1773248", "Id": "32285139", "Score": "6", "OwnerUserId": "1773248", "Tags": "<c++><extern>", "AnswerCount": "2"}});