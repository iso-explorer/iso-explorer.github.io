post_cb({"32546666": {"LastActivityDate": "2015-09-13T21:48:37.160", "CreationDate": "2015-09-13T05:35:08.833", "CommentCount": "1", "Body": "<p>This 'works' only because it's undefined behavior. The memory location the compiler chooses for <code>mB</code> happens to be the same as <code>&amp;mA + 1</code>, the address for <code>mC</code> is <code>&amp;mA + 2</code> and <code>&amp;mB + 1</code> and so on.</p>\n<p>However it is true that the class is 'standard layout' (all data members have same access specifier and no inheritance is being used [n3337 \u00a7 9 p7]), which traditionally does produce this organization of the member variables. It's not guaranteed though. 'standard layout' could mean something else, such as some amount of padding between the members [n3337 \u00a7 9.2 p14], but I doubt there's any platform which actually does that.</p>\n<p>The spec does say that it's legal to get the address one past an object, so calculating <code>&amp;mA + 1</code> is legal. [n3337 \u00a7 5.7 p5] And the spec does also say that a pointer with the correct type and value does point at an object regardless of how the pointer is calculated.</p>\n<blockquote>\n<p id=\"so_32546573_32546666_0\">If an object of type T is located at an address A, a pointer of type cv T* whose value is the address A is said to point to that object, regardless of how the value was obtained. [Note: For instance, the address one past the end of an array (5.7) would be considered to point to an unrelated object of the array\u2019s element type that might be located at that address. <em>\u2014 [n3337 \u00a7 3.9.2 p3]</em></p>\n</blockquote>\n<p>After reviewing \u00a75.9 and \u00a75.10 I think the following may be technically legal, though it could possibly have unspecified behavior:</p>\n<pre><code>if (&amp;mA + 1 == &amp;mB &amp;&amp; &amp;mB + 1 == &amp;mC &amp;&amp; &amp;mC + 1 == &amp;mD) {\n    return ((int*)(this))[index];\n}\n</code></pre>\n<p>Even the cast is legal, since the spec says a standard layout class can be cast to a pointer to its first member. [n3337 \u00a7 9.2 p20]</p>\n", "Id": "32546666", "LastEditDate": "2015-09-13T21:48:37.160", "ParentId": "32546573", "OwnerUserId": "365496", "PostTypeId": "2", "Score": "0", "LastEditorUserId": "365496"}, "bq_ids": {"n4140": {"so_32546573_32546666_0": {"length": 32, "quality": 0.8648648648648649, "section_id": 7223}}, "n3337": {"so_32546573_32546666_0": {"length": 32, "quality": 0.8648648648648649, "section_id": 6967}}}, "32546752": {"LastActivityDate": "2015-09-13T07:17:43.507", "CreationDate": "2015-09-13T05:48:46.683", "CommentCount": "4", "Body": "<p>This type of thing is not recommended, because it is not guaranteed by the C++ standard. However, most compilers do explicitly define their memory layout behaviors (often on a per-architecture basis) and provide <code>#pragma</code>s for manipulating the packing behavior (such as <code>#pragma pack</code> in MSVC). If you understand/leverage these features, you can make it work on most given compilers/architectures. <strong>However, it will <em>not</em> be portable!</strong> For each new compiler, you'd need to re-test and adjust, a costly maintenance task. Generally, we prefer greater ease of portability.</p>\n<p>If you really want to do this, you can add a <code>static_assert</code> to verify the compiler's behavior.</p>\n<pre><code>int operator[] (const int index) const\n{\n    static_assert(sizeof(SomeClass) == 4 * sizeof(mA), \"Padding not supported\");\n    return ((int*)(this))[index];\n}\n</code></pre>\n<p>Because the standard does not allow members to be reordered, logically we can deduce that if the size of <code>SomeClass</code> is 16, then this code will work as expected. With the assert, we are at least notified if somebody builds on a different compiler and it tries to pad it (thus messing us up).</p>\n<p>However, we can be standards-compliant and achieve names for array slots. You might consider a pattern such as:</p>\n<pre><code>class SomeClass\n{\n    enum Index {\n        indexA,\n        indexB,\n        indexC,\n        indexD,\n\n        indexCount;\n    };\n\n    int mData[indexCount];\n\npublic:\n    int operator[] (const int index) const\n    {\n        return mData[index];\n    }\n\n    int&amp; A() { return mData[indexA]; }\n    int&amp; B() { return mData[indexB]; }\n    int&amp; C() { return mData[indexC]; }\n    int&amp; D() { return mData[indexD]; }\n};\n</code></pre>\n<p>This provides similar functionality, but is guaranteed by the C++ standard.</p>\n", "Id": "32546752", "LastEditDate": "2015-09-13T07:17:43.507", "ParentId": "32546573", "OwnerUserId": "981367", "PostTypeId": "2", "Score": "4", "LastEditorUserId": "981367"}, "32546573": {"CreationDate": "2015-09-13T05:19:39.970", "ViewCount": "74", "Id": "32546573", "AcceptedAnswerId": "32546752", "Score": "2", "Title": "Overloading the [] operator with no array internally", "CommentCount": "10", "Body": "<p>I have seen the following code:</p>\n<pre><code>class SomeClass\n{\npublic:\n    int mA;\n    int mB;\n    int mC;\n    int mD;\n\n    int operator[] (const int index) const\n    {\n        return ((int*)(this))[index];\n    }\n};\n</code></pre>\n<p>How does this work? I know the this keyword is a pointer to this class but without property knowing how many variables there are ... how can we safely access [index] of \"this\" pointer?</p>\n", "Tags": "<c++><operator-overloading>", "LastActivityDate": "2015-09-13T21:48:37.160", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "1481358"}});