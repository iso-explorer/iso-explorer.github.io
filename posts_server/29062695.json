post_cb({"bq_ids": {"n4140": {"so_29062695_29062887_0": {"length": 16, "quality": 1.0, "section_id": 6109}}, "n3337": {"so_29062695_29062887_0": {"length": 16, "quality": 1.0, "section_id": 5875}}, "n4659": {"so_29062695_29062887_0": {"length": 16, "quality": 1.0, "section_id": 7606}}}, "29062913": {"Id": "29062913", "PostTypeId": "2", "Body": "<h3>Explanation</h3>\n<p>You are trying to <em>delete</em> an object of incomplete type, this is <em>undefined behavior</em> if the object type being deleted has a non-trivial destructor.</p>\n<p>More about the matter can be read about in <code>[expr.delete]</code> in the Standard, as well as under the following link:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/2517245/why-really-deleting-an-incomplete-type-is-undefined-behaviour\"><strong>stackoverflow.com</strong> - Why, really, deleting an incomplete type is undefined behaviour?</a></li>\n</ul>\n<hr>\n<p><sub><strong>Note</strong>: The destructor of <code>Widget::Cat</code> is non-trivial since it is user-declared; in turn this means it is not called.</sub></p>\n<hr>\n<hr>\n<h3>Solution</h3>\n<p>To fix the problem simply provide the definition of <code>Widget::Cat</code> so that it's not <em>incomplete</em> when you do <code>delete pc</code>.</p>\n<hr>\n<hr>\n<h3>Why does it work for <em>shared_ptr</em>?</h3>\n<p>The reason it works when using a shared_ptr is that the <em>\"point of deletion\"</em> doesn't happen until you actually construct the <em>shared_ptr</em> instance (through <code>make_shared</code>; ie. when the <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr\" rel=\"nofollow noreferrer\"><em>Deleter</em></a> is actually instantiated.</p>\n</hr></hr></hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-03-15T16:17:29.977", "Score": "5", "CreationDate": "2015-03-15T16:11:31.260", "ParentId": "29062695", "CommentCount": "2", "OwnerUserId": "1090079", "LastEditDate": "2017-05-23T12:15:47.903"}, "29062695": {"ViewCount": "1867", "Body": "<p>In the following code:</p>\n<p>smart pointer data member pImpl(class Impl) and raw pointer pc(class CAT) all are incomplete data type, there is no definition of these two classes in Widget.h </p>\n<p>//widget.h</p>\n<pre><code>#ifndef W_H_\n#define W_H_\n#include &lt;memory&gt;\n\nclass Widget { \n    public:\n        Widget();\n        ~Widget() {    //\n            delete pc; // I know I should put ~Widget to .cpp\n                       // I just want to show the difference in behavior\n                       // between raw pointer and smart pointer(both has incomplete type)\n                       // when widget object destructs \n        }\n    private:\n        struct Impl; \n        std::shared_ptr&lt;Impl&gt; pImpl;  // use smart pointer\n        struct CAT;\n        CAT *pc;  //raw pointer\n};\n#endif\n</code></pre>\n<p>//widget.cpp</p>\n<pre><code>#include \"widget.h\"\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nstruct Widget::CAT \n{\n    std::string name;\n    CAT(){cout&lt;&lt;\"CAT\"&lt;&lt;endl;}\n    ~CAT(){cout&lt;&lt;\"~CAT\"&lt;&lt;endl;}\n};      \n\n\nstruct Widget::Impl {\n    std::string name;\n    Impl(){cout&lt;&lt;\"Impl\"&lt;&lt;endl;}\n    ~Impl(){cout&lt;&lt;\"~Impl\"&lt;&lt;endl;}\n};\n\n\nWidget::Widget()  \n    : pImpl(std::make_shared&lt;Impl&gt;()),\n      pc(new CAT)\n{} \n</code></pre>\n<p>//main.cpp</p>\n<pre><code>#include \"widget.h\"\nint main()\n{\n    Widget w;\n}\n</code></pre>\n<p>//output</p>\n<blockquote>\n<p id=\"so_29062695_29062695_0\">Impl </p>\n<p id=\"so_29062695_29062695_1\">CAT </p>\n<p id=\"so_29062695_29062695_2\">~Impl</p>\n</blockquote>\n<p>For the raw pointer data member, its destuctor is <strong>not called</strong> when widget object is destructed.</p>\n<p>While the <code>shared_ptr</code> data member, <strong>its destructor has been correctly called.</strong></p>\n<p>To my understanding, in Widget::~Widget() it should generate some\ncode automatically as the following:</p>\n<pre><code>        ~Widget() {\n            delete pc; // wrote by me\n\n            // generated by compiler\n            delete pImpl-&gt;get();\n        }\n</code></pre>\n<p>Why do shared_ptr data member and raw data member have different behavior when the widget gets destructed?</p>\n<p>I test the code using g++4.8.2 in Linux</p>\n<p>================================EDIT===============================\nAccording to the answers, the reason is because of :</p>\n<p>the code generated by compiler is <strong>NOT</strong>:</p>\n<pre><code>        ~Widget() {\n            delete pc; // wrote by me\n\n            // generated by compiler\n            delete pImpl-&gt;get();\n        }\n</code></pre>\n<p>it maybe something like:</p>\n<pre><code>        ~Widget() {\n            delete pc; // wrote by me\n\n            // generated by compiler\n            pimpl.deleter(); //deleter will be initailized while pimpl object is initialized\n        }\n</code></pre>\n", "AcceptedAnswerId": "29062887", "Title": "Why does incomplete type of smart pointer data member and raw pointer data member have different behavior when their parent destruct?", "CreationDate": "2015-03-15T15:53:32.487", "Id": "29062695", "CommentCount": "10", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-03-15T21:26:42.617", "LastEditorUserId": "440403", "LastActivityDate": "2015-03-25T01:31:06.427", "Score": "10", "OwnerUserId": "440403", "Tags": "<c++><c++11><smart-pointers>", "AnswerCount": "3"}, "29245978": {"Id": "29245978", "PostTypeId": "2", "Body": "<p>A <code>shared_ptr&lt;T&gt;</code> is 3 and a half things.</p>\n<p>It is a pointer to <code>T</code>, a Deleter, and a reference count.  It is also a weak reference count (that is the half).</p>\n<p>The Deleter tells the <code>shared_ptr&lt;T&gt;</code> what to do when the reference count hits 0.  It is, in a sense, unrelated to the pointer to <code>T</code>: you can use what I call the \"god mode\" shared pointer constructor to completely divorce them -- <code>shared_ptr&lt;T&gt;::shared_ptr( shared_ptr&lt;U&gt;, T* )</code> -- and get your reference count from the <code>shared_ptr&lt;U&gt;</code> and your pointer from the <code>T*</code>.</p>\n<p>The point where the Deleter is bound is at construction: the two most common ways are via <code>shared_ptr&lt;T&gt;::shared_ptr(T*)</code> or via <code>make_shared&lt;T&gt;</code>.  At that point, what happens when the reference count returns to 0 is fixed.</p>\n<p>You can copy the <code>shared_ptr&lt;T&gt;</code> into a <code>shared_ptr&lt;Base&gt;</code> and the Deleter follows along.  You can \"god mode\" steal the reference count, and pass a pointer to a member variable as the type pointed to: and the original Deleter follows along.</p>\n<p>When a <code>shared_ptr&lt;T&gt;</code> is reaches 0 reference count, it has <em>no idea</em> what it will do to destroy: the Deleter is some arbitrary task at thd point of destruction, decided at the point of construction.</p>\n<p>So if \"how to destroy the T\" was visible where the smart pointer was created, you are fine.  In comparison, a call to <code>delete ptr;</code> directly needs thd \"how to destroy T\" to be visible <em>at the point of deletion</em>.</p>\n<p>And that is why you get the different behaviour.</p>\n", "LastActivityDate": "2015-03-25T01:31:06.427", "CommentCount": "0", "CreationDate": "2015-03-25T01:31:06.427", "ParentId": "29062695", "Score": "0", "OwnerUserId": "1774667"}, "29062887": {"Id": "29062887", "PostTypeId": "2", "Body": "<p>Because you forward declaration \"CAT\" in the header file, you have an incomplete data type.  With this information the compiler fall into undefined behavior and the destructor may not be called. </p>\n<p>What the standard says</p>\n<blockquote>\n<p id=\"so_29062695_29062887_0\">if the object being deleted has incomplete class type at the point of\n  deletion and the complete class has a non-trivial destructor or a\n  deallocation function, the behavior is undefined.</p>\n</blockquote>\n<p>Here you can find a detailed explanation: <a href=\"https://stackoverflow.com/questions/2517245/why-really-deleting-an-incomplete-type-is-undefined-behaviour\">Why, really, deleting an incomplete type is undefined behaviour?</a>\nJust moving the struct declaration to before the class definition should fix your problem:</p>\n<pre><code>struct CAT\n{\n    std::string name;\n    CAT(){std::cout&lt;&lt;\"CAT\"&lt;&lt;std::endl;}\n    ~CAT(){std::cout&lt;&lt;\"~CAT\"&lt;&lt;std::endl;}\n};\n\nclass Widget {\n    public:\n        Widget();\n        ~Widget() {\n            delete pc; // I know we should put this code to cpp\n                       // I am just want to show the difference behavior\n                       // between raw pointer and smart pointer\n                       // when widget object destruct\n        }\n    private:\n        struct Impl;\n        std::shared_ptr&lt;Impl&gt; pImpl;  // use smart pointer\n        CAT *pc;  //raw pointer\n};\n</code></pre>\n<p>And the output</p>\n<pre><code>Impl\nCAT\n~CAT\n~Impl\n</code></pre>\n<p>Forward declarations are good to speed up compilation time, but can lead to problems when more information about the data type is needed.</p>\n<p>But why does it work for smart pointers?\nHere's a better explanation: <a href=\"https://stackoverflow.com/questions/5606750/deletion-of-pointer-to-incomplete-type-and-smart-pointers\">Deletion of pointer to incomplete type and smart pointers</a></p>\n<p>Basically, the shared_ptr only needs the declaration when it initializes or resets the pointer.  That means it doesn't need the complete type on the moment of the declaration.</p>\n<blockquote>\n<p id=\"so_29062695_29062887_1\">This functionality isn't free:  shared_ptr has to create and store a\n  pointer to the deleter functor; typically this is done by storing the\n  deleter as part of the block that stores the strong and weak reference\n  counts or by having a pointer as part of that block that points to the\n  deleter (since you can provide your own deleter).</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-03-19T02:06:53.337", "Score": "13", "CreationDate": "2015-03-15T16:08:44.780", "ParentId": "29062695", "CommentCount": "2", "OwnerUserId": "1742659", "LastEditDate": "2017-05-23T12:30:55.410"}});