post_cb({"9157041": {"ViewCount": "3017", "Body": "<p>In the C++ standard, \u00a713.3.1.7 [over.match.list], the following is stated:</p>\n<blockquote>\n<p id=\"so_9157041_9157041_0\">In copy-list-initialization, if an <code>explicit</code> constructor is chosen, the initialization is ill-formed.</p>\n</blockquote>\n<p>This is the reason why we can't do, for example, something like this:</p>\n<pre><code>struct foo {\n    // explicit because it can be called with one argument\n    explicit foo(std::string s, int x = 0);\nprivate:\n    // ...\n};\n\nvoid f(foo x);\n\nf({ \"answer\", 42 });\n</code></pre>\n<p><sub>(Note that what happens here is <strong>not a conversion</strong>, and it would not be one even if the constructor was \"implicit\". This is initialization of a <code>foo</code> object using its constructor directly. Other than the <code>std::string</code>, there is no conversion here.)</sub></p>\n<p>This seems perfectly fine to me. There's no way that an implicit conversion will bite me.</p>\n<p>If <code>{ \"answer\", 42 }</code> can initialize something else, the compiler won't betray me and do the wrong thing:</p>\n<pre><code>struct bar {\n    // explicit because it can be called with one argument\n    explicit bar(std::string s, int x = 0);\nprivate:\n    // ...\n};\n\nvoid f(foo x);\nvoid f(bar x);\n\nf({ \"answer\", 42 }); // error: ambiguous call\n</code></pre>\n<p>There's no problem: the call is ambiguous, the code won't compile, and I'll have to pick the overload explicitly.</p>\n<pre><code>f(bar { \"answer\", 42 }); // ok\n</code></pre>\n<p>Since the prohibition is explicitly stated, I have the feeling that I am missing something here. As far as I can see, list initialization picking explicit constructors doesn't seem like a problem to me: by using list initialization syntax the programmer is already expressing the desire to do some kind of \"conversion\".</p>\n<p>What could go wrong? What am I missing?</p>\n", "AcceptedAnswerId": "9158696", "Title": "What could go wrong if copy-list-initialization allowed explicit constructors?", "CreationDate": "2012-02-06T07:49:18.710", "Id": "9157041", "CommentCount": "7", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2014-02-12T16:12:32.827", "LastEditorUserId": "923854", "LastActivityDate": "2015-09-08T08:59:25.000", "Score": "36", "OwnerUserId": "46642", "Tags": "<c++><c++11><initializer-list><explicit-constructor>", "AnswerCount": "4"}, "9158696": {"Id": "9158696", "PostTypeId": "2", "Body": "<p>Conceptually copy-list-initialization is the conversion of a compound value to a destination type. The paper that proposed wording and explained rationale already considered the term \"copy\" in \"copy list initialization\" unfortunate, since it doesn't really convey the actual rationale behind it. But it is kept for compatibility with existing wording. A <code>{10, 20}</code> pair/tuple value should not be able to copy initialize a <code>String(int size, int reserve)</code>, because a string is not a pair.</p>\n<p>Explicit constructors are considered but forbidden to be used. This makes sense in cases as follows</p>\n<pre><code>struct String {\n  explicit String(int size);\n  String(char const *value);\n};\n\nString s = { 0 };\n</code></pre>\n<p><code>0</code> does not convey the value of a string. So this results in an error because <em>both</em> constructors are considered, but an <code>explicit</code> constructor is selected, instead of the <code>0</code> being treated as a null pointer constant. </p>\n<p>Unfortunately this also happens in overload resolution across functions</p>\n<pre><code>void print(String s);\nvoid print(std::vector&lt;int&gt; numbers);\n\nint main() { print({10}); }\n</code></pre>\n<p>This is ill-formed too because of an ambiguity. Some people (including me) before C++11 was released thought that this is unfortunate, but didn't came up with a paper proposing a change regarding this (as far as I am aware).</p>\n", "LastEditorUserId": "1938163", "LastActivityDate": "2015-09-08T08:59:25.000", "Score": "23", "CreationDate": "2012-02-06T10:26:06.933", "ParentId": "9157041", "CommentCount": "5", "LastEditDate": "2015-09-08T08:59:25.000", "OwnerUserId": "34509"}, "9158170": {"Id": "9158170", "PostTypeId": "2", "Body": "<p>This statement:</p>\n<blockquote>\n<p id=\"so_9157041_9158170_0\">In copy-list-initialization, if an <code>explicit</code> constructor is chosen, the initialization is ill-formed.</p>\n</blockquote>\n<p>means many things. Among them, it means that it must <em>look</em> at explicit constructors. After all, it can't select an explicit constructor if it can't look at it. When it looks for candidates to convert the braced list into, it must select from all candidates. Even the ones that will <em>later</em> be found to be illegal.</p>\n<p>If overload resolution results in multiple functions being equally viable, then it results in an ambiguous call that requires manual user intervention.</p>\n", "LastActivityDate": "2012-02-06T09:39:26.300", "Score": "2", "CreationDate": "2012-02-06T09:39:26.300", "ParentId": "9157041", "CommentCount": "0", "OwnerUserId": "734069"}, "9157544": {"Id": "9157544", "PostTypeId": "2", "Body": "<p>Isn't it because 'explicit' is there to stop implicit casting, and you're asking it to do an implicit cast?</p>\n<p>Would you be asking the question if you has specified the structure with a single argument constructor?</p>\n", "LastActivityDate": "2012-02-06T08:46:02.780", "Score": "1", "CreationDate": "2012-02-06T08:46:02.780", "ParentId": "9157041", "CommentCount": "1", "OwnerUserId": "1182921"}, "bq_ids": {"n4140": {"so_9157041_9158170_0": {"length": 6, "quality": 1.0, "section_id": 599}, "so_9157041_9157041_0": {"length": 6, "quality": 1.0, "section_id": 599}}, "n3337": {"so_9157041_9158170_0": {"length": 6, "quality": 1.0, "section_id": 589}, "so_9157041_9157041_0": {"length": 6, "quality": 1.0, "section_id": 589}}, "n4659": {"so_9157041_9158170_0": {"length": 6, "quality": 1.0, "section_id": 622}, "so_9157041_9157041_0": {"length": 6, "quality": 1.0, "section_id": 622}}}, "9157535": {"Id": "9157535", "PostTypeId": "2", "Body": "<p>As I understand the very purpose of the keyword <strong>explicit</strong> is denying implicit cast with this constructor.</p>\n<p>So you are asking why explicit constructor cannot be used for implicit cast? Obviously because the author of that constructor explicitly denied it by using keyword <strong>explicit</strong> with it. The quote from the standard you've posted just states that <strong>explicit</strong> keyword applies also to initializer-lists (not just to simple values of some type).</p>\n<p><strong>ADD:</strong></p>\n<p>To say more correctly: the purpose of the keyword <strong>explicit</strong> used with some constructor is making it absolutely clear that this constructor is used in some place (i.e. forcing all the code to invoke this constructor explicitly).</p>\n<p>And IMO statement like <code>f({a,b})</code> when <code>f</code> is a name of the function has nothing to do with explicit constructor call. It is absolutely unclear (and context dependent) which constructor (and what type) is used here, e.g. it depends on function overloads present.</p>\n<p>On the other hand something like <code>f(SomeType(a,b))</code> is totally different thing - it is absolutely clear that we use the constructor of type <code>SomeType</code> that takes two arguments <code>a,b</code> and that we use the function <code>f</code> overload that will be the best to accept single argument of type <code>SomeType</code>.</p>\n<p>So some constructors are OK for implicit use like <code>f({a,b})</code> and others require that the fact of their using is absolutely clear to the reader that is why we declare them <strong>explicit</strong>.</p>\n<p><strong>ADD2:</strong></p>\n<p>My point is: Sometimes it absolutely makes sense to declare constructors explicit even if nothing could go wrong. IMO whether constructor is explicit is more a matter of its logic than caveats of any kind.</p>\n<p>E.g.</p>\n<pre><code>double x = 2; // looks absolutely natural\nstd::complex&lt;double&gt; x1 = 3;  // also looks absolutely natural\nstd::complex&lt;double&gt; x2 = { 5, 1 };  // also looks absolutely natural\n</code></pre>\n<p>But</p>\n<pre><code>std::vector&lt; std::set&lt;std::string&gt; &gt;  seq1 = 7; // looks like nonsense\nstd::string str = some_allocator; // also looks stupid\n</code></pre>\n", "LastEditorUserId": "569852", "LastActivityDate": "2012-02-08T00:53:05.043", "Score": "2", "CreationDate": "2012-02-06T08:45:18.147", "ParentId": "9157041", "CommentCount": "4", "LastEditDate": "2012-02-08T00:53:05.043", "OwnerUserId": "569852"}});