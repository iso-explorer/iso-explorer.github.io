post_cb({"27376365": {"CommentCount": "6", "ViewCount": "160", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-12-09T10:13:21.840", "LastActivityDate": "2014-12-11T08:21:23.937", "Title": "In-class friend operator doesn't seem to participate in overload resolution", "AcceptedAnswerId": "27376675", "LastEditDate": "2017-05-23T12:06:36.993", "Id": "27376365", "Score": "3", "Body": "<p>While writing a CRTP template that enables classes to provide overloads for <code>operator+</code> based on template arguments, I found that an in-class friend operator doesn't seem to participate in overload resolution if none of it's arguments is of the type of the class it was defined in.</p>\n<p>Boiled down:</p>\n<pre><code>enum class FooValueT{\n    zero, one, two\n};\n\nclass Foo{\n    FooValueT val_;\npublic:\n    Foo(FooValueT x) : val_(x){};\n\n    Foo&amp; operator+=(Foo other){\n        val_ = (FooValueT)((int)val_ + (int)other.val_);\n        return *this;\n    }\n\n    //overload for Foo+Foo, FooValueT+Foo and Foo+FooValueT\n    friend Foo operator+(Foo lhs, Foo rhs){\n        Foo ret = lhs;\n        return ret += lhs;\n    }\n\n    //explicit overload for FooValueT+FooValueT\n    friend Foo operator+(FooValueT lhs, FooValueT rhs){\n        return (Foo)lhs + (Foo)rhs;\n    }\n};\n</code></pre>\n<p>Looks a bit excessive, but is necessary since <code>Foo my = FooValueT::one + FooValueT::zero;</code> should be a valid expression and if none of the arguments has class-type, they are not implicitly converted, as explained in <a href=\"https://stackoverflow.com/questions/27361230/implicit-conversion-of-lefthand-argument-in-in-class-declared-friend-operator/27361572#27361572\">this answer</a> to a previous question of mine.</p>\n<p>Despite all this effort, the following code does not compile:</p>\n<pre><code>int main(int argc, char* argv[])\n{\n    Foo my = FooValueT::zero;\n    my += FooValueT::one;\n    my = Foo(FooValueT::zero) + FooValueT::two;\n    my = FooValueT::zero + Foo(FooValueT::two);\n    my = FooValueT::zero + FooValueT::two; //error C2676\n    return 0;\n}\n</code></pre>\n<p>The error message is:</p>\n<pre><code>error C2676: binary '+' : 'FooValueT' does not define this operator or a conversion to a type acceptable to the predefined operator\n</code></pre>\n<p>This problem resolves once I either move the operator out of the class completely, or declare it as a friend but define it outside the class. Neither of both seem to be viable options when <code>Foo</code> is a template class that is to be derived from.</p>\n<p>As far as I know, the above in-class friend definition of <code>operator+(ValueT,ValueT)</code> should create a free function, just as this definition would:</p>\n<pre><code>class Foo{\n/*All the stuff you saw previously*/\n    friend Foo operator+(FooValueT lhs, FooValueT rhs);\n};\n\nFoo operator+(FooValueT lhs, FooValueT rhs){\n    return (Foo)lhs + (Foo)rhs;\n}\n</code></pre>\n<p>Where am I going wrong here? Does in-class friend definition of functions change the rules of overload resolution compared to regular free friend functions?</p>\n", "Tags": "<c++><operator-overloading><overloading><friend>", "OwnerUserId": "2533467", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27376365_27376675_1": {"section_id": 6690, "quality": 0.9444444444444444, "length": 17}, "so_27376365_27376675_0": {"section_id": 6689, "quality": 1.0, "length": 15}}, "n3337": {"so_27376365_27376675_1": {"section_id": 6445, "quality": 0.9444444444444444, "length": 17}, "so_27376365_27376675_0": {"section_id": 6444, "quality": 1.0, "length": 15}}, "n4659": {"so_27376365_27376675_1": {"section_id": 8165, "quality": 0.9444444444444444, "length": 17}, "so_27376365_27376675_0": {"section_id": 8164, "quality": 1.0, "length": 15}}}, "27376675": {"ParentId": "27376365", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>n3376 11.3/6-7</p>\n<blockquote>\n<p id=\"so_27376365_27376675_0\">A function can be defined in a friend declaration of a class if and\n  only if the class is a non-local class (9.8), the function name is\n  unqualified, and the function has namespace scope.</p>\n<p id=\"so_27376365_27376675_1\">Such a function is implicitly inline. <strong>A friend function defined in a\n  class is in the (lexical) scope of the class in which it is defined. A\n  friend function defined outside the class is not (3.4.1).</strong></p>\n</blockquote>\n<p>In your case operator is in class-scope and when you are trying to call this operator, ADL will not try to find operator in class, since neither argument has type of this class. Just write free function (or friend with declaration not in class).</p>\n<p>Seems like you cannot do something like this, problem with declaration of friend function in class is that function will be in class-scope, but you cannot declare this function to be free friend function, since compiler cannot infer return-type parameter.</p>\n", "OwnerUserId": "1498580", "LastEditorUserId": "1498580", "LastEditDate": "2014-12-11T08:21:23.937", "Id": "27376675", "Score": "3", "CreationDate": "2014-12-09T10:28:05.983", "LastActivityDate": "2014-12-11T08:21:23.937"}});