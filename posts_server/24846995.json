post_cb({"24847058": {"ParentId": "24846995", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>To be more precise, the <em>Requires</em> section of the spec of <code>condition_variable::wait()</code> is (N3936 \u00a730.5.1 [thread.condition.condvar]/p9):</p>\n<blockquote>\n<pre><code>void wait(unique_lock&lt;mutex&gt;&amp; lock);\n</code></pre>\n<p id=\"so_24846995_24847058_0\"><em>Requires</em>: <code>lock.owns_lock()</code> is <code>true</code> and <code>lock.mutex()</code> is locked by\n  the calling thread, and either</p>\n<p id=\"so_24846995_24847058_1\">\u2014 no other thread is waiting on this <code>condition_variable</code> object or</p>\n<p id=\"so_24846995_24847058_2\">\u2014 <code>lock.mutex()</code> returns the same value for each of the lock arguments supplied by all concurrently\n  waiting (via <code>wait</code>, <code>wait_for</code>, or <code>wait_until</code>) threads.</p>\n</blockquote>\n<p>Thus, every thread concurrently waiting on a <code>condition_variable</code> must pass in the same mutex. It is technically allowed for two threads to wait on a <code>condition_variable</code> using one mutex, and then after both wait terminates (and no thread is waiting on the <code>condition_variable</code>), for them to both wait on the same object using a different mutex. I do not know whether there are any realistic use cases for this.</p>\n<p>Note also that <code>std::condition_variable_any::wait()</code> does not have such a requirement. The only requirement on the type supplied is that it meets <code>BasicLockable</code> requirements, which basically means that it has <code>lock()</code> and <code>unlock()</code>.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2017-02-15T15:45:41.500", "Id": "24847058", "Score": "3", "CreationDate": "2014-07-20T03:28:19.533", "LastActivityDate": "2017-02-15T15:45:41.500"}, "24847022": {"ParentId": "24846995", "CommentCount": "4", "Body": "<p>Your mutex in <code>ThreadPool::threadLoop</code> is a local variable. That means that different threads are locking on different mutexes. This is invalid: condition variables are tied to a specific mutex and you must acquire a lock for <em>that</em> mutex before waiting on the condition.</p>\n<p>You should declare a <code>_mutex</code> (or, even better, use the <code>mutex_</code> naming convention: underscore-prefix identifiers are mostly reserved) member variable in your <code>ThreadPool</code> class, and always lock on <em>that</em>.</p>\n", "OwnerUserId": "13", "PostTypeId": "2", "Id": "24847022", "Score": "3", "CreationDate": "2014-07-20T03:18:53.783", "LastActivityDate": "2014-07-20T03:18:53.783"}, "24846995": {"CommentCount": "0", "AcceptedAnswerId": "24847058", "PostTypeId": "1", "LastEditorUserId": "13", "CreationDate": "2014-07-20T03:13:19.207", "LastActivityDate": "2017-02-15T15:45:41.500", "LastEditDate": "2014-07-20T03:23:09.043", "ViewCount": "2227", "FavoriteCount": "1", "Title": "condition_variable throwing system_error with Xcode - fine with VStudio", "Id": "24846995", "Score": "1", "Body": "<p>I'm getting an error every time I try waiting on my condition_variable when compiling in Xcode. Error is \"terminating with uncaught exception of type std::__1::system_error: condition_variable wait failed: Invalid argument\"</p>\n<p>Everything works fine in Visual Studio 2013. Code works if I decide to not wait on the same condition_variable from multiple threads. Grrrr.</p>\n<p>Ok, code.</p>\n<p>main.cpp:</p>\n<pre><code>#include \"ThreadPool.h\"\n\nint main(int argc, const char * argv[])\n{\n    ThreadPool pool;\n    for (int i = 0; i &lt; 10; ++i)\n        pool.sendWork();\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(50000));\n    return 0;\n}\n</code></pre>\n<p>ThreadPool.h</p>\n<pre><code>#pragma once\n#include &lt;condition_variable&gt;\n#include &lt;vector&gt;\n#include &lt;thread&gt;\n\nclass ThreadPool\n{\nprotected:\n    std::condition_variable     _condition;\n\nprivate:\n    std::vector&lt;std::thread&gt;    _threads;\n    void threadLoop();\n\npublic:\n    ThreadPool();\n    void sendWork();\n};\n</code></pre>\n<p>ThreadPool.cpp:</p>\n<pre><code>#include \"ThreadPool.h\"\n\nThreadPool::ThreadPool()\n{\n    for (unsigned int i {0}; i &lt; 10; ++i)\n        _threads.push_back(std::thread(&amp;ThreadPool::threadLoop, this));\n}\nvoid ThreadPool::threadLoop()\n{\n    std::mutex mutex;\n    std::unique_lock&lt;std::mutex&gt; lock {mutex};\n    _condition.wait(lock);            // This is where the crash happens\n}\n\nvoid ThreadPool::sendWork()\n{\n    _condition.notify_one();\n}\n</code></pre>\n<p>This is a major simplification of the real code, but it's enough to trigger the crash.</p>\n<p>Is this supposed to work? Am I missing something here?</p>\n", "Tags": "<c++><multithreading><c++11>", "OwnerUserId": "3561240", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24846995_24847058_0": {"section_id": 2995, "quality": 0.875, "length": 7}, "so_24846995_24847058_1": {"section_id": 2995, "quality": 1.0, "length": 5}, "so_24846995_24847058_2": {"section_id": 2995, "quality": 1.0, "length": 16}}, "n3337": {"so_24846995_24847058_2": {"section_id": 2875, "quality": 1.0, "length": 16}, "so_24846995_24847058_1": {"section_id": 2865, "quality": 1.0, "length": 5}, "so_24846995_24847058_0": {"section_id": 2865, "quality": 0.875, "length": 7}}, "n4659": {"so_24846995_24847058_0": {"section_id": 3754, "quality": 0.875, "length": 7}, "so_24846995_24847058_1": {"section_id": 3754, "quality": 1.0, "length": 5}, "so_24846995_24847058_2": {"section_id": 3754, "quality": 1.0, "length": 16}}}});