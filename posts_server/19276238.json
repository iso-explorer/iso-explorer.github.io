post_cb({"19276448": {"Id": "19276448", "PostTypeId": "2", "Body": "<p>The call is ambiguous because the two operators do not overload. Overloading applies only to names that are defined in <strong>the same scope</strong>. <code>Base1</code> and <code>Base2</code> define two <strong>different</strong> scopes, so in the derived class the compiler simply sees two identical names that have no connection. As the other answers have said, the way to overcome this is to hoist both names into the derived class with appropriate <code>using</code> declarations; when that is done, the compiler sees the two names in the scope of the definition of the derived class, and applies overload resolution.</p>\n", "LastActivityDate": "2013-10-09T15:35:57.390", "CommentCount": "21", "CreationDate": "2013-10-09T15:35:57.390", "ParentId": "19276238", "Score": "4", "OwnerUserId": "1593860"}, "19276329": {"Id": "19276329", "PostTypeId": "2", "Body": "<p>Have you tried explicitly saying that Derived exposes both?</p>\n<pre><code>class Derived : public Base1, public Base2\n{\npublic:\n    using Base1::operator[];\n    using Base2::operator[];\n};\n</code></pre>\n<p>I have no idea whether it may work, I only have Visual here.</p>\n", "LastActivityDate": "2013-10-09T15:31:37.473", "CommentCount": "1", "CreationDate": "2013-10-09T15:31:37.473", "ParentId": "19276238", "Score": "0", "OwnerUserId": "1455631"}, "19276238": {"ViewCount": "389", "Body": "<p>Consider the following class:</p>\n<pre><code>class Foo\n{\n    public:\n\n    void operator [] (const std::string&amp; s) { }\n\n    void operator [] (std::size_t idx) { }\n};\n</code></pre>\n<p>Here, given an instance of <code>Foo f</code>, the expression <code>f[0]</code> is not ambiguous, because the compiler chooses the second overload.  Likewise, the expression <code>f[\"abc\"]</code> is not ambiguous, because the compiler chooses the first overload (since a <code>const char*</code> is convertible to an <code>std::string</code>).</p>\n<p>So, why is it then, that if we have two Base classes, each with a different overload, that there is suddenly ambiguity?</p>\n<p>Suppose we have:</p>\n<pre><code>class Base1\n{\n    public:\n\n    void operator [] (const std::string&amp; s) { }\n};\n\nclass Base2\n{\n    public:\n\n    void operator [] (std::size_t idx) { }\n};\n\nclass Derived : public Base1, public Base2\n{ };\n</code></pre>\n<p>Now, if we say:</p>\n<pre><code>Derived d;\nd[0];\n</code></pre>\n<p>The compiler complains:</p>\n<pre><code>    error: request for member \u2018operator[]\u2019 is ambiguous\n      d[0];\n         ^\n   note: candidates are: void Base2::operator[](std::size_t)\n      void operator [] (std::size_t idx) { }\n           ^\n   note:                 void Base1::operator[](const string&amp;)\n      void operator [] (const std::string&amp; s) { }\n</code></pre>\n<p>Why does the fact that both operator overloads are now in Base classes cause any ambiguity?  And is there some way to resolve this?  </p>\n<p><em><strong>EDIT</strong></em></p>: Could this be a compiler bug (I am using GCC 4.8.1)\n", "AcceptedAnswerId": "19277394", "Title": "Ambiguity with [] operator and multiple inheritance", "CreationDate": "2013-10-09T15:27:19.093", "Id": "19276238", "CommentCount": "10", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-10-09T15:33:23.057", "LastEditorUserId": "469408", "LastActivityDate": "2013-10-09T16:56:54.037", "ClosedDate": "2013-10-10T02:17:46.780", "Score": "11", "OwnerUserId": "469408", "Tags": "<c++>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_19276238_19277394_1": {"length": 24, "quality": 0.96, "section_id": 6994}, "so_19276238_19276546_1": {"length": 38, "quality": 0.9743589743589743, "section_id": 567}, "so_19276238_19276546_0": {"length": 49, "quality": 0.9423076923076923, "section_id": 566}, "so_19276238_19276546_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 569}, "so_19276238_19276546_3": {"length": 9, "quality": 1.0, "section_id": 569}, "so_19276238_19276546_4": {"length": 7, "quality": 1.0, "section_id": 569}}, "n3337": {"so_19276238_19276546_1": {"length": 38, "quality": 0.9743589743589743, "section_id": 558}, "so_19276238_19277394_1": {"length": 24, "quality": 0.96, "section_id": 6740}, "so_19276238_19276546_4": {"length": 7, "quality": 1.0, "section_id": 560}, "so_19276238_19276546_0": {"length": 49, "quality": 0.9423076923076923, "section_id": 557}, "so_19276238_19276546_3": {"length": 9, "quality": 1.0, "section_id": 560}, "so_19276238_19276546_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 560}}, "n4659": {"so_19276238_19276546_1": {"length": 38, "quality": 0.9743589743589743, "section_id": 590}, "so_19276238_19277394_1": {"length": 24, "quality": 0.96, "section_id": 8492}, "so_19276238_19276546_4": {"length": 7, "quality": 1.0, "section_id": 592}, "so_19276238_19276546_0": {"length": 49, "quality": 0.9423076923076923, "section_id": 589}, "so_19276238_19276546_3": {"length": 6, "quality": 0.6666666666666666, "section_id": 592}, "so_19276238_19276546_2": {"length": 19, "quality": 0.7916666666666666, "section_id": 592}}}, "19276546": {"Id": "19276546", "PostTypeId": "2", "Body": "<p>TL;DR: Although both functions are in the candidate set, the candidate set is also <em>invalid</em>, making the program ill-formed.  See <a href=\"https://stackoverflow.com/a/19277394/103167\">dribeas's answer</a> for details on that.</p>\n<hr>\n<p>Both functions are clearly viable, since:</p>\n<pre><code>f((size_t)0)\n</code></pre>\n<p>and</p>\n<pre><code>f((const char*)0)\n</code></pre>\n<p>are legal and both conversion sequences are implicit.</p>\n<p>Originally, the two candidates were not ambiguous because one was a better conversion than the other.  The compiler chose the one that required only an integral promotion.  Since an integral promotion was \"better\" than the other conversion sequence, it won.</p>\n<p>Now, both candidates require a pointer upcast.  Now the conversion sequence involving an upcast and integral promotion is no longer clearly better.  So the compiler cannot choose and it reports ambiguity.\n(Note: I think the conversion sequence without user-defined conversion should still be better, and that candidate <code>f(Base2* implicit, size_t)</code> should still win... but it is MUCH more complicated now, because of the overload resolution rules involving conversions of multiple arguments.)</p>\n<p>The \"using\" declaration allows the <code>this</code> pointer to be passed with an identity conversion instead of an upcast, so again one conversion sequence is just the integral promotion, which IS better.</p>\n<hr>\n<p>From section 13.3.1:</p>\n<blockquote>\n<p id=\"so_19276238_19276546_0\">The set of candidate functions can contain both member and non-member functions to be resolved against the same argument list. So that argument and parameter lists are comparable within this heterogeneous set, a member function is considered to have an extra parameter, called the <em>implicit object parameter</em>, which represents the object for which the member function has been called. For the purposes of overload resolution, both static and non-static member functions have an implicit object parameter, but constructors do not.</p>\n<p id=\"so_19276238_19276546_1\">Similarly, when appropriate, the context can construct an argument list that contains an <em>implied object argument</em> to denote the object to be operated on. Since arguments and parameters are associated by position within their respective lists, the convention is that the implicit object parameter, if present, is always the first parameter and the implied object argument, if present, is always the first argument.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_19276238_19276546_2\">During overload resolution, the implied object argument is indistinguishable from other arguments. The implicit object parameter, however, retains its identity since conversions on the corresponding argument shall obey these additional rules:</p>\n<ul>\n<li><p id=\"so_19276238_19276546_3\">no temporary object can be introduced to hold the argument for the implicit object parameter; and</p></li>\n<li><p id=\"so_19276238_19276546_4\">no user-defined conversions can be applied to achieve a type match with it.</p></li>\n</ul>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-10-09T16:56:54.037", "Score": "2", "CreationDate": "2013-10-09T15:40:29.163", "ParentId": "19276238", "CommentCount": "19", "OwnerUserId": "103167", "LastEditDate": "2017-05-23T12:16:12.117"}, "19276366": {"Id": "19276366", "PostTypeId": "2", "Body": "<pre><code>class Derived : public Base1, public Base2\n{ \n    public:\n    using Base1::operator[];\n    using Base2::operator[];\n};\n</code></pre>\n<p>Make the inherits explicit, so there is no need for the compiler to 'select a base'.</p>\n", "LastActivityDate": "2013-10-09T15:32:54.460", "CommentCount": "4", "CreationDate": "2013-10-09T15:32:54.460", "ParentId": "19276238", "Score": "2", "OwnerUserId": "85371"}, "19277394": {"Id": "19277394", "PostTypeId": "2", "Body": "<p>This is not an issue with <em>overload resolution</em>, but rather with member name lookup, which is defined in 10.2. Consider (as I'd rather not write <code>operator[]</code> everywhere):</p>\n<pre><code>struct base1 { void f(int); };\nstruct base2 { void f(double); };\nstruct derived : base1, base2 {};\nint main() {\n   derived d; d.f(0);\n}\n</code></pre>\n<p>When lookup for <code>f</code> starts in the postfix expression <code>d.f(0)</code>, it will first look into <code>derived</code> and find that <code>f</code> does not resolve to anything at all. 10.2/5 then requires that lookup proceeds to all base classes in parallel, constructing separate lookup sets. In this case, <em>S(f,base1) = { base1::f }</em>  and <em>S(f,base2) = { base2::f }</em>. The sets are then merged following the rules in 10.2/6. The first bullet deals with merging when one of the sets is empty or if the lookup for the different sets ended with the same member (consider that it hit a common base). The second bullet is the interesting one, as it applies here</p>\n<blockquote>\n<p id=\"so_19276238_19277394_0\">10.2/6 bullet 2</p>\n<p id=\"so_19276238_19277394_1\">Otherwise, if the declaration sets of S(f,Bi) and S(f,C) differ, the merge is <strong>ambiguous</strong>: the new S(f,C) is a lookup set with an invalid declaration set and the union of the subobject sets. In subsequent merges, an invalid declaration set is considered different from any other.</p>\n</blockquote>\n<p>That is, <em>S(f,base1)</em> differs from <em>S(f,base2)</em>, so <em>S(f,derived)</em> becomes an invalid declaration set. And lookup fails.</p>\n", "LastActivityDate": "2013-10-09T16:17:55.133", "CommentCount": "6", "CreationDate": "2013-10-09T16:17:55.133", "ParentId": "19276238", "Score": "9", "OwnerUserId": "36565"}});