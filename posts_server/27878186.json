post_cb({"39815543": {"ParentId": "27878186", "CommentCount": "0", "Body": "<p>The issue was finally resolved after we found that the executable linked against a dylib which was itself linked statically against the c++ runtime but was compiled with a different compiler (gcc 4.8 vs clang).</p>\n", "OwnerUserId": "4366545", "PostTypeId": "2", "Id": "39815543", "Score": "0", "CreationDate": "2016-10-02T09:16:09.410", "LastActivityDate": "2016-10-02T09:16:09.410"}, "27878186": {"CommentCount": "12", "ViewCount": "964", "PostTypeId": "1", "LastEditorUserId": "4366545", "CreationDate": "2015-01-10T16:03:54.923", "LastActivityDate": "2016-10-02T09:16:09.410", "Title": "dynamic_cast fails - depending on OS Version", "AcceptedAnswerId": "39815543", "LastEditDate": "2015-01-11T18:22:19.697", "Id": "27878186", "Score": "4", "Body": "<p>I have a dynamic cast which is failing. The class layout is like this:</p>\n<pre><code>class A1\n{\n    public:\nvirtual int foo1()=0;\n};\n\nclass A2\n{\n    public:\n    virtual int foo2();\n};\n\nclass A3\n{\npublic:\n   virtual int foo3();\n};\n\nclass B : public A1, public A2, public A3 \n{\n   int bar();\n};\n</code></pre>\n<p>Now I use pointers ( so no slicing can occur ) for the downcast.</p>\n<pre><code>main()\n{\n   B b;\n\n   A1* a1 = dynamic_cast&lt;A1*&gt; (&amp;b); // ok\n   B*  b1 = dynamic_cast&lt;B*&gt;  (a1); // ok\n\n   A2* a2_1 = dynamic_cast&lt;A2*&gt; (a1); // OSX 10.7 ok, OSX 10.9 fail\n   A2* a1_2 = dynamic_cast&lt;A2*&gt; (b1); // ok\n\n};\n</code></pre>\n<p>The downcast works, the upcast works but the sidecast does not work always. Under OSX 10.7 the sidecast works, under OSX 10.9 it does not ( GCC 4.2 using dynamic c++ stdlib). Looking at the vtable using gdb I can clearly see A2 methods and members listed.</p>\n<p>My questions:</p>\n<p>a) Is the sidecast technically correct? Should it work or is this a runtime bug?<br>\nb) If the sidecast depends on the runtime, where is this runtime defined? I always thought this is a part of the binary?<br>\nc) How does a failing dynamic_cast look like (when looking at assembly), and how can you track down such problems?  </br></br></p>\n<p>Update: this is what i see in the system console</p>\n<blockquote>\n<p id=\"so_27878186_27878186_0\">11/01/15 14:16:27,435 APPNAMECHANGED[15280]: dynamic_cast error 1: Both of the following type_info's should have public visibility.  At least one of them is hidden. 10A1, 15A2.</p>\n</blockquote>\n<p>So c) is answered, at least for OSX 10.9. Have a look at the console. (Linux, someone?)\nIt looks like a problem about symbol visibility. Doc says (gcc.gnu.org/wiki/Visibility)</p>\n<blockquote>\n<p id=\"so_27878186_27878186_1\">However, this isn't the full story - it gets harder. Symbol visibility is \"default\" by default but if the linker encounters just one definition with it hidden - just one - that typeinfo symbol becomes permanently hidden (remember the C++ standard's ODR - one definition rule). This is true for all symbols, but is more likely to affect you with typeinfos; typeinfo symbols for classes without a vtable are defined on demand within each object file that uses the class for EH and are defined weakly so the definitions get merged at link time into one copy.</p>\n</blockquote>\n<p>This leads to the next question,</p>\n<p>d) how can we track down which symbol get at least once marked hidden, and where and why? Is there a tool to inspect .o files?</p>\n", "Tags": "<c++><osx><gcc4>", "OwnerUserId": "4366545", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27878186_27878913_0": {"section_id": 6018, "quality": 1.0, "length": 9}}, "n3337": {"so_27878186_27878913_0": {"section_id": 5786, "quality": 1.0, "length": 9}}, "n4659": {"so_27878186_27878913_0": {"section_id": 7517, "quality": 1.0, "length": 9}}}, "27878913": {"ParentId": "27878186", "CommentCount": "0", "Body": "<p><sub>Disclaimer: I am only gonna address question a).  </sub><br/></p>\n<p>First of all, <code>B</code> is clearly a polymorphic type according to [class.virtual]/1 as it inherits a virtual function (to be precise, <code>B</code> inherits three distinct ones).<br>\nNow consider [expr.dynamic.cast]/8:</br></p>\n<blockquote>\n<p id=\"so_27878186_27878913_0\">If <code>C</code> is the class type to which <code>T</code> points or refers, the run-time\n  check logically executes as follows:</p>\n<ul>\n<li>If, in the most derived object pointed (referred) to by v, v points (refers) to a public base class\n     subobject of a <code>C</code> object, and if only one object of type <code>C</code> is derived from the subobject pointed (referred)\n    to by <code>v</code> the result points (refers) to that <code>C</code> object.</li>\n<li>Otherwise, <strong>if <code>v</code> points (refers) to a public base class subobject of the most derived object, and the type of the most derived object\n  has a base class, of type <code>C</code>, that is unambiguous and public, the\n  result points (refers) to the <code>C</code> subobject of the most derived\n  object.</strong></li>\n<li>Otherwise, the run-time check <em>fails</em>.</li>\n</ul>\n</blockquote>\n<p>So yes, it should work. </p>\n", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "27878913", "Score": "0", "CreationDate": "2015-01-10T17:16:45.777", "LastActivityDate": "2015-01-10T17:16:45.777"}});