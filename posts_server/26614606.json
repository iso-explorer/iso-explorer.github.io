post_cb({"26615252": {"ParentId": "26614606", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes, the the last <code>assert</code> is guaranteed to hold, because this form of placement-new must always return the passed pointer, not using any space for itself:</p>\n<blockquote>\n<h3>5.3.4 New <code>[expr.new]</code></h3>\n<p id=\"so_26614606_26615252_0\">8 A <em>new-expression</em> may obtain storage for the object by calling an <em>allocation function</em> (3.7.4.1). [...]<br>\n  10 An implementation is allowed to omit a call to a replaceable global <em>allocation function</em> (18.6.1.1, 18.6.1.2). When it does so, the storage is instead provided by the implementation or provided by extending the allocation of another <em>new-expression</em>. [...]<br>\n  11 When a new-expression calls an allocation function and <strong>that allocation has not been extended</strong>, the newexpression passes the amount of space requested to the allocation function as the first argument of type <code>std::size_t</code>. <strong>That argument shall be no less than the size of the object being created; it may be greater than the size of the object being created only if the object is an array.</strong><br>\n  [...]</br></br></br></p>\n</blockquote>\n<p>Your new-expression calls the global placement-new allocation-function.<br>\nThat is a non-replacable function, thus the allocation cannot be extended or omitted.<br>\nAlso, you are not allocating an array but a single object, thus no padding of the request may occur at all.</br></br></p>\n<blockquote>\n<h3>18.6.1.3 Placement forms <code>[new.delete.placement]</code></h3>\n<p id=\"so_26614606_26615252_1\">1 These functions are reserved, a C++ program may not define functions that displace the versions in the Standard C++ library (17.6.4). The provisions of (3.7.4) do not apply to these reserved placement forms of <code>operator new</code> and <code>operator delete</code>.</p>\n<pre><code>void* operator new(std::size_t size, void* ptr) noexcept;\n</code></pre>\n<p id=\"so_26614606_26615252_2\">2 Returns: <code>ptr</code>.<br>\n  3 Remarks: Intentionally performs no other action.</br></p>\n</blockquote>\n<p>And this guarantees that the allocation-function returns the passed pointer unchanged.</p>\n", "OwnerUserId": "3204551", "LastEditorUserId": "3204551", "LastEditDate": "2014-10-28T18:06:01.753", "Id": "26615252", "Score": "6", "CreationDate": "2014-10-28T17:58:07.793", "LastActivityDate": "2014-10-28T18:06:01.753"}, "26614740": {"ParentId": "26614606", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>Yes, the assertion will hold. Any <code>new</code> expression creating a single object must request exactly <code>sizeof(Test)</code> bytes of storage from the allocation function; and so it must place the object at the start of that storage in order to have enough room.</p>\n<p><em>Note</em>: This is based on the specification of a <em>new-expression</em> in C++11. It looks like C++14 will change the wording, so the answer may be different in the future.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2014-10-29T10:14:34.150", "Id": "26614740", "Score": "6", "CreationDate": "2014-10-28T17:29:54.773", "LastActivityDate": "2014-10-29T10:14:34.150"}, "26614661": {"ParentId": "26614606", "CommentCount": "6", "Body": "<p>This assertion will always hold, because <code>new</code> is required to return blocks of memory with MAXIMUM possible alignment. BTW - your first <code>assert()</code> is worthless, as normal <code>new</code> does not return <code>nullptr</code> - it throws or aborts, only \"nothrow <code>new</code>\" can return <code>nullptr</code>.</p>\n", "OwnerUserId": "157344", "PostTypeId": "2", "Id": "26614661", "Score": "11", "CreationDate": "2014-10-28T17:26:22.170", "LastActivityDate": "2014-10-28T17:26:22.170"}, "26614606": {"CommentCount": "6", "AcceptedAnswerId": "26614740", "CreationDate": "2014-10-28T17:23:02.303", "LastActivityDate": "2014-10-29T10:14:34.150", "PostTypeId": "1", "ViewCount": "1798", "FavoriteCount": "0", "Title": "Placement new and alignment in C++", "Id": "26614606", "Score": "12", "Body": "<p>Consider the following code snippet constructing an instance of a POD (plain old data) struct in-place:</p>\n<pre><code>#include &lt;new&gt;\n#include &lt;cassert&gt;\n#include &lt;cstddef&gt;\n\nstruct Test\n{\n    int a;\n    char b;\n    double c;\n};\n\nint main()\n{\n    const std::size_t minimumNumberOfBytes = sizeof( Test ) * 4;\n\n    // Get a block of memory that can accommodate a Test instance and then some!\n    void* const ptrToMemBlock = new char[ minimumNumberOfBytes ];\n    assert( ptrToMemBlock );\n\n    // Construct a Test instance in-place.\n    const Test* const testInstance( ::new ( ptrToMemBlock ) Test() );\n\n    // Is this assumption guaranteed to be true?\n    assert( testInstance == ptrToMemBlock );\n}\n</code></pre>\n<p>Is the assumption represented by the final assert() <strong>guaranteed</strong> to always be correct? Or is it conceivable that the compiler might decide to construct the Test instance, say a few bytes after the start of the memory block I specified in the placement-new call?</p>\n<p>Note that I'm asking specifically about POD types here. I know that things can get iffy if multiple inheritance and stuff like that gets involved.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "354633", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_26614606_26615252_0": {"section_id": 6092, "quality": 0.5151515151515151, "length": 34}, "so_26614606_26615252_2": {"section_id": 6859, "quality": 0.5714285714285714, "length": 4}, "so_26614606_26615252_1": {"section_id": 6857, "quality": 0.7727272727272727, "length": 17}}, "n3337": {"so_26614606_26615252_2": {"section_id": 6605, "quality": 0.5714285714285714, "length": 4}, "so_26614606_26615252_1": {"section_id": 6603, "quality": 0.7727272727272727, "length": 17}}, "n4659": {"so_26614606_26615252_0": {"section_id": 7588, "quality": 0.5303030303030303, "length": 35}, "so_26614606_26615252_2": {"section_id": 8351, "quality": 0.5714285714285714, "length": 4}, "so_26614606_26615252_1": {"section_id": 8349, "quality": 0.7727272727272727, "length": 17}}}});