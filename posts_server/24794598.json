post_cb({"bq_ids": {"n4140": {"so_24794598_24794857_1": {"length": 33, "quality": 1.0, "section_id": 3325}, "so_24794598_24794857_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 3325}}, "n3337": {"so_24794598_24794857_0": {"length": 17, "quality": 1.0, "section_id": 3195}}, "n4659": {"so_24794598_24794857_1": {"length": 28, "quality": 0.8484848484848485, "section_id": 4091}, "so_24794598_24794857_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 4091}}}, "24794598": {"ViewCount": "477", "Body": "<p>This code, with a <code>const A&amp; a</code> member in <code>B</code>, where <code>A</code> has a deleted copy constructor, doesn't compile in GCC 4.8.1, but it works OK in clang 3.4:</p>\n<pre><code>class A {\npublic:\n    A() = default;\n    A(const A&amp;) = delete;\n    A&amp; operator=(const A&amp;) = delete;\n};\n\nclass B{\npublic:\n    B(const A&amp; a)\n        : a{a}\n    { }\nprivate:\n    const A&amp; a;\n};\n\nint main()\n{\n    A a{};\n    B b{a};\n}\n</code></pre>\n<p>Which one of the compilers is right?</p>\n<p>The error in GCC is:</p>\n<pre><code>prog.cpp: In constructor \u2018B::B(const A&amp;)\u2019:\nprog.cpp:11:14: error: use of deleted function \u2018A::A(const A&amp;)\u2019\n        : a{a}\n            ^\nprog.cpp:4:5: error: declared here\n    A(const A&amp;) = delete;\n    ^\n</code></pre>\n<p>Ideone: <a href=\"http://ideone.com/x1CVwx\" rel=\"nofollow\">http://ideone.com/x1CVwx</a></p>\n", "AcceptedAnswerId": "24794857", "Title": "Initialization of const reference member with deleted copy constructor", "CreationDate": "2014-07-17T03:48:49.897", "Id": "24794598", "CommentCount": "13", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-10-29T22:15:09.557", "LastEditorUserId": "1505939", "LastActivityDate": "2014-10-29T22:15:09.557", "Score": "7", "OwnerUserId": "401753", "Tags": "<c++><c++11><reference><uniform-initialization>", "AnswerCount": "1"}, "24794857": {"Id": "24794857", "PostTypeId": "2", "Body": "<p>Your example can be reduced to</p>\n<pre><code>class A {\npublic:\n    A() = default;\n    A(const A&amp;) = delete;\n    A&amp; operator=(const A&amp;) = delete;\n};\n\nint main()\n{\n  A a{};\n  A const&amp; ar1(a); \n  A const&amp; ar2{a}; // fails on gcc 4.8\n}\n</code></pre>\n<p>The initialization of <code>ar2</code> fails on gcc-4.8 with the error</p>\n<pre><code>error: use of deleted function \u2018A::A(const A&amp;)\u2019\n</code></pre>\n<p>It compiles cleanly on clang3.4 and gcc4.9. This is the result of the resolution to CWG <a href=\"http://wg21.cmeerw.net/cwg/issue1288\" rel=\"noreferrer\">issue 1288</a>. </p>\n<p>N3337 contains the following language for <em>list-initialization</em>:</p>\n<p><em>\u00a78.5.4/3 [dcl.init.list]</em></p>\n<blockquote>\n<p id=\"so_24794598_24794857_0\">List-initialization of an object or reference of type <code>T</code> is defined as follows:<br/>\n  \u2014 <code>...</code><br/>\n  \u2014 Otherwise, if <code>T</code> is a reference type, a prvalue temporary of the type referenced by\n  <code>T</code> is list-initialized, and the reference is bound to that temporary</p>\n</blockquote>\n<p>This, of course, means that the initialization of <code>ar2</code> requires an accessible copy-constructor, hence the error.</p>\n<hr>\n<p>The language has changed in N3797, where the initialization from an initializer list containing a single element takes precedence over the case quoted above. </p>\n<blockquote>\n<p id=\"so_24794598_24794857_1\">\u2014 Otherwise, if the initializer list has a single element of type <code>E</code> and either <code>T</code> is not a reference type or its referenced type is reference-related to <code>E</code>, the object or reference is initialized from that element; <code>...</code><br/>\n  \u2014 Otherwise, if <code>T</code> is a reference type, a prvalue temporary of the type referenced by <code>T</code> is copy-list-initialized or direct-list-initialized, depending on the kind of initialization for the reference, and the reference is bound to that temporary.</p>\n</blockquote>\n<p>So gcc 4.9 and clang 3.4 are implementing the resolution of issue 1288, while gcc 4.8 is following the wording in the C++11 standard.</p>\n</hr>", "LastActivityDate": "2014-07-17T04:23:47.817", "CommentCount": "5", "CreationDate": "2014-07-17T04:23:47.817", "ParentId": "24794598", "Score": "9", "OwnerUserId": "241631"}});