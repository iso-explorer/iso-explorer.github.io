post_cb({"23685690": {"ParentId": "23685460", "CommentCount": "1", "Body": "<p>No, because rvalue references don't need to be <code>const</code>, so the Standard quote is correct</p>\n<pre><code>string &amp;&amp;s = string(\"hello\");\n</code></pre>\n<p>The lifetime is still enlargened. The constraints that make the code invalid for non-const lvalue reference is at clause 8 (notice that it is not the right place to just add \"const\" and \"rvalue reference\" etc in the paragraph you quoted. You need an <em>active rejection</em> of such bindings, not just saying that the lifetime of such bindings are not enlarged because you would leave the binding itself still wellformed). </p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "23685690", "Score": "4", "CreationDate": "2014-05-15T18:10:03.497", "LastActivityDate": "2014-05-15T18:10:03.497"}, "23686282": {"ParentId": "23685460", "CommentCount": "3", "Body": "<p>The word <code>const</code> was never present in this section.  The rule\nhas always been (from as long as I can remember) that\na temporary used to initialize a reference has its lifetime\nextended to match that of the reference, regardless of the type\nof the reference. </p>\n<p>Sometime in the late 1980's (very pre-standard), C++ introduced\nthe rule that a temporary could not be used to initialize\na non-const reference.  Initializing a non-const reference with\na temporary would still extend the lifetime (presumably), but\nsince you couldn't do it...  Most compilers implemented\na transition period, in which such an initialization would only\nemit a warning (and the lifetime was extended).</p>\n<p>For some reason, when Microsoft finally decided to implement\nC++ (some time in the early 1990's), they decided not to\nimplement the new rule, and allowed initialization of\na non-const reference with a temporary (without even a warning,\nat a time when most other vendors were gradually turning the\nwarning into an error).  And of course, the implemented the\nusual lifetime rule.</p>\n<p>Finally, in C++11, new types of references were introduced,\nwhich allowed (or even required) initialization with\na temporary.  The rule about the lifetime of temporaries hasn't\nchanged, though; a temporary which is used to initialize\na reference (regardless of the type of reference) has its\nlifetime extended.</p>\n<p>(With a few exceptions: I would not recommend using a temporary\nto initialize a class member reference in an initialization\nlist.)</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "23686282", "Score": "11", "CreationDate": "2014-05-15T18:43:58.713", "LastActivityDate": "2014-05-15T18:43:58.713"}, "23685580": {"ParentId": "23685460", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The behavior hasn't changed, you just need to turn your warning level up to <code>/W4</code>. VisualStudio implements the lifetime extension rule even for non-<code>const</code> lvalue references as a compiler extension. In this context, binding an rvalue to the non-<code>const</code> reference behaves the same as if you were binding it to a <code>const</code> reference.</p>\n<p>With <code>/W4</code> you'd see this:</p>\n<pre><code>warning C4239: nonstandard extension used : 'initializing' : conversion from 'Foo' to 'Foo &amp;'\n1&gt;  A non-const reference may only be bound to an lvalue\n</code></pre>\n<p>The text disallowing binding of an rvalue to a non-<code>const</code> lvalue reference can be found in <em>\u00a78.5.3/5</em></p>\n<blockquote>\n<p id=\"so_23685460_23685580_0\">\u2014 Otherwise, the reference shall be an lvalue reference to a non-volatile <code>const</code> type (i.e., <em>cv1</em> shall be\n  <code>const</code>), or the reference shall be an rvalue reference.<br/>[ Example:</p>\n<pre><code>  double&amp; rd2 = 2.0; // error: not an lvalue and reference not const\n  int i = 2;\n  double&amp; rd3 = i; // error: type mismatch and reference not const\n</code></pre>\n<p id=\"so_23685460_23685580_1\">\u2014end example ]</p>\n</blockquote>\n<p>The second half of the quoted statement is what allows binding of a temporary to an rvalue reference, as shown in <a href=\"https://stackoverflow.com/a/23685690/241631\">litb's answer</a>.</p>\n<pre><code>string &amp;&amp;s = string(\"hello\");\n</code></pre>\n<p>This, combined with the lifetime extension rule in <em>\u00a712.2/5</em>, means the lifetime of the temporary will now match the lifetime of the (rvalue) reference it is bound to.</p>\n", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2014-05-15T19:53:06.033", "Id": "23685580", "Score": "13", "CreationDate": "2014-05-15T18:03:59.670", "LastActivityDate": "2014-05-15T19:53:06.033"}, "bq_ids": {"n4140": {"so_23685460_23685460_0": {"section_id": 382, "quality": 0.5142857142857142, "length": 18}, "so_23685460_23685580_0": {"section_id": 3321, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_23685460_23685460_0": {"section_id": 373, "quality": 0.5142857142857142, "length": 18}, "so_23685460_23685580_0": {"section_id": 3191, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_23685460_23685580_0": {"section_id": 4087, "quality": 0.8461538461538461, "length": 11}}}, "23685460": {"CommentCount": "0", "AcceptedAnswerId": "23685580", "PostTypeId": "1", "LastEditorUserId": "3549027", "CreationDate": "2014-05-15T17:57:15.567", "LastActivityDate": "2014-05-15T19:53:06.033", "LastEditDate": "2014-05-15T19:34:04.943", "ViewCount": "735", "FavoriteCount": "2", "Title": "Do *non*-const references prolong the lives of temporaries?", "Id": "23685460", "Score": "14", "Body": "<p>Once upon a time, I assumed that code like this would fail:</p>\n<pre><code>const MyClass&amp; obj = MyClass();\nobj.DoSomething();\n</code></pre>\n<p>because the MyClass object would be destroyed at the end of its full-expression, leaving obj as a dangling reference. However, I learned (here) that this isn't true; the standard actually has a special provision that allows const references to keep temporaries alive until said references are destroyed themselves. But, it was emphasized, only <em>const</em> references have this power. Today I ran the code below in VS2012 as an experiment.</p>\n<pre><code>struct Foo\n{\n    Foo() { std::cout &lt;&lt; \"ctor\" &lt;&lt; std::endl; }\n    ~Foo() { std::cout &lt;&lt; \"dtor\" &lt;&lt; std::endl; }\n};\n\nvoid f()\n{\n    Foo&amp; f = Foo();\n    std::cout &lt;&lt; \"Hello world\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The output when calling <code>f()</code> was:</p>\n<pre><code>ctor  \nHello world  \ndtor  \n</code></pre>\n<p>So I had a look at the C++11 draft standard, and only found this (\u00a7 12.2/4):</p>\n<blockquote>\n<p id=\"so_23685460_23685460_0\">There are two contexts in which temporaries are destroyed at a\n  different point than the end of the full-expression. The first context [doesn't\n  apply]. The second context is when a reference is bound to a\n  temporary. The temporary to which the reference is bound or the\n  temporary that is the complete object of a subobject to which the\n  reference is bound persists for the lifetime of the reference.</p>\n</blockquote>\n<p>The word <code>const</code> is conspicuously absent from the above. So; has this behavior been changed for C++11, was I wrong about the <code>const</code> thing to begin with, or does VS2012 have a bug and I just haven't found the relevant part of the standard?</p>\n", "Tags": "<c++><visual-studio-2012><c++11><language-lawyer>", "OwnerUserId": "3549027", "AnswerCount": "3"}});