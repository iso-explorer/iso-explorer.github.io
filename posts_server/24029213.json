post_cb({"bq_ids": {"n4140": {"so_24029213_24029380_2": {"length": 21, "quality": 0.9545454545454546, "section_id": 639}, "so_24029213_24029380_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 603}}, "n3337": {"so_24029213_24029380_2": {"length": 21, "quality": 0.9545454545454546, "section_id": 629}, "so_24029213_24029380_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 593}}, "n4659": {"so_24029213_24029380_2": {"length": 21, "quality": 0.9545454545454546, "section_id": 667}, "so_24029213_24029380_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 629}}}, "24029380": {"Id": "24029380", "PostTypeId": "2", "Body": "<p>Given two competing overloads, the standard requires the compiler to select the overload that has the \"best fit\". (If there's no unique best overload, or if the unique best overload is inaccessible, the program is ill-formed.)</p>\n<p>In this case, the rules are provided by \u00a713.3.3.2 [over.ics.rank]/p3:</p>\n<blockquote>\n<p id=\"so_24029213_24029380_0\">Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if: </p>\n<ul>\n<li><p id=\"so_24029213_24029380_1\">[...]</p></li>\n<li><p id=\"so_24029213_24029380_2\">S1 and S2 are reference bindings (8.5.3), and the types to which the references refer are the same type except for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers is more cv-qualified than the type to which the reference initialized by S1 refers.</p></li>\n</ul>\n</blockquote>\n<p>This is the example given in the standard:</p>\n<pre><code>int f(const int &amp;);\nint f(int &amp;);\nint g(const int &amp;);\nint g(int);\nint i;\nint j = f(i); // calls f(int &amp;)\nint k = g(i); // ambiguous\n</code></pre>\n<p>In your case, <code>const T&amp;</code> is more cv-qualified than <code>T&amp;</code>, so by the standard, <code>f(T&amp;)</code> is a better fit than <code>f(const T&amp;)</code> and is selected by overload resolution.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-03T09:11:11.787", "Score": "6", "CreationDate": "2014-06-04T05:02:48.593", "ParentId": "24029213", "CommentCount": "5", "OwnerUserId": "2756719", "LastEditDate": "2014-08-03T09:11:11.787"}, "24030008": {"Id": "24030008", "PostTypeId": "2", "Body": "<ol>\n<li><p><strong><code>f(T&amp;)</code> vs. <code>f(T const&amp;)</code></strong><br>\nThe two functions are different, in that the first signature states that any variable passed by reference may be modified by the function. So the const float cannot be passed to the first function, and the second is the only viable choice for the compiler. A nonconst variable could be passed to both, so the compiler has to chose the better fit, if there is one. The standard says, that in order to call the second function, the compiler would have to add a <code>const</code> to any nonconst variable, while for the first function this is not necessary. Adding const is an implicit conversion, and it is a \"worse\" converison (read that as <em>more</em> conversion steps) than adding nothing. Therefore the standard demands that the compiler picks the first function when passing nonconst variables.<br>\nIn case you wonder: literals and temporaries can not be bound to nonconst references, so <code>f(4)</code>, <code>f(\"meow\")</code> and <code>f(someFunc())</code> will all call the second function.</br></br></p></li>\n<li><p><strong><code>f(T)</code> vs. <code>f(const T)</code></strong><br>\nThey look different, but aren't in terms of overload resolution or function signature. Both of them are call by value, or for the compiler: pass a copy of the argument into the function. The only difference is in a function definition, that you require the variable to be constant in the function body. Any function declaration does not affect the variable definition in the function definition's signature:</br></p>\n<pre><code>void f(int);          //a declaration\nvoid f(int i);        //redeclaration of the same function\nvoid f(int const);    //still the same function redeclared\nvoid f(int const i2); //yes... a redeclaration\n\nvoid f(int const i) { //at last a function definition and the copy of the argument used in the function body is required to be const\n  //...\n} \n\nvoid f(int i) {       //there is only one f, so this is a redefinition!\n  //...\n}  \n</code></pre>\n<p>This is not an \"ambuguos call type error\", because for the compiler there is only one function and no ambiguity. The error is simply that you did defin the same funciton twice. For that reason, it is preferred in many style guides that function declarations have no top-level const, and compilers will often ignore them and not mention them in error or warning messages.</p></li>\n</ol>\n", "LastActivityDate": "2014-06-04T05:54:32.867", "CommentCount": "0", "CreationDate": "2014-06-04T05:54:32.867", "ParentId": "24029213", "Score": "5", "OwnerUserId": "1838266"}, "24029213": {"ViewCount": "1337", "Body": "<p>I have the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nvoid f(T&amp; x)        \n{\n    std::cout &lt;&lt; \"f(T&amp; )\" &lt;&lt; std::endl; \n}\n\ntemplate &lt;typename T&gt;\nvoid f(const T&amp; x) \n{ \n    std::cout &lt;&lt; \"f(const T&amp; )\" &lt;&lt; std::endl; \n}\n\nint main() \n{\n    int a = 0;\n    const float b = 1.1;\n\n    f(a); // call f(T&amp;)\n    f(b); // call f(const T&amp;)\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>f(T&amp; )\nf(const T&amp; )\n</code></pre>\n<p>My question is: how does the compiler know which function to call? If I remove the references from the function definitions then I get an \"ambiguous call\" type of error, i.e. <code>error: redefinition of 'f'</code>. For me it looks like <code>f(T&amp;)</code> can be equally well used for both calls, why is the <code>const</code> version unambiguously called for <code>f(b)</code>?</p>\n", "AcceptedAnswerId": "24029380", "Title": "Overloading reference vs const reference", "CreationDate": "2014-06-04T04:46:04.530", "Id": "24029213", "CommentCount": "8", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-08-03T09:11:11.787", "Score": "8", "OwnerUserId": "3093378", "Tags": "<c++><pass-by-reference>", "AnswerCount": "2"}});