post_cb({"45900040": {"CommentCount": "2", "ViewCount": "69", "CreationDate": "2017-08-26T22:06:15.570", "LastActivityDate": "2017-08-27T02:31:18.987", "Title": "Class definitions in headers and ODR?", "AcceptedAnswerId": "45901227", "PostTypeId": "1", "Id": "45900040", "Score": "0", "Body": "<p>So we put class definitions in headers and we do not include translation units rather than headers because of the ODR (there probably are more reasons). Also, because of the ODR, you should not add definitions of variables and functions etc. in headers because it is likely to break the rule....</p>\n<p>But since <a href=\"http://en.cppreference.com/w/cpp/language/definition#One_Definition_Rule\" rel=\"nofollow noreferrer\">ODR also applies for class types</a> (which to me is class definitions), why can that be added in headers without caution?</p>\n", "Tags": "<c++>", "OwnerUserId": "8221510", "AnswerCount": "2"}, "45901227": {"ParentId": "45900040", "CommentCount": "5", "Body": "<p>There are several statements in the \"3.2 Ondefinition rule\" section of the standard, that covers different aspects of the rule.</p>\n<blockquote id=\"so_45900040_45901227_0\">\n<ol>\n<li>No translation unit shall contain more than one definition of any variable, function, class type, enumeration type, or template.</li>\n</ol>\n</blockquote>\n<p>This one covers the class type definition in your question, but this only applies to <strong>one translation unit</strong> (or source file). The same class type definition in the header included in different files (translations units) does not violate this, as it involves multiple-translations units (and there is still only one definition in any one of the translation units).</p>\n<blockquote id=\"so_45900040_45901227_1\">\n<ol start=\"3\">\n<li>Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required. The definition can appear explicitly in the program, it can be found\n  in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8). An inline function shall be defined in every translation unit in which it is odr-used.</li>\n</ol>\n</blockquote>\n<p>This rule covers the program level (may contain several translation units), but it only affects <strong>non-inline function or viable</strong> that are odr-used. Class type definition included in different translation units is not covered and does not violate this rule.</p>\n<p>And, there is a rule that specifically deals with definitions of a class type appearing in different translation units:</p>\n<blockquote>\n<ol start=\"5\">\n<li><p id=\"so_45900040_45901227_2\">There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with external linkage (7.1.2), class template (Clause 14), non-static function template (14.5.6), static data member\n  of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one translation unit, then</p>\n<ul>\n<li>each definition of D shall consist of the same sequence of tokens; and</li>\n<li>in each definition of D, corresponding names, looked up according to 3.4, shall refer to an entity defined within the definition of D, or shall refer to the same entity, after overload resolution (13.3) and after matching of partial template specialization (14.8.3), except that a name can refer to a const object\n  with internal or no linkage if the object has the same literal type in all definitions of D, and the object is initialized with a constant expression (5.19), and the value (but not the address) of the object is used, and the object has the same value in all definitions of D; and</li>\n<li>in each definition of D, corresponding entities shall have the same language linkage; and</li>\n<li>in each definition of D, the overloaded operators referred to, the implicit calls to conversion functions, constructors, operator new functions and operator delete functions, shall refer to the same function, or to a function defined within the definition of D; and</li>\n<li>in each definition of D, a default argument used by an (implicit or explicit) function call is treated as if its token sequence were present in the definition of D; that is, the default argument is subject to the three requirements described above (and, if the default argument has sub-expressions with default arguments, this requirement applies recursively).</li>\n<li>if D is a class with an implicitly-declared constructor (12.1), it is as if the constructor was implicitly defined in every translation unit where it is odr-used, and the implicit definition in every translation unit shall call the same constructor for a base class or a class member of D. </li>\n</ul></li>\n</ol>\n</blockquote>\n<p>In short, you can define the class type multiple times in different translation units, but each translation unit can have at most one definition, and all the definitions must be the same.</p>\n", "OwnerUserId": "1058916", "PostTypeId": "2", "Id": "45901227", "Score": "0", "CreationDate": "2017-08-27T02:31:18.987", "LastActivityDate": "2017-08-27T02:31:18.987"}, "bq_ids": {"n4140": {"so_45900040_45901227_0": {"section_id": 7038, "quality": 1.0, "length": 14}, "so_45900040_45901227_2": {"section_id": 7043, "quality": 0.9076923076923077, "length": 59}, "so_45900040_45901227_1": {"section_id": 7041, "quality": 0.8888888888888888, "length": 32}}, "n3337": {"so_45900040_45901227_0": {"section_id": 6784, "quality": 1.0, "length": 14}, "so_45900040_45901227_2": {"section_id": 6788, "quality": 0.9076923076923077, "length": 59}, "so_45900040_45901227_1": {"section_id": 6786, "quality": 0.8888888888888888, "length": 32}}, "n4659": {"so_45900040_45901227_0": {"section_id": 8535, "quality": 1.0, "length": 14}, "so_45900040_45901227_2": {"section_id": 8540, "quality": 0.9076923076923077, "length": 59}, "so_45900040_45901227_1": {"section_id": 8538, "quality": 0.8888888888888888, "length": 32}}}, "45900072": {"ParentId": "45900040", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>You are confusing between ODR and ODR-use.</p>\n<p>ODR of a type means that a class cannot defined more than once in a translation unit.</p>\n<p>If you have the following in a translation unit, the compiler should report an error since the ODR of type <code>foo</code> is violated.</p>\n<pre><code>struct foo {};\nstruct foo {};\n\nvoid bar() {}\n</code></pre>\n<p>ODR-use does not apply to types. It applies to non-inline functions and variables.</p>\n<p>Both ODR and ODR-use are described in <a href=\"http://en.cppreference.com/w/cpp/language/definition#One_Definition_Rule\" rel=\"nofollow noreferrer\">the link from your post</a>.</p>\n<p>An SO post on ODR-use: <a href=\"https://stackoverflow.com/questions/19630570/what-does-it-mean-to-odr-use-something\">What does it mean to \"ODR-use\" something?</a>.</p>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2017-08-26T22:17:30.730", "Id": "45900072", "Score": "3", "CreationDate": "2017-08-26T22:11:55.213", "LastActivityDate": "2017-08-26T22:17:30.730"}});