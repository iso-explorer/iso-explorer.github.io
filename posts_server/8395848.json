post_cb({"8395848": {"ViewCount": "518", "Body": "<p>Given this code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Foo {\npublic:\n    Foo ()          {   c = 'a'; cout &lt;&lt; \"Foo()\" &lt;&lt; endl;       }\n    Foo (char ch)   {   c = ch; cout &lt;&lt; \"Foo(char)\" &lt;&lt; endl;    }\n    ~Foo ()         {   cout &lt;&lt; \"~Foo()\" &lt;&lt; endl;               }\n\nprivate:\n    char c;\n};\n\nclass Bar : public Foo {\npublic:\n    Bar ()                      {   cout &lt;&lt; \"Bar()\" &lt;&lt; endl;    }\n    Bar (char ch) : Foo(ch)     {   cout &lt;&lt; \"Bar(char)\" &lt;&lt; endl;    }\n    ~Bar ()                     {   cout &lt;&lt; \"~Bar()\" &lt;&lt; endl;           }\n};\n\nFoo f1; static Bar b1;\n\nint main()\n{\n    Bar b2;\n\n    {\n        static Foo f2('c');\n        Foo f3;\n        Bar b3 ('d');\n    }\n\n    return 0;\n}\n</code></pre>\n<p><em>(You can just paste this directly into a compiler)</em></p>\n<p>The <em>first</em> part of my expected sample output is correct:</p>\n<pre><code>Foo()\nFoo() \nBar() \nFoo()\nBar()\nFoo(char) \nFoo()\nFoo(char)\nBar(char)\n~Bar()\n~Foo\n~Foo()\n~Bar()\n~Foo()\n~Foo()\n</code></pre>\n<p>But I get the destructor output of the two static objects <code>static Bar b1;</code> and <code>static Foo f2('c');</code> wrong.</p>\n<p>The correct answer for the last part is:</p>\n<pre><code>~Bar()\n~Foo()\n~Foo()\n</code></pre>\n<p>I get:</p>\n<pre><code>~Foo()\n~Bar()\n~Foo()\n</code></pre>\n<p>This is my reasoning:</p>\n<p>I understand that all local objects are destructed before static objects. Of the two remaining static objects <code>static Bar b1;</code> and <code>static Foo f2('c');</code>, <code>static Foo f2('c');</code> appears <em>last</em>, so it is destructed <em>first</em>, because destructors are called in the reverse order of their creation.</p>\n<p>But <code>static Foo f2('c');</code> isn't destructed first, <code>static Bar b1;</code> is. Why?</p>\n", "AcceptedAnswerId": "8395972", "Title": "(Simple C++ Concepts) Unexpected output of constructor/destructor calls", "CreationDate": "2011-12-06T05:41:50.953", "Id": "8395848", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-12-06T07:03:35.777", "Score": "3", "OwnerUserId": "555547", "Tags": "<c++><inheritance><constructor><destructor>", "AnswerCount": "2"}, "8395972": {"Id": "8395972", "PostTypeId": "2", "Body": "<p>Modified you program :</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Foo {\npublic:\n    Foo ()          {   c = 'a'; cout &lt;&lt; \"Foo()\" &lt;&lt; endl;       }\n    Foo (char ch)   {   c = ch; cout &lt;&lt; \"Foo(char)\" &lt;&lt; ch &lt;&lt; endl;    }\n    ~Foo ()         {   cout &lt;&lt; \"~Foo()\"&lt;&lt; c &lt;&lt; endl;               }\n\nprotected:\n    char c;\n};\n\nclass Bar : public Foo {\npublic:\n    Bar ()                      {   cout &lt;&lt; \"Bar()\" &lt;&lt; endl;    }\n    Bar (char ch) : Foo(ch)     {   cout &lt;&lt; \"Bar(char)\" &lt;&lt; ch &lt;&lt; endl;    }\n    ~Bar ()                     {   cout &lt;&lt; \"~Bar()\" &lt;&lt; c &lt;&lt; endl;           }\n};\n\nFoo f1('a'); static Bar b1('b');\n\nint main()\n{\n    Bar b2('c');\n\n    {\n        static Foo f2('d');\n        Foo f3('e');\n        Bar b3 ('f');\n    }\n\n    return 0;\n}\n</code></pre>\n<p>Which generates the following output in g++ 4.5.2:</p>\n<pre><code>Foo(char)a\nFoo(char)b\nBar(char)b\nFoo(char)c\nBar(char)c\nFoo(char)d\nFoo(char)e\nFoo(char)f\nBar(char)f\n~Bar()f\n~Foo()f\n~Foo()e\n~Bar()c\n~Foo()c\n~Foo()d\n~Bar()b\n~Foo()b\n~Foo()a\n</code></pre>\n<p>You see that the last destructed one is the non-static global variable <code>Foo f1</code>.</p>\n<p>EDIT:\nAs the others mentioned, the initialization order of variables with static storage duration is unspecific if the variables are from different translation units, but they can be defined when they are in the same translation unit.</p>\n<p>Initialization by constructor calls (as in this examples) are called <code>dynamic initialization</code>, and </p>\n<blockquote>\n<p id=\"so_8395848_8395972_0\"><strong>Dynamic initialization of a non-local variable with static storage\n  duration is either ordered or unordered</strong>. Definitions of explicitly\n  specialized class template static data members have ordered\n  initialization. Other class template static data members (i.e.,\n  implicitly or explicitly instantiated specializations) have unordered\n  initialization. <strong>Other non-local variables with static storage duration\n  have ordered initialization. Variables with ordered initialization\n  defined within a single translation unit shall be initialized in the\n  order of their definitions in the translation unit.</strong></p>\n<p id=\"so_8395848_8395972_1\">It is implementation-defined whether the dynamic initialization of a\n  non-local variable with static storage duration is done before the\n  first statement of main. If the initialization is deferred to some\n  point in time after the first statement of main, it shall occur before\n  the first odr-use (3.2) of any function or variable defined in the\n  same translation unit as the variable to be initialized.</p>\n</blockquote>\n<p>The initialization of local static variables is specified as</p>\n<blockquote>\n<p id=\"so_8395848_8395972_2\">... such a variable\n  is initialized the first time control passes through its declaration; ...</p>\n</blockquote>\n<p>And as the destruction of variables with static storage duration should be in the reverse order of their construction, so the order of construction and destruction of the variables with types <code>Foo</code> and <code>Bar</code> in this example is in fact defined.</p>\n<p>Again, when you have multiple translation, you'd better not to rely on the order of initialization.</p>\n", "LastEditorUserId": "1058916", "LastActivityDate": "2011-12-06T07:03:35.777", "Score": "3", "CreationDate": "2011-12-06T06:01:18.240", "ParentId": "8395848", "CommentCount": "2", "OwnerUserId": "1058916", "LastEditDate": "2011-12-06T07:03:35.777"}, "bq_ids": {"n4140": {"so_8395848_8395972_2": {"length": 10, "quality": 1.0, "section_id": 3919}, "so_8395848_8395972_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 7153}, "so_8395848_8395972_0": {"length": 57, "quality": 1.0, "section_id": 7151}}, "n3337": {"so_8395848_8395972_2": {"length": 10, "quality": 1.0, "section_id": 3779}, "so_8395848_8395972_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 6897}, "so_8395848_8395972_0": {"length": 57, "quality": 1.0, "section_id": 6895}}, "n4659": {"so_8395848_8395972_2": {"length": 8, "quality": 0.8, "section_id": 4805}, "so_8395848_8395972_1": {"length": 23, "quality": 0.6571428571428571, "section_id": 8657}}}, "8395962": {"Id": "8395962", "PostTypeId": "2", "Body": "<p>See <a href=\"http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.14\" rel=\"nofollow\">this C++ FAQ entry</a>, the initialization order for static objects is undefined. <strong>Don't</strong> rely on it.</p>\n", "LastActivityDate": "2011-12-06T05:59:56.063", "CommentCount": "2", "CreationDate": "2011-12-06T05:59:56.063", "ParentId": "8395848", "Score": "-1", "OwnerUserId": "17650"}});