post_cb({"bq_ids": {"n4140": {"so_47444081_47444081_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 6076}, "so_47444081_47444410_1": {"length": 51, "quality": 0.9622641509433962, "section_id": 5466}, "so_47444081_47444768_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 7214}, "so_47444081_47444410_0": {"length": 35, "quality": 0.603448275862069, "section_id": 5466}, "so_47444081_47444081_0": {"length": 13, "quality": 0.8125, "section_id": 7202}, "so_47444081_47444410_2": {"length": 70, "quality": 0.8333333333333334, "section_id": 5467}}, "n3337": {"so_47444081_47444081_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 5844}, "so_47444081_47444081_0": {"length": 13, "quality": 0.8125, "section_id": 6946}, "so_47444081_47444768_0": {"length": 50, "quality": 0.9090909090909091, "section_id": 6958}, "so_47444081_47444410_0": {"length": 36, "quality": 0.6206896551724138, "section_id": 5252}, "so_47444081_47444410_1": {"length": 51, "quality": 0.9622641509433962, "section_id": 5252}, "so_47444081_47444410_2": {"length": 70, "quality": 0.8333333333333334, "section_id": 5253}}, "n4659": {"so_47444081_47444081_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 7572}, "so_47444081_47444081_0": {"length": 13, "quality": 0.8125, "section_id": 8711}, "so_47444081_47444768_0": {"length": 50, "quality": 0.9090909090909091, "section_id": 8723}, "so_47444081_47444410_0": {"length": 35, "quality": 0.603448275862069, "section_id": 6900}, "so_47444081_47444410_1": {"length": 51, "quality": 0.9622641509433962, "section_id": 6900}, "so_47444081_47444410_2": {"length": 70, "quality": 0.8333333333333334, "section_id": 6901}}}, "47444768": {"Id": "47444768", "PostTypeId": "2", "Body": "<p>I've searched the standard, and this is best I could find (I know this may not be adequate):</p>\n<p><em>Underlying type</em> is defined implicitly here (3.9.1/5 of C++14):</p>\n<blockquote>\n<p id=\"so_47444081_47444768_0\">Type wchar_t is a distinct type whose values can represent distinct\n  codes for all members of the largest extended character set speci\ufb01ed\n  among the supported locales (22.3.1). Type wchar_t <strong>shall have the same\n  size, signedness, and alignment requirements (3.11) as one of the\n  other integral types, called its underlying type</strong>. Types char16_t and\n  char32_t denote distinct types with the same size, signedness, and\n  alignment as uint_least16_t and uint_least32_t, respectively, in\n  &lt;cstdint&gt;, called the underlying types.</p>\n</blockquote>\n<p>This definition is about <code>wchar_t</code>, but I think it's safe to say that that's the definition for <em>underlying type</em>.\n(at least, that's the best definition the standard gives. Besides, the index of C++14 standard for <em>underlying type</em> refers to here)</p>\n<p>That means:</p>\n<ol>\n<li><p>the representation must be the same</p></li>\n<li><p>size must be equal</p></li>\n</ol>\n<p>(But I do think that <em>underlying type</em> should be defined better in the standard)</p>\n", "LastActivityDate": "2017-11-22T22:22:47.317", "CommentCount": "4", "CreationDate": "2017-11-22T22:22:47.317", "ParentId": "47444081", "Score": "1", "OwnerUserId": "8157187"}, "47444410": {"Id": "47444410", "PostTypeId": "2", "Body": "<p>Taken from: <a href=\"https://stackoverflow.com/questions/1122096/what-is-the-underlying-type-of-a-c-enum\">What is the underlying type of a c++ enum?</a>, An older C++ standard stated at 7.2/5:</p>\n<blockquote>\n<p id=\"so_47444081_47444410_0\">The underlying type of an enumeration is an integral type that can\n  represent all the enumerator values defined in the enumeration. It is\n  implementation-defined which integral type is used as the underlying\n  type for an enumeration except that the underlying type shall not be\n  larger than int unless the value of an enu- merator cannot fit in an\n  int or unsigned int. If the enumerator-list is empty, the underlying\n  type is as if the enumeration had a single enumerator with value 0.\n  The value of sizeof() applied to an enu- meration type, an object of\n  enumeration type, or an enumerator, is the value of sizeof() applied\n  to the underlying type.</p>\n</blockquote>\n<p>From <code>draft n4606</code> the closest I could find is 7.2/7 + 8 which states:</p>\n<blockquote>\n<p id=\"so_47444081_47444410_1\">7) For an enumeration whose underlying type is not fixed, the underlying\n  type is an integral type that can represent all the enumerator values\n  defined in the enumeration. If no integral type can represent all the\n  enumerator values, the enumeration is ill-formed. It is\n  implementation-defined which integral type is used as the underlying\n  type except that the underlying type shall not be larger than int\n  unless the value of an enumerator cannot fit in an int or unsigned\n  int. If the enumerator-list is empty, the underlying type is as if the\n  enumeration had a single enumerator with value 0.</p>\n<p id=\"so_47444081_47444410_2\">8) For an enumeration whose underlying type is fixed, the values of the enumeration are the\n  values of the underlying type. Otherwise, for an enumeration where\n  emin is the smallest enumerator and emax is the largest, the values of\n  the enumeration are the values in the range bmin to bmax, defined as\n  follows: Let K be 1 for a two\u2019s complement representation and 0 for a\n  ones\u2019 complement or sign-magnitude representation. bmax is the\n  smallest value greater than or equal to max(|emin| \u2212 K, |emax|) and\n  equal to 2M \u2212 1, where M is a non-negative integer. bmin is zero if\n  emin is non-negative and \u2212(bmax + K) otherwise. The size of the\n  smallest bit-field large enough to hold all the values of the\n  enumeration type is max(M, 1) if bmin is zero and M + 1 otherwise. It\n  is possible to define an enumeration that has values not defined by\n  any of its enumerators. If the enumerator-list is empty, the values of\n  the enumeration are as if the enumeration had a single enumerator with\n  value 0</p>\n</blockquote>\n<p>On the one hand it seems close enough, on the other hand, the specific demand for the <code>sizeof()</code> operator was removed.\nStill I think it is safe enough to state that answer for both the questions is yes.</p>\n", "LastEditorUserId": "8908931", "LastActivityDate": "2017-11-22T22:11:28.970", "Score": "1", "CreationDate": "2017-11-22T21:50:48.230", "ParentId": "47444081", "CommentCount": "0", "OwnerUserId": "8908931", "LastEditDate": "2017-11-22T22:11:28.970"}, "47444081": {"ViewCount": "179", "Body": "<p>I often assume that size of an enumeration is the same as the size of its underlying type. But is it mandated by the standard?</p>\n<p>The standard (C++14, n4296) says that every enumeration has an underlying type (7.2/5). The standard also says that objects are represented as sequences of bytes, and that the size of an object is related to its representation:</p>\n<blockquote>\n<p id=\"so_47444081_47444081_0\">3.9/4 The object representation of an object of type T is the sequence of N\n  unsigned char objects taken up by the object of type T, where N equals\n  sizeof(T).</p>\n<p id=\"so_47444081_47444081_1\">5.3.3/1 The sizeof operator yields the number of bytes in the object\n  representation of its operand.</p>\n</blockquote>\n<p>However, I was not able to find any relation between an enum's underlying type and the object representation. Is there any? If not, than I would argue that sizeof of an enumeration does not have to be sizeof of its underlying type.</p>\n<p>So my questions are:</p>\n<ol>\n<li><p>Is there any relation between an enum's underlying type and its object representation?</p></li>\n<li><p>Does the standard really require that <code>sizeof(std::underlying_type_t&lt;E&gt;) == sizeof(E)</code> for any enumeration E?</p></li>\n</ol>\n", "Title": "In C++, does the size of an enumeration have to be equal to the size of its underlying type?", "CreationDate": "2017-11-22T21:25:04.543", "LastActivityDate": "2017-11-22T22:22:47.317", "CommentCount": "6", "PostTypeId": "1", "Id": "47444081", "Score": "5", "OwnerUserId": "6209703", "Tags": "<c++><c++14><language-lawyer>", "AnswerCount": "2"}});