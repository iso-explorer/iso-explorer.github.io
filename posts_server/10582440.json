post_cb({"10582553": {"Id": "10582553", "PostTypeId": "2", "Body": "<p>It doesn't really answer <em>why</em>, but it is determined by the standard, \u00a71.3.10</p>\n<blockquote>\n<p id=\"so_10582440_10582553_0\">The information about a function that participates in overload resolution (13.3): the types of its parameters\n  and, if the function is a class member, the cv- qualifiers (if any) on the function itself and the class in which the member function is declared. </p>\n</blockquote>\n<p>This just means the cv qualifiers of the arguments are ignored in the overload resolution.</p>\n<p>A similar (but <strong>not</strong> equivalent) example with references works:</p>\n<pre><code>class Sample {\npublic:\n  void Method(char&amp; x) {}\n  void Method(const char&amp; x) {}\n};\n</code></pre>\n<p>because here the types are different, the first case being a reference to <code>char</code>, the second a reference to <code>const char</code> (as opposed to a <code>const</code> reference to <code>char</code>).</p>\n", "LastEditorUserId": "661519", "LastActivityDate": "2012-05-14T11:55:40.580", "Score": "5", "CreationDate": "2012-05-14T11:35:28.797", "ParentId": "10582440", "CommentCount": "0", "OwnerUserId": "661519", "LastEditDate": "2012-05-14T11:55:40.580"}, "10582440": {"ViewCount": "247", "Body": "<p>Why is following not allowed in <code>C++</code></p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Sample {\npublic:\n  void Method(char x);\n  void Method(char const x);\n};\n\nvoid Sample::Method(char x) {\n  char y = x;\n}\n\nvoid Sample::Method(char const x) {\n  char y = x;\n}\n\nint main() {\n  Sample s;\n  return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "10582553", "Title": "C++ overloading with one parameter const", "CreationDate": "2012-05-14T11:29:55.173", "Id": "10582440", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-05-14T12:10:10.100", "LastEditorUserId": "92568", "LastActivityDate": "2012-05-14T14:12:09.323", "Score": "6", "OwnerUserId": "92568", "Tags": "<c++>", "AnswerCount": "7"}, "10582759": {"Id": "10582759", "PostTypeId": "2", "Body": "<p>The standard says those two declarations are equivalent (13.1.3):</p>\n<blockquote>\n<p id=\"so_10582440_10582759_0\">Parameter declarations that differ only in the presence or absence of <code>const</code> and/or <code>volatile</code> are equivalent. That is, the <code>const</code> and <code>volatile</code> type-specifiers for each parameter type are ignored when determining which function is being declared, defined, or called.</p>\n</blockquote>\n<pre><code>typedef const int cInt;\n\nint f(int);\nint f(const int);            // redeclaration of f(int)\nint f(int) { /* ... */ }     // definiton of f(int)\nint f(cInt) { /* ... */ }    // error: redefiniton of f(int)\n</code></pre>\n", "LastActivityDate": "2012-05-14T11:49:00.430", "CommentCount": "0", "CreationDate": "2012-05-14T11:49:00.430", "ParentId": "10582440", "Score": "2", "OwnerUserId": "947836"}, "10582520": {"Id": "10582520", "PostTypeId": "2", "Body": "<p>because it's ambiguous\nwhen you're passing like this</p>\n<p><code>s.Method('x');</code></p>\n<p>what version should you think be called?</p>\n", "LastActivityDate": "2012-05-14T11:33:49.540", "CommentCount": "0", "CreationDate": "2012-05-14T11:33:49.540", "ParentId": "10582440", "Score": "2", "OwnerUserId": "532208"}, "bq_ids": {"n4140": {"so_10582440_10582759_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 558}}, "n3337": {"so_10582440_10582759_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 549}}, "n4659": {"so_10582440_10582759_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 581}}}, "10582517": {"Id": "10582517", "PostTypeId": "2", "Body": "<p>This is still ambiguous. When it's called with a character argument, one version will copy the argument and say \"OK, you can change the copy\". The other will copy the argument and say \"OK, you cannot change the copy.\" How is the compiler supposed to know whether it can or can't change a copy of something? It could do either just fine.</p>\n", "LastActivityDate": "2012-05-14T11:33:42.130", "CommentCount": "0", "CreationDate": "2012-05-14T11:33:42.130", "ParentId": "10582440", "Score": "3", "OwnerUserId": "962089"}, "10582513": {"Id": "10582513", "PostTypeId": "2", "Body": "<p>When it comes to function parameters, <code>char</code> and <code>char const</code> are the same data type.</p>\n", "LastActivityDate": "2012-05-14T11:33:33.540", "CommentCount": "1", "CreationDate": "2012-05-14T11:33:33.540", "ParentId": "10582440", "Score": "3", "OwnerUserId": "429435"}, "10582528": {"Id": "10582528", "PostTypeId": "2", "Body": "<p><a href=\"http://duramecho.com/ComputerInformation/WhyHowCppConst.html\" rel=\"nofollow\">http://duramecho.com/ComputerInformation/WhyHowCppConst.html</a></p>\n<p>Because <strong>const</strong> denotes that variable as having a set value, that cannot be changed after declaration. It is not a different data type.</p>\n", "LastEditorUserId": "1321957", "LastActivityDate": "2012-05-14T11:43:20.200", "Score": "0", "CreationDate": "2012-05-14T11:34:11.943", "ParentId": "10582440", "CommentCount": "2", "OwnerUserId": "1321957", "LastEditDate": "2012-05-14T11:43:20.200"}, "10582705": {"Id": "10582705", "PostTypeId": "2", "Body": "<p><strong>Why is following not allowed in C++?</strong><br>\nThe reason is the very same that the compiler gives you as an compilation error:<br>\nBecause they are ambiguous!</br></br></p>\n<p><strong>Why are these methods ambiguous?</strong><br>\nShort answer: Because the C++ Standard says so.</br></p>\n<p><strong>What is the rationale behind these overloaded methods being ambiguous?</strong><br>\nThe compiler does not know whether the caller wants to treat the <strong><em>value of the passed</em></strong> argument as an <code>const</code> or not, there is no way for the compiler to determine that with the information at hand.</br></p>\n<p>Note the emphasis on <strong><em>pass by value</em></strong> here, the argument is being passed by value, and hence the ambiguity. If the argument was <strong><em>passed by reference</em></strong> then the compiler knows for sure how the caller wants to treat the argument because then the actual object itself is being passed, and hence compiler can make a selection of the proper overload.</p>\n<p>The following example gives a clearer idea to the explanation above.</p>\n<p><strong><a href=\"http://ideone.com/2psZG\" rel=\"nofollow noreferrer\">Online Sample</a></strong>:</p>\n<pre><code>class Sample \n{\n    public:\n        void Method(char &amp;x){}\n        void Method(char const x){}\n        void Method(char const &amp;x){}\n};\n\n\nint main() \n{\n     Sample s;\n     return 0;\n}\n</code></pre>\n", "LastEditorUserId": "452307", "LastActivityDate": "2012-05-14T14:12:09.323", "Score": "6", "CreationDate": "2012-05-14T11:45:03.967", "ParentId": "10582440", "CommentCount": "0", "OwnerUserId": "452307", "LastEditDate": "2012-05-14T14:12:09.323"}});