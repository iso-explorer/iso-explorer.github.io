post_cb({"17136497": {"CommentCount": "2", "ViewCount": "4230", "PostTypeId": "1", "LastEditorUserId": "3964927", "CreationDate": "2013-06-16T18:45:33.977", "LastActivityDate": "2015-07-28T16:28:54.200", "Title": "Is overriding std::to_string for user defined enums the proper way to provide to_string for user defined enums?", "AcceptedAnswerId": "17136607", "LastEditDate": "2015-07-28T16:28:54.200", "Id": "17136497", "Score": "15", "Body": "<p>C++ doesn't have a way to get the string representation of an enum. People get around this by writing custom functions that contain a lot of boilerplate code aka<br>\n<code>switch</code> with <code>case XYZ return \"XYZ\";</code></br></p>\n<p>That of course requires users of the enum to know the name of the custom function.</p>\n<p>So I thought I could just add a specialization to <code>std::to_string</code> to enable a user to use <code>to_string</code> on my enums. Something like this:</p>\n<pre><code>//\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;cassert&gt;\n#define TEST\nclass Car\n{\npublic:\n    enum class Color\n    {\n        Red,\n        Blue,\n        White\n    };\n};\n#ifdef TEST\n#include &lt;string&gt;\nnamespace std\n{\n    std::string to_string (Car::Color c)\n    {\n        switch (c)\n        {\n        case Car::Color::Red:\n            return \"Red\";\n        case Car::Color::Blue:\n            return \"Blue\";\n        case Car::Color::White:\n            return \"White\";\n        default:\n            {\n                assert(0);\n                return \"\";\n            }\n        }\n    }\n\n}\n#endif\nint main()\n{\n    std::cout &lt;&lt; std::to_string(Car::Color::White) &lt;&lt; std::endl;\n\n}\n</code></pre>\n<p>Are there any problems with this solution?</p>\n", "Tags": "<c++><enums><tostring>", "OwnerUserId": "700825", "AnswerCount": "1"}, "17136607": {"ParentId": "17136497", "CommentCount": "7", "Body": "<p>That's not \"overriding\" (which applies to <code>virtual</code> functions), and you haven't added a \"specialization\" (which applies to templates), you've added an overload, which adds a declaration and definition of a new function to namespace <code>std</code> and that's forbidden:</p>\n<blockquote>\n<p id=\"so_17136497_17136607_0\"><strong>17.6.4.2.1  Namespace std  [namespace.std]</strong><br>\n  The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <code>std</code> or to a namespace within namespace <code>std</code> unless otherwise specified. A program may add a template specialization for any standard library template to namespace std only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</br></p>\n</blockquote>\n<p>A better solution would be to overload it in your own namespace, and call <code>to_string(c)</code> instead of <code>std::to_string(c)</code>. That will find the right function and you don't need to add anything to <code>std</code></p>\n", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "17136607", "Score": "22", "CreationDate": "2013-06-16T18:55:41.643", "LastActivityDate": "2013-06-16T18:55:41.643"}, "bq_ids": {"n4140": {"so_17136497_17136607_0": {"section_id": 6299, "quality": 0.868421052631579, "length": 33}}, "n3337": {"so_17136497_17136607_0": {"section_id": 6056, "quality": 0.868421052631579, "length": 33}}, "n4659": {"so_17136497_17136607_0": {"section_id": 7808, "quality": 0.868421052631579, "length": 33}}}});