post_cb({"9247644": {"Id": "9247644", "PostTypeId": "2", "Body": "<p>std::string and std::wstring are typedefs of std::basic_string templated on char and wchar_t. The size() member function returns the number of elements in the string - the number of char's or wchar_t's. \"\" and L\"\" don't deal with encodings.</p>\n", "LastActivityDate": "2012-02-12T09:10:46.993", "CommentCount": "0", "CreationDate": "2012-02-12T09:10:46.993", "ParentId": "9241935", "Score": "0", "OwnerUserId": "1148251"}, "9242921": {"Id": "9242921", "PostTypeId": "2", "Body": "<p>Use <code>.length()</code>, not <code>.size()</code> to get the string length.</p>\n", "LastActivityDate": "2012-02-11T18:37:39.093", "CommentCount": "1", "CreationDate": "2012-02-11T18:37:39.093", "ParentId": "9241935", "Score": "0", "OwnerUserId": "1016716"}, "9242752": {"Id": "9242752", "PostTypeId": "2", "Body": "<p>It is an error if the <code>std::wstring</code> version uses 17 characters: it should only use 11 characters. Using recent SVN heads of gcc and clang it uses 11 characters for the <code>std::wstring</code> and 17 characters for the <code>std::string</code>. I think this is what expected.</p>\n<p>Please note that the standard C++ library internally has a different idea of what a \"character\" is than what might be expected when multi-word encodings (e.g. UTF-8 for words of type <code>char</code> and UTF-16 for words with 16 bits) are used. Here is the first paragraph of the chapter describing string (21.1 [strings.general]):</p>\n<blockquote>\n<p id=\"so_9241935_9242752_0\">This Clause describes components for manipulating sequences of any non-array POD (3.9) type. In this Clause such types are called char-like types , and objects of char-like types are called char-like objects or simply characters.</p>\n</blockquote>\n<p>This basically means that when using Unicode the various functions <strong>won't</strong> pay attention to what constitutes a code point but rather process the strings as a sequence of words. This is severe impacts and what will happen e.g. when producing substrings because these may easily split multi-byte characters apart. Currently, the standard C++ library doesn't have any support for processing multi-bytes encodings internally because it is assumed that the translation from an encoding to characters is done when reading data (and correspondingly the other way when writing data). If you are processing multi-byte encoded strings internally, you need be aware of this as there is no support at all.</p>\n<p>It is recognized that this state of affairs is actually a problem. For C++2011 the character type <code>char32_t</code> was added which should support Unicode character still better than <code>wchar_t</code> (because Unicode uses 20 bits while <code>wchar_t</code> was allowed to only support 16 bits which is a choice made on some platforms at a time when Unicode was promising to use at most 16 bits). However, this would still not deal with combining characters. It is recognized by the C++ committee that this is a problem and that proper character processing in the standard C++ library would be something nice to have but so far nobody as come forward with a comprehensive proposal to address this problem (if you feel you want to propose something like this but you don't know how, please feel free to contact me and I will help you with how to submit a proposal).</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2012-02-11T18:46:44.347", "Score": "4", "CreationDate": "2012-02-11T18:18:56.440", "ParentId": "9241935", "CommentCount": "3", "LastEditDate": "2012-02-11T18:46:44.347", "OwnerUserId": "1120273"}, "9241935": {"ViewCount": "1065", "Body": "<p>I ran the same code which determines number of characters in a wide-character string. The tested string has ascii, numbers and Korean language. </p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class T,class trait&gt;\nvoid DumpCharacters(T&amp; a)\n{\n    size_t length = a.size();\n    for(size_t i=0;i&lt;length;i++)\n    {\n        trait n = a[i];\n        cout&lt;&lt;i&lt;&lt;\" =&gt; \"&lt;&lt;n&lt;&lt;endl;\n    }\n\n    cout&lt;&lt;endl;\n}\n\nint main(int argc, char* argv[])\n{\n    wstring u = L\"123abc\uac001\ub0981\ub2e4\";\n    wcout&lt;&lt;u&lt;&lt;endl;\n    DumpCharacters&lt;wstring,wchar_t&gt;(u);\n\n    string s = \"123abc\uac001\ub0981\ub2e4\";\n    cout&lt;&lt;s&lt;&lt;endl;\n    DumpCharacters&lt;string,char&gt;(s);\n\n    return 0;\n}\n</code></pre>\n<p>The obvious thing is that wstring.size() in Visual C++ 2010 returns the number of letters (11 characters), regardless if it is ascii or international character. However, it returns the byte count of string data (17 bytes) in XCode 4.2 in Mac OS X. </p>\n<p>Please reply me how to get the character length of a wide-character string, not byte count in xcode.</p>\n<p>--- added on 12 Feb -- </p>\n<p>I found that wcslen() also returns 17 in xcode. it returns 11 in vc++.\nHere's the tested code:</p>\n<pre><code>const wchar_t *p = L\"123abc\uac001\ub0981\ub2e4\";\nsize_t plen = wcslen(p);\n</code></pre>\n<p>--- added on 18 Feb --</p>\n<p>I found that llvm 3.0 causes the wrong length. This problem is fixed after changing compiler frontend from llvm3.0 to 4.2</p>\n<p><a href=\"https://stackoverflow.com/questions/9246043/wcslen-works-differently-in-xcode-and-vc#comment11757815_9246043\">wcslen() works differently in Xcode and VC++</a> says the details.</p>\n", "AcceptedAnswerId": "9242752", "Title": "wstring.size() works differently in xcode or visual c++", "CreationDate": "2012-02-11T16:41:34.713", "Id": "9241935", "CommentCount": "2", "LastEditDate": "2017-05-23T11:48:00.800", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2012-02-18T03:27:35.190", "Score": "0", "OwnerUserId": "169165", "Tags": "<c++><wstring>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_9241935_9242752_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 1526}}, "n3337": {"so_9241935_9242752_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 1520}}, "n4659": {"so_9241935_9242752_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 1676}}}, "9242437": {"Id": "9242437", "PostTypeId": "2", "Body": "<p>XCode 4.2 apparently used UTF-8 (or something very similar) as narrow multibyte encoding to represent your characters string literal <code>\"123abc\uac001\ub0981\ub2e4\"</code> in the program's source code when initializing <code>string s</code>. The UTF-8 representation of that string happens to be 17 bytes long.</p>\n<p>The wide character representation (stored in <code>u</code>) is 11 wide characters. There are many ways to convert from narrow to wide encoding. Try this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;clocale&gt;\n#include &lt;cstdlib&gt;\n\nint main()\n{\n    std::wstring u = L\"123abc\uac001\ub0981\ub2e4\";\n    std::cout &lt;&lt; \"Wide string containts \" &lt;&lt; u.size() &lt;&lt; \" characters\\n\";\n\n    std::string s = \"123abc\uac001\ub0981\ub2e4\";\n    std::cout &lt;&lt; \"Narrow string contains \" &lt;&lt; s.size() &lt;&lt; \" bytes\\n\";\n\n    std::setlocale(LC_ALL, \"\");\n    std::cout &lt;&lt; \"Which can be converted to \"\n              &lt;&lt; std::mbstowcs(NULL, s.c_str(), s.size())\n              &lt;&lt; \" wide characters in the current locale,\\n\";\n}\n</code></pre>\n", "LastEditorUserId": "273767", "LastActivityDate": "2012-02-11T18:00:14.297", "Score": "1", "CreationDate": "2012-02-11T17:42:56.513", "ParentId": "9241935", "CommentCount": "2", "LastEditDate": "2012-02-11T18:00:14.297", "OwnerUserId": "273767"}});