post_cb({"25697972": {"Id": "25697972", "PostTypeId": "2", "Body": "<p>The applicable rule for this is laid out in \u00a73.8 [basic.life]/p1 and 4:</p>\n<blockquote>\n<p id=\"so_25697706_25697972_0\">The lifetime of an object of type <code>T</code> ends when:</p>\n<ul>\n<li>if T is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n<p id=\"so_25697706_25697972_1\">4   A program may end the lifetime of any object by reusing the storage\n  which the object occupies or by explicitly calling the destructor for\n  an object of a class type with a non-trivial destructor. For an object\n  of a class type with a non-trivial destructor, the program is not\n  required to call the destructor explicitly before the storage which\n  the object occupies is reused or released; however, if there is no\n  explicit call to the destructor or if a <em>delete-expression</em> (5.3.5) is\n  not used to release the storage, the destructor shall not be\n  implicitly called and any program that depends on the side effects\n  produced by the destructor has undefined behavior.</p>\n</blockquote>\n<p>So <code>A *b = new (a) B;</code> reuses the storage of the <code>A</code> object created in the previous statement, which is well-defined behavior provided that <code>sizeof(A) &gt;= sizeof(B)</code><sup>*</sup>. That <code>A</code> object's lifetime has ended by virtue of its storage being reused. <code>A</code>'s destructor is not called for that object, and if your program depends on the side effect produced by that destructor, it has undefined behavior.</p>\n<p>The paragraph you cited, \u00a73.8 [basic.life]/p7, governs when a pointer/reference to the original object can be reused. Since this code doesn't satisfy the criteria listed in that paragraph, you may only use <code>a</code> only in the limited ways permitted by \u00a73.8 [basic.life]/p5-6, or undefined behavior results (example and footnote omitted):</p>\n<blockquote>\n<p id=\"so_25697706_25697972_2\">5 Before the lifetime of an object has started but after the storage\n  which the object will occupy has been allocated or, after the lifetime\n  of an object has ended and before the storage which the object\n  occupied is reused or released, any pointer that refers to the storage\n  location where the object will be or was located may be used but only\n  in limited ways. For an object under construction or destruction, see\n  12.7. Otherwise, such a pointer refers to allocated storage (3.7.4.2), and using the pointer as if the pointer were of type <code>void*</code>, is\n  well-defined. Such a pointer may be dereferenced but the resulting\n  lvalue may only be used in limited ways, as described below. The\n  program has undefined behavior if:</p>\n<ul>\n<li>the object will be or was of a class type with a non-trivial destructor and the pointer is used as the operand of a\n  <em>delete-expression</em>,</li>\n<li>the pointer is used to access a non-static data member or call a non-static member function of the object, or</li>\n<li>the pointer is implicitly converted (4.10) to a pointer to a base class type, or</li>\n<li>the pointer is used as the operand of a <code>static_cast</code> (5.2.9) (except when the conversion is to <code>void*</code>, or to <code>void*</code> and\n  subsequently to <code>char*</code>, or <code>unsigned char*</code>), or</li>\n<li>the pointer is used as the operand of a <code>dynamic_cast</code> (5.2.7).</li>\n</ul>\n<p id=\"so_25697706_25697972_3\">6 Similarly, before the lifetime of an object has started but after\n  the storage which the object will occupy has been allocated or, after\n  the lifetime of an object has ended and before the storage which the\n  object occupied is reused or released, any glvalue that refers to the\n  original object may be used but only in limited ways. For an object\n  under construction or destruction, see 12.7. Otherwise, such a glvalue\n  refers to allocated storage (3.7.4.2), and using the properties of the\n  glvalue that do not depend on its value is well-defined. The program\n  has undefined behavior if:</p>\n<ul>\n<li>an lvalue-to-rvalue conversion (4.1) is applied to such a glvalue,</li>\n<li>the glvalue is used to access a non-static data member or call a non-static member function of the object, or</li>\n<li>the glvalue is implicitly converted (4.10) to a reference to a base class type, or</li>\n<li>the glvalue is used as the operand of a <code>static_cast</code> (5.2.9) except when the conversion is ultimately to <code>cv char&amp;</code> or <code>cv unsigned char&amp;</code>, or</li>\n<li>the glvalue is used as the operand of a <code>dynamic_cast</code> (5.2.7) or as the operand of <code>typeid</code>.</li>\n</ul>\n</blockquote>\n<hr>\n<p><sub><sup>*</sup> To prevent UB from cases where <code>sizeof(B) &gt; sizeof(A)</code>, we can rewrite <code>A *a = new A;</code> as <code>char c[sizeof(A) + sizeof(B)]; A* a = new (c) A;</code>.</sub></p>\n</hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2014-09-06T11:23:26.777", "Score": "2", "CreationDate": "2014-09-06T07:30:49.043", "ParentId": "25697706", "CommentCount": "2", "OwnerUserId": "2756719", "LastEditDate": "2014-09-06T11:23:26.777"}, "25697896": {"Id": "25697896", "PostTypeId": "2", "Body": "<p>There are some potential problems with this:</p>\n<ol>\n<li>If B is larger than A, it will overwrite bytes not allocated - which is undefined behaviour. </li>\n<li>Destructor of A is not called for <code>a</code> (or <code>b</code> - your code doesn't show whether you <code>delete a</code> or <code>delete b</code> or neither). This is very important if either for <code>A</code> or <code>B</code> destructor is doing something like reference counting, locks, memory deallocation (including <code>std::</code> containers such as <code>std::vector</code> or <code>std::string</code>), etc. </li>\n</ol>\n<p>If <code>a</code> is not used again after you create <code>b</code>, you still need to call the <code>A</code> destructor to make sure it's lifetime is over - see the example in the third bulled after the section you quoted. So if your purpose was to avoid the \"expensive\" destructor call, then your code is failing to abide by the rules given in section 3.8/7 of the standard. </p>\n<p>You are also breaching the bullet of:</p>\n<blockquote id=\"so_25697706_25697896_0\">\n<ul>\n<li>The original object was a most derived object (1.8) of type T and the new object is a most derived object of type T. </li>\n</ul>\n</blockquote>\n<p>as <code>A</code> is not the most derived type.</p>\n<p>In summary, \"broken\". Even in cases where it does work (e.g. changing to <code>A* a = new B;</code>), it should be discouraged, as it can lead to subtle and difficult bugs.</p>\n", "LastActivityDate": "2014-09-06T07:21:39.930", "CommentCount": "1", "CreationDate": "2014-09-06T07:21:39.930", "ParentId": "25697706", "Score": "1", "OwnerUserId": "1919155"}, "bq_ids": {"n4140": {"so_25697706_25697972_1": {"length": 49, "quality": 0.9607843137254902, "section_id": 7192}, "so_25697706_25697896_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7195}, "so_25697706_25697972_3": {"length": 51, "quality": 0.9272727272727272, "section_id": 7194}, "so_25697706_25697706_0": {"length": 43, "quality": 1.0, "section_id": 7195}, "so_25697706_25697972_2": {"length": 64, "quality": 0.9014084507042254, "section_id": 7193}, "so_25697706_25697972_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}}, "n3337": {"so_25697706_25697972_1": {"length": 49, "quality": 0.9607843137254902, "section_id": 6936}, "so_25697706_25697706_0": {"length": 43, "quality": 1.0, "section_id": 6939}, "so_25697706_25697972_3": {"length": 51, "quality": 0.9272727272727272, "section_id": 6938}, "so_25697706_25697972_2": {"length": 67, "quality": 0.9436619718309859, "section_id": 6937}, "so_25697706_25697972_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_25697706_25697896_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6939}}, "n4659": {"so_25697706_25697972_1": {"length": 49, "quality": 0.9607843137254902, "section_id": 8701}, "so_25697706_25697706_0": {"length": 43, "quality": 1.0, "section_id": 8704}, "so_25697706_25697972_3": {"length": 51, "quality": 0.9272727272727272, "section_id": 8703}, "so_25697706_25697972_2": {"length": 63, "quality": 0.8873239436619719, "section_id": 8702}, "so_25697706_25697972_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_25697706_25697896_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 8704}}}, "25697706": {"ViewCount": "117", "Body": "<p>I've been trying to understand <code>memory reusing</code> concept in C++. Imagine we have an object with non-trivial destructor:</p>\n<pre><code>struct A\n{\n    ~A(){ cout &lt;&lt; \"~A(): &lt;&lt; endl; }\n};\n\nstruct B : A { };\nA *a = new A; //Lifetime of a is starting\nA *b = new (a) B; //Lifetime of a has ended, lifetime of b is starting\n</code></pre>\n<p>Section 3.8/7 says:</p>\n<blockquote>\n<p id=\"so_25697706_25697706_0\">If, after the lifetime of an object has ended and before the storage\n  which the object occupied is reused or released, a new object is\n  created at the storage location which the original object occupied, a\n  pointer that pointed to the original object, a reference that referred\n  to the original object, or the name of the original object will\n  automatically refer to the new object and, once the lifetime of the\n  new object has started, can be used to manipulate the new object, if:</p>\n<p id=\"so_25697706_25697706_1\">[...]</p>\n</blockquote>\n<p>That is, because the lifetime of <code>a</code> had not been ended at the time we called to reuse the memory located by <code>a</code>, we can not apply that rule to the example. So what exactly rule describes behavior in my case?</p>\n", "AcceptedAnswerId": "25697972", "Title": "Concept of memory reusing in c++", "CreationDate": "2014-09-06T06:54:58.883", "Id": "25697706", "CommentCount": "3", "LastEditDate": "2014-09-06T07:26:42.860", "PostTypeId": "1", "LastEditorUserId": "2989920", "LastActivityDate": "2014-09-06T11:23:26.777", "Score": "1", "OwnerUserId": "3663882", "Tags": "<c++><language-lawyer>", "AnswerCount": "3"}, "25698589": {"Id": "25698589", "PostTypeId": "2", "Body": "<p>As an addendum, in order to do this correctly you may call the destructor explicitly.</p>\n<p><strong>Note:</strong> the located memory is of size B to accommodate the potential size between <code>A</code> and <code>B</code>.</p>\n<p><strong>Note 2</strong>: with your implementation of class A this will not work. <code>~A()</code> must be made virtual!! </p>\n<pre><code>A *b = new B; //Lifetime of b is starting. It is important that we use `new B` rather than `new A` so as to get the correct size.\nb-&gt;~B(); //lifetime of b has ended. The memory still remain allocated however.\nA *a = new (a) A; //lifetime of a is starting\na-&gt;~A(); // lifetime of a has ended\n\n// a is still allocated but in an undefined state\n\n::operator delete(b); // release the memory allocated without calling the destructor. This is different from calling 'delete b'\n</code></pre>\n<p>I <em>believe</em>  that calling <code>operator delete</code> on a base pointer should be safe. Please do correct me if this is not the case.</p>\n<p>Alternatively, if you allocate the memory for a as a <code>char</code> buffer, you can then use placement new to construct <code>A</code> and <code>B</code> objects, and safely call <code>delete[]</code> to deallocate the buffer (since <code>char</code> has a trivial destructor):</p>\n<pre><code>char* buf = new char[sizeof(B)];\nA *a = new (a) A;\na-&gt;~();\nA *b = new (a) B;\nb-&gt;~B();\ndelete[] buf;\n</code></pre>\n", "LastActivityDate": "2014-09-06T08:58:53.657", "CommentCount": "0", "CreationDate": "2014-09-06T08:58:53.657", "ParentId": "25697706", "Score": "0", "OwnerUserId": "286731"}});