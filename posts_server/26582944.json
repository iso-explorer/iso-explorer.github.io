post_cb({"bq_ids": {"n4140": {"so_26582944_26583140_0": {"length": 5, "quality": 1.0, "section_id": 87}}, "n3337": {"so_26582944_26583140_0": {"length": 5, "quality": 1.0, "section_id": 82}}}, "26583140": {"CommentCount": "2", "Body": "<p>You're right that it's not possible to do any pointer arithmetics when specifying non-type template arguments of pointer type. The standard says so explicitly, C++11 14.3.2/1:</p>\n<blockquote>\n<p id=\"so_26582944_26583140_0\">A <em>template-argument</em> for a non-type, non-template <em>template-parameter</em> shall be one of:</p>\n<ul>\n<li>...</li>\n<li>a constant expression (5.19) that designates the address of an object with static storage duration and\n  external or internal linkage or a function with external or internal linkage, including function templates\n  and function template-ids but excluding non-static class members, <strong>expressed (ignoring parentheses) as\n  <code>&amp;</code> <em>id-expression</em>,</strong> except that the <code>&amp;</code> may be omitted if the name refers to a function or array and shall\n  be omitted if the corresponding <em>template-parameter</em> is a reference; or</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>(Emphasis mine, omitted other bullet points which don't apply here).</p>\n<p>For completeness, <em>id-expression</em> is defined in 5.1.1 as either a qualified or unqualified identifier, operator name, destructor name or template identifier. <code>[]</code> is not allowed there.</p>\n", "CreationDate": "2014-10-27T07:57:16.863", "ParentId": "26582944", "Id": "26583140", "LastActivityDate": "2014-10-27T07:57:16.863", "PostTypeId": "2", "Score": "3", "OwnerUserId": "1782465"}, "26582944": {"CreationDate": "2014-10-27T07:40:42.820", "ViewCount": "227", "Id": "26582944", "AcceptedAnswerId": "26583140", "Score": "2", "Title": "C++11: (recursive) pointer arithmetic in templates (TMP)", "CommentCount": "0", "Body": "<p>Don't ask me why, but I was trying to initialize an array of pointers at compile-time (the pointers point to elements of another static array). This involves TMP and therefore template-recursion while building a variadic list. I've narrowed the problem down to the following:</p>\n<pre><code>template &lt;int const * const P&gt;\nstruct Foo\n{\n    constexpr static int const * const bar = P;\n};\n\nconstexpr int const array[5] = {0, 1, 2, 3, 4}; // global, so has linkage\n\nint main()\n{\n    /* 1 */ cout &lt;&lt; *Foo&lt;array&gt;::bar &lt;&lt; '\\n';\n    /* 2 */ cout &lt;&lt; *Foo&lt;array + 1&gt;::bar &lt;&lt; '\\n';\n    /* 3 */ cout &lt;&lt; *Foo&lt;&amp;array[1]&gt;::bar &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Case 1 works fine, and prints '0'.</p>\n<p>Case 2 does not compile, and GCC (4.9.1) complains:</p>\n<pre><code>error: \u2018(((const int*)(&amp; array)) + 4u)\u2019 is not a valid template argument for \u2018const int*\u2019 because it is not the address of a variable\n cout &lt;&lt; *Foo&lt;array + 1&gt;::bar &lt;&lt; '\\n';\n                       ^\n</code></pre>\n<p>Case 3 does not compile, and GCC complains:</p>\n<pre><code>error: template argument 1 is invalid\n cout &lt;&lt; *Foo&lt;&amp;array[1]&gt;::bar &lt;&lt; '\\n';\n</code></pre>\n<p>I'm mainly concerned about Case 2. Why is it not possible to do constant pointer-arithmetic and pass the result to a template? </p>\n", "Tags": "<c++><templates><pointers><c++11><metaprogramming>", "LastActivityDate": "2014-10-27T07:57:16.863", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "1428839"}});