post_cb({"bq_ids": {"n4140": {"so_31952252_31962963_0": {"length": 30, "quality": 0.625, "section_id": 739}}, "n3337": {"so_31952252_31962963_0": {"length": 30, "quality": 0.625, "section_id": 728}}, "n4659": {"so_31952252_31962963_0": {"length": 30, "quality": 0.625, "section_id": 797}}}, "31962963": {"Id": "31962963", "PostTypeId": "2", "Body": "<p><code>std::map</code> is one of the <em>associative containers</em> as defined in section 23.2.4 of the standard.\nThere are resctrictions you have to keep in mind while implementing the <code>operator&lt;</code> or <code>Compare</code> object for these containers:</p>\n<blockquote id=\"so_31952252_31962963_0\">\n<ol start=\"2\">\n<li>Each associative container is parameterized on <code>Key</code> and an ordering relation <code>Compare</code> that induces a strict weak ordering ( 25.4 ) on\n  elements of <code>Key</code>. <em>(...)</em> </li>\n<li>The phrase \u201cequivalence of keys\u201d means the\n  equivalence relation imposed by  the comparison and not the operator==\n  on keys. That is, two keys <code>k1</code> and <code>k2</code> are considered to be\n  equivalent if for the comparison object <code>comp</code>, <code>comp(k1, k2) == false\n  &amp;&amp; comp(k2, k1) == false</code>. For any two keys <code>k1</code> and <code>k2</code> in the same\n  container, calling <code>comp(k1, k2)</code> shall always return the same value.</li>\n</ol>\n</blockquote>\n<p>In your case you failed to meet these conditions (e.g. the ordering), hence the \"bad\" behaviour of the map.</p>\n", "LastEditorUserId": "3941935", "LastActivityDate": "2015-08-12T11:51:53.607", "Score": "1", "CreationDate": "2015-08-12T10:45:54.503", "ParentId": "31952252", "CommentCount": "0", "OwnerUserId": "3941935", "LastEditDate": "2015-08-12T11:51:53.607"}, "31952386": {"Id": "31952386", "PostTypeId": "2", "Body": "<p>Without knowing exactly what your <code>a</code>, <code>b,</code> and <code>c</code> members actually represent, I can only guess, but I would think your operator should probably look something more like this instead:</p>\n<pre><code>bool MyClass::operator&lt;(const MyClass&amp; myClass) const\n{\n    if ((a &lt; myClass.a) || ((a == \"0\") &amp;&amp; (myClass.a != \"0\")))\n        return true;\n\n    if (a == myClass.a)\n    {\n        if ((b &lt; myClass.b) || ((b == \"0\") &amp;&amp; (myClass.b != \"0\")))\n            return true;\n\n        if (b == myClass.b)\n            return ((c &lt; myClass.c) || ((c == \"0\") &amp;&amp; (myClass.c != \"0\")));\n    }\n\n    return false;\n}\n</code></pre>\n", "LastActivityDate": "2015-08-11T21:36:13.247", "CommentCount": "0", "CreationDate": "2015-08-11T21:36:13.247", "ParentId": "31952252", "Score": "0", "OwnerUserId": "65863"}, "31952252": {"ViewCount": "81", "Body": "<p>I have a std::map that contains 3 elements, and I'm trying to to see if a key exists in the map. I have put the map through the debugger, and it contains all 3 elements added to it. When using find it stops after the first element and immediatley returns map.end()... I even made sure to override the operator&lt; in the key. Anyone have a clue why find is stopping after the first key?</p>\n<p>Here is the operator&lt; for the key:</p>\n<pre><code>bool MyClass::operator&lt;(const MyClass&amp; myClass) const\n{\n    bool aIsEqual = a == myClass.a || a == \"0\" || myClass.a == \"0\";\n    bool bIsEqual = b == myClass.b || b == \"0\" || myClass.b == \"0\";\n    bool cIsEqual = c == myClass.c || c == \"0\" || myClass.c == \"0\";\n\n    return !aIsEqual || !bIsEqual || !cIsEqual;\n}\n</code></pre>\n", "Title": "std::map.find() stopping at first element?", "CreationDate": "2015-08-11T21:25:44.800", "LastActivityDate": "2015-08-12T11:51:53.607", "CommentCount": "6", "LastEditDate": "2015-08-11T23:51:19.850", "PostTypeId": "1", "LastEditorUserId": "3723423", "Id": "31952252", "Score": "1", "OwnerUserId": "1932934", "Tags": "<c++><dictionary><stl>", "AnswerCount": "2"}});