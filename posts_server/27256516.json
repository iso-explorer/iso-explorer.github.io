post_cb({"27256600": {"ParentId": "27256516", "CommentCount": "2", "Body": "<p><code>const T&amp;</code> does not turn into <code>int&amp;</code> in this example: in <code>f&lt;int&amp;&gt;(i)</code>, you are explicitly setting <code>T</code> to <code>int&amp;</code>. <code>const</code> only enters the picture when that definition of <code>T</code> is used to determine the type of <code>val</code>, which becomes <code>const int&amp;</code> (one subtlety there is that references are collapsed during this substitution, so you don't wind up with two <code>&amp;</code>'s in the type).</p>\n", "OwnerUserId": "2985545", "PostTypeId": "2", "Id": "27256600", "Score": "1", "CreationDate": "2014-12-02T18:40:13.317", "LastActivityDate": "2014-12-02T18:40:13.317"}, "27256903": {"ParentId": "27256516", "CommentCount": "3", "Body": "<p>I would like to append other posts with the following quote from the C++ Standard (8.3.2 References)</p>\n<blockquote>\n<p id=\"so_27256516_27256903_0\">1... Cv-qualified references are ill-formed except when the cv-qualifiers are introduced through the use of a typedef-name (7.1.3,\n  14.1) or decltype-specificer (7.1.6.2), in which case the <strong>cv-qualifiers are ignored.</strong></p>\n</blockquote>\n<pre><code>[ Example:\ntypedef int&amp; A;\nconst A aref = 3; // ill-formed; lvalue reference to non-const initialized with rvalue\n</code></pre>\n<p>In the example above from the C++ Standard the last statement will not be compiled because qualifier const is ignored (according to the quote) and you may not bind rvalue with a non-const reference.</p>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "27256903", "Score": "3", "CreationDate": "2014-12-02T18:58:59.253", "LastActivityDate": "2014-12-02T18:58:59.253"}, "27256516": {"CommentCount": "2", "AcceptedAnswerId": "27256623", "PostTypeId": "1", "LastEditorUserId": "2985545", "CreationDate": "2014-12-02T18:34:32.497", "LastActivityDate": "2015-08-14T17:34:23.963", "LastEditDate": "2014-12-02T19:21:41.243", "ViewCount": "161", "FavoriteCount": "0", "Title": "C++: template function with explicitly specified reference type as type parameter", "Id": "27256516", "Score": "3", "Body": "<p>I was playing with C++ template type deduction and managed to compile this little program.</p>\n<pre><code>template&lt;typename T&gt;\n void f(const T&amp; val)\n {\n   val = 1;\n }\n\n\n int main()\n {\n    int i = 0;\n    f&lt;int&amp;&gt;(i);\n }\n</code></pre>\n<p></p>\n<p>It compiles on all major compilers but I do not understand why. Why can <code>f</code> assign to <code>val</code>, when <code>val</code> is explicitly marked <code>const</code>? Is it bug in these compilers or is it valid behavior according to the C++ standard?</p>\n", "Tags": "<c++><function-templates>", "OwnerUserId": "4316978", "AnswerCount": "3"}, "27256623": {"ParentId": "27256516", "LastEditDate": "2014-12-02T22:27:38.200", "CommentCount": "1", "CreationDate": "2014-12-02T18:41:51.047", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "PostTypeId": "2", "Id": "27256623", "Score": "4", "Body": "<p>\u00a78.3.2 [dcl.ref]/p6:</p>\n<blockquote>\n<p id=\"so_27256516_27256623_0\">If a <em>typedef-name</em> (7.1.3, 14.1)<sup>*</sup> or a <em>decltype-specifier</em> (7.1.6.2)\n  denotes a type TR that is a reference to a type T, an attempt to\n  create the type \u201clvalue reference to cv TR\u201d creates the type \u201clvalue\n  reference to T\u201d, while an attempt to create the type \u201crvalue reference\n  to cv TR\u201d creates the type TR.</p>\n</blockquote>\n<p>This is known as <em>reference collapsing</em> and is introduced in C++11. In C++03, your code would be ill-formed, but some compilers supported it as an extension.</p>\n<p>Note that in <code>const T &amp;</code>, the <code>const</code> applies to the type <code>T</code>, so when <code>T</code> is <code>int &amp;</code>, the <code>const</code> would apply to the reference type itself (which is meaningless as references are immutable anyway), not the type referred to. This is why the reference collapsing specification ignores any cv-qualifiers on <code>TR</code>.</p>\n<hr>\n<p><sub><sup>*</sup>A template type parameter is a <em>typedef-name</em>, per \u00a714.1 [temp.param]/p3:</sub></p>\n<blockquote>\n<p id=\"so_27256516_27256623_1\">A <em>type-parameter</em> whose identifier does not follow an ellipsis\n  defines its <em>identifier</em> to be a <em>typedef-name</em> (if declared with\n  <code>class</code> or <code>typename</code>) or <em>template-name</em> (if declared with\n  <code>template</code>) in the scope of the template declaration.</p></blockquote></hr>\n", "LastActivityDate": "2014-12-02T22:27:38.200"}, "bq_ids": {"n4140": {"so_27256516_27256903_0": {"section_id": 3218, "quality": 0.7647058823529411, "length": 13}, "so_27256516_27256623_0": {"section_id": 3223, "quality": 0.8846153846153846, "length": 23}, "so_27256516_27256623_1": {"section_id": 56, "quality": 1.0, "length": 19}}, "n3337": {"so_27256516_27256903_0": {"section_id": 3092, "quality": 0.7058823529411765, "length": 12}, "so_27256516_27256623_0": {"section_id": 3097, "quality": 0.8461538461538461, "length": 22}, "so_27256516_27256623_1": {"section_id": 51, "quality": 1.0, "length": 19}}, "n4659": {"so_27256516_27256903_0": {"section_id": 3975, "quality": 0.7647058823529411, "length": 13}, "so_27256516_27256623_0": {"section_id": 3980, "quality": 0.8846153846153846, "length": 23}, "so_27256516_27256623_1": {"section_id": 58, "quality": 0.8947368421052632, "length": 17}}}});