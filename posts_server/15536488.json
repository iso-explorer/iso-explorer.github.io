post_cb({"bq_ids": {"n4140": {"so_15536488_15536838_0": {"length": 12, "quality": 1.0, "section_id": 5517}}, "n3337": {"so_15536488_15536838_0": {"length": 12, "quality": 1.0, "section_id": 5303}}, "n4659": {"so_15536488_15536838_0": {"length": 12, "quality": 1.0, "section_id": 6952}}}, "15536488": {"ViewCount": "1201", "Body": "<p>With normal functions, one can write</p>\n<pre><code>extern \"C\" int Frotz(int);  // in a header\n\nint Frotz(int x) { return x; }\n</code></pre>\n<p>With function pointers, however, this appears to have been implemented inconsistently between compilers.</p>\n<pre><code>extern \"C\" int Klutz(int (*)(int), int);\n\nint Klutz(int (*fptr)(int), int x) { return (*fptr)(x); }\n</code></pre>\n<p>In the declaration, the argument is also <code>extern \"C\"</code>. In the definition, most compilers appear to match these functions and make <code>Klutz</code> an <code>extern \"C\"</code> function. The Sun and Cray compilers, however, interpret these functions as being different, producing an overloaded <code>int Klutz(int (*fptr)(int), int x)</code>, which later generates a link-time error.</p>\n<p>Although Section 7.5.5 of C++98 and C++11 guarantees the interpretation of <code>Frotz</code>, I cannot tell if the standard is ambiguous about whether <code>extern \"C\"</code> matching should occur before or after checking for overloading.</p>\n<p>Should <code>Klutz</code> above generate a mangled (C++) symbol or an <code>extern \"C\"</code> symbol?</p>\n<h3>EDIT 1</h3>\n<p>I could use a typedef to disambiguate the function pointer to have C or C++ ABI, but I'm interested in whether the code here (a) defines <code>Klutz</code> to have C++ linkage, (b) defines it to have C linkage, or (c) is ambiguous according to the standard, so that compilers are free to choose how to interpret it.</p>\n<h3>EDIT 2</h3>\n<p>This appears to be a known issue, at least by those compilers with searchable bug trackers. In my tests, GCC, Clang, Intel, MSVC, IBM XL, PathScale, PGI, and Open64 all fail to distinguish function types that are identical except for language linkage, as explicitly required by the standard (see section 7.5.1, quoted in the accepted answer). Fixing this would break a lot of existing code and require an ABI change. I'm not aware of any compiler that actually uses a different calling convention for C versus C++ language linkage.</p>\n<ul>\n<li><p><a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=2316\" rel=\"nofollow\">GCC bug</a>: \"Finding reasons to ask for the removal of this feature from the next standard is kind of relevant ;-)\" ... \"And we may even decide on an official WONTFIX.\"</p></li>\n<li><p><a href=\"http://llvm.org/bugs/show_bug.cgi?id=6277\" rel=\"nofollow\">Clang bug</a>: \"I'm terrified of actually enforcing this rule, because doing it properly means making language linkage part of the canonical type, which is going to break a ton of code.\"</p></li>\n</ul>\n", "AcceptedAnswerId": "15536838", "Title": "Possible ambiguity with extern \"C\", overloading, and function pointers", "CreationDate": "2013-03-20T23:07:31.647", "Id": "15536488", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-03-21T22:41:47.230", "LastEditorUserId": "33208", "LastActivityDate": "2013-03-21T22:41:47.230", "Score": "11", "OwnerUserId": "33208", "Tags": "<c++><standards>", "AnswerCount": "1"}, "15536838": {"Id": "15536838", "PostTypeId": "2", "Body": "<p>The C ABI and the C++ ABI are not guaranteed to be the same. So, an <code>extern \"C\"</code> function pointer is a different type from a C++ function pointer.  You need something like this:</p>\n<pre><code>extern \"C\" {\n    typedef int (*KlutzFuncType)(int);\n    int Klutz (KlutzFuncType, int);\n}\n\nint Klutz (KlutzFuncType fptr, int x) { return (*fptr)(x); }\n</code></pre>\n<p>There is some discussion of this issue <a href=\"https://stackoverflow.com/q/11873939/315052\">here</a>.</p>\n<hr>\n<p>I only have a copy of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow noreferrer\">draft</a>. From 7.5p1:</p>\n<blockquote>\n<p id=\"so_15536488_15536838_0\">Two function types with different language linkages are distinct types even if they are otherwise identical.</p>\n</blockquote>\n<p>My reading of this is that the first parameter of your first <code>Klutz</code> has a different type than the first parameter of your second <code>Klutz</code>, and so your second <code>Klutz</code> should have C++ linkage.</p>\n<hr>\n<p>There are C++ implementations that do not take language linkage into account for function types, despite what the standard says. In the following code snippet, <code>KlutzCxxFuncType</code> refers to a function with C++ linkage, while <code>KlutzCFuncType</code> refers to a function with C linkage.</p>\n<pre><code>typedef int (*KlutzCxxFuncType)(int);\n\nextern \"C\" {\n    typedef int (*KlutzCFuncType)(int);\n    int Klutz (KlutzCFuncType, int);\n}\n\nint Klutz (KlutzCxxFuncType fptr, int x) { return (*fptr)(x); }\nint Klutz (KlutzCFuncType fptr, int x) { return (*fptr)(x); }\n</code></pre>\n<p>A compiler that does not distinguish function types based on language linkage will generate a redefinition error on this code. For example, <code>g++ 4.7.2</code> will emit:</p>\n<pre><code>prog.cpp: In function \u2018int Klutz(KlutzCFuncType, int)\u2019:\nprog.cpp:9:5: error: redefinition of \u2018int Klutz(KlutzCFuncType, int)\u2019\nprog.cpp:8:5: error: \u2018int Klutz(KlutzCxxFuncType, int)\u2019 previously defined here\n</code></pre>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-03-21T15:29:32.507", "Score": "8", "CreationDate": "2013-03-20T23:38:16.530", "ParentId": "15536488", "CommentCount": "5", "OwnerUserId": "315052", "LastEditDate": "2017-05-23T12:04:55.860"}});