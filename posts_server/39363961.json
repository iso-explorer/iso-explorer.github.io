post_cb({"39363961": {"CommentCount": "1", "ViewCount": "580", "PostTypeId": "1", "LastEditorUserId": "315052", "CreationDate": "2016-09-07T07:39:50.563", "LastActivityDate": "2016-09-07T17:08:44.213", "Title": "Questions about class template argument deduction in C++17", "FavoriteCount": "1", "LastEditDate": "2016-09-07T17:08:44.213", "Id": "39363961", "Score": "4", "Body": "<p>I'm trying to make sense of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html\" rel=\"nofollow\">P0091r3</a> (the \"template argument deduction for class templates\" paper that has been adopted into the current C++ draft standard, N4606).</p>\n<p>I believe I understand how it works in the simplest possible case, where the <em>template-name</em> identifies a single template:</p>\n<pre><code>template&lt;class T&gt;\nstruct S {\n    S(T);\n    S(const std::vector&lt;T&gt;&amp;);\n};\n\nint main()\n{\n    std::vector&lt;int&gt; v;\n    auto s = S(v);\n}\n</code></pre>\n<p><code>S</code> identifies the primary template, so we create a fictitious overload set consisting of</p>\n<pre><code>template&lt;class T&gt; void Sctor(T);\ntemplate&lt;class T&gt; void Sctor(const std::vector&lt;T&gt;&amp;);\n</code></pre>\n<p>and perform overload resolution on the fictitious call</p>\n<pre><code>Sctor(v)\n</code></pre>\n<p>to determine that in this case we want to call the fictitious <code>Sctor(const std::vector&lt;T&gt;&amp;) [with T=int]</code>. Which means we end up calling <code>S&lt;int&gt;::S(const std::vector&lt;int&gt;&amp;)</code> and everything works great.</p>\n<p>What I don't understand is how this is supposed to work in the presence of partial specializations.</p>\n<pre><code>template&lt;class T&gt;\nstruct S {\n    S(T);\n};\n\ntemplate&lt;class T&gt;\nstruct S&lt;std::list&lt;T&gt;&gt; {\n    S(const std::vector&lt;T&gt;&amp;);\n};\n\nint main()\n{\n    std::vector&lt;int&gt; v;\n    auto s = S(v);\n}\n</code></pre>\n<p>What we intuitively <em>want</em> here is a call to <code>S&lt;std::list&lt;int&gt;&gt;::S(const std::vector&lt;int&gt;&amp;)</code>. Is that what we actually get, though? and where is this specified?</p>\n<p>Basically I don't intuitively understand what P0091r3 means by \"the class template designated by the <em>template-name</em>\": does that mean the primary template, or does it include all partial specializations and explicit full specializations as well?</p>\n<p>(I also don't understand how P0091r3's changes to \u00a77.1.6.2p2 don't break code using <em>injected-class-name</em>s such as</p>\n<pre><code>template&lt;class T&gt;\nstruct iterator {\n    iterator&amp; operator++(int) {\n        iterator result = *this;  // injected-class-name or placeholder?\n        //...\n    }\n};\n</code></pre>\n<p>but that's a different question altogether.)</p>\n<hr>\n<p>Are class template deduction and explicit deduction guides supported in any extant version of Clang or GCC (possibly under an <code>-f</code> flag, like <code>-fconcepts</code> is)? If so, I could play around with some of these examples in real life and probably clear up half of my confusion.</p>\n</hr>", "Tags": "<c++><templates><language-lawyer><template-meta-programming><c++1z>", "OwnerUserId": "1424877", "AnswerCount": "2"}, "39372580": {"ParentId": "39363961", "CommentCount": "0", "Body": "<p>I would say that the wording of P0091 as it currently stands is under-specified in this regard. It does need to make it clear whether it is just the primary class template or whether it includes the constructors of all specializations.</p>\n<p>That being said, I believe that the <em>intent</em> of P0091 is that partial specializations do not participate in argument deduction. The feature is to allow the compiler to decide what a class's template arguments are. However, what selects a partial specialization is what those template arguments actually are. The way to get the <code>S&lt;std::list&lt;T&gt;&gt;</code> specialization is to use a <code>std::list</code> in the template argument list of <code>S</code>.</p>\n<p>If you want to cause a specific parameter to use a specific specialization, you should use a deduction guide. That is what they're for, after all.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "39372580", "Score": "1", "CreationDate": "2016-09-07T14:25:20.750", "LastActivityDate": "2016-09-07T14:25:20.750"}, "39374845": {"ParentId": "39363961", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This is somewhat skated over by the proposal, but I think the intent is that only constructors of the primary class template are considered. Evidence for this is that the new <strong>[class.template.deduction]</strong> has: </p>\n<blockquote id=\"so_39363961_39374845_0\">\n<ul>\n<li>For each constructor of <strong>the class template</strong> designated by the template-name, a function template with the following properties is a candidate: [...]</li>\n</ul>\n</blockquote>\n<p>If we're talking about \"the\" class template, then this is the primary class template, particularly as class template partial specializations are not found by name lookup ([temp.class.spec]/6). This is also how the prototype implementation (see below) appears to behave.</p>\n<p>Within the paper, class template partial specializations are contemplated in the section \"Pros and cons of implicit deduction guides\", but rather out of concern that constructors within the main class template could trigger a hard (non-SFINAE) error:</p>\n<pre><code>template&lt;class T&gt; struct X {\n   using ty = T::type;\n   static auto foo() { return typename T::type{} };\n   X(ty); #1\n   X(decltype(foo())); #2\n   X(T);\n};\ntemplate&lt;class T&gt;\nstruct X&lt;T*&gt; { \n   X(...);\n};\nX x{(int *)0};\n</code></pre>\n<p>Your plea for class template partial specialization constructors to be considered is on the face of it reasonable, but note that it could result in ambiguity:</p>\n<pre><code>template&lt;class T&gt; struct Y { Y(T*); };\ntemplate&lt;class T&gt; struct Y&lt;T*&gt; { Y(T*); };\nY y{(int*) 0};\n</code></pre>\n<p>It would probably be desirable for the implicitly generated deduction guides to be ranked (as a tie-breaker) by specialization of the class template.</p>\n<p>If you want to try out a prototype implementation, the authors have published their branch of clang on github: <a href=\"https://github.com/faisalv/clang/tree/clang-ctor-deduction\" rel=\"nofollow\">https://github.com/faisalv/clang/tree/clang-ctor-deduction</a>.</p>\n<hr>\n<p>Discussion in the paper (\"A note on injected class names\") indicates that injected-class-names take priority over template names; wording is added to ensure this:</p>\n<blockquote>\n<p id=\"so_39363961_39374845_1\">The <em>template-name</em> shall name a class template that is not an <em>injected-class-name</em>.</p>\n</blockquote>\n</hr>", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2016-09-07T17:04:13.580", "Id": "39374845", "Score": "2", "CreationDate": "2016-09-07T16:13:13.530", "LastActivityDate": "2016-09-07T17:04:13.580"}, "bq_ids": {"n4140": {"so_39363961_39374845_1": {"section_id": 191, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_39363961_39374845_1": {"section_id": 185, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_39363961_39374845_1": {"section_id": 6865, "quality": 0.8333333333333334, "length": 5}, "so_39363961_39374845_0": {"section_id": 623, "quality": 0.9166666666666666, "length": 11}}}});