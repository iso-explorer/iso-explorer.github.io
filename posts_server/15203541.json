post_cb({"15204239": {"ParentId": "15203541", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>A segfault is outside of C++'s exception system. If you dereference a null pointer, you don't get any kind of exception thrown (well, atleast if you comply with the <code>Require:</code> clause; see below for details).</p>\n<p>For <code>operator-&gt;</code>, it's typically implemented as simply <code>return m_ptr;</code> (or <code>return get();</code> for <code>unique_ptr</code>). As you can see, the operator itself can't throw - it just returns the pointer. No dereferencing, no nothing. The language has some special rules for <code>p-&gt;identifier</code>:</p>\n<p><code>\u00a713.5.6 [over.ref] p1</code></p>\n<blockquote>\n<p id=\"so_15203541_15204239_0\">An expression <code>x-&gt;m</code> is interpreted as <code>(x.operator-&gt;())-&gt;m</code> for a class object <code>x</code> of type <code>T</code> if <code>T::operator-&gt;()</code> exists and if the operator is selected as the best match function by the overload resolution mechanism (13.3).</p>\n</blockquote>\n<p>The above applies recursively and in the end must yield a pointer, for which the built-in <code>operator-&gt;</code> is used. This allows users of smart pointers and iterators to simply do <code>smart-&gt;fun()</code> without worrying about anything.</p>\n<p>A note for the <code>Require:</code> parts of the specification: These denote preconditions. If you don't meet them, you're invoking UB.</p>\n<blockquote>\n<p id=\"so_15203541_15204239_1\">Why then, is one of these specified as noexcept and the other not?</p>\n</blockquote>\n<p>To be honest, I'm not sure. It would seem that dereferencing a pointer should always be <code>noexcept</code>, however, <code>unique_ptr</code> allows you to completely <em>change</em> what the internal pointer type is (through the deleter). Now, as the user, you can define entirely different semantics for <code>operator*</code> on your <code>pointer</code> type. Maybe it computes things on the fly? All that fun stuff, which may throw.</p>\n<hr>\n<blockquote>\n<p id=\"so_15203541_15204239_2\">Looking at std::shared_ptr we have this:</p>\n</blockquote>\n<p>This is easy to explain - <code>shared_ptr</code> doesn't support the above-mentioned customization to the pointer type, which means the built-in semantics <em>always</em> apply - and <code>*p</code> where <code>p</code> is <code>T*</code> simply doesn't throw.</p>\n</hr>", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2013-03-04T15:04:19.340", "Id": "15204239", "Score": "25", "CreationDate": "2013-03-04T14:47:42.833", "LastActivityDate": "2013-03-04T15:04:19.340"}, "15203541": {"CommentCount": "2", "AcceptedAnswerId": "15204239", "PostTypeId": "1", "LastEditorUserId": "174614", "CreationDate": "2013-03-04T14:14:12.647", "LastActivityDate": "2014-02-09T01:02:32.570", "LastEditDate": "2013-03-04T15:01:31.860", "ViewCount": "3118", "FavoriteCount": "5", "Title": "Why does std::unique_ptr operator* throw and operator-> does not throw?", "Id": "15203541", "Score": "33", "Body": "<p>In the C++ standard draft (N3485), it states the following:</p>\n<p><strong>20.7.1.2.4 unique_ptr observers [unique.ptr.single.observers]</strong></p>\n<pre><code>typename add_lvalue_reference&lt;T&gt;::type operator*() const;\n\n1 Requires: get() != nullptr.\n2 Returns: *get().\n\npointer operator-&gt;() const noexcept;\n\n3 Requires: get() != nullptr.\n4 Returns: get().\n5 Note: use typically requires that T be a complete type.\n</code></pre>\n<p>You can see that <code>operator*</code> (dereference) is not specified as <code>noexcept</code>, probably because it can cause a segfault, but then <code>operator-&gt;</code> on the same object is specified as <code>noexcept</code>.  The requirements for both are the same, however there is a difference in exception specification.</p>\n<p>I have noticed they have different return types, one returns a pointer and the other a reference. Is that saying that <code>operator-&gt;</code> doesn't actually dereference anything?</p>\n<p>The fact of the matter is that using <code>operator-&gt;</code> on a pointer of any kind which is NULL, will segfault (is UB).  Why then, is one of these specified as <code>noexcept</code> and the other not?</p>\n<p>I'm sure I've overlooked something.</p>\n<p>EDIT:</p>\n<p>Looking at <code>std::shared_ptr</code> we have this:</p>\n<p><strong>20.7.2.2.5 shared_ptr observers [util.smartptr.shared.obs]</strong></p>\n<pre><code>T&amp; operator*() const noexcept;\n\nT* operator-&gt;() const noexcept;\n</code></pre>\n<p>It's not the same? Does that have anything to do with the different ownership semantics? </p>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "174614", "AnswerCount": "4"}, "15204228": {"ParentId": "15203541", "CommentCount": "7", "Body": "<p>Regarding:</p>\n<blockquote>\n<p id=\"so_15203541_15204228_0\">Is that saying that operator-&gt; doesn't actually dereference anything?</p>\n</blockquote>\n<p>No, the standard evaluation of <code>-&gt;</code> for a type overloading <code>operator-&gt;</code> is:</p>\n<pre><code>a-&gt;b; // (a.operator-&gt;())-&gt;b\n</code></pre>\n<p>I.e. the evaluation is defined recursively, when the source code contains a <code>-&gt;</code>, <code>operator-&gt;</code> is applied yielding another expression with an <code>-&gt;</code> that can itself refer to a <code>operator-&gt;</code>...</p>\n<p>Regarding the overall question, if the pointer is null, the behavior is undefined, and the lack of <code>noexcept</code> allows an implementation to <code>throw</code>. If the signature was <code>noexcept</code> then the implementation could not <code>throw</code> (a <code>throw</code> would be a call to <code>std::terminate</code>).</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "15204228", "Score": "-2", "CreationDate": "2013-03-04T14:47:16.573", "LastActivityDate": "2013-03-04T14:47:16.573"}, "21653868": {"ParentId": "15203541", "CommentCount": "0", "Body": "<p>For what it's worth, here's a little of the history, and how things got the way they are now.</p>\n<p>Before N3025, <code>operator *</code> wasn't specified with <code>noexcept</code>, but its description did contain a <code>Throws: nothing</code>. This requirement was removed in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3025.html\" rel=\"nofollow\">N3025</a>:</p>\n<blockquote>\n<p id=\"so_15203541_21653868_0\">Change [unique.ptr.single.observers] as indicated (834) [For details see the Remarks section]:</p>\n<p id=\"so_15203541_21653868_1\"><code>typename add_lvalue_reference&lt;T&gt;::type operator*() const;</code><br>\n  1 - Requires: <code>get() !=</code><strike>0</strike><code>nullptr</code>.<br>\n  2 - Returns: <code>*get().</code><br>\n<strike>3 - Throws: nothing.</strike></br></br></br></p>\n</blockquote>\n<p>Here's the content of the \"Remarks\" section noted above:</p>\n<blockquote>\n<p id=\"so_15203541_21653868_2\">During reviews of this paper it became controversial how to properly specify the operational semantics of operator*, operator[], and the heterogenous comparison functions. [structure.specifications]/3 doesn't clearly say whether a Returns element (in the absence of the new Equivalent to formula) specifies effects. Further-on it's unclear whether this would allow for such a return expression to exit via an exception, if additionally a Throws:-Nothing element is provided (would the implementor be required to catch those?). To resolve this conflict, any existing Throws element was removed for these operations, which is at least consistent with [unique.ptr.special] and other parts of the standard. The result of this is that we give now implicit support for potentially throwing comparison functions, but not for homogeneous == and !=, which might be a bit surprising.</p>\n</blockquote>\n<p>The same paper also contains a recommendation for editing the definition of <code>operator -&gt;</code>, but it reads as follows:</p>\n<blockquote>\n<p id=\"so_15203541_21653868_3\"><code>pointer operator-&gt;() const;</code><br>\n  4 - Requires: <code>get() !=</code><strike>0</strike>nullptr.<br>\n  5 - Returns: get().<br>\n  6 - Throws: nothing.<br>\n  7 - Note: use typically requires that T be a complete type.</br></br></br></br></p>\n</blockquote>\n<p>As far as the question itself goes: it comes down to a basic difference between the operator itself, and the expression in which the operator is used.</p>\n<p>When you use <code>operator*</code>, the operator dereferences the pointer, which can throw.</p>\n<p>When you use <code>operator-&gt;</code>, the operator itself just returns a pointer (which isn't allowed to throw). That pointer is then dereferenced in the expression that contained the <code>-&gt;</code>. Any exception from dereferencing the pointer happens in the surrounding expression rather than in the operator itself.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "21653868", "Score": "4", "CreationDate": "2014-02-09T01:02:32.570", "LastActivityDate": "2014-02-09T01:02:32.570"}, "bq_ids": {"n4140": {"so_15203541_15204239_0": {"section_id": 664, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_15203541_15204239_0": {"section_id": 654, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_15203541_15204239_0": {"section_id": 692, "quality": 0.9411764705882353, "length": 16}}}, "15209134": {"ParentId": "15203541", "CommentCount": "1", "Body": "<p>Frankly, this just looks like a defect to me. Conceptually, a-&gt;b should always be equivalent to (*a).b, and this applies even if a is a smart pointer. But if *a isn't noexcept, then (*a).b isn't, and therefore a-&gt;b shouldn't be.</p>\n", "OwnerUserId": "8922", "PostTypeId": "2", "Id": "15209134", "Score": "1", "CreationDate": "2013-03-04T19:07:35.920", "LastActivityDate": "2013-03-04T19:07:35.920"}});