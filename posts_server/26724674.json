post_cb({"bq_ids": {"n4140": {"so_26724674_26725089_1": {"length": 18, "quality": 0.9, "section_id": 603}, "so_26724674_26725089_4": {"length": 17, "quality": 0.9444444444444444, "section_id": 11}, "so_26724674_26725089_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 3321}, "so_26724674_26725089_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 625}, "so_26724674_26725089_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 603}}, "n3337": {"so_26724674_26725089_4": {"length": 17, "quality": 0.9444444444444444, "section_id": 8}, "so_26724674_26725089_1": {"length": 18, "quality": 0.9, "section_id": 593}, "so_26724674_26725089_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 3191}, "so_26724674_26725089_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 615}, "so_26724674_26725089_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 593}}, "n4659": {"so_26724674_26725089_4": {"length": 17, "quality": 0.9444444444444444, "section_id": 12}, "so_26724674_26725089_1": {"length": 18, "quality": 0.9, "section_id": 629}, "so_26724674_26725089_3": {"length": 11, "quality": 0.7333333333333333, "section_id": 4087}, "so_26724674_26725089_2": {"length": 26, "quality": 0.9285714285714286, "section_id": 651}, "so_26724674_26725089_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 629}}}, "26725089": {"Id": "26725089", "PostTypeId": "2", "Body": "<p>The first call chooses the function template specialization - because it's a better match.<br>\nLet us label both overloads:</br></p>\n<pre><code>template&lt;size_t N&gt; void cm(const char (&amp;h)[N])  // (1) - the specialization\n    {std::cout &lt;&lt; \" const (&amp;)[N] \" &lt;&lt; endl;}\n\nvoid cm(const char * h)                         // (2)\n    {cout &lt;&lt; \" const char * \" &lt;&lt; endl;}\n</code></pre>\n<p>For (1), <code>car</code> binds to a reference. That is an identity conversion<sup>1</sup>.\nFor (2), after the array-to-pointer conversion of <code>car</code>, which yields <code>char*</code><sup>2</sup>, a qualification conversion has to be done so <code>char*</code> becomes <br><code>char const*</code>. That is now invoking this:</br></p>\n<blockquote>\n<p id=\"so_26724674_26725089_0\">Standard conversion sequence <code>S1</code> is a better conversion sequence than\n  standard conversion sequence <code>S2</code> if</p>\n<ul>\n<li><code>S1</code> is a proper subsequence of <code>S2</code> (comparing the conversion sequences in the canonical form defined by 13.3.3.1.1, <strong>excluding any\n  Lvalue Transformation; the identity conversion sequence is\n  considered to be a subsequence of any non-identity conversion\n  sequence</strong>) or, if not that,</li>\n<li>[\u2026]</li>\n</ul>\n</blockquote>\n<p>An array-to-pointer conversion is an Lvalue Transformation, so it isn't considered here - just as in the second example. The qualification conversion has an own category though: <em>Qualification Adjustment</em>. Therefore the conversion to the parameter of (1) is a subsequence of the conversion to the parameter of (2): The first is an identity conversion and the second a qualification conversion, and according to the paragraph above an identity conversion is a subsequence of any non-identity conversion. So (1) is chosen.</p>\n<p>As you already mentioned yourself, in the second case the conversions are equally good; The quote above does not work since the conversion to (2)s parameter is not a subsequence of the conversion to the parameter of (1). Hence, [over.match.best]/1 applies.</p>\n<blockquote>\n<p id=\"so_26724674_26725089_1\">Given these definitions, a viable function <code>F1</code> is defined to be a\n  better function than another viable function <code>F2</code> if for all arguments\n  i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<ul>\n<li>for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,</li>\n<li>the context is an initialization by user-defined conversion [\u2026], or, if not that,</li>\n<li><strong><code>F1</code> is a non-template function and <code>F2</code> is a function template specialization</strong>,</li>\n</ul>\n</blockquote>\n<p>So (2) one is chosen. If the function template wasn't a template but a function with parameter <br><code>char const (&amp;)[8]</code> the call would be ambiguous <a href=\"http://coliru.stacked-crooked.com/a/7bf0cdd049214491\" rel=\"nofollow\">as Clang correctly says</a>.</br></p>\n<hr>\n<p><sup>1</sup>  [over.ics.ref]/1:</p>\n<blockquote>\n<p id=\"so_26724674_26725089_2\"><strong>When a parameter of reference type binds directly (8.5.3) to an\n  argument expression, the implicit conversion sequence is the identity\n  conversion</strong>, unless the argument expression has a type that is a\n  derived class of the parameter type, in which case the implicit\n  conversion sequence is a derived-to-base Conversion (13.3.3.1).</p>\n</blockquote>\n<p>[dcl.init.ref]/5 (which is in 8.5.3):</p>\n<blockquote>\n<p id=\"so_26724674_26725089_3\">In all cases except the last (i.e., creating and initializing a\n  temporary from the initializer expression), the reference is said to\n  <em>bind directly</em> to the initializer expression.</p>\n</blockquote>\n<p><br>\n<sup>2</sup> [conv.array]:</br></p>\n<blockquote>\n<p id=\"so_26724674_26725089_4\">An lvalue or rvalue of type \u201carray of <code>N T</code>\u201d or \u201carray of unknown\n  bound of <code>T</code>\u201d can be converted to a prvalue of type \u201cpointer to <code>T</code>\u201d.\n  The result is a pointer to the first element of the array.</p>\n</blockquote>\n<p><code>T</code> can be cv-qualified, and so would the type of the pointee be. Here <code>T</code> is just <code>char</code>, so the pointer is of type pointer to <code>char</code> =&gt; <code>char*</code>.</p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-04T00:17:11.763", "Score": "4", "CreationDate": "2014-11-03T23:21:14.653", "ParentId": "26724674", "CommentCount": "3", "OwnerUserId": "3647361", "LastEditDate": "2014-11-04T00:17:11.763"}, "26724898": {"Id": "26724898", "PostTypeId": "2", "Body": "<p>Because the string \"errqweq\" directly written in the code is read only because it is, at run time, in a part of memory \"protected\" as it is managed as a constant.</p>\n<p>Pointing at it using a <code>const char* ccar;</code> or a <code>const char ccar[];</code> is correct. You are pointing to the memory holding the original \"errqweq\" with the const specifier: the compiler ensure that the string will be not modified.</p>\n<p>But look at: <code>char car[] = \"errqweq\";</code></p>\n<p>In order to provide you a modificable buffer (as you are requesting without the const modifier) the compiler create an array of 8 elements (7 chars + \\0) on the stack copying in it (i.e: intializing it) the string \"errqweq\".</p>\n<p>So the first call is using a <code>char buffer[8]</code> arguments that is safely converted to a <code>const char buffer[8]</code>. Obviously the fixed size of the array give a best match with the template instead of the more \"weak\" bind with the function that requires \"just\" a constant pointer.</p>\n", "LastActivityDate": "2014-11-03T23:05:12.607", "CommentCount": "2", "CreationDate": "2014-11-03T23:05:12.607", "ParentId": "26724674", "Score": "2", "OwnerUserId": "1140699"}, "26724674": {"ViewCount": "145", "Body": "<p>Why does the first function call (<code>cm(car);</code>) bind to the first function?</p>\n<p>I understand that second call is bound to second function because it's non-template, despite both being perfect matches.</p>\n<p>If the first function is defined as non-template with fixed array length, as:</p>\n<pre><code>    void cm(const char (&amp;h)[8]) {cout &lt;&lt; \"const char (&amp;)[8]\" &lt;&lt; endl;}\n</code></pre>\n<p>than again it gets selected over the second one (the second call will be ambiguous that way).</p>\n<p>Code:</p>\n<pre><code>template&lt;size_t N&gt; void cm(const char (&amp;h)[N]) \n    {std::cout &lt;&lt; \" const (&amp;)[N] \" &lt;&lt; endl;}\n\nvoid cm(const char * h)\n    {cout &lt;&lt; \" const char * \" &lt;&lt; endl;}\n\nint main()\n{\n    char car[] = \"errqweq\";\n    const char ccar[] = \"errqweq\";\n    cm(car);\n    cm(ccar);\n}\n</code></pre>\n<p>Output:</p>\n<pre><code> const (&amp;)[N]\n const char * \n</code></pre>\n", "Title": "Why does the first function call bind to the first function?", "CreationDate": "2014-11-03T22:44:55.870", "LastActivityDate": "2016-03-18T10:16:41.037", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-18T10:16:41.037", "Tags": "<c++><function><templates><language-lawyer><overload-resolution>", "Id": "26724674", "LastEditorUserId": "3647361", "Score": "10", "OwnerUserId": "4212079", "ClosedDate": "2016-03-18T10:16:50.863", "AnswerCount": "2"}});