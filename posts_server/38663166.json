post_cb({"38663166": {"ViewCount": "863", "Body": "<p>I'm trying to create a specialized constructor for <code>std::string</code> arguments, but the other one is always used when I call it with a string argument.</p>\n<pre><code>struct Literal : Expression\n{    \n    template &lt;typename V&gt;\n    Literal(V val)\n    {\n        value = val;\n    }\n};\n\ntemplate &lt;&gt;\nLiteral::Literal(std::string const&amp; val)\n{\n    value = val.c_str();\n}\n</code></pre>\n<p>It doesn't matter if both are defined inside the class, both outside the class, or like in the posted example only the specialization is defined outside the class: When called with <code>std::string</code>, the assignment <code>value = val</code> gives a compiler error.</p>\n<p>How do I correctly specialize this constructor template for <code>std::string</code>?</p>\n", "AcceptedAnswerId": "38663211", "Title": "C++ constructor template specialization", "CreationDate": "2016-07-29T16:07:17.890", "Id": "38663166", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-07-29T17:06:37.213", "Score": "5", "OwnerUserId": "481061", "Tags": "<c++><templates><constructor><template-specialization>", "AnswerCount": "3"}, "38664084": {"Id": "38664084", "PostTypeId": "2", "Body": "<p>According to the <a href=\"http://eel.is/c++draft/temp.deduct.call\" rel=\"nofollow\">standard, 14.8.2.1</a> Deducing template arguments from a function call [temp.deduct.call] where <code>P</code> is the template parameter and <code>A</code> is the function-call argument in that position:</p>\n<blockquote>\n<p id=\"so_38663166_38664084_0\">2 If P is not a reference type:</p>\n<p id=\"so_38663166_38664084_1\">If A is an array type, the pointer type produced by the array-to-pointer = standard conversion ([conv.array]) is used in place of A for type deduction; otherwise,</p>\n<p id=\"so_38663166_38664084_2\">If A is a function type, the pointer type produced by the function-to-pointer standard conversion ([conv.func]) is used in place of A for type deduction; otherwise,</p>\n<p id=\"so_38663166_38664084_3\"><em>If A is a cv-qualified type, the top-level cv-qualifiers of A's type are ignored for type deduction.</em></p>\n<p id=\"so_38663166_38664084_4\">If P is a cv-qualified type, the top-level cv-qualifiers of P's type are ignored for type deduction. If P is a reference type, the type referred to by P is used for type deduction. [...]</p>\n</blockquote>\n<p>So given</p>\n<pre><code>std::string s{\"hello\"};\nconst std::string&amp; sr{s};\nLiteral l(sr);\n</code></pre>\n<p><code>A</code> (sr) is <code>const std::string&amp;</code> but the constness is not considered, so the compiler considered <code>std::string</code>. This matches your</p>\n<pre><code>template &lt;typename V&gt;\nLiteral(V val)\n{\n    value = val;\n}\n</code></pre>\n<p>and so it uses this specialization. If you had specialized</p>\n<pre><code>template&lt;&gt;\nLiteral(std::string val)\n</code></pre>\n<p>the compiler would find this specialization, and this is probably what you will have to do and use move semantics.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct S {\n    template&lt;typename T&gt;\n    S(T t) { std::cout &lt;&lt; \"T t\\n\"; }\n\n    std::string value_;\n};\n\ntemplate&lt;&gt;\nS::S(std::string value) {\n    std::cout &lt;&lt; \"string\\n\";\n    value_ = std::move(value);\n}\n\ntemplate&lt;&gt;\nS::S(const std::string&amp;) {\n    std::cout &lt;&lt; \"const string&amp;\\n\";\n}\n\nint main() {\n    S s1(42);\n\n    std::string foo{\"bar\"};\n    const std::string&amp; foor = foo;\n    S s2(foo);\n    S s3(foor);\n}\n</code></pre>\n<p><a href=\"http://ideone.com/eJJ5Ch\" rel=\"nofollow\">http://ideone.com/eJJ5Ch</a></p>\n", "LastActivityDate": "2016-07-29T17:06:37.213", "CommentCount": "1", "CreationDate": "2016-07-29T17:06:37.213", "ParentId": "38663166", "Score": "4", "OwnerUserId": "257645"}, "38663378": {"Id": "38663378", "PostTypeId": "2", "Body": "<p>Many times, when overload is a solution, people try to define full specialization. But overload could be a much better solution. In your case, I would create a new constructor with the string parameter.\nRemember that only base template is considered in overload resolution. The following article is a good reference to understand this idea:\n<a href=\"http://www.gotw.ca/publications/mill17.htm\" rel=\"nofollow\">http://www.gotw.ca/publications/mill17.htm</a></p>\n<p>UPDATE:</p>\n<p>Anyway, to improve my answer, you could try the following base template constructor:</p>\n<pre><code>template &lt;typename V&gt;\nLiteral(V const&amp; val)\n{\n    value = val;\n}\n</code></pre>\n", "LastEditorUserId": "6578349", "LastActivityDate": "2016-07-29T16:46:50.347", "Score": "1", "CreationDate": "2016-07-29T16:20:20.810", "ParentId": "38663166", "CommentCount": "0", "OwnerUserId": "6578349", "LastEditDate": "2016-07-29T16:46:50.347"}, "bq_ids": {"n4140": {"so_38663166_38664084_4": {"length": 13, "quality": 0.9285714285714286, "section_id": 304}, "so_38663166_38664084_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 303}, "so_38663166_38664084_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 303}, "so_38663166_38664084_3": {"length": 7, "quality": 0.875, "section_id": 303}}, "n3337": {"so_38663166_38664084_4": {"length": 13, "quality": 0.9285714285714286, "section_id": 295}, "so_38663166_38664084_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 294}, "so_38663166_38664084_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 294}, "so_38663166_38664084_3": {"length": 7, "quality": 0.875, "section_id": 294}}, "n4659": {"so_38663166_38664084_4": {"length": 14, "quality": 1.0, "section_id": 311}, "so_38663166_38664084_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 310}, "so_38663166_38664084_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 310}, "so_38663166_38664084_3": {"length": 8, "quality": 1.0, "section_id": 310}}}, "38663211": {"Id": "38663211", "PostTypeId": "2", "Body": "<p>You don't.</p>\n<p>You should overload the <em>constructor</em>: <code>Literal(const std::string&amp;)</code>, which you can do in the <code>struct</code> declaration.</p>\n<p>The compiler always tries to match non-template overloads before template ones.</p>\n", "LastEditorUserId": "2380830", "LastActivityDate": "2016-07-29T16:16:07.223", "Score": "6", "CreationDate": "2016-07-29T16:10:17.163", "ParentId": "38663166", "CommentCount": "5", "OwnerUserId": "2380830", "LastEditDate": "2016-07-29T16:16:07.223"}});