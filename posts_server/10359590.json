post_cb({"bq_ids": {"n4140": {"so_10359590_10359808_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 5440}, "so_10359590_10359808_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5440}, "so_10359590_10359808_5": {"length": 21, "quality": 1.0, "section_id": 6170}, "so_10359590_10359808_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 7206}, "so_10359590_10359808_3": {"length": 21, "quality": 0.9130434782608695, "section_id": 5940}}, "n3337": {"so_10359590_10359808_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 5235}, "so_10359590_10359808_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5235}, "so_10359590_10359808_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 6950}, "so_10359590_10359808_5": {"length": 21, "quality": 1.0, "section_id": 5931}, "so_10359590_10359808_3": {"length": 21, "quality": 0.9130434782608695, "section_id": 5711}}, "n4659": {"so_10359590_10359808_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6867}, "so_10359590_10359808_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6867}, "so_10359590_10359808_5": {"length": 21, "quality": 1.0, "section_id": 7668}, "so_10359590_10359808_4": {"length": 9, "quality": 0.8181818181818182, "section_id": 4058}, "so_10359590_10359808_3": {"length": 21, "quality": 0.9130434782608695, "section_id": 7424}}}, "10359590": {"ViewCount": "229", "Body": "<pre><code>typedef decltype(true ? (long&amp;&amp;)0 : (long&amp;&amp;)0) T;\n</code></pre>\n<p>What should T be?</p>\n<p>According to gcc (4.7), it's <code>long</code>. According to clang (trunk), it's <code>long&amp;&amp;</code>. This difference is causing clang to fail to compile code that uses gcc 4.7's libstdc++. Who is right?</p>\n<p><strong>UPDATE</strong>: As <strong>ildjarn</strong> points out, Clang is right, and as <strong>Richard Smith</strong> points out, the error libstdc++ is due to an error in the Standard. Here is the <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53000\" rel=\"nofollow\">relevant GCC bug</a>, and the <a href=\"http://cplusplus.github.com/LWG/lwg-active.html#2141\" rel=\"nofollow\">relevant Defect Report</a>.</p>\n", "AcceptedAnswerId": "10359808", "Title": "Rvalue references in a conditional expression", "CreationDate": "2012-04-28T00:51:23.160", "Id": "10359590", "CommentCount": "5", "LastEditDate": "2012-04-29T23:00:20.877", "PostTypeId": "1", "LastEditorUserId": "141719", "LastActivityDate": "2012-04-29T23:00:20.877", "Score": "3", "OwnerUserId": "141719", "Tags": "<c++><gcc><c++11><clang><decltype>", "AnswerCount": "1"}, "10359808": {"Id": "10359808", "PostTypeId": "2", "Body": "<p>Clang is right. N3337 \u00a77.1.6.2/4:</p>\n<blockquote>\n<p id=\"so_10359590_10359808_0\">The type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<ul>\n<li>if <code>e</code> is an unparenthesized <em>id-expression</em> or an unparenthesized class member access, <code>decltype(e)</code> is the type of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code> names a set of overloaded functions, the program is ill-formed;</li>\n<li><strong>otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code></strong>;</li>\n<li>otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;</li>\n<li>otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</li>\n</ul>\n<p id=\"so_10359590_10359808_1\">The operand of the <code>decltype</code> specifier is an unevaluated operand.</p>\n</blockquote>\n<p>\u00a75/6:</p>\n<blockquote>\n<p id=\"so_10359590_10359808_2\">[ <em>Note:</em> An expression is an xvalue if it is:</p>\n<ul>\n<li>the result of calling a function, whether implicitly or explicitly, whose return type is an rvalue reference to object type,</li>\n<li><strong>a cast to an rvalue reference to object type</strong>,</li>\n<li>a class member access expression designating a non-static data member of non-reference type in which the object expression is an xvalue, or</li>\n<li>a <code>.*</code> pointer-to-member expression in which the first operand is an xvalue and the second operand is a pointer to data member.</li>\n</ul>\n<p id=\"so_10359590_10359808_3\">In general, the effect of this rule is that named rvalue references are treated as lvalues and unnamed rvalue references to objects are treated as xvalues; rvalue references to functions are treated as lvalues whether named or not. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>I was wary earlier that a literal <code>0</code> may somehow prevent this from qualifying as an object type in this context, but \u00a73.9/8 clarifies things:</p>\n<blockquote>\n<p id=\"so_10359590_10359808_4\">An <em>object type</em> is a (possibly cv-qualified) type that is not a function type, not a reference type, and not a void type.</p>\n</blockquote>\n<p>The conditional operator doesn't affect anything here \u2013 \u00a75.16/4:</p>\n<blockquote>\n<p id=\"so_10359590_10359808_5\">If the second and third operands are glvalues of the same value category and have the same type, the result is of that type and value category and it is a bit-field if the second or the third operand is a bit-field, or if both are bit-fields.</p>\n</blockquote>\n<p>In this case both are of the same value category (xvalue), and xvalues are glvalues.</p>\n", "LastEditorUserId": "636019", "LastActivityDate": "2012-04-28T03:03:07.207", "Score": "5", "CreationDate": "2012-04-28T01:29:37.460", "ParentId": "10359590", "CommentCount": "2", "OwnerUserId": "636019", "LastEditDate": "2012-04-28T03:03:07.207"}});