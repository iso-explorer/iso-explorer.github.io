post_cb({"804686": {"ParentId": "804217", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The reason for the failure is that at instantiation, no unqualified name lookup for the functions occur (but only ADL - Argument Dependent Lookup). The instantiation context is (taken from <code>14.6.4.1/6</code> of the C++ Standard):</p>\n<blockquote>\n<p id=\"so_804217_804686_0\">The instantiation context of an expression that depends on the template arguments is the set of declarations with external linkage declared prior to the point of instantiation of the template specialization in the same translation unit.</p>\n</blockquote>\n<p>The point of instantiation of all those template specializations you called in this case is just after the definition of <code>test</code> (read <code>14.6.4.1/1</code>). So, all functions you declared are visible in your <code>test</code> function using unqualified lookup, but lookup for them is actually different for the function calls:</p>\n<p>A function call that depends on a template parameter within a template is looked up like this:</p>\n<ul>\n<li>Names from the template definition context are considered by both ordinary lookup and ADL.</li>\n<li>Names from instantiation context are considered only for ADL. </li>\n</ul>\n<p>This means that because there is no suitable <code>getClassName</code> function declared in the definition context of the template, a suitable function has to be found in the instantiation context using ADL - otherwise the call will fail and not find any declaration. </p>\n<h3>Argument Dependent Lookup (ADL)</h3>\n<p>For an argument of type <code>std::vector&lt;T&gt;</code>, ADL searches for functions in namespace <code>std</code> and the namespace of <code>T</code>. Putting the <code>getClassName</code> function into the <code>std</code> namespace would work for this (but doing so is not allowed by the Standard because that yields to undefined behavior - this should be done only as the last resort). </p>\n<p>To see the effects of <code>ADL</code> try to call <code>doIt</code> with a vector of <code>MyClass2</code> instead of <code>int</code>. Since then <code>T = MyClass2</code>, ADL will search in the namespace of <code>MyClass2</code> for a suitable function accepting a <code>std::vector&lt;MyClass2&gt;</code> and will succeed - opposed to when you use <code>int</code>, which will only look into <code>std</code>. </p>\n<p>For the other function calls, their respective declarations are all found too, because they are all declared in the global namespace, in which the argument types of the function calls are defined too (<code>MyClass1</code>, <code>MyClass2</code> etc).</p>\n<p>The C++ FAQ is good, but it doesn't go deep into templates (haven't found any mentioning of ADL in it). There is a dedicated <a href=\"http://womble.decadentplace.org.uk/c++/template-faq.html\" rel=\"nofollow noreferrer\">template faq</a> that handles some of the more intricate pitfalls. </p>\n<hr>\n<h3>Beware of undefined behavior</h3>\n<p>Note that many compilers will accept the code even when you put that declaration i showed <em>after</em> the <code>test</code> function (instead of before it). But as the above Standard quote says, then the declaration won't be part of the instantiation context and the rule found in <code>14.6.4.2/1</code> is to be watched:</p>\n<blockquote>\n<p id=\"so_804217_804686_1\">If the call would be ill-formed or would find a better match had the lookup within the associated namespaces considered all the function declarations with external linkage introduced in those namespaces in all translation units, not just considering those declarations found in the template definition and template instantiation contexts, then the program has undefined behavior.</p>\n</blockquote>\n<p>Thus, what would appear to work would be undefined behavior. It's valid for a compiler to accept it, but it's likewise valid for one to reject it or to crash and terminate. So watch that any name needed is indeed visible at the instantiation context as explained. </p>\n<p>Hope this helps.</p>\n</hr>", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2009-07-08T23:59:55.090", "Id": "804686", "Score": "4", "CreationDate": "2009-04-29T23:05:08.287", "LastActivityDate": "2009-07-08T23:59:55.090"}, "804269": {"ParentId": "804217", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_804217_804269_0\">Why is it required that getClassName( std::vector&amp; ) appear before doIt but not getClassName( MyClass2T&amp; )</p>\n</blockquote>\n<p>A declaration in scope is required for any function. When you instantiate your template function with a <code>vector&lt;int&gt;</code> it expects a function with the signature <code>getClassName(vector&lt;int&gt;&amp;)</code> to be present (at least a prototype) for compilation to succeed.</p>\n<blockquote>\n<p id=\"so_804217_804269_1\">What can I do do make doIt independent of std::vector? (I want to be able to place doIt in its own header and not have to know about std::vector, or any of the specializations, which will be user-defined)</p>\n</blockquote>\n<p>Read the <a href=\"http://www.parashift.com/c++-faq-lite/templates.html\" rel=\"nofollow noreferrer\">FAQ on Templates</a>. Try putting the prototype of all of <code>doIt</code>'s dependent template functions before first instantiation of <code>doIt</code>. </p>\n", "OwnerUserId": "66692", "PostTypeId": "2", "Id": "804269", "Score": "4", "CreationDate": "2009-04-29T21:05:16.017", "LastActivityDate": "2009-04-29T21:05:16.017"}, "bq_ids": {"n4140": {"so_804217_804686_0": {"section_id": 222, "quality": 0.95, "length": 19}, "so_804217_804686_1": {"section_id": 224, "quality": 1.0, "length": 36}}, "n3337": {"so_804217_804686_0": {"section_id": 215, "quality": 0.95, "length": 19}, "so_804217_804686_1": {"section_id": 217, "quality": 1.0, "length": 36}}, "n4659": {"so_804217_804686_0": {"section_id": 230, "quality": 0.95, "length": 19}, "so_804217_804686_1": {"section_id": 232, "quality": 1.0, "length": 36}}}, "804217": {"CommentCount": "0", "ViewCount": "1080", "PostTypeId": "1", "LastEditorUserId": "1505939", "CreationDate": "2009-04-29T20:53:10.663", "LastActivityDate": "2014-11-10T02:38:33.340", "Title": "Function template declaration order affects visibility (sometimes)", "AcceptedAnswerId": "804269", "LastEditDate": "2014-11-10T02:38:33.340", "Id": "804217", "Score": "3", "Body": "<p>I'm trying to create a function:</p>\n<pre><code>template &lt;typename T&gt;\nvoid doIt( T*&amp; p )\n{\n   if ( !p ) { return; }\n   T&amp; ref = *p;\n   getClassName( ref );\n}\n</code></pre>\n<p>where the behavior varies according to the type of <code>p</code> passed in. In particular, the version of <code>getClassName</code> called should depend upon the type of <code>p</code>. In the following example, I can successfully call:</p>\n<pre><code>doIt&lt;myClass1&gt;( myClass1*&amp; )\ndoIt&lt;myClass1&lt;int&gt; &gt;( myClass1*&amp; )\ndoIt&lt;myClass2&gt;( myClass2*&amp; )\ndoIt&lt;myClass2&lt;int&gt; &gt;( myClass2*&amp; )\n</code></pre>\n<p>but it fails when I call:</p>\n<pre><code>doIt&lt; std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;( std::vector&lt;int, std::allocator&lt;int&gt;&gt;*&amp; )\n</code></pre>\n<p>with the error:</p>\n<pre><code>a.cxx: In function \u2018void doIt(T*&amp;) [with T = std::vector&lt;int, std::allocator&lt;int&gt; &gt;]\u2019:\nba.cxx:87:   instantiated from here\na.cxx:33: error: invalid initialization of reference of type \u2018MyClass1&amp;\u2019 from expression of type \u2018std::vector&lt;int, std::allocator&lt;int&gt; &gt;\u2019\na.cxx:16: error: in passing argument 1 of \u2018const char* getClassName(MyClass1&amp;)\u2019\n</code></pre>\n<p>(gcc 4.2.4). </p>\n<p>If I move the declaration of: </p>\n<pre><code>template&lt;typename T, typename A&gt;\nchar const* getClassName( std::vector&lt;T,A&gt;&amp; ) { printf(\"std::vector&lt;T,A&gt;\\n\"); return NULL; }\n</code></pre>\n<p>before doIt -- then it compiles. So,</p>\n<ul>\n<li>Why is it required that <code>getClassName( std::vector&lt;T,A&gt;&amp; )</code> appears before <code>doIt</code> but not <code>getClassName( MyClass2T&lt;T&gt;&amp; )</code></li>\n<li>What can I do to make <code>doIt</code> independent of <code>std::vector</code>? (I want to be able to place <code>doIt</code> in its own header and not have to know about <code>std::vector</code>, or any of the specializations, which will be user-defined).</li>\n</ul>\n<p>.</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;vector&gt;\n\n//template&lt;typename T&gt;\n//char const* getClassName( T&amp; );\n\n//template&lt;typename T, typename A&gt;\n////char const* getClassName( std::vector&lt;T,A&gt;&amp; ) { printf(\"std::vector&lt;T,A&gt;\\n\"); return NULL; }\n\n#if 1\n// ---------  MyClass2\nstruct MyClass1\n{};\n\nchar const* getClassName( MyClass1&amp; ) { printf(\"MyClass1\\n\"); return NULL; }\n\n// ---------  MyClass1T\ntemplate&lt; typename T&gt;\nstruct MyClass1T\n{};\n\ntemplate&lt;typename T&gt;\nchar const* getClassName( MyClass1T&lt;T&gt;&amp; ) { printf(\"MyClass1T&lt;T&gt;\\n\"); return NULL; }\n#endif\n\n\ntemplate &lt;typename T&gt;\nvoid doIt( T*&amp; p )\n{\n   if ( !p ) { return; }\n   T&amp; ref = *p;\n   getClassName( ref );\n}\n\n\n// ---------  MyClass2\nstruct MyClass2\n{};\n\n\n// declared after doIt, OK.\nchar const* getClassName( MyClass2&amp; ) { printf(\"MyClass2\\n\"); return NULL; }\n\n// ---------  MyClass2T\ntemplate&lt; typename T&gt;\nstruct MyClass2T\n{};\n\n// declared after doIt, OK.\ntemplate&lt;typename T&gt;\nchar const* getClassName( MyClass2T&lt;T&gt;&amp; ) { printf(\"MyClass2T&lt;T&gt;\\n\"); return NULL; }\n\ntemplate&lt;typename T, typename A&gt;\nchar const* getClassName( std::vector&lt;T,A&gt;&amp; ) { printf(\"std::vector&lt;T,A&gt;\\n\"); return NULL; }\n\n\n\nvoid test()\n{\n#if 1\n   MyClass1 mc1;\n   MyClass1* mc1p = &amp;mc1;\n   doIt( mc1p );\n\n   MyClass2 mc2;\n   MyClass2* mc2p = &amp;mc2;\n   doIt( mc2p );\n\n   MyClass1T&lt;int&gt; mc1t;\n   MyClass1T&lt;int&gt;* mc1tp = &amp;mc1t;\n   doIt( mc1tp );\n\n   MyClass2T&lt;int&gt; mc2t;\n   MyClass2T&lt;int&gt;* mc2tp = &amp;mc2t;\n   doIt( mc2tp );\n\n   // Nested templates are OK.\n   MyClass2T&lt;MyClass1&gt; mc2t2;\n   MyClass2T&lt;MyClass1&gt;* mc2tp2 = &amp;mc2t2;\n   doIt( mc2tp2 );\n#endif\n\n#if 1\n   std::vector&lt;int&gt; v;\n   std::vector&lt;int&gt;* vp = &amp;v;\n   doIt( vp );                   // FAIL!\n#endif\n}\n</code></pre>\n", "Tags": "<c++><templates><lookup><argument-dependent-lookup>", "OwnerUserId": "48956", "AnswerCount": "2"}});