post_cb({"bq_ids": {"n4140": {"so_16068151_16068170_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 763}}, "n3337": {"so_16068151_16068170_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 750}}, "n4659": {"so_16068151_16068170_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 823}}}, "16068173": {"Id": "16068173", "PostTypeId": "2", "Body": "<p>Yes, indeed <a href=\"http://en.cppreference.com/w/cpp/container/map\" rel=\"nofollow\"><code>std::map</code></a>  will be <code>O(log N)</code> and <a href=\"http://en.cppreference.com/w/cpp/container/unordered_map\" rel=\"nofollow\"><code>std::unordered_map</code></a> will have average constant-time complexity and <code>O(N)</code> in the worst case if there are too many hash collisions.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-04-17T19:14:37.467", "Score": "3", "CreationDate": "2013-04-17T19:08:32.787", "ParentId": "16068151", "CommentCount": "2", "OwnerUserId": "1708801", "LastEditDate": "2013-04-17T19:14:37.467"}, "16068151": {"ViewCount": "21367", "Body": "<p>Is key look up on <code>std::map</code> O(1)? I thought it was until I thought about it more. It is based on a tree implementation so the lookup time should be O(log N), correct?</p>\n<p>And, is it possible to have O(1) look up on string key, <code>std::unordered_map</code> perhaps?</p>\n", "Title": "C++ STL map: is access time O(1)?", "CreationDate": "2013-04-17T19:07:26.653", "LastActivityDate": "2013-05-03T22:14:09.660", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-05-03T22:14:09.660", "LastEditorUserId": "636019", "Id": "16068151", "Score": "20", "OwnerUserId": "1459782", "Tags": "<c++><data-structures><c++11><std>", "AnswerCount": "2"}, "16068170": {"Id": "16068170", "PostTypeId": "2", "Body": "<p>The complexity of lookup for <a href=\"http://en.cppreference.com/w/cpp/container/map/operator_at\" rel=\"noreferrer\"><code>std::map</code></a> is O(log N) (logarithmic in the size of the container).</p>\n<p>Per Paragraph 23.4.4.3/4 of the C++11 Standard on <code>std::map::operator []</code>:</p>\n<blockquote>\n<p id=\"so_16068151_16068170_0\"><em>Complexity</em>: logarithmic.</p>\n</blockquote>\n<p>The complexity of lookup for <a href=\"http://en.cppreference.com/w/cpp/container/unordered_map/operator_at\" rel=\"noreferrer\"><code>std::unordered_map</code></a> is O(1) (constant) in the average case, and O(N) (linear) in the worst case.</p>\n<p>Per Paragraph 23.5.4.3/4 of the C++11 Standard on <code>std::unordered_map::operator []</code></p>\n<blockquote>\n<p id=\"so_16068151_16068170_1\"><em>Complexity</em>: Average case O(1), worst case O(<code>size()</code>).</p>\n</blockquote>\n<p><strong>NOTE:</strong></p>\n<p>If your question is only concerned with <em>computational complexity</em>, then what written above should answer it. The computational complexity of an operation, in fact, is measured in terms of the size <strong>of the container</strong> (the number of elements it contains).</p>\n<p>However, if you are looking for a way to perform O(1) lookup on a container that uses string keys, and where the complexity of the lookup is constant <em>with respect to the length of the string</em> rather than to the size of the container, then the answer is that <code>std::unordered_map</code> won't meet your requirements.</p>\n<p>In order to lookup a key, it is first necessary to produce a hash of it; when the key is a string, this operation itself could be linear in the size of the string. Then, the implementation has to compare the key to all the string keys in the same bucket, and each of these comparisons is in turn linear in the size of those strings.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-04-17T19:37:25.250", "Score": "34", "CreationDate": "2013-04-17T19:08:25.833", "ParentId": "16068151", "CommentCount": "11", "OwnerUserId": "1932150", "LastEditDate": "2013-04-17T19:37:25.250"}});