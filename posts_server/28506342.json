post_cb({"bq_ids": {"n4140": {"so_28506342_28506460_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 7040}, "so_28506342_28506460_2": {"length": 10, "quality": 1.0, "section_id": 9}, "so_28506342_28506460_3": {"length": 5, "quality": 1.0, "section_id": 9}, "so_28506342_28506460_1": {"length": 6, "quality": 1.0, "section_id": 9}}, "n3337": {"so_28506342_28506460_3": {"length": 5, "quality": 1.0, "section_id": 6}, "so_28506342_28506460_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6787}}, "n4659": {"so_28506342_28506460_2": {"length": 10, "quality": 1.0, "section_id": 9}, "so_28506342_28506460_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 8537}, "so_28506342_28506460_3": {"length": 5, "quality": 1.0, "section_id": 9}, "so_28506342_28506460_1": {"length": 6, "quality": 1.0, "section_id": 9}}}, "28506342": {"ViewCount": "346", "Body": "\n<p>I have a hard time understanding how this code (an example from the C++14 draft standard <em>[conv.lval]</em>) invokes undefined behavior for <code>g(false)</code>. Why does <code>constexpr</code> make the program valid?</p>\n<p>Also, what does it mean by \"does not access <code>y.n</code>\"? In both calls to <code>g()</code> we are returning the <code>n</code> data member so why does the last line say it doesn't access it?</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>struct S { int n; };\nauto f() {\n    S x { 1 };\n    constexpr S y { 2 };\n    return [&amp;](bool b) { return (b ? y : x).n; };\n}\nauto g = f();\nint m = g(false); // undefined behavior due to access of x.n outside its\n                  // lifetime\nint n = g(true);  // OK, does not access y.n\n</code></pre>\n", "AcceptedAnswerId": "28506460", "Title": "Understanding the example on lvalue-to-rvalue conversion", "CreationDate": "2015-02-13T18:34:15.060", "Id": "28506342", "CommentCount": "5", "LastEditDate": "2015-02-19T03:51:57.730", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2015-02-19T03:51:57.730", "Score": "2", "OwnerUserId": "1594090", "Tags": "<c++><language-lawyer><c++14><constexpr><lvalue-to-rvalue>", "AnswerCount": "1"}, "28506460": {"Id": "28506460", "PostTypeId": "2", "Body": "<p>This is because <code>y.n</code> is not odr-used and therefore does not require an access to <code>y.n</code> the rules for odr-use are covered in <code>3.2</code> and says:</p>\n<blockquote>\n<p id=\"so_28506342_28506460_0\">A variable x whose name appears as a potentially-evaluated expression ex <strong>is odr-used unless</strong> applying the\n  lvalue-to-rvalue conversion (4.1) to x <strong>yields a constant expression</strong> (5.19) that does not invoke any non-trivial\n  functions and, if x is an object, ex is an element of the set of potential results of an expression e, where\n  <strong>either the lvalue-to-rvalue conversion (4.1) is applied to e</strong>, or e is a discarded-value expression</p>\n</blockquote>\n<p>Note, Ben Voigt made some helpful comments that clarified this one a bit. So the working assumption here is that <em>x</em> would be:</p>\n<pre><code>y\n</code></pre>\n<p>and <em>e</em> would be(<em>the different expression that e is defined for is covered in paragraph 2 of section 3.2</em>):</p>\n<pre><code>(b ? y : x).n\n</code></pre>\n<p><code>y</code> yields a constant expression and the lvalue-to-rvalue conversion is applied to the expression <em>e</em>.</p>\n<p>Since <code>f</code> yields a lambda which captures <code>f</code>'s local variables by reference <code>x</code> is no longer valid once the call to <code>f</code> is done since <code>x</code> is an automatic variable inside <code>f</code>. Since <code>y</code> is a <em>constant expression</em> it acts as if <code>y.n</code> was not accessed and therefore we don't have the same lifetime issue.</p>\n<p>Your example is included in <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\" rel=\"nofollow\">N3939</a> section <code>4.1</code> <em>[conv.lval]</em> and right before that example it says:</p>\n<blockquote>\n<p id=\"so_28506342_28506460_1\">When an lvalue-to-rvalue conversion is applied to an expression e, and either</p>\n</blockquote>\n<p>and includes the following bullet which the examle belongs to:</p>\n<blockquote>\n<p id=\"so_28506342_28506460_2\">the evaluation of e results in the evaluation of a member ex of the set of potential results of e, and\n  ex names a variable x that <strong>is not odr-used</strong> by ex (3.2),</p>\n</blockquote>\n<p>then:</p>\n<blockquote>\n<p id=\"so_28506342_28506460_3\">the <strong>value contained in the referenced object is not accessed</strong></p>\n</blockquote>\n<p>This was applied to the C++14 draft standard due to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3953.html#1773\" rel=\"nofollow\">defect report 1773</a> .</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-02-14T20:54:05.857", "Score": "5", "CreationDate": "2015-02-13T18:41:20.747", "ParentId": "28506342", "CommentCount": "2", "OwnerUserId": "1708801", "LastEditDate": "2015-02-14T20:54:05.857"}});