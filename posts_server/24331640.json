post_cb({"24331640": {"CreationDate": "2014-06-20T16:19:43.470", "ViewCount": "132", "Score": "1", "Id": "24331640", "Title": "c++11 construct an object for a caller", "CommentCount": "5", "Body": "<p>I have some <code>Foo</code> struct that requires knowledge of some other object's state to be initialized, so I make a factory method for it:</p>\n<pre><code>struct Foo {\n  Foo(int x) : x_(x) {}\n\n  int x_;\n};\n\nstruct FooFactory {\n  Foo MakeFoo() {\n    return Foo(++counter);\n  }\n\n  int counter = 0;\n};\n</code></pre>\n<p>So while callers <em>could</em> just do <code>Foo(++factory.counter)</code>, it's cleaner to be able to just say <code>factory.MakeFoo()</code>.</p>\n<p>But this code requires copying, and say we want to avoid that. We can use a move constructor instead.</p>\n<pre><code>struct Foo {\n  Foo(int x) : x_(x) {}\n  Foo(Foo&amp; foo) = delete;\n  Foo(Foo&amp;&amp; foo) : Foo(foo.x_) { foo.x_ = 0; }\n\n  int x_;\n};\n\nstruct FooFactory {\n  Foo MakeFoo() {\n    return Foo(++counter);\n  }\n\n  int counter = 0;\n};\n</code></pre>\n<p>Which works, but still seems like \"more\" than I want. Something like <code>Foo foo = factory.MakeFoo()</code> still creates a temporary inside of <code>MakeFoo()</code> and then constructs <code>foo</code> via its move constructor.</p>\n<p>Is there a way to write this so that <code>MakeFoo</code> constructs directly <em>into</em> what it's being assigned to?</p>\n", "Tags": "<c++><c++11><move-semantics>", "LastActivityDate": "2014-06-20T17:00:45.967", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "598940"}, "bq_ids": {"n4140": {"so_24331640_24331698_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 3913}}, "n3337": {"so_24331640_24331698_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 3773}}}, "24332253": {"CommentCount": "0", "Body": "<p>While I would not suggest it, a macro is a valid solution:</p>\n<pre><code>#define MAKE_FOO() Foo(++factory.counter)\n</code></pre>\n<p>or for initialization of class members or locals:</p>\n<pre><code>#define INIT_FOO(x) x(++factory.counter)\n</code></pre>\n", "CreationDate": "2014-06-20T17:00:45.967", "ParentId": "24331640", "Id": "24332253", "LastActivityDate": "2014-06-20T17:00:45.967", "PostTypeId": "2", "Score": "0", "OwnerUserId": "362589"}, "24331698": {"LastActivityDate": "2014-06-20T16:36:11.043", "CommentCount": "10", "Body": "<p>Yes, using <em>braced-init-list</em> return for direct initialization of the target object:</p>\n<pre><code>struct FooFactory {\n  Foo MakeFoo() {\n    return {++counter};\n  }\n  // ...\n};\n</code></pre>\n<p>Note that this will not work if the 1-argument constructor of <code>Foo</code> is <code>explicit</code>.</p>\n<blockquote>\n<p id=\"so_24331640_24331698_0\">6.6.3 <strong>[stmt.return]</strong>:</p>\n<p id=\"so_24331640_24331698_1\">[...] A return statement with a braced-init-list initializes the object or reference to be returned from the function by copy-list-initialization (8.5.4) from the specified initializer list. [...]</p>\n</blockquote>\n", "CreationDate": "2014-06-20T16:22:52.110", "LastEditDate": "2014-06-20T16:36:11.043", "ParentId": "24331640", "Id": "24331698", "LastEditorUserId": "567292", "PostTypeId": "2", "Score": "8", "OwnerUserId": "567292"}});