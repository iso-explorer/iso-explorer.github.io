post_cb({"bq_ids": {"n4140": {"so_29330391_29401603_0": {"length": 19, "quality": 0.95, "section_id": 289}}, "n3337": {"so_29330391_29401603_0": {"length": 19, "quality": 0.95, "section_id": 280}}, "n4659": {"so_29330391_29401603_0": {"length": 19, "quality": 0.95, "section_id": 296}}}, "29330391": {"ViewCount": "381", "Body": "<p>I have a class hierarchy with three classes (A, B and C). A and B are base-classes, parametrized with the derived Type. Class C is derived from both, A and B. </p>\n<p>The class B provides an assignment operator for objects of type A and class C inherits this assignment operator with the <code>using super::operator=</code> declaration.</p>\n<p>When I define a constructor in class B from objects of type A, I get the <strong>Error:</strong> <em>two overloads have similar conversions</em> (C2666) in Visual Studio 2013, but I don't get any error, or warning in gcc (4.8.2), clang (3.4) and intel icc (Studio 2015). (compiled with <code>-Wall -pedantic</code>)</p>\n<p>Here the reduced example:\n</p>\n<pre><code>template &lt;class Model&gt; struct A {};\n\ntemplate &lt;class Model&gt; struct B\n{\n    B() {}; // default constructor\n\n    // copy constructor for objects of type A\n    template &lt;class M&gt; \n    B(A&lt;M&gt; const&amp;) {} \n\n    // assignment operator for objects of type A\n    template &lt;class M&gt;\n    Model&amp; operator=(A&lt;M&gt; const&amp; rhs)\n    {\n        return static_cast&lt;Model&amp;&gt;(*this);\n    }\n};\n\nstruct C : public B&lt;C&gt;, public A&lt;C&gt;\n{\n    typedef B&lt;C&gt;  super;\n\n    // copy assignment operator\n    C&amp; operator=(C const&amp; rhs) { return *this; }\n\n    // adopt assignment operator for A&lt;C&gt; from super-class\n    using super::operator=;\n};\n\nint main()\n{\n    C c;\n    A&lt;C&gt; a;\n    c = a;\n}\n</code></pre>\n<p>If I would replace the templated class A by a non-templated class it also compiles in Visual Studio without errors - but this is not the way it could be solved.</p>\n<p><strong>My question is</strong>: is this construct well-formed in the sense that it is standard conform, or is the error-message correct? Does a specifier like <code>explicit</code> for the copy constructor in B helps to solve the problem?</p>\n<p>By the way: In Visual Studio, I get the <strong>Warning</strong>: <em>multiple assignment operators specified</em> (C4522), because of the copy assignment operator in class C. Can somebody exmplain to me, why this should be a problem?</p>\n", "AcceptedAnswerId": "29401603", "Title": "Assignment operator overloads have similar conversions (only in VS)", "CreationDate": "2015-03-29T14:33:58.763", "Id": "29330391", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-03-30T21:29:42.683", "LastEditorUserId": "2708773", "LastActivityDate": "2015-04-01T22:00:11.990", "Score": "3", "OwnerUserId": "2708773", "Tags": "<c++><inheritance><copy-constructor><assignment-operator><using-declaration>", "AnswerCount": "1"}, "29401603": {"Id": "29401603", "PostTypeId": "2", "Body": "<p>GCC and CLANG are correct and MSVC is wrong:  </p>\n<h1>What's the expected behaviour:</h1>\n<p>The statement <code>c=a;</code> uses the <code>operator=</code>  that you've defined in <code>B</code>,  because an <code>A&lt;C&gt;</code> is not necessarily a <code>C</code>.  So let's write down the the declaration of <code>operator=</code> of <code>B&lt;C&gt;</code> by manually doing the type substitution:  </p>\n<pre><code>template &lt;class M&gt; \nC&amp; operator=(A&lt;M&gt; const&amp; rhs)\n</code></pre>\n<p>As <code>a</code> is a <code>A&lt;C&gt;</code>, the obvious implicit instantiation candidate of this template would be:  </p>\n<pre><code> C&amp; operator=(A&lt;C&gt; const&amp; rhs)\n</code></pre>\n<p>This is in fact the only possible instantiation (you could verify that GCC uses it by displaying the typeinfo).    </p>\n<h1>What is MSVC trying to do ?</h1>\n<p>If you'd change simplify the class C to an even more minimalistic form, you'd still get the<a href=\"https://msdn.microsoft.com/en-us/library/dyafzty4.aspx\" rel=\"nofollow\">error</a>:  </p>\n<pre><code>struct C : public B&lt;C&gt;   // single inheritance\n{   using B&lt;C&gt;::operator=; };  // nothing else\n</code></pre>\n<p>In fact the problem is caused by the constructor <code>B(A&lt;M&gt; const&amp;)</code> : </p>\n<ul>\n<li>comment it out, and the code will compile</li>\n<li><strong>make it explicit</strong> and the code will also compmile </li>\n</ul>\n<p>MSVC identifies wrongly a second potental candidate for the member function's implicit specialisation.  As this constructor allows to convert implicitely from  <code>A&lt;M&gt;</code> to <code>B&lt;C&gt;</code>, the candidate is:  </p>\n<pre><code> C&amp; operator=(B&lt;C&gt; const&amp; rhs)\n</code></pre>\n<p>But according to the C++ standard, this shouldn't be envisaged by the compiler at all: </p>\n<blockquote>\n<p id=\"so_29330391_29401603_0\"><strong>14.8.1/6:</strong> Implicit conversions  will be performed on a function argument to convert it to the type of the corresponding function\n  parameter <strong>if the parameter type contains no template-parameters</strong>\n  that participate in template argument deduction.</p>\n</blockquote>\n<p>So this is clearly a bug of MSVC.    </p>\n<p><strong>By the way:</strong></p>\n<p>The warning about multiple assignemnt operators is <a href=\"https://msdn.microsoft.com/en-us/library/fd45k287.aspx\" rel=\"nofollow\">just an information</a>. Apparently MS assumes that this might be a frequent cause for mistakes.  And now to the core question...  </p>\n", "LastActivityDate": "2015-04-01T22:00:11.990", "CommentCount": "0", "CreationDate": "2015-04-01T22:00:11.990", "ParentId": "29330391", "Score": "1", "OwnerUserId": "3723423"}});