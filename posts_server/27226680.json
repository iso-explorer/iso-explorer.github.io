post_cb({"27226680": {"CommentCount": "0", "ViewCount": "178", "OwnerDisplayName": "user3920237", "CreationDate": "2014-12-01T10:47:12.177", "LastActivityDate": "2014-12-01T14:10:29.240", "PostTypeId": "1", "AcceptedAnswerId": "27226816", "Title": "The address of a function matching a bool vs const void* overload", "Id": "27226680", "Score": "4", "Body": "<p>I'm reading <a href=\"https://stackoverflow.com/questions/27225614/unexpected-value-using-random-number-generator-as-a-function-in-c\">Unexpected value using random number generator as a function in C++</a> and the comments and current answer say that the user is outputting the address of the function. That sounded reasonable. I assumed that a <em>function-to-pointer</em> conversion was occurring and therefore matching the <code>const void*</code> overload, however upon testing it myself, I get different results in GCC/Clang vs MSVC. The following test program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid test()\n{\n}\n\nvoid func(bool)\n{\n    std::cout &lt;&lt; \"bool\";\n}\n\nvoid func(const void*)\n{\n    std::cout &lt;&lt; \"const void*\";\n}\n\nint main()\n{\n    func(test);\n}\n</code></pre>\n<p>outputs <code>bool</code> in GCC/Clang (<kbd><a href=\"http://coliru.stacked-crooked.com/a/d18a21ccde410f83\" rel=\"nofollow\"><code>coliru</code></a></kbd>)</p>\n<p>and <code>const void*</code> in MSVC (<kbd><a href=\"http://rextester.com/live/QNFXT35340\" rel=\"nofollow\"><code>rextester</code></a></kbd> warning live collaboration link)</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">N3337</a> says:</p>\n<p>[conv.func]</p>\n<blockquote>\n<p id=\"so_27226680_27226680_0\">An lvalue of function type <code>T</code> can be converted to a prvalue of type\n  \"pointer to <code>T</code>.\" The result is a pointer to the function.</p>\n</blockquote>\n<p>[conv.bool]</p>\n<blockquote>\n<p id=\"so_27226680_27226680_1\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to\n  member type can be converted to a prvalue of type <code>bool</code>. A zero\n  value, null pointer value, or null member pointer value is converted\n  to <code>false</code>; any other value is converted to <code>true</code>. A prvalue of type\n  <code>std::nullptr_t</code> can be converted to a prvalue of type bool; the\n  resulting value is <code>false</code>.</p>\n</blockquote>\n<p>So a pointer which is not a null pointer value converted to bool should equal <code>true</code>, explaining the warning given by GCC/Clang.</p>\n<p>Then Table 12 Conversions under [over.ics.scs] gives a function-to-pointer conversion an \"Exact Match\" rank and boolean conversions \"Conversion\" rank. [over.ics.rank]/4 then says:</p>\n<blockquote>\n<p id=\"so_27226680_27226680_2\">Standard conversion sequences are ordered by their ranks: an Exact\n  Match is a better conversion than a Promotion, which is a better\n  conversion than a Conversion. Two conversion sequences with the same\n  rank are indistinguishable unless one of the following rules applies:</p>\n<blockquote>\n<p id=\"so_27226680_27226680_5\">\u2014 A conversion that does not convert a pointer, a pointer to member,\n    or <code>std::nullptr_t</code> to <code>bool</code> is better than one that does.</p>\n<p id=\"so_27226680_27226680_6\">\u2014 [...]</p>\n</blockquote>\n</blockquote>\n<p>I am not a language lawyer so I hope that I quoted the right sections. </p>\n<p>However MSVC will call the <code>const void*</code> overload even if the <code>bool</code> overload is absent, and vice versa: GCC/Clang will call the <code>bool</code> overload even if the <code>const void*</code> overload is absent. So I'm not clear on the conversions here. Can somebody clear this up for me?</p>\n", "Tags": "<c++><pointers><visual-c++><c++11><language-lawyer>", "AnswerCount": "1"}, "27226816": {"ParentId": "27226680", "PostTypeId": "2", "CommentCount": "15", "Body": "<p>Seems like a bug (or extension) in MSVC. The standard does not define any standard conversions from a \"pointer to function\" to a \"pointer to <code>void</code>.\"</p>\n<p>It's hard to provide a quote for the <em>absence</em> of something, but the closest I can do is C++11 4.10/2 [conv.ptr]:</p>\n<blockquote>\n<p id=\"so_27226680_27226816_0\">A prvalue of type \u201cpointer to <em>cv</em> <code>T</code>,\u201d <strong>where <code>T</code> is an object type</strong>, can be converted to a prvalue of type \u201cpointer\n  to <em>cv</em> <code>void</code>\u201d. The result of converting a \u201cpointer to <em>cv</em> <code>T</code>\u201d to a \u201cpointer to <em>cv</em> <code>void</code>\u201d points to the start of\n  the storage location where the object of type <code>T</code> resides, as if the object is a most derived object (1.8) of type\n  T (that is, not a base class subobject). The null pointer value is converted to the null pointer value of the\n  destination type.</p>\n</blockquote>\n<p>Together with 3.9/8 [basic.types]:</p>\n<blockquote>\n<p id=\"so_27226680_27226816_1\">An <em>object type</em> is a (possibly cv-qualified) type that is <strong>not a function type</strong>, not a reference type, and not a\n  <code>void</code> type.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>Using <a href=\"http://msdn.microsoft.com/en-us/library/0k0w269d.aspx\" rel=\"nofollow\"><code>/Za</code></a> to disable extensions will disable the non-standard conversion. </p>\n", "OwnerUserId": "1782465", "LastEditorUserId": "1782465", "LastEditDate": "2014-12-01T14:10:29.240", "Id": "27226816", "Score": "3", "CreationDate": "2014-12-01T10:55:11.773", "LastActivityDate": "2014-12-01T14:10:29.240"}, "bq_ids": {"n4140": {"so_27226680_27226680_1": {"section_id": 44, "quality": 1.0, "length": 39}, "so_27226680_27226680_3": {"section_id": 640, "quality": 1.0, "length": 12}, "so_27226680_27226680_2": {"section_id": 640, "quality": 0.9615384615384616, "length": 25}, "so_27226680_27226680_5": {"section_id": 640, "quality": 1.0, "length": 12}, "so_27226680_27226680_0": {"section_id": 12, "quality": 0.9166666666666666, "length": 11}, "so_27226680_27226816_0": {"section_id": 40, "quality": 0.5909090909090909, "length": 26}, "so_27226680_27226816_1": {"section_id": 7206, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_27226680_27226680_1": {"section_id": 41, "quality": 1.0, "length": 39}, "so_27226680_27226680_3": {"section_id": 630, "quality": 1.0, "length": 12}, "so_27226680_27226680_2": {"section_id": 630, "quality": 0.9615384615384616, "length": 25}, "so_27226680_27226680_5": {"section_id": 630, "quality": 1.0, "length": 12}, "so_27226680_27226680_0": {"section_id": 9, "quality": 0.9166666666666666, "length": 11}, "so_27226680_27226816_0": {"section_id": 37, "quality": 0.9545454545454546, "length": 42}, "so_27226680_27226816_1": {"section_id": 6950, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_27226680_27226680_1": {"section_id": 45, "quality": 1.0, "length": 39}, "so_27226680_27226680_3": {"section_id": 668, "quality": 1.0, "length": 12}, "so_27226680_27226680_2": {"section_id": 668, "quality": 0.9615384615384616, "length": 25}, "so_27226680_27226680_5": {"section_id": 668, "quality": 1.0, "length": 12}, "so_27226680_27226680_0": {"section_id": 13, "quality": 0.9166666666666666, "length": 11}, "so_27226680_27226816_0": {"section_id": 41, "quality": 0.5227272727272727, "length": 23}, "so_27226680_27226816_1": {"section_id": 4058, "quality": 0.8181818181818182, "length": 9}}}});