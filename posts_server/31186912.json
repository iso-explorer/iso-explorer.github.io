post_cb({"31187310": {"ParentId": "31186912", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From [over.call.func]:</p>\n<blockquote>\n<p id=\"so_31186912_31187310_0\">The name is looked up in the context of the function call following the normal rules for name lookup in function calls (3.4). The function declarations <strong>found by that lookup</strong> constitute the set of\n  candidate functions.</p>\n</blockquote>\n<p>This is just unqualified lookup. So the candidate functions are anything named <code>foo</code>. Which is to say, all of these:</p>\n<pre><code>void foo(A&amp;&amp; );\nvoid foo(A&amp; );\nvoid foo(B&amp; , B&amp; );\nvoid foo(B&amp; );\nvoid foo(const A&amp; );\n</code></pre>\n<p>It doesn't matter yet whether or not the number of arguments match or any of the conversions are possible - the first step is just name lookup. That's why the term is <em>candidate</em> functions. These are all candidates, we haven't excluded anything yet. </p>\n<p><em>Separate</em> from that, we determine the argument list. This is the second fragment you quoted, which in its entirety reads:</p>\n<blockquote>\n<p id=\"so_31186912_31187310_1\">Because of the rules for name lookup, the set of candidate functions consists (1) entirely\n  of non-member functions or (2) entirely of member functions of some class T. In case (1), the argument list\n  is the same as the <em>expression-list</em> in the call.</p>\n</blockquote>\n<p>We are in case 1 here. So in this case, we have 5 candidate functions and an argument list of <code>a</code>.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-07-02T14:38:10.613", "Id": "31187310", "Score": "1", "CreationDate": "2015-07-02T14:28:10.063", "LastActivityDate": "2015-07-02T14:38:10.613"}, "31186912": {"CommentCount": "4", "ViewCount": "95", "PostTypeId": "1", "LastEditorUserId": "4672588", "CreationDate": "2015-07-02T14:11:23.213", "LastActivityDate": "2015-07-02T14:50:59.743", "Title": "Set of candidate functions", "LastEditDate": "2015-07-02T14:21:28.410", "Id": "31186912", "Score": "1", "Body": "<p>Imagine that I have the following functions:</p>\n<pre><code>#include &lt;iostream&gt;\nclass A{ };\nclass B{ };\n\nvoid foo(A&amp;&amp; a){ std::cout &lt;&lt; \"A&amp;&amp;\" &lt;&lt; std::endl; };\nvoid foo(A&amp; a){ std::cout &lt;&lt; \"A&amp;\" &lt;&lt; std::endl; };\nvoid foo(B&amp; b, B&amp; bb){ std::cout &lt;&lt; \"B&amp;, B&amp;\" &lt;&lt; std::endl; };\nvoid foo(B&amp; b){ std::cout &lt;&lt; \"B&amp;\" &lt;&lt; std::endl; };\nvoid foo(const A&amp; a){ std::cout &lt;&lt; \"const A&amp;\" &lt;&lt; std::endl; };\n\nA a;\n\nint main()\n{\n    foo(a);\n}\n</code></pre>\n<p>When we invoke the function <code>foo(a)</code>, what will be the set of candidate functions? Standard is saying the following:</p>\n<p>13.3.1.1.1 Call to named function [over.call.func]</p>\n<blockquote>\n<p id=\"so_31186912_31186912_0\">In unqualified function calls, the name is not qualified by an -&gt; or .\n  operator and has the more general form of a primary-expression. The\n  name is looked up in the context of the function call following the\n  normal rules for name lookup in function calls (3.4).</p>\n<p id=\"so_31186912_31186912_1\">[...]</p>\n<p id=\"so_31186912_31186912_2\"><strong>the argument list is the same as the expression-list in the call</strong></p>\n</blockquote>\n<p>So, the candidate function will be all <code>foo</code>s except <code>foo(B&amp;, B&amp;)</code> (differs in the number of parameters). Is that right?</p>\n", "Tags": "<c++><overloading><language-lawyer>", "OwnerUserId": "2786156", "AnswerCount": "2"}, "31187855": {"ParentId": "31186912", "CommentCount": "0", "Body": "<p>All of the listed functions will be candidate functions. The paragraph quoted in the question explains why in the skipped portion:</p>\n<blockquote>\n<p id=\"so_31186912_31187855_0\">The name is looked up in the context of the function call following\n  the normal rules for name lookup in function calls. The function\n  declarations found by that lookup constitute the set of candidate\n  functions.</p>\n</blockquote>\n<p>Without venturing into the wonderful world of name lookup, you can infer from its name that if one of your <code>foo</code> functions is found, all will be.</p>\n<p>The more interesting part starts after this process, when the compiler determines the set of viable functions. I'll walk through how a function is selected in order to give a better understanding of the process. I encourage you to read along to see what I left out. I used N4140.</p>\n<p>We'll start with the first point in \u00a713.3.2/2:</p>\n<blockquote>\n<p id=\"so_31186912_31187855_1\">If there are m arguments in the list, all candidate functions having exactly m parameters are viable.</p>\n</blockquote>\n<p>This rules out <code>void foo(B&amp; b, B&amp; bb)</code>. There are no functions with ellipses or more than 1 parameter with default arguments, so we'll skip those and move on to \u00a713.3.2/3:</p>\n<blockquote>\n<p id=\"so_31186912_31187855_2\">Second, for F to be a viable function, there shall exist for each\n  argument an implicit conversion sequence that converts that argument\n  to the corresponding parameter of F. If the parameter has reference\n  type, the implicit conversion sequence includes the operation of\n  binding the reference, and the fact that an lvalue reference to\n  non-const cannot be bound to an rvalue and that an rvalue reference\n  cannot be bound to an lvalue can affect the viability of the function.</p>\n</blockquote>\n<p>There is no implicit conversion sequence from <code>a</code> to <code>B&amp;</code> and <code>A&amp;&amp;</code> cannot be bound to <code>a</code>. This rules out <code>void foo(B&amp; b)</code> and <code>void foo(A&amp;&amp; a)</code>.</p>\n<p>Now we're down to:</p>\n<pre><code>void foo(A&amp; a)\nvoid foo(const A&amp; a)\n</code></pre>\n<p>Time to move on to overload resolution, \u00a713.3. We have two implicit conversion sequences: one to convert <code>a</code> to <code>A&amp;</code> and one to convert <code>a</code> to <code>const A&amp;</code>. If one of these is better than the other (spoiler: it is), then that function will be chosen.</p>\n<p>Both of these fall under \u00a713.3.3.1.4, Reference Binding. </p>\n<blockquote>\n<p id=\"so_31186912_31187855_3\">When a parameter of reference type binds directly (8.5.3) to an\n  argument expression, the implicit conversion sequence is the identity\n  conversion, unless the argument expression has a type that is a\n  derived class of the parameter type, in which case the implicit\n  conversion sequence is a derived-to-base Conversion.</p>\n</blockquote>\n<p>Heading over to \u00a78.5.3/4 and /5:</p>\n<blockquote>\n<p id=\"so_31186912_31187855_4\">Given types \u201ccv1 T1\u201d and \u201ccv2 T2,\u201d \u201ccv1 T1\u201d is reference-related to\n  \u201ccv2 T2\u201d if T1 is the same type as T2, or T1 is a base class of T2.\n  \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2\u201d if T1 is\n  reference-related to T2 and cv1 is the same cv-qualification as, or\n  greater cv-qualification than, cv2.<br>\n  \u2026<br>\n  A reference to type \u201ccv1 T1\u201d is initialized by an expression of type\n  \u201ccv2 T2\u201d as follows: (5.1) \u2014 If the reference is an lvalue reference\n  and the initializer expression (5.1.1) \u2014 is an lvalue (but is not a\n  bit-field), and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2,\u201d<br>\n  \u2026<br>\n  In all cases except the last (i.e., creating and initializing a\n  temporary from the initializer expression), the reference is said to\n  bind directly to the initializer expression.</br></br></br></br></p>\n</blockquote>\n<p>From this, we conclude that both implicit conversion sequences are the identity conversion. Finally, we rank these in \u00a713.3.3.2/3:</p>\n<blockquote>\n<p id=\"so_31186912_31187855_5\">Two implicit conversion sequences of the same form are\n  indistinguishable conversion sequences unless one of the following\n  rules applies:</p>\n<ul>\n<li>Standard conversion sequence S1 is a better\n  conversion sequence than standard conversion sequence S2 if\n  \n  <ul>\n<li>S1 and S2 are reference bindings, and the types to which the\n  references refer are the same type except for top-level cv-qualifiers,\n  and the type to which the reference initialized by S2 refers is more\n  cv-qualified than the type to which the reference initialized by S1\n  refers.</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>If we take <code>a</code> to <code>A&amp;</code> to be S1 and <code>a</code> to <code>const A&amp;</code> to be S2, we see that S2 is more cv-qualified, so this criterion is fulfilled and S1 is the better conversion sequence.</p>\n<p>In conclusion, <code>void foo(A&amp; a)</code> wins overload resolution and will be called.</p>\n", "OwnerUserId": "962089", "PostTypeId": "2", "Id": "31187855", "Score": "1", "CreationDate": "2015-07-02T14:50:59.743", "LastActivityDate": "2015-07-02T14:50:59.743"}, "bq_ids": {"n4140": {"so_31186912_31187855_2": {"section_id": 602, "quality": 0.975, "length": 39}, "so_31186912_31187855_5": {"section_id": 639, "quality": 1.0, "length": 13}, "so_31186912_31187855_1": {"section_id": 601, "quality": 1.0, "length": 10}, "so_31186912_31187855_0": {"section_id": 577, "quality": 0.9090909090909091, "length": 20}, "so_31186912_31187310_1": {"section_id": 577, "quality": 1.0, "length": 22}, "so_31186912_31186912_0": {"section_id": 577, "quality": 0.9565217391304348, "length": 22}, "so_31186912_31187310_0": {"section_id": 577, "quality": 0.9090909090909091, "length": 20}, "so_31186912_31186912_2": {"section_id": 577, "quality": 1.0, "length": 5}, "so_31186912_31187855_3": {"section_id": 625, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_31186912_31186912_2": {"section_id": 567, "quality": 1.0, "length": 5}, "so_31186912_31187855_5": {"section_id": 629, "quality": 1.0, "length": 13}, "so_31186912_31187310_1": {"section_id": 567, "quality": 1.0, "length": 22}, "so_31186912_31187855_1": {"section_id": 591, "quality": 1.0, "length": 10}, "so_31186912_31187855_0": {"section_id": 567, "quality": 0.9090909090909091, "length": 20}, "so_31186912_31187855_4": {"section_id": 3191, "quality": 0.5087719298245614, "length": 29}, "so_31186912_31186912_0": {"section_id": 567, "quality": 0.9565217391304348, "length": 22}, "so_31186912_31187310_0": {"section_id": 567, "quality": 0.9090909090909091, "length": 20}, "so_31186912_31187855_2": {"section_id": 592, "quality": 0.975, "length": 39}, "so_31186912_31187855_3": {"section_id": 615, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_31186912_31187855_2": {"section_id": 628, "quality": 0.975, "length": 39}, "so_31186912_31187855_5": {"section_id": 667, "quality": 1.0, "length": 13}, "so_31186912_31187855_1": {"section_id": 627, "quality": 1.0, "length": 10}, "so_31186912_31187855_0": {"section_id": 600, "quality": 0.9090909090909091, "length": 20}, "so_31186912_31187310_1": {"section_id": 600, "quality": 1.0, "length": 22}, "so_31186912_31186912_0": {"section_id": 600, "quality": 0.9565217391304348, "length": 22}, "so_31186912_31187310_0": {"section_id": 600, "quality": 0.9090909090909091, "length": 20}, "so_31186912_31186912_2": {"section_id": 600, "quality": 1.0, "length": 5}, "so_31186912_31187855_3": {"section_id": 651, "quality": 0.9629629629629629, "length": 26}}}});