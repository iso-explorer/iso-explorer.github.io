post_cb({"19044967": {"PostTypeId": "2", "Body": "<p><code>delete</code> and <code>delete[]</code> will be equal only if the <code>p</code> points to basic data types, such as char or int.</p>\n<p>If <code>p</code> points to an object array, the result will be different. Try the code below:</p>\n<pre><code>class T {\npublic:\n    T() { cout &lt;&lt; \"constructor\" &lt;&lt; endl; }\n    ~T() { cout &lt;&lt; \"destructor\" &lt;&lt; endl; }\n};\n\nint main()\n{\n    const int NUM = 3;\n    T* p1 = new T[NUM];\n\n    cout &lt;&lt; p1 &lt;&lt; endl;\n    //  delete[] p1;\n    delete p1;\n\n    T* p2 = new T[NUM];\n    cout &lt;&lt; p2 &lt;&lt; endl;\n    delete[] p2;\n}\n</code></pre>\n<p>By using <code>delete[]</code> all the destructors of T in the array will be invoked. By using <code>delete</code> only <code>p[0]</code>'s destructor will be invoked.</p>\n", "LastActivityDate": "2013-09-30T20:27:00.047", "LastEditorUserId": "63550", "Id": "19044967", "CommentCount": "2", "CreationDate": "2013-09-27T07:20:43.317", "ParentId": "19044809", "Score": "12", "OwnerUserId": "2209947", "LastEditDate": "2013-09-30T20:27:00.047"}, "19044866": {"PostTypeId": "2", "Body": "<p>Because it's undefined behavior. In your case, <code>delete</code> may do the work of <code>delete []</code> in your compiler, but it may not work on another machine.</p>\n", "LastActivityDate": "2013-09-30T20:23:59.393", "LastEditorUserId": "63550", "Id": "19044866", "CommentCount": "0", "CreationDate": "2013-09-27T07:14:45.333", "ParentId": "19044809", "Score": "7", "OwnerUserId": "1009479", "LastEditDate": "2013-09-30T20:23:59.393"}, "19047503": {"PostTypeId": "2", "Body": "<p>This is <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow noreferrer\">undefined behavior</a>, so we can not reason about its behavior. If we look at the draft C++ standard section <code>3.7.4.2</code> <em>Deallocation functions</em>, paragraph <em>3</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19044809_19047503_0\">[...] Otherwise, the <strong>behavior is undefined if the value supplied to operator delete(void*) in the standard library is not one of the values returned by a previous invocation of either operator new(std::size_t) or operator new(std::size_t, conststd::nothrow_t&amp;) in the standard library</strong>, and the behavior is undefined if the value supplied to operator delete[] (void*) in the standard library is not one of the values returned by a previous invocation of either operator new[] (std::size_t) or operator new[] (std::size_t, const std::nothrow_t&amp;) in the\n  standard library.</p>\n</blockquote>\n<p>The actual details are going to be <a href=\"https://stackoverflow.com/questions/2397984\">implementation-defined behavior</a> and could vary greatly.</p>\n", "LastActivityDate": "2013-09-30T20:30:19.827", "LastEditorUserId": "-1", "Id": "19047503", "CommentCount": "0", "CreationDate": "2013-09-27T09:37:33.047", "ParentId": "19044809", "Score": "1", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T11:52:46.487"}, "19045264": {"PostTypeId": "2", "Body": "<p>When I try this, valgrind reports:</p>\n<pre><code>==22707== Mismatched free() / delete / delete []\n==22707==    at 0x4C2B59C: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==22707==    by 0x40066D: main (in /home/andrew/stackoverflow/memtest)\n==22707==  Address 0x5a1a040 is 0 bytes inside a block of size 256 alloc'd\n==22707==    at 0x4C2C037: operator new[](unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==22707==    by 0x40065D: main (in /home/andrew/stackoverflow/memtest)\n</code></pre>\n<p>It's not really a memory leak, but valgrind does notice the problem.</p>\n", "LastActivityDate": "2013-09-27T07:36:55.123", "Id": "19045264", "CommentCount": "0", "CreationDate": "2013-09-27T07:36:55.123", "ParentId": "19044809", "Score": "11", "OwnerUserId": "459640"}, "19044882": {"PostTypeId": "2", "Body": "<p>Although it's undefined behaviour as @KillianDS says, the difference probably relates to the fact that both <code>delete</code> and <code>delete[]</code> free the underlying memory. The point of <code>delete[]</code> is that the destructors for each object in the array are called before the memory is freed. Since <code>char</code> is a <a href=\"http://en.wikipedia.org/wiki/Plain_old_data_structure\" rel=\"nofollow\">POD</a> and doesn't have a destructor, there isn't any effective difference between the two in this case.</p>\n<p>You definitely shouldn't rely on it, however.</p>\n", "LastActivityDate": "2013-09-30T20:25:03.473", "LastEditorUserId": "63550", "Id": "19044882", "CommentCount": "5", "CreationDate": "2013-09-27T07:15:51.383", "ParentId": "19044809", "Score": "38", "OwnerUserId": "506413", "LastEditDate": "2013-09-30T20:25:03.473"}, "bq_ids": {"n4140": {"so_19044809_19047503_0": {"length": 36, "quality": 0.8372093023255814, "section_id": 7182}}, "n3337": {"so_19044809_19047503_0": {"length": 36, "quality": 0.8372093023255814, "section_id": 6926}}}, "19044809": {"ViewCount": "1755", "Body": "<p>I checked the following code in C++ with <code>valgrind</code> with <code>--leak-check=full</code> and it says no memory leak. Why is that?</p>\n<pre><code>char *p = new char[256];\ndelete p;\n</code></pre>\n<p><code>new[]</code> should be matched by <code>delete[]</code> as far as I know.</p>\n", "Title": "Why does this code not result in a memory leak?", "CreationDate": "2013-09-27T07:11:52.647", "LastActivityDate": "2013-09-30T20:30:19.827", "CommentCount": "10", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-09-27T12:19:12.140", "LastEditorUserId": "953482", "Id": "19044809", "ClosedDate": "2013-09-27T17:53:17.660", "Score": "29", "OwnerUserId": "840968", "Tags": "<c++><memory-leaks><valgrind>", "AnswerCount": "6"}, "19045693": {"PostTypeId": "2", "Body": "<p>The difference between <code>delete</code> and <code>delete []</code> is that the compiler adds code to call the destructor for the deleting objects. Say something like this:</p>\n<pre><code>    class A\n    {\n        int a;\n        public:\n            ...\n            ~A() { cout&lt;&lt;\"D'tor\"; }\n    };\n\n    a=new A[23];\n    delete [] a; \n</code></pre>\n<p>This <code>delete [] a;</code> is transformed to something like,</p>\n<pre><code>   for (int i=0; i&lt;23; i++)\n   {\n       a[i].A::~A();\n   }\n   std::delete a;\n</code></pre>\n<p>So, for your case since it is an built in datatype there is no destructor to call. So, it transformed as,</p>\n<pre><code>   std::delete a;\n</code></pre>\n<p>which intern calls the <code>free()</code> to deallocate the memory. That's the reason that you are not getting any leak. Since memory allocated is completely deallocated using <code>free()</code> in g++.</p>\n<p>But best practice is that you have to use <code>delete []</code> version if you use <code>new []</code>.</p>\n", "LastActivityDate": "2013-09-27T15:29:08.720", "LastEditorUserId": "168057", "Id": "19045693", "CommentCount": "0", "CreationDate": "2013-09-27T07:59:58.220", "ParentId": "19044809", "Score": "0", "OwnerUserId": "987251", "LastEditDate": "2013-09-27T15:29:08.720"}});