post_cb({"29058856": {"ParentId": "29058769", "CommentCount": "1", "Body": "<p>From the C++11 standard, ISO/EIC 14882 \u00a76.8 [stmt.ambig] \u00b61 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_29058769_29058856_0\">There is an ambiguity in the grammar involving <em>expression-statements</em> and declarations: An <em>expression-statement</em> with a function-style explicit type conversion (5.2.3) as its leftmost subexpression can be indistinguishable\n  from a declaration where the first declarator starts with a <code>(</code>. <strong>In those cases the statement is a declaration.</strong></p>\n</blockquote>\n<p>To apply this to your question, <code>A(x);</code> can parse as either \"call the function <code>A</code> / construct a temporary object of type <code>A</code>, and pass <code>x</code> as the only function/constructor argument\" or \"declare a variable <code>x</code> of type <code>A</code>.\"  The standard says that in this case, it should be parsed as a variable declaration.</p>\n<p>Your other examples are not ambiguous because they cannot be parsed as a variable declaration, and so they are parsed as a call to <code>A</code>'s constructor.</p>\n", "OwnerUserId": "501250", "PostTypeId": "2", "Id": "29058856", "Score": "4", "CreationDate": "2015-03-15T08:50:14.557", "LastActivityDate": "2015-03-15T08:50:14.557"}, "bq_ids": {"n4140": {"so_29058769_29058856_0": {"section_id": 3921, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_29058769_29058856_0": {"section_id": 3781, "quality": 0.7692307692307693, "length": 20}}, "n4659": {"so_29058769_29058856_0": {"section_id": 4807, "quality": 0.9615384615384616, "length": 25}}}, "29058769": {"CommentCount": "0", "ViewCount": "225", "CreationDate": "2015-03-15T08:38:49.997", "LastActivityDate": "2015-03-15T08:50:14.557", "Title": "C++ temporary class instantiation ambiguously", "AcceptedAnswerId": "29058856", "PostTypeId": "1", "Id": "29058769", "Score": "4", "Body": "<p>Let we have procedure formed as class. Only constructor call makes some side effect. No need to handle class instance in memory after call. Following code instantiate that class:</p>\n<pre><code>struct A{\n    A(int){}\n    };\nint main() {\n\n    A(0);//right. Pass const to ctor\n    int x=0;\n    A(x);//bad. Compiler interpret like A x;\n    (A(x));//right. New temporary object passed to brackets\n    A((int)x);//right. Pass temporary int to ctor\n\n    return 0;\n}\n</code></pre>\n<p>(see also on <a href=\"http://ideone.com/0SAEZ7\" rel=\"nofollow\">Online IDE</a>)</p>\n<p>Why A(x); interpret as variable x declaration instead of temporary A object instantiaton?</p>\n", "Tags": "<c++><temporary-objects>", "OwnerUserId": "3597240", "AnswerCount": "2"}, "29058804": {"ParentId": "29058769", "CommentCount": "0", "Body": "<p>That's because what you consider should be the parameter list to the ctor, <code>(x)</code> is being interpreted as \"<code>x</code> in parentheses\". Thus, <code>A(x)</code> is read as <code>A (x)</code> is read as <code>A x</code>.</p>\n<p>In the other cases, the compiler has a hint suggesting that it should generate an <code>A</code> instance, calling the ctor with the arguments supplied.</p>\n", "OwnerUserId": "4433386", "PostTypeId": "2", "Id": "29058804", "Score": "1", "CreationDate": "2015-03-15T08:44:13.297", "LastActivityDate": "2015-03-15T08:44:13.297"}});