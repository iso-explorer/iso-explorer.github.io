post_cb({"2752446": {"Id": "2752446", "PostTypeId": "2", "Body": "<p>Googling around a bit, I found more instances of people asking whether <code>operator-&gt;*</code> is ever used than actual suggestions.</p>\n<p>A couple places suggest <code>T &amp;A::operator-&gt;*( T B::* )</code>. Not sure whether this reflects designer's intent or a misimpression that <code>T &amp;A::operator-&gt;*( T A::* )</code> is a builtin. Not really related to my question, but gives an idea of the depth I found in online discussion &amp; literature.</p>\n<p>There was a mention of \"D&amp;E 11.5.4\" which I suppose is Design and Evolution of C++. Perhaps that contains a hint. Otherwise, I'm just gonna conclude it's a bit of useless ugliness that was overlooked by standardization, and most everyone else too.</p>\n<p><strong>Edit</strong> See below for a paste of the D&amp;E quote.</p>\n<p>To put this quantitatively, <code>-&gt;*</code> is the tightest binding operator that can be overloaded by a free function. All the postfix-expression and unary operators overloads require nonstatic member function signatures. Next precedence after unary operators are C-style casts, which could be said to correspond to conversion functions (<code>operator type()</code>), which also cannot be free functions. Then comes <code>-&gt;*</code>, then multiplication. <code>-&gt;*</code> could have been like <code>[]</code> or like <code>%</code>, they could have gone either way, and they chose the path of <strong><em>EEEEEEVIL</em></strong>.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2010-10-06T06:33:23.220", "Score": "2", "CreationDate": "2010-05-02T04:27:31.803", "ParentId": "2696864", "CommentCount": "5", "OwnerUserId": "153285", "LastEditDate": "2010-10-06T06:33:23.220"}, "2696864": {"ViewCount": "6059", "Body": "<p>I was perusing section 13.5 after <a href=\"https://stackoverflow.com/questions/2695169/are-raw-c-pointers-first-class-objects/2695337#2695337\">refuting the notion</a> that built-in operators do not participate in overload resolution, and noticed that there is no section on <code>operator-&gt;*</code>. It is just a generic binary operator.</p>\n<p>Its brethren, <code>operator-&gt;</code>, <code>operator*</code>, and <code>operator[]</code>, are all required to be non-static member functions. This precludes definition of a free function overload to an operator <em>commonly</em> used to obtain a reference from an object. But the uncommon <code>operator-&gt;*</code> is left out.</p>\n<p>In particular, <code>operator[]</code> has many similarities. It is binary (they missed a golden opportunity to make it n-ary), and it accepts some kind of container on the left and some kind of locator on the right. Its special-rules section, 13.5.5, doesn't seem to have any actual effect except to outlaw free functions. (And that restriction even precludes support for commutativity!)</p>\n<p>So, for example, this is <a href=\"http://ideone.com/abA3ux\" rel=\"nofollow noreferrer\">perfectly legal</a>:</p>\n<pre><code>#include &lt;utility&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt; class T &gt;\nT &amp;\noperator-&gt;*( pair&lt;T,T&gt; &amp;l, bool r )\n    { return r? l.second : l.first; }\n\ntemplate&lt; class T &gt;\n T &amp; operator-&gt;*( bool l, pair&lt;T,T&gt; &amp;r ) { return r-&gt;*l; }\n\nint main() {\n        pair&lt;int, int&gt; y( 5, 6 );\n        y-&gt;*(0) = 7;\n        y-&gt;*0-&gt;*y = 8; // evaluates to 7-&gt;*y = y.second\n        cerr &lt;&lt; y.first &lt;&lt; \" \" &lt;&lt; y.second &lt;&lt; endl;\n}\n</code></pre>\n<p>It's easy to find uses, but alternative syntax tends not to be that bad. For example, scaled indexes for <code>vector</code>:</p>\n<pre><code>v-&gt;*matrix_width[2][5] = x; // -&gt;* not hopelessly out of place\n\nmy_indexer&lt;2&gt; m( v, dim ); // my_indexer being the type of (v-&gt;*width)\nm[2][5] = x; // it is probably more practical to slice just once\n</code></pre>\n<p>Did the standards committee forget to prevent this, was it considered too ugly to bother, or are there real-world use cases?</p>\n", "AcceptedAnswerId": "2752446", "Title": "Are free operator->* overloads evil?", "CreationDate": "2010-04-23T07:20:42.750", "Id": "2696864", "CommentCount": "3", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:53:30.537", "LastEditorUserId": "-1", "LastActivityDate": "2014-08-10T05:07:52.713", "Score": "34", "OwnerUserId": "153285", "Tags": "<c++><operator-overloading>", "AnswerCount": "4"}, "2699558": {"Id": "2699558", "PostTypeId": "2", "Body": "<p>Standard (Working Draft 2010-02-16, \u00a7 5.5) says:</p>\n<blockquote>\n<p id=\"so_2696864_2699558_0\">The result of an -&gt;* expression is an\n  lvalue only if its second operand is a\n  pointer to data member. If the second\n  operand is the null pointer to member\n  value (4.11), the behavior is\n  undefined.</p>\n</blockquote>\n<p>You may want this behavior to be <strong>well-defined</strong>. For example, check if it is a null pointer and handle this situation. SO I quess it is right decision for a standard to allow -&gt;* overloading.</p>\n", "LastActivityDate": "2010-04-23T14:57:23.757", "CommentCount": "1", "CreationDate": "2010-04-23T14:57:23.757", "ParentId": "2696864", "Score": "1", "OwnerUserId": "288406"}, "bq_ids": {"n4140": {"so_2696864_2699558_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 6133}}, "n3337": {"so_2696864_2699558_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 5897}}, "n4659": {"so_2696864_2699558_0": {"length": 15, "quality": 0.7894736842105263, "section_id": 7630}}}, "20645086": {"Id": "20645086", "PostTypeId": "2", "Body": "<p>The best example I am aware of is <a href=\"http://www.boost.org/doc/libs/1_55_0/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator\">Boost.Phoenix</a>, which overloads this operator to implement lazy member access.</p>\n<p>For those unfamiliar with Phoenix, it is a supremely nifty library for building actors (or function objects) that look like normal expressions:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>( arg1 % 2 == 1 )     // this expression evaluates to an actor\n                 (3); // returns true since 3 % 2 == 1\n\n// these actors can also be passed to standard algorithms:\nstd::find_if(c.begin(), c.end(), arg1 % 2 == 1);\n// returns iterator to the first odd element of c\n</code></pre>\n<p>It achieves the above by overloading <code>operator%</code> and <code>operator==</code>. - applied to the actor <code>arg1</code> these operators return another actor. The range of expressions which can be built in this manner is extreme:</p>\n<pre><code>// print each element in c, noting its value relative to 5:\nstd::for_each(c.begin(), c.end(),\n  if_(arg1 &gt; 5)\n  [\n    cout &lt;&lt; arg1 &lt;&lt; \" &gt; 5\\n\"\n  ]\n  .else_\n  [\n    if_(arg1 == 5)\n    [\n      cout &lt;&lt; arg1 &lt;&lt; \" == 5\\n\"\n    ]\n    .else_\n    [\n      cout &lt;&lt; arg1 &lt;&lt; \" &lt; 5\\n\"\n    ]\n  ]\n);\n</code></pre>\n<p>After you have been using Phoenix for a short while (not that you ever go back) you will try something like this:</p>\n<pre><code>typedef std::vector&lt;MyObj&gt; container;\ncontainer c;\n//...\ncontainer::iterator inv = std::find_if(c.begin(), c.end(), arg1.ValidStateBit);\nstd::cout &lt;&lt; \"A MyObj was invalid: \" &lt;&lt; inv-&gt;Id() &lt;&lt; std::endl;\n</code></pre>\n<p>Which will fail, because of course Phoenix's actors do not have a member <code>ValidStateBit</code>. Phoenix gets around this by overloading <code>operator-&gt;*</code>:</p>\n<pre><code>(arg1 -&gt;* &amp;MyObj::ValidStateBit)              // evaluates to an actor\n                                (validMyObj); // returns true \n\n// used in your algorithm:\ncontainer::iterator inv = std::find_if(c.begin(), c.end(), \n      (arg1 -&gt;* &amp;MyObj::ValidStateBit)    );\n</code></pre>\n<p><code>operator-&gt;*</code>'s arguments are:</p>\n<ul>\n<li><strong>LHS:</strong> an actor returning <code>MyObj *</code></li>\n<li><strong>RHS:</strong> address of a member</li>\n</ul>\n<p>It returns an actor which evaluates the LHS and looks for the specified member in it. (NB: You really, <em>really</em> want to make sure that <code>arg1</code> returns <code>MyObj *</code> - you have not seen a massive template error until you get something wrong in Phoenix. This little program generated 76,738 characters of pain (Boost 1.54, gcc 4.6):</p>\n<pre><code>#include &lt;boost/phoenix.hpp&gt;\nusing boost::phoenix::placeholders::arg1;\n\nstruct C { int m; };\nstruct D { int n; };\n\nint main() {\n  ( arg1  -&gt;*  &amp;D::n ) (new C);\n  return 0;\n}\n</code></pre>\n", "LastActivityDate": "2013-12-17T21:30:38.490", "CommentCount": "2", "CreationDate": "2013-12-17T21:30:38.490", "ParentId": "2696864", "Score": "13", "OwnerUserId": "1836590"}, "2708220": {"Id": "2708220", "PostTypeId": "2", "Body": "<p>I agree with you that there is an incoherence on the standard, It doesn't allows overloading of <code>operator[]</code> with non-member functions and allows it for <code>operator-&gt;*</code>. For my point of view <code>operator[]</code> is to arrays as <code>operator-&gt;*</code> is to structs/classes (a getter). Members of an array are selected using an index. Members of a struct are selected using member pointers.</p>\n<p>The worst is that we can be tempted to use <code>-&gt;*</code> instead of <code>operator[]</code> to get an array like element</p>\n<pre><code>int&amp; operator-&gt;*(Array&amp; lhs, int i);\n\nArray a;\n\na -&gt;* 2 = 10;\n</code></pre>\n<p>There is also another possible incoherence. We can use a non member function to overload <code>operator+=</code> and all the operator of the form <code>@=</code>) and we cannot do it for <code>operator=</code>.</p>\n<p>I don't really know what is the rationale to make the the following legal</p>\n<pre><code>struct X {\n    int val;\n    explicit X(int i) : val(i) {}\n};\nstruct Z {\n    int val;\n    explicit Z(int i) : val(i) {}\n};\nZ&amp; operator+=(Z&amp; lhs, const X&amp; rhs) {\n    lhs.val+=rhs.val;\n    return lhs;\n}\n\nZ z(2);\nX x(3);\nz += x;\n</code></pre>\n<p>and forbidding</p>\n<pre><code>Z&amp; operator=(Z&amp; lhs, const X&amp; rhs) {\n    lhs.val=i;\n    return lhs;\n}\n\nz = x;\n</code></pre>\n<p>Sorry to not answer to your question, but adding even more confusion. </p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-10T05:07:52.713", "Score": "6", "CreationDate": "2010-04-25T12:39:28.510", "ParentId": "2696864", "CommentCount": "12", "OwnerUserId": "320757", "LastEditDate": "2014-08-10T05:07:52.713"}});