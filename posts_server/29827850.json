post_cb({"bq_ids": {"n4140": {"so_29827850_29828989_3": {"length": 25, "quality": 1.0, "section_id": 7055}, "so_29827850_29828989_1": {"length": 9, "quality": 0.9, "section_id": 7055}, "so_29827850_29828989_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 7124}}, "n3337": {"so_29827850_29828989_3": {"length": 25, "quality": 1.0, "section_id": 6799}, "so_29827850_29828989_1": {"length": 9, "quality": 0.9, "section_id": 6799}, "so_29827850_29828989_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6868}}, "n4659": {"so_29827850_29828989_3": {"length": 25, "quality": 1.0, "section_id": 8552}, "so_29827850_29828989_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 8625}, "so_29827850_29828989_1": {"length": 9, "quality": 0.9, "section_id": 8552}}}, "29827850": {"ViewCount": "206", "Body": "<p>I have seen use like:</p>\n<pre><code>boost::error_info&lt;struct tag_name, std::string&gt; name_info;\n</code></pre>\n<p>Here <code>tag_name</code> names an incomplete type and the <code>struct</code> keyword preceding it seems to declare it in-place, instead of the slightly more verbose:</p>\n<pre><code>struct tag_name;\nboost::error_info&lt;tag_name, std::string&gt; name_info;\n</code></pre>\n<p>What is the relevant part of the standard that allows this?</p>\n", "AcceptedAnswerId": "29828989", "Title": "Declaring an incomplete type template parameter in place in-the argument list", "CreationDate": "2015-04-23T15:23:53.417", "Id": "29827850", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-03-20T10:37:15.923", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-20T10:37:15.923", "Score": "5", "OwnerUserId": "422131", "Tags": "<c++><templates><language-lawyer><declaration>", "AnswerCount": "1"}, "29828989": {"Id": "29828989", "PostTypeId": "2", "Body": "<p>\u00a73.4.4/2 specifies how elaborated-type-specifiers, in any situation, are looked up and what effect they may have:</p>\n<blockquote>\n<p id=\"so_29827850_29828989_0\">If the <em>elaborated-type-specifier</em> is introduced by the <em>class-key</em> and\n  this lookup does not find a previously declared <em>type-name</em> [..] <strong>the\n  <em>elaborated-type-specifier</em> is a declaration that introduces the\n  <em>class-name</em> as described in 3.3.2</strong>.</p>\n</blockquote>\n<p>Then \u00a73.3.2/7(.2) reads</p>\n<blockquote>\n<p id=\"so_29827850_29828989_1\">The point of declaration of a class first declared in an <em>elaborated-type-specifier</em> is as follows: [..]\n  for an <em>elaborated-type-specifier</em> of the form</p>\n<p id=\"so_29827850_29828989_2\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>class-key\n  identifier</em></p>\n<p id=\"so_29827850_29828989_3\">if the <em>elaborated-type-specifier</em> is used in the <em>decl-specifier-seq</em> or\n  <em>parameter-declaration-clause</em> of a function defined in namespace scope,\n  the identifier is declared as a <em>class-name</em> in the namespace that\n  contains the declaration; <strong>otherwise, except as a <code>friend</code> declaration,\n  the identifier is declared in the smallest namespace or block scope\n  that contains the declaration.</strong></p>\n</blockquote>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-04-23T16:17:57.200", "Score": "6", "CreationDate": "2015-04-23T16:11:57.483", "ParentId": "29827850", "CommentCount": "0", "LastEditDate": "2015-04-23T16:17:57.200", "OwnerUserId": "3647361"}});