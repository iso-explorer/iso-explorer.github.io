post_cb({"26955983": {"ParentId": "26954276", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>What the <em>standard conversion</em> term means is covered in the following clause of the C++ Standard:</p>\n<blockquote>\n<h2>4 Standard conversions <code>[conv]</code></h2>\n<ol>\n<li><p id=\"so_26954276_26955983_0\">Standard conversions are implicit conversions with built-in meaning. Clause 4 enumerates the full set of such conversions. A <em>standard conversion sequence</em> is a sequence of standard conversions in the following order:</p>\n<p id=\"so_26954276_26955983_1\">\u2014 Zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion,\n  and function-to-pointer conversion.</p>\n<p id=\"so_26954276_26955983_2\">\u2014 Zero or one conversion from the following set: integral promotions, floating point promotion, integral conversions, floating point conversions, floating-integral conversions, pointer conversions, pointer to member conversions, and boolean conversions.</p>\n<p id=\"so_26954276_26955983_3\">\u2014 Zero or one qualification conversion.</p>\n<p id=\"so_26954276_26955983_4\">[ <em>Note:</em> A standard conversion sequence can be empty, i.e., it can consist of no conversions. \u2014 <em>end note</em> ]</p></li>\n</ol>\n<p id=\"so_26954276_26955983_5\">A standard conversion sequence will be applied to an expression if necessary to convert it to a required\n  destination type.</p>\n</blockquote>\n<p>In other words, the <em>standard conversion</em> is a set of built-in rules the compiler can apply when converting one type to another. Those built-in conversions include:</p>\n<ul>\n<li>No conversions</li>\n<li>Lvalue-to-rvalue conversion</li>\n<li>Array-to-pointer conversion</li>\n<li>Function-to-pointer conversion</li>\n<li>Qualification conversions</li>\n<li>Integral promotions</li>\n<li>Floating point promotion</li>\n<li>Integral conversions</li>\n<li>Floating point conversions</li>\n<li>Floating-integral conversions</li>\n<li>Pointer conversions</li>\n<li>Pointer to member conversions</li>\n<li>Boolean conversions</li>\n</ul>\n<p>The <em>standard conversion sequence</em> can appear <strong>twice</strong> during the <em>user-defined conversion sequence</em> - <strong>either before and/or after</strong> the <em>user-defined conversion</em>:</p>\n<blockquote>\n<h3>\u00a7 13.3.3.1.2 User-defined conversion sequences <code>[over.ics.user]</code></h3>\n<ol>\n<li><p id=\"so_26954276_26955983_6\">A user-defined conversion sequence consists of an initial standard conversion sequence followed by a user-defined conversion (12.3) followed by a second standard conversion sequence. If the user-defined conversion is specified by a constructor (12.3.1), the initial standard conversion sequence converts the source type to the type required by the argument of the constructor. If the user-defined conversion is specified by a conversion function (12.3.2), the initial standard conversion sequence converts the source type to the implicit object parameter of the conversion function.</p></li>\n<li><p id=\"so_26954276_26955983_7\">The second standard conversion sequence converts the result of the user-defined conversion to the target type for the sequence. Since an implicit conversion sequence is an initialization, the special rules for initialization by user-defined conversion apply when selecting the best user-defined conversion for a user-defined conversion sequence (see 13.3.3 and 13.3.3.1).</p></li>\n</ol>\n</blockquote>\n<p>Having that said, for the following conversion:</p>\n<pre><code>A a;\nB b = a;\n</code></pre>\n<ul>\n<li><p>the compiler will search for the <em>conversion constructor</em> in <code>B</code> that can take an instance of <code>A</code> (<em>source type</em>) through some <em>initial standard conversion sequence</em> so that it could then perform that <em>user-defined conversion</em> through selected constructor, and then apply another <em>standard conversion</em> - <strong>second standard conversion</strong> - for converting the resultant type of the <em>user-defined conversion</em> to the <em>target type</em>;</p>\n<p>or:</p></li>\n<li><p>the compiler will search for the <em>conversion function</em> in <code>A</code> that is callable after some <em>initial standard conversion sequence</em> of the implicit context, that could then convert an instance of <code>A</code> to some type convertible through another <em>standard conversion</em> - the <strong>second standard conversion</strong> - to the <em>target type</em> <code>B</code>.</p></li>\n</ul>\n<p>As a tangible example let's consider the below conversion:</p>\n<pre><code>struct A\n{\n    operator int() const;\n};\n\nA a;\nbool b = a;\n</code></pre>\n<p>The compiler considers the following <em>user-defined conversion sequence</em>:</p>\n<ol>\n<li><p>Initial standard conversion: <em>Qualification conversion</em> of <code>A*</code> to <code>const A*</code> to call <code>const</code><em>-qualified</em> <code>operator int() const</code>.</p></li>\n<li><p>User-defined conversion: conversion of <code>A</code> to <code>int</code>, through <em>user-defined conversion function</em>.</p></li>\n<li><p>Second standard conversion: <em>Boolean conversion</em> of <code>int</code> to <code>bool</code>.</p></li>\n</ol>\n<p>The case you are asking about can be split as follows:</p>\n<pre><code>struct A\n{\n    operator int&amp;();\n};\n\nint&amp;&amp; b = A();\n</code></pre>\n<ul>\n<li>The <em>source type</em> is <code>A</code>.</li>\n<li>The <em>target type</em> is <code>int&amp;&amp;</code>.</li>\n<li>The <em>user-defined conversion sequence</em> is the conversion of <code>A</code> to <code>int&amp;&amp;</code>.</li>\n<li>The <em>initial standard conversion sequence</em> is <em>No conversion</em> at all.</li>\n<li>The <em>user-defined conversion</em> is the conversion of <code>A</code> to <code>int&amp;</code>.</li>\n<li>The <em>second standard conversion sequence</em> (converting the result of the <em>user-defined conversion</em> to the <em>target type</em>) that is a part of the overall <em>user-defined conversion sequence</em> would be here the <em>standard conversion</em> of <code>int&amp;</code> to <code>int&amp;&amp;</code> - an <em>Lvalue-to-rvalue conversion</em>. That conversion is considered since <code>int&amp;</code> and <code>int&amp;&amp;</code> are <em>reference-compatible</em> types. According to the below statement \u00a78.5.3 [dcl.init.ref]/p5:</li>\n</ul>\n<blockquote>\n<p id=\"so_26954276_26955983_8\">[...] if the reference is an rvalue reference and the second standard conversion sequence of the user-defined conversion sequence includes an lvalue-to-rvalue conversion, the program is ill-formed.</p>\n</blockquote>\n<p>that conversion is not applicable in the overall <em>user-defined conversion sequence</em>.</p>\n", "OwnerUserId": "3953764", "LastEditorUserId": "3953764", "LastEditDate": "2014-11-16T16:49:29.223", "Id": "26955983", "Score": "0", "CreationDate": "2014-11-16T10:33:37.007", "LastActivityDate": "2014-11-16T16:49:29.223"}, "26956094": {"ParentId": "26954276", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>[over.ics.user]:</p>\n<blockquote>\n<p id=\"so_26954276_26956094_0\">A user-defined conversion <strong>consists of an initial standard conversion sequence</strong> followed by a user-defined conversion (12.3) followed by <strong>a second standard conversion sequence</strong>. [\u2026]<br>\n  The second standard conversion sequence converts the result of the\n  user-defined conversion to the target type for the sequence.</br></p>\n</blockquote>\n<p>E.g. for </p>\n<pre><code>struct A\n{\n    operator int();\n};\n\nvoid foo(short);\n\nfoo(A());\n</code></pre>\n<p>The second standard conversion sequence converts the <code>int</code> prvalue to the parameter of <code>foo</code>, that is, <code>short</code>. The first standard conversion sequence converts the <code>A</code> object to <code>A</code> (the implicit object parameter of <code>operator int</code>), which constitutes an identity conversion.<br> For references, the rule quoted by you provides an example:</br></p>\n<pre><code>struct X {\n    operator B();\n    operator int&amp;();\n} x;\n\nint&amp;&amp; rri2 = X(); // error: lvalue-to-rvalue conversion applied to\n                  // the result of operator int&amp;\n</code></pre>\n<p>Here, <code>operator int&amp;</code> is selected by overload resolution. The return value is an lvalue reference to <code>int</code>. For that to initialize the reference, an lvalue-to-rvalue conversion would be necessary, and that's precisely what the quote prevents: Lvalues shall not be bound to rvalue references.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-11-16T11:33:04.373", "Id": "26956094", "Score": "2", "CreationDate": "2014-11-16T10:46:39.907", "LastActivityDate": "2014-11-16T11:33:04.373"}, "26954276": {"CommentCount": "0", "AcceptedAnswerId": "26956094", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2014-11-16T05:53:26.993", "LastActivityDate": "2016-03-18T10:32:19.627", "AnswerCount": "2", "LastEditDate": "2016-03-18T10:32:19.627", "ViewCount": "254", "FavoriteCount": "2", "Title": "Second standard conversion sequence of user-defined conversion", "Id": "26954276", "Score": "3", "Body": "<p>I have a misunderstanding about standard-conversion sequence terms. I have come across the following quote <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">N3797</a> \u00a78.5.3/5 [dcl.init.ref]:</p>\n<blockquote>\n<p id=\"so_26954276_26954276_0\">\u2014 If the initializer expression</p>\n<blockquote>\n<p id=\"so_26954276_26954276_4\">\u2014 is an xvalue (but not a bit-field), class prvalue, array prvalue or\n    function lvalue and \u201c<em>cv1</em> T1\u201d is reference-compatible with \u201c<em>cv2</em>\n    T2\u201d, or </p>\n<p id=\"so_26954276_26954276_5\">\u2014 has a class type (i.e., T2 is a class type), where T1 is not\n    reference-related to T2, and can be converted to an xvalue, class\n    prvalue, or function lvalue of type \u201c<em>cv3</em> T3\u201d, where \u201c<em>cv1</em> T1\u201d is\n    reference-compatible with \u201c<em>cv3</em> T3\u201d (see 13.3.1.6),</p>\n</blockquote>\n<p id=\"so_26954276_26954276_3\"><em>[..]</em> \n  In the second case, if the reference is an rvalue reference and the second standard conversion sequence of the user-defined conversion\n  sequence includes an lvalue-to-rvalue conversion, the program is\n  ill-formed.</p>\n</blockquote>\n<p>What is the <em>second</em> standard conversion sequence here? I thought there is a standard conversion sequence including all necessary standard conversions (user-defined and implicit).</p>\n", "Tags": "<c++><c++11><language-lawyer><implicit-conversion><overload-resolution>", "OwnerDisplayName": "user2953119"}, "bq_ids": {"n4140": {"so_26954276_26956094_0": {"section_id": 620, "quality": 0.76, "length": 19}, "so_26954276_26955983_1": {"section_id": 0, "quality": 1.0, "length": 11}, "so_26954276_26955983_4": {"section_id": 0, "quality": 0.7, "length": 7}, "so_26954276_26955983_8": {"section_id": 3321, "quality": 1.0, "length": 13}, "so_26954276_26954276_4": {"section_id": 3321, "quality": 0.8333333333333334, "length": 10}, "so_26954276_26955983_5": {"section_id": 0, "quality": 1.0, "length": 10}, "so_26954276_26954276_3": {"section_id": 3321, "quality": 1.0, "length": 15}, "so_26954276_26954276_1": {"section_id": 3321, "quality": 0.8333333333333334, "length": 10}, "so_26954276_26955983_3": {"section_id": 0, "quality": 1.0, "length": 4}, "so_26954276_26955983_7": {"section_id": 621, "quality": 0.9090909090909091, "length": 30}, "so_26954276_26955983_6": {"section_id": 620, "quality": 0.9361702127659575, "length": 44}, "so_26954276_26955983_2": {"section_id": 0, "quality": 1.0, "length": 24}, "so_26954276_26954276_5": {"section_id": 3321, "quality": 0.8095238095238095, "length": 17}, "so_26954276_26954276_2": {"section_id": 3321, "quality": 0.8095238095238095, "length": 17}, "so_26954276_26955983_0": {"section_id": 0, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_26954276_26956094_0": {"section_id": 610, "quality": 0.76, "length": 19}, "so_26954276_26955983_1": {"section_id": 0, "quality": 1.0, "length": 11}, "so_26954276_26955983_4": {"section_id": 0, "quality": 0.7, "length": 7}, "so_26954276_26955983_8": {"section_id": 3191, "quality": 1.0, "length": 13}, "so_26954276_26954276_4": {"section_id": 3191, "quality": 0.75, "length": 9}, "so_26954276_26955983_5": {"section_id": 0, "quality": 1.0, "length": 10}, "so_26954276_26954276_3": {"section_id": 3191, "quality": 1.0, "length": 15}, "so_26954276_26955983_0": {"section_id": 0, "quality": 0.9444444444444444, "length": 17}, "so_26954276_26955983_3": {"section_id": 0, "quality": 1.0, "length": 4}, "so_26954276_26955983_7": {"section_id": 611, "quality": 0.9090909090909091, "length": 30}, "so_26954276_26955983_6": {"section_id": 610, "quality": 0.9361702127659575, "length": 44}, "so_26954276_26955983_2": {"section_id": 0, "quality": 1.0, "length": 24}, "so_26954276_26954276_5": {"section_id": 3191, "quality": 0.7619047619047619, "length": 16}, "so_26954276_26954276_2": {"section_id": 3191, "quality": 0.7619047619047619, "length": 16}, "so_26954276_26954276_1": {"section_id": 3191, "quality": 0.75, "length": 9}}, "n4659": {"so_26954276_26956094_0": {"section_id": 646, "quality": 0.76, "length": 19}, "so_26954276_26955983_1": {"section_id": 0, "quality": 1.0, "length": 11}, "so_26954276_26955983_3": {"section_id": 0, "quality": 1.0, "length": 4}, "so_26954276_26955983_8": {"section_id": 7667, "quality": 0.6153846153846154, "length": 8}, "so_26954276_26955983_5": {"section_id": 0, "quality": 1.0, "length": 10}, "so_26954276_26954276_3": {"section_id": 4087, "quality": 0.6666666666666666, "length": 10}, "so_26954276_26955983_4": {"section_id": 0, "quality": 0.7, "length": 7}, "so_26954276_26955983_7": {"section_id": 647, "quality": 0.9090909090909091, "length": 30}, "so_26954276_26955983_6": {"section_id": 646, "quality": 0.9361702127659575, "length": 44}, "so_26954276_26955983_2": {"section_id": 0, "quality": 0.8333333333333334, "length": 20}, "so_26954276_26954276_5": {"section_id": 4087, "quality": 0.7142857142857143, "length": 15}, "so_26954276_26954276_2": {"section_id": 4087, "quality": 0.7142857142857143, "length": 15}, "so_26954276_26955983_0": {"section_id": 0, "quality": 0.9444444444444444, "length": 17}}}});