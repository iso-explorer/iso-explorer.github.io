post_cb({"19472550": {"CommentCount": "6", "AcceptedAnswerId": "19472607", "PostTypeId": "1", "LastEditorUserId": "2697746", "CreationDate": "2013-10-20T00:17:41.980", "LastActivityDate": "2017-07-05T17:30:23.510", "LastEditDate": "2013-10-20T00:24:08.193", "ViewCount": "2230", "FavoriteCount": "2", "Title": "Exception safety and make_unique", "Id": "19472550", "Score": "11", "Body": "<p>Just to clarify, using <code>make_unique</code> only adds exception safety when you have multiple allocations in an expression, not just one, correct? For example</p>\n<pre><code>void f(T*);\n\nf(new T);\n</code></pre>\n<p>is perfectly exception safe (as far as allocations and stuff), while</p>\n<pre><code>void f(T*, T*);\n\nf(new T, new T);\n</code></pre>\n<p>is not, correct?</p>\n", "Tags": "<c++><c++11><unique-ptr><exception-safety>", "OwnerUserId": "2697746", "AnswerCount": "3"}, "19472607": {"ParentId": "19472550", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Not only when you have multiple allocations, but whenever you can throw at different places. Consider this:</p>\n<pre><code>f(make_unique&lt;T&gt;(), function_that_can_throw());\n</code></pre>\n<p>Versus:</p>\n<pre><code>f(unique_ptr&lt;T&gt;(new T), function_that_can_throw());\n</code></pre>\n<p>In the second case, the compiler is allowed to call (in order):</p>\n<ul>\n<li><code>new T</code></li>\n<li><code>function_that_can_throw()</code></li>\n<li><code>unique_ptr&lt;T&gt;(...)</code></li>\n</ul>\n<p>Obviously if <code>function_that_can_throw</code> actually throws then you leak. <code>make_unique</code> prevents this case.</p>\n<p>And of course, a second allocation (as in your question) is just a special case of <code>function_that_can_throw()</code>.</p>\n<p>As a general rule of thumb, just use <code>make_unique</code> so that your code is consistent. It is always correct (read: exception-safe) when you need a <code>unique_ptr</code>, and it doesn't have any impact on performance, so there is no reason not to use it (while actually <em>not</em> using it introduces a lot of gotchas).</p>\n", "OwnerUserId": "2070725", "LastEditorUserId": "2070725", "LastEditDate": "2013-10-20T01:00:07.737", "Id": "19472607", "Score": "19", "CreationDate": "2013-10-20T00:28:17.170", "LastActivityDate": "2013-10-20T01:00:07.737"}, "19472593": {"ParentId": "19472550", "CommentCount": "0", "Body": "<p>I'd think you'd be better off comparing things actually using <code>std::unique_ptr&lt;T&gt;</code>:</p>\n<pre><code>void f(std::unique_ptr&lt;T&gt;);\n\nf(std::unique_ptr&lt;T&gt;(new T));\nf(std::make_unique&lt;T&gt;());\n</code></pre>\n<p>Neither of these calls can leak if there is an exception being thrown. However</p>\n<pre><code>void f(std::unique_ptr&lt;T&gt;, std::unique_ptr&lt;T&gt;);\n\ng(std::unique_ptr&lt;T&gt;(new T), std::unique_ptr&lt;T&gt;(new T));\ng(std::make_unique&lt;T&gt;(), std::make_unique&lt;T&gt;());\n</code></pre>\n<p>In this case, the version using <code>std::unique_ptr&lt;T&gt;</code> explicitly can leak if an exception is thrown (because the compiler might start evaluating the <code>new</code>-expressions before constructing either of the temporaries).</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "19472593", "Score": "6", "CreationDate": "2013-10-20T00:25:49.843", "LastActivityDate": "2013-10-20T00:25:49.843"}, "bq_ids": {"n4140": {"so_19472550_44932594_0": {"section_id": 5811, "quality": 0.6, "length": 9}}, "n3337": {"so_19472550_44932594_0": {"section_id": 5584, "quality": 0.6, "length": 9}}, "n4659": {"so_19472550_44932594_0": {"section_id": 7492, "quality": 0.9333333333333333, "length": 14}}}, "44932594": {"ParentId": "19472550", "CommentCount": "0", "Body": "<p>As of C++17, the exception safety issue is fixed by a rewording of <a href=\"http://eel.is/c++draft/expr.call#5\" rel=\"nofollow noreferrer\">[expr.call]</a></p>\n<blockquote>\n<p id=\"so_19472550_44932594_0\">The initialization of a parameter, including every associated value computation and side effect, is indeterminately sequenced with respect to that of any other parameter.</p>\n</blockquote>\n<p>Here <em>indeterminately sequenced</em> means that one is sequenced before another, but it is not specified which.</p>\n<pre><code>f(unique_ptr&lt;T&gt;(new T), function_that_can_throw());\n</code></pre>\n<p>Can have only two possible order of execution</p>\n<ol>\n<li><code>new T</code> <code>unique_ptr&lt;T&gt;::unique_ptr</code> <code>function_that_can_throw</code></li>\n<li><code>function_that_can_throw</code> <code>new T</code> <code>unique_ptr&lt;T&gt;::unique_ptr</code></li>\n</ol>\n<p>Which means it is now exception safe.</p>\n", "OwnerUserId": "4832499", "PostTypeId": "2", "Id": "44932594", "Score": "0", "CreationDate": "2017-07-05T17:30:23.510", "LastActivityDate": "2017-07-05T17:30:23.510"}});