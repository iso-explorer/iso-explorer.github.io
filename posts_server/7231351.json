post_cb({"7231400": {"ParentId": "7231351", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It appears it might be a compiler issue. <a href=\"https://ideone.com/bYhq9\" rel=\"nofollow noreferrer\"><strong>This works in g++ 4.5.1</strong> (<em>click for IdeOne online demo)</em></a></p>\n<p><strong>Conclusion</strong>: It was, in the sense that older g++ implementations did not correctly flag an error; initializer lists do not support moving their elements (elements are implicitely copied in the process). Thank to Kerrek SB for <a href=\"https://stackoverflow.com/questions/7231351/initializer-list-constructing-a-vector-of-noncopyable-but-movable-objects/7232135#7232135\">quoting the helpful phrase</a> from the standard.</p>\n<hr>\n<p>Old proceedings (for the sake of understanding the comments:)</p>\n<p><sub>\n<strong>Edit</strong> Found out that at least g++ 4.6.1+ seem to have your complaint about this code.</sub></p>\n<p><strong>Edit</strong> Upon reading the source to <code>std::initializer_list&lt;T&gt;</code> I'm starting to get the impression that this is not supported by the library (it looks intentional). Whether the standard actually allows for an initializer list to <em>forward</em> the <em>xvalue-ness</em> of it's elements... I wouldn't be surprised if they stopped there (perfect forwarding is still not easily supported in C++0x I think, and not all initializer parameters would need to have the same (deductable) type. </p>\n<p>Anyone with more standardese under his belt care to help out? <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf</a></p>\n<pre><code>#include &lt;vector&gt;\n\nstruct S\n{\n    S(int) {};\n    S(S&amp;&amp;) {};\n};\n\nint main()\n{\n    std::vector&lt;S&gt; v = {S(1), S(2), S(3)};\n    std::vector&lt;S&gt; w = {std::move(S(1)), std::move(S(2)), std::move(S(3))};\n\n    std::vector&lt;S&gt; or_even_just = {1, 2, 3};\n}\n</code></pre>\n<p></p></hr>\n", "OwnerUserId": "85371", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:25:33.503", "Id": "7231400", "Score": "8", "CreationDate": "2011-08-29T14:21:09.177", "LastActivityDate": "2011-08-29T15:28:20.367"}, "7231351": {"CommentCount": "4", "AcceptedAnswerId": "7232135", "CreationDate": "2011-08-29T14:17:11.377", "LastActivityDate": "2017-03-26T04:19:58.323", "PostTypeId": "1", "ViewCount": "2467", "FavoriteCount": "1", "Title": "Initializer-list-constructing a vector of noncopyable (but movable) objects", "Id": "7231351", "Score": "19", "Body": "<p>One can <code>push_back</code> rvalues of a noncopyable-but-movable type into a vector of that type:</p>\n<pre><code>#include &lt;vector&gt;\n\nstruct S\n{\n    S(int);\n    S(S&amp;&amp;);\n};\n\nint main()\n{\n    std::vector&lt;S&gt; v;\n    v.push_back(S(1));\n    v.push_back(S(2));\n    v.push_back(S(3));\n}\n</code></pre>\n<p>However, when I try to initializer-list-construct the vector with the same rvalues, I get errors about a copy constructor being required:</p>\n<pre><code>#include &lt;vector&gt;\n\nstruct S\n{\n    S(int);\n    S(S&amp;&amp;);\n};\n\nint main()\n{\n    std::vector&lt;S&gt; v = {S(1), S(2), S(3)};\n}\n</code></pre>\n<p>I get the following errors with GCC 4.7:</p>\n<pre><code>In file included from include/c++/4.7.0/vector:63:0,\n                 from test.cpp:1:\ninclude/c++/4.7.0/bits/stl_construct.h: In instantiation of 'void std::_Construct(_T1*, _Args&amp;&amp; ...) [with _T1 = S, _Args = {const S&amp;}]':\ninclude/c++/4.7.0/bits/stl_uninitialized.h:77:3:   required from 'static _ForwardIterator std::__uninitialized_copy&lt;_TrivialValueTypes&gt;::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const S*, _ForwardIterator = S*, bool _TrivialValueTypes = false]'\ninclude/c++/4.7.0/bits/stl_uninitialized.h:119:41:   required from '_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const S*, _ForwardIterator = S*]'\ninclude/c++/4.7.0/bits/stl_uninitialized.h:260:63:   required from '_ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, std::allocator&lt;_Tp&gt;&amp;) [with _InputIterator = const S*, _ForwardIterator = S*, _Tp = S]'\ninclude/c++/4.7.0/bits/stl_vector.h:1185:4:   required from 'void std::vector&lt;_Tp, _Alloc&gt;::_M_range_initialize(_ForwardIterator, _ForwardIterator, std::forward_iterator_tag) [with _ForwardIterator = const S*, _Tp = S, _Alloc = std::allocator&lt;S&gt;]'\ninclude/c++/4.7.0/bits/stl_vector.h:362:2:   required from 'std::vector&lt;_Tp, _Alloc&gt;::vector(std::initializer_list&lt;_Tp&gt;, const allocator_type&amp;) [with _Tp = S, _Alloc = std::allocator&lt;S&gt;, std::vector&lt;_Tp, _Alloc&gt;::allocator_type = std::allocator&lt;S&gt;]'\ntest.cpp:11:41:   required from here\ninclude/c++/4.7.0/bits/stl_construct.h:77:7: error: no matching function for call to 'S::S(const S&amp;)'\ninclude/c++/4.7.0/bits/stl_construct.h:77:7: note: candidates are:\ntest.cpp:6:5: note: S::S(S&amp;&amp;)\ntest.cpp:6:5: note:   no known conversion for argument 1 from 'const S' to 'S&amp;&amp;'\ntest.cpp:5:5: note: S::S(int)\ntest.cpp:5:5: note:   no known conversion for argument 1 from 'const S' to 'int'\n</code></pre>\n<p>Should this be allowed? I see no technical obstacles to it being allowed, but I don't have the Standard handy at the moment...</p>\n", "Tags": "<c++><vector><c++11><move-semantics><initializer-list>", "OwnerUserId": "141719", "AnswerCount": "4"}, "7232065": {"ParentId": "7231351", "CommentCount": "1", "Body": "<p>The initializer_list only provides const references and const iterators. There is no way for the vector to move from that.</p>\n<pre><code>template&lt;class E&gt; \nclass initializer_list {\npublic:\n    typedef E value_type;\n\n    typedef const E&amp; reference;\n    typedef const E&amp; const_reference;\n\n    typedef size_t size_type;\n\n    typedef const E* iterator;\n    typedef const E* const_iterator;\n</code></pre>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "7232065", "Score": "6", "CreationDate": "2011-08-29T15:12:56.417", "LastActivityDate": "2011-08-29T15:12:56.417"}, "43024945": {"ParentId": "7231351", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It seems the answer is No per <a href=\"https://stackoverflow.com/a/7232135/4339963\">Kerrek SB's answer</a>. But you can achieve something similar by small helper functions using variadic templates:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;utility&gt;\n\ntemplate &lt;typename T&gt;\nvoid add_to_vector(std::vector&lt;T&gt;* vec) {}\n\ntemplate &lt;typename T, typename... Args&gt;\nvoid add_to_vector(std::vector&lt;T&gt;* vec, T&amp;&amp; car, Args&amp;&amp;... cdr) {\n  vec-&gt;push_back(std::forward&lt;T&gt;(car));\n  add_to_vector(vec, std::forward&lt;Args&gt;(cdr)...);\n}\n\ntemplate &lt;typename T, typename... Args&gt;\nstd::vector&lt;T&gt; make_vector(Args&amp;&amp;... args) {\n  std::vector&lt;T&gt; result;\n  add_to_vector(&amp;result, std::forward&lt;Args&gt;(args)...);\n  return result;\n}\n\nstruct S {\n  S(int) {}\n  S(S&amp;&amp;) {}\n};\n\nint main() {\n  std::vector&lt;S&gt; v = make_vector&lt;S&gt;(S(1), S(2), S(3));\n  return 0;\n}\n</code></pre>\n", "OwnerUserId": "4339963", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:22.357", "Id": "43024945", "Score": "2", "CreationDate": "2017-03-26T04:19:58.323", "LastActivityDate": "2017-03-26T04:19:58.323"}, "bq_ids": {"n4140": {"so_7231351_7232135_0": {"section_id": 3327, "quality": 0.9310344827586207, "length": 27}}, "n3337": {"so_7231351_7232135_0": {"section_id": 3197, "quality": 0.9310344827586207, "length": 27}}, "n4659": {"so_7231351_7232135_0": {"section_id": 4093, "quality": 0.8275862068965517, "length": 24}}}, "7232135": {"ParentId": "7231351", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Maybe this clause from 8.5.4.5 explains it (my emphasis):</p>\n<blockquote>\n<p id=\"so_7231351_7232135_0\">An object of type std::initializer_list is constructed from an\n  initializer list as if the implementation allocated an array of N\n  elements of type E, where N is the number of elements in the\n  initializer list. <strong>Each element of that array is copy-initialized\n  with the corresponding element of the initializer list</strong>, and the\n  std::initializer_list object is constructed to refer to that array.</p>\n</blockquote>\n<p>So you can only initialize from lists if the objects are copyable.</p>\n<hr>\n<p>Update: As Johannes points out, copy-initialization can be realized by both copy and move constructors, so that alone isn't enough to answer the question. Here is, however, an excerpt of the specification of the <code>initializer_list</code> class as described in 18.9:</p>\n<pre><code>  template&lt;class _E&gt;\n    class initializer_list\n    {\n    public:\n      typedef _E            value_type;\n      typedef const _E&amp;     reference;\n      typedef const _E&amp;     const_reference;\n      typedef size_t        size_type;\n      typedef const _E*     iterator;\n      typedef const _E*     const_iterator;\n</code></pre>\n<p>Note how there are no non-constant typedefs!</p>\n<p>I just tried making an IL constructor which would traverse the initializer list via <code>std::make_move_iterator</code>, which failed because <code>const T &amp;</code> cannot be converted to <code>T&amp;&amp;</code>.</p>\n<p>So the answer is: You cannot move from the IL, because the standard says so.</p>\n</hr>", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2011-09-05T10:58:28.630", "Id": "7232135", "Score": "11", "CreationDate": "2011-08-29T15:18:47.137", "LastActivityDate": "2011-09-05T10:58:28.630"}});