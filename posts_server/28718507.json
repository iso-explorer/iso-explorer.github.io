post_cb({"28718740": {"ParentId": "28718507", "CommentCount": "0", "Body": "<p>Ops, my mistake, sorry.</p>\n<p>I deleted the copy constructor, but didn't actually implement a move one assuming it would already be there. Creating a move constructor solves the issue.</p>\n<p>Thanks for the light @Joseph Mansfield.</p>\n", "OwnerUserId": "517503", "PostTypeId": "2", "Id": "28718740", "Score": "2", "CreationDate": "2015-02-25T12:11:42.023", "LastActivityDate": "2015-02-25T12:11:42.023"}, "28719283": {"ParentId": "28718507", "LastEditDate": "2015-02-25T14:57:31.677", "CommentCount": "4", "CreationDate": "2015-02-25T12:39:54.327", "OwnerUserId": "2071258", "LastEditorUserId": "2071258", "PostTypeId": "2", "Id": "28719283", "Score": "3", "Body": "<p>This one is wrong:</p>\n<pre><code>Object&amp;&amp; loadFromFile(const std::string&amp; name) {\n    Object obj;\n    ...\n    return std::move(obj);\n}\n</code></pre>\n<p>You are returning a reference to a local variable, and this is <em>undefined behaviour</em>. The object dies and what you return is a reference to your nose, so demons can come out of it.</p>\n<p>The second one is right:</p>\n<pre><code>Object loadFromFile(const std::string&amp; name) {\n    Object obj;\n    ...\n    return obj;\n}\n</code></pre>\n<p>Indeed, in this case, lookup is performed first as if <code>obj</code> was an rvalue (Standard 12.8.32):</p>\n<blockquote>\n<p id=\"so_28718507_28719283_0\">When the criteria for elision of a copy/move operation are met, but not for an exception-declaration, and the  object to be copied is designated by an lvalue, or <strong>when the expression in a return statement is a (possibly parenthesized) id-expression that names an object with automatic storage duration declared in the body</strong> or parameter-declaration-clause of the innermost enclosing function or lambda-expression, overload resolution to select the constructor for the copy <strong>is first performed as if the object were designated by an rvalue</strong>. If the first overload resolution fails or was not performed, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue. [ Note: This two-stage overload resolution must be performed regardless of whether copy elision will occur. <strong>It determines the constructor to be called if elision is not performed, and the selected constructor must be accessible even if the call is elided</strong>. \u2014end note ]</p>\n</blockquote>\n<p>And move-constructor <code>Object(Object&amp;&amp;)</code> should be selected.</p>\n", "LastActivityDate": "2015-02-25T14:57:31.677"}, "28718666": {"ParentId": "28718507", "CommentCount": "0", "Body": "<p>Can you pass it as an output parameter?\nSomething like:</p>\n<pre><code>void loadFromFile(const std::string&amp; name, Object&amp; obj) {\n    //Operations on obj\n}\n</code></pre>\n", "OwnerUserId": "2541809", "PostTypeId": "2", "Id": "28718666", "Score": "0", "CreationDate": "2015-02-25T12:07:38.173", "LastActivityDate": "2015-02-25T12:07:38.173"}, "bq_ids": {"n4140": {"so_28718507_28719283_0": {"section_id": 481, "quality": 0.946236559139785, "length": 88}}, "n3337": {"so_28718507_28719283_0": {"section_id": 472, "quality": 0.6881720430107527, "length": 64}}, "n4659": {"so_28718507_28719283_0": {"section_id": 504, "quality": 0.8279569892473119, "length": 77}}}, "28718507": {"CommentCount": "4", "ViewCount": "152", "CreationDate": "2015-02-25T12:00:47.527", "LastActivityDate": "2015-02-26T12:30:11.270", "Title": "Return object that cannot be copied by value", "AcceptedAnswerId": "28719283", "PostTypeId": "1", "Id": "28718507", "Score": "2", "Body": "<p>I have a object whose copy operation would be too slow so I decided to <code>delete</code> it and force users to only move. A copy of this object wound't make much sense anyway. But then I have this function:</p>\n<pre><code>Object loadFromFile(const std::string&amp; name) {\n    Object obj;\n    ...\n    return obj;\n}\n</code></pre>\n<p>Even though copy elision happens here and no copy constructor is called, this fails to compile because a copy constructor is <strong>required</strong> to exist and be accessible. This is my second attempt:</p>\n<pre><code>Object&amp;&amp; loadFromFile(const std::string&amp; name) {\n    Object obj;\n    ...\n    return std::move(obj);\n}\n</code></pre>\n<p>This compiles. Yay!</p>\n<p>But a new problem surges when trying to use it:</p>\n<pre><code>Object x = loadFromFile(\"test.txt\");\n</code></pre>\n<p>This again requires a copy constructor. I couldn't get it to work even explicitly using move:</p>\n<pre><code>Object x = std::move(loadFromFile(\"test.txt\"));\n</code></pre>\n<p>The only solution I came was:</p>\n<pre><code>const Object&amp; x = loadFromFile(\"test.txt\");\n</code></pre>\n<p>But <code>x</code> has to be non-const as it is going to be altered later.</p>\n<p>How to deal with it?</p>\n", "Tags": "<c++><copy-constructor><c++14><copy-elision>", "OwnerUserId": "517503", "AnswerCount": "3"}});