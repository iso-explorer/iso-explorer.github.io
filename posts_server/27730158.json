post_cb({"bq_ids": {"n4140": {"so_27730158_27735051_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 4377}}, "n3337": {"so_27730158_27735051_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 4214}}, "n4659": {"so_27730158_27735051_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 5640}}}, "27735051": {"Id": "27735051", "PostTypeId": "2", "Body": "<p>This is quite tricky.  I've summarized the logic in your code below:</p>\n<pre>    \n    In thread T62:\n        Create string s (with reference count)\n        Create output_1 pointing to s in the thread storage for T62 \n        Create thread T5\n        Create output_2 pointing to s in the thread storage for T5\n    Sync point\n    In thread T5:\n        Append to s   ** MODIFY **\n        Thread-safe decrement of reference count for s (not a sync point)\n        End of output_2 lifetime\n        Exit\n    In thread T62:\n        Thread-safe decrement of reference count for s (not a sync point)\n        End of output_1 lifetime\n        Deallocate s  ** MODIFY **\n        Join\n    Sync point\n    In thread T62:\n        Destroy T5\n</pre>\n<p>As far as I can tell, the standard makes no guarantees about synchronization with regard to calling the <code>shared_ptr</code> deleter:</p>\n<blockquote>\n<p id=\"so_27730158_27735051_0\">(20.8.2.2/4) For purposes of determining the presence of a data race, member functions shall access and modify only the shared_ptr and weak_ptr objects themselves and not objects they refer to.</p>\n</blockquote>\n<p>I take this to mean that any modifications that do actually happen to the pointed-to object while calling a member function of the shared_ptr, such as any modifications the deleter might make, are considered to be outside the scope of the <code>shared_ptr</code>, and therefore it is not the responsibility of the <code>shared_ptr</code> to make sure they do not introduce a data race. For example, the modifications made to the string by T5 may not be visible to T62 by the time thread T62 tries to destroy it.</p>\n<p>However, Herb Sutter, in his \"Atomic&lt;&gt; weapons\" talk, indicated he saw it as a bug to have the atomic decrement of the reference count in the <code>shared_ptr</code> destructor without both acquire and release semantics, but I'm not sure how it violates the standard.</p>\n", "LastEditorUserId": "951890", "LastActivityDate": "2015-01-01T23:55:23.647", "Score": "1", "CreationDate": "2015-01-01T21:57:05.663", "ParentId": "27730158", "CommentCount": "7", "OwnerUserId": "951890", "LastEditDate": "2015-01-01T23:55:23.647"}, "27730661": {"Id": "27730661", "PostTypeId": "2", "Body": "<p>[edit] Assumptions below turn out to be faulty, see link in comments. T5, not T62 is the thread spawned in the code above. </p>\n<p><strike>\nIt would be useful to understand the thread ID's, but I assume that T5 is the main thread and T62 is the spawned thread. It looks like the copy is made on the main thread (before the new thread is spwaned) and destroyed on the new thread (obviously). This is safe because the new thread cannot race with the main thread before it exists. </strike></p>\n<p>Hence, this is a thread sanitizer bug. It failed to check whether thread T62 existed at the time of the previous write.\n</p>\n", "LastEditorUserId": "15416", "LastActivityDate": "2015-01-01T23:10:36.430", "Score": "2", "CreationDate": "2015-01-01T12:09:00.497", "ParentId": "27730158", "CommentCount": "4", "OwnerUserId": "15416", "LastEditDate": "2015-01-01T23:10:36.430"}, "27730158": {"ViewCount": "717", "Body": "<p>While working with clang's thread sanitizer we noticed data race warnings. We think it's due to std::string's copy-on-write technique not being thread safe, but we could be wrong. We reduced the warning we were seeing to this code:</p>\n<pre><code>void test3() {\n  std::unique_ptr&lt;std::thread&gt; thread;\n\n  {\n    auto output = make_shared&lt;string&gt;();\n    std::string str = \"test\";\n    thread.reset(new std::thread([str, output]() { *output += str; }));\n    // The str string now goes out of scope but due to COW\n    // the captured string may not have the copy of the content yet.\n  }\n\n  thread-&gt;join();\n}\n</code></pre>\n<p>When compiled with thread sanitizer enabled:</p>\n<pre><code>clang++ -stdlib=libc++ -std=c++11 -O0 -g -fsanitize=thread -lpthread -o test main.cpp\n</code></pre>\n<p>or</p>\n<pre><code>clang++ -std=c++11 -O0 -g -fsanitize=thread -lpthread -o test main.cpp\n</code></pre>\n<p>And when run multiple times, it eventually produces this warning:</p>\n<pre><code>WARNING: ThreadSanitizer: data race (pid=30829)\n  Write of size 8 at 0x7d0c0000bef8 by thread T62:\n    #0 operator delete(void*) &lt;null&gt;:0\n    ...\n\n  Previous write of size 1 at 0x7d0c0000befd by thread T5:\n    #0 std::__1::char_traits&lt;char&gt;::assign(char&amp;, char const&amp;) string:639\n    ...\n</code></pre>\n<p>Is this a false positive from the thread sanitizer or is it a real data race? If the later,\ncan it be work arounded without changing the code (e.g. by passing some flags to the compiler), is this a know bug in the string implemntation (or something else)?</p>\n<p>UPDATE: <em>clang --version</em> outputs:</p>\n<pre><code>Ubuntu clang version 3.5-1ubuntu1 (trunk) (based on LLVM 3.5)\nTarget: x86_64-pc-linux-gnu\nThread model: posix\n</code></pre>\n<p>UPDATE: <a href=\"https://gist.github.com/inetic/b73a8a0f4186c8fe034d\" rel=\"noreferrer\">The cpp</a> I use to reproduce this warning.</p>\n", "Title": "Clang's thread sanitizer warning while using std::string in a multi-threaded environment", "CreationDate": "2015-01-01T10:58:33.220", "LastActivityDate": "2015-01-01T23:55:23.647", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-01-01T12:32:59.567", "LastEditorUserId": "273348", "Id": "27730158", "Score": "16", "OwnerUserId": "273348", "Tags": "<c++><multithreading><c++11><thread-safety><clang++>", "AnswerCount": "2"}});