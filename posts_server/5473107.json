post_cb({"5473107": {"ViewCount": "10398", "Body": "<p>The terms 'operator precedence' and 'order of evaluation' are very commonly used terms in programming and extremely important for a programmer to know. And, as far as I understand them, the two concepts are tightly bound; one cannot do without the other when talking about expressions.</p>\n<p>Let us take a simple example:</p>\n<pre><code>int a=1;  // Line 1\na = a++ + ++a;  // Line 2\nprintf(\"%d\",a);  // Line 3\n</code></pre>\n<p>Now, it is evident that <code>Line 2</code> leads to Undefined Behavior, since <strong><a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow noreferrer\">Sequence points in C and C++</a></strong> include:</p>\n<blockquote>\n<ol>\n<li><p id=\"so_5473107_5473107_0\">Between evaluation of the left and right operands of the &amp;&amp; (logical\n  AND), || (logical OR), and comma\n  operators. For example, in the\n  expression <code>*p++ != 0 &amp;&amp; *q++ != 0</code>, all\n  side effects of the sub-expression\n  <code>*p++ != 0</code> are completed before any attempt to access <code>q</code>.</p></li>\n<li><p id=\"so_5473107_5473107_1\">Between the evaluation of the first operand of the ternary\n  \"question-mark\" operator and the\n  second or third operand. For example,\n  in the expression <code>a = (*p++) ? (*p++)\n  : 0</code> there is a sequence point after\n  the first <code>*p++</code>, meaning it has already\n  been incremented by the time the\n  second instance is executed.</p></li>\n<li><p id=\"so_5473107_5473107_2\">At the end of a full expression. This category includes expression\n  statements (such as the assignment\n  <code>a=b;</code>), return statements, the\n  controlling expressions of if, switch,\n  while, or do-while statements, and all\n  three expressions in a for statement.</p></li>\n<li><p id=\"so_5473107_5473107_3\">Before a function is entered in a function call. The order in which\n  the arguments are evaluated is not\n  specified, but this sequence point\n  means that all of their side effects\n  are complete before the function is\n  entered. In the expression <code>f(i++)\u00a0+ g(j++) + h(k++)</code>,\n  <code>f</code> is called with a\n  parameter of the original value of <code>i</code>,\n  but <code>i</code> is incremented before entering\n  the body of <code>f</code>. Similarly, <code>j</code> and <code>k</code> are\n  updated before entering <code>g</code> and <code>h</code>\n  respectively. However, it is not\n  specified in which order <code>f()</code>, <code>g()</code>, <code>h()</code>\n  are executed, nor in which order <code>i</code>, <code>j</code>,\n  <code>k</code> are incremented. The values of <code>j</code> and\n  <code>k</code> in the body of <code>f</code> are therefore\n  undefined.<a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow noreferrer\">3</a> Note that a function\n  call <code>f(a,b,c)</code> is not a use of the\n  comma operator and the order of\n  evaluation for <code>a</code>, <code>b</code>, and <code>c</code> is\n  unspecified.</p></li>\n<li><p id=\"so_5473107_5473107_4\">At a function return, after the return value is copied into the\n  calling context. (This sequence point\n  is only specified in the C++ standard;\n  it is present only implicitly in\n  C.)</p></li>\n<li><p id=\"so_5473107_5473107_5\">At the end of an initializer; for example, after the evaluation of 5\n  in the declaration <code>int a = 5;</code>.</p></li>\n</ol>\n</blockquote>\n<p>Thus, going by Point # 3:</p>\n<p><em>At the end of a full expression. This category includes expression statements (such as the assignment a=b;), return statements, the controlling expressions of if, switch, while, or do-while statements, and all three expressions in a for statement.</em></p>\n<p><code>Line 2</code> clearly leads to Undefined Behavior. This shows how <strong>Undefined Behaviour</strong> is tightly coupled with <strong>Sequence Points</strong>.</p>\n<p>Now let us take another example:</p>\n<pre><code>int x=10,y=1,z=2; // Line 4\nint result = x&lt;y&lt;z; // Line 5\n</code></pre>\n<p>Now its evident that <code>Line 5</code> will make the variable <code>result</code> store <code>1</code>.</p>\n<p>Now the expression <code>x&lt;y&lt;z</code> in <code>Line 5</code> can be evaluated as either:</p>\n<p><code>x&lt;(y&lt;z)</code> or <code>(x&lt;y)&lt;z</code>. In the first case the value of <code>result</code> will be <code>0</code> and in the second case <code>result</code> will be <code>1</code>. But we know, when the <code>Operator Precedence</code> is <code>Equal/Same</code> - <code>Associativity</code> comes into play, hence, is evaluated as <code>(x&lt;y)&lt;z</code>.</p>\n<p>This is what is said in this <a href=\"http://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx\" rel=\"nofollow noreferrer\">MSDN Article</a>:</p>\n<p><em>The precedence and associativity of C operators affect the grouping and evaluation of operands in expressions. An operator's precedence is meaningful only if other operators with higher or lower precedence are present. Expressions with higher-precedence operators are evaluated first. Precedence can also be described by the word \"binding.\" Operators with a higher precedence are said to have tighter binding.</em></p>\n<p>Now, about the above article:</p>\n<p><em>It mentions \"Expressions with higher-precedence operators are evaluated first.\"</em></p>\n<p>It may sound incorrect. But, I think the article is not saying something wrong if we consider that <code>()</code> is also an operator <code>x&lt;y&lt;z</code> is same as <code>(x&lt;y)&lt;z</code>. My reasoning is if associativity does not come into play, then the complete expressions evaluation would become ambiguous since <code>&lt;</code> is not a <a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow noreferrer\"><strong>Sequence Point</strong></a>.</p>\n<p>Also, another link I found says this on <a href=\"http://www.difranco.net/compsci/C_Operator_Precedence_Table.htm\" rel=\"nofollow noreferrer\">Operator Precedence and Associativity</a>:</p>\n<p><em>This page lists C operators in order of precedence (highest to lowest). Their associativity indicates in what order operators of equal precedence in an expression are applied.</em></p>\n<p>So taking, the second example of <code>int result=x&lt;y&lt;z</code>, we can see here that there are in all 3 expressions, <code>x</code>, <code>y</code> and <code>z</code>, since, the simplest form of an expression consists of a single literal constant or object. Hence the result of the expressions <code>x</code>, <code>y</code>, <code>z</code> would be there <strong>rvalues</strong>, i.e., <code>10</code>, <code>1</code> and <code>2</code> respectively. Hence, now we may interpret <code>x&lt;y&lt;z</code> as <code>10&lt;1&lt;2</code>. </p>\n<p>Now, doesn't Associativity come into play since now we have 2 expressions to be evaluated, either <code>10&lt;1</code> or <code>1&lt;2</code> and since the precedence of operator is same, <em>they are evaluated from left to right</em>?</p>\n<p>Taking this last example as my argument:</p>\n<pre><code>int myval = ( printf(\"Operator\\n\"), printf(\"Precedence\\n\"), printf(\"vs\\n\"),\nprintf(\"Order of Evaluation\\n\") );\n</code></pre>\n<p>Now in the above example, since the <code>comma</code> operator has same precedence, the expressions are evaluated <code>left-to-right</code> and the return value of the last <code>printf()</code> is stored in <code>myval</code>.</p>\n<p>In <a href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1336.pdf\" rel=\"nofollow noreferrer\">SO/IEC 9899:201x</a> under <strong>J.1 Unspecified behavior</strong> it mentions:</p>\n<p><em>The order in which subexpressions are evaluated and the order in which side effects\ntake place, except as specified for the function-call (), &amp;&amp;, ||, ?:, and comma\noperators (6.5).</em></p>\n<p>Now I would like to know, would it be wrong to say:</p>\n<p><em>Order of Evaluation depends on the precedence of operators, leaving cases of Unspecified Behavior.</em></p>\n<p>I would like to be corrected if any mistakes were made in something I said in my question.\nThe reason I posted this question is because of the confusion created in my mind by the MSDN Article. Is it in <strong>Error</strong> or not?</p>\n", "AcceptedAnswerId": "5475260", "Title": "Operator Precedence vs Order of Evaluation", "CreationDate": "2011-03-29T13:16:23.763", "Id": "5473107", "CommentCount": "15", "FavoriteCount": "21", "PostTypeId": "1", "LastEditDate": "2017-04-20T14:40:43.060", "LastEditorUserId": "15168", "LastActivityDate": "2017-07-23T13:37:22.923", "Score": "35", "OwnerUserId": "418729", "Tags": "<c++><c><operator-precedence><order-of-evaluation>", "AnswerCount": "6"}, "19792223": {"Id": "19792223", "PostTypeId": "2", "Body": "<p>I think it's only the</p>\n<pre><code>a++ + ++a\n</code></pre>\n<p>epxression problematic, because</p>\n<pre><code>a = a++ + ++a;\n</code></pre>\n<p>fits first in 3. but then in the 6. rule: complete evaluation before assignment.</p>\n<p>So,</p>\n<pre><code>a++ + ++a\n</code></pre>\n<p>gets for a=1 fully evaluated to:</p>\n<pre><code>1 + 3   // left to right, or\n2 + 2   // right to left\n</code></pre>\n<p>The result is the same = 4.</p>\n<p>An</p>\n<pre><code>a++ * ++a    // or\na++ == ++a\n</code></pre>\n<p>would have undefined results. Isn't it?</p>\n", "LastActivityDate": "2013-11-05T15:12:35.930", "CommentCount": "1", "CreationDate": "2013-11-05T15:12:35.930", "ParentId": "5473107", "Score": "0", "OwnerUserId": "2947694"}, "5473530": {"Id": "5473530", "PostTypeId": "2", "Body": "<p>A good way to look at this is to take the expression tree.</p>\n<p>If you have an expression, lets say <code>x+y*z</code> you can rewrite that into an expression tree:</p>\n<p>Applying the priority and associativity rules:</p>\n<pre><code>x + ( y * z )\n</code></pre>\n<p>After applying the priority and associativity rules, you can safely forget about them.</p>\n<p>In tree form:</p>\n<pre><code>  x\n+\n    y\n  *\n    z\n</code></pre>\n<p>Now the leaves of this expression are <code>x</code>, <code>y</code> and <code>z</code>. What this means is that you can evaluate <code>x</code>, <code>y</code> and <code>z</code> in any order you want, and also it means that you can evaluate the result of <code>*</code> and <code>x</code> in any order.</p>\n<p>Now since these expressions don't have side effects you don't really care. But if they do, the ordering can change the result, and since the ordering can be anything the compiler decides, you have a problem.</p>\n<p>Now, sequence points bring a bit of order into this chaos. They effectively cut the tree into sections.</p>\n<p><code>x + y * z, z = 10, x + y * z</code></p>\n<p>after priority and associativity</p>\n<p><code>x + ( y * z ) , z = 10, x + ( y * z)</code></p>\n<p>the tree:</p>\n<pre><code>      x\n    +\n        y\n      *\n        z\n  , ------------\n      z\n    =\n      10     \n  , ------------\n      x\n    +\n        y\n      *\n        z   \n</code></pre>\n<p>The top part of the tree will be evaluated before the middle, and middle before bottom.</p>\n", "LastActivityDate": "2011-03-29T13:44:20.740", "CommentCount": "20", "CreationDate": "2011-03-29T13:44:20.740", "ParentId": "5473107", "Score": "6", "OwnerUserId": "211659"}, "bq_ids": {"n4140": {"so_5473107_25555976_0": {"length": 4, "quality": 1.0, "section_id": 6163}}, "n3337": {"so_5473107_25555976_0": {"length": 4, "quality": 1.0, "section_id": 5924}}, "n4659": {"so_5473107_25555976_0": {"length": 4, "quality": 1.0, "section_id": 7660}}}, "5474386": {"Id": "5474386", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_5473107_5474386_0\">It mentions \"Expressions with higher-precedence operators are evaluated first.\"</p>\n</blockquote>\n<p>I am just going to repeat what I said <a href=\"https://stackoverflow.com/questions/5459880/operator-precedence-expression-evaluation/5459946#5459946\">here</a>. As far as standard C and C++ are concerned that article is flawed.  Precedence only affects which tokens are considered to be the operands of each operator, but it does not affect in any way the order of evaluation. </p>\n<p>So, the link only explains how Microsoft implemented things, not how the language itself works. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-03-29T14:43:24.900", "Score": "4", "CreationDate": "2011-03-29T14:43:24.900", "ParentId": "5473107", "CommentCount": "2", "OwnerUserId": "165520", "LastEditDate": "2017-05-23T11:54:44.267"}, "5475260": {"Id": "5475260", "PostTypeId": "2", "Body": "<p>Yes, the MSDN article is in error, at least with respect to standard C and C++<sup>1</sup>.</p>\n<p>Now, as to evaluation order being determined by precedence, no it's not! It's as simple as that. Just for example, let's consider your example of <code>x&lt;y&lt;z</code>. According to the associativity rules, this parses as <code>(x&lt;y)&lt;z</code>. Now, consider evaluating this expression on a stack machine. It's perfectly allowable for it to do something like this:</p>\n<pre><code> push(z);    // Evaluates its argument and pushes value on stack\n push(y);\n push(x);\n test_less();  // compares TOS to TOS(1), pushes result on stack\n test_less();\n</code></pre>\n<p>This evaluates <code>z</code> before <code>x</code> or <code>y</code>, but still evaluates <code>(x&lt;y)</code>, then compares the result of that comparison to <code>z</code>, just as it's supposed to.</p>\n<h2>Summary: Order of evaluation is independent of associativity.</h2>\n<p>Precedence is the same way. We can change the expression to <code>x*y+z</code>, and still evaluate <code>z</code> before <code>x</code> or <code>y</code>:</p>\n<pre><code>push(z);\npush(y);\npush(x);\nmul();\nadd();\n</code></pre>\n<h2>Summary: Order of evaluation is independent of precedence.</h2>\n<p>When/if we add in side effects, this remains the same. I think it's educational to think of side effects as being carried out by a separate thread of execution, with a <code>join</code> at the next sequence point (e.g., the end of the expression). So something like <code>a=b++ + ++c;</code> could be executed something like this:</p>\n<pre><code>push(a);\npush(b);\npush(c+1);\nside_effects_thread.queue(inc, b);\nside_effects_thread.queue(inc, c);\nadd();\nassign();\njoin(side_effects_thread);\n</code></pre>\n<p>This also shows why an apparent dependency doesn't necessarily affect order of evaluation either. Even though <code>a</code> is the target of the assignment, this still evaluates <code>a</code> <em>before</em> evaluating either <code>b</code> or <code>c</code>. Also note that although I've written it as \"thread\" above, this could also just as well be a <em>pool</em> of threads, all executing in parallel, so you don't get any guarantee about the order of one increment versus another either.</p>\n<p>Unless the hardware had direct (and <em>cheap</em>) support for thread-safe queuing, this probably wouldn't be used in in a real implementation (and even then it's not very likely). Putting something into a thread-safe queue will normally have quite a bit more overhead than doing a single increment, so it's hard to imagine anybody ever doing this in reality. Conceptually, however, the idea is fits the requirements of the standard: when you use a pre/post increment/decrement operation, you're specifying an operation that will happen sometime after that part of the expression is evaluated, and will be complete at the next sequence point.</p>\n<p>Edit: though it's not exactly threading, some architectures do allow such parallel execution. For a couple of examples, the Intel Itanium and VLIW processors such as some DSPs, allow a compiler to designate a number of instructions to be executed in parallel. Most VLIW machines have a specific instruction \"packet\" size that limits the number of instructions executed in parallel. The Itanium also uses packets of instructions, but designates a bit in an instruction packet to say that the instructions in the current packet can be executed in parallel with those in the next packet. Using mechanisms like this, you get instructions executing in parallel, just like if you used multiple threads on architectures with which most of us are more familiar.</p>\n<h2>Summary: Order of evaluation is independent of apparent dependencies</h2>\n<p>Any attempt at using the value before the next sequence point gives undefined behavior -- in particular, the \"other thread\" is (potentially) modifying that data during that time, and you have <em>no</em> way of synchronizing access with the other thread. Any attempt at using it leads to undefined behavior.</p>\n<p>Just for a (admittedly, now rather far-fetched) example, think of your code running on a 64-bit virtual machine, but the real hardware is an 8-bit processor. When you increment a 64-bit variable, it executes a sequence something like:</p>\n<pre><code>load variable[0]\nincrement\nstore variable[0]\nfor (int i=1; i&lt;8; i++) {\n    load variable[i]\n    add_with_carry 0\n    store variable[i]\n}\n</code></pre>\n<p>If you read the value somewhere in the middle of that sequence, you could get something with only some of the bytes modified, so what you get is neither the old value <em>nor</em> the new one.</p>\n<p>This exact example may be pretty far-fetched, but a less extreme version (e.g., a 64-bit variable on a 32-bit machine) is actually fairly common.</p>\n<h2>Conclusion</h2>\n<p>Order of evaluation does <strong>not</strong> depend on precedence, associativity, or (necessarily) on apparent dependencies. Attempting to use a variable to which a pre/post increment/decrement has been applied in any other part of an expression really does give <em>completely</em> undefined behavior. While an actual crash is unlikely, you're definitely <em>not</em> guaranteed to get either the old value or the new one -- you could get something else entirely.</p>\n<hr>\n<p><sup>1</sup> I haven't checked this particular article, but quite a few MSDN articles talk about Microsoft's Managed C++ and/or C++/CLI but do little or nothing to point out that they don't apply to standard C or C++. This can give the false appearance that they're claiming the rules they have decided to apply to their own languages actually apply to the standard languages. In these cases, the articles aren't technically false -- they just don't have anything to do with standard C or C++. If you attempt to apply those statements to standard C or C++, the result is false.</p>\n</hr>", "LastEditorUserId": "179910", "LastActivityDate": "2011-03-29T17:30:08.563", "Score": "36", "CreationDate": "2011-03-29T15:45:21.147", "ParentId": "5473107", "CommentCount": "8", "OwnerUserId": "179910", "LastEditDate": "2011-03-29T17:30:08.563"}, "25555976": {"Id": "25555976", "PostTypeId": "2", "Body": "<p>Precedence has nothing to do with order of evaluation and vice-versa.  </p>\n<p><a href=\"http://blogs.msdn.com/b/ericlippert/archive/2008/05/23/precedence-vs-associativity-vs-order.aspx?Redirected=true\" rel=\"nofollow\"><strong>Precedence</strong></a> rules describe how an underparenthesized expression should be parenthesized when the expression mixes different kinds of operators. For example, multiplication is of higher precedence than addition, so <code>2 + 3 x 4</code> is equivalent to <code>2 + (3 x 4)</code>, not <code>(2 + 3) x 4</code>.  </p>\n<p><strong>Order of evaluation</strong> rules describe the order in which each operand in an expression is evaluated.  </p>\n<p>Take an example   </p>\n<pre><code>y = ++x || --y;   \n</code></pre>\n<p>By operator precedence rule, it will be parenthesize as (<code>++/--</code> has higher precedence than <code>||</code> which has higher precedence than <code>=</code>):  </p>\n<pre><code>y = ( (++x) || (--y) )   \n</code></pre>\n<p>The order of evaluation of logical OR <code>||</code> states that (C11 6.5.14)   </p>\n<blockquote>\n<p id=\"so_5473107_25555976_0\">the || operator guarantees <strong>left-to-right</strong> evaluation.  </p>\n</blockquote>\n<p>This means that the left operand, i.e the sub-expression <code>(x++)</code> will be evaluated first. Due to short circuiting behavior; <em>If the first operand compares unequal to <code>0</code>, the second operand is not evaluated</em>, right operand <code>--y</code> will not be evaluated although it is parenthesize prior than <code>(++x) || (--y)</code>.</p>\n", "LastActivityDate": "2014-08-28T18:51:29.623", "CommentCount": "0", "CreationDate": "2014-08-28T18:51:29.623", "ParentId": "5473107", "Score": "1", "OwnerUserId": "2455888"}, "5473563": {"Id": "5473563", "PostTypeId": "2", "Body": "<p>The only way precedence influences order of evaluation is that it\ncreates dependencies; otherwise the two are orthogonal.  You've\ncarefully chosen trivial examples where the dependencies created by\nprecedence do end up fully defining order of evaluation, but this isn't\ngenerally true.  And don't forget, either, that many expressions have\ntwo effects: they result in a value, and they have side effects.  These\ntwo are no required to occur together, so even when dependencies\nforce a specific order of evaluation, this is only the order of\nevaluation of the values; it has no effect on side effects.</p>\n", "LastActivityDate": "2011-03-29T13:46:55.137", "CommentCount": "2", "CreationDate": "2011-03-29T13:46:55.137", "ParentId": "5473107", "Score": "10", "OwnerUserId": "649665"}});