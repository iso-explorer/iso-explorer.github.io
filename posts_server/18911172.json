post_cb({"18911333": {"ParentId": "18911172", "CommentCount": "0", "Body": "<p><code>delete[0]</code> is illegal syntax according to the current standard.. </p>\n<p>Plus, when you allocate an object with <code>new</code>, you should deallocate it with <code>delete</code>, and <code>new []</code> with <code>delete []</code>. They are not supposed to be interchangeable. </p>\n<blockquote>\n<h3>C++11 \u00a75.3.5 Delete</h3>\n<p id=\"so_18911172_18911333_0\">The delete-expression operator destroys a most derived object (1.8) or array created by a new-expression.</p>\n<p id=\"so_18911172_18911333_1\">delete-expression:</p>\n<pre><code>::opt delete cast-expression\n\n::opt delete [ ] cast-expression\n</code></pre>\n<p id=\"so_18911172_18911333_2\">The first alternative is for non-array objects, and the second is for arrays. The operand shall have a pointer type, or a class type having a single conversion function (12.3.2) to a pointer type. The result has type <code>void</code>.</p>\n</blockquote>\n", "OwnerUserId": "1009479", "PostTypeId": "2", "Id": "18911333", "Score": "5", "CreationDate": "2013-09-20T07:37:33.333", "LastActivityDate": "2013-09-20T07:37:33.333"}, "18911620": {"ParentId": "18911172", "CommentCount": "0", "Body": "<p>It ran without issues because you were lucky. Generally allocating with new and deleting with delete[] is Undefined Behaviour and \"running without any issues\" belongs to the set of behaviours allowed by UB. A code like this sometimes runs fine in tests but breaks at the most unexpected moment, e.g. live demo for your most important customer. </p>\n", "OwnerUserId": "2771718", "PostTypeId": "2", "Id": "18911620", "Score": "0", "CreationDate": "2013-09-20T07:56:04.413", "LastActivityDate": "2013-09-20T07:56:04.413"}, "18911383": {"ParentId": "18911172", "CommentCount": "0", "Body": "<p>The standard knows of two different types of storage deallocation, single-object form storage deallocation, 18.6.1.1/10-19, which is</p>\n<pre><code>void operator delete(void * ptr) noexcept;\nvoid operator delete(void * ptr, std::nothrow_t const &amp;) noexcept;\n</code></pre>\n<p>and array form storage deallocation, 18.6.1.2/9-17, which is</p>\n<pre><code>void operator delete[](void * ptr) noexcept;\nvoid operator delete[](void * ptr, std::nothrow_t const &amp;) noexcept;\n</code></pre>\n<p>However, historically (pre-standard) there was a <code>delete[N]</code> deallocator, that required you to deallocate as much as you had allocated for your array. I suspect that is what your compiler is interpreting.</p>\n", "OwnerUserId": "1056003", "PostTypeId": "2", "Id": "18911383", "Score": "3", "CreationDate": "2013-09-20T07:39:56.203", "LastActivityDate": "2013-09-20T07:39:56.203"}, "18911340": {"ParentId": "18911172", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Back toward the dawn of C++, when you deleted an array you were required to specify the size of the array you'd allocated:</p>\n<pre><code>int * x = new int[10];\n// ...\ndelete [10] x;\n</code></pre>\n<p>This led to many problems, so the requirement was eliminated long ago. By the time the first C++ standard was written, this syntax was no longer officially allowed.</p>\n<p>Nonetheless, many compilers still accept this syntax for the sake of compatibility with older code that uses it. With MS VC++, this is accepted by default, but if you ask for standard compliance (-Za) you'll get an error like:</p>\n<pre><code>error C2203: delete operator cannot specify bounds for an array\n</code></pre>\n<p>Obligatory aside: you shouldn't be using <code>new</code> to allocate an array anyway. Use <code>std::vector</code>.</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2013-09-20T07:44:02.330", "Id": "18911340", "Score": "12", "CreationDate": "2013-09-20T07:38:03.693", "LastActivityDate": "2013-09-20T07:44:02.330"}, "bq_ids": {"n4140": {"so_18911172_18911333_2": {"section_id": 6105, "quality": 0.64, "length": 16}, "so_18911172_18911333_0": {"section_id": 6105, "quality": 0.9, "length": 9}}, "n3337": {"so_18911172_18911333_2": {"section_id": 5871, "quality": 0.84, "length": 21}, "so_18911172_18911333_0": {"section_id": 5871, "quality": 0.9, "length": 9}}, "n4659": {"so_18911172_18911333_0": {"section_id": 7602, "quality": 0.9, "length": 9}, "so_18911172_18911333_2": {"section_id": 7602, "quality": 0.64, "length": 16}}}, "18911172": {"CommentCount": "4", "AcceptedAnswerId": "18911340", "CreationDate": "2013-09-20T07:27:36.693", "LastActivityDate": "2013-09-20T07:56:04.413", "PostTypeId": "1", "ViewCount": "175", "FavoriteCount": "1", "Title": "Another case of which compiler is right", "Id": "18911172", "Score": "3", "Body": "<p>In my endless pursuit of happiness I came across something like this</p>\n<pre><code>auto temp = new int;\ndelete[0] temp;\n</code></pre>\n<p>and in my mind I was like... <em>\"This can't be right !\"</em> so I fired up the most special and rebellious snowflake compiler to test it and, lo and behold, it compiled and ran without any issues !</p>\n<p>I then tried it in GCC (4.8.1) and it rejected it with this error</p>\n<blockquote>\n<p id=\"so_18911172_18911172_0\">error: expected \u2018]\u2019 before numeric constant</p>\n</blockquote>\n<p>So I ask you my fellow comrades, which one is right? ( surely not MSVC(11) ?! ) and if you could quote the standard that would be great.</p>\n", "Tags": "<c++><visual-c++><language-lawyer>", "OwnerUserId": "1233963", "AnswerCount": "4"}});