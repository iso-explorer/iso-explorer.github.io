post_cb({"bq_ids": {"n4140": {"so_27299158_27305232_1": {"length": 21, "quality": 1.0, "section_id": 5522}, "so_27299158_27305232_0": {"length": 28, "quality": 1.0, "section_id": 5522}}, "n3337": {"so_27299158_27305232_1": {"length": 21, "quality": 1.0, "section_id": 5308}, "so_27299158_27305232_0": {"length": 28, "quality": 1.0, "section_id": 5308}}, "n4659": {"so_27299158_27305232_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 6957}, "so_27299158_27305232_0": {"length": 28, "quality": 1.0, "section_id": 6957}}}, "27300851": {"Id": "27300851", "PostTypeId": "2", "Body": "<p>Following suggestion by @Deduplicator, here is how it can be done with linker and just one wrapper file:</p>\n<p>$ cat glue.cpp</p>\n<pre><code>int fun(int, int);\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint __wrap_fun(int in1, int in2) {\n    return fun(in1, in2);\n}\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>\n<p>Pass --wrap=fun to linker:</p>\n<pre><code>g++ -Wl,--wrap=fun file1.o file2.o glue.o -o exe.out\n</code></pre>\n<p>It works, thanks!</p>\n<p>Any other ideas? :)</p>\n", "LastActivityDate": "2014-12-04T18:00:47.293", "CommentCount": "0", "CreationDate": "2014-12-04T18:00:47.293", "ParentId": "27299158", "Score": "1", "OwnerUserId": "4325266"}, "27303827": {"Body": "<p>This glue works with GCC.</p>\n<pre><code>extern \"C\"\n{\n    static int fun_c(int, int) __attribute__ ((weakref (\"fun\")));\n};\n\nint fun(int a, int b)\n{\n  return fun_c(a, b);\n}\n</code></pre>\n<p>No special linker flags needed.</p>\n<p>Update: the above code does it in the opposite direction, C++-calling-C. The requested direction goes like this:</p>\n<pre><code>static int fun_cpp(int, int) __attribute__ ((weakref (\"manglednameforfun\")));\n\n\nextern \"C\" int fun(int a, int b)\n{\n  return fun_cpp(a, b);\n}\n</code></pre>\n<p>You need to know the mangled name for \"fun\" obviously.</p>\n<p>As a side note, no solution can be standard-conforming, as the standard dows not allow to have two functions with the same name and different language linkages.</p>\n", "CreationDate": "2014-12-04T20:51:43.873", "ParentId": "27299158", "CommentCount": "8", "LastEditDate": "2014-12-05T10:24:11.537", "Id": "27303827", "PostTypeId": "2", "LastActivityDate": "2014-12-05T10:24:11.537", "LastEditorUserId": "775806", "CommunityOwnedDate": "2014-12-04T20:51:43.873", "Score": "2", "OwnerUserId": "775806"}, "27305232": {"Id": "27305232", "PostTypeId": "2", "Body": "<p>This works with gcc and clang, but by my reading of the standard it is not legal:</p>\n<pre><code>int fun(int a, int b);\n\nnamespace C {\nextern \"C\" \n  int fun(int a, int b) {\n    return ::fun(a, b);\n  }\n}\n</code></pre>\n<p>Effectively, names declared <code>extern \"C\"</code> have no external namespace (\u00a77.5 [dcl.link], para. 6):</p>\n<blockquote>\n<p id=\"so_27299158_27305232_0\">At most one function with a particular name can have C language\n  linkage. Two declarations for a function with C language linkage with\n  the same function name (ignoring the namespace names that qualify it)\n  that appear in different namespace scopes refer to the same function.</p>\n</blockquote>\n<p>So declaring and defining the \"C\" function inside a namespace is OK. However, the same clause goes on to say:</p>\n<blockquote>\n<p id=\"so_27299158_27305232_1\">An entity with C language linkage shall not be declared with the same\n  name as an entity in global scope, unless both declarations denote the\n  same entity; no diagnostic is required if the declarations appear in\n  different translation units.</p>\n</blockquote>\n<p>With <code>g++ -c -o glue.o -Wall -Wextra --pedantic -std=c++11 glue.cc</code>, I got no warning, even though the two declarations are in the same translation unit.</p>\n", "LastActivityDate": "2014-12-04T22:18:47.813", "CommentCount": "1", "CreationDate": "2014-12-04T22:18:47.813", "ParentId": "27299158", "Score": "1", "OwnerUserId": "1566221"}, "27299158": {"ViewCount": "258", "Body": "<p>There are two object files. On of them contains definition (the body) of a function. This object file was compiled with C++ compiler, so the function name is mangled. The second object file references (calls) the function from the first object file. However, the second object file was compiled with C compiler, so the function name is not mangled. When linking these two object files, there is an error for undefined symbol. It is not possible to change the source files so that the C++ object file uses extern \"C\" definitions and doesn't mangle the function name. It is however possible to write whatever glue (wrapper) code, compile it with C++ compiler and link together with those object files. Here is a simple example:</p>\n<p>$ cat file1.cpp</p>\n<pre><code>int fun(int in1, int in2) {\n    return in1+in2;\n}\n</code></pre>\n<p>$ cat file2.c</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint fun(int, int);\n\nint main() {\n    printf(\"%d\\n\",fun(3, 4));\n    return 0;\n}\n</code></pre>\n<p>These two files are compiled into objects without any possibility to change those:</p>\n<pre><code>g++ -c file1.cpp -o file1.o\ngcc -c file2.c -o file2.o\n</code></pre>\n<p>Writing a glue code seems like a simple task, but the problem is that we have to export function name to C and import it from C++ at the same time. The only solution i could come up with is to write two wrappers. One of them basically renames the C++ function, and the other one exposes the renamed function to C:</p>\n<p>$ cat glue.cpp </p>\n<pre><code>int cppfun(int, int);\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint fun(int in1, int in2) {\n    return cppfun(in1, in2);\n}\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>\n<p>$ cat gluecpp.cpp </p>\n<pre><code>int fun(int, int);\n\nint cppfun(int in1, int in2) {\n    return fun(in1, in2);\n}\n</code></pre>\n<p>Compile and link those wrappers together with original objects:</p>\n<pre><code>g++ -c glue.cpp -o glue.o\ng++ -c gluecpp.cpp -o gluecpp.o\ng++ file1.o file2.o glue.o gluecpp.o -o exe.out\n</code></pre>\n<p>What do you think, guys, is there another way? This have become simply an academic interest now for me :)</p>\n", "AcceptedAnswerId": "27305232", "Title": "Glueing C and C++ object files without source code", "CreationDate": "2014-12-04T16:34:12.947", "Id": "27299158", "CommentCount": "6", "LastEditDate": "2014-12-05T02:28:10.433", "PostTypeId": "1", "LastEditorUserId": "149392", "LastActivityDate": "2014-12-05T10:24:11.537", "Score": "5", "OwnerUserId": "4325266", "Tags": "<c++><c><linker>", "AnswerCount": "3"}});