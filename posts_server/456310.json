post_cb({"bq_ids": {"n4140": {"so_456310_456339_0": {"length": 19, "quality": 0.95, "section_id": 412}}, "n3337": {"so_456310_456339_0": {"length": 19, "quality": 0.95, "section_id": 403}}, "n4659": {"so_456310_456339_0": {"length": 19, "quality": 0.95, "section_id": 430}}}, "456310": {"ViewCount": "6080", "Body": "<p>In C++ the following code gives a compiler error:</p>\n<pre><code>void destruct1 (int * item)\n{\n  item-&gt;~int();\n}\n</code></pre>\n<p>This code is nearly the same, I just typedef the int to another type and something magic happens:</p>\n<pre><code>typedef int myint;\n\nvoid destruct2 (myint * item)\n{\n  item-&gt;~myint();\n}\n</code></pre>\n<p>Why does the second code works? Does an int gets a destructor just because it has been typedefed?</p>\n<p>In case you wonder why one ever would like to do this: This comes from refactoring C++ code. We're removing the standard heap and replacing it with selfmade pools. This requires us to call placement-new and the destructors. I know that calling destructors for primitive types is useless, but we want them in the code nevertheless in case we later replace PODs with real classes.</p>\n<p>Finding out that naked int's don't work but typedefed ones do was quite a surprise.</p>\n<p>Btw - I have a solution that involves template-functions. We just typedef inside the template and everything is fine.</p>\n", "AcceptedAnswerId": "456339", "Title": "Destructors of builtin types (int, char etc..)", "CreationDate": "2009-01-19T01:43:36.400", "LastActivityDate": "2011-01-23T16:57:48.790", "CommentCount": "0", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2011-01-23T16:57:48.790", "OwnerDisplayName": "Nils", "LastEditorUserId": "240633", "Id": "456310", "Score": "51", "OwnerUserId": "15955", "Tags": "<c++><constructor><destructor><typedef>", "AnswerCount": "1"}, "456339": {"Body": "<p>It's the reason that makes your code work for generic parameters. Consider a container C:</p>\n<pre><code>template&lt;typename T&gt;\nstruct C {\n    // ...\n    ~C() {\n        for(size_t i = 0; i&lt;elements; i++)\n            buffer[i].~T();\n    }\n};\n</code></pre>\n<p>It would be annoying to introduce special cases for built-in types. So C++ allows you to do the above, even if T happens to equal to <code>int</code>. The holy Standard says in <code>12.4 p15</code>:</p>\n<blockquote>\n<p id=\"so_456310_456339_0\">The notation for explicit call of a destructor can be used for any scalar type name. Allowing this makes it possible to write code without having to know if a destructor exists for a given type. </p>\n</blockquote>\n<p>The difference between using a plain int and a typedef'ed int is that they are syntactically different things. The rule is, that in a destructor call, the thing after the <code>~</code> is a type-name. <code>int</code> is not such a thing, but a typedef-name is. Look it up in <code>7.1.5.2</code>. </p>\n", "CreationDate": "2009-01-19T02:05:09.290", "ParentId": "456310", "CommentCount": "3", "LastEditDate": "2009-01-19T02:20:30.130", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2009-01-19T02:20:30.130", "LastEditorUserId": "34509", "Id": "456339", "OwnerDisplayName": "litb", "Score": "75", "OwnerUserId": "34509"}});