post_cb({"bq_ids": {"n4140": {"so_41214250_41214250_2": {"length": 12, "quality": 0.8, "section_id": 2412}}, "n3337": {"so_41214250_41214250_2": {"length": 12, "quality": 0.8, "section_id": 2397}}, "n4659": {"so_41214250_41214250_2": {"length": 12, "quality": 0.8, "section_id": 2687}}}, "41214250": {"ViewCount": "79", "Body": "<p>Lately I've stumbled across a post: <a href=\"http://cpp.indi.frih.net/blog/2014/09/how-to-read-an-entire-file-into-memory-in-cpp/\" rel=\"nofollow noreferrer\">How to read an entire file into memory in C++</a> where different techniques for reading files are described. Each approach is commented about its efficiency or risks related to <em>undefined behaviour</em>.\nAmong the list the following example is presented:</p>\n<pre><code>// Bad code; undefined behaviour\nin.seekg(0, std::ios_base::end);\n</code></pre>\n<p>Which basically in this or a similar form is often used to actually read the file size.\nThe reasoning presented in the post, in short, is that in <code>C standard (N1570) \u00a77.21.3</code> it is stated that:</p>\n<blockquote>\n<p id=\"so_41214250_41214250_0\">Setting the file position indicator to end-of-file, as with\n  fseek(file, 0, SEEK_END), has undefined behavior for a binary stream\n  (because of possible trailing null characters) or for any stream with\n  state-dependent encoding that does not assuredly end in the initial\n  shift state.</p>\n</blockquote>\n<p>Which is <code>footnote 268</code> for:</p>\n<blockquote>\n<p id=\"so_41214250_41214250_1\">A file need not begin nor end in the initial shift state</p>\n</blockquote>\n<p>To confirm the above for C++11 there is an additional reference to <code>C++ standard draft (N3242) 27.9.1.1</code> which states:</p>\n<blockquote>\n<p id=\"so_41214250_41214250_2\">The restrictions on reading and writing a sequence controlled by an\n  object of class basic_filebuf are the same as for reading and writing\n  with the Standard C library FILEs.</p>\n</blockquote>\n<p>Where <code>basic_filebuf</code> according to <a href=\"http://en.cppreference.com/w/cpp/io/basic_ifstream\" rel=\"nofollow noreferrer\">cppreference</a> is a part of implementation for <code>basic_ifstream</code> (internal buffer). Which points that <code>ifstream</code> implementation should be also burdened with the denoted behaviour.</p>\n<p>From what I've understood from the description and from what I've managed to dig, this issue is mostly related to wide-oriented streams which may not end in the <code>initial shift state</code>. </p>\n<p>Seems to me this cannot be a typical case due to the popular usage for file size calculation. Still the topic is not quite clear for me. Hence, the following <strong>questions</strong>:</p>\n<ul>\n<li>What is actually the <code>initial state shift</code>? I assume it cannot be related to data clusters. More to the multibyte char encoding but this way wouldn't the problem be only limited to non-binary streams?</li>\n<li>When actually do we deal with <code>wide-</code> and <code>narrow-oriented</code>streams? I am aware that: <code>\"A newly opened stream has no orientation.\"</code> and the orientation is decided on the first I/O call to the stream. But in practice are there, let's say, any defaults dependent on stream type, system, locale or something else?</li>\n<li>If not already answered or denoted, what is a practical example on when such undefined behaviour could occur? In the sense that one could reproduce it.</li>\n</ul>\n", "AcceptedAnswerId": "41214401", "Title": "Reading files and undefined behaviour", "CreationDate": "2016-12-19T00:11:20.483", "Id": "41214250", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-12-19T22:03:11.150", "Score": "3", "OwnerUserId": "4341198", "Tags": "<c++><c++11><io><ifstream>", "AnswerCount": "1"}, "41214401": {"Id": "41214401", "PostTypeId": "2", "Body": "<p><a href=\"http://www.gnu.org/software/libc/manual/html_node/Shift-State.html\" rel=\"nofollow noreferrer\">\"shift state\"</a> - limited indeed to multibyte text streams (and EOL treatment <code>\\r\\n</code> vs <code>\\n</code>) and <strong>this</strong> problem will be limited to text streams indeed.</p>\n<p>But that is not the <em>only</em> problem. From the article you cited, with my emphasis:</p>\n<blockquote>\n<p id=\"so_41214250_41214401_0\">Some platforms store files as fixed-size records. If the file is shorter than the record size, the rest of the block is padded. When you seek to the \u201cend\u201d, <em>for efficiency\u2019s sake it just jumps you right to the end of the last block\u2026 possibly long <strong>after the actual end of the data</strong>, after a bunch of padding.</em></p>\n</blockquote>\n<p><code>fseek(p_file, 0, SEEK_END)</code> followed by <code>ftell(...)</code> affords a valid answer only as long as <code>EOF</code> flag is not raised. <br>Read \"The solution (really large files)\" section of the cited as it provides the details, particularly:<br> step 4. \"Restore the stream to the start position with <code>seekg()</code>. <em>This will also clear the EOF flag.</em>\"</br></br></p>\n<p>Question in comments:</p>\n<blockquote>\n<p id=\"so_41214250_41214401_1\">do you have the knowledge which platforms particularly?</p>\n</blockquote>\n<p>Google landed me on <a href=\"https://en.wikipedia.org/wiki/List_of_file_systems#Record-oriented_file_systems\" rel=\"nofollow noreferrer\">this list</a> of record-oriented file systems - mainly mainframes, some of which are still used.</p>\n<p>Another area which may be a \"record files\" area: \"the cloud\". You never know when somebody is going to (re)incarnate <a href=\"https://en.wikipedia.org/wiki/Distributed_Data_Management_Architecture\" rel=\"nofollow noreferrer\">Distributed Data Management Architecture</a> and hit problems solvable by <a href=\"https://en.wikipedia.org/wiki/Distributed_Data_Management_Architecture#Record-oriented_files\" rel=\"nofollow noreferrer\">record-oriented files</a>. \nFor all I know (which is next to nothing), NFS <em>may</em> be already doing it: the <a href=\"https://tools.ietf.org/html/rfc3530\" rel=\"nofollow noreferrer\">RFC</a> speaks about \"record lock\".</p>\n<p>One of top of the other, I'd be paying attention to the standard and treat this matter with respect when writing \"truly standard, cross-platform compatible software\" in C/C++.</p>\n", "LastEditorUserId": "620908", "LastActivityDate": "2016-12-19T22:03:11.150", "Score": "3", "CreationDate": "2016-12-19T00:41:03.913", "ParentId": "41214250", "CommentCount": "2", "OwnerUserId": "620908", "LastEditDate": "2016-12-19T22:03:11.150"}});