post_cb({"16765651": {"ParentId": "16765179", "CommentCount": "4", "CreationDate": "2013-05-27T02:34:34.497", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "16765651", "Score": "8", "Body": "<p>@jogojapan's answer explains what the language does.  Here's a couple workarounds if you do want to add new members for a specific specialization:</p>\n<pre><code>template&lt;typename T&gt;\nstruct A_Base {\n    void method1() {}\n};\n\ntemplate&lt;typename T&gt;\nstruct A : public A_Base&lt;T&gt; {};\n\ntemplate&lt;&gt;\nstruct A&lt;int&gt;\n  : public A_Base&lt;int&gt;\n{\n    void method2() {}\n};\n</code></pre>\n<p>Now <code>A&lt;int&gt;</code> has members <code>method1</code> and <code>method2</code>, but <code>A&lt;float&gt;</code> has no <code>method2</code>.</p>\n<p>OR (if you can modify the primary template)...</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;typename T&gt;\nstruct A {\n    void method1() {}\n\n    template&lt;int N=0&gt;\n    auto method2() -&gt;\n    typename std::enable_if&lt;std::is_same&lt;T, int&gt;::value &amp;&amp; N==N&gt;::type\n    {}\n};\n</code></pre>\n<p>The <code>template&lt;int N&gt;</code> and <code>N==N</code> parts make sure <code>std::enable_if</code> has a dependent value and therefore doesn't complain until somebody actually tries to use <code>A&lt;T&gt;::method2</code> with an incorrect <code>T</code> parameter.</p>\n", "LastActivityDate": "2013-05-27T02:34:34.497"}, "16765329": {"ParentId": "16765179", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2013-05-27T01:35:43.897", "Score": "12", "LastEditorUserId": "777186", "LastEditDate": "2013-05-27T02:41:09.813", "Id": "16765329", "OwnerUserId": "777186", "Body": "<p>Each specialization brings an entirely new data type into existence (or an entirely new template, if the specialization is only partial). From the Standard (C++11):</p>\n<blockquote>\n<p id=\"so_16765179_16765329_0\">(\u00a714.5.5/2) Each class template partial specialization is a distinct template and definitions shall be provided for the members of a template partial specialization (14.5.5.3).</p>\n</blockquote>\n<p>And:</p>\n<blockquote>\n<p id=\"so_16765179_16765329_1\">(\u00a714.5.5.3/1) [...] The members of the class template partial specialization are unrelated to the members of the primary template. Class template partial specialization members that are used in a way that requires a definition shall be defined; the definitions of members of the primary template are never used as definitions for members of a class template partial specialization. [...]</p>\n</blockquote>\n<p>The above is stated in the context of <em>partial</em> specializations, but it applies to explicit specializations (as in your case) as well, although the Standard does not say this very clearly.</p>\n<p>Also note that you need not only declare all member functions that you want in a specialization, but you need to define them, too (here, the Standard is very clear even about explicit specializations):</p>\n<blockquote>\n<p id=\"so_16765179_16765329_2\">(14.7.3/5) A member of an explicitly specialized class is not implicitly instantiated from the member declaration of the class template; instead, the member of the class template specialization shall itself be explicitly defined if its definition is required. In this case, the definition of the class template explicit specialization shall be in scope\n  at the point at which the member is defined. The definition of an explicitly specialized class is unrelated to the definition of a generated specialization. That is, its members need not have the same names, types, etc. as the members of a generated specialization. [...]</p>\n</blockquote>\n<p>So, indeed, <code>A&lt;int&gt;</code> will only have <code>method2()</code>, and <code>A&lt;float&gt;</code> will only have <code>method1()</code> as member. Furthermore, if you were to introduce <code>method1()</code> in the <code>A&lt;int&gt;</code> specialization as well, it needs not have the same argument types or return type as <code>A&lt;float&gt;::method1()</code>.</p>\n<p>See @aschepler's answer for possible ways to avoid having to rewrite the template definition for the <code>int</code> case.</p>\n", "LastActivityDate": "2013-05-27T02:41:09.813"}, "16765179": {"CommentCount": "0", "AcceptedAnswerId": "16765329", "CreationDate": "2013-05-27T01:09:20.267", "LastActivityDate": "2013-05-27T02:41:09.813", "PostTypeId": "1", "ViewCount": "1752", "FavoriteCount": "1", "Title": "Does a template specialization extend or override the generic template?", "Id": "16765179", "Score": "5", "Body": "<pre><code>template&lt;typename T&gt;\nstruct A{\n    void method1(){}\n };\n\ntemplate&lt;&gt;\nstruct A&lt;int&gt;{\n    void method2(){}\n };\n</code></pre>\n<p>Will <code>A&lt;int&gt;</code> have both method1 and method2? And <code>A&lt;float&gt;</code> will only have <code>method1</code> ?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "3758484", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_16765179_16765329_0": {"section_id": 136, "quality": 0.8666666666666667, "length": 13}, "so_16765179_16765329_2": {"section_id": 267, "quality": 0.9433962264150944, "length": 50}, "so_16765179_16765329_1": {"section_id": 149, "quality": 0.9354838709677419, "length": 29}}, "n3337": {"so_16765179_16765329_0": {"section_id": 130, "quality": 0.8666666666666667, "length": 13}, "so_16765179_16765329_2": {"section_id": 258, "quality": 0.9433962264150944, "length": 50}, "so_16765179_16765329_1": {"section_id": 143, "quality": 0.9354838709677419, "length": 29}}, "n4659": {"so_16765179_16765329_0": {"section_id": 140, "quality": 0.8666666666666667, "length": 13}, "so_16765179_16765329_2": {"section_id": 274, "quality": 0.9433962264150944, "length": 50}, "so_16765179_16765329_1": {"section_id": 153, "quality": 0.9354838709677419, "length": 29}}}, "16765206": {"ParentId": "16765179", "CommentCount": "2", "CreationDate": "2013-05-27T01:13:00.610", "OwnerUserId": "25824", "PostTypeId": "2", "Id": "16765206", "Score": "1", "Body": "<p>The specialisation replaces the generic template. So <code>A&lt;int&gt;</code> will only have <code>method2()</code> and, of course, <code>A&lt;double&gt;</code> will only have <code>method1()</code>.</p>\n", "LastActivityDate": "2013-05-27T01:13:00.610"}});