post_cb({"bq_ids": {"n4140": {"so_24152017_24152066_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 5451}, "so_24152017_24152066_4": {"length": 23, "quality": 0.8846153846153846, "section_id": 5451}, "so_24152017_24152066_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5451}, "so_24152017_24152066_5": {"length": 23, "quality": 0.8846153846153846, "section_id": 5451}}, "n3337": {"so_24152017_24152066_2": {"length": 8, "quality": 0.7272727272727273, "section_id": 5245}, "so_24152017_24152066_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 5245}}, "n4659": {"so_24152017_24152066_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 6889}, "so_24152017_24152066_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6889}}}, "24152017": {"ViewCount": "453", "Body": "<p>Consider following:</p>\n<pre><code>auto list = std::make_tuple(1, 2, 3, 4);\n\n/// Work like a charm\ntemplate &lt;class T&gt;\nauto test1(T &amp;&amp;brush) -&gt; decltype(std::get&lt;0&gt;( std::forward&lt;T&gt;(brush) )) {\n    return std::get&lt;0&gt;( std::forward&lt;T&gt;(brush) );\n}\n\n\n/// And now - C++14 feature\n/// fail to compile - return value(temporary), instead of l-reference\ntemplate &lt;class T&gt;\nauto test2(T &amp;&amp;brush) {\n    return std::get&lt;0&gt;( std::forward&lt;T&gt;(brush) );\n}\n\nint main()\n{\n    auto &amp;t1 = test1(list);\n    auto &amp;t2 = test2(list);        \n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/816dea1a0ed3e9ee\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/816dea1a0ed3e9ee</a></p>\n<p>Both, gcc and clang throw error:</p>\n<pre><code>main.cpp:26:11: error: non-const lvalue reference to type 'int' cannot bind to a temporary of type 'int'\n    auto &amp;t2 = test2(list);        \n          ^    ~~~~~~~~~~~\n</code></pre>\n<p>Shouldn't it work like with <em>decltype</em>? Why difference?</p>\n<hr>\n<p><strong>UPDATED</strong></p>\n<p>Wouldn't it be, in case with <code>std::get</code>, be equivalent to this? (I work with gcc 4.8)</p>\n<pre><code>template &lt;class T&gt;\nauto&amp;&amp; test2(T &amp;&amp;brush) {\n    return std::get&lt;0&gt;( std::forward&lt;T&gt;(brush) );\n}\n</code></pre>\n</hr>", "AcceptedAnswerId": "24152066", "Title": "C++1y auto function type deduction", "CreationDate": "2014-06-10T22:41:12.100", "Id": "24152017", "CommentCount": "3", "LastEditDate": "2014-06-10T23:10:59.307", "PostTypeId": "1", "LastEditorUserId": "1559666", "LastActivityDate": "2014-06-10T23:10:59.307", "Score": "3", "OwnerUserId": "1559666", "Tags": "<c++><auto><c++14>", "AnswerCount": "2"}, "24152066": {"Id": "24152066", "PostTypeId": "2", "Body": "<p><code>auto</code> only deduces the object type, meaning the the value-category of the object returned is not part of the return type.</p>\n<p>Using the <code>auto</code> placeholder, type of the return statement is deduced by rules of template argument deduction:</p>\n<blockquote>\n<p id=\"so_24152017_24152066_0\"><code>\u00a7 7.1.6.4/7</code> <code>auto specificer</code> <code>[dcl.spec.auto]</code></p>\n<blockquote>\n<p id=\"so_24152017_24152066_2\">If the placeholder is the auto <em>type-speci\ufb01er</em>, the deduced type is determined using the rules for template argument deduction.</p>\n</blockquote>\n</blockquote>\n<p><code>decltype(auto)</code> on the other hand uses deduction as if by <code>decltype()</code>:</p>\n<blockquote>\n<p id=\"so_24152017_24152066_3\"><code>\u00a7 7.1.6.4/7</code> <code>auto specificer</code> <code>[dcl.spec.auto]</code></p>\n<blockquote>\n<p id=\"so_24152017_24152066_5\">If the placeholder is the <code>decltype(auto)</code> <em>type-speci\ufb01er</em>, the declared type of the variable or return type of the function shall be the placeholder alone. The type deduced for the variable or return type is determined as described in <code>7.1.6.2</code>, as though the initializer had been the operand of the <code>decltype</code>.</p>\n</blockquote>\n</blockquote>\n<p>So for perfect-forwarding return types, this is what you should use. Here's how it looks:</p>\n<pre><code>template &lt;class T&gt;\ndecltype(auto) test2(T &amp;&amp;brush) {\n    return std::get&lt;0&gt;(std::forward&lt;T&gt;(brush));\n}\n</code></pre>\n<p>As a result, the return type will be an rvalue/lvaue-reference depending on the deduced type of <code>brush</code>.</p>\n<p>I tested the above on Coliru, and it seems that <code>g++ 4.8</code> can't compile the above code yet, though using <a href=\"http://coliru.stacked-crooked.com/a/96677bd195b4dbfb\" rel=\"nofollow\"><code>clang++</code></a> it compiles fine.</p>\n", "LastEditorUserId": "701092", "LastActivityDate": "2014-06-10T23:05:33.437", "Score": "7", "CreationDate": "2014-06-10T22:46:13.823", "ParentId": "24152017", "CommentCount": "8", "OwnerUserId": "701092", "LastEditDate": "2014-06-10T23:05:33.437"}, "24152078": {"Id": "24152078", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24152017_24152078_0\">Shouldn't it work like with decltype? Why difference?</p>\n</blockquote>\n<p>It should work like <code>decltype</code>, but <code>auto</code> doesn't work exactly like <code>decltype</code> in other cases, and they didn't want to make <code>auto</code> inconsistent.</p>\n<p>Instead, C++1y introduces new syntax <code>decltype(auto)</code> for the idiomatic deduced function return type.</p>\n", "LastActivityDate": "2014-06-10T22:47:09.303", "CommentCount": "2", "CreationDate": "2014-06-10T22:47:09.303", "ParentId": "24152017", "Score": "2", "OwnerUserId": "153285"}});