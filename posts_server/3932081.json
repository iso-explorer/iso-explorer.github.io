post_cb({"3932081": {"ViewCount": "341", "Body": "<p>I know there's an old saying when you want to indicate this specific pointer doesn't point to anything it should be set to NULL(actually 0), but I'm wondering isn't there actually a physical part of memory with the address of NULL(0) ?</p>\n", "AcceptedAnswerId": "3932123", "Title": "Is there any physical part of memory with the address of NULL(0)?", "CreationDate": "2010-10-14T10:09:10.827", "Id": "3932081", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2010-10-14T14:43:43.320", "Score": "3", "OwnerUserId": "388056", "Tags": "<c++><memory><pointers><null>", "AnswerCount": "7"}, "3932156": {"Id": "3932156", "PostTypeId": "2", "Body": "<p>In kernel space yes NULL can be a valid address. In user space no. As for physical address, yes there always is address zero, but programs work with logical addresses.</p>\n", "LastActivityDate": "2010-10-14T10:20:08.403", "CommentCount": "7", "CreationDate": "2010-10-14T10:20:08.403", "ParentId": "3932081", "Score": "1", "OwnerUserId": "211659"}, "3932123": {"Id": "3932123", "PostTypeId": "2", "Body": "<p>There is always a physical address of 0 (but it may not necessarily map onto physical RAM), but on a typical platform any accesses will typically be performed in a virtual address space (as jweyrich points out below, you can use <code>mmap</code> and so on to directly map the physical address space), so any attempt to read/write to address 0 will raise an exception of some kind.</p>\n<p>On simpler processors (think microcontrollers and so on), there may be no such protection, so if you attempt to write to address 0, there'll be nothing to catch you.</p>\n<p>Note also that a null pointer doesn't necessarily have to point at address 0; the only guarantee is that it will compare equal to integer value <code>0</code>.</p>\n", "LastEditorUserId": "129570", "LastActivityDate": "2010-10-14T10:23:01.917", "Score": "6", "CreationDate": "2010-10-14T10:14:26.470", "ParentId": "3932081", "CommentCount": "16", "OwnerUserId": "129570", "LastEditDate": "2010-10-14T10:23:01.917"}, "3932269": {"Id": "3932269", "PostTypeId": "2", "Body": "<p>Note that even though the value 0 compares equal to a C/C++ NULL pointer, it is not guaranteed in the standard that a null pointer actually references address zero in the (virtual) address space of the process. (It usually does, but you know, there are bound to be some microcontrollers out there etc.) So <code>*(reinterpret_cast&lt;int *&gt;(&amp;my_pointer))</code> may not <code>== 0</code>.</p>\n<p>On some versions of Unix (but not on Linux), every process has a read-only page containing only zero bytes mapped into its address space at address zero. On those machines, a null pointer always points to a zero value. There is software out there that makes use of this feature, and crashes when ported to Linux or Windows.</p>\n", "LastActivityDate": "2010-10-14T10:39:22.737", "CommentCount": "2", "CreationDate": "2010-10-14T10:39:22.737", "ParentId": "3932081", "Score": "1", "OwnerUserId": "812839"}, "bq_ids": {"n4140": {"so_3932081_3934394_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 5800}}, "n3337": {"so_3932081_3934394_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 36}, "so_3932081_3934394_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 5573}}, "n4659": {"so_3932081_3934394_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 7259}}}, "3932143": {"Id": "3932143", "PostTypeId": "2", "Body": "<p>Yes, computers can have a physical address 0.  For example, in the old DOS days, you'd regularly poke around there - that's where the interrupt table started - so if you wanted to know what would run on a keypress or timer interrupt then you could create a pointer to an array of pointers, and point <em>that</em> at 0.  I reviewed the wording in the C++ Standard a couple years ago to see if this is necessarily undefined behaviour on a system where address 0 should be accessible (at a CPU/architecture level), and my recollection is that it wasn't explicit in saying this would cause undefined behaviour.  Still, it basically reserves the right to load a non-0 value when you put 0 into a pointer, compare a pointer to 0 etc: 0 is a special sentinel value that it can do whatever it likes with, so if you cared about going \"by the book\" then you'd have to pussy-foot around.</p>\n", "LastActivityDate": "2010-10-14T10:18:02.977", "CommentCount": "0", "CreationDate": "2010-10-14T10:18:02.977", "ParentId": "3932081", "Score": "3", "OwnerUserId": "410767"}, "3934394": {"Id": "3934394", "PostTypeId": "2", "Body": "<p>Since this is tagged C++, it should be noted that the Standard guarantees that trying to access the \"null pointer\" via dereference evokes undefined behavior:</p>\n<h2>1.9 Program execution [intro.execution]</h2>\n<blockquote>\n<p id=\"so_3932081_3934394_0\">Certain other operations are described\n  in this International Standard as\n  undefined (for example, the effect of\n  dereferencing the null pointer).\n  [Note: this International Standard\n  imposes no requirements on the\n  behavior of programs that contain\n  undefined behavior. ]</p>\n</blockquote>\n<p>...that the effect of a failed <code>dynamic_cast</code> is the null pointer, that <code>delete</code>ing the null pointer has no effect, and finally that the \"null pointer constant\" is == the integer expression <code>0</code>:</p>\n<h2>4.10 Pointer conversions [conv.ptr]</h2>\n<blockquote id=\"so_3932081_3934394_1\">\n<ol>\n<li>A null pointer constant is an integral constant expression (5.19)\n  rvalue of integer type that evaluates to zero.</li>\n</ol>\n</blockquote>\n", "LastActivityDate": "2010-10-14T14:43:43.320", "CommentCount": "0", "CreationDate": "2010-10-14T14:43:43.320", "ParentId": "3932081", "Score": "1", "OwnerUserId": "241536"}, "3932115": {"Id": "3932115", "PostTypeId": "2", "Body": "<p>Unless you write a system kernel, from your point of view there is no such memory location. Your addresses are in virtual address-space, that mean they are not physical. They are translated to physical by the CPU looking up system tables.</p>\n", "LastActivityDate": "2010-10-14T10:13:31.540", "CommentCount": "2", "CreationDate": "2010-10-14T10:13:31.540", "ParentId": "3932081", "Score": "1", "OwnerUserId": "277176"}, "3932128": {"Id": "3932128", "PostTypeId": "2", "Body": "<p>Yes, in many systems (especially embedded) there is a memory address 0, which is legal to read and write from.</p>\n<p>On such systems, it may be optional to set up a trap that catches such read/writes.</p>\n", "LastActivityDate": "2010-10-14T10:15:18.747", "CommentCount": "0", "CreationDate": "2010-10-14T10:15:18.747", "ParentId": "3932081", "Score": "3", "OwnerUserId": "63832"}});