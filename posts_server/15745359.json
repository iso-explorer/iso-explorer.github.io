post_cb({"bq_ids": {"n4140": {"so_15745359_15745624_0": {"length": 14, "quality": 1.0, "section_id": 5939}}, "n4659": {"so_15745359_15745624_0": {"length": 14, "quality": 1.0, "section_id": 7423}}}, "15745624": {"Id": "15745624", "PostTypeId": "2", "LastEditDate": "2013-04-01T15:05:44.910", "CommentCount": "5", "LastEditorUserId": "150634", "LastActivityDate": "2013-04-01T15:05:44.910", "CreationDate": "2013-04-01T14:46:49.343", "ParentId": "15745359", "Score": "5", "Body": "<p>An expression calling a function that returns by value is a prvalue. However, there are no <code>const</code> prvalues of non-class non-array type (\u00a75/6):</p>\n<blockquote>\n<p id=\"so_15745359_15745624_0\">If a prvalue initially has the type \u201ccv <code>T</code>,\u201d where <code>T</code> is a cv-unqualified non-class, non-array type, the type of the expression is adjusted to <code>T</code> prior to any further analysis.</p>\n</blockquote>\n<p>This means that there's no difference between your two definitions of the function. Whether it returns a <code>const int</code> or just an <code>int</code> is irrelevant because the expression is never <code>const</code>.</p>\n<p>However, there is a difference when you're returning a class type. Consider the following example:</p>\n<pre><code>struct foo\n{\n  void bar() { std::cout &lt;&lt; \"Hello\" &lt;&lt; std::endl; }\n};\n\nfoo get_foo();\n</code></pre>\n<p>Now, if we call <code>get_foo()</code>, we get a temporary <code>foo</code> object. This prvalue is not <code>const</code> and we can call non-<code>const</code> member functions on it, so we could happily do <code>get_foo().bar()</code>. However, we can change the declaration of <code>get_foo</code> like so:</p>\n<pre><code>const foo get_foo();\n</code></pre>\n<p>Now, the expression <code>get_foo()</code> is a <code>const</code> prvalue (which is allowed because it is a class type) and we cannot call <code>bar</code> on the temporary object returned by it any more.</p>\n<p>Nonetheless, it doesn't make sense to talk about move semantics for a non-class type, as an <code>int</code> is never moved from. If you return a <code>const</code> class type, that can also not be moved from because it is <code>const</code>. To demonstrate:</p>\n<pre><code>foo get_foo();\nfoo f(get_foo()); // Will call the move constructor\n\nconst foo get_foo();\nfoo f(get_foo()); // Will call the copy constructor\n</code></pre>\n<p>This is because a <code>const</code> prvalue won't bind to a non-<code>const</code> rvalue reference, which is what the move constructor takes as its argument.</p>\n", "OwnerUserId": "150634"}, "15745359": {"ViewCount": "831", "LastEditDate": "2013-04-01T15:06:32.353", "AcceptedAnswerId": "15745624", "Title": "Impact of returning const value types in C++11 on move semantics", "CreationDate": "2013-04-01T14:31:15.543", "LastActivityDate": "2013-04-01T15:06:32.353", "CommentCount": "8", "Body": "<p>I'm not clear on the impact that returning <code>const</code> values has on move semantics in C++11.</p>\n<p>Is there any difference between these two functions, which return data members? Is <code>const</code> still redundant in C++11?</p>\n<pre><code>int GetValueA() { return mValueA; }\nconst int GetValueB() { return mValueB; }\n</code></pre>\n<p>What about for these functions?</p>\n<pre><code>int GetValuesAB() { return mValueA + mValueB; }\nconst int GetValuesCD() { return mValueC + mValueD; }\n</code></pre>\n", "PostTypeId": "1", "LastEditorUserId": "150634", "Id": "15745359", "AnswerCount": "1", "Score": "3", "OwnerUserId": "111327", "Tags": "<c++><c++11><const><move-semantics>", "FavoriteCount": "3"}});