post_cb({"bq_ids": {"n4140": {"so_19604660_19604731_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 733}}, "n3337": {"so_19604660_19604731_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 722}}, "n4659": {"so_19604660_19604731_1": {"length": 6, "quality": 0.6666666666666666, "section_id": 763}}}, "19604660": {"ViewCount": "106", "Body": "<pre><code>void f()\n{}\n\nstruct A\n{\n    void f()\n    {}\n};\n\nstruct B : A\n{\n    B()\n    {\n        f(); // A::f() is always called, and ::f is always ignored \n    }\n};\n\nint main()\n{\n    B();\n}\n</code></pre>\n<p>As the class <code>B</code>'s designer, I MIGHT NOT know the fact that <code>B</code>'s base class, i.e. <code>A</code>, has a member function <code>A::f</code>, I just know <code>::f</code>, and call <code>::f</code> is just what I want.</p>\n<p>What I expects is the compiler gives an error because of ambiguity of calling <code>f</code>. However, the compiler always chooses <code>A::f</code> and ignore <code>::f</code>. I think this might be a big pitfall.</p>\n<p>I just wonder: </p>\n<p><strong>Why does the overload resolution of member functions exclude the global functions?</strong></p>\n<p><strong>What's the rationale?</strong></p>\n", "AcceptedAnswerId": "19604731", "Title": "Why does the overload resolution of member functions exclude the global functions?", "CreationDate": "2013-10-26T08:34:29.127", "Id": "19604660", "CommentCount": "0", "LastEditDate": "2013-10-26T08:40:16.323", "PostTypeId": "1", "LastEditorUserId": "508343", "LastActivityDate": "2013-10-27T07:52:43.947", "Score": "1", "OwnerUserId": "508343", "Tags": "<c++><function><namespaces><overloading><overload-resolution>", "AnswerCount": "2"}, "19604731": {"Id": "19604731", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_19604660_19604731_0\">As the class B's designer, I MIGHT NOT know B's base class</p>\n</blockquote>\n<p>I don't agree.</p>\n<blockquote>\n<p id=\"so_19604660_19604731_1\">Why does the overload resolution of member functions exclude the\n  global functions?</p>\n</blockquote>\n<p>Because the two overloads belong to two different scopes and compiler chooses the overload of same scope. Reading \u00a73.4.1 . The <code>f</code> of inner (same) scope hide the outside's <code>f</code>.</p>\n<blockquote>\n<p id=\"so_19604660_19604731_2\">What's the rationale?</p>\n</blockquote>\n<p>To have a solid rule. We prefer to work in a same scope. Unless we explicitly want to call an object from somewhere else.</p>\n<p>In a family by calling Alex, they expect their little boy Alex comes in, not the <a href=\"http://en.wikipedia.org/wiki/Alexander_the_Great\" rel=\"nofollow\">Alexander III of Macedon</a>.</p>\n", "LastEditorUserId": "952747", "LastActivityDate": "2013-10-27T07:52:43.947", "Score": "4", "CreationDate": "2013-10-26T08:45:18.110", "ParentId": "19604660", "CommentCount": "0", "OwnerUserId": "952747", "LastEditDate": "2013-10-27T07:52:43.947"}, "19604765": {"Id": "19604765", "PostTypeId": "2", "Body": "<p>That's just how overload resolution works, and <strong>it's good</strong>.</p>\n<p>Imagine you really have a big project, tons of inter-dependencies, third party code and cross-module includes. In this huge mess, you have that one class you know works. It has been working perfectly for 5 years, it's efficient, easy to read and clean. You don't want to touch it. You then upgrade a modules, and start getting compiler errors. Oh no! That module (which you have no control over) introduced a new function <code>DoAmazingStuff()</code> at the global namespace. The same as a method name in our class. You're going to have to refactor it, since now you can no longer use the same name for a class member. Bummer!</p>\n", "LastActivityDate": "2013-10-26T08:50:18.497", "CommentCount": "1", "CreationDate": "2013-10-26T08:50:18.497", "ParentId": "19604660", "Score": "3", "OwnerUserId": "673730"}});