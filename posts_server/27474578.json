post_cb({"27474578": {"CommentCount": "6", "ViewCount": "171", "CreationDate": "2014-12-14T21:54:25.793", "LastActivityDate": "2014-12-14T22:14:06.523", "Title": "Gcc 4.8.3 does not spot missing 'return' keyword", "PostTypeId": "1", "Id": "27474578", "Score": "1", "Body": "<p>Let's look at such piece of code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint foo(int i) {return i; }\n\nint foobar(int z) {return foo(z);}\n\nint main() {\nstd::cout &lt;&lt; foobar(3) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It compiles fine with g++ -std=c++11 ... and gives output 3. But The same output is given by:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint foo(int i) {return i; }\n\nint foobar(int z) { foo(z);}\n\nint main() {\nstd::cout &lt;&lt; foobar(3) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It compiles without problems but clearly the keyword return is missed in foobar. Is it a bug in gcc 4.8.3 or maybe I'm not aware of some c++11 principle? (Runned on Fedora 20)</p>\n", "Tags": "<c++><c++11><gcc><gcc4.8>", "OwnerUserId": "2581720", "AnswerCount": "2"}, "27474617": {"ParentId": "27474578", "LastEditDate": "2017-05-23T12:12:48.587", "CommentCount": "3", "CreationDate": "2014-12-14T21:58:59.010", "OwnerUserId": "3002139", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "27474617", "Score": "4", "Body": "<p>The code compiles fine because it is <em>well-formed</em>, and so you can run it. But since this is undefined behavior, you cannot rely on any behavior of the program, anything is legal. To prevent accidents like this, enable compiler warnings. if you compile your code with <code>-Wall</code>, you will see</p>\n<pre><code>main.cpp:10:28: warning: no return statement in function returning non-void [-Wreturn-type]\n int foobar(int z) { foo(z);}\n</code></pre>\n<p><a href=\"https://stackoverflow.com/questions/399850/best-compiler-warning-level-for-c-c-compilers\">Here</a> you can get more information about those warnings. Use them and make sure your code compiles warning free. It can catch a <strong>lot</strong> of errors in your code at compile time.</p>\n", "LastActivityDate": "2014-12-14T22:12:21.663"}, "bq_ids": {"n4140": {"so_27474578_27474747_0": {"section_id": 3913, "quality": 1.0, "length": 12}}, "n3337": {"so_27474578_27474747_0": {"section_id": 3773, "quality": 1.0, "length": 12}}, "n4659": {"so_27474578_27474747_0": {"section_id": 4799, "quality": 0.75, "length": 9}}}, "27474747": {"ParentId": "27474578", "CommentCount": "2", "Body": "<p>The C++ standard doesn't make a mandate for compilers to insist on a <code>return</code>-statement in functions return non-<code>void</code>. Instead, flowing off the end of such a function without a <code>return</code>-statement is undefined behavior. The relevant statement in the standard is in 6.6.3 [stmt.return] paragraph 2, last sentence (and in 3.6.1 [basic.start.main] paragraph 5 is the statement making it OK for <code>main()</code> to flow off this function):</p>\n<blockquote>\n<p id=\"so_27474578_27474747_0\">Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior in a value-returning function.</p>\n</blockquote>\n<p>The primary reason for this approach is that it may be non-trivial or even impossible if the function actually ever really returns. Consider this function declaration and function definition:</p>\n<pre><code>extern void will_always_throw();\nint does_not_return_anything() {\n    will_always_throw();\n}\n</code></pre>\n<p>Assuming <code>will_always_throw()</code> indeed does as the name suggests, there is nothing wrong. In fact, if the compiler gets smarter and manages to verify that <code>will_always_throw()</code>, indeed, always throws (or a \"noreturn\" attribute is attached to <code>will_always_throw()</code>, it may warn about the last statement in this definition never being reached:</p>\n<pre><code>int does_return_something_just_in_case() {\n    will_always_throw();\n    return 17;\n}\n</code></pre>\n<p>The general approach to deal with these situations is for compilers to support suitable options enabling/disabling warnings as necessary. For example, on your code all compilers I have access to (<a href=\"http://gcc.gnu.org/\"><code>gcc</code></a>, <a href=\"http://clang.llvm.org/\">clang</a>, and <a href=\"https://software.intel.com/en-us/c-compilers\"><code>icc</code></a>) create a warning assuming warnings are enable (using <code>-Wall</code> for the first two and <code>-w2</code> for Intel's compiler).</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "27474747", "Score": "6", "CreationDate": "2014-12-14T22:14:06.523", "LastActivityDate": "2014-12-14T22:14:06.523"}});