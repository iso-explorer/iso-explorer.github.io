post_cb({"9550041": {"Id": "9550041", "PostTypeId": "2", "Body": "<p>What your macro does is to declare a specializations of some members of a class. This won't create any object and probably not what you really want anyway. What you'd need is a definition of <code>FactoryHelper&lt;SomeClass&gt;::_helper</code> somewhere. A definition of the static member would look something like this:</p>\n<pre><code>FactoryHelper&lt;foo&gt; FactoryHelper&lt;foo&gt;::_helper;\n</code></pre>\n<p>That said, I don't think the is the the way to go at all: all you really need is to instantiate something which registers a factory function and this can be done much simpler and, especially, without macros.</p>\n<p>Here is how I would do this:</p>\n<pre><code>template &lt;typename T&gt;\nstruct factory_helper\n{\n    std::auto_ptr&lt;base&gt; create_fuction() { return std::auto_ptr&lt;base&gt;(new T()); }\n    factory_helper(std::string const&amp; name) {\n        factory.register_class(name, create_function);\n    }\n};\n</code></pre>\n<p>This assumes that you want to create objects derived from type <code>base</code> and that your factory uses a mapping to function object returning <code>std::auto_ptr&lt;base&gt;</code> as constructor functions and that it has a <code>register_class()</code> function which takes the name and the constructor function as parameters. Neither of these assumptions is inherent to the apprach, though: this is just to fill in some of the blanks you didn't mention. You would register a factory function for a class <code>foo</code> something like this:</p>\n<pre><code>static factor_helper&lt;foo&gt; foo_helper(\"foo\");\n</code></pre>\n", "LastActivityDate": "2012-03-03T21:31:21.017", "CommentCount": "0", "CreationDate": "2012-03-03T21:31:21.017", "ParentId": "9549714", "Score": "1", "OwnerUserId": "1120273"}, "9549714": {"ViewCount": "2728", "Body": "<p>I am trying to initialize a static object without success. The purpose is to automatically register a factory class in a repository (which is a singleton).</p>\n<p>I've already had a look at: <a href=\"https://stackoverflow.com/questions/6420985/how-to-force-a-static-member-to-be-initialized\">How to force a static member to be initialized?</a></p>\n<p>One of the comments says that (there is also an example that I've followed): </p>\n<blockquote>\n<p id=\"so_9549714_9549714_0\">I read it up in the C++ standard (14.7.1): Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist; in particular, the initialization (and any associated side-effects) of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist.</p>\n</blockquote>\n<p>So I'm trying to do something similar but I haven't manage to force the object initialization. Here is the code. I don't know what I'm missing. This is the template I'm using.</p>\n<pre><code>namespace my_lib\n{\n    template &lt;typename T&gt;\n    struct FactoryHelper\n    {\n        FactoryHelper ();\n        static FactoryHelper&lt;T&gt; _helper;\n    };\n}\n</code></pre>\n<p>And this is the macro that the user of the library would use to define the factory class and, at the same time, register an object in the repository:</p>\n<pre><code>#define CREATE_FACTORY(ClassName)\\\nnamespace my_lib\\\n{\\\n    class ClassName##Factory;\\\n    template&lt;&gt; FactoryHelper&lt;ClassName##Factory&gt;::FactoryHelper () { std::cout &lt;&lt; \"object initialized!\" &lt;&lt; std::endl; }\\\n    template&lt;&gt; FactoryHelper&lt;ClassName##Factory&gt; FactoryHelper&lt;ClassName##Factory&gt;::_helper;\\\n    struct ClassName##Factory : public FactoryBase&lt;ClassName&gt; {\\\n      ...\\\n    };\\\n} \n</code></pre>\n<p>The previous code is defined in a header file (Factory.h). </p>\n<p>In a .cpp file (Example.cpp), I have:</p>\n<pre><code>CREATE_FACTORY(UnitTestExample)\n...\n</code></pre>\n<p>When I execute the program, I cannot see the message that the constructor prints when it is invoked. Any help is more than welcome.</p>\n<p>Thanks in advance.</p>\n", "AcceptedAnswerId": "9550228", "Title": "trying to force static object initialization", "CreationDate": "2012-03-03T20:43:08.207", "Id": "9549714", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:06:49.487", "LastEditorUserId": "-1", "LastActivityDate": "2012-03-04T19:23:21.853", "Score": "4", "OwnerUserId": "1192525", "Tags": "<c++><templates><initialization><static-members>", "AnswerCount": "4"}, "9550228": {"Id": "9550228", "PostTypeId": "2", "Body": "<p>This is a tricky area of C++.   What you've done is to try to define the static member here:</p>\n<pre><code>template&lt;&gt; FactoryHelper&lt;ClassName##Factory&gt; FactoryHelper&lt;ClassName##Factory&gt;::_helper;\\\n</code></pre>\n<p>but this is actually a declaration and not a definition.  For C++ to treat it as a definition you have to pass something to the constructor.  Typically, this is the value you want to initialize it to:</p>\n<pre><code>template&lt;&gt; FactoryHelper&lt;ClassName##Factory&gt; FactoryHelper&lt;ClassName##Factory&gt;::_helper = FactoryHelper&lt;ClassName##Factory&gt;();\\\n</code></pre>\n<p>But in your case, you want this to be a singleton, so you probably don't want it to be copyable.  In that case, you need some dummy parameter:</p>\n<pre><code>template&lt;&gt; FactoryHelper&lt;ClassName##Factory&gt; FactoryHelper&lt;ClassName##Factory&gt;::_helper(0);\\\n</code></pre>\n<p>and you have to modify your constructor appropriately:</p>\n<pre><code>template&lt;&gt; FactoryHelper&lt;ClassName##Factory&gt;::FactoryHelper (int) { std::cout &lt;&lt; \"object initialized!\" &lt;&lt; std::endl; }\\\n</code></pre>\n<p>Here is the complete working example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace my_lib\n{\n    template&lt;typename&gt; struct FactoryBase { };\n    template &lt;typename T&gt;\n    struct FactoryHelper\n    {\n        FactoryHelper (int);\n        static FactoryHelper&lt;T&gt; _helper;\n    };\n}\n\n#define CREATE_FACTORY(ClassName)\\\nnamespace my_lib\\\n{\\\n    class ClassName##Factory;\\\n    template&lt;&gt; FactoryHelper&lt;ClassName##Factory&gt;::FactoryHelper (int) { std::cout &lt;&lt; \"object initialized!\" &lt;&lt; std::endl; }\\\n    template&lt;&gt; FactoryHelper&lt;ClassName##Factory&gt; FactoryHelper&lt;ClassName##Factory&gt;::_helper(0);\\\n    struct ClassName##Factory : public FactoryBase&lt;ClassName&gt; {\\\n    };\\\n} \n\nstruct UnitTestExample {\n};\n\nCREATE_FACTORY(UnitTestExample);\n\nint main(int argc,char **argv)\n{\n  return 0;\n}\n</code></pre>\n<p>That said, using some of the suggestions in the other answers may be a better design decision.</p>\n<p>More information on the explicit specialization declaration vs. definition can be found here: <a href=\"https://stackoverflow.com/questions/2342550/static-member-initialization-for-specialized-template-class\">static member initialization for specialized template class</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-03-04T19:23:21.853", "Score": "4", "CreationDate": "2012-03-03T21:56:30.657", "ParentId": "9549714", "CommentCount": "2", "OwnerUserId": "951890", "LastEditDate": "2017-05-23T12:06:49.487"}, "bq_ids": {"n4140": {"so_9549714_9549714_0": {"length": 42, "quality": 0.9333333333333333, "section_id": 234}}, "n3337": {"so_9549714_9549714_0": {"length": 42, "quality": 0.9333333333333333, "section_id": 227}}, "n4659": {"so_9549714_9549714_0": {"length": 41, "quality": 0.9111111111111111, "section_id": 244}}}, "9550133": {"Id": "9550133", "PostTypeId": "2", "Body": "<p>Instead of a static member (you have to create somewhere), consider the possibility of a static variable into a static function, like</p>\n<pre><code>namespace my_lib\n{\n    template &lt;typename T&gt;\n    struct FactoryHelper\n    {\n        FactoryHelper () { ... };\n        static FactoryHelper&lt;T&gt;&amp; helper()\n        { static FactoryHelper&lt;T&gt; h; return h; }\n    };\n}\n</code></pre>\n<p>Not the same as you are asking, but no need of out-of-band initializations.</p>\n", "LastActivityDate": "2012-03-03T21:42:17.447", "CommentCount": "0", "CreationDate": "2012-03-03T21:42:17.447", "ParentId": "9549714", "Score": "0", "OwnerUserId": "924727"}, "9554154": {"Id": "9554154", "PostTypeId": "2", "Body": "<p>Well, first of all thanks a lot for both the suggestions and the explanations. I added the solutions you gave me to the code and didn't work. Then I tried your solutions as stand-alone programs and worked. </p>\n<p>The difference is that the classes I'm implementing are compiled and then linked to the executable as a static libraries. If I compile the code all together (without using static libraries) then it works. </p>\n<p>I found the response here: <a href=\"https://stackoverflow.com/questions/1804606/static-initialization-and-destruction-of-a-static-librarys-globals-not-happenin\">Static initialization and destruction of a static library's globals not happening with g++</a></p>\n<p>The .o files are not linked unless they are referenced from the main application. I have used the <code>ld</code> option <code>-Wl,--whole-archive</code> and now it works.</p>\n<pre><code>-Wl,--whole-archive -lmy_static_library ... -Wl,--no-whole-archive\n</code></pre>\n<p>Related to the second question, I still don't understand why I have to specify a dummy parameter in the constructor.</p>\n<pre><code>template&lt;&gt; FactoryHelper&lt;ClassName##Factory&gt; FactoryHelper&lt;ClassName##Factory&gt;::_helper(0);\\\n</code></pre>\n<p>Rather than doing this:</p>\n<pre><code>emplate&lt;&gt; FactoryHelper&lt;ClassName##Factory&gt; FactoryHelper&lt;ClassName##Factory&gt;::_helper = FactoryHelper&lt;ClassName##Factory&gt;();\\\n</code></pre>\n<p>Thanks!</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-03-04T10:30:48.303", "Score": "0", "CreationDate": "2012-03-04T10:30:48.303", "ParentId": "9549714", "CommentCount": "2", "OwnerUserId": "1192525", "LastEditDate": "2017-05-23T11:48:44.187"}});