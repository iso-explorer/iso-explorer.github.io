post_cb({"9646297": {"ViewCount": "5408", "Body": "<p>I am writing a hash function for my object. I already can hash containers, and combine hashes, thanks to <a href=\"https://stackoverflow.com/questions/6899392/generic-hash-function-for-all-stl-containers\">Generic Hash function for all STL-containers</a>. But my classes also have enums. Of course I can create a hash function for every enum, but it does not seem like a good idea. Is it possible to create some generic specification for <code>std::hash</code>, so that it could be applied to every enum? Something like that, using <code>std::enable_if</code> and <code>std::is_enum</code></p>\n<pre><code>namespace std {\n  template &lt;class E&gt;\n  class hash&lt;typename std::enable_if&lt;std::is_enum&lt;E&gt;::value, E&gt;::type&gt; {\n  public:\n    size_t operator()( const E&amp; e ) const {\n      return std::hash&lt;std::underlying_type&lt;E&gt;::type&gt;()( e );\n    }\n  };\n};\n</code></pre>\n<p>PS. This code does not compile </p>\n<pre><code>error: template parameters not used in partial specialization:\nerror:         \u2018E\u2019\n</code></pre>\n", "AcceptedAnswerId": "21029900", "Title": "C++11 Hash function for any enum type", "CreationDate": "2012-03-10T12:08:37.530", "Id": "9646297", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:30:37.143", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-20T21:24:46.560", "Score": "9", "OwnerUserId": "170230", "Tags": "<c++><templates><enums><c++11><hash-function>", "AnswerCount": "4"}, "21029900": {"Id": "21029900", "PostTypeId": "2", "Body": "<p>It is possible, by moving the specialization failure out of the template argument list so that parameter deduction of E can still occur.  For instance, you could have it occur on a using declaration:</p>\n<pre><code>namespace std {\n  template&lt;class E&gt;class hash {\n    using sfinae = typename std::enable_if&lt;std::is_enum&lt;E&gt;::value, E&gt;::type;\n  public:\n    size_t operator()(const E&amp;e) const {\n      return std::hash&lt;typename std::underlying_type&lt;E&gt;::type&gt;()(e);\n    }\n  };\n};\n</code></pre>\n<p>(I usually use the type name <code>sfinae</code> so that I remember why it's there.)</p>\n<p>Demo code:</p>\n<pre><code>#include &lt;functional&gt;\n\nnamespace std {\n  template&lt;class E&gt;class hash {\n    using sfinae = typename std::enable_if&lt;std::is_enum&lt;E&gt;::value, E&gt;::type;\n  public:\n    size_t operator()(const E&amp;e) const {\n      return std::hash&lt;typename std::underlying_type&lt;E&gt;::type&gt;()(e);\n    }\n  };\n};\n\nenum foo { BAR, BAZ };\nclass quux {};\n\nint main() {\n  // Compiles.\n  std::hash&lt;foo&gt;foo_hash;\n  // Gives a compile-time error: no type named \u2018type\u2019 in \u2018struct\n  // std::enable_if&lt;false, quux&gt;\u2019.\n  std::hash&lt;quux&gt;quux_hash;\n  return 0;\n}\n</code></pre>\n", "LastEditorUserId": "1304126", "LastActivityDate": "2014-01-09T20:06:45.707", "Score": "4", "CreationDate": "2014-01-09T19:56:52.150", "ParentId": "9646297", "CommentCount": "6", "OwnerUserId": "1304126", "LastEditDate": "2014-01-09T20:06:45.707"}, "9646333": {"Id": "9646333", "PostTypeId": "2", "Body": "<p>Your <code>E</code> parameter cannot be deduced, because the compiler cannot know that your <code>enable_if&lt;...&gt;::type</code> ends up denoting <code>E</code> again (and in fact, there are some specializations of it that by design don't do that!). It's called a \"non-deduced context\" for <code>E</code>.</p>\n<p>If <code>hash</code> has only one parameter, there is no way (that I am aware of) to SFINAE out your partial specialization. </p>\n", "LastActivityDate": "2012-03-10T12:14:34.907", "CommentCount": "0", "CreationDate": "2012-03-10T12:14:34.907", "ParentId": "9646297", "Score": "10", "OwnerUserId": "34509"}, "bq_ids": {"n4140": {"so_9646297_23311961_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 6299}, "so_9646297_23311961_2": {"length": 19, "quality": 0.95, "section_id": 6299}}, "n3337": {"so_9646297_23311961_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 6056}, "so_9646297_23311961_2": {"length": 19, "quality": 0.95, "section_id": 6056}}, "n4659": {"so_9646297_23311961_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 7808}, "so_9646297_23311961_2": {"length": 19, "quality": 0.95, "section_id": 7808}}}, "23311961": {"Id": "23311961", "PostTypeId": "2", "Body": "<p>What you're trying to do is prohibited by the standard.</p>\n<blockquote>\n<p id=\"so_9646297_23311961_0\">[namespace.std]</p>\n<p id=\"so_9646297_23311961_1\">The behavior of a C++ program is unde\ufb01ned if it adds declarations or\n  de\ufb01nitions to namespace std or to a namespace within namespace std\n  unless otherwise specified.</p>\n<p id=\"so_9646297_23311961_2\">A program may add a template specialization for any\n  standard library template to namespace std only if the declaration\n  depends on a user-de\ufb01ned type and the specialization meets the\n  standard library requirements for the original template and is not\n  explicitly prohibited.</p>\n</blockquote>\n<p>So you can certainly pursue some of the ideas in these answers, but you can't call it std::hash.  Defining your own 'enum_hash' template seems like a good idea.</p>\n", "LastActivityDate": "2014-04-26T14:01:02.900", "CommentCount": "0", "CreationDate": "2014-04-26T14:01:02.900", "ParentId": "9646297", "Score": "2", "OwnerUserId": "1639113"}, "17622468": {"Id": "17622468", "PostTypeId": "2", "Body": "<p>If you're willing to use macros, you could dump the correct std::hash specialization next to your enum declaration.</p>\n<p>Otherwise, the only way I've found to easily hash enum values is to generalize the hash type:</p>\n<pre><code>struct enum_hash\n{\n    template &lt;typename T&gt;\n    inline\n    typename std::enable_if&lt;std::is_enum&lt;T&gt;::value, std::size_t&gt;::type\n    operator ()(T const value) const\n    {\n        return static_cast&lt;std::size_t&gt;(value);\n    }\n};\n</code></pre>\n<p>and using it that way:</p>\n<pre><code>enum class E { a, b, c };\nstd::unordered_map&lt;E, std:string, enum_hash&gt; map;\nmap[E::a] = \"a\";\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-20T21:24:46.560", "Score": "4", "CreationDate": "2013-07-12T19:17:58.137", "ParentId": "9646297", "CommentCount": "0", "OwnerUserId": "734923", "LastEditDate": "2014-11-20T21:24:46.560"}});