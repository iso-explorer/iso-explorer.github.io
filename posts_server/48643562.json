post_cb({"48643600": {"Id": "48643600", "PostTypeId": "2", "Body": "<p>A class definition is complete (that is, <em>a class is considered defined</em>) after the closing brace <code>}</code>.<br>\nIn your case, when you try to use <code>A</code> with <code>std::is_base_of</code>, <code>A</code> isn't fully defined yet:</br></p>\n<pre><code>class A : public Base {\n    // no closing brace for A yet, thus A isn't fully defined here\n    static_assert(std::is_base_of&lt;Base, A&gt;::value, \"\");\n};\n</code></pre>\n<p>On the other side, <code>std::is_base_of</code> requires types that are completely defined to work.<br>\nThus the error.</br></p>\n<hr>\n<p>As a workaround, you can put the assert in the destructor of <code>A</code>:</p>\n<pre><code>class A : public Base {\n    ~A() {\n        static_assert(std::is_base_of&lt;Base, A&gt;::value, \"\");\n    }\n};\n</code></pre>\n<p>In fact, a class type is considered fully defined in its member functions' bodies.</p>\n<hr>\n<p>See <a href=\"http://eel.is/c++draft/class#mem-6\" rel=\"nofollow noreferrer\">here</a> for more details (emphasis mine):</p>\n<blockquote>\n<p id=\"so_48643562_48643600_0\">A class is considered a completely-defined object type ([basic.types]) (or complete type) at the closing } of the class-specifier. <strong>Within the class member-specification, the class is regarded as complete within function bodies</strong>, default arguments, noexcept-specifiers, and default member initializers (including such things in nested classes). Otherwise it is regarded as incomplete within its own class member-specification.</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "4987285", "LastActivityDate": "2018-02-06T16:47:35.333", "Score": "14", "CreationDate": "2018-02-06T12:56:20.950", "ParentId": "48643562", "CommentCount": "2", "OwnerUserId": "4987285", "LastEditDate": "2018-02-06T16:47:35.333"}, "bq_ids": {"n4140": {"so_48643562_48643600_0": {"length": 32, "quality": 0.8648648648648649, "section_id": 5862}, "so_48643562_48643654_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 4716}}, "n3337": {"so_48643562_48643600_0": {"length": 32, "quality": 0.8648648648648649, "section_id": 5632}}, "n4659": {"so_48643562_48643600_0": {"length": 36, "quality": 0.972972972972973, "section_id": 7345}, "so_48643562_48643654_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 6114}}}, "48643654": {"Id": "48643654", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/types/is_base_of\" rel=\"nofollow noreferrer\">The doc page</a> for <code>std::is_base_of</code> yields:</p>\n<blockquote>\n<p id=\"so_48643562_48643654_0\">If both Base and Derived are non-union class types, and they are not\n  the same type (ignoring cv-qualification), <strong>Derived shall be a complete\n  type</strong>; otherwise the behavior is undefined.</p>\n</blockquote>\n<p>The definition for a class is complete after you close its scope with <code>}</code>. Thus, in your case, an error is generated.</p>\n<hr>\n<p>Note, that <a href=\"http://en.cppreference.com/w/cpp/language/static_assert\" rel=\"nofollow noreferrer\">static assertion</a> can appear in block <strong>or</strong> namespace / file scope. So you can move it outside the class' body or, if you don't want to have it in your header, move to the implementation file.</p>\n</hr>", "LastEditorUserId": "2812864", "LastActivityDate": "2018-02-06T16:08:18.903", "Score": "7", "CreationDate": "2018-02-06T12:59:28.530", "ParentId": "48643562", "CommentCount": "1", "OwnerUserId": "2812864", "LastEditDate": "2018-02-06T16:08:18.903"}, "48643562": {"ViewCount": "506", "Body": "<p>I completely see why this <strong>cannot</strong> work:</p>\n<pre><code>class Base {};\nclass A;\nstatic_assert(std::is_base_of&lt;Base, A&gt;::value, \"\");\n</code></pre>\n<p>Because there is no information about a 'class hierarchy', but...\nWhy cannot the following work?</p>\n<pre><code>class Base {};\nclass A : public Base {\n    static_assert(std::is_base_of&lt;Base, A&gt;::value, \"\");\n};\n(produce: an undefined class is not allowed as an argument to compiler intrinsic type trait)\n</code></pre>\n<p>The type 'A' is still not complete at line with static_assert (according to definition of this concept). However - the compiler already knows the 'class hierarchy' and could provide the answer for this.</p>\n<p>Of course - this static_assert could be moved to destructor or whatever to fix this issue, but there are situations where it cannot be done, for example:</p>\n<pre><code>class Base {};\n\ntemplate&lt;typename T&gt;\nstruct type_of {\n    static_assert(std::is_base_of&lt;Base, T&gt;::value, \"T is not derived from Base\");\n    using type = int; //* Some normal type in real use\n};\n\nclass A : public Base {\npublic:\n    type_of&lt;A&gt;::type foo(); // Will not compile\n};\n</code></pre>\n<p>Should it not be allowed?</p>\n", "Title": "Why can't \"is_base_of\" be used inside a class declaration (incomplete type)?", "CreationDate": "2018-02-06T12:54:45.833", "LastActivityDate": "2018-02-06T18:49:44.557", "CommentCount": "7", "LastEditDate": "2018-02-06T18:49:44.557", "PostTypeId": "1", "LastEditorUserId": "63550", "Id": "48643562", "Score": "11", "OwnerUserId": "2561762", "Tags": "<c++><static-assert><incomplete-type>", "AnswerCount": "2"}});