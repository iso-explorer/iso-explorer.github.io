post_cb({"bq_ids": {"n4140": {"so_38176000_38176030_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5392}}, "n3337": {"so_38176000_38176030_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5186}}, "n4659": {"so_38176000_38176030_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 4795}}}, "38176030": {"Id": "38176030", "PostTypeId": "2", "Body": "<p>It is true that, historically, you could not take the address of a <code>register</code> variable.</p>\n<p>This is now just a historical footnote. The current C++ standard states that the <code>register</code> keyword </p>\n<blockquote>\n<p id=\"so_38176000_38176030_0\">... specifies that the named variable has automatic storage duration\n  (3.7.3).</p>\n</blockquote>\n<p>In other words, it means ...nothing much. The restriction that an address cannot be taken of a <code>register</code> variable is no longer a part of the current C++ standard.</p>\n", "LastActivityDate": "2016-07-04T02:04:42.947", "Score": "5", "CreationDate": "2016-07-04T02:04:42.947", "ParentId": "38176000", "CommentCount": "0", "OwnerUserId": "3943312"}, "38176000": {"ViewCount": "186", "Body": "<p>Cited from the book \"Thinking in c++\" the section about register variable: \"There are restrictions to the use of register variables. You cannot take or compute the address of a register variable. A register variable can only be declared within a block (you cannot have global or static register variables).\"</p>\n<p>So I wrote this piece of program to test:</p>\n<pre><code>int global = 2;\n// error\n// register int global2 = 3;\n\nint main() {\n    register int local2 = 2;\n    cout &lt;&lt; local2 &lt;&lt; \" \" &lt;&lt; &amp;local2 &lt;&lt; endl;\n}\n</code></pre>\n<p>However g++ generates no error and the address of local2 is printed out. So why I can take the address with no error?</p>\n", "Title": "why I can take address of register variable?", "CreationDate": "2016-07-04T01:58:41.757", "LastActivityDate": "2016-07-04T02:51:56.313", "CommentCount": "7", "LastEditDate": "2016-07-04T02:29:57.727", "PostTypeId": "1", "LastEditorUserId": "379897", "Id": "38176000", "Score": "4", "OwnerUserId": "2561007", "Tags": "<c++>", "AnswerCount": "2"}, "38176018": {"Id": "38176018", "PostTypeId": "2", "Body": "<p>g++ is choosing not to follow your <code>register</code> declaration.  It does not have to, and in this case may either be choosing to ignoring it, or smart enough to turn it off because you take the address of the variable.</p>\n<p>Long ago we tried to write assembly language in C, and we knew far too much about how many registers our processors had, and thought we were smarter than the compilers of that age at allocating CPU resources.</p>\n<p>We have given up that notion, as processors have become far more complex, the compilers have become far more advanced (on a modern intel processor the load instruction itself is turing complete), and our wetware has remained essentially the same.</p>\n", "LastEditorUserId": "153891", "LastActivityDate": "2016-07-04T02:51:56.313", "Score": "1", "CreationDate": "2016-07-04T02:01:45.697", "ParentId": "38176000", "CommentCount": "1", "LastEditDate": "2016-07-04T02:51:56.313", "OwnerUserId": "153891"}});