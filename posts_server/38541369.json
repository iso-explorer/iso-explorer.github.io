post_cb({"bq_ids": {"n4140": {"so_38541369_38541434_1": {"length": 18, "quality": 1.0, "section_id": 466}, "so_38541369_38541434_2": {"length": 24, "quality": 0.96, "section_id": 452}, "so_38541369_38541434_3": {"length": 18, "quality": 1.0, "section_id": 468}, "so_38541369_38541434_0": {"length": 24, "quality": 0.96, "section_id": 451}}, "n3337": {"so_38541369_38541434_2": {"length": 24, "quality": 0.96, "section_id": 443}, "so_38541369_38541434_1": {"length": 18, "quality": 1.0, "section_id": 457}, "so_38541369_38541434_0": {"length": 24, "quality": 0.96, "section_id": 442}, "so_38541369_38541434_3": {"length": 18, "quality": 1.0, "section_id": 459}}, "n4659": {"so_38541369_38541434_2": {"length": 24, "quality": 0.96, "section_id": 475}, "so_38541369_38541434_1": {"length": 18, "quality": 1.0, "section_id": 489}, "so_38541369_38541434_0": {"length": 24, "quality": 0.96, "section_id": 474}, "so_38541369_38541434_3": {"length": 18, "quality": 1.0, "section_id": 491}}}, "38541434": {"Id": "38541434", "PostTypeId": "2", "Body": "<p>The templated version is not a copy constructor. According to the standard \u00a712.8[class.copy]/2 we have that:</p>\n<blockquote>\n<p id=\"so_38541369_38541434_0\">A non-template constructor for class X is a copy constructor if its first parameter is of type X&amp;, const X&amp;, volatile X&amp; or const volatile X&amp;, and either there are no other parameters or else all other parameters have default arguments (8.3.6).</p>\n</blockquote>\n<p>And similarly, the templated version is also not a copy assignment operator, according to \u00a712.8[class.copy]/17:</p>\n<blockquote>\n<p id=\"so_38541369_38541434_1\">A user-declared copy assignment operator X::operator= is a non-static non-template member function of class X with exactly one parameter of type X, X&amp;, const X&amp;, volatile X&amp; or const volatile X&amp;.</p>\n</blockquote>\n<p>The same holds true for move constructors (at \u00a712.8[class.copy]/3):</p>\n<blockquote>\n<p id=\"so_38541369_38541434_2\">A non-template constructor for class X is a move constructor if its first parameter is of type X&amp;&amp;, const X&amp;&amp;, volatile X&amp;&amp;, or const volatile X&amp;&amp;, and either there are no other parameters or else all other parameters have default arguments (8.3.6).</p>\n</blockquote>\n<p>and move assignment operators, at \u00a712.8[class.copy]/19:</p>\n<blockquote>\n<p id=\"so_38541369_38541434_3\">A user-declared move assignment operator X::operator= is a non-static non-template member function of class X with exactly one parameter of type X&amp;&amp;, const X&amp;&amp;, volatile X&amp;&amp;, or const volatile X&amp;&amp;.</p>\n</blockquote>\n", "LastEditorUserId": "493122", "LastActivityDate": "2016-07-23T11:53:37.337", "Score": "2", "CreationDate": "2016-07-23T11:46:57.867", "ParentId": "38541369", "CommentCount": "2", "OwnerUserId": "493122", "LastEditDate": "2016-07-23T11:53:37.337"}, "38541369": {"ViewCount": "40", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr\" rel=\"nofollow\">This page</a> shows that <code>std::shared_ptr</code> has a templated and a non-templated version of copy/move constructors ((9) and (10) on the page). Similarly, it also has two versions of copy/move assignment operator (see <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/operator%3D\" rel=\"nofollow\">here</a>).</p>\n<p>Why do we need the non-templated version? Wouldn't the templated version alone suffice?</p>\n", "AcceptedAnswerId": "38541434", "Title": "std::shared_ptr templated vs. non-templated copy/move constructors", "CreationDate": "2016-07-23T11:40:08.097", "Id": "38541369", "CommentCount": "4", "LastEditDate": "2016-07-23T11:53:08.723", "PostTypeId": "1", "LastEditorUserId": "3234803", "LastActivityDate": "2016-07-23T11:53:37.337", "Score": "1", "OwnerUserId": "3234803", "Tags": "<c++><templates><c++11><shared-ptr>", "AnswerCount": "1"}});