post_cb({"39478189": {"ParentId": "39477443", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2016-09-13T20:06:47.173", "Score": "12", "LastEditorUserId": "15168", "LastEditDate": "2017-09-28T14:09:15.797", "Id": "39478189", "OwnerUserId": "1774667", "Body": "<p>First, use <code>std::aligned_storage_t</code>.  That is what it is meant for.</p>\n<p>Second, the exact size and layout of <code>virtual</code> types and their decendants is compiler-determined.  Allocating a derived class in a block of memory then converting the address of that block to a base type may work, but there is no guarantee in the standard it will work.</p>\n<p>In particular, if we have <code>struct A {}; struct B:A{};</code> there is no guarantee <em>unless you are standard layout</em> that a pointer-to-<code>B</code> can be <code>reintepret</code>ed as a pointer-to-<code>A</code> (especially throught a <code>void*</code>).  And classes with <code>virtual</code>s in them are not standard layout.</p>\n<p>So the reinterpretation is undefined behavior.</p>\n<p>We can get around this.</p>\n<pre><code>struct func_vtable {\n  void(*invoke)(void*) = nullptr;\n  void(*destroy)(void*) = nullptr;\n};\ntemplate&lt;class T&gt;\nfunc_vtable make_func_vtable() {\n  return {\n    [](void* ptr){ (*static_cast&lt;T*&gt;(ptr))();}, // invoke\n    [](void* ptr){ static_cast&lt;T*&gt;(ptr)-&gt;~T();} // destroy\n  };\n}\ntemplate&lt;class T&gt;\nfunc_vtable const* get_func_vtable() {\n  static const auto vtable = make_func_vtable&lt;T&gt;();\n  return &amp;vtable;\n}\n\nclass Func{\n  func_vtable const* vtable = nullptr;\n  std::aligned_storage_t&lt; 64 - sizeof(func_vtable const*), sizeof(void*) &gt; data;\n\npublic:\n  Func() = delete;\n  Func(const Func&amp;) = delete;\n\n  template&lt;class F, class dF=std::decay_t&lt;F&gt;&gt;\n  Func(F&amp;&amp; f){\n    static_assert(sizeof(dF) &lt;= sizeof(data), \"\");\n    new(static_cast&lt;void*&gt;(&amp;data)) dF(std::forward&lt;F&gt;(f));\n    vtable = get_func_vtable&lt;dF&gt;();\n  }\n\n  void operator () (){\n    return vtable-&gt;invoke(&amp;data);\n  }\n\n  ~Func(){\n    if(vtable) vtable-&gt;destroy(&amp;data);\n  }\n};\n</code></pre>\n<p>This no longer relies upon pointer conversion guarantees.  It simply requires that <code>void_ptr == new( void_ptr ) T(blah)</code>.</p>\n<p>If you are really worried about strict aliasing, store the return value of the <code>new</code> expression as a <code>void*</code>, and pass that into <code>invoke</code> and <code>destroy</code> instead of <code>&amp;data</code>.  That is going to be beyond reproach: the pointer returned from <code>new</code> <strong>is</strong> the pointer to the newly constructed object.  Access of the <code>data</code> whose lifetime has ended is probably invalid, but it was invalid before as well.</p>\n<p>When objects begin to exist and when they end is relatively fuzzy in the standard.  The latest attempt I have seen to solve this issue is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0137r1.html\" rel=\"nofollow noreferrer\">P0137-R1</a>, where it introduces <code>T* std::launder(T*)</code> to make the aliasing issues go away in an extremely clear manner.</p>\n<p>The storage of the pointer returned by <code>new</code> is the only way I know of that clearly and unambiguously does not run into any object aliasing problems prior to P0137.</p>\n<p>The standard did state:</p>\n<blockquote>\n<p id=\"so_39477443_39478189_0\">If an object of type T is located at an address A, a pointer of type cv T* whose value is the address A is said to point to that object, regardless of how the value was obtained</p>\n</blockquote>\n<p>the question is \"does the new expression actually guarantee that the object is created at the location in question\".  I was unable to convince myself it states so unambiguously.  However, in my own type erasure implementions, I do not store that pointer.</p>\n<p>Practically, the above is going to do much the same as many C++ implementations do with virtual functions tables in simple cases like this, except there is no RTTI created.</p>\n", "LastActivityDate": "2017-09-28T14:09:15.797"}, "39477443": {"CommentCount": "12", "AcceptedAnswerId": "39478189", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-09-13T19:16:19.590", "LastActivityDate": "2017-09-28T14:09:15.797", "LastEditDate": "2017-05-23T12:19:30.250", "ViewCount": "503", "FavoriteCount": "3", "Title": "Small object stack storage, strict-aliasing rule and Undefined Behavior", "Id": "39477443", "Score": "21", "Body": "<p>I am writing a type-erased function wrapper similar to <code>std::function</code>. (Yes, I have seen similar implementations and even the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0288r0.pdf\" rel=\"nofollow noreferrer\">p0288r0</a> proposal, but my use-case is quite narrow and somewhat specialized.). The heavily simplified code below illustrates my current implementation:</p>\n<pre><code>class Func{\n    alignas(sizeof(void*)) char c[64]; //align to word boundary\n\n    struct base{\n        virtual void operator()() = 0;\n        virtual ~base(){}\n    };\n\n    template&lt;typename T&gt; struct derived : public base{\n        derived(T&amp;&amp; t) : callable(std::move(t)) {} \n        void operator()() override{ callable(); }\n        T callable;\n    };\n\npublic:\n    Func() = delete;\n    Func(const Func&amp;) = delete;\n\n    template&lt;typename F&gt; //SFINAE constraints skipped for brevity\n    Func(F&amp;&amp; f){\n        static_assert(sizeof(derived&lt;F&gt;) &lt;= sizeof(c), \"\");\n        new(c) derived&lt;F&gt;(std::forward&lt;F&gt;(f));\n    }\n\n    void operator () (){\n        return reinterpret_cast&lt;base*&gt;(c)-&gt;operator()(); //Warning\n    }\n\n    ~Func(){\n        reinterpret_cast&lt;base*&gt;(c)-&gt;~base();  //Warning\n    }\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/fea4ed50d5cc890c\" rel=\"nofollow noreferrer\">Compiled</a>, GCC 6.1 warns about <a href=\"https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule\">strict-aliasing</a> :</p>\n<pre><code>warning: dereferencing type-punned pointer will break strict-aliasing rules [-Wstrict-aliasing]\n         return reinterpret_cast&lt;T*&gt;(c)-&gt;operator()();\n</code></pre>\n<p>I also know about the <a href=\"https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule\">strict-aliasing rule</a>. On the other hand, I currently do not know of a better way to make use of small object stack optimization. Despite the warnings, all my tests passes on GCC and Clang, (and an extra level of indirection prevents GCC's warning). My questions are:</p>\n<ul>\n<li>Will I eventually get burned ignoring the warning for this case?</li>\n<li>Is there a better way for in-place object creation?</li>\n</ul>\n<p>See full example: <a href=\"http://coliru.stacked-crooked.com/a/fea4ed50d5cc890c\" rel=\"nofollow noreferrer\">Live on Coliru</a></p>\n", "Tags": "<c++><gcc><c++14>", "OwnerUserId": "1621391", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_39477443_39484401_0": {"section_id": 41, "quality": 1.0, "length": 15}, "so_39477443_39478189_0": {"section_id": 7223, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_39477443_39484401_0": {"section_id": 38, "quality": 1.0, "length": 15}, "so_39477443_39478189_0": {"section_id": 6967, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_39477443_39484401_0": {"section_id": 41, "quality": 1.0, "length": 15}, "so_39477443_39478189_0": {"section_id": 8732, "quality": 0.5294117647058824, "length": 9}}}, "39484401": {"ParentId": "39477443", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2016-09-14T07:07:13.397", "Score": "2", "LastEditorUserId": "1116364", "LastEditDate": "2016-09-14T07:45:05.263", "Id": "39484401", "OwnerUserId": "1116364", "Body": "<p>The other answer is basically rebuilding what most compilers do under the hood. When you store the pointer returned by the placement new, then there's no need to manually build vtables\n:</p>\n<pre><code>class Func{    \n    struct base{\n        virtual void operator()() = 0;\n        virtual ~base(){}\n    };\n\n    template&lt;typename T&gt; struct derived : public base{\n        derived(T&amp;&amp; t) : callable(std::move(t)) {} \n        void operator()() override{ callable(); }\n        T callable;\n    };\n\n    std::aligned_storage_t&lt;64 - sizeof(base *), sizeof(void *)&gt; data;\n    base * ptr;\n\npublic:\n    Func() = delete;\n    Func(const Func&amp;) = delete;\n\n    template&lt;typename F&gt; //SFINAE constraints skipped for brevity\n    Func(F&amp;&amp; f){\n        static_assert(sizeof(derived&lt;F&gt;) &lt;= sizeof(data), \"\");\n        ptr = new(static_cast&lt;void *&gt;(&amp;data)) derived&lt;F&gt;(std::forward&lt;F&gt;(f));\n    }\n\n    void operator () (){\n        return ptr-&gt;operator()();\n    }\n\n    ~Func(){\n        ptr-&gt;~base();\n    }\n};\n</code></pre>\n<p>Going from <code>derived&lt;T&gt; *</code> to <code>base *</code> is perfectly valid (N4431 \u00a74.10/3):</p>\n<blockquote>\n<p id=\"so_39477443_39484401_0\">A prvalue of type \u201cpointer to cv D\u201d, where D is a class type, can be converted to a prvalue of type \u201cpointer\n  to cv B\u201d, where B is a base class (Clause 10) of D. [..]</p>\n</blockquote>\n<p>And since the respective member functions are virtual, calling them through the base pointer actually calls the respective functions in the derived class.</p>\n", "LastActivityDate": "2016-09-14T07:45:05.263"}, "39477623": {"ParentId": "39477443", "PostTypeId": "2", "CommentCount": "22", "CreationDate": "2016-09-13T19:28:37.183", "Score": "6", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:19:30.250", "Id": "39477623", "OwnerUserId": "567292", "Body": "<p>The better option is to use the Standard-provided facility for aligned storage for object creation, which is called <a href=\"http://en.cppreference.com/w/cpp/types/aligned_storage\" rel=\"nofollow noreferrer\"><code>aligned_storage</code></a>:</p>\n<pre><code>std::aligned_storage_t&lt;64, sizeof(void*)&gt; c;\n\n// ...\nnew(&amp;c) F(std::forward&lt;F&gt;(f));\nreinterpret_cast&lt;T*&gt;(&amp;c)-&gt;operator()();\nreinterpret_cast&lt;T*&gt;(&amp;c)-&gt;~T();\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/c1bf7f88115e1e98\" rel=\"nofollow noreferrer\">Example.</a></p>\n<p>If available, you should use <code>std::launder</code> to wrap your <code>reinterpret_cast</code>s: <a href=\"https://stackoverflow.com/questions/39382501/what-is-the-purpose-of-stdlaunder\">What is the purpose of std::launder?</a>; if <code>std::launder</code> is not available you can assume that your compiler is pre-P0137 and the <code>reinterpret_cast</code>s are sufficient per the \"points to\" rule (<strong>[basic.compound]</strong>/3). You can test for <code>std::launder</code> using <code>#ifdef __cpp_lib_launder</code>; <a href=\"http://coliru.stacked-crooked.com/a/c4c2a9a51752177e\" rel=\"nofollow noreferrer\">example</a>.</p>\n<p>Since this is a Standard facility, you are guaranteed that if you use it in accordance with the library description (i.e. as above) then there is no danger of getting burned.</p>\n<p>As a bonus, this will also ensure that any compiler warnings are suppressed.</p>\n<p>One danger not covered by the original question is that you're casting the storage address to a polymorphic base type of your derived type.  This is only OK if you ensure that the polymorphic base has the same address (<strong>[ptr.launder]</strong>/1: \"An object <em><code>X</code></em> that is within its lifetime [...] is located at the address <em><code>A</code></em>\") as the complete object at construction time, as this is not guaranteed by the Standard (since a polymorphic type is not standard-layout). You can check this with an <code>assert</code>:</p>\n<pre><code>    auto* p = new(&amp;c) derived&lt;F&gt;(std::forward&lt;F&gt;(f));\n    assert(static_cast&lt;base*&gt;(p) == std::launder(reinterpret_cast&lt;base*&gt;(&amp;c)));\n</code></pre>\n<p>It would be cleaner to use non-polymorphic inheritance with a manual vtable, as Yakk proposes, as then the inheritance will be standard-layout and the base class subobject is guaranteed to have the same address as the complete object.</p>\n<hr>\n<p>If we look into the implementation of <code>aligned_storage</code>, it is equivalent to your <code>alignas(sizeof(void*)) char c[64]</code>, just wrapped in a <code>struct</code>, and indeed gcc can be shut up by wrapping your <code>char c[64]</code> in a <code>struct</code>; although strictly speaking after P0137 you should use <code>unsigned char</code> rather than plain <code>char</code>. However, this is a rapidly evolving area of the Standard, and this could change in future. If you use the provided facility you have a better guarantee that it will continue to work.</p>\n</hr>", "LastActivityDate": "2016-09-13T20:36:58.017"}});