post_cb({"23827185": {"ParentId": "23827036", "CommentCount": "0", "Body": "<p>They do, see <a href=\"http://en.cppreference.com/w/cpp/utility/tuple/operator_cmp\">operator==,!=,&lt;,&lt;=,&gt;,&gt;=(std::tuple)</a>:</p>\n<blockquote>\n<pre><code>operator==\noperator!=\noperator&lt;\noperator&lt;=\noperator&gt;\noperator&gt;=\n</code></pre>\n<p id=\"so_23827036_23827185_0\">lexicographically compares the values in the tuple </p>\n</blockquote>\n", "OwnerUserId": "412080", "PostTypeId": "2", "Id": "23827185", "Score": "6", "CreationDate": "2014-05-23T10:46:03.073", "LastActivityDate": "2014-05-23T10:46:03.073"}, "23827203": {"ParentId": "23827036", "LastEditDate": "2014-05-23T11:36:50.170", "CommentCount": "0", "CreationDate": "2014-05-23T10:46:59.703", "OwnerUserId": "2567683", "LastEditorUserId": "2567683", "PostTypeId": "2", "Id": "23827203", "Score": "3", "Body": "<p>In <code>20.4.2.7 Relational operators [tuple.rel]</code></p>\n<pre><code>template&lt;class... TTypes, class... UTypes&gt;\nbool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);\n</code></pre>\n<blockquote>\n<p id=\"so_23827036_23827203_0\">Returns: The result of a lexicographical comparison between t and u. The result is defined as:</p>\n</blockquote>\n<pre><code>(bool)(get&lt;0&gt;(t) &lt; get&lt;0&gt;(u)) || (!(bool)(get&lt;0&gt;(u) &lt; get&lt;0&gt;(t)) &amp;&amp; ttail &lt; utail) \n</code></pre>\n<blockquote>\n<p id=\"so_23827036_23827203_1\">where rtail for some tuple r is a tuple containing all but the first element of r. For any two zero-length tuples e and f, e &lt; f returns false.</p>\n</blockquote>\n<p><strong>So no, they don't have an implicit one, they have an explicit</strong></p>\n", "LastActivityDate": "2014-05-23T11:36:50.170"}, "23827036": {"CommentCount": "0", "ViewCount": "262", "CreationDate": "2014-05-23T10:37:47.307", "LastActivityDate": "2014-05-23T11:36:50.170", "Title": "Do tuples have an implicit lexicographical comparison?", "AcceptedAnswerId": "23827185", "PostTypeId": "1", "Id": "23827036", "Score": "5", "Body": "<p>When sorting eg a vector of pairs : </p>\n<pre><code>vector&lt;pair&lt;int, double&gt;&gt; v;\nsort(v.begin(), v.end());\n</code></pre>\n<p>You don't need to specify a sorting criterion to have a sorting based on the lexicographical order of the pairs since, when not elseway specified, a lexicographical comparison applies.  </p>\n<p>Is a similar behaviour standard for tuples as well ? </p>\n<p>In VS2012 this compiles</p>\n<pre><code>vector&lt;tuple&lt;int, double, char&gt;&gt; tv;\nsort(tv.begin(), tv.end());\n</code></pre>\n<p>but is it standard mandated to do so ?</p>\n", "Tags": "<c++><c++11><tuples>", "OwnerUserId": "2567683", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_23827036_23827203_1": {"section_id": 4096, "quality": 0.875, "length": 14}, "so_23827036_23827203_0": {"section_id": 4096, "quality": 0.6666666666666666, "length": 6}}, "n3337": {"so_23827036_23827203_1": {"section_id": 3943, "quality": 0.875, "length": 14}, "so_23827036_23827203_0": {"section_id": 3943, "quality": 0.6666666666666666, "length": 6}}, "n4659": {"so_23827036_23827203_1": {"section_id": 5004, "quality": 0.875, "length": 14}, "so_23827036_23827203_0": {"section_id": 5004, "quality": 0.6666666666666666, "length": 6}}}, "23827239": {"ParentId": "23827036", "LastEditDate": "2014-05-23T10:54:18.647", "CommentCount": "2", "CreationDate": "2014-05-23T10:48:57.327", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "PostTypeId": "2", "Id": "23827239", "Score": "6", "Body": "<p>According to standard [<em>20.4.2.7 Relational operators</em>]: Yes </p>\n<p>Overloaded operator for <code>tuple</code>:</p>\n<pre><code> template&lt;class... TTypes, class... UTypes&gt;\n constexpr bool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, \n const tuple&lt;UTypes...&gt;&amp; u);\n</code></pre>\n<p>Returns: <strong>The result of a lexicographical comparison between t and u.</strong></p>\n<p>The result is de\ufb01ned as: </p>\n<pre><code>(bool)(get&lt;0&gt;(t) &lt; get&lt;0&gt;(u)) ||(!(bool)(get&lt;0&gt;(u) &lt; get&lt;0&gt;(t)) &amp;&amp; ttail &lt; utail)\n</code></pre>\n<p>where <code>rtail</code> for some tuple <code>r</code> is a tuple containing all but the \ufb01rst element of <code>r</code>.\n For any two zero-length tuples <code>e</code> and <code>f</code>, <code>e &lt; f</code> returns <code>false</code>.</p>\n", "LastActivityDate": "2014-05-23T10:54:18.647"}});