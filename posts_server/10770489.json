post_cb({"bq_ids": {"n4140": {"so_10770489_10770661_0": {"length": 16, "quality": 1.0, "section_id": 702}}, "n3337": {"so_10770489_10770661_0": {"length": 16, "quality": 1.0, "section_id": 692}}, "n4659": {"so_10770489_10770661_0": {"length": 16, "quality": 1.0, "section_id": 731}}}, "10770661": {"Id": "10770661", "PostTypeId": "2", "Body": "<p>What are you trying to achieve anyway... does your class have any internal storage at all, or is it only represenatation of number sequence?</p>\n<p>If so, then the problem are operators <code>T &amp;operator*()</code> and <code>T *operator-&gt;()</code> which allow value pointed to by iterator to be changed. But if it's only range class it obviously cannot be edited this way, and you should rather use <code>cons_iterator</code>.</p>\n<p>If your class have an internal storage then your interator should have pointer to it (<code>T* pData_;</code> instead of <code>T pData_;</code>) and then you dont need to remove star in <code>T &amp;operator*()\n</code> which suprisingly was ready for correct version ;) The point is that incrementivg iterator should increment this pointer and incrementing value in your <code>add1</code> function should increment pointed value. Now both operations increment the same variable, so you get those <code>+=2</code>.</p>\n<p>EDIT:</p>\n<p>@DavidRodr\u00edguez-dribeas - You are considering different input iterator categories, which are meant to describe the difference between allowed sequential access (in what sequence elements can be accessed), but described problem is rather that <code>Range</code> class instances are by design constant (at least not possible to be modified using just iterators). I can't see anything against giving it even random access category.</p>\n<p>The only option is to replace iterator with const_iterator everywhere, so that iterated values cannot be modified. Now this is a bit against ISO C++, which divides containers into several categories and for each category it requires <code>begin()</code> and <code>end()</code> to return <code>const_iterator</code> only if container itself is declared <code>const</code>. However I think it is arguable at most that <code>Range</code> class is even container in ISO C++ view, as (according to 23.1.1)</p>\n<blockquote>\n<p id=\"so_10770489_10770661_0\">Containers are objects that store other objects. They control\n  allocation and deallocation of these objects through constructors,\n  destructors, insert and erase operations.</p>\n</blockquote>\n<p>Sice there seem not to be any actual storage of iterated objects in Range class, I think we are out-in-the-wild here, and don't need to comply with standard that much.</p>\n<p>EDIT2:</p>\n<p>Firstly <code>const iterator</code> is NOT the same as <code>const_iterator</code>. The first one is an iterator that cannot be changed (to point to a different value in sequence eg. incremented), and another one allows that, but instead doesn't allow changing pointed value, so <code>(*i)=3</code> would fail.</p>\n<p>Secondly this is how I would have done it:</p>\n<pre><code>template &lt;typename T&gt;\nclass Range {\npublic: \n    class const_iterator;\n    typedef const_iterator iterator; //For stl-compliance - some algorythms use that.\n\n    IntegerRange(T low, T high) : low_(low), high_(high) { assert(low &lt;= high);}\n    const_iterator begin() const { return const_iterator(low_); }\n    const_iterator end() const { return const_iterator(high_); }\nprivate:\n    const T low_;\n    const T high_;\n};\n\ntemplate&lt;typename T&gt;\nclass Range&lt;T&gt;::const_iterator : public std::iterator&lt;std::forward_iterator_tag, T&gt;\n{\npublic:\n\n // default constructor                                                                         \n  const_iterator() : pData_(0)\n  {\n  }\n\n  // constructor from const T&amp;                                                                   \n  const_iterator(const T &amp;pData) : pData_(pData)\n  {\n  }\n\n  // constructor from T&amp;                                                                         \n  const_iterator(T &amp;pData) : pData_(pData)\n  {\n  }\n\n  // operator =                                                                                  \n  const_iterator &amp;operator=(const const_iterator &amp;other)\n  {\n    this-&gt;pData_ = other.pData_;\n    return *this;\n  }\n\n\n  // pre-increment operator                                                                      \n  const_iterator &amp; operator++()\n  {\n    ++(this-&gt;pData_);\n    return *this;\n  }\n  // post-increment operator                                                                     \n  const_iterator operator++(int)\n  {\n    const_iterator temp(*this);\n    this-&gt;operator++();\n    return temp;\n  }\n\n  // operator ==                                                                                 \n  bool operator==(const const_iterator &amp;other) const\n  {\n    return this-&gt;pData_ == other.pData_;\n  }\n\n  // operator !=                                                                                 \n  bool operator!=(const iterator &amp;other) const\n  {\n    return !operator==(other);\n  }\n\n  // operator* r-value                                                                           \n  const T &amp;operator*() const\n  {\n    return (this-&gt;pData_); // had to remove the *                                                \n  }\n\n  // operator-&gt; r-value                                                                          \n  const T *operator-&gt;() const\n  {\n    return &amp;(this-&gt;pData_);\n  }\n\nprivate:\n  T pData_;\n};\n</code></pre>\n<p>You are obviously free to keep the name iterator instead of const_iterator (or use qqwfmnghng as class name) as long as you do keep to const_iterator specification - in this case not providing l-value operators, as those are intended to modify pointed value - what sense would that make?</p>\n", "LastEditorUserId": "455304", "LastActivityDate": "2012-05-27T01:35:14.670", "Score": "0", "CreationDate": "2012-05-26T23:57:55.553", "ParentId": "10770489", "CommentCount": "6", "OwnerUserId": "455304", "LastEditDate": "2012-05-27T01:35:14.670"}, "10770489": {"ViewCount": "848", "Body": "<p>So we know that foreach is something like :</p>\n<pre><code>template&lt;class InputIterator, class Function&gt;\n  Function for_each(InputIterator first, InputIterator last, Function f)\n  {\n    for ( ; first!=last; ++first ) f(*first);\n    return f;\n  }\n</code></pre>\n<p>I have implemented a </p>\n<pre><code>template &lt;typename T&gt;\nclass Range\n</code></pre>\n<p>The problem is that when I use this function with the for_Each :</p>\n<pre><code>static void add1(float &amp;v)\n{\n  ++v;\n}\n</code></pre>\n<p>it go in infinite loop because of first \"!=\" last (it's not first\"&lt;\"last), so how people do when they implemente their own forward iterator to work with for_each ?</p>\n", "AcceptedAnswerId": "10770617", "Title": "Forward Iterator C++ : for_each behavior", "CreationDate": "2012-05-26T23:21:28.670", "Id": "10770489", "CommentCount": "17", "LastEditDate": "2012-05-27T21:41:48.850", "PostTypeId": "1", "LastEditorUserId": "1227265", "LastActivityDate": "2012-05-27T21:41:48.850", "Score": "0", "OwnerUserId": "1227265", "Tags": "<c++><foreach><iterator><forward>", "AnswerCount": "3"}, "10771420": {"Id": "10771420", "PostTypeId": "2", "Body": "<pre><code>#include &lt;assert.h&gt;     // assert\n#include &lt;iterator&gt;     // std::forward_iterator\n#include &lt;utility&gt;      // std::pair\n#include &lt;stddef.h&gt;     // ptrdiff_t, size_t\n\ntypedef size_t          UnsignedSize;\ntypedef ptrdiff_t       Size;\ntypedef Size            Index;\n\ntemplate&lt; class TpValue &gt;\nclass ValueRange\n{\npublic:\n    typedef TpValue     Value;\n\nprivate:\n    Value   first_;\n    Size    span_;\n\npublic:\n    class It\n        : public std::iterator&lt; std::forward_iterator_tag, Value &gt;\n    {\n    friend class ValueRange;\n    private:\n        Value       first_;\n        Index       i_;\n\n        It( Value const first, Index const i )\n            : first_( first )\n            , i_( i )\n        {}\n\n    public:\n        void operator++()           { ++i_; }\n        Value operator*() const     { return first_ + i_; }\n\n        bool operator!=( It const&amp; other ) const\n        { assert( first_ == other.first_ );  return (i_ != other.i_); }\n\n        bool operator&lt;( It const&amp; other ) const\n        { assert( first_ == other.first_ );  return (i_ &lt; other.i_); }\n    };\n\n    Value first() const     { return first_; }\n    Value last() const      { return first_ + span_; }\n\n    It begin() const        { return It( first_, 0 ); }\n    It end() const          { return It( first_, span_ + 1 ); }\n\n    ValueRange( Value const first, Value const last )\n        : first_( first )\n        , span_( Size( last - first ) )\n    {\n        assert( first_ + span_ == last );\n    }\n};\n\n#include &lt;algorithm&gt;    // std::for_each\n#include &lt;iostream&gt;     // std::wcout, std::endl\n\nint main()\n{\n    using namespace std;\n\n    ValueRange&lt; double &gt; const   r( 1.0, 6.0 );\n\n    for_each( r.begin(), r.end(), []( double x )\n    {\n        using std::wcout;       // For Visual C++ 10.0.\n        wcout &lt;&lt; x &lt;&lt; \" \";\n    } );\n    wcout &lt;&lt; endl;\n}\n</code></pre>\n", "LastActivityDate": "2012-05-27T03:20:46.303", "CommentCount": "2", "CreationDate": "2012-05-27T03:20:46.303", "ParentId": "10770489", "Score": "0", "OwnerUserId": "464581"}, "10770617": {"Id": "10770617", "PostTypeId": "2", "Body": "<p>The problem of your approach is that your iterator increment operators do not change the iterator, but rather the stored value. This means that inside the <code>for_each</code> loop, the condition is modified both in the increment operator of the iterator and also through the function.</p>\n", "LastActivityDate": "2012-05-26T23:46:50.783", "CommentCount": "5", "CreationDate": "2012-05-26T23:46:50.783", "ParentId": "10770489", "Score": "4", "OwnerUserId": "36565"}});