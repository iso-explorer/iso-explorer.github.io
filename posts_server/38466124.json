post_cb({"38467507": {"ParentId": "38466124", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_38466124_38467507_0\">Is it safe to assume that <code>-LLONG_MAX</code> (negated <code>LLONG_MAX</code>) belongs to <code>long long</code> range?</p>\n<p id=\"so_38466124_38467507_1\">Is it safe to assume that if <code>LLONG_MIN &lt; -LLONG_MAX</code> then <code>LLONG_MIN == -LLONG_MAX - 1</code>?</p>\n<p id=\"so_38466124_38467507_2\">Is it guaranteed by the Standard or just all actual devices provide either <code>LLONG_MIN == -LLONG_MAX - 1</code> or <code>LLONG_MIN == -LLONG_MAX</code>?</p>\n</blockquote>\n<p><br>\nThose three statements are true in the case the implementation uses one of 2's complement, 1's complement, or sign and magnitude to represent signed integer types. <code>-LLONG_MAX</code> is in the range of <code>long long</code> in all three schemes, and <code>LLONG_MIN</code> is <code>-LLONG_MAX</code> (1's complement, sign and magnitude, and possibly 2's complement) or is <code>-LLONG_MAX-1</code> (possibly 2's complement). 2's complement machines might use that extra value as a trap representation, just as 1's complement and sign and magnitude machines might use negative zero as a trap representation. So the answer to your questions is \"yes\" if the standard mandates that an implementation use one of those schemes.</br></p>\n<p>The C standard (to which the C++ standard defers in many places) mandates either 2's complement, 1's complement, or sign and magnitude:</p>\n<blockquote>\n<p id=\"so_38466124_38467507_3\">C11 <strong>6.2.6.2 Integer types</strong>:</p>\n<p id=\"so_38466124_38467507_4\">If the sign bit is one, the value shall be modified in one of the following ways:</p>\n<p id=\"so_38466124_38467507_5\">\u2014 the corresponding value with sign bit 0 is negated (sign and magnitude);<br>\n   \u2014 the sign bit has the value \u2212(2M ) (two\u2019s complement);<br>\n   \u2014 the sign bit has the value \u2212(2M \u2212 1) (ones\u2019 complement).</br></br></p>\n</blockquote>\n<p>The C++ standard appears to be a bit more open:</p>\n<blockquote>\n<p id=\"so_38466124_38467507_6\">C++14 <strong>3.9.1 Fundamental types:</strong></p>\n<p id=\"so_38466124_38467507_7\">The representations of integral types shall define values by use of a pure binary numeration system<sup>51</sup>. [<em>Example</em>: this International Standard permits 2\u2019s complement, 1\u2019s complement and signed magnitude representations for integral types. \u2014<em>end example</em>]</p>\n</blockquote>\n<p>Footnote 51, which defines what \"a pure binary numeration system\" means, appears to rule out decimal systems, and also offset systems (where 0 isn't all bits zero):</p>\n<blockquote>\n<p id=\"so_38466124_38467507_8\">51) A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin with 1, and are multiplied by successive integral power of 2, except perhaps for the bit with the highest position.</p>\n</blockquote>\n<p>Practically speaking, all that's left are 2's complement, 1's complement, and sign and magnitude: The same schemes mandated by the C standard. I doubt a vendor would touch a machine that uses a new 21st century scheme to represent the integers and  somehow meets the letter of the law of the C++ standard (but hence is noncompliant with C).</p>\n", "OwnerUserId": "774499", "LastEditorUserId": "774499", "LastEditDate": "2016-07-19T20:30:30.323", "Id": "38467507", "Score": "3", "CreationDate": "2016-07-19T20:03:06.953", "LastActivityDate": "2016-07-19T20:30:30.323"}, "38466241": {"ParentId": "38466124", "CommentCount": "4", "Body": "<p>No. The Standard does not prescribe two's complement integer representation.</p>\n<p>That said, the <em>vast majority</em> of C and C++ implementations are on 2's comp machines.</p>\n", "OwnerUserId": "2706707", "PostTypeId": "2", "Id": "38466241", "Score": "0", "CreationDate": "2016-07-19T18:44:57.163", "LastActivityDate": "2016-07-19T18:44:57.163"}, "38466124": {"CommentCount": "4", "AcceptedAnswerId": "38467507", "CreationDate": "2016-07-19T18:38:16.623", "LastActivityDate": "2016-07-19T20:30:30.323", "PostTypeId": "1", "ViewCount": "120", "FavoriteCount": "0", "Title": "What are C++ Standard guarantees on relation between min and max values of signed integer types?", "Id": "38466124", "Score": "6", "Body": "<p>Is it safe to assume that <code>-LLONG_MAX</code> (negated <code>LLONG_MAX</code>) belongs to <code>long long</code> range?</p>\n<p>Is it safe to assume that if <code>LLONG_MIN &lt; -LLONG_MAX</code> then <code>LLONG_MIN == -LLONG_MAX - 1</code>?</p>\n<p>Is it guaranteed by the Standard or just all actual devices provide either <code>LLONG_MIN == -LLONG_MAX - 1</code> or <code>LLONG_MIN == -LLONG_MAX</code>?</p>\n", "Tags": "<c++><integer><max><standards><min>", "OwnerUserId": "3283370", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_38466124_38467507_8": {"section_id": 7216, "quality": 1.0, "length": 21}, "so_38466124_38467507_7": {"section_id": 7216, "quality": 0.75, "length": 18}}, "n3337": {"so_38466124_38467507_8": {"section_id": 6960, "quality": 1.0, "length": 21}, "so_38466124_38467507_7": {"section_id": 6960, "quality": 0.75, "length": 18}}, "n4659": {"so_38466124_38467507_8": {"section_id": 8725, "quality": 1.0, "length": 21}, "so_38466124_38467507_7": {"section_id": 8725, "quality": 0.75, "length": 18}}}});