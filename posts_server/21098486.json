post_cb({"21100214": {"ParentId": "21098486", "CommentCount": "1", "Body": "<p>This appears to be a bug in the MSVC preprocessor.  The good news is that depending on how picky you are with your output, you can work around the issue by putting a space after the R or L.</p>\n<pre><code>A(L ?p:q), // \"L ?p:q\"\n</code></pre>\n", "OwnerUserId": "1273178", "PostTypeId": "2", "Id": "21100214", "Score": "3", "CreationDate": "2014-01-13T19:56:53.737", "LastActivityDate": "2014-01-13T19:56:53.737"}, "21100313": {"ParentId": "21098486", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><b>Update</b></p>\n<p>Looks like the bug report was marked as a duplicate of <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/813595/c-preprocessor-incorrectly-handling-l-character\" rel=\"nofollow\">this one</a> which has an update which says:</p>\n<blockquote>\n<p id=\"so_21098486_21100313_0\">A fix for this issue has been checked into the compiler sources. The fix should show up in the next major release of Visual C++.</p>\n</blockquote>\n<p><b>Original</b></p>\n<p>As remyabel pointed out this is a <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/813514/c-preprocessor-stringification-stringizing-operator-bug\" rel=\"nofollow\">reported bug</a>. Neither <code>gcc</code> nor <code>clang</code> produce this results and the <a href=\"http://msdn.microsoft.com/en-us/library/7e3a913x.aspx\" rel=\"nofollow\">stringizing operator #</a> according to <code>Visual Studios</code> documents, these are the following replacements (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_21098486_21100313_1\">White space preceding the first token of the actual argument and following the last token of the actual argument is ignored. Any white space between the tokens in the actual argument is reduced to a single white space in the resulting string literal. Thus, if a comment occurs between two tokens in the actual argument, it is reduced to a single white space. The resulting string literal is automatically concatenated with any adjacent string literals from which it is separated only by white space.</p>\n<p id=\"so_21098486_21100313_2\">Further, if a character contained in the argument usually requires an escape sequence when used in a string literal (for example, the quotation mark (\") or backslash () character), the necessary escape backslash is automatically inserted before the character. </p>\n</blockquote>\n<p>which corresponds with the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">C++ draft standard</a> section <code>16.3.2</code> <em>The # operator</em> which says:</p>\n<blockquote>\n<p id=\"so_21098486_21100313_3\">If, in the replacement list, a parameter is immediately preceded by a # preprocessing token, both are replaced by a single character string literal preprocessing token that contains the spelling of the preprocessing token sequence for the corresponding\n  argument. Each occurrence of white space between the argument\u2019s preprocessing tokens becomes a single space character in the character string literal. White space before the first preprocessing token and after the last preprocessing token comprising the argument is deleted. Otherwise, the original spelling of each preprocessing token in the argument is retained in the character string literal, except for special handling for producing the spelling of string literals and character literals: a \\ character is inserted before each \" and \\ character of a character literal or string literal (including the delimiting \" characters).</p>\n</blockquote>\n<p>The only thing that relates <code>R</code> and <code>L</code> with respect to <em>C++11</em> is that they have special meaning with <a href=\"http://en.cppreference.com/w/cpp/language/string_literal\" rel=\"nofollow\">string literals</a> but I don't see how that should effect this case. </p>\n<p>It also looks like <code>L\\</code> and <code>R\\</code> also produce the same issue.</p>\n<p>They do document one <a href=\"http://msdn.microsoft.com/en-us/library/8xsbhyzw.aspx\" rel=\"nofollow\">non-compliant issue</a> and it says:</p>\n<blockquote>\n<p id=\"so_21098486_21100313_4\">Visual C++ does not behave correctly when the # (stringize) operator is used with strings that include escape sequences. In this situation, the compiler will generate Compiler Error C2017.</p>\n</blockquote>\n<p>which does not cover this case.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-02-07T03:48:05.740", "Id": "21100313", "Score": "20", "CreationDate": "2014-01-13T20:01:47.477", "LastActivityDate": "2014-02-07T03:48:05.740"}, "bq_ids": {"n4140": {"so_21098486_21100313_3": {"section_id": 526, "quality": 1.0, "length": 82}}, "n3337": {"so_21098486_21100313_3": {"section_id": 517, "quality": 1.0, "length": 82}}, "n4659": {"so_21098486_21100313_3": {"section_id": 547, "quality": 1.0, "length": 82}}}, "21098486": {"CommentCount": "10", "AcceptedAnswerId": "21100313", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-01-13T18:19:21.747", "LastActivityDate": "2014-02-07T03:48:05.740", "LastEditDate": "2014-01-14T01:37:53.790", "ViewCount": "1399", "FavoriteCount": "6", "Title": "What's special about R and L in the C++ preprocessor?", "Id": "21098486", "Score": "47", "Body": "<p>I ran the following code through the Visual Studio 2013 preprocessor. The output surprises me.</p>\n<p>Contents of hello.cpp:</p>\n<pre><code>#define A(j) #j\n\nA(A?)\nA(B?)\nA(C?)\nA(D?)\nA(E?)\nA(F?)\nA(G?)\nA(H?)\nA(I?)\nA(J?)\nA(K?)\nA(L?)\nA(M?)\nA(N?)\nA(O?)\nA(P?)\nA(Q?)\nA(R?)\nA(S?)\nA(T?)\nA(U?)\nA(V?)\nA(W?)\nA(X?)\nA(Y?)\nA(Z?)\n</code></pre>\n<p>The command:</p>\n<pre><code>cl /P hello.cpp\n</code></pre>\n<p>hello.i contains:</p>\n<pre><code>#line 1 \"hello.cpp\"\n\n\n\n\"A?\"\n\"B?\"\n\"C?\"\n\"D?\"\n\"E?\"\n\"F?\"\n\"G?\"\n\"H?\"\n\"I?\"\n\"J?\"\n\"K?\"\n\"L\"\n\"M?\"\n\"N?\"\n\"O?\"\n\"P?\"\n\"Q?\"\n\"R\"\n\"S?\"\n\"T?\"\n\"U?\"\n\"V?\"\n\"W?\"\n\"X?\"\n\"Y?\"\n\"Z?\"\n</code></pre>\n<p>I ran into this while trying to call A(L?p:q), which resulted in \"Lp:q\" which is not good for me.</p>\n<p>Is this proper, well-defined C++? What's special about L and R in C++? If the file has the .c extension, L and R are treated identical to the rest of the alphabet. Is this related to C++11? It must be a new feature, since older versions of MSVS don't tread L and R in a special way. </p>\n<p>And what can I do to stop MSVS 2013 from treating L and R in this special way?</p>\n", "Tags": "<c++><visual-c++><c++11><c-preprocessor><compiler-bug>", "OwnerUserId": "52875", "AnswerCount": "2"}});