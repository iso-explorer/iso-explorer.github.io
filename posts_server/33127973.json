post_cb({"bq_ids": {"n4140": {"so_33127973_33128231_1": {"length": 33, "quality": 0.8918918918918919, "section_id": 5797}, "so_33127973_33128231_2": {"length": 18, "quality": 1.0, "section_id": 5801}}, "n3337": {"so_33127973_33128231_1": {"length": 33, "quality": 0.8918918918918919, "section_id": 5570}, "so_33127973_33128231_2": {"length": 18, "quality": 1.0, "section_id": 5574}}, "n4659": {"so_33127973_33128231_1": {"length": 33, "quality": 0.8918918918918919, "section_id": 7256}, "so_33127973_33128231_2": {"length": 18, "quality": 1.0, "section_id": 7260}}}, "33129318": {"Id": "33129318", "PostTypeId": "2", "Body": "<h2>Yes, in your particular example (no otherwise).</h2>\n<p>Your particular example has a single thread of execution, <code>foo</code> has static storage duration and initialization (that is, before <code>main</code> is entered) and it is otherwise never modified during the program's lifetime.<br>\nIn other words, there is no externally observable difference, and the as-if rule can legally be applied. In fact, the compiler could do away with atomic instructions, alltogether. There is no way the value of <code>x</code> or <code>y</code> could be anything different, ever.</br></p>\n<p>In a program with concurrency which modifies <code>foo</code>, <em>this is not the case</em>.</p>\n<p>You do not specify a memory model, so the default model is used, which is sequential consistency. Sequencial consistency is defined as giving the same happens-before / memory ordering guarantees as release/acquire <strong>and establish a single total modification order of all atomic operations.</strong> That last bit is the important part.</p>\n<p>Single total modification order means that if you have three (atomic) operations, e.g. A, B, and C which happen in that order (maybe concurrently, in two threads), and B is a write operation while A and C are read operations, then C <strong>must</strong> see the state established by B, not some other earlier state. That is, the value seen at points A and C will be <em>different</em>.</p>\n<p>In terms of your code sample, if another thread modifies <code>foo</code> immediately after you are reading it into <code>x</code> (but before you are reading the value into <code>y</code>), the value that is placed into <code>y</code> <strong>must</strong> be the value that was written. Because if the operations happen in that order, they must also be realized in that order.</p>\n<p>Of course, a write that happens exactly in between two consecutive load instructions is a rather unlikely thing (since the time window is very small, a mere single tick), but it does not matter whether it is unlikely.<br>\nThe compiler must produce code that makes sure that if this constellation arises, operations are still seen in exactly the order in which they happened.</br></p>\n", "LastActivityDate": "2015-10-14T15:20:20.180", "CommentCount": "12", "CreationDate": "2015-10-14T15:20:20.180", "ParentId": "33127973", "Score": "-1", "OwnerUserId": "572743"}, "33128231": {"Id": "33128231", "PostTypeId": "2", "Body": "<h3>Yes, because we can not observe the difference!</h3>\n<p>An implementation is allowed to turn your snippet into the following (pseudo-implementation).</p>\n<pre><code>int __loaded_foo = foo;\n\nint x = __loaded_foo;\nint y = __loaded_foo;\n</code></pre>\n<p>The reason is that there is no way for you to observe the difference between the above, and two separate loads of <em>foo</em> given the guarantees of sequential-consistency.</p>\n<blockquote>\n<p id=\"so_33127973_33128231_0\"><sub><strong>Note</strong>: It is not just the compiler that can make such an optimization, the processor can simply reason that there is no way in which you can observe the difference and load the value of <code>foo</code> once \u2014 even though the compiler might have asked it to do it twice.</sub></p>\n</blockquote>\n<p><br/></p>\n<hr>\n<hr>\n<p><br/></p>\n<h3>Explanation</h3>\n<p>Given a thread that keeps on updating <em>foo</em> in an incremental fashion, what you are guaranteed is that <code>y</code> will have either the same, <strong>or</strong> a later written value, when compared to the contents of <code>x</code>.</p>\n<pre><code>// thread 1 - The Writer\nwhile (true) {\n  foo += 1;\n}\n</code></pre>\n<pre><code>// thread 2 - The Reader\nwhile (true) {\n  int x = foo;\n  int y = foo;\n\n  assert (y &gt;= x); // will never fire, unless UB (foo has reached max value)\n}                  \n</code></pre>\n<p>Imagine the writing thread for some reason pauses its execution on every iteration (because of a <em>context-switch</em> or other implementation defined reason); there is no way in which you can prove that this is what is causing both <code>x</code> and <code>y</code> to have the same value, or if it is because of a \"merge optimization\".</p>\n<p><br/></p>\n<p>In other words, we have to potential outcomes given the code in this section:</p>\n<ol>\n<li>No new value is written to <em>foo</em> between the two reads (<code>x == y</code>).</li>\n<li>A new value is written to <em>foo</em> between the two reads (<code>x &lt; y</code>).</li>\n</ol>\n<p>Since any of the two can happen, an implementation is free to narrow down the scope to simply always execute one of them; we can in no way observe the difference.</p>\n<p><br/></p>\n<hr>\n<hr>\n<p><br/></p>\n<h3>What does the Standard say?</h3>\n<p>An implementation can make whatever changes it wants as long as we cannot observe any difference between the behavior which we expressed, and the behavior during execution.</p>\n<p>This is covered in <code>[intro.execution]p1</code>:</p>\n<blockquote>\n<p id=\"so_33127973_33128231_1\">The semantic descriptions in this International Standard define a\n  parameterized nondeterministic abstract machine. This International\n  Standard places no requirement on the structure of conforming\n  implementations. In particular, they need not copy or emulate the\n  structure of the abstract machine. Rather, conforming implementations\n  are <strong>required to emulate (only) the observable behavior of the abstract\n  machine</strong> as explained below.</p>\n</blockquote>\n<p>Another section which makes it even more clear <code>[intro.execution]p5</code>:</p>\n<blockquote>\n<p id=\"so_33127973_33128231_2\">A conforming implementation executing a well-formed program shall\n  produce the same observable behavior as <strong>one of the possible executions</strong>\n  of the corresponding instance of the abstract machine with the same\n  program and the same input.</p>\n</blockquote>\n<p><strong>Further Reading</strong>:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/15718262/what-exactly-is-the-as-if-rule\"><strong>What exactly is the \"as-if\nrule\"?</strong></a></li>\n</ul>\n<p><br/></p>\n<hr>\n<hr>\n<p><br/></p>\n<h3>What about polling in a loop?</h3>\n<pre><code>// initial state\nstd::atomic&lt;int&gt; foo = 0;\n</code></pre>\n<pre><code>// thread 1\nwhile (true) {\n  if (foo)\n    break;\n}\n</code></pre>\n<pre><code>// thread 2\nfoo = 1\n</code></pre>\n<blockquote>\n<p id=\"so_33127973_33128231_3\"><strong>Question</strong>: Given the reasoning in the previous sections, could an implementation simply read <code>foo</code> once in <em>thread 1</em>, and then never break out of the loop even if <em>thread 2</em> writes to <code>foo</code>?</p>\n</blockquote>\n<p>The answer; No.</p>\n<p>In a sequentially-consistent environment we are guaranteed that a write to <em>foo</em> in <em>thread 2</em> will become visible in <em>thread 1</em>; this means that when that write has happened, <em>thread 1</em> must observe this change of state.</p>\n<p><sub><strong>Note</strong>: An implementation can turn two reads into a single one because we cannot observe the difference (one <a href=\"https://en.wikipedia.org/wiki/Memory_barrier\" rel=\"nofollow noreferrer\">fence</a> is just as effective as two), but it cannot completely disregard a read that exists by itself.</sub></p>\n<p><sub><strong>Note</strong>: The contents of this section is guaranteed by <code>[atomics.order]p3-4</code>.</sub></p>\n<p><br/></p>\n<hr>\n<hr>\n<p><br/></p>\n<p><sub><strong>What if I really want to prevent this form of \"optimization\"?</strong></sub></p>\n<p><sub>If you would like to force the implementation to actually read the value of some variable at every point where you have written it you should look into usage of <a href=\"http://en.cppreference.com/w/cpp/language/cv\" rel=\"nofollow noreferrer\"><code>volatile</code></a> (note that this in no way enhances thread-safety).</sub></p>\n</hr></hr></hr></hr></hr></hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-14T18:24:30.487", "Score": "16", "CreationDate": "2015-10-14T14:32:31.093", "ParentId": "33127973", "CommentCount": "5", "OwnerUserId": "1090079", "LastEditDate": "2017-05-23T12:07:31.643"}, "33127973": {"ViewCount": "400", "Body": "<p>Consider the C++ 11 snippet below. For GCC and clang this compiles to two (sequentially consistent) loads of foo. Does the C++ memory model allow the compiler to merge these two loads into a single load and use the same value for x and y?</p>\n<p>I think it cannot merge these loads, because that means that polling an atomic doesn't work anymore, but I cannot find the relevant part in the memory model documentation.</p>\n<pre><code>#include &lt;atomic&gt;\n#include &lt;cstdio&gt;\n\nstd::atomic&lt;int&gt; foo;\n\nint main(int argc, char **argv)\n{\n    int x = foo;\n    int y = foo;\n\n    printf(\"%d %d\\n\", x, y);\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "33128231", "Title": "Can atomic loads be merged in the C++ memory model?", "CreationDate": "2015-10-14T14:22:58.713", "Id": "33127973", "CommentCount": "24", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-10-14T18:24:30.487", "Score": "17", "OwnerUserId": "1570219", "Tags": "<c++><c++11><language-lawyer><memory-model>", "AnswerCount": "2"}});