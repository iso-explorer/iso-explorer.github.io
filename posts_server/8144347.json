post_cb({"8144347": {"CommentCount": "0", "ViewCount": "279", "CreationDate": "2011-11-15T22:58:10.037", "LastActivityDate": "2011-11-17T16:46:42.517", "Title": "Which buffer should be set by basic_streambuf::setbuf?", "AcceptedAnswerId": "8170983", "PostTypeId": "1", "Id": "8144347", "Score": "3", "Body": "<p>I am working on a <code>basic_streambuf</code> to handle reading and writing from/to a Winsock socket. Just like <code>basic_filebuf</code>, I am internally using a <code>std::codecvt</code> object to convert bytes read from the underlying socket to the char type of the \"socket streambuf\" as well as to convert chars written to the socket streambuf to bytes that can be written to the underlying socket. In order to do this, I am finding that I need to maintain buffers for both the reading and writing functionality of the streambuf.</p>\n<p>The logical issue that I am encountering is that a streambuf implementation is intended to be used for both reading and writing (the <a href=\"http://msdn.microsoft.com/en-us/library/ee404762.aspx\" rel=\"nofollow\"><code>std::iostream</code> constructor</a> takes a single pointer-to-streambuf), yet there is only one overridable member function that can be customized for setting an underlying char buffer: <a href=\"http://msdn.microsoft.com/en-us/library/y6febtbz.aspx\" rel=\"nofollow\"><code>setbuf</code></a>. If I want to allow users of my socket streambuf template to set the underlying buffer, should <code>setbuf</code> set the read buffer or the write one? Which option makes more sense?</p>\n", "Tags": "<c++><io><winsock><streambuf>", "OwnerUserId": "196844", "AnswerCount": "2"}, "8170983": {"ParentId": "8144347", "CommentCount": "0", "Body": "<p>The standard streams only have two specified behaviors with setbuf. The first is that setbuf(0,0) may have no effect, and the second is for basic_filebuf where, if setbuf(0,0) is called before any IO then the IO is unbuffered. Otherwise the results are implementation defined. So just do what makes sense for your implementation, and then document it.</p>\n", "OwnerUserId": "365496", "PostTypeId": "2", "Id": "8170983", "Score": "1", "CreationDate": "2011-11-17T16:46:42.517", "LastActivityDate": "2011-11-17T16:46:42.517"}, "bq_ids": {"n4140": {"so_8144347_8144474_0": {"section_id": 2089, "quality": 0.76, "length": 19}}, "n3337": {"so_8144347_8144474_0": {"section_id": 2077, "quality": 0.76, "length": 19}}, "n4659": {"so_8144347_8144474_0": {"section_id": 2362, "quality": 0.8, "length": 20}}}, "8144474": {"ParentId": "8144347", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>std::iostream</code> inherits from both <code>std::istream</code> and <code>std::ostream</code>, but both of <em>those</em> inherit virtually from <code>std::ios</code>, which contains the buffer.  Since they both inherit virtually from <code>std::ios</code>, there is only one <code>std::ios</code> base of <code>std::iostream</code>, and as such, only one internal buffer.</p>\n<p>From the C++11 Feb 2011 Draft: </p>\n<p>\u00a7 27.6.3 </p>\n<blockquote>\n<p id=\"so_8144347_8144474_0\">The class template basic_streambuf serves as an abstract base class for deriving various\n  stream buffers whose objects each control two character sequences:<br>\n  \u2014 a character input sequence;<br>\n  \u2014 a character output sequence.    </br></br></p>\n</blockquote>\n<p>\u00a7 27.7.2</p>\n<pre><code>namespace std {  \ntemplate &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;  \nclass basic_istream : virtual public basic_ios&lt;charT,traits&gt; {\n</code></pre>\n<p>\u00a7 27.7.3 </p>\n<pre><code>namespace std {  \ntemplate &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;  \nclass basic_ostream : virtual public basic_ios&lt;charT,traits&gt; {\n</code></pre>\n", "OwnerUserId": "845092", "LastEditorUserId": "845092", "LastEditDate": "2011-11-15T23:15:40.807", "Id": "8144474", "Score": "2", "CreationDate": "2011-11-15T23:10:22.547", "LastActivityDate": "2011-11-15T23:15:40.807"}});