post_cb({"15221498": {"ParentId": "15217572", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2013-03-05T10:30:42.490", "Score": "8", "LastEditorUserId": "1838266", "LastEditDate": "2013-03-06T12:41:00.413", "Id": "15221498", "OwnerUserId": "1838266", "Body": "<p><strong>Updated:</strong> This answer at first missed some information and thus lead to wrong conclusions.</p>\n<p>In your examples, <code>initial</code> and <code>rest</code> are clearly distinct (array) objects, so comparing pointers to <code>initial</code> (or its elements) with pointers to <code>rest</code> (or its elements) is </p>\n<ul>\n<li>UB, if you use the difference of the pointers. (\u00a75.7,6)</li>\n<li>unspecified, if you use relational operators (\u00a75.9,2)</li>\n<li>well defined for <code>==</code> (So the second snipped is good, see below)</li>\n</ul>\n<h1>First snippet:</h1>\n<p>Building the difference in the first snippet is undefined behavior, for the quote you provided (<strong>\u00a75.7,6</strong>):</p>\n<blockquote>\n<p id=\"so_15217572_15221498_0\">Unless both pointers point to elements of the same array object, or\n  one past the last element of the array object, the behavior is undefined.</p>\n</blockquote>\n<p>To clarify the UB parts of the first example code:</p>\n<pre><code>//first example\nint main()\n{\n    Derived&lt;float, 10&gt; d;\n    assert(&amp;d.rest[9] - &amp;d.initial == 10);            //!!! UB !!!\n    assert(&amp;d.end - &amp;d.begin == sizeof(float) * 10);  //!!! UB !!! (*)\n    return 0;\n}\n</code></pre>\n<p>The line marked with <code>(*)</code> is interesting: <code>d.begin</code> and <code>d.end</code> are not elements of the same array and therefore the operation results in UB. This is despite the fact you may <code>reinterpret_cast&lt;char*&gt;(&amp;d)</code> and have both their addresses in the resulting array. But since that array is a representation of <em>all</em> of <code>d</code>, it's not to be seen as an access to <em>parts</em> of <code>d</code>. So while that operation probably will just work and give the expected result on any implementation one can dream of, it still is UB - as a matter of definition.</p>\n<h1>Second snippet:</h1>\n<p>This is actually well defined behavior, but implementation defined result:</p>\n<pre><code>int main()\n{\n    Derived&lt;float, 10&gt; d;\n    assert(&amp;d.rest[9] - &amp;d.rest[0] == 9);\n    assert(&amp;d.rest[0] == &amp;d.initial[1]);         //(!)\n    assert(&amp;d.initial[1] - &amp;d.initial[0] == 1);\n    return 0;\n}\n</code></pre>\n<p>The line marked with <code>(!)</code> is <em>not</em> ub, but its result is <em>implementation defined</em>, since padding, alignment and the mentioned instumentation might play a role.\nBut <em>if</em> that assertion would hold, <strong>you could use the two object parts like one array</strong>.</p>\n<p>You would know that <code>rest[0]</code> would lay immediately after <code>initial[0]</code> in memory. <em>At first sight</em>, you could not easily use the equality:</p>\n<ul>\n<li><code>initial[1]</code> would point one-past-the-end of <code>initial</code>, dereferencing it is UB. </li>\n<li><code>rest[-1]</code> is clearly out of bounds.</li>\n</ul>\n<p>But enters <strong>\u00a73.9.2,3</strong>:</p>\n<blockquote>\n<p id=\"so_15217572_15221498_1\">If an object of type <code>T</code> is located at an address <code>A</code>, a pointer of type <em>cv</em> <code>T*</code> whose value is the\n  address <code>A</code> is said to point to that object, regardless of how the value was obtained. [ Note: For instance,\n  the address one past the end of an array (5.7) would be considered to point to an unrelated object of the\n  array\u2019s element type that might be located at that address.</p>\n</blockquote>\n<p>So provided that <code>&amp;initial[1] == &amp;rest[0]</code>, it will be binary the same as if there was only one array, and all will be ok. </p>\n<p>You could iterate over both arrays, since you could apply some \"pointer context switch\" at the boundaries. So to your last snippet: the <code>swap</code> is not needed!</p>\n<p>However, there are some caveats: <code>rest[-1]</code> is UB, and so would be <code>initial[2]</code>, because of <strong>\u00a75.7,5</strong>: </p>\n<blockquote>\n<p id=\"so_15217572_15221498_2\">If both the pointer operand and the result point to elements of the same array object, or one past\n  the last element of the array object, the evaluation shall not produce an overflow; <strong>otherwise, the behavior is\n  undefined</strong>. </p>\n</blockquote>\n<p>(emphasis mine). So how do these two fit together?</p>\n<ul>\n<li>\"Good path\": <code>&amp;initial[1]</code> is ok, and since <code>&amp;initial[1] == &amp;rest[0]</code> you can take that address and go on to increment the pointer to access the other elements of <code>rest</code>, because of \u00a73.9.2,3</li>\n<li>\"Bad path\": <code>initial[2]</code> is <code>*(initial + 2)</code>, but since \u00a75.7,5, <code>initial +2</code> is already UB and you never get to use \u00a73.9.2,3 here. </li>\n</ul>\n<p>Together: you have to stop by at the boundary, take a short break to check that the addresses are equal and then you can move on.</p>\n", "LastActivityDate": "2013-03-06T12:41:00.413"}, "bq_ids": {"n4140": {"so_15217572_15217572_0": {"section_id": 6143, "quality": 0.9726027397260274, "length": 71}, "so_15217572_15221498_0": {"section_id": 6143, "quality": 0.9375, "length": 15}, "so_15217572_15221498_2": {"section_id": 6142, "quality": 1.0, "length": 21}, "so_15217572_15221498_1": {"section_id": 7223, "quality": 0.9142857142857143, "length": 32}}, "n3337": {"so_15217572_15217572_0": {"section_id": 5907, "quality": 0.9726027397260274, "length": 71}, "so_15217572_15221498_0": {"section_id": 5907, "quality": 0.9375, "length": 15}, "so_15217572_15221498_2": {"section_id": 5906, "quality": 1.0, "length": 21}, "so_15217572_15221498_1": {"section_id": 6967, "quality": 0.9142857142857143, "length": 32}}, "n4659": {"so_15217572_15221498_0": {"section_id": 7639, "quality": 0.5625, "length": 9}, "so_15217572_15221498_2": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}, "so_15217572_15221498_1": {"section_id": 8732, "quality": 0.5142857142857142, "length": 18}}}, "15217572": {"CommentCount": "15", "ViewCount": "702", "PostTypeId": "1", "CommunityOwnedDate": "2013-03-05T18:15:37.433", "LastEditorUserId": "2008149", "CreationDate": "2013-03-05T06:53:30.393", "LastActivityDate": "2013-03-06T23:44:32.890", "LastEditDate": "2013-03-06T23:44:32.890", "AcceptedAnswerId": "15221498", "FavoriteCount": "2", "Title": "Pointer arithmetic across subobject boundaries", "Id": "15217572", "Score": "24", "Body": "<p>Does the following code (which performs pointer arithmetic across subobject boundaries) have well-defined behavior for types <code>T</code> for which it compiles (which, in C++11, <a href=\"http://en.wikipedia.org/wiki/C%2B%2B11#Unrestricted_unions\" rel=\"nofollow\">does not not necessarily have to be POD</a>) or any subset thereof?</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;cstddef&gt;\n\ntemplate&lt;typename T&gt;\nstruct Base\n{\n    // ensure alignment\n    union\n    {\n        T initial;\n        char begin;\n    };\n};\n\ntemplate&lt;typename T, size_t N&gt;\nstruct Derived : public Base&lt;T&gt;\n{\n    T rest[N - 1];\n    char end;\n};\n\nint main()\n{\n    Derived&lt;float, 10&gt; d;\n    assert(&amp;d.rest[9] - &amp;d.initial == 10);\n    assert(&amp;d.end - &amp;d.begin == sizeof(float) * 10);\n    return 0;\n}\n</code></pre>\n<p>LLVM uses a variation of the above technique in the implementation of an internal vector type which is optimized to initially use the stack for small arrays but switches to a heap-allocated buffer once over initial capacity. (The reason for doing it this way is not clear from this example but is apparently to reduce template code bloat; this is clearer if you look through the <a href=\"http://llvm.org/docs/doxygen/html/SmallVector_8h_source.html\" rel=\"nofollow\">code</a>.) </p>\n<p><strong>NOTE:</strong> Before anyone complains, this is not exactly what they are doing and it might be that their approach is more standards-compliant than what I have given here, but I wanted to ask about the general case.</p>\n<p>Obviously, it works in practice, but I'm curious if anything in the standard guarantees for that to be the case. I'm inclined to say no, given <em>N3242/expr.add</em>:</p>\n<blockquote>\n<p id=\"so_15217572_15217572_0\">When two pointers to elements of the same array object are subtracted, the result is the difference of the subscripts of the two array elements...Moreover, if the expression P points either to an element of an array object or one past the last element of\n  an array object, and the expression Q points to the last element of the same array object, the expression ((Q)+1)-(P) has the same value as ((Q)-(P))+1 and as -((P)-((Q)+1)), and has the value zero if the expression P points one past the last element of the array object, even though the expression (Q)+1 does not point to an element of the array object. \n  ...Unless both pointers point to elements of the same array object, or one past the last element of the array object, the behavior is undefined.</p>\n</blockquote>\n<p>But theoretically, the middle part of the above quote, combined with class layout and alignment guarantees, might allow the following (minor) adjustment to be valid:</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;cstddef&gt;\n\ntemplate&lt;typename T&gt;\nstruct Base\n{\n    T initial[1];\n};\n\ntemplate&lt;typename T, size_t N&gt;\nstruct Derived : public Base&lt;T&gt;\n{\n    T rest[N - 1];\n};\n\nint main()\n{\n    Derived&lt;float, 10&gt; d;\n    assert(&amp;d.rest[9] - &amp;d.rest[0] == 9);\n    assert(&amp;d.rest[0] == &amp;d.initial[1]);\n    assert(&amp;d.rest[0] - &amp;d.initial[0] == 1);\n    return 0;\n}\n</code></pre>\n<p>which combined with various other provisions concerning <code>union</code> layout, convertibility to and from <code>char *</code>, etc., might arguably make the original code valid as well. (The main problem is the lack of transitivity in the definition of pointer arithmetic given above.)</p>\n<p>Anyone know for sure? <em>N3242/expr.add</em> seems to make clear that pointers must belong to the same \"array object\" for it to be defined, but it <em>could</em> hypothetically be the case that other guarantees in the standard, when combined together, might require a definition anyway in this case in order to remain logically self-consistent. (I'm not betting on it, but I would it's at least conceivable.)</p>\n<p><strong>EDIT</strong>: @MatthieuM raises the objection that this class is not standard-layout and therefore might not be guaranteed to contain no padding between the base subobject and the first member of the derived, even if both are aligned to <code>alignof(T)</code>. I'm not sure how true that is, but that opens up the following variant questions:</p>\n<ul>\n<li><p>Would this be guaranteed to work if the inheritance were removed?</p></li>\n<li><p>Would <code>&amp;d.end - &amp;d.begin &gt;= sizeof(float) * 10</code> be guaranteed even if <code>&amp;d.end - &amp;d.begin == sizeof(float) * 10</code> were not?</p></li>\n</ul>\n<p><strong>LAST EDIT</strong> @ArneMertz argues for a very close reading of <em>N3242/expr.add</em> (yes, I know I'm reading a draft, but it's close enough), but does the standard really imply that the following has undefined behavior then if the swap line is removed? (same class definitions as above)</p>\n<pre><code>int main()\n{\n    Derived&lt;float, 10&gt; d;\n    bool aligned;\n    float * p = &amp;d.initial[0], * q = &amp;d.rest[0];\n\n    ++p;\n    if((aligned = (p == q)))\n    {\n        std::swap(p, q); // does it matter if this line is removed?\n        *++p = 1.0;\n    }\n\n    assert(!aligned || d.rest[1] == 1.0);\n\n    return 0;\n}\n</code></pre>\n<p>Also, if <code>==</code> is not strong enough, what if we take advantage of the fact that <code>std::less</code> forms a total order over pointers, and change the conditional above to:</p>\n<pre><code>    if((aligned = (!std::less&lt;float *&gt;()(p, q) &amp;&amp; !std::less&lt;float *&gt;()(q, p))))\n</code></pre>\n<p>Is code that assumes that two equal pointers point to the same array object really broken according to a strict reading of the standard?</p>\n<p><strong>EDIT</strong> Sorry, just want to add one more example, to eliminate the standard layout issue:</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;cstddef&gt;\n#include &lt;utility&gt;\n#include &lt;functional&gt;\n\n// standard layout\nstruct Base\n{\n    float initial[1];\n    float rest[9];\n};\n\nint main()\n{\n    Base b;\n    bool aligned;\n    float * p = &amp;b.initial[0], * q = &amp;b.rest[0];\n\n    ++p;\n    if((aligned = (p == q)))\n    {\n        std::swap(p, q); // does it matter if this line is removed?\n        *++p = 1.0;\n        q = &amp;b.rest[1];\n        // std::swap(p, q); // does it matter if this line is added?\n        p -= 2; // is this UB?\n    }\n    assert(!aligned || b.rest[1] == 1.0);\n    assert(p == &amp;b.initial[0]);\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><pointers><c++11><language-lawyer><pointer-arithmetic>", "OwnerUserId": "2008149", "AnswerCount": "1"}});