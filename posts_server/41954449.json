post_cb({"bq_ids": {"n4140": {"so_41954449_41954449_1": {"section_id": 391, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_41954449_41954449_1": {"section_id": 382, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_41954449_41954449_1": {"section_id": 408, "quality": 0.7058823529411765, "length": 12}}}, "41954449": {"CommentCount": "18", "ViewCount": "105", "PostTypeId": "1", "LastEditorUserId": "896627", "CreationDate": "2017-01-31T09:55:34.127", "LastActivityDate": "2017-01-31T11:18:41.257", "Title": "What does GCCs conversion function &operator int(); do?", "LastEditDate": "2017-01-31T11:18:41.257", "Id": "41954449", "Score": "1", "Body": "<p>With g++, this is a legal declaration:</p>\n<pre><code>class foo\n{\n  public:\n    foo();\n    &amp;operator int();  // this fails with Clang   \n};\n</code></pre>\n<p>This is a simplified example of my real code, which looks more like</p>\n<pre><code>template &lt;class VAR_TYPE&gt; class Foo : public Bar&lt;VAR_TYPE&gt;\n{\n  public:   \n    Foo();\n    // [...] more constructors here\n\n    &amp;operator const VAR_TYPE () const;  // this fails with Clang\n\n    // [...] more stuff (a lot)\n};\n</code></pre>\n<p>Trying to compile this with Clang yields the following error:</p>\n<blockquote>\n<p id=\"so_41954449_41954449_0\">error: cannot specify any part of a return type in the declaration of\n  a conversion function; put the complete type after 'operator'</p>\n</blockquote>\n<p>I've found arguments that the GCCs use of <code>&amp;</code> here is forbidden, as it violates the language definition 12.3.2.1 </p>\n<blockquote>\n<p id=\"so_41954449_41954449_1\">[...] No return type can be specified. If a conversion function is a\n  member function, the  type of the conversion function (8.3.5) is\n  \u201cfunction taking no parameter returning conversion-type-id\u201d. [...]</p>\n</blockquote>\n<p><strong>Question 1.</strong>\nWhat exactly does the GCC implementation do? From my testing, I suspect it to be equivalent to <code>operator int&amp; ();</code>, but please correct me if I'm wrong or if I miss some additional functionality.</p>\n<p><strong>Question 2.</strong>\nIn my (legacy) code, it's actually <code>&amp;operator const VAR_TYPE() const;</code>. Given my assumption from Question 1 is true, this would be equivalent to <code>operator const VAR_TYPE&amp;() const;</code>. What could be the purpose of returning a const reference instead of a non-reference copy and can this be somehow exploited to give write-access to underlying data-structures like array/vector-elements?</p>\n<p><strong>Question 3.</strong>\nIs this really illegal by the language definition? The cited text only talks about return types. <code>&amp;</code> is not a type. It's a lexical element which needs to be combined with a normal type-specifier to become a type. But I can't find an extensive explanation of <code>&amp;</code> in the language definition.</p>\n", "Tags": "<c++><reference><type-conversion><clang>", "OwnerUserId": "896627", "AnswerCount": "0"}});