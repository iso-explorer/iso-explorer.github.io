post_cb({"3057522": {"ParentId": "3052579", "CommentCount": "6", "Body": "<p>Another way to solve it is by delegating to a private function and overloading that function. This way you still have access to member data of <code>*this</code> and to the outer template parameter type.</p>\n<pre><code>template&lt;typename T&gt;\nstruct identity { typedef T type; };\n\ntemplate&lt;typename T&gt;\nclass CConstraint\n{\npublic:\n\n  template &lt;typename TL&gt;\n  void Verify(int position, int constraints[])\n  {\n    Verify(position, constraints, identity&lt;TL&gt;());\n  }\n\nprivate:\n  template&lt;typename TL&gt;\n  void Verify(int, int[], identity&lt;TL&gt;)\n  {\n\n  }\n\n  void Verify(int, int[], identity&lt;int&gt;)\n  {\n\n  }\n};\n</code></pre>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "3057522", "Score": "70", "CreationDate": "2010-06-16T22:07:21.840", "LastActivityDate": "2010-06-16T22:07:21.840"}, "5446621": {"ParentId": "3052579", "CommentCount": "1", "Body": "<p>You may not be able to <strong>explicitly specialize</strong> the member template, but you can <em>partially</em> specialize it.  If you add a second parameter \"int dummyParam\" and also add it to the specialization, it should work with both compilers.</p>\n<p>Not that I knew this more than 10 seconds ago, but googling on the same error, I ran into <a href=\"http://www.linuxquestions.org/questions/programming-9/explicit-specialization-in-non-namespace-scope-186352/\" rel=\"nofollow\">this link</a> and it worked for my member template specialization.</p>\n", "OwnerUserId": "317773", "PostTypeId": "2", "Id": "5446621", "Score": "1", "CreationDate": "2011-03-27T01:34:12.573", "LastActivityDate": "2011-03-27T01:34:12.573"}, "3052579": {"CommentCount": "0", "AcceptedAnswerId": "3052604", "PostTypeId": "1", "ClosedDate": "2014-11-26T12:38:54.923", "LastEditorUserId": "415313", "CreationDate": "2010-06-16T10:46:38.220", "LastActivityDate": "2015-08-17T10:40:44.610", "LastEditDate": "2012-07-04T19:30:57.917", "ViewCount": "53695", "FavoriteCount": "22", "Title": "Explicit specialization in non-namespace scope", "Id": "3052579", "Score": "95", "Body": "<pre><code>template&lt;typename T&gt;\nclass CConstraint\n{\npublic:\n    CConstraint()\n    {\n    }\n\n    virtual ~CConstraint()\n    {\n    }\n\n    template &lt;typename TL&gt;\n    void Verify(int position, int constraints[])\n    {       \n    }\n\n    template &lt;&gt;\n    void Verify&lt;int&gt;(int, int[])\n    {   \n    }\n};\n</code></pre>\n<p>Compiling this under g++ gives the following error:</p>\n<p>Explicit specialization in non-namespace scope 'class CConstraint'</p>\n<p>In VC, it compiles fine. Can anyone please let me know the workaround?</p>\n", "Tags": "<c++><templates><gcc>", "OwnerUserId": "220212", "AnswerCount": "5"}, "6213708": {"ParentId": "3052579", "CommentCount": "2", "Body": "<p>Even better: you can combine partial specialisation with default template arguments. This way modification to the VC++ code are minor, because calls to the specialised function do not need to be modified.</p>\n<pre><code>template &lt;typename TL, class Dummy=int&gt;\nvoid Verify(int position, int constraints[])\n{\n}\n\ntemplate &lt;class Dummy=int&gt;\nvoid Verify&lt;int, Dummy&gt;(int, int[])\n{\n}\n</code></pre>\n", "OwnerUserId": "780997", "PostTypeId": "2", "Id": "6213708", "Score": "3", "CreationDate": "2011-06-02T11:05:22.087", "LastActivityDate": "2011-06-02T11:05:22.087"}, "3052604": {"ParentId": "3052579", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>VC++ is non-compliant in this case - explicit specializations have to be at namespace scope. C++03, <em>\u00a714.7.3/2</em>:</p>\n<blockquote>\n<p id=\"so_3052579_3052604_0\">An explicit specialization shall be declared in the namespace of which the template is a member, or, for member templates, in the namespace of which the enclosing class or enclosing class template is a member.<br>\n  An explicit specialization of a member function, member class or static data member of a class template shall be declared in the namespace of which the class template is a member.</br></p>\n</blockquote>\n<p>Additionally you have the problem that you can't specialize member functions without explicitly specializing the containing class due to C++03, <em>\u00a714.7.3/3</em>, so one solution would be to let <code>Verify()</code> forward to a, possibly specialized, free function:</p>\n<pre><code>namespace detail {\n    template &lt;typename TL&gt; void Verify     (int, int[]) {}\n    template &lt;&gt;            void Verify&lt;int&gt;(int, int[]) {}\n}\n\ntemplate&lt;typename T&gt; class CConstraint {\n    // ...\n    template &lt;typename TL&gt; void Verify(int position, int constraints[]) {\n        detail::Verify&lt;TL&gt;(position, constraints);\n    }\n};\n</code></pre>\n", "OwnerUserId": "168225", "LastEditorUserId": "862396", "LastEditDate": "2015-08-17T10:40:44.610", "Id": "3052604", "Score": "83", "CreationDate": "2010-06-16T10:50:58.617", "LastActivityDate": "2015-08-17T10:40:44.610"}, "bq_ids": {"n4140": {"so_3052579_3052604_0": {"section_id": 150, "quality": 0.5806451612903226, "length": 18}}, "n3337": {"so_3052579_3052604_0": {"section_id": 144, "quality": 0.5806451612903226, "length": 18}}, "n4659": {"so_3052579_3052604_0": {"section_id": 154, "quality": 0.5806451612903226, "length": 18}}}, "13018943": {"ParentId": "3052579", "CommentCount": "0", "Body": "<p>Just take the template specialization outside the class declaration.\ngcc doesn't allow inline template specialization.</p>\n<p>As another option, just deleting line\ntemplate&lt;&gt;\nseems to work for me.</p>\n", "OwnerUserId": "1766484", "PostTypeId": "2", "Id": "13018943", "Score": "8", "CreationDate": "2012-10-22T20:04:17.897", "LastActivityDate": "2012-10-22T20:04:17.897"}});