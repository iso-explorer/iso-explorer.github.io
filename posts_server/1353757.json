post_cb({"bq_ids": {"n4140": {"so_1353757_1353782_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 3804}, "so_1353757_1353813_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 3731}}, "n3337": {"so_1353757_1353782_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 3666}, "so_1353757_1353813_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 3593}}, "n4659": {"so_1353757_1353782_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 4572}, "so_1353757_1353813_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 4498}}}, "1353816": {"Id": "1353816", "PostTypeId": "2", "Body": "<p>This compiles, using the <code>__typeof__</code> GCC extension. Looks like GCC's <code>valarray</code> uses expression templates to delay calculation of the sinus. But that will make the return type of the <code>sin</code> template not exactly <code>valarray&lt;T&gt;</code>, but rather some weird complex type. </p>\n<pre><code>#include &lt;valarray&gt;\n\ntemplate&lt;typename T&gt; struct id { typedef T type; };\nint main() {\n  using std::valarray;\n  using std::sin;\n\n  id&lt;__typeof__(sin(valarray&lt;double&gt;()))&gt;::type (*fp)(const valarray&lt;double&gt; &amp;) = sin;\n}\n</code></pre>\n<p><strong>Edit:</strong> See AProgrammer's standard quote for why GCC is fine doing that. </p>\n<p><strong>Edit:</strong> Standard compliant workaround</p>\n<p>Doing this without <code>__typeof__</code> in a strictly Standard conforming way is a bit tricky. You will need to get the return type of <code>sin</code>. You can use the conditional operator for this, as Eric Niebler <a href=\"http://www.artima.com/cppsource/foreach.html\" rel=\"nofollow noreferrer\">has shown</a>. It works by having the <code>sin</code> function not actually called, but only type-checked. By trying to convert the other branch (the one which is actually evaluated) of the conditional operator to that same type, we can generate a dummy parameter just to be able to deduce the type of the function pointer:</p>\n<pre><code>#include &lt;valarray&gt;\n\nusing std::valarray;\n\ntemplate&lt;typename T&gt; struct id {\n  typedef T type;\n};\n\nstruct ded_ty {\n  template&lt;typename T&gt;\n  operator id&lt;T&gt;() { return id&lt;T&gt;(); }\n};\n\ntemplate&lt;typename E, typename T&gt;\nid&lt;T(*)(valarray&lt;E&gt; const&amp;)&gt; genFTy(T t) { \n  return id&lt;T(*)(valarray&lt;E&gt; const&amp;)&gt;(); \n}\n\ntemplate&lt;typename T&gt;\nvoid work(T fp, id&lt;T&gt;) {\n  // T is the function pointer type, fp points\n  // to the math function.\n}\n\nint main() {\n  work(std::sin, 1 ? ded_ty() : genFTy&lt;double&gt;(std::sin(valarray&lt;double&gt;())));\n}\n</code></pre>\n<p>If you want to get the address right away, you can write <code>work</code> so it returns <code>fp</code> again.</p>\n<pre><code>template&lt;typename T&gt;\nT addy(T fp, id&lt;T&gt;) { return fp; }\n</code></pre>\n<p>Now, you can finally write a macro to encapsulate the conditional operator trickery, and use it when you want to get the address of any such math function.</p>\n<pre><code>#define DEDUCE(FN,Y) (1 ? ded_ty() : genFTy&lt;Y&gt;(FN(std::valarray&lt;Y&gt;())))\n</code></pre>\n<p>To get the address and pass it to some generic function, the following works then</p>\n<pre><code>std::transform(v1.begin(), v1.end(), v1.begin(),\n  addy(std::sin, DEDUCE(std::sin, double)));\nstd::transform(v2.begin(), v2.end(), v2.begin(),\n  addy(std::cos, DEDUCE(std::cos, double)));\n</code></pre>\n", "LastEditorUserId": "34509", "LastActivityDate": "2009-08-30T16:57:34.727", "Score": "11", "CreationDate": "2009-08-30T12:53:54.070", "ParentId": "1353757", "CommentCount": "4", "OwnerUserId": "34509", "LastEditDate": "2009-08-30T16:57:34.727"}, "1353782": {"Id": "1353782", "PostTypeId": "2", "Body": "<p>You speak about <code>std::sin</code> in the title, but then assign <code>::sin</code>.</p>\n<pre><code>valarray&lt;double&gt; (*fp)(const valarray&lt;double&gt; &amp;) = std::sin;\n</code></pre>\n<p>That should work. Note, that you should qualify all uses of <code>sin</code>, though most implementations will inject the name to the global namespace even if you include <code>&lt;cmath&gt;</code> (that is non-standard behavior).</p>\n<p>Edit: unfortunately, you're out of luck. The standard says about <code>sin(valarray&lt;T&gt; const &amp;)</code> the following (26.3.3.3).</p>\n<blockquote>\n<p id=\"so_1353757_1353782_0\">This function shall return a value which is of type T or which can be unambiguously\n  converted to type T.</p>\n</blockquote>\n<p>Optimizations performed by gcc are granted by the standard. The code above is not guaranteed to work.</p>\n", "LastEditorUserId": "89847", "LastActivityDate": "2009-08-30T12:53:05.847", "Score": "4", "CreationDate": "2009-08-30T12:34:14.017", "ParentId": "1353757", "CommentCount": "4", "OwnerUserId": "89847", "LastEditDate": "2009-08-30T12:53:05.847"}, "1353757": {"ViewCount": "892", "Body": "<p>I'm having trouble with some <a href=\"http://www.cplusplus.com/reference/std/valarray/\" rel=\"nofollow noreferrer\">valarray</a> function pointer code:</p>\n<pre><code>double (*fp)(double) = sin;\nvalarray&lt;double&gt; (*fp)(const valarray&lt;double&gt; &amp;) = sin;\n</code></pre>\n<p>The first compiles, the second gives:</p>\n<pre><code>error: no matches converting function 'sin' to type 'class std::valarray&lt;double&gt; (*)(const class std::valarray&lt;double&gt;&amp;)'\n</code></pre>\n", "AcceptedAnswerId": "1353816", "Title": "How do I refer to std::sin(const valarray<double> &)?", "CreationDate": "2009-08-30T12:14:22.700", "Id": "1353757", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2009-08-30T12:26:14.140", "LastEditorUserId": "28169", "LastActivityDate": "2009-08-30T16:57:34.727", "Score": "6", "OwnerUserId": "143913", "Tags": "<c++><function-pointers><functional-programming>", "AnswerCount": "3"}, "1353813": {"Id": "1353813", "PostTypeId": "2", "Body": "<p>26 3.1/3</p>\n<blockquote>\n<p id=\"so_1353757_1353813_0\">Any function returning a valarray is permitted to return an object of another type,\n  provided all the const member functions of valarray are also applicable to this type.</p>\n</blockquote>\n<p>The aim is to allow template expressions to be used to optimize the result (i.e. looping one time on the whole array doing each times the computation, directly assigning to the resulting valarray&lt;&gt; instead of building a temporary).</p>\n<pre><code>z = sin(x+y);\n</code></pre>\n<p>can be optimized to</p>\n<pre><code>for (i = 0; i &lt; N; ++i)\n   z[i] = sin(x[i] + y[i]);\n</code></pre>\n", "LastActivityDate": "2009-08-30T12:52:05.567", "CommentCount": "1", "CreationDate": "2009-08-30T12:52:05.567", "ParentId": "1353757", "Score": "10", "OwnerUserId": "136208"}});