post_cb({"13903068": {"ParentId": "13902910", "CommentCount": "0", "Body": "<p>I would say <strong>no</strong>.</p>\n<p>At the very least:</p>\n<blockquote>\n<p id=\"so_13902910_13903068_0\"><strong>\u00a720.4.1 [tuple.general]</strong></p>\n<p id=\"so_13902910_13903068_1\"><strong>1/</strong> [...] An instantiation of tuple with two arguments is similar to an instantiation of pair with the same two arguments. See 20.3.</p>\n</blockquote>\n<p>And yet:</p>\n<pre><code>#include &lt;tuple&gt;\n\nstruct A {};\nvoid f(A);\n\nstruct B { B(std::tuple&lt;A, A&gt;); };\nvoid f(B);\n\nint main() {\n  f(std::make_tuple(A(), A()));\n}\n</code></pre>\n<p><a href=\"http://liveworkspace.org/code/2KmeWQ%241\" rel=\"nofollow\">fails</a> with:</p>\n<pre><code>Compilation finished with errors:\nsource.cpp: In function 'int main()':\nsource.cpp:10:30: error: 'A' is an ambiguous base of 'std::tuple&lt;A, A&gt;'\nsource.cpp:4:6: error: initializing argument 1 of 'void f(A)'\n</code></pre>\n<p>And I very much doubt this was the Standard's intent.</p>\n<p>Still, the least one can say is that \u00a720.4 is rather succinct...</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "13903068", "Score": "3", "CreationDate": "2012-12-16T16:07:04.880", "LastActivityDate": "2012-12-16T16:07:04.880"}, "13912596": {"ParentId": "13902910", "CommentCount": "1", "Body": "<p>Under clause 17 <strong>Library introduction</strong>:</p>\n<blockquote>\n<h3>17.5.2.3 Private members [objects.within.classes]</h3>\n<p id=\"so_13902910_13912596_0\">1 - Clauses 18 through 30 and Annex D do not specify the representation of classes, and intentionally omit specification of class members.  An implementation may define static or non-static class members, or both, as needed to implement the semantics of the member functions specified in Clauses 18 through 30 and Annex D.</p>\n</blockquote>\n<p>This is supported by <strong>1.4 Implementation compliance [intro.compliance]</strong>:</p>\n<blockquote>\n<p id=\"so_13902910_13912596_1\">3 - For classes and class templates, the library Clauses specify partial definitions. Private members (Clause 11) are not specified, but each implementation shall supply them to complete the definitions according to the description in the library Clauses.</p>\n</blockquote>\n<p>Implementing specified semantics through inheritance is not explicitly discussed anywhere in clause 17, but it is implicitly permitted through paragraph 3 of 17.5.2.3 above:</p>\n<blockquote>\n<p id=\"so_13902910_13912596_2\">3 - An implementation may use any technique that provides equivalent external behavior.</p>\n</blockquote>\n<p>This is how, for example, the node-based ordered associative containers can share implementation detail (including, eventually, class members) through inheritance.</p>\n<p>Since the external behaviour of <code>tuple</code> is changed between having <code>A</code> as a class member and directly inheriting it, and since this change of behaviour causes the rejection of otherwise well-formed programs (as opposed to just changing the <code>sizeof</code> of a class), libstdc++ is in violation of the Standard.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "13912596", "Score": "2", "CreationDate": "2012-12-17T10:45:08.753", "LastActivityDate": "2012-12-17T10:45:08.753"}, "bq_ids": {"n4140": {"so_13902910_13903068_1": {"section_id": 4011, "quality": 0.9166666666666666, "length": 11}, "so_13902910_13912596_0": {"section_id": 6246, "quality": 1.0, "length": 28}, "so_13902910_13912596_1": {"section_id": 5771, "quality": 0.875, "length": 21}, "so_13902910_13912596_2": {"section_id": 6248, "quality": 1.0, "length": 8}}, "n3337": {"so_13902910_13903068_1": {"section_id": 3862, "quality": 0.9166666666666666, "length": 11}, "so_13902910_13912596_0": {"section_id": 6006, "quality": 1.0, "length": 28}, "so_13902910_13912596_1": {"section_id": 5544, "quality": 0.875, "length": 21}, "so_13902910_13912596_2": {"section_id": 6008, "quality": 1.0, "length": 8}}, "n4659": {"so_13902910_13903068_1": {"section_id": 4918, "quality": 0.9166666666666666, "length": 11}, "so_13902910_13912596_0": {"section_id": 7750, "quality": 1.0, "length": 28}, "so_13902910_13912596_1": {"section_id": 7228, "quality": 0.875, "length": 21}, "so_13902910_13912596_2": {"section_id": 7752, "quality": 0.875, "length": 7}}}, "13902910": {"CommentCount": "11", "AcceptedAnswerId": "13912596", "PostTypeId": "1", "LastEditorUserId": "1774667", "CreationDate": "2012-12-16T15:45:39.890", "LastActivityDate": "2012-12-17T10:45:08.753", "LastEditDate": "2012-12-16T15:54:55.293", "ViewCount": "321", "FavoriteCount": "6", "Title": "Is an implementation of std::tuple allowed to fail with triggering a derived-to-base conversion for empty class elements?", "Id": "13902910", "Score": "18", "Body": "<p>This code does not compile with GCC4.7</p>\n<pre><code>struct A {};\nvoid f(A);\n\nstruct B { B(std::tuple&lt;A&gt;); };\nvoid f(B);\n\nint main() {\n  f(std::make_tuple(A()));\n}\n</code></pre>\n<p>Because GCC derives from <code>A</code> to make use of the empty base class optimization. However that causes GCC to pick <code>f(A)</code> and complain </p>\n<blockquote>\n<p id=\"so_13902910_13902910_0\">error: <code>'A'</code> is an inaccessible base of <code>'tuple&lt;A&gt;'</code></p>\n</blockquote>\n<p>Is this error granted by the C++ Standard or is this simply a bug of libstdc++?</p>\n", "Tags": "<c++><c++11><language-lawyer><stdtuple>", "OwnerUserId": "34509", "AnswerCount": "2"}});