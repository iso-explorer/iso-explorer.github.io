post_cb({"bq_ids": {"n4140": {"so_11817873_19698477_1": {"length": 64, "quality": 0.8311688311688312, "section_id": 481}}, "n3337": {"so_11817873_19698477_1": {"length": 73, "quality": 0.948051948051948, "section_id": 472}}, "n4659": {"so_11817873_19698477_1": {"length": 60, "quality": 0.7792207792207793, "section_id": 504}}}, "19698477": {"Id": "19698477", "PostTypeId": "2", "Body": "<p>No. The best practice is directly <code>return t;</code>.</p>\n<p>In case class <code>T</code> has move constructor not deleted, and notice <code>t</code> is a local variable that <code>return t</code> is eligible for copy elision, it move constructs the returned object just like <code>return std::move(t);</code> does. However <code>return t;</code> is still eligible to copy/move elision, so the construction may be omitted, while <code>return std::move(t)</code> always constructs the return value using move constructor.</p>\n<p>In case move constructor in class <code>T</code> is deleted but copy constructor available, <code>return std::move(t);</code> will not compile, while <code>return t;</code> still compiles using copy constructor. Unlike <a href=\"https://stackoverflow.com/users/596781/kerrek-sb\">@Kerrek</a> mentioned, <code>t</code> is not bound to an rvalue reference. There's a two-stage overload resolution for return values that eligible for copy elision -- try move first, then copy, and both move and copy is possibly elided.</p>\n<pre><code>class T\n{\npublic:\n    T () = default;\n    T (T&amp;&amp; t) = delete;\n    T (const T&amp; t) = default;\n};\n\nT foo()\n{\n    T t;\n    return t;                   // OK: copied, possibly elided\n    return std::move(t);        // error: move constructor deleted\n    return static_cast&lt;T&amp;&gt;(t);  // OK: copied, never elided\n}\n</code></pre>\n<p>If the <code>return</code> expression is lvalue and not eligible for copy elision (most likely you are returning a non-local variable or lvalue expression) and you still would like to avoid copy, <code>std::move</code> will be useful. But keep in mind that the best practice is make copy elision possible to happen.</p>\n<pre><code>class T\n{\n public:\n    T () = default;\n    T (T&amp;&amp; t) = default;\n    T (const T&amp; t) = default;\n};\n\nT bar(bool k)\n{\n    T a, b;\n    return k ? a : b;            // lvalue expression, copied\n    return std::move(k ? a : b); // moved\n    if (k)\n        return a;                // moved, and possibly elided\n    else\n        return b;                // moved, and possibly elided\n}\n</code></pre>\n<p>12.8(32) in the standard describes the process.</p>\n<blockquote>\n<p id=\"so_11817873_19698477_0\">12.8 [class.copy]</p>\n<p id=\"so_11817873_19698477_1\">32 When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. If overload resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue. [ Note: This two-stage overload resolution must be performed regardless of whether copy elision will occur. It determines the constructor to be called if elision is not performed, and the selected constructor must be accessible even if the call is elided. \u2014end note ]</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-10-31T04:45:35.117", "Score": "7", "CreationDate": "2013-10-31T04:31:25.767", "ParentId": "11817873", "CommentCount": "0", "OwnerUserId": "393768", "LastEditDate": "2017-05-23T10:31:32.407"}, "11817873": {"ViewCount": "8627", "Body": "<p>Consider a type T supporting the default move semantics. Also consider the function below:</p>\n<pre><code>T f() {\n   T t;\n   return t;\n}\n\nT o = f();\n</code></pre>\n<p>In the old C++03, some non-optimal compilers might call the copy constructor twice, one for the \"return object\" and one for <code>o</code>.</p>\n<p>In c++11, since <code>t</code> inside <code>f()</code> is an lvalue, those compilers might call the copy constructor one time as before, and then call the move constructor for o.</p>\n<p>Is it correct to state that the only way to avoid the first \"extra copy\" is to move <code>t</code> when  returning?</p>\n<pre><code>T f() {\n   T t;\n   return std::move(t);\n}\n</code></pre>\n", "AcceptedAnswerId": "11817902", "Title": "Using std::move() when returning a value from a function to avoid to copy", "CreationDate": "2012-08-05T16:00:36.873", "Id": "11817873", "CommentCount": "2", "FavoriteCount": "6", "PostTypeId": "1", "LastActivityDate": "2013-10-31T04:45:35.117", "Score": "37", "OwnerUserId": "989331", "Tags": "<c++>", "AnswerCount": "3"}, "11817902": {"Id": "11817902", "PostTypeId": "2", "Body": "<p>No. Whenever a local variable in a <code>return</code> statement is eligible for copy elision, it binds to an rvalue re\u00adfe\u00adrence, and thus <code>return t;</code> is identical to <code>return std::move(t);</code> in your example with respect to which constructors are eligible.</p>\n<p>Note however that <code>return std::move(t);</code> <em>prevents</em> the compiler from exercising copy elision, while <code>return t</code>; does not, and thus the latter is the preferred style. [Thanks to @Johannes for the cor\u00adrect\u00adion.] If copy elision happens, the question of whether or not move construction is used becomes a moot point.</p>\n<p>See 12.8(31, 32) in the standard.</p>\n<p>Note also that if <code>T</code> has an accessible copy- but a deleted move-constructor, then <code>return t;</code> will not com\u00adpile, because the move constructor must be considered first; you'd have to say something to the ef\u00adfect of <code>return static_cast&lt;T&amp;&gt;(t);</code> to make it work:</p>\n<pre><code>T f()\n{\n    T t;\n    return t;                 // most likely elided entirely\n    return std::move(t);      // uses T::T(T &amp;&amp;) if defined; error if deleted or inaccessible\n    return static_cast&lt;T&amp;&gt;(t) // uses T::T(T const &amp;)\n}\n</code></pre>\n", "LastEditorUserId": "596781", "LastActivityDate": "2012-08-05T16:17:34.533", "Score": "40", "CreationDate": "2012-08-05T16:04:57.243", "ParentId": "11817873", "CommentCount": "4", "OwnerUserId": "596781", "LastEditDate": "2012-08-05T16:17:34.533"}, "13233197": {"Id": "13233197", "PostTypeId": "2", "Body": "<p>Ok, I would like to drop a comment on this. This question (and the answer) made me believe that it is not necessary to specify <code>std::move</code> on the return statement. However I was just thought a different lesson while dealing with my code. </p>\n<p>So, I have a function (it's actually a specialization) that takes a temporary and just returns it. (The general function template does other stuff, but the specialization does the identity operation).</p>\n<pre><code>template&lt;&gt;\nstruct CreateLeaf&lt; A &gt;\n{\n  typedef A Leaf_t;\n  inline static\n  Leaf_t make( A &amp;&amp;a) { \n    return a;\n  }\n};\n</code></pre>\n<p>Now, this version calls the copy constructor of <code>A</code> upon returning. If I change the return statement to </p>\n<pre><code>Leaf_t make( A &amp;&amp;a) { \n  return std::move(a);\n}\n</code></pre>\n<p>Then the move constructor of <code>A</code> gets called and I can do some optimizations there.</p>\n<p>It might not be 100% matching your question. But it is false to think that <code>return std::move(..)</code> is never necessary. I used to think so. Not any more ;-)</p>\n", "LastActivityDate": "2012-11-05T13:33:33.963", "CommentCount": "1", "CreationDate": "2012-11-05T13:33:33.963", "ParentId": "11817873", "Score": "2", "OwnerUserId": "712302"}});