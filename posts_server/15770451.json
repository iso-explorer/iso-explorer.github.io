post_cb({"15770451": {"CommentCount": "2", "AcceptedAnswerId": "15770612", "PostTypeId": "1", "LastEditorUserId": "1023390", "CreationDate": "2013-04-02T17:30:35.500", "LastActivityDate": "2013-04-02T17:48:22.583", "LastEditDate": "2013-04-02T17:37:58.190", "ViewCount": "1058", "FavoriteCount": "1", "Title": "template class in enclosing namespace as friend", "Id": "15770451", "Score": "3", "Body": "<p>I have code with the following basic structure</p>\n<pre><code>namespace my {\n  template&lt;typename&gt; class A;              // forward declaration\n  namespace details {\n    template&lt;typename T&gt; class B\n    {\n      const T*const t;\n      B(const T*x) : t(x) {}               // non-public constructor\n      template&lt;typename&gt; friend class A;   // friend declaration\n    };\n  }\n  template&lt;typename T&gt; class A\n  {\n    T*const t;\n  public:\n    A(T*x) : t(x) {}\n    details::B&lt;T&gt; makeb() const            // offending method:\n    { return details::B&lt;T&gt;(t); }           //   calls non-public constructor\n  };\n}\n</code></pre>\n<p>which compiled fine under gcc (4.7 &amp; 4.8, using <code>-std=c++11</code>) and icpc (13.1), but not clang (using <code>-std=c++11 -stdlib=libc++</code>), which complains about usage of a non-public constructor (when instantinating the offending method). It turns out that clang is happy if the friend declaration gives the full qualified name, as in</p>\n<pre><code>template&lt;typename&gt; friend class my::A;\n</code></pre>\n<p>Is this a bug of clang? I would have thought that any visible symbol in the enclosing namespace <code>my</code> is available <em>without further qualification</em> in the inner namespace <code>my::details</code>. What does the 2011 standard say?</p>\n", "Tags": "<c++><templates><namespaces><clang><friend>", "OwnerUserId": "1023390", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_15770451_15770612_0": {"section_id": 5485, "quality": 0.8909090909090909, "length": 98}}, "n3337": {"so_15770451_15770612_0": {"section_id": 5271, "quality": 0.8818181818181818, "length": 97}}, "n4659": {"so_15770451_15770612_0": {"section_id": 6920, "quality": 0.8272727272727273, "length": 91}}}, "15770612": {"ParentId": "15770451", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I think Clang is right:</p>\n<blockquote>\n<h3>7.3.1.2 Namespace member definitions [namespace.memdef]</h3>\n<p id=\"so_15770451_15770612_0\"><sup>3</sup> Every name first declared in a namespace is a member of that namespace. If a <code>friend</code> declaration in a non-local class first declares a class, function, class template or function template the friend is a member of the innermost enclosing namespace. The name of the friend is not found by unqualified lookup (3.4.1) or by qualified lookup (3.4.3) until a matching declaration is provided in that namespace scope (either before or after the class definition granting friendship). If a friend function or function template is called, its name may be found by the name lookup that considers functions from namespaces and classes associated with the types of the function arguments (3.4.2). If the name in a <code>friend</code> declaration is neither qualified nor a <em>template-id</em> and the declaration is a function or an <em>elaborated-type-specifier</em>, <strong>the lookup to determine whether the entity has been previously declared shall not consider any scopes outside the innermost enclosing namespace</strong>. [ <em>Note:</em> The other forms of friend declarations cannot declare a new member of the innermost enclosing namespace and thus follow the usual lookup rules. \u2014 <em>end note</em> ] [ <em>Example:</em></p>\n</blockquote>\n<pre><code>// Assume f and g have not yet been declared.\nvoid h(int);\ntemplate &lt;class T&gt; void f2(T);\nnamespace A {\n  class X {\n    friend void f(X);         // A::f(X) is a friend\n    class Y {\n      friend void g();        // A::g is a friend\n      friend void h(int);     // A::h is a friend\n                              // ::h not considered\n      friend void f2&lt;&gt;(int);  // ::f2&lt;&gt;(int) is a friend\n    };\n  };\n\n  // A::f, A::g and A::h are not visible here\n  X x;\n  void g() { f(x); }          // definition of A::g \n  void f(X) { /* ...  */}     // definition of A::f \n  void h(int) { /* ...  */ }  // definition of A::h\n  // A::f, A::g and A::h are visible here and known to be friends\n}\n\nusing A::x;\n\nvoid h() {\n  A::f(x);\n  A::X::f(x);      // error: f is not a member of A::X\n  A::X::Y::g();    // error: g is not a member of A::X::Y\n}\n</code></pre>\n<blockquote>\n<p id=\"so_15770451_15770612_1\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>Note the <code>// ::h not considered</code>.</p>\n", "OwnerUserId": "2073257", "LastEditorUserId": "2073257", "LastEditDate": "2013-04-02T17:48:22.583", "Id": "15770612", "Score": "4", "CreationDate": "2013-04-02T17:39:24.323", "LastActivityDate": "2013-04-02T17:48:22.583"}});