post_cb({"bq_ids": {"n4140": {"so_22258054_22259156_0": {"length": 18, "quality": 1.0, "section_id": 239}}, "n3337": {"so_22258054_22259156_0": {"length": 18, "quality": 1.0, "section_id": 231}}, "n4659": {"so_22258054_22259156_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 248}}}, "22259156": {"Id": "22259156", "PostTypeId": "2", "Body": "<p>I remember a WG21 core discussion about this, and one of the Clang developers defended their position by citing 14.7.1p7</p>\n<blockquote>\n<p id=\"so_22258054_22259156_0\">If the overload resolution process can determine the correct function to call without instantiating a class template definition, it is unspecified whether that instantiation actually takes place. </p>\n</blockquote>\n<p>On the other hand, for an ill-formed program (which is the case here when doing the required instantiation), there is no such notion of \"the correct function to call\", so I agree to the position of another guy in that discussion who said that he can't see that this allows Clang to go that route.</p>\n<p>In the example of p7 it shows code that is well-formed both with and without doing the additional instantiation.</p>\n<p><em>In any case</em>, even if Clang is allowed to do it, the well-formedness of your program would then rely on particular happenstances (unspecified behavior). The Standard therefore doesn't anymore require your program to be accepted, and honestly I don't know what that means. I regard such code as being ill-formed.</p>\n", "LastEditorUserId": "147192", "LastActivityDate": "2014-03-07T19:52:58.360", "Score": "16", "CreationDate": "2014-03-07T19:37:23.687", "ParentId": "22258054", "CommentCount": "13", "OwnerUserId": "34509", "LastEditDate": "2014-03-07T19:52:58.360"}, "22258054": {"ViewCount": "682", "Body": "<p>I came across a C++ inconsistency between <code>gcc</code> (versions <code>4.8.1</code>, <code>4.8.2</code>) and <code>clang</code> (versions <code>3.3</code>, <code>3.4</code>). I wonder which one is correct. Here's the program:</p>\n<pre><code>template &lt; typename T &gt; struct Result {};\ntemplate &lt; typename T &gt; struct Empty {};\n\ntemplate &lt; typename T &gt;\nstruct Bad_Type_Fcn {\n    typedef typename Empty&lt; T &gt;::type type;\n};\n\ntemplate &lt; typename T &gt;\nResult&lt; T &gt;\nf( const T&amp; ) {\n    return Result&lt; T &gt;();\n}\n\ntemplate&lt; class U &gt;\nResult&lt; typename Bad_Type_Fcn&lt; U &gt;::type &gt;\nf( const U&amp;, int ) {\n    return Result&lt; typename Bad_Type_Fcn&lt; U &gt;::type &gt;();\n}\n\nint main() {\n    (void)f&lt; int &gt;(42);\n}\n</code></pre>\n<p>Clearly, this code is not meant to do anything; it is an aggressive simplification of something that appears in the Boost Range library (with <code>f</code> simplifying <code>make_iterator_range</code>). The <code>Bad_Type_Fcn</code> is a type function (technically, a <code>struct</code>) which should never be instantiated, because <code>Empty&lt;T&gt;::type</code> never exists, for any <code>T</code>. The presence of this <code>struct</code> and of the second template specialization of <code>f()</code> is not an error in itself. IRL, <code>f()</code> provides some functionality for certain types for which <code>Bad_Type_Fcn</code> is not empty. However that is not the concern here, which is why I simplified those out. I still want <code>f()</code> to work for types where <code>Bad_Type_Fcn</code> is empty.</p>\n<p>I'm compiling with <code>{g++|clang++} [-std=c++0x] -pedantic -Wall -Wextra -c</code>. The language standard selection doesn't seem to make a difference. With <code>clang</code>, the program compiles without errors or warnings. With <code>gcc</code>, I get an error:</p>\n<pre><code>weird.cpp: In instantiation of \u2018struct Bad_Type_Fcn&lt;int&gt;\u2019:\nweird.cpp:17:5:   required by substitution of \u2018template&lt;class U&gt; Result&lt;typename Bad_Type_Fcn&lt;T&gt;::type&gt; f(const U&amp;, int) [with U = int]\u2019\nweird.cpp:22:26:   required from here\nweird.cpp:6:43: error: no type named \u2018type\u2019 in \u2018struct Empty&lt;int&gt;\u2019\n         typedef typename Empty&lt; T &gt;::type type;\n</code></pre>\n<p>What seems to be happening is that <code>clang</code> eliminates the second overload of <code>f()</code>, probably(?) on the basis that the call is made with 1 argument only, integer <code>42</code>, while the second overload requires 2 arguments. On the other hand, <code>gcc</code> doesn't eliminate the second overload, and instead tries to instantiate <code>struct Bad_Type_Fcn&lt;int&gt;</code>, which results in an error.</p>\n<p>The inconsistency disappears if I remove the explicit instantiation in the call to <code>f()</code>, and write <code>(void)f(42);</code> instead.</p>\n<p>Which of the compilers is correct?</p>\n", "AcceptedAnswerId": "22259156", "Title": "C++ inconsistency between gcc and clang", "CreationDate": "2014-03-07T18:36:53.097", "Id": "22258054", "CommentCount": "15", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-03-07T19:05:20.650", "LastEditorUserId": "1782465", "LastActivityDate": "2014-03-07T19:52:58.360", "Score": "27", "OwnerUserId": "717706", "Tags": "<c++><gcc><clang><language-lawyer><template-specialization>", "AnswerCount": "1"}});