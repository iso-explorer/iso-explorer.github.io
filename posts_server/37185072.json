post_cb({"bq_ids": {"n4140": {"so_37185072_37185298_2": {"length": 22, "quality": 1.0, "section_id": 480}}, "n3337": {"so_37185072_37185298_2": {"length": 19, "quality": 0.8636363636363636, "section_id": 471}}, "n4659": {"so_37185072_37185298_2": {"length": 22, "quality": 1.0, "section_id": 502}}}, "37186126": {"Id": "37186126", "PostTypeId": "2", "Body": "<p>This is pretty well documented in <a href=\"http://www.agner.org/optimize/calling_conventions.pdf\" rel=\"nofollow\">Agner Fog's Calling Conventions document</a>, \u00a7 7.1 Passing and returning objects, Table 7. Methods for returning structure, class and union objects.</p>\n<blockquote>\n<p id=\"so_37185072_37186126_0\">A struct, class or union object can be returned from a function in registers only if it is sufficiently small and not too complex. If the object is too complex or doesn't fit into the appropriate registers then the caller must supply storage space for the object and pass a pointer to this space as a parameter to the function. The pointer can be passed in a register or on the stack. The same pointer is returned by the function. The detailed rules are given in table 7.</p>\n</blockquote>\n<p>In other words, large return objects get constructed directly in the caller supplied buffer (on the caller's stack). </p>\n<p>An extra copy is still required if the identity of the object to return is not known at compile time, e.g.:</p>\n<pre><code>foo func(bool a) {\n    foo x, y;\n    // fill x and y\n    return a ? x : y; // copying is required here\n}\n</code></pre>\n", "LastEditorUserId": "412080", "LastActivityDate": "2016-05-12T12:18:01.577", "Score": "2", "CreationDate": "2016-05-12T11:54:33.713", "ParentId": "37185072", "CommentCount": "0", "OwnerUserId": "412080", "LastEditDate": "2016-05-12T12:18:01.577"}, "37185072": {"ViewCount": "205", "Body": "<p>Assuming I have a <code>struct</code> in C/C++ with fixed size array members, for example:</p>\n<pre><code>#define SIZE 10000\nstruct foo{\n  int vector_i[SIZE];\n  float vector_f[SIZE];\n};\n</code></pre>\n<p>and I would like to create a function that will return an instance of <code>foo</code>, like:</p>\n<pre><code>foo func(int value_i, float value_f){\n  int i;\n  foo f;\n  for(i=0;i&lt;SIZE;i++) f.vector_i[i] = value_i;\n  for(i=0;i&lt;SIZE;i++) f.vector_f[i] = value_f;\n  return f;\n}\n</code></pre>\n<p>If I call the function using:</p>\n<pre><code>foo ff = func(1,1.1);\n</code></pre>\n<p>will the compiler perform some kind of optimization (ie TCO)?</p>\n<p>Will the executable fill directly <code>ff</code> variable, or it will fill first <code>f</code> of <code>func</code> and then copy all values from <code>f</code> to <code>ff</code>?</p>\n<p>How can I check if the optimization is performed?</p>\n", "AcceptedAnswerId": "37185298", "Title": "Will the compiler optimize functions which return structures with fixed size arrays?", "CreationDate": "2016-05-12T11:05:23.043", "Id": "37185072", "CommentCount": "20", "LastEditDate": "2016-05-12T13:24:08.710", "PostTypeId": "1", "LastEditorUserId": "1162141", "LastActivityDate": "2016-05-12T13:24:08.710", "Score": "7", "OwnerUserId": "2707697", "Tags": "<c++><c><struct><return-value><return-value-optimization>", "AnswerCount": "2"}, "37185298": {"Id": "37185298", "PostTypeId": "2", "Body": "<p>My answer applies to c++.</p>\n<blockquote>\n<p id=\"so_37185072_37185298_0\">Will the compiler perform some kind of optimization (ie TCO)?</p>\n</blockquote>\n<p>By TCO do you mean \"tail call optimization\"? The function doesn't make a function call at the end (a tail call, if you will), so that optimization doesn't apply.</p>\n<p>The compiler <em>can</em> <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow\">elide</a> the copy from the return value to the temporary due to named return value optimization. The copy-initialization from the temporary can also be elided.</p>\n<hr>\n<blockquote>\n<p id=\"so_37185072_37185298_1\">How can I check if the optimization is performed?</p>\n</blockquote>\n<p>By reading the generated assembly code.</p>\n<p>If you can't read assembly, another approach would be to add copy and move constructors that have side effects and observe whether those side effects occur. However, modifying the program can have effect on whether the compiler decides to optimize (but side effects are not required to prevent copy elision).</p>\n<hr>\n<p>If you don't want to rely on optimization, you should explicitly pass an exiting object to the function by reference (pointer in c), and modify it in place.</p>\n<hr>\n<p>Standard reference for copy elision <a href=\"http://eel.is/c++draft/class.copy#31\" rel=\"nofollow\">[class.copy] \u00a731 (current standard draft)</a></p>\n<blockquote>\n<p id=\"so_37185072_37185298_2\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the constructor selected for the copy/move operation and/or the destructor for the object have side effects. [...]</p>\n</blockquote>\n<p>The section describes the criteria, which are met in this case. The quote was generated from the standard document draft at 2016-04-07. Numbering may vary across different versions of the standard document and rules have slightly changed. The quoted part has been unchanged since c++03, where the section is [class.copy] \u00a715.</p>\n</hr></hr></hr>", "LastEditorUserId": "2079303", "LastActivityDate": "2016-05-12T13:16:18.817", "Score": "6", "CreationDate": "2016-05-12T11:15:47.520", "ParentId": "37185072", "CommentCount": "14", "OwnerUserId": "2079303", "LastEditDate": "2016-05-12T13:16:18.817"}});