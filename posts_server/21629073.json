post_cb({"21629073": {"CommentCount": "3", "ViewCount": "203", "PostTypeId": "1", "ClosedDate": "2014-02-08T08:53:18.863", "LastEditorUserId": "1708801", "CreationDate": "2014-02-07T13:32:01.710", "LastActivityDate": "2017-04-04T13:05:42.747", "Title": "Why can I construct a string with multiple string literals?", "AcceptedAnswerId": "21629191", "LastEditDate": "2014-02-09T04:02:41.643", "Id": "21629073", "Score": "3", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string str = \"hello \" \"world\" \"!\";\n    std::cout &lt;&lt; str;\n}\n</code></pre>\n<p>The following compiles, runs, and prints:</p>\n<blockquote>\n<p id=\"so_21629073_21629073_0\">hello world!</p>\n</blockquote>\n<p><a href=\"http://ideone.com/6oIexf\" rel=\"nofollow\">see live</a></p>\n<hr>\n<p>It seems as though the string literals are being concatenated together, but interestingly this can not be done with <code>operator +</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string str = \"hello \" + \"world\";\n    std::cout &lt;&lt; str;\n}\n</code></pre>\n<p>This will fail to compile.<br>\n<a href=\"http://ideone.com/DHU5aY\" rel=\"nofollow\">see live</a></br></p>\n<hr>\n<p>Why is this behavior in the language?  My theory is that it is allows strings to be constructed with multiple <code>#include</code> statements because <code>#include</code> statements are required to be on their own line.  Is this behavior simply possible due to the grammar of the language, or is it an exception that was added to help solve a problem?</p>\n</hr></hr>", "Tags": "<c++><string><concatenation><grammar><string-literals>", "OwnerUserId": "908939", "AnswerCount": "5"}, "21629195": {"ParentId": "21629073", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Like @erenon said, the compiler will merge multiple string literals into one, which is especially helpful if you want to use multiple lines like so:</p>\n<pre><code>cout &lt;&lt; \"This is a very long string-literal, \"\n        \"which for readability in the code \"\n        \"is divided over multiple lines.\";\n</code></pre>\n<p>However, when you try to concatenate string-literals together using <code>operator+</code>, the compiler will complain because there is no <code>operator+</code> defined for two <code>char const *</code>'s. The operator <strong>is</strong> defined for the <code>string</code> class (which is totally different from C-strings), so it is legal to do this:</p>\n<pre><code>string str = string(\"Hello \") + \"world\";\n</code></pre>\n", "OwnerUserId": "1428839", "LastEditorUserId": "1242646", "LastEditDate": "2017-04-04T13:05:42.747", "Id": "21629195", "Score": "7", "CreationDate": "2014-02-07T13:37:49.443", "LastActivityDate": "2017-04-04T13:05:42.747"}, "21629191": {"ParentId": "21629073", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Adjacent string literals are concatenated we can see this in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">draft C++ standard</a> section <code>2.2</code> <em>Phases of translation</em> paragraph <em>6</em> which says:</p>\n<blockquote>\n<p id=\"so_21629073_21629191_0\">Adjacent string literal tokens are concatenated</p>\n</blockquote>\n<p>In your other case, there is no <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator%2B\" rel=\"nofollow noreferrer\">operator+</a> defined to take two *const char**.</p>\n<p>As to why, this comes from <em>C</em> and we can go to the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf\" rel=\"nofollow noreferrer\">Rationale for International Standard\u2014Programming Languages\u2014C</a> and it says in section <code>6.4.5</code> <em>String literals</em>:</p>\n<blockquote>\n<p id=\"so_21629073_21629191_1\">A string can be continued across multiple lines by using the backslash\u2013newline line continuation, but this requires that the continuation of the string start in the first position of the next line. To permit more flexible layout, and to solve some preprocessing problems (see \u00a76.10.3), the C89 Committee introduced string literal concatenation. Two string literals in a row are pasted together, with no null character in the middle, to make one combined string literal. This addition to the C language allows a programmer to extend a string literal beyond the end of a physical line without having to use the backslash\u2013newline mechanism and thereby destroying the indentation scheme of the program. An explicit concatenation operator was not introduced because the concatenation is a lexical construct rather than a run-time operation.</p>\n</blockquote>\n<p>without this feature you would have to do this to continue a string literal over multiple lines:</p>\n<pre><code>   std::string str = \"hello \\\nworld\\\n!\";\n</code></pre>\n<p>which is pretty ugly.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-02-08T01:50:13.540", "Id": "21629191", "Score": "10", "CreationDate": "2014-02-07T13:37:40.897", "LastActivityDate": "2014-02-08T01:50:13.540"}, "21629313": {"ParentId": "21629073", "CommentCount": "0", "Body": "<p>In the first example, the consecutive string literals are concatenated by magic, before compilation has properly started. The compiler sees a single literal, as if you'd written <code>\"hello world!\"</code>.</p>\n<p>In the second example, once compilation has begun, the literals become static arrays. You can't apply <code>+</code> to two arrays.</p>\n<blockquote>\n<p id=\"so_21629073_21629313_0\">Why is this behavior in the language?</p>\n</blockquote>\n<p>This is a legacy of C, which comes from a time when memory was a precious resource. It allows you to do quite a lot of string manipulation without requiring dynamic memory allocation (as more modern idioms like <code>std::string</code> often do); the price for that is some rather quirky semantics.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "21629313", "Score": "0", "CreationDate": "2014-02-07T13:43:02.240", "LastActivityDate": "2014-02-07T13:43:02.240"}, "21629176": {"ParentId": "21629073", "CommentCount": "0", "Body": "<p>When the compiler sees <code>\"hello \" + \"world\";</code> is looking for a global <code>+</code> operator which takes two <code>const char*</code> ... And since by default there is none it fails.</p>\n<p>The <code>\"hello \" \"world\" \"!\"</code> is resolved by the compiler as a single string. This allows you to have concatenated strings written over multiple lines .</p>\n", "OwnerUserId": "186193", "PostTypeId": "2", "Id": "21629176", "Score": "0", "CreationDate": "2014-02-07T13:37:01.603", "LastActivityDate": "2014-02-07T13:37:01.603"}, "bq_ids": {"n4140": {"so_21629073_21629191_0": {"section_id": 5313, "quality": 1.0, "length": 5}}, "n3337": {"so_21629073_21629191_0": {"section_id": 5110, "quality": 1.0, "length": 5}}, "n4659": {"so_21629073_21629191_0": {"section_id": 6737, "quality": 1.0, "length": 5}}}, "21629100": {"ParentId": "21629073", "CommentCount": "0", "Body": "<p>The compiler concatenates the string literals automatically into a single one.</p>\n", "OwnerUserId": "116273", "PostTypeId": "2", "Id": "21629100", "Score": "2", "CreationDate": "2014-02-07T13:33:18.273", "LastActivityDate": "2014-02-07T13:33:18.273"}});