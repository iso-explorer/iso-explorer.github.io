post_cb({"15899369": {"CommentCount": "17", "AcceptedAnswerId": "15899370", "CreationDate": "2013-04-09T10:21:13.043", "LastActivityDate": "2013-04-09T18:20:31.110", "PostTypeId": "1", "ViewCount": "2425", "FavoriteCount": "3", "Title": "Does `decltype` give me an object's static type, or its runtime type?", "Id": "15899369", "Score": "11", "Body": "<blockquote>\n<p id=\"so_15899369_15899369_0\"><code>[C++11: 7.1.6.2/4]:</code> The type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<ul>\n<li>if <code>e</code> is an unparenthesized <em>id-expression</em> or an unparenthesized class member access (5.2.5), <code>decltype(e)</code> is the type of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code> names a set of overloaded functions, the program is ill-formed;</li>\n<li>otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;</li>\n<li>otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;</li>\n<li>otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</li>\n</ul>\n<p id=\"so_15899369_15899369_1\">The operand of the <code>decltype</code> specifier is an unevaluated operand (Clause 5).</p>\n</blockquote>\n<p>The second, third and fourth cases clearly refer to the type of the expression, which would not include any polymorphism considerations.</p>\n<p>However, and I'm not entirely sure what \"<em>entity</em>\" means here, the <em>first</em> case appears to be naming the <em>object</em> refered to by the expression <code>e</code>. It is ambiguous to me as to whether \"the type of the entity\" means its runtime type, or its static type.</p>\n", "Tags": "<c++><c++11><language-lawyer><decltype>", "OwnerUserId": "560648", "AnswerCount": "3"}, "15908015": {"ParentId": "15899369", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-04-09T17:00:43.510", "Score": "0", "LastEditorUserId": "34509", "LastEditDate": "2013-04-09T18:20:31.110", "Id": "15908015", "OwnerUserId": "34509", "Body": "<p>It's basically a question of what \"entity\" means here (the possible meanings are defined in clause 3). Consider</p>\n<pre><code>struct A {\n  int a;\n};\n\nint main() {\n  A a = {};\n  const A b = {};\n\n  const A *aptr = (rand() % 42) ? &amp;a : &amp;b;\n  decltype(aptr-&gt;a) x = 0;\n  decltype((aptr-&gt;a)) y = 0;\n}\n</code></pre>\n<p>Is <code>x</code>'s type <code>const int</code> or <code>int</code>? If you take <em>entity</em> to mean \"member\", it is <code>int</code> because the member <code>A::a</code> has type <code>int</code>. If you take the entity kind \"object\", then the type is either <code>const int</code> or <code>int</code>, depending on the result of <code>rand()</code>. Objects, their existence and properties (including their type in general) is a runtime issue.</p>\n<p>I say that this is not a real ambiguity. Because everyone knows what is meant and because the Standard uses the phrase \"named by e\" rather than \"referred to by e\" or \"denoted by e\" indicating that it is only the name lookup result that it is consulted.</p>\n<p>Note that the type of <code>y</code> is <em>always</em> <code>const int&amp;</code>, because the type of the expression <code>aptr-&gt;a</code> is <code>const int</code> and it is an lvalue.</p>\n", "LastActivityDate": "2013-04-09T18:20:31.110"}, "15900599": {"ParentId": "15899369", "CommentCount": "7", "CreationDate": "2013-04-09T11:26:13.943", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "15900599", "Score": "5", "Body": "<p>You don't have to look into the individual points: the results\nof <code>decltype</code> are a type known to the compiler, which pretty\nmuch excludes any dynamic typing.  And the last line that you\nquote couldn't be more explicit: the specifier is not evaluated,\nwhich also excludes any dynamic typing.</p>\n", "LastActivityDate": "2013-04-09T11:26:13.943"}, "15899370": {"ParentId": "15899369", "PostTypeId": "2", "CommentCount": "13", "CreationDate": "2013-04-09T10:21:13.043", "Score": "9", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:32:23.620", "Id": "15899370", "OwnerUserId": "560648", "Body": "<p>It's actually impossible to run into this problem, due to the restraints of that first case.</p>\n<p>Consider:</p>\n<pre><code>struct A     {};\nstruct B : A {};\n\nint main()\n{\n   A* x = new B();\n   // What is `decltype(*x)`?\n}\n</code></pre>\n<p>The use of <code>*</code> makes us fall through to the third case.</p>\n<p>And for references?</p>\n<pre><code>struct A     {};\nstruct B : A {};\n\nint main()\n{\n   A&amp; x = *(new B());\n   // What is `decltype(x)`?\n}\n</code></pre>\n<p><code>x</code> is a reference with type <code>A&amp;</code>, and it is <em>this</em> \"entity\" whose type results.</p>\n<p>The only way to use the first case is by directly naming an object, and we cannot do that in a way that hides a runtime type:</p>\n<pre><code>struct A     {};\nstruct B : A { void foo() {} };\n\nint main()\n{\n   A x = B();     // well, you've sliced it now, innit?\n\n   decltype(x) y;\n   y.foo();       // error: \u2018struct A\u2019 has no member named \u2018foo\u2019\n}\n</code></pre>\n<p><strong>This is why, according to <a href=\"https://stackoverflow.com/questions/10424337/does-c11s-decltype-make-clone-unecessary\">these answers</a>, it is always the <em>static type</em> of an object that is used.</strong></p>\n", "LastActivityDate": "2013-04-09T11:26:16.980"}, "bq_ids": {"n4140": {"so_15899369_15899369_1": {"section_id": 5440, "quality": 0.8571428571428571, "length": 6}, "so_15899369_15899369_0": {"section_id": 5440, "quality": 0.625, "length": 5}}, "n3337": {"so_15899369_15899369_1": {"section_id": 5235, "quality": 0.8571428571428571, "length": 6}, "so_15899369_15899369_0": {"section_id": 5235, "quality": 0.625, "length": 5}}, "n4659": {"so_15899369_15899369_1": {"section_id": 6867, "quality": 0.8571428571428571, "length": 6}, "so_15899369_15899369_0": {"section_id": 6867, "quality": 0.625, "length": 5}}}});