post_cb({"12324515": {"Id": "12324515", "PostTypeId": "2", "Body": "<p>Why not putting a log class in it's own namespace and using <code>typedef namespace::log logger;</code> to avoid name clashes in a more convenient way?</p>\n", "LastActivityDate": "2012-09-07T19:51:45.270", "CommentCount": "1", "CreationDate": "2012-09-07T19:51:45.270", "ParentId": "12324302", "Score": "6", "OwnerUserId": "1328718"}, "12324346": {"Id": "12324346", "PostTypeId": "2", "Body": "<p>No, the solution that you are considering is not allowed. In practice what it means is that you are changing the meaning of the header file. You are changing all of its declarations to declare differently named functions.</p>\n<p>These altered declarations won't match the actual names of the standard library functions so, at link time, none of the standard library functions will resolve calls to the functions declared by the altered declarations unless they happen to have been declared <code>extern \"C\"</code> which is allowed - but not recommended - for names which come from the C standard library.</p>\n<p>ISO/IEC 14882:2011 17.6.2.2/3 [using.headers] applies to the C standard library headers as they are part of the C++ standard library:</p>\n<blockquote>\n<p id=\"so_12324302_12324346_0\">A translation unit shall include a header only outside of any external declaration or definition[*], and shall include the header lexically before the first reference in that translation unit to any of the entities declared in that header.</p>\n</blockquote>\n<p>[*] which would include a namespace definition.</p>\n", "LastEditorUserId": "19563", "LastActivityDate": "2012-09-07T21:36:54.353", "Score": "18", "CreationDate": "2012-09-07T19:37:35.750", "ParentId": "12324302", "CommentCount": "5", "OwnerUserId": "19563", "LastEditDate": "2012-09-07T21:36:54.353"}, "bq_ids": {"n4140": {"so_12324302_12324346_0": {"length": 19, "quality": 1.0, "section_id": 6270}}, "n3337": {"so_12324302_12324346_0": {"length": 19, "quality": 1.0, "section_id": 6030}}, "n4659": {"so_12324302_12324346_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 7776}}}, "12324302": {"ViewCount": "1726", "Body": "<blockquote>\n<p id=\"so_12324302_12324302_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/6670738/is-it-a-good-idea-to-wrap-an-include-in-a-namespace-block\">Is it a good idea to wrap an #include in a namespace block?</a> </br></p>\n</blockquote>\n<p>I've got a project with a class <code>log</code> in the global namespace (<code>::log</code>).</p>\n<p>So, naturally, after <code>#include &lt;cmath&gt;</code>, the compiler gives an error message each time I try to instantiate an object of my log class, because <code>&lt;cmath&gt;</code> pollutes the global namespace with lots of three-letter methods, one of them being the logarithm function <code>log()</code>.</p>\n<p>So there are three possible solutions, each having their unique ugly side-effects.</p>\n<ul>\n<li>Move the log class to it's own namespace and always access it with it's fully qualified name. I really want to avoid this because the logger should be as convenient as possible to use.</li>\n<li>Write a <code>mathwrapper.cpp</code> file which is the only file in the project that includes <code>&lt;cmath&gt;</code>, and makes all the required <code>&lt;cmath&gt;</code> functions available through wrappers in a <code>namespace math</code>. I don't want to use this approach because I have to write a wrapper for every single required math function, and it would add additional call penalty (cancelled out partially by the <code>-flto</code> compiler flag)</li>\n<li>The solution I'm currently considering:</li>\n</ul>\n<p>Replace</p>\n<pre><code>#include &lt;cmath&gt;\n</code></pre>\n<p>by</p>\n<pre><code>namespace math {\n#include \"math.h\"\n}\n</code></pre>\n<p>and then calculating the logarithm function via <code>math::log()</code>.</p>\n<p>I have tried it out and it does, indeed, compile, link and run as expected. It does, however, have multiple downsides:</p>\n<ul>\n<li>It's (obviously) impossible to use <code>&lt;cmath&gt;</code>, because the <code>&lt;cmath&gt;</code> code accesses the functions by their fully qualified names, and it's deprecated to use  in C++.</li>\n<li>I've got a really, really bad feeling about it, like I'm <a href=\"http://xkcd.com/292/\" rel=\"nofollow noreferrer\">gonna get attacked and eaten alive by raptors.</a></li>\n</ul>\n<p>So my question is:</p>\n<ul>\n<li>Is there any recommendation/convention/etc that forbid putting include directives in namespaces?</li>\n<li><p>Could anything go wrong with</p>\n<ul>\n<li>diferent C standard library implementations (I use glibc),</li>\n<li>different compilers (I use g++ 4.7, -std=c++11),</li>\n<li>linking?</li>\n</ul></li>\n<li>Have you ever tried doing this?</li>\n<li>Are there any alternate ways to banish the math functions from the global namespace?</li>\n</ul>\n<p>I've found several similar questions on stackoverflow, but most were about including other C++ headers, which obviously is a bad idea, and those that weren't made contradictory statements about linking behaviour for C libraries. Also, would it be beneficial to additionally put the <code>#include &lt;math.h&gt;</code> inside <code>extern \"C\" {}</code>?</p>\n<p><strong>edit</strong></p>\n<p>So I decided to do what probably everyone else is doing, and put all of my code in a project namespace, and to access the logger with it's fully qualified name when including <code>&lt;cmath&gt;</code>.</p>\n", "AcceptedAnswerId": "12324346", "Title": "Is it OK to put a standard, pure C header #include directive inside a namespace?", "CreationDate": "2012-09-07T19:33:55.907", "Id": "12324302", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:24:38.840", "LastEditorUserId": "-1", "LastActivityDate": "2012-09-08T03:11:34.157", "ClosedDate": "2012-09-08T09:36:47.803", "Score": "13", "OwnerUserId": "1347646", "Tags": "<c++><namespaces><include>", "AnswerCount": "4"}, "12325430": {"Id": "12325430", "PostTypeId": "2", "Body": "<p>It is ugly hack too, but I believe will not cause any linker problems. Just redefine log name from <code>&lt;math.h&gt;</code></p>\n<pre><code> #define log math_log\n #include &lt;math.h&gt;\n #undef log\n</code></pre>\n<p>It could cause problems with inline functions from math using this log, but maybe you'd be lucky...</p>\n<p>Math log() is still accessible but it's not easy. Within functions where you want to use it, just repeat its real declaration:</p>\n<pre><code>    int somefunc() {\n        double log(double); // not sure if correct\n        return log(1.1);\n    }\n</code></pre>\n", "LastEditorUserId": "1463922", "LastActivityDate": "2012-09-08T03:11:34.157", "Score": "2", "CreationDate": "2012-09-07T21:08:58.067", "ParentId": "12324302", "CommentCount": "4", "OwnerUserId": "1463922", "LastEditDate": "2012-09-08T03:11:34.157"}, "12325421": {"Id": "12325421", "PostTypeId": "2", "Body": "<p><a href=\"http://news.softpedia.com/news/Steve-Jobs-to-Dev-We-ll-Get-Off-Your-Back-Just-Rename-Your-App-127559.shtml\" rel=\"nofollow\">Change your class's name. Not that big of a deal.</a> ;-)</p>\n<p>Seriously though, it's not a great idea to put names in the global namespace that collide with names from <em>any</em> standard header. C++03 didn't explicitly permit <code>&lt;cmath&gt;</code> to define <code>::log</code>. But implementations were chronically non-conforming about that due to the practicalities of defining <code>&lt;cmath&gt;</code> on top of an existing <code>&lt;math.h&gt;</code> (and perhaps also an existing static-link library for some headers, including math). So C++11 ratifies existing practice, and allows <code>&lt;cmath&gt;</code> to dump everything into the global namespace. C++11 also reserves all those names for use with extern \"C\" linkage, and all function signatures for use with C++ linkage, even if you don't include the header. But more on that later.</p>\n<p>Because in C++ any standard header is allowed to define the names from any other standard header (i.e, they're allowed to include each other), this means that any standard header at all can define <code>::log</code>. So don't use it.</p>\n<p>The answer to your question about different implementations is that even if your scheme works to begin with (which isn't guaranteed), in some other implementation there might be a header that you use (or want to use in future in the same TU as your log class), that includes <code>&lt;cmath&gt;</code>, and that you didn't give the <code>namespace math</code> treatment to. Off the top of my head, <code>&lt;random&gt;</code> seems to me a candidate. It provides a whole bunch of continuous random number distributions that plausibly could be implemented inline with math functions.</p>\n<p>I suggest <code>Log</code>, but then I like capitalized class names. Partly because they're always distinct from standard types and functions.</p>\n<p>Another possibility is to define your class as before and use <code>struct log</code> in place of <code>log</code>. This doesn't clash with the function, for reasons that only become clear if you spend way too much time with the C and C++ standards (you only use <code>log</code> as a <em>class</em> name, not as a function and not as a name with \"C\" linkage, so you don't infringe on the reserved name. Despite all appearances to the contrary, class names in C++ still inhabit a parallel universe from other names, rather like <code>struct</code> tags do in C).</p>\n<p>Unfortunately <code>struct log</code> isn't a simple-type-identifier, so for example you can't create a temporary with <code>struct log(VERY_VERBOSE, TO_FILE)</code>. To define a simple-type-identifier:</p>\n<pre><code>typedef struct log Log;\nLog(VERY_VERBOSE, TO_FILE); // unused temporary object\n</code></pre>\n<p>An example of what I say in a comment below, based on a stated example usage. I <em>think</em> this is valid, but I'm not certain:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing std::log; // to enforce roughly what the compiler does anyway\n\nenum Foo {\n    foo, bar\n};\n\nstd::ostream &amp;log(Foo f) { return std::cout; }\n\nint main() {\n    log(foo) &lt;&lt; log(10) &lt;&lt; \"\\n\";\n}\n</code></pre>\n", "LastEditorUserId": "13005", "LastActivityDate": "2012-09-07T22:51:13.513", "Score": "2", "CreationDate": "2012-09-07T21:08:16.727", "ParentId": "12324302", "CommentCount": "7", "OwnerUserId": "13005", "LastEditDate": "2012-09-07T22:51:13.513"}});