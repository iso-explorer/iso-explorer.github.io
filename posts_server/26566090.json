post_cb({"bq_ids": {"n4140": {"so_26566090_26566275_6": {"length": 8, "quality": 0.8, "section_id": 6085}, "so_26566090_26566275_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 6085}, "so_26566090_26566275_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 393}, "so_26566090_26566275_1": {"length": 14, "quality": 0.6666666666666666, "section_id": 6084}, "so_26566090_26566275_3": {"length": 7, "quality": 0.6363636363636364, "section_id": 6085}}, "n3337": {"so_26566090_26566275_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 5853}, "so_26566090_26566275_1": {"length": 14, "quality": 0.6666666666666666, "section_id": 5852}, "so_26566090_26566275_6": {"length": 8, "quality": 0.8, "section_id": 5853}, "so_26566090_26566275_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 384}, "so_26566090_26566275_3": {"length": 7, "quality": 0.6363636363636364, "section_id": 5853}}, "n4659": {"so_26566090_26566275_6": {"length": 8, "quality": 0.8, "section_id": 7581}, "so_26566090_26566275_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 410}, "so_26566090_26566275_1": {"length": 14, "quality": 0.6666666666666666, "section_id": 7580}, "so_26566090_26566275_3": {"length": 6, "quality": 0.5454545454545454, "section_id": 7581}, "so_26566090_26566275_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 7581}}}, "26566090": {"ViewCount": "94", "Body": "<p>I have run into the following code</p>\n<pre><code>int main() {\n    int **objects; \n    objects=new (int(*[10])); // seems to be equal to new int*[10];\n    delete[] objects;\n    return 0;\n}\n</code></pre>\n<p>I have not managed to parse the line \"new (int(*[10]))\".\nI am used to standard syntax \"new int*[10]\" and totally surprised with the one above.</p>\n<p>Could you explain me why this \"new (int(*[10]))\" is correct and does the same as \"new int*[10]\"?</p>\n", "AcceptedAnswerId": "26566275", "Title": "operator new syntax for array of pointers", "CreationDate": "2014-10-25T18:59:38.400", "Id": "26566090", "CommentCount": "2", "LastEditDate": "2014-10-25T19:08:55.657", "PostTypeId": "1", "LastEditorUserId": "253056", "LastActivityDate": "2014-10-25T19:18:30.953", "Score": "2", "OwnerUserId": "2950316", "Tags": "<c++>", "AnswerCount": "1"}, "26566275": {"Id": "26566275", "PostTypeId": "2", "Body": "<p>Here are the two grammatical constructions at work, straight from <code>[C++11: 5.3.4]</code>:</p>\n<blockquote>\n<p id=\"so_26566090_26566275_0\"><em>new-expression</em>:<br>\n<code>::</code><sub>opt</sub><code>new</code> <em>new-placement</em><sub>opt</sub> <em>new-type-id</em> <em>new-initializer</em><sub>opt</sub><br>\n<code>::</code><sub>opt</sub><code>new</code> <em>new-placement</em><sub>opt</sub><code>(</code> <em>type-id</em> <code>)</code> <em>new-initializer</em><sub>opt</sub></br></br></p>\n</blockquote>\n<p>You're used to the former but have encountered the latter. Let's take a closer look at that one; what is <em>type-id</em> and how does it differ from <em>new-type-id</em>?</p>\n<blockquote>\n<p id=\"so_26566090_26566275_1\"><code>[C++11: 5.3.4/3]:</code> The <em>new-type-id</em> in a <em>new-expression</em> is the longest possible sequence of <em>new-declarators.</em> <em>[ Note:</em> this prevents ambiguities between the declarator operators &amp;, &amp;&amp;, *, and [] and their expression counterparts. <em>\u2014end note ] [ Example:</em></p>\n<pre><code>new int * i; // syntax error: parsed as (new int*) i, not as (new int)*i\n</code></pre>\n<p id=\"so_26566090_26566275_2\">The * is the pointer declarator and not the multiplication operator. <em>\u2014end example ]</em></p>\n</blockquote>\n<p>So, you see, this is why <code>new (int(*[10]))</code> is valid but <code>new int(*[10])</code> is not: the outer parenthesis allows <code>5.3.4/3</code> to kick in.</p>\n<p>This is actually addressed in the following passage, as is the validity of the inner parenthesis in an example <em>very</em> similar to yours:</p>\n<blockquote>\n<p id=\"so_26566090_26566275_3\"><code>[C++11: 5.3.4/4]:</code> <em>[ Note:</em> parentheses in a <em>new-type-id</em> of a <em>new-expression</em> can have surprising effects. <em>[ Example:</em></p>\n<pre><code>new int(*[10])(); // error\n</code></pre>\n<p id=\"so_26566090_26566275_4\">is ill-formed because the binding is</p>\n<pre><code>(new int) (*[10])(); // error\n</code></pre>\n<p id=\"so_26566090_26566275_5\">Instead, the explicitly parenthesized version of the new operator can be used to create objects of compound types (3.9.2):</p>\n<pre><code>new (int (*[10])());\n</code></pre>\n<p id=\"so_26566090_26566275_6\">allocates an array of 10 pointers to functions (taking no argument and returning <code>int</code>.) <em>\u2014end example ]</em></p>\n<p id=\"so_26566090_26566275_7\"><em>\u2014end note ]</em></p>\n</blockquote>\n<p>In your case, although you are using pointers rather than pointers-to-functions (note the additional <code>()</code> in the above quote examples), your <code>int (*[10])</code> is still a compound type and thus the same logic applies.</p>\n<p>Finally, <code>int (*[10])</code> is the same as <code>int* [10]</code> because <em>it just is</em>: that's how the syntax of <em>type-id</em> constructions works:</p>\n<pre><code>&lt;tomalak&gt; &lt;&lt; TYPE_DESC&lt;int (*[10])&gt;;\n&lt;geordi&gt; array of 10 pointers to integers\n&lt;tomalak&gt; &lt;&lt; TYPE_DESC&lt;int* [10]&gt;;\n&lt;geordi&gt; Same output.\n</code></pre>\n<p><em>(using <a href=\"http://www.eelis.net/geordi/\">geordi</a>)</em></p>\n", "LastActivityDate": "2014-10-25T19:18:30.953", "Score": "7", "CreationDate": "2014-10-25T19:18:30.953", "ParentId": "26566090", "CommentCount": "0", "OwnerUserId": "560648"}});