post_cb({"bq_ids": {"n4140": {"so_38304847_38316977_0": {"length": 4, "quality": 0.8, "section_id": 175}, "so_38304847_38316977_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 5382}}, "n3337": {"so_38304847_38316977_0": {"length": 5, "quality": 1.0, "section_id": 169}, "so_38304847_38316977_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 5176}}, "n4659": {"so_38304847_38316977_0": {"length": 5, "quality": 1.0, "section_id": 180}, "so_38304847_38316977_2": {"length": 17, "quality": 1.0, "section_id": 6806}}}, "38316977": {"Id": "38316977", "PostTypeId": "2", "Body": "<p><strong><em>Edit:</em></strong> I'm keeping this self-answer with examples and more detailed explanations of the misunderstandings that lead to this questions. The short answer by T.C. is strictly enough.</p>\n<p>After rereading the proposal and on <code>static_assert</code> in the <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4594.pdf\" rel=\"nofollow\">current draft</a>, and  I conclude that my worries were misguided. First of all, the emphasis here should be on template <em>definition</em>.</p>\n<blockquote>\n<p id=\"so_38304847_38316977_0\">ill-formed; no diagnostic required for template definition</p>\n</blockquote>\n<p>If a template is <em>instantiated</em>, any <code>static_assert</code> fire as expected. This presumably plays well with the statement I quoted: </p>\n<blockquote>\n<p id=\"so_38304847_38316977_1\">... a discarded statement is not instantiated.</p>\n</blockquote>\n<p>This is a bit vague to me, but I conclude that it means that <em>templates</em> occurring in the discarded statement will not be instantiated. Other code \nhowever must be syntactically valid. A <code>static_assert(F)</code>, [where F is false, either literally or a constexpr value] inside a discarded <code>if constexpr</code> clause will thus still 'bite' when the template containing the <code>static_assert</code> is instantiated. Or (not required, at the mercy of the compiler) already at declaration if it's known to always be false.</p>\n<p>Examples: (<a href=\"http://melpon.org/wandbox/permlink/I78eDUSk5sDjepEK\" rel=\"nofollow\">live demo</a>)</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt; typename T&gt;\nconstexpr void some_library_foo(){\n    static_assert(std::is_same&lt;T,int&gt;::value);\n}\n\ntemplate&lt; typename T&gt;\nconstexpr void other_library_bar(){\n    static_assert(std::is_same&lt;T,float&gt;::value);\n}\n\ntemplate&lt; typename T&gt;\nconstexpr void buzz(){\n    // This template is ill-formated, (invalid) no diagnostic required,\n    // since there are no T which could make it valid. (As also mentioned\n    // in the answer by T.C.).\n    // That also means that neither of these are required to fire, but\n    // clang does (and very likely all compilers for similar cases), at\n    // least when buzz is instantiated.\n    static_assert(! std::is_same&lt;T,T&gt;::value);\n    static_assert(false); // does fire already at declaration\n                          // with latest version of clang\n}\n\ntemplate&lt;class T, bool IntCase&gt;\nvoid g() {\n  if constexpr (IntCase){\n    some_library_foo&lt;T&gt;();\n\n    // Both two static asserts will fire even though within if constexpr:\n    static_assert(!IntCase) ;  // ill-formated diagnostic required if \n                              // IntCase is true\n    static_assert(IntCase) ; // ill-formated diagnostic required if \n                              // IntCase is false\n\n    // However, don't do this:\n    static_assert(false) ; // ill-formated, no diagnostic required, \n                           // for the same reasons as with buzz().\n\n  } else {\n    other_library_bar&lt;T&gt;();\n  }      \n}\n\nint main(){\n    g&lt;int,true&gt;();\n    g&lt;float,false&gt;();\n\n    //g&lt;int,false&gt;(); // ill-formated, diagnostic required\n    //g&lt;float,true&gt;(); // ill-formated, diagnostic required\n}\n</code></pre>\n<p>The standard text on <code>static_assert</code> is remarkably short. In standardese, it's a way to make the program <em>ill-formed</em> with diagnostic (as @immibis also pointed out):</p>\n<blockquote>\n<p id=\"so_38304847_38316977_2\">7.6 ... If the value of the expression when so converted is true, the declaration has no effect. Otherwise, the program is ill-formed, and\n  the resulting diagnostic message (1.4) shall include the text of the\n  string-literal, if one is supplied ...</p>\n</blockquote>\n", "LastEditorUserId": "1149664", "LastActivityDate": "2016-07-12T19:35:04.243", "Score": "2", "CreationDate": "2016-07-11T22:06:38.140", "ParentId": "38304847", "CommentCount": "0", "OwnerUserId": "1149664", "LastEditDate": "2016-07-12T19:35:04.243"}, "38317834": {"Id": "38317834", "PostTypeId": "2", "Body": "<p>This is talking about a well-established rule for templates - the same rule that allows compilers to diagnose <code>template&lt;class&gt; void f() { return 1; }</code>. <a href=\"http://eel.is/c++draft/temp#res-8\">[temp.res]/8</a> with the new change bolded:</p>\n<blockquote>\n<p id=\"so_38304847_38317834_0\">The program is ill-formed, no diagnostic required, if:</p>\n<ul>\n<li>no valid specialization can be generated for a template <strong>or a substatement\n  of a <code>constexpr if</code> statement ([stmt.if]) within a\n  template</strong> and the template is not instantiated, or</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>No valid specialization can be generated for a template containing <code>static_assert</code> whose condition is nondependent and evaluates to <code>false</code>, so the program is ill-formed NDR.</p>\n<p><code>static_assert</code>s with a dependent condition that can evaluate to <code>true</code> for at least one type are not affected.</p>\n", "LastActivityDate": "2016-07-11T23:38:29.543", "CommentCount": "4", "CreationDate": "2016-07-11T23:38:29.543", "ParentId": "38304847", "Score": "12", "OwnerUserId": "2756719"}, "38304847": {"ViewCount": "3643", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0292r1.html\">P0292R1 constexpr if</a> has been <a href=\"https://herbsutter.com/2016/06/30/trip-report-summer-iso-c-standards-meeting-oulu/\">included</a>, on track for C++17. It seems useful (and can replace use of SFINAE), but a comment regarding <code>static_assert</code> being <em>ill-formed, no diagnostic required</em> in the false branch scares me:</p>\n<pre><code>Disarming static_assert declarations in the non-taken branch of a\nconstexpr if is not proposed.\n\nvoid f() {\n  if constexpr (false)\n    static_assert(false);   // ill-formed\n}\n\ntemplate&lt;class T&gt;\nvoid g() {\n  if constexpr (false)\n    static_assert(false);   // ill-formed; no \n               // diagnostic required for template definition\n}\n</code></pre>\n<p>I take it that it's completely forbidden to use <code>static_assert</code> inside constexpr if (at least the false / non-taken branch, but that in practice means it's not a safe or useful thing to do).</p>\n<p>How does this come about from the standard text? I find no mentioning of <code>static_assert</code> in the proposal wording, and C++14 constexpr functions do allow <code>static_assert</code> (details at cppreference: <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\">constexpr</a>).</p>\n<p>Is it hiding in this new sentence (after 6.4.1) ? : </p>\n<blockquote>\n<p id=\"so_38304847_38304847_0\">When a constexpr if statement appears in a templated entity, \n     during an instantiation of the enclosing template or generic lambda, \n     a discarded statement is not instantiated.</p>\n</blockquote>\n<p>From there on, I assume that it is also forbidden, no diagnostic required, to call other constexpr (template) functions which <em>somewhere</em> down the call graph may call <code>static_assert</code>. </p>\n<p><strong>Bottom line:</strong> </p>\n<p>If my understanding is correct, doesn't that put a quite hard limit on the safety and usefulness of <code>constexpr if</code> as we would have to know (from documentation or code inspection) about any use of <code>static_assert</code>? Are my worries misplaced?</p>\n<p><strong>Update:</strong></p>\n<p>This code compiles without warning (clang head 3.9.0) but is to my understanding <em>ill-formed</em>, no diagnostic required. Valid or not?</p>\n<pre><code>template&lt; typename T&gt;\nconstexpr void other_library_foo(){\n    static_assert(std::is_same&lt;T,int&gt;::value);\n}\n\ntemplate&lt;class T&gt;\nvoid g() {\n  if constexpr (false)\n    other_library_foo&lt;T&gt;(); \n}\n\nint main(){\n    g&lt;float&gt;();\n    g&lt;int&gt;();\n}\n</code></pre>\n", "AcceptedAnswerId": "38317834", "Title": "constexpr if and static_assert", "CreationDate": "2016-07-11T10:38:11.240", "Id": "38304847", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-07-11T21:35:50.123", "LastEditorUserId": "1149664", "LastActivityDate": "2016-07-12T19:35:04.243", "Score": "19", "OwnerUserId": "1149664", "Tags": "<c++><templates><constexpr><c++1z><static-assert>", "AnswerCount": "2"}});