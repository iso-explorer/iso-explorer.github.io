post_cb({"384001": {"Id": "384001", "PostTypeId": "2", "Body": "<p>It's so not-guaranteed that students used to try to hide the fact that they were playing Rogue on the school mainframe by writing C programs that would start it with argv[0] of \"cc\" or \"tcsh\".</p>\n", "OwnerDisplayName": "chaos", "LastActivityDate": "2008-12-21T02:04:02.020", "Score": "3", "CreationDate": "2008-12-21T02:04:02.020", "ParentId": "383973", "CommentCount": "1", "OwnerUserId": "47529"}, "383976": {"Body": "<p>It is not always. It's the value that you gave the program by the Operation System. For example when starting a program using <code>exec</code> you can set that to an arbitrary value:</p>\n<pre><code>int execve(const char *filename, char *const argv[],\n           char *const envp[]);\n</code></pre>\n<p>The first parameter is the file to start, and argv will contains argv[0] and all other parameters for main. envp contains the environment variables (not defined by Standard C or C++. This is a posix thing). </p>\n<p>More precisely, this is the definition of argv in C++:</p>\n<blockquote>\n<p id=\"so_383973_383976_0\">An implementation shall not predefine the main function. This function shall not be overloaded. It shall\n  have a return type of type int, but otherwise its type is implementation-defined. All implementations\n  shall allow both of the following definitions of main:</p>\n</blockquote>\n<pre><code>int main() { /* ... */ }\n</code></pre>\n<blockquote>\n<p id=\"so_383973_383976_1\">and</p>\n</blockquote>\n<pre><code>int main(int argc, char* argv[]) { /* ... */ }\n</code></pre>\n<blockquote>\n<p id=\"so_383973_383976_2\">In the latter form argc shall be the number of arguments passed to the program from the environment in\n  which the program is run. If argc is nonzero these arguments shall be supplied in <code>argv[0]</code> through\n  <code>argv[argc-1]</code> as pointers to the initial characters of null-terminated multibyte strings (NTMBSs)\n  (17.3.2.1.3.2) and <code>argv[0]</code> shall be the pointer to the initial character of a NTMBS that represents the\n  name used to invoke the program or \"\". The value of argc shall be nonnegative. The value of\n  <code>argv[argc]</code> shall be 0. [Note: it is recommended that any further (optional) parameters be added after\n  argv. ]</p>\n</blockquote>\n<p>It's pretty much up to the implementation what defines a \"name used to invoke the program\". If you want to get the full path of your executable, you can use <a href=\"http://msdn.microsoft.com/en-us/library/ms683197%28VS.85%29.aspx\" rel=\"noreferrer\">GetModuleFileName</a> on Windows, and <code>argv[0]</code> (for getting the name used to execute, may be relative) together with <code>getcwd</code> (for getting the current working directory, trying to make the name absolute).</p>\n", "CreationDate": "2008-12-21T01:26:08.790", "ParentId": "383973", "CommentCount": "4", "LastEditDate": "2009-01-19T13:42:25.013", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2009-01-19T13:42:25.013", "LastEditorUserId": "34509", "Id": "383976", "OwnerDisplayName": "litb", "Score": "21", "OwnerUserId": "34509"}, "383986": {"Id": "383986", "PostTypeId": "2", "Body": "<p>Here's what the C standard says that <code>argv[0]</code> should be:</p>\n<blockquote>\n<p id=\"so_383973_383986_0\">If the value of <code>argc</code> is greater than\n  zero, the string pointed to by\n  <code>argv[0]</code> represents the program name;\n  <code>argv[0][0]</code> shall be the null\n  character if the program name is not\n  available from the host environment.</p>\n</blockquote>\n<p>As for whether it contains the full path, the answer is that argv[0] does not necessarily contain the full path to the executable.  On Windows it seems to be exactly what was provided on the command line. Dunno what Linux/Unix does.</p>\n", "OwnerDisplayName": "Michael Burr", "LastActivityDate": "2008-12-21T01:40:40.600", "Score": "2", "CreationDate": "2008-12-21T01:40:40.600", "ParentId": "383973", "CommentCount": "0", "OwnerUserId": "12711"}, "bq_ids": {"n4140": {"so_383973_383976_2": {"length": 40, "quality": 0.8695652173913043, "section_id": 7146}, "so_383973_383976_0": {"length": 18, "quality": 0.75, "section_id": 7146}}, "n3337": {"so_383973_383976_2": {"length": 40, "quality": 0.8695652173913043, "section_id": 6890}, "so_383973_383976_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 6890}}, "n4659": {"so_383973_383976_2": {"length": 40, "quality": 0.8695652173913043, "section_id": 8647}, "so_383973_383976_0": {"length": 18, "quality": 0.75, "section_id": 8647}}}, "383994": {"Id": "383994", "PostTypeId": "2", "Body": "<p>No. On Windows GetModuleFileName gurantees the exact full path to the current executing program. On linux there is a symlink /proc/self/exe. Do a readlink on this symlink to get the full path of the currently executing program. Even if youprogram was called thorugh a symlink /proc/self/exe will always point to the actuall program.</p>\n", "OwnerDisplayName": "Ctrl Alt D-1337", "LastActivityDate": "2008-12-21T01:48:22.910", "Score": "5", "CreationDate": "2008-12-21T01:48:22.910", "ParentId": "383973", "CommentCount": "0", "OwnerUserId": "36157"}, "383973": {"ViewCount": "5521", "Body": "<p>This is a fundamental question, but an important one none the less...</p>\n<p><strong>When starting a C++ program whose main method has the following common signature:</strong></p>\n<pre><code>int main(int argc, char* args[]) {\n    //Magic!\n    return 0;\n}\n</code></pre>\n<p><strong>is args[0] always guaranteed to be the path to the currently running program? What about cross platform (since I am in a Linux environment but may port later on.)?</strong></p>\n", "AcceptedAnswerId": "383976", "Title": "Is args[0] guaranteed to be the path of execution?", "CreationDate": "2008-12-21T01:21:43.977", "Id": "383973", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "OwnerDisplayName": "s13james", "LastActivityDate": "2009-01-19T13:42:25.013", "Score": "8", "OwnerUserId": "3552", "Tags": "<c++>", "AnswerCount": "4"}});