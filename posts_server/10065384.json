post_cb({"11498358": {"ParentId": "10065384", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to the <a href=\"http://clang.llvm.org/compatibility.html#undep_incomplete\" rel=\"nofollow noreferrer\">clang docs</a> also already linked, they are not willing to support incomplete types for stl containers in libc++.  </p>\n<p>Something funny that stems from this is the following code will not compile with libc++:</p>\n<pre><code>#include &lt;list&gt;\n\nstruct Tree {\n    // ... more stuff ...\n    std::list&lt;Tree&gt; mChildren;\n};\n</code></pre>\n<p>but this code compiles fine, because list's template parameter also depends on a template parameter:</p>\n<pre><code>template&lt;typename T&gt;\nstruct TreeT {\n    // ... more stuff ...\nprivate:\n    std::list&lt;TreeT&lt;T&gt; &gt; mChildren;\n};\n</code></pre>\n<p>This strikes me as odd, since the latter is more complex.</p>\n<p>On a similar <a href=\"https://stackoverflow.com/a/8333633/506584\">post</a>, which also contains a reference to the ISO section concerning incomplete types in templates, <a href=\"http://www.boost.org/doc/libs/1_48_0/doc/html/container/containers_of_incomplete_types.html\" rel=\"nofollow noreferrer\">Boost.Container</a> is mentioned as an alternative because it explicitly allows recursive data structures.  I came across this post while diagnosing a similar problem and this is my solution for now.</p>\n", "OwnerUserId": "506584", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:04:43.653", "Id": "11498358", "Score": "2", "CreationDate": "2012-07-16T05:02:34.307", "LastActivityDate": "2012-07-17T02:18:48.987"}, "10065384": {"CommentCount": "2", "ViewCount": "1475", "CreationDate": "2012-04-08T18:45:08.230", "LastActivityDate": "2012-07-17T02:18:48.987", "Title": "Instantiation of a list with an incomplete type in a typedef", "AcceptedAnswerId": "11514677", "PostTypeId": "1", "Id": "10065384", "Score": "3", "Body": "<p>I have a problem with compiling llvm. The problem is that my current compiler (clang + libc++) tries to instantiate a template before the template parameter gets defined. Here is the code example:</p>\n<pre><code>// ----- TYPEDEFS -----\nclass NodeEntry;\nclass EdgeEntry;\n\ntypedef std::list&lt;NodeEntry&gt; NodeList;\ntypedef std::list&lt;EdgeEntry&gt; EdgeList;\n\ntypedef NodeList::iterator NodeItr; // line 39 \ntypedef NodeList::const_iterator ConstNodeItr;\n\ntypedef EdgeList::iterator EdgeItr;\ntypedef EdgeList::const_iterator ConstEdgeItr;\n\ntypedef std::list&lt;EdgeItr&gt; AdjEdgeList;\n\ntypedef AdjEdgeList::iterator AdjEdgeItr;\n\nclass NodeEntry {\nprivate:  \n  AdjEdgeList adjEdges;\n  ...\n};\n\nclass EdgeEntry {\nprivate:\n  AdjEdgeItr node1AEItr, node2AEItr;\n  ...\n};\n</code></pre>\n<p>The error from the compiler is this:</p>\n<pre><code>error: field has incomplete type 'PBQP::Graph::NodeEntry'\n\n/Developer/Extras/llvm/include/llvm/CodeGen/PBQP/Graph.h:39:13: note: in instantiation of template class\n  'std::__1::list&lt;PBQP::Graph::NodeEntry, std::__1::allocator&lt;PBQP::Graph::NodeEntry&gt; &gt;' requested here\ntypedef NodeList::iterator NodeItr;\n        ^\n/Developer/Extras/llvm/include/llvm/CodeGen/PBQP/Graph.h:31:11: note: forward declaration of 'PBQP::Graph::NodeEntry'\nclass NodeEntry;\n</code></pre>\n<p>As far as I can tell the compiler tries to instantiate <code>std::list&lt;NodeEntry&gt;</code> in order to get the iterator. This fails as NodeEntry is not defined yet. And of course EdgeEntry is using NodeEntry and vice versa.</p>\n<p>The obvious question is: How do I fix it?<br>\nThe educational question is: Why does the compiler try to instantiate the template when defining the type? Should it not wait until we do something with the list?</br></p>\n<p>Thanks.</p>\n", "Tags": "<templates><typedef><clang><libc++>", "OwnerUserId": "1013568", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_10065384_11514677_0": {"section_id": 6324, "quality": 1.0, "length": 5}}, "n3337": {"so_10065384_11514677_0": {"section_id": 6081, "quality": 1.0, "length": 5}}, "n4659": {"so_10065384_11514677_0": {"section_id": 7834, "quality": 1.0, "length": 5}}}, "11514677": {"ParentId": "10065384", "CommentCount": "0", "Body": "<p>If you want guaranteed support for incomplete types, your best bet is to create <code>unique_ptr</code>'s to them:</p>\n<pre><code>typedef std::list&lt;std::unique_ptr&lt;NodeEntry&gt;&gt; NodeList;\ntypedef std::list&lt;std::unique_ptr&lt;EdgeEntry&gt;&gt; EdgeList;\n</code></pre>\n<p>In the past, many times <code>std::list&lt;incomplete_type&gt;</code> would just work.  However with C++11 and <code>noexcept</code> specifications, it is becoming more likely that a complete type is needed, just so that the <code>noexcept</code> spec can be validated.</p>\n<p>C++11 guarantees that <code>unique_ptr&lt;incomplete_type&gt;</code> and <code>shared_ptr&lt;incomplete_type&gt;</code> will work, although there are strict limits.  For example wherever <code>~unique_ptr()</code> is executed, the type has to be complete there.  But you can usually outline such code to a source and #include the complete type at that point.</p>\n<p><code>unique_ptr&lt;incomplete_type&gt;</code> and <code>shared_ptr&lt;incomplete_type&gt;</code> are the only class templates in the C++11 std::lib that are guaranteed to work with incomplete types.  Everything else is undefined behavior:</p>\n<p>[res.on.functions]/p2/b5:</p>\n<blockquote>\n<p id=\"so_10065384_11514677_0\">In particular, the effects are undefined in the following cases:</p>\n<p id=\"so_10065384_11514677_1\">...</p>\n<ul>\n<li>if an incomplete type (3.9) is used as a template argument when instantiating a template component, unless specifically allowed for that component.</li>\n</ul>\n</blockquote>\n<p>If for some reason the <code>std::list</code> does not need to own the pointer to the incomplete type, then <code>std::list&lt;NodeEntry*&gt;</code> would work even better.  You might also want to entertain using <code>vector</code> instead of <code>list</code> since the cost of moving pointers (or even <code>unique_ptr</code>'s) around is relatively small.</p>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "11514677", "Score": "3", "CreationDate": "2012-07-17T00:55:36.323", "LastActivityDate": "2012-07-17T00:55:36.323"}});