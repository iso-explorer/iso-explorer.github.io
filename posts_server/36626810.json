post_cb({"bq_ids": {"n4140": {"so_36626810_36629498_0": {"length": 13, "quality": 0.8125, "section_id": 5937}}, "n3337": {"so_36626810_36629498_0": {"length": 13, "quality": 0.8125, "section_id": 5709}}, "n4659": {"so_36626810_36629498_0": {"length": 13, "quality": 0.8125, "section_id": 7421}}}, "36626993": {"Id": "36626993", "PostTypeId": "2", "Body": "<p>This is an optimisation that's perfectly valid for correct code. Your code isn't correct.</p>\n<p>What GCC sees is that the only way the loop exit condition <code>i &gt;= maxOuter</code> could ever be reached is if you have signed integer overflow during earlier loop iterations in your calculation of <code>sum</code>. The compiler assumes there isn't signed integer overflow, because signed integer overflow isn't allowed in standard C. Therefore, <code>i &lt; maxOuter</code> can be optimised to just <code>true</code>.</p>\n<p>This is controlled by the <code>-faggressive-loop-optimizations</code> flag. You should be able to get the behaviour you expect by adding <code>-fno-aggressive-loop-optimizations</code> to your command line arguments. But better would be making sure your code is valid. Use unsigned integer types to get guaranteed valid wraparound behaviour.</p>\n", "LastActivityDate": "2016-04-14T15:02:29.667", "CommentCount": "0", "CreationDate": "2016-04-14T15:02:29.667", "ParentId": "36626810", "Score": "11", "OwnerUserId": "743382"}, "36626906": {"Id": "36626906", "PostTypeId": "2", "Body": "<p>Your code invokes undefined behaviour, since the int sum overflows. You say \"this shouldn't in any way affect the other variables\". Wrong. Once you have undefined behaviour, all odds are off. Anything can happen. </p>\n<p>gcc is (in)famous for optimisations that assume there is no undefined behaviour and do let's say interesting things if undefined behaviour happens. </p>\n<p>Solution: Don't do it. </p>\n", "LastActivityDate": "2016-04-14T14:58:30.513", "CommentCount": "0", "CreationDate": "2016-04-14T14:58:30.513", "ParentId": "36626810", "Score": "11", "OwnerUserId": "3255455"}, "36629498": {"Id": "36629498", "PostTypeId": "2", "Body": "<h2>Answers</h2>\n<p>As @hvd pointed out, the problem is in your invalid code, not in the compiler.</p>\n<p>During your program execution, the <code>sum</code> value overflows <code>int</code> range. Since <code>int</code> is by default <code>signed</code> and overflow of <code>signed</code> values causes undefined behavior* in C, the compiler is free to do anything. As someone noted somewhere, dragons could be flying out of your nose. The result is just undefined.</p>\n<p>The difference <code>-O2</code> causes is in testing the end condition. When the compiler optimizes your loop, it realizes that it can optimize away the inner loop, making it</p>\n<pre><code>int sum = 0;\nfor(int i = 0; i &lt; maxOuter; i++) {\n    sum += maxInner;\n    std::cout&lt;&lt;\"i = \"&lt;&lt;i&lt;&lt;\" sum = \"&lt;&lt;sum&lt;&lt;std::endl;\n}\n</code></pre>\n<p>and it may go further, transforming it to</p>\n<pre><code>int i = 0;\nfor(int sum = 0; sum &lt; (maxInner * maxOuter); sum += maxInner) {\n    i++;\n    std::cout&lt;&lt;\"i = \"&lt;&lt;i&lt;&lt;\" sum = \"&lt;&lt;sum&lt;&lt;std::endl;\n}\n</code></pre>\n<p><em>To be honest, I don't really know what it <strong>does</strong>, the point is, it <strong>can</strong> do just this. Or anything else, remember the dragons, your program causes <strong>undefined</strong> behavior.</em></p>\n<p>Suddenly, your <code>sum</code> variable is used in the loop end condition. <em>Note that for defined behavior, these optimizations are perfectly valid. If your <code>sum</code> was <code>unsigned</code> (and your <code>maxInner</code> and <code>maxOuter</code>), the <code>(maxInner * maxOuter)</code> value (which would also be <code>unsigned</code>) would be reached after <code>maxOuter</code> loops, because <code>unsigned</code> operations are defined** to overflow as expected.</em></p>\n<p>Now since we're in the <code>signed</code> domain, the compiler is for one free to assume, that at all times <code>sum &lt; (maxInner * maxOuter)</code>, just because the latter overflows, and therefore is not defined. So the optimizing compiler can end up with something like</p>\n<pre><code>int i = 0;\nfor(int sum = 0;/* nothing here evaluates to true */; sum += maxInner) {\n    i++;\n    std::cout&lt;&lt;\"i = \"&lt;&lt;i&lt;&lt;\" sum = \"&lt;&lt;sum&lt;&lt;std::endl;\n}\n</code></pre>\n<p>which looks like observed behavior.</p>\n<p><em>*</em>: According to the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">C11 standard draft</a>, section 6.5 Expressions:</p>\n<blockquote>\n<p id=\"so_36626810_36629498_0\">If an exceptional condition occurs during the evaluation of an expression (that is, if the result is not mathematically defined or not in the range of representable values for its type), the behavior is undefined.</p>\n</blockquote>\n<p><em>**</em>: According to the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">C11 standard draft</a>, Annex H, H.2.2:</p>\n<blockquote>\n<p id=\"so_36626810_36629498_1\">C\u2019s unsigned integer types are \u2018\u2018modulo\u2019\u2019 in the LIA\u22121 sense in that overflows or out-of-bounds results silently wrap.</p>\n</blockquote>\n<hr>\n<p>I did some research on the topic. I compiled the code above with <code>gcc</code> and <code>g++</code> (version 5.3.0 on Manjaro) and got some pretty interesting things of it.</p>\n<h2>Description</h2>\n<p>To successfully compile it with <code>gcc</code> (C compiler, that is), I have replaced</p>\n<pre><code>#include &lt;iostream&gt;\n...\nstd::cout&lt;&lt;\"i = \"&lt;&lt;i&lt;&lt;\" sum = \"&lt;&lt;sum&lt;&lt;std::endl;\n</code></pre>\n<p>with</p>\n<pre><code>#include &lt;stdio.h&gt;\n...\nprintf(\"i = %d sum = %d\\n\", i, sum);\n</code></pre>\n<p>and wrapped this replacement with <code>#ifndef ORIG</code>, so I could have both versions. Then I ran 8 compilations: {<code>gcc</code>,<code>g++</code>} x {<code>-O2</code>, <code>\"\"</code>} x {<code>-DORIG=1</code>,<code>\"\"</code>}. This yields following results:</p>\n<h2>Results</h2>\n<ol>\n<li><p><code>gcc</code>, <code>-O2</code>, <code>-DORIG=1</code>: Won't compile, missing <code>&lt;iostream&gt;</code>. <em>Not surprising</em>.</p></li>\n<li><p><code>gcc</code>, <code>-O2</code>, <code>\"\"</code>: Produces compiler warning and behaves \"normally\". A look in the assembly shows that the inner loop is optimized out (<code>j</code> being incremented by 100000000) and the outer loop variable is compared with hardcoded value -1294967296. <em>So, GCC <strong>can</strong> detect this and do some clever things while the program is working expectably. More importantly, warning is emitted to warn user about undefined behavior.</em></p></li>\n<li><p><code>gcc</code>, <code>\"\"</code>, <code>-DORIG=1</code>: Won't compile, missing <code>&lt;iostream&gt;</code>. <em>Not surprising.</em></p></li>\n<li><p><code>gcc</code>, <code>\"\"</code>, <code>\"\"</code>: Compiles without warning. No optimizations, program runs as expected.</p></li>\n<li><p><code>g++</code>, <code>-O2</code>, <code>-DORIG=1</code>: Compiles without warning, runs in endless loop. This is OP's original code running. <em>C++ assembly is tough to follow for me. Addition of 100000000 is there though.</em></p></li>\n<li><p><code>g++</code>, <code>-O2</code>, <code>\"\"</code>: Compiles <strong>with</strong> warning. It is enough to change how the output is printed to change compiler warning emiting. Runs \"normally\". <em>By the assembly, AFAIK the inner loop gets optimized out. At least there is again comparison against -1294967296 and incrementation by 100000000.</em></p></li>\n<li><p><code>g++</code>, <code>\"\"</code>, <code>-DORIG=1</code>: Compiles without warning. No optimization, runs \"normally\".</p></li>\n<li><p><code>g++</code>, <code>\"\"</code>, <code>\"\"</code>: dtto</p></li>\n</ol>\n<p>The most interesting part for me was to find out the difference upon change of printing. Actually from all the combinations, only the one used by OP produces endless-loop program, the others fail to compile, do not optimize or optimize with warning and preserve sanity.</p>\n<h2>Code</h2>\n<p>Follows example build command and my full code</p>\n<pre><code>$ gcc -x c -Wall -Wextra -O2 -DORIG=1 -o gcc_opt_orig  main.cpp\n</code></pre>\n<p>main.cpp:</p>\n<pre><code>#ifdef ORIG\n#include &lt;iostream&gt;\n#else\n#include &lt;stdio.h&gt;\n#endif\n\nint main(){\n    int sum = 0;\n    //                 Value of 100 million. (2047483648 less than int32 max.)\n    int maxInner = 100000000;\n\n    int maxOuter = 30;\n\n    // 100million * 30 = 3 billion. (Larger than int32 max)\n\n    for(int i = 0; i &lt; maxOuter; ++i)\n    {\n        for(int j = 0; j &lt; maxInner; ++j)\n        {\n            ++sum;\n        }\n#ifdef ORIG\n        std::cout&lt;&lt;\"i = \"&lt;&lt;i&lt;&lt;\" sum = \"&lt;&lt;sum&lt;&lt;std::endl;\n#else\n        printf(\"i = %d sum = %d\\n\", i, sum);\n#endif\n    }\n}\n</code></pre>\n</hr>", "LastEditorUserId": "5872193", "LastActivityDate": "2016-04-15T10:30:31.193", "Score": "6", "CreationDate": "2016-04-14T17:01:44.003", "ParentId": "36626810", "CommentCount": "8", "OwnerUserId": "5872193", "LastEditDate": "2016-04-15T10:30:31.193"}, "36626810": {"ViewCount": "550", "Body": "<p>A few days ago, I encountered what I believe to be a bug in g++ 5.3 concerning the nesting of for loops at higher <code>-OX</code> optimization levels. (Been experiencing it specifically for <code>-O2</code> and <code>-O3</code>). The issue is that if you have two nested for loops, that have some internal sum to keep track of total iterations, once this sum exceeds its maximum value it prevents the outer loop from terminating. The smallest code set that I have been able to replicate this with is: </p>\n<pre><code>int main(){\n    int sum = 0;\n    //                 Value of 100 million. (2047483648 less than int32 max.)\n    int maxInner = 100000000;\n\n    int maxOuter = 30;\n\n    // 100million * 30 = 3 billion. (Larger than int32 max)\n\n    for(int i = 0; i &lt; maxOuter; ++i)\n    {\n        for(int j = 0; j &lt; maxInner; ++j)\n        {\n            ++sum;\n        }\n        std::cout&lt;&lt;\"i = \"&lt;&lt;i&lt;&lt;\" sum = \"&lt;&lt;sum&lt;&lt;std::endl;\n    }\n}\n</code></pre>\n<p>When this is compiled using <code>g++ -o run.me main.cpp</code> it runs just as expected outputting: </p>\n<pre><code>i = 0 sum = 100000000\ni = 1 sum = 200000000\ni = 2 sum = 300000000\ni = 3 sum = 400000000\ni = 4 sum = 500000000\ni = 5 sum = 600000000\ni = 6 sum = 700000000\ni = 7 sum = 800000000\ni = 8 sum = 900000000\ni = 9 sum = 1000000000\ni = 10 sum = 1100000000\ni = 11 sum = 1200000000\ni = 12 sum = 1300000000\ni = 13 sum = 1400000000\ni = 14 sum = 1500000000\ni = 15 sum = 1600000000\ni = 16 sum = 1700000000\ni = 17 sum = 1800000000\ni = 18 sum = 1900000000\ni = 19 sum = 2000000000\ni = 20 sum = 2100000000\ni = 21 sum = -2094967296\ni = 22 sum = -1994967296\ni = 23 sum = -1894967296\ni = 24 sum = -1794967296\ni = 25 sum = -1694967296\ni = 26 sum = -1594967296\ni = 27 sum = -1494967296\ni = 28 sum = -1394967296\ni = 29 sum = -1294967296\n</code></pre>\n<p>However, when this is compiled using <code>g++ -O2 -o run.me main.cpp</code>, the outer loop fails to terminate. (This only occurs when <code>maxInner * maxOuter &gt; 2^31</code>) While sum continually overflows, it shouldn't in any way affect the other variables. I have also tested this on Ideone.com with the test case demonstrated here: <a href=\"https://ideone.com/5MI5Jb\" rel=\"nofollow noreferrer\">https://ideone.com/5MI5Jb</a></p>\n<p>My question is thus twofold. </p>\n<ol>\n<li><strong>How is it possible for the value of sum to in some way effect the system? No decisions are based upon its value, it is merely utilized for the purposes of a counter and the <code>std::cout</code> statement.</strong></li>\n<li><strong>What could possibly be causing the dramatically different outcomes at different optimization levels?</strong></li>\n</ol>\n<p><em>Thank you greatly in advance for taking the time to read and consider my question.</em></p>\n<p><em>Note: This question differs from existing questions such as: <a href=\"https://stackoverflow.com/questions/7682477/why-does-integer-overflow-on-x86-with-gcc-cause-an-infinite-loop\">Why does integer overflow on x86 with GCC cause an infinite loop?</a> because the issue with that problem was an overflow for the sentinal variable. However, both sentinal variables in this question <code>i</code> and <code>j</code> never exceed the value of 100m let alone 2^31.</em></p>\n", "AcceptedAnswerId": "36629498", "Title": "g++ optimization breaks for loops", "CreationDate": "2016-04-14T14:54:14.507", "Id": "36626810", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:15:07.033", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-15T10:30:31.193", "Score": "8", "OwnerUserId": "1658810", "Tags": "<c++><for-loop><optimization><nested-loops>", "AnswerCount": "3"}});