post_cb({"bq_ids": {"n4140": {"so_34158902_34159684_0": {"length": 27, "quality": 0.9, "section_id": 7080}, "so_34158902_34159684_1": {"length": 39, "quality": 0.8478260869565217, "section_id": 5504}}, "n3337": {"so_34158902_34159684_1": {"length": 39, "quality": 0.8478260869565217, "section_id": 5290}, "so_34158902_34159684_0": {"length": 27, "quality": 0.9, "section_id": 6824}}, "n4659": {"so_34158902_34159684_1": {"length": 32, "quality": 0.6956521739130435, "section_id": 6938}, "so_34158902_34159684_0": {"length": 27, "quality": 0.9, "section_id": 8581}}}, "34158902": {"ViewCount": "295", "Body": "<p>During resolution of an overload of a templated member function of a base class, I observed a different behaviour between g++ (5.2.1-23) and clang (3.8.0), with <code>-std=c++14</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nstruct Base\n{\n  template &lt;typename T&gt;\n  auto a(T t) -&gt; void {\n    std::cout&lt;&lt; \"False\\n\";\n  }\n};\n\ntemplate &lt;bool Bool&gt;\nstruct Derived : public Base\n{\n\n  using Base::a;\n  template &lt;typename T, bool B = Bool&gt;\n  auto a(T t) -&gt; std::enable_if_t&lt;B, void&gt;\n  {\n    std::cout&lt;&lt; \"True\\n\";\n  }\n};\n\nint main()\n{\n  Derived&lt;true&gt; d;\n  d.a(1); // fails with g++, prints \"true\" with clang\n  Derived&lt;false&gt; d2;\n  d2.a(1); // fails with clang++, prints \"false\" with g++\n}\n</code></pre>\n<p>The call to <code>Derived&lt;true&gt;::a</code> fails with g++ with the following message:</p>\n<pre><code>test.cc: In function \u2018int main()\u2019:\ntest.cc:28:8: error: call of overloaded \u2018a(int)\u2019 is ambiguous\n   d.a(1);\n        ^\ntest.cc:18:8: note: candidate: std::enable_if_t&lt;B, void&gt; Derived&lt;Bool&gt;::a(T) [with T = int; bool B = true; bool Bool = true; std::enable_if_t&lt;B, void&gt; = void]\n   auto a(T t) -&gt; std::enable_if_t&lt;B, void&gt;\n        ^\ntest.cc:7:8: note: candidate: void Base::a(T) [with T = int]\n   auto a(T t) -&gt; void {\n        ^\n</code></pre>\n<p>and the call to <code>Derived&lt;false&gt;::a</code> fails with clang++ with the following message:</p>\n<pre><code>test.cc:32:6: error: no matching member function for call to 'a'\n  d2.a(1);\n  ~~~^\n/usr/bin/../lib/gcc/x86_64-linux-gnu/5.2.1/../../../../include/c++/5.2.1/type_traits:2388:44: note: candidate template ignored: disabled by 'enable_if' [with T = int, B = false]\n    using enable_if_t = typename enable_if&lt;_Cond, _Tp&gt;::type;\n                                           ^\n</code></pre>\n<p>My guess is that they interpret differently the <code>using Base::a;</code>, and that it isn't considered in clang, whereas it's (maybe too much) considered in g++. What I thought would happen is that if <code>Derived</code> has <code>true</code> as parameter, then the call of <code>a()</code> is dispatched to <code>Derived</code>'s implementation, whereas if the parameter is <code>false</code>, the call is dispatched to <code>Base::a</code>.</p>\n<p>Are they both wrong? Who is right? Who should I submit a bug report to? Can somebody explain what is going on?</p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "34159684", "Title": "C++ Template overload with enable_if: different behaviour with g++ and clang", "CreationDate": "2015-12-08T14:51:16.253", "Id": "34158902", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-12-09T08:45:25.030", "Score": "13", "OwnerUserId": "5654919", "Tags": "<c++><templates><overloading><c++14>", "AnswerCount": "1"}, "34159684": {"Id": "34159684", "PostTypeId": "2", "Body": "<p>From 3.3.10/p3 Name hiding [basic.scope.hiding]:</p>\n<blockquote>\n<p id=\"so_34158902_34159684_0\">In a member function definition, the declaration of a name at block\n  scope hides the declaration of a member of the class with the same\n  name; see 3.3.7. <strong>The declaration of a member in a derived class\n  (Clause 10) hides the declaration of a member of a base class of the\n  same name;</strong> see 10.2  </p>\n</blockquote>\n<p>Also 7.3.3/p15 The using declaration [namespace.udecl]:</p>\n<blockquote>\n<p id=\"so_34158902_34159684_1\">When a using-declaration brings names from a base class into a derived\n  class scope, member functions and member function templates in the\n  derived class override and/or hide member functions and member\n  function templates with the same name, parameter-type-list (8.3.5),\n  cv-qualification, and ref-qualifier (if any) in a base class (rather\n  than conflicting). [ Note: For using-declarations that name a\n  constructor, see 12.9. \u2014 end note ] [Example:</p>\n<pre><code>struct B {\n  virtual void f(int);\n  virtual void f(char);\n  void g(int);\n  void h(int);\n};\nstruct D : B {\n  using B::f;\n  void f(int); // OK: D::f(int) overrides B::f(int);\n  using B::g;\n  void g(char); // OK\n  using B::h;\n  void h(int); // OK: D::h(int) hides B::h(int)\n};\nvoid k(D* p)\n{\n  p-&gt;f(1); // calls D::f(int)\n  p-&gt;f(\u2019a\u2019); // calls B::f(char)\n  p-&gt;g(1); // calls B::g(int)\n  p-&gt;g(\u2019a\u2019); // calls D::g(char)\n}\n</code></pre>\n<p id=\"so_34158902_34159684_2\">\u2014 end example ]</p>\n</blockquote>\n<p>This is resolved during member name look-up. Thus, it's before template argument deduction. Consequently, as correctly TC mentioned in the comments Base template function is hidden no matter of SFINAE verdict.</p>\n<p>Therefore CLANG is correct and GCC is wrong.</p>\n", "LastEditorUserId": "1353549", "LastActivityDate": "2015-12-09T08:45:25.030", "Score": "3", "CreationDate": "2015-12-08T15:27:39.337", "ParentId": "34158902", "CommentCount": "6", "LastEditDate": "2015-12-09T08:45:25.030", "OwnerUserId": "2352671"}});