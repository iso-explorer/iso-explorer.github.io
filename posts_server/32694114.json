post_cb({"32694233": {"ParentId": "32694114", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Atomic can be instantiated with trivially copyable types. Vector is not such a type.</p>\n", "OwnerUserId": "4764736", "LastEditorUserId": "4764736", "LastEditDate": "2015-09-21T11:39:03.990", "Id": "32694233", "Score": "3", "CreationDate": "2015-09-21T11:36:31.387", "LastActivityDate": "2015-09-21T11:39:03.990"}, "32694114": {"CommentCount": "3", "AcceptedAnswerId": "32694294", "PostTypeId": "1", "LastEditorUserId": "2577654", "CreationDate": "2015-09-21T11:30:29.443", "LastActivityDate": "2015-09-21T14:09:50.900", "LastEditDate": "2015-09-21T14:09:50.900", "ViewCount": "5783", "FavoriteCount": "1", "Title": "Can I make a thread-safe std::atomic<vector<int>>?", "Id": "32694114", "Score": "10", "Body": "<p>I'm having a function that needs to be executed <code>n=1000</code> times. This functions does a Monte Carlo style simulation and returns an <code>int</code> as the result. I'd like to run <code>nthreads=4</code> in parallel. Whenever a thread finishes one cycle, it should put the result in a <code>std::vector&lt;int&gt;</code>.\nThus, after 1000 cycles, I've a vector of 1000 <code>int</code>s that can be examined by statistics.</p>\n<p>Since a <code>std::vector</code> is not thread-safe, I thought about <code>std::mutex</code> (which would surely work).</p>\n<p>But I wonder if I can declare a vector to be atomic and thus get around mutexes?\nIs it possible to have a <code>std::atomic&lt;std::vector&lt;int&gt;&gt;</code>? And can I use <code>push_back</code> etc. on it?</p>\n", "Tags": "<c++><multithreading><c++11><vector>", "OwnerUserId": "3392714", "AnswerCount": "3"}, "32694294": {"ParentId": "32694114", "CommentCount": "2", "Body": "<p>You don't need to. It is totally okay, to access ja <code>std::vector</code> from multiple threads, if</p>\n<ul>\n<li>you read objects </li>\n<li>you write to <em>different</em> objects</li>\n</ul>\n<p>So just make sure, you create a vector of size <code>n=1000</code> and depending on your thread number (1 to 4) you assign elements 0-249, 250-499 etc. to your threads.</p>\n<p>So each of your thread computes <code>n/nthreads</code> elements.</p>\n", "OwnerUserId": "2534472", "PostTypeId": "2", "Id": "32694294", "Score": "7", "CreationDate": "2015-09-21T11:39:24.497", "LastActivityDate": "2015-09-21T11:39:24.497"}, "bq_ids": {"n4140": {"so_32694114_32694707_1": {"section_id": 7207, "quality": 0.8421052631578947, "length": 16}, "so_32694114_32694707_0": {"section_id": 1165, "quality": 0.8181818181818182, "length": 9}, "so_32694114_32694707_2": {"section_id": 4706, "quality": 1.0, "length": 4}}, "n3337": {"so_32694114_32694707_1": {"section_id": 6951, "quality": 0.8947368421052632, "length": 17}, "so_32694114_32694707_0": {"section_id": 1163, "quality": 0.8181818181818182, "length": 9}, "so_32694114_32694707_2": {"section_id": 4515, "quality": 1.0, "length": 4}}, "n4659": {"so_32694114_32694707_1": {"section_id": 8716, "quality": 0.8947368421052632, "length": 17}, "so_32694114_32694707_0": {"section_id": 57, "quality": 0.5454545454545454, "length": 6}, "so_32694114_32694707_2": {"section_id": 6103, "quality": 1.0, "length": 4}}}, "32694707": {"ParentId": "32694114", "CommentCount": "0", "Body": "<p>C++11 \u00a729.5/1 says</p>\n<blockquote>\n<p id=\"so_32694114_32694707_0\">There is a generic class template atomic. The type of the template argument T shall be trivially copyable (3.9).</p>\n</blockquote>\n<p>What does trivially copyable mean?</p>\n<p>\u00a73.9 tells</p>\n<blockquote>\n<p id=\"so_32694114_32694707_1\">Scalar types, trivially copyable class types (Clause 9), arrays of such types, and cv-qualified versions of these types (3.9.3) are collectively called trivially copyable types.</p>\n</blockquote>\n<p>For class types (of which <code>std::vector</code> is):</p>\n<blockquote>\n<p id=\"so_32694114_32694707_2\">A trivially copyable class is a class that:</p>\n<ul>\n<li>has no non-trivial copy constructors </li>\n<li>has no non-trivial move constructors</li>\n<li>has no non-trivial copy assignment operators</li>\n<li>has no non-trivial move assignment operators</li>\n<li>has a trivial destructor</li>\n</ul>\n</blockquote>\n<p>According to this list <code>std::vector</code> is not trivially copyable and so you cannot use <code>std::atomic&lt;std::vector&lt;int&gt;&gt;</code>.</p>\n<p>Since you know the size in advance and since you do not need to use methods that would require the vector be reallocated in a different location (like <code>push_back)</code>. You can use <code>std::vector&lt;int&gt;::resize</code> or the size constructor to preallocate and preconstruct the required <code>int</code>s. Therefore your concurrent threads do not need to operate on the vector itself but on the elements.</p>\n<p>If there is no access from different threads to the same element there is no race condition.</p>\n<p>The same goes for <code>int k[1000]</code> which is trivially copyable. But you do not need it to be since the threads do not change the array/vector/list itself but the elements.</p>\n", "OwnerUserId": "951423", "PostTypeId": "2", "Id": "32694707", "Score": "11", "CreationDate": "2015-09-21T12:00:37.830", "LastActivityDate": "2015-09-21T12:00:37.830"}});