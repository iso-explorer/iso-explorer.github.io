post_cb({"16607125": {"ParentId": "16606841", "CommentCount": "11", "Body": "<blockquote>\n<p id=\"so_16606841_16607125_0\">This is a necessary condition for a code to be working.</p>\n</blockquote>\n<p>No, it is not. OK, it is necessary, but it is not <em>sufficient</em>. Another necessary condition for this (very terrible) code to be working is:</p>\n<pre><code>sizeof(std::array&lt;F, N&gt;) == sizeof(F) * N;\n</code></pre>\n<p>And that is <em>not</em> guaranteed by the standard. <code>std::array</code> is not layout-compatible with C-style arrays. The <em>contents</em> of <code>std::array</code> are, but not the full type itself.</p>\n<p>If you want to initialize some object in memory you allocate in blocks of bits, you should new up a <code>char[]</code> array, not an array of <code>F</code>. You should allocate this:</p>\n<pre><code>char *a = new char[sizeof(std::array&lt;F, N&gt;)];\n</code></pre>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "16607125", "Score": "5", "CreationDate": "2013-05-17T10:45:16.533", "LastActivityDate": "2013-05-17T10:45:16.533"}, "16607068": {"ParentId": "16606841", "CommentCount": "0", "Body": "<p>Standard layout types guarantee that you can convert a pointer to them to a pointer of their first member using <code>reinterpret_cast</code>. IIRC <code>reinterpret_cast</code> can potentially return a different address than used as input (due to alignment restriction).</p>\n", "OwnerUserId": "105672", "PostTypeId": "2", "Id": "16607068", "Score": "1", "CreationDate": "2013-05-17T10:42:48.820", "LastActivityDate": "2013-05-17T10:42:48.820"}, "16606841": {"CommentCount": "2", "AcceptedAnswerId": "16607125", "PostTypeId": "1", "LastEditorUserId": "1430927", "CreationDate": "2013-05-17T10:29:54.947", "LastActivityDate": "2013-05-17T18:10:21.300", "LastEditDate": "2013-05-17T18:10:21.300", "ViewCount": "450", "FavoriteCount": "1", "Title": "What about std::array storage placement?", "Id": "16606841", "Score": "1", "Body": "<p>I want to have mechanism that allows me to concatenate variadic function parameters (all of them are convertable into value of some specific plain-old-data type <code>F</code>) into a raw data storage of appropriate size (size is greater than or equal to sum of parameters sizes). I wrote the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;new&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cassert&gt;\n#include &lt;array&gt;\n#include &lt;tuple&gt;\n\ntemplate&lt; typename F &gt;\nstruct repacker\n{\n\n    constexpr\n    repacker(F * const _storage)\n        : storage_(_storage)\n    {\n        static_assert(std::is_pod&lt; F &gt;::value, \"Underlying type is not a POD type.\");\n    }\n\n    F * const storage_;\n\n    template&lt; typename... P &gt;\n    auto operator () (P &amp;&amp; ...params) const\n    {\n        constexpr auto N = sizeof...(P);\n        using A = std::array&lt; F, N &gt;; // using A = F [N]; this eliminates the problem\n        static_assert(sizeof(A) == sizeof(F) * N, \"This compiler does not guarantee, that this code to be working.\");\n#ifndef _NDEBUG\n        auto a =\n#else\n        std::ignore =\n#endif\n                new (storage_) A{F(params)...};\n        assert(static_cast&lt; void * &gt;(a) == static_cast&lt; void * &gt;(a-&gt;data()));\n        return N;\n    }\n\n};\n\nint main()\n{\n    using F = double;\n    constexpr auto N = 6;\n    F * a = new F[N];\n    {\n        F x(1.0);\n        F const y(2.0); \n        repacker&lt; F &gt; r(a);\n        auto const M = r(x, y, 3.0, 4, 5.0f, 6.0L);\n        assert(M == N);\n    }\n    std::copy(a, a + N, std::ostream_iterator&lt; F const &amp; &gt;(std::cout, \" \"));\n    std::cout &lt;&lt; std::endl;\n    delete [] a;\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>But I am not sure that the <code>assert(static_cast&lt; void * &gt;(&amp;a) == static_cast&lt; void * &gt;(a.data()));</code> assertion is true for all the compilers. This is a necessary condition for a code to be working.</p>\n<p>Is it always the assertion is true?</p>\n", "Tags": "<c++><arrays><c++11>", "OwnerUserId": "1430927", "AnswerCount": "3"}, "16607656": {"ParentId": "16606841", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>@AndyProwl pointed out something very important:</p>\n<p><code>std::array</code> is guaranteed to be an aggregate as defined by C++11 8.5.1/1:</p>\n<blockquote>\n<p id=\"so_16606841_16607656_0\">An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no brace-or-equalinitializers for non-static data members (9.2), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>Let us test that against C++11 9/7:</p>\n<blockquote>\n<p id=\"so_16606841_16607656_1\">A <em>standard-layout</em> class is a class that:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference</li>\n</ul>\n<p id=\"so_16606841_16607656_2\">[...]</p>\n</blockquote>\n<p>Violationg this is easier than one might expect:</p>\n<pre><code>struct violator { virtual ~violator () { } };\n\ntypedef ::std::array&lt;violator, 2&gt; violated;\n</code></pre>\n<p>Here the type <code>violated</code> would have a data member that is of type array of a non-standard-layout class.</p>\n<p>Therefore the guarantee expressed in C++11 9.2/20 (that allows reinterpreting a pointer to the class as one to its first member, and is as far as I can see the only passage in the standard that might make your assumption valid) does <em>not</em> hold in all cases for <code>::std::array</code>.</p>\n", "OwnerUserId": "65678", "LastEditorUserId": "65678", "LastEditDate": "2013-05-17T13:26:59.587", "Id": "16607656", "Score": "3", "CreationDate": "2013-05-17T11:17:22.817", "LastActivityDate": "2013-05-17T13:26:59.587"}, "bq_ids": {"n4140": {"so_16606841_16607656_0": {"section_id": 3298, "quality": 0.6956521739130435, "length": 16}}, "n3337": {"so_16606841_16607656_0": {"section_id": 3168, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_16606841_16607656_0": {"section_id": 4063, "quality": 0.5217391304347826, "length": 12}}}});