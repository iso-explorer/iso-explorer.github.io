post_cb({"12175516": {"Id": "12175516", "PostTypeId": "2", "Body": "<p>It is guaranteed to be legal, given that the element type is standard-layout.  Note: all references in the following are to the <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a> standard.</p>\n<blockquote>\n<h3>8.3.4 Arrays [dcl.array]</h3>\n<p id=\"so_12138243_12175516_0\">1 - [...] An object of array type contains a contiguously allocated non-empty set of <code>N</code> subobjects of type <code>T</code>. [...]</p>\n</blockquote>\n<p>Regarding a <code>struct</code> with <code>N</code> members of type <code>T</code>,</p>\n<blockquote>\n<h3>9.2 Class members [class.mem]</h3>\n<p id=\"so_12138243_12175516_1\">14 - Nonstatic data members of a (non-union) class with the same access control are allocated so\n  that later members have higher addresses within a class object. [...] Implementation alignment requirements might\n  cause two adjacent members not to be allocated immediately after each other [...]<br/>\n  20 - A pointer to a standard-layout struct object, suitably converted using a <code>reinterpret_cast</code>, points to its\n  initial member [...] and vice versa. [ Note:\n  There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning,\n  as necessary to achieve appropriate alignment. \u2014end note ]</p>\n</blockquote>\n<p>So the question is whether any alignment-required padding within a <code>struct</code> could cause its members not to be contiguously allocated with respect to each other.  The answer is:</p>\n<blockquote>\n<h3>1.8 The C++ object model [intro.object]</h3>\n<p id=\"so_12138243_12175516_2\">4 - [...] An object of trivially copyable or standard-layout type shall occupy contiguous bytes of storage.</p>\n</blockquote>\n<p>In other words, a standard-layout <code>struct</code> <code>a</code> containing at least two members <code>x</code>, <code>y</code> of the same (standard-layout) type that does not respect the identity <code>&amp;a.y == &amp;a.x + 1</code> is in violation of 1.8:4.</p>\n<p>Note that <em>alignment</em> is defined as (<strong>3.11 Alignment [basic.align]</strong>) <em>the number of bytes between successive addresses at which a given object can be allocated</em>; it follows that alignment of a type <code>T</code> can be no greater than the distance between adjacent objects in an array of <code>T</code>, and (since <strong>5.3.3 Sizeof [expr.sizeof]</strong> specifies that <em>the size of an array of</em> n <em>elements is</em> n <em>times the size of an element</em>) <code>alignof(T)</code> can be no greater than <code>sizeof(T)</code>.  Thus any <em>additional</em> padding between adjacent elements of a struct of the same type would not be <em>required</em> by alignment and so would not be countenanced by 9.2:14.</p>\n<hr>\n<p>With regard to AProgrammer's point, I would interpret the language in <strong>26.4 Complex numbers [complex.numbers]</strong> as requiring that the instantiations of <code>std::complex&lt;T&gt;</code> should behave as standard-layout types with regard to the position of their members, without being required to conform to all the requirements of standard-layout types.</p>\n</hr>", "LastEditorUserId": "567292", "LastActivityDate": "2012-08-29T16:16:53.367", "Score": "3", "CreationDate": "2012-08-29T10:07:56.603", "ParentId": "12138243", "CommentCount": "3", "OwnerUserId": "567292", "LastEditDate": "2012-08-29T16:16:53.367"}, "12205709": {"Id": "12205709", "PostTypeId": "2", "Body": "<p>A typical alignment of C structs guarantees that the data structure members in the struct will be stored sequentially which is the same as a C array. So order cannot be a problem.</p>\n<p>As it comes to alignment, since you have only one data type(int), though the compiler is eligible to do so, there is no scenario it would be necessary to add padding to align your data members. The compiler can add padding before the beginning of the struct, but it cannot add padding at the beginning of the data structure. So if the compiler were to add padding in your situation,</p>\n<p>Instead of this:\n[4Byte int][4Byte int][4Byte int]...[4Byte int]</p>\n<p>Your data structure would have to be stored like this:<br>\n[4Byte Data]<strong>[4Byte Padding]</strong>[4Byte Data]... which is unreasonable.</br></p>\n<p>Overall, I think this cast should work with no problems in your situation, though I think it is bad practice to use it.</p>\n", "LastEditorUserId": "944181", "LastActivityDate": "2012-09-27T15:36:00.860", "Score": "1", "CreationDate": "2012-08-30T21:22:08.030", "ParentId": "12138243", "CommentCount": "0", "OwnerUserId": "1409872", "LastEditDate": "2012-09-27T15:36:00.860"}, "12138243": {"ViewCount": "1415", "Body": "<p>Just 20 minutes age when I answered a question, I come up with an interesting scenario that I'm not sure of the behavior:</p>\n<p>Let me have an integer array of size n, pointed by intPtr;</p>\n<pre><code>int* intPtr;\n</code></pre>\n<p>and let me also have a struct like this:</p>\n<pre><code>typedef struct {\nint val1;\nint val2;\n//and less or more integer declarations goes on like this(not any other type)\n}intStruct;\n</code></pre>\n<p>My question is if I do a cast <code>intStruct* structPtr = (intStruct*) intPtr;</code> </p>\n<p>Am I sure to get every element correctly if I traverse the elements of the struct? Is there any possibility of miss-alignment(possible because of padding) in any architecture/compiler?</p>\n", "AcceptedAnswerId": "12181316", "Title": "Cast A primitive type pointer to A structure pointer - Alignment and Padding?", "CreationDate": "2012-08-27T08:02:54.710", "Id": "12138243", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2012-09-27T15:36:00.860", "Score": "9", "OwnerUserId": "1038709", "Tags": "<c++><c><casting>", "AnswerCount": "6"}, "12176973": {"Id": "12176973", "PostTypeId": "2", "Body": "<p>The behavior there is almost certainly compiler-, architecture-, and ABI-dependent.  However, if you're using gcc, you can make use of <code>__attribute__((packed))</code> to force the compiler to pack struct members one after the other, without any padding.  With that, the memory layout should match that of a flat array.</p>\n", "LastActivityDate": "2012-08-29T11:33:58.417", "CommentCount": "0", "CreationDate": "2012-08-29T11:33:58.417", "ParentId": "12138243", "Score": "2", "OwnerUserId": "1626395"}, "bq_ids": {"n4140": {"so_12138243_12175516_0": {"length": 10, "quality": 1.0, "section_id": 3228}, "so_12138243_12175516_2": {"length": 9, "quality": 1.0, "section_id": 5794}, "so_12138243_12181316_0": {"length": 9, "quality": 1.0, "section_id": 5794}, "so_12138243_12181316_1": {"length": 10, "quality": 1.0, "section_id": 3228}}, "n3337": {"so_12138243_12175516_0": {"length": 10, "quality": 1.0, "section_id": 3101}, "so_12138243_12175516_2": {"length": 9, "quality": 1.0, "section_id": 5567}, "so_12138243_12181316_1": {"length": 10, "quality": 1.0, "section_id": 3101}, "so_12138243_12181316_0": {"length": 9, "quality": 1.0, "section_id": 5567}}, "n4659": {"so_12138243_12175516_0": {"length": 10, "quality": 1.0, "section_id": 3985}, "so_12138243_12175516_2": {"length": 9, "quality": 1.0, "section_id": 7253}, "so_12138243_12181316_1": {"length": 10, "quality": 1.0, "section_id": 3985}, "so_12138243_12181316_0": {"length": 9, "quality": 1.0, "section_id": 7253}}}, "12181316": {"Id": "12181316", "PostTypeId": "2", "Body": "<p>The standard is fairly specific that even a POD-struct (which is, I believe the most restrictive class of structs) can have padding between members. (\"There might therefore be unnamed padding within a POD-struct object, but not at its beginning, as necessary to achieve appropriate alignment.\" -- a non-normative note, but still makes the intent quite clear).</p>\n<p>For example, contrast the requirements for a standard-layout struct (C++11, \u00a71.8/4): </p>\n<blockquote>\n<p id=\"so_12138243_12181316_0\">An object of trivially copyable or standard-layout type (3.9) shall occupy contiguous bytes of storage.\"</p>\n</blockquote>\n<p>...with those for an array (\u00a78.3.4/1):</p>\n<blockquote>\n<p id=\"so_12138243_12181316_1\">An object of array type contains a contiguously allocated non-empty set of N subobjects of type T.</p>\n</blockquote>\n<p>In the array, the <em>elements</em> themselves are required to be allocated contiguously, whereas in the struct, only the <em>storage</em> is required to be contiguous.</p>\n<p>The third possibility that might make the \"contiguous storage\" requirement make more sense would be to consider a struct/class that is not trivially copyable or standard layout. In this case, it's possible that the storage might might not be contiguous at all. For example, an implementation might set aside one area of memory for holding all the private variables, and an entirely separate area of memory to hold all the public variables. To make that a little more concrete, consider two definitions like:</p>\n<pre><code>class A { \n    int a;\npublic:\n    int b;\n} a;\n\nclass B {\n    int x;\npublic:\n    int y;\n} b;\n</code></pre>\n<p>With these definitions, the memory might be laid out something like:</p>\n<pre><code>a.a;\nb.x;\n\n// ... somewhere else in memory entirely:\n\na.b;\nb.y;\n</code></pre>\n<p>In this case, neither the elements <em>nor</em> the storage needs to be contiguous, so interleaving parts of entirely separate structs/classes is allowable. </p>\n<p>That said, the first element must be at the same address as the struct as a whole (9.2/17): \"A pointer to a POD-struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa.\"</p>\n<p>In your case, you have a POD-struct, so (\u00a79.2/17): \"A pointer to a POD-struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa.\" Since the first member <em>must</em> be aligned, and the remaining members are all of the same type, it's impossible for any padding to be truly necessary between the other members (i.e., except for bit-fields, any type you can put in a struct you can also put in an array, where contiguous allocation of the elements is required). If you have elements smaller than a word, on a word-oriented machine (e.g., early DEC Alphas), it's possible that padding could make access somewhat simpler though. For example, early DEC Alphas (at the hardware level) were only capable of reading/writing an entirely (64-bit) word at a time. As such, let's consider something like a struct of four <code>char</code> elements:</p>\n<pre><code>struct foo { \n   char a, b, c, d;\n};\n</code></pre>\n<p>If it was required to lay these out in memory so they were contiguous, accessing a <code>foo::b</code> (for example) would require that the CPU load the word, then shift it 8-bits right, then mask to zero-extend that byte to fill the entire register.</p>\n<p>Storing would be even worse -- the CPU would have to load the current value of the whole word, mask out the current contents of the appropriate char-sized piece of that, shift the new value to the correct place, OR it into the word, and finally store the result.</p>\n<p>By contrast, with padding between the elements, each of those becomes a simple load/store, with no shifting, masking, etc.</p>\n<p>At least if memory serves, with DEC's normal compiler for the Alpha, <code>int</code> was 32 bits, and <code>long</code> was 64 bits (it predated <code>long long</code>). As such, with your struct of four <code>int</code>s, you could have expected to see another 32 bits of padding between the elements (and another 32 bits after the last element as well).</p>\n<p>Given that you do have a POD-struct, you still have some possibilities though. The one I'd probably prefer would be to use <code>offsetof</code> to get the offsets of the members of the struct, create an array of them, and access the members via those offsets. I showed how to do this in a <a href=\"https://stackoverflow.com/a/5088496/179910\">couple</a> of <a href=\"https://stackoverflow.com/a/2043949/179910\">previous answers</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-08-29T15:22:33.000", "Score": "5", "CreationDate": "2012-08-29T15:22:33.000", "ParentId": "12138243", "CommentCount": "2", "OwnerUserId": "179910", "LastEditDate": "2017-05-23T12:07:52.840"}, "12138499": {"Id": "12138499", "PostTypeId": "2", "Body": "<p>Strictly speaking, such pointer casts aren't allowed and lead to undefined behavior.</p>\n<p>The main issue with the cast is however that the compiler is free to add any number of padding bytes anywhere inside a struct, except before the very first element. So whether it will work or not depends on the alignment requirements of the specific system, and also whether struct padding is enabled or not.</p>\n<p><code>int</code> is not necessarily of the same size as the optimal size for an addressable chunk of data, even though this is true for most 32-bit systems. Some 32-bitters don't care about misalignment, some will allow misalignment but produce less efficient code, and some must have the data aligned. In theory, 64-bitters may also want to add padding after an int (which will be 32 bit there) to get a 64-bit chunk, but in practice they support 32-bit instruction sets.</p>\n<p>If you write code relying on this cast, you should add something like this:</p>\n<pre><code>static_assert (sizeof(intStruct) == \n               sizeof(int) + sizeof(int));\n</code></pre>\n", "LastEditorUserId": "584518", "LastActivityDate": "2012-08-27T08:51:05.963", "Score": "2", "CreationDate": "2012-08-27T08:22:36.627", "ParentId": "12138243", "CommentCount": "9", "OwnerUserId": "584518", "LastEditDate": "2012-08-27T08:51:05.963"}, "12138521": {"Id": "12138521", "PostTypeId": "2", "Body": "<p>I've found nothing which guarantee it is valid when I searched some time ago, and I've found explicit guarantee for the case of std::complex&lt;&gt; in C++ which could have been formulated more easily if it was more generally true, so I doubt I missed something in my search (but absence of proof is hardly a proof of absence and the standard is sometimes obscure in its formulation).</p>\n", "LastActivityDate": "2012-08-27T08:24:12.787", "CommentCount": "2", "CreationDate": "2012-08-27T08:24:12.787", "ParentId": "12138243", "Score": "1", "OwnerUserId": "136208"}});