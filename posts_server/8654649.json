post_cb({"8654649": {"CommentCount": "7", "AcceptedAnswerId": "8655415", "CreationDate": "2011-12-28T10:26:47.977", "LastActivityDate": "2011-12-28T11:42:22.150", "PostTypeId": "1", "ViewCount": "193", "FavoriteCount": "2", "Title": "Is storing objects of class with overloaded \"operator&\" in STL containers legal in C++?", "Id": "8654649", "Score": "6", "Body": "<p>According to C++03 Standard (23.1/3) only <em>copy-constructible</em> class objects can be stored in STL containers. <em>Copy-constructible</em> is described in 20.1.3 and requires that \"&amp;\" yields address of the object.</p>\n<p>Now suppose I have this class:</p>\n<pre><code>class Class {\npublic:\n   Class* operator&amp;()\n   {\n       //do some logging\n       return this;\n   }\n   const Class* operator&amp;() const\n   {\n       //do some logging\n       return this;\n   }\n   //whatever else - assume it doesn't violate requierements\n};\n</code></pre>\n<p>Can this class objects be legally stored in STL containers?</p>\n", "Tags": "<c++><stl><operator-overloading>", "OwnerUserId": "57428", "AnswerCount": "2"}, "8655415": {"ParentId": "8654649", "CommentCount": "0", "Body": "<p>Yes. In C++03, the CopyConstructible requirements for <code>&amp;</code>, given values <code>t</code> of type <code>T</code> and <code>u</code> of type <code>const T</code>, are:</p>\n<ul>\n<li><code>&amp;t</code> has type <code>T*</code>, and gives the address of <code>t</code>, and</li>\n<li><code>&amp;u</code> has type <code>const T*</code>, and gives the address of <code>u</code>.</li>\n</ul>\n<p>Your overloaded operators have this behaviour; so, assuming the class meets the other CopyConstructible and Assignable requirements, values of this type can be stored in any C++03 container.</p>\n<p>C++11 relaxes these requirements, requiring that types be movable or copyable only in containers or operations that specifically have such requirements, and removing the rather odd specification of what <code>&amp;</code> must do; so your class is still fine, again assuming it meets all the other requirements for the particular container and set of operations you use.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "8655415", "Score": "5", "CreationDate": "2011-12-28T11:37:58.273", "LastActivityDate": "2011-12-28T11:37:58.273"}, "8655465": {"ParentId": "8654649", "CommentCount": "0", "Body": "<p>While in C++03 we <em>only</em> had the possibility to copy construct / copy assign objects, we get two additional, by far more powerful tools to construct objects and one additional tool to assign objects: move construction and assignment and emplace construction (based on perfect forwarding).</p>\n<p>Thanks to that, the standard gives the <code>value_type</code> of a container way more leeway in its requirements. For example, you are allowed to store <code>unique_ptr</code>s, which are move-only, in a <code>std::vector</code>, as long as you don't use any operations that require <em>CopyConstructible</em>, <em>CopyInsertable</em> or <em>CopyAssignable</em> (such as assignment of one container to another).</p>\n<blockquote>\n<p id=\"so_8654649_8655465_0\">Can this class objects be legally stored in STL containers?</p>\n</blockquote>\n<p><strong>Yes</strong>, <em>none</em> of the requirements that <em>may</em> be used in a container instantiated with a certain <code>value_type</code> even mention the address-of operator in any way.</p>\n<p><code>\u00a717.6.3.1 [utility.arg.requirements]</code></p>\n<blockquote>\n<p id=\"so_8654649_8655465_1\">The template definitions in the C++ standard library refer to various named requirements whose details are set out in tables 17\u201324.</p>\n</blockquote>\n<p>(Table 17 and 18 are Comparable requirements)</p>\n<pre><code>Table 19 \u2014 DefaultConstructible requirements [defaultconstructible]\nExpression               Post-condition\nT t;                     object t is default-initialized\nT u{};                   object u is value-initialized\nT()                      a temporary object of type T is value-initialized\nT{}\n\nTable 20 \u2014 MoveConstructible requirements [moveconstructible]\nExpression               Post-condition\nT u = rv;                u is equivalent to the value of rv before the construction\nT(rv)                    T(rv) is equivalent to the value of rv before the construction\nrv\u2019s state is unspecified\n\nTable 21 \u2014 CopyConstructible requirements (in addition to MoveConstructible) [copyconstructible]\nExpression               Post-condition\nT u = v;                 the value of v is unchanged and is equivalent to u\nT(v)                     the value of v is unchanged and is equivalent to T(v)\n\nTable 22 \u2014 MoveAssignable requirements [moveassignable]\nExpression    Return type    Return value    Post-condition\nt = rv        T&amp;             t               t is equivalent to the value of\n                                             rv before the assignment\nrv\u2019s state is unspecified.\n\nTable 23 \u2014 CopyAssignable requirements(in addition to MoveAssignable) [copyassignable]\nExpression    Return type    Return value    Post-condition\nt = v         T&amp;             t               t is equivalent to v, the value of\n                                             v is unchanged\n\nTable 24 \u2014 Destructible requirements [destructible]\nExpression               Post-condition\nu.~T()                   All resources owned by u are reclaimed, no exception is propagated.\n</code></pre>\n<p>Then we also got the container requirements themselves. Those are based on their allocator types:</p>\n<p><code>\u00a723.2.1 [container.requirements.general] p13</code></p>\n<blockquote>\n<p id=\"so_8654649_8655465_2\">All of the containers defined in this Clause and in (21.4) except array meet the additional requirements of an allocator-aware container, as described in Table 99.\n  Given a container type <strong><code>X</code></strong> having an allocator_type identical to <strong><code>A</code></strong> and a <strong><code>value_type</code></strong> identical to <strong><code>T</code></strong> and given an lvalue <strong><code>m</code></strong> of type <strong><code>A</code></strong>, a pointer <strong><code>p</code></strong> of type <strong><code>T*</code></strong>, an expression <strong><code>v</code></strong> of type <strong><code>T</code></strong>, and an rvalue <strong><code>rv</code></strong> of type <strong><code>T</code></strong>, the following terms are defined. (If <strong><code>X</code></strong> is not allocator-aware, the terms below are defined as if <strong><code>A</code></strong> were <strong><code>std::allocator&lt;T&gt;</code></strong>.)</p>\n<ul>\n<li><p id=\"so_8654649_8655465_3\"><strong><code>T</code></strong> is <em>CopyInsertable into <strong><code>X</code></strong></em></p></li></ul></blockquote> means that the following expression is well-formed:\n      <code>allocator_traits&lt;A&gt;::construct(m, p, v);</code>\n<li><p><strong><code>T</code></strong> is <em>MoveInsertable into <strong><code>X</code></strong></em></p></li> means that the following expression is well-formed:\n      <code>allocator_traits&lt;A&gt;::construct(m, p, rv);</code>\n<li><p><strong><code>T</code></strong> is <em>EmplaceConstructible into <strong><code>X</code></strong> from <strong><code>args</code></strong></em></p></li>, for zero or more arguments <strong><code>args</code></strong>, means that the following expression is well-formed:\n      <code>allocator_traits&lt;A&gt;::construct(m, p, args);</code>\n<p>An excerpt from the table for sequence containers (where <code>p</code> is a valid const iterator and <code>t</code> is an lvalue of type <code>T</code>):</p>\n<blockquote>\n<p id=\"so_8654649_8655465_4\"><code>a.insert(p,t)</code><br>\n<em>Requires:</em> <strong><code>T</code></strong> shall be CopyInsertable into <strong><code>X</code></strong>. For <strong><code>vector</code></strong> and <strong><code>deque</code></strong>, <strong><code>T</code></strong> shall also be CopyAssignable.<br>\n<em>Effects:</em> Inserts a copy of t before p.</br></br></p>\n</blockquote>\n<p>If you never use that specific <code>insert</code> variant (and other members, that require CopyInsertible), your type doesn't need to be CopyInsertable. Easy as that. Same goes for all the other members. The <strong><em>only</em></strong> requirement that <em>must</em> be fulfilled is the Destructible requirement (logical, isn't it?).</p>\n", "OwnerUserId": "500104", "PostTypeId": "2", "Id": "8655465", "Score": "1", "CreationDate": "2011-12-28T11:42:22.150", "LastActivityDate": "2011-12-28T11:42:22.150"}, "bq_ids": {"n4140": {"so_8654649_8655465_1": {"section_id": 6275, "quality": 0.8571428571428571, "length": 12}, "so_8654649_8655465_4": {"section_id": 723, "quality": 0.7692307692307693, "length": 10}, "so_8654649_8655465_2": {"section_id": 715, "quality": 0.95, "length": 38}}, "n3337": {"so_8654649_8655465_1": {"section_id": 6035, "quality": 0.8571428571428571, "length": 12}, "so_8654649_8655465_4": {"section_id": 712, "quality": 0.7692307692307693, "length": 10}, "so_8654649_8655465_2": {"section_id": 704, "quality": 0.95, "length": 38}}, "n4659": {"so_8654649_8655465_1": {"section_id": 7782, "quality": 0.8571428571428571, "length": 12}, "so_8654649_8655465_4": {"section_id": 754, "quality": 0.7692307692307693, "length": 10}, "so_8654649_8655465_2": {"section_id": 745, "quality": 0.875, "length": 35}}}});