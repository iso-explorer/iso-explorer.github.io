post_cb({"14369468": {"CommentCount": "11", "AcceptedAnswerId": "14378234", "PostTypeId": "1", "LastEditorUserId": "179910", "CreationDate": "2013-01-16T23:01:00.920", "LastActivityDate": "2013-03-04T15:09:40.057", "LastEditDate": "2013-03-04T15:09:40.057", "ViewCount": "821", "FavoriteCount": "6", "Title": "operator++ as both a postfix and prefix doesn't work with clang", "Id": "14369468", "Score": "28", "Body": "<p>I tried to write an operator that can be used both as a prefix and a postfix operator</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nstruct B { \n  // ...\n};\n\ntemplate&lt;typename ...T&gt;\nvoid operator++(B, T...) {\n  std::cout &lt;&lt; ((sizeof...(T) == 0) ? \"prefix\" : \"postfix\") &lt;&lt; std::endl;\n}\n\nint main() {\n  B b;\n  b++;\n  ++b;\n}\n</code></pre>\n<p>GCC compiles and works fine with this, but clang says</p>\n<blockquote>\n<p id=\"so_14369468_14369468_0\">main.cpp:9:24: error: parameter of overloaded post-increment operator must have type 'int' (not 'T...')</p>\n<pre><code>void operator++(B, T...) {\n</code></pre>\n</blockquote>\n<p>Who is right?</p>\n<hr>\n<p>Thanks to anyone who helped me understand GCC's behavior. I filed a new Clang bug report:</p>\n<p><a href=\"http://llvm.org/bugs/show_bug.cgi?id=14995\" rel=\"nofollow\">http://llvm.org/bugs/show_bug.cgi?id=14995</a></p>\n</hr>", "Tags": "<c++><templates><c++11><operators><language-lawyer>", "OwnerUserId": "34509", "AnswerCount": "1"}, "14378234": {"ParentId": "14369468", "PostTypeId": "2", "CommentCount": "16", "CreationDate": "2013-01-17T11:38:46.133", "Score": "7", "LastEditorUserId": "1932150", "LastEditDate": "2013-01-17T20:25:23.997", "Id": "14378234", "OwnerUserId": "1932150", "Body": "<p><strong>ORIGINAL ANSWER:</strong> (<em>not deleted as it may contain useful information</em>)</p>\n<p>I would say it all boils down to whether an overloaded operator <strong>template</strong> is considered to be an overloaded operator or not. Logically, I would like to think this is not the case, and Clang is wrong: I believe the template <em>should</em> be first selected as a candidate for overload resolution based on name and signature compatibility, then instantiated, then (possibly) selected. The way I see it, only after instantiation the compiler should check whether the resulting <strong>function</strong> has the proper amount of arguments or not.</p>\n<p>But that is only my <em>opinion</em>. Per \u00a7 13.5.7/1 about overloading of the postfix <code>operator ++</code>: </p>\n<p><em>\"If the function is a member function with one parameter (which shall be of type int) or a non-member <strong>function</strong> with two parameters (the second of which shall be of type int), it defines the postfix increment operator ++ for objects of that type\"</em></p>\n<p>The Standard does not seem to clarify whether a function <strong>template</strong> shall be considered as a <strong>function</strong> for what concerns the restrictions on the signature of legal operator overloads (at least, I could not find any sentence that solves this ambiguity). As long as this is true, this question can hardly be given a clear answer, and we are left with <em>opinions</em>. </p>\n<p>But I would like to mention another relevant aspect of the matter: <strong>consistency</strong>.</p>\n<p>Although it is true that the code in the question's text does not compile on Clang, the following does:</p>\n<pre><code>template&lt;typename... Ts&gt;\nint operator + (X x1, Ts... args)\n{\n    return 0;\n}\n</code></pre>\n<p>I do not see any conceptual difference between the two cases: if the signature of the operator overload is to be checked <em>before instantiation</em>, then the above definition should not compile either. If this is not the case, then the code in the question's text should compile.</p>\n<p>So the answer in my opinion is that either GCC is right, or they are both wrong.</p>\n<p><strong>UPDATE:</strong></p>\n<p>As @JesseGood and @SethCarnegie correctly point out, per 14.7/4:</p>\n<p><em>\"A specialization is a class, function, or class member that is either instantiated or explicitly specialized.\"</em></p>\n<p>Moreover, per 14.6/8:</p>\n<p><em>\"No diagnostic shall be issued for a template for which a valid specialization can be generated.\"</em></p>\n<p>Thus, it seems Clang is indeed wrong and <strong>no compilation error shall be produced</strong> for the operator function template in the question's text.</p>\n", "LastActivityDate": "2013-01-17T20:25:23.997"}, "bq_ids": {"n4140": {"so_14369468_14369468_0": {"section_id": 466, "quality": 0.6, "length": 6}}, "n3337": {"so_14369468_14369468_0": {"section_id": 457, "quality": 0.6, "length": 6}}, "n4659": {"so_14369468_14369468_0": {"section_id": 489, "quality": 0.6, "length": 6}}}});