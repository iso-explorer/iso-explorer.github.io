post_cb({"8000200": {"ParentId": "7997539", "CommentCount": "0", "Body": "<p>There is an implementation of <code>int vwscanf(format, ...)</code> with VS2010.</p>\n<p>File = wscanf.c </p>\n<p>Directory = C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\crt\\src</p>\n", "OwnerUserId": "517580", "PostTypeId": "2", "Id": "8000200", "Score": "0", "CreationDate": "2011-11-03T18:41:05.607", "LastActivityDate": "2011-11-03T18:41:05.607"}, "7998611": {"ParentId": "7997539", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>My version of <a href=\"https://stackoverflow.com/questions/7997539/better-way-to-work-around-lack-of-vwscanf-in-visual-c/7998091#7998091\">awoodland</a>'s answer: default-valued arguments are required:</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;cassert&gt;\n\ntemplate &lt;typename CodingValue&gt;\nint scanf(CodingValue const* format,\n    void* a01 = 0, void* a02 = 0, void* a03 = 0, void* a04 = 0, void* a05 = 0,\n    void* a06 = 0, void* a07 = 0, void* a08 = 0, void* a09 = 0, void* a10 = 0,\n    void* a11 = 0, void* a12 = 0)\n{\n    return wscanf( format,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11,a12 );\n}\n\nint main()\n{\n    int v(0);\n    int rc = scanf&lt;wchar_t&gt;(L\"%d\", &amp;v);\n    assert(1 == rc);\n    return 0;\n}\n</code></pre>\n<p>Please, refer to <a href=\"https://stackoverflow.com/questions/7997539/better-way-to-work-around-lack-of-vwscanf-in-visual-c/7998091#7998091\">Dennis Zickefoose</a> comments above for some background details.</p>\n", "OwnerUserId": "151641", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:21:10.337", "Id": "7998611", "Score": "1", "CreationDate": "2011-11-03T16:42:06.803", "LastActivityDate": "2011-11-03T16:59:20.500"}, "7997539": {"CommentCount": "5", "AcceptedAnswerId": "7998091", "CreationDate": "2011-11-03T15:30:15.043", "LastActivityDate": "2011-11-03T18:41:05.607", "PostTypeId": "1", "ViewCount": "151", "FavoriteCount": "2", "Title": "Better way to work around lack of vwscanf in Visual C++?", "Id": "7997539", "Score": "4", "Body": "<p>The C++11 standard specifies that <code>vwscanf</code> is available via header <code>&lt;cwchar&gt;</code> (and therefore <code>&lt;wchar.h&gt;</code>). However it seems to be lacking in Visual C++. With that function I could write \u2026</p>\n<pre><code>inline int scanf( CodingValue const* format, ... )\n{\n    va_list args;\n    va_start( args, format );\n    return ::vwscanf( format-&gt;ptr(), args );\n}\n</code></pre>\n<p>but without it, i.e. with Visual C++ 10.0, which also appears to lack support for C++11 variadic templates, I\u2019m reduced to writing \u2026</p>\n<pre><code>inline int scanf(\n    CodingValue const* format,\n    void* a01 = 0, void* a02 = 0, void* a03 = 0, void* a04 = 0, void* a05 = 0,\n    void* a06 = 0, void* a07 = 0, void* a08 = 0, void* a09 = 0, void* a10 = 0,\n    void* a11 = 0, void* a12 = 0\n    )\n{\n    int const   nArgs = !!a01 + !!a02 + !!a03 + !!a04 + !!a05 + !!a06 +\n                        !!a07 + !!a08 + !!a09 + !!a10 + !!a11 + !!a12;\n    BasicCodingValue const* const   f   = format-&gt;ptr();\n\n    switch( nArgs )\n    {\n    case  0:    return ::wscanf( f );\n    case  1:    return ::wscanf( f,a01 );\n    case  2:    return ::wscanf( f,a01,a02 );\n    case  3:    return ::wscanf( f,a01,a02,a03 );\n    case  4:    return ::wscanf( f,a01,a02,a03,a04 );\n    case  5:    return ::wscanf( f,a01,a02,a03,a04,a05 );\n    case  6:    return ::wscanf( f,a01,a02,a03,a04,a05,a06 );\n    case  7:    return ::wscanf( f,a01,a02,a03,a04,a05,a06,a07 );\n    case  8:    return ::wscanf( f,a01,a02,a03,a04,a05,a06,a07,a08 );\n    case  9:    return ::wscanf( f,a01,a02,a03,a04,a05,a06,a07,a08,a09 );\n    case 10:    return ::wscanf( f,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10 );\n    case 11:    return ::wscanf( f,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11 );\n    case 12:    return ::wscanf( f,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11,a12 );\n    }\n}\n</code></pre>\n<p>Or, I could do some assembly, as I did like 15 years ago when I encountered similar (or perhaps the same) problem, but that does not feel quite right.</p>\n<p>Can you suggest some better way?</p>\n", "Tags": "<c++><visual-c++><variadic-functions>", "OwnerUserId": "464581", "AnswerCount": "3"}, "7998091": {"ParentId": "7997539", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>As I understand it's not an error to call a variadic function with extra (i.e. more than asked for) arguments in C (and possibly in C++, although I've yet to locate a definitive statement either way on that).</p>\n<p>The best I've got on the C++ side so far is 5.2.2 [expr.call]:</p>\n<blockquote>\n<p id=\"so_7997539_7998091_0\">A function can be declared to accept fewer arguments (by declaring\n  default arguments (8.3.6)) or more arguments (by using the ellipsis,\n  ..., or a function parameter pack (8.3.5)) than the number of\n  parameters in the function definition (8.4)</p>\n</blockquote>\n<p>18.10 [support.runtime] defers to the ISO C 4.8.1.1 on the subject of restrictions for <code>va_start()</code>.</p>\n<p>I can't see anywhere that says \"you must not pass extra arguments\", so it seems that it wouldn't be unreasonable to assume that it's not prohibited.</p>\n<p>If it's not legal in C++ to give extra arguments then you can use C++ to handle the default arguments still and call a C function with the defaults having been \"filled out\" so that you only ever call the one C function, regardless of how many arguments were given.</p>\n<p>So in C++ you'd do:</p>\n<pre><code>extern \"C\" {\n  int real_scanf(\n        const char* format,\n        void* a01, void* a02, void* a03, void* a04, void* a05,\n        void* a06, void* a07, void* a08, void* a09, void* a10,\n        void* a11, void* a12\n        );\n}\n\ninline int scanf(\n    CodingValue const* format,\n    void* a01 = 0, void* a02 = 0, void* a03 = 0, void* a04 = 0, void* a05 = 0,\n    void* a06 = 0, void* a07 = 0, void* a08 = 0, void* a09 = 0, void* a10 = 0,\n    void* a11 = 0, void* a12 = 0\n    )\n{\n    BasicCodingValue const* const   f   = format-&gt;ptr();\n    return real_scanf( f,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11,a12 );\n}\n</code></pre>\n<p>and then in C you could do: </p>\n<pre><code>int real_scanf(\n    const char* format,\n    void* a01, void* a02, void* a03, void* a04, void* a05,\n    void* a06, void* a07, void* a08, void* a09, void* a10,\n    void* a11, void* a12\n    )\n{\n    return wscanf( format,a01,a02,a03,a04,a05,a06,a07,a08,a09,a10,a11,a12 );\n}\n</code></pre>\n", "OwnerUserId": "168175", "LastEditorUserId": "168175", "LastEditDate": "2011-11-03T16:39:12.213", "Id": "7998091", "Score": "2", "CreationDate": "2011-11-03T16:07:30.833", "LastActivityDate": "2011-11-03T16:39:12.213"}, "bq_ids": {"n4140": {"so_7997539_7998091_0": {"section_id": 5993, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_7997539_7998091_0": {"section_id": 5761, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_7997539_7998091_0": {"section_id": 7495, "quality": 0.9130434782608695, "length": 21}}}});