post_cb({"16752613": {"ParentId": "16752451", "CommentCount": "3", "Body": "<p>C++11 says (5.1.2, p3) that the type of a lambda will be declared \"<code>in the smallest block scope, class scope, or namespace scope that contains the corresponding lambda-expression.</code>\" So in this case, the type will be declared in <code>f</code>. C++14's CD has the same language.</p>\n<p>So the question really is what the namespace for a local class is. I don't think it has one.</p>\n<p>C++11, section 9.8, p1, states: <code>The name of a local class is local to its enclosing scope.</code> As such, I don't believe that it has any associated namespaces (per 3.4.2, p2), and is therefore not subject to ADL.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "16752613", "Score": "10", "CreationDate": "2013-05-25T18:20:39.250", "LastActivityDate": "2013-05-25T18:20:39.250"}, "16773803": {"ParentId": "16752451", "CommentCount": "0", "Body": "<p>\u00a73.4.2/2 says</p>\n<blockquote>\n<p id=\"so_16752451_16773803_0\">If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and its direct and indirect base classes. Its associated namespaces are the namespaces of which its associated classes are members.</p>\n</blockquote>\n<p>Namespace association only penetrates through one level of class nesting, and not through function scopes, if this is taken literally. But both Clang and GCC allow multiple levels of class nesting, and GCC makes functions scopes transparent as well.</p>\n<p>It looks to me like multiple levels of class nesting are a defect, and local classes are an oversight in C++11, since before C++11 there was no way to take a local class out of its namespace \u2014 they weren't allowed as template arguments.</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "16773803", "Score": "0", "CreationDate": "2013-05-27T13:00:27.183", "LastActivityDate": "2013-05-27T13:00:27.183"}, "16752451": {"CommentCount": "5", "AcceptedAnswerId": "16752613", "PostTypeId": "1", "LastEditorUserId": "298661", "CreationDate": "2013-05-25T18:03:13.897", "LastActivityDate": "2013-05-27T13:00:27.183", "LastEditDate": "2013-05-25T18:24:08.140", "ViewCount": "284", "FavoriteCount": "1", "Title": "What does the Standard say about the namespace of lambda types?", "Id": "16752451", "Score": "8", "Body": "<p>Let's say that I have a setup like this:</p>\n<pre><code>namespace hi {\n    template&lt;typename L, typename R&gt; L operator+(L l, R r) {\n        // some body\n    }\n    auto f() {\n        return [] {}; // Legal C++14\n    }\n}\nint main() {\n    auto x = hi::f();\n    1 + x; // Is this legal?\n}\n</code></pre>\n<p>The question is whether ADL on the lambda type will find the overloaded operator in that namespace by Standard.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "298661", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_16752451_16773803_0": {"section_id": 7104, "quality": 1.0, "length": 24}}, "n3337": {"so_16752451_16773803_0": {"section_id": 6848, "quality": 1.0, "length": 24}}, "n4659": {"so_16752451_16773803_0": {"section_id": 8605, "quality": 1.0, "length": 24}}}});