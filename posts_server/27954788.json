post_cb({"27954788": {"CommentCount": "0", "ViewCount": "490", "PostTypeId": "1", "LastEditorUserId": "2126725", "CreationDate": "2015-01-15T00:09:13.350", "LastActivityDate": "2015-01-15T00:45:38.220", "Title": "Bit manipulation- for negative numbers", "AcceptedAnswerId": "27954851", "LastEditDate": "2015-01-15T00:17:17.267", "Id": "27954788", "Score": "2", "Body": "<p>Let the size of integer <strong><em>i=-5</em></strong> be 2 bytes. The <strong>signed bit</strong> value at the leftmost bit is '1'(which signifies that it is a negative number). \nWhen i am trying to do a right shift operation, should i not expect the '1' at the 15th bit position to shift to 14th position? and give me a high but positive value?</p>\n<p>What i tried:<br/></p>\n<pre><code>int i=5;\ni&gt;&gt;1 // giving me 2 (i understand this)\n\nint i=-5\ni&gt;&gt;1 // giving me -3 (mind=blown)\n</code></pre>\n", "Tags": "<c++><bit-manipulation>", "OwnerUserId": "2126725", "AnswerCount": "1"}, "27954851": {"ParentId": "27954788", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Right shifts of negative values are implementation-defined, [expr.shift]/3</p>\n<blockquote>\n<p id=\"so_27954788_27954851_0\">The value of <code>E1 &gt;&gt; E2</code> is <code>E1</code> right-shifted <code>E2</code> bit positions. \n  [..]. <strong>If <code>E1</code> has a signed type and a negative value, the resulting\n  value is implementation-defined.</strong></p>\n</blockquote>\n<p>Most implementations use the so-called <a href=\"http://en.wikipedia.org/wiki/Arithmetic_shift\" rel=\"nofollow\"><strong>arithmetic shift</strong></a> though, <strong>which preserves and extends the sign-bit</strong>:</p>\n<blockquote>\n<p id=\"so_27954788_27954851_1\">Shifting right by <em>n</em> bits on a two's complement signed binary number\n  <strong>has the effect of dividing it by <em>2<sup>n</sup></em></strong>, but it always rounds down\n  (towards negative infinity). This is different from the way rounding\n  is usually done in signed integer division (which rounds towards 0).\n  This discrepancy has led to bugs in more than one compiler.</p>\n</blockquote>\n<p>So what happens is, when shortened down to 8 bit, the following. In two's complement -5 would be</p>\n<pre><code>1111 1011\n</code></pre>\n<p>After the arithmetic right shift:</p>\n<pre><code>1111 1101\n</code></pre>\n<p>Now flip and add one to get the positive value for comparison:</p>\n<pre><code>0000 0011 \n</code></pre>\n<p>Looks like a three to me.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-01-15T00:45:38.220", "Id": "27954851", "Score": "7", "CreationDate": "2015-01-15T00:15:49.187", "LastActivityDate": "2015-01-15T00:45:38.220"}, "bq_ids": {"n4140": {"so_27954788_27954851_0": {"section_id": 6148, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_27954788_27954851_0": {"section_id": 5911, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_27954788_27954851_0": {"section_id": 7644, "quality": 0.8333333333333334, "length": 10}}}});