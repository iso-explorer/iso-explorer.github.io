post_cb({"33486121": {"Id": "33486121", "PostTypeId": "2", "Body": "<p>There's no contradiction between these two things. The allocation function gets the size, and almost certainly has to allocate a bit more than that so it knows the size again if the deallocation function is called.</p>\n<p>When an array of objects that have a non-trivial destructor is allocated, the implementation needs some way to know how many times to call the destructor when <code>delete[]</code> is called. Implementations are permitted to allocate some extra space along with the array to store this additional information though not every implementation works this way.</p>\n", "LastEditorUserId": "721269", "LastActivityDate": "2015-11-02T20:52:34.853", "Score": "21", "CreationDate": "2015-11-02T20:20:27.763", "ParentId": "33486001", "CommentCount": "11", "OwnerUserId": "721269", "LastEditDate": "2015-11-02T20:52:34.853"}, "33486344": {"Id": "33486344", "PostTypeId": "2", "Body": "<p>If you call <code>new</code> on a type <code>T</code>, the overloaded <code>operator new</code> that may be invoked will be passed exactly <code>sizeof(T)</code>.</p>\n<p>If you implement a <code>new</code> of your own (or an allocator) that uses some different memory store (ie, not just forwarding to another call to <code>new</code> or <code>malloc</code> etc), you'll find yourself wanting to store information to clean up the allocation later, when the <code>delete</code> occurs.  A typical way to do this is to get a slightly larger block of memory, and store the amount of memory requested at the start of it, then return a pointer to <em>later</em> in the memory you acquired.</p>\n<p>This is roughly what most standard implementations of <code>new</code> (and <code>malloc</code> do).</p>\n<p>So while you only need <code>sizeof(T)</code> bytes to store a <code>T</code>, the amount of bytes consumed by <code>new</code>/<code>malloc</code> is more than <code>sizeof(T)</code>.  This is what Stroustrup is talking about: every dynamic allocation has actual overhead, and that overhead can be substantial if you make lots of small allocations.</p>\n<hr>\n<p>There are some allocators that don't need that extra room \"before\" the allocation.  For example, a stack-scoped allocator that doesn't delete anything until it goes out of scope.  Or one that allocates from stores of fixed-sized blocks and uses a bitfield to describe which are in use.</p>\n<p>Here, the accounting information isn't store adjacent to the data, or we make the accounting information implicit in the code state (scoped allocators).</p>\n<hr>\n<p>Now, in the case of arrays, the C++ compiler is free to call <code>operator new[]</code> with an amount of memory requested <em>larger</em> than <code>sizeof(T)*n</code> when <code>T[n]</code> is allocated.  This is done by <code>new</code> (not <code>operator new</code>) code generated by the compiler when it asks your overload for memory.</p>\n<p>This is traditionally done on types with non-trivial destructors so that the C++ runtime can, when <code>delete[]</code> is called, iterate over each of the items and call <code>.~T()</code> on them.  It pulls off a similar trick, where <em>it</em> stuffs <code>n</code> into memory before the array it is using, then does pointer arithmetic to extract it at delete time.</p>\n<p>This is <em>not required</em> by the standard, but it is a common technique (clang and gcc both do it at least on some platforms, and I believe MSVC does as well).  Some method of calculating the size of the array is needed; this is just one of them.</p>\n<p>For something without a destructor (like <code>char</code>) or a trivial one (like <code>struct foo{ ~foo()=default; }</code>, <code>n</code> isn't needed by the runtime, so it doesn't have to store it.  So it can say \"naw, I won't store it\".</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/6982bc7868158181\" rel=\"nofollow\">Here is a live example</a>.</p>\n<pre><code>struct foo {\n  static void* operator new[](std::size_t sz) {\n    std::cout &lt;&lt; sz &lt;&lt; '/' &lt;&lt; sizeof(foo) &lt;&lt; '=' &lt;&lt; sz/sizeof(foo) &lt;&lt; \"+ R(\" &lt;&lt; sz%sizeof(foo) &lt;&lt; \")\" &lt;&lt; '\\n';\n    return malloc(sz);\n  }\n  static void operator delete[](void* ptr) {\n    free(ptr);\n  }\n  virtual ~foo() {}\n};\n\nfoo* test(std::size_t n) {\n  std::cout &lt;&lt; n &lt;&lt; '\\n';\n  return new foo[n];\n}\n\nint main(int argc, char**argv) {\n  foo* f = test( argc+10 );\n  std::cout &lt;&lt; *std::prev(reinterpret_cast&lt;std::size_t*&gt;(f)) &lt;&lt; '\\n';\n}\n</code></pre>\n<p>If run with 0 arguments, it prints out <code>11</code>, <code>96/8 = 12 R(0)</code> and <code>11</code>.</p>\n<p>The first is the number of elements allocated, the second is how much memory is allocated (which adds up to 11 element's worth, plus 8 bytes -- <code>sizeof(size_t)</code> I suspect), the last is what we happen to find right before the start of the array of 11 elements (a <code>size_t</code> with the value <code>11</code>).</p>\n<p>Accessing memory before the start of the array is naturally undefined behavior, but I did it in order to expose some implementation details in gcc/clang.  The point is that they <em>did</em> ask for an extra 8 bytes (as predicted), and they did happen to store the value <code>11</code> there (the size of the array).</p>\n<p>If you change that <code>11</code> to <code>2</code>, a call to <code>delete[]</code> will actually delete the wrong number of elements.</p>\n<p>Other solutions (to store how big the array is) are naturally possible.  As an example, if you know you aren't calling an overload of <code>new</code> and you know details of your underlying memory allocation, you could reuse the data <em>it</em> uses to know your block size to determine the number of elements, thus saving an extra <code>size_t</code> of memory.  This requires knowing that your underlying allocator won't over-allocate on you, and that it stores the bytes used at a known offset to the data-pointer.</p>\n<p>Or, in theory, a compiler could build a separate pointer-&gt;size map.</p>\n<p>I am unaware of compilers that do either of these, but would be surprised by neither.</p>\n<p>Allowing this technique is what the C++ standard is talking about.  For array allocation, the compiler's <code>new</code> (not <code>operator new</code>) code is permitted to ask <code>operator new</code> for extra memory.  For non-array allocation, the compiler's <code>new</code> is <em>not</em> permitted to ask <code>operator new</code> for extra memory, it must ask for the exact amount.  (I believe there may be exceptions for memory-allocation merging?)</p>\n<p>As you can see, the two situations are different.</p>\n</hr></hr>", "LastEditorUserId": "1774667", "LastActivityDate": "2015-11-03T13:13:53.410", "Score": "22", "CreationDate": "2015-11-02T20:33:28.080", "ParentId": "33486001", "CommentCount": "11", "OwnerUserId": "1774667", "LastEditDate": "2015-11-03T13:13:53.410"}, "33486206": {"Id": "33486206", "PostTypeId": "2", "Body": "<p>I'm not sure that both talk about the same thing...</p>\n<p>It seems that Stroustrup is talking about a more general memory allocation, that inherently uses extra data to manage free/allocated chunks. I think he is not talking about the value of the size passed to <code>new</code> but what really happens at some lower level. He probably would say: when you ask for 10 bytes, the machine will probably use slightly more than 10 bytes. <strong>using the standard implementation</strong> seems to be important here.</p>\n<p>While the standard talks about the value passed to the function.</p>\n<p>One talks about implementation while the other not.</p>\n", "LastActivityDate": "2015-11-02T20:25:28.623", "CommentCount": "0", "CreationDate": "2015-11-02T20:25:28.623", "ParentId": "33486001", "Score": "2", "OwnerUserId": "719263"}, "bq_ids": {"n4140": {"so_33486001_33486001_1": {"length": 34, "quality": 0.9444444444444444, "section_id": 6092}}, "n3337": {"so_33486001_33486001_1": {"length": 26, "quality": 0.7222222222222222, "section_id": 5859}}, "n4659": {"so_33486001_33486001_1": {"length": 35, "quality": 0.9722222222222222, "section_id": 7588}}}, "33486001": {"ViewCount": "1843", "Body": "<p>I'm trying to understand the following paragraph from Stroustrup's \"The C++ Programming Language\" on page 282 (emphasis is mine):  </p>\n<blockquote>\n<p id=\"so_33486001_33486001_0\">To deallocate space allocated by new, delete and delete[] must be able\n  to determine the size of the object allocated. This implies that an\n  object allocated using the standard implementation of new will occupy\n  slightly more space than a static object. <strong>At a minimum, space is\n  needed to hold the object\u2019s size</strong>. Usually two or more words per\n  allocation are used for free-store management. Most modern machines\n  use 8-byte words. This overhead is not significant when we allocate\n  many objects or large objects, but it can matter if we allocate lots\n  of small objects (e.g., ints or Points) on the free store.</p>\n</blockquote>\n<p>Note that the author doesn't differentiate whether the object is an array, or not, in the sentence highlighted above.</p>\n<p>But according to paragraph \u00a75.3.4/11 in C++14, we have (my emphasis):</p>\n<blockquote>\n<p id=\"so_33486001_33486001_1\">When a new-expression calls an allocation function and that allocation\n  has not been extended, the new-expression passes the amount of space\n  requested to the allocation function as the first argument of type\n  std::size_t. That argument shall be no less than the size of the\n  object being created; it may be greater than the size of the object\n  being created <strong>only</strong> if the object is an array.</p>\n</blockquote>\n<p>I may be missing something, but it seems to me, we have a contradiction in those two statements. It was my understanding that the additional space required was only for array objects, and that <strong>this additional space would hold the number of elements in the array, not the array size in bytes</strong>.   </p>\n", "AcceptedAnswerId": "33486121", "Title": "Apparent contradiction between Stroustrup book and the C++Standard", "CreationDate": "2015-11-02T20:11:34.280", "Id": "33486001", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-11-03T13:13:53.410", "Score": "21", "OwnerUserId": "1577873", "Tags": "<c++><memory-management><c++14>", "AnswerCount": "6"}, "33489319": {"Id": "33489319", "PostTypeId": "2", "Body": "<p>There is no contradiction, because \"precisely the object's size\" is one possible implementation of \"at a minimum, the size of the object\".</p>\n<p>The number 42 is at least 42.</p>\n", "LastActivityDate": "2015-11-03T00:11:48.240", "CommentCount": "0", "CreationDate": "2015-11-03T00:11:48.240", "ParentId": "33486001", "Score": "0", "OwnerUserId": "560648"}, "33489504": {"Id": "33489504", "PostTypeId": "2", "Body": "<p>The quote from the standard is talking about the value passed to operator new; the quote from Stroustrup is talking about what operator new does with the value. The two are pretty much independent; the requirement is only that the allocator allocate <strong>at least</strong> as much storage as was requested. Allocators often allocate more space than was requested. What they do with that extra space is up to the implementation; often it's just padding. Note that even if you read the requirements narrowly, that the allocator must allocate the exact number of bytes requested, allocating more is allowed under the \"as if\" rule, because no portable program can detect how much memory was in fact allocated.</p>\n", "LastActivityDate": "2015-11-03T00:30:07.913", "CommentCount": "0", "CreationDate": "2015-11-03T00:30:07.913", "ParentId": "33486001", "Score": "3", "OwnerUserId": "1593860"}, "33486637": {"Id": "33486637", "PostTypeId": "2", "Body": "<p>There is no contradiction between the two paragraphs.</p>\n<p>The paragraph from the Standard discusses the rules of the first argument being passed to the allocation function.</p>\n<p>The paragraph out of Stroustrup doesn't talk focus on the first argument having type std::size_t but explains the allocation itself which is \"two or more words\" bigger than what new indicates, and that every programmer should know.</p>\n<p>Stroustrup's explanation is more low level, that's the difference. But there is no contradiction.</p>\n", "LastActivityDate": "2015-11-02T20:49:05.887", "CommentCount": "0", "CreationDate": "2015-11-02T20:49:05.887", "ParentId": "33486001", "Score": "3", "OwnerUserId": "4411577"}});