post_cb({"21421998": {"CommentCount": "2", "ViewCount": "2106", "PostTypeId": "1", "LastEditorUserId": "2881489", "CreationDate": "2014-01-29T04:18:45.743", "LastActivityDate": "2014-01-29T06:40:14.653", "Title": "Subtraction operation on unsigned char", "AcceptedAnswerId": "21422105", "LastEditDate": "2014-01-29T04:34:47.840", "Id": "21421998", "Score": "0", "Body": "<p>I have a curiosity about unsigned char. I have a curiosity about unsigned char. I did a subtraction operation on unsigned char accidentally.I know i am not supposed to do that. But i am bit curious about how a particular answer came. Can anybody explain this at bit level? </p>\n<pre><code>unsigned char x = 150;\nunsigned char y = 229;\n\nunsigned char z = x - y;\n</code></pre>\n<p>finally i got 177 for z during the debugging</p>\n<p>I am running this code in visual studio 2008. </p>\n", "Tags": "<c++><visual-studio-2008><subtraction><unsigned-char>", "OwnerUserId": "2881489", "AnswerCount": "2"}, "21422105": {"ParentId": "21421998", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_21421998_21422105_0\">Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2^n where n is the number\n  of bits in the value representation of that particular size of integer.</p>\n</blockquote>\n<p>(C++11 standard, 3.9.1.5)</p>\n<p>On most platforms an <code>unsigned char</code> is 8 bits, so the result is 150 - 229 mod 256 = -79 mod 256 = 177.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "21422105", "Score": "4", "CreationDate": "2014-01-29T04:28:03.727", "LastActivityDate": "2014-01-29T04:28:03.727"}, "bq_ids": {"n4140": {"so_21421998_21422105_0": {"section_id": 7213, "quality": 0.875, "length": 14}}, "n3337": {"so_21421998_21422105_0": {"section_id": 6957, "quality": 1.0, "length": 16}}, "n4659": {"so_21421998_21422105_0": {"section_id": 8722, "quality": 0.875, "length": 14}}}, "21422091": {"ParentId": "21421998", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes, if you subtract <code>229</code> from <code>150</code>, you end up with <code>-79</code>. However, since you're limited to the range <code>0..255</code> (assuming 8 bits) because of the destination, it wraps around to ensure that range is maintained. Hence you basically add <code>256</code> to <code>-79</code> to end up with <code>177</code>.</p>\n<p>In other words, <code>9 - 10</code> which would give you <code>-1</code> in a signed value, actually gives you <code>255</code> for an 8-bit <code>unsigned char</code>. Similarly, <code>9 - 11</code> would give you <code>254</code>.</p>\n<p>It's no different to addition, with <code>255 + 7</code> giving you <code>6</code> because it wraps back to <code>0</code> following <code>255</code>.</p>\n<p>Now, the rules are a <em>little</em> more complex than that insofar as the values may be promoted to a larger data type, then the subtraction done, then the result truncated. But <em>mathematically,</em> that first paragraph is correct.</p>\n", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2014-01-29T06:40:14.653", "Id": "21422091", "Score": "1", "CreationDate": "2014-01-29T04:26:10.827", "LastActivityDate": "2014-01-29T06:40:14.653"}});