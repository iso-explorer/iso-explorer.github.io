post_cb({"6456636": {"CommentCount": "0", "ViewCount": "786", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-06-23T15:29:11.720", "LastActivityDate": "2011-06-23T16:29:00.850", "Title": "Disambiguator template keyword for a template member of a template: when exactly?", "AcceptedAnswerId": "6456886", "LastEditDate": "2017-05-23T12:27:00.283", "Id": "6456636", "Score": "2", "Body": "<p>A question regarding template disambiguator was given here:</p>\n<p><a href=\"https://stackoverflow.com/questions/4077110/template-disambiguator\">template disambiguator</a></p>\n<p>and in the answer we can read:</p>\n<p>ISO C++03 <code>14.2/4</code></p>\n<blockquote>\n<p id=\"so_6456636_6456636_0\">When the name of a member template specialization appears after . or -&gt; in a postfix-expression, or after nested-name-specifier in a qualified-id, and the postfix-expression or qualified-id explicitly depends on a template-parameter (14.6.2), the member template name must be prefixed by the keyword template. Otherwise the name is assumed to name a non-template.</p>\n</blockquote>\n<p>Now here comes my conrete example that I don't quite understand:</p>\n<pre><code>template &lt;class T&gt;\nclass Base {\n  public:\n\n\n  template &lt;int v&gt;\n    static int baseGet() {return v;}\n\n  class InnerA {\n    public:\n\n    template &lt;int v&gt;\n      static int aget() {return v;}\n\n  };\n\n  class InnerB {\n    public:\n      typedef Base BaseType;\n      typedef BaseType::InnerA OtherType;\n\n      template &lt;int v&gt;\n        static int baseGet() {return BaseType::baseGet&lt;v&gt;();} //(A)\n\n      template &lt;int v&gt;\n        static int aget() {return OtherType::aget&lt;v&gt;();} //(B)\n  };\n};\n</code></pre>\n<p>It obviously fails to compile. You need <code>template</code> in the line (B): <code>OtherType::template aget&lt;v&gt;();</code>.\nHowever, both g++ (4.4.3) and clang++ (2.9) don't complain about the lack of <code>template</code> in the line (A). Why? <code>BaseType</code> depends on the type <code>T</code>, does it not? Is it a small depart from the standard by those compilers, or do I misunderstand something in the standard?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "635654", "AnswerCount": "3"}, "6456669": {"ParentId": "6456636", "CommentCount": "2", "Body": "<p><code>BaseType</code> does depend on the type <code>T</code>- but so does <code>InnerB</code>. In effect, from the perspective of any code inside <code>BaseType&lt;T&gt;</code>, it does not depend on <code>T</code>.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "6456669", "Score": "0", "CreationDate": "2011-06-23T15:31:50.143", "LastActivityDate": "2011-06-23T15:31:50.143"}, "6456755": {"ParentId": "6456636", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Because <code>OtherType</code> is a <em>nested</em> dependent name while <code>BaseType</code> is not a nested type to begin with.</p>\n<p>You need to use <code>template</code> for <em>nested</em> dependent types.</p>\n<p>The keywords here are:</p>\n<ul>\n<li>Dependent Type</li>\n<li>Nested Type</li>\n</ul>\n<p>If a <em>type</em> is both, then you've to use <em>template</em>.</p>\n<ul>\n<li><code>OtherType</code> is both dependent type (it depends on <code>T</code>) as well as nested type</li>\n<li><code>BaseType</code> is only dependent type (it depends on <code>T</code>). Its not a nested type.</li>\n</ul>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-06-23T15:44:19.767", "Id": "6456755", "Score": "1", "CreationDate": "2011-06-23T15:37:22.123", "LastActivityDate": "2011-06-23T15:44:19.767"}, "6456886": {"ParentId": "6456636", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>They implement the C++0x specification, where <code>Base</code> is the <em>current instantiation</em>. And C++0x allows to omit <code>template</code> keyword in such a case. Since <code>BaseType</code> is a typedef for <code>Base</code>, when you say <code>BaseType</code>, that names the current instantiation too. </p>\n<p>To quote the spec, since you seem to be interested in spec refs</p>\n<blockquote>\n<p id=\"so_6456636_6456886_0\">A name is a <strong>member of the current instantiation</strong> if it is [...]</p>\n<ul>\n<li>A qualified-id in which the nested-name-speci\ufb01er refers to the <strong>current instantiation</strong> and that, when looked up, refers to at least one member of the current instantiation or a non-dependent base class thereof. </li>\n</ul>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_6456636_6456886_1\">A name refers to the <strong>current instantiation</strong> if it is [...]</p>\n<ul>\n<li>in the definition of a [...] <strong>nested class</strong> of a class template, [...], <strong>the injected-class-name</strong> (Clause 9) of the class template or nested class</li>\n</ul>\n</blockquote>\n<p>and (the modified 14.2/4 that you quoted)</p>\n<blockquote>\n<p id=\"so_6456636_6456886_2\">[...] or the nested-name-specifier in the qualified-id refers to a dependent type, but the name is not a member of the current instantiation (14.6.2.1), the member template name must be prefixed by the keyword template. [...]</p>\n</blockquote>\n<hr>\n<p>Note: In C++03 your code is ill-formed because both <code>BaseType</code> and <code>OtherType</code> are dependent. The spec says:</p>\n<blockquote>\n<p id=\"so_6456636_6456886_3\">A type is dependent if it is [...]</p>\n<ul>\n<li>a template parameter</li>\n<li>a qualified-id with a nested-name-specifier which contains a class-name that names a dependent type</li>\n<li>a template-id in which either the template name is a template parameter or any of the template arguments is a dependent type </li>\n</ul>\n</blockquote>\n<p>(note that <code>Base</code> is equivalent to <code>Base&lt;T&gt;</code>, which is the base on which <code>Base</code> and <code>BaseType::InnerA</code> are dependent types). </p>\n<p>Note that \"explicitly depends\" in your quote is a pre-standard term, and was gotten rid of fairly lately (I believe it was at December1996). It basically meant (in this context) a qualified-id in which the qualifier is dependent or a class member access (<code>a-&gt;x</code> / <code>a.x</code>) where the <code>a</code> was dependent. After \"explicitly depends\" was removed from the draft, it was still lurking around at some places, and even C++0x has still references to \"explicitly depends\" in a note at 14.6.2p2:</p>\n<blockquote>\n<p id=\"so_6456636_6456886_4\">the base class name <code>B&lt;T&gt;</code>, the type name <code>T::A</code>, the names <code>B&lt;T&gt;::i</code> and <code>pb-&gt;j</code> <strong>explicitly depend</strong> on the template-parameter.</p>\n</blockquote>\n</hr>", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2011-06-23T16:29:00.850", "Id": "6456886", "Score": "8", "CreationDate": "2011-06-23T15:45:55.220", "LastActivityDate": "2011-06-23T16:29:00.850"}, "bq_ids": {"n4140": {"so_6456636_6456886_1": {"section_id": 72, "quality": 1.0, "length": 4}, "so_6456636_6456886_4": {"section_id": 189, "quality": 1.0, "length": 11}, "so_6456636_6456636_0": {"section_id": 72, "quality": 0.8620689655172413, "length": 25}, "so_6456636_6456886_2": {"section_id": 72, "quality": 0.9444444444444444, "length": 17}, "so_6456636_6456886_0": {"section_id": 72, "quality": 1.0, "length": 4}}, "n3337": {"so_6456636_6456886_1": {"section_id": 67, "quality": 1.0, "length": 4}, "so_6456636_6456886_4": {"section_id": 183, "quality": 1.0, "length": 11}, "so_6456636_6456636_0": {"section_id": 67, "quality": 0.8620689655172413, "length": 25}, "so_6456636_6456886_2": {"section_id": 67, "quality": 0.9444444444444444, "length": 17}, "so_6456636_6456886_0": {"section_id": 67, "quality": 1.0, "length": 4}}, "n4659": {"so_6456636_6456886_1": {"section_id": 200, "quality": 1.0, "length": 4}, "so_6456636_6456886_4": {"section_id": 194, "quality": 1.0, "length": 11}, "so_6456636_6456886_0": {"section_id": 196, "quality": 1.0, "length": 4}}}});