post_cb({"bq_ids": {"n4140": {"so_25562042_25562868_1": {"length": 26, "quality": 0.8387096774193549, "section_id": 447}, "so_25562042_25562868_4": {"length": 9, "quality": 0.8181818181818182, "section_id": 5792}, "so_25562042_25562267_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 5791}, "so_25562042_25562042_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 447}, "so_25562042_25562868_2": {"length": 26, "quality": 0.7222222222222222, "section_id": 447}, "so_25562042_25562868_3": {"length": 20, "quality": 0.8333333333333334, "section_id": 5791}, "so_25562042_25562267_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 5792}, "so_25562042_25562868_6": {"length": 8, "quality": 1.0, "section_id": 5792}, "so_25562042_25562868_5": {"length": 5, "quality": 1.0, "section_id": 5792}, "so_25562042_25562042_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 447}, "so_25562042_25562868_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 447}}, "n3337": {"so_25562042_25562868_1": {"length": 26, "quality": 0.8387096774193549, "section_id": 438}, "so_25562042_25562868_4": {"length": 9, "quality": 0.8181818181818182, "section_id": 5565}, "so_25562042_25562267_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 5564}, "so_25562042_25562042_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 438}, "so_25562042_25562868_2": {"length": 26, "quality": 0.7222222222222222, "section_id": 438}, "so_25562042_25562868_3": {"length": 20, "quality": 0.8333333333333334, "section_id": 5564}, "so_25562042_25562267_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 5565}, "so_25562042_25562868_6": {"length": 8, "quality": 1.0, "section_id": 5565}, "so_25562042_25562868_5": {"length": 5, "quality": 1.0, "section_id": 5565}, "so_25562042_25562042_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 438}, "so_25562042_25562868_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 438}}, "n4659": {"so_25562042_25562868_1": {"length": 26, "quality": 0.8387096774193549, "section_id": 469}, "so_25562042_25562868_4": {"length": 9, "quality": 0.8181818181818182, "section_id": 7251}, "so_25562042_25562267_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 7248}, "so_25562042_25562042_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 469}, "so_25562042_25562868_2": {"length": 26, "quality": 0.7222222222222222, "section_id": 469}, "so_25562042_25562868_3": {"length": 20, "quality": 0.8333333333333334, "section_id": 7248}, "so_25562042_25562267_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 7251}, "so_25562042_25562868_6": {"length": 8, "quality": 1.0, "section_id": 7251}, "so_25562042_25562868_5": {"length": 5, "quality": 1.0, "section_id": 7251}, "so_25562042_25562042_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 469}, "so_25562042_25562868_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 469}}}, "25562042": {"ViewCount": "294", "Body": "<p>Code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing std::cout;\nusing std::endl;\n\nstruct A\n{\n    virtual void foo()\n    {\n        cout &lt;&lt; \"A\" &lt;&lt; endl;\n    }\n\n    A(){ }\n};\n\nstruct B : A\n{\n    B();\n    virtual void foo()\n    {\n        cout &lt;&lt; \"B\" &lt;&lt; endl;\n    }\n};\n\nB b;\n\nB::B()\n{\n    b.foo();\n    foo();\n}  \n\nstruct C : B\n{\n    virtual void foo()\n    {\n        cout &lt;&lt; \"C\" &lt;&lt; endl;\n    }\n\n    C() : B(){ }      \n};\n\nC c;\n\nint main(){ }\n</code></pre>\n<p><a href=\"http://ideone.com/aV5y5s\"><strong>DEMO</strong></a></p>\n<blockquote>\n<p id=\"so_25562042_25562042_0\">When a virtual function is called directly or indirectly from a\n  constructor or from a destructor, including during the construction or\n  destruction of the class\u2019s non-static data members, and the <strong>object\n  to which the call applies is the object (call it x)</strong> under\n  construction or destruction, the function called is the final\n  overrider in the constructor\u2019s or destructor\u2019s class and not one\n  overriding it in a more-derived class. If the virtual function call\n  uses an explicit class member access (5.2.5) and the <strong>object\n  expression refers to the complete object of x</strong> or one of that\n  object\u2019s base class subobjects but not x or one of its base class\n  subobjects, the behavior is undefined.</p>\n</blockquote>\n<p>I've been trying to recieve UB for </p>\n<blockquote>\n<p id=\"so_25562042_25562042_1\">If the virtual function call uses an explicit class member access\n  (5.2.5) and the object expression refers to the complete object of x\n  [...]</p>\n</blockquote>\n<p>It is unclear what means <strong>complete object of x</strong>, where <code>x</code> is an object. Is it the same as complete object of type of <code>x</code>?</p>\n", "AcceptedAnswerId": "25562267", "Title": "Call a virtual function inside the constructor using an object-expression", "CreationDate": "2014-08-29T05:12:24.633", "LastActivityDate": "2014-09-08T12:21:23.333", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "Id": "25562042", "Score": "6", "Tags": "<c++>", "AnswerCount": "2"}, "25562267": {"Id": "25562267", "PostTypeId": "2", "Body": "<p>\u00a71.8 [intro.object]/p2-3:</p>\n<blockquote>\n<p id=\"so_25562042_25562267_0\">Objects can contain other objects, called <em>subobjects</em>. A subobject\n  can be a <em>member subobject</em> (9.2), a <em>base class subobject</em> (Clause\n  10), or an array element. An object that is not a subobject of any\n  other object is called a <em>complete object</em>.</p>\n<p id=\"so_25562042_25562267_1\">For every object <code>x</code>, there is some object called the <em>complete object\n  of <code>x</code></em>, determined as follows:</p>\n<ul>\n<li>If <code>x</code> is a complete object, then <code>x</code> is the complete object of <code>x</code>.</li>\n<li>Otherwise, the complete object of <code>x</code> is the complete object of the (unique) object that contains <code>x</code>.</li>\n</ul>\n</blockquote>\n<p>In essence, the sentence you cited makes doing <code>static_cast&lt;C*&gt;(this)-&gt;foo();</code> in <code>B</code>'s constructor undefined behavior in your code, even if the complete object being constructed is a <code>C</code>. The standard actually provides a pretty good example here:</p>\n<pre><code>struct V {\n    virtual void f();\n    virtual void g();\n};\nstruct A : virtual V {\n    virtual void f();\n};\nstruct B : virtual V {\n    virtual void g();\n    B(V*, A*);\n};\n\nstruct D : A, B {\n    virtual void f();\n    virtual void g();\n    D() : B((A*)this, this) { }\n};\n\nB::B(V* v, A* a) {\n    f();    // calls V::f, not A::f\n    g();    // calls B::g, not D::g\n    v-&gt;g(); // v is base of B, the call is well-defined, calls B::g\n    a-&gt;f(); // undefined behavior, a\u2019s type not a base of B\n}\n</code></pre>\n<p>In fact, you can already <a href=\"http://ideone.com/Xw8hUb\" rel=\"noreferrer\">see the undefined behavior show up in this example if you run it</a>: Ideone's compiler (GCC) actually calls <code>V::f()</code> on the <code>a-&gt;f();</code> line, even though the pointer is referring to a fully constructed <code>A</code> subobject.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-29T06:10:47.140", "Score": "7", "CreationDate": "2014-08-29T05:39:05.100", "ParentId": "25562042", "CommentCount": "8", "OwnerUserId": "2756719", "LastEditDate": "2014-08-29T06:10:47.140"}, "25562868": {"Id": "25562868", "PostTypeId": "2", "Body": "<p>This is kind of tricky and I had to edit the post several times (thanks to the guys who helped me out), I'll try to get it simple and referring to N3690:</p>\n<p>\u00a712.7.4 states</p>\n<blockquote>\n<p id=\"so_25562042_25562868_0\">Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2).</p>\n</blockquote>\n<p>and this is what you've been doing in B's constructor</p>\n<pre><code>B::B()\n{\n    b.foo(); // virtual\n    foo(); // virtual\n}  \n</code></pre>\n<p>This is perfectly legit for now. The <em>this</em> pointer (implicitly used in the second function call) always points to the object being constructed.</p>\n<p>Then the standard also says:</p>\n<blockquote>\n<p id=\"so_25562042_25562868_1\">When a virtual function is called directly or indirectly from a constructor and the object to which the\n  call applies is the object (call it x) under construction or destruction the function called is the final overrider\n  in the constructor\u2019s or destructor\u2019s class and not one overriding it in a more-derived class (thus ignore the more-derived versions of the function)</p>\n</blockquote>\n<p>so the vtable is not completely walked as you might think but stops to the constructor's class' version of the virtual function (see <a href=\"http://www.parashift.com/c%2B%2B-faq-lite/calling-virtuals-from-ctors.html\" rel=\"nofollow\">http://www.parashift.com/c%2B%2B-faq-lite/calling-virtuals-from-ctors.html</a>). </p>\n<p>Still legit.</p>\n<p>Finally to your point:</p>\n<blockquote>\n<p id=\"so_25562042_25562868_2\">If the virtual function call uses an explicit class member access e.g. \n  (object.vfunction() or object-&gt;vfunction()) and the object expression refers to the complete object of x or one of that object\u2019s base class subobjects but not x or one of its base class subobjects, (i.e. not the object under construction or one of its base class subobjects), the behavior is undefined.</p>\n</blockquote>\n<p>to understand this sentence we first need to understand what a <em>complete object of x</em> means:</p>\n<p>\u00a71.8.2</p>\n<blockquote>\n<p id=\"so_25562042_25562868_3\">Objects can contain other objects, called subobjects. A subobject can be a member subobject (9.2), a base\n  class subobject (Clause 10), or an array element. An object that is not a subobject of any other object is\n  called a complete object.</p>\n<p id=\"so_25562042_25562868_4\">For every object x, there is some object called the complete object of x, determined as follows:</p>\n<p id=\"so_25562042_25562868_5\">\u2014 If x is a complete object, then x is the complete object of x.</p>\n<p id=\"so_25562042_25562868_6\">\u2014 Otherwise, the complete object of x is the complete object of the (unique) object that contains x</p>\n</blockquote>\n<p>if you put together the passage above with the previous one you get that you can't call a virtual function referring to \"the complete type\" of a base class (i.e. the derived object not yet constructed) or an object which owns that member or array element.</p>\n<p>If you were to explicitly refer to C in B's constructor:</p>\n<pre><code>B::B() {\n    static_cast&lt;C*&gt;(this)-&gt;foo(); // Refers to the complete object of B, i.e. C\n}\n\nstruct C : B\n{\n    C() : B(){ }\n}\n</code></pre>\n<p>then you would have had undefined behavior.</p>\n<p>The intuitive (more or less) reason is that </p>\n<ul>\n<li><p>Calling a virtual or member function in a constructor is allowed and in case of virtual functions it \"stops the virtual hierarchy walk\" to that object and calls its version of the function (see <a href=\"http://www.parashift.com/c%2B%2B-faq-lite/calling-virtuals-from-ctors.html\" rel=\"nofollow\">http://www.parashift.com/c%2B%2B-faq-lite/calling-virtuals-from-ctors.html</a>)</p></li>\n<li><p>Anyway if you do that from a subobject referring to a complete object of that subobject (re-read the standard passage), then it's undefined behavior</p></li>\n</ul>\n<p>Rule of thumb: <a href=\"http://www.parashift.com/c++-faq/using-this-in-ctors.html\" rel=\"nofollow\">don't call virtual functions in your constructors/destructors if you're not really sure you can</a>.</p>\n<p>In case I got something wrong please let me know in the comments below and I'll fix the post. Thanks!</p>\n", "LastEditorUserId": "1938163", "LastActivityDate": "2014-09-08T12:21:23.333", "Score": "2", "CreationDate": "2014-08-29T06:38:29.443", "ParentId": "25562042", "CommentCount": "10", "OwnerUserId": "1938163", "LastEditDate": "2014-09-08T12:21:23.333"}});