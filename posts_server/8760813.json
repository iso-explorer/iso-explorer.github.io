post_cb({"bq_ids": {"n4140": {"so_8760813_8760854_0": {"length": 18, "quality": 0.6428571428571429, "section_id": 378}, "so_8760813_8760854_2": {"length": 62, "quality": 0.9393939393939394, "section_id": 480}, "so_8760813_8760813_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 480}}, "n3337": {"so_8760813_8760854_0": {"length": 20, "quality": 0.7142857142857143, "section_id": 369}, "so_8760813_8760854_2": {"length": 63, "quality": 0.9545454545454546, "section_id": 471}}, "n4659": {"so_8760813_8760854_2": {"length": 62, "quality": 0.9393939393939394, "section_id": 502}}}, "8760813": {"ViewCount": "264", "Body": "<p>Scott Meyers says:</p>\n<blockquote>\n<p id=\"so_8760813_8760813_0\">C++ specifies that an object thrown as an exception is always copied and the copying is performed by the object's copy constructor.</p>\n</blockquote>\n<p>But in my code:</p>\n<pre><code>struct test\n{\n    test() { cout &lt;&lt; \"constructor is called\" &lt;&lt; endl; }\n    test(const test&amp;) { cout &lt;&lt; \"copy constructor is called\" &lt;&lt; endl; }\n    ~test() { cout &lt;&lt; \"destructor is called\" &lt;&lt; endl; }\n};\n\nvoid fun()\n{\n    throw test();\n}\n\nint main()\n{\n    try { \n       fun();\n    }\n    catch (test&amp; t1) { cout &lt;&lt; \"exception handler\" &lt;&lt; endl; }\n}\n</code></pre>\n<p>I do not see the exception object's copy constructor being called.</p>\n<p>If I change the <code>catch</code> to receive the exception object by value then it is, but according to Meyers's quote the exception object should have been copied even when it's received by reference.</p>\n<p><strong>Why is the copy constructor is not called (even when exception handling is performed by reference)?</strong></p>\n", "AcceptedAnswerId": "8760854", "Title": "If a thrown exception is always a copy of the exception object, why isn't this copy constructor being invoked?", "CreationDate": "2012-01-06T16:13:14.637", "Id": "8760813", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-01-06T16:28:09.690", "LastEditorUserId": "560648", "LastActivityDate": "2012-01-06T16:33:24.520", "Score": "9", "OwnerUserId": "791403", "Tags": "<c++>", "AnswerCount": "1"}, "8760854": {"Id": "8760854", "PostTypeId": "2", "Body": "<p>Meyers is correct that a copy is made, semantically:</p>\n<blockquote>\n<p id=\"so_8760813_8760854_0\"><code>[C++11: 12.2/1]:</code> <strong>Temporaries of class type are created in various contexts</strong>: binding a reference to a prvalue (8.5.3), returning a prvalue (6.6.3), a conversion that creates a prvalue (4.1, 5.2.9, 5.2.11, 5.4), <strong>throwing an exception (15.1),</strong> entering a handler (15.3), and in some initializations (8.5). [..]</p>\n<p id=\"so_8760813_8760854_1\"><code>[C++11: 15.1/4]:</code> The memory for <strong>the temporary copy of the exception</strong> being thrown is allocated in an unspecified way, except as noted in 3.7.3.1. The temporary persists as long as there is a handler being executed for that exception.</p>\n</blockquote>\n<p>However, copies can be elided by clever compilers and they are allowed to do so regardless of side-effects.</p>\n<blockquote>\n<p id=\"so_8760813_8760854_2\"><code>[C++11: 12.8/31]:</code> <strong>When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object</strong>, even if the copy/move constructor and/or destructor for the object have side effects. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization. This elision of copy/move operations, called <em>copy elision</em>, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<ul>\n<li>[..]</li>\n<li><strong>when a temporary class object</strong> that has not been bound to a reference (12.2) <strong>would be copied/moved to a class object</strong> with the same cv-unqualified type, <strong>the copy/move operation can be omitted</strong> by constructing the temporary object directly into the target of the omitted copy/move.</li>\n<li>[..]</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "560648", "LastActivityDate": "2012-01-06T16:33:24.520", "Score": "11", "CreationDate": "2012-01-06T16:16:04.853", "ParentId": "8760813", "CommentCount": "7", "OwnerUserId": "560648", "LastEditDate": "2012-01-06T16:33:24.520"}});