post_cb({"bq_ids": {"n4140": {"so_33689895_33690255_1": {"length": 61, "quality": 0.953125, "section_id": 3919}}, "n3337": {"so_33689895_33690255_1": {"length": 61, "quality": 0.953125, "section_id": 3779}}, "n4659": {"so_33689895_33690255_1": {"length": 49, "quality": 0.765625, "section_id": 4805}}}, "33689895": {"ViewCount": "115", "Body": "<p>I just read <a href=\"https://www.justsoftwaresolutions.co.uk/articles/implementing_mutexes.html\" rel=\"nofollow\">this</a> article about the actual reasons behind the current <code>boost::mutex</code> implementation and noticed the following phrase:</p>\n<blockquote>\n<p id=\"so_33689895_33689895_0\">Block-scope statics have the additional problem of a potential race\n  condition on \"the first time through\", which can lead to the\n  destructor being run multiple times on popular compilers, which is\n  undefined behaviour \u2014 compilers often use the equivalent of a call to\n  atexit in order to ensure that destruction is done in the reverse\n  order of construction, and the initialization race that may cause the\n  constructor to be run twice may also cause the destructor to be\n  registered twice</p>\n</blockquote>\n<p>Is it true? Should I really check whether another thread already inside this object's destructor via atomic operations or something like this? Should I do it even in C++11 - C++14? Because as far as I know there's no more \"constructor for the same local object with static storage duration can be called simultaneously from several threads\" problem since C++11 -- it requires that another threads should wait for the constructor's completion. Am I right?</p>\n", "AcceptedAnswerId": "33690255", "Title": "Destructors of block-scope statics can be called several times?", "CreationDate": "2015-11-13T09:51:55.473", "Id": "33689895", "CommentCount": "0", "LastEditDate": "2015-11-13T10:02:06.943", "PostTypeId": "1", "LastEditorUserId": "60281", "LastActivityDate": "2015-11-14T01:17:54.880", "Score": "4", "OwnerUserId": "1608835", "Tags": "<c++><multithreading><c++11>", "AnswerCount": "1"}, "33690255": {"Id": "33690255", "PostTypeId": "2", "Body": "<p>It looks like this article was written pre C++11, it says amongst other things:</p>\n<blockquote>\n<p id=\"so_33689895_33690255_0\">[...] next version of the C++ Standard, scheduled to be released in 2009.[...]</p>\n</blockquote>\n<p>and this was the case pre C++11, it was unspecified what happened in this case since threading was not part of memory model pre C++11.</p>\n<p>This changed in C++11 and the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">draft C++11 standard</a> section <code>6.7</code> <em>Declaration statement</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_33689895_33690255_1\">The zero-initialization (8.5) of <strong>all block-scope variables with static\n  storage duration</strong> (3.7.1) or thread storage duration (3.7.2) is\n  performed before any other initialization takes place. [...] Otherwise\n  such a variable is initialized the first time control passes through\n  its declaration; such a variable is considered initialized upon the\n  completion of its initialization. If the initialization exits by\n  throwing an exception, the initialization is not complete, so it will\n  be tried again the next time control enters the declaration. <strong>If\n  control enters the declaration concurrently while the variable is\n  being initialized, the concurrent execution shall wait for completion\n  of the initialization.</strong> [...]</p>\n</blockquote>\n<p>Pre C++11 we have to treat the static local variable just like we treat any other critical section. We can find a excellent description of the situation pre C++11 in the post <a href=\"http://blogs.msdn.com/b/oldnewthing/archive/2004/03/08/85901.aspx\" rel=\"nofollow\">C++ scoped static initialization is not thread-safe, on purpose!</a>.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-14T01:17:54.880", "Score": "2", "CreationDate": "2015-11-13T10:09:33.047", "ParentId": "33689895", "CommentCount": "4", "OwnerUserId": "1708801", "LastEditDate": "2015-11-14T01:17:54.880"}});