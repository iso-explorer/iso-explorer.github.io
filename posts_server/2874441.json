post_cb({"2874441": {"ViewCount": "66704", "Body": "<p>I need to go through a set and remove elements that meet a predefined criteria.</p>\n<p>This is the test code I wrote:</p>\n<pre><code>#include &lt;set&gt;\n#include &lt;algorithm&gt;\n\nvoid printElement(int value) {\n    std::cout &lt;&lt; value &lt;&lt; \" \";\n}\n\nint main() {\n    int initNum[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    std::set&lt;int&gt; numbers(initNum, initNum + 10);\n    // print '0 1 2 3 4 5 6 7 8 9'\n    std::for_each(numbers.begin(), numbers.end(), printElement);\n\n    std::set&lt;int&gt;::iterator it = numbers.begin();\n\n    // iterate through the set and erase all even numbers\n    for (; it != numbers.end(); ++it) {\n        int n = *it;\n        if (n % 2 == 0) {\n            // wouldn't invalidate the iterator?\n            numbers.erase(it);\n        }\n    }\n\n    // print '1 3 5 7 9'\n    std::for_each(numbers.begin(), numbers.end(), printElement);\n\n    return 0;\n}\n</code></pre>\n<p>At first, I thought that erasing an element from the set while iterating through it would invalidate the iterator, and the increment at the for loop would have undefined behavior. Even though, I executed this test code and all went well, and I can't explain why.</p>\n<p><strong>My question:</strong>\nIs this the defined behavior for std sets or is this implementation specific? I am using gcc 4.3.3 on ubuntu 10.04 (32-bit version), by the way.</p>\n<p>Thanks!</p>\n<p><strong>Proposed solution:</strong></p>\n<p>Is this a correct way to iterate and erase elements from the set?</p>\n<pre><code>while(it != numbers.end()) {\n    int n = *it;\n    if (n % 2 == 0) {\n        // post-increment operator returns a copy, then increment\n        numbers.erase(it++);\n    } else {\n        // pre-increment operator increments, then return\n        ++it;\n    }\n}\n</code></pre>\n<p><strong>Edit: PREFERED SOLUTION</strong></p>\n<p>I came around a solution that seems more elegant to me, even though it does exactly the same.</p>\n<pre><code>while(it != numbers.end()) {\n    // copy the current iterator then increment it\n    std::set&lt;int&gt;::iterator current = it++;\n    int n = *current;\n    if (n % 2 == 0) {\n        // don't invalidate iterator it, because it is already\n        // pointing to the next element\n        numbers.erase(current);\n    }\n}\n</code></pre>\n<p>If there are several test conditions inside the while, each one of them must increment the iterator. I like this code better because the iterator is incremented <strong>only in one place</strong>, making the code less error-prone and more readable.</p>\n", "AcceptedAnswerId": "2874533", "Title": "Deleting elements from STL set while iterating", "CreationDate": "2010-05-20T14:03:53.927", "Id": "2874441", "CommentCount": "9", "FavoriteCount": "36", "PostTypeId": "1", "LastEditDate": "2012-06-22T07:02:12.817", "LastEditorUserId": "134841", "LastActivityDate": "2015-10-27T06:58:23.473", "Score": "99", "OwnerUserId": "83284", "Tags": "<c++><stl><iterator><set>", "AnswerCount": "5"}, "2874533": {"Id": "2874533", "PostTypeId": "2", "Body": "<p>This is implementation dependent:</p>\n<p>Standard 23.1.2.8:</p>\n<blockquote>\n<p id=\"so_2874441_2874533_0\">The insert members shall not affect the validity of iterators and references to the container, and the erase members shall invalidate only iterators and references to the erased elements.</p>\n</blockquote>\n<p>Maybe you could try this -- this is standard conforming:</p>\n<pre><code>for (it = numbers.begin(); it != numbers.end(); ) {\n    if (*it % 2 == 0) {\n        numbers.erase(it++);\n    }\n    else {\n        ++it;\n    }\n}\n</code></pre>\n<p>Note that it++ is postfix, hence it passes the old position to erase, but first jumps to a newer one due to the operator.</p>\n<p><strong>2015.10.27 update:</strong>\nC++11 has resolved the defect. <code>iterator erase (const_iterator position);</code> return an iterator to the element that follows the last element removed (or set::end, if the last element was removed). So C++11 style is:</p>\n<pre><code>for (it = numbers.begin(); it != numbers.end(); ) {\n    if (*it % 2 == 0) {\n        it = numbers.erase(it);\n    }\n    else {\n        ++it;\n    }\n}\n</code></pre>\n", "LastEditorUserId": "261378", "LastActivityDate": "2015-10-27T06:58:23.473", "Score": "125", "CreationDate": "2010-05-20T14:13:56.913", "ParentId": "2874441", "CommentCount": "2", "OwnerUserId": "233522", "LastEditDate": "2015-10-27T06:58:23.473"}, "2874501": {"Id": "2874501", "PostTypeId": "2", "Body": "<p>This behaviour is implementation specific. To guarantee the correctness of the iterator you should use \"it = numbers.erase(it);\" statement if you need to delete the element and simply incerement iterator in other case.</p>\n", "LastActivityDate": "2010-05-20T14:09:49.603", "CommentCount": "3", "CreationDate": "2010-05-20T14:09:49.603", "ParentId": "2874441", "Score": "0", "OwnerUserId": "346176"}, "bq_ids": {"n4140": {"so_2874441_2874533_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 745}}, "n3337": {"so_2874441_2874533_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 734}}, "n4659": {"so_2874441_2874533_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 803}}}, "2874726": {"Id": "2874726", "PostTypeId": "2", "Body": "<p>If you run your program through valgrind, you'll see a bunch of read errors.  In other words, yes, the iterators are being invalidated, but you're getting lucky in your example (or really unlucky, as you're not seeing the negative effects of undefined behavior).  One solution to this is to create a temporary iterator, increment the temp, delete the target iterator, then set the target to the temp.  For example, re-write your loop as follows:</p>\n<pre><code>std::set&lt;int&gt;::iterator it = numbers.begin();                               \nstd::set&lt;int&gt;::iterator tmp;                                                \n\n// iterate through the set and erase all even numbers                       \nfor ( ; it != numbers.end(); )                                              \n{                                                                           \n    int n = *it;                                                            \n    if (n % 2 == 0)                                                         \n    {                                                                       \n        tmp = it;                                                           \n        ++tmp;                                                              \n        numbers.erase(it);                                                  \n        it = tmp;                                                           \n    }                                                                       \n    else                                                                    \n    {                                                                       \n        ++it;                                                               \n    }                                                                       \n} \n</code></pre>\n", "LastActivityDate": "2010-05-20T14:35:05.043", "CommentCount": "2", "CreationDate": "2010-05-20T14:35:05.043", "ParentId": "2874441", "Score": "17", "OwnerUserId": "275669"}, "32162642": {"Id": "32162642", "PostTypeId": "2", "Body": "<p>Just to warn, that in case of a deque container, all solutions that check for the deque iterator equality to numbers.end() will likely fail on gcc 4.8.4. Namely, erasing an element of the deque generally invalidates pointer to numbers.end(): </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\nint main() \n{\n\n  deque&lt;int&gt; numbers;\n\n  numbers.push_back(0);\n  numbers.push_back(1);\n  numbers.push_back(2);\n  numbers.push_back(3);\n  //numbers.push_back(4);\n\n  deque&lt;int&gt;::iterator  it_end = numbers.end();\n\n  for (deque&lt;int&gt;::iterator it = numbers.begin(); it != numbers.end(); ) {\n    if (*it % 2 == 0) {\n      cout &lt;&lt; \"Erasing element: \" &lt;&lt; *it &lt;&lt; \"\\n\";\n      numbers.erase(it++);\n      if (it_end == numbers.end()) {\n    cout &lt;&lt; \"it_end is still pointing to numbers.end()\\n\";\n      } else {\n    cout &lt;&lt; \"it_end is not anymore pointing to numbers.end()\\n\";\n      }\n    }\n    else {\n      cout &lt;&lt; \"Skipping element: \" &lt;&lt; *it &lt;&lt; \"\\n\";\n      ++it;\n    }\n  }\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Erasing element: 0\nit_end is still pointing to numbers.end()\nSkipping element: 1\nErasing element: 2\nit_end is not anymore pointing to numbers.end()\n</code></pre>\n<p>Note that while the deque transformation is correct in this particular case, the end pointer has been invalidated along the way. With the deque of a different size the error is more apparent:</p>\n<pre><code>int main() \n{\n\n  deque&lt;int&gt; numbers;\n\n  numbers.push_back(0);\n  numbers.push_back(1);\n  numbers.push_back(2);\n  numbers.push_back(3);\n  numbers.push_back(4);\n\n  deque&lt;int&gt;::iterator  it_end = numbers.end();\n\n  for (deque&lt;int&gt;::iterator it = numbers.begin(); it != numbers.end(); ) {\n    if (*it % 2 == 0) {\n      cout &lt;&lt; \"Erasing element: \" &lt;&lt; *it &lt;&lt; \"\\n\";\n      numbers.erase(it++);\n      if (it_end == numbers.end()) {\n    cout &lt;&lt; \"it_end is still pointing to numbers.end()\\n\";\n      } else {\n    cout &lt;&lt; \"it_end is not anymore pointing to numbers.end()\\n\";\n      }\n    }\n    else {\n      cout &lt;&lt; \"Skipping element: \" &lt;&lt; *it &lt;&lt; \"\\n\";\n      ++it;\n    }\n  }\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Erasing element: 0\nit_end is still pointing to numbers.end()\nSkipping element: 1\nErasing element: 2\nit_end is still pointing to numbers.end()\nSkipping element: 3\nErasing element: 4\nit_end is not anymore pointing to numbers.end()\nErasing element: 0\nit_end is not anymore pointing to numbers.end()\nErasing element: 0\nit_end is not anymore pointing to numbers.end()\n...\nSegmentation fault (core dumped)\n</code></pre>\n<p>Here is one of the ways to fix this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;deque&gt;\n\nusing namespace std;\nint main() \n{\n\n  deque&lt;int&gt; numbers;\n  bool done_iterating = false;\n\n  numbers.push_back(0);\n  numbers.push_back(1);\n  numbers.push_back(2);\n  numbers.push_back(3);\n  numbers.push_back(4);\n\n  if (!numbers.empty()) {\n    deque&lt;int&gt;::iterator it = numbers.begin();\n    while (!done_iterating) {\n      if (it + 1 == numbers.end()) {\n    done_iterating = true;\n      } \n      if (*it % 2 == 0) {\n    cout &lt;&lt; \"Erasing element: \" &lt;&lt; *it &lt;&lt; \"\\n\";\n      numbers.erase(it++);\n      }\n      else {\n    cout &lt;&lt; \"Skipping element: \" &lt;&lt; *it &lt;&lt; \"\\n\";\n    ++it;\n      }\n    }\n  }\n}\n</code></pre>\n", "LastEditorUserId": "2356296", "LastActivityDate": "2015-08-23T02:45:55.813", "Score": "2", "CreationDate": "2015-08-23T02:32:24.757", "ParentId": "2874441", "CommentCount": "0", "OwnerUserId": "2356296", "LastEditDate": "2015-08-23T02:45:55.813"}, "2874545": {"Id": "2874545", "PostTypeId": "2", "Body": "<p>You misunderstand what \"undefined behavior\" means. Undefined behavior does not mean \"if you do this, your program <em>will</em> crash or produce unexpected results.\" It means \"if you do this, your program <em>could</em> crash or produce unexpected results\", or do anything else, depending on your compiler, your operating system, the phase of the moon, etc.</p>\n<p>If something executes without crashing and behaves as you expect it to, that is <em>not</em> proof that it is not undefined behavior. All it proves is that its behavior happened to be as observed for that particular run after compiling with that particular compiler on that particular operating system.</p>\n<p>Erasing an element from a set invalidates the iterator to the erased element. Using an invalidated iterator is undefined behavior. It just so happened that the observed behavior was what you intended in this particular instance; it does not mean that the code is correct.</p>\n", "LastActivityDate": "2010-05-20T14:15:38.757", "CommentCount": "3", "CreationDate": "2010-05-20T14:15:38.757", "ParentId": "2874441", "Score": "4", "OwnerUserId": "39375"}});