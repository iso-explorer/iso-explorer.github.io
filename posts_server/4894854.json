post_cb({"4894879": {"Id": "4894879", "PostTypeId": "2", "Body": "<p>This is called 'implicit template instantiation'. See the standard, section 14.7.1. I would note that this is very commonly used for function templates.</p>\n", "LastActivityDate": "2011-02-04T05:31:44.257", "CommentCount": "1", "CreationDate": "2011-02-04T05:31:44.257", "ParentId": "4894854", "Score": "1", "OwnerUserId": "540026"}, "4894898": {"Id": "4894898", "PostTypeId": "2", "Body": "<p>You aren't necessarily required to specify each type parameter. Essentially, the compiler figures out Y from the type of the parameter passed in, and you specified X in your declaration. Just another difference between Java and C++.</p>\n", "LastActivityDate": "2011-02-04T05:35:25.457", "CommentCount": "0", "CreationDate": "2011-02-04T05:35:25.457", "ParentId": "4894854", "Score": "1", "OwnerUserId": "364015"}, "bq_ids": {"n4140": {"so_4894854_4894884_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 235}, "so_4894854_4894884_1": {"length": 17, "quality": 0.8095238095238095, "section_id": 293}}, "n3337": {"so_4894854_4894884_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 228}, "so_4894854_4894884_1": {"length": 17, "quality": 0.8095238095238095, "section_id": 284}}, "n4659": {"so_4894854_4894884_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 245}, "so_4894854_4894884_1": {"length": 17, "quality": 0.8095238095238095, "section_id": 300}}}, "4894884": {"Id": "4894884", "PostTypeId": "2", "Body": "<p>14.7.1 Paragraph 2:</p>\n<blockquote>\n<p id=\"so_4894854_4894884_0\">Unless a function template specialization has been explicitly instantiated or explicitly specialized, the function template specialization is implicitly instantiated when the specialization is referenced in a context that requires a function definition to exist.</p>\n</blockquote>\n<p>As Jeremiah points out, argument deduction is what you're <em>really</em> asking about:</p>\n<p>14.8.2:</p>\n<blockquote>\n<p id=\"so_4894854_4894884_1\">When a template function specialization is referenced, all of the template arguments must have values. The values can be either explicitly specified or, in some cases, deduced from the use. ...</p>\n</blockquote>\n<p>The process is described in detail there.</p>\n<p>Source: ISO/IEC 14882:1998(E)</p>\n", "LastActivityDate": "2011-02-04T05:32:18.880", "CommentCount": "2", "CreationDate": "2011-02-04T05:32:18.880", "ParentId": "4894854", "Score": "3", "OwnerUserId": "99032"}, "4894854": {"ViewCount": "85", "Body": "<p>Suppose the following template definition (the code is meaningless):</p>\n<pre><code>template&lt;class X, class Y&gt;\nbool FooBar(const Y&amp; val) { return sizeof(X) + 4; }\n</code></pre>\n<p>I have found that following calling code was legal:</p>\n<pre><code>float temp = 0.f;\nFooBar&lt;int&gt;(temp);\n</code></pre>\n<p>As you can see, the second type parameter <code>Y</code> can be omitted. A compiler infers the type of <code>Y</code> by looking the argument type of <code>temp</code>.</p>\n<p>What rule or specification of C++ template allows this? I was pretty surprised to see it.</p>\n", "AcceptedAnswerId": "4894877", "Title": "A question regarding C++ template", "CreationDate": "2011-02-04T05:27:37.720", "Id": "4894854", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2011-02-04T05:35:25.457", "Score": "3", "OwnerUserId": "202699", "Tags": "<c++><templates>", "AnswerCount": "4"}, "4894877": {"Id": "4894877", "PostTypeId": "2", "Body": "<p>That is template argument deduction; it is the same as if you used <code>X</code> as the type of a value parameter of <code>FooBar</code> and called it without any template arguments at all.  There is a document with more details at <a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/topic/com.ibm.xlcpp8a.doc/language/ref/template_argument_deduction.htm\" rel=\"nofollow\">IBM's compiler site</a>.</p>\n", "LastActivityDate": "2011-02-04T05:31:41.530", "CommentCount": "0", "CreationDate": "2011-02-04T05:31:41.530", "ParentId": "4894854", "Score": "5", "OwnerUserId": "319906"}});