post_cb({"4894898": {"ParentId": "4894854", "CommentCount": "0", "Body": "<p>You aren't necessarily required to specify each type parameter. Essentially, the compiler figures out Y from the type of the parameter passed in, and you specified X in your declaration. Just another difference between Java and C++.</p>\n", "OwnerUserId": "364015", "PostTypeId": "2", "Id": "4894898", "Score": "1", "CreationDate": "2011-02-04T05:35:25.457", "LastActivityDate": "2011-02-04T05:35:25.457"}, "4894884": {"ParentId": "4894854", "CommentCount": "2", "Body": "<p>14.7.1 Paragraph 2:</p>\n<blockquote>\n<p id=\"so_4894854_4894884_0\">Unless a function template specialization has been explicitly instantiated or explicitly specialized, the function template specialization is implicitly instantiated when the specialization is referenced in a context that requires a function definition to exist.</p>\n</blockquote>\n<p>As Jeremiah points out, argument deduction is what you're <em>really</em> asking about:</p>\n<p>14.8.2:</p>\n<blockquote>\n<p id=\"so_4894854_4894884_1\">When a template function specialization is referenced, all of the template arguments must have values. The values can be either explicitly specified or, in some cases, deduced from the use. ...</p>\n</blockquote>\n<p>The process is described in detail there.</p>\n<p>Source: ISO/IEC 14882:1998(E)</p>\n", "OwnerUserId": "99032", "PostTypeId": "2", "Id": "4894884", "Score": "3", "CreationDate": "2011-02-04T05:32:18.880", "LastActivityDate": "2011-02-04T05:32:18.880"}, "4894854": {"CommentCount": "0", "ViewCount": "85", "CreationDate": "2011-02-04T05:27:37.720", "LastActivityDate": "2011-02-04T05:35:25.457", "Title": "A question regarding C++ template", "AcceptedAnswerId": "4894877", "PostTypeId": "1", "Id": "4894854", "Score": "3", "Body": "<p>Suppose the following template definition (the code is meaningless):</p>\n<pre><code>template&lt;class X, class Y&gt;\nbool FooBar(const Y&amp; val) { return sizeof(X) + 4; }\n</code></pre>\n<p>I have found that following calling code was legal:</p>\n<pre><code>float temp = 0.f;\nFooBar&lt;int&gt;(temp);\n</code></pre>\n<p>As you can see, the second type parameter <code>Y</code> can be omitted. A compiler infers the type of <code>Y</code> by looking the argument type of <code>temp</code>.</p>\n<p>What rule or specification of C++ template allows this? I was pretty surprised to see it.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "202699", "AnswerCount": "4"}, "4894879": {"ParentId": "4894854", "CommentCount": "1", "Body": "<p>This is called 'implicit template instantiation'. See the standard, section 14.7.1. I would note that this is very commonly used for function templates.</p>\n", "OwnerUserId": "540026", "PostTypeId": "2", "Id": "4894879", "Score": "1", "CreationDate": "2011-02-04T05:31:44.257", "LastActivityDate": "2011-02-04T05:31:44.257"}, "bq_ids": {"n4140": {"so_4894854_4894884_1": {"section_id": 293, "quality": 0.8095238095238095, "length": 17}, "so_4894854_4894884_0": {"section_id": 235, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_4894854_4894884_1": {"section_id": 284, "quality": 0.8095238095238095, "length": 17}, "so_4894854_4894884_0": {"section_id": 228, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_4894854_4894884_1": {"section_id": 300, "quality": 0.8095238095238095, "length": 17}, "so_4894854_4894884_0": {"section_id": 245, "quality": 0.9545454545454546, "length": 21}}}, "4894877": {"ParentId": "4894854", "CommentCount": "0", "Body": "<p>That is template argument deduction; it is the same as if you used <code>X</code> as the type of a value parameter of <code>FooBar</code> and called it without any template arguments at all.  There is a document with more details at <a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/topic/com.ibm.xlcpp8a.doc/language/ref/template_argument_deduction.htm\" rel=\"nofollow\">IBM's compiler site</a>.</p>\n", "OwnerUserId": "319906", "PostTypeId": "2", "Id": "4894877", "Score": "5", "CreationDate": "2011-02-04T05:31:41.530", "LastActivityDate": "2011-02-04T05:31:41.530"}});