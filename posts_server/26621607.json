post_cb({"26621754": {"ParentId": "26621607", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The operators you can replace are as follows</p>\n<p>[replacement.functions]</p>\n<pre><code>(2.1) \u2014 operator new(std::size_t)\n(2.2) \u2014 operator new(std::size_t, const std::nothrow_t&amp;)\n(2.3) \u2014 operator new[](std::size_t)\n(2.4) \u2014 operator new[](std::size_t, const std::nothrow_t&amp;)\n(2.5) \u2014 operator delete(void*)\n(2.6) \u2014 operator delete(void*, const std::nothrow_t&amp;)\n</code></pre>\n<p><code>void *operator new(size_t s) throw()</code> is invalid, it <strong>has</strong> to throw in case of error</p>\n<p>[new.delete.single]</p>\n<pre><code>void* operator new(std::size_t size);\n</code></pre>\n<blockquote>\n<p id=\"so_26621607_26621754_0\">3 Required behavior: Return a <strong>non-null</strong> pointer to suitably aligned\n  storage (3.7.4), or else throw a <code>bad_alloc</code> exception. <strong>This requirement\n  is binding on a replacement version of this function</strong>.</p>\n</blockquote>\n<p>You can however safely replace the non-throwing <code>noexcept</code> overloads with a function that always returns null, as whoever calls these overloads must be aware of this behavior and check the return value accordingly. Obviously they won't be called unless the nothrow tag is passed, i.e. <code>int* i = new (std::nothrow) int;</code></p>\n<pre><code>void* operator new(std::size_t size, const std::nothrow_t&amp;) noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_26621607_26621754_1\">7 Required behavior: Return a non-null pointer to suitably aligned\n  storage (3.7.4), or else return a null pointer. This nothrow version\n  of <code>operator new</code> returns a pointer obtained as if acquired from the\n  (possibly replaced) ordinary version. This requirement is binding on a\n  replacement version of this function.</p>\n</blockquote>\n", "OwnerUserId": "657267", "LastEditorUserId": "657267", "LastEditDate": "2014-10-29T02:30:34.990", "Id": "26621754", "Score": "1", "CreationDate": "2014-10-29T02:16:25.093", "LastActivityDate": "2014-10-29T02:30:34.990"}, "26621607": {"CommentCount": "4", "ViewCount": "588", "CreationDate": "2014-10-29T01:56:28.143", "LastActivityDate": "2014-10-29T02:30:34.990", "Title": "User-defined operator new that returns null pointer", "FavoriteCount": "1", "PostTypeId": "1", "Id": "26621607", "Score": "5", "Body": "<p>I know that quite few C++ FAQs out there (and answers here on SO) say that there's no need to check the return value of a plain new-expression for null, since plain new-expression indicates failures by throwing exceptions. They basically state that plain new-expression never returns null. (By \"plain new-expression\" I mean a new-expression that is not a <code>nothrow</code> one).</p>\n<p>However, despite this looking like a very basic question, I suddenly realized that I don't understand what specific assumptions they make (if any) when they give that answer. </p>\n<p>In particular, I wonder if am I allowed to overload the basic plain form of <code>::operator new</code> to always return null pointer, and therefore expect that all plain new-expressions that use that operator will now return null pointers as well.</p>\n<p>According to the language specification, if my <code>::operator new</code> is declared as non-throwing, then I may/shall indicate memory allocation failure by returning a null pointer. So, let's do just that</p>\n<pre><code>void *operator new(size_t s) throw() {\n  return 0;\n}\n\nint main() {\n  int *i = new int;\n}\n</code></pre>\n<p>In my experiments, the above new-expression does successfully return a null pointer. So, am I breaking any rules in the above code or not? Is it legal to declare a plain <code>::operator new</code> as non-throwing?</p>\n<p>And if the above code is fine, then I'd presume that when someone states that a plain new \"never returns null pointer\", they do that under assumption that the standard-library-provided version of <code>::operator new</code> has not been replaced. Is that presumption correct?</p>\n", "Tags": "<c++><null><new-operator><standards-compliance>", "OwnerUserId": "187690", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26621607_26621754_1": {"section_id": 6818, "quality": 0.84375, "length": 27}, "so_26621607_26621754_0": {"section_id": 6814, "quality": 0.7894736842105263, "length": 15}}, "n3337": {"so_26621607_26621754_1": {"section_id": 6573, "quality": 0.84375, "length": 27}, "so_26621607_26621754_0": {"section_id": 6569, "quality": 0.7894736842105263, "length": 15}}, "n4659": {"so_26621607_26621754_1": {"section_id": 8310, "quality": 0.6875, "length": 22}, "so_26621607_26621754_0": {"section_id": 8306, "quality": 0.6842105263157895, "length": 13}}}});