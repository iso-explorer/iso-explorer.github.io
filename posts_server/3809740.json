post_cb({"3809740": {"CommentCount": "1", "ViewCount": "792", "PostTypeId": "1", "LastEditorUserId": "1530549", "CreationDate": "2010-09-28T04:45:17.193", "LastActivityDate": "2014-11-24T10:08:51.753", "Title": "Behaviour of Delete in C++ on cast", "AcceptedAnswerId": "3809794", "LastEditDate": "2014-11-24T10:08:51.753", "Id": "3809740", "Score": "2", "Body": "<p>I am working on some strange piece of code ,For me its not good piece of code.</p>\n<pre><code>PIP_ADAPTER_INFO pAdapterInfo=(PIP_ADAPTER_INFO)new  \n                               char[sizeof(IP_IP_ADAPTER_INFO)];\n\n.\n.\n.\ndelete []pAdapterInfo;\n</code></pre>\n<p>Here PIP_ADAPTER_INFO is pointer to struct IP_IP_ADAPTER_INFO , size of IP_IP_ADAPTER_INFO is 640.</p>\n<p>I was expecting crash in delete []pAdapterInfo call.But there is no crash.I wrote an small\ntest code.</p>\n<pre><code>        class TestClass\n        {\n\n        public:\n        /*  TestClass()\n            {\n            }\n            ~TestClass()\n            {\n            }*/\n\n        public:\n            int array[10];\n        };\n\n        int main (int ac, char **av)\n\n        {\n            TestClass *myptr=(TestClass*) new char[10];\n            delete []myptr;\n            return 0;\n        }\n</code></pre>\n<p>What i see :</p>\n<ol>\n<li>If i un-comment the c'tor and d'tor, test code crashes (assert fails)</li>\n<li>If i keep it commented nothing fails.</li>\n</ol>\n<p>Even if i see disassemble , it is different in both case above</p>\n<pre><code>/*****************************************************************/\n/********Compiler provided c'tor and d'tor ***********************/\n/*****************************************************************/\n28:       TestClass *myptr=(TestClass*) new char[10];\n00401268   push        0Ah\n0040126A   call        operator new (004082d0)\n0040126F   add         esp,4\n00401272   mov         dword ptr [ebp-8],eax\n00401275   mov         eax,dword ptr [ebp-8]\n00401278   mov         dword ptr [ebp-4],eax\n29:       delete []myptr;\n0040127B   mov         ecx,dword ptr [ebp-4]\n0040127E   mov         dword ptr [ebp-0Ch],ecx\n00401281   mov         edx,dword ptr [ebp-0Ch]\n00401284   push        edx\n00401285   call        operator delete (004060d0)\n0040128A   add         esp,4\n30:\n/*****************************************************************/\n/********User provided c'tor and d'tor ***********************/\n/*****************************************************************/\n28:       TestClass *myptr=(TestClass*) new char[10];\n\n28:       TestClass *myptr=(TestClass*) new char[10];\n00401278   push        0Ah\n0040127A   call        operator new (004083e0)\n0040127F   add         esp,4\n00401282   mov         dword ptr [ebp-8],eax\n00401285   mov         eax,dword ptr [ebp-8]\n00401288   mov         dword ptr [ebp-4],eax\n29:       delete []myptr;\n0040128B   mov         ecx,dword ptr [ebp-4]\n0040128E   mov         dword ptr [ebp-10h],ecx\n00401291   mov         edx,dword ptr [ebp-10h]\n00401294   mov         dword ptr [ebp-0Ch],edx\n00401297   cmp         dword ptr [ebp-0Ch],0\n0040129B   je          main+4Ch (004012ac)\n0040129D   push        3\n0040129F   mov         ecx,dword ptr [ebp-0Ch]\n004012A2   call        @ILT+0(TestClass::`vector deleting destructor') (00401005)\n004012A7   mov         dword ptr [ebp-14h],eax\n004012AA   jmp         main+53h (004012b3)\n004012AC   mov         dword ptr [ebp-14h],0\n</code></pre>\n<p>Please help me with your expertise to learn this feature of C++ .</p>\n<p>Thanks in advance.</p>\n<p>Sat</p>\n", "Tags": "<c++><delete-operator>", "OwnerUserId": "177584", "AnswerCount": "2"}, "3809792": {"ParentId": "3809740", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_3809740_3809792_0\">$5.3.5/3 - \"In the second alternative\n  (delete array) if the dynamic type of\n  the object to be deleted differs from\n  its static type, the behavior is\n  undefined.<sup>73</sup>)\"</p>\n</blockquote>\n<p>So, what you are seeing is infact undefined behavior.</p>\n<p><sub>73)\nThis implies that an object cannot be deleted using a pointer of type void* because there are no objects of type void.</sub></p>\n", "OwnerUserId": "418110", "LastEditorUserId": "165520", "LastEditDate": "2010-09-28T04:59:49.480", "Id": "3809792", "Score": "4", "CreationDate": "2010-09-28T04:57:22.277", "LastActivityDate": "2010-09-28T04:59:49.480"}, "bq_ids": {"n4140": {"so_3809740_3809792_0": {"section_id": 6107, "quality": 0.8, "length": 12}}, "n3337": {"so_3809740_3809792_0": {"section_id": 5873, "quality": 0.8, "length": 12}}, "n4659": {"so_3809740_3809792_0": {"section_id": 7604, "quality": 0.8, "length": 12}}}, "3809794": {"ParentId": "3809740", "CommentCount": "5", "Body": "<p>I'm assuming here that by <code>IP_IP_ADAPTER_INFO</code> you mean Windows' <code>IP_ADAPTER_INFO</code> structure. Even if not, the gist of this is the same: your code is leading to undefined behaviour, and it's the fault of whoever wrote it. <strong>Fix it immediately.</strong></p>\n<p>You allocated an array of <code>char</code> with <code>new</code>, but then free that memory as if it were an array of <code>IP_ADAPTER_INFO</code>. C++ doesn't know that you're lying to it, so it goes and tries to treat your <code>char</code> array as an <code>IP_ADAPTER_INFO</code> array, and then dies horribly when it finds out the awful truth.</p>\n<p>Now, this works <em>sometimes</em> because VC++ records enough info about the allocated memory that <code>delete[]</code> doesn't care about the pointer's type, <strong>but this is evil evil wrong bad illegal <em>get-you-taken-out-back-and-shot</em> code</strong>.</p>\n<p>It may work on your particular compiler, but that's entirely a fluke. You should instead be doing:</p>\n<pre><code>PIP_ADAPTER_INFO pAdapterInfo = new IP_ADAPTER_INFO;\n//DoSomethingToAdapterInfo(pAdapterInfo);\ndelete pAdapterInfo;\n</code></pre>\n<p>But even then, unless you need to hold onto that structure in a global scope, which itself points to bad design, you really shouldn't be using <code>new</code> and <code>delete</code> here at all. You should be doing something closer to this:</p>\n<pre><code>IP_ADAPTER_INFO adapterInfo;\n//DoSomethingToAdapterInfo(&amp;adapterInfo);\n</code></pre>\n<p>Letting C++ handle allocation and deletion (on the stack) for you. If you need to return the structure, return it rather than a pointer to it (so your caller doesn't need to worry about memory management.)</p>\n<p>If there's some obscure or unique reason why you are using heap allocation instead of stack allocation, then you may be justified in doing so--but even then, casting <code>new char[...]</code> to <code>PIP_ADAPTER_INFO</code> is bad.</p>\n", "OwnerUserId": "265530", "PostTypeId": "2", "Id": "3809794", "Score": "12", "CreationDate": "2010-09-28T04:57:49.607", "LastActivityDate": "2010-09-28T04:57:49.607"}});