post_cb({"13104358": {"CommentCount": "0", "AcceptedAnswerId": "13104492", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-10-27T21:29:54.590", "LastActivityDate": "2012-10-27T22:01:00.683", "LastEditDate": "2017-05-23T12:23:06.533", "ViewCount": "543", "FavoriteCount": "1", "Title": "Is a compiler forced to reject invalid constexpr?", "Id": "13104358", "Score": "9", "Body": "<pre><code>#include &lt;exception&gt;\n\nconstexpr bool foo(bool x)\n{\n  return x ? true : throw std::exception();\n}\n\nint main()\n{\n  // 1) must never be compiled\n  // static_assert(foo(false), \"\");\n\n  // 2) must always be compiled?\n  const bool x = foo(false);\n\n  // 3) must never compile?\n  constexpr bool y = foo(false);\n\n  return 0;\n}\n</code></pre>\n<p>I'm sure that (1) must lead to a compile error. I'm quite sure that (2) must not be rejected at compile time, though it will fail at runtime.</p>\n<p>The interesting case is the constexpr variable (3). In this simple example, gcc and clang actually evaluate the expression, and will therefore reject the program. (Error message: y is not a constant expression).</p>\n<p>Is every C++11 compiler forced to reject the program? What if foo(false) was replaced by a more complex expression?</p>\n<p>I was suprised to find out that constexpr were not turing-complete, though it will be after a change in the specification:\n<a href=\"https://stackoverflow.com/questions/9201506/is-constexpr-based-computation-turing-complete\">Is constexpr-based computation Turing complete?</a></p>\n<p>Maybe this is related to my question. As far as I understand, the compiler is allowed to postpone the actual evaluation of the constexpr (3) in this example until runtime. But if constexpr are turing-complete, I find it hard to believe that the compiler can decide for all constexpr whether an exception will be thrown (which means that the constexpr is invalid).</p>\n", "Tags": "<c++><c++11><language-lawyer><constexpr>", "OwnerUserId": "783510", "AnswerCount": "2"}, "13104492": {"ParentId": "13104358", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>By my reading, yes, every compiler must complain about statement (3).</p>\n<p>N3242 7.1.5 paragraph 9:</p>\n<blockquote>\n<p id=\"so_13104358_13104492_0\">A <code>constexpr</code> specifier used in an object declaration declares the object as <code>const</code>.  Such an object shall have literal type and shall be initialized.  If it initialized by a constructor call, that call shall be a constant expression (5.19).  Otherwise, every full-expression that appears in its initializer shall be a constant expression.  Each implicit conversion used in converting the initializer expressions and each constructor call used for the initialization shall be one of those allowed in a constant expression (5.19).</p>\n</blockquote>\n<p>I think of a <code>constexpr</code> object as \"evaluated at compile time\", and a <code>constexpr</code> function or <code>constexpr</code> constructor as \"might be evaluated at compile time\".  A compiler must determine the semantic validity of statements like (3) at compile time.  You could argue that the \"evaluation\" can still be done at run time, but checking for validity does most of that work anyway.  Plus, the code could then continue to instantiate a template like <code>Check&lt;y&gt;</code>, which pretty much guarantees the compiler needs to figure out the value of <code>y</code> at compile-time.</p>\n<p>This does mean you could write a diabolical program to make the compiler take a really long or infinite time.  But I suspect that was already possible with <code>operator-&gt;</code> tricks.</p>\n", "OwnerUserId": "459640", "LastEditorUserId": "459640", "LastEditDate": "2012-10-27T22:01:00.683", "Id": "13104492", "Score": "8", "CreationDate": "2012-10-27T21:49:55.503", "LastActivityDate": "2012-10-27T22:01:00.683"}, "13104505": {"ParentId": "13104358", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_13104358_13104505_0\">I'm sure that (1) must lead to a compile error. I'm quite sure that (2) must not be rejected at compile time, though it will fail at runtime.</p>\n</blockquote>\n<p>Correct. The <code>throw</code> part of the conditional operator is not a constant expression, and in (1), it's not unevaluated. For (2), <code>foo</code> is not forced to be evaluated at compile-time.</p>\n<p>For (3), how would the compiler be allowed to post-pone evaluation? The <code>constexpr</code> decl-specifier <em>forces</em> <code>foo</code> to be evaluated at compile-time. It's basically the same as (1), initialization of <code>y</code> is a context where a constant expression is <em>required</em>.</p>\n<p><code>\u00a77.1.6 [dcl.constexpr] p9</code></p>\n<blockquote>\n<p id=\"so_13104358_13104505_1\">A <code>constexpr</code> specifier used in an object declaration declares the object as <code>const</code>. Such an object shall have literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant expression (5.19). <strong>Otherwise</strong>, or if a <code>constexpr</code> specifier is used in a reference declaration, <strong>every full-expression that appears in its initializer shall be a constant expression.</strong> [...]</p>\n</blockquote>\n", "OwnerUserId": "500104", "PostTypeId": "2", "Id": "13104505", "Score": "5", "CreationDate": "2012-10-27T21:51:54.910", "LastActivityDate": "2012-10-27T21:51:54.910"}, "bq_ids": {"n4140": {"so_13104358_13104492_0": {"section_id": 5425, "quality": 0.8409090909090909, "length": 37}, "so_13104358_13104505_1": {"section_id": 5425, "quality": 0.96875, "length": 31}}, "n3337": {"so_13104358_13104492_0": {"section_id": 5220, "quality": 0.9545454545454546, "length": 42}, "so_13104358_13104505_1": {"section_id": 5220, "quality": 0.96875, "length": 31}}, "n4659": {"so_13104358_13104505_1": {"section_id": 6847, "quality": 0.5625, "length": 18}}}});