post_cb({"bq_ids": {"n4140": {"so_47775439_47775496_0": {"length": 12, "quality": 0.5714285714285714, "section_id": 599}}, "n3337": {"so_47775439_47775496_0": {"length": 12, "quality": 0.5714285714285714, "section_id": 589}}, "n4659": {"so_47775439_47775496_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 622}}}, "47775439": {"ViewCount": "87", "Body": "<pre><code>#include &lt;vector&gt;\n\nusing std::size_t;\n\nstruct Foo\n{\n    Foo(size_t i, char c) {}\n};\n\nFoo Bar1()\n{\n    size_t i = 0;\n    char c = 'x';\n    return { i, c }; // good\n}\n\nstd::vector&lt;char&gt; Bar2()\n{\n    size_t i = 0;\n    char c = 'x';\n    return { i, c }; // bad\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/87uD1ikpMkThPTaw\" rel=\"nofollow noreferrer\">https://wandbox.org/permlink/87uD1ikpMkThPTaw</a></p>\n<blockquote>\n<p id=\"so_47775439_47775439_0\">warning: narrowing conversion of 'i' from 'std::size_t {aka long\n  unsigned int}' to 'char' inside { }</p>\n</blockquote>\n<p>Obviously it tries to use the initializer_list of vector. But why doesn't it use the better match <code>vector&lt;char&gt;(size_t, char)</code> ?</p>\n<p>Can i use the desired constructor in a return statement without writing the type again?</p>\n", "AcceptedAnswerId": "47775496", "Title": "Curly braces constructor prefers initializer_list over better match. Why?", "CreationDate": "2017-12-12T14:50:49.377", "LastActivityDate": "2017-12-12T15:08:37.237", "CommentCount": "2", "LastEditDate": "2017-12-12T15:00:03.470", "PostTypeId": "1", "LastEditorUserId": "1000551", "Id": "47775439", "Score": "1", "OwnerUserId": "7384437", "Tags": "<c++><constructor>", "AnswerCount": "1"}, "47775496": {"Id": "47775496", "PostTypeId": "2", "Body": "<p>Because initializer_list constructors, if at all possible, take precedence over other constructors. This is to make edge cases less confusing - specifically, this particular vector constructor that you expect it to use was deemed too easily selected by accident.</p>\n<p>Specifically, the standard says in 16.3.1.7 \"Initialization by list-initialization\" [over.match.list] (latest draft, N4687):</p>\n<blockquote>\n<p id=\"so_47775439_47775496_0\">(1) When objects of non-aggregate class type T are list-initialized such that 11.6.4 specifies that overload resolution is performed according to the rules in this section, overload resolution selects the constructor in two phases:</p>\n<ul>\n<li>Initially, the candidate functions are the initializer-list constructors (11.6.4) of the class T and the argument list consists of the initializer list as a single argument.</li>\n<li>If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class T and the argument list consists of the elements of the initializer list.</li>\n</ul>\n</blockquote>\n<p>So if you do <code>std::vector&lt;char&gt;( i, c )</code>, this section does not apply at all, since it isn't list-initialization. Normal overload resolution is applied, the <code>(size_t, char)</code> constructor is found, and used.</p>\n<p>But if you do <code>std::vector&lt;char&gt;{ i, c }</code>, this is list-initialization. The initializer list constructors are tried first, and the <code>(initializer_list&lt;char&gt;)</code> constructor is a match (even though it involves the narrowing conversion from <code>size_t</code> to <code>char</code>), so it is used before the size+value constructor is ever considered.</p>\n<p>So to answer the edited-in question: no, you can't create the vector without naming its type. But in C++17 you can use class template argument deduction and simply write <code>return std::vector(i, c);</code></p>\n", "LastEditorUserId": "8922", "LastActivityDate": "2017-12-12T15:08:37.237", "Score": "4", "CreationDate": "2017-12-12T14:53:29.543", "ParentId": "47775439", "CommentCount": "4", "OwnerUserId": "8922", "LastEditDate": "2017-12-12T15:08:37.237"}});