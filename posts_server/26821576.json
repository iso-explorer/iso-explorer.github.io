post_cb({"bq_ids": {"n4140": {"so_26821576_26821655_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 5882}, "so_26821576_26821653_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 6259}, "so_26821576_26821655_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 6310}}, "n3337": {"so_26821576_26821655_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 5653}, "so_26821576_26821655_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 6067}, "so_26821576_26821653_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 6019}}, "n4659": {"so_26821576_26821655_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 701}, "so_26821576_26821655_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 7820}, "so_26821576_26821653_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 7763}}}, "26821655": {"Id": "26821655", "PostTypeId": "2", "Body": "<p>You are defining a function that is already declared in <code>&lt;math.h&gt;</code> with external linkage. </p>\n<p>C11 standard, \u00a77.12.6.7:</p>\n<blockquote id=\"so_26821576_26821655_0\">\n<pre><code>#include &lt;math.h&gt;\ndouble log(double x);\n</code></pre>\n</blockquote>\n<p>\u00a77.1.2:</p>\n<blockquote>\n<p id=\"so_26821576_26821655_1\">Any declaration of a library function shall have external linkage.</p>\n</blockquote>\n<p>[extern.names]/3:</p>\n<blockquote>\n<p id=\"so_26821576_26821655_2\">Each name from the Standard C library declared with external linkage\n  is reserved to the implementation for use as a name with extern \"C\"\n  linkage, both in namespace <code>std</code> and in the global namespace.</p>\n</blockquote>\n<p>According to [reserved.names]/2 the behavior is undefined; The implementation can thus do what it wants, including the issuance of nonsensical error messages.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-08T20:36:53.103", "Score": "5", "CreationDate": "2014-11-08T20:19:46.767", "ParentId": "26821576", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2014-11-08T20:36:53.103"}, "26821653": {"Id": "26821653", "PostTypeId": "2", "Body": "<p>So according to the standard (17.6.1.2.4):</p>\n<blockquote>\n<p id=\"so_26821576_26821653_0\">In the C++ standard library, however, the declarations (except for names which are defined as macros in C) are within namespace scope (3.3.6) of the namespace std. It is unspecified whether these names are first declared within the global namespace scope and are then injected into namespace std by explicit using-declarations (7.3.3).</p>\n</blockquote>\n<p>It's unspecified whether or not the <code>log()</code> in <code>math.h</code> (really <code>cmath</code>) is in namespace <code>std</code> or not. If it is (like it is for libstdc++ for gcc), then calling <code>log(1)</code> quite simply calls your function because the other one is named <code>std::log()</code>. But for clang, apparently it puts it in the global namespace. Since there is a </p>\n<p><code>template &lt;typename T&gt; double log(T x);</code></p>\n<p>That will be preferred to yours since you're passing an int, so on clang it will call that one. (I can't check this right now since I can't access coliru and don't have clang installed, but this is a best guess).</p>\n", "LastActivityDate": "2014-11-08T20:19:32.153", "CommentCount": "5", "CreationDate": "2014-11-08T20:19:32.153", "ParentId": "26821576", "Score": "2", "OwnerUserId": "2069064"}, "26821576": {"ViewCount": "257", "Body": "<p>Consider following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;math.h&gt;\n\ndouble log(double) { return 42; }\n\nint main() {\n    std::cout &lt;&lt; log(1) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>While build debug version all used compilers (msvc,gcc,clang) prints <code>42</code>.</p>\n<p>But when i try build (and run) in release mode i got:</p>\n<ul>\n<li>compilation error in msvc: <code>error C2169: 'log' : intrinsic function, cannot be defined</code>;</li>\n<li>prints <code>42</code> for gcc;</li>\n<li>prints <code>0</code> for clang.</li>\n</ul>\n<p>Why release/debug results are different for same compiler? </p>\n<p>Why got different results for different compilers in release mode?</p>\n", "AcceptedAnswerId": "26821655", "Title": "Overload built-in (intrinsic?) function", "CreationDate": "2014-11-08T20:11:05.703", "Id": "26821576", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-11-08T20:36:53.103", "Score": "4", "OwnerUserId": "3240681", "Tags": "<c++><visual-c++><gcc><clang><built-in>", "AnswerCount": "2"}});