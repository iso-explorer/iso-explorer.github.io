post_cb({"bq_ids": {"n4140": {"so_39309908_39309980_4": {"length": 44, "quality": 0.9777777777777777, "section_id": 5561}, "so_39309908_39309980_1": {"length": 16, "quality": 1.0, "section_id": 5560}, "so_39309908_39309980_2": {"length": 44, "quality": 0.9777777777777777, "section_id": 5561}, "so_39309908_39309980_3": {"length": 16, "quality": 1.0, "section_id": 5560}}, "n3337": {"so_39309908_39309980_4": {"length": 44, "quality": 0.9777777777777777, "section_id": 5343}, "so_39309908_39309980_1": {"length": 16, "quality": 1.0, "section_id": 5342}, "so_39309908_39309980_2": {"length": 44, "quality": 0.9777777777777777, "section_id": 5343}, "so_39309908_39309980_3": {"length": 16, "quality": 1.0, "section_id": 5342}}, "n4659": {"so_39309908_39309980_4": {"length": 44, "quality": 0.9777777777777777, "section_id": 7008}, "so_39309908_39309980_1": {"length": 16, "quality": 1.0, "section_id": 7007}, "so_39309908_39309980_2": {"length": 44, "quality": 0.9777777777777777, "section_id": 7008}, "so_39309908_39309980_3": {"length": 16, "quality": 1.0, "section_id": 7007}}}, "39309980": {"Id": "39309980", "PostTypeId": "2", "Body": "<p>The text you're looking for is in the iterators section (emphasis mine):</p>\n<blockquote>\n<p id=\"so_39309908_39309980_0\">[iterator.requirements.general]/7-8</p>\n<blockquote>\n<p id=\"so_39309908_39309980_3\">An iterator j is called reachable from an iterator i if and only if there is a finite sequence of applications of\n    the expression ++i that makes i == j. If j is reachable from i, they refer to elements of the same sequence.</p>\n<p id=\"so_39309908_39309980_4\">Most of the library\u2019s algorithmic templates that operate on data structures have interfaces that use ranges.\n    A range is a pair of iterators that designate the beginning and end of the computation. A range [i,i) is an\n    empty range; <strong>in general, a range [i,j) refers to the elements in the data structure starting with the element\n    pointed to by i and up to but not including the element pointed to by j. Range [i,j) is valid if and only if\n    j is reachable from i. The result of the application of functions in the library to invalid ranges is undefined.</strong></p>\n</blockquote>\n</blockquote>\n<p>The standard explicitly says here that passing an invalid (not fulfilled) range to standard algorithms results in undefined behaviour. The algorithms themselves do specify ranges in the <code>[first, last)</code> format.</p>\n<p>Note that /7 disallows swapping the arguments for random access iterators because you cannot apply <code>++first</code> over and over to reach <code>last</code>.</p>\n", "LastEditorUserId": "962089", "LastActivityDate": "2016-09-03T18:18:34.843", "Score": "5", "CreationDate": "2016-09-03T18:11:58.013", "ParentId": "39309908", "CommentCount": "1", "OwnerUserId": "962089", "LastEditDate": "2016-09-03T18:18:34.843"}, "39309908": {"ViewCount": "67", "Body": "<p>What does the official C++ standard says about the algorithms when the condition <code>first &lt;= last</code> is not fullfilled, <code>first</code> and <code>last</code> being the iterators passed to one of the standard algorithms?</p>\n<p>I see three possibities:</p>\n<ul>\n<li>The algorithms are required to check the condition so that if it not fullfilled, the algorithm do not do anything</li>\n<li>The algorithms are required to throw an exception</li>\n<li>This is undefined behaviour, so... anything can happen</li>\n</ul>\n<p>I am puzzled, because in the algorithms description I don't see a <code>requires</code> clause concerning <code>first</code> and <code>last</code>.</p>\n<p>EDIT1: This was a simplification of the question. A more exact version is \"what happen to the algorithms when <code>last</code> is not reachable from <code>first</code> by successively applying <code>operator++</code>?</p>\n<p>EDIT2: I am asking this question because I am implementing an specialization of <code>std::reverse</code> and I was wondering whether I should check this condition, or if I can allow the function to do something completely wrong when <code>last</code> is not reachable from <code>first</code>?</p>\n", "AcceptedAnswerId": "39309980", "Title": "What does the C++ standard says for algorithms when first <= last is not fullfilled?", "CreationDate": "2016-09-03T18:04:40.127", "Id": "39309908", "CommentCount": "4", "LastEditDate": "2016-09-03T18:17:09.613", "PostTypeId": "1", "LastEditorUserId": "882932", "LastActivityDate": "2016-09-03T18:18:34.843", "Score": "2", "OwnerUserId": "882932", "Tags": "<c++><algorithm><language-lawyer><undefined-behavior><c++-standard-library>", "AnswerCount": "1"}});