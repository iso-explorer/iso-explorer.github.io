post_cb({"bq_ids": {"n4140": {"so_42226148_42226605_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 4290}}, "n3337": {"so_42226148_42226605_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 4131}}, "n4659": {"so_42226148_42226605_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 5548}}}, "42226605": {"Id": "42226605", "PostTypeId": "2", "Body": "<p>Here's what the standard says about the deleter of <code>unique_ptr</code> (<strong>[unique.ptr.single]/1</strong>):</p>\n<blockquote>\n<p id=\"so_42226148_42226605_0\">A client-supplied template argument\n  D\n  shall be a function object type (20.9), lvalue-reference to function, or lvalue-reference to function object type\n  for which, given a value\n  d\n  of type\n  D\n  and a value\n  ptr\n  of type\n  unique_ptr::pointer\n  , the expression\n  d(ptr)\n  is valid and has the effect of disposing of the pointer as appropriate for that deleter.</p>\n</blockquote>\n<p>Judging by the above, both <code>[]</code> and <code>[&amp;]</code> are perfectly valid.</p>\n", "LastActivityDate": "2017-02-14T12:47:02.120", "CommentCount": "3", "CreationDate": "2017-02-14T12:47:02.120", "ParentId": "42226148", "Score": "4", "OwnerUserId": "1490355"}, "42226148": {"ViewCount": "125", "Body": "<h2>Background</h2>\n<p>Cppreference:s <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\" rel=\"nofollow noreferrer\">section on <code>std::unique_ptr</code></a> shows the following demo for supplying a custom deleter to the <code>unique_ptr</code> instance:</p>\n<blockquote id=\"so_42226148_42226148_0\">\n<pre><code>std::unique_ptr&lt;D, std::function&lt;void(D*)&gt;&gt; p(new D, [&amp;](D* ptr)\n{\n    std::cout &lt;&lt; \"destroying from a custom deleter...\\n\";\n    delete ptr;\n});\n</code></pre>\n</blockquote>\n<p>Where <code>D</code>, for the purpose of this question, is just as simple custom type, say</p>\n<pre><code>struct D\n{\n    D() { std::cout &lt;&lt; \"D CTOR\\n\"; }\n    ~D() { std::cout &lt;&lt; \"D DTOR\\n\"; }\n};\n</code></pre>\n<p>Moreover, the reference above states the following type requirement on the deleter:</p>\n<blockquote>\n<p id=\"so_42226148_42226148_1\"><strong>Type requirements</strong></p>\n<p id=\"so_42226148_42226148_2\"><code>Deleter</code> must be <code>FunctionObject</code> or lvalue reference to a\n  <code>FunctionObject</code> or lvalue reference to function, callable with an\n  argument of type <code>unique_ptr&lt;T, Deleter&gt;::pointer</code></p>\n<p id=\"so_42226148_42226148_3\">...</p>\n<p id=\"so_42226148_42226148_4\"><strong>Member types</strong></p>\n<p id=\"so_42226148_42226148_5\"><code>pointer</code>: <code>std::remove_reference&lt;Deleter&gt;::type::pointer</code> if that type exists, otherwise <code>T*</code>. Must satisfy <code>NullablePointer</code>.</p>\n</blockquote>\n<p>As a capture list of the deleter lambda in the example above, <code>[&amp;]</code> is used. Based on Cppreference:s <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow noreferrer\">section on lambdas</a>, as I see it, the only effect of this capture list in the deleter example above would be to capture the <em>\"current object by reference\"</em> [emphasis mine]:</p>\n<blockquote>\n<p id=\"so_42226148_42226148_6\"><code>[&amp;]</code> captures all automatic variables odr-used in the body of the\n  lambda by reference and <strong>current object by reference if exists</strong>.</p>\n</blockquote>\n<p>But as I understand it from above, the supplied lambda will be simply called with the object's <code>unique_ptr&lt;T, Deleter&gt;::pointer</code>, no matter if we choose <code>[&amp;]</code> or <code>[]</code> as capture list to the lambda. I don't understand myself why we'd want to use by-reference capture (of the <em>object</em>, which is the <code>unique_ptr</code> instance here?) default here, but I'm pretty sure I'm missing something essential (hence the question).</p>\n<h2>Question</h2>\n<ul>\n<li>Is there any particular reason to use by-reference capture default (<code>[&amp;]</code>) in the deleter lambda in the example above, as compared to simply using no-capturing (<code>[]</code>)?</li>\n</ul>\n", "AcceptedAnswerId": "42226605", "Title": "Simple custom deleter lambda supplied to std::unique_ptr: why use by-reference capture default ([&]) over no-capture ([])?", "CreationDate": "2017-02-14T12:25:59.153", "Id": "42226148", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-02-14T12:47:02.120", "Score": "3", "OwnerUserId": "4573247", "Tags": "<c++><lambda>", "AnswerCount": "1"}});