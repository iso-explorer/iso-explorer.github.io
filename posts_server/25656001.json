post_cb({"bq_ids": {"n4140": {"so_25656001_25697507_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 241}}, "n3337": {"so_25656001_25697507_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 233}}, "n4659": {"so_25656001_25697507_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 55}}}, "25656001": {"ViewCount": "229", "Body": "<p>I'd like to do this:</p>\n<pre><code>template &lt;typename T&gt;\nclass S\n{\n    ...\n    class A\n    {\n        ~A(){cout &lt;&lt; \"~A\";}\n    };\n    static A obj;\n};\n\ntemplate &lt;typename T&gt;\ntypename S&lt;T&gt;::A S&lt;T&gt;::obj;\n\nint main()\n{...}\n</code></pre>\n<p>But when the program starts, no static instance of the nested class A is created. \"~A\" is not printed then. What is the problem? </p>\n", "AcceptedAnswerId": "25698057", "Title": "The initialization of a static instance of a nested class in template class", "CreationDate": "2014-09-04T01:27:27.420", "Id": "25656001", "CommentCount": "0", "LastEditDate": "2014-09-06T06:25:22.790", "PostTypeId": "1", "LastEditorUserId": "315052", "LastActivityDate": "2014-09-08T14:36:42.077", "Score": "0", "OwnerUserId": "3471994", "Tags": "<c++><templates><static><initialization><nested>", "AnswerCount": "2"}, "25697507": {"Id": "25697507", "PostTypeId": "2", "Body": "<h1>The static object in the template was not used</h1>\n<p>When you implicitly instantiate a template class, only the parts of the class that are used get instantiated. The standard makes a point to mention static data members in C++.11 \u00a714.7.1\u00b68:</p>\n<blockquote>\n<p id=\"so_25656001_25697507_0\">The implicit instantiation of a class template does not cause any static data members of that class to be implicitly instantiated.</p>\n</blockquote>\n<h1>Solution</h1>\n<p>Your will need non-template code that refers to the static object in some way, or you will need to explicitly instantiate the template.</p>\n<h3>Refer to the static object</h3>\n<p>Since <code>obj</code> is static and private to <code>S</code>, you need some public code in <code>S</code> that refers to this object. For example, a static method that returns it.</p>\n<pre><code>tempalte &lt;typename T&gt;\nclass S\n{\n    //... define class A\n    static A obj;\npublic:\n    static A &amp; get_obj () { return obj; }\n};\n\ntemplate &lt;typename T&gt;\ntypename S&lt;T&gt;::A S&lt;T&gt;::obj;\n</code></pre>\n<p>Then, you can call this method from <code>main()</code> to implicitly instantiate <code>obj</code>.</p>\n<pre><code>int main()\n{\n    get_obj();\n}\n</code></pre>\n<h3>Explicitly instantiate the template</h3>\n<p>Explicit instantiation of a template class will fully define it as if the template class had been written as a regular class. So, the static object will be created without need to refer to it implicitly.</p>\n<pre><code>template class S&lt;int&gt;;\n</code></pre>\n<h1>Regarding the Singleton Pattern</h1>\n<h3>Implicit instantiation behavior reduces bloat</h3>\n<p>If you are using your code of a singleton, then the behavior you observed is actually what you want. You only want your singleton objects created if they are actually used. This will prevent unused code from unnecessarily occupying resources in your program.</p>\n<h3>Prevent bloat for explicit instantiation</h3>\n<p>Since it is desirable to prevent run-time bloat of the program, then it is also desirable to do so even if the Singleton is explicitly instantiated. This is naturally accomplished by scoping the singleton instance inside the method that returns it.</p>\n<pre><code>template &lt;typename T&gt;\nclass S\n{\n    class A\n    {\n        friend S;\n        ~A(){std::cout &lt;&lt; \"~A\\n\";}\n        static A &amp; getInstance () {\n            static A obj;\n            return obj;\n        }\n    };\npublic:\n    void foo () { A::getInstance(); }\n};\n</code></pre>\n<p>When the static instance is scoped within the static method that returns it, there is no need to create a template definition of it outside of the class. The static instance only gets created at the moment <code>getInstance()</code> is called.</p>\n", "LastEditorUserId": "315052", "LastActivityDate": "2014-09-06T13:32:02.767", "Score": "0", "CreationDate": "2014-09-06T06:25:03.740", "ParentId": "25656001", "CommentCount": "4", "LastEditDate": "2014-09-06T13:32:02.767", "OwnerUserId": "315052"}, "25698057": {"Id": "25698057", "PostTypeId": "2", "Body": "<p>The answer depends on what is written in the '...' parts of your question.  Here is a complete example that works using gcc 4.8.1; i.e. prints \"Ahello~A\"\nIf you comment out the code in <code>main()</code> the program produces nothing.  </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\ntemplate &lt;typename T&gt;\nclass S\n{\npublic:\n    T m;\n    class A\n    {\n    public:\n        A() {cout &lt;&lt; \"A\";}\n        void say() {cout &lt;&lt; \"hello\";}\n        ~A(){cout &lt;&lt; \"~A\";}\n    };\n    static A obj;\n};\n\ntemplate &lt;typename T&gt;\ntypename S&lt;T&gt;::A S&lt;T&gt;::obj;\n\nint main() {\n    S&lt;int&gt;::obj.say();\n}\n</code></pre>\n<p>If you do not use the static in your code, but you still want your static instance to be created, the answer given by jxh applies. In this (unlikely) case, you will have to explicitly instantiate the template class:\n<code>template class S&lt;int&gt;;</code> </p>\n", "LastEditorUserId": "108403", "LastActivityDate": "2014-09-06T07:59:45.977", "Score": "0", "CreationDate": "2014-09-06T07:41:09.213", "ParentId": "25656001", "CommentCount": "1", "LastEditDate": "2014-09-06T07:59:45.977", "OwnerUserId": "108403"}});