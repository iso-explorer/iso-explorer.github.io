post_cb({"22182432": {"CommentCount": "12", "ViewCount": "857", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-03-04T20:34:04.893", "LastActivityDate": "2015-01-13T14:48:35.733", "Title": "Is gcc considering builtins of non-constant expression functions to be constant expressions", "FavoriteCount": "4", "LastEditDate": "2017-05-23T12:16:55.167", "Id": "22182432", "Score": "11", "Body": "<p><b>Please see the update for a better sample of the problem. The original code has a mix of issues which muddies the picture</b>:</p>\n<p>This question <a href=\"https://stackoverflow.com/questions/22176777/why-can-i-call-a-non-constexpr-function-inside-a-constexpr-function\">Why can I call a non-constexpr function inside a constexpr function?</a> presented the following code</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nconstexpr int f()\n{\n    return printf(\"a side effect!\\n\");\n}\n\nint main()\n{\n    char a[f()];\n    printf(\"%zd\\n\", sizeof a);\n}\n</code></pre>\n<p>Which as I answer is <em>ill-formed</em> but <code>gcc 4.8.2</code> allows it (<em><a href=\"http://coliru.stacked-crooked.com/a/2601b0c1b3abeb55\" rel=\"nofollow noreferrer\">see it live</a></em>).</p>\n<p>But, if we use the <code>-fno-builtin</code> flag <code>gcc</code> generates an error (<em><a href=\"http://coliru.stacked-crooked.com/a/01f14304763bac04\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>error: call to non-constexpr function 'int printf(const char*, ...)'\n     return printf(\"a side effect!\\n\");\n                                     ^\n</code></pre>\n<p>so it <code>seems</code> that <code>gcc</code> is considering its builtin version of <code>printf</code> to be a constant expression. <code>gcc</code> <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\" rel=\"nofollow noreferrer\">documents builtins here</a> but does not document this case where a builtin of a non-constexpr function can be considered a constant expression.</p>\n<p>If this is indeed the case:</p>\n<ul>\n<li>Is a compiler allowed to to do this?</li>\n<li>If they are allowed, don't they have to document it to be conformant?</li>\n<li>Can this be considered an extension, if so, it seems like this would require a warning as the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">C++ draft standard</a> section <code>1.4</code> <em>Implementation compliance</em> paragraph <em>8</em> says (<em>emphasis mine</em>):</li>\n</ul>\n<blockquote>\n<p id=\"so_22182432_22182432_0\">A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any well-formed program. <strong>Implementations are required to diagnose programs that use such extensions that are ill-formed according to this International Standard</strong>. Having done so, however, they can compile and execute such programs.</p>\n</blockquote>\n<p><b>Update</b></p>\n<p>As Casey points out there are a few things going on in the original problem that makes it a poor example. A simple example would be using <a href=\"http://en.cppreference.com/w/cpp/numeric/math/pow\" rel=\"nofollow noreferrer\">std::pow</a> which is not a constexpr function:</p>\n<pre><code>#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n\nconstexpr double f()\n{\n    return std::pow( 2.0, 2.0 ) ;\n}\n\nint main()\n{\n    constexpr double x = f() ;\n\n    printf( \"%f\\n\", x ) ;\n}\n</code></pre>\n<p>Compiles and builds with no warnings or error (<em><a href=\"http://coliru.stacked-crooked.com/a/6573dfe268851616\" rel=\"nofollow noreferrer\">see it live</a></em>) but adding <code>-fno-builtin</code> makes it generates an error (<em><a href=\"http://coliru.stacked-crooked.com/a/131dd080cc4312b8\" rel=\"nofollow noreferrer\">see it live</a></em>). Note: <a href=\"https://stackoverflow.com/questions/17347935/constexpr-math-functions\">why math functions are not constexpr in C++11</a>:</p>\n<pre><code>error: call to non-constexpr function 'double pow(double, double)'\n     return std::pow( 2.0, 2.0 ) ;\n                               ^\n</code></pre>\n", "Tags": "<c++><gcc><c++11><language-lawyer><constant-expression>", "OwnerUserId": "1708801", "AnswerCount": "2"}, "27906899": {"ParentId": "22182432", "LastEditDate": "2017-05-23T11:45:35.777", "CommentCount": "1", "CreationDate": "2015-01-12T16:51:17.693", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "27906899", "Score": "6", "Body": "<p>Yes, <code>gcc</code> is considering some <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\" rel=\"nofollow noreferrer\">builtin functions</a> as <em>constexpr</em> even if the standard does not explicitly mark them as such. We can find the discussion that pertains specifically to the math function found in <code>cmath</code> in the <code>gcc</code> bug report <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=49813\" rel=\"nofollow noreferrer\">[C++0x] sinh vs asinh vs constexpr</a> which says:</p>\n<blockquote>\n<p id=\"so_22182432_27906899_0\">LWG 2013 does seem to allow GCC to treat these functions as constexpr.\n  So, fixed for 4.7</p>\n</blockquote>\n<p>which is referring to <a href=\"http://lwg.github.io/issues/lwg-active.html#2013\" rel=\"nofollow noreferrer\">LWG issue 2013</a> whose original proposed resolution was to add the following to section <code>17.6.5.6</code> <em>[constexpr.functions]</em> (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_22182432_27906899_1\">[...]Additionally, an implementation <strong>may declare</strong> any function to be\n  constexpr if that function's definition satisfies the necessary\n  constraints[...]</p>\n</blockquote>\n<p>but after C++11 the resolution was reversed and the final resolution ended up as:</p>\n<blockquote>\n<p id=\"so_22182432_27906899_2\">[...]An implementation <strong>shall not declare</strong> any standard library function\n  signature as constexpr except for those where it is explicitly\n  required.[..]</p>\n</blockquote>\n<p>So this is currently(<em>in C++14</em>) <a href=\"https://stackoverflow.com/q/27744079/1708801\">a explicitly non-conforming extension</a> and as far as I can tell this was non-conforming in C++11 since it alters observable behavior and therefore would not be allowed via the <em>as-if rule</em>.</p>\n<p>Jonathan Wakely points out a <code>libstdc++</code> mailing list discussion: <a href=\"https://gcc.gnu.org/ml/libstdc++/2014-09/msg00004.html\" rel=\"nofollow noreferrer\">PR libstdc++/49813 revisited: constexpr on  functions (and builtins)</a>  where reopening the bug report mentioned above was discussed due to the issues laid out above:</p>\n<blockquote>\n<p id=\"so_22182432_27906899_3\">I believe we should re-open the bug in light of the actual resolution\n  of LWG 2013 (adding constexpr is forbidden).</p>\n<p id=\"so_22182432_27906899_4\">The FE should not treat builtins as constexpr in strict-conformance\n  mode.</p>\n<p id=\"so_22182432_27906899_5\">We should either remove _GLIBCXX_CONSTEXPR from &lt;cmath&gt; entirely or\n  make it conditional on __STRICT_ANSI__.</p>\n</blockquote>\n", "LastActivityDate": "2015-01-13T14:48:35.733"}, "bq_ids": {"n4140": {"so_22182432_22182432_0": {"section_id": 5776, "quality": 0.9705882352941176, "length": 33}, "so_22182432_27906899_2": {"section_id": 6343, "quality": 1.0, "length": 11}}, "n3337": {"so_22182432_22182432_0": {"section_id": 5549, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_22182432_22182432_0": {"section_id": 7233, "quality": 0.9705882352941176, "length": 33}, "so_22182432_27906899_2": {"section_id": 7852, "quality": 1.0, "length": 11}, "so_22182432_27906899_1": {"section_id": 7709, "quality": 0.5454545454545454, "length": 6}}}, "22187116": {"ParentId": "22182432", "CommentCount": "6", "Body": "<p>GCC does <em>not</em> consider <code>f()</code> to be a constant expression. Look at the diagnostics for <a href=\"http://coliru.stacked-crooked.com/a/2601b0c1b3abeb55\" rel=\"nofollow\">the first sample program you linked</a>:</p>\n<pre>main.cpp: In function 'int main()':\nmain.cpp:10:19: warning: ISO C++ forbids variable length array 'a' [-Wvla]\n         char a[f()];\n                   ^\n</pre>\n<p>The compiler doesn't think <code>f()</code> is a constant expression, the program is in fact using GCC's extension that allows variable length arrays - arrays with non-constant size.</p>\n<p>If you change the program to force <code>f()</code> into a constant expression:</p>\n<pre><code>int main() {\n    constexpr int size = f();\n    char a[size];\n    printf(\"%zd\\n\", sizeof a);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/e2d871e09339db4d\" rel=\"nofollow\">GCC does report an error</a>:</p>\n<pre>\nmain.cpp: In function 'int main()':\nmain.cpp:10:32:   in constexpr expansion of 'f()'\nmain.cpp:5:41: error: 'printf(((const char*)\"a side effect!\\012\"))' is not a constant expression\n         return printf(\"a side effect!\\n\");\n                                         ^</pre>\n", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "22187116", "Score": "4", "CreationDate": "2014-03-05T02:11:48.647", "LastActivityDate": "2014-03-05T02:11:48.647"}});