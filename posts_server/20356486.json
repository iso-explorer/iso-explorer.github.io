post_cb({"20356486": {"CommentCount": "3", "AcceptedAnswerId": "20356938", "CreationDate": "2013-12-03T16:28:21.147", "LastActivityDate": "2013-12-03T19:56:27.857", "PostTypeId": "1", "ViewCount": "400", "FavoriteCount": "1", "Title": "Can a variadic template match a non-variadic template parameter?", "Id": "20356486", "Score": "4", "Body": "<p>Consider the following snippet:</p>\n<pre><code>template&lt;template&lt;class&gt; class T,class U&gt;\nstruct apply\n{\n     typedef T&lt;U&gt; type;\n};\n\ntypedef apply&lt;std::tuple,int&gt;::type tuple_of_one_int; //Should be std::tuple&lt;int&gt;\n</code></pre>\n<p>GCC 4.8.2. says:</p>\n<pre><code>type/value mismatch at argument 1 in template parameter list for [...] struct apply\nexpected a template of type \u2018template&lt;class&gt; class T\u2019, got \u2018template&lt;class ...&gt; class std::tuple\u2019\n</code></pre>\n<p>Which basically means that a variadic template like <code>std::tuple</code> is not a valid template argument for <code>T</code> in <code>apply</code>.</p>\n<p>Is this a GCC bug or does the standard mandates this behaviour?</p>\n", "Tags": "<c++><templates><c++11><template-meta-programming><variadic>", "OwnerUserId": "666785", "AnswerCount": "3"}, "20357090": {"ParentId": "20356486", "CommentCount": "0", "Body": "<p>Your code is ill-formed, there is equivalent example in the standard (under 14.3.3/2):</p>\n<pre><code>...\ntemplate &lt;class ... Types&gt; class C { /\u2217 ... \u2217/ };\n\ntemplate&lt;template&lt;class&gt; class P&gt; class X { /\u2217 ... \u2217/ };\n...\nX&lt;C&gt; xc; // ill-formed: a template parameter pack does not match a template parameter\n...\n</code></pre>\n", "OwnerUserId": "1126943", "PostTypeId": "2", "Id": "20357090", "Score": "3", "CreationDate": "2013-12-03T16:55:17.253", "LastActivityDate": "2013-12-03T16:55:17.253"}, "bq_ids": {"n4140": {"so_20356486_20356938_0": {"section_id": 94, "quality": 0.9130434782608695, "length": 21}, "so_20356486_20356938_1": {"section_id": 94, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_20356486_20356938_0": {"section_id": 89, "quality": 0.9130434782608695, "length": 21}, "so_20356486_20356938_1": {"section_id": 89, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_20356486_20356938_0": {"section_id": 97, "quality": 0.6956521739130435, "length": 16}, "so_20356486_20356938_1": {"section_id": 97, "quality": 0.8888888888888888, "length": 24}}}, "20356938": {"ParentId": "20356486", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Someone correct me if I'm wrong but it seems like it's correct from this quote:  </p>\n<blockquote>\n<p id=\"so_20356486_20356938_0\">3 A template-argument matches a template template-parameter (call it P) when each of the template parameters in the template-parameter-list of the template-argument\u2019s corresponding class template or [FI 11] template aliasalias template (call it A) matches the corresponding template parameter in the template-parameter-list of P</p>\n</blockquote>\n<p><code>A</code> (the given template) has to match each of it's templates parameters to <code>P</code>'s the template template.   </p>\n<p>From the second part of the section we learn the restriction doesn't apply in the reverse, meaning a template template containing a parameter pack can match anything.  </p>\n<blockquote>\n<p id=\"so_20356486_20356938_1\">When P\u2019s template-parameter-list contains a template parameter pack (14.5.3), the template parameter pack will match zero or more template parameters or template parameter packs in the template-parameter- list of A with the same type and form as the template parameter pack in P   </p>\n</blockquote>\n<p>As you probably already knew the way to make it work is  </p>\n<pre><code>template&lt;template&lt;class&gt; class T,class U&gt;                                       \nstruct apply                                                                       \n{                                                                                  \n         typedef T&lt;U&gt; type;                                                        \n};                                                                                 \n\ntemplate&lt;class T&gt; using tuple_type  = std::tuple&lt;T&gt;;\ntypedef apply&lt;tuple_type,int&gt;::type tuple_of_one_int;                          \n</code></pre>\n<p>The c++11 standard also has an equivalent example to yours.  </p>\n<pre><code>template &lt;class ... Types&gt; class C { /\u2217 ... \u2217/ };\n\ntemplate&lt;template&lt;class&gt; class P&gt; class X { /\u2217 ... \u2217/ };\n\nX&lt;C&gt; xc; //ill-formed: a template parameter pack does not match a template parameter  \n</code></pre>\n<p>The last comment completely describes your situation, class <code>C</code> would be the equivalent of <code>std::tuple</code> in this case.</p>\n", "OwnerUserId": "2167655", "LastEditorUserId": "2167655", "LastEditDate": "2013-12-03T19:56:27.857", "Id": "20356938", "Score": "4", "CreationDate": "2013-12-03T16:48:33.760", "LastActivityDate": "2013-12-03T19:56:27.857"}, "20358579": {"ParentId": "20356486", "CommentCount": "4", "Body": "<p>The fix:</p>\n<pre><code>template&lt;template&lt;class...&gt; class T,class U&gt;\nstruct apply\n{\n     typedef T&lt;U&gt; type;\n};\n\ntypedef apply&lt;std::tuple,int&gt;::type tuple_of_one_int;\ntypedef apply&lt;std::vector,int&gt;::type vector_of_int;\n</code></pre>\n", "OwnerUserId": "1137388", "PostTypeId": "2", "Id": "20358579", "Score": "0", "CreationDate": "2013-12-03T18:13:00.680", "LastActivityDate": "2013-12-03T18:13:00.680"}});