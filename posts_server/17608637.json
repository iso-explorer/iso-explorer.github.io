post_cb({"bq_ids": {"n4140": {"so_17608637_17616371_0": {"length": 10, "quality": 1.0, "section_id": 5455}, "so_17608637_17608907_0": {"length": 5, "quality": 0.625, "section_id": 3321}}, "n3337": {"so_17608637_17616371_0": {"length": 6, "quality": 0.6, "section_id": 3191}}, "n4659": {"so_17608637_17616371_0": {"length": 10, "quality": 1.0, "section_id": 6881}, "so_17608637_17608907_0": {"length": 5, "quality": 0.625, "section_id": 7709}}}, "17608907": {"Id": "17608907", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_17608637_17608907_0\">but the return statement would be ill-formed, does SFINAE result? </p>\n</blockquote>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3638.html\" rel=\"noreferrer\">proposal-n3638</a> says, </p>\n<blockquote>\n<p id=\"so_17608637_17608907_1\"><strong>SFINAE</strong></p>\n<p id=\"so_17608637_17608907_2\">Since the return type is deduced by instantiating the template, <strong>if the instantiation is ill-formed, this causes an error rather than a substitution failure</strong>. This allows an auto function to return a lambda, which is not possible using the decltype(returned expression) pattern.</p>\n</blockquote>\n<p>Hope that is what you're looking for.</p>\n", "LastActivityDate": "2013-07-12T06:41:38.617", "Score": "15", "CreationDate": "2013-07-12T06:41:38.617", "ParentId": "17608637", "CommentCount": "1", "OwnerUserId": "415784"}, "17616371": {"Id": "17616371", "PostTypeId": "2", "Body": "<p>Following up on Nawaz's link, the remaining questions are answered by N3690 \u00a77.1.6.4/11:</p>\n<blockquote>\n<p id=\"so_17608637_17616371_0\">If the type of an entity with an undeduced placeholder type is needed to determine the type of an expression, the program is ill-formed.</p>\n</blockquote>\n<p>This means that even if SFINAE worked with return type deduction, it couldn't be used to query one function declaration from another. The signature is essentially invalid until the <code>return</code> statement is processed, which occurs at the closing brace of the <code>class {}</code> definition, and after the definitions of preceding members have been processed.</p>\n<p>In a sense, all member <code>decltype(auto)</code> functions are incomplete with respect to preceding functions in the same class:</p>\n<pre><code>struct s {\n    void f() { a(); } // error: use of \u2018auto s::a()\u2019 before deduction of \u2018auto\u2019\n    auto a() { return 3; }\n};\n</code></pre>\n<p>This is GCC's complaint; it goes away if the member declarations are reversed. This is because the function definitions are processed in order of declaration, when the <code>}</code> from the class definition is reached. If the statement <code>a();</code> is processed before the <code>return 3;</code>, then the program is ill-formed.</p>\n", "LastActivityDate": "2013-07-12T13:43:25.000", "Score": "3", "CreationDate": "2013-07-12T13:43:25.000", "ParentId": "17608637", "CommentCount": "0", "OwnerUserId": "153285"}, "17608637": {"ViewCount": "820", "Body": "<p>If a function template returns <code>decltype(auto)</code> (or another type specifier using <code>auto</code>) but the return statement would be ill-formed, does SFINAE result? Is the <code>return</code> statement considered to be the immediate context of the function signature?</p>\n<p>Nothing in the N3690 draft seems to require this. By default, I guess SFINAE does not apply.</p>\n<p>This seems unfortunate because you can write a function to forward to another function, but you cannot make its existence conditional on the delegate as when writing longhand. Furthermore, checking the existence of a peer nonstatic member function cannot be done without <code>decltype(auto)</code> because <code>this</code> cannot be used in a function signature. However this indicates a fundamental problem, as <code>decltype(auto)</code> provides a path to considering the class type as complete within a member signature, where it's not.</p>\n<p>Has a proposal been written, or has the problem been formally analyzed anywhere?</p>\n<p>The ability to treat the class type as complete within a member signature may have other implications\u2026 but that's just fodder for another question.</p>\n", "AcceptedAnswerId": "17608907", "Title": "SFINAE and decltype(auto)", "CreationDate": "2013-07-12T06:23:00.197", "Id": "17608637", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-07-12T06:27:27.230", "LastEditorUserId": "153285", "LastActivityDate": "2013-07-12T13:43:25.000", "Score": "16", "OwnerUserId": "153285", "Tags": "<c++><auto><decltype><c++14>", "AnswerCount": "2"}});