post_cb({"30013739": {"ParentId": "30012733", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>There might be difference in contexts involving <code>std::initializer_list&lt;&gt;</code>, e.g.:</p>\n<p>Case 1 - <code>()</code> and <code>{}</code></p>\n<pre><code>#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Test2 {\n    Test2(initializer_list&lt;int&gt; l) {}\n};\n\nint main() {\n    Test2* test3 = new Test2(); // compile error: no default ctor\n    Test2* test4 = new Test2{}; // calls initializer_list ctor\n}\n</code></pre>\n<p>Case 2: <code>(v)</code> and <code>{v}</code></p>\n<pre><code>struct Value {\n};\n\nstruct Test3 {\n    Test3(Value v) {}\n    Test3(initializer_list&lt;Value&gt; v) {}\n};\n\nint main() {\n    Value v;\n    Test3* test5 = new Test3(v); // calls Test3(Value)\n    Test3* test6 = new Test3{v}; // calls Test3(initializer_list&lt;Value&gt;)\n}\n</code></pre>\n<p>As stated by Meyers and others there is also a huge difference when using STL:</p>\n<pre><code>    using Vec = std::vector&lt;int&gt;;\n    Vec* v1 = new Vec(10); // vector of size 10 holding 10 zeroes\n    Vec* v2 = new Vec{10}; // vector of size 1 holding int 10\n</code></pre>\n<p>and it is not restricted to <code>std::vector</code> only</p>\n<p>In this case there's no difference though (and <code>initializer_list</code> ctor is ignored)</p>\n<pre><code>#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Test {\n    Test() {}\n    Test(initializer_list&lt;int&gt; l) {}\n};\n\nint main() {\n    Test* test1 = new Test(); // calls default ctor\n    Test* test2 = new Test{}; // same, calls default ctor\n}\n</code></pre>\n<p>There is also a well-known difference in this case</p>\n<pre><code>void f() {\n    Test test{};\n    Test test2();\n}\n</code></pre>\n<p>where <code>test</code> is default-initialized object of type <code>Test</code> and <code>test2</code> is a function declaration.</p>\n", "OwnerUserId": "2014022", "LastEditorUserId": "1916893", "LastEditDate": "2015-05-06T07:06:30.813", "Id": "30013739", "Score": "9", "CreationDate": "2015-05-03T12:20:06.987", "LastActivityDate": "2015-05-06T07:06:30.813"}, "30013834": {"ParentId": "30012733", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><strong>No!</strong></p>\n<p>A <em>new-initializer</em> may take the following forms:</p>\n<blockquote>\n<p id=\"so_30012733_30013834_0\"><em>new-initializer</em>:<br>\n  \u00a0\u00a0\u00a0<code>(</code> <em>expression-list</em><sub>opt</sub><code>)</code><br>\n  \u00a0\u00a0\u00a0<em>braced-init-list</em></br></br></p>\n</blockquote>\n<p>And:</p>\n<blockquote>\n<p id=\"so_30012733_30013834_1\"><code>[C++11: 5.3.4/15]:</code> A <em>new-expression</em> that creates an object of type <code>T</code> initializes that object as follows:</p>\n<ul>\n<li>If the <em>new-initializer</em> is omitted, the object is <em>default-initialized</em> (8.5); if no initialization is performed, the object has indeterminate value.</li>\n<li>Otherwise, the <em>new-initializer</em> is interpreted according to the initialization rules of 8.5 for <em>direct-initialization</em>.</li>\n</ul>\n</blockquote>\n<p>And:</p>\n<blockquote>\n<p id=\"so_30012733_30013834_2\"><code>[C++11: 8.5/15]:</code> The initialization that occurs in the forms</p>\n<pre><code>T x(a);\nT x{a};\n</code></pre>\n<p id=\"so_30012733_30013834_3\">as well as in <code>new</code> expressions (5.3.4), <code>static_cast</code> expressions (5.2.9), functional notation type conversions (5.2.3), and base and member initializers (12.6.2) is called <em>direct-initialization</em>.</p>\n</blockquote>\n<p>And:</p>\n<blockquote>\n<p id=\"so_30012733_30013834_4\"><code>[C++11: 8.5/16]:</code> The semantics of initializers are as follows. <em>[..]</em></p>\n<ul>\n<li>If the initializer is a (non-parenthesized) <em>braced-init-list</em>, the object or reference is <em>list-initialized</em> (8.5.4).</li>\n<li><em>[..]</em></li>\n<li>If the initializer is <code>()</code>, the object is <em>value-initialized</em>.</li>\n<li><em>[..]</em></li>\n<li>If the initialization is <em>direct-initialization</em>, or if it is <em>copy-initialization</em> where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best\n  one is chosen through overload resolution (13.3). The constructor so selected is called to initialize the object, with the initializer expression or expression-list as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</li>\n<li><em>[..]</em></li>\n</ul>\n</blockquote>\n<p>So, you see, in this case (and a few others), the two are defined to both be <em>direct-initialisation</em>, but further rules mean that different things can occur depending on whether you use <code>()</code> or <code>{}</code> and whether the initialiser is empty.</p>\n<p>Considering the rules for <em>list-initialisation</em>, which I shan't reproduce here, the two initialisers have essentially the same effect <em>if</em> <code>T</code> has no constructor taking an <code>std::initializer_list&lt;&gt;</code>.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2015-05-03T12:53:03.363", "Id": "30013834", "Score": "4", "CreationDate": "2015-05-03T12:31:02.427", "LastActivityDate": "2015-05-03T12:53:03.363"}, "30013914": {"ParentId": "30012733", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The general answer is no. The use of a braced-init-list as the initializer will first try to resolve to the constructor that takes an <code>std::initializer_list</code>. As an illustration:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nint main() {\n  auto p = new std::vector&lt;int&gt;{1};\n  auto q = new std::vector&lt;int&gt;(1);\n  std::cout &lt;&lt; p-&gt;at(0) &lt;&lt; '\\n';\n  std::cout &lt;&lt; q-&gt;at(0) &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Note the semantics of list-initialization (Quoted from <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow\">cppreference</a>):</p>\n<blockquote id=\"so_30012733_30013914_0\">\n<ul>\n<li>All constructors that take std::initializer_list as the only argument, or as the first argument if the remaining arguments have\n  default values, are examined, and matched by overload resolution\n  against a single argument of type std::initializer_list</li>\n<li>If the previous stage does not produce a match, all constructors of T participate in overload resolution against the set of arguments that\n  consists of the elements of the braced-init-list, with the restriction\n  that only non-narrowing conversions are allowed. If this stage\n  produces an explicit constructor as the best match for a\n  copy-list-initialization, compilation fails (note, in simple\n  copy-initialization, explicit constructors are not considered at all)</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "1348273", "LastEditorUserId": "1348273", "LastEditDate": "2015-05-03T13:08:30.330", "Id": "30013914", "Score": "4", "CreationDate": "2015-05-03T12:40:14.213", "LastActivityDate": "2015-05-03T13:08:30.330"}, "30012733": {"CommentCount": "1", "AcceptedAnswerId": "30013739", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-05-03T10:25:40.513", "LastActivityDate": "2015-05-06T07:06:30.813", "LastEditDate": "2017-05-23T10:29:15.243", "ViewCount": "546", "FavoriteCount": "1", "Title": "Are () and {} always equivalent when used for initialization with \"new\"?", "Id": "30012733", "Score": "7", "Body": "<p>There is a post that deals with <a href=\"https://stackoverflow.com/questions/620137/do-the-parentheses-after-the-type-name-make-a-difference-with-new\">parentheses or not after the type name</a> when using new. But what about this:</p>\n<p>If 'Test' is an ordinary class, is there any difference between:</p>\n<pre><code>Test* test = new Test();\n// and\nTest* test = new Test{};\n</code></pre>\n<p>Furthermore, suppose <code>Test2</code> has a constructor for an argument of type <code>Value</code>, is it always equivalent to write:</p>\n<pre><code>Value v;\nTest2 *test2 = new Test(v);\n// and\nTest2 *test2 = new Test{v};\n</code></pre>\n", "Tags": "<c++><c++11><constructor><initialization><new-operator>", "OwnerUserId": "1978011", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_30012733_30013834_3": {"section_id": 3295, "quality": 0.7777777777777778, "length": 14}, "so_30012733_30013834_1": {"section_id": 6098, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_30012733_30013834_3": {"section_id": 3165, "quality": 0.7777777777777778, "length": 14}, "so_30012733_30013834_1": {"section_id": 5864, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_30012733_30013834_3": {"section_id": 4057, "quality": 0.5555555555555556, "length": 10}, "so_30012733_30013834_1": {"section_id": 7595, "quality": 0.7777777777777778, "length": 7}}}});