post_cb({"19340190": {"ViewCount": "277", "Body": "<p>I am trying to use <code>boost::bind</code> to call a member function in a class.  Normally this works fine, but in this particular case my compiler (GCC) is complaining that I am trying to use an inaccessible base class when I am not.</p>\n<p>Here is some code that demonstrates the problem.  What am I doing wrong?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;boost/bind.hpp&gt;\n#include &lt;boost/function.hpp&gt;\n\nclass base\n{\n    protected:\n        void test()\n        {\n            std::cout &lt;&lt; \"base::test()\\n\";\n        }\n};\n\nclass derived: virtual protected base\n{\n    public:\n        using base::test;\n};\n\nint main(void)\n{\n    derived d;\n\n    // This works, calling derived::test(), which in turn calls base::test()\n    d.test();\n\n    // This does not work, saying 'base' is an inaccessible base of 'derived',\n    // but I am not binding base::test, I am binding derived::test.\n    boost::function&lt;void()&gt; fn;\n    fn = boost::bind(&amp;derived::test, d);\n    fn();\n\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "19340231", "Title": "C++ boost::bind says inaccessible base class", "CreationDate": "2013-10-12T23:18:06.850", "Id": "19340190", "CommentCount": "15", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-10-13T00:53:01.860", "LastEditorUserId": "308237", "LastActivityDate": "2013-10-13T11:38:45.090", "Score": "2", "OwnerUserId": "308237", "Tags": "<c++><inheritance><boost>", "AnswerCount": "2"}, "19340231": {"Id": "19340231", "PostTypeId": "2", "Body": "<p>The <code>using</code> declaration doesn't define a function. It \"declares a name\" (not a function!), and unhides base names. It's true that the declaration itself has its own accessibility level, which is why you're using it at all in the first place, but to stress again: The using declaration does not declare a new member function. E.g. C++11 7.3.3/11:</p>\n<blockquote>\n<p id=\"so_19340190_19340231_0\">The entity declared by a <em>using-declaration</em> shall be known in the context using it according to its definition at the point of the using-declaration.</p>\n</blockquote>\n<p>\"Its definition\", in your case, is still <code>void base::test(){}</code>, and <em>that</em> is the entity that is made known to the derived class and referred to by <code>&amp;derived::test</code>. You can't get a function pointer of type <code>void(derived:**)()</code> from this because there is no such function.</p>\n<p>When you say <code>&amp;derived::test</code>, the <code>&amp;</code>-operator is used, which works like this (5.3.1/3):</p>\n<blockquote>\n<p id=\"so_19340190_19340231_1\">The result of the unary <code>&amp;</code> operator is a pointer to its operand. The operand shall be an lvalue or a <em>qualified-id</em>. If the operand is a <em>qualified-id</em> naming a non-static member <code>m</code> of some class <code>C</code> with type <code>T</code>, the result has type \u201cpointer to member of class <code>C</code> of type <code>T</code>\u201d and is a prvalue designating C::m.</p>\n</blockquote>\n<p>In my interpretation of the above logic, <code>&amp;derived::test</code> \"names the non-static member <code>test</code> of class <code>base</code>\". [Thanks to @DyP:] The is formalized in 10.2/3:</p>\n<blockquote>\n<p id=\"so_19340190_19340231_2\">The lookup set for <code>f</code> in <code>C</code> [...] consists of [...] the declaration set [...]. In the declaration set, <em>using-declarations</em> are replaced by the members they designate</p>\n</blockquote>\n<p>If you really want, you can provide a wrapper like this:</p>\n<pre><code>class derived : protected base\n{\npublic:\n    void test() { base::test(); }\n};\n</code></pre>\n<p>(Curiously, that solution actually <em>does</em> hide the base function, which is what we want. Rather than using <code>using</code>, we use an explicitly qualified name to refer to the base function.)</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2013-10-13T11:38:45.090", "Score": "7", "CreationDate": "2013-10-12T23:25:08.517", "ParentId": "19340190", "CommentCount": "3", "OwnerUserId": "596781", "LastEditDate": "2013-10-13T11:38:45.090"}, "19340796": {"Id": "19340796", "PostTypeId": "2", "Body": "<p>When the function is called, the implicit <code>this</code> argument needs to be converted to the base class. The <code>using</code> declaration does not adjust the type of <code>test</code> from <code>base::*</code> to <code>derived::*</code>.</p>\n<p>You can perform such adjustment manually:</p>\n<pre><code>static_cast&lt; void (derived::*)() &gt;( &amp;derived::test )\n</code></pre>\n<p>but this likewise requires the base to be accessible. So the complete solution would be to encapsulate the above <code>static_cast</code> inside the derived class. Otherwise it should be an accessible base.</p>\n", "LastActivityDate": "2013-10-13T01:08:40.983", "CommentCount": "3", "CreationDate": "2013-10-13T01:08:40.983", "ParentId": "19340190", "Score": "6", "OwnerUserId": "153285"}, "bq_ids": {"n4140": {"so_19340190_19340231_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 6066}, "so_19340190_19340231_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 6991}}, "n3337": {"so_19340190_19340231_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 5834}, "so_19340190_19340231_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 6737}, "so_19340190_19340231_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5286}}, "n4659": {"so_19340190_19340231_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 7562}, "so_19340190_19340231_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 8489}}}});