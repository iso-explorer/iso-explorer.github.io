post_cb({"19850591": {"Id": "19850591", "PostTypeId": "2", "Body": "<p><strong><em>Update 3:</em></strong>: I've added <a href=\"https://stackoverflow.com/a/27851536/146041\">another answer</a>, so ignore this. I'm tempted to delete this as it no longer works for me with newer compilers. But I already have some responses here, so I guess I shouldn't delete this. Also, this particular answer did work on some older compilers, so it might be useful to some people.</p>\n<p>This will test if there is a constructor of the form <code>T(T&amp;&amp;)</code>.  <em>Works on clang-3.3, and g++-4.6.3.  But <a href=\"http://ideone.com/CbmUxG\" rel=\"nofollow noreferrer\">this test on ideone</a> shows that their compiler (g++-???) confuses the copy and move constructors.</em></p>\n<p><strong><em>Update 2: January 2015</em></strong>. This does not work with newer g++ (4.8.2) and clang (3.5.0). So I guess my answer here is not helpful without first checking that your particular version supports the trick I've used here. Perhaps my trick is not compliant with the standard and has since been removed from g++ and clang++. In my answer below I said \"a derived class will only have an implicit move constructor if all its bases have move constructors\" - perhaps this is not true or too simplistic?</p>\n<pre><code>struct move_not_copy { move_not_copy(move_not_copy &amp;&amp;); };\n\ntemplate&lt;typename T&gt;\nstruct has_move_constructor {\n        struct helper : public move_not_copy,  public T {\n        };\n        constexpr static bool value =\n               std::is_constructible&lt;helper,\n               typename std::add_rvalue_reference&lt;helper&gt;::type&gt; :: value;\n        constexpr operator bool () const { return value; }\n};\n</code></pre>\n<p>More precisely, regardless of whether a class has a copy constructor <code>T(const T&amp;)</code>, this trait is still able to detect if the class also has a move constructor <code>T(T&amp;&amp;)</code>.</p>\n<p>The trick is to derive a very simple class, <code>helper</code>, with two bases and no other methods/constructors.  Such a derived class will only have an implicit move constructor if <em>all</em> its bases have move constructors.  Similarly for copy constructors.  The first base, <code>move_not_copy</code> has no copy constructor, therefore <code>helper</code> will not have a copy constructor.  However, <code>helper</code> is still able to pick up an implicitly-defined move constructor if, and only if, <code>T</code> has such a constructor.  Therefore, <code>helper</code> will either have zero constructors, or one constructor (a move constructor), depending only on whether T has a move constructor.</p>\n<hr>\n<p><strong><em>Tests</em></strong>.  This is the table for four types, showing the desired behaviour.  A full program testing it is at <a href=\"http://ideone.com/CbmUxG\" rel=\"nofollow noreferrer\">ideone</a>, but as I said earlier, it's getting the wrong results on ideone because they're using and old g++.</p>\n<pre><code>               Copy is_copy_constructible 1  is_move_constructible 1  has_move_constructor 0\n           MoveOnly is_copy_constructible 0  is_move_constructible 1  has_move_constructor 1\n               Both is_copy_constructible 1  is_move_constructible 1  has_move_constructor 1\nCopyWithDeletedMove is_copy_constructible 1  is_move_constructible 0  has_move_constructor 0\n</code></pre>\n<hr>\n<p>What does the standard have to say on this?  I got the idea after reading <a href=\"http://en.cppreference.com/w/cpp/language/move_constructor\" rel=\"nofollow noreferrer\">cppreference</a>, specifically:</p>\n<blockquote>\n<p id=\"so_7054952_19850591_0\">The implicitly-declared or defaulted move constructor for class T is defined as deleted if <em>any</em> of the following is true: </p>\n<p id=\"so_7054952_19850591_1\">...</p>\n<p id=\"so_7054952_19850591_2\">T has direct or virtual base class that cannot be moved (has deleted, inaccessible, or ambiguous move constructors)</p>\n<p id=\"so_7054952_19850591_3\">...</p>\n</blockquote>\n<p>and I assume a similar thing applies to copy constructors.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-11T21:54:16.850", "Score": "2", "CreationDate": "2013-11-08T02:33:16.193", "ParentId": "7054952", "CommentCount": "2", "LastEditDate": "2017-05-23T12:02:43.670", "OwnerUserId": "146041"}, "7056581": {"Id": "7056581", "PostTypeId": "2", "Body": "<p>After a little discussion, and in full agreement that this may be entirely useless, and with the warning that older compilers may get this wrong, I would nevertheless like to paste a little trait class I rigged up which I believe will give you <code>true</code> only when a class has a move constructor:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename T, bool P&gt; struct is_movecopy_helper;\n\ntemplate &lt;typename T&gt;\nstruct is_movecopy_helper&lt;T, false&gt;\n{\n  typedef T type;\n};\n\ntemplate &lt;typename T&gt;\nstruct is_movecopy_helper&lt;T, true&gt;\n{\n  template &lt;typename U&gt;\n  struct Dummy : public U\n  {\n    Dummy(const Dummy&amp;) = delete;\n    Dummy(Dummy&amp;&amp;) = default;\n  };\n  typedef Dummy&lt;T&gt; type;\n};\n\ntemplate &lt;class T&gt;\nstruct has_move_constructor\n : std::integral_constant&lt;bool, std::is_class&lt;T&gt;::value &amp;&amp;\n   std::is_move_constructible&lt;typename is_movecopy_helper&lt;T, std::is_class&lt;T&gt;::value&gt;::type&gt;::value&gt; { };\n</code></pre>\n<p>Usage: <code>has_move_constructor&lt;T&gt;::value</code></p>\n<p>Note that the compiler-trait <code>std::is_move_constructible</code> isn't actually shipped with GCC 4.6.1 and has to be provided separately, see my <a href=\"http://ideone.com/ac8YI\" rel=\"nofollow\">complete code</a>.</p>\n", "LastActivityDate": "2011-08-14T11:38:50.737", "Score": "3", "CreationDate": "2011-08-14T11:38:50.737", "ParentId": "7054952", "CommentCount": "6", "OwnerUserId": "596781"}, "30806221": {"Id": "30806221", "PostTypeId": "2", "Body": "<p>I took <a href=\"https://stackoverflow.com/a/27851536/2229188\">Aaron McDaid's last answer</a> and wrapped it in the construct below. The code in his answer didn't work for me, this does with both clang 3.6 and MSVC2013.</p>\n<pre><code>template &lt;typename T&gt;\nstruct has_move_constructor_alongside_copy {\n  typedef char yes[1];\n  typedef char no[2];\n\n  struct AmbiguousConverter {\n    operator T&amp;&amp; ();\n    operator const T&amp; ();\n  };\n\n  template &lt;typename C&gt;\n  static no&amp; test(decltype( new C( AmbiguousConverter{} )));\n\n  template &lt;typename&gt;\n  static yes&amp; test(...);\n\n  static const bool value = sizeof(test&lt;T&gt;(0)) == sizeof(yes);\n};\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-12T14:58:54.590", "Score": "1", "CreationDate": "2015-06-12T14:58:54.590", "ParentId": "7054952", "CommentCount": "1", "LastEditDate": "2017-05-23T12:17:55.067", "OwnerUserId": "2229188"}, "bq_ids": {"n4140": {"so_7054952_19850591_0": {"length": 6, "quality": 0.6, "section_id": 369}}, "n3337": {"so_7054952_19850591_0": {"length": 6, "quality": 0.6, "section_id": 359}, "so_7054952_19850591_2": {"length": 8, "quality": 0.7272727272727273, "section_id": 451}}, "n4659": {"so_7054952_19850591_0": {"length": 6, "quality": 0.6, "section_id": 483}, "so_7054952_19850591_2": {"length": 6, "quality": 0.5454545454545454, "section_id": 495}}}, "27851536": {"Id": "27851536", "PostTypeId": "2", "Body": "<p>You can introduce an intentional ambiguity error when both a move constructor and a copy constructor are present. This allow us to test for the presence of a move constructor.</p>\n<p><em>Over recent years, as compilers change, different solutions work and then break. This is working with clang 3.5.0. I'm hopeful that it will work on older and newer compilers also - but I'm not an expert on the standard.</em></p>\n<p><em>Also, This answer requires more work to finish it, but I've tested the fundamental idea.</em></p>\n<p>First, it's easy to tell if there is a copy-constructor. If there is no copy constructor, then it's easy to tell if there is a move constructor. The challenge is, when there <em>is</em> a copy constructor, to test if there is <em>also</em> a move constructor. This is the challenge I will focus on here.</p>\n<p>Therefore, it is enough to consider only types that do have a copy constructor and test for the presence of a move constructor. For the remainder of this question I will assume a copy constructor is present.</p>\n<hr>\n<p>I test for the move constructor by forcing an ambiguity error when both kinds of constructor are present and then (ab)using SFINAE to test for the presence of this ambiguity.</p>\n<p>In other words, our challenge is to test the difference between the following types:</p>\n<pre><code>struct CopyOnly { \n    CopyOnly (const CopyOnly&amp;);  // just has a copy constructor\n};\nstruct Both { \n    Both (const Both&amp;);          // has both kinds of constructor\n    Both (Both&amp;&amp;);     \n};\n</code></pre>\n<p>To do this, first define a <code>Converter&lt;T&gt;</code> class that claims to be able to convert itself into two kinds of reference. (We'll never need to implement these)</p>\n<pre><code>template&lt;typename T&gt;\nstruct Converter { \n    operator T&amp;&amp; ();\n    operator const T&amp; ();\n};\n</code></pre>\n<p>Second, consider these lines:</p>\n<pre><code>Converter&lt;T&gt; z;\nT t(z);\n</code></pre>\n<p>The second line is trying to construct a <code>T</code>. If <code>T</code> is <code>CopyOnly</code>, then <code>t</code> will be made via the copy constructor, and the relevant reference to pass to the copy constructor is extracted from the <code>operator const CopyOnly &amp;()</code> method of <code>Converter&lt;CopyOnly&gt;</code>. So far, this is pretty standard. (I think?)</p>\n<p>But, if <code>T</code> is <code>Both</code>, i.e. it also has a move constructor, there will be an ambiguity error. Both constructors of <code>T</code> are available, as converters are available for both (converters from <code>z</code>), therefore there is ambiguity. (Any language lawyers able to confirm this is fully standard?)</p>\n<p>This logic applies also to <code>new T( Converter&lt;T&gt;{} )</code>. This expression has a type if, and only if, <code>T</code> does not have a move constructor. We can therefore wrap <code>decltype</code> around this and use this in SFINAE.</p>\n<p>I close with two overloads of <code>baz&lt;T&gt;</code>. The chosen overload will depend on whether <code>T</code> is like <code>CopyOnly</code> or <code>Both</code>. The first overload is valid only if <code>new T( Converter&lt;T&gt;{} )</code> is well-defined, i.e. if there is no ambiguity error, i.e. if there is no move constructor. You can give different return types to each overload to make this information available at compile time.</p>\n<pre><code>template&lt;typename T&gt;\nstd:: true_type\nbaz (decltype( new T( Converter&lt;T&gt;{} )   )) {\n    cout &lt;&lt; __LINE__ &lt;&lt; endl;\n    return {};\n}\n\ntemplate&lt;typename U&gt;\nstd:: false_type\nbaz ( \n        const volatile // const volatile to tie break when both forms of baz are available\n        U *) { \n    cout &lt;&lt; __LINE__ &lt;&lt; endl;\n    return {};\n}\n</code></pre>\n<p><code>baz</code> should be called like this:</p>\n<pre><code>baz&lt;JustCopy&gt;((JustCopy*)nullptr);\nbaz&lt;Both&gt;((Both*)nullptr);\n</code></pre>\n<p>And you could wrap it up in something like this:</p>\n<pre><code>template&lt;typename T&gt;\nstruct has_move_constructor_alongside_copy {\n    typedef decltype(baz&lt;T&gt;((T*)nullptr)) type;\n};\n</code></pre>\n<hr>\n<p>There's a lot to do to tidy this up, and I'm sure SFINAE experts could improve it greatly (please do!). But I think this solves the main problem, testing for the presence of a move constructor when we already know a copy constructor is present.</p>\n</hr></hr>", "LastEditorUserId": "146041", "LastActivityDate": "2015-01-11T11:57:30.660", "Score": "1", "CreationDate": "2015-01-08T23:38:53.517", "ParentId": "7054952", "CommentCount": "0", "LastEditDate": "2015-01-11T11:57:30.660", "OwnerUserId": "146041"}, "7054952": {"ViewCount": "3244", "Body": "<p>I'm trying to write a template that behaves one way if T has a move constructor, and another way if T does not.  I tried to look for a type trait that could identify this but have had no such luck and my attempts at writing my own type trait for this have failed.</p>\n<p>Any help appreciated.</p>\n", "AcceptedAnswerId": "7055102", "Title": "Type trait for moveable types?", "CreationDate": "2011-08-14T04:10:03.043", "Id": "7054952", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-06-12T14:58:54.590", "Score": "13", "OwnerUserId": "88315", "Tags": "<c++><c++11><typetraits>", "AnswerCount": "6"}, "7055102": {"Id": "7055102", "PostTypeId": "2", "Body": "<p>I feel the need to point out a subtle distinction.</p>\n<p>While <code>&lt;type_traits&gt;</code> does provide <code>std::is_move_constructible</code> and <code>std::is_move_assignable</code>, those do not exactly detect whether a type has a move constructor (resp. move assignment operator) or not. For instance, <code>std::is_move_constructible&lt;int&gt;::value</code> is <code>true</code>, and consider as well the following case:</p>\n<pre><code>struct copy_only {\n    copy_only(copy_only const&amp;) {} // note: not defaulted on first declaration\n};\nstatic_assert( std::is_move_constructible&lt;copy_only&gt;::value\n             , \"This won't trip\" );\n</code></pre>\n<p>Note that the user-declared copy constructor suppresses the implicit declaration of the move constructor: there is not even a hidden, compiler-generated <code>copy_only(copy_only&amp;&amp;)</code>.</p>\n<p>The purpose of type traits is to facilitate generic programming, and are thus specified in terms of expressions (for want of concepts). <code>std::is_move_constructible&lt;T&gt;::value</code> is asking the question: is e.g. <code>T t = T{};</code> valid? It is not asking (assuming <code>T</code> is a class type here) whether there is a <code>T(T&amp;&amp;)</code> (or any other valid form) move constructor declared.</p>\n<p>I don't know what you're trying to do and I have no reason not to believe that <code>std::is_move_constructible</code> isn't suitable for your purposes however.</p>\n", "LastActivityDate": "2011-08-14T04:58:45.530", "Score": "15", "CreationDate": "2011-08-14T04:58:45.530", "ParentId": "7054952", "CommentCount": "3", "OwnerUserId": "726300"}, "7054990": {"Id": "7054990", "PostTypeId": "2", "Body": "<p>It's called <code>std::is_move_constructable</code>. There is also <code>std::is_move_assignable</code>. They are both in the C++0x <code>&lt;type_traits&gt;</code> header.</p>\n", "LastActivityDate": "2011-08-14T04:24:03.167", "Score": "9", "CreationDate": "2011-08-14T04:24:03.167", "ParentId": "7054952", "CommentCount": "0", "OwnerUserId": "734069"}});