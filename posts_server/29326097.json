post_cb({"29328655": {"ParentId": "29326097", "CommentCount": "1", "Body": "<p>All guarantees about the function are only valid as long as you pass a valid pointer to a string.</p>\n<p>If you don't, anything may happen, including throwing an exception.</p>\n<p>In other words, the part about unspecified behavior takes priority over the part about the regular behavior.</p>\n", "OwnerUserId": "49793", "PostTypeId": "2", "Id": "29328655", "Score": "0", "CreationDate": "2015-03-29T11:40:58.973", "LastActivityDate": "2015-03-29T11:40:58.973"}, "29326097": {"CommentCount": "3", "AcceptedAnswerId": "29326353", "CreationDate": "2015-03-29T05:51:49.543", "LastActivityDate": "2015-03-29T11:40:58.973", "PostTypeId": "1", "ViewCount": "307", "FavoriteCount": "1", "Title": "How can C++'s atoi() guarantee not to throw an exception if it allows undefined behavior?", "Id": "29326097", "Score": "2", "Body": "<p>I was reading this:</p>\n<p><a href=\"http://www.cplusplus.com/reference/cstdlib/atoi/\" rel=\"nofollow\">http://www.cplusplus.com/reference/cstdlib/atoi/</a></p>\n<p>when I saw two sentences that make no sense to me towards the end.</p>\n<blockquote>\n<p id=\"so_29326097_29326097_0\">this function never throws exceptions.</p>\n</blockquote>\n<p>vs.</p>\n<blockquote>\n<p id=\"so_29326097_29326097_1\">If str does not point to a valid C-string, or if the converted value would be out of the range of values representable by an int, it causes undefined behavior.</p>\n</blockquote>\n<p>If the behavior of a bad parse is undefined, doesn't that mean all bets are off, and it's entirely possible for an exception to be raised? Or does this mean \"undefined except that the runtime promises not to throw an exception\"?</p>\n", "Tags": "<c++><exception><undefined-behavior><atoi>", "OwnerUserId": "3075658", "AnswerCount": "4"}, "29326353": {"ParentId": "29326097", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>When the C or C++ standards speak of undefined behaviour, they mean that the consequence of running the program <em>as a whole</em> is undefined, not that the result or consequence of executing a particular construct is unspecified. It is even possible that execution of the program will be derailed <em>before the erroneous construct is executed</em>. For example, the runtime may detect that a pointer which will later be provided to <code>atoi</code> is invalid, and interrupt execution at that point. If the compiler could prove that this will happen, it could even fail to compile the program. The standard(s) explicitly make no restriction on what might be the result of the execution of a program which engenders undefined behaviour.</p>\n<p>Having said that, it is unlikely that calling <code>atoi</code> with an invalid argument will raise an exception. The most likely consequences of integer overflow are truncation, clamping, or a trap/signal (which is not an exception); the most likely consequence of an invalid pointer is a segfault, which (on a Unix-like system) is a signal; as above, signals are not exceptions.</p>\n<p>Nonetheless, it is not impossible that a given implementation may choose to raise an exception on receipt of a signal produced by a segfault or an integer overflow. Such an implementation would presumably attempt to ensure that an exception so raised could be caught, even if the signal is raised during execution of a function declared as not throwing. (Such an implementation would probably also document which exception would be raised in such cases, since an implementation is free to define the consequence of behaviour undefined by the standard.) If that attempt failed, and the exception was instead punted higher up the exception stack than was desired, that would still fall inside the complete lack of standard specification; the worst the implementation could be accused of would be failing to implement its own extension to the standard, which is a quality-of-implementation issue.</p>\n<hr>\n<h3>Language-lawyerly addition:</h3>\n<p>Obligatory standard quote: (\u00a71.9 <strong>[intro.execution]</strong>, paragraph 5)</p>\n<blockquote>\n<p id=\"so_29326097_29326353_0\">A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible executions of the corresponding instance of the abstract machine with the same program and the same input. However, if any such execution contains an undefined operation, this International Standard places no requirement on the implementation executing that program with that input (not even with regard to operations preceding the first undefined operation).</p>\n</blockquote>\n<p>Any description of program execution made by the standard (\"shall not throw exceptions\", for example) needs to be interpreted within the context of that paragraph.</p>\n</hr>", "OwnerUserId": "1566221", "LastEditorUserId": "1566221", "LastEditDate": "2015-03-29T07:21:09.987", "Id": "29326353", "Score": "3", "CreationDate": "2015-03-29T06:36:24.173", "LastActivityDate": "2015-03-29T07:21:09.987"}, "29326275": {"ParentId": "29326097", "CommentCount": "1", "Body": "<p>When it says that it does not throw an exception, you should read that - do not expect an exception to be raised when a problem arises.</p>\n<p>Of course the exception may be raised by a pure luck, but it is very unlikely to happen. You shouldn't rely on it.</p>\n", "OwnerUserId": "635654", "PostTypeId": "2", "Id": "29326275", "Score": "0", "CreationDate": "2015-03-29T06:22:17.583", "LastActivityDate": "2015-03-29T06:22:17.583"}, "bq_ids": {"n4140": {"so_29326097_29326353_0": {"section_id": 5801, "quality": 0.9736842105263158, "length": 37}}, "n3337": {"so_29326097_29326353_0": {"section_id": 5574, "quality": 0.9736842105263158, "length": 37}}, "n4659": {"so_29326097_29326353_0": {"section_id": 7260, "quality": 0.9736842105263158, "length": 37}}}, "29326990": {"ParentId": "29326097", "CommentCount": "0", "Body": "<p>The C++ standard defines the term \"undefined\" to (in effect) mean that the C++ standard does not place any constraints on what happens.</p>\n<p>A statement that a function does not throw exceptions means that the specification of the function does not include throwing any exceptions.</p>\n<p>Yes, it is possible for an implementer (of a compiler or an implementation of the standard library) to throw an exception in a circumstance that is undefined according to the standard.   After all, throwing an exception is a perfectly acceptable decision by an implementer if the standard does not constrain what is permitted to occur.</p>\n<p>However, that does not mean instances of undefined behaviour must result in exceptions being thrown.   Nor does it mean that a thrown exception indicates that some instance of undefined behaviour has occurred.</p>\n<p>It does mean that two different implementations (e.g. different versions of some vendor's product, or products from different vendors) can do completely different things in response to an instance of undefined behaviour.   One can throw an exception of some form.  Another can reformat the systems hard drive (although, fortunately, implementations that deliberately do this are rare).   Because the behaviour is undefined according to the standard, whatever happens is correct - at least according to the standard.</p>\n", "OwnerUserId": "4706785", "PostTypeId": "2", "Id": "29326990", "Score": "1", "CreationDate": "2015-03-29T08:12:00.900", "LastActivityDate": "2015-03-29T08:12:00.900"}});