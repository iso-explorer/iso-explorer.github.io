post_cb({"10256716": {"PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_10256545_10256716_0\">if we use the 2nd approach, is the variable ConstStrVal always initialized to \"some_string_value\" before it is actually used by any code in any case?</p>\n</blockquote>\n<p><strong>No</strong></p>\n<p>It depends on the value it's initialized to, and the order of initialization. <code>ConstStrVal</code> has a global constructor.</p>\n<p>Consider adding another global object with a constructor:</p>\n<pre><code>static const std::string ConstStrVal2(ConstStrVal);\n</code></pre>\n<p>The order is not defined by the language, and <code>ConstStrVal2</code>'s constructor may be called before <code>ConstStrVal</code> has been constructed.</p>\n<p>The initialization order can vary for a number of reasons, but it's often specified by your toolchain. Altering the order of linked object files could (for example) change the order of your image's initialization and then the error would surface.</p>\n<blockquote>\n<p id=\"so_10256545_10256716_1\">why is everybody using the 2nd approach?</p>\n</blockquote>\n<p>many people use other approaches for very good reasons\u2026</p>\n<blockquote>\n<p id=\"so_10256545_10256716_2\">Which is the best approach, 2 or 3?</p>\n</blockquote>\n<p>Number 3. You can also avoid multiple constructions like so:</p>\n<pre><code>class Demo {\npublic:  \n  static const std::string&amp; GetValue() {\n    // this is constructed exactly once, when the function is first called\n    static const std::string s(\"some_string_value\");\n    return s;\n  }  \n};  \n</code></pre>\n<p>caution: this is approach is still capable of the initialization problem seen in <code>ConstStrVal2(ConstStrVal)</code>. however, you have more control over initialization order and it's an easier problem to solve portably when compared to objects with global constructors.</p>\n", "LastActivityDate": "2012-04-21T06:22:33.703", "LastEditorUserId": "191596", "Id": "10256716", "CommentCount": "2", "CreationDate": "2012-04-21T06:07:32.290", "ParentId": "10256545", "Score": "4", "OwnerUserId": "191596", "LastEditDate": "2012-04-21T06:22:33.703"}, "10256693": {"PostTypeId": "2", "Body": "<p>Avoid using the preprocessor with C++.  Also, why would you have a string in a class, but need it in other classes?  I would re-evaluate your class design to allow better encapsulation.  If you absolutely need this global string then I would consider adding a globals.h/cpp module and then declare/define string there as:</p>\n<pre><code>const char* const kMyErrorMsg = \"This is my error message!\";\n</code></pre>\n", "LastActivityDate": "2012-04-21T06:03:42.983", "Id": "10256693", "CommentCount": "3", "CreationDate": "2012-04-21T06:03:42.983", "ParentId": "10256545", "Score": "0", "OwnerUserId": "1296840"}, "bq_ids": {"n4140": {"so_10256545_10256800_0": {"length": 86, "quality": 0.7610619469026548, "section_id": 7151}}, "n3337": {"so_10256545_10256800_0": {"length": 87, "quality": 0.7699115044247787, "section_id": 6895}}}, "10256800": {"PostTypeId": "2", "Body": "<p>Don't use preprocessor directives in C++, unless you're trying to achieve a holy purpose that can't possibly be achieved any other way.</p>\n<p>From the standard (3.6.2):</p>\n<blockquote>\n<p id=\"so_10256545_10256800_0\">Objects with static storage duration (3.7.1) shall be zero-initialized\n  (8.5) before any other initialization takes place. A reference with\n  static storage duration and an object of POD type with static storage\n  duration can be initialized with a constant expression (5.19); this is\n  called constant initialization. Together, zero-initialization and\n  constant initialization are called static initialization; all other\n  initialization is dynamic initialization. Static initialization shall\n  be performed before any dynamic initialization takes place. Dynamic\n  initialization of an object is either ordered or unordered.\n  Definitions of explicitly specialized class template static data\n  members have ordered initialization. Other class template static data\n  members (i.e., implicitly or explicitly instantiated specializations)\n  have unordered initialization. Other objects defined in namespace\n  scope have ordered initialization. Objects defined within a single\n  translation unit and with ordered initialization shall be initialized\n  in the order of their definitions in the translation unit. The order\n  of initialization is unspecified for objects with unordered\n  initialization and for objects defined in different translation units.</p>\n</blockquote>\n<p>So, the fate of 2 depends on whether your variable is static initialised or dynamic initialised. For instance, in your concrete example, if you use <code>const char * Demo::ConstStrVal = \"some_string_value\";</code> (better yet <code>const char Demo::ConstStrVal[]</code> if the value will stay constant in the program) you can be sure that it will be initialised no matter what. With a <code>std::string</code>, you can't be sure since it's not a POD type (I'm not dead sure on this one, but fairly sure).</p>\n<p>3rd method allows you to be sure and the method in Justin's answer makes sure that there are no unnecessary constructions. Though keep in mind that the static method has a hidden overhead of checking whether or not the variable is already initialised on every call. If you're returning a simple constant, just returning your value is definitely faster since the function will probably be inlined.</p>\n<p>All of that said, try to write your programs so as not to rely on static initialisation. Static variables are best regarded as a convenience, they aren't convenient any more when you have to juggle their initialisation orders.</p>\n", "LastActivityDate": "2012-04-21T07:20:22.440", "LastEditorUserId": "1103705", "Id": "10256800", "CommentCount": "1", "CreationDate": "2012-04-21T06:23:12.333", "ParentId": "10256545", "Score": "0", "OwnerUserId": "1103705", "LastEditDate": "2012-04-21T07:20:22.440"}, "10256623": {"PostTypeId": "2", "Body": "<p>In general, I (and many others) prefer to use functions to return values rather than variables, because functions give greater flexibility for future enhancement.  Remember that most of the time spent on a successful software project is maintaining and enhancing the code, not writing it in the first place.  It's hard to predict if your constant today might not be a compile time constant tomorrow.  Maybe it will be read from a configuration file some day. </p>\n<p>So I recommend approach 3 because it does what you want today and leaves more flexibility for the future. </p>\n", "LastActivityDate": "2012-04-21T05:54:20.813", "Id": "10256623", "CommentCount": "1", "CreationDate": "2012-04-21T05:54:20.813", "ParentId": "10256545", "Score": "1", "OwnerUserId": "712765"}, "10256545": {"ViewCount": "1618", "Body": "<p>In C++, if I want to define some <strong>non-local const string</strong> which can be used in different classes, functions, files, the approaches that I know are:</p>\n<ol>\n<li><p>use define directives, e.g.</p>\n<pre><code>#define STR_VALUE \"some_string_value\"\n</code></pre></li>\n<li><p>const class member variable, e.g.</p>\n<pre><code>class Demo {  \npublic:  \n  static const std::string ConstStrVal;  \n};  \n// then in cpp  \nstd::string Demo::ConstStrVal = \"some_string_value\";  \n</code></pre></li>\n<li><p>const class member function, e.g.</p>\n<pre><code>class Demo{  \npublic:  \n  static const std::string GetValue(){return \"some_string_value\";}  \n};  \n</code></pre></li>\n</ol>\n<p>Now what I am not clear is, if we use the 2nd approach, is the variable ConstStrVal always initialized to \"some_string_value\" before it is actually used by any code in any case? Im concerned about this because of the <a href=\"http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.14\" rel=\"nofollow\">\"static initialization order fiasco\"</a>. If this issue is valid, why is everybody using the 2nd approach? </p>\n<p>Which is the best approach, 2 or 3? I know that #define directives have no respect of scope, most people don't recommend it.</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "10256716", "Title": "is static const string member variable always initialized before used?", "CreationDate": "2012-04-21T05:39:43.380", "Id": "10256545", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-01-10T18:09:52.060", "LastEditorUserId": "100297", "LastActivityDate": "2013-01-10T18:09:52.060", "Score": "4", "OwnerUserId": "577324", "Tags": "<c++><const-string>", "AnswerCount": "4"}});