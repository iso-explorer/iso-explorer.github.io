post_cb({"19376232": {"ParentId": "19372952", "CommentCount": "0", "Body": "<p>If you want to test it properly, initialize the strings in a function so the initialization can be dynamic and use <code>strdup()</code> for that.</p>\n<pre><code>int\nmain(int argc, char **argv)\n{\n    char *d1 = strdup(\"hello\");\n    char *d2 = strdup(\"world\");\n\n    const char *s = d1;\n    char *const t = d2;\n\n    ...\n\n    free(d1);\n    free(d2);\n}\n</code></pre>\n<p>The d1 and d2 variables are mainly used so that the dynamic allocations can be properly freed using <code>free()</code> at the end. Also, as other answers suggest, always treat string literals as <code>const char *</code>.</p>\n", "OwnerUserId": "2876370", "PostTypeId": "2", "Id": "19376232", "Score": "1", "CreationDate": "2013-10-15T08:13:05.560", "LastActivityDate": "2013-10-15T08:13:05.560"}, "19372952": {"CommentCount": "0", "ViewCount": "862", "LastActivityDate": "2014-07-21T18:04:33.163", "Body": "<p>I know that <code>const char *</code> is a pointer to a const char, while <code>char *const</code> is a constant pointer to a char.\nI am testing this in the following code:</p>\n<pre><code>const char *s = \"hello\";    // Not permitted to modify the string \"hello\"\nchar *const t = \"world\";    // Not permitted to modify the pointer t\n\ns = \"hello2\";   // Valid\n// t = \"world2\";   // Invalid, gives compilation error\n\n// *(s + 1) = 'a';    // Invalid, gives compilation error\n*(t + 1) = 'a';       // Why does this not work?    \n</code></pre>\n<p>The last line does not give any error, but causes the program to terminate unexpectedly. Why is modifying the string pointed to by <code>t</code> not allowed?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "19372981", "FavoriteCount": "2", "Title": "Modifying a char *const string", "Id": "19372952", "Score": "2", "CreationDate": "2013-10-15T03:44:50.860", "Tags": "<c++><c><string><pointers><runtime-error>", "OwnerUserId": "1003492", "AnswerCount": "4"}, "19372979": {"ParentId": "19372952", "CommentCount": "0", "Body": "<p>Although string literals in C officially have a type of <code>char[]</code> (array of <code>char</code>, not <code>const</code>), the C standard specifically states that they must be treated as non-modifiable. Compilers tend to put string literals in a read-only segment, so attempting to modify them results in an access violation.</p>\n<p>String literals are described in section <code>6.4.5</code> of the C11 standard (ISO/IEC 9899:2011).</p>\n", "OwnerUserId": "2171689", "PostTypeId": "2", "Id": "19372979", "Score": "3", "CreationDate": "2013-10-15T03:47:34.737", "LastActivityDate": "2013-10-15T03:47:34.737"}, "19373039": {"ParentId": "19372952", "CommentCount": "0", "Body": "<p>You can bypass the compiler error by recast it as <code>char*</code>, as in <code>*((char*)s + 1) = 'a';</code> but as it was already estated in other answers, this is undefined behaviour and will probably result in Segmentation Fault because you are editing a string literal.</p>\n", "OwnerUserId": "156811", "PostTypeId": "2", "Id": "19373039", "Score": "1", "CreationDate": "2013-10-15T03:55:01.927", "LastActivityDate": "2013-10-15T03:55:01.927"}, "bq_ids": {"n4140": {"so_19372952_19372981_0": {"section_id": 5361, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_19372952_19372981_0": {"section_id": 5157, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_19372952_19372981_0": {"section_id": 6789, "quality": 0.8235294117647058, "length": 14}}}, "19372981": {"ParentId": "19372952", "LastEditDate": "2014-07-21T18:04:33.163", "CommentCount": "2", "CreationDate": "2013-10-15T03:47:48.160", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "PostTypeId": "2", "Id": "19372981", "Score": "7", "Body": "<p><code>t</code> is pointing to a <em>string literal</em> it is undefined behavior to modify a <em>string literal</em>. The C++ draft standard section <code>2.14.5</code> <em>String literals</em> paragraph <em>12</em> says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19372952_19372981_0\">Whether all string literals are distinct (that is, are stored in nonoverlapping objects) is implementation defined. <strong>The effect of attempting to modify a string literal is undefined</strong>.</p>\n</blockquote>\n<p>The relevant section from the C99 draft standard is <code>6.4.5</code> <em>String literals</em> paragraph <em>6</em> which says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19372952_19372981_1\">It is unspecified whether these arrays are distinct provided their elements have the\n  appropriate values. <strong>If the program attempts to modify such an array, the behavior is\n  undefined.</strong></p>\n</blockquote>\n<p>On a typical modern Unix platform you will find <em>string literals</em> in the read-only segment which would result in a access violation if we attempt to modify it. We can use <em>objdump</em> to inspect the read-only section as follows:</p>\n<pre><code>objdump -s -j .rodata\n</code></pre>\n<p>we can see in the following <a href=\"http://coliru.stacked-crooked.com/a/95f61a4fe4a19155\" rel=\"nofollow\">live example</a> that the string literal will indeed be found in the <em>read-only</em> section. Note that I had to add a <code>printf</code> otherwise the compiler would optimize out the string literal. Sample `<em>objdump</em> output:</p>\n<pre><code>Contents of section .rodata:\n 400668 01000200 776f726c 64002573 0a00      ....world.%s..\n</code></pre>\n<p>An alternative approach would be to have <code>t</code> point to an array with a copy of a <em>string literal</em> like so:</p>\n<pre><code>char r[] = \"world\";    \nchar *const t = r ;\n</code></pre>\n", "LastActivityDate": "2014-07-21T18:04:33.163"}});