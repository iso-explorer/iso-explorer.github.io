post_cb({"21920311": {"CommentCount": "3", "AcceptedAnswerId": "21920994", "PostTypeId": "1", "LastEditorUserId": "851835", "CreationDate": "2014-02-20T21:46:27.037", "LastActivityDate": "2014-02-21T07:47:19.117", "LastEditDate": "2014-02-20T22:04:16.343", "ViewCount": "341", "FavoriteCount": "2", "Title": "What's the rationale of the exceptions of temporary object lifetime expansion when bound to a reference?", "Id": "21920311", "Score": "6", "Body": "<p>In 12.2 of C++11 standard:</p>\n<blockquote>\n<p id=\"so_21920311_21920311_0\">The temporary to which the reference is bound or the temporary that is\n  the complete object of a subobject to which the reference is bound\n  persists for the lifetime of the reference except: </p>\n<ol>\n<li><p id=\"so_21920311_21920311_1\">A temporary bound\n  to a reference member in a constructor\u2019s ctor-initializer (12.6.2)\n  persists until the constructor exits. </p></li>\n<li><p id=\"so_21920311_21920311_2\">A temporary bound to a\n  reference parameter in a function call (5.2.2) persists until the\n  completion of the full-expression containing the call. </p></li>\n<li><p id=\"so_21920311_21920311_3\">The lifetime\n  of a temporary bound to the returned value in a function return\n  statement (6.6.3) is not extended; the temporary is destroyed at the\n  end of the full-expression in the return statement. </p></li>\n<li><p id=\"so_21920311_21920311_4\">A temporary\n  bound to a reference in a new-initializer (5.3.4) persists until the\n  completion of the full-expression containing the new-initializer.</p></li>\n</ol>\n</blockquote>\n<p>And there is an example of the last case in the standard: </p>\n<pre><code>struct S {\n  int mi; \n  const std::pair&lt;int,int&gt;&amp; mp;\n}; \nS a { 1,{2,3} };  // No problem.\nS* p = new S{ 1, {2,3} };  // Creates dangling reference\n</code></pre>\n<p>To me, <code>2. and 3.</code> make sense and easy to agree. But what's the reason bebind <code>1. and 4.</code>? The example looks just evil to me.</p>\n", "Tags": "<c++><c++11><object-lifetime><temporary-objects>", "OwnerUserId": "851835", "AnswerCount": "3"}, "21920952": {"ParentId": "21920311", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>How long do you want the temporary object to last? It has to be allocated somewhere.</p>\n<p>It can't be on the heap because it would leak; there is no applicable automatic memory management. It can't be static because there can be more than one. It must be on the stack. Then it either lasts until the end of the expression or the end of the function.</p>\n<p>Other temporaries in the expression, perhaps bound to function call parameters, are destroyed at the end of the expression, and persisting until the end of the function or \"<code>{}</code>\" scope would be an exception to the general rules. So by deduction and extrapolation of the other cases, the full-expression is the most reasonable lifetime.</p>\n<p>I'm not sure why you say this is no problem:</p>\n<pre><code>S a { 1,{2,3} };  // No problem.\n</code></pre>\n<p>The dangling reference is the same whether or not you use <code>new</code>.</p>\n<p>Instrumenting your program and running it in Clang produces these results:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct noisy {\n    int n;\n    ~noisy() { std::cout &lt;&lt; \"destroy \" &lt;&lt; n &lt;&lt; \"\\n\"; }\n};\n\nstruct s {\n    noisy const &amp; r;\n};\n\nint main() {\n    std::cout &lt;&lt; \"create 1 on stack\\n\";\n    s a {noisy{ 1 }};  // Temporary created and destroyed.\n\n    std::cout &lt;&lt; \"create 2 on heap\\n\";\n    s* p = new s{noisy{ 2 }};  // Creates dangling reference\n}\n</code></pre>\n<p>\u00a0</p>\n<pre><code>create 1 on stack\ndestroy 1\ncreate 2 on heap\ndestroy 2\n</code></pre>\n<p>The object bound to the class member reference does not have an extended lifetime.</p>\n<p>Actually I'm sure this is the subject of a known defect in the standard, but I don't have time to delve in right now\u2026</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2014-02-20T22:44:20.330", "Id": "21920952", "Score": "0", "CreationDate": "2014-02-20T22:19:57.813", "LastActivityDate": "2014-02-20T22:44:20.330"}, "21921073": {"ParentId": "21920311", "CommentCount": "0", "Body": "<p>The main thrust is that reference extension only occurs when the lifetime can be easily and deterministically determined, and this fact can be deduced as possible <strong>on the line of code where the temporary is created</strong>.</p>\n<p>When you call a function, it is extended to the end of the current line.  That is long enough, and easy to determine.</p>\n<p>When you create an automatic storage reference \"on the stack\", the scope of that automatic storage reference can be deterministically determined.  The temporary can be cleaned up at that point.  (Basically, create an anonymous automatic storage variable to store the temporary)</p>\n<p>In a <code>new</code> expression, the point of destruction cannot be statically determined at the point of creation.  It is whenever the <code>delete</code> occurs.  If we wanted the <code>delete</code> to (sometimes) destroy the temporary, then our reference \"binary\" implementation would have to be more complicated than a pointer, instead of less or equal.  It would sometimes own the referred to data, and sometimes not.  So that is a pointer, plus a <code>bool</code>.  And in C++ you don't pay for what you don't use.</p>\n<p>The same holds in a constructor, because you cannot know if the constructor was in a <code>new</code> or a stack allocation.  So any lifetime extension cannot be statically understood at the line in question.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "21921073", "Score": "2", "CreationDate": "2014-02-20T22:27:07.133", "LastActivityDate": "2014-02-20T22:27:07.133"}, "21920994": {"ParentId": "21920311", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>As with many things in C and C++, I think this boils down to what can be reasonably (and efficiently) implemented.</p>\n<p>Temporaries are generally allocated on the stack, and code to call their constructors and destructors are emitted into the function itself.  So if we expand your first example into what the compiler is actually doing, it would look something like:</p>\n<pre><code>  struct S {\n    int mi;\n    const std::pair&lt;int,int&gt;&amp; mp;\n  };\n\n  // Case 1:\n  std::pair&lt;int,int&gt; tmp{ 2, 3 };\n  S a { 1, tmp };\n</code></pre>\n<p>The compiler can easily extend the life of the <code>tmp</code> temporary long enough to keep \"S\" valid because we know that \"S\" will be destroyed before the end of the function.</p>\n<p>But this doesn't work in the \"new S\" case:</p>\n<pre><code>  struct S {\n    int mi;\n    const std::pair&lt;int,int&gt;&amp; mp;\n  };\n\n  // Case 2:\n  std::pair&lt;int,int&gt; tmp{ 2, 3 };\n  // Whoops, this heap object will outlive the stack-allocated\n  // temporary!\n  S* p = new S{ 1, tmp };\n</code></pre>\n<p>To avoid the dangling reference, we would need to allocate the temporary on the heap instead of the stack, something like:</p>\n<pre><code>   // Case 2a -- compiler tries to be clever?\n   // Note that the compiler won't actually do this.\n   std::pair&lt;int,int&gt; tmp = new std::pair&lt;int,int&gt;{ 2, 3 };\n   S* p = new S{ 1, tmp };\n</code></pre>\n<p>But then a corresponding <code>delete p</code> would need to free this heap memory!  This is quite contrary to the behavior of references, and would break anything that uses normal reference semantics:</p>\n<pre><code>  // No way to implement this that satisfies case 2a but doesn't\n  // break normal reference semantics.\n  delete p;\n</code></pre>\n<p>So the answer to your question is: the rules are defined that way because it sort of the only practical solution given C++'s semantics around the stack, heap, and object lifetimes.</p>\n<p><strong>WARNING</strong>: @Potatoswatter notes below that this doesn't seem to be implemented consistently across C++ compilers, and therefore is non-portable at best for now.  See his example for how Clang doesn't do what the standard seems to mandate here.  He also says that the situation \"may be more dire than that\" -- I don't know exactly what this means, but it appears that in practice this case in C++ has some uncertainty surrounding it.</p>\n", "OwnerUserId": "77070", "LastEditorUserId": "153285", "LastEditDate": "2014-02-21T07:47:19.117", "Id": "21920994", "Score": "5", "CreationDate": "2014-02-20T22:22:16.753", "LastActivityDate": "2014-02-21T07:47:19.117"}, "bq_ids": {"n4140": {"so_21920311_21920311_2": {"section_id": 382, "quality": 0.9230769230769231, "length": 12}, "so_21920311_21920311_4": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}, "so_21920311_21920311_0": {"section_id": 382, "quality": 0.9285714285714286, "length": 13}, "so_21920311_21920311_1": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}, "so_21920311_21920311_3": {"section_id": 382, "quality": 0.8823529411764706, "length": 15}}, "n3337": {"so_21920311_21920311_2": {"section_id": 373, "quality": 0.9230769230769231, "length": 12}, "so_21920311_21920311_4": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}, "so_21920311_21920311_0": {"section_id": 373, "quality": 0.9285714285714286, "length": 13}, "so_21920311_21920311_1": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}, "so_21920311_21920311_3": {"section_id": 373, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_21920311_21920311_2": {"section_id": 397, "quality": 0.9230769230769231, "length": 12}, "so_21920311_21920311_4": {"section_id": 397, "quality": 0.9090909090909091, "length": 10}, "so_21920311_21920311_0": {"section_id": 397, "quality": 0.9285714285714286, "length": 13}, "so_21920311_21920311_3": {"section_id": 397, "quality": 0.8823529411764706, "length": 15}}}});