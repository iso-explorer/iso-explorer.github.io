post_cb({"bq_ids": {"n4140": {"so_34834125_34834157_0": {"length": 13, "quality": 0.8125, "section_id": 1395}, "so_34834125_34834389_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 1395}, "so_34834125_34834157_1": {"length": 7, "quality": 0.7, "section_id": 1396}}, "n3337": {"so_34834125_34834157_0": {"length": 13, "quality": 0.8125, "section_id": 1389}, "so_34834125_34834389_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 1389}, "so_34834125_34834157_1": {"length": 7, "quality": 0.7, "section_id": 1390}}, "n4659": {"so_34834125_34834157_0": {"length": 11, "quality": 0.6875, "section_id": 1513}, "so_34834125_34834389_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 1513}, "so_34834125_34834157_1": {"length": 7, "quality": 0.7, "section_id": 1514}}}, "34834389": {"Id": "34834389", "PostTypeId": "2", "Body": "<p>Warning: extreme language-lawyering follows.</p>\n<p>The wording of <a href=\"http://wg21.link/N4567\" rel=\"nofollow noreferrer\">the most recent draft of the standard</a> puts it this way in [alg.sorting]p3:</p>\n<blockquote>\n<p id=\"so_34834125_34834389_0\">For all algorithms that take <code>Compare</code>, there is a version that uses <code>operator&lt;</code> instead. That is, <code>comp(*i, *j) != false</code> defaults to <code>*i &lt; *j != false</code>. For algorithms other than those described in 25.4.3, comp\n  shall induce a strict weak ordering on the values.</p>\n</blockquote>\n<p>By using the word \"shall\", the standard is <a href=\"https://stackoverflow.com/a/25300537/734069\">implicitly stating that violating it leads to undefined behavior</a>.</p>\n<p>Whether this requires that the given function impose a SWO for all possible values or just for the values given to the algorithm is not clear from the standard. However, since the restriction is stated in a paragraph that is talking about those specific algorithms, it's not unreasonable to assume that it is refering to the range of values provided to the algorithm.</p>\n<p>Otherwise, the default <code>operator&lt;</code> could not impose SWO for <code>float</code>s, thanks to NaN.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-17T03:10:02.937", "Score": "4", "CreationDate": "2016-01-17T02:15:56.757", "ParentId": "34834125", "CommentCount": "6", "OwnerUserId": "734069", "LastEditDate": "2017-05-23T11:44:58.113"}, "34834204": {"Id": "34834204", "PostTypeId": "2", "Body": "<p>This has already been asked and kind of answered in <a href=\"https://stackoverflow.com/questions/18291620/why-will-stdsort-crash-if-the-comparison-function-is-not-as-operator\">Why will std::sort crash if the comparison function is not as operator &lt;?</a>. </p>\n<p>At least the person in that thread who asked the question claims to have received an <strong>exception</strong>. </p>\n<p>To summarize here from the <strong>standard</strong>, I have highlighted the part relevant to the question. Now the opposite of \"work correctly\" could be interpreted as  \"undefined behavior\".</p>\n<blockquote id=\"so_34834125_34834204_0\">\n<h2>25.3 Sorting and related operations [alg.sorting]</h2>\n<ol>\n<li>All the operations in 25.3 have two versions: one that takes a function object of type Compare and one that uses an\n  operator&lt;.</li>\n<li>Compare is used as a function object which returns true if the first argument is less than the second, and false\n  otherwise. Compare comp is used throughout for algorithms assuming an ordering relation. It is assumed that comp\n  will not apply any non-constant function through the dereferenced iterator.</li>\n<li>For all algorithms that take Compare, there is a version that uses operator&lt; instead. That is, comp (*i, *j) !=\n  false defaults to *i &lt; *j != false. For algorithms other than those described in 25.3.3 <strong>to work correctly, comp has\n  to induce a strict weak ordering on the values.</strong></li>\n<li>The term strict refers to the requirement of an irreflexive relation (!comp (x, x) for all x), and the term weak to\n  requirements that are not as strong as those for a total ordering, but stronger than those for a partial ordering. If we\n  define equiv(a, b) as !comp (a, b) &amp;&amp; !comp (b, a), then the requirements are that comp and equiv both be\n  transitive relations:\n  \n  <ul>\n<li>comp (a, b) &amp;&amp; comp (b, c) implies comp (a, c)</li>\n<li>equiv(a, b) &amp;&amp; equiv(b, c) implies equiv(a, c) [ Note: Under these   conditions, it can be shown that\n  \n  <ol>\n<li>equiv is an equivalence relation</li>\n<li>comp induces a well-defined relation on the equivalence classes determined by equiv</li>\n<li>The induced relation is a strict total ordering. \u2014end note ]</li>\n</ol></li>\n</ul></li>\n</ol>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-17T13:56:28.143", "Score": "1", "CreationDate": "2016-01-17T01:45:53.177", "ParentId": "34834125", "CommentCount": "2", "OwnerUserId": "2070994", "LastEditDate": "2017-05-23T12:31:27.133"}, "34834157": {"Id": "34834157", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_34834125_34834157_0\"><strong>[alg.sorting]/3</strong> For algorithms other than those described in 25.4.3 to work\n  correctly, <code>comp</code> has to induce a strict weak ordering on the values.</p>\n<p id=\"so_34834125_34834157_1\"><strong>[alg.sorting]/4</strong> The term <em>strict</em> refers to the requirement of an irreflexive relation (<code>!comp(x, x)</code> for all <code>x</code>) ...</p>\n</blockquote>\n<p>Your comparison predicate is not a strict weak ordering.</p>\n", "LastActivityDate": "2016-01-17T01:37:42.997", "CommentCount": "4", "CreationDate": "2016-01-17T01:37:42.997", "ParentId": "34834125", "Score": "1", "OwnerUserId": "1670129"}, "34834125": {"ViewCount": "342", "Body": "<p>Consider this code:</p>\n<pre><code>std::sort(vec.begin(), vec.end(),\n    [](const Foo&amp; lhs, const Foo&amp; rhs) { return !(lhs &lt; rhs); }\n);\n</code></pre>\n<p>If lhs == rhs, both lambda(lhs, rhs) and lambda(rhs, lhs) will return true, which violates the requirement to provide <em>strict</em> weak ordering. However, does the standard explicitly mark passing such a comparator as undefined behavior?</p>\n", "AcceptedAnswerId": "34834389", "Title": "std::sort - is passing a faulty comparator undefined behavior?", "CreationDate": "2016-01-17T01:33:02.707", "Id": "34834125", "CommentCount": "1", "LastEditDate": "2016-01-17T02:21:43.037", "PostTypeId": "1", "LastEditorUserId": "2478832", "LastActivityDate": "2016-01-17T13:56:28.143", "Score": "4", "OwnerUserId": "2478832", "Tags": "<c++><stl><undefined-behavior>", "AnswerCount": "3"}});