post_cb({"33966029": {"ParentId": "33965966", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Generally compilers are not obligated to do NRVO (Named Return Value Optimization) aka copy elision even if the certain criteria that allow it are met. Nor a program must be depended on such optimizations as it makes it effectively non portable.</p>\n<p>Now, as far as it concerns the first case, the answer is yes, the compiler is permitted to optimize away the copy of the vector. In particular this case falls in the following wording of the standard <em>12.8/p31.1 Copying and moving class objects [class.copy]</em>:</p>\n<blockquote>\n<p id=\"so_33965966_33966029_0\">... elision of copy/move operations, called copy elision, is permitted in\n  the following circumstances (which may be combined to eliminate\n  multiple copies): </p>\n<p id=\"so_33965966_33966029_1\">(31.1) \u2014 in a return statement in a function with a\n  class return type, when the expression is the name of a nonvolatile\n  automatic object (other than a function parameter or a variable\n  introduced by the exceptiondeclaration of a handler (15.3)) with the\n  same type (ignoring cv-qualification) as the function return type, the\n  copy/move operation can be omitted by constructing the automatic\n  object directly into the function\u2019s return value.</p>\n</blockquote>\n<p>Also, from C++11 and beyond <code>std::vector</code> has move facilities and actually the <code>vector</code> is going to be moved.</p>\n<p>As far as it concerns the second case the answer is no. And after all there's no need to, since you pass a reference to the vector. That is, you pass an alias of the vector (i.e. the object itself).</p>\n", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "LastEditDate": "2015-11-27T23:58:34.063", "Id": "33966029", "Score": "0", "CreationDate": "2015-11-27T23:34:31.683", "LastActivityDate": "2015-11-27T23:58:34.063"}, "bq_ids": {"n4140": {"so_33965966_33966029_1": {"section_id": 480, "quality": 0.7804878048780488, "length": 32}, "so_33965966_33966029_0": {"section_id": 480, "quality": 1.0, "length": 14}}, "n3337": {"so_33965966_33966029_1": {"section_id": 471, "quality": 0.7804878048780488, "length": 32}, "so_33965966_33966029_0": {"section_id": 471, "quality": 1.0, "length": 14}}, "n4659": {"so_33965966_33966029_0": {"section_id": 502, "quality": 1.0, "length": 14}, "so_33965966_33966029_1": {"section_id": 502, "quality": 0.9024390243902439, "length": 37}}}, "33965966": {"CommentCount": "5", "AcceptedAnswerId": "33966029", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-11-27T23:26:11.497", "LastActivityDate": "2015-11-27T23:58:34.063", "LastEditDate": "2017-05-23T12:07:22.943", "ViewCount": "109", "FavoriteCount": "0", "Title": "GCC optimize return value", "Id": "33965966", "Score": "1", "Body": "<p>This question is related to <a href=\"https://stackoverflow.com/questions/26193575/function-returning-value-vs-modifying-value-passed-by-reference?rq=1\">Function returning value vs modifying value passed by reference</a>. I want to know if gcc will optimize the following the same way. Imagine the two functions do the same thing:</p>\n<p>Return:</p>\n<pre><code>vector&lt;int&gt; f(...)\n{\n    vector&lt;int&gt; r;\n    ...\n    return r;\n}\n</code></pre>\n<p>Pass by reference:</p>\n<pre><code>void f(vector&lt;int&gt; &amp;r, ...)\n{\n    ...\n}\n\nvector&lt;int&gt; r;\nf(r, ...)\n</code></pre>\n<p>Pass by reference occurs frequently in (performance critical) GMP functions. </p>\n", "Tags": "<c++><gcc><return-value><pass-by-reference>", "OwnerUserId": "3163618", "AnswerCount": "1"}});