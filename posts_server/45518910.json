post_cb({"45546008": {"ParentId": "45518910", "CommentCount": "1", "Body": "<p>Instantiating a class template instantiates the declarations of its member function templates (<a href=\"http://eel.is/c++draft/temp.inst#2\" rel=\"nofollow noreferrer\">[temp.inst]/2</a>). I.e. we're looking at the declaration</p>\n<pre><code>template &lt;typename... Args&gt;\nauto entry(Args&amp;&amp;... args)\n    -&gt; decltype(std::declval&lt;Incomplete&amp;&gt;().operator()(std::declval&lt;Args&amp;&amp;&gt;()...));\n</code></pre>\n<p>Now consider <a href=\"http://eel.is/c++draft/temp.res#10\" rel=\"nofollow noreferrer\">[temp.res]/10</a>:</p>\n<blockquote>\n<p id=\"so_45518910_45546008_0\">If a name does not depend on a template-parameter (as defined in 14.6.2), a declaration (or set of declarations)\n  for that name shall be in scope at the point where the name appears in the template definition;</p>\n</blockquote>\n<p>And indeed, the name <code>operator()</code> does not depend on a template parameter. It's neither type- nor value-dependent, and it's not a dependent name, either. Clearly, there is no declaration in scope, hence the declaration is ill-formed, no diagnostic required. </p>\n<p>By contrast, your first snippet does not necessitate the lookup of a name within <code>Incomplete</code>. The transformation of <code>x(...)</code>, where <code>x</code> is of class type, to <code>x.operator()(...)</code> happens only after <code>operator()</code> is looked up within x\u2014<a href=\"http://eel.is/c++draft/over.call\" rel=\"nofollow noreferrer\">[over.call]</a>:</p>\n<blockquote>\n<p id=\"so_45518910_45546008_1\">Thus, a call <code>x(arg1,...)</code> is interpreted as x.operator()(arg1, ...) for\n  a class object x of type T <strong>if <code>T\u200b::\u200boperator()(T1, T2, T3)</code> exists and\n  if the operator is selected as the best match function by the overload\n  resolution mechanism</strong> ([over.match.best]).</p>\n</blockquote>\n<p>This is different from the paragraph that made your second code ill-formed: [temp.res]/10 says that <em>some declaration(s)</em> must be in scope, and that the name is bound to those declarations. The above transformation requires that the argument types (and also the number...) are known such that we can uniquely determine one <code>operator()</code> to be called; that is, we don't just insert <code>.operator()</code>, but always simultaneously identify which operator function is called.  We can find further confirmation of this interpretation in [temp.dep]:</p>\n<blockquote>\n<p id=\"so_45518910_45546008_2\">If an operand of an operator is a type-dependent expression, the operator also denotes a dependent name. Such names are unbound and are looked up at the point of the template instantiation [...]</p>\n</blockquote>\n<p>The <code>operator()</code>'s argument operands are clearly type-dependent. </p>\n", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "45546008", "Score": "4", "CreationDate": "2017-08-07T11:37:29.457", "LastActivityDate": "2017-08-07T11:37:29.457"}, "bq_ids": {"n4140": {"so_45518910_45546008_2": {"section_id": 188, "quality": 1.0, "length": 16}, "so_45518910_45546008_0": {"section_id": 177, "quality": 0.9411764705882353, "length": 16}, "so_45518910_45546008_1": {"section_id": 662, "quality": 0.8947368421052632, "length": 17}}, "n3337": {"so_45518910_45546008_2": {"section_id": 182, "quality": 1.0, "length": 16}, "so_45518910_45546008_0": {"section_id": 171, "quality": 0.9411764705882353, "length": 16}, "so_45518910_45546008_1": {"section_id": 652, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_45518910_45546008_2": {"section_id": 193, "quality": 1.0, "length": 16}, "so_45518910_45546008_0": {"section_id": 182, "quality": 0.9411764705882353, "length": 16}, "so_45518910_45546008_1": {"section_id": 690, "quality": 0.8947368421052632, "length": 17}}}, "45518910": {"CommentCount": "3", "AcceptedAnswerId": "45546008", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2017-08-05T06:15:41.363", "LastActivityDate": "2017-08-07T11:40:57.763", "LastEditDate": "2017-08-07T11:40:57.763", "ViewCount": "102", "FavoriteCount": "3", "Title": "Special behavior for decltype of call operator for incomplete types", "Id": "45518910", "Score": "6", "Body": "<p>I've been struggling with a compilation issue, and have been able to shrink the problem down to a small code segment.</p>\n<p>To set the stage, I'm trying to do CRTP, where the base method calls another in the derived class. The complication is, I want to use trailing return types to get the type of forwarding directly to the the Derived class's method. This always fails to compile <strong>unless</strong> I forward to the call operator in the derived class.</p>\n<p>This compiles:</p>\n<pre><code>#include &lt;utility&gt;\n\nstruct Incomplete;\n\ntemplate &lt;typename Blah&gt;\nstruct Base\n{\n    template &lt;typename... Args&gt;\n    auto entry(Args&amp;&amp;... args)\n        -&gt; decltype(std::declval&lt;Blah&amp;&gt;()(std::declval&lt;Args&amp;&amp;&gt;()...));\n};\n\nvoid example()\n{\n    Base&lt;Incomplete&gt; derived;\n}\n</code></pre>\n<p>While this does not: (note comment for the only difference)</p>\n<pre><code>#include &lt;utility&gt;\n\nstruct Incomplete;\n\ntemplate &lt;typename Blah&gt;\nstruct Base\n{\n    template &lt;typename... Args&gt;\n    auto entry(Args&amp;&amp;... args)\n        -&gt; decltype(std::declval&lt;Blah&amp;&gt;().operator()(std::declval&lt;Args&amp;&amp;&gt;()...));\n        //             I only added this ^^^^^^^^^^^\n};\n\nvoid example()\n{\n    Base&lt;Incomplete&gt; derived;\n}\n</code></pre>\n<p>The error I get:</p>\n<pre><code>&lt;source&gt;: In instantiation of 'struct Base&lt;Incomplete&gt;':\n15 : &lt;source&gt;:15:22:   required from here\n10 : &lt;source&gt;:10:58: error: invalid use of incomplete type 'struct Incomplete'\n         -&gt; decltype(std::declval&lt;Blah&amp;&gt;().operator()(std::declval&lt;Args&amp;&amp;&gt;()...));\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n</code></pre>\n<p>There seems to be some special behavior going on during resolution of the decltype in the Derived class. Is there something in the standard that would explain this?</p>\n<p>EDIT: Made an even bigger simplification</p>\n<p>PS: compiling example on godbolt: <a href=\"https://godbolt.org/g/St2gYC\" rel=\"nofollow noreferrer\">https://godbolt.org/g/St2gYC</a></p>\n", "Tags": "<c++><templates><operator-overloading><language-lawyer><name-lookup>", "OwnerUserId": "436025", "AnswerCount": "1"}});