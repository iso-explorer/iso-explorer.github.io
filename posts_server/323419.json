post_cb({"323438": {"Id": "323438", "PostTypeId": "2", "Body": "<p>Not a script, but you can try this command-line open source tool: <a href=\"http://sourceforge.net/projects/nloc/\" rel=\"nofollow noreferrer\">NLOC</a></p>\n", "OwnerDisplayName": "schnaader", "LastActivityDate": "2008-11-27T10:40:12.163", "Score": "1", "CreationDate": "2008-11-27T10:40:12.163", "ParentId": "323419", "CommentCount": "2", "OwnerUserId": "34065"}, "365808": {"Id": "365808", "PostTypeId": "2", "Body": "<p><a href=\"http://www.locmetrics.com/\" rel=\"nofollow noreferrer\" title=\"Locmetrics\">Locmetrics</a> works well.</p>\n", "OwnerDisplayName": "Steve Fallows", "LastActivityDate": "2008-12-13T21:59:07.110", "Score": "1", "CreationDate": "2008-12-13T21:59:07.110", "ParentId": "323419", "CommentCount": "1", "OwnerUserId": "18882"}, "323419": {"ViewCount": "2577", "Body": "<p>Do you know a simple script to count NLOCs (netto lines of code). The script should count lines of C Code. It should not count empty lines or lines with just braces. But it doesn't need to be overly exact either.</p>\n", "AcceptedAnswerId": "365787", "Title": "Simple script to count NLOC?", "CreationDate": "2008-11-27T10:28:08.240", "Id": "323419", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-07-17T21:44:04.780", "LastEditorDisplayName": "J.F. Sebastian", "OwnerDisplayName": "Markus Schnell", "LastEditorUserId": "64046", "LastActivityDate": "2015-07-17T21:44:04.780", "Score": "5", "OwnerUserId": "20668", "Tags": "<c++><c><metrics><lines-of-code>", "AnswerCount": "14"}, "365787": {"Body": "<p>I would do that using <strong>awk</strong> &amp; <strong>cpp</strong> (preprocessor) &amp; <strong>wc</strong> . awk removes all braces and blanks, the preprocessor removes all comments and wc counts the lines:</p>\n<pre><code>find . -name \\*.cpp -o -name \\*.h | xargs -n1 cpp -fpreprocessed -P | \n    awk '!/^[{[:space:]}]*$/' | wc -l\n</code></pre>\n<p>If you want to have comments included:</p>\n<pre><code>find . -name \\*.cpp -o -name \\*.h | xargs awk '!/^[{[:space:]}]*$/' | wc -l\n</code></pre>\n", "CreationDate": "2008-12-13T21:42:25.363", "ParentId": "323419", "CommentCount": "0", "LastEditDate": "2008-12-13T21:59:38.123", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2008-12-13T21:59:38.123", "LastEditorUserId": "34509", "Id": "365787", "OwnerDisplayName": "litb", "Score": "6", "OwnerUserId": "34509"}, "bq_ids": {"n4140": {"so_323419_324732_1": {"length": 21, "quality": 0.875, "section_id": 5313}, "so_323419_324732_2": {"length": 42, "quality": 0.9767441860465116, "section_id": 5313}, "so_323419_324732_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 5313}}, "n3337": {"so_323419_324732_1": {"length": 21, "quality": 0.875, "section_id": 5110}, "so_323419_324732_2": {"length": 42, "quality": 0.9767441860465116, "section_id": 5110}, "so_323419_324732_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 5110}}, "n4659": {"so_323419_324732_1": {"length": 18, "quality": 0.75, "section_id": 6737}, "so_323419_324732_2": {"length": 42, "quality": 0.9767441860465116, "section_id": 6737}, "so_323419_324732_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 6737}}}, "324732": {"Body": "<p>I have a program called <code>scc</code> that strips C comments (and C++ comments, though with C99 they're the same).  Apply that plus a filter to remove blank lines and, if so desired, lines containing just open and close braces, to generate the line counts.   I've used that on internal projects - not needed to discount open/close braces.  Those scripts were more complex, comparing the source code for two different versions of a substantial project stored in ClearCase.  They also did statistics on files added and removed, and on lines added and removed from common files, etc.</p>\n<p>Not counting braces makes quite a difference:</p>\n<pre><code>Black JL: co -q -p scc.c | scc | sed '/^[       ]*$/d' | wc -l\n     208\nBlack JL: co -q -p scc.c | scc | sed '/^[       {}]*$/d' | wc -l\n     144\nBlack JL: co -p -q scc.c | wc -l\n     271\nBlack JL:\n</code></pre>\n<p>So, 144 lines under your rules; 208 counting open and close brace lines; 271 counting everything.</p>\n<p>Lemme know if you want the code for <code>scc</code> (send email to first dot last at gmail dot com).  It's 13 KB of gzipped tar file including man page, torture test, and some library files.</p>\n<hr>\n<p>@litb commented that '<code>cpp -fpreprocessed -P file</code>' handles stripping of\ncomments.  It mostly does.  However, when I run it on the stress test\nfor SCC, it complains when (in my opinion) it should not:</p>\n<pre><code>SCC has been trained to handle 'q' single quotes in most of\nthe aberrant forms that can be used. '\\0', '\\', '\\'', '\\\\\nn' (a valid variant on '\\n'), because the backslash followed\nby newline is elided by the token scanning code in CPP before\nany other processing occurs.\n</code></pre>\n<p>When the CPP from GCC 4.3.2 processes this, it complains (warns):</p>\n<pre><code>SCC has been trained to handle 'q' single quotes in most of\n&lt;stdin&gt;:2:56: warning: missing terminating ' character\nthe aberrant forms that can be used. '\\0', '\\', '\\'', '\\\\\n&lt;stdin&gt;:3:27: warning: missing terminating ' character\nn' (a valid variant on '\\n'), because the backslash followed\nby newline is elided by the token scanning code in CPP before\nany other processing occurs.\n</code></pre>\n<p>Section 5.1.1.2 Translation Phases of the C99 standard says:</p>\n<blockquote>\n<p id=\"so_323419_324732_0\">The precedence among the syntax rules of translation is specified by the following phases.(<em>Footnote 5</em>)</p>\n<ol>\n<li><p id=\"so_323419_324732_1\">Physical source file multibyte characters are mapped, in an implementation-defined\n  manner, to the source character set (introducing new-line characters for\n  end-of-line indicators) if necessary. Trigraph sequences are replaced by\n  corresponding single-character internal representations.</p></li>\n<li><p id=\"so_323419_324732_2\">Each instance of a backslash character () immediately followed by a new-line\n  character is deleted, splicing physical source lines to form logical source lines.\n  Only the last backslash on any physical source line shall be eligible for being part\n  of such a splice. A source file that is not empty shall end in a new-line character,\n  which shall not be immediately preceded by a backslash character before any such\n  splicing takes place.</p></li>\n</ol>\n<p id=\"so_323419_324732_3\">Footnote 5 is:</p>\n<p id=\"so_323419_324732_4\">(5) Implementations shall behave as if these separate phases occur, even\n  though many are typically folded together in practice.</p>\n</blockquote>\n<p>Consequently, in my view, CPP is mishandling phase two in the example text.  Or, at least, the warning is not what I want - the construct is valid C and it is not self-evident that the warning is warranted.</p>\n<p>Granted, it is an edge case, and extra warnings are permitted.  But it would annoy the living daylights out of me.  If I didn't have my own, possibly better tool for the job, then using '<code>cpp -fpreprocessed -P</code>' would do - it is an extreme edge case that I'm complaining about (and, it might be legitimate to argue that it is more likely that there is a problem than not -- though a better heuristic would observe that the line was spliced and the result was a legitimate single character constant and therefore the complaint should be suppressed; if the result was not a legitimate single character constant, then the complaint should be produced.  (On my test case - admittedly a torture test - CPP yields 13 problems, mostly related to the one I'm complaining about, where SCC correctly yields 2.)</p>\n<p>(I observe that the '<code>-P</code>' manages to suppress a '<code>#line</code>' directive in the output that appears when the option is omitted.)</p>\n</hr>", "CreationDate": "2008-11-27T22:15:20.370", "ParentId": "323419", "CommentCount": "2", "LastEditDate": "2008-12-13T23:23:05.940", "PostTypeId": "2", "LastEditorDisplayName": "Jonathan Leffler", "LastActivityDate": "2008-12-13T23:23:05.940", "LastEditorUserId": "15168", "Id": "324732", "OwnerDisplayName": "Jonathan Leffler", "Score": "0", "OwnerUserId": "15168"}, "365685": {"Id": "365685", "PostTypeId": "2", "Body": "<p>The following script will get count of all file matching a pattern in a given directory.</p>\n<p># START OF SCRIPT</p>\n<p>var str files<br>\nvar str dir</br></p>\n<p>set $files = \"*.cpp\"        # &lt;===================== Set your file name pattern here. <br>\nset $dir = \"C:/myproject\"   # &lt;===================== Set your project directory here.</br></p>\n<p># Get the list of files in variable fileList.<br>\nvar str fileList<br>\nfind -rn files($files) dir($dir) &gt; $fileList</br></br></p>\n<p># Declare variables where we will save counts of individual files.<br>\nvar int c   # all lines<br>\nvar int nb  # non-blank lines<br/></br></br></p>\n<p># Declare variables where we will save total counts for all files.<br>\nvar int totalc  # sum-total of all lines<br>\nvar int totalnb # sum-total of all non-blank lines</br></br></p>\n<p># Declare variable where we will store file count.<br>\nvar int fileCount</br></p>\n<p># We will store the name of the file we are working on currently, in the following.<br>\nvar str file</br></p>\n<p># Go thru the $fileList one by one file.<br>\nwhile ($fileList&lt;&gt;\"\")<br>\ndo<br>\n  # Extract the next file.<br>\n  lex \"1\" $fileList &gt;$file<br/></br></br></br></br></p>\n<p># Check if this is a flat file. We are not interested in directories.<br>\n  af $file &gt;null    # We don't want to see the output.<br>\n        # We only want to set the $ftype variable.<br>\n  if ($ftype==\"f\")<br>\n  do<br>\n    # Yes, this is a flat file.<br/></br></br></br></br></br></p>\n<pre><code> # Increment file count.&lt;br&gt;\nset $fileCount = $fileCount+1&lt;br&gt;\n\n# Collect the content of $file in $content&lt;br&gt;\nvar str content # Content of one file at a time&lt;br&gt;\nrepro $file &gt;$content&lt;br&gt;\n\n# Get count and non-blank count.&lt;br&gt;\nset $c={len -e $content}&lt;br&gt;\nset $nb={len $content}&lt;br&gt;\n\necho -e \"File: \" $file \", Total Count: \" $c \", Non-blank Count: \" $nb&lt;br&gt;\n\n# Update total counts.&lt;br&gt;\nset $totalc = $totalc + $c&lt;br&gt;\nset $totalnb = $totalnb + $nb&lt;br&gt;\n</code></pre>\n<p>done<br>\n  endif<br/></br></p>\n<p>done<br/></p>\n<h1>Show sum-totals<br/></h1>\n<p>echo \"**********************************************************************************************************************************\"<br>\necho \"Total Count of all lines:\\t\" $totalc \",\\tTotal Count of non-blank lines:\\t\" $totalnb \", Total files: \" $fileCount<br>\necho \"**********************************************************************************************************************************\"<br/></br></br></p>\n<p># END OF SCRIPT</p>\n<p>If you want line counts in files modified in year 2008 only, add ($fmtime &gt;= \"2008\"), etc.</p>\n<p>If you don't have biterscripting, get it from .com .</p>\n", "OwnerDisplayName": "Mike", "LastActivityDate": "2008-12-13T20:35:47.790", "Score": "0", "CreationDate": "2008-12-13T20:35:47.790", "ParentId": "323419", "CommentCount": "0"}, "365722": {"Id": "365722", "PostTypeId": "2", "Body": "<p>If the comments can still be in, the standard unix tool are sufficent:</p>\n<pre><code>grep  -x -v \"[[:space:]}{]*\" files.c  | wc\n</code></pre>\n", "OwnerDisplayName": "flolo", "LastActivityDate": "2008-12-13T20:59:48.710", "Score": "1", "CreationDate": "2008-12-13T20:59:48.710", "ParentId": "323419", "CommentCount": "0", "OwnerUserId": "36472"}, "365856": {"Body": "<p>Here's a simple Perl script <a href=\"http://gist.github.com/35562\" rel=\"nofollow noreferrer\">eLOC.pl</a>:</p>\n<pre><code>#!/usr/bin/perl -w\n# eLOC - Effective Lines of Code Counter\n# JFS (2005)\n#\n# $ perl eLOC.pl --help\n#\nuse strict;\nuse warnings;\nuse sigtrap;\nuse diagnostics;\n\nuse warnings::register;\nno warnings __PACKAGE__;\nsub DEBUG { 0 }\n\nuse English qw( -no_match_vars ) ;  # Avoids regex performance penalty\nuse Getopt::Long qw(:config gnu_getopt);\nuse File::DosGlob 'glob';\nuse Pod::Usage;\n\n\nour $VERSION = '0.01';\n\n# globals\nuse constant NOTFILENAME =&gt; undef;\nmy %counter = ( \n    'PHYS'          =&gt; 0, \n    'ELOC'          =&gt; 0, \n    'PURE_COMMENT'  =&gt; 0,\n    'BLANK'         =&gt; 0,\n    'LLOC'          =&gt; 0,\n    'INLINE_COMMENT'=&gt; 0,\n    'LOC'           =&gt; 0,\n);\nmy %header = (\n    \"eloc\"      =&gt;  \"eloc\",\n    \"lloc\"      =&gt;  \"lloc\",\n    \"loc\"       =&gt;  \"loc\",\n    \"comment\"   =&gt;  \"comment\",\n    \"blank\"     =&gt;  \"blank\",\n    \"newline\"   =&gt;  \"newline\",\n    \"logicline\" =&gt;  \"lgcline\",\n);\nmy %total = %counter; # copy\nmy $c = \\%counter; # see format below\nmy $h = \\%header;  # see top format below\nmy $inside_multiline_comment = 0;\nmy $filename = NOTFILENAME;\nmy $filecount = 0;\nmy $filename_header = \"file name\";\n\n# process input args\nmy $version = '';\nmy $help = '';\nmy $man = '';\nmy $is_deterministic = '';\nmy $has_header = '';\n\nprint STDERR \"Input args:'\" if DEBUG;\nprint STDERR (join(\"|\",@ARGV),\"'\\n\") if DEBUG;\n\nmy %option = ('version' =&gt; \\$version,\n    'help' =&gt; \\$help,   \n    'man'  =&gt; \\$man,\n    'deterministic' =&gt; \\$is_deterministic,\n    'header' =&gt; \\$has_header\n);\nGetOptions( \\%option, 'version',    'help', 'man',\n    'eloc|e', # print the eLOC counts\n    'lloc|s', # print the lLOC counts (code statements)\n    'loc|l' , # print the LOC counts (eLOC + lines of a single brace or parenthesis)\n    'comment|c'    , # print the comments counts (count lines which contains a comment)\n    'blank|b'      , # print the blank counts\n    'newline|n'    , # print the newline count\n    'logicline|g'  , # print the logical line count (= LOC + Comment Lines + Blank Lines)   \n    'deterministic', # print the LOC determination for every line in the source file\n    'header',        # print header line\n) or invalid_options(\"$0: invalid options\\nTry `$0 --help' for more information.\");\n\nversion()                                   if $version;\npod2usage(-exitstatus =&gt; 0, -verbose =&gt; 1)  if $help ;\npod2usage(-exitstatus =&gt; 0, -verbose =&gt; 2)  if $man;\n\n#\n$has_header = 1 if $is_deterministic &amp;&amp; $has_header eq '';\n\n#format for print_loc_metric()\nmy ($format, $format_top) = make_format(); \nprint STDERR \"format:\\n\" if DEBUG &gt; 10;\nprint STDERR $format if DEBUG &gt; 10;\neval $format;\ndie $@ if $@; # $EVAL_ERROR\n\nif(DEBUG&gt;10) {\n    print STDERR (\"format_top:\\n\", $format_top);\n}\nif( $has_header) {\n    eval $format_top;\n    die $@ if $@; # $EVAL_ERROR \n}\n\n# process files\nprint STDERR (\"Input args after Getopts():\\n\",\n    join(\"|\",@ARGV),\"\\n\") if DEBUG &gt; 10;\n\nexpand_wildcards();\n@ARGV = '-' unless @ARGV;\nforeach my $fn (@ARGV) {\n    $filename = $fn;\n    unless (open(IN, \"&lt;$filename\")) {\n        warn \"$0: Unable to read from '$filename': $!\\n\";\n        next;\n    }\n    print STDERR \"Scanning $filename...\\n\" if DEBUG;\n\n    clear_counters();\n    generate_loc_metric();  \n\n    $filecount++;\n\n    print_loc_metric();                     \n\n    close(IN)\n        or warn \"$0: Could not close $filename: $!\\n\";      \n}\n\n# print total\nif($filecount &gt; 1) {\n    $filename = \"total\";\n    $c = \\%total;\n    print_loc_metric();\n}\nexit 0;\n\n#-------------------------------------------------\nsub wsglob {\n    my @list = glob;\n    @list ? @list : @_; #HACK: defence from emtpy list from glob()\n}\nsub expand_wildcards {\n    print STDERR (\"Input args before expand_wildcards():\\n\",\n        join(\"|\",@ARGV),\"\\n\") if DEBUG;\n\n    {       \n        @ARGV = map( /['*?']/o ? wsglob($_) : $_ , @ARGV);\n    }   \n    print STDERR (\"Input args after expand_wildcards():\\n\",\n        join(\"|\",@ARGV),\"\\n\") if DEBUG; \n}\nsub clear_counters {\n    for my $name ( keys %counter) {\n        $counter{$name} = 0;\n    }   \n}\nsub make_format {\n    my $f = 'format STDOUT =' . \"\\n\";\n    $f .= '# LOC, eLOC, lLOC, comment, blank, newline, logicline and filename' . \"\\n\";\n    my $f_top = 'format STDOUT_TOP =' . \"\\n\";   \n    my $console_screen_width = (get_terminal_size())[0];\n    print STDERR '$console_screen_width=' . $console_screen_width .\"\\n\" if DEBUG&gt;10;\n    $console_screen_width = 100 if $console_screen_width &lt; 0;\n    my $is_print_specifiers_set = \n         ($option{\"eloc\"} or\n         $option{\"lloc\"} or\n         $option{\"loc\"} or\n         $option{\"comment\"} or\n         $option{\"blank\"} or\n         $option{\"newline\"} or\n         $option{\"logicline\"});\n\n    my %o = %option;\n    my $fc = 0;\n    if( $is_print_specifiers_set ) {\n\n        $fc++ if $o{\"eloc\"};\n        $fc++ if $o{\"lloc\"};\n        $fc++ if $o{\"loc\"};\n        $fc++ if $o{\"comment\"};\n        $fc++ if $o{\"blank\"};\n        $fc++ if $o{\"newline\"};\n        $fc++ if $o{\"logicline\"};\n        if( $fc == 0 ) { die \"$0: assertion failed: field count is zero\" }\n    }\n    else {\n        # default\n        $fc = 7;\n        $o{\"loc\"}       = 1;       \n        $o{\"eloc\"}      = 1;         \n        $o{\"lloc\"}      = 1;      \n        $o{\"comment\"}   = 1;   \n        $o{\"blank\"}     = 1;     \n        $o{\"newline\"}   = 1;   \n        $o{\"logicline\"} = 1;        \n    }\n    if (DEBUG &gt; 10) {\n        while( (my ($name, $value) = each %{o}) ) {\n            print STDERR \"name=$name, value=$value\\n\";\n        }       \n    }\n\n\n    # picture line  \n    my $field_format = '@&gt;&gt;&gt;&gt;&gt;&gt; ';\n    my $field_width = length $field_format;\n    my $picture_line = $field_format x $fc;     \n    #   place for filename\n    $picture_line .= '^';       \n    $picture_line .= '&lt;' x ($console_screen_width - $field_width * $fc - 2);\n    $picture_line .= \"\\n\";  \n    $f .= $picture_line;\n    $f_top .= $picture_line;\n    # argument line\n    $f .=   '$$c{\"LOC\"}, '      ,$f_top .= '$$h{\"loc\"}, '       if $o{\"loc\"};\n    $f .=   '$$c{\"ELOC\"}, '     ,$f_top .= '$$h{\"eloc\"}, '      if $o{\"eloc\"};      \n    $f .=   '$$c{\"LLOC\"}, '     ,$f_top .= '$$h{\"lloc\"}, '      if $o{\"lloc\"};\n    $f .=   '$$c{\"comment\"}, '  ,$f_top .= '$$h{\"comment\"}, '   if $o{\"comment\"};\n    $f .=   '$$c{\"BLANK\"}, '    ,$f_top .= '$$h{\"blank\"}, '     if $o{\"blank\"};\n    $f .=   '$$c{\"PHYS\"}, '     ,$f_top .= '$$h{\"newline\"}, '   if $o{\"newline\"};\n    $f .=   '$$c{\"logicline\"}, ',$f_top .= '$$h{\"logicline\"}, ' if $o{\"logicline\"};\n    $f .=  '$filename' . \"\\n\";\n    $f_top .= '$filename_header' . \"\\n\";        \n\n    # 2nd argument line for long file names\n    $f .=   '^';    \n    $f .= '&lt;' x ($console_screen_width-2);\n    $f .= '~~'  . \"\\n\"\n            .' $filename'  . \"\\n\";\n    $f .='.' . \"\\n\";\n    $f_top .='.' . \"\\n\";\n    return ($f, $f_top);\n}\nsub generate_loc_metric {\n    my $is_concatinated = 0;\n    LINE: while(&lt;IN&gt;)\n    {\n        chomp;      \n        print if $is_deterministic &amp;&amp; !$is_concatinated;        \n\n        # handle multiline code statements\n        if ($is_concatinated = s/\\\\$//) {\n            warnings::warnif(\"$0: '\\\\'-ending line concantinated\");\n            increment('PHYS');\n            print \"\\n\" if $is_deterministic;\n            my $line = &lt;IN&gt;;\n            $_ .= $line;\n            chomp($line);\n            print $line if $is_deterministic;\n            redo unless eof(IN);            \n        }               \n\n        # blank lines, including inside comments, don't move to next line here\n        increment('BLANK')                  if( /^\\s*$/ );  \n\n        # check whether multiline comments finished\n        if( $inside_multiline_comment &amp;&amp; m~\\*/\\s*(\\S*)\\s*$~ ) {\n            $inside_multiline_comment = 0;\n            # check the rest of the line if it contains non-whitespace characters\n            #debug $_ = $REDO_LINE . $1, redo LINE if($1);\n            warnings::warnif(\"$0: expression '$1' after '*/' discarded\") if($1);\n            # else mark as pure comment\n            increment('PURE_COMMENT');\n            next LINE;\n        }\n        # inside multiline comments\n        increment('PURE_COMMENT'), next LINE if( $inside_multiline_comment );\n\n        # C++ style comment at the begining of line (except whitespaces)\n        increment('PURE_COMMENT'), next LINE if( m~^\\s*//~ ); \n\n        # C style comment at the begining of line (except whitespaces)\n        if ( m~^\\s*/\\*~ ) {\n            $inside_multiline_comment = 1 unless( m~\\*/~ );\n            increment('PURE_COMMENT'),  next LINE;\n        }\n        # inline comment, don't move to next line here\n        increment('INLINE_COMMENT')        if ( is_inline_comment($_) );\n\n        # lLOC implicitly incremented inside is_inline_comment($)\n\n        #\n        increment('LOC')                    unless( /^\\s*$/ );\n\n        # standalone braces or parenthesis  \n                                  next LINE if( /^\\s*(?:\\{|\\}|\\(|\\))+\\s*$/ );           \n\n        # eLOC is not comments, blanks or standalone braces or parenthesis\n        #   therefore just increment eLOC counter here\n        increment('ELOC'),        next LINE unless( /^\\s*$/ );\n    }\n    continue {\n        increment('PHYS');\n        print \" [$.]\\n\" if $is_deterministic; # $INPUT_LINE_NUMBER\n    }\n}\n\nsub print_loc_metric {\n    $$c{'comment'} = $$c{'PURE_COMMENT'} + $$c{'INLINE_COMMENT'}; \n    # LOC + Comment Lines + Blank Lines \n    $$c{'logicline'} = $$c{'LOC'} + $$c{'comment'} + $$c{'BLANK'};\n    unless (defined $filename) { \n        die \"print_loc_metric(): filename is not defined\";\n    }       \n\n    my $fn = $filename;\n    $filename = \"\", $filename_header = \"\" \n        unless($#ARGV);\n    print STDERR (\"ARGV in print_loc_metric:\" , join('|',@ARGV), \"\\n\") \n        if DEBUG;\n    write STDOUT; # replace with printf\n    $filename = $fn;\n}\nsub increment {\n    my $loc_type = shift;\n    defined $loc_type\n        or die 'increment(\\$): input argument is undefined';    \n\n    $counter{$loc_type}++;\n    $total{$loc_type}++;\n    print \"\\t#\". $loc_type .\"#\" if $is_deterministic;   \n}\n\nsub is_inline_comment {\n    my $line = shift;\n    defined $line \n        or die 'is_inline_comment($): $line is not defined';\n\n    print \"\\n$line\" if DEBUG &gt; 10;  \n\n# here: line is not empty, not begining both C and C++ comments signs,\n#       not standalone '{}()', not inside multiline comment,\n#       ending '\\' removed (joined line created if needed)\n\n# Possible cases: \n#   - no C\\C++ comment signs                        =&gt; is_inline_comment = 0\n#   - C++ comment (no C comment sign)\n#       * no quote characters                       =&gt; is_inline_comment = 1\n#       * at least one comment sign is not quoted   =&gt; is_inline_comment = 1\n#       * all comment signs are quoted              =&gt; is_inline_comment = 0\n#   - C comment (no C++ comment sign)\n#       * no quote characters                       =&gt; is_inline_comment = 1,\n#           ~ odd number of '/*' and '*/'           =&gt; $inside_multiple_comment = 1                             \n#           ~ even number                           =&gt; $inside_multiple_comment = 0\n#       * etc...\n#   - ...\n# algorithm: move along the line from left to right\n# rule: quoted comments are not counted\n# rule: quoted by distinct style quotes are not counted\n# rule: commented quotes are not counted\n# rule: commented distinct style comments are not counted\n# rule: increment('LLOC') if not-quoted, not-commented\n#           semi-colon presents in the line except that two \n#           semi-colon in for() counted as one.\n\n# \n$_ = $line; #hack: $_ = $line inside sub\n#   state\nmy %s = (\n    'c'     =&gt; 0, # c slash star - inside c style comments\n    'cpp'   =&gt; 0, # c++ slash slash - inside C++ style comment\n    'qm'    =&gt; 0, # quoted mark - inside quoted string\n    'qqm'   =&gt; 0, # double quoted - inside double quoted string\n);\nmy $has_comment = 0;\n# find state\nLOOP:\n    {\n      /\\G\\\"/gc  &amp;&amp;  do { # match double quote\n                            unless( $s{'qm'} || $s{'c'} || $s{'cpp'} ) {\n                                    # toggle \n                                $s{'qqm'} = $s{'qqm'} ? 0 : 1; \n                            }\n                            redo LOOP;\n                    };\n      /\\G\\'/gc  &amp;&amp;  do { # match single quote\n                            unless( $s{'qqm'} || $s{'c'} || $s{'cpp'} ) {\n                                    # toggle \n                                $s{'qm'} = $s{'qm'} ? 0 : 1; \n                            }\n                            redo LOOP;\n                    };\n      m~\\G//~gc &amp;&amp;  do { # match C++ comment sign\n                            unless( $s{'qm'} || $s{'qqm'} || $s{'c'} ) {\n                                    # on\n                                $has_comment = 1;\n                                $s{'cpp'} = 1; \n                            } \n                            redo LOOP;\n                    };\n      m~\\G/\\*~gc    &amp;&amp;  do { # match begining C comment sign\n                            unless( $s{'qm'} || $s{'qqm'} || $s{'cpp'} ) {\n                                    # on\n                                $has_comment = 1;\n                                $s{'c'} = $s{'c'} ? 1 : 1; \n                            } \n                            redo LOOP;\n                    };\n      m~\\G\\*/~gc    &amp;&amp;  do { # match ending C comment sign\n                            unless( $s{'qm'} || $s{'qqm'} || $s{'cpp'} ) {\n                                    # off                                   \n                                if( $s{'c'} ) {                                     \n                                    $s{'c'} = 0;\n                                }\n                                else {\n                                    die 'is_inline_comment($): unexpected c style ending comment sign'.\n                                        \"\\n'$line'\";\n                                }\n                            } \n                            redo LOOP;\n                    };\n      /\\Gfor\\s*\\(.*\\;.*\\;.*\\)/gc    &amp;&amp;  do { # match for loop\n                            unless( $s{'qm'} || $s{'qqm'} || $s{'cpp'} || $s{'c'} ) {\n                                # not-commented, not-quoted semi-colon                                  \n                                increment('LLOC');\n                            }\n                            redo LOOP;\n                    };                                          \n      /\\G\\;/gc  &amp;&amp;  do { # match semi-colon\n                            unless( $s{'qm'} || $s{'qqm'} || $s{'cpp'} || $s{'c'} ) {\n                                # not-commented, not-quoted semi-colon\n                                # not inside for() loop\n                                increment('LLOC');\n                            }\n                            redo LOOP;\n                    };                      \n      /\\G./gc   &amp;&amp;  do { # match any other character\n                            # skip 1 character\n                            redo LOOP;\n                    };\n      /\\G$/gc   &amp;&amp;  do { # match end of the line\n                            last LOOP;\n                    };                      \n      #default\n        die 'is_inline_comment($): unexpected character in the line:' .\n            \"\\n'$line'\";\n    }\n# apply state\n    $inside_multiline_comment = $s{'c'};\n    return $has_comment;\n}\n\nsub version {\n#   TODO: version implementation\n    print &lt;&lt;\"VERSION\";\nNAME v$VERSION\nWritten by AUTHOR\n\nCOPYRIGHT AND LICENSE\nVERSION\n\nexit 0;\n}\n\nsub invalid_options {\n    print STDERR (@_ ,\"\\n\");\n    exit 2;\n}\n\nsub get_terminal_size {\n    my ($wchar, $hchar) = ( -1, -1); \n    my $win32console = &lt;&lt;'WIN32_CONSOLE';   \n        use Win32::Console; \n        my $CONSOLE = new Win32::Console(); \n        ($wchar, $hchar) = $CONSOLE-&gt;MaxWindow();\nWIN32_CONSOLE\n\n    eval($win32console); \n    return ($wchar, $hchar) unless( $@ );\n    warnings::warnif($@); # $EVAL_ERROR\n\n    my $term_readkey = &lt;&lt;'TERM_READKEY';\n        use Term::ReadKey; \n        ($wchar,$hchar, $wpixels, $hpixels) = GetTerminalSize(); \nTERM_READKEY\n\n    eval($term_readkey); \n    return ($wchar, $hchar) unless( $@ );\n\n    warnings::warnif($@); # $EVAL_ERROR \n    my $ioctl = &lt;&lt;'IOCTL'; \n        require 'sys/ioctl.ph'; \n        die \"no TIOCGWINSZ \" unless defined &amp;TIOCGWINSZ; \n        open(TTY, \"+&lt;/dev/tty\")                     \n            or die \"No tty: $!\"; \n        unless (ioctl(TTY, &amp;TIOCGWINSZ, $winsize='')) { \n            die sprintf \"$0: ioctl TIOCGWINSZ (%08x: $!)\\n\", \n                    &amp;TIOCGWINSZ; \n        } \n        ($hchar, $wchar, $xpixel, $ypixel) = \n            unpack('S4', $winsize); # probably $hchar &amp; $wchar should be swapped here \nIOCTL\n\n    eval($ioctl); \n    warnings::warnif($@) if $@ ; # $EVAL_ERROR  \n\n    return ($wchar, $hchar); \n}\n\n1;\n__END__ \n\n=head1 NAME\n\neLOC - Effective Lines of Code Counter\n\n=head1 SYNOPSIS\n\nB&lt;eloc&gt; B&lt;[&gt;OPTIONB&lt;]...&gt; B&lt;[&gt;FILEB&lt;]...&gt;\n\nPrint LOC, eLOC, lLOC, comment, blank, newline and logicline counts \nfor each FILE, and a total line if more than one FILE is specified.\nSee L&lt;/\"LOC Specification\"&gt; for more info, use `eloc --man'.\n\n  -e, --eloc             print the {E}LOC counts\n  -s, --lloc             print the lLOC counts (code {S}tatements)\n  -l, --loc              print the {L}OC counts (eLOC + lines of a single brace or parenthesis)\n  -c, --comment          print the {C}omments counts (count lines which contains a comment)\n  -b, --blank            print the {B}lank counts\n  -n, --newline          print the {N}ewline count\n  -g, --logicline        print the lo{G}ical line count (= LOC + Comment Lines + Blank Lines)\n      --deterministic    print the LOC determination for every line in the source file\n      --header           print header line\n      --help display this help and exit\n      --man  display full help and exit\n      --version  output version information and exit\n\nWith no FILE, or when FILE is -, read standard input.      \n\nMetrics counted by the program are based on narration from \nhttp://msquaredtechnologies.com/m2rsm/docs/rsm_metrics_narration.htm\n\n=for TODO: Comment Percent = Comment Line Count / Logical Line Count ) x 100      \n\n=for TODO: White Space Percentage = (Number of spaces / Number of spaces and characters) * 100       \n\n=head1 DESCRIPTION\n\neLOC is a simple LOC counter. See L&lt;/\"LOC Specification\"&gt;. \n\n=head2 LOC Specification\n\n=over 1\n\n=item LOC\n\nLines Of Code = eLOC + lines of a single brace or parenthesis\n\n=item eLOC\n\nAn effective line of code or eLOC is the measurement of all lines that are \nnot comments, blanks or standalone braces or parenthesis. \nThis metric more closely represents the quantity of work performed. \nRSM introduces eLOC as a metrics standard.\nSee http://msquaredtechnologies.com/m2rsm/docs/rsm_metrics_narration.htm\n\n=item lLOC\n\nLogical lines of code represent a metrics for those line of code which form \ncode statements.  These statements are terminated with a semi-colon.  \n\nThe control line for the \"for\" loop contain two semi-colons but accounts \nfor only one semi colon.\nSee http://msquaredtechnologies.com/m2rsm/docs/rsm_metrics_narration.htm\n\n=item comment\n\ncomment = pure comment + inline comment\n\n\n\n=over\n\n=item pure comment\n\nComment lines represent a metrics for pure comment line without any code in it.\nSee L&lt;/\"inline comment\"&gt;.\n\n=item inline comment\n\nInline comment line is a line which contains both LOC line and pure comment.\n\nInline comment line and pure comment line (see L&lt;/\"pure comment\"&gt;)\nare mutually exclusive, that is a given physical line cannot be an inline comment\nline and a pure comment line simultaneously.\n\n=over\n\n=item Example:\n\n    static const int defaultWidth = 400;        // value provided in declaration\n\n=back\n\n=back\n\n=item blank\n\nBlank line is a line which contains at most whitespaces.\nBlank lines are counted inside comments too.\n\n=item logicline\n\nThe logical line count = LOC + Comment Lines + Blank Lines\n\n=back\n\n=head1 KNOWN BUGS AND LIMITATIONS\n\n=over\n\n=item\n\nIt supports only C/C++ source files.\n\n=item\n\nComments inside for(;;) statements are not counted\n\n=over\n\n=item Example:\n\n    for(int i = 0; i &lt; N /*comment*/; i++ );        #LLOC#  #LLOC#  #LOC#   #ELOC#  #PHYS# [1]\n\n=back\n\n=item\n\n'\\'-ending lines are concatinated ( though newline count is valid)\n\n=item\n\nInput from stdin is not supported in the case \nthe script is envoked solely by name without explicit perl executable.\n\n=item\n\nWildcards in path with spaces are not supported (like GNU utilities).\n\n=back\n\n=over\n\n=begin fixed\n=item Limitation: single source file\n\n    Only one source file at time supported\n\n=item Limitation: LLOC is unsupported\n\n    The logical lines of code metric is unsupported. \n\n=item missed inline comment for C style comment\n\n    #include &lt;math.h&gt; /* comment */ #ELOC#  #PHYS# [2]\n\nBut must be\n    #include &lt;math.h&gt; /* comment */ #INLINE_COMMENT#    #ELOC#  #PHYS# [2]\n\n=item wrong LOC type for the code after '*/'\n\n    /* another  #PURE_COMMENT#  #PHYS# [36]\n    trick   #PURE_COMMENT#  #PHYS# [37]\n    */  i++;    #PURE_COMMENT#  #PHYS# [38]\n\nIn the last line must be \n\n    #INLINE_COMMENT# #PHYS# [38]\n\n=end fixed\n\n=back\n\n=head1 SEE ALSO\n\nMetrics counted by the program are based on narration from L&lt;http://msquaredtechnologies.com/m2rsm/docs/rsm_metrics_narration.htm&gt;\n\n=cut\n</code></pre>\n", "CreationDate": "2008-12-13T22:24:50.223", "ParentId": "323419", "CommentCount": "0", "LastEditDate": "2008-12-13T22:41:42.093", "PostTypeId": "2", "LastEditorDisplayName": "J.F. Sebastian", "LastActivityDate": "2008-12-13T22:41:42.093", "LastEditorUserId": "4279", "Id": "365856", "OwnerDisplayName": "J.F. Sebastian", "Score": "1", "OwnerUserId": "4279"}, "323427": {"Id": "323427", "PostTypeId": "2", "Body": "<p>Check out DPack plugin for Visual Studio. It has a stats report for any solution/project.</p>\n", "OwnerDisplayName": "Tim Ring", "LastActivityDate": "2008-11-27T10:33:32.270", "Score": "1", "CreationDate": "2008-11-27T10:33:32.270", "ParentId": "323419", "CommentCount": "1", "OwnerUserId": "3685"}, "324469": {"Id": "324469", "PostTypeId": "2", "Body": "<p><a href=\"http://www.ohloh.net\" rel=\"nofollow noreferrer\">Ohloh</a> offers the free <a href=\"http://www.ohloh.net/projects/ohcount\" rel=\"nofollow noreferrer\">Ohcount</a> which counts lines of code and comments.</p>\n", "OwnerDisplayName": "Greg Hewgill", "LastActivityDate": "2008-11-27T18:51:21.173", "Score": "1", "CreationDate": "2008-11-27T18:51:21.173", "ParentId": "323419", "CommentCount": "1", "OwnerUserId": "893"}, "323736": {"Id": "323736", "PostTypeId": "2", "Body": "<p><a href=\"http://www.campwoodsw.com/sourcemonitor.html\" rel=\"nofollow noreferrer\">Source monitor</a> is freeware source analysis software. It is windows application but it also can be run with parameters from command line. </p>\n<p>It can analyze C++, C, C#, VB.NET, Java, Delphi, Visual Basic (VB6) or HTML.</p>\n", "LastActivityDate": "2008-11-27T13:14:48.217", "CommentCount": "0", "CreationDate": "2008-11-27T13:14:48.217", "ParentId": "323419", "Score": "1", "OwnerUserId": "25732"}, "365745": {"Id": "365745", "PostTypeId": "2", "Body": "<p><a href=\"http://www.dwheeler.com/sloccount/\" rel=\"nofollow noreferrer\">SLOCCOunt</a> is not a simple script and does much more than what you need. However, it is a powerful alternative to the already mentioned Ohcount and NLOC. :)</p>\n", "OwnerDisplayName": "hangy", "LastActivityDate": "2008-12-13T21:13:39.307", "Score": "1", "CreationDate": "2008-12-13T21:13:39.307", "ParentId": "323419", "CommentCount": "0", "OwnerUserId": "11963"}, "323531": {"Body": "<p>Looking NLOC on the Net, I found mostly \"Non-commented lines of code\".<br>\nYou don't specify if comments must be skipped...<br>\nSo if I stick to your current message, the following one-liner in Perl should do the job:</br></br></p>\n<pre><code>perl -pe \"s/^\\s*[{}]?\\s*\\n//\" Dialog.java | wc -l\n</code></pre>\n<p>I can extend it to handle line comments:</p>\n<pre><code>perl -pe \"s#^\\s*[{}]?\\s*\\n|^\\s*//.*\\n##\" Dialog.java | wc -l\n</code></pre>\n<p>or perhaps</p>\n<pre><code>perl -pe \"s#^\\s*(?:[{}]?\\s*|//.*)\\n##\" Dialog.java | wc -l\n</code></pre>\n<p>Handling block comments is slightly more tricky (I am not a Perl expert!).</p>\n<p>[EDIT] Got it... First part can be probably improved (shorter). Was fun to experiment with.</p>\n<pre><code>perl -e \"$x = join('', &lt;&gt;); $x =~ s#/\\*.*?\\*/##gs; print $x\" Dialog.java | perl -pe \"s#^\\s*(?:[{}]?\\s*|//.*)\\n##\" | wc -l\n</code></pre>\n<p>PS.: I use double quotes because I tested on Windows...</p>\n", "CreationDate": "2008-11-27T11:35:20.773", "ParentId": "323419", "CommentCount": "2", "LastEditDate": "2008-11-27T13:05:22.713", "PostTypeId": "2", "LastEditorDisplayName": "PhiLho", "LastActivityDate": "2008-11-27T13:05:22.713", "LastEditorUserId": "15459", "Id": "323531", "OwnerDisplayName": "PhiLho", "Score": "2", "OwnerUserId": "15459"}, "365749": {"Id": "365749", "PostTypeId": "2", "Body": "<p>I usually just do this:</p>\n<pre><code>grep -vc '^$' (my files)\n</code></pre>\n<p>Works only if your empty lines are really empty (no spaces). Sufficient for me.</p>\n", "OwnerDisplayName": "jkramer", "LastActivityDate": "2008-12-13T21:17:14.730", "Score": "1", "CreationDate": "2008-12-13T21:17:14.730", "ParentId": "323419", "CommentCount": "0", "OwnerUserId": "12523"}, "365772": {"Id": "365772", "PostTypeId": "2", "Body": "<p>Not a simple script, but <a href=\"http://cccc.sourceforge.net/\" rel=\"nofollow noreferrer\">CCCC</a> (C and C++ Code Counter) has been around for a while and it works great for me.</p>\n", "OwnerDisplayName": "florin", "LastActivityDate": "2008-12-13T21:35:09.263", "Score": "0", "CreationDate": "2008-12-13T21:35:09.263", "ParentId": "323419", "CommentCount": "0", "OwnerUserId": "18308"}});