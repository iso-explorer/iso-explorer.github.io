post_cb({"10968506": {"ParentId": "10968494", "CommentCount": "0", "Body": "<p>The order depends on comparing functor used (third template argument on map, second on set). The default is <code>std::less&lt;T&gt;</code>, which gives sets/maps an ascending order, yes.</p>\n", "OwnerUserId": "16102", "PostTypeId": "2", "Id": "10968506", "Score": "6", "CreationDate": "2012-06-10T12:03:31.260", "LastActivityDate": "2012-06-10T12:03:31.260"}, "10968494": {"CommentCount": "0", "ViewCount": "1744", "PostTypeId": "1", "LastEditorUserId": "544721", "CreationDate": "2012-06-10T12:02:02.510", "LastActivityDate": "2012-06-10T12:28:22.417", "Title": "c++ set ordered iterating - Are results of iterating over set, ordered by standard?", "AcceptedAnswerId": "10968509", "LastEditDate": "2012-06-10T12:07:39.127", "Id": "10968494", "Score": "2", "Body": "<p>Can I rely on the assumption (in other words: Is it guaranteed by standard?) that :</p>\n<ul>\n<li><code>set&lt;T&gt;::begin()</code> will point to the smallest element in set?</li>\n<li>iterating over set, (from <code>set&lt;T&gt;::begin()</code> till <code>set&lt;T&gt;::end()</code>) will give elements in increasing order?</li>\n<li>and just to be sure: Do these properties hold for keys in <code>map</code>?</li>\n</ul>\n<p>I mean <code>set</code> and <code>map</code> from <code>STL</code>.</p>\n<p>P.S. I know abut <code>operator&lt;()</code> and defining own comparators. Please ensure me about what standard says about this ?</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "544721", "AnswerCount": "3"}, "10968535": {"ParentId": "10968494", "CommentCount": "1", "Body": "<p>Short answer:  Yes.</p>\n<p>Longer answer: both std::set and std::map take a second templated argument - a binary predicate to compare elements.  By default, this is std::less - a class implementing a single boolean function - which is, itself, defined in terms of operator &lt;.</p>\n<p>Unless you specify otherwise when instantiating the stl template, operator &lt; will define the order of keys.  N.B. Weird things may happen if you use a boolean predicate that does not define a (partial) order. :)</p>\n", "OwnerUserId": "835734", "PostTypeId": "2", "Id": "10968535", "Score": "1", "CreationDate": "2012-06-10T12:06:43.673", "LastActivityDate": "2012-06-10T12:06:43.673"}, "bq_ids": {"n4140": {"so_10968494_10968509_1": {"section_id": 746, "quality": 0.8620689655172413, "length": 25}, "so_10968494_10968509_0": {"section_id": 738, "quality": 0.9, "length": 27}}, "n3337": {"so_10968494_10968509_1": {"section_id": 735, "quality": 0.8620689655172413, "length": 25}, "so_10968494_10968509_0": {"section_id": 727, "quality": 0.9, "length": 27}}, "n4659": {"so_10968494_10968509_1": {"section_id": 805, "quality": 0.8620689655172413, "length": 25}, "so_10968494_10968509_0": {"section_id": 796, "quality": 0.9, "length": 27}}}, "10968509": {"ParentId": "10968494", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2012-06-10T12:03:49.477", "Score": "5", "LastEditorUserId": "661519", "LastEditDate": "2012-06-10T12:28:22.417", "Id": "10968509", "OwnerUserId": "661519", "Body": "<p>Yes, you can rely on that by definition, depending on the element's (keys) <code>bool operator&lt;</code> or the comparison functor passed as template parameter to the set (map). So the ordering will be from smallest to largest according to the comparator used.</p>\n<p>In the C++11 standard, \u00a723.2.4, dealing with requirements of Associative Containers:</p>\n<blockquote>\n<p id=\"so_10968494_10968509_0\">Each associative container is parameterized on Key and an ordering relation Compare that induces a strict weak ordering (25.4) on elements of Key. In addition, map and multimap associate an arbitrary type T with the Key. The object of type Compare is called the comparison object of a container.</p>\n</blockquote>\n<p>Then, in the same section:</p>\n<blockquote>\n<p id=\"so_10968494_10968509_1\">The fundamental property of iterators of associative containers is that they iterate through the containers\n  in the non-descending order of keys where non-descending is defined by the comparison that was used to\n   construct them. For any two dereferenceable iterators i and j such that distance from i to j is positive,\n  value_comp(*j, *i) == false</p>\n</blockquote>\n<p>where <code>value_comp</code> is the comparison function.</p>\n", "LastActivityDate": "2012-06-10T12:28:22.417"}});