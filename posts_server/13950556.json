post_cb({"13951350": {"ParentId": "13950556", "CommentCount": "3", "Body": "<p>I've tried your code (on the Visual Studio version only).</p>\n<p>Since you have a built-in copy-CTOR, I guess your main is equal to:</p>\n<pre><code>int main()\n{\n    try { Value w((struct Value)(Convertible())); }\n    catch (char const *s) { cerr &lt;&lt; s &lt;&lt; endl; }\n}\n</code></pre>\n<p>The compiler has chosen to use your copy CTOR, rather than Value(int).</p>\n<p>Changing it to:</p>\n<pre><code>int main()\n{\n    try { Value w((int)(Convertible())); }\n    catch (char const *s) { cerr &lt;&lt; s &lt;&lt; endl; }\n}\n</code></pre>\n<p>It printed \"int\".</p>\n", "OwnerUserId": "1817919", "PostTypeId": "2", "Id": "13951350", "Score": "1", "CreationDate": "2012-12-19T11:25:44.293", "LastActivityDate": "2012-12-19T11:25:44.293"}, "13951621": {"ParentId": "13950556", "CommentCount": "0", "Body": "<p>In the first example Visual Studio is incorrect; the call is ambiguous.  gcc in C++03 mode prints:</p>\n<pre><code>source.cpp:21:34: error: call of overloaded 'Value(Convertible)' is ambiguous\nsource.cpp:21:34: note: candidates are:\nsource.cpp:9:5: note: Value::Value(int)\nsource.cpp:6:8: note: Value::Value(const Value&amp;)\n</code></pre>\n<p>Recall that a copy constructor is implicitly defaulted.  The governing paragraph is <strong>13.3.1.3 Initialization by constructor [over.match.ctor]</strong>:</p>\n<blockquote>\n<p id=\"so_13950556_13951621_0\">When objects of class type are direct-initialized [...], overload resolution selects the constructor. For direct-initialization, the candidate functions are all the constructors of the class of the object being initialized.</p>\n</blockquote>\n<p>In the second example, deleted functions participate equally in overload resolution; they only affect compilation once overloads have been resolved, when a program that selects a deleted function is ill-formed.  The motivating example in the standard is of a class that can only be constructed from floating-point types:</p>\n<pre><code>struct onlydouble {\n  onlydouble(std::intmax_t) = delete;\n  onlydouble(double);\n};\n</code></pre>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "13951621", "Score": "8", "CreationDate": "2012-12-19T11:39:21.147", "LastActivityDate": "2012-12-19T11:39:21.147"}, "bq_ids": {"n4140": {"so_13950556_13951621_0": {"section_id": 592, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_13950556_13951621_0": {"section_id": 582, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_13950556_13951621_0": {"section_id": 615, "quality": 0.9473684210526315, "length": 18}}}, "13950556": {"CommentCount": "13", "AcceptedAnswerId": "13951621", "PostTypeId": "1", "LastEditorUserId": "541686", "CreationDate": "2012-12-19T10:43:21.007", "LastActivityDate": "2012-12-19T11:39:21.147", "LastEditDate": "2012-12-19T10:55:17.617", "ViewCount": "594", "FavoriteCount": "2", "Title": "Conversion operator + conversion constructor = unintuitive behavior?", "Id": "13950556", "Score": "11", "Body": "<p>I don't understand why the code below prints <code>struct Value</code> instead of <code>int</code> (which implies the conversion constructor is converting to <code>Value</code> instead of <code>int</code>). (Visual C++ 2012)</p>\n<p>Why is this happening? Why does the compiler completely ignore the <code>Value(int)</code> constructor?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_info&gt;\n\nusing namespace std;\n\nstruct Value { Value(int) { } };\n\nstruct Convertible\n{\n    template&lt;class T&gt;\n    operator T() const\n    { throw typeid(T).name(); }\n};\n\nint main()\n{\n    try { Value w((Convertible())); }\n    catch (char const *s) { cerr &lt;&lt; s &lt;&lt; endl; }\n}\n</code></pre>\n<h2>Edit:</h2>\n<p>Even more bizarre is <a href=\"http://liveworkspace.org/code/1htnJu%242\">this</a> (this time it's C++11 only, on GCC 4.7.2):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nusing namespace std;\n\nstruct Value\n{\n    Value(Value const &amp;) = delete;\n    Value(int) { }\n};\n\nstruct Convertible\n{\n    template&lt;class T&gt;\n    operator T() const\n    { throw typeid(T).name(); }\n};\n\nint main()\n{\n    try { Value w((Convertible())); }\n    catch (char const *s) { cerr &lt;&lt; s &lt;&lt; endl; }\n}\n</code></pre>\n<p>Which gives:</p>\n<pre><code>source.cpp: In function 'int main()':\nsource.cpp:21:32: error: call of overloaded 'Value(Convertible)' is ambiguous\nsource.cpp:21:32: note: candidates are:\nsource.cpp:9:3: note: Value::Value(int)\nsource.cpp:8:3: note: Value::Value(const Value&amp;) &lt;deleted&gt;\n</code></pre>\n<p>If the copy constructor is deleted, then why is there any ambiguity?!</p>\n", "Tags": "<c++><visual-c++><implicit-conversion>", "OwnerUserId": "541686", "AnswerCount": "2"}});