post_cb({"11851468": {"CommentCount": "12", "ViewCount": "302", "PostTypeId": "1", "LastEditorUserId": "509614", "CreationDate": "2012-08-07T17:56:24.120", "LastActivityDate": "2012-08-07T18:17:33.203", "Title": "Visual Studio - No compilation error when failing to return a value", "AcceptedAnswerId": "11851757", "LastEditDate": "2012-08-07T18:11:23.343", "Id": "11851468", "Score": "1", "Body": "<p><strong>The problem.</strong> \nSee the below code... I was missing the <code>return field;</code> statement and didn't spot it for a few debug runs. I would never have thought that something like that would get past the compiler without an error! Why did it?</p>\n<p><strong>Description</strong> \nI have an parser object that uses <code>std::tr1::function</code> to have receive a translation algorithm on construction. The translation converts from a string to an object of type <code>TransportableMessage</code>, which is made of <code>TMFields</code>, which can hold different types. So anyway I made a factory function for the creation of the fields because the type of the field is based on a string (from the XML), and while there is only a few now, it may be that there are more in the future.</p>\n<p>The <code>tstring</code> object is a typecast based on <code>UNICODE</code> and basically resolves to <code>std::wstring</code> at the minute. Also because I am using VS2008 <code>unique_ptr</code> is not there so I have hidden <code>std::auto_ptr</code> behind <code>ScopedPtr_t</code> to make an upgrade easier and thus more likely to happen.</p>\n<pre><code>namespace arc\n{\n    namespace util\n    {\n\n        int internalTest()\n        {\n            std::cout &lt;&lt; \"Any error?\" &lt;&lt; std::endl;\n        }\n\n        ScopedPtr_T&lt;TMField&gt; TmFieldFactory( const tstring&amp; name, const tstring&amp; typeName, const tstring&amp; value )\n        {\n            ScopedPtr_T&lt;TMField&gt; field;\n            int a = internalTest();\n            if( typeName == _T(\"int\") || typeName == _T(\"long\") )\n            {\n                field.reset( new TMNumericField( name, boost::lexical_cast&lt;__int64&gt;(value) ) );\n            }\n            else if( typeName == _T(\"string\") )\n            {\n                field.reset( new TMStringField( name, value ) );\n            }\n            else if( typeName == _T(\"timestamp\") )\n            {\n                field.reset( new TMTimeField( name, boost::lexical_cast&lt;__int64&gt;(value) ) );\n            }\n            else\n            {\n                std::string info( __FILE__ \" :: \" __FUNCTION__ \" : Unrecognized TmField type \");\n                std::string type( typeName.begin(), typeName.end() );\n                info += type;\n                throw ARC_Exception( info.c_str() );\n            }\n            return field; // I WAS MISSING THIS!\n        }\n    }\n}\n</code></pre>\n<p>Basically I would like to know if anyone else has had problems with this? I introduced the function <code>internalTest</code> to see if the problem was specific to <code>scoped_ptr</code>s but it appears that it is not. I also tried using <code>internalTest</code> in GCC and it returned an error.\nWhy did it Visual Studio not flag this? Am I missing a compilation setting somewhere that I can turn on? Does the standard allow this? Apologies if this is something well known, I did google and look for answers here.</p>\n<p><strong>EDIT:: Calling Code</strong> - Just adding this for more context.</p>\n<pre><code>SharedPtr_T&lt;TransportableMessage&gt; strToTmConvFunc_Default_Apc7_0(const std::string&amp; tm_str)\n{\n    pugi::xml_document xmlDoc;\n    if( false == xmlDoc.load( tm_str.c_str() ) )\n    {\n        ARC_LOG(LOG_WARN, \"The passed TM object was malformed. %s\", tm_str.c_str() );\n        throw ARC_Exception( \"Malformed Transportable Message XML\" );\n    }\n\n    pugi::xml_node tmBase = xmlDoc.first_child();\n    std::string xmlRootName( tmBase.name() );\n    if( xmlRootName.compare(\"TM\") != 0 )\n    {\n        ARC_LOG(LOG_WARN, \"The passed TM object was malformed. %s\", tm_str.c_str() );\n        throw ARC_Exception( \"Malformed Transportable Message XML\" );\n    }\n\n    std::string tmname = tmBase.child(\"N\").child_value();\n    std::string entity = tmBase.child(\"E\").child_value();\n    ARC_LOG(LOG_INFO, \"TM message received for parsing. TM name is %s\", tmname.c_str() );\n\n    tstring t_tmname( tmname.begin(), tmname.end() );\n    SharedPtr_T&lt;TransportableMessage&gt; tm_obj( new TransportableMessage( t_tmname, 0 ) );\n\n    pugi::xml_node fields = tmBase.child(\"FS\");\n    for( pugi::xml_node field = fields.first_child(); field; field = field.next_sibling(\"field\") )\n    {\n        tm_obj-&gt;addField( arc::util::TmFieldFactory( field.child_value(\"N\"), field.child_value(\"T\"), field.child_value(\"V\") ) );\n    }\n\n    return tm_obj;\n}\n</code></pre>\n", "Tags": "<c++><visual-studio-2008>", "OwnerUserId": "509614", "AnswerCount": "1"}, "11851757": {"ParentId": "11851468", "CommentCount": "0", "Body": "<p>Falling off the body of a function without returning something is not an  error, it is undefined behavior; see 6.3.3 The <code>return</code> statement [stmt.return] \u00a73:</p>\n<blockquote>\n<p id=\"so_11851468_11851757_0\">Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior in a value-returning function.</p>\n</blockquote>\n", "OwnerUserId": "252000", "PostTypeId": "2", "Id": "11851757", "Score": "5", "CreationDate": "2012-08-07T18:17:33.203", "LastActivityDate": "2012-08-07T18:17:33.203"}, "bq_ids": {"n4140": {"so_11851468_11851757_0": {"section_id": 3913, "quality": 1.0, "length": 12}}, "n3337": {"so_11851468_11851757_0": {"section_id": 3773, "quality": 1.0, "length": 12}}, "n4659": {"so_11851468_11851757_0": {"section_id": 4799, "quality": 0.75, "length": 9}}}});