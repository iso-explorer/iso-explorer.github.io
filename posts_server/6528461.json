post_cb({"6528461": {"CommentCount": "3", "AcceptedAnswerId": "6528485", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2011-06-29T23:34:48.993", "LastActivityDate": "2015-08-07T21:27:02.733", "LastEditDate": "2015-08-07T21:27:02.733", "ViewCount": "1250", "FavoriteCount": "0", "Title": "Freeing abstract class pointers", "Id": "6528461", "Score": "1", "Body": "<p>In C++ I have a <code>class A</code> that has an abstract class pointer to allow for polymorphism contained in a <code>class B</code>, I have another pointer to an abstract <code>class C</code> that allocates a concrete instance of a child class of <code>class B</code> into that memory and I need to call a cleanup (see question below) function from <code>class C</code> to deallocate the memory taken by the child class of <code>class B</code> that I allocated from the heap, the problem is I can't guarantee I have access to the cleanup function because I only have a pointer to <code>class C</code> which I can't just copy, because it could be gone by the time I call need to destroy the containing <code>class A</code>. </p>\n<p>In order to solve the problem of not having access to the cleanup function can I call delete on the <code>class A</code> pointer even though I'm pointing to a child class? <strong>Does C++ new also store heap block size like malloc so that you can just delete memory referenced by a pointer to an abstract class like this?</strong> If not is there another way to organize the program that allows me to handle the situation?</p>\n", "Tags": "<c++><virtual><new-operator><abstract><delete-operator>", "OwnerUserId": "423410", "AnswerCount": "2"}, "6528485": {"ParentId": "6528461", "CommentCount": "4", "Body": "<p>I'm using my crystal ball because it's hard to follow your question but you probably need virtual destructors.</p>\n", "OwnerUserId": "650405", "PostTypeId": "2", "Id": "6528485", "Score": "6", "CreationDate": "2011-06-29T23:39:12.530", "LastActivityDate": "2011-06-29T23:39:12.530"}, "bq_ids": {"n4140": {"so_6528461_6528590_0": {"section_id": 6107, "quality": 0.88, "length": 22}}, "n3337": {"so_6528461_6528590_0": {"section_id": 5873, "quality": 0.88, "length": 22}}, "n4659": {"so_6528461_6528590_0": {"section_id": 7604, "quality": 0.88, "length": 22}}}, "6528590": {"ParentId": "6528461", "CommentCount": "1", "Body": "<p>The standard states (\u00a75.3.5 \u00b63):</p>\n<blockquote>\n<p id=\"so_6528461_6528590_0\">In the first alternative (<em>delete object</em>), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<p>If I understood correctly, you have an object of some derived type, and you hold a pointer to it whose static type is one of its base classes; so, you're ok, as far as you have <code>virtual</code> destructors.</p>\n<hr>\n<p><em><strong>Edit</strong></em></p></hr> well, I was way too slow :P\n", "OwnerUserId": "214671", "PostTypeId": "2", "Id": "6528590", "Score": "4", "CreationDate": "2011-06-29T23:53:58.853", "LastActivityDate": "2011-06-29T23:53:58.853"}});