post_cb({"11336379": {"ParentId": "6438086", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-07-04T23:36:24.350", "Score": "30", "LastEditorUserId": "187690", "LastEditDate": "2013-09-23T18:54:43.360", "Id": "11336379", "OwnerUserId": "187690", "Body": "<p>It is probably worth adding that an insert iterator of any kind (<code>std::back_insert_iterator</code>, <code>std::front_insert_iterator</code>, <code>std::insert_iterator</code>) is guaranteed to remain valid as long as all insertions are performed through this iterator and no other iterator-invalidating event occurs.</p>\n<p>For example, when you are performing a series of insertion operations into a <code>std::vector</code> by using <code>std::insert_iterator</code> it is quite possible that the vector will experience a reallocation event, which will invalidate all iterators that \"point\" into that vector. However, the insert iterator in question is guaranteed to remain valid, i.e. you can safely continue the sequence of insertions. There's no need to worry about triggering vector reallocation at all.</p>\n<p>This, again, applies only to insertions performed through the insert iterator itself. If iterator-invalidating event is triggered by some independent action on the container, then the insert iterator becomes invalidated as well in accordance with the general rules.</p>\n<p>For example, this code</p>\n<pre><code>std::vector&lt;int&gt; v(10);\nstd::vector&lt;int&gt;::iterator it = v.begin() + 5;\nstd::insert_iterator&lt;std::vector&lt;int&gt; &gt; it_ins(v, it);\n\nfor (unsigned n = 20; n &gt; 0; --n)\n  *it_ins++ = rand();\n</code></pre>\n<p>is guaranteed to perform a valid sequence of insertions into the vector, even if the vector \"decides\" to reallocate somewhere in the middle of this process.</p>\n", "LastActivityDate": "2013-09-23T18:54:43.360"}, "22264195": {"ParentId": "6438086", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-03-08T02:24:59.837", "Score": "15", "LastEditorUserId": "3239559", "LastEditDate": "2014-03-08T11:59:45.440", "Id": "22264195", "OwnerUserId": "3239559", "Body": "<p>Since this question draws so many votes and kind of becomes an FAQ, I guess it would be better to write a separate answer to mention one significant difference between C++03 and C++11 regarding the impact of <code>std::vector</code>'s insertion operation on the validity of iterators and references with respect to <code>reserve()</code> and <code>capacity()</code>, which the most upvoted answer failed to notice.</p>\n<p>C++ 03:</p>\n<blockquote>\n<p id=\"so_6438086_22264195_0\">Reallocation invalidates all the references, pointers, and iterators\n  referring to the elements in the sequence. It is guaranteed that no\n  reallocation takes place during insertions that happen after a call to\n  reserve() until the time when an insertion would make the size of the\n  vector <strong>greater than the size specified in the most recent call to\n  reserve()</strong>.</p>\n</blockquote>\n<p>C++11:</p>\n<blockquote>\n<p id=\"so_6438086_22264195_1\">Reallocation invalidates all the references, pointers, and iterators\n  referring to the elements in the sequence. It is guaranteed that no\n  reallocation takes place during insertions that happen after a call to\n  reserve() until the time when an insertion would make the size of the\n  vector <strong>greater than the value of capacity()</strong>.</p>\n</blockquote>\n<p>So in C++03, it is not \"<code>unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated)</code>\" as mentioned in the other answer, instead, it should be \"<code>greater than the size specified in the most recent call to reserve()</code>\". This is one thing that C++03 differs from C++11. In C++03, once an <code>insert()</code> causes the size of the vector to reach the value specified in the previous <code>reserve()</code> call (which could well be smaller than the current <code>capacity()</code> since a <code>reserve()</code> could result a bigger <code>capacity()</code> than asked for), any subsequent <code>insert()</code> could cause reallocation and invalidate all the iterators and references. In C++11, this won't happen and you can always trust <code>capacity()</code> to know with certainty that the next reallocation won't take place before the size overpasses <code>capacity()</code>.</p>\n<p>In conclusion, if you are working with a C++03 vector and you want to make sure a reallocation won't happen when you perform insertion, it's the value of the argument you previously passed to <code>reserve()</code> that you should check the size against, not the return value of a call to <code>capacity()</code>, otherwise you may get yourself surprised at a \"<em>premature</em>\" reallocation.</p>\n", "LastActivityDate": "2014-03-08T11:59:45.440"}, "6438087": {"ParentId": "6438086", "PostTypeId": "2", "CommentCount": "28", "CreationDate": "2011-06-22T10:01:57.873", "Score": "347", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:34:37.587", "Id": "6438087", "OwnerUserId": "560648", "Body": "<p><strong>C++03</strong> (Source: <a href=\"http://kera.name/articles/2011/06/iterator-invalidation-rules/\" rel=\"noreferrer\">Iterator Invalidation Rules (C++03)</a>)</p>\n<hr>\n<h1>Insertion</h1>\n<p><em>Sequence containers</em></p>\n<ul>\n<li><code>vector</code>: all iterators and references before the point of insertion are unaffected, unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated) [23.2.4.3/1]</li>\n<li><code>deque</code>: all iterators and references are invalidated, unless the inserted member is at an end (front or back) of the deque (in which case all iterators are invalidated, but references to elements are unaffected) [23.2.1.3/1]</li>\n<li><code>list</code>: all iterators and references unaffected [23.2.2.3/1]</li>\n</ul>\n<p><em>Associative containers</em></p>\n<ul>\n<li><code>[multi]{set,map}</code>: all iterators and references unaffected [23.1.2/8]</li>\n</ul>\n<p><em>Container adaptors</em></p>\n<ul>\n<li><code>stack</code>: inherited from underlying container</li>\n<li><code>queue</code>: inherited from underlying container</li>\n<li><code>priority_queue</code>: inherited from underlying container</li>\n</ul>\n<hr>\n<h1>Erasure</h1>\n<p><em>Sequence containers</em></p>\n<ul>\n<li><code>vector</code>: every iterator and reference after the point of erase is invalidated [23.2.4.3/3]</li>\n<li><code>deque</code>: all iterators and references are invalidated, unless the erased members are at an end (front or back) of the deque (in which case only iterators and references to the erased members are invalidated) [23.2.1.3/4]</li>\n<li><code>list</code>: only the iterators and references to the erased element is invalidated [23.2.2.3/3]</li>\n</ul>\n<p><em>Associative containers</em></p>\n<ul>\n<li><code>[multi]{set,map}</code>: only iterators and references to the erased elements are invalidated [23.1.2/8]</li>\n</ul>\n<p><em>Container adaptors</em></p>\n<ul>\n<li><code>stack</code>: inherited from underlying container</li>\n<li><code>queue</code>: inherited from underlying container</li>\n<li><code>priority_queue</code>: inherited from underlying container</li>\n</ul>\n<hr>\n<h1>Resizing</h1>\n<ul>\n<li><code>vector</code>: as per insert/erase [23.2.4.2/6]</li>\n<li><code>deque</code>: as per insert/erase [23.2.1.2/1]</li>\n<li><code>list</code>: as per insert/erase [23.2.2.2/1]</li>\n</ul>\n<hr>\n<h2>Note 1</h2>\n<blockquote>\n<p id=\"so_6438086_6438087_0\"><strong>Unless otherwise specified</strong> (either\n  explicitly or by defining a function\n  in terms of other functions), invoking\n  a container member function or passing\n  a container as an argument to <strong>a\n  library function shall not invalidate\n  iterators</strong> to, or change the values of,\n  objects within that container.\n  [23.1/11]</p>\n</blockquote>\n<h2>Note 2</h2>\n<p><a href=\"https://stackoverflow.com/questions/6440392/end-iterator-invalidation-rules\">It's not clear in C++2003 whether \"end\" iterators are subject to the above rules</a>; you should assume, anyway, that they are (as this is the case in practice).</p>\n<h2>Note 3</h2>\n<p>The rules for invalidation of pointers are the sames as the rules for invalidation of references.</p>\n</hr></hr></hr></hr>", "LastActivityDate": "2011-11-01T18:55:24.020"}, "6438086": {"CommentCount": "0", "AcceptedAnswerId": "6442829", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-06-22T10:01:49.870", "LastActivityDate": "2016-02-23T18:10:31.517", "LastEditDate": "2017-05-23T10:31:12.887", "ViewCount": "79974", "FavoriteCount": "278", "Title": "Iterator invalidation rules", "Id": "6438086", "Score": "391", "Body": "<p>What are the iterator invalidation rules for C++ containers?</p>\n<p>Preferably in a summary list format.</p>\n<p><sub>\n<em>(Note: This is meant to be an entry to <a href=\"https://stackoverflow.com/questions/tagged/c++-faq\">Stack Overflow's C++ FAQ</a>. If you want to critique the idea of providing an FAQ in this form, then <a href=\"https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag\">the posting on meta that started all this</a> would be the place to do that. Answers to that question are monitored in the <a href=\"http://chat.stackoverflow.com/rooms/10/c-lounge\">C++ chatroom</a>, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)</em>\n</sub></p>\n", "Tags": "<c++><c++11><iterator><c++03><c++-faq>", "OwnerUserId": "560648", "AnswerCount": "4"}, "6442829": {"ParentId": "6438086", "PostTypeId": "2", "CommentCount": "23", "CreationDate": "2011-06-22T15:53:12.653", "Score": "283", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:31:12.887", "Id": "6442829", "OwnerUserId": "560648", "Body": "<p><strong>C++11</strong> (Source: <a href=\"http://kera.name/articles/2011/06/iterator-invalidation-rules-c0x/\" rel=\"noreferrer\">Iterator Invalidation Rules (C++0x)</a>)</p>\n<hr>\n<h1>Insertion</h1>\n<p><em>Sequence containers</em></p>\n<ul>\n<li><code>vector</code>: all iterators and references before the point of insertion are unaffected, unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated) [23.3.6.5/1]</li>\n<li><code>deque</code>: all iterators and references are invalidated, unless the inserted member is at an end (front or back) of the deque (in which case all iterators are invalidated, but references to elements are unaffected) [23.3.3.4/1]</li>\n<li><code>list</code>: all iterators and references unaffected [23.3.5.4/1]</li>\n<li><code>forward_list</code>: all iterators and references unaffected <em>(applies to <code>insert_after</code>)</em> [23.3.4.5/1]</li>\n<li><code>array</code>: <em>(n/a)</em></li>\n</ul>\n<p><em>Associative containers</em></p>\n<ul>\n<li><code>[multi]{set,map}</code>: all iterators and references unaffected [23.2.4/9]</li>\n</ul>\n<p><em>Unsorted associative containers</em></p>\n<ul>\n<li><code>unordered_[multi]{set,map}</code>: all iterators invalidated when rehashing occurs, but references unaffected [23.2.5/8]. Rehashing does not occur if the insertion does not cause the container's size to exceed <code>z * B</code> where <code>z</code> is the maximum load factor and <code>B</code> the current number of buckets. [23.2.5/14]</li>\n</ul>\n<p><em>Container adaptors</em></p>\n<ul>\n<li><code>stack</code>: inherited from underlying container</li>\n<li><code>queue</code>: inherited from underlying container</li>\n<li><code>priority_queue</code>: inherited from underlying container</li>\n</ul>\n<hr>\n<h1>Erasure</h1>\n<p><em>Sequence containers</em></p>\n<ul>\n<li><code>vector</code>: every iterator and reference at or after the point of erase is invalidated [23.3.6.5/3]</li>\n<li><code>deque</code>: erasing the last element invalidates only iterators and references to the erased elements and the past-the-end iterator; erasing the first element invalidates only iterators and references to the erased elements; erasing any other elements invalidates all iterators and references (including the past-the-end iterator) [23.3.3.4/4]</li>\n<li><code>list</code>: only the iterators and references to the erased element is invalidated [23.3.5.4/3]</li>\n<li><code>forward_list</code>: only the iterators and references to the erased element is invalidated <em>(applies to <code>erase_after</code>)</em> [23.3.4.5/1]</li>\n<li><code>array</code>: <em>(n/a)</em></li>\n</ul>\n<p><em>Associative containers</em></p>\n<ul>\n<li><code>[multi]{set,map}</code>: only iterators and references to the erased elements are invalidated [23.2.4/9]</li>\n</ul>\n<p><em>Unordered associative containers</em></p>\n<ul>\n<li><code>unordered_[multi]{set,map}</code>: only iterators and references to the erased elements are invalidated [23.2.5/13]</li>\n</ul>\n<p><em>Container adaptors</em></p>\n<ul>\n<li><code>stack</code>: inherited from underlying container</li>\n<li><code>queue</code>: inherited from underlying container</li>\n<li><code>priority_queue</code>: inherited from underlying container</li>\n</ul>\n<hr>\n<h1>Resizing</h1>\n<ul>\n<li><code>vector</code>: as per insert/erase [23.3.6.5/12]</li>\n<li><code>deque</code>: as per insert/erase [23.3.3.3/3]</li>\n<li><code>list</code>: as per insert/erase [23.3.5.3/1]</li>\n<li><code>forward_list</code>: as per insert/erase [23.3.4.5/25]</li>\n<li><code>array</code>: (n/a)</li>\n</ul>\n<hr>\n<h2>Note 1</h2>\n<blockquote>\n<p id=\"so_6438086_6442829_0\"><strong>Unless otherwise specified</strong> (either\n  explicitly or by defining a function\n  in terms of other functions), invoking\n  a container member function or passing\n  a container as an argument to <strong>a\n  library function shall not invalidate\n  iterators</strong> to, or change the values of,\n  objects within that container.\n  [23.2.1/11]</p>\n</blockquote>\n<h2>Note 2</h2>\n<blockquote>\n<p id=\"so_6438086_6442829_1\"><strong>no swap() function invalidates any\n  references, pointers, or iterators</strong>\n  referring to the elements of the\n  containers being swapped. [ Note: <strong>The\n  end() iterator</strong> does not refer to any\n  element, so it <strong>may be invalidated</strong>.\n  \u2014end note ] [23.2.1/10]</p>\n</blockquote>\n<h2>Note 3</h2>\n<p>Other than the above caveat regarding <code>swap()</code>, <a href=\"https://stackoverflow.com/questions/6440392/end-iterator-invalidation-rules\">it's not clear whether \"end\" iterators are subject to the above listed per-container rules</a>; you should assume, anyway, that they are.</p>\n<h2>Note 4</h2>\n<p><code>vector</code> and all <em>unordered associative containers</em> support <code>reserve(n)</code> which guarantees that no automatic resizing will occur at least until the size of the container grows to <code>n</code>. Caution should be taken with <em>unordered associative containers</em> because a future proposal will allow the specification of a minimum load factor, which would allow rehashing to occur on <code>insert</code> after enough <code>erase</code> operations reduce the container size below the minimum; the guarantee should be considered potentially void after an <code>erase</code>.</p>\n</hr></hr></hr></hr>", "LastActivityDate": "2015-05-26T16:13:39.620"}, "bq_ids": {"n4140": {"so_6438086_6442829_1": {"section_id": 712, "quality": 0.782608695652174, "length": 18}, "so_6438086_22264195_0": {"section_id": 972, "quality": 0.7714285714285715, "length": 27}, "so_6438086_6442829_0": {"section_id": 713, "quality": 0.9259259259259259, "length": 25}, "so_6438086_6438087_0": {"section_id": 713, "quality": 0.9259259259259259, "length": 25}, "so_6438086_22264195_1": {"section_id": 972, "quality": 0.9354838709677419, "length": 29}}, "n3337": {"so_6438086_6442829_1": {"section_id": 701, "quality": 0.782608695652174, "length": 18}, "so_6438086_22264195_0": {"section_id": 961, "quality": 0.8285714285714286, "length": 29}, "so_6438086_6442829_0": {"section_id": 702, "quality": 0.9259259259259259, "length": 25}, "so_6438086_6438087_0": {"section_id": 702, "quality": 0.9259259259259259, "length": 25}, "so_6438086_22264195_1": {"section_id": 961, "quality": 1.0, "length": 31}}, "n4659": {"so_6438086_6442829_1": {"section_id": 741, "quality": 0.782608695652174, "length": 18}, "so_6438086_22264195_0": {"section_id": 1034, "quality": 0.7714285714285715, "length": 27}, "so_6438086_6442829_0": {"section_id": 742, "quality": 0.9259259259259259, "length": 25}, "so_6438086_6438087_0": {"section_id": 742, "quality": 0.9259259259259259, "length": 25}, "so_6438086_22264195_1": {"section_id": 1034, "quality": 0.9354838709677419, "length": 29}}}});