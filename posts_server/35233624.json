post_cb({"35233822": {"CommentCount": "0", "Body": "<p>In C++17 you'll could do it with folds as:</p>\n<pre><code>template&lt;typename... Ts&gt;\nvoid expander(Ts&amp;&amp;... ts) {\n    (..., std::forward&lt;Ts&gt;(ts)());\n}\n</code></pre>\n<p><a href=\"http://melpon.org/wandbox/permlink/maB8yFGAn7QrRANc\" rel=\"nofollow\"><strong>Live Demo</strong></a></p>\n", "CreationDate": "2016-02-05T21:27:03.920", "ParentId": "35233624", "Id": "35233822", "LastActivityDate": "2016-02-05T21:27:03.920", "PostTypeId": "2", "Score": "3", "OwnerUserId": "2352671"}, "35250043": {"CommentCount": "2", "Body": "<p>You can do it as follows:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename... Ts&gt;\nvoid expander(Ts&amp;&amp;... ts)\n{\n    int dummy[sizeof...(Ts)] = {(std::forward&lt;Ts&gt;(ts)(), 0)...};\n}\nvoid f()\n{\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n}\nint main()\n{\n    expander(f, f, f);\n    expander();\n}\n</code></pre>\n<p><a href=\"https://ideone.com/BzNXhD\" rel=\"nofollow\">https://ideone.com/BzNXhD</a></p>\n", "CreationDate": "2016-02-07T05:21:04.893", "ParentId": "35233624", "Id": "35250043", "LastActivityDate": "2016-02-07T05:21:04.893", "PostTypeId": "2", "Score": "1", "OwnerUserId": "257645"}, "35233757": {"CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_35233624_35233757_0\">Can we do this without introducing a typedef?</p>\n</blockquote>\n<p>Without a typedef, but with a variable</p>\n<pre><code>template&lt;typename... Ts&gt;\nvoid expander(Ts&amp;&amp;... ts)\n{\n    int dummy[] = {0, (std::forward&lt;Ts&gt;(ts)(), void(), 0)...};\n    (void) dummy;\n}\n</code></pre>\n", "CreationDate": "2016-02-05T21:22:23.827", "ParentId": "35233624", "Id": "35233757", "LastActivityDate": "2016-02-05T21:22:23.827", "PostTypeId": "2", "Score": "5", "OwnerUserId": "2684539"}, "bq_ids": {"n4140": {"so_35233624_35234036_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6001}}, "n3337": {"so_35233624_35234036_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5769}}}, "35233624": {"CreationDate": "2016-02-05T21:13:43.650", "ViewCount": "281", "Id": "35233624", "AcceptedAnswerId": "35234036", "Score": "5", "Title": "Variadic expander without a typedef", "CommentCount": "1", "Body": "<p>One trick often used to perform a variadic parameter expansion is using an un-sized array typedef in combination with the comma operator, like below:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename... Ts&gt;\nvoid expander(Ts&amp;&amp;... ts)\n{\n    using expand = int[];\n    (void)expand{0, (std::forward&lt;Ts&gt;(ts)(), 0)...};\n}\nvoid f()\n{\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n}\nint main()\n{\n    expander(f, f);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a4131fd862e185ef\" rel=\"nofollow\"><kbd>Live on Coliru</kbd></a></p>\n<p><strong>Can we do this without introducing a typedef?</strong> If I try directly</p>\n<pre><code>(void)int[]{0, (std::forward&lt;Ts&gt;(ts)(), 0)...};\n</code></pre>\n<p>gcc/clang spit out</p>\n<blockquote>\n<p id=\"so_35233624_35233624_0\">error: expected primary-expression before 'int'</p>\n</blockquote>\n<p>and if I try to parenthesize, the code compiles but I believe it is non-standard compliant:</p>\n<blockquote>\n<p id=\"so_35233624_35233624_1\">warning: ISO C++ forbids compound-literals [-Wpedantic]</p>\n</blockquote>\n", "Tags": "<c++><templates><c++11><variadic-templates>", "LastActivityDate": "2016-02-07T05:21:04.893", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "3093378"}, "35234036": {"CommentCount": "0", "Body": "<p>In this expression</p>\n<pre><code>(void)int[]{0, (std::forward&lt;Ts&gt;(ts)(), 0)...};\n</code></pre>\n<p>you're trying to use a functional notation cast to create a temporary array. That won't work because the language only allows the functional notation to be used with either a <em>simple-type-specifier</em> or a <em>typename-specifier</em>.</p>\n<p>From <a href=\"http://eel.is/c++draft/expr.type.conv#3\"><em>[expr.type.conv]/3</em></a></p>\n<blockquote>\n<p id=\"so_35233624_35234036_0\">Similarly, a <em>simple-type-specifier</em> or <em>typename-specifier</em> followed by a <em>braced-init-list</em> creates a temporary object of the specified type direct-list-initialized (8.5.4) with the specified <em>braced-init-list</em>, and its value is that temporary object as a prvalue.</p>\n</blockquote>\n<p>And if you go lookup the definition of <em>simple-type-specifier</em> under <a href=\"http://eel.is/c++draft/dcl.type.simple#1\"><em>[dcl.type.simple]</em></a>, it doesn't include anything with array brackets. In fact, it doesn't even include anything that's more than one word. This is why writing <code>int(1)</code> is valid, but <code>signed int(1)</code> isn't.</p>\n<p>So, with C++11/14 you need a <code>typedef</code> or declare an array variable. But, with a C++1z compiler, you can make use of fold expressions and avoid both</p>\n<pre><code>template&lt;typename... Ts&gt;\nvoid expander(Ts&amp;&amp;... ts)\n{\n    (void(std::forward&lt;Ts&gt;(ts)()), ...);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/4ba1369ac6cb93fa\">Live demo</a></p>\n", "CreationDate": "2016-02-05T21:41:22.630", "ParentId": "35233624", "Id": "35234036", "LastActivityDate": "2016-02-05T21:41:22.630", "PostTypeId": "2", "Score": "5", "OwnerUserId": "241631"}});