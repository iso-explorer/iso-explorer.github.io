post_cb({"42608873": {"Id": "42608873", "PostTypeId": "2", "Body": "<p>Your professor made a mistake of writing things too close to each other:)<br>\n<code>0A</code>, <code>0B</code>, <code>0C</code> and <code>0D</code> are the addresses of four bytes of your integer. Contiguous memory implies that address of your whole integer will then be <code>0A</code>. That's it.<br>\nDo <strong>NOT</strong> concatenate the four of them, that makes no sense at all.  </br></br></p>\n<p>Instead, to get the address of the second byte in the contiguous memory, you just add 1 to the address of the first byte: <code>0A+1=0B</code>.</p>\n<p>What your code printed out is the address of your variable <code>a</code>; In real life addresses tend to be ugly due to virtual memory, paging, lots of stuff loaded and what not. You can <code>reinterpret_cast</code> it to <code>char*</code> and walk through bytes of your integer:    </p>\n<pre><code>char* b = reinterpret_cast&lt;char*&gt;(&amp;a); // now *b is the first byte\nfor(int i=0;i&lt;sizeof(int);i++)\n    std::cout&lt;&lt; static_cast&lt;int&gt;(*b++) &lt;&lt;' ';\n</code></pre>\n<p>It should output three zeroes and a 5 (in a platform-dependent order)  </p>\n", "LastEditorUserId": "6350858", "LastActivityDate": "2017-03-05T13:52:29.797", "Score": "0", "CreationDate": "2017-03-05T13:25:08.563", "ParentId": "42608320", "CommentCount": "0", "OwnerUserId": "6350858", "LastEditDate": "2017-03-05T13:52:29.797"}, "42608376": {"Id": "42608376", "PostTypeId": "2", "Body": "<p>All built-in types, including integers, occupy consecutive bytes in memory.</p>\n<p>When you print <code>&amp;a</code> to <code>cout</code> you get the address of the initial byte of the integer. The other three bytes are stored behind it. In your case, the next three bytes will be at <code>0x7fffba2e6c3d</code>, <code>0x7fffba2e6c3e</code>, and <code>0x7fffba2e6c3f</code>.</p>\n", "LastActivityDate": "2017-03-05T12:30:33.020", "CommentCount": "0", "CreationDate": "2017-03-05T12:30:33.020", "ParentId": "42608320", "Score": "2", "OwnerUserId": "335858"}, "42608320": {"ViewCount": "91", "Body": "<p>To start of, I am talking about the 32-bit architecture. My professor gave us an example of how the address of a C/C++ 32-bit integer may be stored and have an address as <code>0A0B0C0D</code> with the first byte of the integer being stored at <code>0x0A</code>, the second at <code>0x0B</code>, the third at <code>0x0C</code>, and the fourth at <code>0x0D</code>. However, I tried in C++ the following code:</p>\n<pre><code>#include &lt;iostream&gt;\nint main(){\n  int a = 5;\n  std::cout &lt;&lt; &amp;a;\n}\n</code></pre>\n<p>and I got <code>0x7fffba2e6c3c</code>. However, this doesn't look like the bytes are contiguous like the example that the professor gave us. my question is, why didn't the compiler store the 4 bytes of the integer in contiguous memory addresses instead of storing every byte from the integer in a different address?</p>\n", "Title": "Is it a must that an integer must be stored in contiguous memory addresses?", "CreationDate": "2017-03-05T12:24:55.943", "LastActivityDate": "2017-03-05T13:57:23.510", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "Id": "42608320", "Score": "3", "OwnerUserId": "3508551", "Tags": "<c++><memory><memory-address>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_42608320_42608531_1": {"length": 9, "quality": 1.0, "section_id": 5794}}, "n3337": {"so_42608320_42608531_1": {"length": 9, "quality": 1.0, "section_id": 5567}}, "n4659": {"so_42608320_42608531_1": {"length": 9, "quality": 1.0, "section_id": 7253}}}, "42608679": {"Id": "42608679", "PostTypeId": "2", "Body": "<p>It is not really mandatory, however, if you do it any other way, the memory i/o performance of the computer system/application won't be as optimal and as efficient. </p>\n<p>Storing application data in contiguous regions in memory makes memory level access optimizations possible. Why? Because memory itself is designed to perform best when memory access operations point to contiguous memory addresses. </p>\n", "LastEditorUserId": "191064", "LastActivityDate": "2017-03-05T13:10:08.843", "Score": "0", "CreationDate": "2017-03-05T13:04:08.490", "ParentId": "42608320", "CommentCount": "0", "OwnerUserId": "191064", "LastEditDate": "2017-03-05T13:10:08.843"}, "42608531": {"Id": "42608531", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_42608320_42608531_0\">Is it a must that an integer must be stored in contiguous memory addresses?</p>\n</blockquote>\n<p>Yes, because the C++ standard, \u00a71.8/5, says:</p>\n<blockquote>\n<p id=\"so_42608320_42608531_1\">An object of trivially copyable or standard-layout type (...) shall\n  occupy contiguous bytes of storage.</p>\n</blockquote>\n<p>As for your example,</p>\n<blockquote>\n<p id=\"so_42608320_42608531_2\">However, this doesn't look like the bytes are contiguous like the example that the professor gave us.</p>\n</blockquote>\n<p>You are misinterpreting the output. What you see is just the single address where the <code>int</code> begins.</p>\n", "LastActivityDate": "2017-03-05T12:48:07.847", "CommentCount": "0", "CreationDate": "2017-03-05T12:48:07.847", "ParentId": "42608320", "Score": "3", "OwnerUserId": "3313064"}, "42608396": {"Id": "42608396", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_42608320_42608396_0\">and have an address as 0A0B0C0D with the first byte of the integer being stored at 0x0A</p>\n</blockquote>\n<p>There appears to be some confusion here.</p>\n<p>If the first byte of an integer is stored at 0x0A, then the address of the entire integer is 0x0A. 0A0B0C0D appears to be some sort of concatenation of addresses of the bytes that are part of that integer.</p>\n<p>Or conversely, if the address of the integer is 0x0A0B0C0D, then the address of the first byte is also 0x0A0B0C0D, and the second would be 0x0A0B0C0E and so on.</p>\n<blockquote>\n<p id=\"so_42608320_42608396_1\">I got 0x7fffba2e6c3c. However, this doesn't look like the bytes are contiguous</p>\n</blockquote>\n<p>You've printed the address of the integer. You cannot tell from an address whether the object at that address is contiguous or not. For example, if you had gotten 0x0A like in your professors example, how would you have determined that the successive byte is or isn't 0x0B?</p>\n<p>You cannot make such conclusion from the address, but you simply have to assume the contiguity.</p>\n<blockquote>\n<p id=\"so_42608320_42608396_2\">Is it a must that an integer must be stored in contiguous memory addresses?</p>\n</blockquote>\n<p>Yes. All objects are contiguous in memory. (Note that an object can contain addresses of separate objects, that are not necessarily stored contiguously in relation to the object that holds the pointer. So, for example a linked list object does not store the elements of the list contiguously, but each node of the list are by themselves contiguous).</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2017-03-05T13:57:23.510", "Score": "6", "CreationDate": "2017-03-05T12:32:36.653", "ParentId": "42608320", "CommentCount": "0", "OwnerUserId": "2079303", "LastEditDate": "2017-03-05T13:57:23.510"}});