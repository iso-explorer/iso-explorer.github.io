post_cb({"20455655": {"ParentId": "20455382", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Here are the relevant bits of the C++ standard that are involved:</p>\n<blockquote>\n<p id=\"so_20455382_20455655_0\">[dcl.init]/16, bullet 6, sub-bullet 1: If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered.... <strong>If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</strong> [emphasis added]</p>\n</blockquote>\n<p>In other words, it doesn't matter if a compiler optimization <em>could</em> elide the copy, the initialization is ill-formed because there are no applicable constructors. Of course, once you make the copy constuctor public, the following section applies:</p>\n<blockquote>\n<p id=\"so_20455382_20455655_1\">[class.copy]/31: When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the copy/move constructor and/or destructor for the object have side effects.... This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<p id=\"so_20455382_20455655_2\">bullet 3: when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move</p>\n</blockquote>\n", "OwnerUserId": "2905299", "LastEditorUserId": "2905299", "LastEditDate": "2013-12-11T04:43:28.590", "Id": "20455655", "Score": "4", "CreationDate": "2013-12-08T16:20:02.063", "LastActivityDate": "2013-12-11T04:43:28.590"}, "20455382": {"CommentCount": "3", "ViewCount": "299", "PostTypeId": "1", "LastEditorUserId": "36938", "CreationDate": "2013-12-08T15:53:09.323", "LastActivityDate": "2013-12-18T19:10:52.163", "Title": "Why is a public copy constructor required even if it is not invoked?", "AcceptedAnswerId": "20455655", "LastEditDate": "2013-12-18T19:10:52.163", "Id": "20455382", "Score": "8", "Body": "<p>Having a public copy constructor will make the little program \ncompile, but not showing the side effect \"Copy\".</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass X\n{\n    public:\n    X(int) { std::cout &lt;&lt; \"Construct\" &lt;&lt; std::endl; }\n\n    // Having a public copy constructor will make the little program \n    // compile, but not showing the side effect \"Copy\".\n\n    private:\n    X(const X&amp;) { std::cout &lt;&lt; \"Copy\" &lt;&lt; std::endl; }\n\n    private:\n    X&amp; operator = (const X&amp;);\n};\n\nint main() {\n    X x = 1;\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><oop><constructor>", "OwnerUserId": "2249683", "AnswerCount": "4"}, "20455496": {"ParentId": "20455382", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You initialisation is being optimised by the compiler down to:</p>\n<pre><code>X x(1)\n</code></pre>\n<p>This is a kind of copy elision, and is allowed by the standard, even though it can remove side effects like you saw.</p>\n<p>From the C++03 standard section 12.8:</p>\n<blockquote>\n<p id=\"so_20455382_20455496_0\">When certain criteria are met, an implementation is allowed to omit\n  the copy construction of a class object, even if the copy constructor\n  and/or destructor for the object have side effects. In such cases, the\n  implemen-tation treats the source and target of the omitted copy\n  operation as simply two different ways of referring to the same\n  object, and the destruction of that object occurs at the later of the\n  times when the two objects would have been destroyed without the\n  optimization. 111) This elision of copy operations is permitted in the\n  following circumstances (which may be combined to eliminate multiple\n  copies): \n     \u2014 in areturnstatement in a function with a class return type,\n  when the expression is the name of a non-volatile automatic object\n  with the same cv-unqualified type as the function return type, the\n  copy operation can be omitted by constructing the automatic object\n  directly into the function\u2019s return value \n     \u2014 when a temporary class&gt; object that has not been bound to a reference (12.2) \n  would be copied to a class object with the same cv-unqualified type, the copy\n  operation can be omitted by constructing the tempo-rary object\n  directly into the target of the omitted copy</p>\n</blockquote>\n<p>The second case is what we have here.</p>\n", "OwnerUserId": "2428400", "LastEditorUserId": "2428400", "LastEditDate": "2013-12-08T16:11:19.397", "Id": "20455496", "Score": "2", "CreationDate": "2013-12-08T16:06:00.153", "LastActivityDate": "2013-12-08T16:11:19.397"}, "20455447": {"ParentId": "20455382", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>My best guess is that this is a compiler optimization. There is a valid path to declaring an object this way if you have a copy constructor. Consider doing this explicitly:</p>\n<pre><code>int main() {\n    X x(X(1));\n    return 0;\n}\n</code></pre>\n<p>Or more explicitly:</p>\n<pre><code>int main() {\n    X intermediate(1);\n    X x(intermediate);\n    return 0;\n}\n</code></pre>\n<p>So instead of using <code>operator=</code>, it knows you are trying to initialize your object since the declaration. In essence, the compiler is being \"smart\". Finally, it optimizes this again to this step:</p>\n<pre><code>int main() {\n    X x(1);\n    return 0;\n}\n</code></pre>\n<p>Therefore, after the compiler figures out \"what you were trying to do\" this becomes a standard initialization of the object.</p>\n<p><strong>EDIT</strong></p>\n<p>For completeness, notice that if you try this:</p>\n<pre><code>int main() {\n    X x = 1;\n    x = 2;\n    return 0;\n}\n</code></pre>\n<p>You will see the issue with private <code>operator=</code>. Explicitly, this is important to notice that <code>operator=</code> is never actually used in the original initialization question above even though <code>=</code> appears in the code.</p>\n", "OwnerUserId": "388182", "LastEditorUserId": "388182", "LastEditDate": "2013-12-08T16:13:53.407", "Id": "20455447", "Score": "2", "CreationDate": "2013-12-08T16:00:19.083", "LastActivityDate": "2013-12-08T16:13:53.407"}, "bq_ids": {"n4140": {"so_20455382_20455655_0": {"section_id": 3296, "quality": 0.8148148148148148, "length": 22}, "so_20455382_20455496_0": {"section_id": 480, "quality": 0.9067796610169492, "length": 107}, "so_20455382_20455655_1": {"section_id": 480, "quality": 0.9166666666666666, "length": 33}, "so_20455382_20455655_2": {"section_id": 480, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_20455382_20455655_0": {"section_id": 3166, "quality": 0.8148148148148148, "length": 22}, "so_20455382_20455496_0": {"section_id": 471, "quality": 0.9067796610169492, "length": 107}, "so_20455382_20455655_1": {"section_id": 471, "quality": 0.9444444444444444, "length": 34}, "so_20455382_20455655_2": {"section_id": 471, "quality": 0.9285714285714286, "length": 26}}, "n4659": {"so_20455382_20455655_0": {"section_id": 4058, "quality": 0.8148148148148148, "length": 22}, "so_20455382_20455496_0": {"section_id": 502, "quality": 0.7627118644067796, "length": 90}, "so_20455382_20455655_1": {"section_id": 502, "quality": 0.9166666666666666, "length": 33}, "so_20455382_20455655_2": {"section_id": 502, "quality": 0.6071428571428571, "length": 17}}}, "20455549": {"ParentId": "20455382", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You have used so-called \"copy initialization\" (defined in <code>[decl.init]</code>). The defined meaning is to construct a temporary object of type <code>X</code> using the <code>int</code> constructor, and then initialize <code>x</code> from the temporary using the copy constructor.</p>\n<p>However, the standard also permits an optimization called \"copy constructor elision\" (defined in <code>[class.copy]</code>) in this case. If that optimization is applied there is no temporary. <code>x</code> is constructed using the <code>int</code> constructor just as if you'd written so-called \"direct initialization\" <code>X x(1);</code>.</p>\n<p>In order that you don't accidentally write code that compiles when the optimization is applied but not when it isn't, the standard requires that the copy constructor must be accessible even if it is elided. Hence, the constructor must be public even though (with the compiler and options you're using) it's not called.</p>\n<p>In C++11 move constructors are considered, and are eligible for elision too. However this class <code>X</code> doesn't have a move constructor, so C++11 and C++03 are the same for this example.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2013-12-08T16:21:30.657", "Id": "20455549", "Score": "8", "CreationDate": "2013-12-08T16:10:26.243", "LastActivityDate": "2013-12-08T16:21:30.657"}});