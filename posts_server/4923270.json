post_cb({"4923314": {"ParentId": "4923270", "CommentCount": "0", "CreationDate": "2011-02-07T15:51:45.950", "OwnerUserId": "167958", "PostTypeId": "2", "Id": "4923314", "Score": "0", "Body": "<p>No, it is not possible for it to work. If you could overload <code>operator -&gt;</code> for <code>string *</code> you could make it work. But <code>operator -&gt;</code> already has a definition for all pointer types. So, just like you can't overload <code>+</code> for primitive numeric types, you can't overload <code>operator -&gt;</code> for any pointer type.</p>\n<p>And even if you could, how could the compiler know when the recursion should end?</p>\n", "LastActivityDate": "2011-02-07T15:51:45.950"}, "4923270": {"CommentCount": "5", "AcceptedAnswerId": "4923639", "PostTypeId": "1", "ClosedDate": "2011-02-07T17:26:31.420", "LastEditorUserId": "-1", "CreationDate": "2011-02-07T15:46:47.560", "LastActivityDate": "2011-02-07T16:23:05.760", "LastEditDate": "2017-05-23T10:31:18.997", "ViewCount": "2611", "FavoriteCount": "2", "Title": "Is operator-> \"chained\" for pointers?", "Id": "4923270", "Score": "5", "Body": "<blockquote>\n<p id=\"so_4923270_4923270_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/4896238/overloading-operator\">Overloading operator -&gt;</a> </br></p>\n</blockquote>\n<p>Hi,</p>\n<p>I've seen that <code>operator-&gt;()</code> is chained (re-applied) after it is evaluated, for example:</p>\n<pre><code>struct Bar\n{\n  Bar() : m_str(\"Hello world!\") {}\n  const string* operator-&gt;() const { return &amp;m_str; }\n  string m_str;\n};\n\nstruct Foo\n{\n  const Bar&amp; operator-&gt;() const { return m_bar; }\n  Bar m_bar;\n};\n\nint main()\n{\n  Foo f;\n  cout &lt;&lt; f-&gt;c_str() &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p>works pretty fine, which requires three <code>operator-&gt;()</code> to be evaluated - <code>Foo::operator-&gt;()</code>, <code>Bar::operator-&gt;()</code> and regular pointer resolution.</p>\n<p>But it wont work with pointers in the middle - if <code>Foo::operator-&gt;()</code> returns pointer to Bar instead of reference, it wont compile. Same happens with <code>auto_ptr&lt;auto_ptr&lt;string&gt;&gt; </code> for example.</p>\n<p>Is it specific to non-overloaded <code>operator-&gt;()</code> so it is only applied once and does not cause chaining?\nIs it possible to make code below works without using <code>(*ptr2)-&gt; ...</code>?</p>\n<pre><code>int main()\n{\n  string s = \"Hello world\";\n  auto_ptr&lt;string&gt; ptr1(&amp;s);\n  auto_ptr&lt;auto_ptr&lt;string&gt; &gt; ptr2(&amp;ptr1);\n  cout &lt;&lt; ptr1-&gt;c_str() &lt;&lt; endl; // fine\n  cout &lt;&lt; ptr2-&gt;c_str() &lt;&lt; endl; // breaks compilation\n}\n</code></pre>\n<p>Thanks!</p>\n", "Tags": "<c++><operator-keyword><method-chaining><arrow>", "OwnerUserId": "457223", "AnswerCount": "3"}, "4923639": {"ParentId": "4923270", "CommentCount": "0", "CreationDate": "2011-02-07T16:23:05.760", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "4923639", "Score": "11", "Body": "<p>C++98 standard \u00a713.5.6/1 \"Class member access\":</p>\n<blockquote>\n<p id=\"so_4923270_4923639_0\">An expression <code>x-&gt;m</code> is interpreted as <code>(x.operator-&gt;())-&gt;m</code> for a class object <code>x</code> of type <code>T</code> if <code>T::operator-&gt;</code> exists and if the operator is selected at the best match function by the overload resolution mechanism (13.3).</p>\n</blockquote>\n<p>What this means in practice is that when <code>x</code> is a pointer, you don\u2019t get chaining; you then just get the built-in <code>operator-&gt;</code> (i.e. <code>x-&gt;m</code> with <code>x</code> a pointer translates to <code>(*x).m</code>).</p>\n<p>But when <code>x</code> is an object of class type <code>T</code>, then you can get the chaining effect. Because then the interpretation as <code>(x.operator-&gt;())-&gt;m</code> can be that <code>(x.operator-&gt;())</code> itself is an object of some class, say class <code>U</code>. Whence the second <code>-&gt;</code> can be resolved as <code>U::operator-&gt;</code>, and so on, if the result of that again is a class type object\u2026</p>\n<p>Like, in your case, <code>Foo::operator-&gt;</code> produces (a reference to) an object of class <code>Bar</code>, which does define an <code>operator-&gt;</code>.</p>\n<p>But when <code>operator-&gt;</code> returns a pointer, as e.g. <code>std::auto_ptr&lt;T&gt;::operator-&gt;</code> does, then it's just the built-in <code>operator-&gt;</code> that's used.</p>\n<p>In passing, the chaining <em>can</em> be used to practically prevent someone from using <code>delete</code> inappropriately. <code>std::auto_ptr</code> does not do that. And I\u2019ve never seen it done.</p>\n<p>But there was once a long discussion thread over in [comp.lang.c++.moderated] about how to prevent inadvertent <code>delete</code> of the raw pointer managed by a smart pointer, and this was one possibility that was discussed.</p>\n<p>Cheers &amp; hth.</p>\n", "LastActivityDate": "2011-02-07T16:23:05.760"}, "4923339": {"ParentId": "4923270", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-02-07T15:53:34.160", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:26:13.973", "Id": "4923339", "OwnerUserId": "1491", "Body": "<p>The reason your first example works is because you returned a reference instead of a pointer. That operator would normally be invalid except in the case that it is overloaded. Therefore, the compiler must execute the overloaded functions down the chain. However, in the case of <code>auto_ptr</code> you actually are returned a real pointer and the default <code>operator -&gt;</code> is invoked for regular pointers.</p>\n<p>Please see the <a href=\"https://stackoverflow.com/questions/4896238/overloading-operator\">Overloading operator -&gt;</a> question for more details.</p>\n", "LastActivityDate": "2011-02-07T15:53:34.160"}, "bq_ids": {"n4140": {"so_4923270_4923639_0": {"section_id": 664, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_4923270_4923639_0": {"section_id": 654, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_4923270_4923639_0": {"section_id": 692, "quality": 0.9411764705882353, "length": 16}}}});