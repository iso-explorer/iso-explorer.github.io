post_cb({"bq_ids": {"n4140": {"so_37583431_37583477_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 32}}, "n3337": {"so_37583431_37583477_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 29}}, "n4659": {"so_37583431_37583477_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 32}}}, "37583431": {"ViewCount": "180", "Body": "<p>I've written a simple Fibonacci sequence generator that looks like:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid print(int c, int r) {\n    std::cout &lt;&lt; c &lt;&lt; \"\\t\\t\" &lt;&lt; r &lt;&lt; std::endl;\n}\n\nint main() {\n    unsigned long long int a = 0, b = 1, c = 1;\n    for (int r = 1; r &lt;= 1e3; r += 1) {\n        print(c, r);\n        a = b;\n        b = c;\n        c = a + b;\n    }\n}\n</code></pre>\n<p>However, as <code>r</code> gets around the value of 40, strange things begin to happen. <code>c</code>'s value oscillate between negative and positive, despite the fact he's an <code>unsigned</code> integer, and of course the Fibonacci sequence can't be exactly that.</p>\n<p>What's going on with <code>unsigned long long</code> integers?</p>\n<p>Does <code>c</code> get too large even for a <code>long long</code> integer?</p>\n", "AcceptedAnswerId": "37583477", "Title": "Unsigned long long Fibonacci numbers negative?", "CreationDate": "2016-06-02T05:34:34.553", "Id": "37583431", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-06-02T06:17:24.487", "Score": "-3", "OwnerUserId": "6245072", "Tags": "<c++><unsigned-integer><negative-integer>", "AnswerCount": "1"}, "37583477": {"Id": "37583477", "PostTypeId": "2", "Body": "<p>You have a narrowing conversion here <code>print(c, r);</code> where you defined <code>print</code> to take only <code>int</code>'s and here you pass an <code>unsigned long long</code>. It is implementation defined.</p>\n<p>Quoting the C++ Standard Draft:</p>\n<blockquote>\n<p id=\"so_37583431_37583477_0\"><a href=\"http://eel.is/c++draft/conv.integral#3\" rel=\"nofollow noreferrer\">4.4.7:3:</a> If the destination type is signed, the value is\n  unchanged if it can be represented in the destination type; otherwise,\n  the value is implementation-defined.</p>\n</blockquote>\n<p>But what typically happens is that: from the <code>unsigned long long</code>, only the bits that are just enough to fit into an <code>int</code> are copied to your function. The <em>truncated</em> <code>int</code> is stored in <a href=\"http://en.wikipedia.org/wiki/Two%27s_complement\" rel=\"nofollow noreferrer\">Twos complements</a>, depending on the value of the <a href=\"https://en.wikipedia.org/wiki/Most_significant_bit\" rel=\"nofollow noreferrer\">Most Significant Bit</a>. you get such alternation.</p>\n<p>Change your function signature to capture <code>unsigned long long</code></p>\n<pre><code>void print(unsigned long long c, int r) {\n    std::cout &lt;&lt; c &lt;&lt; \"\\t\\t\" &lt;&lt; r &lt;&lt; std::endl;\n}\n</code></pre>\n<hr>\n<p><em>BTW, see <a href=\"https://stackoverflow.com/questions/37583431/unsigned-long-long-fibonacci-numbers-negative/37583477?noredirect=1#comment62653206_37583431\">Mohit Jain's comment</a> to your question.</em></p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-06-02T06:17:24.487", "Score": "5", "CreationDate": "2016-06-02T05:38:30.867", "ParentId": "37583431", "CommentCount": "2", "OwnerUserId": "1621391", "LastEditDate": "2017-05-23T12:31:33.607"}});