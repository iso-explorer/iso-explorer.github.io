post_cb({"14782254": {"ParentId": "14782176", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Any <a href=\"http://en.wikipedia.org/wiki/Plain_old_data_structure\" rel=\"nofollow\">POD</a> data (including all fundamental types) will have an unknown value when both:</p>\n<ul>\n<li>it doesn't have <a href=\"http://en.wikipedia.org/wiki/Static_memory_allocation\" rel=\"nofollow\">static memory allocation</a> (it's instead created on the stack or with <code>new</code>)</li>\n<li>it isn't initialized, including empty initialization and/or constructor initialization lists</li>\n</ul>\n<p>Global/static variables, of all types, are set to zero as part of the startup process before <code>main</code> is called. Constructors are called for types that have constructors before <code>main</code> <a href=\"http://en.wikipedia.org/wiki/Plain_old_data_structure\" rel=\"nofollow\">1</a>. </p>\n<p>Anything not initialized in the constructor is also unknown. </p>\n<p><strong>Edit:</strong> to clarify, <code>std::string</code> is a good example of \"constructor not initializing everything\" - if you have a local <code>std::string str;</code>, then <code>str</code> will have a defined \"empty string\" content, but the content of the actual buffer, or indeed what the buffer points at may not be set to anything meaningful at all - as the implementation may determine based on the length [or some other way] whether there is a buffer available or not once we start using the string to store stuff]. </p>\n<p><strong>Edit2:</strong> As the comment explains, you can also have \"hybrid\" cases, where parts of a structure is being initialized, e.g. a <code>struct</code> that contains some elements of \"plain data\" and some elements that have constructors. The ones that have constructors will have their constructor called. The plain data will not be initialized. </p>\n<p><a href=\"http://en.wikipedia.org/wiki/Plain_old_data_structure\" rel=\"nofollow\">1</a> It may well be that the code running constructors is part of, or called from inside the \"main\" function - but if that is the case, it will be \"before any of your code in main is started\". </p>\n", "OwnerUserId": "1919155", "LastEditorUserId": "16287", "LastEditDate": "2013-02-11T16:25:00.913", "Id": "14782254", "Score": "7", "CreationDate": "2013-02-08T22:17:41.037", "LastActivityDate": "2013-02-11T16:25:00.913"}, "14782518": {"ParentId": "14782176", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>From \"Working Draft C++, 2012-11-02\" </p>\n<blockquote>\n<p id=\"so_14782176_14782518_0\"><strong>3.6.2 Initialization of non-local variables [basic.start.init]</strong><br>\n  2 Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5)\n  before any other initialization takes place.  </br></p>\n</blockquote>\n<p>Variables with static storage are <em>at least</em> zero initialized.</p>\n<blockquote>\n<p id=\"so_14782176_14782518_1\"><strong>3.7.3 Automatic storage duration [basic.stc.auto]</strong><br>\n  2 [ Note: These variables are initialized and destroyed as described in 6.7. \u2014 end note ]</br></p>\n</blockquote>\n<p>6.7 says nothing about <em>how</em> automatic variables are initialized.</p>\n<blockquote>\n<p id=\"so_14782176_14782518_2\"><strong>3.7.4 Dynamic storage duration [basic.stc.dynamic]</strong><br>\n  ...<br>\n<strong>3.7.4.1 Allocation functions [basic.stc.dynamic.allocation]</strong><br>\n  ... There are no constraints on the contents of the allocated storage on return from the\n  allocation function. The order, contiguity, and <strong>initial value</strong> of storage allocated by successive calls to an\n  allocation function <strong>are unspecified</strong>.</br></br></br></p>\n<p id=\"so_14782176_14782518_3\"><strong>8.5 Initializers [dcl.init]</strong><br>\n  7 To default-initialize an object of type T means:<br>\n  \u2014 if T is a (possibly cv-qualified) class type (Clause 9), the default constructor for T is called (and the\n  initialization is ill-formed if T has no accessible default constructor);<br>\n  \u2014 if T is an array type, each element is default-initialized;<br>\n  \u2014 otherwise, no initialization is performed.  </br></br></br></br></p>\n</blockquote>\n<p>If you provide an explicit initializer, any variable will have a known value.</p>\n<p>If you don't provide an explicit initializer for a POD type, it depends on the storage class. Static or thread variables will be zero initialized, whereas automatic or dynamically allocated variables are not.</p>\n<p>If you have a compound type, the same rules apply. If you have don't have an explicit initializer, through a (default) constructor or otherwise, the initial value of fundamental types depends on the storage class.</p>\n<p>Finally, memory allocated through <code>malloc</code> will be uninitialized, whereas <code>calloc</code> memory will be zero initialized.</p>\n", "OwnerUserId": "1741542", "LastEditorUserId": "1741542", "LastEditDate": "2013-02-08T23:00:43.077", "Id": "14782518", "Score": "2", "CreationDate": "2013-02-08T22:40:27.847", "LastActivityDate": "2013-02-08T23:00:43.077"}, "bq_ids": {"n4140": {"so_14782176_14782518_0": {"section_id": 7151, "quality": 0.65, "length": 13}, "so_14782176_14782518_2": {"section_id": 7177, "quality": 0.6896551724137931, "length": 20}, "so_14782176_14782518_3": {"section_id": 3286, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_14782176_14782518_0": {"section_id": 6895, "quality": 0.65, "length": 13}, "so_14782176_14782518_2": {"section_id": 6921, "quality": 0.6896551724137931, "length": 20}, "so_14782176_14782518_3": {"section_id": 3156, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_14782176_14782518_2": {"section_id": 8685, "quality": 0.6896551724137931, "length": 20}, "so_14782176_14782518_3": {"section_id": 4049, "quality": 0.6296296296296297, "length": 17}}}, "14782176": {"CommentCount": "4", "AcceptedAnswerId": "14782254", "PostTypeId": "1", "LastEditorUserId": "16287", "CreationDate": "2013-02-08T22:11:44.917", "LastActivityDate": "2013-02-11T16:25:00.913", "LastEditDate": "2013-02-08T22:42:50.647", "ViewCount": "312", "FavoriteCount": "1", "Title": "When do fundamental C++ types have an unknown initial value?", "Id": "14782176", "Score": "4", "Body": "<p>When will a fundamental C++ type, such as <code>int</code> or <code>float</code>, have an unknown initial value?</p>\n<p>How does the type of memory allocation factor in, if at all?  What about the declaration?  What if it's a member of a <code>class</code>/<code>struct</code>/<code>union</code>?  Is C++11 different from C++03 or C++98?</p>\n<p>I have my suspicions, but no idea if my knowledge is complete (or correct, for that matter)</p>\n", "Tags": "<c++><initialization><standards><built-in-types>", "OwnerUserId": "16287", "AnswerCount": "2"}});