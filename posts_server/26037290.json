post_cb({"26640789": {"PostTypeId": "2", "Body": "<p>MSVC is rejecting valid code here, as <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">N3337</a> 14.2 (temp.names) p4 states:</p>\n<blockquote>\n<p id=\"so_26037290_26640789_0\">When the name of a member template specialization appears after <code>.</code> or <code>-&gt;</code> in a\n  <em>postfix-expression</em> or after a <em>nested-name-specifier</em> in a <em>qualified-id</em>, and the \n  object expression of the <em>postfix-expression</em> is type-dependent or the\n  <em>nested-name-specifier</em> in the <em>qualified-id</em> refers to a dependent type, but the name \n  is not a member of the current instantiation (14.6.2.1), the member template name must \n  be prefixed by the keyword <code>template</code>. Otherwise the name is assumed to name a \n  non-template.</p>\n</blockquote>\n<p>Given this, I checked your sample against ICC 13 and Clang 3.3 on <a href=\"http://gcc.godbolt.org\" rel=\"nofollow\">Godbolt</a>: ICC correctly rejects this MSVC-ism with <code>nontype \"Base&lt;A, B&gt;::InBase [with A=A, B=B]\" is not a template</code> while accepting the conformant (<code>typename</code>/<code>template</code> qualified) version, whereas Clang, interestingly enough, accepts both the conformant <em>and</em> the nonconformant typedefs!  My local copy of MSVC 11 (VS2012) also rejects the version with <code>template</code> and <code>typename</code> in it, as well as passing a template argument list as the error suggests (which is ill-formed in any case).</p>\n<p>It appears that the <code>template</code> keyword is what is tripping MSVC up, too, which prevents GCC 4.9's suggestion of using an otherwise-redundant <code>Derived::MyBase::template InBase&lt;A, B&gt;</code> to force the expression into a dependent context without using <code>typename</code> from working.</p>\n<p>The Visual Studio devs are already <a href=\"https://connect.microsoft.com/VisualStudio/Feedback/Details/752908\" rel=\"nofollow\">aware of a very similar issue to this</a>. As to working around it, though? You'll just have to use a <code>#ifdef _MSC_VER</code> block to cage the MSVC-specific version of the typedef.</p>\n<p>For pedants: ICC, for all it gets ripped on in some corners of the world, <em>does</em> conform to the C++ standards in practice, as it uses the same EDG frontend as Comeau C++.</p>\n", "LastActivityDate": "2014-10-29T21:30:18.323", "LastEditorUserId": "3657206", "Id": "26640789", "CommentCount": "1", "CreationDate": "2014-10-29T21:13:18.617", "ParentId": "26037290", "Score": "3", "OwnerUserId": "3657206", "LastEditDate": "2014-10-29T21:30:18.323"}, "bq_ids": {"n4140": {"so_26037290_26640789_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 72}}, "n3337": {"so_26037290_26640789_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 67}}}, "26037290": {"ViewCount": "279", "Body": "<p>I have an issue with nested template classes on MSVC 12 and GCC 4.8. I've reduced it to the following snippet:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;list&gt;\n\ntemplate &lt;typename A, typename B&gt;\nstruct Base\n{\n  template &lt;typename A2, typename B2&gt; struct InBase { };\n};\n\ntemplate &lt;typename A, typename B&gt;\nstruct Derived : public Base&lt;A, B&gt;\n{\n  typedef Base&lt;A, B&gt; MyBase;\n\n  // this works on GCC 4.8\n  typedef typename MyBase::template InBase&lt;A, B&gt; MyInBase;\n  // this works on MSVC 12\n  typedef MyBase::InBase&lt;A, B&gt; MyInBase;\n\n  typedef std::vector&lt;MyInBase*&gt; MyInBaseVector;\n  typedef std::list&lt;MyInBase*&gt; MyInBaseList;\n\n  MyInBaseList list;\n};\n</code></pre>\n<p>When I use the MSVC variant of <code>MyInBase</code> on GCC, it just tells me to add <code>typename</code> and <code>template</code>, which I find understandable. When I use the GCC variant on MSVC (which I believe is the correct one), it reports this:</p>\n<pre><code>deptypes.cpp(20) : error C2955: 'Base&lt;A,B&gt;::InBase' : use of class template requires template argument list\n    deptypes.cpp(7) : see declaration of 'Base&lt;A,B&gt;::InBase'\n    deptypes.cpp(24) : see reference to class template instantiation 'Derived&lt;A,B&gt;' being compiled\nC:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\INCLUDE\\vector(648) : error C2955: 'Base&lt;A,B&gt;::InBase' : use of class template requires template argument list\n    deptypes.cpp(7) : see declaration of 'Base&lt;A,B&gt;::InBase'\n    deptypes.cpp(7) : see declaration of 'Base&lt;A,B&gt;::InBase'\ndeptypes.cpp(21) : error C2955: 'Base&lt;A,B&gt;::InBase' : use of class template requires template argument list\n    deptypes.cpp(7) : see declaration of 'Base&lt;A,B&gt;::InBase'\nC:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\INCLUDE\\list(859) : error C2955: 'Base&lt;A,B&gt;::InBase' : use of class template requires template argument list\n    deptypes.cpp(7) : see declaration of 'Base&lt;A,B&gt;::InBase'\n    deptypes.cpp(7) : see declaration of 'Base&lt;A,B&gt;::InBase'\n</code></pre>\n<p>Is the MSVC error correct? If yes, how can I fix it?</p>\n", "AcceptedAnswerId": "26640789", "Title": "MSVC: \"use of class template requires template argument list\" inside STL containers", "CreationDate": "2014-09-25T11:18:56.293", "Id": "26037290", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-10-29T21:30:18.323", "Score": "2", "OwnerUserId": "35951", "Tags": "<c++><templates><visual-c++><gcc><stl>", "AnswerCount": "1"}});