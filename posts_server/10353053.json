post_cb({"10353262": {"Id": "10353262", "PostTypeId": "2", "Body": "<p>The C++ language is designed in such a way that in your first approach without virtual inheritance there will be two parent copies of the method and it can't figure out which one to call.</p>\n<p>Virtual inheritance is the C++ solution to inheriting the same function from multiple bases, so I would suggest just using that approach.</p>\n<p>Alternately have you considered just not inheriting the same function from multiple bases? Do you really have a derived class that you need to be able to treat as <code>Derived1</code> or <code>Derived2</code> OR <code>Base</code> depending on the context?</p>\n<p>In this case elaborating on a concrete problem rather than a contrived example may help provide a better design.</p>\n", "LastActivityDate": "2012-04-27T15:16:34.767", "CommentCount": "2", "CreationDate": "2012-04-27T15:16:34.767", "ParentId": "10353053", "Score": "3", "OwnerUserId": "251738"}, "10353406": {"Id": "10353406", "PostTypeId": "2", "Body": "<p>As you've defined it, your object structure looks like this:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/sy0Gn.png\"/></p>\n<p>The important point here is that each instance of <code>Implementation</code> contains two entirely separate instances of <code>Base</code>. You're providing an override of <code>Base::funcBase</code>, but it doesn't know whether you're trying to override <code>funcBase</code> for the <code>Base</code> you inherited through <code>Derived1</code>, or the <code>Base</code> you inherited through <code>Derived2</code>.</p>\n<p>Yes, the clean way to deal with this is virtual inheritance. This will change your structure so there's only one instance of Base:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/NKg5c.png\"/></p>\n<p>This is almost undoubtedly what you really want. Yes, it got a reputation for performance problems in the days of primitive compilers and 25 MHz 486's and such. With a modern compiler and processor, you're <em>unlikely</em> to encounter a problem.</p>\n<p>Another possibility would be some sort of template-based alternative, but that tends to pervade the rest of your code -- i.e., instead of passing a <code>Base *</code>, you write a template that will work with anything that provides functions A, B, and C, then pass (the equivalent of) <code>Implementation</code> as a template parameter.</p>\n", "LastActivityDate": "2012-04-27T15:25:16.760", "CommentCount": "2", "CreationDate": "2012-04-27T15:25:16.760", "ParentId": "10353053", "Score": "7", "OwnerUserId": "179910"}, "10353053": {"ViewCount": "6433", "Body": "<p>I made a test code as following:</p>\n<pre class=\"lang-C++ prettyprint-override\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\n#ifndef interface\n#define interface struct\n#endif\n\ninterface Base\n{\n    virtual void funcBase() = 0;\n};\n\ninterface Derived1 : public Base\n{\n    virtual void funcDerived1() = 0;\n};\n\ninterface Derived2 : public Base\n{\n    virtual void funcDerived2() = 0;\n};\n\ninterface DDerived : public Derived1, public Derived2\n{\n    virtual void funcDDerived() = 0;\n};\n\nclass Implementation : public DDerived\n{\npublic:\n    void funcBase() { cout &lt;&lt; \"base\" &lt;&lt; endl; }\n    void funcDerived1() { cout &lt;&lt; \"derived1\" &lt;&lt; endl; }\n    void funcDerived2() { cout &lt;&lt; \"derived2\" &lt;&lt; endl; }\n    void funcDDerived() { cout &lt;&lt; \"dderived\" &lt;&lt; endl; }\n};\n\nint main()\n{\n    DDerived *pObject = new Implementation;\n    pObject-&gt;funcBase();\n\n    return 0;\n}\n</code></pre>\n<p>The reason I wrote this code is to test if the function funcBase() can be called in an instance of DDerived or not. My C++ complier (Visual Studio 2010) gave me a compile error message when I tried to compile this code. In my opinion, there is no problem in this code because it is certain that the function <code>funcBase()</code> will be implemented (thus overriden) in some derived class of the interface <code>DDerived</code>, because it is pure virtual. In other words, any pointer variable of type <code>Implementation *</code> should be associated with an instance of a class deriving Implentation and overriding the function <code>funcBase()</code>. </p>\n<p>My question is, why the compiler give me such an error message? Why the C++ syntax is defined like that; i.e., to treat this case as an error?  How can I make the code runs? I want to allow multiple inheritance of interfaces. Of course, if I use \"virtual public\" or re-declare the function <code>funcBase()</code> in <code>Implementation</code> like </p>\n<pre class=\"lang-C++ prettyprint-override\"><code>interface DDerived : public Derived1, public Derived2\n{\n    virtual void funcBase() = 0;\n    virtual void funcDDerived() = 0;\n};\n</code></pre>\n<p>then everything runs with no problem. </p>\n<p>But I don't want to do that and looking for more convenient method, because virtual inheritance may degrade the performance, and re-declaration is so tedious to do if inheritance relations of classes are very complex. Is there any methods to enable multiple inheritance of interfaces in C++ other than using virtual inheritance?</p>\n", "Title": "Ambiguity in multiple inheritance of interfaces in C++", "CreationDate": "2012-04-27T15:03:15.320", "LastActivityDate": "2012-04-27T18:21:23.230", "CommentCount": "6", "LastEditDate": "2012-04-27T18:21:23.230", "PostTypeId": "1", "LastEditorUserId": "1361349", "Id": "10353053", "Score": "7", "OwnerUserId": "1361349", "Tags": "<c++><inheritance><interface><multiple-inheritance><virtual-inheritance>", "AnswerCount": "4"}, "10353511": {"Id": "10353511", "PostTypeId": "2", "Body": "<p>I think C++ Standard 10.1.4 - 10.1.5 can help you to understand the problem in your code.</p>\n<pre><code>class L { public: int next; /\u2217 ... \u2217/ };\nclass A : public L { /\u2217...\u2217/ };\nclass B : public L { /\u2217...\u2217/ };\nclass C : public A, public B { void f(); /\u2217 ... \u2217/ };\n</code></pre>\n<blockquote>\n<p id=\"so_10353053_10353511_0\"><strong>10.1.4</strong> A base class specifier that <strong>does not</strong> contain the keyword virtual,\n  specifies a non-virtual base class. A base class specifier that\n  contains the keyword virtual, specifies a virtual base class. For each\n  distinct occurrence of a non-virtual base class in the class lattice\n  of the most derived class, the most derived object (1.8) shall contain\n  a corresponding distinct base class subobject of that type. For each\n  distinct base class that is specified virtual, the most derived object\n  shall contain a single base class subobject of that type. [ <strong>Example:</strong>\n  for an object of class type C, each distinct occurrence of a\n  (non-virtual) base class L in the class lattice of C corresponds\n  one-to-one with a distinct L subobject within the object of type C.\n  Given the class C defined above, an object of <strong>class C will have two\n  subobjects of class L</strong> as shown below.</p>\n<p id=\"so_10353053_10353511_1\"><strong>10.1.5</strong> In such lattices, <strong>explicit qualification</strong> can be used to specify which\n  subobject is meant. The body of function C::f could refer to the\n  member next of each L subobject: void C::f() { A::next = B::next; } <em>//\n  well-formed</em>. Without the A:: or B:: qualifiers, the definition of C::f\n  above would be <strong><em>ill-formed because of ambiguity</em></strong></p>\n</blockquote>\n<p>So just add qualifiers when calling pObject-&gt;funcBase() or solve ambiguity in another way.</p>\n<pre><code>pObject-&gt;Derived1::funcBase();\n</code></pre>\n<p><strong>Updated:</strong> Also very helpful reading will be <strong>10.3 Virtual Functions</strong> of Standard.</p>\n<p>Have a nice weekend :)</p>\n", "LastEditorUserId": "569198", "LastActivityDate": "2012-04-27T16:06:18.000", "Score": "1", "CreationDate": "2012-04-27T15:31:48.210", "ParentId": "10353053", "CommentCount": "0", "OwnerUserId": "569198", "LastEditDate": "2012-04-27T16:06:18.000"}, "10353350": {"Id": "10353350", "PostTypeId": "2", "Body": "<pre><code>DDerived *pObject = new Implementation;\npObject-&gt;funcBase();\n</code></pre>\n<p>This creates a pointer of type DDerived to a Implementation. When you are using DDerived you really just have a pointer to an interface. </p>\n<p>DDerived does not know about the implementation of funcBase because of the ambiguity of having  funcBase being defined in both Derived1 and Derived2.</p>\n<p>This has created a inheritance diamond which is what is really causing the problem. </p>\n<p><a href=\"http://en.wikipedia.org/wiki/Diamond_problem\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Diamond_problem</a></p>\n<p>I also had to check on the interface \"keyword\" you have in there </p>\n<p>it's an ms-specific extension that's recognised by visual studio</p>\n", "LastActivityDate": "2012-04-27T15:21:21.047", "CommentCount": "0", "CreationDate": "2012-04-27T15:21:21.047", "ParentId": "10353053", "Score": "1", "OwnerUserId": "1209369"}, "bq_ids": {"n4140": {"so_10353053_10353511_0": {"length": 88, "quality": 0.9565217391304348, "section_id": 6985}, "so_10353053_10353511_1": {"length": 23, "quality": 0.7666666666666667, "section_id": 6986}}, "n3337": {"so_10353053_10353511_0": {"length": 88, "quality": 0.9565217391304348, "section_id": 6731}, "so_10353053_10353511_1": {"length": 23, "quality": 0.7666666666666667, "section_id": 6732}}, "n4659": {"so_10353053_10353511_0": {"length": 53, "quality": 0.5760869565217391, "section_id": 8483}, "so_10353053_10353511_1": {"length": 23, "quality": 0.7666666666666667, "section_id": 8484}}}});