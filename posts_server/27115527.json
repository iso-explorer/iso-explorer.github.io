post_cb({"27115644": {"ParentId": "27115527", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>PODs don't really move, they copy (or, their copy and move is the same operation, as there is nothing to really \"move\" in that case) - see <a href=\"https://stackoverflow.com/questions/11589028/efficiently-moving-a-class-with-pods\">here</a>. </p>\n", "OwnerUserId": "2854947", "LastEditorUserId": "2854947", "LastEditDate": "2014-11-24T23:01:04.827", "Id": "27115644", "Score": "1", "CreationDate": "2014-11-24T22:49:09.280", "LastActivityDate": "2014-11-24T23:01:04.827"}, "27115650": {"ParentId": "27115527", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The built-in <code>=</code> operator, when used as <code>a = b</code>, has well-documented long-standing behaviour of reading <code>b</code>'s value, and storing it in <code>a</code>. There is nothing in the standard that suggests that integer assignment modifies the assignment RHS.</p>\n<blockquote>\n<p id=\"so_27115527_27115650_0\"><strong>5.17 Assignment and compound assignment operators [expr.ass]</strong></p>\n<p id=\"so_27115527_27115650_1\">...</p>\n<p id=\"so_27115527_27115650_2\">2 In simple assignment (<code>=</code>), the value of the expression replaces that of the object referred to by the left operand.</p>\n</blockquote>\n<p>Nothing is said about changing any values of any other objects, so the values of other objects must not be changed.</p>\n<p>Overloaded custom <code>operator=</code> implementations may behave differently, and many standard library types do in fact make it behave differently, but that does not affect the guarantees provided for the language's built-in <code>=</code> operator.</p>\n", "OwnerUserId": "743382", "LastEditorUserId": "743382", "LastEditDate": "2014-11-24T23:13:59.543", "Id": "27115650", "Score": "2", "CreationDate": "2014-11-24T22:49:26.947", "LastActivityDate": "2014-11-24T23:13:59.543"}, "bq_ids": {"n4140": {"so_27115527_27115650_2": {"section_id": 6174, "quality": 1.0, "length": 9}}, "n3337": {"so_27115527_27115650_2": {"section_id": 5935, "quality": 1.0, "length": 9}}, "n4659": {"so_27115527_27115650_2": {"section_id": 7676, "quality": 1.0, "length": 9}}}, "27115527": {"CommentCount": "5", "ViewCount": "177", "CreationDate": "2014-11-24T22:41:40.627", "LastActivityDate": "2014-11-24T23:13:59.543", "Title": "Does the standard give any guarantees about moving from fundamental types?", "PostTypeId": "1", "Id": "27115527", "Score": "2", "Body": "<p>Does the standard give any guarantees about moving from a fundamental data type?</p>\n<pre><code>int i = 42;\nint j = std::move(i);\n// what can we say about i here?\n</code></pre>\n<p>Reasonable options would be to keep the moved-from value untouched or set it to zero? </p>\n<p>Obviously, the code above makes little sense by itself, but think templates.</p>\n", "Tags": "<c++><c++11><move><move-semantics>", "OwnerUserId": "1171688", "AnswerCount": "2"}});