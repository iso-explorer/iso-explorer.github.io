post_cb({"13203698": {"ParentId": "13203589", "CommentCount": "0", "Body": "<p>According to the standards the name() is implementation defined (as well as according to Stroustrup book - see p 415 on 3th edition)</p>\n", "OwnerUserId": "115198", "PostTypeId": "2", "Id": "13203698", "Score": "1", "CreationDate": "2012-11-02T22:08:21.023", "LastActivityDate": "2012-11-02T22:08:21.023"}, "13203996": {"ParentId": "13203589", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The word \"type\" has multiple meanings.</p>\n<p>In terms of type theory, a C++ struct doesn't really define a type at all.</p>\n<p>More usefully, the C++ language standard talks about types in a way that can be taken rigorously, even if it never quite rigorously defines the term. In those terms, the struct declaration does define a unique and consistent type.</p>\n<p>Maybe even more usefully, to your C++ compiler (and C linker), a type is represented by things like a memory layout, a mangled name, a list of member names and types, pointers to special and normal member functions, possibly pointers to vtable and/or rtti info, etc. This will not be the same from implementation to implementation. Between builds with the same implementation, some details (like where the pointers point) may change even if no relevant code changes, but you could probably define a useful subset of information that you could usefully call a \"type\" that doesn't change.</p>\n<p>Beyond that, the <code>type_info</code> instance defined by section 18.5.1 of the standard cannot change within the bounds of what's explicitly defined, and the result of <code>typeid</code> as defined by section 5.2.8 as to be that instance or a compatible object that still compares equal to it. So, it sounds to me like, if it were possible to load up the <code>type_info</code> instances from two different runs at the same time, <code>operator==</code> would have to return <code>true</code>. However, it's not actually possible to load up <code>type_info</code> instances from two different runs (there's no requirement that they be serializable in any way, for example), so this may not be relevant.</p>\n<p>Finally, the name displayed by <code>typeid().name()</code>, as defined by section 18.5.1, is just any implementation-defined NTBS. It could change between builds, runs, even calls within the same run. It could always be empty. Practically, it'll often be something vaguely useful for debugging, but that isn't guaranteed\u2014and, even if it were, that wouldn't help, because \"vaguely useful for debugging\" doesn't have to mean \"unique within a run and persistent across runs\".</p>\n<p>If you're asking about a specific compiler, the documentation for the compiler may give stricter guarantees than the standard requires. For example, I believe that on various platforms g++ guarantees that it'll use the C++ ABI defined at CodeSourcery, and will not change ABI versions within minor compiler versions, and will use the mangled names defined in the ABI as the <code>type_info</code> names. This means taking the binary to another computer won't affect the names, and even recompiling the source on another computer with the same platform and g++ version won't affect the names.</p>\n", "OwnerUserId": "908494", "LastEditorUserId": "908494", "LastEditDate": "2012-11-02T22:48:09.727", "Id": "13203996", "Score": "1", "CreationDate": "2012-11-02T22:41:20.150", "LastActivityDate": "2012-11-02T22:48:09.727"}, "13203808": {"ParentId": "13203589", "CommentCount": "3", "Body": "<p>It depends on what you mean by \"type\".  The more or less standard definition of type is the set of values and operations the type can take, and this will change from one machine to the next, because the size of <code>int</code> will change, or the maximum length of a string.  On the other hand, there is a very real sense that type is what the compiler and the C++ standard consider it to be, which very roughly would correspond to, or at least be identified by the scoped name.  Finally, the <code>std::type_info::name()</code> function is seriously underspecified.  At best, it can be useful for debugging (e.g. logging the actual derived class a function was called with), and not all compilers provide even that.  As far as the standard is concerned, a compiler could always return an empty string, and still be conform.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "13203808", "Score": "3", "CreationDate": "2012-11-02T22:19:31.033", "LastActivityDate": "2012-11-02T22:19:31.033"}, "13203589": {"CommentCount": "6", "ViewCount": "144", "PostTypeId": "1", "LastEditorUserId": "1128905", "CreationDate": "2012-11-02T21:58:06.177", "LastActivityDate": "2012-11-03T12:03:44.867", "Title": "Does the \"type\" of a struct change from computer to computer?", "AcceptedAnswerId": "13203609", "LastEditDate": "2012-11-03T12:03:44.867", "Id": "13203589", "Score": "1", "Body": "<p>Let's assume I have this code;</p>\n<pre><code>class Ingredients{\n    public:\n        Ingredients(int size,string name);\n        int getsize();\n    private:\n        string name;\n        int size;\n};\n\nstruct Chain{\n    Ingredients* ing;\n    Chain* next;  \n}\n</code></pre>\n<p>And in my main;</p>\n<pre><code>int main()\n{\n    cout&lt;&lt;typeid(Chain).name()&lt;&lt;endl;\n    cout&lt;&lt;typeid(Chain-&gt;ing).name()&lt;&lt;endl;\n    cout&lt;&lt;typeid(Chain-&gt;next).name()&lt;&lt;endl; \n\n}\n</code></pre>\n<p>my headers are;</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nusing namespace std;\n</code></pre>\n<p>and finally outputs;</p>\n<pre><code>P8Chain\nP12Ingredients\nP8Chain\n</code></pre>\n<p>so my question is, will this types are reliable for using it in a code? If the types are changing (because of the P8 and P12 things I am not sure it would be the same) from computer to comp. this types wouldn't be reliable. What are your opinions?</p>\n<p>Also they are <em>not</em> changing on every run.</p>\n", "Tags": "<c++><types>", "OwnerUserId": "1128905", "AnswerCount": "4"}, "13203609": {"ParentId": "13203589", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>They depend on your compiler, so don't use them inside your code.</p>\n<p>The C++ standard says the following concerning <code>typeid</code> (<a href=\"http://www-d0.fnal.gov/~dladams/cxx_standard.pdf\" rel=\"nofollow\">section 5.2.8</a>):</p>\n<blockquote>\n<p id=\"so_13203589_13203609_0\">The result of a <code>typeid</code> expression is an lvalue of static type <code>const std::type_info</code> and dynamic type <code>const std::type_info</code> or <code>const</code> <em>name</em> where <em>name</em> is an <strong>implementation-defined class</strong> derived from <code>std::type_info</code>.</p>\n</blockquote>\n<p>What you <em>can</em> do if you want some sort of <a href=\"http://en.wikipedia.org/wiki/Run-time_type_information\" rel=\"nofollow\">RTTI</a> is</p>\n<pre><code>if (typeid(myobject) == typeid(Chain)) {\n    do_something();\n}\n</code></pre>\n", "OwnerUserId": "1225541", "LastEditorUserId": "1225541", "LastEditDate": "2012-11-02T22:10:31.990", "Id": "13203609", "Score": "3", "CreationDate": "2012-11-02T22:00:19.483", "LastActivityDate": "2012-11-02T22:10:31.990"}, "bq_ids": {"n4140": {"so_13203589_13203609_0": {"section_id": 6020, "quality": 0.8095238095238095, "length": 17}}, "n3337": {"so_13203589_13203609_0": {"section_id": 5788, "quality": 0.8095238095238095, "length": 17}}, "n4659": {"so_13203589_13203609_0": {"section_id": 7519, "quality": 0.8095238095238095, "length": 17}}}});