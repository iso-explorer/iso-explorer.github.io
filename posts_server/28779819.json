post_cb({"bq_ids": {"n4140": {"so_28779819_28780125_0": {"section_id": 7040, "quality": 0.9230769230769231, "length": 24}}, "n3337": {"so_28779819_28780125_0": {"section_id": 6785, "quality": 0.9230769230769231, "length": 24}}, "n4659": {"so_28779819_28780125_0": {"section_id": 8537, "quality": 0.9230769230769231, "length": 24}}}, "28779819": {"CommentCount": "17", "ViewCount": "97", "PostTypeId": "1", "LastEditorUserId": "4305818", "CreationDate": "2015-02-28T08:45:19.200", "LastActivityDate": "2015-03-01T21:31:29.397", "Title": "why does this not compile if operator delete has no implementation", "LastEditDate": "2015-02-28T09:14:04.343", "Id": "28779819", "Score": "2", "Body": "<p>why does this not compile if operator delete has no implementation?</p>\n<hr>\n<pre><code>class A\n{ \npublic: \n    virtual ~A(){ } \nprivate: \n    void operator delete(void *p); \n};\n\nint main() \n{\n    A a;\n}\n</code></pre>\n<p>compile with g++, get below error:</p>\n<p>undefined reference to `A::operator delete(void*)'</p>\n<p>if either give it an empty implementation for operator delete </p>\n<pre><code>class A\n{ \npublic: \n    virtual ~A(){ } \nprivate: \n    void operator delete(void *p) {}\n};\n\nint main() \n{\n    A a;\n}\n</code></pre>\n<p>or remove the \"virtual\"</p>\n<pre><code>class A\n{ \npublic: \n    ~A(){ } \nprivate: \n    void operator delete(void *p); \n};\n\nint main() \n{\n    A a;\n}\n</code></pre>\n<p>both compile successfully.</p>\n<p>How to explain this?</p>\n</hr>", "Tags": "<c++>", "OwnerUserId": "4305818", "AnswerCount": "1"}, "28780125": {"ParentId": "28779819", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Well, there is a huge difference between:</p>\n<pre><code>void operator delete(void *p); \n</code></pre>\n<p>and</p>\n<pre><code>void operator delete(void *p) {}\n</code></pre>\n<p>The former simply <em>declares</em> the function; the latter <em>defines</em> it. When you declare a function, you're basically just saying \"there is a function, and here are the types of its arguments and its return value\", but when you define a function, you are writing down the code that actually comprises the function. A function defined with an empty pair of braces does nothing; a function declared but not defined might do anything at all (you can't know until you see the definition). Obviously, a function cannot be called unless it has been defined. Less obviously, a function cannot have its address taken unless it has been defined. Obviously, both of these statements imply that if you call a function or take the address of a function, and you have failed to define it, your program is ill-formed.</p>\n<p>Generally, the result of failing to define something that needs a definition is a linker error. That's because when you use something in a way that requires a definition, the compiler creates a symbol that tells the linker to insert the address in the required location once it finds the definition. If the linker can't find the definition (and hence the address), then it can't complete its job.</p>\n<p>The C++ standard has an arcane set of rules that basically tell you under what conditions a function is <em>required</em> to be defined. Sometimes it does, and sometimes it doesn't. A trivial example:</p>\n<pre><code>int f();\nint main() {}\n</code></pre>\n<p>This is fine; the function <code>f</code> is never called, implicitly or explicitly; its address is never taken; it doesn't even have a <em>chance</em> of being called. Therefore, this program will compile, even though <code>f</code> is not defined.</p>\n<p>According to the standard, a function must be defined if it is <em>odr-used</em>. The standard has the following to say about <code>operator delete</code> ([basic.def.odr]/3):</p>\n<blockquote>\n<p id=\"so_28779819_28780125_0\">... A non-placement allocation or deallocation function for\n  a class is odr-used by the definition of a constructor of that class. A non-placement deallocation function for\n  a class is odr-used by the definition of the destructor of that class, or by being selected by the lookup at the\n  point of definition of a virtual destructor (12.4). (footnote 26)...</p>\n</blockquote>\n<p>Therefore: if your class has a constructor or destructor defined, it odr-uses your <code>operator delete</code>. Therefore, it doesn't matter whether your destructor is virtual or not; your program is ill-formed without a definition of <code>operator delete</code>, since you defined a destructor. [1]</p>\n<p>Now, you might ask why your compiler and linker don't complain when the destructor is non-virtual. Well, toolchains sometimes accept code even when they are supposed to reject it. In this particular case, if the destructor is not virtual, then nothing your program actually needs the address of <code>operator delete</code>, so the linker won't complain if you never define it. But when you make the destructor virtual, because lookup of deallocation functions is based on the dynamic type of the object being deallocated, there needs to be a vtable entry for the deallocation function, implying that its address must be known. Hence the link error. (Again, I want to reiterate that even though your compiler and linker accept the code when the destructor is non-virtual, it's still ill-formed code by my reading of the standard.)</p>\n<p>[1] Note that as long as you actually create an object of type <code>A</code>, it's impossible for there not to be a definition of the constructor and destructor, even if you didn't define them yourself; that is, the compiler will generate the definition implicitly.)</p>\n", "OwnerUserId": "481267", "LastEditorUserId": "140719", "LastEditDate": "2015-03-01T21:31:29.397", "Id": "28780125", "Score": "2", "CreationDate": "2015-02-28T09:20:10.883", "LastActivityDate": "2015-03-01T21:31:29.397"}});