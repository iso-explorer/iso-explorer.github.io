post_cb({"bq_ids": {"n4140": {"so_15126495_15126673_5": {"length": 10, "quality": 0.9090909090909091, "section_id": 3325}, "so_15126495_15126673_0": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_15126495_15126673_1": {"length": 9, "quality": 1.0, "section_id": 3325}, "so_15126495_15126673_6": {"length": 17, "quality": 1.0, "section_id": 3325}, "so_15126495_15126673_3": {"length": 9, "quality": 0.9, "section_id": 3325}, "so_15126495_15126673_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 633}, "so_15126495_15126673_4": {"length": 21, "quality": 0.875, "section_id": 3325}}, "n3337": {"so_15126495_15126673_5": {"length": 11, "quality": 1.0, "section_id": 3195}, "so_15126495_15126673_0": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_15126495_15126673_1": {"length": 9, "quality": 1.0, "section_id": 3195}, "so_15126495_15126673_6": {"length": 17, "quality": 1.0, "section_id": 3195}, "so_15126495_15126673_3": {"length": 9, "quality": 0.9, "section_id": 3195}, "so_15126495_15126673_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 3195}, "so_15126495_15126673_4": {"length": 21, "quality": 0.875, "section_id": 3195}}, "n4659": {"so_15126495_15126673_5": {"length": 7, "quality": 0.6363636363636364, "section_id": 4087}, "so_15126495_15126673_0": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_15126495_15126673_1": {"length": 9, "quality": 1.0, "section_id": 4091}, "so_15126495_15126673_6": {"length": 17, "quality": 1.0, "section_id": 4091}, "so_15126495_15126673_3": {"length": 7, "quality": 0.7, "section_id": 4091}, "so_15126495_15126673_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 4091}, "so_15126495_15126673_4": {"length": 21, "quality": 0.875, "section_id": 4091}}}, "15126495": {"ViewCount": "468", "Body": "<p>Consider the following program:</p>\n<pre><code>struct X\n{\n    X(int, int) { }\n    X(X&amp;&amp;) { }\n};\n\nint main()\n{\n    X x( {0, 1} ); // Doesn't compile on ICC 13.0.1, compiles on\n                   // Clang 3.2, GCC 4.7.2, and GCC 4.8.0 beta.\n}\n</code></pre>\n<p>When compiled with GCC 4.7.2, GCC 4.8.0, and Clang 3.2, this program does the following (*):</p>\n<ol>\n<li>Constructs a temporary of type <code>X</code> passing values <code>0</code> and <code>1</code> to the constructor, then;</li>\n<li>Move-constructs <code>X</code> from that temporary.</li>\n</ol>\n<p>With ICC 13.0.1, instead, it doesn't compile.</p>\n<p><strong>QUESTION #1: Who is right?</strong></p>\n<p>(*) <em>Actually, the creation of the temporary and the call to the move constructor are elided, but compiling with the <code>-fno-elide-constructors</code> option and adding some printouts to the constructors reveals that this is what is going on.</em></p>\n<hr>\n<p>Now consider the following, slight variation of the above program, where <em>uniform initialization</em> is used to direct-initialize <code>x</code>:</p>\n<pre><code>int main()\n{\n    X x{ {0, 1} }; // ERROR! Doesn't compile.\n//     ^........^\n}\n</code></pre>\n<p>I would not expect the use of braces instead of parentheses to change anything here, but it somehow does: this program doesn't compile on <em>any</em> of the compilers I've tested it on (Clang 3.2, GCC 4.7.2, GCC 4.8.0 beta, and ICC 13.0.1).</p>\n<p><strong>QUESTION #2: Why?</strong></p>\n</hr>", "AcceptedAnswerId": "15126673", "Title": "Simple program using uniform initialization to construct an object fails to compile", "CreationDate": "2013-02-28T02:37:19.377", "Id": "15126495", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-02-28T02:45:57.310", "LastEditorUserId": "1932150", "LastActivityDate": "2013-02-28T03:22:55.027", "Score": "6", "OwnerUserId": "1932150", "Tags": "<c++><c++11><constructor><initialization><uniform-initialization>", "AnswerCount": "1"}, "15126673": {"Id": "15126673", "PostTypeId": "2", "Body": "<p>It's simply a bug in all the compilers. \u00a78.5.4/3 says,</p>\n<blockquote>\n<p id=\"so_15126495_15126673_0\">List-initialization of an object or reference of type T is defined as follows:</p>\n<p id=\"so_15126495_15126673_1\">\u2014 If the initializer list has no elements and T is a class type with a default constructor, the object is\n  value-initialized.</p>\n<p id=\"so_15126495_15126673_2\">\u2014 Otherwise, if T is an aggregate, aggregate initialization is performed (8.5.1).</p>\n<p id=\"so_15126495_15126673_3\">\u2014 Otherwise, if T is a specialization of std::initializer_list, an initializer_list object is constructed as described below and used to initialize the object \u2026</p>\n<p id=\"so_15126495_15126673_4\"><strong>\u2014 Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7). If a narrowing conversion (see below) is required to convert any of the arguments, the program is ill-formed.</strong></p>\n<p id=\"so_15126495_15126673_5\">\u2014 Otherwise, if T is a reference type, a prvalue temporary of the type referenced by T is list-initialized, and the reference is bound to that temporary.</p>\n<p id=\"so_15126495_15126673_6\">\u2014 Otherwise, if the initializer list has a single element, the object or reference is initialized from that element; if a narrowing conversion (see below) is required to convert the element to T, the program is ill-formed.</p>\n<p id=\"so_15126495_15126673_7\">\u2026</p>\n</blockquote>\n<p>There are <em>quite a few</em> cases. Note that you're actually list-initializing an prvalue temporary object bound to the rvalue reference.</p>\n<p>As for GCC, I think it's trying to apply the last item mentioned above, for a single-element initializer list. If I change the constructor signature to <code>X(X&amp;&amp;, int = 3)</code>, then the initializer <code>{ {0, 1} }</code> fails but <code>{ {0, 1}, 3 }</code> succeeds. The single item should succeed because because the element is a braced-init-list, and I believe that case is supposed to allow extra enclosing braces, analogous to parens. But the failure is similar to other shortcomings of GCC with brace elision.</p>\n<p>My high-level impression is that the problems arise when the compiler tries to treat the list as an object with a type, which it's not. It's hard to convert that back to something like a parenthesized argument list.</p>\n<p>Looking more specifically at the error messages (thanks for the LWS link),</p>\n<ul>\n<li><p>ICC insists it expects an expression. This is wrong because according to the basic grammar, braced-init-lists can enclose other braced-init-lists, not only expressions.</p></li>\n<li><p>Clang says <em>\"candidate constructor not viable: cannot convert initializer list argument to 'X'\"</em> but it works if the conversion is explicit, using <code>X x{ X{0, 0 } };</code>. That doesn't make sense. It's not a conversion, because a list doesn't have a type to convert from. It's list-initialization.</p></li>\n<li><p>GCC says <em>\"no known conversion for argument 1 from '' to 'X&amp;&amp;'\"</em> suggesting it didn't even get to the point of defining a temporary to bind to the reference. As with Clang it seems to be attempting spurious conversion, and specifying <code>X{0,0}</code> fixes it.</p></li>\n</ul>\n", "LastEditorUserId": "153285", "LastActivityDate": "2013-02-28T03:22:55.027", "Score": "2", "CreationDate": "2013-02-28T03:00:13.610", "ParentId": "15126495", "CommentCount": "8", "LastEditDate": "2013-02-28T03:22:55.027", "OwnerUserId": "153285"}});