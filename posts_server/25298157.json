post_cb({"bq_ids": {"n4140": {"so_25298157_25298191_0": {"length": 46, "quality": 0.9583333333333334, "section_id": 5804}, "so_25298157_25298157_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 5804}}, "n3337": {"so_25298157_25298191_0": {"length": 46, "quality": 0.9583333333333334, "section_id": 5577}, "so_25298157_25298157_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 5577}}, "n4659": {"so_25298157_25298191_0": {"length": 44, "quality": 0.9166666666666666, "section_id": 7262}, "so_25298157_25298157_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 7262}}}, "25298157": {"ViewCount": "179", "Body": "<p>The \"<em>as-if</em>\" rule basically defines what transformations an implementation is allowed to perform on a legal C++ program. In short, all transformations that do not affect a program's <strong><em>observable behavior</em></strong> are allowed.</p>\n<p>As to what exactly <strong><em>\"observable behavior\"</em></strong> stands for, <a href=\"http://en.cppreference.com/w/cpp/language/as_if\" rel=\"nofollow\">cppreference.com</a> seems to have a different definition with the one given by the Standard, <em>regarding input/output</em>. I'm not sure if that's an reinterpretation of the Standard, or a mistake.</p>\n<p>\"<em>as-if</em>\" rule by cppreference.com:</p>\n<blockquote id=\"so_25298157_25298157_0\">\n<ul>\n<li>All input and output operations occur in the same order and with the\n  same content as if the program was executed as written.</li>\n</ul>\n</blockquote>\n<p>\"<em>as-if</em>\" rule by the Standard:</p>\n<blockquote id=\"so_25298157_25298157_1\">\n<ul>\n<li>The input and output dynamics of interactive devices shall take place\n  in such a fashion that prompting output is actually delivered before a\n  program waits for input. What constitutes an interactive device is\n  implementation-defined</li>\n</ul>\n</blockquote>\n<p>This difference is important to me because I want to know if a normal store reordering is a valid compiler optimization or not. Per cppreference's wording, a memory store should belong to <code>output operations</code> it mentions. But according to the Standard, a memory store doesn't seem to be <code>the output dynamics of interactive devices</code>. (What's interactive devices anyway?)</p>\n<p>An example to follow.</p>\n<pre><code>int A = 0;\nint B = 0;\n\nvoid foo()\n{\n    A = B + 1;              // (1)\n    B = 1;                  // (2)\n}\n</code></pre>\n<p>A modern compiler <a href=\"http://preshing.com/20130702/the-happens-before-relation/\" rel=\"nofollow\">may generate the following code</a> for function <code>foo</code>:</p>\n<pre><code>mov     0x804a018, %eax\nmovl    $0x1, 0x804a018    ; store 1 to B\nadd     $0x1, %eax         \nmov     %eax, 0x804a01c    ; store 1 to A\nret\n</code></pre>\n<p>As seen, the store to <code>A</code> is reordered with the store to <code>B</code>. Is it compliant to the \"<em>as-if</em>\" rule? Is this kind of reordering permitted by the Standard?</p>\n", "AcceptedAnswerId": "25298210", "Title": "Is store reordering allowed by C++ as-if rule?", "CreationDate": "2014-08-14T00:10:45.497", "Id": "25298157", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-08-14T00:17:20.103", "Score": "2", "OwnerUserId": "419391", "Tags": "<c++><c++11><order><as-if>", "AnswerCount": "2"}, "25298210": {"Id": "25298210", "PostTypeId": "2", "Body": "<p>If cppreference.com disagrees with the actual text of the C++ standard, cppreference.com is wrong.  The only things that can supersede the text of the standard are a newer version of the standard, and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html\" rel=\"nofollow\">official resolutions of defect reports</a> (which sometimes get rolled up into documents called \"technical corrigienda\", which is a fancy name for a minor release of the standard).</p>\n<p>However, in this case, you have misunderstood what cppreference.com means by \"input and output operations\".  (If memory serves, that text is taken verbatim from an older version of the standard.)  Stores to memory are <strong>NOT</strong> output operations.  Only writing to a <em>file</em> (that is, any <code>stdio.h</code> or <code>iostream</code> output stream, or other implementation-defined mechanism, e.g. a Unix file descriptor) counts as output for purposes of this rule.</p>\n<p>The C and C++ standards, prior to their 2011 revisions, assumed a <em>single-threaded</em> abstract machine, and therefore did not bother specifying anything about store ordering, because there was no way to observe stores out of program order.  C(++)11 added a whole bunch of rules for store ordering as part of the new multithreading specification.</p>\n", "LastActivityDate": "2014-08-14T00:17:20.103", "Score": "3", "CreationDate": "2014-08-14T00:17:20.103", "ParentId": "25298157", "CommentCount": "15", "OwnerUserId": "388520"}, "25298191": {"Id": "25298191", "PostTypeId": "2", "Body": "<p>The real articulation of the as-if rule is found at \u00a71.9/8 in the standard:</p>\n<blockquote id=\"so_25298157_25298191_0\">\n<ul>\n<li>Access to volatile objects are evaluated strictly according to the rules of the abstract machine.</li>\n<li>At program termination, all data written into files shall be identical to one of the possible results that\n  execution of the program according to the abstract semantics would have produced.</li>\n<li>The input and output dynamics of interactive devices shall take place in such a fashion that prompting\n  output is actually delivered before a program waits for input. What constitutes an interactive device\n  is implementation-defined.</li>\n</ul>\n</blockquote>\n<p>Since <code>A</code> and <code>B</code> are not volatile, this reordering is allowed.</p>\n", "LastActivityDate": "2014-08-14T00:14:49.707", "Score": "2", "CreationDate": "2014-08-14T00:14:49.707", "ParentId": "25298157", "CommentCount": "0", "OwnerUserId": "481267"}});