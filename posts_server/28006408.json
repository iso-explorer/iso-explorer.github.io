post_cb({"bq_ids": {"n4140": {"so_28006408_28140887_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 286}, "so_28006408_28140887_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 302}}, "n3337": {"so_28006408_28140887_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 277}, "so_28006408_28140887_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 293}}, "n4659": {"so_28006408_28140887_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 293}, "so_28006408_28140887_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 309}}}, "28006408": {"ViewCount": "257", "Body": "<p>The following compiles in clang but not in gcc:</p>\n<pre><code>template &lt;class... Ts, class... Args&gt;\nvoid f(Ts&amp;&amp;..., Args&amp;&amp;...);\n\nint main()\n{\n    f();\n}\n</code></pre>\n<p>This is the error I get in GCC:</p>\n<pre><code>main.cpp: In function 'int main()':\nmain.cpp:30:7: error: no matching function for call to 'f()'\n     f();\n       ^\nmain.cpp:30:7: note: candidate is:\nmain.cpp:23:6: note: template&lt;class ... Ts, class ... Args&gt; void f(Ts&amp;&amp; ..., Args&amp;&amp; ...)\n void f(Ts&amp;&amp;..., Args&amp;&amp;...)\n      ^\nmain.cpp:23:6: note:   template argument deduction/substitution failed:\nmain.cpp:30:7: note:   candidate expects 1 argument, 0 provided\n     f();\n       ^\n</code></pre>\n<p>If I give an argument like <code>f(0)</code> then it compiles with GCC but not with Clang.</p>\n<p>Error with clang:</p>\n<pre><code>main.cpp:30:5: error: no matching function for call to 'f'\n    f(0);\n    ^\nmain.cpp:23:6: note: candidate function not viable: requires 0 arguments, but 1 was provided\nvoid f(Ts&amp;&amp;..., Args&amp;&amp;...)\n     ^\n1 error generated.\n</code></pre>\n<p>If I give the same number of explicit template arguments as function parameters then it compiles with both compilers (i.e <code>f&lt;int, int, int&gt;(0, 0, 0)</code>).</p>\n", "AcceptedAnswerId": "28140887", "Title": "Ambiguous function call with two parameter packs", "CreationDate": "2015-01-18T01:56:31.203", "Id": "28006408", "CommentCount": "4", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-02-02T12:07:25.053", "Score": "9", "OwnerUserId": "1594090", "Tags": "<c++><templates><c++11>", "AnswerCount": "1"}, "28140887": {"Id": "28140887", "PostTypeId": "2", "Body": "<p>The second template parameter pack <code>Args</code> is indeed deduced:</p>\n<blockquote>\n<p id=\"so_28006408_28140887_0\">A trailing template parameter pack (14.5.3) not otherwise deduced will\n  be deduced to an empty sequence of template arguments.</p>\n</blockquote>\n<p>Taking that into account it also becomes clear that e.g. <code>f&lt;int&gt;(0)</code> is well-formed. However, <code>Ts</code> is never deduced. [temp.deduct.call]/1:</p>\n<blockquote>\n<p id=\"so_28006408_28140887_1\">When a function parameter pack appears in a non-deduced context\n  (14.8.2.5), <strong>the type of that parameter pack is never deduced</strong>.</p>\n</blockquote>\n<p>Note that the previous quote doesn't apply to <code>Ts</code>, as it isn't trailing. Therefore, pure deduction will always fail.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2016-02-02T12:07:25.053", "Score": "2", "CreationDate": "2015-01-25T20:05:59.763", "ParentId": "28006408", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2016-02-02T12:07:25.053"}});