post_cb({"bq_ids": {"n4140": {"so_41495401_41495871_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 483}, "so_41495401_41495871_5": {"length": 40, "quality": 0.975609756097561, "section_id": 484}}, "n3337": {"so_41495401_41495871_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 474}, "so_41495401_41495871_5": {"length": 35, "quality": 0.8536585365853658, "section_id": 475}}, "n4659": {"so_41495401_41495871_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 464}}}, "41495401": {"ViewCount": "204", "Body": "<p>Intel C++ compiler (Version 16.0.3.207 Build 20160415) seems to drop the <em>explicit</em> specifier when the constructor of the base class is inherited with <em>using</em>. Is this a bug?</p>\n<pre><code>struct B\n{\n    explicit B(int) { }\n};\n\nstruct D : B\n{\n    using B::B;\n};\n\nB b = 1; // Not OK, fine\nD d = 1; // Not OK with Microsoft C++ and GCC, but OK with Intel C++\n</code></pre>\n", "AcceptedAnswerId": "41495871", "Title": "Inheriting an explicit constructor (Intel C++)", "CreationDate": "2017-01-05T21:55:22.640", "Id": "41495401", "CommentCount": "2", "LastEditDate": "2017-08-02T14:02:22.570", "PostTypeId": "1", "LastEditorUserId": "1033581", "LastActivityDate": "2017-08-02T14:02:22.570", "Score": "9", "OwnerUserId": "1625187", "Tags": "<c++><c++11><using-declaration><icc><explicit-constructor>", "AnswerCount": "1"}, "41495871": {"Id": "41495871", "PostTypeId": "2", "Body": "<p>I believe that the appropriate wording from the standard is the following (n4296, <em>12.9 Inheriting constructors</em>):</p>\n<blockquote>\n<p id=\"so_41495401_41495871_0\">...</p>\n<p id=\"so_41495401_41495871_1\"><strong>The constructor characteristics</strong> of a constructor or constructor template are</p>\n<p id=\"so_41495401_41495871_2\">(2.1) \u2014 the template parameter list (14.1), if any,</p>\n<p id=\"so_41495401_41495871_3\">(2.2) \u2014 the parameter-type-list (8.3.5), and</p>\n<p id=\"so_41495401_41495871_4\">(2.3) \u2014 <strong>absence or presence of explicit</strong> (12.3.1).</p>\n<p id=\"so_41495401_41495871_5\">For each non-template constructor in the candidate set of inherited\n  constructors other than a constructor having no parameters or a\n  copy/move constructor having a single parameter, a constructor is\n  implicitly declared with <strong>the same constructor characteristics</strong>\n  unless there is a user-declared constructor with the same signature in\n  the complete class where the using-declaration appears or the\n  constructor would be a default, copy, or move constructor for that\n  class.</p>\n<p id=\"so_41495401_41495871_6\">...</p>\n</blockquote>\n<p>So most probably it is a bug in the Intel C++ compiler.</p>\n", "LastEditorUserId": "5507349", "LastActivityDate": "2017-01-05T22:35:28.620", "Score": "6", "CreationDate": "2017-01-05T22:28:55.050", "ParentId": "41495401", "CommentCount": "1", "OwnerUserId": "5507349", "LastEditDate": "2017-01-05T22:35:28.620"}});