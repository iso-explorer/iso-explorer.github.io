post_cb({"bq_ids": {"n4140": {"so_28035616_28059505_0": {"length": 14, "quality": 1.0, "section_id": 7105}, "so_28035616_28059505_2": {"length": 4, "quality": 1.0, "section_id": 7105}}, "n3337": {"so_28035616_28059505_0": {"length": 14, "quality": 1.0, "section_id": 6849}, "so_28035616_28059505_2": {"length": 4, "quality": 1.0, "section_id": 6849}}, "n4659": {"so_28035616_28059505_0": {"length": 14, "quality": 1.0, "section_id": 8606}, "so_28035616_28059505_2": {"length": 4, "quality": 1.0, "section_id": 8606}}}, "28035616": {"ViewCount": "119", "Body": "<p>Josuttis and Vandervoorde mentioned, that for dependent unqualified names compiler applies ordinary lookup on first phase and ADL on second. Then it combines overload set. Something like this:</p>\n<pre><code>struct B{};\n\nvoid bar(int){} // first overload\n\ntemplate &lt;class T&gt;\nvoid foo(T t)\n{\n  bar(2, t);\n}\n\nvoid bar(int, B){} // second overload\n\nint main() {\n    foo(B{}); // works just fine, calls second overload\n}\n</code></pre>\n<p>But if dependent name is name of member function then this principle doesn't work:</p>\n<pre><code>struct B{};\n\nstruct A{\n  template &lt;class T&gt;\n  void foo(T t)\n  {\n    bar(2, t);\n  }\n\n  void bar(int){} // first overload\n};\n\nvoid bar(int, B){} // second overload\n\nint main() {\n  A a;\n  a.foo(B{}); // gives error\n}\n</code></pre>\n<p>Why is it?\nI was wondering if somebody could point on notes from Standard</p>\n", "AcceptedAnswerId": "28059505", "Title": "C++ two-phase lookup for dependent unqualified name of member function", "CreationDate": "2015-01-19T23:57:25.593", "Id": "28035616", "CommentCount": "4", "LastEditDate": "2015-01-20T03:27:06.710", "PostTypeId": "1", "LastEditorUserId": "3120079", "LastActivityDate": "2015-01-21T04:11:58.510", "Score": "0", "OwnerUserId": "3120079", "Tags": "<c++><templates>", "AnswerCount": "1"}, "28059505": {"Id": "28059505", "PostTypeId": "2", "Body": "<p>I found a statement in Standard\n3.4.2:</p>\n<blockquote>\n<p id=\"so_28035616_28059505_0\">Let X be the lookup set produced by unqualified lookup and let Y be\n  the lookup set produced by argument dependent lookup. If X contains:</p>\n<ul>\n<li><p id=\"so_28035616_28059505_1\">a declaration of class member, or</p></li>\n<li><p id=\"so_28035616_28059505_2\">a block-scope function declaration    that is not a using-declaration, or</p></li>\n<li>a declaration that is neither a    function or a function template</li>\n</ul>\n<p id=\"so_28035616_28059505_3\">then Y is empty.</p>\n</blockquote>\n", "LastActivityDate": "2015-01-21T04:11:58.510", "Score": "0", "CreationDate": "2015-01-21T04:11:58.510", "ParentId": "28035616", "CommentCount": "0", "OwnerUserId": "3120079"}});