post_cb({"33649438": {"ParentId": "33649370", "CommentCount": "2", "Body": "<p>I don't see a problem. Accessing the uninitialized integer members is valid, because you're accessing for the purpose of writing. <em>Reading</em> them would cause UB.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "33649438", "Score": "3", "CreationDate": "2015-11-11T11:19:11.483", "LastActivityDate": "2015-11-11T11:19:11.483"}, "33649370": {"CommentCount": "10", "ViewCount": "580", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-11-11T11:14:09.090", "LastActivityDate": "2015-12-15T01:44:28.220", "Title": "Can initializing expression use the variable itself?", "LastEditDate": "2015-11-11T14:01:22.130", "Id": "33649370", "Score": "16", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Data\n{\n    int x, y;\n};\n\nData fill(Data&amp; data)\n{\n    data.x=3;\n    data.y=6;\n    return data;\n}\n\nint main()\n{\n    Data d=fill(d);\n    std::cout &lt;&lt; \"x=\" &lt;&lt; d.x &lt;&lt; \", y=\" &lt;&lt; d.y &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Here <code>d</code> is copy-initialized from the return value of <code>fill()</code>, but <code>fill()</code> writes to <code>d</code> itself before returning its result. What I'm concerned about is that <code>d</code> is non-trivially used before being initialized, and use of uninitialized variables in some(all?) cases leads to undefined behavior.</p>\n<p>So is this code valid, or does it have undefined behavior? If it's valid, will the behavior become undefined once <code>Data</code> stops being POD or in some other case?</p>\n", "Tags": "<c++><initialization><language-lawyer><undefined-behavior>", "OwnerUserId": "673852", "AnswerCount": "3"}, "33651899": {"ParentId": "33649370", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>This does not seem like valid code. It is similar to the case outlined in the question: <a href=\"https://stackoverflow.com/q/32608458/1708801\">Is passing a C++ object into its own constructor legal?</a>, although in that case the code was valid. The mechanics are not identical but the base reasoning can at least get us started.</p>\n<p>We start with <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#363\" rel=\"nofollow noreferrer\">defect report 363</a> which asks:</p>\n<blockquote>\n<p id=\"so_33649370_33651899_0\">And if so, what is the semantics of the self-initialization of UDT?\n  For example</p>\n<pre><code> #include &lt;stdio.h&gt;\n\n struct A {\n        A()           { printf(\"A::A() %p\\n\",            this);     }\n        A(const A&amp; a) { printf(\"A::A(const A&amp;) %p %p\\n\", this, &amp;a); }\n        ~A()          { printf(\"A::~A() %p\\n\",           this);     }\n };\n\n int main()\n {\n  A a=a;\n }\n</code></pre>\n<p id=\"so_33649370_33651899_1\">can be compiled and prints:</p>\n<pre><code>A::A(const A&amp;) 0253FDD8 0253FDD8\nA::~A() 0253FDD8\n</code></pre>\n</blockquote>\n<p>and the proposed resolution was:</p>\n<blockquote>\n<p id=\"so_33649370_33651899_2\">3.8 [basic.life] paragraph 6 indicates that the references here are valid. It's permitted to take the address of a class object before it\n  is fully initialized, and it's permitted to pass it as an argument to\n  a reference parameter as long as the reference can bind directly.\n  [...]</p>\n</blockquote>\n<p>So although <code>d</code> is not fully initialized we can pass it as a reference.</p>\n<p>Where we start to get into trouble is here:</p>\n<pre><code>data.x=3;\n</code></pre>\n<p>The draft C++ standard section <code>3.8</code>(<em>The same section and paragraph the defect report quotes</em>) says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_33649370_33651899_3\">Similarly, before the lifetime of an object has started but after the\n  storage which the object will occupy has been allocated or, after the\n  lifetime of an object has ended and before the storage which the\n  object occupied is reused or released, any glvalue that refers to the\n  original object may be used but only in limited ways. For an object\n  under construction or destruction, see 12.7. Otherwise, such a glvalue\n  refers to allocated storage (3.7.4.2), and using the properties of the\n  glvalue that do not depend on its value is well-defined. The program\n  has undefined behavior if:</p>\n<ul>\n<li><p id=\"so_33649370_33651899_4\">an lvalue-to-rvalue conversion (4.1) is applied to such a glvalue,</p></li>\n<li><p id=\"so_33649370_33651899_5\"><strong>the glvalue is used to access a non-static data member or call a non-static member function of the\n  object, or</strong></p></li>\n<li><p id=\"so_33649370_33651899_6\">the glvalue is bound to a reference to a virtual base class (8.5.3), or</p></li>\n<li><p id=\"so_33649370_33651899_7\">the glvalue is used as the operand of a dynamic_cast (5.2.7) or as the operand of typeid.</p></li>\n</ul>\n</blockquote>\n<p>So what does <em>access</em> mean? That was clarified with <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3714.html#1531\" rel=\"nofollow noreferrer\">defect report 1531</a> which defines access as:</p>\n<blockquote>\n<p id=\"so_33649370_33651899_8\">access</p>\n<blockquote>\n<p id=\"so_33649370_33651899_10\"> to read or modify the value of an object </p>\n</blockquote>\n</blockquote>\n<p>So <code>fill</code> <em>accesses</em> a non-static data member and hence we have undefined behavior.</p>\n<p>This also agrees with section <code>12.7</code> which says:</p>\n<blockquote>\n<p id=\"so_33649370_33651899_11\">[...]To form a pointer to (or\n  access the value of) a direct non-static member of an object obj, the construction of obj shall have started\n  and its destruction shall not have completed, otherwise the computation of the pointer value (or accessing\n  the member value) results in undefined behavior.</p>\n</blockquote>\n<p>Since you are using a copy anyway you might as well create an instance of Data inside of <code>fill</code> and initialize that. The you avoid having to pass <code>d</code>.</p>\n<p>As pointed out by T.C. it is important to explicitly quote the details on when lifetime starts. From section <code>3.8</code>:</p>\n<blockquote>\n<p id=\"so_33649370_33651899_12\">The lifetime of an object is a runtime property of the object. An\n  object is said to have non-trivial initialization if it is of a class\n  or aggregate type and it or one of its members is initialized by a\n  constructor other than a trivial default constructor. [ Note:\n  initialization by a trivial copy/move constructor is non-trivial\n  initialization. \u2014 end note ] The lifetime of an object of type T\n  begins when:</p>\n<ul>\n<li><p id=\"so_33649370_33651899_13\">storage with the proper alignment and size for type T is obtained, and</p></li>\n<li><p id=\"so_33649370_33651899_14\">if the object has non-trivial initialization, its initialization is complete.</p></li>\n</ul>\n</blockquote>\n<p>The initialization is non-trivial since we are initializing via the copy constructor.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:08.233", "Id": "33651899", "Score": "13", "CreationDate": "2015-11-11T13:45:43.290", "LastActivityDate": "2015-12-13T23:40:25.093"}, "bq_ids": {"n4140": {"so_33649370_33651899_3": {"section_id": 7194, "quality": 0.9272727272727272, "length": 51}, "so_33649370_33651899_14": {"section_id": 7189, "quality": 1.0, "length": 6}, "so_33649370_33651899_5": {"section_id": 7194, "quality": 1.0, "length": 10}, "so_33649370_33651899_12": {"section_id": 7189, "quality": 0.8461538461538461, "length": 33}, "so_33649370_33651899_7": {"section_id": 7194, "quality": 0.8333333333333334, "length": 5}, "so_33649370_33651899_11": {"section_id": 446, "quality": 1.0, "length": 27}, "so_33649370_33651899_4": {"section_id": 6185, "quality": 1.0, "length": 5}, "so_33649370_33651899_13": {"section_id": 7189, "quality": 1.0, "length": 6}, "so_33649370_33651899_6": {"section_id": 7194, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_33649370_33651899_3": {"section_id": 6938, "quality": 0.9272727272727272, "length": 51}, "so_33649370_33651899_14": {"section_id": 6933, "quality": 1.0, "length": 6}, "so_33649370_33651899_5": {"section_id": 6938, "quality": 1.0, "length": 10}, "so_33649370_33651899_12": {"section_id": 6933, "quality": 0.8461538461538461, "length": 33}, "so_33649370_33651899_7": {"section_id": 6938, "quality": 0.8333333333333334, "length": 5}, "so_33649370_33651899_11": {"section_id": 437, "quality": 1.0, "length": 27}, "so_33649370_33651899_4": {"section_id": 5946, "quality": 1.0, "length": 5}, "so_33649370_33651899_13": {"section_id": 6933, "quality": 1.0, "length": 6}, "so_33649370_33651899_6": {"section_id": 359, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_33649370_33651899_3": {"section_id": 8703, "quality": 0.9272727272727272, "length": 51}, "so_33649370_33651899_14": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_33649370_33651899_4": {"section_id": 7687, "quality": 1.0, "length": 5}, "so_33649370_33651899_9": {"section_id": 7225, "quality": 1.0, "length": 4}, "so_33649370_33651899_12": {"section_id": 8697, "quality": 0.7435897435897436, "length": 29}, "so_33649370_33651899_11": {"section_id": 468, "quality": 1.0, "length": 27}, "so_33649370_33651899_7": {"section_id": 8703, "quality": 0.8333333333333334, "length": 5}, "so_33649370_33651899_5": {"section_id": 8702, "quality": 0.9, "length": 9}, "so_33649370_33651899_10": {"section_id": 7225, "quality": 1.0, "length": 4}, "so_33649370_33651899_13": {"section_id": 8697, "quality": 1.0, "length": 6}, "so_33649370_33651899_6": {"section_id": 8703, "quality": 0.8571428571428571, "length": 6}}}, "34179911": {"ParentId": "33649370", "CommentCount": "11", "Body": "<p>I think it is valid ( crazy, but valid ).</p>\n<p>This would be both legal and logically acceptable :</p>\n<pre><code>Data d ;\n\nd = fill( d ) ;\n</code></pre>\n<p>and the fact is that this form is the same :</p>\n<pre><code>Data d = fill( d ) ;\n</code></pre>\n<p>As far as the logical structure of the language is concerned those two versions are equivalent.</p>\n<p>So it's legal and logically correct for the language.</p>\n<p>However, as we normally expect people to initialize variables to a default when we created them ( for safety ), it is <em>bad programming practice</em>.</p>\n<p>It is interesting that g++ -Wall compiles this code without a blurp.</p>\n", "OwnerUserId": "5635258", "PostTypeId": "2", "Id": "34179911", "Score": "-5", "CreationDate": "2015-12-09T13:22:35.907", "LastActivityDate": "2015-12-09T13:22:35.907"}});