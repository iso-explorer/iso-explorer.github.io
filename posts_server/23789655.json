post_cb({"23799402": {"Id": "23799402", "PostTypeId": "2", "Body": "<p>Here is an example of how to use <code>std::vector&lt;std::unique_ptr&lt;Action&gt;&gt;</code> instead of <code>std:vector&lt;Action&gt;</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n\nclass Action {\n public:\n  typedef std::vector&lt;std::unique_ptr&lt;Action&gt;&gt; Ptrs;\n  Action() { }\n  virtual void doAction() = 0;\n};\n\nclass MoveAction : public Action {\n public:\n  MoveAction() { }\n  void doAction() { std::cout &lt;&lt; \"MoveAction::doAction\" &lt;&lt; std::endl;}\n};\n\nclass Actor {\n public:\n  Action::Ptrs getActions();\n};\n\nAction::Ptrs\nActor::getActions() {\n  Action::Ptrs actions;\n  actions.emplace_back(new MoveAction());\n  return actions;\n}\n\nint main() {\n  Actor actor;\n  Action::Ptrs actions = actor.getActions();\n  actions.back()-&gt;doAction();\n}\n</code></pre>\n", "LastActivityDate": "2014-05-22T06:33:49.627", "CommentCount": "0", "CreationDate": "2014-05-22T06:33:49.627", "ParentId": "23789655", "Score": "0", "OwnerUserId": "3422652"}, "23789770": {"Id": "23789770", "PostTypeId": "2", "Body": "<p>You cannot have a vector of objects of type <code>Action</code>, i.e:</p>\n<pre><code>vector&lt;Action&gt;\n</code></pre>\n<p>because abstract class cannot have instances. You can however have a vector of pointers to abstract class.</p>\n<pre><code>vector&lt;Action*&gt;\n</code></pre>\n<p>This way the polymorphic behavior will be preserved. Note: storing <code>Action</code> instead of <code>Action*</code> would have been an error even if it was not the compilation error because you would face a <em>slicing</em> <a href=\"http://en.wikipedia.org/wiki/Object_slicing\" rel=\"nofollow\">then</a>. Remember also to handle correctly memory management when dealing with raw pointers. You can use some kind of <a href=\"http://en.wikipedia.org/wiki/Opaque_pointer\" rel=\"nofollow\"><em>handle</em></a> to pointer that will ease memory problems: <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow\">std::shared_ptr</a>, <a href=\"http://www.boost.org/doc/libs/1_55_0/libs/smart_ptr/shared_ptr.htm\" rel=\"nofollow\">boost::shared_ptr</a> or similar. This way you will introduce a little, little efficiency overhead but this is strongly advised as long as you are a beginner. Do not worry about this because this will probably be the preoptimization. First you need a correct, working code that is not leaking memory, then you can always adjust (optimize) later.</p>\n<p>C++ Standard n3337 <strong>\u00a7</strong> 10.4/1 Abstract classes</p>\n<blockquote>\n<p id=\"so_23789655_23789770_0\">The abstract class mechanism supports the notion of a general concept,\n  such as a shape, of which only more concrete variants, such as circle\n  and square, can actually be used. An abstract class can also be used\n  to define an interface for which derived classes provide a variety of\n  implementations.</p>\n</blockquote>\n<p>C++ Standard n3337 <strong>\u00a7</strong> 10.4/2</p>\n<blockquote>\n<p id=\"so_23789655_23789770_1\">An abstract class is a class that can be used only as a base class of\n  some other class; <strong>no objects of an abstract class can be created</strong>\n  except as subobjects of a class derived from it. A class is abstract\n  if it has at least one pure virtual function. [ Note: Such a function\n  might be inherited: see below. \u2014 end note ] A virtual function is\n  specified pure by using a pure-specifier (9.2) in the function\n  declaration in the class definition. (...)</p>\n</blockquote>\n", "LastEditorUserId": "1141471", "LastActivityDate": "2014-05-21T20:06:03.377", "Score": "6", "CreationDate": "2014-05-21T17:11:33.427", "ParentId": "23789655", "CommentCount": "5", "OwnerUserId": "1141471", "LastEditDate": "2014-05-21T20:06:03.377"}, "23789655": {"ViewCount": "92", "Body": "<p>I'm getting the <code>cannot instantiate abstract class</code> error. Now I am aware of the implications of this, however I don't see how I've done my code wrong. So here I am, asking for help.</p>\n<p>I have</p>\n<p><code>Action.h</code>:</p>\n<pre><code>#ifndef ACTION_H\n#define ACTION_H\n\n// ===== Dependencies ===== //\n#include ...\n... \n\n// ===== Classes ===== //\nclass Action\n{\npublic:\n    Action();\n\n    void set(...);\n\n    virtual void doAction() = 0;\n};\n\n#endif\n</code></pre>\n<p><code>MoveAction.h</code>:</p>\n<pre><code>#ifndef MOVE_ACTION_H\n#define MOVE_ACTION_H\n\n// ===== Dependencies ===== //\n#include ...\n...\n\n// ===== Classes ===== //\nclass MoveAction : public Action\n{\npublic:\n    MoveAction(...); // Constructor \n\n    using Action::set;\n\n    void doAction(); // Do action\n\nprivate:\n    ...\n};\n\n#endif\n</code></pre>\n<p><code>MoveAction.cpp</code>:</p>\n<pre><code>#include \"MoveAction.h\"\n\nMoveAction::MoveAction(...) : Action() {\n    ...\n}\n\n/* Do action */\nvoid MoveAction::doAction() {\n    ...\n    setTile(...);\n}\n</code></pre>\n<p>So essentially I am implementing <code>doAction()</code> in the class <code>MoveAction.h</code> that inherits <code>Action.h</code>. However, when I do the following:</p>\n<p><code>Actor.cpp</code>:</p>\n<pre><code>...\nvector&lt;Action&gt; Actor::getActions(...) {\n    vector&lt;Action&gt; actions = vector&lt;Action&gt;();\n\n    actions.push_back(MoveAction(...));\n    ...\n\n    return actions;\n}\n</code></pre>\n<p>I use a vector of <code>Action</code> so then future Action types (e.g. <code>AttackAction</code>) can be added to this vector and all I would need to do is call <code>action.doAction()</code> for it to perform the action. However doing the above gives me the <code>cannot instantiate abstract class</code> error..</p>\n<p>If I change the code to:</p>\n<pre><code>...\nvector&lt;MoveAction&gt; Actor::getActions(...) {\n    vector&lt;MoveAction&gt; actions = vector&lt;MoveAction&gt;();\n\n    actions.push_back(MoveAction(...));\n    ...\n\n    return actions;\n}\n</code></pre>\n<p>It works fine (notice the change of all types to <code>MoveAction</code>), this would obviously stop any extensibility options however.</p>\n<p>Anyone have any ideas? I feel like I'm missing something very obvious.</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "23789770", "Title": "C++ inheritance and abstract function implementation", "CreationDate": "2014-05-21T17:05:13.477", "Id": "23789655", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-05-22T06:33:49.627", "Score": "1", "OwnerUserId": "2714911", "Tags": "<c++><inheritance><polymorphism><virtual><abstract>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23789655_23789770_1": {"length": 41, "quality": 0.9318181818181818, "section_id": 7019}, "so_23789655_23789770_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 7018}}, "n3337": {"so_23789655_23789770_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 6764}, "so_23789655_23789770_1": {"length": 41, "quality": 0.9318181818181818, "section_id": 6765}}, "n4659": {"so_23789655_23789770_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 8515}, "so_23789655_23789770_1": {"length": 41, "quality": 0.9318181818181818, "section_id": 8516}}}});