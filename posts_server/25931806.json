post_cb({"37043980": {"ParentId": "25931806", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-05-05T06:35:39.743", "Score": "1", "LastEditorUserId": "4688119", "LastEditDate": "2016-05-05T09:09:54.557", "Id": "37043980", "OwnerUserId": "5875912", "Body": "<p>I am providing a contradictory answer.  The standard is overly presumptuous in saying that changing the object will change the order.  I can easily have an object that itself has constant data that can be used for ordering AND non-constant data that doesn't have anything to do with its order within the set. My objects have a const std::string m_name that is used by my custom comparator for ordering, but has a whole slew of setters for changing other things about it.</p>\n", "LastActivityDate": "2016-05-05T09:09:54.557"}, "25932431": {"ParentId": "25931806", "CommentCount": "0", "CreationDate": "2014-09-19T11:01:50.973", "OwnerUserId": "3953764", "PostTypeId": "2", "Id": "25932431", "Score": "3", "Body": "<p>This is because your actual <code>testSet</code> declaration looks as follows:</p>\n<pre><code>std::set&lt;std::vector&lt;int&gt;, std::less&lt;std::vector&lt;int&gt;&gt;&gt; testSet;\n//                         ~~~~~~~~~~~~~~~~~~~~~~~~~~^\n</code></pre>\n<p>That is, the <code>value_type</code> itself is used as the argument for ordering predicate (no matter if it is <code>std::less&lt;T&gt;</code> or a custom one), and its location within <code>std::set</code> data structure (possibly RB-tree) depends on its <em>original</em> value (at the time of <code>insert</code> operation).\nThus, changing the content without reordering the <code>std::set</code> would break the ordering logic.</p>\n<p>The constness of non-const iterator is also mentioned in the standard:</p>\n<blockquote id=\"so_25931806_25932431_0\">\n<h3>\u00a7 23.2.4 Associative containers <code>[associative.reqmts]</code></h3>\n<ol start=\"6\">\n<li><code>iterator</code> of an associative container is of the bidirectional iterator category. For associative containers where the value type is the same as the key type, both <code>iterator</code> and <code>const_iterator</code> are constant iterators. It is unspecified whether or not <code>iterator</code> and <code>const_iterator</code> are the same type.</li>\n</ol>\n</blockquote>\n", "LastActivityDate": "2014-09-19T11:01:50.973"}, "25931806": {"CommentCount": "6", "ViewCount": "415", "PostTypeId": "1", "LastEditorUserId": "3953764", "CreationDate": "2014-09-19T10:28:20.350", "LastActivityDate": "2016-05-05T09:09:54.557", "Title": "Why const is required when dereferencing std::set<T>::iterator?", "LastEditDate": "2014-09-19T11:12:44.050", "Id": "25931806", "Score": "1", "Body": "<p>I have the following code:</p>\n<pre><code>    std::set&lt; std::vector&lt;int&gt; &gt; testSet;\n    vector&lt;int&gt; v0 = vector&lt;int&gt;(3);\n    vector&lt;int&gt; v11 = vector&lt;int&gt;(3);\n    v0[0] = 0;\n    v0[1] = 10;\n    v0[2] = 20;\n    std::cout &lt;&lt; v0[0] &lt;&lt; endl;\n    testSet.insert(v0);\n    v0[0] = 1;\n    v0[1] = 11;\n    v0[2] = 22;\n    testSet.insert(v0);\n    std::set&lt; std::vector&lt;int&gt; &gt;::iterator it;\n\n    for (it = testSet.begin(); it != testSet.end(); it++) {\n        const std::vector&lt;int&gt;&amp; i = (*it); \n        std::cout &lt;&lt; i[0] &lt;&lt; endl;  \n    }\n</code></pre>\n<p>When I change:</p>\n<pre><code>const std::vector&lt;int&gt;&amp; i = (*it)\n</code></pre>\n<p>to:</p>\n<pre><code>std::vector&lt;int&gt;&amp; i = (*it)\n</code></pre>\n<p>it stops working. Apparently <code>(*it)</code> returns a <code>const vector&lt;int&gt;&amp;</code>, but why is it the case? The set contains vectors, not <code>const</code> vectors.</p>\n", "Tags": "<c++><vector><iterator><stdset>", "OwnerUserId": "3170609", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25931806_25932431_0": {"section_id": 742, "quality": 0.8333333333333334, "length": 25}}, "n3337": {"so_25931806_25932431_0": {"section_id": 731, "quality": 0.8333333333333334, "length": 25}}, "n4659": {"so_25931806_25932431_0": {"section_id": 800, "quality": 0.8333333333333334, "length": 25}}}});