post_cb({"bq_ids": {"n4140": {"so_47726959_47727449_1": {"length": 13, "quality": 1.0, "section_id": 304}}, "n3337": {"so_47726959_47727449_1": {"length": 13, "quality": 1.0, "section_id": 295}}, "n4659": {"so_47726959_47727449_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 311}, "so_47726959_47727449_1": {"length": 13, "quality": 1.0, "section_id": 311}}}, "47726959": {"ViewCount": "73", "Body": "<pre><code> template&lt;typename T&gt;\n void F(T&amp;&amp; x) {}\n</code></pre>\n<p>If we call it with argument of type int&amp; everything is clear - reference collapsing takes place and we still have lvalue-reference. But what happens if we call it with, for example, int argument. My thoughts: we have deduced type T=int, decorate it with rvalue-reference, so F takes int&amp;&amp; argument and calling it with int type will result in error. But in real F takes such argument as lvalue-reference. Where does lvalue-reference come from? What rules did compiler apply to get int&amp; from int?</p>\n", "AcceptedAnswerId": "47727449", "Title": "Forwarding references for non-reference types", "CreationDate": "2017-12-09T08:57:07.720", "LastActivityDate": "2017-12-09T11:17:17.057", "CommentCount": "13", "LastEditDate": "2017-12-09T11:17:17.057", "PostTypeId": "1", "LastEditorUserId": "3992440", "Id": "47726959", "Score": "0", "OwnerUserId": "3992440", "Tags": "<c++>", "AnswerCount": "2"}, "47727449": {"Id": "47727449", "PostTypeId": "2", "Body": "<p>Since C++17, there is the concept of <em>forwarding reference</em> in the C++ standard. Normaly the template parameter is deduced as a non reference. But for the specific case of a <em>forwarding reference</em> if the corresponding argument is a lvalue, the parameter is deduced as a reference. <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.deduct.call#3\" rel=\"nofollow noreferrer\">C++ standard (N4700)[temp.over.deduct.call]/3</a>:</p>\n<blockquote>\n<p id=\"so_47726959_47727449_0\">[...]A <em>forwarding reference</em> is an rvalue reference to a cv-unqualified template parameter that does not represent a template parameter of a class template (during class template argument deduction ([over.match.class.deduct])). If P is a forwarding reference and the argument is an lvalue, the type \u201clvalue reference to A\u201d is used in place of A for type deduction.[...]</p>\n</blockquote>\n<p>For the concern of function call, it has the same meaning as this equivalent paragraph in the <a href=\"https://timsong-cpp.github.io/cppwp/n3337/temp.deduct.call#3\" rel=\"nofollow noreferrer\">C++11(N337)</a> and <a href=\"https://timsong-cpp.github.io/cppwp/n4140/temp.deduct.call#3\" rel=\"nofollow noreferrer\">C++14(N414)</a> [temp.over.deduct.call]/3:</p>\n<blockquote>\n<p id=\"so_47726959_47727449_1\">[...]If P is an rvalue reference to a cv-unqualified template parameter and the argument is an lvalue, the type \u201clvalue reference to A\u201d is used in place of A for type deduction[...]</p>\n</blockquote>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2017-12-09T11:02:04.207", "Score": "1", "CreationDate": "2017-12-09T10:07:16.363", "ParentId": "47726959", "CommentCount": "2", "OwnerUserId": "5632316", "LastEditDate": "2017-12-09T11:02:04.207"}, "47727136": {"Id": "47727136", "PostTypeId": "2", "Body": "<p>Forwarding references deduce lvalue reference for lvalues and rvalue reference for rvalues. For example, even for <strong>lvalue</strong> of type <code>int&amp;&amp;</code> it will still deduce <code>int&amp;</code> (as it would for lvalue of type <code>int</code>), likewise, for <strong>rvalues</strong> of type <code>int</code> or <code>int&amp;&amp;</code> it will deduce <code>int&amp;&amp;</code>:</p>\n<pre><code>template&lt;typename T&gt;\nclass show;\n\ntemplate&lt;typename T&gt;\nvoid F(T&amp;&amp; x) \n{ show&lt;decltype(x)&gt;();}\n\nint main() {\n    int&amp;&amp; x = 5;\n    F(x);\n}\n</code></pre>\n<blockquote id=\"so_47726959_47727136_0\">\n<pre><code>main.cpp:6:3: error: implicit instantiation of undefined template 'show&lt;int &amp;&gt;'\n</code></pre>\n</blockquote>\n<pre><code>int main() {\n    F(5);\n}\n</code></pre>\n<blockquote id=\"so_47726959_47727136_1\">\n<pre><code>main.cpp:6:3: error: implicit instantiation of undefined template 'show&lt;int &amp;&amp;&gt;'\n</code></pre>\n</blockquote>\n<pre><code>int main() {\n    int x = 5;\n    F(x);\n}\n</code></pre>\n<blockquote id=\"so_47726959_47727136_2\">\n<pre><code>main.cpp:6:3: error: implicit instantiation of undefined template 'show&lt;int &amp;&gt;'\n</code></pre>\n</blockquote>\n<pre><code>int main() {\n    F([]()-&gt;int{return 5;}());\n}\n</code></pre>\n<blockquote id=\"so_47726959_47727136_3\">\n<pre><code>main.cpp:6:3: error: implicit instantiation of undefined template 'show&lt;int &amp;&amp;&gt;'\n</code></pre>\n</blockquote>\n", "LastActivityDate": "2017-12-09T09:23:55.063", "Score": "0", "CreationDate": "2017-12-09T09:23:55.063", "ParentId": "47726959", "CommentCount": "2", "OwnerUserId": "3410396"}});