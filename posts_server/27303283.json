post_cb({"bq_ids": {"n4140": {"so_27303283_27335365_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 302}, "so_27303283_27335365_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 286}}, "n3337": {"so_27303283_27335365_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 293}, "so_27303283_27335365_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 277}}, "n4659": {"so_27303283_27335365_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 309}, "so_27303283_27335365_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 293}}}, "27303283": {"ViewCount": "599", "Body": "<p>The code below works in gcc-4.8.2\n</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;typename... Args&gt;\nvoid func(Args... args, int optional = 0)\n{\n    cout &lt;&lt; optional &lt;&lt; endl;\n}\n\nint main()\n{\n    func(1);\n    func(2.1f); // converts 2.1 to int as 'optional' parameter\n    func&lt;float&gt;(3.3f);  // Fine, prints '0'\n    func();  // gcc OK, fails to compile with clang-3.5\n}\n</code></pre>\n<p>And it outputs:</p>\n<pre><code>$ ./a.out\n1\n2\n0\n0\n</code></pre>\n<p>But if fails to compile with clang-3.5,</p>\n<pre><code>test_variadic.cpp:15:2: error: no matching function for call to 'func'\n    func();\n    ^~~~\ntest_variadic.cpp:5:6: note: candidate function template not viable: requires at least argument 'args', but no arguments were provided\nvoid func(Args... args, int optional = 0)\n     ^\n</code></pre>\n<p>Clang at least warns of the implicit conversion from a float to an int.  Fine, we can correct that by calling <code>func&lt;float&gt;</code> which puts the float parameter into the template pack.  So, if I comment out <code>func()</code>, it compiles fine.</p>\n<p>I can't find anything in the standard saying explicitly that variadic template pack has to be the last thing in the parameter-declaration-clause, just that it becomes a non-deduced context.</p>\n<p>My confusion comes from why clang doesn't like <code>func()</code> when <code>func(1)</code> is perfectly acceptable.  I can manually define <code>func(int optional = 4) { cout &lt;&lt; optional &lt;&lt; endl; }</code> and everything is fine (but instead of the templated function when passing <code>int</code> I correctly get the specialized <code>func()</code> in both clang and gcc.  What is clang enforcing that restricts the use of <code>func()</code>?</p>\n", "AcceptedAnswerId": "27335365", "Title": "Clang vs GCC - Variadic template parameter pack followed by parameter with default value works in GCC 4.8 but not Clang 3.5", "CreationDate": "2014-12-04T20:21:04.670", "Id": "27303283", "CommentCount": "4", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-12-04T21:30:30.120", "LastEditorUserId": "1012251", "LastActivityDate": "2016-03-07T17:03:11.100", "Score": "10", "OwnerUserId": "1012251", "Tags": "<c++><c++11><clang><variadic-templates>", "AnswerCount": "1"}, "27335365": {"Id": "27335365", "PostTypeId": "2", "Body": "<p>This is actually covered by the slightly misplaced <a href=\"http://eel.is/c++draft/temp.arg.explicit#3\" rel=\"nofollow\">[temp.arg.explicit]/3</a>:</p>\n<blockquote>\n<p id=\"so_27303283_27335365_0\">A trailing template parameter pack (14.5.3) not\n  otherwise deduced will be deduced to an empty sequence of template arguments.</p>\n</blockquote>\n<p>The template parameter pack is trailing and thus deduced to the empty pack in all calls except for <code>func&lt;float&gt;(3.3f)</code>, that is, they are all valid (and Clang compiles them fine <a href=\"http://coliru.stacked-crooked.com/a/6d2184a139335a5b\" rel=\"nofollow\">as of 3.5</a>).</p>\n<hr>\n<p>However, the compilers are not conforming anymore once we adjust the template's declaration to </p>\n<pre><code>template &lt;typename... Args, typename=void&gt;\nvoid func(Args... args, int optional = 0)\n</code></pre>\n<p>Now, the aforementioned quote is not applicable (as <code>Args</code> is not trailing) and <a href=\"http://eel.is/c++draft/temp.deduct.call#1\" rel=\"nofollow\">[temp.deduct.call]/1</a> applies instead:</p>\n<blockquote>\n<p id=\"so_27303283_27335365_1\">When a function parameter pack appears in a non-deduced context\n  (14.8.2.5), the type of that parameter pack is never deduced.</p>\n</blockquote>\n<p>(I.e. this should yield a deduction failure.)</p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-07T17:03:11.100", "Score": "3", "CreationDate": "2014-12-06T19:10:37.063", "ParentId": "27303283", "CommentCount": "2", "OwnerUserId": "3647361", "LastEditDate": "2016-03-07T17:03:11.100"}});