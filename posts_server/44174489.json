post_cb({"bq_ids": {"n4140": {"so_44174489_44174489_0": {"length": 19, "quality": 1.0, "section_id": 234}}, "n3337": {"so_44174489_44174489_0": {"length": 19, "quality": 1.0, "section_id": 227}}, "n4659": {"so_44174489_44174489_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 244}}}, "44174489": {"ViewCount": "199", "Body": "<p>The following code works with GCC and Clang, but not with Visual C++:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct MyType {\n    static constexpr std::size_t it = 10;\n};\n\nstruct MyType2 {\n};\n\ntemplate&lt;typename T&gt;\nstruct Type2 {\n    static constexpr std::size_t it = T::it;\n};\n\nint main() {\n    Type2&lt;MyType&gt; t1;\n    Type2&lt;MyType2&gt; t2; // Visual C++ complains that MyType2::it doesn't exist\n    (void) t1;\n    (void) t2;\n}\n</code></pre>\n<p>According to section 14.7.1 of the standard:</p>\n<blockquote>\n<p id=\"so_44174489_44174489_0\">... the initialization (and any associated side-effects) of a static\n  data member does not occur unless the static data member is itself\n  used in a way that requires the definition of the static data member\n  to exist</p>\n</blockquote>\n<p>So it seems that this is a bug in Visual C++; it should be accepting this code.</p>\n<p>Regardless, I still want to be able to do this using Visual C++. What is the easiest way to allow Visual C++ to work, without changing the syntax of accessing the member variable? I also require that <code>Type2&lt;T&gt;::it</code> doesn't exist when <code>T::it</code> doesn't exist, or that it is otherwise possible to SFINAE off of the existance of <code>Type2&lt;T&gt;::it</code>.</p>\n<hr>\n<p>This changes the syntax, so I don't want it:</p>\n<pre><code>template&lt;typename T&gt;\nstruct Type2 {\n    template&lt;typename = void&gt;\n    static constexpr std::size_t it = T::it;\n};\n\n// Type2&lt;MyType&gt;::it&lt;&gt;\n</code></pre>\n<p>This is a lot of work, because my class will contain more than a simple <code>constexpr</code> variable:</p>\n<pre><code>template&lt;typename T, typename = void&gt;\nstruct Type2 {\n};\n\ntemplate&lt;typename T&gt;\nstruct Type2&lt;T, decltype((void) T::it)&gt; {\n    static constexpr std::size_t it = T::it;\n};\n</code></pre>\n</hr>", "AcceptedAnswerId": "44174579", "Title": "How do I delay the instantiation of a static data member in Visual C++?", "CreationDate": "2017-05-25T07:14:25.197", "Id": "44174489", "CommentCount": "2", "LastEditDate": "2017-05-25T07:33:35.047", "PostTypeId": "1", "LastEditorUserId": "1896169", "LastActivityDate": "2017-05-25T07:33:35.047", "Score": "8", "OwnerUserId": "1896169", "Tags": "<c++><visual-c++><c++14><compatibility><template-meta-programming>", "AnswerCount": "1"}, "44174579": {"Id": "44174579", "PostTypeId": "2", "Body": "<p>You could inherit <code>it</code> (when it exists) instead of declaring it directly:</p>\n<pre><code>template&lt;typename T, typename = void&gt;\nstruct ItHolder\n{};\n\ntemplate&lt;typename T&gt;\nstruct ItHolder&lt;T, decltype((void) T::it)&gt; {\n    static constexpr std::size_t it = T::it;\n};\n\n\ntemplate&lt;typename T&gt;\nstruct Type2 : ItHolder&lt;T&gt; {\n};\n</code></pre>\n<p>In other words, just take what you already suggested and combine it using another layer of indirection.</p>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2017-05-25T07:22:43.827", "Score": "2", "CreationDate": "2017-05-25T07:19:22.153", "ParentId": "44174489", "CommentCount": "3", "OwnerUserId": "1782465", "LastEditDate": "2017-05-25T07:22:43.827"}});