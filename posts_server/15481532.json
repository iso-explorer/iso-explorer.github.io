post_cb({"15481828": {"Id": "15481828", "PostTypeId": "2", "Body": "<p>The C standard states:</p>\n<blockquote>\n<p id=\"so_15481532_15481828_0\">\"The type of an integer constant is the first of the corresponding list in which its value can be represented.\"</p>\n</blockquote>\n<p>In C89, this list is:</p>\n<blockquote>\n<p id=\"so_15481532_15481828_1\"><code>int, long int, unsigned long int</code></p>\n</blockquote>\n<p>C99 extends that list to include:</p>\n<blockquote>\n<p id=\"so_15481532_15481828_2\"><code>long long int, unsigned long long int</code></p>\n</blockquote>\n<p>As such, when you code is compiled, the literal 65 fits in an int type, and so it's type is accordingly int.  The int is then promoted to long when the function is called.</p>\n<p>If, for instance, sizeof(int) == 2, and your literal is something like 64000, the type of the value will be a long (assuming sizeof(long) &gt; sizeof(int)).</p>\n<p>The suffixes are used to overwrite the default behavior and force the specified literal value to be of a certain type.  This can be particularly useful when the integer promotion would be expensive (e.g. as part of an equation in a tight loop).  </p>\n", "LastActivityDate": "2013-03-18T16:24:03.353", "CommentCount": "4", "CreationDate": "2013-03-18T16:24:03.353", "ParentId": "15481532", "Score": "0", "OwnerUserId": "1607746"}, "15481947": {"Id": "15481947", "PostTypeId": "2", "Body": "<p>In C++ objects and values have a type, that is independent on how you use them. Then when you use them, if you need a different type it will be converted appropriately.</p>\n<p>The problem in the linked question is that varargs is not type-safe. It assumes that you pass in the correct types and that you decode them for what they are. While processing the caller, the compiler does not know how the callee is going to decode each one of the arguments so it cannot possibly convert them for you. Effectively, varargs is as typesafe as converting to a <code>void*</code> and converting back to a different type, if you get it right you get what you pushed in, if you get it wrong you get trash.</p>\n<p>Also note that in this particular case, with inlining the compiler <em>has</em> enough information, but this is just a small case of a general family if errors. Consider the <code>printf</code> family of functions, depending on the contents of the first argument each one of the arguments is processed as a different type. Trying to fix this case at the language level would lead to inconsistencies, where in some cases the compiler does the right thing or the wrong one and it would not be clear to the user when to expect which, including the fact that it could do the right thing today, and the wrong one tomorrow if during refactoring the function definition is moved and not available for inlining, or if the logic of the function changes and the argument is processed as one type or another based on some previous parameter.</p>\n", "LastActivityDate": "2013-03-18T16:29:53.907", "CommentCount": "2", "CreationDate": "2013-03-18T16:29:53.907", "ParentId": "15481532", "Score": "4", "OwnerUserId": "36565"}, "15481532": {"ViewCount": "641", "Body": "<p>Imagine you have this function:</p>\n<pre><code>void foo(long l) { /* do something with l */}\n</code></pre>\n<p>Now you call it like so at the call site:</p>\n<pre><code>foo(65); // here 65 is of type int\n</code></pre>\n<p>Why, (technically) when you specify in the declaration of your function that you are expecting a <code>long</code> and you pass just a number without the <code>L</code> suffix, is it being treated as an <code>int</code>?</p>\n<p>Now, I know it is because the C++ Standard says so, however, what is the technical reason that this <code>65</code> isn't just promoted to being of type <code>long</code> and so save us the silly error of forgetting <code>L</code> suffix to make it a long explicitly?</p>\n<p>I have found this in the C++ Standard:</p>\n<p><strong>4.7 Integral conversions [conv.integral]</strong></p>\n<blockquote>\n<p id=\"so_15481532_15481532_0\">5 The conversions allowed as integral promotions are excluded from the set of integral conversions.</p>\n</blockquote>\n<p>That a narrowing conversion isn't being done implicitly, I can think with, but here the destination type is obviously wider than the source type.</p>\n<p><strong>EDIT</strong></p>\n<p>This question is based on <a href=\"https://stackoverflow.com/questions/15480927/va-arg-64bit-issue/15481101\">a question</a> I saw earlier, which had funny behavior when you didn't specify the <code>L</code> suffix.  <a href=\"http://liveworkspace.org/code/23yOdN$22\" rel=\"nofollow noreferrer\">Example</a>, but perhaps it's a C thing, more than C++?!!</p>\n", "Title": "Widening of integral types?", "CreationDate": "2013-03-18T16:11:23.217", "LastActivityDate": "2013-03-18T16:48:18.610", "CommentCount": "10", "LastEditDate": "2017-05-23T11:50:09.677", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "15481532", "Score": "3", "OwnerUserId": "174614", "Tags": "<c++><integer-promotion>", "AnswerCount": "5"}, "15481826": {"Id": "15481826", "PostTypeId": "2", "Body": "<p>The function in this instance does receive a <code>long</code>, not an <code>int</code>. The compiler automatically converts any argument to the required parameter type if it's possible without losing any information (as here). That's one of the main reasons function prototypes are important.</p>\n<p>It's essentially the same as with an expression like <code>(1L + 1)</code> - because the integer <code>1</code> is not the right type, it's implicitly converted to a <code>long</code> to perform the calculation, and the result is a <code>long</code>.</p>\n<p>If you pass <code>65L</code> in this function call, no type conversion is necessary, but there's no practical difference - <code>65L</code> is used either way.</p>\n<p>Although not C++, this is the relevant part of the C99 standard, which also explains the var args note:</p>\n<blockquote>\n<p id=\"so_15481532_15481826_0\">If the expression that denotes the called function has a type that\n  does include a prototype, the arguments are implicitly converted, as\n  if by assignment, to the types of the corresponding parameters, taking\n  the type of each parameter to be the unquali\ufb01ed version of its\n  declared type. The ellipsis notation in a function prototype\n  declarator causes argument type conversion to stop after the last\n  declared parameter. The default argument promotions are performed on\n  trailing arguments.</p>\n</blockquote>\n", "LastEditorUserId": "1627348", "LastActivityDate": "2013-03-18T16:29:13.783", "Score": "1", "CreationDate": "2013-03-18T16:23:58.457", "ParentId": "15481532", "CommentCount": "0", "OwnerUserId": "1627348", "LastEditDate": "2013-03-18T16:29:13.783"}, "bq_ids": {"n4140": {"so_15481532_15481828_1": {"length": 6, "quality": 1.0, "section_id": 22}, "so_15481532_15481532_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 34}, "so_15481532_15481828_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5341}, "so_15481532_15481828_2": {"length": 7, "quality": 1.0, "section_id": 22}}, "n3337": {"so_15481532_15481828_1": {"length": 6, "quality": 1.0, "section_id": 19}, "so_15481532_15481532_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 31}, "so_15481532_15481828_2": {"length": 7, "quality": 1.0, "section_id": 19}, "so_15481532_15481828_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5138}}, "n4659": {"so_15481532_15481828_1": {"length": 6, "quality": 1.0, "section_id": 22}, "so_15481532_15481532_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 34}, "so_15481532_15481828_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 6762}, "so_15481532_15481828_2": {"length": 7, "quality": 1.0, "section_id": 22}}}, "15481924": {"Id": "15481924", "PostTypeId": "2", "Body": "<p>We have to have a standard meaning for types because for lower level applications, the type REALLY matters, especially for integral types. Low level operators (such as bitshift, add, ect) rely on the type of the input to determine overflow locations. ((65 &lt;&lt; 2) with integers is 260 (0x104), but with a single char it is 4! (0x004)). Sometimes you want this behavior, sometimes you don't. As a programmer, you just need to be able to always know what the compiler is going to do. Thus the design decision was made to make the human explicitly declare the integral types of their constants, with \"undecorated\" as the most commonly used type, integer.</p>\n<p>The compiler does automatically \"cast\" your constant expressions at compile time, such that the effective value passed to the function is long, but up until the cast it is considered an int for this reason.</p>\n", "LastActivityDate": "2013-03-18T16:28:46.050", "CommentCount": "0", "CreationDate": "2013-03-18T16:28:46.050", "ParentId": "15481532", "Score": "0", "OwnerUserId": "1756405"}, "15481888": {"Id": "15481888", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15481532_15481888_0\">Why, (technically) when you specify in the declaration of your function that you are expecting a long and you pass just a number without the <code>L</code> suffix, is it being treated as an <code>int</code>?</p>\n</blockquote>\n<p>Because the type of a literal is specified only by the form of the literal, not the context in which it is used. For an integer, that is <code>int</code> unless the value is too large for that type, or a suffix is used to specify another type.</p>\n<blockquote>\n<p id=\"so_15481532_15481888_1\">Now, I know it is because the C++ Standard says so, however, what is the technical reason that this 65 isn't just promoted to being of type <code>long</code> and so save us the silly error of forgetting <code>L</code> suffix to make it a <code>long</code> explicitly?</p>\n</blockquote>\n<p>The value should be promoted to <code>long</code> whether or not you specify that type explicitly, since the function is declared to take an argument of type <code>long</code>. If that's not happening, perhaps you could give an example of code that fails, and describe how it fails?</p>\n<p>UPDATE: the example you give passes the literal to a function taking untyped ellipsis (<code>...</code>) arguments, not a typed <code>long</code> argument. In that case, the function caller has no idea what type is expected, and only the <em>default argument promotions</em> are applied. Specifically, a value of type <code>int</code> remains an <code>int</code> when passed through ellipsis arguments.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2013-03-18T16:38:26.423", "Score": "1", "CreationDate": "2013-03-18T16:27:04.100", "ParentId": "15481532", "CommentCount": "2", "OwnerUserId": "204847", "LastEditDate": "2013-03-18T16:38:26.423"}});