post_cb({"994368": {"ParentId": "994353", "CommentCount": "0", "Body": "<p>Just so i understand your question. You are asking if it is normal for each version of the templated function to have its own instance of myStaticVar. (for example: <code>incAndShow&lt;int&gt;</code> vs. <code>intAndShow&lt;float&gt;</code> The answer is yes.</p>\n<p>Your other question is, if two files include the header containing the template function, will they still share the static variable for a given T. I would say yes.</p>\n", "OwnerUserId": "13430", "PostTypeId": "2", "Id": "994368", "Score": "5", "CreationDate": "2009-06-15T03:06:11.680", "LastActivityDate": "2009-06-15T03:06:11.680"}, "994420": {"ParentId": "994353", "CommentCount": "0", "Body": "<p>Yes, it is \"normal\", but whatever you try to achieve with this \"feature\" maybe questionable. Try explain why you want to use local static variable, may be we can come up with a cleaner way to do it.</p>\n<p>The reason this is normal is because of the way template functions are compiled and linked. Each translation unit (the two .cpp in your case) gets see their own copy of incAndShow and when the program is linked together, the two incAndShow will be merged into one. If you declare your regular function inline in the header file, you'll get similar effect.</p>\n", "OwnerUserId": "96885", "PostTypeId": "2", "Id": "994420", "Score": "0", "CreationDate": "2009-06-15T03:41:48.490", "LastActivityDate": "2009-06-15T03:41:48.490"}, "1163631": {"ParentId": "994353", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Take this example that shows the behaviour is absolutely expected:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt; class Some\n{\npublic:\n   static int stat;\n};\n\ntemplate&lt;class T&gt;\nint Some&lt;T&gt;::stat = 10;\n\nvoid main()\n{\n   Some&lt;int&gt;::stat = 5;\n   std::cout &lt;&lt; Some&lt;int&gt;::stat   &lt;&lt; std::endl;\n   std::cout &lt;&lt; Some&lt;char&gt;::stat  &lt;&lt; std::endl;\n   std::cout &lt;&lt; Some&lt;float&gt;::stat &lt;&lt; std::endl;\n   std::cout &lt;&lt; Some&lt;long&gt;::stat  &lt;&lt; std::endl;\n}\n</code></pre>\n<p>You get: <code>5 10 10 10 10</code> </p>\n<p>The above shows that the change in static variable is only for type \"int\" and hence in your case you don't see any problem.</p>\n", "Id": "1163631", "LastEditDate": "2009-07-23T01:55:05.733", "OwnerDisplayName": "legend2804", "Score": "-1", "CreationDate": "2009-07-22T07:32:56.663", "LastActivityDate": "2009-07-23T01:55:05.733", "LastEditorUserId": "56338"}, "bq_ids": {"n4140": {"so_994353_994428_4": {"section_id": 7136, "quality": 0.7272727272727273, "length": 8}, "so_994353_994428_3": {"section_id": 51, "quality": 0.9285714285714286, "length": 13}, "so_994353_994428_1": {"section_id": 51, "quality": 0.6153846153846154, "length": 8}, "so_994353_994428_2": {"section_id": 7136, "quality": 0.7647058823529411, "length": 13}, "so_994353_994428_0": {"section_id": 7043, "quality": 0.8372093023255814, "length": 36}}, "n3337": {"so_994353_994428_4": {"section_id": 6880, "quality": 0.7272727272727273, "length": 8}, "so_994353_994428_3": {"section_id": 46, "quality": 0.9285714285714286, "length": 13}, "so_994353_994428_1": {"section_id": 46, "quality": 0.6153846153846154, "length": 8}, "so_994353_994428_2": {"section_id": 6880, "quality": 0.7647058823529411, "length": 13}, "so_994353_994428_0": {"section_id": 6788, "quality": 0.8604651162790697, "length": 37}}, "n4659": {"so_994353_994428_4": {"section_id": 8637, "quality": 0.7272727272727273, "length": 8}, "so_994353_994428_0": {"section_id": 8540, "quality": 0.8372093023255814, "length": 36}, "so_994353_994428_1": {"section_id": 52, "quality": 0.6153846153846154, "length": 8}, "so_994353_994428_2": {"section_id": 8637, "quality": 0.7647058823529411, "length": 13}}}, "994353": {"CommentCount": "1", "CreationDate": "2009-06-15T02:53:56.360", "PostTypeId": "1", "AcceptedAnswerId": "994428", "LastEditorUserId": "56338", "LastActivityDate": "2017-04-11T11:35:49.487", "LastEditDate": "2009-06-15T17:59:40.920", "ViewCount": "7414", "FavoriteCount": "7", "Title": "Static variable inside template function", "Id": "994353", "Score": "23", "Body": "<p>In C++, if you define this function in header.hpp</p>\n<pre><code>void incAndShow()\n{\n  static int myStaticVar = 0;\n  std::cout &lt;&lt; ++myStaticVar &lt;&lt; \" \" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>and you include header.hpp in at least two .cpp files. Then you will have <code>multiple definition of incAndShow()</code>. Which is expected. However, if you add a template to the function</p>\n<pre><code>template &lt;class T&gt;\nvoid incAndShow()\n{\n  static int myStaticVar = 0;\n  std::cout &lt;&lt; ++myStaticVar &lt;&lt; \" \" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>then you won't have any <code>multiple definition of</code> error. Likewise, two different .cpp calling the function with the same template (e.g. <code>incAndShow&lt;int&gt;()</code>), will share <code>myStaticVar</code>. Is this normal? I'm asking this question, because I do rely on this \"feature\" (sharing the static variable) and I want to be sure that it is not only my implementation that is doing this.</p>\n", "Tags": "<c++><templates><static>", "OwnerUserId": "122894", "AnswerCount": "7"}, "994428": {"ParentId": "994353", "LastEditDate": "2009-06-15T05:22:00.397", "CommentCount": "0", "CreationDate": "2009-06-15T03:46:06.093", "OwnerUserId": "34509", "LastEditorUserId": "34509", "PostTypeId": "2", "Id": "994428", "Score": "27", "Body": "<p>You can rely on this. The ODR (One Definition Rule) says at <code>3.2/5</code> in the Standard, where <code>D</code> stands for the non-static function template (cursive font by me)</p>\n<blockquote>\n<p id=\"so_994353_994428_0\">If D is a template, and is defined in more than one translation unit, then the last four requirements from the list above shall apply to names from the template\u2019s enclosing scope used in the template definition (14.6.3), and also to dependent names at the point of instantiation (14.6.2). <em>If the definitions of D satisfy all these requirements, then the program shall  behave as if there were a single definition of D.</em> If the definitions of D do not satisfy these requirements, then the behavior is undefined.</p>\n</blockquote>\n<p>Of the last four requirements, the two most important are roughly</p>\n<ul>\n<li>each definition of D shall consist of the same sequence of tokens</li>\n<li>names in each definition shall refer to the same things (\"entities\")</li>\n</ul>\n<p><strong>Edit</strong> </p>\n<p>I figure that this alone is not sufficient to guarantee that your static variables in the different instantiations are all the same. The above only guarantees that the multiple definitions of the template is valid. It doesn't say something about the specializations generated from it. </p>\n<p>This is where <em>linkage</em> kicks in. If the name of a function template specialization (which is a function) has external linkage (<code>3.5/4</code>), then a name that refers to such a specialization refers to the same function. For a template that was declared static, functions instantiated from it have internal linkage, because of</p>\n<blockquote>\n<p id=\"so_994353_994428_1\">Entities generated from a template with internal linkage are distinct from all entities generated in other translation units. <code>-- 14/4</code></p>\n<p id=\"so_994353_994428_2\">A name having namespace scope (3.3.6) has internal linkage if it is the name of [...] an object, reference, function or function template that is explicitly declared static <code>-- 3.5/3</code></p>\n</blockquote>\n<p>If the function template wasn't declared with static, then it has extern linkage (that, by the way, is also the reason that we have to follow the ODR at all. Otherwise, <code>D</code> would not be multiply defined at all!). This can be derived from <code>14/4</code> (together with <code>3.5/3</code>)</p>\n<blockquote>\n<p id=\"so_994353_994428_3\">A non-member function template can have internal linkage; any other template name shall have external linkage. <code>-- 14/4</code>. </p>\n</blockquote>\n<p>Finally, we come to the conclusion that a function template specialization generated from a function template with external linkage has itself external linkage by <code>3.5/4</code>:</p>\n<blockquote>\n<p id=\"so_994353_994428_4\">A name having namespace scope has external linkage if it is the name of [...] a function, unless it has internal linkage <code>-- 3.5/4</code></p>\n</blockquote>\n<p>And when it has internal linkage was explained by <code>3.5/3</code> for functions provided by explicit specializations, and <code>14/4</code> for generated specializations (template instantiations). Since your template name has external linkage, all your specializations have external linkage: If you use their name (<code>incAndShow&lt;T&gt;</code>) from different translation units, they will refer to the same functions, which means your static objects will be the same in each occasion. </p>\n", "LastActivityDate": "2009-06-15T05:22:00.397"}, "994372": {"ParentId": "994353", "CommentCount": "2", "Body": "<ul>\n<li>templates will only actually be turned into code once they're instantiated (i.e. used)</li>\n<li>headers are not to be used for implementation code, but only for declarations</li>\n</ul>\n", "OwnerUserId": "78244", "PostTypeId": "2", "Id": "994372", "Score": "-3", "CreationDate": "2009-06-15T03:07:20.430", "LastActivityDate": "2009-06-15T03:07:20.430"}, "994437": {"ParentId": "994353", "CommentCount": "0", "Body": "<p>The difference when you create the function template is that it has external linkage. The same incAndShow will be accessible from all translation units.</p>\n<p>Paraphrasing from C++ standard working draft N2798 (2008-10-04):\n14 part 4: a non member function template can have internal linkage, others always have external linkage.\n14.8 point 2: every specialization will have its own copy of the static variable.</p>\n<p>Your function template should have external linkage unless you declare it in the unnamed namespace or something. So, for each T that you use with your function template, you should get one static variable used throughput the program. In other words, it's OK to rely on having only one static variable in the program for each instantiation of the template (one for T==int, one for T==short, etc).</p>\n<p>As an aside, this can lead to weird situations if you define incAndShow differently in different translation units. E.g., if you define it to increment in one file and the decrement in another file (without specifying internal linkage by putting the function into the unnamed namespace) both will end up sharing the same function, which will effectively be chosen at random at compile time (with g++ it depends on the order the object files are given on the command line).</p>\n", "OwnerUserId": "122671", "PostTypeId": "2", "Id": "994437", "Score": "1", "CreationDate": "2009-06-15T03:53:30.813", "LastActivityDate": "2009-06-15T03:53:30.813"}, "994369": {"ParentId": "994353", "LastEditDate": "2009-06-15T03:23:46.147", "CommentCount": "0", "CreationDate": "2009-06-15T03:06:34.707", "OwnerUserId": "45654", "LastEditorUserId": "45654", "PostTypeId": "2", "Id": "994369", "Score": "0", "Body": "<p>Templates are instantiated as needed, which means that compiler (linker as well in this case?) will make sure that you don't end up with multiple instances of the same template as well as only those instances of templates that you need - in your case only <code>incAndShow&lt;int&gt;()</code> is instantiated and nothing else (otherwise compiler would have to try to instantiate for every type which does not make sense).</p>\n<p>So I assume that the same methods it uses to figure out for which type to instantiate template prevents it from instantiating twice for the same type e.g. only one instance of <code>incAndShow&lt;int&gt;()</code></p>\n<p>This is different from non template code.</p>\n", "LastActivityDate": "2009-06-15T03:23:46.147"}});