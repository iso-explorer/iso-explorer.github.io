post_cb({"bq_ids": {"n4140": {"so_12905539_12905607_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 5966}}, "n3337": {"so_12905539_12905607_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 5735}}, "n4659": {"so_12905539_12905607_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 7460}}}, "12905539": {"ViewCount": "215", "Body": "<p>I'm looking at the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid f()\n{\n    std::cout &lt;&lt; \"Called ::f()\" &lt;&lt; std::endl;\n}\n\nstruct S\n{\n    void f()\n    {\n        std::cout &lt;&lt; \"Called S::f()\" &lt;&lt; std::endl;\n    }\n\n    void oops()\n    {\n        [this](){ f(); }(); // calls the wrong function\n    }\n};\n\nint main()\n{\n    S().oops();\n    return 0;\n}\n</code></pre>\n<p>(<a href=\"http://ideone.com/w7nyb\" rel=\"nofollow\">http://ideone.com/w7nyb</a>)</p>\n<p>VS2010 calls <code>::f()</code> but GCC &amp; VS2012 calls <code>S::f()</code>. To me it seems that VS2012 is correct. </p>\n<p>Which function should be called according to the standard?</p>\n", "AcceptedAnswerId": "12905607", "Title": "Function name resolution in a lambda that captures _this_", "CreationDate": "2012-10-15T23:41:01.787", "LastActivityDate": "2012-10-16T00:53:36.640", "CommentCount": "8", "LastEditDate": "2012-10-16T00:53:36.640", "PostTypeId": "1", "Tags": "<c++><visual-studio-2010><lambda><c++11><visual-studio-2012>", "Id": "12905539", "AnswerCount": "1", "Score": "3", "OwnerUserId": "221619", "ClosedDate": "2012-10-17T08:20:40.967", "LastEditorUserId": "221619"}, "12905607": {"Id": "12905607", "PostTypeId": "2", "Body": "<p><code>S::f()</code> should be called.  C++11 \u00a75.1.2/7 states:</p>\n<blockquote>\n<p id=\"so_12905539_12905607_0\">The <em>lambda-expression</em>'s <em>compound-statement</em> yields the <em>function-body</em> of the function call operator, but for purposes of name lookup, determining the type and value of <code>this</code> and transforming <em>id-expressions</em> referring to non-static class members into class member access expressions using <code>(*this)</code>, the <em>compound-statement</em> is considered in the context of the <em>lambda-expression</em>.</p>\n</blockquote>\n<p>The important part here is that \"for purposes of name lookup,... the <em>compound-statement</em> is considered in the context of the <em>lambda-expression</em>.\"  Since there is no <code>f</code> declared locally in the lambda block, it is looked up just as it would be looked up if it was referred to directly from the body of <code>oops</code>.  Therefore, the member function is found.</p>\n<hr>\n<p>Note that recent versions of Visual C++ and gcc both have the correct behavior (including Visual C++ 2012 and gcc 4.7.2).  Older versions may exhibit incorrect behavior because the lambda specification was overhauled in the second half of 2009 (see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf\" rel=\"nofollow\">n2927:  New wording for C++0x Lambdas</a> [PDF]).  Remember that before C++11 was finalized, the specification was a moving target, and older compilers are likely to implement different revisions of the specification.  Even now, many implementers are still working to catch up to the final specification.</p>\n</hr>", "LastEditorUserId": "151292", "LastActivityDate": "2012-10-16T00:04:10.730", "Score": "5", "CreationDate": "2012-10-15T23:49:45.100", "ParentId": "12905539", "CommentCount": "1", "OwnerUserId": "151292", "LastEditDate": "2012-10-16T00:04:10.730"}});