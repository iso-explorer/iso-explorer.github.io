post_cb({"bq_ids": {"n4140": {"so_5273144_5273165_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 3260}, "so_5273144_5273165_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 3261}}, "n3337": {"so_5273144_5273165_1": {"length": 7, "quality": 1.0, "section_id": 3132}, "so_5273144_5273165_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 3133}}, "n4659": {"so_5273144_5273165_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 4018}, "so_5273144_5273165_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 4019}}}, "5273144": {"ViewCount": "1615", "Body": "<p>I have these classes:</p>\n<pre><code>class Base\n{\n    public:\n        virtual void foo(int x = 0)\n        {\n            printf(\"X = %d\", x);\n        }\n};\n\nclass Derived : public Base\n{\n    public:\n        virtual void foo(int x = 1)\n        {\n            printf(\"X = %d\", x);\n        }\n};</code></pre>\n<p>When I have:</p>\n<pre><code>Base* bar = new Derived();\nbar-&gt;foo();</code></pre>\n<p>My output is \"X = 0\", even if foo is called from Derived, but when I have:</p>\n<pre><code>Derived* bar = new Derived();\nbar-&gt;foo();</code></pre>\n<p>My output is \"X = 1\". Is this behavior correct? (To select default parameter value from the declaration type, instead of selecting it from actual object type). Does this break C++ polymorphism? </p>\n<p>It can cause many problems if somebody uses virtual functions without specifying the actual function parameter and uses the function's default parameter.</p>\n", "AcceptedAnswerId": "5273165", "Title": "C++ polymorphism and default argument", "CreationDate": "2011-03-11T12:56:44.027", "Id": "5273144", "CommentCount": "4", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2011-08-22T20:44:08.513", "LastEditorUserId": "597607", "LastActivityDate": "2011-08-22T20:44:08.513", "Score": "9", "OwnerUserId": "336578", "Tags": "<c++>", "AnswerCount": "3"}, "5273177": {"Id": "5273177", "PostTypeId": "2", "Body": "<p>The behavior is correct. Check out the answer to this question for an explanation:</p>\n<p><a href=\"https://stackoverflow.com/q/3533589/50079\">Can virtual functions have default parameters?</a></p>\n<p>Moral: treat default parameter values as part of the function signature and <em>do not modify them</em> when overriding virtual functions!</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-03-11T12:59:15.403", "Score": "5", "CreationDate": "2011-03-11T12:59:15.403", "ParentId": "5273144", "CommentCount": "7", "OwnerUserId": "50079", "LastEditDate": "2017-05-23T12:13:54.673"}, "5273211": {"Id": "5273211", "PostTypeId": "2", "Body": "<p>This is what C++ designed, I think.</p>\n<p>The polymorphism is finished by virtual table, which internally plays with pointer to functions, but the parameter's default value is not stored with the function pointer, it is binded in compiling phase, so it can only get the default value by first looking at its type, in your first case, it is Base, then it use 0 as the default value. </p>\n", "LastActivityDate": "2011-03-11T13:01:48.207", "CommentCount": "2", "CreationDate": "2011-03-11T13:01:48.207", "ParentId": "5273144", "Score": "0", "OwnerUserId": "334999"}, "5273165": {"Id": "5273165", "PostTypeId": "2", "Body": "<p>Default arguments are retained even if you override a function! And this behaviour is correct. Let me search the reference from the C++ Standard.</p>\n<p>\u00a78.3.6/10 [Default arguments] from the C++ Standard says,</p>\n<blockquote>\n<p id=\"so_5273144_5273165_0\">A virtual function call (10.3) uses\n  the default arguments in the\n  declaration of the virtual function\n  <strong>determined by the static type of the\n  pointer or reference denoting the\n  object</strong>. <em>An overriding function in a\n  derived class does not acquire default\n  arguments from the function it\n  overrides</em>.</p>\n</blockquote>\n<p>The example from the Standard itself</p>\n<pre><code>struct A {\n     virtual void f(int a = 7);\n};\nstruct B : public A {\n     void f(int a);\n};\nvoid m()\n{\n    B* pb = new B;\n    A* pa = pb;\n    pa-&gt;f(); //OK, calls pa-&gt;B::f(7)\n    pb-&gt;f(); //error: wrong number of arguments for B::f()\n}\n</code></pre>\n<p>Also, not only it's retained, it is evaluated everytime the function is called:</p>\n<p>\u00a78.3.6/9 says,</p>\n<blockquote>\n<p id=\"so_5273144_5273165_1\">Default arguments are evaluated each\n  time the function is called</p>\n</blockquote>\n", "LastEditorUserId": "102", "LastActivityDate": "2011-03-11T14:18:47.840", "Score": "5", "CreationDate": "2011-03-11T12:58:21.437", "ParentId": "5273144", "CommentCount": "7", "OwnerUserId": "415784", "LastEditDate": "2011-03-11T14:18:47.840"}});