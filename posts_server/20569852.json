post_cb({"bq_ids": {"n4140": {"so_20569852_20570181_0": {"length": 29, "quality": 0.8787878787878788, "section_id": 7183}}, "n3337": {"so_20569852_20570181_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 6927}}}, "20570181": {"PostTypeId": "2", "Body": "<p>Pointers to deleted objects are toxic: don't touch then for anything other than giving them a new value. A memory tracking system may trap aby use of a reclaimed pointer value. I'm not aware if any such system in existence, however.</p>\n<p>The relevant quote is 3.7.4.2 [basic.stc.dynamic.deallocation] paragraph 4:</p>\n<blockquote>\n<p id=\"so_20569852_20570181_0\">If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value, the deallocation function shall deallocate the storage referenced by the pointer, rendering invalid all pointers to any part of the <em>deallocated storage</em>. The effect of using an invalid pointer value (including passing it to a deallocation function) is undefined.</p>\n</blockquote>\n<p>When resizing a <code>std::vector&lt;...&gt;</code> it jumps through a number of hoops (allocators) and, by default, eventually calls a deallocation function.</p>\n", "LastActivityDate": "2013-12-13T18:07:52.457", "LastEditorUserId": "1120273", "Id": "20570181", "CommentCount": "6", "CreationDate": "2013-12-13T15:32:12.733", "ParentId": "20569852", "Score": "5", "OwnerUserId": "1120273", "LastEditDate": "2013-12-13T18:07:52.457"}, "20569852": {"ViewCount": "417", "Body": "<p>Today I wrote something which looked like this:</p>\n<pre><code>void foo(std::vector&lt;char&gt;&amp;v){\n    v.push_back('a');\n    char*front=&amp;v.front();\n    char*back=&amp;v.back();\n    size_t n1=back-front+1;\n    v.push_back('b');//This could reallocate the vector elements\n    size_t n2=back-front+1;//Is this line valid or Undefined Behavior ?\n}\n</code></pre>\n<p><strong>If a reallocation occures when I push 'b' back, may I still compute the difference of my two pointers ?</strong></p>\n<p>After reading the relevant passage of the standard a few times, I still cannot make my mind on this point.</p>\n<p><strong>C++11 5.7.6</strong>:\nWhen two pointers to elements of the same array object are subtracted, the result is the difference of the\nsubscripts of the two array elements. The type of the result is an implementation-defined signed integral\ntype; this type shall be the same type that is defined as std::ptrdiff_t in the  header (18.2). As\nwith any other arithmetic overflow, if the result does not fit in the space provided, the behavior is undefined.\nIn other words, if the expressions P and Q point to, respectively, the i-th and j-th elements of an array object,\nthe expression (P)-(Q) has the value i \u2212 j provided the value fits in an object of type std::ptrdiff_t.\nMoreover, if the expression P points either to an element of an array object or one past the last element of\nan array object, and the expression Q points to the last element of the same array object, the expression\n((Q)+1)-(P) has the same value as ((Q)-(P))+1 and as -((P)-((Q)+1)), and has the value zero if the\nexpression P points one past the last element of the array object, even though the expression (Q)+1 does not\npoint to an element of the array object. <strong>Unless both pointers point to elements of the same array object, or\none past the last element of the array object, the behavior is undefined.</strong></p>\n<p>Of course I know that it works, I just wonder if it is legal.</p>\n", "AcceptedAnswerId": "20570181", "Title": "Is it still legal to do pointer arithmetic on a deleted array?", "CreationDate": "2013-12-13T15:16:38.037", "Id": "20569852", "CommentCount": "6", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-12-13T15:59:58.387", "LastEditorUserId": "1824274", "LastActivityDate": "2013-12-13T18:07:52.457", "Score": "5", "OwnerUserId": "1824274", "Tags": "<c++><c++11><language-lawyer><undefined-behavior><pointer-arithmetic>", "AnswerCount": "3"}, "20570483": {"PostTypeId": "2", "Body": "<p>This particular case is safe but ugly and misleading.</p>\n<p>Line <code>v.push_back('b');//This could reallocate the vector elements</code> can cause reallocation of your container. In this case next line will use a non existent <code>front</code> and <code>back</code> pointers. Computing difference of two addresses is safe even if are dangling pointers. What is not safe is dereferencing them. </p>\n<p>The correct solution is to use <code>vector::count()</code> function the will be always in sync. If you (for some reason) don;t want to call <code>vector::count()</code> you should at leas use <code>++n1</code>.</p>\n", "LastActivityDate": "2013-12-13T15:48:12.440", "Id": "20570483", "CommentCount": "3", "CreationDate": "2013-12-13T15:48:12.440", "ParentId": "20569852", "Score": "0", "OwnerUserId": "653143"}, "20570936": {"PostTypeId": "2", "Body": "<p>Strictly speaking, it's UB. But you can always convert your <code>char *</code> pointers to <code>uintptr_t</code> (provided it is present) and then safely subtract the resulting integers.</p>\n<pre><code>void foo(std::vector&lt;char&gt;&amp;v){\n    v.push_back('a');\n    auto front= uintptr_t (&amp;v.front());\n    auto back = uintptr_t (&amp;v.back());\n    size_t n1=back-front+1;\n    v.push_back('b');//This could reallocate the vector elements\n    size_t n2=back-front+1;\n}\n</code></pre>\n", "LastActivityDate": "2013-12-13T16:11:18.363", "Id": "20570936", "CommentCount": "5", "CreationDate": "2013-12-13T16:11:18.363", "ParentId": "20569852", "Score": "1", "OwnerUserId": "390807"}});