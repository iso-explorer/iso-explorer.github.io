post_cb({"23030403": {"CommentCount": "20", "AcceptedAnswerId": "23031288", "PostTypeId": "1", "LastEditorUserId": "923854", "CreationDate": "2014-04-12T12:30:26.397", "LastActivityDate": "2014-04-12T14:02:52.423", "LastEditDate": "2014-04-12T13:05:57.230", "ViewCount": "535", "FavoriteCount": "2", "Title": "Can the point-of-instantiation be delayed until the end of the translation unit?", "Id": "23030403", "Score": "10", "Body": "<p>Consider the following small code fragment:</p>\n<pre><code>#include &lt;iostream&gt; \n\ntemplate&lt;class T&gt; \nint test(); \n\nint main() \n{     \n    std::cout &lt;&lt; test&lt;int&gt;() &lt;&lt; \"\\n\"; \n} \n\n// POI for test&lt;int&gt;() should be right here      \n\ntemplate&lt;class T&gt; \nint test() \n{ \n    return 0; \n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/\"><strong>Live Example</strong></a> that compiles and prints 0 for both Clang and g++.</p>\n<p>Here's the <a href=\"https://github.com/cplusplus/draft/blob/master/papers/N3936.pdf\"><strong>draft Standard</strong></a> quote on the point of instantiation of function templates</p>\n<p><strong>14.6.4.1 Point of instantiation [temp.point]</strong></p>\n<blockquote>\n<p id=\"so_23030403_23030403_0\">1 For a function template specialization, a member function template specialization, or a specialization for a\n  member function or static data member of a class template, if the specialization is implicitly instantiated\n  because it is referenced from within another template specialization and the context from which it is referenced\n  depends on a template parameter, the point of instantiation of the specialization is the point of\n  instantiation of the enclosing specialization. Otherwise, the point of instantiation for such a specialization\n  immediately follows the namespace scope declaration or definition that refers to the specialization.</p>\n</blockquote>\n<p><a href=\"http://rads.stackoverflow.com/amzn/click/0201734842\"><strong>Vandevoorde and Josuttis</strong></a> have the following to say about this:</p>\n<blockquote>\n<p id=\"so_23030403_23030403_1\">In practice, most compilers delay the actual instantiation of\n  noninline function templates to the end of the translation unit. This\n  effectively moves the POIs of the corresponding template\n  specializations to the end of the translation unit. The intention of\n  the C++ language designers was for this to be a valid implementation\n  technique, but the standard does not make this clear.</p>\n</blockquote>\n<p><strong>Question</strong>: are Clang/g++ non-conforming because they delay the POI to the end of the translation unit?</p>\n", "Tags": "<c++><templates><c++11><language-lawyer>", "OwnerUserId": "819272", "AnswerCount": "2"}, "23030965": {"ParentId": "23030403", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Explicitly specializing after the explicit call to the template will fail at compilation.</p>\n<pre><code>#include &lt;iostream&gt; \n\ntemplate&lt;class T&gt; \nint test(T y);\n\n\nint main() \n{     \n    std::cout &lt;&lt; test&lt;int&gt;(0) &lt;&lt; \"\\n\"; \n}\n\ntemplate&lt;class T&gt; \nint test(T y) \n{ \n    return 0; \n}\n\n// POI for test&lt;int&gt;() should be right here      \n\ntemplate&lt;&gt;\nint test(int y) \n{ \n    return 2; \n}\n</code></pre>\n<p>Check the compilation error <a href=\"http://ideone.com/TUbHYc\" rel=\"nofollow\">here</a></p>\n<pre><code>Compilation error    time: 0 memory: 0 signal:0\nprog.cpp:21:15: error: specialization of \u2018int test(T) [with T = int]\u2019 after instantiation\nint test(int y) \n</code></pre>\n", "OwnerUserId": "870953", "LastEditorUserId": "923854", "LastEditDate": "2014-04-12T13:58:31.373", "Id": "23030965", "Score": "3", "CreationDate": "2014-04-12T13:23:18.717", "LastActivityDate": "2014-04-12T13:58:31.373"}, "23031288": {"ParentId": "23030403", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#993\" rel=\"nofollow\">Core Working Group defect report 993</a> was created to address this issue:</p>\n<blockquote>\n<p id=\"so_23030403_23031288_0\"><strong>993. Freedom to perform instantiation at the end of the translation unit</strong></p>\n<p id=\"so_23030403_23031288_1\">Section: 14.6.4.1  [temp.point]     Status: C++11     Submitter: John Spicer     Date: 6 March, 2009<br>[Voted into the WP at the March, 2011 meeting.]</br></p>\n<p id=\"so_23030403_23031288_2\">The intent is that it is a permissible implementation technique to do template instantiation at the end of a translation unit rather than at an actual point of instantiation. This idea is not reflected in the current rules, however.</p>\n<p id=\"so_23030403_23031288_3\">Proposed resolution (January, 2011):</p>\n<p id=\"so_23030403_23031288_4\">Change 14.6.4.1 [temp.point] paragraph 7 as follows:</p>\n<blockquote>\n<p id=\"so_23030403_23031288_6\">A specialization for a function template, a member function template, or of a member function or static data member of a class template may have multiple points of instantiations within a translation unit, <strong>and in addition to the points of instantiation described above, for any such specialization that has a point of instantiation within the translation unit, the end of the translation unit is also considered a point of instantiation.</strong> A specialization for a class template...</p>\n</blockquote>\n</blockquote>\n<p>Paragraph 14.6.4.1/7 in C++11 is 14.6.4.1/8 in N3936:</p>\n<blockquote>\n<p id=\"so_23030403_23031288_7\">A specialization for a function template, a member function template, or of a member function or static\n  data member of a class template may have multiple points of instantiations within a translation unit, and\n  in addition to the points of instantiation described above, for any such specialization that has a point\n  of instantiation within the translation unit, the end of the translation unit is also considered a point of\n  instantiation. A specialization for a class template has at most one point of instantiation within a translation\n  unit. A specialization for any template may have points of instantiation in multiple translation units. If\n  two different points of instantiation give a template specialization different meanings according to the one\n  definition rule (3.2), the program is ill-formed, no diagnostic required.</p>\n</blockquote>\n<p>So yes, it is allowable for implementations to delay the point of instantiation of templates to the end of the translation unit.</p>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2014-04-12T14:02:52.423", "Id": "23031288", "Score": "5", "CreationDate": "2014-04-12T13:55:14.873", "LastActivityDate": "2014-04-12T14:02:52.423"}, "bq_ids": {"n4140": {"so_23030403_23031288_0": {"section_id": 223, "quality": 0.5714285714285714, "length": 4}, "so_23030403_23031288_5": {"section_id": 223, "quality": 1.0, "length": 42}, "so_23030403_23031288_7": {"section_id": 223, "quality": 1.0, "length": 74}, "so_23030403_23030403_0": {"section_id": 216, "quality": 0.98, "length": 49}, "so_23030403_23031288_6": {"section_id": 223, "quality": 1.0, "length": 42}}, "n3337": {"so_23030403_23031288_0": {"section_id": 216, "quality": 0.5714285714285714, "length": 4}, "so_23030403_23031288_5": {"section_id": 216, "quality": 1.0, "length": 42}, "so_23030403_23030403_0": {"section_id": 210, "quality": 0.98, "length": 49}, "so_23030403_23031288_7": {"section_id": 216, "quality": 1.0, "length": 74}, "so_23030403_23031288_6": {"section_id": 216, "quality": 1.0, "length": 42}}, "n4659": {"so_23030403_23031288_0": {"section_id": 231, "quality": 0.5714285714285714, "length": 4}, "so_23030403_23031288_5": {"section_id": 231, "quality": 1.0, "length": 42}, "so_23030403_23031288_7": {"section_id": 231, "quality": 0.972972972972973, "length": 72}, "so_23030403_23030403_0": {"section_id": 224, "quality": 0.98, "length": 49}, "so_23030403_23031288_6": {"section_id": 231, "quality": 1.0, "length": 42}}}});