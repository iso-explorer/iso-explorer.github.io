post_cb({"31183642": {"ParentId": "31183484", "CommentCount": "0", "Body": "<p>I'm pretty sure this is a mandated standard. Here at the University I attend whenever we used friend functions it was always outside of the class. I'm not 100% sure why myself but I do know that it works without causing problems.</p>\n", "OwnerUserId": "4953728", "PostTypeId": "2", "Id": "31183642", "Score": "0", "CreationDate": "2015-07-02T11:40:32.070", "LastActivityDate": "2015-07-02T11:40:32.070"}, "31183574": {"ParentId": "31183484", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>This is a C++ oddity.</p>\n<blockquote>\n<p id=\"so_31183484_31183574_0\"><code>[C++14: 11.3/7]:</code> <em>[..]</em> A friend function defined in a class is in the (lexical) scope of the class in which it is defined. A friend function defined outside the class is not (3.4.1).</p>\n</blockquote>\n<p>This means that the operator call would work if you made it from within a member function, <a href=\"https://stackoverflow.com/q/4114126/560648\">but not otherwise</a>. Even though it's not a member.</p>\n<p>Argument-dependent lookup is about the only other way to call it, but that's useless to you here because both arguments are <code>X</code>s, not <code>Y</code>s.</p>\n<p>Your workaround is the best way to do it, and avoids this mess (as you've seen).</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:58:16.563", "Id": "31183574", "Score": "5", "CreationDate": "2015-07-02T11:37:54.500", "LastActivityDate": "2015-07-02T11:37:54.500"}, "31183484": {"CommentCount": "1", "ViewCount": "63", "PostTypeId": "1", "ClosedDate": "2015-07-02T11:40:21.580", "LastEditorUserId": "560648", "CreationDate": "2015-07-02T11:34:07.817", "LastActivityDate": "2015-07-02T11:42:15.500", "Title": "Difference between friends defined in-class and outside: bug or feature?", "LastEditDate": "2015-07-02T11:42:15.500", "Id": "31183484", "Score": "3", "Body": "<p>Consider:</p>\n<pre><code>struct Y {\n  Y(float f) : f(f) {}\n  float f;\n};\n\nstruct X {\n  X(Y y) : i(y.f) {}\n  int i;\n  friend bool operator==(X x1, X x2) {\n    return x1.i == x2.i;\n  }\n};\n\nint main()\n{\n    return Y(1) == Y(2); // ERROR\n}\n</code></pre>\n<p>This causes the following error on MSVC and a similar one on Clang:</p>\n<pre><code>'==': candidate function(s) not accessible\ncould be the friend function at '..\\main.cpp(11)' : '=='  [may be found via argument-dependent lookup]\n</code></pre>\n<p>If I move the definition of the friend function out of the class:</p>\n<pre><code>struct X {\n    X(Y y) : i(y.f) {}\n    int i;\n    friend bool operator==(X x1, X x2);\n};\n\ninline bool operator==(X x1, X x2)\n{\n    return x1.i == x2.i;\n}\n</code></pre>\n<p>The expression in <code>main()</code> above compiles fine.</p>\n<p>Is this mandated by the standard or a bug? If it's mandated: why?</p>\n", "Tags": "<c++><language-lawyer><friend-function>", "OwnerUserId": "134841", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31183484_31183574_0": {"section_id": 6690, "quality": 0.8125, "length": 13}}, "n3337": {"so_31183484_31183574_0": {"section_id": 6445, "quality": 0.8125, "length": 13}}, "n4659": {"so_31183484_31183574_0": {"section_id": 8165, "quality": 0.8125, "length": 13}}}});