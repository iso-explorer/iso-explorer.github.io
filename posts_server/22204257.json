post_cb({"22204503": {"ParentId": "22204257", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The standard does seem to not mandate such a thing although I may be missing key passages. All we know about fundamental signed integral types is in 3.9.1/2:</p>\n<blockquote>\n<p id=\"so_22204257_22204503_0\">There are five standard signed integer types : \u201csigned char\u201d, \u201cshort\n  int\u201d, \u201cint\u201d, \u201clong int\u201d, and \u201clong long int\u201d. In this list, each type\n  provides at least as much storage as those preceding it in the list.</p>\n</blockquote>\n<p>And in 3.9.1/7:</p>\n<blockquote>\n<p id=\"so_22204257_22204503_1\">Types bool, char, char16_t, char32_t, wchar_t, and the signed and\n  unsigned integer types are collectively called integral types.48 A\n  synonym for integral type is integer type. The representations of\n  integral types shall define values by use of a pure binary numeration\n  system.</p>\n</blockquote>\n<p>Neither of these passages seem to say anything about the respective positive and negative ranges. Even given that I can't conceive of a binary representation that wouldn't meet your needs.</p>\n", "OwnerUserId": "251738", "LastEditorUserId": "251738", "LastEditDate": "2014-03-05T17:41:35.367", "Id": "22204503", "Score": "3", "CreationDate": "2014-03-05T17:11:19.707", "LastActivityDate": "2014-03-05T17:41:35.367"}, "22204257": {"CommentCount": "3", "ViewCount": "641", "PostTypeId": "1", "LastEditorUserId": "1698548", "CreationDate": "2014-03-05T17:00:14.803", "LastActivityDate": "2014-03-06T22:30:45.500", "Title": "Is the non-negative range of a signed C++ integer at least as big as the negative range?", "LastEditDate": "2014-03-06T22:30:45.500", "Id": "22204257", "Score": "4", "Body": "<p>Does the C++ standard mandate that the <strong>non-negative</strong> range of a standard signed integer type is at least as big as the negative range?</p>\n<p>EDIT: Please note that I am referring to the <strong>non-negative</strong> range here, not the <strong>positive</strong> range which is obviously one smaller than the <strong>non-negative</strong> range.</p>\n<p>EDIT: If we assume C++11, the answer is \"Yes\". See my clarifications below. From the point of view of C++03, the answer is probably \"No\".</p>\n<p>The same question can be posed as follows: Does the standard guarantee that the result of <code>a - b</code> is representable in a standard signed integer type <code>T</code> assuming that both <code>a</code> and <code>b</code> are <strong>negative</strong> values of type <code>T</code>, and that <code>a \u2265 b</code>?</p>\n<p>I know that the standard allows for two's complement, ones' complement, and sign magnitude representation of negative values (see C++11 section 3.9.1 [basic.fundamental] paragraph 7), but I am not sure whether it demands the use of one of those three representations. Probably not.</p>\n<p>If we assume one of these three representations, and we assume that there is no \"spurious\" restrictions on either of the two ranges (negative, and non-negative), then it is indeed true that the non-negative range is at least as big as the negative one. In fact, with two's complement the size of the two ranges will be equal, and with the two other representations, the size of the non-negative range will be one greater than the size of the negative one.</p>\n<p>However, even if we assume one of the mentioned representations, it is really not enough to guarantee anything about the size of either range.</p>\n<p>What I am seeking here, is a section (or set of sections) that unambiguously provides the desired guarantee.</p>\n<p>Any help will be appreciated.</p>\n<hr>\n<p>Note that something like the following would suffice: Every bit within the \"storage slot\" of the integer has one, and only one of the following functions:</p>\n<ul>\n<li>Unused</li>\n<li>Sign bit (exclusively, or mixed sign/value bit)</li>\n<li>Value bit (participating in the value)</li>\n</ul>\n<p>I have a vague memory that C99 says something along those lines. Anyone that knows anything about that?</p>\n<hr>\n<p>Alright, C99 (with TC3) does provide the necessary guarantees in section 6.2.6.2 \"Integer types\" paragraph 2:</p>\n<blockquote>\n<p id=\"so_22204257_22204257_0\">For signed integer types, the bits of the object representation shall be divided into three groups: value bits, padding bits, and the sign bit. There need not be any padding bits; there shall be exactly one sign bit. Each bit that is a value bit shall have the same value as the same bit in the object representation of the corresponding unsigned type (if there are M value bits in the signed type and N in the unsigned type, then M \u2264 N ). If the sign bit is zero, it shall not affect the resulting value. If the sign bit is one, the value shall be modified in one of the following ways:</p>\n<ul>\n<li>the corresponding value with sign bit 0 is negated (sign and magnitude);</li>\n<li>the sign bit has the value \u2212(2<sup>N</sup> ) (two\u2019s complement);</li>\n<li>the sign bit has the value \u2212(2<sup>N</sup> \u2212 1) (ones\u2019 complement ).</li>\n</ul>\n<p id=\"so_22204257_22204257_1\">Which of these applies is implementation-defined, as is whether the value with sign bit 1 and all value bits zero (for the first two), or with sign bit and all value bits 1 (for ones\u2019 complement), is a trap representation or a normal value. In the case of sign and magnitude and ones\u2019 complement, if this representation is a normal value it is called a negative zero.</p>\n</blockquote>\n<p>Can someone confirm that this part of C99 is also a binding part of C++11?</p>\n<hr>\n<p>I have taken another careful look at both the C99 and the C++11 standards, and it is clear that the guarantees in C99 section 6.2.6.2 paragraph 2 are binding in C++11 too.</p>\n<p>C89/C90 does not provide the same guarantees, so we do need C99, which means that we do need C++11.</p>\n<p>In summary, C++11 (and C99) provides the following guarantees:</p>\n<ol>\n<li><p>Negative values in fundamental signed integers types (standard + extended) <strong>must</strong> be represented using one of the following three representations: Two's complement, ones' complement, or sign magnitude.</p></li>\n<li><p>The size of the <strong>non-negative</strong> range is <strong>one</strong> greater than, or equal to the size of the negative range for all fundamental signed integers types (standard + extended).</p></li>\n</ol>\n<p>The second guarantee can be restated as follows:</p>\n<pre><code>-1 \u2264 min&lt;T&gt; + max&lt;T&gt; \u2264 0\n</code></pre>\n<p>for any fundamental signed integers type <code>T</code> (standard + extended) where <code>min&lt;T&gt;</code> and <code>max&lt;T&gt;</code> are shorthands for <code>std::numeric_limits&lt;T&gt;::min()</code> and <code>std::numeric_limits&lt;T&gt;::max()</code> respectively.</p>\n<p>Also, if we assume that <code>a</code> and <code>b</code> are values of the same, or of different fundamental signed integer types (standard or extended), then it follows that <code>a - b</code> is well defined and representable in <code>decltype(a - b)</code> as long as <code>a</code> and <code>b</code> are either both negative or both non-negative.</p>\n</hr></hr></hr>", "Tags": "<c++><signed><twos-complement>", "OwnerUserId": "1698548", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_22204257_22204503_1": {"section_id": 7216, "quality": 0.9, "length": 27}, "so_22204257_22204503_0": {"section_id": 7211, "quality": 1.0, "length": 25}}, "n3337": {"so_22204257_22204503_1": {"section_id": 6960, "quality": 0.9, "length": 27}, "so_22204257_22204503_0": {"section_id": 6955, "quality": 1.0, "length": 25}}, "n4659": {"so_22204257_22204503_1": {"section_id": 8725, "quality": 0.9333333333333333, "length": 28}, "so_22204257_22204503_0": {"section_id": 8720, "quality": 0.96, "length": 24}}}});