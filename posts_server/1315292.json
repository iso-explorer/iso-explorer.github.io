post_cb({"1315292": {"CommentCount": "0", "ViewCount": "9419", "PostTypeId": "1", "LastEditorUserId": "834176", "CreationDate": "2009-08-22T06:22:42.283", "LastActivityDate": "2017-10-01T18:27:25.983", "AnswerCount": "8", "LastEditDate": "2012-07-30T15:06:12.690", "FavoriteCount": "6", "Title": "Static constant versus constant in a function that is called repeatedly", "Id": "1315292", "Score": "24", "Body": "<p>I'm just wondering how </p>\n<pre><code>void test()\n{\n   const static int ABC = 12;\n   cout &lt;&lt; ABC;\n}\n</code></pre>\n<p>is different from</p>\n<pre><code>void test()\n{\n   const int ABC = 12;\n   cout &lt;&lt; ABC;\n}\n</code></pre>\n<p>if this function is repeatedly called while the program is executing? What I mean is, is there any performance difference? Or is there a reason why you should prefer one over the other?</p>\n", "Tags": "<c++><static><const>", "OwnerDisplayName": "Jordan Smith"}, "1315301": {"ParentId": "1315292", "CommentCount": "1", "Body": "<p>I would go with the second one - it is more readable. why unnecesarily add a keyword (static) that does not really add any value to someone reading the code. </p>\n", "OwnerUserId": "159937", "PostTypeId": "2", "Id": "1315301", "Score": "-1", "CreationDate": "2009-08-22T06:27:32.430", "LastActivityDate": "2009-08-22T06:27:32.430"}, "1316009": {"ParentId": "1315292", "CommentCount": "0", "Body": "<p>There are a couple of things that affect the answer:</p>\n<ul>\n<li>First, as long as the value is <code>const</code> it will almost certainly be optimized out in any case. That means that the resulting code will most likely be the same.</li>\n<li>Second, <code>static</code> members are stored elsewhere which means less locality and probably a cache miss.</li>\n<li>Third, the cost of initialization depends on the type. In your case, for an int, the cost of initialization is basically nonexistent. For more complex user-defined types, it may be huge.</li>\n</ul>\n<p>So the answer is, in cases simple enough for the compiler to figure them out and optimize, it makes <em>zero</em> difference. In your example that would almost certainly be the case.</p>\n<p>As long as the variable has a type that is easy and cheap to construct, prefer non-static to avoid the cache miss.</p>\n<p>If the type is expensive to construct, you <em>might</em> want to use <code>static</code>.</p>\n<p>And of course, last, and most importantly of all:</p>\n<p>Don't trust our guesswork. If you are concerned about performance, there is only one correct course of action:</p>\n<ul>\n<li>Measure it, to verify that it is actually a problem</li>\n<li>Measure the performance of each possible solution</li>\n<li>Pick the solution that results in the best performance.</li>\n</ul>\n", "OwnerUserId": "33213", "PostTypeId": "2", "Id": "1316009", "Score": "41", "CreationDate": "2009-08-22T13:44:34.300", "LastActivityDate": "2009-08-22T13:44:34.300"}, "1315295": {"ParentId": "1315292", "CommentCount": "1", "Body": "<p>well theoretically the former method is a tiny bit better as it only insantiates the variable once.</p>\n<p>However the compiler will simply remove either \"const\" line and substitute \"cout &lt;&lt; 12;\" into the function (When compiled with optimisations on, obviously).</p>\n", "OwnerUserId": "131140", "PostTypeId": "2", "Id": "1315295", "Score": "2", "CreationDate": "2009-08-22T06:25:24.870", "LastActivityDate": "2009-08-22T06:25:24.870"}, "1316023": {"ParentId": "1315292", "CommentCount": "0", "Body": "<p>It depends on the compiler.</p>\n<p>In embedded software, a static const will typically be stored in flash (i.e. code memory), and will be accessed directly, like a normal variable, without any need for initialisation.</p>\n<p>In contrast, a non-static const may have its <em>value</em> stored in flash, but the const itself will be created on the stack like a variable, and be initialised just like a variable.</p>\n<p>If this is how your compiler handles these scenarios, then the static const is more efficient, as it requires neither stack allocation nor initialisation.</p>\n<p>Obviously, these scenarios may be handled different by non-embedded compilers.</p>\n", "OwnerUserId": "45552", "PostTypeId": "2", "Id": "1316023", "Score": "1", "CreationDate": "2009-08-22T13:51:26.307", "LastActivityDate": "2009-08-22T13:51:26.307"}, "31097322": {"ParentId": "1315292", "CommentCount": "1", "Body": "<p>The static const example certainly saves on execution time for subsequent calls, much faster for complex object construction to use static const, but I question the need to limit the ABC to function scope and introduce a variation in behaviour on the function from 1st call to following calls. Usually a file contains coupled functionally coupled functions, just give ABC file scope and be done with it.</p>\n", "OwnerUserId": "3359771", "PostTypeId": "2", "Id": "31097322", "Score": "-1", "CreationDate": "2015-06-28T07:47:24.303", "LastActivityDate": "2015-06-28T07:47:24.303"}, "1315363": {"ParentId": "1315292", "CommentCount": "0", "Body": "<p>For a basic type, such as an integer value, then I would pigeon hole the use of static as a \"premature optimisation\" unless you have done some benchmarking and taken into account the various trade offs (for example initialising a static to a non-zero value often requires an entry in a table to specify the position, size and initial value to be set when the code is loaded).</p>\n<p>Unless you are taking a pointer to the int and it is dereferenced after your function returns then you don't need the static - let the compiler do the optimisation.</p>\n<p>If a pointer to the value is dereferenced after your function has exited then I would class it as a persistent state variable and it would be good practice to define it at at the class or module level to make that clear.</p>\n", "OwnerUserId": "35989", "PostTypeId": "2", "Id": "1315363", "Score": "0", "CreationDate": "2009-08-22T07:02:31.160", "LastActivityDate": "2009-08-22T07:02:31.160"}, "1315300": {"ParentId": "1315292", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>In first cast ABC will be initialized only once, on first function call. In second case ABC will be initialized every time. You'll feel the difference if ABC is complex type with constructor. It could allocate memory or initialize some mutex. For int there is no difference in practice.</p>\n<p>According to C++03 Standard 3.7.1/2:</p>\n<blockquote>\n<p id=\"so_1315292_1315300_0\">If an object of static storage duration has initialization or a destructor with side effects, it shall not be eliminated even if it appears to be unused, except that a class object or its copy may be eliminated as specified in\n  12.8.</p>\n</blockquote>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2009-08-22T06:33:51.293", "Id": "1315300", "Score": "2", "CreationDate": "2009-08-22T06:26:20.233", "LastActivityDate": "2009-08-22T06:33:51.293"}, "bq_ids": {"n4140": {"so_1315292_1315300_0": {"section_id": 7165, "quality": 0.8571428571428571, "length": 18}}, "n3337": {"so_1315292_1315300_0": {"section_id": 6909, "quality": 0.8571428571428571, "length": 18}}, "n4659": {"so_1315292_1315300_0": {"section_id": 8673, "quality": 0.8571428571428571, "length": 18}}}, "46515527": {"ParentId": "1315292", "CommentCount": "0", "Body": "<p>You can also get a good idea of what the compiler will do by making use of your compiler's assembler or something like this online utility: <a href=\"https://godbolt.org\" rel=\"nofollow noreferrer\">https://godbolt.org</a> and taking a look at the resulting assembly code.</p>\n<p>This was worth a look, since the question is fundamental.</p>\n<p>An example based on your question, looking at primitives vs \"complex\" (not even very) considering local vs static type declaration and instantiation:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct non_primitive\n{\n    int v;\n    non_primitive(const int v_) : v(v_) {}\n};\n\nvoid test_non_static_const_primitive()\n{\n   const int ABC = 12;\n   std::cout &lt;&lt; ABC;\n}\n\nvoid test_static_const_primitive()\n{\n   const static int ABC = 12;\n   std::cout &lt;&lt; ABC;\n}\n\nvoid test_non_static_constant_non_primitive_global_struct() \n{\n    const non_primitive s(12);\n    std::cout &lt;&lt; s.v;\n}\n\nvoid test_non_static_constant_non_primitive_local_struct() \n{\n    struct local_non_primitive\n    {\n        int v;\n        local_non_primitive(const int v_) : v(v_) {}\n    };\n    const local_non_primitive s(12);\n    std::cout &lt;&lt; s.v;\n}\n\nvoid test_static_constant_non_primitive_global_struct() \n{\n    const static non_primitive s(12);\n    std::cout &lt;&lt; s.v;\n}\n\nvoid test_static_constant_non_primitive_local_struct() \n{\n    struct local_non_primitive\n    {\n        int v;\n        local_non_primitive(const int v_) : v(v_) {}\n    };\n    const static local_non_primitive s(12);\n    std::cout &lt;&lt; s.v;\n}\n</code></pre>\n<p>The compiler recognizes that it doesn't have to deal with any memory linkage for local const complex types, and the first four cases are treated identically.  It looks like the compiler doesn't try to explore the complex type's relative simplicity and potential for further simplification in the static instantiation. </p>\n<p>The resulting cost difference is relatively huge.</p>\n<p>The compiled assembly code using gcc7.2 with -O3 optimization:</p>\n<pre><code>test_non_static_const_primitive():\n  mov esi, 12\n  mov edi, OFFSET FLAT:std::cout\n  jmp std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)\ntest_static_const_primitive():\n  mov esi, 12\n  mov edi, OFFSET FLAT:std::cout\n  jmp std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)\ntest_non_static_constant_non_primitive_global_struct():\n  mov esi, 12\n  mov edi, OFFSET FLAT:std::cout\n  jmp std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)\ntest_non_static_constant_non_primitive_local_struct():\n  mov esi, 12\n  mov edi, OFFSET FLAT:std::cout\n  jmp std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)\ntest_static_constant_non_primitive_global_struct():\n  movzx eax, BYTE PTR guard variable for test_static_constant_non_primitive_global_struct()::s[rip]\n  test al, al\n  je .L7\n  mov esi, DWORD PTR test_static_constant_non_primitive_global_struct()::s[rip]\n  mov edi, OFFSET FLAT:std::cout\n  jmp std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)\n.L7:\n  sub rsp, 8\n  mov edi, OFFSET FLAT:guard variable for test_static_constant_non_primitive_global_struct()::s\n  call __cxa_guard_acquire\n  test eax, eax\n  mov esi, DWORD PTR test_static_constant_non_primitive_global_struct()::s[rip]\n  je .L8\n  mov edi, OFFSET FLAT:guard variable for test_static_constant_non_primitive_global_struct()::s\n  mov DWORD PTR test_static_constant_non_primitive_global_struct()::s[rip], 12\n  call __cxa_guard_release\n  mov esi, 12\n.L8:\n  mov edi, OFFSET FLAT:std::cout\n  add rsp, 8\n  jmp std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)\ntest_static_constant_non_primitive_local_struct():\n  movzx eax, BYTE PTR guard variable for test_static_constant_non_primitive_local_struct()::s[rip]\n  test al, al\n  je .L14\n  mov esi, DWORD PTR test_static_constant_non_primitive_local_struct()::s[rip]\n  mov edi, OFFSET FLAT:std::cout\n  jmp std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)\n.L14:\n  sub rsp, 8\n  mov edi, OFFSET FLAT:guard variable for test_static_constant_non_primitive_local_struct()::s\n  call __cxa_guard_acquire\n  test eax, eax\n  mov esi, DWORD PTR test_static_constant_non_primitive_local_struct()::s[rip]\n  je .L15\n  mov edi, OFFSET FLAT:guard variable for test_static_constant_non_primitive_local_struct()::s\n  mov DWORD PTR test_static_constant_non_primitive_local_struct()::s[rip], 12\n  call __cxa_guard_release\n  mov esi, 12\n.L15:\n  mov edi, OFFSET FLAT:std::cout\n  add rsp, 8\n  jmp std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)\n_GLOBAL__sub_I__Z31test_non_static_const_primitivev:\n  sub rsp, 8\n  mov edi, OFFSET FLAT:std::__ioinit\n  call std::ios_base::Init::Init()\n  mov edx, OFFSET FLAT:__dso_handle\n  mov esi, OFFSET FLAT:std::__ioinit\n  mov edi, OFFSET FLAT:std::ios_base::Init::~Init()\n  add rsp, 8\n  jmp __cxa_atexit\n</code></pre>\n", "OwnerUserId": "1120350", "PostTypeId": "2", "Id": "46515527", "Score": "1", "CreationDate": "2017-10-01T18:27:25.983", "LastActivityDate": "2017-10-01T18:27:25.983"}});