post_cb({"29809241": {"ViewCount": "268", "Body": "<p>Is the following well-defined?</p>\n<pre><code>class A;\nclass B;\n\n// define A, which takes B&amp; in constructor\n// define B, which takes A&amp; in constructor\n\nclass C\n{\n    A a;\n    B b;\npublic:\n    C() : a(b), b(a) { /* stuff with a and b */ }\n}\n</code></pre>\n<p>Full example at <a href=\"https://ideone.com/EuVNca\" rel=\"noreferrer\">ideone.com</a>.</p>\n<p>Is it safe/well-defined so long as the constructors for <code>A</code> and <code>B</code> don't do anything with the references they get? </p>\n", "AcceptedAnswerId": "29809865", "Title": "Circular dependency in constructor initialization list", "CreationDate": "2015-04-22T21:30:46.960", "Id": "29809241", "CommentCount": "4", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-04-22T21:34:40.127", "LastEditorUserId": "3848", "LastActivityDate": "2015-04-22T22:12:13.347", "Score": "5", "OwnerUserId": "15055", "Tags": "<c++><constructor><initialization><circular-dependency><initialization-list>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29809241_29809865_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 444}}, "n3337": {"so_29809241_29809865_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 435}}, "n4659": {"so_29809241_29809865_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 467}}}, "29809865": {"Id": "29809865", "PostTypeId": "2", "Body": "<p>N4140 [class.cdtor]/1 reads:</p>\n<blockquote>\n<p id=\"so_29809241_29809865_0\">For an object with a non-trivial constructor, referring to any non-static member or base class of the object\n  before the constructor begins execution results in undefined behavior. For an object with a non-trivial\n  destructor, referring to any non-static member or base class of the object after the destructor finishes\n  execution results in undefined behavior.</p>\n</blockquote>\n<p>While this passage itself doesn't imply that the behavior is otherwise well-defined, the following example shows that it is. Here is an excerpt:</p>\n<pre><code>struct B : public A { int j; Y y; }; // non-trivial\nextern B bobj;\nB* pb = &amp;bobj; // OK\n</code></pre>\n<p>So the answer is: yes, the behavior in your case is well defined if you aren't referring to members or base classes of <code>b</code> in the constructor of <code>A</code>.</p>\n", "LastActivityDate": "2015-04-22T22:12:13.347", "CommentCount": "4", "CreationDate": "2015-04-22T22:12:13.347", "ParentId": "29809241", "Score": "2", "OwnerUserId": "3959454"}});