post_cb({"bq_ids": {"n4140": {"so_13951720_13951845_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 6148}, "so_13951720_13951845_1": {"length": 32, "quality": 0.8421052631578947, "section_id": 6147}}, "n3337": {"so_13951720_13951845_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 5911}, "so_13951720_13951845_1": {"length": 32, "quality": 0.8421052631578947, "section_id": 5910}}, "n4659": {"so_13951720_13951845_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 7644}, "so_13951720_13951845_1": {"length": 32, "quality": 0.8421052631578947, "section_id": 7643}}}, "13951845": {"Id": "13951845", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13951720_13951845_0\">Why it fails when one argument is positive and another negative?\n  What is the workaround in function foo() to display results correctly for all cases i.e. for all negative and positive arguments ?</p>\n</blockquote>\n<p>The answer lies with in C99-Standard (ISO C99 : 6.5.7 Bitwise shift operators):</p>\n<blockquote>\n<p id=\"so_13951720_13951845_1\">/4. The result of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions; vacated bits are filled with\n  zeros. If <code>E1</code> has an unsigned type, the value of the result is <code>E1 \u00d7 2E2</code>, reduced modulo\n  one more than the maximum value representable in the result type. If <code>E1</code> has a signed\n  type and nonnegative value, and <code>E1 \u00d7 2E2</code> is representable in the result type, then that is\n  the resulting value; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>So <code>foo(-2,-2)</code> is <em>undefined behavior</em>.</p>\n<blockquote>\n<p id=\"so_13951720_13951845_2\">/5. The result of <code>E1 &gt;&gt; E2</code> is <code>E1</code> right-shifted <code>E2</code> bit positions. If <code>E1</code> has an unsigned type\n  or if <code>E1</code> has a signed type and a nonnegative value, the value of the result is the integral\n  part of the quotient of <code>E1 / 2E2</code>. If <code>E1</code> has a signed type and a negative value, the\n  resulting value is implementation-defined.</p>\n</blockquote>\n<p>So <code>foo(-8,8)</code> is <em>implementation-defined</em>.</p>\n", "LastEditorUserId": "492901", "LastActivityDate": "2012-12-19T12:25:46.813", "Score": "5", "CreationDate": "2012-12-19T11:51:16.877", "ParentId": "13951720", "CommentCount": "3", "OwnerUserId": "270060", "LastEditDate": "2012-12-19T12:25:46.813"}, "13951789": {"Id": "13951789", "PostTypeId": "2", "Body": "<p>That's not an equality check (as you can clearly see from the results), it's an assignment:</p>\n<pre><code>a = ( a &gt;&gt; ( b = b &lt;&lt; a ) );  //results in UB for negatives\n</code></pre>\n<p>An equality check is the simple</p>\n<pre><code>a == b;\n</code></pre>\n", "LastEditorUserId": "673730", "LastActivityDate": "2013-09-10T08:14:46.923", "Score": "7", "CreationDate": "2012-12-19T11:48:27.597", "ParentId": "13951720", "CommentCount": "4", "OwnerUserId": "673730", "LastEditDate": "2013-09-10T08:14:46.923"}, "13952351": {"Id": "13952351", "PostTypeId": "2", "Body": "<p>Trying a few more values:</p>\n<pre><code>1,0: Equal\n0,0: Not Equal\n1,1: Not Equal\n2,2: Not Equal\n3,3: Not Equal\n</code></pre>\n<p>indicating that it isn't an equality check at all.</p>\n<p>The expression has undefined behaviour, since it performs two unsequenced modifications of <code>a</code>. If we assume that your compiler evaluates it as if there were a sequence point after the left shift, i.e.</p>\n<pre><code>b &lt;&lt;= a;\na &gt;&gt;= b;\nreturn a ? 1 : 0;\n</code></pre>\n<p>then it's quite easy to see that, unless <code>b</code> is zero, this always returns zero, <em>unless</em> the left-shift overflows, in which case behaviour is again undefined.</p>\n", "LastActivityDate": "2012-12-19T12:19:22.683", "CommentCount": "0", "CreationDate": "2012-12-19T12:19:22.683", "ParentId": "13951720", "Score": "4", "OwnerUserId": "204847"}, "13951720": {"ViewCount": "517", "Body": "<pre><code>#include &lt;stdio.h&gt;\n\nint foo(int a, int b)\n{\n        return ((a&gt;&gt;= b&lt;&lt;= a) ? 1 : 0);\n}\n\nvoid bar(int x, int y)\n{\n        printf(\"%d,%d: %s\\n\",x, y, (foo(x,y) ? \"Equal\" : \"Not Equal\"));\n}\n\nint main()\n{\n        bar(0,1);\n        bar(4,4);\n        bar(3,2);\n        bar(9,9);\n        bar(-2,-2);\n        bar(-8,8);\n        return 0;\n}\n</code></pre>\n<p>The output of the above program is</p>\n<pre><code>0,1: Not Equal\n4,4: Equal\n3,2: Not Equal\n9,9: Equal\n-2,-2: Equal\n-8,8: Equal\n</code></pre>\n<p>Can you help me in understanding how the <strong>equality check</strong> in function <code>foo</code>() works? Why it fails when one argument is positive and another negative? What is the workaround in function <code>foo</code>() to display results correctly for all cases i.e. for all negative and positive arguments ?</p>\n<p><strong>EDIT</strong>: From the answers below, results for other values are:</p>\n<pre><code>70,72: Equal\n-2,-2: Equal\n64,64: Equal\n128,32: Equal\n256,250: Not Equal\n250,256: Equal\n-250,-256: Equal\n</code></pre>\n<p>Please explain, why this equality check works for some value sets, and not for others. What is happening inside?</p>\n", "AcceptedAnswerId": "13951789", "Title": "Strange equality check using bitwise shift operators", "CreationDate": "2012-12-19T11:44:58.857", "Id": "13951720", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-12-19T12:06:45.863", "LastEditorUserId": "220386", "LastActivityDate": "2013-09-10T08:14:46.923", "Score": "1", "OwnerUserId": "220386", "Tags": "<c++><c><linux><operators><bit-manipulation>", "AnswerCount": "3"}});