post_cb({"bq_ids": {"n4140": {"so_29434001_29434109_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 7230}, "so_29434001_29434142_3": {"length": 4, "quality": 0.8, "section_id": 3498}}, "n3337": {"so_29434001_29434142_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 6921}, "so_29434001_29434142_3": {"length": 4, "quality": 0.8, "section_id": 3363}, "so_29434001_29434109_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 6974}}, "n4659": {"so_29434001_29434142_3": {"length": 4, "quality": 0.8, "section_id": 4261}}}, "29434001": {"ViewCount": "185", "Body": "<p>In smart pointer implementation, dereferencing operator and member selection operators are always defined as below. </p>\n<pre><code>T&amp; operator* () const     // dereferencing operator\n{\n    return *(m_pRawPointer); \n}\n\nT* operator-&gt;() const     // member selection operator\n{\n    return m_pRowPointer;\n}\n</code></pre>\n<p>I don't quite understand why the former is returned by reference, the latter is returned by pointer. Is it just to differentiate them or some other reasons?\nTo be more specific, can I make dereferencing operator returns by pointer, while the other one returns by reference?</p>\n", "AcceptedAnswerId": "29434142", "Title": "Regarding definition of dereferencing and member selection operators in smart pointer", "CreationDate": "2015-04-03T14:23:28.793", "Id": "29434001", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-04-03T14:35:11.417", "Score": "0", "OwnerUserId": "4746527", "Tags": "<c++><operator-overloading><smart-pointers><dereference>", "AnswerCount": "2"}, "29434142": {"Id": "29434142", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_29434001_29434142_0\">why the former is returned by reference</p>\n</blockquote>\n<p>So that the expression <code>*thing</code> gives an <em>lvalue</em> denoting an object of type <code>T</code>, just as it would if <code>thing</code> were a pointer.</p>\n<blockquote>\n<p id=\"so_29434001_29434142_1\">the latter is returned by pointer</p>\n</blockquote>\n<p>Because that's how the language is specified. Note that you never use the result of <code>-&gt;</code> directly, but always in an expression of the form <code>thing-&gt;member</code>. </p>\n<p>If <code>thing</code> is a class type, that's evaluated by calling <code>operator-&gt;</code>, then applying <code>-&gt;member</code> to the result of that. To support that, it must return either a pointer, or another class type which also overloads <code>operator-&gt;</code>.</p>\n<blockquote>\n<p id=\"so_29434001_29434142_2\">can I make dereferencing operator returns by pointer</p>\n</blockquote>\n<p>Yes, but that would be rather confusing since it would behave differently to applying the same operator a pointer. You'd have to say <code>**thing</code> to access the <code>T</code>.</p>\n<blockquote>\n<p id=\"so_29434001_29434142_3\">while the other one returns by reference</p>\n</blockquote>\n<p>No, because that would break the language's built-in assumptions about how the overloaded operator should work, making it unusable.</p>\n", "LastActivityDate": "2015-04-03T14:31:58.313", "CommentCount": "0", "CreationDate": "2015-04-03T14:31:58.313", "ParentId": "29434001", "Score": "1", "OwnerUserId": "204847"}, "29434109": {"Id": "29434109", "PostTypeId": "2", "Body": "<p>The reason that the dereference operator returns by reference and the member selection operator returns by pointer is to line up the syntax of using a smart pointer with the syntax of using a raw pointer:</p>\n<pre><code>int* p = new int(42);\n*p = 7;\n\nstd::unique_ptr&lt;int&gt; p(new int(42));\n*p = 7;\n</code></pre>\n<p>You could absolutely make your dereference operator return anything you like:</p>\n<pre><code>struct IntPtr {\n    int* p;\n\n    int* operator*() { return p; }\n};\n</code></pre>\n<p>But that would be pretty confusing for your users when they have to write:</p>\n<pre><code>IntPtr p{new int{42}};\n**p = 7;\n</code></pre>\n<p>The arrow operator is a little different in that [over.ref]:</p>\n<blockquote>\n<p id=\"so_29434001_29434109_0\">An expression <code>x-&gt;m</code> is interpreted as <code>(x.operator-&gt;())-&gt;m</code></p>\n</blockquote>\n<p>So you have to return something on which you can call <code>-&gt;m</code>, otherwise you'll just get an error like (from gcc):</p>\n<blockquote>\n<p id=\"so_29434001_29434109_1\">error: result of 'operator-&gt;()' yields non-pointer result</p>\n</blockquote>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-04-03T14:35:11.417", "Score": "0", "CreationDate": "2015-04-03T14:29:56.053", "ParentId": "29434001", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2015-04-03T14:35:11.417"}});