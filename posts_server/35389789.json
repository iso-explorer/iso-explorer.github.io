post_cb({"bq_ids": {"n4140": {"so_35389789_35389789_6": {"length": 8, "quality": 0.8888888888888888, "section_id": 7162}, "so_35389789_35395517_6": {"length": 16, "quality": 1.0, "section_id": 7195}, "so_35389789_35395517_7": {"length": 17, "quality": 1.0, "section_id": 7195}, "so_35389789_35395517_2": {"length": 15, "quality": 0.9375, "section_id": 7192}, "so_35389789_35395517_3": {"length": 43, "quality": 1.0, "section_id": 7195}, "so_35389789_35389789_4": {"length": 14, "quality": 0.7777777777777778, "section_id": 6082}, "so_35389789_35395517_0": {"length": 29, "quality": 0.90625, "section_id": 7196}, "so_35389789_35395517_1": {"length": 16, "quality": 1.0, "section_id": 7192}, "so_35389789_35395517_4": {"length": 10, "quality": 1.0, "section_id": 7195}, "so_35389789_35395517_5": {"length": 9, "quality": 1.0, "section_id": 7195}}, "n3337": {"so_35389789_35389789_6": {"length": 8, "quality": 0.8888888888888888, "section_id": 6906}, "so_35389789_35395517_6": {"length": 16, "quality": 1.0, "section_id": 6939}, "so_35389789_35389789_4": {"length": 14, "quality": 0.7777777777777778, "section_id": 5850}, "so_35389789_35395517_2": {"length": 15, "quality": 0.9375, "section_id": 6936}, "so_35389789_35395517_3": {"length": 43, "quality": 1.0, "section_id": 6939}, "so_35389789_35395517_7": {"length": 17, "quality": 1.0, "section_id": 6939}, "so_35389789_35395517_0": {"length": 29, "quality": 0.90625, "section_id": 6940}, "so_35389789_35395517_4": {"length": 10, "quality": 1.0, "section_id": 6939}, "so_35389789_35395517_1": {"length": 16, "quality": 1.0, "section_id": 6936}, "so_35389789_35395517_5": {"length": 9, "quality": 1.0, "section_id": 6939}}, "n4659": {"so_35389789_35389789_6": {"length": 6, "quality": 0.6666666666666666, "section_id": 8669}, "so_35389789_35395517_6": {"length": 16, "quality": 1.0, "section_id": 8704}, "so_35389789_35389789_4": {"length": 14, "quality": 0.7777777777777778, "section_id": 7578}, "so_35389789_35395517_2": {"length": 15, "quality": 0.9375, "section_id": 8701}, "so_35389789_35395517_3": {"length": 43, "quality": 1.0, "section_id": 8704}, "so_35389789_35395517_7": {"length": 17, "quality": 1.0, "section_id": 8704}, "so_35389789_35395517_0": {"length": 29, "quality": 0.90625, "section_id": 8705}, "so_35389789_35395517_4": {"length": 10, "quality": 1.0, "section_id": 8704}, "so_35389789_35395517_1": {"length": 16, "quality": 1.0, "section_id": 8701}, "so_35389789_35395517_5": {"length": 9, "quality": 1.0, "section_id": 8704}}}, "35395517": {"Id": "35395517", "PostTypeId": "2", "Body": "<p>It seems to me that the standard (as quoted in the OP) can only be interpreted as it reads, which is that <strong>operator new creates objects of dynamic storage duration</strong>, and this is true even if the underlying memory was obtained for an object of automatic duration.</p>\n<p>This precise scenario is anticipated by the standard in \u00a73.8 [basic.life] paragraph 8, with reference to the following example of undefined behaviour:</p>\n<pre><code>class T { };\nstruct B {\n    ~B();\n};\nvoid h() {\n    B b;\n    new (&amp;b) T;\n}\n</code></pre>\n<p>The paragraph reads:</p>\n<blockquote>\n<p id=\"so_35389789_35395517_0\">If a program ends the lifetime of an object of type T with static (3.7.1), thread (3.7.2), or automatic (3.7.3) storage duration and if T has a non-trivial destructor, the program must ensure that an object of the original type occupies that same storage location when the implicit destructor call takes place; otherwise the behavior of the program is undefined.</p>\n</blockquote>\n<p>In the example, the program has \"ended the lifetime\" of the object <code>b</code> by reusing its storage, as provided by paragraph 4 of the same section: (emphasis added).</p>\n<blockquote>\n<p id=\"so_35389789_35395517_1\">A program may end the lifetime of any object by <em>reusing the storage which the object occupies</em> or by explicitly calling the destructor for an object of a class type with a non-trivial destructor.</p>\n</blockquote>\n<p>In the example code, <code>b</code>'s destructor was not called but this is acceptable because paragraph 4 explicitly allows a non-trivial destructor to not be called:</p>\n<blockquote>\n<p id=\"so_35389789_35395517_2\">For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released;</p>\n</blockquote>\n<p>as long as the program is prepared to live with the consequences of the destructor not being called.</p>\n<p>But to return to paragraph 8, <code>b</code>'s lifetime has ended, and the storage has been reused to create an object of type <code>T</code>. This object has dynamic storage duration, which means that its destructor will not be called implicitly. As above, it is not obligatory to explicitly call the destructor either, as long as the program does not require any side-effects which might be performed by the destructor.</p>\n<p>Despite the fact that the lifetime of <code>b</code> has ended, the fact that <code>b</code> had automatic storage duration means that its destructor will be implicitly called when control flow leaves its scope. Calling a destructor on an object whose lifetime has ended is a specific case of the prohibition on using an object whose lifetime has ended, as per paragraph 6 of \u00a73.8, which prohibits calling a non-static member member function of an object whose lifetime has ended but whose storage has not yet been reused or released.</p>\n<p>For this reason, the example program's behaviour is undefined.</p>\n<p>But paragraph 7 of this section provides a mechanism for the program to avoid the undefined behaviour by recreating a different object of the same type at the same location:</p>\n<blockquote>\n<p id=\"so_35389789_35395517_3\">If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be used to manipulate the new object, if:</p>\n<p id=\"so_35389789_35395517_4\">(7.1) \u2014 the storage for the new object exactly overlays the storage location which the original object occupied, and</p>\n<p id=\"so_35389789_35395517_5\">(7.2) \u2014 the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and</p>\n<p id=\"so_35389789_35395517_6\">(7.3) \u2014 the type of the original object is not const-qualified, and, if a class type, does not contain any non-static data member whose type is const-qualified or a reference type, and</p>\n<p id=\"so_35389789_35395517_7\">(7.4) \u2014 the original object was a most derived object (1.8) of type T and the new object is a most derived object of type T (that is, they are not base class subobjects).</p>\n</blockquote>\n<p>So, in my interpretation, the following snippet would have defined behaviour:</p>\n<pre><code>class T { };\nstruct B {\n    ~B();\n};\nvoid h() {\n    B b;\n    new (&amp;b) T;\n    new (&amp;b) B; /* recreate a B so that it can be destructed */\n}\n</code></pre>\n<p>In short, the standard contemplates the possibility that an object of dynamic storage duration can be created using memory allocated to an object of automatic storage duration, and provides a set of restrictions and requirements for a well-defined program which performs this action, thereby avoiding the consequences of executing an implicit destructor on an object whose lifetime has been ended by reusing its storage.</p>\n", "LastEditorUserId": "1566221", "LastActivityDate": "2016-02-14T19:09:09.527", "Score": "7", "CreationDate": "2016-02-14T18:32:55.800", "ParentId": "35389789", "CommentCount": "7", "LastEditDate": "2016-02-14T19:09:09.527", "OwnerUserId": "1566221"}, "35389789": {"ViewCount": "140", "Body": "<blockquote>\n<p id=\"so_35389789_35389789_0\"><strong>(5.3.4)</strong></p>\n<p id=\"so_35389789_35389789_1\"><strong>new-expression:</strong></p>\n<ul>\n<li><p id=\"so_35389789_35389789_2\">::<strong>opt_</strong>new new-placement_<strong>opt</strong> new-type-id new-initializeropt</p></li>\n<li><p id=\"so_35389789_35389789_3\">::<strong>opt_</strong>new new-placement_<strong>opt</strong> ( type-id ) new-initializeropt</p></li>\n</ul>\n<p id=\"so_35389789_35389789_4\">Entities created <strong>by a new-expression have dynamic storage duration</strong>\n  (3.7.4). [ Note: the lifetime of such an entity <strong>is not necessarily\n  restricted to the scope in which it is created</strong>. \u2014 end note ]</p>\n</blockquote>\n<p>I think the following has 1 main object (<strong>local_object</strong>) with <strong>automatic</strong> storage duration, and 3 dummy classes with <strong>dynamic</strong> storage duration.</p>\n<pre><code>struct dummy\n{\n    int a;\n};\n\nchar local_object[256];\ndummy * a = new(&amp;local_object) dummy;\ndummy * b = new(&amp;local_object +100) dummy;\ndummy * c = new(&amp;local_object +200) dummy;\n</code></pre>\n<p>The user @M.M. argues that there's only one object (local_object), and that the rest are just pointers. Is this correct?</p>\n<blockquote>\n<p id=\"so_35389789_35389789_5\"><strong>(3.7)</strong></p>\n<p id=\"so_35389789_35389789_6\">The <strong>dynamic storage duration</strong> is associated with objects created with <strong>operator new</strong></p>\n</blockquote>\n", "AcceptedAnswerId": "35395517", "Title": "Does an object created with placement new have dynamic storage duration?", "CreationDate": "2016-02-14T08:25:51.030", "Id": "35389789", "CommentCount": "14", "LastEditDate": "2016-02-14T18:37:34.233", "PostTypeId": "1", "LastEditorUserId": "1566221", "LastActivityDate": "2016-02-14T19:09:09.527", "Score": "7", "OwnerUserId": "5866175", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}});