post_cb({"46874055": {"CommentCount": "1", "AcceptedAnswerId": "46874207", "PostTypeId": "1", "LastEditorUserId": "1505939", "CreationDate": "2017-10-22T12:27:38.867", "LastActivityDate": "2017-10-22T13:19:02.807", "LastEditDate": "2017-10-22T12:31:27.320", "ViewCount": "608", "FavoriteCount": "2", "Title": "Why is \"inline\" required on static inline variables?", "Id": "46874055", "Score": "15", "Body": "<p>C++17 allows static member variables to be defined thus:</p>\n<pre><code>class X {\n  public:\n    static inline int i = 8;\n};\n</code></pre>\n<p>What is the rationale behind requiring the <code>inline</code> specification? Why not simply allow programmers to write</p>\n<pre><code>    static int i = 8;\n</code></pre>\n<p>in the class?</p>\n", "Tags": "<c++><inline><c++1z>", "OwnerUserId": "919705", "AnswerCount": "1"}, "46874207": {"ParentId": "46874055", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Without <code>inline</code>, it's explicitly stated as only a declaration. As specified in <a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.static.data#2\" rel=\"noreferrer\">[class.static.data]/2</a></p>\n<blockquote>\n<p id=\"so_46874055_46874207_0\"><strong>The declaration of a non-inline static data member in its class\n  definition is not a definition</strong> and may be of an incomplete type other\n  than cv void. The definition for a static data member that is not\n  defined inline in the class definition shall appear in a namespace\n  scope enclosing the member's class definition.</p>\n</blockquote>\n<p>The rationale is most probably to keep legacy code intact and valid. Recall that we could initialize integral constants in the class definition itself since about forever. But odr-using them still required an out-of-class definition in some translation unit.</p>\n<p>So to makes such variables implicitly inline could be problematic in existing codebases. The committee is always thinking about backwards compatibility when core language features are added.</p>\n<p>For instance, consider this valid C++03 class definition:</p>\n<pre><code>struct foo {\n    static const int n = 3;\n    double bar[n];\n};\n</code></pre>\n<p><code>n</code> can be used as a constant expression to define the extent of <code>bar</code>, and it's not considered an odr-use. Nowadays we'd write it as <code>constexpr</code><sup>1</sup>, however that above is still valid. But there <em>may</em> be cases were <code>n</code> would have to be odr-used (imagine its address taken, or a reference bound to it, etc). They are probably not many, and probably not common, but certain API's have crazy requirements that would end up necessitating this</p>\n<pre><code>const int foo::n;\n</code></pre>\n<p>to appear in some translation unit.</p>\n<p>Now, if <code>static inline int i = 8;</code> was suddenly implicitly <code>inline</code>, the definition above (that is in an existing code base) would be an odr-violation. Now previously well-formed code, is ill-formed. So it's best to allow only <em>explicit</em> <code>inline</code> to take effect here, since only new code will actually have it.</p>\n<hr>\n<p><sub>\n<sup>1</sup> One could argue that <code>static constexpr</code> variables may have the same issue (and yet they are implicitly inline). But IIRC their original wording allowed this change without potentially breaking existing code. It was essentially already \"inline\" by everything but name. \n</sub></p>\n</hr>", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-10-22T13:19:02.807", "Id": "46874207", "Score": "12", "CreationDate": "2017-10-22T12:42:43.460", "LastActivityDate": "2017-10-22T13:19:02.807"}, "bq_ids": {"n4140": {"so_46874055_46874207_0": {"section_id": 5907, "quality": 0.78125, "length": 25}}, "n3337": {"so_46874055_46874207_0": {"section_id": 5679, "quality": 0.78125, "length": 25}}, "n4659": {"so_46874055_46874207_0": {"section_id": 7389, "quality": 0.90625, "length": 29}}}});