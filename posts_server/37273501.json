post_cb({"37273979": {"ParentId": "37273501", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You can make a new method to make the object \"commit suicide\" and keep the destructor empty, so something like this will do the job you would like to do:</p>\n<pre><code>Class1::~Class1()\n{\n    myClass2-&gt;status = FINISHED;\n    myClass2-&gt;DeleteMe();\n}\n\nvoid Class2::DeleteMe()\n{\n   if (status == FINISHED)\n   {\n      delete this;\n   }\n }\n\n Class2::~Class2()\n {\n }\n</code></pre>\n", "OwnerUserId": "3771299", "LastEditorUserId": "3771299", "LastEditDate": "2016-05-17T11:06:37.833", "Id": "37273979", "Score": "1", "CreationDate": "2016-05-17T10:48:51.610", "LastActivityDate": "2016-05-17T11:06:37.833"}, "37274145": {"ParentId": "37273501", "CommentCount": "0", "Body": "<p>Of course not. Explicit call of 'return' ist 100% equivalent to implicit returning after execution of the destructor.</p>\n", "OwnerUserId": "6270435", "PostTypeId": "2", "Id": "37274145", "Score": "1", "CreationDate": "2016-05-17T10:56:41.180", "LastActivityDate": "2016-05-17T10:56:41.180"}, "37273622": {"ParentId": "37273501", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>No, you can't prevent the object from being destroyed by return statement, it just means the execution of the dtor's body will end at that point. After that it still will be destroyed (including its members and bases), and the memory still will be deallocated.</p>\n<p>You migth throw exception.</p>\n<pre><code>Class2::~Class2() noexcept(false) {\n    if (status != FINISHED) throw some_exception();\n}\n\nClass1::~Class1() {\n    myClass2-&gt;status = FINISHED;\n    try {\n        delete myClass2;\n    } catch (some_exception&amp; e) {\n        // what should we do now?\n    }\n}\n</code></pre>\n<p>Note it's a <em>terrible</em> idea indeed. You'd better to reconsider the design, I'm sure there must be a better one.</p>\n<p><strong>EDIT</strong></p>\n<p>I made a mistake, throwing exception won't stop the destruction of its bases and members, just make it possible to get the process result of <code>Class2</code>'s dtor. And what could be done with it is still not clear.</p>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2016-05-18T01:50:32.183", "Id": "37273622", "Score": "45", "CreationDate": "2016-05-17T10:32:33.700", "LastActivityDate": "2016-05-18T01:50:32.183"}, "37273501": {"CommentCount": "8", "AcceptedAnswerId": "37273622", "PostTypeId": "1", "LastEditorUserId": "3747990", "CreationDate": "2016-05-17T10:26:36.637", "LastActivityDate": "2016-05-18T15:13:56.337", "LastEditDate": "2016-05-17T11:06:14.797", "ViewCount": "6015", "FavoriteCount": "7", "Title": "C++ destructor with return", "Id": "37273501", "Score": "39", "Body": "<p>In C++ if we define a class destructor as:</p>\n<pre><code>~Foo(){\n   return;\n}\n</code></pre>\n<p>upon calling this destructor will the object of <code>Foo</code> be destroyed or does\nexplicitly returning from the destructor mean that we don't ever want to destroy it.</p>\n<p>I want to make it so that a certain object is destroyed only through another objects destructor i.e. only when the other object is ready to be destroyed.</p>\n<p>Example:</p>\n<pre><code>class Class1{\n...\nClass2* myClass2;\n...\n};\n\nClass1::~Class1(){\n    myClass2-&gt;status = FINISHED;\n    delete myClass2;\n}\n\nClass2::~Class2(){\n    if (status != FINISHED) return;\n}\n</code></pre>\n<p>I searched online and couldn't seem to find an answer to my question.\nI've also tried figuring it out myself by going through some code step by step with a debugger but can't get a conclusive result.</p>\n", "Tags": "<c++><c++11><return><c++14><destructor>", "OwnerUserId": "6345066", "AnswerCount": "11"}, "37273616": {"ParentId": "37273501", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_37273501_37273616_0\">does explicitly returning from the destructor mean that we don't ever want to destroy it.</p>\n</blockquote>\n<p>No. </p>\n<p>The destructor is a function so you can use the <code>return</code> keyword inside of it but that won't prevent the destruction of the object, once you are inside the destructor you are already destroying your object so any logic that wants to prevent that will have to occur before.</p>\n<p>For some reason i intuitively think your design problem can be solved with a <code>shared_ptr</code> and maybe a custom deleter, but that would require more info on the said problem.</p>\n", "OwnerUserId": "1147772", "PostTypeId": "2", "Id": "37273616", "Score": "7", "CreationDate": "2016-05-17T10:32:14.287", "LastActivityDate": "2016-05-17T10:32:14.287"}, "37274111": {"ParentId": "37273501", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_37273501_37274111_0\">[D]oes explicitly returning from the destructor mean that we don't ever want to destroy it?</p>\n</blockquote>\n<p>No. An early return (via <code>return;</code> or <code>throw ...</code>) only means the rest of the body of the destructor is not executed. The base and members are still destroyed and their destructors still run, see <a href=\"http://eel.is/c++draft/except#except.ctor-3\">[except.ctor]/3</a>.</p>\n<blockquote>\n<p id=\"so_37273501_37274111_1\">For an object of class type of any storage duration whose initialization or destruction is terminated by an exception, the destructor is invoked for each of the object's fully constructed subobjects...</p>\n</blockquote>\n<p>See below for code samples of this behaviour.</p>\n<hr>\n<blockquote>\n<p id=\"so_37273501_37274111_2\">I want to make it so that a certain object is destroyed only through another objects destructor i.e. only when the other object is ready to be destroyed.</p>\n</blockquote>\n<p>It sounds like the question is rooted in the issue of ownership. Deleting the \"owned\" object only once the parent is destroyed in a very common idiom and achieved with one of (but not limited to);</p>\n<ul>\n<li>Composition, it is an automatic member variable (i.e. \"stack based\")</li>\n<li>A <code>std::unique_ptr&lt;&gt;</code> to express exclusive ownership of the dynamic object</li>\n<li>A <code>std::shared_ptr&lt;&gt;</code> to express shared ownership of a dynamic object</li>\n</ul>\n<p>Given the code example in the OP, the <code>std::unique_ptr&lt;&gt;</code> may be a suitable alternative;</p>\n<pre><code>class Class1 {\n  // ...\n  std::unique_ptr&lt;Class2&gt; myClass2;\n  // ...\n};\n\nClass1::~Class1() {\n    myClass2-&gt;status = FINISHED;\n    // do not delete, the deleter will run automatically\n    // delete myClass2;\n}\n\nClass2::~Class2() {\n    //if (status != FINISHED)\n    //  return;\n    // We are finished, we are being deleted.\n}\n</code></pre>\n<p>I note the <code>if</code> condition check in the example code. It hints at the state being tied to the ownership and lifetime. They are not all the same thing; sure, you can tie the object reaching a certain state to it's \"logical\" lifetime (i.e. run some cleanup code), but I would avoid the direct link to the ownership of the object. It may be a better idea to reconsider some of the semantics involved here, or allow the \"natural\" construction and destruction to dictate the object begin and end states.</p>\n<p><em>Side note</em>; if you have to check for some state in the destructor (or assert some end condition), one alternative to the <code>throw</code> is to call <code>std::terminate</code> (with some logging) if that condition is not met. This approach is similar to the standard behavior and result when an exception is thrown when unwinding the stack as a result of an already thrown exception. This is also the standard behavior when a <code>std::thread</code> exits with an unhandled exception.</p>\n<hr>\n<blockquote>\n<p id=\"so_37273501_37274111_3\">[D]oes explicitly returning from the destructor mean that we don't ever want to destroy it?</p>\n</blockquote>\n<p>No (see above). The following code demonstrates this behaviour; <a href=\"http://coliru.stacked-crooked.com/a/95dff1f726b09c4a\">linked here</a> and a <a href=\"http://coliru.stacked-crooked.com/a/77bd57c054bc4c88\">dynamic version</a>. <em>The <code>noexcept(false)</code> is needed to avoid <code>std::terminate()</code> being called</em>.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nstruct NoisyBase {\n    NoisyBase() { cout &lt;&lt; __func__ &lt;&lt; endl; }\n    ~NoisyBase() { cout &lt;&lt; __func__ &lt;&lt; endl; }\n    NoisyBase(NoisyBase const&amp;) { cout &lt;&lt; __func__ &lt;&lt; endl; }\n    NoisyBase&amp; operator=(NoisyBase const&amp;) { cout &lt;&lt; __func__ &lt;&lt; endl; return *this; }    \n};\nstruct NoisyMember {\n    NoisyMember() { cout &lt;&lt; __func__ &lt;&lt; endl; }\n    ~NoisyMember() { cout &lt;&lt; __func__ &lt;&lt; endl; }\n    NoisyMember(NoisyMember const&amp;) { cout &lt;&lt; __func__ &lt;&lt; endl; }\n    NoisyMember&amp; operator=(NoisyMember const&amp;) { cout &lt;&lt; __func__ &lt;&lt; endl; return *this; }    \n};\nstruct Thrower : NoisyBase {\n    Thrower() { cout &lt;&lt; __func__ &lt;&lt; std::endl; }\n    ~Thrower () noexcept(false) {\n        cout &lt;&lt; \"before throw\" &lt;&lt; endl;\n        throw 42;\n        cout &lt;&lt; \"after throw\" &lt;&lt; endl;\n    }\n    NoisyMember m_;\n};\nstruct Returner : NoisyBase {\n    Returner() { cout &lt;&lt; __func__ &lt;&lt; std::endl; }\n    ~Returner () noexcept(false) {\n        cout &lt;&lt; \"before return\" &lt;&lt; endl;\n        return;\n        cout &lt;&lt; \"after return\" &lt;&lt; endl;\n    }\n    NoisyMember m_;\n};\nint main()\n{\n    try {\n        Thrower t;\n    }\n    catch (int&amp; e) {\n        cout &lt;&lt; \"catch... \" &lt;&lt; e &lt;&lt; endl;\n    }\n    {\n        Returner r;\n    }\n}\n</code></pre>\n<p>Has the following output;</p>\n<pre><code>NoisyBase\nNoisyMember\nThrower\nbefore throw\n~NoisyMember\n~NoisyBase\ncatch... 42\nNoisyBase\nNoisyMember\nReturner\nbefore return\n~NoisyMember\n~NoisyBase\n</code></pre>\n</hr></hr>", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2016-05-18T09:52:56.793", "Id": "37274111", "Score": "17", "CreationDate": "2016-05-17T10:55:24.977", "LastActivityDate": "2016-05-18T09:52:56.793"}, "bq_ids": {"n4140": {"so_37273501_37273812_0": {"section_id": 404, "quality": 0.9540229885057471, "length": 83}, "so_37273501_37274111_1": {"section_id": 3344, "quality": 0.6111111111111112, "length": 11}}, "n3337": {"so_37273501_37273812_0": {"section_id": 395, "quality": 0.9540229885057471, "length": 83}, "so_37273501_37274111_1": {"section_id": 3214, "quality": 0.6111111111111112, "length": 11}}, "n4659": {"so_37273501_37273812_0": {"section_id": 422, "quality": 0.9540229885057471, "length": 83}}}, "37303716": {"ParentId": "37273501", "CommentCount": "3", "Body": "<p>For this case you could use a class-specific overload of the delete operator.\nSo for you Class2 you could something like this</p>\n<pre><code>class Class2\n{\n    static void operator delete(void* ptr, std::size_t sz)\n    {\n        std::cout &lt;&lt; \"custom delete for size \" &lt;&lt; sz &lt;&lt; '\\n';\n        if(finished)\n            ::operator delete(ptr);\n    }\n\n    bool Finished;\n}\n</code></pre>\n<p>Then if you set the finished to true before the delete, the actual deletion will be called.\nNote that i haven't tested it, i just modified the code that i've found here\n<a href=\"http://en.cppreference.com/w/cpp/memory/new/operator_delete\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/memory/new/operator_delete</a></p>\n<pre><code>Class1::~Class1()\n{\n    class2-&gt;Finished = true;\n    delete class2;\n}\n</code></pre>\n", "OwnerUserId": "2212484", "PostTypeId": "2", "Id": "37303716", "Score": "0", "CreationDate": "2016-05-18T15:13:56.337", "LastActivityDate": "2016-05-18T15:13:56.337"}, "37273733": {"ParentId": "37273501", "CommentCount": "1", "Body": "<p>All stack-based objects inside will get destructed, no matter how soon you <code>return</code> from the destructor. If you miss to <code>delete</code> dynamically allocated objects, then there would be <em>intentional</em> memory leak. </p>\n<p>This is the whole idea how <em>move-constructors</em> would work. The move CTOR would simply take original object's memory. The destructor of original object simply wont/cant call <code>delete</code>.</p>\n", "OwnerUserId": "264325", "PostTypeId": "2", "Id": "37273733", "Score": "1", "CreationDate": "2016-05-17T10:37:45.847", "LastActivityDate": "2016-05-17T10:37:45.847"}, "37300751": {"ParentId": "37273501", "CommentCount": "0", "Body": "\n<p>So, as all the others pointed out, <code>return</code> is not a solution. </p>\n<p>The first thing I would add is that you shouldn't usually worry about this. Unless your professor explicitly asked. \nIt would be very odd if you could't trust the external class to only delete your class at the right time, and I figure no one else is seeing it. \nIf the pointer is passed around, the pointer would very probably be <code>shared_ptr</code>/<code>weak_ptr</code>, and let it destroy your class at the right moment.  </p>\n<p>But, hey, it's good to wonder how we would solve an odd problem if it ever arose, if we learn something (and don't waste time while on a deadline!)</p>\n<p>So what for a solution? If you can at least trust the destructor of Class1 not to destroy your object too early, then you can just declare the destructor of Class2 as private, and then declare the destructor of Class1 as friend of Class2, like this:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Class2;\n\nclass Class1 {\n\n    Class2* myClass2;\n\npublic:\n    ~Class1();\n};\n\nclass Class2 {\nprivate:\n        ~Class2();\n\nfriend Class1::~Class1();\n};\n\nClass1::~Class1() {\n    delete myClass2;\n}\n\nClass2::~Class2() {\n}\n</code></pre>\n<p>As a bonus, you don't need the 'status' flag; which is good -if someone wanted this bad to screw with you, why wouldn't set the status flag to <code>FINISHED</code> anywhere else, and then call <code>delete</code>? </p>\n<p>This way, you have actual guarantee that the object can be destroyed nowhere else than in the destructor of Class1. </p>\n<p>Of course, the destructor of Class1 gets access to all private members of Class2. It might not matter -after all, Class2 is about to be destroyed anyway! But if it does, we can conjure even more convoluted ways to work around it; why not. For instance:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Class2;\n\nclass Class1 {\nprivate:\n    int status;\n\n    Class2* myClass2;\n\npublic:\n    ~Class1();\n};\n\nclass Class2Hidden {\nprivate:\n      //Class2 private members\nprotected:\n    ~Class2Hidden();\npublic:\n    //Class2 public members\n};\n\nclass Class2 : public Class2Hidden {\nprotected:\n        ~Class2();\n\nfriend Class1::~Class1();\n};\n\nClass1::~Class1() {\n    delete myClass2;\n}\n\nClass2Hidden::~Class2Hidden() {\n}\n\nClass2::~Class2() {\n}\n</code></pre>\n<p>This way the public members will still be available in the derived class, but the private members will actually be private. ~Class1 will only get access to the private and protected members of Class2, and the protected members of Class2Hidden; which in this case is only the destructors. \nIf you need to keep a protected member of Class2 protected from the destructor of Class1... there are ways, but it really depends on what you are doing.</p>\n<p>Good luck!</p>\n", "OwnerUserId": "5160450", "PostTypeId": "2", "Id": "37300751", "Score": "1", "CreationDate": "2016-05-18T13:14:34.163", "LastActivityDate": "2016-05-18T13:14:34.163"}, "37273863": {"ParentId": "37273501", "CommentCount": "1", "Body": "<pre><code>~Foo(){\n   return;\n}\n</code></pre>\n<p>means exactly the same as:</p>\n<pre><code>~Foo() {}\n</code></pre>\n<p>It is similar to a <code>void</code> function; reaching the end without a <code>return;</code> statement is the same as having <code>return;</code> at the end.</p>\n<p>The destructor contains actions that are performed when the process of destroying a <code>Foo</code> has already begun.  It's not possible to abort a destruction process without aborting the entire program.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "37273863", "Score": "24", "CreationDate": "2016-05-17T10:43:36.673", "LastActivityDate": "2016-05-17T10:43:36.673"}, "37273843": {"ParentId": "37273501", "CommentCount": "0", "Body": "<p>No. <code>return</code> just means exit the method, it doesn't stop the destruction of the object. </p>\n<p>Also, why would you want to? If the object is allocated on the stack and you somehow managed to stop destruction then the object would live on a reclaimed part of the stack that will probably be overwritten by the next function call, which may write all over your objects memory and create undefined behavior.</p>\n<p>Likewise, if the object is allocated on the heap and you managed to prevent destruction you'd have a memory leak as the code calling <code>delete</code> would assume that it didn't need to hold on to a pointer to the object whilst it's actually still there and taking up memory that nobody is referencing.</p>\n", "OwnerUserId": "26095", "PostTypeId": "2", "Id": "37273843", "Score": "1", "CreationDate": "2016-05-17T10:42:31.013", "LastActivityDate": "2016-05-17T10:42:31.013"}, "37273812": {"ParentId": "37273501", "CommentCount": "0", "Body": "<p>According to the C++ Standard (12.4 Destructors)</p>\n<blockquote>\n<p id=\"so_37273501_37273812_0\">8 After executing the body of the destructor and destroying any\n  automatic objects allocated within the body, a destructor for class X\n  calls the destructors for X\u2019s direct non-variant non-static data\n  members, the destructors for X\u2019s direct base classes and, if X is the\n  type of the most derived class (12.6.2), its destructor calls the\n  destructors for X\u2019s virtual base classes. All destructors are called\n  as if they were referenced with a qualified name, that is, ignoring\n  any possible virtual overriding destructors in more derived classes.\n  Bases and members are destroyed in the reverse order of the completion\n  of their constructor (see 12.6.2). <strong>A return statement (6.6.3) in a\n  destructor might not directly return to the caller; before\n  transferring control to the caller, the destructors for the members\n  and bases are called. Destructors for elements of an array are called\n  in reverse order of their construction</strong> (see 12.6).</p>\n</blockquote>\n<p>So a returning statement does not prevent the object for which the destructor is called to be destroyed.</p>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "37273812", "Score": "8", "CreationDate": "2016-05-17T10:41:06.900", "LastActivityDate": "2016-05-17T10:41:06.900"}});