post_cb({"3824213": {"CommentCount": "0", "AcceptedAnswerId": "3824241", "PostTypeId": "1", "LastEditorUserId": "388056", "CreationDate": "2010-09-29T17:23:17.480", "LastActivityDate": "2010-09-29T20:06:45.100", "LastEditDate": "2010-09-29T17:50:32.420", "ViewCount": "2265", "FavoriteCount": "4", "Title": "does order of members of objects of a class have any impact on performance?", "Id": "3824213", "Score": "13", "Body": "<p>May order of members in binary architecture of objects of a class somehow have an impact on performance of applications which use that class? and I'm wondering about how to decide order of members of PODs in case the answer is yes since programmer defines order of members via order of their declaraions </p>\n", "Tags": "<c++><performance><class><object><binary>", "OwnerUserId": "388056", "AnswerCount": "3"}, "3824752": {"ParentId": "3824213", "CommentCount": "0", "Body": "<p>Absolutely agree with Potatoswatter. However one more point should be added about the CPU cache lines.</p>\n<p>If your application is multithreaded and different threads read/write members of your structure - it's very important to make sure those members are <strong>not</strong> within the same cache line.</p>\n<p>The point is that whenever a thread modifies a memory address that is cached in other CPU - that CPU immediately invalidates the cache line containing that address. So that improper members order may lead to the unjustified cache invalidation and performance degradation.</p>\n", "OwnerUserId": "1560850", "PostTypeId": "2", "Id": "3824752", "Score": "4", "CreationDate": "2010-09-29T18:34:01.710", "LastActivityDate": "2010-09-29T18:34:01.710"}, "3825425": {"ParentId": "3824213", "CommentCount": "0", "Body": "<p>In addition to the <strong>runtime performance</strong>, described in the cache-line related answers, I think one should also consider <strong>memory performance</strong>, i.e. the size of the class object.</p>\n<p>Due to the <a href=\"http://en.wikipedia.org/wiki/Data_structure_alignment#Data_structure_padding\" rel=\"nofollow\">padding</a>, the size of the class object is dependent on the order of member variable declaration.</p>\n<p>The following declaration would probably take 12 bytes</p>\n<pre><code>class foo {\n    char c1;\n    int  i;\n    char c2;\n}\n</code></pre>\n<p>However, upon simple re-ordering of the order of member declaration, the following would probably take 8 bytes</p>\n<pre><code>class bar {\n    int  i;\n    char c1;\n    char c2;\n}\n</code></pre>\n<p>In machines aligned with 4-byte words:</p>\n<pre><code>sizeof( foo ) = 12\n</code></pre>\n<p>but</p>\n<pre><code>sizeof( bar ) = 8\n</code></pre>\n", "OwnerUserId": "278326", "PostTypeId": "2", "Id": "3825425", "Score": "3", "CreationDate": "2010-09-29T20:06:45.100", "LastActivityDate": "2010-09-29T20:06:45.100"}, "bq_ids": {"n4140": {"so_3824213_3824241_0": {"section_id": 5873, "quality": 0.8235294117647058, "length": 42}}, "n3337": {"so_3824213_3824241_0": {"section_id": 5644, "quality": 0.8235294117647058, "length": 42}}, "n4659": {"so_3824213_3824241_0": {"section_id": 7356, "quality": 0.8235294117647058, "length": 42}}}, "3824241": {"ParentId": "3824213", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Absolutely. C++ guarantees that the order of objects in memory is the same as the order of declaration, unless an access qualifier intervenes.</p>\n<p>Objects which are directly adjacent are more likely to be on the same cacheline, so one memory access will fetch them both (or flush both from the cache). Cache effectiveness may also be improved as the proportion of useful data inside it may be higher. Simply put, spatial locality in your code translates to spatial locality for performance.</p>\n<p>Also, as Jerry notes in the comments, order may affect the amount of padding. Sort the members by decreasing size, which is also by decreasing alignment (usually treat an array as just one element of its type, and a member struct as its most-aligned member). Unnecessary padding may increase the total size of the structure, leading to higher memory traffic.</p>\n<p>C++03 \u00a79/12:</p>\n<blockquote>\n<p id=\"so_3824213_3824241_0\">Nonstatic data members of a\n  (non-union) class declared without an\n  intervening access-specifier are allocated so that later members have\n  higher addresses within a class\n  object. The order of allocation of\n  nonstatic data members separated by an\n  access-specifier is unspecified\n  (11.1). Implementation alignment\n  requirements might cause two\n  adjacent members not to be allocated\n  immediately after each other; so might\n  requirements for space for managing\n  virtual functions (10.3) and virtual\n  base classes (10.1).</p>\n</blockquote>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2010-09-29T18:15:35.687", "Id": "3824241", "Score": "27", "CreationDate": "2010-09-29T17:25:09.017", "LastActivityDate": "2010-09-29T18:15:35.687"}});