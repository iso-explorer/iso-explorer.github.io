post_cb({"34811578": {"ParentId": "34811486", "CommentCount": "0", "Body": "<p>from \u00a7 7.2, p 165</p>\n<blockquote>\n<p id=\"so_34811486_34811578_0\">. If the first enumerator has no initializer, the value of the corresponding constant is zero</p>\n</blockquote>\n<p>source: <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf</a></p>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "34811578", "Score": "2", "CreationDate": "2016-01-15T12:54:56.297", "LastActivityDate": "2016-01-15T12:54:56.297"}, "34811486": {"CommentCount": "4", "AcceptedAnswerId": "34811571", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-01-15T12:50:38.053", "LastActivityDate": "2016-11-24T19:33:32.670", "LastEditDate": "2017-05-23T10:31:22.967", "ViewCount": "10248", "FavoriteCount": "3", "Title": "Do C++ enums Start at 0?", "Id": "34811486", "Score": "12", "Body": "<p>If I have an <code>enum</code> that does not assign numbers to the enumerations, will it's ordinal value be 0? For example:</p>\n<pre><code>enum enumeration { ZERO,\n                   ONE,\n                   TWO,\n                   THREE,\n                   FOUR,\n                   FIVE,\n                   SIX,\n                   SEVEN,\n                   EIGHT,\n                   NINE };\n</code></pre>\n<p>I've been able to find a <a href=\"https://stackoverflow.com/a/30312219/2642059\">post citing that the C99 standard requires a 0 ordinal number</a>. But I know C++ ignores several things in the C99 standard. And I've also been able to find a <a href=\"https://stackoverflow.com/a/404253/2642059\">post witnessing the compiler using an ordinal value of 1</a>, something I also seem recall seeing, though I can't say how long ago that was.</p>\n<p>I would really like to see an answer that confirms this for C++, but I'd also like to know if an ordinal 0 holds <em>even if</em> I specify a value in the middle of an <code>enum</code>:</p>\n<pre><code>enum enumeration { ZERO,\n                   ONE,\n                   TWO,\n                   THREE = 13,\n                   FOUR,\n                   FIVE,\n                   SIX,\n                   SEVEN,\n                   EIGHT,\n                   NINE };\n</code></pre>\n", "Tags": "<c++><enums><language-lawyer><enumeration><ordinal>", "OwnerUserId": "2642059", "AnswerCount": "3"}, "34811588": {"ParentId": "34811486", "CommentCount": "0", "Body": "<p>From the C++11 specification (7.2/2):</p>\n<blockquote>\n<p id=\"so_34811486_34811588_0\">If the first <em>enumerator</em> has no <em>initializer</em>, the value of the corresponding constant is zero. An <em>enumerator-definition</em> without an <em>initializer</em> gives the <em>enumerator</em> the value obtained by increasing the value of the previous <em>enumerator</em> by one.</p>\n</blockquote>\n<p>So yes, the first identifier in the enumeration will have the value zero (if it's not explicitly initialized to another value), and each consecutive identifier will have the value of the previous plus one.</p>\n", "OwnerUserId": "440558", "PostTypeId": "2", "Id": "34811588", "Score": "12", "CreationDate": "2016-01-15T12:55:30.537", "LastActivityDate": "2016-01-15T12:55:30.537"}, "bq_ids": {"n4140": {"so_34811486_34811578_0": {"section_id": 5461, "quality": 1.0, "length": 7}, "so_34811486_34811588_0": {"section_id": 5461, "quality": 1.0, "length": 18}, "so_34811486_34811571_0": {"section_id": 5461, "quality": 0.8953488372093024, "length": 77}}, "n3337": {"so_34811486_34811578_0": {"section_id": 5248, "quality": 1.0, "length": 7}, "so_34811486_34811588_0": {"section_id": 5248, "quality": 1.0, "length": 18}, "so_34811486_34811571_0": {"section_id": 5248, "quality": 0.8953488372093024, "length": 77}}, "n4659": {"so_34811486_34811578_0": {"section_id": 6895, "quality": 1.0, "length": 7}, "so_34811486_34811588_0": {"section_id": 6895, "quality": 1.0, "length": 18}, "so_34811486_34811571_0": {"section_id": 6895, "quality": 0.872093023255814, "length": 75}}}, "34811571": {"ParentId": "34811486", "CommentCount": "0", "Body": "<p>Per that standard [dcl.enum]</p>\n<blockquote>\n<p id=\"so_34811486_34811571_0\">The enumeration type declared with an enum-key of only enum is an unscoped enumeration, and its enumerators are unscoped enumerators. The enum-keys enum class and enum struct are semantically equivalent; an enumeration type declared with one of these is a scoped enumeration, and its enumerators are scoped\n  enumerators. The optional identifier shall not be omitted in the declaration of a scoped enumeration. The type-specifier-seq of an enum-base shall name an integral type; any cv-qualification is ignored. An opaqueenum-declaration declaring an unscoped enumeration shall not omit the enum-base. The identifiers in an enumerator-list are declared as constants, and can appear wherever constants are required. An enumeratordefinition with = gives the associated enumerator the value indicated by the constant-expression. <strong>If the first\n  enumerator has no initializer, the value of the corresponding constant is zero.</strong> An enumerator-definition without an initializer gives the enumerator the value obtained by increasing the value of the previous enumerator by one.</p>\n</blockquote>\n<p><sup>Emphasis mine</sup></p>\n<p>So yes if you do not specify a start value it will default to 0.</p>\n<blockquote>\n<p id=\"so_34811486_34811571_1\">I would really like to see an answer that confirms this for C++, but I'd also like to know if an ordinal 0 holds even if I specify a value in the middle of an enum:</p>\n</blockquote>\n<p>This also works.  It will start at 0 and increment up along the way.  Then after the enum you assign the value to it will begin to increase from that value for the next ones.</p>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "34811571", "Score": "16", "CreationDate": "2016-01-15T12:54:39.960", "LastActivityDate": "2016-01-15T12:54:39.960"}});