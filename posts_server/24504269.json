post_cb({"bq_ids": {"n4140": {"so_24504269_24505925_0": {"length": 9, "quality": 0.75, "section_id": 1868}}, "n3337": {"so_24504269_24505925_0": {"length": 9, "quality": 0.75, "section_id": 1862}}, "n4659": {"so_24504269_24505925_0": {"length": 9, "quality": 0.75, "section_id": 2040}}}, "24504269": {"ViewCount": "702", "Body": "<p>I'm using GCC 4.9.0 on Linux.  Here's my test program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n  size_t pos = 42;\n  cout &lt;&lt; \"result: \" &lt;&lt; stoi(argv[1], &amp;pos, atoi(argv[2])) &lt;&lt; '\\n';\n  cout &lt;&lt; \"consumed: \" &lt;&lt; pos &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Here's an expected result:</p>\n<pre><code>$ ./a.out 100 2\nresult: 4\nconsumed: 3\n</code></pre>\n<p>That is, it parsed \"100\" in base 2 as the number 4 and consumed all 3 characters.</p>\n<p>We can do similar up to base 36:</p>\n<pre><code> $ ./a.out 100 36\nresult: 1296\nconsumed: 3\n</code></pre>\n<p>But what about larger bases?</p>\n<pre><code>$ ./a.out 100 37\nresult: 0\nconsumed: 18446744073707449552\n</code></pre>\n<p>What's this?  The <code>pos</code> is supposed to be an index where it stopped parsing.  Here it's close to <code>std::string::npos</code> but not quite (off by a few million).  And if I compile without optimization then <code>pos</code> is <code>18446744073703251929</code> instead, so it looks like uninitialized garbage, despite that I did initialize it (to 42).  And indeed, valgrind complains:</p>\n<pre><code>Conditional jump or move depends on uninitialised value(s)\n  at 0x400F11: int __gnu_cxx::__stoa&lt;long, int, char, int&gt;(...) (in a.out)\n  by 0x400EC7: std::stoi(std::string const&amp;, unsigned long*, int) (in a.out)\n</code></pre>\n<p>So that's interesting.  Also, the documentation of <code>std::stoi</code> says it throws std::invalid_argument if no conversion could be performed.  Clearly in this case it didn't perform any conversion, and it returned garbage in <code>pos</code>, and there was no exception thrown.</p>\n<p>Similar bad things happen if <code>base</code> is 1 or negative.</p>\n<p>Is this a bug in the GCC implementation, a bug in the standard, or just something we have to learn to live with?  I thought one of the goals of <code>stoi()</code> vs <code>atoi()</code> was better error detection, but it seems not to check <code>base</code> at all.</p>\n<hr>\n<p>Edit: here's a C version of the same program which also prints errno:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char* argv[])\n{\n  char* pos = (char*)42;\n  printf(\"result: %ld\\n\", strtol(argv[1], &amp;pos, atoi(argv[2])));\n  printf(\"consumed: %lu (%p)\\n\", pos - argv[1], pos);\n  perror(\"errno\");\n  return 0;\n}\n</code></pre>\n<p>When it works, it does the same thing as before.  When it fails, it's a lot more clear:</p>\n<pre><code>$ ./a.out 100 37\nresult: 0\nconsumed: 18446603340345143502 (0x2a)\nerrno: Invalid argument\n</code></pre>\n<p>Now we see why <code>pos</code> in the C++ version was a \"garbage\" value: it was because <code>strtol()</code> left <code>endptr</code> unchanged, and the C++ wrapper erroneously subtracts the input string starting address from that.</p>\n<p>In the C version we also see that <code>errno</code> is set to <code>EINVAL</code> to indicate the error.  The documentation on my system says this will happen when <code>base</code> is invalid, but also says it's not specified by C99.  If we print <code>errno</code> in the C++ version we can also detect this error (but it's not standard in C99 and it sure isn't specified by C++11).</p>\n</hr>", "AcceptedAnswerId": "24505925", "Title": "C++11 std::stoi silently fails when base not in [2,36] (GCC)", "CreationDate": "2014-07-01T07:03:33.690", "Id": "24504269", "CommentCount": "11", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-07-01T08:33:55.543", "LastEditorUserId": "4323", "LastActivityDate": "2014-07-01T08:42:38.430", "Score": "12", "OwnerUserId": "4323", "Tags": "<c++><gcc><c++11><std>", "AnswerCount": "1"}, "24505925": {"Id": "24505925", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24504269_24505925_0\"><code>[C++11: 21.5/3]:</code> Throws: invalid_argument if <code>strtol</code>, <code>strtoul</code>, <code>strtoll</code>, or <code>strtoull</code> reports that no conversion could be performed. <em>[..]</em></p>\n<p id=\"so_24504269_24505925_1\"><code>[C99: 7.20.1.4/5]:</code>  If the subject sequence has the expected form and the value of <code>base</code> is zero, the sequence of characters starting with the \ufb01rst digit is interpreted as an integer constant according to the rules of 6.4.4.1. If the subject sequence has the expected form and the value of <code>base</code> is between 2 and 36, it is used as the base for conversion, ascribing to each letter its value as given above. <em>[..]</em></p>\n</blockquote>\n<p>No semantics are specified in C99 for the case when <code>base</code> is <em>not</em> zero or between 2 and 36, so the result is undefined. This does not necessarily satisfy the excerpt from <code>[C++11: 21.5/3]</code>.</p>\n<p>In short, this is UB; you'd expect an exception only when the base is valid but the input value is inconvertible in that base. <em>This is a bug in neither GCC nor the standard.</em></p>\n", "LastActivityDate": "2014-07-01T08:42:38.430", "CommentCount": "8", "CreationDate": "2014-07-01T08:42:38.430", "ParentId": "24504269", "Score": "5", "OwnerUserId": "560648"}});