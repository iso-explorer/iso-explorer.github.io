post_cb({"27496004": {"ViewCount": "1883", "Body": "<p>This is a follow-up of this question: <a href=\"https://stackoverflow.com/questions/16063123/is-it-legal-to-declare-a-constexpr-initializer-list-object\">Is it legal to declare a constexpr initializer_list object?</a>.</p>\n<p>Since C++14, the <code>std::initializer_list</code> class has all of its methods marked with <code>constexpr</code>. It seems natural to be able to initialize an instance by doing \n<code>constexpr std::initializer_list&lt;int&gt; list = {1, 2, 3};</code> \nbut Clang 3.5 complains about <code>list</code> not being initialized by a constant expression. \n<a href=\"https://stackoverflow.com/questions/16063123/is-it-legal-to-declare-a-constexpr-initializer-list-object#comment43416424_16067393\">As dyp pointed out in a comment</a>, any requirement for <code>std::initializer_list</code> to be a literal type seem to have vanished from the specs.</p>\n<p>What's the point of having a class fully defined as constexpr if we can't even initialize it as such? Is it an oversight in the standard and will get fixed in the future?</p>\n", "AcceptedAnswerId": "28115954", "Title": "Why isn't `std::initializer_list` defined as a literal type?", "CreationDate": "2014-12-16T01:16:41.550", "Id": "27496004", "CommentCount": "9", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:02:29.837", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-23T18:02:14.607", "Score": "53", "OwnerUserId": "1640404", "Tags": "<c++><language-lawyer><c++14><initializer-list><constexpr>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27496004_28115954_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 7208}, "so_27496004_28115954_1": {"length": 30, "quality": 0.8823529411764706, "section_id": 6955}}, "n3337": {"so_27496004_28115954_0": {"length": 30, "quality": 0.9090909090909091, "section_id": 6952}, "so_27496004_28115954_1": {"length": 30, "quality": 0.8823529411764706, "section_id": 6702}}, "n4659": {"so_27496004_28115954_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 8717}, "so_27496004_28115954_1": {"length": 30, "quality": 0.8823529411764706, "section_id": 8452}}}, "28115954": {"Id": "28115954", "PostTypeId": "2", "Body": "<p>The standard committee seems to intend on <code>initializer_list</code> being a literal type.  However, it doesn't look like it's an explicit requirement, and seems to be a bug in the standard.</p>\n<p>From \u00a7 3.9.10.5:</p>\n<blockquote>\n<p id=\"so_27496004_28115954_0\">A type is a <em>literal type</em> if it is:<br>\n  - a class type (Clause 9) that has all of the following properties:<br>\n  - - it has a trivial destructor,<br>\n  - - it is an aggregate type (8.5.1) or has at least one <em>constexpr</em> constructor or constructor template that is not a copy or move constructor, and<br>\n  - - all of its non-static data members and base classes are of non-volatile literal types.</br></br></br></br></p>\n</blockquote>\n<p>From \u00a7 18.9.1:</p>\n<pre><code>namespace std {\n  template&lt;class E&gt; class initializer_list {\n  public:\n    /* code removed */\n    constexpr initializer_list() noexcept;\n    // No destructor given, so trivial\n    /* code removed */\n  };\n}\n</code></pre>\n<p>This satisfies the first and second requirements.</p>\n<p>For the third requirement though: </p>\n<p>From \u00a7 18.9.2 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_27496004_28115954_1\">An object of type <code>initializer_list&lt;E&gt;</code> provides access to an array of objects of type <code>const E</code>. [Note: <strong>A pair of pointers or a pointer plus a length</strong> would be obvious representations for <code>initializer_list</code>. <code>initializer_list</code> is used to implement initializer lists as specified in 8.5.4. Copying an initializer list does not copy the underlying elements.<br>\n  \u2014end note]</br></p>\n</blockquote>\n<p>So there is no requirement for the private members of the implementation of <code>initializer_list</code> to be non-volatile literal types; however, because they mention that they believe a pair of pointers or a pointer and a length would be the \"obvious representation,\" they probably didn't consider that someone might put something non-literal in the members of <code>initializer_list</code>.</p>\n<p>I'd say that it's both a bug in clang and the standard, probably.</p>\n", "LastActivityDate": "2015-01-23T18:02:14.607", "CommentCount": "0", "CreationDate": "2015-01-23T18:02:14.607", "ParentId": "27496004", "Score": "5", "OwnerUserId": "483486"}});