post_cb({"bq_ids": {"n4140": {"so_9183087_9183087_0": {"length": 64, "quality": 0.8311688311688312, "section_id": 481}}, "n3337": {"so_9183087_9183087_0": {"length": 73, "quality": 0.948051948051948, "section_id": 472}}, "n4659": {"so_9183087_9183087_0": {"length": 60, "quality": 0.7792207792207793, "section_id": 504}}}, "9183087": {"ViewCount": "474", "Body": "<p>The C++11 standard states that, if the conditions for copy elision are met (<code>\u00a712.8/31</code>), the implementation shall treat a <code>return</code>ed local lvalue variable and function parameters, as an rvalue first (move), and if overload resolution doesn't succeed as detailed, shall then treat it as an lvalue (copy).</p>\n<p><code>\u00a712.8 [class.copy] p32</code></p>\n<blockquote>\n<p id=\"so_9183087_9183087_0\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, <strong>and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue</strong>. If overload resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue. [ <em>Note:</em> This two-stage overload resolution must be performed regardless of whether copy elision will occur. It determines the constructor to be called if elision is not performed, and the selected constructor must be accessible even if the call is elided. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Does this also include member subobjects? I tested with the following snippet:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct traced{\n  traced(){ std::cout &lt;&lt; \"default ctor\\n\"; }\n  traced(traced const&amp;){ std::cout &lt;&lt; \"copy ctor\\n\"; }\n  traced(traced&amp;&amp;){ std::cout &lt;&lt; \"move ctor\\n\"; }\n};\n\nstruct X{\n  traced t;\n};\n\ntraced f(){\n  X x;\n  return x.t;\n}\n\nint main(){\n  traced t = f();\n}\n</code></pre>\n<p><a href=\"http://ideone.com/x11Md\">Live example on Ideone.</a>\nAnd neither GCC 4.7 ToT nor Clang 3.1 ToT will display \"move ctor\", which leads me to believe that the standard doesn't include member subobjects.</p>\n<p>Did I overlook something? Is my test code broken? What exactly causes the output to be as it is?</p>\n", "AcceptedAnswerId": "9183213", "Title": "Will member subobjects of local variables be moved too if returned from a function?", "CreationDate": "2012-02-07T20:06:03.303", "Id": "9183087", "CommentCount": "3", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2012-02-07T21:38:19.587", "Score": "7", "OwnerUserId": "500104", "Tags": "<c++><c++11><local-variables><move-semantics>", "AnswerCount": "1"}, "9183213": {"Id": "9183213", "PostTypeId": "2", "Body": "<p>When returning a subobject you can't elide its construction. Think of it this way: move and copy elision essentially amount to constructing the object in the place it would eventually be moved or copied to. This works for complete objects because there will be the appropriate space be set aside. It doesn't work with subobjects because you would construct the enclosing object. Even if this has the same size as the subobject, i.e. there is enough space, the enclosing object gets destroyed and may do funny things to the subobjects.</p>\n<p>Effectively, this means that construction of the subject cannot be elided.</p>\n", "LastActivityDate": "2012-02-07T20:16:08.883", "CommentCount": "14", "CreationDate": "2012-02-07T20:16:08.883", "ParentId": "9183087", "Score": "6", "OwnerUserId": "1120273"}});