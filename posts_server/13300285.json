post_cb({"13300655": {"ParentId": "13300285", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From the C++ Standard (C++11, but it wasn't different in C++98/03):</p>\n<blockquote>\n<p id=\"so_13300285_13300655_0\">(\u00a7 3.3.2/1) The <em>point of declaration</em> for a name is immediately after its complete declarator (Clause 8) and before its <em>initializer</em> (if any), [...] [ Example:</p>\n<pre><code>int x = 12;\n{ int x = x; }\n</code></pre>\n<p id=\"so_13300285_13300655_1\">Here the second x is initialized with its own (indeterminate) value. \u2014end example ]</p>\n</blockquote>\n<p>This applies to user-defined types as well as array-types as well. Notice how the Standard emphasizes that <code>x</code> in the second example is initialised with an <em>indeterminate</em> value. So there is no way to know what value <code>x</code> is initialised with.</p>\n", "OwnerUserId": "777186", "LastEditorUserId": "560648", "LastEditDate": "2012-11-09T01:22:26.837", "Id": "13300655", "Score": "5", "CreationDate": "2012-11-09T01:07:06.360", "LastActivityDate": "2012-11-09T01:22:26.837"}, "13300353": {"ParentId": "13300285", "CommentCount": "6", "Body": "<p>It's legal, because the declaration of the variable is complete by the time you initialize it. However, the value of <code>test[1]</code> is undefined.</p>\n", "OwnerUserId": "265530", "PostTypeId": "2", "Id": "13300353", "Score": "0", "CreationDate": "2012-11-09T00:32:23.773", "LastActivityDate": "2012-11-09T00:32:23.773"}, "13300285": {"CommentCount": "9", "ViewCount": "179", "PostTypeId": "1", "LastEditorUserId": "2246380", "CreationDate": "2012-11-09T00:24:39.447", "LastActivityDate": "2016-05-13T18:48:59.100", "Title": "Is it legal to reference a variable in its definition?", "AcceptedAnswerId": "13300655", "LastEditDate": "2016-05-13T18:48:59.100", "Id": "13300285", "Score": "11", "Body": "<pre><code>int test[2] = { 45, test[0] };\nint x = (x = 111);\ncout &lt;&lt; test[0] &lt;&lt; \" \" &lt;&lt; test[1] &lt;&lt; \" \" &lt;&lt; x &lt;&lt; \"\\n\"; // 45 45 111\n</code></pre>\n<p>Are the assignments in the first two lines legal? Visual Studio 2010 compiles and runs it without any errors or warnings but it seems like an odd case that could possibly be undefined, so I wanted to confirm that it is acceptable. Visual Studio does warn me if I do something blatantly reflexive (and presumably undefined) like <code>int x = x;</code> so I'm wondering how these situations it seems to allow are handled.</p>\n", "Tags": "<c++><variables><initialization><standards><variable-assignment>", "OwnerUserId": "839932", "AnswerCount": "4"}, "13301480": {"ParentId": "13300285", "CommentCount": "0", "Body": "<p>I'll assume you're in some function since you're calling functions and such.</p>\n<p>The space for both <code>test</code> and <code>x</code> is allocated on the <b>stack</b>. In theory, the space for these guys should exist before their values are filled in. If we look at the generated assembly (x86 gcc), this is true.</p>\n<pre><code>subl    $40, %esp         # Add 40 bytes of memory to the current stack\nmovl    $0, -20(%ebp)     # Clear test[0] to 0\nmovl    $0, -16(%ebp)     # Clear test[1] to 0\nmovl    $45, -20(%ebp)    # Place the value of 45 into test[0]\nmovl    -20(%ebp), %eax  # Copy that 45 into a register\nmovl    %eax, -16(%ebp)  # Move that register's value (45) into test[1]\nmovl    $111, -12(%ebp)  # Assign x to be 111, optimize out the unnecessary duplicate assignment\n    ... #continues on to set up and call printf\n</code></pre>\n<p>We can see that 40 bytes are added to the stack. Notice how the addresses of test[0], test[1], and x are all contiguous addresses marked off from <code>%ebp</code> at 4 byte intervals (-20,-16,-12, respectively). <b>Their locations in memory exist and can be accessed without error before they are defined.</b> The compiler here clears them both to 0, although we can see that this is unnecessary. You can delete those two lines and still run fine.</p>\n<p><b>What we can draw from this</b> is that your <b>int test[2]</b> and <b>int x</b> could have any number of funky circular references within themselves and the code will compile - it's just your job to make sure your references grab good data (ie somehow initialized data) and not garbage, which you've done here. This also works with other cases - compile to assembly and check it out for yourself how it's done.</p>\n", "OwnerUserId": "1633305", "PostTypeId": "2", "Id": "13301480", "Score": "1", "CreationDate": "2012-11-09T02:57:24.560", "LastActivityDate": "2012-11-09T02:57:24.560"}, "13300356": {"ParentId": "13300285", "CommentCount": "3", "Body": "<p>All the code you have is perfectly legal.  There are even circumstances in which you might actually even <em>want</em> to do it, too.</p>\n", "OwnerUserId": "1324631", "PostTypeId": "2", "Id": "13300356", "Score": "0", "CreationDate": "2012-11-09T00:32:35.180", "LastActivityDate": "2012-11-09T00:32:35.180"}, "bq_ids": {"n4140": {"so_13300285_13300655_1": {"section_id": 7049, "quality": 0.7777777777777778, "length": 7}, "so_13300285_13300655_0": {"section_id": 7049, "quality": 0.7333333333333333, "length": 11}}, "n3337": {"so_13300285_13300655_1": {"section_id": 6794, "quality": 0.7777777777777778, "length": 7}, "so_13300285_13300655_0": {"section_id": 6794, "quality": 0.7333333333333333, "length": 11}}, "n4659": {"so_13300285_13300655_1": {"section_id": 8546, "quality": 0.7777777777777778, "length": 7}, "so_13300285_13300655_0": {"section_id": 8546, "quality": 0.7333333333333333, "length": 11}}}});