post_cb({"24054286": {"ParentId": "24053998", "CommentCount": "5", "Body": "<p>I don\u2019t really understand what you are trying to achieve, but I can help you with the error</p>\n<pre><code>template &lt;typename T, typename U&gt;\nstruct fail : dummy&lt;T&gt;, dummy&lt;U&gt; {};\n\ntemplate &lt;typename T&gt;\nstruct fail&lt;T, T&gt; : dummy&lt;T&gt; {};\n</code></pre>\n<p>The error is because when you instantiate <code>fail</code> with <code>T</code> and <code>U</code> the same you basically inherit from the same class twice, which is illegal, so you need to create a specialization to take care of this case.</p>\n", "OwnerUserId": "2805305", "PostTypeId": "2", "Id": "24054286", "Score": "0", "CreationDate": "2014-06-05T07:34:45.700", "LastActivityDate": "2014-06-05T07:34:45.700"}, "24054690": {"ParentId": "24053998", "PostTypeId": "2", "CommentCount": "3", "Body": "<h3>THE ERROR</h3>\n<blockquote>\n<p id=\"so_24053998_24054690_0\"><code>prog.cpp: In instantiation of \u2018struct fail&lt;int, int&gt;\u2019:\n  prog.cpp:23:29:   required from here\n  prog.cpp:9:8: error: duplicate base type \u2018dummy&lt;int&gt;\u2019 invalid\n   struct fail : dummy&lt;T&gt;, dummy&lt;U&gt; {};</code></p>\n</blockquote>\n<p>As stated in the above diagnostic you cannot explicitly inherit from the same <em>base</em> more than once in a  <em>base-specifier-list</em>, and since <code>T</code> and <code>U</code> can possibly be of the same type.. <em>BOOM</em>.</p>\n<hr>\n<h3>WAIT, HOLD UP; WHAT ABOUT <em>SFINAE</em>?</h3>\n<p><em>SFINAE</em> is only checked in the immediate context of the template itself, error that happens beyond the declaration are <strong>not</strong> suitable to trigger a <em>SFINAE</em>.</p>\n<blockquote>\n<p id=\"so_24053998_24054690_1\"><code>14.8.2p8</code> <strong>Template argument deduction</strong> <code>[temp.deduct]</code></p>\n<blockquote>\n<p id=\"so_24053998_24054690_4\">If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is one that would be ill-formed, with a diagnostic required, if written using the substituted arguemts.</p>\n<p id=\"so_24053998_24054690_5\">Only invalid types and expressions in the immediate context of the function type and its templat eparameter types can result in a deduction failure.</p>\n</blockquote>\n</blockquote>\n<p>The ill-formed inheritance does not happen in the immediate context, and the application is ill-formed.</p>\n<p>To answer your question explicitly: since inheritance <em>never</em> happens in the declaration of a certain function, the ill-formed inheritance itself cannot be caught by <em>SFINAE</em>.</p>\n<p>Sure, you can ask for the compiler to generate a class that uses <em>inheritance</em>, by instantiation it in the function declaration, but the actual (ill-formed) inheritance is not in the <em>immediate context</em>.</p>\n</hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2014-06-05T09:40:56.097", "Id": "24054690", "Score": "4", "CreationDate": "2014-06-05T07:57:33.680", "LastActivityDate": "2014-06-05T09:40:56.097"}, "24054401": {"ParentId": "24053998", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>What about a simple <code>std::is_same&lt;&gt;</code>? As far as I can see, it directly models the desired behaviour of your class.</p>\n<p>So try something like this:</p>\n<pre><code>template&lt;typename T, typename U&gt;\nfail\n{\n    fail(const T &amp;t, const U &amp;u)\n    {\n         static_assert(std::is_same&lt;T,U&gt;::value,\"T and U must have a distinct type\");\n    }\n};\n</code></pre>\n<p>Or even better, directly use <code>std::is_same&lt;T,U&gt;</code> in your code.</p>\n<p><strong>EDIT:</strong> Here is a solution inspired by Jarod42's but which uses only a single class (to make it clearer: this is an answer to the question <em>how to write a variadic class template which detects whether all given types are distinct</em>, which seemed to be the desired goal in one of the early versions of the original question):</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename ...Ts&gt; struct are_all_different {};\ntemplate &lt;&gt; struct are_all_different&lt;&gt; {static const bool value=true;};\ntemplate &lt;typename T&gt; struct are_all_different&lt;T&gt; {static const bool value=true;};\n\ntemplate &lt;typename T1, typename T2&gt;\nstruct are_all_different&lt;T1, T2&gt;\n{\n    static const bool value = !std::is_same&lt;T1, T2&gt;::value;\n};\n\ntemplate &lt;typename T1, typename T2, typename ...Ts&gt;\nstruct are_all_different&lt;T1,T2,Ts...&gt;\n{\n    static const bool value = are_all_different&lt;T1, T2&gt;::value\n                           &amp;&amp; are_all_different&lt;T1, Ts...&gt;::value\n                           &amp;&amp; are_all_different&lt;T2, Ts...&gt;::value;\n};\n\nstatic_assert(are_all_different&lt;char, int, float, long, short&gt;::value, \"type should be all different\");\nstatic_assert(!are_all_different&lt;char, int, float, char, short&gt;::value, \"type should not all different\");\n</code></pre>\n<p>In the end, for <code>n</code> variadic template arguments, this should check for equality of all of the <code>n*(n+1)/2</code> combinations.</p>\n", "OwnerUserId": "2412846", "LastEditorUserId": "2412846", "LastEditDate": "2014-06-18T08:27:39.507", "Id": "24054401", "Score": "1", "CreationDate": "2014-06-05T07:41:31.260", "LastActivityDate": "2014-06-18T08:27:39.507"}, "24054671": {"ParentId": "24053998", "CommentCount": "10", "Body": "<p>As I understand, you want a traits to check if all type are differents,<br>\nfollowing may help: </br></p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename T, typename ...Ts&gt; struct is_in;\n\ntemplate &lt;typename T&gt; struct is_in&lt;T&gt; : std::false_type {};\ntemplate &lt;typename T1, typename T2, typename ... Ts&gt;\nstruct is_in&lt;T1, T2, Ts...&gt; : std::conditional&lt;std::is_same&lt;T1, T2&gt;::value, std::true_type, is_in&lt;T1, Ts...&gt;&gt;::type {};\n\n\ntemplate &lt;typename ... Ts&gt; struct are_all_different;\n\ntemplate &lt;&gt; struct are_all_different&lt;&gt; : std::true_type {};\ntemplate &lt;typename T&gt; struct are_all_different&lt;T&gt; : std::true_type {};\n\ntemplate &lt;typename T1, typename T2, typename ... Ts&gt; struct are_all_different&lt;T1, T2, Ts...&gt; :\n    std::conditional&lt;is_in&lt;T1, T2, Ts...&gt;::value, std::false_type, are_all_different&lt;T2, Ts...&gt;&gt;::type {};\n\n\nstatic_assert(are_all_different&lt;char, int, float, long, short&gt;::value, \"type should be all different\");\nstatic_assert(!are_all_different&lt;char, int, float, char, short&gt;::value, \"type should not all different\");\n</code></pre>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "24054671", "Score": "1", "CreationDate": "2014-06-05T07:56:25.780", "LastActivityDate": "2014-06-05T07:56:25.780"}, "24056427": {"ParentId": "24053998", "CommentCount": "3", "Body": "<p>You can't catch duplicate inheritance with SFINAE, because it is not one of the listed reasons for deduction to fail under 14.8.2p8 <strong>[temp.deduct]</strong>; equally, it is because the error occurs outside the \"immediate context\" of template deduction, as it is an error with the <em>instantiation</em> of your <code>struct fail</code>.</p>\n<p>There is however a very similar technique which is suitable for use in your case, which is to detect an <em>ambiguous conversion</em> from a derived class to multiple base classes.  Clearly the ambiguous base classes can't be inherited directly from a single derived class, but it works fine to inherit them in a linear chain:</p>\n<pre><code>C&lt;&gt; A&lt;int&gt;\n|  /\nC&lt;int&gt; A&lt;char&gt;\n|     /\nC&lt;char, int&gt; A&lt;int&gt;\n|           /\nC&lt;int, char, int&gt;\n</code></pre>\n<p>Now a conversion from <code>C&lt;int, char, int&gt;</code> to <code>A&lt;int&gt;</code> will be ambiguous, and as ambiguous conversion <em>is</em> listed under 14.8.2p8 we can use SFINAE to detect it:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;class&gt; struct A {};\ntemplate&lt;class... Ts&gt; struct C;\ntemplate&lt;&gt; struct C&lt;&gt; {};\ntemplate&lt;class T, class... Ts&gt; struct C&lt;T, Ts...&gt;: A&lt;T&gt;, C&lt;Ts...&gt; {};\ntemplate&lt;class... Ts&gt; void f(A&lt;Ts&gt;...);\ntemplate&lt;class... Ts&gt; std::false_type g(...);\ntemplate&lt;class... Ts&gt; decltype(f((A&lt;Ts&gt;(), C&lt;Ts...&gt;())...), std::true_type()) g(int);\ntemplate&lt;class... Ts&gt; using distinct = decltype(g&lt;Ts...&gt;(0));\n\nstatic_assert(distinct&lt;int, char, float&gt;::value, \"!!\");\nstatic_assert(!distinct&lt;int, char, int&gt;::value, \"!!\");\n</code></pre>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "24056427", "Score": "6", "CreationDate": "2014-06-05T09:26:10.953", "LastActivityDate": "2014-06-05T09:26:10.953"}, "bq_ids": {"n4140": {"so_24053998_24054690_2": {"section_id": 300, "quality": 0.95, "length": 19}, "so_24053998_24054690_5": {"section_id": 300, "quality": 0.8125, "length": 13}, "so_24053998_24054690_3": {"section_id": 300, "quality": 0.8125, "length": 13}, "so_24053998_24054690_4": {"section_id": 300, "quality": 0.95, "length": 19}}, "n3337": {"so_24053998_24054690_2": {"section_id": 291, "quality": 0.85, "length": 17}, "so_24053998_24054690_5": {"section_id": 291, "quality": 0.8125, "length": 13}, "so_24053998_24054690_3": {"section_id": 291, "quality": 0.8125, "length": 13}, "so_24053998_24054690_4": {"section_id": 291, "quality": 0.85, "length": 17}}, "n4659": {"so_24053998_24054690_2": {"section_id": 307, "quality": 0.95, "length": 19}, "so_24053998_24054690_5": {"section_id": 307, "quality": 0.8125, "length": 13}, "so_24053998_24054690_3": {"section_id": 307, "quality": 0.8125, "length": 13}, "so_24053998_24054690_4": {"section_id": 307, "quality": 0.95, "length": 19}}}, "24053998": {"CommentCount": "2", "CreationDate": "2014-06-05T07:19:31.020", "PostTypeId": "1", "AcceptedAnswerId": "24056427", "LastEditorUserId": "1872046", "LastActivityDate": "2014-06-18T08:27:39.507", "LastEditDate": "2014-06-05T09:02:36.977", "ViewCount": "478", "FavoriteCount": "2", "Title": "Detect same class inheritance with SFINAE", "Id": "24053998", "Score": "4", "Body": "<p>I'm trying to write a metafunction that checks whether all types passed as a variadic template parameter are distinct. It seems that the most performant way to do this is to inherit from a set of classes and detect, whether there is an error.</p>\n<p>The problem is that compilation fails in the following code, while I would expect SFINAE to work.</p>\n<p><strong>Edit.</strong> The question is not \"how to write that metafunction\" but \"how do I catch that double inheritance error and output <code>false_type</code> when it happens\". AFAIK, it's possible only with SFINAE.</p>\n<hr>\n<pre><code>template &lt;typename T&gt;\nstruct dummy {};\n\n// error: duplicate base type \u2018dummy&lt;int&gt;\u2019 invalid\ntemplate &lt;typename T, typename U&gt;\nstruct fail : dummy&lt;T&gt;, dummy&lt;U&gt; {};\n\ntemplate &lt;typename T&gt;\ntrue_type test(fail&lt;T, T&gt; a = fail&lt;T, T&gt;());\n\nfalse_type test(...);\n\nint main() {\n    cout &lt;&lt; decltype(test&lt;int&gt;())::value &lt;&lt; endl;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/22S50k\" rel=\"nofollow\">Live version here</a>.</p>\n<hr>\n<p><strong>Edit.</strong> Previously I've tried to do this with specialization failure, but it didn't work either with the same compilation error.</p>\n<pre><code>template &lt;typename T&gt;\nstruct dummy {};\n\ntemplate &lt;typename T, typename U&gt;\nstruct fail : dummy&lt;T&gt;, dummy&lt;U&gt;, true_type {};\n\ntemplate &lt;typename T, typename U = void&gt;\nstruct test : false_type {};\n\ntemplate &lt;typename T&gt;\nstruct test&lt;T, typename enable_if&lt;fail&lt;T, T&gt;::value, void&gt;::type&gt; : true_type {};\n</code></pre>\n<p><a href=\"http://ideone.com/QN0SVE\" rel=\"nofollow\">Live version here.</a></p>\n</hr></hr>", "Tags": "<c++><c++11><template-meta-programming><sfinae><decltype>", "OwnerUserId": "1872046", "AnswerCount": "5"}});