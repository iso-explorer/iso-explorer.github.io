post_cb({"31586277": {"ViewCount": "173", "Body": "<p><strong>C++ Primer</strong> (5th edition) gives a number of examples of achieving nice effects by passing an <code>inserter</code> or a <code>move iterator</code> instead of a regular iterator into an <code>std</code>'s generic algorithm.</p>\n<p>I suspect, however, that being able to do this depends on inside knowledge of the workings of the algorithm, i.e. what precisely it does with its iterator arguments. This is even more severe with the <code>move inserter</code>, since we need to be sure that an object is not accessed after being moved from.</p>\n<p>Is my suspicion justified? If it is, then how come the standard library takes an approach that requires the client (me) to know the internals of the provider (STL)?</p>\n", "AcceptedAnswerId": "31591251", "Title": "Do I need to know the algorithm's code to take advantage of inserters and move iterators?", "CreationDate": "2015-07-23T11:39:32.397", "Id": "31586277", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-07-23T15:18:50.473", "Score": "4", "OwnerUserId": "2725810", "Tags": "<c++><c++11><stl>", "AnswerCount": "2"}, "31591251": {"Id": "31591251", "PostTypeId": "2", "Body": "<p>You seem to be confused about the style of specification of the algorithms in the standard library.</p>\n<p>Maybe you should start with  <a href=\"http://www.sgi.com/tech/stl/stl_introduction.html\">Introduction to the Standard Template Library</a> which explains that the whole point of the STL is that it is written in terms of generic <a href=\"http://www.generic-programming.org/about/intro/concepts.php\">concepts</a>, not the specifics of what happens for every possible different argument type. This is the basis of <a href=\"http://www.generic-programming.org/\">Generic Programming</a>.</p>\n<p>If an algorithm that is specified to accept arguments that model the <a href=\"http://www.sgi.com/tech/stl/OutputIterator.html\">OutputIterator</a> concept then it means that the algorithm will only use operations that are valid for OutputIterators. The algorithm's specification will tell you what it does, e.g. <a href=\"http://www.sgi.com/tech/stl/copy.html\">copy</a> says:</p>\n<blockquote>\n<p id=\"so_31586277_31591251_0\">for every integer <code>n</code> from <code>0</code> to <code>last - first</code>, copy performs the assignment <code>*(result + n) = *(first + n)</code></p>\n</blockquote>\n<p>So this tells you that the algorithm will use the assignment operator.</p>\n<p>A <a href=\"http://www.sgi.com/tech/stl/insert_iterator.html\"><code>std::insert_iterator</code></a> is a model of the OutputIterator concept, so you can use it with algorithms that work with OutputIterators. If the specification of the algorithm tells you it will assign to its OutputIterator arguments then you know what will happen because the specification of <code>std::insert_iterator</code> tells you what assignment means for <code>std::insert_iterator</code>. You don't need to look at the code of the algorithm to know this, because the description of the algorithms and the concepts named in its signature tell you which operations it is going to use (and they will only be ones supported by the concepts it requires).</p>\n<p>In C++ today the concepts used by an algorithm are only stated informally, by naming template parameters to indicate the required concepts e.g.</p>\n<pre><code>template&lt;class ForwardIterator, class T&gt;\nForwardIterator \nremove(ForwardIterator first, ForwardIterator last, const T&amp; value);\n</code></pre>\n<p>By convention (and as specified in 25.1 [algorithms.general] paragraph 5) this means that the <code>remove</code> algorithm requires the type of its first two arguments to model the <code>ForwardIterator</code> concept. </p>\n<p>In a future version of C++ it is expected that you will be able to state these requirements explicitly in the language e.g.</p>\n<pre><code>template&lt;class FI, class T&gt; requires Forward_iterator&lt;FI&gt;\nFI \nremove(FI first, FI last, const T&amp; value);\n</code></pre>\n<p>or equivalently:</p>\n<pre><code>template&lt;Forward_iterator FI, class T&gt;\nFI\nremove(FI first, FI last, const T&amp; value);\n</code></pre>\n<p>Using this style of declaration will all the compiler to check that the arguments to the function really do meet all the requirements of a ForwardIterator, and reject the program otherwise.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2015-07-23T15:18:50.473", "Score": "6", "CreationDate": "2015-07-23T15:05:30.800", "ParentId": "31586277", "CommentCount": "5", "LastEditDate": "2015-07-23T15:18:50.473", "OwnerUserId": "981959"}, "bq_ids": {"n4140": {"so_31586277_31591251_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 1358}}, "n3337": {"so_31586277_31591251_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 1352}}, "n4659": {"so_31586277_31591251_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 1490}}}, "31586546": {"Id": "31586546", "PostTypeId": "2", "Body": "<p>No, you don't need to know the <em>implememtation</em> of any of the STL algorithms, as they have their Requirements in general specified in The International Standard.\nFor example, <code>std::remove()</code> is declared as:</p>\n<pre><code>template&lt;class ForwardIterator, class T&gt;\nForwardIterator remove(ForwardIterator first, ForwardIterator last, const T&amp; value);\n</code></pre>\n<p>And is described as follows:</p>\n<pre><code>template&lt;class ForwardIterator, class T&gt;\nForwardIterator remove(ForwardIterator first, ForwardIterator last, const T&amp; value);\n</code></pre>\n<blockquote id=\"so_31586277_31586546_0\">\n<ul>\n<li><strong>Requires:</strong> The type of <code>*first</code> shall satisfy the <code>MoveAssignable</code> requirements (Table 22).</li>\n<li><strong>Effects:</strong> Eliminates all the elements referred to by iterator <code>i</code> in the range <code>[first,last)</code> for which the\n  following corresponding conditions hold: <code>*i == value</code>.</li>\n<li><strong>Returns:</strong> The end of the resulting range.</li>\n<li><strong>Remarks:</strong> Stable (17.6.5.7).</li>\n<li><strong>Complexity:</strong> Exactly <code>last - first</code> applications of the corresponding predicate.</li>\n<li><strong>Note:</strong> each element in the range <code>[ret,last)</code>, where <code>ret</code> is the returned value, has a valid but unspecified state, because the algorithms can eliminate elements by moving from elements that were originally in that range.</li>\n</ul>\n</blockquote>\n<p>So all you ever <em>need</em> to know is The International Standard's paragraph about the algorithm, as it (and only it) specifies exactly <em>what</em> happens in the particular algorithm, no more, no less.</p>\n<p>Besides, reading STL internals is a not a good idea, most of the time.</p>\n", "LastEditorUserId": "3233393", "LastActivityDate": "2015-07-23T12:07:55.680", "Score": "7", "CreationDate": "2015-07-23T11:51:26.203", "ParentId": "31586277", "CommentCount": "13", "LastEditDate": "2015-07-23T12:07:55.680", "OwnerUserId": "2851815"}});