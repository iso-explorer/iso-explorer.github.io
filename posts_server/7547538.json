post_cb({"7547608": {"ParentId": "7547538", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I'm not entirely sure, but this is what I suspect...</p>\n<p>I wonder if this is related to the fact that an array of derived classes should not be casted to an array of base classes (they're not the same, see: <a href=\"http://www.parashift.com/c++-faq-lite/proper-inheritance.html#faq-21.3\" rel=\"nofollow\">http://www.parashift.com/c++-faq-lite/proper-inheritance.html#faq-21.3</a>): how would <code>delete</code> know the size of the object it is deleting, to adjust the pointer for <code>numArr[0]</code> and <code>numArr[1]</code> (to find the v-table and pass <code>this</code> to the d-tor)</p>\n<p>Apparently, the standard explicitly names this as undefined (5.3.5):</p>\n<blockquote>\n<p id=\"so_7547538_7547608_0\">In the second alternative (delete array ) if the dynamic type of the object to be deleted differs from its static type, the behavior is unde\ufb01ned.</p>\n</blockquote>\n", "OwnerUserId": "101999", "LastEditorUserId": "101999", "LastEditDate": "2011-09-25T18:33:41.967", "Id": "7547608", "Score": "2", "CreationDate": "2011-09-25T18:24:03.797", "LastActivityDate": "2011-09-25T18:33:41.967"}, "7547626": {"ParentId": "7547538", "PostTypeId": "2", "CommentCount": "0", "Body": "<pre><code>Number *numArr = new Complex [2];\ndelete [] numArr;\n</code></pre>\n<p>Actually, the delete operation invokes undefined behaviour.</p>\n<p>\u00a75.3.5/3 says,</p>\n<blockquote>\n<p id=\"so_7547538_7547626_0\">In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined. <strong>In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</strong>)</p>\n</blockquote>\n<p>What it actually means is this:</p>\n<pre><code>Number *object= new Complex();\ndelete object; //well-defined\n\n//BUT\nNumber *array = new Complex[N];\ndelete [] array; //undefined\n</code></pre>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-09-25T18:44:10.973", "Id": "7547626", "Score": "6", "CreationDate": "2011-09-25T18:27:39.303", "LastActivityDate": "2011-09-25T18:44:10.973"}, "7547538": {"CommentCount": "5", "ViewCount": "445", "CreationDate": "2011-09-25T18:16:03.983", "LastActivityDate": "2011-09-25T18:44:10.973", "Title": "Virtual dtor segmentation fault", "AcceptedAnswerId": "7547608", "PostTypeId": "1", "Id": "7547538", "Score": "2", "Body": "<p>I've got the following code in C++:</p>\n<pre><code>#include &lt;iostream&gt; \n\nclass Number \n{ \npublic: \n    virtual void foo(){std::cout &lt;&lt; \"Number foo\\n\";};\n    Number (){ std::cout &lt;&lt; \"Number ctor\" &lt;&lt; std::endl;} \n    virtual ~Number(){ std::cout &lt;&lt; \"Number dtor\" &lt;&lt; std::endl;} \n}; \n\n\nclass Complex : public Number \n{ \npublic:\n    virtual void foo(){std::cout &lt;&lt; \"Complex foo\\n\";};\n    Complex (double r=0, double i=0) : _r (r), _i (i)\n    { std::cout &lt;&lt; \"Complex ctor\" &lt;&lt; std::endl; };\n    virtual ~Complex(){ std::cout &lt;&lt; \"Complex dtor\" &lt;&lt; std::endl;}\nprivate: \n    double _r,_i;\n};\n\n\nint main()\n{\n    Number *numArr = new Complex [2];\n    delete [] numArr;\n    return 0; \n}\n</code></pre>\n<p>When the destructors are declared as virtual, the application is quitting with segmentation fault. When it is not declared as virtual, than the Number class destructors are invoked (which is obvious...). But, when the destructors are declared as virtual, AND when i'm removing the doubles in the Complex class, there is no segmentation fault and the destructors are called in the expected order (Complex, Number), So i guess the problem is related to the size of the object, can anyone please give me an explanation?\nThanks,\nAmit.</p>\n", "Tags": "<c++><destructor>", "OwnerUserId": "924258", "AnswerCount": "3"}, "7547684": {"ParentId": "7547538", "CommentCount": "1", "Body": "<p>You cannot have polymorphic arrays in C++. Arrays rely on pointer arithmetic and pointer arithmetic relies on the compiler knowing object sizes. Any access to any element of the array beyond the zeroth is undefined in your case. </p>\n", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "7547684", "Score": "4", "CreationDate": "2011-09-25T18:36:02.683", "LastActivityDate": "2011-09-25T18:36:02.683"}, "bq_ids": {"n4140": {"so_7547538_7547608_0": {"section_id": 6107, "quality": 0.8571428571428571, "length": 12}, "so_7547538_7547626_0": {"section_id": 6107, "quality": 0.8974358974358975, "length": 35}}, "n3337": {"so_7547538_7547608_0": {"section_id": 5873, "quality": 0.8571428571428571, "length": 12}, "so_7547538_7547626_0": {"section_id": 5873, "quality": 0.8974358974358975, "length": 35}}, "n4659": {"so_7547538_7547608_0": {"section_id": 7604, "quality": 0.8571428571428571, "length": 12}, "so_7547538_7547626_0": {"section_id": 7604, "quality": 0.8974358974358975, "length": 35}}}});