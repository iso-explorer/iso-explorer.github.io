post_cb({"bq_ids": {"n4140": {"so_27573928_27574235_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 392}, "so_27573928_27574224_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 599}}, "n3337": {"so_27573928_27574235_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 383}, "so_27573928_27575475_0": {"length": 45, "quality": 0.9, "section_id": 599}, "so_27573928_27574224_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 589}}, "n4659": {"so_27573928_27574235_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 409}, "so_27573928_27574224_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 622}}}, "27575475": {"Id": "27575475", "PostTypeId": "2", "Body": "<p>clang doesn't seem to care whether the conversion operator is <code>explicit</code> or not, and I believe it is correct due to the wording in <em>[over.best.ics]</em>.</p>\n<p>First of all, the <em>direct-initialization</em> </p>\n<pre><code>std::string baz(Foo{});\n</code></pre>\n<p>works on both gcc and clang, and is explained by <em>[class.conv.fct]/2</em> as mentioned in <a href=\"https://stackoverflow.com/a/27574235/241631\">KerrekSB's answer</a>.</p>\n<p>The <em>direct-list-initialization</em></p>\n<pre><code>std::string bar{Foo{}};\n</code></pre>\n<p>on the other hand, does not consider <em>any</em> user defined conversions, <code>explicit</code> or not.</p>\n<p>Quoting N3337, <em>\u00a713.3.3.1/4</em> <strong>[over.best.ics]</strong></p>\n<blockquote>\n<p id=\"so_27573928_27575475_0\">However, <strong>when considering the argument of a constructor</strong> or user-defined conversion function that is a candidate by 13.3.1.3 when invoked for the copying/moving of the temporary in the second step of a class copy-initialization, by 13.3.1.7 when passing the initializer list as a single argument or <strong>when the initializer list has exactly one element and a conversion to some class X</strong> or reference to (possibly cv-qualified) X <strong>is considered for the first parameter of a constructor of X</strong>, or by 13.3.1.4, 13.3.1.5, or 13.3.1.6 in all cases, <strong>only standard conversion sequences and ellipsis conversion sequences are considered</strong>.</p>\n</blockquote>\n", "LastActivityDate": "2014-12-19T23:44:31.360", "CommentCount": "4", "CreationDate": "2014-12-19T23:44:31.360", "ParentId": "27573928", "Score": "2", "OwnerUserId": "241631"}, "27574224": {"Id": "27574224", "PostTypeId": "2", "Body": "<p>This seems to be a Clang bug. [over.match.list]/1:</p>\n<blockquote>\n<p id=\"so_27573928_27574224_0\">When objects of non-aggregate class type <code>T</code> are list-initialized\n  (8.5.4), overload resolution selects the constructor in two phases:</p>\n<ul>\n<li>[..]</li>\n<li>If no viable initializer-list constructor is found, <strong>overload resolution is performed again, where the candidate functions are all\n  the constructors of the class <code>T</code> and the argument list consists of\n  the elements of the initializer list.</strong></li>\n</ul>\n</blockquote>\n<p>Since the second line compiles fine, there is an inconsistency: They should be equivalent when it comes to overload resolution.</p>\n", "LastActivityDate": "2014-12-19T21:37:44.770", "CommentCount": "1", "CreationDate": "2014-12-19T21:37:44.770", "ParentId": "27573928", "Score": "4", "OwnerUserId": "3647361"}, "27574235": {"Id": "27574235", "PostTypeId": "2", "Body": "<p>From [class.conv.fct]/2:</p>\n<blockquote>\n<p id=\"so_27573928_27574235_0\">A conversion function may be explicit (7.1.2), in which case it is only considered as a user-defined conversion for direct-initialization (8.5).</p>\n</blockquote>\n<p>So the question is how you initialize your objects. Clearly <code>baz</code> is direct-initialized, so this works. By contrast, <code>bar</code> is direct-list-initialized, but not direct-initialized, and so the explicit conversion is not available.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2014-12-19T21:51:40.260", "Score": "3", "CreationDate": "2014-12-19T21:38:23.770", "ParentId": "27573928", "CommentCount": "4", "OwnerUserId": "596781", "LastEditDate": "2014-12-19T21:51:40.260"}, "27573928": {"ViewCount": "414", "Body": "<p>The following code compiles with GCC 4.9.2 but not with Clang 3.5.0:</p>\n<pre><code>#include &lt;string&gt;\n\nclass Foo\n{\npublic:\n  explicit operator std::string() const;\n};\n\nstd::string bar{Foo{}}; // Works in g++, fails in clang++\nstd::string baz(Foo{}); // Works in both\n</code></pre>\n<p>clang++ says:</p>\n<pre><code>foo.cpp:9:13: error: no matching constructor for initialization of 'std::string'\n      (aka 'basic_string&lt;char&gt;')\nstd::string bar{Foo{}};\n            ^  ~~~~~~~\n...: note: candidate constructor not viable: no known conversion from 'Foo' to\n      'const std::basic_string&lt;char&gt; &amp;' for 1st argument\n      basic_string(const basic_string&amp; __str);\n      ^\n</code></pre>\n<p>Curiously, it works if <code>std::string</code> is replaced with a primitive type like <code>int</code>.</p>\n", "Title": "Are explicit conversion operators allowed in braced initializer lists?", "CreationDate": "2014-12-19T21:10:26.560", "LastActivityDate": "2014-12-19T23:44:31.360", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-12-19T21:32:17.597", "LastEditorUserId": "502399", "Id": "27573928", "Score": "14", "OwnerUserId": "502399", "Tags": "<c++><c++11><gcc><clang><compiler-bug>", "AnswerCount": "3"}});