post_cb({"bq_ids": {"n4140": {"so_33434606_33434606_0": {"length": 49, "quality": 0.98, "section_id": 216}}, "n3337": {"so_33434606_33434606_0": {"length": 49, "quality": 0.98, "section_id": 210}}, "n4659": {"so_33434606_33434606_0": {"length": 49, "quality": 0.98, "section_id": 224}}}, "33434606": {"ViewCount": "113", "Body": "<p>I don't understand why it isn't correct  </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct CL{};\n\ntemplate &lt;typename T&gt;\nvoid fnc(T t)\n{\n    f(t);\n}\n\nnamespace NS {\n    void f(CL){}\n    void fn() {fnc(CL()); /*error is here*/}\n    //point of instantiation fnc&lt;CL&gt; is here (in namespace scope,\n    //according to 14.6.4.1/1)\n}\n\nint main(){}\n</code></pre>\n<p>Calling <code>f(t)</code> in template function <code>fnc</code> is dependent on template parameter and then name lookup must be at an instantiation point. I saw Standard (C++ 14) 14.6.4.1/1  </p>\n<blockquote>\n<p id=\"so_33434606_33434606_0\">For a function template specialization, a member function template\n  specialization, or a specialization for a member function or static\n  data member of a class template, if the specialization is implicitly\n  instantiated because it is referenced from within another template\n  specialization and the context from which it is referenced depends\n  on a template parameter, the point of instantiation of the\n  specialization is the point of instantiation of the enclosing\n  specialization. <strong>Otherwise, the point of instantiation for such a\n  specialization immediately follows the namespace scope declaration or\n  definition that refers to the specialization.</strong></p>\n</blockquote>\n<p><code>f(CL)</code> is visible at a point of instantiation of <code>fnc&lt;CL&gt;</code>, but all the compilers (VS, gcc, clang) give an error. What is reason for that behavior?</p>\n", "AcceptedAnswerId": "33434768", "Title": "Template specialization doesn't see a function in its point of instantiation", "CreationDate": "2015-10-30T11:10:09.173", "Id": "33434606", "CommentCount": "0", "LastEditDate": "2015-10-31T15:44:38.990", "PostTypeId": "1", "LastEditorUserId": "3309790", "LastActivityDate": "2015-10-31T15:44:38.990", "Score": "4", "OwnerUserId": "3514538", "Tags": "<c++><templates><language-lawyer><instantiation>", "AnswerCount": "1"}, "33434768": {"Id": "33434768", "PostTypeId": "2", "Body": "<p>Here the argument <code>t</code> of <code>fnc</code> is a dependent name, which cannot be resolved when parsing templates. Instead, they are looked up again at the point of instantiation. This is so-called two-phase lookup: the 1st phase is the parsing of a template, and the 2nd phase is its instantiation.</p>\n<p>The answer to your question lies in the fact that the 2nd lookup performed at the POI (point of instantiation) is only an <strong>ADL</strong>. Because the struct <code>CL</code> is not defined inside the same namespace with <code>void f(CL)</code>, the POI lookup would therefore not take place and would not find it.</p>\n<p>If you try to put the definition of the struct <code>CL</code> into the namespace to make <a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow\">ADL</a> take effect, it will compile well.</p>\n<pre><code>namespace NS {\n    struct CL{};\n    void f(CL){}\n    //...\n}\n</code></pre>\n<p>According to the rule of <a href=\"http://en.cppreference.com/w/cpp/language/unqualified_lookup\" rel=\"nofollow\">unqualified name lookup</a>, (bold by me)</p>\n<blockquote>\n<p id=\"so_33434606_33434768_0\">For a dependent name used in a template definition, the lookup is\n  postponed until the template arguments are known, at which time ADL\n  examines function declarations with external linkage (until C++11)\n  that are visible from the template definition context as well as in\n  the template instantiation context, while non-ADL lookup only examines\n  function declarations with external linkage (until C++11) that are\n  visible from the template definition context (in other words, <strong>adding\n  a new function declaration after template definition does not make it\n  visible except via ADL</strong>).</p>\n</blockquote>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2015-10-31T12:31:02.227", "Score": "7", "CreationDate": "2015-10-30T11:19:07.207", "ParentId": "33434606", "CommentCount": "2", "OwnerUserId": "3309790", "LastEditDate": "2015-10-31T12:31:02.227"}});