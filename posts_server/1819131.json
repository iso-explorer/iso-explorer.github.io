post_cb({"1819202": {"ParentId": "1819131", "CommentCount": "0", "Body": "<ul>\n<li><p>[1] uncommented case:\nIt is ok. <code>static InitHelper B&lt;int&gt;::mInit</code> does not exist. If member of the template class (struct) is not used it does not compiled.</p></li>\n<li><p>[1] and [2] uncommented case:\nIt is ok. <code>B&lt;int&gt;::getHelper()</code> use <code>static InitHelper B&lt;int&gt;::mInit</code> and <code>mInit</code> exists.</p></li>\n<li><p>[1] commented, [2] uncommented:\nit works for me in VS2008.</p></li>\n</ul>\n", "OwnerUserId": "124161", "PostTypeId": "2", "Id": "1819202", "Score": "2", "CreationDate": "2009-11-30T11:15:27.903", "LastActivityDate": "2009-11-30T11:15:27.903"}, "1825872": {"ParentId": "1819131", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This was discussed on usenet some time ago, while i was trying to answer another question on stackoverflow: <a href=\"http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/cae9fd5fa38c898e?pli=1\" rel=\"noreferrer\">Point of Instantiation of Static Data Members</a>. I think it's worth reducing the test-case, and considering each scenario in isolation, so let's look at it more general first:</p>\n<hr>\n<pre><code>struct C { C(int n) { printf(\"%d\\n\", n); } };\n\ntemplate&lt;int N&gt;\nstruct A {\n  static C c;\n}; \n\ntemplate&lt;int N&gt;\nC A&lt;N&gt;::c(N); \n\nA&lt;1&gt; a; // implicit instantiation of A&lt;1&gt; and 2\nA&lt;2&gt; b;\n</code></pre>\n<p>You have the definition of a static data member template. This does not yet create any data members, because of <code>14.7.1</code>: </p>\n<blockquote>\n<p id=\"so_1819131_1825872_0\">\"... in particular, the initialization (and any associated side-effects) of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist.\"</p>\n</blockquote>\n<p>The definition of something (= entity) is needed when that entity is \"used\", according to the one definition rule which defines that word (at <code>3.2/2</code>). In particular, if all references are from uninstantiated templates, members of a template or a <code>sizeof</code> expressions or similar things that don't \"use\" the entity (since they are either not potentially evaluating it, or they just don't exist yet as functions/member functions that are itself used), such a static data member is not instantiated.</p>\n<p>An implicit instantiation by <code>14.7.1/7</code> instantiates declarations of static data members - that is to say, it will instantiate any template needed to process that declaration. It won't, however, instantiate definitions - that is to say, initializers are not instantiated and constructors of the type of that static data member are not implicitly defined (marked as used). </p>\n<p>That all means, the above code will output nothing yet. Let's cause implicit instantiations of the static data members now. </p>\n<pre><code>int main() { \n  A&lt;1&gt;::c; // reference them\n  A&lt;2&gt;::c; \n}\n</code></pre>\n<p>This will cause the two static data members to exist, but the question is - how is the order of initialization? On a simple read, one might think that <code>3.6.2/1</code> applies, which says (emphasis by me):</p>\n<blockquote>\n<p id=\"so_1819131_1825872_1\">\"Objects with static storage duration defined in namespace scope in the same <em>translation unit</em> and dynamically initialized shall be initialized in the order in which their definition appears in the translation unit.\"</p>\n</blockquote>\n<p>Now as said in the usenet post and explained <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#362\" rel=\"noreferrer\">in this defect report</a>, these static data members are not defined in a translation unit, but they are instantiated in a <em>instantiation unit</em>, as explained at <code>2.1/1</code>:</p>\n<blockquote>\n<p id=\"so_1819131_1825872_2\">Each translated translation unit is examined to produce a list of required instantiations. [Note: this may include instantiations which have been explicitly requested (14.7.2). ] The definitions of the required templates are located. It is implementation-defined whether the source of the translation units containing these definitions is required to be available. [Note: an implementation could encode sufficient information into the translated translation unit so as to ensure the source is not required here. ] All the required instantiations are performed to produce instantiation units. [Note: these are similar to translated translation units, but contain no references to uninstantiated templates and no template definitions. ] The program is ill-formed if any instantiation fails.</p>\n</blockquote>\n<p>The Point of Instantiation of such a member also does not really matter, because such a point of instantiation is the context link between an instantiation and its translation units - it defines the declarations that are visible (as specified at <code>14.6.4.1</code>, and each of those point of instantiations must give instantiations the same meaning, as specified in the one definition rule at <code>3.2/5</code>, last bullet). </p>\n<p>If we want ordered initialization, we have to arrange so we don't mess with instantiations, but with explicit declarations - this is the area of explicit specializations, as these are not really different to normal declarations. In fact, C++0x changed its wording of <code>3.6.2</code> to the following:</p>\n<blockquote>\n<p id=\"so_1819131_1825872_3\">Dynamic initialization of a non-local object with static storage duration is either ordered or unordered.\n  Definitions of explicitly specialized class template static data members have ordered initialization. Other\n  class template static data members (i.e., implicitly or explicitly instantiated specializations) have unordered initialization.</p>\n</blockquote>\n<hr>\n<p>This means to your code, that:</p>\n<ul>\n<li><strong><code>[1]</code></strong> and <strong><code>[2]</code></strong> commented: No reference to the static data members exist, so their definitions (and also not their declarations, since there is no need for instantiation of <code>B&lt;int&gt;</code>) are not instantiated. No side effect occurs.</li>\n<li><strong><code>[1]</code></strong> uncommented: <code>B&lt;int&gt;::getB()</code> is used, which in itself uses <code>B&lt;int&gt;::mB</code>, which requires that static member to exist. The string is initialized prior to main (at any case before that statement, as part of initializing non-local objects). Nothing uses <code>B&lt;int&gt;::mInit</code>, so it's not instantiated, and so no object of <code>B&lt;int&gt;::InitHelper</code> is ever created, which makes its constructor not being used, which in turn will never assign something to <code>B&lt;int&gt;::mB</code>: You will just output an empty string. </li>\n<li><strong><code>[1]</code></strong> and <strong><code>[2]</code></strong> uncommented: That this worked for you is luck (or the opposite :)). There is no requirement for a particular order of initialization calls, as explained above. It might work on VC++, fail on GCC and work on clang. We don't know.</li>\n<li><strong><code>[1]</code></strong> commented, <strong><code>[2]</code></strong> uncommented: Same problem - again, <em>both</em> static data members are <em>used</em>: <code>B&lt;int&gt;::mInit</code> is used by <code>B&lt;int&gt;::getHelper</code>, and the instantiation of <code>B&lt;int&gt;::mInit</code> will cause its constructor to be instantiated, which will use <code>B&lt;int&gt;::mB</code> - but for your compiler, the order is different in this particular run (unspecified behavior is not required to be consistent among different runs): It initializes <code>B&lt;int&gt;::mInit</code> first, which will operate on a not-yet-constructed string object. </li>\n</ul>\n</hr></hr>", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2009-12-01T12:57:54.910", "Id": "1825872", "Score": "35", "CreationDate": "2009-12-01T12:22:57.770", "LastActivityDate": "2009-12-01T12:57:54.910"}, "1819290": {"ParentId": "1819131", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The problem is that the defintions you give for the static member variables are templates too.</p>\n<pre><code>template&lt;class T&gt;\nstd::string B&lt;T&gt;::mB;\ntemplate&lt;class T&gt;\ntypename B&lt;T&gt;::InitHelper B&lt;T&gt;::mInit;\n</code></pre>\n<p>During compilation, this defines actually nothing, since T is not known. It is something like a class declaration or a template definition, the compiler does not generate code or reserve storage when it sees it.</p>\n<p>The definition happens implicitly later, when you use the template class. Because in the segfaulting case you don't use B&lt;int&gt;::mInit, it is never created.</p>\n<p>A solution would be explictly defining the needed member (without initializing it): Put somewhere source file a</p>\n<pre><code>template&lt;&gt;\ntypename B&lt;int&gt;::InitHelper B&lt;int&gt;::mInit;\n</code></pre>\n<p>This works basically the same way as explictly defining a template class.</p>\n", "OwnerUserId": "154980", "LastEditorUserId": "154980", "LastEditDate": "2009-11-30T15:10:51.887", "Id": "1819290", "Score": "4", "CreationDate": "2009-11-30T11:32:51.750", "LastActivityDate": "2009-11-30T15:10:51.887"}, "bq_ids": {"n4140": {"so_1819131_1825872_2": {"section_id": 5313, "quality": 0.8840579710144928, "length": 61}, "so_1819131_1825872_1": {"section_id": 7152, "quality": 0.5263157894736842, "length": 10}, "so_1819131_1825872_3": {"section_id": 7151, "quality": 0.9705882352941176, "length": 33}, "so_1819131_1825872_0": {"section_id": 234, "quality": 1.0, "length": 20}, "so_1819131_1819131_0": {"section_id": 234, "quality": 0.9767441860465116, "length": 42}}, "n3337": {"so_1819131_1825872_2": {"section_id": 5110, "quality": 0.8840579710144928, "length": 61}, "so_1819131_1825872_1": {"section_id": 6896, "quality": 0.5263157894736842, "length": 10}, "so_1819131_1825872_0": {"section_id": 227, "quality": 1.0, "length": 20}, "so_1819131_1825872_3": {"section_id": 6895, "quality": 0.9705882352941176, "length": 33}, "so_1819131_1819131_0": {"section_id": 227, "quality": 0.9767441860465116, "length": 42}}, "n4659": {"so_1819131_1825872_2": {"section_id": 6737, "quality": 0.8840579710144928, "length": 61}, "so_1819131_1825872_0": {"section_id": 244, "quality": 0.95, "length": 19}, "so_1819131_1819131_0": {"section_id": 244, "quality": 0.9534883720930233, "length": 41}}}, "1819131": {"CommentCount": "4", "AcceptedAnswerId": "1825872", "PostTypeId": "1", "LastEditorUserId": "221259", "CreationDate": "2009-11-30T10:59:10.230", "LastActivityDate": "2009-12-01T12:57:54.910", "LastEditDate": "2009-12-01T07:35:32.537", "ViewCount": "19802", "FavoriteCount": "12", "Title": "C++ Static member initalization (template fun inside)", "Id": "1819131", "Score": "37", "Body": "<p>For static member initialization I use a nested helper struct, which works fine for non templated classes. \nHowever, if the enclosing class is parameterized by a template, the nested initialization class is not instantiated, if the helper object is not accessed in the main code.\nFor illustration, a simplified example (In my case, I need to initialize a vector).  </p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nstruct A\n{\n    struct InitHelper\n    {\n        InitHelper()\n        {\n            A::mA = \"Hello, I'm A.\";\n        }\n    };\n    static std::string mA;\n    static InitHelper mInit;\n\n    static const std::string&amp; getA(){ return mA; }\n};\nstd::string A::mA;\nA::InitHelper A::mInit;\n\n\ntemplate&lt;class T&gt;\nstruct B\n{\n    struct InitHelper\n    {\n        InitHelper()\n        {\n            B&lt;T&gt;::mB = \"Hello, I'm B.\"; // [3]\n        }\n    };\n    static std::string mB;\n    static InitHelper mInit;\n\n    static const std::string&amp; getB() { return mB; }\n    static InitHelper&amp; getHelper(){ return mInit; }\n};\ntemplate&lt;class T&gt;\nstd::string B&lt;T&gt;::mB; //[4]\ntemplate&lt;class T&gt;\ntypename B&lt;T&gt;::InitHelper B&lt;T&gt;::mInit;\n\n\nint main(int argc, char* argv[])\n{\n    std::cout &lt;&lt; \"A = \" &lt;&lt; A::getA() &lt;&lt; std::endl;\n\n//    std::cout &lt;&lt; \"B = \" &lt;&lt; B&lt;int&gt;::getB() &lt;&lt; std::endl; // [1]\n//    B&lt;int&gt;::getHelper();    // [2]\n}\n</code></pre>\n<p>With g++ 4.4.1: </p>\n<ul>\n<li><p>[1] and [2] commented:  </p>\n<pre>A = Hello, I'm A.</pre>\n<p>Works as intended</p></li>\n<li><p>[1] uncommented:  </p>\n<pre>A = Hello, I'm A.\nB = </pre>\n<p>I would expect, that the InitHelper initializes mB</p></li>\n<li>[1] and [2] uncommented:  \n\n<pre>A = Hello, I'm A.\nB = Hello, I'm B.</pre>  \n\nWorks as intended</li>\n<li>[1] commented, [2] uncommented:<br>\nSegfault in the static initialization stage at [3]  </br></li>\n</ul>\n<p>Thus my question: Is this a compiler bug or is the bug sitting between the monitor and the chair? \nAnd if the latter is the case: Is there an elegant solution (i.e. without explicitly calling a static initialization method)?</p>\n<p>Thank you very much for any suggestions/comments.</p>\n<p><strong>Update I:</strong><br>\nThis seems to be a desired behavior (as defined in the ISO/IEC C++ 2003 standard, 14.7.1):</br></p>\n<blockquote>\n<p id=\"so_1819131_1819131_0\">Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist; in particular, the initialization (and any associated side-effects) of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist.</p>\n</blockquote>\n", "Tags": "<c++><templates><initialization><static-members>", "OwnerUserId": "221259", "AnswerCount": "3"}});