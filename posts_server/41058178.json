post_cb({"41058695": {"ParentId": "41058178", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>You don't name any standards, but let's see what the differences are:</p>\n<blockquote>\n<p id=\"so_41058178_41058695_0\"><code>[C++11: 4.10/1]:</code> A <em>null pointer constant</em> is an integral constant expression (5.19) prvalue of integer type that evaluates to zero or a prvalue of type <code>std::nullptr_t</code>. A null pointer constant can be converted to a pointer type; the result is the <em>null pointer value</em> of that type and is distinguishable from every other value of object pointer or function pointer type. Such a conversion is called a <em>null pointer conversion</em>. Two null pointer values of the same type shall compare equal. The conversion of a null pointer constant to a pointer to cv-qualified type is a single conversion, and not the sequence of a pointer conversion followed by a qualification. <em>[..]</em></p>\n<p id=\"so_41058178_41058695_1\"><code>[C++11: 5.19/3]:</code> A literal constant expression is a prvalue core constant expression of literal type, but not pointer type. An integral constant expression is a literal constant expression of integral or unscoped enumeration type. <em>[..]</em></p>\n</blockquote>\n<p>And:</p>\n<blockquote>\n<p id=\"so_41058178_41058695_2\"><code>[C++03: 4.10/1]:</code> A null pointer constant is an integral constant expression (5.19) rvalue of integer type that evaluates to zero. A null pointer constant can be converted to a pointer type; the result is the null pointer value of that type and is distinguishable from every other value of pointer to object or pointer to function type. Two null pointer values of the same type shall compare equal. The conversion of a null pointer constant to a pointer to cv-qualified type is a single conversion, and not the sequence of a pointer conversion followed by a qualification conversion (4.4).</p>\n<p id=\"so_41058178_41058695_3\"><code>[C++03: 5.19/2]:</code>Other expressions are considered constant-expressions only for the purpose of non-local static object initialization (3.6.2). Such constant expressions shall evaluate to one of the following:</p>\n<ul>\n<li>a null pointer value (4.10),</li>\n<li>a null member pointer value (4.11),</li>\n<li>an arithmetic constant expression,</li>\n<li>an address constant expression,</li>\n<li>a reference constant expression,</li>\n<li>an address constant expression for a complete object type, plus or minus an integral constant expression, or</li>\n<li>a pointer to member constant expression.</li>\n</ul>\n</blockquote>\n<p>The key here is that the standard language changed between C++03 and C++11, with the latter introducing the requirement that a null pointer constant of this form be a literal.</p>\n<p>(They always needed to actually be constants and evaluate to 0, so you can remove <code>v2</code>, <code>v3</code>, <code>w2</code>  and <code>w3</code> from your testcase.)</p>\n<p>A null pointer constant can convert to a <code>double*</code> more easily than going through your user-defined conversion, so\u2026</p>\n<p><strong>I believe MSVS is implementing the C++03 rules.</strong></p>\n<p>Amusingly, though, if I put GCC in C++03 mode, its behaviour isn't changed, which is technically non-compliant. I suspect the change in the language stemmed from the behaviour of common implementations at the time, rather than the other way around. I <em>can</em> see some <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#456\" rel=\"nofollow noreferrer\">evidence that GCC was [allegedly] non-conforming in this regard as early as 2004</a>, so it may also just be that the standard wording change fortuitously un-bugged what had been a GCC bug.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2016-12-09T10:59:57.500", "Id": "41058695", "Score": "5", "CreationDate": "2016-12-09T10:49:58.463", "LastActivityDate": "2016-12-09T10:59:57.500"}, "bq_ids": {"n4140": {"so_41058178_41058695_2": {"section_id": 39, "quality": 0.7796610169491526, "length": 46}, "so_41058178_41058695_0": {"section_id": 39, "quality": 0.8059701492537313, "length": 54}, "so_41058178_41058695_1": {"section_id": 6186, "quality": 0.5416666666666666, "length": 13}}, "n3337": {"so_41058178_41058695_2": {"section_id": 36, "quality": 0.864406779661017, "length": 51}, "so_41058178_41058695_0": {"section_id": 36, "quality": 0.8955223880597015, "length": 60}, "so_41058178_41058695_1": {"section_id": 5947, "quality": 0.8333333333333334, "length": 20}}, "n4659": {"so_41058178_41058695_2": {"section_id": 39, "quality": 0.7796610169491526, "length": 46}, "so_41058178_41058695_0": {"section_id": 39, "quality": 0.8059701492537313, "length": 54}}}, "41058178": {"CommentCount": "13", "ViewCount": "95", "PostTypeId": "1", "LastEditorUserId": "6918", "CreationDate": "2016-12-09T10:24:27.223", "LastActivityDate": "2016-12-09T10:59:57.500", "Title": "MSVC function matching with const enum value 0", "AcceptedAnswerId": "41058695", "LastEditDate": "2016-12-09T10:34:21.993", "Id": "41058178", "Score": "6", "Body": "<p>I was bitten by an unintended C++ function match by MSVC. I can reduce it to the following test case:</p>\n<pre><code>#include &lt;iostream&gt;\n\nenum Code { aaa, bbb };\n\nstruct MyVal {\n    Code c;\n    MyVal(Code c): c(c) { }\n};\n\nvoid test(int i, MyVal val) {\n    std::cout &lt;&lt; \"case \" &lt;&lt; i &lt;&lt; \": value \" &lt;&lt; val.c &lt;&lt; std::endl;\n}\n\nvoid test(int i, double* f) {\n    std::cout &lt;&lt; \"case \" &lt;&lt; i &lt;&lt; \": WRONG\" &lt;&lt; std::endl;\n}\n\nconst Code v1 = aaa;\n      Code v2 = aaa;\nconst Code v3 = bbb;\n\nint main() {\n    const Code w1 = aaa;\n          Code w2 = aaa;\n    const Code w3 = bbb;\n\n    test(1, v1);  // unexpected MSVC WRONG\n    test(2, v2);\n    test(3, v3);\n    test(4, aaa);\n    test(5, w1);  // unexpected MSVC WRONG\n    test(6, w2);\n    test(7, w3);\n    return 0;\n}\n</code></pre>\n<p>I expected that all 7 invocations of test would match the first overload, and GCC (<a href=\"http://rextester.com/TOCI97245\" rel=\"nofollow noreferrer\">live example</a>) and Clang (<a href=\"http://rextester.com/TIVB97417\" rel=\"nofollow noreferrer\">live example</a>) match this as intended:</p>\n<pre><code>case 1: value 0\ncase 2: value 0\ncase 3: value 1\ncase 4: value 0\ncase 5: value 0\ncase 6: value 0\ncase 7: value 1\n</code></pre>\n<p>But MSVC (<a href=\"http://rextester.com/NFW8886\" rel=\"nofollow noreferrer\">live example</a>) matches cases 1 and 5 to the \"wrong\" overload (I found this behavior in MSVC 2013 and 2015):</p>\n<pre><code>case 1: WRONG\ncase 2: value 0\ncase 3: value 1\ncase 4: value 0\ncase 5: WRONG\ncase 6: value 0\ncase 7: value 1\n</code></pre>\n<p>It seems that the conversion to a pointer is preferred by MSVC for a const enum variable with (accidental) value 0. I would have expected this behavior with a literal 0, but not with an enum variable.</p>\n<p>My questions: Is the MSVC behavior standard-conformant? (Perhaps for an older version of C++?) If not, is this a known extension or bug?</p>\n", "Tags": "<c++><visual-c++>", "OwnerUserId": "6918", "AnswerCount": "1"}});