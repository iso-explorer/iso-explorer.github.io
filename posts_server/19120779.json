post_cb({"19120926": {"ParentId": "19120779", "CommentCount": "12", "Body": "<p>So we have 25.2.1/1 which says:</p>\n<blockquote>\n<p id=\"so_19120779_19120926_0\">Returns: true if for every iterator i in the range [first1,last1) the\n  following corresponding conditions hold: *i == *(first2 + (i -\n  first1)), pred(*i, *(first2 + (i - first1))) != false.</p>\n<p id=\"so_19120779_19120926_1\">Otherwise,\n  returns false.</p>\n</blockquote>\n<p>In your case there are no iterators in the range [0, 0) so \"every\" iterator in the range passes the test, but no actual test should be done (since no iterators exist in the range upon which to test).</p>\n<p>It looks like a VisualStudio bug to me.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "19120926", "Score": "9", "CreationDate": "2013-10-01T16:06:18.490", "LastActivityDate": "2013-10-01T16:06:18.490"}, "19126224": {"ParentId": "19120779", "CommentCount": "2", "Body": "<p>As @Zac pointed out, this check is Visual Studio being extra pedantic in the name of security. If you want Visual Studio to more closely comply with the standard even in debug builds, you can turn off this behaviour by setting the macro <a href=\"http://msdn.microsoft.com/en-us/library/vstudio/hh697468.aspx\" rel=\"nofollow\">_ITERATOR_DEBUG_LEVEL to 0</a>.</p>\n", "OwnerUserId": "4304", "PostTypeId": "2", "Id": "19126224", "Score": "2", "CreationDate": "2013-10-01T21:24:55.353", "LastActivityDate": "2013-10-01T21:24:55.353"}, "19137552": {"ParentId": "19120779", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The C++11 standard states \"[i,i) is an empty range\" in 24.2.1/5. </p>\n<p>However, in 24.2.1/5 it first implies that 0 must be a singular value and then states \"Results of most expressions are undefined for singular values\". It then lists exceptions to the undefined behaviour, but comparison is not included.</p>\n<p>So maybe it's undefined to compare singular iterators for equality, hence making [i, i) impossible to evaluate.</p>\n<p>This is also indicated by the fact that your runtime error happens inside a function named _Equal1().</p>\n<p>I think the standard is vague with respect to this, and I'm not at all sure it's a bug in Visual Studio 2012.</p>\n<p><a href=\"http://cplusplus.github.io/LWG/lwg-unresolved.html\" rel=\"nofollow\">http://cplusplus.github.io/LWG/lwg-unresolved.html</a> in the chapter \"1213. Meaning of valid and singular iterator underspecified\" is also pretty amusing with this confusion...</p>\n", "OwnerUserId": "2838737", "LastEditorUserId": "2838737", "LastEditDate": "2013-10-02T20:23:22.527", "Id": "19137552", "Score": "0", "CreationDate": "2013-10-02T13:01:58.163", "LastActivityDate": "2013-10-02T20:23:22.527"}, "19120779": {"CommentCount": "7", "ViewCount": "512", "PostTypeId": "1", "LastEditorUserId": "1698548", "CreationDate": "2013-10-01T15:57:24.670", "LastActivityDate": "2013-10-02T20:23:22.527", "Title": "Is `char* p=0; std::equal(p,p,p)` well-defined according to the C++ standard?", "AcceptedAnswerId": "19120926", "LastEditDate": "2013-10-01T20:58:13.997", "Id": "19120779", "Score": "11", "Body": "<p>Is the following well-defined according to the C++ standard?</p>\n<pre><code>char* p = 0;\nstd::equal(p, p, p);\n</code></pre>\n<p>The question is really this:</p>\n<p>Does the standard require that <code>std::equal(begin1, end1, begin2)</code> is implemented in such a way that if <code>begin1 == end1</code>, then <code>begin1</code> and <code>begin2</code> can be any pointer, even one that does not point to a valid memory object?</p>\n<p>I assume this is the intention of the standard, but I have not been able to find a statement that makes this clear.</p>\n<p>The reason I am concerned about this, is that VisualStudio apparently tries to check the \"validity\" of <code>begin2</code> even when <code>begin1 == end1</code>. And that contradicts my understanding of the requirements of the standard.</p>\n<p>EDIT: Here is the code from VS 2012 that I believe is in violation of the standard:</p>\n<pre><code>template&lt;class _InIt1, class _InIt2&gt; inline\nbool equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)\n{   // compare [_First1, _Last1) to [First2, ...)\n    _DEBUG_RANGE(_First1, _Last1);\n    _DEBUG_POINTER(_First2);\n    return (_Equal1(_Unchecked(_First1), _Unchecked(_Last1), _First2, _Is_checked(_First2)));\n}\n\ntemplate&lt;class _Ty&gt; inline\nvoid _Debug_pointer(const _Ty *_First, _Dbfile_t _File, _Dbline_t _Line)\n{   // test iterator for non-singularity, const pointers\n    if (_First == 0)\n        _DEBUG_ERROR2(\"invalid null pointer\", _File, _Line);\n}\n</code></pre>\n", "Tags": "<c++><visual-studio><stl>", "OwnerUserId": "1698548", "AnswerCount": "4"}, "19123156": {"ParentId": "19120779", "CommentCount": "7", "Body": "<p>With your update, It is clear that it is not a violation of the standard, but a debugging check.  If you compile it in Release mode, those checks do not get run, and the function matches the standard's description.</p>\n<p>It is useful to have that information in Debug mode as it will help you to track down some hard to find bugs.</p>\n", "OwnerUserId": "529761", "PostTypeId": "2", "Id": "19123156", "Score": "0", "CreationDate": "2013-10-01T18:18:57.050", "LastActivityDate": "2013-10-01T18:18:57.050"}, "bq_ids": {"n4140": {"so_19120779_19120926_0": {"section_id": 1273, "quality": 0.875, "length": 14}}, "n3337": {"so_19120779_19120926_0": {"section_id": 1269, "quality": 0.875, "length": 14}}, "n4659": {"so_19120779_19120926_0": {"section_id": 1393, "quality": 0.875, "length": 14}}}});