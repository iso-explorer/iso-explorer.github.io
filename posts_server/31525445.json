post_cb({"bq_ids": {"n4140": {"so_31525445_31526379_0": {"length": 46, "quality": 0.9787234042553191, "section_id": 584}, "so_31525445_31526379_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6991}, "so_31525445_31526379_4": {"length": 34, "quality": 0.918918918918919, "section_id": 6994}, "so_31525445_31526379_3": {"length": 29, "quality": 0.9666666666666667, "section_id": 6993}}, "n3337": {"so_31525445_31526379_0": {"length": 42, "quality": 0.8936170212765957, "section_id": 574}, "so_31525445_31526379_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6737}, "so_31525445_31526379_3": {"length": 29, "quality": 0.9666666666666667, "section_id": 6739}, "so_31525445_31526379_4": {"length": 34, "quality": 0.918918918918919, "section_id": 6740}}, "n4659": {"so_31525445_31526379_0": {"length": 46, "quality": 0.9787234042553191, "section_id": 607}, "so_31525445_31526379_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 8489}, "so_31525445_31526379_3": {"length": 29, "quality": 0.9666666666666667, "section_id": 8491}, "so_31525445_31526379_4": {"length": 34, "quality": 0.918918918918919, "section_id": 8492}}}, "31526379": {"Id": "31526379", "PostTypeId": "2", "Body": "<p>The code is invalid and gcc is correct to reject it (clang 3.6.0 accepts it though - this is a bug). The rules for looking up an operator start with, from [over.match.oper]:</p>\n<blockquote>\n<p id=\"so_31525445_31526379_0\">[...] for a binary\n  operator @ with a left operand of a type whose cv-unqualified version is T1 and a right operand of a type\n  whose cv-unqualified version is T2, three sets of candidate functions, designated <em>member candidates</em>, <em>non-member\n  candidates</em> and <em>built-in candidates</em>, are constructed as follows:<br>\n  \u2014 If T1 is a complete class type or a class currently being defined, the set of member candidates is the\n  result of the qualified lookup of <code>T1::operator@</code> (13.3.1.1.1); otherwise, the set of member candidates\n  is empty.</br></p>\n</blockquote>\n<p>The lookup rules for a member name are (since we're looking up <code>ctmap&lt;last_name,age&gt;::operator[]</code>), from [class.member.lookup]:</p>\n<blockquote>\n<p id=\"so_31525445_31526379_1\">The lookup set for f in C, called S(f,C), [...] is calculated\n  as follows:  </p>\n<p id=\"so_31525445_31526379_2\">If C contains a declaration of the name f, [...]</p>\n<p id=\"so_31525445_31526379_3\">Otherwise (i.e., C does not contain a declaration of f or the resulting declaration set is empty), S(f,C) is\n  initially empty. If C has base classes, calculate the lookup set for f in each direct base class subobject Bi,\n  and merge each such lookup set S(f,B<sub>i</sub>) in turn into S(f,C).</p>\n<p id=\"so_31525445_31526379_4\">The following steps define the result of merging lookup set S(f,B<sub>i</sub>) into the intermediate S(f,C):<br>\n  \u2014 [...]<br>\n  \u2014 Otherwise, if the declaration sets of S(f,B<sub>i</sub>) and S(f,C) differ, the merge is ambiguous: the new\n  S(f,C) is a lookup set with an invalid declaration set and the union of the subobject sets. In subsequent\n  merges, an invalid declaration set is considered different from any other.<br>\n  \u2014 [...]  </br></br></br></p>\n</blockquote>\n<p>Basically - we have two base classes here, both with an <code>operator[]</code>. Both declaration sets differ - so the merge is ambiguous. The way to disambiguate would be to introduce <em>using-declaration</em>s bringing in all the base class member functions into the derived class, so that the initial lookup set finds everything. </p>\n<p>To shorten your example:</p>\n<pre><code>struct A { void foo(char) { } };\nstruct B { void foo(int ) { } };\n\nstruct C : A, B { };\n\nstruct D : A, B {\n    using A::foo;\n    using B::foo;\n};\n</code></pre>\n<p>With that hierarchy</p>\n<pre><code>C c;\nc.foo(4);  // error: ambiguous lookup set for foo()\n\nD d;\nd.foo('x') // OK: calls A::foo()\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-21T10:32:30.323", "Score": "2", "CreationDate": "2015-07-20T21:07:25.073", "ParentId": "31525445", "CommentCount": "10", "OwnerUserId": "2069064", "LastEditDate": "2015-07-21T10:32:30.323"}, "31526228": {"Id": "31526228", "PostTypeId": "2", "Body": "<p>A portable way do do what you want is roughly:</p>\n<pre><code>template&lt;class...Ts&gt;\nstruct operator_index_inherit {};\ntemplate&lt;class T0, class T1, class...Ts&gt;\nstruct operator_index_inherit&lt;T0, T1, Ts...&gt;:\n  T0, operator_index_inherit&lt;T1, Ts...&gt;\n{\n  using T0::operator[];\n  using operator_index_inherit&lt;T1, Ts...&gt;::operator[];\n};\ntemplate&lt;class T0&gt;\nstruct operator_index_inherit&lt;T0&gt;:\n  T0\n{\n  using T0::operator[];\n};\n</code></pre>\n<p>then:</p>\n<pre><code>template&lt;class... Fields&gt;\nstruct ctmap : operator_index_inherit&lt;Field&lt;Fields&gt;...&gt; {\n  using base = operator_index_inherit&lt;Field&lt;Fields&gt;...&gt;;\n  using base::operator[];\n};\n</code></pre>\n<p>here we linearly inherit from each of the types, and <code>using operator[]</code> on our parents.</p>\n<p>If we could <code>using Field&lt;Fields&gt;::operator[]...;</code> we would not have to do this.</p>\n<p>Some care has to be taken with constructors (which I did not take), but you might not need to do this.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a4cd4c24d242631c\" rel=\"nofollow\">live example</a>.</p>\n<hr>\n<p>What is actually going wrong depends on details of the standard I am less than certain of.  Basically, you are mixing operators and inheritance and overloading in a complex way.  Even if your code is standard compliant (which it may or may not be), it is compliant in a way that some compilers die on.</p>\n</hr>", "LastActivityDate": "2015-07-20T20:57:41.077", "CommentCount": "4", "CreationDate": "2015-07-20T20:57:41.077", "ParentId": "31525445", "Score": "3", "OwnerUserId": "1774667"}, "31525445": {"ViewCount": "165", "Body": "<p>I'm trying to compile this example, where a variadic class template inherits from a variadic amount of bases, each of which implements a different <code>operator[]</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nstruct Field {\n  typename T::value_type storage;\n\n  typename T::value_type &amp;operator[](const T &amp;c) {\n    return storage;\n  }\n};\n\ntemplate&lt;typename... Fields&gt;\nstruct ctmap : public Field&lt;Fields&gt;... {\n};\n\nint main() {\n    struct age { typedef int value_type; };\n    struct last_name { typedef std::string value_type; };\n\n    ctmap&lt;last_name, age&gt; person;\n\n    person[last_name()] = \"Smith\";\n    person[age()] = 104;\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>When I compile with gcc (Debian 4.9.2-10), I get the following error</p>\n<pre><code>main.cpp: In function \u2018int main()\u2019:\nmain.cpp:22:23: error: request for member \u2018operator[]\u2019 is ambiguous\n     person[last_name()] = \"Smith\";\n                       ^\nmain.cpp:7:27: note: candidates are: typename T::value_type&amp; Field&lt;T&gt;::operator[](const T&amp;) [with T = main()::age; typename T::value_type = int]\n   typename T::value_type &amp;operator[](const T &amp;c) {\n                           ^\nmain.cpp:7:27: note:                 typename T::value_type&amp; Field&lt;T&gt;::operator[](const T&amp;) [with T = main()::last_name; typename T::value_type = std::basic_string&lt;char&gt;]\nmain.cpp:23:17: error: request for member \u2018operator[]\u2019 is ambiguous\n     person[age()] = 104;\n                 ^\nmain.cpp:7:27: note: candidates are: typename T::value_type&amp; Field&lt;T&gt;::operator[](const T&amp;) [with T = main()::age; typename T::value_type = int]\n   typename T::value_type &amp;operator[](const T &amp;c) {\n                           ^\nmain.cpp:7:27: note:                 typename T::value_type&amp; Field&lt;T&gt;::operator[](const T&amp;) [with T = main()::last_name; typename T::value_type = std::basic_string&lt;char&gt;]\n</code></pre>\n<p>Why is this ambiguous? </p>\n", "AcceptedAnswerId": "31526228", "Title": "ambiguous operator[] in variadic template", "CreationDate": "2015-07-20T20:09:15.647", "Id": "31525445", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-07-20T21:15:51.037", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-21T10:32:30.323", "Score": "4", "OwnerUserId": "3334460", "Tags": "<c++><c++11><operator-overloading><variadic-templates><ambiguous>", "AnswerCount": "2"}});