post_cb({"bq_ids": {"n4140": {"so_47980682_47980994_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 489}, "so_47980682_47980994_1": {"length": 6, "quality": 1.0, "section_id": 438}}, "n3337": {"so_47980682_47980994_1": {"length": 6, "quality": 1.0, "section_id": 429}, "so_47980682_47980994_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 480}}, "n4659": {"so_47980682_47980994_1": {"length": 6, "quality": 1.0, "section_id": 458}}}, "47980994": {"Id": "47980994", "PostTypeId": "2", "Body": "<p>This is a fairly common pitfall. First let me say that the presence of <code>A</code> is a red herring. You could have made your example shorter by omitting it entirely.</p>\n<p>The reason you don't see <code>B(int)</code> used is due to two clauses in the C++ standard. First <a href=\"https://timsong-cpp.github.io/cppwp/n3337/class.inhctor#8\" rel=\"nofollow noreferrer\">[class.inhctor]/8</a> says:</p>\n<blockquote>\n<p id=\"so_47980682_47980994_0\">An implicitly-defined inheriting constructor performs the set of\n  initializations of the class that would be performed by a user-written\n  inline constructor for that class with a mem-initializer-list whose\n  only mem-initializer has a mem-initializer-id that names the base\n  class denoted in the nested-name-specifier of the using-declaration\n  and an expression-list as specified below, and where the\n  compound-statement in its function body is empty ([class.base.init]).</p>\n</blockquote>\n<p>Which says that the c'tor inherited from <code>D</code> in <code>E</code> is translated to something like this:</p>\n<pre><code>E::E(int i) : D(i) {}\n</code></pre>\n<p>And that is unfortunately your problem. Because upon consulting <a href=\"https://timsong-cpp.github.io/cppwp/n3337/class.base.init#10\" rel=\"nofollow noreferrer\">[class.base.init/10]</a>:</p>\n<blockquote>\n<p id=\"so_47980682_47980994_1\">In a non-delegating constructor, initialization proceeds in the\n  following order:</p>\n<ul>\n<li>First, <strong>and only for the constructor of the most derived class</strong> ([intro.object]), virtual base classes are initialized in the order\n  they appear on a depth-first left-to-right traversal of the directed\n  acyclic graph of base classes, where \u201cleft-to-right\u201d is the order of\n  appearance of the base classes in the derived class\n  base-specifier-list.</li>\n</ul>\n</blockquote>\n<p>We see (emphasis mine) that it is only the most derived c'tor that can and will initialize the virtual base. And how is the most derived c'tor doing that? As we wrote previously. It omits the virtual base from its member initializer list. So the virtual base is <em>default initialized</em>.</p>\n<p>If you want to pass an integer to <code>B</code>'s c'tor. You need to define <code>E</code>'s constructor yourself:</p>\n<pre><code>E::E(int i) : B(i), D(i) {}\n</code></pre>\n", "LastActivityDate": "2017-12-26T16:07:07.190", "Score": "3", "CreationDate": "2017-12-26T16:07:07.190", "ParentId": "47980682", "CommentCount": "4", "OwnerUserId": "817643"}, "47980682": {"ViewCount": "76", "Body": "<p>Running the code below I am expecting to get the following console output:</p>\n<p><code>B int v</code></p>\n<p><code>D</code></p>\n<p>Instead of that, the constructor of E is calling the default constructor of B and the result is:</p>\n<p><code>B</code></p>\n<p><code>D</code> </p>\n<p>One way of achieving the correct construction, is to re-declare the same constructors of D in E (i.e. the commented code part), but I still hope for a better solution than that.</p>\n<p>Ready to run code, with -std=c++11 flag:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A {\npublic:\n  virtual void fun() = 0;\n  virtual void fun2();\n  void fun3();\n};\n\nclass B : public A {\npublic:\n  B();\n  B(int);\n  void fun();\n  void fun2();\n};\n\nclass C : virtual public B {\npublic:\n  using B::B;\n  void fun();\n};\n\nclass D : virtual public B {\npublic:\n  D();\n  D(int);\n  void fun();\n};\n\nclass E : public C, public D {\npublic:\n  using D::D;\n  void fun();\n};\n\nvoid A::fun2() {}\nvoid A::fun3() {}\nB::B() { std::cout &lt;&lt; \"B\\n\"; }\nB::B(int v1) { std::cout &lt;&lt; \"B int v\\n\"; }\nvoid B::fun() {}\nvoid B::fun2() {}\nvoid C::fun() {}\n\nD::D() { std::cout &lt;&lt; \"D\\n\"; }\nD::D(int v1) : B(v1) { std::cout &lt;&lt; \"D\\n\"; }\nvoid D::fun() {}\n\n/*E::E(int v1): D::B(v1){  std::cout &lt;&lt;\"E\\n\";}  */ void E::fun() {}\n\nint main() {\n  E Eob(1);\n  return 0;\n}\n</code></pre>\n<p>Conclusion:\nEventually, defining explicit constructor for E, with an explicit call to the virtual base class B (see commented piece of code), is necessary.</p>\n<p>As Eljay correctly commented in the very first place, I assumed a wrong use of the \"using D::D\". \nThe \"using\" keyword, never redefines constructors for E, which would be similar to that of D; it just calls the constructors of the base class D, and forces the base class D construction. The latter fact, triggers the hierarchy of virtual base classes construction (as StoryTeller replied below) and causes my problems to construct as desired an object of class E.</p>\n", "Title": "Using base constructors with virtual multiple inheritance", "CreationDate": "2017-12-26T15:37:10.240", "LastActivityDate": "2017-12-26T18:04:07.300", "CommentCount": "9", "LastEditDate": "2017-12-26T18:04:07.300", "PostTypeId": "1", "LastEditorUserId": "8623858", "Id": "47980682", "Score": "0", "OwnerUserId": "8623858", "Tags": "<c++><c++11><virtual-inheritance>", "AnswerCount": "1"}});