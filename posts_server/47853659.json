post_cb({"bq_ids": {"n4140": {"so_47853659_47856424_0": {"length": 15, "quality": 0.625, "section_id": 3296}}, "n3337": {"so_47853659_47856424_0": {"length": 15, "quality": 0.625, "section_id": 3166}}, "n4659": {"so_47853659_47856424_0": {"length": 21, "quality": 0.875, "section_id": 4058}}}, "47853659": {"ViewCount": "39", "Body": "<p>Given:</p>\n<pre><code>//C++17\n#include &lt;string&gt;\nstruct Foo {\n    int i;\n    std::string str;\n};\n\nint main() {\n    Foo foo{1, std::string(\"Hello, world!\")};\n}\n</code></pre>\n<p>Can <code>Foo::i</code> and <code>Foo::str</code> be directly initialized from <code>1</code> and <code>std::string(...)</code> instead of being copied into them, and explain why can/can't using C++17 standard(probably some code for testing purpose)?\n<p>If they can't, how many copies are required?</p>\n</p>", "AcceptedAnswerId": "47856424", "Title": "Can copy elision be perfomed in aggregate initialization in c++17?", "CreationDate": "2017-12-17T09:07:39.843", "LastActivityDate": "2017-12-17T15:09:27.427", "CommentCount": "0", "LastEditDate": "2017-12-17T15:09:27.427", "PostTypeId": "1", "LastEditorUserId": "2069064", "Id": "47853659", "Score": "0", "OwnerUserId": "8375400", "Tags": "<c++><c++17><copy-elision><aggregate-initialization>", "AnswerCount": "1"}, "47856424": {"Id": "47856424", "PostTypeId": "2", "Body": "<p>Aggregate initialization basically performs element-wise copy-initialization. So this:</p>\n<pre><code>struct Foo {\n    int i;\n    std::string str;\n};\n\nFoo foo{1, std::string(\"Hello, world!\")};\n</code></pre>\n<p>does the same initializations as:</p>\n<pre><code>int i = 1;\nstd::string str = std::string(\"Hello, world!\");\n</code></pre>\n<p>And we have <a href=\"http://eel.is/c++draft/dcl.init#17.6.1\" rel=\"nofollow noreferrer\">a new rule</a> in C++17 that says that:</p>\n<blockquote>\n<p id=\"so_47853659_47856424_0\">If the initializer expression is a prvalue and the cv-unqualified version of the source type is the same class as the class of the destination, the initializer expression is used to initialize the destination object. <em>[\u2009Example:</em> <code>T x = T(T(T()));</code> calls the <code>T</code> default constructor to initialize <code>x</code>. <em>\u2014\u2009end example\u2009]</em></p>\n</blockquote>\n<p>which means that the second initialization must behave as if you'd written:</p>\n<pre><code>std::string str(\"Hello, world!\");\n</code></pre>\n<p>That is, zero copies. </p>\n<hr/>\n<p>A nice demonstration of the new rule is the following example:</p>\n<pre><code>struct X {\n    X(int ) { }\n    X(X&amp;&amp; ) = delete;\n};\n\nstruct Y {\n    X x;\n};\n\nint main() {\n    Y y{X{4}}; // ill-formed in C++14 due to deleted move ctor\n               // ok in C++17, no move required\n}\n</code></pre>\n", "LastActivityDate": "2017-12-17T15:08:42.263", "CommentCount": "0", "CreationDate": "2017-12-17T15:08:42.263", "ParentId": "47853659", "Score": "4", "OwnerUserId": "2069064"}});