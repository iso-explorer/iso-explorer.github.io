post_cb({"31936418": {"CommentCount": "1", "ViewCount": "227", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-08-11T08:08:46.020", "LastActivityDate": "2015-08-13T01:10:58.580", "Title": "Why less than operator accepts different types of params while std::min not?", "AcceptedAnswerId": "31936552", "LastEditDate": "2017-05-23T10:29:03.170", "Id": "31936418", "Score": "8", "Body": "<pre><code>#include &lt;iostream&gt;\n\nint main(){\n    int a = 1;\n    long long b = 2;\n    std::cout&lt;&lt;(a&lt;b);\n    std::cout&lt;&lt;std::min(a, b);\n    return 0;\n}\n</code></pre>\n<hr>\n<pre><code>&gt; In file included from /usr/include/c++/4.8/bits/char_traits.h:39:0,\n&gt;                  from /usr/include/c++/4.8/ios:40,\n&gt;                  from /usr/include/c++/4.8/ostream:38,\n&gt;                  from /usr/include/c++/4.8/iostream:39,\n&gt;                  from sum_to.cpp:1: /usr/include/c++/4.8/bits/stl_algobase.h:239:5: note: template&lt;class\n&gt; _Tp, class _Compare&gt; const _Tp&amp; std::min(const _Tp&amp;, const _Tp&amp;, _Compare)\n&gt;      min(const _Tp&amp; __a, const _Tp&amp; __b, _Compare __comp)\n&gt;      ^ /usr/include/c++/4.8/bits/stl_algobase.h:239:5: note:   template argument deduction/substitution failed: sum_to.cpp:7:29:\n&gt; note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018int\u2019 and\n&gt; \u2018long long int\u2019)\n&gt;      std::cout&lt;&lt;std::min(a, b);\n\n---\n</code></pre>\n<p>Thanks to <a href=\"https://stackoverflow.com/users/962089/chris\">chris</a> comment in <a href=\"https://stackoverflow.com/questions/31935189/why-this-function-overloading-fails-in-c\">function overloading post</a>\n  Template argument deduction doesn't take conversions into account. One\n  template parameter can't match two types</p>\n<p>So <code>std::min</code> fail.</p>\n<p>Why <code>&lt;</code> would work?</p>\n</hr>", "Tags": "<c++><templates><overloading>", "OwnerUserId": "1392943", "AnswerCount": "5"}, "31936552": {"ParentId": "31936418", "CommentCount": "5", "Body": "<p>Because built-in <code>&lt;</code> applies <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast#Numeric_promotions\" rel=\"noreferrer\">Numeric promotions</a>, and template argument deduction doesn't.</p>\n", "OwnerUserId": "3233393", "PostTypeId": "2", "Id": "31936552", "Score": "7", "CreationDate": "2015-08-11T08:16:13.797", "LastActivityDate": "2015-08-11T08:16:13.797"}, "31936591": {"ParentId": "31936418", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Primitive types don't overload operators, so <em>usual arithmetic conversions</em> are applied and your int is  converted to a long long, and the \"&lt;\" has a valid meaning. </p>\n<p>You can't even overload operators for primitive types:\n<a href=\"https://isocpp.org/wiki/faq/intrinsic-types#intrinsics-and-operator-overloading\" rel=\"nofollow\">https://isocpp.org/wiki/faq/intrinsic-types#intrinsics-and-operator-overloading</a></p>\n<p>Example to show that your int is promoted to long long</p>\n<pre><code>// common_type example\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nint main() {\n\n  typedef std::common_type&lt;int, long long&gt;::type A;           // i\n  std::cout &lt;&lt; \"A: \" &lt;&lt; std::is_same&lt;long long,A&gt;::value &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>Documentation\n<a href=\"http://en.cppreference.com/w/cpp/language/operator_arithmetic\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/operator_arithmetic</a></p>\n<blockquote>\n<p id=\"so_31936418_31936591_0\">For the binary operators (except shifts), if the promoted operands\n  have different types, additional set of implicit conversions is\n  applied, known as usual arithmetic conversions with the goal to\n  produce the common type (also accessible via the std::common_type type\n  trait)</p>\n</blockquote>\n", "OwnerUserId": "1001195", "LastEditorUserId": "1001195", "LastEditDate": "2015-08-11T16:14:43.540", "Id": "31936591", "Score": "-1", "CreationDate": "2015-08-11T08:17:58.290", "LastActivityDate": "2015-08-11T16:14:43.540"}, "31937090": {"ParentId": "31936418", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>As explained in other answers, the reason is that <code>std::min</code> requires the types of the arguments to be identical if deduction is to be performed, while <code>&lt;</code> implies the usual arithmetic conversions (\u00a75.9/2), which will make sure that the types are converted to a \"common denominator\". Note how \u00a713.6/12 lists up built-in operators as candidates:</p>\n<blockquote>\n<p id=\"so_31936418_31937090_0\">For every pair of promoted arithmetic types <code>L</code> and <code>R</code>, there exist\n  candidate operator functions of the form</p>\n<pre><code>// [\u2026]\nLR operator&lt;(L , R );\n// [\u2026]\n</code></pre>\n<p id=\"so_31936418_31937090_1\">where <code>LR</code> is the result of the usual arithmetic conversions between\n  types <code>L</code> and <code>R</code>.</p>\n</blockquote>\n<hr>\n<p>Actually, <code>std::min</code> should be able to deal with distinct types. The following is a more modern approach:</p>\n<pre><code>template &lt;typename T&gt;\nconstexpr decltype(auto) min(T&amp;&amp; t) {return std::forward&lt;T&gt;(t);}\n\ntemplate &lt;typename T, typename U, typename... Args&gt;\nconstexpr auto min(T&amp;&amp; t, U&amp;&amp;u, Args&amp;&amp;... args) {\n    std::common_type_t&lt;T, U&gt; const&amp; _t(std::forward&lt;T&gt;(t)), _u(std::forward&lt;U&gt;(u));\n    return min(_t&lt;_u? _t : _u, std::forward&lt;Args&gt;(args)...);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/cfc0aa669b076932\" rel=\"nofollow\"><strong>Demo</strong></a>.</p>\n</hr>", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-08-11T14:02:35.683", "Id": "31937090", "Score": "3", "CreationDate": "2015-08-11T08:42:28.887", "LastActivityDate": "2015-08-11T14:02:35.683"}, "31936575": {"ParentId": "31936418", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It is because <a href=\"http://www.cplusplus.com/reference/algorithm/min/\" rel=\"nofollow\"><code>std::min</code></a> is a template function.</p>\n<blockquote id=\"so_31936418_31936575_0\">\n<pre><code>template &lt;class T&gt; const T&amp; min (const T&amp; a, const T&amp; b) {\n  return !(b&lt;a)?a:b;     // or: return !comp(b,a)?a:b; for version (2)\n}\n</code></pre>\n</blockquote>\n<p>so it needs the arguments to have the same type, but if you use <code>(a&lt;b)</code>, so <code>a</code> could implicitly converted to a <code>long long</code></p>\n", "OwnerUserId": "1466583", "LastEditorUserId": "1782465", "LastEditDate": "2015-08-11T08:21:24.880", "Id": "31936575", "Score": "2", "CreationDate": "2015-08-11T08:17:19.113", "LastActivityDate": "2015-08-11T08:21:24.880"}, "31936610": {"ParentId": "31936418", "CommentCount": "0", "Body": "<p>The <code>&lt;</code> operator is binary, so the compiler could convert arguments to the same type and compare them.</p>\n<p>Otherwise <code>min</code> function should return something. How could compiler guess which type should he return?</p>\n", "OwnerUserId": "2042587", "PostTypeId": "2", "Id": "31936610", "Score": "-1", "CreationDate": "2015-08-11T08:19:14.500", "LastActivityDate": "2015-08-11T08:19:14.500"}, "bq_ids": {"n4140": {"so_31936418_31937090_1": {"section_id": 686, "quality": 1.0, "length": 7}, "so_31936418_31937090_0": {"section_id": 686, "quality": 0.9166666666666666, "length": 11}, "so_31936418_31936575_0": {"section_id": 6290, "quality": 0.6363636363636364, "length": 7}}, "n3337": {"so_31936418_31937090_1": {"section_id": 676, "quality": 1.0, "length": 7}, "so_31936418_31937090_0": {"section_id": 676, "quality": 0.9166666666666666, "length": 11}, "so_31936418_31936575_0": {"section_id": 6050, "quality": 0.6363636363636364, "length": 7}}, "n4659": {"so_31936418_31937090_1": {"section_id": 715, "quality": 1.0, "length": 7}, "so_31936418_31937090_0": {"section_id": 715, "quality": 0.9166666666666666, "length": 11}, "so_31936418_31936575_0": {"section_id": 7797, "quality": 0.5454545454545454, "length": 6}}}});