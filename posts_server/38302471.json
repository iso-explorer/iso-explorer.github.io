post_cb({"38302863": {"Id": "38302863", "PostTypeId": "2", "Body": "<p>You can <a href=\"http://eel.is/c++draft/func.wrap.func.con#21\" rel=\"nofollow noreferrer\">assign a lambda to a function object</a> of type <code>std::function&lt;R(ArgTypes...)&gt;</code> when the lambda is <a href=\"http://eel.is/c++draft/func.wrap.func#2\" rel=\"nofollow noreferrer\"><em>Lvalue-Callable</em></a> for that signature. In turn, <em>Lvalue-Callable</em> is defined in terms of the <a href=\"http://eel.is/c++draft/func.require#1\" rel=\"nofollow noreferrer\"><em>INVOKE</em> operation</a>, which here means that the lambda has to be callable when it is an lvalue and all its arguments are values of the required types and value categories (as if each argument was the result of calling a nullary function with that argument type as the return type in its signature).</p>\n<p>That is, if you give your lambda an id so that we can refer to its type,</p>\n<pre><code>auto l = [](int i) -&gt; int { cout&lt;&lt;i&lt;&lt;endl; return i; };\n</code></pre>\n<p>To assign it to a <code>function&lt;void(const int&amp;)&gt;</code>, the expression</p>\n<pre><code>static_cast&lt;void&gt;(std::declval&lt;decltype(l)&amp;&gt;()(std::declval&lt;const int&amp;&gt;()))\n</code></pre>\n<p>must be well-formed.</p>\n<p>The result of <code>std::declval&lt;const int&amp;&gt;()</code> is an lvalue reference to <code>const int</code>, but there's no problem binding that to the <code>int</code> argument, since this is just the <a href=\"http://eel.is/c++draft/conv.lval#1\" rel=\"nofollow noreferrer\">lvalue-to-rvalue conversion</a>, which is <a href=\"http://eel.is/c++draft/over.best.ics#tab:over.conversions\" rel=\"nofollow noreferrer\">considered an exact match</a> for the purposes of overload resolution:</p>\n<pre><code>return l(static_cast&lt;int const&amp;&gt;(int{}));\n</code></pre>\n<p>As you've observed, return values are discarded <a href=\"http://eel.is/c++draft/func.require#2\" rel=\"nofollow noreferrer\">if the function object signature has return type <code>void</code></a>; otherwise, the return types have to be implicitly convertible. As Jonathan Wakely points out, C++11 had unsatisfactory behavior on this (<a href=\"https://stackoverflow.com/questions/9339829/using-stdfunctionvoid-to-call-non-void-function?noredirect=1&amp;lq=1\">Using `std::function&lt;void(...)&gt;` to call non-void function</a>; <a href=\"https://stackoverflow.com/questions/25395605/is-it-illegal-to-invoke-a-stdfunctionvoidargs-under-the-standard\">Is it illegal to invoke a std::function&lt;void(Args...)&gt; under the standard?</a>), but it's been fixed since, in <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#2420\" rel=\"nofollow noreferrer\">LWG 2420</a>; the resolution was applied as a post-publication fix to C++14. Most modern C++ compiler will provide the C++14 behavior (as amended) as an extension, even in C++11 mode.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-12T12:30:36.887", "Score": "16", "CreationDate": "2016-07-11T08:57:31.993", "ParentId": "38302471", "CommentCount": "7", "OwnerUserId": "567292", "LastEditDate": "2017-05-23T11:55:16.410"}, "38302471": {"ViewCount": "751", "Body": "<p>I was recently surprised by the fact that lambdas can be assigned to <code>std::function</code>s with <em>slightly different</em> signatures. <em>Slightly different</em> meaning that return values of the lambda might be ignored when the <code>function</code> is specified to return <code>void</code>, or that the parameters might be references in the <code>function</code> but values in the lambda. </p>\n<p>See <a href=\"http://ideone.com/xXXvQz\" rel=\"nofollow noreferrer\">this example (ideone)</a> where I highlighted what I would suspect to be incompatible. I would think that the return value isn't a problem since you can always call a function and ignore the return value, but the conversion from a reference to a value looks strange to me: </p>\n<pre><code>int main() {\n    function&lt;void(const int&amp; i)&gt; f;\n    //       ^^^^ ^^^^^    ^\n    f = [](int i) -&gt; int { cout&lt;&lt;i&lt;&lt;endl; return i; };\n    //     ^^^    ^^^^^^\n    f(2);\n    return 0;\n}\n</code></pre>\n<p>The minor question is: Why does this code compile and work? The major question is: What are the general rules for type conversion of lambda parameters and return values when used together with <code>std::function</code>?</p>\n", "AcceptedAnswerId": "38302863", "Title": "What are the type conversion rules for parameters and return values of lambdas?", "CreationDate": "2016-07-11T08:35:03.450", "Id": "38302471", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-01-02T19:19:33.690", "LastEditorUserId": "1033581", "LastActivityDate": "2017-01-02T19:19:33.690", "Score": "21", "OwnerUserId": "3198247", "Tags": "<c++><c++11><lambda><type-conversion>", "AnswerCount": "4"}, "38304044": {"Id": "38304044", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_38302471_38304044_0\">the conversion from a reference to a value looks strange to me</p>\n</blockquote>\n<p>Why?</p>\n<p>Does this look strange too?</p>\n<pre><code>int foo(int i) { return i; }\n\nvoid bar(const int&amp; ir) { foo(ir); }\n</code></pre>\n<p>This is exactly the same. A function taking an <code>int</code> by value gets called by another function, taking an <code>int</code> by const-reference.</p>\n<p>Inside <code>bar</code> the variable <code>ir</code> gets copied, and the return value gets ignored. That's exactly what happens inside the <code>std::function&lt;void(const int&amp;)&gt;</code> when it has a target with the signature <code>int(int)</code>.</p>\n", "LastActivityDate": "2016-07-11T09:57:57.090", "CommentCount": "0", "CreationDate": "2016-07-11T09:57:57.090", "ParentId": "38302471", "Score": "4", "OwnerUserId": "981959"}, "bq_ids": {"n4140": {"so_38302471_38303037_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 4651}, "so_38302471_38303037_0": {"length": 5, "quality": 0.625, "section_id": 4660}}, "n3337": {"so_38302471_38303037_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 4462}, "so_38302471_38303037_0": {"length": 6, "quality": 0.75, "section_id": 4470}}, "n4659": {"so_38302471_38303037_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 6020}}}, "38303083": {"Id": "38303083", "PostTypeId": "2", "Body": "<p>Just adding to @ecatmur answer, g++/libstd++ just chose to ignore the return value of the <code>callable</code>, it's just as normal as one would do to ignore return value in regular code:</p>\n<pre><code>static void\n_M_invoke(const _Any_data&amp; __functor, _ArgTypes&amp;&amp;... __args)\n{\n   (*_Base::_M_get_pointer(__functor))(  // Gets the pointer to the callable\n           std::forward&lt;_ArgTypes&gt;(__args)...);\n}   \n</code></pre>\n<p>The type trait which explicitly permits this in libstd++ is :</p>\n<pre><code>template&lt;typename _From, typename _To&gt;     \nusing __check_func_return_type = __or_&lt;is_void&lt;_To&gt;, is_convertible&lt;_From, _To&gt;&gt;;\n</code></pre>\n", "LastEditorUserId": "434233", "LastActivityDate": "2016-07-11T09:17:44.637", "Score": "3", "CreationDate": "2016-07-11T09:07:53.590", "ParentId": "38302471", "CommentCount": "0", "OwnerUserId": "434233", "LastEditDate": "2016-07-11T09:17:44.637"}, "38303037": {"Id": "38303037", "PostTypeId": "2", "Body": "<p>The assignment operator is defined to have the effect:</p>\n<pre><code>function(std::forward&lt;F&gt;(f)).swap(*this);\n</code></pre>\n<p>(<em>14882:2011 20.8.11.2.1 par. 18</em>)</p>\n<p>The constructor that this references,</p>\n<pre><code>template &lt;class F&gt; function(F f);\n</code></pre>\n<p>requires:</p>\n<blockquote>\n<p id=\"so_38302471_38303037_0\"><code>F</code> shall be <code>CopyConstructible</code>. <code>f</code> shall be <code>Callable</code> (20.8.11.2) for argument type <code>ArgTypes</code> and return type <code>R</code>.</p>\n</blockquote>\n<p>where <code>Callable</code> is defined as follows:</p>\n<blockquote>\n<p id=\"so_38302471_38303037_1\">A callable object <code>f</code> of type <code>F</code> is <code>Callable</code> for argument types <code>ArgTypes</code> and return type <code>R</code> if the expression <code>INVOKE(f, declval&lt;ArgTypes&gt;()..., R)</code>, considered as an unevaluated operand (Clause 5), is well formed (20.8.2).</p>\n</blockquote>\n<p><code>INVOKE</code>, in turn, is <a href=\"http://eel.is/c++draft/func.require#2\" rel=\"nofollow noreferrer\">defined as</a>:</p>\n<blockquote>\n<ol>\n<li><p id=\"so_38302471_38303037_2\">Define INVOKE(f, t1, t2, ..., tN) as follows:</p>\n<ul>\n<li>... <em>cases for handling member functions omitted here</em> ...</li>\n<li><code>f(t1, t2, ..., tN)</code> in all other cases.</li>\n</ul></li>\n<li><p id=\"so_38302471_38303037_3\">Define <code>INVOKE(f, t1, t2, ..., tN, R)</code> as <code>static_cast&lt;void&gt;(INVOKE(f,\n  t1, t2, ..., tN))</code> if <code>R</code> is <em>cv</em> <code>void</code>, otherwise <code>INVOKE(f, t1, t2, ...,\n  tN)</code> implicitly converted to <code>R</code>.</p></li>\n</ol>\n</blockquote>\n<p>Since the <code>INVOKE</code> definition becomes a plain function call, in this case, the arguments can be <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion\" rel=\"nofollow noreferrer\">converted</a>: If your <code>std::function&lt;void(const int&amp;)&gt;</code> accepts a <code>const int&amp;</code> then it can be converted to an <code>int</code> for the call. The example below compiles with <a href=\"http://coliru.stacked-crooked.com/a/71eff7bcd5a7a20f\" rel=\"nofollow noreferrer\"><code>clang++ -std=c++14 -stdlib=libc++ -Wall -Wconversion</code></a>:</p>\n<pre><code>int main() {\n    std::function&lt;void(const int&amp; i)&gt; f;\n    f = [](int i) -&gt; void { std::cout &lt;&lt; i &lt;&lt; std::endl; };\n    f(2);\n    return 0;\n}\n</code></pre>\n<p>The return type (<code>void</code>) is handled by the <code>static_cast&lt;void&gt;</code> special-case for the <code>INVOKE</code> definition.</p>\n<p>Note, however, that at the time of writing the following generates an error when compiled with <a href=\"http://coliru.stacked-crooked.com/a/1dde24dce2c30b01\" rel=\"nofollow noreferrer\"><code>clang++ -std=c++1z -stdlib=libc++ -Wconversion -Wall</code></a>, but not when compiled with <a href=\"http://coliru.stacked-crooked.com/a/53ea5eb38df0b3bd\" rel=\"nofollow noreferrer\"><code>clang++ -std=c++1z -stdlib=libstdc++ -Wconversion -Wall</code></a>:</p>\n<pre><code>int main() {\n    std::function&lt;void(const int&amp; i)&gt; f;\n    f = [](int i) -&gt; int { std::cout &lt;&lt; i &lt;&lt; std::endl; return i;};\n    f(2);\n    return 0;\n}\n</code></pre>\n<p>This is due to <code>libc++</code> implementing the behaviour as specified in C++14, rather than the <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#2420\" rel=\"nofollow noreferrer\">amended behaviour</a> described above (thanks to @Jonathan Wakely for pointing this out). @Arunmu describes the <code>libstdc++</code> type trait responsible for the same thing in <a href=\"https://stackoverflow.com/a/38303083/3852968\">his post</a>. In this regard, implementations may behave slightly differently when handling callables with <code>void</code> return types, depending on whether they implement C++11, 14, or something newer.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-11T10:48:51.677", "Score": "4", "CreationDate": "2016-07-11T09:05:27.807", "ParentId": "38302471", "CommentCount": "3", "OwnerUserId": "3852968", "LastEditDate": "2017-05-23T10:30:38.347"}});