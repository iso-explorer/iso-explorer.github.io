post_cb({"14127379": {"CommentCount": "4", "AcceptedAnswerId": "14127380", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2013-01-02T18:43:20.413", "LastActivityDate": "2013-05-30T20:53:22.370", "LastEditDate": "2013-01-27T22:17:15.610", "ViewCount": "11117", "FavoriteCount": "55", "Title": "Does const mean thread-safe in C++11?", "Id": "14127379", "Score": "106", "Body": "<p>I hear that <code>const</code> means <em>thread-safe</em> in <em>C++11</em>. Is that true?</p>\n<p>Does that mean <code>const</code> is now the equivalent of <em>Java</em>'s <code>synchronized</code>?</p>\n<p>Are they running out of <em>keywords</em>?</p>\n", "Tags": "<c++><c++11><thread-safety><const><c++-faq>", "OwnerUserId": "927034", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_14127379_14127380_1": {"section_id": 5817, "quality": 0.8823529411764706, "length": 15}, "so_14127379_14127380_3": {"section_id": 6346, "quality": 0.9, "length": 27}, "so_14127379_14127380_2": {"section_id": 5834, "quality": 0.7692307692307693, "length": 20}, "so_14127379_14127380_4": {"section_id": 6348, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_14127379_14127380_1": {"section_id": 5588, "quality": 0.8823529411764706, "length": 15}, "so_14127379_14127380_3": {"section_id": 6103, "quality": 0.9, "length": 27}, "so_14127379_14127380_2": {"section_id": 5605, "quality": 0.8461538461538461, "length": 22}, "so_14127379_14127380_4": {"section_id": 6105, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_14127379_14127380_1": {"section_id": 7278, "quality": 0.8235294117647058, "length": 14}, "so_14127379_14127380_3": {"section_id": 7855, "quality": 0.9, "length": 27}, "so_14127379_14127380_2": {"section_id": 7296, "quality": 0.7692307692307693, "length": 20}, "so_14127379_14127380_4": {"section_id": 7857, "quality": 0.9130434782608695, "length": 21}}}, "14127380": {"ParentId": "14127379", "PostTypeId": "2", "CommentCount": "23", "Body": "<blockquote id=\"so_14127379_14127380_0\">\n<h3>I hear that <code>const</code> means <em>thread-safe</em> in <em>C++11</em>. Is that true?</h3>\n</blockquote>\n<p>It is <strong>somewhat</strong> true...</p>\n<p>This is what the <em>Standard Language</em> has to say on thread-safety:</p>\n<blockquote>\n<p id=\"so_14127379_14127380_1\"><strong><em>[1.10/4]</em></strong>\n  Two expression evaluations <em>conflict</em> if one of them modifies a memory location (1.7) and the other one accesses or modifies the same memory location.</p>\n<p id=\"so_14127379_14127380_2\"><strong><em>[1.10/21]</em></strong>\n  The execution of a program contains a <em>data race</em> if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior.</p>\n</blockquote>\n<p>which is nothing else than the sufficient condition for a <em>data race</em> to occur:</p>\n<ol>\n<li>There are two or more actions being performed at the same time on a given thing; and</li>\n<li>At least one of them is a write.</li>\n</ol>\n<p>The <em>Standard Library</em> builds on that, going a bit further:</p>\n<blockquote>\n<p id=\"so_14127379_14127380_3\"><strong><em>[17.6.5.9/1]</em></strong>\n  This section specifies requirements that implementations shall meet to prevent data races (1.10). Every standard library function shall meet each requirement unless otherwise specified. Implementations may prevent data races in cases other than those specified below.</p>\n<p id=\"so_14127379_14127380_4\"><strong><em>[17.6.5.9/3]</em></strong>\n  A C++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s non-<strong>const</strong> arguments, including <code>this</code>.</p>\n</blockquote>\n<p>which in simple words says that it expects operations on <code>const</code> objects to be <em>thread-safe</em>. This means that the <em>Standard Library</em> won't introduce a data race as long as operations on <code>const</code> objects of your own types either</p>\n<ol>\n<li>Consist entirely of reads --that is, there are no writes--; or</li>\n<li>Internally synchronizes writes.</li>\n</ol>\n<p>If this expectation does not hold for one of your types, then using it directly or indirectly together with any component of the <em>Standard Library</em> may result in a <em>data race</em>. In conclusion, <code>const</code> does mean <em>thread-safe</em> from the <em>Standard Library</em> point of view. It is important to note that this is merely a <em>contract</em> and it won't be enforced by the compiler, if you break it you get <em>undefined behavior</em> and you are on your own. Whether <code>const</code> is present or not will not affect code generation --at least not in respect to <em>data races</em>--.</p>\n<blockquote id=\"so_14127379_14127380_5\">\n<h3>Does that mean <code>const</code> is now the equivalent of <em>Java</em>'s <code>synchronized</code>?</h3>\n</blockquote>\n<p><strong>No</strong>. Not at all...</p>\n<p>Consider the following overly simplified class representing a rectangle:</p>\n<pre><code>class rect {\n    int width = 0, height = 0;\n\npublic:\n    /*...*/\n    void set_size( int new_width, int new_height ) {\n        width = new_width;\n        height = new_height;\n    }\n    int area() const {\n        return width * height;\n    }\n};\n</code></pre>\n<p>The <em>member-function</em> <code>area</code> is <em>thread-safe</em>; not because its <code>const</code>, but because it consist entirely of read operations. There are no writes involved, and at least one write involved is necessary for a <em>data race</em> to occur. That means that you can call <code>area</code> from as many threads as you want and you will get correct results all the time.</p>\n<p>Note that this doesn't mean that <code>rect</code> is <em>thread-safe</em>. In fact, its easy to see how if a call to <code>area</code> were to happen at the same time that a call to <code>set_size</code> on a given <code>rect</code>, then <code>area</code> could end up computing its result based on an old width and a new height (or even on garbled values).</p>\n<p>But that is alright, <code>rect</code> isn't <code>const</code> so its not even expected to be <em>thread-safe</em> after all. An object declared <code>const rect</code>, on the other hand, would be <em>thread-safe</em> since no writes are possible (and if you are considering <code>const_cast</code>-ing something originally declared <code>const</code> then you get <em>undefined-behavior</em> and that's it).</p>\n<blockquote id=\"so_14127379_14127380_6\">\n<h3>So what does it mean then?</h3>\n</blockquote>\n<p>Let's assume --for the sake of argument-- that multiplication operations are extremely costly and we better avoid them when possible. We could compute the area only if it is requested, and then cache it in case it is requested again in the future:</p>\n<pre><code>class rect {\n    int width = 0, height = 0;\n\n    mutable int cached_area = 0;\n    mutable bool cached_area_valid = true;\n\npublic:\n    /*...*/\n    void set_size( int new_width, int new_height ) {\n        cached_area_valid = ( width == new_width &amp;&amp; height == new_height );\n        width = new_width;\n        height = new_height;\n    }\n    int area() const {\n        if( !cached_area_valid ) {\n            cached_area = width;\n            cached_area *= height;\n            cached_area_valid = true;\n        }\n        return cached_area;\n    }\n};\n</code></pre>\n<p>[If this example seems too artificial, you could mentally replace <code>int</code> by a <em>very large dynamically allocated integer</em> which is inherently non <em>thread-safe</em> and for which multiplications are extremely costly.]</p>\n<p>The <em>member-function</em> <code>area</code> is no longer <em>thread-safe</em>, it is doing writes now and is not internally synchronized. Is it a problem? The call to <code>area</code> may happen as part of a <em>copy-constructor</em> of another object, such <em>constructor</em> could have been called by some operation on a <em>standard container</em>, and at that point the <em>standard library</em> expects this operation to behave as a <em>read</em> in regard to <em>data races</em>. But we are doing writes!</p>\n<p>As soon as we put a <code>rect</code> in a <em>standard container</em> --directly or indirectly-- we are entering a <em>contract</em> with the <em>Standard Library</em>. To keep doing writes in a <code>const</code> function while still honoring that contract, we need to internally synchronize those writes:</p>\n<pre><code>class rect {\n    int width = 0, height = 0;\n\n    mutable std::mutex cache_mutex;\n    mutable int cached_area = 0;\n    mutable bool cached_area_valid = true;\n\npublic:\n    /*...*/\n    void set_size( int new_width, int new_height ) {\n        if( new_width != width || new_height != height )\n        {\n            std::lock_guard&lt; std::mutex &gt; guard( cache_mutex );\n\n            cached_area_valid = false;\n        }\n        width = new_width;\n        height = new_height;\n    }\n    int area() const {\n        std::lock_guard&lt; std::mutex &gt; guard( cache_mutex );\n\n        if( !cached_area_valid ) {\n            cached_area = width;\n            cached_area *= height;\n            cached_area_valid = true;\n        }\n        return cached_area;\n    }\n};\n</code></pre>\n<p>Note that we made the <code>area</code> function <em>thread-safe</em>, but the <code>rect</code> still isn't <em>thread-safe</em>. A call to <code>area</code> happening at the same time that a call to <code>set_size</code> may still end up computing the wrong value, since the assignments to <code>width</code> and <code>height</code> are not protected by the mutex.</p>\n<p>If we really wanted a <em>thread-safe</em> <code>rect</code>, we would use a synchronization primitive to protect the <em>non-thread-safe</em> <code>rect</code>.</p>\n<blockquote id=\"so_14127379_14127380_7\">\n<h3>Are they running out of <em>keywords</em>?</h3>\n</blockquote>\n<p>Yes, they are. They have been running out of <em>keywords</em> since day one.</p>\n<hr>\n<p><em>Source</em>: <a href=\"http://isocpp.org/blog/2012/12/you-dont-know-const-and-mutable-herb-sutter\" rel=\"noreferrer\">You don't know <code>const</code> and <code>mutable</code></a> - <em>Herb Sutter</em></p>\n</hr>", "OwnerUserId": "927034", "LastEditorUserId": "927034", "LastEditDate": "2013-05-30T20:53:22.370", "Id": "14127380", "Score": "114", "CreationDate": "2013-01-02T18:43:20.413", "LastActivityDate": "2013-05-30T20:53:22.370"}});