post_cb({"17906171": {"ParentId": "17906131", "CommentCount": "0", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/container/priority_queue/priority_queue\" rel=\"nofollow\">std::priority_queue</a> uses <code>operator&lt;</code> to sort elements by default, it requires elements to be <strong>strict weak ordered</strong></p>\n<p>You need to define <code>operator&lt;</code> function for <code>myData</code> type</p>\n<pre><code>bool operator&lt;(const myData&amp; lhs, const myData&amp; rhs)\n{\n    return lhs.data &lt; rhs.data;\n}\n</code></pre>\n<p>\u00a7 23.6.4.1\n Class template priority_queue</p>\n<blockquote>\n<p id=\"so_17906131_17906171_0\">Any sequence container with random access iterator and supporting operations front(), push_back() and pop_back() can be used to instantiate priority_queue. In particular, vector (23.3.6) and deque (23.3.3) can be used. Instantiating priority_queue also involves supplying a function or function object for mak- ing priority comparisons; the library assumes that the function or function object defines a <strong>strict weak ordering</strong> (25.4).</p>\n</blockquote>\n<p>\u00a7 25.4</p>\n<blockquote>\n<p id=\"so_17906131_17906171_1\">All the operations in 25.4 have two versions: one <strong>that takes a function object of type Compare and one that uses an operator&lt;.</strong></p>\n</blockquote>\n", "OwnerUserId": "951757", "PostTypeId": "2", "Id": "17906171", "Score": "2", "CreationDate": "2013-07-28T07:54:27.217", "LastActivityDate": "2013-07-28T07:54:27.217"}, "17906131": {"CommentCount": "0", "ViewCount": "257", "CreationDate": "2013-07-28T07:48:33.943", "LastActivityDate": "2013-07-28T07:54:54.433", "Title": "std::priority_queue complex types?", "AcceptedAnswerId": "17906171", "PostTypeId": "1", "Id": "17906131", "Score": "0", "Body": "<p>I want to use a std::priority_queue with complex types:</p>\n<pre><code>typedef struct\n{\nuint8_t data;\n    uint64_t moredata;\n}myData;\n\ntypedef struct\n{\n    boost::mutex someQueueLock;\n    std::priority_queue&lt;myData&gt; myQueue; //does not work\n}\n</code></pre>\n<p>I don't want to use a queue full of pointers (priority_queue) because the pointers can get invalid.</p>\n<p>Is this even possible? Or should I use another std container?</p>\n", "Tags": "<c++><data-structures><struct><std><priority-queue>", "OwnerUserId": "2550815", "AnswerCount": "2"}, "17906175": {"ParentId": "17906131", "CommentCount": "0", "Body": "<p>You need to define your own comparison function, so that the priority_queue will know which items have higher priority.</p>\n<pre><code>bool MyCompare(const myData&amp; left, const myData&amp; right)\n{\n    // todo: return true if left has higher priority than right\n}\n\nstd::priority_queue&lt;myData, std::vector&lt;myData&gt;, MyCompare&gt; queue;\n</code></pre>\n", "OwnerUserId": "532057", "PostTypeId": "2", "Id": "17906175", "Score": "1", "CreationDate": "2013-07-28T07:54:54.433", "LastActivityDate": "2013-07-28T07:54:54.433"}, "bq_ids": {"n4140": {"so_17906131_17906171_0": {"section_id": 1113, "quality": 0.8571428571428571, "length": 36}, "so_17906131_17906171_1": {"section_id": 1393, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_17906131_17906171_0": {"section_id": 1110, "quality": 0.8571428571428571, "length": 36}, "so_17906131_17906171_1": {"section_id": 1387, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_17906131_17906171_0": {"section_id": 1204, "quality": 0.8571428571428571, "length": 36}, "so_17906131_17906171_1": {"section_id": 1511, "quality": 0.9333333333333333, "length": 14}}}});