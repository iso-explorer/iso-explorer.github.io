post_cb({"9435534": {"ParentId": "9435108", "CommentCount": "1", "Body": "<p>Templates in C++ are compiled during compile time using the concrete types. They have to be known.</p>\n<p>This said you can go a bit further with your partial solution by passing a function template which arguments can be deduced. Note that this is no different then explicitly passing function with concrete types you just have to type less.</p>\n<pre><code>template&lt;typename T&gt;\nT square(T a, T b)\n{\n    return a * b;\n}\n\ntemplate&lt;typename T, T (*some_function)(T, T)&gt;\nT test(T a) \n{\n   return square (a, a);\n}\n\nvoid main()\n{\n    int a = test&lt;int, square&gt;(2);\n    float b = test&lt;float, square&gt;(2.2f);\n}\n</code></pre>\n", "OwnerUserId": "257311", "PostTypeId": "2", "Id": "9435534", "Score": "1", "CreationDate": "2012-02-24T17:49:37.167", "LastActivityDate": "2012-02-24T17:49:37.167"}, "9435108": {"CommentCount": "0", "ViewCount": "250", "PostTypeId": "1", "LastEditorUserId": "760091", "CreationDate": "2012-02-24T17:18:15.290", "LastActivityDate": "2012-02-24T18:35:31.120", "Title": "Is it possible to pass a function template as a template argument?", "AcceptedAnswerId": "9435234", "LastEditDate": "2012-02-24T18:35:31.120", "Id": "9435108", "Score": "10", "Body": "<p>Let's asssume, that we have a template funcion:</p>\n<pre><code>template&lt;typename T1, typename T2, typename T3&gt;\nT3 such_fun(T1 a, T2 b) {\n    // do something...\n}\n</code></pre>\n<p>and now we want to use it as an argument in another template, e.g. like that</p>\n<pre><code>template&lt;typename T1, template&lt;typename, typename, typename&gt; some_function&gt;\nvoid big_fun(T1 a) {\n   // some code...\n   a = some_function&lt;T1, T1, T1&gt;(a, a);\n   // some code...\n}\n</code></pre>\n<p>Is it possible?</p>\n<p>I know that I can use a struct with defined () operator. I'm just curious about functions.</p>\n<p><strong>EDIT:</strong></p>\n<p>While I was writing that question my friend found a partial solution:</p>\n<pre><code>template&lt;typename T1, T1 (*some_function)(T1, T1)&gt;\nvoid big_fun(T1 a) {\n   // some code...\n   a = some_function(a, a);\n   // some code...\n}\n</code></pre>\n<p>But still - I'm curious if it's possible without a materialization of a function type before call. For example - I may want to call the passed template with various types combinations:</p>\n<pre><code>template&lt;typename T1, typename T2, template&lt;typename, typename, typename&gt; some_function&gt;\nvoid big_fun(T1 a, T2 b) {\n   // some code...\n   a = some_function&lt;T1, T1, T1&gt;(a, a);\n   a = some_function&lt;T1, T2, T1&gt;(a, b);\n   b = some_function&lt;T2, T2, T2&gt;(b, b);\n   b = some_function&lt;T2, T1, T2&gt;(b, a);\n   // some code...\n}\n</code></pre>\n", "Tags": "<c++><templates><template-meta-programming>", "OwnerUserId": "760091", "AnswerCount": "3"}, "9435717": {"ParentId": "9435108", "CommentCount": "3", "Body": "<p>As long as <code>template&lt; typename T1, typename T2, typename T3&gt; someTemplate</code> evaluates to some actual class without errors you can use it with as much combinations as you want, out and inside other templates. </p>\n<p>Have you tried to compile it? Show us what error do you get (and concrete sample)</p>\n", "OwnerUserId": "170521", "PostTypeId": "2", "Id": "9435717", "Score": "0", "CreationDate": "2012-02-24T18:02:56.363", "LastActivityDate": "2012-02-24T18:02:56.363"}, "bq_ids": {"n4140": {"so_9435108_9435234_0": {"section_id": 92, "quality": 1.0, "length": 35}}, "n3337": {"so_9435108_9435234_0": {"section_id": 87, "quality": 1.0, "length": 35}}, "n4659": {"so_9435108_9435234_0": {"section_id": 95, "quality": 1.0, "length": 35}}}, "9435234": {"ParentId": "9435108", "CommentCount": "7", "Body": "<p>No, this is not possible. From 14.3.3 in N3337:</p>\n<blockquote>\n<p id=\"so_9435108_9435234_0\">A template-argument for a template template-parameter shall be the\n  name of a class template or an alias template, expressed as\n  id-expression . When the template-argument names a class template,\n  only primary class templates are considered when matching the template\n  template argument with the corresponding parameter; partial\n  specializations are not considered even if their parameter lists match\n  that of the template template parameter.</p>\n</blockquote>\n<p>The first paragraph only mentions class templates explicitly. I guess it's also not really worth the trouble given that you can do something very similar already with functions or a <code>std::function</code> as an argument.</p>\n", "OwnerUserId": "105672", "PostTypeId": "2", "Id": "9435234", "Score": "8", "CreationDate": "2012-02-24T17:27:52.327", "LastActivityDate": "2012-02-24T17:27:52.327"}});