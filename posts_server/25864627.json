post_cb({"25864754": {"Id": "25864754", "PostTypeId": "2", "Body": "<p>Yes, 100% valid. This is just fine, in fact, appreciated.</p>\n<pre><code>enum RxqType\n{\n    A = (1 &lt;&lt; 0),\n    B = (1 &lt;&lt; 1),\n    C = (A | B),\n    D = A+B+C\n};\n</code></pre>\n", "LastActivityDate": "2014-09-16T09:07:48.687", "CommentCount": "1", "CreationDate": "2014-09-16T09:07:48.687", "ParentId": "25864627", "Score": "-3", "OwnerUserId": "2032021"}, "25864690": {"Id": "25864690", "PostTypeId": "2", "Body": "<pre><code>enum RxqType\n{\n    A = (1 &lt;&lt; 0),\n    B = (1 &lt;&lt; 1),\n    C = (A | B),\n    D = A+B+C\n};\n</code></pre>\n<p>In C and in  C++ this is valid.</p>\n<p>For C:</p>\n<blockquote>\n<p id=\"so_25864627_25864690_0\">(C11, 6.2.1p7) \"Each enumeration constant has scope that begins just after the appearance of its defining enumerator in an enumerator list.\"</p>\n</blockquote>\n<p>For C++:</p>\n<blockquote>\n<p id=\"so_25864627_25864690_1\">(C++11, 3.3.2p4) \"The point of declaration for an enumerator is immediately after its enumerator-definition.\"</p>\n</blockquote>\n", "LastEditorUserId": "1119701", "LastActivityDate": "2014-09-16T09:13:50.853", "Score": "21", "CreationDate": "2014-09-16T09:04:48.173", "ParentId": "25864627", "CommentCount": "0", "OwnerUserId": "1119701", "LastEditDate": "2014-09-16T09:13:50.853"}, "25874476": {"Id": "25874476", "PostTypeId": "2", "Body": "<p>Although as noted already, it is perfectly valid, there is one thing you have to look out for: while an enumeration type is being defined, in C++, the already-declared enumerators may not have the exact type you're expecting. As a result, something like</p>\n<pre><code>enum E {\n  a = INT_MAX,\n  b = UINT_MAX,\n  c = a + 1, // error: overflow\n};\n</code></pre>\n<p>is not valid, even though this is:</p>\n<pre><code>enum E {\n  a = INT_MAX,\n  b = UINT_MAX,\n};\nenum E2 {\n  c = a + 1, // okay: a is promoted to unsigned int\n};\n</code></pre>\n<p>For a similar example, overload resolution may not behave like you would expect:</p>\n<pre><code>char f(int);\ntemplate &lt;typename T&gt;\nchar (&amp;f(T))[2];\n\nenum E {\n  a = 0,\n  b = sizeof(f(a)), // 1\n};\nenum E2 {\n  c = sizeof(f(a)), // 2\n};\n</code></pre>\n<p>There are other similar examples that are somewhat unintuitive.</p>\n<p>For C, the rules are a bit simpler. In C, an enumeration constant's type is independent of the enumeration type, so my example of <code>a + 1</code> is invalid even with the <code>E2</code>. This does lead do consistent results.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2014-09-16T17:02:35.840", "Score": "1", "CreationDate": "2014-09-16T16:57:34.653", "ParentId": "25864627", "CommentCount": "0", "OwnerUserId": "743382", "LastEditDate": "2014-09-16T17:02:35.840"}, "bq_ids": {"n4140": {"so_25864627_25864755_1": {"length": 15, "quality": 0.9375, "section_id": 7051}, "so_25864627_25864690_1": {"length": 7, "quality": 0.7, "section_id": 7053}}, "n3337": {"so_25864627_25864690_1": {"length": 7, "quality": 0.7, "section_id": 6797}, "so_25864627_25864755_1": {"length": 15, "quality": 0.9375, "section_id": 6796}}, "n4659": {"so_25864627_25864690_1": {"length": 7, "quality": 0.7, "section_id": 8550}, "so_25864627_25864755_1": {"length": 15, "quality": 0.9375, "section_id": 8548}}}, "25864627": {"ViewCount": "714", "Body": "<p>For the sake of curiosity, I am experimenting this:</p>\n<pre><code>enum RxqType\n{\n    A = (1 &lt;&lt; 0),\n    B = (1 &lt;&lt; 1),\n    C = (A | B),\n    D = A+B+C\n};\n</code></pre>\n<p>Enumerator C and D are defined in terms of earlier enumerators. It is unusual so I am not sure whether it is safe. I can find no example about it through Google (maybe overlook though).</p>\n<p>It seems to be fine when I <code>printf</code> or <code>cout</code> <code>C</code> and <code>D</code> on Visual C++ 2013 and MinGW. But I am worrying whether it is standard conforming, and whether it triggers undefined behaviours.</p>\n<p>Can anyone answer to my worry about standard conformance and undefined behaviour? And is there anything else I have to concern?</p>\n", "AcceptedAnswerId": "25864690", "Title": "Can an enumerator be defined in terms of other enumerators within the same enum type?", "CreationDate": "2014-09-16T09:02:04.087", "Id": "25864627", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-09-16T17:02:35.840", "Score": "21", "OwnerUserId": "2486888", "Tags": "<c++><c><enums>", "AnswerCount": "4"}, "25864755": {"Id": "25864755", "PostTypeId": "2", "Body": "<p>Yes, this is covered in the draft C99 standard section <code>6.2.1</code> <em>Scopes of identifiers</em> which which tells us each enumerator is in scope after it is defined:</p>\n<blockquote>\n<p id=\"so_25864627_25864755_0\">Each enumeration constant has scope that\n  begins just after the appearance of its defining enumerator in an enumerator list.</p>\n</blockquote>\n<p>This is covered in the draft C++ standard section <code>3.3.2</code> <em>Point of declaration</em> which says:</p>\n<blockquote>\n<p id=\"so_25864627_25864755_1\">The point of declaration\n  for an enumeration is immediately after the identifier (if any) in either its enum-specifier (7.2) or its first\n  opaque-enum-declaration (7.2), whichever comes first.</p>\n</blockquote>\n<p>and for completeness sake we can go to section <code>6.7.2.2</code> <em>Enumeration specifiers</em> of the draft C99 standard,  which tells us an enumerator can be set by a constant expression and an enumerator itself is a constant expression. </p>\n<pre><code>enumerator:\n    enumeration-constant\n    enumeration-constant = constant-expression\n</code></pre>\n<p>What are constant expression is covered in section <code>6.6</code> <em>Constant expressions</em> and it tells us that enumerators are constants and also that arithmetic expressions of integer constants are also constant expressions.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-09-16T09:35:07.247", "Score": "5", "CreationDate": "2014-09-16T09:07:59.030", "ParentId": "25864627", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-09-16T09:35:07.247"}});