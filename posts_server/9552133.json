post_cb({"bq_ids": {"n4140": {"so_9552133_12919036_11": {"length": 6, "quality": 0.8571428571428571, "section_id": 1186}, "so_9552133_12919036_9": {"length": 20, "quality": 0.8, "section_id": 5834}, "so_9552133_12919036_4": {"length": 6, "quality": 0.75, "section_id": 1188}, "so_9552133_12919036_5": {"length": 12, "quality": 0.9230769230769231, "section_id": 1189}}, "n3337": {"so_9552133_12919036_11": {"length": 6, "quality": 0.8571428571428571, "section_id": 1184}, "so_9552133_12919036_9": {"length": 22, "quality": 0.88, "section_id": 5605}, "so_9552133_12919036_4": {"length": 6, "quality": 0.75, "section_id": 1186}, "so_9552133_12919036_5": {"length": 12, "quality": 0.9230769230769231, "section_id": 1187}}, "n4659": {"so_9552133_12919036_11": {"length": 5, "quality": 0.7142857142857143, "section_id": 1268}, "so_9552133_12919036_9": {"length": 20, "quality": 0.8, "section_id": 7296}, "so_9552133_12919036_4": {"length": 6, "quality": 0.75, "section_id": 1269}, "so_9552133_12919036_5": {"length": 11, "quality": 0.8461538461538461, "section_id": 1270}}}, "9552133": {"ViewCount": "2606", "Body": "<p>I am trying to use std::atomic library. </p>\n<ol>\n<li>What's the difference between <strong>specialized</strong> and <strong>non-specialized</strong> atomic\nmember functions?</li>\n<li>What's the difference (if there is any) between following functions?</li>\n<li><strong>operator=</strong> stores a value into an atomic object (public member function) v.s. <strong>store</strong>  (C++11) atomically replaces the value of the atomic object with a non-atomic argument (public member function)</li>\n<li><strong>operator T()</strong> loads a value from an atomic object (public member function) v.s. <strong>load</strong>  (C++11) atomically obtains the value of the atomic object (public member function).</li>\n<li><strong>operator+=</strong> v.s. <strong>fetch_add</strong></li>\n<li><strong>operator-=</strong> v.s. <strong>fetch_sub</strong></li>\n<li><strong>operator&amp;=</strong> v.s. <strong>fetch_and</strong></li>\n<li><strong>operator|=</strong> v.s. <strong>fetch_or</strong></li>\n<li><strong>operator^=</strong> v.s. <strong>fetch_xor</strong></li>\n<li>What's the downside of declare a variable as atomic v.s. a\n non-atomic variable. For example, what's the downside of\n <code>std::atomic&lt;int&gt; x</code> v.s. <code>int x</code>? In other words, how much is the overhead of an atomic variable?</li>\n<li>Which one has more overhead? An atomic variable, v.s. a normal\n variable protected by a mutex?</li>\n</ol>\n<p>Here is the reference to my quesitons. <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/atomic/atomic</a></p>\n", "AcceptedAnswerId": "9552371", "Title": "c++, c++11, std::atomic member functions", "CreationDate": "2012-03-04T03:45:55.210", "Id": "9552133", "CommentCount": "1", "LastEditDate": "2012-03-04T09:13:14.430", "PostTypeId": "1", "LastEditorUserId": "597607", "LastActivityDate": "2012-11-05T11:32:57.480", "Score": "10", "OwnerUserId": "1191316", "Tags": "<c++><c++11><atomic>", "AnswerCount": "3"}, "9552371": {"Id": "9552371", "PostTypeId": "2", "Body": "<p>Not an expert, but I'll try:</p>\n<ol>\n<li>The specializations (for built-in types such as <code>int</code>) contain additional operations such as <code>fetch_add</code>. Non-specialized forms (user defined types) will not contain these.</li>\n<li><code>operator=</code> returns its argument, <code>store</code> does not. Also, non-operators allow you to specify a memory order. The standard says <code>operator=</code> is defined in terms of <code>store</code>.</li>\n<li>Same as above, although it returns the value of <code>load</code>.</li>\n<li>Same as above</li>\n<li>Same as above</li>\n<li>Same as above</li>\n<li>Same as above</li>\n<li>Same as above</li>\n<li>Same as above</li>\n<li>They do different things. It's undefined behavior to use an <code>int</code> in the way you would use <code>std::atomic_int</code>.</li>\n<li>You can assume the overhead is <code>int &lt;= std::atomic &lt;= int and std::mutex</code> where <code>&lt;=</code> means 'less overhead'. So it's likely better than locking with a mutex (especially for built-in types), but worse than <code>int</code>.</li>\n</ol>\n", "LastEditorUserId": "560648", "LastActivityDate": "2012-11-05T11:32:57.480", "Score": "10", "CreationDate": "2012-03-04T04:42:11.057", "ParentId": "9552133", "CommentCount": "3", "OwnerUserId": "964135", "LastEditDate": "2012-11-05T11:32:57.480"}, "9552322": {"Id": "9552322", "PostTypeId": "2", "Body": "<p>I'm not an expert on this stuff, but if I understand correctly the non-specialized operations in your reference do one thing atomically, load, store, replace, etc.</p>\n<p>The specialized function do two things atomically, that is they modify and then return an atomic object in such a way that both operations happen before any other thread could mess with them.</p>\n", "LastActivityDate": "2012-03-04T04:29:34.770", "CommentCount": "0", "CreationDate": "2012-03-04T04:29:34.770", "ParentId": "9552133", "Score": "0", "OwnerUserId": "15079"}, "12919036": {"Id": "12919036", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_9552133_12919036_0\">What's the difference between specialized and non-specialized atomic member functions?</p>\n</blockquote>\n<p>As can be seen in the synposis of these classes on the standard (\u00a729.5), there are three different sets of member functions:</p>\n<ul>\n<li>the most generic one provides only store, load, exchange, and compare-exchange operations;</li>\n<li>the specializations for integral types provide atomic arithmetic and bitwise operations, in addition to the generic ones;</li>\n<li>the specialization for pointers provides pointer arithmetic operations in addition to the generic ones.</li>\n</ul>\n<blockquote>\n<p id=\"so_9552133_12919036_1\">What's the difference (if there is any) between following functions?</p>\n<p id=\"so_9552133_12919036_2\"><code>operator=</code> stores a value into an atomic object (public member function) v.s. <code>store</code> (C++11) atomically replaces the value of the atomic object with a non-atomic argument (public member function)</p>\n<p id=\"so_9552133_12919036_3\">(...)</p>\n</blockquote>\n<p>The main functional difference is that the non-operator versions (\u00a729.6.5, paragraphs 9-17 and more) have an extra parameter for specifying the desired memory ordering (\u00a729.3/1). The operator versions use the sequential consistency memory ordering:</p>\n<blockquote>\n<pre><code>void A::store(C desired, memory_order order = memory_order_seq_cst) volatile noexcept;\nvoid A::store(C desired, memory_order order = memory_order_seq_cst) noexcept;\n</code></pre>\n<p id=\"so_9552133_12919036_4\"><em>Requires:</em> The order argument shall not be <code>memory_order_consume</code>, <code>memory_order_acquire</code>, nor <code>memory_order_acq_rel</code>.</p>\n<p id=\"so_9552133_12919036_5\"><em>Effects:</em> Atomically replaces the value pointed to by object or by this with the value of desired. Memory is affected according to the\n  value of <code>order</code>.</p>\n<pre><code>C A::operator=(C desired) volatile noexcept;\nC A::operator=(C desired) noexcept;\n</code></pre>\n<p id=\"so_9552133_12919036_6\"><em>Effects:</em> <code>store(desired)</code></p>\n<p id=\"so_9552133_12919036_7\"><em>Returns:</em> <code>desired</code></p>\n</blockquote>\n<p>The non-operator forms are advantageous because sequential consistency is not always necessary, and it is potentially more expensive than the other memory orderings. With careful analysis one can find out what are the minimal guarantees needed for correct operation and select one of the less restrictive memory orderings, giving more leeway to the optimizer.</p>\n<blockquote>\n<p id=\"so_9552133_12919036_8\">What's the downside of declare a variable as atomic v.s. a non-atomic variable. For example, what's the downside of <code>std::atomic&lt;int&gt; x</code> v.s. <code>int x</code>? In other words, how much is the overhead of an atomic variable?</p>\n</blockquote>\n<p>Using an atomic variable when a regular variable would suffice limits the number of possible optimizations, because atomic variables impose additional constraints of indivisibility and (possibly) memory ordering.</p>\n<p>Using a regular variable when an atomic variable is needed may introduce data races, and that makes the behaviour undefined (\u00a71.10/21):</p>\n<blockquote>\n<p id=\"so_9552133_12919036_9\">The execution of a program contains a <em>data race</em> if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior.</p>\n</blockquote>\n<p>The overhead of an atomic variable is a matter of quality of implementation. Ideally, an atomic variable has zero overhead when you need atomic operations. When you don't need atomic operations, whatever overhead it may have is irrelevant: you just use a regular variable.</p>\n<blockquote>\n<p id=\"so_9552133_12919036_10\">Which one has more overhead? An atomic variable, v.s. a normal variable protected by a mutex?</p>\n</blockquote>\n<p>There's no reason for an atomic variable to have more overhead than a normal variable protected by a mutex: worst case scenario, the atomic variable is implemented just like that. But there is a possibility that the atomic variable is lock-free, which would involve less overhead. This property can be ascertained with the functions described in the standard in \u00a729.6.5/7:</p>\n<blockquote>\n<pre><code>bool atomic_is_lock_free(const volatile A *object) noexcept;\nbool atomic_is_lock_free(const A *object) noexcept;\nbool A::is_lock_free() const volatile noexcept;\nbool A::is_lock_free() const noexcept;\n</code></pre>\n<p id=\"so_9552133_12919036_11\"><em>Returns:</em> True if the object\u2019s operations are lock-free, false otherwise.</p>\n</blockquote>\n", "LastActivityDate": "2012-10-16T16:14:25.130", "CommentCount": "0", "CreationDate": "2012-10-16T16:14:25.130", "ParentId": "9552133", "Score": "9", "OwnerUserId": "46642"}});