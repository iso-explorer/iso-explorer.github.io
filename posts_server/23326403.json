post_cb({"23326404": {"ParentId": "23326403", "CommentCount": "0", "CreationDate": "2014-04-27T08:53:53.050", "OwnerUserId": "3578084", "Id": "23326404", "PostTypeId": "2", "OwnerDisplayName": "jblume", "Score": "2", "Body": "<p>I think I figured this out myself. In \u00a714.7.2.11 the standard says</p>\n<blockquote>\n<p id=\"so_23326403_23326404_0\">If an entity is the subject of both an explicit instantiation declaration and an explicit\n  instantiation definition in the same translation unit, the definition shall follow the \n  declaration.</p>\n</blockquote>\n<p>which is probably what IntelliSense refers to. And this is where I noticed that the error message says \"...cannot follow <em>explicit</em> instantiation...\". There is obviously no explicit instantiation anywhere, just an <em>implicit</em> instantiation inside the class definition of <code>widget</code>. So I assume that this is a bug inside IntelliSense. Inside the same paragraph, the standard says</p>\n<blockquote>\n<p id=\"so_23326403_23326404_1\">An entity that is the subject of an explicit instantiation declaration and that is also\n  used in a way that would otherwise cause an implicit instantiation (14.7.1) in the\n  translation unit shall be the subject of an explicit instantiation definition some-\n  where in the program; otherwise the program is ill-formed, no diagnostic required.</p>\n</blockquote>\n<p>which does not require any specific order of (potential) implicit instantiation and explicit instantiation declaration.</p>\n<p>At this point I also realized that my solution is actually overkill for my original problem. I did not want to prevent the implicit instantiation of both the template class <em>declaration</em> and <em>definition</em> of <code>pimpl&lt;impl&gt;</code>, but only the template class <em>definition</em> inside <code>pimpl_impl.h</code>. The <code>extern template pimpl&lt;impl&gt;</code> suppressed both, which solved my problem but does more than necessary. The solution is to declare the actual members of <code>pimpl&lt;impl&gt;</code> with <code>extern template</code> and explicitly instantiate them later.</p>\n", "LastActivityDate": "2014-04-27T10:33:19.747"}, "23326403": {"CommentCount": "0", "ViewCount": "453", "OwnerDisplayName": "jblume", "CreationDate": "2014-04-25T21:00:26.533", "LastActivityDate": "2014-04-27T17:12:00.680", "PostTypeId": "1", "AcceptedAnswerId": "23326404", "Title": "How to use \"extern template\" with a nested class which is used by a templated member in the same class?", "Id": "23326403", "Score": "3", "Body": "<p>First, some context: I'm trying to use the Pimpl idiom in the way Herb Sutter presented it in the solution to his <a href=\"http://herbsutter.com/gotw/_101/\" rel=\"nofollow\">GotW #101</a>. This would look like this in the header file:</p>\n<pre><code>#include \"pimpl_h.h\"\nclass widget {\n    class impl;\n    pimpl&lt;impl&gt; m;\n    // ...\n};\n</code></pre>\n<p>The implementation would look like this:</p>\n<pre><code>#include \"pimpl_impl.h\"\nclass widget::impl {\n    // ...\n};\n</code></pre>\n<p>The problem I am trying to solve appears when a class using this technique uses another Pimpl class for their own implementation. It includes the \"pimpl_impl.h\", so the compiler (in my case VC++ 2013) gains knowledge of the concrete template for <code>pimpl &lt;impl&gt;</code> of the other class and tries to implicitly instantiate it, which of course results in compilation errors as it does not know about the implementation of that class.</p>\n<p>To solve this, I have used the new \"extern template\" feature of C++ 11 in the header:</p>\n<pre><code>#include \"pimpl_h.h\"\nclass widget {\n    class impl;\n    pimpl&lt;impl&gt; m;\n    // ...\n};\nextern template pimpl&lt;widget::impl&gt;;\n</code></pre>\n<p>This should guarantee that only the explicit instantiation I have in the compilation unit providing the implementation of <code>widget::impl</code> leads to an actual instantiation. This compiles without a problem, but IntelliSense shows me an error:</p>\n<pre><code>Error: 'extern template' cannot follow explicit instantiation of class \"pimpl&lt;widget::impl&gt;\"\n</code></pre>\n<p>As \"extern template\" cannot be used inside of a class declaration, I cannot write</p>\n<pre><code>#include \"pimpl_h.h\"\nclass widget {\n    class impl;\n    extern template pimpl&lt;impl&gt;;\n    pimpl&lt;impl&gt; m;\n    // ...\n};\n</code></pre>\n<p>and I can't think of any other way. My question is:</p>\n<p>Is IntelliSense wrong and the compiler right in accepting my code? Or is it just coincidence that VC++ compiles this and it isn't valid C++?</p>\n<p>If my solution is not valid C++, what alternatives do I have?</p>\n", "Tags": "<c++><c++11><templates>", "OwnerUserId": "3578084", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_23326403_23326404_1": {"section_id": 260, "quality": 0.88, "length": 22}, "so_23326403_23326404_0": {"section_id": 260, "quality": 1.0, "length": 15}}, "n3337": {"so_23326403_23326404_1": {"section_id": 251, "quality": 0.88, "length": 22}, "so_23326403_23326404_0": {"section_id": 251, "quality": 1.0, "length": 15}}, "n4659": {"so_23326403_23326404_0": {"section_id": 267, "quality": 1.0, "length": 15}, "so_23326403_23326404_1": {"section_id": 267, "quality": 0.88, "length": 22}}}});