post_cb({"bq_ids": {"n4140": {"so_24381523_24381563_0": {"length": 14, "quality": 0.875, "section_id": 6161}}, "n3337": {"so_24381523_24381563_0": {"length": 14, "quality": 0.875, "section_id": 5922}}, "n4659": {"so_24381523_24381563_0": {"length": 14, "quality": 0.875, "section_id": 7658}}}, "24381523": {"ViewCount": "882", "Body": "<p>I wrote the following two lines :</p>\n<p>Line 1 :</p>\n<pre><code>int a;\na=a^a;\n</code></pre>\n<p>Line 2 :</p>\n<pre><code>double d;\nd=d^d;\n</code></pre>\n<p>Line 1 Works Fine But Line 2 Gives Me Error :</p>\n<pre><code>error: invalid operands of types \u2018double\u2019 and \u2018double\u2019 to binary \u2018operator^\u2019\n</code></pre>\n<p>Can Somebody tell me why the bit-wise <strong>XOR operator</strong> works on two <strong>int</strong> but doesn't work on two <strong>double</strong> variables...??</p>\n<p>Seems like a silly doubt...but i really couldn't get through my program without this...!</p>\n", "AcceptedAnswerId": "24381563", "Title": "XORing two double variables", "CreationDate": "2014-06-24T08:13:10.740", "Id": "24381523", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2017-01-10T20:44:32.183", "Score": "3", "OwnerUserId": "3751615", "Tags": "<c++><double><xor>", "AnswerCount": "3"}, "24381622": {"Id": "24381622", "PostTypeId": "2", "Body": "<p>Because XOR, like other boolean bitwise operators is defined for binary operations, e.g. <code>0b10^0b01 = 0b11</code> but that doesn't make sense for anything where the representation is different from the value. If you XOR <code>4.0</code> and <code>1.0</code> should you get the XOR of the value, i.e. <code>5.0</code> or a bitwise XOR of the representation. If the former what do you do with values where the precision doesn't fully overlap e.g. '1.89e92<code>and</code>0.01`? Whilst the latter is difficult to even define (and likely meaningless) since the C++ standard doesn't define exactly how the double is represented and it may be represented differently during calculation and storage.</p>\n", "LastActivityDate": "2014-06-24T08:19:36.077", "CommentCount": "4", "CreationDate": "2014-06-24T08:19:36.077", "ParentId": "24381523", "Score": "1", "OwnerUserId": "1502345"}, "24381563": {"Id": "24381563", "PostTypeId": "2", "Body": "<p>Because the standard says so.</p>\n<blockquote>\n<h3>C++11 \u00a75.12 Bitwise exclusive OR operator</h3>\n<p id=\"so_24381523_24381563_0\">The usual arithmetic conversions are performed; the result is the bitwise exclusive OR function of the operands. <strong>The operator applies only to integral or enumeration operands.</strong></p>\n</blockquote>\n<p>And it doesn't make much sense to xor two <code>double</code>s, in my opinion.</p>\n", "LastActivityDate": "2014-06-24T08:15:57.597", "CommentCount": "1", "CreationDate": "2014-06-24T08:15:57.597", "ParentId": "24381523", "Score": "3", "OwnerUserId": "1009479"}, "41578052": {"Id": "41578052", "PostTypeId": "2", "Body": "<p>xor'ing is the easiest way to interchange two values (integers, IEEE standard or any other) without using temporary registers. I don't understand how today's programmers get through school without understand the simplest concepts of 50 years ago.</p>\n<pre><code>int a, b;\na=a^b;\nb=a^b;\na=a^b;\n</code></pre>\n", "LastActivityDate": "2017-01-10T20:44:32.183", "CommentCount": "0", "CreationDate": "2017-01-10T20:44:32.183", "ParentId": "24381523", "Score": "1", "OwnerUserId": "7401464"}});