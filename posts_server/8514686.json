post_cb({"bq_ids": {"n4140": {"so_8514686_8514899_0": {"length": 31, "quality": 0.8611111111111112, "section_id": 5485}}, "n3337": {"so_8514686_8514899_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 5271}}, "n4659": {"so_8514686_8514899_0": {"length": 31, "quality": 0.8611111111111112, "section_id": 6920}}}, "8514899": {"Id": "8514899", "PostTypeId": "2", "Body": "<p>For a quick fix, make that <code>operator-</code> a free function instead of a friend of <code>Vector3D</code>. Friendship is only needed when you want to access <code>private</code> members, which you not do for <code>Point3D</code> (you use the public getters), and which you especially not do for the <code>Vector3D</code> (you use the constructor to directly construct it from the values).</p>\n<p>The same holds true for <code>operator+</code>, no need for friendship here.</p>\n<p>Now on to why your code fails:</p>\n<p>If a <code>friend</code> declaration is <em>first</em> found in a class body, and it isn't declared in the enclosing namespace after the class declaration, then the function can only be found by argument dependant lookup, meaning that it won't be found if none of the arguments are of the class type it is a friend of. You can fix this by either making them free functions when the friendship isn't needed, or by explicitly declaring them outside the body of the <code>Vector3D</code> class again in the header, e.g.:</p>\n<pre><code>class Vector3D{\n  friend const Point3D operator+(const Point3D&amp; a, const Vector3D&amp; b);\n  friend const Vector3D operator-(const Point3D&amp; a, const Point3D&amp; b);\npublic:\n  // bla bla, yadda yadda\n};\n\n// also *declare* them here\nconst Point3D operator+(const Point3D&amp; a, const Vector3D&amp; b);\nconst Vector3D operator+(const Point3D&amp; a, const Point3D&amp; b);\n</code></pre>\n<p>For those language lawyer freaks out there, here is the relevant standard paragraph:</p>\n<p><code>\u00a77.3.1.2 [namespace.memdef] p3</code></p>\n<blockquote>\n<p id=\"so_8514686_8514899_0\">[...] If a <code>friend</code> declaration in a nonlocal class first declares a class or function the friend class or function is a member of the innermost enclosing namespace. <strong>The name of the friend is not found by unqualified lookup or by qualified lookup until a matching declaration is provided in that namespace scope</strong> (either before or after the class definition granting friendship). [...]</p>\n</blockquote>\n", "LastEditorUserId": "500104", "LastActivityDate": "2011-12-15T03:58:14.447", "Score": "4", "CreationDate": "2011-12-15T03:50:59.970", "ParentId": "8514686", "CommentCount": "0", "OwnerUserId": "500104", "LastEditDate": "2011-12-15T03:58:14.447"}, "8514909": {"Id": "8514909", "PostTypeId": "2", "Body": "<p>When the only declaration of a function is the <code>friend</code> declaration, I believe the function is only found when one of its arguments is the type within which it was declared. Since operator+ takes a Vector3D, the compiler looks inside Vector3D when looking for it. Since operator- only takes Point3Ds, the compiler looks inside Point3D but not Vector3D and so doesn't find the operator.</p>\n<p>As Xeo said, move the function declarations outside of the classes, and it should work.</p>\n", "LastActivityDate": "2011-12-15T03:52:48.273", "CommentCount": "2", "CreationDate": "2011-12-15T03:52:48.273", "ParentId": "8514686", "Score": "3", "OwnerUserId": "943619"}, "8514686": {"ViewCount": "1200", "Body": "<p>The compiler gives me an error when trying to subtract two Point3D objects.  I get this error:</p>\n<pre><code>Invalid operands to binary expression ('Point3D' and 'Point3D')\n</code></pre>\n<p>This is what I have in my Vector3D.h:</p>\n<pre><code>#include \"Point3D.h\"\nusing namespace std;\nclass Vector3D\n{\n    friend const Point3D operator+(const Point3D&amp; a, const Vector3D&amp; b);\n    friend const Vector3D operator-(const Point3D&amp; a, const Point3D&amp; b);\n\npublic:\n\n    Vector3D() {}\n    Vector3D(float x, float y, float z);\n    Vector3D(Point3D const&amp; originPoint, float theta, float distance);\n    float getX() const {return x;}\n    float getY() const {return y;}\n    float getZ() const {return z;}\n    static Vector3D minus(Point3D const&amp; destination, Point3D const&amp; origin);\n    Vector3D operator-(Vector3D const&amp; other) const;\n    float dot(Vector3D const&amp; other) const;\n    static float angleBetweenTwoVectorsZeroToPi(Vector3D const&amp; a, Vector3D const&amp; b);\n    static float angleBetweenTwoVectorsZeroToTwoPi(Vector3D const&amp; a, Vector3D const&amp; b);\n    Vector3D normalize() const;\n    float length() const;\n    //const float * const getArray() const {return &amp;x;}\n    Vector3D multiply(float scalar) const;\n    bool operator==(Vector3D const&amp; v) const;\n    float operator[] (int i) const;\nprivate:\n    float x;\n    float y;\n    float z;\n};\n</code></pre>\n<p>The Vector3D.cpp file which defines the binary operators:</p>\n<pre><code>#include \"Vector3D.h\"\n#include \"Math3D.h\"\n#include &lt;math.h&gt;\n#include \"MathConstants.h\"\n\nVector3D::Vector3D(float x, float y, float z):\nx(x), y(y), z(z)\n{}\n\nVector3D::Vector3D(Point3D const&amp; originPoint, float theta, float distance) \n{\n    Point3D endPoint = Math3D::calcaultePoint3D(originPoint, theta, distance);\n    Vector3D result = minus(endPoint, originPoint);\n    this-&gt;x = result.x;\n    this-&gt;y = result.y;\n    this-&gt;z = result.z;\n\n}\n\nVector3D Vector3D::minus(Point3D const&amp; destination, Point3D const&amp; origin)\n{\n    return Vector3D(destination.getX() - origin.getX(), \n                    destination.getY() - origin.getY(), \n                    destination.getZ() - origin.getZ());\n}\n\nVector3D Vector3D::operator-(Vector3D const&amp; other) const {\n    return Vector3D(x-other.x, y-other.y, z-other.z);\n}\n\nfloat Vector3D::dot(const Vector3D &amp;other) const\n{\n    return x * other.x + y * other.y + z * other.z;\n}\n\n\n\nfloat Vector3D::length() const\n{\n    return sqrtf(dot(*this));\n}\n\nVector3D Vector3D::normalize() const\n{\n    float len = length();\n    return Vector3D(getX()/len, getY()/len, getZ()/len);\n}\n\nVector3D Vector3D::multiply(float scalar) const {\n    return Vector3D(x * scalar, y * scalar, z * scalar);\n}\n\nfloat Vector3D::angleBetweenTwoVectorsZeroToPi(const Vector3D &amp;a, const Vector3D &amp;b)\n{\n    /*\n     *  The result is between 0 and PI\n     */\n    Vector3D unitA = a.normalize();\n    Vector3D unitB = b.normalize();\n    return acos(unitA.dot(unitB));\n\n}\n\nbool Vector3D::operator==(const Vector3D &amp;v) const {\n    return (x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (z == v.z);\n}\n\nfloat Vector3D::operator[](int i) const {\n    return (&amp;x)[i];\n}\n\nfloat Vector3D::angleBetweenTwoVectorsZeroToTwoPi(const Vector3D &amp;a, const Vector3D &amp;b)\n{\n    /*\n     *  The result is between 0 and 2PI\n     *\n     *  \"Assuming a = [x1,y1] and b = [x2,y2] are two vectors with their bases at the \n     *  origin, the non-negative angle between them measured counterclockwise \n     *  from a to b is given by\n     *\n     *  angle = mod(atan2(x1*y2-x2*y1,x1*x2+y1*y2),2*pi);\n     *\n     *  As you can see, this bears a close relationship to the three-dimensional \n     *  formula I wrote last July 10. The quantities, x1*y2-x2*y1 and x1*x2+y1*y2 \n     *  are, respectively, the sine and cosine of the counterclockwise angle from \n     *  vector a to vector b, multiplied by the product of their norms - that is, their \n     *  cross product and the dot product restricted to two dimensions. The 'atan2' \n     *  function then gives the angle between them ranging from -pi to +pi, and the \n     *  'mod' operation changes this so as to range from 0 to 2*pi, as you requested.\"\n     *\n     *  Roger Stafford\n     *  http://www.mathworks.com/matlabcentral/newsreader/view_thread/151925\n     */\n    float resultNegPiToPosPi = atan2f(a.x*b.y-b.x*a.y, a.x*b.x+a.y*b.y);\n    if (resultNegPiToPosPi &lt; 0.0f)\n    {\n        resultNegPiToPosPi = resultNegPiToPosPi + 2*MathConstants::PI;\n    }\n    return resultNegPiToPosPi;\n}\n\n\nconst Point3D operator+(const Point3D&amp; a, const Vector3D&amp; b) {return Point3D(a.getX()+b.getX(), a.getY()+b.getY(), a.getZ()+b.getZ());}\n\n\nconst Vector3D operator-(const Point3D&amp; a, const Point3D&amp; b) {return Vector3D(a.getX()-b.getX(), a.getY()-b.getY(), a.getZ()-b.getZ());}\n</code></pre>\n<p>This is where I try to subtract a Point3D from another:</p>\n<pre><code>void AnimationService::handlePlayerMovement(double lastTime, double currentTime, Vector3D vector) {\n\n    Point3D a;\n    Point3D b;\n    Vector3D result = a - b; // this is the problem line\n}\n</code></pre>\n<p>The strange part is that the binary <code>operator+</code> does work, but for some reason <code>operator-</code> gives me the error.  Can anyone tell me what I'm doing wrong?</p>\n", "AcceptedAnswerId": "8514899", "Title": "I'm having trouble with operator overloading of the operator- function", "CreationDate": "2011-12-15T03:15:05.247", "Id": "8514686", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-12-15T03:52:50.440", "LastEditorUserId": "256062", "LastActivityDate": "2011-12-15T03:58:14.447", "Score": "2", "OwnerUserId": "256062", "Tags": "<c++><operator-overloading>", "AnswerCount": "2"}});