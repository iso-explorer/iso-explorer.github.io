post_cb({"bq_ids": {"n4140": {"so_11794696_11794730_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3317}, "so_11794696_11794730_3": {"length": 15, "quality": 0.6818181818181818, "section_id": 3321}}, "n3337": {"so_11794696_11794730_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3187}, "so_11794696_11794730_3": {"length": 15, "quality": 0.6818181818181818, "section_id": 3191}}, "n4659": {"so_11794696_11794730_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 502}, "so_11794696_11794730_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 4086}}}, "11794696": {"ViewCount": "159", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass B{\npublic:\n  B(){}\n};\nclass A\n{\npublic:\nA(){}\nA(B &amp;b){\n\n}\nA(const B &amp;b){\n       cout&lt;&lt;\"cccddd\"&lt;&lt;endl;\n}\n};\nint main()\n{\n   B b;\n   A c(b);\n   A a;\n   a=b; //ok\n   A &amp;ref = b; //error and why???\n}\n</code></pre>\n<p>why b assigned to a is ok,but b assigned to ref is illegal???</p>\n", "AcceptedAnswerId": "11794730", "Title": "Assigning one type of object to other type of reference variable not working", "CreationDate": "2012-08-03T11:19:33.223", "Id": "11794696", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-08-03T12:22:10.613", "LastEditorUserId": "250259", "LastActivityDate": "2012-08-03T12:22:10.613", "Score": "0", "OwnerUserId": "1567318", "Tags": "<c++>", "AnswerCount": "1"}, "11794730": {"Id": "11794730", "PostTypeId": "2", "Body": "<pre><code>A(const B &amp;b){\n       cout&lt;&lt;\"cccddd\"&lt;&lt;endl;\n}\n</code></pre>\n<p>This will enable you to convert an object of type <code>B</code> into an object of type <code>A</code>. However, a reference <code>T&amp;</code> cannot be created from another type <code>L</code>.</p>\n<blockquote>\n<h3>8.5.3 References [dcl.init.ref]</h3>\n<ol>\n<li><p id=\"so_11794696_11794730_0\">A variable declared to be a <code>T&amp;</code> or <code>T&amp;&amp;</code>, that is, \u201creference to type <code>T</code>\u201d (8.3.2), shall be initialized by an object, or function, of type T or by an object that can be converted into a T.</p></li>\n<li><p id=\"so_11794696_11794730_1\">[...]</p></li>\n<li><p id=\"so_11794696_11794730_2\">[...]</p></li>\n<li><p id=\"so_11794696_11794730_3\">Given types \u201ccv1 <code>T1</code>\u201d and \u201ccv2 <code>T2</code>,\u201d \u201ccv1 <code>T1</code>\u201d is reference-related to \u201ccv2 <code>T2</code>\u201d if <code>T1</code> is the same type as <code>T2</code>, or <code>T1</code> is a base class of <code>T2</code>. \u201ccv1 <code>T1</code>\u201d is reference-compatible with \u201ccv2 <code>T2</code>\u201d if <code>T1</code> is reference-related to <code>T2</code> and cv1 is the same cv-qualification as, or greater cv-qualification than, cv2 [...].</p></li>\n</ol>\n</blockquote>\n<p>In your example neither are <code>A</code> and <code>B</code> the same type, nor is <code>A</code> a base class of <code>B</code>, thus both classes aren't reference-related.</p>\n<h3>Why won't <code>A &amp;ref = (A)b</code> work?</h3>\n<p>The expression <code>(A) b</code> will actually create a temporary, which cannot be bound to a normal reference:</p>\n<blockquote>\n<p id=\"so_11794696_11794730_4\">error: invalid initialization of non-const reference of type \u2018A&amp;\u2019 from a temporary of type \u2018B\u2019</p>\n</blockquote>\n<p>You would need to a const reference <code>A const &amp; ref = (A)b</code> for this.</p>\n", "LastEditorUserId": "1139697", "LastActivityDate": "2012-08-03T11:48:33.080", "Score": "4", "CreationDate": "2012-08-03T11:21:36.603", "ParentId": "11794696", "CommentCount": "8", "OwnerUserId": "1139697", "LastEditDate": "2012-08-03T11:48:33.080"}});