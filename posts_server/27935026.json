post_cb({"bq_ids": {"n4140": {"so_27935026_30153809_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 6036}, "so_27935026_30153809_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 5466}, "so_27935026_30153809_7": {"length": 9, "quality": 1.0, "section_id": 5467}, "so_27935026_30153809_5": {"length": 17, "quality": 0.8095238095238095, "section_id": 5467}, "so_27935026_30153809_0": {"length": 5, "quality": 1.0, "section_id": 3285}, "so_27935026_30153809_1": {"length": 7, "quality": 0.875, "section_id": 6027}, "so_27935026_30153809_4": {"length": 12, "quality": 0.75, "section_id": 5467}}, "n3337": {"so_27935026_30153809_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 5804}, "so_27935026_30153809_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 5252}, "so_27935026_30153809_7": {"length": 9, "quality": 1.0, "section_id": 5253}, "so_27935026_30153809_5": {"length": 17, "quality": 0.8095238095238095, "section_id": 5253}, "so_27935026_30153809_0": {"length": 5, "quality": 1.0, "section_id": 3155}, "so_27935026_30153809_1": {"length": 7, "quality": 0.875, "section_id": 5795}, "so_27935026_30153809_4": {"length": 12, "quality": 0.75, "section_id": 5253}}, "n4659": {"so_27935026_30153809_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 7535}, "so_27935026_30153809_5": {"length": 17, "quality": 0.8095238095238095, "section_id": 6901}, "so_27935026_30153809_7": {"length": 9, "quality": 1.0, "section_id": 6901}, "so_27935026_30153809_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 6900}, "so_27935026_30153809_0": {"length": 4, "quality": 0.8, "section_id": 653}, "so_27935026_30153809_1": {"length": 7, "quality": 0.875, "section_id": 7526}, "so_27935026_30153809_4": {"length": 12, "quality": 0.75, "section_id": 6901}}}, "27935026": {"ViewCount": "4606", "Body": "<p>First, I want to say, according to cppreference.com, it is somewhat impossible to value-initialize an enum.</p>\n<p>According to <a href=\"http://en.cppreference.com/w/cpp/language/value_initialization\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/language/value_initialization</a>, value-initializing an enum actually performs zero-initialization. It then follows that, according to <a href=\"http://en.cppreference.com/w/cpp/language/zero_initialization\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/language/zero_initialization</a>, the effect of zero-initializing an enum is:</p>\n<blockquote>\n<p id=\"so_27935026_27935026_0\">If <code>T</code> is a scalar type, the object's initial value is the integral constant zero implicitly converted to <code>T</code>.</p>\n</blockquote>\n<p>However, an integral constant zero is not implicitly convertible to an enum. Ultimately, an enum cannot be value-initialized. This sounds weird, and value-initializing an enum does work on VC, GCC, and clang. So, what does the standard say about this?</p>\n<p>Second, according to <a href=\"http://en.cppreference.com/w/cpp/language/static_cast\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/language/static_cast</a>:</p>\n<blockquote>\n<p id=\"so_27935026_27935026_1\">Integer, floating-point, or enumeration type can be converted to any complete enumeration type (the result is unspecified (until C++17) undefined behavior (since C++17) if the value of expression, converted to the enumeration's underlying type, is not one of the target enumeration values)</p>\n</blockquote>\n<p>So, does this imply that value-initializing an enum (if it works at all) may actually lead to undefined behavior if the target enum does not have an enumerator equal to <code>0</code>?</p>\n", "Title": "The behavior of value-initializing an enum", "CreationDate": "2015-01-14T02:42:07.513", "LastActivityDate": "2015-05-10T16:30:51.553", "CommentCount": "4", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2015-01-14T04:36:52.123", "LastEditorUserId": "251738", "Id": "27935026", "Score": "26", "OwnerUserId": "1348273", "Tags": "<c++><enums><initialization><language-lawyer><value-initialization>", "AnswerCount": "2"}, "30153809": {"Id": "30153809", "PostTypeId": "2", "Body": "<p>The answer to this was given in the comments. My attempt of explaining the entire standardese behind it is given below.</p>\n<blockquote>\n<p id=\"so_27935026_30153809_0\">To <em>zero-initialize</em> an object or reference of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a scalar type (3.9), the object is initialized to the value\n  obtained by converting the integer literal <code>0</code> (zero) to <code>T</code>;</li>\n</ul>\n</blockquote>\n<p>(Enumerations are scalar types; \u00a73.9/9)\nSo as the conversion is not said to be implicit, we're not looking in \u00a74, but \u00a75.2.9; </p>\n<blockquote>\n<p id=\"so_27935026_30153809_1\">The result of the expression <code>static_cast&lt;T&gt;(v)</code> is the result of\n  converting the expression <code>v</code> to type <code>T</code>.</p>\n</blockquote>\n<p>\u00a75.2.9/10 then defines how integral values are converted to enumeration types.</p>\n<blockquote>\n<p id=\"so_27935026_30153809_2\">A value of integral or enumeration type can be explicitly converted to\n  an enumeration type. <strong>The value is unchanged if the original value is\n  within the range of the enumeration values (7.2)</strong>. Otherwise, the resulting\n  value is unspecified (and might not be in that range).</p>\n</blockquote>\n<p>It must be shown that zero is in the range of enumeration values for all enumerations.<br>\nThe next five quotes are taken from \u00a77.2/8:</br></p>\n<blockquote>\n<p id=\"so_27935026_30153809_3\">For an enumeration whose underlying type is fixed, the values of the\n  enumeration are the values of the underlying type.</p>\n</blockquote>\n<p>Since all permitted underlying types include zero in their range of values*, this automatically gives the desired result. Now, for enumerations without fixed underlying types, </p>\n<blockquote>\n<p id=\"so_27935026_30153809_4\">Otherwise, for an enumeration where <em>e<sub>min</sub></em> is the smallest\n  enumerator and <em>e <sub>max</sub></em> is the largest, the values of the\n  enumeration are the values in the range <em>b <sub>min</sub></em> to <em>b\n  <sub>max</sub></em> , defined as follows:</p>\n</blockquote>\n<p>I.e. we have to show that <em>b<sub>min</sub></em> is always less than or equal to zero, and <em>b<sub>max</sub></em> is always greater or equal to zero.</p>\n<blockquote>\n<p id=\"so_27935026_30153809_5\">Let <em>K</em> be 1 for a two\u2019s\n  complement representation and 0 for a one\u2019s complement or\n  sign-magnitude representation.<br>\n<strong><em>b <sub>max</sub></em> is the smallest value greater than or equal to <em>max(|e <sub>min</sub>| \u2212 K, |e <sub>max</sub>|)</em></strong> and equal to <em>2M \u2212 1</em>, where\n  <em>M</em> is a non-negative integer.</br></p>\n</blockquote>\n<p><em>|e <sub>max</sub>|</em> is non-negative, and the maximum of two numbers is at least as large as both numbers are. Hence <em>max(|e <sub>min</sub>| \u2212 K, |e <sub>max</sub>|)</em> is non-negative as well, and <em>b<sub>max</sub></em> must be greater or equal to that number - so our first requirement is met.</p>\n<blockquote>\n<p id=\"so_27935026_30153809_6\"><em>b <sub>min</sub></em> is zero if <em>e<sub>min</sub></em> is non-negative and <em>\u2212(b<sub>max</sub> + K)</em> otherwise.</p>\n</blockquote>\n<p><em>b<sub>min</sub></em> is clearly either zero or negative: <em>b<sub>max</sub></em> is non-negative as shown above, and <em>K</em> is non-negative (0 or 1), hence the additive inverse of their sum is non-positive. Our second requirement is met. Finally,</p>\n<blockquote>\n<p id=\"so_27935026_30153809_7\">If the <em>enumerator-list</em> is empty, the values of the\n  enumeration are as if the enumeration had a single enumerator with\n  value <code>0</code>.</p>\n</blockquote>\n<p>This leads to the above result by setting <em>e<sub>min</sub> = e<sub>max</sub> = 0</em>.</p>\n<hr>\n<ul>\n<li>This reduces to the claim \"All integral types have zero in their range of values\", which is left to prove for the reader.</li>\n</ul>\n</hr>", "LastActivityDate": "2015-05-10T16:30:51.553", "CommentCount": "0", "CreationDate": "2015-05-10T16:30:51.553", "ParentId": "27935026", "Score": "3", "OwnerUserId": "3647361"}, "28881185": {"Id": "28881185", "PostTypeId": "2", "Body": "<p>1: This can be undestood like so:</p>\n<pre><code>enum class SomeEnum : int { V1 = 0, V2 = 1, V3 = 2 }; \nSomeEnum a = 0; // compile error\nSomeEnum b = SomeEnum.V1; // OK\n</code></pre>\n<p>This is basic protection from undefined behavior!</p>\n<p>2: Yes and Yes :)</p>\n<pre><code>SomeEnum c = static_cast&lt;SomeEnum&gt;(1); // = SomeEnum.V2\nSomeEnum d = static_cast&lt;SomeEnum&gt;(5); // undefined behavior\n</code></pre>\n<p>static_cast is dangerous by definition, it shoud only be used to support serrialization or old c interfaces!</p>\n", "LastActivityDate": "2015-03-05T15:11:25.817", "CommentCount": "4", "CreationDate": "2015-03-05T15:11:25.817", "ParentId": "27935026", "Score": "1", "OwnerUserId": "4634598"}});