post_cb({"1952685": {"CommentCount": "2", "Body": "<p>C++ Standard 2003,  <strong>5.19 \"Constant expressions\"</strong>, paragraph 1.</p>\n<blockquote>\n<p id=\"so_1951741_1952685_0\">In several places, C++ requires\n  expressions that evaluate to an\n  integral or enumeration constant: <strong>as\n  array bounds (8.3.4, 5.3.4)</strong>, as case\n  expressions (6.4.2), as bit-field\n  lengths (9.6), as enumerator\n  initializers (7.2), as static member\n  initializers (9.4.2), and as integral\n  or enumeration non-type template\n  arguments (14.3).</p>\n<p id=\"so_1951741_1952685_1\"><em>constant-expression:\n  conditional-expression</em></p>\n<p id=\"so_1951741_1952685_2\">An <em>integral constant-expression</em> can\n  involve only literals (2.13),\n  enumerators, const variables or static\n  data members of integral or\n  enumeration types initialized with\n  constant expressions (8.5), non-type\n  tem- plate parameters of integral or\n  enumeration types, and sizeof\n  expressions.  <strong>Floating literals\n  (2.13.3) can appear only if they are\n  cast to integral or enumeration types.</strong>\n  Only type conversions to integral or\n  enumeration types can be used.  In\n  particular, except in sizeof\n  expressions, functions, class objects,\n  pointers, or references shall not be\n  used, and assignment, increment,\n  decrement, function-call, or comma\n  operators shall not be used.</p>\n</blockquote>\n", "PostTypeId": "2", "ParentId": "1951741", "Id": "1952685", "LastActivityDate": "2009-12-23T13:00:49.480", "Score": "8", "CreationDate": "2009-12-23T13:00:49.480", "OwnerUserId": "124161"}, "bq_ids": {"n4140": {"so_1951741_1952685_0": {"length": 15, "quality": 0.5172413793103449, "section_id": 6186}}}, "1951741": {"CreationDate": "2009-12-23T09:50:37.580", "ViewCount": "2009", "PostTypeId": "1", "AcceptedAnswerId": "1952685", "Score": "2", "Title": "invalid static assert behavior", "LastEditorUserId": "138579", "CommentCount": "0", "Body": "<p>I am trying to setup a static assert (outside the main function) with GCC v4.3.x:</p>\n<pre><code>#define STATIC_ASSERT(cond) extern void static_assert(int arg[(cond) ? 1 : -1])\nSTATIC_ASSERT( (double)1 == (double)1 ); // failed\n</code></pre>\n<p>but when I use float numbers, the assert always failed.</p>\n<p>Is it possible to run this static assert properly ?</p>\n", "Tags": "<c++><c><gcc><floating-point>", "Id": "1951741", "LastEditDate": "2009-12-23T11:05:33.827", "LastActivityDate": "2009-12-26T00:28:10.923", "FavoriteCount": "2", "AnswerCount": "3", "OwnerUserId": "138579"}, "1951920": {"CommentCount": "0", "Body": "<p>I think this has to do with the rule that a cast to anything but an integer or enumeration type can not appear in a constant expression.</p>\n<pre><code>// would all work for example\nSTATIC_ASSERT( 1.0 == 1.0 );\nSTATIC_ASSERT( (int)1.0 == (int)1.0 );\n</code></pre>\n<p>So it's not the assert itself that's invalid, and causes a compiler error, it's your cast...</p>\n<p>Just for the record, boost, of course, has a <a href=\"http://www.boost.org/doc/libs/1_41_0/doc/html/boost_staticassert.html\" rel=\"nofollow noreferrer\">static assert</a> too.</p>\n", "PostTypeId": "2", "ParentId": "1951741", "Id": "1951920", "LastActivityDate": "2009-12-23T10:21:12.827", "Score": "4", "CreationDate": "2009-12-23T10:21:12.827", "OwnerUserId": "5822"}, "1951810": {"CommentCount": "10", "Body": "<p>EDIT:</p>\n<p>Indeed, moving <code>STATIC_ASSERT</code> out of <code>main()</code> gives a compiler error because a cast to a type other than an integral or enumeration type cannot appear in a constant-expression. Removing the casts works with GCC still it's not a valid ICE (as pointed by @AndreyT).</p>\n<pre><code>#define STATIC_ASSERT(cond) extern void static_assert(int arg[(cond) ? 1 : -1])\n\nSTATIC_ASSERT( 1.0 == 1.0 );\nSTATIC_ASSERT( 1.0 != 1.0 ); // this is line 4\n\nint main()\n{\n  return 0;\n}\n</code></pre>\n<p>gives:</p>\n<blockquote>\n<p id=\"so_1951741_1951810_0\">main.cpp:4: error: size of array \u2018arg\u2019 is negative</p>\n<p id=\"so_1951741_1951810_1\">Reference: ISO/IEC 14882 - 5.19 Constant Expressions</p>\n<p id=\"so_1951741_1951810_2\">An <em>integral constant-expression</em> can involve only literals (2.13), enumerators, <code>const</code> variables or <code>static</code> data members of integral or enumeration types initialized with constant expressions (8.5), non-type template parameters of integral or enumeration types, andsizeofexpressions. Floating literals (2.13.3) can appear only if they are cast to integral or enumeration types. Only type conversions to integral or enumeration types can be used. In particular, except in <code>sizeof</code> expressions, functions, class objects, pointers, or references shall not be used, and assignment, increment, decrement, function-call, or comma operators shall not be used.</p>\n</blockquote>\n<hr>\n<p>EDIT2: for the record, here is my own implementation of static assertions extracted from my code base: <a href=\"http://gregory.pakosz.fr/stackoverflow/1951741.cpp\" rel=\"nofollow noreferrer\"><code>1951741.cpp</code></a></p>\n<pre><code>#define CONCATENATE(arg1, arg2)   CONCATENATE1(arg1, arg2)\n#define CONCATENATE1(arg1, arg2)  CONCATENATE2(arg1, arg2)\n#define CONCATENATE2(arg1, arg2)  arg1##arg2\n\n/**\n * Usage:\n *\n * &lt;code&gt;STATIC_ASSERT(expression, message)&lt;/code&gt;\n *\n * When the static assertion test fails, a compiler error message that somehow\n * contains the \"STATIC_ASSERTION_FAILED_AT_LINE_xxx_message\" is generated.\n *\n * /!\\ message has to be a valid C++ identifier, that is to say it must not\n * contain space characters, cannot start with a digit, etc.\n *\n * STATIC_ASSERT(true, this_message_will_never_be_displayed);\n */\n\n#define STATIC_ASSERT(expression, message)\\\n  struct CONCATENATE(__static_assertion_at_line_, __LINE__)\\\n  {\\\n    implementation::StaticAssertion&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _), message);\\\n  };\\\n  typedef implementation::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__)\n\n  // note that we wrap the non existing type inside a struct to avoid warning\n  // messages about unused variables when static assertions are used at function\n  // scope\n  // the use of sizeof makes sure the assertion error is not ignored by SFINAE\n\nnamespace implementation {\n\n  template &lt;bool&gt;\n  struct StaticAssertion;\n\n  template &lt;&gt;\n  struct StaticAssertion&lt;true&gt;\n  {\n  }; // StaticAssertion&lt;true&gt;\n\n  template&lt;int i&gt;\n  struct StaticAssertionTest\n  {\n  }; // StaticAssertionTest&lt;int&gt;\n\n} // namespace implementation\n\n\nSTATIC_ASSERT(1.0f == 1.0 , ok);\nSTATIC_ASSERT(1.0f != 1.0 , ko);\n\nint main()\n{\n  return 0;\n}\n</code></pre>\n<p>When using <code>STATIC_ASSERT((float) 1 == (float) 1, must_be_true);</code> it gives a proper error:</p>\n<blockquote>\n<p id=\"so_1951741_1951810_3\">main.cpp:49: error: a cast to a type other than an integral or enumeration type cannot appear in a constant-expression</p>\n</blockquote>\n<hr>\n<p>What is your question exactly?</p>\n<pre><code>#define STATIC_ASSERT(cond) extern void static_assert(int arg[(cond) ? 1 : -1])\n\nint main()\n{\n  STATIC_ASSERT( (float)1 == (float)1 );\n  STATIC_ASSERT( (float)1 != (float)1 ); // this is line 6\n  return 0;\n}\n</code></pre>\n<p>Compiling it with gcc 4.4.2 gives me:</p>\n<blockquote>\n<p id=\"so_1951741_1951810_4\">main.cpp: In function \u2018int main()\u2019:</p>\n<p id=\"so_1951741_1951810_5\">main.cpp:6: error: size of array \u2018arg\u2019 is negative</p>\n</blockquote>\n<p>So yes, <code>(float)1 != (float)1</code> evaluates to <code>false</code> and makes your <code>STATIC_ASSERT</code> macro use an array of size <code>-1</code> which stops compilation.</p>\n</hr></hr>", "LastEditorUserId": "216063", "PostTypeId": "2", "LastEditDate": "2009-12-26T00:28:10.923", "ParentId": "1951741", "Id": "1951810", "LastActivityDate": "2009-12-26T00:28:10.923", "Score": "2", "CreationDate": "2009-12-23T10:01:13.017", "OwnerUserId": "216063"}});