post_cb({"32364220": {"ParentId": "32364011", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-09-02T22:33:13.477", "Score": "2", "LastEditorUserId": "1120273", "LastEditDate": "2015-09-02T23:57:26.243", "Id": "32364220", "OwnerUserId": "1120273", "Body": "<p>Copy elision of temporary objects is permitted if the source and the destination have the same \"cv-<strong>un</strong>qualified type\" according to 12.8 [class.copy] paragraph 31 third item in the list:</p>\n<blockquote>\n<p id=\"so_32364011_32364220_0\">when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move</p>\n</blockquote>\n<p>That is, the quoted code copy elision <em>is</em> allowed.</p>\n<p>Instrumenting the destructor in the original example shows that <a href=\"http://clang.llvm.org/\" rel=\"nofollow\">clang</a>, <a href=\"https://software.intel.com/en-us/c-compilers\" rel=\"nofollow\">Intel's compiler</a>, and <a href=\"https://www.edg.com/index.php?location=c_frontend\" rel=\"nofollow\">EDG's frontend</a> elide the copies while <a href=\"http://gcc.gnu.org/\" rel=\"nofollow\">gcc</a> does not. That is, there are only two destructor calls implying that all possibly elidable copies are elided. The copies are elided independent of how <code>b</code> is declared. I have declared <code>b</code> using <code>auto</code>, <code>A</code>, and <code>A const</code>.</p>\n", "LastActivityDate": "2015-09-02T23:57:26.243"}, "32364011": {"CommentCount": "9", "AcceptedAnswerId": "32364220", "CreationDate": "2015-09-02T22:13:08.487", "LastActivityDate": "2015-09-02T23:57:26.243", "PostTypeId": "1", "ViewCount": "62", "FavoriteCount": "0", "Title": "avoiding code duplication for const-overload and RVO", "Id": "32364011", "Score": "0", "Body": "<p>For the sake of avoiding code duplication when dealing with const-overload I wrote something like this:</p>\n<pre><code>#include &lt;memory&gt;\n\nclass A\n{\n    std::shared_ptr&lt;int&gt; _data;\npublic:\n    const A lightCopy() const\n    {\n        A a;\n        a._data = _data;\n        return a;\n    }\n\n    A lightCopy()\n    {\n        using const_a_t = const A;\n        const_a_t &amp;const_me = *this;\n        return const_me.lightCopy(); // const object here\n    }\n};\n\nint main()\n{\n    A a;\n    auto b = a.lightCopy();\n}\n</code></pre>\n<p><code>const_cast</code> is used in non-const version because otherwise it would be a non-const function call in const-method that will probably modify the object and will get away with it unnoticed (because of <code>const_cast</code>). And const-casting from non-const to const shouldn't cause any problems.</p>\n<p>And question here is: since I can't const_cast an object \u2014 <strong>is it possible that because invoked <code>lightCopy()</code> returns const object and actual return type is not const \u2014 RVO won't be possible and an additional copy will be made?</strong></p>\n", "Tags": "<c++><rvo>", "OwnerUserId": "2784509", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32364011_32364220_0": {"section_id": 480, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_32364011_32364220_0": {"section_id": 471, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_32364011_32364220_0": {"section_id": 502, "quality": 0.6296296296296297, "length": 17}}}});