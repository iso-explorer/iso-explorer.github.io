post_cb({"bq_ids": {"n4140": {"so_12372442_12373830_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 606}, "so_12372442_12372442_1": {"length": 8, "quality": 0.5714285714285714, "section_id": 392}, "so_12372442_12372442_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 593}, "so_12372442_12373830_2": {"length": 11, "quality": 1.0, "section_id": 2}, "so_12372442_12379512_0": {"length": 66, "quality": 0.9850746268656716, "section_id": 593}, "so_12372442_12373830_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 602}}, "n3337": {"so_12372442_12372442_1": {"length": 8, "quality": 0.5714285714285714, "section_id": 383}, "so_12372442_12373830_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 596}, "so_12372442_12372442_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 583}, "so_12372442_12373830_2": {"length": 11, "quality": 1.0, "section_id": 2}, "so_12372442_12379512_0": {"length": 66, "quality": 0.9850746268656716, "section_id": 583}, "so_12372442_12373830_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 592}}, "n4659": {"so_12372442_12372442_1": {"length": 8, "quality": 0.5714285714285714, "section_id": 409}, "so_12372442_12373830_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 632}, "so_12372442_12372442_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 616}, "so_12372442_12373830_2": {"length": 11, "quality": 1.0, "section_id": 2}, "so_12372442_12379512_0": {"length": 62, "quality": 0.9253731343283582, "section_id": 616}, "so_12372442_12373830_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 628}}}, "12379512": {"Id": "12379512", "PostTypeId": "2", "Body": "<p>As noted in Luc Danton's answer, implicit conversion is defined in terms of copy initialization. Then, if we look at 13.3.1.4:1[Copy-initialization of class by user-defined conversion]:</p>\n<blockquote>\n<p id=\"so_12372442_12379512_0\">When the type of the initializer expression is a class type \u201ccv S\u201d,\n  <strong>the non-explicit conversion functions of S</strong> and its base classes are\n  considered. When initializing a temporary to be bound to the first\n  parameter of a constructor that takes a reference to possibly\n  cv-qualified T as its first argument, called with a single argument in\n  the context of direct-initialization, explicit conversion functions\n  are also considered. Those that are not hidden within S and yield a\n  type whose cv-unqualified version is the <strong>same type as T or is a\n  derived class thereof are candidate functions</strong>. Conversion functions\n  that return \u201creference to X\u201d return lvalues or xvalues, depending on\n  the type of reference, of type X and are therefore considered to yield\n  X for this process of selecting candidate functions.</p>\n</blockquote>\n<p>If I understand this correctly, the first one works because the conversion function yields a <code>Y</code> and is therefore a candidate function as noted by the second emphasized part in the quote, however, in your second case, the set of candidate functions is empty because there is no conversion function to <code>Y</code> and no non-explicit conversion functions as noted by the first emphasized part.</p>\n<p><strong>Concerning the third case:</strong></p>\n<p>After finding <a href=\"http://www.comeaucomputing.com/iso/cwg_defects.html#1087\" rel=\"nofollow\">defect report 1087</a>, it seems clear that the intention was to allow, copy, move and template constructors when direct-initializing an object of cv2 T as you mention. <s>If you read the first passage of 13.3.1.4, it says <code>Assuming that \u201ccv1 T\u201d is\nthe type of the object being initialized, with T a class type</code>, so I think that implies <code>of an object of type \"cv2 T\"</code> that you mention.</s> However, (after reading it over), it seems that the change due to the defect report has caused the wording to become vague and not cover the third case you propose.</p>\n", "LastEditorUserId": "906773", "LastActivityDate": "2012-09-15T22:24:24.603", "Score": "3", "CreationDate": "2012-09-11T23:56:31.793", "ParentId": "12372442", "CommentCount": "6", "LastEditDate": "2012-09-15T22:24:24.603", "OwnerUserId": "906773"}, "12375508": {"Id": "12375508", "PostTypeId": "2", "Body": "<p>I am no language lawyer, however the wording of the standard implies to me that marking a conversion operator as <code>explicit</code> requires that you explicity specify the conversion type (i.e. <code>int</code>) as part of the initialisation of object <code>y1</code>.  With the code  <code>Y y1(z)</code>, it would appear that you're relying on an implicit conversion, since the type you specify for variable <code>y1</code> is <code>Y</code>.    </p>\n<p>Therefore, I would expect correct usage of the explicit conversion operator in this situation to be:</p>\n<pre><code>Y y1( int(z) ); \n</code></pre>\n<p>Or, since you are effectively specifying a cast, preferably</p>\n<pre><code>Y y1( static_cast&lt;int&gt; (z) ); \n</code></pre>\n", "LastActivityDate": "2012-09-11T18:12:22.940", "Score": "2", "CreationDate": "2012-09-11T18:12:22.940", "ParentId": "12372442", "CommentCount": "1", "OwnerUserId": "1301901"}, "12372442": {"ViewCount": "954", "Body": "<p>Post-standard draft n3376 has as an example (12.3.2:2) of the use of an explicit conversion function to a user-defined type:</p>\n<pre><code>class Y { };\nstruct Z {\n  explicit operator Y() const;\n};\nvoid h(Z z) {\n  Y y1(z); // OK: direct-initialization\n}\n</code></pre>\n<p>Per 12.3.2:2, an explicit conversion function is \"<em>only considered as a user-defined conversion for direct-initialization</em>\"; however, that would appear to permit:</p>\n<pre><code>struct Y { Y(int); };\nstruct Z {\n  explicit operator int() const;\n};\nvoid h(Z z) {\n  Y y1(z); // direct-initialization\n}\n</code></pre>\n<p>which appears to conflict with the intent of the standard, and indeed is rejected by gcc-4.7.1:</p>\n<pre><code>source.cpp: In function 'void h(Z)':\nsource.cpp:4:9: error: no matching function for call to 'Y::Y(Z&amp;)'\nsource.cpp:4:9: note: candidates are:\nsource.cpp:1:12: note: Y::Y(int)\nsource.cpp:1:12: note:   no known conversion for argument 1 from 'Z' to 'int'\nsource.cpp:1:8: note: constexpr Y::Y(const Y&amp;)\nsource.cpp:1:8: note:   no known conversion for argument 1 from 'Z' to 'const Y&amp;'\nsource.cpp:1:8: note: constexpr Y::Y(Y&amp;&amp;)\nsource.cpp:1:8: note:   no known conversion for argument 1 from 'Z' to 'Y&amp;&amp;'\n</code></pre>\n<p>Is gcc correct to reject the conversion from <code>Z</code> to <code>Y</code> via <code>int</code>, or does the standard indeed permit this usage?</p>\n<p>I considered the context of the mentioned <em>direct-initialization</em>; per the definition of direct-initialization to class type in 8.5:16, a constructor is called with the initializer expression as its arguments, which therefore are converted to the parameter type by an implicit conversion sequence (13.3.3.1). Since an implicit conversion sequence is an implicit conversion (4:3), and thus models copy-initialization (8.5:14) and not direct-initialization, the language in 12.3.2:2 must be referring to the expression as a whole.</p>\n<p>Note also that this isn't a violation of 12.3:4 (multiple user-defined conversions); the same compiler is happy with the same code with <code>explicit</code> removed (as are Clang and Comeau):</p>\n<pre><code>struct Y { Y(int); };\nstruct Z { operator int(); };\nvoid h(Z z) {\n  Y y1(z); // direct-initialization\n}\n</code></pre>\n<hr>\n<p>I think Jesse Good has identified the distinction between the <code>operator Y</code> and <code>operator int</code> cases in 13.3.1.4:1, but there's a third case that I'm still concerned by:</p>\n<pre><code>struct X {};\nstruct Y { Y(const X &amp;); };\nstruct Z {\n  explicit operator X() const;\n};\nvoid h(Z z) {\n  Y y1(z); // direct-initialization via class-type X\n}\n</code></pre>\n<p>The initialization of the temporary <code>X</code> to be bound to the single <code>const X &amp;</code> parameter of the constructor of <code>Y</code> proceeds in a direct-initialization context per 13.3.1.4:1, with <code>T</code> as <code>X</code> and <code>S</code> as <code>Z</code>.  I think this clause is incorrect and should read:</p>\n<blockquote>\n<h3>13.3.1.4 Copy-initialization of class by user-de\ufb01ned conversion [over.match.copy]</h3>\n<p id=\"so_12372442_12372442_0\">1 - [...] When initializing a temporary to be bound to the first parameter\n  of a constructor that takes a reference to possibly <em>cv</em>-qualified <code>T</code> as its first argument, called with a single argument in the context of direct-initialization <em>of an object of type \"cv2 <code>T</code>\"</em>, explicit conversion functions are also considered. [...]</p>\n</blockquote>\n<p>For the avoidance of confusion, I think 12.3.2:2 should also be amended:</p>\n<blockquote>\n<h3>12.3.2 Conversion functions [class.conv.fct]</h3>\n<p id=\"so_12372442_12372442_1\">2 - A conversion function may be explicit (7.1.2), in which case it is only considered as a user-defined conversion for direct-initialization (8.5) <em>in certain contexts (13.3.1.4, 13.3.1.5, 13.3.1.6)</em>. [...]</p>\n</blockquote>\n<p>Any comments on the above?</p>\n</hr>", "AcceptedAnswerId": "12379512", "Title": "Explicit conversion functions, direct-initialization, and converting constructors", "CreationDate": "2012-09-11T14:49:07.430", "Id": "12372442", "CommentCount": "2", "LastEditDate": "2012-09-14T19:15:40.140", "PostTypeId": "1", "LastEditorUserId": "567292", "LastActivityDate": "2012-09-15T22:24:24.603", "Score": "3", "OwnerUserId": "567292", "Tags": "<c++><c++11><initialization><type-conversion><language-lawyer>", "AnswerCount": "3"}, "12373830": {"Id": "12373830", "PostTypeId": "2", "Body": "<p>According to 8.5 and 13.3.1.3 the constructors of <code>Y</code> are considered and the best one is picked via overload resolution. In this case the relevant constructors are <code>Y(int);</code> and the copy and move constructors. In the process of overload resolution 13.3.2 Viable functions [over.match.viable] specifies this:</p>\n<blockquote>\n<p id=\"so_12372442_12373830_0\">3 Second, for <code>F</code> to be a viable function, there shall exist for each argument an <em>implicit conversion sequence</em> (13.3.3.1) that converts that argument to the corresponding parameter of <code>F</code>. [...]</p>\n</blockquote>\n<p>For all those constructors there is no such conversion from <code>Z</code> to either <code>int</code> or one of the flavours of <code>Y</code>. To convince ourselves, let's investigate what the Standard says about implicit conversion sequences in 13.3.3.1 Implicit conversion sequences [over.best.ics]:</p>\n<blockquote>\n<p id=\"so_12372442_12373830_1\">1 An implicit conversion sequence is a sequence of conversions used to convert an argument in a function call to the type of the corresponding parameter of the function being called. The sequence of conversions is an implicit conversion as defined in Clause 4, which means it is governed by the rules for initialization of an object or reference by a single expression (8.5, 8.5.3).</p>\n</blockquote>\n<p>If we cross-reference Clause 4, then we learn that an implicit conversion is defined in terms of copy-initialization (i.e. <code>T t=e;</code>, where <code>T</code> is <code>int</code> and <code>e</code> is <code>z</code>):</p>\n<blockquote>\n<p id=\"so_12372442_12373830_2\">(\u00a74.3) An expression e can be implicitly converted to a type T if and only if the declaration <code>T t=e;</code> is well-formed, for some invented temporary variable t (8.5). [...]</p>\n</blockquote>\n<p>So I take 12.3.2:2 not to apply for <em>this</em> initialization, which happens in the larger context of a direct initialization. Doing otherwise would contradict with this latest paragraph.</p>\n", "LastEditorUserId": "777186", "LastActivityDate": "2012-09-15T03:48:55.940", "Score": "4", "CreationDate": "2012-09-11T16:08:24.740", "ParentId": "12372442", "CommentCount": "8", "LastEditDate": "2012-09-15T03:48:55.940", "OwnerUserId": "726300"}});