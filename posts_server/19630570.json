post_cb({"45557709": {"Id": "45557709", "PostTypeId": "2", "Body": "<p>In plain word, odr-used means something(variable or function) is used in a context where the definition of it must be present.</p>\n<p>e.g., </p>\n<pre><code>struct F {\n   static const int g_x = 2;\n};\n\nint g_x_plus_1 = F::g_x + 1; // in this context, only the value of g_x is needed.\n                             // so it's OK without the definition of g_x\n\nvector&lt;int&gt;  vi;\nvi.push_back( F::g_x );      // Error, this is odr-used, push_back(const int &amp; t) expect\n                             // a const lvalue, so it's definition must be present\n</code></pre>\n<p>Note, the above push_back passed in MSVC 2013, this behavior is not standard compliance, both gcc 4.8.2 and clang 3.8.0 failed, the error message is:\nundefined reference to `K::g_x'</p>\n", "LastActivityDate": "2017-08-08T00:58:20.183", "CommentCount": "1", "CreationDate": "2017-08-08T00:58:20.183", "ParentId": "19630570", "Score": "2", "OwnerUserId": "64469"}, "bq_ids": {"n4140": {"so_19630570_19630570_1": {"length": 16, "quality": 0.6153846153846154, "section_id": 7040}, "so_19630570_19630570_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 7040}}, "n3337": {"so_19630570_19630570_1": {"length": 26, "quality": 1.0, "section_id": 6785}, "so_19630570_19630570_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 6785}}, "n4659": {"so_19630570_19630570_1": {"length": 16, "quality": 0.6153846153846154, "section_id": 8537}, "so_19630570_19630570_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 8537}}}, "19631208": {"Id": "19631208", "PostTypeId": "2", "Body": "<p>It's just an arbitrary definition, used by the standard to\nspecify when you must provide a definition for an entity (as\nopposed to just a declaration).  The standard doesn't say just\n\"used\", because this can be interpreted diversely depending on\ncontext.  And some ODR-use doesn't really correspond to what one\nwould normally associate with \"use\"; for example, a virtual\nfunction is always ODR-used unless it is pure, even if it isn't\nactually called anywhere in the program.</p>\n<p>The full definition is in <a href=\"http://eel.is/c++draft/basic.def.odr\">\u00a73.2</a>, second paragraph, although this\ncontains references to other sections to complete the\ndefinition.  </p>\n<p>With regards to templates, ODR-used is only part of question;\nthe other part is instantiation.  In particular, \u00a714.7 covers\nwhen a template is instantiated.  But the two are related: while\nthe text in \u00a714.7.1 (implicit instantiation) is fairly long, the\nbasic principle is that a template will only be instantiated if\nit is used, and in this context, used means ODR-used.  Thus,\na member function of a class template will only be instantiated\nif it is called, or if it is virtual and the class itself is\ninstantiated.  The standard itself counts on this in many\nplaces: the <code>std::list&lt;&gt;::sort</code> uses <code>&lt;</code> on the individual\nelements, but you can instantiate a list over an element type\nwhich doesn't support <code>&lt;</code>, as long as you don't call <code>sort</code> on\nit.</p>\n", "LastEditorUserId": "485343", "LastActivityDate": "2016-08-14T12:51:22.603", "Score": "46", "CreationDate": "2013-10-28T09:31:59.840", "ParentId": "19630570", "CommentCount": "1", "OwnerUserId": "649665", "LastEditDate": "2016-08-14T12:51:22.603"}, "19630570": {"ViewCount": "6628", "Body": "<p>This just came up in the context of <a href=\"https://stackoverflow.com/questions/19630138/the-impact-of-virtual-on-the-use-of-member-of-class-template?noredirect=1#comment29143561_19630138\">another question</a>.</p>\n<p>Apparently member functions in class templates are only instantiated if they are ODR-used.\nCould somebody explain what exactly that means. The <a href=\"http://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"noreferrer\">wikipedia article on ODR</a> doesn't mention \"<em>ODR-use</em>\".</p>\n<p>However the standard defines it as</p>\n<blockquote>\n<p id=\"so_19630570_19630570_0\">A variable whose name appears as a potentially-evaluated expression\n  is <em>odr-used</em> unless it is an object that satisfies the requirements for\n  appearing in a constant expression (5.19) and the lvalue-to-rvalue\n  conversion (4.1) is immediately applied.</p>\n</blockquote>\n<p>in [basic.def.odr].</p>\n<p>Edit: Apparently this is the wrong part and the entire paragraph contains multiple definitions for different things. This might be the relevant one for class template member function:</p>\n<blockquote>\n<p id=\"so_19630570_19630570_1\">A non-overloaded function whose name appears as a\n  potentially-evaluated expression or a member of a set of candidate\n  functions, if selected by overload resolution when referred to from a\n  potentially-evaluated expression, is odr-used, unless it is a pure\n  virtual function and its name is not explicitly qualified.</p>\n</blockquote>\n<p>I do however not understand, how this rule works across multiple compilation units? Are all member functions instantiated if I explicitly instantiate a class template?</p>\n", "AcceptedAnswerId": "19631208", "Title": "What does it mean to \"ODR-use\" something?", "CreationDate": "2013-10-28T08:58:46.793", "Id": "19630570", "CommentCount": "2", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:10:24.400", "LastEditorUserId": "-1", "LastActivityDate": "2017-08-08T00:58:20.183", "Score": "48", "OwnerUserId": "1994377", "Tags": "<c++><templates><one-definition-rule>", "AnswerCount": "2"}});