post_cb({"22661499": {"ParentId": "22661317", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If you have a class definition like this:</p>\n<pre><code>class A\n{\npublic:\n    int q;\n    A() {\n        std::cout &lt;&lt; \"Constructor without argument\" &lt;&lt; std::endl;\n    }\n    A(int x) : q(x) {\n        std::cout &lt;&lt; \"Constructor\" &lt;&lt; std::endl;\n    }\n    A(const A&amp; a) {\n        std::cout &lt;&lt; \"Copy Constructor\" &lt;&lt; std::endl;\n        this-&gt;q = a.q;\n    }\n    A&amp; operator=(const A&amp; a) {\n        std::cout &lt;&lt; \"Assignment operator\" &lt;&lt; std::endl;\n        if(&amp;a != this) this-&gt;q = a.q;\n        return *this;\n    }\n};\n</code></pre>\n<p>then you get the following results:</p>\n<pre><code>int main(int argc, char** argv)\n{\n    A a(2); // uses constructor\n    A b = A(3); // uses constructor (exact same as A b(3);)\n    A c = b; // uses copy constructor\n    A d; // uses constructor without parameter\n    c = d; // uses assignment operator\n}\n</code></pre>\n<p>As a remark: in C++11 you can also write <code>A a{2};</code> which avoids some confusions with function calls.</p>\n<p>So to summarize: just write <code>A a(2);</code> - or if you are using C++11 <code>A a{2};</code>.</p>\n", "OwnerUserId": "316448", "LastEditorUserId": "316448", "LastEditDate": "2014-03-26T13:21:19.013", "Id": "22661499", "Score": "0", "CreationDate": "2014-03-26T12:45:38.920", "LastActivityDate": "2014-03-26T13:21:19.013"}, "22662143": {"ParentId": "22661317", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The relevant portion of the standard is (n3797)8.5/17.</p>\n<blockquote>\n<p id=\"so_22661317_22662143_0\">Otherwise (i.e., for the remaining copy-initialization cases),\n  user-defined conversion sequences that can convert from the source\n  type to the destination type or (when a conversion function is used)\n  to a derived class thereof are enumerated as described in 13.3.1.4,\n  and the best one is chosen through overload resolution (13.3). If the\n  conversion cannot be done or is ambiguous, the initialization is\n  ill-formed. The function selected is called with the initializer\n  expression as its argument; if the function is a constructor, the call\n  initializes a temporary of the cv-unqualified version of the\n  destination type. The temporary is a prvalue. The result of the call\n  (which is the temporary for the constructor case) is then used to\n  direct-initialize, according to the rules above, the object that is\n  the destination of the copy-initialization. In certain cases, an\n  implementation is permitted to eliminate the copying inherent in this\n  direct-initialization by constructing the intermediate result directly\n  into the object being initialized; see 12.2, 12.8.</p>\n</blockquote>\n<p>What is means is that, given the code:</p>\n<pre><code>CBox a=CBox(1);\nCBox b(2);\n</code></pre>\n<p>The two pieces of code will do <strong>exactly</strong> the same thing in a standards compliant compiler, provided certain (reasonable) conditions are met. There is no temporary generated, no assignment operation and no copy. The constructor is called to direct-initialise the object itself in both cases.</p>\n<p>I find the standard unclear as to whether this is <code>copy elision</code>, since the term is not used here. It is covered in 12.8/31.</p>\n<p>[I wasn't going to answer this, but unfortunately all the other answers are wrong. I hope @Kerrek will agree, or suggest an edit.]</p>\n<p>In answer to the question, which to use depends on readability and other factors.</p>\n", "OwnerUserId": "1105562", "LastEditorUserId": "18882", "LastEditDate": "2014-03-26T13:25:53.967", "Id": "22662143", "Score": "0", "CreationDate": "2014-03-26T13:12:38.520", "LastActivityDate": "2014-03-26T13:25:53.967"}, "bq_ids": {"n4140": {"so_22661317_22662143_0": {"section_id": 3296, "quality": 0.9204545454545454, "length": 81}}, "n3337": {"so_22661317_22662143_0": {"section_id": 3166, "quality": 0.9204545454545454, "length": 81}}, "n4659": {"so_22661317_22662143_0": {"section_id": 4058, "quality": 0.6818181818181818, "length": 60}}}, "22661317": {"CommentCount": "4", "ViewCount": "76", "PostTypeId": "1", "LastEditorUserId": "718379", "CreationDate": "2014-03-26T12:38:25.163", "LastActivityDate": "2014-03-26T13:25:53.967", "Title": "The correct ways about Instantiating class", "OwnerDisplayName": "user3463246", "LastEditDate": "2014-03-26T12:41:30.700", "Id": "22661317", "Score": "1", "Body": "<p>Is this two ways of instantiating class both acceptable?\nMy intention is to create <code>CBox</code> on stack instead of heap</p>\n<pre><code>CBox a=CBox(1);\nCBox b(2);\n</code></pre>\n<p>Definition of CBox is as followed:</p>\n<pre><code>class CBox\n{\npublic:\n    int abc;\n    CBox(int var){\n        abc=var;\n    }\n\n};\n</code></pre>\n", "Tags": "<c++>", "AnswerCount": "3"}, "22661428": {"ParentId": "22661317", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>In fact due to the elision of the copy/move constructor in the first definition the both definitions are equivalent. </p>\n<pre><code>CBox a=CBox(1);\nCBox b(2);\n</code></pre>\n<p>The only difference is that if the copy/move constructor is not accessible or may not be called implicitly (for example it is private or defined as deleted or has function specifier explicit) then the first statement will not be compiled except MS VC++ that has its own language extensions that are usually simply compiler bugs.:).</p>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-03-26T13:08:29.587", "Id": "22661428", "Score": "1", "CreationDate": "2014-03-26T12:42:20.203", "LastActivityDate": "2014-03-26T13:08:29.587"}});