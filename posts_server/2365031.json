post_cb({"2365031": {"AcceptedAnswerId": "2366070", "Tags": "<c++><unique-ptr>", "AnswerCount": "2", "OwnerUserId": "4928", "Body": "<p>I'm currently trying to use <a href=\"http://home.roadrunner.com/~hinnant/unique_ptr03.html\" rel=\"nofollow noreferrer\">Howard Hinnant's unique_ptr implementation</a>, and am running into a compile error. Here is some sample code:</p>\n<pre><code>struct Base {};\n\nstruct Derived : public Base {};\n\nvoid testfun(boost::unique_ptr&lt;Base&gt;);\n\nvoid test()\n{\n    unique_ptr&lt;Derived&gt; testDerived; \n    unique_ptr&lt;Base&gt; testBase(move(testDerived)); // ok, construct base explicitly from derived \n    testfun(move(testBase));                      // ok, pass base to testfun which expects base \n    testfun(unique_ptr&lt;Base&gt;(move(testDerived))); // ok, explicitly converts to unique_ptr&lt;Base&gt;\n    testfun(move(testDerived));                   // error on this line\n}\n</code></pre>\n<p>The error I get is</p>\n<pre><code>In function 'void test()':\nerror: no matching function for call to 'boost::unique_ptr&lt;Base, boost::default_delete&lt;Base&gt; &gt;::unique_ptr(boost::unique_ptr&lt;Base, boost::default_delete&lt;Base&gt; &gt;)'\nnote: candidates are: boost::unique_ptr&lt;T, D&gt;::unique_ptr(boost::detail_unique_ptr::rv&lt;boost::unique_ptr&lt;T, D&gt; &gt;) [with T = Base, D = boost::default_delete&lt;Base&gt;]\nnote:                 boost::unique_ptr&lt;T, D&gt;::unique_ptr(boost::unique_ptr&lt;T, D&gt;&amp;) [with T = Base, D = boost::default_delete&lt;Base&gt;]\nerror:   initializing argument 1 of 'void testfun(boost::unique_ptr&lt;Base, boost::default_delete&lt;Base&gt; &gt;)' from result of 'boost::unique_ptr&lt;T, D&gt;::unique_ptr(boost::unique_ptr&lt;U, E&gt;, typename boost::enable_if_c&lt;((((! boost::is_array&lt;U&gt;::value) &amp;&amp; boost::detail_unique_ptr::is_convertible&lt;typename boost::unique_ptr&lt;U, boost::default_delete&lt;U&gt; &gt;::pointer,typename boost::detail_unique_ptr::pointer_type&lt;T, D&gt;::type&gt;::value) &amp;&amp; boost::detail_unique_ptr::is_convertible&lt;E,D&gt;::value) &amp;&amp; ((! boost::is_reference&lt;D&gt;::value) || boost::is_same&lt;D,E&gt;::value)), void&gt;::type*) [with U = Derived, E = boost::default_delete&lt;Derived&gt;, T = Base, D = boost::default_delete&lt;Base&gt;]'\n</code></pre>\n<p>It seems like the offending line should not fail. Is this a bug in the implementation, a limitation of the implementation due to the lack of C++0x language features, or a misunderstanding of the rules of unique_ptrs?</p>\n<p>(Note, I know this won't work at run-time because I'm moving the same thing more than once; I'm just trying to figure out the compile-time error.)</p>\n", "CommentCount": "2", "CreationDate": "2010-03-02T17:02:21.463", "PostTypeId": "1", "FavoriteCount": "1", "LastActivityDate": "2010-06-28T14:48:52.977", "Id": "2365031", "Title": "Does Hinnant's unique_ptr implementation incorrectly fail to convert derived-to-base in this case?", "Score": "3", "ViewCount": "1621"}, "bq_ids": {"n3337": {"so_2365031_2366063_0": {"section_id": 599, "quality": 0.7857142857142857, "length": 11}}}, "2366063": {"LastActivityDate": "2010-03-02T20:18:19.277", "LastEditorUserId": "34509", "ParentId": "2365031", "LastEditDate": "2010-03-02T20:18:19.277", "Id": "2366063", "Score": "1", "Body": "<p>For a similar example, see this which should fail too</p>\n<pre><code>unique_ptr&lt;Base&gt; testBase = move(testDerived);\n</code></pre>\n<p>The problem here is how the move semantic is implemented: The \"copy constructor\" takes a non-const reference, thus not being able to bind to temporaries. To still \"move\" from temporaries, the class has a conversion function (following are really just conceptual - they may be differently implemented in detail):</p>\n<pre><code>operator rv&lt;T&gt;() { return rv&lt;T&gt;(*this); }\n</code></pre>\n<p>And a constructor will take that object:</p>\n<pre><code>unique_ptr(rv&lt;T&gt; r):ptr_(r.release()) { }\n</code></pre>\n<p>Here is an example that fails for the same reason:</p>\n<pre><code>// move helper. rv&lt;&gt; in unique_ptr\nstruct E { };\n\n// simulates a unique_ptr&lt;D&gt;\nstruct D { };\n\n// simulates the unique_ptr&lt;B&gt;\nstruct A {\n  A() { }\n\n  // accepts \"derived\" classes. Note that for unique_ptr, this will need that\n  // the argument needs to be copied (we have a by-value parameter). Thus we \n  // automatically ensure only rvalue derived-class pointers are accepted.\n  A(D) { } \n\n  // these will accept rvalues\n  A(E) { }\n  operator E() { return E(); }\n\nprivate:\n  A(A&amp;); // private, error if passed lvalue\n};\n</code></pre>\n<p>Now, consider this code:</p>\n<pre><code>// allowed: goes: D -&gt; A(D)\nA a((D()));\n\n// compile failure. Goes:\n// D -&gt; A(D) -&gt; A(E)\nA a = D();\n</code></pre>\n<p>Copy initialization will first convert to <code>A</code>. But then, the temporary <code>A</code> object is tried to be copied again to the final object. This will need the way using <code>operator E</code>. But that's another user defined conversion in the initialization, which the standard forbids:</p>\n<p><code>13.3.3.1/4</code></p>\n<blockquote>\n<p id=\"so_2365031_2366063_0\">When invoked for the copying of the temporary in the second step of a class copy-initialization, [...], only standard conversion sequences and ellipsis conversion sequences are allowed.</p>\n</blockquote>\n<p>This is why your code fails. </p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "34509", "CreationDate": "2010-03-02T19:28:42.640"}, "2366070": {"LastActivityDate": "2010-06-28T14:48:52.977", "LastEditorUserId": "4928", "ParentId": "2365031", "LastEditDate": "2010-06-28T14:48:52.977", "Id": "2366070", "Score": "0", "Body": "<p>Further research has lead me to <a href=\"http://lists.boost.org/Archives/boost/2009/01/146858.php\" rel=\"nofollow noreferrer\">this note</a>, leading me to believe that this is a known limitation of the implementation:</p>\n<p>3 of the tests currently fail for me (fail at compile time,\nsupposed to compile, run and pass). These are all associated with the\nconverting constructor specified in [unique.ptr.single.ctor]. When\nthe source and target are of different type, this emulation demands\nthat the conversion be explicit, and refuses to compile on implicit\nconversions:</p>\n<pre><code>unique_ptr&lt;base&gt; b(unique_ptr&lt;derived&gt;()); // ok\n\nunique_ptr&lt;base&gt; b = unique_ptr&lt;derived&gt;(); // causes 3 compile time failures under unique.ptr/unique.ptr.single/unique.ptr.single.ctor .\n</code></pre>\n", "CommentCount": "1", "PostTypeId": "2", "OwnerUserId": "4928", "CreationDate": "2010-03-02T19:30:02.340"}});