post_cb({"14426927": {"Id": "14426927", "PostTypeId": "2", "Body": "<p>The Standard has a quiet not explicitly defined equivalence rule for types that is mainly based on syntax for qualified names but for template parameters is the position in the paremeter list and the nesting depth of that list (i.e whether it is the one of a member template or of the enclosing class template).</p>\n<p>A particular dependent type is remembered by typedefs. However that decltype type by 14.4p2 is a distinct type and not equivalent with T.</p>\n", "LastActivityDate": "2013-01-20T17:03:41.117", "CommentCount": "0", "CreationDate": "2013-01-20T17:03:41.117", "ParentId": "14420908", "Score": "2", "OwnerUserId": "34509"}, "bq_ids": {"n4140": {"so_14420908_14420908_0": {"length": 15, "quality": 1.0, "section_id": 7142}, "so_14420908_14420908_1": {"length": 15, "quality": 1.0, "section_id": 7142}, "so_14420908_14420908_11": {"length": 11, "quality": 1.0, "section_id": 158}, "so_14420908_14420908_10": {"length": 13, "quality": 0.9285714285714286, "section_id": 5768}, "so_14420908_14420908_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 7142}, "so_14420908_14420908_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 7142}, "so_14420908_14420908_2": {"length": 10, "quality": 1.0, "section_id": 7142}, "so_14420908_14420908_6": {"length": 7, "quality": 0.875, "section_id": 5768}, "so_14420908_14420908_8": {"length": 13, "quality": 0.9285714285714286, "section_id": 3241}, "so_14420908_14420908_7": {"length": 5, "quality": 0.625, "section_id": 5768}}, "n3337": {"so_14420908_14420908_10": {"length": 13, "quality": 0.9285714285714286, "section_id": 5541}, "so_14420908_14420908_0": {"length": 15, "quality": 1.0, "section_id": 6886}, "so_14420908_14420908_1": {"length": 15, "quality": 1.0, "section_id": 6886}, "so_14420908_14420908_6": {"length": 7, "quality": 0.875, "section_id": 5541}, "so_14420908_14420908_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 6886}, "so_14420908_14420908_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 6886}, "so_14420908_14420908_8": {"length": 13, "quality": 0.9285714285714286, "section_id": 3114}, "so_14420908_14420908_2": {"length": 10, "quality": 1.0, "section_id": 6886}, "so_14420908_14420908_7": {"length": 5, "quality": 0.625, "section_id": 5541}, "so_14420908_14420908_11": {"length": 11, "quality": 1.0, "section_id": 152}}, "n4659": {"so_14420908_14420908_10": {"length": 13, "quality": 0.9285714285714286, "section_id": 7225}, "so_14420908_14420908_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 8643}, "so_14420908_14420908_1": {"length": 15, "quality": 1.0, "section_id": 8643}, "so_14420908_14420908_6": {"length": 7, "quality": 0.875, "section_id": 7225}, "so_14420908_14420908_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 8643}, "so_14420908_14420908_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 8643}, "so_14420908_14420908_8": {"length": 12, "quality": 0.8571428571428571, "section_id": 3997}, "so_14420908_14420908_2": {"length": 10, "quality": 1.0, "section_id": 8643}, "so_14420908_14420908_7": {"length": 5, "quality": 0.625, "section_id": 7225}, "so_14420908_14420908_11": {"length": 11, "quality": 1.0, "section_id": 162}}}, "14420908": {"ViewCount": "286", "Body": "<p>What determines whether two function template declarations declare the same template, or are overloads of the same name?</p>\n<p>The beginning of the answer is found in 3.5p9:</p>\n<blockquote>\n<p id=\"so_14420908_14420908_0\">Two names that are the same (Clause 3) and that are declared in different scopes shall denote the same variable, function, type, enumerator, template or namespace if</p>\n<ul>\n<li><p id=\"so_14420908_14420908_1\">both names have external linkage or else both names have internal linkage and are declared in the same translation unit; and</p></li>\n<li><p id=\"so_14420908_14420908_2\">both names refer to members of the same namespace or to members, not by inheritance, of the same class; and</p></li>\n<li><p id=\"so_14420908_14420908_3\">when both names denote functions, the parameter-type-lists of the functions (8.3.5) are identical; and</p></li>\n<li><p id=\"so_14420908_14420908_4\">when both names denote function templates, the signatures (14.5.6.1) are the same.</p></li>\n</ul>\n</blockquote>\n<p>The signature of a non-template non-member function is (1.3.17):</p>\n<blockquote>\n<p id=\"so_14420908_14420908_5\"><strong>signature</strong></p>\n<p id=\"so_14420908_14420908_6\">&lt;function&gt; name, parameter type list (8.3.5), and enclosing namespace (if any)</p>\n<p id=\"so_14420908_14420908_7\">[<em>Note:</em> Signatures are used as a basis for name mangling and linking. -- <em>end note</em>]</p>\n</blockquote>\n<p>The <em>parameter-type-list</em> mentioned twice already is defined in section 8.3.5p5.  The paragraph describes how the actual types of function parameters are adjusted from the declared types, replacing arrays and functions with pointers, and discarding top-level <em>cv-qualifiers</em>.  Then,</p>\n<blockquote>\n<p id=\"so_14420908_14420908_8\">The resulting list of transformed parameter types and the presence or absence of the ellipsis or a function parameter pack is the function's <em>parameter-type-list</em>.</p>\n</blockquote>\n<p>So in the non-template case, <em>parameter-type-list</em> is plainly a conceptual semantic list of types (plus maybe a fancy ending), not a sequence of tokens or syntactic construct.  And the following is, as we'd expect, a violation of the ODR, since both definitions define the same function:</p>\n<pre><code>void f(int, int*) {}\nvoid f(int p, decltype(p)*) {}\n</code></pre>\n<p>In the template case, we have (1.3.18):</p>\n<blockquote>\n<p id=\"so_14420908_14420908_9\"><strong>signature</strong></p>\n<p id=\"so_14420908_14420908_10\">&lt;function template&gt; name, parameter type list (8.3.5), enclosing namespace (if any), return type, and template parameter list</p>\n</blockquote>\n<p>Now consider:</p>\n<pre><code>template&lt;typename T&gt; void g(int, int*, T, T*) {}               // #1\n// template&lt;typename T&gt; void g(int p, decltype(p)*, T, T*) {}  // #2\ntemplate&lt;typename T&gt; void g(int, int*, T q, decltype(q)*) {}   // #3\n</code></pre>\n<p>g++ -std=c++0x version 4.6.3 complains that definitions #1 and #2 define the same function, but has no problem accepting #1 and #3 as overloads.  (It also thinks #3 is more specialized than #1, and there's no way to call #1, but that's a tangent issue.)  The main difference between #2 and #3 is that <code>q</code> is type-dependent and <code>p</code> is not.  So I guess the meaning of <code>decltype(q)</code> can't be determined until the template is instantiated?  Is this behavior guaranteed by the Standard?</p>\n<p>For function templates, the meaning of <em>parameter-type-list</em> must be allowed to include template parameters which have not yet been replaced by instantiation, and therefore dependent names and all that.  But that makes it tricky, if possible, to know whether two declarations are equivalent.</p>\n<p>A similar issue is solved by 14.5.6.1 paragraphs 5-6, which define <em>equivalent</em> expressions and <em>equivalent</em> function template declarations (same sequence of tokens except that different declarations may use different identifiers for the template parameters), <em>functionally equivalent</em> expressions and <em>functionally equivalent</em> function template declarations (same after instantiation), with the requirement:</p>\n<blockquote>\n<p id=\"so_14420908_14420908_11\">If a program contains declarations of function templates that are functionally equivalent but not equivalent, the program is ill-formed; no diagnostic is required.</p>\n</blockquote>\n<p>An example from paragraph 5 demonstrates safely equivalent function templates:</p>\n<pre><code>template &lt;int I, int J&gt; void f(A&lt;I+J&gt;);  // #1\ntemplate &lt;int K, int L&gt; void f(A&lt;K+L&gt;);  // same as #1\n</code></pre>\n<p>and an example from paragraph 7 demonstrates a violation of that rule:</p>\n<pre><code>// Ill-formed, no diagnostic required\ntemplate &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+10&gt;);\ntemplate &lt;int I&gt; void f(A&lt;I&gt;, A&lt;I+1+2+3+4&gt;);\n</code></pre>\n<p>But this doesn't apply to the example <code>g</code> functions above.  <code>T*</code> and <code>decltype(q)*</code> might be considered functionally equivalent under some analogous definition of equivalence of type, but section 14.5.6.1 only spells out replacement of expressions, not types.</p>\n", "AcceptedAnswerId": "14426927", "Title": "Function template signatures", "CreationDate": "2013-01-20T01:46:45.787", "Id": "14420908", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-01-23T16:22:02.780", "LastEditorUserId": "459640", "LastActivityDate": "2013-01-23T16:22:02.780", "Score": "4", "OwnerUserId": "459640", "Tags": "<c++><templates><language-lawyer>", "AnswerCount": "1"}});