post_cb({"27802892": {"ViewCount": "1399", "Body": "<p>I have mostly convinced myself that I have encountered some g++ 4.8.3 bug, but I thought I would ask this list first because I have very little experience with setjmp/longjmp.  I have simplified my code in question to the following foo.cxx:</p>\n<pre><code>#include &lt;setjmp.h&gt;\n#include &lt;string.h&gt;\n\n// Changing MyStruct to be just a single int makes the compiler happy.\nstruct MyStruct\n{\n    int a;\n    int b;\n};\n\n// Setting MyType to int makes the compiler happy.\n#ifdef USE_STRUCT\ntypedef MyStruct MyType;\n#elif USE_INT\ntypedef int MyType;\n#endif\n\nvoid SomeFunc(MyType val)\n{\n}\n\nstatic void static_func(MyType val)\n{\n    SomeFunc(val);\n}\n\nint main(int argc, char **argv)\n{\n    jmp_buf env;\n    if (setjmp(env))\n    {\n        return 1;\n    }\n\n    MyType val;\n#ifdef USE_STRUCT\n    val.a = val.b = 0;\n#elif USE_INT\n    val = 0;\n#endif\n    // Enabling the below memset call makes the compiler happy.\n    //memset(&amp;val, 0, sizeof(val));\n\n    // Iterating 1 or 2 times makes the compiler happy.\n    for (unsigned i = 0; i &lt; 3; i++)\n    {\n        // calling SomeFunc() directly makes the compiler happy.\n        static_func(val);\n    }\n    return 0;\n}\n</code></pre>\n<p>I use g++ 4.8.3 to compile this code.  What's interesting to me is that when I define USE_STRUCT, the compilation fails but succeeds with USE_INT.  There are comments in the code that further indicate how to make compilation succeed with USE_STRUCT.  Compilation only fails also with the -fPIC option to g++, but this is a required argument in my environment.</p>\n<p>To see the compilation error:</p>\n<pre class=\"lang-none prettyprint-override\"><code>g++ -DUSE_STRUCT -Wextra -Wno-unused-parameter -O3 -Werror -fPIC foo.cxx\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code>foo.cxx: In function \u2018int main(int, char**)\u2019:\nfoo.cxx:26:5: error: variable \u2018val\u2019 might be clobbered by \u2018longjmp\u2019 or \u2018vfork\u2019 [-Werror=clobbered]\n</code></pre>\n<p>But using a simple int is OK:</p>\n<pre class=\"lang-none prettyprint-override\"><code>g++ -DUSE_INT -Wextra -Wno-unused-parameter -O3 -Werror -fPIC foo.cxx\n</code></pre>\n<p>Can someone please explain to me why val might be clobbered if it is a struct but not if it is an int?  Any insights on the other ways to make compilation succeed with the struct, as indicated in the comments in the code?  Or is this pointing to a compiler bug?</p>\n<p>Any insights and comments are greatly appreciated.</p>\n", "Title": "inconsistent warning: variable might be clobbered by \u2018longjmp\u2019 or \u2018vfork\u2019", "CreationDate": "2015-01-06T16:27:55.000", "LastActivityDate": "2015-01-06T19:16:38.910", "CommentCount": "6", "LastEditDate": "2015-01-06T17:31:36.893", "PostTypeId": "1", "LastEditorUserId": "1392132", "Id": "27802892", "Score": "7", "OwnerUserId": "4424516", "Tags": "<c++><g++4.8><longjmp><setjmp>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27802892_27805575_0": {"length": 16, "quality": 1.0, "section_id": 6967}}, "n3337": {"so_27802892_27805575_0": {"length": 16, "quality": 1.0, "section_id": 6714}}, "n4659": {"so_27802892_27805575_0": {"length": 16, "quality": 1.0, "section_id": 8467}}}, "27805612": {"Id": "27805612", "PostTypeId": "2", "Body": "<p>There are several factors at work here:</p>\n<ol>\n<li><code>struct</code> instead of <code>int</code></li>\n<li>not using <code>memset</code> (I admit I don't understand how this can make things worse)</li>\n<li>iterating the loop more than twice -- if you only iterate twice, the compiler unrolls the loop</li>\n<li>the <code>-fPIC</code> command-line option (this produces position-independent code)</li>\n</ol>\n<p>Only if all four of these factors are present does the compiler produce a warning. It seems that they constitute a perfect storm for the optimiser, which has a kind of nervous breakdown (see below). If any of these factors is absent, the compiler just optimises everything away to nothing, so it can just ignore the <code>setjmp</code>.</p>\n<p>Whether this is a bug is open to question -- the code presumably still works (although I haven't tested it). But in any case the problem seems to have been fixed in version 4.9, so the obvious solution is to upgrade.</p>\n<p>Here is the machine code (NSFW):</p>\n<pre><code>SomeFunc(MyStruct):\n    rep; ret\nmain:\n    pushq   %r12\n    pushq   %rbp\n    pushq   %rbx\n    subq    $224, %rsp\n    leaq    16(%rsp), %rdi\n    call    _setjmp@PLT\n    testl   %eax, %eax\n    movl    %eax, %ebp\n    jne .L5\n    movl    $3, %ebx\n    movabsq $-4294967296, %r12\n.L4:\n    movq    8(%rsp), %rdx\n    andq    %r12, %rdx\n    movl    %edx, %eax\n    movq    %rax, %rdi\n    movq    %rax, 8(%rsp)\n    call    SomeFunc(MyStruct)@PLT\n    subl    $1, %ebx\n    jne .L4\n.L3:\n    addq    $224, %rsp\n    movl    %ebp, %eax\n    popq    %rbx\n    popq    %rbp\n    popq    %r12\n    ret\n.L5:\n    movl    $1, %ebp\n    jmp .L3\n</code></pre>\n", "LastActivityDate": "2015-01-06T19:16:38.910", "CommentCount": "0", "CreationDate": "2015-01-06T19:16:38.910", "ParentId": "27802892", "Score": "0", "OwnerUserId": "428857"}, "27805575": {"Id": "27805575", "PostTypeId": "2", "Body": "<p><code>setjmp()</code> saves the current stack. Since it's called before the declaration of <code>val</code>, that variable won't be in the saved stack.</p>\n<p>After <code>setjmp()</code>, the variable is initialized and if the code later jumps back to the <code>setjmp</code> point, the variable will be initialized again, clobbering the old variable. If there would be a non-trivial destructor that should be called on the old instance, this is undefined behavior (\u00a718.10/4):</p>\n<blockquote>\n<p id=\"so_27802892_27805575_0\">A <code>setjmp</code>/<code>longjmp</code> call pair has undefined behavior if replacing the <code>setjmp</code> and <code>longjmp</code> by <code>catch</code> and <code>throw</code> would invoke any non-trivial destructors for any automatic objects.</p>\n</blockquote>\n<p>Likely the destructor of the old instance won't be called. My guess would be that gcc doesn't warn for primitive types, since they don't have destructors, but warns for more complicated types where this might be problematic.</p>\n", "LastActivityDate": "2015-01-06T19:14:37.113", "CommentCount": "2", "CreationDate": "2015-01-06T19:14:37.113", "ParentId": "27802892", "Score": "2", "OwnerUserId": "56338"}});