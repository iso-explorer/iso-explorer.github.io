post_cb({"bq_ids": {"n4140": {"so_12987834_12988714_0": {"length": 14, "quality": 0.7, "section_id": 6148}}, "n3337": {"so_12987834_12988714_0": {"length": 14, "quality": 0.7, "section_id": 5911}}, "n4659": {"so_12987834_46430638_3": {"length": 5, "quality": 0.625, "section_id": 8018}, "so_12987834_12988714_0": {"length": 14, "quality": 0.7, "section_id": 7644}}}, "12987869": {"Id": "12987869", "PostTypeId": "2", "Body": "<p>What about:</p>\n<pre><code>const T max_power_of_two = (std::numeric_limits&lt;T&gt;::max() &gt;&gt; 1) + 1;\n</code></pre>\n", "LastActivityDate": "2012-10-20T11:17:51.517", "CommentCount": "0", "CreationDate": "2012-10-20T11:17:51.517", "ParentId": "12987834", "Score": "3", "OwnerUserId": "697352"}, "12988714": {"Id": "12988714", "PostTypeId": "2", "Body": "<p>To get the highest power of 2 representable by a certain integer type you may use <code>limits.h</code> instead of the <code>sizeof</code> operator. For instance:</p>\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt;\n\nint main() {\n\n  int max   = INT_MAX;\n  int hmax  = max&gt;&gt;1;\n  int mpow2 = max ^ hmax;\n\n  printf(\"The maximum representable integer is %d\\n\",max);\n  printf(\"The maximum representable power of 2 is %d\\n\",mpow2);\n  return 0;\n}\n</code></pre>\n<p>This should always work as the right shift of a positive integer is always defined. Quoting from the standard C section 6.5.7.5 (Bitwise shift operator):</p>\n<blockquote>\n<p id=\"so_12987834_12988714_0\">The result of <strong>E1</strong> &gt;&gt; <strong>E2</strong> is <strong>E1</strong> right-shifted <strong>E2</strong> bit positions. If <strong>E1</strong>\n  has an unsigned type or if <strong>E1</strong> has a signed type and a nonnegative\n  value, the value of the result is the integral part of the quotient of\n  <strong>E1</strong> divided by the quantity, 2 raised to the power <strong>E2</strong>.</p>\n</blockquote>\n<p>If the use of <code>sizeof</code> is mandatory you can use:</p>\n<pre><code>1 &lt;&lt; (CHAR_BIT*sizeof(param)-1)\n</code></pre>\n<p>for unsigned integer types and:</p>\n<pre><code>1 &lt;&lt; (CHAR_BIT*sizeof(param)-2)\n</code></pre>\n<p>for signed integer types. The lines above will work only in the case of integer types <strong>without padding bits</strong>. The part of the standard C ensuring these lines to work is in section 6.2.6.2. In particular:</p>\n<blockquote>\n<p id=\"so_12987834_12988714_1\">For unsigned integer types other than <strong>unsigned char</strong>, the bits of the\n  object representation shall be divided into two groups: value bits and\n  padding bits (there need not be any of the latter). If there are N\n  value bits, each bit shall represent a different power of 2 between 1\n  and 2N-1, so that objects of that type shall be capable of\n  representing values from 0 to 2N - 1 using a pure binary\n  representation; this shall be known as the value representation.</p>\n</blockquote>\n<p>guarantees the first method to work while:</p>\n<blockquote>\n<p id=\"so_12987834_12988714_2\">For signed integer types, the bits of the object representation shall\n  be divided into three groups: value bits, padding bits, and the sign\n  bit. There need not be any padding bits; there shall be exactly one\n  sign bit.</p>\n<p id=\"so_12987834_12988714_3\">...</p>\n<p id=\"so_12987834_12988714_4\">A valid (non-trap) object representation of a signed integer type\n  where the sign bit is zero is a valid object representation of the\n  corresponding unsigned type, and shall represent the same value.</p>\n</blockquote>\n<p>explains why the second line give the right answer.</p>\n", "LastEditorUserId": "771663", "LastActivityDate": "2012-10-20T21:05:38.657", "Score": "2", "CreationDate": "2012-10-20T13:01:21.970", "ParentId": "12987834", "CommentCount": "3", "OwnerUserId": "771663", "LastEditDate": "2012-10-20T21:05:38.657"}, "12987863": {"Id": "12987863", "PostTypeId": "2", "Body": "<p>Setting most significant bit of your a variable of that parameter size will give you the highest power of 2.</p>\n<pre><code>1 &lt;&lt; (8*sizeof(param)-1)\n</code></pre>\n", "LastActivityDate": "2012-10-20T11:17:06.757", "CommentCount": "7", "CreationDate": "2012-10-20T11:17:06.757", "ParentId": "12987834", "Score": "4", "OwnerUserId": "716445"}, "12987834": {"ViewCount": "463", "Body": "<p>Is there a way in C/C++ to compute the maximum power of two that is representable by a certain data type using the sizeof operator?</p>\n<p>For example, say I have an <code>unsigned short int</code>. Its values can range between <code>0</code> and <code>65535</code>.\nTherefore the maximum power of two that an <code>unsigned short int</code> can contain is <code>32768</code>.</p>\n<p>I pass this <code>unsigned short int</code> to a function and I have (at the moment) and algorithm that looks like this:</p>\n<pre><code>if (ushortParam &gt; 32768) {\n    ushortParam = 32768; // Bad hardcoded literals\n}\n</code></pre>\n<p>However, in the future, I may want to change the variable type to incorporate larger powers of two. Is there a type-independent formula using sizeof() that can achieve the following:</p>\n<pre><code>if (param &gt; /*Some function...*/sizeof(param) )\n{\n    param = /*Some function...*/sizeof(param);\n}\n</code></pre>\n<p>Note the parameter will never require floating-point precision - integers only.</p>\n", "AcceptedAnswerId": "12987863", "Title": "Using sizeof to get maximum power of two", "CreationDate": "2012-10-20T11:13:02.777", "Id": "12987834", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-09-27T15:41:55.377", "Score": "1", "OwnerUserId": "1618592", "Tags": "<c++><c><types><sizeof>", "AnswerCount": "4"}, "46430638": {"Id": "46430638", "PostTypeId": "2", "Body": "<p>The accepted answer will probably work on Posix platforms, but is not general C/C++.  It assumes that CHAR_BIT is 8, doesn't specify the type, and assumes that the type has no padding bits.</p>\n<p>Here are more general versions for any/all unsigned integer types and don't require including any headers, dependencies, etc.:</p>\n<pre><code>#define MAX_VAL(UNSIGNED_TYPE) ((UNSIGNED_TYPE) -1)\n\n#define MAX_POW2(UNSIGNED_TYPE) (~(MAX_VAL(UNSIGNED_TYPE) &gt;&gt; 1))\n\n#define MAX_POW2_VER2(UNSIGNED_TYPE) (MAX_VAL(UNSIGNED_TYPE) ^ (MAX_VAL(UNSIGNED_TYPE) &gt;&gt; 1))\n\n#define MAX_POW2_VER3(UNSIGNED_TYPE) ((MAX_VAL(UNSIGNED_TYPE) &gt;&gt; 1) + 1)\n</code></pre>\n<p>The standards, even C90, guarantee that casting -1 to an unsigned type always yields the maximum value that type can represent.  From there, all of the bitwise operators above are well defined.</p>\n<p><a href=\"http://c0x.coding-guidelines.com/6.3.1.3.html\" rel=\"nofollow noreferrer\">http://c0x.coding-guidelines.com/6.3.1.3.html</a></p>\n<blockquote>\n<p id=\"so_12987834_46430638_0\">6.3.1.3 Signed and unsigned integers</p>\n<p id=\"so_12987834_46430638_1\">682 When a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged.</p>\n<p id=\"so_12987834_46430638_2\">683 <strong>Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.</strong></p>\n<p id=\"so_12987834_46430638_3\">684 Otherwise, the new type is signed and the value cannot be represented in it;</p>\n<p id=\"so_12987834_46430638_4\">685 either the result is implementation-defined or an implementation-defined signal is raised.</p>\n</blockquote>\n<p>The maximum value of an unsigned type is one less than a power of 2 and has all value bits set.  The above expressions result in the highest bit alone being set, which is the maximum power of 2 that the type can represent.</p>\n<p><a href=\"http://c0x.coding-guidelines.com/6.2.6.2.html\" rel=\"nofollow noreferrer\">http://c0x.coding-guidelines.com/6.2.6.2.html</a></p>\n<blockquote>\n<p id=\"so_12987834_46430638_5\">6.2.6.2 Integer types</p>\n<p id=\"so_12987834_46430638_6\">593 For unsigned integer types other than unsigned char, the bits of the object representation shall be divided into two groups: value bits and padding bits (there need not be any of the latter).</p>\n<p id=\"so_12987834_46430638_7\">594 If there are N value bits, each bit shall represent a different power of 2 between 1 and 2^(N - 1), so that objects of that type shall be capable of representing values from 0 to 2^N \u2212 1 using a pure binary representation;</p>\n<p id=\"so_12987834_46430638_8\">595 this shall be known as the value representation.</p>\n<p id=\"so_12987834_46430638_9\">596 The values of any padding bits are unspecified.</p>\n</blockquote>\n", "LastEditorUserId": "4564515", "LastActivityDate": "2017-09-27T15:41:55.377", "Score": "0", "CreationDate": "2017-09-26T15:37:38.633", "ParentId": "12987834", "CommentCount": "0", "OwnerUserId": "4564515", "LastEditDate": "2017-09-27T15:41:55.377"}});