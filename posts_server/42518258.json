post_cb({"bq_ids": {"n4140": {"so_42518258_42518371_4": {"length": 16, "quality": 1.0, "section_id": 7043}, "so_42518258_42518371_1": {"length": 32, "quality": 1.0, "section_id": 7043}, "so_42518258_42518371_2": {"length": 6, "quality": 1.0, "section_id": 7043}, "so_42518258_42518371_0": {"length": 12, "quality": 1.0, "section_id": 7041}}, "n3337": {"so_42518258_42518371_4": {"length": 15, "quality": 0.9375, "section_id": 6788}, "so_42518258_42518371_1": {"length": 32, "quality": 1.0, "section_id": 6788}, "so_42518258_42518371_2": {"length": 6, "quality": 1.0, "section_id": 6788}, "so_42518258_42518371_0": {"length": 12, "quality": 1.0, "section_id": 6786}}, "n4659": {"so_42518258_42518371_0": {"length": 12, "quality": 1.0, "section_id": 8538}, "so_42518258_42518371_1": {"length": 32, "quality": 1.0, "section_id": 8540}, "so_42518258_42518371_2": {"length": 6, "quality": 1.0, "section_id": 8540}, "so_42518258_42518371_4": {"length": 16, "quality": 1.0, "section_id": 8540}}}, "42518371": {"Id": "42518371", "PostTypeId": "2", "Body": "<p>You have <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow noreferrer\">UB</a>; C++14 [basic.def.odr]/4:</p>\n<blockquote>\n<p id=\"so_42518258_42518371_0\">Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required.</p>\n</blockquote>\n<p>and /6:</p>\n<blockquote>\n<p id=\"so_42518258_42518371_1\">There can be more than one definition of a class type (Clause 9) \u2026 in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named <code>D</code> defined in more than one translation unit, then</p>\n<ul>\n<li><p id=\"so_42518258_42518371_2\">each definition of <code>D</code> shall consist of the same sequence of tokens; and</p></li>\n<li><p id=\"so_42518258_42518371_3\">\u2026</p></li>\n</ul>\n<p id=\"so_42518258_42518371_4\">\u2026 If the definitions of <code>D</code> satisfy all these requirements, then the behavior is as if there were a single definition of <code>D</code>. If the definitions of <code>D</code> do not satisfy these requirements, then the behavior is undefined.</p>\n</blockquote>\n", "LastEditorUserId": "636019", "LastActivityDate": "2017-02-28T20:48:25.890", "Score": "2", "CreationDate": "2017-02-28T20:43:09.997", "ParentId": "42518258", "CommentCount": "0", "LastEditDate": "2017-02-28T20:48:25.890", "OwnerUserId": "636019"}, "42518258": {"ViewCount": "41", "Body": "<p>I've come across a situation that I'm not sure whether it can be considered a bug in the code, a bug/misuse of the compiler/linker or some misunderstanding of the C++ standard.</p>\n<p>Two different source files (containing unit tests in the real code) declare a structure with the same name, but (slightly) different members. Both source files reference a header containing a helper method which is templated and returns a vector of the template (performs deserialization in real code).</p>\n<p>After compiling with no errors or warnings, I realized that the template was specialized for only one type and used in both translation units (although the types are declared in the .cpp files), leading to wrong results.</p>\n<p>Below is a short proof of concept:</p>\n<p><em>Main.cpp</em></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n#include \"Header.h\"\n\nstruct Foo\n{\n    std::string name = \"FooMain\";\n};\n\nvoid test1()\n{\n    auto v = getVector&lt;Foo&gt;();\n    std::cout &lt;&lt; v[0].name &lt;&lt; ' '\n              &lt;&lt; v[1].name &lt;&lt; '\\n';\n}\n\nvoid test2();\n\nint main()\n{\n    test1();\n    test2();\n}\n</code></pre>\n<p><em>Second.cpp</em></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n#include \"Header.h\"\n\nstruct Foo\n{\n    std::string name = \"FooSecond\";\n    int extraInfo = 1;\n};\n\nvoid test2()\n{\n    auto v = getVector&lt;Foo&gt;();\n    std::cout &lt;&lt; v[0].name &lt;&lt; ' ' &lt;&lt; v[0].extraInfo &lt;&lt; ' '\n              &lt;&lt; v[1].name &lt;&lt; ' ' &lt;&lt; v[1].extraInfo &lt;&lt; '\\n';\n}\n</code></pre>\n<p><em>Header.h</em></p>\n<pre><code>#ifndef _HEADER_H_\n#define _HEADER_H_\n\n#include &lt;vector&gt;\n\ntemplate&lt;typename T&gt;\nauto getVector()\n{\n    std::vector&lt;T&gt; result;\n\n    result.push_back({});\n    result.push_back({});\n\n    return result;\n}\n\n#endif\n</code></pre>\n<p>The output is (numbers are different every time), under both Visual Studio 2015 and gcc 4.9.2 (32-bit, Windows)</p>\n<pre><code>FooMain FooMain\nFooMain 1299148614 FooMain 1097202845\n</code></pre>\n<p>Commenting out the code of <code>test1()</code> makes <code>test2()</code> return the expected output of <code>FooSecond 1 FooSecond 1</code>.</p>\n<p>Any idea what may be causing this? \nThank you</p>\n", "AcceptedAnswerId": "42518371", "Title": "Local structure influences different translation unit via use of common templated function", "CreationDate": "2017-02-28T20:36:01.263", "Id": "42518258", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-02-28T20:48:25.890", "Score": "1", "OwnerUserId": "7143494", "Tags": "<c++><gcc><visual-c++><c++14>", "AnswerCount": "2"}, "42518463": {"Id": "42518463", "PostTypeId": "2", "Body": "<p>The template code is identified only by it's name, which is the same in this case, even though the structs are different.\nThe best practice here, in my opinion, is to move one of the structs to a different namespace.</p>\n", "LastActivityDate": "2017-02-28T20:48:19.147", "Score": "0", "CreationDate": "2017-02-28T20:48:19.147", "ParentId": "42518258", "CommentCount": "0", "OwnerUserId": "6640227"}});