post_cb({"35011017": {"CommentCount": "5", "ViewCount": "108", "PostTypeId": "1", "LastEditorUserId": "675100", "CreationDate": "2016-01-26T09:53:51.037", "LastActivityDate": "2016-01-26T11:05:08.020", "Title": "How to catch an error resulting from an invalid memory block being destroyed", "AcceptedAnswerId": "35011292", "LastEditDate": "2016-01-26T10:08:44.467", "Id": "35011017", "Score": "0", "Body": "<p>The following code makes it so that a destructor is called twice.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;exception&gt;\n#include &lt;cstdlib&gt; \n\nvoid myterminate()\n{\n    std::cout &lt;&lt; \"terminate\\n\";\n    abort();\n}\n\nclass data \n{\n    int a;\npublic:\n    data(int a) : a(a) { std::cout &lt;&lt; \"ctor \" &lt;&lt; a &lt;&lt; \"\\n\"; }\n    ~data() { std::cout &lt;&lt; \"dtor \" &lt;&lt; a &lt;&lt; \"\\n\"; }\n    static data failure(int a) { return data(a); }\n};\n\nvoid main()\n{\n    std::set_terminate(myterminate); //terminate is not called\n    try\n    {\n        std::unique_ptr&lt;data&gt; u;\n        u.reset(&amp;data::failure(1));\n        std::cout &lt;&lt; \"no worries\\n\"; //this prints \n        //destructor called at try-block end and attempt to destruct an invalid memory block.\n    }\n    catch (...)\n    {\n        std::cout &lt;&lt; \"caught\\n\"; //this can not catch the error\n    }\n    std::cout &lt;&lt; \"end\\n\"; //program crash, will not be called\n}\n</code></pre>\n<p>How would I catch an error like this in production?</p>\n<p>On a Release build the program crashes. On a Debug build it the on my system is:\n<a href=\"https://i.stack.imgur.com/CTlW5.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/CTlW5.png\"/></a></p>\n", "Tags": "<c++><c++11><unique-ptr><terminate-handler>", "OwnerUserId": "536874", "AnswerCount": "3"}, "35011317": {"ParentId": "35011017", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>First as noted in the comments you declare <code>main</code> as <code>void main</code> where the standard only allows two forms in \u00a7 3.6.1</p>\n<blockquote>\n<ol start=\"2\">\n<li><p id=\"so_35011017_35011317_0\">An implementation shall not predefine the main function. This function\n  shall not be overloaded. <strong>It shall have a declared return type of type\n  int</strong>, but otherwise its type is implementation-defined. An\n  implementation shall allow both </p>\n<p id=\"so_35011017_35011317_1\">(2.1) \u2014 a function of () returning int and </p>\n<p id=\"so_35011017_35011317_2\">(2.2) \u2014 a function of (int, pointer to pointer to char) returning int</p></li>\n</ol>\n</blockquote>\n<p>Secondly you are resetting your <code>unique_ptr</code> to manage a temporary which when <code>unique_ptr</code> gets destroyed at the end of its scope will be <code>delete</code>d which results in undefined behavior. You can't predict/catch errors resulting from undefined behavior.</p>\n<p>What you should do (if you really want to use dynamically allocated memory) you can return a pointer to object on the heap:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;exception&gt;\n#include &lt;cstdlib&gt; \n\nvoid myterminate()\n{\n    std::cout &lt;&lt; \"terminate\\n\";\n    abort();\n}\n\nclass data \n{\n    int a;\npublic:\n    data(int a) : a(a) { std::cout &lt;&lt; \"ctor \" &lt;&lt; a &lt;&lt; \"\\n\"; }\n    ~data() { std::cout &lt;&lt; \"dtor \" &lt;&lt; a &lt;&lt; \"\\n\"; }\n    static data* failure(int a) { return new data(a); }\n};\n\nint main()\n{\n    std::set_terminate(myterminate); //terminate is not called\n    try\n    {\n        std::unique_ptr&lt;data&gt; u;\n        u.reset(data::failure(1));\n        std::cout &lt;&lt; \"no worries\\n\"; //this prints \n        //destructor called at try-block end and attempt to destruct an invalid memory block.\n    }\n    catch (...)\n    {\n        std::cout &lt;&lt; \"caught\\n\"; //this can not catch the error\n    }\n    std::cout &lt;&lt; \"end\\n\"; //program crash, will not be called\n}\n</code></pre>\n<p>Online code: <a href=\"http://melpon.org/wandbox/permlink/pdiijgDxBshVOYRu\" rel=\"nofollow\">http://melpon.org/wandbox/permlink/pdiijgDxBshVOYRu</a></p>\n", "OwnerUserId": "675100", "LastEditorUserId": "675100", "LastEditDate": "2016-01-26T10:12:17.927", "Id": "35011317", "Score": "0", "CreationDate": "2016-01-26T10:07:48.063", "LastActivityDate": "2016-01-26T10:12:17.927"}, "35011292": {"ParentId": "35011017", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_35011017_35011292_0\">How would I catch an error like this in production?</p>\n</blockquote>\n<p>You cannot. The standard says that invalid memory access has undefined behaviour. There is no standard way to \"catch\" UB. Catching and terminate handler are for exceptions, which are <em>defined</em> behaviour.</p>\n<p>What you could do, is use the debug build in production, and run it with valgrind or similar tool, so that you can at least analyze the error.</p>\n", "OwnerUserId": "2079303", "PostTypeId": "2", "Id": "35011292", "Score": "4", "CreationDate": "2016-01-26T10:06:32.370", "LastActivityDate": "2016-01-26T10:06:32.370"}, "bq_ids": {"n4140": {"so_35011017_35011317_2": {"section_id": 7146, "quality": 1.0, "length": 7}, "so_35011017_35011317_0": {"section_id": 7146, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_35011017_35011317_2": {"section_id": 3073, "quality": 0.8571428571428571, "length": 6}, "so_35011017_35011317_0": {"section_id": 6890, "quality": 0.8095238095238095, "length": 17}}, "n4659": {"so_35011017_35011317_2": {"section_id": 8647, "quality": 1.0, "length": 7}, "so_35011017_35011317_0": {"section_id": 8647, "quality": 0.9047619047619048, "length": 19}}}, "35012371": {"ParentId": "35011017", "CommentCount": "0", "Body": "<p>\"try/catch\" such mistakes will not catch, because in this case a great probability of a crash. But a moment of destruction you can try to catch, using signals and more menne dignified exit the program.\nLooking away: #include , signal(), sig_atomic_t ...</p>\n", "OwnerUserId": "5401215", "PostTypeId": "2", "Id": "35012371", "Score": "1", "CreationDate": "2016-01-26T11:05:08.020", "LastActivityDate": "2016-01-26T11:05:08.020"}});