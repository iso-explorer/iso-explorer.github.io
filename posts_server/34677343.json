post_cb({"34677577": {"Body": "<p><strong>Yes</strong> you can read the other member in this <strong>particular case</strong>.</p>\n<p>This is what the C++11/14 standard has to say:</p>\n<blockquote>\n<p id=\"so_34677343_34677577_0\">9.5 - <em>Unions</em></p>\n<p id=\"so_34677343_34677577_1\">In a union, at most one of the non-static data members can be active\n  at any time, that is, the value of at most one of the non-static data\n  members can be stored in a union at any time.</p>\n</blockquote>\n<p>But the note immediately after the section makes your particular instance legal since one special guarantee is made <em>in order to simplify the use of unions</em>:</p>\n<blockquote>\n<p id=\"so_34677343_34677577_2\">[ <em>Note</em>: If a standard-layout union contains several standard-layout\n  structs that share a common initial sequence (9.2), and if an object\n  of this standard-layout union type contains one of the standard-layout\n  structs, it is permitted to inspect the common initial sequence of any\n  of standard-layout struct members; see 9.2. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>And your <code>struct</code>s <strong>do share</strong> a common initial sequence:</p>\n<blockquote>\n<p id=\"so_34677343_34677577_3\">9.2.16 - <em>Class members</em></p>\n<p id=\"so_34677343_34677577_4\">The common initial sequence of two standard-layout\n  struct (Clause 9) types is the longest sequence of non- static data\n  members and bit-fields in declaration order, starting with the first\n  such entity in each of the structs, such that corresponding entities\n  have layout-compatible types and either neither entity is a bit-field\n  or both are bit-fields with the same width.</p>\n</blockquote>\n", "CreationDate": "2016-01-08T12:51:23.593", "ParentId": "34677343", "CommentCount": "5", "LastEditDate": "2016-01-08T13:20:12.107", "Id": "34677577", "PostTypeId": "2", "LastActivityDate": "2016-01-08T13:20:12.107", "LastEditorUserId": "2666289", "CommunityOwnedDate": "2016-01-08T12:58:07.620", "Score": "12", "OwnerUserId": "2380830"}, "bq_ids": {"n4140": {"so_34677343_34677577_2": {"length": 27, "quality": 0.9, "section_id": 5913}, "so_34677343_34677577_1": {"length": 19, "quality": 1.0, "section_id": 5913}}, "n3337": {"so_34677343_34677577_2": {"length": 27, "quality": 0.9, "section_id": 5685}, "so_34677343_34677577_1": {"length": 19, "quality": 1.0, "section_id": 5685}}, "n4659": {"so_34677343_34677577_2": {"length": 26, "quality": 0.8666666666666667, "section_id": 7404}, "so_34677343_34677577_4": {"length": 34, "quality": 0.8947368421052632, "section_id": 7359}, "so_34677343_34677577_1": {"length": 19, "quality": 1.0, "section_id": 7404}}}, "34677343": {"ViewCount": "298", "Body": "<p>I have something like this:</p>\n<pre><code>union DataXYZ\n{\n    struct complex_t\n    {\n        float real, imag;\n    } complex;\n\n    struct vector_t\n    {\n        float magnitude, phase;\n    } vector;\n};\n</code></pre>\n<p>I have some vectors of these, being general-purpose workspace memory, where I use the fields accordingly after the semantic context. </p>\n<p>I know it's undefined behaviour to read a field in a union, when the last active member was another field (and type?). Does this matter when the types and layout match exactly?</p>\n<p>I've been commenting on some other similar questions, asking for references that guarantee the behaviour, but nothing came up yet - hence this question.</p>\n", "AcceptedAnswerId": "34677577", "Title": "Accessing same-type inactive member in unions", "CreationDate": "2016-01-08T12:39:31.013", "Id": "34677343", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-01-08T13:20:12.107", "Score": "14", "OwnerUserId": "1287254", "Tags": "<c++><undefined-behavior><unions>", "AnswerCount": "1"}});