post_cb({"12074544": {"ParentId": "12074058", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-08-22T13:44:31.423", "Score": "6", "LastEditorUserId": "36565", "LastEditDate": "2012-08-22T14:01:03.290", "Id": "12074544", "OwnerUserId": "36565", "Body": "<p><em>[I am assuming that in your program the code is: <code>void (bar::*p)() = &amp;bar::foobar;</code>]</em></p>\n<p>The problem is not that the <em>using declaration</em> does not bring the identifier into space, but the semantics of <code>&amp;bar::foobar</code>. I am considering (I would have done it if I had the time) refilling a Defect Report with this. There is already one such report.</p>\n<p>Basically the problem is that the using declaration brings the base function into scope for lookup in the derived type, and the access specifiers for the expression <code>&amp;bar::foobar</code> will be checked against <code>bar</code>. <strong>But</strong>, the result of the expression <code>&amp;bar::foobar</code> is of type <code>void (foo::*)()</code>, not <code>void (bar::*)()</code>. Now, after evaluation of <code>&amp;bar::foobar</code> if you try to use that as a <code>void (bar::*)()</code> the compiler will try to perform the conversion of the pointer to member but will fail because <code>foo</code> is a <code>protected</code> base of <code>bar</code>, and in the context of <code>main</code> you don't have access to that relationship.</p>\n<p>Note that I consider that to be a defect in the language for two reasons: first it breaks your code: <code>void (bar::*p)() = &amp;bar::foobar;</code> surprisingly fails to compile. Secondly, it breaks access protections in other cases:</p>\n<pre><code>class base {\nprotected: void f() {}\n};\nstruct derived : base {\n   void foo( base&amp; b ) {\n       b.f();                // Error\n       b.*(&amp;derived::f)();   // OK\n   }\n};\n</code></pre>\n<p>This problem is actually symmetric to yours, while in yours the surprising type of the address-of-member operation inhibits your use case when it shouldn't, in this case it allows an usage that is against the intent of <code>protected</code>.</p>\n<p>Related links:</p>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#203\" rel=\"nofollow\">DR 203 - Type of address-of-member expression</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1007\" rel=\"nofollow\">DR 1007 - Protected access and pointers to members</a></li>\n</ul>\n<hr>\n<p>After the comment on using <code>bind</code>, it might not be the case that you are trying to convert the pointer to member to a pointer to member of <code>bar</code> directly, but somewhere inside <code>bind</code> code will be generated to apply the pointer to member to an instance of <code>bar</code>, and that requires the conversion.</p>\n</hr>", "LastActivityDate": "2012-08-22T14:01:03.290"}, "12074308": {"ParentId": "12074058", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2012-08-22T13:31:02.813", "Score": "3", "LastEditorUserId": "204847", "LastEditDate": "2012-08-22T14:22:39.927", "Id": "12074308", "OwnerUserId": "204847", "Body": "<p>NOTE: this answers the original question; David Rodriguez has answered the update.</p>\n<p>Your code is fine. According to the language standard:</p>\n<blockquote>\n<p id=\"so_12074058_12074308_0\">7.3.3/2 Every <em>using-declaration</em> is a <em>declaration</em> and a <em>member-declaration</em></p>\n</blockquote>\n<p>That means you are declaring <code>foobar</code> to be a member of <code>bar</code> as well as <code>foo</code>, and so referring to it as <code>bar::foobar</code> is just as legitimate as <code>foo::foobar</code>.</p>\n<p>My compiler (GCC) agrees with this; if yours doesn't, then it would appear to have a bug.</p>\n", "LastActivityDate": "2012-08-22T14:22:39.927"}, "12074058": {"CommentCount": "6", "ViewCount": "128", "PostTypeId": "1", "LastEditorUserId": "135326", "CreationDate": "2012-08-22T13:16:54.703", "LastActivityDate": "2012-08-22T14:22:39.927", "Title": "Why does using declaration not expose pointer to member", "AcceptedAnswerId": "12074544", "LastEditDate": "2012-08-22T13:58:52.920", "Id": "12074058", "Score": "3", "Body": "<p>Consider:</p>\n<pre><code>struct foo\n{\n    void foobar(){}\n};\n\nstruct bar : protected foo\n{\n    using foo::foobar;\n};\n\nint main()\n{\n    bar b;\n    b.foobar(); // Fine\n    &amp;bar::foobar; // Not fine\n}\n</code></pre>\n<p>I'm wondering what the rationale for letting using declarations expose the member, but not a pointer to it. In fact it would seem all using declarations that changes access level works for everything except taking the address of an exposed function.</p>\n<p><strong>UPDATE</strong>: An example which resembles my real use case better:</p>\n<pre><code>#include \"boost/bind.hpp\"\n\nstruct foo\n{\n    void foobar() {}\n};\n\nstruct bar : protected foo\n{\n    using foo::foobar;\n    bar() { boost::bind( &amp;bar::foobar, this )(); } // Crashes VS2008, GCC 4.1.1 fails to compile as it tries to go through foo*\n};\n\nint main()\n{\n    bar b;\n}\n</code></pre>\n<p>However, Mike Seymours' explanation is spot on and explains why GCC fails. Thanks!</p>\n", "Tags": "<c++><visual-studio-2008>", "OwnerUserId": "135326", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_12074058_12074308_0": {"section_id": 5491, "quality": 0.8, "length": 4}}, "n3337": {"so_12074058_12074308_0": {"section_id": 5277, "quality": 0.8, "length": 4}}, "n4659": {"so_12074058_12074308_0": {"section_id": 6925, "quality": 0.8, "length": 4}}}});