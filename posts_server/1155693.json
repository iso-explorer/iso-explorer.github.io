post_cb({"1155693": {"ViewCount": "11295", "Body": "<p>The C++ standard seems to make no statement regarding side-effects on capacity by either \n<code>resize(n)</code>, with <code>n &lt; size()</code>, or <code>clear()</code>.</p>\n<p>It does make a statement about amortized cost of <code>push_back</code> and <code>pop_back</code> - O(1)</p>\n<p>I can envision an implementation that does the usual sort of capacity changes \nala CLRS Algorithms (e.g. double when enlarging, halve when decreasing <code>size to &lt; capacity()/4</code>).\n(Cormen Lieserson Rivest Stein)</p>\n<p>Does anyone have a reference for any implementation restrictions?</p>\n", "Title": "std::vector resize downward", "CreationDate": "2009-07-20T20:11:52.200", "LastActivityDate": "2017-05-11T21:37:06.313", "CommentCount": "0", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2017-05-11T20:35:35.633", "LastEditorDisplayName": "pgast", "OwnerDisplayName": "pgast", "LastEditorUserId": "1398841", "Id": "1155693", "Score": "22", "Tags": "<c++><stl><vector><resize>", "AnswerCount": "4"}, "7835619": {"Id": "7835619", "PostTypeId": "2", "Body": "<p>As i checked for gcc (mingw) the only way to free vector capacity is what mattnewport says.\nSwaping it with other teporary vector.\nThis code makes it for gcc.</p>\n<pre><code>template&lt;typename C&gt; void shrinkContainer(C &amp;container) {\n    if (container.size() != container.capacity()) {\n        C tmp = container;\n        swap(container, tmp);\n    }\n    //container.size() == container.capacity()\n}\n</code></pre>\n", "LastEditorUserId": "621706", "LastActivityDate": "2011-10-20T12:10:25.430", "Score": "0", "CreationDate": "2011-10-20T12:00:41.693", "ParentId": "1155693", "CommentCount": "0", "OwnerUserId": "621706", "LastEditDate": "2011-10-20T12:10:25.430"}, "1155721": {"Id": "1155721", "PostTypeId": "2", "Body": "<p>Actually, the standard does specify what should happen:</p>\n<p>This is from <code>vector</code>, but the theme is the same for all the containers (<code>list</code>, <code>deque</code>, etc...)</p>\n<blockquote>\n<p id=\"so_1155693_1155721_0\">23.2.4.2 vector capacity [lib.vector.capacity]</p>\n</blockquote>\n<p><code>void resize(size_type sz, T c = T());</code></p>\n<blockquote>\n<p id=\"so_1155693_1155721_1\">6) Effects:</p>\n</blockquote>\n<pre><code>if (sz &gt; size())\n    insert(end(), sz-size(), c);\nelse if (sz &lt; size())\n    erase(begin()+sz, end());\nelse\n    ; //do nothing\n</code></pre>\n<p>That is to say: If the size specified to <code>resize</code> is less than the number of elements, those elements will be erased from the container. Regarding <code>capacity()</code>, this depends on what <code>erase()</code> does to it.</p>\n<p>I cannot locate it in the standard, but I'm pretty sure <code>clear()</code> is defined to be:</p>\n<pre><code>void clear()\n{\n    erase(begin(), end());\n}\n</code></pre>\n<p>Therefore, the effects <code>clear()</code> has on <code>capacity()</code> is also tied to the effects <code>erase()</code> has on it. According to the standard:</p>\n<blockquote>\n<p id=\"so_1155693_1155721_2\">23.2.4.3 vector modifiers [lib.vector.modifiers]</p>\n</blockquote>\n<pre><code>iterator erase(iterator position);\niterator erase(iterator first, iterator last);\n</code></pre>\n<blockquote>\n<p id=\"so_1155693_1155721_3\">4) Complexity: The destructor of T is called the number of times equal to the number of the elements erased....</p>\n</blockquote>\n<p>This means that the elements will be destructed, but the memory will remain intact. <code>erase()</code> has no effect on capacity, therefore <code>resize()</code> and <code>clear()</code> also have no effect.</p>\n", "LastEditorUserId": "87234", "LastActivityDate": "2009-07-20T21:13:33.247", "Score": "20", "CreationDate": "2009-07-20T20:16:32.660", "ParentId": "1155693", "CommentCount": "5", "OwnerUserId": "87234", "LastEditDate": "2009-07-20T21:13:33.247"}, "bq_ids": {"n4140": {"so_1155693_1155721_3": {"length": 8, "quality": 0.8, "section_id": 989}}, "n3337": {"so_1155693_1155721_3": {"length": 8, "quality": 0.8, "section_id": 974}}, "n4659": {"so_1155693_1155721_3": {"length": 8, "quality": 0.8, "section_id": 1052}}}, "1155822": {"Id": "1155822", "PostTypeId": "2", "Body": "<p>The capacity will never decrease. I'm not sure if the standard states this explicitly, but it is implied: iterators and references to vector's elements must not be invalidated by <code>resize(n)</code> if <code>n &lt; capacity()</code>.</p>\n", "LastActivityDate": "2009-07-20T20:36:03.573", "CommentCount": "0", "CreationDate": "2009-07-20T20:36:03.573", "ParentId": "1155693", "Score": "4", "OwnerUserId": "89847"}, "1155710": {"Id": "1155710", "PostTypeId": "2", "Body": "<p>Calling <code>resize()</code> with a smaller size has no effect on the capacity of a <code>vector</code>. It will not free memory.</p>\n<p>The standard idiom for freeing memory from a <code>vector</code> is to <code>swap()</code> it with an empty temporary <code>vector</code>: <code>std::vector&lt;T&gt;().swap(vec);</code>. If you want to resize downwards you'd need to copy from your original vector into a new local temporary vector and then swap the resulting vector with your original.</p>\n<p><strong>Updated:</strong> C++11 added a member function <a href=\"http://en.cppreference.com/w/cpp/container/vector/shrink_to_fit\" rel=\"nofollow noreferrer\"><code>shrink_to_fit()</code></a> for this purpose, it's a non-binding request to reduce <code>capacity()</code> to <code>size()</code>.</p>\n", "LastEditorUserId": "1398841", "LastActivityDate": "2017-05-11T21:37:06.313", "Score": "31", "CreationDate": "2009-07-20T20:14:57.030", "ParentId": "1155693", "CommentCount": "3", "OwnerUserId": "139091", "LastEditDate": "2017-05-11T21:37:06.313"}});