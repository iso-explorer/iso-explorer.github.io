post_cb({"bq_ids": {"n4140": {"so_17471525_17472621_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 7168}, "so_17471525_17472621_2": {"length": 27, "quality": 0.84375, "section_id": 5394}}, "n3337": {"so_17471525_17472621_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 6912}, "so_17471525_17472621_2": {"length": 30, "quality": 0.9375, "section_id": 5188}}, "n4659": {"so_17471525_17472621_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 8676}, "so_17471525_17472621_2": {"length": 27, "quality": 0.84375, "section_id": 6819}}}, "17471525": {"ViewCount": "387", "Body": "<p>Consider the following C++11 program:</p>\n<pre><code>struct S {\n   S() {/* do something */ }\n} global_object;\n\nint main() {\n}\n</code></pre>\n<p>I don't have <code>GCC 4.8</code> yet to test, but from what I read about the C++11 standard, no matter if I declare the global object as <code>thread_local</code>, the object itself will be instantiated once for all the possible threads that can be created during the execution of the program.</p>\n<p>Is there a way (portable or not) in GCC to have the global object instantiated and constrcuted every time one thread starts and destructed every time the same thread finishes?</p>\n", "AcceptedAnswerId": "17472621", "Title": "Thread-scoped objects in C++11 with GCC", "CreationDate": "2013-07-04T13:26:23.660", "Id": "17471525", "CommentCount": "1", "LastEditDate": "2013-07-04T13:38:41.207", "PostTypeId": "1", "LastEditorUserId": "989331", "LastActivityDate": "2013-07-04T14:24:20.250", "Score": "0", "OwnerUserId": "989331", "Tags": "<c++><gcc><c++11><g++>", "AnswerCount": "2"}, "17472621": {"Id": "17472621", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_17471525_17472621_0\"><em>but from what I read about the C++11 standard, no matter if I declare the global object as <code>thread_local</code>, the object itself will be instantiated once for all the possible threads that can be created during the execution of the program.</em></p>\n</blockquote>\n<p>This is not what the C++11 standard states. The relevant sections from C++11 standard (draft n3337):</p>\n<ul>\n<li><em>3.7.2 Thread storage duration</em>, clause 1:</li>\n</ul>\n<blockquote>\n<p id=\"so_17471525_17472621_1\">All variables declared with the <code>thread_local</code> keyword have thread storage duration. The storage for these entities shall last for the duration of the thread in which they are created. <strong>There is a distinct object or reference per thread</strong>, and use of the declared name refers to the entity associated with the current thread.</p>\n</blockquote>\n<ul>\n<li><em>7.1.1 Storage class specifiers</em>, clause 4:</li>\n</ul>\n<blockquote>\n<p id=\"so_17471525_17472621_2\">The <code>thread_local</code> specifier indicates that the named entity has thread storage duration (3.7.2). <strong>It shall be applied only to the names of variables of namespace or block scope and to the names of static data members.</strong>  When thread_local is applied to a variable of block scope the storage-class-specifier static is implied if it does not appear explicitly.</p>\n</blockquote>\n<p>Nowhere does it state that if an object is defined in the global namespace with <code>thread_local</code> that only a single instance of it will be created. An alternative example to that already posted by <a href=\"https://stackoverflow.com/users/906773/jesse-good\">Jesse Good</a> prints the <em>unique</em> address of each instance of the global object (see <a href=\"http://coliru.stacked-crooked.com/view?id=b7d59e596d40b551abf042bb7681a877-f674c1a6d04c632b71a62362c0ccfc51\" rel=\"nofollow noreferrer\">online demo</a>):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nstruct S {};\nthread_local S global_s;\n\nint main()\n{\n    std::vector&lt;std::thread&gt; threads;\n    for (int i = 0; i &lt; 10; ++i)\n        threads.push_back(std::thread([](){ std::cout &lt;&lt; &amp;global_s &lt;&lt; '\\n'; }));\n    for (auto&amp; t: threads) t.join();\n}\n</code></pre>\n<p>Output:</p>\n<pre>\n0x4165993f\n0x4205a93f\n0x4485e93f\n0x42a5b93f\n0x4525f93f\n0x45c6093f\n0x4666193f\n0x4706293f\n0x43e5d93f\n0x4345c93f\n</pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-04T14:22:58.313", "Score": "4", "CreationDate": "2013-07-04T14:17:57.037", "ParentId": "17471525", "CommentCount": "0", "OwnerUserId": "1033896", "LastEditDate": "2017-05-23T12:11:17.267"}, "17471869": {"Id": "17471869", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_17471525_17471869_0\">no matter if I declare the global object as thread_local</p>\n</blockquote>\n<p>Did you try it out? I'm pretty sure that it <em>will</em> create a separate instance per thread.</p>\n<p>See the following code on <a href=\"http://coliru.stacked-crooked.com/view?id=40cd338821d53bc35c526ca16dadd699-f674c1a6d04c632b71a62362c0ccfc51\" rel=\"nofollow\">coliru</a>:</p>\n<pre><code>struct S {\n   int i = 0;\n   S() {}\n};\n\nthread_local S global;\n\nint main()\n{\n    std::thread t1([](){global.i = 1; std::cout &lt;&lt; global.i &lt;&lt; std::endl;});\n    t1.join();\n    std::cout &lt;&lt; global.i &lt;&lt; std::endl;\n    std::thread t2([](){global.i = 2; std::cout &lt;&lt; global.i &lt;&lt; std::endl;});\n    t2.join();\n    std::cout &lt;&lt; global.i &lt;&lt; std::endl;\n    std::thread t3([](){global.i = 3; std::cout &lt;&lt; global.i &lt;&lt; std::endl;});\n    t3.join();\n    std::cout &lt;&lt; global.i &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It outputs:</p>\n<pre><code>1\n0\n2\n0\n3\n0\n</code></pre>\n", "LastEditorUserId": "906773", "LastActivityDate": "2013-07-04T14:24:20.250", "Score": "2", "CreationDate": "2013-07-04T13:42:19.987", "ParentId": "17471525", "CommentCount": "2", "OwnerUserId": "906773", "LastEditDate": "2013-07-04T14:24:20.250"}});