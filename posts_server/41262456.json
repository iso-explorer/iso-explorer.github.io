post_cb({"41262493": {"ParentId": "41262456", "CommentCount": "2", "Body": "<p>Let's add a typedef, to help make heads or tails out of it:</p>\n<pre><code>typedef int (*int_func_ptr)();\n\n(*(int_func_ptr)a)();\n</code></pre>\n<p>So <code>a</code> is being cast to a function pointer of a particular prototype, dereferenced (which is redundant), and then called.</p>\n", "OwnerUserId": "817643", "PostTypeId": "2", "Id": "41262493", "Score": "8", "CreationDate": "2016-12-21T12:07:46.207", "LastActivityDate": "2016-12-21T12:07:46.207"}, "41262456": {"CommentCount": "3", "ViewCount": "211", "PostTypeId": "1", "LastEditorUserId": "1413395", "CreationDate": "2016-12-21T12:05:35.020", "LastActivityDate": "2016-12-22T15:58:01.423", "Title": "what is the meaning of (*(int (*)())a)()?", "LastEditDate": "2016-12-21T12:07:42.327", "Id": "41262456", "Score": "3", "Body": "<p>I am the beginner of learning C++. Today, I saw a pointer function like that </p>\n<pre><code>(*(int (*)())a)()\n</code></pre>\n<p>I was very confused with what the meaning of this and how I can understand it easily.</p>\n", "Tags": "<c++><pointers>", "OwnerUserId": "7325581", "AnswerCount": "3"}, "41262532": {"ParentId": "41262456", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><code>int (*)()</code> is a function pointer type that returns <code>int</code> and accepts no parameters.</p>\n<p>I presume that <code>a</code> is a function pointer whose type \"erases\" the actual type (perhaps so that one can store a bunch of different function pointers in a <code>vector</code>) that we need to cast to this pointer type, so <code>(int(*)())a)</code> will perform that casting.</p>\n<p>Afterwards we want to call the function, so the provided code dereferences the pointer <code>*</code> and then calls it with parenthesis <code>()</code></p>\n<h3>Example</h3>\n<p>I have a function <code>foo</code> that looks like this:</p>\n<pre><code>int foo()\n{\n    std::cout &lt;&lt; \"foo\\n\";\n    return 1;\n}\n</code></pre>\n<p>And then via <code>reinterpret_cast</code> I get a pointer to a function that instead returns <code>void</code> (for type-erasure reasons): </p>\n<pre><code> void(*fptr)() = reinterpret_cast&lt;void(*)()&gt;(&amp;::foo); //\u00a75.2.10/6\n</code></pre>\n<p>Later, I want to call that function, so I need to re-cast it back to its original type, and then call it:</p>\n<pre><code> (*(int (*)())fptr)(); // prints `foo`\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/61287d36de769746\" rel=\"nofollow noreferrer\">Demo</a></p>\n<p>De-referencing it is actually unecessary and the following is equivalent:</p>\n<pre><code>((int (*)())fptr)();\n</code></pre>\n<p>The explanation for <em>why</em> they're equivalent boils down to \"The standard says that both a function type and a function pointer type can be callable\"</p>\n<p>If you're standard savvy, you can check out \u00a75.2.2[expr.call] that states </p>\n<blockquote>\n<p id=\"so_41262456_41262532_0\">A function call is a postfix expression followed by parentheses containing a possibly empty, comma-separated list of <em>initializer-clauses</em> which constitute the arguments to the function. The postfix expression shall have function type or pointer to function type</p>\n</blockquote>\n", "OwnerUserId": "27678", "LastEditorUserId": "27678", "LastEditDate": "2016-12-22T13:22:24.257", "Id": "41262532", "Score": "6", "CreationDate": "2016-12-21T12:09:58.970", "LastActivityDate": "2016-12-22T13:22:24.257"}, "bq_ids": {"n4140": {"so_41262456_41262532_0": {"section_id": 5988, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_41262456_41262532_0": {"section_id": 5756, "quality": 0.875, "length": 21}}, "n4659": {"so_41262456_41262532_0": {"section_id": 7488, "quality": 0.9583333333333334, "length": 23}}}, "41264099": {"ParentId": "41262456", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>StoryTeller and Andy have given correct answers. I'll give general rules, additionally.</p>\n<p>StoryTeller makes a correct and useful typedef with <code>typedef int (*int_func_ptr)();</code>, which defines a function pointer type. Two things are to remember here. </p>\n<ul>\n<li><p>The general language design for <strong>typedefs:</strong> it exactly mimics a declaration of an object of the given type! Simply prefixing a declaration with <code>typedef</code>  makes the declared identifier a type alias instead of a variable. That is, if <code>int i;</code>  declares an integer variable, <strong><code>typedef</code></strong><code>int i;</code>  declares <code>i</code> as a synonym for the type <code>int</code>. So declaring a function pointer <em>variable</em> would simply read <code>int (*int_func_ptr)();</code>. Prefixing this with the <code>typedef</code>, as StoryTeller  did, makes it a type alias instead.</p></li>\n<li><p>Casts of function pointers are notoriously confusing. One reason are the necessary <strong>parentheses</strong>:</p>\n<ol>\n<li><p>Parentheses serve several unrelated purposes:</p>\n<ul>\n<li>They group expressions to indicate subexpression precedence, as in <code>(a+b) * c</code>.</li>\n<li>They delimit function arguments, both in declarations and in calls.</li>\n<li>They delimit type names used in casts.</li>\n</ul></li>\n<li><p>We have parentheses for <em>all three</em> purposes here!</p></li>\n<li><a href=\"http://en.cppreference.com/w/c/language/operator_precedence\" rel=\"nofollow noreferrer\">The operator precedence</a> is \"unnatural\" for function pointer declarations. This is so, of course, because they are natural for the much more frequent uses: Without parentheses, the declaration would be the more familiar looking <code>int *int_func();</code>, which declares a <em>function proper</em> which returns an int pointer. The reason is that the argument parentheses have higher priority than the dereferencing asterisk, so that in order to infer the type we mentally execute the call first, and not the dereferencing. And something that can be called is a function.<sup>1</sup> The result of the call can be dereferenced, and that result is an int. <br>\nCompare that to the original <code>int (*int_func_ptr)();</code>: The additional parentheses force us to dereference first, so the identifier must be a pointer of some kind. The result of the dereferencing can be called, so it must be a function; the result of the call is an <code>int</code>.</br></li>\n</ol></li>\n</ul>\n<p>Another reason why function pointer declarations or typedefs look unnatural is that the declared identifier tends to be at the <em>center of the expression.</em> The reason is that <strong>operators to the left <em>and</em> to the right</strong> of the identifier are applied (the dereferencing, the function call, and then there is finally the result type declaration all the way to the left).</p>\n<p>The next rule is about constructing <strong>casts.</strong> The type names used in casts are constructed from corresponding variable declarations simply <em>by omitting the variable name!</em> This is obvious in the simple cases: since <code>int i</code>  declares an int variable, <code>(int)</code> without the <code>i</code> is the corresponding cast.</p>\n<p>If we apply that to the function pointer type, <code>int (*int_func_ptr)()</code> is transformed to the weird-looking <code>(int (*)())</code> by omitting the variable name and putting the type name in parentheses as required for a cast. Note that the parentheses which force precedence of the asterisk are still there, even though there is nothing to dereference! Without them, <code>(int *())</code> would be derived from <code>int *int_func()</code> and therefore denote a function which returns a pointer.<sup>2</sup></p>\n<p>It is perhaps surprising that there is exactly one place in a declaration where a variable name can syntactically be, so that even very complicated type expressions in casts are well-defined: It is this one place where a variable name fits which defines the cast type.</p>\n<p>With these rules, let's re-examine the original expression:</p>\n<p><code>(*(int (*)())a)</code><strong><code>()</code></strong></p>\n<p>On the outermost level we have two pairs of parentheses. The second pair is empty and thus must be a function call operator. That implies that the operand to the left has function type:</p>\n<p><code>*</code><strong><code>(int (*)())</code></strong><code>a</code></p>\n<p>The operand is an expression in parentheses for precedence. It has three parts: The asterisk, an expression in parentheses, and an identifier <code>a</code>. Since there is no operator between the parenthesized expression and the variable <code>a</code>, it must be a cast, actually the one we scrutinized above. <code>*</code> and the type cast have the same precedence and are evaluated right-to-left: first <code>a</code> is cast to a function pointer, and then <code>*</code> dereferences that in order to obtain the \"function proper\" (which are no real objects in C++). This fits because the function call operator from above will be applied to this result. </p>\n<p><hr>\n<sub><sup>1</sup> That C permits calling function <em>pointers</em> directly as well, without dereferencing first, is syntactic sugar and not considered in declarations.</sub></hr></p>\n<p><sup>2</sup> While the expression is syntactically valid, such a cast to function is not allowed in C or C++.\n</p>\n", "OwnerUserId": "3150802", "LastEditorUserId": "3150802", "LastEditDate": "2016-12-22T15:58:01.423", "Id": "41264099", "Score": "2", "CreationDate": "2016-12-21T13:36:48.647", "LastActivityDate": "2016-12-22T15:58:01.423"}});