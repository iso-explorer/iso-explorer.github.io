post_cb({"18727022": {"ViewCount": "2944", "Body": "<pre><code>int data[8];\ndata[9] = 1;\n</code></pre>\n<p>What does the c++ standard say about it? Is this undefined behaviour?</p>\n<p>At least the C compiler (gcc -std=c99 -pedantic -W -Wall) doesn't say anything about it.</p>\n<p>Thanks.</p>\n", "Title": "Access array beyond the limit in C and C++", "CreationDate": "2013-09-10T19:11:17.533", "LastActivityDate": "2013-09-14T15:12:44.520", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-09-10T19:13:10.237", "LastEditorUserId": "501557", "Id": "18727022", "Score": "4", "OwnerUserId": "738154", "Tags": "<c++><c><arrays><undefined-behavior>", "AnswerCount": "7"}, "18727132": {"Id": "18727132", "PostTypeId": "2", "Body": "<p>C and C++ don't check bounds. The values that you are trying to reach could be practically anything. It might seem to work on your compiler, but it is not legal C or C++, and there is no guarantee that it'll still work the next time you run the program.</p>\n<p>According to the ISO C Standard, accessing an array outside bounders causes</p>\n<blockquote>\n<p id=\"so_18727022_18727132_0\"><strong>undefined behavior:</strong> behavior, upon use of a nonportable or erroneous program construct or of erroneous data, for which this International Standard imposes no requirements</p>\n</blockquote>\n<p>Segmentation faults occur when you are trying to dereference a pointer to memory that your program is not allowed to access, and just going past the end of your array probably won't cause that. But it will <em>most-likely</em> give you some bad values. </p>\n", "LastEditorUserId": "1670308", "LastActivityDate": "2013-09-10T19:32:55.707", "Score": "2", "CreationDate": "2013-09-10T19:18:24.937", "ParentId": "18727022", "CommentCount": "0", "OwnerUserId": "1670308", "LastEditDate": "2013-09-10T19:32:55.707"}, "bq_ids": {"n4140": {"so_18727022_18727216_2": {"length": 9, "quality": 0.6428571428571429, "section_id": 5986}, "so_18727022_18727216_1": {"length": 57, "quality": 1.0, "section_id": 6142}, "so_18727022_18727216_3": {"length": 20, "quality": 0.8695652173913043, "section_id": 5769}}, "n3337": {"so_18727022_18727216_2": {"length": 9, "quality": 0.6428571428571429, "section_id": 5754}, "so_18727022_18727216_1": {"length": 57, "quality": 1.0, "section_id": 5906}, "so_18727022_18727216_3": {"length": 20, "quality": 0.8695652173913043, "section_id": 5542}}, "n4659": {"so_18727022_18727216_2": {"length": 9, "quality": 0.6428571428571429, "section_id": 7486}, "so_18727022_18727216_3": {"length": 20, "quality": 0.8695652173913043, "section_id": 7226}}}, "18727039": {"Id": "18727039", "PostTypeId": "2", "Body": "<p>Yes, it is undefined behavior.</p>\n<p>A compiler may or may not warn you against undefined behavior even if it is able to detect it.</p>\n", "LastActivityDate": "2013-09-10T19:12:25.797", "CommentCount": "0", "CreationDate": "2013-09-10T19:12:25.797", "ParentId": "18727022", "Score": "4", "OwnerUserId": "1062250"}, "18727040": {"Id": "18727040", "PostTypeId": "2", "Body": "<p>Undefined.\nIt may or may not be invalid memory, which makes it dangerous.\nYou can use tools like valgrind to detect bad accesses like this.</p>\n", "LastActivityDate": "2013-09-10T19:12:32.383", "CommentCount": "0", "CreationDate": "2013-09-10T19:12:32.383", "ParentId": "18727022", "Score": "2", "OwnerUserId": "681026"}, "18727126": {"Id": "18727126", "PostTypeId": "2", "Body": "<p>Yes, it is undefined behavior. Everything might happen, it might work or not, it might work 2 years and then stop to work. This is most dangerous out of three:</p>\n<ul>\n<li>undefined behavior</li>\n<li>unspecified behavior</li>\n<li>implementation-defined behavior</li>\n</ul>\n<p>You might check this to meet other its relatives:\n<a href=\"https://stackoverflow.com/a/367662/1141471\">What are all the common undefined behaviour that a C++ programmer should know about?</a></p>\n<p><a href=\"https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior\">Undefined, unspecified and implementation-defined behavior</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-10T19:23:29.280", "Score": "2", "CreationDate": "2013-09-10T19:18:04.160", "ParentId": "18727022", "CommentCount": "0", "OwnerUserId": "1141471", "LastEditDate": "2017-05-23T12:28:29.257"}, "18727043": {"Id": "18727043", "PostTypeId": "2", "Body": "<p>This is considered undefined behavior.  Compilers aren't required to issue warnings if you try to compile code that will result in undefined behavior, though it's nice of them to do so.</p>\n<p>Hope this helps!</p>\n", "LastActivityDate": "2013-09-10T19:12:45.393", "CommentCount": "1", "CreationDate": "2013-09-10T19:12:45.393", "ParentId": "18727022", "Score": "4", "OwnerUserId": "501557"}, "18727216": {"Id": "18727216", "PostTypeId": "2", "Body": "<p>Accessing outside the array bounds is undefined behavior, from the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow\">c99 draft standard</a> section <code>Annex J.2</code> <em>J.2 Undefined behavior</em> includes the follow point:</p>\n<blockquote>\n<p id=\"so_18727022_18727216_0\">An array subscript is out of range, even if an object is apparently accessible with the\n  given subscript (as in the lvalue expression a[1][7] given the declaration int\n  a[4][5]) (6.5.6).</p>\n</blockquote>\n<p>and the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> in section <code>5.7</code> <em>Additive operators</em> paragraph <em>5</em> says:</p>\n<blockquote>\n<p id=\"so_18727022_18727216_1\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an <strong>array object, and the array is large enough</strong>, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integral expression. [...] If both the pointer operand and the <strong>result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</strong></p>\n</blockquote>\n<p>For completeness sake, section <code>5.2.1</code> <em>Subscripting</em> paragraph <em>1</em> says:</p>\n<blockquote>\n<p id=\"so_18727022_18727216_2\">[...]The expression <strong>E1[E2] is identical (by definition) to *((E1)+(E2))</strong> [ Note: <strong>see 5.3 and 5.7 for details</strong> of * and + and 8.3.4 for details of arrays. \u2014end note ]</p>\n</blockquote>\n<p>It is important to note that the compiler is not required to produce a warning(<em>diagnostic</em>) for undefined behavior, the draft C++ standard in section <code>1.4</code> <em>Implementation compliance</em> paragraph <em>1</em> says:</p>\n<blockquote>\n<p id=\"so_18727022_18727216_3\">The set of diagnosable rules consists of all syntactic and semantic rules in this International Standard <strong>except for those rules containing an explicit notation that \u201cno diagnostic is required\u201d or which are described as resulting in \u201cundefined behavior.\u201d</strong></p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-09-11T02:11:56.973", "Score": "6", "CreationDate": "2013-09-10T19:23:00.133", "ParentId": "18727022", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2013-09-11T02:11:56.973"}, "18803199": {"Id": "18803199", "PostTypeId": "2", "Body": "<p>Yes, it is undefined behavior, some compilers gives warnings about that, others don't, but lets look, that your code do.</p>\n<p>Look at opeators <code>[]</code> inline implementation. <code>a[b]</code> actually is <code>*(a + b)</code>. So go back to your code.</p>\n<pre><code>int data[8];\ndata[9] = 1;\n</code></pre>\n<p>First you allocate some part of stack and create a pointer to the first element. Then you rewrite some data, which is just after your array, so you corrupt some data.</p>\n<p>Lets take another example:</p>\n<pre><code>int data[8];\nint data2[8] = {};\ndata[9] = 1;\n</code></pre>\n<p>It is very likely, that compiler generates code which allocates once and creates two pointers as arrays. So <code>data[9] = 1;</code> may set second value of <code>data2</code> to one, however there is no guarantees about that.</p>\n", "LastActivityDate": "2013-09-14T15:12:44.520", "CommentCount": "0", "CreationDate": "2013-09-14T15:12:44.520", "ParentId": "18727022", "Score": "1", "OwnerUserId": "1237747"}});