post_cb({"bq_ids": {"n4140": {"so_25348099_25348164_0": {"length": 7, "quality": 0.875, "section_id": 3400}, "so_25348099_25348164_3": {"length": 9, "quality": 1.0, "section_id": 3402}, "so_25348099_25348164_2": {"length": 5, "quality": 1.0, "section_id": 3402}}, "n3337": {"so_25348099_25348164_0": {"length": 7, "quality": 0.875, "section_id": 3269}, "so_25348099_25348164_3": {"length": 9, "quality": 1.0, "section_id": 3271}, "so_25348099_25348164_2": {"length": 5, "quality": 1.0, "section_id": 3271}}, "n4659": {"so_25348099_25348164_0": {"length": 7, "quality": 0.875, "section_id": 4157}, "so_25348099_25348164_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 4159}, "so_25348099_25348164_2": {"length": 4, "quality": 0.8, "section_id": 4087}}}, "25348099": {"ViewCount": "1049", "Body": "<h1>Breif</h1>\n<p>I would like to be able to convert between std::complex and float 's with minimal overhead in copying of data. (None at all if possible.)</p>\n<h1>Situation</h1>\n<p>I have a class which contains samples of data. On one side of the class, there is a program which reads and writes data in the form of std::complex. The data is either all real-valued, or all imaginary, and hence the input is a (float*). Inside the class there is a function which carries out processing, such as fourier transform processing, which takes arguments of float*. (Pointer to floats.) The data inside the class is stored in a std::vector.</p>\n<p>Hence the description is;</p>\n<p><code>std::vector&lt;std::complex&lt;float&gt;&gt;</code>;</p>\n<p>The reason for this choice is that the output is not always either real or imaginary. And it would be advantageous to access data using vector.at(index).real() or vector.at(index).imag(), as this makes coding other functions, such as a function to compute the average power, much easier. (The alternative is to use indices to dereference a pointer. Usually, I would not have any problem with this method, however many other SO programmers will tell you that it is an awful method because you have to be able to multiply by 2 and add up... In this case, it becomes more difficult to be sure you have got the algorithm correct, as there is a change in the way in which the data is stored[1], hence why I agree with the SO consensus in this case.)</p>\n<p>[1]: The input data is a (float*) to all real values. 2 blocks of input values are interleaved into an array twice the size: real0 = data0[0], imag0 = data1[0], real1 = data0[1], imag1 = data1[1], ... etc ...</p>\n<p>This is then stored as: <code>{ complex(real0, imag0) , complex(real1, imag1) , ... etc ... }</code></p>\n<p>But then processed using an FFT which takes a float*, and uses indices rather than complex.real() and complex.imag().</p>\n<p>Then another set of functions compute values using complex.real() and complex.imag() rather than just indices.</p>\n<p>Results are then returned back in both the forms above: Using std::vector&gt;&amp; (reference to) and float*...</p>\n<h1>Possible Solution Number 1</h1>\n<p>Clearly this method of changing the way in which data is stored is idiotic. It should be 1 way or another, not many different ways.</p>\n<p>Unfortunately, I didn't write most of this code and so I can't edit it... Solution 2 it is then...</p>\n<h1>Possible Solution Number 2</h1>\n<p>It would be possible to return a pointer to the data inside the vector class. For this to work, I am assuming that:</p>\n<p><em>The std::complex class stores real and imaginary values in that order</em></p>\n<p>If this is not true, the following will not work:</p>\n<pre><code>// Function inside my_class which returns access to real components\nfloat* getReal(int&amp; stride, int&amp; length)\n{\n    stride = 2;\n    return &amp;my_vector.at(0); // Think this is the same as my_vector.data()?\n}\n\n// This is then used in the following way to set all real values to 0.0\nvoid Reset()\n{\n    int stride, length;\n    float* data_p = my_class.getReal(stride, length);\n    float* data_p_last_value = data_p + length - 1;\n\n    for(; data_p &lt;= data_p_last_value; ++ data_p)\n    {\n        (*data_p) = 0.0;\n    }\n}\n</code></pre>\n<p>But this is kind of not very nice. Is there an alternative, more \"sleek\" or intuitive, method?</p>\n", "Title": "C++: Convert between std::complex and 2x floating point values for use as interface", "CreationDate": "2014-08-17T09:49:39.507", "LastActivityDate": "2014-08-17T10:16:02.953", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "Id": "25348099", "Score": "1", "OwnerUserId": "893254", "Tags": "<c++>", "AnswerCount": "1"}, "25348164": {"Id": "25348164", "PostTypeId": "2", "Body": "<p><code>std::complex</code> is a <em>very special</em> class, specified for interoperability with complex number types in other languages, including C. The standard guarantees that (\u00a726.4 [complex.numbers]/p2, 4):</p>\n<blockquote>\n<p id=\"so_25348099_25348164_0\">The specializations <code>complex&lt;float&gt;</code>, <code>complex&lt;double&gt;</code>, \n  and <code>complex&lt;long double&gt;</code> are literal types (3.9).</p>\n<p id=\"so_25348099_25348164_1\">[...]</p>\n<p id=\"so_25348099_25348164_2\">If <code>z</code> is an lvalue expression of type <code>cv std::complex&lt;T&gt;</code> then:</p>\n<ul>\n<li>the expression <code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)</code> shall be well-formed,</li>\n<li><code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[0]</code> shall designate the real part of z, and</li>\n<li><code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[1]</code> shall designate the imaginary part of z.</li>\n</ul>\n<p id=\"so_25348099_25348164_3\">Moreover, if <code>a</code> is an expression of type <code>cv std::complex&lt;T&gt;*</code> and\n  the expression <code>a[i]</code> is well-defined for an integer expression <code>i</code>,\n  then:</p>\n<ul>\n<li><code>reinterpret_cast&lt;cv T*&gt;(a)[2*i]</code> shall designate the real part of <code>a[i]</code>, and</li>\n<li><code>reinterpret_cast&lt;cv T*&gt;(a)[2*i + 1]</code> shall designate the imaginary part of <code>a[i]</code>.</li>\n</ul>\n</blockquote>\n<p>So the approach in your suggested solution 2 is safe modulo bugs (for instance, you are using <code>length</code> in <code>Reset()</code> uninitialized, and your algorithm seems to be zeroing everything and not just the real parts).</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-17T10:16:02.953", "Score": "7", "CreationDate": "2014-08-17T09:59:53.223", "ParentId": "25348099", "CommentCount": "5", "OwnerUserId": "2756719", "LastEditDate": "2014-08-17T10:16:02.953"}});