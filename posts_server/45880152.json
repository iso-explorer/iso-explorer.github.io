post_cb({"45880152": {"CommentCount": "5", "AcceptedAnswerId": "45880569", "PostTypeId": "1", "ClosedDate": "2017-08-27T23:41:20.887", "LastEditorUserId": "1711796", "CreationDate": "2017-08-25T11:16:52.897", "LastActivityDate": "2017-08-25T16:40:24.707", "LastEditDate": "2017-08-25T16:40:24.707", "ViewCount": "1283", "FavoriteCount": "1", "Title": "Why are copy and move constructors called together?", "Id": "45880152", "Score": "21", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass A\n{\npublic:\n     A(int) { cout &lt;&lt; \"int\" &lt;&lt; endl; }\n     A(A&amp;&amp;) { cout &lt;&lt; \"move\" &lt;&lt; endl; }\n     A(const A&amp;) { cout &lt;&lt; \"copy\" &lt;&lt; endl; }\n};\n\nint main()\n{\n    vector&lt;A&gt; v\n    {\n        A(10), A(20), A(30)\n    };\n\n    _getch();\n    return 0;\n}\n</code></pre>\n<p>The output is:</p>\n<pre class=\"lang-none prettyprint-override\"><code>int\nint\nint\ncopy\ncopy\ncopy\n</code></pre>\n<p><code>A(10)</code>, <code>A(20)</code> and <code>A(30)</code> are temporaries, right? </p>\n<p>So why is the copy constructor called? Shouldn't the move constructor be called instead?</p>\n<p>Passing <code>move(A(10))</code>, <code>move(A(20))</code>, <code>move(A(30))</code> instead, the output is:</p>\n<pre class=\"lang-none prettyprint-override\"><code>int\nmove\nint\nmove\nint\nmove\ncopy\ncopy\ncopy\n</code></pre>\n<p>In this case either copy or move constructor is called.</p>\n<p>What's happening?</p>\n", "Tags": "<c++><c++11><copy-constructor><move-semantics><move-constructor>", "OwnerUserId": "7636248", "AnswerCount": "2"}, "45880569": {"ParentId": "45880152", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><code>std::vector</code> can be constructed from a <a href=\"http://en.cppreference.com/w/cpp/container/vector/vector\" rel=\"noreferrer\"><code>std::initializer_list</code></a>, and you are calling that constructor. The rules for initializer_list construction state that this constructor is aggressively preferred:</p>\n<blockquote>\n<p id=\"so_45880152_45880569_0\">A constructor is an <em>initializer-list</em> constructor if its first parameter is of type <code>std::initializer_list&lt;E&gt;</code>\n  or reference to possibly cv-qualified <code>std::initializer_list&lt;E&gt;</code> for some type <code>E</code>, and either there are\n  no other parameters or else all other parameters have default arguments (8.3.6). [ Note: Initializer-list\n  constructors are favored over other constructors in list-initialization &lt;...&gt;]</p>\n</blockquote>\n<p>Also, because of the sort of weird implementation of an <code>initializer_list</code> as an array allocated under the hood, elements of the corresponding array that the <code>std::initializer_list&lt;E&gt;</code> refers to are forced to be copy initialized (which can be elided):</p>\n<blockquote>\n<p id=\"so_45880152_45880569_1\">An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an initializer list as if the implementation\n  allocated an array of <code>N</code> elements of type <code>E</code>, where <code>N</code> is the number of elements in the initializer list.\n  Each element of that array is copy-initialized with the corresponding element of the initializer list, and\n  the <code>std::initializer_list&lt;E&gt;</code> object is constructed to refer to that array</p>\n</blockquote>\n<p>(Both references above from N3337 [dcl.init.list])</p>\n<p>However, in your first example the copies can/are <em>elided</em> despite the name ([dcl.init]/14) so you don't see an extra copy construction (they can also be moved) You can thank your compiler for that, because <em>copy elision</em> is not required in C++11 (although it is in C++17).</p>\n<p>See [class.copy] for more details (\"When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class\nobject...\"). </p>\n<p>The final part is key:</p>\n<p>[support.initlist] states that</p>\n<blockquote>\n<p id=\"so_45880152_45880569_2\">An object of type <code>initializer_list&lt;E&gt;</code> provides access to an array of objects of type <code>const E</code>.</p>\n</blockquote>\n<p>This means that the <code>std::vector</code> cannot take over the memory directly; it must be copied, this is where you ultimately see the copy constructions being called.</p>\n<p>In the second example it is as Kerrek SB stated, you prevented the copy-elision I mentioned earlier and caused an additional overhead of a move.</p>\n", "OwnerUserId": "27678", "LastEditorUserId": "27678", "LastEditDate": "2017-08-25T12:00:06.963", "Id": "45880569", "Score": "14", "CreationDate": "2017-08-25T11:39:45.687", "LastActivityDate": "2017-08-25T12:00:06.963"}, "bq_ids": {"n4140": {"so_45880152_45880569_0": {"section_id": 3324, "quality": 0.9411764705882353, "length": 32}, "so_45880152_45880569_2": {"section_id": 6955, "quality": 1.0, "length": 9}, "so_45880152_45880590_1": {"section_id": 458, "quality": 0.5555555555555556, "length": 5}, "so_45880152_45880569_1": {"section_id": 3327, "quality": 1.0, "length": 29}}, "n3337": {"so_45880152_45880569_0": {"section_id": 3194, "quality": 0.9411764705882353, "length": 32}, "so_45880152_45880569_2": {"section_id": 6702, "quality": 1.0, "length": 9}, "so_45880152_45880590_1": {"section_id": 449, "quality": 0.5555555555555556, "length": 5}, "so_45880152_45880569_1": {"section_id": 3197, "quality": 1.0, "length": 29}}, "n4659": {"so_45880152_45880590_1": {"section_id": 481, "quality": 0.5555555555555556, "length": 5}, "so_45880152_45880569_2": {"section_id": 8452, "quality": 1.0, "length": 9}, "so_45880152_45880569_0": {"section_id": 4090, "quality": 0.9117647058823529, "length": 31}, "so_45880152_45880569_1": {"section_id": 4093, "quality": 0.896551724137931, "length": 26}}}, "45880590": {"ParentId": "45880152", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_45880152_45880590_0\">A(10), A(20), A(30) are temporaries, right? </p>\n</blockquote>\n<p>Correct.</p>\n<blockquote>\n<p id=\"so_45880152_45880590_1\">So why the copy constructor is called? Shouldn't the move constructor be called instead?</p>\n</blockquote>\n<p>Unfortunately, it is not possible to move from <code>std::initializer_list</code>, which is what this constructor of <code>std::vector</code> uses.</p>\n<blockquote>\n<p id=\"so_45880152_45880590_2\">Passing move(A(10)), move(A(20)), move(A(30)) instead</p>\n<p id=\"so_45880152_45880590_3\">In this case either copy or move constructor are called. What's happening?</p>\n</blockquote>\n<p>Because the <code>std::move</code> conversion prevents copy-elision, and so the elements of the <code>std::initializer_list</code> are move constructed without elision. Then the constructor of vector copies from the list.</p>\n", "OwnerUserId": "2079303", "PostTypeId": "2", "Id": "45880590", "Score": "5", "CreationDate": "2017-08-25T11:41:27.337", "LastActivityDate": "2017-08-25T11:41:27.337"}});