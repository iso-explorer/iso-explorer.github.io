post_cb({"46683875": {"ParentId": "46683353", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This behavior is due to <em>copy elision</em>.  From the standard \u00a7[class.copy]\u00b631:</p>\n<blockquote>\n<p id=\"so_46683353_46683875_0\">When certain criteria are met, an implementation is allowed to omit\n  the copy/move construction of a class object, even if the constructor\n  selected for the copy/move operation and/or the destructor for the\n  object have side effects. In such cases, the implementation treats the\n  source and target of the omitted copy/move operation as simply two\n  different ways of referring to the same object, and the destruction of\n  that object occurs at the later of the times when the two objects\n  would have been destroyed without the optimization. This elision of\n  copy/move operations, called <em>copy elision</em>, is permitted in the\n  following circumstances (which may be combined to eliminate multiple\n  copies):<br>\n  [...]<br>\n  \u2014 when a temporary class object that has not been bound to a reference\n  (12.2) would be copied/moved to a class object with the same\n  cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the\n  omitted copy/move\n  [...]</br></br></p>\n</blockquote>\n<p>In this case, <code>Test test1 = getTest()</code> fulfills the criterion I've quoted above.  The temporary <code>Test</code> object that would be created in <code>getTest</code> is not bound to a reference.  It can therefore be constructed directly in the return value of <code>getTest</code>.  This optimization is also referred to as Return Value Optimization, or RVO.  Also, since the return value of <code>getTest</code> (itself a temporary object), is not bound to a reference, it can be constructed directly into <code>test1</code>.</p>\n<p>In the case of <code>vec.push_back(Test());</code>, the temporary <code>Test</code> object you create must be copied or moved into the <code>vector</code>'s internal storage.  No copy elision is possible in this case since the temporary object you create gets bound to a reference when passed to <code>push_back</code> and none of the other situations listed in the standard apply.  That means that two <code>Test</code> objects must be created: one (your temporary) constructed using its default constructor, and another (the <code>vector</code>'s copy) created by copy-constructor.</p>\n", "OwnerUserId": "4151599", "LastEditorUserId": "4151599", "LastEditDate": "2017-10-11T08:59:30.210", "Id": "46683875", "Score": "0", "CreationDate": "2017-10-11T08:51:34.970", "LastActivityDate": "2017-10-11T08:59:30.210"}, "46683353": {"CommentCount": "5", "ViewCount": "54", "CreationDate": "2017-10-11T08:26:24.133", "LastActivityDate": "2017-10-11T09:08:38.913", "Title": "C++: Execution of programm(constructors, destructors, assignment operators, etc)", "PostTypeId": "1", "Id": "46683353", "Score": "0", "Body": "<p>I'm trying to understand why the following C++ program outputs what it does. </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;initializer_list&gt;\n#include &lt;memory.h&gt;\nusing namespace std;\n\n\n// Constructors and memory\n\nclass Test{\n    static const int SIZE = 100;\n    int *_pBuffer;\n\npublic:\n    Test(){\n        cout &lt;&lt; \"constructor\" &lt;&lt; endl;\n        _pBuffer = new int[SIZE]{}; // allocated memory for int[size] and initialised with 'size' 0's\n\n    }\n\n    Test(int i){\n        cout &lt;&lt; \"parameterized constructor\" &lt;&lt; endl;\n        _pBuffer = new int[SIZE]{};\n\n        for(int i=0; i&lt;SIZE; i++)\n        {\n            _pBuffer[i] = 7*i;\n        }\n    }\n\n    Test(const Test&amp; other) // in the copy constructor we...\n    {\n        cout &lt;&lt; \"copy constructor\" &lt;&lt; endl;\n        _pBuffer = new int[SIZE]{}; // allocate the bytes then copy them from the 'other'\n        memcpy(_pBuffer, other._pBuffer, SIZE*sizeof(int));\n\n    }\n\n    Test &amp;operator=(const Test &amp;other){\n        cout &lt;&lt; \"assignment\" &lt;&lt; endl;\n\n        _pBuffer = new int[SIZE]{}; // allocate the bytes then copy them from the 'other'\n        memcpy(_pBuffer, other._pBuffer, SIZE*sizeof(int));\n\n        return *this;\n    }\n\n    ~Test(){\n        cout &lt;&lt; \"Destructor\" &lt;&lt; endl;\n\n        delete [] _pBuffer;\n    }\n\n};\n\nostream &amp;operator&lt;&lt;(ostream &amp;out, const Test &amp;test)\n    {\n        out &lt;&lt; \"Hello from test\";\n        return out;\n    }\n\nTest getTest()\n{\n    return Test();\n}\n\n\nint main() {\n\n    Test test1 = getTest(); // object gets created with default constructor =&gt;\n    cout &lt;&lt; test1 &lt;&lt; endl;\n\n    vector&lt;Test&gt; vec;\n    vec.push_back(Test());\n\n    return 0;\n}\n</code></pre>\n<p>This is how I expected it to work and what I expected it to print:</p>\n<pre><code>Test test1 = getTest(); \n</code></pre>\n<p>Here I was expecting this to happen: Inside the getTest a Test instance is created with the ctor with no parameters therefore: cout &lt;&lt; constructor; Then this value is returned and assigned to test1 with the '=' which in this case would be the 'copy ctor' therefore also cout &lt;&lt; 'copy ctor';</p>\n<pre><code>cout &lt;&lt; test1 &lt;&lt; endl;\n</code></pre>\n<p>Here I expected cout &lt;&lt; \"Hello from test\"; cuz of the overloaded '&lt;&lt;'</p>\n<pre><code>vector&lt;Test&gt; vec;\nvec.push_back(Test());\n</code></pre>\n<p>And here I was expecting an instance to be created and pushed into vec(1) with the no parameter ctor so cout &lt;&lt; \"Constructor\" &lt;&lt; endl;</p>\n<p>Then I was expecting the test1 and vec(1) to go out of scope at the end of the program so 2x \"cout &lt;&lt; \"destructor\"; \"</p>\n<p>So overall my expectations was this:</p>\n<pre><code>cout &lt;&lt; constructor;\ncout &lt;&lt; copy constructor;\ncout &lt;&lt; hello from test;\ncout &lt;&lt; constructor;\ncout &lt;&lt; destructor;\ncout &lt;&lt; destructor;\n</code></pre>\n<p>However the actuall output of the program is this:</p>\n<pre><code>constructor\nHello from test\nconstructor\ncopy constructor\nDestructor\nDestructor\nDestructor\n</code></pre>\n<p>which is different from my expectations :).</p>\n<p>Out of those I guess I can understand the extra destructor I get in the end. I suppose when the function getTest() returns a value which is assigned to test1 that value also gets destroyed at the end of the program so that's why the extra destructor. Or at least that's what I think. Please correct me if I'm wrong.</p>\n<p>Also I don't understand why I don't get a 'cout &lt;&lt; \"Copy ctor\"' after the first 'cout &lt;&lt; \"Constructor\";'. Isn't Test test1 = getTest();' a call to copy ctor?</p>\n<p>Also if possible please help me understand the flow of this program so I can understand why it outputs what it does and get a better understanding of OOP in c++. Thank you for reading.</p>\n", "Tags": "<c++><oop><constructor>", "OwnerUserId": "8548951", "AnswerCount": "2"}, "46684218": {"ParentId": "46683353", "CommentCount": "1", "Body": "<p>So here is the actual output of the program. I have disabled compiler optimisation and return value optimisation. The following is the output of the program</p>\n<pre><code>constructor\ncopy constructor\nDestructor\ncopy constructor\nDestructor\nHello from test\nconstructor\ncopy constructor\nDestructor\nDestructor\nDestructor\n</code></pre>\n<p>Lets break this down. The first constructor, copy and destructor calls are all related to the <code>getTest()</code> method. The constructor is initially called when you create a instance of the object by <code>Test()</code> this outputs <code>constructor</code>. This value then needs to be returned, since this is all compiled down to assembly object needs to be place on the stack, in particular in needs to be place on the position before the function call on the stack(I might be wrong either before or after however a position is reserved for the return value). So the instance is copied to that position on the stack outputting the <code>copy constructor</code>. This results in the function completing and calling the destructor of the original instance that was created.</p>\n<p>Next is the <code>Test test1 = getTest();</code>, the instance at the reserved position from the function call is then copied to the variable <code>test1</code> resulting in <code>copy constructor</code> and then the instance in the reserved position is destroyed outputting <code>Destructor</code>.</p>\n<p>Then the <code>Hello from test</code> is displayed and since the stream operator works with references, nothing is copied. So no constructor or destructors are called.</p>\n<p>The last <code>constructor</code> call is output when <code>vec.push_back(Test());</code> is called specifically <code>Test()</code>. This instance is created and then the vector class copies that instance to a position in the vector class's array during the <code>push_back</code> call. The remaining three destructors are called for the <code>test1</code>, the instance created during the <code>push_back</code> and the instance stored in the vector class.</p>\n<p>I hope this helped.</p>\n", "OwnerUserId": "4773139", "PostTypeId": "2", "Id": "46684218", "Score": "0", "CreationDate": "2017-10-11T09:08:38.913", "LastActivityDate": "2017-10-11T09:08:38.913"}, "bq_ids": {"n4140": {"so_46683353_46683875_0": {"section_id": 480, "quality": 0.978494623655914, "length": 91}}, "n3337": {"so_46683353_46683875_0": {"section_id": 471, "quality": 0.946236559139785, "length": 88}}, "n4659": {"so_46683353_46683875_0": {"section_id": 502, "quality": 0.8387096774193549, "length": 78}}}});