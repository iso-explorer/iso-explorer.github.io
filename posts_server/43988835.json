post_cb({"43989418": {"ParentId": "43988835", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_43988835_43989418_0\">Can anyone tell me how to create the first Cat object in this case? or kindly correct me if my understanding is wrong.</p>\n</blockquote>\n<p>The only valid answer here is: </p>\n<p>There is no way only using the code you posted. You probably missed some additional functionality that was given along with that example you saw.</p>\n<hr>\n<p>There are ways though if any other constuctor is declared <code>private</code>, e.g.:</p>\n<pre><code>class Cat {\n    public:\n        Cat(const Cat&amp; iCat);\n        static Cat* CreateCat(const std::string&amp; color) {\n            return new Cat(color);\n        }\n    private:\n        Cat(const std::string&amp; color)\n};\n</code></pre>\n</hr>", "OwnerUserId": "1413395", "LastEditorUserId": "1413395", "LastEditDate": "2017-05-15T22:05:49.607", "Id": "43989418", "Score": "5", "CreationDate": "2017-05-15T21:55:50.337", "LastActivityDate": "2017-05-15T22:05:49.607"}, "43989060": {"ParentId": "43988835", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>You can do this, although it's <strong>not at all recommended</strong>; doing what's show below is <strong>very very bad</strong> practice and leads to \"Undefined behavior\"</p>\n<pre><code> const Cat* pCat = nullptr;\n const Cat&amp; cat = *pCat; // yikes! NULL reference...boo!\n Cat fluffy(cat);\n</code></pre>\n<p>If you're trying to doing something like this, you're probably approaching the problem <em>in a completely wrong way</em>, and you should <strong>rethink</strong> your solution.</p>\n", "OwnerUserId": "8877", "LastEditorUserId": "8877", "LastEditDate": "2017-05-15T21:31:02.917", "Id": "43989060", "Score": "-2", "CreationDate": "2017-05-15T21:25:34.413", "LastActivityDate": "2017-05-15T21:31:02.917"}, "43989088": {"ParentId": "43988835", "PostTypeId": "2", "CommentCount": "14", "Body": "<p><strong>Don't do the following in production code</strong>, but for the case of illustration, the following worked with \"gcc 5.4.0\".</p>\n<p>As there is UB (undefined behaviour) involved, using std::string here e.g. as a member variable of cat, the example is stripped down to:</p>\n<p>For the sake of bringing a 'cat' to life, you could do some reinterpret-cast to create your 'first' cat:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Cat {\n    public:\n        Cat(const Cat&amp; iCat) {\n        }\n};\n\nint main() {        \n    Cat* cat = reinterpret_cast&lt;Cat*&gt;(new char[sizeof(Cat)]);\n    Cat cat2 = Cat(*cat);\n    delete cat;\n}\n</code></pre>\n<p><strong>Again, the above code is just for illustration purpose, only worked on gcc 5.4.0 and does not guarantee that it works with other compilers.</strong></p>\n<p>There is the chance to easily introduce UB in the code, by expanding it as explained in the comments e.g:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Cat {\n    private:\n        std::string name_;\n    public:\n        Cat(const Cat&amp; iCat) {\n           this-&gt;name_ = iCat.name_;\n        }\n        void setName(const std::string&amp; name) { name_ = name; }\n        const std::string&amp; name() { return name_; }\n};\n\nint main() {        \n    Cat* cat = reinterpret_cast&lt;Cat*&gt;(new char[sizeof(Cat)]);\n    cat-&gt;setName(\"Lilly\");\n    Cat cat2 = Cat(*cat);\n    std::cout &lt;&lt; cat2.name() &lt;&lt; std::endl;\n    delete cat;\n}\n</code></pre>\n", "OwnerUserId": "2999921", "LastEditorUserId": "2999921", "LastEditDate": "2017-05-15T22:17:39.657", "Id": "43989088", "Score": "-2", "CreationDate": "2017-05-15T21:27:53.397", "LastActivityDate": "2017-05-15T22:17:39.657"}, "43989937": {"ParentId": "43988835", "CommentCount": "0", "Body": "<p>Taking advantage of C++14 [class.mem]/18:</p>\n<blockquote>\n<p id=\"so_43988835_43989937_0\">If a standard-layout union contains two or more standard-layout structs that share a common initial sequence,\n  and if the standard-layout union object currently contains one of these standard-layout structs, it is permitted\n  to inspect the common initial part of any of them. Two standard-layout structs share a common initial\n  sequence if corresponding members have layout-compatible types and either neither member is a bit-field or\n  both are bit-fields with the same width for a sequence of one or more initial members.</p>\n</blockquote>\n<p><code>Cat</code> is standard-layout, so we can make a union that contains two types of common initial sequence.   Any two standard-layout classes with no data members meet the criteria for having a common initial sequence, so:</p>\n<pre><code>class Cat {\n    public: Cat(const Cat&amp; iCat);\n};\n\nclass Dog {\n    public: Dog();\n};\n\nunion CatDog\n{\n    Dog dog;\n    Cat cat;\n};\n\nint main()\n{\n    CatDog horse{};\n    Cat cat(horse.cat);\n}\n</code></pre>\n<hr>\n<p><em>Note:</em> The standard does not precisely define the meaning of \"inspect the common initial part\".  If the common initial part coincides with the entirety of the struct, does that mean the entire struct can be inspected as in my code? I guess that is a question for the language-lawyers.</p>\n</hr>", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "43989937", "Score": "1", "CreationDate": "2017-05-15T22:47:37.467", "LastActivityDate": "2017-05-15T22:47:37.467"}, "43988835": {"CommentCount": "5", "AcceptedAnswerId": "43989740", "CreationDate": "2017-05-15T21:08:00.333", "LastActivityDate": "2017-05-15T22:48:20.987", "PostTypeId": "1", "ViewCount": "147", "FavoriteCount": "1", "Title": "How to create the first object if only copy constructor is declared?", "Id": "43988835", "Score": "1", "Body": "<p>I saw a C++03 example online today.</p>\n<pre><code>class Cat {\n    public:\n        Cat(const Cat&amp; iCat);\n};\n</code></pre>\n<p>I was told that in this case, no default constructor will be automatically generated by compiler. If it is true, this means new Cat object can be created from an existing Cat object.</p>\n<p>Can anyone tell me how to create the first Cat object in this case? or kindly correct me if my understanding is wrong.</p>\n", "Tags": "<c++><copy-constructor><default-constructor>", "OwnerUserId": "2707055", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_43988835_43989740_2": {"section_id": 5852, "quality": 1.0, "length": 9}, "so_43988835_43989937_0": {"section_id": 5878, "quality": 1.0, "length": 50}, "so_43988835_43989740_0": {"section_id": 5876, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_43988835_43989740_2": {"section_id": 5622, "quality": 1.0, "length": 9}, "so_43988835_43989937_0": {"section_id": 5649, "quality": 1.0, "length": 50}, "so_43988835_43989740_0": {"section_id": 5647, "quality": 1.0, "length": 22}}, "n4659": {"so_43988835_43989740_2": {"section_id": 7331, "quality": 0.8888888888888888, "length": 8}, "so_43988835_43989740_0": {"section_id": 7361, "quality": 0.8181818181818182, "length": 18}}}, "43989740": {"ParentId": "43988835", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>First of all, the valid answer should be that there is no way to create the first <code>Cat</code>. The example was probably only pulled out to demonstrate how a user-declared constructor will prevent the implicitly-declared default constructor to be declared.</p>\n<hr>\n<p>Now, in spite of this, and purely if the means justifies the ends, there is, however, ways of creating the first cat using a <em>layout-compatible</em> object.</p>\n<p>C++11 introduced <strong>layout compatibility:</strong></p>\n<blockquote>\n<p id=\"so_43988835_43989740_0\">Two standard-layout struct (Clause 9) types are layout-compatible if they have the same number of non-static data members and corresponding non-static data members (in declaration order) have layout-compatible types (3.9).</p>\n<hr>\n<p id=\"so_43988835_43989740_1\">A standard-layout class is a class that:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</li>\n<li>has no virtual functions (10.3) and no virtual base classes (10.1),</li>\n<li>has the same access control (Clause 11) for all non-static data members,</li>\n<li>has no non-standard-layout base classes,</li>\n<li>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and\n  *has no base classes of the same type as the first non-static data member.</li>\n</ul>\n<p id=\"so_43988835_43989740_2\">A standard-layout struct is a standard-layout class defined with the class-key <code>struct</code> or the class-key <code>class</code>.</p>\n</hr></blockquote>\n<p>This means that you can do:</p>\n<pre><code>class Cat {\npublic:\n    Cat(const Cat&amp; iCat) : x{iCat.x} {}\n    int x;\n};\n\nclass foo {\npublic:\n    foo(int x) : m_x{x} {}\n    int m_x;\n};\n\nint main() {\n    foo f{5};\n    Cat* c1 = reinterpret_cast&lt;Cat*&gt;(&amp;f);\n    Cat c2 = *c1;\n    std::cout &lt;&lt; c2.x &lt;&lt; std::endl; // 5\n}\n</code></pre>\n<p>The <code>x</code> and <code>m_x</code> members are used to demonstrate the copying of (layout-compatible) members.</p>\n<p><em>Note: As mentioned in comment by <a href=\"https://stackoverflow.com/questions/43988835/how-to-create-the-first-object-if-only-copy-constructor-is-declared#comment75008817_43989740\">@M.M</a>, you might need to disable strict aliasing in your compiler for this to work.</em></p>\n</hr>", "OwnerUserId": "873025", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:29.303", "Id": "43989740", "Score": "2", "CreationDate": "2017-05-15T22:25:31.497", "LastActivityDate": "2017-05-15T22:48:20.987"}});