post_cb({"42074544": {"ParentId": "42074424", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_42074424_42074544_0\">Is the above program guaranteed to return 0 in C++14? Why?</p>\n</blockquote>\n<p>Yes. From [vector.capacity]:</p>\n<blockquote>\n<p id=\"so_42074424_42074544_1\"><code>void resize(size_type sz);</code><br>\n<em>13 Effects</em>: If <code>sz &lt; size()</code>, erases the last <code>size() - sz</code> elements from the sequence. Otherwise, appends <code>sz - size()</code> <strong>default-inserted</strong> elements to the sequence.</br></p>\n</blockquote>\n<p>Where, from [container.requirements.general]:</p>\n<blockquote>\n<p id=\"so_42074424_42074544_2\">An element of <code>X</code> is <em>default-inserted</em> if it is initialized by evaluation of the expression <code>allocator_traits&lt;A&gt;::construct(m, p)</code> where <code>p</code> is the address of the uninitialized storage for the element allocated within <code>X</code>.</p>\n</blockquote>\n<p><code>construct</code> for <code>std::allocator&lt;T&gt;</code> does, from [default.allocator]:</p>\n<blockquote>\n<pre><code>template &lt;class U, class... Args&gt;\nvoid construct(U* p, Args&amp;&amp;... args);\n</code></pre>\n<p id=\"so_42074424_42074544_3\"><em>Effects</em>: <code>::new((void *)p) U(std::forward&lt;Args&gt;(args)...)</code></p>\n</blockquote>\n<p>So, that's value-initialization. We're doing <code>new S()</code>, not <code>new S</code>, so the member <code>x</code> will be zero-initialized. </p>\n<hr/>\n<p>The ways of <em>avoiding</em> this behavior (if desired) are either:</p>\n<ol>\n<li>Change the allocator. Provide your own allocator type that has two overloads for <code>construct</code>: one empty (which would do default-initialization) and one taking <code>Args&amp;&amp;...</code>. </li>\n<li>Change the type. Add a default constructor to <code>S</code> that does no initialization.</li>\n</ol>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-02-06T18:23:05.703", "Id": "42074544", "Score": "3", "CreationDate": "2017-02-06T18:15:28.063", "LastActivityDate": "2017-02-06T18:23:05.703"}, "42074466": {"ParentId": "42074424", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, because <code>std::vector::resize</code> and similar methods perform value initialization by default<sup>\u2020</sup> which in turn value-initializes the members of aggregates:</p>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/language/value_initialization\" rel=\"nofollow noreferrer\">cppr:</a></p>\n<blockquote>\n<p id=\"so_42074424_42074466_0\">The effects of value initialization are:<br>\n  [...]<br>\n  if T is a class type with a default constructor that is neither user-provided nor deleted (that is, it may be a class with an implicitly-defined or defaulted default constructor), the object is zero-initialized and then it is default-initialized if it has a non-trivial default constructor; </br></br></p>\n</blockquote>\n<p>and the <a href=\"http://en.cppreference.com/w/cpp/language/zero_initialization\" rel=\"nofollow noreferrer\">Zero Initialiation</a> part does what we need:</p>\n<blockquote>\n<p id=\"so_42074424_42074466_1\">If T is an non-union class type, all base classes and non-static data members are zero-initialized, and all padding is initialized to zero bits. The constructors, if any, are ignored. </p>\n</blockquote>\n<p>And of course, zero initialization of our member does the right thing:</p>\n<blockquote>\n<p id=\"so_42074424_42074466_2\">If T is a scalar type, the object's initial value is the integral constant zero explicitly converted to T. </p>\n</blockquote>\n<hr>\n<p><sup>\u2020</sup>The default allocator does, custom allocators may use different initialization. You can use those to leave such values unitialized, see the full article on <a href=\"http://en.cppreference.com/w/cpp/concept/DefaultInsertable\" rel=\"nofollow noreferrer\">default-insert</a>.</p>\n</hr>", "OwnerUserId": "3002139", "LastEditorUserId": "3002139", "LastEditDate": "2017-02-06T18:26:50.997", "Id": "42074466", "Score": "3", "CreationDate": "2017-02-06T18:09:50.467", "LastActivityDate": "2017-02-06T18:26:50.997"}, "bq_ids": {"n4140": {"so_42074424_42074544_2": {"section_id": 715, "quality": 0.8461538461538461, "length": 11}, "so_42074424_42074466_0": {"section_id": 3287, "quality": 0.56, "length": 14}, "so_42074424_42074466_1": {"section_id": 3285, "quality": 0.5555555555555556, "length": 10}}, "n3337": {"so_42074424_42074466_1": {"section_id": 3155, "quality": 0.5555555555555556, "length": 10}}, "n4659": {"so_42074424_42074544_1": {"section_id": 868, "quality": 0.8, "length": 12}, "so_42074424_42074466_0": {"section_id": 4049, "quality": 0.56, "length": 14}, "so_42074424_42074544_2": {"section_id": 745, "quality": 0.8461538461538461, "length": 11}, "so_42074424_42074466_1": {"section_id": 4047, "quality": 0.6111111111111112, "length": 11}}}, "42074424": {"CommentCount": "1", "ViewCount": "168", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2017-02-06T18:07:23.227", "LastActivityDate": "2017-02-06T18:26:50.997", "Title": "Container of struct containing primitive type, zero initialized?", "LastEditDate": "2017-02-06T18:17:22.287", "Id": "42074424", "Score": "7", "Body": "<pre><code>#include &lt;vector&gt;\nstruct S { int x; };\nstd::vector&lt;S&gt; v;\nint main() { v.resize(1000); return v[42].x; }\n</code></pre>\n<p>Is the above program guaranteed to return 0 in C++14?  Why?</p>\n", "Tags": "<c++><c++14>", "OwnerUserId": "1131467", "AnswerCount": "2"}});