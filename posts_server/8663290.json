post_cb({"8663393": {"ParentId": "8663290", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You are only allowed to cast away constness of an object which is known <strong>not</strong> to be <code>const</code>. For example, an interface may pass objects through using a <code>const</code> pointer or a <code>const</code> reference but you passed in an object which isn't <code>const</code> and want/need to modify it. In this case it may be right thing to cast away constness.</p>\n<p>On the other hand, casting away constness of an object which was <code>const</code> all the way can land you in deep trouble: when accessing this object, in particular when writing to it, the system may cause all kinds of strange things: the behavior is not defined (by the C++ standard) and on a particular system it may cause e.g. an access violation (because the address of the object is arranged to be in a read-only area).</p>\n<p>Note that despite another response I saw <code>const</code> objects need to get an address assigned if the address is ever taken and used in some way. In your code the <code>const_cast&lt;int&amp;&gt;(maxint)</code> expression essentially obtains the address of your constant int which is apparently stored in a memory area which is marked to be read-only. The interesting aspect of your code snippet is that it is like to <strong>apparently</strong> work, especially when turning on optimization: the code is simple enough that the compiler can tell that the changed location isn't really used and doesn't actually attempt to change the memory location! In this case, no access violation is reported. This is what apparently is the case when the constant is declared inside the function (although the constant may also be located on the stack which typically can't be marked as read-only). Another potential outcome of your code is (independent of whether the constant is declared inside the function or not) is that is actually changed and sometimes read as 100 and in other contexts (which in some way or another involve the address) as 200.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2013-12-17T00:37:29.433", "Id": "8663393", "Score": "0", "CreationDate": "2011-12-29T02:25:20.640", "LastActivityDate": "2013-12-17T00:37:29.433"}, "8663397": {"ParentId": "8663290", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Modifying an object that is <code>const</code> (with the exception of mutable members) results in undefined behavior (from the C++03 standard):</p>\n<blockquote>\n<p id=\"so_8663290_8663397_0\">7.1.5.1/4  \"The cv-qualifiers\"</p>\n<p id=\"so_8663290_8663397_1\">Except that any class member declared mutable (7.1.1) can be modified,\n  any attempt to modify a const object during its lifetime (3.8) results\n  in undefined behavior.</p>\n</blockquote>\n<p>The above undefined behavior is specifically called out in the standard's section on <code>const_cast</code>:</p>\n<blockquote>\n<p id=\"so_8663290_8663397_2\">5.2.11/7 \"Const cast\"</p>\n<p id=\"so_8663290_8663397_3\">[Note: Depending on the type of the object, a write operation through\n  the pointer, lvalue or pointer to data member resulting from a\n  const_cast that casts away a const-qualifier68) may produce undefined\n  behavior (7.1.5.1).  ]</p>\n</blockquote>\n<p>So, if you have a <code>const</code> pointer or reference to an object that isn't actually <code>const</code>, you're allowed to write to that object (by casting away the constness), but not if the object really is <code>const</code>.</p>\n<p>The compiler is permitted to place <code>const</code> objects in read-only storage, for example. It doesn't have to though, and apparently doesn't for your test code that doesn't crash.</p>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2011-12-29T02:32:40.820", "Id": "8663397", "Score": "5", "CreationDate": "2011-12-29T02:25:59.300", "LastActivityDate": "2011-12-29T02:32:40.820"}, "8663311": {"ParentId": "8663290", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>They are correct, it is undefined behaviour. You're not allowed to modify the value of a <code>const</code> variable, which is the danger of casting away the <code>const</code>ness of something: you better <em>know</em> it's not really <code>const</code>.</p>\n<p>The compiler, seeing that <code>maxint</code> is <code>const</code> and should <em>never</em> be modified, doesn't even have to give it an address. It can just replace all the uses of <code>maxint</code> with 100 if it sees fit. Also it might just put the constant in to a portion of memory that is read-only, as Matteo Italia points out, which is probably what's happening for you. That's why modifying it produces undefined behaviour.</p>\n<p>The only way you can safely cast away the <code>const</code>ness of a variable is if the variable is not actually <code>const</code>, but the <code>const</code> qualifier was added to a non-<code>const</code> variable, like this:</p>\n<pre><code>int f(const int&amp; x) {\n    int&amp; nonconst = const_cast&lt;int&amp;&gt;(x);\n\n    ++nonconst;\n}\n\nint blah = 523;\n\nf(blah); // this is safe\n\nconst int constblah = 123;\n\nf(constblah); // this is undefined behaviour\n</code></pre>\n<p>Think about this example, which compiles perfectly:</p>\n<pre><code>int f(const int&amp; x) {\n    int&amp; nonconst = const_cast&lt;int&amp;&gt;(x);\n\n    ++nonconst;\n}\n\nint main() {\n    f(4); // incrementing a number literal???\n}\n</code></pre>\n<p>You can see how using <code>const_cast</code> is pretty dangerous because there's no way to actually tell whether a variable is originally <code>const</code> or not. You should avoid using <code>const_cast</code> when possible (with functions, by just not accepting <code>const</code> parameters).</p>\n", "OwnerUserId": "726361", "LastEditorUserId": "726361", "LastEditDate": "2011-12-29T02:26:20.523", "Id": "8663311", "Score": "9", "CreationDate": "2011-12-29T02:09:56.563", "LastActivityDate": "2011-12-29T02:26:20.523"}, "8663290": {"CommentCount": "1", "AcceptedAnswerId": "8663311", "CreationDate": "2011-12-29T02:05:53.337", "LastActivityDate": "2013-12-17T00:37:29.433", "PostTypeId": "1", "ViewCount": "373", "FavoriteCount": "4", "Title": "const cast to a global var and program crashed (C++)", "Id": "8663290", "Score": "2", "Body": "<pre><code>int main()\n{\n    const int maxint=100;//The program will crash if this line is put outside the main\n    int &amp;msg=const_cast&lt;int&amp;&gt;(maxint);  \n    msg=200;  \n    cout&lt;&lt;\"max:\"&lt;&lt;msg&lt;&lt;endl; \n    return 0;\n}\n</code></pre>\n<p>The function will run ok if the 'const int maxint=100;' definition is put inside the main function but crash and popup a error message said \"Access Violation\" if put outside.</p>\n<p>Someone says it's some kind of 'undefined behavior', and i want to know the exact answer and how i can use the const cast safely?</p>\n", "Tags": "<c++><const-cast>", "OwnerUserId": "579339", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_8663290_8663397_1": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}, "so_8663290_8663397_3": {"section_id": 6057, "quality": 0.8636363636363636, "length": 19}}, "n3337": {"so_8663290_8663397_1": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}, "so_8663290_8663397_3": {"section_id": 5825, "quality": 0.8636363636363636, "length": 19}}, "n4659": {"so_8663290_8663397_1": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}, "so_8663290_8663397_3": {"section_id": 7555, "quality": 0.8636363636363636, "length": 19}}}});