post_cb({"1675094": {"Id": "1675094", "PostTypeId": "2", "Body": "<p>The long and short of it is that if you haven't made any allocations of other entities in you object(as in your example) then the memory that was allocated will be deleted automatically. However, any new statements(or anything else that directly manages memory) needs to be handled in a catch statement in the constructor, Otherwise the object is deleted without deleting it's subsequent allocations and you, my friend, have a leak.</p>\n", "LastActivityDate": "2009-11-04T16:43:46.420", "CommentCount": "0", "CreationDate": "2009-11-04T16:43:46.420", "ParentId": "1674980", "Score": "2", "OwnerUserId": "202059"}, "1675140": {"Id": "1675140", "PostTypeId": "2", "Body": "<p>If an object cannot complete destruction because the constructor throws an exception, the first thing to happen (this happens as part of the constructor's special handling) is that all member variables to have been constructed are destroyed - if an exception is thrown in the initializer list, this means that only elements for which the initializer has completed are destroyed.</p>\n<p>Then, if the object was being allocated with <code>new</code>, the appropriate deallocation function (<code>operator delete</code>) is called with the same additional arguments that were passed to <code>operator new</code>. For instance, <code>new (std::nothrow) SomethingThatThrows()</code> will allocate memory with <code>operator new (size_of_ob, nothrow)</code>, attempt to construct <code>SomethingThatThrows</code>, destroy any members that were successfully constructed, then call <code>operator delete (ptr_to_obj, nothrow)</code> when an exception is propagated - it won't leak memory.</p>\n<p>What you have to be careful is allocating several objects in succession - if one of the later ones throws, the previous ones will not be automatically be deallocated. The best way around this is with smart pointers, because as local objects their destructors will be called during stack unwinding, and their destructors will properly deallocate memory.</p>\n", "LastActivityDate": "2009-11-04T16:49:50.917", "CommentCount": "1", "CreationDate": "2009-11-04T16:49:50.917", "ParentId": "1674980", "Score": "22", "OwnerUserId": "16855"}, "1675682": {"Id": "1675682", "PostTypeId": "2", "Body": "<p>From the C++ 2003 Standard 5.3.4/17 - New:</p>\n<blockquote>\n<p id=\"so_1674980_1675682_0\">If any part of the object initialization described above terminates by throwing an exception and a suitable deallocation  function  can  be  found,  the  deallocation  function  is  called  to  free  the  memory  in  which the object was being constructed, after which the exception continues to propagate in the context of the new-expression.  If  no  unambiguous  matching  deallocation  function  can  be  found,  propagating  the  exception does not cause the object\u2019s memory to be freed.  [Note: This is appropriate when the called allocation function does not allocate memory; otherwise, it is likely to result in a memory leak.  ]</p>\n</blockquote>\n<p>So there may or may not be a leak - it depends on whether an appropriate deallocator can be found (which is normally the case, unless operator new/delete have been overridden).In the case where there's a suitable deallocator, the compiler is responsible for wiring in a call to it if the constructor throws.</p>\n<p>Note that this is more or less unrelated to what happens to resources acquired in the constructor, which is what my first attempt at an answer discussed - and is a question that is discussed in many FAQs, articles, and postings.</p>\n", "LastActivityDate": "2009-11-04T18:16:51.940", "CommentCount": "0", "CreationDate": "2009-11-04T18:16:51.940", "ParentId": "1674980", "Score": "4", "OwnerUserId": "12711"}, "1675033": {"Id": "1675033", "PostTypeId": "2", "Body": "<p>You should refer to the similar questions <a href=\"https://stackoverflow.com/questions/1230423/c-handle-resources-if-constructors-may-throw-exceptions-reference-to-faq-17\">here</a> and <a href=\"https://stackoverflow.com/questions/1197566/is-it-ever-not-safe-to-throw-an-exception-in-a-constructor\">here</a>.\nBasically if the constructor throws an exception you're safe that the memory of the object itself is freed again. Although, if other memory has been claimed during the constructor, you're on your own to have it freed before leaving the constructor with the exception.</p>\n<p>For your question WHO deletes the memory the answer is the code behind the new-operator (which is generated by the compiler). If it recognizes an exception leaving the constructor it has to call all the destructors of the classes members (as those have already been constructed successfully prior calling the constructor code) and free their memory (could be done recursively together with destructor-calling, most probably by calling a proper <em>delete</em> on them) as well as free the memory allocated for this class itself. Then it has to rethrow the catched exception from the constructor to the caller of <em>new</em>. \nOf course there may be more work which has to be done but I cannot pull out all the details from my head because they are up to each compiler's implementation.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2009-11-04T17:01:10.433", "Score": "29", "CreationDate": "2009-11-04T16:36:23.900", "ParentId": "1674980", "CommentCount": "6", "OwnerUserId": "57601", "LastEditDate": "2017-05-23T12:25:02.703"}, "1675030": {"Id": "1675030", "PostTypeId": "2", "Body": "<p>I think it's kind of wierd for a constructor to raise an exception.\nCould you have a return value and test it in your main?</p>\n<pre><code>class Blah\n{\n   public:\n\n   Blah()\n       {\n           if Error\n           {\n              this.Error = \"oops\";\n           }\n        }\n};\n\nvoid main()\n{\nBlah* b = NULL;\n\nb = new Blah();\n\nif (b.Error == \"oops\")\n{\n   delete (b);\n   b = NULL;\n}\n</code></pre>\n", "LastEditorUserId": "496830", "LastActivityDate": "2011-11-29T13:04:37.227", "Score": "-6", "CreationDate": "2009-11-04T16:35:31.303", "ParentId": "1674980", "CommentCount": "4", "OwnerUserId": "202703", "LastEditDate": "2011-11-29T13:04:37.227"}, "bq_ids": {"n4140": {"so_1674980_1675682_0": {"length": 54, "quality": 0.9642857142857143, "section_id": 6101}}, "n3337": {"so_1674980_1675682_0": {"length": 54, "quality": 0.9642857142857143, "section_id": 5867}}, "n4659": {"so_1674980_1675682_0": {"length": 54, "quality": 0.9642857142857143, "section_id": 7598}}}, "1675097": {"Id": "1675097", "PostTypeId": "2", "Body": "<p>If the Constructor throws the memory allocated for the object is auto-magically returned to the system.</p>\n<p>Note the destructor of the class that threw will not be called.<br>\nBut the destructor of any base class (where the base constructor has completed)  will also be called.</br></p>\n<p>Note:<br>\nAs most other people have noted members may need some clean up.</br></p>\n<p>Members that have been fully initialized will have their destructors called, but if you have any RAW pointer members that you own (ie delete in the destructor) you will have to do some clean up before you do the throw (another reason not to use owned RAW pointers in your class). </p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Base\n{\n    public:\n        Base()  {std::cout &lt;&lt; \"Create  Base\\n\";}\n        ~Base() {std::cout &lt;&lt; \"Destroy Base\\n\";}\n};\n\nclass Deriv: public Base\n{\n    public:\n        Deriv(int x)    {std::cout &lt;&lt; \"Create  Deriv\\n\";if (x &gt; 0) throw int(x);}\n        ~Deriv()        {std::cout &lt;&lt; \"Destroy Deriv\\n\";}\n};\n\nint main()\n{\n    try\n    {\n        {\n            Deriv       d0(0);  // All constructors/Destructors called.\n        }\n        {\n            Deriv       d1(1);  // Base constructor and destructor called.\n                                // Derived constructor called (not destructor)\n        }\n    }\n    catch(...)\n    {\n        throw;\n        // Also note here.\n        // If an exception escapes main it is implementation defined\n        // whether the stack is unwound. By catching in main() you force\n        // the stack to unwind to this point. If you can't handle re-throw\n        // so the system exception handling can provide the appropriate\n        // error handling (such as user messages).\n    }\n}\n</code></pre>\n", "LastEditorUserId": "14065", "LastActivityDate": "2009-11-05T16:53:04.403", "Score": "6", "CreationDate": "2009-11-04T16:43:57.270", "ParentId": "1674980", "CommentCount": "1", "OwnerUserId": "14065", "LastEditDate": "2009-11-05T16:53:04.403"}, "1675018": {"Id": "1675018", "PostTypeId": "2", "Body": "<p>Quoted from C++ FAQ (<a href=\"http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.10\" rel=\"nofollow noreferrer\">parashift.com</a>):</p>\n<blockquote>\n<h2>[17.4] How should I handle resources if my constructors may throw\n  exceptions?</h2>\n<p id=\"so_1674980_1675018_0\">Every data member inside your object should clean up its own mess.</p>\n<p id=\"so_1674980_1675018_1\">If a constructor throws an exception, the object's destructor is not\n  run. If your object has already done something that needs to be undone\n  (such as allocating some memory, opening a file, or locking a\n  semaphore), this \"stuff that needs to be undone\" <em>must</em> be remembered\n  by a data member inside the object.</p>\n<p id=\"so_1674980_1675018_2\">For example, rather than allocating memory into a raw <code>Fred*</code> data\n  member, put the allocated memory into a \"smart pointer\" member object,\n  and the destructor of this smart pointer will <code>delete</code> the <code>Fred</code>\n  object when the smart pointer dies. The template <code>std::auto_ptr</code> is an\n  example of such as \"smart pointer.\" You can also <a href=\"http://www.parashift.com/c++-faq-lite/freestore-mgmt.html#faq-16.22\" rel=\"nofollow noreferrer\">write your own\n  reference counting smart pointer</a>. You can also <a href=\"http://www.parashift.com/c++-faq-lite/operator-overloading.html#faq-13.3\" rel=\"nofollow noreferrer\">use smart pointers\n  to \"point\" to disk records or objects on other machines</a>.</p>\n<p id=\"so_1674980_1675018_3\">By the way, if you think your <code>Fred</code> class is going to be allocated\n  into a smart pointer, be nice to your users and create a <code>typedef</code>\n  within your <code>Fred</code> class:</p>\n<pre><code> #include &lt;memory&gt;\n\n class Fred {\n public:\n   typedef std::auto_ptr&lt;Fred&gt; Ptr;\n   ...\n };\n</code></pre>\n<p id=\"so_1674980_1675018_4\">That typedef simplifies the syntax of all the code that uses your\n  objects: your users can say <code>Fred::Ptr</code> instead of\n  <code>std::auto_ptr&lt;Fred&gt;</code>:</p>\n<pre><code> #include \"Fred.h\"\n\n void f(std::auto_ptr&lt;Fred&gt; p);  // explicit but verbose\n void f(Fred::Ptr           p);  // simpler\n\n void g()\n {\n   std::auto_ptr&lt;Fred&gt; p1( new Fred() );  // explicit but verbose\n   Fred::Ptr           p2( new Fred() );  // simpler\n   ...\n }\n</code></pre>\n</blockquote>\n", "LastEditorUserId": "496830", "LastActivityDate": "2011-11-29T13:08:29.097", "Score": "0", "CreationDate": "2009-11-04T16:33:51.150", "ParentId": "1674980", "CommentCount": "3", "OwnerUserId": "35501", "LastEditDate": "2011-11-29T13:08:29.097"}, "6639682": {"Id": "6639682", "PostTypeId": "2", "Body": "<p>The problem described is as old as the road to Rome, to use a Dutch saying. I have worked out the problem and a memory allocation for an object that might throw an exception looks as follows:</p>\n<pre><code>try\n{\n    std::string *l_string =\n        (_heap_cleanup_tpl&lt;std::string&gt;(&amp;l_string),\n        new std::string(0xf0000000, ' '));\n    delete l_string;\n}\ncatch(std::exception &amp;)\n{\n}\n</code></pre>\n<p>Before the actual call to the <code>new</code>-operator, a nameless (temporary) object is created, which receives the address of the allocated memory through a user-defined new-operator (see the rest of this answer). In case of normal programme execution, the temporary object passes the result of the new-operator (the newly created and fully constructed object, in our case a very very very long string) to the variable <code>l_string</code>. In case of an exception, the value is not passed on, but the destructor of the temporary object deletes the memory (without ofcourse calling the destructor of the main object).</p>\n<p>It is a bit fuzzy way of dealing with the issue, but it works. Problems may arise because this solution requires a user-defined new-operator and a user-defined delete-operator to go allong with it. The user-defined new/delete-operators would have to call the C++-standard library's implementation of new/delete-operators, but I have left that out for briefity and relied on <code>malloc()</code> and <code>free()</code> instead.</p>\n<p>It is not the final answer, but I think it is worth working this one out.</p>\n<p>PS: There was an 'undocumented' feature in the code below, so I have made an improvement. </p>\n<p>The code for the temporary object is as follows:</p>\n<pre><code>class _heap_cleanup_helper\n{\n    public:\n    _heap_cleanup_helper(void **p_heap_block) :\n        m_heap_block(p_heap_block),\n        m_previous(m_last),\n        m_guard_block(NULL)\n    {\n        *m_heap_block = NULL;\n        m_last = this;\n    }\n    ~_heap_cleanup_helper()\n    {\n        if (*m_heap_block == NULL) operator delete(m_guard_block);\n        m_last = m_previous;\n    }\n    void **m_heap_block, *m_guard_block;\n    _heap_cleanup_helper *m_previous;\n    static _heap_cleanup_helper *m_last;\n};\n\n_heap_cleanup_helper *_heap_cleanup_helper::m_last;\n\ntemplate &lt;typename p_alloc_type&gt;\nclass _heap_cleanup_tpl : public _heap_cleanup_helper\n{\n    public:\n    _heap_cleanup_tpl(p_alloc_type **p_heap_block) :\n        _heap_cleanup_helper((void **)p_heap_block)\n    {\n    }\n};\n</code></pre>\n<p>The user-defined new-operator is as follows:</p>\n<pre><code>void *operator new (size_t p_cbytes)\n{\n    void *l_retval = malloc(p_cbytes);\n\n    if (\n        l_retval != NULL &amp;&amp;\n        *_heap_cleanup_helper::m_last-&gt;m_heap_block == NULL &amp;&amp;\n        _heap_cleanup_helper::m_last-&gt;m_guard_block == NULL\n    )\n    {\n        _heap_cleanup_helper::m_last-&gt;m_guard_block = l_retval;\n    }\n    if (p_cbytes != 0 &amp;&amp; l_retval == NULL) throw std::bad_alloc();\n\n    return l_retval;\n}\n\nvoid operator delete(void *p_buffer)\n{\n    if (p_buffer != NULL) free(p_buffer);\n}\n</code></pre>\n", "LastEditorUserId": "496830", "LastActivityDate": "2011-11-29T13:13:37.890", "Score": "-2", "CreationDate": "2011-07-10T06:46:48.173", "ParentId": "1674980", "CommentCount": "6", "OwnerUserId": "837396", "LastEditDate": "2011-11-29T13:13:37.890"}, "1674980": {"ViewCount": "9303", "Body": "<p>I really can't believe I couldn't find a clear answer to this...</p>\n<p>How do you free the memory allocated after a C++ class constructor throws an exception, in the case where it's initialised using the <code>new</code> operator. E.g.:</p>\n<pre><code>class Blah\n{\npublic:\n  Blah()\n  {\n    throw \"oops\";\n  }\n};\n\nvoid main()\n{\n  Blah* b = NULL;\n  try\n  {\n    b = new Blah();\n  }\n  catch (...)\n  {\n    // What now?\n  }\n}\n</code></pre>\n<p>When I tried this out, <code>b</code> is NULL in the catch block (which makes sense).</p>\n<p>When debugging, I noticed that the conrol enters the memory allocation routine BEFORE it hits the constructor. </p>\n<p>This on the MSDN website <a href=\"http://msdn.microsoft.com/en-us/library/kewsb8ba.aspx\" rel=\"noreferrer\">seems to confirm this</a>:</p>\n<blockquote>\n<p id=\"so_1674980_1674980_0\">When new is used to allocate memory\n  for a C++ class object, the object's\n  constructor is called after the memory\n  is allocated.</p>\n</blockquote>\n<p>So, bearing in mind that the local variable <code>b</code> is never assigned (i.e. is NULL in the catch block) how do you delete the allocated memory? </p>\n<p>It would also be nice to get a cross platform answer on this. i.e., what does the C++ spec say?</p>\n<p>CLARIFICATION: I'm not talking about the case where the class has allocated memory itself in the c'tor and then throws. I appreciate that in those cases the d'tor won't be called. I'm talking about the memory used to allocate <em>THE</em> object (<code>Blah</code> in my case).</p>\n", "AcceptedAnswerId": "1675033", "Title": "Who deletes the memory allocated during a \"new\" operation which has exception in constructor?", "CreationDate": "2009-11-04T16:27:55.407", "Id": "1674980", "CommentCount": "9", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2011-11-29T13:10:05.523", "LastEditorUserId": "496830", "LastActivityDate": "2011-11-29T13:13:37.890", "Score": "37", "OwnerUserId": "31760", "Tags": "<c++><exception><memory-leaks><constructor>", "AnswerCount": "8"}});