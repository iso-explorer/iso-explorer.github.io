post_cb({"39281145": {"ParentId": "39280993", "CommentCount": "2", "Body": "<p><code>add_rvalue_reference&lt;T&gt;</code> only results in <code>T&amp;&amp;</code> if <code>T</code> is a referenceable type. So when <code>T</code> is <code>void</code>, the result is just <code>void</code>. This is also why you can <code>add_rvalue_reference&lt;int&amp;&amp;&gt;</code> and not get an error attempting to construct a reference to a reference. (Same with lvalue reference.)</p>\n", "OwnerUserId": "87234", "PostTypeId": "2", "Id": "39281145", "Score": "9", "CreationDate": "2016-09-01T21:29:27.440", "LastActivityDate": "2016-09-01T21:29:27.440"}, "bq_ids": {"n4140": {"so_39280993_39280993_0": {"section_id": 3954, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_39280993_39280993_0": {"section_id": 3812, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_39280993_39280993_0": {"section_id": 4841, "quality": 0.8571428571428571, "length": 6}}}, "39280993": {"CommentCount": "0", "ViewCount": "235", "PostTypeId": "1", "LastEditorUserId": "4987285", "CreationDate": "2016-09-01T21:17:43.073", "LastActivityDate": "2016-09-23T07:40:15.127", "Title": "Is std::declval<void>() a valid expression?", "AcceptedAnswerId": "39281145", "LastEditDate": "2016-09-23T07:40:15.127", "Id": "39280993", "Score": "13", "Body": "<p>As far as I know, I cannot declare an rvalue reference to <code>void</code>.<br>\nAs an example, the following code is ill-formed:</br></p>\n<pre><code> void f(void &amp;&amp;v) { }\n</code></pre>\n<p>From <a href=\"http://eel.is/c++draft/declval\" rel=\"noreferrer\">[20.2.6/1]</a> (function template declval) we have a declaration for <code>declval</code> that is:</p>\n<pre><code>template &lt;class T&gt;\nadd_rvalue_reference_t&lt;T&gt;\ndeclval() noexcept;\n</code></pre>\n<p>Thus, <code>declval&lt;void&gt;</code> (let me say) <em>would result</em> in <code>void &amp;&amp;</code>, that I guessed it was ill-formed as well as in the previous example.</p>\n<p>Anyway, the following minimal, working example compiles:</p>\n<pre><code>#include&lt;utility&gt;\n\nint main() {\n    decltype(std::declval&lt;void&gt;())* ptr = nullptr;\n}\n</code></pre>\n<p>Note that the following is true too:</p>\n<pre><code>static_assert(std::is_same&lt;decltype(std::declval&lt;void&gt;()), void&gt;::value, \"!\");\n</code></pre>\n<p>I would have expected it to be <code>void&amp;&amp;</code> as previously mentioned (or better, I was expecting it fails to compile).<br>\nActually, it happens to be an rvalue reference for any other non-reference type.<br>\nAs an example:</br></br></p>\n<pre><code>static_assert(std::is_same&lt;decltype(std::declval&lt;int&gt;()), int&amp;&amp;&gt;::value, \"!\");\n</code></pre>\n<p>Is <code>declval&lt;void&gt;</code> a valid expression or not? Is the code above legal?<br>\nWhy does the behavior in case of <code>void</code> is different than with any other type? (<em>For it wouldn't have worked otherwise</em> could be an answer, if the code is legal).</br></p>\n<p>If it's legal, where does the standard allow that? I've not been able to find the case.<br>\nOf course, the standard says:</br></p>\n<blockquote>\n<p id=\"so_39280993_39280993_0\">The template parameter\u00a0T\u00a0of\u00a0declval may be an incomplete type.</p>\n</blockquote>\n<p>Anyway, here it would result in a non acceptable type (<code>void&amp;&amp;</code>) and it works around it discarding the rvalue reference.</p>\n", "Tags": "<c++><c++11><language-lawyer><void><decltype>", "OwnerUserId": "4987285", "AnswerCount": "1"}});