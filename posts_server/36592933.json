post_cb({"36592933": {"ViewCount": "176", "Body": "<p>Dear fellow programmers,</p>\n<p>the code below gives me some headaches. It tries to add a 'generic' object (=object that can be constructed from anything) to a tuple and then copy that tuple. </p>\n<pre><code>    #include &lt;tuple&gt;\n    #include &lt;iostream&gt;\n    #include &lt;typeinfo&gt;\n\n\n    struct anything\n    {\n       anything()\n       {}\n\n       anything(const anything&amp;)\n       {\n          std::cout &lt;&lt; \"Called copy c'tor\" &lt;&lt; std::endl;\n       }\n\n       template&lt;class T&gt;\n       anything(T arg)\n       {\n          std::cout &lt;&lt; \"Called c'tor with with argument of type \" &lt;&lt; typeid(arg).name() &lt;&lt; std::endl;\n          // new T(arg); // causes stack overflow\n       }\n    };\n\n\n    int main()\n    {\n       std::tuple&lt;anything&gt; t;\n       //\n       std::cout &lt;&lt; \"Copy constructing t2, expecting copy c'tor to be called.\" &lt;&lt; std::endl;\n       std::tuple&lt;anything&gt; t2(t);\n\n       return 0;\n    }\n</code></pre>\n<p>With VS 2015 Update 2 it doesn't even compile, the line</p>\n<pre><code>std::tuple&lt;anything&gt; t2(t);\n</code></pre>\n<p>triggers a compiler error deep in tuple.h.\nWith gcc 5.3.1 it compiles, but the output is not what I'd expect:</p>\n<p>Copy constructing t2, expecting copy c'tor to be called.<br>\nCalled copy c'tor<br>\nCalled c'tor with with argument of type St5tupleIJ8anythingEE</br></br></p>\n<p>What I don't understand is the last line, i.e. why the templated constructor gets called with std::tuple as argument?</p>\n<p>This is actually a real world problem. In my application I use a boost::signal of signature </p>\n<pre><code> typedef boost::type_erasure::any\n         &lt;boost::mpl::vector&lt;\n         boost::type_erasure::typeid_&lt;&gt;,\n         boost::type_erasure::copy_constructible&lt;&gt;,\n         boost::type_erasure::less_than_comparable&lt;&gt;,\n         boost::type_erasure::equality_comparable&lt;&gt;,\n         boost::type_erasure::relaxed\n         &gt;&gt; KeyType;\n\nboost::signals2::signal&lt;void(const KeyType&amp;)&gt;\n</code></pre>\n<p>Boost signals internally wraps the argument in a tuple before calling the slot function with it, which eventually results in a stack overflow, because the tuple c'tor calls the any c'tor with tuple as argument and the any c'tor then calls the tuple c'tor with 'any of tuple' and so on and on and on...</p>\n", "AcceptedAnswerId": "36607925", "Title": "std::tuple with generic types like boost::any", "CreationDate": "2016-04-13T08:38:47.887", "Id": "36592933", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-04-13T19:33:33.230", "Score": "4", "OwnerUserId": "6197447", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "36607925": {"Id": "36607925", "PostTypeId": "2", "Body": "<p>Let's go through overload resolution for:</p>\n<pre><code>std::tuple&lt;anything&gt; t2(t);\n</code></pre>\n<p>We have three viable <a href=\"http://en.cppreference.com/w/cpp/utility/tuple/tuple\" rel=\"nofollow\">constructors</a> at our disposal:</p>\n<pre><code>explicit tuple( const Types&amp;... args ); // (2) with Types = [anything]\n\ntemplate&lt; class... UTypes &gt;\nexplicit tuple( UTypes&amp;&amp;... args );     // (3) with UTypes = [std::tuple&lt;anything&gt;&amp;]\n\ntuple( const tuple&amp; other ) = default;  // (8)\n</code></pre>\n<p>Which have these argument lists:</p>\n<pre><code>tuple(const anything&amp; );             // (2)\ntuple(std::tuple&lt;anything&gt;&amp; );       // (3)\ntuple(std::tuple&lt;anything&gt; const&amp; ); // (8)\n</code></pre>\n<p><code>(2)</code> involves a user-defined conversion whereas <code>(3)</code> and <code>(8)</code> are exact matches. When it comes to reference bindings:</p>\n<blockquote>\n<p id=\"so_36592933_36607925_0\">Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence\n  S2 if [...] S1 and S2 are reference bindings (8.5.3), and the types to which the references refer are the same\n  type except for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers\n  is more cv-qualified than the type to which the reference initialized by S1 refers.</p>\n</blockquote>\n<p>So <code>(3)</code> is preferred - since it's less cv-qualified than <code>(8)</code>. That constructor calls <code>anything(std::tuple&lt;anything&gt; )</code>. </p>\n<hr/>\n<p>As far as solutions, what you need is for <code>(3)</code> to not be considered in this case - we need to make it not a viable option (since <code>(8)</code> is already preferred to <code>(2)</code>). <em>Currently</em>, the easiest thing is just to make your constructor <code>explicit</code>:</p>\n<pre><code>template&lt;class T&gt;\nexplicit anything(T arg) { ... }\n</code></pre>\n<p>this works since <code>(3)</code> is specified in terms of <code>is_convertible&lt;&gt;</code>, which will return false on <code>explicit</code> conversions. However, that's currently considered a defect and will likely be changed in the future - since after all, we <em>are</em> explicitly constructing every aspect here so the <code>explicit</code> constructors should still be considered! </p>\n<p>Once that happens, you're kind of out of luck as far as direct copy construction goes. You'd have to do something like disable your <code>anything</code> constructor for <code>tuple</code>? That seems... not great. But in that case, marking that constructor <code>explicit</code> would still work for copy-initialization:</p>\n<pre><code>std::tuple&lt;anything&gt; t2 = t;\n</code></pre>\n<p>which works now even without marking the <code>anything</code> constructor <code>explicit</code>, due to the same aforementioned defect.</p>\n", "LastActivityDate": "2016-04-13T19:33:33.230", "CommentCount": "0", "CreationDate": "2016-04-13T19:33:33.230", "ParentId": "36592933", "Score": "2", "OwnerUserId": "2069064"}, "bq_ids": {"n4140": {"so_36592933_36607925_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 639}}, "n3337": {"so_36592933_36607925_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 629}}, "n4659": {"so_36592933_36607925_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 667}}}, "36593746": {"Id": "36593746", "PostTypeId": "2", "Body": "<p>If you look at the implementation of the tuple you'll notice that </p>\n<pre><code>_Tuple_val&lt;_This&gt; _Myfirst; // the stored element\n...\ntemplate&lt;class _This2,\n    class... _Rest2,\n    class = typename _Tuple_enable&lt;tuple&lt;_This2, _Rest2...&gt;, _Myt&gt;::type&gt;\n    explicit tuple(_This2&amp;&amp; _This_arg, _Rest2&amp;&amp;... _Rest_arg)\n    : _Mybase(_STD forward&lt;_Rest2&gt;(_Rest_arg)...),\n        _Myfirst(_STD forward&lt;_This2&gt;(_This_arg))\n    {   // construct from one or more moved elements\n    }\n</code></pre>\n<p>The constructor of the tuple passes first argument to the the constructor of the first element of tuple. As variable <code>t</code> has type <code>std::tuple&lt;anything&gt;</code> compiler finds the best match for constructing <code>anything</code> with <code>t</code> - a template constructor.</p>\n<p>To copy a tuple you simply need to write </p>\n<pre><code>std::tuple&lt;anything&gt; t2 = t;\n</code></pre>\n<hr>\n<p>UPD.</p>\n<p>According to standard std::tuple provides following constructors:</p>\n<pre><code>template &lt;class... UTypes&gt;\nexplicit constexpr tuple(const Types&amp;...);\n\ntemplate &lt;class... UTypes&gt;\nconstexpr tuple(const tuple&lt;UTypes...&gt;&amp;);\n</code></pre>\n<p>And apparently your template constructor is a better match than copy constructor of the tuple.</p>\n</hr>", "LastEditorUserId": "3344612", "LastActivityDate": "2016-04-13T09:44:57.120", "Score": "1", "CreationDate": "2016-04-13T09:13:16.957", "ParentId": "36592933", "CommentCount": "0", "OwnerUserId": "3344612", "LastEditDate": "2016-04-13T09:44:57.120"}});