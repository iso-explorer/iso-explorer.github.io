post_cb({"19433014": {"CommentCount": "4", "ViewCount": "499", "PostTypeId": "1", "LastEditorUserId": "1591041", "CreationDate": "2013-10-17T17:06:35.983", "LastActivityDate": "2013-10-17T18:40:20.247", "Title": "How to force not to use conversion constructor in C++", "AcceptedAnswerId": "19434526", "LastEditDate": "2013-10-17T17:28:33.963", "Id": "19433014", "Score": "1", "Body": "<p>I'm working on a project with matrices and I'm having a problem with overloaded operators.</p>\n<p>I have declared these user-friendly input/output functions: </p>\n<pre><code>friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, MathMatrix&amp; m); //keyboard input\nfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const MathMatrix&amp; m); // screen output\nfriend std::ifstream&amp; operator&gt;&gt;(std::ifstream&amp; ifs, MathMatrix&amp; m); // file input\nfriend std::ofstream&amp; operator&lt;&lt;(std::ofstream&amp; ofs, const MathMatrix&amp; m); // file output\n</code></pre>\n<p>While defining the last one of them, in this simple piece of code, I am given an error and can't compile:</p>\n<pre><code>// file output\nstd::ofstream&amp; operator&lt;&lt;(std::ofstream&amp; ofs, const MathMatrix&amp; m) {\n    //put matrix dimension in first line\n    ofs &lt;&lt; m.n &lt;&lt; std::endl;\n    //put data in third line\n    for (int i=0; i&lt;m.n; i++) {\n        for (int j=0; j&lt;m.n; j++) ofs &lt;&lt; m(i,j) &lt;&lt; \" \";\n        ofs &lt;&lt; std::endl;\n    }\n    return ofs;\n}\n</code></pre>\n<p>The errors is in <code>ofs &lt;&lt; m.n</code> (and a similar one in <code>ofs &lt;&lt; m(i,j)</code>). It says:</p>\n<pre><code>const MathMatrix &amp;m\nError: more than one operator \"&lt;&lt;\" matches these operands:\n    function \"operator&lt;&lt;(std::ofstream &amp;ofs, const MathMatrix &amp;m)\"\n    function \"std::basic_ostream&lt;_Elem, _Traits&gt;::operator&lt;&lt;(int _Val) [with _Elem=char, _Traits=std::char_traits&lt;char&gt;]\"\n    operand types are std::ofstream &lt;&lt; const int\n</code></pre>\n<p>After a while I thought that maybe the problem is that I have a <code>MathMatrix</code> constructor like <code>MathMatrix (int n)</code>, so the compiler could be trying to convert from <code>int n</code> to <code>MathMatrix(int n)</code>. I don't see why it would do that, but it's the only explanation I can think of, given the explanation the IDE gives.</p>\n<p>Can you see what I am missing? Do you know how to fix it?</p>\n", "Tags": "<c++><operator-overloading>", "OwnerUserId": "2891462", "AnswerCount": "2"}, "19433964": {"ParentId": "19433014", "CommentCount": "3", "Body": "<p>If in your class you have a constructor with single argument with different type than your class, it can be used for implicit type conversion. To prevent that you just need to mark that constructor explicit:</p>\n<pre><code>class MathMatrix {\npublic:\n   explicit MathMatrix( int m );\n...\n};\n</code></pre>\n<p>It is a good idea to always mark single argument constructor explicit (unless argument is the same class type or you do want such type conversion)</p>\n", "OwnerUserId": "432358", "PostTypeId": "2", "Id": "19433964", "Score": "2", "CreationDate": "2013-10-17T18:02:24.760", "LastActivityDate": "2013-10-17T18:02:24.760"}, "19434526": {"ParentId": "19433014", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There's a subtlety in the overload resolution that leads to an ambiguity here between the selection of a function for the call <code>ofs &lt;&lt; m.n</code>. Here's a short example that reproduces the problem:</p>\n<pre><code>struct Base\n{\n    void operator&lt;&lt;(int);\n};\n\nstruct Derived : Base\n{\n};\n\nstruct converter\n{\n    converter(int);\n};\n\nvoid operator&lt;&lt;(Derived&amp;, converter const&amp;);\n\nint main()\n{\n    const int i = 42;\n    Derived d;\n    d &lt;&lt; i;\n}\n</code></pre>\n<hr>\n<h3>Why is the call ambiguous?</h3>\n<p>First, the member function <code>Base::operator&lt;&lt;</code> gets an additional parameter of type <code>Base&amp;</code> just for overload resolution [over.match.funcs]/2</p>\n<blockquote>\n<p id=\"so_19433014_19434526_0\">The set of candidate functions can contain both member and non-member functions to be resolved against the same argument list. So that argument and parameter lists are comparable within this heterogeneous set, a member function is considered to have an extra parameter, called the <em>implicit object parameter</em>, which represents the object for which the member function has been called.</p>\n</blockquote>\n<p>As the member function (even inherited in <code>Derived</code>) is a member function of <code>Base</code>, the parameter type is a <code>Base&amp;</code>, not a <code>Derived</code>; see /4.</p>\n<p>Therefore we compare</p>\n<pre><code>void operator&lt;&lt;(Base&amp;, int);                  // #0\nvoid operator&lt;&lt;(Derived&amp;, converter const&amp;);  // #1\n</code></pre>\n<p>The arguments of the call <code>d &lt;&lt; i</code> are of type <code>Derived</code> (lvalue) and <code>const int</code>. Therefore:</p>\n<ol>\n<li>for overload #0\n<ol>\n<li>for the first argument, a derived-to-base conversion is required</li>\n<li>for the second argument, a qualification conversion is required (<code>const int</code> to <code>int</code>)</li>\n</ol></li>\n<li>for overload #1\n<ol>\n<li>for the first argument, Exact Match (no conversion)</li>\n<li>for the second argument, a qualification conversion followed by a user-defined conversion is required (<code>const int</code> to <code>int</code>, <code>int</code> to <code>converter</code>)</li>\n</ol></li>\n</ol>\n<p>Conversion 1.1 is worse than conversion 2.1, but conversion 1.2 is better than conversion 2.2. Hence, the call is ambiguous.</p>\n<hr>\n<h3>How to resolve the ambiguity?</h3>\n<p>Either:</p>\n<ul>\n<li>(preferred) make the conversion in <code>MathMatrix</code> explicit</li>\n<li>only declare an <code>operator&lt;&lt;(std::ostream&amp;, MathMatrix const&amp;)</code>, but none for <code>std::ofstream</code> (this will make 1.1 equal to 1.2, therefore overload #1 becomes a better match)</li>\n<li>convert the <code>std::ofstream</code> in the call explicitly to the base class <code>std::ostream</code> (helps in a similar way to the previous version)</li>\n<li>hide the offending overload e.g. via a <em>using-declaration</em> <code>using std::operator&lt;&lt;;</code></li>\n</ul>\n</hr></hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2013-10-17T18:40:20.247", "Id": "19434526", "Score": "2", "CreationDate": "2013-10-17T18:34:17.123", "LastActivityDate": "2013-10-17T18:40:20.247"}, "bq_ids": {"n4140": {"so_19433014_19434526_0": {"section_id": 566, "quality": 0.9459459459459459, "length": 35}}, "n3337": {"so_19433014_19434526_0": {"section_id": 557, "quality": 0.9459459459459459, "length": 35}}, "n4659": {"so_19433014_19434526_0": {"section_id": 589, "quality": 0.9459459459459459, "length": 35}}}});