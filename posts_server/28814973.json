post_cb({"28815144": {"ParentId": "28814973", "CommentCount": "1", "Body": "<p>This is explained in the text immediately preceding the example!</p>\n<blockquote>\n<p id=\"so_28814973_28815144_0\">The implicit instantiation of a class template specialization causes the implicit instantiation of the declarations, but not of the definitions or default arguments, of the class member functions, member classes, scoped member enumerations, static data members and member templates; and it causes the implicit instantiation of the definitions of unscoped member enumerations and member anonymous unions. However, for the purpose of determining whether an instantiated redeclaration of a member is valid according to 9.2, a declaration that corresponds to a definition in the template is considered to be a\n  definition.</p>\n</blockquote>\n<p>There is a difference between the definition of the function that results from instantiating the templates, and a definition of the function templates themselves.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "28815144", "Score": "3", "CreationDate": "2015-03-02T16:48:56.723", "LastActivityDate": "2015-03-02T16:48:56.723"}, "bq_ids": {"n4140": {"so_28814973_28815144_0": {"section_id": 233, "quality": 0.9803921568627451, "length": 50}, "so_28814973_28814973_0": {"section_id": 233, "quality": 1.0, "length": 20}}, "n3337": {"so_28814973_28815144_0": {"section_id": 226, "quality": 0.9803921568627451, "length": 50}, "so_28814973_28814973_0": {"section_id": 226, "quality": 1.0, "length": 20}}, "n4659": {"so_28814973_28814973_0": {"section_id": 243, "quality": 1.0, "length": 20}, "so_28814973_28815144_0": {"section_id": 243, "quality": 0.9607843137254902, "length": 49}}}, "28814973": {"CommentCount": "0", "ViewCount": "50", "OwnerDisplayName": "user2953119", "CreationDate": "2015-03-02T16:40:28.823", "LastActivityDate": "2015-03-02T18:21:03.610", "PostTypeId": "1", "FavoriteCount": "1", "Title": "Declaration that corresponds to a definition in a template", "Id": "28814973", "Score": "0", "Body": "<p>The <code>N4296::14.7.1/1 [temp.inst]</code> provides the following example:</p>\n<pre><code>template&lt;class T, class U&gt;\nstruct Outer {\n    template&lt;class X, class Y&gt; struct Inner;\n    template&lt;class Y&gt; struct Inner&lt;T, Y&gt;; // #1a\n    template&lt;class Y&gt; struct Inner&lt;T, Y&gt; { }; // #1b; OK: valid redeclaration of #1a\n    template&lt;class Y&gt; struct Inner&lt;U, Y&gt; { }; // #2\n};\nOuter&lt;int, int&gt; outer; // error at #2\n</code></pre>\n<p>and the following explanation is given:</p>\n<blockquote>\n<p id=\"so_28814973_28814973_0\"><code>Outer&lt;int, int&gt;::Inner&lt;int, Y&gt;</code> is redeclared at <code>#1b</code>. (It is not\n  defined but noted as being associated with a definition in \n  <code>Outer&lt;T, U&gt;</code>.) <code>#2</code> is also a redeclaration of <code>#1a</code>. It is noted as \n  associated with a definition, so it is an invalid redeclaration of the same \n  partial specialization.</p>\n</blockquote>\n<p>I was confused by the fact that <code>#1b</code> is treated as a declaration, but not a definition. We explcitily provided the function body there, and why isn't it still a definition? In fact, couldn't you explain that exlnation.</p>\n", "Tags": "<c++><templates>", "AnswerCount": "2"}, "28816351": {"ParentId": "28814973", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>A name is introduced into its scope with its first declaration and is then associated with an entity such as an object, function or class. In certain scopes, such as namespace scope or class scope, a name may be declared multiple times. A declaration of name may also include a definition of the named entity. After a definition is seen, it is said that the declaration in question is associated with a definition. No more than one definition is allowed for a named entity.</p>\n<p>When a class template is instantiated implicitly, the definitions of its nested functions, classes and static object members are not instantiated immediately. They are only instantiated as soon as they are needed. However, there's a special rule to catch potential definition conflicts.</p>\n<p>In this example, in a class template with two parameters, <code>T</code> and <code>U</code>, an inner class template with two parameters, <code>X</code> and <code>Y</code>, is declared. Two partial specializations are defined for the inner class, one for the case when <code>X</code> coincides with <code>T</code> and another for the case when <code>X</code> coincides with <code>U</code>. The first partial specialization is first declared at #1a and then redeclared and associated with a definition at #1b. The second partial specialization is declared and associated with a definition at #2.</p>\n<p>So far so good.</p>\n<p>But what if <code>T</code> and <code>U</code> are the same type, for example, <code>int</code>? In such a case, for any given <code>Y</code>, declarations in #1a, #1b, and #2 all declare the same name, <code>Outer&lt;int, int&gt;::Inner&lt;int, Y&gt;</code>. Two of these declarations are associated with definitions and that causes conflict. The example in N4296 you quote is to demonstrate that the conflict must be diagnosed even though there are no references that require the instantiation of <code>Outer&lt;int, int&gt;::Inner&lt;int, Y&gt;</code>.</p>\n<p><code>Outer&lt;int, char&gt;</code> is fine because in this case <code>T</code> and <code>U</code> do not coincide and therefore the #2 gives definition to <code>Outer&lt;int, char&gt;::Inner&lt;char, Y&gt;</code> which is different from <code>Outer&lt;int, char&gt;::Inner&lt;int, Y&gt;</code> defined in #1b.</p>\n", "OwnerUserId": "2623659", "LastEditorUserId": "2623659", "LastEditDate": "2015-03-02T18:21:03.610", "Id": "28816351", "Score": "0", "CreationDate": "2015-03-02T17:53:26.523", "LastActivityDate": "2015-03-02T18:21:03.610"}});