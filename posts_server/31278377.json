post_cb({"bq_ids": {"n4140": {"so_31278377_31278474_5": {"length": 7, "quality": 0.875, "section_id": 775}, "so_31278377_31278474_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 775}, "so_31278377_31278474_6": {"length": 17, "quality": 0.9444444444444444, "section_id": 3299}, "so_31278377_31278474_3": {"length": 37, "quality": 0.9024390243902439, "section_id": 3325}, "so_31278377_31278474_0": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_31278377_31278474_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 633}, "so_31278377_31278474_1": {"length": 9, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_31278377_31278474_5": {"length": 7, "quality": 0.875, "section_id": 762}, "so_31278377_31278474_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 762}, "so_31278377_31278474_6": {"length": 17, "quality": 0.9444444444444444, "section_id": 3169}, "so_31278377_31278474_3": {"length": 37, "quality": 0.9024390243902439, "section_id": 3195}, "so_31278377_31278474_0": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_31278377_31278474_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 3195}, "so_31278377_31278474_1": {"length": 9, "quality": 1.0, "section_id": 3195}}, "n4659": {"so_31278377_31278474_3": {"length": 24, "quality": 0.5853658536585366, "section_id": 4091}, "so_31278377_31278474_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 4091}, "so_31278377_31278474_0": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_31278377_31278474_1": {"length": 9, "quality": 1.0, "section_id": 4091}, "so_31278377_31278474_6": {"length": 13, "quality": 0.7222222222222222, "section_id": 4065}}}, "31278474": {"Id": "31278474", "PostTypeId": "2", "Body": "<p>That is because <a href=\"http://en.cppreference.com/w/cpp/container/array\" rel=\"nofollow\">std::array</a> is an aggregate and therefore <a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization\" rel=\"nofollow\">aggregate initialization</a> is performed this is covered in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">draft C++11 standard</a> section <code>8.5.4</code> <em>[dcl.init.list]</em> which says:</p>\n<blockquote>\n<p id=\"so_31278377_31278474_0\">List-initialization of an object or reference of type T is defined as follows:</p>\n<ul>\n<li><p id=\"so_31278377_31278474_1\">If the initializer list has no elements and T is a class type with a default constructor, the object is\n  value-initialized.</p></li>\n<li><p id=\"so_31278377_31278474_2\">Otherwise, if T is an aggregate, aggregate initialization is performed (8.5.1).</p>\n<pre><code>double ad[] = { 1, 2.0 }; // OK\nint ai[] = { 1, 2.0 }; // error: narrowing\n\nstruct S2 {\n  int m1;\n  double m2, m3;\n};\n\nS2 s21 = { 1, 2, 3.0 }; // OK\nS2 s22 { 1.0, 2, 3 }; // error: narrowing\nS2 s23 { }; // OK: default to 0,0,0\n</code></pre></li>\n</ul>\n</blockquote>\n<p>and we can see if it is not an aggregate then the list goes on and says:</p>\n<blockquote id=\"so_31278377_31278474_3\">\n<ul>\n<li>Otherwise, if T is a specialization of std::initializer_list, an initializer_list object is\n  constructed as described below and used to initialize the object according to the rules for initialization\n  of an object from a class of the same type (8.5).</li>\n<li>Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated\n  and the best one is chosen through overload resolution (13.3, 13.3.1.7). If a narrowing conversion (see\n  below) is required to convert any of the arguments, the program is ill-formed.</li>\n</ul>\n</blockquote>\n<p>We can confirm <code>std::array</code> is an aggregate from section <code>23.3.2.1</code> <em>[array.overview]</em>:</p>\n<blockquote>\n<p id=\"so_31278377_31278474_4\">An array is an aggregate (8.5.1) that can be initialized with the\n  syntax</p>\n<pre><code>array&lt;T, N&gt; a = { initializer-list };\n</code></pre>\n<p id=\"so_31278377_31278474_5\">where initializer-list is a comma-separated list of up to N elements\n  whose types are convertible to T.</p>\n</blockquote>\n<p>section <code>8.5.1</code> referenced is <code>8.5.1</code> Aggregates <em>[dcl.init.aggr]</em> and says:</p>\n<blockquote>\n<p id=\"so_31278377_31278474_6\">When an aggregate is initialized by an initializer list, as specified\n  in 8.5.4, the elements of the initializer list are taken as\n  initializers for the members of the aggregate, in increasing subscript\n  or member order [...]</p>\n</blockquote>\n<p>and we come full-circle back to section <code>8.5.4</code> which is where we started.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-07-15T19:26:07.070", "Score": "8", "CreationDate": "2015-07-07T20:18:13.220", "ParentId": "31278377", "CommentCount": "2", "LastEditDate": "2015-07-15T19:26:07.070", "OwnerUserId": "1708801"}, "31278377": {"ViewCount": "710", "Body": "<p>The following is a quote from <strong>Effective Modern C++</strong> (page 55):</p>\n<blockquote>\n<p id=\"so_31278377_31278377_0\">\"Suppose that you use an empty set of braces to construct an object that supports default constructor and also supports std::initializer_list construction. What do your empty braces mean? etc. The rule is that you get default construction.\"</p>\n</blockquote>\n<p>I tried this with std::array:</p>\n<pre><code>std::array&lt;int, 10&gt; arr{};\n</code></pre>\n<p>and got the warning from g++ (version 4.8.2):</p>\n<blockquote>\n<p id=\"so_31278377_31278377_1\">warning: missing initializer for member \u2018std::array&lt;int, 10ul&gt;::_M_elems\u2019</p>\n</blockquote>\n<p>which is the warning one gets when trying to construct an <code>std::array</code> from an empty <code>std::initializer_list</code> (see <a href=\"https://stackoverflow.com/questions/31271975/why-can-i-initialize-a-regular-array-from-but-not-a-stdarray\">Why can I initialize a regular array from {}, but not a std::array</a> for a discussion of this warning). </p>\n<p>So, why isn't the above line of code interpreted as calling the default constructor? </p>\n", "Title": "Do empty braces call the default constructor or the constructor taking an std::initializer_list?", "CreationDate": "2015-07-07T20:11:41.763", "LastActivityDate": "2015-07-15T19:26:07.070", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:16:26.847", "LastEditorUserId": "-1", "Id": "31278377", "Score": "8", "OwnerUserId": "2725810", "Tags": "<c++><c++11><aggregate-initialization>", "AnswerCount": "1"}});