post_cb({"13693871": {"CommentCount": "6", "AcceptedAnswerId": "13694435", "PostTypeId": "1", "LastEditorUserId": "1000282", "CreationDate": "2012-12-03T23:49:21.043", "LastActivityDate": "2013-02-26T16:17:50.430", "LastEditDate": "2013-02-26T16:17:50.430", "ViewCount": "1236", "FavoriteCount": "1", "Title": "copy-list-initialization of non-copyable types", "Id": "13693871", "Score": "10", "Body": "<p><strong>12.6.1 - Explicit initialization</strong></p>\n<pre><code>struct complex {\n  complex();\n  complex(double);\n  complex(double,double);\n};\n\ncomplex sqrt(complex,complex);\n\ncomplex g = { 1, 2 };  // construct complex(1, 2) \n                       // using complex(double, double) \n                       // and *copy/move* it into g\n</code></pre>\n<p><strong>8.5 Initializers</strong> </p>\n<blockquote>\n<p id=\"so_13693871_13693871_0\">14 - The initialization that occurs in the form</p>\n<p id=\"so_13693871_13693871_1\"><code>T x = a;</code></p>\n<p id=\"so_13693871_13693871_2\">as well as in argument passing, function return, throwing an exception\n  (15.1), handling an exception (15.3), and aggregate member\n  initialization (8.5.1) <strong>is called copy-initialization</strong>. [Note:\n  Copy-initialization may invoke a move (12.8). \u2014 end note ]</p>\n<p id=\"so_13693871_13693871_3\">15 - The initialization that occurs in the forms</p>\n<p id=\"so_13693871_13693871_4\"><code>T x(a);</code></p>\n<p id=\"so_13693871_13693871_5\"><code>T x{a};</code></p>\n<p id=\"so_13693871_13693871_6\">as well as in new expressions (5.3.4), static_cast expressions\n  (5.2.9), functional notation type conversions (5.2.3), and base and\n  member initializers (12.6.2) <strong>is called direct-initialization</strong>.</p>\n</blockquote>\n<p><strong>8.5.4 List-initialization [dcl.init.list]</strong></p>\n<blockquote>\n<p id=\"so_13693871_13693871_7\">1 - List-initialization is initialization of an object or reference from\n  a braced-init-list. Such an initializer is called an initializer list,\n  and the comma-separated initializer-clauses of the list are called the\n  elements of the initializer list. An initializer list may be empty.\n  List-initialization can occur in direct-initialization or copy-initialization\n  contexts; list-initialization in a\n  <strong>direct-initialization context</strong> is called direct-list-initialization and\n  list-initialization in a <strong>copy-initialization context</strong> is called\n  copy-list-initialization.</p>\n</blockquote>\n<h2>The problem with atomics</h2>\n<p><strong>29.6.5 Requirements for operations on atomic types [atomics.types.operations.req]</strong></p>\n<blockquote>\n<p id=\"so_13693871_13693871_8\"><code>#define ATOMIC_VAR_INIT(value)</code> see below</p>\n<p id=\"so_13693871_13693871_9\">The macro expands to a token sequence suitable for constant\n  initialization of an atomic variable of static storage duration of a\n  type that is initialization-compatible with value. [Note: This\n  operation may need to initialize locks. \u2014 end note ] Concurrent access\n  to the variable being initialized, even via an atomic operation,\n  constitutes a data race. [ Example:</p>\n<p id=\"so_13693871_13693871_10\"><code>atomic&lt;int&gt; v = ATOMIC_VAR_INIT(5);</code></p>\n</blockquote>\n<p>According to previous sections it seems there shouldn't be assignment initialization without a copy-constructor involved, even if it's elided according to \u00a712.8.31 and \u00a712.8.32, but atomics are defined as:</p>\n<p><strong>29.5 Atomic types [atomics.types.generic]</strong></p>\n<pre><code>atomic() noexcept = default;\nconstexpr atomic(T) noexcept;\natomic(const atomic&amp;) = delete;\natomic&amp; operator=(const atomic&amp;) = delete;\natomic&amp; operator=(const atomic&amp;) volatile = delete;\nT operator=(T) volatile noexcept;\nT operator=(T) noexcept;\n</code></pre>\n<p>There's no copy-constructor!</p>\n<p>Frequently, <code>ATOMIC_VAR_INIT</code> expands to a brace expression for brace initialization, but <code>atomic&lt;int&gt; v = {5}</code> is still an assignment initialization and would imply copy construction after direct construction of a temporary.</p>\n<p>I've looked over the \"constant initialization\" section to see whether there's a loophole allowing this without a copy (because of \"The macro expands to a token sequence suitable for constant initialization of an atomic variable of static storage duration of a type that is initialization-compatible with value\") but I'm already giving up.</p>\n<p>Related discussions:</p>\n<p><a href=\"http://thread.gmane.org/gmane.comp.lib.qt.devel/8298\" rel=\"nofollow\">http://thread.gmane.org/gmane.comp.lib.qt.devel/8298</a></p>\n<p><a href=\"http://llvm.org/bugs/show_bug.cgi?id=14486\" rel=\"nofollow\">http://llvm.org/bugs/show_bug.cgi?id=14486</a></p>\n<h2>EDIT</h2>\n<p>An answer quoting the relevant standard sections while building a deduction process would be ideal.</p>\n<h2>CONCLUSION</h2>\n<p>So, after the nice answer by Nicol Bolas, the funny conclusion is that <code>complex g = { 1, 2 }</code> is a copy (it is copy-initialization context) which don't copy (copy-list-initialization resolves like direct-list-initialization) for which the standard suggests there's a copy operation (12.6.1: <code>...and copy/move it into g</code>).</p>\n<h2>FIX</h2>\n<p>Pull request: <a href=\"https://github.com/cplusplus/draft/pull/37\" rel=\"nofollow\">https://github.com/cplusplus/draft/pull/37</a></p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1000282", "AnswerCount": "2"}, "13694435": {"ParentId": "13693871", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2012-12-04T00:52:50.287", "Score": "10", "LastEditorUserId": "734069", "LastEditDate": "2012-12-04T03:42:55.503", "Id": "13694435", "OwnerUserId": "734069", "Body": "<pre><code>complex g = { 1, 2 };  // construct complex(1, 2) \n                       // using complex(double, double) \n                       // and *copy/move* it into g\n</code></pre>\n<p>This is untrue. And I'm not saying that the copy/move will be elided; I mean that there will be no copying or moving.</p>\n<p>You quoted 8.5 p14, which defines <code>T x = a;</code> as <em>copy-initialization</em>. This is true. But it then goes on to define how initialization actually works:</p>\n<p>From 8.5, p16:</p>\n<blockquote>\n<p id=\"so_13693871_13694435_0\">The semantics of initializers are as follows. The destination type is the type of the object or reference being initialized and the source type is the type of the initializer expression. If the initializer is not a single (possibly parenthesized) expression, the source type is not defined.</p>\n<ul>\n<li>If the initializer is a (non-parenthesized) braced-init-list, the object or reference is list-initialized (8.5.4).</li>\n</ul>\n</blockquote>\n<p>That right there means that <em>copy-initialization</em> rules <em>do not apply</em> to a <em>braced-init-list</em>. They use a separate set of rules, as covered in 8.5.4.</p>\n<p>You quoted 8.5.4, which defines <code>T x = {...};</code> as <em>copy-list-initialization</em>. Where your reasoning goes wrong is that you never looked up what <em>copy-list-initialization</em> actually <em>does</em>. There is no copying; that's just what it's <em>called</em>.</p>\n<p><em>copy-list-initialization</em> is a subset of <em>list-initialization</em>. Therefore, it follows all of the rules laid down by 8.5.4, p3. I'm not going to quote them here, because they're several pages long. I'll simply explain how the rules apply to <code>complex g = {1, 2};</code>, in order:</p>\n<ol>\n<li>The initializer list has elements, so this rule doesn't count.</li>\n<li><code>complex</code> is not an aggregate, so this rule doesn't count.</li>\n<li><code>complex</code> is not a specialization of <code>initializer_list</code>, so this rule doesn't count.</li>\n<li>Applicable constructors are considered via overload resolution, in accord with the rules of 13.3 and 13.3.1.7. This finds the constructor that takes two doubles.</li>\n</ol>\n<p>Therefore, no temporary will be created and copied/moved in.</p>\n<p>The only difference between <em>copy-list-initialization</em> and <em>direct-list-initialization</em> is stated in 13.3.1.7, p1:</p>\n<blockquote>\n<p id=\"so_13693871_13694435_1\">[...] In copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed.</p>\n</blockquote>\n<p>That is the <em>only difference</em> between <code>complex g{1, 2}</code> and <code>complex g = {1, 2}</code>. They are both examples of <code>list-initialization</code>, and they work in a uniform way except for the use of explicit constructors.</p>\n", "LastActivityDate": "2012-12-04T03:42:55.503"}, "13693952": {"ParentId": "13693871", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2012-12-03T23:58:27.597", "Score": "8", "LastEditorUserId": "596781", "LastEditDate": "2012-12-04T00:23:54.460", "Id": "13693952", "OwnerUserId": "596781", "Body": "<p>The constructor-from-<code>T</code> is <em>not</em> explicit, and copy-list-initialization is not the same as copy-initialization. Both cause \"constructors to be considered\", but copy-initialization always \"considers\" the copy con\u00adstruc\u00adtor, while list-initialization considers constructors with the list elements filled in (plus some details). To wit:</p>\n<pre><code>struct Foo\n{\n    Foo(int) {}\n    Foo(Foo const &amp;) = delete;\n};\n\nint main()\n{\n    Foo f = { 1 };  // Fine\n}\n</code></pre>\n<p>(This would fail if the constructor was <code>explicit</code>. Also, <code>Foo x = 1;</code> will of course fail on account of the deleted copy constructor.)</p>\n<p>Perhaps an even more enlightening use case:</p>\n<pre><code>Foo make() { return { 2 }; }\n\nvoid take(Foo const &amp;);\ntake(make());\n</code></pre>\n<p>Everything necessary for this is in 8.5.4/3 and in 13.3.1.7/1.</p>\n", "LastActivityDate": "2012-12-04T00:23:54.460"}, "bq_ids": {"n4140": {"so_13693871_13693871_2": {"section_id": 3294, "quality": 0.68, "length": 17}, "so_13693871_13694435_1": {"section_id": 599, "quality": 1.0, "length": 6}, "so_13693871_13693871_6": {"section_id": 3295, "quality": 0.7777777777777778, "length": 14}, "so_13693871_13693871_7": {"section_id": 3323, "quality": 0.9459459459459459, "length": 35}, "so_13693871_13693871_9": {"section_id": 1185, "quality": 0.8157894736842105, "length": 31}, "so_13693871_13694435_0": {"section_id": 3296, "quality": 0.84, "length": 21}}, "n3337": {"so_13693871_13693871_2": {"section_id": 3164, "quality": 0.68, "length": 17}, "so_13693871_13694435_1": {"section_id": 589, "quality": 1.0, "length": 6}, "so_13693871_13693871_6": {"section_id": 3165, "quality": 0.7777777777777778, "length": 14}, "so_13693871_13693871_7": {"section_id": 3193, "quality": 0.9459459459459459, "length": 35}, "so_13693871_13693871_9": {"section_id": 1183, "quality": 0.8157894736842105, "length": 31}, "so_13693871_13694435_0": {"section_id": 3166, "quality": 0.84, "length": 21}}, "n4659": {"so_13693871_13693871_2": {"section_id": 4056, "quality": 0.68, "length": 17}, "so_13693871_13694435_1": {"section_id": 622, "quality": 1.0, "length": 6}, "so_13693871_13693871_6": {"section_id": 4057, "quality": 0.5555555555555556, "length": 10}, "so_13693871_13693871_7": {"section_id": 4089, "quality": 0.8648648648648649, "length": 32}, "so_13693871_13693871_9": {"section_id": 1266, "quality": 0.8421052631578947, "length": 32}, "so_13693871_13694435_0": {"section_id": 4058, "quality": 0.84, "length": 21}}}});