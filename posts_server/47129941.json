post_cb({"bq_ids": {"n4140": {"so_47129941_47129941_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 7040}}, "n4659": {"so_47129941_47129941_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 8537}}}, "47129941": {"ViewCount": "26", "FavoriteCount": "1", "Title": "How does odr-use apply to a variable identified by a qualified-id?", "CreationDate": "2017-11-06T04:52:22.003", "LastActivityDate": "2017-11-06T04:52:22.003", "CommentCount": "2", "Body": "<p>Sample code:</p>\n<pre><code>struct S\n{\n    static const int a = 0;\n};\nint const *b = &amp;S::a;\n</code></pre>\n<p>My understanding of the intent of the ODR is that <code>S::a</code> should be <em>odr-used</em> here, because its address is taken.</p>\n<p>My question is: Where and how does the Standard specify that <code>S::a</code> is <em>odr-used</em> in this code?</p>\n<hr>\n<p><em>My research so far:</em> The only relevant part of the C++14 standard seems to be [basic.def.odr]/3:</p>\n<blockquote>\n<p id=\"so_47129941_47129941_0\">A variable <code>x</code> whose name appears as a potentially-evaluated expression <code>ex</code> is odr-used by <code>ex</code> unless applying the lvalue-to-rvalue conversion to <code>x</code> yields a constant expression that does not invoke any non-trivial functions and, if <code>x</code> is an object, <code>ex</code> is an element of the set of potential results of an expression <code>e</code>, where either the lvalue-to-rvalue conversion is applied to <code>e</code>, or <code>e</code> is a discarded-value expression. </p>\n</blockquote>\n<p>However I don't see how <code>S::a</code> fits into this. The definition of <em>name</em> ([basic]/4) excludes qualified-ids, so <code>x</code> can't refer to <code>S::a</code>  here.  I don't see any other text in the standard supporting the use of <em>name</em> to mean anything other than the definition from [basic]/4. </p>\n<p>Maybe <code>x</code> means <code>a</code>; however <code>a</code> never appears as an expression, let alone a potentially-evaluated one: the <code>a</code> in <code>S::a</code> is an identifier, not an expression. (A qualified-id is a nested-name-specifier followed by an identifier, or some other things not relevant here).</p>\n<p>I also don't understand why two different placeholders <code>x</code> and <code>ex</code>  are used in this sentence.  Saying \"A appears as B\" says to me that A and B are lexically identical but seeing A in the context of B has some extra meaning. At first I thought this might mean <code>x</code> is a more abstract way of talking about a variable (e.g. meaning the variable that is identified by <code>S::a</code>) and <code>ex</code> is an expression denoting that variable. However the quote goes on to say \"Applying the lvalue-to-rvalue conversion to <code>x</code>\", therefore <code>x</code> is actually an expression after all; so I don't see what the difference is between <code>x</code> and <code>ex</code>. </p>\n<p>Further, I am not sure what \"an expression <code>e</code>\" refers to exactly. I guess it is an existential taken over all expressions in the program such that <code>ex</code> is a subexpression of <code>e</code>.</p>\n</hr>", "PostTypeId": "1", "Id": "47129941", "Score": "0", "OwnerUserId": "1505939", "Tags": "<c++><language-lawyer><one-definition-rule>", "AnswerCount": "0"}});