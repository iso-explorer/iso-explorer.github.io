post_cb({"bq_ids": {"n4140": {"so_15880204_15880292_0": {"length": 30, "quality": 0.9090909090909091, "section_id": 739}}, "n3337": {"so_15880204_15880292_0": {"length": 30, "quality": 0.9090909090909091, "section_id": 728}}, "n4659": {"so_15880204_15880292_0": {"length": 30, "quality": 0.9090909090909091, "section_id": 797}}}, "15880333": {"Id": "15880333", "PostTypeId": "2", "Body": "<p>As a corollary of what Andy Prowl quoted, you would need to regenerate a new set every time you change your weight array</p>\n", "LastActivityDate": "2013-04-08T13:27:28.617", "Score": "1", "CreationDate": "2013-04-08T13:27:28.617", "ParentId": "15880204", "CommentCount": "0", "OwnerUserId": "1086804"}, "15880204": {"ViewCount": "56", "Body": "<p>I've created a <code>std::set</code> in the following code where elements are kept sorted based on an array.</p>\n<pre><code>int weight[] = {0, 1, 58, 21, 10, 21, 24};\n\nstruct Comp\n{\n    public:\n    bool operator() (const int &amp;a, const int &amp;b) const\n    {\n        if (weight[a] == weight[b])\n            return a &lt; b;\n        else\n            return weight[a] &lt; weight[b];\n    }\n};\nset&lt;int, Comp&gt; s;\n</code></pre>\n<p>Surprisingly, when I change any element in the <code>weight</code> array, corresponding element in the set vanishes away. Here is my testing function:</p>\n<pre><code>void print()\n{\n    printf(\"Elements = \");  \n    for(int i = 1; i &lt;= 6; i++)\n        if(s.find(i) != s.end())\n            printf(\"%2d \", i);;\n    printf(\"\\n\");\n}\n\nint main()\n{   \n    for(int i = 1; i &lt;= 6; i++)\n        s.insert(i);\n\n    print();\n    weight[2] = 1;\n    weight[5] = 15;\n    print();\n\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Elements =  1  2  3  4  5  6  \nElements =  1  3  4  6\n</code></pre>\n<p>I'm using <code>gcc 4.6.3</code> in buntu.</p>\n", "AcceptedAnswerId": "15880292", "Title": "std::set elements vanishes away", "CreationDate": "2013-04-08T13:21:45.170", "Id": "15880204", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-04-08T13:27:28.617", "Score": "1", "OwnerUserId": "1031888", "Tags": "<c++><stl>", "AnswerCount": "2"}, "15880292": {"Id": "15880292", "PostTypeId": "2", "Body": "<p>Per Paragraph 23.2.4/3 of the C++11 Standard on requirements of associative containers:</p>\n<blockquote>\n<p id=\"so_15880204_15880292_0\">The phrase \u201cequivalence of keys\u201d means the equivalence relation imposed by the comparison and not the\n  <code>operator==</code> on keys. That is, two keys <code>k1</code> and <code>k2</code> are considered to be equivalent if for the comparison\n  object <code>comp</code>, <code>comp(k1, k2) == false &amp;&amp; comp(k2, k1) == false</code>. <strong>For any two keys <code>k1</code> and <code>k2</code> in the\n  same container, calling <code>comp(k1, k2)</code> shall always return the same value</strong>.</p>\n</blockquote>\n<p>Since you are not fulfilling this precondition by changing the weights (and your comparator uses those weights to define an ordering on elements of your set), your program has <strong>Undefined Behavior</strong>.</p>\n", "LastActivityDate": "2013-04-08T13:25:47.347", "Score": "6", "CreationDate": "2013-04-08T13:25:47.347", "ParentId": "15880204", "CommentCount": "0", "OwnerUserId": "1932150"}});