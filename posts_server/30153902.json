post_cb({"30156727": {"Id": "30156727", "PostTypeId": "2", "Body": "<p>'\u00e9' is not a valid character to backslash escape in a string literal, and so a backslash followed by '\u00e9' as either a literal source character or a UCN should produce a compiler diagnostic and undefined behavior.</p>\n<p>Note, however, that <code>\"\\\\u00e9\"</code> is not a UCN preceded by a backslash, and that it's not possible to write any sequence of basic source characters in a string or character literal that is a backslash followed by a UCN. Thus <code>\"\\\u00e9\"</code> and <code>\"\\\\u00e9\"</code> are not required to behave the same: The behavior of <code>\"\\\\u00e9\"</code> can be perfectly well defined while the behavior of <code>\"\\\u00e9\"</code> is undefined.</p>\n<p>If we were to posit some syntax that allowed backslash escaping a UCN, say <code>\"\\\u00ab\\u00e9\u00bb\"</code>, then that would have undefined behavior like <code>\"\\\u00e9\"</code>.</p>\n<hr>\n<blockquote id=\"so_30153902_30156727_0\">\n<ul>\n<li>In Phase 1, <code>printf(\"\\\u00e9\\n\");</code> maps to <code>printf(\"\\\\u00e9\\n\");</code>.</li>\n</ul>\n</blockquote>\n<p>The phase one conversion of <code>\u00e9</code> into a UCN cannot create a non-UCN, such as <code>\"\\\\u00e9\"</code>.</p>\n<hr>\n<p>The compilers are right, but don't specifically handle this situation with perfect diagnostic messages. Ideally what you'd get is:</p>\n<pre><code>$ clang++ -std=c++11  -Wall -Wextra ucn.cpp -o ucn\nucn.cpp:4:10: warning: unknown escape sequence '\\\u00e9' [-Wunknown-escape-sequence]\n        printf(\"\\\u00e9\\n\");\n                ^\n1 warnings generated.\n$ ./ucn\n\u00e9\n\\u00e9\n</code></pre>\n<p>Both compilers specify that their behavior in the presence of an unknown escape sequence is to replace the escape sequence with the character thus escaped, so <code>\"\\\u00e9\"</code> would be treated as <code>\"\u00e9\"</code> and the program overall should be interpreted as:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main(void){\n        printf(\"\u00e9\\n\");\n        printf(\"\\\\u00e9\\n\");\n        return 0;\n}\n</code></pre>\n<p>Both compilers do happen to get this behavior, partially by chance, but also partially because the policy to treat unrecognized escape sequences the way they do is a smart choice: Even though they only see the unrecognized escape sequence as the backslash followed by the byte 0xC3, they remove the backslash and leave the 0xC3 in place, which means the UTF-8 sequence is left intact for later processing.</p>\n</hr></hr>", "LastEditorUserId": "365496", "LastActivityDate": "2015-05-10T21:18:39.187", "Score": "2", "CreationDate": "2015-05-10T21:13:09.950", "ParentId": "30153902", "CommentCount": "8", "OwnerUserId": "365496", "LastEditDate": "2015-05-10T21:18:39.187"}, "30156160": {"Id": "30156160", "PostTypeId": "2", "Body": "<p>You seem to be confused, thinking that <code>\\\\u00e9</code> is a UCN -- it is not.  UCNs all begin with <code>\\u</code>, and in your case, you have an extract backslash which escapes this initial backslash.  So <code>\\\\u00e9</code> is the sequence of 6 characters: <code>\\</code>, <code>u</code>, <code>0</code>, <code>0</code>, <code>e</code>, <code>9</code>.</p>\n<p><strong>edit</strong></p>\n<blockquote>\n<p id=\"so_30153902_30156160_0\">In Phase 1, printf(\"\\\u00e9\\n\"); maps to printf(\"\\u00e9\\n\");.</p>\n</blockquote>\n<p>This is where you're going wrong -- Phase 1 translates input characters into source characters, so <code>printf(\"\\\u00e9\\n\");</code> maps to <code>p</code> <code>r</code> <code>i</code> <code>n</code> <code>t</code> <code>f</code> <code>(</code> <code>\"</code> <code>\\</code> <code>\u00e9</code> <code>\\</code> <code>n</code> <code>\"</code> <code>)</code> <code>;</code>, which is the same as <code>p</code> <code>r</code> <code>i</code> <code>n</code> <code>t</code> <code>f</code> <code>(</code> <code>\"</code> <code>\\</code> <code>\\u00e9</code> <code>\\</code> <code>n</code> <code>\"</code> <code>)</code> <code>;</code>, but that's not the same as what <code>printf(\"\\\\u00e9\\n\");</code> maps to because of the double-backslash in the latter.  Because of the special handling of double-backslash, there is no way to have a backslash followed by a UCN in the source.</p>\n", "LastEditorUserId": "16406", "LastActivityDate": "2015-05-10T21:13:18.483", "Score": "1", "CreationDate": "2015-05-10T20:10:48.373", "ParentId": "30153902", "CommentCount": "2", "OwnerUserId": "16406", "LastEditDate": "2015-05-10T21:13:18.483"}, "30153902": {"ViewCount": "438", "Body": "<h3>Context</h3>\n<p>C11 and C++11 both support extended characters in source files, as well as Universal Character Names (UCNs), which allow one to enter characters not in the basic source character set using only characters that are.</p>\n<p>C++11 also defines several translation phases of compilation. In particular,  extended characters are normalized to UCNs in the very first phase of translation, described below:</p>\n<p><strong>\u00a7 C++11 2.2p1.1:</strong></p>\n<blockquote>\n<p id=\"so_30153902_30153902_0\">Physical source file characters are mapped, in an\n  implementation-defined manner, to the basic source character set\n  (introducing new-line characters for end-of-line indicators) if\n  necessary. The set of physical source file characters accepted is\n  implementation-defined. Trigraph sequences (2.4) are replaced by\n  corresponding single-character internal representations. Any source\n  file character not in the basic source character set (2.3) is replaced\n  by the universal-character-name that designates that character. (An\n  implementation may use any internal encoding, so long as an actual\n  extended character encountered in the source file, and the same\n  extended character expressed in the source file as a\n  universal-character-name (i.e., using the \\uXXXX notation), are\n  handled equivalently except where this replacement is reverted in a\n  raw string literal.)</p>\n</blockquote>\n<hr>\n<h3>Question</h3>\n<p><em>My question, therefore, is:</em></p>\n<blockquote>\n<p id=\"so_30153902_30153902_1\">Does a Standard-conforming compilation of the program</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main(void){\n        printf(\"\\\u00e9\\n\");\n        printf(\"\\\\u00e9\\n\");\n        return 0;\n}\n</code></pre>\n<p id=\"so_30153902_30153902_2\">fail, compile and print</p>\n<pre><code>\u00e9\n\u00e9\n</code></pre>\n<p id=\"so_30153902_30153902_3\">or compile and print</p>\n<pre><code>\\u00e9\n\\u00e9\n</code></pre>\n<p id=\"so_30153902_30153902_4\">, when run?</p>\n</blockquote>\n<hr>\n<h3>Informed Personal Opinion</h3>\n<p>It is my contention that the answer is that it successfully compiles and prints <code>\\u00e9</code>, since by \u00a72.2p1.1 above, we have</p>\n<p><em>An implementation may use any internal encoding, <strong>so long as an actual extended character encountered in the source file</strong>, and <strong>the same extended character expressed in the source file as a universal-character-name</strong> (i.e., <strong>using the \\uXXXX notation</strong>), are handled <strong>equivalently</strong> except where this replacement is reverted in a raw string literal.</em>, and we are not in a raw string literal.</p>\n<p>It then follows that</p>\n<ul>\n<li>In Phase 1, <code>printf(\"\\\u00e9\\n\");</code> maps to <code>printf(\"\\\\u00e9\\n\");</code>.</li>\n<li>In Phase 3, <em>The source file is decomposed into preprocessing tokens</em> (\u00a72.2p1.3), of which the <em>string-literal</em> <code>\"\\\\u00e9\\n\"</code> is one.</li>\n<li>In Phase 5, <em>Each source character set member in a character literal or a string literal, as well as each escape sequence and universal-character-name in a character literal or a non-raw string literal, is converted to the corresponding member of the execution character set</em> (\u00a72.2p1.5). Thus, by the maximal munch principle, <code>\\\\</code> maps to <code>\\</code>, and the fragment <code>u00e9</code> is not recognized as a UCN and therefore prints as is.</li>\n</ul>\n<h3>Experiments</h3>\n<p>Unfortunately, extant compilers disagree with me. I've tested with both GCC 4.8.2 and Clang 3.5, and here is what they gave me:</p>\n<ul>\n<li><p>GCC 4.8.2</p>\n<pre><code>$ g++ -std=c++11  -Wall -Wextra ucn.cpp -o ucn\nucn.cpp: In function 'int main()':\nucn.cpp:4:9: warning: unknown escape sequence: '\\303' [enabled by default]\n  printf(\"\\\u00e9\\n\");\n         ^\n$ ./ucn\n\u00e9\n\\u00e9\n</code></pre></li>\n<li><p>Clang 3.5</p>\n<pre><code>$ clang++ -std=c++11  -Wall -Wextra ucn.cpp -o ucn\nucn.cpp:4:10: warning: unknown escape sequence '\\xFFFFFFC3' [-Wunknown-escape-sequence]\n        printf(\"\\\u00e9\\n\");\n                ^\nucn.cpp:4:12: warning: illegal character encoding in string literal [-Winvalid-source-encoding]\n        printf(\"\\\u00e9\\n\");\n                 ^\n2 warnings generated.\n$ ./ucn\n\u00e9\n\\u00e9\n</code></pre></li>\n</ul>\n<p>I have double- and -triple checked that the <code>\u00e9</code> character appears as <code>C3 A9</code> using <code>hexdump -C ucn.cpp</code>, in agreement with the expected UTF-8 encoding. I've moreover verified that a plain <code>printf(\"\u00e9\\n\");</code> or <code>printf(\"\\u00e9\\n\");</code> works flawlessly, so this is not a problem of the compilers tested being unable to read UTF-8 source files.</p>\n<p><strong><em>Who's right?</em></strong></p>\n</hr></hr>", "AcceptedAnswerId": "30156727", "Title": "C11 & C++11 Exended and Universal Character Escaping", "CreationDate": "2015-05-10T16:38:38.523", "Id": "30153902", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-12-26T18:58:26.190", "LastEditorUserId": "3204551", "LastActivityDate": "2015-12-26T18:58:26.190", "Score": "8", "OwnerUserId": "2809095", "Tags": "<c++><c><c++11><language-lawyer><c11>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_30153902_30153902_0": {"length": 69, "quality": 0.92, "section_id": 5313}}, "n3337": {"so_30153902_30153902_0": {"length": 69, "quality": 0.92, "section_id": 5110}}, "n4659": {"so_30153902_30153902_0": {"length": 63, "quality": 0.84, "section_id": 6737}}}});