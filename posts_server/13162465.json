post_cb({"bq_ids": {"n4140": {"so_13162465_13162653_0": {"length": 15, "quality": 1.0, "section_id": 6007}, "so_13162465_13162653_1": {"length": 15, "quality": 1.0, "section_id": 5891}}, "n3337": {"so_13162465_13162653_0": {"length": 15, "quality": 1.0, "section_id": 5775}, "so_13162465_13162653_1": {"length": 15, "quality": 1.0, "section_id": 5662}}, "n4659": {"so_13162465_13162653_0": {"length": 15, "quality": 1.0, "section_id": 7506}, "so_13162465_13162653_1": {"length": 15, "quality": 1.0, "section_id": 7374}}}, "13162465": {"ViewCount": "207", "Body": "<p>I have a C++ class field that is declared mutable.  When it was of type double, I could modify it in a const method with no problem.  But when I switched its type to a class in which operator= is overloaded, I got the error that this overloaded operator= does not take a const pointer to this.  Is this a gcc bug, or a language quirk?</p>\n", "Title": "mutable field with overloaded assignment operator", "CreationDate": "2012-10-31T16:24:16.883", "LastActivityDate": "2012-10-31T16:46:09.513", "CommentCount": "2", "PostTypeId": "1", "ClosedDate": "2012-11-01T05:28:41.413", "Id": "13162465", "Score": "0", "OwnerUserId": "410315", "Tags": "<c++><operator-overloading><mutable>", "AnswerCount": "2"}, "13162657": {"Id": "13162657", "PostTypeId": "2", "Body": "<p>When you suspect a compiler bug you should say which compiler version you are using. You know, bugs are killed every day.</p>\n<p>Anyway, this code compiles fine with GCC 4.6.3:</p>\n<pre><code>struct A\n{\n    void operator=(int)\n    {\n    }\n};\n\nstruct B\n{\n    mutable A a;\n};\n\nint main()\n{\n    const B b;\n    b.a = 42;\n}\n</code></pre>\n<p>But, of course, this does not (it this your case):</p>\n<pre><code>struct A\n{\n    mutable int m;\n    void operator=(int x)\n    {\n        m = x;\n    }\n};\n\nstruct B\n{\n    A a;\n};\n\nint main()\n{\n    const B b;\n    b.a = 42;\n}\n</code></pre>\n", "LastActivityDate": "2012-10-31T16:35:59.280", "Score": "1", "CreationDate": "2012-10-31T16:35:59.280", "ParentId": "13162465", "CommentCount": "0", "OwnerUserId": "865874"}, "13162653": {"Id": "13162653", "PostTypeId": "2", "Body": "<p><code>mutable</code> has the effect that <code>const</code> qualification on the implicit object parameter is nullified (<strong>5.2.5 Class member access [expr.ref]</strong>, paragraph 4):</p>\n<blockquote>\n<p id=\"so_13162465_13162653_0\">[...] If <code>E2</code> is declared to be a <code>mutable</code> member, then the type of <code>E1.E2</code>\n  is \u201c<em>vq12</em> <code>T</code>\u201d. If <code>E2</code> is not declared to be a <code>mutable</code> member, then the type of <code>E1.E2</code> is \u201c<em>cq12 vq12</em> <code>T</code>\u201d.</p>\n</blockquote>\n<p>5.2.5 applies for implicit member access per 9.3.1p3:</p>\n<blockquote>\n<p id=\"so_13162465_13162653_1\">When an <em>id-expression</em> [...] is used in a member of class <code>X</code> [...] the <em>id-expression</em> is transformed into a class member access expression using <code>(*this)</code> as the <em>postfix-expression</em> to the left of the <code>.</code> operator.</p>\n</blockquote>\n<p>So in your <code>const</code> method the <code>mutable</code> member is not (observed to be) const-qualified.  Your observed behaviour must be the result of a compiler bug.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-10-31T16:46:09.513", "Score": "0", "CreationDate": "2012-10-31T16:35:52.067", "ParentId": "13162465", "CommentCount": "1", "LastEditDate": "2012-10-31T16:46:09.513", "OwnerUserId": "567292"}});