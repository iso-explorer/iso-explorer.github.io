post_cb({"29857487": {"Id": "29857487", "PostTypeId": "2", "Body": "<p>As a word of caution - the standard doesn't really enforce an implementation scheme for bitfields. There is no guarantee that <code>Bits</code> will be 1 byte, and hypothetically it is entirely possible for it to be larger.</p>\n<p>In practice however the actual implementations usually follow the obvious logic and it will \"almost always\" be 1 byte in size, but again, there is no requirement that it is guaranteed. Just in case you want to be sure, you could <a href=\"https://stackoverflow.com/questions/11815894/how-to-read-write-arbitrary-bits-in-c-c?lq=1\">do it manually</a>.</p>\n<p>BTW <code>-1</code> is still <code>true</code> but it <code>-1 != true</code></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-04-25T13:31:18.900", "Score": "13", "CreationDate": "2015-04-24T21:06:36.707", "ParentId": "29855708", "CommentCount": "3", "LastEditDate": "2017-05-23T12:34:54.200", "OwnerUserId": "991484"}, "29864781": {"Id": "29864781", "PostTypeId": "2", "Body": "<p>As noted, these variables consist of only a sign bit, so the only available values are <code>0</code> and <code>-1</code>.</p>\n<p>A more appropriate type for these bitfields would be <code>bool</code>. C++14 \u00a79.6/4:</p>\n<blockquote>\n<p id=\"so_29855708_29864781_0\">If the value <code>true</code> or <code>false</code> is stored into a bit-field of type <code>bool</code> of any size (including a one bit bit-field), the original <code>bool</code> value and the value of the bit-field shall compare equal.</p>\n</blockquote>\n<p>Yes, <code>std::uint8_t</code> will do the job, but you might as well use the best fit. You won't need things like the cast for <code>std::cout &lt;&lt; (int)b.b0;</code>.</p>\n", "LastActivityDate": "2015-04-25T11:51:50.420", "CommentCount": "2", "CreationDate": "2015-04-25T11:51:50.420", "ParentId": "29855708", "Score": "2", "OwnerUserId": "153285"}, "29855708": {"ViewCount": "3151", "Body": "<p>I'm working on a microcontroller with only 2KB of SRAM and desperately need to conserve some memory. Trying to work out how I can put 8 <code>0</code>/<code>1</code> values into a single byte using a bitfield but can't quite work it out.</p>\n<pre><code>struct Bits\n{\n    int8_t b0:1, b1:1, b2:1, b3:1, b4:1, b5:1, b6:1, b7:1;\n};\n\nint main(){\n    Bits b;\n    b.b0 = 0;\n    b.b1 = 1;\n\n    cout &lt;&lt; (int)b.b0; // outputs 0, correct\n    cout &lt;&lt; (int)b.b1; // outputs -1, should be outputting 1\n}\n</code></pre>\n<p>What gives?</p>\n", "AcceptedAnswerId": "29855747", "Title": "Storing 8 logical true/false values inside 1 byte?", "CreationDate": "2015-04-24T19:16:35.560", "Id": "29855708", "CommentCount": "12", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2015-04-24T20:49:34.110", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-08T15:34:38.043", "Score": "65", "OwnerUserId": "1864403", "Tags": "<c++><bit-fields>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_29855708_29864781_0": {"length": 20, "quality": 1.0, "section_id": 5924}}, "n3337": {"so_29855708_29864781_0": {"length": 20, "quality": 1.0, "section_id": 5696}}, "n4659": {"so_29855708_29864781_0": {"length": 20, "quality": 1.0, "section_id": 7398}}}, "29855747": {"Id": "29855747", "PostTypeId": "2", "Body": "<p>All of your bitfield members are signed 1-bit integers. On a two's complement system, that means they can represent only either <code>0</code> or <code>-1</code>. Use <code>uint8_t</code> if you want <code>0</code> and <code>1</code>:</p>\n<pre><code>struct Bits\n{\n    uint8_t b0:1, b1:1, b2:1, b3:1, b4:1, b5:1, b6:1, b7:1;\n};\n</code></pre>\n", "LastEditorUserId": "116908", "LastActivityDate": "2015-04-24T19:28:20.463", "Score": "112", "CreationDate": "2015-04-24T19:19:12.073", "ParentId": "29855708", "CommentCount": "5", "LastEditDate": "2015-04-24T19:28:20.463", "OwnerUserId": "116908"}, "31297292": {"Id": "31297292", "PostTypeId": "2", "Body": "<p>Signed and unsigned integers are the answer. </p>\n<p>Keep in mind that signaling is just an interpretation of bits, -1 or 1 is just the 'print' serializer interpreting the \"variable type\", as it was \"revealed\" to cout functions (look operator overloading) by compiler, the bit is the same, its value also (on/off) - since you have only 1 bit. </p>\n<p>Don't care about that, but is a good practice to be explicit, so prefer to declare your variable with unsigned, it instructs the compiler to mount a proper code when you set or get the value to a serializer like \"print\" (cout).</p>\n<p><strong>\"COUT\" OPERATOR OVERLOADING:</strong>\n\"cout\" works through a series of functions which the parameter overloading instructs the compiler which function to call. So, there are two functions, one receives an unsigned and another signed, thus they can interpret the same data differently, and you can change it, instructing the compiler to call another one using cast. See <a href=\"https://stackoverflow.com/questions/2981836/how-can-i-use-coutmyclass\">cout &lt;&lt; myclass</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-08T15:34:38.043", "Score": "0", "CreationDate": "2015-07-08T15:34:38.043", "ParentId": "29855708", "CommentCount": "0", "LastEditDate": "2017-05-23T10:30:52.590", "OwnerUserId": "926064"}});