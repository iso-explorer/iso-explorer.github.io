post_cb({"44889285": {"Id": "44889285", "PostTypeId": "2", "Body": "<p>Citing Malcolm McLean:</p>\n<blockquote>\n<p id=\"so_44888502_44889285_0\">This is a confusing hangover from the days of early C. Early C didn't have const, so string literals were \"char *\". They remained char * to avoid breaking old code, but they became non-modifiable, so const char * in all but name.</p>\n</blockquote>\n<p>Actually, string literals are not pointers, but arrays, this is why <code>sizeof(\"hello world\")</code> works as a charm (yields 12, the terminating null character is included, in contrast to strlen...). Apart from this small detail, above statement is correct for good old <strong>C</strong> even in these days.</p>\n<p>In <strong>C++</strong>, though, string literals have been arrays of constant characters (<code>char const[]</code>) right from the start:</p>\n<p>C++ standard, 5.13.5.8:</p>\n<blockquote>\n<p id=\"so_44888502_44889285_1\">Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow string literal has type <strong>\u201carray of n const char\u201d</strong>, where n is the size of the string as defined below, and has static storage duration.</p>\n</blockquote>\n<p>(Emphasised by me.) In general, you are not allowed to assign pointer to const to pointer to non-const:</p>\n<pre><code>char const* s = \"hello\";\nchar ss = s;\n</code></pre>\n<p>This will fail to compile. Assigning string literals to pointer to non-const <em>should</em> normally fail, too, as the standard explicitly states in C.1.1, subclause 5.13.5:</p>\n<blockquote>\n<p id=\"so_44888502_44889285_2\">Change: String literals made const.\n  The type of a string literal is changed from \u201carray of char\u201d to \u201carray of const char\u201d.\n  [...]<pre>char* p = \"abc\"; // valid in C, invalid in C++</pre></p>\n</blockquote>\n<p>Still, string literal assignement to pointer to non-const is commonly accepted by compilers (as an extension!), probably to retain compatibility to C. As this is, according to the standard, invalid, the compiler yields a warning, at least...</p>\n", "LastEditorUserId": "1312382", "LastActivityDate": "2017-07-03T15:39:03.147", "Score": "0", "CreationDate": "2017-07-03T15:28:00.323", "ParentId": "44888502", "CommentCount": "0", "OwnerUserId": "1312382", "LastEditDate": "2017-07-03T15:39:03.147"}, "44889140": {"Id": "44889140", "PostTypeId": "2", "Body": "<p>As other answers say, you should distinguish pointers and bytes they point to.</p>\n<p>Both types of pointers, <code>char *</code> and <code>const char *</code>, can be changed, that is, \"redirected\" to point to different bytes. However, if you want to change the bytes (characters) of the strings, you cannot use <code>const char *</code>.</p>\n<p>So, if you have string literals \"Hello\" and \"World\" in your program, you can assign them to pointers, and printing the pointer will print the corresponding literal. However, to do anything non-trivial (e.g. change <code>Hello</code> to <code>HELLO</code>), you will need non-<code>const</code> pointers.</p>\n<p>Another example: with some pointer manipulation, you can remove leading bytes from a string literal:</p>\n<pre><code>const char* str = \"Hello\";\nstd::cout &lt;&lt; str; // Hello\nstr = str + 2;\nstd::cout &lt;&lt; str; // llo\n</code></pre>\n<p>However, if you want to extract a substring, or do any other transformation on a string, you should reallocate it, and for that you need a non-<code>const</code> pointer.</p>\n<hr>\n<p>BTW since you are using C++, you can use <code>std::string</code>, which makes it easier to work with strings. It reallocates strings without your intervention:</p>\n<pre><code>#include &lt;string&gt;\nstd::string str(\"Hello\");\nstr = str.substr(1, 3);\nstd::cout &lt;&lt; str; // ell\n</code></pre>\n</hr>", "LastEditorUserId": "509868", "LastActivityDate": "2017-07-03T15:38:32.353", "Score": "0", "CreationDate": "2017-07-03T15:20:11.143", "ParentId": "44888502", "CommentCount": "0", "OwnerUserId": "509868", "LastEditDate": "2017-07-03T15:38:32.353"}, "bq_ids": {"n4140": {"so_44888502_44889285_1": {"length": 26, "quality": 1.0, "section_id": 5356}}, "n3337": {"so_44888502_44889285_1": {"length": 26, "quality": 1.0, "section_id": 5153}}, "n4659": {"so_44888502_44889285_1": {"length": 26, "quality": 1.0, "section_id": 6781}}}, "44888502": {"ViewCount": "89", "Body": "<p>im realy confused about <code>const char *</code> and <code>char *</code>.\nI know in <code>char *</code> when we want to modify the content, we need to do something like this</p>\n<pre><code>const char * temp = \"Hello world\";\nchar * str = new char[strlen(temp) + 1];\nmemcpy(str, temp, strlen(temp));\nstr[strlen(temp) + 1] = '\\0';\n</code></pre>\n<p>and if we want to use something like this</p>\n<pre><code>char * str = \"xxx\";\nchar * str2 = \"xts\";\nstr = str2;\n</code></pre>\n<p>we get compiler warning. it's ok I know when i want to change <code>char *</code> I have to use something memory copy. but about <code>const char *</code> im realy confused. in <code>const char *</code> I can use this</p>\n<pre><code>const char * str = \"Hello\";\nconst char * str2 = \"World\";\nstr = str2; // and now str is Hello\n</code></pre>\n<p>and I have no compiler error ! why ? why we use memory copy when is not const and in const we only use equal operator ! and done !... how possible? <strong>is it ok to just use equal in const? no problem happen later?</strong></p>\n", "AcceptedAnswerId": "44888697", "Title": "modify const char * vs char * content in easy way", "CreationDate": "2017-07-03T14:45:39.257", "Id": "44888502", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-07-03T14:51:15.193", "LastEditorUserId": "8197602", "LastActivityDate": "2017-07-03T16:28:16.720", "Score": "-1", "OwnerUserId": "8197602", "Tags": "<c++><char><const>", "AnswerCount": "4"}, "44888697": {"Id": "44888697", "PostTypeId": "2", "Body": "<p>That is cause your variables are just a pointers <code>*</code>. You're not modifiying their contents, but where they are pointing to.</p>\n<pre><code>char * a = \"asd\";\nchar * b = \"qwe\";\na = b; \n</code></pre>\n<p>now you threw away the contents of a. Now a and b points to the same place. If you modify one, both are modified.</p>\n<p>In other words. <strong>Pointers are never constants</strong> (mostly). your <code>const</code> predicate in a pointer variable does not means nothing to the pointer. </p>\n<p>The real difference is that the pointer (that is not <code>const</code>) is pointing to a <code>const</code> variable. and when you change the pointer it will be point to ANOTHER NEW <code>const</code> variable. That is why <code>const</code> has no effect on simple pointers.</p>\n<p>Note: You can achieve different behaviours with pointers and const with more complex scenario. But with simple as it, it mostly has no effect. </p>\n", "LastEditorUserId": "888469", "LastActivityDate": "2017-07-03T16:28:16.720", "Score": "0", "CreationDate": "2017-07-03T14:55:38.213", "ParentId": "44888502", "CommentCount": "6", "OwnerUserId": "888469", "LastEditDate": "2017-07-03T16:28:16.720"}, "44888639": {"Id": "44888639", "PostTypeId": "2", "Body": "<p>This is a confusing hangover from the days of early C. Early C didn't have const, so string literals were \"char *\". They remained char * to avoid breaking old code, but they became non-modifiable, so const char * in all but name. So modern C++ either warns or gives an error (to be strictly conforming) when the const is omitted.</p>\n<p>Your memcpy missed the trailing nul byte, incidentally. Use strcpy() to copy a string, that's the right function with the right name. You can create a string in read/write memory by use of the </p>\n<pre><code>char rwstring[] = \"I am writeable\";\n</code></pre>\n<p>syntax.</p>\n", "LastEditorUserId": "3310281", "LastActivityDate": "2017-07-03T16:12:26.520", "Score": "1", "CreationDate": "2017-07-03T14:53:04.730", "ParentId": "44888502", "CommentCount": "3", "OwnerUserId": "3310281", "LastEditDate": "2017-07-03T16:12:26.520"}});