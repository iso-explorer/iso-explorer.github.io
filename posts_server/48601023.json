post_cb({"48601326": {"ParentId": "48601023", "LastActivityDate": "2018-02-03T20:37:18.440", "OwnerUserId": "5507349", "Id": "48601326", "CreationDate": "2018-02-03T19:47:21.730", "LastEditorUserId": "5507349", "Body": "<blockquote>\n<p id=\"so_48601023_48601326_0\">Does the standard guarantee the stability of the address of the value?</p>\n</blockquote>\n<p>From my point of view, it is <em>unspecified</em> whether the address is stable or not.</p>\n<p>Formally, the standard only guarantees that there are no dynamic allocations for the object contained within <code>std::optional</code> and the containing object is stored as a part of <code>std::optional</code>:</p>\n<blockquote>\n<p id=\"so_48601023_48601326_1\">23.6.3 Class template optional [optional.optional]</p>\n<p id=\"so_48601023_48601326_2\">Any instance of optional at any given time either contains a value\n  or does not contain a value. <em>When an instance of optional contains\n  a value, it means that an object of type T, referred to as the\n  optional object\u2019s contained value, is allocated within the storage of\n  the optional object. Implementations are not permitted to use\n  additional storage, such as dynamic memory, to allocate its contained\n  value. The contained value shall be allocated in a region of the\n  optional storage suitably aligned for the type T.</em> When an object of\n  type optional is contextually converted to bool, the conversion\n  returns true if the object contains a value; otherwise the conversion\n  returns false.</p>\n</blockquote>\n<p>The actual storage mechanism is defined by a particular implementation, so, potentially, the address might change.</p>\n<p>In practice, however, implementations will be using something like <code>aligned_storage</code> (see <em>boost</em> <a href=\"https://github.com/boostorg/optional/blob/develop/include/boost/optional/optional.hpp\" rel=\"noreferrer\">implementation</a>) or <code>union</code> (as <em>gcc</em> <a href=\"https://gcc.gnu.org/onlinedocs/gcc-7.3.0/libstdc++/api/a01010_source.html\" rel=\"noreferrer\">does</a>) and keep an address of the containing object the same.</p>\n", "LastEditDate": "2018-02-03T20:37:18.440", "PostTypeId": "2", "CommentCount": "1", "Score": "12"}, "48601023": {"Tags": "<c++><language-lawyer><std><c++17>", "ViewCount": "588", "LastEditDate": "2018-02-04T05:57:06.220", "AnswerCount": "1", "FavoriteCount": "1", "Title": "Is the address of a std::optional's value stable?", "CommentCount": "8", "LastEditorUserId": "2173029", "AcceptedAnswerId": "48601326", "Score": "15", "CreationDate": "2018-02-03T19:11:54.763", "Id": "48601023", "LastActivityDate": "2018-02-04T05:57:06.220", "Body": "<p>Say I have a <code>std::optional&lt;T&gt;</code>. I reset and assign the value multiple times. Is the address of the value (when present) always the same for a given optional?</p>\n<p>In other words:</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;optional&gt;\n#include &lt;string&gt;\n\ntemplate&lt;typename T&gt;\nauto test()\n{\n    auto opt = std::optional&lt;T&gt;{T{}};\n    auto* ptr = &amp;*opt;\n\n    opt.reset();\n    opt = T{};\n\n    assert(ptr == &amp;*opt); // Can this assert fail?\n}\n\nint main()\n{\n    test&lt;int&gt;();\n    test&lt;double&gt;();\n    test&lt;std::string&gt;();\n    // ...\n}\n</code></pre>\n<p>Does the standard guarantee the stability of the address of the value?</p>\n", "PostTypeId": "1", "OwnerUserId": "2173029"}, "bq_ids": {"n4659": {"so_48601023_48601326_2": {"length": 60, "section_id": 5016, "quality": 0.8823529411764706}}}});