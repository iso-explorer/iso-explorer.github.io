post_cb({"4877742": {"ParentId": "4877705", "CommentCount": "1", "Body": "<p>Because there are no templates in C.</p>\n", "OwnerUserId": "301883", "PostTypeId": "2", "Id": "4877742", "Score": "-4", "CreationDate": "2011-02-02T17:33:49.763", "LastActivityDate": "2011-02-02T17:33:49.763"}, "31161737": {"ParentId": "4877705", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>Because <code>extern C</code> disables name mangling which templates use</strong></p>\n<p>To see that templates are implemented with name mangling, compile and decompile:</p>\n<pre><code>#include &lt;cassert&gt;\n\ntemplate &lt;class C&gt;\nC f(C i) { return i; }\n\nint main() {\n    f&lt;int&gt;(1);\n    f&lt;double&gt;(1.5);\n}\n</code></pre>\n<p>with:</p>\n<pre><code>g++ -c -g -std=c++98 main.cpp\nobjdump -Sr main.o\n</code></pre>\n<p>The output contains:</p>\n<pre><code>int main() {\n   0:   55                      push   %rbp\n   1:   48 89 e5                mov    %rsp,%rbp\n   4:   48 83 ec 10             sub    $0x10,%rsp\n    f&lt;int&gt;(1);\n   8:   bf 01 00 00 00          mov    $0x1,%edi\n   d:   e8 00 00 00 00          callq  12 &lt;main+0x12&gt;\n            e: R_X86_64_PC32    _Z1fIiET_S0_-0x4\n    f&lt;double&gt;(1.5);\n  12:   48 b8 00 00 00 00 00    movabs $0x3ff8000000000000,%rax\n  19:   00 f8 3f \n  1c:   48 89 45 f8             mov    %rax,-0x8(%rbp)\n  20:   f2 0f 10 45 f8          movsd  -0x8(%rbp),%xmm0\n  25:   e8 00 00 00 00          callq  2a &lt;main+0x2a&gt;\n            26: R_X86_64_PC32   _Z1fIdET_S0_-0x4\n}\n  2a:   b8 00 00 00 00          mov    $0x0,%eax\n  2f:   c9                      leaveq \n  30:   c3                      retq\n</code></pre>\n<p>Note how all <code>callq</code> were made to call weird names like <code>_Z1fIiET_S0_</code>.</p>\n<p>The same goes for other features which depend on name mangling, e.g. function overloading.</p>\n<p>See also: <a href=\"https://stackoverflow.com/a/30526795/895245\">https://stackoverflow.com/a/30526795/895245</a></p>\n", "OwnerUserId": "895245", "LastEditorUserId": "895245", "LastEditDate": "2017-10-03T14:11:01.863", "Id": "31161737", "Score": "2", "CreationDate": "2015-07-01T12:46:22.873", "LastActivityDate": "2017-10-03T14:11:01.863"}, "4878529": {"ParentId": "4877705", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_4877705_4878529_0\">What does it mean that a template \"may\" have linkage? What is template linkage?</p>\n</blockquote>\n<p>All names either have external linkage, internal linkage, or have no linkage (C++03 \u00a73.5p2), but this is not the same linkage as language linkage.  (Confusing, I know. C++0x changes things around considerably with linkage, too.)  External linkage is required for anything used as a template argument:</p>\n<pre><code>void f() {\n  struct S {};\n  vector&lt;S&gt; v;  // Not allowed as S has internal linkage.\n}\n</code></pre>\n<p>Notice that C++98 has \"may\" in what you quoted of \u00a714p4, but C++03 removes the \"may\", as templates cannot be declared in a context that would give them internal linkage:</p>\n<pre><code>void f() {\n  // Not allowed:\n  template&lt;class T&gt;\n  struct S {};\n}\n</code></pre>\n", "OwnerUserId": "511601", "PostTypeId": "2", "Id": "4878529", "Score": "7", "CreationDate": "2011-02-02T18:49:31.950", "LastActivityDate": "2011-02-02T18:49:31.950"}, "4877705": {"CommentCount": "1", "AcceptedAnswerId": "4878529", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-02-02T17:30:55.137", "LastActivityDate": "2017-10-03T14:11:01.863", "LastEditDate": "2017-05-23T12:02:14.477", "ViewCount": "18330", "FavoriteCount": "2", "Title": "Why can't templates be within extern \"C\" blocks?", "Id": "4877705", "Score": "19", "Body": "<p><em>This is a follow-up question to <a href=\"https://stackoverflow.com/questions/4866433/is-it-possible-to-typedef-a-pointer-to-extern-c-function-type-within-a-template/4866569#4866569\">an answer</a> to <a href=\"https://stackoverflow.com/q/4866433/196844\">Is it possible to typedef a pointer-to-extern-\u201cC\u201d-function type within a template?</a></em></p>\n<p>This code fails to compile with <code>g++</code>, Visual C/C++, and Comeau C/C++ with basically the same error message:</p>\n<pre><code>#include &lt;cstdlib&gt;\n\nextern \"C\" {\n    static int do_stuff(int) {\n        return 3;\n    }\n\n    template &lt;typename return_t_, typename arg1_t_&gt;\n    struct test {\n        static void foo(return_t_ (*)(arg1_t_)) { }\n    };\n}\n\nint main()\n{\n    test&lt;int, int&gt;::foo(&amp;do_stuff);\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>g++ says \"error: template with C linkage\", Visual C/C++ emits compiler error <a href=\"http://msdn.microsoft.com/en-us/library/95bhc9c2.aspx\" rel=\"nofollow noreferrer\">C2894</a>, and Comeau C/C++ says \"error: this declaration may not have extern \"C\" linkage\".</p>\n<p>The thing is, all are happy with:</p>\n<pre><code>#include &lt;cstdlib&gt;\n\nextern \"C\" {\n    static int do_stuff(int) {\n        return 3;\n    }\n\n    struct test {\n        static void foo(int (*)(int)) { }\n    };\n}\n\nint main()\n{\n    test::foo(&amp;do_stuff);\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>Section 7.5, Linkage specifications, of the C++ Standard states:</p>\n<blockquote>\n<p id=\"so_4877705_4877705_0\">A C language linkage is ignored for the names of class members and the member function\n  type of class member functions.</p>\n</blockquote>\n<p>And it even gives the example:</p>\n<pre><code>extern \"C\" {\n    class X {\n        void mf(); // the name of the function mf and the member\n                // function's type have C++ language linkage\n        void mf2(void(*)()); // the name of the function mf2 has C++ language\n                // linkage; the parameter has type pointer to C function\n    };\n}\n</code></pre>\n<p>If templates were allowed in extern \"C\" blocks, then the member functions of the instantiations would have C++ linkage.</p>\n<p>Why, then, does chapter 14, Templates, of the C++98 Standard state:</p>\n<blockquote>\n<p id=\"so_4877705_4877705_1\">A template name may have linkage (3.5). A template, a template explicit specialization (14.7.3), and a class template partial specialization shall not have C linkage.</p>\n</blockquote>\n<p>What does it mean that a template \"may\" have linkage? What is template linkage?</p>\n<p>Why is it explicitly forbidden to have a template with C linkage, when a class is okay, and all member functions of instantiations of the template (the default constructor, destructor, and assignment operator overload) would have C++ linkage?</p>\n", "Tags": "<c++><templates><extern><linkage>", "OwnerUserId": "196844", "AnswerCount": "5"}, "4877752": {"ParentId": "4877705", "CommentCount": "4", "Body": "<p>Templates aren't actual code, they're just guidelines to the compiler for how to generate the code once the template parameters are known. As such they don't actually exist until you try to use them. You can't provide linkage to something that doesn't exist.</p>\n", "OwnerUserId": "5987", "PostTypeId": "2", "Id": "4877752", "Score": "13", "CreationDate": "2011-02-02T17:34:39.023", "LastActivityDate": "2011-02-02T17:34:39.023"}, "4877749": {"ParentId": "4877705", "CommentCount": "2", "Body": "<p>Because template function names need to be decorated with additional information, and <code>extern \"C\"</code> turns decoration off. The purpose of <code>extern \"C\"</code> is to be able to declare functions that can be called with C linkage, which is something that will never work with a template function obviously.</p>\n", "OwnerUserId": "12416", "PostTypeId": "2", "Id": "4877749", "Score": "3", "CreationDate": "2011-02-02T17:34:34.700", "LastActivityDate": "2011-02-02T17:34:34.700"}, "bq_ids": {"n4140": {"so_4877705_4877705_1": {"section_id": 51, "quality": 0.875, "length": 14}, "so_4877705_4877705_0": {"section_id": 5520, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_4877705_4877705_1": {"section_id": 46, "quality": 0.875, "length": 14}, "so_4877705_4877705_0": {"section_id": 5306, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_4877705_4877705_1": {"section_id": 52, "quality": 0.8125, "length": 13}, "so_4877705_4877705_0": {"section_id": 6955, "quality": 0.9166666666666666, "length": 11}}}});