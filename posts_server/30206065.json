post_cb({"30206065": {"CommentCount": "10", "AcceptedAnswerId": "30206193", "CreationDate": "2015-05-13T05:02:24.480", "LastActivityDate": "2015-05-13T11:32:51.620", "PostTypeId": "1", "ViewCount": "927", "FavoriteCount": "0", "Title": "Inconsistency for size_t and sizeof", "Id": "30206065", "Score": "29", "Body": "<p>Isn't it bothersome that the result of a native operator cannot be defined without including a header file?</p>\n<p>According to this <a href=\"http://en.cppreference.com/w/cpp/types/size_t\">page</a>, <code>size_t</code> is defined in headers cstddef, cstdio, cstring, ctime, and cstdlib. Thus, if neither of those headers is included then <code>size_t</code> should be undefined. However, the following program compiles without any warning (using MSVC 2015RC).</p>\n<pre><code>int main()\n{\n    auto d_Size = sizeof( int );\n    return 0;\n}\n</code></pre>\n<p>It seems that <code>size_t</code> is somewhat of a bastard between a native type and a typedef. What does the standard say?</p>\n", "Tags": "<c++><sizeof>", "OwnerUserId": "2549876", "AnswerCount": "2"}, "30206245": {"ParentId": "30206065", "CommentCount": "0", "CreationDate": "2015-05-13T05:17:09.770", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "30206245", "Score": "4", "Body": "<p>According to the C++ standard, <code>std::size_t</code> is defined in <code>&lt;cstddef&gt;</code>.</p>\n<blockquote>\n<p id=\"so_30206065_30206245_0\"><strong>5.3.3 Sizeof</strong></p>\n<p id=\"so_30206065_30206245_1\">...</p>\n<p id=\"so_30206065_30206245_2\">6 The result of <code>sizeof</code> and <code>sizeof...</code> is a constant of type <code>std::size_t.</code> [ <em>Note:</em> <code>std::size_t</code> is defined in\n  the standard header <code>&lt;cstddef&gt;</code> (18.2). \u2014 <em>end note</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2015-05-13T05:17:09.770"}, "bq_ids": {"n4140": {"so_30206065_30206193_1": {"section_id": 6081, "quality": 0.6666666666666666, "length": 10}, "so_30206065_30206193_0": {"section_id": 6076, "quality": 0.7727272727272727, "length": 51}, "so_30206065_30206245_2": {"section_id": 6081, "quality": 0.6666666666666666, "length": 10}}, "n3337": {"so_30206065_30206193_1": {"section_id": 5849, "quality": 0.6666666666666666, "length": 10}, "so_30206065_30206193_0": {"section_id": 5844, "quality": 0.7575757575757576, "length": 50}, "so_30206065_30206245_2": {"section_id": 5849, "quality": 0.6666666666666666, "length": 10}}, "n4659": {"so_30206065_30206193_1": {"section_id": 7577, "quality": 0.6666666666666666, "length": 10}, "so_30206065_30206193_0": {"section_id": 7572, "quality": 0.7727272727272727, "length": 51}, "so_30206065_30206245_2": {"section_id": 7577, "quality": 0.6666666666666666, "length": 10}}}, "30206193": {"ParentId": "30206065", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-05-13T05:13:06.253", "Score": "31", "LastEditorUserId": "3093378", "LastEditDate": "2015-05-13T11:32:51.620", "Id": "30206193", "OwnerUserId": "3093378", "Body": "<p><strong>5.3.3 Sizeof [expr.sizeof]</strong></p>\n<blockquote>\n<p id=\"so_30206065_30206193_0\">1) The sizeof operator yields the number of bytes in the object\n  representation of its operand. The operand is either an expression,\n  which is an unevaluated operand (Clause 5), or a parenthesized\n  type-id. The sizeof operator shall not be applied to an expression\n  that has function or incomplete type, to the parenthesized name of\n  such types, or to a glvalue that designates a bit-field. sizeof(char),\n  sizeof(signed char) and sizeof(unsigned char) are 1. The result of\n  sizeof applied to any other fundamental type (3.9.1) is\n  implementation-defined. [ Note: in particular, sizeof(bool),\n  sizeof(char16_t), sizeof(char32_t), and sizeof(wchar_t) are\n  implementation-defined.75 \u2014 end note ] [ Note: See 1.7 for the\n  definition of byte and 3.9 for the definition of object\n  representation. \u2014 end note ]</p>\n<p id=\"so_30206065_30206193_1\">6) <strong>The result of sizeof and sizeof... is a constant of type std::size_t</strong>.\n  [ Note: std::size_t is defined in the standard header <code>&lt;cstddef&gt;</code>\n  (18.2). \u2014 end note ]</p>\n</blockquote>\n<p>However, <code>std::size_t</code> is just a type alias. The <code>sizeof</code> operator can return its result without any need of \"accessing\" the type alias; the result of <code>sizeof</code> is some fundamental type (implementation defined), which is then aliased as <code>std::size_t</code> in <code>&lt;cstddef&gt;</code>. </p>\n<p>Note also that in C++ <code>typedef</code> or <code>using</code> <strong>do not define a new type</strong> (i.e. a <em>strong type</em>), but only an alias (i.e. their <code>typeid</code> are the same). Hence, in your case, <code>auto</code> just deduces the fundamental type returned by the <code>sizeof</code> operator, which is the same as the type alias <code>std::size_t</code>. No problem for the compiler.</p>\n", "LastActivityDate": "2015-05-13T11:32:51.620"}});