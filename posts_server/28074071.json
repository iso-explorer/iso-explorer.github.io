post_cb({"28074354": {"ParentId": "28074071", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-01-21T18:35:11.540", "Score": "3", "LastEditorUserId": "3647361", "LastEditDate": "2015-01-21T18:41:41.950", "Id": "28074354", "OwnerUserId": "3647361", "Body": "<p>I believe that the problem in your analysis is the fact that the statement</p>\n<pre><code>int t = 1.0;\n</code></pre>\n<p>is indeed well-formed - an implicit conversion from <code>double</code> to <code>int</code> obviously exists. [over.ics.list]/4 also describes it:</p>\n<blockquote>\n<p id=\"so_28074071_28074354_0\">Otherwise, if the parameter type is <code>std::initializer_list&lt;X&gt;</code> and all\n  the elements of the initializer list can be implicitly converted to\n  <code>X</code>, the implicit conversion sequence is the worst conversion\n  necessary to convert an element of the list to <code>X</code>, or if the\n  initializer list has no elements, the identity conversion.</p>\n</blockquote>\n<p>Every element from the initializer list can be implicitly converted to <code>int</code>, thus the constructor is viable and chosen. However, only once it is chosen, the whole thing hard-errors, [dcl.init.list]/(3.6):</p>\n<blockquote>\n<p id=\"so_28074071_28074354_1\">The applicable constructors are enumerated and the best one is chosen\n  through overload resolution (13.3, 13.3.1.7). <strong>If a narrowing\n  conversion (see below) is required to convert any of the arguments,\n  the program is ill-formed.</strong></p>\n</blockquote>\n<p>As you can see, the constructor to call is determined before the narrowing-check is performed. In other words, <strong>the viability of an initializer-list constructor is not depending on narrowing of any arguments.</strong><br>\nThus the code should be ill-formed.</br></p>\n<p>One way to get the desired behavior is to use a constructor template with SFINAE</p>\n<pre><code>template &lt;typename T, typename=std::enable_if_t&lt;std::is_same&lt;int, T&gt;{}&gt;&gt;\nA(std::initializer_list&lt;T&gt;) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/db85f5e7c6a78783\" rel=\"nofollow\"><strong>Demo</strong></a>.</p>\n", "LastActivityDate": "2015-01-21T18:41:41.950"}, "28074071": {"CommentCount": "5", "ViewCount": "184", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-01-21T18:16:38.680", "LastActivityDate": "2015-01-21T19:01:30.103", "Title": "Why is this initializer_list constructor a viable overload?", "AcceptedAnswerId": "28074354", "LastEditDate": "2017-05-23T12:20:35.417", "Id": "28074071", "Score": "1", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;initializer_list&gt;\n\nclass A\n{\n public:\n  A(int, bool) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n  A(int, double) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n  A(std::initializer_list&lt;int&gt;) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n};\n\nint main()\n{\n  A a1 = {1, 1.0};\n  return 0;\n}\n</code></pre>\n<p>(This question is a follow-up to <a href=\"https://stackoverflow.com/questions/28058371/list-initialization-and-failed-overload-resolution-of-initializer-list-construct\">this</a>.)</p>\n<p>The above program fails to compile with <code>clang35 -std=c++11</code></p>\n<pre><code>init.cpp:15:14: error: type 'double' cannot be narrowed to 'int' in initializer list [-Wc++11-narrowing]\n  A a1 = {1, 1.0};\n             ^~~\ninit.cpp:15:14: note: insert an explicit cast to silence this issue\n  A a1 = {1, 1.0};\n             ^~~\n             static_cast&lt;int&gt;( )\n</code></pre>\n<p>while <code>g++48 -std=c++11</code> chooses a produce a warning to diagnose the ill-formed narrowing</p>\n<pre><code>init.cpp: In function \u2018int main()\u2019:\ninit.cpp:15:17: warning: narrowing conversion of \u20181.0e+0\u2019 from \u2018double\u2019 to \u2018int\u2019 inside { } [-Wnarrowing]\n   A a1 = {1, 1.0};\n                 ^\ninit.cpp:15:17: warning: narrowing conversion of \u20181.0e+0\u2019 from \u2018double\u2019 to \u2018int\u2019 inside { } [-Wnarrowing]\n</code></pre>\n<p>and produces the result</p>\n<pre><code>A::A(std::initializer_list&lt;int&gt;)\n</code></pre>\n<p>My question is if <code>A::A(std::initializer_list&lt;int&gt;)</code> should be a viable overload. Below are standard quotes that I think imply that the <code>initializer_list</code> overload should not be viable. </p>\n<p>From <code>13.3.2 [over.match.viable]</code></p>\n<blockquote>\n<p id=\"so_28074071_28074071_0\">Second, for <code>F</code> to be a viable function, there shall exist for each\n  argument an <em>implicit conversion</em> sequence that converts that argument\n  to the corresponding parameter of <code>F</code>.</p>\n</blockquote>\n<p>From <code>4 [conv]</code></p>\n<blockquote>\n<p id=\"so_28074071_28074071_1\">An expression <code>e</code> can be <em>implicitly converted</em> to a type <code>T</code> if and\n  only if the declaration <code>T t=e</code>; is well-formed, for some invented\n  temporary variable <code>t</code>.</p>\n</blockquote>\n<p>From <code>8.5.1 [dcl.init.aggr]</code></p>\n<blockquote>\n<p id=\"so_28074071_28074071_2\">If the <em>initializer-clause</em> is an expression and a narrowing\n  conversion is required to convert the expression, the program is\n  ill-formed.</p>\n</blockquote>\n<p>Using <code>8.5.1</code> and <code>4</code>, since the following is not well-formed</p>\n<pre><code>std::initializer_list&lt;int&gt; e = {1, 1.0};\n</code></pre>\n<p><code>{1, 1.0}</code> is not <em>implicitly convertible</em> to <code>std::initializer_list&lt;int&gt;</code>.</p>\n<p>Using the quote from <code>13.3.2</code>, shouldn't it imply that <code>A::A(std::initializer_list&lt;int&gt;)</code> isn't a viable function when doing overload resolution for <code>A a1 = {1, 1.0};</code>? Finding no viable <code>initializer_list</code> constructors, shouldn't this statement pick <code>A::A(int, double)</code>?</p>\n", "Tags": "<c++><c++11><language-lawyer><overload-resolution><list-initialization>", "OwnerUserId": "862351", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28074071_28074354_0": {"section_id": 630, "quality": 0.96, "length": 24}, "so_28074071_28074071_0": {"section_id": 602, "quality": 0.9285714285714286, "length": 13}, "so_28074071_28074071_2": {"section_id": 3299, "quality": 1.0, "length": 8}, "so_28074071_28074354_1": {"section_id": 3325, "quality": 0.85, "length": 17}, "so_28074071_28074071_1": {"section_id": 2, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_28074071_28074354_0": {"section_id": 621, "quality": 0.8, "length": 20}, "so_28074071_28074071_0": {"section_id": 592, "quality": 0.9285714285714286, "length": 13}, "so_28074071_28074071_2": {"section_id": 3169, "quality": 1.0, "length": 8}, "so_28074071_28074354_1": {"section_id": 3195, "quality": 0.85, "length": 17}, "so_28074071_28074071_1": {"section_id": 2, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_28074071_28074071_1": {"section_id": 2, "quality": 0.9090909090909091, "length": 10}, "so_28074071_28074071_0": {"section_id": 628, "quality": 0.9285714285714286, "length": 13}, "so_28074071_28074071_2": {"section_id": 4065, "quality": 1.0, "length": 8}, "so_28074071_28074354_0": {"section_id": 658, "quality": 1.0, "length": 25}, "so_28074071_28074354_1": {"section_id": 4091, "quality": 0.85, "length": 17}}}});