post_cb({"24646084": {"CommentCount": "1", "AcceptedAnswerId": "24649250", "CreationDate": "2014-07-09T05:40:12.287", "LastActivityDate": "2014-07-09T08:53:27.440", "PostTypeId": "1", "ViewCount": "409", "FavoriteCount": "1", "Title": "When does reinterpret_cast modify bits?", "Id": "24646084", "Score": "10", "Body": "<p>From the C++ standard:</p>\n<blockquote>\n<p id=\"so_24646084_24646084_0\">5.2.10.3</p>\n<p id=\"so_24646084_24646084_1\">The mapping performed by reinterpret_cast might, or might not, produce\n  a representation different from the original value.</p>\n</blockquote>\n<p>I've been trained at this very site to believe and repeat this.  <em>(Even if it's possibly just trivia)</em>.  A <code>reinterpret_cast</code> from <code>float*</code> to <code>int*</code> is allowed to produce a different bit pattern.  The only guarantee is that <code>reinterpret_cast</code>-ing that result back to <code>float*</code> will produce the original bit pattern.</p>\n<p>My question:  Does this ever happen?  Is there an existing, real-world platform or CPU or compiler that actually <code>reinterpret_cast</code>s to a different bit pattern?  If not, are there any real-world situations where <code>reinterpret_cast</code> has <em>any</em> runtime overhead?</p>\n<p>In all my experience with <code>reinterpret_cast</code>, the cast was a directive to the <em>compiler</em>, not the <em>runtime</em>.</p>\n", "Tags": "<c++><casting><reinterpret-cast>", "OwnerUserId": "16287", "AnswerCount": "2"}, "24649250": {"ParentId": "24646084", "CommentCount": "4", "Body": "<p>I've worked on platforms where <code>char*</code> was larger than <code>int*</code>,\nand on platforms where they had a different layout, even though\nthe size was the same.  Neither of the machines in question are\nparticularly relevant today, however (although the second, the\nPDP-10, <em>was</em> one of the more important machines in its heyday).\nIt's also conceivable that some compilation modes on an Intel in\nnative mode (or what used to be called native mode) would\n\"normalize\" pointers in a <code>reinterpret_cast</code>, or even an\nimplicit conversion, in order to facilitate address comparisons.\nIt's also conceivable (although I've not seen it) that such\nconversions enforce correct alignment, e.g. a conversion from\n<code>char*</code> to <code>int*</code> might force the 2 low-order bits to 0.  In\npractice, however, I don't think, today, that you're likely to\nsee a <code>reinterpret_cast</code> make any changes between data pointer\ntypes.  The issue is more historic.  (But I'm not sure about\nmodern embedded processors.  From what I understand, many of them\nare word addressing, and so if <code>sizeof(int) != sizeof(char)</code>, they're\nlikely to need a special format to address <code>char</code>.)</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "24649250", "Score": "1", "CreationDate": "2014-07-09T08:53:27.440", "LastActivityDate": "2014-07-09T08:53:27.440"}, "bq_ids": {"n4140": {"so_24646084_24646191_0": {"section_id": 7224, "quality": 0.88, "length": 22}, "so_24646084_24646084_1": {"section_id": 6042, "quality": 0.9090909090909091, "length": 10}, "so_24646084_24646191_1": {"section_id": 6046, "quality": 0.6557377049180327, "length": 40}}, "n3337": {"so_24646084_24646191_0": {"section_id": 6968, "quality": 0.88, "length": 22}, "so_24646084_24646191_2": {"section_id": 5650, "quality": 1.0, "length": 19}, "so_24646084_24646084_1": {"section_id": 5810, "quality": 0.9090909090909091, "length": 10}, "so_24646084_24646191_1": {"section_id": 5814, "quality": 0.9508196721311475, "length": 58}}, "n4659": {"so_24646084_24646191_0": {"section_id": 8734, "quality": 0.8, "length": 20}, "so_24646084_24646084_1": {"section_id": 7541, "quality": 0.9090909090909091, "length": 10}, "so_24646084_24646191_1": {"section_id": 7545, "quality": 0.639344262295082, "length": 39}}}, "24646191": {"ParentId": "24646084", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Pointers can in principle be different sizes. The largest pointer, if there is any difference (disregarding member pointers, talking about real pointers), is <code>char*</code>, since a <code>char</code> by definition is a byte and can be anywhere, no alignment. <code>void*</code> must be able to represent <code>char*</code>.</p>\n<p>On a system with <code>int*</code> using fewer bits than <code>char*</code>, reinterpret-casting in that direction might be a bit risky.</p>\n<p>I think with these pointers (heh) you can find this in the standard. It's the requirement about <code>void*</code> being large enough for any pointer, and the thing about alignment: the stricter/larger, the fewer bits needed for pointer to that type. But I have not ever heard of any extant system where there is such difference.</p>\n<hr>\n<p>Standardese regarding <code>void*</code> being able to represent <code>char*</code>:</p>\n<p>C++11 \u00a73.9.2/4:</p>\n<blockquote>\n<p id=\"so_24646084_24646191_0\"><strong>\u201d</strong><br>\n  A pointer to <em>cv</em>-qualified (3.9.3) or <em>cv</em>-unqualified <code>void</code> can be used\n  to point to objects of unknown type. Such a pointer shall be able to hold any object\n  pointer. An object of type <em>cv</em> <code>void*</code> shall have the same\n  representation and alignment requirements as <em>cv</em> <code>char*</code></br></p>\n</blockquote>\n<p>The \u201cany object pointer\u201d implies vaguely that there are different sizes of pointer.</p>\n<hr>\n<p>Standaredese regarding the alignment of referent:</p>\n<p>C++11 \u00a75.2.10/7:</p>\n<blockquote>\n<p id=\"so_24646084_24646191_1\"><strong>\u201d</strong><br>\n  An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue <code>v</code> of type \u201cpointer to <code>T1</code>\u201d is converted to the type \u201cpointer to <em>cv</em> <code>T2</code>\u201d, the result <code>is static_cast&lt;</code><em>cv</em> <code>T2*&gt;(static_cast&lt;</code><em>cv</em> <code>void*&gt;(v))</code> if both <code>T1</code> and <code>T2</code> are standard-layout types (3.9) and the alignment\n  requirements of <code>T2</code> are no stricter than those of <code>T1</code>, or if either type is <code>void</code>. Converting a prvalue of type\n  \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment\n  requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer\n  value. The result of any other such pointer conversion is unspecified.</br></p>\n</blockquote>\n<p>It\u2019s worth noting that later on in the standard there is some support for C-style emulation of class derivation, that apparently contradicts the \u201cany other\u201d at the end above:</p>\n<p>C++11 \u00a79.2/20,</p>\n<blockquote>\n<p id=\"so_24646084_24646191_2\"><strong>\u201d</strong><br>\n  A pointer to a standard-layout struct object, suitably converted using a <code>reinterpret_cast</code>, points to its\n  initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa.</br></p>\n</blockquote>\n<p>In this case the two <em>objects</em> necessarily have the same alignment, while the previous cited paragraph talked only about alignment of types \u2013 but clearly the formal little contradiction is not a practical problem, as I see it.</p>\n</hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2014-07-09T06:09:13.383", "Id": "24646191", "Score": "5", "CreationDate": "2014-07-09T05:49:16.153", "LastActivityDate": "2014-07-09T06:09:13.383"}});