post_cb({"bq_ids": {"n4140": {"so_12214134_12215308_3": {"length": 6, "quality": 0.6666666666666666, "section_id": 3976}, "so_12214134_12215308_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 3967}}, "n3337": {"so_12214134_12215308_3": {"length": 6, "quality": 0.6666666666666666, "section_id": 3833}, "so_12214134_12215308_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 3824}}, "n4659": {"so_12214134_12215308_1": {"length": 8, "quality": 0.5714285714285714, "section_id": 5572}}}, "12215308": {"Id": "12215308", "PostTypeId": "2", "Body": "<p>Seems like a bug in Boost and many C++ standard library implementations. The problem is shared by both <code>pair</code> and <code>tuple</code>. The simplest code to demonstrate it is:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;utility&gt;\nusing namespace std;\nint main() {\n    //compiles\n    pair&lt;int,vector&lt;int&gt;&gt; bug1( pair&lt;int,int&gt;(5,6) );\n\n    //compiles\n    pair&lt;int,vector&lt;int&gt;&gt; bug2;\n    bug2 = pair&lt;int,int&gt;(5,6);\n}\n</code></pre>\n<p>Clang 4.0 with <code>libc++</code> and the other one accepts this, Comeau Online accepts it too. GCC 4.7.1 gives an error.</p>\n<p>It must not compile, according to:</p>\n<blockquote>\n<p id=\"so_12214134_12215308_0\">20.3.2/12</p>\n<pre><code>template&lt;class U, class V&gt; pair(const pair&lt;U, V&gt;&amp; p);\n</code></pre>\n<p id=\"so_12214134_12215308_1\">Remark: This constructor shall not participate in overload resolution unless const U&amp; is implicitly convertible to first_type and const V&amp; is implicitly convertible to second_type.</p>\n<p id=\"so_12214134_12215308_2\">20.3.2/23</p>\n<pre><code>template&lt;class U, class V&gt; pair&amp; operator=(const pair&lt;U, V&gt;&amp; p);\n</code></pre>\n<p id=\"so_12214134_12215308_3\">Requires: <code>is_assignable&lt;first_type&amp;, const U&amp;&gt;::value</code> is <code>true</code> and <code>is_assignable&lt;second_type&amp;, const V&amp;&gt;::value</code> is <code>true</code>.</p>\n</blockquote>\n", "LastEditorUserId": "544621", "LastActivityDate": "2012-08-31T12:42:41.903", "Score": "1", "CreationDate": "2012-08-31T12:22:44.963", "ParentId": "12214134", "CommentCount": "7", "OwnerUserId": "544621", "LastEditDate": "2012-08-31T12:42:41.903"}, "12216929": {"Id": "12216929", "PostTypeId": "2", "Body": "<p>The issue is the implicit conversion.  It's not from <code>int</code> to\n<code>std::vector&lt;int&gt;</code>; that wouldn't work, because the constructor involved\nthere is declared <code>explicit</code>, and so cannot be used for implicit\nconversions.  The implicit conversion is from <code>std::pair&lt;int, int&gt;</code> to\n<code>std::pair&lt;int, std::vector&lt;int&gt; &gt;</code>.  This uses the constructor derived\nfrom the template: <code>template &lt;typename U1, typename U2&gt; std::pair(\nstd::pair&lt;U1, U2&gt; const&amp; )</code>, which is not implicit.  And the definition\nof this constructor is: </p>\n<pre><code>template &lt;typename T1, typename T2&gt;\ntemplate &lt;typename U1, typename U2&gt;\nstd::pair&lt;T1, T2&gt;::std::pair( std::pair&lt;U1, U2&gt; const&amp; other )\n    : first( other.first )\n    , second( other.second )\n{\n}\n</code></pre>\n<p>(This is not exactly how the standard specifies it.  But the\nspecification in C++03 doesn't allow much else.  In C++11, there's a lot\nof extra baggage so that things can be move constructed when possible,\nbut I think the final effect comes out the the same.)</p>\n<p>Note that in this constructor, there is an explicit invocation of the\nconstructor, rather than an implicit conversion.  So for the implicit\nconversion of <code>pair</code> to work, it is sufficient that the two types be\nexplicitly convertible.</p>\n<p>Personally, I doubt that this was the original intent.  I suspect, in\nfact, that most of the language surrounding <code>std::pair</code> was frozen\nbefore <code>explicit</code> was added to the language, so there wasn't an issue.\nLater, no one thought to revisit the issue.  And in C++11, revisiting it\nwould have broken backwards compatibility.  So you get some unexpected\nconversions.</p>\n<p>Note that this isn't the only situation where forwarding causes an\nexplicit conversion to become implicit.  Consider:</p>\n<pre><code>std::vector&lt;std::vector&lt;int&gt; &gt; v2D( 5, 10 );\n</code></pre>\n<p>Obviously, <code>10</code> is not a <code>std::vector&lt;int&gt;</code> (which is what the second\nargument should be).  But... in C++03, this matches the constructor\ntemplate:</p>\n<pre><code>template&lt;typename ForwardIterator, typename ForwardIterator&gt;\nstd::vector( ForwardIterator begin, ForwardIterator end );\n</code></pre>\n<p>And the standard has some special language for this:</p>\n<p>\u2014 the constructor</p>\n<pre><code>template &lt;class InputIterator&gt;\nX(InputIterator f, InputIterator l, const Allocator&amp; a = Allocator())\n</code></pre>\n<p>shall have the same effect as:</p>\n<pre><code>X(static_cast&lt;typename X::size_type&gt;(f),\nstatic_cast&lt;typename X::value_type&gt;(l), a)\n</code></pre>\n<p>if InputIterator is an integral type.</p>\n<p>And the implicit conversion has become explicit.</p>\n<p>(Note that without this special language,</p>\n<pre><code>std::vector&lt;int&gt; v(10, 42);\n</code></pre>\n<p>fails to compile: the intantiation of the template constructor, above,\nis an exact match, which is better than <code>std::vector&lt;int&gt;( size_t, int\n)</code>.  The committee felt that requiring an explicit cast of the first\ninteger, above, to <code>size_t</code> was perhaps asking too much of the users.)</p>\n<p>C++11 has changed the wording here significantly, and:</p>\n<pre><code>std::vector&lt;int, std::vector&lt;int&gt;&gt; v2D( 10, 42 );\n</code></pre>\n<p>is no longer legal.</p>\n<p>No such changes, at laest that I can see, were applied to the\nconstructor of <code>std::pair</code>.</p>\n", "LastActivityDate": "2012-08-31T14:00:18.447", "CommentCount": "0", "CreationDate": "2012-08-31T14:00:18.447", "ParentId": "12214134", "Score": "1", "OwnerUserId": "649665"}, "12214134": {"ViewCount": "343", "Body": "<p>Consider the following code. A tuple consisting of integer and <strong>vector of integer</strong> is defined as the key of a map. However, I was surprised that the compiler does not throw any error when inserting or looking for a tuple consisting of integer and <strong>integer</strong> as the key. How can this be, since the second element of the tuple should be of the type  <strong>vector of integer</strong>?  </p>\n<pre><code>std::map &lt;boost::tuple&lt;int, vector&lt;int &gt; &gt;, int&gt; test;\nstd::map &lt;boost::tuple&lt;int, vector&lt;int &gt; &gt;, int&gt;::iterator test_it;\n\nvector &lt;int&gt; t;\nt.push_back(4);\n\ntest.insert(make_pair(boost::make_tuple(3, t), 4));\n\ntest.insert(make_pair(boost::make_tuple(3, 6), 4));\n\ntest_it = test.find(boost::make_tuple(3, 7)); \nif(test_it != test.end()) \nthrow \" test is passed\";  \n</code></pre>\n", "AcceptedAnswerId": "12215308", "Title": "Issue with key of std::map", "CreationDate": "2012-08-31T11:10:55.147", "Id": "12214134", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-08-31T12:06:10.473", "LastEditorUserId": "1638452", "LastActivityDate": "2012-08-31T14:00:18.447", "Score": "3", "OwnerUserId": "1638452", "Tags": "<c++><stl><stdmap><boost-tuples>", "AnswerCount": "2"}});