post_cb({"29423727": {"ParentId": "27954940", "CommentCount": "0", "Body": "<p>This case has been discussed in the C++ committee (according to Richard Smith <a href=\"https://llvm.org/bugs/show_bug.cgi?id=23107#c1\" rel=\"nofollow\">https://llvm.org/bugs/show_bug.cgi?id=23107#c1</a>) and things have gotten clearer now:</p>\n<pre><code>using Base::B\n</code></pre>\n<p>is <em>not</em> intended to be valid code.</p>\n<p>The following method is the correct way to express constructor inheritance when introducing a class alias <code>Base</code>:</p>\n<pre><code>using Base::Base\n</code></pre>\n<p>However, the error messages produced by clang are misleading and will hopefully be solved as part of this bug report (<a href=\"https://llvm.org/bugs/show_bug.cgi?id=22242\" rel=\"nofollow\">https://llvm.org/bugs/show_bug.cgi?id=22242</a>).</p>\n", "OwnerUserId": "2188211", "PostTypeId": "2", "Id": "29423727", "Score": "2", "CreationDate": "2015-04-02T22:45:49.207", "LastActivityDate": "2015-04-02T22:45:49.207"}, "27954940": {"CommentCount": "6", "AcceptedAnswerId": "29423727", "PostTypeId": "1", "LastEditorUserId": "1593077", "CreationDate": "2015-01-15T00:26:00.283", "LastActivityDate": "2015-04-02T22:45:49.207", "LastEditDate": "2015-02-13T22:07:35.560", "ViewCount": "585", "FavoriteCount": "1", "Title": "A 'using' statement compiles with g++, fails compilation with clang", "Id": "27954940", "Score": "8", "Body": "<p>I have code of the following structure (which is of course much more complex in reality, especially \"Base\" is a three-liner, but I've tried to capture the gist of it):</p>\n<pre><code>template &lt;class T&gt;\nclass A {};\n\ntemplate &lt;class T&gt;\nclass B {\npublic:\n    B(){};\n};\n\ntemplate &lt;class T&gt;\nclass C : public B&lt;A&lt;T&gt;&gt; {\npublic:\n    using Base = B&lt;A&lt;T&gt;&gt;;\n    using Base::B;\n};\n\nstatic const C&lt;int&gt; c{};\n</code></pre>\n<p>The code compiles fine with g++ via</p>\n<pre><code>g++ -c test.cpp -std=c++11\n</code></pre>\n<p>However, with clang++ I get an error message I don't really understand</p>\n<pre><code>clang++ -c test.cpp -std=c++11\n</code></pre>\n<blockquote>\n<p id=\"so_27954940_27954940_0\">test.cpp:14:14: error: dependent using declaration resolved to type without 'typename'\n        using Base::B;</p>\n</blockquote>\n<p>Is there anything wrong with my code or is this a bug in clang?</p>\n<p>Note: When writing <code>using B&lt;A&lt;T&gt;&gt;::B;</code> it compiles fine with both compilers, but this not a real solution to my problem.</p>\n<p>Edit: clang version is 3.5.0, gcc version is 4.9.2</p>\n", "Tags": "<c++><compilation><g++><clang>", "OwnerUserId": "2188211", "AnswerCount": "2"}, "28511153": {"ParentId": "27954940", "CommentCount": "0", "Body": "<p>From section 12.1:</p>\n<blockquote>\n<p id=\"so_27954940_28511153_0\">Constructors do not have names</p>\n</blockquote>\n<p>So the usual rules for qualified lookup do not apply.  Instead you have to rely on the special rule for constructor lookup (section 3.4.3.1):</p>\n<blockquote>\n<p id=\"so_27954940_28511153_1\">In a lookup in which function names are not ignored    and the <em>nested-name-specifier</em>  nominates a class <code>C</code>:</p>\n<p id=\"so_27954940_28511153_2\">\u2014   if  the  name  specified  after  the  <em>nested-name-specifier</em>,  when  looked  up  in  <code>C</code>,  is  the  <em>injected-class-name</em> of <code>C</code>, or</p>\n<p id=\"so_27954940_28511153_3\">\u2014   <strong>in a <em>using-declaration</em>  (7.3.3) that is a <em>member-declaration</em>, if the name speci\ufb01ed after the <em>nested-name-specifier</em> is the same as the <em>identifier</em> or the <em>simple-template-id</em>\u2019s <em>template-name</em> in the last component of the nested-name-specifier</strong>,</p>\n<p id=\"so_27954940_28511153_4\">the name is instead considered to name the constructor of class <code>C</code>.</p>\n</blockquote>\n<p>So you can certainly write</p>\n<pre><code>using Base::Base;\n</code></pre>\n<p>instead of</p>\n<pre><code>using Base::B;\n</code></pre>\n<p>Your original version should work under the first bullet point, but injected-class-names get complicated when templates are involved.  Just go with the simpler version <code>Base::Base</code>, which additionally is more readable.  Anyone who sees that instantly knows you are naming a constructor.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "28511153", "Score": "2", "CreationDate": "2015-02-14T00:47:02.773", "LastActivityDate": "2015-02-14T00:47:02.773"}, "bq_ids": {"n4140": {"so_27954940_28511153_2": {"section_id": 7114, "quality": 1.0, "length": 7}, "so_27954940_28511153_4": {"section_id": 7114, "quality": 1.0, "length": 5}, "so_27954940_28511153_1": {"section_id": 7114, "quality": 1.0, "length": 7}, "so_27954940_28511153_3": {"section_id": 7114, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_27954940_28511153_2": {"section_id": 6858, "quality": 1.0, "length": 7}, "so_27954940_28511153_4": {"section_id": 6858, "quality": 1.0, "length": 5}, "so_27954940_28511153_1": {"section_id": 574, "quality": 0.5714285714285714, "length": 4}, "so_27954940_28511153_3": {"section_id": 6858, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_27954940_28511153_2": {"section_id": 8615, "quality": 1.0, "length": 7}, "so_27954940_28511153_4": {"section_id": 8615, "quality": 1.0, "length": 5}, "so_27954940_28511153_1": {"section_id": 8615, "quality": 1.0, "length": 7}, "so_27954940_28511153_3": {"section_id": 8615, "quality": 0.8571428571428571, "length": 12}}}});