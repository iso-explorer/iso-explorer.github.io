post_cb({"bq_ids": {"n4140": {"so_49100298_49114467_1": {"length": 9, "quality": 1.0, "section_id": 5441}}, "n3337": {"so_49100298_49114467_1": {"length": 9, "quality": 1.0, "section_id": 5236}}, "n4659": {"so_49100298_49114467_1": {"length": 9, "quality": 1.0, "section_id": 6868}}}, "49114467": {"Id": "49114467", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_49100298_49114467_0\">// Q1): Why the following works, but (I) does not. <br/>\n<code>static_assert(std::is_same&lt;decltype(std::get&lt;2&gt;(defaults).second), intp&gt;::value);</code></p>\n</blockquote>\n<p>Here's the magic: in C++ some expressions are considered <strong><em>unevaluated</em></strong>. <code>decltype(...)</code> is one of them (refer to [dcl.type.simple])</p>\n<p>What does it mean for <code>decltype(...)</code> to be unevaluated?</p>\n<blockquote>\n<p id=\"so_49100298_49114467_1\">In this context, the common purpose of\n  writing the expression is merely to refer to its type.</p>\n</blockquote>\n<p>Think of it more like a fancy <code>typedef</code>. Nothing can ever actually be created from within this context. You can do some interesting things with it, like use incomplete types.</p>\n<hr>\n<p>The reason why </p>\n<pre><code>typedef std::shared_ptr&lt;int&gt; intp;\nconstexpr intp x = nullptr; \n</code></pre>\n<p>doesn't work should now become obvious: this expression <strong>is</strong> evaluated, and since we know that we cannot create a <code>constexpr shared_ptr</code>, compilation fails.</p>\n<hr>\n<blockquote>\n<p id=\"so_49100298_49114467_2\">// Q2): Why this works: is there a better way to say something like <br/>\n<code>//      static_assert(actual_type(var1) == int);</code>? <br/>\n<code>static_assert(std::get&lt;int&gt;(var1) == 3);</code></p>\n</blockquote>\n<p>This works because a <a href=\"http://en.cppreference.com/w/cpp/utility/variant/variant\" rel=\"nofollow noreferrer\"><code>std::variant</code></a> has a <code>constexpr</code> constructor, and you are constructing it with a compile-time integer value of <code>3</code> which constructs the <code>int</code> field of the variant.</p>\n<p>Next, <a href=\"http://en.cppreference.com/w/cpp/utility/variant/get\" rel=\"nofollow noreferrer\"><code>std::get</code></a> on a <code>variant</code> is <strong>also</strong> marked <code>constexpr</code>, and since the variant is constructedd as <code>constexpr</code>, we can obtain the value <code>3</code> at compile-time.</p>\n</hr></hr>", "LastEditorUserId": "27678", "LastActivityDate": "2018-03-05T16:02:38.953", "Score": "0", "CreationDate": "2018-03-05T15:57:09.120", "ParentId": "49100298", "CommentCount": "0", "OwnerUserId": "27678", "LastEditDate": "2018-03-05T16:02:38.953"}, "49100298": {"ViewCount": "96", "Body": "<p>I have the following questions regarding the <code>constexpr</code>, I kinda understand that one cannot declare a <code>std::shared_ptr&lt;T&gt;</code> to be <code>const</code>, but why does the first <code>static_assert()</code> works?</p>\n<p>Also, how does the second <code>static_assert()</code> work? I wanted to have an array of <code>std::variants</code>, which are consts, and wanted to have compile-time type-checking to enforce the type; however, it seems that if a <code>std::shared_ptr</code> is one of the variant type, then it cannot be declared <code>constexpr</code>; but if I declare the container as <code>std::tuple</code>, even without the <code>constexpr</code> annotation, (I) seemed to work; </p>\n<pre><code>typedef std::shared_ptr&lt;int&gt; intp;\n\nconst auto defaults = std::make_tuple(std::make_pair(1, true),\n                                  std::make_pair(2, 3),\n                                  std::make_pair(3, intp(nullptr)));\n\n\ntypedef std::variant&lt;int, bool&gt; MyVar;\nconstexpr MyVar var1 = 3;\n\n// constexpr intp x = nullptr; (I)\n//typedef std::variant&lt;int, bool, intp&gt; MyVar2; This doesn't work\n//constexpr MyVar2 var2 = 3;\n\nint main()\n{\n    // Q1): Why the following works, but (I) does not.\n    static_assert(std::is_same&lt;decltype(std::get&lt;2&gt;(defaults).second), intp&gt;::value);\n    // Q2): Why this works: is there a better way to say something like\n    //      static_assert(actual_type(var1) == int);\n    static_assert(std::get&lt;int&gt;(var1) == 3);\n    //static_assert(x == nullptr);  This does not work \n}\n</code></pre>\n", "Title": "c++ why this static_assert works:", "CreationDate": "2018-03-04T20:47:27.553", "LastActivityDate": "2018-03-05T16:02:38.953", "CommentCount": "1", "LastEditDate": "2018-03-04T21:36:51.597", "PostTypeId": "1", "LastEditorUserId": "6022656", "Id": "49100298", "Score": "2", "OwnerUserId": "1819047", "Tags": "<c++><c++17><constexpr><variant><static-assert>", "AnswerCount": "2"}, "49100444": {"Id": "49100444", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_49100298_49100444_0\">I kinda understand that one cannot declare a shared_ptr to be const, but why does the first static_assert works?</p>\n</blockquote>\n<p>Because</p>\n<pre><code>static_assert(std::is_same&lt;decltype(std::get&lt;2&gt;(defaults).second), intp&gt;::value);\n</code></pre>\n<p>doesn't create a compile-time <code>stared_ptr</code>; only check if the type of <code>std::get&lt;2&gt;(defaults).second</code> is a <code>intp</code>.</p>\n<p>This information is known compile time also if the values are available only run time.</p>\n<blockquote>\n<p id=\"so_49100298_49100444_1\">Also, how does the second static_assert work? I wanted to have an array of std::variants, which are consts, and wanted to have compile-time type-checking to enforce the type; however, it seems that if a shared_ptr is one of the variant type, then it cannot be declared constexpr; but if I declare the container as std::tuple, even without the constexpr annotation, (I) seemed to work;</p>\n</blockquote>\n<p>Not sure what you mean.</p>\n<p>If for \"second static_assert work\" do you mean</p>\n<pre><code>static_assert(std::get&lt;int&gt;(var1) == 3);\n</code></pre>\n<p>it's because <code>var1</code> is <code>constexpr</code> and <code>std::get()</code> (for <code>std::variant</code>) is <code>constexpr</code>; so <code>std::get&lt;int&gt;(var1)</code> it's a value that can be used, compile time, in a <code>static_assert()</code>\nWith</p>\n", "LastActivityDate": "2018-03-04T21:02:31.273", "Score": "3", "CreationDate": "2018-03-04T21:02:31.273", "ParentId": "49100298", "CommentCount": "0", "OwnerUserId": "6022656"}});