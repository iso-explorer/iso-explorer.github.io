post_cb({"16780786": {"CommentCount": "1", "AcceptedAnswerId": "16781321", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-05-27T21:30:42.163", "LastActivityDate": "2013-05-28T06:39:04.030", "LastEditDate": "2017-05-23T10:29:11.710", "ViewCount": "526", "FavoriteCount": "3", "Title": "Is an inherited default constructor also user-defined?", "Id": "16780786", "Score": "12", "Body": "<p>The <a href=\"http://clang.llvm.org/compatibility.html#default_init_const\" rel=\"nofollow noreferrer\">Clang documentation</a> neatly explains that </p>\n<blockquote>\n<p id=\"so_16780786_16780786_0\">If a class or struct has no user-defined default constructor, C++\n  doesn't allow you to default construct a const instance of it like\n  this ([dcl.init], p9)</p>\n</blockquote>\n<p>The following code has such a user-defined default constructor for <code>Base</code>, but g++ and Clang disagree whether the default constructor for <code>Derived</code> is user-defined, even though <code>Derived</code> does explicitly inherit all of the <code>Base</code> constructors (using the <strong><a href=\"https://stackoverflow.com/questions/9979194/what-is-constructor-inheritance\">new C++11 inheriting constructors feature</a></strong>)</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Base\n{\npublic:\n    Base(): b_(0) {}  // look! user-defined default constructor\n    void print() const { std::cout &lt;&lt; b_ &lt;&lt; \"\\n\"; }\nprivate:\n    int b_;\n};\n\nclass Derived\n:\n    public Base\n{\n    using Base::Base; // does this constitute a user-defined default constructor?\n};\n\nint main()\n{\n    Base const b;\n    b.print();    // 0 for g++ &amp; CLang\n\n    Derived const d;\n    d.print();    // 0 for g++, Clang: \"default initialization of an object of const type 'const Derived' requires a user-provided default constructor\"\n}\n</code></pre>\n<p><strong>g++ 4.8 happily accepts this code, but Clang 3.3 does not. What does the Standard say?</strong></p>\n<p><strong>NOTE</strong>: without a user-defined default constructor for <code>Base</code>, neither g++ 4.8 nor Clang 3.3  accept <code>Base const b;</code> (whereas e.g. g++ 4.7.2 previously accepted that). Given that g++ knows about the rule, I would think that this implies that g++ regards the default constructor for <code>Derived</code> as user-defined. But Clang 3.3 thinks otherwise.</p>\n<p><strong>UPDATE</strong>: based on @JesseGood 's  answer that 0/1 argument constructors are never inherited, I tried changing the <code>Base</code> constructor to </p>\n<pre><code>Base(int b = 0, void* = nullptr): b_(b) {}\n</code></pre>\n<p>but it does not resolve the Clang error.</p>\n", "Tags": "<c++><c++11><g++><clang><default-constructor>", "OwnerUserId": "819272", "AnswerCount": "1"}, "16781321": {"ParentId": "16780786", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Clang is correct.</p>\n<p>The relevant passage about const instances is from 8.5p7:</p>\n<blockquote>\n<p id=\"so_16780786_16781321_0\">If a program calls for the default initialization of an object of a\n  const-qualified type T, T shall be a class type with a <strong>user-provided</strong>\n  default constructor.</p>\n</blockquote>\n<p>Since <code>Base(): b_(0) {}</code> is user-provided, <code>Base const b;</code> is fine.</p>\n<p>The next important part is 12.9p3:</p>\n<blockquote>\n<p id=\"so_16780786_16781321_1\">For each non-template constructor in the candidate set of inherited\n  constructors <strong>other than a constructor having no parameters</strong> or a\n  copy/move constructor having a single parameter, a constructor is\n  implicitly declared with the same constructor characteristics unless\n  there is a user-declared constructor with the same signature in the\n  class where the using-declaration appears</p>\n</blockquote>\n<p>The important part here is the bolded text. I believe this rules out your case since <code>Base()</code> is a constructor having no parameters. This means that the <code>Derived</code> does not have a user provided default constructor (although one still is implicitly declared).</p>\n<p>What this also means is that default, copy and move constructors from a base class are <strong>never</strong> inherited.</p>\n", "OwnerUserId": "906773", "LastEditorUserId": "906773", "LastEditDate": "2013-05-27T22:44:52.993", "Id": "16781321", "Score": "7", "CreationDate": "2013-05-27T22:29:53.220", "LastActivityDate": "2013-05-27T22:44:52.993"}, "bq_ids": {"n4140": {"so_16780786_16781321_0": {"section_id": 3286, "quality": 1.0, "length": 11}, "so_16780786_16781321_1": {"section_id": 484, "quality": 0.9696969696969697, "length": 32}}, "n3337": {"so_16780786_16781321_0": {"section_id": 3156, "quality": 1.0, "length": 11}, "so_16780786_16781321_1": {"section_id": 475, "quality": 0.9696969696969697, "length": 32}}, "n4659": {"so_16780786_16781321_0": {"section_id": 382, "quality": 0.6363636363636364, "length": 7}}}});