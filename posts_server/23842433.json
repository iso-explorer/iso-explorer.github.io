post_cb({"bq_ids": {"n4140": {"so_23842433_23842564_0": {"length": 71, "quality": 0.9861111111111112, "section_id": 3919}, "so_23842433_23842564_1": {"length": 137, "quality": 0.9383561643835616, "section_id": 7156}}, "n3337": {"so_23842433_23842564_0": {"length": 71, "quality": 0.9861111111111112, "section_id": 3779}, "so_23842433_23842564_1": {"length": 137, "quality": 0.9383561643835616, "section_id": 6900}}, "n4659": {"so_23842433_23842564_0": {"length": 49, "quality": 0.6805555555555556, "section_id": 4805}, "so_23842433_23842564_1": {"length": 76, "quality": 0.5205479452054794, "section_id": 8663}}}, "23842433": {"ViewCount": "162", "Body": "<p>I have recently read Andrei Alexandrescu's Modern C++ Design. After reading 6. chapter, I begin to worry about our singletons at company. Since our experienced team leader writes core helper libraries like singletons etc... . I asked him if the way he handles singleton takes care of on dead reference problem ? If he used at_exit function call which is given by C core language?  </p>\n<p>He told me C++11 has singleton support and will execute CTORs and DTORs in a row that they will not be any dead reference problem. User will not have to cope with synchronization. </p>\n<p>Even it sounds awesome I couldn't find any information which confirms him on internet. So please tell me if C++11 takes care of Dead Reference Problem for singletons and if so please explain a little what dark magic going behind ? </p>\n", "AcceptedAnswerId": "23842564", "Title": "Does C++11 core language takes care of Singleton Dead Reference?", "CreationDate": "2014-05-24T07:30:00.887", "Id": "23842433", "CommentCount": "2", "LastEditDate": "2014-05-24T07:45:43.227", "PostTypeId": "1", "LastEditorUserId": "241631", "LastActivityDate": "2014-05-24T09:17:37.687", "Score": "1", "OwnerUserId": "1745372", "Tags": "<c++><c++11><singleton>", "AnswerCount": "1"}, "23842564": {"Id": "23842564", "PostTypeId": "2", "Body": "<p>Presumably your team leader is talking about singletons implemented as follows:</p>\n<pre><code>T &amp;get_value() {\n   static T val;\n   return val; \n}\n</code></pre>\n<p>In this case, the standard gives two guarantees. The first is that the <code>val</code> objects will be constructed exactly once, the first time that the flow of program execution passes the declaration of the local static variable, even if that happens simultaneously on several threads <code>6.7/4</code>:</p>\n<blockquote>\n<p id=\"so_23842433_23842564_0\">An implementation is permitted to perform early initialization of other block-scope variables with static or thread storage duration under the same conditions that an implementation is permitted to statically initialize a variable with static or thread storage duration in namespace scope (3.6.2). Otherwise such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration. If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</p>\n</blockquote>\n<p>Static initialisation is only allowed in the case of constants, so as long as <code>T</code> does not have a <code>constexpr</code> constructor you shouldn't have to worry (but read 3.6.2 for the full rules, in case there is some edge case that is relevant to your code).</p>\n<p>The second guarantee is that all variables with static storage duration will be destructed in the reverse order of their construction <code>3.6.3/1</code>:</p>\n<blockquote>\n<p id=\"so_23842433_23842564_1\">Destructors (12.4) for initialized objects (that is, objects whose lifetime (3.8) has begun) with static storage duration are called as a result of returning from main and as a result of calling std::exit (18.5). Destructors for initialized objects with thread storage duration within a given thread are called as a result of returning from the initial function of that thread and as a result of that thread calling std::exit. The completions of the destructors for all initialized objects with thread storage duration within that thread are sequenced before the initiation of the destructors of any object with static storage duration. If the completion of the constructor or dynamic initialization of an object with thread storage duration is sequenced before that of another, the completion of the destructor of the second is sequenced before the initiation of the destructor of the first. If the completion of the constructor or dynamic initialization of an object with static storage duration is sequenced before that of another, the completion of the destructor of the second is sequenced before the initiation of the destructor of the first. [Note: This definition permits concurrent destruction. \u2014 end note ] If an object is initialized statically, the object is destroyed in the same order as if the object was dynamically initialized. For an object of array or class type, all subobjects of that object are destroyed before any block-scope object with static storage duration initialized during the construction of the subobjects is destroyed. If the destruction of an object with static or thread storage duration exits via an exception, std::terminate is called (15.5.1).</p>\n</blockquote>\n<p>While this paragraph gives a lot of scope for concurrent destruction of static objects when their construction was concurrent, the main thing to take away from it is that destruction happens in the reverse order of construction.</p>\n<p>Together, these mean means that if <code>T val</code> depends on some <code>U val</code> in another of these singleton functions, the <code>U val</code> will always be constructed before <code>T val</code> and destructed after the <code>T val</code>, so overall, this is a safe way of implementing singletons (unless you're doing something very crazy).</p>\n", "LastEditorUserId": "485561", "LastActivityDate": "2014-05-24T09:17:37.687", "Score": "5", "CreationDate": "2014-05-24T07:47:51.237", "ParentId": "23842433", "CommentCount": "0", "LastEditDate": "2014-05-24T09:17:37.687", "OwnerUserId": "485561"}});