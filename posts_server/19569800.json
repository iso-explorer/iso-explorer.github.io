post_cb({"19569857": {"Id": "19569857", "PostTypeId": "2", "Body": "<ol>\n<li>Because <code>*</code> operator of iterator is overloaded and it return a\nreference to the object it points on.</li>\n<li>You can force it by <code>thing_pointer = *(reinterpret_cast&lt;Thing**&gt;(&amp;it));</code>. But it's undefined behavior.</li>\n</ol>\n", "LastActivityDate": "2013-10-24T15:14:52.903", "CommentCount": "3", "CreationDate": "2013-10-24T15:14:52.903", "ParentId": "19569800", "Score": "2", "OwnerUserId": "2720534"}, "19569930": {"Id": "19569930", "PostTypeId": "2", "Body": "<p>The first gets a reference to the object, then takes the address of it, giving the pointer.</p>\n<p>The second tries to cast the iterator to a pointer, which is likely to fail because most types can't be cast to pointers - only other pointers, integers, and class types with a conversion operator.</p>\n", "LastActivityDate": "2013-10-24T15:17:55.850", "CommentCount": "0", "CreationDate": "2013-10-24T15:17:55.850", "ParentId": "19569800", "Score": "2", "OwnerUserId": "204847"}, "19570223": {"Id": "19570223", "PostTypeId": "2", "Body": "<p>Obligitory Standard Quotes, emphasis mine:</p>\n<h2>5.2.19 Reinterpret cast</h2>\n<blockquote>\n<p id=\"so_19569800_19570223_0\">1/ [...]  Conversions that can be performed explicitly using\n  reinterpret_cast are listed below. <strong>No  other conversion can be\n  performed explicitly using reinterpret_cast.</strong></p>\n<p id=\"so_19569800_19570223_1\">4/ A pointer can be explicitly converted to any integral type large\n  enough to hold it. [...]</p>\n<p id=\"so_19569800_19570223_2\">5/ A value of integral type or enumeration type can be explicitly\n  converted to a pointer. [...]</p>\n<p id=\"so_19569800_19570223_3\">6/ A function pointer can be explicitly converted to a function\n  pointer of a different type. [...]</p>\n<p id=\"so_19569800_19570223_4\">7/ An object pointer can be explicitly converted to an object pointer\n  of a different type. [...]</p>\n<p id=\"so_19569800_19570223_5\">8/ Converting a function pointer to an object pointer type or vice\n  versa is conditionally-supported. [...]</p>\n<p id=\"so_19569800_19570223_6\">9/ The null pointer value (4.10) is converted to the null pointer\n  value of the destination type. [...]</p>\n<p id=\"so_19569800_19570223_7\">10/ [...] \u201cpointer to member of X of type T1\u201d can be explicitly\n  converted to [...] \u201cpointer to member of Y of type T2\u201d [...]</p>\n<p id=\"so_19569800_19570223_8\">11/ A [...] T1 can be cast to the type \u201creference to T2\u201d if an\n  expression of type \u201cpointer to T1\u201d can be explicitly converted to the\n  type \u201cpointer to T2\u201d using a reinterpret_cast. [...]</p>\n</blockquote>\n<p>With the exception of the integral-to-pointer and value-to-reference conversions noted in 4/, 5/ and 11/  the only conversions that can be performed using <code>reinterpret_cast</code> are pointer-to-pointer conversions.  </p>\n<p>However in:</p>\n<pre><code>thing_pointer = reinterpret_cast&lt;Thing*&gt;(it);\n</code></pre>\n<p><code>it</code> is not a <em>pointer</em>, but an object.  It just so happens that this object was designed to emulate a pointer in many ways, but it's still not a pointer.</p>\n", "LastActivityDate": "2013-10-24T15:32:06.890", "CommentCount": "3", "CreationDate": "2013-10-24T15:32:06.890", "ParentId": "19569800", "Score": "4", "OwnerUserId": "241536"}, "bq_ids": {"n4140": {"so_19569800_19570223_0": {"length": 15, "quality": 1.0, "section_id": 6040}, "so_19569800_19570223_8": {"length": 14, "quality": 1.0, "section_id": 6050}, "so_19569800_19570223_5": {"length": 9, "quality": 1.0, "section_id": 6047}, "so_19569800_19570223_3": {"length": 9, "quality": 1.0, "section_id": 6045}, "so_19569800_19570223_6": {"length": 9, "quality": 0.8181818181818182, "section_id": 40}, "so_19569800_19570223_4": {"length": 9, "quality": 1.0, "section_id": 6046}, "so_19569800_19570223_7": {"length": 9, "quality": 1.0, "section_id": 6049}, "so_19569800_19570223_2": {"length": 9, "quality": 1.0, "section_id": 6044}, "so_19569800_19570223_1": {"length": 9, "quality": 1.0, "section_id": 6043}}, "n3337": {"so_19569800_19570223_0": {"length": 15, "quality": 1.0, "section_id": 5808}, "so_19569800_19570223_8": {"length": 14, "quality": 1.0, "section_id": 5818}, "so_19569800_19570223_2": {"length": 9, "quality": 1.0, "section_id": 5812}, "so_19569800_19570223_1": {"length": 9, "quality": 1.0, "section_id": 5811}, "so_19569800_19570223_3": {"length": 9, "quality": 1.0, "section_id": 5813}, "so_19569800_19570223_6": {"length": 9, "quality": 0.8181818181818182, "section_id": 37}, "so_19569800_19570223_7": {"length": 9, "quality": 1.0, "section_id": 5817}, "so_19569800_19570223_4": {"length": 9, "quality": 1.0, "section_id": 5814}, "so_19569800_19570223_5": {"length": 9, "quality": 1.0, "section_id": 5815}}, "n4659": {"so_19569800_19570223_0": {"length": 15, "quality": 1.0, "section_id": 7539}, "so_19569800_19570223_8": {"length": 14, "quality": 1.0, "section_id": 7549}, "so_19569800_19570223_2": {"length": 9, "quality": 1.0, "section_id": 7543}, "so_19569800_19570223_5": {"length": 9, "quality": 1.0, "section_id": 7546}, "so_19569800_19570223_3": {"length": 9, "quality": 1.0, "section_id": 7544}, "so_19569800_19570223_6": {"length": 9, "quality": 0.8181818181818182, "section_id": 41}, "so_19569800_19570223_7": {"length": 9, "quality": 1.0, "section_id": 7548}, "so_19569800_19570223_4": {"length": 9, "quality": 1.0, "section_id": 7545}, "so_19569800_19570223_1": {"length": 9, "quality": 1.0, "section_id": 7542}}}, "19569800": {"ViewCount": "602", "Body": "<p>I've got an iterator of Things. If I want to convert the current item to a pointer to the item, why does this work:</p>\n<pre><code>thing_pointer = &amp;(*it);\n</code></pre>\n<p>But this not:</p>\n<pre><code>thing_pointer = reinterpret_cast&lt;Thing*&gt;(it);\n</code></pre>\n<p>This is the compiler error I'm trying to comprehend: <a href=\"http://msdn.microsoft.com/en-us/library/sy5tsf8z(v=vs.90).aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/sy5tsf8z(v=vs.90).aspx</a></p>\n<p>Just in case, the type of the iterator is <code>std::_Vector_iterator&lt;std::_Vector_val&lt;Thing,std::allocator&lt;Thing&gt; &gt; &gt;</code></p>\n", "AcceptedAnswerId": "19569899", "Title": "reinterpret_cast an iterator to a pointer", "CreationDate": "2013-10-24T15:12:14.333", "Id": "19569800", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-10-24T15:32:06.890", "Score": "3", "OwnerUserId": "1225617", "Tags": "<c++><iterator><reinterpret-cast>", "AnswerCount": "5"}, "19569862": {"Id": "19569862", "PostTypeId": "2", "Body": "<p>Because iterator is not a pointer. It is a class of implementation-defined structure, and if you try to reinterpret it to a pointer, the raw data of the iterator class will be taken as a memory pointer, which may, but probably will not point to valid memory</p>\n", "LastActivityDate": "2013-10-24T15:15:03.660", "CommentCount": "0", "CreationDate": "2013-10-24T15:15:03.660", "ParentId": "19569800", "Score": "2", "OwnerUserId": "624664"}, "19569899": {"Id": "19569899", "PostTypeId": "2", "Body": "<p>In </p>\n<pre><code>&amp;(*it);\n</code></pre>\n<p>the <code>*</code> is <em>overloaded</em> to do what you logically mean: convert the iterator type to its pointed-to object.  You can then safely take the address of this object.</p>\n<p>Whereas in</p>\n<pre><code>reinterpret_cast&lt;Thing*&gt;(it);\n</code></pre>\n<p>you are telling the compiler to literally reinterpret the <code>it</code> object as a pointer.  But it might not be a pointer at all -- it might be a 50-byte struct, for all you know!  In that case, the first <code>sizeof (Thing*)</code> bytes of it will absolutely not happen to point at anything sensible.</p>\n<p>Tip: <code>reinterpret_cast&lt;&gt;</code> is nearly always the wrong thing.</p>\n", "LastActivityDate": "2013-10-24T15:16:20.923", "CommentCount": "2", "CreationDate": "2013-10-24T15:16:20.923", "ParentId": "19569800", "Score": "10", "OwnerUserId": "47984"}});