post_cb({"19868727": {"ParentId": "19476818", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The increment accesses the value of <code>foo</code> through an lvalue of a different type, which is undefined behaviour except in the cases listed in 3.10 [basic.lval]. Enumeration types and their underlying types are not in that list, so the code has undefined behaviour.</p>\n<p>With some compilers that support non-standard extensions you can do it via type-punning:</p>\n<pre><code>union intenum\n{\n    int8_t i;\n    Foo    e;\n};\n\nintenum ie;\nfor (ie.e = Foo::First; ie.e &lt;= Foo::Last; ++ie.i)\n  // ...\n</code></pre>\n<p>but this is not portable either, because accessing <code>intenum::i</code> after storing a value in <code>intenum::e</code> is not allowed by the standard.</p>\n<p>But why not just use an integer and convert as needed?</p>\n<pre><code>for (int8_t i = static_cast&lt;int8_t&gt;(Foo::First);\n     i &lt;= static_cast&lt;int8_t&gt;(Foo::Last);\n     ++i)\n{\n  Foo e = static_cast&lt;Foo&gt;(i);\n  // ...\n}\n</code></pre>\n<p>This is portable and safe.  </p>\n<p>(It's still not a good idea IMHO, because there could be several enumerators with the same value, or values of the enumeration type that have no corresponding enumerator label.)</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2013-11-08T21:31:38.960", "Id": "19868727", "Score": "1", "CreationDate": "2013-11-08T21:23:18.497", "LastActivityDate": "2013-11-08T21:31:38.960"}, "19477123": {"ParentId": "19476818", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>You might want to overload operator <code>++</code> for your enum if you really want to iterate its values:</p>\n<pre><code>Foo&amp; operator++( Foo&amp; f )\n{\n    using UT = std::underlying_type&lt; Foo &gt;::type;\n    f = static_cast&lt; Foo &gt;( static_cast&lt; UT &gt;( f ) + 1 );\n    return f;\n}\n</code></pre>\n<p>and use</p>\n<pre><code>for (Foo foo = Foo::First; foo != Foo::Last; ++foo)\n{\n    ...\n}\n</code></pre>\n<hr>\n<p>To answer the question of whether or not the <code>reinterpret_cast</code> is allowed, it all starts with 5.2.10/1:</p>\n<blockquote>\n<h3>5.2.10 Reinterpret cast [expr.reinterpret.cast]</h3>\n<p id=\"so_19476818_19477123_0\"><sup>1</sup> The result of the expression <code>reinterpret_cast&lt;T&gt;(v)</code> is the result of converting the expression <code>v</code> to type <code>T</code>. If <code>T</code> is an lvalue reference type or an rvalue reference to function type, the result is an lvalue; if <code>T</code> is an rvalue reference to object type, the result is an xvalue; otherwise, the result is a prvalue and the lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the expression <code>v</code>. <strong>Conversions that can be performed explicitly using <code>reinterpret_cast</code> are listed below. No other conversion can be performed explicitly using <code>reinterpret_cast</code>.</strong></p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>The reinterpretation using references is based on pointers as per 5.2.10/11:</p>\n<blockquote>\n<p id=\"so_19476818_19477123_1\"><sup>11</sup> A glvalue expression of type <code>T1</code> can be cast to the type \u201creference to <code>T2</code>\u201d if an expression of type \u201cpointer to <code>T1</code>\u201d can be explicitly converted to the type \u201cpointer to <code>T2</code>\u201d using a <code>reinterpret_cast</code>. The result refers to the same object as the source glvalue, but with the specified type. [ <em>Note:</em> That is, for lvalues, a reference cast <code>reinterpret_cast&lt;T&amp;&gt;(x)</code> has the same effect as the conversion <code>*reinterpret_cast&lt;T*&gt;(&amp;x)</code> with the built-in <code>&amp;</code> and <code>*</code> operators (and similarly for <code>reinterpret_cast&lt;T&amp;&amp;&gt;(x)</code>). \u2014 <em>end note</em> ] No temporary is created, no copy is made, and constructors (12.1) or conversion functions (12.3) are not called.</p>\n</blockquote>\n<p>Which transforms the question from this:</p>\n<pre><code>reinterpret_cast&lt;int8_t&amp;&gt;(foo)\n</code></pre>\n<p>to whether this is legal:</p>\n<pre><code>*reinterpret_cast&lt;int8_t*&gt;(&amp;foo)\n</code></pre>\n<p>Next stop is 5.2.10/7:</p>\n<blockquote>\n<p id=\"so_19476818_19477123_2\"><sup>7</sup> An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue <code>v</code> of type \u201cpointer to <code>T1</code>\u201d is converted to the type \u201cpointer to <em>cv</em> <code>T2</code>\u201d, the result is <code>static_cast&lt;</code><em><code>cv</code></em><code>T2*&gt;(static_cast&lt;</code><em><code>cv</code></em><code>void*&gt;(v))</code> if both <code>T1</code> and <code>T2</code> are standard-layout types (3.9) and the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>, or if either type is <code>void</code>. Converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value. The result of any other such pointer conversion is unspecified.</p>\n</blockquote>\n<p>Given 3.9/9 both <code>int8_t</code> and your enumeration type are standard layout types the question now transformed into:</p>\n<pre><code>*static_cast&lt;int8_t*&gt;(static_cast&lt;void*&gt;(&amp;foo))\n</code></pre>\n<p>This is where you are out of luck. <code>static_cast</code> is defined in 5.2.9 and there is nothing which makes the above legal - in fact 5.2.9/5 is a clear hint that it is illegal. The other clauses don't help:</p>\n<ul>\n<li>5.2.9/13 requires <code>T*</code> -&gt; <code>void*</code> -&gt; <code>T*</code> where <code>T</code> must be identical (omitting <em>cv</em>)</li>\n<li>5.2.9/9 and 5.2.9/10 are not about pointers, but about values</li>\n<li>5.2.9/11 is about classes and class hierarchies</li>\n<li>5.2.9/12 is about class member pointers</li>\n</ul>\n<p>My conclusion from this is that your code</p>\n<pre><code>reinterpret_cast&lt;int8_t&amp;&gt;(foo)\n</code></pre>\n<p>is not legal, its behavior is not defined by the standard.</p>\n<p>Also note that the above mentioned 5.2.9/9 and 5.2.9/10 are responsible for making the code legal which I gave in the initial answer and which you can still find at the top.</p>\n</hr>", "OwnerUserId": "2073257", "LastEditorUserId": "2073257", "LastEditDate": "2013-11-08T21:19:23.143", "Id": "19477123", "Score": "13", "CreationDate": "2013-10-20T12:05:56.653", "LastActivityDate": "2013-11-08T21:19:23.143"}, "19476818": {"CommentCount": "4", "AcceptedAnswerId": "19477123", "CreationDate": "2013-10-20T11:28:03.567", "LastActivityDate": "2013-11-08T21:31:38.960", "PostTypeId": "1", "ViewCount": "1492", "FavoriteCount": "4", "Title": "Is it safe to reinterpret_cast an enum class variable to a reference of the underlying type?", "Id": "19476818", "Score": "12", "Body": "<p>I've seen <code>reinterpret_cast</code> used to apply incrementation to enum classes, and I'd like to know if this usage is acceptable in standard C++.</p>\n<pre><code>enum class Foo : int8_t\n{\n    Bar1,\n    Bar2,\n    Bar3,\n    Bar4,\n\n    First = Bar1,\n    Last = Bar4\n};\n\nfor (Foo foo = Foo::First; foo &lt;= Foo::Last; ++reinterpret_cast&lt;int8_t &amp;&gt;(foo))\n{\n    ...\n}\n</code></pre>\n<p>I know casting to a reference of a base class is safe in case of trivial classes. But since enum classes are not event implicitly converted to their underlying types, I'm not sure if and how the code above would be guaranteed to work in all compilers. Any clues?</p>\n", "Tags": "<c++><c++11><reinterpret-cast><enum-class>", "OwnerUserId": "1083663", "AnswerCount": "3"}, "19477091": {"ParentId": "19476818", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>It is safe as long as it casts to the exact underlying type of the enum. </p>\n<p>If the underlying type of the enum class changes that <code>++reinterpret_cast&lt;int8_t &amp;&gt;(foo)</code> breaks silently.</p>\n<p>A safer version:</p>\n<pre><code>foo = static_cast&lt;Foo&gt;(static_cast&lt;std::underlying_type&lt;Foo&gt;::type&gt;(foo) + 1);\n</code></pre>\n<p>Or,</p>\n<pre><code>++reinterpret_cast&lt;std::underlying_type&lt;Foo&gt;::type&amp;&gt;(foo);\n</code></pre>\n", "OwnerUserId": "412080", "LastEditorUserId": "412080", "LastEditDate": "2013-10-20T12:13:25.927", "Id": "19477091", "Score": "0", "CreationDate": "2013-10-20T12:01:58.147", "LastActivityDate": "2013-10-20T12:13:25.927"}, "bq_ids": {"n4140": {"so_19476818_19477123_2": {"section_id": 6046, "quality": 0.6610169491525424, "length": 39}, "so_19476818_19477123_0": {"section_id": 6040, "quality": 0.9787234042553191, "length": 46}, "so_19476818_19477123_1": {"section_id": 6050, "quality": 0.8113207547169812, "length": 43}}, "n3337": {"so_19476818_19477123_2": {"section_id": 5814, "quality": 0.9661016949152542, "length": 57}, "so_19476818_19477123_0": {"section_id": 5808, "quality": 0.9787234042553191, "length": 46}, "so_19476818_19477123_1": {"section_id": 5818, "quality": 0.6037735849056604, "length": 32}}, "n4659": {"so_19476818_19477123_0": {"section_id": 7539, "quality": 0.9787234042553191, "length": 46}, "so_19476818_19477123_2": {"section_id": 7545, "quality": 0.6610169491525424, "length": 39}, "so_19476818_19477123_1": {"section_id": 7549, "quality": 0.8113207547169812, "length": 43}}}});