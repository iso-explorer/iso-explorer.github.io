post_cb({"30409055": {"Id": "30409055", "PostTypeId": "2", "Body": "<p>You cannot specialize inside a class scope. According to the C++ standard,</p>\n<blockquote>\n<p id=\"so_30409044_30409055_0\"><strong>14.7.3/2</strong> An explicit specialization shall be declared in a namespace enclosing the specialized template.</p>\n</blockquote>\n<p>Therefore you should specialize the template member function at namespace scope,</p>\n<pre><code>template&lt;&gt; // this should be outside the primary template class definition\nbool Foo::method() {\n    return true;\n}\n</code></pre>\n", "LastEditorUserId": "3093378", "LastActivityDate": "2015-12-12T22:01:07.327", "Score": "2", "CreationDate": "2015-05-23T05:01:45.453", "ParentId": "30409044", "CommentCount": "3", "OwnerUserId": "3093378", "LastEditDate": "2015-12-12T22:01:07.327"}, "30409254": {"Id": "30409254", "PostTypeId": "2", "Body": "<p>You can use SFINAE to achieve the desired effect, which technically turns the \"specialization\" (which is not possible as the other answer explained) into an overload:</p>\n<pre><code>template &lt;class T&gt;\ntypename std::enable_if&lt;\n    ! std::is_same&lt; T, bool &gt;::value,\n    T\n&gt;::type\nmethod() {\n    ...\n    return T();\n}\n\ntemplate &lt;class T&gt;\ntypename std::enable_if&lt;\n    std::is_same&lt; T, bool &gt;::value,\n    T\n&gt;::type\nmethod() {\n    ...\n    return true;\n}\n</code></pre>\n<p>The above is C++11, with C++14 you can even use <code>std::enable_if_t</code> to make it shorter.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/b9401a142315032d\" rel=\"nofollow\"><strong>Live example</strong></a></p>\n", "LastActivityDate": "2015-05-23T05:35:59.050", "CommentCount": "0", "CreationDate": "2015-05-23T05:35:59.050", "ParentId": "30409044", "Score": "1", "OwnerUserId": "2073257"}, "30409044": {"ViewCount": "1490", "Body": "<p>I have a class with template method that the parameter defines the return type. The default constructor for everything else is ok, but for bool I would like the method to return true. I am trying to specialize it as the following code, but this does not compile.</p>\n<pre><code>class Foo {\n    template &lt;class T&gt;\n    T method() {\n        ...\n        return T();\n    }\n\n    template&lt;&gt;\n    bool method() {\n       ...\n       return true;\n    }\n\n};\n</code></pre>\n<p>How I can achieve this?</p>\n", "AcceptedAnswerId": "30409055", "Title": "method template specialization by return type", "CreationDate": "2015-05-23T05:00:02.700", "Id": "30409044", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-12-12T22:01:07.327", "Score": "2", "OwnerUserId": "1870790", "Tags": "<c++><templates><template-specialization>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_30409044_30409055_0": {"length": 7, "quality": 0.875, "section_id": 264}}, "n3337": {"so_30409044_30409055_0": {"length": 7, "quality": 0.875, "section_id": 255}}, "n4659": {"so_30409044_30409055_0": {"length": 6, "quality": 0.75, "section_id": 285}}}});