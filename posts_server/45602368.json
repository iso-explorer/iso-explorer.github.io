post_cb({"45602856": {"ParentId": "45602368", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I agree with your interpretation. We have arguments of type <code>int*</code> and <code>Y</code> and we have two candidates:</p>\n<pre><code>operator+(X, int);                // #1\noperator+(int*, std::ptrdiff_t ); // #2\n</code></pre>\n<p><code>#1</code> requires two user-defined conversion sequences, <code>#2</code> requires an standard conversion sequence (Exact Match, though doesn't matter) and a user-defined conversion sequence. For the first argument, a standard conversion sequence <a href=\"http://eel.is/c++draft/over.ics.rank#2.1\" rel=\"nofollow noreferrer\">is better than</a> a user-defined conversion sequence, while for the second argument, the two sequences are indistinguishable (none of <a href=\"http://eel.is/c++draft/over.ics.rank#3.3\" rel=\"nofollow noreferrer\">these conditions</a> apply). Since the first implicit conversion sequence in <code>#2</code> is better than the first implicit conversion sequence in <code>#1</code>, and the second conversion sequences are equivalent, <code>#2</code> <a href=\"http://eel.is/c++draft/over.match.best#1.3\" rel=\"nofollow noreferrer\">wins</a>. </p>\n<p>And then post-CWG 1687, we <a href=\"http://eel.is/c++draft/over.match.oper#7\" rel=\"nofollow noreferrer\">don't perform</a> the last conversion from <code>double</code> to <code>ptrdiff_t</code>, so the result should be ill-formed. </p>\n<hr/>\n<p>To answer this question:</p>\n<blockquote>\n<p id=\"so_45602368_45602856_0\">is the behavior intended by CWG 1687?</p>\n</blockquote>\n<p>I suspect it certainly is, given that the example is:</p>\n<blockquote id=\"so_45602368_45602856_1\">\n<pre><code>int *b = Y() + X();             // error: pointer arithmetic requires integral operand\n</code></pre>\n</blockquote>\n<p>which is quite similar to your example - the only difference being that <code>Y()</code> is convertible to <code>int*</code> rather directly being <code>int*</code>.  I went ahead and filed <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81789\" rel=\"nofollow noreferrer\">gcc 81789</a> and <a href=\"https://bugs.llvm.org/show_bug.cgi?id=34138\" rel=\"nofollow noreferrer\">llvm 34138</a>. Note that clang simply doesn't implement CWG 1687, the examples from that issue and in the standard compile.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-08-10T01:14:49.643", "Id": "45602856", "Score": "4", "CreationDate": "2017-08-10T01:01:57.860", "LastActivityDate": "2017-08-10T01:14:49.643"}, "bq_ids": {"n4140": {"so_45602368_45602368_2": {"section_id": 588, "quality": 0.9545454545454546, "length": 21}, "so_45602368_45602856_1": {"section_id": 676, "quality": 0.5714285714285714, "length": 4}, "so_45602368_45602368_0": {"section_id": 588, "quality": 0.9411764705882353, "length": 32}}, "n3337": {"so_45602368_45602368_2": {"section_id": 578, "quality": 0.9545454545454546, "length": 21}, "so_45602368_45602856_1": {"section_id": 666, "quality": 0.5714285714285714, "length": 4}, "so_45602368_45602368_0": {"section_id": 578, "quality": 0.6470588235294118, "length": 22}}, "n4659": {"so_45602368_45602368_2": {"section_id": 611, "quality": 0.9545454545454546, "length": 21}, "so_45602368_45602856_1": {"section_id": 704, "quality": 0.5714285714285714, "length": 4}, "so_45602368_45602368_0": {"section_id": 611, "quality": 0.9411764705882353, "length": 32}}}, "45602368": {"CommentCount": "2", "ViewCount": "212", "PostTypeId": "1", "LastEditorUserId": "4908404", "CreationDate": "2017-08-09T23:55:22.503", "LastActivityDate": "2017-08-11T11:05:14.193", "Title": "Correct behavior of built-in operator candidates of overload resolution in the operator expression context", "AcceptedAnswerId": "45602856", "LastEditDate": "2017-08-11T11:05:14.193", "Id": "45602368", "Score": "8", "Body": "<p>Currently I'm trying to understand the paragraph <a href=\"http://eel.is/c++draft/over.match.oper#7\" rel=\"nofollow noreferrer\">[over.match.oper]/7</a> in the C++ Standard, but encountered the following case where GCC and Clang produce different results:</p>\n<p><a href=\"https://wandbox.org/permlink/WpoMviA4MHId7iD9\" rel=\"nofollow noreferrer\">https://wandbox.org/permlink/WpoMviA4MHId7iD9</a></p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n\nvoid print_type(int) { std::cout &lt;&lt; \"int\" &lt;&lt; std::endl; }\nvoid print_type(int*) { std::cout &lt;&lt; \"int*\" &lt;&lt; std::endl; }\n\nstruct X { X(int*) {} };\nstruct Y { operator double() { return 0.0; } };\n\nint operator+(X, int) { return 0; }   // #1\n// T* operator+(T*, std::ptrdiff_t);  // #2: a built-in operator (N4659 16.6/14)\n\nint main() {\n  int* p = 0;\n  Y y;\n\n  print_type(p + y);  // This line produces different results for different compilers:\n                      //   - gcc HEAD 8.0.0   : always \"int\" (#1 is called)\n                      //   - clang HEAD 6.0.0 : always \"int*\" (#2 is called)\n                      //   - my understanding : \"int*\" until C++11, ill-formed since C++14\n\n  return 0;\n}\n</code></pre>\n<h1>Description in standards</h1>\n<p>Here are quotes of the corresponding paragraph from versions of standards:</p>\n<p><strong>C++1z (N4659) 16.3.1.2 [over.match.oper] paragraph 7</strong> <br/>\n(essentially the same with <strong>C++14 (N4140) 13.3.1.2 [over.match.oper] paragraph 7</strong>):</p>\n<blockquote>\n<p id=\"so_45602368_45602368_0\">If a built-in candidate is selected by overload resolution, the operands of class type are converted to the types of the corresponding parameters of the selected operation function, except that the second standard conversion sequence of a user-defined conversion sequence (16.3.3.1.2) is not applied. Then the operator is treated as the corresponding built-in operator and interpreted according to Clause 8. [Example:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>struct X {\n  operator double();\n};\nstruct Y {\n  operator int*();\n};\nint *a = Y() + 100.0; // error: pointer arithmetic requires integral operand\nint *b = Y() + X();   // error: pointer arithmetic requires integral operand\n</code></pre>\n<p id=\"so_45602368_45602368_1\">- end example]</p>\n</blockquote>\n<p><strong>C++03 13.3.1.2 [over.match.oper] paragraph 7</strong> <br/>\n(essentially the same with <strong>C++11 (N3291) 13.3.1.2 [over.match.oper] paragraph 7</strong>):</p>\n<blockquote>\n<p id=\"so_45602368_45602368_2\">If a built-in candidate is selected by overload resolution, the operands are converted to the types of the corresponding parameters of the selected operation function. Then the operator is treated as the corresponding built-in operator and interpreted according to clause 5.</p>\n</blockquote>\n<p>The change in C++14 was introduced by <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1687\" rel=\"nofollow noreferrer\">CWG 1687</a>.</p>\n<h2>My naive interpretation</h2>\n<p>I initially thought the top code should be ill-formed in C++14. According to the standards, my naive understanding of the process of the overload resolution of the top code is this (section numbers are from N4659):</p>\n<p>First the set of candidate functions is generated. It contains the user-defined operator <code>#1</code> (<a href=\"http://eel.is/c++draft/over.match.oper#3.2\" rel=\"nofollow noreferrer\">16.3.1.2/(3.2)</a>) and a built-in operator <code>#2</code> (<a href=\"http://eel.is/c++draft/over.match.oper#3.3\" rel=\"nofollow noreferrer\">16.3.1.2/(3.3)</a>, <a href=\"http://eel.is/c++draft/over.built#14\" rel=\"nofollow noreferrer\">16.6/14</a>). Next, to determine the set of viable functions, viability of both operators is tested by constructing implicit conversion sequences (ICS) for each argument/parameter pair; All of the ICSs are successfully constructed as <code>ICS1(#1) = int* \u2192 X</code> (<a href=\"http://eel.is/c++draft/over.ics.user\" rel=\"nofollow noreferrer\">16.3.3.1.2</a>, user-defined conversion sequence), <code>ICS2(#2) = Y \u2192 double \u2192 int</code> (user-defined conversion sequence), <code>ICS1(#2) = int* \u2192 int*</code> (<a href=\"http://eel.is/c++draft/over.best.ics#6\" rel=\"nofollow noreferrer\">16.3.3.1/6</a>, identity conversion, one of the standard conversion sequences) and <code>ICS2(#2) = X \u2192 double \u2192 std::ptrdiff_t</code> (user-defined conversion sequence), and therefore both operators are viable. Then, the best viable function is selected by comparing ICSs; Since <code>ICS1(#2)</code> is better than <code>ICS1(#1)</code> (<a href=\"http://eel.is/c++draft/over.ics.rank#2.1\" rel=\"nofollow noreferrer\">16.3.3.2/(2.1)</a>) and <code>ICS2(#2)</code> is not worse than <code>ICS2(#1)</code> (<a href=\"http://eel.is/c++draft/over.ics.rank#3\" rel=\"nofollow noreferrer\">16.3.3.2/3</a>), <code>#2</code> is a better function than <code>#1</code> (<a href=\"http://eel.is/c++draft/over.match.best#1\" rel=\"nofollow noreferrer\">16.3.3/1</a>). Finally the built-in operator <code>#2</code> is selected by the overload resolution (<a href=\"http://eel.is/c++draft/over.match.best#2\" rel=\"nofollow noreferrer\">16.3.3/2</a>).</p>\n<p>When a built-in operator is selected, the rule quoted above (<a href=\"http://eel.is/c++draft/over.match.oper#7\" rel=\"nofollow noreferrer\">16.3.1.2/7</a>) applies: after applying ICSs to the arguments, treatment of the operator expression is transferred to Clause 8 [expr]. Here the application of ICSs differs in C++11 and C++14. In C++11, ICSs are totally applied, so <code>(int*) y + (std::ptrdiff_t) (double) n</code> is considered, and it's fine. While, in C++14 the second standard conversion sequences in user-defined conversion sequences are not applied, so <code>(int*) y + (double) n</code> is considered. This results in a semantic rule violation (<a href=\"http://eel.is/c++draft/expr.add#1\" rel=\"nofollow noreferrer\">8.7/1</a>), i.e. the expression is ill-formed and implementation is required to issue diagnostic messages.</p>\n<h2>Clang's interpretation</h2>\n<p>Clang selects <code>#2</code> and calls it without any diagnostic messages on 8.7/1 violation. My guess is Clang totally applies ICSs to the arguments before it transfers the call to built-in rules (8.7/1), and this is a bug.</p>\n<h2>GCC's interpretation</h2>\n<p>GCC selects <code>#1</code> without diagnostics. Microsoft C/C++ compiler in Visual Studio 2017 seems to behave the same. <del>Also, this behavior seems reasonable to me</del> (<strong>Edit</strong>: See [1]).</p>\n<p>My guess is GCC considers <code>#2</code> is not viable and then only the viable function is <code>#1</code>. But I couldn't find any rules like that the built-in operator is not viable when it becomes ill-formed without second standard conversion sequences in user-defined conversion sequences. In fact, when the phrase \"<em>except that the second standard conversion sequence of a user-defined conversion sequence</em>\" is introduced by CWG 1687, it seems there are no other modifications in the definition of viability.</p>\n<h1>Question</h1>\n<p><em>Question 1</em>: According to the current standard, which is the correct interpretation?</p>\n<p><em>Question 2</em>: If my naive interpretation is correct, is the behavior intended by CWG 1687?</p>\n<hr>\n<p><strong>Footnotes</strong></p>\n<ul>\n<li>[1]: Not to silently break the existing codes written in C++03, this behavior wouldn't be desired. This might be the reason why CWG 1687 decided to just disable the second standard conversion sequence leaving the definition of viability as it is. See comments below.</li>\n</ul>\n<p><strong>Update</strong></p>\n<p>After this question this issue was reported for the following compilers:</p>\n<ul>\n<li>gcc <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81789\" rel=\"nofollow noreferrer\">gcc 81789</a></li>\n<li>clang <a href=\"https://bugs.llvm.org/show_bug.cgi?id=34138\" rel=\"nofollow noreferrer\">llvm 34138</a></li>\n<li>msc <a href=\"https://developercommunity.visualstudio.com/content/problem/92207/bug-c-cwg-1687-is-performed-too-early-in-overload.html\" rel=\"nofollow noreferrer\">visualstudio 92207</a></li>\n</ul>\n</hr>", "Tags": "<c++><operator-overloading><c++14><c++1z>", "OwnerUserId": "4908404", "AnswerCount": "1"}});