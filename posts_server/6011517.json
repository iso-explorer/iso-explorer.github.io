post_cb({"6011651": {"ParentId": "6011517", "CommentCount": "7", "Body": "<p>According to Pete Becker, when you have list of rules like the bullet points in \u00a71.4/2, they're (at least normally) to be read in order, with earlier rules taking precedence over later rules.</p>\n<p>In other words, if your code violates both the second and third bullet points, violation of the second bullet point requires issuing a diagnostic, even though violating the third bullet point appears to remove that requirement.</p>\n<p>Unfortunately, I've never seen any explicit statement to that effect in the standard proper, only in old Usenet posts from Pete (and, if memory serves, perhaps also from Andrew Koenig who was the editor before Pete).</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "6011651", "Score": "0", "CreationDate": "2011-05-15T22:21:56.073", "LastActivityDate": "2011-05-15T22:21:56.073"}, "6030797": {"ParentId": "6011517", "CommentCount": "0", "Body": "<p>I think the rule you're quoting is talking about the whole program. A diagnostic isn't required if one TU has <code>extern int a;</code> and another has <code>extern float a;</code> because separate translation makes it impossible - the problem can only be detected at link time at best.</p>\n<p>But if both declarations occur within a single TU I'm sure a diagnostic is required. Perhaps by 3.3/4? That (roughly) requires that all declarations of a name in one scope refer to the same entity.</p>\n", "OwnerUserId": "212870", "PostTypeId": "2", "Id": "6030797", "Score": "1", "CreationDate": "2011-05-17T12:31:52.783", "LastActivityDate": "2011-05-17T12:31:52.783"}, "6012283": {"ParentId": "6011517", "CommentCount": "0", "Body": "<p>This looks like heavy math problem. My guess is that the the reason is that with two different typedefs you could end up with the same type in two different expressions. However when compiler stores the data structures, requiring the check would require compiler to \"evaluate\" the type expression to it's normal form. Church-Rosser theorem would need to be used inside the compiler to prove that the two expressions are equivalent. The operation used in typedefs is just plain old substitution, so full church-rosser would be required. So guess they made it optional. I think they don't want to add lambda calculus, which would be required next.</p>\n<pre><code>typedef A&lt;int&gt; C;\ntypedef int D;\ntypedef A&lt;D&gt; E;\nextern C v;\nextern E v;\n</code></pre>\n<p>Now, without evaluating both to <code>A&lt;int&gt;</code>, there is no way to check if these are the same type.</p>\n", "OwnerUserId": "560684", "PostTypeId": "2", "Id": "6012283", "Score": "0", "CreationDate": "2011-05-16T00:40:23.470", "LastActivityDate": "2011-05-16T00:40:23.470"}, "6011517": {"CommentCount": "1", "ViewCount": "168", "PostTypeId": "1", "LastEditorUserId": "256138", "LastActivityDate": "2011-05-17T12:50:50.147", "Body": "<p>On a search through the spec, it appears that my compiler isn't required to diagnose such mistakes as </p>\n<pre><code>extern int a;\nextern float a;\n</code></pre>\n<p>I previously thought that my compiler needs to diagnose that, but the spec says (emphasis added by me)</p>\n<blockquote>\n<p id=\"so_6011517_6011517_0\">After all adjustments of types (during which typedefs (7.1.3) are replaced by their definitions), the types speci\ufb01ed by all declarations referring to a given variable or function shall be identical, except that declarations for an array object can specify array types that differ by the presence or absence of a major array bound (8.3.4). <strong>A violation of this rule on type identity does not require a diagnostic.</strong></p>\n</blockquote>\n<p>And in fact, I found cases where compilers don't care. For example, GCC and clang accept the following</p>\n<pre><code>void g() { int f(); } \nvoid h() { float f(); }\n</code></pre>\n<p>Since a violation of a rule for which no diagnostic is required means that the entire program requires no diagnostic at all anymore, it means that the following ill-formed program doesn't require a diagnostic either (see 1.4p2). Fortunately, both GCC and Clang diagnose them.</p>\n<pre><code>int f();\nfloat f();\n</code></pre>\n<p>The behavior of this code at translation time is effectively undefined. What is the reason for this? Why can the spec not require such cases to be rejected and require these to be diagnosed?</p>\n", "Title": "Can I rely on my compiler to diagnose type mismatches within a TU?", "FavoriteCount": "2", "LastEditDate": "2011-05-17T12:50:50.147", "Id": "6011517", "Score": "4", "CreationDate": "2011-05-15T21:52:16.533", "Tags": "<c++><declaration><undefined-behavior>", "OwnerUserId": "34509", "AnswerCount": "4"}, "6011627": {"ParentId": "6011517", "CommentCount": "2", "Body": "<p>For your first example Visual studio (rightfully) kicks up:</p>\n<pre><code>d:\\experiments\\test1\\test1\\test1.cpp(7) : error C2371: 'a' : redefinition; different basic types\n        d:\\experiments\\test1\\test1\\test1.cpp(6) : see declaration of 'a'\n</code></pre>\n<p>There's nothing wrong with your second example as the function definitions are local so they can do whatever they like.</p>\n<p>Your third example (rightfully) kicks up an error in visual studio:</p>\n<pre><code>d:\\experiments\\test1\\test1\\test1.cpp(7) : error C2556: 'float f(void)' : overloaded function differs only by return type from 'int f(void)'\n        d:\\experiments\\test1\\test1\\test1.cpp(6) : see declaration of 'f'\nd:\\experiments\\test1\\test1\\test1.cpp(7) : error C2371: 'f' : redefinition; different basic types\n</code></pre>\n<p>I'm certain the spec says you cannot have multiple identically named variables in the same scope and function definitions in the same scope must differ by more than their return type.</p>\n", "OwnerUserId": "15369", "PostTypeId": "2", "Id": "6011627", "Score": "0", "CreationDate": "2011-05-15T22:15:24.673", "LastActivityDate": "2011-05-15T22:15:24.673"}, "bq_ids": {"n4140": {"so_6011517_6011517_0": {"section_id": 7143, "quality": 0.926829268292683, "length": 38}}, "n3337": {"so_6011517_6011517_0": {"section_id": 6887, "quality": 0.926829268292683, "length": 38}}, "n4659": {"so_6011517_6011517_0": {"section_id": 8644, "quality": 0.926829268292683, "length": 38}}}});