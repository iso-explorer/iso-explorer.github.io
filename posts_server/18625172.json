post_cb({"18625228": {"ParentId": "18625172", "CommentCount": "1", "Body": "<p>The conversion from <code>S</code> using the conversion operator is better than the conversion to <code>T</code> taking an <code>S const</code> as argument. If you make <code>s</code> an <code>S const</code>, the constructor is preferred: Your <em>identity operation</em> in one case, indeed, is an identity operation, in the other case it isn't. If you make the conversion operator of <code>S</code> a <code>const</code> member, you get an ambiguity. Below is a test program demonstrating all cases:</p>\n<pre><code>struct S;\nstruct T {\n    T(const T&amp;) = default;\n    T(const S &amp;);\n};\n\nstruct S {\n    S(); // needed to allow creation of a const object\n#ifdef AMBIGUOUS\n    operator T() const;\n#else\n    operator T();\n#endif\n};\n\nint main() {\n#ifdef CONST\n    S const s;\n#else\n    S s;\n#endif\n    T t = s; // copy-initialization of class type\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "18625228", "Score": "2", "CreationDate": "2013-09-04T23:08:46.607", "LastActivityDate": "2013-09-04T23:08:46.607"}, "18625389": {"ParentId": "18625172", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I think i found the rule which clarifies this:</p>\n<blockquote>\n<p id=\"so_18625172_18625389_0\">13.3.3.2: ... S1 and S2 are reference bindings (8.5.3), and the types to which the references refer are the same type except for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers is more cv-qualified than the type to which the reference initialized by S1 refers.</p>\n</blockquote>\n<p>In the member function S::operator T() the implicit object parameter has type S&amp; which is directly bound to the lvalue s of type S. In the constructor T::T(const S&amp;) the parameter is directly bound to the lvalue s of type S but this reference binding is more cv-qualified than in the operator function, so the operator function is preferred by overload resolution.</p>\n<p>Do you agree with this?</p>\n", "OwnerUserId": "1692163", "LastEditorUserId": "1692163", "LastEditDate": "2013-09-04T23:31:12.973", "Id": "18625389", "Score": "0", "CreationDate": "2013-09-04T23:25:13.500", "LastActivityDate": "2013-09-04T23:31:12.973"}, "18625172": {"CommentCount": "0", "ViewCount": "263", "CreationDate": "2013-09-04T23:03:09.307", "LastActivityDate": "2013-09-04T23:31:12.973", "Title": "Copy initialization of class type by user defined conversion", "PostTypeId": "1", "Id": "18625172", "Score": "3", "Body": "<p>I have the following code snippet:</p>\n<pre><code>struct T {\n    T(const T&amp;) = default;\n    T(const S &amp;);\n};\n\nstruct S {\n    operator T();\n};\n\nint main() {\n    S s;\n    T t = s; // copy-initialization of class type\n    return 0;\n}\n</code></pre>\n<p>My question is why the compiler prefers S::operator T() for the initialization of t rather than reporting an error that the initialization is ambigious. In my opinion the following happens (correct me if i am wrong):</p>\n<ul>\n<li>t is copy-initialized with an lvalue of type S</li>\n<li>S is not T and S is also not a subclass of T, so S and T are unrelated</li>\n<li>because of the fact that the variable t is copy-initialized and the fact that the types S and T are unrelated, the compiler tries to find user-defined-conversion sequences to do the initialization.</li>\n<li>overload resolution is responsible for selecting the best user-defined-conversion which can be either a converting constructor of T or the conversion function of S</li>\n<li>the implicite conversion sequence for the constructor T::T(const S&amp;) from the argument s is the identity conversion because the lvalue s can be bound directly to this lvalue reference</li>\n<li>the implicite conversion sequence for the conversion function S::operator T() from the argument s is also the identity conversion, because the implicit object parameter is S&amp;</li>\n</ul>\n<p>Both the constructor and the conversion function return a prvalue of type T which can be used to direct-initialize the variable t. That means that the second standard conversion sequence of both user-defined-conversion sequences is the identity conversion.</p>\n<p>This would mean that both user-defined-conversion sequences are equally good. Or is there a special rule which prefers the conversion functions?</p>\n<p>I was reading the following rules in the c++11 standard:</p>\n<blockquote>\n<p id=\"so_18625172_18625172_0\">The initialization that occurs in the form\n      T x = a;\n  as well as in argument passing, function return, throwing an exception (15.1), handling an exception (15.3), and aggregate member initialization (8.5.1) is called copy-initialization. </p>\n<p id=\"so_18625172_18625172_1\">The semantics of initializers are as follows...If the destination type is a (possibly cv-qualified) class type: If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified\n  version of the source type is the same class as, or a derived class of, the class of the destination,\n  constructors are considered....\n  Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3)</p>\n<p id=\"so_18625172_18625172_2\">User-defined conversion sequence U1 is a better conversion sequence than another user    defined conversion sequence U2 if they contain the same user-defined conversion function or constructor and if the second standard conversion sequence of U1 is better than the second standard conversion sequence of U2</p>\n</blockquote>\n<p>Maybe i am making false assumptions. I hope you can help me!</p>\n<p>Regards,\nKevin</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1692163", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_18625172_18625389_0": {"section_id": 639, "quality": 0.9130434782608695, "length": 21}, "so_18625172_18625172_1": {"section_id": 3296, "quality": 0.9259259259259259, "length": 50}, "so_18625172_18625172_2": {"section_id": 639, "quality": 0.9259259259259259, "length": 25}, "so_18625172_18625172_0": {"section_id": 3294, "quality": 0.7619047619047619, "length": 16}}, "n3337": {"so_18625172_18625389_0": {"section_id": 629, "quality": 0.9130434782608695, "length": 21}, "so_18625172_18625172_1": {"section_id": 3166, "quality": 0.9259259259259259, "length": 50}, "so_18625172_18625172_2": {"section_id": 629, "quality": 0.9259259259259259, "length": 25}, "so_18625172_18625172_0": {"section_id": 3164, "quality": 0.7619047619047619, "length": 16}}, "n4659": {"so_18625172_18625172_0": {"section_id": 4056, "quality": 0.7619047619047619, "length": 16}, "so_18625172_18625172_1": {"section_id": 4058, "quality": 0.9259259259259259, "length": 50}, "so_18625172_18625172_2": {"section_id": 667, "quality": 0.9259259259259259, "length": 25}, "so_18625172_18625389_0": {"section_id": 667, "quality": 0.9130434782608695, "length": 21}}}});