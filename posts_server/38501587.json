post_cb({"38501596": {"ParentId": "38501587", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Some common cases where the evaluation order has so far been <em>unspecified</em>, are specified and valid with <code>C++17</code>. Some undefined behaviour is now instead unspecified.</p>\n<blockquote>\n<p id=\"so_38501587_38501596_0\">What about things like </p>\n<pre><code>i=1;\nf(i++, i)\n</code></pre>\n</blockquote>\n<p>was undefined but is now unspecified.</p>\n<blockquote id=\"so_38501587_38501596_1\">\n<pre><code>std::cout &lt;&lt; f() &lt;&lt; f() &lt;&lt; f() ;\n</code></pre>\n</blockquote>\n<p>Was unspecified, but will become compatible with operator precedence so that the first evaluation of <code>f</code> will come first in the stream. (examples below).</p>\n<blockquote id=\"so_38501587_38501596_2\">\n<pre><code>f(g(),h(),j());\n</code></pre>\n</blockquote>\n<p>still has unspecified evaluation order of g, h, j. Note that <code>getf()(g(),h(),j())</code>, the rules state that <code>getf()</code> will be evaluated before <code>g,h,j</code>.</p>\n<p>Also note the following example from the proposal text:</p>\n<blockquote id=\"so_38501587_38501596_3\">\n<pre><code> std::string s = \u201cbut I have heard it works even if you don\u2019t believe in it\u201d \n s.replace(0, 4, \u201c\u201d).replace(s.find(\u201ceven\u201d), 4, \u201conly\u201d)\n .replace(s.find(\u201c don\u2019t\u201d), 6, \u201c\u201d);\n</code></pre>\n</blockquote>\n<p>The example comes from <em>The C++ Programming Language, 4th edition, Stroustrup</em>, and used to be unspecified behaviour, but with C++17 it will work as expected. There were similar issues with resumable functions (<code>.then( . . . )</code>).</p>\n<p>As another example, consider the following:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;cassert&gt;\n\nstruct Speaker{\n    int i =0;\n    Speaker(std::vector&lt;std::string&gt; words) :words(words) {}\n    std::vector&lt;std::string&gt; words;\n    std::string operator()(){\n        assert(words.size()&gt;0);\n        if(i==words.size()) i=0;\n        // pre- C++17 version:\n        auto word = words[i] + (i+1==words.size()?\"\\n\":\",\");\n        ++i;\n        return word;\n        // Still not possible with C++17:\n        // return words[i++] + (i==words.size()?\"\\n\":\",\");\n\n    }   \n};\n\nint main() {\n    auto spk = Speaker{{\"All\", \"Work\", \"and\", \"no\", \"play\"}};\n    std::cout &lt;&lt; spk() &lt;&lt; spk() &lt;&lt; spk() &lt;&lt; spk() &lt;&lt; spk() ;\n}\n</code></pre>\n<p>With C++14 and before we may (and will) get results such as</p>\n<pre><code>play\nno,and,Work,All,\n</code></pre>\n<p>instead of </p>\n<pre><code>All,work,and,no,play\n</code></pre>\n<p>Note that the above is in effect the same as </p>\n<pre><code>(((((std::cout &lt;&lt; spk()) &lt;&lt; spk()) &lt;&lt; spk()) &lt;&lt; spk()) &lt;&lt; spk()) ;\n</code></pre>\n<p>But still, before C++17 there was no guarantee that the first calls would come first into the stream.</p>\n<p>References: From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf\" rel=\"noreferrer\">accepted proposal</a>:</p>\n<blockquote>\n<p id=\"so_38501587_38501596_4\">Postfix expressions are evaluated from left to right. This includes\n  functions calls and member selection expressions.</p>\n<p id=\"so_38501587_38501596_5\">Assignment expressions are evaluated from right to left. This\n  includes compound assignments.</p>\n<p id=\"so_38501587_38501596_6\">Operands to shift operators are evaluated from left to right. In\n  summary, the following expressions are evaluated in the order a, then\n  b, then c, then d:</p>\n<ol>\n<li>a.b</li>\n<li>a-&gt;b</li>\n<li>a-&gt;*b</li>\n<li>a(b1, b2, b3)</li>\n<li>b @= a</li>\n<li>a[b]</li>\n<li>a &lt;&lt; b</li>\n<li>a &gt;&gt; b</li>\n</ol>\n<p id=\"so_38501587_38501596_7\">Furthermore, we suggest the following additional rule: the order of\n  evaluation of an expression involving an overloaded operator is\n  determined by the order associated with the corresponding built-in\n  operator, not the rules for function calls.</p>\n</blockquote>\n<p><strong>Edit note:</strong> My original answer misinterpreted <code>a(b1, b2, b3)</code>. The order of <code>b1</code>, <code>b2</code>, <code>b3</code> is still unspecified. (thank you @KABoissonneault, all commenters.)</p>\n<p>However, (as @Yakk points out) and this is important: Even when <code>b1</code>, <code>b2</code>, <code>b3</code> are non-trivial expressions, each of them are completely evaluated <em>and tied to the respective function parameter</em> before the other ones are started to be evaluated. The standard states this like this: </p>\n<blockquote>\n<p id=\"so_38501587_38501596_8\">\u00a75.2.2 -  Function call 5.2.2.4:</p>\n<p id=\"so_38501587_38501596_9\">. . .\n  The postfix-expression is sequenced before each expression in the\n  expression-list and any default argument. Every value computation and\n  side effect associated with the initialization of a parameter, and the\n  initialization itself, is sequenced before every value computation and\n  side effect associated with the initialization of any subsequent\n  parameter.</p>\n</blockquote>\n<p>However, one of these new sentences are missing from the <a href=\"https://github.com/cplusplus/draft/blob/master/source/expressions.tex#L1585\" rel=\"noreferrer\">github draft</a>:</p>\n<blockquote>\n<p id=\"so_38501587_38501596_10\">Every value computation and side effect associated with the\n  initialization of a parameter, and the initialization itself, is\n  sequenced before every value computation and side effect associated\n  with the initialization of any subsequent parameter.</p>\n</blockquote>\n<p>The example <em>is</em> there. It solves a decades-old problems (<a href=\"https://herbsutter.com/2016/06/30/trip-report-summer-iso-c-standards-meeting-oulu/\" rel=\"noreferrer\">As explained by Herb Sutter</a>) with exception safety where things like</p>\n<pre><code>f(std::unique_ptr&lt;A&gt; a, std::unique_ptr&lt;B&gt; b);\n\nf(get_raw_a(),get_raw_a()); \n</code></pre>\n<p>would leak if one of the calls <code>get_raw_a()</code> would throw before the other\nraw pointer was tied to it's smart pointer parameter.\n<em>edit: as pointed out by T.C. the example is flawed since unique_ptr construction from raw pointer is explicit, preventing this from compiling.</em></p>\n<p>Also note this classical <a href=\"https://stackoverflow.com/questions/949433/why-are-these-constructs-using-undefined-behavior\">question</a> (tagged <em>C</em>, not <em>C++</em>):</p>\n<blockquote id=\"so_38501587_38501596_11\">\n<pre><code>int x=0;\nx++ + ++x;\n</code></pre>\n</blockquote>\n<p>is still undefined.</p>\n", "OwnerUserId": "1149664", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:26:27.013", "Id": "38501596", "Score": "25", "CreationDate": "2016-07-21T10:22:16.390", "LastActivityDate": "2016-07-22T17:01:02.727"}, "38501587": {"CommentCount": "2", "AcceptedAnswerId": "38501596", "PostTypeId": "1", "LastEditorUserId": "1149664", "CreationDate": "2016-07-21T10:21:52.527", "LastActivityDate": "2017-09-28T15:05:21.073", "LastEditDate": "2016-07-21T12:51:16.317", "ViewCount": "2349", "FavoriteCount": "9", "Title": "What are the evaluation order guarantees introduced by C++17?", "Id": "38501587", "Score": "32", "Body": "<p>What are the implications of the voted in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf\" rel=\"noreferrer\">C++17 evaluation order guarantees (P0145R3)</a> on typical C++ code? (<em>edit: updated the link to the latest version, r3</em>)</p>\n<p>What does it change about things like </p>\n<pre><code>i=1;\nf(i++, i)\n</code></pre>\n<p>and</p>\n<pre><code>std::cout &lt;&lt; f() &lt;&lt; f() &lt;&lt; f() ;\n</code></pre>\n<p>or </p>\n<pre><code>f(g(),h(),j());\n</code></pre>\n", "Tags": "<c++><operator-precedence><c++1z><order-of-evaluation>", "OwnerUserId": "1149664", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_38501587_38501596_10": {"section_id": 3326, "quality": 0.6666666666666666, "length": 14}, "so_38501587_38501596_9": {"section_id": 6182, "quality": 0.5333333333333333, "length": 16}, "so_38501587_46472497_1": {"section_id": 5811, "quality": 1.0, "length": 7}}, "n3337": {"so_38501587_38501596_10": {"section_id": 3196, "quality": 0.6666666666666666, "length": 14}, "so_38501587_38501596_9": {"section_id": 5943, "quality": 0.5333333333333333, "length": 16}, "so_38501587_46472497_1": {"section_id": 5584, "quality": 1.0, "length": 7}}, "n4659": {"so_38501587_38501596_10": {"section_id": 4092, "quality": 0.6666666666666666, "length": 14}, "so_38501587_46472497_0": {"section_id": 7273, "quality": 0.9615384615384616, "length": 25}, "so_38501587_38501596_9": {"section_id": 7492, "quality": 0.5333333333333333, "length": 16}, "so_38501587_46472497_1": {"section_id": 7273, "quality": 1.0, "length": 7}}}, "46472497": {"ParentId": "38501587", "CommentCount": "0", "Body": "<h3>Interleaving is prohibited in C++17</h3>\n<p>In C++14, the following was unsafe:</p>\n<pre><code>void foo(std::unique_ptr&lt;A&gt;, std::unique_ptr&lt;B&gt; );\n\nfoo(std::unique_ptr&lt;A&gt;(new A), std::unique_ptr&lt;B&gt;(new B));\n</code></pre>\n<p>There are four operations that happen here during the function call</p>\n<ol>\n<li><code>new A</code></li>\n<li><code>unique_ptr&lt;A&gt;</code> constructor</li>\n<li><code>new B</code></li>\n<li><code>unique_ptr&lt;B&gt;</code> constructor</li>\n</ol>\n<p>The ordering of these was completely unspecified, and so a perfectly valid ordering is (1), (3), (2), (4). If this ordering was selected and (3) throws, then the memory from (1) leaks - we haven't run (2) yet, which would've prevented the leak.</p>\n<hr/>\n<p>In C++17, the new rules prohibit interleaving. From [intro.execution]:</p>\n<blockquote>\n<p id=\"so_38501587_46472497_0\">For each function invocation F, for every evaluation A that occurs within F and every evaluation B that does not occur within F but is evaluated on the same thread and as part of the same signal handler (if any), either A is sequenced before B or B is sequenced before A.</p>\n</blockquote>\n<p>There is a footnote to that sentence which reads:</p>\n<blockquote>\n<p id=\"so_38501587_46472497_1\">In other words, function executions do not interleave with each other.</p>\n</blockquote>\n<p>This leaves us with two valid orderings: (1), (2), (3), (4) or (3), (4), (1), (2). It is unspecified which ordering is taken, but both of these are safe. All the orderings where (1) (3) both happen before (2) and (4) are now prohibited. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "46472497", "Score": "4", "CreationDate": "2017-09-28T15:05:21.073", "LastActivityDate": "2017-09-28T15:05:21.073"}});