post_cb({"25092726": {"ParentId": "25091602", "CommentCount": "2", "CreationDate": "2014-08-02T07:23:55.630", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "25092726", "Score": "5", "Body": "<p>The strict aliasing rule refers to \u00a73.10 [basic.lval]/p10, which provides that</p>\n<blockquote>\n<p id=\"so_25091602_25092726_0\">If a program attempts to access the stored value of an object through\n  a glvalue of other than one of the following types the behavior is\n  undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including,\n  recursively, an element or non-static data member of a subaggregate or\n  contained union)</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>Thus, accessing an object of type <code>char</code> through a glvalue of type <code>std::array&lt;char, N&gt;</code> does not break this rule, because <code>std::array&lt;char, N&gt;</code> is an aggregate type that includes <code>char</code> as an element of a nonstatic subaggregate data member.</p>\n<p>However, you still can't do anything useful with the resulting reference without invoking undefined behavior because of a different rule - \u00a79.3.1 [class.mfct.non-static]/p2:</p>\n<blockquote>\n<p id=\"so_25091602_25092726_1\">If a non-static member function of a class <code>X</code> is called for an object\n  that is not of type <code>X</code>, or of a type derived from <code>X</code>, the behavior\n  is undefined.</p>\n</blockquote>\n<p>It's also worth noting that no rule in the standard guarantees that <code>sizeof(std::array&lt;T, N&gt;) == sizeof(T) * N</code>. The only things the standard guarantees is that <code>std::array&lt;T, N&gt;</code> is an aggregate type and it can be initialized using a <em>braced-init-list</em> containing up to <code>N</code> <code>T</code>s. The implementation is free to add extra stuff.</p>\n<p>Depending on what <code>do_things</code> needs, you may want to make your function take random access iterators, or simply a pointer. Alternatively, if you want to limit your function to take only <code>std::vector</code> and <code>std::array</code>s, you can write overloads that take const refs to those and call a helper function taking <code>const char *</code> that does the actual work.</p>\n<hr>\n<p>The new version doesn't break any rule I can think of, but it's fairly bad design to require <code>reinterpret_cast</code> to be used pretty much every time your function is called. If you accidentally declared <code>buffer</code> as a <code>std::vector&lt;std::string&gt;</code>, or wrote <code>buffer</code> instead of <code>buffer[0]</code>, the compiler will happily compile your code without a warning, with potentially disastrous results.</p>\n</hr>", "LastActivityDate": "2014-08-02T07:23:55.630"}, "bq_ids": {"n4140": {"so_25091602_25092726_0": {"section_id": 7239, "quality": 1.0, "length": 14}, "so_25091602_25092726_1": {"section_id": 5890, "quality": 1.0, "length": 11}}, "n3337": {"so_25091602_25092726_0": {"section_id": 6983, "quality": 1.0, "length": 14}, "so_25091602_25092726_1": {"section_id": 5661, "quality": 1.0, "length": 11}}, "n4659": {"so_25091602_25092726_0": {"section_id": 8748, "quality": 1.0, "length": 14}, "so_25091602_25092726_1": {"section_id": 7373, "quality": 1.0, "length": 11}}}, "25091602": {"CommentCount": "10", "AcceptedAnswerId": "25092726", "PostTypeId": "1", "LastEditorUserId": "516037", "CreationDate": "2014-08-02T04:13:06.047", "LastActivityDate": "2014-08-02T07:45:17.330", "LastEditDate": "2014-08-02T07:45:17.330", "ViewCount": "270", "FavoriteCount": "1", "Title": "Casting a section of a std::vector<char> to std::array<char, n>, c++11", "Id": "25091602", "Score": "6", "Body": "<p>Does the following code violate strict aliasing or otherwise result in undefined behaviour according to the C++11 standard? Are there better ways to achieve the same functionality?</p>\n<pre><code>void do_things(const std::array&lt;char, 64&gt; &amp;block) {\n   // ...\n}\n\nint main() {\n    std::vector&lt;char&gt; buffer(64);\n    do_things(reinterpret_cast&lt;const std::array&lt;char, 64&gt; &amp;&gt;(buffer[0]));\n}\n</code></pre>\n<h2>tldr: Using <code>const char *</code> is a lot less painful</h2>\n<p>edit: since <code>sizeof(std::array&lt;char, n&gt;)</code> isn't guaranteed to be equal to <code>n</code>, I then propose the following:</p>\n<pre><code>void do_things(const char (&amp;block)[64]) {\n   // ...\n}\n\nint main() {\n    std::vector&lt;char&gt; buffer(64);\n    do_things(reinterpret_cast&lt;char (&amp;)[64]&gt;(buffer[0]));\n}\n</code></pre>\n<p>According my understanding of aliasing this should not result in undefined behaviour and capture the semantics of passing an array of fixed size. Is my understanding correct?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "516037", "AnswerCount": "1"}});