post_cb({"5131691": {"ViewCount": "2159", "Body": "<p>As part of my toilet reading on the C++ Standard ANSI ISO IEC 14882 2003, I came across the following:</p>\n<blockquote>\n<p id=\"so_5131691_5131691_0\">14.3.1.2: A local type, a type with no linkage, an unnamed type or a type\n  compounded from any of these types\n  shall not be used as a\n  template-argument for a template\n  type-parameter.</p>\n</blockquote>\n<p>While I get what a local type and a compound type are, what is an unnamed type?  If a type is unnamed, how could you even attempt to use it in a template anyway, which prompted the standard to verbally exclude it?</p>\n", "AcceptedAnswerId": "5131701", "Title": "What is an unnamed type in C++?", "CreationDate": "2011-02-27T05:52:50.620", "Id": "5131691", "CommentCount": "1", "LastEditDate": "2011-02-27T08:13:43.580", "PostTypeId": "1", "LastEditorUserId": "165520", "LastActivityDate": "2011-02-27T20:17:23.637", "Score": "13", "OwnerUserId": "2063015", "Tags": "<c++><templates><types><standards>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_5131691_5131691_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 7141}}, "n3337": {"so_5131691_5131691_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 6885}}, "n4659": {"so_5131691_5131691_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 8642}}}, "5131730": {"Id": "5131730", "PostTypeId": "2", "Body": "<p>Think about the following code:</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(const T&amp;) {}\n\nstruct {\n  int x;\n} y;\nfoo(y);\n</code></pre>\n<p>That includes an unnamed type.  Note that the rule is different in C++0x.</p>\n", "LastActivityDate": "2011-02-27T06:03:35.303", "CommentCount": "0", "CreationDate": "2011-02-27T06:03:35.303", "ParentId": "5131691", "Score": "1", "OwnerUserId": "319906"}, "5131701": {"Id": "5131701", "PostTypeId": "2", "Body": "<p>\"Unnamed type\" really means \"unnamed enumeration or class type\" [for more information, see the comments to this answer].  An enumeration or class type doesn't have to have a name.  For example:</p>\n<pre><code>struct { int i; } x; // x is of a type with no name\n</code></pre>\n<p>You could try to use an unnamed type as a template argument through argument deduction:</p>\n<pre><code>template &lt;typename T&gt; void f(T) { }\n\nstruct { int i; } x;\nf(x); // would call f&lt;[unnamed-type]&gt;() and is invalid in C++03\n</code></pre>\n<p>Note that this restriction has been lifted in C++0x, so this <em>will</em> be valid (you'll also be able to use local types as type template parameters).  In C++0x, you could also use <code>decltype</code> to \"name\" an unnamed type:</p>\n<pre><code>template &lt;typename T&gt; void g() { }\n\nstruct { int i; } x;\nf&lt;decltype(x)&gt;(); // valid in C++0x (decltype doesn't exist in C++03)\n</code></pre>\n", "LastEditorUserId": "151292", "LastActivityDate": "2011-02-27T20:17:23.637", "Score": "22", "CreationDate": "2011-02-27T05:55:41.463", "ParentId": "5131691", "CommentCount": "22", "LastEditDate": "2011-02-27T20:17:23.637", "OwnerUserId": "151292"}});