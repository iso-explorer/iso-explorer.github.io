post_cb({"8276164": {"Id": "8276164", "PostTypeId": "2", "Body": "<p>Because <code>Empty</code> is a POD-type, you can use <code>memcpy</code> to overwrite its \"representation\", so it better not share it with another C++ object or useful data.</p>\n", "LastActivityDate": "2011-11-26T03:59:49.410", "CommentCount": "0", "CreationDate": "2011-11-26T03:59:49.410", "ParentId": "4623963", "Score": "1", "OwnerUserId": "963864"}, "4623963": {"ViewCount": "1173", "Body": "<p>In C++, most of the optimizations are derived from the as-if rule. That is, as long as the program behaves as-if no optimization had taken place, then they are valid.</p>\n<p>The Empty Base Optimization is one such trick: in some conditions, if the base class is empty (does not have any non-static data member), then the compiler may elide its memory representation.</p>\n<p>Apparently it seems that the standard forbids this optimization on data members, that is even if a data member is empty, it must still take at least one byte worth of place: from n3225, <em>[class]</em></p>\n<blockquote>\n<p id=\"so_4623963_4623963_0\">4 - Complete objects and member subobjects of class type shall have nonzero size.</p>\n</blockquote>\n<p><em>Note: this leads to the use of private inheritance for Policy Design in order to have EBO kick in when appropriate</em></p>\n<p>I was wondering if, using the as-if rule, one could still be able to perform this optimization.</p>\n<hr>\n<p><strong>edit</strong>: following a number of answers and comments, and to make it clearer what I am wondering about.</p>\n<p>First, let me give an example:</p>\n<pre><code>struct Empty {};\n\nstruct Foo { Empty e; int i; };\n</code></pre>\n<p>My question is, why is <code>sizeof(Foo) != sizeof(int)</code> ? In particular, unless you specify some packing, chances are due to alignment issues that Foo will be twice the size of int, which seems ridiculously inflated.</p>\n<p><em>Note: my question is not why is <code>sizeof(Foo) != 0</code>, this is not actually required by EBO either</em></p>\n<p>According to C++, it is because no sub-object may have a zero size. However a base is authorized to have a zero size (EBO) therefore:</p>\n<pre><code>struct Bar: Empty { int i; };\n</code></pre>\n<p>is likely (thanks to EBO) to obey <code>sizeof(Bar) == sizeof(int)</code>.</p>\n<p><em>Steve Jessop</em> seems to be of an opinion that it is so that no two sub-objects would have the same address. I thought about it, however it doesn't actually prevent the optimization in most cases:</p>\n<p>If you have \"unused\" memory, then it is trivial:</p>\n<pre><code>struct UnusedPadding { Empty e; Empty f; double d; int i; };\n// chances are that the layout will leave some memory after int\n</code></pre>\n<p>But in fact, it's even \"worse\" than that, because <code>Empty</code> space is never written to (you'd better not if EBO kicks in...) and therefore you could actually place it at an occupied place that is not the address of another object:</p>\n<pre><code>struct Virtual { virtual ~Virtual() {} Empty e; Empty f; int i; };\n// most compilers will reserve some space for a virtual pointer!\n</code></pre>\n<p>Or, even in our original case:</p>\n<pre><code>struct Foo { Empty e; int i; }; // deja vu!\n</code></pre>\n<p>One could have <code>(char*)foo.e == (char*)foo.i + 1</code> if all we wanted were different address.</p>\n</hr>", "AcceptedAnswerId": "4624128", "Title": "Empty Data Member Optimization: would it be possible?", "CreationDate": "2011-01-07T09:08:08.137", "Id": "4623963", "CommentCount": "6", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2011-01-07T10:38:42.917", "LastEditorUserId": "147192", "LastActivityDate": "2011-11-26T03:59:49.410", "Score": "13", "OwnerUserId": "147192", "Tags": "<c++><compiler-optimization>", "AnswerCount": "4"}, "4624128": {"Id": "4624128", "PostTypeId": "2", "Body": "<p>Under the as-if rule:</p>\n<pre><code>struct A {\n    EmptyThing x;\n    int y;\n};\n\nA a;\nassert((void*)&amp;(a.x) != (void*)&amp;(a.y));\n</code></pre>\n<p>The assert must not be triggered. So I don't see any benefit in secretly making <code>x</code> have size 0, when you'd just need to add padding to the structure anyway.</p>\n<p>I suppose in theory a compiler could track whether pointers might be taken to the members, and make the optimization only if they definitely aren't. This would have limited use, since there'd be two different versions of the struct with different layouts: one for the optimized case and one for general code.</p>\n<p>But for example if you create an instance of A on the stack, and do something with it that is entirely inlined (or otherwise visible to the optimizer), yes, parts of the struct could be completely omitted. This isn't specific to empty objects, though - an empty object is just a special case of an object whose storage isn't accessed, and therefore could in some situations never be allocated at all.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2011-01-07T09:38:45.770", "Score": "5", "CreationDate": "2011-01-07T09:33:42.400", "ParentId": "4623963", "CommentCount": "6", "OwnerUserId": "13005", "LastEditDate": "2011-01-07T09:38:45.770"}, "4624313": {"Id": "4624313", "PostTypeId": "2", "Body": "<p>Given <code>struct Empty { };</code> consider what happens if <code>sizeof(Empty) == 0</code>.  Generic code that allocates heap for Empty objects could easily behave differently, as - for example - a <code>realloc(p, n * sizeof(T))</code>, where <code>T</code> is <code>Empty</code>, is then equivalent to <code>free(p)</code>.  If <code>sizeof(Empty) != 0</code> then things like memset/memcpy etc. would try to work on memory regions that weren't in use by the <code>Empty</code> objects.  So, the compiler would need to stitch up things like <code>sizeof(Empty)</code> on the basis of the eventual usage of the value - that sounds close to impossible to me.</p>\n<p>Separately, under current C++ rules the assurance that each member has a distinct address means you can use those addresses to encode some state about those fields - e.g. a textual field name, whether some member function of the field object should be visited etc..  If addresses suddenly coincide, any existing code reliant on these keys could break.</p>\n", "LastEditorUserId": "410767", "LastActivityDate": "2011-01-07T11:08:20.080", "Score": "-1", "CreationDate": "2011-01-07T09:55:40.440", "ParentId": "4623963", "CommentCount": "7", "OwnerUserId": "410767", "LastEditDate": "2011-01-07T11:08:20.080"}, "bq_ids": {"n4140": {"so_4623963_4623963_0": {"length": 9, "quality": 1.0, "section_id": 5848}}, "n3337": {"so_4623963_4623963_0": {"length": 9, "quality": 1.0, "section_id": 5618}}, "n4659": {"so_4623963_4623963_0": {"length": 9, "quality": 1.0, "section_id": 7327}}}, "4624192": {"Id": "4624192", "PostTypeId": "2", "Body": "<p>C++ for technical reasons mandates that empty classes should have non-zero size.<br>\nThis is to enforce that distinct objects have distinct memory addresses. So compilers silently insert a byte into \"empty\" objects.<br>\nThis constraint does not apply to base class parts of derived classes as they are not free-standing.</br></br></p>\n", "LastActivityDate": "2011-01-07T09:40:41.200", "CommentCount": "0", "CreationDate": "2011-01-07T09:40:41.200", "ParentId": "4623963", "Score": "2", "OwnerUserId": "384706"}});