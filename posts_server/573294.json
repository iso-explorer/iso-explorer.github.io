post_cb({"34749431": {"ParentId": "573294", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>One use of reinterpret_cast is if you want to apply bitwise operations to (IEEE 754) floats. One example of this was the Fast Inverse Square-Root trick:</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Fast_inverse_square_root#Overview_of_the_code\" rel=\"noreferrer\">https://en.wikipedia.org/wiki/Fast_inverse_square_root#Overview_of_the_code</a></p>\n<p>It treats the binary representation of the float as an integer, shifts it right and subtracts it from a constant, thereby halving and negating the exponent. After converting back to a float, it's subjected to a Newton-Raphson iteration to make this approximation more exact: </p>\n<pre><code>float Q_rsqrt( float number )\n{\n    long i;\n    float x2, y;\n    const float threehalfs = 1.5F;\n\n    x2 = number * 0.5F;\n    y  = number;\n    i  = * ( long * ) &amp;y;                       // evil floating point bit level hacking\n    i  = 0x5f3759df - ( i &gt;&gt; 1 );               // what the deuce? \n    y  = * ( float * ) &amp;i;\n    y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration\n//  y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed\n\n    return y;\n}\n</code></pre>\n<p>This was originally written in C, so uses C casts, but the analogous C++ cast is the reinterpret_cast.</p>\n", "OwnerUserId": "5130486", "LastEditorUserId": "5130486", "LastEditDate": "2016-07-16T12:32:13.473", "Id": "34749431", "Score": "9", "CreationDate": "2016-01-12T16:54:06.553", "LastActivityDate": "2016-07-16T12:32:13.473"}, "43273907": {"ParentId": "573294", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>The short answer:</strong>\nIf you don't know what <code>reinterpret_cast</code> stands for, don't use it. If you will need it in the future, you will know.</p>\n<p><strong>Full answer:</strong></p>\n<p>Let's consider basic number types.</p>\n<p>When you convert for example <code>int(12)</code> to <code>unsigned float (12.0f)</code> your processor needs to invoke some calculations as both numbers has different bit representation. This is what <strong><code>static_cast</code></strong> stands for.</p>\n<p>On the other hand, when you call <strong><code>reinterpret_cast</code></strong> the CPU does not invoke any calculations. It just treats a set of bits in the memory like if it had another type. So when you convert <code>int*</code> to <code>float*</code> with this keyword, the new value (after pointer dereferecing) has nothing to do with the old value in mathematical meaning.</p>\n<p><strong><em>Example:</em></strong> It is true that <code>reinterpret_cast</code> is not portable because of one reason - byte order (endianness). But this is often surprisingly the best reason to use it. Let's imagine the example: you have to read binary 32bit number from file, and you know it is big endian. Your code has to be generic and works properly on big endian (e.g. ARM) and little endian (e.g. x86) systems. So you have to check the byte order. It is well-known on compile time so you can write <code>constexpr</code> function:</p>\n<pre><code>constexpr bool is_little_endian() {\n  unsigned short x=0x0001;\n  auto p = reinterpret_cast&lt;unsigned char*&gt;(&amp;x);\n  return *p != 0;\n}\n</code></pre>\n<p><strong><em>Explanation:</em></strong> the binary representation of <code>x</code> in memory could be <code>0000'0000'0000'0001</code> (big) or <code>0000'0001'0000'0000</code> (little endian). After reinterpret-casting the byte under <code>p</code> pointer could be respectively <code>0000'0000</code> or <code>0000'0001</code>. If you use static-casting, it will always be <code>0000'0001</code>, no matter what endianness is being used.</p>\n", "OwnerUserId": "4131673", "LastEditorUserId": "4131673", "LastEditDate": "2017-08-10T08:00:56.493", "Id": "43273907", "Score": "16", "CreationDate": "2017-04-07T08:58:07.223", "LastActivityDate": "2017-08-10T08:00:56.493"}, "573319": {"CommentCount": "0", "CreationDate": "2009-02-21T16:31:02.333", "LastEditorUserId": "6850771", "LastActivityDate": "2017-03-13T01:21:54.967", "ParentId": "573294", "LastEditDate": "2017-03-13T01:21:54.967", "OwnerDisplayName": "dirkgently", "PostTypeId": "2", "Id": "573319", "Score": "-13", "Body": "<p>Read the <a href=\"http://www.parashift.com/c++-faq-lite/mixing-c-and-cpp.html\" rel=\"nofollow noreferrer\">FAQ</a>! Holding C++ data in C can be risky.</p>\n<p>In C++, a pointer to an object can be converted to <code>void *</code> without any casts. But it's not true the other way round. You'd need a <code>static_cast</code> to get the original pointer back.</p>\n", "OwnerUserId": "66692"}, "573345": {"CommentCount": "10", "CreationDate": "2009-02-21T16:42:12.010", "OwnerDisplayName": "jalf", "LastActivityDate": "2011-11-22T17:46:42.750", "ParentId": "573294", "LastEditDate": "2011-11-22T17:46:42.750", "LastEditorDisplayName": "user142019", "PostTypeId": "2", "Id": "573345", "Score": "320", "Body": "<p>The C++ standard guarantees the following:</p>\n<p><code>static_cast</code>ing a pointer to and from <code>void*</code> preserves the address. That is, in the following, a, b and c all point to the same address:</p>\n<pre><code>int* a = new int();\nvoid* b = static_cast&lt;void*&gt;(a);\nint* c = static_cast&lt;int*&gt;(b);\n</code></pre>\n<p><code>reinterpret_cast</code> only guarantees that if you cast a pointer to a different type, <em>and then <code>reinterpret_cast</code> it back to the original type</em>, you get the original value. So in the following:</p>\n<pre><code>int* a = new int();\nvoid* b = reinterpret_cast&lt;void*&gt;(a);\nint* c = reinterpret_cast&lt;int*&gt;(b);\n</code></pre>\n<p>a and c contain the same value, but the value of b is unspecified. (in practice it will typically contain the same address as a and c, but that's not specified in the standard, and it may not be true on machines with more complex memory systems.)</p>\n<p>For casting to and from void*, <code>static_cast</code> should be preferred.</p>\n", "OwnerUserId": "33213"}, "42415406": {"ParentId": "573294", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>First you have some data in a specific type like int here:</p>\n<pre><code>int x = 0x7fffffff://==nan in binary representation\n</code></pre>\n<p>Then you want to access the same variable as an other type like float:\nYou can decide between</p>\n<pre><code>float y = reinterpret_cast&lt;float&amp;&gt;(x);\n\n//this could only be used in cpp, looks like a function with template-parameters\n</code></pre>\n<p>or</p>\n<pre><code>float y = *(float*)&amp;(x);\n\n//this could be used in c and cpp\n</code></pre>\n<p>BRIEF: it means that the same memory is used as a different type. So you could convert binary representations of floats as int type like above to floats. 0x80000000 is -0 for example (the mantissa and exponent are null but the sign, the msb, is one. This also works for doubles and long doubles.</p>\n<p>OPTIMIZE: I think reinterpret_cast would be optimized in many compilers, while the c-casting is made by pointerarithmetic (the value must be copied to the memory, cause pointers couldn't point to cpu- registers).</p>\n<p>NOTE: In both cases you should save the casted value in a variable before cast! This macro could help:</p>\n<pre><code>#define asvar(x) ({decltype(x) __tmp__ = (x); __tmp__; })\n</code></pre>\n", "OwnerUserId": "7610883", "LastEditorUserId": "7610883", "LastEditDate": "2017-02-23T19:51:47.530", "Id": "42415406", "Score": "0", "CreationDate": "2017-02-23T12:10:27.070", "LastActivityDate": "2017-02-23T19:51:47.530"}, "bq_ids": {"n4140": {"so_573294_573334_0": {"section_id": 6039, "quality": 0.7692307692307693, "length": 20}}, "n3337": {"so_573294_573334_0": {"section_id": 5807, "quality": 0.7692307692307693, "length": 20}}, "n4659": {"so_573294_573334_0": {"section_id": 7548, "quality": 0.6923076923076923, "length": 18}}}, "573334": {"CommentCount": "9", "CreationDate": "2009-02-21T16:38:15.530", "LastEditorUserId": "66620", "LastActivityDate": "2009-02-21T16:52:25.903", "ParentId": "573294", "PostTypeId": "2", "LastEditorDisplayName": "flodin", "LastEditDate": "2009-02-21T16:52:25.903", "Id": "573334", "Score": "16", "Body": "<p>The meaning of <code>reinterpret_cast</code> is not defined by the C++ standard. Hence, in theory a <code>reinterpret_cast</code> could crash your program. In practice compilers try to do what you expect, which is to interpret the bits of what you are passing in as if they were the type you are casting to. If you know what the compilers you are going to use do with <code>reinterpret_cast</code>  you can use it, but to say that it is <em>portable</em> would be lying.</p>\n<p>For the case you describe, and pretty much any case where you might consider <code>reinterpret_cast</code>, you can use <code>static_cast</code> or some other alternative instead. Among other things the standard has this to say about what you can expect of <code>static_cast</code> (\u00a75.2.9):</p>\n<blockquote>\n<p id=\"so_573294_573334_0\">An rvalue of type \u201cpointer to cv void\u201d can be explicitly converted to a pointer to object type. A value of type pointer to object converted to \u201cpointer to cv void\u201d and back to the original pointer type will have its original value.</p>\n</blockquote>\n<p>So for your use case, it seems fairly clear that the standardization committee intended for you to use <code>static_cast</code>.</p>\n", "OwnerUserId": "66620", "OwnerDisplayName": "flodin"}, "573294": {"CommentCount": "2", "AcceptedAnswerId": "573345", "PostTypeId": "1", "LastEditorUserId": "6850771", "LastEditorDisplayName": "Head Geek", "CreationDate": "2009-02-21T16:12:39.960", "LastActivityDate": "2017-08-10T08:00:56.493", "AnswerCount": "10", "LastEditDate": "2017-03-13T01:22:26.403", "ViewCount": "235935", "FavoriteCount": "157", "Title": "When to use reinterpret_cast?", "Id": "573294", "Score": "320", "Body": "<p>I am little confused with the applicability of <code>reinterpret_cast</code> vs <code>static_cast</code>. From what I have read the general rules are to use static cast when the types can be interpreted at compile time hence the word <code>static</code>. This is the cast the C++ compiler uses internally for implicit casts also.</p>\n<p><code>reinterpret_cast</code>s are applicable in two scenarios, convert integer types to pointer types and vice versa or to convert one pointer type to another. The general idea I get is this is unportable and should be avoided.</p>\n<p>Where I am a little confused is one usage which I need, I am calling C++ from C and the C code needs to hold on to the C++ object so basically it holds a <code>void*</code>. What cast should be used to convert between the <code>void *</code> and the Class type?</p>\n<p>I have seen usage of both <code>static_cast</code> and <code>reinterpret_cast</code>? Though from what I have been reading it appears <code>static</code> is better as the cast can happen at compile time? Though it says to use <code>reinterpret_cast</code> to convert from one pointer type to another? </p>\n", "Tags": "<c++><casting>", "OwnerUserId": "1984928", "OwnerDisplayName": "HeretoLearn"}, "40523340": {"ParentId": "573294", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Quick answer: use <code>static_cast</code> if it compiles, otherwise resort to <code>reinterpret_cast</code>.</p>\n", "OwnerUserId": "403342", "LastEditorUserId": "6850771", "LastEditDate": "2017-03-13T01:20:52.063", "Id": "40523340", "Score": "-3", "CreationDate": "2016-11-10T08:49:01.823", "LastActivityDate": "2017-03-13T01:20:52.063"}, "573574": {"CommentCount": "5", "CreationDate": "2009-02-21T19:06:14.473", "LastEditorUserId": "10559", "LastActivityDate": "2014-12-02T21:16:06.120", "ParentId": "573294", "LastEditDate": "2014-12-02T21:16:06.120", "OwnerDisplayName": "jwfearn", "PostTypeId": "2", "Id": "573574", "Score": "113", "Body": "<p>One case when <code>reinterpret_cast</code> is necessary is when interfacing with opaque data types.  This occurs frequently in vendor APIs over which the programmer has no control.  Here's a contrived example where a vendor provides an API for storing and retrieving arbitrary global data:</p>\n<pre><code>// vendor.hpp\ntypedef struct _Opaque * VendorGlobalUserData;\nvoid VendorSetUserData(VendorGlobalUserData p);\nVendorGlobalUserData VendorGetUserData();\n</code></pre>\n<p>To use this API, the programmer must cast their data to <code>VendorGlobalUserData</code> and back again.  <code>static_cast</code> won't work, one must use <code>reinterpret_cast</code>:</p>\n<pre><code>// main.cpp\n#include \"vendor.hpp\"\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct MyUserData {\n    MyUserData() : m(42) {}\n    int m;\n};\n\nint main() {\n    MyUserData u;\n\n        // store global data\n    VendorGlobalUserData d1;\n//  d1 = &amp;u;                                          // compile error\n//  d1 = static_cast&lt;VendorGlobalUserData&gt;(&amp;u);       // compile error\n    d1 = reinterpret_cast&lt;VendorGlobalUserData&gt;(&amp;u);  // ok\n    VendorSetUserData(d1);\n\n        // do other stuff...\n\n        // retrieve global data\n    VendorGlobalUserData d2 = VendorGetUserData();\n    MyUserData * p = 0;\n//  p = d2;                                           // compile error\n//  p = static_cast&lt;MyUserData *&gt;(d2);                // compile error\n    p = reinterpret_cast&lt;MyUserData *&gt;(d2);           // ok\n\n    if (p) { cout &lt;&lt; p-&gt;m &lt;&lt; endl; }\n    return 0;\n}\n</code></pre>\n<p>Below is a contrived implementation of the sample API:</p>\n<pre><code>// vendor.cpp\nstatic VendorGlobalUserData g = 0;\nvoid VendorSetUserData(VendorGlobalUserData p) { g = p; }\nVendorGlobalUserData VendorGetUserData() { return g; }\n</code></pre>\n", "OwnerUserId": "10559"}, "14401188": {"ParentId": "573294", "PostTypeId": "2", "CommentCount": "5", "Body": "<pre><code>template &lt;class outType, class inType&gt;\noutType safe_cast(inType pointer)\n{\n    void* temp = static_cast&lt;void*&gt;(pointer);\n    return static_cast&lt;outType&gt;(temp);\n}\n</code></pre>\n<p>I tried to conclude and wrote a simple safe cast using templates.\nNote that this solution doesn't guarantee to cast pointers on a functions.</p>\n", "OwnerUserId": "857684", "LastEditorUserId": "10559", "LastEditDate": "2013-06-27T15:52:14.880", "Id": "14401188", "Score": "0", "CreationDate": "2013-01-18T14:38:38.570", "LastActivityDate": "2013-06-27T15:52:14.880"}, "26636676": {"ParentId": "573294", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You could use reinterprete_cast to check inheritance at compile time.<br>\nLook here:\n<a href=\"https://stackoverflow.com/questions/26649987/using-reinterpret-cast-to-check-inheritance-at-compile-time\">Using reinterpret_cast to check inheritance at compile time</a></br></p>\n", "OwnerUserId": "3334339", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:34:50.693", "Id": "26636676", "Score": "2", "CreationDate": "2014-10-29T17:12:47.023", "LastActivityDate": "2014-10-30T10:02:11.513"}});