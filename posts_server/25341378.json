post_cb({"25341378": {"CommentCount": "2", "ViewCount": "350", "PostTypeId": "1", "LastEditorUserId": "417024", "CreationDate": "2014-08-16T14:58:43.630", "LastActivityDate": "2014-10-09T22:52:48.047", "LastEditDate": "2014-08-18T09:00:51.460", "AcceptedAnswerId": "25341458", "FavoriteCount": "1", "Title": "Is it possible to ignore the trailing return type feature of c++11 in favor of the function return type deduction feature of c++14?", "Id": "25341378", "Score": "12", "Body": "<h2>When I skip the return type of an expression</h2>\n<p>The following code in <strong>C++11</strong>:</p>\n<pre><code>auto function(X x, Y y) -&gt; decltype(x + y)\n{\n    return x + y;\n}\n</code></pre>\n<p>Is equal to the following code in <strong>C++14</strong>:</p>\n<pre><code>decltype(auto) function(X x, Y y)\n{\n    return x + y;\n}\n</code></pre>\n<p>But additionally it is possible to deduce the return type without <code>decltype</code> rules in <strong>C++14</strong>:</p>\n<pre><code>auto function()\n{\n    return 0;\n}\n</code></pre>\n<h2>When I know what the return type is exactly</h2>\n<p>The following code in <strong>C++11</strong>:</p>\n<pre><code>auto function() -&gt; int\n{\n    return 0;\n}\n</code></pre>\n<p>Is equal to the following code in <strong>C++03</strong>:</p>\n<pre><code>int function()\n{\n    return 0;\n}\n</code></pre>\n<h2>A strange example that should never happen</h2>\n<p>The following code in <strong>C++11</strong>:</p>\n<pre><code>auto function(X x, Y y) -&gt; decltype(x * y)\n{\n    return x; // Yeah! return x with the type of x * y expression!\n}\n</code></pre>\n<p>Is equal to the following code in <strong>C++14</strong>:</p>\n<pre><code>decltype(auto) function(X x, Y y)\n{\n    return static_cast&lt;decltype(x * y)&gt;(x);\n}\n</code></pre>\n<p>Please correct me, if the above code is wrong and does not work as expected.</p>\n<p><strong>EDIT</strong>, <em>According to the comment (Yakk): They are not really equal, the first one (<strong>C++11</strong> example) is an implicit cast while the second one (the <code>static_cast</code> of <strong>C++14</strong> example) is an explicit cast.</em></p>\n<h2>Conclusion</h2>\n<p>As you can see, I can do everything without using the <em>alternative function syntax</em> feature of C++11. Am I correct? Can I completely forget about it without getting any technical problem?</p>\n<p>In general, the following syntax can be avoided:</p>\n<pre><code>auto function() -&gt; TYPE\n{\n    return 0;\n}\n</code></pre>\n<p>In favor of the following syntax:</p>\n<pre><code>TYPE function() // TYPE can be: auto, decltype(auto), or ...\n{\n    return 0;\n}\n</code></pre>\n<p>Did I forget any usage of the <em>trailing return type</em> feature of C++11 that is not possible with the <em>function return type deduction</em> feature of C++14?</p>\n", "Tags": "<c++11><c++14><trailing-return-type><return-type-deduction>", "OwnerUserId": "417024", "AnswerCount": "1"}, "25341458": {"ParentId": "25341378", "LastEditDate": "2014-10-09T22:52:48.047", "CommentCount": "3", "CreationDate": "2014-08-16T15:06:59.390", "Score": "15", "LastEditorUserId": "3204551", "PostTypeId": "2", "Id": "25341458", "OwnerUserId": "3204551", "Body": "<p>There are three important differences between a function using automatic-return-type-deduction and one with an explicit return-type (even if that is computed):</p>\n<ol>\n<li><p>You cannot do SFINAE on the computability of the return-type if you do not explicitly specify it: You get a hard error instead. Why? Because SFINAE only works with the declaration, not the definition of functions (SFINAE: (template-argument) substitution-failure is not an error).</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/fa14fbaa17e62543\" rel=\"nofollow\">automatic-return-type-deduction</a>, no SFINAE<br>\n<a href=\"http://coliru.stacked-crooked.com/a/99e8747a42bde63e\" rel=\"nofollow\">SFINAE</a>, but no automatic return-type deduction</br></p>\n<pre><code>#include &lt;iostream&gt;\nint doit(int x, ...) { return x; }\ntemplate&lt;class X, class Y&gt; auto doit(X x, Y y)\n#ifdef TRAILING_RETURN_TYPE\n    -&gt; decltype(doit(x) + doit(y))\n#endif\n{ return doit(x) + doit(y); }\nint main() {\n    std::cout &lt;&lt; doit(1, nullptr) &lt;&lt; std::endl;\n}\n</code></pre></li>\n<li><p>At the moment, you cannot forward-declare a function with its actual return-type, if the definition uses automatic return-type-deduction, nor can it be virtual. (Explicit rule)</p>\n<blockquote>\n<h3>7.1.6.4 auto specifier <code>[dcl.spec.auto]</code></h3>\n<p id=\"so_25341378_25341458_0\">13 Redeclarations or specializations of a function or function template with a declared return type that uses a placeholder type shall also use that placeholder, not a deduced type.<br>\n  14 A function declared with a return type that uses a placeholder type shall not be virtual (10.3).</br></p>\n</blockquote></li>\n<li><p>Only functions with automatic return-type deduction can return a lambda, as there is no other way to get its type.</p>\n<pre><code>auto foo() { return [] {}; }\n</code></pre></li>\n</ol>\n<p>Link to the proposal, which was incorporated into the draft for C++1y:<br>\n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3638.html\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3638.html</a></br></p>\n", "LastActivityDate": "2014-10-09T22:52:48.047"}, "bq_ids": {"n4140": {"so_25341378_25341458_0": {"section_id": 5457, "quality": 0.64, "length": 16}}, "n4659": {"so_25341378_25341458_0": {"section_id": 6883, "quality": 0.64, "length": 16}}}});