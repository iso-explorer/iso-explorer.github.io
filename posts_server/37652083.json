post_cb({"bq_ids": {"n4140": {"so_37652083_37652168_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 7114}, "so_37652083_37652168_4": {"length": 5, "quality": 1.0, "section_id": 7114}, "so_37652083_37652168_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 5846}, "so_37652083_37652168_2": {"length": 8, "quality": 1.0, "section_id": 7114}}, "n3337": {"so_37652083_37652168_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 6858}, "so_37652083_37652168_4": {"length": 5, "quality": 1.0, "section_id": 6858}, "so_37652083_37652168_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 5616}, "so_37652083_37652168_2": {"length": 8, "quality": 1.0, "section_id": 6858}}, "n4659": {"so_37652083_37652168_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 8615}, "so_37652083_37652168_4": {"length": 5, "quality": 1.0, "section_id": 8615}, "so_37652083_37652168_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 7325}, "so_37652083_37652168_2": {"length": 8, "quality": 1.0, "section_id": 8615}}}, "37652116": {"Id": "37652116", "PostTypeId": "2", "Body": "<p>This is valid in all contexts, not just <code>decltype</code>. A class contains its own name as the <em>injected class name.</em> So within a class <code>A::B::M</code>, the name <code>M</code> is injected to refer to the class <code>A::B::M</code>. This means that you can then use <code>M::M::M::some_member</code> to refer to members of that class, if you really want to.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/2397cc2dd5ea3b69\" rel=\"nofollow\">[Live example]</a></p>\n<p>Note that when referring just to the class name itself (e.g. <code>M::M::M</code>), the situation is slightly different. If such a reference occurs in a place where a reference to a function could also potentially be correct, the syntax is taken to refer to the constructor instead. However, in type-only contexts, even such reference is valid. Example:</p>\n<pre><code>M::M::M m;  // illegal, M::M interpreted as reference to constructor\n\nstruct D : public M::M::M  // legal, a function could not be references here, so M::M::M means M\n{};\n</code></pre>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2016-06-06T07:55:55.173", "Score": "10", "CreationDate": "2016-06-06T07:49:07.353", "ParentId": "37652083", "CommentCount": "0", "LastEditDate": "2016-06-06T07:55:55.173", "OwnerUserId": "1782465"}, "37652083": {"ViewCount": "263", "Body": "<p>I noticed by accident that this code compiles and works correctly:</p>\n<pre><code>struct M { int some_int; };\nstatic_assert(std::is_same&lt;\n                   decltype(M::M::M::M::some_int) /* &lt;- this */,\n                   int&gt;::value, \"Types must be int\");\n</code></pre>\n<p>Why is this correct (<code>decltype(M::M::M::M::some_int) &lt;=&gt; decltype(M::some_int)</code>)?</p>\n<p>What other constructs one can use this pattern with <code>class::class::...::member</code>?</p>\n<p>Compiler: Microsoft (R) C/C++ Optimizing Compiler Version 19.00.23824.1 for x86</p>\n", "AcceptedAnswerId": "37652168", "Title": "Why is decltype(class::class::class::member) valid", "CreationDate": "2016-06-06T07:46:21.473", "LastActivityDate": "2016-06-06T07:56:14.277", "CommentCount": "1", "LastEditDate": "2016-06-06T07:50:41.307", "PostTypeId": "1", "Tags": "<c++><c++11><decltype>", "Id": "37652083", "AnswerCount": "2", "Score": "8", "OwnerUserId": "66681", "ClosedDate": "2016-06-06T07:57:36.347", "LastEditorUserId": "66681"}, "37652168": {"Id": "37652168", "PostTypeId": "2", "Body": "<p>This works because of the <em>injected-class-name</em>:</p>\n<blockquote>\n<p id=\"so_37652083_37652168_0\"><code>(N3337) [class]/2:</code>A class-name is inserted into the scope in which it is declared immediately after the class-name is seen.\n  The class-name is also inserted into the scope of the class itself; this is known as the injected-class-name.\n  For purposes of access checking, the injected-class-name is treated as if it were a public member name. [...]</p>\n</blockquote>\n<p>So you can arbitrarily nest these, and they'll work with derived types as well:</p>\n<pre><code>struct A { using type = int; };\nstruct B : public A {};\n\nusing foo = B::B::B::A::A::A::type;\n</code></pre>\n<p>Note that in the case of <code>A[::A]*::A</code>, the injected-class-name can be considered to name the constructor instead: </p>\n<blockquote>\n<p id=\"so_37652083_37652168_1\"><code>[class.qual]/2:</code> In a lookup in which the constructor is an acceptable lookup result and the nested-name-specifier nominates\n  a class <code>C</code>:</p>\n<p id=\"so_37652083_37652168_2\">\u2014 if the name specified after the nested-name-specifier, when looked up in <code>C</code>, is the injected-class-name\n  of <code>C</code> (Clause 9), or</p>\n<p id=\"so_37652083_37652168_3\">\u2014 [...]</p>\n<p id=\"so_37652083_37652168_4\">the name is instead considered to name the constructor of class <code>C</code>.</p>\n</blockquote>\n", "LastActivityDate": "2016-06-06T07:52:06.073", "Score": "9", "CreationDate": "2016-06-06T07:52:06.073", "ParentId": "37652083", "CommentCount": "1", "OwnerUserId": "496161"}});