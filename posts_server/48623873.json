post_cb({"bq_ids": {"n4140": {"so_48623873_48629107_0": {"length": 20, "quality": 0.6451612903225806, "section_id": 5421}, "so_48623873_48623873_1": {"length": 4, "quality": 0.8, "section_id": 6185}}, "n3337": {"so_48623873_48629107_0": {"length": 16, "quality": 0.5161290322580645, "section_id": 5216}}, "n4659": {"so_48623873_48629107_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 6843}, "so_48623873_48623873_1": {"length": 4, "quality": 0.8, "section_id": 7687}}}, "48624028": {"Id": "48624028", "PostTypeId": "2", "Body": "<p>Your functions are <code>constexpr</code>, this means that they will be evaluated as <code>constexpr</code> (compile-time) <strong>when the context allows it</strong>. In your usage, the context isn't <code>constexpr</code> so it <strong>defers the calculation to runtime</strong>. <a href=\"https://godbolt.org/g/Jo5GyL\" rel=\"nofollow noreferrer\">https://godbolt.org/g/Jo5GyL</a></p>\n<pre><code>int x = div(10, 0); // x isn't a constexpr var, calculation in runtime\nconstexpr int y = div(10, 0); // y is constexpr, calculation in compile-time + error\n</code></pre>\n<p>On your second example, the division part is well-defined: <code>x / 0</code>. That's why the compiler knows that this will fail and reports the error <strong>even if the function isn't invoked at compile-time</strong> (again, lack of <code>constexpr</code> in var <code>y</code>).</p>\n", "LastEditorUserId": "6314639", "LastActivityDate": "2018-02-05T14:01:56.783", "Score": "-1", "CreationDate": "2018-02-05T13:46:51.623", "ParentId": "48623873", "CommentCount": "0", "OwnerUserId": "6314639", "LastEditDate": "2018-02-05T14:01:56.783"}, "48623873": {"ViewCount": "91", "Body": "<p>Consider the below code snippets</p>\n<pre><code>constexpr int divide( int x, int y)\n{\n    return (x/y);\n}\n\nconstexpr int div_by_zero( int x)\n{\n    return (x/0);\n}\n</code></pre>\n<p><strong>Case 1 :</strong></p>\n<pre><code>int x = divide(10,0);\n</code></pre>\n<p>This compiles successfully (with both gcc and clang) but produces the below runtime error.</p>\n<blockquote>\n<p id=\"so_48623873_48623873_0\">Floating point exception (core dumped)</p>\n</blockquote>\n<p><strong>Case 2 :</strong></p>\n<pre><code>int y = div_by_zero(10);\n</code></pre>\n<p>This gives a Compiler error,</p>\n<blockquote>\n<p id=\"so_48623873_48623873_1\">(g++ -std=c++17) division by zero is not a constant expression</p>\n<p id=\"so_48623873_48623873_2\">NOTE : clang does not throw error even in this case</p>\n</blockquote>\n<p>And also Compiler warnings:</p>\n<blockquote>\n<p id=\"so_48623873_48623873_3\">(clang++ -std=c++17), division by zero is undefined\n  [-Wdivision-by-zero]</p>\n<p id=\"so_48623873_48623873_4\">(g++ -std=c++17), division by zero [-Wdiv-by-zero]</p>\n</blockquote>\n<p>For Case 1, why the compiler does not complain even when the value for second argument is known(i.e. zero) during the compile time ?</p>\n<p>Example <a href=\"https://godbolt.org/g/9hdi9b\" rel=\"nofollow noreferrer\">here</a>\ndivide(10,2); generates below assembly code</p>\n<pre><code>  mov rbp, rsp\n  sub rsp, 16\n  mov DWORD PTR [rbp-4], 5\n</code></pre>\n<p>divide(10,0); generates below assembly code</p>\n<pre><code>  mov esi, 0\n  mov edi, 10\n  call divide(int, int)\n</code></pre>\n<p>There is call to divide() when the input is zero. The same is evaluated at compile time when non-zero values are the input to the function. If a compiler is able to find out and call the method instead of evaluating, why an error can't be thrown ?</p>\n", "Title": "Runtime errors with constexpr", "CreationDate": "2018-02-05T13:38:25.990", "LastActivityDate": "2018-02-05T18:25:52.633", "CommentCount": "0", "LastEditDate": "2018-02-05T18:25:52.633", "PostTypeId": "1", "LastEditorUserId": "2069064", "Id": "48623873", "Score": "1", "OwnerUserId": "1382284", "Tags": "<c++><c++11><c++14><constexpr><c++17>", "AnswerCount": "2"}, "48629107": {"Id": "48629107", "PostTypeId": "2", "Body": "<p>The fact that <code>divide(10, 0)</code> doesn't warn is a Quality of Implementation (QoI) issue. You could file a bug with gcc about it. But note that such arbitrary constant tracking isn't always feasible.</p>\n<p>But the fact that <code>div_by_zero(10)</code> doesn't compile is slightly different. From <a href=\"http://eel.is/c++draft/dcl.constexpr#5\" rel=\"nofollow noreferrer\">[dcl.constexpr]/5</a>:</p>\n<blockquote>\n<p id=\"so_48623873_48629107_0\">For a constexpr function or constexpr constructor that is neither defaulted nor a template, if no argument values exist such that an invocation of the function or constructor could be an evaluated subexpression of a core constant expression, or, for a constructor, a constant initializer for some object ([basic.start.static]), the program is ill-formed, no diagnostic required. </p>\n</blockquote>\n<p>One of the restrictions of what constitutes a core constant express is that it cannot invoke <a href=\"http://eel.is/c++draft/expr.const#2.6\" rel=\"nofollow noreferrer\">undefined behavior</a>, which includes <a href=\"http://eel.is/c++draft/expr.mul#4.sentence-2\" rel=\"nofollow noreferrer\">division by zero</a>.</p>\n<p>So for <code>divide()</code>, there are arguments that you can pass that would make the call a valid constant expression. But for <code>div_by_zero()</code>, there does not exist <em>any</em> argument you can provide to make it a constant expression - which makes the program ill-formed.</p>\n", "LastActivityDate": "2018-02-05T18:25:36.873", "Score": "2", "CreationDate": "2018-02-05T18:25:36.873", "ParentId": "48623873", "CommentCount": "1", "OwnerUserId": "2069064"}});