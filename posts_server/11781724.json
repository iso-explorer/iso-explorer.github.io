post_cb({"11781823": {"ParentId": "11781724", "CommentCount": "0", "Body": "<p>a quick google tells me that gcc on powerpc has an option to tell the compiler if unaligned accesses are handeled by the system or not. </p>\n<p>I would assume that in either case unaligned accesses on that platform will be very slow, and should be avoided as much as possible.</p>\n", "OwnerUserId": "417292", "PostTypeId": "2", "Id": "11781823", "Score": "3", "CreationDate": "2012-08-02T16:26:22.347", "LastActivityDate": "2012-08-02T16:26:22.347"}, "bq_ids": {"n4140": {"so_11781724_11782277_2": {"section_id": 6097, "quality": 0.92, "length": 23}, "so_11781724_11782277_1": {"section_id": 6857, "quality": 0.6388888888888888, "length": 23}}, "n3337": {"so_11781724_11782277_2": {"section_id": 5863, "quality": 0.92, "length": 23}, "so_11781724_11782277_1": {"section_id": 6603, "quality": 0.6388888888888888, "length": 23}}, "n4659": {"so_11781724_11782277_2": {"section_id": 7594, "quality": 0.88, "length": 22}, "so_11781724_11782277_1": {"section_id": 8349, "quality": 0.6388888888888888, "length": 23}}}, "11781784": {"ParentId": "11781724", "CommentCount": "2", "Body": "<p>Yes, it all depends on the architecture, and probably the compiler optimization flags as well.\nIt will all work fine until you do <code>A b = a;</code> or some other random access which gets compiled to some <a href=\"http://www.jaist.ac.jp/iscenter-new/mpc/altix/altixdata/opt/intel/vtune/doc/users_guide/mergedProjects/analyzer_ec/mergedProjects/reference_olh/mergedProjects/instructions/instruct32_hh/vc183.htm\" rel=\"nofollow\"><code>movdqa</code></a> ops and your program crashes.</p>\n", "OwnerUserId": "180090", "PostTypeId": "2", "Id": "11781784", "Score": "4", "CreationDate": "2012-08-02T16:22:58.647", "LastActivityDate": "2012-08-02T16:22:58.647"}, "11782277": {"ParentId": "11781724", "CommentCount": "2", "Body": "<p>When you call placement new on a buffer:</p>\n<pre><code>A *a = new (buf) A;\n</code></pre>\n<p>you are invoking the built-in <code>void* operator new (std::size_t size, void* ptr) noexcept</code> as defined in:</p>\n<blockquote>\n<p id=\"so_11781724_11782277_0\"><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a></p>\n<h3>18.6.1.3 Placement forms [new.delete.placement]</h3>\n<p id=\"so_11781724_11782277_1\">These functions are reserved, a C++ program may not de\ufb01ne functions that displace the versions in the\n  Standard C++ library (17.6.4). The provisions of (3.7.4) do not apply to these reserved placement forms of\n  operator new and operator delete.<br/><br/>\n<code>void* operator new(std::size_t size, void* ptr) noexcept;</code><br/>\n  Returns: <code>ptr</code>.<br/>\n  Remarks: Intentionally performs no other action.</p>\n</blockquote>\n<p>The <em>provisions of (3.7.4)</em> include that the returned pointer should be suitably aligned, so it's fine for <code>void* operator new (std::size_t size, void* ptr) noexcept</code> to return a nonaligned pointer if one is passed in.  This doesn't let <em>you</em> off the hook, though:</p>\n<blockquote>\n<h3>5.3.4 New [expr.new]</h3>\n<p id=\"so_11781724_11782277_2\">[14] Note: when the allocation function returns a value other than null, it must be a pointer to a block of storage\n  in which space for the object has been reserved. The block of storage is assumed to be appropriately aligned\n  and of the requested size.</p>\n</blockquote>\n<p>So if you pass unaligned storage to a placement-new expression you're violating the assumption that the storage is aligned, and the result is UB.</p>\n<hr/>\n<p>Indeed, in your program above, if you replace <code>long long b</code> with <code>__m128 b</code> (after <code>#include &lt;xmmintrin.h&gt;</code>) then the program will segfault, as expected.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "11782277", "Score": "18", "CreationDate": "2012-08-02T16:57:47.350", "LastActivityDate": "2012-08-02T16:57:47.350"}, "11781822": {"ParentId": "11781724", "CommentCount": "0", "Body": "<p>some processors will definitely blow up with this (sparc for example), others will not care at all, others will be slow. C++ is assuming that you know what you are doing (or not), same as reinterpret_cast etc.</p>\n", "OwnerUserId": "173397", "PostTypeId": "2", "Id": "11781822", "Score": "4", "CreationDate": "2012-08-02T16:26:20.957", "LastActivityDate": "2012-08-02T16:26:20.957"}, "11781724": {"CommentCount": "6", "AcceptedAnswerId": "11782277", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-08-02T16:19:09.783", "LastActivityDate": "2014-04-22T20:38:33.243", "LastEditDate": "2017-05-23T12:09:20.680", "ViewCount": "3647", "FavoriteCount": "10", "Title": "Do I really have to worry about alignment when using placement new operator?", "Id": "11781724", "Score": "22", "Body": "<p>I read this  <a href=\"https://stackoverflow.com/questions/6474316/when-should-i-worry-about-alignment\">When should I worry about alignment?</a> but I am still do not know if I have to worry about not aligned pointer returned by placement new operator - like in this example:</p>\n<pre><code>class A {\npublic:\n   long double a;\n   long long b;\n   A() : a(1.3), b(1234) {}\n};\n\nchar buffer[64];\n\nint main() {\n   // (buffer + 1) used intentionally to have wrong alignment\n   A* a = new (buffer + 1) A(); \n   a-&gt;~A();\n}\n</code></pre>\n<p><code>__alignof(A) == 4</code>, <code>(buffer + 1)</code> is not aligned to <code>4</code>. But everything works fine - full example here: <a href=\"http://ideone.com/jBrk8\" rel=\"nofollow noreferrer\">http://ideone.com/jBrk8</a></p>\n<p>If this depends on architecture then I am using: linux/powerpc/g++ 4.x.x.</p>\n<p>[UPDATE] Just after posting this question I read this article: <a href=\"http://virtrev.blogspot.de/2010/09/memory-alignment-theory-and-c-examples.html\" rel=\"nofollow noreferrer\">http://virtrev.blogspot.de/2010/09/memory-alignment-theory-and-c-examples.html</a>.\nMaybe the only drawbacks in my case would be performance penalty, I mean unaligned access cost more than aligned?</p>\n", "Tags": "<c++><g++><memory-alignment><powerpc><placement-new>", "OwnerUserId": "1463922", "AnswerCount": "5"}, "11781778": {"ParentId": "11781724", "CommentCount": "2", "Body": "<p>Just because everything appears to work doesn't mean it <em>actually</em> does.</p>\n<p>C++ is a specification that defines what is <em>required</em> to work. The compiler can also make not required things work. That's what \"undefined behavior\" means: anything can happen, so your code isn't portable anymore.</p>\n<p>C++ does not <em>require</em> this to work. So if you take your code to a compiler where this doesn't work, you can't blame C++ anymore; it's your fault for misusing the language.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "11781778", "Score": "9", "CreationDate": "2012-08-02T16:22:43.770", "LastActivityDate": "2012-08-02T16:22:43.770"}});