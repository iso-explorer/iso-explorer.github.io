post_cb({"24119246": {"ParentId": "24117997", "CommentCount": "6", "CreationDate": "2014-06-09T11:21:08.743", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "24119246", "Score": "0", "Body": "<p>As far as the standard is concerned, you have no guaranteed.  An\nimplementation can copy a functional object any time it wants.\nThe idea is that an implementation could potentially divide the\nrange into sub-ranges, and process each sub-range in a separate\nthread.  (At least, this was what was claimed at one point in\nthe standardization process.) </p>\n<p>Globally, of course, for some algorithms, like <code>generate</code> or\n<code>accumulate</code>, allowing multiple copies or reordering would make\nthe algorithm useless.  Usually, such algorithms guarantee\norder; they seem to have forgotten <code>generate</code> in this.  And\nwhile the standard does seem to have forgotten allowing copies,\npratically, if order is guaranteed, there is no need for\nmultiple copies in the processing, so I think we can safely\nassume that there aren't, even in the absense of a strict\nguarantee.</p>\n", "LastActivityDate": "2014-06-09T11:21:08.743"}, "24117997": {"CommentCount": "4", "AcceptedAnswerId": "24118439", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-06-09T10:09:54.107", "LastActivityDate": "2014-06-09T11:41:54.167", "LastEditDate": "2017-05-23T11:58:41.420", "ViewCount": "463", "FavoriteCount": "1", "Title": "Can functor provided to std::generate be stateful?", "Id": "24117997", "Score": "4", "Body": "<p>Recently I read that some STL algorithms have undefined behaviour if the passed functor is stateful (has internal side-effects). I've used the <code>std::generate</code> function with a functor similar (less trivial) to the following:</p>\n<pre><code>class Gen\n{\npublic:\n    explicit Gen(int start = 0)\n        : next(start)\n    {\n    }\n\n    int operator() ()\n    {\n        return next++;\n    }\n\nprivate:\n    int next;\n};\n</code></pre>\n<p>Is this safe to use with <code>std::generate</code>? Is the order of generating values guaranteed?</p>\n<p>Edit: Claim made here <a href=\"https://stackoverflow.com/questions/6112995/stateful-functors-stl-undefined-behaviour\">Stateful functors &amp; STL : Undefined behaviour</a></p>\n", "Tags": "<c++>", "OwnerUserId": "2068573", "AnswerCount": "3"}, "24118069": {"ParentId": "24117997", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-06-09T10:14:18.310", "Score": "5", "LastEditorUserId": "1968", "LastEditDate": "2014-06-09T10:25:28.863", "Id": "24118069", "OwnerUserId": "1968", "Body": "<p>Almost every meaningful generator is stateful. Think about it: a generator invocation has no arguments. If the generator were stateless it would thus have to generate the same value every time. In other words, the only stateless generator is a <em>constant</em> generator:</p>\n<pre><code>template &lt;typename T&gt;\nstruct constant {\n    constant(T&amp;&amp; value) : value{value} {}\n\n    T const&amp; operator ()() const { return value; }\n\nprivate:\n    T const value;\n};\n</code></pre>\n<p>Or, alternatively, you could have a generator which has state external to the object itself, such as <a href=\"http://en.cppreference.com/w/cpp/numeric/random/random_device\"><code>std::random_device</code></a>. But these are really the only two applicable cases. This would be awfully restrictive. So yes \u2013\u00a0it is definitely possible to have a stateful generator.</p>\n<p>The source for this statement that you refer to is <strong>not</strong> talking about generators \u2013 instead, it is talking about <em>predicats</em>, which are a different class of functions, and have different requirements (a predicate is a function with a single argument which returns a <code>bool</code> value).</p>\n", "LastActivityDate": "2014-06-09T10:25:28.863"}, "bq_ids": {"n4140": {"so_24117997_24118439_1": {"section_id": 1243, "quality": 0.7941176470588235, "length": 27}, "so_24117997_24118439_2": {"section_id": 1243, "quality": 0.7941176470588235, "length": 27}}, "n3337": {"so_24117997_24118439_1": {"section_id": 1241, "quality": 0.7941176470588235, "length": 27}, "so_24117997_24118439_2": {"section_id": 1241, "quality": 0.7941176470588235, "length": 27}}, "n4659": {"so_24117997_24118439_1": {"section_id": 1331, "quality": 0.7941176470588235, "length": 27}, "so_24117997_24118439_2": {"section_id": 1331, "quality": 0.7941176470588235, "length": 27}}}, "24118439": {"ParentId": "24117997", "PostTypeId": "2", "CommentCount": "15", "CreationDate": "2014-06-09T10:35:18.020", "Score": "5", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:58:41.420", "Id": "24118439", "OwnerUserId": "1090079", "Body": "<h3>Introduction</h3>\n<p>There's no problem using a stateful functor with functions such as <em>std::generate</em>, but one has to be careful not to run into issues where the underlying implementation makes a copy that will change the semantics of a program in a way that is different from what the developer have in mind.</p>\n<blockquote>\n<p id=\"so_24117997_24118439_0\"><code>25.1p10</code> <strong>Algorithms library</strong> - <strong>General</strong> <code>[algorithms.general]</code></p>\n<blockquote>\n<p id=\"so_24117997_24118439_2\">[ <em>Note:</em> Unless otherwise specified, algorithms that take function objects as arguments are permitted to copy those function obejcts freely. Programmers for whom object identity is imoprtant should consider using a wrapper class that points to a noncopied implementation object such as reference_wrapper, or some equivalent solution. -- <em>end note</em> ]</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2>Order of assignment/evaluation</h2>\n<p>The standard explicitly states that exactly <code>last - first</code> (N) assignments and invocations of the generator will be made, but it doesn't state in what order. More can be read in the following <em>Q&amp;A</em>:</p>\n<ul>\n<li><strong><a href=\"https://stackoverflow.com/q/14823732/1090079\">C++ standard wording: Does \u201cthrough all iterators in the range\u201d imply sequentiality?</a></strong></li>\n</ul>\n<hr>\n<h2>Stateful <em>functors</em> + <code>std::generate</code>, unsafe?</h2>\n<p>Generally no, but there are a few caveats.</p>\n<p>Within <em>std::generate</em> the standard guarantees that the same instance of the functor type will be invoked for every element in the given range, but as can be hinted by the declaration of <em>std::generate</em> we might run into issues where we forget that the passed <em>functor</em> invoked <strong>inside</strong> the function will be a <strong>copy</strong> of the one passed as argument.</p>\n<p>See the below snippet where we declare a <em>functor</em> to generate \"unique\" ids:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\ntemplate&lt;class id_type&gt;\nstruct id_generator {\n  id_type operator() () {\n    return ++idx;\n  }\n\n  id_type next_id () const {\n    return idx + 1;\n  }\n\n  id_type idx {};\n};\n</code></pre>\n<p><sup></sup></p>\n<pre><code>int main () {\n  id_generator&lt;int&gt; gen;\n\n  std::vector&lt;int&gt;  vec1 (5);\n  std::vector&lt;int&gt;  vec2 (5);\n\n  std::generate (vec1.begin (), vec1.end (), gen);\n  std::generate (vec2.begin (), vec2.end (), gen);\n\n  std::cout &lt;&lt; gen.next_id () &lt;&lt; std::endl; // will print '1'\n}\n</code></pre>\n<p>After running the above we might expect <code>gen.next_id ()</code> to yield <code>11</code>, since we have used it to <em>generate</em> 5 ids for <code>vec1</code>, and 5 ids for <code>vec2</code>. </p>\n<p>This is not the case since upon invoking <em>std::generate</em> our instance of <em>id_generator</em> will be <strong>copied</strong>, and it is the <strong>copy</strong> that will be used inside the function.</p>\n<hr>\n<h2>What would be the solution?</h2>\n<p>There are several solutions to this problem, all of which prevents a copy from being made when you pass your <em>functor</em> to some <em>algorithm</em> function related to <em>std::generated</em>.</p>\n<p><br/></p>\n<p><em>Alternative #1</em></p>\n<p>The recommended solution is to wrap your <em>functor</em> in a <a href=\"http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper\" rel=\"nofollow noreferrer\"><code>std::reference_wrapper</code></a> with the use of <a href=\"http://en.cppreference.com/w/cpp/utility/functional/ref\" rel=\"nofollow noreferrer\"><code>std::ref</code></a> from <a href=\"http://en.cppreference.com/w/cpp/header/functional\" rel=\"nofollow noreferrer\"><code>&lt;functional&gt;</code></a>. This will effectively copy the <em>reference_wrapper</em>, but the referred to instance of <em>generate_id</em> will stay the same.</p>\n<pre><code>std::generate (vec1.begin (), vec1.end (), std::ref (gen));\nstd::generate (vec2.begin (), vec2.end (), std::ref (gen));\n\nstd::cout &lt;&lt; gen.next_id () &lt;&lt; std::endl; // will print '11'\n</code></pre>\n<p><br/></p>\n<p><em>Alternative #2</em></p>\n<p>You could, of course, also make your fingers stronger by writing something as confusing as the below:</p>\n<pre><code>std::generate&lt;decltype(vec1.begin()), id_generator&lt;int&gt;&amp;&gt;(vec1.begin(), vec1.end(), gen);\n</code></pre>\n</hr></hr></hr>", "LastActivityDate": "2014-06-09T11:41:54.167"}});