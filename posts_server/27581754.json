post_cb({"27581872": {"ParentId": "27581754", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>In most implementations of the STL, a <code>reserve</code> of an empty vector will trigger a reallocation and ensure that the data your are pointed it is owned/managed.</p>\n<p>The location of the data (the value of the pointer as returned by <code>data()</code>) might change when a vector is resized. Holding a pointer <em>per se</em> is of course legal, dereferencing it for a read while un-initialized is of course undefined, and derefering it after initialized is <em>only</em> legal if you can guarantee that your vector did not resize and as such the range you allocated is still in the same place.</p>\n<p>Incrementing a pointer to data that has been <code>malloc</code>'d is fine. In this example, you perform pointer arithmetic to hold a pointer to data that you know has been allocated by the <code>std::vector</code>. Regardless of whether the element pointed to by the pointer is ever initialized, a resize operation is problematic as it might deallocate the memory you are pointing to.</p>\n", "OwnerUserId": "864313", "LastEditorUserId": "864313", "LastEditDate": "2014-12-20T19:03:44.960", "Id": "27581872", "Score": "0", "CreationDate": "2014-12-20T15:54:35.333", "LastActivityDate": "2014-12-20T19:03:44.960"}, "27581754": {"CommentCount": "6", "ViewCount": "352", "PostTypeId": "1", "LastEditorUserId": "1287251", "CreationDate": "2014-12-20T15:42:30.850", "LastActivityDate": "2014-12-20T19:03:44.960", "Title": "Is it legal to have a pointer to a reserved vector element?", "FavoriteCount": "3", "LastEditDate": "2014-12-20T16:16:40.930", "Id": "27581754", "Score": "10", "Body": "<p>I'm curious if this sort of thing is legal:</p>\n<pre><code>std::vector&lt;some_class_type&gt; vec;\nvec.reserve(10);\nsome_class_type* ptr = vec.data() + 3; // that object doesn't exist yet\n</code></pre>\n<p>Note that I'm not attempting to access the value pointed to.</p>\n<p>This is what the standard says about <code>data()</code>, but I'm not sure if it's relevant:</p>\n<blockquote>\n<p id=\"so_27581754_27581754_0\">Returns: A pointer such that <code>[data(),data() + size())</code> is a valid\n  range. For a non-empty vector, <code>data() == &amp;front()</code>.</p>\n</blockquote>\n", "Tags": "<c++><pointers><vector><language-lawyer><undefined-behavior>", "OwnerUserId": "964135", "AnswerCount": "3"}, "27582018": {"ParentId": "27581754", "CommentCount": "7", "Body": "<p>The example you provided does not exhibit any <em>immediate</em> undefined behavior. According to the standard since the number of elements you are reserving is greater than the current capacity of the vector a reallocation will occur. Since the allocation occurs at the point where <code>reserve</code> is called the pointer returned by <code>data()</code> is itself valid.</p>\n<p>23.3.6.3/2 (Emphasis mine)</p>\n<blockquote>\n<p id=\"so_27581754_27582018_0\">Effects: A directive that informs a vector of a planned change in size, so that it can manage the storage allocation accordingly. After reserve(), capacity() is greater or equal to the argument of reserve if reallocation happens; and equal to the previous value of capacity() otherwise. <strong>Reallocation happens at this point if and only if the current capacity is less than the argument of reserve()</strong>. If an exception is thrown other than by the move constructor of a non-CopyInsertable type, there are no effects.</p>\n</blockquote>\n<p>If however you attempt to dereference the pointer prior to adding enough elements where the pointer is outside of <code>data() + size()</code> or if you add more than <code>capacity()</code> slements then undefined behavior occurs. </p>\n", "OwnerUserId": "845568", "PostTypeId": "2", "Id": "27582018", "Score": "3", "CreationDate": "2014-12-20T16:13:53.607", "LastActivityDate": "2014-12-20T16:13:53.607"}, "bq_ids": {"n4140": {"so_27581754_27581998_0": {"section_id": 969, "quality": 1.0, "length": 34}, "so_27581754_27582018_0": {"section_id": 969, "quality": 0.9777777777777777, "length": 44}, "so_27581754_27581754_0": {"section_id": 984, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_27581754_27581998_0": {"section_id": 958, "quality": 1.0, "length": 34}, "so_27581754_27581754_0": {"section_id": 969, "quality": 0.6666666666666666, "length": 8}, "so_27581754_27582018_0": {"section_id": 958, "quality": 0.9777777777777777, "length": 44}}, "n4659": {"so_27581754_27581998_0": {"section_id": 1031, "quality": 1.0, "length": 34}, "so_27581754_27582018_0": {"section_id": 1031, "quality": 0.9777777777777777, "length": 44}, "so_27581754_27581754_0": {"section_id": 1047, "quality": 0.6666666666666666, "length": 8}}}, "27581998": {"ParentId": "27581754", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>Definitely <strong>NO</strong>: your pointer cannot assumed to be valid. Here the proof that it's UB: </p>\n<p>The standard says about capactity (23.3.6.3) that <code>reserve()</code> has the following effect:  </p>\n<blockquote>\n<p id=\"so_27581754_27581998_0\">A directive that <strong>informs</strong> a vector of a planned change in size, so\n  that it can manage the storage allocation accordingly. After\n  reserve(), capacity() is greater or equal to the argument of reserve\n  if reallocation happens; and equal to the previous value of capacity()\n  otherwise. Reallocation happens at this point if and only if the\n  current capacity is less than the argument of reserve().</p>\n</blockquote>\n<p>So the standard guarantees that if there was something allocated and was not of sufficient capacity, a reallocation has to take place at this moment.  But nothing more. </p>\n<p>This wording lets the implementation manage empty vectors in other ways.  For instance, one could perfectly imagine that an implementation may not to allocate memory for an empty vector that was just created, and to allocate the needed capacity only when adding the first element (\"lazy-allocation\" strategy).  </p>\n<p>In that case, your example, would result in a pointer to an invalid address.  </p>\n<p><strong><em>Important edit:</em></strong>\nSome might argue that the \"<em>if and only if</em>\" clause would ensure that an allocation has to take place in the example, because the new capacity would be greater than the initial one.  However, the standard does <strong><em>not make any claim about initial capacity of a vector</em></strong>.  An implemenation that would use a bloc oriented lazy allocation strategy (i.e. managing capacity by blocs of minimu, say 10 items) would be compliant with the standard and cause your example to point to an invalid address as explained above. </p>\n", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "LastEditDate": "2014-12-20T16:51:43.910", "Id": "27581998", "Score": "-1", "CreationDate": "2014-12-20T16:11:05.570", "LastActivityDate": "2014-12-20T16:51:43.910"}});