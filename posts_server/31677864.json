post_cb({"31678740": {"ParentId": "31677864", "CommentCount": "0", "Body": "<p>As said by @aschepler, standard 4.7 \u00a72 (<em>Integral conversions</em>) ensures that the result will be <em>least unsigned integer congruent to the source\ninteger (modulo 2n where n is the number of bits used to represent the unsigned type)</em></p>\n<p>So in your case, it will be 0xFFFFFFFFFFFFFFFE == 18446744073709551614</p>\n<p>But this is a one step conversion as specified by the standard (what compiler actually does is out of scope)</p>\n<p>If you want first unsigned conversion to uint32_t and then conversion to uint64_t, you have to specify 2 conversions : <code>static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(-2))</code></p>\n<p>Per 4.7 \u00a72, first will give 0xFFFFFFFE = 4294967294 but as this number is already a valid uint64_t it is unchanged by the second conversion.</p>\n<p>What you observed is required by the standard and will be observable on any conformant compiler (provided <code>uint32_t</code> and <code>uint64_t</code> are defined, because <em>this part</em> is not required ...)</p>\n", "OwnerUserId": "3545273", "PostTypeId": "2", "Id": "31678740", "Score": "0", "CreationDate": "2015-07-28T14:07:04.813", "LastActivityDate": "2015-07-28T14:07:04.813"}, "31677864": {"CommentCount": "2", "ViewCount": "72", "PostTypeId": "1", "LastEditorUserId": "3545273", "CreationDate": "2015-07-28T13:33:22.957", "LastActivityDate": "2015-07-28T14:09:36.757", "Title": "Casting both bitwidth and signed/unsigned, which conversion is executed first?", "AcceptedAnswerId": "31677997", "LastEditDate": "2015-07-28T13:46:52.497", "Id": "31677864", "Score": "3", "Body": "<p>Consider the following code:</p>\n<pre><code>int32_t x = -2;\ncout &lt;&lt; uint64_t(x) &lt;&lt; endl;\n</code></pre>\n<p>The cast in the second line contains basically two atomic steps. The increase in bitwidth from 32 bits to 64 bits and the change of interpretation from signed to unsigned. If one compiles this with g++ and executes, one gets 18446744073709551614. This suggests that the increase in bitwidth is processed first (as a signed extension) and the change in signed/unsigned interpretation thereafter, i.e. that the code above is equivalent to writing:</p>\n<pre><code>int32_t x = -2;\ncout &lt;&lt; uint64_t(int64_t(x)) &lt;&lt; endl;\n</code></pre>\n<p>What confuses me that one could also first interpret x as an unsigned 32-bit bitvector first and then zero-extend it to 64-bit, i.e.</p>\n<pre><code>int32_t x = -2;\ncout &lt;&lt; uint64_t(uint32_t(x)) &lt;&lt; endl;\n</code></pre>\n<p>This would yield 4294967294. Would someone please confirm that the behavior of g++ is required by the standard and is not implementation defined? I would be most excited if you could refer me to the norm in the standard that actually concerns the issue at hand. I tried to do so but failed bitterly.</p>\n<p>Thanks in advance!</p>\n", "Tags": "<c++><casting><int>", "OwnerUserId": "1541340", "AnswerCount": "2"}, "31677997": {"ParentId": "31677864", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You are looking for Standard section 4.7.  In particular, paragraph 2 says:</p>\n<blockquote>\n<p id=\"so_31677864_31677997_0\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup><em>n</em></sup> where <em>n</em> is the number of bits used to represent the unsigned type).</p>\n</blockquote>\n<p>In the given example, we have that 18446744073709551614 = -2 mod 2<sup><em>64</em></sup>.</p>\n", "OwnerUserId": "459640", "LastEditorUserId": "1541340", "LastEditDate": "2015-07-28T14:09:36.757", "Id": "31677997", "Score": "2", "CreationDate": "2015-07-28T13:39:01.063", "LastActivityDate": "2015-07-28T14:09:36.757"}, "bq_ids": {"n4140": {"so_31677864_31677997_0": {"section_id": 31, "quality": 1.0, "length": 18}}, "n3337": {"so_31677864_31677997_0": {"section_id": 28, "quality": 1.0, "length": 18}}, "n4659": {"so_31677864_31677997_0": {"section_id": 31, "quality": 1.0, "length": 18}}}});