post_cb({"47398475": {"ParentId": "47398358", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_47398358_47398475_0\">Is this the intended behavior by the standard, or is this a case of incomplete support by the compiler? </p>\n</blockquote>\n<p>Yes, this is intended behavior. <a href=\"http://eel.is/c++draft/dcl.type.class.deduct#1\" rel=\"noreferrer\">[dcl.type.class.deduct]</a> reads:</p>\n<blockquote>\n<p id=\"so_47398358_47398475_1\">If a placeholder for a deduced class type appears as a <em>decl-specifier</em> in the <em>decl-specifier-seq</em> of an initializing declaration ([dcl.init]) of <strong>a variable</strong>, [...]</p>\n<p id=\"so_47398358_47398475_2\">A placeholder for a deduced class type can also be used in the <em>type-specifier-seq</em> in the <em>new-type-id</em> or <em>type-id</em> of a <em>new-expression</em>, or as the <em>simple-type-specifier</em> in an explicit type conversion (functional notation). <strong>A placeholder for a deduced class type shall not appear in any other context</strong>.</p>\n</blockquote>\n<p>A non-static data member is not a variable, and we're in none of the other situations.</p>\n<p>Note that the same principle is true for non-static data members attempting to be declared with <code>auto</code>: </p>\n<pre><code>struct X {\n    auto y = 0; // error\n};\n</code></pre>\n<p>The default member initializer is just that - a default initializer. What if you provided a constructor that initialized the member with expression(s) of different types?</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-11-20T18:23:23.680", "Id": "47398475", "Score": "6", "CreationDate": "2017-11-20T18:09:43.003", "LastActivityDate": "2017-11-20T18:23:23.680"}, "47398358": {"CommentCount": "3", "ViewCount": "255", "LastEditDate": "2017-11-20T18:04:18.950", "LastEditorUserId": "2069064", "CreationDate": "2017-11-20T18:02:38.343", "LastActivityDate": "2017-11-20T18:23:23.680", "PostTypeId": "1", "Title": "Can template parameter deduction be used in class data members?", "Id": "47398358", "OwnerUserId": "2212292", "Body": "<p>C++17 introduces <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0091r4.html\" rel=\"noreferrer\">template argument deduction</a>.</p>\n<p>With gcc-7.2, I can use it easily in a function:</p>\n<pre><code>int test() {\n  std::pair d(0, 0.0);\n}\n</code></pre>\n<p>I was expecting this same syntax to work in class non-static data members, like:</p>\n<pre><code>class Test {\n  std::pair d_{0, 0.0};\n};\n</code></pre>\n<p>but this causes gcc <code>error: invalid use of template-name ... without an argument list</code>, with <code>--std=c++17</code> passed.</p>\n<p>I tried a few other combinations, but none seems to work.</p>\n<p>Is this the intended behavior by the standard, or is this a case of incomplete support by the compiler? I can't find any explicit reference to class data members in the standard.</p>\n<p>My use case is of course much more complex, having this syntax would be extremely convenient (think functions being passed and stored).</p>\n", "Tags": "<c++><gcc><c++1z>", "Score": "8", "AnswerCount": "1"}, "bq_ids": {"n4659": {"so_47398358_47398475_1": {"section_id": 6891, "quality": 0.9090909090909091, "length": 10}, "so_47398358_47398475_2": {"section_id": 6892, "quality": 1.0, "length": 23}}}});