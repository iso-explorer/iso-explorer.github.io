post_cb({"8643288": {"Id": "8643288", "PostTypeId": "2", "Body": "<p>Try this code below.  If your string is initialized with anywhere from 1-9 characters, you'll be able to get the length of it this way.  The max is 9 characters because you must have room for the '\\0' terminating character.</p>\n<p>Incidentally, if your string is not initialized, the <code>strlen</code> in <code>foo()</code> does not report zero as I would expect, but rather some unexpected number.  Perhaps someone more experienced than me can comment on this.</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid foo(const char * data1, const char * data2)\n{\n   char copy[10];\n   const char copy1[10] = {};\n\n   printf(\"%i\\n\", sizeof(copy)); //prints 10, as expected\n   printf(\"%i\\n\", sizeof(copy1)); //prints 10, as expected\n   printf(\"%i\\n\", (sizeof(*data1) * strlen(data1))); //prints 1\n   printf(\"%i\\n\", (sizeof(*data2) * strlen(data2))); //prints 9\n}\n\nint main(void)\n{\n    const char bar1[10] = \"1\";\n    const char bar2[10] = \"123456789\";\n\n    printf(\"%i\\n\", sizeof(bar1)); //prints 10, as expected\n    printf(\"%i\\n\", sizeof(bar2)); //prints 10, as expected\n    foo(bar1, bar2);\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2011-12-27T09:55:03.003", "CommentCount": "2", "CreationDate": "2011-12-27T09:55:03.003", "ParentId": "8642741", "Score": "-1", "OwnerUserId": "912935"}, "8642797": {"Id": "8642797", "PostTypeId": "2", "Body": "<p>When you pass an array to a function, what you are actually doing is passing a pointer to the first element of the array (you probably knew that). Even if you have a parameter declared as <code>char[10]</code>, that will still mean you only get a pointer since C is designed to be very fast so it avoids making copies of potentially very large data such as arrays. The <code>[10]</code> serves no purpose, except maybe as a reminder to the programmer.</p>\n", "LastEditorUserId": "1011995", "LastActivityDate": "2011-12-27T10:58:09.300", "Score": "5", "CreationDate": "2011-12-27T09:02:43.287", "ParentId": "8642741", "CommentCount": "0", "OwnerUserId": "627005", "LastEditDate": "2011-12-27T10:58:09.300"}, "8643416": {"Id": "8643416", "PostTypeId": "2", "Body": "<p>There are actually two related but independent rules in play here.</p>\n<p>One is that an expression of array type is, in most contexts, implicitly converted (at compile time) into a pointer to (i.e., the address of) the first element of the array.  The exceptions are when it's the operand of <code>sizeof</code>, when it's the operand of unary <code>&amp;</code>, and when it's a string literal in an initializer used to initialize an array object.</p>\n<p>The other is that a function parameter declared to be of an array type is really of a pointer type -- and if the array type includes a length, that length is silently ignored.  This is the rule that causes the behavior you're seeing.</p>\n<p>Strongly recommended reading: Section 6 of the <a href=\"http://c-faq.com\" rel=\"nofollow\">comp.lang.c FAQ</a>.</p>\n<p><strong>EDIT :</strong> Your program has several errors that would prevent it from compiling, which means you couldn't have seen the results you say you're seeing.  You apparently re-typed the program when posting it here.  Instead, you should copy-and-paste the <em>exact</em> code as you fed it to the compiler.</p>\n<p>Here's a corrected version of your code, with a bit of commentary added.</p>\n<pre><code>#include &lt;stdio.h&gt; /* required for printf */\n\nvoid foo(const char data[10]) /* NOTE: The 10 is quietly ignored */\n{\n    char copy[10];\n    /* syntax, [10] follows \"copy\", not \"char\" */\n    const char copy1[10]; // = {};\n    /* as above, and standard C disallows empty initializer */\n\n    printf(\"%d\", (int)sizeof copy);  // prints 10, as expected\n    printf(\"%d\", (int)sizeof copy1); // prints 10, as expected\n    printf(\"%d\", (int)sizeof data);  // prints 4 (sizeof (char*), as expected\n\n    /*\n     * \"%i\" or \"%d\" requires an int argument; sizeof yields size_t.\n     * You need to convert the result.\n     * \"%d\" is more common and idiomatic than the equivalent \"%i\"\n     * When sizeof is applied to an expression, no parentheses are needed\n     * (it's an operator, not a function\n     */\n}\n</code></pre>\n", "LastEditorUserId": "827263", "LastActivityDate": "2011-12-27T10:32:42.493", "Score": "4", "CreationDate": "2011-12-27T10:08:25.210", "ParentId": "8642741", "CommentCount": "3", "OwnerUserId": "827263", "LastEditDate": "2011-12-27T10:32:42.493"}, "bq_ids": {"n4140": {"so_8642741_8644519_1": {"length": 14, "quality": 1.0, "section_id": 3244}, "so_8642741_8644519_0": {"length": 16, "quality": 1.0, "section_id": 3241}}, "n3337": {"so_8642741_8644519_1": {"length": 14, "quality": 1.0, "section_id": 3117}, "so_8642741_8644519_0": {"length": 16, "quality": 1.0, "section_id": 3114}}, "n4659": {"so_8642741_8644519_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 6103}, "so_8642741_8644519_0": {"length": 12, "quality": 0.75, "section_id": 3997}}}, "8642791": {"Id": "8642791", "PostTypeId": "2", "Body": "<p>I never saw that syntax before in C++ but maybe you meant</p>\n<pre><code>void foo(const char data[10])\n</code></pre>\n<p>Anyway, in C++ arrays decay to pointers when passed to a function. So the function has no way of knowing how big the passed arrays are. In that sense, what I wrote above is completely equivalent to:</p>\n<pre><code>void foo(const char data[])\n</code></pre>\n<p>There is also a <a href=\"http://c-faq.com/aryptr/aryparmsize.html\" rel=\"nofollow\">C FAQ</a> about this subject.</p>\n", "LastActivityDate": "2011-12-27T09:01:19.667", "CommentCount": "2", "CreationDate": "2011-12-27T09:01:19.667", "ParentId": "8642741", "Score": "4", "OwnerUserId": "714501"}, "8642788": {"Id": "8642788", "PostTypeId": "2", "Body": "<p>You are passing address of 1st element. When we call foo() method  the compiler generates a pointer to its <a href=\"http://www.cplusplus.com/doc/tutorial/arrays/\" rel=\"nofollow\">first element</a>. Array name is itself a pointer to the first element.</p>\n", "LastActivityDate": "2011-12-27T09:00:56.737", "CommentCount": "0", "CreationDate": "2011-12-27T09:00:56.737", "ParentId": "8642741", "Score": "3", "OwnerUserId": "142822"}, "8644519": {"Id": "8644519", "PostTypeId": "2", "Body": "<p>Other answers already mention that this is because a function parameter of declared as an array type actually declares a parameter of pointer type; this is specified in C++11, 8.3.5/5:</p>\n<blockquote>\n<p id=\"so_8642741_8644519_0\">After determining the type of each parameter, any parameter of type \u201carray of T\u201d or \u201cfunction returning T\u201d is adjusted to be \u201cpointer to T\u201d or \u201cpointer to function returning T,\u201d respectively.</p>\n</blockquote>\n<p>Therefore, <code>data</code> actually has type <code>const char *</code>, so <code>sizeof data</code> gives the size of a pointer.</p>\n<p>You can preserve the size of an array by passing a reference to it:</p>\n<pre><code>void foo(const char (&amp;data)[10])\n{\n   char copy[10];\n   const char copy1[10] = {};\n\n   printf(\"%i\", sizeof(copy)); //prints 10, as expected\n   printf(\"%i\", sizeof(copy1)); //prints 10, as expected\n   printf(\"%i\", sizeof(data)); //prints 10, as expected\n}\n</code></pre>\n<p>The reference must be to an array of known size, since 8.3.5/8 says:</p>\n<blockquote>\n<p id=\"so_8642741_8644519_1\">If the type of a parameter includes a type of the form \u201cpointer to array of unknown bound of T\u201d or \u201creference to array of unknown bound of T,\u201d the program is ill-formed.</p>\n</blockquote>\n<p>You can get around this using a function template, parametrised by the size of the array:</p>\n<pre><code>template &lt;size_t N&gt;\nvoid foo(const char (&amp;data)[N]);\n</code></pre>\n", "LastActivityDate": "2011-12-27T12:15:55.010", "CommentCount": "1", "CreationDate": "2011-12-27T12:15:55.010", "ParentId": "8642741", "Score": "1", "OwnerUserId": "204847"}, "8642741": {"ViewCount": "171", "Body": "<p>Can you explain this:</p>\n<pre><code>void foo(const char data[10])\n{\n   char copy[10];\n   const char copy1[10] = {};\n\n   printf(\"%i\", sizeof(copy)); //prints 10, as expected\n   printf(\"%i\", sizeof(copy1)); //prints 10, as expected\n   printf(\"%i\", sizeof(data)); //prints 4, WTF?\n\n}\n</code></pre>\n<p>Looks like function parameters are treated as simple pointers for sizeof.\nBut WHY does this happen? Is it documented anywhere?</p>\n", "AcceptedAnswerId": "8642791", "Title": "Weird behavior of sizeof for arrays passed as parameters", "CreationDate": "2011-12-27T08:56:22.290", "Id": "8642741", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-12-27T11:08:35.460", "LastEditorUserId": "1660", "LastActivityDate": "2011-12-27T12:15:55.010", "Score": "1", "OwnerUserId": "1660", "Tags": "<c++><parameters><sizeof>", "AnswerCount": "6"}});