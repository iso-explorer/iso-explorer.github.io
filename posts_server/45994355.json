post_cb({"45994543": {"ParentId": "45994355", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>From the standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4687.pdf\" rel=\"nofollow noreferrer\">N4687</a>: </p>\n<p><strong>20.5.4.3.2 Macro names</strong></p>\n<blockquote>\n<p id=\"so_45994355_45994543_0\">1 A translation unit that includes a standard library header <strong>shall not\n    #define or #undef names declared in any standard library header</strong>.</p>\n<p id=\"so_45994355_45994543_1\">2 A translation unit shall not #define or #undef names lexically\n    identical to keywords, to the identifiers listed in Table 4, or to the\n    attribute-tokens described in 10.6.</p>\n</blockquote>\n<p>So what you are trying to do is prohibited by the standard!</p>\n<p>Additionally in this specific case it won't work because you are substituting <code>endl</code> for a string of some sort, causing the preprocessor to generate this: <code>std::\"\\n\\r\"</code> which causes the compilation to fail.</p>\n<hr>\n<p>If you wan't to replace <code>std::endl</code> by <code>\"\\r\\n\"</code> (BTW: not <code>\"\\n\\r\"</code>) then do it by hand or write a script to do it. </p>\n</hr>", "OwnerUserId": "4711812", "LastEditorUserId": "4711812", "LastEditDate": "2017-09-01T06:54:35.110", "Id": "45994543", "Score": "5", "CreationDate": "2017-09-01T06:39:31.957", "LastActivityDate": "2017-09-01T06:54:35.110"}, "45994355": {"CommentCount": "6", "ViewCount": "101", "PostTypeId": "1", "LastEditorUserId": "5752711", "CreationDate": "2017-09-01T06:23:50.617", "LastActivityDate": "2017-09-22T08:27:27.437", "Title": "C++ unable to call std::endl", "AcceptedAnswerId": "45994543", "LastEditDate": "2017-09-22T08:27:27.437", "Id": "45994355", "Score": "-5", "Body": "<p>Framed the question better manner:</p>\n<p>Have a logger C++ class which has the &lt;&lt; operator overloaded to accept ints, strings.. </p>\n<pre><code>logR &lt;&lt;\"Test\"&lt;&lt;endl\n</code></pre>\n<p>Now the endl had been defined as macro </p>\n<pre><code>#define endl \"\\n\\r\" \n</code></pre>\n<p>Now in any .cpp file if i included this logger class's header file i used to get compilation error for using endl.</p>\n<p>Found a fix for this instead of defining macro endl, I overloaded operator to receive the endl() itself.\nThanks for the inputs it helped in solving the issue.</p>\n", "Tags": "<c++><string><macros>", "OwnerUserId": "5752711", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_45994355_45994543_1": {"section_id": 6306, "quality": 0.7142857142857143, "length": 10}, "so_45994355_45994543_0": {"section_id": 6305, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_45994355_45994543_1": {"section_id": 6063, "quality": 0.7142857142857143, "length": 10}, "so_45994355_45994543_0": {"section_id": 6062, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_45994355_45994543_1": {"section_id": 7817, "quality": 0.7142857142857143, "length": 10}, "so_45994355_45994543_0": {"section_id": 7816, "quality": 0.8181818181818182, "length": 9}}}, "45994830": {"ParentId": "45994355", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As was pointed out already, you are not allowed to define a macro with the name <code>endl</code>. However, you are allowed to declare a varaiable with the name <code>endl</code> (outside namespace <code>std</code> obviously). So you could have</p>\n<pre><code>// where the macro is currently define:\nextern char const endl[3];\n\n// in a suitable source file including the header with the above declaration:\nchar const endl[3] = \"\\n\\r\";\n</code></pre>\n<p>The observed behavior should be the same as using the macro except that this declaration can coexist with <code>std::endl</code>. That does assume that you don''t use <code>L endl</code> with which I'd consider rather odd. Thinking of it, I can imagine you are using <code>T(endl)</code> which nearly adds this <code>L</code> but accually concatenates <code>L</code> to the name. If so, you'd just also add</p>\n<pre><code>extern wchar_t const Lendl[];\n</code></pre>\n<p>with a corresponding definition.</p>\n<p>If you want to use your <code>endl</code> just like <code>std::endl</code> is used but with some different behavior, I'd recommend defining it in a similar way, too:</p>\n<pre><code>template &lt;typename cT, typename Traits&gt;\nstd::basic_ostream&lt;cT, Traits&gt;&amp; endl(std::basic_ostream&lt;cT, Traits&gt;&amp; out) {\n    return out &lt;&lt; out.widen('\\n') &lt;&lt; out.widen('\\r');\n}\n</code></pre>\n<p>Of course, when sending a <code>'\\n'</code> character to a <code>std::ofstream</code> (or an <code>std::wofstream</code>) opened in text mode (i.e., without using <code>std::ios_base::binary</code>) it gets translated into the [platform specific] end of line sequence.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "8242698", "LastEditDate": "2017-09-01T07:15:00.423", "Id": "45994830", "Score": "3", "CreationDate": "2017-09-01T06:58:28.097", "LastActivityDate": "2017-09-01T07:15:00.423"}});