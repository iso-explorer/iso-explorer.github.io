post_cb({"4999241": {"CommentCount": "0", "ViewCount": "1792", "CreationDate": "2011-02-15T01:57:16.103", "LastActivityDate": "2011-02-15T04:18:51.700", "Title": "mixing use of constexpr and const?", "AcceptedAnswerId": "4999832", "PostTypeId": "1", "Id": "4999241", "Score": "7", "Body": "<p>I read a little of CLang implementation of standard library and it confuses me a little bit on const and constexpr.</p>\n<pre><code>template&lt;class _Tp, _Tp __v&gt;\nstruct integral_constant\n{\n    static constexpr _Tp value = __v;\n};\n\ntemplate&lt;class _Tp, _Tp __v&gt;\nconst _Tp integral_constant&lt;_Tp, __v&gt;::value;\n</code></pre>\n<p>What makes me confusing is that, it is using constexpr inside class definition and const outside. My question is, is that allowed? And under what situation const and constexpr can me be used interchangingly? Of course constexpr functions cannot apply to const, so I am talking about const data and constexpr data.</p>\n<p>I did read some standard draft and the proposal in \n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf</a>,\nbut it makes me feel more confusing. So I have some more questions,</p>\n<p>In N2235, it clearly states that, const data are not guaranteed to be a compile time constants, see the following example,</p>\n<pre><code>struct S {\nstatic const int size;\n};\nconst int limit = 2 * S::size; // dynamic initialization\nconst int S::size = 256;\n</code></pre>\n<p>and constexpr is supposed to solve this, so at least under this situation, constexpr is not allowed as below,</p>\n<pre><code>struct S {\nstatic const int size;\n};\nconstexpr int limit = 2 * S::size; // shall be error in my understanding\nconst int S::size = 256;\n</code></pre>\n<p>However, after reading C++ standard draft N3225, I see nowhere explicitly stated that the above example shall cause an error. Particularly, from 7.1.5/9,</p>\n<blockquote>\n<p id=\"so_4999241_4999241_0\">A constexpr specifier used in an\n  object declaration declares the object\n  as const. Such an object shall have\n  literal type and shall be initialized.\n  If it is initialized by a constructor\n  call, the constructor shall be a\n  constexpr constructor and every\n  argument to the constructor shall be a\n  constant expression. that call shall\n  be a constant expression (5.19).\n  Otherwise, every full-expression that\n  appears in its initializer shall be a\n  constant expression.</p>\n</blockquote>\n<p>Therefore, if constexpr int limit = 2 * S::size; is invalid, then S::size must not be an constant expression, then from 5.19 (constant expression), I see nowhere the standard disallow 2 * S::size in the above example to not be a constant expression.</p>\n<p>Can anybody point out anything I have overlooked? Thank you very much.</p>\n", "Tags": "<c++><c++11><const><clang>", "OwnerUserId": "534498", "AnswerCount": "2"}, "4999832": {"ParentId": "4999241", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>S::size is not a constant expression according to N3225 \u00a75.19p2:</p>\n<blockquote>\n<p id=\"so_4999241_4999832_0\">A conditional-expression is a constant expression unless it involves one of the following\u2026</p>\n<ul>\n<li>an lvalue-to-rvalue conversion (4.1) unless it is applied to\n  \n  <ul>\n<li>a glvalue of integral or enumeration type that refers to a non-volatile const object with a preceding initialization, initialized with a constant expression, or</li>\n<li>[other conditions that don't apply]</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>Note how the second bullet point I quoted allows an integral static data member which is itself initialized with a constant expression to also be a constant expression, but your S::size is uninitialized.</p>\n<p>(Side-note: constant-expressions are defined in terms of conditional-expressions because that's how the C++ grammar works.)</p>\n<p>If you're wondering how the lvalue-to-rvalue conversion happens, see \u00a75p9:</p>\n<blockquote>\n<p id=\"so_4999241_4999832_1\">Whenever a glvalue expression appears as an operand of an operator that expects a prvalue for that operand, the lvalue-to-rvalue (4.1), array-to-pointer (4.2), or function-to-pointer (4.3) standard conversions are applied to convert the expression to a prvalue.</p>\n</blockquote>\n<p>This is probably a good example of how reading the standard <a href=\"https://softwareengineering.stackexchange.com/q/47807\">doesn't make a good reference</a>, though there's not much else available yet for 0x.</p>\n", "OwnerUserId": "511601", "LastEditorUserId": "-1", "LastEditDate": "2017-04-12T07:31:17.220", "Id": "4999832", "Score": "3", "CreationDate": "2011-02-15T04:18:51.700", "LastActivityDate": "2011-02-15T04:18:51.700"}, "4999554": {"ParentId": "4999241", "CommentCount": "1", "Body": "<p>\"every full-expression that appears in it's initializer shall be a constant expression\"</p>\n<p><code>S::size</code> is not a constant expression, therefore it can not appear in the initialization of a constant expression.</p>\n", "OwnerUserId": "440119", "PostTypeId": "2", "Id": "4999554", "Score": "2", "CreationDate": "2011-02-15T03:10:40.567", "LastActivityDate": "2011-02-15T03:10:40.567"}, "bq_ids": {"n4140": {"so_4999241_4999241_0": {"section_id": 5425, "quality": 0.75, "length": 27}, "so_4999241_4999832_0": {"section_id": 6185, "quality": 0.8333333333333334, "length": 5}, "so_4999241_4999832_1": {"section_id": 5942, "quality": 1.0, "length": 17}}, "n3337": {"so_4999241_4999241_0": {"section_id": 5220, "quality": 0.75, "length": 27}, "so_4999241_4999832_0": {"section_id": 5946, "quality": 1.0, "length": 6}, "so_4999241_4999832_1": {"section_id": 5713, "quality": 1.0, "length": 17}}, "n4659": {"so_4999241_4999832_1": {"section_id": 7426, "quality": 1.0, "length": 17}}}});