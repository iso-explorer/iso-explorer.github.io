post_cb({"4418220": {"CommentCount": "8", "ViewCount": "867", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-12-11T18:24:09.333", "LastActivityDate": "2015-07-11T23:37:11.980", "Title": "Legality of using operator delete on a pointer obtained from placement new", "FavoriteCount": "4", "LastEditDate": "2017-05-23T11:51:37.963", "Id": "4418220", "Score": "12", "Body": "<p>I'm dang certain that this code ought to be illegal, as it clearly won't work, but it seems to be allowed by the C++0x FCD.</p>\n<pre><code>class X { /* ... */};\nvoid* raw = malloc(sizeof (X));\nX* p = new (raw) X(); // according to the standard, the RHS is a placement-new expression\n::operator delete(p); // definitely wrong, per litb's answer\ndelete p; // legal?  I hope not\n</code></pre>\n<p>Maybe one of you language lawyers can explain how the standard forbids this.</p>\n<p>There's also an array form:</p>\n<pre><code>class X { /* ... */};\nvoid* raw = malloc(sizeof (X));\nX* p = new (raw) X[1]; // according to the standard, the RHS is a placement-new expression\n::operator delete[](p); // definitely wrong, per litb's answer\ndelete [] p; // legal?  I hope not\n</code></pre>\n<p><a href=\"https://stackoverflow.com/questions/4030575/keep-the-track-of-placement-delete-against-placement-new\">This is the closest question</a> I was able to find.</p>\n<p>EDIT: I'm just not buying the argument that the standard's language restricting arguments to function <code>void ::operator delete(void*)</code> apply in any meaningful way to the operand of <code>delete</code> in a <em>delete-expression</em>.  At best, the connection between the two is <em>extremely</em> tenuous, and a number of expressions <em>are</em> allowed as operands to <code>delete</code> which are not valid to pass to <code>void ::operator delete(void*)</code>.  For example:</p>\n<pre><code>struct A\n{\n  virtual ~A() {}\n};\n\nstruct B1 : virtual A {};\n\nstruct B2 : virtual A {};\n\nstruct B3 : virtual A {};\n\nstruct D : virtual B1, virtual B2, virtual B3 {};\n\nstruct E : virtual B3, virtual D {};\n\nint main( void )\n{\n  B3* p = new E();\n  void* raw = malloc(sizeof (D));\n  B3* p2 = new (raw) D();\n\n  ::operator delete(p); // definitely UB\n  delete p; // definitely legal\n\n  ::operator delete(p2); // definitely UB\n  delete p2; // ???\n\n  return 0;\n}\n</code></pre>\n<p>I hope this shows that whether a pointer may be passed to <code>void operator delete(void*)</code> has no bearing on whether that same pointer may be used as the operand of <code>delete</code>.</p>\n", "Tags": "<c++><language-lawyer><delete-operator><placement-new>", "OwnerUserId": "103167", "AnswerCount": "4"}, "4418374": {"ParentId": "4418220", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>The Standard rules at [basic.stc.dynamic.deallocation]p3</p>\n<blockquote>\n<p id=\"so_4418220_4418374_0\">Otherwise, the value supplied to <code>operator delete(void*)</code> in the standard library shall be one of the values returned by a previous invocation of either <code>operator new(size_t)</code> or <code>operator new(size_t, const std::nothrow_t&amp;)</code> in the standard library, and the value supplied to <code>operator delete[](void*)</code> in the standard library shall be one of the values returned by a previous invocation of either <code>operator new[](size_t)</code> or <code>operator new[](size_t, const std::nothrow_t&amp;)</code> in the standard library.</p>\n</blockquote>\n<p>Your <code>delete</code> call will call the libraries' <code>operator delete(void*)</code>, unless you have overwritten it. Since you haven't said anything about that, I will assume you haven't. </p>\n<p>The \"shall\" above really should be something like \"behavior is undefined if not\" so it's not mistaken as being a diagnosable rule, which it isn't by [lib.res.on.arguments]p1. This was corrected by n3225 so it can't be mistaken anymore.</p>\n", "OwnerUserId": "34509", "LastEditorUserId": "608639", "LastEditDate": "2015-07-11T23:37:11.980", "Id": "4418374", "Score": "7", "CreationDate": "2010-12-11T18:59:30.950", "LastActivityDate": "2015-07-11T23:37:11.980"}, "4418327": {"ParentId": "4418220", "CommentCount": "1", "Body": "<p>I suppose you might get away with it (on a particular compiler) if </p>\n<ol>\n<li><code>new</code>/<code>delete</code> are implemented in terms of <code>malloc</code>/<code>free</code> and </li>\n<li>the placement <code>new</code> actually uses the same mechanism for keeping track of the destructor associated with allocations as the standard <code>new</code>, so that the call to <code>delete</code> could find the right destructor. </li>\n</ol>\n<p>But there is no way it can be portable or safe.</p>\n", "OwnerUserId": "2509", "PostTypeId": "2", "Id": "4418327", "Score": "2", "CreationDate": "2010-12-11T18:46:48.067", "LastActivityDate": "2010-12-11T18:46:48.067"}, "4418299": {"ParentId": "4418220", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The compiler doesn't really care that <code>p</code> comes from a placement <code>new</code> call, so it won't prevent you from issuing <code>delete</code> on the object. In that way, your example can be considered \"legal\".</p>\n<p>That won't work though, since \"placement <code>delete</code>\" operators cannot be called explicitly. They're only called implicitly if the constructor throws, so the destructor can run.</p>\n", "OwnerUserId": "464709", "LastEditorUserId": "464709", "LastEditDate": "2010-12-11T18:49:34.783", "Id": "4418299", "Score": "2", "CreationDate": "2010-12-11T18:39:55.747", "LastActivityDate": "2010-12-11T18:49:34.783"}, "4418330": {"ParentId": "4418220", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I found this in the library section of the standard, which is about as counter-intuitive a location (IMO) as possible:</p>\n<p>C++0x FCD (and n3225 draft) section 18.6.1.3, <code>[new.delete.placement]</code>:</p>\n<blockquote>\n<p id=\"so_4418220_4418330_0\">These functions are reserved, a C ++\n  program may not define functions that\n  displace the versions in the Standard\n  C ++ library (17.6.3). The provisions\n  of (3.7.4) do not apply to these\n  reserved placement forms of operator \n  new and operator  delete.</p>\n</blockquote>\n<pre><code>void*  operator  new(std::size_t  size,  void*  ptr)  throw();\nvoid*  operator  new[](std::size_t  size,  void*  ptr)  throw();\nvoid  operator  delete(void*  ptr,  void*)  throw();\nvoid  operator  delete[](void*  ptr,  void*)  throw();\n</code></pre>\n<p>Still, the section defining legal expressions to pass to <code>delete</code> is 5.3.5, not 3.7.4.</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2010-12-11T19:54:30.637", "Id": "4418330", "Score": "2", "CreationDate": "2010-12-11T18:47:34.503", "LastActivityDate": "2010-12-11T19:54:30.637"}, "bq_ids": {"n4140": {"so_4418220_4418374_0": {"section_id": 7182, "quality": 0.8918918918918919, "length": 33}, "so_4418220_4418330_0": {"section_id": 6857, "quality": 0.7727272727272727, "length": 17}}, "n3337": {"so_4418220_4418374_0": {"section_id": 6926, "quality": 0.8918918918918919, "length": 33}, "so_4418220_4418330_0": {"section_id": 6603, "quality": 0.7727272727272727, "length": 17}}, "n4659": {"so_4418220_4418330_0": {"section_id": 8349, "quality": 0.7727272727272727, "length": 17}}}});