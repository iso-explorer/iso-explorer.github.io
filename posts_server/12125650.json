post_cb({"12126041": {"Id": "12126041", "PostTypeId": "2", "Body": "<p>You already got some answers about the representation of integer values. There is exactly one way that is guaranteed to give you all the individual bits of any object that is represented in memory: view it as array of <code>unsigned char</code>. This is the only integral type that has no padding bits and is guaranteed to have no trap representation. So casting a pointer of type <code>T*</code> to your object to <code>unsigned char*</code> will always work, as long as you only access the first <code>sizeof(T)</code> bytes. By that you could inspect and set all bytes (and thus bits) to your liking. </p>\n<p>If you are interested in more details, here I have written something up about the <a href=\"http://gustedt.wordpress.com/2010/09/21/anatomy-of-integer-types-in-c/\" rel=\"nofollow\">anatomy of integer types</a> in C. C++ might differ a bit from that, in particular type puning through <code>union</code> as described there doesn't seem to be well defined in C++.</p>\n", "LastActivityDate": "2012-08-25T22:10:01.350", "CommentCount": "0", "CreationDate": "2012-08-25T22:10:01.350", "ParentId": "12125650", "Score": "2", "OwnerUserId": "366377"}, "12125836": {"Id": "12125836", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_12125650_12125836_0\"><strong>(1)</strong> If all the bits in an integer type are zero, does the integer as whole represent zero?</p>\n</blockquote>\n<p>Yes, the bit pattern consisting of all zeroes always represents 0:</p>\n<blockquote>\n<p id=\"so_12125650_12125836_1\">The representations of integral types shall define values by use of a pure binary numeration system.<sup>49</sup> <strong>[\u00a73.9.1/7]</strong></p>\n<p id=\"so_12125650_12125836_2\"><sup>49</sup> A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin with 1, and are multiplied by successive integral power of 2, except perhaps for the bit with the highest position.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_12125650_12125836_3\"><strong>(2)</strong> If any bit in an integer type is one, does the integer as a whole represent non-zero? (if this is a \"yes\" then some representations like sign-and-magnitude would be additionally restricted)</p>\n</blockquote>\n<p>No. In fact, signed magnitude is specifically allowed:</p>\n<blockquote>\n<p id=\"so_12125650_12125836_4\">[ <em>Example:</em> this International Standard permits 2\u2019s complement, 1\u2019s complement and signed magnitude representations for integral types. <em>\u2014end\n  example</em> ] <strong>[\u00a73.9.1/7]</strong></p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_12125650_12125836_5\"><strong>(3)</strong> Is there a guaranteed way to check if any bit is not set?</p>\n</blockquote>\n<p>I <em>believe</em> the answer to this is \"no,\" if you consider signed types. It is equivalent to equality testing with a bit pattern of all ones, which is only possible if you have a way to produce a signed number with bit pattern of all ones. For an unsigned number this representation is guaranteed, but casting from unsigned to signed is undefined if the number is unrepresentable:</p>\n<blockquote>\n<p id=\"so_12125650_12125836_6\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined. <strong>[\u00a74.7/3]</strong></p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_12125650_12125836_7\"><strong>(4)</strong> Is there a guaranteed way to check if any bit is set?</p>\n</blockquote>\n<p>I don't think so, because signed magnitude is allowed\u20140 would compare equal to \u22120. But it should be possible with unsigned numbers.</p>\n<hr>\n<blockquote>\n<p id=\"so_12125650_12125836_8\"><strong>(5)</strong> Is there a guaranteed way to set the left-most and/or right-most bits?</p>\n</blockquote>\n<p>Again, I believe the answer is \"yes\" for unsigned numbers, but \"no\" for signed numbers. Shifts are undefined for negative signed numbers:</p>\n<blockquote>\n<p id=\"so_12125650_12125836_9\">Otherwise, if <code>E1</code> has a signed type and non-negative value, and E1 \u00d7 2<sup>E2</sup> is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined. <strong>[\u00a75.8/2]</strong></p>\n</blockquote>\n</hr></hr></hr></hr>", "LastActivityDate": "2012-08-25T21:35:06.290", "Score": "13", "CreationDate": "2012-08-25T21:35:06.290", "ParentId": "12125650", "CommentCount": "7", "OwnerUserId": "5696", "CommunityOwnedDate": "2012-08-25T21:35:06.290"}, "12125650": {"ViewCount": "2550", "Body": "<p>I know the C and C++ standards don't dictate a particular representation for numbers (could be two's complement, sign-and-magnitude, etc.). But I don't know the standards well enough (and couldn't find if it's stated) to know if there are any particular restrictions/guarantees/reserved representations made when working with bits. Particularly:</p>\n<ol>\n<li>If all the bits in an integer type are zero, does the integer as whole represent zero?</li>\n<li>If any bit in an integer type is one, does the integer as a whole represent non-zero? (if this is a \"yes\" then some representations like sign-and-magnitude would be additionally restricted)</li>\n<li>Is there a guaranteed way to check if any bit is not set?</li>\n<li>Is there a guaranteed way to check if any bit is set? (#3 and #4 kind of depend on #1 and #2, because I know how to set, for example the 5th bit (see #5) in some variable <code>x</code>, and I'd like to check a variable <code>y</code> to see if it's 5th bit is 1, I would like to know if <code>if (x &amp; y)</code> will work (because as I understand, this relies on the value of the representation and not whether nor not that bit is actually 1 or 0))</li>\n<li>Is there a guaranteed way to set the left-most and/or right-most bits? (At least a simpler way than taking a <code>char c</code> with all bits true (set by <code>c = c | ~c</code>) and doing <code>c = c &lt;&lt; (CHAR_BIT - 1)</code> for setting the high-bit and <code>c = c ^ (c &lt;&lt; 1)</code> for the low-bit, assuming I'm not making any assumptions I should't be, given these questions)</li>\n<li>If the answer to #1 is \"no\" how could one iterate over the bits in an integer type and check if each one was a 1 or a 0?</li>\n</ol>\n<p>I guess my overall question is: are there any restrictions/guarantees/reserved representations made by the C and C++ standards regarding bits and integers, despite the fact that an integer's representation is not mandated (and if the C and C++ standards differ in this regard, what's their difference)?</p>\n<p>I came up with these questions while doing my homework which required me to do some bit manipulating (note these aren't questions from my homework, these are much more \"abstract\").</p>\n<p><strong>Edit:</strong> As to what I refer to as \"bits,\" I mean \"value forming\" bits and am not including \"padding\" bits.</p>\n", "AcceptedAnswerId": "12125836", "Title": "What do the C and C++ standards say about bit-level integer representation and manipulation?", "CreationDate": "2012-08-25T21:04:46.377", "Id": "12125650", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-08-25T22:05:25.380", "LastEditorUserId": "1287251", "LastActivityDate": "2015-07-16T16:15:55.490", "Score": "16", "OwnerUserId": "1287251", "Tags": "<c++><c><language-lawyer>", "AnswerCount": "8"}, "28609218": {"Id": "28609218", "PostTypeId": "2", "Body": "<p>If you want your brain to explode, consider this: If you interpret an int or long or long long as an array of unsigned char (which is the most reasonable thing to do if you want to see all the bits), you know that the order of bytes is not defined, for example \"bigendian\" vs. \"littleendian\". We all (hopefully) know that. </p>\n<p>But it is worse: Each bit of an int could be stored in <em>any</em> of the bits of the array of char. So there are 32! ways how the bits of a 32 bit integer could be mapped to an array of four 8-bit unsigned chars by a truly bizarre implementation. Fortunately, I haven't encountered more than two ways myself (and I know of one more ordering in a real computer). </p>\n", "LastActivityDate": "2015-02-19T14:44:18.357", "CommentCount": "12", "CreationDate": "2015-02-19T14:44:18.357", "ParentId": "12125650", "Score": "0", "OwnerUserId": "3255455"}, "12125710": {"Id": "12125710", "PostTypeId": "2", "Body": "<p>For the bitmanipulations you could make a struct with 8 one unsigned bit fields and let the pointer of that struct point to your char. In that way you can easily access each bit. But the compiler will probably do masking under the hood, so it is only a cleaner way for the programmer I think. You must check that your compiler doesn't change the order of the fields when doing this.</p>\n<pre><code>yourstruct* pChar=(yourstruct*)(&amp;c)\npChar.Bit7=1;\n</code></pre>\n", "LastActivityDate": "2012-08-25T21:14:28.453", "CommentCount": "2", "CreationDate": "2012-08-25T21:14:28.453", "ParentId": "12125650", "Score": "-1", "OwnerUserId": "1625070"}, "12125717": {"Id": "12125717", "PostTypeId": "2", "Body": "<p>Let me caveat this by saying I'm addressing C and C++ in general (e.g. C90 and lower, MS Visual C++, etc): the \"greatest common denominator\" (vs. the latest/greatest cx11 \"standard\").</p>\n<p>Q: If all the bits in an integer type are zero, does the integer as whole represent zero?</p>\n<p>A: Yes</p>\n<p>Q: If any bit in an integer type is one, does the integer as a whole represent non-zero? (if this is a \"yes\" then some representations like sign-and-magnitude would be additionally restricted)</p>\n<p>A: Yes.  This includes the sign bit, for a signed int.\nI'm frankly not familiar with \"magnitude\"</p>\n<p>Q: Is there a guaranteed way to check if any bit is not set?</p>\n<p>A: \"And'ing\" a bitmask is always guaranteed.</p>\n<p>Q: Is there a guaranteed way to check if any bit is set?</p>\n<p>A: Again, \"and'ing\" a bitmask is always guaranteed.</p>\n<p>Q: Is there a guaranteed way to set the left-most and/or right-most bits?</p>\n<p>A: I believe you should always have a \"MAX_INT\" available for all implementations/all architectures to determine the leftmost bit.</p>\n<p>I'm prepared to be flamed ... but I believe the above is accurate.  And I hope it helps.</p>\n<p>IMHO...</p>\n", "LastActivityDate": "2012-08-25T21:15:02.530", "CommentCount": "6", "CreationDate": "2012-08-25T21:15:02.530", "ParentId": "12125650", "Score": "-1", "OwnerUserId": "421195"}, "bq_ids": {"n4140": {"so_12125650_12125836_1": {"length": 9, "quality": 0.75, "section_id": 7216}, "so_12125650_12125836_2": {"length": 21, "quality": 1.0, "section_id": 7216}, "so_12125650_12125836_6": {"length": 13, "quality": 0.8666666666666667, "section_id": 32}, "so_12125650_12125836_4": {"length": 9, "quality": 0.6428571428571429, "section_id": 7216}, "so_12125650_12125836_9": {"length": 14, "quality": 0.875, "section_id": 6147}}, "n3337": {"so_12125650_12125836_1": {"length": 9, "quality": 0.75, "section_id": 6960}, "so_12125650_12125836_2": {"length": 21, "quality": 1.0, "section_id": 6960}, "so_12125650_12125836_6": {"length": 13, "quality": 0.8666666666666667, "section_id": 29}, "so_12125650_12125836_4": {"length": 9, "quality": 0.6428571428571429, "section_id": 6960}, "so_12125650_12125836_9": {"length": 14, "quality": 0.875, "section_id": 5910}}, "n4659": {"so_12125650_12125836_1": {"length": 9, "quality": 0.75, "section_id": 8725}, "so_12125650_12125836_2": {"length": 21, "quality": 1.0, "section_id": 8725}, "so_12125650_12125836_6": {"length": 11, "quality": 0.7333333333333333, "section_id": 32}, "so_12125650_12125836_4": {"length": 9, "quality": 0.6428571428571429, "section_id": 8725}, "so_12125650_12125836_9": {"length": 14, "quality": 0.875, "section_id": 7643}}}, "12125881": {"Id": "12125881", "PostTypeId": "2", "Body": "<p>You use the term \"all bits\" repeatedly, but you do not clarify what \"all bits\" you are referring to. Object representation of integer types in C/C++ might include <em>value-forming bits</em> and <em>padding bits</em>. The only integer type that is guaranteed not to have padding bits is <code>[signed/unsigned] char</code>. </p>\n<p>The language always guaranteed that if all <em>value-forming</em> bits are zero, then the represented integer value is also zero.</p>\n<p>As for <em>padding</em> bits, things are/were a bit more complicated. The original specification of C language (C89/90 as well as the original C99) did not guarantee that setting all object bits to zero produced a valid integer representation. It could've produced an invalid <em>trap</em> representation. I.e. in the original C (and even in C99 at first) using <code>memset(..., 0, ...)</code> on integer types did not guarantee that the objects will receive valid zero values (with the exception of <code>[signed/unsigned] char</code>). This was changed in later specifications, namely in one of the technical corrigendums for C99. Now it is required that all-zero bit pattern in an integer object (that involves all bits, including padding ones) represents a valid zero value. </p>\n<p>I.e. in modern C it is legal to use <code>memset(..., 0, ...)</code> to set any integer objects to zero, but it became legal only after C99.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2012-08-25T21:48:08.120", "Score": "8", "CreationDate": "2012-08-25T21:42:59.257", "ParentId": "12125650", "CommentCount": "2", "OwnerUserId": "187690", "LastEditDate": "2012-08-25T21:48:08.120"}, "28322234": {"Id": "28322234", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_12125650_28322234_0\">If all the bits in an integer type are zero, does the integer as whole represent zero?</p>\n</blockquote>\n<p><strong>Edit</strong>: since you have now clarified that you are not concerned with the padding bits, the answer to this is actually \"yes\". But I leave the original:</p>\n<p>Not necessarily, it could be a trap representation. See C99 6.2.6.1:</p>\n<p><em>For unsigned integer types other than unsigned char, the bits of the object\nrepresentation shall be divided into two groups: value bits and padding bits (there need not be any of the latter)</em></p>\n<p>The presence of padding bits allows for the possibility that all 0 is a <em>trap representation</em>. (As noted by Keith Thompson in the comment below, the more recent C11 makes explicit that such a representation is not a trap representation).</p>\n<p>and</p>\n<p><em>The values of any padding bits are unspecified</em></p>\n<p>and</p>\n<p><em>44) Some combinations of padding bits might generate trap representations</em></p>\n<p>If you restrict the question to <em>value and sign</em> bits, the answer is yes, due to 6.2.6.2:</p>\n<p><em>If there are N value bits, each bit shall represent a different\npower of 2 between 1 and 2 N \u22121 , so that objects of that type shall be capable of representing values from 0 to 2 N \u2212 1 using a pure binary representation; this shall be known as the value representation.</em></p>\n<p>and</p>\n<p><em>If the sign bit is zero, it shall not affect the resulting value.</em></p>\n<blockquote>\n<p id=\"so_12125650_28322234_1\">If any bit in an integer type is one, does the integer as a whole represent non-zero? (if this is a \"yes\" then some representations like sign-and-magnitude would be additionally restricted)</p>\n</blockquote>\n<p>Not necessarily, and in fact sign-and-magnitude is explicitly supported in 6.2.6.2.</p>\n<blockquote>\n<p id=\"so_12125650_28322234_2\">Is there a guaranteed way to check if any bit is not set?</p>\n</blockquote>\n<p>If you do not care about padding and sign bits, you could just compare to 0, but this would not work with a 1's complement representation (which is allowed) seeing as all bits 0 and all bits 1 both represent the value 0.</p>\n<p>Otherwise: you can read the value of each byte via an <code>unsigned char *</code>, and compare the result to 0:</p>\n<p><em>Values stored in unsigned bit-fields and objects of type unsigned char\nshall be represented using a pure binary notation</em></p>\n<p>If you want to check a specific <em>value</em> bit, you could construct a suitable bitmask using (1u &lt;&lt; n), but this will not necessarily let you inspect the <em>sign</em> bit.</p>\n<blockquote>\n<p id=\"so_12125650_28322234_3\">Is there a guaranteed way to check if any bit is set? </p>\n</blockquote>\n<p>The answer is essentially the same as to the previous question.</p>\n<blockquote>\n<p id=\"so_12125650_28322234_4\">Is there a guaranteed way to set the left-most and/or right-most bits?</p>\n</blockquote>\n<p>Do you mean left-most <em>value</em> bit? You could count the bits in INT_MAX or UINT_MAX or equivalent depending on the type, and use that to construct a value (via <code>1 &lt;&lt; n</code>) with which to OR the original value.</p>\n<blockquote>\n<p id=\"so_12125650_28322234_5\">If the answer to #1 is \"no\" how could one iterate over the bits in an integer type and check if each one was a 1 or a 0?</p>\n</blockquote>\n<p>You can do so using a bitmask which you left shift repeatedly, but you can check only the <em>value</em> bits this way and not the <em>sign</em> bit.</p>\n", "LastEditorUserId": "388661", "LastActivityDate": "2015-07-16T16:15:55.490", "Score": "0", "CreationDate": "2015-02-04T13:08:30.607", "ParentId": "12125650", "CommentCount": "2", "OwnerUserId": "388661", "LastEditDate": "2015-07-16T16:15:55.490"}, "12125846": {"Id": "12125846", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_12125650_12125846_0\">Q: If any bit in an integer type is one, does the integer as a whole represent non-zero? (if this is a \"yes\" then some representations like sign-and-magnitude would be additionally restricted)</p>\n</blockquote>\n<p>No. The standards for C and C++ don't rule out signed magnitude or one's complement, both of which have +0 and -0. While +0 and -0 do have to compare equal, but they do not have to have the same representation.</p>\n<p>Good luck finding a machine nowadays that uses signed magnitude or one's complement.</p>\n", "LastActivityDate": "2012-08-25T21:36:59.540", "CommentCount": "0", "CreationDate": "2012-08-25T21:36:59.540", "ParentId": "12125650", "Score": "1", "OwnerUserId": "774499"}});