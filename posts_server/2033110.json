post_cb({"2033110": {"ViewCount": "47433", "Body": "<p>I want a class which takes two parameters in its constructor. The first can be either an int, double or float, so <code>&lt;typename T&gt;</code>, and the second is always a string literal \"my string\", so I guess const char * const.</p>\n<p>Can anyone give me some compilable code which declares a simple class template as described and declares an object of that class? </p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "2033112", "Title": "Passing a string literal as a parameter to a C++ template class", "CreationDate": "2010-01-09T10:57:34.433", "Id": "2033110", "CommentCount": "1", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2015-02-16T17:22:08.527", "LastEditorDisplayName": "anon", "LastEditorUserId": "72178", "LastActivityDate": "2017-07-27T09:29:30.960", "Score": "30", "OwnerUserId": "192910", "Tags": "<c++><templates>", "AnswerCount": "9"}, "2033395": {"Id": "2033395", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_2033110_2033395_0\">a string literal \"my string\", so I guess const char * const</p>\n</blockquote>\n<p>Actually, string literals with n visible characters are of type <code>const char[n+1]</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\ntemplate&lt;class T&gt;\nvoid test(const T&amp; t)\n{\n    std::cout &lt;&lt; typeid(t).name() &lt;&lt; std::endl;\n}\n\nint main()\n{\n    test(\"hello world\"); // prints A12_c on my compiler\n}\n</code></pre>\n", "LastActivityDate": "2010-01-09T12:46:05.663", "CommentCount": "1", "CreationDate": "2010-01-09T12:46:05.663", "ParentId": "2033110", "Score": "3", "OwnerUserId": "242346"}, "2033125": {"Id": "2033125", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_2033110_2033125_0\">I want a class which takes two parameters in its constructor. The first can be either an int, double or float, so , and the second is always a string literal \"my string\"</p>\n</blockquote>\n<pre><code>template&lt;typename T&gt;\nclass demo\n{\n   T data;\n   std::string s;\n\n   public:\n\n   demo(T d,std::string x=\"my string\"):data(d),s(x) //Your constructor\n   {\n   }\n};\n</code></pre>\n<p>I am not sure but is this something what you want?</p>\n", "LastEditorUserId": "165520", "LastActivityDate": "2010-01-09T11:11:32.373", "Score": "3", "CreationDate": "2010-01-09T11:03:57.950", "ParentId": "2033110", "CommentCount": "5", "OwnerUserId": "165520", "LastEditDate": "2010-01-09T11:11:32.373"}, "45346679": {"Id": "45346679", "PostTypeId": "2", "Body": "<p>You cannot pass a string literal directly as a template parameter.</p>\n<p>But you can get close:</p>\n<pre><code>template&lt;class MyString = typestring_is(\"Hello!\")&gt;\nvoid MyPrint() {\n  puts( MyString::data() );\n}\n\n...\n// or:\nMyPrint&lt;typestring_is(\"another text\")&gt;();\n...\n</code></pre>\n<p>All you need is a small header file from <a href=\"https://github.com/irrequietus/typestring\" rel=\"nofollow noreferrer\">here</a>.</p>\n<hr>\n<p><strong>Alternatives:</strong></p>\n<ul>\n<li><p>Define a global <code>char const *</code> and pass it to the template as pointer. (<a href=\"https://stackoverflow.com/a/1826505/4792058\">here</a>) </p>\n<p>Drawback: Requires additional code outside of the template argument list. It is not suitable, if you need to specify the string literal \"inline\".</p></li>\n<li><p>Use a non-standard language extension. (<a href=\"https://stackoverflow.com/a/28209546/4792058\">here</a>)</p>\n<p>Drawback: Not guaranteed to work with all compilers.</p></li>\n<li><p>Use <code>BOOST_METAPARSE_STRING</code>. (<a href=\"http://www.boost.org/doc/libs/1_64_0/doc/html/metaparse/user_manual.html\" rel=\"nofollow noreferrer\">here</a>)</p>\n<p>Drawback: Your code will depend on the Boost library.</p></li>\n<li><p>Use a variadic template parameter pack of char, e.g. <code>str_t&lt;'T','e','s','t'&gt;</code>.</p>\n<p>This is what the above solution does for you behind the scenes.</p></li>\n</ul>\n</hr>", "LastActivityDate": "2017-07-27T09:29:30.960", "CommentCount": "0", "CreationDate": "2017-07-27T09:29:30.960", "ParentId": "2033110", "Score": "2", "OwnerUserId": "4792058"}, "2055471": {"Id": "2055471", "PostTypeId": "2", "Body": "<p>Based on your comments under Niel's answer, another possibility is the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstatic const char* eventNames[] = { \"event_A\", \"event_B\" };\n\nenum EventId {\n        event_A = 0,\n        event_B\n};\n\ntemplate &lt;int EventId&gt;\nclass Event\n{\npublic:\n   Event() {\n     name_ = eventNames[EventId];\n   }\n   void print() {\n        std::cout &lt;&lt; name_ &lt;&lt; std::endl;\n   }\nprivate:\n   const char* name_;\n};\n\nint main()\n{\n        Event&lt;event_A&gt;().print();\n        Event&lt;event_B&gt;().print();\n}\n</code></pre>\n<p>prints</p>\n<pre><code>event_A\nevent_B\n</code></pre>\n", "LastActivityDate": "2010-01-13T09:01:45.277", "CommentCount": "4", "CreationDate": "2010-01-13T09:01:45.277", "ParentId": "2033110", "Score": "5", "OwnerUserId": "19501"}, "bq_ids": {"n4140": {"so_2033110_2033147_5": {"length": 4, "quality": 1.0, "section_id": 57}, "so_2033110_2033147_11": {"length": 24, "quality": 0.9230769230769231, "section_id": 87}, "so_2033110_2033147_12": {"length": 4, "quality": 0.8, "section_id": 87}, "so_2033110_2033395_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 5356}, "so_2033110_2033147_13": {"length": 9, "quality": 0.8181818181818182, "section_id": 88}, "so_2033110_2033147_8": {"length": 5, "quality": 1.0, "section_id": 87}, "so_2033110_2033147_9": {"length": 4, "quality": 0.8, "section_id": 676}, "so_2033110_2033147_4": {"length": 4, "quality": 1.0, "section_id": 57}, "so_2033110_2033147_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 57}}, "n3337": {"so_2033110_2033147_5": {"length": 4, "quality": 1.0, "section_id": 52}, "so_2033110_2033147_11": {"length": 23, "quality": 0.8846153846153846, "section_id": 82}, "so_2033110_2033147_4": {"length": 4, "quality": 1.0, "section_id": 52}, "so_2033110_2033147_8": {"length": 5, "quality": 1.0, "section_id": 82}, "so_2033110_2033147_13": {"length": 9, "quality": 0.8181818181818182, "section_id": 83}, "so_2033110_2033147_9": {"length": 4, "quality": 0.8, "section_id": 666}, "so_2033110_2033147_12": {"length": 4, "quality": 0.8, "section_id": 82}, "so_2033110_2033147_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 52}, "so_2033110_2033395_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 5153}}, "n4659": {"so_2033110_2033147_5": {"length": 4, "quality": 1.0, "section_id": 59}, "so_2033110_2033147_4": {"length": 4, "quality": 1.0, "section_id": 59}, "so_2033110_2033395_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 2940}, "so_2033110_2033147_9": {"length": 4, "quality": 0.8, "section_id": 704}, "so_2033110_2033147_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 59}}}, "2033147": {"Id": "2033147", "PostTypeId": "2", "Body": "<p>EDIT: ok the title of your question seems to be misleading</p>\n<blockquote>\n<p id=\"so_2033110_2033147_0\">\"I want a class which takes two parameters in its constructor. The first can be either an int, double or float, so , and the second is always a string literal \"my string\", so I guess const char * const.\"</p>\n</blockquote>\n<p>It looks like you're trying to achieve:</p>\n<pre><code>template&lt;typename T&gt;\nclass Foo\n{\n  public:\n  Foo(T t,  const char* s) : first(t), second(s)\n  {\n    // do something\n  }\n\n  private:\n  T first;\n  const char* second;\n\n};\n</code></pre>\n<p>This would work for any type, for the first parameter: <code>int</code>, <code>float</code>, <code>double</code>, whatever.</p>\n<p>Now if you really want to restrict the type of the first parameter to be only <code>int</code>, <code>float</code> or <code>double</code>; you can come up with something more elaborate like</p>\n<pre><code>template&lt;typename T&gt;\nstruct RestrictType;\n\ntemplate&lt;&gt;\nstruct RestrictType&lt;int&gt;\n{\n  typedef int Type;\n};\n\ntemplate&lt;&gt;\nstruct RestrictType&lt;float&gt;\n{\n  typedef float Type;\n};\n\ntemplate&lt;&gt;\nstruct RestrictType&lt;double&gt;\n{\n  typedef double Type;\n};\n\ntemplate&lt;typename T&gt;\nclass Foo\n{\n  typedef typename RestrictType&lt;T&gt;::Type FirstType;\n\n  public:\n  Foo(FirstType t,  const char* s) : first(t), second(s)\n  {\n    // do something\n  }\n\n  private:\n  FirstType first;\n  const char* second;\n\n};\n\nint main()\n{\n  Foo&lt;int&gt; f1(0, \"can\");\n  Foo&lt;float&gt; f2(1, \"i\");\n  Foo&lt;double&gt; f3(1, \"have\");\n  //Foo&lt;char&gt; f4(0, \"a pony?\");\n}\n</code></pre>\n<p>If you remove the comment on the last line, you'll effectively get a compiler error.</p>\n<hr>\n<p>String literals are not allowed by C++2003</p>\n<p>ISO/IEC 14882-2003 \u00a714.1:</p>\n<blockquote>\n<p id=\"so_2033110_2033147_1\"><strong>14.1 Template parameters</strong></p>\n<p id=\"so_2033110_2033147_2\">A non-type template-parameter shall have one of the following (optionallycv-qualified) types:</p>\n<p id=\"so_2033110_2033147_3\">\u2014 integral or enumeration type, </p>\n<p id=\"so_2033110_2033147_4\">\u2014 pointer to object or pointer to function, </p>\n<p id=\"so_2033110_2033147_5\">\u2014 reference to object or reference to function, </p>\n<p id=\"so_2033110_2033147_6\">\u2014 pointer to member. </p>\n</blockquote>\n<p>ISO/IEC 14882-2003 \u00a714.3.2:</p>\n<blockquote>\n<p id=\"so_2033110_2033147_7\"><strong>14.3.2 Template non-type arguments</strong></p>\n<p id=\"so_2033110_2033147_8\">A template-argument for a non-type, non-template template-parameter shall be one of: </p>\n<p id=\"so_2033110_2033147_9\">\u2014 an integral constant-expression of integral or enumeration type; or</p>\n<p id=\"so_2033110_2033147_10\">\u2014 the name of a non-type template-parameter; or </p>\n<p id=\"so_2033110_2033147_11\">\u2014 the address of an object or function with external linkage, including function templates and function template-ids but excluding non-static class members, expressed as &amp; id expression where the &amp; is optional if the name refers to a function or array, or if the corresponding template-parameter is a reference; or</p>\n<p id=\"so_2033110_2033147_12\">\u2014 a pointer to member expressed as described in 5.3.1.</p>\n<p id=\"so_2033110_2033147_13\">[Note:A string literal (2.13.4) does not satisfy the requirements of any of these categories and thus is not an acceptable template-argument.</p>\n<p id=\"so_2033110_2033147_14\">[Example: </p>\n</blockquote>\n<pre><code>template&lt;class T, char* p&gt; class X { \n  //... \n  X(); \n  X(const char* q) { /* ... */ } \n}; \n\nX&lt;int,\"Studebaker\"&gt; x1; //error: string literal as template-argument \nchar p[] = \"Vivisectionist\"; \nX&lt;int,p&gt; x2; //OK \n</code></pre>\n<blockquote>\n<p id=\"so_2033110_2033147_15\">\u2014end example] \u2014end note] </p>\n</blockquote>\n<p>And it looks like it's not going to change in the upcoming C++0X, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf\" rel=\"nofollow noreferrer\">see the current draft 14.4.2 Template non-type arguments</a>.</p>\n</hr>", "LastEditorUserId": "216063", "LastActivityDate": "2010-01-09T13:31:03.653", "Score": "3", "CreationDate": "2010-01-09T11:15:45.190", "ParentId": "2033110", "CommentCount": "3", "OwnerUserId": "216063", "LastEditDate": "2010-01-09T13:31:03.653"}, "2033112": {"Id": "2033112", "PostTypeId": "2", "Body": "<p>Sorry, C++ does not currently support the use of string literals (or real literals) as template parameters.</p>\n<p>But re-reading your question, is that what you are asking? You cannot say:</p>\n<pre><code>foo &lt;\"bar\"&gt; x;\n</code></pre>\n<p>but you can say</p>\n<pre><code>template &lt;typename T&gt;\nstruct foo {\n   foo( T t ) {}\n};\n\nfoo &lt;const char *&gt; f( \"bar\" );\n</code></pre>\n", "LastEditorDisplayName": "anon", "OwnerDisplayName": "anon", "LastActivityDate": "2010-01-09T11:04:32.710", "Score": "20", "CreationDate": "2010-01-09T10:58:40.990", "ParentId": "2033110", "CommentCount": "10", "LastEditDate": "2010-01-09T11:04:32.710"}, "18154638": {"Id": "18154638", "PostTypeId": "2", "Body": "<p>This is a solution with MPLLIBS to pass a strings as template arguments ( C++11 ).</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;mpllibs/metaparse/string.hpp&gt; // https://github.com/sabel83/mpllibs\n#include &lt;boost/mpl/string.hpp&gt;\n\n// -std=c++11\n\ntemplate&lt;class a_mpl_string&gt;\nstruct A\n{\n  static const char* string;\n};\n\ntemplate&lt;class a_mpl_string&gt;\nconst char* A&lt; a_mpl_string &gt;\n::string { boost::mpl::c_str&lt; a_mpl_string &gt;::value };  // boost compatible\n\ntypedef A&lt; MPLLIBS_STRING ( \"any string as template argument\" ) &gt; a_string_type;\n\nint main ( int argc, char **argv )\n{\n  std::cout &lt;&lt; a_string_type{}.string &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p>prints:</p>\n<pre><code>any string as template argument\n</code></pre>\n<p>The lib on github: <a href=\"https://github.com/sabel83/mpllibs\">https://github.com/sabel83/mpllibs</a></p>\n", "LastEditorUserId": "2669105", "LastActivityDate": "2013-09-06T19:31:23.120", "Score": "11", "CreationDate": "2013-08-09T19:55:27.440", "ParentId": "2033110", "CommentCount": "0", "OwnerUserId": "2669105", "LastEditDate": "2013-09-06T19:31:23.120"}, "2033318": {"Id": "2033318", "PostTypeId": "2", "Body": "<p>Further from Neil's answer: one way to using strings with templates as you want is to define a traits class and define the string as a trait of the type.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt;\nstruct MyTypeTraits\n{\n   static const char* name;\n};\n\ntemplate &lt;class T&gt;\nconst char* MyTypeTraits&lt;T&gt;::name = \"Hello\";\n\ntemplate &lt;&gt;\nstruct MyTypeTraits&lt;int&gt;\n{\n   static const char* name;\n};\n\nconst char* MyTypeTraits&lt;int&gt;::name = \"Hello int\";\n\ntemplate &lt;class T&gt;\nclass MyTemplateClass\n{\n    public:\n     void print() {\n         std::cout &lt;&lt; \"My name is: \" &lt;&lt; MyTypeTraits&lt;T&gt;::name &lt;&lt; std::endl;\n     }\n};\n\nint main()\n{\n     MyTemplateClass&lt;int&gt;().print();\n     MyTemplateClass&lt;char&gt;().print();\n}\n</code></pre>\n<p>prints </p>\n<pre><code>My name is: Hello int\nMy name is: Hello\n</code></pre>\n", "LastActivityDate": "2010-01-09T12:23:11.613", "CommentCount": "5", "CreationDate": "2010-01-09T12:23:11.613", "ParentId": "2033110", "Score": "32", "OwnerUserId": "19501"}, "5499902": {"Id": "5499902", "PostTypeId": "2", "Body": "<pre><code>inline const wchar_t *GetTheStringYouWant() { return L\"The String You Want\"; }\n\ntemplate &lt;const wchar_t *GetLiteralFunc(void)&gt;\nclass MyType\n{\n     void test()\n     {\n           std::cout &lt;&lt; GetLiteralFunc;\n     }    \n}\n\nint main()\n{\n     MyType&lt;GetTheStringYouWant&gt;.test();\n}\n</code></pre>\n<p>Try it with pasing the address of a function as the template argument.</p>\n", "LastEditorUserId": "685712", "LastActivityDate": "2014-01-07T14:42:32.583", "Score": "10", "CreationDate": "2011-03-31T12:33:05.187", "ParentId": "2033110", "CommentCount": "0", "OwnerUserId": "685712", "LastEditDate": "2014-01-07T14:42:32.583"}});