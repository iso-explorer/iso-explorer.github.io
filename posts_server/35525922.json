post_cb({"35526054": {"Id": "35526054", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_35525922_35526054_0\">Now, what will happen over the address #1, #2 after executing delete; (in the code) please?</p>\n</blockquote>\n<p>The pointer <code>p</code> will have an undefined value, but it'll keep its address (\"#1\").</p>\n<p>The <code>int</code> object at <code>*p</code> (with address \"#2\") no longer exists. That address now describes memory that is free for use in future allocations.</p>\n<hr>\n<blockquote>\n<p id=\"so_35525922_35526054_1\">What does the C++ language say about this?</p>\n</blockquote>\n<p>This:</p>\n<blockquote>\n<p id=\"so_35525922_35526054_2\"><code>[C++14: 5.3.5/1]</code>: The delete-expression operator destroys a most derived object (1.8) or array created by a new-expression. <em>[..]</em></p>\n<p id=\"so_35525922_35526054_3\"><code>[C++14: 5.3.5/7]:</code> If the value of the operand of the delete-expression is not a null pointer value, then:</p>\n<ul>\n<li>If the allocation call for the new-expression for the object to be deleted was not omitted (5.3.4), the delete-expression shall call a deallocation function (3.7.4.2). The value returned from the allocation call of the new-expression shall be passed as the first argument to the deallocation function.</li>\n<li>Otherwise, the delete-expression will not call a deallocation function (3.7.4.2).</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_35525922_35526054_4\">And what can be the effect of various compilers on the case?</p>\n</blockquote>\n<p>Provided they are compliant, none. All compilers must behave the same way.</p>\n</hr></hr>", "LastEditorUserId": "560648", "LastActivityDate": "2016-02-20T17:01:28.887", "Score": "3", "CreationDate": "2016-02-20T16:44:06.303", "ParentId": "35525922", "CommentCount": "4", "OwnerUserId": "560648", "LastEditDate": "2016-02-20T17:01:28.887"}, "35526039": {"Id": "35526039", "PostTypeId": "2", "Body": "<pre><code>int main() {\n    int* p;             // p is at address #1 and the value uninitialized. p will\n                        // be at address #1 throughout the whole program.\n                        // It is only the value of p that can change.\n\n    p = new int(6);     // The value of p is set to address #2 and your\n                        // program now has ownership of sizeof(int) bytes\n                        // starting from address #2. The int at address #2\n                        // is initialized with the value 6.\n    cout &lt;&lt; *p &lt;&lt; endl;\n\n    delete p;           // Your program releases ownership of the memory at\n                        // address #2 and you are not allowed to use it anymore.\n                        // The value of p is undefined.\n\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "4386427", "LastActivityDate": "2016-02-20T17:07:33.693", "Score": "3", "CreationDate": "2016-02-20T16:42:29.460", "ParentId": "35525922", "CommentCount": "2", "OwnerUserId": "4386427", "LastEditDate": "2016-02-20T17:07:33.693"}, "35526046": {"Id": "35526046", "PostTypeId": "2", "Body": "<p>After <code>delete p</code> ,<code>p</code> still has the same address it used to. The object has gone, so it has no address. The bytes it used to occupy may be used for something else or may have been returned to the OS; there's no way you can look at them without invoking undefined behaviour.</p>\n<p>The value of <code>p</code> is no longer useful - and you can't do much with <code>p</code>, except assigning a new value to it or let it be destroyed.</p>\n<p>That's what the language says, and the compilers implement it.</p>\n<p>Lot more details here: <a href=\"http://en.cppreference.com/w/cpp/language/delete\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/delete</a></p>\n", "LastActivityDate": "2016-02-20T16:43:29.783", "CommentCount": "4", "CreationDate": "2016-02-20T16:43:29.783", "ParentId": "35525922", "Score": "2", "OwnerUserId": "212870"}, "bq_ids": {"n4140": {"so_35525922_35526054_3": {"length": 7, "quality": 0.7777777777777778, "section_id": 6111}, "so_35525922_35526054_2": {"length": 9, "quality": 0.75, "section_id": 6105}}, "n3337": {"so_35525922_35526054_3": {"length": 6, "quality": 0.6666666666666666, "section_id": 5876}, "so_35525922_35526054_2": {"length": 9, "quality": 0.75, "section_id": 5871}}, "n4659": {"so_35525922_35526054_3": {"length": 7, "quality": 0.7777777777777778, "section_id": 7608}, "so_35525922_35526054_2": {"length": 9, "quality": 0.75, "section_id": 7602}}}, "35525922": {"ViewCount": "77", "Body": "<p>I've heard much about <em>the C++</em> <code>delete</code> <em>operator</em> and also have used it a lot so far but I don't know what its real work is exactly.<br>\nWhat I have seen on the web have been the talks on \"Deallocating storage space\" about it, but it does not make sense well to me for understanding the issue completely.     </br></p>\n<p>Please have a look at the snippet of code below.  </p>\n<pre><code>int main()\n{\n   int* p = new int(6);\n   cout &lt;&lt; *p &lt;&lt; endl;\n   delete p;\n}\n</code></pre>\n<p>The pointer <code>p</code> has its own address, since it's a variable (#1). The pointer <code>p</code>, too, has an address inside itself because it's a pointer(#2). The object (unnamed), contains the value 6 inside its memory block, and the address of that memory block is the same as the address of <code>#2</code>. (Because the pointer points to that object using that address.)</p>\n<p>Now, what will happen to the addresses #1 and #2 after executing <code>delete;</code>?<br>\nWhat does the C++ language say about this?<br>\nAnd what can be the effect of various compilers on the case?</br></br></p>\n", "AcceptedAnswerId": "35526054", "Title": "the exact operation of the delete operator", "CreationDate": "2016-02-20T16:33:08.790", "Id": "35525922", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-02-20T16:47:09.020", "LastEditorUserId": "560648", "LastActivityDate": "2016-02-20T17:07:33.693", "Score": "2", "OwnerUserId": "4989541", "Tags": "<c++><pointers><delete-operator>", "AnswerCount": "4"}, "35525986": {"Id": "35525986", "PostTypeId": "2", "Body": "<p>Regarding</p>\n<blockquote>\n<p id=\"so_35525922_35525986_0\"><strong>\u201d</strong> The exact operation of the delete operator</p>\n</blockquote>\n<p>Example code in the question:</p>\n<pre><code>delete p;\n</code></pre>\n<p>That's a <code>delete</code> <strong>expression</strong>, not direct a call of the <code>delete</code> <strong>operator</strong>. The operator is a deallocation function that's usually called by a <code>delete</code> expression, after the <code>delete</code> expression calls an object destructor (or for an array, a sequence of such). Here's what happens:</p>\n<ol>\n<li><p>If <code>p</code> points to an object of class type then its destructor is called to clean up things, e.g. to free resources.</p></li>\n<li><p>The relevant deallocation function, an <code>operator delete</code>, is called to free the memory. This is usually the global <code>operator delete</code>, but it can be an <code>operator delete</code> defined by the class in question.</p></li>\n</ol>\n<p>Worth noting that for a placement <code>new</code> expression the placement deallocation function is called, with the same allocator arguments, if construction fails during evaluation of that <code>new</code> expression, but a later <code>delete</code> expression only calls the ordinary standard argument <code>operator delete</code>. I do not know the rationale for this. But it has led to some errors, in particular an infamous one in MFC that manifested only in debug builds, where memory was leaked.</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2016-02-20T16:45:37.710", "Score": "2", "CreationDate": "2016-02-20T16:38:01.317", "ParentId": "35525922", "CommentCount": "0", "OwnerUserId": "464581", "LastEditDate": "2016-02-20T16:45:37.710"}});