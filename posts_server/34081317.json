post_cb({"34082287": {"ParentId": "34081317", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I note that the code in the question is C++ code and not C code.  However, the question is dual-tagged with C and C++, which is irksome since the rules for C and C++ are different.</p>\n<h2>The code fails to compile in C++ but equivalent code compiles in C</h2>\n<p>The C++ code in the question should not compile.  Analogous code written in C should compile, but the net result is an infinite loop.</p>\n<h2>C++11</h2>\n<p>In ISO/IEC 14882:2011 (the C++11 standard; I don't have an official copy of the 2014 standard to report on), it says:</p>\n<blockquote>\n<h3>6.6.4 The goto statement [stmt.goto]</h3>\n<p id=\"so_34081317_34082287_0\">\u00b61 The <code>goto</code> statement unconditionally transfers control to the statement labeled by the identifier. The identifier shall be a label (6.1) located in the current function.</p>\n<h3>6.7 Declaration statement [stmt.dcl]</h3>\n<p id=\"so_34081317_34082287_1\">\u00b61 A declaration statement introduces one or more new identifiers into a block; it has the form declaration-statement:\n  block-declaration\n  If an identifier introduced by a declaration was previously declared in an outer block, the outer declaration is hidden for the remainder of the block, after which it resumes its force.</p>\n<p id=\"so_34081317_34082287_2\">\u00b62 Variables with automatic storage duration (3.7.3) are initialized each time their declaration-statement is executed. Variables with automatic storage duration declared in the block are destroyed on exit from the block (6.6).</p>\n<p id=\"so_34081317_34082287_3\">\u00b63 It is possible to transfer into a block, but not in a way that bypasses declarations with initialization. A program that jumps<sup>87</sup> from a point where a variable with automatic storage duration is not in scope to a point where it is in scope is ill-formed unless the variable has scalar type, class type with a trivial default constructor and a trivial destructor, a cv-qualified version of one of these types, or an array of one of the preceding types and is declared without an initializer (8.5).</p>\n<p id=\"so_34081317_34082287_4\"><sup>87)  The transfer from the condition of a switch statement to a case label is considered a jump in this respect.</sup></p>\n</blockquote>\n<p>Although a plain <code>int</code> is a scalar type, the jump bypasses the initialization and so is not allowed.</p>\n<h2>C11</h2>\n<p>In ISO/IEC 9899:2011 (the C11 standard), it says:</p>\n<blockquote>\n<h3>6.8.6.1 The <code>goto</code> statement</h3>\n<p id=\"so_34081317_34082287_5\"><strong>Constraints</strong><br>\n  \u00b61 The identifier in a <code>goto</code> statement shall name a label located somewhere in the enclosing function. A <code>goto</code> statement shall not jump from outside the scope of an identifier having a variably modified type to inside the scope of that identifier.</br></p>\n<p id=\"so_34081317_34082287_6\"><strong>Semantics</strong><br>\n  \u00b62 A goto statement causes an unconditional jump to the statement prefixed by the named label in the enclosing function.</br></p>\n</blockquote>\n<p>Note that constraint violations require a diagnostic.  Violations of rules in semantics sections do not require a diagnostic.</p>\n<p>And in <strong>Annex I (Common Warnings)</strong>, which is an informative annex and not a normative one, it says:</p>\n<blockquote>\n<p id=\"so_34081317_34082287_7\">\u2014 A block with initialization of an object that has automatic storage duration is jumped into (6.2.4).</p>\n</blockquote>\n<p>And</p>\n<blockquote>\n<h3>6.2.4 Storage durations of objects</h3>\n<p id=\"so_34081317_34082287_8\">\u00b65 An object whose identifier is declared with no linkage and without the storage-class specifier <code>static</code> has <em>automatic storage duration</em>, as do some compound literals. The result of attempting to indirectly access an object with automatic storage duration from a thread other than the one with which the object is associated is implementation-defined.</p>\n<p id=\"so_34081317_34082287_9\">\u00b66 For such an object that does not have a variable length array type, its lifetime extends from entry into the block with which it is associated until execution of that block ends in any way. (Entering an enclosed block or calling a function suspends, but does not end, execution of the current block.) If the block is entered recursively, a new instance of the object is created each time. The initial value of the object is indeterminate. If an initialization is specified for the object, it is performed each time the declaration or compound literal is reached in the execution of the block; otherwise, the value becomes indeterminate each time the declaration is reached.</p>\n<p id=\"so_34081317_34082287_10\">\u00b67 For such an object that does have a variable length array type, its lifetime extends from the declaration of the object until execution of the program leaves the scope of the declaration.<sup>35)</sup> If the scope is entered recursively, a new instance of the object is created each time. The initial value of the object is indeterminate.</p>\n<p id=\"so_34081317_34082287_11\"><sup>35) Leaving the innermost block containing the declaration, or jumping to a point in that block or an embedded block prior to the declaration, leaves the scope of the declaration.</sup></p>\n</blockquote>\n<p>Note that there is no variably modified type (no VLA or <em>variable length array</em>) in the code in the question.  Standard C++ does not support the concept of VLAs (though the GNU C++ compiler does allow them as an extension).</p>\n<p>Code (<code>goto1.c</code>):</p>\n<pre><code>#include &lt;stdio.h&gt;\nint main(void)\n{\n    {\n        int a = 10;\ntag:\n        printf(\"%d\\n\", a);\n    }\n    goto tag;\n    return 0;\n}\n</code></pre>\n<p>Sample compilation:</p>\n<pre><code>$ gcc -std=c11 -O3 -g -Wall -Wextra -Werror goto1.c -o goto1\n$\n</code></pre>\n<p>Those are fairly stringent warning options, and GCC utters not a peep \u2014 which is permissible behaviour given what the C standard says.</p>\n", "OwnerUserId": "15168", "LastEditorUserId": "15168", "LastEditDate": "2015-12-04T07:32:04.610", "Id": "34082287", "Score": "4", "CreationDate": "2015-12-04T06:34:24.180", "LastActivityDate": "2015-12-04T07:32:04.610"}, "34081317": {"CommentCount": "2", "AcceptedAnswerId": "34082287", "PostTypeId": "1", "LastEditorUserId": "1505939", "CreationDate": "2015-12-04T05:12:36.280", "LastActivityDate": "2015-12-04T07:44:53.430", "LastEditDate": "2015-12-04T07:44:53.430", "ViewCount": "106", "FavoriteCount": "0", "Title": "Is goto from outside a block past an initialized variable declaration guaranteed to give a compile error?", "Id": "34081317", "Score": "0", "Body": "<p>I have some simple C++ code:</p>\n<pre><code>#include &lt;iostream&gt;\nint main(){\n   {\n     int a = 10;\n     tag:\n     std::cout &lt;&lt; a &lt;&lt; std::endl;\n    }\n     goto tag;\n    return 0;\n }\n</code></pre>\n<p>Now I know it is not a good idea to use <code>goto</code> and if I jump with <code>goto</code> to some other scope, I will get compile error. I have tried this and it is naturally giving me a compile error which is obvious. <strong>But my question is whether there is any way for which this may get into some infinite loop</strong></p>\n<p>I am asking this question because of this <a href=\"https://www.quora.com/Why-doesnt-following-C++-code-give-any-compile-or-run-time-error\" rel=\"nofollow\"><strong>question</strong></a></p>\n", "Tags": "<c++>", "OwnerUserId": "4037927", "AnswerCount": "2"}, "34081365": {"ParentId": "34081317", "CommentCount": "0", "Body": "<p>As the first comment to the question you mention says, the behavior is undefined. That basically means every compiler is free to interpret your code however it wants. Clearly, your compiler sees the problem and throws an error, while a different compiler may allow the code to compile, especially if it's internal representation of scope allows the loop to happen.</p>\n", "OwnerUserId": "2988730", "PostTypeId": "2", "Id": "34081365", "Score": "0", "CreationDate": "2015-12-04T05:17:03.237", "LastActivityDate": "2015-12-04T05:17:03.237"}, "bq_ids": {"n4140": {"so_34081317_34082287_0": {"section_id": 3915, "quality": 0.8666666666666667, "length": 13}, "so_34081317_34082287_3": {"section_id": 3918, "quality": 0.9512195121951219, "length": 39}, "so_34081317_34082287_7": {"section_id": 382, "quality": 0.6666666666666666, "length": 6}, "so_34081317_34082287_1": {"section_id": 3916, "quality": 0.9655172413793104, "length": 28}, "so_34081317_34082287_2": {"section_id": 3917, "quality": 0.95, "length": 19}, "so_34081317_34082287_4": {"section_id": 3918, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_34081317_34082287_0": {"section_id": 3775, "quality": 0.8666666666666667, "length": 13}, "so_34081317_34082287_3": {"section_id": 3778, "quality": 0.9512195121951219, "length": 39}, "so_34081317_34082287_7": {"section_id": 3161, "quality": 0.5555555555555556, "length": 5}, "so_34081317_34082287_1": {"section_id": 3776, "quality": 0.9655172413793104, "length": 28}, "so_34081317_34082287_2": {"section_id": 3777, "quality": 0.95, "length": 19}, "so_34081317_34082287_4": {"section_id": 3778, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_34081317_34082287_0": {"section_id": 4801, "quality": 0.8666666666666667, "length": 13}, "so_34081317_34082287_2": {"section_id": 4803, "quality": 0.95, "length": 19}, "so_34081317_34082287_7": {"section_id": 7687, "quality": 0.6666666666666666, "length": 6}, "so_34081317_34082287_1": {"section_id": 4802, "quality": 0.9655172413793104, "length": 28}, "so_34081317_34082287_3": {"section_id": 4804, "quality": 0.975609756097561, "length": 40}, "so_34081317_34082287_4": {"section_id": 4804, "quality": 0.8888888888888888, "length": 8}}}});