post_cb({"7731106": {"Id": "7731106", "PostTypeId": "2", "Body": "<p>\u00a7 14.7.1\\1 Implicit instantiation [temp.inst]  </p>\n<blockquote>\n<p id=\"so_7730874_7731106_0\"><strong>Unless a class template specialization has been explicitly\n  instantiated (14.7.2) or explicitly specialized (14.7.3), the class\n  template specialization is implicitly instantiated when the\n  specialization is referenced in a context that requires a\n  completely-defined object type or when the completeness of the class\n  type affects the semantics of the program.</strong> The implicit instantiation\n  of a class template specialization causes the implicit instantiation\n  of the declarations, but not of the definitions or default arguments,\n  of the class member functions, member classes, static data members and\n  member templates; and it causes the implicit instantiation of the\n  definitions of member anonymous unions. Unless a member of a class\n  template or a member template has been explicitly instantiated or\n  explicitly specialized, <strong>the specialization of the member is implicitly\n  instantiated when the specialization is referenced in a context that\n  requires the member definition to exist;</strong> in particular, the\n  initialization (and any associated side-effects) of a static data\n  member does not occur unless the static data member is itself used in\n  a way that requires the definition of the static data member to exist.</p>\n</blockquote>\n<p>\u00a7 8.3.5\\9 Functions [dcl.fct]</p>\n<blockquote>\n<p id=\"so_7730874_7731106_1\">Types shall not be defined in return or parameter types. The type of a\n  parameter or the return type for a function <strong>definition</strong> shall not be an\n  incomplete class type (possibly cv-qualified) unless the function\n  definition is nested within the member-specification for that class\n  (including definitions in nested classes defined within the class).</p>\n</blockquote>\n<p>\u00a7 3.1\\2 Declarations and definitions [basic.def]</p>\n<blockquote>\n<p id=\"so_7730874_7731106_2\"><strong>A declaration is a definition unless it declares a function without\n  specifying the function\u2019s body (8.4),</strong> it contains the extern specifier\n  (7.1.1) or a linkage-specification25 (7.5) and neither an initializer\n  nor a function-body, it declares a static data member in a class\n  definition (9.4), it is a class name declaration (9.1), it is an\n  opaque-enum-declaration (7.2), <strong>or it is a typedef declaration (7.1.3),</strong>\n  a using-declaration (7.3.3), a static_assert-declaration (Clause 7),\n  an attribute-declaration (Clause 7), an empty-declaration (Clause 7),\n  or a using-directive (7.3.4).</p>\n</blockquote>\n<p>It's only instantiated if it's <em>required</em>.  I couldn't find a clear definition anywhere, but the second quote says that those declaratations are not definitions, which seems to be the same to me.</p>\n", "LastEditorUserId": "845092", "LastActivityDate": "2011-10-11T19:44:53.123", "Score": "5", "CreationDate": "2011-10-11T19:02:04.923", "ParentId": "7730874", "CommentCount": "6", "OwnerUserId": "845092", "LastEditDate": "2011-10-11T19:44:53.123"}, "bq_ids": {"n4140": {"so_7730874_7731106_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 3245}, "so_7730874_9148408_0": {"length": 24, "quality": 0.96, "section_id": 3245}, "so_7730874_7731106_2": {"length": 33, "quality": 0.8461538461538461, "section_id": 7034}, "so_7730874_7731106_0": {"length": 60, "quality": 0.5769230769230769, "section_id": 233}, "so_7730874_7730874_0": {"length": 12, "quality": 0.75, "section_id": 6324}}, "n3337": {"so_7730874_7731106_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 3118}, "so_7730874_9148408_0": {"length": 24, "quality": 0.96, "section_id": 3118}, "so_7730874_7731106_2": {"length": 33, "quality": 0.8461538461538461, "section_id": 6780}, "so_7730874_7731106_0": {"length": 60, "quality": 0.5769230769230769, "section_id": 226}, "so_7730874_7730874_0": {"length": 12, "quality": 0.75, "section_id": 6081}}, "n4659": {"so_7730874_7731106_1": {"length": 16, "quality": 0.5333333333333333, "section_id": 4003}, "so_7730874_7731106_2": {"length": 33, "quality": 0.8461538461538461, "section_id": 8531}, "so_7730874_7730874_0": {"length": 12, "quality": 0.75, "section_id": 7834}}}, "9148408": {"Id": "9148408", "PostTypeId": "2", "Body": "<p>No, it does not instantiate the template. Mooing Duck's answer provides all the necessary quotes, but here is some analysis.</p>\n<p>Instantiation, by default, cannot occur if nothing exists to require a completely-defined type (\u00a714.7.1/1). Function definitions specifically require complete types (\u00a78.3.5/9), but the question is whether some other part of the standard also requires this for other declarations.</p>\n<p>But there's a special exception for definitions, which reveals that non-definition declarations really are different:</p>\n<blockquote>\n<p id=\"so_7730874_9148408_0\">The type of a parameter or the return type for a function definition shall not be an incomplete class type (possibly cv-qualified) unless the function definition is nested within the member-specification for that class (including definitions in nested classes defined within the class).</p>\n</blockquote>\n<p>What's special about function definitions inside member-specifications? Because a member-specification cannot declare the same function twice (\u00a79.2/1), and member function bodies are processed after all member declarations (\u00a73.3.7/1.1). Essentially, a nested member function definition is treated as a declaration during the first pass, and then a definition once the entire member-specification has been processed, and the class is complete (\u00a79.2/2). And \u00a78.3.5/9 specifies that an incomplete class is permissible for that first pass, but not the second.</p>\n<p>It's pretty onerous to perform an exhaustive, definitive search of the Standard's rules for function declarations and instantiations. But this example, although limited to member functions and the completeness of the enclosing type, can reasonably be extended to other functions and types. In any case, it's pretty good evidence of a distinction.</p>\n", "LastActivityDate": "2012-02-05T10:12:21.110", "CommentCount": "0", "CreationDate": "2012-02-05T10:12:21.110", "ParentId": "7730874", "Score": "2", "OwnerUserId": "153285"}, "7730874": {"ViewCount": "626", "Body": "<p>The C++ Language Standard states the following concerning template components in the Standard Library:</p>\n<blockquote>\n<p id=\"so_7730874_7730874_0\">The effects are undefined...if an incomplete type is used as a template argument when instantiating a template component, unless specifically allowed for that component (C++11 \u00a717.6.4.8/2).</p>\n</blockquote>\n<p>Does the following cause instantiation of the <code>std::vector</code> class template?</p>\n<pre><code>class X;\nstd::vector&lt;X&gt; f(); // Declaration only; we will define it when X is complete\n</code></pre>\n<p>To ask it another way, in the function declaration <code>std::vector&lt;X&gt; f();</code>, is <code>std::vector</code> instantiated with the argument <code>X</code>?  Or, is <code>std::vector&lt;X&gt;</code> not instantiated until <code>f()</code> is odr-used or defined?</p>\n<p>Likewise, does the following cause instantiation of the <code>std::vector</code> class template?</p>\n<pre><code>class X;\ntypedef std::vector&lt;X&gt; XVector; // We will complete X before we use XVector\n</code></pre>\n<p>While I use <code>std::vector</code> in these examples, the question applies equally to all templates.</p>\n", "AcceptedAnswerId": "7731106", "Title": "In the declaration \"std::vector<X> f();\", is \"std::vector<X>\" an instantiation?", "CreationDate": "2011-10-11T18:42:26.040", "Id": "7730874", "CommentCount": "11", "FavoriteCount": "10", "PostTypeId": "1", "LastActivityDate": "2012-02-05T10:12:21.110", "Score": "19", "OwnerUserId": "151292", "Tags": "<c++><templates>", "AnswerCount": "2"}});