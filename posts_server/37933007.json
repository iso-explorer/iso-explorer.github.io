post_cb({"37938976": {"ParentId": "37933007", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I do not know exactly <em>why</em> the posted code does not work. I suspect the answer lies deep within the C++ Standard name lookup rules, which are incredibly complicated -- assuming, of course, that this is not actually a compiler bug. Someone else here probably knows.</p>\n<p>The following \"equivalent\" examples compile on GCC 5.2.0 and Clang 3.8. They may or may not be suitable for your situation.</p>\n<p>Example 1: Use <code>constexpr</code> and in-class initialization</p>\n<pre><code>struct my_symbols {\n  enum class syms { symb_0_0, symb_0_1 };\n};\n\ntemplate&lt;typename SymbolEnums&gt;\nstruct outer {\n\n  using syms_0 = typename SymbolEnums::syms;\n\n  template &lt;syms_0 AnSym0, int Int&gt;\n  struct inner {\n    static constexpr int val = Int;\n  };\n};\n\nint main() {\n  return outer&lt;my_symbols&gt;::inner&lt;my_symbols::syms::symb_0_1, 1&gt;::val;\n}\n</code></pre>\n<p>Example 2: Tweak the nested template type parameter</p>\n<pre><code>struct my_symbols {\n  enum class syms { symb_0_0, symb_0_1 };\n};\n\ntemplate&lt;typename SymbolEnums&gt;\nstruct outer {\n\n  using syms_0 = typename SymbolEnums::syms;\n\n  template &lt;syms_0 AnSym0, int Int&gt;\n  struct inner {\n    static int const val;\n  };\n};\n\ntemplate&lt;typename SymbolEnums&gt;\ntemplate&lt;typename SymbolEnums::syms AnSym0, int Int&gt;\n//       ^^^^^^^^^^^^^^^^^^^^^^^^^^\nint const outer&lt;SymbolEnums&gt;::inner&lt;AnSym0, Int&gt;::val = Int;\n\nint main() {\n  return outer&lt;my_symbols&gt;::inner&lt;my_symbols::syms::symb_0_1, 1&gt;::val;\n}\n</code></pre>\n", "OwnerUserId": "2397809", "LastEditorUserId": "2397809", "LastEditDate": "2016-06-21T08:20:09.077", "Id": "37938976", "Score": "1", "CreationDate": "2016-06-21T08:13:56.827", "LastActivityDate": "2016-06-21T08:20:09.077"}, "bq_ids": {"n4140": {"so_37933007_37933007_1": {"section_id": 126, "quality": 0.5625, "length": 9}}, "n3337": {"so_37933007_37933007_1": {"section_id": 120, "quality": 0.5625, "length": 9}}, "n4659": {"so_37933007_37933007_1": {"section_id": 131, "quality": 0.5625, "length": 9}}}, "37933007": {"CommentCount": "0", "ViewCount": "56", "PostTypeId": "1", "LastEditorUserId": "1681377", "CreationDate": "2016-06-20T22:48:17.183", "LastActivityDate": "2016-06-21T08:20:09.077", "Title": "c++ static int def in doubly nested template class fails with clang++ and g++", "AcceptedAnswerId": "37938976", "LastEditDate": "2016-06-21T02:56:55.313", "Id": "37933007", "Score": "3", "Body": "<p>With following code:</p>\n<pre><code>struct my_symbols {\n  enum class syms { symb_0_0, symb_0_1 };\n};\ntemplate\n&lt; typename SymbolEnums\n&gt;\nstruct outer {\n  using syms_0 = typename SymbolEnums ::syms;\n  template &lt;syms_0 AnSym0, int Int&gt;\n  struct inner {\n    static int const val;\n  };\n};\n\ntemplate \n&lt; typename SymbolEnums\n&gt;\ntemplate \n&lt; typename outer&lt;SymbolEnums&gt;::syms_0 AnSym0\n, int Int\n&gt;\nint const outer&lt;SymbolEnums&gt;::inner&lt;AnSym0, Int&gt;::val = Int;\n\nint main() {\n  return \n      outer&lt;my_symbols&gt;::\n      inner&lt;my_symbols::syms::symb_0_1, 1&gt;::val;\n}\n</code></pre>\n<p>I get, with gcc5.2.0:</p>\n<blockquote>\n<p id=\"so_37933007_37933007_0\">template definition of non-template \u2018int outer_tmpl::inner_tmpl::val\u2019\n           val=Int;\n           ^</p>\n</blockquote>\n<p>and with clang3.8.0, I get:</p>\n<blockquote>\n<p id=\"so_37933007_37933007_1\">nested name specifier 'outer_tmpl::inner_tmpl::' for\n        declaration does not refer into a class, class template or class template partial specialization\n          val=Int;\n          ^</p>\n</blockquote>\n<p>How can I correct the code?</p>\n<p>TIA.</p>\n", "Tags": "<c++><templates><static><nested>", "OwnerUserId": "1681377", "AnswerCount": "1"}});