post_cb({"bq_ids": {"n4140": {"so_48053478_48078275_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 603}, "so_48053478_48078275_2": {"length": 19, "quality": 1.0, "section_id": 639}}, "n3337": {"so_48053478_48078275_2": {"length": 19, "quality": 1.0, "section_id": 629}, "so_48053478_48078275_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 593}}, "n4659": {"so_48053478_48078275_2": {"length": 19, "quality": 1.0, "section_id": 667}, "so_48053478_48078275_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 629}}}, "48078275": {"Id": "48078275", "PostTypeId": "2", "Body": "<p>The resolution of issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1604\" rel=\"nofollow noreferrer\">CWG 1604</a> makes it ill-formed to direct-initialize a rvalue reference of class type <code>T</code> with an initializer that can be converted to a <code>const T</code> rvalue, but an implicit conversion sequence can still be formed because the resolution does not change relevant part about implicit conversion sequence. </p>\n<p>As a result, in your example of <code>s3</code>, while ranking <code>string::operator=(const string&amp;)</code> and <code>string::operator=(string&amp;&amp;)</code> during overload resolution, according to <a href=\"http://www.eel.is/c++draft/over.ics.rank#3.2.3\" rel=\"nofollow noreferrer\">[over.ics.rank]/3.2.3</a>:</p>\n<blockquote>\n<p id=\"so_48053478_48078275_0\">Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if</p>\n<ul>\n<li><p id=\"so_48053478_48078275_1\">...</p></li>\n<li><p id=\"so_48053478_48078275_2\">S1 and S2 are reference bindings and neither refers to an implicit object parameter of a non-static member function declared without a ref-qualifier, and S1 binds an rvalue reference to an rvalue and S2 binds an lvalue reference</p></li>\n<li><p id=\"so_48053478_48078275_3\">...</p></li>\n</ul>\n</blockquote>\n<p>the compiler chooses <code>string::operator=(string&amp;&amp;)</code> finally, thus causes an error when the initialization of its parameter actually occurs.</p>\n<p>In your example of <code>s2</code>, the semantic is copy-initializing rather than choosing proper assignment operator, and there is no reference binding. So everything is OK.</p>\n<p>Thank T.C. for pointing out that this is already a drafting issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2077\" rel=\"nofollow noreferrer\">CWG 2077</a> in <a href=\"https://groups.google.com/a/isocpp.org/d/msg/std-discussion/rz0HWHx4gfU/PJYFaJIhDgAJ\" rel=\"nofollow noreferrer\">this discussion</a>.</p>\n", "LastActivityDate": "2018-01-03T13:21:52.987", "Score": "1", "CreationDate": "2018-01-03T13:21:52.987", "ParentId": "48053478", "CommentCount": "0", "OwnerUserId": "5376789"}, "48054959": {"Id": "48054959", "PostTypeId": "2", "Body": "<p>I would surmise (but it's only going on what your seeing):</p>\n<p><strong>s2(s2 *newValue) { std::string temp=*newValue; storage=temp; }</strong></p>\n<p>Can be completed automatically by the compiler via implicit casting.</p>\n<p>Where as:</p>\n<p><strong>s3(s3 *newValue) { storage=*newValue; }</strong></p>\n<p>Cannot.</p>\n<p>First place <strong>(*newValue)</strong> in brackets and see if its misinterpreting your intentions in the compiler. Second try performing an explicit cast:</p>\n<p><strong>s3(s3 *newValue) { storage=((std::string)(*newValue)); }</strong></p>\n<p>If neither of those work, I would have to conquer its a compiler issue.</p>\n", "LastActivityDate": "2018-01-02T02:33:17.423", "Score": "0", "CreationDate": "2018-01-02T02:33:17.423", "ParentId": "48053478", "CommentCount": "1", "OwnerUserId": "7402124"}, "48053478": {"ViewCount": "136", "Body": "<p>Given the following:</p>\n<pre><code>#include &lt;string&gt;\n\nclass s1\n{\n    private:\n        std::string storage;\n    public:\n        s1(s1 *newValue) { storage=*newValue; }\n        operator std::string () { return storage; }\n};\n\nclass s2\n{\n    private:\n        std::string storage;\n    public:\n        s2(s2 *newValue) { std::string temp=*newValue; storage=temp; }\n        operator std::string const () { return storage; }\n};\n\nclass s3\n{\n    private:\n        std::string storage;\n    public:\n        s3(s3 *newValue) { storage=*newValue; } // Compile Error here.\n        operator std::string const () { return storage; }\n};\n</code></pre>\n<p>The first (s1) and second (s2) examples compile fine; the third one does not... but s2 and s3 should be identical except for passing the value thru the temp variable.</p>\n<p>Chasing the error messages into the library code, I <em>think</em> that the compiler is trying to bind to a move constructor on std::string in the case of s3.</p>\n<p>What I don't understand is why it's doing that; and why I can do what I did with s2, but not s3 --- shouldn't they be the same, semantically?</p>\n<p>Any enlightenment anybody can provide would be <strong><em>MUCH</em></strong> appreciated!</p>\n<p>FWIW, the IDE is Xcode Version 9.2 (9C40b); and the C++ variant is gnu++17. Also, here's the (slightly redacted) error listing from Xcode:</p>\n<hr>\n<pre><code>In file included from /Users/... big long path here... .cpp:9:\n/Users/... big long path here... .hpp:77:31: error: no viable conversion from 's3' to 'std::__1::basic_string&lt;char&gt;'\n                        s3(s3 *newValue) { storage=*newValue; }\n                                                   ^~~~~~~~~\nIn file included from /Users/... big long path here... .cpp:9:\nIn file included from /Users/... big long path here... .hpp:45:\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string:763:5: note: candidate constructor not viable: no known conversion from 's3' to 'const std::__1::basic_string&lt;char&gt; &amp;' for 1st argument\n    basic_string(const basic_string&amp; __str);\n    ^\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string:768:5: note: candidate constructor not viable: no known conversion from 's3' to 'std::__1::basic_string&lt;char&gt; &amp;&amp;' for 1st argument\n    basic_string(basic_string&amp;&amp; __str)\n    ^\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string:778:31: note: candidate constructor not viable: no known conversion from 's3' to 'const value_type *' (aka 'const char *') for 1st argument\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n                              ^\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string:810:5: note: candidate constructor not viable: no known conversion from 's3' to 'initializer_list&lt;value_type&gt;' (aka 'initializer_list&lt;char&gt;') for 1st argument\n    basic_string(initializer_list&lt;value_type&gt; __il);\n    ^\nIn file included from /Users/... big long path here... .cpp:9:\n/Users/... big long path here... .hpp:78:4: note: candidate function\n                        operator std::string const () { return storage; }\n                        ^\nIn file included from /Users/... big long path here... .cpp:9:\nIn file included from /Users/... big long path here... .hpp:45:\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/string:829:44: note: passing argument to parameter '__str' here\n    basic_string&amp; operator=(basic_string&amp;&amp; __str)\n                                           ^\n1 error generated.\n</code></pre>\n</hr>", "AcceptedAnswerId": "48078275", "Title": "Why does adding a temp variable here make this compiler error go away? The types are the same", "CreationDate": "2018-01-01T21:44:37.780", "LastActivityDate": "2018-01-03T13:21:52.987", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-01T21:49:06.703", "LastEditorUserId": "3727050", "Id": "48053478", "Score": "2", "OwnerUserId": "9161490", "Tags": "<c++>", "AnswerCount": "2"}});