post_cb({"25295345": {"CommentCount": "11", "AcceptedAnswerId": "25295745", "CreationDate": "2014-08-13T20:18:10.057", "LastActivityDate": "2014-08-13T20:41:31.210", "PostTypeId": "1", "ViewCount": "171", "FavoriteCount": "2", "Title": "Does Koenig's lookup apply here?", "Id": "25295345", "Score": "5", "Body": "<p>Is the following snippet correct C++ code?</p>\n<pre><code>#include &lt;sstream&gt;\nclass Foo;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; str, Foo x);  // (A)\n\nnamespace test {\n  class Message {\n  public:\n    std::ostringstream str;\n  };\n\n  template&lt;typename T&gt;\n  Message&amp; operator&lt;&lt;(Message&amp; m, T&amp; t)\n  {\n    using ::operator&lt;&lt;;\n    m.str &lt;&lt; t;\n    return m;\n  }\n}\n\nnamespace detail {\n  class Class {\n  public:\n    int i;\n    Class() : i(5) {}\n  };\n}\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; str, detail::Class&amp; myClass) { // (B)\n  return str &lt;&lt; myClass.i;\n}\n\nint main() {\n  test::Message m;\n  detail::Class c;\n  m &lt;&lt; c;\n}\n</code></pre>\n<p>According to <a href=\"http://goo.gl/NkPNau\" rel=\"noreferrer\">http://goo.gl/NkPNau</a> GCC compiles this fine, while Clang doesn't find the <code>operator&lt;&lt;</code> (B).</p>\n<hr>\n<p>In case you are wondering: This is from a code that uses GTest with a custom <code>operator&lt;&lt;</code> for <code>std::set</code> to print nice assertion messages. We couldn't figure out a way to make it work with clang other than putting the <code>operator&lt;&lt;</code> (B) in std namespace (yeah I know...).</p>\n</hr>", "Tags": "<c++>", "OwnerUserId": "546632", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25295345_25295745_2": {"section_id": 224, "quality": 0.8888888888888888, "length": 16}, "so_25295345_25295745_3": {"section_id": 224, "quality": 0.9487179487179487, "length": 37}, "so_25295345_25295745_1": {"section_id": 224, "quality": 0.6666666666666666, "length": 12}, "so_25295345_25295745_0": {"section_id": 224, "quality": 0.5882352941176471, "length": 10}}, "n3337": {"so_25295345_25295745_2": {"section_id": 217, "quality": 0.8888888888888888, "length": 16}, "so_25295345_25295745_3": {"section_id": 217, "quality": 1.0, "length": 39}, "so_25295345_25295745_1": {"section_id": 217, "quality": 0.8333333333333334, "length": 15}, "so_25295345_25295745_0": {"section_id": 217, "quality": 0.7647058823529411, "length": 13}}, "n4659": {"so_25295345_25295745_3": {"section_id": 232, "quality": 0.9487179487179487, "length": 37}, "so_25295345_25295745_2": {"section_id": 232, "quality": 0.8888888888888888, "length": 16}, "so_25295345_25295745_1": {"section_id": 232, "quality": 0.6666666666666666, "length": 12}, "so_25295345_25295745_0": {"section_id": 232, "quality": 0.5882352941176471, "length": 10}}}, "25295745": {"ParentId": "25295345", "CommentCount": "7", "Body": "<p>Clang is correct here.  Let's call g++'s behavior a language extension.</p>\n<p>Argument-dependent lookup (aka Koenig lookup) does apply, since <code>m.str &lt;&lt; t</code> is interpreted using the best overload matching either <code>m.str.operator&lt;&lt;(t)</code> or <code>operator&lt;&lt;(m.str, t)</code>, and the second case is an <em>unqualified-id</em> as the function name.  But:</p>\n<p>14.6.4.2:</p>\n<blockquote>\n<p id=\"so_25295345_25295745_0\">For a function call that depends on a template parameter, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2, 3.4.3) except that:</p>\n<ul>\n<li><p id=\"so_25295345_25295745_1\">For the part of the lookup using unqualified name lookup (3.4.1) or qualified name lookup (3.4.3), only function declarations from the template definition context are found.</p></li>\n<li><p id=\"so_25295345_25295745_2\">For the part of the lookup using associated namespaces (3.4.2), only function declarations found in either the template definition context or the template instantiation context are found.</p></li>\n</ul>\n<p id=\"so_25295345_25295745_3\">If the function name is an <em>unqualified-id</em> and the call would be ill-formed or would find a better match had the lookup within the associated namespaces considered all the function declarations with external linkage introduced in those namespaces in all translation units, not just considering those declarations found in the template definition and template instantiation contexts, then the program has undefined behavior.</p>\n</blockquote>\n<p>At the template definition context, (B) is not visible.  (B) is visible at the template instantiation context, but the global namespace is not an associated namespace of either <code>std::ostringstream</code> or <code>detail::Class</code>.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "25295745", "Score": "3", "CreationDate": "2014-08-13T20:41:31.210", "LastActivityDate": "2014-08-13T20:41:31.210"}});