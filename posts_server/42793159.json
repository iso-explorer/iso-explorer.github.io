post_cb({"42793270": {"Id": "42793270", "PostTypeId": "2", "Body": "<p>the scope of t is the main function. Its created on the stack and will be destroyed at the end of the function.</p>\n<p>That's how its supposed to work and when you call the destructor on it early, you don't change that.</p>\n<p>You don't need to call the destructor and in this case doing so leads to it being called twice.</p>\n<p>if you'd used</p>\n<pre><code>Test* t = new Test();\n</code></pre>\n<p>the destructor would not have been automatically called at the end of main.</p>\n", "LastActivityDate": "2017-03-14T17:56:55.187", "Score": "0", "CreationDate": "2017-03-14T17:56:55.187", "ParentId": "42793159", "CommentCount": "2", "OwnerUserId": "6261163"}, "bq_ids": {"n4140": {"so_42793159_42793281_4": {"length": 31, "quality": 0.9393939393939394, "section_id": 410}, "so_42793159_42793281_3": {"length": 32, "quality": 0.9142857142857143, "section_id": 411}, "so_42793159_42793281_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 407}}, "n3337": {"so_42793159_42793281_4": {"length": 31, "quality": 0.9393939393939394, "section_id": 401}, "so_42793159_42793281_2": {"length": 9, "quality": 0.75, "section_id": 398}, "so_42793159_42793281_3": {"length": 32, "quality": 0.9142857142857143, "section_id": 402}}, "n4659": {"so_42793159_42793281_4": {"length": 31, "quality": 0.9393939393939394, "section_id": 428}, "so_42793159_42793281_3": {"length": 32, "quality": 0.9142857142857143, "section_id": 429}, "so_42793159_42793281_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 425}}}, "42793251": {"Id": "42793251", "PostTypeId": "2", "Body": "<p>This is not an \"explicit call to constructor\":</p>\n<pre><code>Test(); // Explicit call to constructor\n</code></pre>\n<p>It constructs a temporary object, which implicitly calls the constructor, then the temporary immediately goes out of scope, which implicitly calls the destructor. You can't explicitly call a constructor, it gets called implicitly when you construct an object.</p>\n<blockquote>\n<p id=\"so_42793159_42793251_0\">My question is even after explicitly calling destructor in main(), why does the compiler call the destructor implicitly before exiting main()?</p>\n</blockquote>\n<p>Because the compiler always destroys local variables. Just because you did something dumb (manually destroyed an object that gets destroyed automatically) doesn't change that.</p>\n<blockquote>\n<p id=\"so_42793159_42793251_1\">As a side question, apart from use in delete operator is there any other use of the strategy of calling destructor explicitly?</p>\n</blockquote>\n<p>It's used when managing the lifetime of objects in raw memory, which is done by containers like <code>std::vector</code> and other utilities like <code>std::optional</code>.</p>\n", "LastActivityDate": "2017-03-14T17:55:34.413", "Score": "2", "CreationDate": "2017-03-14T17:55:34.413", "ParentId": "42793159", "CommentCount": "0", "OwnerUserId": "981959"}, "42793159": {"ViewCount": "122", "Body": "<p>The following program :</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Test\n{\npublic:\n    Test() { cout &lt;&lt; \"Constructor is executed\\n\"; }\n    ~Test() { cout &lt;&lt; \"Destructor is executed\\n\"; }\n};\n\nint main()\n{\n    Test(); // Explicit call to constructor\n    Test t; // local object\n    t.~Test(); // Explicit call to destructor\n    return 0;\n}\n</code></pre>\n<p>prints the following output:</p>\n<pre><code>Constructor is executed\nDestructor is executed\nConstructor is executed\nDestructor is executed\nDestructor is executed\n</code></pre>\n<p>My question is even after explicitly calling destructor in main(), why does the compiler call the destructor implicitly before exiting main()?</p>\n<p>As a side question, apart from use in delete operator is there any other use of the strategy of calling destructor explicitly?</p>\n", "AcceptedAnswerId": "42793281", "Title": "Automatic destruction of object even after calling destructor explicitly", "CreationDate": "2017-03-14T17:50:46.557", "Id": "42793159", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-03-14T17:58:13.673", "Score": "-1", "OwnerUserId": "5216232", "Tags": "<c++><oop>", "AnswerCount": "5"}, "42793288": {"Id": "42793288", "PostTypeId": "2", "Body": "<p>The compiler does not care if you called the destructor explicitly or not. The local object <code>t</code> gets out of scope, that's why it gets destroyed and the destructor is called.\nIt is no good practice to call destructors explicitly. Instead you should write a method like <code>cleanup()</code> that can be called explicitly as well as from within the destructor. If you want to avoid that cleanup can be called twice, add something like this to you class:</p>\n<pre><code>private:\nbool cleanupPerformed;\n\nvoid cleanup()\n{\n   if( !cleanupPerformed )\n   {\n       // ... do cleanup work here ...\n       cleanupPerformed = true;\n   }\n}\n</code></pre>\n", "LastActivityDate": "2017-03-14T17:58:00.910", "Score": "0", "CreationDate": "2017-03-14T17:58:00.910", "ParentId": "42793159", "CommentCount": "0", "OwnerUserId": "4397543"}, "42793295": {"Id": "42793295", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_42793159_42793295_0\">My question is even after explicitly calling destructor in main(), why does the compiler call the destructor implicitly before exiting main()?</p>\n</blockquote>\n<p>The destructor will be called when the object gets out of scope, regardless of whether you call the destructor explicitly or not. Don't explicitly call the destructor for objects with automatic storage duration.</p>\n<blockquote>\n<p id=\"so_42793159_42793295_1\">As a side question, apart from use in delete operator is there any other use of the strategy of calling destructor explicitly?</p>\n</blockquote>\n<p>Yes. When you initialize an object using the <a href=\"http://en.cppreference.com/w/cpp/language/new\" rel=\"nofollow noreferrer\">placement <code>new</code> expression</a>, you need to call the destructor explicitly. Sample code from the above site:</p>\n<pre><code>char* ptr = new char[sizeof(T)]; // allocate memory\nT* tptr = new(ptr) T;            // construct in allocated storage (\"place\")\ntptr-&gt;~T();                      // destruct\ndelete[] ptr;                    // deallocate memory\n</code></pre>\n", "LastActivityDate": "2017-03-14T17:58:13.673", "Score": "1", "CreationDate": "2017-03-14T17:58:13.673", "ParentId": "42793159", "CommentCount": "0", "OwnerUserId": "434551"}, "42793281": {"Id": "42793281", "PostTypeId": "2", "Body": "<p>You've introduced undefined behavior.</p>\n<p>Per the standard:</p>\n<blockquote>\n<p id=\"so_42793159_42793281_0\">\u00a7 12.4 Destructors</p>\n<p id=\"so_42793159_42793281_1\">(11) A destructor is invoked implicitly</p>\n<p id=\"so_42793159_42793281_2\">(11.3) \u2014 <strong>for a constructed object with automatic storage duration (3.7.3) when the block in which an object is\n  created exits</strong> (6.7),</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_42793159_42793281_3\">15 Once a destructor is invoked for an object, the object no longer exists; the behavior is undefined if the\n  destructor is invoked for an object whose lifetime has ended (3.8). [ Example: if the destructor for an\n  automatic object is explicitly invoked, and the block is subsequently left in a manner that would ordinarily\n  invoke implicit destruction of the object, the behavior is undefined. \u2014end example ]</p>\n</blockquote>\n<p>You explicitly call the destructor  or by calling <code>t.~Test()</code>, it is then implicitly invoked when the object leaves scope. This is undefined.</p>\n<p>The standard provides this note as well:</p>\n<blockquote>\n<p id=\"so_42793159_42793281_4\">14 [ Note: explicit calls of destructors are rarely needed. One use of such calls is for objects placed at specific\n  addresses using a placement new-expression. Such use of explicit placement and destruction of objects can\n  be necessary to cope with dedicated hardware resources and for writing memory management facilities.</p>\n</blockquote>\n", "LastActivityDate": "2017-03-14T17:57:29.507", "Score": "3", "CreationDate": "2017-03-14T17:57:29.507", "ParentId": "42793159", "CommentCount": "0", "OwnerUserId": "1020484"}});