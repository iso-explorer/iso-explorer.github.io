post_cb({"bq_ids": {"n4140": {"so_26755400_26758377_0": {"length": 14, "quality": 0.875, "section_id": 7123}}, "n3337": {"so_26755400_26758377_0": {"length": 14, "quality": 0.875, "section_id": 6867}}, "n4659": {"so_26755400_26758377_0": {"length": 14, "quality": 0.875, "section_id": 8624}}}, "26755400": {"ViewCount": "226", "Body": "<p>Consider the following piece of code:</p>\n<pre><code>struct Foo {};\n\ntemplate&lt;typename ForwardIterator&gt;\nstruct Foo*\nBar(ForwardIterator first, ForwardIterator last)\n{ \n    (void)first;\n    (void)last;\n    Foo *foo(nullptr);\n    return foo;\n}\n</code></pre>\n<p>The above piece of code compiles fine in <a href=\"http://coliru.stacked-crooked.com/a/73746ea02cc0781e\" rel=\"noreferrer\">Clangv3.5</a> and <a href=\"http://coliru.stacked-crooked.com/a/73746ea02cc0781e\" rel=\"noreferrer\">GCCv4.9</a>.</p>\n<p>However, it fails to compile in VC++2013.</p>\n<p>Removing the <code>struct</code> identifier (see below) from the return type solves the problem:</p>\n<pre><code>struct Foo {};\n\ntemplate&lt;typename ForwardIterator&gt;\nFoo*\nBar(ForwardIterator first, ForwardIterator last)\n{ \n    (void)first;\n    (void)last;\n    Foo *foo(nullptr);\n    return foo;\n}\n</code></pre>\n<h2><strong>Q1:</strong></h2>\n<p>Is this a visual studio bug?</p>\n<h2><strong>Q2:</strong></h2>\n<p>This issue came up, because in my code-base the <code>Foo</code> <code>struct</code> lies in a <code>.h.c</code> file (i.e., is a C <code>struct</code>) and in order to signify C/POD <code>struct</code>s in my code, I use the <code>struct</code> identifier. Is this a bad idea (i.e., in C++ code I should avoid to use <code>struct</code> identifier in this fashion)?</p>\n", "AcceptedAnswerId": "26758377", "Title": "Use of struct identifier to signify POD types and C structures", "CreationDate": "2014-11-05T10:52:41.183", "Id": "26755400", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-11-06T15:42:50.953", "Score": "8", "OwnerUserId": "2352671", "Tags": "<c++><c++11><struct><visual-studio-2013><c++14>", "AnswerCount": "1"}, "26758377": {"Id": "26758377", "PostTypeId": "2", "Body": "<p>The main point of an <em>elaborated type specifiers</em> is to allow you refer to a name that has been hidden, from the <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>3.4.4</code> <em>Elaborated type specifiers</em>:</p>\n<blockquote>\n<p id=\"so_26755400_26758377_0\">An elaborated-type-specifier (7.1.6.3) may be used to refer to a\n  previously declared class-name or enum-name even though the name has\n  been hidden by a non-type declaration (3.3.10).</p>\n</blockquote>\n<p>and so in the case where <code>Foo</code> is hidden, you would have to use an <em>elaborated type specifiers</em>:</p>\n<pre><code>struct Foo {};\n\nvoid Foo()\n{\n}\n</code></pre>\n<p>I see nothing in <code>7.1.6.3</code> <em>Elaborated type specifiers</em> or <code>14</code> <em>Templates</em> that would prevent this use. In fact it looks like from the description of <a href=\"http://msdn.microsoft.com/en-us/library/b25sbd9x.aspx\" rel=\"nofollow\">CS2989</a> Visual Studio is getting confused and thinks you are attempting to redefine a non-template class as a template class.</p>\n<p>So this looks like a bug to me, so I would file a <a href=\"https://connect.microsoft.com/visualstudio\" rel=\"nofollow\">bug report</a>.</p>\n<p><b>Update</b></p>\n<p>Filed a <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/1022916/using-an-elaborated-type-specifiers-as-a-return-type-in-a-template-function-does-not-work\" rel=\"nofollow\">bug report</a>.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-11-06T15:42:50.953", "Score": "7", "CreationDate": "2014-11-05T13:25:46.753", "ParentId": "26755400", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-11-06T15:42:50.953"}});