post_cb({"bq_ids": {"n4140": {"so_45769950_45800815_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 336}, "so_45769950_45800815_7": {"length": 6, "quality": 0.8571428571428571, "section_id": 154}, "so_45769950_45800815_6": {"length": 12, "quality": 1.0, "section_id": 153}}, "n3337": {"so_45769950_45800815_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 326}, "so_45769950_45800815_7": {"length": 6, "quality": 0.8571428571428571, "section_id": 148}, "so_45769950_45800815_6": {"length": 12, "quality": 1.0, "section_id": 147}}, "n4659": {"so_45769950_45800815_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 345}, "so_45769950_45800815_7": {"length": 7, "quality": 1.0, "section_id": 158}, "so_45769950_45800815_6": {"length": 12, "quality": 1.0, "section_id": 157}}}, "45769950": {"ViewCount": "65", "Body": "<p>The <code>identity</code> template is a common idiom for switching off deduction for a certain (dependent) template argument, for example to allow for implicit conversions like in the example below:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nstruct A {};\nstruct B : public A&lt;int&gt; {};\nstruct C {\n  operator B() { return {}; }\n};\n\ntemplate&lt;typename U&gt; struct identity { typedef U type; };\n\ntemplate&lt;class T&gt; using identity_t = typename identity&lt;T&gt;::type;\n\ntemplate&lt;class X&gt;\nvoid test(A&lt;X&gt; arg1, A&lt;X&gt; arg2) {              // #1\n  std::cout &lt;&lt; \"ok1\";\n}\n\ntemplate&lt;class X&gt;\nvoid test(A&lt;X&gt; arg1, identity_t&lt;A&lt;X&gt;&gt; arg2) {  // #2\n  std::cout &lt;&lt; \"ok2\";\n}\n\nint main() {\n  B a, b;\n  C c;\n  test(a, b);\n  test(b, c);\n}\n</code></pre>\n<p>But the results from different compilers are not the same: <a href=\"https://godbolt.org/g/nXHW2D\" rel=\"nofollow noreferrer\">Live demo on Godbolt</a></p>\n<ul>\n<li>GCC 6: <code>ok1ok2</code></li>\n<li>clang 5: <code>ok1ok2</code></li>\n<li>MSVC 2017:</li>\n</ul>\n<p></p>\n<blockquote id=\"so_45769950_45769950_0\">\n<pre><code>27 : &lt;source&gt;(27): error C2668: 'test': ambiguous call to overloaded function\n20 : &lt;source&gt;(20): note: could be 'void test&lt;int&gt;(A&lt;int&gt;,A&lt;int&gt;)'\n15 : &lt;source&gt;(15): note: or       'void test&lt;int&gt;(A&lt;int&gt;,A&lt;int&gt;)'\n27 : &lt;source&gt;(27): note: while trying to match the argument list '(B, B)'\n</code></pre>\n</blockquote>\n<p>The error kind of makes sense (although is surely a bug in MSVC) and thus brings us to my questions about <strong>why and how it works in GCC and clang</strong>:</p>\n<ol>\n<li><p>How does <code>test(a, b)</code> select <code>#1</code> while <code>test(b, c)</code> - <code>#2</code>? They look like equally good candidates at least in case <code>test(a, b)</code>.</p></li>\n<li><p>Why isn't the compiler complaining about two <code>test</code> instantiations with an exact same signature?</p></li>\n</ol>\n", "Title": "Partial ordering of function templates and non-deduced context not working in MSVC 2017", "CreationDate": "2017-08-19T09:33:23.027", "LastActivityDate": "2017-10-12T10:00:49.733", "CommentCount": "3", "LastEditDate": "2017-08-21T19:56:27.903", "PostTypeId": "1", "LastEditorUserId": "485343", "Id": "45769950", "Score": "3", "OwnerUserId": "485343", "Tags": "<c++><c++11><templates>", "AnswerCount": "1"}, "45800815": {"Id": "45800815", "PostTypeId": "2", "Body": "<p>It's a bug in MSVC, the program is correct.</p>\n<blockquote>\n<p id=\"so_45769950_45800815_0\"><strong><em>How does <code>test(a, b)</code> select <code>#1</code>?</em></strong></p>\n</blockquote>\n<p>For <code>test(a, b)</code>, overload resolution performs argument deduction from a function call (see <a href=\"https://timsong-cpp.github.io/cppwp/n3337/temp.deduct.call\" rel=\"nofollow noreferrer\">[temp.deduct.call]</a>):</p>\n<ul>\n<li>#1 is deduced as <code>void test(A&lt;int&gt;, A&lt;int&gt;)</code></li>\n<li>#2 is deduced as <code>void test(A&lt;int&gt;, &lt;non-deduced context&gt;)</code>, arg2 is then synthesized from arg1 as <code>A&lt;int&gt;</code>, the result: <code>void test(A&lt;int&gt;, A&lt;int&gt;)</code></li>\n</ul>\n<p>There is more than one viable alternative, so the process continues with <em>partial ordering</em> (see <a href=\"https://timsong-cpp.github.io/cppwp/n3337/temp.deduct.partial\" rel=\"nofollow noreferrer\">[temp.deduct.partial]</a>).</p>\n<p>Partial ordering uses the <em>original</em> templates, trying a <em>deduction from a type</em> (<a href=\"https://timsong-cpp.github.io/cppwp/n3337/temp.deduct.type\" rel=\"nofollow noreferrer\">[temp.deduct.type]</a>) pair-wise of each argument of one template into another (after a minor conversion), and vice versa.\nIf the deduction succeeds in only one direction, the winning template is selected as the most specialized.</p>\n<p>Deduction from a type <em>always fails</em> at nested contexts (anything to the left of the scope operator <code>::</code> is a nested context), see <a href=\"https://timsong-cpp.github.io/cppwp/n3337/temp.deduct.type#5\" rel=\"nofollow noreferrer\">[temp.deduct.type]/5</a>:</p>\n<blockquote>\n<p id=\"so_45769950_45800815_1\">The non-deduced contexts are:</p>\n<p id=\"so_45769950_45800815_2\">\u2014 The <em><a href=\"https://timsong-cpp.github.io/cppwp/n3337/expr.prim.general#nt:nested-name-specifier\" rel=\"nofollow noreferrer\">nested-name-specifier</a></em> of a type that was specified using a <em><a href=\"https://timsong-cpp.github.io/cppwp/n3337/expr.prim.general#nt:qualified-id\" rel=\"nofollow noreferrer\">qualified-id</a></em>.</p>\n<p id=\"so_45769950_45800815_3\">. . .</p>\n</blockquote>\n<p>So this means that #2 will always lose in partial ordering; the deduction into it will always fail, whereas the other way will always succeed:</p>\n<ol>\n<li><p>Deducing <code>void test(A&lt;T&gt;,A&lt;T&gt;)</code> from <code>void test(A&lt;U&gt;, typename identity&lt;A&lt;U&gt;&gt;::type)</code> : P1=<code>A&lt;T&gt;</code>, A1=<code>A&lt;U&gt;</code>, P2=<code>A&lt;U&gt;</code>, A2=<code>A&lt;U&gt;</code>, success, T=<code>U</code></p></li>\n<li><p>Deducing <code>void test(A&lt;T&gt;, typename identity&lt;A&lt;T&gt;&gt;::type)</code> from <code>void test(A&lt;U&gt;,A&lt;U&gt;)</code> : P1=<code>A&lt;T&gt;</code>, A1=<code>A&lt;U&gt;</code>, P2=<code>&lt;non-deduced-context&gt;</code>, fail</p></li>\n</ol>\n<p>So the outcome of partial ordering is: use <code>void test(A&lt;T&gt;,A&lt;T&gt;)</code> (#1) for the call <code>test(a, b)</code>.</p>\n<blockquote>\n<p id=\"so_45769950_45800815_4\"><strong><em>How does <code>test(b, c)</code> select <code>#2</code>?</em></strong></p>\n</blockquote>\n<p>For <code>test(b, c)</code>, <code>A&lt;X&gt;</code> cannot be deduced from <code>C</code> (implicit conversions are not considered during deduction), so #2 is the only viable alternative. <code>identity_t&lt;A&lt;X&gt;&gt;</code> is resolved <em>after</em> deduction to <code>A&lt;int&gt;</code>, since <code>X</code> is known (deduced from the first argument).</p>\n<blockquote>\n<p id=\"so_45769950_45800815_5\"><strong><em>Why isn't the compiler complaining about two test instantiations with an exact same signature?</em></strong></p>\n</blockquote>\n<p>The template parameters referenced in the function declaration are part of the signature of the instantiated function. See <a href=\"https://timsong-cpp.github.io/cppwp/n3337/temp.over.link#1\" rel=\"nofollow noreferrer\">[temp.over.link]</a>:</p>\n<blockquote>\n<ol>\n<li><p id=\"so_45769950_45800815_6\">It is possible to overload function templates so that two different function template specializations have the same type.</p></li>\n<li><p id=\"so_45769950_45800815_7\">Such specializations are distinct functions and do not violate the one-definition rule.</p></li>\n</ol>\n</blockquote>\n", "LastEditorUserId": "485343", "LastActivityDate": "2017-10-12T10:00:49.733", "Score": "1", "CreationDate": "2017-08-21T15:27:03.233", "ParentId": "45769950", "CommentCount": "0", "OwnerUserId": "485343", "LastEditDate": "2017-10-12T10:00:49.733"}});