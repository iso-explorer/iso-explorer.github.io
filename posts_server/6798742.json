post_cb({"bq_ids": {"n4140": {"so_6798742_6800024_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 643}}, "n3337": {"so_6798742_6800024_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 633}}, "n4659": {"so_6798742_6800024_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 671}}}, "6798742": {"ViewCount": "493", "Body": "<p>Recently I was trying to create flexible observer pattern implementation which hides <code>boost::signal</code>. I almost succeeded. </p>\n<p>I have a <code>Observer</code> class which has to have an <code>update</code> method matching signature provided by template parameter. </p>\n<p>Example of use:</p>\n<pre><code>Observable&lt;void(float, float)&gt; observable;\nObserver&lt;void(float, float)&gt; observer;\nobservable.attach(&amp;observer);\nobservable.notify(Observable::Arguments(10.0f, 1.0f)); // invokes observer-&gt;update(10.0f, 1.0f);\n</code></pre>\n<p>Everything works just fine if <code>observer</code> does not have overloaded <code>update</code> method. In that case <code>boost::bind</code> can not deduce correct method to use. Unfortunately I can't use explicit casting because I don't know update arguments (this information is in <code>FunctionSignature</code>). </p>\n<p>Following method causes troubles:</p>\n<pre><code>class Observable &lt;typename FunctionSignature&gt;\n{\n...\ntemplate &lt;class DerivedObserverClass&gt;\nvoid attach(DerivedObserverClass* observer)\n{\n    STATIC_ASSERT((boost::is_base_of&lt;ObserverType, DerivedObserverClass&gt;::value));\n\n    ConnectionsMap::iterator it = connections.find(observer);\n    if (it == connections.end() || !it-&gt;second.connected()) {\n        // i would like to do something like \n            // boost::function&lt;FunctionSignature&gt; f;\n        // f = boost::bind(&amp;static_cast&lt;FunctionSignature&gt;DerivedObserverClass::update, observer, _1);\n\n        // singnalSlot is defined as boost::signal&lt;FunctionSignature&gt;\n        // this works as long, as Derived class doesn't have overloaded update method\n        connections[observer] = signalSlot.connect(boost::bind(&amp;DerivedClass::update, observer, _1));\n    } else {\n        throw std::invalid_argument(\"Observer already attached.\");\n    }\n}\n</code></pre>\n<p>I think that <code>boost::function</code> could help to solve this problem. I don't know how to bind it with correct member method using only template signature.</p>\n<p>Is it even possible?</p>\n", "AcceptedAnswerId": "6800024", "Title": "How to create boost::function from template signature", "CreationDate": "2011-07-23T06:35:32.150", "Id": "6798742", "CommentCount": "0", "LastEditDate": "2015-08-31T09:23:42.090", "PostTypeId": "1", "LastEditorUserId": "4433386", "LastActivityDate": "2015-08-31T09:23:42.090", "Score": "1", "OwnerUserId": "859041", "Tags": "<c++><boost><boost-bind><boost-function>", "AnswerCount": "1"}, "6800024": {"Id": "6800024", "PostTypeId": "2", "Body": "<p>No, boost::function won't help you either. 13.4.3 says</p>\n<blockquote>\n<p id=\"so_6798742_6800024_0\">Nonstatic member functions match targets of type\n  \u201cpointer-to-member-function;\u201d the function type of the pointer to\n  member is used to select the member function from the set of\n  overloaded member functions.</p>\n</blockquote>\n<p>This means you cannot take an address of overloaded member function, pass it to any kind of function object (templated or not, boost or std or whatever), and hope the overloading will resolve itself. You need a genuine honest pointer-to-member-function type at the left-hand side of the assignment.</p>\n<p>You will have to convert your <code>FunctionSignature</code> to a pointer-to-member-function type somehow. Here's some old-fashioned template magic that does what you need, for a limited number of function arguments. c++0x might have a better, more general solution.</p>\n<pre><code>template &lt;typename C, typename F&gt;\nstruct tomemfun;\n\ntemplate &lt;typename C, typename res&gt;\nstruct tomemfun&lt;C, res()&gt;\n{\n  typedef res (C::*memfun_t)();\n};\n\ntemplate &lt;typename C, typename res, typename arg1&gt;\nstruct tomemfun&lt;C, res(arg1)&gt;\n{\n  typedef res (C::*memfun_t)(arg1);\n};\n\ntemplate &lt;typename C, typename res, typename arg1, typename arg2&gt;\nstruct tomemfun&lt;C, res(arg1, arg2)&gt;\n{\n  typedef res (C::*memfun_t)(arg1, arg2);\n};\n\n// repeat with more arguments as needed\n</code></pre>\n<p>Now you can use </p>\n<pre><code>tomemfun&lt;DerivedClass, FunctionSignature&gt;::memfun_t update = &amp;DerivedClass::update;\n</code></pre>\n<p>and it will resolve to the right overloaded function.</p>\n<p><code>boost</code> might already have such a conversion template, but I couldn't find it.</p>\n", "LastActivityDate": "2011-07-23T11:19:38.737", "CommentCount": "1", "CreationDate": "2011-07-23T11:19:38.737", "ParentId": "6798742", "Score": "0", "OwnerUserId": "775806"}});