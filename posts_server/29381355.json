post_cb({"29402604": {"ParentId": "29381355", "CommentCount": "0", "Body": "<p>The elements of a container are not the buckets, but rather the <code>value_type</code> elements.</p>\n<p>Modifying one element in a <code>std</code> container has no concurrency impact on other elements.  But modifying one <em>bucket</em> has no such guarantee.</p>\n<p>Adding or removing elements in a bucket is a non-<code>const</code> operation on the container that is not from the special list of non-<code>const</code> operations that are safe to use without synchronization.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "29402604", "Score": "1", "CreationDate": "2015-04-01T23:27:44.783", "LastActivityDate": "2015-04-01T23:27:44.783"}, "29381355": {"CommentCount": "9", "ViewCount": "795", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-04-01T01:25:12.223", "LastActivityDate": "2015-04-01T23:27:44.783", "Title": "Concurrent write to different buckets in unordered_map (C++)?", "FavoriteCount": "3", "LastEditDate": "2017-05-23T11:44:28.483", "Id": "29381355", "Score": "20", "Body": "<p>C++ newbie here.  I'm trying to write to different buckets concurrently in an unordered_map.  From what I can tell by searching, it is my understanding that this should be a thread safe operation.  My (perhaps incorrect) understanding is based on the answers <a href=\"https://stackoverflow.com/questions/1846186/thread-safety-of-stdmap-for-read-only-operations\">here</a> and <a href=\"https://stackoverflow.com/questions/16130494/are-stdmap-and-stdvector-thread-safe\">here</a>, as well as the referenced portion of the C++11 standard (particularly item 2 -- emphasis mine):</p>\n<blockquote>\n<p id=\"so_29381355_29381355_0\"><strong>23.2.2 Container data races [container.requirements.dataraces]</strong></p>\n<p id=\"so_29381355_29381355_1\">1 For purposes of avoiding data races (17.6.5.9), implementations shall consider the following functions to be const: begin, end, rbegin, rend, front, back, data, find, lower_bound, upper_bound, equal_range, at and, except in associative or unordered associative containers, operator[].</p>\n<p id=\"so_29381355_29381355_2\">2 Notwithstanding (17.6.5.9), <strong>implementations are required to avoid data races when the contents of the contained object in different elements in the same sequence, excepting <code>vector&lt;bool&gt;</code>, are modified concurrently</strong>.</p>\n<p id=\"so_29381355_29381355_3\">3 [ Note: For a vector x with a size greater than one, x[1] = 5 and *x.begin() = 10 can be executed concurrently without a data race, but x[0] = 5 and *x.begin() = 10 executed concurrently may result in a data race. As an exception to the general rule, for a vector &lt; bool &gt; y, y[0] = true may race with y[1] = true. \u2014end note ]</p>\n</blockquote>\n<p>In any case, it seems that writing to different buckets is not thread safe with the standard containers, as demonstrated by the code below. You'll see that I enable a lock corresponding to the bucket being modified before writing, yet sometimes  pairs do not get recorded correctly.  For what it's worth, if I use a single lock -- e.g., just change <code>auto bkt = mm-&gt;bucket(key);</code> to <code>auto bkt=0;</code>, effectively locking the entire unordered_map container -- everything works as expected.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;atomic&gt;\n#include &lt;vector&gt;\n#include &lt;thread&gt;\n\n#define NUM_LOCKS 409\n#define N 100\n#define NUM_THREADS 2\n\nusing namespace std;\n\n\nclass SpinLock\n{\n    public:\n        void lock()\n        {\n            while(lck.test_and_set(memory_order_acquire)){}\n        }\n    void unlock()\n        {\n            lck.clear(memory_order_release);\n        }\n\n    private:\n        atomic_flag lck = ATOMIC_FLAG_INIT;\n};\n\n\nvector&lt;SpinLock&gt; spinLocks(NUM_LOCKS);\n\n\nvoid add_to_map(unordered_map&lt;int,int&gt; * mm, const int keyStart, const int keyEnd, const int tid){\n\n    for(int key=keyStart;key&lt;keyEnd;++key){\n        auto bkt = mm-&gt;bucket(key);\n\n        //lock bucket\n        spinLocks[bkt].lock();\n\n        //insert pair\n        mm-&gt;insert({key,tid});\n\n        //unlock bucket\n        spinLocks[bkt].unlock();\n    }\n\n}\n\n\nint main() {\n\n    int Nbefore, Nafter;\n    thread *t = new thread[NUM_THREADS];\n\n    //create an unordered map, and reserve enough space to avoid a rehash\n    unordered_map&lt;int,int&gt; my_map;\n    my_map.reserve(2*NUM_THREADS*N);\n\n    //count number of buckets to make sure that a rehash didn't occur\n    Nbefore=my_map.bucket_count();\n\n\n    // Launch NUM_THREADS threads.  Thread k adds keys k*N through (k+1)*N-1 to the hash table, all with associated value = k.\n\n    for(int threadID=0;threadID&lt;NUM_THREADS;++threadID){\n        t[threadID]=thread(add_to_map,&amp;my_map,threadID*N,(threadID+1)*N,threadID);\n    }\n\n    // Wait for the threads to finish\n    for(int threadID=0;threadID&lt;NUM_THREADS;++threadID){\n        t[threadID].join();\n    }\n\n    //count number of buckets to make sure that a rehash didn't occur\n    Nafter=my_map.bucket_count();\n\n\n    cout &lt;&lt; \"Number of buckets before adding elements: \" &lt;&lt; Nbefore &lt;&lt;endl;\n    cout &lt;&lt; \"Number of buckets after  adding elements: \" &lt;&lt; Nafter  &lt;&lt; \" &lt;--- same as above, so rehash didn't occur\" &lt;&lt;endl;\n\n    //see if any keys are missing\n    for(int key=0;key&lt;NUM_THREADS*N;++key){\n\n        if(!my_map.count(key)){\n\n            cout &lt;&lt; \"key \" &lt;&lt; key &lt;&lt; \" not found!\" &lt;&lt; endl;\n\n        }\n    }\n\n    return 0;\n}\n</code></pre>\n<p>The program will exit when a key was erroneously not entered.  A sample output is:</p>\n<pre><code>Number of buckets before adding elements: 401\nNumber of buckets after  adding elements: 401 &lt;--- same as above, so rehash didn't occur\nkey 0 not found!\nkey 91 not found!\nkey 96 not found!\nkey 97 not found!\nkey 101 not found!\nkey 192 not found!\nkey 193 not found!\nkey 195 not found!\n</code></pre>\n<p>So, my question is two-fold:  </p>\n<ol>\n<li>Am I doing something wrong in how I am locking the buckets?  </li>\n<li>If so, is there a better way to lock the map on a bucket-by-bucket basis to enable concurrent writes to different buckets?</li>\n</ol>\n<p>Finally, I'll mention that I already tried TBB's concurrent_unordered_map, but it was much slower in my application than simply doing things in serial.  The stray errors aside, my bucket-locking approach using std::unordered_map performed significantly better.</p>\n", "Tags": "<c++><multithreading><c++11><concurrency>", "OwnerUserId": "4736161", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29381355_29381355_2": {"section_id": 718, "quality": 0.8947368421052632, "length": 17}, "so_29381355_29381355_3": {"section_id": 719, "quality": 0.78125, "length": 25}, "so_29381355_29381355_1": {"section_id": 717, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_29381355_29381355_2": {"section_id": 707, "quality": 0.9473684210526315, "length": 18}, "so_29381355_29381355_3": {"section_id": 708, "quality": 0.78125, "length": 25}, "so_29381355_29381355_1": {"section_id": 706, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_29381355_29381355_2": {"section_id": 749, "quality": 0.8947368421052632, "length": 17}, "so_29381355_29381355_3": {"section_id": 750, "quality": 0.78125, "length": 25}, "so_29381355_29381355_1": {"section_id": 748, "quality": 0.9259259259259259, "length": 25}}}});