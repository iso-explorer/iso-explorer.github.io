post_cb({"26143976": {"CommentCount": "12", "AcceptedAnswerId": "26144079", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2014-10-01T14:40:30.257", "LastActivityDate": "2015-10-24T21:55:38.463", "LastEditDate": "2014-10-01T14:46:19.240", "ViewCount": "9606", "FavoriteCount": "8", "Title": "Is the operation \"false < true\" well defined?", "Id": "26143976", "Score": "147", "Body": "<p>Does the C++ specification define:</p>\n<ol>\n<li>the existence of the 'less than' operator for boolean parameters, and if so,</li>\n<li>the result of the 4 parameter permutations?</li>\n</ol>\n<p>In other words, are the results from the following operations defined by the specification?</p>\n<pre><code>false &lt; false\nfalse &lt; true\ntrue &lt; false\ntrue &lt; true\n</code></pre>\n<p>On my setup (Centos 7, gcc 4.8.2) , the code below spits out what I'd expect (given C's history of representing false as 0 and true as 1):</p>\n<pre><code>false &lt; false = false\nfalse &lt; true = true\ntrue &lt; false = false\ntrue &lt; true = false\n</code></pre>\n<p>Whilst I'm pretty sure most (all?) compilers will give the same output, is this legislated by the C++ specification? Or is an obfuscating, but specification-compliant compiler allowed to decide that true is less than false?</p>\n<pre><code>#include &lt;iostream&gt;\n\nconst char * s(bool a)\n{\n  return (a ? \"true\" : \"false\");\n}\n\nvoid test(bool a, bool b)\n{\n  std::cout &lt;&lt; s(a) &lt;&lt; \" &lt; \" &lt;&lt; s(b) &lt;&lt; \" = \" &lt;&lt; s(a &lt; b) &lt;&lt; std::endl;\n}\n\nint main(int argc, char* argv[])\n{\n  test(false, false);\n  test(false, true);\n  test(true, false);\n  test(true, true);\n  return 0;\n}\n</code></pre>\n", "Tags": "<c++><boolean><language-lawyer><comparison-operators>", "OwnerUserId": "3672071", "AnswerCount": "4"}, "26144010": {"ParentId": "26143976", "CommentCount": "6", "Body": "<p>Boolean values are subject to the usual integer promotions, with <code>false</code> defined as <code>0</code> and <code>true</code> defined as <code>1</code>. That makes all the comparisons well defined.</p>\n", "OwnerUserId": "5987", "PostTypeId": "2", "Id": "26144010", "Score": "63", "CreationDate": "2014-10-01T14:42:38.580", "LastActivityDate": "2014-10-01T14:42:38.580"}, "26144237": {"ParentId": "26143976", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to the C++ Standard (5.9 Relational operators)</p>\n<blockquote>\n<p id=\"so_26143976_26144237_0\">2 The usual arithmetic conversions are performed on operands of\n  arithmetic or enumeration type.</p>\n</blockquote>\n<p>and </p>\n<blockquote>\n<p id=\"so_26143976_26144237_1\">1...The type of the result is bool.</p>\n</blockquote>\n<p>and (3.9.1 Fundamental types)</p>\n<blockquote>\n<p id=\"so_26143976_26144237_2\">6 Values of type bool are either true or false.49 [ Note: There are no\n  signed, unsigned, short, or long bool types or values. \u2014end note ]\n  <strong>Values of type bool participate in integral promotions</strong> (4.5).</p>\n</blockquote>\n<p>and (4.5 Integral promotions)</p>\n<blockquote>\n<p id=\"so_26143976_26144237_3\">6 A prvalue of type bool can be converted to a prvalue of type int,\n  with <strong>false becoming zero and true becoming one</strong>.</p>\n</blockquote>\n<p>So in all your examples true is converted to int 1 and false is converted to int 0</p>\n<p>These expressions</p>\n<pre><code>false &lt; false\nfalse &lt; true\ntrue &lt; false\ntrue &lt; true\n</code></pre>\n<p>are entirely equivalent to</p>\n<pre><code>0 &lt; 0\n0 &lt; 1\n1 &lt; 0\n1 &lt; 1\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "254830", "LastEditDate": "2014-10-03T07:04:06.850", "Id": "26144237", "Score": "22", "CreationDate": "2014-10-01T14:53:35.353", "LastActivityDate": "2014-10-03T07:04:06.850"}, "26144079": {"ParentId": "26143976", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><b>TL;DR:</b></p>\n<p>The operations are well defined according to the draft C++ standard.</p>\n<p><b>Details</b></p>\n<p>We can see that by going to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">draft C++ standard</a> section <code>5.9</code> <em>Relational operators</em> which says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_26143976_26144079_0\">The <strong>operands shall have arithmetic</strong>, enumeration, or pointer <strong>type</strong>, or type std::nullptr_t. The operators\n  &lt; (less than), &gt; (greater than), &lt;= (less than or equal to), and &gt;= (greater than or equal to) all yield\n  false or true. The type of the result is bool</p>\n</blockquote>\n<p>and bools are arithematic types from 3.9.1 Fundamental types</p>\n<blockquote>\n<p id=\"so_26143976_26144079_1\">Types <strong>bool</strong>, char, char16_t, char32_t, wchar_t, and the signed and unsigned integer types are collectively\n  <strong>called integral types.</strong></p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_26143976_26144079_2\">Integral and floating types are collectively called arithmetic\n  types.</p>\n</blockquote>\n<p>and <code>true</code> and <code>false</code> are boolean literals from <code>2.14.6</code> Boolean literals:</p>\n<pre><code>boolean-literal:\n    false\n    true\n</code></pre>\n<p>Going back to section <code>5.9</code> to see the mechanics of the relational operators further, it says:</p>\n<blockquote>\n<p id=\"so_26143976_26144079_3\">The usual arithmetic conversions are performed on operands of arithmetic or enumeration type.</p>\n</blockquote>\n<p>the <em>usual arithmetic conversions</em> are covered in section <code>5</code> which says:</p>\n<blockquote>\n<p id=\"so_26143976_26144079_4\">Otherwise, the integral promotions (4.5) shall be performed on both operands</p>\n</blockquote>\n<p>and section <code>4.5</code> says:</p>\n<blockquote>\n<p id=\"so_26143976_26144079_5\">A prvalue of type bool can be converted to a prvalue of type int, with false becoming zero and true\n  becoming one.</p>\n</blockquote>\n<p>and so the expressions:</p>\n<pre><code>false &lt; false\nfalse &lt; true\ntrue &lt; false\ntrue &lt; true\n</code></pre>\n<p>using these rules become:</p>\n<pre><code>0 &lt; 0\n0 &lt; 1\n1 &lt; 0\n1 &lt; 1\n</code></pre>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-10-02T09:20:24.607", "Id": "26144079", "Score": "200", "CreationDate": "2014-10-01T14:45:53.890", "LastActivityDate": "2014-10-02T09:20:24.607"}, "bq_ids": {"n4140": {"so_26143976_26144237_0": {"section_id": 6138, "quality": 0.8888888888888888, "length": 8}, "so_26143976_26144237_2": {"section_id": 7215, "quality": 0.8260869565217391, "length": 19}, "so_26143976_26144079_4": {"section_id": 5943, "quality": 1.0, "length": 6}, "so_26143976_26144079_1": {"section_id": 7216, "quality": 1.0, "length": 14}, "so_26143976_26144079_3": {"section_id": 6138, "quality": 0.8888888888888888, "length": 8}, "so_26143976_26144079_2": {"section_id": 7217, "quality": 0.7142857142857143, "length": 5}, "so_26143976_26144079_5": {"section_id": 26, "quality": 1.0, "length": 14}, "so_26143976_26144237_3": {"section_id": 26, "quality": 1.0, "length": 14}, "so_26143976_26144079_0": {"section_id": 6149, "quality": 0.8275862068965517, "length": 24}}, "n3337": {"so_26143976_26144237_0": {"section_id": 5902, "quality": 0.8888888888888888, "length": 8}, "so_26143976_26144237_2": {"section_id": 6959, "quality": 0.8260869565217391, "length": 19}, "so_26143976_26144079_4": {"section_id": 5714, "quality": 1.0, "length": 6}, "so_26143976_26144079_1": {"section_id": 6960, "quality": 1.0, "length": 14}, "so_26143976_26144079_2": {"section_id": 5714, "quality": 0.5714285714285714, "length": 4}, "so_26143976_26144079_5": {"section_id": 23, "quality": 1.0, "length": 14}, "so_26143976_26144079_3": {"section_id": 5902, "quality": 0.8888888888888888, "length": 8}, "so_26143976_26144079_0": {"section_id": 5912, "quality": 0.896551724137931, "length": 26}, "so_26143976_26144237_3": {"section_id": 23, "quality": 1.0, "length": 14}}, "n4659": {"so_26143976_26144237_0": {"section_id": 7635, "quality": 0.8888888888888888, "length": 8}, "so_26143976_26144237_2": {"section_id": 8724, "quality": 0.8260869565217391, "length": 19}, "so_26143976_26144079_4": {"section_id": 7428, "quality": 1.0, "length": 6}, "so_26143976_26144079_1": {"section_id": 8725, "quality": 1.0, "length": 14}, "so_26143976_26144079_3": {"section_id": 7635, "quality": 0.8888888888888888, "length": 8}, "so_26143976_26144079_2": {"section_id": 8726, "quality": 1.0, "length": 7}, "so_26143976_26144079_5": {"section_id": 26, "quality": 1.0, "length": 14}, "so_26143976_26144237_3": {"section_id": 26, "quality": 1.0, "length": 14}, "so_26143976_26144079_0": {"section_id": 7646, "quality": 0.8275862068965517, "length": 24}}}, "26157563": {"ParentId": "26143976", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Boolean <code>false</code> is equivalent to <code>int 0</code>, and boolean <code>true</code> is equivalent to <code>int 1</code>.\nSo this explains why the expression <code>false &lt; true</code> =&gt; <code>0 &lt; 1</code> is the only one which returns <code>true</code>.</p>\n", "OwnerUserId": "3360017", "LastEditorUserId": "3313438", "LastEditDate": "2015-10-24T21:55:38.463", "Id": "26157563", "Score": "7", "CreationDate": "2014-10-02T09:03:17.043", "LastActivityDate": "2015-10-24T21:55:38.463"}});