post_cb({"9610724": {"ParentId": "9607089", "CommentCount": "0", "Body": "<p>OK, let's start from the beginning. The \"template-name\" of a template is the actual name of the function or class being templated; that is, in</p>\n<pre><code>template&lt;class T&gt; T foo(T t);\n</code></pre>\n<p><code>foo</code> is the template name. For function templates, the rule for deciding whether they are the same is quite long, described in 14.5.5.1 \"Function template overloading\". Paragraph 6 of that section (I'm quoting from C++03 here, so the wording and paragraph numbers might have changed in C++11) defines the terms <em>equivalent</em> and <em>functionally equivalent</em>, when applied to expressions involving template parameters.</p>\n<p>In short, <em>equivalent</em> expressions are the same apart from possibly having different names for template parameters, and <em>functionally equivalent</em> expressions are the same if they happen to evaluate to the same thing. For example, the first two <code>f</code> declarations are <em>equivalent</em>, but the third is only <em>functionally equivalent</em> to the other two:-</p>\n<pre><code>template&lt;int A, int B&gt;\nvoid f(array&lt;A + B&gt;);\ntemplate&lt;int T1, int T2&gt;\nvoid f(array&lt;T1 + T2&gt;);\ntemplate&lt;int A, int B&gt;\nvoid f(array&lt; mpl::plus&lt; mpl::int&lt;A&gt;, mpl::int&lt;B&gt; &gt;::value &gt;);\n</code></pre>\n<p>It goes on in paragraph 7 to extend those two definitions to whole function templates. Two function templates that match (in name, scope, and template parameter lists) are equivalent if they also have equivalent return types and argument types, or functionally equivalent if they only have functionally equivalent return types and argument types. Looking at your second example, these two functions are only functionally equivalent:-</p>\n<pre><code>template&lt;typename T&gt;\nT foo(T t);\n\ntemplate&lt;typename T&gt;\ntypename identity&lt;T&gt;::type foo(T t);\n</code></pre>\n<p>Paragraph 7 closes with the dire warning that, \"If a program contains declarations of function templates that are functionally equivalent but not equivalent, the program is ill-formed; no diagnostic is required.\" Your second example is, thus, not valid C++. Detecting errors like that would require each declaration and definition of a function template to be annotated in the binary with an AST describing the template expression each parameter and the return type came from, which is why the standard doesn't require implementations to detect it. MSVC is justified in compiling your third example how you intended, but it would be just as justified to break.</p>\n<p>Moving on to explicit instantiation, the important section is 14.7, \"Template instantiation and specialization\". Paragraph 5 disallows all of the following:</p>\n<ul>\n<li>Explicitly instantiating a template more than once;</li>\n<li>Explicitly instantiating and explicitly specializing the same template;</li>\n<li>Explicitly specializing a template for the same set of arguments more than once.</li>\n</ul>\n<p>Again, \"no diagnostic is required\" as it's quite hard to detect.</p>\n<p>So to expand your explicit instantiation example, the following code breaks the second rule and is illegal :-</p>\n<pre><code>/* Template definition. */\ntemplate&lt;typename T&gt;\nT foo(T t)\n{ ... }\n\n/* Specialization, OK in itself. */\ntemplate&lt; &gt;\nint foo(int t)\n{ ... }\n\n/* Explicit instantiation, OK in itself. */\ntemplate&lt; &gt;\nint foo(int t);\n</code></pre>\n<p>This is illegal regardless of the locations of the explicit specialization and the explicit instantiation, but of course because no diagnostic is required, you may get useful results on some compilers. Note also the difference between explicit instantiation and explicit specialization. The following example is ill-formed because it declares an explicit specialization without defining it:-</p>\n<pre><code>template&lt;typename T&gt;\nT f(T f)\n{ ... }\n\ntemplate&lt; &gt;\nint f(int);\n\nvoid g(void)\n{ f(3); }\n</code></pre>\n<p>but this example is well-formed, because it has an explicit instantiation:-</p>\n<pre><code>template&lt;typename T&gt;\nT f(T f)\n{ ... }\n\ntemplate f(int);\n\nvoid g(void)\n{ f(3); }\n</code></pre>\n<p>The <code>&lt; &gt;</code> makes all the difference. Be warned also that even when you do define an explicit specialization, it has to be <strong>before</strong> you use it, otherwise the compiler might already have generated an implicit instantiation for that template. This is in 14.7.3 \"Explicit specialization\" paragraph 6, just below where you were reading, and again, no diagnostic is required. To adapt the same example, this is ill-formed:-</p>\n<pre><code>template&lt;typename T&gt;\nT f(T f)\n{ ... }\n\nvoid g(void)\n{ f(3); } // Implicitly specializes int f(int)\n\ntemplate&lt; &gt;\nint f(int) // Too late for an explicit specialization\n{ ... }\n</code></pre>\n<p>If you weren't confused enough yet, take a look at your last example:-</p>\n<pre><code>template&lt;typename T&gt;\nT foo(T t) { ... }\n\ntemplate&lt;typename T&gt;\nint foo(int t) { ... }\n</code></pre>\n<p>The second definition of <code>foo</code> is <strong>not</strong> a specialization of the first definition. It would have to be <code>template&lt; &gt; int foo(int)</code> to be a specialization of <code>template&lt;typename T&gt; T foo(T)</code>. But that's OK: function overloading is allowed, and it's allowed between function templates and normal functions. Calls of the form <code>foo(3)</code> will always use the first definition, because its template parameter <code>T</code> can be deduced from the argument type. The second definition does not allow its template parameter to be deduced from the argument type. Only by explicitly specifying <code>T</code> can you reach the second definition, and only then when the call is not ambiguous with the first definition:-</p>\n<pre><code>f&lt;int&gt;(3); // ambiguous\nf&lt;string&gt;(3); // can only be the second one\n</code></pre>\n<p>The whole process of doing overload resolution for function templates is too long to describe here. Read section 14.8.3 if you're interested and ask more questions :-)</p>\n", "OwnerUserId": "967945", "PostTypeId": "2", "Id": "9610724", "Score": "4", "CreationDate": "2012-03-07T23:24:38.460", "LastActivityDate": "2012-03-07T23:24:38.460"}, "9607089": {"CommentCount": "1", "AcceptedAnswerId": "9610724", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-03-07T18:29:37.857", "LastActivityDate": "2012-03-07T23:24:38.460", "LastEditDate": "2017-05-23T12:06:12.023", "ViewCount": "301", "FavoriteCount": "1", "Title": "How are template definitions matched to template declarations?", "Id": "9607089", "Score": "7", "Body": "<p>How exactly is a template declaration matched to a template definition? I found some text in the standard about <em>template-ids</em> referring to the same function if \"their <em>template-names</em> [...] refer to the same template and [...]\" (14.4 [temp.type] p1) but I can't find a definition for <em>template-names</em> or when <em>template-names</em> refer to the same template. I'm not sure if I'm on the right track anyway because I haven't deciphered the grammar well enough to tell if a <em>template-id</em> is part of the definition/declaration of a template, or just a use of a template.</p>\n<p>For example, the following program works fine.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nT foo(T t);\n\nint main() {\n    foo(1);\n}\n\ntemplate&lt;typename T&gt;\nT foo(T t)\n{ std::cout &lt;&lt; \"A\\n\"; return 0; }\n</code></pre>\n<p>If I change the way I use the template parameters in the template definition the names apparently no longer refer to the same template, and linking fails.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nT foo(T t);\n\nint main() {\n    foo(1);\n}\n\ntemplate&lt;typename T&gt;\nint foo(T t) { std::cout &lt;&lt; \"A\\n\"; return 0; }\n\n// or\n\ntemplate&lt;typename T&gt;\nstruct identity {\n    typedef T type;\n};\n\ntemplate&lt;typename T&gt;\ntypename identity&lt;T&gt;::type\nfoo(T t) { std::cout &lt;&lt; \"A\\n\"; return 0; }\n</code></pre>\n<p>Next, if I move the template definition to another translation unit, for my implementation of C++ (MSVC 11 beta) the program works no matter how I say the types.</p>\n<pre><code>//main.cpp\n\ntemplate&lt;typename T&gt;\nT foo(T t);\n\nint main() {\n    foo(1);\n}\n\n//definition.cpp\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nstruct identity {\n    typedef T type;\n};\n\ntemplate&lt;typename T&gt;\ntypename identity&lt;T&gt;::type\nfoo(T t) { std::cout &lt;&lt; \"A\\n\"; return 0; }\n\ntemplate int foo&lt;int&gt;(int);\n</code></pre>\n<p>or</p>\n<pre><code>//definition.cpp\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nint foo(T t) { std::cout &lt;&lt; \"A\\n\"; return 0; }\n\ntemplate int foo&lt;int&gt;(int);\n</code></pre>\n<p>or even if the definition isn't a template at all:</p>\n<pre><code>//definition.cpp\n#include &lt;iostream&gt;\n\nint foo(T t) { std::cout &lt;&lt; \"A\\n\"; return 0; }\n</code></pre>\n<p>Obviously linking is succeeding because the signature/mangled name is the same regardless of the template that was instantiated to create the symbol. I think this undefined behavior  because I'm violating:</p>\n<blockquote>\n<p id=\"so_9607089_9607089_0\"><em>\u00a7 14.1 [temp] p6</em></p>\n<p id=\"so_9607089_9607089_1\">A function template, member function of a class template, or static\n  data member of a class template shall be defined in every translation\n  unit in which it is implicitly instantiated (14.7.1) unless the\n  corresponding specialization is explicitly instantiated (14.7.2) in\n  some translation unit; no diagnostic is required.</p>\n</blockquote>\n<p>But then say I try to fulfill those requirements by putting a definition of the template in the second translation unit, and including an explicit instantiation at one of two locations:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nT foo(T t) { std::cout &lt;&lt; \"A\\n\"; return 0; }\n\n// Location 1    \n\ntemplate&lt;typename T&gt;\nint foo(int t) { std::cout &lt;&lt; \"B\\n\"; return 0; }\n\n// Location 2\n</code></pre>\n<p>What are the rules about disambiguating what template an explicit instantiation refers to? Putting it at Location 1 causes the correct template to be instantiated and that definition to be used in the final program, while putting it at Location 2 instantiates the other template, and causes what I believe is undefined behavior under 14.1 p6 above.</p>\n<p>On the other hand an implicit instantiation of two templates definitions picks the first template no matter what, so it seems like the rule for disambiguating the templates is different in these circumstances:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nT foo(T t) { std::cout &lt;&lt; \"A\\n\"; return 0; }\n\ntemplate&lt;typename T&gt;\nint foo(int t) { std::cout &lt;&lt; \"B\\n\"; return 0; }\n\nint main() {\n    foo(1); // prints \"A\"\n}\n</code></pre>\n<p>The reason this came up is related to <a href=\"https://stackoverflow.com/questions/9570985/c-and-typetraits-simplest-way-of-defining-a-list-of-possible-definitions/9572326#9572326\">this question</a> where the questioner discovered that a single forward declaration </p>\n<pre><code>template&lt;typename T&gt;\nT CastScriptVarConst(const ScriptVar_t&amp; s);\n</code></pre>\n<p>could not act as a declaration of multiple template definitions:</p>\n<pre><code>template&lt;typename T&gt;\ntypename std::enable_if&lt;GetType&lt;T&gt;::value &lt; SVT_BASEOBJ,T&gt;::type\nCastScriptVarConst(const ScriptVar_t&amp; s) {\n    return (T) s;\n}\n\ntemplate&lt;typename T&gt;\ntypename std::enable_if&lt;!(GetType&lt;T&gt;::value &lt; SVT_BASEOBJ)\n                        &amp;&amp; std::is_base_of&lt;CustomVar,T&gt;::value,T&gt;::type\nCastScriptVarConst(const ScriptVar_t&amp; s) {\n    return *s.as&lt;T&gt;();\n}\n</code></pre>\n<p>And I wanted to better understand the relationship between template definitions and declarations.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "365496", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_9607089_9607089_1": {"section_id": 53, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_9607089_9607089_1": {"section_id": 48, "quality": 0.9285714285714286, "length": 26}}, "n4659": {"so_9607089_9607089_1": {"section_id": 55, "quality": 0.9285714285714286, "length": 26}}}});