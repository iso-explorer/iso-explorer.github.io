post_cb({"25887077": {"ParentId": "25886998", "CommentCount": "0", "Body": "<p>You can't do that because you assigned a string literal to your <code>char*</code>. And this is memory you can't modify.</p>\n", "OwnerUserId": "1594913", "PostTypeId": "2", "Id": "25887077", "Score": "0", "CreationDate": "2014-09-17T09:38:40.043", "LastActivityDate": "2014-09-17T09:38:40.043"}, "25886998": {"CommentCount": "4", "ViewCount": "511", "PostTypeId": "1", "LastEditorUserId": "442284", "CreationDate": "2014-09-17T09:34:20.297", "LastActivityDate": "2014-09-17T15:49:33.257", "Title": "c++ pass by value segmentation fault", "AcceptedAnswerId": "25887297", "LastEditDate": "2014-09-17T09:50:58.290", "Id": "25886998", "Score": "-3", "Body": "<p>I have a function f() which receives a char* p and gives a const char* to it. </p>\n<pre><code>void f(char *p) {\n  string s = \"def\";\n  strcpy(p, s.c_str());\n}\n</code></pre>\n<p>In the main() below I expect to get q = \"def\". </p>\n<pre><code>int main(){\n  char *q = \"abc\";\n  f(q);\n  cout &lt;&lt; q &lt;&lt; endl;\n}\n</code></pre>\n<p>By running this I get segmentation fault and as I am new in C++ I don't understand why.</p>\n<p>I also get a segmentation fault when I do not initialize <code>q</code> thus:</p>\n<pre><code>int main(){\n  char *q;\n  f(q);\n  cout &lt;&lt; q &lt;&lt; endl;\n}\n</code></pre>\n<p>Knowing that the function's parameter and the way it's called must not change. Is there any work around that I can do inside the function? Any suggestions?\nThanks for your help.</p>\n", "Tags": "<c++>", "OwnerUserId": "2486067", "AnswerCount": "6"}, "25887227": {"ParentId": "25886998", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-09-17T09:45:49.337", "Score": "2", "LastEditorUserId": "442284", "LastEditDate": "2014-09-17T10:16:00.553", "Id": "25887227", "OwnerUserId": "442284", "Body": "<p>This is an issue that, in reality, should fail at compilation time but for really old legacy reasons they allow it.</p>\n<p><code>\"abc\"</code> is not not a mutable string and therefore it should be illegal to point a mutable pointer to it.</p>\n<p>Really any legacy code that does this should be forced to be fixed, or have some pragma around it that lets it compile or some permissive flag set in the build.</p>\n<p>But a long time ago in the old days of C there was no such thing as a const modifier, and literals were stored in char * parameters and programmers had to be careful what they did with them.</p>\n<p>The latter construct, where <code>q</code> is not initialised at all is an error because now <code>q</code> could be pointing anywhere, and is unlikely to be pointing to a valid memory place to write the string. It is actually undefined behaviour, for obvious reason - who knows where <code>q</code> is pointing?</p>\n<p>The normal construct for such a function like <code>f</code> is to request not only a pointer to a writable buffer but also a maximum available size (capacity). Usually this size includes the null-terminator, sometimes it might not, but either way the function <code>f</code> can then write into it without an issue. It will also often return a status, possibly the number of bytes it wanted to write. This is very common for a \"C\" interface. (And C interfaces are often used even in C++ for better portability / compatibility with other languages).</p>\n<p>To make it work in this instance, you need at least 4 bytes in your buffer.</p>\n<pre><code>int main()\n{\n    char q[4];\n    f(q);\n    std::cout &lt;&lt; q &lt;&lt; std::endl;\n}\n</code></pre>\n<p>would work.</p>\n<p>Inside the function <code>f</code> you can use <a href=\"http://www.cplusplus.com/reference/string/string/copy/\" rel=\"nofollow\">std::string::copy</a> to copy into the buffer. Let's modify <code>f</code>.\n(We assume this is a prototype and in reality you have a meaningful name and it returns something more meaningful that you retrieve off somewhere).</p>\n<pre><code>size_t f( char * buf, size_t capacity )\n{\n    std::string s = \"def\";\n    size_t copied = s.copy( buf, capacity-1 ); // leave a space for the null\n    buf[copied] = '\\0'; // std::string::copy doesn't write this\n    return s.size() + 1; // the number of bytes you need\n}\n\nint main()\n{\n     char q[3];\n     size_t needed = f( q, 3 );\n     std::cout &lt;&lt; q &lt;&lt; \" - needed \" &lt;&lt; needed &lt;&lt; \" bytes \" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output should be:</p>\n<pre><code>de needed 4 bytes\n</code></pre>\n<p>In your question you suggested you can change your function but not the way it is called. Well in that case, you actually have only one real solution:</p>\n<pre><code>void f( const char * &amp; p )\n{\n   p = \"def\";\n}\n</code></pre>\n<p>Now you can happily do</p>\n<pre><code>int main()\n{\n   const char * q;\n   f( q );\n   std::cout &lt;&lt; q &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Note that in this solution I am actually moving your pointer to point to something else. This works because it is a static string. You cannot have a local <code>std::string</code> then point it to its <code>c_str()</code>. You can have a <code>std::string</code> whose lifetime remains beyond the scope of your <code>q</code> pointer e.g. stored in a collection somewhere.</p>\n", "LastActivityDate": "2014-09-17T10:16:00.553"}, "25887067": {"ParentId": "25886998", "CommentCount": "10", "Body": "<p>Look at the warnings you get while compiling your code (and if you don\u2019t get any, turn up the warning levels or get a better compiler).</p>\n<p>You will notice that despite the type declaration, the value of <code>q</code> is not really mutable. The compiler was humoring you because not doing so would break a lot of legacy code.</p>\n", "OwnerUserId": "2332553", "PostTypeId": "2", "Id": "25887067", "Score": "0", "CreationDate": "2014-09-17T09:38:19.847", "LastActivityDate": "2014-09-17T09:38:19.847"}, "25887233": {"ParentId": "25886998", "CommentCount": "1", "Body": "<p>With your <code>f</code>, You should do</p>\n<pre><code>int main(){\n  char q[4 /*or more*/];\n  f(q);\n  std::cout &lt;&lt; q &lt;&lt; std::endl;\n}\n</code></pre>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "25887233", "Score": "0", "CreationDate": "2014-09-17T09:45:59.360", "LastActivityDate": "2014-09-17T09:45:59.360"}, "25887239": {"ParentId": "25886998", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-09-17T09:46:01.787", "Score": "4", "LastEditorUserId": "2877241", "LastEditDate": "2014-09-17T15:49:33.257", "Id": "25887239", "OwnerUserId": "2877241", "Body": "<p>You are trying to change a string literal. Any attemp to change a string literal results in undefined behaviour of the program.</p>\n<p>Take into account that string literals have types of constant character arrays. So it would be more correct to write</p>\n<pre><code>  const char *q = \"abc\";\n</code></pre>\n<p>From the C++ Standard (2.14.5 String literals)</p>\n<blockquote>\n<p id=\"so_25886998_25887239_0\">8 Ordinary string literals and UTF-8 string literals are also referred\n  to as narrow string literals. A narrow string literal has type\n  \u201c<strong>array of n const char</strong>\u201d, where n is the size of the string as\n  defined below, and has static storage duration</p>\n</blockquote>\n<p>You could write your program the following way</p>\n<pre><code>//...\nvoid f(char *p) {\n  string s = \"def\";\n  strcpy(p, s.c_str());\n}\n//..\nmain(){\n  char q[] = \"abc\";\n  f(q);\n  cout &lt;&lt; q &lt;&lt; endl;\n}\n</code></pre>\n<p>If you need to use a pointer then you could write</p>\n<pre><code>//...\nvoid f(char *p) {\n  string s = \"def\";\n  strcpy(p, s.c_str());\n}\n//..\nmain(){\n  char *q = new char[4] { 'a', 'b', 'c', '\\0' };\n  f(q);\n  cout &lt;&lt; q &lt;&lt; endl;\n  delete []q;  \n}\n</code></pre>\n", "LastActivityDate": "2014-09-17T15:49:33.257"}, "bq_ids": {"n4140": {"so_25886998_25887239_0": {"section_id": 5356, "quality": 1.0, "length": 26}}, "n3337": {"so_25886998_25887239_0": {"section_id": 5153, "quality": 1.0, "length": 26}}, "n4659": {"so_25886998_25887239_0": {"section_id": 6781, "quality": 1.0, "length": 26}}}, "25887297": {"ParentId": "25886998", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2014-09-17T09:48:36.520", "Score": "-4", "LastEditorUserId": "3884862", "LastEditDate": "2014-09-17T11:31:08.837", "Id": "25887297", "OwnerUserId": "3884862", "Body": "<p>The problem is that you are trying to write on a read-only place in the process address space. As all the string literals are placed in read-only-data. <code>char *q = \"abc\";</code> creates a pointer and points towards the read-only section where the string literal is placed. and when you copy using strcpy or memcpy or even try q[1] = 'x' it attempts to write on a space which is write protected. <br/></p>\n<p>This was the problem among many other solutions one can be</p>\n<pre><code>main(){\n  char *q = \"abc\";    \\\\ the strings are placed at a read-only portion \n                      \\\\ in the process address space so you can not write that\n  q = new char[4];    \\\\ will make q point at space at heap which is writable\n  f(q);\n  cout &lt;&lt; q &lt;&lt; endl;\n\n  delete[] q;\n}\n</code></pre>\n<p>the initialization of q is unnecessary here. after the second line q gets a space of 4 characters on the heap (3 for chars and one for null char). This would work but there are many other and better solutions to this problem which varies from situation to situation.</p>\n", "LastActivityDate": "2014-09-17T11:31:08.837"}});