post_cb({"23250651": {"ViewCount": "300", "Body": "<p>I'm trying to understand some recursive C++ template code I've been handed, and I'm hitting some strange behavior.  For some reason, the compiler seems able to add two values at compile-time but doing a left-shift has to be left for run-time.  And even then, the problem only occurs if I try to build with c++11 enabled.</p>\n<p>The code (which I've boiled down and you will see later) defines two pairs of templates - one pair named <code>shft</code> and <code>shft_aux</code> and one pair named <code>add</code> and <code>add_aux</code> that generate themselves recursively.  BTW, the <code>add</code> template is not supposed to be useful, its sole purpose is to demonstrate the problem, not to generate an actual <code>min</code> value.</p>\n<p>If I compile this code with no command-line parameters, it compiles just fine.  But if I specify <code>-std=c++11 -stdlib=libc++</code>, the static_assert on add_aux is still fine but the static_assert on shft_aux now generates a compile-time error saying <code>static_assert expression is not an integral constant expression</code>.</p>\n<p>Why is left-shift treated differently from addition?</p>\n<p>Thanks,\nChris</p>\n<p>p.s. I'm using clang++ version <code>Apple LLVM version 5.1 (clang-503.0.38) (based on LLVM 3.4svn)</code></p>\n<pre><code>#include &lt;climits&gt;\n\ntemplate &lt;unsigned size&gt; struct shft; // forward\n\ntemplate &lt;unsigned size&gt;\nstruct shft_aux\n{\n    static const int min = shft&lt;size&gt;::min;\n};\n\ntemplate &lt;unsigned size&gt;\nstruct shft\n{\n    typedef shft_aux&lt;size - 1&gt; prev;\n    static const int min = prev::min &lt;&lt; CHAR_BIT;\n};\n\n// Base specialization of shft, puts an end to the recursion.\ntemplate &lt;&gt;\nstruct shft&lt;1&gt;\n{\n    static const int min = SCHAR_MIN;\n};\n\n\n// -----\n\ntemplate &lt;unsigned size&gt; struct add; // forward\n\ntemplate &lt;unsigned size&gt;\nstruct add_aux\n{\n    static const int min = add&lt;size&gt;::min;\n};\n\ntemplate &lt;unsigned size&gt;\nstruct add\n{\n    typedef add_aux&lt;size - 1&gt; prev;\n    static const int min = prev::min + CHAR_BIT;\n};\n\n// Base specialization of add, puts an end to the recursion.\ntemplate &lt;&gt;\nstruct add&lt;1&gt;\n{\n    static const int min = SCHAR_MIN;\n};\n\n\n// -----\n\nint main()\n{\n    static_assert(shft_aux&lt;sizeof(int)&gt;::min &lt; 0, \"min is not negative\");\n    static_assert(add_aux&lt;sizeof(int)&gt;::min &lt; 0, \"min is not negative\");\n\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "23250909", "Title": "Strange behavior with c++ recursive templates when c++11 is enabled", "CreationDate": "2014-04-23T16:51:15.507", "Id": "23250651", "CommentCount": "2", "LastEditDate": "2014-04-23T16:54:23.660", "PostTypeId": "1", "LastEditorUserId": "1692107", "LastActivityDate": "2014-04-23T17:14:43.107", "Score": "6", "OwnerUserId": "1997735", "Tags": "<c++><templates><c++11><recursion><clang++>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_23250651_23250909_0": {"length": 23, "quality": 0.92, "section_id": 6147}, "so_23250651_23250909_2": {"length": 7, "quality": 0.6363636363636364, "section_id": 6185}, "so_23250651_23250909_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 6147}, "so_23250651_23250909_4": {"length": 20, "quality": 1.0, "section_id": 5908}, "so_23250651_23250909_3": {"length": 17, "quality": 0.7391304347826086, "section_id": 6185}}, "n3337": {"so_23250651_23250909_0": {"length": 23, "quality": 0.92, "section_id": 5910}, "so_23250651_23250909_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 5946}, "so_23250651_23250909_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 5910}, "so_23250651_23250909_4": {"length": 20, "quality": 1.0, "section_id": 5680}}, "n4659": {"so_23250651_23250909_0": {"length": 23, "quality": 0.92, "section_id": 7643}, "so_23250651_23250909_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 7643}, "so_23250651_23250909_4": {"length": 20, "quality": 1.0, "section_id": 7390}, "so_23250651_23250909_3": {"length": 17, "quality": 0.7391304347826086, "section_id": 7687}}}, "23250909": {"Id": "23250909", "PostTypeId": "2", "Body": "<p>C++11 Standard, [expr.shift]/2</p>\n<blockquote>\n<p id=\"so_23250651_23250909_0\">The value of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions; vacated bits are zero-filled. If <code>E1</code> has an unsigned type, [...]. Otherwise, if <code>E1</code> has a signed type and non-negative value, and <i>E1*2<sup>E2</sup></i> is representable\n  in the result type, then that is the resulting value; <strong>otherwise, the behavior is undefined</strong>.</p>\n</blockquote>\n<p>[emphasis mine]</p>\n<p>This is affected slightly by <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1457\">DR1457</a> which makes shifting <em>into the \"sign-bit\"</em> defined behaviour:</p>\n<blockquote>\n<p id=\"so_23250651_23250909_1\">Otherwise, if <code>E1</code> has a signed type and non-negative value, and <i>E1*2<sup>E2</sup></i> is representable in the corresponding unsigned type of the result type [...].</p>\n</blockquote>\n<p>Anyway, in the OP, <code>E1</code> is negative, so that's still Undefined Behaviour. As such, it is not allowed inside <em>constant expressions</em>:</p>\n<blockquote>\n<p id=\"so_23250651_23250909_2\">[expr.const]/2\n  A <em>conditional-expression</em> is a <em>core constant expression</em> unless it involves one of the following as a potentially evaluated subexpression [...]</p>\n<ul>\n<li>[...]</li>\n<li>a result that is not mathematically defined or not in the range of representable values for its type;</li>\n</ul>\n</blockquote>\n<p>That point has changed (<a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1313\">DR1313</a>); in n3485 it says:</p>\n<blockquote id=\"so_23250651_23250909_3\">\n<ul>\n<li>an operation that would have undefined behavior  [ <em>Note:</em> including, for example, signed integer over-\n  flow (Clause 5), certain pointer arithmetic (5.7), division by zero (5.6), or certain shift operations (5.8)\n  <em>\u2014 end note</em> ];</li>\n</ul>\n</blockquote>\n<hr>\n<p>[class.static.data]/3</p>\n<blockquote>\n<p id=\"so_23250651_23250909_4\">If a non-volatile <code>const static</code> data member is of integral or enumeration type, its declaration in the class definition can specify a <em>brace-or-equal-initializer</em> in which <strong>every <em>initializer-clause</em> that is an assignment-expression is a constant expression</strong></p>\n</blockquote>\n<hr>\n<p>Conclusion: shifting <code>SCHAR_MIN</code> is not a constant expression, so you can't do that in the in-class initializer of a static data member.</p>\n<p>Hint: always compile with <code>-Wall -Wextra -pedantic</code>. Using no parameters IMO is a bad idea for g++ and compatible compilers. g++/clang++ per default use the <code>gnu99</code> mode (<a href=\"http://clang.llvm.org/docs/UsersManual.html#differences-between-various-standard-modes\">see clang doc</a>), which is an extension to C++98 AFAIK. Also, you'll miss many important warnings.</p>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2014-04-23T17:14:43.107", "Score": "7", "CreationDate": "2014-04-23T17:06:29.700", "ParentId": "23250651", "CommentCount": "4", "OwnerUserId": "420683", "LastEditDate": "2014-04-23T17:14:43.107"}});