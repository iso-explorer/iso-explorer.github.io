post_cb({"11615532": {"CommentCount": "1", "ViewCount": "2936", "PostTypeId": "1", "LastEditorUserId": "373025", "CreationDate": "2012-07-23T15:22:16.737", "LastActivityDate": "2012-07-23T22:11:01.870", "Title": "Using Partial Specialization in C++11", "AcceptedAnswerId": "11616312", "LastEditDate": "2012-07-23T15:37:16.370", "Id": "11615532", "Score": "5", "Body": "<p>I have the following code:</p>\n<pre><code>template&lt;class T, int I=44&gt; struct test {T j = I;};\n\ntemplate&lt;int J&gt; struct test&lt;int, J&gt; {int j = J;};\n\nint main()\n{\n  test&lt;55&gt; jj;\n\n  std::cout &lt;&lt; jj.j &lt;&lt; std::endl;\n  return(1);\n}\n</code></pre>\n<p>The compiler (clang) complains only about the line <code>test&lt;55&gt; jj</code></p>\n<p>I don't understand why? Is there a work around? </p>\n<p>And if it complains about that line, why doesn't it complain about the second template definition?</p>\n<p>Thanks in advance.</p>\n<p>The message is:</p>\n<pre><code>enable.cpp:17:8: error: template argument for template type parameter must be a type\ntest&lt;55&gt; jj;\n   ^~\nenable.cpp:9:16: note: template parameter is declared here\ntemplate&lt;class T, int I=44&gt; struct test\n</code></pre>\n", "Tags": "<c++><templates><c++11>", "OwnerUserId": "435426", "AnswerCount": "2"}, "11616312": {"ParentId": "11615532", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The problem is that you haven't understood how selecting a class template specialization works.</p>\n<p>Your specialization:</p>\n<pre><code>template&lt;int J&gt; struct test&lt;int, J&gt; {int j = J;};\n</code></pre>\n<p>does not create a template for which you only have to pass in a single int template parameter.</p>\n<pre><code>test&lt;55&gt; jj; // doesn't work because there's no template&lt;int J&gt; struct test\n</code></pre>\n<p>Instead what it does is create a specialization of <code>template&lt;class T, int I&gt; struct test</code> which will be used when the template arguments to <code>template&lt;class T, int I&gt; struct test</code> match the specialization, i.e. <code>test&lt;int,J&gt;</code>.</p>\n<pre><code>test&lt;int,55&gt; jj; // uses the specialization template&lt;int J&gt; struct test&lt;int, J&gt;\n</code></pre>\n<p>Here's the key quote from the standard:</p>\n<blockquote>\n<p id=\"so_11615532_11616312_0\">In a type name that refers to a class template specialization, (e.g.,\n  <code>A&lt;int, int, 1&gt;</code>) the argument list shall match the template parameter\n  list of the primary template. <strong>The template arguments of a\n  specialization are deduced from the arguments of the primary template.</strong> <em>[emphasis added]</em></p>\n<p id=\"so_11615532_11616312_1\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>\u2014 14.5.5.1 [temp.class.spec.match] p4</em></p>\n</blockquote>\n<hr>\n<p>You seem to be attempting to set <code>int</code> as a default type for <code>T</code> while simultaneously setting an independent default value for <code>I</code>. I think your intent is to be able to specify a type and a value, specify only a type and get 44 as a default value, or specify only a value and get int as a default type.</p>\n<p>Unfortunately I don't know of a way to specify independent defaults like that. You can specify defaults (<code>template&lt;class T=int, int I=44&gt; struct test</code>) but getting the default type will also require accepting the default value.</p>\n<p>However if you're willing to use a second name then you can do:</p>\n<pre><code>template &lt;int I&gt;\nusing test_int = test&lt;int, I&gt;;\n</code></pre>\n<p>This creates a template alias such that you only have to specify a value:</p>\n<pre><code>test_int&lt;55&gt; jj;\n</code></pre>\n<p>And this will end up using whatever specialization <code>test&lt;int, I&gt;</code> happens to resolve to whether there's an explicit specialization or the compiler generates an implicit one.</p>\n</hr>", "OwnerUserId": "365496", "LastEditorUserId": "365496", "LastEditDate": "2012-07-23T22:11:01.870", "Id": "11616312", "Score": "6", "CreationDate": "2012-07-23T16:09:50.530", "LastActivityDate": "2012-07-23T22:11:01.870"}, "11615768": {"ParentId": "11615532", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The first error occurs because the compiler tries to instantiate the <em>first</em> template parameter (<code>class T</code>) with 55. This does not work, because 55 is not a type itself, but an instantiation of it. However, <code>test&lt;int&gt;</code> works because here the template parater is a type, as requested by your template signature.</p>\n<p>What you want instead is \"currying\" for types, aka. template aliasing:</p>\n<pre><code>template &lt;typename T&gt;\nstruct test2 = using test&lt;T, 55&gt;;\n</code></pre>\n<p>Here you only need to provide a <code>T</code>  to choose 55 as fixed second parameter. But you still need to use that type by giving it a concrete <code>T</code>, e.g., <code>test2&lt;double&gt;</code>.</p>\n<p>The comments indicated you could also be interested in the following variant:</p>\n<pre><code>template &lt;int I&gt;\nusing test3 = test&lt;int, I&gt;;\n</code></pre>\n<p>Here you fix the first type parameter to int, which allows you to use it as you did in your code:</p>\n<pre><code>test3&lt;55&gt; t;\n</code></pre>\n", "OwnerUserId": "1170277", "LastEditorUserId": "726300", "LastEditDate": "2012-07-23T15:58:30.140", "Id": "11615768", "Score": "3", "CreationDate": "2012-07-23T15:36:16.317", "LastActivityDate": "2012-07-23T15:58:30.140"}, "bq_ids": {"n4140": {"so_11615532_11616312_0": {"section_id": 146, "quality": 0.8846153846153846, "length": 23}}, "n3337": {"so_11615532_11616312_0": {"section_id": 140, "quality": 0.8846153846153846, "length": 23}}, "n4659": {"so_11615532_11616312_0": {"section_id": 150, "quality": 0.8846153846153846, "length": 23}}}});