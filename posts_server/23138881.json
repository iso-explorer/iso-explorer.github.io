post_cb({"23138881": {"CommentCount": "6", "ViewCount": "133", "PostTypeId": "1", "LastEditorUserId": "168868", "CreationDate": "2014-04-17T16:43:32.450", "LastActivityDate": "2014-04-17T21:15:19.210", "Title": "why isn't my implicit ctor invoked in following", "AcceptedAnswerId": "23139850", "LastEditDate": "2014-04-17T16:55:01.840", "Id": "23138881", "Score": "1", "Body": "<p>With the following template to try to make C++ 11/14's new class-enum work as-desired, I find that the following code doesn't even try to invoke the implicit ctor to use a nonmember template that would fit by VS2013 update 1:</p>\n<p><code>BitTest</code> is defined as:</p>\n<pre><code>template &lt;typename enumT&gt;\nbool BitTest(const EnumeratedFlags&lt;enumT&gt;&amp; lhs, const EnumeratedFlags&lt;enumT&gt;&amp; rhs)\n{\n    return (lhs &amp; rhs);\n}\n</code></pre>\n<p>testing code with anomalies:</p>\n<pre><code>enum class Flags { None = 0x00, CanChangeDataSources = 0x01, RequiresExclusiveAccess = 0x02 };\nEnumeratedFlags&lt;Flags&gt; lhs(Flags::CanChangeDataSources);\n\n// ... the following fails to even attempt to convert the Foo::Flags\nif (BitTest(lhs, Flags::CanChangeDataSources)) { DoSomething(); }\n\n// this compiles, but I don't know why it's necessary (and this is annoying and ugly)...\nif (BitTest(lhs, EnumeratedFlags&lt;Flags&gt;(Flags::CanChangeDataSources))) { DoSomething(); }\n</code></pre>\n<p>Here is the template definition I am currently attempting to use:</p>\n<pre><code>template &lt;typename enumT&gt;\nclass EnumeratedFlags\n{\npublic:\n\n    typedef enumT enum_type;\n    typedef typename std::underlying_type&lt;enumT&gt;::type store_type;\n\n// constructors\n\n    EnumeratedFlags()\n        : m_bits(0)\n    {\n    }\n\n    EnumeratedFlags(enum_type flag)\n        : m_bits(static_cast&lt;store_type&gt;(flag))\n    {\n    }\n\n    explicit EnumeratedFlags(store_type value)\n        : m_bits(value)\n    {\n    }\n\n    EnumeratedFlags(const std::initializer_list&lt;enum_type&gt; &amp; initializers)\n        : m_bits(0)\n    {\n        for (auto flag : initializers)\n            m_bits |= static_cast&lt;store_type&gt;(flag);\n    }\n\n// operators\n\n    operator std::string () const\n    {\n        return to_string();\n    }\n\n    bool operator [] (enum_type flag) const\n    {\n        return test(flag);\n    }\n\n    store_type operator * () const\n    {\n        return m_bits;\n    }\n\n    operator bool () const\n    {\n        return m_bits != store_type(0);\n    }\n\n// explicit accessors\n\n    store_type bits() const\n    {\n        return m_bits;\n    }\n\n    std::string to_string() const\n    {\n        std::string str(size(), '0');\n\n        for (size_t x = 0; x &lt; size(); ++x)\n            str[size() - x - 1] = (m_bits &amp; (1 &lt;&lt; x) ? '1' : '0');\n\n        return str;\n    }\n\n    EnumeratedFlags &amp; set(enum_type flag)\n    {\n        BitSet(m_bits, static_cast&lt;store_type&gt;(flag));\n        return *this;\n    }\n\n    EnumeratedFlags &amp; set_if(enum_type flag, bool set_or_clear)\n    {\n        BitSetIf(m_bits, static_cast&lt;store_type&gt;(flag), set_or_clear);\n        return *this;\n    }\n\n    EnumeratedFlags &amp; clear()\n    {\n        m_bits = store_type(0);\n        return *this;\n    }\n\n    EnumeratedFlags &amp; flip()\n    {\n        m_bits = ~m_bits;\n        return *this;\n    }\n\n    EnumeratedFlags &amp; flip(enum_type flag)\n    {\n        m_bits ^= static_cast&lt;store_type&gt;(flag);\n        return *this;\n    }\n\n    size_t count() const\n    {\n        // http://www-graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\n\n        store_type bits = m_bits;\n        size_t total = 0;\n        for (; bits != 0; ++total)\n        {\n            bits &amp;= bits - 1; // clear the least significant bit set\n        }\n        return total;\n    }\n\n    size_t size() const\n    {\n        // one character per possible bit\n        return sizeof(enum_type) * 8;\n    }\n\n    bool test(enum_type flag) const\n    {\n        return BitTest(m_bits, static_cast&lt;store_type&gt;(flag));\n    }\n\n    bool any() const\n    {\n        return m_bits != 0;\n    }\n\n    bool none() const\n    {\n        return m_bits == 0;\n    }\n\nprivate:\n\n    store_type m_bits;\n};\n\ntemplate &lt;class charT, class traits, typename enumT&gt;\nstd::basic_ostream&lt;charT, traits&gt; &amp; operator &lt;&lt; (std::basic_ostream&lt;charT, traits&gt; &amp; os, const EnumeratedFlags&lt;enumT&gt; &amp; flags)\n{\n    return os &lt;&lt; flags.to_string();\n}\n\ntemplate &lt;typename enumT&gt;\nEnumeratedFlags&lt;enumT&gt; operator &amp; (const EnumeratedFlags&lt;enumT&gt;&amp; lhs, const EnumeratedFlags&lt;enumT&gt;&amp; rhs)\n{\n    return EnumeratedFlags&lt;enumT&gt;(lhs.bits() &amp; rhs.bits());\n}\n\ntemplate &lt;typename enumT&gt;\nEnumeratedFlags&lt;enumT&gt; operator | (const EnumeratedFlags&lt;enumT&gt;&amp; lhs, const EnumeratedFlags&lt;enumT&gt;&amp; rhs)\n{\n    return EnumeratedFlags&lt;enumT&gt;(lhs.bits() | rhs.bits());\n}\n\ntemplate &lt;typename enumT&gt;\nEnumeratedFlags&lt;enumT&gt; operator ^ (const EnumeratedFlags&lt;enumT&gt;&amp; lhs, const EnumeratedFlags&lt;enumT&gt;&amp; rhs)\n{\n    return EnumeratedFlags&lt;enumT&gt;(lhs.bits() ^ rhs.bits());\n}\n\ntemplate &lt;typename enumT&gt;\nbool BitTest(const EnumeratedFlags&lt;enumT&gt;&amp; lhs, const EnumeratedFlags&lt;enumT&gt;&amp; rhs)\n{\n    return (lhs &amp; rhs);\n}\n</code></pre>\n<p>Basically, I would have thought that any free function in the form of <code>X (const T &amp; lhs, const T &amp; rhs)</code> would use up to one user-defined conversion to find a valid invocation of <code>BitTest&lt;&gt;()</code>, above.  Instead, I have to explicitly state the conversion in my above code to get the compiler to use this function, which vastly reduces the expressive power of <code>template class EnumeratedFlags&lt;&gt;</code>.</p>\n<p>In general, C++ drives me nuts that there isn't a good way to use bits that combines all of the features and good programming habits of using a scoped enum (<code>enum class Foo</code>) and bit-fields (or a similar named set of bits) and make using them very easy for the client-programmer while retaining basic sanity checking from the compiler (won't auto-convert to a numeric type or vice-verse).  Seems like a more comprehensive improvement in the language spec is required to make a bit-field enum that really shines... or am I missing something?</p>\n", "Tags": "<c++><c++11><enums><visual-studio-2013><c++14>", "OwnerUserId": "112755", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23138881_23139850_0": {"section_id": 289, "quality": 1.0, "length": 20}}, "n3337": {"so_23138881_23139850_0": {"section_id": 280, "quality": 1.0, "length": 20}}, "n4659": {"so_23138881_23139850_0": {"section_id": 296, "quality": 1.0, "length": 20}}}, "23139850": {"ParentId": "23138881", "CommentCount": "5", "Body": "<p>From <em>\u00a714.8.1/6 [temp.arg.explicit]</em></p>\n<blockquote>\n<p id=\"so_23138881_23139850_0\">Implicit conversions (Clause 4) will be performed on a function argument to convert it to the type of the corresponding function parameter if the parameter type contains no <em>template-parameters</em> that participate in template argument deduction.</p>\n</blockquote>\n<p>In your example the second argument to <code>BitTest()</code> does participate in template argument deduction, hence no implicit conversion is attempted and the compiler is unable to convert the type <code>Flags</code> to <code>const EnumeratedFlags&lt;Flag&gt;&amp;</code>.</p>\n<p>You could solve it by converting the second parameter type to a non-deduced context, thus preventing it from participating in template argument deduction.</p>\n<pre><code>template &lt;typename enumT&gt;\nbool BitTest(const EnumeratedFlags&lt;enumT&gt;&amp; lhs, \n             const EnumeratedFlags&lt;typename EnumeratedFlags&lt;enumT&gt;::enum_type&gt;&amp; rhs)\n{\n    return (lhs &amp; rhs);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/e5b60b22a95e5d52\">Live demo</a></p>\n<p>Of course, the other solution is to provide these overloads instead</p>\n<pre><code>template &lt;typename enumT&gt;\nbool BitTest(const EnumeratedFlags&lt;enumT&gt;&amp; lhs, \n             enumT rhs)\n{\n    return (lhs &amp; EnumeratedFlags&lt;enumT&gt;(rhs));\n}\n\ntemplate &lt;typename enumT&gt;\nbool BitTest(enumT lhs, \n             const EnumeratedFlags&lt;enumT&gt;&amp; rhs)\n{\n    return BitTest(rhs, lhs);\n}\n</code></pre>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "23139850", "Score": "5", "CreationDate": "2014-04-17T17:38:26.473", "LastActivityDate": "2014-04-17T17:38:26.473"}, "23143588": {"ParentId": "23138881", "CommentCount": "0", "Body": "<p>My question is already answered above. However, this has been bothering me forever, so I was able to leverage everyone's responses and came up with, what I think is for the first time, a mechanism that I really like!</p>\n<p>This gives me a way to use C++ enumerations to store bit flag values, and then to logically bit-manipulate them at will, while never losing type information or the compiler's assistance with making sure that I fall into the pit of success. :)</p>\n<p>I hope this helps you too!\n(Note: this code compiles and runs properly under VS2013 update 1)</p>\n<pre><code>#pragma once\n\n#include &lt;type_traits&gt;\n\n// This is my ongoing attempt to make a really solid enumeration facility in C++11/14\n//\n// What I hate about C++98 (and older) enum\n//  - lack of namespace scoping of the non-class enum (name collisions everywhere)\n//  - auto conversion to numeric types (int i = MyEnumConstant), but no conversion back again (so supports losing info, but restricts regaining it)\n//\n// What I hate about C++11/14 built-in `enum class X`\n//  - having to constantly cast in order to treat them (now neither direction works)\n//  - no built-in mechanism to treat enumerated values as bits or bit-flags\n\ntemplate &lt;typename enum_type&gt;\nclass bitflag_enum\n{\npublic:\n\n    // expose our underlying types\n    typedef enum_type enum_type;\n    typedef typename std::underlying_type&lt;enum_type&gt;::type store_type;\n\n    // constructors\n\n    bitflag_enum()\n        : m_bits(0)\n    {\n    }\n\n    bitflag_enum(enum_type flag)\n        : m_bits(static_cast&lt;store_type&gt;(flag))\n    {\n    }\n\n    explicit bitflag_enum(store_type value)\n        : m_bits(value)\n    {\n    }\n\n    // operators\n\n    operator bool() const\n    {\n        return m_bits != store_type(0);\n    }\n\n    // explicit accessors\n\n    store_type bits() const\n    {\n        return m_bits;\n    }\n\nprivate:\n\n    store_type m_bits;\n};\n\n// because implicit conversion isn't considered if a type participates in template type deduction,\n// we've defined both homogeneous and heterogeneous operators here for bitflag_enum&lt;enum_type&gt; and enum_type\n// hence we define logical operators &amp;, |, ^ and comparisons for TxT, TxU, UxT (where T is bitflag_enum&lt;enum_type&gt;, and U is enum_type)\n\ntemplate &lt;typename enum_type&gt;\nbool operator != (bitflag_enum&lt;enum_type&gt; lhs, bitflag_enum&lt;enum_type&gt; rhs)\n{\n    return bitflag_enum&lt;enum_type&gt;(lhs.bits() != rhs.bits());\n}\n\ntemplate &lt;typename enum_type&gt;\nbool operator != (bitflag_enum&lt;enum_type&gt; lhs, enum_type rhs)\n{\n    using store_type = std::underlying_type&lt;enum_type&gt;::type;\n    return bitflag_enum&lt;enum_type&gt;(lhs.bits() != static_cast&lt;store_type&gt;(rhs));\n}\n\ntemplate &lt;typename enum_type&gt;\nbool operator != (enum_type lhs, bitflag_enum&lt;enum_type&gt; rhs)\n{\n    using store_type = std::underlying_type&lt;enum_type&gt;::type;\n    return bitflag_enum&lt;enum_type&gt;(static_cast&lt;store_type&gt;(lhs) != rhs.bits());\n}\n\ntemplate &lt;typename enum_type&gt;\nbool operator == (bitflag_enum&lt;enum_type&gt; lhs, bitflag_enum&lt;enum_type&gt; rhs)\n{\n    return bitflag_enum&lt;enum_type&gt;(lhs.bits() == rhs.bits());\n}\n\ntemplate &lt;typename enum_type&gt;\nbool operator == (bitflag_enum&lt;enum_type&gt; lhs, enum_type rhs)\n{\n    using store_type = std::underlying_type&lt;enum_type&gt;::type;\n    return bitflag_enum&lt;enum_type&gt;(lhs.bits() == static_cast&lt;store_type&gt;(rhs));\n}\n\ntemplate &lt;typename enum_type&gt;\nbool operator == (enum_type lhs, bitflag_enum&lt;enum_type&gt; rhs)\n{\n    using store_type = std::underlying_type&lt;enum_type&gt;::type;\n    return bitflag_enum&lt;enum_type&gt;(static_cast&lt;store_type&gt;(lhs) == rhs.bits());\n}\n\ntemplate &lt;typename enum_type&gt;\nbitflag_enum&lt;enum_type&gt; operator &amp; (bitflag_enum&lt;enum_type&gt; lhs, bitflag_enum&lt;enum_type&gt; rhs)\n{\n    return bitflag_enum&lt;enum_type&gt;(lhs.bits() &amp; rhs.bits());\n}\n\ntemplate &lt;typename enum_type&gt;\nbitflag_enum&lt;enum_type&gt; operator &amp; (bitflag_enum&lt;enum_type&gt; lhs, enum_type rhs)\n{\n    using store_type = std::underlying_type&lt;enum_type&gt;::type;\n    return bitflag_enum&lt;enum_type&gt;(lhs.bits() &amp; static_cast&lt;store_type&gt;(rhs));\n}\n\ntemplate &lt;typename enum_type&gt;\nbitflag_enum&lt;enum_type&gt; operator &amp; (enum_type lhs, bitflag_enum&lt;enum_type&gt; rhs)\n{\n    using store_type = std::underlying_type&lt;enum_type&gt;::type;\n    return bitflag_enum&lt;enum_type&gt;(static_cast&lt;store_type&gt;(lhs)&amp; rhs.bits());\n}\n\ntemplate &lt;typename enum_type&gt;\nbitflag_enum&lt;enum_type&gt; operator | (bitflag_enum&lt;enum_type&gt; lhs, bitflag_enum&lt;enum_type&gt; rhs)\n{\n    return bitflag_enum&lt;enum_type&gt;(lhs.bits() | rhs.bits());\n}\n\ntemplate &lt;typename enum_type&gt;\nbitflag_enum&lt;enum_type&gt; operator | (bitflag_enum&lt;enum_type&gt; lhs, enum_type rhs)\n{\n    using store_type = std::underlying_type&lt;enum_type&gt;::type;\n    return bitflag_enum&lt;enum_type&gt;(lhs.bits() | static_cast&lt;store_type&gt;(rhs));\n}\n\ntemplate &lt;typename enum_type&gt;\nbitflag_enum&lt;enum_type&gt; operator | (enum_type lhs, bitflag_enum&lt;enum_type&gt; rhs)\n{\n    using store_type = std::underlying_type&lt;enum_type&gt;::type;\n    return bitflag_enum&lt;enum_type&gt;(static_cast&lt;store_type&gt;(lhs) | rhs.bits());\n}\n\ntemplate &lt;typename enum_type&gt;\nbitflag_enum&lt;enum_type&gt; operator ^ (bitflag_enum&lt;enum_type&gt; lhs, bitflag_enum&lt;enum_type&gt; rhs)\n{\n    return bitflag_enum&lt;enum_type&gt;(lhs.bits() ^ rhs.bits());\n}\n\ntemplate &lt;typename enum_type&gt;\nbitflag_enum&lt;enum_type&gt; operator ^ (bitflag_enum&lt;enum_type&gt; lhs, enum_type rhs)\n{\n    using store_type = std::underlying_type&lt;enum_type&gt;::type;\n    return bitflag_enum&lt;enum_type&gt;(lhs.bits() ^ static_cast&lt;store_type&gt;(rhs));\n}\n\ntemplate &lt;typename enum_type&gt;\nbitflag_enum&lt;enum_type&gt; operator ^ (enum_type lhs, bitflag_enum&lt;enum_type&gt; rhs)\n{\n    using store_type = std::underlying_type&lt;enum_type&gt;::type;\n    return bitflag_enum&lt;enum_type&gt;(static_cast&lt;store_type&gt;(lhs) ^ rhs.bits());\n}\n\n// The only missing pieces above are for the UxU cases\n// we allow you to have those by defining a specialization of is_bitflag_enum&lt;&gt;, as follows:\n//\n// template &lt;&gt; struct is_bitflag_enum&lt;YourEnumType&gt; : std::true_type { };\n//\n// However, by default, no other types will convert to an bitflag_enum&lt;&gt; unless you explicitly say you want it\n//\n// If you have asked for them, then you can use MyEnum::ValueX | MyEnum::ValueY and that will produce a bitflag_enum&lt;MyEnum&gt;\n// so your code can simply use your enumeration values with scope and as-if they were bit flags as you would think you could\n\n// don't mess up existing enumerations or types by defining these global operators on every existing type!\ntemplate &lt;typename enum_type&gt; struct is_bitflag_enum : std::false_type { };\n\ntemplate &lt;typename enum_type&gt;\ntypename std::enable_if&lt;is_bitflag_enum&lt;enum_type&gt;::value, bitflag_enum&lt;enum_type&gt;&gt;::type\noperator &amp; (enum_type lhs, enum_type rhs)\n{\n    using store_type = std::underlying_type&lt;enum_type&gt;::type;\n    return bitflag_enum&lt;enum_type&gt;(static_cast&lt;store_type&gt;(lhs) &amp; static_cast&lt;store_type&gt;(rhs));\n}\n\ntemplate &lt;typename enum_type&gt;\ntypename std::enable_if&lt;is_bitflag_enum&lt;enum_type&gt;::value, bitflag_enum&lt;enum_type&gt;&gt;::type\noperator | (enum_type lhs, enum_type rhs)\n{\n    using store_type = std::underlying_type&lt;enum_type&gt;::type;\n    return bitflag_enum&lt;enum_type&gt;(static_cast&lt;store_type&gt;(lhs) | static_cast&lt;store_type&gt;(rhs));\n}\n\ntemplate &lt;typename enum_type&gt;\ntypename std::enable_if&lt;is_bitflag_enum&lt;enum_type&gt;::value, bitflag_enum&lt;enum_type&gt;&gt;::type\noperator ^ (enum_type lhs, enum_type rhs)\n{\n    using store_type = std::underlying_type&lt;enum_type&gt;::type;\n    return bitflag_enum&lt;enum_type&gt;(static_cast&lt;store_type&gt;(lhs) ^ static_cast&lt;store_type&gt;(rhs));\n}\n</code></pre>\n", "OwnerUserId": "112755", "PostTypeId": "2", "Id": "23143588", "Score": "1", "CreationDate": "2014-04-17T21:15:19.210", "LastActivityDate": "2014-04-17T21:15:19.210"}});