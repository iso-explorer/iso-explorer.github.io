post_cb({"11886930": {"ViewCount": "368", "Body": "<p>Let's consider the following code snippet</p>\n<pre><code>void Test()\n  {\n  int x = 0;\n\n  int&amp; rx = x;\n  int* px = &amp;x;\n\n  auto apx = px;    // deduced type is int*\n  auto arx = rx;    // deduced type is int\n  }\n</code></pre>\n<p>One could draw an analogy from pointer types expecting that the deduced type of <code>arx</code> is <code>int&amp;</code>, but it is <code>int</code> in fact. </p>\n<p>What is the rule in Standard which governs that? What is the reason behind it?\nSometimes I get caught by it in a case like this:</p>\n<pre><code>const BigClass&amp; GetBigClass();\n...\nauto ref_bigclass = GetBigClass();   // unexpected copy is performed\n</code></pre>\n", "AcceptedAnswerId": "11887501", "Title": "`auto` specifier type deduction for references", "CreationDate": "2012-08-09T15:38:12.873", "Id": "11886930", "CommentCount": "0", "LastEditDate": "2012-08-09T15:59:20.557", "PostTypeId": "1", "LastEditorUserId": "500104", "LastActivityDate": "2012-08-09T18:34:51.313", "Score": "4", "OwnerUserId": "1345960", "Tags": "<c++><c++11><type-inference>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_11886930_11887041_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 305}}, "n3337": {"so_11886930_11887041_0": {"length": 18, "quality": 0.9, "section_id": 5245}, "so_11886930_11887041_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 296}}, "n4659": {"so_11886930_11887041_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 307}}}, "11887501": {"Id": "11887501", "PostTypeId": "2", "Body": "<p>The simplest way to think about it is comparing it to template argument deduction.</p>\n<p>Given:</p>\n<pre><code>template&lt;typename T&gt;\nvoid deduce(T) { }\n</code></pre>\n<p>If you call:</p>\n<pre><code>deduce(px);\n</code></pre>\n<p>then the template argument <code>T</code> will be deduced as <code>int*</code> and if you call</p>\n<pre><code>deduce(rx);\n</code></pre>\n<p>then <code>T</code> will be deduced as <code>int</code>, not <code>int&amp;</code></p>\n<p>You get the same types deduced when using <code>auto</code>.</p>\n<blockquote>\n<p id=\"so_11886930_11887501_0\">One could draw an analogy from pointer types expecting that the deduced type of <code>arx</code> is <code>int&amp;</code></p>\n</blockquote>\n<p>You'd have to have a fairly confused model of the C++ language to make that analogy. Just because they are declared in syntactically similar ways, as <code>Type@</code> with a type and a modifier doesn't make them work the same way. A pointer is a value, an object, and it can be copied and have its value altered by assignment. A reference is not an object, it's a reference to some object.  A reference can't be copied (copying it copies the referent) or altered (assigning to it alters the referent).  A function that returns a pointer returns an object <em>by value</em> (the object in question being a pointer object), but a function that returns a reference (like your <code>GetBigClass()</code>) returns an object <em>by reference</em>. They're completely different semantics, trying to draw analogies between pointers and references is doomed to failure.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2012-08-09T18:34:51.313", "Score": "5", "CreationDate": "2012-08-09T16:09:23.977", "ParentId": "11886930", "CommentCount": "0", "OwnerUserId": "981959", "LastEditDate": "2012-08-09T18:34:51.313"}, "11887041": {"Id": "11887041", "PostTypeId": "2", "Body": "<p>Use <code>auto&amp;</code>:</p>\n<pre><code>auto&amp; ref_bigclass = GetBigClass();\n</code></pre>\n<p>References are supposed to be transparent: any operation on them happens on the object they refer to, there is no way to 'get' reference itself.</p>\n<p>UPD: This is covered in 7.1.6.4/6:</p>\n<blockquote>\n<p id=\"so_11886930_11887041_0\">Once the type of a declarator-id has been determined according to 8.3, the type of the declared variable using the declarator-id is determined from the type of its initializer using the rules for template argument deduction.</p>\n</blockquote>\n<p>And template argument deduction is defined in 14.8.2.1/3: </p>\n<blockquote>\n<p id=\"so_11886930_11887041_1\">If template parameter type P is a reference type, the type referred to by P is used for type deduction.</p>\n</blockquote>\n<p>P.S. Note that this is different for <code>decltype</code>: <code>decltype(rx)</code> will yield <code>int&amp;</code> type (7.1.6.2/4). </p>\n", "LastEditorUserId": "544621", "LastActivityDate": "2012-08-09T15:58:47.997", "Score": "9", "CreationDate": "2012-08-09T15:44:02.580", "ParentId": "11886930", "CommentCount": "3", "OwnerUserId": "544621", "LastEditDate": "2012-08-09T15:58:47.997"}});