post_cb({"bq_ids": {"n4140": {"so_39628799_39629142_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 6032}}, "n3337": {"so_39628799_39629142_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 5800}}, "n4659": {"so_39628799_39629142_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 7531}}}, "39628799": {"ViewCount": "192", "Body": "<p>Hoping to get some clarification/explaination on the following piece of code</p>\n<pre><code>#define NOOP(x) ((void)(x))\n\nvoid my_function(int x)\n{\n     NOOP(x);\n}\n</code></pre>\n<p>This macro prevents unused parameter warnings.</p>\n<p>I have two questions-</p>\n<ol>\n<li>So we're void casting whatever x is by using this macro. What's\nreally happening when we void cast something?</li>\n<li>Why the extra set of parenthesis around <code>(void)(x)</code></li>\n</ol>\n<p>Thanks</p>\n", "AcceptedAnswerId": "39628917", "Title": "Void cast macro explaination", "CreationDate": "2016-09-22T01:18:28.743", "Id": "39628799", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-09-22T12:42:11.477", "Score": "2", "OwnerUserId": "5380257", "Tags": "<c++>", "AnswerCount": "3"}, "39628954": {"Id": "39628954", "PostTypeId": "2", "Body": "<p>As you said , your code will not display a unused variable warning because you are using your variable 'x' , but you are just doing nothing to it , you are passing it to a function that do nothing important (NOOP(x) --do nothing important but , compiler see you are trying to use the x variable) so it do not tell you you are not using your variable </p>\n", "LastActivityDate": "2016-09-22T01:40:03.830", "CommentCount": "0", "CreationDate": "2016-09-22T01:40:03.830", "ParentId": "39628799", "Score": "1", "OwnerUserId": "4195727"}, "39628917": {"Id": "39628917", "PostTypeId": "2", "Body": "<p>As far as what happens, it's absolutely nothing, and that's the point. Just a reference to the variable, but do absolutely nothing with it. The compiler dutifully processes it, notes that the parameter was used, then throws everything away and does not generate any actual code.</p>\n<p>As far as parenthesis go:</p>\n<p>It is a good practice to use parenthesis for macros that can potentially be used in an expression, even when it is not needed.</p>\n<p>Consider, for example, a simple macro in hypothetical code that draws a window on the screen. The library that does it adds a border around the window that, say, is 6 pixels long. This macro computes the total width of the window. A naive implementation of this macro would read:</p>\n<pre><code>#define ACTUAL_WIDTH(w)  w+6\n</code></pre>\n<p>Now, let's say your code wants to compute the actual width of two windows. Both windows are 100 pixels wide:</p>\n<pre><code>int total_width=ACTUAL_WIDTH(100)*2;\n</code></pre>\n<p>What do you think happens? Recall that a macro substitution is basically just a straightforward text substitution, so this is what actually gets compiled:</p>\n<pre><code>int total_width=100+6*2;\n</code></pre>\n<p>Which is utterly wrong. You want to have an extra set of parenthesis in your macro, so that the correct code gets compiled:</p>\n<pre><code>int total_width=(100+6)*2;\n</code></pre>\n<p>And that's why you will often see an extra set of parenthesis in macros that can be used in expressions. Not only that, a macro like that will also have parenthesis around its argument, so it will probably be:</p>\n<pre><code>#define ACTUAL_WIDTH(w)  ((w)+6)\n</code></pre>\n<p>And that's why you see an extra set of parenthesis in macros. It's easier to acquire a habit of always sticking them into every macro you write and be safe; rather than waste time figuring out, every time, if they are really needed or not.</p>\n<p>Using good programming habits will avoid many common bugs.</p>\n", "LastEditorUserId": "3943312", "LastActivityDate": "2016-09-22T12:42:11.477", "Score": "2", "CreationDate": "2016-09-22T01:34:43.560", "ParentId": "39628799", "CommentCount": "0", "OwnerUserId": "3943312", "LastEditDate": "2016-09-22T12:42:11.477"}, "39629142": {"Id": "39629142", "PostTypeId": "2", "Body": "<p>From Section 5.2.9 paragraph 6 of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">C++14 standard working draft from November 2014</a>:</p>\n<blockquote>\n<p id=\"so_39628799_39629142_0\">Any expression can be explicitly converted to type cv void, in which case it becomes a discarded-value expression.</p>\n</blockquote>\n<p>As stated by others, the extra parentheses prohibits any undesired effects by effectively quarantining the expression from code that might be around it.  Although in this case, I believe it would be unlikely that any ill effects would be felt in practical applications by not including the outer parentheses, especially if you were just using this to avoid the unused variable warning in a function.  It is just not worth any risk though by leaving them out.</p>\n<p>To demonstrate this, I have come up with a very contrived example that leads to unintentional execution of code, because there are operators with higher precedence than C-style casting.</p>\n<pre><code>#include &lt;iostream&gt;\n\n#define NOOP(x) ((void)(x))\n#define MYNOOP(x) (void) (x)\n\nstruct A\n{\n  bool operator()(void) {\n    std::cout &lt;&lt; \"Called function unintentionally\" &lt;&lt; std::endl;\n    return true;\n  }\n};\n\nint main() {\n  A i;\n  MYNOOP(i)();\n  //NOOP(i)(); // error: called object type 'void' is not a function or function pointer\n  return 0;\n}\n</code></pre>\n", "LastActivityDate": "2016-09-22T02:05:49.217", "CommentCount": "0", "CreationDate": "2016-09-22T02:05:49.217", "ParentId": "39628799", "Score": "2", "OwnerUserId": "6776535"}});