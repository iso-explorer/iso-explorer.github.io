post_cb({"6241364": {"Id": "6241364", "PostTypeId": "2", "Body": "<p>you can try ostream(NULL,false), the first input is target output and I don't know what the second input exaclty mean but after tracing code it seems just because ostream has no place to write to, calling <code>operator &lt;&lt;</code> is just ignored by ostream. I mean in the first call state changes to bad and after that it's always ignoring input data because of stream state ,so you can use the following code :</p>\n<pre><code>void data(std::ostream &amp; stream = ostream(NULL,false)){\n    stream &lt;&lt; \"DATA\" ;\n}\n</code></pre>\n", "LastActivityDate": "2011-06-05T06:28:04.703", "CommentCount": "2", "CreationDate": "2011-06-05T06:28:04.703", "ParentId": "6240950", "Score": "-1", "OwnerUserId": "651687"}, "bq_ids": {"n4140": {"so_6240950_6240980_2": {"length": 6, "quality": 1.0, "section_id": 1993}, "so_6240950_6240980_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 2268}, "so_6240950_6240980_1": {"length": 5, "quality": 0.625, "section_id": 1993}, "so_6240950_6240980_4": {"length": 10, "quality": 1.0, "section_id": 2278}, "so_6240950_6240980_3": {"length": 23, "quality": 1.0, "section_id": 2308}}, "n3337": {"so_6240950_6240980_3": {"length": 23, "quality": 1.0, "section_id": 2296}, "so_6240950_6240980_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 2256}, "so_6240950_6240980_2": {"length": 6, "quality": 1.0, "section_id": 1981}, "so_6240950_6240980_4": {"length": 10, "quality": 1.0, "section_id": 2266}, "so_6240950_6240980_1": {"length": 5, "quality": 0.625, "section_id": 1981}}, "n4659": {"so_6240950_6240980_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 2263}, "so_6240950_6240980_3": {"length": 23, "quality": 1.0, "section_id": 2582}, "so_6240950_6240980_4": {"length": 10, "quality": 1.0, "section_id": 2551}, "so_6240950_6240980_2": {"length": 6, "quality": 1.0, "section_id": 2266}}}, "6240950": {"ViewCount": "6925", "Body": "<blockquote>\n<p id=\"so_6240950_6240950_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/760301/implementing-a-no-op-stdostream\">Implementing a no-op std::ostream</a> </br></p>\n</blockquote>\n<p>Is there any stream equivalent of NULL in c++? I want to write a function that takes in a stream if the user wants to have the internal outputted to somewhere, but if not, the output goes into some fake place</p>\n<pre><code>void data(std::stream &amp; stream = fake_stream){\n    stream &lt;&lt; \"DATA\" ;\n}\n</code></pre>\n<p>i want to be able to chose to do <code>data()</code> or <code>data(std::cout)</code></p>\n", "AcceptedAnswerId": "6240980", "Title": "Platform independent /dev/null in c++", "CreationDate": "2011-06-05T04:08:14.527", "Id": "6240950", "CommentCount": "8", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:46:04.997", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-05T17:10:50.300", "ClosedDate": "2011-06-05T08:05:24.937", "Score": "21", "OwnerUserId": "341683", "Tags": "<c++><stream><ostream><default-parameters>", "AnswerCount": "3"}, "6241204": {"Id": "6241204", "PostTypeId": "2", "Body": "<p>Linux file /dev/null is a black hole like you're looking for.  In Windows there's a device called NUL:.  I've never tried to open that file, but I've used it from the command line</p>\n", "LastActivityDate": "2011-06-05T05:35:08.490", "CommentCount": "5", "CreationDate": "2011-06-05T05:35:08.490", "ParentId": "6240950", "Score": "1", "OwnerUserId": "349143"}, "6240980": {"Id": "6240980", "PostTypeId": "2", "Body": "<p><strong>Edit</strong>: Taken from @Johannes Schaub - litb's mail <a href=\"http://groups.google.com/group/comp.lang.c++.moderated/msg/6125e4267ce31d7a\" rel=\"noreferrer\">here</a> with slight modifications:</p>\n<pre><code>template&lt;typename Ch, typename Traits = std::char_traits&lt;Ch&gt; &gt;\nstruct basic_nullbuf : std::basic_streambuf&lt;Ch, Traits&gt; {\n     typedef std::basic_streambuf&lt;Ch, Traits&gt; base_type;\n     typedef typename base_type::int_type int_type;\n     typedef typename base_type::traits_type traits_type;\n\n     virtual int_type overflow(int_type c) {\n         return traits_type::not_eof(c);\n     }\n};\n\n// convenient typedefs\ntypedef basic_nullbuf&lt;char&gt; nullbuf;\ntypedef basic_nullbuf&lt;wchar_t&gt; wnullbuf;\n\n// buffers and streams\n// in some .h\nextern std::ostream cnull;\nextern std::wostream wcnull;\n\n// in a concrete .cpp\nnullbuf null_obj;\nwnullbuf wnull_obj;\nstd::ostream cnull(&amp;null_obj);\nstd::wostream wcnull(&amp;wnull_obj);\n</code></pre>\n<p>Use those:</p>\n<pre><code>void data(std::ostream&amp; stream = cnull){\n  // whatever...\n}\n</code></pre>\n<hr>\n<p>Now, this looks cool and all, but the following is way shorter and works, because if a null pointer is provided to the constructor of <code>ostream</code>, it automatically sets the badbit and silently ignores any writes:</p>\n<pre><code>// in .h\nextern std::ostream cnull;\nextern std::wostream wcnull;\n\n// in .cpp\nstd::ostream cnull(0);\nstd::wostream wcnull(0);\n</code></pre>\n<p>The standard guarantees this works, beginning from <code>27.6.2.2 [lib.ostream.cons] p1</code> which describes the constructor of <code>ostream</code> that takes a pointer to a <code>streambuf</code>:</p>\n<blockquote>\n<p id=\"so_6240950_6240980_0\">Effects: Constructs an object of class <code>basic_ostream</code>, assigning initial values to the base class by calling <code>basic_ios&lt;charT,traits&gt;::init(sb)</code>.</p>\n</blockquote>\n<p>The relevant function from <code>basic_ios</code>, <code>27.4.4.1 [lib.basic.ios.cons] p3</code>:</p>\n<blockquote>\n<p id=\"so_6240950_6240980_1\"><code>void init(basic_streambuf&lt;charT,traits&gt;* sb);</code><br>\n  Postconditions: The postconditions of this function are indicated in Table 89:</br></p>\n</blockquote>\n<p>The important row from Table 89:</p>\n<blockquote>\n<p id=\"so_6240950_6240980_2\">rdstate() -- goodbit if sb is not a null pointer, otherwise badbit.</p>\n</blockquote>\n<p>What happens if the <code>badbit</code> is set is described under <code>27.6.2.6 [lib.ostream.unformatted]</code>:</p>\n<blockquote>\n<p id=\"so_6240950_6240980_3\">Each unformatted output function begins execution by constructing an object of class <code>sentry</code>. If this object returns true, while converting to a value of type bool, the function endeavors to generate the requested output.</p>\n</blockquote>\n<p>This implies that, in case the <code>sentry</code> is false, it does not. Here is how the <code>sentry</code> converts to <code>bool</code>, taken from <code>27.6.2.3 [lib.ostream::sentry] p3 &amp; p5</code>:</p>\n<blockquote>\n<p id=\"so_6240950_6240980_4\">3) If, after any preparation is completed, <code>os.good()</code> is <code>true</code>, <code>ok_ == true</code> otherwise, <code>ok_ == false</code>.</p>\n<p id=\"so_6240950_6240980_5\">5) <code>operator bool();</code><br>\n  Effects: Returns ok_.</br></p>\n</blockquote>\n<p>(<code>ok_</code> is a member of <code>ostream::sentry</code> of type <code>bool</code>.)</p>\n<hr>\n<p>Note that these quotes are still present in C++11, just in different places. In order of appearance in this answer:</p>\n<ul>\n<li><code>27.6.2.2 [lib.ostream.cons] p1</code> =&gt; <code>27.7.3.2 [ostream.cons] p1</code></li>\n<li><code>27.4.4.1 [lib.basic.ios.cons] p3</code> =&gt; <code>27.5.5.2 [basic.ios.cons]</code></li>\n<li>Table 89 =&gt; Table 128</li>\n<li><code>27.6.2.6 [lib.ostream.unformatted]</code> =&gt; <code>27.7.3.7 [ostream.unformatted] p1</code></li>\n<li><code>27.6.2.3 [lib.ostream::sentry] p3 &amp; p5</code> =&gt; <code>27.7.3.4 [ostream::sentry] p4 &amp; p5</code></li>\n</ul>\n</hr></hr>", "LastEditorUserId": "500104", "LastActivityDate": "2014-09-05T17:10:50.300", "Score": "33", "CreationDate": "2011-06-05T04:20:31.597", "ParentId": "6240950", "CommentCount": "1", "OwnerUserId": "500104", "LastEditDate": "2014-09-05T17:10:50.300"}});