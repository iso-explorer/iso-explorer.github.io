post_cb({"bq_ids": {"n4140": {"so_29381171_29381331_2": {"length": 36, "quality": 0.9, "section_id": 592}, "so_29381171_29381331_0": {"length": 43, "quality": 0.9772727272727273, "section_id": 6169}, "so_29381171_29381331_1": {"length": 55, "quality": 1.0, "section_id": 6169}, "so_29381171_29381331_3": {"length": 17, "quality": 1.0, "section_id": 388}}, "n3337": {"so_29381171_29381331_2": {"length": 36, "quality": 0.9, "section_id": 582}, "so_29381171_29381331_0": {"length": 43, "quality": 0.9772727272727273, "section_id": 5930}, "so_29381171_29381331_1": {"length": 55, "quality": 1.0, "section_id": 5930}, "so_29381171_29381331_3": {"length": 17, "quality": 1.0, "section_id": 379}}, "n4659": {"so_29381171_29381331_2": {"length": 36, "quality": 0.9, "section_id": 615}, "so_29381171_29381331_0": {"length": 35, "quality": 0.7954545454545454, "section_id": 7667}, "so_29381171_29381331_1": {"length": 38, "quality": 0.6909090909090909, "section_id": 7667}, "so_29381171_29381331_3": {"length": 17, "quality": 1.0, "section_id": 405}}}, "29381171": {"ViewCount": "1539", "Body": "<p>The following piece of code behaves differently under g++ 4.9.2 and clang++ 3.7.0.  Which one is correct?  What part in standard is related to this?  Thanks.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Base {\n  Base() = default;\n  Base(const Base&amp;) = default;\n  Base(Base&amp;&amp;) = delete;\n};\n\nstruct Derived : Base {\n};\n\nint main() {\n  const Base&amp; b = true ? Derived() : Base();\n}\n</code></pre>\n<p>g++ accepts it and clang++ gives an error <code>incompatible operand types ('Derived' and 'Base')</code>.  See below for details.</p>\n<pre><code>[hidden]$ g++ -v\nUsing built-in specs.\nCOLLECT_GCC=/usr/bin/g++\nCOLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.9.2/lto-wrapper\nTarget: x86_64-redhat-linux\nConfigured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --enable-multilib --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.9.2-20150212/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.9.2-20150212/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux\nThread model: posix\ngcc version 4.9.2 20150212 (Red Hat 4.9.2-6) (GCC) \n[hidden]$ g++ -std=c++11 b.cpp \n[hidden]$ clang++ -v\nclang version 3.7.0 (http://llvm.org/git/clang.git 6bbdbba8ec8a7730c68fee94363547dc2dc65b10)\nTarget: x86_64-unknown-linux-gnu\nThread model: posix\nFound candidate GCC installation: /usr/lib/gcc/x86_64-redhat-linux/3.4.6\nFound candidate GCC installation: /usr/lib/gcc/x86_64-redhat-linux/4.9.2\nSelected GCC installation: /usr/lib/gcc/x86_64-redhat-linux/4.9.2\nCandidate multilib: .;@m64\nCandidate multilib: 32;@m32\nSelected multilib: .;@m64\n[hidden]$ clang++ -std=c++11 b.cpp \nb.cpp:14:24: error: incompatible operand types ('Derived' and 'Base')\n  const Base&amp; b = true ? Derived() : Base();\n                       ^ ~~~~~~~~~   ~~~~~~\n1 error generated.\n</code></pre>\n", "AcceptedAnswerId": "29381331", "Title": "ternary operator of different types", "CreationDate": "2015-04-01T01:01:59.793", "Id": "29381171", "CommentCount": "18", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-04-01T13:16:12.833", "Score": "14", "OwnerUserId": "875044", "Tags": "<c++><c++11><c++14>", "AnswerCount": "1"}, "29381331": {"Id": "29381331", "PostTypeId": "2", "Body": "<p>I don't have N3936 handy, but N3797 \u00a75.12 [expr.cond]/3 contains this (emphasis mine):</p>\n<blockquote>\n<p id=\"so_29381171_29381331_0\">Otherwise, if the second and third operand have different types and\n  either has (possibly cv-qualified) class type, or if both are glvalues\n  of the same value category and the same type except for\n  cv-qualification, an attempt is made to convert each of those operands\n  to the type of the other. The process for determining whether an\n  operand expression E1 of type T1 can be converted to match an operand\n  expression E2 of type T2 is defined as follows:  </p>\n<ul>\n<li>If E2 is an lvalue: [removed]</li>\n<li>If E2 is an xvalue: [removed]</li>\n<li>If E2 is a prvalue or if neither of the conversions\n  above can be done and at least one of the operands has (possibly\n  cv-qualified) class type: \n  \n  <ul>\n<li>if <strong>E1 and E2 have class type</strong>, and the\n  underlying class types are the same or <strong>one is a base class of the\n  other</strong>:<br>\n  E1 can be converted to match E2 if the class of T2 is the same\n  type as, <strong>or a base class of</strong>, the class of T1, and the cv-qualification\n  of T2 is the same cv-qualification as, or a greater cv-qualification\n  than, the cv-qualification of T1. If the conversion is applied, E1 is\n  changed to a prvalue of type T2 by <strong>copy-initializing</strong> a temporary of\n  type T2 from E1 and using that temporary as the converted operand.   </br></li>\n</ul></li>\n</ul>\n<p id=\"so_29381171_29381331_1\">Using this process, it is determined whether the <strong>second operand can be \n  converted to match the third operand</strong>, and whether the third operand\n  can be converted to match the second operand. If both can be\n  converted, or one can be converted but the conversion is ambiguous,\n  the program is ill-formed. If neither can be converted, the operands\n  are left unchanged and further checking is performed as described\n  below. <strong>If exactly one conversion is possible, that conversion is\n  applied to the chosen operand and the converted operand is used in\n  place of the original operand for the remainder of this section.</strong></p>\n</blockquote>\n<p>Now to copy-initialize the final <code>Base</code> operand from <code>Derived()</code>, we can look at \u00a713.3.1.3  [over.match.ctor]:</p>\n<blockquote>\n<p id=\"so_29381171_29381331_2\">When objects of class type are direct-initialized (8.5), or\n  <strong>copy-initialized from an expression of the same or a derived class\n  type</strong> (8.5), overload resolution <strong>selects the constructor</strong>. For\n  direct-initialization, the candidate functions are all the\n  constructors of the class of the object being initialized. <strong>For\n  copy-initialization, the candidate functions are all the converting\n  constructors (12.3.1) of that class</strong>. The argument list is the\n  expression-list or assignment-expression of the initializer.</p>\n</blockquote>\n<p>Converting constructors are defined as follows in \u00a712.3.1 [class.conv.ctor]:</p>\n<blockquote>\n<p id=\"so_29381171_29381331_3\">A constructor declared without the function-specifier explicit\n  specifies a conversion from the types of its parameters to the type of\n  its class. Such a constructor is called a converting constructor.</p>\n</blockquote>\n<p>Now, if you'll believe me (for the sake of not having to quote more than I have of 13.3) that a prvalue <code>Derived()</code> will cause overload resolution to choose the move constructor (taking <code>Base&amp;&amp;</code>), <a href=\"https://stackoverflow.com/questions/14085620/why-do-c11-deleted-functions-participate-in-overload-resolution\">despite being deleted</a>, this causes the error from Clang.</p>\n<p>In conclusion, Clang is correct in issuing an error. As using a deleted function requires a diagnostic, this is a bug in GCC.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-04-01T13:16:12.833", "Score": "6", "CreationDate": "2015-04-01T01:21:26.583", "ParentId": "29381171", "CommentCount": "6", "OwnerUserId": "962089", "LastEditDate": "2017-05-23T11:58:28.053"}});