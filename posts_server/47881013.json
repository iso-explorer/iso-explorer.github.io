post_cb({"bq_ids": {"n4140": {"so_47881013_47897732_1": {"length": 35, "quality": 1.0, "section_id": 481}, "so_47881013_47897732_0": {"length": 14, "quality": 0.6363636363636364, "section_id": 481}, "so_47881013_47881213_4": {"length": 10, "quality": 0.7692307692307693, "section_id": 572}, "so_47881013_47897732_2": {"length": 16, "quality": 1.0, "section_id": 564}, "so_47881013_47881213_3": {"length": 58, "quality": 0.9354838709677419, "section_id": 481}, "so_47881013_47881213_1": {"length": 18, "quality": 1.0, "section_id": 481}}, "n3337": {"so_47881013_47897732_1": {"length": 32, "quality": 0.9142857142857143, "section_id": 472}, "so_47881013_47897732_2": {"length": 16, "quality": 1.0, "section_id": 555}, "so_47881013_47881213_3": {"length": 55, "quality": 0.8870967741935484, "section_id": 472}}, "n4659": {"so_47881013_47897732_1": {"length": 35, "quality": 1.0, "section_id": 504}, "so_47881013_47897732_0": {"length": 22, "quality": 1.0, "section_id": 504}, "so_47881013_47881213_0": {"length": 9, "quality": 1.0, "section_id": 504}, "so_47881013_47897732_2": {"length": 16, "quality": 1.0, "section_id": 587}, "so_47881013_47881213_3": {"length": 58, "quality": 0.9354838709677419, "section_id": 504}, "so_47881013_47881213_1": {"length": 18, "quality": 1.0, "section_id": 504}, "so_47881013_47881213_4": {"length": 10, "quality": 0.7692307692307693, "section_id": 595}}}, "47881045": {"Id": "47881045", "PostTypeId": "2", "Body": "<p><code>result</code> is not an lvalue after returning from <code>foo()</code>, but a prvalue, so it is allowed to call the move constructor.</p>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/language/value_category#prvalue\" rel=\"nofollow noreferrer\">CppReference</a>:</p>\n<blockquote>\n<p id=\"so_47881013_47881045_0\">The following expressions are <em>prvalue expressions</em>:</p>\n<ul>\n<li><strong>a function call</strong> or an overloaded operator expression, <strong>whose return type is non-reference</strong>, such as <code>str.substr(1, 2)</code>, <code>str1 + str2</code>, or <code>it++</code></li>\n</ul>\n</blockquote>\n<p>It is possible that Clang detected that the return value is unused and threw it away directly, while GCC didn't.</p>\n", "LastEditorUserId": "5958455", "LastActivityDate": "2017-12-19T06:25:15.457", "Score": "0", "CreationDate": "2017-12-19T06:17:37.187", "ParentId": "47881013", "CommentCount": "6", "OwnerUserId": "5958455", "LastEditDate": "2017-12-19T06:25:15.457"}, "47897732": {"Id": "47897732", "PostTypeId": "2", "Body": "<p>From <a href=\"http://eel.is/c++draft/class.copy.elision#3\" rel=\"noreferrer\">[class.copy.elision]</a>:</p>\n<blockquote>\n<p id=\"so_47881013_47897732_0\">In the following copy-initialization contexts, a move operation might be used instead of a copy operation: <strong>If the expression in a return statement is a (possibly parenthesized) <em>id-expression</em> that names an object with automatic storage duration declared in the body</strong> [...] </p>\n<p id=\"so_47881013_47897732_1\">overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. <strong>If the first overload resolution fails</strong> or was not performed, or <strong>if the type of the first parameter of the selected constructor is not an rvalue reference to the object's type</strong> (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue.</p>\n</blockquote>\n<p>In <code>return result;</code> we are precisely in the case mentioned in that paragraph - <code>result</code> is an <em>id-expression</em> naming an object with automatic storage duration declared in the body. So, we first perform overload resolution <em>as if</em> it were an rvalue. </p>\n<p>Overload resolution will find two candidates: <code>X(X const&amp;)</code> and <code>X(X&amp;&amp;)</code>. The latter <a href=\"http://eel.is/c++draft/over#ics.rank-3.2.3\" rel=\"noreferrer\">is preferred</a>.</p>\n<p>Now, what does it mean for overload resolution to fail? From <a href=\"http://eel.is/c++draft/over.match#3\" rel=\"noreferrer\">[over.match]/3</a>:</p>\n<blockquote>\n<p id=\"so_47881013_47897732_2\">If a best viable function exists and is unique, overload resolution succeeds and produces it as the result. Otherwise overload resolution fails and the invocation is ill-formed.</p>\n</blockquote>\n<p><code>X(X&amp;&amp;)</code> is a unique, best viable function, so overload resolution <em>succeeds</em>. This copy elision context has one extra criteria for us, but we satisfy it as well because this candidate has as the type of its first parameter as (possibly cv-qualified) rvalue reference to <code>X</code>. Both boxes are checked, so we stop there. We do not go on to perform overload resolution again as an lvalue, we have already selected our candidate: the move constructor. </p>\n<p>Once we selected it, the program fails because we're trying to call a deleted function. But only <em>at that point</em>, and not any earlier. Candidates are not excluded from overload sets for being deleted, otherwise deleting overloads wouldn't be nearly as useful.</p>\n<p>This is clang bug <a href=\"https://bugs.llvm.org/show_bug.cgi?id=31025\" rel=\"noreferrer\">31025</a>.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-12-20T13:09:28.440", "Score": "8", "CreationDate": "2017-12-20T01:53:18.783", "ParentId": "47881013", "CommentCount": "4", "OwnerUserId": "2069064", "LastEditDate": "2017-12-20T13:09:28.440"}, "47881213": {"Id": "47881213", "PostTypeId": "2", "Body": "<p>I'm gonna quote C++17 (n4659), since the wording there is the most clear, but previous revisions say the same, just less clearly to me. Here is <a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.copy.elision#3\" rel=\"nofollow noreferrer\">[class.copy.elision]/3</a>, emphasis mine:</p>\n<blockquote>\n<p id=\"so_47881013_47881213_0\"><strong>In the following copy-initialization contexts, a move operation might\n  be used instead of a copy operation</strong>:</p>\n<ul>\n<li><p id=\"so_47881013_47881213_1\">If the expression in a return statement is a (possibly parenthesized) id-expression that names an object with automatic\n  storage duration declared in the body or parameter-declaration-clause\n  of the innermost enclosing function or lambda-expression, or</p></li>\n<li><p id=\"so_47881013_47881213_2\">[...]</p></li>\n</ul>\n<p id=\"so_47881013_47881213_3\">overload resolution to select the constructor for the copy is first\n  performed as if the object were designated by an rvalue. <strong>If the\n  first overload resolution fails or was not performed</strong>, or if the type\n  of the first parameter of the selected constructor is not an rvalue\n  reference to the object's type (possibly cv-qualified), <strong>overload\n  resolution is performed again, considering the object as an lvalue.</strong>\n  [\u2009Note: This two-stage overload resolution must be performed\n  regardless of whether copy elision will occur. It determines the\n  constructor to be called if elision is not performed, and the selected\n  constructor must be accessible even if the call is elided. \u2009\u2014\u2009end\n  note\u2009]</p>\n</blockquote>\n<p>So this is why in fact both Clang and GCC will try to call the move c'tor first. The difference in behavior is because Clang adheres to the text in bold differently. Overload resolution happened, found a move c'tor, but calling it is ill-formed. So Clang performs it again and finds the copy c'tor.</p>\n<p>GCC just stops in its tracks because a deleted function was picked in overload resolution.</p>\n<p>I do believe Clang is correct here, in spirit if anything else. Trying to move the returned value and copying as a fallback is the intended behavior of this <em>optimization</em>. I feel GCC should not stop because it found a deleted move c'tor. Neither compiler would if it was a defaulted move c'tor that's defined deleted. The standard is aware of a potential problem in <em>that</em> case (<a href=\"https://timsong-cpp.github.io/cppwp/n4659/over.match.funcs#8\" rel=\"nofollow noreferrer\">[over.match.funcs]/8</a>):</p>\n<blockquote>\n<p id=\"so_47881013_47881213_4\">A defaulted move special function ([class.copy]) that is defined as\n  deleted is excluded from the set of candidate functions in all\n  contexts.</p>\n</blockquote>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-12-20T05:42:03.637", "Score": "11", "CreationDate": "2017-12-19T06:32:05.450", "ParentId": "47881013", "CommentCount": "7", "OwnerUserId": "817643", "LastEditDate": "2017-12-20T05:42:03.637"}, "47881013": {"ViewCount": "401", "Body": "<p>Consider the following example:</p>\n<pre><code>class X {\npublic:\n    X() = default;\n    X(const X&amp;) = default;\n    X(X&amp;&amp;) = delete;\n};\n\nX foo() {\n    X result;\n    return result;\n}\n\nint main() {\n    foo();\n}\n</code></pre>\n<p>Clang and GCC disagree on whether this program is valid. GCC tries to call the move constructor when initializing the temporary during the call to <code>foo()</code>, which has been deleted leading to a compilation error. Clang handles this just fine, even with <code>-fno-elide-constructors</code>.</p>\n<p>Can anyone explain why GCC is allowed to call the move constructor in this case? Isn't <code>result</code> an lvalue?</p>\n", "AcceptedAnswerId": "47897732", "Title": "Constructor called on return statement", "CreationDate": "2017-12-19T06:14:41.630", "LastActivityDate": "2017-12-20T13:09:28.440", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-12-20T04:05:59.707", "LastEditorUserId": "4089452", "Id": "47881013", "Score": "13", "OwnerUserId": "4089452", "Tags": "<c++><language-lawyer><c++17>", "AnswerCount": "3"}});