post_cb({"26244887": {"CommentCount": "7", "ViewCount": "148", "CreationDate": "2014-10-07T20:39:59.293", "LastActivityDate": "2014-10-07T23:10:22.237", "Title": "Copy Constructor/Assignment Operator", "AcceptedAnswerId": "26245704", "PostTypeId": "1", "Id": "26244887", "Score": "0", "Body": "<p>I am learning about automatic conversions in Accelerated C++, and the author states that the copy constructor is always called when you have a statement of the form</p>\n<pre><code>myClass myVar = 24;\n</code></pre>\n<p>Additionally he states that when you have statements of the form</p>\n<pre><code>myClass myVar;\nmyVar = 24;\n</code></pre>\n<p>what actually happens is that the myClass constructor that takes an integer as an argument is called to create an unnamed temporary variable of the type myClass, and then the assignment operator is called. The book was written in the year 2000, I believe. My question is whether or not these claims are still true. I learned about the move constructor and move assignment operations elsewhere, and I was wondering if those were called instead of the assignment operator/copy constructor.</p>\n<p>Thank you for your time. I really appreciate it. </p>\n", "Tags": "<c++><copy-constructor><accelerated-c++>", "OwnerUserId": "3998955", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26244887_26245704_5": {"section_id": 3294, "quality": 0.68, "length": 17}, "so_26244887_26245704_10": {"section_id": 383, "quality": 0.8695652173913043, "length": 20}, "so_26244887_26245704_9": {"section_id": 383, "quality": 0.8695652173913043, "length": 20}, "so_26244887_26245704_3": {"section_id": 3294, "quality": 0.68, "length": 17}}, "n3337": {"so_26244887_26245704_5": {"section_id": 3164, "quality": 0.68, "length": 17}, "so_26244887_26245704_10": {"section_id": 374, "quality": 0.8695652173913043, "length": 20}, "so_26244887_26245704_9": {"section_id": 374, "quality": 0.8695652173913043, "length": 20}, "so_26244887_26245704_3": {"section_id": 3164, "quality": 0.68, "length": 17}}, "n4659": {"so_26244887_26245704_5": {"section_id": 4056, "quality": 0.68, "length": 17}, "so_26244887_26245704_10": {"section_id": 400, "quality": 0.8695652173913043, "length": 20}, "so_26244887_26245704_9": {"section_id": 400, "quality": 0.8695652173913043, "length": 20}, "so_26244887_26245704_3": {"section_id": 4056, "quality": 0.68, "length": 17}}}, "26245704": {"ParentId": "26244887", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_26244887_26245704_0\">...the author states that the copy constructor is always called when you have a statement of the form</p>\n<pre><code>myClass myVar = 24;\n</code></pre>\n</blockquote>\n<p><strong>Wrong</strong>.</p>\n<p>Your book was written before C++11 became the new standard, so it doesn't mention move-semantics and the possibility that the <em>move-constructor</em> may be called. Moreover, it doesn't talk about <em>copy-elision</em>. Yes, it is true that a copy-constructor called may be invoked, but because of an optimization called copy-elison the compiler is allowed to remove a call from the copy/move-constructor. This is allowed even though it may affect the behavior of the program but note that this isn't <em>guaranteed</em> to happen on every compiler.</p>\n<p>If you write a <a href=\"http://rextester.com/FNJLQ46032\" rel=\"nofollow\">program</a> to test this behavior you find that no copy/move constructor is called. Passing the command line argument <a href=\"https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html#C_002b_002b-Dialect-Options\" rel=\"nofollow\"><code>-fno-elide-constructors</code></a> <a href=\"http://rextester.com/MZI77673\" rel=\"nofollow\">disables</a> this elision and permits a call from the <em>move-constructor</em>.</p>\n<p>The form of initialization your are using is called <em>copy-initialization</em>:</p>\n<blockquote>\n<p id=\"so_26244887_26245704_1\"><strong>\u00a7 8.5/15 Initializers</strong></p>\n<blockquote>\n<p id=\"so_26244887_26245704_4\">The initialization that occurs in the form</p>\n<pre><code>T x = a;\n</code></pre>\n<p id=\"so_26244887_26245704_5\">as well as in\n    argument passing, function return, throwing an exception (15.1),\n    handling an exception (15.3), and aggregate member initialization\n    (8.5.1) is called <em>copy-initialization</em>. [ Note: <em>Copy-initialization may\n    invoke a move (12.8)</em>. \u2014 end note ]</p>\n</blockquote>\n</blockquote>\n<p>Assuming copy-elision doesn't take place, the compiler will construct a temporary instance of the class in order to convert to the designated type. It will then copy or move-construct <code>myVar</code> from this temporary using the copy-constructor or move-constructor. A move constructor takes precedence over a copy-constructor for rvalues, and will only be called if your class has an accessible move constructor; otherwise the copy-constructor is called.</p>\n<p>If copy-elision doesn't happen, the compiler will initialize <code>myVar</code> as if it had been copy-constructed from the right hand side. This is in accordance with the <a href=\"http://en.wikipedia.org/wiki/As-if_rule\" rel=\"nofollow\">as-if rule</a> which states that the compiler can perform optimizations given that it doesn't affect the <em>observable behavior</em> of the program.</p>\n<blockquote>\n<p id=\"so_26244887_26245704_6\">Additionally he states that when you have statements of the form</p>\n<pre><code>myClass myVar;\nmyVar = 24;\n</code></pre>\n<p id=\"so_26244887_26245704_7\">what actually happens is that the <code>myClass</code>\n  constructor that takes an integer as an argument is called to create\n  an unnamed temporary variable of the type <code>myClass</code>, and then the\n  assignment operator is called. [...] My question is whether or not these claims are still true.</p>\n</blockquote>\n<p>Yes, constructors do take part in implicit type conversions. From the latest draft, <a href=\"http://isocpp.org/files/papers/N3797.pdf\" rel=\"nofollow\">N3797</a>:</p>\n<blockquote>\n<p id=\"so_26244887_26245704_8\"><strong>\u00a7 12.3 Conversions</strong></p>\n<blockquote>\n<p id=\"so_26244887_26245704_10\">Type conversions of class objects can be specified by <strong>constructors</strong> and\n    by conversion functions. These conversions are called <em>user-defined\n    conversions</em> and are used for implicit type conversions (Clause 4), for\n    initialization (8.5), and for explicit type conversions (5.4, 5.2.9)</p>\n</blockquote>\n</blockquote>\n<p>The explanation your author gave for that part was right except for the fact that the <em>move-assignment operator</em> will be called if it is accessible.</p>\n", "OwnerUserId": "701092", "LastEditorUserId": "701092", "LastEditDate": "2014-10-07T23:10:22.237", "Id": "26245704", "Score": "2", "CreationDate": "2014-10-07T21:33:25.203", "LastActivityDate": "2014-10-07T23:10:22.237"}});