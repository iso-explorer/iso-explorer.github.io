post_cb({"26710071": {"ParentId": "26709862", "LastEditDate": "2014-11-25T19:08:40.790", "CommentCount": "1", "CreationDate": "2014-11-03T08:04:50.943", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "PostTypeId": "2", "Id": "26710071", "Score": "10", "Body": "<p>Yes, <em>this is correct behaviour</em>.</p>\n<h2>Case 1 - type deduction</h2>\n<pre><code>func&lt;int&gt;(d);\n</code></pre>\n<p>This uses <a href=\"http://en.cppreference.com/w/cpp/language/template_argument_deduction\" rel=\"nofollow\">template type deduction</a> to determine the type for <code>bleh</code>.</p>\n<blockquote>\n<p id=\"so_26709862_26710071_0\">In order to instantiate a function template, every template argument must be known, but not every template argument has to be specified. <strong>When possible, the compiler will deduce the missing template arguments from the function arguments</strong>. This occurs when a function call is attempted and when an address of a function template is taken.</p>\n</blockquote>\n<p>The compiler sees the type for <code>d</code> as being a <code>double</code> and thus deduces the actual type for <code>bleh</code> must also be a <code>double</code>.</p>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/language/template_argument_deduction\" rel=\"nofollow\">cppreference</a>, also covered in \u00a7 14.8.2 of the C++ specification;</p>\n<blockquote>\n<p id=\"so_26709862_26710071_1\">Template argument deduction attempts to determine template arguments ..., <strong>which can be substituted into each parameter <code>P</code> to produce the type deduced <code>A</code></strong>, which is the same as the type of the argument <code>A</code>, ... .</p>\n<p id=\"so_26709862_26710071_2\">If there are multiple parameters, each <code>P</code>/<code>A</code> pair is deduced separately and the deduced template arguments are then combined. If deduction fails or is ambiguous for any <code>P</code>/<code>A</code> pair or if different pairs yield different deduced template arguments, or if any template argument remains neither deduced nor explicitly specified, compilation fails.</p>\n</blockquote>\n<h2>Case 2</h2>\n<pre><code>func&lt;int,double&gt;(d);\n</code></pre>\n<p>The type for <code>bleh</code> is explicitly set to <code>double</code>, hence the compiler will make it such. The argument <code>d</code> is provided and since it is also a <code>double</code>, the compiler happily continues. If an argument (i.e. in place of <code>d</code>) was provided with a type that was not a <code>double</code>, or could not implicitly be converted to a <code>double</code> (e.g. via promotions, non-explicit constructors or user provided conversions), this would result in an error.</p>\n", "LastActivityDate": "2014-11-25T19:08:40.790"}, "26709862": {"CommentCount": "3", "ViewCount": "125", "PostTypeId": "1", "LastEditorUserId": "3747990", "CreationDate": "2014-11-03T07:46:40.797", "LastActivityDate": "2014-11-25T19:08:40.790", "Title": "Is this correct behavior of template?", "AcceptedAnswerId": "26710071", "LastEditDate": "2014-11-03T08:35:14.710", "Id": "26709862", "Score": "6", "Body": "<pre><code>template&lt;class blah, class bleh&gt;\nblah func(bleh p)\n{\n    // Do something\n}\n\nint main()\n{\n    double d=1.111;\n    int i = func&lt;int&gt;(d); // #1\n    int j = func&lt;int,double&gt;(d); // #2\n    // ....\n}\n</code></pre>\n<p>In this example both the instances of <code>func</code>, #1 and #2 are compiling, but I'm unsure of what is correct, and why.</p>\n<p>Can some one explain why #1 is correct, and maybe give some background?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "2689696", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26709862_26710071_2": {"section_id": 333, "quality": 0.696969696969697, "length": 23}}, "n3337": {"so_26709862_26710071_2": {"section_id": 323, "quality": 0.696969696969697, "length": 23}}, "n4659": {"so_26709862_26710071_2": {"section_id": 342, "quality": 0.696969696969697, "length": 23}}}});