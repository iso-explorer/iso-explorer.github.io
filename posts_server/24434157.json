post_cb({"24630425": {"ParentId": "24434157", "LastEditDate": "2015-07-19T19:43:18.653", "CommentCount": "14", "CreationDate": "2014-07-08T11:17:46.177", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "PostTypeId": "2", "Id": "24630425", "Score": "4", "Body": "<h2>Original question</h2>\n<p>In answer to the original question; is this a bug, are there workarounds?</p>\n<p>Yes, it looks like you have found a bug in VS2008, I've tested it with VS2008 and VS2013.2 with the same linker error. I would encourage you to file a bug report with <a href=\"https://connect.microsoft.com/VisualStudio\" rel=\"nofollow\" title=\"Microsoft Connect\">Microsoft</a>. Are there workarounds, I believe there may be.</p>\n<p>As you noted, it looks like the compiler \"looses\" the implicit instantiation of the template <code>foo&lt;int&gt;</code> somewhere between the decay to <code>void (*Function)(T,void*)</code> and when it is needed at link time. Having played with the code a little, I think it may involve the <code>apply(M)</code> template and Microsoft's template parsing techniques; since, if <code>apply</code> just takes an <code>int</code> as its argument <code>apply(int)</code> (i.e. no template) it seems happy to compile and link it.</p>\n<p>To workaround this, the code can be changed as follows (adding the default constructor and changing the <code>apply</code> call to be made from an instance of <code>kernel</code>). I know this may look ugly; but it works around the issue and may help you work around the issue in your project.</p>\n<pre><code>#include &lt;iostream&gt;\n\n// Simple function\ntemplate&lt;class T&gt;\nvoid foo(T a,void* = 0) {\n  std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n\n// A distpatching class\ntemplate&lt;class T,\n         void(*Function)(T,void*)&gt;\nclass kernel {\n  void (*dummy)(T,void*);\npublic:\n  kernel() : dummy(Function) {\n    // \"Force\" an implicit instantiation...\n    // dummy can be either a member variable or declared in\n    // in the constructor here. It exists only to \"force\"\n    // the implicit instantiation.\n    // Alternative...\n    //void* dummy = (void*)Function;\n    //(void)dummy; // silence \"unused\" warnings\n  }\n\n  // Function dispatcher\n  template&lt;class M&gt;\n  inline static void apply(M t) {\n    Function(t,0);\n  }\n};\n\nint main()\n{\n  kernel&lt;int,foo&gt;().apply(5);\n  // The kernel temporary instantiation is only needed once for the\n  // following line to link as well.\n  //kernel&lt;int,foo&gt;::apply(5);\n}\n</code></pre>\n<p>The code compiles and links with VS2008, VS2013 and gcc.</p>\n<hr>\n<h2>How does the code work with modern compilers?</h2>\n<p>With reference to the comments posted on the original question; why or how does this work with a modern compiler? It centres around two C++ facilities.</p>\n<ol>\n<li>Function pointer decay\n\n<ul>\n<li>With any additional rules if applicable (e.g templates)</li>\n</ul></li>\n<li>Implicit function template instantiation</li>\n</ol>\n<p>When supplying <code>foo</code> as an argument for <code>void(*Function)(T,void*)</code>, a decay takes place and a pointer is used, as if <code>&amp;foo</code> had been used.</p>\n<blockquote>\n<p id=\"so_24434157_24630425_0\"><strong>Function-to-pointer conversion 4.3</strong></p>\n<p id=\"so_24434157_24630425_1\">1 An lvalue of function type T can be converted to a prvalue of type \u201cpointer to T.\u201d The result is a pointer to the function</p>\n</blockquote>\n<p>Function-to-pointer conversions reference section 13.4 for additional rules when there are possible overloaded functions. Note the details on the usage of <code>&amp;</code> and the case where the function is a template (emphasis mine).</p>\n<blockquote>\n<p id=\"so_24434157_24630425_2\"><strong>Address of overloaded function 13.4</strong></p>\n<p id=\"so_24434157_24630425_3\">1 A function template name is considered to name a set of overloaded functions... The overloaded function name <em>can be preceded by the &amp; operator</em>.</p>\n<p id=\"so_24434157_24630425_4\">2 If the name is a function template, <em>template argument deduction is done</em> (14.8.2.2), and if the argument deduction succeeds, the resulting template argument list is used to generate a single function template specialization, which is added to the set of overloaded functions considered.</p>\n</blockquote>\n<p>Given the pointer and the compiler's deduction of the type required <code>T</code> for the function <code>foo</code> being <code>int</code> in this case. The compiler then generates the code for the function <code>void foo(int,void*)</code> and then this is used during linking.</p>\n<blockquote>\n<p id=\"so_24434157_24630425_5\"><strong>Implicit instantiation 14.7.1</strong></p>\n<p id=\"so_24434157_24630425_6\">3 Unless a function template specialization has been explicitly instantiated or explicitly specialized, the function template specialization is implicitly instantiated when the specialization is referenced in a context that requires a function definition to exist.</p>\n</blockquote>\n<p>Quotes taken from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\" title=\"C++ public draft n3797.pdf\">C++ WD n3797</a></p>\n</hr>", "LastActivityDate": "2015-07-19T19:43:18.653"}, "24434157": {"CommentCount": "8", "ViewCount": "410", "LastActivityDate": "2015-07-19T19:43:18.653", "Body": "<p>The following minimal code compiles and links fine in GNU C++:</p>\n<pre><code>#include &lt;iostream&gt;\n\n// Simple function\ntemplate&lt;class T&gt;\nvoid foo(T a,void* = 0) {\n  std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n\n// A distpatching class\ntemplate&lt;\n         class T,\n         void (*Function)(T,void*)\n        &gt;\nclass kernel {\npublic:\n  // Function dispatcher\n  template&lt;class M&gt;\n  inline static void apply(M t) {\n    Function(t,0);\n  }\n};\n\nint main()\n{\n  kernel&lt;int,foo&gt;::apply(5);\n  //foo(5,0);\n}\n</code></pre>\n<p>but with Visual Studio 2008 it produces the error</p>\n<pre><code>error LNK2019: Verweis auf nicht aufgel\u00f6stes externes Symbol \"\"void __cdecl foo&lt;int&gt;(int,void *)\" (??$foo@H@@YAXHPAX@Z)\" in Funktion \"\"public: static void __cdecl kernel&lt;int,&amp;void __cdecl foo&lt;int&gt;(int,void *)&gt;::apply&lt;int&gt;(int)\" (??$apply@H@?$kernel@H$1??$foo@H@@YAXHPAX@Z@@SAXH@Z)\".\n</code></pre>\n<p>Obviously the whole function implementation is there, but it seems that the compiler throws away the implementation of the <code>foo</code> function.  If the commented line is activated then the linker finds the symbol.</p>\n<p>I think (as g++ compiles it fine) this is valid code, so I suppose there is some bug in VS 2008, or am I doing something wrong here?  Does anyone knows a workaround/solution for this?   The final code has to work with Visual Studio 2008 and in the real code it is not possible to guess all the template type combinations (i.e. I cannot explicitly instantiate the functions for all available types: here just T, in the real code, up to 5 template parameters with arbitrary classes are used).</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "24630425", "FavoriteCount": "1", "Title": "LNK2019 (VS 2008) with full implementation of template function using template function pointers", "Id": "24434157", "Score": "8", "CreationDate": "2014-06-26T15:10:50.157", "Tags": "<c++><templates><visual-studio-2008><function-pointers><lnk2019>", "OwnerUserId": "3779790", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24434157_24630425_6": {"section_id": 235, "quality": 0.9545454545454546, "length": 21}, "so_24434157_24630425_4": {"section_id": 642, "quality": 0.9583333333333334, "length": 23}, "so_24434157_24630425_3": {"section_id": 641, "quality": 0.9285714285714286, "length": 13}, "so_24434157_24630425_1": {"section_id": 12, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_24434157_24630425_6": {"section_id": 228, "quality": 0.9545454545454546, "length": 21}, "so_24434157_24630425_4": {"section_id": 632, "quality": 0.9583333333333334, "length": 23}, "so_24434157_24630425_3": {"section_id": 631, "quality": 0.9285714285714286, "length": 13}, "so_24434157_24630425_1": {"section_id": 9, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_24434157_24630425_3": {"section_id": 669, "quality": 0.9285714285714286, "length": 13}, "so_24434157_24630425_4": {"section_id": 670, "quality": 0.9583333333333334, "length": 23}, "so_24434157_24630425_6": {"section_id": 245, "quality": 0.9545454545454546, "length": 21}, "so_24434157_24630425_1": {"section_id": 13, "quality": 0.9166666666666666, "length": 11}}}});