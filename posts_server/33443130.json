post_cb({"bq_ids": {"n4140": {"so_33443130_33443130_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 89}}, "n3337": {"so_33443130_33443130_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 84}}}, "33679752": {"CommentCount": "0", "Body": "<p>Replace your main with this piece of code</p>\n<pre><code>int main(void)\n{    \nconstexpr static int bb = 5;    \nconstexpr test&lt;&amp;bb&gt; t;    \nreturn 0;\n}\n</code></pre>\n<p>and you will receive the error bb cannot be used as a template argument because it has no linkage ( not to be mistaken with linker related staff ) .</p>\n<p>Class data members cannot be accessed unless they are referenced through the object, and cannot be taken into account during template instantiation, since data members do not have linkage, i.e. they are not defined symbols and therefore cannot be used as template arguments.</p>\n<p>That being said , doing a readelf you can verify this:</p>\n<pre><code>48: 00000000004006ac     4 OBJECT  LOCAL  DEFAULT   14 q0\n\n\n68: 000000000060097c     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start\n69: 0000000000600978     4 OBJECT  GLOBAL DEFAULT   23 q::a\n</code></pre>\n<p>but there is no <code>q0.b</code> defined . The alternative would be to name (mangle) none static class members which would strip dynamic capabilities of the language.</p>\n", "CreationDate": "2015-11-12T19:32:57.203", "ParentId": "33443130", "Id": "33679752", "LastActivityDate": "2015-11-12T19:32:57.203", "PostTypeId": "2", "Score": "1", "OwnerUserId": "4345926"}, "33443130": {"CreationDate": "2015-10-30T18:59:15.850", "ViewCount": "372", "FavoriteCount": "6", "Id": "33443130", "AcceptedAnswerId": "33443763", "Score": "26", "Title": "Why is address of non-static member not allowed as template non-type parameter?", "LastEditorUserId": "2035439", "CommentCount": "13", "Body": "<pre><code>template &lt;int * ip&gt; struct test {};\n\nstruct q {\n    static int a;\n    int b;\n\n    constexpr q(int b_) : b(b_) {}\n};\n\nint i;\nconstexpr q q0(2);\n\nint main()\n{\n    constexpr test&lt;&amp;i&gt; t1;      // Works fine\n    constexpr test&lt;&amp;q::a&gt; t2;   // Works \n    constexpr test&lt;&amp;q0.b&gt; t3;   // Does not work; address of non-static member?\n\n    return 0;\n}\n</code></pre>\n<p>The declaration of t3 in the above piece of code fails despite the template argument <code>&amp;q0.b</code> being known during compile time. Some googling revealed that this is disallowed by the standard (section 14.3.2):</p>\n<blockquote>\n<p id=\"so_33443130_33443130_0\">[Note: Addresses of array elements and names or addresses of non-static class members are not acceptable template-arguments.</p>\n<p id=\"so_33443130_33443130_1\">X&lt;&amp;s.m&gt; x4; // error: address of non-static membe</p>\n</blockquote>\n<p>So why exactly is this explicitly disallowed by the standard despite the addresses of non-static members of global variables being unique as well as known during compile-time?</p>\n", "Tags": "<c++><templates><language-lawyer>", "LastEditDate": "2015-10-30T19:22:50.613", "LastActivityDate": "2015-11-12T19:32:57.203", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "2035439"}, "33443763": {"CommentCount": "3", "Body": "<p>First, to use pointers/references to subobjects, you'd need to be able to mangle them. That's a pretty big undertaking.</p>\n<p>Second, and probably more importantly, from <a href=\"http://wg21.link/N4198\">N4198</a>:</p>\n<blockquote>\n<p id=\"so_33443130_33443763_0\">The restriction that the constant expression must name a complete\n  object is retained to avoid aliasing problems with pointers to\n  subobjects:</p>\n<pre><code>struct A { int x, y; } a;\ntemplate&lt;int*&gt; struct Z;\nusing B = Z&lt;&amp;a.x + 1&gt;;\nusing C = Z&lt;&amp;a.y&gt;;\n// Are B and C the same type?\n</code></pre>\n</blockquote>\n<p>To quote <a href=\"https://groups.google.com/a/isocpp.org/d/msg/std-discussion/26jBWYIBrp0/o74AWYXMWpMJ\">Richard Smith</a>,</p>\n<blockquote>\n<p id=\"so_33443130_33443763_1\">The answer \"yes\" is problematic because there are things you can do\n  with a pointer to [<code>a.y</code>] that would have undefined behavior if\n  performed on a pointer past the end of [<code>a.x</code>] The answer \"no\" is\n  problematic because they (in typical implementations) represent the\n  same address.</p>\n</blockquote>\n", "CreationDate": "2015-10-30T19:43:48.400", "ParentId": "33443130", "Id": "33443763", "LastActivityDate": "2015-10-30T19:43:48.400", "PostTypeId": "2", "Score": "15", "OwnerUserId": "2756719"}});