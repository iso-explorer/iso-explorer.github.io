post_cb({"bq_ids": {"n4140": {"so_32911729_32911729_0": {"length": 33, "quality": 0.8048780487804879, "section_id": 5979}}, "n3337": {"so_32911729_32911729_0": {"length": 33, "quality": 0.8048780487804879, "section_id": 5747}}}, "32913392": {"LastActivityDate": "2015-10-02T18:31:05.890", "CommentCount": "2", "Body": "<p>The relationship between a <strong>closure</strong> to <strong>lambda</strong> is similar to <strong>object</strong> to <strong>class</strong>.</p>\n<p>The <em>C++11 standard</em> says that the <strong>closure!</strong> type has no default constructor, and that is correct because it doesn't say it has no constructor.</p>\n<p>The lambda is used to create a closure. But your quoted parapgraph will change for <em>C++14</em>.</p>\n<pre><code>ClosureType() = delete;                     // (until C++14)\nClosureType(const ClosureType&amp; ) = default; // (since C++14)\nClosureType(ClosureType&amp;&amp; ) = default;      // (since C++14)\n</code></pre>\n<blockquote>\n<p id=\"so_32911729_32913392_0\">Closure types are not <a href=\"http://en.cppreference.com/w/cpp/concept/DefaultConstructible\" rel=\"nofollow\">DefaultConstructible</a>. Closure types have <code>a deleted (until C++14)</code> <code>no (since C++14)</code> default constructor. The copy constructor and the move constructor are <code>implicitly-declared (until C++14)</code> declared <code>as defaulted (since C++14)</code> and may be implicitly-defined according to the usual rules for copy constructors and move constructors.</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/lambda</a></p>\n", "CreationDate": "2015-10-02T18:18:52.303", "LastEditDate": "2015-10-02T18:31:05.890", "ParentId": "32911729", "Id": "32913392", "LastEditorUserId": "1385931", "PostTypeId": "2", "Score": "4", "OwnerUserId": "1385931"}, "32911729": {"CreationDate": "2015-10-02T16:30:31.057", "ViewCount": "1472", "FavoriteCount": "2", "Id": "32911729", "AcceptedAnswerId": "32913392", "Score": "1", "Title": "Understanding how Lambda closure type has deleted default constructor", "LastEditorUserId": "3348786", "CommentCount": "1", "Body": "<p>From 5.1.2 </p>\n<blockquote>\n<p id=\"so_32911729_32911729_0\">[19] The closure type associated with a lambda-expression <strong>has a deleted (8.4.3) default constructor</strong> and a deleted\n  copy assignment operator. It has an implicitly-declared copy constructor (12.8) and may have an implicitlydeclared\n  move constructor (12.8). [ Note: The copy/move constructor is implicitly defined in the same way\n  as any other implicitly declared copy/move constructor would be implicitly defined. \u2014end note ]</p>\n</blockquote>\n<p>I'm reading through C++ Primer 14.8.1 which explains lambda expressions being translated by the compiler in to an unnamed object of an unnamed class. How is it I can I define objects of lambda functions which do not contain a lambda capture, if the default constructor is deleted?</p>\n<pre><code> auto g = [](){};\n</code></pre>\n<p>Is this not conceptually the same as...</p>\n<pre><code> class lambdaClass{\n public:\n      lambdaClass() = delete;\n      lambdaClass&amp; operator=(const lambdaClass&amp;) = delete;\n      void operator()(){ }\n\n      //copy/move constructor and destructor implicitly defined\n};\n\nauto g = lambdaClass(); //would be an error since default is deleted.\n</code></pre>\n<p>If there was a capture then a constructor <em>other</em> than the default constructor would be defined and it would be okay to initialise objects of such (as long as a parameter was passed). But if there is no capture and the default constructor is deleted, it doesn't seem consistent conceptually that a lambda class object can be created.</p>\n<p>Edit: Hmm, maybe the conception that the lambda class creates constructors depending on its lambda captures is unfounded despite this being how it's described in C++ Primer (I can find no quote of it in the standard), because the following code does not work even though I would expect it to conceptually:</p>\n<pre><code>int sz = 2;\nauto a = [sz](){ return sz;};\ndecltype(a) b(10); //compiler error\ndecltype(a) b = a; //all good though\n</code></pre>\n", "Tags": "<c++><constructor><lambda><default>", "LastEditDate": "2015-10-02T17:00:51.657", "LastActivityDate": "2015-10-02T18:31:05.890", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "3348786"}});