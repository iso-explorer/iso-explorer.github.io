post_cb({"37345994": {"ParentId": "37345946", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>There is nothing really surprising going on here.</p>\n<pre><code>template &lt;typename T&gt;\nclass Foo\n{\n    //...\n};\n</code></pre>\n<p>Is not a class, it is a template to stamp out classes.  That means <code>Foo&lt;A&gt;</code> is a completely different class from <code>Foo&lt;B&gt;</code>.  As such all static members are unique to the <em>different</em> instantiated classes \u2014 and the fact that class template being same has no relevance in this context, as it is after all a template, the blueprint of the instantiated classes.</p>\n<p>If you want all the different kinds of <code>Foo</code>'s to share a common state then you can have them inherit from the same base class and put the common information there.  Here is a very boiled down example:</p>\n<pre><code>struct Foo_Base\n{\n    static int bar;\n};\n\nint Foo_Base::bar = 10;\n\ntemplate&lt;typename T&gt;\nstruct Foo : Foo_Base {};\n\nint main()\n{   \n    Foo&lt;int&gt; foo_i;\n    Foo&lt;double&gt; foo_d;\n    std::cout &lt;&lt; foo_i.bar &lt;&lt; \"\\n\";\n    foo_i.bar += 10;\n    std::cout &lt;&lt; foo_d.bar;\n}\n</code></pre>\n<p>output:</p>\n<pre><code>10\n20\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/8fd54d19d46f551b\" rel=\"nofollow\">Live Example</a></kbd></p>\n", "OwnerUserId": "4342498", "LastEditorUserId": "643393", "LastEditDate": "2016-05-20T12:38:43.790", "Id": "37345994", "Score": "11", "CreationDate": "2016-05-20T11:50:04.773", "LastActivityDate": "2016-05-20T12:38:43.790"}, "37346109": {"ParentId": "37345946", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>From the standard, $14.7/6 Template instantiation and specialization [temp.spec]</p>\n<blockquote>\n<p id=\"so_37345946_37346109_0\">Each class template specialization instantiated from a template has its own copy of any static members.</p>\n</blockquote>\n<p><code>Foo&lt;int&gt;</code> and <code>Foo&lt;double&gt;</code> are irrelevant classes, even though they're instantiated from the same template, and they will have their own static member <code>bar</code>, even though their types are same (e.g. both <code>int</code>).</p>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2016-05-20T12:07:54.583", "Id": "37346109", "Score": "9", "CreationDate": "2016-05-20T11:55:12.023", "LastActivityDate": "2016-05-20T12:07:54.583"}, "37345946": {"CommentCount": "0", "ViewCount": "126", "PostTypeId": "1", "LastEditorUserId": "4342498", "CreationDate": "2016-05-20T11:47:27.363", "LastActivityDate": "2017-03-23T14:49:22.660", "Title": "Why are static members of template classes not unique", "AcceptedAnswerId": "37345994", "LastEditDate": "2017-03-23T14:49:22.660", "Id": "37345946", "Score": "5", "Body": "<p>Take a look at the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nclass Foo\n{\n    public:\n    static T bar;\n};\n\ntemplate &lt;typename T&gt; typename T Foo&lt;T&gt;::bar;\n\nint main() {\n    std::cout &lt;&lt; \"Foo&lt;int&gt;::bar : \" &lt;&lt; &amp;Foo&lt;int&gt;::bar &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Foo&lt;double&gt;::bar : \" &lt;&lt; &amp;Foo&lt;double&gt;::bar &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>This will print out 2 different addresses. I can understand why in this case, <code>bar</code> is of type <code>T</code> and thus instantiations of different T's in <code>Foo&lt;T&gt;</code> will get you different static members. However, if we change <code>bar</code> to a type we already know ( e.g. <code>static int bar</code> ) this <a href=\"http://ideone.com/xSsCMr\" rel=\"noreferrer\">still happens</a>.</p>\n<p>Why is this the case? Why just not re-use <code>bar</code> for multiple template instantiations? How would I be able to get just 1 <code>bar</code> object throughout different instantiations?</p>\n", "Tags": "<c++><templates><c++14><static-members>", "OwnerUserId": "1870760", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_37345946_37346109_0": {"section_id": 232, "quality": 1.0, "length": 11}}, "n3337": {"so_37345946_37346109_0": {"section_id": 225, "quality": 1.0, "length": 11}}, "n4659": {"so_37345946_37346109_0": {"section_id": 240, "quality": 1.0, "length": 11}}}, "37346320": {"ParentId": "37345946", "CommentCount": "0", "Body": "<p><code>Foo&lt;int&gt;::bar</code> and <code>Foo&lt;double&gt;::bar</code> are two different global (statically accessible class-level) variables. they are not same. Consider this code:</p>\n<pre><code>template &lt;typename T&gt;\nclass Foo\n{\npublic:\n    static T var1;\n    static int var2;\n};\n</code></pre>\n<p>What do you think the relative placement of <code>var2</code> be (assume compiler places <code>var2</code> just after <code>var1</code>)? In one case, it may be relatively just 1 byte ahead (<code>foo&lt;char&gt;</code>), but 8 bytes ahead in case of other datatype.</p>\n", "OwnerUserId": "264325", "PostTypeId": "2", "Id": "37346320", "Score": "0", "CreationDate": "2016-05-20T12:05:19.590", "LastActivityDate": "2016-05-20T12:05:19.590"}});