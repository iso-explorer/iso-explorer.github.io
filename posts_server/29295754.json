post_cb({"29296413": {"Id": "29296413", "PostTypeId": "2", "Body": "<p>As N4296 10.4 [class.abstract]\nsays:</p>\n<blockquote>\n<p id=\"so_29295754_29296413_0\">An abstract class shall not be used as a parameter type, as a function\n  return type, or as the type of an explicit conversion. Pointers and\n  references to an abstract class can be declared.</p>\n</blockquote>\n<pre><code>[ Example:\nshape x;//  error: object of abstract class\nshape* p;// OK\nshape f();// error\nvoid g(shape);// error\nshape&amp; h(shape&amp;);//OK\n\u2014 end example ]\n</code></pre>\n<p>So gcc follow the standard.</p>\n<p>Why cannot declare parameter to be of abstract type? Suppose when a pass subclass object to bar,object slicing happen,oh,an object that has a pure virtual function...This is a contradiction.That maybe the reason.</p>\n<h2>EDIT:</h2>\n<p>Why clang pass it,it is clang compiler issue.</p>\n", "LastEditorUserId": "2593814", "LastActivityDate": "2015-03-28T00:35:48.513", "Score": "1", "CreationDate": "2015-03-27T08:41:36.287", "ParentId": "29295754", "CommentCount": "3", "OwnerUserId": "2593814", "LastEditDate": "2015-03-28T00:35:48.513"}, "bq_ids": {"n4140": {"so_29295754_29296413_0": {"length": 16, "quality": 1.0, "section_id": 7020}}, "n3337": {"so_29295754_29296413_0": {"length": 16, "quality": 1.0, "section_id": 6766}}, "n4659": {"so_29295754_29296413_0": {"length": 16, "quality": 1.0, "section_id": 8517}}}, "29295754": {"ViewCount": "144", "Body": "<p>why does clang++ 3.6 compile the follwing code (g++ doesn't)?</p>\n<pre><code>class Abc\n{\npublic:\n    virtual void foo() const = 0;\n    virtual ~Abc() {}\n};\n\n// is correctly rejected\n// void bar(Abc o)\n// {\n// }\n\nclass B\n{\n    void bar(Abc o) // should also be rejected\n    {\n    }\n\n};\n\nint main()\n{\n}\n</code></pre>\n<p>I am using clang 3.6 and gcc 4.9.2.</p>\n<p>Why is the free function (correctly) rejected and the member function not?</p>\n<p>Any hints? A Bug in clang?</p>\n<p>If I modify the above to:</p>\n<pre><code>class Abc\n{\npublic:\n    virtual void foo() const = 0;\n    virtual ~Abc() {}\n};\nclass Impl : public Abc {\npublic:\n    void foo() const {}\n};\nclass B\n{\npublic:\n    void bar(Abc o)\n    {\n        o.foo();\n    }\n};\nint main()\n{\n    B b;\n    Impl i;\n    b.bar(i);\n}\n</code></pre>\n<p>I get an </p>\n<p>main.cc:16: undefined reference to `Abc::foo() const'</p>\n<p>linker error.</p>\n<p>So the question is: why at all allows clang++ to compile this wrong code?\nI would say that is a heavy bug!</p>\n", "Title": "Passing abstract object by value weirdness in clang++", "CreationDate": "2015-03-27T07:53:58.507", "LastActivityDate": "2015-03-28T00:35:48.513", "CommentCount": "4", "LastEditDate": "2015-03-27T10:07:40.423", "PostTypeId": "1", "LastEditorUserId": "3359751", "Id": "29295754", "Score": "6", "OwnerUserId": "3359751", "Tags": "<c++>", "AnswerCount": "1"}});