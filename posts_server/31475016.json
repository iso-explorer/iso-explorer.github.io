post_cb({"31475016": {"CommentCount": "5", "ViewCount": "169", "CreationDate": "2015-07-17T11:41:45.223", "LastActivityDate": "2015-07-17T14:19:11.393", "Title": "Overloading of template function in template class", "AcceptedAnswerId": "31475554", "PostTypeId": "1", "Id": "31475016", "Score": "5", "Body": "<p>I have a templated operator in templated class and I want to change its behavior for specific type. My code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename N&gt;\nstruct A {\n  int x;\n  template&lt;typename T&gt;\n  A&amp; operator&lt;&lt;(const T&amp; t) {\n    x += static_cast&lt;int&gt;(t);\n    return *this;\n  }\n};\n\n\nenum class B {\n  s,t\n};\n\ntemplate &lt;typename N&gt;\nA&lt;N&gt;&amp; operator&lt;&lt;(A&lt;N&gt;&amp; a, const B&amp; b) {\n  a.x -= static_cast&lt;int&gt;(b);\n  return a;\n}\n\nint main() {\n  A&lt;int&gt; a{3};\n  std::cout &lt;&lt; (a&lt;&lt;1).x &lt;&lt; \" \" &lt;&lt; (a &lt;&lt; B::s).x;\n}\n</code></pre>\n<p>g++-4.9 compiles it fine but clang-3.6 complains that it's ambiguous.</p>\n<p>Note, that if class is not templated, than both of compilers compile it fine.</p>\n<p>What is correct behavior?</p>\n", "Tags": "<c++><templates><g++><language-lawyer><clang++>", "OwnerUserId": "768110", "AnswerCount": "2"}, "31475554": {"ParentId": "31475016", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Short summary: I believe this is a gcc bug in the template partial ordering rules, and that clang is correct. I filed <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66914\" rel=\"nofollow\">bug 66914</a>, although it's probably a duplicate of <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53499\" rel=\"nofollow\">bug 53499</a> which I didn't notice until afterwards. </p>\n<hr/>\n<p>In the call</p>\n<pre><code>a &lt;&lt; B::s;\n</code></pre>\n<p>We have two viable candidates:</p>\n<pre><code>template &lt;typename T&gt; A&lt;int&gt;::operator&lt;&lt;(const T&amp; );\ntemplate &lt;typename N&gt; operator&lt;&lt;(A&lt;N&gt;&amp;, const B&amp; );\n</code></pre>\n<p>You can rewrite the member function to take a reference to the instance as the first argument, and write out both as instantiatons. So we have:</p>\n<pre><code>template &lt;&gt; operator&lt;&lt;(A&lt;int&gt;&amp;, const B&amp; ); // [T = B]\ntemplate &lt;&gt; operator&lt;&lt;(A&lt;int&gt;&amp;, const B&amp; ); // [N = int]\n</code></pre>\n<p>Since both are viable candidates, let's go through the rules in [over.match.best] to determine which one is the best viable candidate:</p>\n<blockquote>\n<p id=\"so_31475016_31475554_0\">Given these definitions, a viable function F1 is defined to be a better function than another viable function\n  F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<p id=\"so_31475016_31475554_1\">\u2014 for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,</p>\n</blockquote>\n<p>Nope, both take the exact same arguments, so the conversion sequences are identical.</p>\n<blockquote>\n<p id=\"so_31475016_31475554_2\">\u2014 the context is an initialization by user-defined conversion [ ... ]</p>\n</blockquote>\n<p>Nope, irrelevant.</p>\n<blockquote>\n<p id=\"so_31475016_31475554_3\">\u2014 the context is an initialization by conversion function [ ... ]</p>\n</blockquote>\n<p>Nope, irrelevant.</p>\n<blockquote>\n<p id=\"so_31475016_31475554_4\">\u2014 F1 is not a function template specialization and F2 is a function template specialization, or, if not that,</p>\n</blockquote>\n<p>Nope, <em>both</em> are function template specializations.</p>\n<blockquote>\n<p id=\"so_31475016_31475554_5\">\u2014 F1 and F2 are function template specializations, and the function template for F1 is more specialized\n  than the template for F2 according to the partial ordering rules described in 14.5.6.2.</p>\n</blockquote>\n<p>This is the most complicated of the rules. Ultimately, neither is more specialized than the other. Why? The member function is effectively:</p>\n<pre><code>template &lt;typename T&gt; A&lt;int&gt;&amp; operator&lt;&lt;(A&lt;int&gt;&amp;, const T&amp; );\n</code></pre>\n<p>If we synthesized a type for <code>T</code> (call it <code>Unique1</code>), deduction would fail against the free function (since <code>Unique1</code> wouldn't match <code>B</code>). On the other side, if we synthesized a type for <code>N</code> (call it <code>Unique2</code>), deduction would fail against the member function (since <code>Unique2</code> wouldn't match <code>int</code>).</p>\n<p>Since neither function is more specialized than the other, we've run out of bullet points. The function call should be ambiguous, this is a gcc bug. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-07-17T14:19:11.393", "Id": "31475554", "Score": "5", "CreationDate": "2015-07-17T12:10:21.650", "LastActivityDate": "2015-07-17T14:19:11.393"}, "31475568": {"ParentId": "31475016", "CommentCount": "2", "Body": "<p>This:</p>\n<pre><code>template &lt;typename N&gt;\nA&lt;N&gt;&amp; operator&lt;&lt;(A&lt;N&gt;&amp; a, const B&amp; b) {\n  a.x -= static_cast&lt;int&gt;(b);\n  return a;\n}\n</code></pre>\n<p>is not an overload of your member operator (I'm sure there is a more correct way to say it from the standardese point of view), and not a specialization, it is a global template operator that participates in overload resolution.</p>\n<p>From that point of view both are equally perfect matches so I think clang is correct.</p>\n", "OwnerUserId": "4999494", "PostTypeId": "2", "Id": "31475568", "Score": "-1", "CreationDate": "2015-07-17T12:11:00.743", "LastActivityDate": "2015-07-17T12:11:00.743"}, "bq_ids": {"n4140": {"so_31475016_31475554_0": {"section_id": 603, "quality": 0.85, "length": 17}, "so_31475016_31475554_2": {"section_id": 603, "quality": 1.0, "length": 4}, "so_31475016_31475554_1": {"section_id": 603, "quality": 0.75, "length": 6}, "so_31475016_31475554_3": {"section_id": 603, "quality": 1.0, "length": 4}, "so_31475016_31475554_5": {"section_id": 603, "quality": 0.9333333333333333, "length": 14}, "so_31475016_31475554_4": {"section_id": 147, "quality": 1.0, "length": 6}}, "n3337": {"so_31475016_31475554_0": {"section_id": 593, "quality": 0.85, "length": 17}, "so_31475016_31475554_2": {"section_id": 593, "quality": 1.0, "length": 4}, "so_31475016_31475554_1": {"section_id": 593, "quality": 0.75, "length": 6}, "so_31475016_31475554_3": {"section_id": 593, "quality": 1.0, "length": 4}, "so_31475016_31475554_5": {"section_id": 593, "quality": 0.9333333333333333, "length": 14}, "so_31475016_31475554_4": {"section_id": 141, "quality": 1.0, "length": 6}}, "n4659": {"so_31475016_31475554_5": {"section_id": 629, "quality": 0.9333333333333333, "length": 14}, "so_31475016_31475554_2": {"section_id": 629, "quality": 1.0, "length": 4}, "so_31475016_31475554_1": {"section_id": 629, "quality": 0.75, "length": 6}, "so_31475016_31475554_3": {"section_id": 629, "quality": 1.0, "length": 4}, "so_31475016_31475554_0": {"section_id": 629, "quality": 0.85, "length": 17}, "so_31475016_31475554_4": {"section_id": 151, "quality": 1.0, "length": 6}}}});