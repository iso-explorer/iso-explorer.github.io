post_cb({"32034260": {"ParentId": "32034115", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-08-16T10:53:56.110", "Score": "4", "LastEditorUserId": "3953764", "LastEditDate": "2015-08-16T11:08:44.777", "Id": "32034260", "OwnerUserId": "3953764", "Body": "<p>\u00a7 23.3.6.1 [vector.overview]/p1:</p>\n<blockquote>\n<p id=\"so_32034115_32034260_0\">A vector is a sequence container that supports random access iterators.</p>\n</blockquote>\n<p>A <a href=\"http://en.cppreference.com/w/cpp/concept/RandomAccessIterator\" rel=\"nofollow\">random access iterator</a> is the one that is able to compute the offset of an arbitrary element in a constant time, without a need to iterate from one place to another (what would result in linear complexity).</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/algorithm/lower_bound\" rel=\"nofollow\"><code>std::lower_bound</code></a> itself provides generic implementation of the binary search algorithm, that doesn't care much about what iterator is used to indicate ranges (it only requires the iterator to be of at least a <a href=\"http://en.cppreference.com/w/cpp/concept/ForwardIterator\" rel=\"nofollow\">forward</a> category). It uses helper functions like <code>std::advance</code> to iteratively limit the ranges in its binary search. With <code>std::vector&lt;T&gt;::iterator</code> which <em>is</em> of a random access category, <code>std::lower_bound</code> runs with logarithmic time complexity with regards to the number of steps required to iterate over elements, as it can partition the range by half in each step in a constant time.</p>\n<p>\u00a7 25.4.3 [alg.binary.search]/p1:</p>\n<blockquote>\n<p id=\"so_32034115_32034260_1\">All of the algorithms in this section are versions of binary search and assume that the sequence being\n  searched is partitioned with respect to an expression formed by binding the search key to an argument of\n  the implied or explicit comparison function. They work on non-random access iterators minimizing the\n  number of comparisons, which will be logarithmic for all types of iterators. <strong>They are especially appropriate\n  for random access iterators, because these algorithms do a logarithmic number of steps through the data\n  structure. For non-random access iterators they execute a linear number of steps.</strong></p>\n</blockquote>\n", "LastActivityDate": "2015-08-16T11:08:44.777"}, "bq_ids": {"n4140": {"so_32034115_32034260_0": {"section_id": 955, "quality": 1.0, "length": 7}, "so_32034115_32034260_1": {"section_id": 1421, "quality": 0.9827586206896551, "length": 57}}, "n3337": {"so_32034115_32034260_0": {"section_id": 943, "quality": 1.0, "length": 7}, "so_32034115_32034260_1": {"section_id": 1415, "quality": 0.9827586206896551, "length": 57}}, "n4659": {"so_32034115_32034260_0": {"section_id": 856, "quality": 0.8571428571428571, "length": 6}, "so_32034115_32034260_1": {"section_id": 1541, "quality": 0.9827586206896551, "length": 57}}}, "32034115": {"CommentCount": "6", "AcceptedAnswerId": "32034260", "PostTypeId": "1", "LastEditorUserId": "3953764", "CreationDate": "2015-08-16T10:36:43.757", "LastActivityDate": "2015-08-16T11:08:44.777", "LastEditDate": "2015-08-16T10:55:39.943", "ViewCount": "1727", "FavoriteCount": "1", "Title": "Time complexity of std::lower_bound on a sorted vector", "Id": "32034115", "Score": "2", "Body": "<p>I was studying <code>std::upper_bound</code> from <a href=\"http://www.cplusplus.com/reference/algorithm/upper_bound/\" rel=\"nofollow\">http://www.cplusplus.com/reference/algorithm/upper_bound/</a>\nand I came across the fact that this might run in linear time on <em>non-random access</em> iterators.</p>\n<p>I need to use this for a sorted vector. Now I don't know what are <em>non-random access</em> iterators and whether this will run in logarithmic time on the sorted vector.</p>\n<p>Can anyone clear this for me.</p>\n", "Tags": "<c++><c++11><vector><iterator><lower-bound>", "OwnerUserId": "4039495", "AnswerCount": "1"}});