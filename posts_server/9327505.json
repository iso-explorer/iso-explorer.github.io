post_cb({"9327505": {"ViewCount": "873", "Body": "<pre><code>#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nint fun1()\n{\n    printf(\"I am fun1.\");\n    return 0;\n}\n\nint fun2(int fun())\n{\n    fun();\n    return 0;\n}\n\nint main()\n{\n    fun2(fun1);\n    return 0;\n}\n</code></pre>\n<p>The above program can run. As far as I am concerned, I can understand <code>int fun2(int (*fun)())</code>, but I do not know how <code>int fun2(int fun())</code> works.  Thank you.</p>\n", "AcceptedAnswerId": "9327552", "Title": "About Pointers To Functions in function declarations", "CreationDate": "2012-02-17T11:34:09.160", "Id": "9327505", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2012-05-28T08:50:17.793", "LastEditorUserId": "648658", "LastActivityDate": "2012-05-28T08:50:17.793", "Score": "22", "OwnerUserId": "1174746", "Tags": "<c++><c><function><pointers><function-pointers>", "AnswerCount": "4"}, "9328713": {"Id": "9328713", "PostTypeId": "2", "Body": "<p>These two function definitions are equivalent in C:</p>\n<pre><code> int fun2(int fun()) { ... }\n</code></pre>\n<p>and</p>\n<pre><code> int fun2(int (*fun)()) { ... }\n</code></pre>\n<p>In the first function the parameter is adjusted to a function pointer. See C Standard paragraph:</p>\n<blockquote>\n<p id=\"so_9327505_9328713_0\">(C99, 6.7.5.3p8) \"A declaration of a parameter as \u2018\u2018function returning type\u2019\u2019 shall be adjusted to \u2018\u2018pointer to function returning type\u2019\u2019, as in 6.3.2.1.\"</p>\n</blockquote>\n", "LastActivityDate": "2012-02-17T13:03:09.167", "Score": "3", "CreationDate": "2012-02-17T13:03:09.167", "ParentId": "9327505", "CommentCount": "0", "OwnerUserId": "1119701"}, "9327552": {"Id": "9327552", "PostTypeId": "2", "Body": "<p>When you write <code>int fun2(int fun())</code>, the parameter <code>int fun()</code> converts into <code>int (*fun)()</code>, it becomes exactly equivalent to this:</p>\n<pre><code>int fun2(int (*fun)());\n</code></pre>\n<p>A more famiiar conversion happens in case of array when you declare it as function parameter. For example, if you've this:</p>\n<pre><code>int f(int a[100]);\n</code></pre>\n<p>Even here the parameter type converts into <code>int*</code>, and it becomes this:</p>\n<pre><code>int f(int *a);\n</code></pre>\n<p>The reason why function type and array type converts into function <em>pointer</em> type, and pointer type, respectively, is because the  Standard doesn't allow function and array to be passed to a function, neither can you return function and array from a function. In both cases, they decay into their pointer version.</p>\n<p>The C++03 Standard says in \u00a713.1/3 (and it is same in C++11 also),</p>\n<blockquote>\n<p id=\"so_9327505_9327552_0\">Parameter declarations that differ only in that one is a function type and the other is a pointer to the same function type are <strong>equivalent</strong>. <strong>That is, the function type is adjusted to become a pointer to function type (8.3.5)</strong>.</p>\n</blockquote>\n<p>And a more interesting discussion is here:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/7321993/reference-to-function-syntax-with-and-without\">Reference to Function syntax - with and without &amp;</a></li>\n</ul>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-02-17T12:07:35.490", "Score": "32", "CreationDate": "2012-02-17T11:37:28.707", "ParentId": "9327505", "CommentCount": "3", "LastEditDate": "2017-05-23T11:53:14.593", "OwnerUserId": "415784"}, "bq_ids": {"n4140": {"so_9327505_9328713_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 558}, "so_9327505_9327552_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 558}}, "n3337": {"so_9327505_9328713_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 549}, "so_9327505_9327552_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 549}}, "n4659": {"so_9327505_9328713_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 581}, "so_9327505_9327552_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 581}}}, "9327535": {"Id": "9327535", "PostTypeId": "2", "Body": "<p><code>int fun2(int (*fun)())</code> and <code>int fun2(int fun())</code> are exactly the same. When you declare a function argument from a function type, the compiler uses it as if it were a pointer to the same function type.</p>\n", "LastEditorUserId": "152796", "LastActivityDate": "2012-02-17T23:29:08.853", "Score": "6", "CreationDate": "2012-02-17T11:35:55.040", "ParentId": "9327505", "CommentCount": "0", "LastEditDate": "2012-02-17T23:29:08.853", "OwnerUserId": "1055952"}, "9327547": {"Id": "9327547", "PostTypeId": "2", "Body": "<p>Looking to it in a lower level (and in a x86-based architecture):</p>\n<pre><code>int fun2(int fun())\n</code></pre>\n<p><em>int fun()</em>'s address is pushed into the stack and passed to fun2() function.</p>\n<pre><code>int fun2(int (*fun)())\n</code></pre>\n<p><em>int fun()</em>'s <strong>pointer</strong> address is pushed into the stack and passed to fun2() function.</p>\n<p>The result is the same, except that with second one, you pass the fun()'s address by reference, and in the first one you pass it by value.</p>\n", "LastActivityDate": "2012-02-17T11:36:54.990", "Score": "-3", "CreationDate": "2012-02-17T11:36:54.990", "ParentId": "9327505", "CommentCount": "8", "OwnerUserId": "898478"}});