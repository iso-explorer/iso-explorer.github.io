post_cb({"13150449": {"CommentCount": "8", "AcceptedAnswerId": "13208789", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-10-31T02:32:10.630", "LastActivityDate": "2017-05-01T18:26:41.840", "LastEditDate": "2017-05-23T11:33:26.740", "ViewCount": "26078", "FavoriteCount": "35", "Title": "Efficient unsigned-to-signed cast avoiding implementation-defined behavior", "Id": "13150449", "Score": "70", "Body": "<p>I want to define a function that takes an <code>unsigned int</code> as argument and returns an <code>int</code> congruent modulo UINT_MAX+1 to the argument.</p>\n<p>A first attempt might look like this:</p>\n<pre><code>int unsigned_to_signed(unsigned n)\n{\n    return static_cast&lt;int&gt;(n);\n}\n</code></pre>\n<p>But as any language lawyer knows, casting from unsigned to signed for values larger than INT_MAX is implementation-defined.</p>\n<p>I want to implement this such that (a) it only relies on behavior mandated by the spec; and (b) it compiles into a no-op on any modern machine and optimizing compiler.</p>\n<p>As for bizarre machines...  If there is no signed int congruent modulo UINT_MAX+1 to the unsigned int, let's say I want to throw an exception.  If there is more than one (I am not sure this is possible), let's say I want the largest one.</p>\n<p>OK, second attempt:</p>\n<pre><code>int unsigned_to_signed(unsigned n)\n{\n    int int_n = static_cast&lt;int&gt;(n);\n\n    if (n == static_cast&lt;unsigned&gt;(int_n))\n        return int_n;\n\n    // else do something long and complicated\n}\n</code></pre>\n<p>I do not much care about the efficiency when I am not on a typical twos-complement system, since in my humble opinion that is unlikely.  And if my code becomes a bottleneck on the omnipresent sign-magnitude systems of 2050, well, I bet someone can figure that out and optimize it then.</p>\n<p>Now, this second attempt is pretty close to what I want.  Although the cast to <code>int</code> is implementation-defined for some inputs, the cast back to <code>unsigned</code> is guaranteed by the standard to preserve the value modulo UINT_MAX+1.  So the conditional does check exactly what I want, and it will compile into nothing on any system I am likely to encounter.</p>\n<p>However...  I am still casting to <code>int</code> without first checking whether it will invoke implementation-defined behavior.  On some hypothetical system in 2050 it could do who-knows-what.  So let's say I want to avoid that.</p>\n<p>Question:  What should my \"third attempt\" look like?</p>\n<p>To recap, I want to:</p>\n<ul>\n<li>Cast from unsigned int to signed int</li>\n<li>Preserve the value mod UINT_MAX+1</li>\n<li>Invoke only standard-mandated behavior</li>\n<li>Compile into a no-op on a typical twos-complement machine with optimizing compiler</li>\n</ul>\n<p>[Update]</p>\n<p>Let me give an example to show why this is not a trivial question.</p>\n<p>Consider a hypothetical C++ implementation with the following properties:</p>\n<ul>\n<li><code>sizeof(int)</code> equals 4</li>\n<li><code>sizeof(unsigned)</code> equals 4</li>\n<li><code>INT_MAX</code> equals 32767</li>\n<li><code>INT_MIN</code> equals -2<sup>32</sup> + 32768</li>\n<li><code>UINT_MAX</code> equals 2<sup>32</sup> - 1</li>\n<li>Arithmetic on <code>int</code> is modulo 2<sup>32</sup> (into the range <code>INT_MIN</code> through <code>INT_MAX</code>)</li>\n<li><code>std::numeric_limits&lt;int&gt;::is_modulo</code> is true</li>\n<li>Casting unsigned <code>n</code> to int preserves the value for 0 &lt;= n &lt;= 32767 and yields <em>zero</em> otherwise</li>\n</ul>\n<p>On this hypothetical implementation, there is exactly one <code>int</code> value congruent (mod UINT_MAX+1) to each <code>unsigned</code> value.  So my question would be well-defined.</p>\n<p>I claim that this hypothetical C++ implementation fully conforms to the C++98, C++03, and C++11 specifications.  I admit I have not memorized every word of all of them...  But I believe I have read the relevant sections carefully.  So if you want me to accept your answer, you either must (a) cite a spec that rules out this hypothetical implementation or (b) handle it correctly.</p>\n<p>Indeed, a correct answer must handle <em>every</em> hypothetical implementation permitted by the standard. That is what \"invoke only standard-mandated behavior\" means, by definition.</p>\n<p>Incidentally, note that <code>std::numeric_limits&lt;int&gt;::is_modulo</code> is utterly useless here for multiple reasons.  For one thing, it can be <code>true</code> even if unsigned-to-signed casts do not work for large unsigned values.  For another, it can be <code>true</code> even on one's-complement or sign-magnitude systems, if arithmetic is simply modulo the entire integer range.  And so on.  If your answer depends on <code>is_modulo</code>, it's wrong.</p>\n<p>[Update 2]</p>\n<p><a href=\"https://stackoverflow.com/a/13208789/768469\">hvd's answer</a> taught me something:  My hypothetical C++ implementation for integers is <em>not</em> permitted by modern C.  The C99 and C11 standards are very specific about the representation of signed integers; indeed, they only permit twos-complement, ones-complement, and sign-magnitude (section 6.2.6.2 paragraph (2); ).</p>\n<p>But C++ is not C.  As it turns out, this fact lies at the very heart of my question.</p>\n<p>The original C++98 standard was based on the much older C89, which says (section 3.1.2.5):</p>\n<blockquote>\n<p id=\"so_13150449_13150449_0\">For each of the signed integer types, there is a corresponding (but\n  different) unsigned integer type (designated with the keyword\n  unsigned)  that uses the same amount of storage (including sign\n  information) and has the same alignment requirements.  The range of\n  nonnegative values of a signed integer type is a subrange of the\n  corresponding unsigned integer type, and the representation of the\n  same value in each type is the same.</p>\n</blockquote>\n<p>C89 says nothing about only having one sign bit or only allowing twos-complement/ones-complement/sign-magnitude.</p>\n<p>The C++98 standard adopted this language nearly verbatim (section 3.9.1 paragraph (3)):</p>\n<blockquote>\n<p id=\"so_13150449_13150449_1\">For each of the signed integer types, there exists a corresponding\n  (but different) <em>unsigned integer type</em>: \"<code>unsigned char</code>\", \"<code>unsigned\n  short int</code>\", \"<code>unsigned int</code>\", and \"<code>unsigned long int</code>\", each of\n  which occupies the same amount of storage and has the same alignment\n  requirements (3.9) as the corresponding signed integer type ; that\n  is, each <em>signed integer</em> type has the same object representation as\n  its corresponding <em>unsigned integer</em> type. The range of nonnegative\n  values of a signed integer type is a subrange of the corresponding\n  unsigned integer type, and the value representation of each\n  corresponding signed/unsigned type shall be the same.</p>\n</blockquote>\n<p>The C++03 standard uses essentially identical language, as does C++11.</p>\n<p>No standard C++ spec constrains its signed integer representations to any C spec, as far as I can tell.  And there is nothing mandating a single sign bit or anything of the kind.  All it says is that <em>non-negative</em> signed integers must be a subrange of the corresponding unsigned.</p>\n<p>So, again I claim that INT_MAX=32767 with INT_MIN=-2<sup>32</sup>+32768 is permitted.  If your answer assumes otherwise, it is incorrect unless you cite a <strong>C++</strong> standard proving me wrong.</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "768469", "AnswerCount": "8"}, "13213471": {"ParentId": "13150449", "CommentCount": "10", "Body": "<p>This is perfectly standard-compliant and will compile to no-op on MSVC/gcc.</p>\n<pre><code>int unsigned_to_signed(unsigned int n)\n{\n    union UltimateCast\n    {\n        unsigned int In;\n        int Out;\n    } cast;\n\n    cast.In = n;\n\n    return cast.Out;\n}\n</code></pre>\n<p>For the calling code like:</p>\n<pre><code>volatile unsigned int i = 32167;\n\nint main()\n{\n    return unsigned_to_signed( i );\n}\n</code></pre>\n<p>We will have this assembly output (g++ -O3 -S): </p>\n<pre><code>__Z18unsigned_to_signedj:\n    movl    4(%esp), %eax\n    ret\n_main:\n    pushl   %ebp\n    movl    %esp, %ebp\n    andl    $-16, %esp\n    call    ___main\n    movl    _i, %eax\n    leave\n    ret\n    .globl  _i\n    .data\n    .align 4\n_i:\n    .long   32167\n</code></pre>\n<p>And declaring <code>unsigned_to_signed()</code> as <code>inline</code> yields:</p>\n<pre><code>_main:\n    pushl   %ebp\n    movl    %esp, %ebp\n    andl    $-16, %esp\n    call    ___main\n    movl    _i, %eax\n    leave\n    ret\n    .globl  _i\n    .data\n    .align 4\n_i:\n    .long   32167\n</code></pre>\n<p>Which is pretty neat code.</p>\n", "OwnerUserId": "1065190", "PostTypeId": "2", "Id": "13213471", "Score": "-4", "CreationDate": "2012-11-03T21:03:40.940", "LastActivityDate": "2012-11-03T21:03:40.940"}, "13208789": {"ParentId": "13150449", "PostTypeId": "2", "CommentCount": "19", "Body": "<p>Expanding on user71404's answer:</p>\n<pre><code>int f(unsigned x)\n{\n    if (x &lt;= INT_MAX)\n        return static_cast&lt;int&gt;(x);\n\n    if (x &gt;= INT_MIN)\n        return static_cast&lt;int&gt;(x - INT_MIN) + INT_MIN;\n\n    throw x; // Or whatever else you like\n}\n</code></pre>\n<p>If <code>x &gt;= INT_MIN</code> (keep the promotion rules in mind, <code>INT_MIN</code> gets converted to <code>unsigned</code>), then <code>x - INT_MIN &lt;= INT_MAX</code>, so this won't have any overflow.</p>\n<p>If that is not obvious, take a look at the claim \"If <code>x &gt;= -4u</code>, then <code>x + 4 &lt;= 3</code>.\", and keep in mind that <code>INT_MAX</code> will be equal to at least the mathematical value of -INT_MIN - 1.</p>\n<p>On the most common systems, where <code>!(x &lt;= INT_MAX)</code> implies <code>x &gt;= INT_MIN</code>, the optimizer should be able (and on my system, is able) to remove the second check, determine that the two <code>return</code> statements can be compiled to the same code, and remove the first check too. Generated assembly listing:</p>\n<pre><code>__Z1fj:\nLFB6:\n    .cfi_startproc\n    movl    4(%esp), %eax\n    ret\n    .cfi_endproc\n</code></pre>\n<p>The hypothetical implementation in your question:</p>\n<ul>\n<li>INT_MAX equals 32767</li>\n<li>INT_MIN equals -2<sup>32</sup> + 32768</li>\n</ul>\n<p>is not possible, so does not need special consideration. <code>INT_MIN</code> will be equal to either <code>-INT_MAX</code>, or to <code>-INT_MAX - 1</code>. This follows from C's representation of integer types (6.2.6.2), which requires <code>n</code> bits to be value bits, one bit to be a sign bit, and only allows one single trap representation (not including representations that are invalid because of padding bits), namely the one that would otherwise represent negative zero / <code>-INT_MAX - 1</code>. C++ doesn't allow any integer representations beyond what C allows.</p>\n<p><em><strong>Update</strong></em></p>: Microsoft's compiler apparently does not notice that <code>x &gt; 10</code> and <code>x &gt;= 11</code> test the same thing. It only generates the desired code if <code>x &gt;= INT_MIN</code> is replaced with <code>x &gt; INT_MIN - 1u</code>, which it can detect as the negation of <code>x &lt;= INT_MAX</code> (on this platform).\n<p>[Update from questioner (Nemo), elaborating on our discussion below]</p>\n<p>I now believe this answer works in all cases, but for complicated reasons.  I am likely to award the bounty to this solution, but I want to capture all the gory details in case anybody cares.</p>\n<p>Let's start with C++11, section 18.3.3:</p>\n<blockquote>\n<p id=\"so_13150449_13208789_0\">Table 31 describes the header <code>&lt;climits&gt;</code>.</p>\n<p id=\"so_13150449_13208789_1\">...</p>\n<p id=\"so_13150449_13208789_2\">The contents are the same as the Standard C library header <code>&lt;limits.h&gt;</code>.</p>\n</blockquote>\n<p>Here, \"Standard C\" means C99, whose specification severely constrains the representation of signed integers.  They are just like unsigned integers, but with one bit dedicated to \"sign\" and zero or more bits dedicated to \"padding\".  The padding bits do not contribute to the value of the integer, and the sign bit contributes only as twos-complement, ones-complement, or sign-magnitude.</p>\n<p>Since C++11 inherits the <code>&lt;climits&gt;</code> macros from C99, INT_MIN is either -INT_MAX or -INT_MAX-1, and hvd's code is guaranteed to work.  (Note that, due to the padding, INT_MAX could be much less than UINT_MAX/2...  But thanks to the way signed-&gt;unsigned casts work, this answer handles that fine.)</p>\n<p>C++03/C++98 is trickier.  It uses the same wording to inherit <code>&lt;climits&gt;</code> from \"Standard C\", but now \"Standard C\" means C89/C90.</p>\n<p>All of these -- C++98, C++03, C89/C90 -- have the wording I give in my question, but also include this (C++03 section 3.9.1 paragraph 7):</p>\n<blockquote>\n<p id=\"so_13150449_13208789_3\">The representations of integral types shall define values by use of a\n  pure binary numeration system.(44) [<em>Example</em>: this International\n  Standard permits 2\u2019s complement, 1\u2019s complement and signed magnitude\n  representations for integral types.]</p>\n</blockquote>\n<p>Footnote (44) defines \"pure binary numeration system\":</p>\n<blockquote>\n<p id=\"so_13150449_13208789_4\">A positional representation for integers that uses the binary digits 0\n  and 1, in which the values represented by successive bits are\n  additive, begin with 1, and are multiplied by successive integral\n  power of 2, except perhaps for the bit with the highest position.</p>\n</blockquote>\n<p>What is interesting about this wording is that it contradicts itself, because the definition of \"pure binary numeration system\" does not permit a sign/magnitude representation!  It does allow the high bit to have, say, the value -2<sup>n-1</sup> (twos complement) or -(2<sup>n-1</sup>-1) (ones complement).  But there is no value for the high bit that results in sign/magnitude.</p>\n<p>Anyway, my \"hypothetical implementation\" does not qualify as \"pure binary\" under this definition, so it is ruled out.</p>\n<p>However, the fact that the high bit is special means we can imagine it contributing any value at all: A small positive value, huge positive value, small negative value, or huge negative value.  (If the sign bit can contribute -(2<sup>n-1</sup>-1), why not -(2<sup>n-1</sup>-2)?  etc.)</p>\n<p>So, let's imagine a signed integer representation that assigns a wacky value to the \"sign\" bit.  </p>\n<p>A small positive value for the sign bit would result in a positive range for <code>int</code> (possibly as large as <code>unsigned</code>), and hvd's code handles that just fine.</p>\n<p>A huge positive value for the sign bit would result in <code>int</code> having a maximum larger than <code>unsigned</code>, which is is forbidden.</p>\n<p>A huge negative value for the sign bit would result in <code>int</code> representing a non-contiguous range of values, and other wording in the spec rules that out.</p>\n<p>Finally, how about a sign bit that contributes a small negative quantity?  Could we have a 1 in the \"sign bit\" contribute, say, -37 to the value of the int?  So then INT_MAX would be (say) 2<sup>31</sup>-1 and INT_MIN would be -37?</p>\n<p>This would result in some numbers having two representations...  But ones-complement gives two representations to zero, and that is allowed according to the \"Example\".  Nowhere does the spec say that zero is the <em>only</em> integer that might have two representations.  So I think this new hypothetical is allowed by the spec.</p>\n<p>Indeed, any negative value from -1 down to <code>-INT_MAX-1</code> appears to be permissible as a value for the \"sign bit\", but nothing smaller (lest the range be non-contiguous).  In other words, <code>INT_MIN</code> might be anything from <code>-INT_MAX-1</code> to -1.</p>\n<p>Now, guess what?  For the second cast in hvd's code to avoid implementation-defined behavior, we just need <code>x - (unsigned)INT_MIN</code> less than or equal to <code>INT_MAX</code>.  We just showed <code>INT_MIN</code> is at least <code>-INT_MAX-1</code>.  Obviously, <code>x</code> is at most <code>UINT_MAX</code>.  Casting a negative number to unsigned is the same as adding <code>UINT_MAX+1</code>.  Put it all together:</p>\n<pre><code>x - (unsigned)INT_MIN &lt;= INT_MAX\n</code></pre>\n<p>if and only if</p>\n<pre><code>UINT_MAX - (INT_MIN + UINT_MAX + 1) &lt;= INT_MAX\n-INT_MIN-1 &lt;= INT_MAX\n-INT_MIN &lt;= INT_MAX+1\nINT_MIN &gt;= -INT_MAX-1\n</code></pre>\n<p>That last is what we just showed, so even in this perverse case, the code actually works.</p>\n<p>That exhausts all of the possibilities, thus ending this extremely academic exercise.</p>\n<p>Bottom line:  There is some seriously under-specified behavior for signed integers in C89/C90 that got inherited by C++98/C++03.  It is fixed in C99, and C++11 indirectly inherits the fix by incorporating <code>&lt;limits.h&gt;</code> from C99.  But even C++11 retains the self-contradictory \"pure binary representation\" wording...</p>\n", "OwnerUserId": "743382", "LastEditorUserId": "768469", "LastEditDate": "2012-11-04T00:27:09.377", "Id": "13208789", "Score": "56", "CreationDate": "2012-11-03T11:39:30.497", "LastActivityDate": "2012-11-04T00:27:09.377"}, "13150839": {"ParentId": "13150449", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>If <code>x</code> is our input...</p>\n<p>If <code>x &gt; INT_MAX</code>, we want to find a constant <code>k</code> such that <code>0</code> &lt; <code>x - k*INT_MAX</code> &lt; <code>INT_MAX</code>.</p>\n<p>This is easy -- <code>unsigned int k = x / INT_MAX;</code>.  Then, let <code>unsigned int x2 = x - k*INT_MAX;</code></p>\n<p>We can now cast <code>x2</code> to <code>int</code> safely.  Let <code>int x3 = static_cast&lt;int&gt;(x2);</code></p>\n<p>We now want to subtract something like <code>UINT_MAX - k * INT_MAX + 1</code> from <code>x3</code>, if <code>k &gt; 0</code>.</p>\n<p>Now, on a 2s complement system, so long as <code>x &gt; INT_MAX</code>, this works out to:</p>\n<pre><code>unsigned int k = x / INT_MAX;\nx -= k*INT_MAX;\nint r = int(x);\nr += k*INT_MAX;\nr -= UINT_MAX+1;\n</code></pre>\n<p>Note that <code>UINT_MAX+1</code> is zero in C++ guaranteed, the conversion to int was a noop, and we subtracted <code>k*INT_MAX</code> then added it back on \"the same value\".  So an acceptable optimizer should be able to erase all that tomfoolery!</p>\n<p>That leaves the problem of <code>x &gt; INT_MAX</code> or not.  Well, we create 2 branches, one with <code>x &gt; INT_MAX</code>, and one without.  The one without does a strait cast, which the compiler optimizes to a noop.  The one with ... does a noop after the optimizer is done.  The smart optimizer realizes both branches to the same thing, and drops the branch.</p>\n<p>Issues: if <code>UINT_MAX</code> is really large relative to <code>INT_MAX</code>, the above might not work.  I am assuming that <code>k*INT_MAX &lt;= UINT_MAX+1</code> implicitly.</p>\n<p>We could probably attack this with some enums like:</p>\n<pre><code>enum { divisor = UINT_MAX/INT_MAX, remainder = UINT_MAX-divisor*INT_MAX };\n</code></pre>\n<p>which work out to 2 and 1 on a 2s complement system I believe (are we guaranteed for that math to work?  That's tricky...), and do logic based on these that easily optimize away on non-2s complement systems...</p>\n<p>This also opens up the exception case.  It is only possible if UINT_MAX is much larger than (INT_MIN-INT_MAX), so you can put your exception code in an if block asking exactly that question somehow, and it won't slow you down on a traditional system.</p>\n<p>I'm not exactly sure how to construct those compile-time constants to deal correctly with that.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2016-05-09T20:12:04.020", "Id": "13150839", "Score": "2", "CreationDate": "2012-10-31T03:26:47.383", "LastActivityDate": "2016-05-09T20:12:04.020"}, "13207021": {"ParentId": "13150449", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can explicitly tell the compiler what you want to do:</p>\n<pre><code>int unsigned_to_signed(unsigned n) {\n  if (n &gt; INT_MAX) {\n    if (n &lt;= UINT_MAX + INT_MIN) {\n      throw \"no result\";\n    }\n    return static_cast&lt;int&gt;(n + INT_MIN) - (UINT_MAX + INT_MIN + 1);\n  } else {\n    return static_cast&lt;int&gt;(n);\n  }\n}\n</code></pre>\n<p>Compiles with <code>gcc 4.7.2</code> for <code>x86_64-linux</code> (<code>g++ -O -S test.cpp</code>) to </p>\n<pre><code>_Z18unsigned_to_signedj:\n    movl    %edi, %eax\n    ret\n</code></pre>\n", "OwnerUserId": "1621532", "LastEditorUserId": "1508522", "LastEditDate": "2012-11-03T07:57:36.730", "Id": "13207021", "Score": "2", "CreationDate": "2012-11-03T07:29:21.637", "LastActivityDate": "2012-11-03T07:57:36.730"}, "13243143": {"ParentId": "13150449", "CommentCount": "0", "Body": "<p>I think the int type is at least two bytes, so the INT_MIN and INT_MAX may change in different platforms.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/types\" rel=\"nofollow\">Fundamental types</a></p>\n<p><a href=\"http://www.cplusplus.com/reference/clibrary/climits/\" rel=\"nofollow\">\u2264climits\u2265 header</a></p>\n", "OwnerUserId": "679937", "PostTypeId": "2", "Id": "13243143", "Score": "1", "CreationDate": "2012-11-06T01:33:52.110", "LastActivityDate": "2012-11-06T01:33:52.110"}, "13211708": {"ParentId": "13150449", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This code relies only on behavior, mandated by the spec, so requirement (a) is easily satisfied:</p>\n<pre><code>int unsigned_to_signed(unsigned n)\n{\n  int result = INT_MAX;\n\n  if (n &gt; INT_MAX &amp;&amp; n &lt; INT_MIN)\n    throw runtime_error(\"no signed int for this number\");\n\n  for (unsigned i = INT_MAX; i != n; --i)\n    --result;\n\n  return result;\n}\n</code></pre>\n<p>It's not so easy with requirement (b). This compiles into a no-op with gcc 4.6.3 (-Os, -O2, -O3) and with clang 3.0 (-Os, -O, -O2, -O3). Intel 12.1.0 refuses to optimize this. And I have no info about Visual C.</p>\n", "OwnerUserId": "1009831", "LastEditorUserId": "1009831", "LastEditDate": "2012-11-03T17:58:09.427", "Id": "13211708", "Score": "16", "CreationDate": "2012-11-03T17:34:40.287", "LastActivityDate": "2012-11-03T17:58:09.427"}, "13150866": {"ParentId": "13150449", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>std::numeric_limits&lt;int&gt;::is_modulo</code> is a compile time constant. so you can use it for template specialization. problem solved, at least if compiler plays along with inlining.</p>\n<pre><code>#include &lt;limits&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n\n#ifdef TESTING_SF\n    bool const testing_sf = true;\n#else\n    bool const testing_sf = false;\n#endif\n\n// C++ \"extensions\"\nnamespace cppx {\n    using std::runtime_error;\n    using std::string;\n\n    inline bool hopefully( bool const c ) { return c; }\n    inline bool throw_x( string const&amp; s ) { throw runtime_error( s ); }\n\n}  // namespace cppx\n\n// C++ \"portability perversions\"\nnamespace cppp {\n    using cppx::hopefully;\n    using cppx::throw_x;\n    using std::numeric_limits;\n\n    namespace detail {\n        template&lt; bool isTwosComplement &gt;\n        int signed_from( unsigned const n )\n        {\n            if( n &lt;= unsigned( numeric_limits&lt;int&gt;::max() ) )\n            {\n                return static_cast&lt;int&gt;( n );\n            }\n\n            unsigned const u_max = unsigned( -1 );\n            unsigned const u_half = u_max/2 + 1;\n\n            if( n == u_half )\n            {\n                throw_x( \"signed_from: unsupported value (negative max)\" );\n            }\n\n            int const i_quarter = static_cast&lt;int&gt;( u_half/2 );\n            int const int_n1 = static_cast&lt;int&gt;( n - u_half );\n            int const int_n2 = int_n1 - i_quarter;\n            int const int_n3 = int_n2 - i_quarter;\n\n            hopefully( n == static_cast&lt;unsigned&gt;( int_n3 ) )\n                || throw_x( \"signed_from: range error\" );\n\n            return int_n3;\n        }\n\n        template&lt;&gt;\n        inline int signed_from&lt;true&gt;( unsigned const n )\n        {\n            return static_cast&lt;int&gt;( n );\n        }\n    }    // namespace detail\n\n    inline int signed_from( unsigned const n )\n    {\n        bool const is_modulo = numeric_limits&lt; int &gt;::is_modulo;\n        return detail::signed_from&lt; is_modulo &amp;&amp; !testing_sf &gt;( n );\n    }\n}    // namespace cppp\n\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int const x = cppp::signed_from( -42u );\n    wcout &lt;&lt; x &lt;&lt; endl;\n}\n</code></pre>\n<p><hr>\n<strong>EDIT</strong>: Fixed up code to avoid possible trap on non-modular-int machines (only one is known to exist, namely the archaically configured versions of the Unisys Clearpath). For simplicity this is done by not supporting the value -2<sup><i>n</i>-1</sup> where <i>n</i> is the number of <code>int</code> value bits, on such machine (i.e., on the Clearpath). in practice this value will not be supported by the machine either (i.e., with sign-and-magnitude or 1\u2019s complement representation).</hr></p>\n", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2012-10-31T05:16:34.090", "Id": "13150866", "Score": "1", "CreationDate": "2012-10-31T03:30:08.230", "LastActivityDate": "2012-10-31T05:16:34.090"}, "43724313": {"ParentId": "13150449", "CommentCount": "1", "Body": "<p>My money is on using memcpy. Any decent compiler knows to optimise it away:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;memory.h&gt;\n#include &lt;limits.h&gt;\n\nstatic inline int unsigned_to_signed(unsigned n)\n{\n    int result;\n    memcpy( &amp;result, &amp;n, sizeof(result));\n    return result;\n}\n\nint main(int argc, const char * argv[])\n{\n    unsigned int x = UINT_MAX - 1;\n    int xx = unsigned_to_signed(x);\n    return xx;\n}\n</code></pre>\n<p>For me (Xcode 8.3.2, Apple LLVM 8.1, -O3), that produces:</p>\n<pre><code>_main:                                  ## @main\nLfunc_begin0:\n    .loc    1 21 0                  ## /Users/Someone/main.c:21:0\n    .cfi_startproc\n## BB#0:\n    pushq    %rbp\nLtmp0:\n    .cfi_def_cfa_offset 16\nLtmp1:\n    .cfi_offset %rbp, -16\n    movq    %rsp, %rbp\nLtmp2:\n    .cfi_def_cfa_register %rbp\n    ##DEBUG_VALUE: main:argc &lt;- %EDI\n    ##DEBUG_VALUE: main:argv &lt;- %RSI\nLtmp3:\n    ##DEBUG_VALUE: main:x &lt;- 2147483646\n    ##DEBUG_VALUE: main:xx &lt;- 2147483646\n    .loc    1 24 5 prologue_end     ## /Users/Someone/main.c:24:5\n    movl    $-2, %eax\n    popq    %rbp\n    retq\nLtmp4:\nLfunc_end0:\n    .cfi_endproc\n</code></pre>\n", "OwnerUserId": "7948481", "PostTypeId": "2", "Id": "43724313", "Score": "1", "CreationDate": "2017-05-01T18:26:41.840", "LastActivityDate": "2017-05-01T18:26:41.840"}, "bq_ids": {"n4140": {"so_13150449_13150449_0": {"section_id": 7212, "quality": 0.7209302325581395, "length": 31}, "so_13150449_13208789_4": {"section_id": 7216, "quality": 1.0, "length": 21}, "so_13150449_13208789_2": {"section_id": 6793, "quality": 0.7142857142857143, "length": 5}, "so_13150449_13150449_1": {"section_id": 7212, "quality": 0.9393939393939394, "length": 62}, "so_13150449_13208789_3": {"section_id": 7216, "quality": 0.8181818181818182, "length": 18}}, "n3337": {"so_13150449_13150449_0": {"section_id": 6956, "quality": 0.7209302325581395, "length": 31}, "so_13150449_13208789_4": {"section_id": 6960, "quality": 1.0, "length": 21}, "so_13150449_13208789_2": {"section_id": 6548, "quality": 0.7142857142857143, "length": 5}, "so_13150449_13150449_1": {"section_id": 6956, "quality": 0.9393939393939394, "length": 62}, "so_13150449_13208789_3": {"section_id": 6960, "quality": 0.8181818181818182, "length": 18}}, "n4659": {"so_13150449_13208789_3": {"section_id": 8725, "quality": 0.8181818181818182, "length": 18}, "so_13150449_13208789_4": {"section_id": 8725, "quality": 1.0, "length": 21}, "so_13150449_13208789_2": {"section_id": 2156, "quality": 0.5714285714285714, "length": 4}, "so_13150449_13150449_1": {"section_id": 8721, "quality": 0.9696969696969697, "length": 64}, "so_13150449_13150449_0": {"section_id": 8721, "quality": 0.7906976744186046, "length": 34}}}});