post_cb({"17070269": {"ParentId": "17069315", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Internally there is an entity that is the <em>null pointer constant type</em>.  It is one of the fundamental types.</p>\n<p>The keyword, literal and expression <code>nullptr</code> has this type.  <code>decltype(nullptr)</code> refers to this type.</p>\n<p>However the <em>name</em> <code>std::nullptr_t</code> is not a keyword (not even a context-sensitive one), and so the name does not exist until declared.  If you refer to the name <code>std::nullptr_t</code> without declaring it, it is an error, as for any undeclared name.</p>\n<p>So although the <em>type</em> exists at the start of translation like any fundamental type, the <em>name</em> does not exist.</p>\n<p>In fact there are other fundamental types that do not have a \"single spelling\", such as short int.  A short int can be refered to as <code>short</code>, <code>short int</code>, <code>signed short int</code>, <code>signed short</code>, or any permutation thereof.</p>\n<p>It is also not dissimilar to the relationship between the <code>typeid</code> operator (keyword), and the type of the <code>typeid(...)</code> expression, <code>std::typeinfo</code>.  <code>typeinfo</code> is also not a keyword and the name does not exist before being declared.</p>\n<p>Basically, you are conflating an <em>entity</em> (the null pointer constant type) with a <em>name</em> (<code>std::nullptr_t</code>)</p>\n<p>If you ask why didn't the language designers specify <code>nullptr_t</code> and <code>typeinfo</code> as keywords, I would speculate that they are not common enough to risk a name collision with a user-defined name with the same spelling.  Recall that such a collision would occur in any and all scopes.</p>\n", "OwnerUserId": "1131467", "LastEditorUserId": "1131467", "LastEditDate": "2013-06-12T16:32:00.467", "Id": "17070269", "Score": "3", "CreationDate": "2013-06-12T16:06:11.040", "LastActivityDate": "2013-06-12T16:32:00.467"}, "17069315": {"CommentCount": "0", "AcceptedAnswerId": "17070269", "PostTypeId": "1", "LastEditorUserId": "1932150", "CreationDate": "2013-06-12T15:23:22.927", "LastActivityDate": "2013-06-12T17:12:11.190", "LastEditDate": "2013-06-12T15:30:19.547", "ViewCount": "2044", "FavoriteCount": "1", "Title": "What is the type of nullptr?", "Id": "17069315", "Score": "5", "Body": "<p>The Standard states, that <code>nullptr</code> is a pointer literal of type <code>std::nullptr_t</code> (2.14.7). And 18.2p9 defines <code>nullptr_t</code> by</p>\n<pre><code>namespace std {\n  typedef decltype(nullptr) nullptr_t;\n}\n</code></pre>\n<p>By 7.1.6.2p4 <code>decltype(nullptr)</code> is the type of the expression <code>nullptr</code>, which is by definition <code>std::nullptr_t</code> (since the expression <code>nullptr</code> is a prvalue). Substituting that into the definition of <code>nullptr_t</code> results in</p>\n<pre><code>typedef nullptr_t nullptr_t\n</code></pre>\n<p>On the other hand a typedef specifier does not introduce a new type, it's just a name for another existing type. So, what is exactly <code>nullptr_t</code>? I'm not able to comprehend these definitions.</p>\n", "Tags": "<c++><c++11><types><nullptr>", "OwnerUserId": "1770418", "AnswerCount": "2"}, "17069469": {"ParentId": "17069315", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>It is implementation-specific. What is important is that (p. 18.2/9 of the C++11 Standard):</p>\n<blockquote>\n<p id=\"so_17069315_17069469_0\">[...] The type for which <code>nullptr_t</code> is a synonym has the characteristics described in 3.9.1 and 4.10. [...]</p>\n</blockquote>\n<p>As long as it behaves like the Standard specifies in those two paragraphs, it can be anything. </p>\n<p>I believe the logical fallacy in your argument is that this:</p>\n<blockquote>\n<p id=\"so_17069315_17069469_1\">By 7.1.6.2p4 <code>decltype(nullptr)</code> is the type of the expression <code>nullptr</code>, which is by definition <code>std::nullptr_t</code> (since the expression <code>nullptr</code> is a prvalue)</p>\n</blockquote>\n<p>Does <strong>not</strong> mean that <code>nullptr_t</code> is <em>not</em> a type alias. For instance, if I define:</p>\n<pre><code>typedef decltype(42) foo;\n</code></pre>\n<p>I can say that the type of the expression:</p>\n<pre><code>42\n</code></pre>\n<p>Is <code>foo</code>. Yet, <code>foo</code> is just an alias for another type (<code>int</code>).</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-06-12T17:12:11.190", "Id": "17069469", "Score": "6", "CreationDate": "2013-06-12T15:30:13.577", "LastActivityDate": "2013-06-12T17:12:11.190"}, "bq_ids": {"n4140": {"so_17069315_17069469_0": {"section_id": 6711, "quality": 0.625, "length": 5}}, "n3337": {"so_17069315_17069469_0": {"section_id": 6466, "quality": 0.625, "length": 5}}, "n4659": {"so_17069315_17069469_0": {"section_id": 8179, "quality": 0.625, "length": 5}}}});