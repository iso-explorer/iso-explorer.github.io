post_cb({"4851838": {"Id": "4851838", "PostTypeId": "2", "Body": "<p>Enums are completely resolved at compile time (enum constants as integer literals, enum variables as integer variables), there's no speed penalty in using them.</p>\n<p>In general the average enumeration won't have an underlying type bigger than <code>int</code> (unless you put in it very big constants); in facts, at \u00a77.2 \u00b6 5 it's explicitly said:</p>\n<blockquote>\n<p id=\"so_4851810_4851838_0\">The underlying type of an enumeration is an integral type that can represent all the enumerator values defined in the enumeration. It is implementation-defined which integral type is used as the underlying type for an enumeration <strong><em>except that the underlying type shall not be larger than <code>int</code></em></strong> <em>unless the value of an enumerator cannot fit in an <code>int</code> or <code>unsigned int</code></em>.</p>\n</blockquote>\n<p>You should use enumerations when it's appropriate because they usually make the code easier to read and to maintain (have you ever tried to debug a program full of \"magic numbers\"? <code>:S</code>).</p>\n<p>As for your results: probably your test methodology doesn't take into account the normal speed fluctuations you get when you run code on \"normal\" machines<sup>1</sup>; have you tried running the test many (100+) times and calculating mean and standard deviation of your times? The results should be compatible: the difference between the means shouldn't be bigger than 1 or 2 times the RSS<sup>2</sup> of the two standard deviations (assuming, as usual, a Gaussian distribution for the fluctuations).</p>\n<p>Another check you could do is to compare the generated assembly code (with g++ you can get it with the <code>-S</code> switch).</p>\n<hr/>\n<ol><li>On \"normal\" PCs you have some indeterministic fluctuations because of other tasks running, cache/RAM/VM state, ...</li>\n<li>Root Sum Squared, the square root of the sum of the squared standard deviations.</li></ol>\n", "LastEditorUserId": "214671", "LastActivityDate": "2011-01-31T14:35:18.313", "Score": "78", "CreationDate": "2011-01-31T14:11:53.050", "ParentId": "4851810", "CommentCount": "11", "LastEditDate": "2011-01-31T14:35:18.313", "OwnerUserId": "214671"}, "4868540": {"Id": "4868540", "PostTypeId": "2", "Body": "<p>This is implementation dependent, and it is quite possible for enums and ints to have different performance and either the same or different assembly code, although it is probably a sign of a suboptimal compiler. some ways to get differences are:</p>\n<ul>\n<li>QVector may be specialized on your enum type to do something surprising.</li>\n<li>enum doesn't get compiled to int but to \"some integral type no larger than int\". QVector of int may be specialized differently from QVector of some_integral_type.</li>\n<li>even if QVector isn't specialized, the compiler may do a better job of aligning ints in memory than of aligning some_integral_type, leading to a greater cache miss rate when you loop over the vector of enums or of some_integral_type.</li>\n</ul>\n", "LastEditorUserId": "72312", "LastActivityDate": "2011-02-06T16:37:21.987", "Score": "2", "CreationDate": "2011-02-01T22:10:04.730", "ParentId": "4851810", "CommentCount": "0", "LastEditDate": "2011-02-06T16:37:21.987", "OwnerUserId": "599158"}, "4851954": {"Id": "4851954", "PostTypeId": "2", "Body": "<p>if you use Visual Studio for example you can create a simple project where you have </p>\n<pre><code>     a=Player::EMPTY;\n</code></pre>\n<p>and if you right click \"go to disassembly\" the code will be </p>\n<pre><code>mov         dword ptr [a],0\n</code></pre>\n<p>So the compiler replace the value of the enum, and normally it will not generate any overhead.</p>\n", "LastActivityDate": "2011-01-31T14:23:10.917", "Score": "3", "CreationDate": "2011-01-31T14:23:10.917", "ParentId": "4851810", "CommentCount": "0", "OwnerUserId": "587834"}, "bq_ids": {"n4140": {"so_4851810_4851838_0": {"length": 27, "quality": 0.84375, "section_id": 5466}}, "n3337": {"so_4851810_4851838_0": {"length": 28, "quality": 0.875, "section_id": 5252}}, "n4659": {"so_4851810_4851838_0": {"length": 27, "quality": 0.84375, "section_id": 6900}}}, "4851817": {"Id": "4851817", "PostTypeId": "2", "Body": "<p>Enums should be no slower.  They're implemented as integers.</p>\n", "LastActivityDate": "2011-01-31T14:09:47.437", "Score": "17", "CreationDate": "2011-01-31T14:09:47.437", "ParentId": "4851810", "CommentCount": "0", "OwnerUserId": "129570"}, "4853766": {"Id": "4853766", "PostTypeId": "2", "Body": "<p>The compiler should convert <code>enum</code> into integers. They get inlined at compile time, so once your program is compiled, it's supposed to be exactly the same as if you used the integers themselves.</p>\n<p>If your testing produces different results, there could be something going on with the test itself. Either that, or your compiler is behaving oddly.</p>\n", "LastActivityDate": "2011-01-31T17:08:17.047", "Score": "2", "CreationDate": "2011-01-31T17:08:17.047", "ParentId": "4851810", "CommentCount": "0", "OwnerUserId": "399649"}, "4854011": {"Id": "4854011", "PostTypeId": "2", "Body": "<p>Well, I did a few tests and there wasn't much difference between the integer and enum forms. I also added a char form which was consistently about 6% quicker (which isn't surprising as it is using less memory). Then I just used a char array rather than a vector and that was 300% faster! Since we've not been given what QVector is, it could be a wrapper for an array rather than the std::vector I've used.</p>\n<p>Here's the code I used, compiled using standard release options in Dev Studio 2005. Note that I've changed the timed loop a small amount as the code in the question could be optimised to nothing (you'd have to check the assembly code).</p>\n<pre><code>#include &lt;windows.h&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nenum Player\n{\n    EMPTY = 0,\n    BLACK = 1,\n    WHITE = 2\n};\n\n\ntemplate &lt;class T, T search&gt;\nLONGLONG TimeFunction ()\n{\n  vector &lt;T&gt;\n    vec;\n\n  vec.resize (10000000);\n\n  size_t\n    size = vec.size ();\n\n  for (size_t i = 0 ; i &lt; size ; ++i)\n  {\n      vec [i] = static_cast &lt;T&gt; (rand () % 3);\n  }\n\n  LARGE_INTEGER\n    start,\n    end;\n\n  QueryPerformanceCounter (&amp;start);\n\n  for (size_t i = 0 ; i &lt; size ; ++i)\n  {\n    if (vec [i] == search)\n    {\n      break;\n    }\n  }\n\n  QueryPerformanceCounter (&amp;end);\n\n  return end.QuadPart - start.QuadPart;\n}\n\nLONGLONG TimeArrayFunction ()\n{\n  size_t\n    size = 10000000;\n\n  char\n    *vec = new char [size];\n\n  for (size_t i = 0 ; i &lt; size ; ++i)\n  {\n      vec [i] = static_cast &lt;char&gt; (rand () % 3);\n  }\n\n  LARGE_INTEGER\n    start,\n    end;\n\n  QueryPerformanceCounter (&amp;start);\n\n  for (size_t i = 0 ; i &lt; size ; ++i)\n  {\n    if (vec [i] == 10)\n    {\n      break;\n    }\n  }\n\n  QueryPerformanceCounter (&amp;end);\n\n  delete [] vec;\n\n  return end.QuadPart - start.QuadPart;\n}\n\nint main ()\n{\n  cout &lt;&lt; \"   Char form = \" &lt;&lt; TimeFunction &lt;char, 10&gt; () &lt;&lt; endl;\n  cout &lt;&lt; \"Integer form = \" &lt;&lt; TimeFunction &lt;int, 10&gt; () &lt;&lt; endl;\n  cout &lt;&lt; \" Player form = \" &lt;&lt; TimeFunction &lt;Player, static_cast &lt;Player&gt; (10)&gt; () &lt;&lt; endl;\n  cout &lt;&lt; \"  Array form = \" &lt;&lt; TimeArrayFunction () &lt;&lt; endl;\n}\n</code></pre>\n", "LastActivityDate": "2011-01-31T17:31:28.183", "Score": "3", "CreationDate": "2011-01-31T17:31:28.183", "ParentId": "4851810", "CommentCount": "0", "OwnerUserId": "1898"}, "4851810": {"ViewCount": "5399", "Body": "<p>It's really a simple problem : </p>\n<p>I'm programming a Go program. Should I represent the board with a <code>QVector&lt;int&gt;</code> or a <code>QVector&lt;Player&gt;</code> where</p>\n<pre><code>enum Player\n{\n    EMPTY = 0,\n    BLACK = 1,\n    WHITE = 2\n};\n</code></pre>\n<p>I guess that of course, using Player instead of integers will be slower. But I wonder how much more, because I believe that using <code>enum</code> is better coding.</p>\n<p>I've done a few tests regarding assigning and comparing Players (as opposed to <code>int</code>)</p>\n<pre><code>QVector&lt;int&gt; vec;\nvec.resize(10000000);\nint size = vec.size();\n\n\nfor(int i =0; i&lt;size; ++i)\n{\n    vec[i] = 0;\n}\n\n\nfor(int i =0; i&lt;size; ++i)\n{\n    bool b = (vec[i] == 1);\n}\n\n\nQVector&lt;Player&gt; vec2;\nvec2.resize(10000000);\nint size = vec2.size();\n\n\nfor(int i =0; i&lt;size; ++i)\n{\n    vec2[i] = EMPTY;\n}\n\n\nfor(int i =0; i&lt;size; ++i)\n{\n    bool b = (vec2[i] == BLACK);\n}\n</code></pre>\n<p>Basically, it's only 10% slower. Is there anything else I should know before continuing?</p>\n<p>Thanks!</p>\n<p>Edit : The 10% difference is not a figment of my imagination, it seems to be specific to Qt and QVector. When I use std::vector, the speed is the same</p>\n", "AcceptedAnswerId": "4851838", "Title": "Are C++ enums slower to use than integers?", "CreationDate": "2011-01-31T14:08:36.373", "Id": "4851810", "CommentCount": "13", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-09-02T21:13:41.697", "LastEditorUserId": "596951", "LastActivityDate": "2015-09-02T21:13:41.697", "Score": "65", "OwnerUserId": "596951", "Tags": "<c++><enums><profiling><performance>", "AnswerCount": "7"}, "4851829": {"Id": "4851829", "PostTypeId": "2", "Body": "<p>In general, using an enum should make absolutely no difference to performance. How did you test this?</p>\n<p>I just ran tests myself. The differences are pure noise.</p>\n<p>Just now, I compiled both versions to assembler. Here's the main function from each:</p>\n<h2>int</h2>\n<pre><code>LFB1778:\n        pushl   %ebp\nLCFI11:\n        movl    %esp, %ebp\nLCFI12:\n        subl    $8, %esp\nLCFI13:\n        movl    $65535, %edx\n        movl    $1, %eax\n        call    __Z41__static_initialization_and_destruction_0ii\n        leave\n        ret\n</code></pre>\n<h2>Player</h2>\n<pre><code>LFB1774:\n        pushl   %ebp\nLCFI10:\n        movl    %esp, %ebp\nLCFI11:\n        subl    $8, %esp\nLCFI12:\n        movl    $65535, %edx\n        movl    $1, %eax\n        call    __Z41__static_initialization_and_destruction_0ii\n        leave\n        ret\n</code></pre>\n<p>It's hazardous to base any statement regarding performance on micro-benchmarks. There are too many extraneous factors skewing the data.</p>\n", "LastEditorUserId": "9990", "LastActivityDate": "2011-01-31T15:04:25.673", "Score": "43", "CreationDate": "2011-01-31T14:11:09.960", "ParentId": "4851810", "CommentCount": "5", "LastEditDate": "2011-01-31T15:04:25.673", "OwnerUserId": "9990"}});