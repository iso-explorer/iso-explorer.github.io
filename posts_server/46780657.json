post_cb({"46780860": {"ParentId": "46780657", "CommentCount": "6", "Body": "<p>The compilers are obeying the Standard. C++17 draft N4659 says ([dcl.constexpr]/(3.4.4)):</p>\n<blockquote>\n<p id=\"so_46780657_46780860_0\">The definition of a constexpr function shall satisfy the following requirements:</p>\n<ul>\n<li><p id=\"so_46780657_46780860_1\">...</p></li>\n<li><p id=\"so_46780657_46780860_2\">its <em>function-body</em> shall be <code>= delete</code>, <code>= default</code>, or a <em>compound-statement</em> that does not contain</p>\n<ul>\n<li><p id=\"so_46780657_46780860_3\">...</p></li>\n<li><p id=\"so_46780657_46780860_4\">a <em>try-block</em>, or</p></li>\n<li><p id=\"so_46780657_46780860_5\">...</p></li>\n</ul></li>\n</ul>\n</blockquote>\n<p>And none of the rules for \"discarded statements\" such as the <code>else</code> statement in your <code>S&lt;int&gt;::foo</code> override this rule.  The only special things specified about discarded statements are that discarded statements are not instantiated, odr-uses within discarded statements do not cause a definition for the used declaration to be required, and discarded <code>return</code> statements are ignored when determining the true return type of a function with placeholder return type.</p>\n<p>I did not see any existing C++ Issue discussing this, and the paper P0292R1 which proposed <code>if constexpr</code> does not address interactions with constexpr functions.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "46780860", "Score": "11", "CreationDate": "2017-10-17T00:40:54.433", "LastActivityDate": "2017-10-17T00:40:54.433"}, "46780657": {"CommentCount": "1", "ViewCount": "162", "PostTypeId": "1", "LastEditorUserId": "1424877", "CreationDate": "2017-10-17T00:07:08.000", "LastActivityDate": "2017-10-17T00:49:57.790", "Title": "\"if constexpr\" interaction with \"try in constexpr function\" warning", "FavoriteCount": "0", "LastEditDate": "2017-10-17T00:49:57.790", "Id": "46780657", "Score": "7", "Body": "<p>I claim that <a href=\"https://wandbox.org/permlink/T8hOsaV95CPUPNK4\" rel=\"noreferrer\">this program</a> ought to be well-formed: it declares a constexpr member function of <code>S&lt;int&gt;</code>. However, both GCC and Clang reject this program.</p>\n<pre><code>template&lt;class T&gt;\nstruct S {\n    constexpr int foo() {\n        if constexpr (std::is_same_v&lt;T, int&gt;) {\n            return 0;\n        } else {\n            try {} catch (...) {}\n            return 1;\n        }\n    }\n};\n\nint main()\n{\n    S&lt;int&gt; s;\n    return s.foo();  // expect \"return 0\"\n}\n</code></pre>\n<p>GCC says:</p>\n<blockquote>\n<p id=\"so_46780657_46780657_0\">error: 'try' in 'constexpr' function</p>\n</blockquote>\n<p>Clang says:</p>\n<blockquote>\n<p id=\"so_46780657_46780657_1\">error: statement not allowed in constexpr function</p>\n</blockquote>\n<p>Neither of them seem to notice that the \"try\" statement is located in a discarded branch of the <code>if constexpr</code> statement.</p>\n<p>If I factor the <code>try</code>/<code>catch</code> out into a <em>non-constexpr</em> member function <code>void trycatch()</code>, then both Clang and GCC are happy with the code again, even though its behavior ought to be equivalent to the unhappy version.</p>\n<pre><code>template&lt;class T&gt;\nstruct S {\n    void trycatch() {\n        try {} catch (...) {}\n    }\n    constexpr int foo() {\n        if constexpr (std::is_same_v&lt;T, int&gt;) {\n            return 0;\n        } else {\n            trycatch();  // This is fine.\n            return 1;\n        }\n    }\n};\n</code></pre>\n<p>Is this</p>\n<ul>\n<li>a bug in both GCC and Clang?</li>\n<li>a defect in the Standard, which GCC and Clang are faithfully implementing?</li>\n<li>a Quality of Implementation issue due to the <a href=\"https://stackoverflow.com/questions/41517603/conditionally-constexpr-member-function\">\"conditional constexprness\"</a> of <code>foo()</code>?</li>\n</ul>\n<p>(Irrelevant background: I'm implementing constexpr <code>any::emplace&lt;T&gt;()</code> for an allocator-aware version of <code>any</code> whose allocator might be constexpr-per-<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0639r0.html\" rel=\"noreferrer\">P0639</a> (i.e. it might lack a <code>deallocate</code> member function) or might not. In the former case we don't want or need the <code>try</code>; in the latter case we need the <code>try</code> in order to call <code>deallocate</code> if the constructor of <code>T</code> throws.)</p>\n", "Tags": "<c++><c++1z><template-meta-programming><if-constexpr>", "OwnerUserId": "1424877", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46780657_46780860_2": {"section_id": 5419, "quality": 1.0, "length": 7}, "so_46780657_46780860_0": {"section_id": 5419, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_46780657_46780860_2": {"section_id": 5214, "quality": 0.7142857142857143, "length": 5}, "so_46780657_46780860_0": {"section_id": 5214, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_46780657_46780657_1": {"section_id": 180, "quality": 0.8, "length": 4}, "so_46780657_46780860_2": {"section_id": 6841, "quality": 1.0, "length": 7}, "so_46780657_46780860_0": {"section_id": 6841, "quality": 0.8571428571428571, "length": 6}}}});