post_cb({"8867469": {"CommentCount": "0", "CreationDate": "2012-01-15T04:11:59.450", "PostTypeId": "1", "AcceptedAnswerId": "8867477", "LastEditorUserId": "500104", "LastActivityDate": "2012-01-15T11:27:58.080", "LastEditDate": "2012-01-15T06:51:28.503", "ViewCount": "6856", "FavoriteCount": "2", "Title": "Do derived classes indirectly inherit base's assignment operator?", "Id": "8867469", "Score": "3", "Body": "<p>I'm trying to understand this behaviour but it seems I don't. Please see this code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Base\n{\npublic:\n    void operator=(const Base&amp; rf)\n    {\n        cout &lt;&lt; \"base operator=\" &lt;&lt; endl;\n        this-&gt;y = rf.y;\n    }\n    int y;\n    Base() : y(100) { }\n};\n\nclass Derived : public Base\n{\npublic:\n    int x;\n    Derived() : x(100) { }\n};\n\nint main()\n{\n    Derived test;\n    Derived test2;\n    test2.x = 0;\n    test2.y = 0;\n    test.operator=(test2); // operator auto-generated for derived class but...\n    cout &lt;&lt; test.x &lt;&lt; endl &lt;&lt; test.y &lt;&lt; endl;\n    cin.ignore();\n    return 0;\n}\n</code></pre>\n<p>PROGRAM OUTPUT:</p>\n<pre><code>&gt; base operator=\n&gt;  0\n&gt;  0\n</code></pre>\n<p>Now where I'm confused is:\nThe rule says that a derived class never inherits the assigment operator, instead it creates its own <code>operator=</code> however in this example base's <code>operator=</code> gets invoked on the derived class.</p>\n<p>Second I was able to explicitly invoke an assigment operator on a derived class, which isn't in turn explicitly defined in the derived class.</p>\n<p>Now if I understand it correctly, this means that any user defined base's operator always gets invoked on the derived class?</p>\n", "Tags": "<c++><inheritance><assignment-operator>", "OwnerUserId": "1044776", "AnswerCount": "4"}, "8867477": {"ParentId": "8867469", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The generated ones automatically <em>call</em> the base-class assignment operator.</p>\n<pre><code>// generated version looks basically like this\nDerived&amp; operator=(Derived const&amp; other){\n  Base::operator=(static_cast&lt;Base const&amp;&gt;(other));\n  x = other.x;\n  return *this;\n}\n</code></pre>\n<p>The cast is there to avoid an accidential call to a templated <code>Base::operator=</code> like this one:</p>\n<pre><code>template&lt;class Other&gt;\nBase&amp; operator=(Other const&amp; other); // accepts everything\n</code></pre>\n<p>Or a strange one like this:</p>\n<pre><code>// forward-declare 'Derived' outside of 'Base'\nBase&amp; operator=(Derived const&amp; other); // accepts derived class (for whatever reason)\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_8867469_8867477_0\">Second I was able to explicitly invoke an assigment operator on a derived class, which isn't in turn explicitly defined in the derived class.</p>\n</blockquote>\n<p>The compiler automatically <em>declares</em> an assignment operator if you do not and your class allows it (i.e., no reference members and some other arcane rules) and additionally <em>defines</em> it if you actually use it somewhere.</p>\n</hr>", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2012-01-15T04:28:19.210", "Id": "8867477", "Score": "12", "CreationDate": "2012-01-15T04:13:36.623", "LastActivityDate": "2012-01-15T04:28:19.210"}, "8867487": {"ParentId": "8867469", "CommentCount": "1", "Body": "<p>That's because the implicitly defined operator = calls the base classes operator =. See the FAQ lite:</p>\n<p><a href=\"http://www.parashift.com/c++-faq-lite/assignment-operators.html#faq-12.4\" rel=\"nofollow\">I'm creating a derived class; should my assignment operator call my base class's assignment operator?</a></p>\n<blockquote>\n<p id=\"so_8867469_8867487_0\">Yes (if you need to define an assignment operator in the first place).</p>\n<p id=\"so_8867469_8867487_1\">If you define your own assignment operator, the compiler will not automatically call your base class's assignment operator for you. Unless your base class's assignment operator itself is broken, you should call it explicitly from your derived class's assignment operator (again, assuming you create one in the first place).</p>\n<p id=\"so_8867469_8867487_2\">However if you do not create your own assignment operator, the one that the compiler creates for you will automatically call your base class's assignment operator.</p>\n</blockquote>\n", "OwnerUserId": "1021915", "PostTypeId": "2", "Id": "8867487", "Score": "2", "CreationDate": "2012-01-15T04:15:36.660", "LastActivityDate": "2012-01-15T04:15:36.660"}, "8869305": {"ParentId": "8867469", "CommentCount": "2", "Body": "<p>4 things never get inherited \nConstructor\nCopy-constructor\nAssignment operator\nDestructor</p>\n<p>Even you have not written the assignment operator your code will be Woking fine.\nWhenever you use assignment operator compiler will make sure that assignment operator for each member object and base class get called.</p>\n", "OwnerUserId": "1145292", "PostTypeId": "2", "Id": "8869305", "Score": "-1", "CreationDate": "2012-01-15T11:27:58.080", "LastActivityDate": "2012-01-15T11:27:58.080"}, "8867476": {"ParentId": "8867469", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The compiler-generated assignment operator calls the assignment operator of each subobject.  That includes base classes and non-static member variables.</p>\n<p>The standard says (section 12.8 <code>[class.copy]</code>):</p>\n<blockquote>\n<p id=\"so_8867469_8867476_0\">If the class de\ufb01nition does not explicitly declare a copy assignment operator, one is declared implicitly.  If the class definition declares a move constructor or move assignment operator, the implicitly declared copy assignment operator is defined as deleted;  otherwise, it is defined as defaulted (8.4).   The latter case is deprecated if the class has a user-declared copy constructor or a user-declared destructor.  The implicitly-declared copy assignment operator for a class <code>X</code> will have the form</p>\n<pre><code>X&amp;  X::operator=(const  X&amp;)\n</code></pre>\n<p id=\"so_8867469_8867476_1\">if</p>\n<ul>\n<li>each direct base class <code>B</code> of <code>X</code> has a copy assignment operator whose parameter is of type <code>const B&amp;</code>,\n  <code>const volatile B&amp;</code> or <code>B</code>, and</li>\n<li>for all the non-static data members of <code>X</code> that are of a class type <code>M</code> (or array thereof), each such class type has a copy assignment operator whose parameter is of type <code>const M&amp;</code>, <code>const volatile M&amp;</code> or <code>M</code>.</li>\n</ul>\n<p id=\"so_8867469_8867476_2\">Otherwise, the implicitly-declared copy assignment operator will have the form</p>\n<pre><code>X&amp;  X::operator=(X&amp;)\n</code></pre>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_8867469_8867476_3\">The implicitly-defined copy/move assignment operator for a non-union class <code>X</code> performs memberwise copy/move assignment of its subobjects.  The direct base classes of <code>X</code> are assigned first, in the order of their declaration in the <em>base-specifier-list</em>, and then the immediate non-static data members of <code>X</code> are assigned, in the order in which they were declared in the class definition. Let <code>x</code> be either the parameter of the function\n  or, for the move operator, an xvalue referring to the parameter.  Each subobject is assigned in the manner appropriate to its type:</p>\n<ul>\n<li>if the subobject is of class type, as if by a call to <code>operator=</code> with the subobject as the object expression and the corresponding subobject of <code>x</code> as a single function argument (as if by explicit quali\ufb01cation; that is, ignoring any possible virtual overriding functions in more derived classes);</li>\n<li>if the subobject is an array, each element is assigned, in the manner appropriate to the element type;</li>\n<li>if the subobject is of scalar type, the built-in assignment operator is used.</li>\n</ul>\n<p id=\"so_8867469_8867476_4\">It is unspecified whether subobjects representing virtual base classes are assigned more than once by the implicitly-defined copy assignment operator.</p>\n</blockquote>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2012-01-15T04:19:09.673", "Id": "8867476", "Score": "4", "CreationDate": "2012-01-15T04:13:36.053", "LastActivityDate": "2012-01-15T04:19:09.673"}, "bq_ids": {"n4140": {"so_8867469_8867476_2": {"section_id": 467, "quality": 1.0, "length": 8}, "so_8867469_8867476_4": {"section_id": 477, "quality": 1.0, "length": 15}, "so_8867469_8867476_3": {"section_id": 477, "quality": 0.9607843137254902, "length": 49}, "so_8867469_8867476_0": {"section_id": 467, "quality": 0.9166666666666666, "length": 44}}, "n3337": {"so_8867469_8867476_2": {"section_id": 458, "quality": 1.0, "length": 8}, "so_8867469_8867476_4": {"section_id": 468, "quality": 1.0, "length": 15}, "so_8867469_8867476_3": {"section_id": 468, "quality": 0.9607843137254902, "length": 49}, "so_8867469_8867476_0": {"section_id": 458, "quality": 0.9166666666666666, "length": 44}}, "n4659": {"so_8867469_8867476_2": {"section_id": 490, "quality": 1.0, "length": 8}, "so_8867469_8867476_4": {"section_id": 500, "quality": 0.9333333333333333, "length": 14}, "so_8867469_8867476_3": {"section_id": 500, "quality": 0.9607843137254902, "length": 49}, "so_8867469_8867476_0": {"section_id": 490, "quality": 0.9166666666666666, "length": 44}}}});