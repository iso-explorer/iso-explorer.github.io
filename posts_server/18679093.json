post_cb({"18679358": {"ParentId": "18679093", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Maybe I'm missing something, but don't you just want something like this for the <code>int</code> case:</p>\n<pre><code>namespace std {\n\n// first give ranged_integer a ground zero\n    template&lt;intmax_t minimum, intmax_t maximum&gt;\n    class common_type&lt;ranged_integer&lt;minimum, maximum&gt;&gt; {\n        typedef typename ranged_integer&lt;minimum, maximum&gt; type;\n    };\n\n// sort out int\n    template&lt;intmax_t minimum, intmax_t maximum&gt;\n    class common_type&lt;int, ranged_integer&lt;minimum, maximum&gt;&gt; {\n        typedef typename ranged_integer&lt;minimum, maximum&gt; type;\n    };\n\n    template&lt;intmax_t minimum, intmax_t maximum&gt;\n    class common_type&lt;ranged_integer&lt;minimum, maximum&gt;, int&gt;&gt; {\n        typedef typename ranged_integer&lt;minimum, maximum&gt; type;\n    };\n</code></pre>\n<p>repeat this for <code>`long</code>, <code>long long</code>, <em>etc</em>... and <code>common_type</code>'s template definition will take care of all the variadic cases with only one <code>ranged_integer</code> type?</p>\n", "OwnerUserId": "1312406", "LastEditorUserId": "1312406", "LastEditDate": "2013-09-08T01:03:05.217", "Id": "18679358", "Score": "0", "CreationDate": "2013-09-08T00:57:20.900", "LastActivityDate": "2013-09-08T01:03:05.217"}, "18680380": {"ParentId": "18679093", "PostTypeId": "2", "CommentCount": "10", "Body": "<p><strong>Short answer</strong> </p>\n<p>If using <code>std::common_type</code> as provided by the standard library is absolutely required, there's no better way other than the 3 alternatives you observed yourself. If a user defined <code>common_type</code> be considered acceptable, then you can achieve what you want as shown below.</p>\n<hr>\n<p><strong>Long Answer</strong></p>\n<p>You are right when you say <code>std::common_type&lt;unsigned [long [long]] int, [long [long]] int&gt;::type</code> will yield <code>unsigned [long [long]]</code>. However, since the <code>common_ type</code> of any expression involving <code>ranged_integer</code> is itself a <code>ranged_integer</code> and given that your specializations involving <code>ranged_integer</code> correctly infer the ranges, there's only a problem if the pairwise <code>common_type</code> of the types preceding <code>[long [long]] unsigned</code> yields <code>[long [long]] int</code>.T\u0336h\u0336a\u0336t\u0336 \u0336l\u0336e\u0336a\u0336v\u0336e\u0336s\u0336 \u0336u\u0336s\u0336 \u0336o\u0336n\u0336l\u0336y\u0336 \u0336s\u0336i\u0336x\u0336 \u0336c\u0336a\u0336s\u0336e\u0336s\u0336 \u0336w\u0336e\u0336 \u0336h\u0336a\u0336v\u0336e\u0336 \u0336t\u0336o\u0336 \u0336w\u0336o\u0336r\u0336k\u0336a\u0336r\u0336o\u0336u\u0336n\u0336d\u0336,\u0336 \u0336n\u0336a\u0336m\u0336e\u0336l\u0336y\u0336 \u0336<code>\u0336s\u0336t\u0336d\u0336:\u0336:\u0336c\u0336o\u0336m\u0336m\u0336o\u0336n\u0336_\u0336t\u0336y\u0336p\u0336e\u0336&lt;\u0336u\u0336n\u0336s\u0336i\u0336g\u0336n\u0336e\u0336d\u0336 \u0336[\u0336l\u0336o\u0336n\u0336g\u0336 \u0336[\u0336l\u0336o\u0336n\u0336g\u0336]\u0336]\u0336 \u0336i\u0336n\u0336t\u0336,\u0336 \u0336[\u0336l\u0336o\u0336n\u0336g\u0336 \u0336[\u0336l\u0336o\u0336n\u0336g\u0336]\u0336]\u0336 \u0336i\u0336n\u0336t\u0336&gt;\u0336:\u0336:\u0336t\u0336y\u0336p\u0336e\u0336</code>\u0336 \u0336a\u0336n\u0336d\u0336 \u0336t\u0336h\u0336e\u0336i\u0336r\u0336 \u0336o\u0336r\u0336d\u0336e\u0336r\u0336i\u0336n\u0336g\u0336 \u0336p\u0336e\u0336r\u0336m\u0336u\u0336t\u0336a\u0336t\u0336i\u0336o\u0336n\u0336s\u0336.\u0336 \u0336(\u0336I\u0336'\u0336m\u0336 \u0336i\u0336g\u0336n\u0336o\u0336r\u0336i\u0336n\u0336g\u0336 \u0336t\u0336h\u0336e\u0336 \u0336f\u0336i\u0336x\u0336e\u0336d\u0336 \u0336w\u0336i\u0336d\u0336t\u0336h\u0336 \u0336t\u0336y\u0336p\u0336e\u0336s\u0336 \u0336h\u0336e\u0336r\u0336e\u0336,\u0336 \u0336b\u0336u\u0336t\u0336 \u0336t\u0336h\u0336e\u0336 \u0336e\u0336x\u0336t\u0336e\u0336n\u0336d\u0336i\u0336n\u0336g\u0336 \u0336t\u0336h\u0336e\u0336 \u0336i\u0336d\u0336e\u0336a\u0336 \u0336t\u0336o\u0336 \u0336c\u0336o\u0336n\u0336s\u0336i\u0336d\u0336e\u0336r\u0336 \u0336t\u0336h\u0336e\u0336m\u0336 \u0336s\u0336h\u0336o\u0336u\u0336l\u0336d\u0336 \u0336b\u0336e\u0336 \u0336s\u0336t\u0336r\u0336a\u0336i\u0336g\u0336h\u0336t\u0336f\u0336o\u0336r\u0336w\u0336a\u0336r\u0336d\u0336)\u0336</p>\n<p>W\u0336e\u0336 \u0336c\u0336a\u0336n\u0336 \u0336a\u0336c\u0336h\u0336i\u0336e\u0336v\u0336e\u0336 \u0336t\u0336h\u0336a\u0336t\u0336 \u0336b\u0336y\u0336 \u0336a\u0336g\u0336a\u0336i\u0336n\u0336 \u0336p\u0336r\u0336o\u0336v\u0336i\u0336d\u0336i\u0336n\u0336g\u0336 \u0336e\u0336x\u0336p\u0336l\u0336i\u0336c\u0336i\u0336t\u0336 \u0336s\u0336p\u0336e\u0336c\u0336i\u0336a\u0336l\u0336i\u0336z\u0336a\u0336t\u0336i\u0336o\u0336n\u0336s\u0336:\u0336</p>\n<p><strong>In fact we can't according to</strong> <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">n3485</a></p>\n<p><strong>[meta.type.synop] Paragraph 1</strong></p>\n<p><em>\"The behavior of a program that adds specializations for any of the class templates defined in this subclause [<code>template &lt;class... T&gt; common_type</code> included] is undefined unless otherwise specified.\"</em></p>\n<p><strong>[meta.trans.other] Table 57</strong></p>\n<p><em>[...] A\nprogram may specialize this trait [<code>template &lt;class... T&gt; common_type</code>] if at least one template parameter in the specialization is a user-defined type. [...]</em>\"</p>\n<p>That implies that <strong>there's no valid way of overwriting the behavior for <code>std::common_type&lt;unsigned [long [long]] int, [long [long]] int&gt;::type</code></strong>, it is required by the standard to always yield <code>unsigned [long [long]] int</code> as pointed out before. </p>\n<hr>\n<p><strong>Alternative to <code>std::common_type</code></strong></p>\n<p>An alternative to overcome the limitations of <code>std::common_type</code> when applied to primitive integral types, is to define a custom <code>common_type</code>.</p>\n<p>Assuming <code>ranged_integer</code> to be defined as follows.</p>\n<pre><code>template&lt;typename T, T min, T max&gt;\nstruct basic_ranged_integer;\n\ntemplate&lt;std::intmax_t min, std::intmax_t max&gt;\nusing ranged_integer = basic_ranged_integer&lt;std::intmax_t, min, max&gt;;\n</code></pre>\n<p>A custom <code>common_type</code> could be defined as follows. </p>\n<p>First the left recursion:</p>\n<pre><code>template&lt;typename... T&gt;\nstruct common_type;\n\ntemplate&lt;typename T, typename U, typename... V&gt;\nstruct common_type&lt;T, U, V...&gt; :\n        common_type&lt;typename common_type&lt;T, U&gt;::type, V...&gt; //left recursion\n{};\n</code></pre>\n<p>Now the specializations involving <code>basic_ranged_integer</code>.</p>\n<pre><code>//two basic_ranged_integer\ntemplate&lt;typename T, T minT, T maxT, typename U, U minU, U maxU&gt;\nstruct common_type&lt;basic_ranged_integer&lt;T, minT, maxT&gt;, basic_ranged_integer&lt;U, minU, maxU&gt;&gt;\n{\n    //gory details go here\n};\n\n//basic_ranged_integer mixed with primitive integer types\n//forwards to the case involving two basic_ranged_integer\ntemplate&lt;typename T, T minT, T maxT, typename U&gt;\nstruct common_type&lt;basic_ranged_integer&lt;T, minT, maxT&gt;, U&gt; :\n        common_type\n        &lt;\n            basic_ranged_integer&lt;T, minT, maxT&gt;,\n            typename make_ranged_integer&lt;U&gt;::type\n        &gt;\n{};\n\ntemplate&lt;typename T, typename U, U minU, U maxU&gt;\nstruct common_type&lt;T, basic_ranged_integer&lt;U, minU, maxU&gt;&gt; :\n        common_type\n        &lt;\n            typename make_ranged_integer&lt;T&gt;::type,\n            basic_ranged_integer&lt;U, minU, maxU&gt;\n        &gt;\n{};\n</code></pre>\n<p>And finally the specializations involving a combination of signed and unsigned primitive integers.</p>\n<pre><code>//base case: forwards to the satandard library\ntemplate&lt;typename T&gt;\nstruct common_type&lt;T&gt; :\n        std::common_type&lt;T&gt;\n{};\n\ntemplate&lt;typename T, typename U&gt;\nstruct common_type&lt;T, U&gt;\n{\n    static constexpr bool signed_xor  = std::is_signed&lt;T&gt;{} xor std::is_signed&lt;U&gt;{};\n\n    //base case: forwards to the satandard library\n    template&lt;bool b = signed_xor, typename = void&gt;\n    struct helper :\n            std::common_type&lt;T, U&gt;\n    {};\n\n    //mixed signed/unsigned: forwards to the case involving two basic_ranged_integer\n    template&lt;typename _ &gt;\n    struct helper&lt;true, _&gt; :\n            common_type&lt;typename make_ranged_integer&lt;T&gt;::type, typename make_ranged_integer&lt;U&gt;::type&gt;\n    {};\n\n    using type = typename helper&lt;&gt;::type;\n};\n</code></pre>\n<p>In the above <code>make_ranged_integer</code> is expected to take a primitive integer type and define <code>type</code> to be the desired corresponding <code>basic_ranged_integer</code>.</p>\n</hr></hr>", "OwnerUserId": "801438", "LastEditorUserId": "801438", "LastEditDate": "2013-09-09T00:16:34.180", "Id": "18680380", "Score": "2", "CreationDate": "2013-09-08T04:19:15.717", "LastActivityDate": "2013-09-09T00:16:34.180"}, "18679403": {"ParentId": "18679093", "CommentCount": "0", "Body": "<p>Here's a possible implementation:</p>\n<pre><code>#include &lt;limits&gt;  \n#include &lt;utility&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T, typename U&gt;\nstatic constexpr auto min(T x, U y) -&gt; decltype(x &lt; y ? x : y)\n{\n    return x &lt; y ? x : y;\n}\n\ntemplate&lt;typename T, typename U&gt;\nstatic constexpr auto max(T x, U y) -&gt; decltype(x &lt; y ? x : y)\n{\n    return x &gt; y ? x : y;\n}\n\ntemplate&lt;intmax_t f, intmax_t l&gt;\nstruct ranged_integer\n{\n    static intmax_t const first = f;\n    static intmax_t const last  = l;\n    static_assert(l &gt; f, \"invalid range\");\n};\n\ntemplate &lt;class ...T&gt; struct common_type\n{\n};\n\ntemplate &lt;class T&gt;\nstruct common_type&lt;T&gt;\n{\n    typedef T type;\n};\n\ntemplate &lt;class T, class U&gt;\nstruct common_type&lt;T, U&gt;\n{\n    typedef decltype(true ? std::declval&lt;T&gt;() : std::declval&lt;U&gt;()) type;\n};\n\ntemplate &lt;class T, intmax_t f, intmax_t l&gt;\nstruct common_type&lt;T, ranged_integer&lt;f,l&gt;&gt;\n{\n    typedef ranged_integer&lt; min(std::numeric_limits&lt;T&gt;::min(),f) , max(std::numeric_limits&lt;T&gt;::max(),l) &gt; type;\n};\n\ntemplate &lt;class T, intmax_t f, intmax_t l&gt;\nstruct common_type&lt;ranged_integer&lt;f,l&gt;, T&gt;\n{\n    typedef typename common_type&lt;T, ranged_integer&lt;f,l&gt;&gt;::type type;\n};\n\ntemplate &lt;intmax_t f1, intmax_t l1, intmax_t f2, intmax_t l2&gt;\nstruct common_type&lt;ranged_integer&lt;f1,l1&gt;, ranged_integer&lt;f2,l2&gt;&gt;\n{\n    typedef ranged_integer&lt; min(f1,f2) , max(l1,l2) &gt; type;\n};\n\ntemplate &lt;class T, class U, class... V&gt;\nstruct common_type&lt;T, U, V...&gt;\n{\n    typedef typename common_type&lt;typename common_type&lt;T, U&gt;::type, V...&gt;::type type;\n};\n\nint main(int argc, char *argv[])\n{\n    typedef common_type&lt;char, ranged_integer&lt;-99999999, 20&gt;, short, ranged_integer&lt;10, 999999999&gt;, char&gt;::type type;\n    std::cout &lt;&lt; type::first &lt;&lt; std::endl; // -99999999\n    std::cout &lt;&lt; type::last &lt;&lt; std::endl;  // 999999999\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "1003615", "PostTypeId": "2", "Id": "18679403", "Score": "1", "CreationDate": "2013-09-08T01:05:04.543", "LastActivityDate": "2013-09-08T01:05:04.543"}, "18679093": {"CommentCount": "2", "ViewCount": "665", "PostTypeId": "1", "LastEditorUserId": "852254", "CreationDate": "2013-09-08T00:02:35.743", "LastActivityDate": "2013-12-09T00:02:36.760", "Title": "Partial specialization of class template for a type that appears in any position of a variadic template parameter pack", "FavoriteCount": "1", "LastEditDate": "2013-12-09T00:02:36.760", "Id": "18679093", "Score": "7", "Body": "<p>I have defined a type that acts as an integer. I want to define a specialization for std::common_type for my type. However, this specialization should be able to give the common_type of bounded_integer (my class) in combination with any number of other arguments that are either other bounded_integer or built-in integer types. I want the following code to all be valid:</p>\n<pre><code>std::common_type&lt;bounded_integer&lt;1, 10&gt;&gt;::type\nstd::common_type&lt;bounded_integer&lt;1, 10&gt;, int&gt;::type\nstd::common_type&lt;int, long, bounded_integer&lt;1, 10&gt;&gt;::type\nstd::common_type&lt;int, int, long, short, long long, short, bounded_integer&lt;1, 10&gt;, int, short, short, short, ..., short, bounded_integer&lt;1, 10&gt;&gt;::type\n</code></pre>\n<p>My first attempt at solving this problem was by using enable_if. However, I realized that this would not allow me to distinguish from the library definition of common_type, as what I had was essentially</p>\n<pre><code>#include &lt;type_traits&gt;\n\nclass C {};\n\ntemplate&lt;typename T, typename... Ts&gt;\nclass contains_c {\npublic:\n        static constexpr bool value = contains_c&lt;T&gt;::value or contains_c&lt;Ts...&gt;::value;\n};\ntemplate&lt;typename T&gt;\nclass contains_c&lt;T&gt; {\npublic:\n        static constexpr bool value = std::is_same&lt;T, C&gt;::value;\n};\n\nnamespace std {\n\ntemplate&lt;typename... Args, typename std::enable_if&lt;contains_c&lt;Args...&gt;::value&gt;::type&gt;\nclass common_type&lt;Args...&gt; {\npublic:\n        using type = C;\n};\n\n}       // namespace std\n\nint main() {\n}\n</code></pre>\n<p>Where the 'partial specialization' is really just \"any arguments\", which is no more specialized than what we have.</p>\n<p>So it seems like the only solution is to require my users to do one of the following:</p>\n<ol>\n<li>always put the bounded_integer as the first argument to common_type</li>\n<li>always use my make_bounded(built-in integer value) function to convert their integers to bounded_integer (so don't have a specialization of common_type for built-in types in combination with bounded_integer)</li>\n<li>never put bounded_integer in a position greater than N, where N is some number I determine, similar to Visual Studio's old variadic template work-around</li>\n</ol>\n<p>3 would look something like this:</p>\n<pre><code>// all_bounded_integer_or_integral and all_are_integral defined elsewhere with obvious definitions\ntemplate&lt;intmax_t minimum, intmax_t maximum, typename... Ts, typename = type std::enable_if&lt;all_bounded_integer_or_integral&lt;Ts...&gt;::value&gt;::type&gt;\nclass common_type&lt;bounded_integer&lt;minimum, maximum&gt;, Ts...&gt; {\n};\ntemplate&lt;typename T1, intmax_t minimum, intmax_t maximum, typename... Ts, typename = typename std::enable_if&lt;all_are_integral&lt;T1&gt;::value&gt;::type, typename = typename std::enable_if&lt;all_bounded_integer_or_builtin&lt;Ts...&gt;::value&gt;::type&gt;\nclass common_type&lt;T1, bounded_integer&lt;minimum, maximum&gt;, Ts...&gt; {\n};\ntemplate&lt;typename T1, typename T2, intmax_t minimum, intmax_t maximum, typename... Ts, typename = typename std::enable_if&lt;all_are_integral&lt;T1, T2&gt;::value&gt;::type, typename = typename std::enable_if&lt;all_bounded_integer_or_builtin&lt;Ts...&gt;::value&gt;::type&gt;\nclass common_type&lt;T1, T2, bounded_integer&lt;minimum, maximum&gt;, Ts...&gt; {\n};\n// etc.\n</code></pre>\n<p>Is there a better way to accomplish this (template specialization when all the types meet one condition and any of the types meet another condition) for a class that I cannot change the original definition for?</p>\n<p>EDIT:</p>\n<p>Based on the answers, I was not clear enough in my problem.</p>\n<p>First, expected behavior:</p>\n<p>If someone calls std::common_type with all of the types being an instance of bounded_integer or a built-in numeric type, I want the result to be a bounded_integer that has a minimum of all of the possible minimums and a maximum of all of the possible maximums.</p>\n<p>The problem:</p>\n<p>I have a working solution when someone calls std::common_type on any number of bounded_integer. However, if I only specialize the two-argument version, then I run into the following problem:</p>\n<p><code>std::common_type&lt;int, unsigned, bounded_integer&lt;0, std::numeric_limits&lt;unsigned&gt;::max() + 1&gt;</code></p>\n<p>should give me</p>\n<p><code>bounded_integer&lt;std::numeric_limits&lt;int&gt;::min(), std::numeric_limits&lt;unsigned&gt;::max() + 1&gt;</code></p>\n<p>However, it does not. It first applies common_type to <code>int</code> and <code>unsigned</code>, which follows the standard integral promotion rules, giving <code>unsigned</code>. Then it returns the result of <code>common_type</code> with <code>unsigned</code> and my <code>bounded_integer</code>, giving</p>\n<p><code>bounded_integer&lt;0, std::numeric_limits&lt;unsigned&gt;::max() + 1&gt;</code></p>\n<p>So by adding <code>unsigned</code> to the middle of the parameter pack, even though it should have absolutely no impact on the result type (its ranges are entirely contained within the ranges of all other types), it still affects the result. The only way I can think of to prevent this is to specialize <code>std::common_type</code> for any number of built-in integers followed by <code>bounded_integer</code>, followed by any number of built-in integers or <code>bounded_integer</code>.</p>\n<p>My question is: how can I do this without having to approximate it by manually writing out an arbitrary number of parameters followed by a <code>bounded_integer</code> followed by a parameter pack, or is this not possible?</p>\n<p>EDIT 2:</p>\n<p>The reason that common_type will give the wrong values can be explained by this reasoning following the standard (quoting from N3337)</p>\n<p>The <code>common_type</code> of <code>int</code> and <code>unsigned</code> is <code>unsigned</code>. For an example: <a href=\"http://ideone.com/9IxKIW\" rel=\"nofollow\">http://ideone.com/9IxKIW</a> . Standardese can be found in \u00a7 20.9.7.6/3, where the <code>common_type</code> of two values is</p>\n<p><code>typedef decltype(true ? declval&lt;T&gt;() : declval&lt;U&gt;()) type;</code></p>\n<p>In \u00a7 5.16/6, it says</p>\n<blockquote>\n<p id=\"so_18679093_18679093_0\">The second and third operands have arithmetic or enumeration type; the\n  usual arithmetic conversions are performed to bring them to a common\n  type, and the result is of that type.</p>\n</blockquote>\n<p>The usual arithmetic conversions are defined in \u00a7 5/9 as</p>\n<blockquote>\n<p id=\"so_18679093_18679093_1\">Otherwise, if the operand that has unsigned integer type has rank\n  greater than or equal to the rank of the type of the other operand,\n  the operand with signed integer type shall be converted to the type of\n  the operand with unsigned integer type.</p>\n</blockquote>\n", "Tags": "<c++><c++11><variadic-templates><template-specialization><template-meta-programming>", "OwnerUserId": "852254", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_18679093_18679093_0": {"section_id": 6172, "quality": 0.9444444444444444, "length": 17}, "so_18679093_18679093_1": {"section_id": 5943, "quality": 1.0, "length": 23}}, "n3337": {"so_18679093_18679093_0": {"section_id": 5933, "quality": 0.9444444444444444, "length": 17}, "so_18679093_18679093_1": {"section_id": 5714, "quality": 1.0, "length": 23}}, "n4659": {"so_18679093_18679093_0": {"section_id": 7670, "quality": 0.9444444444444444, "length": 17}, "so_18679093_18679093_1": {"section_id": 7428, "quality": 1.0, "length": 23}}}, "18679287": {"ParentId": "18679093", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><code>std::common_type</code> extrapolates its own two-argument specialization into the n-argument case. You only need to specialize the two-argument cases.</p>\n<pre><code>template&lt; typename other, int low, int high &gt;\nstruct common_type&lt; other, ::my::ranged_integer&lt; low, high &gt; &gt; {\n    using type = other;\n};\n\ntemplate&lt; typename other, int low, int high &gt;\nstruct common_type&lt; ::my::ranged_integer&lt; low, high &gt;, other &gt; {\n    using type = other;\n};\n\ntemplate&lt; int low, int high &gt;\nstruct common_type&lt; ::my::ranged_integer&lt; low, high &gt;,\n                    ::my::ranged_integer&lt; low, high &gt; &gt; {\n    using type = ::my::ranged_integer&lt; low, high &gt;;\n};\n</code></pre>\n<p>This leaves undefined the <code>common_type</code> between different ranged integers. I suppose you could do it with <code>min</code> and <code>max</code>.</p>\n<p>You could also make an <code>is_ranged_integer</code> trait if your class supports inheritance.</p>\n<p>Don't forget to put your library inside a namespace.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2013-09-08T09:54:53.417", "Id": "18679287", "Score": "3", "CreationDate": "2013-09-08T00:42:52.737", "LastActivityDate": "2013-09-08T09:54:53.417"}});