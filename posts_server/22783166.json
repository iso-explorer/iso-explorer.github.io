post_cb({"22783166": {"CommentCount": "0", "AcceptedAnswerId": "22783340", "PostTypeId": "1", "LastEditorUserId": "2234300", "CreationDate": "2014-04-01T10:27:44.980", "LastActivityDate": "2014-04-01T14:25:08.253", "LastEditDate": "2014-04-01T14:08:13.410", "ViewCount": "208", "FavoriteCount": "2", "Title": "A valid singleton Class \uff1f", "Id": "22783166", "Score": "3", "Body": "<pre><code>class Singleton\n{\n private:\n     static Singleton s;\n     Singleton(){}\n public:\n    static Singleton *getInstance()\n    {\n        return &amp;s;\n    }\n};\n\nSingleton Singleton::s;\n</code></pre>\n<p>Is this a valid singleton class\uff1f</p>\n<pre><code>class Singleton\n{\n private:\n     static Singleton *m_instance;\n     Singleton(){}\n public:\n    static Singleton *getInstance()\n    {\n        return m_instance;\n    }\n\n};\nSingleton * Singleton::m_instance = new Singleton;\n</code></pre>\n<p>.</p>\n<pre><code>class Singleton\n{\n private:\n     static Singleton *m_instance;\n     Singleton(){}\n public:\n    static Singleton *getInstance()\n    {\n        if(m_instance == NULL)\n        {\n            lock();\n            if(m_instance == NULL)\n                m_instance = new Singleton;\n            unlock();\n        }\n        return m_instance;\n    }\n\n};\nSingleton * Singleton::m_instance = NULL;\n</code></pre>\n<p>The three singleton classes above both are thread safe, but they are both prone to \"static initialization order fiasco\", am I right?</p>\n", "Tags": "<c++><design-patterns><singleton>", "OwnerUserId": "2234300", "AnswerCount": "3"}, "22783717": {"ParentId": "22783166", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>As far as I can tell, it's thread safe. But it's susceptible to <a href=\"http://www.parashift.com/c++-faq/static-init-order.html\" rel=\"nofollow\">static initialization order fiasco</a>.</p>\n<p>If an object tries to access <code>Singleton</code> in it's constructor and that object is constructed during program initialization and this code is in another compilation unit than <code>Singleton</code>, it may or may not crash because <code>Singleton::s</code> may or may not have been initialized yet (because the order of initialization of static objects across compilation units is undefined). Here is an example:</p>\n<pre><code>// in another compilation unit, far far away\nstruct Foo {\n    Foo() {\n        Singleton::getInstance();\n    }\n};\nFoo foo;\n</code></pre>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2014-04-01T11:24:09.303", "Id": "22783717", "Score": "3", "CreationDate": "2014-04-01T10:51:43.973", "LastActivityDate": "2014-04-01T11:24:09.303"}, "22783340": {"ParentId": "22783166", "PostTypeId": "2", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_22783166_22783340_0\">Is this a valid singleton class\uff1f</p>\n</blockquote>\n<p>Now, after the edit the answer is yes, it is valid &amp; it is also thread safe since all non-function-scope static variables are constructed before <code>main()</code>, while there is only one active thread.</p>\n<p><strong>C++ Standard n3337 \u00a7 3.6.2/1 \u00a7 3.6.2/2: Initialization of non-local variables</strong></p>\n<blockquote>\n<p id=\"so_22783166_22783340_1\">There are two broad classes of named non-local variables: those with\n  static storage duration (3.7.1) and those with thread storage duration\n  (3.7.2). Non-local variables with static storage duration are\n  initialized as a consequence of program initiation. Non-local\n  variables with thread storage duration are initialized as a\n  consequence of thread execution. Within each of these phases of initiation, initialization occurs as follows.</p>\n<p id=\"so_22783166_22783340_2\">Variables with static storage duration (3.7.1) or thread storage\n  duration (3.7.2) shall be zero-initialized (8.5) before any other\n  initialization takes place. Constant initialization is performed:</p>\n<p id=\"so_22783166_22783340_3\">\u2014 if each full-expression (including implicit conversions) that\n  appears in the initializer of a reference with static or thread\n  storage duration is a constant expression (5.19) and the reference is\n  bound to an lvalue designating an object with static storage duration\n  or to a temporary (see 12.2);</p>\n<p id=\"so_22783166_22783340_4\">\u2014 if an object with static or thread storage duration is initialized\n  by a constructor call, if the constructor is a constexpr constructor,\n  if all constructor arguments are constant expressions (including\n  conversions), and if, after function invocation substitution (7.1.5),\n  every constructor call and full-expression in the mem-initializers and\n  in the brace-or-equal-initializers for non-static data members is a\n  constant expression;</p>\n<p id=\"so_22783166_22783340_5\">\u2014 if an object with static or thread storage duration is not\n  initialized by a constructor call and if every full-expression that\n  appears in its initializer is a constant expression.</p>\n<p id=\"so_22783166_22783340_6\">Together, zero-initialization and constant initialization are called\n  static initialization; all other initial- ization is dynamic\n  initialization. Static initialization shall be performed before any\n  dynamic initialization takes place. (...)</p>\n</blockquote>\n<p><strong>C++ Standard n3337 \u00a7 6.7/4: Declaration statement</strong></p>\n<blockquote>\n<p id=\"so_22783166_22783340_7\">The zero-initialization (8.5) of all block-scope variables with static\n  storage duration (3.7.1) or thread storage duration (3.7.2) is\n  performed before any other initialization takes place. Constant\n  initialization (3.6.2) of a block-scope entity with static storage\n  duration, if applicable, is performed before its block is first\n  entered. An implementation is permitted to perform early\n  initialization of other block-scope variables with static or thread\n  storage duration under the same conditions that an implementation is\n  permitted to statically initialize a variable with static or thread\n  storage duration in namespace scope. Otherwise such a variable is\n  initialized the first time control passes through its declaration;\n  such a variable is considered initialized upon the completion of its\n  initialization. If the initialization exits by throwing an exception,\n  the initialization is not complete, so it will be tried again the next\n  time control enters the declaration. <strong>If control enters the declaration\n  concurrently while the variable is being initialized, the concurrent\n  execution shall wait for completion of the initialization*).</strong> (...)</p>\n</blockquote>\n<p>*): </p>\n<blockquote>\n<p id=\"so_22783166_22783340_8\">The implementation must not introduce any deadlock around execution of\n  the initializer.</p>\n</blockquote>\n<p>But it is still prone to <a href=\"http://www.parashift.com/c++-faq/static-init-order.html\" rel=\"nofollow\">static initialization order fiasco</a>. The common way to write <code>getInstance</code> is:</p>\n<pre><code>Singleton&amp; getInstance()\n{\n    static Singleton instance;\n    return instance;\n}\n</code></pre>\n<p>This way you can avoid this initialization problem.</p>\n<blockquote>\n<p id=\"so_22783166_22783340_9\">Is this a thread-safe singleton class\uff1f</p>\n</blockquote>\n<p>In C++11 above code is thread safe. In C++03 you can use</p>\n<p><a href=\"http://www.opengroup.org/onlinepubs/007908775/xsh/pthread_once.html\" rel=\"nofollow\"><code>pthread_once</code></a> </p>\n<hr>\n<p>Besides this you should also prevent from copying and assignment:</p>\n<pre><code>Singleton( Singleton const&amp;);      // Don't Implement\nvoid operator=( Singleton const&amp;); // Don't implement\n</code></pre>\n</hr>", "OwnerUserId": "1141471", "LastEditorUserId": "1141471", "LastEditDate": "2014-04-01T14:25:08.253", "Id": "22783340", "Score": "5", "CreationDate": "2014-04-01T10:35:12.037", "LastActivityDate": "2014-04-01T14:25:08.253"}, "22783735": {"ParentId": "22783166", "CommentCount": "1", "Body": "<p>That's the lazy initialised Singleton, yes. It is thread safe under C++11.</p>\n", "OwnerUserId": "602272", "PostTypeId": "2", "Id": "22783735", "Score": "0", "CreationDate": "2014-04-01T10:52:51.220", "LastActivityDate": "2014-04-01T10:52:51.220"}, "bq_ids": {"n4140": {"so_22783166_22783340_2": {"section_id": 7151, "quality": 0.8333333333333334, "length": 15}, "so_22783166_22783340_7": {"section_id": 3919, "quality": 0.9619047619047619, "length": 101}, "so_22783166_22783340_6": {"section_id": 7151, "quality": 0.8095238095238095, "length": 17}, "so_22783166_22783340_3": {"section_id": 7151, "quality": 0.9230769230769231, "length": 24}, "so_22783166_22783340_8": {"section_id": 3919, "quality": 0.875, "length": 7}, "so_22783166_22783340_1": {"section_id": 7150, "quality": 0.9512195121951219, "length": 39}, "so_22783166_22783340_5": {"section_id": 7151, "quality": 1.0, "length": 15}}, "n3337": {"so_22783166_22783340_2": {"section_id": 6895, "quality": 0.8333333333333334, "length": 15}, "so_22783166_22783340_7": {"section_id": 3779, "quality": 0.9619047619047619, "length": 101}, "so_22783166_22783340_6": {"section_id": 6895, "quality": 0.8095238095238095, "length": 17}, "so_22783166_22783340_3": {"section_id": 6895, "quality": 0.9230769230769231, "length": 24}, "so_22783166_22783340_4": {"section_id": 6895, "quality": 0.9705882352941176, "length": 33}, "so_22783166_22783340_8": {"section_id": 3779, "quality": 0.875, "length": 7}, "so_22783166_22783340_1": {"section_id": 6894, "quality": 0.9512195121951219, "length": 39}, "so_22783166_22783340_5": {"section_id": 6895, "quality": 1.0, "length": 15}}, "n4659": {"so_22783166_22783340_5": {"section_id": 8652, "quality": 0.5333333333333333, "length": 8}, "so_22783166_22783340_2": {"section_id": 4051, "quality": 0.5555555555555556, "length": 10}, "so_22783166_22783340_8": {"section_id": 4805, "quality": 0.875, "length": 7}, "so_22783166_22783340_1": {"section_id": 8651, "quality": 0.5121951219512195, "length": 21}, "so_22783166_22783340_6": {"section_id": 8652, "quality": 0.6190476190476191, "length": 13}}}});