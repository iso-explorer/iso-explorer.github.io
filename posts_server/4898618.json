post_cb({"4899340": {"Id": "4899340", "PostTypeId": "2", "Body": "<p>It doesn't.  It doesn't even call the <code>operator const char*</code>.  Visual C++ just passes the class data to <code>printf</code> as if by <code>memcpy</code>.  It works because of the layout of the <code>CString</code> class: It only contains one member variable which is a pointer to the character data.</p>\n", "LastActivityDate": "2011-02-04T14:51:41.447", "CommentCount": "0", "CreationDate": "2011-02-04T14:51:41.447", "ParentId": "4898618", "Score": "1", "OwnerUserId": "287586"}, "4898669": {"Id": "4898669", "PostTypeId": "2", "Body": "<p>What you're doing is undefined behaviour, and is either a non-standard extension provided by your compiler or works by sheer luck. I'm guessing that the CString stores the string data as the first element in the structure, and thus that reading from the <code>CString</code> as if it were a <code>char *</code> yields a valid null-terminated string.</p>\n", "LastEditorUserId": "511601", "LastActivityDate": "2011-02-04T14:39:12.947", "Score": "6", "CreationDate": "2011-02-04T13:47:34.153", "ParentId": "4898618", "CommentCount": "8", "OwnerUserId": "174963", "LastEditDate": "2011-02-04T14:39:12.947"}, "4898677": {"Id": "4898677", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_4898618_4898677_0\">if the variadic-function call is calling operator (const char*) on it, why wouldn't it do so for my own class?</p>\n</blockquote>\n<p>Yes but you should explicitly cast it in your code: <code>printf(\"%s\", (LPCSTR)s, ...);</code>.</p>\n", "LastActivityDate": "2011-02-04T13:48:27.813", "CommentCount": "0", "CreationDate": "2011-02-04T13:48:27.813", "ParentId": "4898618", "Score": "1", "OwnerUserId": "457352"}, "4898618": {"ViewCount": "1137", "Body": "<p>Considering this code fragment:</p>\n<pre><code>struct My {\n  operator const char*()const{ return \"my\"; }\n} my;\n\nCStringA s( \"aha\" );\nprintf(\"%s %s\", s, my );\n\n\n// another variadic function to get rid of comments about printf :)\nvoid foo( int i, ... ) {\n  va_list vars;\n  va_start(vars, i);\n  for( const char* p = va_arg(vars,const char*)\n     ; p != NULL\n     ; p=va_arg(vars,const char*) ) \n  {\n    std::cout &lt;&lt; p &lt;&lt; std::endl;\n  }\n  va_end(vars);\n}\nfoo( 1, s, my );\n</code></pre>\n<p>This snippet results in the 'intuitive' output \"aha\".  But I haven't got a clue how this can work:</p>\n<ul>\n<li>if the variadic-function call is translated into pushing the pointers of the arguments, printf will receive a <code>CStringA*</code> that is interpreted as a <code>const char*</code></li>\n<li>if the variadic-function call is calling <code>operator (const char*)</code> on it, why wouldn't it do so for my own class?</li>\n</ul>\n<p>Can someone explain this?</p>\n<p>EDIT:  added a dummy variadic function that treats it's arguments as <code>const char*</code>s.  Behold - it even crashes when it reaches the <code>my</code> argument...  </p>\n", "AcceptedAnswerId": "4899199", "Title": "how does printf know the address of a CString's character data?", "CreationDate": "2011-02-04T13:43:42.807", "Id": "4898618", "CommentCount": "6", "LastEditDate": "2011-02-04T14:14:32.943", "PostTypeId": "1", "LastEditorUserId": "6610", "LastActivityDate": "2011-02-04T15:11:18.610", "Score": "7", "OwnerUserId": "6610", "Tags": "<c++><type-conversion><printf><variadic-functions>", "AnswerCount": "7"}, "4899199": {"Id": "4899199", "PostTypeId": "2", "Body": "<p>The relevant text of C++98 standard \u00a75.2.2/7:</p>\n<blockquote>\n<p id=\"so_4898618_4899199_0\">The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the argument expression. After these conversions, if the argument does not have arithmetic, enumeration, pointer, pointer to member, or class type, the program is ill-formed. If the argument has a non-POD class type (clause 9), the behavior is undefined.</p>\n</blockquote>\n<p>So <strong>formally the behavior is undefined</strong>.</p>\n<p>However, a given compiler can provide any number of language extensions, and Visual C++ does. The <a href=\"http://msdn.microsoft.com/en-us/library/z11y6be4.aspx\">MSDN Library</a> documents the behavior of Visual C++ as follows, with respect to passing arguments to <code>...</code>:</p>\n<blockquote id=\"so_4898618_4899199_1\">\n<ul>\n<li>If the actual argument is of type float, it is promoted to type double prior to the function call.</li>\n<li>Any signed or unsigned char, short, enumerated type, or bit field is converted to either a signed or an unsigned int using integral promotion.</li>\n<li>Any argument of class type is passed by value as a data structure; the copy is created by binary copying instead of by invoking the class's copy constructor (if one exists).</li>\n</ul>\n</blockquote>\n<p>This doesn\u2019t mention anything about Visual C++ applying user defined conversions.</p>\n<p>It may be that <code>CString::Format</code>, which is the function that you\u2019re really interested in, depends on the last point above.</p>\n<p>Cheers &amp; hth.,</p>\n", "LastActivityDate": "2011-02-04T14:37:32.653", "CommentCount": "0", "CreationDate": "2011-02-04T14:37:32.653", "ParentId": "4898618", "Score": "7", "OwnerUserId": "464581"}, "bq_ids": {"n4140": {"so_4898618_4899199_0": {"length": 22, "quality": 0.7857142857142857, "section_id": 5994}, "so_4898618_4899051_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 709}, "so_4898618_4899051_1": {"length": 65, "quality": 0.8904109589041096, "section_id": 5994}}, "n3337": {"so_4898618_4899199_0": {"length": 22, "quality": 0.7857142857142857, "section_id": 5762}, "so_4898618_4899051_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 5541}, "so_4898618_4899051_1": {"length": 65, "quality": 0.8904109589041096, "section_id": 5762}}, "n4659": {"so_4898618_4899199_0": {"length": 22, "quality": 0.7857142857142857, "section_id": 7496}, "so_4898618_4899051_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 7709}, "so_4898618_4899051_1": {"length": 59, "quality": 0.8082191780821918, "section_id": 7496}}}, "4899051": {"Id": "4899051", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_4898618_4899051_0\">If the variadic-function call is translated into pushing the pointers of the arguments, \u2026</p>\n</blockquote>\n<p>That is not how variadic functions work.  The <em>values</em> of the arguments, rather than pointers to the arguments, are passed, after special conversion rules for built-in types (such as char to int).</p>\n<p>C++03 \u00a75.2.2p7:</p>\n<blockquote>\n<p id=\"so_4898618_4899051_1\">When there is no parameter for a given argument, the argument is passed in such a way that the receiving function can obtain the value of the argument by invoking va_arg (18.7). The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the argument expression. After these conversions, if the argument does not have arithmetic, enumeration, pointer, pointer to member, or class type, the program is ill-formed. If the argument has a non-POD class type (clause 9), the behavior is undefined. If the argument has integral or enumeration type that is subject to the integral promotions (4.5), or a floating point type that is subject to the floating point promotion (4.6), the value of the argument is converted to the promoted type before the call. These promotions are referred to as the default argument promotions.</p>\n</blockquote>\n<p>In particular from the above:</p>\n<blockquote>\n<p id=\"so_4898618_4899051_2\">If the argument has a non-POD class type (clause 9), the behavior is undefined.</p>\n</blockquote>\n<p>C++ punts to C for the definition of va_arg, and C99 TC3 \u00a77.15.1.2p2 says:</p>\n<blockquote>\n<p id=\"so_4898618_4899051_3\">\u2026 if type is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined, except for the following cases: [list of cases that don't apply here]</p>\n</blockquote>\n<p>Thus, if you pass a class type, it must be POD, and the receiving function must apply the correct type, otherwise the behavior is undefined.  This means that in the worst case, it may work exactly as you expect.</p>\n<p>Printf will not apply the correct type for any user-defined class type as it has no knowledge of them, so you cannot pass any UDT class type to printf.  Your foo does the same thing by using a char pointer instead of the correct class type.</p>\n", "LastEditorUserId": "511601", "LastActivityDate": "2011-02-04T15:09:27.157", "Score": "1", "CreationDate": "2011-02-04T14:23:45.710", "ParentId": "4898618", "CommentCount": "1", "OwnerUserId": "511601", "LastEditDate": "2011-02-04T15:09:27.157"}, "4898684": {"Id": "4898684", "PostTypeId": "2", "Body": "<p>Your printf statement is wrong:</p>\n<pre><code>printf(\"%s\", s, my );\n</code></pre>\n<p>Should be:</p>\n<pre><code>printf(\"%s %s\", s, my);\n</code></pre>\n<p>Which will print out \"aha my\".</p>\n<p>CString has a converstion operator for <code>const char*</code> (its actually for <code>LPCTSTR</code> which is a <code>const TCHAR*</code> - <code>CStringA</code> has a conversion function for <code>LPCSTR</code>).</p>\n<p>The <code>printf</code> call will not convert your <code>CStringA</code> object to a <code>CStringA*</code> pointer.  It essentially treats it like a <code>void*</code>.  In the case of CString, it is sheer luck (or perhaps design of Microsoft's developers taking advantage of something that isn't in the standard) that it will give you the NULL-terminated string.  If you were to use a <code>_bstr_t</code> instead (which has the size of the string first), despite having the conversion function, it would fail horribly.</p>\n<p>It is good practice (and required in many cases) to explicitly cast your objects/pointers to what you want them to be when you call <code>printf</code> (or any variadic function for that matter).</p>\n", "LastEditorUserId": "529761", "LastActivityDate": "2011-02-04T15:11:18.610", "Score": "0", "CreationDate": "2011-02-04T13:49:05.840", "ParentId": "4898618", "CommentCount": "5", "OwnerUserId": "529761", "LastEditDate": "2011-02-04T15:11:18.610"}, "4898746": {"Id": "4898746", "PostTypeId": "2", "Body": "<p>You cannot insert Non-POD data into variadic functions.\n<a href=\"http://tycho.ws/blog/2010/06/variadic\" rel=\"nofollow\">More info</a></p>\n", "LastActivityDate": "2011-02-04T13:57:22.683", "CommentCount": "6", "CreationDate": "2011-02-04T13:57:22.683", "ParentId": "4898618", "Score": "4", "OwnerUserId": "312067"}});