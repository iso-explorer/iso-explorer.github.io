post_cb({"16165105": {"ParentId": "16164769", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>If you don't use argument placeholders (<code>_1</code>, <code>_2</code>, ...), then any arguments passed to the function object returned from <code>std::bind</code> will just be discarded. With:</p>\n<pre><code>std::function&lt;void(int)&gt; f = std::bind(fun, std::placeholders::_1);\n</code></pre>\n<p>I get a (long and ugly) error as expected.</p>\n<p>For the people interested in Standardese:</p>\n<p><code>\u00a720.8.9.1.2 [func.bind.bind]</code></p>\n<pre><code>template&lt;class F, class... BoundArgs&gt;\n*unspecified* bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);\n</code></pre>\n<blockquote>\n<p id=\"so_16164769_16165105_0\">p3 Returns: A forwarding call wrapper <code>g</code> with a weak result type (20.8.2). The effect of <code>g(u1, u2, ..., uM)</code> shall be <code>INVOKE(fd, v1, v2, ..., vN, result_of&lt;FD cv (V1, V2, ..., VN)&gt;::type)</code>, where <em>cv</em> represents the <em>cv</em>-qualifiers of <code>g</code> <strong>and the values and types of the bound arguments <code>v1, v2, ..., vN</code> are determined as specified below</strong>.</p>\n<p id=\"so_16164769_16165105_1\">p10 The values of the bound arguments <code>v1, v2, ..., vN</code> and their corresponding types <code>V1, V2, ..., VN</code> <strong>depend on the types <code>TiD</code> derived from the call to <code>bind</code></strong> and the <em>cv</em>-qualifiers <em>cv</em> of the call wrapper <code>g</code> as follows:</p>\n<ul>\n<li>if <code>TiD</code> is <code>reference_wrapper&lt;T&gt;</code>, the argument is <code>tid.get()</code> and its type <code>Vi</code> is <code>T&amp;</code>;</li>\n<li>if the value of <code>is_bind_expression&lt;TiD&gt;::value</code> is <code>true</code>, the argument is <code>tid(std::forward&lt;Uj&gt;(uj)...)</code> and its type <code>Vi</code> is <code>result_of&lt;TiD cv (Uj...)&gt;::type</code>;</li>\n<li>if the value <code>j</code> of <code>is_placeholder&lt;TiD&gt;::value</code> is not zero, the argument is <code>std::forward&lt;Uj&gt;(uj)</code> and its type <code>Vi</code> is <code>Uj&amp;&amp;</code>;</li>\n<li>otherwise, the value is <code>tid</code> and its type <code>Vi</code> is <code>TiD cv &amp;</code>.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2013-04-23T10:55:21.770", "Id": "16165105", "Score": "7", "CreationDate": "2013-04-23T08:56:37.123", "LastActivityDate": "2013-04-23T10:55:21.770"}, "16164769": {"CommentCount": "8", "AcceptedAnswerId": "16165105", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2013-04-23T08:42:14.233", "LastActivityDate": "2013-04-23T10:55:21.770", "LastEditDate": "2013-04-23T08:55:05.273", "ViewCount": "1449", "FavoriteCount": "1", "Title": "Understanding std::function and std::bind", "Id": "16164769", "Score": "9", "Body": "<p>I was playing arround with std::function and std::bind and I noticed something unintuitive and I would like to understand it better.</p>\n<p>For example:</p>\n<pre><code>void fun()\n{\n}\n\nvoid hun(std::string) \n{ \n}\n\nint main()\n{\n\n   function&lt;void(int)&gt; g = &amp;fun; //This fails as it should in my understanding.\n\n   function&lt;void(int)&gt; f = std::bind(fun); //This works for reasons unknown to me     \n   function&lt;void(int, std::string)&gt; h = std::bind(hun); //this doesn't work\n\nreturn 0;\n}\n</code></pre>\n<p>How is it possible to bind a <strong><code>function&lt;void(int)&gt;</code></strong> to a function that is <strong>void()</strong>.\nI could then call f(1) and get fun().\nI would like to understand how this is done. \nGoing inside Microsoft Visual Studio 2012's implementation of this got me lost in a sea of unreadable macros. so that is why I ask this question here.</p>\n", "Tags": "<c++><c++11><std-function><stdbind>", "OwnerUserId": "2223769", "AnswerCount": "2"}, "16165199": {"ParentId": "16164769", "CommentCount": "0", "Body": "<p>The forwarding call wrapper generated by a call to function template <code>bind</code> can accept any number of extra parameters; these will be ignored.  The effective arity and minimal signature of a <code>bind</code> expression is determined by the <code>placeholder</code>s used in its construction, and which callable argument(s) they are bound to.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "16165199", "Score": "6", "CreationDate": "2013-04-23T09:00:39.213", "LastActivityDate": "2013-04-23T09:00:39.213"}, "bq_ids": {"n4140": {"so_16164769_16165105_1": {"section_id": 4641, "quality": 0.7777777777777778, "length": 14}, "so_16164769_16165105_0": {"section_id": 4634, "quality": 0.7083333333333334, "length": 17}}, "n3337": {"so_16164769_16165105_1": {"section_id": 4452, "quality": 0.7777777777777778, "length": 14}, "so_16164769_16165105_0": {"section_id": 4445, "quality": 0.7916666666666666, "length": 19}}, "n4659": {"so_16164769_16165105_1": {"section_id": 6011, "quality": 0.7777777777777778, "length": 14}}}});