post_cb({"17936135": {"ParentId": "17936009", "PostTypeId": "2", "CommentCount": "3", "Body": "<pre><code>template &lt;typename R&gt;\ninline Ref (const Ref&lt;R&gt; &amp;other)\n: m_ptr(other.m_ptr)\n{\n  LogDebugc(\"copy ctor \", long(other.m_ptr));\n  Retain(m_ptr);\n}\n</code></pre>\n<p>That is not a copy constructor.  As such, it's not being called.</p>\n<blockquote>\n<p id=\"so_17936009_17936135_0\">\u00a7 12.8 A <strong>non-template</strong> constructor for class X is a copy constructor if its first parameter is of type X&amp;, const X&amp;, volatile X&amp; or const volatile X&amp;, and either there are no other parameters or else all other parameters have default arguments</p>\n</blockquote>\n<p>The compiler is using the implicitly generated copy constructor rather than the <em>conversion</em> constructor that you wrote.</p>\n", "OwnerUserId": "845092", "LastEditorUserId": "845092", "LastEditDate": "2013-07-29T23:56:51.553", "Id": "17936135", "Score": "1", "CreationDate": "2013-07-29T23:50:46.637", "LastActivityDate": "2013-07-29T23:56:51.553"}, "17936009": {"CommentCount": "9", "AcceptedAnswerId": "17936135", "ClosedDate": "2013-07-30T00:15:15.957", "CreationDate": "2013-07-29T23:36:50.147", "LastActivityDate": "2013-07-29T23:56:51.553", "PostTypeId": "1", "ViewCount": "188", "FavoriteCount": "1", "Title": "C++ Vector element constuctor not called", "Id": "17936009", "Score": "2", "Body": "<p>I have a class with a copy constructor and move constructor, both of which report messages to stdout until I figure this problem out. When pushing a local object onto a vector, no constructor is ever called, leading to later problems. However, when I use std::move to tell it to use the move constructor instead of the copy constructor, everything works fine. Is this a bug, or am I misunderstanding how std::vector operates?</p>\n<p>These are my object's constructors:</p>\n<pre><code>template &lt;typename R&gt;\ninline Ref (const Ref&lt;R&gt; &amp;other)\n: m_ptr(other.m_ptr)\n{\n  LogDebugc(\"copy ctor \", long(other.m_ptr));\n  Retain(m_ptr);\n}\n\ntemplate &lt;typename R&gt;\ninline Ref (Ref&lt;R&gt; &amp;&amp;other)\n: m_ptr(other.m_ptr)\n{\n  LogDebugc(\"move ctor \", long(other.m_ptr));\n  other.m_ptr = nullptr;\n}\n</code></pre>\n<p>And here's where the problem occurs:</p>\n<pre><code>void SetState (State *state)\n{\n  // Keep a reference so we don't free the state by mistake\n  Ref&lt;State&gt; ref (state);\n\n  s_stateStack.clear();\n  if (ref) {\n    LogDebugc(\"pre push \", long(state));\n    s_stateStack.push_back(ref);\n    LogDebugc(\"post push \", long(state));\n  }\n}\n</code></pre>\n<p>I'm expecting to get the output...</p>\n<pre><code>[dbg] pre push 6415744\n[dbg] copy ctor 6415744\n[dbg] post push 6415744\n</code></pre>\n<p>...but instead, I'm getting...</p>\n<pre><code>[dbg] pre push 6415744\n[dbg] post push 6415744\n</code></pre>\n<p>When I change the line where the state is pushed back, I get:</p>\n<pre><code>s_stateStack.push_back(std::move(ref));\n\n[dbg] pre push 6415744\n[dbg] move ctor 6415744\n[dbg] post push 6415744\n</code></pre>\n<p>This is deeply confusing me. Any help is appreciated.</p>\n", "Tags": "<c++><c++11><stdvector><move-semantics><reference-counting>", "OwnerUserId": "813022", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_17936009_17936135_0": {"section_id": 451, "quality": 0.96, "length": 24}}, "n3337": {"so_17936009_17936135_0": {"section_id": 442, "quality": 0.96, "length": 24}}, "n4659": {"so_17936009_17936135_0": {"section_id": 474, "quality": 0.96, "length": 24}}}});