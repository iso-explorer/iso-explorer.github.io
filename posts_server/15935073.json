post_cb({"15936695": {"ParentId": "15935073", "CommentCount": "0", "Body": "<p>As far as C++ is concerted, <code>#ifdef C++11</code> is a syntax error. There is no rule saying a compiler has to reject a program with a syntax error.</p>\n<blockquote>\n<p id=\"so_15935073_15936695_0\">1.4 Implementation compliance [intro.compliance]</p>\n<p id=\"so_15935073_15936695_1\">The set of diagnosable rules consists of all syntactic and semantic rules in this International Standard except for those rules containing an explicit notation that \"no diagnostic is required\" or which are described as resulting in \"undefined behavior.\"</p>\n<p id=\"so_15935073_15936695_2\">[...]</p>\n<p id=\"so_15935073_15936695_3\">If a program contains a violation of any diagnosable rule or an occurrence of a construct described in this Standard as \"conditionally-supported\" when the implementation does not support that construct, a conforming implementation shall issue at least one diagnostic message.</p>\n</blockquote>\n<p>A warning is a diagnostic message. The compilers are perfectly within their rights to continue to successfully compile the program, as long as they ensure they show you that one diagnostic message. Since compilers have historically accepted such directives, and accepting such directives does not conflict with the requirements of the standard, they continue to do so.</p>\n<p>At least as far as GCC is concerned, you can ask to make all standard-required diagnostics a hard error with the <code>-pedantic-errors</code> option.</p>\n<pre class=\"lang-none prettyprint-override\"><code>$ printf \"#ifdef C++11\\n#endif\\n\" | gcc -std=c++11 -pedantic-errors -E -x c++ -\n# 1 \"&lt;stdin&gt;\"\n# 1 \"&lt;command-line&gt;\"\n# 1 \"&lt;stdin&gt;\"\n&lt;stdin&gt;:1:9: error: extra tokens at end of #ifdef directive\n</code></pre>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "15936695", "Score": "3", "CreationDate": "2013-04-10T21:24:19.907", "LastActivityDate": "2013-04-10T21:24:19.907"}, "15935073": {"CommentCount": "3", "ViewCount": "9945", "CreationDate": "2013-04-10T19:48:05.410", "LastActivityDate": "2013-04-10T21:29:35.573", "Title": "Extra tokens at end of #ifdef directive", "PostTypeId": "1", "Id": "15935073", "Score": "4", "Body": "<p>Why does the following code compiles?</p>\n<pre><code>#ifdef C++11\n// ...\n#endif\n\nint main() {}\n</code></pre>\n<p>gcc 4.8.0 gives me the following warning:</p>\n<blockquote>\n<p id=\"so_15935073_15935073_0\">extra tokens at end of #ifdef directive</p>\n</blockquote>\n<p>According to the standard, the macro name can contain only letters, digits and underscore character.</p>\n<p>Maybe because this?</p>\n<p><strong>ISO/IEC 14882:2011</strong></p>\n<blockquote>\n<p id=\"so_15935073_15935073_1\">16.1 Conditional inclusion [cpp.cond]</p>\n<p id=\"so_15935073_15935073_2\">6 Each directive\u2019s condition is checked in order. If it evaluates to\n  false (zero), the group that it controls is skipped: directives are\n  processed only through the name that determines the directive in order\n  to keep track of the level of nested conditionals; the rest of the\n  directives\u2019 preprocessing tokens are ignored, as are the other\n  preprocessing tokens in the group. Only the first group whose control\n  condition evaluates to true (nonzero) is processed. If none of the\n  conditions evaluates to true, and there is a #else directive, the\n  group controlled by the #else is processed; lacking a #else directive,\n  all the groups until the #endif are skipped.151</p>\n</blockquote>\n<p>I can't understand this quote correctly.</p>\n", "Tags": "<c++><c>", "OwnerUserId": "1608835", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_15935073_15936695_3": {"section_id": 5770, "quality": 0.9523809523809523, "length": 20}, "so_15935073_15936695_1": {"section_id": 5769, "quality": 0.8695652173913043, "length": 20}, "so_15935073_15935073_2": {"section_id": 502, "quality": 0.9016393442622951, "length": 55}}, "n3337": {"so_15935073_15936695_3": {"section_id": 5543, "quality": 0.9523809523809523, "length": 20}, "so_15935073_15936695_1": {"section_id": 5542, "quality": 0.8695652173913043, "length": 20}, "so_15935073_15935073_2": {"section_id": 493, "quality": 0.9016393442622951, "length": 55}}, "n4659": {"so_15935073_15936695_3": {"section_id": 7227, "quality": 0.9523809523809523, "length": 20}, "so_15935073_15936695_1": {"section_id": 7226, "quality": 0.8695652173913043, "length": 20}, "so_15935073_15935073_2": {"section_id": 523, "quality": 0.9016393442622951, "length": 55}}}, "15936048": {"ParentId": "15935073", "LastEditDate": "2013-04-10T21:29:35.573", "CommentCount": "14", "CreationDate": "2013-04-10T20:46:50.467", "OwnerUserId": "1261432", "LastEditorUserId": "1261432", "PostTypeId": "2", "Id": "15936048", "Score": "1", "Body": "<p>A <code>#ifdef</code> is defined as follow (taken from \u00a716.1)</p>\n<blockquote>\n<p id=\"so_15935073_15936048_0\"><code># ifdef</code> \u00a0\u00a0\u00a0\u00a0 <em>identifier new-line</em></p>\n</blockquote>\n<p>With regexp-like notation, an identifier is: <code>[a-zA-Z_][a-zA-Z_0-9]*</code> (*)</p>\n<p>The point is: <strong>the macro you declare is NOT <code>C++11</code></strong>. It is in fact <code>C</code> (see <a href=\"http://liveworkspace.org/code/460h5Z%240\" rel=\"nofollow\">this live example</a>). The <code>++11</code> part is ignored by the preprocessor. The only allowed character after the identifier (which is <code>C</code>) is a new-line, but as said in hvd's answer, from \u00a71.4, a syntax error only force a diagnostic message, here the warning; the only reason I see for this instead of an error is to be compatible with old code, where such names sould have been used.</p>\n<p>Also: the quote explains how <code>#ifdef / #elif / #else / #endif</code> work together, not the way conditions are specified.</p>\n<p><em>I do not have a copy of the standard. I used draft <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">n3485</a> for this answer.</em></p>\n<p>(*) <em>It is possible to have implementation-defined characters in an identifier, but that does not impact your question. Note that variables, class name, macros, ... all follows the same identifier rules.</em></p>\n", "LastActivityDate": "2013-04-10T21:29:35.573"}});