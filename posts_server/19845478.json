post_cb({"19845583": {"ParentId": "19845478", "CommentCount": "0", "Body": "<p>Sure. Read the second line of the error message carefully: the function was declared <code>extern</code> and <strong>later</strong> <code>static</code>. So all you have to do is declare it static before the friend declaration:</p>\n<pre><code>class A;\nstatic void IncrementValue(A&amp;);\n\nclass A {\n    // class definition, including friend declaration\n};\n\nstatic void IncrementValue(A&amp;) {\n    // code here, of course\n}\n</code></pre>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "19845583", "Score": "16", "CreationDate": "2013-11-07T20:04:28.560", "LastActivityDate": "2013-11-07T20:04:28.560"}, "40937193": {"ParentId": "19845478", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>While Praetorian's <a href=\"https://stackoverflow.com/a/19845672/954927\" title=\"answer\">answer</a> is technically correct in that it answers the question you explicitly asked, I believe it is not a useful answer in that what he proposes is both unsound and it also does not fulfill your stated objective of wishing to define a method that can be called in the friend classes' translation unit only.</p>\n<p>There are two problems with his solution. Firstly any other translation unit that includes the header containing the class definition preceeded by the static function declaration will fail to compile due to the error that the statically declared friend function is not defined in the referencing translation module. And secondly, the referencing TU can eliminate that compile error by defining the statically declared function itself, and that definition will be able to access all the private data of the class that the function was declared a friend of. This suggests that friend functions should always be left having the public linkage that is their default, as this prevents this potential encapsulation breach due to multiple definitions of a public linkage function being a compile error.</p>\n<p>I believe @engf was on the right track in his comment on your question, you need a friend class defined in the same translation unit as the class you wish it to be able to access. E.g.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>// A.h\n\nclass A\n{\npublic:\n   A() : _value(0) {}\nprivate:\n   int _value;\n   friend struct A_Accessor;\n};\n</code></pre>\n<pre class=\"lang-cpp prettyprint-override\"><code>// A.cpp\n\nstruct A_Accessor\n{\n   static void IncrementValue(A&amp; a)\n   {\n      ++a._value;\n   }\n};\n\n\nTEST(StaticInit, IncrementA)\n{\n   A a;\n   A_Accessor::IncrementValue(a);\n}\n</code></pre>\n<p>This will define IncrementValue in a way that permits it to access A's private data, yet cannot be referenced from outside A's translation module.</p>\n", "OwnerUserId": "954927", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:07.780", "Id": "40937193", "Score": "4", "CreationDate": "2016-12-02T16:49:22.100", "LastActivityDate": "2016-12-02T16:49:22.100"}, "19845478": {"CommentCount": "5", "AcceptedAnswerId": "19845672", "CreationDate": "2013-11-07T19:58:57.963", "LastActivityDate": "2016-12-02T16:49:22.100", "PostTypeId": "1", "ViewCount": "11885", "FavoriteCount": "4", "Title": "Is it possible to declare a friend function as static?", "Id": "19845478", "Score": "18", "Body": "<p>Here is some C++ example code that compiles and works fine:</p>\n<pre><code>class A\n{\npublic:\n   A() {/* empty */}\n\nprivate:\n   friend void IncrementValue(A &amp;);\n   int value;\n};\n\nvoid IncrementValue(A &amp; a)\n{\n   a.value++;\n}   \n\nint main(int, char **)\n{\n   A a;\n   IncrementValue(a);\n   return 0;\n}\n</code></pre>\n<p>What I would like to do, however, is declare IncrementValue() as static, so that it can't be seen or called from another compilation unit:</p>\n<pre><code>static void IncrementValue(A &amp; a)\n{\n    a.value++;\n}\n</code></pre>\n<p>Doing that, however, gives me a compile error:</p>\n<pre><code>temp.cpp: In function \u2018void IncrementValue(A&amp;)\u2019:\ntemp.cpp:12: error: \u2018void IncrementValue(A&amp;)\u2019 was declared \u2018extern\u2019 and later \u2018static\u2019\ntemp.cpp:8: error: previous declaration of \u2018void IncrementValue(A&amp;)\u2019\n</code></pre>\n<p>... and changing the friend declaration to match doesn't help:</p>\n<pre><code>friend static void IncrementValue(A &amp;);\n</code></pre>\n<p>... as it gives this error: </p>\n<pre><code>temp.cpp:8: error: storage class specifiers invalid in friend function declarations\n</code></pre>\n<p>My question is, is there any way in C++ to have a (non-method) friend function that is declared static?</p>\n", "Tags": "<c++><static><friend>", "OwnerUserId": "131930", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_19845478_19845672_0": {"section_id": 6687, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_19845478_19845672_0": {"section_id": 6442, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_19845478_19845672_0": {"section_id": 8162, "quality": 0.8571428571428571, "length": 12}}}, "19845672": {"ParentId": "19845478", "CommentCount": "1", "Body": "<p>Quoting N3691 - \u00a711.3/4 [class.friend]</p>\n<blockquote>\n<p id=\"so_19845478_19845672_0\">A function first declared in a friend declaration has external linkage (3.5). Otherwise, the function retains its previous linkage (7.1.1).</p>\n</blockquote>\n<p>So you need to declare the function as <code>static</code> <em>prior to</em> declaring it as a <code>friend</code>. This can be done by adding the following declarations above the definition of <code>A</code>.</p>\n<pre><code>class A;  // forward declaration, required for following declaration\nstatic void IncrementValue(A&amp;); // the friend declaration will retain static linkage\n</code></pre>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "19845672", "Score": "17", "CreationDate": "2013-11-07T20:09:23.473", "LastActivityDate": "2013-11-07T20:09:23.473"}});