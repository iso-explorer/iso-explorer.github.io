post_cb({"29875674": {"CommentCount": "0", "ViewCount": "166", "CreationDate": "2015-04-26T09:02:29.733", "LastActivityDate": "2015-08-29T10:01:42.037", "Title": "increment pointer within if (pointer) condition", "AcceptedAnswerId": "29875691", "PostTypeId": "1", "Id": "29875674", "Score": "4", "Body": "<p>I'm reading c++ code, where the developer often uses this kind of pattern:</p>\n<pre><code>float *_array;\n\n//...\nwhile (expression) {\n\n    if (_array) {\n        // ...\n        _array += 1;\n    } else {\n        // ...\n    }\n}\n</code></pre>\n<p>The outer while loop will terminate independently from where _array points to. My question is about the <code>if (_array)</code> condition and the incrementation within that clause.</p>\n<p>I first thought that it should check if the pointer \"ran out of\" the array, but  that does not seem to be case. I tested it with this simple snippet:</p>\n<pre><code>float *p = new float[5];\nint i = 0;\nfor (i = 0; i &lt; 10; i++) {\n    if (p) {\n        std::cout &lt;&lt; \"ok\\n\";\n    } else {\n        std::cout &lt;&lt; \"no\\n\";\n    }\n    p += 1;\n}\n</code></pre>\n<p>This will print 10 times \"ok\". So <code>if (pointer)</code> evaluates to <code>true</code> even if the pointer exceeded the defined array length.</p>\n<p>But what else could be the purpose of <code>if (pointer)</code> in that context?</p>\n", "Tags": "<c++><c><arrays><pointers>", "OwnerUserId": "1258878", "AnswerCount": "6"}, "29875838": {"ParentId": "29875674", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The code is flawed - the pointer is incremented even if it's <code>NULL</code>.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    float *ptr = nullptr;\n\n    for(int i = 0; i &lt; 5; ++i)\n    {\n        cout &lt;&lt; (ptr ? \"ok\" : \"no\") &lt;&lt; endl;\n        ++ptr;\n    }\n\n    cin.get();\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>no\nok\nok\nok\nok\n</code></pre>\n<p>You'll get access violation if you try to dereference that pointer. Put the pointer incrementation in the <code>if(ptr)</code> clause and it will stay <code>NULL</code> if it was <code>NULL</code> before the loop.</p>\n", "OwnerUserId": "3552770", "LastEditorUserId": "3552770", "LastEditDate": "2015-08-29T10:01:42.037", "Id": "29875838", "Score": "1", "CreationDate": "2015-04-26T09:22:05.110", "LastActivityDate": "2015-08-29T10:01:42.037"}, "29901822": {"ParentId": "29875674", "CommentCount": "0", "Body": "<p>As far as I understand, in C, <code>if</code> condition works on whether the value is <code>zero</code> or <code>non-zero</code>. Since NULL pointer has a value of zero, it fails the <code>if</code> condition! In other words, this method can be <strong>interpreted as a verification for NULL pointer</strong></p>\n<p><strong>Proof</strong></p>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int *p = NULL;\n    int a = 1;\n\n    printf(\"%p %d\\n\", p, p);\n\n    p = &amp;a;\n    printf(\"%p %d\\n\", p, p);\n\n    return 0;\n}\n</code></pre>\n<p>Now when we compile &amp; run this:</p>\n<pre><code>$&gt; gcc null.c\n$&gt; ./a.out\n(nil) 0\n0x7fff0556ff3c 89587516\n</code></pre>\n<p>Notice that in the first <code>printf</code>, with the %d, the value of the pointer <code>p</code> is <code>zero</code>. Hence if you use a pointer directly in a <code>if</code> condition, it will act as a true or false, which can be interpreted as NULL pointer or non-NULL pointer.</p>\n<p><strong>Best Practice</strong></p>\n<p>Also, I would like to add that the usage is from the standard best practices. This is the preferred method for checking if the pointer is NULL as compared to the potentially dangerous &amp; error-prone:</p>\n<pre><code>if (p == NULL) {\n}\n</code></pre>\n<p>which can be mis-typed (dangerously) into:</p>\n<pre><code>if (p = NULL) {\n}\n</code></pre>\n", "OwnerUserId": "3550741", "PostTypeId": "2", "Id": "29901822", "Score": "0", "CreationDate": "2015-04-27T17:02:32.950", "LastActivityDate": "2015-04-27T17:02:32.950"}, "29875712": {"ParentId": "29875674", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The null pointer is implicitly converted into boolean false and the non-null pointers are converted into true.</p>\n<p>So you can use either</p>\n<pre><code>if(_array != NULL)\n</code></pre>\n<p>or</p>\n<pre><code>if(_array)\n</code></pre>\n<p><strong>\u00a7 4.12 Boolean conversions</strong></p>\n<blockquote>\n<p id=\"so_29875674_29875712_0\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to\n  member type can be converted to a prvalue of type bool. A zero value,\n  null pointer value, or null member pointer value is converted to\n  false; any other value is converted to true. A prvalue of type\n  std::nullptr_t can be converted to a prvalue of type bool; the\n  resulting value is false.</p>\n</blockquote>\n", "OwnerUserId": "2019993", "LastEditorUserId": "2019993", "LastEditDate": "2015-04-26T09:16:25.360", "Id": "29875712", "Score": "2", "CreationDate": "2015-04-26T09:06:16.950", "LastActivityDate": "2015-04-26T09:16:25.360"}, "29875908": {"ParentId": "29875674", "CommentCount": "0", "Body": "<p>Adding to the main answer: your second code causes undefined behaviour.</p>\n<p>Once the loop runs 6 times, <code>p</code> moves past the end of the array and causes undefined behaviour. Pointers may only point to an object, or one past the end, or be null pointers.</p>\n<p>This shows why \"trial and error\" is not a good way to learn about C++ because it is hard to tell the difference between defined behaviour, and undefined behaviour that happens to do what you expect this time.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "29875908", "Score": "1", "CreationDate": "2015-04-26T09:28:41.267", "LastActivityDate": "2015-04-26T09:28:41.267"}, "29875708": {"ParentId": "29875674", "CommentCount": "0", "Body": "<p>In C and C++ a pointer when evaluated in a boolean context returns <code>true</code> if the pointer is not NULL and <code>false</code> if the pointer is NULL.</p>\n<p>The form <code>if (ptr) ...</code> is a common shorthand for <code>if (ptr != NULL) ...</code>.</p>\n<p>This interpretation rule is true even if in the specific platform a NULL pointer is not represented by binary zeros.</p>\n", "OwnerUserId": "320726", "PostTypeId": "2", "Id": "29875708", "Score": "3", "CreationDate": "2015-04-26T09:05:48.880", "LastActivityDate": "2015-04-26T09:05:48.880"}, "bq_ids": {"n4140": {"so_29875674_29875712_0": {"section_id": 44, "quality": 1.0, "length": 39}}, "n3337": {"so_29875674_29875712_0": {"section_id": 41, "quality": 1.0, "length": 39}}, "n4659": {"so_29875674_29875712_0": {"section_id": 45, "quality": 1.0, "length": 39}}}, "29875691": {"ParentId": "29875674", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Its purpose is to check whether pointer <code>_array</code> is pointing to <code>NULL</code> or not, i.e. to check if it is a <code>NULL</code> pointer.    </p>\n<p><code>new</code> throws <code>std::bad_alloc</code> exception and therefore no need to check <code>NULL</code>. In case of <code>malloc, calloc, realloc</code> or <code>new(std::nothrow)</code>, if the allocation fails they return <code>NULL</code>. In such case you need to check for <code>NULL</code>.</p>\n", "OwnerUserId": "2455888", "LastEditorUserId": "2455888", "LastEditDate": "2015-04-26T09:46:24.820", "Id": "29875691", "Score": "6", "CreationDate": "2015-04-26T09:04:23.903", "LastActivityDate": "2015-04-26T09:46:24.820"}});