post_cb({"32154924": {"CommentCount": "17", "ViewCount": "229", "CreationDate": "2015-08-22T10:14:13.653", "LastActivityDate": "2015-08-22T10:56:22.547", "Title": "In C/C++ is it safe to use boolean operator short circuit for control flow without using computed boolean value?", "AcceptedAnswerId": "32155323", "PostTypeId": "1", "Id": "32154924", "Score": "3", "Body": "<p>A recurring pattern in a piece of inherited code is that a chain of functions is called and the chain aborted, as soon as one of the functions returns a certain value. This value shall then be used for following computation. For the sake of demonstration the breaking value is <code>0</code>. Consider the following program:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nstatic int n;\n\nstatic int foo(int x)\n{\n    fprintf(stderr, \"%d(%d) \", x, n++);\n    return x ? 0 : n;\n}\n\nstatic void with_if(void)\n{\n    int rc;\n    n = 0;\n\n    do {\n        if( (rc = foo(1)) ) break;\n        if( (rc = foo(2)) ) break;\n        if( (rc = foo(3)) ) break;\n        if( (rc = foo(4)) ) break;\n        if( (rc = foo(0)) ) break;\n        if( (rc = foo(5)) ) break;\n    } while(0);\n\n    fprintf(stderr, \"&gt;&gt;%d&lt;&lt;\\n\", rc);\n}\n\nvoid with_short_circuit(void)\n{\n    int rc;\n    n = 0;\n\n       (rc = foo(1))\n    || (rc = foo(2))\n    || (rc = foo(3))\n    || (rc = foo(4))\n    || (rc = foo(0))\n    || (rc = foo(5));\n\n    fprintf(stderr, \"&gt;&gt;%d&lt;&lt;\\n\", rc);\n}\n\nint main(int argc, char *argv[])\n{\n    with_if();\n    with_short_circuit();\n    return 0;\n}\n</code></pre>\n<p>Note that the short circuited variant is not only more concise, it's (IMHO) also far easier to read and reason about, since you don't have to push all the other surrounding statements into your mental stack, when reading that code. So I by large prefer the short circuited variant.</p>\n<p>As far as GCC-4.9.3 and Clang-3.6.2 are concerned <code>with_if</code> and <code>with_short_circuit</code> are identical (they produce the very same assembly output).</p>\n<p>What I'm worried about is, that the outcome of the boolean operator chain is ignored (if compiled with <code>-Wall</code> GCC emits a warning about it, Clang remains silent though) and that this might be seen as a chance for optimization. Of course calling foo causes a side effect, hence in my understanding of the C language standard is should be safe to use boolean short circuit for control flow like this. Bit I'm not quite sure about it.</p>\n", "Tags": "<c++><c><language-lawyer>", "OwnerUserId": "524368", "AnswerCount": "3"}, "32155323": {"ParentId": "32154924", "CommentCount": "0", "Body": "<p>This is called a \"discarded-value expression\", and it has to be evaluated:</p>\n<p>N4296, 5\u00a711:</p>\n<blockquote>\n<p id=\"so_32154924_32155323_0\">In some contexts, an expression only appears for its side effects. Such an expression is called a discarded-value\n  expression. The expression is evaluated and its value is discarded.</p>\n</blockquote>\n", "OwnerUserId": "3435400", "PostTypeId": "2", "Id": "32155323", "Score": "3", "CreationDate": "2015-08-22T10:56:22.547", "LastActivityDate": "2015-08-22T10:56:22.547"}, "32155067": {"ParentId": "32154924", "LastEditDate": "2015-08-22T10:47:47.823", "CommentCount": "2", "CreationDate": "2015-08-22T10:31:05.677", "OwnerUserId": "1377697", "LastEditorUserId": "1377697", "PostTypeId": "2", "Id": "32155067", "Score": "0", "Body": "<p>The GCC in fact does make a hard guarantee about the behaviour of any code that produces a side effect. You are quite safe, so long as you are not trying to create a delay or measure execution speed.</p>\n<p>However, your code in the while(0) would actually be considered bad design by most. Code that performs that way is usually written like:</p>\n<pre><code>if( (rc = foo(1)) ) ;\n    else if( (rc = foo(2)) ) ;\n    else if( (rc = foo(3)) ) ;\n    else if( (rc = foo(4)) ) ;\n    else if( (rc = foo(0)) ) ;\n    else if( (rc = foo(5)) ) ;\n</code></pre>\n<p>In addition, it is not usually considered appropriate to put an = inside a conditional expression, if for no other reason than the similarity between == and =.</p>\n", "LastActivityDate": "2015-08-22T10:47:47.823"}, "bq_ids": {"n4140": {"so_32154924_32155323_0": {"section_id": 5944, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_32154924_32155323_0": {"section_id": 5715, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_32154924_32155323_0": {"section_id": 7429, "quality": 0.8888888888888888, "length": 16}}}, "32155039": {"ParentId": "32154924", "LastEditDate": "2017-05-23T11:46:41.763", "CommentCount": "0", "CreationDate": "2015-08-22T10:27:10.710", "OwnerUserId": "335858", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "32155039", "Score": "3", "Body": "<p>C/C++ are not allowed to optimize out function calls like this, so you are completely safe. The standard guarantees both the short-circuiting and the order of evaluation of your <code>with_short_circuit</code> expression, so any standard-compliant compiler will produce the code with the right behavior.</p>\n<p>My guess as to why the compiler issues the warning is that a stand-alone expression statement without obvious side effects is <em>usually</em> a mistake. In your case, however, side effects are very obvious. Since you know for sure what you are doing, you can <a href=\"https://stackoverflow.com/a/3394305/335858\">silence this specific warning with a diagnostic pragma</a>. </p>\n", "LastActivityDate": "2015-08-22T10:27:10.710"}});