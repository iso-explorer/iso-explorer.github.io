post_cb({"5632419": {"Id": "5632419", "PostTypeId": "2", "Body": "<p>Multimap only has a predicate ordering the keys. It has no method to determine whether the values are equal. Is value \"A\" a duplicate of value \"a\"? Without a second predicate for the values, there's no telling. Therefore, it doesn't even make sense to talk about duplicate values in a multimap.</p>\n<p>If you would like a container that stores pairs, and enforces the unique-ness of both parts of the pair, look at <a href=\"http://www.boost.org/doc/libs/1_46_1/libs/multi_index/doc/index.html\" rel=\"nofollow noreferrer\"><code>boost::multi_index_container</code></a>. It's very flexible,  but takes a load of arguments as a result.</p>\n", "LastEditorUserId": "15416", "LastActivityDate": "2016-04-11T12:47:32.760", "Score": "17", "CreationDate": "2011-04-12T08:31:21.697", "ParentId": "5632194", "CommentCount": "2", "LastEditDate": "2016-04-11T12:47:32.760", "OwnerUserId": "15416"}, "5632313": {"Id": "5632313", "PostTypeId": "2", "Body": "<p>As you know, <code>multimap</code> allows to have multiple keys. Since it does not place any constraints on values comparability, it is unable to check, if values haven't been doubled.</p>\n<p>If you want to have some dictionary data structure which allows for duplicate keys, but not key-value pairs, you would have to ensure that values are comparable.</p>\n<p>Let's say we have a game of some sort, where there is 2D world of sqaure fields, and you can put items on fields. You can have <code>multimap&lt;Field, Item&gt;</code>, which will allow you to keep two identical items on the field. Items don't have to be comparable here.</p>\n", "LastEditorUserId": "212191", "LastActivityDate": "2011-04-12T08:27:17.253", "Score": "1", "CreationDate": "2011-04-12T08:21:07.563", "ParentId": "5632194", "CommentCount": "0", "LastEditDate": "2011-04-12T08:27:17.253", "OwnerUserId": "212191"}, "5632498": {"Id": "5632498", "PostTypeId": "2", "Body": "<p>The values are allowed to be duplicates because they are not required to be comparable to each other. The container cannot do anything with the values besides copy them in. This enables types like <code>multimap&lt; int, my_class &gt;</code>.</p>\n<p>If duplicate key-value pairs are undesirable, then use <code>set&lt; pair&lt; T, U &gt; &gt;</code> and use <code>lower_bound</code> to find the first match to a given key.</p>\n", "LastActivityDate": "2011-04-12T08:39:18.757", "CommentCount": "0", "CreationDate": "2011-04-12T08:39:18.757", "ParentId": "5632194", "Score": "2", "OwnerUserId": "153285"}, "bq_ids": {"n4140": {"so_5632194_5633372_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 1021}}, "n3337": {"so_5632194_5633372_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 1006}}, "n4659": {"so_5632194_5633372_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 1094}}}, "5633372": {"Id": "5633372", "PostTypeId": "2", "Body": "<p>My reasoning is multimap is based on the Key lookup/insertion and not on the value. So whether the value on duplicate keys is the same or not does not play a part when elements are being inserted. </p>\n<p>23.3.2 <strong>Class template multimap</strong></p>\n<blockquote>\n<p id=\"so_5632194_5633372_0\">1 A multimap is a kind of associative\n  container that supports equivalent\n  keys (possibly containing multiple\n  copies of the same key value) and\n  provides for fast retrieval of values\n  of another type T based on the keys.</p>\n</blockquote>\n", "LastActivityDate": "2011-04-12T09:53:47.413", "CommentCount": "0", "CreationDate": "2011-04-12T09:53:47.413", "ParentId": "5632194", "Score": "0", "OwnerUserId": "77673"}, "5632359": {"Id": "5632359", "PostTypeId": "2", "Body": "<p><a href=\"http://www.cplusplus.com/reference/stl/multimap/\" rel=\"nofollow\">\"multimap\"</a> is meant to support 'multiple' keys unlike simple <a href=\"http://www.cplusplus.com/reference/stl/map/\" rel=\"nofollow\">\"map\"</a>. Since it allows multiple keys, it won't bother for their values, so it shows 3 elements in your example. The other difference is, one can not have <code>operator []</code> for <code>multimap</code>.</p>\n", "LastActivityDate": "2011-04-12T08:25:40.280", "CommentCount": "0", "CreationDate": "2011-04-12T08:25:40.280", "ParentId": "5632194", "Score": "0", "OwnerUserId": "514235"}, "5632237": {"Id": "5632237", "PostTypeId": "2", "Body": "<p><strong>EDIT: This answer does not answer the current question anymore.</strong> I'll keep it as it is because it got upvoted a lot so it must be useful for some.</p>\n<p>The <em>multi</em> in <code>multimap</code> stands for the fact that the same <strong>key</strong> can occur <em>multiple</em> times.</p>\n<p>The standard puts no limit on the type used as value, so one cannot assume that <code>operator==()</code> is defined. Because we don't want the result of your code depend on whether the operator==() is defined or not, it is never used.</p>\n<p><code>std::multimap</code> is not a replacement for <code>std::map</code>. As you noticed, it behaves differently when the same key is inserted multiple times. If you want <code>std::map</code>'s behaviour, use <code>std::map</code>.</p>\n<p>There is also a <code>std::multiset</code>.</p>\n<p>The rational: sometimes one would like to keep all old entries for the same key around as well. <em>[TBD: Insert some example here]</em></p>\n<p>Personally, I barely ever use <code>std::multimap</code>. If I want multiple entries for the same key, I usually rely on <code>std::map&lt;std::vector&lt;T&gt; &gt;</code>.</p>\n", "LastEditorUserId": "396551", "LastActivityDate": "2011-04-12T08:56:12.283", "Score": "10", "CreationDate": "2011-04-12T08:14:11.900", "ParentId": "5632194", "CommentCount": "8", "LastEditDate": "2011-04-12T08:56:12.283", "OwnerUserId": "396551"}, "5632194": {"ViewCount": "13323", "Body": "<p><strong>EDIT:</strong> <em>Please</em> note, I'm <strong>NOT</strong> asking why multimap can't contain duplicate <strong>keys</strong>.</p>\n<p>What's the rationale behind multimap allowing duplicate key-value pairs? (not <em>keys</em>)</p>\n<pre><code>#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nint\nmain(int argc, char** argv)\n{\n    std::multimap&lt;std::string, std::string&gt; m;\n    m.insert(std::make_pair(\"A\", \"B\"));\n    m.insert(std::make_pair(\"A\", \"B\"));\n    m.insert(std::make_pair(\"A\", \"C\"));\n    std::cout &lt;&lt; m.size() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>This printed 3, which somewhat surprised me, I expected multimap to behave like a set of <em>pairs</em>, so I was expecting 2.</p>\n<p>Intuitively, it's not consistent with C++ <code>std::map</code> behaviour, where <code>insert</code> does not always change the map (as opposed to <code>operator[]</code>). </p>\n<p>Is there a rationale behind it, or it's just arbitrary?</p>\n", "AcceptedAnswerId": "5632419", "Title": "Why does multimap allow duplicate key-value pairs?", "CreationDate": "2011-04-12T08:09:59.327", "Id": "5632194", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2011-04-12T08:42:41.577", "LastEditorUserId": "23643", "LastActivityDate": "2016-04-11T12:47:32.760", "Score": "16", "OwnerUserId": "23643", "Tags": "<c++><multimap>", "AnswerCount": "6"}});