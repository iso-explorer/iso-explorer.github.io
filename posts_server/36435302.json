post_cb({"36435400": {"ParentId": "36435302", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>An array designator in expressions is converted (with rare exception) to pointer to its first element.</p>\n<p>From the C Standard (6.3.2.1 Lvalues, arrays, and function designators)</p>\n<blockquote>\n<p id=\"so_36435302_36435400_0\">3 Except when it is the operand of the sizeof operator or the unary &amp;\n  operator, or is a string literal used to initialize an array, an\n  expression that has type \u2018\u2018array of type\u2019\u2019 is converted to an\n  expression with type \u2018\u2018pointer to type\u2019\u2019 that points to the initial\n  element of the array object and is not an lvalue. If the array object\n  has register storage class, the behavior is undefined.</p>\n</blockquote>\n<p>And from the C++ Standard (4.2 Array-to-pointer conversion)</p>\n<blockquote>\n<p id=\"so_36435302_36435400_1\">1 An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown\n  bound of T\u201d can be converted to a prvalue of type \u201cpointer to T\u201d. The\n  result is a pointer to the first element of the array.</p>\n</blockquote>\n<p>Thus this declaration</p>\n<pre><code>double *p1 = array;\n</code></pre>\n<p>is equivalent to</p>\n<pre><code>double *p1 = &amp;array[0];\n            ^^^\n</code></pre>\n<p>Consider this demonstrative program</p>\n<pre><code>$include &lt;iostream&gt;\n\nint main()\n{\n    double array[] = { 1000.0, 2.0, 3.4, 17.0, 50.0 };\n\n    std::cout &lt;&lt; \"sizeof( array ) = \" &lt;&lt; sizeof( array ) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"sizeof( array + 0 ) = \" &lt;&lt; sizeof( array + 0 ) &lt;&lt; std::endl;\n}    \n</code></pre>\n<p>The program output is</p>\n<pre><code>sizeof( array ) = 40\nsizeof( array + 0 ) = 8\n</code></pre>\n<p>In the first output statement the array designator is used as an operand of the <code>sizeof</code> operator. So there is no conversion from the type <code>double[5]</code> to <code>double *</code>.</p>\n<p>In the second output statement the array designator is used in expression <code>array + 0</code> that in turn is used as an operand of the <code>sizeof</code> operator. \nIn this case there is conversion from the type <code>double[5]</code> to the type <code>double *</code>. </p>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2016-04-05T19:50:11.210", "Id": "36435400", "Score": "1", "CreationDate": "2016-04-05T19:29:31.250", "LastActivityDate": "2016-04-05T19:50:11.210"}, "36435374": {"ParentId": "36435302", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>According to Bjarne Stroustrup's book - <a href=\"http://www.stroustrup.com/programming.html\" rel=\"nofollow\">Programming: Principles and Practice Using C++</a> name of an array refers to all elemnts of the array, so for example:</p>\n<pre><code>char ar[10];\nsizeof(ar) // 10\n</code></pre>\n<blockquote>\n<p id=\"so_36435302_36435374_0\">However, the name of an array turns into (\"decays to\") a pointer with\n  the slightest excuse.</p>\n</blockquote>\n<p>So this is why we can have: <code>char* c = ar</code>. Now <code>c</code> is initialized to <code>&amp;c[0]</code> (that is first element of an array) making <code>sizeof(c)</code> 4 (depending of implementation.</p>\n<p>As for variable it is just one element.</p>\n", "OwnerUserId": "1080517", "LastEditorUserId": "1080517", "LastEditDate": "2016-04-05T20:04:47.337", "Id": "36435374", "Score": "0", "CreationDate": "2016-04-05T19:28:07.657", "LastActivityDate": "2016-04-05T20:04:47.337"}, "36435302": {"CommentCount": "5", "ViewCount": "51", "PostTypeId": "1", "ClosedDate": "2016-04-05T19:44:09.473", "LastEditorUserId": "2877241", "LastActivityDate": "2016-04-05T20:04:47.337", "Body": "<p>Simple <a href=\"http://cpp.sh/8uljj\" rel=\"nofollow\">example</a>:</p>\n<pre><code>double array[] = {1000.0, 2.0, 3.4, 17.0, 50.0};\ndouble *p1 = array;\nprintf(\"p1: %f\\n\", *(p1));\n\nint x = 2;\nint* p2 = &amp;x;\nprintf(\"p2: %d\\n\", *p2);\n</code></pre>\n<p>why on p1 I need to use &amp; and on array I don't need this in c/c++? Is there a logic reason?</p>\n", "LastEditDate": "2016-04-05T19:43:46.817", "AcceptedAnswerId": "36435406", "Title": "Why on a single variable I need to specify the memory address while on array I don't need it?", "Id": "36435302", "Score": "0", "CreationDate": "2016-04-05T19:25:02.963", "Tags": "<c++><arrays><pointers><declaration><memory-address>", "OwnerUserId": "365251", "AnswerCount": "4"}, "36435406": {"ParentId": "36435302", "CommentCount": "0", "Body": "<p>You can think that array evaluates to a variable of type 'address' while x is a variable of type int. x is stored in a memory location and &amp;x gives you the address of that memory location. </p>\n<p>The address of the array, that is &amp;array will evaluate to the address of the first element and hence the address of the array itself.</p>\n", "OwnerUserId": "559095", "PostTypeId": "2", "Id": "36435406", "Score": "1", "CreationDate": "2016-04-05T19:29:41.163", "LastActivityDate": "2016-04-05T19:29:41.163"}, "36435376": {"ParentId": "36435302", "CommentCount": "0", "Body": "<p>Because an array decays to a pointer of it's declared type that points to the first element that the array holds.</p>\n", "OwnerUserId": "1870760", "PostTypeId": "2", "Id": "36435376", "Score": "0", "CreationDate": "2016-04-05T19:28:14.967", "LastActivityDate": "2016-04-05T19:28:14.967"}, "bq_ids": {"n4140": {"so_36435302_36435400_1": {"section_id": 11, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_36435302_36435400_1": {"section_id": 8, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_36435302_36435400_1": {"section_id": 12, "quality": 0.9444444444444444, "length": 17}}}});