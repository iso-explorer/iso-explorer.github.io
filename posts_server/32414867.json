post_cb({"32414941": {"Id": "32414941", "PostTypeId": "2", "Body": "<p>The relevant standardese is contained in \"Template Parameters [temp.param]\" (14.1).</p>\n<p>Essentially, a default argument may only be used if the parameter to which it applies is not followed by any non-pack parameters that do not have default arguments ([temp.param]/11). However, the  syntax you quoted is usable in a declaration in the situation described by  [temp.param]/10:</p>\n<blockquote>\n<p id=\"so_32414867_32414941_0\">The set of default template-arguments available for use is obtained by merging the default arguments from\n  all prior declarations of the template in the same way default function arguments are (8.3.6). [<em>Example</em>:</p>\n<pre><code>template&lt;class T1, class T2 = int&gt; class A;\ntemplate&lt;class T1 = int, class T2&gt; class A;\n</code></pre>\n<p id=\"so_32414867_32414941_1\">is equivalent to</p>\n<pre><code>template&lt;class T1 = int, class T2 = int&gt; class A;\n</code></pre>\n<p id=\"so_32414867_32414941_2\">\u2014 <em>end example</em>]</p>\n</blockquote>\n", "LastActivityDate": "2015-09-05T15:48:50.673", "CommentCount": "2", "CreationDate": "2015-09-05T15:48:50.673", "ParentId": "32414867", "Score": "3", "OwnerUserId": "596781"}, "bq_ids": {"n4140": {"so_32414867_32414941_0": {"length": 16, "quality": 0.7619047619047619, "section_id": 63}}, "n3337": {"so_32414867_32414941_0": {"length": 16, "quality": 0.7619047619047619, "section_id": 58}}, "n4659": {"so_32414867_32414941_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 65}}}, "45887712": {"Id": "45887712", "PostTypeId": "2", "Body": "<p>The word \"class\" is kind of hidden in your question, so I thought I'd mention (even though this isn't exactly an answer) that template parameters with defaults <em>can</em> be \"skipped\", sort of, in calls to <em>function</em> templates. Consider <a href=\"https://wandbox.org/permlink/cASrkeTcqVvobNp5\" rel=\"nofollow noreferrer\">this code</a>:</p>\n<pre><code>template&lt;class X, class Y = int, class Z&gt;\nvoid foo(X x, Y y, Z z) {\n    (void)x, (void)y, (void)z;\n    puts(__PRETTY_FUNCTION__);\n}\n\nint main()\n{\n    foo(3.14, {}, 1.45f);\n}\n</code></pre>\n<ul>\n<li>Template parameter <code>X</code> is deduced as <code>double</code> (and the default, if any, would go unused).</li>\n<li>Template parameter <code>Y</code> cannot be deduced in this call, so the default of <code>int</code> is used.</li>\n<li>Template parameter <code>Z</code> is deduced as <code>float</code>.</li>\n</ul>\n<p>Providing defaults for function template parameters happens a lot in the STL these days because of the undeduceability of <code>{}</code> in a function argument list. See for example <a href=\"http://en.cppreference.com/w/cpp/utility/exchange\" rel=\"nofollow noreferrer\"><code>std::exchange</code></a> or <a href=\"http://en.cppreference.com/w/cpp/utility/optional/optional\" rel=\"nofollow noreferrer\">constructor #8 of <code>std::optional</code></a>.</p>\n<p>You might expect that a similar trick could be used with constructor template argument deduction in C++17, but my experimentation suggests that this is <em>not</em> the case. In <em>class</em> template definitions, the compiler will produce a diagnostic if you put a template-parameter-with-default earlier in the list than a template-parameter-without-default.</p>\n<pre><code>template&lt;class X, class Y = int, class Z&gt;  // error!\nstruct Foo {};\n</code></pre>\n", "LastActivityDate": "2017-08-25T18:43:00.787", "CommentCount": "0", "CreationDate": "2017-08-25T18:43:00.787", "ParentId": "32414867", "Score": "0", "OwnerUserId": "1424877"}, "32414867": {"ViewCount": "256", "Body": "<p>I've been trying to find a way to skip a template parameter not located at the end of the template parameter list, in a derived class that has been assigned a default in its base class.</p>\n<p>I've done some research on this topic, also here on SO. While similar questions have been discussed on SO - many answers basically suggesting it doesn't work were related to very special cases like the hash map case <a href=\"https://stackoverflow.com/a/1276993/2852046\">here</a>. Also I found <a href=\"https://stackoverflow.com/a/2727120\">this</a> answer by \"Potatoswatter\", which in my opinion contradicts the impossibility of skipping such a parameter. In his answer he claims this declaration would be valid:</p>\n<pre><code>template&lt; class A, class B = int, class C &gt;\nclass X;\n</code></pre>\n<p>Assuming it is true that a template parameter may not be skipped (unless at the end of the argument list) such a declaration would make no sense at all. Since B is assigned a default value, but followed by C which has no default, in this case value B would always have to be assigned explicitly, rendering the assignment of int as default for B completely useless. The only scenario where the declaration of X above would make sense is one where one of the following declarations of Y would be valid:</p>\n<pre><code>class Y : public X&lt;double, , const std::string&amp;&gt; { ... }\n\nclass Y : public X&lt;A = double, C = const std::string&amp;&gt; { ... }\n</code></pre>\n<p>So is it really impossible to skip a template parameter that is not located at the end of the template parameter list when deriving a specialized class?</p>\n<p>If it is impossible why so, and why does legal syntax apparently suggest otherwise (see class X example above)?</p>\n<p>If it is in fact <em>not</em> impossible, how can one skip a template argument that has been assigned a default?</p>\n", "AcceptedAnswerId": "32414941", "Title": "Is it really impossible to skip template parameters with default arguments in C++, why does syntax suggest otherwise?", "CreationDate": "2015-09-05T15:40:31.263", "Id": "32414867", "CommentCount": "2", "LastEditDate": "2017-05-23T10:27:56.727", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2017-08-25T18:43:00.787", "Score": "1", "OwnerUserId": "2852046", "Tags": "<c++><templates><parameters><default>", "AnswerCount": "2"}});