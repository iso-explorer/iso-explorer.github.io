post_cb({"2280688": {"ViewCount": "18122", "Body": "<p>\u00a75.3.1 Unary operators, Section 3</p>\n<blockquote>\n<p id=\"so_2280688_2280688_0\">The result of the unary &amp; operator is a pointer to its operand. <strong>The operand shall be an lvalue</strong> or a qualified-id.</p>\n</blockquote>\n<p>What exactly does \"shall be\" mean in this context? Does it mean it's an error to take the address of a temporary? I was just wondering, because g++ only gives me a warning, whereas comeau refuses to compile the following program:</p>\n<pre><code>#include &lt;string&gt;\n\nint main()\n{\n    &amp;std::string(\"test\");\n}\n</code></pre>\n<p>g++ <strong>warning</strong>: <code>taking address of temporary</code></p>\n<p>comeau <strong>error</strong>: <code>expression must be an lvalue or a function designator</code></p>\n<p>Does anyone have a Microsoft compiler or other compilers and can test this program, please? Thanks in advance.</p>\n", "AcceptedAnswerId": "2281928", "Title": "taking the address of a temporary object", "CreationDate": "2010-02-17T12:51:24.327", "Id": "2280688", "CommentCount": "2", "FavoriteCount": "8", "PostTypeId": "1", "LastActivityDate": "2016-12-17T15:32:29.063", "Score": "17", "OwnerUserId": "252000", "Tags": "<c++><rvalue>", "AnswerCount": "6"}, "2280780": {"Id": "2280780", "PostTypeId": "2", "Body": "<p>It is permitted in MSVC with the deprecated /Ze (extensions enabled) option.  It was allowed in previous versions of MSVC.  It generates a diagnostic with all warnings enabled:</p>\n<blockquote>\n<p id=\"so_2280688_2280780_0\">warning C4238: nonstandard extension used : class rvalue used as lvalue.</p>\n</blockquote>\n<p>Unless the /Za option is used (enforce ANSI compatibility), then:</p>\n<blockquote>\n<p id=\"so_2280688_2280780_1\">error C2102: '&amp;' requires l-value</p>\n</blockquote>\n", "LastActivityDate": "2010-02-17T13:03:56.977", "CommentCount": "0", "CreationDate": "2010-02-17T13:03:56.977", "ParentId": "2280688", "Score": "4", "OwnerUserId": "17034"}, "2281831": {"Id": "2281831", "PostTypeId": "2", "Body": "<p>The C++ standard is a actually a requirement on conformant C++ implementations. At places it is written to distinguish between code that conformant implementations must accept and code for which conformant implementations must give a diagnostic.</p>\n<p>So, in this particular case, a conformant compiler <em>must</em> give a diagnostic if the address of an rvalue is taken. Both compilers do, so they are conformant in this respect.</p>\n<p>The standard does not forbid the generation of an executable if a certain input causes a diagnostic, i.e. warnings are valid diagnostics.</p>\n", "LastActivityDate": "2010-02-17T15:19:31.943", "CommentCount": "0", "CreationDate": "2010-02-17T15:19:31.943", "ParentId": "2280688", "Score": "1", "OwnerUserId": "15416"}, "2280795": {"Id": "2280795", "PostTypeId": "2", "Body": "<p><code>&amp;std::string(\"test\");</code> is asking for the address of the return value of the function call (we'll ignore as irrelevant the fact that this function is a ctor).  It didn't have an address until you assign it to something.  Hence it's an error.</p>\n", "LastActivityDate": "2010-02-17T13:05:03.567", "CommentCount": "4", "CreationDate": "2010-02-17T13:05:03.567", "ParentId": "2280688", "Score": "0", "OwnerUserId": "12725"}, "2280731": {"Id": "2280731", "PostTypeId": "2", "Body": "<p>I'm not a standards expert, but it certainly sounds like an error to me. g++ very often only gives a warning for things that are really errors.</p>\n", "LastActivityDate": "2010-02-17T12:58:07.043", "CommentCount": "0", "CreationDate": "2010-02-17T12:58:07.043", "ParentId": "2280688", "Score": "-1", "OwnerUserId": "264180"}, "bq_ids": {"n4140": {"so_2280688_2280688_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 6066}}, "n3337": {"so_2280688_2280688_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5834}}, "n4659": {"so_2280688_2280688_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 7562}}}, "2280718": {"Id": "2280718", "PostTypeId": "2", "Body": "<p>When the word \"shall\" is used in the C++ Standard, it means \"must on pain of death\" - if an implementation does not obey this, it is faulty.</p>\n", "OwnerDisplayName": "anon", "LastActivityDate": "2010-02-17T12:56:11.240", "Score": "4", "CreationDate": "2010-02-17T12:56:11.240", "ParentId": "2280688", "CommentCount": "11"}, "2281928": {"Id": "2281928", "PostTypeId": "2", "Body": "<p>The word \"shall\" in the standard language means a strict requirement. So, yes, your code is ill-formed (it is an error) because it attempts to apply address-of operator to a non-lvalue.</p>\n<p>However, the problem here is not an attempt of taking address of a <em>temporary</em>. The problem is, again, taking address of a <em>non-lvalue</em>. Temporary object can be lvalue or non-lvalue depending on the expression that produces that temporary or provides access to that temporary. In your case you have <code>std::string(\"test\")</code> - a functional style cast to a non-reference type, which by definition produces a non-lvalue. Hence the error.</p>\n<p>If you wished to take address of a temporary object, you could have worked around the restriction by doing this, for example</p>\n<pre><code>const std::string &amp;r = std::string(\"test\");\n&amp;r; // this expression produces address of a temporary\n</code></pre>\n<p>whith the resultant pointer remaining valid as long as the temporary exists. There are other ways to legally obtain address of a temporary object. It is just that your specific method happens to be illegal.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2016-12-17T15:32:29.063", "Score": "21", "CreationDate": "2010-02-17T15:29:21.360", "ParentId": "2280688", "CommentCount": "8", "OwnerUserId": "187690", "LastEditDate": "2016-12-17T15:32:29.063"}});