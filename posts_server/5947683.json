post_cb({"5947709": {"Id": "5947709", "PostTypeId": "2", "Body": "<p>For Input Iterators, incrementing an iterator invalidates copies of the same iterator.</p>\n<p>So:</p>\n<pre><code>auto a = istream_iterator&lt;whatever&gt;(something);\nauto b = a;\na == b; // true\n++a;    // b is now invalid\n++b;    // undefined behavior, I think, but in any case not guaranteed to\n        // result in anything sensible.\n</code></pre>\n<p>So certainly <code>++a == ++b</code> is not guaranteed. That is, <code>a == b</code> does not imply <code>++a == ++b</code>.</p>\n<p>I think the \"substitution property\" means \"anything you do with the value of <code>a</code> has the same result as doing the same with the value of <code>b</code>\", or similar - there are various versions of substitution that it might refer to, but something along those lines. I think in this context it must mean \"<em>later</em> doing the same with <code>b</code>\", since if <code>a == b</code> and I haven't done anything invalid yet, then it doesn't matter which of <code>a</code> and <code>b</code> I use, they refer to the same point in the stream. But when I increment, I do have to pick one and lose the other, hence the difficulty with <code>++a == ++b</code>.</p>\n<p>\"Referential transparency\" means that different objects are independent, i.e. they're not references/pointers to or aliases of each other. In combination with \"substitution property\" this means:</p>\n<blockquote>\n<p id=\"so_5947683_5947709_0\">Later? There is no <em>earlier</em> or\n  <em>later</em> since operations don't have global side-effects. If you can't\n  substitute \"later\" then you\n  can't substitute</p>\n</blockquote>\n<p>Input iterators in the same sequence typically refer to the same \"actual data\", like a file handle or whatever, which itself contains mutable state. Since <code>a</code> and <code>b</code> refer to the same file handle, and their value is dependent on its state, you don't have referential transparency. This lack is <em>why</em> substitution fails.</p>\n<p>Forward iterators typically <em>also</em> refer to the same underlying data (like a container), but as long as you use them read-only (and don't otherwise modify the container), they don't betray this fact, at least not until you start comparing the addresses of the values they return. So they have a limited kind of referential transparency <em>of their own value</em>, that input iterators don't. They're still references themselves, so the things they refer to are still aliased.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2011-05-10T17:09:44.057", "Score": "9", "CreationDate": "2011-05-10T09:04:10.193", "ParentId": "5947683", "CommentCount": "8", "OwnerUserId": "13005", "LastEditDate": "2011-05-10T17:09:44.057"}, "5947804": {"Id": "5947804", "PostTypeId": "2", "Body": "<p>Consider that an input iterator could be connected to a stream reading from the keyboard. Incrementing the iterator means reading the next character. </p>\n<p>Also incrementing a copy of the iterator does not mean reading the same character.</p>\n", "LastActivityDate": "2011-05-10T09:12:04.267", "CommentCount": "0", "CreationDate": "2011-05-10T09:12:04.267", "ParentId": "5947683", "Score": "1", "OwnerUserId": "597607"}, "5947725": {"Id": "5947725", "PostTypeId": "2", "Body": "<p>As the explanation says: \u201cThey should be single pass algorithms.\u201d</p>\n<p>The point is that an iterator on an input stream represents a transient state. Once the iterator is changed, that state no longer exists; all other iterators representing that state are invalidated: once you increment <code>a</code>, the iterator <code>b</code> becomes invalid.</p>\n", "LastActivityDate": "2011-05-10T09:05:11.220", "CommentCount": "0", "CreationDate": "2011-05-10T09:05:11.220", "ParentId": "5947683", "Score": "6", "OwnerUserId": "1968"}, "5951860": {"Id": "5951860", "PostTypeId": "2", "Body": "<p>The properties referred to are:</p>\n<p><em>Substitution Property</em></p>\n<blockquote>\n<p id=\"so_5947683_5951860_0\">For any quantities a and b and any expression F(x), if a = b, then F(a) = F(b) (if either side makes sense, i.e. is well-formed).</p>\n</blockquote>\n<p><em><a href=\"http://en.wikipedia.org/wiki/Referential_transparency_%28computer_science%29\" rel=\"nofollow\">Referential Transparency</a></em></p>\n<p>Informally, it means that there is no difference between a value and a reference to this value (thus how the term was coined).</p>\n<p>In imperative programming it is a difficult concept to get, because we are used to modify our variables. Rick Hickey (behind Clojure) gives a nice talk about the <a href=\"http://clojure.org/state\" rel=\"nofollow\">distinction between Identity and State</a> that may help you. The gist of it is that a variable is an Identity. At any point in time an Identity refers to a State. A State never changes, however an Identity may be altered to refer to another State.</p>\n<p><em>Input Iterators</em></p>\n<p>The <em>substitution property</em> violation is \"obvious\" here, if we define <code>F(x)</code> in the above to mean <code>++x</code>, then we have that if input iterators verified the substitution property, the following would hold <code>a == b =&gt; ++a == ++b</code>.</p>\n<p>This is not true, however, because incrementing an input iterator may invalidate all other input iterators from the same source. From table 107 in n3290 (page 831, just above the paragraph you quoted): </p>\n<blockquote>\n<p id=\"so_5947683_5951860_1\">++r</p>\n<p id=\"so_5947683_5951860_2\">pre: r is dereferenceable.</p>\n<p id=\"so_5947683_5951860_3\">post: r is dereferenceable or r is past-the-end.</p>\n<p id=\"so_5947683_5951860_4\">post: any copies of the previous value of r are no longer required either to be\n  dereferenceable or to be in the domain of ==.</p>\n</blockquote>\n<p>That is, when we perform <code>++a</code>, then <code>b</code> may become invalid, and therefore <code>++b</code> itself will be undefined behavior.</p>\n<p>This is a direct violation of <code>++a == ++b</code>, therefore the <em>substitution property</em> does not hold.</p>\n<p>The <em>referential transparency</em> is a bit more evident here. If Input Iterators were referentially transparent, it would mean that they would be indifferentiable from the value they point to. Clearly this is not the case, as applying <code>++</code> does not increment the value, but the iterator.</p>\n", "LastActivityDate": "2011-05-10T14:44:10.887", "CommentCount": "5", "CreationDate": "2011-05-10T14:44:10.887", "ParentId": "5947683", "Score": "3", "OwnerUserId": "147192"}, "bq_ids": {"n4140": {"so_5947683_5947683_1": {"length": 7, "quality": 1.0, "section_id": 5570}, "so_5947683_5951860_4": {"length": 9, "quality": 1.0, "section_id": 5569}, "so_5947683_5947683_0": {"length": 38, "quality": 0.9047619047619048, "section_id": 5570}}, "n3337": {"so_5947683_5947683_1": {"length": 7, "quality": 1.0, "section_id": 5352}, "so_5947683_5951860_4": {"length": 9, "quality": 1.0, "section_id": 5351}, "so_5947683_5947683_0": {"length": 38, "quality": 0.9047619047619048, "section_id": 5352}}, "n4659": {"so_5947683_5947683_1": {"length": 7, "quality": 1.0, "section_id": 7017}, "so_5947683_5951860_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 7016}, "so_5947683_5947683_0": {"length": 38, "quality": 0.9047619047619048, "section_id": 7017}}}, "5947774": {"Id": "5947774", "PostTypeId": "2", "Body": "<p>Input iterators define a sequence which can only be read once; input\nfrom a keyboard or a pipe would be a good example.  Incrementing an\n<code>istream_iterator</code> effectively means reading further in the <code>istream</code>,\nextracting characters, so other <code>istream_iterator</code> on the same stream\nwill no longer be valid with regards to their position.  Imagine\na stream of characters <code>\"abcdefg...\"</code> (the alphabet, in sum), with two\n<code>istream_iterator&lt;char&gt;</code> pointing to the <code>'a'</code>.  Incrementing one of\nthem will cause the <code>'b'</code> to be read from the stream, and no other\niterator can ever see it.</p>\n", "LastActivityDate": "2011-05-10T09:09:52.443", "CommentCount": "0", "CreationDate": "2011-05-10T09:09:52.443", "ParentId": "5947683", "Score": "2", "OwnerUserId": "649665"}, "5947683": {"ViewCount": "508", "Body": "<p>\u00a724.1.1/3 from C++03 Standard reads,</p>\n<blockquote>\n<p id=\"so_5947683_5947683_0\"><strong>For input iterators, a == b does not imply ++a == ++b.</strong> (<em>Equality does not\n  guarantee the substitution property or\n  referential transparency.</em>) Algorithms\n  on input iterators should never\n  attempt to pass through the same\n  iterator twice. They should be single\n  pass algorithms. Value type T is not\n  required to be an Assignable type\n  (23.1). These algorithms can be used\n  with istreams as the source of the\n  input data through the\n  istream_iterator class.</p>\n</blockquote>\n<p>I couldn't understand the bold text in the above quotation. Can anyone help me understanding this?</p>\n<p>Also, what does the following statement (italicized text in the above quotation) mean? How is it related to <code>a==b</code> and <code>++a==++b</code> expressions?</p>\n<blockquote>\n<p id=\"so_5947683_5947683_1\">Equality does not\n  guarantee the substitution property or\n  referential transparency.</p>\n</blockquote>\n", "AcceptedAnswerId": "5951860", "Title": "For input iterators, why a == b does not imply ++a == ++b?", "CreationDate": "2011-05-10T09:01:54.420", "Id": "5947683", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-05-13T04:48:54.977", "LastEditorUserId": "415784", "LastActivityDate": "2011-05-13T04:48:54.977", "Score": "14", "OwnerUserId": "415784", "Tags": "<c++><stl><iterator>", "AnswerCount": "5"}});