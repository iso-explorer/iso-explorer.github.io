post_cb({"44413900": {"ParentId": "44294743", "PostTypeId": "2", "CommentCount": "17", "CreationDate": "2017-06-07T13:21:35.290", "Score": "9", "LastEditorUserId": "8005438", "LastEditDate": "2017-06-09T21:50:05.537", "Id": "44413900", "OwnerUserId": "8005438", "Body": "<p>Because when there is a template parameter involved, <code>decltype</code> returns an unqiue dependent type according to the standard, see below. If there is no template parameter then it resolves to an obvious <code>size_t</code>. So in this case you have to choose either both declaration and definition have an independent expression (e.g. <code>size_t/decltype(sizeof(int))</code>), as a return type, or both have dependent expression (e.g. <code>decltype(sizeof(T))</code>), which resolved to an unique dependent type and considered to be equivalent, if their expressions are equivalent (see below).</p>\n<p>In this post I am using the C++ standard draft <a href=\"https://github.com/cplusplus/draft/blob/master/papers/n3337.pdf\" rel=\"nofollow noreferrer\">N3337</a>.</p>\n<blockquote>\n<p id=\"so_44294743_44413900_0\"><strong>\u00a7 7.1.6.2 [dcl.type.simpl]</strong></p>\n<p id=\"so_44294743_44413900_1\">\u00b6 4</p>\n<p id=\"so_44294743_44413900_2\">The type denoted by decltype(e) is defined as follows:\n  \u2014 if e is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), decltype(e)\n  is the type of the entity named by e. If there is no such entity, or if e names a set of overloaded func-\n  tions, the program is ill-formed;</p>\n<p id=\"so_44294743_44413900_3\">\u2014 otherwise, if e is an xvalue, decltype(e) is T&amp;&amp;, where T is the type of e;</p>\n<p id=\"so_44294743_44413900_4\">\u2014 otherwise, if e is an lvalue, decltype(e) is T&amp;, where T is the type of e;</p>\n<p id=\"so_44294743_44413900_5\">\u2014 otherwise, <strong>decltype(e) is the type of e</strong>.</p>\n</blockquote>\n<p>This explains what is <code>decltype(sizeof(int))</code>. But for <code>decltype(sizeof(T))</code> there is another section explaining what it is.</p>\n<blockquote>\n<p id=\"so_44294743_44413900_6\"><strong>\u00a7 14.4 [temp.type]</strong></p>\n<p id=\"so_44294743_44413900_7\">\u00b6 2</p>\n<p id=\"so_44294743_44413900_8\">If an expression e involves a template parameter, decltype(e) denotes a <strong>unique dependent type</strong>. Two such\n  decltype-specifiers refer to the same type only if their expressions are equivalent (14.5.6.1). [ Note: however,\n  it may be aliased, e.g., by a typedef-name. \u2014 end note ]</p>\n</blockquote>\n<p>In Clang LLVM sources version 3.9 in file <code>lib/AST/Type.cpp</code></p>\n<pre><code>DecltypeType::DecltypeType(Expr *E, QualType underlyingType, QualType can)\n  // C++11 [temp.type]p2: \"If an expression e involves a template parameter,\n  // decltype(e) denotes a unique dependent type.\" Hence a decltype type is\n  // type-dependent even if its expression is only instantiation-dependent.\n  : Type(Decltype, can, E-&gt;isInstantiationDependent(),\n         E-&gt;isInstantiationDependent(),\n         E-&gt;getType()-&gt;isVariablyModifiedType(),\n         E-&gt;containsUnexpandedParameterPack()),\n</code></pre>\n<p>The important phrase starts as \"Hence a decltype...\". It again clarifies the situation.</p>\n<p>Again in Clang sources version 3.9 in file <code>lib/AST/ASTContext.cpp</code></p>\n<pre><code>QualType ASTContext::getDecltypeType(Expr *e, QualType UnderlyingType) const {\n  DecltypeType *dt;\n\n  // C++11 [temp.type]p2:\n  //   If an expression e involves a template parameter, decltype(e) denotes a\n  //   unique dependent type. Two such decltype-specifiers refer to the same\n  //   type only if their expressions are equivalent (14.5.6.1).\n  if (e-&gt;isInstantiationDependent()) {\n    llvm::FoldingSetNodeID ID;\n    DependentDecltypeType::Profile(ID, *this, e);\n\n    void *InsertPos = nullptr;\n    DependentDecltypeType *Canon\n      = DependentDecltypeTypes.FindNodeOrInsertPos(ID, InsertPos);\n    if (!Canon) {\n      // Build a new, canonical typeof(expr) type.\n      Canon = new (*this, TypeAlignment) DependentDecltypeType(*this, e);\n      DependentDecltypeTypes.InsertNode(Canon, InsertPos);\n    }\n    dt = new (*this, TypeAlignment)\n        DecltypeType(e, UnderlyingType, QualType((DecltypeType *)Canon, 0));\n  } else {\n    dt = new (*this, TypeAlignment)\n        DecltypeType(e, UnderlyingType, getCanonicalType(UnderlyingType));\n  }\n  Types.push_back(dt);\n  return QualType(dt, 0);\n}\n</code></pre>\n<p>So you see Clang gathers and picks those unique dependent types of <code>decltype</code> in/from a special set.</p>\n<p>Why compiler is so stupid that it does not see that the expression of <code>decltype</code> is <code>sizeof(T)</code> that is always <code>size_t</code>? Yes, this is obvious to a human reader. But when you design and implement a formal grammar and semantic rules, especially for such complicated languages as C++, you have to group problems up and define the rules for them, rather than just come up with a rule for each particular problem, in the latter way you just wont be able to move with your language/compiler design. The same here there is no just rule: if <code>decltype</code> has a function call expression that does not need any template parameters resolution - resolve <code>decltype</code> to the return type of the function. There is more than that, there are so many cases you need to cover, that you come up with a more generic rule, like the quoted above from the standard (<code>14.4[2]</code>).</p>\n<p>In addition, a similar non-obvious case with <code>auto</code>, <code>decltype(auto)</code> found by AndyG in C++-14 (N4296, \u00a7 7.1.6.4 [dcl.spec.auto] 12/13):</p>\n<blockquote>\n<p id=\"so_44294743_44413900_9\"><strong>\u00a7 7.1.6.4 [dcl.spec.auto]</strong></p>\n<p id=\"so_44294743_44413900_10\">\u00b6 13</p>\n<p id=\"so_44294743_44413900_11\">Redeclarations or specializations of a function or function template with a declared return type that uses a\n  placeholder type shall also use that placeholder, not a deduced type. [ Example:</p>\n<pre><code>auto f();\nauto f() { return 42; } // return type is int\nauto f();               // OK\nint f();                // error, cannot be overloaded with auto f()\ndecltype(auto) f();     // error, auto and decltype(auto) don\u2019t match\n</code></pre>\n</blockquote>\n<h1>Changes in C++17, Document Number &gt;= N4582</h1>\n<p>Change in the standard draft N4582 from March 2016 (thanks to bogdan) generalizes the statement:</p>\n<blockquote>\n<p id=\"so_44294743_44413900_12\"><strong>\u00a7 17.4 (old \u00a7 14.4) [temp.type]</strong></p>\n<p id=\"so_44294743_44413900_13\">\u00b6 2</p>\n<p id=\"so_44294743_44413900_14\">If an expression e is <strong>type-dependent (17.6.2.2)</strong>, decltype(e) denotes a unique dependent type. Two such\n  decltype-specifiers refer to the same type only if their expressions are equivalent (17.5.6.1). [ Note: however,\n  such a type may be aliased, e.g., by a typedef-name. \u2014 end note ]</p>\n</blockquote>\n<p>This change leads to another section describing the type dependent expression that looks quite strange to our particular case.</p>\n<blockquote>\n<p id=\"so_44294743_44413900_15\"><strong>\u00a7 17.6.2.2 [temp.dep.expr] (old \u00a7 14.6.2.2)</strong></p>\n<p id=\"so_44294743_44413900_16\">\u00b6 4</p>\n<p id=\"so_44294743_44413900_17\">Expressions of the following forms are never type-dependent (because the type of the expression cannot be\n  dependent):</p>\n<pre><code>...\nsizeof ( type-id )\n...\n</code></pre>\n</blockquote>\n<p>There are further sections on value-dependent expressions where <code>sizeof</code> can be value-dependent if the <code>type-id</code> dependent. There is no relation between value-dependent expression and <code>decltype</code>. After some thinking, I did not find any reason why <code>decltype(sizeof(T))</code> must not or cannot resolve into <code>size_t</code>. And I would assume that was quite sneaky change (\"involves a template parameter\" to \"type-dependent\") in the standard that compiler developers did not pay much attention to (maybe overwhelmed by many other changes, maybe did not think that it might actually change something, just a simple formulation improvement). The change does make sense, because <code>sizeof(T)</code> is not type-dependent, it is value-dependent. <code>decltype(e)</code>'s operand is a unevaluated operand, i.e. does not care about value, only about type. That is why <code>decltype</code> returns a unique type only when <code>e</code> is type-dependent. <code>sizeof(e)</code> might be only value-dependent.</p>\n<p>I tried the code with clang 5, gcc 8 <code>-std=c++1z</code> - the same result: error. I went further and tried this code:</p>\n<pre><code>template &lt;typename&gt;\nstruct Cls {\n  static std::size_t f();\n};\n\ntemplate &lt;typename T&gt;\ndecltype(sizeof(sizeof(T))) Cls&lt;T&gt;::f() {\n  return 0;\n}\n</code></pre>\n<p>The same error was given, even that <code>sizeof(sizeof(T))</code> is neither type- or value-dependent (see <a href=\"https://stackoverflow.com/questions/27713222/can-sizeof-nested-twice-ever-be-a-dependent-expression\">this post</a>). This gives me a reason to assume that the compilers are working in an old way of C++-11/14 standard (i.e. \"involves a template parameter\") like in the source snippet above from clang 3.9 source (I can verify that the latest developing clang 5.0 has the same lines, have not found anything related to this new change in the standard), but not type-dependent.</p>\n", "LastActivityDate": "2017-06-09T21:50:05.537"}, "44294743": {"CommentCount": "15", "AcceptedAnswerId": "44413900", "PostTypeId": "1", "LastEditorUserId": "1013719", "CreationDate": "2017-05-31T21:11:34.157", "LastActivityDate": "2017-06-09T21:50:05.537", "LastEditDate": "2017-06-06T22:50:22.393", "ViewCount": "574", "FavoriteCount": "7", "Title": "Dependent type or argument in decltype in function definition fails to compile when declared without decltype", "Id": "44294743", "Score": "28", "Body": "<p>I've been playing with deduced return types in definitions that resolve to the same type as the declaration. This works:</p>\n<pre><code>template &lt;typename&gt;\nstruct Cls {\n  static std::size_t f();\n};\n\ntemplate &lt;typename T&gt;\ndecltype(sizeof(int)) Cls&lt;T&gt;::f()  { return 0; }\n</code></pre>\n<p>But if I change the definition to something that should be equivalent by replacing <code>sizeof(int)</code> with <code>sizeof(T)</code> <a href=\"https://wandbox.org/permlink/ojdeesqU3Z9Bs1NU\" rel=\"noreferrer\">it fails</a></p>\n<pre><code>template &lt;typename T&gt;\ndecltype(sizeof(T)) Cls&lt;T&gt;::f() { return 0; }\n</code></pre>\n<p>gcc's error (clang is almost identical):</p>\n<pre><code>error: prototype for \u2018decltype (sizeof (T)) Cls&lt;T&gt;::f()\u2019 does not match any in class \u2018Cls&lt;T&gt;\u2019\n decltype(sizeof(T)) Cls&lt;T&gt;::f() { return 0; }\n                     ^~~~~~\nso.cpp:4:24: error: candidate is: static std::size_t Cls&lt;T&gt;::f()\n     static std::size_t f();\n                        ^\n</code></pre>\n<p>The same problem arises with function parameter types:</p>\n<pre><code>template &lt;typename&gt;\nstruct Cls {\n  static void f(std::size_t);\n};\n\ntemplate &lt;typename T&gt;\nvoid Cls&lt;T&gt;::f(decltype(sizeof(T))) { } // sizeof(int) works instead\n</code></pre>\n<p>Stranger yet, if the declaration and definition match and <em>both</em> use <code>decltype(sizeof(T))</code> it compiles successfully, and I can <code>static_assert</code> that the return type is <code>size_t</code>. The following compiles successfully:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename T&gt;\nstruct Cls {\n  static decltype(sizeof(T)) f();\n};\n\ntemplate &lt;typename T&gt;\ndecltype(sizeof(T)) Cls&lt;T&gt;::f() { return 0; }\n\nstatic_assert(std::is_same&lt;std::size_t, decltype(Cls&lt;int&gt;::f())&gt;{}, \"\");\n</code></pre>\n<hr>\n<p>Update with another example. This isn't a dependent type but still fails.</p>\n<pre><code>template &lt;int I&gt;\nstruct Cls {\n  static int f();\n};\n\ntemplate &lt;int I&gt;\ndecltype(I) Cls&lt;I&gt;::f() { return I; }\n</code></pre>\n<p>If I use <code>decltype(I)</code> in both the definition and declaration it works, if I use <code>int</code> in both the definition and declaration it works, but having the two differ fails.</p>\n<hr>\n<p>Update 2:\nA similar example. If <code>Cls</code> is changed to not be a class template, it compiles successfully.</p>\n<pre><code>template &lt;typename&gt;\nstruct Cls {\n  static int f();\n  using Integer = decltype(Cls::f());\n};\n\ntemplate &lt;typename T&gt;\ntypename Cls&lt;T&gt;::Integer Cls&lt;T&gt;::f() { return I; }\n</code></pre>\n<hr>\n<p>Update 3:\nAnother failing example from M.M. A templated member function of a non-templated class.</p>\n<pre><code>struct S {\n  template &lt;int N&gt;\n  int f();\n};\n\ntemplate &lt;int N&gt;\ndecltype(N) S::f() {}\n</code></pre>\n<hr>\n<p>Why is it illegal for the declaration and definition to disagree with a dependent type only? Why is it affected even when the type itself isn't dependent as with the <code>template &lt;int I&gt;</code> above?</p>\n</hr></hr></hr></hr>", "Tags": "<c++><c++11><templates><language-lawyer>", "OwnerUserId": "1013719", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44294743_44413900_11": {"section_id": 5457, "quality": 0.9411764705882353, "length": 16}, "so_44294743_44413900_4": {"section_id": 5440, "quality": 1.0, "length": 5}, "so_44294743_44413900_3": {"section_id": 5440, "quality": 1.0, "length": 5}, "so_44294743_44413900_17": {"section_id": 203, "quality": 1.0, "length": 10}, "so_44294743_44413900_8": {"section_id": 96, "quality": 0.8461538461538461, "length": 22}, "so_44294743_44413900_2": {"section_id": 5440, "quality": 0.8461538461538461, "length": 22}, "so_44294743_44413900_14": {"section_id": 96, "quality": 0.7037037037037037, "length": 19}}, "n3337": {"so_44294743_44413900_14": {"section_id": 91, "quality": 0.7037037037037037, "length": 19}, "so_44294743_44413900_17": {"section_id": 197, "quality": 1.0, "length": 10}, "so_44294743_44413900_3": {"section_id": 5235, "quality": 1.0, "length": 5}, "so_44294743_44413900_8": {"section_id": 91, "quality": 0.8461538461538461, "length": 22}, "so_44294743_44413900_2": {"section_id": 5235, "quality": 0.8461538461538461, "length": 22}, "so_44294743_44413900_4": {"section_id": 5235, "quality": 1.0, "length": 5}}, "n4659": {"so_44294743_44413900_11": {"section_id": 6883, "quality": 0.9411764705882353, "length": 16}, "so_44294743_44413900_14": {"section_id": 100, "quality": 0.7777777777777778, "length": 21}, "so_44294743_44413900_3": {"section_id": 6867, "quality": 1.0, "length": 5}, "so_44294743_44413900_8": {"section_id": 100, "quality": 0.6923076923076923, "length": 18}, "so_44294743_44413900_2": {"section_id": 6867, "quality": 0.8461538461538461, "length": 22}, "so_44294743_44413900_4": {"section_id": 6867, "quality": 1.0, "length": 5}, "so_44294743_44413900_17": {"section_id": 209, "quality": 1.0, "length": 10}}}});