post_cb({"bq_ids": {"n4140": {"so_18759692_18759792_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 955}}, "n3337": {"so_18759692_18759792_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 943}}}, "18759692": {"ViewCount": "1304", "Body": "<p>Is the following code ok?:</p>\n<pre><code>std::vector&lt;char&gt; var;\nsize_t requiredSize;\n\ngetenv_s(&amp;requiredSize, NULL, 0, \"Something\");\nif (requiredSize == 0)\n{\n   return ENV_NOT_EXIST;\n}\nif(var.size() &lt; requiredSize)\n    var.resize(requiredSize);\n\n// Get the value of the environment variable.\ngetenv_s(&amp;requiredSize, &amp;var[0], requiredSize, \"Something\");\n\nstd::string str(var.begin(),var.end());\n</code></pre>\n<p>If this code is OK, can someone please explain me how the <code>begin()</code> and the <code>end()</code> values of the <code>var</code> vector are updated? it looks like this code changes directly the internal array of the vector, not over the <code>std::vector</code> api - so how these values are updated to the actual size?</p>\n", "AcceptedAnswerId": "18759792", "Title": "STD::Vector- write directly to the internal array", "CreationDate": "2013-09-12T08:52:58.040", "Id": "18759692", "CommentCount": "3", "LastEditDate": "2013-09-12T09:05:36.353", "PostTypeId": "1", "LastEditorUserId": "1056003", "LastActivityDate": "2013-09-12T09:32:27.133", "Score": "2", "OwnerUserId": "493371", "Tags": "<c++><vector><stdvector>", "AnswerCount": "1"}, "18759792": {"PostTypeId": "2", "Body": "<p><code>std::vector</code> guarantees data to be stored contiguously, so writing to data, as long as you do not overrun the end is perfectly fine:</p>\n<p>From the C++11 standard section 23.3.6.1.1:</p>\n<blockquote>\n<p id=\"so_18759692_18759792_0\">The elements of a vector are stored contiguously, meaning that if v is\n  a vector where T is some type other than bool, then it\n  obeys the identity &amp;v[n] == &amp;v[0] + n for all 0 &lt;= n &lt; v.size().</p>\n</blockquote>\n<p>However, note that resizing the vector might move the data and invalidate iterators.</p>\n<p>Unfortunately, the standard does not require <code>std::vector&lt;T&gt;::iterator</code> to be a raw pointer type (although it usually is). So, you cannot portably use <code>std::vector&lt;T&gt;::begin()</code> to access the first element. There is <code>std::vector&lt;T&gt;::data()</code>, which returns a pointer to the first element and which can be used for code that expects raw c-arrays.</p>\n<p>I suggest to rewrite your call like this:</p>\n<pre><code>getenv_s(&amp;requiredSize, var.data(), var.size(), \"Something\");\nif (requiredSize &lt; var.size())\n  var.resize(requiredSize);\n</code></pre>\n", "LastActivityDate": "2013-09-12T09:32:27.133", "LastEditorUserId": "430766", "Id": "18759792", "CommentCount": "7", "CreationDate": "2013-09-12T08:57:12.550", "ParentId": "18759692", "Score": "2", "OwnerUserId": "430766", "LastEditDate": "2013-09-12T09:32:27.133"}});