post_cb({"7364106": {"Id": "7364106", "PostTypeId": "2", "Body": "<p>As mentioned before, it depends on the compiler implementation.</p>\n<p>But, usually each time a programmer adds a new method, is stored in code, even if there is another method with the same id. elsewhere (\"overriden\" or \"overloaded\").</p>\n<p>The code for each method is stored only once, so if a class inherits and uses the same method from a parent class, internally, its uses a pointer to the code, it doesn't duplicates the code.</p>\n<p>If a parent class defines a virtual method, and if a child class overrides it, both methods are stored. Each class has something called \"Virtual Method Table\" where there is a table of pointers to each method.</p>\n<p>Don't worry about performance, the compiler doesn't duplicate code for methods.</p>\n", "LastActivityDate": "2011-09-09T15:38:53.477", "Score": "0", "CreationDate": "2011-09-09T15:38:53.477", "ParentId": "7360752", "CommentCount": "0", "OwnerUserId": "535724"}, "7360752": {"ViewCount": "3836", "Body": "<p>How the compilers implement the virtual inheritance?</p>\n<p>In the following code:</p>\n<pre><code>class A {\n  public:\n    A(int) {}\n};\n\nclass B : public virtual A {\n  public:\n    B() : A(1) {}\n};\n\nclass C : public B {\n  public:\n    C() : A(3), B() {}\n};\n</code></pre>\n<p>Does a compiler generate two instance of <code>B::ctor</code> function, one without <code>A(1)</code> call, and one with it? So when <code>B::constructor</code> is called from derived class's constructor the first instance is used, otherwise the second.</p>\n", "AcceptedAnswerId": "7361019", "Title": "How C++ virtual inheritance is implemented in compilers?", "CreationDate": "2011-09-09T11:08:57.727", "Id": "7360752", "CommentCount": "2", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2017-10-18T03:06:05.553", "LastEditorUserId": "3745896", "LastActivityDate": "2017-10-18T03:06:05.553", "Score": "20", "OwnerUserId": "653478", "Tags": "<c++><inheritance><compiler-construction><virtual-inheritance>", "AnswerCount": "5"}, "7361019": {"Id": "7361019", "PostTypeId": "2", "Body": "<p>It's implementation-dependent. GCC (see <a href=\"https://stackoverflow.com/questions/6921295/dual-emission-of-constructor-symbols\">this question</a>), for example, will emit two constructors, one with a call to <code>A(1)</code>, another one without.</p>\n<pre><code>B1()\nB2() // no A\n</code></pre>\n<p>When B is constructed, the \"full\" version is called:</p>\n<pre><code>B1():\n    A(1)\n    B() body\n</code></pre>\n<p>When C is constructed, the base version is called instead:</p>\n<pre><code>C():\n    A(3)\n    B2()\n       B() body\n    C() body\n</code></pre>\n<p>In fact, two constructors will be emitted even if there is no virtual inheritance, and they will be identical.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-09-09T11:33:55.917", "Score": "8", "CreationDate": "2011-09-09T11:33:55.917", "ParentId": "7360752", "CommentCount": "0", "LastEditDate": "2017-05-23T10:29:52.607", "OwnerUserId": "23643"}, "7360821": {"Id": "7360821", "PostTypeId": "2", "Body": "<p>The compiler does not create another constructor of B - but it ignores the <code>A(1)</code>. Since <code>A</code> is virtually inherited, it is constructed first, with its default constructor. And since it's already constructed when <code>B()</code> is invoked, the <code>A(1)</code> part is ignored.</p>\n<p>Edit - I missed the <code>A(3)</code> part in <code>C</code>'s constructor initialization list. When virtual inheritance is used, only the most derived class initializes the virtual base classes. So <code>A</code> will be constructed with <code>A(3)</code> and not its default constructor. The rest still stands - any initializations of <code>A</code> by an intermediate class (here <code>B</code>) are ignored.</p>\n<p>Edit 2, trying to answer the actual question regarding the implementation of the above:</p>\n<p>In Visual Studio (at least 2010), a flag is used instead of having two implementations of <code>B()</code>. Since <code>B</code> virtually inherits from <code>A</code>, before it calls <code>A</code>'s constructor, the flag is checked. If the flag is not set, the call to <code>A()</code> is skipped. Then, in every class deriving from <code>B</code>, the flag is reset after it initializes <code>A</code>. The same mechanism is used to prevent <code>C</code> from initializing <code>A</code> if it's part of some <code>D</code> (if <code>D</code> inherits from <code>C</code>,  <code>D</code> will initialize <code>A</code>).</p>\n", "LastEditorUserId": "26039", "LastActivityDate": "2011-09-09T13:19:50.360", "Score": "7", "CreationDate": "2011-09-09T11:15:31.713", "ParentId": "7360752", "CommentCount": "5", "LastEditDate": "2011-09-09T13:19:50.360", "OwnerUserId": "26039"}, "11814437": {"Id": "11814437", "PostTypeId": "2", "Body": "<p>The <a href=\"http://mentorembedded.github.com/cxx-abi/abi.html\" rel=\"nofollow\">Itanium C++ ABI</a> is a useful resource for all questions like \"how could this be implemented by C++ compilers\".</p>\n<p>In particular <a href=\"http://mentorembedded.github.com/cxx-abi/abi.html#mangling-special\" rel=\"nofollow\">5.1.4 Other Special Functions and Entities</a> list different special member functions for different purposes:</p>\n<blockquote id=\"so_7360752_11814437_0\">\n<pre><code>&lt;ctor-dtor-name&gt; ::= C1   # complete object constructor\n             ::= C2   # base object constructor\n             ::= C3   # complete object allocating constructor\n             ::= D0   # deleting destructor\n             ::= D1   # complete object destructor\n             ::= D2   # base object destructor\n</code></pre>\n</blockquote>\n<p>The <a href=\"http://mentorembedded.github.com/cxx-abi/abi.html#definitions\" rel=\"nofollow\">1.1 Definitions</a> section is useful (but not complete):</p>\n<blockquote>\n<p id=\"so_7360752_11814437_1\"><strong>base object destructor of a class T</strong></p>\n<p id=\"so_7360752_11814437_2\">A function that runs the destructors for non-static data members of T and non-virtual direct base classes of T.</p>\n<p id=\"so_7360752_11814437_3\"><strong>complete object destructor of a class T</strong></p>\n<p id=\"so_7360752_11814437_4\">A function that, in addition to the actions required of a base object destructor, runs the destructors for the virtual base classes\n  of T.</p>\n<p id=\"so_7360752_11814437_5\"><strong>deleting destructor of a class T</strong></p>\n<p id=\"so_7360752_11814437_6\">A function that, in addition to the actions required of a complete object destructor, calls the appropriate deallocation function (i.e,.\n  operator delete) for T.</p>\n</blockquote>\n<p>From these definitions, the purpose of the complete object constructor and of the base object constructor are obvious.</p>\n", "LastActivityDate": "2012-08-05T06:23:30.077", "Score": "3", "CreationDate": "2012-08-05T06:23:30.077", "ParentId": "7360752", "CommentCount": "0", "OwnerUserId": "963864"}, "bq_ids": {"n4140": {"so_7360752_11814437_0": {"length": 11, "quality": 0.5789473684210527, "section_id": 3356}, "so_7360752_11814437_1": {"length": 4, "quality": 1.0, "section_id": 4706}, "so_7360752_11814437_3": {"length": 4, "quality": 1.0, "section_id": 4706}, "so_7360752_11814437_6": {"length": 7, "quality": 0.5384615384615384, "section_id": 416}, "so_7360752_11814437_2": {"length": 7, "quality": 0.7, "section_id": 365}}, "n3337": {"so_7360752_11814437_0": {"length": 11, "quality": 0.5789473684210527, "section_id": 3226}, "so_7360752_11814437_2": {"length": 7, "quality": 0.7, "section_id": 395}, "so_7360752_11814437_6": {"length": 7, "quality": 0.5384615384615384, "section_id": 6921}}, "n4659": {"so_7360752_11814437_0": {"length": 10, "quality": 0.5263157894736842, "section_id": 467}, "so_7360752_11814437_1": {"length": 4, "quality": 1.0, "section_id": 6103}, "so_7360752_11814437_3": {"length": 4, "quality": 1.0, "section_id": 4110}, "so_7360752_11814437_6": {"length": 7, "quality": 0.5384615384615384, "section_id": 434}, "so_7360752_11814437_2": {"length": 8, "quality": 0.8, "section_id": 422}}}, "7361176": {"Id": "7361176", "PostTypeId": "2", "Body": "<p>I suggest you to read some papers. These two are really interesting, especially the first since it comes from C++'s father:</p>\n<p><a href=\"http://scholar.google.it/scholar?cluster=18344325569090189447&amp;hl=en&amp;as_sdt=0,5\" rel=\"nofollow\">[1] Bjarne Stroustrup. Multiple Inheritance for C++. The C/C++ Users\nJournal, May 1999.</a></p>\n<p><a href=\"http://scholar.google.it/scholar?cluster=7746074297750115106&amp;hl=en&amp;as_sdt=0,5\" rel=\"nofollow\">[2] J. Templ. A Systematic Approach to Multiple Inheritance Implementation.\nACM SIGPLAN Notices, Volume 28, No. 4 April 1993.</a></p>\n<p>I used them as main references while making a seminar (as a student) on multiple inheritance in my university.</p>\n", "LastActivityDate": "2011-09-09T11:49:01.973", "Score": "2", "CreationDate": "2011-09-09T11:49:01.973", "ParentId": "7360752", "CommentCount": "0", "OwnerUserId": "898400"}});