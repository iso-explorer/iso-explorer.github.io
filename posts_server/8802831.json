post_cb({"8803230": {"ParentId": "8802831", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Recent gcc version are able to use mfpr to do compile time floating point computation. My guess is that your recent gcc does that and use an higher precision for the compile time version.  This is allowed by the at least the C99 standard (I've not looked in other one if it was modified)</p>\n<p>6.3.1.8/2 in C99</p>\n<blockquote>\n<p id=\"so_8802831_8803230_0\">The values of floating operands and of the results of floating expressions may be\n  represented in greater precision and range than that required by the type; the types are not\n  changed thereby.</p>\n</blockquote>\n<p>Edit: your gcc -S results confirm that.  I haven't checked the computations, but the old one has (after substituting memory for its constant content)</p>\n<pre><code>movss 1053092943, %xmm1\nmovss 1055100473, %xmm0\ncall powf\n</code></pre>\n<p>calling powf with the precomputed values for 4/9.0 and 1/2.6 and then printing the result after promotion to double, while the new one just print the float 0x3f3b681f promoted to double.</p>\n", "OwnerUserId": "136208", "LastEditorUserId": "136208", "LastEditDate": "2012-01-10T14:17:58.783", "Id": "8803230", "Score": "8", "CreationDate": "2012-01-10T12:25:39.840", "LastActivityDate": "2012-01-10T14:17:58.783"}, "8802897": {"ParentId": "8802831", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You should be able to distinguish between the format rounding differently and the math giving a different answer, just by printing more (all) significant digits.</p>\n<p>If it looks the same when no rounding takes place, <code>printf(\"%0.6f\"</code> is just rounding differently.</p>\n<hr>\n<p>OK, with the old Linux+python environment I have to hand, I get:</p>\n<pre><code>Python 2.4.3 (#1, Jun 11 2009, 14:09:37)\n[GCC 4.1.2 20080704 (Red Hat 4.1.2-44)] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; (4.0/9.0)**(1.0/2.6)\n0.7320574847636997\n</code></pre>\n<p>which is different again.</p>\n<p>Maybe it would be simpler to ask instead, how many significant figures are really significant for this unit test?</p>\n</hr>", "OwnerUserId": "212858", "LastEditorUserId": "212858", "LastEditDate": "2012-01-10T12:17:16.413", "Id": "8802897", "Score": "1", "CreationDate": "2012-01-10T11:57:13.280", "LastActivityDate": "2012-01-10T12:17:16.413"}, "8803491": {"ParentId": "8802831", "CommentCount": "2", "Body": "<p>I think the old gcc used <code>double</code> under the hood. Doing the calculation in Haskell and printing the results to full precision, I get</p>\n<pre><code>Prelude Text.FShow.RealFloat&gt; FD ((4/9) ** (1/2.6))\n0.73205748476369969512944635425810702145099639892578125\nPrelude Text.FShow.RealFloat&gt; FF ((4/9) ** (1/2.6))\n0.732057511806488037109375\n</code></pre>\n<p>So the <code>double</code> result agrees with what gcc-4.1.2 produced and the <code>float</code> result with what gcc-4.4.0 does. The results gcc-4.5.1 produces here for <code>float</code> resp. <code>double</code> agree with the Haskell results.</p>\n<p>As A Programmer cited, the compiler is allowed to use higher precision, the old gcc did, the new apparently doesn't.</p>\n", "OwnerUserId": "1011995", "PostTypeId": "2", "Id": "8803491", "Score": "4", "CreationDate": "2012-01-10T12:45:36.243", "LastActivityDate": "2012-01-10T12:45:36.243"}, "8802831": {"CommentCount": "2", "AcceptedAnswerId": "8803230", "PostTypeId": "1", "LastEditorUserId": "745", "CreationDate": "2012-01-10T11:50:56.590", "LastActivityDate": "2012-01-10T14:17:58.783", "LastEditDate": "2012-01-10T12:14:32.050", "ViewCount": "867", "FavoriteCount": "3", "Title": "gcc rounding difference between versions", "Id": "8802831", "Score": "14", "Body": "<p>I'm looking into <a href=\"https://github.com/imageworks/OpenColorIO/issues/168\">why a test case is failing</a></p>\n<p>The problematic test can be reduced to doing <code>(4.0/9.0) ** (1.0/2.6)</code>, rounding this to 6 digits and checking against a known value (as a string):</p>\n<pre><code>#include&lt;stdio.h&gt;\n#include&lt;math.h&gt;\nint main(){\n    printf(\"%.06f\\n\", powf(4.0/9.0, (1.0/2.6)));\n}\n</code></pre>\n<p>If I compile and run this in gcc 4.1.2 on Linux, I get:</p>\n<pre><code>0.732057\n</code></pre>\n<p>Python agrees, as does <a href=\"http://www.wolframalpha.com/input/?i=%284.0%2F9.0%29%2a%2a%281%2F2.6%29\">Wolfram|Alpha</a>:</p>\n<pre><code>$ python2.7 -c 'print \"%.06f\" % (4.0/9.0)**(1/2.6)'\n0.732057\n</code></pre>\n<p>However I get the following result on gcc 4.4.0 on Linux, and 4.2.1 on OS X:</p>\n<pre><code>0.732058\n</code></pre>\n<p>A <code>double</code> acts identically (although I didn't test this extensively)</p>\n<p>I'm not sure how to narrow this down any further.. Is this a gcc regression? A change in rounding algorithm? Me doing something silly?</p>\n<p><strong>Edit:</strong> Printing the result to 12 digits, the digit at the 7th place is 4 vs 5, which explains the rounding difference, but not the value difference:</p>\n<p>gcc 4.1.2:</p>\n<pre><code>0.732057452202\n</code></pre>\n<p>gcc 4.4.0:</p>\n<pre><code>0.732057511806\n</code></pre>\n<p>Here's the <code>gcc -S</code> output from both versions: <a href=\"https://gist.github.com/1588729\">https://gist.github.com/1588729</a></p>\n", "Tags": "<c++><c><gcc><floating-point><precision>", "OwnerUserId": "745", "AnswerCount": "4"}, "8802874": {"ParentId": "8802831", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There are many players here.  Gcc is most probably just going to forward the calculation to your floating point processor; you can check the disassembly for that.</p>\n<p>You may check the binary results with a binary representation (from same <a href=\"http://www.wolframalpha.com/input/?i=0.7320574847636997251189785525450826267064076611277443760391%20hex\" rel=\"nofollow\">wolfram/alpha</a>):</p>\n<pre><code>float q=powf(4.0/9.0, (1.0/2.6));\nunsigned long long hex=*reinterpret_cast&lt;unsigned long long*&gt;(&amp;q);\nunsigned long long reference=0x1f683b3f;\nassert( hex==reference );\n</code></pre>\n<p>But also <code>printf</code> is a possible culprit: the decimal representation of that number may be the problem, too.  You could try to write <code>printf(\"%0.06f\", 0.73205748 );</code> to test that.</p>\n", "OwnerUserId": "6610", "LastEditorUserId": "6610", "LastEditDate": "2012-01-10T12:00:57.370", "Id": "8802874", "Score": "3", "CreationDate": "2012-01-10T11:55:15.603", "LastActivityDate": "2012-01-10T12:00:57.370"}, "bq_ids": {"n4140": {"so_8802831_8803230_0": {"section_id": 5945, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_8802831_8803230_0": {"section_id": 5716, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_8802831_8803230_0": {"section_id": 7430, "quality": 0.9444444444444444, "length": 17}}}});