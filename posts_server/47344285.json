post_cb({"47344285": {"CommentCount": "0", "AcceptedAnswerId": "47344491", "PostTypeId": "1", "LastEditorUserId": "6935629", "CreationDate": "2017-11-17T06:07:57.433", "LastActivityDate": "2017-11-17T08:44:22.503", "LastEditDate": "2017-11-17T08:44:22.503", "ViewCount": "50", "FavoriteCount": "1", "Title": "Names of constructors and destructors of templates", "Id": "47344285", "Score": "1", "Body": "<p>From <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4459.html\" rel=\"nofollow noreferrer\">n4459</a>:</p>\n<blockquote>\n<p id=\"so_47344285_47344285_0\"><strong>635. Names of constructors and destructors of templates</strong></p>\n<p id=\"so_47344285_47344285_1\">There is a discrepancy between the syntaxes allowed for defining a\n  constructor and a destructor of a class template. For example:</p>\n<pre><code>template &lt;class&gt; struct S { S(); ~S (); };\ntemplate &lt;class T&gt; S&lt;T&gt;::S&lt;T&gt;() { }        // error\ntemplate &lt;class T&gt; S&lt;T&gt;::~S&lt;T&gt;() { }       // okay\n</code></pre>\n<p id=\"so_47344285_47344285_2\">The reason for this is that 3.4.3.1 [class.qual] paragraph 2 says that\n  <strong>S::S is \u201cconsidered to name the constructor,\u201d which is not a template and thus cannot accept a template argument list.</strong> On the\n  other hand, the second S in <code>S::~S</code> finds the injected-class-name, which\n  \u201ccan be used with or without a template-argument-list\u201d (14.6.1\n  [temp.local] paragraph 1) and thus satisfies the requirement to name\n  the destructor's class (12.4 [class.dtor] paragraph 1).</p>\n</blockquote>\n<p>I don't understand, What does say <strong>that <code>S::S</code> is \u201cconsidered to name the constructor,\u201d which is not a template</strong>?</p>\n", "Tags": "<c++><c++11><templates><constructor>", "OwnerUserId": "6935629", "AnswerCount": "1"}, "47344491": {"ParentId": "47344285", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_47344285_47344491_0\">S::S is \u201cconsidered to name the constructor,\u201d which is not a template and thus cannot accept a template argument list</p>\n</blockquote>\n<p>Yes, it is possibly because a constructor <em>might</em> be templated. So by preventing non-template constructor to <em>not</em> have <code>S&lt;T&gt;::S&lt;T&gt;</code> syntax, the language reserves this syntax for the templated constructor. </p>\n<p>Here is an example:</p>\n<pre><code>template &lt;typename T&gt; \nstruct X \n{ \n   template&lt;typename U&gt;\n   X(); \n  ~X (); \n};\n\ntemplate &lt;typename T&gt; \ntemplate &lt;typename U&gt; \nX&lt;T&gt;::X&lt;U&gt;() { }        //OK now\n\ntemplate &lt;class T&gt;\nX&lt;T&gt;::~X&lt;T&gt;() { }       // okay\n</code></pre>\n<p>If the syntax <code>S&lt;T&gt;::S&lt;T&gt;()</code> was allowed, then in this case you would have to write <code>X&lt;T&gt;::X&lt;T&gt;&lt;U&gt;()</code> \u2014 that is an ugly and a <strong>new</strong> syntax. So in a sense, by preventing this, the syntax is slightly cleaner and that also avoids introducing a <em>new</em> syntax.</p>\n<p>On the other hand, the destructor can <em>never</em> be a template. </p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2017-11-17T06:29:04.030", "Id": "47344491", "Score": "5", "CreationDate": "2017-11-17T06:23:56.000", "LastActivityDate": "2017-11-17T06:29:04.030"}, "bq_ids": {"n4140": {"so_47344285_47344491_0": {"section_id": 138, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_47344285_47344491_0": {"section_id": 132, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_47344285_47344491_0": {"section_id": 142, "quality": 0.5555555555555556, "length": 5}}}});