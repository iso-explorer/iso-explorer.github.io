post_cb({"40311194": {"CommentCount": "12", "ViewCount": "529", "PostTypeId": "1", "LastEditorUserId": "4625005", "CreationDate": "2016-10-28T18:31:55.693", "LastActivityDate": "2016-10-29T15:58:06.723", "Title": "no type named \u2018pointer\u2019 in struct std::iterator_traits<...>", "AcceptedAnswerId": "40312665", "LastEditDate": "2016-10-29T15:58:06.723", "Id": "40311194", "Score": "0", "Body": "<p>Here are the fragments of my linked_list template :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\ntemplate &lt; class &gt;\nstruct linked_list {\n    struct iterator_base : public std::iterator&lt; std::bidirectional_iterator_tag , int &gt;\n    {  \n        typename std::iterator_traits&lt; iterator_base &gt;::pointer operator -&gt; () const {\n            std::cerr &lt;&lt; __func__ ; \n            return nullptr ; } ;\n    };\n    using difference_type = typename std::iterator_traits&lt; iterator_base &gt;::difference_type ;\n} ;\n\nint main ()\n{\n    int * inullptr = linked_list&lt; int &gt;::iterator_base().operator-&gt;() ;\n    return 0 ;\n}\n</code></pre>\n<p>When I leave <code>using...</code> line uncommented, the code doesn't compile.</p>\n<p>g++5.4 :</p>\n<pre><code>list2.cxx:105:66: error: no type named \u2018pointer\u2019 in \u2018struct std::iterator_traits&lt;linked_list&lt;int&gt;::iterator_base&lt;(linked_list&lt;int, std::allocator&lt;int&gt; &gt;::constantness)1u&gt; &gt;\u2019\n          typename std::iterator_traits&lt; iterator_base &gt;::pointer operator -&gt; () const { return &amp;( to_obj_node( current_node_ ) -&gt; object() ) ; }\n</code></pre>\n<p>icpc :</p>\n<pre><code>list.cxx(105): error: incomplete type is not allowed typename std::iterator_traits&lt; iterator_base &gt;::pointer operator -&gt; () const { return &amp;( to_obj_node( current_node_ ) -&gt; object() ) ; }\n</code></pre>\n<p>Without that line all compiles fine.  </p>\n<p>the question is : What happens, when i'm commenting <code>using difference_type = typename std::iterator_traits&lt; iterator &gt;::difference_type;</code> in above code ( only with such changes code compiles ).?</p>\n<p>==========================================================================\n<a href=\"http://eel.is/c++draft/res.on.functions\" rel=\"nofollow\">res.on.functions/2.5</a></p>\n<blockquote id=\"so_40311194_40311194_0\">\n<ol start=\"2\">\n<li>In particular, the <strong><em>effects are undefined</em></strong> in the following cases:...\n  \n  <ol start=\"5\">\n<li>if an incomplete type ([basic.types]) is used as a template argument when instantiating a template component, unless specifically\n  allowed for that component.</li>\n</ol></li>\n</ol>\n</blockquote>\n<p>and historical <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#287\" rel=\"nofollow\">discussion</a> on that.</p>\n", "Tags": "<c++><c++11><templates><iterator-traits>", "OwnerUserId": "4625005", "AnswerCount": "2"}, "40312665": {"ParentId": "40311194", "CommentCount": "7", "CreationDate": "2016-10-28T20:18:56.120", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "40312665", "Score": "1", "Body": "<p>The error here is that the type <code>std::iterator_traits&lt; iterator_base &gt;</code> is still incomplete and at the time that you want to access <code>::pointer</code> does not yet provide that <code>pointer</code> member. </p>\n<p>The class <code>std::iterator_traits&lt;iterator_base&gt;</code> is being instantiated by <code>typename std::iterator_traits&lt; iterator_base &gt;::difference_type</code>, because it's used on the left side of a <code>::</code>, and because it has not yet been instantiated. This triggers the instantiation of <code>linked_list&lt;int&gt;::iterator_base</code> because the body of <code>iterator_traits</code> uses that class to define its various member typedefs - for example the instantiation could happen at a line that looks like <code>typedef typename Iterator::value_type value_type;</code> in the Standard library. </p>\n<p>What follows is the use of <code>std::iterator_traits&lt; iterator_base &gt;::pointer</code> in your nested class. This time, <code>iterator_traits&lt;iterator_base&gt;</code> is already being instantiated, so nothing is done, and <code>::pointer</code> is searched. But since that wasn't declared yet, it can't found. </p>\n<p>Note that when you comment-out the <code>using</code> line, nothing in the code will instantiate the nested class body anymore (the body of members of class templates are \"lazily instantiated\"), so this can't be a measure for or against the validity of the constructs inside of that nested class body.</p>\n", "LastActivityDate": "2016-10-28T20:18:56.120"}, "bq_ids": {"n4140": {"so_40311194_40311194_0": {"section_id": 6324, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_40311194_40311194_0": {"section_id": 6081, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_40311194_40311194_0": {"section_id": 7834, "quality": 0.9411764705882353, "length": 16}}}, "40312515": {"ParentId": "40311194", "CommentCount": "4", "CreationDate": "2016-10-28T20:08:15.747", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "40312515", "Score": "0", "Body": "<pre><code>#include &lt;iterator&gt;\n\nstruct OK_1: std::iterator&lt;std::bidirectional_iterator_tag, int&gt; {};\nusing Pointer_1 = typename std::iterator_traits&lt;OK_1&gt;::pointer;\n\nstruct Nah\n{\n    using Pointer_nah = typename std::iterator_traits&lt;Nah&gt;::pointer;    //!\n};\n\nauto main() -&gt; int\n{}\n</code></pre>\n<p>At the point of declaration of <code>Pointer_nah</code>, the type <code>Nah</code> is an incomplete type.</p>\n<p><code>iterator_traits</code> has to look inside that type in order to find its <code>pointer</code> definition.</p>\n<p>But that, recursively, requires the definition of <code>iterator_traits&lt;Nah&gt;</code>.</p>\n<p>And so on.</p>\n<p>But, main point: <code>Nah</code> is incomplete at the point where <code>Pointer_nah</code> is declared. <strong>Incomplete</strong> means that the class is not fully known. In particular its size is not known here, so it can't be passed to <code>sizeof</code>.</p>\n<p>I suspect that that's the reason why one of your compilers exclaimed,</p>\n<blockquote>\n<p id=\"so_40311194_40312515_0\"><strong>\u201d</strong> error: incomplete type is not allowed</p>\n</blockquote>\n", "LastActivityDate": "2016-10-28T20:08:15.747"}});