post_cb({"47498351": {"ParentId": "47498215", "CommentCount": "0", "Body": "<p>If the object was constructed, it will be destroyed on the exit of the thread function. Pretty much in those exact words over at <a href=\"https://timsong-cpp.github.io/cppwp/n3337/basic.stc.thread#2\" rel=\"nofollow noreferrer\">[basic.stc.thread]/2</a>:</p>\n<blockquote>\n<p id=\"so_47498215_47498351_0\">A variable with thread storage duration shall be initialized before\n  its first odr-use ([basic.def.odr]) and, if constructed, shall be\n  destroyed on thread exit.</p>\n</blockquote>\n", "OwnerUserId": "817643", "PostTypeId": "2", "Id": "47498351", "Score": "1", "CreationDate": "2017-11-26T16:26:43.500", "LastActivityDate": "2017-11-26T16:26:43.500"}, "47498215": {"CommentCount": "0", "ViewCount": "29", "LastActivityDate": "2017-11-26T16:26:43.500", "Body": "<p>In the question <a href=\"https://stackoverflow.com/questions/47457478/using-qsqlquery-from-multiple-threads\">Using QSqlQuery from multiple threads</a> there was the outcome that thread storage solves the problem. </p>\n<p>I made a simple demo code to be absolutely clear about C++11 thread_local specifier. The code below creates two threads which have ThreadLocal object as a local unique object. The Storage::get function is a thread specific singleton. Does the standard guarantee that ThreadLocal destructor is called on join or the exit of the thread function? </p>\n<p>Compiled with GCC 5.4.0\n(g++ -o main main.cpp --std=c++11 -lpthread)</p>\n<pre><code>#include &lt;thread&gt;\n#include &lt;mutex&gt;\n#include &lt;string&gt;\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;atomic&gt;\n\nstatic std::mutex mtx;\n\nstruct ThreadLocal {\n    std::string name;\n\n    ~ThreadLocal() {\n        mtx.lock();\n        std::cout &lt;&lt; \"destroy \" &lt;&lt; name &lt;&lt; std::endl;\n        mtx.unlock();\n    }\n};\n\nstruct Storage {\n    static ThreadLocal &amp;get() {\n        /* Thread local singleton */\n        static thread_local ThreadLocal l;\n        static std::atomic&lt;int&gt; cnt(0);\n        l.name = std::to_string(cnt);\n        cnt++;\n        return l;\n    }\n};\n\nvoid thread() {\n    mtx.lock();\n    std::cout &lt;&lt; Storage::get().name &lt;&lt; std::endl;\n    mtx.unlock();\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n\nint main(int argc, const char **argv) {\n    std::thread t1(&amp;thread);\n    std::thread t2(&amp;thread);\n    t1.join();\n    t2.join();\n}\n</code></pre>\n", "PostTypeId": "1", "AcceptedAnswerId": "47498351", "FavoriteCount": "0", "Title": "Destruction of thread_local objects", "Id": "47498215", "Score": "1", "CreationDate": "2017-11-26T16:12:51.613", "Tags": "<c++><multithreading><c++11>", "OwnerUserId": "5666503", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_47498215_47498351_0": {"section_id": 7169, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_47498215_47498351_0": {"section_id": 6913, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_47498215_47498351_0": {"section_id": 8677, "quality": 0.9285714285714286, "length": 13}}}});