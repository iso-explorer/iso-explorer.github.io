post_cb({"49104679": {"ViewCount": "49", "Body": "<p>Is there a compiler flag that logs warning / error in case of any implicit conversions - like int32_t to uint32_t.</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n\n\nusing ::std::int32_t;\nusing ::std::uint32_t;\n\n\nint main(int argc, char *argv[])\n{\n\n   int32_t x = 9;\n\n    uint32_t i = x;\n\n    std::cout &lt;&lt; \" \" &lt;&lt; x &lt;&lt; \" \" &lt;&lt; i &lt;&lt; std::flush &lt;&lt; std::endl;\n\n    return 0;\n}\n\nc++ -std=c++11 -Wall -Wconversion -Wpedantic cast.cpp\n</code></pre>\n<p>I get no issues / warning / error during compilation - is there a way it can achieved.</p>\n", "AcceptedAnswerId": "49104723", "Title": "C++ - compilation error for all implicit conversion", "CreationDate": "2018-03-05T06:32:36.660", "LastActivityDate": "2018-03-05T06:58:43.850", "CommentCount": "4", "LastEditDate": "2018-03-05T06:33:12.450", "PostTypeId": "1", "LastEditorUserId": "4062354", "Id": "49104679", "Score": "0", "OwnerUserId": "304974", "Tags": "<c++>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_49104679_49104723_0": {"length": 29, "quality": 0.90625, "section_id": 31}}, "n3337": {"so_49104679_49104723_0": {"length": 29, "quality": 0.90625, "section_id": 28}}, "n4659": {"so_49104679_49104723_0": {"length": 29, "quality": 0.90625, "section_id": 31}}}, "49104999": {"Id": "49104999", "PostTypeId": "2", "Body": "<p>I don't know of a compiler that provides such a flag (though it's always possible I've missed one).</p>\n<p>Lacking it, you could build a little template that will make such implicit conversions impossible in at least a few obvious situations:</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n\nusing ::std::int32_t;\nusing ::std::uint32_t;\n\ntemplate &lt;class T&gt;\nclass holder {\n    T value;\npublic:\n    holder(T value) : value(value) {}\n    operator T&amp;() { return value; }\n    operator T() const { return value; }\n    holder &amp;operator=(holder const &amp;other) { value = other.value; return *this; }\n};\n\nint main(int argc, char *argv[]) {\n    holder&lt;int32_t&gt; x = 9;\n\n    holder&lt;uint32_t&gt; i = x;\n\n    ++i;\n\n    std::cout &lt;&lt; \" \" &lt;&lt; x &lt;&lt; \" \" &lt;&lt; i &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Attempting to compile with g++ gives:</p>\n<pre><code>trash9.cpp:20:23: error: conversion from 'holder&lt;int&gt;' to non-scalar type 'holder&lt;unsigned int&gt;' requested\n  holder&lt;uint32_t&gt; i = x;\n                       ^\n</code></pre>\n<p>If, however, we change the second to <code>holder&lt;int32_t&gt; i = x;</code> it all works fine and acts as expected.</p>\n<p>This suffices for the demo code you've given, but won't work in all situations. In particular, an implicit conversion in the course of evaluating an expression will still be allowed:</p>\n<pre><code>void use(holder&lt;uint32_t&gt; v) {\n    std::cout &lt;&lt; v;\n}\n\nint main(int argc, char *argv[]) {\n    holder&lt;int32_t&gt; x = 9;\n\n    holder&lt;int32_t&gt; i = x;\n\n    use(i | 1u);\n}\n</code></pre>\n<p>If you want to prevent conversions in cases like that as well, you can do it, but it's going to be a lot more work--you'll need to remove the <code>operator T</code> and <code>operator T&amp;</code> from the code above, and then implement all the operators you do want to support. That would/will probably be tedious to the point that it's at least mildly painful, but you might find it acceptable anyway.</p>\n", "LastActivityDate": "2018-03-05T06:58:43.850", "Score": "1", "CreationDate": "2018-03-05T06:58:43.850", "ParentId": "49104679", "CommentCount": "3", "OwnerUserId": "179910"}, "49104723": {"Id": "49104723", "PostTypeId": "2", "Body": "<pre><code>uint32_t i = x;\n</code></pre>\n<p>Signed int type to unsigned int type conversion is well defined in C++.</p>\n<p><strong>(C++11, \u00a74.7 \u00b62)</strong></p>\n<blockquote>\n<p id=\"so_49104679_49104723_0\">If the destination type is unsigned, the resulting value is the least\n  unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n\n  is the number of bits used to represent the unsigned type). [ Note: In a two\u2019s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). \u2014 end note ]</p>\n</blockquote>\n", "LastActivityDate": "2018-03-05T06:35:59.347", "Score": "2", "CreationDate": "2018-03-05T06:35:59.347", "ParentId": "49104679", "CommentCount": "3", "OwnerUserId": "4188894"}});