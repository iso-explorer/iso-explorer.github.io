post_cb({"28950011": {"ParentId": "28949774", "CommentCount": "4", "Body": "<p>The IEEE 754 rules of arithmetic for signed zeros state that <code>+0.0 + -0.0</code> depends on the rounding mode.  In the default rounding mode, it will be <code>+0.0</code>.  When rounding towards -\u221e, it will be <code>-0.0</code>.</p>\n<p>You can check this in C++ like so:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"+0.0 + +0.0 == \" &lt;&lt; +0.0 + +0.0 &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"+0.0 + -0.0 == \" &lt;&lt; +0.0 + -0.0 &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"-0.0 + +0.0 == \" &lt;&lt; -0.0 + +0.0 &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"-0.0 + -0.0 == \" &lt;&lt; -0.0 + -0.0 &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/yD4HVh\">Output</a>:</p>\n<pre><code>+0.0 + +0.0 == 0\n+0.0 + -0.0 == 0\n-0.0 + +0.0 == 0\n-0.0 + -0.0 == -0\n</code></pre>\n", "OwnerUserId": "502399", "PostTypeId": "2", "Id": "28950011", "Score": "16", "CreationDate": "2015-03-09T19:14:21.810", "LastActivityDate": "2015-03-09T19:14:21.810"}, "28949926": {"ParentId": "28949774", "CommentCount": "1", "Body": "<p>The answer, by the IEEE floating point standard, is +0.</p>\n", "OwnerUserId": "1232685", "PostTypeId": "2", "Id": "28949926", "Score": "0", "CreationDate": "2015-03-09T19:09:07.797", "LastActivityDate": "2015-03-09T19:09:07.797"}, "28959462": {"ParentId": "28949774", "CommentCount": "0", "Body": "<p>Assume standard rounding mode (which you are using if you don't know what a rounding mode is and how to change it).</p>\n<p>If the exact result is non-zero but so small that it gets rounded to zero, the result is +0 if the exact result is greater than 0, and -0 if the exact result is less than 0. This situation only happens for multiplication and division, not for addition and subtraction. </p>\n<p>There are several cases where the exact result is zero. In that case the result is -0 in the following cases: Adding (-0) + (-0). Subtracting (-0) - (+0). Multiplying where one factor is a zero, and the other factor has the opposite sign (including (+0) * (-0). Dividing a zero by a non-zero number including infinity of the opposite sign. In all other cases, the result is +0. </p>\n<p>An unfortunate side effect of this rule is that x + 0.0 is not always identical to x (not when x is -0). On the other hand, x - 0.0 is always identical to x. Also, x * 0.0 may be +0 or -0, depending on x. This prevents some optimisations by compilers that support IEE754 precisely, or makes them more difficult. </p>\n", "OwnerUserId": "3255455", "PostTypeId": "2", "Id": "28959462", "Score": "1", "CreationDate": "2015-03-10T08:53:03.407", "LastActivityDate": "2015-03-10T08:53:03.407"}, "28949939": {"ParentId": "28949774", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>My answer deals with <a href=\"http://en.wikipedia.org/wiki/IEEE_floating_point\" rel=\"nofollow noreferrer\">IEEE 754:2008</a>, which is the current version of the standard.</p>\n<h2>In the IEEE 754:2008 standard:</h2>\n<p>Section 4.3 deals with the rounding of values when performing arithmetic operations in order to fit the bits into the mantissa.</p>\n<blockquote>\n<p id=\"so_28949774_28949939_0\"><strong>4.3 Rounding-direction attributes</strong></p>\n<p id=\"so_28949774_28949939_1\">Rounding takes a number regarded as infinitely precise and, if necessary, modifies it to fit in the destination\u2019s format while signaling the inexact exception, underflow, or overflow when appropriate (see 7). Except where stated otherwise, every operation shall be performed as if it first produced an intermediate result correct to infinite precision and with unbounded range, and then rounded that result according to one of the attributes in this clause.</p>\n<p id=\"so_28949774_28949939_2\">The rounding-direction attribute affects all computational operations that might be inexact. Inexact numeric floating-point results always have the same sign as the unrounded result.</p>\n<p id=\"so_28949774_28949939_3\">The rounding-direction attribute affects the signs of exact zero sums (see 6.3), and also affects the thresholds beyond which overflow and underflow are signaled.</p>\n</blockquote>\n<hr>\n<p>Section 6.3 prescribes the value of the sign bit when performing arithmetic with special values (NaN, infinities, +0, -0).</p>\n<blockquote>\n<p id=\"so_28949774_28949939_4\"><strong>6.3 The sign bit</strong></p>\n<p id=\"so_28949774_28949939_5\">When the sum of two operands with opposite signs (or the difference of two operands with like signs) is exactly zero, <strong>the sign of that sum (or difference) shall be +0 in all rounding-direction attributes except <code>roundTowardNegative</code></strong>; under that attribute, the sign of an exact zero sum (or difference) shall be \u22120.</p>\n<p id=\"so_28949774_28949939_6\">However, x + x = x \u2212 (\u2212x) retains the same sign as x even when x is zero.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>In other words, (+0) + (-0) = +0 except when the <a href=\"http://en.wikipedia.org/wiki/IEEE_floating_point#Rounding_rules\" rel=\"nofollow noreferrer\">rounding mode</a> is <code>roundTowardNegative</code>, in which case it is (+0) + (-0) = -0.</p>\n<hr>\n<hr>\n<hr>\n<h2>In the context of C#:</h2>\n<p>According to <a href=\"http://msdn.microsoft.com/en-us/library/aa691375\" rel=\"nofollow noreferrer\">\u00a77.7.4</a> of the <a href=\"http://msdn.microsoft.com/en-us/library/aa645596\" rel=\"nofollow noreferrer\">C# Language Specification</a> (emphasis mine):</p>\n<blockquote>\n<ul>\n<li>Floating-point addition:</li>\n</ul>\n<p id=\"so_28949774_28949939_7\"><code>float operator +(float x, float y);</code></p>\n<p id=\"so_28949774_28949939_8\"><code>double operator +(double x, double y);</code></p>\n<p id=\"so_28949774_28949939_9\"><strong>The sum is computed according to the rules of IEEE 754 arithmetic</strong>. The following table lists the results of all possible combinations of nonzero finite values, zeros, infinities, and NaN's. In the table, x and y are nonzero finite values, and z is the result of x + y. <strong>If x and y have the same magnitude but opposite signs, z is positive zero</strong>. If x + y is too large to represent in the destination type, z is an infinity with the same sign as x + y.</p>\n</blockquote>\n<pre><code> +  \u2022  x      +0     -0     +\u221e     -\u221e    NaN\n\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\ny   \u2022  z      y      y      +\u221e     -\u221e    NaN\n+0  \u2022  x      +0     +0     +\u221e     -\u221e    NaN\n-0  \u2022  x      +0     -0     +\u221e     -\u221e    NaN\n+\u221e  \u2022  +\u221e     +\u221e     +\u221e     +\u221e     NaN   NaN\n-\u221e  \u2022  -\u221e     -\u221e     -\u221e     NaN    -\u221e    NaN\nNaN \u2022  NaN    NaN    NaN    NaN    NaN   NaN\n</code></pre>\n<hr>\n<p><strong>(+0) + (-0) in C#:</strong></p>\n<p>In other words, based on the specification, the addition of two zeros only results in negative zero if <strong>both</strong> are negative zero. Therefore, the answer to the original question</p>\n<blockquote>\n<p id=\"so_28949774_28949939_10\">What is (+0)+(-0) by IEEE floating point standard?</p>\n</blockquote>\n<p>is +0.</p>\n<hr>\n<p><strong>Rounding modes in C#:</strong></p>\n<p>In case anyone is interested in changing the rounding mode in C#, in \"<a href=\"https://stackoverflow.com/q/24241545/1364007\">Is there an C# equivalent of c++ <code>fesetround()</code> function?</a>\", <a href=\"https://stackoverflow.com/users/17034/hans-passant\">Hans Passant</a> states:</p>\n<blockquote>\n<p id=\"so_28949774_28949939_11\">Never tinker with the FPU control word in C#. It is the worst possible global variable you can imagine. With the standard misery that globals cause, your changes cannot last and will arbitrarily disappear. The internal exception handling code in the CLR resets it when it processes an exception.</p>\n</blockquote>\n</hr></hr></hr></hr></hr></hr>", "OwnerUserId": "1364007", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:51:40.730", "Id": "28949939", "Score": "1", "CreationDate": "2015-03-09T19:09:55.697", "LastActivityDate": "2015-05-08T15:33:00.730"}, "28949774": {"CommentCount": "4", "AcceptedAnswerId": "28950011", "PostTypeId": "1", "LastEditorUserId": "502399", "CreationDate": "2015-03-09T19:00:12.377", "LastActivityDate": "2015-05-08T15:33:00.730", "LastEditDate": "2015-03-09T19:19:37.817", "ViewCount": "567", "FavoriteCount": "2", "Title": "What is (+0)+(-0) by IEEE floating point standard?", "Id": "28949774", "Score": "10", "Body": "<p>Am I right that any arithmetic operation on any floating numbers is unambiguously defined by IEEE floating point standard? If yes, just for curiosity, what is <code>(+0)+(-0)</code>? And is there a way to check such things in practice, in C++ or other commonly used programming language?</p>\n", "Tags": "<c++><floating-point><ieee-754>", "OwnerUserId": "4146202", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_28949774_28949939_7": {"section_id": 763, "quality": 1.0, "length": 4}}, "n3337": {"so_28949774_28949939_7": {"section_id": 750, "quality": 1.0, "length": 4}}, "n4659": {"so_28949774_28949939_7": {"section_id": 823, "quality": 1.0, "length": 4}}}});