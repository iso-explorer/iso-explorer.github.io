post_cb({"19900524": {"CommentCount": "1", "AcceptedAnswerId": "19900680", "CreationDate": "2013-11-11T06:55:38.127", "LastActivityDate": "2013-11-11T07:20:48.480", "PostTypeId": "1", "ViewCount": "2398", "FavoriteCount": "2", "Title": "Does the C++ 11 standard guarantees that std::atomic<> is implemented as an atomic operation?", "Id": "19900524", "Score": "20", "Body": "<p>I'm at a junction, I'm trying to pick one between mutex-lock-based data structure and lock-free ( and possibly wait-free ) data structure.</p>\n<p>While digging a little deeper I found no word about the fact that the C++ 11 standard is supporting atomic operations for atomic types, not even for width-based integrals like <code>atomic_uint32_t</code> . In other words it's not just the <code>std::atomic&lt;&gt;</code> interface that is <strong>not</strong> granted to be really atomic, the only thing that looks like it's granted to be atomic in the whole standard library is <code>std::atomic_flag</code> .</p>\n<p>Is this true or I'm missing something ? What is the reason for that ? I mean the standard calls \"atomic\" something that is clearly not atomic at all and it's something that is even allowed to use mutexes or blocking calls under the hood.</p>\n", "Tags": "<c++><multithreading><c++11><atomic>", "OwnerUserId": "2485710", "AnswerCount": "2"}, "19900680": {"ParentId": "19900524", "CommentCount": "7", "Body": "<p>The C++ standard makes no guarantee that <code>std::atomic&lt;T&gt;</code> operations are atomic. However, you can use <code>std::atomic&lt;T&gt;::is_lock_free()</code> to find out if the operation of <code>std::atomic&lt;T&gt;</code> is lock free 29.6.5 [atomics.types.operations.req] paragraph 7:</p>\n<blockquote>\n<p id=\"so_19900524_19900680_0\">Returns: True if the object\u2019s operations are lock-free, false otherwise.</p>\n</blockquote>\n<p>If it is not lock-free it will still do the required synchronization but it uses some lock to do so.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "19900680", "Score": "10", "CreationDate": "2013-11-11T07:06:40.560", "LastActivityDate": "2013-11-11T07:06:40.560"}, "bq_ids": {"n4140": {"so_19900524_19900680_0": {"section_id": 1186, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_19900524_19900680_0": {"section_id": 1184, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_19900524_19900680_0": {"section_id": 1268, "quality": 0.7142857142857143, "length": 5}}}, "19900649": {"ParentId": "19900524", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>If by atomic you mean, using hardware support without locks, then yes, the standard doesn't give you a guarantee for that. Why? Well, because different architectures support different kind of hardware atomicity. <code>std::atomic&lt;&gt;</code> has the handy <code>is_lock_free()</code> method which can be used to check wether the given object is actually lock free, or uses a lock internally to guarantee atomic operations. You can use that and check on your target hardware wether it would be lock free or not, and then decide what data structure to go for.</p>\n<p>However, that being said, if the target architecture has hardware support for atomic operations for the fixed width integrals you are interested in, and you didn't obtain your copy of the standard library from the the shady software shop in the ghetto, it's probably going to use the hardware instead of a full blown lock.</p>\n", "OwnerUserId": "350272", "LastEditorUserId": "350272", "LastEditDate": "2013-11-11T07:20:48.480", "Id": "19900649", "Score": "9", "CreationDate": "2013-11-11T07:04:56.883", "LastActivityDate": "2013-11-11T07:20:48.480"}});