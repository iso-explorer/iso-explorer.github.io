post_cb({"33896020": {"ParentId": "33895811", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><code>std::unordered_map</code> and <code>std::unordered_set</code> have no special requirements on their template parameters in this regard, so the general library-wide rule applies. Which is C++14 17.6.4.8/2.5:</p>\n<blockquote>\n<p id=\"so_33895811_33896020_0\">In particular, the effects are undefined in the following cases:</p>\n<p id=\"so_33895811_33896020_1\">...</p>\n<ul>\n<li>if an incomplete type (3.9) is used as a template argument when instantiating a template component,\n  unless specifically allowed for that component.</li>\n</ul>\n</blockquote>\n<p>So if either the value type, hash type, or predicate type are incomplete (which is true in your case), you have Undefined Behaviour.</p>\n<p>Since this bullet point specifically says \"template <em>component\"</em> while the rest of that clause refers to <em>functions,</em> I would say this means a class template is also a \"template component.\" And in your case, the class template is instantiated at the definition of the <code>artifactSet_</code> member in the definition of the <code>SetHolder</code> class.</p>\n", "OwnerUserId": "1782465", "LastEditorUserId": "996886", "LastEditDate": "2015-11-24T16:28:00.950", "Id": "33896020", "Score": "2", "CreationDate": "2015-11-24T14:20:11.820", "LastActivityDate": "2015-11-24T16:28:00.950"}, "33895811": {"CommentCount": "0", "ViewCount": "66", "PostTypeId": "1", "LastEditorUserId": "1782465", "CreationDate": "2015-11-24T14:10:14.067", "LastActivityDate": "2015-11-24T16:28:00.950", "Title": "What requirements does the standard impose on the Value type of unordered_set in terms of definition visibility", "AcceptedAnswerId": "33896020", "LastEditDate": "2015-11-24T14:21:37.923", "Id": "33895811", "Score": "1", "Body": "<p>I'm creating a class that contains an <code>unordered_set</code> with its own hash and predicate as follows:</p>\n<pre><code>//SetHolder.h\n#include &lt;unordered_set&gt;\n\nstruct SetHolder\n{\n    SetHolder(); //Defined in SetHolder.cpp\n    ~SetHolder(); //Defined in SetHolder.cpp\n\n    struct ArtifactImpl; //Defined in SetHolder.cpp\n    struct ArtifactSetKeyOps\n    {\n      std::size_t operator()(\n        const ArtifactImpl&amp; artifact) const noexcept;\n      bool operator()(\n        const ArtifactImpl&amp; lhs, const ArtifactImpl&amp; rhs) const;\n    };\n\n    std::unordered_set&lt;ArtifactImpl,\n      ArtifactSetKeyOps,ArtifactSetKeyOps&gt; artifactSet_;\n};\n</code></pre>\n<p>I'm using the <em>gcc 4.8.2 compiler</em> under <em>ubuntu linux (stdlibc++)</em>, and I've observed that it compiles when only declaring <code>ArtifactImpl</code> if I only use <code>unordered_set</code> from the cpp file. Yet, I need to provide the definition of <code>ArtifactSetKeyOps</code> (why, I don't understand).</p>\n<ul>\n<li>What requirements does the standard impose on the <strong>Value</strong> type of\n<code>unordered_set</code> in terms of definition visibility at the time of\ndeclaring <code>unordered_set</code>?</li>\n<li>Is this code supposed to work on all platforms? Also, if so, why does\nthe <strong>Hash</strong> and the <strong>Predicate</strong> need to be visible during the declaration\nof <code>unordered_set</code>?</li>\n</ul>\n", "Tags": "<c++><c++11><language-lawyer><c++-standard-library>", "OwnerUserId": "1400817", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33895811_33896020_0": {"section_id": 6324, "quality": 1.0, "length": 5}}, "n3337": {"so_33895811_33896020_0": {"section_id": 6081, "quality": 1.0, "length": 5}}, "n4659": {"so_33895811_33896020_0": {"section_id": 7834, "quality": 1.0, "length": 5}}}});