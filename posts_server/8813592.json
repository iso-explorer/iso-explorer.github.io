post_cb({"bq_ids": {"n4140": {"so_8813592_8816053_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 6348}, "so_8813592_8816053_8": {"length": 8, "quality": 0.6666666666666666, "section_id": 6354}, "so_8813592_8816053_6": {"length": 16, "quality": 1.0, "section_id": 6352}, "so_8813592_8816053_7": {"length": 17, "quality": 0.8947368421052632, "section_id": 6353}, "so_8813592_8816053_4": {"length": 23, "quality": 1.0, "section_id": 6350}, "so_8813592_8816053_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 6346}, "so_8813592_8816053_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 6347}, "so_8813592_8816053_3": {"length": 20, "quality": 0.8333333333333334, "section_id": 6349}, "so_8813592_8816053_5": {"length": 25, "quality": 0.8928571428571429, "section_id": 6351}}, "n3337": {"so_8813592_8816053_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 6105}, "so_8813592_8816053_8": {"length": 8, "quality": 0.6666666666666666, "section_id": 6111}, "so_8813592_8816053_6": {"length": 16, "quality": 1.0, "section_id": 6109}, "so_8813592_8816053_7": {"length": 17, "quality": 0.8947368421052632, "section_id": 6110}, "so_8813592_8816053_4": {"length": 23, "quality": 1.0, "section_id": 6107}, "so_8813592_8816053_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 6103}, "so_8813592_8816053_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 6104}, "so_8813592_8816053_3": {"length": 20, "quality": 0.8333333333333334, "section_id": 6106}, "so_8813592_8816053_5": {"length": 25, "quality": 0.8928571428571429, "section_id": 6108}}, "n4659": {"so_8813592_8816053_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 7857}, "so_8813592_8816053_8": {"length": 8, "quality": 0.6666666666666666, "section_id": 7863}, "so_8813592_8816053_6": {"length": 16, "quality": 1.0, "section_id": 7861}, "so_8813592_8816053_7": {"length": 17, "quality": 0.8947368421052632, "section_id": 7862}, "so_8813592_8816053_4": {"length": 23, "quality": 1.0, "section_id": 7859}, "so_8813592_8816053_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 7855}, "so_8813592_8816053_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 7856}, "so_8813592_8816053_3": {"length": 20, "quality": 0.8333333333333334, "section_id": 7858}, "so_8813592_8816053_5": {"length": 25, "quality": 0.8928571428571429, "section_id": 7860}}}, "8813633": {"Id": "8813633", "PostTypeId": "2", "Body": "<p>The <a href=\"http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution\" rel=\"nofollow\">documentation</a> makes no mention of thread safety, so I would assume they are <strong><em>not</em></strong> thread safe.</p>\n", "LastActivityDate": "2012-01-11T02:58:50.387", "CommentCount": "1", "CreationDate": "2012-01-11T02:58:50.387", "ParentId": "8813592", "Score": "0", "OwnerUserId": "16076"}, "8816053": {"Id": "8816053", "PostTypeId": "2", "Body": "<p>The C++11 standard library is broadly thread safe. The thread safety guarantees on PRNG objects are the same as on containers. More specifically, since the PRNG classes are all <em>pseudo</em>-random, i.e. they generate a deterministic sequence based on a definite current state, there is really no room to be peeking or poking at anything outside the contained state (which is also visible to the user).</p>\n<p>Just as containers need locks to make them safe to share, you would have to lock the PRNG object. This would make it slow and nondeterministic. One object per thread would be better.</p>\n<p>\u00a717.6.5.9 [res.on.data.races]:</p>\n<blockquote>\n<p id=\"so_8813592_8816053_0\">1 This section specifies requirements that implementations shall meet\n  to prevent data races (1.10). Every standard library function shall\n  meet each requirement unless otherwise specified. Implementations may\n  prevent data races in cases other than those specified below.</p>\n<p id=\"so_8813592_8816053_1\">2 A C++ standard library function shall not directly or indirectly\n  access objects (1.10) accessible by threads other than the current\n  thread unless the objects are accessed directly or indirectly via the\n  function\u2019s argu- ments, including this.</p>\n<p id=\"so_8813592_8816053_2\">3 A C++ standard library function shall not directly or indirectly\n  modify objects (1.10) accessible by threads other than the current\n  thread unless the objects are accessed directly or indirectly via the\n  function\u2019s non- const arguments, including this.</p>\n<p id=\"so_8813592_8816053_3\">4 [ Note: This means, for example, that implementations can\u2019t use a\n  static object for internal purposes without synchronization because it\n  could cause a data race even in programs that do not explicitly share\n  objects betweenthreads. \u2014endnote]</p>\n<p id=\"so_8813592_8816053_4\">5 A C++ standard library function shall not access objects indirectly\n  accessible via its arguments or via elements of its container\n  arguments except by invoking functions required by its specification\n  on those container elements.</p>\n<p id=\"so_8813592_8816053_5\">6 Operations on iterators obtained by calling a standard library\n  container or string member function may access the underlying\n  container, but shall not modify it. [Note: In particular, container\n  operations that invalidate iterators conflict with operations on\n  iterators associated with that container. \u2014 end note ]</p>\n<p id=\"so_8813592_8816053_6\">7 Implementations may share their own internal objects between threads\n  if the objects are not visible to users and are protected against data\n  races.</p>\n<p id=\"so_8813592_8816053_7\">8 Unless otherwise specified, C++ standard library functions shall\n  perform all operations solely within the current thread if those\n  operations have effects that are visible (1.10) to users.</p>\n<p id=\"so_8813592_8816053_8\">9 [ Note: This allows implementations to parallelize operations if\n  there are no visible side effects. \u2014 end note ]</p>\n</blockquote>\n", "LastEditorUserId": "153285", "LastActivityDate": "2012-01-11T08:28:29.737", "Score": "25", "CreationDate": "2012-01-11T08:08:54.363", "ParentId": "8813592", "CommentCount": "2", "OwnerUserId": "153285", "LastEditDate": "2012-01-11T08:28:29.737"}, "8813762": {"Id": "8813762", "PostTypeId": "2", "Body": "<p>The standard (well <code>N3242</code>) seems to make no mention of random number generation being race free (except that <code>rand</code> isn't), so it isn't(unless  I missed something). Besides there is really no point in having them threadsave, since it would incur a relatively hefty overhead (compared to the generation of the numbers itself at least), without really winning anything.</p>\n<p>Furthermore I don't really see a benefit og having one shared random number generator, instead of having one per thread, each being slighly differently initialized (e.g. from the results of another generator, or the current thread id). Afterall you probably don't rely on the generator generating a certain sequence each run anyways. So I would rewrite your code as something like this (for <code>openmp</code>, no clue about <code>libdispatch</code>):</p>\n<pre><code>void foo() {\n    #pragma omp parallel\n    {\n    //just an example, not sure if that is a good way too seed the generation\n    //but the principle should be clear\n    std::mt19937_64 engine((omp_get_thread_num() + 1) * static_cast&lt;uint64_t&gt;(system_clock::to_time_t(system_clock::now())));\n    std::uniform_real_distribution&lt;double&gt; zeroToOne(0.0, 1.0);\n    #pragma omp for\n        for (int i = 0; i &lt; 1000; i++) {\n            double a = zeroToOne(engine);\n        }\n    }\n}\n</code></pre>\n", "LastActivityDate": "2012-01-11T03:22:57.477", "CommentCount": "2", "CreationDate": "2012-01-11T03:22:57.477", "ParentId": "8813592", "Score": "2", "OwnerUserId": "201270"}, "8813592": {"ViewCount": "9037", "Body": "<p>In C++11 there are a bunch of new Random number generator engines and distribution functions. Are they thread safe? If you share a single random distribution and engine among multiple threads, is it safe and will you still receive random numbers? The scenario I am looking is something like,</p>\n<pre><code>void foo() {\n    std::mt19937_64 engine(static_cast&lt;uint64_t&gt; (system_clock::to_time_t(system_clock::now())));\n    std::uniform_real_distribution&lt;double&gt; zeroToOne(0.0, 1.0);\n#pragma omp parallel for\n    for (int i = 0; i &lt; 1000; i++) {\n        double a = zeroToOne(engine);\n    }\n}\n</code></pre>\n<p>using OpenMP or</p>\n<pre><code>void foo() {\n    std::mt19937_64 engine(static_cast&lt;uint64_t&gt; (system_clock::to_time_t(system_clock::now())));\n    std::uniform_real_distribution&lt;double&gt; zeroToOne(0.0, 1.0);\n    dispatch_apply(1000, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) {\n        double a = zeroToOne(engine);\n    });\n}\n</code></pre>\n<p>using libdispatch.</p>\n", "AcceptedAnswerId": "8816053", "Title": "C++11 Thread safety of Random number generators", "CreationDate": "2012-01-11T02:53:22.493", "Id": "8813592", "CommentCount": "0", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2012-01-11T16:28:10.690", "LastEditorUserId": "636019", "LastActivityDate": "2012-01-11T16:28:10.690", "Score": "30", "OwnerUserId": "1139069", "Tags": "<c++><thread-safety><c++11><openmp><grand-central-dispatch>", "AnswerCount": "3"}});