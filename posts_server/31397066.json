post_cb({"31397066": {"ViewCount": "177", "Body": "<p>Suppose I have the following macro:</p>\n<pre><code>#define CALL_FOO(x) x.foo&lt;int&gt;();\n</code></pre>\n<p>This macro will call the templated <code>foo</code> function with template argument <code>int</code>, and it will compile as long as <code>x</code> is itself not a template type. If it is, I would need to define a second variant of this macro to handle template types:</p>\n<pre><code>#define CALL_FOO_TEMPLATED(x) x.template foo&lt;int&gt;();\n</code></pre>\n<p>How can I create a macro that will call a template member function <code>foo</code> regardless of whether or not <code>x</code> is a dependent name?</p>\n", "AcceptedAnswerId": "31701116", "Title": "How do I call a templated member function without knowing whether or not the class is a template?", "CreationDate": "2015-07-14T03:22:42.413", "Id": "31397066", "CommentCount": "3", "LastEditDate": "2015-07-14T03:30:39.817", "PostTypeId": "1", "LastEditorUserId": "1613983", "LastActivityDate": "2015-07-31T10:38:31.267", "Score": "1", "OwnerUserId": "1613983", "Tags": "<c++><templates><macros>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_31397066_31701116_2": {"length": 21, "quality": 0.875, "section_id": 73}, "so_31397066_31701116_1": {"length": 9, "quality": 1.0, "section_id": 73}, "so_31397066_31701116_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 72}}, "n3337": {"so_31397066_31701116_2": {"length": 21, "quality": 0.875, "section_id": 68}, "so_31397066_31701116_1": {"length": 9, "quality": 1.0, "section_id": 68}, "so_31397066_31701116_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 67}}, "n4659": {"so_31397066_31701116_2": {"length": 21, "quality": 0.875, "section_id": 75}, "so_31397066_31701116_1": {"length": 9, "quality": 1.0, "section_id": 75}}}, "31699446": {"Id": "31699446", "PostTypeId": "2", "Body": "<p>(First, <em>never</em> put a <code>;</code> at the end of a macro. It will break inside certain <code>if</code> calls.)</p>\n<p>I think you can safely put <code>template</code> in front of <code>foo</code> at all times. Sometimes it is required. Sometimes it's optional. But I don't think it is ever disallowed to have <code>template</code> immediately in front of a template.</p>\n<pre><code>#define CALL_FOO(x) x.template foo&lt;int&gt;()\n</code></pre>\n", "LastActivityDate": "2015-07-29T11:40:30.360", "CommentCount": "0", "CreationDate": "2015-07-29T11:40:30.360", "ParentId": "31397066", "Score": "1", "OwnerUserId": "146041"}, "31701116": {"Id": "31701116", "PostTypeId": "2", "Body": "<p>The answer you're looking for, in [temp.names], <code>template</code> is required when:</p>\n<blockquote>\n<p id=\"so_31397066_31701116_0\">When the name of a member template specialization appears after <code>.</code> or <code>-&gt;</code> in a <em>postfix-expression</em> or after a\n  <em>nested-name-specifier</em> in a <em>qualified-id</em>, and the object expression of the <em>postfix-expression</em> is type-dependent\n  or the <em>nested-name-specifier</em> in the <em>qualified-id</em> refers to a dependent type, but the name is not a member of\n  the current instantiation (14.6.2.1), the member template name must be prefixed by the keyword <code>template</code>.</p>\n</blockquote>\n<p>but while there are restrictions on the name referred to:</p>\n<blockquote>\n<p id=\"so_31397066_31701116_1\">A name prefixed by the keyword <code>template</code> shall be a <em>template-id</em> or the name shall refer to a class template.</p>\n</blockquote>\n<p>there are not any restrictions on the \"dependence-ness\" of it:</p>\n<blockquote>\n<p id=\"so_31397066_31701116_2\"><em>[ Note:</em> As is the case with the <code>typename</code> prefix, the <code>template</code> prefix is allowed in cases where it is\n  not strictly necessary; i.e., when the <em>nested-name-specifier</em> or the expression on the left of the <code>-&gt;</code> or <code>.</code> is not\n  dependent on a template-parameter, or the use does not appear in the scope of a template. <em>\u2014end note]</em></p>\n</blockquote>\n<p>So the following will always compile fine:</p>\n<pre><code>struct X\n{\n    template &lt;typename &gt;\n    void foo() { }\n};\n\nint main()\n{\n    X{}.template foo&lt;int &gt;(); // template keyword not strictly necessary\n}\n</code></pre>\n<p>The <strong>real</strong> answer though is: don't use a macro for such a thing. Just write out the function call. Everybody will thank you later. With the added bonus that at the call site, you know whether or not the <code>template</code> keyword is required, so you can use it precisely where necessary. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-31T10:38:31.267", "Score": "6", "CreationDate": "2015-07-29T12:58:45.273", "ParentId": "31397066", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2015-07-31T10:38:31.267"}, "31703579": {"Id": "31703579", "PostTypeId": "2", "Body": "<p>For C++11 just use <code>template</code> unconditionally.  For C++03, most compilers will accept <code>template</code> even for non-dependent names, but may issue a warning.  If you need to cater to other compilers, or if the warning is not acceptable, you can try something like this:</p>\n<pre><code>template&lt;class X&gt;\nvoid CALL_FOO(X&amp; x)\n{\n  x.template foo&lt;int&gt;();\n}\ntemplate&lt;class X&gt;\nvoid CALL_FOO(const X&amp; x)\n{\n  x.template foo&lt;int&gt;();\n}\n</code></pre>\n<p>This does not allow you to pass along the value returned by <code>foo</code>.  This is easy enough to add if it is a fixed type.  Otherwise you need some form of <code>decltype</code>, which is not part of C++03, but you can try <a href=\"http://www.boost.org/doc/libs/1_58_0/doc/html/typeof.html\" rel=\"nofollow\">Boost.Typeof</a>.</p>\n", "LastActivityDate": "2015-07-29T14:35:10.113", "CommentCount": "4", "CreationDate": "2015-07-29T14:35:10.113", "ParentId": "31397066", "Score": "0", "OwnerUserId": "5165306"}});