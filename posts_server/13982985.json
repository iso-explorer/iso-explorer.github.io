post_cb({"18700401": {"Id": "18700401", "PostTypeId": "2", "Body": "<p>You could have a memory leak if you create dependent objects inside the constructor.</p>\n<p>In any language/environment this could cause a leak if these dependents are referenced by external entities which don't clean them up.</p>\n<p>In JAVA and C# this WILL NOT cause a leak if the dependents are not referenced externally. The garbage collector will eventually clean then up.</p>\n<p>In C++ this WILL CERTAINLY cause a leak if the dependents are not referenced externally. </p>\n<p>see Jon' answer for more possibilities: <a href=\"https://stackoverflow.com/a/1371559/1037993\">Can constructors throw exceptions in Java?</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-09T14:24:39.727", "Score": "1", "CreationDate": "2013-09-09T14:18:52.430", "ParentId": "13982985", "CommentCount": "0", "OwnerUserId": "1037993", "LastEditDate": "2017-05-23T11:51:14.897"}, "13984308": {"Id": "13984308", "PostTypeId": "2", "Body": "<p>The situation is similar yet different in both languages, C++ or Java.</p>\n<p>When the exception is thrown, it propagates back up the stack, looking for a handler. In C++ or Java, it might never find one and thus unwind all the way back to the start and terminate the program. In Java, there is a concept of checked exceptions which enforce that there will be some kind of handling of the exception (if checked). In C++, there is a concept of exception specification, but it is impractical (ill-designed) and should not be used, so, consider all exceptions as \"unchecked\" in C++.  </p>\n<p>Whether the exception ends up terminating the program or being caught somewhere far up-stream of where it was thrown, the unwinding process leading up to that is what matters. If it ends up terminating the program, then, of course, there are no memory leaks as the OS reclaims the memory. What you have to worry about is:</p>\n<ul>\n<li>Memory leaks during unwinding if the exception is eventually handled somewhere upstream; and,</li>\n<li>Other kinds of resources that could leak (e.g., pending database operations, network connections, etc.) because they won't be reclaimed / undone by the OS if the program terminates.</li>\n</ul>\n<p>As the stack unwinding occurs, in C++, the guarantee is, simply put, that every stack-bound object that was fully constructed (including the data members or base class instance of an object being constructed) will be destroyed immediately (i.e., deterministically) in the exact reverse order in which they were created. So, as long as all resources are tied directly to the construction / destruction of objects (also called \"RAII\") there will be no leaks (of memory or other resource) during the unwinding process since every resource successfully acquired will be freed (unless freeing the resource fails during unwinding, which is something you need to handle with care).</p>\n<p>In Java, the \"stack\" unwinding occurs in the same fashion, except that instead of immediately destroying the objects, they are marked as discarded (i.e., to be garbage collected), and eventually destroyed at some indeterminate point in the future. This guarantees no memory leaks, as long as the garbage collector stays alive long enough to do its job, which I'm not sure is guaranteed if the program ends up terminating on an unhandled exception (but it doesn't matter at that point). The main problem in Java are the other resources. These resources must be released in the <code>finally</code> blocks. The <code>finally</code> blocks are guaranteed to be executed during the unwinding, but, of course, they must contain code to release the resource allocated in the corresponding <code>try</code> block. As long as the programmer did his job, resources won't leak.</p>\n<p>The fact that the exception is thrown from a constructor really doesn't make much of a difference, and the basic rules are just the same basic rules for not leaking resources when exceptions are thrown:</p>\n<ul>\n<li>In C++, tie every <em>single</em> resource (memory or otherwise) to a <em>single</em> object, and the language guarantees the rest, no leaks. This is the Resource Acquisition Is Initialization (RAII) idiom.</li>\n<li>In Java, make sure the write every <em>single</em> non-memory resource acquisition within its own try-block which has its own finally-block that releases that <em>single</em> resource.</li>\n</ul>\n<p>In both cases, you must release your resources cleanly (no-throw).</p>\n", "LastActivityDate": "2012-12-21T04:34:17.897", "CommentCount": "2", "CreationDate": "2012-12-21T04:34:17.897", "ParentId": "13982985", "Score": "-1", "OwnerUserId": "491645"}, "13983053": {"Id": "13983053", "PostTypeId": "2", "Body": "<p>Whether you get a memory leak or not depends on how the code is written. If you write \"good\" code, you shouldn't have a memory leak. But it's entirely possible to come up with scenarios where this goes horribly wrong. </p>\n<p>If the constructor allocates anything in the constructor, then things may well go wrong. </p>\n<p>The solution, in general is to use what's called \"two-phase construction\", so the constructor itself is very simple and \"can't go wrong\". Once the object is constructed, you call a member function that fills in the object in ways that could perhaps fail, and you can then throw exceptions at will, and as long as it's ensured that the destructor is run at some point down the line, all should work out well. Beware of \"part-constructed object in destructor\" tho' - what happens if your pointers are NULL, or if something else hasn't been constructed partway through the destructor. </p>\n<p>[The above is subject to \"there is a handler somewhere before we get back to main, and we do actually want to do something other than abort the entire program\"]. </p>\n", "LastActivityDate": "2012-12-21T01:25:03.503", "CommentCount": "4", "CreationDate": "2012-12-21T01:25:03.503", "ParentId": "13982985", "Score": "-1", "OwnerUserId": "1919155"}, "13983014": {"Id": "13983014", "PostTypeId": "2", "Body": "<p>Well, in C++ at least, an unhandled exception would just go on and on until it reaches your main() and thus closes your program. Not freed memory would then be taken care of by the operating system.</p>\n<p>Not sure if that answers your question...?</p>\n<p>So, basically, it's just like if it was thrown from any other function.</p>\n", "LastActivityDate": "2012-12-21T01:19:55.753", "CommentCount": "1", "CreationDate": "2012-12-21T01:19:55.753", "ParentId": "13982985", "Score": "2", "OwnerUserId": "1840231"}, "bq_ids": {"n4140": {"so_13982985_13983221_1": {"length": 12, "quality": 0.8, "section_id": 3354}}, "n3337": {"so_13982985_13983221_1": {"length": 12, "quality": 0.8, "section_id": 3224}}, "n4659": {"so_13982985_13983221_1": {"length": 12, "quality": 0.8, "section_id": 4121}}}, "13983046": {"Id": "13983046", "PostTypeId": "2", "Body": "<p>It's worth adding:</p>\n<p>1) Java distinguishes between \"checked\" and \"unchecked\" exceptions</p>\n<p>2) Most user-defined exceptions should be \"checked\".  This means the code won't even <em>compile</em> unless each module in the call chain either a) handles the exception, or b) explicitly marks that it can \"throw\" the exception</p>\n", "LastActivityDate": "2012-12-21T01:24:15.243", "CommentCount": "2", "CreationDate": "2012-12-21T01:24:15.243", "ParentId": "13982985", "Score": "0", "OwnerUserId": "421195"}, "13983221": {"Id": "13983221", "PostTypeId": "2", "Body": "<p>You ask,</p>\n<blockquote>\n<p id=\"so_13982985_13983221_0\">\u201cWhat happens when an unhandled exception is thrown from a constructor? For Java, and for C++? Will there be a memory leak?\u201d</p>\n</blockquote>\n<p>An <strong>unhandled exception</strong> is an exception that does not have an associated handler.</p>\n<p>In C++ any unhandled exception terminates the program. It is unspecified whether the stack is unwound in this case, i.e. destructors of successfully constructed local variables may be executed or not depending on the compiler. Where the exception is throw from (such as inside a constructor) is irrelevant.</p>\n<blockquote>\n<p id=\"so_13982985_13983221_1\"><strong>C++11 \u00a715.3/9</strong>:<br>\n  \u201cIf no matching handler is found, the function <code>std::terminate()</code>  is called; whether or not the stack is unwound before this call to <code>std::terminate()</code> is implementation-defined.\u201d</br></p>\n</blockquote>\n<p>An unhandled exception in Java likewise necessarily terminates the program, or at least the current thread if it\u2019s not the main thread, but with guaranteed calls of <code>finally</code> clauses:</p>\n<blockquote>\n<p id=\"so_13982985_13983221_2\"><strong>Java SE 7 Language Specification \u00a711.3</strong>:<br>\n  \u201cIf no <code>catch</code>  clause that can handle an exception can be found, then the current thread (the thread that encountered the exception) is terminated. Before termination, all\n  <code>finally</code> clauses are executed [\u2026]\u201d</br></p>\n</blockquote>\n<p>Since the program terminates there is in practice no memory leak for the program itself, because in practice the operating system cleans up after a process.</p>\n<p>However, a crashing program may leave temporary files on disk, and it may leak other resources from server processes, including memory leaks in those server processes.</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2012-12-21T09:33:12.550", "Score": "6", "CreationDate": "2012-12-21T01:47:59.103", "ParentId": "13982985", "CommentCount": "3", "OwnerUserId": "464581", "LastEditDate": "2012-12-21T09:33:12.550"}, "13983321": {"Id": "13983321", "PostTypeId": "2", "Body": "<p>For C++, the answer is in the C++ FAQ.</p>\n<p><a href=\"http://www.parashift.com/c++-faq/ctors-can-throw.html\" rel=\"nofollow\">How can I handle a constructor that fails?</a></p>\n<p><a href=\"http://www.parashift.com/c++-faq/selfcleaning-members.html\" rel=\"nofollow\">How should I handle resources if my constructors may throw exceptions?</a></p>\n<p>More info from <a href=\"http://www.gotw.ca/gotw/066.htm\" rel=\"nofollow\">GOTW</a></p>\n", "LastEditorUserId": "922712", "LastActivityDate": "2012-12-21T02:20:41.273", "Score": "0", "CreationDate": "2012-12-21T02:05:42.113", "ParentId": "13982985", "CommentCount": "1", "OwnerUserId": "922712", "LastEditDate": "2012-12-21T02:20:41.273"}, "13982985": {"ViewCount": "1873", "Body": "<p>What happens when an unhandled exception is thrown from a constructor? For Java, and for C++? Will there be a memory leak?</p>\n", "Title": "what happens when an unhandled exception is thrown from a constructor", "CreationDate": "2012-12-21T01:14:37.590", "LastActivityDate": "2013-09-09T14:24:39.727", "CommentCount": "6", "PostTypeId": "1", "Id": "13982985", "Score": "9", "OwnerUserId": "219837", "Tags": "<java><c++><memory-leaks>", "AnswerCount": "8"}, "13983001": {"Id": "13983001", "PostTypeId": "2", "Body": "<p>For Java: Control flow returns to the caller just like with an exception being thrown from a regular method. No memory leak (the half-constructed instance will be discarded and garbage-collected)</p>\n", "LastActivityDate": "2012-12-21T01:17:24.817", "CommentCount": "0", "CreationDate": "2012-12-21T01:17:24.817", "ParentId": "13982985", "Score": "6", "OwnerUserId": "14955"}});