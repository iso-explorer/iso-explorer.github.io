post_cb({"bq_ids": {"n4140": {"so_21973064_21973403_1": {"length": 4, "quality": 0.8, "section_id": 6123}, "so_21973064_21973403_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 5999}}, "n3337": {"so_21973064_21973403_1": {"length": 4, "quality": 0.8, "section_id": 5887}, "so_21973064_21973403_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 5767}}, "n4659": {"so_21973064_21973403_1": {"length": 4, "quality": 0.8, "section_id": 7620}}}, "21973064": {"ViewCount": "248", "Body": "<p>Consider the following C++ code:</p>\n<pre><code>typedef std::string&amp; mutable_string_ref;\nconst std::string str = \"abc\";\nmutable_string_ref ref(str);\n</code></pre>\n<p>This obviously results in a compiler error, because you cannot create a mutable reference to a const string.  With GCC 4.7.2, the error this produces is:</p>\n<pre><code>error: invalid initialization of reference of type \u2018mutable_string_ref {aka std::basic_string&lt;char&gt;&amp;}\u2019 from expression of type \u2018const string {aka const std::basic_string&lt;char&gt;}\u2019\n</code></pre>\n<p><br/></p>\n<p><strong>BUT</strong>... why is it that if we try the same thing, only we pass the reference type as a <em>template parameter</em>, suddenly it seems to ignore the const-ness?</p>\n<p>Consider:</p>\n<pre><code>template &lt;class T&gt;\nT get()\n{\n    const static std::string s = \"abc\";\n    return T(s);\n}\n\nint main()\n{\n    std::string&amp; s = get&lt;std::string&amp;&gt;();\n    s = \"blah\"; // undefined behavior!!\n}\n</code></pre>\n<p>The above code compiles fine on GCC 4.7.2, with no warnings.  I don't understand why it compiles.  It seems the expression <code>T(s)</code> is basically being interpreted as a C-style cast that just casts away const-ness.  But why?  I instantiated the function template <code>get</code> with <code>T = std::string&amp;</code>, so the expression <code>return T(s)</code> should fail to compile because <code>s</code> is <code>const</code>.  Yet it doesn't fail.</p>\n<p>Ideone link: <a href=\"http://ideone.com/TAO5C6\" rel=\"nofollow\">http://ideone.com/TAO5C6</a></p>\n<p>Is this a compiler bug?  Or is there some valid reason this compiles?</p>\n", "AcceptedAnswerId": "21973403", "Title": "Casting to reference in a template seems to cast away const-ness", "CreationDate": "2014-02-23T19:05:11.110", "Id": "21973064", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-02-23T19:25:06.310", "LastEditorUserId": "2923952", "LastActivityDate": "2014-02-23T19:59:12.070", "Score": "8", "OwnerUserId": "2923952", "Tags": "<c++>", "AnswerCount": "1"}, "21973403": {"Id": "21973403", "PostTypeId": "2", "Body": "<p>You're not initializing, you're C-style casting, which indeed has the ability to cast away constness.</p>\n<p>From the standard:</p>\n<blockquote>\n<h3>5.2.3 Explicit type conversion (functional notation) [expr.type.conv]</h3>\n<p id=\"so_21973064_21973403_0\"><em><strong>1</strong> A simple-type-specifier (7.1.6.2) or typename-specifier (14.6) followed by a parenthesized expression-list constructs a value of the specified type given the expression list. If the expression list is a single expression, the type conversion expression is equivalent (in definedness, and if defined in meaning) to the corresponding cast expression (5.4).</em></p>\n<h3>5.4 Explicit type conversion (cast notation)</h3>\n<p id=\"so_21973064_21973403_1\"><em><strong>1</strong> The result of the expression (T) cast-expression is of type T. [...]</em></p>\n</blockquote>\n", "LastEditorUserId": "701092", "LastActivityDate": "2014-02-23T19:59:12.070", "Score": "3", "CreationDate": "2014-02-23T19:33:21.217", "ParentId": "21973064", "CommentCount": "4", "LastEditDate": "2014-02-23T19:59:12.070", "OwnerUserId": "602372"}});