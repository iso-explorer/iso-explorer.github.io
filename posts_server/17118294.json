post_cb({"bq_ids": {"n4140": {"so_17118294_17118768_0": {"length": 36, "quality": 1.0, "section_id": 243}}, "n3337": {"so_17118294_17118768_0": {"length": 36, "quality": 1.0, "section_id": 235}}, "n4659": {"so_17118294_17118768_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 250}}}, "17118294": {"ViewCount": "5620", "Body": "<p>Below is the code to recreate the problem I am having. <code>Base</code> class is a template class with the virtual function <code>foo</code>. <code>foo</code> has a default implementation that adds the passed in arguments.</p>\n<p><code>SimpleDerived</code> derives from <code>Base</code>, specializing it with <code>std::string</code>. <code>SimpleDerived</code> overloads the virtual <code>Base&lt;T&gt;::foo()</code> function. This class compiles fine and its <code>foo</code> outputs as expected when called in <code>main</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nstruct Base\n{\n    virtual void foo(T val)\n    {\n        T local = val + val;    // THE OFFENDING LINE OF CODE\n        std::cout &lt;&lt; \"Base\" &lt;&lt; std::endl;\n    }   \n};\n\nstruct SimpleDerived : public Base&lt;std::string&gt;\n{\n    virtual void foo(std::string val)\n    {\n        std::cout &lt;&lt; \"SimpleDerived\" &lt;&lt; std::endl;\n    }\n};\n\nstruct SimpleObject\n{\n    int value;\n};\n\nstruct ComplexDerived : public Base&lt;SimpleObject&gt;\n{\n    virtual void foo(SimpleObject val)\n    {\n        std::cout &lt;&lt; \"ComplexDerived\" &lt;&lt; std::endl;\n    }   \n};\n\nint main(void)\n{\n    Base&lt;int&gt; base;\n    base.foo(2);\n\n    SimpleDerived simpleDerived;\n    simpleDerived.foo(\"hello world\");\n\n    SimpleObject object;\n    ComplexDerived complexDerived;\n    complexDerived.foo(object);\n\n    return 0;\n}\n</code></pre>\n<p><code>ComplexDerived</code> derives from <code>Base</code>, specializing it with a custom struct <code>SimpleObject</code>. <code>ComplexDerived</code> overloads <code>foo</code> as well. However, this is the root of the problem. If I try to compile this I get:</p>\n<pre><code>quicktest.cpp: In member function \u2018void Base&lt;T&gt;::foo(T) [with T = SimpleObject]\u2019:\nquicktest.cpp:47:1:   instantiated from here\nquicktest.cpp:8:19: error: no match for \u2018operator+\u2019 in \u2018val + val\u2019\n</code></pre>\n<p>Obviously, there is no operator \"+\" for <code>SimpleObject</code>. But here is my confusion.. the compiler is being asked to implement <code>Base&lt;SimpleObject&gt;::foo</code> because this is what <code>ComplexDerived</code> inherits from. However, I never use or call <code>Base&lt;SimpleObject&gt;::foo</code>. So should the compiler be trying to generate this base class function?</p>\n", "AcceptedAnswerId": "17118768", "Title": "Overloading a C++ template class virtual function", "CreationDate": "2013-06-14T22:39:22.583", "Id": "17118294", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-06-14T23:58:08.327", "Score": "6", "OwnerUserId": "2130260", "Tags": "<c++><function><templates><virtual><overloading>", "AnswerCount": "1"}, "17118768": {"Id": "17118768", "PostTypeId": "2", "Body": "<p>Paragraph 14.7.1/10 of the C++11 Standard specifies:</p>\n<blockquote>\n<p id=\"so_17118294_17118768_0\">An implementation shall not implicitly instantiate a function template, a member template, a non-virtual\n  member function, a member class, or a static data member of a class template that does not require instantiation. <strong>It is unspecified whether or not an implementation implicitly instantiates\n  a virtual member function of a class template if the virtual member function would not otherwise be instantiated.</strong> [...]</p>\n</blockquote>\n<p>In other words, the behavior in this case is implementation-specific. </p>\n<p>While in theory the compiler <em>could</em> figure out that the call to the base class's implementation of <code>foo()</code> won't ever be invoked (since the function call does not occur through a reference or pointer) and avoid instantiating it, this behavior is not mandated by the Standard.</p>\n", "LastActivityDate": "2013-06-14T23:38:13.173", "Score": "9", "CreationDate": "2013-06-14T23:38:13.173", "ParentId": "17118294", "CommentCount": "2", "OwnerUserId": "1932150"}});