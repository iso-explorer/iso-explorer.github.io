post_cb({"17002161": {"Id": "17002161", "PostTypeId": "2", "Body": "<p>You can always fake it...</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;int NUM, int DEN&gt;\nstruct Float\n{\n    static constexpr float value() { return (float)NUM / (float)DEN; }\n    static constexpr float VALUE = value();\n};\n\ntemplate &lt;class GRAD, class CONST&gt;\nstruct LinearFunc\n{\n    static float func(float x) { return GRAD::VALUE*x + CONST::VALUE; }\n};\n\n\nint main()\n{\n    // Y = 0.333 x + 0.2\n    // x=2, y=0.866\n    std::cout &lt;&lt; \" func(2) = \"\n              &lt;&lt; LinearFunc&lt;Float&lt;1,3&gt;, Float&lt;1,5&gt; &gt; ::func(2) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Ref: <a href=\"http://code-slim-jim.blogspot.jp/2013/06/c11-no-floats-in-templates-wtf.html\" rel=\"nofollow\">http://code-slim-jim.blogspot.jp/2013/06/c11-no-floats-in-templates-wtf.html</a></p>\n", "LastActivityDate": "2013-06-08T17:43:52.943", "CommentCount": "2", "CreationDate": "2013-06-08T17:43:52.943", "ParentId": "2183087", "Score": "1", "OwnerUserId": "226019"}, "38973227": {"Id": "38973227", "PostTypeId": "2", "Body": "<p>Wrap the parameter(s) in their own class as constexprs. Effectively this is similar to a trait as it parameterizes the class with a set of floats.</p>\n<pre><code>class MyParameters{\n    public:\n        static constexpr float Kd =1.0f;\n        static constexpr float Ki =1.0f;\n        static constexpr float Kp =1.0f;\n};\n</code></pre>\n<p>and then create a template taking the class type as a parameter</p>\n<pre><code>  template &lt;typename NUM, typename TUNING_PARAMS &gt;\n  class PidController {\n\n      // define short hand constants for the PID tuning parameters\n      static constexpr NUM Kp = TUNING_PARAMS::Kp;\n      static constexpr NUM Ki = TUNING_PARAMS::Ki;\n      static constexpr NUM Kd = TUNING_PARAMS::Kd;\n\n      .... code to actually do something ...\n};\n</code></pre>\n<p>and then use it like so...</p>\n<pre><code>int main (){\n    PidController&lt;float, MyParameters&gt; controller;\n    ...\n    ...\n}\n</code></pre>\n<p>This allows the compiler to guarantee that only a single instance of the code is created for each template instantiation with the same parameter pack. That gets around all the issues and you are able to use floats and doubles as constexpr inside the templated class.</p>\n", "LastActivityDate": "2016-08-16T11:03:32.040", "CommentCount": "0", "CreationDate": "2016-08-16T11:03:32.040", "ParentId": "2183087", "Score": "3", "OwnerUserId": "4311258"}, "2183106": {"Id": "2183106", "PostTypeId": "2", "Body": "<p>The current C++ standard does not allow <code>float</code> (i.e. real number) or character string literals to be used as <em>template non-type parameters</em>. You can of course use the <code>float</code> and <code>char *</code> types as normal arguments. </p>\n<p>Perhaps the author is using a compiler that doesn't follow the current standard? </p>\n", "OwnerDisplayName": "anon", "LastEditorUserId": "1090079", "LastActivityDate": "2013-07-13T05:30:54.550", "Score": "29", "CreationDate": "2010-02-02T09:54:02.557", "ParentId": "2183087", "CommentCount": "4", "LastEditDate": "2013-07-13T05:30:54.550"}, "32870587": {"Id": "32870587", "PostTypeId": "2", "Body": "<p>If you are ok to have a fixed default per type you can create a type to define it as a constant and specialize it as needed.</p>\n<pre><code>template &lt;typename T&gt; struct MyTypeDefault { static const T value; };\ntemplate &lt;typename T&gt; const T MyTypeDefault&lt;T&gt;::value = T();\ntemplate &lt;&gt; struct MyTypeDefault&lt;double&gt; { static const double value; };\nconst double MyTypeDefault&lt;double&gt;::value = 1.0;\n\ntemplate &lt;typename T&gt;\nclass MyType {\n  public:\n    MyType() { value = MyTypeDefault&lt;T&gt;::value; }\n  private:\n    T value;\n };\n</code></pre>\n<p>If you have C++11 you can use constexpr when defining the default value. With C++14, MyTypeDefault can be a template variable which is a bit cleaner syntactically.</p>\n<pre><code>//C++14\ntemplate &lt;typename T&gt; constexpr T MyTypeDefault = T();\ntemplate &lt;&gt; constexpr double MyTypeDefault&lt;double&gt; = 1.0;\n\ntemplate &lt;typename T&gt;\nclass MyType {\n  private:\n    T value = MyTypeDefault&lt;T&gt;;\n };\n</code></pre>\n", "LastEditorUserId": "2608582", "LastActivityDate": "2015-09-30T16:00:43.463", "Score": "4", "CreationDate": "2015-09-30T15:54:39.433", "ParentId": "2183087", "CommentCount": "0", "OwnerUserId": "2608582", "LastEditDate": "2015-09-30T16:00:43.463"}, "bq_ids": {"n4140": {"so_2183087_11518757_3": {"length": 40, "quality": 0.975609756097561, "section_id": 87}, "so_2183087_11518757_6": {"length": 4, "quality": 0.8, "section_id": 87}, "so_2183087_11518757_5": {"length": 7, "quality": 0.875, "section_id": 87}, "so_2183087_11518757_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 87}, "so_2183087_11518757_0": {"length": 5, "quality": 1.0, "section_id": 87}, "so_2183087_11518757_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 87}}, "n3337": {"so_2183087_11518757_3": {"length": 40, "quality": 0.975609756097561, "section_id": 82}, "so_2183087_11518757_6": {"length": 4, "quality": 0.8, "section_id": 82}, "so_2183087_11518757_5": {"length": 7, "quality": 0.875, "section_id": 82}, "so_2183087_11518757_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 82}, "so_2183087_11518757_0": {"length": 5, "quality": 1.0, "section_id": 82}, "so_2183087_11518757_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 36}}, "n4659": {"so_2183087_11518757_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 90}, "so_2183087_11518757_4": {"length": 5, "quality": 0.7142857142857143, "section_id": 7690}, "so_2183087_11518757_5": {"length": 5, "quality": 0.625, "section_id": 42}}}, "30109418": {"Id": "30109418", "PostTypeId": "2", "Body": "<p>If you don't need the double to be a compile-time constant, you can pass it in as a pointer:</p>\n<pre><code>#include &lt;iostream&gt;\n\nextern const double kMyDouble = 0.1;;\n\ntemplate &lt;const double* MyDouble&gt;\nvoid writeDouble() {\n   std::cout &lt;&lt; *MyDouble &lt;&lt; std::endl; \n}\n\nint main()\n{\n    writeDouble&lt;&amp;kMyDouble&gt;();\n   return 0;\n}\n</code></pre>\n", "LastActivityDate": "2015-05-07T18:53:20.973", "CommentCount": "3", "CreationDate": "2015-05-07T18:53:20.973", "ParentId": "2183087", "Score": "1", "OwnerUserId": "3233025"}, "2185852": {"Id": "2185852", "PostTypeId": "2", "Body": "<p>Just to provide one of the reasons why this is a limitation (in the current standard at least).</p>\n<p>When matching template specializations, the compiler matches the template arguments, including non-type arguments.</p>\n<p>By their very nature, floating point values are not exact and their implementation is not specified by the C++ standard.  As a result, it is difficult to decide when two floating point non type arguments really match:</p>\n<pre><code>template &lt;float f&gt; void foo () ;\n\nvoid bar () {\n    foo&lt; (1.0/3.0) &gt; ();\n    foo&lt; (7.0/21.0) &gt; ();\n}\n</code></pre>\n<p>These expressions do not necessarily produce the same \"bit pattern\" and so it would not be possible to guarantee that they used the same specialization - without special wording to cover this.</p>\n", "LastActivityDate": "2010-02-02T16:46:37.450", "CommentCount": "2", "CreationDate": "2010-02-02T16:46:37.450", "ParentId": "2183087", "Score": "28", "OwnerUserId": "11698"}, "2183121": {"Id": "2183121", "PostTypeId": "2", "Body": "<p>Indeed, you can't use float literals as template parameters. See <a href=\"http://std.dkuug.dk/JTC1/SC22/open/n2356/template.html\" rel=\"noreferrer\">section 14.1</a> <em>(\"A non-type template-parameter shall have one of the following (optionally cv-qualified) types...\")</em> of the standard.</p>\n<p>You can use a reference to the float as a template parameter:</p>\n<pre><code>template &lt;class T, T const &amp;defaultValue&gt;\nclass GenericClass\n\n.\n.\n\nfloat const c_four_point_six = 4.6; // at global scope\n\n.\n.\n\nGenericClass &lt; float, c_four_point_six&gt; gcFlaot;\n</code></pre>\n", "LastEditorUserId": "11834", "LastActivityDate": "2010-02-02T10:03:00.497", "Score": "14", "CreationDate": "2010-02-02T09:56:47.653", "ParentId": "2183087", "CommentCount": "1", "OwnerUserId": "11834", "LastEditDate": "2010-02-02T10:03:00.497"}, "23999424": {"Id": "23999424", "PostTypeId": "2", "Body": "<p>If you only want to represent a fixed precision, then you can use a technique like this to convert a float parameter into an int.</p>\n<p>For example an array with a growth factor of 1.75 could be created as follows assuming 2 digits of precision (divide by 100).</p>\n<pre><code>template &lt;typename _Kind_, int _Factor_=175&gt;\nclass Array\n{\npublic:\n    static const float Factor;\n    _Kind_ * Data;\n    int Size;\n\n    // ...\n\n    void Resize()\n    {\n         _Kind_ * data = new _Kind_[(Size*Factor)+1];\n\n         // ...\n    }\n}\n\ntemplate&lt;typename _Kind_, int _Factor_&gt;\nconst float Array&lt;_kind_,_Factor_&gt;::Factor = _Factor_/100;\n</code></pre>\n<p>If you dont like the representation of 1.75 as 175 in the template argument list \nthen you could always wrap it in some macro.</p>\n<pre><code>#define FloatToIntPrecision(f,p) (f*(10^p))\n\ntemplate &lt;typename _Kind_, int _Factor_=FloatToIntPrecision(1.75,2)&gt;\n// ...\n</code></pre>\n", "LastActivityDate": "2014-06-02T16:43:04.577", "CommentCount": "1", "CreationDate": "2014-06-02T16:43:04.577", "ParentId": "2183087", "Score": "0", "OwnerUserId": "3700200"}, "11518757": {"Id": "11518757", "PostTypeId": "2", "Body": "<h2>THE SIMPLE ANSWER</h2>\n<p>The standard doesn't allow floating points as <em>non-type template-arguments</em>, which can be read about in the following section of the C++11 standard;</p>\n<blockquote>\n<h3>14.3.2/1 \u00a0\u00a0\u00a0\u00a0 Template non-type arguments \u00a0\u00a0\u00a0\u00a0 [temp.arg.nontype]</h3>\n<p id=\"so_2183087_11518757_0\">A template-argument for a non-type, non-template template-parameter\n  shall be one of:</p>\n<ul>\n<li><p id=\"so_2183087_11518757_1\">for a non-type template-parameter of integral or enumeration type, a converted constant expression (5.19) of the type of the\n  template-parameter;</p></li>\n<li><p id=\"so_2183087_11518757_2\">the name of a non-type template-parameter; or</p></li>\n<li><p id=\"so_2183087_11518757_3\">a constant expression (5.19) that designates the address of an object with static storage duration and external or internal linkage\n  or a function with external or internal linkage, including function\n  templates and function template-ids but excluding non-static class\n  members, expressed (ignoring parentheses) as &amp; id-expression, except\n  that the &amp; may be omitted if the name refers to a function or array\n  and shall be omitted if the corresponding template-parameter is a\n  reference; or</p></li>\n<li><p id=\"so_2183087_11518757_4\">a constant expression that evaluates to a null pointer value (4.10); or</p></li>\n<li><p id=\"so_2183087_11518757_5\">a constant expression that evaluates to a null member pointer value (4.11); or</p></li>\n<li><p id=\"so_2183087_11518757_6\">a pointer to member expressed as described in 5.3.1.</p></li>\n</ul>\n</blockquote>\n<hr>\n<h2>But.. but.. WHY!?</h2>\n<p>It is probably due to the fact that floating point calculations cannot be represented in an exact manner. If it was allowed it could/would result in erroneous/weird behavior when doing something as this;</p>\n<pre><code>func&lt;1/3.f&gt; (); \nfunc&lt;2/6.f&gt; ();\n</code></pre>\n<p>We meant to call the same function twice but this might not be the case since the floating point representation of the two calculations isn't guaranteed to be <strong>exactly</strong> the same.</p>\n<hr>\n<h2>How would I represent floating point values as template arguments?</h2>\n<p>With <code>C++11</code> you could write some pretty advanced <em>constant-expressions</em> (<em>constexpr</em>) that would calculate the numerator/denominator of a floating value compile time and then pass these two as separate integer arguments.</p>\n<p>Remember to define some sort of threshold so that floating point values close to each other yields the same <em>numerator/denominator</em>, otherwise it's kinda pointless since it will then yield the same result previously mentioned as a reason not to allow floating point values as  <em>non-type template arguments</em>.</p>\n</hr></hr>", "LastEditorUserId": "66516", "LastActivityDate": "2015-11-06T14:39:19.210", "Score": "103", "CreationDate": "2012-07-17T08:31:44.867", "ParentId": "2183087", "CommentCount": "8", "OwnerUserId": "1090079", "LastEditDate": "2015-11-06T14:39:19.210"}, "2183087": {"ViewCount": "32073", "Body": "<p>When I try to use <code>float</code> as a template parameter, the compiler cries for this code, while <code>int</code> works fine.</p>\n<p>Is it because I cannot use <code>float</code> as a template parameter?</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class T, T defaultValue&gt;\nclass GenericClass\n{\nprivate:\n    T value;\npublic:\n    GenericClass()\n    {\n        value = defaultValue;\n    }\n\n    T returnVal()\n    {\n        return value;\n    }\n}; \n\n\nint main()\n{\n    GenericClass &lt;int, 10&gt; gcInteger;\n    GenericClass &lt; float, 4.6f&gt; gcFlaot;\n\n    cout &lt;&lt; \"\\n sum of integer is \"&lt;&lt;gcInteger.returnVal();\n    cout &lt;&lt; \"\\n sum of float is \"&lt;&lt;gcFlaot.returnVal();\n\n    return 0;       \n}\n</code></pre>\n<p><strong>Error:</strong></p>\n<pre class=\"lang-none prettyprint-override\"><code>main.cpp: In function `int main()':\nmain.cpp:25: error: `float' is not a valid type for a template constant parameter\nmain.cpp:25: error: invalid type in declaration before ';' token\n\nmain.cpp:28: error: request for member `returnVal' in `gcFlaot',\n                    which is of non-class type `int'\n</code></pre>\n<p>I am reading <em>\"Data Structures for Game Programmers\"</em> by Ron Penton, the author passes a <code>float</code>, but when I try it it doesn't seem to compile.</p>\n", "AcceptedAnswerId": "2183106", "Title": "Why can't I use float value as a template parameter?", "CreationDate": "2010-02-02T09:50:23.927", "Id": "2183087", "CommentCount": "2", "FavoriteCount": "16", "PostTypeId": "1", "LastEditDate": "2014-03-02T11:53:58.593", "LastEditorUserId": "1090079", "LastActivityDate": "2016-08-16T11:03:32.040", "Score": "80", "OwnerUserId": "205929", "Tags": "<c++><templates><generics><floating-point>", "AnswerCount": "9"}});