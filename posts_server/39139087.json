post_cb({"39139188": {"ParentId": "39139087", "PostTypeId": "2", "CommentCount": "14", "Body": "<p><strong>1. The behavior of <code>std::is_move_constructible</code></strong></p>\n<p>This is expected behavior of <a href=\"http://en.cppreference.com/w/cpp/types/is_move_constructible#Notes\">std::is_move_constructible</a>:</p>\n<blockquote>\n<p id=\"so_39139087_39139188_0\">Types without a move constructor, but with a copy constructor that accepts <code>const T&amp;</code> arguments, satisfy <code>std::is_move_constructible</code>.</p>\n</blockquote>\n<p>Which means with a copy constructor it's still possible to construct <code>T</code> from rvalue reference <code>T&amp;&amp;</code>. And <code>Foo&lt;Bar&gt;</code> has an <a href=\"http://en.cppreference.com/w/cpp/language/copy_constructor#Implicitly-declared_copy_constructor\">Implicitly-declared copy constructor</a>.</p>\n<p><strong>2. The implicitly-declared move constructor of <code>Foo&lt;Bar&gt;</code></strong></p>\n<blockquote>\n<p id=\"so_39139087_39139188_1\">Why does compiler generates move constructor despite base class being non-move-constructible?</p>\n</blockquote>\n<p>In fact, the move constructor of <code>Foo&lt;Bar&gt;</code> is defined as <a href=\"http://en.cppreference.com/w/cpp/language/move_constructor#Deleted_implicitly-declared_move_constructor\">deleted</a>, but note that the deleted implicitly-declared move constructor is ignored by overload resolution. </p>\n<blockquote>\n<p id=\"so_39139087_39139188_2\">The implicitly-declared or defaulted move constructor for class <code>T</code> is\n  defined as deleted in any of the following is true:</p>\n<pre><code>...\nT has direct or virtual base class that cannot be moved (has deleted, inaccessible, or ambiguous move constructors); \n...\n</code></pre>\n<p id=\"so_39139087_39139188_3\">The deleted implicitly-declared move constructor is ignored by overload resolution (otherwise it would prevent copy-initialization from rvalue). </p>\n</blockquote>\n<p><strong>3. The different behavior between <code>Bar</code> and <code>Foo&lt;Bar&gt;</code></strong></p>\n<p>Note that the move constructor of <code>Bar</code> is declared as <code>deleted</code> explicitly, and the move constructor of <code>Foo&lt;Bar&gt;</code> is implicitly-declared and defined as <code>deleted</code>. The point is that <strong>the deleted implicitly-declared move constructor is ignored by overload resolution</strong>, which makes it possible to move construct <code>Foo&lt;Bar&gt;</code> with its copy constructor. But the explicitly deleted move constructor will participate in overload resolution, means when trying to move constructor <code>Bar</code> the deleted move constructor will be selected, then the program is ill-formed.</p>\n<p>That's why <code>Foo&lt;Bar&gt;</code> is move constructible but <code>Bar</code> is not.</p>\n<p>The standard has an explicit statement about this. <a href=\"http://eel.is/c++draft/class.copy#11\">$12.8/11 Copying and moving class objects\n[class.copy]</a></p>\n<blockquote>\n<p id=\"so_39139087_39139188_4\">A defaulted move constructor that is defined as deleted is ignored by overload resolution ([over.match], [over.over]). [ Note: A deleted move constructor would otherwise interfere with initialization from an rvalue which can use the copy constructor instead.  \u2014 end note ]</p>\n</blockquote>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2016-08-25T09:53:14.540", "Id": "39139188", "Score": "23", "CreationDate": "2016-08-25T07:29:41.410", "LastActivityDate": "2016-08-25T09:53:14.540"}, "39139214": {"ParentId": "39139087", "CommentCount": "5", "Body": "<p>Because:</p>\n<blockquote>\n<p id=\"so_39139087_39139214_0\">A defaulted move constructor that is defined as deleted is ignored by overload resolution.</p>\n</blockquote>\n<p>([class.copy]/11)</p>\n<p><code>Bar</code>'s move constructor is <em>explicitly deleted</em>, so <code>Bar</code> cannot be moved. But <code>Foo&lt;Bar&gt;</code>'s move constructor is <em>implicitly deleted</em> after being implicitly declared as defaulted, due to the fact that the <code>Bar</code> member cannot be moved. Therefore <code>Foo&lt;Bar&gt;</code> can be moved using its copy constructor.</p>\n<p>Edit: I also forgot to mention the important fact that an inheriting constructor declaration such as <code>using Base::Base</code> does not inherit default, copy, or move constructors, so that's why <code>Foo&lt;Bar&gt;</code> doesn't have an explicitly deleted move constructor inherited from <code>Bar</code>.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "39139214", "Score": "29", "CreationDate": "2016-08-25T07:30:52.897", "LastActivityDate": "2016-08-25T07:30:52.897"}, "bq_ids": {"n4140": {"so_39139087_39139214_0": {"section_id": 460, "quality": 1.0, "length": 8}, "so_39139087_39139188_4": {"section_id": 460, "quality": 0.8076923076923077, "length": 21}, "so_39139087_39139188_3": {"section_id": 460, "quality": 0.6153846153846154, "length": 8}, "so_39139087_39139188_2": {"section_id": 369, "quality": 0.6, "length": 6}}, "n3337": {"so_39139087_39139214_0": {"section_id": 451, "quality": 0.75, "length": 6}, "so_39139087_39139188_2": {"section_id": 359, "quality": 0.6, "length": 6}}, "n4659": {"so_39139087_39139214_0": {"section_id": 483, "quality": 1.0, "length": 8}, "so_39139087_39139188_0": {"section_id": 474, "quality": 0.5454545454545454, "length": 6}, "so_39139087_39139188_4": {"section_id": 483, "quality": 0.8076923076923077, "length": 21}, "so_39139087_39139188_3": {"section_id": 483, "quality": 0.6153846153846154, "length": 8}, "so_39139087_39139188_2": {"section_id": 483, "quality": 0.6, "length": 6}}}, "39139087": {"CommentCount": "7", "AcceptedAnswerId": "39139214", "PostTypeId": "1", "LastEditorUserId": "3309790", "CreationDate": "2016-08-25T07:23:28.743", "LastActivityDate": "2016-08-25T14:18:40.253", "LastEditDate": "2016-08-25T14:18:40.253", "ViewCount": "1733", "FavoriteCount": "5", "Title": "Why is derived class move constructible when base class isn't?", "Id": "39139087", "Score": "56", "Body": "<p>Consider the following example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n\ntemplate &lt;typename Base&gt; struct Foo : public Base {\n    using Base::Base;\n};\n\nstruct Bar {\n    Bar(const Bar&amp;) { }\n    Bar(Bar&amp;&amp;) = delete;\n};\n\nint main() {\n    std::cout &lt;&lt; std::is_move_constructible&lt;Bar&gt;::value &lt;&lt; std::endl; // NO\n    std::cout &lt;&lt; std::is_move_constructible&lt;Foo&lt;Bar&gt;&gt;::value &lt;&lt; std::endl; // YES. Why?!\n}\n</code></pre>\n<p>Why does the compiler generate a move constructor despite the base class being non-move-constructible?</p>\n<p>Is that in the standard or is it a compiler bug? Is it possible to \"perfectly propagate\" move construction from base to derived class? </p>\n", "Tags": "<c++><c++11><language-lawyer><move-semantics><move-constructor>", "OwnerUserId": "2163127", "AnswerCount": "2"}});