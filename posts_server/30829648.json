post_cb({"30830594": {"Id": "30830594", "PostTypeId": "2", "Body": "<p>This is actually correct behavior on the compilers' part. Overload resolution has two steps, from [over.match]:</p>\n<blockquote>\n<p id=\"so_30829648_30830594_0\">\u2014 First, a subset of the candidate functions (those that have the proper number of arguments and meet\n  certain other conditions) is selected to form a set of viable functions (13.3.2).<br>\n  \u2014 Then the best viable function is selected based on the implicit conversion sequences (13.3.3.1) needed\n  to match each argument to the corresponding parameter of each viable function.</br></p>\n</blockquote>\n<p>The candidate functions for <code>x1 + x2</code> are:</p>\n<pre><code>// TAG1\ntemplate &lt; typename T &gt;\nA_Number&lt; T &gt;\noperator+(const A_Number&lt; T &gt; &amp;a, const A_Number&lt; T &gt; &amp;b);\n\n// TAG2\ntemplate &lt; typename T, typename S &gt;\nA_Number&lt; T &gt;\noperator+(const A_Number&lt; T &gt; &amp;a, const S &amp;b);\n\n// TAG3\ntemplate &lt; typename T, typename S &gt;\nauto operator+(const S &amp;b, const A_Number&lt; T &gt; &amp;a) -&gt; decltype(a + b)\n</code></pre>\n<p>So ok, we need to determine what the return type is for <code>TAG3</code> first, before we pick the best viable candidate. Now, <code>operator+</code> is a <em>dependent name</em> here, as it depends on two template arguments. So according to [temp.dep.res]:</p>\n<blockquote>\n<p id=\"so_30829648_30830594_1\">In resolving dependent names, names from the following sources are considered:<br>\n  \u2014 Declarations that are visible at the point of definition of the template.<br>\n  \u2014 Declarations from namespaces associated with the types of the function arguments both from the\n  instantiation context (14.6.4.1) and from the definition context.</br></br></p>\n</blockquote>\n<p>So to resolve the return type of <code>TAG3</code>, we need to do lookup and overload resolution on <code>a+b</code>. That gives us our same three candidates again (the first two found the usual way, <code>TAG3</code> not-so-helpfully being found again via ADL), so around and around we go.</p>\n<p>Your solutions are:</p>\n<ul>\n<li>In C++14, drop the trailing return type for <code>TAG3</code>. That stops the merry-go-round, and we will start with our three viable candiates, of which <code>TAG1</code> is most specialized so it will be selected as the best viable candidate.</li>\n<li><p>Prevent <code>TAG3</code> from being instantiated if <code>S</code> is <code>A_Number&lt;T&gt;</code>. For instance, we can create a type trait for <code>A_Number</code>:</p>\n<pre><code>template &lt;typename T&gt;\nstruct is_A_Number : std::false_type { };\n\ntemplate &lt;typename T&gt;\nstruct is_A_Number&lt;A_Number&lt;T&gt;&gt; : std::true_type { };\n\n// TAG3\ntemplate &lt; typename T, typename S, \n           typename = typename std::enable_if&lt;!is_A_Number&lt;S&gt;::value&gt;::type&gt;\nauto operator+(const S &amp;b, const A_Number&lt; T &gt; &amp;a) -&gt; decltype(a + b);\n</code></pre></li>\n</ul>\n<p>That will compile even in C++11.</p>\n", "LastActivityDate": "2015-06-14T14:33:39.370", "CommentCount": "0", "CreationDate": "2015-06-14T14:33:39.370", "ParentId": "30829648", "Score": "0", "OwnerUserId": "2069064"}, "bq_ids": {"n4140": {"so_30829648_30830594_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 215}, "so_30829648_30830594_0": {"length": 36, "quality": 0.9473684210526315, "section_id": 563}}, "n3337": {"so_30829648_30830594_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 209}, "so_30829648_30830594_0": {"length": 36, "quality": 0.9473684210526315, "section_id": 554}}, "n4659": {"so_30829648_30830594_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 223}, "so_30829648_30830594_0": {"length": 36, "quality": 0.9473684210526315, "section_id": 586}}}, "30829648": {"ViewCount": "263", "Body": "<p>For a class with expression templates, I stumbled over the following error during return type deduction of overloaded operators. The example below illustrates the error:</p>\n<pre><code>template &lt; typename T &gt;\nstruct A_Number {\n     T x;\n};\n\n\n// TAG1\ntemplate &lt; typename T &gt;\nA_Number&lt; T &gt;\noperator+(const A_Number&lt; T &gt; &amp;a, const A_Number&lt; T &gt; &amp;b)\n{\n    return {a.x + b.x};\n}\n\n// TAG2\ntemplate &lt; typename T, typename S &gt;\nA_Number&lt; T &gt;\noperator+(const A_Number&lt; T &gt; &amp;a, const S &amp;b)\n{\n    return {a.x + b};\n}\n\n// TAG3\ntemplate &lt; typename T, typename S &gt;\nauto\noperator+(const S &amp;b, const A_Number&lt; T &gt; &amp;a) -&gt; decltype(a + b)\n//                                                        ^^^^^\n{\n    return a + b;\n}\n\nint\nmain(void)\n{\n    auto x1 = A_Number&lt; int &gt;{1};\n    auto x2 = A_Number&lt; int &gt;{1};\n\n    auto res1 = x1 + 1;  // instantiates TAG2\n\n    auto res2 = 1 + x1;  // instantiates TAG3, TAG2\n\n    auto res3 = x1 + x2; // error, tries to match TAG3\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>When trying to compile this with g++-5 or clang++, I get this error</p>\n<pre><code>fatal error: template instantiation depth exceeds maximum of 900 (use -ftemplate-depth= to increase the maximum)\n operator+(const S &amp;b, const A_Number&lt; T &gt; &amp;a) -&gt; decltype(a + b)\n</code></pre>\n<p>Apparently, the compilers try to match version TAG3, although a better match (TAG1) is available. When trying to match, they try to deduce the return type which seems to cause recursive instantiations of TAG3. Why does the return type deduction not see the other (better matching) overloads? And is it correct behavior to deduce the return type even though another overloaded template function has a better matching signature?</p>\n<p>Interestingly, this error evaporates in thin air, when omitting the return type altogether and compiling with <code>c++14</code>, like so:</p>\n<pre><code>// TAG3\ntemplate &lt; typename T, typename S &gt;\nauto\noperator+(const S &amp;b, const A_Number&lt; T &gt; &amp;a) // C++14\n{\n    return a + b;\n}\n</code></pre>\n<p>Admittedly, it's an academic question because workarounds are possible. But can anybody elucidate whether this behavior is standard conforming or a compiler bug?</p>\n", "Title": "decltype, recursive type deduction for overloaded operator", "CreationDate": "2015-06-14T12:57:59.277", "LastActivityDate": "2015-09-04T18:28:06.513", "CommentCount": "0", "LastEditDate": "2015-09-04T18:28:06.513", "PostTypeId": "1", "LastEditorUserId": "2069064", "Id": "30829648", "Score": "2", "OwnerUserId": "1978011", "Tags": "<c++><templates><c++11><language-lawyer><decltype>", "AnswerCount": "1"}});