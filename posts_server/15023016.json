post_cb({"15023271": {"ParentId": "15023016", "CommentCount": "2", "Body": "<p>Calling the incorrect destructor, I think, is undefined behaviour. You should have a virtual destructor. </p>\n<p>However, since the allocation is done in one block for the Derived class, it \"works\" because the internals of delete simply keeps track of the size of the allocation, and thus frees the 8 bytes that the object takes up, instead of the four that Base would use.</p>\n<p>Note that the virtual destructor is not responsible in itself of FREEING the memory that <code>this</code> points to. That happens in <code>delete</code> after the destructor has been called. </p>\n", "OwnerUserId": "1919155", "PostTypeId": "2", "Id": "15023271", "Score": "2", "CreationDate": "2013-02-22T11:35:24.703", "LastActivityDate": "2013-02-22T11:35:24.703"}, "15023142": {"ParentId": "15023016", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><strong>As other great guys mentioned, the standard says it is undefined behavior, but usually amongst compilers that care about competition and users</strong> this is up to system allocator implementation, which can be different from platform to platform. The destructor itself does not free the memory of <code>Derived</code> object, which contains fields.</p>\n<p>When you call <code>new Derived</code>, global implementation of <code>operator new</code> is called and it receives number of bytes to allocate. It will be <code>sizeof(Derived)</code> in your case.</p>\n<p>Upon actual memory freeing (global <code>operator delete</code>), allocator will know how many bytes to free from the address of the object being freed. So, the memory used by both <code>b</code> and <code>d</code> will be reclaimed</p>\n", "OwnerUserId": "1560833", "LastEditorUserId": "1560833", "LastEditDate": "2013-02-22T12:30:22.393", "Id": "15023142", "Score": "1", "CreationDate": "2013-02-22T11:27:54.633", "LastActivityDate": "2013-02-22T12:30:22.393"}, "bq_ids": {"n4140": {"so_15023016_15023257_0": {"section_id": 6107, "quality": 0.9512195121951219, "length": 39}}, "n3337": {"so_15023016_15023257_0": {"section_id": 5873, "quality": 0.9512195121951219, "length": 39}}, "n4659": {"so_15023016_15023257_0": {"section_id": 7604, "quality": 0.9512195121951219, "length": 39}}}, "15023016": {"CommentCount": "4", "ViewCount": "205", "PostTypeId": "1", "LastEditorUserId": "1192297", "CreationDate": "2013-02-22T11:20:37.003", "LastActivityDate": "2013-02-22T12:30:22.393", "Title": "Destruction of class members when destructor is not called", "AcceptedAnswerId": "15023257", "LastEditDate": "2013-02-22T12:02:16.250", "Id": "15023016", "Score": "6", "Body": "<p>In the following code, when <code>ptr</code> is deleted, the destructor for <code>Base</code> is called, but not the destructor for <code>Derived</code> (due to destructor of <code>Base</code> not being virtual).</p>\n<pre><code>class Base\n{\n  int b;\n};\n\nclass Derived : public Base\n{\n  int d;\n};\n\nint main(void)\n{\n    Base * ptr = new Derived();\n    delete ptr;\n    return 0;\n}\n</code></pre>\n<p>Valgrind reports that the program contains no memory leaks, which i guess is true in the sense that all newed data is deleted in this particular case. <strong>My question is - given that the (default) destructor of <code>Derived</code> is not called, when and how is the memory for <code>d</code> deallocated or reclaimed?</strong></p>\n", "Tags": "<c++>", "OwnerUserId": "1192297", "AnswerCount": "3"}, "15023257": {"ParentId": "15023016", "CommentCount": "0", "Body": "<p>It is Undefined behavior to call <code>delete</code> on a base class pointer pointing to a derived class object if the destructor in base class is not <code>virtual</code>.     </p>\n<p>Undefined behavior means that anything can happen. Whether memory leaks or not is irrelevant the fact is that your program can show any behavior and you cannot rely on any behavior that is shown.</p>\n<p><strong>For your code to be valid the destructor in Base class must be <code>virtual</code>.</strong></p>\n<hr>\n<p><strong>C++11 Standard 5.3.5 Delete:</strong><br>\n<strong>Para 3:</strong> </br></p>\n<blockquote>\n<p id=\"so_15023016_15023257_0\">In the first alternative (delete object), <strong>if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the static type shall have a virtual destructor or the behavior is undefined</strong>. In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n</hr>", "OwnerUserId": "452307", "PostTypeId": "2", "Id": "15023257", "Score": "8", "CreationDate": "2013-02-22T11:34:32.460", "LastActivityDate": "2013-02-22T11:34:32.460"}});