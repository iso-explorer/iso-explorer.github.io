post_cb({"bq_ids": {"n4140": {"so_8501294_8501421_1": {"length": 9, "quality": 0.75, "section_id": 188}, "so_8501294_8501421_4": {"length": 16, "quality": 0.8, "section_id": 224}, "so_8501294_8501421_3": {"length": 12, "quality": 0.75, "section_id": 224}}, "n3337": {"so_8501294_8501421_1": {"length": 9, "quality": 0.75, "section_id": 182}, "so_8501294_8501421_2": {"length": 13, "quality": 0.6190476190476191, "section_id": 217}, "so_8501294_8501421_4": {"length": 16, "quality": 0.8, "section_id": 217}, "so_8501294_8501421_3": {"length": 12, "quality": 0.75, "section_id": 217}}, "n4659": {"so_8501294_8501421_1": {"length": 7, "quality": 0.5833333333333334, "section_id": 193}, "so_8501294_8501421_4": {"length": 16, "quality": 0.8, "section_id": 232}, "so_8501294_8501421_3": {"length": 12, "quality": 0.75, "section_id": 232}}}, "8501455": {"Id": "8501455", "PostTypeId": "2", "Body": "<p>Yes, this is the expected behaviour. In the first case (::read) you effectivly disable ADL (argument dependent lookup) which restricts name lookup to things that have been declared in the global scope <em>before</em> your use of read. If you remove :: ADL will kick which may resolve to functions you declared <em>after</em> your function template.</p>\n<p>Edit: And since for fundamental types like <code>int</code> and <code>double</code> there is no ADL, this explains your 2nd observation.</p>\n", "LastEditorUserId": "172531", "LastActivityDate": "2011-12-14T08:43:58.520", "Score": "5", "CreationDate": "2011-12-14T08:33:02.557", "ParentId": "8501294", "CommentCount": "3", "OwnerUserId": "172531", "LastEditDate": "2011-12-14T08:43:58.520"}, "8501421": {"Id": "8501421", "PostTypeId": "2", "Body": "<p>What you're observing is a superposition of <em>two-phase name lookup</em> and <em>argument dependent lookup</em>.</p>\n<p>Let's see what the standard says (C++03). [temp.dep]:</p>\n<blockquote>\n<p id=\"so_8501294_8501421_0\">[...] In an expression of the form:</p>\n<pre><code>postfix-expression ( expression-listopt )\n</code></pre>\n<p id=\"so_8501294_8501421_1\">where the postfix-expression is an identifier, the identifier denotes a dependent name if and only if any of the expressions in the expression-list is a type-dependent expression (14.6.2.2).</p>\n</blockquote>\n<p>That means that in both <code>read</code> and <code>::read</code>, <code>read</code> is a dependent name because <code>x</code> is type-dependent. That means that it's resolved at the point of instantiation. Let's see what are the rules for this [temp.dep.candidate]:</p>\n<blockquote>\n<p id=\"so_8501294_8501421_2\">For a function call that depends on a template parameter, if the function name is an unqualified-id but not a template-id, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2) except that:</p>\n<p id=\"so_8501294_8501421_3\">\u2014 For the part of the lookup using unqualified name lookup (3.4.1), only function declarations with external linkage from the template <strong>definition context</strong> are found.</p>\n</blockquote>\n<p>Therefore for the <code>::read</code> case only functions declared before the template definition are considered. But:</p>\n<blockquote>\n<p id=\"so_8501294_8501421_4\">\u2014 For the part of the lookup using <strong>associated namespaces</strong> (3.4.2), only function declarations with external linkage found in either the template <strong>definition context</strong> or the template <strong>instantiation context</strong> are found.</p>\n</blockquote>\n<p>for the unqualified <code>read</code> both functions are considered, those visible at template definition and template instantiation.</p>\n", "LastEditorUserId": "277176", "LastActivityDate": "2011-12-14T09:14:14.783", "Score": "9", "CreationDate": "2011-12-14T08:30:09.037", "ParentId": "8501294", "CommentCount": "5", "OwnerUserId": "277176", "LastEditDate": "2011-12-14T09:14:14.783"}, "8501294": {"ViewCount": "1089", "Body": "<p>How should this code behave? It calls generic function ignoring my overload if I use <em>qualified</em> name in <code>call_read()</code> function; and it calls overload first and then generic version if I use <em>unqualified</em> name. What's the difference? Is it a bug in GCC?</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct info1 {};\nstruct info2 {};\n\ntemplate&lt;class T&gt; void read(T&amp; x)\n{\n   std::cout &lt;&lt; \"generic\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;class T&gt; void call_read(T&amp; x)\n{\n   ::read(x); // if I replace ::read(x) with read(x) the overload is called\n}\n\nvoid read(info1&amp; x)\n{\n   std::cout &lt;&lt; \"overload\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n   info1 x;\n   info2 y;\n   call_read(x);\n   call_read(y);\n}\n</code></pre>\n<p>I also noticed that it works different for fundamental types.\nSee the code bellow</p>\n<pre><code>#include &lt;iostream&gt;\n\ntypedef struct info1 {};\ntypedef struct info2 {};\ntypedef int info3;\ntypedef double info4;\n\ntemplate&lt;class T&gt; void read(T x)\n{\n    std::cout &lt;&lt; \"generic\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;class T&gt; void call_read(T x)\n{\n    read(x);\n}\n\nvoid read(info1 x)\n{\n    std::cout &lt;&lt; \"overload\" &lt;&lt; std::endl;\n}\nvoid read(info3 x)\n{\n    std::cout &lt;&lt; \"overload\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n    call_read(info1());\n    call_read(info2());\n    call_read(info3());\n    call_read(info4());\n}\n</code></pre>\n<p>It is supposed to call overloaded function twice, but it's not.\nSee the result here\n<a href=\"http://codepad.org/iFOOFD52\" rel=\"nofollow\">http://codepad.org/iFOOFD52</a></p>\n", "AcceptedAnswerId": "8501421", "Title": "Different behavior for qualified and unqualified name lookup for template", "CreationDate": "2011-12-14T08:18:35.587", "Id": "8501294", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2014-11-10T02:39:00.910", "LastEditorUserId": "1505939", "LastActivityDate": "2014-11-10T02:39:00.910", "Score": "12", "OwnerUserId": "940912", "Tags": "<c++><templates><lookup><language-lawyer><argument-dependent-lookup>", "AnswerCount": "3"}, "8501436": {"Id": "8501436", "PostTypeId": "2", "Body": "<p>The compiler will always call the method which match the most your call. Here you call :</p>\n<pre><code>read(T&amp; x) [with T = info1]\n</code></pre>\n<p>Thus the compiler will prefer the overload as it precisely match the call. It in the logic of template specializations, which permits to say that if an overloaded function exists which better match your call, then this one will be used.</p>\n<p>For the second part of the question, concerning the difference when using fully-qualified and unqualified names, it comes from the fact that fully-qualified name is not dependent to anything else, and is thus resolved to the first match (here your template declaration).</p>\n", "LastActivityDate": "2011-12-14T08:31:42.730", "CommentCount": "2", "CreationDate": "2011-12-14T08:31:42.730", "ParentId": "8501294", "Score": "-1", "OwnerUserId": "610351"}});