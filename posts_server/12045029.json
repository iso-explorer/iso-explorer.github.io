post_cb({"12045275": {"ParentId": "12045029", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2012-08-20T21:13:23.453", "Score": "1", "LastEditorUserId": "661519", "LastEditDate": "2012-08-21T05:57:50.347", "Id": "12045275", "OwnerUserId": "661519", "Body": "<p>You have two errors. </p>\n<p>First of all, you cannot use the local type <code>visitor</code> to instantiate the template member function function <code>iterate</code> (this would work in C++11).</p>\n<p>Second, you cannot have an anonymous type here. You need a named <code>struct visitor</code> and you would need to pass an instance of that.</p>\n<pre><code>#include &lt;deque&gt;\n#include &lt;iostream&gt;\n\nstruct visitor {\n  void operator()(int x) {\n    std::cout &lt;&lt; x &lt;&lt; std::endl;\n  }\n};\n\nclass Test {\npublic:\n  std::deque&lt;int&gt; d;\n\n  template &lt;typename C&gt;\n  void iterate(C&amp; c) {\n    for(std::deque&lt;int&gt;::iterator itr = d.begin(); itr != d.end(); itr++) {\n      c(*itr);\n    }\n  }\n};\n\nint main() {\n  Test test;\n  test.d.push_back(1);\n  test.d.push_back(2);\n\n  visitor v;\n  test.iterate(v);\n}\n</code></pre>\n", "LastActivityDate": "2012-08-21T05:57:50.347"}, "12045334": {"ParentId": "12045029", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2012-08-20T21:17:53.427", "Score": "1", "LastEditorUserId": "201270", "LastEditDate": "2012-08-20T21:31:07.870", "Id": "12045334", "OwnerUserId": "1364836", "Body": "<p>You could make <code>visitor</code> global and you'll also need to name the <code>struct</code>, say something like <code>Visitor</code>.</p>\n<pre><code>#include &lt;deque&gt;\n#include &lt;iostream&gt;\n\nstruct Visitor {\n    void operator()(int x) \n    {\n       std::cout &lt;&lt; x &lt;&lt; std::endl;\n    }\n};\n\n\nclass Test {\npublic:\n    std::deque&lt;int&gt; d;\n\n    template &lt;typename C&gt;\n    void iterate(C&amp; c) {\n        for(std::deque&lt;int&gt;::iterator itr = d.begin(); itr != d.end(); itr++) {\n            c(*itr);\n        }\n    }\n};\n\nint main(int argc, char** argv) {\n    Test test;\n    test.d.push_back(1);\n    test.d.push_back(2);\n    Visitor visitor;\n    test.iterate(visitor);\n}\n</code></pre>\n", "LastActivityDate": "2012-08-20T21:31:07.870"}, "bq_ids": {"n4140": {"so_12045029_12045179_0": {"section_id": 7141, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_12045029_12045179_0": {"section_id": 6885, "quality": 0.6666666666666666, "length": 8}}, "n4659": {"so_12045029_12045179_0": {"section_id": 8642, "quality": 0.6666666666666666, "length": 8}}}, "12045179": {"ParentId": "12045029", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2012-08-20T21:06:53.717", "Score": "3", "LastEditorUserId": "201270", "LastEditDate": "2012-08-20T21:21:11.370", "Id": "12045179", "OwnerUserId": "201270", "Body": "<p>The C++03 standard says the following in \u00a714.3.1.2 [temp.arg.type]:</p>\n<blockquote>\n<p id=\"so_12045029_12045179_0\">A local type, a type with no linkage, an unnamed type or a type\n  compounded from any of these types shall not be used as a\n  template-argument for a template type-parameter.</p>\n</blockquote>\n<p>Therefore you need a global named struct instead of a local unnamed one, giving you something like the following:</p>\n<pre><code>struct Visitor {\n    void operator()(int x) {\n        std::cout &lt;&lt; x &lt;&lt; std::endl;\n    }\n} visitor;\nint main(int argc, char** argv) {\n    Test test;\n    test.d.push_back(1);\n    test.d.push_back(2);\n    Visitor visitor;\n    test.iterate(visitor);\n}\n</code></pre>\n<p>The restrictions on local/unnamed typed have been lifted in c++11, so if those reasons not to use it go away someday your code will be fine as is.</p>\n", "LastActivityDate": "2012-08-20T21:21:11.370"}, "12045029": {"CommentCount": "2", "ViewCount": "365", "CreationDate": "2012-08-20T20:56:28.910", "LastActivityDate": "2012-08-21T05:57:50.347", "Title": "\"No matching function\" for template function accepting a callback", "AcceptedAnswerId": "12045179", "PostTypeId": "1", "Id": "12045029", "Score": "3", "Body": "<p>I'm trying to pass a callback to a template function, but GCC gives me </p>\n<pre><code>error: no matching function for call to \u2018Test::iterate(main(int, char**)::&lt;anonymous struct&gt;&amp;)\u2019\n</code></pre>\n<p>Why doesn't this work?\n(Also, for reasons beyond my control, I can't use C++11.)</p>\n<p>I've also tried naming the struct e.g. <code>myvis</code> and calling <code>test.iterate&lt;myvis&gt;(visitor)</code>, but that didn't work either.</p>\n<pre><code>#include &lt;deque&gt;\n#include &lt;iostream&gt;\n\nclass Test {\npublic:\n    std::deque&lt;int&gt; d;\n\n    template &lt;typename C&gt;\n    void iterate(C&amp; c) {\n        for(std::deque&lt;int&gt;::iterator itr = d.begin(); itr != d.end(); itr++) {\n            c(*itr);\n        }\n    }\n};\n\nint main(int argc, char** argv) {\n    Test test;\n    test.d.push_back(1);\n    test.d.push_back(2);\n    struct {\n        void operator()(int x) {\n            std::cout &lt;&lt; x &lt;&lt; std::endl;\n        }\n    } visitor;\n    test.iterate(visitor);\n}\n</code></pre>\n", "Tags": "<c++><templates>", "OwnerUserId": "25498", "AnswerCount": "3"}});