post_cb({"bq_ids": {"n4140": {"so_42034848_42035156_0": {"section_id": 4706, "quality": 0.7777777777777778, "length": 7}, "so_42034848_42035156_1": {"section_id": 4706, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_42034848_42035156_0": {"section_id": 4546, "quality": 0.5555555555555556, "length": 5}, "so_42034848_42035156_1": {"section_id": 4515, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_42034848_42035156_0": {"section_id": 6103, "quality": 0.8888888888888888, "length": 8}, "so_42034848_42035156_1": {"section_id": 6103, "quality": 0.8571428571428571, "length": 6}}}, "42035156": {"ParentId": "42034848", "CommentCount": "2", "Body": "<p>The definition of <code>is_nothrow_copy_assignable</code> is in [meta.unary.prop]:</p>\n<blockquote>\n<p id=\"so_42034848_42035156_0\">For a referenceable type <code>T</code>, the same result as <code>is_nothrow_assignable_v&lt;T&amp;, const T&amp;&gt;</code>, otherwise <code>false</code>.</p>\n</blockquote>\n<p>Ok, <code>A</code> is referenceable (meaning <code>A&amp;</code> is valid). So we go into <code>is_nothrow_assignable</code>:</p>\n<blockquote>\n<p id=\"so_42034848_42035156_1\"><code>is_assignable_v&lt;T, U&gt;</code> is <code>true</code> and the assignment is known not to throw any exceptions (5.3.7).</p>\n</blockquote>\n<p><code>is_assignable_v&lt;A, A const&amp;&gt;</code> is definitely <code>true</code>, so we satisfy the first part. What does it mean to be known not to throw any exceptions? According to [expr.unary.noexcept]:</p>\n<blockquote>\n<p id=\"so_42034848_42035156_2\">The <code>noexcept</code> operator determines whether the evaluation of its operand, which is an unevaluated operand (Clause 5), can throw an exception (15.1). [...] The result of the <code>noexcept</code> operator is <code>true</code> if the set of potential exceptions of the expression (15.4) is empty, and false otherwise. </p>\n</blockquote>\n<p>And in [except.spec]:</p>\n<blockquote>\n<p id=\"so_42034848_42035156_3\">The exception-specification <code>noexcept</code> or <code>noexcept(constant-expression)</code>, where the constant-expression yields <code>true</code>, denotes an exception specification that is the empty set. The exception-specification <code>noexcept(constant-expression)</code>, where the <em>constant-expression</em> yields <code>false</code>, or the absence of an <em>exception-specification</em> in a function declarator other than that for a destructor (12.4) or a deallocation function (3.7.4.2) denotes an\n  exception specification that is the set of all types.</p>\n</blockquote>\n<p>And:</p>\n<blockquote>\n<p id=\"so_42034848_42035156_4\">The set of potential exceptions of an expression e is empty if e is a core constant expression (5.20). Otherwise,\n  it is the union of the sets of potential exceptions of the immediate sub-expressions of e, including default\n  argument expressions used in a function call, combined with a set S defined by the form of e, as follows: [...]<br>\n  \u2014 If e implicitly invokes one or more functions (such as an overloaded operator, an allocation function in a new-expression, or a destructor if e is a full-expression (1.9)), S is the union of:<br>\n  \u00a0\u00a0\u00a0\u2014 the sets of types in the exception specifications of all such functions, and<br>\n  \u00a0\u00a0\u00a0\u2014 if e is a new-expression [...]</br></br></br></p>\n</blockquote>\n<p>Now, the assignment of an <code>A</code> from an <code>A const&amp;</code> involves two steps:</p>\n<ol>\n<li>invoking the copy constructor of <code>A</code></li>\n<li>invoking the copy assignment operator of <code>A</code></li>\n</ol>\n<p>The exception specification is the union of all the exception specifications of both of these functions, which is the set of all types - because the copy constructor does not have an <em>exception-specification</em> at all. </p>\n<p>Therefore, <code>is_nothrow_copy_assignable_v&lt;A&gt;</code> should be <code>false</code>. gcc is correct.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "42035156", "Score": "7", "CreationDate": "2017-02-04T00:31:45.497", "LastActivityDate": "2017-02-04T00:31:45.497"}, "42034848": {"CommentCount": "3", "ViewCount": "121", "PostTypeId": "1", "LastEditorUserId": "7210792", "CreationDate": "2017-02-03T23:53:13.017", "LastActivityDate": "2017-02-05T22:21:36.527", "Title": "What is the value of is_nothrow_copy_assignable for a class with a throwing copy constructor and a noexcept by-value copy assignment?", "AcceptedAnswerId": "42035156", "LastEditDate": "2017-02-05T22:21:36.527", "Id": "42034848", "Score": "5", "Body": "<p>What is, in terms of the C++ standard, the expected (if any) output of the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;type_traits&gt;\n\nclass A {\npublic:\n    A() = default;\n    ~A() = default;\n    A(A const&amp; other) {}\n    A(A&amp;&amp; other) noexcept {}\n    A&amp; operator=(A other) noexcept { return *this; }\n};\n\nint main() {\n    std::cout &lt;&lt; std::boolalpha\n        &lt;&lt; std::is_nothrow_copy_assignable&lt;A&gt;::value &lt;&lt; \"\\n\"\n        &lt;&lt; std::is_nothrow_move_assignable&lt;A&gt;::value &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>In other words, does the evaluation of the type traits' values look at the declaration of the assignment operator only, which is noexcept, and does it thus yield</p>\n<pre><code>true\ntrue\n</code></pre>\n<p>Or does it consider the calling context (<code>a</code>, <code>b</code> are instances of <code>A</code>)</p>\n<pre><code>a = b;            // may throw, implicitly calls copy c'tor\na = std::move(b); // noexcept, implicitly calls move c'tor\n</code></pre>\n<p>and does it yield</p>\n<pre><code>false\ntrue\n</code></pre>\n<p><em>Practical attempts</em></p>\n<p>Running the code with Visual Studio 2015, Update 3 gives</p>\n<pre><code>true\ntrue\n</code></pre>\n<p>whereas gcc 6.1 gives</p>\n<pre><code>false\ntrue\n</code></pre>\n<p>Who is right?</p>\n<p><em>Background</em></p>\n<p>A situation like this occurs when we have a resource managing class with a throwing copy constructor (since resource allocation may fail), a noexcept move constructor, a throwing copy assignment and a noexcept move assignment.</p>\n<p>Supposing that both copy and move assignment can be efficiently implemented in terms of the swap idom:</p>\n<pre><code>A&amp; operator=(A const&amp; other) {\n    A(other).swap(*this); // calls the copy c'tor, may throw\n    return *this;\n}\n\nA&amp; operator=(A&amp;&amp; other) noexcept {\n    A(std::move(other)).swap(*this); // calls noexcept move c'tor\n    return *this;\n}\n</code></pre>\n<p>Then we might consider condensing both into the single by-value copy assignment</p>\n<pre><code>A&amp; operator=(A other) noexcept {\n    other.swap(*this);\n    return *this;\n}\n</code></pre>\n<p>However, we can only safely do this if <code>std::is_nothrow_copy_assignable&lt;A&gt;</code> and <code>std::is_nothrow_move_assignable&lt;A&gt;</code> provide the correct values (false and true, respectively). Otherwise, code relying on these type traits would behave badly and our single by-value assignment would <em>not</em> be a correct replacement for two separate assignment operators.</p>\n", "Tags": "<c++><c++11><c++14><language-lawyer>", "OwnerUserId": "7210792", "AnswerCount": "1"}});