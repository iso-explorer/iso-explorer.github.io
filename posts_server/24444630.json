post_cb({"bq_ids": {"n4140": {"so_24444630_24444630_0": {"length": 42, "quality": 0.9130434782608695, "section_id": 6325}}, "n3337": {"so_24444630_24444630_0": {"length": 42, "quality": 0.9130434782608695, "section_id": 6082}}, "n4659": {"so_24444630_24444630_0": {"length": 41, "quality": 0.8913043478260869, "section_id": 7835}}}, "24445141": {"Id": "24445141", "PostTypeId": "2", "Body": "<p>Your assumption about the C++11/14 <code>std::swap</code> implementation is wrong. In your version <code>temp</code> is being copy constructed from one of the arguments; however, there's no need for this. <code>temp</code> can be move constructed, and then the rest remains the same as your example</p>\n<pre><code>template&lt;typename T&gt;\nvoid swap(T&amp; lhs, T&amp; rhs) // omitting noexcept specification\n{\n  T temp = std::move(lhs);\n  lhs = std::move(rhs);\n  rhs = std::move(temp); \n}\n</code></pre>\n<p>The second statement is still a self-move-assignment, but any resource that was owned by <code>lhs</code> (and <code>rhs</code>) has been moved into <code>temp</code>. So both the objects should now be in a <em>\"valid but unspecified\"</em> state, and the assignment shouldn't cause any trouble at this point.</p>\n<p><strong>Edit:</strong> Just found <a href=\"https://stackoverflow.com/a/9322542/241631\">this answer</a> from Howard Hinnant where he discusses this very situation (about 2/3rds of the way down). His assessment is the same as above.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-27T06:37:56.713", "Score": "3", "CreationDate": "2014-06-27T06:16:01.820", "ParentId": "24444630", "CommentCount": "12", "OwnerUserId": "241631", "LastEditDate": "2017-05-23T11:54:25.417"}, "24444630": {"ViewCount": "655", "Body": "<p>This question is based on discussion below a <a href=\"http://scottmeyers.blogspot.com/2014/06/the-drawbacks-of-implementing-move.html\">recent blog post by Scott Meyers</a>.</p>\n<p>It seems \"obvious\" that <code>std::swap(x, x)</code> should leave <code>x</code> unchanged in both C++98 and C++11, but I can't find any guarantee to that effect in either standard. C++98 defines <code>std::swap</code> in terms of copy construction and copy assignment, while C++11 defines it in terms of move construction and move assignment, and this seems relevant, because in C++11 (and C++14),  17.6.4.9 says that move-assignment need not be self-assignment-safe:</p>\n<blockquote>\n<p id=\"so_24444630_24444630_0\">If a function argument binds to an rvalue reference parameter, the implementation may assume that this parameter is a unique reference to this argument. ... [ Note: If a program casts an lvalue to an\n  xvalue while passing that lvalue to a library function (e.g. by calling the function with the argument\n  move(x)), the program is effectively asking that function to treat that lvalue as a temporary. The\n  implementation is free to optimize away aliasing checks which might be needed if the argument was\n  an lvalue. \u2014end note ]</p>\n</blockquote>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204\">defect report</a> that gave rise to this wording makes the consequence clear:</p>\n<blockquote>\n<p id=\"so_24444630_24444630_1\">this clarifies that move assignment operators need not perform the traditional if (this != &amp;rhs) test commonly found (and needed) in copy assignment operators.</p>\n</blockquote>\n<p>But in C++11 and C++14, <code>std::swap</code> is expected to use this implementation,</p>\n<pre><code>template&lt;typename T&gt;\nvoid swap(T&amp; lhs, T&amp; rhs)\n{\n  auto temp(std::move(lhs));\n  lhs = std::move(rhs);\n  rhs = std::move(temp); \n}\n</code></pre>\n<p>and the first assignment is performing an assignment to self where the argument is an rvalue. If the move assignment operator for <code>T</code> follows the policy of the standard library and doesn't worry about assignment to self, this would seem to court undefined behavior, and that would mean that <code>std::swap(x, x)</code> would have UB, as well.</p>\n<p>That's worrisome even in isolation, but if we assume that <code>std::swap(x, x)</code> was supposed to be safe in C++98, it also means that C++11/14's <code>std::swap</code> could silently break C++98 code. </p>\n<p>So is <code>std::swap(x, x)</code> guaranteed to leave <code>x</code> unchanged? In C++98? In C++11? If it is, how does this interact with 17.6.4.9's permission for move-assignment to not be self-assignment-safe?</p>\n", "Title": "Is std::swap(x, x) guaranteed to leave x unchanged?", "CreationDate": "2014-06-27T05:37:10.923", "LastActivityDate": "2014-06-27T06:37:56.713", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-06-27T06:35:30.360", "LastEditorUserId": "1426649", "Id": "24444630", "Score": "14", "OwnerUserId": "1426649", "Tags": "<c++><c++11><swap>", "AnswerCount": "1"}});