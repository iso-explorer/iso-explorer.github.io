post_cb({"44885321": {"ParentId": "44885143", "CommentCount": "0", "Body": "<p><code>{}</code> prevent convertion type e.g <code>double</code> to <code>int</code>\nbut </p>\n<p><code>()</code> can do this, only can display warning about conversion</p>\n<p>you can to write like this</p>\n<p><code>int z(7.9) // == 7</code></p>\n<p>you can use brackets when you are sure, that in class don't exist constructor with <code>std::initializer_list</code>, because he would be execute or you can <code>delete</code> that constructor.</p>\n", "OwnerUserId": "6615552", "PostTypeId": "2", "Id": "44885321", "Score": "0", "CreationDate": "2017-07-03T12:14:34.190", "LastActivityDate": "2017-07-03T12:14:34.190"}, "44885143": {"CommentCount": "3", "ViewCount": "57", "PostTypeId": "1", "LastEditorUserId": "336527", "CreationDate": "2017-07-03T12:04:47.490", "LastActivityDate": "2017-07-03T12:14:38.257", "Title": "Type safety during assignment vs initialization", "AcceptedAnswerId": "44885274", "LastEditDate": "2017-07-03T12:09:30.673", "Id": "44885143", "Score": "0", "Body": "<p>One of the stated advantages of initializer list syntax is that it improves type safety by prohibiting <a href=\"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#note-182\" rel=\"nofollow noreferrer\">narrowing conversions</a>:</p>\n<pre><code>int x {7.9};   // error: narrowing\nint y = 7.9;   // OK: y becomes 7. Hope for a compiler warning\n</code></pre>\n<p>However, AFAIK there is no way to enforce the same check in a subsequent assignment:</p>\n<pre><code>int z {7};\nz = 7.9;  // allows narrowing, and no other syntax available\n</code></pre>\n<p>Why is type safety during initialization given greater attention by the language design than type safety during assignment? Is narrowing in assignments less likely to cause bugs and/or harder to detect?</p>\n", "Tags": "<c++><c++11><type-safety>", "OwnerUserId": "336527", "AnswerCount": "3"}, "44885326": {"ParentId": "44885143", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_44885143_44885326_0\">Why is type safety during initialization given greater attention by\n  the language design than type safety during assignment?</p>\n</blockquote>\n<p>No that's not the reason here, it's the list initialization that's giving you the error, for example, this would error too:</p>\n<pre><code>int x = {7.8};\n</code></pre>\n<p>And that is because narrowing is not allowed in list initialization, as per [dcl.init]:</p>\n<blockquote>\n<p id=\"so_44885143_44885326_1\">If the initializer-clause is an expression and a narrowing conversion\n  is required to convert the expression, the program is ill-formed.</p>\n</blockquote>\n", "OwnerUserId": "1870760", "PostTypeId": "2", "Id": "44885326", "Score": "2", "CreationDate": "2017-07-03T12:14:38.257", "LastActivityDate": "2017-07-03T12:14:38.257"}, "44885274": {"ParentId": "44885143", "CommentCount": "3", "Body": "<p>If <code>x</code> is an <code>int</code> variable, then </p>\n<pre><code>x = 7.9;\n</code></pre>\n<p>must continue working in C++11 and later for the reason of backward compatibility. This is the case even if <code>x</code> was brace-initialized. A brace-initialized <code>int</code> variable has the same type as a non-brace-initialized <code>int</code> variable. If you passed <code>x</code> by reference to a function,</p>\n<pre><code>void f(int&amp; r);\nf(x);\n</code></pre>\n<p>then in the body of <code>f</code> there would be no way to \"tell\" whether the object had been brace-initialized, so the language cannot apply different rules to it.</p>\n<p>You can prevent narrowing conversions yourself by doing this:</p>\n<pre><code>x = {7.9};  // error\n</code></pre>\n<p>You could also try to take advantage of the type system by creating an <code>int</code> \"wrapper\" type that disallowed narrowing assignments:</p>\n<pre><code>struct safe_int {\n    template &lt;class T&gt; safe_int(T&amp;&amp; x) : value{std::forward&lt;T&gt;(x)} {}\n    template &lt;class T&gt; safe_int&amp; operator=(T&amp;&amp; x) {\n        value = {std::forward&lt;T&gt;(x)}; return *this;\n    }\n    operator int() const { return value; }\n    int value;\n};\n</code></pre>\n<p>Unfortunately this class cannot be made to behave like an actual <code>int</code> object under all circumstances.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "44885274", "Score": "3", "CreationDate": "2017-07-03T12:11:48.673", "LastActivityDate": "2017-07-03T12:11:48.673"}, "bq_ids": {"n4140": {"so_44885143_44885326_1": {"section_id": 3299, "quality": 1.0, "length": 8}}, "n3337": {"so_44885143_44885326_1": {"section_id": 3169, "quality": 1.0, "length": 8}}, "n4659": {"so_44885143_44885326_1": {"section_id": 4065, "quality": 1.0, "length": 8}}}});