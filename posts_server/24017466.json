post_cb({"24017466": {"ViewCount": "992", "Body": "<p>I'd like to ask whether the following code sample should compile:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;typeinfo&gt;\n\nusing namespace std;\n\ntemplate &lt;template &lt;class...&gt; class C&gt;\nstruct convert_container\n{\n    using type = C&lt;double&gt;; \n\n    // Visual Studio requires this to be:\n    // using type = C&lt;double, std::allocator&lt;doble&gt;&gt;\n};\n\nint main()\n{\n    std::cout &lt;&lt; typeid(convert_container&lt;std::vector&gt;::type).name();\n}\n</code></pre>\n<p>The code compiles fine with GCC 4.8.1 and Clang 3.4 but not with Visual Studio 2013. The error I get:</p>\n<pre><code>error C2976: 'std::vector' : too few template arguments\n    c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\vector(650) : see declaration of 'std::vector'\n    c:\\users\\micha\u0142\\documents\\visual studio 2013\\projects\\transform\\transform.cpp(14) : see reference to class template instantiation 'convert_container&lt;std::vector&gt;' being compiled\n</code></pre>\n<p>What does the standard say about this? Am I required to explicitly state all the parameters (including defaulted ones) when using the template template parameter <code>C</code> or is this just a bug in VC++?</p>\n<p>Context: The issue araised from Constructor's answer to my previous question: <a href=\"https://stackoverflow.com/a/23874768/2617356\">https://stackoverflow.com/a/23874768/2617356</a></p>\n<p>When searching the archives I've found this question: <a href=\"https://stackoverflow.com/questions/5301706/default-values-in-templates-with-template-arguments-c\">Default values in templates with template arguments ( C++ )</a>   It's basically about the same problem, the question author states that default parameters for template template parameter \"had to be\" explicitly stated. However, the asker accepted solution that's not quite applicable in my case. The question was not about what is the standard-conforming behaviour, so I believe this is not a duplicate.</p>\n", "AcceptedAnswerId": "24026094", "Title": "Is it required to explicitly list default parameters when using template template parameter?", "CreationDate": "2014-06-03T14:12:52.380", "Id": "24017466", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:15:56.273", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-03T23:00:27.793", "Score": "21", "OwnerUserId": "2617356", "Tags": "<c++><templates>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24017466_24026094_3": {"length": 20, "quality": 0.9523809523809523, "section_id": 3255}, "so_24017466_24026094_5": {"length": 19, "quality": 1.0, "section_id": 67}, "so_24017466_24022186_0": {"length": 19, "quality": 1.0, "section_id": 67}, "so_24017466_24026094_1": {"length": 22, "quality": 0.9166666666666666, "section_id": 63}}, "n3337": {"so_24017466_24026094_3": {"length": 20, "quality": 0.9523809523809523, "section_id": 3127}, "so_24017466_24026094_5": {"length": 19, "quality": 1.0, "section_id": 62}, "so_24017466_24022186_0": {"length": 19, "quality": 1.0, "section_id": 62}, "so_24017466_24026094_1": {"length": 22, "quality": 0.9166666666666666, "section_id": 58}}, "n4659": {"so_24017466_24026094_3": {"length": 20, "quality": 0.9523809523809523, "section_id": 4013}, "so_24017466_24026094_5": {"length": 19, "quality": 1.0, "section_id": 69}, "so_24017466_24022186_0": {"length": 19, "quality": 1.0, "section_id": 69}, "so_24017466_24026094_1": {"length": 16, "quality": 0.6666666666666666, "section_id": 65}}}, "24022186": {"Id": "24022186", "PostTypeId": "2", "Body": "<p>A (seemingly related) quote from the standard <code>14.1 Template parameters</code></p>\n<blockquote>\n<p id=\"so_24017466_24022186_0\">14 . A template-parameter of a template template-parameter is permitted to have a default template-argument. When such default arguments are specified, <strong>they apply to the template template-parameter in the scope of the template template-parameter</strong>. </p>\n</blockquote>\n<p>[ Example:</p>\n<pre><code>template &lt;class T = float&gt; struct B {};\n\ntemplate &lt;template &lt;class TT = float&gt; class T&gt; struct A {\n\ninline void f();\n\ninline void g();\n};\n\ntemplate &lt;template &lt;class TT&gt; class T&gt; void A&lt;T&gt;::f() { // (*)\nT&lt;&gt; t; // error - TT has no default template argument\n}\n\ntemplate &lt;template &lt;class TT = char&gt; class T&gt; void A&lt;T&gt;::g() {\nT&lt;&gt; t; // OK - T&lt;char&gt;\n}\n</code></pre>\n<p>\u2014 end example ]</p>\n<p>This is the only verse posing limitations to the <strong>use</strong> of default template parameters of template template parameters (verse 9,11,12 pose limitations on the definition/specification)</p>\n<p>As stressed in the comments, OP's case does not involve a default parameter in <code>convert_container</code> (so the above does not apply explicitly). IMHO there are two ways of interpreting the situation : </p>\n<ol>\n<li><p><code>using type = C&lt;double&gt;</code> is a type alias for a class template; that class \"loses\" the right to use default template parameters, since it's passed as a template template parameter and all default arguments (of that TT parameter) lie outside the scope of the \"typedefing\". Then VS is correct. </p></li>\n<li><p>By <strong>tracking the instantiation process</strong> : Say a correct compiler instantiates the struct as so <sup>(it's just a type substitution - no actual representation of the actual instantiation process is implied)</sup></p>\n<pre><code>struct convert_container\n{\n    using type = vector&lt;double&gt;; \n};\n</code></pre></li>\n</ol>\n<p>then OP's case seems fairly legit (and gcc/clang are correct)</p>\n<hr>\n<h2>FWIW</h2>\n<p><strong>This compiles</strong> in VS2013</p>\n<pre><code>template &lt;template &lt;class...&gt; class C&gt;\nusing tt = C&lt;double&gt;;\n\nint main()\n{\n    std::cout &lt;&lt; typeid(tt&lt;std::vector&gt;).name();\n}\n</code></pre>\n<p>So the arguments of default template parameters being non legal to pass to template template parameters seems more and more shaky.</p>\n</hr>", "LastEditorUserId": "2567683", "LastActivityDate": "2014-06-03T20:52:15.637", "Score": "1", "CreationDate": "2014-06-03T18:17:30.900", "ParentId": "24017466", "CommentCount": "7", "OwnerUserId": "2567683", "LastEditDate": "2014-06-03T20:52:15.637"}, "24026094": {"Id": "24026094", "PostTypeId": "2", "Body": "<p>Consider the similar</p>\n<pre><code>template &lt;typename = void, int = 0&gt; struct A { };\ntemplate &lt;template &lt;typename ...&gt; class T&gt; struct B : T&lt;&gt; { };\ntemplate class B&lt;A&gt;;\n</code></pre>\n<p>This is clearly covered by the standard (14.3.3p3 if you're interested, I won't quote it, as GCC and clang do both implement the rule already), where the use of <code>A</code> as a template argument for <code>B</code> is disallowed because of the non-type template parameter. That rule makes no sense if the instantiation of a template template parameter could make use of the template template argument's default template arguments, so the behaviour of MSVC and Intel is more consistent than that of GCC and clang.</p>\n<p>Of course, the reasoning \"if this were valid, the standard would have inconsistencies\" doesn't actually mean it isn't valid, only that it shouldn't be valid. To actually check what the standard says:</p>\n<blockquote>\n<p id=\"so_24017466_24026094_0\"><strong>14.1 Template parameters [temp.param]</strong></p>\n<p id=\"so_24017466_24026094_1\">10 The set of default <em>template-arguments</em> available for use with a template declaration or definition is obtained by merging the default arguments from the definition (if in scope) and all declarations in scope in the same way default function arguments are (8.3.6).</p>\n<p id=\"so_24017466_24026094_2\"><strong>8.3.6 Default arguments [dcl.fct.default]</strong></p>\n<p id=\"so_24017466_24026094_3\">4 Declarations in different scopes have completely distinct sets of default arguments. That is, declarations in inner scopes do not acquire default arguments from declarations in outer scopes, and vice versa.</p>\n</blockquote>\n<p>Although not specifically intended to address this use of default template arguments, I think it does manage to do so. Nikos Athanasiou has already included the part of the standard that says any default template arguments of <code>C</code> do get used:</p>\n<blockquote>\n<p id=\"so_24017466_24026094_4\"><strong>14.1 Template parameters [temp.param]</strong></p>\n<p id=\"so_24017466_24026094_5\">14 A <em>template-parameter</em> of a template <em>template-parameter</em> is permitted to have a default <em>template-argument</em>. When such default arguments are specified, they apply to the template <em>template-parameter</em> in the scope of the template <em>template-parameter</em>.</p>\n</blockquote>\n<p>Since <code>C</code>'s default template arguments are used, <code>std::vector</code>'s aren't, and MSVC and Intel seem to be correct here.</p>\n<p>And to come up with an example that clearly shows that GCC and clang cannot be considered to conform here:</p>\n<pre><code>template &lt;typename = char, typename = short&gt;\nstruct A { };\n\ntemplate &lt;template &lt;typename = void, typename ...&gt; class T&gt;\nstruct B {\n  using type = T&lt;&gt;;\n};\n</code></pre>\n<p>Both GCC and clang treat <code>B&lt;A&gt;::type</code> as <code>A&lt;void, short&gt;</code>, taking one default template argument from <code>T</code>, and another from <code>A</code>, even though the standard disallows merging of default arguments (and hence default template arguments) in declarations in different scopes.</p>\n<hr>\n<p>A workaround for you, to avoid the need to type out the allocator argument, could be to use a template alias:</p>\n<pre><code>template &lt;template &lt;class...&gt; class C&gt;\nstruct convert_container\n{\n  using type = C&lt;double&gt;; \n};\n\ntemplate &lt;typename T&gt;\nusing vector_default_alloc = std::vector&lt;T&gt;;\n\nint main()\n{\n  std::cout &lt;&lt; typeid(convert_container&lt;vector_default_alloc&gt;::type).name();\n}\n</code></pre>\n<p>I cannot test on MSVC right now, but Intel accepts it, and I see no reason why this variant would be invalid.</p>\n</hr>", "LastEditorUserId": "743382", "LastActivityDate": "2014-06-03T23:00:27.793", "Score": "2", "CreationDate": "2014-06-03T22:34:26.467", "ParentId": "24017466", "CommentCount": "3", "OwnerUserId": "743382", "LastEditDate": "2014-06-03T23:00:27.793"}});