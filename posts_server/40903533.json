post_cb({"40903668": {"ParentId": "40903533", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Dereferencing the return value of <code>std::vector::end()</code> is cause for undefined behavior. There is no point trying to make sense of what happens if you do.</p>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/container/vector/end\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/container/vector/end</a>:</p>\n<blockquote>\n<p id=\"so_40903533_40903668_0\">This element acts as a placeholder; attempting to access it results in undefined behavior. </p>\n</blockquote>\n<p>Re. the second part, the only thing I could find in the C++11 standard is:</p>\n<blockquote>\n<p id=\"so_40903533_40903668_1\"><strong>5.3.1 Unary operators</strong></p>\n<p id=\"so_40903533_40903668_2\">1 The unary <code>*</code> operator performs <em>indirection</em>: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points. If the type of the expression is \u201cpointer to <code>T</code>,\u201d the type of the result is \u201c<code>T</code>.\u201d [ <em>Note:</em> a pointer to an incomplete type (other than <em>cv</em> <code>void</code>) can be dereferenced. The lvalue thus obtained can be used in limited ways (to initialize a reference, for example); this lvalue must not be converted to a\n  prvalue, see 4.1. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>The result of dereferencing a NULL pointer seems to be unspecified.</p>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2016-12-01T06:22:48.510", "Id": "40903668", "Score": "5", "CreationDate": "2016-12-01T06:05:46.550", "LastActivityDate": "2016-12-01T06:22:48.510"}, "40903533": {"CommentCount": "1", "ViewCount": "57", "CreationDate": "2016-12-01T05:56:10.060", "LastActivityDate": "2016-12-01T06:22:48.510", "Title": "Accessing invalid pointer and taking its address", "PostTypeId": "1", "Id": "40903533", "Score": "1", "Body": "<p>Consider a code like this:</p>\n<pre><code>std::vector&lt;int&gt; vec { 1, 2, 3 };\nauto addr = &amp;*vec.end();\n</code></pre>\n<p>or simplified:</p>\n<pre><code>int* ptr = 0;\nauto addr = &amp;*ptr;\n</code></pre>\n<p>It's obvious that <code>auto val = *ptr;</code> would segfault. Hence <code>&amp;*ptr</code> is not accessing memory in the same way. Why is that the case? Is there a specific entry in standard for that?</p>\n", "Tags": "<c++><memory><stl>", "OwnerUserId": "1084199", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_40903533_40903668_2": {"section_id": 6064, "quality": 0.8431372549019608, "length": 43}}, "n3337": {"so_40903533_40903668_2": {"section_id": 5832, "quality": 0.8823529411764706, "length": 45}}, "n4659": {"so_40903533_40903668_2": {"section_id": 7560, "quality": 0.8431372549019608, "length": 43}}}, "40903698": {"ParentId": "40903533", "CommentCount": "2", "Body": "<p>In both cases you end up computing addresses rather than accessing memory, that is why your code happens to work. But both cases are undefined behavior according to c++ standard. The first example may actually trigger an assertion  failure in Debug version of standard library.</p>\n", "OwnerUserId": "459565", "PostTypeId": "2", "Id": "40903698", "Score": "3", "CreationDate": "2016-12-01T06:08:22.507", "LastActivityDate": "2016-12-01T06:08:22.507"}});