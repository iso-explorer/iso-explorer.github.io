post_cb({"bq_ids": {"n4140": {"so_40903533_40903668_2": {"length": 44, "quality": 0.8627450980392157, "section_id": 6064}}, "n3337": {"so_40903533_40903668_2": {"length": 46, "quality": 0.9019607843137255, "section_id": 5832}}, "n4659": {"so_40903533_40903668_2": {"length": 43, "quality": 0.8431372549019608, "section_id": 7560}}}, "40903698": {"Id": "40903698", "PostTypeId": "2", "Body": "<p>In both cases you end up computing addresses rather than accessing memory, that is why your code happens to work. But both cases are undefined behavior according to c++ standard. The first example may actually trigger an assertion  failure in Debug version of standard library.</p>\n", "LastActivityDate": "2016-12-01T06:08:22.507", "CommentCount": "2", "CreationDate": "2016-12-01T06:08:22.507", "ParentId": "40903533", "Score": "3", "OwnerUserId": "459565"}, "40903533": {"ViewCount": "57", "Body": "<p>Consider a code like this:</p>\n<pre><code>std::vector&lt;int&gt; vec { 1, 2, 3 };\nauto addr = &amp;*vec.end();\n</code></pre>\n<p>or simplified:</p>\n<pre><code>int* ptr = 0;\nauto addr = &amp;*ptr;\n</code></pre>\n<p>It's obvious that <code>auto val = *ptr;</code> would segfault. Hence <code>&amp;*ptr</code> is not accessing memory in the same way. Why is that the case? Is there a specific entry in standard for that?</p>\n", "Title": "Accessing invalid pointer and taking its address", "CreationDate": "2016-12-01T05:56:10.060", "LastActivityDate": "2016-12-01T06:22:48.510", "CommentCount": "1", "PostTypeId": "1", "Id": "40903533", "Score": "1", "OwnerUserId": "1084199", "Tags": "<c++><memory><stl>", "AnswerCount": "2"}, "40903668": {"Id": "40903668", "PostTypeId": "2", "Body": "<p>Dereferencing the return value of <code>std::vector::end()</code> is cause for undefined behavior. There is no point trying to make sense of what happens if you do.</p>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/container/vector/end\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/container/vector/end</a>:</p>\n<blockquote>\n<p id=\"so_40903533_40903668_0\">This element acts as a placeholder; attempting to access it results in undefined behavior. </p>\n</blockquote>\n<p>Re. the second part, the only thing I could find in the C++11 standard is:</p>\n<blockquote>\n<p id=\"so_40903533_40903668_1\"><strong>5.3.1 Unary operators</strong></p>\n<p id=\"so_40903533_40903668_2\">1 The unary <code>*</code> operator performs <em>indirection</em>: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points. If the type of the expression is \u201cpointer to <code>T</code>,\u201d the type of the result is \u201c<code>T</code>.\u201d [ <em>Note:</em> a pointer to an incomplete type (other than <em>cv</em> <code>void</code>) can be dereferenced. The lvalue thus obtained can be used in limited ways (to initialize a reference, for example); this lvalue must not be converted to a\n  prvalue, see 4.1. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>The result of dereferencing a NULL pointer seems to be unspecified.</p>\n", "LastEditorUserId": "434551", "LastActivityDate": "2016-12-01T06:22:48.510", "Score": "5", "CreationDate": "2016-12-01T06:05:46.550", "ParentId": "40903533", "CommentCount": "6", "OwnerUserId": "434551", "LastEditDate": "2016-12-01T06:22:48.510"}});