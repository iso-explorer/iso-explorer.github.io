post_cb({"31429561": {"ParentId": "31428980", "CommentCount": "4", "Body": "<p>Well sir, the answer i pretty straightforward. Instead of casting to const reference in return like this:</p>\n<pre><code>return static_cast&lt;const std::string&amp;&gt;(lhs) == static_cast&lt;const std::string&amp;&gt;(rhs);\n</code></pre>\n<p>Cast your type to <code>std::string</code>:</p>\n<pre><code>return static_cast&lt;std::string&gt;(lhs) == static_cast&lt;std::string&gt;(rhs);\n</code></pre>\n<p>And enjoy working code :)</p>\n", "OwnerUserId": "3414900", "PostTypeId": "2", "Id": "31429561", "Score": "1", "CreationDate": "2015-07-15T11:48:38.667", "LastActivityDate": "2015-07-15T11:48:38.667"}, "31430017": {"ParentId": "31428980", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>UPDATE</strong> My previous answer was exactly wrong. Apologies! tldr; clang is correct to accept the code, gcc is incorrect to reject it. </p>\n<hr>\n<p>First, from [expr.static.cast]:</p>\n<blockquote>\n<p id=\"so_31428980_31430017_0\">An expression e can be explicitly converted to a type T using a static_cast of the form <code>static_cast&lt;T&gt;(e)</code>\n  if the declaration <code>T t(e)</code>; is well-formed, for some invented temporary variable t (8.5).</p>\n</blockquote>\n<p>So effectively we're trying to direct-initialize an object of type <code>std::string const&amp;</code> explicitly from an object of type <code>SymbolGroup const&amp;</code>. There is a section specifically on initializing references by a conversion function: \"Initialization by conversion function for direct reference binding\" [over.match.ref]:</p>\n<blockquote>\n<p id=\"so_31428980_31430017_1\">Under the conditions specified in 8.5.3, a reference can be bound directly to a glvalue or class prvalue that is\n  the result of applying a conversion function to an initializer expression. Overload resolution is used to select\n  the conversion function to be invoked. Assuming that \u201c<em>cv1</em> T\u201d is the underlying type of the reference being\n  initialized, and \u201c<em>cv</em> S\u201d is the type of the initializer expression, with S a class type, the candidate functions\n  are selected as follows:</p>\n<p id=\"so_31428980_31430017_2\">\u2014 The conversion functions of S and its base classes are considered. Those non-explicit conversion\n  functions that [...] are candidate functions. For direct-initialization, those explicit\n  conversion functions that are not hidden within S and yield type \u201clvalue reference to <em>cv2</em> T2\u201d or \u201c<em>cv2</em>\n  T2\u201d or \u201crvalue reference to <em>cv2</em> T2\u201d, respectively, where T2 is the same type as T or can be converted\n  to type T with a qualification conversion (4.4), are also candidate functions.</p>\n</blockquote>\n<p>The first part doesn't apply since our conversion function is <code>explicit</code>, so I omitted it. The second part does. We have <em>cv1</em> T is <code>const std::string</code>, so our conversion function to <code>std::string</code> is a candidate function because <code>std::string</code> can be converted to <code>const std::string</code> with a qualification conversion. </p>\n<hr/>\n<p>gcc is wrong here, and I filed <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66893\" rel=\"nofollow noreferrer\">bug 66893</a>, confirmed by our very own C++ expert and all around good guy <a href=\"https://stackoverflow.com/users/981959/jonathan-wakely\">Jonathan Wakely</a> as well as the head Clang developer and C++ standard editor Richard Smith (after I thoroughly embarrassed myself filing a Clang bug). </p>\n</hr>", "OwnerUserId": "2069064", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:30:31.840", "Id": "31430017", "Score": "4", "CreationDate": "2015-07-15T12:08:50.763", "LastActivityDate": "2015-07-16T13:01:53.727"}, "bq_ids": {"n4140": {"so_31428980_31430017_1": {"section_id": 597, "quality": 0.9487179487179487, "length": 37}, "so_31428980_31430017_0": {"section_id": 6030, "quality": 1.0, "length": 15}, "so_31428980_31430017_2": {"section_id": 597, "quality": 0.8780487804878049, "length": 36}}, "n3337": {"so_31428980_31430017_1": {"section_id": 587, "quality": 0.9487179487179487, "length": 37}, "so_31428980_31430017_0": {"section_id": 5798, "quality": 1.0, "length": 15}, "so_31428980_31430017_2": {"section_id": 585, "quality": 0.6829268292682927, "length": 28}}, "n4659": {"so_31428980_31430017_1": {"section_id": 620, "quality": 0.9230769230769231, "length": 36}, "so_31428980_31430017_0": {"section_id": 2, "quality": 0.6666666666666666, "length": 10}, "so_31428980_31430017_2": {"section_id": 620, "quality": 0.8780487804878049, "length": 36}}}, "31428980": {"CommentCount": "4", "AcceptedAnswerId": "31430017", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-07-15T11:19:55.910", "LastActivityDate": "2015-07-16T13:01:53.727", "LastEditDate": "2015-07-15T12:15:22.637", "ViewCount": "429", "FavoriteCount": "1", "Title": "User-defined conversion function and casting to reference", "Id": "31428980", "Score": "6", "Body": "<p>I am encountering a compilation error for the following code:</p>\n<pre><code>class SymbolGroup\n{\n  std::string d_;\n\npublic:\n  SymbolGroup(std::string a):d_(a){}\n\n  // explicit operator const std::string&amp;() const { return d_;} // compiles\n  explicit operator std::string() const { return d_;} // Does not compile\n};\n\ninline\nbool operator==(const SymbolGroup&amp; lhs, const SymbolGroup&amp; rhs)\n{\n  return static_cast&lt;const std::string&amp;&gt;(lhs) ==\n    static_cast&lt;const std::string&amp;&gt;(rhs);\n}\n\nint main(){\n\n  SymbolGroup a(\"hello\");\n  SymbolGroup b(\"hello\");\n\n  if (a==b)\n    std::cout &lt;&lt; \"they are the same\\n\";\n\n  return 0;\n}\n</code></pre>\n<p>Without the 'const' and '&amp;' in the user-defined type conversion line, it does not compile in g++ (4.8) with --std=c++11 flag:</p>\n<blockquote>\n<p id=\"so_31428980_31428980_0\">error: invalid initialization of reference of type \u2018std::string&amp; {aka\n  std::basic_string&amp;}\u2019 from expression of type \u2018const string {aka\n  const std::basic_string}\u2019    explicit operator std::string&amp;()\n  const { return d_;}</p>\n</blockquote>\n<p>The code compiles on Clang both ways. Which compiler is correct? Should this code compile with <code>operator std::string()</code>?</p>\n", "Tags": "<c++><type-conversion>", "OwnerUserId": "2512873", "AnswerCount": "2"}});