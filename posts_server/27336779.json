post_cb({"27624369": {"ParentId": "27336779", "LastEditDate": "2017-05-23T12:10:17.723", "CommentCount": "0", "CreationDate": "2014-12-23T16:34:11.557", "Score": "12", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "27624369", "OwnerUserId": "560648", "Body": "<p>The constructor needs access to the deleter in just the same way the destructor does: exception safety requires that the constructor be able to roll-back initialisation of all the members in the case that your constructor's body throws:</p>\n<blockquote>\n<p id=\"so_27336779_27624369_0\"><code>[C++14: 12.6.2/10]:</code> In a non-delegating constructor, the destructor for each potentially constructed subobject of class type is potentially invoked (12.4). <em>[ Note:</em> This provision ensures that destructors can be called for fully-constructed sub-objects in case an exception is thrown (15.2). <em>\u2014end note ]</em></p>\n</blockquote>\n<p>Related:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/a/26995534/560648\">https://stackoverflow.com/a/26995534/560648</a></li>\n</ul>\n", "LastActivityDate": "2014-12-23T16:34:11.557"}, "27336992": {"ParentId": "27336779", "CommentCount": "4", "CreationDate": "2014-12-06T21:52:12.913", "OwnerUserId": "1893837", "PostTypeId": "2", "Id": "27336992", "Score": "-1", "Body": "<p>It is no possible for 'A' to not have a constructor.</p>\n<p>If you comment the constructor you wrote, the compiler will make a default constructor for you and it won't necessarily be in the same place you defined the one you made. Causing said problem.</p>\n", "LastActivityDate": "2014-12-06T21:52:12.913"}, "bq_ids": {"n4140": {"so_27336779_27624369_0": {"section_id": 437, "quality": 0.7241379310344828, "length": 21}}, "n4659": {"so_27336779_27624369_0": {"section_id": 457, "quality": 0.7241379310344828, "length": 21}}}, "27336779": {"CommentCount": "13", "ViewCount": "3891", "PostTypeId": "1", "LastEditorUserId": "4332865", "CreationDate": "2014-12-06T21:31:34.220", "LastActivityDate": "2014-12-23T16:34:11.557", "Title": "Unique_ptr and forward declaration", "FavoriteCount": "2", "LastEditDate": "2014-12-06T22:21:18.363", "Id": "27336779", "Score": "9", "Body": "<p>Say I have two classes:</p>\n<p>\"Foo.h\"</p>\n<pre><code>#pragma once    \nclass Foo\n{\npublic:\n    Foo()\n    {\n\n    };\n\n    ~Foo()\n    {\n\n    };\n};\n</code></pre>\n<p>\"A.h\"</p>\n<pre><code>#pragma once\n#include &lt;memory&gt;\n\nclass Foo;\n\nclass A\n{\npublic:\n    A(){};\n    ~A(){};\n\n    std::unique_ptr&lt;Foo&gt; foo;\n};\n</code></pre>\n<p>A holds a <code>unique_ptr</code> of <code>Foo</code>. I didn't want to include <code>Foo</code> in \"A.h\", so I forward declared it. By just forward declaring the class <code>Foo</code> in \"A.h\", I get a compile time error:   </p>\n<pre><code>error C2027: use of undefined type 'Foo'\nerror C2338: can't delete an incomplete type  \n</code></pre>\n<p>So I was following <a href=\"https://binglongx.wordpress.com/2012/07/27/implementation-hiding-with-c11-unique_ptr-and-shared_ptr/\">this</a> article on how to avoid this error and moved A's destructor in it's own .cpp file where I also include Foo:</p>\n<p>\"A.cpp\"</p>\n<pre><code>#include \"A.h\"\n\n#include \"Foo.h\"\n\nA::A()\n{\n\n}\n\nA::~A()\n{\n\n}\n</code></pre>\n<p>After implementing the destructor of A in \"A.cpp\", I'm able to compile the program, because the class Foo is known in \"A.cpp\". This seems logical, because unique_ptr needs the complete type to call it's destructor. But to my surprise, after commenting out the constructor of A (in \"A.h\" as well as \"A.cpp\"), I get the same error. How is this possible? Why does the compiler complain about beeing not able to call Foo's destructor when A has no constructor?</p>\n<p>EDIT:\nI uploaded the 4 files so you can test the program.\nI'm using MSVC++ of Visual Studio 2013.  </p>\n<p><a href=\"http://www.filedropper.com/test_61\">http://www.filedropper.com/test_61</a></p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "4332865", "AnswerCount": "2"}});