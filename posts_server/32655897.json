post_cb({"32655927": {"Id": "32655927", "PostTypeId": "2", "Body": "<p>No.\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b</p>\n", "LastActivityDate": "2015-09-18T15:36:32.590", "CommentCount": "11", "CreationDate": "2015-09-18T15:36:32.590", "ParentId": "32655897", "Score": "21", "OwnerUserId": "560648"}, "32655897": {"ViewCount": "230", "Body": "<p>I would like to create a namespace and prevent it from adding any more class or other things into.Is there any way I can accomplish this.</p>\n", "AcceptedAnswerId": "32655927", "Title": "Is there any way I can prevent a namespace from adding further classes in C++?", "CreationDate": "2015-09-18T15:35:06.280", "Id": "32655897", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-09-22T10:48:43.443", "LastEditorUserId": "819272", "LastActivityDate": "2015-09-22T10:48:43.443", "Score": "1", "OwnerUserId": "5096772", "Tags": "<c++><namespaces>", "AnswerCount": "4"}, "32659227": {"Id": "32659227", "PostTypeId": "2", "Body": "<p>The answer by @LightnessRacesinOrbit is explained by the following quote from the Standard</p>\n<blockquote>\n<p id=\"so_32655897_32659227_0\"><strong>7.3 Namespaces [basic.namespace]</strong> </p>\n<p id=\"so_32655897_32659227_1\">1 A namespace is an optionally-named declarative region. The name of a namespace can be used to access\n  entities declared in that namespace; that is, the members of the\n  namespace. Unlike other declarative regions, the definition of a\n  namespace can be split over several parts of one or more translation\n  units.</p>\n</blockquote>\n<p>Because the number of translation units is an open set, namespace membership is open to addition. </p>\n<p>However, as suggested by @Galik, you can imperfectly emulate a closed namespace by writing a struct or class with only static member functions</p>\n<pre><code>struct closed_namespace {\n\nstatic void fun() { /* bla */ }\n\n};\n</code></pre>\n<p>The translation of namespace to struct is probably not 100% drop-in. E.g. ordinary name lookup might act the same, but you always need to qualify functions so ADL goes out of the window. </p>\n<p>But calling code is pretty much the same (i.e. using the <code>::</code> accessor)</p>\n<pre><code>closed_namespace::fun();\n</code></pre>\n<p>and you can also use a typedef to shorten long names with a C++11 <code>using</code>-syntax that resembles left-to-right namespace alias</p>\n<pre><code>using cn = closed_namespace;\n</code></pre>\n<p>On the other hand, using directives and declarations don't carry over.</p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2015-09-18T20:48:17.007", "Score": "9", "CreationDate": "2015-09-18T18:59:31.183", "ParentId": "32655897", "CommentCount": "3", "OwnerUserId": "819272", "LastEditDate": "2015-09-18T20:48:17.007"}, "bq_ids": {"n4140": {"so_32655897_32659227_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 5471}}, "n3337": {"so_32655897_32659227_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 5257}}, "n4659": {"so_32655897_32659227_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 6906}}}, "32657359": {"Id": "32657359", "PostTypeId": "2", "Body": "<p>There is no language support for that. That's why you can mess up with the <code>std</code> namespace by adding things you are not supposed to, like <code>type_traits</code> specializations.</p>\n<p>I don't really see much need for that because, if I really want to, I can however do that by simply editing the source files but it's not a really rewarding way to break a program.</p>\n<p>Consider that <code>namespace</code>s can be extended by multiple TUs, so how could you select which one the namespace should \"terminate\"? Could you do that, and at certain point it becomes problematic, you <code>goto</code> the previous paragraph.</p>\n", "LastEditorUserId": "2692339", "LastActivityDate": "2015-09-18T18:59:29.883", "Score": "4", "CreationDate": "2015-09-18T16:58:26.933", "ParentId": "32655897", "CommentCount": "0", "OwnerUserId": "2692339", "LastEditDate": "2015-09-18T18:59:29.883"}, "32658073": {"Id": "32658073", "PostTypeId": "2", "Body": "<p>I agree that this is a simple boolean answer and really requires NO further elaboration except all of us piling on 'me too' or 'no, you need to be more verbose'. Sometimes terse is good (and answers the question). However...</p>\n<p>If you THINK about it for a moment it would be a HUGE change to the entire tool chain to enforce this. The metadata simply isn't kept (if at all) in the ~right~ place for this and the encouraged/needed(? for IP protection likely, but open-source folks wouldn't care!) separation between headers (declarations) and source bodies (implementations) would make it extra messy for compiler vendors. I suspect that it wouldn't gain ANY traction AT ALL because unless (and even then NOT) you made every vendor/project register a namespace or use a UUID (yick) the potential for collisions would be WAY too great. </p>\n<pre><code>// &lt;header1&gt;\n// Yick! (IMO)\nnamespace frozen std_A1DD3D0F_DC56_41D4_9B87_F820B420A94D \n{\n    class foo { ... };\n}\n\n// &lt;header2&gt;\n// Now what? \nnamespace frozen std_A1DD3D0F_DC56_41D4_9B87_F820B420A94D \n{\n    class bar{ ... };\n}\n\n// Uh, Java like maybe?\nnamespace frozen com_google_fabulous_stuff_v1 \n{\n    // Yipes! This could get extra tricky\n    namespace thawed other_nested_junk \n    {\n        struct PainfulToUse\n        {\n        };\n    }\n}\n\n// Would this even make sense?\nnamespace frozen WizzyTool {\nnamespace thawed Module_Like_DLL_so_or_static_lib {\nnamespace frozen SeparateOptionalSubLibraryFromAnotherHeader {\nnamespace frozen ExtraSubSubLibraryNeededONLYForAdvancedUsers {\n}\n}\n}\n}\n</code></pre>\n<p><strong>[begin soap box mode]</strong>\nHaving used projects where folks have done major nesting of namespaces, this kind of stuff gets VERY old quickly.  Thank goodness for C++ 11's using (although typedefs get you nearly the same thing, without the template&lt;&gt; goodness).</p>\n<pre><code>// Promote JUST the class_name into the scope Likely a method,\n// 'translation unit', class body or function. \n//\ntemplate&lt;typename x1,typename x2&gt;\nusing mapish = Some::Really::Deeply::Nested::mapish&lt;x1,x2&gt;;\n\n// or in some cases this is nice:\ntemplate&lt;typename x1&gt;\nusing mapish_int = Some::Really::Deeply::Nested::mapish&lt;x1,int&gt;;\n\nmapish_int&lt;bool&gt;::iterator x = ...\n</code></pre>\n<p>or</p>\n<pre><code>// Way too much typing and (IMO) harder to read.\n// Counter argument is that the explicit scoping makes maintenance easier.\n// Wanna debate tabs v spaces too?\nSome::Really::Deeply::Nested::class_name&lt;bool,int&gt;::iterator x = ...\n</code></pre>\n<p>One particular project from an unnamed vendor using the second technique would have resulted in MANY functions where even a generous 120 column 'standard' would make member declarations painful.\n<strong>[end soap_box_mode]</strong></p>\n<p>So, just spit balling here. Even if it WAS something that was do-able. (It is technically, just a challenge.) Would you WANT to have to do this? (Those of you that started with Java or C# are probably so used to this style that NOT having it seems painful.)  I don't loath it, but it would be difficult to <strong>enforce</strong> this with all the historical legacy that C++ has. The idea of the header DEFINING the ABI (application binary interface) is well engrained into the C and C++ standard and has a massive tail beyond JUST the declaration.</p>\n<p>For the most part, namespaces are a 'lucky hack' (IMO, but still creative!) as they really 'just' change the name mangling during initial compile (and subsequent compile/link) and little else.</p>\n", "LastActivityDate": "2015-09-18T17:45:41.187", "CommentCount": "0", "CreationDate": "2015-09-18T17:45:41.187", "ParentId": "32655897", "Score": "1", "OwnerUserId": "1855568"}});