post_cb({"24793143": {"ParentId": "24793019", "PostTypeId": "2", "CommentCount": "4", "Body": "<pre><code>vector&lt;Foo&gt; v{std::move(foo)};\n</code></pre>\n<p>Here you're calling the vector constructor that takes an <code>std::initializer_list</code>. An initializer list only allows <code>const</code> access to its elements, so the <code>vector</code> is going to have to copy each element from the <code>initializer_list</code> to its own storage. That's what causes the call to the copy constructor.</p>\n<p>From <em>\u00a78.5.4/5 [dcl.init.list]</em></p>\n<blockquote>\n<p id=\"so_24793019_24793143_0\">An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an initializer list as if the implementation allocated a temporary array of <strong><code>N</code> elements of type <code>const E</code></strong>, where <code>N</code> is the number of elements in the initializer list.</p>\n</blockquote>\n<hr>\n<p>As for the extra move constructor call with <code>-fno-elide-constructors</code>, this was discussed in <a href=\"https://stackoverflow.com/a/24753189/241631\">another answer</a> a couple of days ago. It seems as though g++ takes a very literal approach to the example implementation of an <code>initializer_list</code> shown in the standard in same section I've quoted above.</p>\n<p>The same example, when <a href=\"http://coliru.stacked-crooked.com/a/3473d795c6da3fd3\" rel=\"nofollow\">compiled using clang</a>, doesn't produce the extra move constructor call.</p>\n</hr>", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2014-07-17T00:46:51.490", "Id": "24793143", "Score": "8", "CreationDate": "2014-07-17T00:41:23.907", "LastActivityDate": "2014-07-17T00:46:51.490"}, "24793059": {"ParentId": "24793019", "CommentCount": "2", "Body": "<p>The containers try <em>very</em> hard to make sure they remain usable should an exception occur.  As part of this, they'll only use <code>std::move</code> internally if your class' move constructor is exception safe.  If it is not, (or it can't tell), it will copy just to be safe.</p>\n<p>The correct move operations are </p>\n<pre><code>Foo(Foo&amp;&amp;) noexcept {cout &lt;&lt; \"move ctor\" &lt;&lt; endl;}\nFoo&amp; operator=(Foo&amp;&amp;) noexcept {cout &lt;&lt; \"move assn\" &lt;&lt; endl;}\n</code></pre>\n", "OwnerUserId": "845092", "PostTypeId": "2", "Id": "24793059", "Score": "3", "CreationDate": "2014-07-17T00:31:09.883", "LastActivityDate": "2014-07-17T00:31:09.883"}, "24793019": {"CommentCount": "0", "AcceptedAnswerId": "24793143", "PostTypeId": "1", "LastEditorUserId": "3093378", "CreationDate": "2014-07-17T00:26:27.857", "LastActivityDate": "2014-07-17T00:46:51.490", "LastEditDate": "2014-07-17T00:42:34.737", "ViewCount": "1005", "FavoriteCount": "1", "Title": "std::vector initialization move/copy constructor of the element", "Id": "24793019", "Score": "2", "Body": "<p>I have this piece of code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Foo{\npublic:\n    Foo() noexcept {cout &lt;&lt; \"ctor\" &lt;&lt; endl;}\n    Foo(const Foo&amp;) noexcept {cout &lt;&lt; \"copy ctor\" &lt;&lt; endl;}\n    Foo(Foo&amp;&amp;) noexcept {cout &lt;&lt; \"move ctor\" &lt;&lt; endl;}\n\n    Foo&amp; operator=(Foo&amp;&amp;) noexcept {cout &lt;&lt; \"move assn\" &lt;&lt; endl; return *this;}\n    Foo&amp; operator=(const Foo&amp;) noexcept {cout &lt;&lt; \"copy assn\" &lt;&lt; endl; return *this;}\n\n    ~Foo() noexcept {cout &lt;&lt; \"dtor\" &lt;&lt; endl;}\n};\n\n\nint main()\n{   \n    Foo foo;\n\n    vector&lt;Foo&gt; v;\n    v.push_back(std::move(foo)); \n\n    // comment the above 2 lines and replace by\n    // vector&lt;Foo&gt; v{std::move(foo)}; \n}\n</code></pre>\n<p>The output is what I expect (compiled with <code>g++ -std=c++11 --no-elide-constructors</code>, same output without the flag)</p>\n<pre><code>ctor\nmove ctor\ndtor\ndtor\n</code></pre>\n<p>Now instead of using <code>push_back</code> initialize directly the vector <code>v</code> as</p>\n<pre><code>vector&lt;Foo&gt; v{std::move(foo)};\n</code></pre>\n<p>I do not understand why I get the outputs:</p>\n<p>1) (without <code>--no-elide-constructors</code>)</p>\n<pre><code>ctor\nmove ctor\ncopy ctor\ndtor\ndtor\ndtor\n</code></pre>\n<p>2) (with <code>--no-elide-constructors</code>)</p>\n<pre><code>ctor\nmove ctor\nmove ctor\ncopy ctor\ndtor\ndtor\ndtor\ndtor\n</code></pre>\n<p>In the first case, why is the copy ctor invoked? And in the second case, when the compiler does not perform elision, I have absolutely no idea why the move ctor is invoked twice. Any ideas? </p>\n", "Tags": "<c++><c++11><move-semantics><copy-elision>", "OwnerUserId": "3093378", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24793019_24793143_0": {"section_id": 3327, "quality": 1.0, "length": 18}}, "n3337": {"so_24793019_24793143_0": {"section_id": 3197, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_24793019_24793143_0": {"section_id": 4093, "quality": 0.7777777777777778, "length": 14}}}});