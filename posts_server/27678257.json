post_cb({"bq_ids": {"n4140": {"so_27678257_27678304_3": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_27678257_27678304_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 569}, "so_27678257_27678304_0": {"length": 7, "quality": 0.875, "section_id": 568}}, "n3337": {"so_27678257_27678304_3": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_27678257_27678304_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 560}, "so_27678257_27678304_0": {"length": 7, "quality": 0.875, "section_id": 559}}, "n4659": {"so_27678257_27678304_3": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_27678257_27678304_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 592}, "so_27678257_27678304_0": {"length": 7, "quality": 0.875, "section_id": 591}}}, "27678257": {"ViewCount": "378", "Body": "<p>In the below code I call <code>step</code> as a member function and as a global function on a temporary value. The member function is allowed, and works, whereas the global function is disallowed due to <code>invalid initialisation of non-const reference of type \u2018kludge&amp;\u2019 from an rvalue of type \u2018kludge\u2019</code>.</p>\n<p>I'm trying to understand, from a language perspective, why one behaviour is allowed and the other is not. Technically both calls and functions seem like they'd be compiled identically, or at least could be.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct kludge {\n    int a;\n    kludge() {\n        a = 1;\n    }\n\n    kludge &amp; step() {\n        a++;\n        std::cout &lt;&lt; a &lt;&lt; \",\";\n        return *this;\n    }\n};\n\nkludge get() {\n    kludge t;\n    return t;\n}\n\nkludge &amp; step( kludge &amp; t ) {\n    t.a++;\n    std::cout &lt;&lt; t.a &lt;&lt; \",\";\n    return t;\n}\n\nint main() {\n    get().step();\n    step( get() );\n}\n</code></pre>\n", "Title": "Why can a member function be called on a temporary but a global function cannot?", "CreationDate": "2014-12-28T16:21:29.343", "LastActivityDate": "2014-12-28T16:39:03.117", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "Id": "27678257", "Score": "4", "OwnerUserId": "229686", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}, "27678304": {"Id": "27678304", "PostTypeId": "2", "Body": "<p>You cannot bind rvalues to non-const lvalue references<sup>1</sup>. That applies to <code>step(get())</code> as the parameter of <code>step</code>, which is a non-const lvalue reference, cannot be bound to the prvalue (<em>pure rvalue</em>) <code>get()</code>.</p>\n<p>However, member functions can per se be called on object arguments of <em>every</em> value category, be it lvalue or rvalue - [over.match.funcs]/4 and /5:</p>\n<blockquote>\n<p id=\"so_27678257_27678304_0\">For non-static member functions, the type of the implicit object\n  parameter is</p>\n<ul>\n<li>\u201clvalue reference to <em>cv</em> <code>X</code>\u201d for functions declared without a <em>ref-qualifier</em> or with the <code>&amp;</code> <em>ref-qualifier</em></li>\n</ul>\n<p id=\"so_27678257_27678304_1\">[..]</p>\n<p id=\"so_27678257_27678304_2\">For non-static member functions declared without a <em>ref-qualifier</em>, an\n  additional rule applies:  </p>\n<ul>\n<li><strong>even if the implicit object parameter is\n  not <code>const</code>-qualified, an rvalue can be bound to the parameter as long\n  as in all other respects the argument can be converted to the type of\n  the implicit object parameter.</strong>   [ <em>Note:</em> The fact that such an\n  argument is an rvalue does not affect the ranking of implicit\n  conversion sequences (13.3.3.2). <em>\u2014 end note</em> ]</li>\n</ul>\n</blockquote>\n<p>But if you use so-called <em>ref-qualifiers</em>, you can restrict the value categories that are valid for a particular member function. That is, if you write:</p>\n<pre><code>kludge &amp; step() &amp; { /* .. */ }\n</code></pre>\n<p>The call <code>get().step()</code> will be ill-formed too.</p>\n<p><hr>\n<sup>1</sup>)<br>\nThis is a well-known fact, but here is [dcl.init.ref]/5, heavily shortened:</br></hr></p>\n<blockquote>\n<p id=\"so_27678257_27678304_3\">A reference to type \u201c<em>cv1</em> <code>T1</code>\u201d is initialized by an expression of\n  type \u201c<em>cv2</em> <code>T2</code>\u201d as follows:</p>\n<ul>\n<li>If the reference is an lvalue reference and the initializer expression\n  <ul>\n<li>is an lvalue [..]</li>\n<li>has a class type (i.e., <code>T2</code> is a class type), where <code>T1</code> is not reference-related to <code>T2</code>, and can be implicitly converted to an lvalue of type \u201c<em>cv3</em> <code>T3</code>,\u201d\n  [..]<br>\n<br/></br></li>\n</ul></li>\n<li><strong>Otherwise, the reference shall be an lvalue reference to a non-volatile <code>const</code> type (i.e., <em>cv1</em> shall be <code>const</code>), or the\n  reference shall be an rvalue reference.</strong></li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-12-28T16:39:03.117", "Score": "5", "CreationDate": "2014-12-28T16:25:34.613", "ParentId": "27678257", "CommentCount": "6", "LastEditDate": "2014-12-28T16:39:03.117", "OwnerUserId": "3647361"}, "27678301": {"Id": "27678301", "PostTypeId": "2", "Body": "<p>Temporary cannot bind to non-const reference</p>\n<pre><code>step( get() );\n//    ~~~~~   Creates a temporary object (r-value)\n// But step( ) excepts a non-const reference\n</code></pre>\n", "LastActivityDate": "2014-12-28T16:25:22.753", "Score": "1", "CreationDate": "2014-12-28T16:25:22.753", "ParentId": "27678257", "CommentCount": "3", "OwnerUserId": "1870232"}});