post_cb({"43512098": {"Id": "43512098", "PostTypeId": "2", "Body": "<p>GCC and Clang are correct, because the conversion you are attempting to perform is not among those that can be performed by <code>static_cast</code>. Those conversions are enumerated in [expr.static.cast]. I will briefly summarize them with references to paragraphs in that section:</p>\n<ul>\n<li>Base to derived reference conversion (p2)</li>\n<li>Conversion to xvalue of reference-compatible type (p3)</li>\n<li>Conversion using the operand for direct-initialization (p4)</li>\n<li>Conversion to void (p6)</li>\n<li>Inverse of standard conversion sequence (p7)</li>\n<li>Integer/enum conversions (p9, p10)</li>\n<li>Base to derived pointer conversion (p11)</li>\n<li>Derived to base pointer-to-member conversion (p12)</li>\n<li>Void pointer to object pointer conversion (p13)</li>\n</ul>\n<p>Furthermore, p5 says:</p>\n<blockquote>\n<p id=\"so_43511868_43512098_0\">No other conversion shall be performed explicitly using a <code>static_cast</code>.</p>\n</blockquote>\n<p>The conversion of a function or function pointer to <code>void*</code> is not among the conversions listed.</p>\n<p>In particular, direct-initialization does not apply since there is no standard conversion from function pointer to <code>void*</code>. According to [conv.ptr]/2:</p>\n<blockquote>\n<p id=\"so_43511868_43512098_1\">A prvalue of type \u201cpointer to <em>cv</em> <code>T</code>,\u201d where <code>T</code> is an object type, can be converted to a prvalue of type \u201cpointer\n  to <em>cv</em> <code>void</code>\u201d. The result of converting a non-null pointer value of a pointer to object type to a \u201cpointer to\n  <em>cv</em> <code>void</code>\u201d represents the address of the same byte in memory as the original pointer value. The null pointer\n  value is converted to the null pointer value of the destination type.</p>\n</blockquote>\n<p>Note that this only covers object pointers, not function pointers.</p>\n", "LastActivityDate": "2017-04-20T06:44:38.987", "CommentCount": "0", "CreationDate": "2017-04-20T06:44:38.987", "ParentId": "43511868", "Score": "9", "OwnerUserId": "481267"}, "bq_ids": {"n4140": {"so_43511868_43512098_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 40}, "so_43511868_43512098_0": {"length": 6, "quality": 1.0, "section_id": 6031}, "so_43511868_43511923_0": {"length": 6, "quality": 0.75, "section_id": 40}}, "n3337": {"so_43511868_43512098_1": {"length": 26, "quality": 0.6341463414634146, "section_id": 37}, "so_43511868_43512098_0": {"length": 6, "quality": 1.0, "section_id": 5799}, "so_43511868_43511923_0": {"length": 6, "quality": 0.75, "section_id": 37}}, "n4659": {"so_43511868_43512098_1": {"length": 22, "quality": 0.5365853658536586, "section_id": 43}, "so_43511868_43512098_0": {"length": 6, "quality": 1.0, "section_id": 7530}, "so_43511868_43511923_0": {"length": 6, "quality": 0.75, "section_id": 40}}}, "43511868": {"ViewCount": "110", "Body": "<p>Consider following simple program:</p>\n<pre><code>#include &lt;iostream&gt;\nvoid foo() { }\nint main() {\n    std::cout&lt;&lt;static_cast&lt;void*&gt;(foo);\n}\n</code></pre>\n<p>It compiles fine on <code>VC++</code> but <code>g++</code> &amp; <code>clang++</code> gives compilation errors.</p>\n<p>See live demo <a href=\"http://rextester.com/HPFFD48636\" rel=\"nofollow noreferrer\">here</a> ( <code>VC++</code> )</p>\n<p>See live demo <a href=\"http://rextester.com/XXYIB76210\" rel=\"nofollow noreferrer\">here</a> ( <code>clang++</code> )</p>\n<p>See live demo <a href=\"http://rextester.com/PAADP7292\" rel=\"nofollow noreferrer\">here</a> ( <code>g++</code> )</p>\n<p>Diagnostics given by <code>g++</code> &amp; <code>clang++</code>:</p>\n<pre><code>source_file.cpp: In function \u2018int main()\u2019:\nsource_file.cpp:4:38: error: invalid static_cast from type \u2018void()\u2019 to type \u2018void*\u2019\n     std::cout&lt;&lt;static_cast&lt;void*&gt;(foo);\n                                  ^\n</code></pre>\n<p>So, the question is which compiler is right here according to C++ standard ? I think behaviour of <code>g++</code> &amp; <code>clang++</code> is correct here. I know that I should use <code>reinterpret_cast</code> here instead of <code>static_cast</code>. Is this bug in <code>VC++</code> compiler ? If answer depends on the specific standard of C++ then also I am curious to know about it.</p>\n", "AcceptedAnswerId": "43512098", "Title": "Print an address of function in C++, g++/clang++ vs vc++ , who is right?", "CreationDate": "2017-04-20T06:31:06.583", "Id": "43511868", "CommentCount": "2", "LastEditDate": "2017-07-09T13:12:23.097", "PostTypeId": "1", "LastEditorUserId": "3777958", "LastActivityDate": "2017-07-09T13:12:23.097", "Score": "1", "OwnerUserId": "3777958", "Tags": "<c++><visual-c++><clang++><reinterpret-cast><static-cast>", "AnswerCount": "2"}, "43511923": {"Id": "43511923", "PostTypeId": "2", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/pointer#Pointers_to_void\" rel=\"nofollow noreferrer\">this pointers-to-void reference</a>:</p>\n<blockquote>\n<p id=\"so_43511868_43511923_0\">Pointer to <strong>object</strong> of any type can be implicitly converted to pointer to <code>void</code></p>\n</blockquote>\n<p><sub>[Emphasis mine]</sub></p>\n<p>And <a href=\"http://en.cppreference.com/w/cpp/language/functions\" rel=\"nofollow noreferrer\">from this function reference</a>:</p>\n<blockquote>\n<p id=\"so_43511868_43511923_1\">Functions are not objects</p>\n</blockquote>\n<p>That seem to indicate that pointers to functions simply can not be converted to <code>void*</code>.</p>\n", "LastEditorUserId": "440558", "LastActivityDate": "2017-04-20T06:47:14.610", "Score": "1", "CreationDate": "2017-04-20T06:34:32.870", "ParentId": "43511868", "CommentCount": "2", "OwnerUserId": "440558", "LastEditDate": "2017-04-20T06:47:14.610"}});