post_cb({"31223711": {"ParentId": "31223666", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast\" rel=\"nofollow\">cppreference.com on implicit conversions</a>:</p>\n<blockquote>\n<p id=\"so_31223666_31223711_0\">Floating point conversions</p>\n<p id=\"so_31223666_31223711_1\">A prvalue of an floating-point type can be converted to prvalue of any other floating-point type. If the conversion is listed under floating-point promotions, it is a promotion and not a conversion.</p>\n<ul>\n<li><p id=\"so_31223666_31223711_2\">If the source value can be represented exactly in the destination type, it does not change. </p></li>\n<li><p id=\"so_31223666_31223711_3\">If the source value is between two representable values of the destination type, the result is one of those two values (it is implementation-defined which one) </p></li>\n<li><p id=\"so_31223666_31223711_4\">Otherwise, the behavior is undefined. </p></li>\n</ul>\n</blockquote>\n<p>Here, the case is the second rule. <code>100.05</code> is not exactly representable as a <code>float</code> <em>or</em> a <code>double</code>. For values such as <code>0.375</code> or <code>34</code>, the first rule would be applied, as the source value can be represented exactly.</p>\n<p>As for Java, a <code>return</code> is an assignment context. <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.2\" rel=\"nofollow\">JLS\u00a75.2</a> states:</p>\n<blockquote>\n<p id=\"so_31223666_31223711_5\">Assignment contexts allow the use of one of the following:\n  * an identity conversion (\u00a75.1.1)\n  * a widening primitive conversion (\u00a75.1.2)\n  * a widening reference conversion (\u00a75.1.5)\n  * a boxing conversion (\u00a75.1.7) optionally followed by a widening reference conversion\n  * an unboxing conversion (\u00a75.1.8) optionally followed by a widening primitive conversion.</p>\n</blockquote>\n<p>Note that an implicit narrowing conversion is <em>not</em> permitted here, unless the value being returned is a constant value (i.e. a final field, or literal expression the compiler can evalulate).</p>\n", "OwnerUserId": "1424875", "LastEditorUserId": "1424875", "LastEditDate": "2015-07-04T18:14:05.107", "Id": "31223711", "Score": "2", "CreationDate": "2015-07-04T18:05:51.143", "LastActivityDate": "2015-07-04T18:14:05.107"}, "31223755": {"ParentId": "31223666", "CommentCount": "0", "Body": "<p>Yes, the C++ compiler is smart enough that it can auto convert double to float. The Java compiler <em>could</em> do the same thing, but the designers of Java decided that it's better to not allow it, in case it is a mistake by the programmer.</p>\n", "OwnerUserId": "15727", "PostTypeId": "2", "Id": "31223755", "Score": "3", "CreationDate": "2015-07-04T18:10:36.860", "LastActivityDate": "2015-07-04T18:10:36.860"}, "31223666": {"CommentCount": "1", "ViewCount": "104", "CreationDate": "2015-07-04T18:01:43.507", "LastActivityDate": "2015-07-04T18:14:05.107", "Title": "Why returning double from float returning method does not cause any error/warning in c++", "FavoriteCount": "1", "PostTypeId": "1", "Id": "31223666", "Score": "3", "Body": "<p>Well I was trying to compile following code (just a snippet) in <code>Java</code>:</p>\n<pre><code>class MyClass{\n        public float get100(){\n        return 100.05;  // returning 100.05f should work\n    }\n}\n</code></pre>\n<p>But as you can see <code>100.5</code> being a <code>double</code> in nature but <code>get100()</code> is returning <code>float</code> by its declaration, <code>javac</code> gives error as: <code>can't convert double to float</code>.</p>\n<p>Which is totally understandable. But Here is what i noticed about <code>c++</code></p>\n<p>I tried following code (Almost similar to the one mentioned above):</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nclass MyClass{\n        public:\n               float get100(){\n                    return 100.05;\n               }\n};\n\nint main(){\nMyClass m;\ncout&lt;&lt;m.get100()&lt;&lt;endl;\nreturn 0;\n}\n</code></pre>\n<p>and this code is running fine in <code>c++</code>..</p>\n<p>Can anyone tell me why is it so? or does it mean <code>c++</code> compiler is smart enough that it can auto convert <code>double</code> to <code>float</code>? </p>\n<p>But as <code>double</code> is of higher range than <code>float</code>, how is that working in <code>c++</code>?</p>\n<p>Any help/Suggestion is appreciated. Thanks in advance. </p>\n", "Tags": "<java><c++><g++><javac>", "OwnerUserId": "2010838", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31223666_31223711_2": {"section_id": 35, "quality": 0.6666666666666666, "length": 6}, "so_31223666_31223711_3": {"section_id": 35, "quality": 0.5333333333333333, "length": 8}}, "n3337": {"so_31223666_31223711_2": {"section_id": 32, "quality": 0.6666666666666666, "length": 6}, "so_31223666_31223711_3": {"section_id": 32, "quality": 0.5333333333333333, "length": 8}}, "n4659": {"so_31223666_31223711_2": {"section_id": 35, "quality": 0.6666666666666666, "length": 6}, "so_31223666_31223711_1": {"section_id": 35, "quality": 0.625, "length": 10}, "so_31223666_31223711_3": {"section_id": 35, "quality": 0.5333333333333333, "length": 8}}}});