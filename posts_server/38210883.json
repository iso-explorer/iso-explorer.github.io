post_cb({"38210883": {"Tags": "<c++><multithreading>", "ViewCount": "82", "AnswerCount": "1", "CreationDate": "2016-07-05T19:07:45.167", "Title": "Return value register and destructor call order", "CommentCount": "6", "AcceptedAnswerId": "38211087", "Score": "3", "OwnerUserId": "2369597", "Id": "38210883", "LastActivityDate": "2016-07-05T19:21:29.927", "Body": "<p>I am implementing my own atomic class as on a particular project <em>in which I don't have access to the C++11 atomic library</em>.  I have the following code so far:</p>\n<pre><code> class CAtomicLong\n {\n public:\n\n     CAtomicLong(long lVal) : m_lValue(lVal) {}\n\n     long operator+(long lVal)\n     {\n         CAutoLock lock(m_lock);\n         m_lValue += lVal;\n         return m_lValue;\n     }\n private:\n\n     CMyMutex m_lock;\n     long m_lValue;\n };\n</code></pre>\n<p>Assume that <code>CMyMutex</code> is a custom wrapper around a mutex, and <code>CAutoLock</code> is a class whose destructor unlocks the object passed to it during its construction.  Those details are largely irrelevant for this question anyway.</p>\n<p>What I would like to know is if it is safe to return <code>m_lValue</code> like this; i.e. will it be copied into a register to return <em>before</em> the destructor for <code>lock</code> is called?  I ask as I am concerned about torn reads and writes, because if the destructor is called <em>before</em> the return register is setup another thread could start modifying <code>m_lValue</code> as it is being copied for return.</p>\n<p>I have had a look at the disassembly in Visual Studio for code like this and it appears to show the return call being made <em>before</em> the destructor is called, but a) I don't really know what I'm looking at with assembly (I'm still learning :)) and b) I don't know if this is standard behaviour (again, I'm still learning).  The safest workaround to this <em>potential</em> problem is</p>\n<pre><code>long operator+(long lVal)\n{\n    CAutoLock lock(m_lock);\n    long lTemp = (m_lValue += lVal);\n    return lTemp;\n}\n</code></pre>\n<p>...but if this is overkill I'd rather know now.</p>\n", "PostTypeId": "1"}, "38211087": {"ParentId": "38210883", "Score": "5", "CreationDate": "2016-07-05T19:21:29.927", "Id": "38211087", "OwnerUserId": "596781", "LastActivityDate": "2016-07-05T19:21:29.927", "Body": "<p>Your code is correct. [stmt.return]/3 says:</p>\n<blockquote>\n<p id=\"so_38210883_38211087_0\">The copy-initialization of the result of the call is sequenced before the destruction of temporaries at the end of the full-expression established by the operand of the return statement, which, in turn, is sequenced before\n  the destruction of local variables (6.6) of the block enclosing the return statement.</p>\n</blockquote>\n", "PostTypeId": "2", "CommentCount": "0"}, "bq_ids": {"n4659": {"so_38210883_38211087_0": {"length": 23, "section_id": 4800, "quality": 0.9583333333333334}}}});