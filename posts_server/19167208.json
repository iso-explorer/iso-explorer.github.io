post_cb({"bq_ids": {"n4140": {"so_19167208_19167928_0": {"length": 15, "quality": 0.7894736842105263, "section_id": 5341}, "so_19167208_19167928_1": {"length": 10, "quality": 0.5555555555555556, "section_id": 5341}}, "n3337": {"so_19167208_19167928_0": {"length": 15, "quality": 0.7894736842105263, "section_id": 5138}, "so_19167208_19167928_1": {"length": 10, "quality": 0.5555555555555556, "section_id": 5138}}, "n4659": {"so_19167208_19167928_0": {"length": 15, "quality": 0.7894736842105263, "section_id": 6762}, "so_19167208_19167928_1": {"length": 10, "quality": 0.5555555555555556, "section_id": 6762}}}, "19167928": {"Id": "19167928", "PostTypeId": "2", "Body": "<p>It appears that as far as your first result goes, VC++ still follows the rule from C89/90, which said (\u00a7 6.1.3.2):</p>\n<blockquote>\n<p id=\"so_19167208_19167928_0\">The type of an integer constant is the first of the corresponding list in which its value can be represented. Unsuffixed decimal: <code>int</code>, <code>long int</code>, <code>unsigned long int</code>; [...]</p>\n</blockquote>\n<p>So, since 4294967295 can be represented as an <code>unsigned long int</code>, that's what it's using.</p>\n<p>In C++98/03, this is still permitted, but no longer required -- you're using a value larger than can be represented in an <code>long int</code>, which gives undefined behavior (\u00a7 2.13.1/2):</p>\n<blockquote>\n<p id=\"so_19167208_19167928_1\">If it is decimal and has no suffix, it has the first of these types in which its value can be represented: <code>int</code>, <code>long int</code>; <strong>if the value cannot be represented as a long int, the behavior is undefined.</strong></p>\n</blockquote>\n<p>[emphasis added]</p>\n<p>C++11 adds <code>long long int</code> to the list, so that's the type <code>4294967295</code> <em>should</em> become, but even in VC++ 2013 RC, it still follows the C89/90 standard in this respect and gives it type <code>unsigned long int</code>.</p>\n<p>Note that the the string produced by <code>typeid</code> is implementation defined, so it doesn't have to correspond directly to the proper name of the type. If you use overloading, we can see that <code>0x100000000</code> and <code>4294967296</code> have type <code>long long</code> though:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid f(unsigned long){\n    std::cout &lt;&lt; \"unsigned long\\n\";\n}\n\nvoid f(long long) {\n    std::cout &lt;&lt; \"long long\\n\";\n}\n\nvoid f(unsigned long long) {\n    std::cout &lt;&lt; \"unsigned long long\\n\";\n}\n\nvoid f(unsigned) {\n    std::cout &lt;&lt; \"unsigned int\\n\";\n}\n\nint main(){\n    f(4294967295);\n    f(4294967296);\n    f(0xffffffff);\n    f(0x100000000);\n}\n</code></pre>\n<p>Result with VC++ 2008 and VC++ 2013 RC:</p>\n<pre><code>unsigned long\nlong long\nunsigned int\nlong long\n</code></pre>\n<p>I don't have all the intervening versions installed, but given that 2008 and 2013 match, I think it's fair to guess that versions in between them act the same way as well.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2013-10-03T20:08:41.073", "Score": "6", "CreationDate": "2013-10-03T19:45:30.280", "ParentId": "19167208", "CommentCount": "7", "OwnerUserId": "179910", "LastEditDate": "2013-10-03T20:08:41.073"}, "19167208": {"ViewCount": "258", "Body": "<p>I know the standard is as follows:</p>\n<ul>\n<li>Integrals starting with 0 are interpreted as octal.</li>\n<li>Integrals starting with 0x or 0X are interpreted as hexadecimal.</li>\n</ul>\n<p>The type of an integer literal depend on its value and notation:</p>\n<ul>\n<li>Decimals are by default signed and has the smallest type of int, long, long long in which the value fits.</li>\n<li>Hexadecimal and octal can be signed or unsigned and have the smallest type of int, unsigned int, long, unsigned long, long long, unsigned long long in which the literal value fits.</li>\n<li>No literals of type short but this can be override by a suffix.</li>\n</ul>\n<p>But what about VC++?! It seems to be treating decimal, octal and hexadecimal the same and unsigned types are also allowed for decimals.</p>\n<p>something like the following code:</p>\n<pre><code>cout &lt;&lt; typeid(4294967295).name() &lt;&lt; endl;\ncout &lt;&lt; typeid(4294967296).name() &lt;&lt; endl;\n\ncout &lt;&lt; typeid(0xffffffff).name() &lt;&lt; endl;\ncout &lt;&lt; typeid(0x100000000).name() &lt;&lt; endl;\n</code></pre>\n<p>gives:</p>\n<pre><code>unsigned long\n__int64\nunsigned int\n__int64\n</code></pre>\n<p>Is this expected and why it is different from the standard?</p>\n", "AcceptedAnswerId": "19167928", "Title": "Literals types in VC++", "CreationDate": "2013-10-03T19:05:10.240", "Id": "19167208", "CommentCount": "11", "LastEditDate": "2013-10-03T19:17:19.340", "PostTypeId": "1", "LastEditorUserId": "1782465", "LastActivityDate": "2013-10-03T20:08:41.073", "Score": "4", "OwnerUserId": "1495217", "Tags": "<c++><visual-c++><c++11>", "AnswerCount": "1"}});