post_cb({"37863528": {"ParentId": "37861600", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_37861600_37863528_0\">Is the code example valid in all C language standards?</p>\n</blockquote>\n<p>Note that only one ISO standard is in effect at a time; C2011 supercedes C99, which superceded C89.  </p>\n<p>I believe it should be valid under any one of those standards, though.</p>\n<blockquote>\n<p id=\"so_37861600_37863528_1\">Is it invalid in all C++ language standards?</p>\n</blockquote>\n<p>Same as above, just change \"valid\" to \"invalid\".</p>\n<blockquote>\n<p id=\"so_37861600_37863528_2\">Is there a reason that is valid in one language but not another?</p>\n</blockquote>\n<p>Most likely, it was left valid in C so as not to break any legacy code that relied on the behavior.  C++ came along about a decade or so after C and tried to address some of C's shortcomings, and this was one of the holes that got plugged.  </p>\n<p>Many modern programming languages are iterations and improvements on earlier languages; C is B with a type system, C++ is C with OO support and better type safety, Java and C# are C++ with less undefined behavior, etc.  </p>\n", "OwnerUserId": "134554", "LastEditorUserId": "908939", "LastEditDate": "2016-06-16T16:05:03.397", "Id": "37863528", "Score": "5", "CreationDate": "2016-06-16T15:32:24.860", "LastActivityDate": "2016-06-16T16:05:03.397"}, "37861600": {"CommentCount": "24", "ViewCount": "840", "CreationDate": "2016-06-16T14:06:46.050", "LastActivityDate": "2016-06-16T16:05:03.397", "Title": "What language standards allow ignoring null terminators on fixed size arrays?", "AcceptedAnswerId": "37862035", "PostTypeId": "1", "Id": "37861600", "Score": "21", "Body": "<p>We are transitioning C code into C++.<br>\nI noticed  that the following code is well defined in C,  </br></p>\n<pre><code>int main(){\n\n  //length is valid. '\\0' is ignored\n  char  str[3]=\"abc\";\n}\n</code></pre>\n<p>as it is stated in <a href=\"http://en.cppreference.com/w/c/language/array_initialization\">Array initialization</a> that:  </p>\n<blockquote>\n<p id=\"so_37861600_37861600_0\">\"If the size of the array is known, it may be one less than the size of\n  the string literal, in which case the terminating null character is\n  ignored.\"</p>\n</blockquote>\n<p>However, if I were to build the same code in C++, I get the following C++ error:  </p>\n<pre><code>error: initializer-string for array of chars is too long\n[-fpermissive]    char  str[3]=\"abc\";\n</code></pre>\n<p>I'm hoping someone can expound on this.  </p>\n<p><strong>Questions:</strong><br>\nIs the code example valid in all C language standards?<br>\nIs it invalid in all C++ language standards?<br>\nIs there a reason that is valid in one language but not another?</br></br></br></p>\n", "Tags": "<c++><c><arrays><c-strings><array-initialization>", "OwnerUserId": "908939", "AnswerCount": "2"}, "37862035": {"ParentId": "37861600", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>What you see here is a difference in the initialization rules for cstring in C and C++.  In C11 \u00a76.7.9/14 we have</p>\n<blockquote>\n<p id=\"so_37861600_37862035_0\">An array of character type may be initialized by a character string literal or UTF\u22128 string literal, optionally enclosed in braces. Successive bytes of the string literal (<strong>including the terminating null character if there is room</strong> or if the array is of unknown size) initialize the elements of the array.</p>\n</blockquote>\n<p><sup>emphasis mine</sup></p>\n<p>So as long as the array is large enough for the string excluding the null terminator it is valid.  So </p>\n<pre><code>char  str[3]=\"abc\";\n</code></pre>\n<p>Is valid C.  In C++14 however the rule that governs this found in [dcl.init.string]/2 states</p>\n<blockquote>\n<p id=\"so_37861600_37862035_1\">There shall not be more initializers than there are array elements.</p>\n</blockquote>\n<p>And goes on to show that the following code is an error</p>\n<pre><code>char cv[4] = \"asdf\"; // error\n</code></pre>\n<p>So in C++ you have to have enough storage for the entire string literal including the null terminator.</p>\n", "OwnerUserId": "4342498", "LastEditorUserId": "4342498", "LastEditDate": "2016-06-16T14:31:45.160", "Id": "37862035", "Score": "16", "CreationDate": "2016-06-16T14:25:53.317", "LastActivityDate": "2016-06-16T14:31:45.160"}, "bq_ids": {"n4140": {"so_37861600_37862035_1": {"section_id": 3315, "quality": 1.0, "length": 7}, "so_37861600_37862035_0": {"section_id": 3314, "quality": 0.5333333333333333, "length": 16}}, "n3337": {"so_37861600_37862035_1": {"section_id": 3185, "quality": 1.0, "length": 7}}, "n4659": {"so_37861600_37862035_1": {"section_id": 4081, "quality": 1.0, "length": 7}, "so_37861600_37862035_0": {"section_id": 4080, "quality": 0.5333333333333333, "length": 16}}}});