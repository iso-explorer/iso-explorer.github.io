post_cb({"bq_ids": {"n4140": {"so_20377210_20377285_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 91}, "so_20377210_20377285_4": {"length": 10, "quality": 1.0, "section_id": 6067}, "so_20377210_20377285_2": {"length": 5, "quality": 1.0, "section_id": 87}}, "n3337": {"so_20377210_20377285_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 86}, "so_20377210_20377285_4": {"length": 10, "quality": 1.0, "section_id": 5835}, "so_20377210_20377285_2": {"length": 5, "quality": 1.0, "section_id": 82}}, "n4659": {"so_20377210_20377285_4": {"length": 10, "quality": 1.0, "section_id": 7563}}}, "20377210": {"ViewCount": "361", "Body": "<p>What is wrong with this code? I thought I could convert due to this answer:</p>\n<p><a href=\"https://stackoverflow.com/questions/4272909/is-it-safe-to-upcast-a-method-pointer-and-use-it-with-base-class-pointer/\">Is it safe to \"upcast\" a method pointer and use it with base class pointer?</a></p>\n<pre><code>struct B\n{\n  void f(){}\n};\n\nstruct D : B\n{\n  virtual ~D(){}\n};\n\ntemplate &lt;typename FP, FP fp&gt;\nvoid g()\n{\n}\n\nint main()\n{\n  g&lt;void (D::*)(), &amp;B::f&gt;();\n  return 0;\n}\n</code></pre>\n<p>Error:</p>\n<pre><code>t.cpp:18:27: error: could not convert template argument '&amp;B::f' to 'void (D::*)()'\n   g&lt;void (D::*)(), &amp;B::f&gt;();\n</code></pre>\n<p>This doesn't work either:</p>\n<pre><code>g&lt;void (D::*)(), static_cast&lt;void (D::*)()&gt;(&amp;B::f)&gt;();\n</code></pre>\n", "AcceptedAnswerId": "20377285", "Title": "what is wrong with this pointer to member conversion?", "CreationDate": "2013-12-04T13:55:10.527", "Id": "20377210", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:13:06.053", "LastEditorUserId": "-1", "LastActivityDate": "2013-12-04T14:09:40.517", "Score": "3", "OwnerUserId": "1095108", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "20377285": {"Id": "20377285", "PostTypeId": "2", "Body": "<p>This is disallowed by the standard (C++11, [temp.arg.nontype]\u00a75):</p>\n<blockquote>\n<p id=\"so_20377210_20377285_0\">The following conversions are performed on each expression used as a non-type <em>template-argument.</em> If a non-type <em>template-argument</em> cannot be converted to the type of the corresponding <em>template-parameter</em> then the program is ill-formed.</p>\n<p id=\"so_20377210_20377285_1\">...</p>\n<ul>\n<li>For a non-type <em>template-parameter</em> of type pointer to member function, if the <em>template-argument</em> is of type <code>std::nullptr_t</code>, the null member pointer conversion (4.11) is applied; <strong>otherwise, no conversions apply</strong>. If the template-argument represents a set of overloaded member functions, the matching member function is selected from the set (13.4).</li>\n</ul>\n</blockquote>\n<p>(Emphasis mine)</p>\n<p>Casts are not allowed either, because of [temp.arg.nontype]\u00a71:</p>\n<blockquote>\n<p id=\"so_20377210_20377285_2\">A <em>template-argument</em> for a non-type, non-template <em>template-parameter</em> shall be one of:</p>\n<p id=\"so_20377210_20377285_3\">...</p>\n<ul>\n<li>a pointer to member expressed as described in 5.3.1.</li>\n</ul>\n</blockquote>\n<p>Where 5.3.1\u00a74 reads:</p>\n<blockquote>\n<p id=\"so_20377210_20377285_4\">A pointer to member is only formed when an explicit <code>&amp;</code> is used and its operand is a <em>qualified-id</em> not enclosed in parentheses.</p>\n</blockquote>\n<p>This combines to say that a cast experssion is not allowed as a non-type template argument.</p>\n<p>So, while such conversions are possible at runtime, it seems there's no way to use them as template arguments.</p>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2013-12-04T14:09:40.517", "Score": "4", "CreationDate": "2013-12-04T13:58:06.390", "ParentId": "20377210", "CommentCount": "3", "OwnerUserId": "1782465", "LastEditDate": "2013-12-04T14:09:40.517"}});