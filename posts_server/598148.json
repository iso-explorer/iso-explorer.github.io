post_cb({"598159": {"Body": "<p>To build on <a href=\"https://stackoverflow.com/questions/598148/is-it-legal-to-use-the-increment-operator-in-a-c-function-call/598150#598150\">Kristo's answer</a>,</p>\n<pre><code>foo(i++, i++);\n</code></pre>\n<p>yields undefined behavior because the order that function arguments are evaluated is undefined (and in the more general case because <a href=\"http://www.research.att.com/~bs/bs_faq2.html#evaluation-order\" rel=\"nofollow noreferrer\">if you read a variable twice in an expression where you also write it, the result is undefined</a>).  You don't know which argument will be incremented first.</p>\n<pre><code>int i = 1;\nfoo(i++, i++);\n</code></pre>\n<p>might result in a function call of</p>\n<pre><code>foo(2, 1);\n</code></pre>\n<p>or</p>\n<pre><code>foo(1, 2);\n</code></pre>\n<p>or even</p>\n<pre><code>foo(1, 1);\n</code></pre>\n<p>Run the following to see what happens on your platform:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid foo(int a, int b)\n{\n    cout &lt;&lt; \"a: \" &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; \"b: \" &lt;&lt; b &lt;&lt; endl;\n}\n\nint main()\n{\n    int i = 1;\n    foo(i++, i++);\n}\n</code></pre>\n<p>On my machine I get</p>\n<pre><code>$ ./a.out\na: 2\nb: 1\n</code></pre>\n<p>every time, but this code is <strong>not portable</strong>, so I would expect to see different results with different compilers.</p>\n", "CreationDate": "2009-02-28T15:31:30.517", "ParentId": "598148", "CommentCount": "8", "LastEditDate": "2017-05-23T12:26:07.887", "PostTypeId": "2", "LastEditorDisplayName": "Bill the Lizard", "LastActivityDate": "2009-03-01T13:52:55.003", "LastEditorUserId": "-1", "Id": "598159", "OwnerDisplayName": "Bill the Lizard", "Score": "13", "OwnerUserId": "1288"}, "599564": {"Id": "599564", "PostTypeId": "2", "Body": "<p>++Kristo!</p>\n<p>The C++ standard 1.9.16 makes a lot of sense with respect to how one implements operator++(postfix) for a class.  When that operator++(int) method is called, it increments itself and returns a copy of the original value.  Exactly as the C++ spec says.</p>\n<p>It's nice to see standards improving!</p>\n<hr>\n<p>However, I distinctly remember using older (pre-ANSI) C compilers wherein:</p>\n<pre><code>foo -&gt; bar(i++) -&gt; charlie(i++);\n</code></pre>\n<p>Did not do what you think!  Instead it compiled equivalent to:</p>\n<pre><code>foo -&gt; bar(i) -&gt; charlie(i); ++i; ++i;\n</code></pre>\n<p>And this behavior was compiler-implementation dependent.  (Making porting fun.)</p>\n<hr>\n<p>It's easy enough to test and verify that modern compilers now behave correctly:</p>\n<pre><code>#define SHOW(S,X)  cout &lt;&lt; S &lt;&lt; \":  \" # X \" = \" &lt;&lt; (X) &lt;&lt; endl\n\nstruct Foo\n{\n  Foo &amp; bar(const char * theString, int theI)\n    { SHOW(theString, theI);   return *this; }\n};\n\nint\nmain()\n{\n  Foo f;\n  int i = 0;\n  f . bar(\"A\",i) . bar(\"B\",i++) . bar(\"C\",i) . bar(\"D\",i);\n  SHOW(\"END \",i);\n}\n</code></pre>\n<hr>\n<hr>\n<h2>Responding to comment in thread...</h2>\n<p>...And building on pretty much <strong><em>EVERYONE's</em></strong> answers...  (Thanks guys!)</p>\n<hr>\n<p>I think we need spell this out a bit better:</p>\n<p>Given:</p>\n<pre><code>baz(g(),h());\n</code></pre>\n<p>Then we don't know whether <em>g()</em> will be invoked <strong>before or after</strong> <em>h()</em>.  It is <em>\"unspecified\"</em>.</p>\n<p>But we do know that <strong>both <em>g()</em> and <em>h()</em> will be invoked before <em>baz()</em></strong>.</p>\n<p>Given:</p>\n<pre><code>bar(i++,i++);\n</code></pre>\n<p>Again, we don't know which <em>i++</em> will be evaluated first, and perhaps not even whether <em>i</em> will be incremented once or twice before <em>bar()</em> is called.  <strong>The results are undefined!</strong>  (Given <em>i=0</em>, this could be <em>bar(0,0)</em> or <em>bar(1,0)</em> or <em>bar(0,1)</em> or something really weird!)</p>\n<hr>\n<p>Given:</p>\n<pre><code>foo(i++);\n</code></pre>\n<p>We now know that <em>i</em> will be incremented before <em>foo()</em> is invoked.  As <a href=\"https://stackoverflow.com/questions/598148/is-it-legal-to-use-the-increment-operator-in-a-c-function-call/598150#598150\">Kristo</a> pointed out from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf\" rel=\"nofollow noreferrer\">the C++ standard  section 1.9.16:</a></p>\n<blockquote>\n<blockquote>\n<p id=\"so_598148_599564_1\">When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function. [ Note: Value computations and side effects associated with different argument expressions are unsequenced. -- end note ]</p>\n</blockquote>\n</blockquote>\n<p>Though I think section 5.2.6 says it better:</p>\n<blockquote>\n<blockquote>\n<p id=\"so_598148_599564_3\">The value of a postfix ++ expression is the value of its operand. [ Note: the value obtained is a copy of the original value -- end note ] The operand shall be a modifiable lvalue. The type of the operand shall be an arithmetic type or a pointer to a complete effective object type. The value of the operand object is modified by adding 1 to it, unless the object is of type bool, in which case it is set to true. [ Note: this use is deprecated, see Annex D. -- end note ] The value computation of the ++ expression is sequenced before the modification of the operand object. <strong>With respect to an indeterminately-sequenced function call, the operation of postfix ++ is a single evaluation. [ Note: Therefore, a function call shall not intervene between the lvalue-to-rvalue conversion and the side effect associated with any single postfix ++ operator. -- end note ]</strong> The result is an rvalue. The type of the result is the cv-unqualified version of the type of the operand. See also 5.7 and 5.17.</p>\n</blockquote>\n</blockquote>\n<p>The standard, in section 1.9.16, also lists (as part of its examples):</p>\n<pre><code>i = 7, i++, i++;    // i becomes 9 (valid)\nf(i = -1, i = -1);  // the behavior is undefined\n</code></pre>\n<p>And we can trivially demonstrate this with:</p>\n<pre><code>#define SHOW(X)  cout &lt;&lt; # X \" = \" &lt;&lt; (X) &lt;&lt; endl\nint i = 0;  /* Yes, it's global! */\nvoid foo(int theI) { SHOW(theI);  SHOW(i); }\nint main() { foo(i++); }\n</code></pre>\n<p>So, yes, <em>i</em> is incremented before <em>foo()</em> is invoked.</p>\n<hr>\n<p>All this makes a lot of sense from the perspective of:</p>\n<pre><code>class Foo\n{\npublic:\n  Foo operator++(int) {...}  /* Postfix variant */\n}\n\nint main() {  Foo f;  delta( f++ ); }\n</code></pre>\n<p>Here <em>Foo::operator++(int)</em> must be invoked prior to <em>delta()</em>.  And the increment operation must be completed during that invocation.</p>\n<hr>\n<p>In my (perhaps overly complex) example:</p>\n<pre><code>f . bar(\"A\",i) . bar(\"B\",i++) . bar(\"C\",i) . bar(\"D\",i);\n</code></pre>\n<p><em>f.bar(\"A\",i)</em> must be executed to obtain the object used for <em>object.bar(\"B\",i++)</em>, and so on for <em>\"C\"</em> and <em>\"D\"</em>.</p>\n<p>So we know that <em>i++</em> increments <em>i</em> prior to calling <em>bar(\"B\",i++)</em> (even though <em>bar(\"B\",...)</em> is invoked with the old value of <em>i</em>), and therefore <em>i</em> is incremented prior to <em>bar(\"C\",i)</em> and <em>bar(\"D\",i)</em>.</p>\n<hr>\n<p>Getting back to <strong><em>j_random_hacker</em></strong>'s comment:</p>\n<blockquote>\n<p id=\"so_598148_599564_4\"><strong>j_random_hacker writes:</strong><br> +1, but I had to read the standard carefully to convince myself that this was OK. Am I right in thinking that, if bar() was instead a global function returning say int, f was an int, and those invocations were connected by say \"^\" instead of \".\", then any of A, C and D could report \"0\"?</br></p>\n</blockquote>\n<p>This question is a lot more complicated than you might think...</p>\n<p>Rewriting your question as code...</p>\n<pre><code>int bar(const char * theString, int theI) { SHOW(...);  return i; }\n\nbar(\"A\",i)   ^   bar(\"B\",i++)   ^   bar(\"C\",i)   ^   bar(\"D\",i);\n</code></pre>\n<p>Now we have only <strong>ONE</strong> expression.  According to the standard (section 1.9, page 8, pdf page 20):</p>\n<blockquote>\n<blockquote>\n<p id=\"so_598148_599564_6\">Note: operators can be regrouped according to the usual mathematical rules only where the operators really are associative or commutative.(7) For example, in the following fragment:  a=a+32760+b+5; the expression statement behaves exactly the same as: a=(((a+32760)+b)+5); due to the associativity and precedence of these operators. Thus, the result of the sum (a+32760) is next added to b, and that result is then added to 5 which results in the value assigned to a. On a machine in which overflows produce an exception and in which the range of values representable by an int is [-32768,+32767], the implementation cannot rewrite this expression as a=((a+b)+32765); since if the values for a and b were, respectively, -32754 and -15, the sum a+b would produce an exception while the original expression would not; nor can the expression be rewritten either as a=((a+32765)+b); or a=(a+(b+32765)); since the values for a and b might have been, respectively, 4 and -8 or -17 and 12. <strong>However on a machine in which overflows do not produce an exception and in which the results of overflows are reversible, the above expression statement can be rewritten by the implementation in any of the above ways because the same result will occur. -- end note ]</strong></p>\n</blockquote>\n</blockquote>\n<p>So we might think that, due to precedence, that our expression would be the same as:</p>\n<pre><code>(\n       (\n              ( bar(\"A\",i) ^ bar(\"B\",i++)\n              )\n          ^  bar(\"C\",i)\n       )\n    ^ bar(\"D\",i)\n);\n</code></pre>\n<p>But, because (a^b)^c==a^(b^c) without any possible overflow situations, it could be rewritten in any order...</p>\n<p>But, because bar() is being invoked, and could  hypothetically involve side effects, this expression cannot be rewritten in just any order.  Rules of precedence still apply.</p>\n<p>Which nicely determines the order of evaluation of the <em>bar()'s</em>.</p>\n<p>Now, when does that <em>i+=1</em> occur?  Well it still has to occur before <em>bar(\"B\",...)</em> is invoked.  (Even though <em>bar(\"B\",....)</em> is invoked with the old value.)</p>\n<p>So it's deterministically occurring before <em>bar(C)</em> and <em>bar(D)</em>, and after <em>bar(A)</em>.</p>\n<p><strong>Answer: NO</strong>.  We will always have \"A=0, B=0, C=1, D=1\", <strong>if the compiler is standards-compliant.</strong></p>\n<hr>\n<p>But consider another problem:</p>\n<pre><code>i = 0;\nint &amp; j = i;\nR = i ^ i++ ^ j;\n</code></pre>\n<p>What is the value of R?</p>\n<p>If the <em>i+=1</em> occurred before <em>j</em>, we'd have 0^0^1=1.  But if the <em>i+=1</em> occurred after the whole expression, we'd have 0^0^0=0.</p>\n<p>In fact, R is zero.  The <em>i+=1</em> does not occur until after the expression has been evaluated.</p>\n<hr>\n<p>Which I reckon is why:</p>\n<p>i = 7, i++, i++;    // i becomes 9 (valid)</p>\n<p>Is legal...  It has three expressions:</p>\n<ul>\n<li>i = 7</li>\n<li>i++</li>\n<li>i++</li>\n</ul>\n<p>And in each case, the value of <em>i</em> is changed at the conclusion of each expression.  (Before any subsequent expressions are evaluated.)</p>\n<hr>\n<p>PS:  Consider:</p>\n<pre><code>int foo(int theI) { SHOW(theI);  SHOW(i);  return theI; }\ni = 0;\nint &amp; j = i;\nR = i ^ i++ ^ foo(j);\n</code></pre>\n<p>In this case, <em>i+=1</em> has to be evaluated before <em>foo(j)</em>.  <em>theI</em> is 1.  And <em>R</em> is 0^0^1=1.</p>\n</hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2009-03-05T18:13:10.617", "Score": "2", "CreationDate": "2009-03-01T09:43:56.083", "ParentId": "598148", "CommentCount": "2", "OwnerUserId": "37946", "LastEditDate": "2017-05-23T12:18:02.170"}, "598311": {"Body": "<p>The standard says the side effect happens before the call, so the code is the same as:</p>\n<pre><code>std::list&lt;item*&gt;::iterator i_before = i;\n\ni = i_before + 1;\n\nitems.erase(i_before);\n</code></pre>\n<p>rather than being:</p>\n<pre><code>std::list&lt;item*&gt;::iterator i_before = i;\n\nitems.erase(i);\n\ni = i_before + 1;\n</code></pre>\n<p>So it is safe in this case, because list.erase() specifically doesn't invalidate any iterators other than the one erased.</p>\n<p>That said, it's bad style - the erase function for all containers returns the next iterator specifically so you don't have to worry about invalidating iterators due to reallocation, so the idiomatic code:</p>\n<pre><code>i = items.erase(i);\n</code></pre>\n<p>will be safe for lists, and will also be safe for vectors, deques and any other sequence container should you want to change your storage. </p>\n<p>You also wouldn't get the original code to compile without warnings - you'd have to  write </p>\n<pre><code>(void)items.erase(i++);\n</code></pre>\n<p>to avoid a warning about an unused return, which would be a big clue that you're doing something odd.</p>\n", "CreationDate": "2009-02-28T17:04:25.347", "ParentId": "598148", "CommentCount": "5", "LastEditDate": "2009-03-01T10:40:37.103", "PostTypeId": "2", "LastEditorDisplayName": "Pete Kirkham", "LastActivityDate": "2009-03-01T10:40:37.103", "LastEditorUserId": "1527", "Id": "598311", "OwnerDisplayName": "Pete Kirkham", "Score": "5", "OwnerUserId": "1527"}, "616006": {"Id": "616006", "PostTypeId": "2", "Body": "<p>Sutter's <a href=\"http://www.gotw.ca/gotw/055.htm\" rel=\"nofollow noreferrer\">Guru of the Week #55</a> (and the corresponding piece in \"More Exceptional C++\") discusses this exact case as an example.</p>\n<p>According to him, it is perfectly valid code, and in fact a case where trying to transform the statement into two lines:</p>\n<pre>\nitems.erase(i);\ni++;\n</pre>\n<p>does <i>not</i> produce code that is semantically equivalent to the original statement.</p>\n", "OwnerDisplayName": "Boojum", "LastActivityDate": "2009-03-05T18:34:42.470", "Score": "0", "CreationDate": "2009-03-05T18:34:42.470", "ParentId": "598148", "CommentCount": "0", "OwnerUserId": "37555"}, "598150": {"Body": "<p>Quoth the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf\" rel=\"noreferrer\">C++ standard</a> 1.9.16:</p>\n<blockquote>\n<p id=\"so_598148_598150_0\">When calling a function (whether or\n  not the function is inline), every\n  value computation and side effect\n  associated with any argument\n  expression, or with the postfix\n  expression designating the called\n  function, is sequenced before\n  execution of every expression or\n  statement in the body of the called\n  function.  (Note: Value computations\n  and side effects associated with the\n  different argument expressions are\n  unsequenced.)</p>\n</blockquote>\n<p>So it would seem to me that this code:</p>\n<pre><code>foo(i++);\n</code></pre>\n<p>is perfectly legal.  It will increment <code>i</code> and then call <code>foo</code> with the previous value of <code>i</code>.  However, this code:</p>\n<pre><code>foo(i++, i++);\n</code></pre>\n<p>yields undefined behavior because paragraph 1.9.16 also says:</p>\n<blockquote>\n<p id=\"so_598148_598150_1\">If a side effect on a scalar object is\n  unsequenced relative to either another\n  side effect on the same scalar object\n  or a value computation using the value\n  of the same scalar object, the\n  behavior is undefined.</p>\n</blockquote>\n", "CreationDate": "2009-02-28T15:23:51.643", "ParentId": "598148", "CommentCount": "7", "LastEditDate": "2009-02-28T15:48:21.363", "PostTypeId": "2", "LastEditorDisplayName": "Kristo", "LastActivityDate": "2009-02-28T15:48:21.350", "LastEditorUserId": "46821", "Id": "598150", "OwnerDisplayName": "Kristo", "Score": "55", "OwnerUserId": "46821"}, "598148": {"ViewCount": "11164", "Body": "<p>There's been some debate going on in <a href=\"https://stackoverflow.com/questions/596162/can-you-remove-elements-from-a-stdlist-while-iterating-through-it/596180#596180\">this question</a> about whether the following code is legal C++:</p>\n<pre><code>std::list&lt;item*&gt;::iterator i = items.begin();\nwhile (i != items.end())\n{\n    bool isActive = (*i)-&gt;update();\n    if (!isActive)\n    {\n        items.erase(i++);  // *** Is this undefined behavior? ***\n    }\n    else\n    {\n        other_code_involving(*i);\n        ++i;\n    }\n}\n</code></pre>\n<p>The problem here is that <code>erase()</code> will invalidate the iterator in question.  If that happens before <code>i++</code> is evaluated, then incrementing <code>i</code> like that is technically undefined behavior, even if it appears to work with a particular compiler.  One side of the debate says that all function arguments are fully evaluated before the function is called.  The other side says, \"the only guarantees are that i++ will happen before the next statement and after i++ is used. Whether that is before erase(i++) is invoked or afterwards is compiler dependent.\"</p>\n<p>I opened this question to hopefully settle that debate.</p>\n", "AcceptedAnswerId": "598150", "Title": "Is it legal to use the increment operator in a C++ function call?", "CreationDate": "2009-02-28T15:22:44.780", "LastActivityDate": "2009-11-19T16:38:40.037", "CommentCount": "2", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:31:10.703", "OwnerDisplayName": "Kristo", "LastEditorUserId": "-1", "Id": "598148", "Score": "40", "OwnerUserId": "46821", "Tags": "<c++><function><standards>", "AnswerCount": "8"}, "bq_ids": {"n4140": {"so_598148_599564_2": {"length": 75, "quality": 0.7894736842105263, "section_id": 6009}, "so_598148_599564_6": {"length": 90, "quality": 0.8737864077669902, "section_id": 5805}, "so_598148_599564_0": {"length": 37, "quality": 0.925, "section_id": 5811}, "so_598148_599564_3": {"length": 75, "quality": 0.7894736842105263, "section_id": 6009}, "so_598148_598150_1": {"length": 22, "quality": 1.0, "section_id": 5811}, "so_598148_599564_5": {"length": 90, "quality": 0.8737864077669902, "section_id": 5805}, "so_598148_599564_1": {"length": 37, "quality": 0.925, "section_id": 5811}, "so_598148_598150_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 5811}}, "n3337": {"so_598148_599564_5": {"length": 90, "quality": 0.8737864077669902, "section_id": 5578}, "so_598148_599564_2": {"length": 75, "quality": 0.7894736842105263, "section_id": 5777}, "so_598148_599564_0": {"length": 37, "quality": 0.925, "section_id": 5584}, "so_598148_599564_6": {"length": 90, "quality": 0.8737864077669902, "section_id": 5578}, "so_598148_598150_1": {"length": 22, "quality": 1.0, "section_id": 5584}, "so_598148_598150_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 5584}, "so_598148_599564_1": {"length": 37, "quality": 0.925, "section_id": 5584}, "so_598148_599564_3": {"length": 75, "quality": 0.7894736842105263, "section_id": 5777}}, "n4659": {"so_598148_599564_5": {"length": 90, "quality": 0.8737864077669902, "section_id": 7263}, "so_598148_599564_2": {"length": 65, "quality": 0.6842105263157895, "section_id": 7508}, "so_598148_599564_0": {"length": 28, "quality": 0.7, "section_id": 7273}, "so_598148_599564_6": {"length": 90, "quality": 0.8737864077669902, "section_id": 7263}, "so_598148_598150_1": {"length": 16, "quality": 0.7272727272727273, "section_id": 7272}, "so_598148_598150_0": {"length": 28, "quality": 0.7368421052631579, "section_id": 7273}, "so_598148_599564_1": {"length": 28, "quality": 0.7, "section_id": 7273}, "so_598148_599564_3": {"length": 65, "quality": 0.6842105263157895, "section_id": 7508}}}, "598152": {"Id": "598152", "PostTypeId": "2", "Body": "<p>It's perfectly OK. \nThe value passed would be the value of \"i\" before the increment.</p>\n", "OwnerDisplayName": "DasBoot", "LastActivityDate": "2009-02-28T15:23:58.880", "Score": "3", "CreationDate": "2009-02-28T15:23:58.880", "ParentId": "598148", "CommentCount": "0", "OwnerUserId": "66344"}, "598257": {"Body": "<p>To build on MarkusQ's answer: ;)</p>\n<p>Or rather, Bill's comment to it:</p>\n<p>(<strong>Edit:</strong> Aw, the comment is gone again... Oh well)</p>\n<p>They're <em>allowed</em> to be evaluated in parallel. Whether or not it happens in practice is technically speaking irrelevant. </p>\n<p>You don't need thread parallelism for this to occur though, just evaluate the first step of both (take the value of i) before the second (increment i). Perfectly legal, and some compilers may consider it more efficient than fully evaluating one i++ before starting on the second.</p>\n<p>In fact, I'd expect it to be a common optimization. Look at it from an instruction scheduling point of view. You have the following you need to evaluate:</p>\n<ol>\n<li>Take the value of i for the right argument</li>\n<li>Increment i in the right argument</li>\n<li>Take the value of i for the left argument</li>\n<li>Increment i in the left argument</li>\n</ol>\n<p>But there's really no dependency between the left and the right argument. Argument evaluation happens in an unspecified order, and need not be done sequentially either (which is why new() in function arguments is usually a memory leak, even when wrapped in a smart pointer)\nIt's also undefined what happens when you modify the same variable twice in the same expression.\nWe do have a dependency between 1 and 2, however, and between 3 and 4.\nSo why would the compiler wait for 2 to complete before computing 3? That introduces added latency, and it'll take even longer than necessary before 4 becomes available.\nAssuming there's a 1 cycle latency between each, it'll take 3 cycles from 1 is complete until the result of 4 is ready and we can call the function.</p>\n<p>But if we reorder them and evaluate in the order 1, 3, 2, 4, we can do it in 2 cycles. 1 and 3 can be started in the same cycle (or even merged into one instruction, since it's the same expression), and in the following, 2 and 4 can be evaluated.\nAll modern CPU's can execute 3-4 instructions per cycle, and a good compiler should try to exploit that.</p>\n", "CreationDate": "2009-02-28T16:27:36.433", "ParentId": "598148", "CommentCount": "3", "LastEditDate": "2009-02-28T16:40:10.210", "PostTypeId": "2", "LastEditorDisplayName": "jalf", "LastActivityDate": "2009-02-28T16:40:10.210", "LastEditorUserId": "33213", "Id": "598257", "OwnerDisplayName": "jalf", "Score": "2", "OwnerUserId": "33213"}, "598178": {"Body": "<p>To build on Bill the Lizard's answer:</p>\n<pre><code>int i = 1;\nfoo(i++, i++);\n</code></pre>\n<p>might also result in a function call of </p>\n<pre><code>foo(1, 1);\n</code></pre>\n<p>(meaning that the actuals are evaluated in parallel, and then the postops are applied).</p>\n<p>-- MarkusQ</p>\n", "CreationDate": "2009-02-28T15:45:16.223", "ParentId": "598148", "CommentCount": "5", "LastEditDate": "2009-03-01T16:09:56.390", "PostTypeId": "2", "LastEditorDisplayName": "MarkusQ", "LastActivityDate": "2009-03-01T16:09:56.390", "LastEditorUserId": "62970", "Id": "598178", "OwnerDisplayName": "MarkusQ", "Score": "0", "OwnerUserId": "62970"}});