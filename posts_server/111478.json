post_cb({"111531": {"CreationDate": "2008-09-21T17:47:35.863", "CommunityOwnedDate": "2008-09-21T17:47:35.863", "ParentId": "111478", "LastEditorDisplayName": "Kevin", "Id": "111531", "LastEditorUserId": "965648", "CommentCount": "5", "Body": "<p>The C++ Standard says that an STL element must be \"copy-constructible\" and \"assignable.\"  In other words, an element must be able to be assigned or copied and the two elements are logically independent. <code>std::auto_ptr</code> does not fulfill this requirement.</p>\n<p>Take for example this code:</p>\n<pre><code>class X\n{\n};\n\nstd::vector&lt;std::auto_ptr&lt;X&gt; &gt; vecX;\nvecX.push_back(new X);\n\nstd::auto_ptr&lt;X&gt; pX = vecX[0];  // vecX[0] is assigned NULL.\n</code></pre>\n<p>To overcome this limitation, you should use the <a href=\"http://msdn.microsoft.com/en-us/library/ee410601.aspx\" rel=\"noreferrer\"><code>std::unique_ptr</code></a>, <a href=\"http://msdn.microsoft.com/en-us/library/bb982026.aspx\" rel=\"noreferrer\"><code>std::shared_ptr</code></a> or <a href=\"http://msdn.microsoft.com/en-us/library/bb982126.aspx\" rel=\"noreferrer\"><code>std::weak_ptr</code></a> smart pointers or the boost equivalents if you don't have C++11.   <a href=\"http://www.boost.org/doc/libs/1_54_0/libs/smart_ptr/smart_ptr.htm\" rel=\"noreferrer\">Here is the boost library documentation for these smart pointers.</a> </p>\n", "OwnerDisplayName": "Kevin", "LastEditDate": "2013-09-04T16:18:00.093", "LastActivityDate": "2013-09-04T16:18:00.093", "PostTypeId": "2", "Score": "116", "OwnerUserId": "6386"}, "3120715": {"CommentCount": "6", "Body": "<p>Two super excellent articles on the subject:</p>\n<ul>\n<li><a href=\"http://ootips.org/yonat/4dev/smart-pointers.html\" rel=\"noreferrer\">Smart Pointers - What, Why, Which?</a></li>\n<li><a href=\"http://www.gotw.ca/gotw/025.htm\" rel=\"noreferrer\">Guru of the Week #25</a></li>\n</ul>\n", "CreationDate": "2010-06-25T19:01:08.453", "ParentId": "111478", "Id": "3120715", "LastActivityDate": "2010-06-25T19:01:08.453", "PostTypeId": "2", "Score": "37", "OwnerUserId": "113124"}, "111478": {"CreationDate": "2008-09-21T17:27:28.360", "ViewCount": "40429", "FavoriteCount": "62", "Id": "111478", "AcceptedAnswerId": "111531", "LastEditorDisplayName": "Kevin", "Score": "191", "Title": "Why is it wrong to use std::auto_ptr<> with standard containers?", "LastEditorUserId": "560648", "CommentCount": "4", "Body": "<p>Why is it wrong to use <code>std::auto_ptr&lt;&gt;</code> with standard containers?</p>\n", "Tags": "<c++><stl><raii><auto-ptr><c++-faq>", "OwnerDisplayName": "Uhall", "LastEditDate": "2011-12-14T12:06:42.030", "LastActivityDate": "2017-03-30T22:12:17.973", "PostTypeId": "1", "AnswerCount": "7", "OwnerUserId": "19129"}, "111511": {"CreationDate": "2008-09-21T17:40:43.680", "ParentId": "111478", "Score": "16", "LastEditorUserId": "113124", "CommentCount": "1", "Body": "<p>The STL containers need to be able to copy the items you store in them, and are designed to expect the original and the copy to be equivalent. auto pointer objects have a completely different contract, whereby copying creates a transfer of ownership. This means that containers of auto_ptr will exhibit strange behaviour, depending on usage.</p>\n<p>There is a detailed description of what can go wrong in Effective STL (Scott Meyers) item 8 and also a not-so-detailed description in Effective C++ (Scott Meyers) item 13.</p>\n", "Id": "111511", "OwnerDisplayName": "Garth Gilmour", "LastEditDate": "2010-06-25T17:32:56.437", "LastActivityDate": "2010-06-25T17:32:56.437", "PostTypeId": "2", "OwnerUserId": "2635682"}, "13141169": {"LastActivityDate": "2015-01-06T12:47:14.460", "CommentCount": "0", "Body": "<p><em>C++03 Standard (ISO-IEC 14882-2003)</em> says in clause 20.4.5 paragraph 3:</p>\n<blockquote>\n<p id=\"so_111478_13141169_0\">[...]\n  [<strong>Note: [...]\n  auto_ptr does not meet the CopyConstructible and Assignable requirements for Standard Library\n  container elements and thus instantiating a Standard Library container\n  with an auto_ptr results in undefined behavior. \u2014 end note</strong>]</p>\n</blockquote>\n<p><em>C++11 Standard (ISO-IEC 14882-2011)</em> says in appendix D.10.1 paragraph 3:</p>\n<blockquote>\n<p id=\"so_111478_13141169_1\">[...]\n  <strong>Note: [...] Instances of auto_ptr meet the requirements of\n  MoveConstructible and MoveAssignable, but do not meet the requirements\n  of CopyConstructible and CopyAssignable. \u2014 end note ]</strong></p>\n</blockquote>\n<p><em>C++14 Standard (ISO-IEC 14882-2014)</em> says in appendix C.4.2\n Annex D: compatibility features:  </p>\n<blockquote>\n<p id=\"so_111478_13141169_2\"><strong><em>Change</em>: The class templates auto_ptr, unary_function, and binary_function, the function templates random_shuffle, and the\n  function templates (and their return types) ptr_fun, mem_fun,\n  mem_fun_ref, bind1st, and bind2nd are not defined.<br>\n<em>Rationale</em>: Superseded by new features.<br>\n<em>Effect on original feature</em>: Valid C ++ 2014 code that uses these class templates and function templates may fail to compile in this\n  International Standard.</br></br></strong></p>\n</blockquote>\n", "CreationDate": "2012-10-30T14:30:30.003", "LastEditDate": "2015-01-06T12:47:14.460", "ParentId": "111478", "Id": "13141169", "LastEditorUserId": "313113", "PostTypeId": "2", "Score": "3", "OwnerUserId": "313113"}, "bq_ids": {"n4140": {"so_111478_13141169_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 5005}}, "n3337": {"so_111478_13141169_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 4806}}}, "43129258": {"CommentCount": "1", "Body": "<p>You cannot put auto_ptr object to std::vector anyway, due to const-correctness.\nYou should get a compile error. </p>\n", "CreationDate": "2017-03-30T22:12:17.973", "ParentId": "111478", "Id": "43129258", "LastActivityDate": "2017-03-30T22:12:17.973", "PostTypeId": "2", "Score": "1", "OwnerUserId": "7794708"}, "111526": {"CommentCount": "2", "Body": "<p>STL containers store copies of contained items.  When an auto_ptr is copied, it sets the old ptr to null.  Many container methods are broken by this behavior.</p>\n", "CreationDate": "2008-09-21T17:44:30.380", "OwnerDisplayName": "Dustin Getz", "ParentId": "111478", "Id": "111526", "LastActivityDate": "2008-09-21T17:44:30.380", "PostTypeId": "2", "Score": "12", "OwnerUserId": "20003"}, "111492": {"CreationDate": "2008-09-21T17:29:13.987", "ParentId": "111478", "Score": "62", "LastEditorUserId": "338", "CommentCount": "0", "Body": "<p>The <strong>copy semantics</strong> of <code>auto_ptr</code> are not compatible with the containers.</p>\n<p>Specifically, copying one <code>auto_ptr</code> to another does not create two equal objects since one has lost its ownership of the pointer.</p>\n<p>More specifically, copying an <code>auto_ptr</code> causes one of the copies to let go of the pointer. Which of these remains in the container is not defined. Therefore, you can randomly lose access to pointers if you store <code>auto_ptrs</code> in the containers.</p>\n", "Id": "111492", "OwnerDisplayName": "Frank Krueger", "LastEditDate": "2010-04-15T17:22:40.470", "LastActivityDate": "2010-04-15T17:22:40.470", "PostTypeId": "2", "OwnerUserId": "338"}});