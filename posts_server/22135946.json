post_cb({"22136083": {"ParentId": "22135946", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2014-03-03T01:16:49.763", "Score": "-1", "LastEditorUserId": "207421", "LastEditDate": "2014-03-03T03:39:21.893", "Id": "22136083", "OwnerUserId": "207421", "Body": "<blockquote>\n<p id=\"so_22135946_22136083_0\">Q1\uff1a the member <code>objectMember</code> will be destructed. So is it caused by exception unwinding</p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p id=\"so_22135946_22136083_1\">or other mechanism?</p>\n</blockquote>\n<p>No.</p>\n<blockquote>\n<p id=\"so_22135946_22136083_2\">Q2: is the member pobjectMember will be destructed too?</p>\n</blockquote>\n<p>No.</p>\n<blockquote>\n<p id=\"so_22135946_22136083_3\">Someone mention the pobjectMember will be deconstructed but without anything be done for pointer's destruct process?</p>\n</blockquote>\n<p>No. 'Someone' was wrong, or very confused. The space for <code>pobjectMember</code> will be released along with the rest of the containing object. It is not correct to refer to that as 'deconstruction'. Nothing specific happens to the object pointed to by <code>pobjectMember</code> unless you code it.</p>\n<blockquote>\n<p id=\"so_22135946_22136083_4\">is it right? </p>\n</blockquote>\n<p>No.</p>\n<p>I'm wondering why on earth you're writing code like that in the first place. Everything is wrong with it, and the destructor in particular is complete nonsense. It should be like this:</p>\n<pre><code>class Object {\npublic:\n    Object()\n    : objectMember(10),\n      pobjectMember(new ObjectMember(20)) {\n        throw 1;\n    }\n\n    ~Object() {\n        delete pobjectMember;\n        throw 1;\n    }\n\nprivate:\n    ObjectMember objectMember ;\n    ObjectMember *pobjectMember ;\n}\n</code></pre>\n<p>Throwing an exception from a destructor is poor practice. In this case it is in fact illegal as the constructor is already throwing an exception, so you get an illegal throw-within-throw.</p>\n", "LastActivityDate": "2014-03-03T03:39:21.893"}, "22136015": {"ParentId": "22135946", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2014-03-03T01:09:33.953", "Score": "0", "LastEditorUserId": "493122", "LastEditDate": "2014-03-03T01:35:24.493", "Id": "22136015", "OwnerUserId": "493122", "Body": "<blockquote>\n<p id=\"so_22135946_22136015_0\">Q1\uff1a the member : objectMember will be destructed. So is it caused by exception unwinding or other mechanism?</p>\n</blockquote>\n<p>As of \u00a715.2/3:</p>\n<blockquote>\n<p id=\"so_22135946_22136015_1\">The process of calling destructors for automatic objects constructed on the path from a try block to the point where an exception is thrown is called \u201cstack unwinding.\u201d If a destructor called during stack unwinding exits with an exception, std::terminate is called (15.5.1). [ Note: So destructors should generally catch exceptions and not let them propagate out of the destructor. </p>\n</blockquote>\n<p>So, yes, that's how it's called.</p>\n<hr>\n<blockquote>\n<p id=\"so_22135946_22136015_2\">Q2: Is the member pobjectMember will be destructed too? Someone mention the pobjectMember will be deconstructed but without anything be done for pointer's destruct process? is it right?</p>\n</blockquote>\n<p>From \u00a7 15.2/1:</p>\n<blockquote>\n<p id=\"so_22135946_22136015_3\">As control passes from the point where an exception is thrown to a handler, destructors are invoked for all automatic objects constructed since the try block was entered. The automatic objects are destroyed in the reverse order of the completion of their construction.</p>\n</blockquote>\n<p>This means that in the constructor of <code>Object</code>, when you throw the exception, both <code>objectMember</code> and <code>pobjectMember</code> will be deallocated, <strong>but</strong> the dynamically allocated resource of <code>pobjectMember</code> will not be freed (this is also the reason why <a href=\"http://flamingdangerzone.com/cxx11/2012/08/15/rule-of-zero.html\" rel=\"nofollow\">people recommend to use smart pointers</a>).</p>\n<hr>\n<blockquote>\n<p id=\"so_22135946_22136015_4\">Q3: do the memory allocated for new Object will be freed by calling delete auto?</p>\n</blockquote>\n<p>I don't know what you mean by calling <code>delete auto</code>, but the easiest way to assure no memory leaks happens is by using smart pointers:</p>\n<pre><code>class Object {\npublic:\n\n    Object()\n        : objectMember(10)\n        , pobjectMember(new ObjectMember(20))\n        { throw 1; }\n\n    ~Object():objectMember(10) {\n        pobjectMember.reset(new ObjectMember(20));\n        throw 1;\n    }\n\nprivate:\n    ObjectMember objectMember;\n    std::unique_ptr&lt;ObjectMember&gt; pobjectMember;\n};\n</code></pre>\n</hr></hr>", "LastActivityDate": "2014-03-03T01:35:24.493"}, "22135946": {"CommentCount": "3", "ViewCount": "60", "PostTypeId": "1", "LastEditorUserId": "1288446", "CreationDate": "2014-03-03T01:01:50.430", "LastActivityDate": "2014-03-03T03:39:21.893", "Title": "do the followed destruct happened base on exception unwinding?", "LastEditDate": "2014-03-03T01:31:07.273", "Id": "22135946", "Score": "-3", "Body": "<pre><code>Class Object {\npublic:\n    Object() {\n        this-&gt;objectMember=ObjectMember(10); \n        this-&gt;pobjectMember=new ObjectMember(20);\n        throw 1;\n    }\n\n    ~Object():objectMember(10) {\n        this-&gt;pobjectMember=new ObjectMember(20);\n        throw 1;\n    }\n\nprivate:\n    ObjectMember objectMember ;\n    ObjectMember *pobjectMember ;\n}\n</code></pre>\n<p>when call <code>Object *o = new Object()</code>, it will throw exception. </p>\n<p>Q1\uff1a the member : objectMember will be destructed. So is it caused by exception unwinding or other mechanism?</p>\n<p>Q2:  is the member pobjectMember will be destructed too? Someone mention the  pobjectMember will be deconstructed but without anything be done for pointer's destruct process? is it right? </p>\n<p>Q3:  do the memory allocated for new Object will be freed by calling delete auto?</p>\n<p>Any official articles discuss this issues?</p>\n", "Tags": "<c++><exception><constructor>", "OwnerUserId": "1288446", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_22135946_22136015_3": {"section_id": 3343, "quality": 0.9629629629629629, "length": 26}, "so_22135946_22136015_1": {"section_id": 3345, "quality": 0.8648648648648649, "length": 32}}, "n3337": {"so_22135946_22136015_3": {"section_id": 3213, "quality": 0.8148148148148148, "length": 22}, "so_22135946_22136015_1": {"section_id": 3215, "quality": 0.7567567567567568, "length": 28}}, "n4659": {"so_22135946_22136015_3": {"section_id": 4109, "quality": 0.5555555555555556, "length": 15}}}, "22136033": {"ParentId": "22135946", "CommentCount": "7", "CreationDate": "2014-03-03T01:11:34.270", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "22136033", "Score": "0", "Body": "<blockquote>\n<p id=\"so_22135946_22136033_0\">Q1\uff1a the member : objectMember will be destructed. So is it caused by exception unwinding or other mechanism?</p>\n</blockquote>\n<p>Stack unwinding refers to the destruction of automatic (local) variables as control passes outward and outward until a <code>catch</code> block is found that can handle the exception. The destruction of <code>objectmember</code> and <code>pobjectmember</code> in this example are not part of stack unwinding. There is also a rule that if an exception propagates out of a constructor or destructor, then all fully constructed \"subobjects\" (which includes both members and base classes) are destroyed. This is what's happening here. <code>objectmember</code> and <code>pobjectmember</code> are initialized before the body of the constructor are entered, so they must be destroyed when the exception is thrown.</p>\n<blockquote>\n<p id=\"so_22135946_22136033_1\">Q2: is the member pobjectMember will be destructed too? Someone mention the pobjectMember will be deconstructed but without anything be done for pointer's destruct process? is it right?</p>\n</blockquote>\n<p>I think what they meant to say (and they'd be right) is that, yes, <code>pobjectmember</code> is destroyed too, but the destruction of a pointer object does not <code>delete</code> the pointer, so a memory leak occurs.</p>\n<p>Note that <code>Object</code>'s destructor never gets called. If an object's constructor exits <em>via</em> an exception, then the object is never really created, so it doesn't get destroyed, either.</p>\n", "LastActivityDate": "2014-03-03T01:11:34.270"}});