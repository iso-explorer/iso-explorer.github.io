post_cb({"bq_ids": {"n4140": {"so_29571705_29571768_0": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_29571705_29571768_1": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_29571705_29571782_2": {"length": 10, "quality": 1.0, "section_id": 3300}, "so_29571705_29571782_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 3298}, "so_29571705_29571782_1": {"length": 30, "quality": 0.9375, "section_id": 3299}}, "n3337": {"so_29571705_29571782_2": {"length": 10, "quality": 1.0, "section_id": 3170}, "so_29571705_29571768_1": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_29571705_29571768_0": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_29571705_29571782_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 3168}, "so_29571705_29571782_1": {"length": 30, "quality": 0.9375, "section_id": 3169}}, "n4659": {"so_29571705_29571782_2": {"length": 10, "quality": 1.0, "section_id": 4066}, "so_29571705_29571768_1": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_29571705_29571768_0": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_29571705_29571782_0": {"length": 12, "quality": 0.631578947368421, "section_id": 4063}, "so_29571705_29571782_1": {"length": 25, "quality": 0.78125, "section_id": 4065}}}, "29571705": {"ViewCount": "186", "Body": "<p>Given the following code snippet:</p>\n<pre><code>class Foo {};\nFoo makeFoo() { return Foo{}; }\n\nint main()\n{\n  Foo myFoo{makeFoo()};\n}\n</code></pre>\n<p>I would expect the single line in <code>main</code> to declare and define/initialize <code>myFoo</code> using <code>Foo</code>'s move constructor on the return value of <code>makeFoo()</code>.</p>\n<p>However, I get the following error from <code>clang++</code> 3.5.1 (compiling in C++14 mode):</p>\n<pre><code>error: excess elements in struct initializer\n      Foo myFoo{makeFoo()};\n                ^~~~~~~~~\n1 error generated.\n</code></pre>\n<p>What's going on here? What does \"struct initializer\" mean, exactly--is it just the default (no-argument) constructor for POD? Why isn't the move constructor being called?</p>\n", "AcceptedAnswerId": "29571782", "Title": "Brace-initialization via move from function return value gives \"excess elements\" error", "CreationDate": "2015-04-10T22:36:35.247", "Id": "29571705", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-04-10T22:52:10.823", "LastEditorUserId": "1858225", "LastActivityDate": "2015-04-10T22:52:10.823", "Score": "2", "OwnerUserId": "1858225", "Tags": "<c++><c++11><c++14><move-semantics><c++1z>", "AnswerCount": "2"}, "29571782": {"Id": "29571782", "PostTypeId": "2", "Body": "<p>There is no such thing as \"universal (or uniform) initialization syntax\", after all.  List-initialization has some peculiar behaviors.</p>\n<p>In your case, the relevant rules are found in section 8.5.1:</p>\n<blockquote>\n<p id=\"so_29571705_29571782_0\">An  aggregate  is  an  array  or  a  class  (Clause  9)  with  no  user-provided  constructors  (12.1),  no  private  or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>Your <code>class Foo</code> is therefore an <em>aggregate</em>.</p>\n<blockquote>\n<p id=\"so_29571705_29571782_1\">When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list are taken as initializers for the members of the aggregate, in increasing subscript or member order.  Each\n  member is copy-initialized from the corresponding initializer-clause.  If the initializer-clause is an expression and a narrowing conversion (8.5.4) is required to convert the expression, the program is ill-formed.</p>\n</blockquote>\n<p>This is how the compiler is interpreting your code (As @chris notes, in the next version of C++, it won't do so... although I would argue that this rule needs to be updated as well, merely \"as specified in 8.5.4\" is not really sufficient to stop the aggregate initialization behavior).</p>\n<p>Since there are more initializers than members, it is illegal.</p>\n<blockquote>\n<p id=\"so_29571705_29571782_2\">An aggregate that is a class can also be initialized with a single expression <strong>not enclosed in braces</strong>, as described in 8.5.</p>\n</blockquote>\n<p>That's the rule that permits copy/move initialization.  Copy/move of an aggregate cannot use braces.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2015-04-10T22:50:06.103", "Score": "7", "CreationDate": "2015-04-10T22:44:11.700", "ParentId": "29571705", "CommentCount": "3", "OwnerUserId": "103167", "LastEditDate": "2015-04-10T22:50:06.103"}, "29571768": {"Id": "29571768", "PostTypeId": "2", "Body": "<p>Since <code>Foo</code>, is an aggregate, aggregate initialization is performed.</p>\n<p>N3797 \u00a78.5.4  [dcl.init.list]/3:</p>\n<blockquote>\n<p id=\"so_29571705_29571768_0\">List-initialization of an object or reference of type T is defined as follows:  </p>\n<ul>\n<li>If T is an aggregate, aggregate initialization is performed (8.5.1).</li>\n</ul>\n</blockquote>\n<p>It seems this has been changed for C++17, according to N4296:</p>\n<blockquote>\n<p id=\"so_29571705_29571768_1\">List-initialization of an object or reference of type T is defined as\n  follows:  </p>\n<ul>\n<li>If T is a class type and the initializer list has a\n  single element of type cv U, where U is T or a class derived from T,\n  the object is initialized from that element (by copy-initialization\n  for copy-list-initialization, or by direct-initialization for\n  direct-list-initialization).</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2015-04-10T22:42:46.837", "CommentCount": "2", "CreationDate": "2015-04-10T22:42:46.837", "ParentId": "29571705", "Score": "4", "OwnerUserId": "962089"}});