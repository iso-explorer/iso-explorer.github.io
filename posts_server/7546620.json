post_cb({"7546646": {"Id": "7546646", "PostTypeId": "2", "Body": "<p>That's not <code>operator new</code>, that's the <code>new</code> operator. There's actually a big difference! The difference is that <code>operator new</code> is a function that returns raw memory; when you use the <code>new</code> operator, it invokes a constructor for you. It's the constructor that's setting the value of that <code>int</code>, not <code>operator new</code>.</p>\n", "LastActivityDate": "2011-09-25T15:55:09.637", "CommentCount": "1", "CreationDate": "2011-09-25T15:55:09.637", "ParentId": "7546620", "Score": "4", "OwnerUserId": "659804"}, "7546620": {"ViewCount": "49607", "Body": "<p>There is such code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main(){\n  unsigned int* wsk2 = new unsigned int(5);\n  std::cout &lt;&lt; \"wsk2: \" &lt;&lt; wsk2 &lt;&lt; \" \" &lt;&lt; *wsk2 &lt;&lt; std::endl;\n  delete wsk2;\n  wsk2 = new unsigned int;\n  std::cout &lt;&lt; \"wsk2: \" &lt;&lt; wsk2 &lt;&lt; \" \" &lt;&lt; *wsk2 &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p>Result:</p>\n<pre><code>wsk2: 0x928e008 5\nwsk2: 0x928e008 0\n</code></pre>\n<p>I have read that <code>new</code> doesn't initialize memory with zeroes. But here it seems that it does. How does it work?</p>\n", "AcceptedAnswerId": "7546745", "Title": "Operator new initializes memory to zero", "CreationDate": "2011-09-25T15:51:00.340", "Id": "7546620", "CommentCount": "5", "FavoriteCount": "31", "PostTypeId": "1", "LastEditDate": "2015-06-29T16:47:01.983", "LastEditorUserId": "146041", "LastActivityDate": "2015-06-29T16:47:01.983", "Score": "36", "OwnerUserId": "738811", "Tags": "<c++><memory-management>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_7546620_7546745_1": {"length": 23, "quality": 0.92, "section_id": 6098}}, "n3337": {"so_7546620_7546745_1": {"length": 23, "quality": 0.92, "section_id": 5864}}, "n4659": {"so_7546620_7546745_1": {"length": 23, "quality": 0.92, "section_id": 7595}}}, "7546930": {"Id": "7546930", "PostTypeId": "2", "Body": "<p>With some compilers, the debug version of new will initialise the data, but there is certainly nothing that you can rely on.</p>\n<p>It is also possible that the memory just had 0 from a previous use.  Don't assume that nothing happened to the memory between delete and new.  There could be something done in the background that you never noticed.  Also, the same pointer value might not be the same physical memory.  Memory pages get moved and paged out and in.  A pointer might be mapped to an entirely different location than earlier.</p>\n<p>Bottom line: if you didn't specifically initialise a memory location then you can assume nothing about its contents.  The memory manager might not even allocate a specific physical memory location until you use the memory.</p>\n<p>Modern memory management is amazingly complex, but as a C++ programmer you don't really care (mostly\u2021).  Play by the rules and you won't get into trouble.</p>\n<p>\u2021 You might care if you are optimising to reduce page faults.</p>\n", "LastActivityDate": "2011-09-25T16:38:26.090", "CommentCount": "0", "CreationDate": "2011-09-25T16:38:26.090", "ParentId": "7546620", "Score": "4", "OwnerUserId": "111432"}, "7546661": {"Id": "7546661", "PostTypeId": "2", "Body": "<p><code>operator new</code> is not guaranteed to initialize memory to anything, and the <em>new-expression</em> that allocates an <code>unsigned int</code> without a <em>new-initializer</em> leaves the object with an indeterminate value.</p>\n<p>Reading the value of an uninitialized object results in <em>undefined behavior</em>. <em>Undefined behavior</em> includes evaluating to the value zero with no ill effects but could result in anything happening so you should avoid causing it.</p>\n<p>In C++11, the language used is that the allocated objects are <em>default-initialized</em> which for non-class types means that no initialization is performed. This is different from the meaning of <em>default-initialized</em> in C++03.</p>\n", "LastEditorUserId": "19563", "LastActivityDate": "2011-09-25T16:03:18.290", "Score": "14", "CreationDate": "2011-09-25T15:56:18.887", "ParentId": "7546620", "CommentCount": "0", "OwnerUserId": "19563", "LastEditDate": "2011-09-25T16:03:18.290"}, "7546745": {"Id": "7546745", "PostTypeId": "2", "Body": "<p>There are two versions:</p>\n<pre><code>wsk = new unsigned int;      // default initialized (ie nothing happens)\nwsk = new unsigned int();    // zero    initialized (ie set to 0)\n</code></pre>\n<p>Also works for arrays:</p>\n<pre><code>wsa = new unsigned int[5];   // default initialized (ie nothing happens)\nwsa = new unsigned int[5](); // zero    initialized (ie all elements set to 0)\n</code></pre>\n<p>In answer to comment below.</p>\n<blockquote>\n<p id=\"so_7546620_7546745_0\">Ehm... are you sure that new unsigned int5 zeroes the integers?</p>\n</blockquote>\n<p>Apparently yes:</p>\n<blockquote>\n<p id=\"so_7546620_7546745_1\">[C++11: 5.3.4/15]: A new-expression that creates an object of type T initializes that object as follows: If the new-initializer is omitted, the object is default-initialized (8.5); if no initialization is performed, the object has indeterminate value. Otherwise, the new-initializer is interpreted according to the initialization rules of 8.5 for direct-initialization.</p>\n</blockquote>\n<pre><code>#include &lt;new&gt;\n#include &lt;iostream&gt;\n\n\nint main()\n{\n    unsigned int   wsa[5] = {1,2,3,4,5};\n\n    // Use placement new (to use a know piece of memory).\n    // In the way described above.\n    // \n    unsigned int*    wsp = new (wsa) unsigned int[5]();\n\n    std::cout &lt;&lt; wsa[0] &lt;&lt; \"\\n\";   // If these are zero then it worked as described.\n    std::cout &lt;&lt; wsa[1] &lt;&lt; \"\\n\";   // If they contain the numbers 1 - 5 then it failed.\n    std::cout &lt;&lt; wsa[2] &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; wsa[3] &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; wsa[4] &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Results:</p>\n<pre><code>&gt; g++ --version\nConfigured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1\nApple LLVM version 5.1 (clang-503.0.40) (based on LLVM 3.4svn)\nTarget: x86_64-apple-darwin13.2.0\nThread model: posix\n&gt; g++ t.cpp\n&gt; ./a.out\n0\n0\n0\n0\n0\n&gt;\n</code></pre>\n", "LastEditorUserId": "14065", "LastActivityDate": "2014-06-16T23:28:52.387", "Score": "113", "CreationDate": "2011-09-25T16:10:12.357", "ParentId": "7546620", "CommentCount": "8", "OwnerUserId": "14065", "LastEditDate": "2014-06-16T23:28:52.387"}});