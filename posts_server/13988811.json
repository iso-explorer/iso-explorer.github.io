post_cb({"13988811": {"CommentCount": "2", "ViewCount": "3797", "PostTypeId": "1", "LastEditorUserId": "335858", "CreationDate": "2012-12-21T10:55:19.950", "LastActivityDate": "2012-12-21T11:54:58.237", "Title": "Please explain the sequence of destructor invocations", "AcceptedAnswerId": "13989125", "LastEditDate": "2012-12-21T11:54:58.237", "Id": "13988811", "Score": "2", "Body": "<pre><code>using namespace std;\n\nclass C\n{\n    int a;\n    public:\n        C(int aa=0) {a=aa;}\n        ~C() {cout &lt;&lt; \"Destructor C!\" &lt;&lt; a &lt;&lt; endl;}\n};\n\nclass D: public C\n{\n    int b;\n    public:\n        D(int aa=0, int bb=0): C(aa) {b=bb;}\n        ~D() {cout &lt;&lt; \"Destructor D!\" &lt;&lt; b &lt;&lt; endl;}\n};\n\nvoid test()\n{\n    D x(5);\n    D y(6,7);\n}\n\nint main()\n{\n    test();\n}\n</code></pre>\n<p>Above is the code, and below is the running result:</p>\n<pre><code>Destructor D!7\nDestructor C!6\nDestructor D!0\nDestructor C!5\n</code></pre>\n<p>I don't understand why \"Destructor C!\" will be invoked. And the related destructor's calling sequence. I feel that it seems like the stack push/pop.</p>\n<p><strong>Further:</strong>\nWhy it calls \"<strong>D x(5);</strong>\" earlier but the corresponding result is given later?</p>\n", "Tags": "<c++>", "OwnerUserId": "1319802", "AnswerCount": "8"}, "13988870": {"ParentId": "13988811", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>When you create a <code>D</code> instance, the constructor of <code>C</code> will be called because <code>D</code> inherits from it.  <br/>When you destroy <code>D</code> again, it'll call <code>D</code>s destructor and then <code>C</code> destructor.</p>\n", "OwnerUserId": "174614", "LastEditorUserId": "189608", "LastEditDate": "2012-12-21T11:02:29.150", "Id": "13988870", "Score": "1", "CreationDate": "2012-12-21T10:59:31.017", "LastActivityDate": "2012-12-21T11:02:29.150"}, "13989101": {"ParentId": "13988811", "CommentCount": "0", "CreationDate": "2012-12-21T11:14:42.767", "OwnerUserId": "951757", "PostTypeId": "2", "Id": "13989101", "Score": "2", "Body": "<pre><code> I feel that it seems like the stack push/pop.\n</code></pre>\n<p>class D derived from C, when call D constructor, C constructor will be called first, destructor is called the reverse way.</p>\n<pre><code>Further: Why it calls \"D x(5);\" earlier but the corresponding result is given later?\n</code></pre>\n<p>Automatic objects (commonly referred to as \"local variables\") are destructed, in reverse order of their definition, when control flow leaves the scope of their definition.</p>\n", "LastActivityDate": "2012-12-21T11:14:42.767"}, "13989376": {"ParentId": "13988811", "CommentCount": "0", "CreationDate": "2012-12-21T11:32:44.237", "OwnerUserId": "1874016", "PostTypeId": "2", "Id": "13989376", "Score": "0", "Body": "<blockquote>\n<p id=\"so_13988811_13989376_0\"><strong>Further</strong>: Why it calls \"D x(5);\" earlier but the corresponding result\n  is given later?</p>\n</blockquote>\n<p>These objets are allocated on the <em>stack</em> (while <code>D * d1 = new D();</code> would allocate on the <em>heap</em>).</p>\n<p>It is not the call to <code>D x(5)</code> which gives output, but the call to the destructor <code>~D</code> occuring when the instance gets out of scope, in this case, when exiting <code>main()</code>. </p>\n<p>Because it's stack memory, the desallocations occur in reverse order to the allocation;</p>\n", "LastActivityDate": "2012-12-21T11:32:44.237"}, "13989012": {"ParentId": "13988811", "CommentCount": "0", "CreationDate": "2012-12-21T11:09:00.620", "OwnerUserId": "1865794", "PostTypeId": "2", "Id": "13989012", "Score": "3", "Body": "<p>The constructor and destructor calling sequence for a derived class is as follows:<br/></p>\n<pre><code>Base  Class  Constructor\nDerived  Class  Constructor\nDerived  Class  Destructor\nBase  Class  Destructor\n</code></pre>\n<p>As a derived class is built on top a base class:</p>\n<ul>\n<li> the base class has to be constructed before the derived class.\n<li> the derived class has to be destroyed before the base class.\n</li></li></ul>\n", "LastActivityDate": "2012-12-21T11:09:00.620"}, "13989125": {"ParentId": "13988811", "CommentCount": "0", "CreationDate": "2012-12-21T11:16:14.170", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "13989125", "Score": "3", "Body": "<p>The destructor calling sequence always goes from the derived to base, like popping the stack. This allows derived classes to clean up resources allocated by your base class. In this case, the compiler knows how to construct this sequence, because it knows the exact type of the objects <code>x</code> and <code>y</code> statically.</p>\n<p>There are situations, however, when this sequence would be broken. Consider the following modification of your code:</p>\n<pre><code>void test()\n{\n    C *x = new D(5);\n    D *y = new D(6,7);\n    delete x;\n    delete y;\n}\n</code></pre>\n<p>It produces the following output:</p>\n<pre><code>Destructor C!5\nDestructor D!7\nDestructor C!6\n</code></pre>\n<p>Running this produces no call of <code>~D</code> for <code>x</code>; for <code>y</code>, both destructors are called.</p>\n<p>This is because you did not declare the destructor <code>virtual</code> in the base class. When the destructor is not virtual, the compiler has no idea that it must call the destructor of the derived class in situations when an object is referred to by a pointer to a base class. This is why you should always make a destructor virtual in classes that must be inherited and allocate resources dynamically.</p>\n", "LastActivityDate": "2012-12-21T11:16:14.170"}, "13988866": {"ParentId": "13988811", "CommentCount": "0", "CreationDate": "2012-12-21T10:59:20.350", "OwnerUserId": "137369", "PostTypeId": "2", "Id": "13988866", "Score": "1", "Body": "<p>When an objected is cleaned up, first the destructor of the derived class is called, then the destructor of the base class.</p>\n", "LastActivityDate": "2012-12-21T10:59:20.350"}, "13989085": {"ParentId": "13988811", "CommentCount": "0", "CreationDate": "2012-12-21T11:13:42.453", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "13989085", "Score": "0", "Body": "<p>The destructor of <code>C</code> is called because destroying an object of a derived class includes destroying its base class subobject. As per [class.dtor] para 8:</p>\n<blockquote>\n<p id=\"so_13988811_13989085_0\">After executing the body of the destructor ... a destructor for class X calls ... the destructors for X's direct base classes ...</p>\n</blockquote>\n<p>When control flow exits a scope (such as your function <code>test()</code> ending), local objects are destroyed in LIFO manner: objects created first are destroyed last. As per [stmt.jump] para 2:</p>\n<blockquote>\n<p id=\"so_13988811_13989085_1\">On exit from a scope (however accomplished), objects with automatic storage duration (3.7.3) that have been constructed in that scope are destroyed in the reverse order of their construction.</p>\n</blockquote>\n", "LastActivityDate": "2012-12-21T11:13:42.453"}, "bq_ids": {"n4140": {"so_13988811_13989085_0": {"section_id": 404, "quality": 1.0, "length": 11}, "so_13988811_13989085_1": {"section_id": 3909, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_13988811_13989085_1": {"section_id": 3769, "quality": 0.9444444444444444, "length": 17}, "so_13988811_13989085_0": {"section_id": 395, "quality": 1.0, "length": 11}}, "n4659": {"so_13988811_13989085_1": {"section_id": 4795, "quality": 0.9444444444444444, "length": 17}, "so_13988811_13989085_0": {"section_id": 422, "quality": 1.0, "length": 11}}}, "13988926": {"ParentId": "13988811", "CommentCount": "0", "CreationDate": "2012-12-21T11:02:57.157", "OwnerUserId": "1173513", "PostTypeId": "2", "Id": "13988926", "Score": "1", "Body": "<p>When you inherit, you \"extend\" the object you inherit from. So if you want to build <code>D</code>, you need <code>C</code>. And when you need to destroy <code>D</code>, you will the destroy <code>C</code>, which you build to be able to extend it.</p>\n", "LastActivityDate": "2012-12-21T11:02:57.157"}});