post_cb({"3952020": {"ViewCount": "904", "Body": "<p>Is Demo a POD type in C++03?</p>\n<pre><code>struct Demo\n{\n     private:\n       int x;\n       int y;\n};\n</code></pre>\n<p>C++03, \u00a79p4:</p>\n<blockquote>\n<p id=\"so_3952020_3952020_0\">A POD-struct is an aggregate class that has no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or reference, and has no user-defined copy assignment operator and no user-defined destructor. </p>\n</blockquote>\n<p>After reading <a href=\"https://stackoverflow.com/q/146589/54262\">Steve Jessop's post</a>, I believe Demo is a non-POD because the members are private. However the Standard doesn't say anything about the relation between POD types and access modifiers.</p>\n<p>In C++0x Demo is POD because \u00a79p9 (n3126) says:</p>\n<blockquote>\n<p id=\"so_3952020_3952020_1\">A POD struct is a class that is <strong>both a trivial class and a standard-layout class</strong>, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). </p>\n</blockquote>\n<p>Demo is trivial<sup>1</sup> as well as a standard-layout class so it is a POD. Is my interpretation correct?</p>\n<p><sub><sup>1</sup> A trivial class is a class that has a trivial default constructor (12.1) and is trivially copyable. [9p5, n3126]</sub></p>\n", "AcceptedAnswerId": "3952053", "Title": "Plain Old Data types with private members?", "CreationDate": "2010-10-17T04:18:27.457", "Id": "3952020", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:18:38.473", "LastEditorDisplayName": "Roger Pate", "LastEditorUserId": "-1", "LastActivityDate": "2010-10-17T19:26:28.573", "Score": "4", "OwnerUserId": "165520", "Tags": "<c++><c++11><pod>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_3952020_3952053_0": {"length": 13, "quality": 0.6842105263157895, "section_id": 3298}, "so_3952020_3952020_0": {"length": 11, "quality": 0.5789473684210527, "section_id": 467}, "so_3952020_3952020_1": {"length": 19, "quality": 1.0, "section_id": 5854}}, "n3337": {"so_3952020_3952053_0": {"length": 13, "quality": 0.6842105263157895, "section_id": 3168}, "so_3952020_3952020_0": {"length": 11, "quality": 0.5789473684210527, "section_id": 458}, "so_3952020_3952020_1": {"length": 19, "quality": 1.0, "section_id": 5624}}, "n4659": {"so_3952020_3952020_0": {"length": 11, "quality": 0.5789473684210527, "section_id": 490}, "so_3952020_3952020_1": {"length": 19, "quality": 1.0, "section_id": 7333}}}, "3952053": {"Id": "3952053", "PostTypeId": "2", "Body": "<p>In C++03, it's definitely <em>not</em> a POD. According to \u00a79/4, \"A <em>POD-struct</em> is an aggregate class ...\", and according to \u00a78.5.1/1:</p>\n<blockquote>\n<p id=\"so_3952020_3952053_0\">An <em>aggregate</em> is an array or a class (clause 9) with no user-declared constructors (12.1), no private or protected non-static data members (clause 11), no base classes (clause 10), and no virtual functions (10.3).\"</p>\n</blockquote>\n<p>Under C++0x, at least as of N3090/3092, I believe it <em>is</em> a POD. These require only that all non-static members have the same access, not that the access is necessarily public. This is to fix a problem that I believe I was the first to point out -- in C++98/03, a vacuous access specifier leads to a problem:</p>\n<pre><code>struct x { \n    int a;\npublic:\n    int b;\npublic:\n   int c;\n};\n</code></pre>\n<p>This fits the requirements of a POD struct -- but the standard still gives permission for the relative positions of <code>b</code> and <code>c</code> to be swapped because of the intervening access specifier. As a result, being a POD struct doesn't provide the layout guarantees that were intended to ensure compatibility with C structs (for the obvious example).</p>\n", "LastActivityDate": "2010-10-17T04:32:54.393", "CommentCount": "8", "CreationDate": "2010-10-17T04:32:54.393", "ParentId": "3952020", "Score": "11", "OwnerUserId": "179910"}});