post_cb({"7617636": {"ParentId": "7191650", "CommentCount": "0", "Body": "<p>You are correct.</p>\n<p>You can infer from the <strong>\"compact\" (no padding) layout of C++ arrays</strong> that any object type such that an array of this type can be defined must have an alignment that is a divisor of its size.</p>\n<p>In particular, the alignment of such a type of size 1 must be 1.</p>\n<p>In particular, the alignment of <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> is 1.</p>\n<p>OTOH, you cannot infer anything about the alignment of an abstract class with this argument.</p>\n", "OwnerUserId": "963864", "PostTypeId": "2", "Id": "7617636", "Score": "1", "CreationDate": "2011-10-01T01:50:21.153", "LastActivityDate": "2011-10-01T01:50:21.153"}, "7191650": {"CommentCount": "13", "AcceptedAnswerId": "7617636", "CreationDate": "2011-08-25T13:56:56.603", "LastActivityDate": "2012-07-03T17:15:52.673", "PostTypeId": "1", "ViewCount": "948", "FavoriteCount": "0", "Title": "alignof(char) == 1?", "Id": "7191650", "Score": "6", "Body": "<p>sizeof(char) is always 1 and it seems to me that the alignment requirement of a type can never be larger than its size. Quoting from the upcoming C++11 standard (3.11):</p>\n<blockquote>\n<p id=\"so_7191650_7191650_0\">An aligment is an implementation-de\ufb01ned integer value representing\n  the number of bytes between successive addresses at which a given object can be allocated.</p>\n</blockquote>\n<p>So if the alignment of a type were greater than its size, it would not be possible to create arrays without empty space between consecutive elements.</p>\n<p>Is this interpretation correct and is thus alignof(char) == 1 always?</p>\n", "Tags": "<c++11>", "OwnerUserId": "453925", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_7191650_7191650_0": {"section_id": 7240, "quality": 0.8571428571428571, "length": 12}, "so_7191650_7236710_1": {"section_id": 6142, "quality": 1.0, "length": 36}}, "n3337": {"so_7191650_7191650_0": {"section_id": 6984, "quality": 0.8571428571428571, "length": 12}, "so_7191650_7236710_1": {"section_id": 5906, "quality": 1.0, "length": 36}}, "n4659": {"so_7191650_7191650_0": {"section_id": 8749, "quality": 0.8571428571428571, "length": 12}}}, "7236710": {"ParentId": "7191650", "PostTypeId": "2", "CommentCount": "16", "Body": "<p>I looked at the way C++11 defines pointer arithmetic and didn't see anything that would prevent a type's alignment from being larger than its size. The compiler would be responsible for making sure every element in the array was properly aligned (by inserting the right amount of padding) and for making sure that pointer arithmetic works properly. Basically, pointer arithmetic is not defined with reference to sizeof(*ptr) even though people usually talk about it as though it is.</p>\n<blockquote>\n<p id=\"so_7191650_7236710_0\"><strong>n3290 \u00a7 5.7 p5:</strong></p>\n<p id=\"so_7191650_7236710_1\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integral expression.</p>\n</blockquote>\n<p>edit:</p>\n<p>However, the <code>sizeof</code> operator is defined in terms of the offset between consecutive elements in an array, so <code>alignof(X)</code> can't be greater than <code>sizeof(X)</code> because that would mean an array of X contains objects at invalid alignments. At the same time, <code>sizeof(X)</code> doesn't necessarily represent the actual size of the object. E.g. an X member or base sub-object of another type may use less than <code>sizeof(X)</code> bytes to store, although I don't know of any implementation that actually uses that.</p>\n", "OwnerUserId": "365496", "LastEditorUserId": "365496", "LastEditDate": "2012-07-03T17:15:52.673", "Id": "7236710", "Score": "0", "CreationDate": "2011-08-29T22:25:57.607", "LastActivityDate": "2012-07-03T17:15:52.673"}});