post_cb({"5677188": {"ParentId": "5676835", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2011-04-15T13:04:48.730", "Score": "2", "LastEditorUserId": "576911", "LastEditDate": "2011-04-15T17:58:54.453", "Id": "5677188", "OwnerUserId": "576911", "Body": "<p>I would not trust this code.  I believe it is lacking proper memory barriers on all memory shared by the different threads, except for the two reference counts.</p>\n<p>This looks like a good application for <a href=\"http://home.roadrunner.com/~hinnant/mutexes/locking.html#Shared\" rel=\"nofollow\">shared_mutex</a> to me.</p>\n<p><strong>Edit:</strong></p>\n<p>20.7.2.2 [util.smartptr.shared]/p4 says:</p>\n<blockquote>\n<p id=\"so_5676835_5677188_0\">For purposes of determining the\n  presence of a data race, member\n  functions shall access and modify only\n  the shared_ptr and weak_ptr objects\n  themselves and not objects they refer\n  to.</p>\n</blockquote>\n<p>However, instead of using a shared_mutex, another option might be to use the API in 20.7.2.5 shared_ptr atomic access [util.smartptr.shared.atomic]:</p>\n<blockquote>\n<p id=\"so_5676835_5677188_1\">Concurrent access to a shared_ptr\n  object from multiple threads does not\n  introduce a data race if the access is\n  done exclusively via the functions in\n  this section and the instance is\n  passed as their first argument.</p>\n</blockquote>\n<pre><code>template&lt;class T&gt;\n    bool atomic_is_lock_free(const shared_ptr&lt;T&gt;* p);\ntemplate&lt;class T&gt;\n    shared_ptr&lt;T&gt; atomic_load(const shared_ptr&lt;T&gt;* p);\ntemplate&lt;class T&gt;\n    shared_ptr&lt;T&gt; atomic_load_explicit(const shared_ptr&lt;T&gt;* p, memory_order mo);\ntemplate&lt;class T&gt;\n    void atomic_store(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);\ntemplate&lt;class T&gt;\n    void atomic_store_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r, memory_order mo);\ntemplate&lt;class T&gt;\n    shared_ptr&lt;T&gt; atomic_exchange(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r);\ntemplate&lt;class T&gt;\n    shared_ptr&lt;T&gt;\n    atomic_exchange_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt; r, memory_order mo);\ntemplate&lt;class T&gt;\n    bool\n    atomic_compare_exchange_weak(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);\ntemplate&lt;class T&gt;\n    bool\n    atomic_compare_exchange_strong( shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v, shared_ptr&lt;T&gt; w);\ntemplate&lt;class T&gt;\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v,\n                                          shared_ptr&lt;T&gt; w, memory_order success,\n                                          memory_order failure);\ntemplate&lt;class T&gt;\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr&lt;T&gt;* p, shared_ptr&lt;T&gt;* v,\n                                            shared_ptr&lt;T&gt; w, memory_order success,\n                                            memory_order failure);\n</code></pre>\n<p>shared_mutex will be easier to get right.  But the atomic shared_ptr API may yield a higher performance solution.</p>\n<p><strong>Update:</strong></p>\n<p>Here is untested code for the shared_mutex solution (note shared_mutex is not std, but is 3rd party library):</p>\n<pre><code>struct STNGS\n{\n    int i;\n    vector&lt;double&gt; v;\n    ting::shared_mutex m;\n};\n\nSTNGS stngs;\n\nint myFunction() //called by multiple threads\n{\n    shared_lock&lt;shared_mutex&gt; _(stngs.m);\n    //do some stuff using stngs\n    return 0;\n}\n\nvoid updateSettings()\n{\n    unique_lock&lt;shared_mutex&gt; _(stngs.m);\n    //fill stngs\n}\n\nvoid initialize()\n{\n    //fill stngs\n}\n</code></pre>\n<p>Here is untested code which uses the atomic load/store functions for shared_ptr:</p>\n<pre><code>struct STNGS\n{\n    int i;\n    vector&lt;double&gt; v;\n};\n\nshared_ptr&lt;STNGS&gt; pStng;\n\nint myFunction() //called by multiple threads\n{\n    shared_ptr&lt;STNGS&gt; stngs = atomic_load(&amp;pStng);\n    //do some stuff using *stngs\n    return 0;\n}\n\nvoid updateSettings()\n{\n    shared_ptr&lt;STNGS&gt; newStng(new STNGS);\n    //fill *newStng\n    atomic_store(&amp;pStng, newStng);\n}\n\nvoid initialize()\n{\n    pStng.reset(new STNGS);\n    //fill *pStng\n}\n</code></pre>\n", "LastActivityDate": "2011-04-15T17:58:54.453"}, "5676835": {"CommentCount": "0", "ViewCount": "375", "PostTypeId": "1", "LastEditorUserId": "700825", "CreationDate": "2011-04-15T12:37:53.870", "LastActivityDate": "2011-04-15T18:35:55.143", "Title": "(Ab)using shared_ptr as a reference counter", "AcceptedAnswerId": "5677188", "LastEditDate": "2011-04-15T18:35:55.143", "Id": "5676835", "Score": "2", "Body": "<p>Recently i thought of a cunning plan(tm :P)) \nI have to update settings structure in my program(lets say every 15 seconds). Settings structure is used by multiple functions and every of those functions is called by multiple threads. \nSo I need a reference counter to know when it is safe to free the old settings struct. \nSo is this the correct way to do it?\nPlease don't respond that it is OK if you haven't read the code carefully, when it comes to shared pointers it's easy to make mistakes when doing abuses like this(trust me).\nEDIT:I forgott to mention important part. I think that this implementation prevents the ref counter dropping to 0, because I initialize it in updateSettings() and it doesn't drop until it is called again(and then myFucntion uses the other of the 2 settings in the memory).  </p>\n<pre><code>#include&lt;memory&gt;\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nstruct STNGS\n{\n    int i;\n    vector&lt;double&gt; v;\n};\nstatic int CUR_STNG=0;\nshared_ptr&lt;STNGS&gt; stngsArray[2];\nint myFunction() //called by multiple threads\n{\n    shared_ptr&lt;STNGS&gt; pStngs=stngsArray[CUR_STNG];\n    STNGS&amp; stngs=*pStngs;\n    //do some stuff using stngs\n\n}\n\nvoid updateSettings()\n{\n    auto newIndex=(CUR_STNG+1)%2;\n    stngsArray[newIndex].reset(new STNGS);\n    CUR_STNG=newIndex;\n}\nvoid initialize()\n{\n    auto newIndex=CUR_STNG;\n    stngsArray[newIndex].reset(new STNGS);\n    CUR_STNG=newIndex;\n}\nint main()\n{\n    initialize();\n    //launch bunch of threads that are calling myFunction\n    while(true)\n    {\n        //call updateSettings every 15 seconds\n    }\n}\n</code></pre>\n<p>EDIT:using feedback from the comments I updated the code:</p>\n<pre><code>#include&lt;memory&gt;\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nstatic const int N_STNG_SP=4;\nstatic int CUR_STNG=0;\nstruct STNGS\n{\n    int i;\n    vector&lt;double&gt; v;\n    STNGS()\n    {\n        for (int i=0;i&lt;10;++i)\n            v.push_back(42);\n    }\n};\nshared_ptr&lt;STNGS&gt; stngs[N_STNG_SP];\nint myFunction() //called by multiple threads\n{\n    shared_ptr&lt;STNGS&gt; pStngs=stngs[CUR_STNG];\n    STNGS&amp; stngs=*pStngs;\n    //do some stuff using stngs\n}\n\nvoid updateSettings()\n{\n    auto pStng=new STNGS;\n    //fill *pStng\n    int newVer=(CUR_STNG+1)%N_STNG_SP;\n    stngs[newVer].reset(pStng);\n    CUR_STNG=newVer;\n}\nvoid initialize()\n{\n    auto pStng=new STNGS;\n    //fill *pStng\n    int newVer=(CUR_STNG+1)%N_STNG_SP;\n    stngs[newVer].reset(pStng);\n    CUR_STNG=newVer;\n}\nint main()\n{\n    initialize();\n    //launch bunch of threads that are calling myFunction\n    while(true)\n    {\n        //call updateSettings every 15 seconds\n        updateSettings();\n    }\n}\n</code></pre>\n", "Tags": "<c++11><shared-ptr><refcounting>", "OwnerUserId": "700825", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_5676835_5677188_1": {"section_id": 4508, "quality": 1.0, "length": 21}, "so_5676835_5677188_0": {"section_id": 4377, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_5676835_5677188_1": {"section_id": 4339, "quality": 1.0, "length": 21}, "so_5676835_5677188_0": {"section_id": 4214, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_5676835_5677188_0": {"section_id": 5640, "quality": 0.9411764705882353, "length": 16}, "so_5676835_5677188_1": {"section_id": 5768, "quality": 1.0, "length": 21}}}});