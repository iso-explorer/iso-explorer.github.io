post_cb({"bq_ids": {"n4140": {"so_2488515_2488553_2": {"section_id": 5822, "quality": 0.6666666666666666, "length": 4}, "so_2488515_2488515_0": {"section_id": 6066, "quality": 0.8571428571428571, "length": 6}, "so_2488515_2488553_3": {"section_id": 5822, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_2488515_2488553_2": {"section_id": 5593, "quality": 0.6666666666666666, "length": 4}, "so_2488515_2488515_0": {"section_id": 5834, "quality": 0.8571428571428571, "length": 6}, "so_2488515_2488553_3": {"section_id": 5593, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_2488515_2488553_2": {"section_id": 7283, "quality": 0.6666666666666666, "length": 4}, "so_2488515_2488553_3": {"section_id": 7283, "quality": 0.5714285714285714, "length": 4}, "so_2488515_2488515_0": {"section_id": 7562, "quality": 0.8571428571428571, "length": 6}}}, "2488553": {"ParentId": "2488515", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2010-03-21T20:16:41.280", "Score": "12", "LastEditorUserId": "224671", "LastEditDate": "2010-03-21T20:25:43.027", "Id": "2488553", "OwnerUserId": "224671", "Body": "<p>From the C99 draft, at the index:</p>\n<blockquote>\n<p id=\"so_2488515_2488553_0\"><code>*</code> (indirection operator), 6.5.2.1, <strong>6.5.3.2</strong></p>\n<p id=\"so_2488515_2488553_1\"><code>&amp;</code> (address operator), 6.3.2.1, <strong>6.5.3.2</strong></p>\n</blockquote>\n<p>From the C++0x draft, at the index:</p>\n<blockquote>\n<p id=\"so_2488515_2488553_2\"><code>*</code>, <em>see</em> indirection operator, <em>see</em> multiplication operator</p>\n<p id=\"so_2488515_2488553_3\"><code>&amp;</code>, <em>see</em> address-of operator, <em>see</em> bitwise AND operator</p>\n</blockquote>\n<p>It's also referenced in 9.6/3 \"The address-of operator <code>&amp;</code> shall not be applied to a bit-field, so there are no pointers to bit-fields.\"</p>\n<p>(So, sorry, you still need to call <code>&amp;</code> \"address-of\" :p)</p>\n<p>Personally I don't care the actual name as long as other can understand what I'm saying. I just call <code>*</code> \"star\" and <code>&amp;</code> \"and\". :)</p>\n", "LastActivityDate": "2010-03-21T20:25:43.027"}, "2488515": {"CommentCount": "9", "CreationDate": "2010-03-21T20:05:53.173", "PostTypeId": "1", "AcceptedAnswerId": "2488553", "LastEditorUserId": "252000", "LastActivityDate": "2010-03-21T22:00:00.210", "LastEditDate": "2010-03-21T21:07:19.650", "ViewCount": "304", "FavoriteCount": "1", "Title": "Official names for pointer operators", "Id": "2488515", "Score": "5", "Body": "<p>What are the official names for the operators <code>*</code> and <code>&amp;</code> in the context of pointers? They seem to be frequently called <em>dereference operator</em> and <em>address-of operator</em> respectively, but unfortunately, the section on unary operators in the standard does not name them.</p>\n<p>I really don't want to name <code>&amp;</code> <em>address-of</em> anymore, because <code>&amp;</code> returns a pointer, not an address. (see below) The standard is very clear about this:</p>\n<blockquote>\n<p id=\"so_2488515_2488515_0\">The result of the unary <code>&amp;</code> operator is a <strong>pointer</strong> to its operand.</p>\n</blockquote>\n<p>Symmetry suggests to name <code>&amp;</code> <em>reference operator</em> which is a little unfortunate because of the collision with references in C++. The fact that <code>&amp;</code> returns a pointer suggests <em>pointer operator</em>. Are there any official sources that would confirm these (or other) namings?</p>\n<h2>pointers vs. addresses</h2>\n<p>A pointer is a language mechanism, while an address is an implementation detail. Addresses are untyped, while pointers aren't, except for <code>void*</code>. Kevlin Henney also distinguishes between pointers and addresses in an <a href=\"http://www.se-radio.net/transcript-91-kevlin-henney-c\" rel=\"nofollow noreferrer\">Interview</a>:</p>\n<blockquote>\n<p id=\"so_2488515_2488515_1\">C [...] allows us to abstract the specifics of the machine to the point that we are talking about pointers and not addresses. There is a whole load of pain that you no longer have to go through.</p>\n</blockquote>\n", "Tags": "<c++><pointers>", "OwnerUserId": "252000", "AnswerCount": "3"}, "2488549": {"ParentId": "2488515", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-03-21T20:16:22.747", "Score": "2", "LastEditorUserId": "170230", "LastEditDate": "2010-03-21T22:00:00.210", "Id": "2488549", "OwnerUserId": "170230", "Body": "<p>The official names are address-of (&amp;) (Found in 2.3.3. Pointers and Arrays) and dereference (or indirection operator) (*) (Found in 5.1.Pointers) operators.</p>\n<p>according to \"The C++ Programming Language\", Third Edition by Bjarne Stroustrup.</p>\n", "LastActivityDate": "2010-03-21T22:00:00.210"}, "2488580": {"ParentId": "2488515", "CommentCount": "5", "Body": "<p>Not true.</p>\n<p>&amp; does not return a pointer.</p>\n<p>A pointer is a <strong>variable</strong> of pointer type, that may be used to contain address. Pointer has an address of it's own, usually different from its value, which is the address it holds.</p>\n<p>As such, pointer is <strong>lvalue</strong>, and result of &amp;p is not.</p>\n<p>Example:</p>\n<pre><code>int *p, a, b;\n\np = &amp;b; // valid, p is a pointer\n&amp;a = &amp;b; // invalid, address is not a variable. lvalue required\n</code></pre>\n", "OwnerUserId": "73656", "PostTypeId": "2", "Id": "2488580", "Score": "-1", "CreationDate": "2010-03-21T20:24:13.107", "LastActivityDate": "2010-03-21T20:24:13.107"}});