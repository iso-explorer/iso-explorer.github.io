post_cb({"26616163": {"CommentCount": "0", "AcceptedAnswerId": "26616558", "CreationDate": "2014-10-28T18:46:13.743", "LastActivityDate": "2014-10-28T19:17:45.120", "PostTypeId": "1", "ViewCount": "397", "FavoriteCount": "1", "Title": "Scope of nested function declaration in C++", "Id": "26616163", "Score": "13", "Body": "<pre><code>namespace X {\n    void f();\n}\n\nvoid X::f() {\n    void g();\n    g();\n}\n</code></pre>\n<p>Have I declared <code>::g</code>, or <code>X::g</code>?</p>\n<p>clang 3.5 will compile and link this if I add a definition of <code>X::g</code>:</p>\n<pre><code>namespace X {\n    void f();\n}\n\nvoid X::f() {\n    void g();\n    g();\n}\n\nvoid X::g() { }\n</code></pre>\n<p>gcc 4.9.1 rejects the definition with the message:</p>\n<blockquote>\n<p id=\"so_26616163_26616163_0\">error: \u2018void X::g()\u2019 should have been declared inside \u2018X\u2019</p>\n</blockquote>\n<p>but if I define <code>g</code> in the global namespace instead, gcc seems to change it's mind and complain about the opposite:</p>\n<blockquote id=\"so_26616163_26616163_1\">\n<pre><code>Undefined symbols for architecture x86_64:\n  \"X::g()\", referenced from:\n      X::f()     in ccABCDEF.o\n</code></pre>\n</blockquote>\n<p>Because it is also illegal to declare <code>void ::g()</code> inside of <code>f</code>, it seems that it isn't possible to have a function-scope forward declaration of global function in a namespace function. Am I missing something? What exactly are the scoping rules here?</p>\n<p><sub>g++ (GCC) 4.9.1; Apple LLVM version 6.0 (clang-600.0.54) (based on LLVM 3.5svn)</sub></p>\n", "Tags": "<c++><c++11><namespaces><scope><language-lawyer>", "OwnerUserId": "839932", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26616163_26616558_0": {"section_id": 7139, "quality": 0.875, "length": 7}, "so_26616163_26616558_1": {"section_id": 7140, "quality": 1.0, "length": 27}}, "n3337": {"so_26616163_26616558_0": {"section_id": 6883, "quality": 0.875, "length": 7}, "so_26616163_26616558_1": {"section_id": 6884, "quality": 1.0, "length": 27}}, "n4659": {"so_26616163_26616558_0": {"section_id": 8640, "quality": 0.875, "length": 7}, "so_26616163_26616558_1": {"section_id": 8641, "quality": 1.0, "length": 27}}}, "26616558": {"ParentId": "26616163", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-10-28T19:08:23.520", "Score": "6", "LastEditorUserId": "3647361", "LastEditDate": "2014-10-28T19:17:45.120", "Id": "26616558", "OwnerUserId": "3647361", "Body": "<p>Function declarations at block scope have linkage. [basic.link]/6:</p>\n<blockquote>\n<p id=\"so_26616163_26616558_0\">The name of a function declared in block scope and [..] have linkage.</p>\n</blockquote>\n<p>But such block scope declarations with linkage do not introduce any names into enclosing namespaces. [basic.link]/7:</p>\n<blockquote>\n<p id=\"so_26616163_26616558_1\">When a block scope declaration of an entity with linkage is not found\n  to refer to some other declaration, then that entity is a member of\n  the innermost enclosing namespace. <strong>However such a declaration does not\n  introduce the member name in its namespace scope.</strong></p>\n</blockquote>\n<p>You have therefore neither declared <code>::g</code> nor <code>X::g</code>. Defining it via</p>\n<pre><code>void X::g() {}\n</code></pre>\n<p>is ill-formed.</p>\n", "LastActivityDate": "2014-10-28T19:17:45.120"}});