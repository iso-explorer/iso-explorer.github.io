post_cb({"12558065": {"CommentCount": "2", "ViewCount": "106", "CreationDate": "2012-09-24T02:14:19.960", "LastActivityDate": "2012-09-24T02:35:45.710", "Title": "Do function calls as another functions parameters follow any defined behaviour?", "AcceptedAnswerId": "12558121", "PostTypeId": "1", "Id": "12558065", "Score": "1", "Body": "<p>In C++11 is there any defined behaviour regarding the following? (i.e. does a = 1, 2 or is undefined)</p>\n<pre><code>void somefunc(int a, int b) {\n  std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl;\n}\n\nint i = 0;\nsomefunc(++i, ++i)\n</code></pre>\n<p>Or should I write:</p>\n<pre><code>int i = 0;\nint a = ++i;\nint b = ++i;\nsomefunc(a, b);\n</code></pre>\n<p>The reason I ask, is I'm parsing a file for options and in one circumstance I'd like to create a keyvalue pair. And have functions similar to the following:</p>\n<pre><code>std::string create_key(std::string &amp;source, size_t &amp;size, int &amp;index) {\n  std:: string key = \"\";\n  while(index &lt; size) {\n    // parse the string to create the key\n    ++index\n  }\n  return key;\n}\n\n// Value is an base class for a template class. Allowing me to store values \n// of different data types inside a container.\nValue* create_value(std::string &amp;source, size_t &amp;size, int &amp;index) {\n  Value* value = nullptr;\n  while(index &lt; size) {\n    // determine type and assign it to value\n    ++index;\n  }\n  return value;\n}\n\nstd::map&lt;std::string, Value*&gt; create_object(std::string &amp;source, size_t &amp;size, int &amp;index) {\n  std::map&lt;std::string, Value*&gt; object;\n  while(index &lt; size) {\n    // the line I think produces the same issue as my original example\n    object.insert(std::pair&lt;std::string, Value*&gt;(create_key(source, size, index), create_value(source, size, index)));\n    ++index;\n  }\n}\n</code></pre>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1691346", "AnswerCount": "2"}, "12558121": {"ParentId": "12558065", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2012-09-24T02:24:11.230", "Score": "4", "LastEditorUserId": "726361", "LastEditDate": "2012-09-24T02:33:25.327", "Id": "12558121", "OwnerUserId": "726361", "Body": "<p>Yes, because you are modifying a variable in a manner which is not sequenced with respect to another modification of the same variable. Note that the comma is not a comma operator, which would introduce sequencing and prevent UB; it just separates the function arguments.</p>\n<p>You cannot even do</p>\n<pre><code>somefunc(i, ++i)\n</code></pre>\n<p>without causing undefined behaviour. Modify the variable and then call the function (or vice versa if it's what you want) separately.</p>\n", "LastActivityDate": "2012-09-24T02:33:25.327"}, "12558136": {"ParentId": "12558065", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-09-24T02:28:12.157", "Score": "2", "LastEditorUserId": "14860", "LastEditDate": "2012-09-24T02:35:45.710", "Id": "12558136", "OwnerUserId": "14860", "Body": "<p>The order in which function arguments are evaluated is unspecified. <code>C++11 5.2.2.Function call para/4</code> states:</p>\n<blockquote>\n<p id=\"so_12558065_12558136_0\">When a function is called, each parameter shall be initialized with its corresponding\n  argument [Note: such initializations are <strong>indeterminately sequenced</strong> with respect to each other].</p>\n</blockquote>\n<p>You should use:</p>\n<pre><code>somefunc (i+1, i+2); i += 2;\n</code></pre>\n<p>and stop worrying about such things.</p>\n<p>This will work fine unless you're able to access <code>i</code> from elsewhere, in which case you have even <em>more</em> problems that should be fixed.</p>\n", "LastActivityDate": "2012-09-24T02:35:45.710"}, "bq_ids": {"n4140": {"so_12558065_12558136_0": {"section_id": 5991, "quality": 0.8823529411764706, "length": 15}}, "n3337": {"so_12558065_12558136_0": {"section_id": 5759, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_12558065_12558136_0": {"section_id": 7491, "quality": 0.5882352941176471, "length": 10}}}});