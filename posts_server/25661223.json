post_cb({"bq_ids": {"n4140": {"so_25661223_25661238_1": {"length": 28, "quality": 1.0, "section_id": 6169}}, "n3337": {"so_25661223_25661238_1": {"length": 28, "quality": 1.0, "section_id": 5930}}, "n4659": {"so_25661223_25661238_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 7667}}}, "25661223": {"ViewCount": "219", "Body": "<p>I'm using <code>std::find_if</code> and as the third argument I'd like to use a ternary within <code>std::bind2nd</code>:</p>\n<pre><code>std::bind2nd(foo ? std::greater&lt;K&gt;() : std::greater_equal&lt;K&gt;(), bar);\n</code></pre>\n<p>for some type <code>K</code>. <code>foo</code> is a <code>bool</code> flag. But this is not syntatically correct since <code>std::greater&lt;K&gt;()</code> and <code>std::greater_equal&lt;K&gt;()</code> are different types.</p>\n<p>Ideally I'd like to remove the ternary (since the above runs in a loop for various <code>bar</code>s) and have</p>\n<pre><code>auto predicate = foo ? std::greater&lt;K&gt;() : std::greater_equal&lt;K&gt;();\nstd::bind2nd(predicate, bar); /*this statement is in a loop*/\n</code></pre>\n<p>But this is not legal either as the type for <code>predicate</code> is not known at compile time. But <code>std::bind2nd</code> can take either type so my thinking is that there <em>could</em> be a way of achieving what I want. Is there?</p>\n", "AcceptedAnswerId": "25661238", "Title": "Using std::greater<K> and std::greater_equal<K> in a ternary", "CreationDate": "2014-09-04T08:56:55.280", "Id": "25661223", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-06-27T20:37:50.577", "Score": "1", "OwnerUserId": "3415258", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "25661253": {"Id": "25661253", "PostTypeId": "2", "Body": "<p>If you insist on using the ternary operator, you can cast one of the operand to the desired type (here we force a <code>std::function&lt;bool(const K&amp;, const K&amp;)&gt;</code>), which will also be the type deduced by <code>auto</code>:</p>\n<pre><code>auto predicate = foo ? std::greater&lt;K&gt;() : (std::function&lt;bool(const K&amp;, const K&amp;)&gt;) std::greater_equal&lt;K&gt;();   \n</code></pre>\n<p>And a lambda would also do it, possibly more readable (and without the need for <code>&lt;functional&gt;</code>) :</p>\n<pre><code>auto predicate = [&amp;](const K&amp; a) { return foo ? (a &gt; bar) : (a &gt;= bar); };\npredicate(val);\n</code></pre>\n<hr>\n<p><strong>Notes:</strong></p>\n<p><code>bind2nd</code> is <em>deprecated</em> in C++11, you should use <code>std::bind</code> instead :</p>\n<pre><code>std::bind(predicate, bar, std::placeholders::_1);\n</code></pre>\n</hr>", "LastEditorUserId": "3510483", "LastActivityDate": "2014-09-04T09:09:43.363", "Score": "2", "CreationDate": "2014-09-04T08:58:41.360", "ParentId": "25661223", "CommentCount": "3", "OwnerUserId": "3510483", "LastEditDate": "2014-09-04T09:09:43.363"}, "25661238": {"Id": "25661238", "PostTypeId": "2", "Body": "<p>Make the operands of the same type:</p>\n<pre><code>auto predicate = foo\n             ? std::function&lt;bool(K,K)&gt;(std::greater&lt;K&gt;())\n             : std::function&lt;bool(K,K)&gt;(std::greater_equal&lt;K&gt;());\n</code></pre>\n<p><a href=\"http://ideone.com/bENRRP\" rel=\"nofollow\"><strong>DEMO</strong></a></p>\n<p>Rationale:</p>\n<blockquote>\n<p id=\"so_25661223_25661238_0\"><strong>\u00a7 5.16 Conditional operator [expr.cond] / p3</strong></p>\n<p id=\"so_25661223_25661238_1\">[...] if the second and third operand <strong>have different types</strong> and either has (possibly cv-qualified) class\n  type, or if both are glvalues of the same value category and the same type except for cv-qualification, an\n  attempt is made to convert each of those operands to the type of the other.</p>\n</blockquote>\n<p>There is no conversion between <code>std::greater&lt;K&gt;()</code> and <code>std::greater_equal&lt;K&gt;()</code> that a compiler could perform on its own.</p>\n", "LastEditorUserId": "3953764", "LastActivityDate": "2015-06-27T20:37:50.577", "Score": "6", "CreationDate": "2014-09-04T08:57:37.707", "ParentId": "25661223", "CommentCount": "5", "OwnerUserId": "3953764", "LastEditDate": "2015-06-27T20:37:50.577"}, "25663552": {"Id": "25663552", "PostTypeId": "2", "Body": "<p>based on the accepted answer, but I'd invert the order of operations:</p>\n<pre><code>auto predicate = foo\n             ? std::function&lt;bool(K)&gt;(std::bind(std::greater&lt;K&gt;(), bar))\n             : std::function&lt;bool(K)&gt;(std::bind(std::greater_equal&lt;K&gt;(), bar));\n</code></pre>\n<p>Both <code>bind</code> and <code>function</code> have some type erasure overhead, and I suspect it's somewhat smaller in this order. That's because the result of <code>bind</code> is specified as something that can be stored in a <code>std::function</code>, but the other way around is more coincidental.</p>\n", "LastActivityDate": "2014-09-04T10:49:22.913", "CommentCount": "2", "CreationDate": "2014-09-04T10:49:22.913", "ParentId": "25661223", "Score": "0", "OwnerUserId": "15416"}});