post_cb({"22412696": {"ParentId": "22412150", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-03-14T18:10:16.023", "Score": "1", "LastEditorUserId": "241631", "LastEditDate": "2014-03-14T21:27:57.383", "Id": "22412696", "OwnerUserId": "241631", "Body": "<p>I'm assuming your question is about two keys that not only generate the same hash value, but also compare equal using the equality predicate supplied to the <code>unordered_multiset</code>. <a href=\"http://en.cppreference.com/w/cpp/container/unordered_multiset/find\" rel=\"nofollow\"><code>unordered_multiset::find</code></a> will only use the hash value to initially locate the bucket within which to search, but after that the search is done using the equality predicate.</p>\n<blockquote>\n<p id=\"so_22412150_22412696_0\"><em>\u00a723.2.5</em> <strong>[unord.req]</strong> Table 103 \u2014 Unordered associative container requirements</p>\n<p id=\"so_22412150_22412696_1\"><code>b.find(k)</code></p>\n<p id=\"so_22412150_22412696_2\">Returns an iterator pointing to an element with key equivalent to <code>k</code>,\n  or <code>b.end()</code> if no such element exists.</p>\n</blockquote>\n<p>No additional requirements for <code>find()</code> are placed upon the <code>unordered_multi*</code> containers. This means implementations are not required that <code>unordered_multiset::find</code> return an iterator to the first inserted element. But then again, if the two (or more) keys are truly equivalent, why would you care?</p>\n", "LastActivityDate": "2014-03-14T21:27:57.383"}, "22412150": {"CommentCount": "0", "ViewCount": "298", "CreationDate": "2014-03-14T17:42:44.540", "LastActivityDate": "2014-03-14T21:27:57.383", "Title": "Does std::unordered_multiset::find function return the first inserted element between two values with same hash value", "AcceptedAnswerId": "22412696", "PostTypeId": "1", "Id": "22412150", "Score": "1", "Body": "<p>Saying we have <code>std::unordered_multiset</code> with two values mapping the same hash value, is there any guarantees by the c++ standard that a find will return the first inserted element ?</p>\n", "Tags": "<c++><unordered-set><unordered-multiset>", "OwnerUserId": "619570", "AnswerCount": "2"}, "22412688": {"ParentId": "22412150", "CommentCount": "1", "CreationDate": "2014-03-14T18:09:43.593", "OwnerUserId": "2169853", "PostTypeId": "2", "Id": "22412688", "Score": "3", "Body": "<p>Interesting question. Haven't used unordered associative containers a lot, so I took the chance to search the standard. Here is my interpretation: 23.2.5.6 says</p>\n<blockquote>\n<p id=\"so_22412150_22412688_0\">\"In containers that support equivalent keys, elements with equivalent\n  keys are adjacent to each other in the iteration order of the\n  container. Thus, although the absolute order of elements in an\n  unordered container is not specified, its elements are grouped into\n  equivalent-key groups such that all elements of each group have\n  equivalent keys.\"</p>\n</blockquote>\n<p>But then continues with</p>\n<blockquote>\n<p id=\"so_22412150_22412688_1\">\"Mutating operations on unordered containers shall preserve the\n  relative order of elements within each equivalent-key group unless\n  otherwise specified.\"</p>\n</blockquote>\n<p>23.2.5.9 then states </p>\n<blockquote>\n<p id=\"so_22412150_22412688_2\">\"For unordered_multiset and unordered_multimap, rehashing preserves\n  the relative ordering of equivalent elements.\"</p>\n</blockquote>\n<p>So the order seems to be preserved, because insert does not say that it may change the order of equivalent keys. But then, find is specified as</p>\n<blockquote>\n<p id=\"so_22412150_22412688_3\">\"Returns an iterator pointing to an element with key equivalent to k,\n  or b.end() if no such element exists.\"</p>\n</blockquote>\n<p>So, it does not defined which element of the equivalent keys ones it returns. Strictly, this may return a random element with given key and still fulfill the specification. Given that equal_range is defined as</p>\n<blockquote>\n<p id=\"so_22412150_22412688_4\">Returns a range containing all elements with keys equivalent to k.</p>\n</blockquote>\n<p><code>*equal_range(k).first</code> could do the job and return the first element inserted with key k.</p>\n", "LastActivityDate": "2014-03-14T18:09:43.593"}, "bq_ids": {"n4140": {"so_22412150_22412688_2": {"section_id": 761, "quality": 0.8888888888888888, "length": 8}, "so_22412150_22412688_0": {"section_id": 758, "quality": 0.9714285714285714, "length": 34}, "so_22412150_22412688_1": {"section_id": 758, "quality": 1.0, "length": 14}, "so_22412150_22412696_2": {"section_id": 763, "quality": 1.0, "length": 10}, "so_22412150_22412688_3": {"section_id": 763, "quality": 1.0, "length": 10}, "so_22412150_22412688_4": {"section_id": 763, "quality": 1.0, "length": 7}}, "n3337": {"so_22412150_22412688_2": {"section_id": 748, "quality": 0.8888888888888888, "length": 8}, "so_22412150_22412688_0": {"section_id": 746, "quality": 0.9714285714285714, "length": 34}, "so_22412150_22412688_1": {"section_id": 746, "quality": 1.0, "length": 14}, "so_22412150_22412696_2": {"section_id": 750, "quality": 1.0, "length": 10}, "so_22412150_22412688_3": {"section_id": 750, "quality": 1.0, "length": 10}, "so_22412150_22412688_4": {"section_id": 750, "quality": 1.0, "length": 7}}, "n4659": {"so_22412150_22412688_2": {"section_id": 821, "quality": 0.8888888888888888, "length": 8}, "so_22412150_22412688_0": {"section_id": 818, "quality": 0.9428571428571428, "length": 33}, "so_22412150_22412688_1": {"section_id": 818, "quality": 1.0, "length": 14}, "so_22412150_22412696_2": {"section_id": 823, "quality": 1.0, "length": 10}, "so_22412150_22412688_3": {"section_id": 823, "quality": 1.0, "length": 10}, "so_22412150_22412688_4": {"section_id": 823, "quality": 1.0, "length": 7}}}});