post_cb({"13643102": {"ParentId": "13642381", "CommentCount": "0", "Body": "<p>Bytes are usually intended as unsigned 8 bit wide integers.</p>\n<p>Now, char doesn't specify the sign of the integer: on some compilers char could be signed, on other it may be unsigned.</p>\n<p>If I add a bit shift operation to the code you wrote, then I will have an undefined behaviour. The added comparison will also have an unexpected result. </p>\n<pre><code>char c[5], d[5];\nc[0] = 0xF0;\nc[1] = 0xA4;\nc[2] = 0xAD;\nc[3] = 0xA2;\nc[4] = '\\0';\nc[0] &gt;&gt;= 1; // If char is signed, will the 7th bit go to 0 or stay the same?\n\nbool isBiggerThan0 = c[0] &gt; 0; // FALSE if char is signed!\n\nprintf(\"%s\\n\", c);\nmemcpy(d, c, 5);\nprintf(\"%s\\n\", d);\n</code></pre>\n<p>Regarding the warning during the compilation: if the char is signed then you are trying to assign the value 0xf0, which cannot be represented in the signed char (range -128 to +127), so it will be casted to a signed value (-16). </p>\n<p>Declaring the char as signed will remove the warning, and is always good to have a clean build without any warning.</p>\n", "OwnerUserId": "147763", "PostTypeId": "2", "Id": "13643102", "Score": "5", "CreationDate": "2012-11-30T10:13:38.177", "LastActivityDate": "2012-11-30T10:13:38.177"}, "13642381": {"CommentCount": "10", "AcceptedAnswerId": "13642984", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-11-30T09:33:40.083", "LastActivityDate": "2016-06-08T15:09:38.317", "LastEditDate": "2017-05-23T12:32:01.897", "ViewCount": "18010", "FavoriteCount": "20", "Title": "C/C++ Why to use unsigned char for binary data?", "Id": "13642381", "Score": "44", "Body": "<p>Is it really necessary to use <code>unsigned char</code> to hold binary data as in some libraries which work on character encoding or binary buffers? To make sense of my question, have a look at the code below -</p>\n<pre><code>char c[5], d[5];\nc[0] = 0xF0;\nc[1] = 0xA4;\nc[2] = 0xAD;\nc[3] = 0xA2;\nc[4] = '\\0';\n\nprintf(\"%s\\n\", c);\nmemcpy(d, c, 5);\nprintf(\"%s\\n\", d);\n</code></pre>\n<p>both the <code>printf's</code> output <code></code> correctly, where <code>f0 a4 ad a2</code> is the encoding for the Unicode code-point <code>U+24B62 ()</code> in hex.</p>\n<p>Even <code>memcpy</code> also correctly copied the bits held by a char.</p>\n<p>What reasoning could possibly advocate the use of <code>unsigned char</code> instead of a <code>plain char</code>?</p>\n<p>In other related questions <code>unsigned char</code> is highlighted because it is the only (byte/smallest) data type which is guaranteed to have no padding by the C-specification. But as the above example showed, the output doesn't seem to be affected by any padding as such.</p>\n<p>I have used VC++ Express 2010 and MinGW to compile the above. Although VC gave the warning </p>\n<p><code>warning C4309: '=' : truncation of constant value</code></p>\n<p>the output doesn't seems to reflect that.</p>\n<p>P.S. This could be marked a possible duplicate of <a href=\"https://stackoverflow.com/questions/653336/should-a-buffer-of-bytes-be-signed-or-unsigned-char-buffer?rq=1\">Should a buffer of bytes be signed or unsigned char buffer?</a> but my intent is different. I am asking why something which seems to be working as fine with <code>char</code> should be typed <code>unsigned char</code>?</p>\n<p><strong>Update:</strong> To quote from N3337, </p>\n<p><code>Section 3.9 Types</code></p>\n<blockquote>\n<p id=\"so_13642381_13642381_0\">2 For any object (other than a base-class subobject) of trivially\n  copyable type T, whether or not the object holds a valid value of type\n  T, the underlying bytes (1.7) making up the object can be copied into\n  an array of char or unsigned char. If the content of the array of char\n  or unsigned char is copied back into the object, the object shall\n  subsequently hold its original value.</p>\n</blockquote>\n<p>In view of the above fact and that my original example was on Intel machine where <code>char</code> defaults to <code>signed char</code>, am still not convinced if <code>unsigned char</code> should be preferred over <code>char</code>.</p>\n<p>Anything else?</p>\n", "Tags": "<c++><c><character-encoding><bytebuffer><rawbytestring>", "OwnerUserId": "1363471", "AnswerCount": "8"}, "13642575": {"ParentId": "13642381", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_13642381_13642575_0\">I am asking why something which seems to be working as fine with char should be typed unsigned char?</p>\n</blockquote>\n<p>If you do things which are not \"correct\" in the sense of the standard, you rely on undefined behaviour. Your compiler might do it the way you want today, but you don't know what it does tomorrow. You don't know what GCC does or VC++ 2012. Or even if the behaviour depends on external factors or Debug/Release compiles etc. As soon as you leave the safe path of the standard, you might run into trouble.</p>\n", "OwnerUserId": "292233", "PostTypeId": "2", "Id": "13642575", "Score": "2", "CreationDate": "2012-11-30T09:44:47.953", "LastActivityDate": "2012-11-30T09:44:47.953"}, "13642984": {"ParentId": "13642381", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>In C the <code>unsigned char</code> data type is the only data type that has all the following three properties simultaneously </p>\n<ul>\n<li>it has no padding bits, that it where all storage bits contribute to the value of the data</li>\n<li>no bitwise operation starting from a value of that type, when converted back into that type, can produce overflow, trap representations or undefined behavior</li>\n<li>it may alias other data types without violating the \"aliasing rules\", that is that access to the same data through a pointer that is typed differently will be guaranteed to see all modifications</li>\n</ul>\n<p>if these are the properties of a \"binary\" data type you are looking for, you definitively should use <code>unsigned char</code>.</p>\n<p>For the second property we need a type that is <code>unsigned</code>. For these all conversion are defined with modulo arihmetic, here modulo <code>UCHAR_MAX+1</code>, <code>256</code> in most 99% of the architectures. All conversion of wider values to <code>unsigned char</code> thereby just corresponds to truncation to the least significant byte.</p>\n<p>The two other character types generally don't work the same. <code>signed char</code> is signed, anyhow, so conversion of values that don't fit it is not well defined. <code>char</code> is not fixed to be signed or unsigned, but on a particular platform to which your code is ported it might be signed even it is unsigned on yours.</p>\n", "OwnerUserId": "366377", "LastEditorUserId": "366377", "LastEditDate": "2016-06-08T15:09:38.317", "Id": "13642984", "Score": "74", "CreationDate": "2012-11-30T10:06:26.977", "LastActivityDate": "2016-06-08T15:09:38.317"}, "13642586": {"ParentId": "13642381", "CommentCount": "1", "Body": "<p>The signed-ness of the plain <code>char</code> type is implementation defined, so unless you're actually dealing with character data (a string using the platform's character set - usually ASCII), it's usually better to specify the signed-ness explicitly by either using <code>signed char</code> or <code>unsigned char</code>.</p>\n<p>For binary data, the best choice is most probably <code>unsigned char</code>, especially if bitwise operations will be performed on the data (specifically bit shifting, which doesn't behave the same for signed types as for unsigned types).</p>\n", "OwnerUserId": "822669", "PostTypeId": "2", "Id": "13642586", "Score": "4", "CreationDate": "2012-11-30T09:45:34.820", "LastActivityDate": "2012-11-30T09:45:34.820"}, "13643830": {"ParentId": "13642381", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_13642381_13643830_0\">Is it really necessary to use unsigned char to hold binary data as in some libraries which work on character encoding or binary buffers?</p>\n</blockquote>\n<p>\"really\" necessary? No.</p>\n<p>It is a very good idea though, and there are many reasons for this.</p>\n<p>Your example uses printf, which not type-safe. That is, printf takes it's formatting cues from the format string and not from the data type. You could just as easily tried:</p>\n<pre><code>printf(\"%s\\n\", (void*)c);\n</code></pre>\n<p>... and the result would have been the same. If you try the same thing with c++ iostreams, the result will be different (depending on the signed-ness of c).</p>\n<blockquote>\n<p id=\"so_13642381_13643830_1\">What reasoning could possibly advocate the use of unsigned char instead of a plain char?</p>\n</blockquote>\n<p>Unsigned specifies that the most significant bit of the data (for unsigned char the 8-th bit) represents the sign. Since you obviously do not need that, you should specify your data is unsigned (the \"sign\" bit represents data, not the sign of the other bits).</p>\n", "OwnerUserId": "186997", "PostTypeId": "2", "Id": "13643830", "Score": "2", "CreationDate": "2012-11-30T10:57:20.550", "LastActivityDate": "2012-11-30T10:57:20.550"}, "13643658": {"ParentId": "13642381", "CommentCount": "0", "Body": "<p>You'll get most of your problems when comparing the contents of individual bytes:</p>\n<pre><code>char c[5];\nc[0] = 0xff;\n/*blah blah*/\nif (c[0] == 0xff)\n{\n    printf(\"good\\n\");\n}\nelse\n{\n    printf(\"bad\\n\");\n}\n</code></pre>\n<p>can print \"bad\", because, depending on your compiler, c[0] will be sign extended to -1, which is not any way the same as 0xff</p>\n", "OwnerUserId": "1182921", "PostTypeId": "2", "Id": "13643658", "Score": "12", "CreationDate": "2012-11-30T10:46:50.397", "LastActivityDate": "2012-11-30T10:46:50.397"}, "13642594": {"ParentId": "13642381", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The plain <code>char</code> type is problematic and shouldn't be used for anything but strings. The main problem with <code>char</code> is that you can't know whether it is signed or unsigned: this is implementation-defined behavior. This makes <code>char</code> different from <code>int</code> etc, <code>int</code> is always guaranteed to be signed.</p>\n<blockquote>\n<p id=\"so_13642381_13642594_0\">Although VC gave the warning ... truncation of constant value</p>\n</blockquote>\n<p>It is telling you that you are trying to store int literals inside char variables. This might be related to the signedness: if you try to store an integer with value &gt; 0x7F inside a signed character, unexpected things might happen. Formally, this is undefined behavior in C, though practically you'd just get a weird output if attempting to print the result as an integer value stored inside a (signed) char.</p>\n<p>In this specific case, the warning shouldn't matter.</p>\n<p><strong>EDIT :</strong></p>\n<blockquote>\n<p id=\"so_13642381_13642594_1\">In other related questions unsigned char is highlighted because it is the only (byte/smallest) data type which is guaranteed to have no padding by the C-specification. </p>\n</blockquote>\n<p>In theory, all integer types except unsigned char and signed char are allowed to contain \"padding bits\", as per C11 6.2.6.2:</p>\n<blockquote>\n<p id=\"so_13642381_13642594_2\">\"For unsigned integer types other than unsigned char, the bits of the\n  object representation shall be divided into two groups: value bits and\n  padding bits  (there need not be any of the latter).\"</p>\n<p id=\"so_13642381_13642594_3\">\"For signed integer types, the bits of the object representation shall\n  be divided  into three groups: value bits, padding bits, and the sign\n  bit.  There need not be any padding bits;  signed char shall not have\n  any padding bits.\"</p>\n</blockquote>\n<p>The C standard is intentionally vague and fuzzy, allowing these theoretical padding bits because:</p>\n<ul>\n<li>It allows different symbol tables than the standard 8-bit ones.</li>\n<li>It allows implementation-defined signedness and weird signed integer formats such as one's complement or \"sign and magnitude\".</li>\n<li>An integer may not necessarily use all bits allocated.</li>\n</ul>\n<p>However, in the real world outside the C standard, the following applies:</p>\n<ul>\n<li>Symbol tables are almost certainly 8 bits (UTF8 or ASCII). Some weird exceptions exist, but clean implementations use the standard type <strong>wchar_t</strong> when implementing symbols tables larger than 8 bits.</li>\n<li>Signedness is always two's complement.</li>\n<li>An integer always uses all bits allocated.</li>\n</ul>\n<p>So there is no real reason to use unsigned char or signed char just to dodge some theoretical scenario in the C standard.</p>\n", "OwnerUserId": "584518", "LastEditorUserId": "584518", "LastEditDate": "2012-11-30T10:06:58.653", "Id": "13642594", "Score": "12", "CreationDate": "2012-11-30T09:46:18.090", "LastActivityDate": "2012-11-30T10:06:58.653"}, "13642597": {"ParentId": "13642381", "CommentCount": "0", "Body": "<p>Well, what do you call \"binary data\"? This is a bunch of bits, without any meaning assigned to them by that specific part of software that calls them \"binary data\". What's the closest primitive data type, which conveys the idea of the lack of any specific meaning to any one of these bits? I think <code>unsigned char</code>.</p>\n", "OwnerUserId": "390807", "PostTypeId": "2", "Id": "13642597", "Score": "2", "CreationDate": "2012-11-30T09:46:20.683", "LastActivityDate": "2012-11-30T09:46:20.683"}, "bq_ids": {"n4140": {"so_13642381_13642381_0": {"section_id": 7200, "quality": 0.975609756097561, "length": 40}}, "n3337": {"so_13642381_13642381_0": {"section_id": 6944, "quality": 0.975609756097561, "length": 40}}, "n4659": {"so_13642381_13642381_0": {"section_id": 8709, "quality": 0.9024390243902439, "length": 37}}}});