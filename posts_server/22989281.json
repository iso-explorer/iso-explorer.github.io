post_cb({"22989829": {"ParentId": "22989281", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>No, I don't think it's okay:</p>\n<blockquote>\n<p id=\"so_22989281_22989829_0\"><code>[C++11: 14/6]:</code> A function template, member function of a class template, or static data member of a class template shall be defined in every translation unit in which it is implicitly instantiated (14.7.1) unless the corresponding specialization is explicitly instantiated (14.7.2) in some translation unit; no diagnostic is required.</p>\n<p id=\"so_22989281_22989829_1\"><code>[C++11: 14.7.3/6]:</code> If a template, a member template or a member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required. <em>[..]</em></p>\n</blockquote>\n<p>Frankly I can't explain why it works for you.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2014-04-10T13:51:15.950", "Id": "22989829", "Score": "3", "CreationDate": "2014-04-10T13:43:22.783", "LastActivityDate": "2014-04-10T13:51:15.950"}, "22991779": {"CommentCount": "0", "CreationDate": "2014-04-10T15:00:47.987", "CommunityOwnedDate": "2014-04-10T15:00:47.987", "LastEditorUserId": "-1", "LastActivityDate": "2014-04-10T17:15:28.623", "ParentId": "22989281", "PostTypeId": "2", "LastEditDate": "2017-05-23T11:57:38.483", "Id": "22991779", "Score": "2", "Body": "<p>I think that your original code was incorrect and your \"workaround\" is not standard-compliant, too (despite the fact that your compiler and linker process it). Good quotes from the standard were cited in the <a href=\"https://stackoverflow.com/questions/22989281/is-it-safe-to-place-definition-of-specialization-of-template-member-function-wi/22989829#22989829\">answer</a> of <a href=\"https://stackoverflow.com/users/560648/lightness-races-in-orbit\"><strong>@Lightness Races in Orbit</strong></a>. See also the following example from the standard ([temp.expl.spec] 14.7.3/6):</p>\n<pre><code>class String { };\ntemplate&lt;class T&gt; class Array { /* ... */ };\ntemplate&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v) { /* ... */ }\n\nvoid f(Array&lt;String&gt;&amp; v) {\n  sort(v);          // use primary template\n                    // sort(Array&lt;T&gt;&amp;), T is String\n}\n\ntemplate&lt;&gt; void sort&lt;String&gt;(Array&lt;String&gt;&amp; v); // error: specialization\n                                                // after use of primary template\ntemplate&lt;&gt; void sort&lt;&gt;(Array&lt;char*&gt;&amp; v);        // OK: sort&lt;char*&gt; not yet used\n</code></pre>\n<p>I marked my answer as community wiki because in fact it is only a big comment.</p>\n", "OwnerUserId": "3043539"}, "23430228": {"ParentId": "22989281", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><a href=\"https://stackoverflow.com/a/22989829/147192\">Lightness Races in Orbit</a> cited <em>why it's not compliant</em> parts from the Standard. There might be some others, in the vicinity.</p>\n<p>I will try to explain in simpler terms what the Standard verbiage means, and hopefully I'll get it correctly, and finally explain the linker errors (or absence of error):</p>\n<ol>\n<li>What is the point of instantiation ?</li>\n<li>How does the compiler select a specialization ?</li>\n<li>What is necessary at the point of instantiation ?</li>\n<li>Why a linker error ?</li>\n</ol>\n<hr>\n<p><strong>1/ What is the point of instantiation ?</strong></p>\n<p>The point of instantiation of a template function is the point where it is called or referred to (<code>&amp;std::sort&lt;Iterator&gt;</code>) with <em>all</em> the template parameters fleshed out (*).</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(T) { std::cout &lt;&lt; typeid(T).name() &lt;&lt; \"\\n\"; }\n\nint main() { foo(1); } // point of instantiation of \"foo&lt;int&gt;(int)\"\n</code></pre>\n<p>It can be delayed though, and thus not match the exact call site, for templates called from other templates:</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(T) { std::cout &lt;&lt; typeid(T).name() &lt;&lt; \"\\n\"; }\n\ntemplate &lt;typename T&gt;\nvoid bar(T t) { foo(t); } // not a point of instantiation, T is still \"abstract\"\n\nint main() { foo(1); } // point of instantiation of \"bar&lt;int&gt;(int)\"\n                       // and ALSO of \"foo&lt;int&gt;(int)\"\n</code></pre>\n<p>This delay is very important as it enables writing:</p>\n<ul>\n<li>co-recursive templates (ie, templates that refer to each-others)</li>\n<li>user-specializations</li>\n</ul>\n<p>(*) Roughly speaking, there are exceptions such as non-template methods of a template class...</p>\n<hr>\n<p><strong>2/ How does the compiler select a specialization ?</strong></p>\n<p>At the point of instantiation, a compiler need to be able to:</p>\n<ul>\n<li>decide which <em>base template</em> function to call</li>\n<li>and possibly, which of its specializations to call</li>\n</ul>\n<p>This old <a href=\"http://www.gotw.ca/gotw/049.htm\" rel=\"nofollow noreferrer\">GotW</a> shows off the woes of specializations... but in short:</p>\n<pre><code>template &lt;typename T&gt; void foo(T);   // 1\ntemplate &lt;typename T&gt; void foo(T*);  // 2\n</code></pre>\n<p>are <strong>overloads</strong>, and each spawns a distinct <em>family</em> of possible specializations of which they are the <em>base</em>.</p>\n<pre><code>template &lt;&gt; void foo&lt;int&gt;(int);\n</code></pre>\n<p>is a specialization of 1, and</p>\n<pre><code>template &lt;&gt; void foo&lt;int*&gt;(int*);\n</code></pre>\n<p>is a specialization of 2.</p>\n<p>In order to resolve the function call, the compiler will first pick the best overload, <em>while ignoring template specializations</em>, and then, if it picked a template function, check if it has any specialization that could better apply.</p>\n<hr>\n<p><strong>3/ What is necessary at the point of instantiation ?</strong></p>\n<p>So, from the way a compiler resolve the call, we understand <em>why</em> the Standard specifies that any specialization should be declared <em>before</em> its first point of instantiation. Otherwise, it simply would not be considered.</p>\n<p>Thus, at the point of instantiation, one needs to have already seen:</p>\n<ul>\n<li>a declaration of the base template function to be used</li>\n<li>a declaration of the specialization to be selected, if any</li>\n</ul>\n<p>But what of the definition ?</p>\n<p>It is not needed. The compiler assumes it will either be provided later on in the TU or by another TU entirely.</p>\n<p><em>Note: it does burden the compiler because it means it needs to remember all the implicit instantiations it encountered and for which it could not emit a function-body so that when it finally encounters the definition it can (at last) emit all the necessary code fo all the specializations it encountered. I wonder why this particular approach was selected, and also wonder why even in the absence of an <code>extern</code> declaration the TU may end with undefined function-bodies.</em></p>\n<hr>\n<p><strong>4/ Why a linker error ?</strong></p>\n<p>Since no definition is provided, gcc trusts you to provide it later and simply emits a call to an unresolved symbol. If you happen to link with another TU that provides this symbol, then everything will be fine, and otherwise you'll get a linker error.</p>\n<p>Since gcc follows the <a href=\"http://refspecs.linuxbase.org/cxxabi-1.83.html\" rel=\"nofollow noreferrer\">Itanium ABI</a> we can simply look up how it mangles the symbols. It turns out that the ABI makes no difference in mangling specializations and implicit instantiations thus</p>\n<pre><code>cls.f( asd );\n</code></pre>\n<p>calls <code>_ZN3cls1fIPKcEEvT_</code> (which demangles as <code>void cls::f&lt;char const*&gt;(char const*)</code>) and the specialization:</p>\n<pre><code>template&lt;&gt;\nvoid cls::f( const char* )\n{\n}\n</code></pre>\n<p>also produces <code>_ZN3cls1fIPKcEEvT_</code>.</p>\n<p><em>Note: it is not clear to me whether an explicit specialization could have been given a different mangling.</em></p>\n</hr></hr></hr></hr>", "OwnerUserId": "147192", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:11:14.460", "Id": "23430228", "Score": "4", "CreationDate": "2014-05-02T14:12:43.790", "LastActivityDate": "2014-05-02T14:12:43.790"}, "bq_ids": {"n4140": {"so_22989281_22989829_1": {"section_id": 268, "quality": 0.9354838709677419, "length": 29}, "so_22989281_22989829_0": {"section_id": 53, "quality": 0.8666666666666667, "length": 26}}, "n3337": {"so_22989281_22989829_1": {"section_id": 259, "quality": 0.9354838709677419, "length": 29}, "so_22989281_22989829_0": {"section_id": 48, "quality": 0.8666666666666667, "length": 26}}, "n4659": {"so_22989281_22989829_1": {"section_id": 275, "quality": 0.9354838709677419, "length": 29}, "so_22989281_22989829_0": {"section_id": 55, "quality": 0.8666666666666667, "length": 26}}}, "22989281": {"CommentCount": "6", "AcceptedAnswerId": "23430228", "PostTypeId": "1", "LastEditorUserId": "435800", "CreationDate": "2014-04-10T13:20:15.207", "LastActivityDate": "2014-05-02T14:12:43.790", "LastEditDate": "2014-04-29T07:09:23.800", "ViewCount": "245", "FavoriteCount": "1", "Title": "Is it safe to place definition of specialization of template member function (withOUT default body) in source file?", "Id": "22989281", "Score": "8", "Body": "<p>Here's what I mean:</p>\n<pre><code>// test.h\nclass cls\n{\npublic:\n    template&lt; typename T &gt;\n    void f( T t );\n};\n</code></pre>\n<p>-</p>\n<pre><code>// test.cpp\ntemplate&lt;&gt;\nvoid cls::f( const char* )\n{\n}\n</code></pre>\n<p>-</p>\n<pre><code>// main.cpp\nint main()\n{\n    cls c;\n\n    double x = .0;\n    c.f( x ); // gives EXPECTED undefined reference (linker error)\n\n    const char* asd = \"ads\";\n    c.f( asd ); // works as expected, NO errors\n\n    return 0;\n}\n</code></pre>\n<p>This is completely fine, right?</p>\n<p>I started doubting this, because I just ran over the <code>specialization of '...' after instantiation</code> error, which was new to me. So, I \"worked around\" this error and everything seems to work fine now, but still.. </p>\n<p>Is this well-defined behavior?</p>\n<hr>\n<p><strong>edit:</strong> And the same for non-member template functions (forward declared non-member template functions).</p>\n</hr>", "Tags": "<c++><templates><template-specialization><member-functions><default-implementation>", "OwnerUserId": "435800", "AnswerCount": "3"}});