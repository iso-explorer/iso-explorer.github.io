post_cb({"25988410": {"ParentId": "25968047", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-09-23T06:35:48.607", "Score": "3", "LastEditorUserId": "2889431", "LastEditDate": "2014-09-23T18:58:51.740", "Id": "25988410", "OwnerUserId": "2889431", "Body": "<p>The division is indeed not an integer division. Most functions in OpenCV convert their input to Scalar, which is container for 1, 2, 3, or 4 doubles. And other functions in OpenCV that perform similar operations (scaleAdd, addWeighted, convertTo, etc...) all works with doubles as well. In other words, your code performing division by double and rounding of the result. This is why you got 44 instead of 43.</p>\n<p><strong>Edit:</strong></p>\n<p>As for the \"encode\" function you don't need to perform complex operations. The bytes for your new matrix are already there. You just need to create convenient way of accessing them:</p>\n<pre><code>Mat temp(src.size(), CV_8UC4, src.data);\n</code></pre>\n<p>This will create new matrix header (i.e. no copy of data) that point to the data of src. But instead of seeing the data as integer matrix with single channel, it will be 4-channel matrix of unsigned char (with same width and height). Than you can do anything with multi-channel matrix: split(), merge(), mixChannels(), etc...</p>\n", "LastActivityDate": "2014-09-23T18:58:51.740"}, "25968224": {"ParentId": "25968047", "CommentCount": "1", "CreationDate": "2014-09-22T06:57:59.023", "OwnerUserId": "3903983", "PostTypeId": "2", "Id": "25968224", "Score": "2", "Body": "<p>No, you're right, integer division is performed by flooring in C++. See <em>[expr.mul]</em>:</p>\n<blockquote>\n<p id=\"so_25968047_25968224_0\">For integral operands the / operator yields the algebraic quotient with any fractional part discarded; 81</p>\n<p id=\"so_25968047_25968224_1\">81) This is often called truncation towards zero.</p>\n</blockquote>\n", "LastActivityDate": "2014-09-22T06:57:59.023"}, "33994686": {"ParentId": "25968047", "CommentCount": "0", "CreationDate": "2015-11-30T08:56:10.810", "OwnerUserId": "2611477", "PostTypeId": "2", "Id": "33994686", "Score": "0", "Body": "<p>Here is a hand-made function to perform integer division on OpenCV, based on your ideas.\nHope it's helpful.</p>\n<pre><code>#include \"opencv2\\highgui.hpp\"\nusing cv::Mat;\n#include \"opencv2\\imgproc.hpp\"\nusing cv::threshold;\nvoid IntegerDivide(Mat&amp; Input_Dividendo, int Input_Divisor, Mat&amp; Output_Cociente, Mat&amp; Output_Resto)\n{\n    // Input_Dividendo is supposed to be CV_32S\n    // Input_Dividendo = Input_Divisor * Output_Cociente + Output_Resto\n\n    Mat candidato_Cociente=Input_Dividendo/Input_Divisor;\n    Mat offset=Input_Dividendo-(candidato_Cociente*Input_Divisor);\n    Mat error_en_candidato_Cociente;\n\n    // Threshold\n    // threshold( offset, error_en_candidato_Cociente, 0, 1,CV_THRESH_BINARY_INV);\n    Mat aux_src;\n    offset.convertTo(aux_src,CV_32F);\n    Mat aux_dst;\n    threshold( aux_src, aux_dst, 0, 1,CV_THRESH_BINARY_INV);\n    aux_dst.convertTo(error_en_candidato_Cociente,CV_32S);  \n    // End threshold\n\n    Output_Cociente=candidato_Cociente-error_en_candidato_Cociente;\n\n    Output_Resto=Input_Dividendo-(Output_Cociente*Input_Divisor);\n}\n</code></pre>\n", "LastActivityDate": "2015-11-30T08:56:10.810"}, "bq_ids": {"n4140": {"so_25968047_25968224_0": {"section_id": 6137, "quality": 0.9, "length": 9}, "so_25968047_25968224_1": {"section_id": 6137, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_25968047_25968224_0": {"section_id": 5901, "quality": 0.9, "length": 9}, "so_25968047_25968224_1": {"section_id": 5901, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_25968047_25968224_0": {"section_id": 7634, "quality": 0.9, "length": 9}, "so_25968047_25968224_1": {"section_id": 7634, "quality": 0.8333333333333334, "length": 5}}}, "25968047": {"CommentCount": "3", "AcceptedAnswerId": "25988410", "PostTypeId": "1", "LastEditorUserId": "871985", "CreationDate": "2014-09-22T06:44:35.140", "LastActivityDate": "2015-11-30T08:56:10.810", "LastEditDate": "2014-09-22T06:58:46.693", "ViewCount": "790", "FavoriteCount": "1", "Title": "OpenCV Integer division in c++ not as expected", "Id": "25968047", "Score": "5", "Body": "<p>Given the following output:</p>\n<p>[11233, 11345, 11434, 10897]\n[44, 44, 45, 43]\n[-31, 81, -86, -111]</p>\n<p>from this code</p>\n<pre><code>std::cout &lt;&lt; mat32sc1;\nchannels[1] = mat32sc1 / 256;\nchannels[0] = mat32sc1 - channels[1] * 256;\nstd::cout &lt;&lt; channels[1];\nstd::cout &lt;&lt; channels[0];\n</code></pre>\n<p>I would have expected 11233 / 256 to be 43, using integer division?</p>\n<p>Is my assumption wronge that c++ always do integer division by flooring?</p>\n<h3>Update</h3>\n<p>Here is my current encoding function.</p>\n<pre><code>void encode(cv::Mat &amp; src, cv::Mat &amp; dst)\n{\n    cv::Mat_&lt;int&gt; mat32sc1;\n    src.convertTo(mat32sc1, CV_32SC1, 10, 11000);\n\n    std::vector&lt;cv::Mat&gt; channels;\n    channels.resize(3);\n\n//  bitwise_and(mat32sc1, cv::Scalar(255), channels[0]); // is this needed or will converTo truncate automaticly.\n//  channels[0].convertTo(channels[0], CV_8UC1);\n//  mat32sc1.convertTo(channels[1], CV_8UC1, 1.0 / (1 &lt;&lt; 8));\n    channels[2] = cv::Mat::zeros(src.rows, src.cols, CV_8UC1);\n    int flag = 256;\n//  std::cout &lt;&lt; mat32sc1;\n    channels[1] = mat32sc1 / flag;\n    channels[0] = mat32sc1 - channels[1] * flag;\n    cv::Mat_&lt;int&gt; off = (channels[0] &lt; 0) / 255;\n    //std::cout &lt;&lt; off;\n    channels[1] -= off;\n    channels[0] = mat32sc1 - channels[1] * flag;\n\n\n    //std::cout &lt;&lt; channels[1];\n    //std::cout &lt;&lt; channels[0];\n    channels[0].convertTo(channels[0], CV_8UC1);\n    channels[1].convertTo(channels[1], CV_8UC1);\n\n    cv::merge(channels, dst);\n}\n</code></pre>\n<p>Any smarter way to get the same result</p>\n", "Tags": "<c++><opencv>", "OwnerUserId": "871985", "AnswerCount": "3"}});