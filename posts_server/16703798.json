post_cb({"16703973": {"ParentId": "16703798", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Deleted move members are evil.  They are not outlawed, because some day, someone will find a clever use for them.  But I haven't seen a good use yet.</p>\n<p>Deleting a special member is not the same thing as not having a special member.  Nowhere is this more obvious than with the move constructor and move assignment operator.</p>\n<p>When present, whether deleted, defaulted, or user-defined, the move constructor and the move assignment operator participate in overload resolution.  That means that they \"compete\" with the special copy members.  The copy members will typically favor const lvalues, whereas the move members attract rvalues.</p>\n<p>When returning a local type from a function (when the local type is the same un-cv-qualified type as the return type), the return statement first considers the return expression as an rvalue, and only if it can't find a suitable constructor, will it then be considered as an lvalue.  I.e. matching the proper constructor for returning a local object from a function is a 2-phase operation.</p>\n<p>When you don't have a move constructor at all (not even deleted), but you do have a normal copy constructor (takes a const &amp;), then the rvalue from the return statement will match the copy constructor.</p>\n<p>When you <strong>do</strong> have a move constructor, even it is marked deleted, the rvalue from the return statement will find the move constructor a better match than the copy constructor.</p>\n<p><strong>Summary</strong></p>\n<p>Unless you really know what you are doing, <strong>never</strong> delete the move members.  If you don't want your type to be movable, just do not define the move members and make sure that you do declare copy members, even if the copy members are <code>=default</code>'d.</p>\n<p><strong>Update</strong></p>\n<blockquote>\n<p id=\"so_16703798_16703973_0\">I suppose it's hard to provide quotes from the Standard on what delete\n  doesn't do? \u2013 DyP</p>\n</blockquote>\n<p>8.4.3 Deleted definitions [dcl.fct.def.delete]</p>\n<blockquote>\n<p id=\"so_16703798_16703973_1\">2 A program that refers to a deleted function implicitly or\n  explicitly, other than to declare it, is ill-formed. [ Note: This\n  includes calling the function implicitly or explicitly and forming a\n  pointer or pointer-to-member to the function. It applies even for\n  references in expressions that are not potentially-evaluated. If a\n  function is overloaded, it is referenced only if the function is\n  selected by overload resolution. \u2014 end note ]</p>\n</blockquote>\n<p><strong>Update 2</strong></p>\n<p>12.8 Copying and moving class objects [class.copy]</p>\n<blockquote>\n<p id=\"so_16703798_16703973_2\">9 If the definition of a class X does not explicitly declare a move\n  constructor, one will be implicitly declared as defaulted if and only\n  if</p>\n<ul>\n<li>X does not have a user-declared copy constructor,</li>\n<li>X does not have a user-declared copy assignment operator,</li>\n<li>X does not have a user-declared move assignment operator, and</li>\n<li>X does not have a user-declared destructor.</li>\n</ul>\n<p id=\"so_16703798_16703973_3\">[Note: When the move constructor is not implicitly declared or\n  explicitly supplied, expressions that otherwise would have invoked the\n  move constructor may instead invoke a copy constructor. \u2014 end note ]</p>\n</blockquote>\n", "OwnerUserId": "576911", "LastEditorUserId": "576911", "LastEditDate": "2013-05-23T01:02:40.687", "Id": "16703973", "Score": "32", "CreationDate": "2013-05-23T00:55:47.583", "LastActivityDate": "2013-05-23T01:02:40.687"}, "16703798": {"CommentCount": "10", "AcceptedAnswerId": "16703973", "PostTypeId": "1", "LastEditorUserId": "1935708", "CreationDate": "2013-05-23T00:34:13.680", "LastActivityDate": "2013-05-23T01:02:40.687", "LastEditDate": "2013-05-23T00:55:28.167", "ViewCount": "708", "FavoriteCount": "8", "Title": "Why is my object not being copied when move constructor is deleted?", "Id": "16703798", "Score": "25", "Body": "<p>I'm trying to use this code to demonstrate the use of the copy-constructor. My presumption was that when I have a function that returns by value, my compiler will, by default, perform a move of the object. But when the move-constructor is unavailable, the compiler will copy instead (in C++03, the compiler would copy when returning by-value). So why in the following example does the compiler try to call the explicitly-deleted move-constructor instead of the available copy-constructor? I'm compiling this in GCC 4.7.2.</p>\n<pre><code>struct S\n{\n    S() = default;\n    S(S const &amp;) = default;\n    S(S&amp;&amp;) = delete;\n};\n\nS f() { return S{}; }\n\nint main()\n{\n    f();\n}\n</code></pre>\n<blockquote>\n<p id=\"so_16703798_16703798_0\">prog.cpp: In function <code>\u2018S f()\u2019</code>:<br>\n  prog.cpp:8:18: error: use of deleted function <code>\u2018S::S(S&amp;&amp;)\u2019</code><br>\n  prog.cpp:5:5: error: declared here</br></br></p>\n</blockquote>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1935708", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_16703798_16703973_2": {"section_id": 458, "quality": 1.0, "length": 12}, "so_16703798_16703973_3": {"section_id": 458, "quality": 0.8636363636363636, "length": 19}, "so_16703798_16703973_1": {"section_id": 3277, "quality": 0.8823529411764706, "length": 30}}, "n3337": {"so_16703798_16703973_2": {"section_id": 449, "quality": 1.0, "length": 12}, "so_16703798_16703973_3": {"section_id": 449, "quality": 0.8636363636363636, "length": 19}, "so_16703798_16703973_1": {"section_id": 3148, "quality": 0.8823529411764706, "length": 30}}, "n4659": {"so_16703798_16703973_2": {"section_id": 481, "quality": 1.0, "length": 12}, "so_16703798_16703973_3": {"section_id": 481, "quality": 0.8636363636363636, "length": 19}, "so_16703798_16703973_1": {"section_id": 4035, "quality": 0.8823529411764706, "length": 30}}}});