post_cb({"12283302": {"CommentCount": "0", "ViewCount": "917", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2012-09-05T14:05:37.730", "LastActivityDate": "2012-09-06T01:11:25.880", "Title": "Is there an operational difference between std::set::iterator and std::set::const_iterator?", "AcceptedAnswerId": "12283411", "LastEditDate": "2012-09-06T00:48:36.440", "Id": "12283302", "Score": "8", "Body": "<p>For most containers, the <code>iterator</code> type provides read-write access to values in the container, and the <code>const_iterator</code> type provides read-only access. However, for <code>std::set&lt;T&gt;</code>, the iterator type cannot provide read-write access, because modifying a value in the set (potentially) breaks the container invariants. Therefore, in <code>std::set&lt;T&gt;</code>, both <code>iterator</code> and <code>const_iterator</code> provide read-only access.</p>\n<p>This leads me to my question: Is there any difference between the things you can do with a <code>std::set&lt;T&gt;::iterator</code> and the things you can do with a <code>std::set&lt;T&gt;::const_iterator</code>?</p>\n<p>Note that in C++11, the manipulation methods of containers (e.g., <code>erase</code>) can take <code>const_iterator</code> arguments.</p>\n", "Tags": "<c++><c++11><iterator><set><containers>", "OwnerUserId": "52251", "AnswerCount": "2"}, "12291718": {"ParentId": "12283302", "CommentCount": "0", "Body": "<p>When we (Err I) ported our large app to VC 10.0, this rule took affect. It broke all sorts of old code where folks manipulated the iterators by calling non const methods on them. </p>\n<p>So that leads to the biggest difference I found: You can only call const methods on a const iterator. Where-as in the old standard you could willy-nilly call non-const methods and mess up your set. In some cases I ended up replacing some set's with map's where I found the code absolutely required modification to the items getting stored in the container.</p>\n<p>Hope that helps.</p>\n", "OwnerUserId": "321866", "PostTypeId": "2", "Id": "12291718", "Score": "1", "CreationDate": "2012-09-06T01:11:25.880", "LastActivityDate": "2012-09-06T01:11:25.880"}, "bq_ids": {"n4140": {"so_12283302_12283411_0": {"section_id": 742, "quality": 0.9038461538461539, "length": 47}}, "n3337": {"so_12283302_12283411_0": {"section_id": 731, "quality": 0.9038461538461539, "length": 47}}, "n4659": {"so_12283302_12283411_0": {"section_id": 800, "quality": 0.8461538461538461, "length": 44}}}, "12283411": {"ParentId": "12283302", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, there's not much much functional difference between them. Of course, there <em>used</em> to be back in C++03, when <code>set&lt;T&gt;::iterator</code> didn't return a <code>const T&amp;</code>. But once they changed it, they were stuck with two different kinds of iterators that both do the same thing.</p>\n<p>Indeed, the standard is quite clear that they have identical functionality (to the point where they <em>can</em> be the same type, but aren't required to be). From 23.2.4, p. 6:</p>\n<blockquote>\n<p id=\"so_12283302_12283411_0\"><code>iterator</code> of an associative container is of the bidirectional iterator category. For associative containers where the value type is the same as the key type, both <code>iterator</code> and <code>const_iterator</code> are constant iterators. It is unspeci\ufb01ed whether or not <code>iterator</code> and <code>const_iterator</code> are the same type. [ <em>Note:</em> <code>iterator</code> and <code>const_iterator</code> have identical semantics in this case, and <code>iterator</code> is convertible to <code>const_iterator</code>. Users can avoid violating the One Definition Rule by always using <code>const_iterator</code> in their function parameter lists. \u2014<em>end note</em> ]</p>\n</blockquote>\n", "OwnerUserId": "734069", "LastEditorUserId": "567292", "LastEditDate": "2012-09-05T14:29:39.403", "Id": "12283411", "Score": "6", "CreationDate": "2012-09-05T14:10:27.507", "LastActivityDate": "2012-09-05T14:29:39.403"}});