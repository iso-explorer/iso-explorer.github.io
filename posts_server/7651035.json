post_cb({"bq_ids": {"n4140": {"so_7651035_7651475_0": {"length": 15, "quality": 0.5172413793103449, "section_id": 6186}}}, "7651475": {"PostTypeId": "2", "Body": "<p><strong>C++03 Standard  5.19 \"Constant expressions\", Para 1</strong> states:  </p>\n<blockquote>\n<p id=\"so_7651035_7651475_0\">In several places, C++ requires expressions that evaluate to an integral or enumeration constant: as array bounds (8.3.4, 5.3.4), as case expressions (6.4.2), as bit-field lengths (9.6), as enumerator initializers (7.2), as static member initializers (9.4.2), and as integral or enumeration non-type template arguments (14.3).</p>\n<p id=\"so_7651035_7651475_1\"><em>constant-expression: conditional-expression</em></p>\n<p id=\"so_7651035_7651475_2\">An integral constant-expression can involve only literals (2.13), enumerators, const variables or static data members of integral or enumeration types initialized with constant expressions (8.5), non-type template parameters of integral or enumeration types, and sizeof expressions. Floating literals (2.13.3) can appear only if they are cast to integral or enumeration types. <strong>Only type conversions to integral or enumeration types can be used.</strong> In particular, except in sizeof expressions, functions, class objects, pointers, or references shall not be used, and assignment, increment, decrement, function-call, or comma operators shall not be used.</p>\n</blockquote>\n<p>The code statements:  </p>\n<blockquote>\n<p id=\"so_7651035_7651475_3\">static_assert(!std::is_pointer(), \"That's a pointer, you probably don't want to write that\");\n  static_assert(std::is_pod(), \"That's not a POD: can't write it\");</p>\n</blockquote>\n<p>break this rule and hence the compiler complains.</p>\n", "LastActivityDate": "2011-10-04T17:04:07.677", "Id": "7651475", "Score": "1", "CreationDate": "2011-10-04T17:04:07.677", "ParentId": "7651035", "CommentCount": "3", "OwnerUserId": "452307"}, "7651035": {"ViewCount": "1740", "Body": "<p>Ideone testcase: <a href=\"http://ideone.com/lzepF\" rel=\"nofollow\">http://ideone.com/lzepF</a></p>\n<p>Code: </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;list&gt;\n#include &lt;set&gt;\n\n#include &lt;stdint.h&gt;\n\ntemplate &lt;typename T&gt; std::ostream&amp; write(std::ostream&amp; os, T const&amp; x);\ntemplate &lt;typename T&gt; std::istream&amp; read(std::istream&amp; is, T&amp; x);\n\ntemplate &lt;typename T, typename U&gt; std::ostream&amp; write(std::ostream&amp; os, std::pair&lt;T, U&gt; const&amp; rh);\ntemplate &lt;typename T, typename U&gt; std::istream&amp; read(std::istream&amp; is, std::pair&lt;T, U&gt;&amp; rh);\n\ntemplate &lt;typename T&gt; std::ostream&amp; writeContainer(std::ostream&amp; os, T const&amp; rh);\n\ntemplate &lt;typename T, typename U&gt; std::ostream&amp; write(std::ostream&amp; os, std::map&lt;T, U&gt; const&amp; rh);\ntemplate &lt;typename T, typename U&gt; std::istream&amp; read(std::istream&amp; is, std::map&lt;T, U&gt; rh);\n\ntemplate &lt;typename T&gt; std::ostream&amp; write(std::ostream&amp; os, std::vector&lt;T&gt; const&amp; rh);\ntemplate &lt;typename T&gt; std::istream&amp; read(std::istream&amp; is, std::vector&lt;T&gt;&amp; rh);\n\ntemplate &lt;typename T&gt;\nstd::ostream&amp; write(std::ostream&amp; os, T const&amp; x){\n    static_assert(!std::is_pointer&lt;T&gt;(), \"That's a pointer, you probably don't want to write that\");\n    static_assert(std::is_pod&lt;T&gt;(), \"That's not a POD: can't write it\");\n    os.write(reinterpret_cast&lt;const char *&gt;(&amp;x), sizeof(T));\n    return os;\n}\n\ntemplate &lt;typename T&gt;\nstd::istream&amp; read(std::istream&amp; is, T&amp; x){\n    static_assert(!std::is_pointer&lt;T&gt;(), \"That's a pointer, you probably don't want to read that\");\n    static_assert(std::is_pod&lt;T&gt;(), \"That's not a POD: can't read it\");\n    is.read(reinterpret_cast&lt;char *&gt;(&amp;x), sizeof(T));\n    return is;\n}\n\ntemplate &lt;typename T, typename U&gt;\nstd::ostream&amp; write(std::ostream&amp; os, std::pair&lt;T, U&gt; const&amp; rh){\n    write(os, rh.first);\n    write(os, rh.second);\n    return os;\n}\n\ntemplate &lt;typename T, typename U&gt;\nstd::istream&amp; read(std::istream&amp; is, std::pair&lt;T, U&gt;&amp; rh){\n    read(is, rh.first);\n    read(is, rh.second);\n    return is;\n}\n\ntemplate &lt;typename T&gt;\nstd::ostream&amp; writeContainer(std::ostream&amp; os, T const&amp; rh){\n    uint32_t size = std::distance(rh.begin(), rh.end());\n    write(os, size);\n\n    for(auto it = rh.begin(); it != rh.end(); ++it){\n        write(os, *it);\n    }\n\n    return os;\n}\n\ntemplate &lt;typename T&gt;\nstd::istream&amp; readContainer(std::istream&amp; is, T&amp; rh){\n    uint32_t size;\n    read(is, size);\n    std::insert_iterator&lt;T&gt; it(rh, rh.end());\n\n    for(uint32_t i=0; i&lt;size; ++i) {\n        typename T::value_type x;\n        read(is, x);\n        it = x;\n    }\n    return is;\n}\n\ntemplate &lt;typename T, typename U&gt;\nstd::ostream&amp; write(std::ostream&amp; os, std::map&lt;T, U&gt; const&amp; rh){\n    return writeContainer(os, rh);\n}\n\ntemplate &lt;typename T, typename U&gt;\nstd::istream&amp; read(std::istream&amp; is, std::map&lt;T, U&gt; rh){\n    return readContainer(is, rh);\n}\n\ntemplate &lt;typename T&gt;\nstd::ostream&amp; write(std::ostream&amp; os, std::vector&lt;T&gt; const&amp; rh){\n    return writeContainer(os, rh);\n}\n\ntemplate &lt;typename T&gt;\nstd::istream&amp; read(std::istream&amp; is, std::vector&lt;T&gt;&amp; rh){\n    return readContainer(is, rh);\n}\n\nint main(){\n    {\n        std::stringstream s;\n        std::vector&lt;int&gt; x = {0, 1, 2, 3};\n        write(s, x);\n    }\n\n    {\n        std::stringstream s;\n        std::map&lt;int, int&gt; x = {{0, 0}, {1, 2}, {2, 4}, {3, 6}};\n        write(s, x);\n    }\n\n    return 0;\n}\n</code></pre>\n<p>Errors:</p>\n<pre class=\"lang-none prettyprint-override\"><code>prog.cpp: In function 'std::ostream&amp; write(std::ostream&amp;, const T&amp;) [with T = unsigned int, std::ostream = std::basic_ostream&lt;char&gt;]':\nprog.cpp:57:2:   instantiated from 'std::ostream&amp; writeContainer(std::ostream&amp;, const T&amp;) [with T = std::vector&lt;int&gt;, std::ostream = std::basic_ostream&lt;char&gt;]'\nprog.cpp:92:30:   instantiated from 'std::ostream&amp; write(std::ostream&amp;, const std::vector&lt;T&gt;&amp;) [with T = int, std::ostream = std::basic_ostream&lt;char&gt;]'\nprog.cpp:104:13:   instantiated from here\nprog.cpp:29:11: error: a cast to a type other than an integral or enumeration type cannot appear in a constant-expression\nprog.cpp:29:11: error: a cast to a type other than an integral or enumeration type cannot appear in a constant-expression\nprog.cpp: In function 'std::ostream&amp; write(std::ostream&amp;, const T&amp;) [with T = int, std::ostream = std::basic_ostream&lt;char&gt;]':\nprog.cpp:60:3:   instantiated from 'std::ostream&amp; writeContainer(std::ostream&amp;, const T&amp;) [with T = std::vector&lt;int&gt;, std::ostream = std::basic_ostream&lt;char&gt;]'\nprog.cpp:92:30:   instantiated from 'std::ostream&amp; write(std::ostream&amp;, const std::vector&lt;T&gt;&amp;) [with T = int, std::ostream = std::basic_ostream&lt;char&gt;]'\nprog.cpp:104:13:   instantiated from here\nprog.cpp:29:11: error: a cast to a type other than an integral or enumeration type cannot appear in a constant-expression\nprog.cpp:29:11: error: a cast to a type other than an integral or enumeration type cannot appear in a constant-expression\n</code></pre>\n<p>Since we have no line numbers, :( ,  it complains about the FIRST <code>write(s, x)</code>, and seems to me complain about the <code>reinterpret_cast&lt;const char*&gt;(const unsigned int*)</code> but I'm pretty sure that should be legal. </p>\n<p>What's going wrong?</p>\n", "AcceptedAnswerId": "7651230", "Title": "Cast to integral type or other type cannot appear in a constant expression", "CreationDate": "2011-10-04T16:24:35.700", "LastActivityDate": "2011-10-04T17:04:07.677", "CommentCount": "1", "LastEditDate": "2011-10-04T16:40:47.053", "PostTypeId": "1", "LastEditorUserId": "636019", "Id": "7651035", "AnswerCount": "2", "Score": "5", "OwnerUserId": "220687", "Tags": "<c++>", "FavoriteCount": "1"}, "7651230": {"PostTypeId": "2", "Body": "<p>You are using the <code>is_pod</code> and <code>is_pointer</code> incorrectly. You need to change it to the following:</p>\n<pre><code>    static_assert(!std::is_pointer&lt;T&gt;::value, \"That's a pointer, you probably don't want to write that\");\n    static_assert(std::is_pod&lt;T&gt;::value, \"That's not a POD: can't write it\");\n</code></pre>\n<p>You can test with this:</p>\n<pre><code>    write(std::cout, 1);\n    int *p = 0;\n    write(std::cout, p);\n</code></pre>\n", "LastActivityDate": "2011-10-04T16:42:49.603", "Id": "7651230", "Score": "5", "CreationDate": "2011-10-04T16:42:49.603", "ParentId": "7651035", "CommentCount": "3", "OwnerUserId": "266198"}});