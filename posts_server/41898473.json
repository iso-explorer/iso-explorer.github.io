post_cb({"bq_ids": {"n4140": {"so_41898473_41899111_15": {"length": 6, "quality": 1.0, "section_id": 5578}, "so_41898473_41899111_12": {"length": 6, "quality": 1.0, "section_id": 5578}}, "n3337": {"so_41898473_41899111_13": {"length": 20, "quality": 0.8, "section_id": 5393}, "so_41898473_41899111_1": {"length": 20, "quality": 0.8, "section_id": 5393}, "so_41898473_41899111_4": {"length": 20, "quality": 0.8, "section_id": 5393}, "so_41898473_41899111_9": {"length": 20, "quality": 0.8, "section_id": 5393}, "so_41898473_41899111_15": {"length": 6, "quality": 1.0, "section_id": 5360}, "so_41898473_41899111_12": {"length": 6, "quality": 1.0, "section_id": 5360}}, "n4659": {"so_41898473_41899111_15": {"length": 6, "quality": 1.0, "section_id": 7025}, "so_41898473_41899111_12": {"length": 6, "quality": 1.0, "section_id": 7025}}}, "41899111": {"Id": "41899111", "PostTypeId": "2", "Body": "<p>Looking at <code>std::reverse_iterator</code>'s <em>libstdc++</em> implementation reveals something interesting:</p>\n<pre><code>  /**\n   *  @return  A reference to the value at @c --current\n   *\n   *  This requires that @c --current is dereferenceable.\n   *\n   *  @warning This implementation requires that for an iterator of the\n   *           underlying iterator type, @c x, a reference obtained by\n   *           @c *x remains valid after @c x has been modified or\n   *           destroyed. This is a bug: http://gcc.gnu.org/PR51823\n  */\n  _GLIBCXX17_CONSTEXPR reference\n  operator*() const\n  {\n    _Iterator __tmp = current;\n     return *--__tmp;\n  }\n</code></pre>\n<p>The <code>@warning</code> section tells us that a requirement of the underlying iterator type is that <code>*x</code> must remain valid even after the underlying iterator is modified/destroyed.</p>\n<p>Looking at the <a href=\"http://gcc.gnu.org/PR51823\">mentioned bug link</a> reveals more interesting information:</p>\n<blockquote>\n<blockquote>\n<p id=\"so_41898473_41899111_3\">at some point between C++03 and C++11 the definition of reverse_iterator::operator* was changed to clarify this, making libstdc++'s implementation wrong.  The standard now says:</p>\n<p id=\"so_41898473_41899111_4\">[ Note: This operation must use an auxiliary member variable rather than a temporary variable to avoid returning a reference that persists beyond the lifetime of its associated iterator. (See 24.2.) \u2014end note ]</p>\n</blockquote>\n<p id=\"so_41898473_41899111_2\">comment by Jonathan Wakely (2012)</p>\n</blockquote>\n<p>So it looks like a bug... but at the end of the topic:</p>\n<blockquote>\n<blockquote>\n<p id=\"so_41898473_41899111_7\">The definition of reverse_iterator has been reverted to the C++03 version, which does not use an extra member, so \"stashing iterators\" can not be used with reverse_iterator.</p>\n</blockquote>\n<p id=\"so_41898473_41899111_6\">comment by Jonathan Wakely (2014)</p>\n</blockquote>\n<p>So it seems that using <code>std::reverse_iterator</code> with \"stashing iterators\" does indeed lead to UB. </p>\n<hr>\n<p>Looking at the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3473.html#2204\">DR 2204: <strong>\"<code>reverse_iterator</code> should not require a second copy of the base iterator\"</strong></a> further clarifies the issue:</p>\n<blockquote>\n<p id=\"so_41898473_41899111_8\">This note in 24.5.1.3.4 [reverse.iter.op.star]/2:</p>\n<blockquote>\n<p id=\"so_41898473_41899111_13\"><strong>[ Note: This operation must use an auxiliary member variable rather than a temporary variable to avoid returning a reference that persists beyond the lifetime of its associated iterator. (See 24.2.) \u2014end note ]</strong></p>\n<p id=\"so_41898473_41899111_14\"><em>[my note: I think that the above note would fix your UB issue]</em></p>\n</blockquote>\n<p id=\"so_41898473_41899111_11\">is incorrect because such iterator implementations are ruled out by 24.2.5 [forward.iterators]/6, where it says:</p>\n<blockquote>\n<p id=\"so_41898473_41899111_15\"><strong>If a and b are both dereferenceable, then a == b if and only if *a and *b are bound to the same object.</strong></p>\n</blockquote>\n</blockquote>\n</hr>", "LastEditorUserId": "598696", "LastActivityDate": "2017-01-27T17:01:05.337", "Score": "44", "CreationDate": "2017-01-27T16:54:56.053", "ParentId": "41898473", "CommentCount": "2", "OwnerUserId": "598696", "LastEditDate": "2017-01-27T17:01:05.337"}, "41898473": {"ViewCount": "1482", "Body": "<p>I have a <code>AsIterator</code> template class which takes a numeric-like type, in this example just an <code>int</code>, and converts it into an iterator (<code>++</code> and <code>--</code> increment and decrement the number, and <code>operator*</code> just returns a reference to it).</p>\n<p>This works fine <strong>unless it's wrapped into a <code>std::reverse_iterator</code> and compiled with any optimization</strong> (<code>-O</code> is enough). When I optimize the binary, the compiler strips out the dereference call to the <code>reverse_iterator</code> and replaces it with some weird value. It must be noted that it still <strong>makes the correct number of iterations</strong>. It's just the value obtained by reverse iterator that is garbage.</p>\n<p>Consider the following code:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iterator&gt;\n#include &lt;cstdio&gt;\n\ntemplate&lt;typename T&gt;\nclass AsIterator : public std::iterator&lt;std::bidirectional_iterator_tag, T&gt; {\n    T v;\npublic:\n    AsIterator(const T &amp; init) : v(init) {}\n\n    T &amp;operator*() { return v; }\n\n    AsIterator &amp;operator++() { ++v; return *this; }\n    AsIterator operator++(int) { AsIterator copy(*this); ++(*this); return copy; }\n    AsIterator &amp;operator--() { --v; return *this; }\n    AsIterator operator--(int) { AsIterator copy(*this); --(*this); return copy; }\n\n    bool operator!=(const AsIterator &amp;other) const {return v != other.v;}\n    bool operator==(const AsIterator &amp;other) const {return v == other.v;}\n};\n\ntypedef std::reverse_iterator&lt;AsIterator&lt;int&gt;&gt; ReverseIt;\n\nint main() {\n    int a = 0, b = 0;\n    printf(\"Insert two integers: \");\n    scanf(\"%d %d\", &amp;a, &amp;b);\n    if (b &lt; a) std::swap(a, b);\n\n    AsIterator&lt;int&gt; real_begin(a);\n    AsIterator&lt;int&gt; real_end(b);\n    for (ReverseIt rev_it(real_end); rev_it != ReverseIt(real_begin); ++rev_it) {\n        printf(\"%d\\n\", *rev_it);\n    }\n    return 0;\n}\n</code></pre>\n<p>This should supposingly loop down from the highest inserted number to the lowest and print them, such as in this run (compiled with <code>-O0</code>):</p>\n<pre><code>Insert two integers: 1 4 \n3\n2\n1\n</code></pre>\n<p>What I get with <code>-O</code> is instead:</p>\n<pre><code>Insert two integers: 1 4 \n1\n0\n0\n</code></pre>\n<p>You can <a href=\"http://cpp.sh/3htz\">try it online here</a>; the numbers may vary but they're always \"wrong\" when optimizing the binary.</p>\n<hr>\n<p>What I've tried:</p>\n<ul>\n<li>hardcoding the input integers is enough to produce the same result;</li>\n<li>the issue persists with <em>gcc 5.4.0</em> and <em>clang 3.8.0</em>, also when using <em>libc++</em>;</li>\n<li>making all the objects <code>const</code> (i.e. returning <code>const int &amp;</code>, and declaring all variables as such) doesn't fix it;</li>\n<li>using the <code>reverse_iterator</code> in the same way on for example some <code>std::vector&lt;int&gt;</code> works fine;</li>\n<li>if I just use <code>AsIterator&lt;int&gt;</code> for a normal forward or backward loop it works fine.</li>\n<li>in my tests, the constant <code>0</code> that is printed is actually <em>hardcoded</em> by the compiler, the calls to <code>printf</code> all look like this when compiled with <code>-S -O</code>:</li>\n</ul>\n<pre><code>    movl    $.L.str.2, %edi  # .L.str.2 is \"%d\\n\"\n    xorl    %eax, %eax\n    callq   printf\n</code></pre>\n<p>Given the consistency of <em>clang</em> and <em>gcc</em>'s behavior here I am pretty sure they're doing it right and I misunderstood, but I really can't see it.</p>\n</hr>", "AcceptedAnswerId": "41899111", "Title": "Reverse iterator returns garbage when optimized", "CreationDate": "2017-01-27T16:21:48.877", "Id": "41898473", "CommentCount": "7", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2017-01-27T17:01:05.337", "Score": "42", "OwnerUserId": "1749822", "Tags": "<c++><loops><iterator><reverse><compiler-optimization>", "AnswerCount": "1"}});