post_cb({"bq_ids": {"n4140": {"so_34119876_34119876_0": {"length": 79, "quality": 0.8977272727272727, "section_id": 593}, "so_34119876_34120764_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 603}, "so_34119876_34120764_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 603}}, "n3337": {"so_34119876_34119876_0": {"length": 77, "quality": 0.875, "section_id": 583}, "so_34119876_34120764_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 593}, "so_34119876_34120764_1": {"length": 6, "quality": 0.5454545454545454, "section_id": 2}}, "n4659": {"so_34119876_34119876_0": {"length": 85, "quality": 0.9659090909090909, "section_id": 616}, "so_34119876_34120764_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 629}, "so_34119876_34120764_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 629}}}, "34119876": {"ViewCount": "133", "Body": "<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct CL2\n{\n    CL2(){}\n    CL2(const CL2&amp;){}\n};\n\nCL2 cl2;\n\nstruct CL1\n{\n    CL1(){}\n    operator CL2&amp;(){cout&lt;&lt;\"operator CL2&amp;\"; return cl2;}\n    operator const CL2&amp;(){cout&lt;&lt;\"operator const CL2&amp;\"; return cl2;}\n};\n\nCL1 cl1;\n\nint main()\n{\n    CL1 cl1;\n    CL2 cl2 (cl1);\n}\n</code></pre>\n<p>Both clang and gcc give ambiguous conversion operator, but Visual Studio compiles ok and prints \"operator const CL2&amp;\". How must be right according to Standard?<br>\nAs I undestand, conversion of CL1 to const CL2&amp; is in copy-initialization context (as a part of a direct-initialization of cl2 object). I seen n4296 draft, [over.match.copy]:</br></p>\n<blockquote>\n<p id=\"so_34119876_34119876_0\">Assuming that \u201ccv1 T\u201d is the type of the object being initialized,\n  with T a class type, the candidate functions are selected as follows:<br>\n  \u2014 The converting constructors (12.3.1) of T are candidate\n  functions.<br>\n  \u2014 When the type of the initializer expression is a\n  class type \u201ccv S\u201d, the non-explicit conversion functions of S and its\n  base classes are considered. When initializing a temporary to be bound\n  to the first parameter of a constructor where the parameter is of type\n  \u201creference to possibly cv-qualified T\u201d and the constructor is called\n  with a single argument in the context of direct-initialization of an\n  object of type \u201ccv2 T\u201d, explicit conversion functions are also\n  considered. Those that are not hidden within S and yield a type whose\n  cv-unqualified version is the same type as T or is a derived class\n  thereof are candidate functions. <strong>Conversion functions that return\n  \u201creference to X\u201d return lvalues or xvalues, depending on the type of\n  reference, of type X and are therefore considered to yield X for this\n  process of selecting candidate functions.</strong></br></br></p>\n</blockquote>\n<p>I.e. both of conversion operators are considered as return CL2 and const CL2 (not just CL2 without const) and it remains to solve, which conversion is better: CL2 -&gt; const CL2&amp; or const CL2 -&gt; const CL2&amp;. The second case seems more appropriate. Should a better qualification conversion considered in that context? Or both cases are Identity conversion? I couldn't find it in Standard</p>\n", "AcceptedAnswerId": "34120764", "Title": "Reference binding through ambiguous conversion operator", "CreationDate": "2015-12-06T16:35:41.500", "Id": "34119876", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-12-06T18:34:34.093", "Score": "8", "OwnerUserId": "3514538", "Tags": "<c++><visual-studio><c++11><c++14><copy-initialization>", "AnswerCount": "1"}, "34120764": {"Id": "34120764", "PostTypeId": "2", "Body": "<p>Since both conversion operators have identical signatures, the only way in which one could be preferred over the other is by application of [over.match.best]/(1.4)\u2026</p>\n<blockquote>\n<p id=\"so_34119876_34120764_0\">\u2014 the context is an initialization by user-defined conversion (see 8.5,\n  13.3.1.5, and 13.3.1.6) and the standard conversion sequence from the return type of <code>F1</code> to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the\n  standard conversion sequence from the return type of <code>F2</code> to the\n  destination type.</p>\n</blockquote>\n<p>\u2026or (1.5):</p>\n<blockquote>\n<p id=\"so_34119876_34120764_1\">\u2014 the context is an initialization by conversion function for direct\n  reference binding (13.3.1.6) of a reference to function type, [\u2026]</p>\n</blockquote>\n<p>Clearly, neither applies, hence the ambiguity. A possible way to disambiguate:</p>\n<pre><code>operator CL2&amp;();\noperator const CL2&amp;() const; \n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/b4e750e1d96e3c3c\" rel=\"nofollow\"><strong>Demo</strong></a>; Here, the former overload's initial standard conversion sequence of the implicit object argument is better as per [over.ics.rank]/(3.2.6), which is decisive by [over.match.best]/(1.3).</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-12-06T18:34:34.093", "Score": "4", "CreationDate": "2015-12-06T18:03:38.340", "ParentId": "34119876", "CommentCount": "3", "OwnerUserId": "3647361", "LastEditDate": "2015-12-06T18:34:34.093"}});