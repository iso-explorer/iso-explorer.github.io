post_cb({"25001213": {"ParentId": "25001147", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The types Parent and Child are not covariant, but Parent&amp; and Child&amp; are.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Parent\n{\npublic:\n    virtual Parent&amp; foo() = 0;\n};\n\ntemplate &lt;class T&gt;\nclass Child : public Parent\n{\npublic:\n    Child&amp; foo() { cout &lt;&lt; \"Child Foo\\n\"; return *this; }\n};\n\nint main()\n{\n    Child&lt;int&gt; c;\n    Parent&amp; parent = c.foo();\n    return 0;\n}\n</code></pre>\n<p>From 10.3.7 Virtual functions</p>\n<blockquote>\n<p id=\"so_25001147_25001213_0\">The return type of an overriding function shall be either identical to\n  the return type of the overridden function or covariant with the\n  classes of the functions. If a function D::f overrides a function\n  B::f, the return types of the functions are covariant if they satisfy\n  the following criteria: </p>\n<p id=\"so_25001147_25001213_1\">\u2014 both are pointers to classes, both are\n  lvalue references to classes, or both are rvalue references to\n  classes112</p>\n<p id=\"so_25001147_25001213_2\">\u2014 the class in the return type of B::f is the same class as\n  the class in the return type of D::f, or is an unambiguous and\n  accessible direct or indirect base class of the class in the return\n  type of D::f </p>\n<p id=\"so_25001147_25001213_3\">\u2014 both pointers or references have the same\n  cv-qualification and the class type in the return type of D::f has the\n  same cv-qualification as or less cv-qualification than the class type\n  in the return type of B::f.</p>\n</blockquote>\n", "OwnerUserId": "2249683", "LastEditorUserId": "2249683", "LastEditDate": "2014-07-28T18:06:15.017", "Id": "25001213", "Score": "6", "CreationDate": "2014-07-28T17:50:54.330", "LastActivityDate": "2014-07-28T18:06:15.017"}, "25001147": {"CommentCount": "2", "ViewCount": "477", "PostTypeId": "1", "LastEditorUserId": "1884803", "CreationDate": "2014-07-28T17:46:59.407", "LastActivityDate": "2014-07-28T18:42:00.080", "Title": "invalid covariant return type for templated child class", "AcceptedAnswerId": "25001213", "LastEditDate": "2014-07-28T18:42:00.080", "Id": "25001147", "Score": "0", "Body": "<p>I have a child class that inherits from a parent class, but the child also picks up a template argument. Both classes have a 'clone' function that just calls their copy constructor. I want to make the copy virtual so that the child class will always call it's own copy.</p>\n<p>Here is a simplified version of the problem:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Parent\n{\npublic:\n    virtual Parent foo() { cout &lt;&lt; \"Parent Foo\\n\"; return *this; }\n};\n\ntemplate &lt;class T&gt;\nclass Child : public Parent\n{\npublic:\n    Child&lt;T&gt; foo() { cout &lt;&lt; \"Child Foo\\n\"; return *this; }\n};\n\nint main()\n{\n    Child&lt;int&gt; c;\n\n    c.foo();\n\n    return 0;\n}\n</code></pre>\n<p>It seems that the Child class should be covariant with the Parent class. What am I missing? Is there a way to still keep the virtual function and the template? Thanks.</p>\n<p><strong>EDIT</strong></p>\n<p>Perhaps my previous example was too simple. Here is an expanded simple example:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Parent\n{\npublic:\n    Parent(){}\n    virtual Parent clone() const { return Parent(*this); }\nprivate:\n    Parent( Parent const&amp; cpy ) { };\n};\n\ntemplate &lt;class T&gt;\nclass Child : public Parent\n{\npublic:\n    Child(){}\n    Child&lt;T&gt; clone() const { return Child&lt;T&gt;(*this); }\nprivate:\n    Child( Child&lt;T&gt; const&amp; cpy ) {};\n};\n\nint main()\n{\n    Child&lt;int&gt; c;\n    Parent* pc = &amp;c;\n    pc-&gt;clone();\n\n    return 0;\n}\n</code></pre>\n<p>I would like the copy to always be an actual copy of the class by making copy virtual.\nI wanted to avoid returning a pointer, but it looks like I will be forced to return pointers to avoid the slicing problem mentioned by Dieter L\u00fccking.</p>\n", "Tags": "<c++><templates><virtual><covariance>", "OwnerUserId": "1884803", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25001147_25001213_2": {"section_id": 7008, "quality": 1.0, "length": 17}, "so_25001147_25001213_0": {"section_id": 7008, "quality": 0.92, "length": 23}, "so_25001147_25001213_1": {"section_id": 7008, "quality": 0.9090909090909091, "length": 10}, "so_25001147_25001213_3": {"section_id": 7008, "quality": 1.0, "length": 19}}, "n3337": {"so_25001147_25001213_2": {"section_id": 6754, "quality": 1.0, "length": 17}, "so_25001147_25001213_0": {"section_id": 6754, "quality": 0.92, "length": 23}, "so_25001147_25001213_1": {"section_id": 6754, "quality": 0.9090909090909091, "length": 10}, "so_25001147_25001213_3": {"section_id": 6754, "quality": 1.0, "length": 19}}, "n4659": {"so_25001147_25001213_2": {"section_id": 8505, "quality": 1.0, "length": 17}, "so_25001147_25001213_0": {"section_id": 8505, "quality": 0.92, "length": 23}, "so_25001147_25001213_1": {"section_id": 8505, "quality": 0.9090909090909091, "length": 10}, "so_25001147_25001213_3": {"section_id": 8505, "quality": 1.0, "length": 19}}}});