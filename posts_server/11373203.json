post_cb({"12001180": {"ParentId": "11373203", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I well explain this with a example.<br/>\nassume we have the following union:</p>\n<pre><code>union A{\n   int x;\n   short y[2];\n};\n</code></pre>\n<p>I well assume that <code>sizeof(int)</code> gives 4, and that <code>sizeof(short)</code> gives 2.\n<br/>\nwhen you write <code>union A a = {10}</code> that well create a new var of type A in put in it the value 10.</p>\n<p>your memory should look like that: (remember that all of the union members get the same location)<br/></p>\n<pre>\n       |                   x                   |\n       |        y[0]       |       y[1]        |\n       -----------------------------------------\n   a-&gt; |0000 0000|0000 0000|0000 0000|0000 1010|\n       -----------------------------------------\n</pre>\n<p>as you could see, the value of a.x is 10, the value of a.y<a href=\"http://msdn.microsoft.com/en-us/library/5dxy4b7b%28v=vs.80%29.aspx\" rel=\"nofollow\">1</a> is 10, and the value of a.y[0] is 0.</p>\n<p>now, what well happen if I do this?</p>\n<pre><code>a.y[0] = 37;\n</code></pre>\n<p>our memory will look like this:</p>\n<pre>\n       |                   x                   |\n       |        y[0]       |       y[1]        |\n       -----------------------------------------\n   a-&gt; |0000 0000|0010 0101|0000 0000|0000 1010|\n       -----------------------------------------\n</pre>\n<p>this will turn the value of a.x to 2424842 (in decimal).</p>\n<p>now, if your union has a float, or double, your memory map well be more of a mess, because of the way you store exact numbers.\nmore info you could get in <a href=\"http://msdn.microsoft.com/en-us/library/5dxy4b7b%28v=vs.80%29.aspx\" rel=\"nofollow\">here</a>.</p>\n", "OwnerUserId": "1561062", "LastEditorUserId": "1938163", "LastEditDate": "2014-09-14T09:20:19.560", "Id": "12001180", "Score": "-3", "CreationDate": "2012-08-17T07:00:47.880", "LastActivityDate": "2014-09-14T09:20:19.560"}, "11373277": {"ParentId": "11373203", "PostTypeId": "2", "CommentCount": "23", "Body": "<p>The C++11 standard says it this way</p>\n<blockquote>\n<p id=\"so_11373203_11373277_0\"><strong>9.5 Unions</strong></p>\n<p id=\"so_11373203_11373277_1\">In a union, at most one of the non-static data members can be active at any time, that is, the value of at most one of the non-static data members can be stored in a union at any time.</p>\n</blockquote>\n<p>If only one value is stored, how can you read another? It just isn't there.</p>\n<hr>\n<p>The gcc documentation lists this under <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Structures-unions-enumerations-and-bit_002dfields-implementation.html#Structures-unions-enumerations-and-bit_002dfields-implementation\" rel=\"noreferrer\">Implementation defined behavior</a></p>\n<blockquote>\n<ul>\n<li><em>A member of a union object is accessed using a member of a different type (C90 6.3.2.3).</em></li>\n</ul>\n<p id=\"so_11373203_11373277_2\">The relevant bytes of the representation of the object are treated as an object of the type used for the access. See Type-punning. This may be a trap representation.</p>\n</blockquote>\n<p>indicating that this is not required by the C standard.</p>\n<hr>\n<p>2016-01-05: Through the comments I was linked to <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_283.htm\" rel=\"noreferrer\">C99 Defect Report #283</a> which adds a similar text as a footnote to the C standard document:</p>\n<blockquote>\n<p id=\"so_11373203_11373277_3\">78a) If the member used to access the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called \"type punning\"). This might be a trap representation.</p>\n</blockquote>\n<p>Not sure if it clarifies much though, considering that a footnote is not normative for the standard.</p>\n</hr></hr>", "OwnerUserId": "597607", "LastEditorUserId": "597607", "LastEditDate": "2016-01-05T11:48:37.820", "Id": "11373277", "Score": "21", "CreationDate": "2012-07-07T07:48:43.203", "LastActivityDate": "2016-01-05T11:48:37.820"}, "11996072": {"ParentId": "11373203", "CommentCount": "2", "Body": "<p>Something that is not yet mentioned by available answers is the footnote 37 in the paragraph 21 of the section 6.2.5:</p>\n<blockquote>\n<p id=\"so_11373203_11996072_0\">Note that aggregate type does not include union type because an object\n  with union type can only contain one member at a time.</p>\n</blockquote>\n<p>This requirement seem to clearly imply that you must not write in a member and read in another one. In this case it might be undefined behavior by lack of specification.</p>\n", "OwnerUserId": "1602982", "PostTypeId": "2", "Id": "11996072", "Score": "8", "CreationDate": "2012-08-16T22:00:52.497", "LastActivityDate": "2012-08-16T22:00:52.497"}, "11373203": {"CommentCount": "6", "AcceptedAnswerId": "11996970", "PostTypeId": "1", "LastEditorUserId": "608639", "CreationDate": "2012-07-07T07:37:00.127", "LastActivityDate": "2016-09-20T16:11:20.460", "LastEditDate": "2016-09-20T16:11:20.460", "ViewCount": "8969", "FavoriteCount": "37", "Title": "Accessing inactive union member and undefined behavior?", "Id": "11373203", "Score": "82", "Body": "<p>I was under the impression that accessing an <code>union</code> member other than the last one set is UB, but I can't seem to find a solid reference (other than answers claiming it's UB but without any support from the standard).</p>\n<p>So, is it undefined behavior?</p>\n", "Tags": "<c++><undefined-behavior><language-lawyer><unions>", "OwnerUserId": "673730", "AnswerCount": "5"}, "11906997": {"ParentId": "11373203", "CommentCount": "6", "Body": "<p>I think the closest the standard comes to saying it's undefined behavior is where it defines the behavior for a union containing a common initial sequence (C99, \u00a76.5.2.3/5):</p>\n<blockquote>\n<p id=\"so_11373203_11906997_0\">One special guarantee is made in order to simplify the use of unions: if a union contains\n  several structures that share a common initial sequence (see below), and if the union\n  object currently contains one of these structures, it is permitted to inspect the common\n  initial part of any of them anywhere that a declaration of the complete type of the union is\n  visible. Two structures share a common initial sequence if corresponding members have\n  compatible types (and, for bit-fields, the same widths) for a sequence of one or more\n  initial members.</p>\n</blockquote>\n<p>C++11 gives similar requirements/permission at \u00a79.2/19:</p>\n<blockquote>\n<p id=\"so_11373203_11906997_1\">If a standard-layout union contains two or more standard-layout structs that share a common initial sequence,\n  and if the standard-layout union object currently contains one of these standard-layout structs, it is permitted\n  to inspect the common initial part of any of them. Two standard-layout structs share a common initial\n  sequence if corresponding members have layout-compatible types and either neither member is a bit-field or\n  both are bit-fields with the same width for a sequence of one or more initial members.</p>\n</blockquote>\n<p>Though neither states it directly, these both carry a strong implication that \"inspecting\" (reading) a member is \"permitted\" <em>only</em> if 1) it is (part of) the member most recently written, or 2) is part of a common initial sequence.</p>\n<p>That's not a direct statement that doing otherwise is undefined behavior, but it's the closest of which I'm aware.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "11906997", "Score": "16", "CreationDate": "2012-08-10T18:06:46.540", "LastActivityDate": "2012-08-10T18:06:46.540"}, "bq_ids": {"n4140": {"so_11373203_11373277_1": {"section_id": 5913, "quality": 1.0, "length": 19}, "so_11373203_11996970_6": {"section_id": 7223, "quality": 0.9411764705882353, "length": 16}, "so_11373203_11906997_0": {"section_id": 5878, "quality": 0.6, "length": 33}, "so_11373203_11996970_5": {"section_id": 7189, "quality": 0.9444444444444444, "length": 17}, "so_11373203_11996970_4": {"section_id": 7202, "quality": 0.8431372549019608, "length": 43}, "so_11373203_11906997_1": {"section_id": 5878, "quality": 1.0, "length": 50}, "so_11373203_11996970_3": {"section_id": 5913, "quality": 1.0, "length": 19}}, "n3337": {"so_11373203_11373277_1": {"section_id": 5685, "quality": 1.0, "length": 19}, "so_11373203_11996970_6": {"section_id": 6967, "quality": 0.9411764705882353, "length": 16}, "so_11373203_11996970_7": {"section_id": 5, "quality": 0.9615384615384616, "length": 25}, "so_11373203_11906997_0": {"section_id": 5649, "quality": 0.6, "length": 33}, "so_11373203_11996970_5": {"section_id": 6933, "quality": 0.9444444444444444, "length": 17}, "so_11373203_11996970_4": {"section_id": 6946, "quality": 0.8431372549019608, "length": 43}, "so_11373203_11906997_1": {"section_id": 5649, "quality": 1.0, "length": 50}, "so_11373203_11996970_3": {"section_id": 5685, "quality": 1.0, "length": 19}}, "n4659": {"so_11373203_11373277_1": {"section_id": 7404, "quality": 1.0, "length": 19}, "so_11373203_11996970_5": {"section_id": 8697, "quality": 0.8888888888888888, "length": 16}, "so_11373203_11996970_3": {"section_id": 7404, "quality": 1.0, "length": 19}, "so_11373203_11996970_6": {"section_id": 8732, "quality": 0.5294117647058824, "length": 9}, "so_11373203_11996970_4": {"section_id": 8711, "quality": 0.8431372549019608, "length": 43}}}, "11996970": {"ParentId": "11373203", "PostTypeId": "2", "CommentCount": "20", "Body": "<p>The confusion is that C explicitly permits type-punning through a union, whereas C++ (<a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a>) has no such permission.</p>\n<blockquote>\n<p id=\"so_11373203_11996970_0\"><a class=\"post-tag\" href=\"/questions/tagged/c11\" rel=\"tag\" title=\"show questions tagged 'c11'\">c11</a></p>\n<h3>6.5.2.3 Structure and union members</h3>\n<p id=\"so_11373203_11996970_1\">95) If the member used to read the contents of a union object is not the same as the member last used to\n  store a value in the object, the appropriate part of the object representation of the value is reinterpreted\n  as an object representation in the new type as described in 6.2.6 (a process sometimes called \u2018\u2018type\n  punning\u2019\u2019). This might be a trap representation.</p>\n</blockquote>\n<p>The situation with C++:</p>\n<blockquote>\n<p id=\"so_11373203_11996970_2\"><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a></p>\n<h3>9.5 Unions [class.union]</h3>\n<p id=\"so_11373203_11996970_3\">In a union, at most one of the non-static data members can be active at any time, that is, the value of at\n  most one of the non-static data members can be stored in a union at any time.</p>\n</blockquote>\n<p>C++ later has language permitting the use of unions containing <code>struct</code>s with common initial sequences; this doesn't however permit type-punning.</p>\n<p>To determine whether union type-punning <em>is</em> allowed in C++, we have to search further.  Recall that <a class=\"post-tag\" href=\"/questions/tagged/c99\" rel=\"tag\" title=\"show questions tagged 'c99'\">c99</a> is a normative reference for C++11 (and C99 has similar language to C11 permitting union type-punning):</p>\n<blockquote>\n<h3>3.9 Types [basic.types]</h3>\n<p id=\"so_11373203_11996970_4\">4 - The object representation of an object of type T is the sequence of N unsigned char objects taken up by\n  the object of type T, where N equals sizeof(T). The value representation of an object is the set of bits that\n  hold the value of type T. For trivially copyable types, the value representation is a set of bits in the object\n  representation that determines a value, which is one discrete element of an implementation-de\ufb01ned set of\n  values. <sup>42</sup><br/>\n  42) The intent is that the memory model of C++ is compatible with that of ISO/IEC 9899 Programming Language C.</p>\n</blockquote>\n<p>It gets particularly interesting when we read</p>\n<blockquote>\n<h3>3.8 Object lifetime [basic.life]</h3>\n<p id=\"so_11373203_11996970_5\">The lifetime of an object of type T begins when:\n  \u2014 storage with the proper alignment and size for type T is obtained, and\n  \u2014 if the object has non-trivial initialization, its initialization is complete.</p>\n</blockquote>\n<p>So for a primitive type (which <em>ipso facto</em> has trivial initialization) contained in a union, the lifetime of the object encompasses at least the lifetime of the union itself.  This allows us to invoke </p>\n<blockquote>\n<h3>3.9.2 Compound types [basic.compound]</h3>\n<p id=\"so_11373203_11996970_6\">If an object of type T is located at an address A, a pointer of type cv T* whose value is the\n  address A is said to point to that object, regardless of how the value was obtained.</p>\n</blockquote>\n<p>Assuming that the operation we are interested in is type-punning i.e. taking the value of a non-active union member, and given per the above that we have a valid reference to the object referred to by that member, that operation is lvalue-to-rvalue conversion:</p>\n<blockquote>\n<h3>4.1 Lvalue-to-rvalue conversion [conv.lval]</h3>\n<p id=\"so_11373203_11996970_7\">A glvalue of a non-function, non-array type <code>T</code> can be converted to a prvalue.\n  If <code>T</code> is an incomplete type, a program that necessitates this conversion is ill-formed. <strong>If the object to which the glvalue refers is not an object of type <code>T</code> and is not an object of a type derived from <code>T</code>, or if the object is uninitialized, a program that necessitates this conversion has unde\ufb01ned behavior.</strong></p>\n</blockquote>\n<p>The question then is whether an object that is a non-active union member is initialized by storage to the active union member.  As far as I can tell, this is not the case and so although if:</p>\n<ul>\n<li>a union is copied into <code>char</code> array storage and back (3.9:2), or</li>\n<li>a union is bytewise copied to another union of the same type (3.9:3), or</li>\n<li>a union is accessed across language boundaries by a program element conforming to ISO/IEC 9899 (so far as that is defined) (3.9:4 note 42), then</li>\n</ul>\n<p>the access to a union by a non-active member <em>is defined</em> and is defined to follow the object and value representation, access without one of the above interpositions is undefined behaviour.  This has implications for the optimisations allowed to be performed on such a program, as the implementation may of course assume that undefined behaviour does not occur.</p>\n<p>That is, although we can legitimately form an lvalue to a non-active union member (which is why assigning to a non-active member without construction is ok) it is considered to be uninitialized.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "103167", "LastEditDate": "2013-07-24T00:58:32.237", "Id": "11996970", "Score": "94", "CreationDate": "2012-08-16T23:41:10.043", "LastActivityDate": "2013-07-24T00:58:32.237"}});