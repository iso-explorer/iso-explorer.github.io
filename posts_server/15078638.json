post_cb({"15217020": {"Id": "15217020", "PostTypeId": "2", "Body": "<p>Semantically, <strong>passing</strong> between <code>unsigned char *</code> and <code>char *</code> are safe, and even though casting between them, so as in c++.  </p>\n<p>However, consider the following sample code: </p>\n<pre><code>#include \"stdio.h\"\n\nvoid process_unsigned(unsigned char *data_in, int data_len) {\n    int i=data_len;\n    unsigned short product=1;\n\n    for(; i--; product*=data_in[i]) \n        ;\n\n    for(i=sizeof(product); i--; ) {\n        data_in[i]=((unsigned char *)&amp;product)[i];\n        printf(\"%d\\r\\n\", data_in[i]);\n    }\n}\n\nvoid process(char *data_in, int data_len) {\n    int i=data_len;\n    unsigned short product=1;\n\n    for(; i--; product*=data_in[i]) \n        ;\n\n    for(i=sizeof(product); i--; ) {\n        data_in[i]=((unsigned char *)&amp;product)[i];\n        printf(\"%d\\r\\n\", data_in[i]);\n    }\n}\n\nvoid main() {\n    unsigned char \n        a[]={1, -1}, \n        b[]={1, -1};\n\n    process_unsigned(a, sizeof(a));\n    process(b, sizeof(b));\n    getch();\n}\n</code></pre>\n<p>output:</p>\n<pre>\n0\n255\n-1\n-1\n</pre>\n<p>All the code inside <code>process_unsigned</code> and <code>process</code> are just <strong>IDENTICAL</strong>. The only difference is unsigned and signed. This sample shows that the code in the <strong>black box</strong>, do be affected by the <strong>SIGN</strong>, and <strong>nothing</strong> is guaranteed between the callee and caller. </p>\n<p>Thus I would say that, it's applicable of <strong>passing</strong> only, but none of any other possibilities is guaranteed. </p>\n", "LastEditorUserId": "927012", "LastActivityDate": "2013-03-05T06:25:26.720", "Score": "1", "CreationDate": "2013-03-05T06:13:22.790", "ParentId": "15078638", "CommentCount": "0", "OwnerUserId": "927012", "LastEditDate": "2013-03-05T06:25:26.720"}, "15255085": {"Id": "15255085", "PostTypeId": "2", "Body": "<p>Yes, you can always convert from char to unsigned char &amp; <em>vice versa</em> without problems. If you run the following code, and compare it with an ASCII table (ref. <a href=\"http://www.asciitable.com/\" rel=\"nofollow\">http://www.asciitable.com/</a>), you can see a proof by yourself, and how the C/C++ deal with the conversions - they deal exactly in the same way:</p>\n<pre><code>#include \"stdio.h\"\n\n\nint main(void) {\n    //converting from char to unsigned char\n    char c = 0;\n    printf(\"%d byte(s)\\n\", sizeof(char));  // result: 1byte, i.e. 8bits, so there are 2^8=256 values that a char can store.\n    for (int i=0; i&lt;256; i++){\n        printf(\"int value: %d - from: %c\\tto: %c\\n\", c,  c, (unsigned char) c);\n        c++;\n    }\n\n    //converting from unsigned char to char\n    unsigned char uc = 0;\n    printf(\"\\n%d byte(s)\\n\", sizeof(unsigned char));\n    for (int i=0; i&lt;256; i++){\n        printf(\"int value: %d - from: %c\\tto: %c\\n\", uc, uc, (char) uc);\n        uc++;\n    }\n}\n</code></pre>\n<p>I will not post the output because it has too many lines! It can be noticed in the output that in the first half of each section, i.e. from i=0:127, the conversion from chars to unsigned chars and <em>vice-versa</em> works well, without any modification or loss.</p>\n<p>However, from i=128:255 the chars and the unsigned chars cannot be casted, or you would have different outputs, because unsigned char saves the values from [0:256] and char saves the values in the interval [-128:127]). Nevertheless, the behaviour in this 2nd half is irrelevant, because in C/C++, in general, you only lead with chars/unsigned chars as ASCII characters, whose can take only 128 different values and the other 128 values (positive for chars or negative for unsigned chars) are never used.</p>\n<p>If you never put a value in a char that doesn't represent a character, and you never put a value in an unsigned char that doesn't represent a character, everything will be OK!</p>\n<p>extra: even if you use UTF-8 or other encodings (for special characters) in your strings with C/C++, everything with this kind of casts would be OK, for instance, using UTF-8 encoding (ref. <a href=\"http://lwp.interglacial.com/appf_01.htm\" rel=\"nofollow\">http://lwp.interglacial.com/appf_01.htm</a>):</p>\n<pre><code>char hearts[]   = {0xe2, 0x99, 0xa5, 0x00};\nchar diamonds[] = {0xe2, 0x99, 0xa6, 0x00};\nchar clubs[]    = {0xe2, 0x99, 0xa3, 0x00};\nchar spades[]   = {0xe2, 0x99, 0xa0, 0x00};\nprintf(\"hearts (%s)\\ndiamonds (%s)\\nclubs (%s)\\nspades (%s)\\n\\n\", hearts, diamonds, clubs, spades);\n</code></pre>\n<p>the output of that code will be:\n<br/>hearts (\u2665)\n<br/>diamonds (\u2666)\n<br/>clubs (\u2663)\n<br/>spades (\u2660)</p>\n<p>even if you cast each of its chars to unsigned chars.</p>\n<p>so:</p>\n<ul>\n<li><p>\"can I always safely pass a unsigned char * into this function?\"\nyes!</p></li>\n<li><p>\"is it guaranteed that I can safely convert (cast) between char and unsigned char at will, without any loss of information?\"\nyes!</p></li>\n<li><p>\"can I safely convert (cast) between pointers to char and unsigned char at will, without any loss of information?\"\nyes!</p></li>\n<li><p>\"is the answer same in C and C++?\"\nyes!</p></li>\n</ul>\n", "LastEditorUserId": "2097703", "LastActivityDate": "2013-03-07T02:17:17.257", "Score": "1", "CreationDate": "2013-03-06T18:24:28.087", "ParentId": "15078638", "CommentCount": "0", "OwnerUserId": "2097703", "LastEditDate": "2013-03-07T02:17:17.257"}, "15172708": {"Id": "15172708", "PostTypeId": "2", "Body": "<p>You really need to view the code to <code>process()</code> to know if you can safely pass in unsigned characters.  If the function uses the characters as an index into an array, then no, you can't use unsigned data.</p>\n", "LastActivityDate": "2013-03-02T09:06:16.043", "CommentCount": "0", "CreationDate": "2013-03-02T09:06:16.043", "ParentId": "15078638", "Score": "1", "OwnerUserId": "2044923"}, "bq_ids": {"n4140": {"so_15078638_15172304_0": {"length": 14, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_15078638_15172304_0": {"length": 14, "quality": 1.0, "section_id": 6983}}, "n4659": {"so_15078638_15172304_0": {"length": 14, "quality": 1.0, "section_id": 8748}}}, "15078669": {"Id": "15078669", "PostTypeId": "2", "Body": "<p><code>unsigned char</code> or <code>signed char</code> is just interpretation: there is no conversion happening.</p>\n<p>Since you are processing bytes, to show intent, it would be better to declare as</p>\n<pre><code>void process(unsigned char *data_in, int data_len);\n</code></pre>\n<p>[As noted by an editor: A plain <code>char</code> may be either a signed or an unsigned type. The C and C++ standards explicitly allow either (it is always a separate type from either <code>unsigned char</code> or <code>signed char</code>, but has the same range as one of them)]</p>\n", "LastEditorUserId": "16076", "LastActivityDate": "2013-02-25T23:52:56.867", "Score": "13", "CreationDate": "2013-02-25T23:39:16.507", "ParentId": "15078638", "CommentCount": "2", "OwnerUserId": "16076", "LastEditDate": "2013-02-25T23:52:56.867"}, "15172304": {"Id": "15172304", "PostTypeId": "2", "Body": "<p>The short answer is yes if you use an explicit cast, but to explain it in detail, there are three aspects to look at:</p>\n<p><strong>1) Legality of the conversion</strong><br>\nConverting between <code>signed T*</code> and <code>unsigned T*</code> (for some type <code>T</code>) in either direction is generally possible because the source type can first be converted to <code>void *</code> (this is a standard conversion, \u00a74.10), and the <code>void *</code> can be converted to the destination type using an explicit <code>static_cast</code> (\u00a75.2.9/13):</br></p>\n<pre><code>static_cast&lt;unsigned char*&gt;(static_cast&lt;void *&gt;(data_in))\n</code></pre>\n<p>This can be abbreviated (\u00a75.2.10/7) as</p>\n<pre><code>reinterpret_cast&lt;unsigned char *&gt;(data_in)\n</code></pre>\n<p>because <code>char</code> is a standard-layout type (\u00a73.9.1/7,8 and \u00a73.9/9) and signedness does not change alignment (\u00a73.9.1/1). It can also be written as a C-style cast:</p>\n<pre><code>(unsigned char *)(data_in)\n</code></pre>\n<p>Again, this works both ways, from <code>unsigned*</code> to <code>signed*</code> and back. There is also a guarantee that if you apply this procedure one way and then back, the pointer value (i.e. the address it's pointing to) won't have changed (\u00a75.2.10/7).</p>\n<p>All of this applies not only to conversions between <code>signed char *</code> and <code>unsigned char *</code>, but also to <code>char *</code>/<code>unsigned char *</code> and <code>char *</code>/<code>signed char *</code>, respectively. (<code>char</code>, <code>signed char</code> and <code>unsigned char</code> are formally three distinct types, \u00a73.9.1/1.)</p>\n<p>To be clear, it doesn't matter which of the three cast-methods you use, but you must use one. Merely passing the pointer will not work, as the conversion, while legal, is not a standard conversion, so it won't be performed implicitly (the compiler will issue an error if you try).</p>\n<p><strong>2) Well-definedness of the access to the values</strong><br>\nWhat happens if, inside the function, you dereference the pointer, i.e. you perform <code>*data_in</code> to retrieve a glvalue for the underlying character; is this well-defined and legal? The relevant rule here is the strict-aliasing rule (\u00a73.10/10):</br></p>\n<blockquote>\n<p id=\"so_15078638_15172304_0\">If a program attempts to access the stored value of an object through a <em>glvalue</em> of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>[...]  </li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,  </li>\n<li>[...]  </li>\n<li>a <code>char</code> or <code>unsigned char</code> type.</li>\n</ul>\n</blockquote>\n<p>Therefore, accessing a <code>signed char</code> (or <code>char</code>) through an <code>unsigned char*</code> (or <code>char</code>) and vice versa is not disallowed by this rule \u2013 you should be able to do this without problems.</p>\n<p><strong>3) Resulting values</strong><br>\nAfter derefencing the type-converted pointer, will you be able to work with the value you get? It's important to bear in mind that the conversion and dereferencing of the pointer described above amounts to reinterpreting (not changing!) the bit pattern stored at the address of the character. So what happens when a bit pattern for a signed character is interpreted as that of an unsigned character (or vice versa)?</br></p>\n<p>When going from unsigned to signed, the <em>typical effect</em> will be that for values between 0 and 128 nothing happens, and values above 128 become negative. Similar in reverse: When going from signed to unsigned, negative values will appear as values greater than 128.</p>\n<p>But this behaviour <em>isn't actually guaranteed</em> by the Standard. The only thing the Standard guarantees is that for all three types, <code>char</code>, <code>unsigned char</code> and <code>signed char</code>, all bits (not necessarily 8, btw) are used for the value representation. So if you interpret one as the other, make a few copies and then store it back to the original location, you can be sure that there will be no information loss (as you required), but you won't necessarily know what the values actually mean (at least not in a fully portable way).</p>\n", "LastActivityDate": "2013-03-02T08:11:05.593", "CommentCount": "9", "CreationDate": "2013-03-02T08:11:05.593", "ParentId": "15078638", "Score": "61", "OwnerUserId": "777186"}, "15078831": {"Id": "15078831", "PostTypeId": "2", "Body": "<p>You can pass a pointer to a different kind of <code>char</code>, but you may need to explicitly cast it. The pointers are guaranteed to be the same size and the same values. There isn't going to be any information loss during the conversion.</p>\n<p>If you want to convert <code>char</code> to <code>unsigned char</code> inside the function, you just assign a <code>char</code> value to an <code>unsigned char</code> variable or cast the <code>char</code> value to <code>unsigned char</code>.</p>\n<p>If you need to convert <code>unsigned char</code> to <code>char</code> without data loss, it's a bit harder, but still possible:</p>\n<pre><code>#include &lt;limits.h&gt;\n\nchar uc2c(unsigned char c)\n{\n#if CHAR_MIN == 0\n  // char is unsigned\n  return c;\n#else\n  // char is signed\n  if (c &lt;= CHAR_MAX)\n    return c;\n  else\n    // ASSUMPTION 1: int is larger than char\n    // ASSUMPTION 2: integers are 2's complement\n    return c - CHAR_MAX - 1 - CHAR_MAX - 1;\n#endif\n}\n</code></pre>\n<p>This function will convert <code>unsigned char</code> to <code>char</code> in such a way that the returned value can be converted back to the same <code>unsigned char</code> value as the parameter.</p>\n", "LastActivityDate": "2013-02-25T23:53:36.417", "CommentCount": "11", "CreationDate": "2013-02-25T23:53:36.417", "ParentId": "15078638", "Score": "2", "OwnerUserId": "968261"}, "15078638": {"ViewCount": "31520", "Body": "<p>I want to use a function that expects data like this:</p>\n<pre><code>void process(char *data_in, int data_len);\n</code></pre>\n<p>So it's just processing some bytes really.</p>\n<p>But I'm more comfortable working with \"unsigned char\" when it comes to raw bytes (it somehow \"feels\" more right to deal with positive 0 to 255 values only), so my question is:</p>\n<p>Can I always safely pass a <code>unsigned char *</code> into this function?</p>\n<p>In other words:</p>\n<ul>\n<li>Is it guaranteed that I can safely convert  (cast) between char and unsigned char at will, without any loss of information?</li>\n<li>Can I safely convert (cast) between pointers to char and unsigned char at will, without any loss of information?</li>\n</ul>\n<p>Bonus: Is the answer same in C and C++?</p>\n", "AcceptedAnswerId": "15172304", "Title": "Can I turn unsigned char into char and vice versa?", "CreationDate": "2013-02-25T23:37:14.683", "Id": "15078638", "CommentCount": "1", "FavoriteCount": "14", "PostTypeId": "1", "LastEditDate": "2013-03-02T00:22:08.793", "LastEditorUserId": "2015453", "LastActivityDate": "2013-03-07T02:17:17.257", "Score": "39", "OwnerUserId": "2015453", "Tags": "<c++><c>", "AnswerCount": "6"}});