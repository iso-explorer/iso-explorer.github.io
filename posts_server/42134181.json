post_cb({"42134481": {"ParentId": "42134181", "CommentCount": "0", "Body": "<p>Dereferencing a pointer of type <code>son*</code> when it doesn't point to an object of type or derived from <code>son</code> (i.e. the pointed object has an incompatible type) has undefined behaviour.</p>\n<blockquote>\n<p id=\"so_42134181_42134481_0\">How come mother object is able to ...</p>\n</blockquote>\n<p>The behaviour is undefined.</p>\n", "OwnerUserId": "2079303", "PostTypeId": "2", "Id": "42134481", "Score": "2", "CreationDate": "2017-02-09T10:41:12.883", "LastActivityDate": "2017-02-09T10:41:12.883"}, "42134629": {"ParentId": "42134181", "CommentCount": "0", "Body": "<p>Your code has undefined behavior because you attempt to access the object of type <code>mother</code> through type <code>son</code> which is not the dynamic type of the object. </p>\n<p>More precisely, <a href=\"http://eel.is/c++draft/basic.lval#8\" rel=\"nofollow noreferrer\">[basic.lval]</a> in the standard says:</p>\n<blockquote>\n<p id=\"so_42134181_42134629_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:<sup>56</sup></p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or non-static data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a char or unsigned char type. </li>\n</ul>\n</blockquote>\n<p>Quoting <a href=\"http://en.cppreference.com/w/cpp/language/ub\" rel=\"nofollow noreferrer\">cppreference.com</a>:</p>\n<blockquote>\n<p id=\"so_42134181_42134629_1\"><em>undefined behavior</em> - there are no restrictions on the behavior of the program. Examples of undefined behavior are memory accesses outside of array bounds, signed integer overflow, null pointer dereference, modification of the same scalar more than once in an expression without sequence points, access to an object through a pointer of a different type, etc. Compilers are not required to diagnose undefined behavior (although many simple situations are diagnosed), and the compiled program is not required to do anything meaningful.</p>\n</blockquote>\n", "OwnerUserId": "3919155", "PostTypeId": "2", "Id": "42134629", "Score": "3", "CreationDate": "2017-02-09T10:48:00.270", "LastActivityDate": "2017-02-09T10:48:00.270"}, "bq_ids": {"n4140": {"so_42134181_42134629_0": {"section_id": 7239, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_42134181_42134629_0": {"section_id": 6983, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_42134181_42134629_0": {"section_id": 8748, "quality": 0.9285714285714286, "length": 13}}}, "42134181": {"CommentCount": "5", "ViewCount": "69", "PostTypeId": "1", "LastEditorUserId": "3919155", "CreationDate": "2017-02-09T10:28:34.683", "LastActivityDate": "2017-02-09T15:22:46.940", "Title": "C++ typecasting with multiple inheritance", "LastEditDate": "2017-02-09T15:22:46.940", "Id": "42134181", "Score": "1", "Body": "<p>How come the <code>mother</code> object is able to call <code>father</code>'s function upon typecasting to <code>son</code>?</p>\n<p>Here the <code>father</code> object is not created then how come <code>drive()</code> function is getting called. Sorry for novice question.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n#include &lt;iostream&gt;\nusing namespace std;\nclass father\n{\n    public:\n    void drive(){cout&lt;&lt;\"Driving\";}\n};\nclass mother\n{\n    public:\n    void cook(){cout&lt;&lt;\"Cooking\";}\n};\nclass son: public father, public mother\n{\n\n};\nint main() {\n    // your code goes here\n    mother *m = new mother();\n    son* s = static_cast&lt;son *&gt;(m);\n    s-&gt;drive();\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><casting><multiple-inheritance>", "OwnerUserId": "7182668", "AnswerCount": "2"}});