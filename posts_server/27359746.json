post_cb({"bq_ids": {"n4140": {"so_27359746_27360064_0": {"length": 15, "quality": 0.9375, "section_id": 300}}, "n3337": {"so_27359746_27360064_0": {"length": 15, "quality": 0.9375, "section_id": 291}}, "n4659": {"so_27359746_27360064_0": {"length": 15, "quality": 0.9375, "section_id": 307}}}, "27360064": {"Id": "27360064", "PostTypeId": "2", "Body": "<p>SFINAE is applicable only in an <a href=\"https://stackoverflow.com/q/15260685/3953764\"><em>immediate context</em></a> (SFINAE = SFIICINAE, <em>Substitution Failure In Immediate Context Is Not An Error</em>):</p>\n<p>\u00a714.8.2 [temp.deduct]/p8:</p>\n<blockquote>\n<p id=\"so_27359746_27360064_0\">Only invalid types and expressions in the immediate context of the function type and its template parameter types can result in a deduction failure.</p>\n</blockquote>\n<p>A substitution of class template parameters in a member function's declaration is not an immediate context, and results in <em>hard</em> error on failure.</p>\n<p>You can either <em>partially-specialize</em> entire class depending on the type, or introduce an immediate context yourself by adding a template parameters to the member function template itself, so that a substitution failure can result in <em>soft</em> error:</p>\n<pre><code>template &lt;typename U = T, typename std::enable_if&lt;std::is_signed&lt;U&gt;{}, int&gt;::type = 0&gt;\ntest &amp;operator&lt;&lt;=(int value)\n{ return *this; }\n\ntemplate &lt;typename U = T, typename std::enable_if&lt;std::is_unsigned&lt;U&gt;{}, int&gt;::type = 0&gt;\ntest &amp;operator&lt;&lt;=(int value)\n{ return *this; }\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-08T20:38:28.117", "Score": "5", "CreationDate": "2014-12-08T14:22:24.233", "ParentId": "27359746", "CommentCount": "0", "OwnerUserId": "3953764", "LastEditDate": "2017-05-23T12:33:02.880"}, "27359746": {"ViewCount": "165", "Body": "<p>I can't understand why the following code is not working. compiler (gcc) seems to instanciate both\nmethods and obviously integer is either signed or unsigned, so one always fails. I though enable_if was here to avoid that.</p>\n<p>Q: why the compile error, and how to avoid it ?</p>\n<pre><code>using namespace boost; // or std as you want\n\ntemplate&lt;typename T&gt;\nstruct test {\n    // if signed\n    template&lt; typename enable_if\n                        &lt; is_signed&lt;T&gt;\n                        , int\n                        &gt;:: type = 0\n            &gt;\n    test &amp;operator&lt;&lt;=(int value)\n    {}\n\n    // if unsigned\n    template&lt; typename enable_if\n                        &lt; is_unsigned&lt;T&gt;\n                        , int\n                        &gt;:: type = 0\n            &gt; \n    test &amp;operator&lt;&lt;=(int value)\n    {}\n};\n\nvoid foo()\n{\n    test&lt;int&gt; x;\n    x &lt;&lt; 1;            // COMPILE ERROR no type named 'type' in struct enable_if&lt;unsigned&gt; etc.\n    test&lt;unsigned&gt; y;\n    y &lt;&lt; 1;            // COMPILE ERROR no type named 'type' in struct enable_if&lt;int&gt; etc.\n}\n</code></pre>\n", "Title": "enable_if and mutually exclusive methods", "CreationDate": "2014-12-08T14:06:17.103", "LastActivityDate": "2014-12-08T23:00:38.347", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-12-08T23:00:38.347", "LastEditorUserId": "2141196", "Id": "27359746", "Score": "4", "OwnerUserId": "2141196", "Tags": "<c++><metaprogramming><enable-if>", "AnswerCount": "1"}});