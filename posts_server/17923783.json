post_cb({"17925300": {"ParentId": "17923783", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Contrary to what the other answers state, from a <em>practical</em> point of view there is a huge difference, although there might not be such a difference in the standard.</p>\n<p>From the standard point of view, <code>reinterpret_cast</code> is only guaranteed to work for roundtrip conversions and only if the alignment requirements of the intermediate pointer type are not stronger than those of the source type. You are not allowed <sup>(*)</sup> to read through one pointer and read from another pointer type. </p>\n<p>At the same time, the standard requires similar behavior from unions, it is undefined behavior to read out of a union member other than the active one (the member that was last written to)<sup>(+)</sup>.</p>\n<p>Yet compilers often provide additional guarantees for the union case, and all compilers I know of (VS, g++, clang++, xlC_r, intel, Solaris CC) guarantee that you can read out of an union through an inactive member and that it will produce a value with exactly the same bits set as those that were written through the active member.</p>\n<p>This is particularly important with high optimizations when reading from network:</p>\n<pre><code>double ntohdouble(const char *buffer) {          // [1]\n   union {\n      int64_t   i;\n      double    f;\n   } data;\n   memcpy(&amp;data.i, buffer, sizeof(int64_t));\n   data.i = ntohll(data.i);\n   return data.f;\n}\ndouble ntohdouble(const char *buffer) {          // [2]\n   int64_t data;\n   double  dbl;\n   memcpy(&amp;data, buffer, sizeof(int64_t));\n   data = ntohll(data);\n   dbl = *reinterpret_cast&lt;double*&gt;(&amp;data);\n   return dbl;\n}\n</code></pre>\n<p>The implementation in [1] is sanctioned by all compilers I know (gcc, clang, VS, sun, ibm, hp), while the implementation in [2] is not and will <em>fail</em> horribly in some of them when aggressive optimizations are used. In particular, I have seen gcc reorder the instructions and <em>read</em> into the <code>dbl</code> variable before evaluating <em>ntohl</em>, thus producing the wrong results.</p>\n<hr>\n<p><sup>(*)</sup> With the exception that you are always allowed to <em>read</em> from a <code>[signed|unsigned] char*</code> regardless of that the real object (original pointer type) was.</p>\n<p><sup>(+)</sup> Again with some exceptions, if the active member shares a common prefix with another member, you can read through the <em>compatible</em> member that prefix.</p>\n</hr>", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2013-07-29T13:31:34.313", "Id": "17925300", "Score": "8", "CreationDate": "2013-07-29T13:24:29.110", "LastActivityDate": "2013-07-29T13:31:34.313"}, "17924309": {"ParentId": "17923783", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>There are some technical differences between a proper <code>union</code> and a (let's assume) a proper and safe <code>reinterpret_cast</code>.  However, I can't think of any of these differences which cannot be overcome.  </p>\n<p>The <em>real</em> reason to prefer a <code>union</code> over <code>reinterpret_cast</code> in my opinion isn't a technical one.  It's for documentation.</p>\n<p>Supposing you are designing a bunch of classes to represent a wire protocol (which I guess is the most common reason to use type-punning in the first place), and that wire protocol consists of many messages, submessages and fields.  If some of those fields are common, such as msg type, seq#, etc, using a union simplifies tying these elements together and helps to document exactly how the protocol appears on the wire.</p>\n<p>Using <code>reinterpret_cast</code> does the same thing, obviously, but in order to really know what's going on you have to examine the code that advances from one packet to the next.  Using a <code>union</code> you can just take a look at the header and get an idea what's going on.</p>\n", "OwnerUserId": "241536", "LastEditorUserId": "241536", "LastEditDate": "2013-07-29T12:45:47.700", "Id": "17924309", "Score": "5", "CreationDate": "2013-07-29T12:39:38.043", "LastActivityDate": "2013-07-29T12:45:47.700"}, "17923783": {"CommentCount": "29", "AcceptedAnswerId": "17925300", "PostTypeId": "1", "LastEditorUserId": "718379", "CreationDate": "2013-07-29T12:16:13.040", "LastActivityDate": "2016-10-28T11:37:08.903", "LastEditDate": "2014-05-07T15:07:47.567", "ViewCount": "608", "FavoriteCount": "2", "Title": "What is the difference between a proper defined union and a reinterpret_cast?", "Id": "17923783", "Score": "11", "Body": "<p>Can you propose at least 1 scenario where there is a substantial difference between</p>\n<pre><code>union {\nT var_1;\nU var_2;\n}\n</code></pre>\n<p>and</p>\n<pre><code>var_2 = reinterpret_cast&lt;U&gt; (var_1)\n</code></pre>\n<p>?</p>\n<p>The more i think about this, the more they look like the same thing to me, at least from a practical viewpoint. </p>\n<p>One difference that I found is that while the union size is big as the biggest data type in terms of size, the reinterpret_cast as described in this post can lead to a truncation, so the plain old C-style union is even safer than a newer C++ casting.</p>\n<p>Can you outline the differences between this 2 ?</p>\n", "Tags": "<c++><unions><reinterpret-cast>", "OwnerUserId": "2485710", "AnswerCount": "4"}, "17923935": {"ParentId": "17923783", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>In C++11, union is <strong>class type</strong>, you can an hold a member with non-trivial member functions. You can't simply cast from one member to another.</p>\n<p>\u00a7 9.5.3</p>\n<p>[ Example: Consider the following union:</p>\n<pre><code>union U {\nint i;\nfloat f;\nstd::string s;\n};\n</code></pre>\n<blockquote>\n<p id=\"so_17923783_17923935_0\">Since std::string (21.3) declares non-trivial versions of all of the special member functions, U will have\n  an implicitly deleted default constructor, copy/move constructor, copy/move assignment operator, and destructor. To use U, some or all of these member functions must be user-provided. \u2014 end example ]</p>\n</blockquote>\n", "OwnerUserId": "951757", "LastEditorUserId": "72583", "LastEditDate": "2016-10-28T11:37:08.903", "Id": "17923935", "Score": "1", "CreationDate": "2013-07-29T12:23:13.033", "LastActivityDate": "2016-10-28T11:37:08.903"}, "17924242": {"ParentId": "17923783", "CommentCount": "7", "Body": "<p>From a practical point of view, they're most probably 100% identical, at least on real, non-fictional computers. You take the binary representation of one type and stuff it into another type.</p>\n<p>From a language lawyer point of view, using <code>reinterpret_cast</code> is well-defined for some occasions (e.g. pointer to integer conversions) and implementation-specific otherwise.</p>\n<p>Union type punning, on the other hand is very clearly undefined behaviour, always (though undefined does not necessarily mean \"doesn't work\"). The standard says that the value of at most one of the non-static data members can be stored in a union at any time. This means that if you set <code>var1</code> then <code>var1</code> is valid, but <code>var2</code> is not.<br>\nHowever, since <code>var1</code> and <code>var2</code> are stored at the same memory location, you can of course still read and write any of the types as you like, and assuming they have the same storage size, no bits are \"lost\".</br></p>\n", "OwnerUserId": "572743", "PostTypeId": "2", "Id": "17924242", "Score": "-1", "CreationDate": "2013-07-29T12:36:39.433", "LastActivityDate": "2013-07-29T12:36:39.433"}, "bq_ids": {"n4140": {"so_17923783_17923935_0": {"section_id": 5915, "quality": 0.9032258064516129, "length": 28}}, "n3337": {"so_17923783_17923935_0": {"section_id": 5687, "quality": 0.9032258064516129, "length": 28}}, "n4659": {"so_17923783_17923935_0": {"section_id": 7407, "quality": 0.9032258064516129, "length": 28}}}});