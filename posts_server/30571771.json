post_cb({"30571897": {"ParentId": "30571771", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I hate to say this, but MSVC is right and <a href=\"http://coliru.stacked-crooked.com/a/cd7dd3ef7958315b\" rel=\"nofollow\">gcc 5.1</a> and <a href=\"http://coliru.stacked-crooked.com/a/a3fbcb9d4c28a4f0\" rel=\"nofollow\">clang 3.6</a> are wrong! To simplify, we're calling:</p>\n<pre><code>operator+(Num&lt;1&gt;, Num&lt;-1&gt;)\n</code></pre>\n<p>with overloads:</p>\n<pre><code>operator+(Num&lt;N&gt;, Num&lt;M&gt;)\noperator+(Num&lt;N&gt;, Num&lt;-N&gt;)\n</code></pre>\n<p>Both are obviously viable candidates. And, according to [over.match.best]:</p>\n<blockquote>\n<p id=\"so_30571771_30571897_0\">Given these definitions, a viable function <code>F1</code> is defined to be a better function than another viable function\n  <code>F2</code> if for all arguments <code>i</code>, ICS<sub><em>i</em></sub>(<code>F1</code>) is not a worse conversion sequence than ICS<sub><em>i</em></sub>(<code>F2</code>), and then</p>\n<ul>\n<li>[...]</li>\n<li><code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized\n  than the template for <code>F2</code> according to the partial ordering rules described in 14.5.6.2.</li>\n</ul>\n</blockquote>\n<p>The rules for determining partial ordering boil down to: for every template parameter, synthesize a new type/value and try to call the other overload with it. For the first overload, it becomes <code>operator+(Num&lt;A&gt;, Num&lt;B&gt;)</code>, with which you cannot call <code>operator+(Num&lt;N&gt;, Num&lt;-N&gt;)</code>. However, the second overload becomes <code>operator+(Num&lt;C&gt;, Num&lt;-C&gt;)</code>, with which you <em>can</em> call the first overload. </p>\n<p>Thus, the overload taking <code>Num&lt;-N&gt;</code> is more specialized than the overload taking <code>Num&lt;M&gt;</code>, so it should be preferred unambiguously. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-06-01T11:11:23.033", "Id": "30571897", "Score": "4", "CreationDate": "2015-06-01T11:06:12.007", "LastActivityDate": "2015-06-01T11:11:23.033"}, "30571771": {"CommentCount": "2", "ViewCount": "256", "CreationDate": "2015-06-01T11:00:08.227", "LastActivityDate": "2015-06-01T11:11:23.033", "Title": "Ambiguous overload in gcc, fine with msvc", "AcceptedAnswerId": "30571897", "PostTypeId": "1", "Id": "30571771", "Score": "4", "Body": "<p>The following code compiles fine with msvc 18.00 but fails with gcc 4.9.1:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;int N&gt; class Num { };\n\nclass Zero { };\n\ntemplate &lt;int N, int M&gt;\nNum&lt;N + M&gt; operator+(Num&lt;N&gt;, Num&lt;M&gt;)\n{\n  return {};\n}\n\ntemplate &lt;int N&gt;\nZero operator+(Num&lt;N&gt;, Num&lt;-N&gt;)\n{\n  return {};\n}\n\nint main()\n{\n  Num&lt;1&gt; one;\n  Num&lt;-1&gt; mone;\n  Num&lt;0&gt; null;\n\n  auto a = one + one;\n  static_assert(std::is_same&lt;decltype(a), Num&lt;2&gt;&gt;::value, \":(\");\n\n  auto b = one + mone;\n  static_assert(std::is_same&lt;decltype(b), Zero&gt;::value, \":(\");\n\n  auto c = null + null;\n  static_assert(std::is_same&lt;decltype(c), Zero&gt;::value, \":(\");\n}\n</code></pre>\n<p>gcc's error message is:</p>\n<pre><code>ambiguous.cpp: In function 'int main()':\nambiguous.cpp:28:16: error: ambiguous overload for 'operator+' (operand types are 'Num&lt;1&gt;' and 'Num&lt;-1&gt;')\n   auto b = one + mone;\n                ^\nambiguous.cpp:28:16: note: candidates are:\nambiguous.cpp:8:12: note: Num&lt;(N + M)&gt; operator+(Num&lt;N&gt;, Num&lt;M&gt;) [with int N = 1; int M = -1]\n Num&lt;N + M&gt; operator+(Num&lt;N&gt;, Num&lt;M&gt;)\n            ^\nambiguous.cpp:14:6: note: Zero operator+(Num&lt;N&gt;, Num&lt;(- N)&gt;) [with int N = 1]\n Zero operator+(Num&lt;N&gt;, Num&lt;-N&gt;)\n      ^\nambiguous.cpp:29:47: error: template argument 1 is invalid\n   static_assert(std::is_same&lt;decltype(b), Zero&gt;::value, \":(\");\n                                               ^\nambiguous.cpp:31:17: error: ambiguous overload for 'operator+' (operand types are 'Num&lt;0&gt;' and 'Num&lt;0&gt;')\n   auto c = null + null;\n                 ^\nambiguous.cpp:31:17: note: candidates are:\nambiguous.cpp:8:12: note: Num&lt;(N + M)&gt; operator+(Num&lt;N&gt;, Num&lt;M&gt;) [with int N = 0; int M = 0]\n Num&lt;N + M&gt; operator+(Num&lt;N&gt;, Num&lt;M&gt;)\n            ^\nambiguous.cpp:14:6: note: Zero operator+(Num&lt;N&gt;, Num&lt;(- N)&gt;) [with int N = 0]\n Zero operator+(Num&lt;N&gt;, Num&lt;-N&gt;)\n      ^\nambiguous.cpp:32:47: error: template argument 1 is invalid\n   static_assert(std::is_same&lt;decltype(c), Zero&gt;::value, \":(\");\n                                               ^\n</code></pre>\n<p>Which compiler is right?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "1463557", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_30571771_30571897_0": {"section_id": 603, "quality": 0.85, "length": 17}}, "n3337": {"so_30571771_30571897_0": {"section_id": 593, "quality": 0.85, "length": 17}}, "n4659": {"so_30571771_30571897_0": {"section_id": 629, "quality": 0.85, "length": 17}}}});