post_cb({"36578736": {"ParentId": "36578111", "CommentCount": "2", "Body": "<p>I think i am obligated to point this out. \n<em>What you are trying to do should be avoided at all costs.</em> You are trying too manipulate the syntax of the language itself too mimic another's. And you are doing this because you're more comfortable with using another syntax for an <strong>if statement</strong>. You can't think like this, at one point this code will be seen by someone else, and they will be utterly confused when they are seeing this weird syntax. If i saw such things in any c++ library that i was going to use i would simply not use it and never worry about it again.  </p>\n<p>Maybe you decide to name all your variables in camel case, or maybe you think that you should omit the padded whitespace before a <code>private</code>, <code>protected</code>, or <code>public</code> specifier, or maybe you just like putting all your brackets on a new line. That's when you should say:</p>\n<blockquote>\n<p id=\"so_36578111_36578736_0\">...I like using the following...</p>\n</blockquote>\n<p>But when you decide that you don't like how the language reads an <code>if-statement</code> or a function declaration, you have to deal with it. Why? Because that's how it's done, that's how the language was written. What you're trying to do is equivalent to changing a letter of the English alphabet because you're more comfortable with the way the 's' looks in your native language. </p>\n<p>Whenever i see <code>&amp;&amp;</code> i think one of three things, <code>r-value</code>, <code>universal ref</code>, and <code>AND</code>. Do i think of <code>if</code>? NO. Why should I, who says I have ever programmed in Perl before, hey how do you know if I am even familiar with such a syntax? </p>\n<p>So basically...  </p>\n<p><em>You're writing in c++, you're not writing in Perl.\nSomewhere along the lines you will have to write in a different language, will you then try to manipulate it's syntax as well? Will you even be able to do such a thing, where does this begin, where does it stop?</em></p>\n", "OwnerUserId": "6162032", "PostTypeId": "2", "Id": "36578736", "Score": "3", "CreationDate": "2016-04-12T16:12:20.640", "LastActivityDate": "2016-04-12T16:12:20.640"}, "36578207": {"ParentId": "36578111", "PostTypeId": "2", "CommentCount": "1", "Body": "<ol>\n<li><p>Yes it is legal. An expression followed by <code>;</code> is a valid statement.</p></li>\n<li><p>Some folk might find it obfuscating.</p></li>\n<li><p>It cannot be optimised out if there are side effects.</p></li>\n</ol>\n<p>Do be aware though that <code>&amp;&amp;</code> can be <em>overloaded</em> in C++. If it's overloaded then then the short-cutting property of the operator is discarded. <em>That</em> will cause strange effects. It's chiefly for this reason that I would advise against this style.</p>\n", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "LastEditDate": "2016-04-12T15:55:32.647", "Id": "36578207", "Score": "3", "CreationDate": "2016-04-12T15:47:59.457", "LastActivityDate": "2016-04-12T15:55:32.647"}, "36582337": {"ParentId": "36578111", "CommentCount": "0", "Body": "<p>I must confess that I use this technique because it often seems more succinct (at least to me and my colleagues) when coupled with the alternative operator representations.</p>\n<p>Consider this (contrived but indicative) example:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;stdexcept&gt;\n#include &lt;exception&gt;\n#include &lt;regex&gt;\n\nstruct invalid_number : std::logic_error\n{\n    using std::logic_error::logic_error;\n};\n\ntemplate&lt;class Excep, class...Args&gt;\n[[noreturn]]\nbool raise(Args&amp;&amp;...args)\n{\n  throw Excep(std::forward&lt;Args&gt;(args)...);\n}\n\nint parse_number(const std::string&amp; s)\ntry\n{\n  const std::regex re(\"^\\\\d+$\");\n  std::regex_match(s, re) or raise&lt;std::invalid_argument&gt;(s);\n  return std::stoi(s);\n}\ncatch(...)\n{\n  std::throw_with_nested(std::invalid_argument(__func__));\n}\n</code></pre>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "36582337", "Score": "1", "CreationDate": "2016-04-12T19:27:19.843", "LastActivityDate": "2016-04-12T19:27:19.843"}, "36578229": {"ParentId": "36578111", "CommentCount": "1", "Body": "<p>It's perfectly legal. From [expr.log.and]:</p>\n<blockquote>\n<p id=\"so_36578111_36578229_0\"><code>&amp;&amp;</code> guarantees left-to-right\n  evaluation: the second operand is not evaluated if the first operand is <code>false</code>.</p>\n</blockquote>\n<p><code>expr() &amp;&amp; fun()</code> is equivalent to <code>if (expr()) fun()</code> (assuming <code>fun()</code> returns something convertible to <code>bool</code>). That's an extremely important property when it comes to writing compound conditional expressions. For example, only dereferencing a pointer after we know it's valid:</p>\n<pre><code>if (ptr &amp;&amp; ptr-&gt;foo()) { ... }\n</code></pre>\n<p>That said, if what you really want is:</p>\n<pre><code>if (expr()) {\n    fun();\n}\n</code></pre>\n<p>just write that. The compiler will generate the same code either way, but the intent of what you're trying to do will be much clearer.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "36578229", "Score": "4", "CreationDate": "2016-04-12T15:48:48.190", "LastActivityDate": "2016-04-12T15:48:48.190"}, "bq_ids": {"n4140": {"so_36578111_36578229_0": {"section_id": 6163, "quality": 1.0, "length": 9}}, "n3337": {"so_36578111_36578229_0": {"section_id": 5924, "quality": 1.0, "length": 9}}, "n4659": {"so_36578111_36578229_0": {"section_id": 7660, "quality": 1.0, "length": 9}}}, "36578111": {"CommentCount": "3", "ViewCount": "88", "PostTypeId": "1", "LastEditorUserId": "4235797", "CreationDate": "2016-04-12T15:44:01.740", "LastActivityDate": "2016-04-12T19:27:19.843", "Title": "C++ condition without selection statement", "AcceptedAnswerId": "36578229", "LastEditDate": "2016-04-12T16:07:31.003", "Id": "36578111", "Score": "2", "Body": "<p>Maybe because of Perl influence, I like using the following syntax</p>\n<pre><code>condition &amp;&amp; do_something();\n</code></pre>\n<p>instead of</p>\n<pre><code>if ( condition )\n{\n  do_something();\n}\n</code></pre>\n<p>(I know I could put the latter in one row without braces, but that's not the point.)</p>\n<p>I've made several tests (below), which work.\nBut I couldn't find a reference in the standard, stating that it's legal.\nIt could be implied in </p>\n<ul>\n<li>5.14 Logical AND operator</li>\n<li>5.17 Assignment operators</li>\n<li>6.4. Selection statements</li>\n</ul>\n<p>but I'm not completely sure (I checked C++ 98, sorry to be old fashioned, but probably even C standard would suffice).</p>\n<p>NB: I do realize that in order to work, the last expression (do_something) has also to be be convertible to bool, which is not necessary for the selection statement. This is a serious restriction of course.</p>\n<p>So the questions are:</p>\n<ol>\n<li>Is it perfectly legal?</li>\n<li>Is there a reason not to use it?</li>\n<li>Are there possible side effects (like optimizations leading to unexpected results)?</li>\n</ol>\n<p>Apologies if turns out to be a duplicate, I couldn't find anything, but possibly because I didn't use the right keywords.</p>\n<pre><code>#include &lt;cassert&gt;\n\nbool sayYes()\n{\n  return true;\n}\n\nbool sayNo()\n{\n  return false;\n}\n\nint main( int args, char* argv[] )\n{\n  bool a = true;\n  bool b = false;\n  int i = 0;\n\n  a &amp;&amp; ( i = 1 );\n  assert( i == 1 );\n\n  !a &amp;&amp; ( i = 0 );\n  assert( i == 1 );\n\n  ( a || b ) &amp;&amp; ( i = 0 );\n  assert( i == 0 );\n\n  sayYes() &amp;&amp; ( i = 1 );\n  assert( i == 1 );\n\n  ( sayNo() || sayYes() ) &amp;&amp; ( i = 0 );\n  assert( i == 0 );\n\n  return 0;\n}\n</code></pre>\n", "Tags": "<c++><if-statement><expression><logical-operators>", "OwnerUserId": "4235797", "AnswerCount": "4"}});