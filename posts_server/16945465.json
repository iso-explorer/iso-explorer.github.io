post_cb({"bq_ids": {"n4140": {"so_16945465_16946035_0": {"section_id": 438, "quality": 1.0, "length": 29}}, "n3337": {"so_16945465_16946035_0": {"section_id": 429, "quality": 1.0, "length": 29}}, "n4659": {"so_16945465_16946035_0": {"section_id": 458, "quality": 1.0, "length": 29}}}, "16945772": {"ParentId": "16945465", "CommentCount": "1", "CreationDate": "2013-06-05T17:01:53.963", "OwnerUserId": "862231", "PostTypeId": "2", "Id": "16945772", "Score": "3", "Body": "<p>The key to remember is that constructors for virtual base classes are done as part of the most derived class initialization (and prior to the other base classes being constructed).  So your construction order slide is not correct.  </p>\n<p>In fact, what is happening when you construct the ProtocolConnection is that it first constructs the Socket, followed by the Connection (since you inherited it virtually), and finally the ProtcolSocket.</p>\n<p>To call the constructor of socket you want, you need to call its constructor as part of the ProtocolSocket member initializer list, as so</p>\n<pre><code>class ProtocolConnection: public ProtocolSocket, public virtual Connection\n{\n    public:\n    ProtocolConnection(int s, int ip) :\n        Socket(s), Connection(ip), ProtocolSocket(s)  \n        // Note, also reordered, since all virtual bases are initialized before the\n        // non-virtual bases\n    {\n        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    }\n};\n</code></pre>\n<p>Finally, as a note, I would recommend simplifying your inheritance hierarchy.  In particular, virtual inheritance and using multiple constructors complicates factors.</p>\n", "LastActivityDate": "2013-06-05T17:01:53.963"}, "16946035": {"ParentId": "16945465", "CommentCount": "0", "CreationDate": "2013-06-05T17:15:46.697", "OwnerUserId": "420683", "PostTypeId": "2", "Id": "16946035", "Score": "2", "Body": "<p>Inheritance DAG:</p>\n<pre><code>       ProtocolConnection\n           /        \\\n     non-virtual  virtual\n         /            \\\nProtocolSocket     Connection\n       |               |\n    virtual         virtual\n       |               |\n    Socket           Socket\n</code></pre>\n<p>Note there's only one <code>Socket</code> subobject in an object of type <code>ProtocolConnection</code> due to virtual inheritance.</p>\n<p>[class.base.init]/10</p>\n<blockquote>\n<p id=\"so_16945465_16946035_0\">First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class base-specifier-list.</p>\n</blockquote>\n<p>Initialization of virtual base classes is done via a depth-first left-to right traversal. The traversal order:</p>\n<pre><code>       (0) ProtocolConnection\n             /             \\\n           nv               v\n           /                 \\\n(1) ProtocolSocket    (3) Connection\n         |                   |\n         v                   nv\n         |                   |\n    (2) Socket         (4) Socket\n</code></pre>\n<p>Leads to an initialization order of:</p>\n<p>(2); (3); (1); (0)<br/>\n<code>Socket</code>; <code>Connection</code>; <code>ProtocolSocket</code> (non-virtual base class); <code>ProtocolConnection</code></p>\n<p>The most-derived class <code>ProtocolConnection</code> has to include the initalizers for <strong>all</strong> <em>virtual base classes</em>. If a virtual base class does not appear in the mem-initializer-list of the most-derived class, the subobject of this virtual base class will be default-constructed.</p>\n", "LastActivityDate": "2013-06-05T17:15:46.697"}, "16945465": {"CommentCount": "9", "ViewCount": "281", "PostTypeId": "1", "LastEditorUserId": "1412808", "CreationDate": "2013-06-05T16:43:33.483", "LastActivityDate": "2013-06-05T17:20:07.077", "Title": "virtual inheritance - skipping constructors", "AcceptedAnswerId": "16945772", "LastEditDate": "2013-06-05T17:20:07.077", "Id": "16945465", "Score": "1", "Body": "<p>I have the following classes:</p>\n<pre><code>class Socket\n{\n    Socket();\n    Socket( SOCKET s );\n};\n\nclass Connection : public virtual Socket\n{\n    Connection( IP ip );\n};\n</code></pre>\n<p>These two classes contain some pure virtual functions and some non-virtual functions and some of their own data.  The point of them is that I will derive a few socket types, implementing different protocols.</p>\n<p>So I specialize on these two classes:</p>\n<pre><code>class ProtocolSocket : public virtual Socket\n{\n    ProtocolSocket() {}\n    ProtocolSocket( SOCKET s ) : Socket( s ) { ; }\n};\n\nclass ProtocolConnection : public ProtocolSocket, public virtual Connection\n{\n    ProtocolConnection( SOCKET s, IP ip ) : ProtocolSocket( s ), Connection( ip ) {;}\n};\n</code></pre>\n<p>Something goes wrong - as I'm sure many of you can see. I try to create a ProtocolConnection:</p>\n<pre><code>new ProtocolConnection( s, ip );\n</code></pre>\n<p>Construction proceeds like this:</p>\n<pre><code>start ctor ProtocolConnection\n    start ctor Connection\n       start ctor Socket\n          Socket(); - default ctor via Connection's init list\n       end ctor Socket\n       Connection(); - default ctor ProtocolConnection's init list\n    end ctor Connection\n    start ctor ProtocolSocket\n       start ctor Socket     \n          // Socket( s ); - skipped!!! - would have been from init \n          //                list of ProtocolSocket, but ctor for this object \n          //                already called!\n       end ctor Socket\n       ProtocolSocket( s ); -from init list of ProtocolConnection()\n    end ctor ProtocolSocket\n    ProtocolConnection( s, ip );\nend ctor ProtocolConnection\n</code></pre>\n<p>Skipping that second Socket constructor is what the language specification says should happen, and for good reasons.</p>\n<p>How do I make it call the constructor with Socket( s ) called, instead of the earlier one?</p>\n<p>I intend to have multiple derived classes e.g. Also OtherProtocolSocket and OtherProcolConnection, at the same level as ProtocoSocket and ProtocolConnection objects.</p>\n<p>The effect I'm trying to achieve is I want to construct ProtocolSocket and ProtocolConnection objects, and then pass them around my system as Socket and Connection objects. So after I've made a socket the implements a given protocol, I just read and write to it, without worrying about the details of the underlying protocol.</p>\n<p>Connection objects need to inherit all the methods from Socket objects.</p>\n<p>@UPDATE:</p>\n<p>DyP suggest adding initializer for Socket in ProtocolConnection. This solves the problem. I'd give you an accept for that... but it was just in a comment.</p>\n", "Tags": "<c++>", "OwnerUserId": "1412808", "AnswerCount": "2"}});