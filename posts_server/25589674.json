post_cb({"25589764": {"ParentId": "25589674", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Either give <code>test</code> a move constructor:</p>\n<pre><code>test(test&amp;&amp;) = default;\n</code></pre>\n<p>or use direct initialization:</p>\n<pre><code>test a{item{10}};\n</code></pre>\n<p>There's no other workaround. Copy-initialization where destination type is a class type, such as <code>test a = item{10};</code>, always requires a callable copy or move constructor.</p>\n<hr>\n<p>The relevant rule is specified in \u00a78.5 [dcl.init]/p17:</p>\n<blockquote>\n<p id=\"so_25589674_25589764_0\">If the destination type is a (possibly cv-qualified) class type:</p>\n<ul>\n<li>If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source\n  type is the same class as, or a derived class of, the class of the\n  destination, constructors are considered. The applicable constructors\n  are enumerated (13.3.1.3), and the best one is chosen through overload\n  resolution (13.3). The constructor so selected is called to initialize\n  the object, with the initializer expression or <em>expression-list</em> as its\n  argument(s). If no constructor applies, or the overload resolution is\n  ambiguous, the initialization is ill-formed.</li>\n<li>Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source\n  type to the destination type or (when a conversion function is used)\n  to a derived class thereof are enumerated as described in 13.3.1.4,\n  and the best one is chosen through overload resolution (13.3). If the\n  conversion cannot be done or is ambiguous, the initialization is\n  ill-formed. The function selected is called with the initializer\n  expression as its argument; if the function is a constructor, the call\n  initializes a temporary of the cv-unqualified version of the\n  destination type. The temporary is a prvalue. The result of the call\n  (which is the temporary for the constructor case) is then used to\n  direct-initialize, according to the rules above, the object that is\n  the destination of the copy-initialization. In certain cases, an\n  implementation is permitted to eliminate the copying inherent in this\n  direct-initialization by constructing the intermediate result directly\n  into the object being initialized; see 12.2, 12.8.</li>\n</ul>\n</blockquote>\n<p>The source type is <code>item</code>, the destination type is <code>test</code>, it's copy initialization, so it falls under the second bullet point. There's only one available conversion using the <code>test(const item&amp; a)</code> constructor, so a prvalue temporary of type <code>test</code> is constructed from the <code>item</code> and then used to direct-initialize the destination in accordance with the first bullet point. This, in turn, must call a constructor of <code>test</code> that can accept a <code>const test &amp;</code> or <code>test &amp;&amp;</code> argument. Even if the copy or move is elided, you still must have such a constructor available.</p>\n</hr>", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-08-31T07:35:56.950", "Id": "25589764", "Score": "5", "CreationDate": "2014-08-31T07:13:07.887", "LastActivityDate": "2014-08-31T07:35:56.950"}, "25589674": {"CommentCount": "6", "AcceptedAnswerId": "25589764", "PostTypeId": "1", "LastEditorUserId": "3953764", "CreationDate": "2014-08-31T07:00:48.513", "LastActivityDate": "2014-08-31T07:35:56.950", "LastEditDate": "2014-08-31T07:20:12.020", "ViewCount": "246", "FavoriteCount": "1", "Title": "Disallow copy constructor but allow implicit copy from other type", "Id": "25589674", "Score": "3", "Body": "<p>Here is my code, I disable the copy constructor, but it also disables my implicit copy from other types. Any work around in this case ?</p>\n<p>Tested on: g++ (GCC) 4.7.1</p>\n<pre><code>struct item {\n  int b;\n};\n\nclass test {\n public:\n  test(const test&amp; copy) = delete;\n\n  test(const item&amp; a) {\n    std::cout &lt;&lt; \"OK \" &lt;&lt; a.b &lt;&lt; std::endl;\n  }\n};\n\nint main() {\n  test a = item{10}; //error: use of deleted function \u2018test::test(const test&amp;)\u2019\n}\n</code></pre>\n", "Tags": "<c++><class><c++11><copy-constructor>", "OwnerUserId": "411524", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25589674_25589764_0": {"section_id": 3296, "quality": 1.0, "length": 6}}, "n3337": {"so_25589674_25589764_0": {"section_id": 3166, "quality": 1.0, "length": 6}}, "n4659": {"so_25589674_25589764_0": {"section_id": 4058, "quality": 1.0, "length": 6}}}, "25589815": {"ParentId": "25589674", "CommentCount": "0", "Body": "<p>There are three options I can think of:</p>\n<p>1) Move constructor<br>\n2) Assignment operator + default constructor<br>\n3) Calling the constructor explicitly  </br></br></p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct item {\n    int b;\n};\nstruct test {\n    test(const test&amp; copy) = delete;\n    test(const item&amp; a) {\n        std::cout &lt;&lt; \"OK \" &lt;&lt; a.b &lt;&lt; std::endl;\n    }\n//  move:\n    test(test&amp;&amp; from) {}\n//  added:\n    test() {}\n    test&amp; operator = (const test&amp; src) = default;\n};\n\nint main() {\n//fine after move constructor:\n    test a = item{10};\n//all fine with original\n    test b(item{20});\n//fine after adding .ctor() and op=\n    test c; c = item{30};\n}\n</code></pre>\n", "OwnerUserId": "1722660", "PostTypeId": "2", "Id": "25589815", "Score": "0", "CreationDate": "2014-08-31T07:21:10.947", "LastActivityDate": "2014-08-31T07:21:10.947"}});