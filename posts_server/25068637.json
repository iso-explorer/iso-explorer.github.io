post_cb({"25068726": {"ParentId": "25068637", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>In C++11, <code>c_str()</code> and <code>data()</code> are both required to return a pointer to the internal storage (sorry, I don't have a direct quote handy to back that up).  In earlier versions, <code>c_str()</code> was not require to do that, but <code>data()</code> was.  Implementors could (but rarely did) implement copy-on-write semantics so that the pointer returned by <code>c_str()</code> was not the original internal storage.</p>\n<p>In all versions, <code>c_str()</code> is required to return a null-terminated pointer.  So, that implies that in C++11, the internal storage must be null-terminated.</p>\n", "OwnerUserId": "65863", "LastEditorUserId": "893", "LastEditDate": "2014-07-31T21:59:51.620", "Id": "25068726", "Score": "1", "CreationDate": "2014-07-31T20:52:17.297", "LastActivityDate": "2014-07-31T21:59:51.620"}, "25068713": {"ParentId": "25068637", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>From <strong>21.4.5</strong>:</p>\n<blockquote>\n<p id=\"so_25068637_25068713_0\"><code>const_reference operator[](size_type pos) const;</code> <code>reference\n  operator[](size_type pos);</code></p>\n<p id=\"so_25068637_25068713_1\">1 Requires: <code>pos &lt;= size()</code>.</p>\n<p id=\"so_25068637_25068713_2\">2 Returns:\n  <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>, otherwise a reference to an\n  object of type <code>T</code> with value <code>charT()</code>; the referenced value shall\n  not be modified.</p>\n</blockquote>\n<p>Note that <code>s[s.size()]</code> is well-defined and required to return NUL character.</p>\n<p>However, that doesn't by itself require <code>NUL</code>-terimnated internal storage. <strong>21.4.1/5</strong> has this to say:</p>\n<blockquote>\n<p id=\"so_25068637_25068713_3\">The char-like objects in a basic_string object shall be stored contiguously. That is, for any <code>basic_string</code> object <code>s</code>, the identity <code>&amp;*(s.begin() + n) == &amp;*s.begin() + n</code> shall hold for all values of <code>n</code> such that <code>0 &lt;= n &lt; s.size()</code>.</p>\n</blockquote>\n<p>Note that contiguous storage is only required up to <code>n &lt; s.size()</code>, but not for <code>s.size()</code> itself. So <code>char* p = &amp;s[0];</code> doesn't necessarily point to a <code>NUL</code>-terminated buffer, as the standard doesn't require that <code>p[s.size()]</code> be valid.</p>\n<p>Practically speaking, between requirements on <code>data()</code>, <code>c_str()</code> and <code>operator[]</code>, any sane implementation would maintain a <code>NUL</code>-terminated storage. But insane implementations don't appear to be precluded by the standard.</p>\n", "OwnerUserId": "1670129", "LastEditorUserId": "1670129", "LastEditDate": "2014-07-31T20:57:04.233", "Id": "25068713", "Score": "5", "CreationDate": "2014-07-31T20:51:43.783", "LastActivityDate": "2014-07-31T20:57:04.233"}, "25068637": {"CommentCount": "3", "ViewCount": "299", "ClosedDate": "2014-07-31T20:54:09.927", "CreationDate": "2014-07-31T20:47:29.143", "LastActivityDate": "2014-07-31T21:59:51.620", "PostTypeId": "1", "FavoriteCount": "0", "Title": "Null terminated string, is it really dictated by the standard?", "Id": "25068637", "Score": "4", "Body": "<h2>Discussion</h2>\n<ul>\n<li><p>It is known that from C++11 and beyond <code>std::basic_string</code>s are considered to have null character terminated internal storage buffers. </p></li>\n<li><p>The main reason for this change, among others, was that the previous definition of <code>std::basic_string</code> allowed only very limited concurrent access to strings and thus, limited performance for multi-threaded applications. (More on the reasons for the changes in <code>std::basic_string</code> can be read in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2534.html\" rel=\"nofollow\">proposal N2534</a>).</p></li>\n<li><p>However, reading the standard I couldn't find a quote where explicitly is stated that <code>std::basic_string</code> must have a null character terminated internal storage buffer.</p></li>\n<li><p>The only implicit quote that I've found is <em>\u00a721.4.7.1/1&amp;3 basic_string accessors [string.accessors]:</em></p></li>\n</ul>\n<blockquote>\n<blockquote>\n<p id=\"so_25068637_25068637_3\"><em><code>const charT* c_str() const noexcept;</code></em></p>\n<p id=\"so_25068637_25068637_4\"><em><code>const charT* data() const noexcept;</code></em></p>\n<p id=\"so_25068637_25068637_5\"><em><code>1</code> Returns: A pointer <code>p</code> such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.</em>\n<em><code>3</code> Requires: The program shall not alter any of the values stored in the character array.</em></p>\n</blockquote>\n</blockquote>\n<ul>\n<li><p>I assume that due to efficiency reasons and since <code>\u00a721.4.7.1/3</code> require that the program shall not alter the returned buffer, most implementers in <code>std::basic_string::c_str()</code> and  <code>std::basic_string::data()</code> are returning the null character terminated internal buffer.</p></li>\n<li><p>However, the standard doesn't state anywhere that the buffer that must be returned by <code>std::basic_string::c_str()</code> and <code>std::basic_string::data()</code> must be the internal storage buffer of the <code>std::basic_string</code> and not some null character terminated copy.</p></li>\n</ul>\n<h2>Questions:</h2>\n<ol>\n<li>Is there somewhere in the standard explicitly stated that <code>std::basic_string</code> internal storage buffer must be null character terminated?</li>\n<li>In case there is not an explicit statement (i.e., question #1 short answer is no), does this mean that an implementer could implement the <code>std::basic_string</code> with out a null character terminated internal storage buffer and consequently the wide spread notion that since C++11 strings are null terminated is wrong?  </li>\n</ol>\n", "Tags": "<c++><c++11><language-lawyer><stdstring><c++14>", "OwnerUserId": "2352671", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25068637_25068713_3": {"section_id": 1566, "quality": 0.7777777777777778, "length": 14}, "so_25068637_25068713_2": {"section_id": 1617, "quality": 0.6428571428571429, "length": 9}, "so_25068637_25068713_0": {"section_id": 1619, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_25068637_25068637_0": {"section_id": 1836, "quality": 0.8, "length": 4}, "so_25068637_25068713_3": {"section_id": 1561, "quality": 0.7777777777777778, "length": 14}, "so_25068637_25068713_2": {"section_id": 1613, "quality": 0.6428571428571429, "length": 9}, "so_25068637_25068637_3": {"section_id": 1836, "quality": 0.8, "length": 4}, "so_25068637_25068637_1": {"section_id": 1836, "quality": 0.8, "length": 4}, "so_25068637_25068637_4": {"section_id": 1836, "quality": 0.8, "length": 4}, "so_25068637_25068713_0": {"section_id": 1615, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_25068637_25068637_0": {"section_id": 1984, "quality": 0.8, "length": 4}, "so_25068637_25068637_3": {"section_id": 1984, "quality": 0.8, "length": 4}, "so_25068637_25068713_2": {"section_id": 1770, "quality": 0.7142857142857143, "length": 10}, "so_25068637_25068637_1": {"section_id": 1984, "quality": 0.8, "length": 4}, "so_25068637_25068637_4": {"section_id": 1984, "quality": 0.8, "length": 4}, "so_25068637_25068713_0": {"section_id": 1772, "quality": 0.7142857142857143, "length": 5}}}});