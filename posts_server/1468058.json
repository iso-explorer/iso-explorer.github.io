post_cb({"1819268": {"Id": "1819268", "PostTypeId": "2", "Body": "<p>Arrays are not first class in C++; you cannot pass them as arguments to functions, for example (they decay to pointers, although you can pass pointers and references <em>to</em> arrays). Further, they do not have value semantics.</p>\n", "LastActivityDate": "2009-11-30T11:28:39.843", "CommentCount": "0", "CreationDate": "2009-11-30T11:28:39.843", "ParentId": "1468058", "Score": "-1", "OwnerUserId": "2131"}, "1468074": {"Id": "1468074", "PostTypeId": "2", "Body": "<p>It's been a little while since I used C++, but I believe the core problem you're encountering is that arrays don't have the required semantics to get along well with a <code>std::vector&lt;&gt;</code>.  I don't have my copy of Stroustrup handy, or I'd give you a reference.</p>\n", "LastActivityDate": "2009-09-23T19:19:39.613", "CommentCount": "0", "CreationDate": "2009-09-23T19:19:39.613", "ParentId": "1468058", "Score": "2", "OwnerUserId": "6932"}, "1468225": {"Id": "1468225", "PostTypeId": "2", "Body": "<p>Try using a <code>vector</code> of <code>vector</code> instead.</p>\n", "LastActivityDate": "2009-09-23T19:57:02.633", "CommentCount": "1", "CreationDate": "2009-09-23T19:57:02.633", "ParentId": "1468058", "Score": "2", "OwnerUserId": "18192"}, "1468069": {"Id": "1468069", "PostTypeId": "2", "Body": "<p>Under the hood it's doing an assignment and that isn't defined for arrays.</p>\n<p>The pertinent part of the error is</p>\n<p>instantiated from here /usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/bits/vector.tcc:306: <strong>error: array must be initialized with a brace-enclosed initializer</strong> /usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/bits/stl_vector.h:741: instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::push_back(const _Tp&amp;) [with _Tp = int [4], _Alloc = std::allocator]\u2019 test2.cpp:9: instantiated from here /usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/bits/vector.tcc:312: <strong>error: invalid array assignment</strong></p>\n", "LastActivityDate": "2009-09-23T19:18:47.500", "CommentCount": "3", "CreationDate": "2009-09-23T19:18:47.500", "ParentId": "1468058", "Score": "6", "OwnerUserId": "3937"}, "bq_ids": {"n4140": {"so_1468058_1468304_0": {"length": 6, "quality": 0.6, "section_id": 5768}}, "n3337": {"so_1468058_1468304_0": {"length": 6, "quality": 0.6, "section_id": 5541}}, "n4659": {"so_1468058_1468304_0": {"length": 6, "quality": 0.6, "section_id": 7225}}}, "1468058": {"ViewCount": "8442", "Body": "<p>I am unclear about the following.</p>\n<p>First, this code compiles fine:</p>\n<pre><code>#include &lt;vector&gt;\n\ntypedef struct{\n    int x1,x2,x3,x4;\n}  ints;\n\ntypedef std::vector&lt;ints&gt; vec;\n\nint main(){\n    vec v;\n    ints a = {0,1,2,3};\n    v.push_back(a);\n}\n</code></pre>\n<p>The following code is near identical:</p>\n<pre><code>#include &lt;vector&gt;\n\ntypedef std::vector&lt;int[4]&gt; vec;\n\nint main(){\n    vec v;\n    int a[4] = {0,1,2,3};\n    v.push_back(a);\n}\n</code></pre>\n<p>but it throws the extremely length error output I will include at the end. Why does the compiler treat these two programs so differently? It is definitely not intuitive.</p>\n<p>Here is the compiler error that is thrown on my system that is using g++ to compile:</p>\n<pre><code>[mattg@pigott Test]$ g++ test2.cpp -o test2\nIn file included from /usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/i586-redhat-linux/bits/c++allocator.h:34,\n                 from /usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/bits/allocator.h:48,\n                 from /usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/vector:62,\n                 from test2.cpp:2:\n/usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/ext/new_allocator.h: In member function \u2018void __gnu_cxx::new_allocator&lt;_Tp&gt;::construct(_Tp*, const _Tp&amp;) [with _Tp = int [4]]\u2019:\n/usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/bits/stl_vector.h:737:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::push_back(const _Tp&amp;) [with _Tp = int [4], _Alloc = std::allocator&lt;int [4]&gt;]\u2019\ntest2.cpp:9:   instantiated from here\n/usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/ext/new_allocator.h:105: error: ISO C++ forbids initialization in array new\nIn file included from /usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/vector:69,\n                 from test2.cpp:2:\n/usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/bits/vector.tcc: In member function \u2018void std::vector&lt;_Tp, _Alloc&gt;::_M_insert_aux(__gnu_cxx::__normal_iterator&lt;typename std::_Vector_base&lt;_Tp, _Alloc&gt;::_Tp_alloc_type::pointer, std::vector&lt;_Tp, _Alloc&gt; &gt;, const _Tp&amp;) [with _Tp = int [4], _Alloc = std::allocator&lt;int [4]&gt;]\u2019:\n/usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/bits/stl_vector.h:741:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::push_back(const _Tp&amp;) [with _Tp = int [4], _Alloc = std::allocator&lt;int [4]&gt;]\u2019\ntest2.cpp:9:   instantiated from here\n/usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/bits/vector.tcc:306: error: array must be initialized with a brace-enclosed initializer\n/usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/bits/stl_vector.h:741:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::push_back(const _Tp&amp;) [with _Tp = int [4], _Alloc = std::allocator&lt;int [4]&gt;]\u2019\ntest2.cpp:9:   instantiated from here\n/usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/bits/vector.tcc:312: error: invalid array assignment\nIn file included from /usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/i586-redhat-linux/bits/c++allocator.h:34,\n                 from /usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/bits/allocator.h:48,\n                 from /usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/vector:62,\n                 from test2.cpp:2:\n/usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/ext/new_allocator.h: In member function \u2018void __gnu_cxx::new_allocator&lt;_Tp&gt;::destroy(_Tp*) [with _Tp = int [4]]\u2019:\n/usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/bits/vector.tcc:353:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::_M_insert_aux(__gnu_cxx::__normal_iterator&lt;typename std::_Vector_base&lt;_Tp, _Alloc&gt;::_Tp_alloc_type::pointer, std::vector&lt;_Tp, _Alloc&gt; &gt;, const _Tp&amp;) [with _Tp = int [4], _Alloc = std::allocator&lt;int [4]&gt;]\u2019\n/usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/bits/stl_vector.h:741:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::push_back(const _Tp&amp;) [with _Tp = int [4], _Alloc = std::allocator&lt;int [4]&gt;]\u2019\ntest2.cpp:9:   instantiated from here\n/usr/lib/gcc/i586-redhat-linux/4.4.1/../../../../include/c++/4.4.1/ext/new_allocator.h:115: error: request for member \u2018~int [4]\u2019 in \u2018* __p\u2019, which is of non-class type \u2018int [4]\u2019\n</code></pre>\n", "AcceptedAnswerId": "1468069", "Title": "Question about storing array in a std::vector in C++", "CreationDate": "2009-09-23T19:16:27.257", "Id": "1468058", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2009-09-23T19:45:59.170", "LastEditorUserId": "13430", "LastActivityDate": "2013-07-03T10:26:33.333", "Score": "6", "OwnerUserId": "177931", "Tags": "<c++><gcc><compiler-construction><g++><stdvector>", "AnswerCount": "7"}, "1468102": {"Id": "1468102", "PostTypeId": "2", "Body": "<p>Try <a href=\"http://www.boost.org/doc/libs/1_40_0/doc/html/array.html\" rel=\"nofollow noreferrer\">boost::array</a> instead of plain arrays. It provides STL-compliant interface around fixed-size arrays, so it can be used inside STL containers. Plus, it implements boundary checking (<code>boost::array::at</code>).</p>\n<pre><code>#include &lt;boost/array.hpp&gt;\n#include &lt;vector&gt;\n\ntypedef std::vector&lt; boost::array&lt;int, 4&gt; &gt; vec;\nint main(){\n    vec v;\n    boost::array&lt;int, 4&gt; va = {0,1,2,3};\n    v.push_back(va);\n}\n</code></pre>\n", "LastActivityDate": "2009-09-23T19:28:34.590", "CommentCount": "1", "CreationDate": "2009-09-23T19:28:34.590", "ParentId": "1468058", "Score": "6", "OwnerUserId": "16102"}, "1468304": {"Id": "1468304", "PostTypeId": "2", "Body": "<p>The requirement for value type <code>T</code> for all STL containers, including <code>std::vector&lt;T&gt;</code>, is that <code>T</code> is <code>Assignable</code> - ISO C++03 23.1[lib.container.requirements]/4-5. <code>Assignable</code> is defined as follows:</p>\n<blockquote>\n<p id=\"so_1468058_1468304_0\">Expression <code>t = u</code>, where <code>t</code> is of type <code>T</code>, and <code>u</code> is of type <em>cv</em> <code>T</code>, is valid, its return type is <code>T&amp;</code>, and the post-condition is that <code>t</code> is equivalent to <code>u</code>.</p>\n</blockquote>\n<p>Arrays do not fulfill this requirement, because you cannot write:</p>\n<pre><code>int a[2], b[2];\na = b;\n</code></pre>\n<p>The reason why you cannot is because both <code>a</code> and <code>b</code> in the code snippet above decay to pointer-type rvalues according to the usual C++ rules for array-to-pointer decay described in 4.2[conv.array]. Naturally, an rvalue if not permitted on the left side of non-overloaded <code>operator=</code>.</p>\n", "LastActivityDate": "2009-09-23T20:18:07.067", "CommentCount": "0", "CreationDate": "2009-09-23T20:18:07.067", "ParentId": "1468058", "Score": "1", "OwnerUserId": "111335"}, "1468115": {"Id": "1468115", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_1468058_1468115_0\">error: ISO C++ forbids initialization\n  in array new<br> error: array must be\n  initialized with a brace-enclosed\n  initializer<br> error: invalid array\n  assignment<br> error: request for\n  member \u2018~int [4]\u2019 in \u2018* __p\u2019, which is\n  of non-class type \u2018int [4]\u2019<br/></br></br></br></p>\n</blockquote>\n<p>To understand one of the errors, imagine the following:</p>\n<pre><code>void main() {\n    int a[4] = {0,1,2,3};\n    int b[4] = a;\n}\n</code></pre>\n<p>As opposed to:</p>\n<pre><code>typedef struct{\n    int x1,x2,x3,x4;\n}  ints;\n\nint main()\n{\n    ints a;\n    ints b = a;\n}\n</code></pre>\n<p>Or even:</p>\n<pre><code>typedef struct{\n    int x[4];\n}  ints;\n\nint main()\n{\n    ints a;\n    ints b = a;\n}\n</code></pre>\n<p>C/C++ arrays cannot be copied via the assignment operator, though <code>struct</code>s containing arrays can be.<br>\nSo an easy fix is to do:</br></p>\n<pre><code>typedef struct{\n        int x[4];\n}  ints;\n\ntypedef std::vector&lt;ints&gt; vec;\n\nint main(){\n        vec v;\n        ints a = { {0,1,2,3} };\n        v.push_back(a);\n}\n</code></pre>\n", "LastEditorUserId": "560648", "LastActivityDate": "2013-07-03T10:26:33.333", "Score": "11", "CreationDate": "2009-09-23T19:31:44.957", "ParentId": "1468058", "CommentCount": "0", "OwnerUserId": "97160", "LastEditDate": "2013-07-03T10:26:33.333"}});