post_cb({"bq_ids": {"n4140": {"so_24411638_24412775_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 6066}}, "n3337": {"so_24411638_24412775_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 5834}}, "n4659": {"so_24411638_24412775_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 7562}}}, "24412775": {"Id": "24412775", "PostTypeId": "2", "Body": "<h2>You can't take an address of a temporary \"directly\"...</h2>\n<p>You can't take an address of a temporary with <code>&amp;</code>:</p>\n<pre><code>g(&amp;({1, 3.14})); \n</code></pre>\n<p>as per:</p>\n<blockquote>\n<p id=\"so_24411638_24412775_0\"><strong>\u00a75.3.1/3</strong></p>\n<p id=\"so_24411638_24412775_1\">The result of the unary &amp; operator is a pointer to its operand. <strong>The operand shall be an lvalue or a qualified-id.</strong></p>\n</blockquote>\n<p>(emphasis mine)</p>\n<h2>... but you can indirectly!</h2>\n<p>For example, you can use a function to extract the pointer to the temporary object:</p>\n<pre><code>A* fn(A&amp;&amp; a) {\n    return std::addressof(a);\n}\n</code></pre>\n<p>and use it as:</p>\n<pre><code>g(fn({1, 4.0}));\n</code></pre>\n<p>Note that <code>std::addressof</code> is necessary to avoid possible <code>operator&amp;</code> overloading for the class <code>A</code>.\nYou could also extract it via a member function of the class <code>A</code> and probably many other ways.</p>\n<p><sub><strong>Why the sudden opinion change?</strong> Well, I've <a href=\"http://chat.stackoverflow.com/transcript/message/17366383#17366383\">discussed it</a> with other C++ haters and apparently it is possible and perfectly legal.</sub></p>\n<h2>What I'd recommend</h2>\n<p>I'd recommend for <code>g</code> to take a <code>const</code> reference instead:</p>\n<pre><code>void g(const A&amp; a);\n</code></pre>\n<p>and then:</p>\n<pre><code>g({1, 3.14});\n</code></pre>\n<p>will work fine (assuming, of course, that the constructor is not explicit).</p>\n", "LastEditorUserId": "493122", "LastActivityDate": "2014-06-25T16:05:45.170", "Score": "8", "CreationDate": "2014-06-25T15:28:14.017", "ParentId": "24411638", "CommentCount": "2", "OwnerUserId": "493122", "LastEditDate": "2014-06-25T16:05:45.170"}, "24411638": {"ViewCount": "227", "Body": "<p>For example, I have a class</p>\n<pre><code>struct A\n{\n    A(int i, double d) {...}\n};\n</code></pre>\n<p>and a function with an argument A</p>\n<pre><code>void f(A a);\n</code></pre>\n<p>I can call the function by</p>\n<pre><code>f( { 1, 3.14 } );\n</code></pre>\n<p>If the function has an argument A*</p>\n<pre><code>void g(A* a);\n</code></pre>\n<p>How to make it call like</p>\n<pre><code>g( my_new{1, 3.14} ); // Note: no type A is shown here.\n</code></pre>\n<p>Or how to derive the type A here? </p>\n", "AcceptedAnswerId": "24412775", "Title": "How to use uniform initialization for a pointer?", "CreationDate": "2014-06-25T14:38:21.630", "Id": "24411638", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-06-25T14:50:07.933", "LastEditorUserId": "1899020", "LastActivityDate": "2014-06-25T16:05:45.170", "Score": "3", "OwnerUserId": "1899020", "Tags": "<c++><initialization>", "AnswerCount": "1"}});