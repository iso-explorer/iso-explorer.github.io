post_cb({"25113863": {"Id": "25113863", "PostTypeId": "2", "Body": "<p>\u00a713.3.3.1.2 [over.ics.user]/p1-2:</p>\n<blockquote>\n<p id=\"so_25113661_25113863_0\">A user-defined conversion sequence consists of an initial standard\n  conversion sequence followed by a user-defined conversion (12.3)\n  followed by a second standard conversion sequence. If the user-defined\n  conversion is specified by a constructor (12.3.1), the initial\n  standard conversion sequence converts the source type to the type\n  required by the argument of the constructor. If the user-defined\n  conversion is specified by a conversion function (12.3.2), the initial\n  standard conversion sequence converts the source type to the implicit\n  object parameter of the conversion function.</p>\n<p id=\"so_25113661_25113863_1\">The second standard conversion sequence converts the result of the\n  user-defined conversion to the target type for the sequence.</p>\n</blockquote>\n<p>In particular, there's an implicit conversion from floating point to integral type (\u00a74.9 [conv.fpint]/p1):</p>\n<blockquote>\n<p id=\"so_25113661_25113863_2\">A prvalue of a floating point type can be converted to a prvalue of an\n  integer type. The conversion truncates; that is, the fractional part\n  is discarded. The behavior is undefined if the truncated value cannot\n  be represented in the destination type.</p>\n</blockquote>\n<p>For overload resolution purposes, the applicable candidates are:</p>\n<pre><code>Foo::operator[](std::string x)              // overload\noperator[](std::ptrdiff_t, const char *);   // built-in\n</code></pre>\n<p>Given an argument list of types <code>(Foo, const char [5])</code>.</p>\n<p>To match the first operator function, the first argument is an exact match; the second requires a user-defined conversion.</p>\n<p>To match the second built-in function, the first argument requires a user-defined conversion sequence (the user-defined conversion to <code>double</code> followed by a standard conversion to <code>std::ptrdiff_t</code>, a floating-integral conversion). The second argument requires a standard array-to-pointer conversion (still exact match rank), which is better than a user-defined conversion.</p>\n<p>Thus for the first argument the first function is better; for the second argument the second function is better, we have a criss-cross situation, overload resolution fails, and the program is ill-formed. </p>\n<p>Note that, while for the purposes of operator overload resolution, a user-defined conversion sequence can have two standard conversion sequences (one before and one after the user-defined conversion), and operands of non-class-type can be converted to match the candidates, if a built-in operator is selected, the second standard conversion sequence is not applied for operands of class type, and no conversion at all is applied for operands for non-class type before the operator is interpreted as a built-in (\u00a713.3.1.2 [over.match.oper]/p7):</p>\n<blockquote>\n<p id=\"so_25113661_25113863_3\">If a built-in candidate is selected by overload resolution, the\n  operands of class type are converted to the types of the corresponding\n  parameters of the selected operation function, except that the second\n  standard conversion sequence of a user-defined conversion sequence\n  (13.3.3.1.2) is not applied. Then the operator is treated as the\n  corresponding built-in operator and interpreted according to Clause 5.</p>\n</blockquote>\n<p>Thus if <code>Foo::operator[](std::string x)</code> is removed, the compiler should report an error, though clang doesn't. This is an obvious clang bug, as <a href=\"http://coliru.stacked-crooked.com/a/25bcc0549a19921f\" rel=\"nofollow\">it fails to reject the example given in the standard</a>.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-04T08:37:59.117", "Score": "6", "CreationDate": "2014-08-04T07:43:24.667", "ParentId": "25113661", "CommentCount": "7", "OwnerUserId": "2756719", "LastEditDate": "2014-08-04T08:37:59.117"}, "bq_ids": {"n4140": {"so_25113661_25113863_0": {"length": 44, "quality": 0.9361702127659575, "section_id": 620}, "so_25113661_25113863_2": {"length": 22, "quality": 0.9166666666666666, "section_id": 37}, "so_25113661_25113863_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 621}, "so_25113661_25113863_3": {"length": 32, "quality": 0.9696969696969697, "section_id": 588}}, "n3337": {"so_25113661_25113863_0": {"length": 44, "quality": 0.9361702127659575, "section_id": 610}, "so_25113661_25113863_2": {"length": 22, "quality": 0.9166666666666666, "section_id": 34}, "so_25113661_25113863_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 611}, "so_25113661_25113863_3": {"length": 22, "quality": 0.6666666666666666, "section_id": 578}}, "n4659": {"so_25113661_25113863_0": {"length": 44, "quality": 0.9361702127659575, "section_id": 646}, "so_25113661_25113863_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 37}, "so_25113661_25113863_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 647}, "so_25113661_25113863_3": {"length": 32, "quality": 0.9696969696969697, "section_id": 611}}}, "25113661": {"ViewCount": "573", "Body": "<p>The following code</p>\n<pre><code>#include &lt;string&gt;\n\nstruct Foo {\n    operator double() {\n        return 1;\n    }\n\n    int operator[](std::string x) {\n        return 1;\n    }\n};\n\nint main() {\n    Foo()[\"abcd\"];\n}\n</code></pre>\n<p>Compiles fine with g++ but fails with clang and intel compilers because of an ambiguity between the declared method and native operator <code>[]</code>.</p>\n<p>It would be clear for me if <code>Foo</code> had an implicit conversion to <code>int</code>, but here the conversion is to <code>double</code>. Doesn't that solve the ambiguity?</p>\n", "AcceptedAnswerId": "25113863", "Title": "operator[](const char *) ambiguity", "CreationDate": "2014-08-04T07:27:35.027", "Id": "25113661", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2014-08-04T08:37:59.117", "Score": "11", "OwnerUserId": "320726", "Tags": "<c++>", "AnswerCount": "1"}});