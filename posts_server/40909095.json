post_cb({"40911798": {"Id": "40911798", "PostTypeId": "2", "Body": "<p>Rvalue references are implicitly converted to rvalues (more specifically, to xvalues) as one of the standard conversions (chapter 4 of the C++ standard):</p>\n<blockquote>\n<p id=\"so_40909095_40911798_0\">The effect of any implicit conversion is the same as performing the\n  corresponding declaration and initialization and then using the\n  temporary variable as the result of the conversion. <strong>The result is</strong> an\n  lvalue if T is an lvalue reference type or an rvalue reference to\n  function type (8.3.2), <strong>an xvalue if T is an rvalue reference to object\n  type</strong>, and a prvalue otherwise</p>\n</blockquote>\n<p>Rvalues (including xvalues) can be bound to <code>const</code> lvalue references so that you can pass a temporary to a function with such a parameter:</p>\n<pre><code>void foo(const bar &amp;a);\n// ...\nfoo(bar());\n</code></pre>\n<p>(A temporary is an rvalue; in this case, the result of <code>bar()</code> is an rvalue). There is no reason <em>not</em> to allow this, since the temporary always lives as long as the containing expression - in this case, the function call - and so it will not create a dangling reference inside <code>foo</code>.</p>\n<p>This means it is always possible to adjust the signature of a function <code>fun(bar)</code> to <code>fun(const bar &amp;)</code> - and change the implementation accordingly of course! - since temporary arguments will still be accepted, and the semantics should be the same from the perspective of the caller; <code>const</code> implies the object won't be modified, which is also the case if it is passed by copy.</p>\n<p>Non-<code>const</code> references are not allowed; one practical reason is because they imply that the value should be modified in some meaningful way, and if the value is a temporary, this would be lost. However, you can convert an rvalue to an lvalue if you really want to do so, with some caveats, as described in <a href=\"https://stackoverflow.com/a/35440617/388661\">this answer</a> to another question.</p>\n<p>Allowing an rvalue to bind to a <code>const</code> lvalue reference, other than allowing temporary arguments to be passed by reference, is also good for cases where the exact parameter type is not known but you want to allow move semantics if it is possible. Suppose that I am calling a function that could be defined as <code>foo2(const bar &amp;)</code> or <code>foo2(bar)</code> and which in the former case may or may not have an overload <code>foo2(bar &amp;&amp;)</code>, and I want to allow move semantics to be used if possible (assuming that a <code>foo2(bar &amp;&amp;)</code> overload will use move semantics in its implementation); I can safely use <code>std::move</code> to create an rvalue since it will apply in either case. This example might seem a little contrived, but it is the sort of thing that can come up quite a bit when writing templates. In code:</p>\n<pre><code>bar bb = bar();\nfoo2(std::move(bb));\n// above is legal if foo2 is declared as either:\n//    foo2(bar)\n//    foo2(const bar &amp;)\n// and in latter case calls overload foo2(bar &amp;&amp;) if it is defined.\n</code></pre>\n<p>In the case of other rvalue-to-lvalue-reference assignments involving a temporary, the lifetime of the temporary is extended to that of the reference, so that dangling references are not created even in contexts other than parameter passing:</p>\n<pre><code>const bar &amp;b = bar(); // temporary lifetime is extended\n</code></pre>\n<p>In the above, the <code>bar</code> object will not be destroyed until the reference <code>b</code> goes out of scope.</p>\n", "LastEditorUserId": "388661", "LastActivityDate": "2017-11-06T12:54:49.517", "Score": "4", "CreationDate": "2016-12-01T13:23:05.917", "ParentId": "40909095", "CommentCount": "12", "OwnerUserId": "388661", "LastEditDate": "2017-11-06T12:54:49.517"}, "bq_ids": {"n4140": {"so_40909095_40911798_0": {"length": 30, "quality": 0.9090909090909091, "section_id": 5}}, "n3337": {"so_40909095_40911798_0": {"length": 29, "quality": 0.8787878787878788, "section_id": 2}}, "n4659": {"so_40909095_40911798_0": {"length": 30, "quality": 0.9090909090909091, "section_id": 5}}}, "40909095": {"ViewCount": "222", "Body": "<p>This very simple code is allowed:</p>\n<pre><code>class s\n{\npublic:\n};\n\nconst s&amp; tt = std::move(s()); // Also valid without 'const'\n</code></pre>\n<p>But right now I'm wondering <strong>why</strong> it is allowed.. </p>\n<p>First we use <code>std::move</code> and mark a rvalue (the temporary) as rvalue reference, but why a lvalue reference can bind to a rvalue reference?</p>\n<p>Is it because a rvalue reference is also a rvalue?</p>\n<p><strong>What's the rationale (or standard quotes) that causes a lvalue reference to bind to a rvalue reference??</strong> That <em>it can be done</em> I got it.</p>\n<p>Edit: msvc2015 allows for nonconst lvalue references to bind to rvalue references, the question remains for const lvalue references binding to rvalue references. Sorry, I should have specified the compiler I used.</p>\n", "AcceptedAnswerId": "40911798", "Title": "Why both const/nonconst lvalue references bind to a rvalue reference?", "CreationDate": "2016-12-01T11:08:54.780", "Id": "40909095", "CommentCount": "10", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-12-01T15:11:28.307", "LastEditorUserId": "3834459", "LastActivityDate": "2017-11-06T12:54:49.517", "Score": "1", "OwnerUserId": "3834459", "Tags": "<c++><rvalue-reference><rvalue>", "AnswerCount": "1"}});