post_cb({"24423480": {"CommentCount": "0", "ViewCount": "161", "PostTypeId": "1", "LastEditorUserId": "1337961", "CreationDate": "2014-06-26T06:08:21.097", "LastActivityDate": "2014-07-12T05:37:40.503", "Title": "covariant virtual function in C++", "AcceptedAnswerId": "24423563", "LastEditDate": "2014-06-26T06:15:45.313", "Id": "24423480", "Score": "4", "Body": "<p>I tried following program, but compiler shows error.  </p>\n<pre><code>#include &lt;iostream&gt;\nclass Base\n{\n    public:\n        virtual Base&amp; fun() const \n        {\n            std::cout&lt;&lt;\"fun() in Base\\n\";\n            return *this;\n        }\n};\nclass Derived : public Base\n{\n    public:\n         Derived&amp; fun() const\n        {\n            std::cout&lt;&lt;\"fun() in Derived\\n\";\n            return *this;\n        }\n};\nint main()\n{\n    Base* p=new Derived();\n    p-&gt;fun();\n    delete p;\n    return 0;\n}\n</code></pre>\n<p>Compiler errors:  </p>\n<pre><code>[Error] invalid initialization of reference of type 'Base&amp;' from expression of type 'const Base'\n[Error] invalid initialization of reference of type 'Derived&amp;' from expression of type 'const Derived'\n</code></pre>\n<p>Why I am getting these errors?<br>\n  But when I write following in both class' function program works fine.  </br></p>\n<pre><code>return (Base&amp;)*this;      // write this line in Base class function\nreturn (Derived&amp;)*this    // write this line in Derived class function\n</code></pre>\n<p>What is the meaning of above 2 statements?<br>\n  Please help me.</br></p>\n", "Tags": "<c++>", "OwnerUserId": "3777958", "AnswerCount": "3"}, "24423650": {"ParentId": "24423480", "CommentCount": "0", "CreationDate": "2014-06-26T06:20:07.930", "OwnerUserId": "477878", "PostTypeId": "2", "Id": "24423650", "Score": "4", "Body": "<p>The <code>const</code> keyword in</p>\n<pre><code>virtual Base&amp; fun() const \n</code></pre>\n<p>...makes <code>this</code> into a pointer to a <code>const</code> object inside the method. The problem is that you're trying to use</p>\n<pre><code>return *this;\n</code></pre>\n<p>...and return it from the method which returns <code>Base&amp;</code>, thus dropping the <code>const</code>.</p>\n<p>Either you need to drop the <code>const</code> in your declaration, making <code>this</code> not point to a const object, or you need to declare the method to return <code>const Base&amp;</code>.</p>\n", "LastActivityDate": "2014-06-26T06:20:07.930"}, "24423563": {"ParentId": "24423480", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-06-26T06:13:50.033", "Score": "8", "LastEditorUserId": "701092", "LastEditDate": "2014-07-05T00:24:13.860", "Id": "24423563", "OwnerUserId": "2352671", "Body": "<h2><strong>Solution:</strong></h2>\n<p>In your <code>fun</code> member functions (i.e., for both <code>Base::fun</code> and <code>Derived::fun</code>) you have to either drop the <code>const</code> qualifier of the function:</p>\n<pre><code>virtual Base&amp; fun() \n{\n  std::cout&lt;&lt;\"fun() in Base\\n\";\n  return *this;\n}\n</code></pre>\n<p>or return a const reference to a <code>Base</code> class object.</p>\n<pre><code>virtual const Base&amp; fun() const\n{\n  std::cout&lt;&lt;\"fun() in Base\\n\";\n  return *this;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/f879903c3538be80\" rel=\"nofollow\"><kbd><strong>Live Demo</strong></kbd></a></p>\n<p>Also you have to define a virtual destructor at least for your <code>Base</code> class to ensure that destructors are evoked in the correct order.</p>\n<h2>Explanation:</h2>\n<p>According to the standard <em>\u00a7 9.3.2 The <code>this</code> pointer [class.this]</em>:</p>\n<blockquote>\n<p id=\"so_24423480_24423563_0\">In the body of a non-static (9.3) member function, the keyword <code>this</code> is a prvalue expression whose value is the address of the object for which the function is called. The type of <code>this</code> in a member function of a <code>class X</code> is <code>X*</code>. <strong>If the member function is declared <code>const</code>, the type of <code>this</code> is <code>const X*</code>,</strong> if the member\n  function is declared <code>volatile</code>, the type of <code>this</code> is <code>volatile X*</code>, and if the member function is declared <code>const volatile</code>, the type of <code>this</code> is <code>const volatile X*</code>. [ Note: <strong>thus in a <code>const</code> member function, the object for which the function is called is accessed through a <code>const</code> access path.</strong> \u2014 end note ]</p>\n</blockquote>\n<p>Thus, interpreting the above, in a <code>const</code> member function <code>this</code> is <code>const</code> so returning it as non-const reference drops its <code>const</code> qualifier and therefore the compiler rightfully complains.</p>\n", "LastActivityDate": "2014-07-05T00:24:13.860"}, "bq_ids": {"n4140": {"so_24423480_24423563_0": {"section_id": 5895, "quality": 0.9245283018867925, "length": 49}}, "n3337": {"so_24423480_24423563_0": {"section_id": 5666, "quality": 0.6981132075471698, "length": 37}}, "n4659": {"so_24423480_24423563_0": {"section_id": 7378, "quality": 0.9056603773584906, "length": 48}}}, "24709994": {"ParentId": "24423480", "CommentCount": "0", "CreationDate": "2014-07-12T05:37:40.503", "OwnerUserId": "1081110", "PostTypeId": "2", "Id": "24709994", "Score": "1", "Body": "<p>When you write <code>const</code> in a variable declaration, or on the return type of a function, it means \"this value is read-only, so nobody is allowed to change it\".  When you write <code>const</code> on one of the parameters in a function declaration, it means \"this function is not going to change this value\".  When you write <code>const</code> at the end of a member function (method) declaration, it means \"this member function is not going to change the object on which it was called\".</p>\n<p>One of the compiler's jobs is to make sure that these <code>const</code> declarations are respected.  In particular, the compiler won't let you do any of the following.</p>\n<ul>\n<li>Change the value of a variable that's been declared as <code>const</code>.</li>\n<li>Change the value of an argument to a function, if the parameter was declared as <code>const</code>.</li>\n<li>Pass the value of a variable that's been declared as <code>const</code> into a function, by reference or by pointer, as a parameter that was NOT declared as <code>const</code>.</li>\n<li>Call a member function without the final <code>const</code> declaration on a variable that has been declared as <code>const</code>.</li>\n</ul>\n<p>The reason for the third restriction is that if a function has been declared <em>without</em> the <code>const</code> declaration on one of its parameters, then the compiler won't prevent it from changing the value of the corresponding argument.  And if you could pass in a <code>const</code> variable to such a function, then the compiler would not be able to guarantee that its value won't change.  Therefore, the compiler won't let you pass in a <code>const</code> variable.</p>\n<p>The reason for the fourth restriction is that if a member function has been declared <em>without</em> the <code>const</code> declaration at the end, then the compiler won't prevent it from changing the value of the object on which it was called.  And if you could call such a function on a <code>const</code> object, then the compiler would not be able to guarantee that its value won't change.</p>\n<p>So if you ever write a function that <em>doesn't</em> change the value referenced by one of its arguments, (via a reference parameter or pointer parameter), then it's best to add the <code>const</code> into the declaration.  That way, it will be possible to call the function, passing in a <code>const</code> variable by reference or by pointer.  Likewise, if your member function doesn't change the value of the object on which it's called, then it's best to add the <code>const</code> at the end of the declaration.</p>\n<p>But in your particular example, you have placed the <code>const</code> declaration at the end of a member function that returns a reference to the object on which it was called, but without having the <code>const</code> declaration on the returned reference.  That means that it would be possible to call this member function on a <code>const</code> object, assign the result to a non-<code>const</code> variable, then change its value via that variable.  This breaks the <code>const</code> rules.</p>\n<p>To make this work, you have three options.</p>\n<ul>\n<li>Make the function return a value rather than a reference.</li>\n<li>Make the function return a <code>const</code> reference (that is, add the word <code>const</code> at the beginning of the function declaration).</li>\n<li>Remove the <code>const</code> declaration from the end of the function declaration.</li>\n</ul>\n", "LastActivityDate": "2014-07-12T05:37:40.503"}});