post_cb({"17712872": {"LastEditDate": "2013-07-18T01:34:19.303", "Body": "<p>The section <code>Array Initialization</code> in <code>Chapter 4, page 231</code> of <code>Thinking in Java, 2nd Edition</code> has this to say:  </p>\n<blockquote>\n<p id=\"so_17712872_17712872_0\">Initializing arrays in C is error-prone and tedious. C++ uses \n  aggregate initialization  to make it much safer. Java has no\n  \u201caggregates\u201d like C++, since everything is an object in Java. It does\n  have arrays, and these are supported with array initialization.  </p>\n</blockquote>\n<p>Why is it error prone and tedious in C? What does it mean by aggregate initialization and why is it safer? I came across <a href=\"http://www.mi.uni-koeln.de/c/mirror/www.codeguru.com/cpp/tic/tic_html.zip/tic0077.html\">THIS</a> but it doesn't convince me of anything.</p>\n", "LastEditorUserId": "62576", "Score": "15", "AcceptedAnswerId": "17713121", "CommentCount": "6", "OwnerUserId": "1693203", "Title": "what is aggregate initialization", "PostTypeId": "1", "Tags": "<c++><c>", "LastActivityDate": "2013-07-18T01:44:47.987", "FavoriteCount": "0", "Id": "17712872", "AnswerCount": "2", "ViewCount": "5123", "CreationDate": "2013-07-18T01:09:35.447"}, "17712968": {"PostTypeId": "2", "ParentId": "17712872", "Score": "0", "LastEditorUserId": "2433695", "Body": "<p>I am assuming that the author is warning you about the lack of enforcing size constraints in C and C++. In C and C++, arrays decay down to pointers to their first element. It then uses pointer arithmetic to find the element you are refering to by index. Since arrays are not objects and the compiler makes no effort to store their size, there are no length checks. In java, arrays are objects and therefore their size is known. This size can be checked against, which safe guards the developer from accessing memory which doesn't belong to him/her when overstepping the bounds of the array.</p>\n<p>I find it strange the statement 'C++ uses aggregate initialize to make it much safer' was even used in this context. </p>\n<p>Aggregate initialization, which is common to most modern languages, is as follows</p>\n<pre><code>int intArray[3] = {1,2,3};\nint int2DArray[2][2] = {{1,2}, {3,4}};\n</code></pre>\n<p>This type of initialization assumes you know the size of the array beforehand and its contents. This type of initialization safe guards one from over stepping the boundary and provides for initializing an array with set values. Maybe in this case the author has in a mind a developer who declared a static C array of size 5. This developer then creates a loop to initialize its content but oversteps the boundary of the array by one, writing to memory that is not his/hers.</p>\n", "LastEditDate": "2013-07-18T01:28:16.110", "CommentCount": "3", "Id": "17712968", "OwnerUserId": "2433695", "CreationDate": "2013-07-18T01:23:11.903", "LastActivityDate": "2013-07-18T01:28:16.110"}, "17713121": {"PostTypeId": "2", "ParentId": "17712872", "Score": "14", "CreationDate": "2013-07-18T01:44:47.987", "Body": "<p>First of all, to answer the main question, aggregate initialization means the use of brace-enclosed initializer lists to initialize all members of an aggregate (i.e. an array or struct [in C++, only certain types of structs count as aggregates]).</p>\n<p>Obviously,</p>\n<pre><code>int ar[] = { 1 , 2 };\n</code></pre>\n<p>is safer than</p>\n<pre><code>int ar[2];\nar[0] = 1;\nar[1] = 2;\n</code></pre>\n<p>because the latter gives ample opportunity for typos and other errors in the indices of the individual elements to be initialized.</p>\n<p>Looking at today's C and C++, it's unclear to me why the author makes a distinction between C and C++. Both languages enable aggregate initialization for arrays.</p>\n<p>One possibility is that the author referred to old versions of the C Standard. Notably, in ANSI C (C89) an important restriction applied to the use of aggregate initialization: All initializers had to be constant expressions:</p>\n<pre><code>/* This is possible in C89: */\nf(int i)\n{ int ar[] = { 1 , 2 }; }\n\n/* But this is not\n   (because i is not a constant expression):\n*/\nf(int i)\n{ int ar[] = { i , i+1 }; }\n</code></pre>\n<p>This is due to 3.5.7 in C89 (quoting from the draft I found <a href=\"http://flash-gordon.me.uk/ansi.c.txt\" rel=\"noreferrer\">here</a>):</p>\n<blockquote>\n<p id=\"so_17712872_17713121_0\">All the expressions in an initializer for an object that has static storage duration or in an initializer list for an object that has aggregate or union type shall be constant expressions.</p>\n</blockquote>\n<p>This clearly limits the usefulness of aggregate initialization (and even in 1989, I believe many compilers implemented extensions to enable aggregate initialization also for non-constant expressions).</p>\n<p>Later versions of the C Standard did not have this restriction, and the standardized versions of C++ (starting with C++98), I believe, never had any such restriction.</p>\n<p>I can only speculate, but perhaps this is what the author had in mind?</p>\n", "CommentCount": "1", "Id": "17713121", "OwnerUserId": "777186", "LastActivityDate": "2013-07-18T01:44:47.987"}, "bq_ids": {"n3337": {"so_17712872_17713121_0": {"quality": 0.6, "length": 9, "section_id": 5947}}}});