post_cb({"bq_ids": {"n4140": {"so_2666578_2806385_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 3919}}, "n3337": {"so_2666578_2806385_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 3779}}}, "2666578": {"ViewCount": "2916", "Body": "<p>The questions are in bold, for those that cannot be bothered reading a question in depth.</p>\n<p>This is a followup to <a href=\"https://stackoverflow.com/questions/2652164/compile-time-meta-programming-with-string-literals\">this</a> question. It is to do with the initialization semantics of static variables in functions. Static variables should be initialized once, and their internal state might be altered later - as I (<strong>currently</strong>) do in the linked question. However, the code in question does not require the feature to change the state of the variable later. </p>\n<p>Let me clarrify my position, since I don't require the string object's internal state to change. The code is for a  trait class for meta programming, and as such would  would benifit from a const char * const ptr -- thus Ideally  a local cost static const variable is needed. My educated guess is that in this case the string in question will be optimally placed in memory by the link-loader, and that the code is more secure and maps to the intended semantics.</p>\n<p>This leads to the semantics of such a variable \"The C++ Programming language Third Edition -- Stroustrup\" does not have anything (that I could find) to say about this matter. All that is said is that the variable is initialized once when the flow of control of the thread first reaches the code. <strong>This leads me to ponder if the following code would be sensible, and if not what are the intended semantics ?.</strong></p>\n<pre><code>#include &lt;iostream&gt;\nconst char * const GetString(const char * x_in)\n{\n    static const char * const x = x_in;\n    return x;\n}\n\nint main()\n{\n  const char * const temp = GetString(\"yahoo\");\n  std::cout &lt;&lt; temp &lt;&lt; std::endl;\n  const char * const temp2 = GetString(\"yahoo2\");\n  std::cout &lt;&lt; temp2 &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The following compiles on GCC and prints \"yahoo\" twice. Which is what I want -- However it might not be standards compliant (which is why I post this question). It might be more elegant to have two functions, \"SetString\" and \"String\" where the latter forwards to the first. <strong>If it is standards compliant does someone know of a templates implementation in boost (or elsewhere) ?</strong></p>\n<p><strong>edit: 11-may-2010</strong> </p>\n<p>I am using the following macro to generate the above mentioned getter/setters in my classes that encode compile time information.</p>\n<pre><code>#define MACRO_STATIC_SETTING_PTR(name, type)                          \\\n  static const type const set_##name (const type const name##_in) {   \\\n    static const type const name = name##_in;                         \\\n    return name;                                                      \\\n  }                                                                   \\\n  static const type const name() {                                    \\\n    return set_##name(NULL);                                          \\\n  } \n\n#define MACRO_STATIC_SETTING(name, type)                              \\\n  static const type set_##name (const type name##_in) {               \\\n    static const type name = name##_in;                               \\\n    return name;                                                      \\\n  }                                                                   \\\n  static const type name() {                                          \\\n    return set_##name(NULL);                                          \\\n  } \n</code></pre>\n<p>These macros are placed inside a class declaration. For example:</p>\n<pre><code>template&lt;class tag&gt;\nclass ConfigInstance{\npublic:\n  MACRO_STATIC_SETTING_PTR(sqllite3_filename, char *)\n};\n</code></pre>\n<p>Hopefully this will be useful to others. </p>\n", "Title": "Function-Local Static Const variable Initialization semantics", "CreationDate": "2010-04-19T10:24:02.173", "LastActivityDate": "2010-11-10T09:57:42.710", "CommentCount": "7", "LastEditDate": "2017-05-23T12:01:05.443", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "2666578", "Score": "2", "OwnerUserId": "153865", "Tags": "<c++><metaprogramming><micro-optimization><generic-programming>", "AnswerCount": "1"}, "2806385": {"PostTypeId": "2", "Body": "<p>Let's look into part 6.7 \u00a74 (Declaration statement) of the C++ standard.</p>\n<blockquote>\n<p id=\"so_2666578_2806385_0\">An implementation  is  permitted to perform early initialization of other\n      local objects with static storage duration under the  same  conditions\n      that an implementation is permitted to statically initialize an object\n      with static storage duration in namespace scope.\n      Otherwise  such an object is initialized the first time control passes\n      through its declaration; such an object is considered initialized upon\n      the  completion of its initialization.</p>\n</blockquote>\n<p>So we have two cases:</p>\n<ol>\n<li>Either we now before we enter the function with a static local <code>x</code>, what value <code>x</code> will have. Then the compiler is allowed to initialize the value as early as possible (even at compile time).</li>\n<li>We don't now the value of <code>x</code> initialize it only the first time we enter our function.</li>\n</ol>\n<p>So yes what gcc does is not only what you want, this behavior is also standard compliant.</p>\n", "LastActivityDate": "2010-05-10T20:52:35.577", "Id": "2806385", "CommentCount": "1", "CreationDate": "2010-05-10T20:52:35.577", "ParentId": "2666578", "Score": "4", "OwnerUserId": "331618"}});