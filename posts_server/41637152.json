post_cb({"41637450": {"ParentId": "41637152", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>clang is right (see references below) - Since there are no possible conversions between <code>A</code> and <code>B</code>, overload resolution is used to determine the conversions to be applied to the operands, and the following (fictive) overload is selected:</p>\n<pre><code>int operator?:(bool, int, int);\n</code></pre>\n<p>There exists such a (again, fictive) overload of the <code>?:</code> operator for any pair of arithmetic types (see references below). </p>\n<hr>\n<h3>Standard rules:</h3>\n<p>Since you cannot convert <code>A</code> to <code>B</code> or <code>B</code> to <code>A</code>, then the following applies (<a href=\"https://timsong-cpp.github.io/cppwp/expr.cond#6\" rel=\"nofollow noreferrer\">[expr.cond]</a>):</p>\n<blockquote>\n<p id=\"so_41637152_41637450_0\">Otherwise, the result is a prvalue. If the second and third operands do not have the same type, and either\n  has (possibly cv-qualified) class type, overload resolution is used to determine the conversions (if any) to be\n  applied to the operands (13.3.1.2, 13.6). If the overload resolution fails, the program is ill-formed. Otherwise,\n  the conversions thus determined are applied, and the converted operands are used in place of the original\n  operands for the remainder of this section.</p>\n</blockquote>\n<p>This falls back to this (<a href=\"https://timsong-cpp.github.io/cppwp/over.match.oper#2\" rel=\"nofollow noreferrer\">[over.match.oper]</a>):</p>\n<blockquote>\n<p id=\"so_41637152_41637450_1\">If either operand has a type that is a class or an enumeration, a user-defined operator function might be\n  declared that implements this operator or a <strong>user-defined conversion can be necessary to convert the operand\n  to a type that is appropriate for a built-in operator.</strong></p>\n<p id=\"so_41637152_41637450_2\">[...]</p>\n<p id=\"so_41637152_41637450_3\">The set of candidate functions for overload resolution is the union of the member candidates, the non-member candidates, and <strong>the built-in candidates</strong>.</p>\n<p id=\"so_41637152_41637450_4\">If a built-in candidate is selected by overload resolution, <strong>the operands of class type are converted to the\n  types of the corresponding parameters of the selected operation function</strong>, except that the second standard\n  conversion sequence of a user-defined conversion sequence (13.3.3.1.2) is not applied.</p>\n</blockquote>\n<p>In your case, there is a built-in candidate (thanks to @cpplearner, <a href=\"http://eel.is/c++draft/over.built#25\" rel=\"nofollow noreferrer\">[over.built]</a>):</p>\n<blockquote>\n<p id=\"so_41637152_41637450_5\">For every pair of promoted arithmetic types L and R, there exist candidate operator functions of the form</p>\n<pre><code>LR      operator?:(bool, L, R);\n</code></pre>\n<p id=\"so_41637152_41637450_6\">where LR is the result of the usual arithmetic conversions between types L and R. [\u2009Note: As with all these descriptions of candidate functions, this declaration serves only to describe the built-in operator for purposes of overload resolution. The operator \u201c?:\u201d cannot be overloaded. \u2009\u2014\u2009end note\u2009]</p>\n</blockquote>\n<hr>\n<h3>Extra details:</h3>\n<p>Since the <code>?:</code> operator cannot be overloaded, this means that your code only works if both types can be converted to an arithmetic type (<code>int</code>). As a \"counter\"-example, the following code is ill-formed:</p>\n<pre><code>auto c = true ? A{} : B{}; // Error\n</code></pre>\n<p>Also note that you would get an ambiguous \"call\" if both types are convertible to both, e.g., <code>int</code> and <code>float</code>. There error (from gcc) is actually full of information:</p>\n<blockquote>\n<p id=\"so_41637152_41637450_7\">error: no match for ternary 'operator?:' (operand types are 'bool', 'A', and 'B')</p>\n<pre><code>auto c = true ? A{} : B{};\n~~~~~^~~~~~~~~~~\n</code></pre>\n<ul>\n<li>note: candidate: operator?:(bool, int, int) </li>\n<li>note: candidate: operator?:(bool, int, float) </li>\n<li>note: candidate: operator?:(bool, float, int) </li>\n<li>note: candidate: operator?:(bool, float, float) </li>\n</ul>\n</blockquote>\n</hr></hr>", "OwnerUserId": "2666289", "LastEditorUserId": "2666289", "LastEditDate": "2017-01-14T12:12:12.950", "Id": "41637450", "Score": "12", "CreationDate": "2017-01-13T14:59:25.847", "LastActivityDate": "2017-01-14T12:12:12.950"}, "41637152": {"CommentCount": "5", "AcceptedAnswerId": "41637450", "CreationDate": "2017-01-13T14:45:07.057", "LastActivityDate": "2017-01-14T12:12:12.950", "PostTypeId": "1", "ViewCount": "420", "FavoriteCount": "1", "Title": "c++ - Implicit conversions with the ternary operator", "Id": "41637152", "Score": "15", "Body": "<p>I have the following code:</p>\n<pre><code>class A {\npublic:\n    operator int() const { return 5; }\n};\n\nclass B {\npublic:\n    operator int() const { return 6; }\n};\n\nint main() {\n    A a;\n    B b;\n    int myInt = true ? a : b;\n    return 0;\n}\n</code></pre>\n<p>Attempting to compile that code with Visual Studio 2017 RC results in the error:<br>\n<code>ternarytest.cpp(14): error C2446: ':': no conversion from 'B' to 'A'</code><br>\nwhich is surprising because you'd expect it to convert them both to a common type (int).<br>\nClang 4.0 compiles the same code successfully without any errors or warnings.</br></br></br></p>\n<p>Which of the two is correct in this case?</p>\n", "Tags": "<c++><type-conversion><operator-keyword><implicit-conversion><ternary>", "OwnerUserId": "1000039", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41637152_41637450_0": {"section_id": 6171, "quality": 0.9473684210526315, "length": 36}, "so_41637152_41637450_6": {"section_id": 698, "quality": 0.8461538461538461, "length": 22}, "so_41637152_41637450_4": {"section_id": 588, "quality": 0.9583333333333334, "length": 23}, "so_41637152_41637450_3": {"section_id": 587, "quality": 0.9230769230769231, "length": 12}, "so_41637152_41637450_5": {"section_id": 686, "quality": 0.9166666666666666, "length": 11}, "so_41637152_41637450_1": {"section_id": 583, "quality": 1.0, "length": 22}}, "n3337": {"so_41637152_41637450_0": {"section_id": 5932, "quality": 0.9473684210526315, "length": 36}, "so_41637152_41637450_6": {"section_id": 688, "quality": 0.8461538461538461, "length": 22}, "so_41637152_41637450_4": {"section_id": 578, "quality": 0.5416666666666666, "length": 13}, "so_41637152_41637450_3": {"section_id": 577, "quality": 0.9230769230769231, "length": 12}, "so_41637152_41637450_5": {"section_id": 676, "quality": 0.9166666666666666, "length": 11}, "so_41637152_41637450_1": {"section_id": 573, "quality": 1.0, "length": 22}}, "n4659": {"so_41637152_41637450_0": {"section_id": 7669, "quality": 0.9473684210526315, "length": 36}, "so_41637152_41637450_6": {"section_id": 727, "quality": 0.8461538461538461, "length": 22}, "so_41637152_41637450_4": {"section_id": 611, "quality": 0.9583333333333334, "length": 23}, "so_41637152_41637450_3": {"section_id": 610, "quality": 0.9230769230769231, "length": 12}, "so_41637152_41637450_5": {"section_id": 715, "quality": 0.9166666666666666, "length": 11}, "so_41637152_41637450_1": {"section_id": 606, "quality": 1.0, "length": 22}}}});