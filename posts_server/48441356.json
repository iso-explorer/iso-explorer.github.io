post_cb({"48441547": {"Id": "48441547", "PostTypeId": "2", "Body": "<p>Your code is fine so long as the constructor of <code>B</code> doesn't <em>use</em> that reference it gets for anything other than binding its member. The storage for <code>a</code> has already been allocated when the c'tor of <code>C</code> starts, and like <a href=\"https://stackoverflow.com/a/48441423/817643\"><strong>Sneftel</strong></a> says, it's in scope. As such, you may take its reference, as <a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.life#7\" rel=\"noreferrer\">[basic.life]/7</a> explicitly allows:</p>\n<blockquote>\n<p id=\"so_48441356_48441547_0\">Similarly, before the lifetime of an object has started but after the\n  storage which the object will occupy has been allocated or, after the\n  lifetime of an object has ended and before the storage which the\n  object occupied is reused or released, any glvalue that refers to the\n  original object may be used but only in limited ways. For an object\n  under construction or destruction, see [class.cdtor]. Otherwise, such\n  a glvalue refers to allocated storage\n  ([basic.stc.dynamic.deallocation]), and using the properties of the\n  glvalue that do not depend on its value is well-defined. The program\n  has undefined behavior if:</p>\n<ul>\n<li>the glvalue is used to access the object, or</li>\n<li>the glvalue is used to call a non-static member function of the object, or</li>\n<li>the glvalue is bound to a reference to a virtual base class ([dcl.init.ref]), or</li>\n<li>the glvalue is used as the operand of a dynamic_\u00adcast or as the operand of typeid.</li>\n</ul>\n</blockquote>\n<p>Regarding your edit:</p>\n<blockquote>\n<p id=\"so_48441356_48441547_1\">What surprises me even more is that I can add a call to \"a.doSth();\" inside B constructor and this will also work. Why? At this moment the A object should not exist!</p>\n</blockquote>\n<p>Undefined behavior is undefined. The second bullet in the paragraph I linked to pretty much says it. A compiler may be clever enough to catch it, but it doesn't have to be.</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2018-01-25T11:17:35.240", "Score": "25", "CreationDate": "2018-01-25T11:14:01.507", "ParentId": "48441356", "CommentCount": "5", "OwnerUserId": "817643", "LastEditDate": "2018-01-25T11:17:35.240"}, "bq_ids": {"n4140": {"so_48441356_48441547_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 7194}}, "n3337": {"so_48441356_48441547_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 6938}}, "n4659": {"so_48441356_48441547_0": {"length": 51, "quality": 0.9272727272727272, "section_id": 8703}}}, "48441417": {"Id": "48441417", "PostTypeId": "2", "Body": "<p>It doesn't \"work\" in the sense that the <code>a</code> object used for initialization hasn't had its constructor called yet (which your logs reveal) - this means that the init of <code>b</code> might or might not fail depending on what <code>a</code> is doing.</p>\n<p>The compiler doesn't prevent that, but I guess it should. Anyway, I don't <em>think</em> this is UB unless you actually try to use the unitialized object; just storing the reference should be fine.</p>\n", "LastEditorUserId": "752976", "LastActivityDate": "2018-01-25T11:10:20.883", "Score": "0", "CreationDate": "2018-01-25T11:07:26.510", "ParentId": "48441356", "CommentCount": "3", "OwnerUserId": "752976", "LastEditDate": "2018-01-25T11:10:20.883"}, "48441533": {"Id": "48441533", "PostTypeId": "2", "Body": "<p>This works because you are not accessing uninitialized field <code>C::a</code> during <code>C::b</code>initialization. By calling <code>C() : b(a)</code> you are binding a reference to <code>a</code> to be supplied for <code>B(A&amp; a)</code> constructor. If you change your code to actually use uninitialized value somehow then it will be an undefined behavior:</p>\n<pre><code>struct B {\n   B(A&amp; a)\n   : m_a(a) // now this calls copy constructor attempting to access uninitialized value of `a`\n   { cout &lt;&lt; \"ctor B\" &lt;&lt; endl; }\n\n  void doSth() { a.doSth(); }\n\n   A m_a;\n};\n</code></pre>\n", "LastEditorUserId": "7860670", "LastActivityDate": "2018-01-25T11:18:38.733", "Score": "1", "CreationDate": "2018-01-25T11:13:21.937", "ParentId": "48441356", "CommentCount": "0", "OwnerUserId": "7860670", "LastEditDate": "2018-01-25T11:18:38.733"}, "48441356": {"ViewCount": "1756", "Body": "<p>Why does this code work? I expected this to fail because of breaking of one of the basic C++ rules:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct A {\n    A() { cout &lt;&lt; \"ctor A\" &lt;&lt; endl; }\n    void doSth() { cout &lt;&lt; \"a doing sth\" &lt;&lt; endl; }\n};\n\nstruct B {\n    B(A&amp; a) : a(a) { cout &lt;&lt; \"ctor B\" &lt;&lt; endl; }\n\n    void doSth() { a.doSth(); }\n\n    A&amp; a;\n};\n\nstruct C {\n    C() : b(a) { cout &lt;&lt; \"ctor C\" &lt;&lt; endl; }\n\n    void doSth() { b.doSth(); }\n\n    B b;\n    A a;\n};\n\nint main()\n{\n    C c;\n    c.doSth();\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/aoJsYkbhDO6pNrg0\" rel=\"noreferrer\">https://wandbox.org/permlink/aoJsYkbhDO6pNrg0</a></p>\n<p>I expected this to fail since in C's constructor, B is given a reference to object of A when this A object has not yet been created.</p>\n<p>Am I missing something? Does the rule of order of initialization being the same as the order of fields not apply for references?</p>\n<p>EDIT:\nWhat surprises me even more is that I can add a call to \"a.doSth();\" inside B constructor and this will also work. Why? At this moment the A object should not exist!</p>\n", "AcceptedAnswerId": "48441547", "Title": "Why does it work when it breaks the rule of order of initialization list", "CreationDate": "2018-01-25T11:04:11.497", "LastActivityDate": "2018-01-25T23:24:24.667", "CommentCount": "20", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2018-01-25T11:15:04.130", "LastEditorUserId": "7174778", "Id": "48441356", "Score": "21", "OwnerUserId": "7174778", "Tags": "<c++>", "AnswerCount": "6"}, "48441423": {"Id": "48441423", "PostTypeId": "2", "Body": "<p>In your code snippet, when <code>C</code> is being constructed, <code>a</code> has not been initialized <em>but it is already in scope</em>, so the compiler is not required to issue a diagnostic. Its value is undefined.</p>\n<p>The code is fine in the sense that <code>B::a</code> is properly an alias of <code>C::a</code>. The lifetime of the storage backing <code>C::a</code> has already begun by the time <code>B::B()</code> runs.</p>\n<p>With respect to your edit: Although <code>C::a</code>'s storage duration has already begun, <code>a.doSth()</code> from <code>B::B()</code> would absolutely result in undefined behavior (google to see why something can be UB and still \"work\").</p>\n", "LastEditorUserId": "787480", "LastActivityDate": "2018-01-25T11:17:59.437", "Score": "11", "CreationDate": "2018-01-25T11:07:35.673", "ParentId": "48441356", "CommentCount": "5", "OwnerUserId": "787480", "LastEditDate": "2018-01-25T11:17:59.437"}, "48441486": {"Id": "48441486", "PostTypeId": "2", "Body": "<p>It works because <code>B</code> is initialized with a reference, and that reference already exists so it can be used to initialize something with it.</p>\n<p>If you try with <code>a</code> being passed by value in ctor of <code>B</code> then the compiler would complain:</p>\n<blockquote>\n<p id=\"so_48441356_48441486_0\">warning: field 'a' is uninitialized when used here\n        [-Wuninitialized]</p>\n</blockquote>\n", "LastActivityDate": "2018-01-25T11:11:14.673", "Score": "0", "CreationDate": "2018-01-25T11:11:14.673", "ParentId": "48441356", "CommentCount": "0", "OwnerUserId": "719263"}, "48453526": {"Id": "48453526", "PostTypeId": "2", "Body": "<p>Undefined behavior means anything is possible, including appearing to work fine. Doesn't mean it will work fine next week or even the next time you run it - you might get <a href=\"http://www.catb.org/jargon/html/N/nasal-demons.html\" rel=\"nofollow noreferrer\">demons flying from your nose</a>.</p>\n<p>What's <em>probably</em> going on when you call <code>a.doSth()</code> is that the compiler converts the call to a static <code>a::doSth()</code>; since it's not a virtual function, it doesn't need to access the object to make the call. The function itself doesn't use any member variables or functions so no invalid accesses are generated. It works even though it's not guaranteed to work.</p>\n", "LastActivityDate": "2018-01-25T23:24:24.667", "Score": "1", "CreationDate": "2018-01-25T23:24:24.667", "ParentId": "48441356", "CommentCount": "0", "OwnerUserId": "5987"}});