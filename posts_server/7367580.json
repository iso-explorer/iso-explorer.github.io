post_cb({"7367778": {"ParentId": "7367580", "CommentCount": "3", "CreationDate": "2011-09-09T21:43:08.267", "OwnerUserId": "85371", "PostTypeId": "2", "Id": "7367778", "Score": "9", "Body": "<p>Casting away volatile would be ok, once the value is in fact no longer volatile. In SMP/multi-threading situations, this <em>could</em> become true after acquiring a lock (and passing a memory barrier, which is most often implicit in acquiring the lock).</p>\n<p>So a typical pattern for this would be</p>\n<pre><code> volatile long *pl = /*...*/;\n\n //\n {\n      Lock scope(m_BigLock);   /// acquire lock\n      long *p1nv = const_cast&lt;long *&gt;(p1);\n\n      // do work\n } // release lock and forget about p1nv!\n</code></pre>\n<p>But I could come up with a number of other scenarios in which values stop being volatile. I won't suggest them here, as I'm sure you can come up with them yourself, if you know what you're doing. Otherwise, the locking scenarios seems solid enough to provide as an example</p>\n", "LastActivityDate": "2011-09-09T21:43:08.267"}, "7368038": {"ParentId": "7367580", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-09-09T22:18:18.483", "Score": "16", "LastEditorUserId": "196844", "LastEditDate": "2011-09-09T22:46:08.417", "Id": "7368038", "OwnerUserId": "5597", "Body": "<p>If the variable is <strong>declared</strong> <code>volatile</code> then it is <strong>undefined behaviour</strong> to cast away the <code>volatile</code>, just as it is undefined behaviour to cast away the <code>const</code> from a variable declared <code>const</code>. See Annex J.2 of the C Standard:</p>\n<blockquote>\n<p id=\"so_7367580_7368038_0\">The behavior is undefined in the following circumstances:</p>\n<p id=\"so_7367580_7368038_1\">...</p>\n<p id=\"so_7367580_7368038_2\">\u2014 An attempt is made to modify an object defined with a const-qualified type through\n  use of an lvalue with non-const-qualified type (6.7.3).</p>\n<p id=\"so_7367580_7368038_3\">\u2014 An attempt is made to refer to an object defined with a volatile-qualified type through\n  use of an lvalue with non-volatile-qualified type (6.7.3).</p>\n</blockquote>\n<p>If, however, you just have a <code>volatile</code> pointer or a <code>volatile</code> reference to a non-<code>volatile</code> variable then you can freely cast away <code>volatile</code>.</p>\n<pre><code>volatile int i=0;\nint j=0;\n\nvolatile int* pvi=&amp;i; // ok\nvolatile int* pvj=&amp;j; // ok can take a volatile pointer to a non-volatile object\n\nint* pi=const_cast&lt;int*&gt;(pvi); // Danger Will Robinson! casting away true volatile\nint* pj=const_cast&lt;volatile int*&gt;(pvj); // OK\n*pi=3; // undefined behaviour, non-volatile access to volatile variable\n*pj=3; // OK, j is not volatile\n</code></pre>\n", "LastActivityDate": "2011-09-09T22:46:08.417"}, "7367580": {"CommentCount": "9", "ViewCount": "4290", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-09-09T21:22:06.387", "LastActivityDate": "2011-09-09T22:48:24.763", "Title": "C/C++: casting away volatile considered harmful?", "LastEditDate": "2017-05-23T11:46:13.853", "Id": "7367580", "Score": "12", "Body": "<p>(related to this question <a href=\"https://stackoverflow.com/questions/2474756/is-it-safe-to-cast-away-volatile\">Is It Safe to Cast Away volatile?</a>, but not quite the same, as that question relates to a specific instance)</p>\n<p><strong>Is there ever a case where casting away <code>volatile</code> is <em>not</em> considered a dangerous practice?</strong></p>\n<p>(one particular example: if there is a function declared</p>\n<pre><code>void foo(long *pl);\n</code></pre>\n<p>and I have to implement</p>\n<pre><code>void bar(volatile long *pl);\n</code></pre>\n<p>with part of my implementation requiring bar() to call foo(pl), then it seems like I can't get this to work as is, because the assumptions made by the compilation of foo() and the compilation of the caller of bar() are incompatible.)</p>\n<hr>\n<p>As a corollary, if I have a <code>volatile</code> variable v, and I want to call <code>foo(&amp;v)</code> with someone else's function <code>void foo(long *pl)</code>, and that person tells me it's safe, I can just cast the pointer before the call, my instinct is to tell them they're wrong because there's no way to guarantee that, and that they should change the declaration to <code>void foo(volatile long *pl)</code> if they want to support the use of volatile variables. Which one of us is correct?</p>\n</hr>", "Tags": "<c++><c><volatile>", "OwnerUserId": "44330", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_7367580_7368038_2": {"section_id": 5435, "quality": 0.6153846153846154, "length": 8}, "so_7367580_7368038_3": {"section_id": 5435, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_7367580_7368038_2": {"section_id": 5230, "quality": 0.6153846153846154, "length": 8}, "so_7367580_7368038_3": {"section_id": 5230, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_7367580_7368038_2": {"section_id": 6862, "quality": 0.5384615384615384, "length": 7}, "so_7367580_7368038_3": {"section_id": 6862, "quality": 0.6153846153846154, "length": 8}}}, "7368051": {"ParentId": "7367580", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-09-09T22:20:38.987", "Score": "5", "LastEditorUserId": "196844", "LastEditDate": "2011-09-09T22:48:24.763", "Id": "7368051", "OwnerUserId": "196844", "Body": "<p>With a signature of <code>foo(long *pl)</code>, the programmer is declaring that they are not expecting the pointed-to <code>long</code> value to change externally during the execution of <code>foo</code>. Passing a pointer to a <code>long</code> value that <em>is</em> being concurrently modified throughout an invocation might even lead to erroneous behavior if the compiler emits code that dereferences the pointer multiple times due to lack of registers and by it choosing not to store the value of the first dereference on the stack. For example, in:</p>\n<pre><code>void foo(long *pl) {\n\n    char *buf = (char *) malloc((size_t) *pl);\n\n    // ... busy work ...\n\n    // Now zero out buf:\n    long l;\n    for (l = 0; l &lt; *pl; ++l) {\n        buf[l] = 0;\n    }\n\n    free(buf);\n}\n</code></pre>\n<p><code>foo</code> could overrun the buffer in the \"zero out buf\" step if the <code>long</code> value is increased while the busy work is being performed.</p>\n<p>If the <code>foo()</code> function is supposed to atomically increment the <code>long</code> value pointed to by <code>pl</code>, then it would be incorrect for the function to take <code>long *pl</code> and not <code>volatile long *pl</code> because the function clearly requires that accesses of the <code>long</code> value be a sequence point. If <code>foo()</code> only atomically incremented, the function might work, but it would not be correct.</p>\n<p>Two solutions to this problem have already been suggested in comments:</p>\n<ol>\n<li><p>Wrap <code>foo</code> taking <code>long *</code> in an overload taking <code>volatile long *</code>:</p>\n<pre><code>inline void foo(volatile long *pvl) {\n    long l = *pvl;\n    foo(&amp;l);\n    *pvl = l;\n}\n</code></pre></li>\n<li><p>Change the declaration of <code>foo</code> to <code>void foo(volatile long *pvl)</code>.</p></li>\n</ol>\n", "LastActivityDate": "2011-09-09T22:48:24.763"}});