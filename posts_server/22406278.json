post_cb({"22407068": {"ParentId": "22406278", "CommentCount": "0", "Body": "<p><code>malloc()</code> allocates the memory and sends the address of the first block to the assigned pointer variable,in the case of new it allocates the memory and returns the address .it is a convention that when you use a <code>malloc()</code> function we should use delete function and when you are allocating memory with the help of new function the usage of <code>free()</code> function is comfortable.when <code>malloc()</code>it is a convention that we should use the corresponding <code>realloc(),calloc(),delete()</code> functions and similarly,when you use <code>new()</code> function the corresponding <code>free()</code>function is used. </p>\n", "OwnerUserId": "3415603", "PostTypeId": "2", "Id": "22407068", "Score": "0", "CreationDate": "2014-03-14T13:56:44.167", "LastActivityDate": "2014-03-14T13:56:44.167"}, "22406916": {"ParentId": "22406278", "CommentCount": "0", "Body": "<p>As you've heard now, you can't mix them.</p>\n<p>Keep in mind that in C++ it's common to have lots of relatively small temporary objects dynamically allocated (for instance, it's easy to write code like <code>my_string + ' ' + your_string + '\\n'</code>), while in C memory allocation's typically more deliberate, often with a larger average allocation size and longer lifetime (much more likely someone would directly <code>malloc(strlen(my_string) + strlen(your_string) + 3)</code> for the result without any temporary buffers).  For that reason, some C++ libraries will optimise for large numbers of small transient objects.  They might, for instance, use <code>malloc()</code> to get three 16k blocks, then use each for fixed-size requests of up to 16, 32 and 64 bytes respectively.  If you call <code>delete</code> in such a situation, it doesn't free anything - it just returns the particular entry in the 16k buffer to a C++-library free list.  If you called <code>free()</code> and the pointer happened to be to the first element in the 16k buffer, you'd accidentally deallocate all the elements; if it wasn't to the first you have undefined behaviour (but some implementations like Visual C++ apparently still free blocks given a pointer anywhere inside them).</p>\n<p>So - really, really don't do it.</p>\n<p>Even if it ostensibly works on your current system, it's a bomb waiting to go off.  Different runtime behaviour (based on different inputs, thread race conditions etc.) could cause a later failure.  Compilation with different optimisation flags, compiler version, OS etc. could all break it at any time.</p>\n", "OwnerUserId": "410767", "PostTypeId": "2", "Id": "22406916", "Score": "2", "CreationDate": "2014-03-14T13:50:23.103", "LastActivityDate": "2014-03-14T13:50:23.103"}, "22406352": {"ParentId": "22406278", "CommentCount": "1", "Body": "<p>You MUST match calls to <code>malloc</code> with <code>free</code> and <code>new</code> with <code>delete</code>.  Mixing/matching them is not an option.</p>\n", "OwnerUserId": "2376156", "PostTypeId": "2", "Id": "22406352", "Score": "16", "CreationDate": "2014-03-14T13:27:14.680", "LastActivityDate": "2014-03-14T13:27:14.680"}, "22406327": {"ParentId": "22406278", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You must use <code>delete</code> operator to deallocate memory when it is allocated by <code>new</code> operator.  </p>\n", "OwnerUserId": "2455888", "LastEditorUserId": "2455888", "LastEditDate": "2014-03-14T13:37:09.020", "Id": "22406327", "Score": "0", "CreationDate": "2014-03-14T13:26:17.900", "LastActivityDate": "2014-03-14T13:37:09.020"}, "22406278": {"CommentCount": "6", "ViewCount": "876", "PostTypeId": "1", "ClosedDate": "2014-03-14T16:06:15.097", "LastEditorUserId": "1009479", "CreationDate": "2014-03-14T13:24:27.633", "LastActivityDate": "2014-06-06T02:18:06.877", "Title": "Is it safe to `free()` memory allocated by `new`?", "AcceptedAnswerId": "22406540", "LastEditDate": "2014-06-06T02:18:06.877", "Id": "22406278", "Score": "6", "Body": "<p>I'm working on a C++ library, one of whose functions returns a (freshly allocated) pointer to an array of doubles. The API states that it is the responsibility of the caller to deallocate the memory.</p>\n<p>However, that C++ library used to be implemented in C and the function in question allocates the memory with <code>malloc()</code>. It also assumes that the caller will deallocate that memory with <code>free()</code>.</p>\n<p>Can I safely replace the call to <code>malloc()</code> with a call to <code>new</code>? Will the existing client code (that uses <code>free()</code> break if I do so? All I could find so far was the official documentation of <code>free()</code>, which states that</p>\n<blockquote>\n<p id=\"so_22406278_22406278_0\">If ptr does not point to a block of memory allocated with [malloc, calloc or realloc], it causes undefined behavior.</p>\n</blockquote>\n<p>But I believe this was written before C++ came along with its own allocation operators.</p>\n", "Tags": "<c++><memory-management>", "OwnerUserId": "1428", "AnswerCount": "6"}, "22406960": {"ParentId": "22406278", "CommentCount": "0", "Body": "<p>The library should really provide a deallocation function that forwards to the correct function.</p>\n<p>In addition to what the others already said (no compatibility guarantee), there is also the possibility that the library is linked to a different C library than your program, and so invoking <code>free()</code> on a pointer received from them would pass it to the wrong deallocation function even if the function names are correct.</p>\n", "OwnerUserId": "613064", "PostTypeId": "2", "Id": "22406960", "Score": "1", "CreationDate": "2014-03-14T13:52:21.727", "LastActivityDate": "2014-03-14T13:52:21.727"}, "bq_ids": {"n4140": {"so_22406278_22406540_2": {"section_id": 4272, "quality": 0.8, "length": 12}, "so_22406278_22406540_0": {"section_id": 4270, "quality": 0.7777777777777778, "length": 7}, "so_22406278_22406540_1": {"section_id": 4271, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_22406278_22406540_2": {"section_id": 4113, "quality": 0.8, "length": 12}, "so_22406278_22406540_0": {"section_id": 4111, "quality": 0.7777777777777778, "length": 7}, "so_22406278_22406540_1": {"section_id": 4112, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_22406278_22406540_2": {"section_id": 5531, "quality": 0.6, "length": 9}, "so_22406278_22406540_0": {"section_id": 3233, "quality": 0.6666666666666666, "length": 6}, "so_22406278_22406540_1": {"section_id": 5528, "quality": 0.5833333333333334, "length": 7}}}, "22406540": {"ParentId": "22406278", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You are not allowed to mix and match <code>malloc</code> and <code>free</code> with <code>new</code> and <code>delete</code> the draft C++ standard refers back to the C99 standard for this and if we go to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>20.6.13</code> <em>C library</em> it says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_22406278_22406540_0\">The contents are the same as the Standard C library header stdlib.h, with the following changes:</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_22406278_22406540_1\">The functions calloc(), malloc(), and realloc() do not attempt to allocate storage by calling ::operator\n  new() (18.6).</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_22406278_22406540_2\">The function free() does not attempt to deallocate storage by calling ::operator delete().\n  See also: ISO C Clause 7.11.2.</p>\n</blockquote>\n<p>and includes other changes, none of which state that we can use <code>free</code> on contents allocated with <code>new</code>. So section <code>7.20.3.2</code> <em>The free function</em> from the draft C99 standard is still the proper reference and it says:</p>\n<blockquote>\n<p id=\"so_22406278_22406540_3\">Otherwise, if the argument does not match a pointer earlier returned by the calloc, malloc, or realloc function, or if the space has been deallocated by a call to free or realloc, <strong>the behavior is undefined</strong>.</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-06-06T02:15:27.087", "Id": "22406540", "Score": "5", "CreationDate": "2014-03-14T13:36:06.013", "LastActivityDate": "2014-06-06T02:15:27.087"}});