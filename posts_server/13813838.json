post_cb({"13813838": {"CommentCount": "3", "AcceptedAnswerId": "13814380", "PostTypeId": "1", "LastEditorUserId": "436025", "CreationDate": "2012-12-11T04:50:35.297", "LastActivityDate": "2012-12-23T17:56:47.550", "LastEditDate": "2012-12-11T05:00:35.077", "ViewCount": "3481", "FavoriteCount": "1", "Title": "Perfect Forwarding to async lambda", "Id": "13813838", "Score": "10", "Body": "<p>I have a function template, where I want to do perfect forwarding into a lambda that I run on another thread. Here is a minimal test case which you can directly compile:</p>\n<pre><code>#include &lt;thread&gt;\n#include &lt;future&gt;\n#include &lt;utility&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n/**\n * Function template that does perfect forwarding to a lambda inside an\n * async call (or at least tries to). I want both instantiations of the\n * function to work (one for lvalue references T&amp;, and rvalue reference T&amp;&amp;).\n * However, I cannot get the code to compile when calling it with an lvalue.\n * See main() below.\n */\ntemplate &lt;typename T&gt;\nstd::string accessValueAsync(T&amp;&amp; obj)\n{\n\n    std::future&lt;std::string&gt; fut =\n        std::async(std::launch::async,\n            [](T&amp;&amp; vec) mutable\n            {\n                return vec[0];\n            },\n            std::forward&lt;T&gt;(obj));\n\n    return fut.get();\n}\n\nint main(int argc, char const *argv[])\n{\n    std::vector&lt;std::string&gt; lvalue{\"Testing\"};\n\n    // calling with what I assume is an lvalue reference does NOT compile\n    std::cout &lt;&lt; accessValueAsync(lvalue) &lt;&lt; std::endl;\n\n    // calling with rvalue reference compiles\n    std::cout &lt;&lt; accessValueAsync(std::move(lvalue)) &lt;&lt; std::endl;\n\n    // I want both to compile.\n\n    return 0;\n}\n</code></pre>\n<p>For the non-compiling case, here is the last line of the error message which is intelligible:</p>\n<pre><code>main.cpp|13 col 29| note:   no known conversion for argument 1 from \u2018std::vector&lt;std::basic_string&lt;char&gt; &gt;\u2019 to \u2018std::vector&lt;std::basic_string&lt;char&gt; &gt;&amp;\u2019\n</code></pre>\n<p>I have a feeling it may have something to do with how <code>T&amp;&amp;</code> is deduced, but I can't pinpoint the exact point of failure and fix it. Any suggestions?</p>\n<p>Thank you!</p>\n<p>EDIT: I am using gcc 4.7.0 just in case this could be a compiler issue (probably not)</p>\n", "Tags": "<c++><c++11><lambda><perfect-forwarding><stdasync>", "OwnerUserId": "436025", "AnswerCount": "1"}, "13814380": {"ParentId": "13813838", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The way I understand it you cannot use a function through <code>async</code> that expects non-const lvalue references as arguments, because <code>async</code> will always make a copy of them internally (or move them inside) to ensure they exist and are valid throughout the running time of the thread created.</p>\n<p>Specifically, the Standard says about <code>async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args)</code>:</p>\n<blockquote>\n<p id=\"so_13813838_13814380_0\">(\u00a730.6.8)  </p>\n<p id=\"so_13813838_13814380_1\">(2) Requires: <code>F</code> and each <code>Ti</code> in <code>Args</code> shall satisfy the MoveConstructible requirements. <code>INVOKE(DECAY_COPY (std::forward&lt;F&gt;(f)), DECAY_COPY (std::forward&lt;Args&gt;(args))...)</code> (20.8.2, 30.3.1.2) shall be a valid expression.</p>\n<p id=\"so_13813838_13814380_2\">(3) Effects: [...] if policy &amp; launch::async is non-zero \u2014 calls <code>INVOKE(DECAY_COPY (std::forward&lt;F&gt;(f)),DECAY_COPY (std::forward&lt;Args&gt;(args))...)</code> (20.8.2, 30.3.1.2) as if in a new thread of execution represented by a thread object with the calls to <code>DECAY_COPY()</code> being evaluated in the thread that called async. Any return value is stored as the result in the shared state. Any exception propagated from the execution of INVOKE (DECAY_COPY (std::forward(f)), DECAY_COPY (std::forward(args))...) is stored as the exceptional result in the shared state.<br>\n  The thread object is stored in the shared state and affects the behavior of any asynchronous\n  return objects that reference that state.</br></p>\n</blockquote>\n<p>Unfortunately, this means you cannot even replace the reference with a <code>std::reference_wrapper</code>, because the latter isn't move-constructible. I suppose using a <code>std::unique_ptr</code> instead of the reference would work (implying, however, that your function arguments will always live on the heap).</p>\n<p><strong>(EDIT/CORRECTION)</strong><br>\nI was working on a related problem when I realized that <code>std::reference_wrapper</code> actually enables a workaround, although I claimed the opposite above.</br></p>\n<p>If you define a function that wraps lvalue references in a <code>std::reference_wrapper</code>, but leaves rvalue references unchanged, you can pass the <code>T&amp;&amp;</code> argument through this function before handing it over to <code>std::async</code>. I have called this special wrapper function <code>wrap_lval</code> below:</p>\n<pre><code>#include &lt;thread&gt;\n#include &lt;future&gt;\n#include &lt;utility&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;type_traits&gt;\n\n/* First the two definitions of wrap_lval (one for rvalue references,\n   the other for lvalue references). */\n\ntemplate &lt;typename T&gt;\nconstexpr T&amp;&amp;\nwrap_lval(typename std::remove_reference&lt;T&gt;::type &amp;&amp;obj) noexcept\n{ return static_cast&lt;T&amp;&amp;&gt;(obj); }\n\ntemplate &lt;typename T&gt;\nconstexpr std::reference_wrapper&lt;typename std::remove_reference&lt;T&gt;::type&gt;\nwrap_lval(typename std::remove_reference&lt;T&gt;::type &amp;obj) noexcept\n{ return std::ref(obj); }\n\n\n/* The following is your code, except for one change. */\ntemplate &lt;typename T&gt;\nstd::string accessValueAsync(T&amp;&amp; obj)\n{\n\n  std::future&lt;std::string&gt; fut =\n    std::async(std::launch::async,\n           [](T&amp;&amp; vec) mutable\n           {\n             return vec[0];\n           },\n           wrap_lval&lt;T&gt;(std::forward&lt;T&gt;(obj)));   // &lt;== Passing obj through wrap_lval\n\n  return fut.get();\n}\n\nint main(int argc, char const *argv[])\n{\n  std::vector&lt;std::string&gt; lvalue{\"Testing\"};\n\n  std::cout &lt;&lt; accessValueAsync(lvalue) &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; accessValueAsync(std::move(lvalue)) &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>With this change, both calls to <code>accessValueAsync</code> compile and work. The first one, which uses an lvalue reference, automatically wraps it in a <code>std::reference_wrapper</code>. The latter is automatically converted back to an lvalue reference when <code>std::async</code> calls the lambda function.</p>\n", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2012-12-23T17:56:47.550", "Id": "13814380", "Score": "6", "CreationDate": "2012-12-11T05:48:07.467", "LastActivityDate": "2012-12-23T17:56:47.550"}, "bq_ids": {"n4140": {"so_13813838_13814380_2": {"section_id": 3161, "quality": 0.7368421052631579, "length": 42}, "so_13813838_13814380_1": {"section_id": 2708, "quality": 0.5714285714285714, "length": 8}}, "n3337": {"so_13813838_13814380_2": {"section_id": 3034, "quality": 0.7368421052631579, "length": 42}, "so_13813838_13814380_1": {"section_id": 2670, "quality": 0.5714285714285714, "length": 8}}, "n4659": {"so_13813838_13814380_2": {"section_id": 3923, "quality": 0.7192982456140351, "length": 41}}}});