post_cb({"38875293": {"ParentId": "38874913", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>You might think that the non-<code>explicit</code> <code>operator bool</code> in <code>Derived</code> doesn't override <code>explicit</code> <code>operator bool</code> in <code>Base</code>, no, it <strong>does</strong>. The <a href=\"http://en.cppreference.com/w/cpp/language/explicit\" rel=\"nofollow\">explicit specifier</a> doesn't matter, it's not a part of function signature.</p>\n<p>From the standard, <a href=\"http://eel.is/c++draft/class.virtual#2\" rel=\"nofollow\">$10.3/2 Virtual functions\n[class.virtual]</a>:</p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_38874913_38875293_0\">If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a member function <code>vf</code> with <strong>the same name, parameter-type-list ([dcl.fct]), cv-qualification, and ref-qualifier (or absence of same)</strong> as <code>Base::vf</code> is declared, then <code>Derived::vf</code> is also virtual (whether or not it is so declared) and it overrides <code>Base::vf</code>.</p>\n</blockquote>\n<p>So the compiler will complain only when the name, parameter-type-list, cv-qualification or ref-qualifier of the function doesn't match, the explicit specifier won't be considered.</p>\n<hr>\n<p><sup>You said \"marked <code>override</code> without a <code>virtual</code> declaration\", note that the <code>virtual</code> declaration for member function in derived class doesn't matter, which will be also <code>virtual</code>.</sup></p>\n</hr>", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2016-08-10T15:41:46.427", "Id": "38875293", "Score": "16", "CreationDate": "2016-08-10T13:47:17.260", "LastActivityDate": "2016-08-10T15:41:46.427"}, "38874913": {"CommentCount": "3", "ViewCount": "569", "PostTypeId": "1", "LastEditorUserId": "3309790", "CreationDate": "2016-08-10T13:31:42.983", "LastActivityDate": "2016-08-10T15:41:46.427", "Title": "Virtual explicit conversion operator overriding", "AcceptedAnswerId": "38875293", "LastEditDate": "2016-08-10T14:38:28.033", "Id": "38874913", "Score": "23", "Body": "<p>I have a class <code>Base</code> defining an <code>explicit operator bool</code>:</p>\n<pre><code>struct Base {\n    virtual explicit operator bool() const {\n        return true;\n    }\n};\n</code></pre>\n<p>And I have a subclass <code>Derived</code>, defining an <code>operator bool</code>:</p>\n<pre><code>struct Derived : Base {\n    operator bool() const override {\n        return false;\n    }\n};\n</code></pre>\n<p>As you can observe, <code>Derived::operator bool</code> is explicitly not marked <code>explicit</code>, but marked <code>override</code>, so I expected the compiler to complain. However, both gcc and clang seem to agree that this is valid. Was my expectation unreasonable?</p>\n<p>Moreover, if I use the classes as follows, <code>TakesBool(base)</code> does not compile (as expected), but <code>TakesBool(derived)</code> does:</p>\n<pre><code>void TakesBool(bool b) {}\n\nint main() {\n    //Base base;     TakesBool(base); // compilation error (as expected)\n    Derived derived; TakesBool(derived);\n    return 0;\n}\n</code></pre>\n<p>This seems to indicate that <code>Derived</code> has an (non-<code>explicit</code>) <code>operator bool</code>, which, however, is marked <code>override</code> without a <code>virtual</code> declaration. How is this possible?</p>\n", "Tags": "<c++><c++11><operator-overloading><override><explicit>", "OwnerUserId": "255688", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_38874913_38875293_0": {"section_id": 7003, "quality": 0.9375, "length": 30}}, "n3337": {"so_38874913_38875293_0": {"section_id": 6749, "quality": 0.9375, "length": 30}}, "n4659": {"so_38874913_38875293_0": {"section_id": 8500, "quality": 0.9375, "length": 30}}}});