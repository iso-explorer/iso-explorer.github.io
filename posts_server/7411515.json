post_cb({"7412269": {"ParentId": "7411515", "CommentCount": "5", "Body": "<p>Congratulations, you've invented a case in which there need not be any user defined constructor for the <code>const</code> declaration with no initializer to make sense.</p>\n<p>Now can you come up with a reasonable re-wording of the rule that covers your case but still makes the cases that should be illegal illegal? Is it less than 5 or 6 paragraphs? Is it easy and obvious how it should be applied in any situation?</p>\n<p>I posit that coming up with a rule that allows the declaration you created to make sense is really hard, and making sure that the rule can be applied in a way that makes sense to people when reading code is even harder. I would prefer a somewhat restrictive rule that was the right thing to do in most cases to a very nuanced and complex rule that was difficult to understand and apply.</p>\n<p>The question is, is there a compelling reason the rule should be more complex? Is there some code that would otherwise be very difficult to write or understand that can be written much more simply if the rule is more complex?</p>\n", "OwnerUserId": "167958", "PostTypeId": "2", "Id": "7412269", "Score": "1", "CreationDate": "2011-09-14T06:43:13.080", "LastActivityDate": "2011-09-14T06:43:13.080"}, "7411661": {"ParentId": "7411515", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Pure speculation on my part, but consider that other types have a similar restriction, too:</p>\n<pre><code>int main()\n{\n    const int i; // invalid\n}\n</code></pre>\n<p>So not only is this rule consistent, but it also (recursively) prevents unitialized <code>const</code> (sub)objects:</p>\n<pre><code>struct X {\n    int j;\n};\nstruct A {\n    int i;\n    X x;\n}\n\nint main()\n{\n    const A a; // a.i and a.x.j in unitialized states!\n}\n</code></pre>\n<hr>\n<p>As for the other side of the question (allowing it for types with a default constructor), I think the idea is that a type with a user-provided default constructor is supposed to always be in some sensible state after construction. Note that the rules as they are allow for the following:</p>\n<pre><code>struct A {\n    explicit\n    A(int i): initialized(true), i(i) {} // valued constructor\n\n    A(): initialized(false) {}\n\n    bool initialized;\n    int i;\n};\n\nconst A a; // class invariant set up for the object\n           // yet we didn't pay the cost of initializing a.i\n</code></pre>\n<p>Then perhaps we could formulate a rule like 'at least one member must be sensibly initialized in a user-provided default constructor', but that's way too much time spent trying to protect against Murphy. C++ tends to trust the programmer on certain points.</p>\n</hr>", "OwnerUserId": "726300", "LastEditorUserId": "726300", "LastEditDate": "2011-09-14T05:45:51.540", "Id": "7411661", "Score": "11", "CreationDate": "2011-09-14T05:29:39.527", "LastActivityDate": "2011-09-14T05:45:51.540"}, "7411708": {"ParentId": "7411515", "PostTypeId": "2", "CommentCount": "17", "Body": "<p>The reason is that if the class doesn't have a user-defined constructor, then it can be POD, and the POD class is not initialized by default. So if you declare a const object of POD which is uninitialized, what use of it? So I think the Standard enforces this rule so that the object can actually be useful.</p>\n<pre><code>struct POD\n{\n  int i;\n};\n\nPOD p1; //uninitialized - but don't worry we can assign some value later on!\np1.i = 10; //assign some value later on!\n\nPOD p2 = POD(); //initialized\n\nconst POD p3 = POD(); //initialized \n\nconst POD p4; //uninitialized  - error - as we cannot change it later on!\n</code></pre>\n<p>But if you make the class a non-POD:</p>\n<pre><code>struct nonPOD_A\n{\n    nonPOD_A() {} //this makes non-POD\n};\n\nnonPOD_A a1; //initialized \nconst nonPOD_A a2; //initialized \n</code></pre>\n<p>Note the difference between POD and non-POD.</p>\n<p>User-defined constructor is one way to make the class non-POD. There are several ways you can do that.</p>\n<pre><code>struct nonPOD_B\n{\n    virtual void f() {} //virtual function make it non-POD\n};\n\nnonPOD_B b1; //initialized \nconst nonPOD_B b2; //initialized \n</code></pre>\n<p>Notice nonPOD_B doesn't defined user-defined constructor. Compile it. It will compile:</p>\n<ul>\n<li><a href=\"http://www.ideone.com/h7TsA\">http://www.ideone.com/h7TsA</a></li>\n</ul>\n<p>And comment the virtual function, then it gives error, as expected:</p>\n<ul>\n<li><a href=\"http://www.ideone.com/SWk7B\">http://www.ideone.com/SWk7B</a></li>\n</ul>\n<hr>\n<p>Well, I think, you misunderstood the passage. It first says this (\u00a78.5/9):</p>\n<blockquote>\n<p id=\"so_7411515_7411708_0\">If no initializer is specified for an object, and the object is of (possibly cv-qualified) <strong>non-POD class</strong> type (or array thereof), the object shall be default-initialized; [...]</p>\n</blockquote>\n<p>It talks about non-POD class <em>possibly cv-qualified</em> type. That is, the non-POD object shall be default-initialized if there is no initializer specified. And what is <em>default-initialized</em>? For non-POD, the spec says (\u00a78.5/5),</p>\n<blockquote>\n<p id=\"so_7411515_7411708_1\">To default-initialize an object of type T means:<br>\n  \u2014 if T is a non-POD class type (clause 9), the default constructor for T is called (and the initialization is ill-formed if T has no accessible default constructor);</br></p>\n</blockquote>\n<p>It simply talks about <em>default constructor</em> of T, whether its user-defined or compiler-generated is irrelevant.</p>\n<p>If you're clear up to this, then understand what the spec next says ((\u00a78.5/9),</p>\n<blockquote>\n<p id=\"so_7411515_7411708_2\">[...]; if the object is of const-qualified type, the underlying class type shall have a user-declared default constructor.</p>\n</blockquote>\n<p>So this text implies, the program will be ill-formed <strong>if</strong> the object is of <em>const-qualified</em> POD type, and there is no initializer specified (because POD are not default initialized):</p>\n<pre><code>POD p1; //uninitialized - can be useful - hence allowed\nconst POD p2; //uninitialized - never useful  - hence not allowed - error\n</code></pre>\n<p>By the way, <a href=\"http://www.ideone.com/1fZ3a\">this compiles fine</a>, because its non-POD, and can be <em>default-initialized</em>.</p>\n</hr>", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-09-14T06:31:38.150", "Id": "7411708", "Score": "64", "CreationDate": "2011-09-14T05:35:45.127", "LastActivityDate": "2011-09-14T06:31:38.150"}, "7411515": {"CommentCount": "5", "AcceptedAnswerId": "47368753", "PostTypeId": "1", "LastEditorUserId": "885306", "CreationDate": "2011-09-14T05:08:52.020", "LastActivityDate": "2017-11-18T17:10:48.937", "LastEditDate": "2011-09-14T05:17:31.987", "ViewCount": "12750", "FavoriteCount": "23", "Title": "Why does C++ require a user-provided default constructor to default-construct a const object?", "Id": "7411515", "Score": "86", "Body": "<p>The C++ standard (section 8.5) says:</p>\n<blockquote>\n<p id=\"so_7411515_7411515_0\">If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type with a user-provided default constructor.</p>\n</blockquote>\n<p>Why? I can't think of any reason why a user-provided constructor is required in this case.</p>\n<pre><code>struct B{\n  B():x(42){}\n  int doSomeStuff() const{return x;}\n  int x;\n};\n\nstruct A{\n  A(){}//other than \"because the standard says so\", why is this line required?\n\n  B b;//not required for this example, just to illustrate\n      //how this situation isn't totally useless\n};\n\nint main(){\n  const A a;\n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "885306", "AnswerCount": "4"}, "47368753": {"ParentId": "7411515", "CommentCount": "2", "Body": "<p>This was considered a defect (against all versions of the standard) and it was resolved by <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#253\" rel=\"nofollow noreferrer\">Core Working Group (CWG) Defect 253</a>. The new wording for the standard states in <a href=\"http://eel.is/c++draft/dcl.init#7\" rel=\"nofollow noreferrer\">http://eel.is/c++draft/dcl.init#7</a></p>\n<blockquote>\n<p id=\"so_7411515_47368753_0\">A class type T is const-default-constructible if\n  default-initialization of T would invoke a user-provided constructor\n  of T (not inherited from a base class) or if</p>\n<ul>\n<li>each direct non-variant non-static data member M of T has a default member initializer or, if M is of class type X (or array thereof), X\n  is const-default-constructible,</li>\n<li>if T is a union with at least one non-static data member, exactly one variant member has a default member initializer,</li>\n<li>if T is not a union, for each anonymous union member with at least one non-static data member (if any), exactly one non-static data\n  member has a default member initializer, and</li>\n<li>each potentially constructed base class of T is const-default-constructible.</li>\n</ul>\n<p id=\"so_7411515_47368753_1\">If a program calls for the default-initialization of an object of a\n  const-qualified type T, T shall be a const-default-constructible class\n  type or array thereof.</p>\n</blockquote>\n<p>This wording essentially means that the obvious code works. If you initialize all of your bases and members, you can say <code>A const a;</code> regardless of how or if you spell any constructors.</p>\n<pre><code>struct A {\n};\nA const a;\n</code></pre>\n<p>gcc has accepted this since 4.6.4. clang has accepted this since 3.9.0. Visual Studio also accepts this (at least in 2017, not sure if sooner).</p>\n", "OwnerUserId": "852254", "PostTypeId": "2", "Id": "47368753", "Score": "4", "CreationDate": "2017-11-18T17:10:48.937", "LastActivityDate": "2017-11-18T17:10:48.937"}, "bq_ids": {"n4140": {"so_7411515_7411708_1": {"section_id": 3286, "quality": 0.8125, "length": 13}, "so_7411515_7411708_0": {"section_id": 421, "quality": 0.7692307692307693, "length": 10}, "so_7411515_7411708_2": {"section_id": 369, "quality": 0.7, "length": 7}, "so_7411515_47368753_1": {"section_id": 369, "quality": 0.6, "length": 6}, "so_7411515_7411515_0": {"section_id": 3286, "quality": 1.0, "length": 11}}, "n3337": {"so_7411515_7411708_1": {"section_id": 3156, "quality": 0.875, "length": 14}, "so_7411515_7411708_0": {"section_id": 413, "quality": 0.7692307692307693, "length": 10}, "so_7411515_7411708_2": {"section_id": 359, "quality": 0.7, "length": 7}, "so_7411515_47368753_1": {"section_id": 359, "quality": 0.6, "length": 6}, "so_7411515_7411515_0": {"section_id": 3156, "quality": 1.0, "length": 11}}, "n4659": {"so_7411515_7411708_1": {"section_id": 4049, "quality": 0.5625, "length": 9}, "so_7411515_7411708_2": {"section_id": 382, "quality": 0.6, "length": 6}, "so_7411515_7411708_0": {"section_id": 439, "quality": 0.7692307692307693, "length": 10}, "so_7411515_7411515_0": {"section_id": 382, "quality": 0.6363636363636364, "length": 7}, "so_7411515_47368753_1": {"section_id": 4048, "quality": 1.0, "length": 10}, "so_7411515_47368753_0": {"section_id": 4048, "quality": 0.9090909090909091, "length": 10}}}});