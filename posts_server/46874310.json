post_cb({"bq_ids": {"n4140": {"so_46874310_46874564_0": {"length": 7, "quality": 1.0, "section_id": 818}, "so_46874310_46874564_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 710}, "so_46874310_46874444_0": {"length": 19, "quality": 0.95, "section_id": 986}}, "n3337": {"so_46874310_46874564_0": {"length": 7, "quality": 1.0, "section_id": 807}, "so_46874310_46874564_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 699}, "so_46874310_46874444_0": {"length": 11, "quality": 0.55, "section_id": 807}}, "n4659": {"so_46874310_46874564_0": {"length": 7, "quality": 1.0, "section_id": 877}, "so_46874310_46874564_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 739}, "so_46874310_46874444_0": {"length": 20, "quality": 1.0, "section_id": 1049}}}, "46874310": {"ViewCount": "437", "Body": "<p>I've checked a lot of move constructor/vector/noexcept threads, but I am still unsure what actually happens when things are supposed to go wrong. I can't produce an error when I expect to, so either my little test is wrong, or my understanding of the problem is wrong.</p>\n<p>I am using a vector of a BufferTrio object, which defines a noexcept(false) move constructor, and deletes every other constructor/assignment operator so that there's nothing to fall back to:</p>\n<pre><code>    BufferTrio(const BufferTrio&amp;) = delete;\n    BufferTrio&amp; operator=(const BufferTrio&amp;) = delete;\n    BufferTrio&amp; operator=(BufferTrio&amp;&amp; other) = delete;\n\n    BufferTrio(BufferTrio&amp;&amp; other) noexcept(false)\n        : vaoID(other.vaoID)\n        , vboID(other.vboID)\n        , eboID(other.eboID)\n    {\n        other.vaoID = 0;\n        other.vboID = 0;\n        other.eboID = 0;\n    }\n</code></pre>\n<p>Things compile and run, but from <em><a href=\"https://xinhuang.github.io/posts/2013-12-31-when-to-use-noexcept-and-when-to-not.html\" rel=\"noreferrer\">https://xinhuang.github.io/posts/2013-12-31-when-to-use-noexcept-and-when-to-not.html</a>:</em></p>\n<blockquote>\n<p id=\"so_46874310_46874310_0\">std::vector will use move when it needs to increase(or decrease) the capacity, as long as the move operation is noexcept.</p>\n</blockquote>\n<p>Or from <em>Optimized C++: Proven Techniques for Heightened Performance By Kurt Guntheroth</em>:</p>\n<blockquote>\n<p id=\"so_46874310_46874310_1\">If the move constructor and move assignment operator are not declared noexcept, std::vector uses the less efficient copy operations instead.</p>\n</blockquote>\n<p>Since I've deleted those, my understanding is that something should be breaking here. But things are running ok with that vector. So I also created a basic loop that push_backs half a million times into a dummy vector, and then swapped that vector with another single-element dummy vector. Like so:</p>\n<pre><code>    vector&lt;BufferTrio&gt; thing;\n\n    int n = 500000;\n    while (n--)\n    {\n        thing.push_back(BufferTrio());\n    }\n\n    vector&lt;BufferTrio&gt; thing2;\n    thing2.push_back(BufferTrio());\n\n    thing.swap(thing2);\n    cout &lt;&lt; \"Sizes are \" &lt;&lt; thing.size() &lt;&lt; \" and \" &lt;&lt; thing2.size() &lt;&lt; endl;\n    cout &lt;&lt; \"Capacities are \" &lt;&lt; thing.capacity() &lt;&lt; \" and \" &lt;&lt; thing2.capacity() &lt;&lt; endl;\n</code></pre>\n<p>Output:</p>\n<pre><code>Sizes are 1 and 500000\nCapacities are 1 and 699913\n</code></pre>\n<p>Still no problems, so:</p>\n<p><strong>Should I see something going wrong, and if so, how can I demonstrate it?</strong></p>\n", "AcceptedAnswerId": "46874444", "Title": "Using an object without copy and without a noexcept move constructor in a vector. What actually breaks and how can I confirm it?", "CreationDate": "2017-10-22T12:55:31.937", "Id": "46874310", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-10-22T13:06:23.153", "LastEditorUserId": "8806368", "LastActivityDate": "2017-10-22T13:31:56.523", "Score": "6", "OwnerUserId": "8806368", "Tags": "<c++><c++11><vector><constructor><move>", "AnswerCount": "3"}, "46874473": {"Id": "46874473", "PostTypeId": "2", "Body": "<p>There is nothing going wrong in your example. From <a href=\"http://en.cppreference.com/w/cpp/container/vector/push_back\" rel=\"nofollow noreferrer\"><code>std::vector::push_back</code></a>:</p>\n<blockquote>\n<p id=\"so_46874310_46874473_0\">If T's move constructor is not <code>noexcept</code> and T is not CopyInsertable into <code>*this</code>, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</p>\n</blockquote>\n<p><code>std::vector</code> prefers non-throwing move constructors, and if none is available, will fall back on the copy constructor (throwing or not). But if that is also not available, then it has to use the throwing move constructor. Basically, the vector tries to save you from throwing constructors and leaving objects in an indeterminate state.</p>\n<p>So in that regard, your example is correct, but if your move constructor actually threw an exception, then you'd have unspecified behavior.</p>\n", "LastActivityDate": "2017-10-22T13:11:18.697", "Score": "2", "CreationDate": "2017-10-22T13:11:18.697", "ParentId": "46874310", "CommentCount": "2", "OwnerUserId": "3980929"}, "46874444": {"Id": "46874444", "PostTypeId": "2", "Body": "<p>A vector reallocation attempts to offer an exception guarantee, i.e. an attempt to preserve the original state if an exception is thrown during the reallocation operation. There are three scenarios:</p>\n<ol>\n<li><p>The element type is <code>nothrow_move_constructible</code>: Reallocation can move elements which won't cause an exception. This is the efficient case.</p></li>\n<li><p>The element type is <code>CopyInsertable</code>: if the type fails to be <code>nothrow_move_constructible</code>, this is sufficient to provide the strong guarantee, though copies are made during reallocation. This was the old C++03 default behaviour and is the less efficient fall-back.</p></li>\n<li><p>The element type is neither <code>CopyInsertable</code> nor <code>nothrow_move_constructible</code>. As long as it is still move-constructible, like in your example, vector reallocation is possible, but does not provide any exception guarantees (e.g. you might lose elements if a move construction throws).</p></li>\n</ol>\n<p>The normative wording that says this is spread out across the various reallocating functions. For example, [vector.modifiers]/<code>push_back</code> says:</p>\n<blockquote>\n<p id=\"so_46874310_46874444_0\">If an exception is thrown while\n  inserting a single element at the end and <code>T</code> is <code>CopyInsertable</code> or <code>is_nothrow_move_constructible_v&lt;T&gt;</code> is <code>true</code>, there are no effects. Otherwise, if an exception is thrown by the move constructor of a\n  non-<code>CopyInsertable</code> <code>T</code>, the effects are unspecified.</p>\n</blockquote>\n<p>I don't know what the authors of the posts you cite had in mind, though I can imagine that they are implicitly assuming that you want the strong exception guarantee, and so they'd like to steer you into cases (1) or (2).</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2017-10-22T13:31:56.523", "Score": "8", "CreationDate": "2017-10-22T13:08:51.047", "ParentId": "46874310", "CommentCount": "4", "LastEditDate": "2017-10-22T13:31:56.523", "OwnerUserId": "596781"}, "46874564": {"Id": "46874564", "PostTypeId": "2", "Body": "<h2><strong>TLDR</strong> So long as a type is  <em>MoveInsertable</em>, you're okay, and here you're okay.</h2>\n<p>A type is <em>MoveInsertable</em> if, given the container's allocator <code>A</code>, an instance of the allocator assigned to variable <code>m</code>, a pointer to <code>T*</code> called <code>p</code>, and an r-value of type <code>T</code> the following expression is well-formed:</p>\n<pre><code>allocator_traits&lt;A&gt;::construct(m, p, rv);\n</code></pre>\n<p>For your <code>std::vector&lt;BufferTrio&gt;</code>, you are using the default <code>std::allocator&lt;BufferTrio&gt;</code>, so this call to <a href=\"http://en.cppreference.com/w/cpp/memory/allocator_traits/construct\" rel=\"nofollow noreferrer\"><code>construct</code></a> calls </p>\n<pre><code>m.construct(p, std::forward&lt;U&gt;(rv))\n</code></pre>\n<p>Where <code>U</code> is a forwarding reference type (in your case it's <code>BufferTrio&amp;&amp;</code>, an rvalue reference)</p>\n<p>So far so good,</p>\n<p><code>m.construct</code> will use placement-new to construct the member in-place([allocator.members])</p>\n<pre><code>::new((void *)p) U(std::forward&lt;Args&gt;(args)...)\n</code></pre>\n<p>At no point does this <em>require</em> <code>noexcept</code>. It's only for exception guarantee reasons.</p>\n<p>[vector.modifiers] states that for <code>void push_back(T&amp;&amp; x);</code></p>\n<blockquote>\n<p id=\"so_46874310_46874564_0\">If an exception is thrown by the move\n  constructor of a non-<code>CopyInsertable T</code>, the effects are unspecified.</p>\n</blockquote>\n<hr>\n<p>Finally, \nRegarding your <code>swap</code> (<strong>Emphasis mine</strong>):</p>\n<p>[container.requirements.general]</p>\n<blockquote>\n<p id=\"so_46874310_46874564_1\">The expression <code>a.swap(b)</code>, for containers <code>a</code> and <code>b</code> of a standard container type other than <code>array</code>, shall exchange\n  the values of <code>a</code> and <code>b</code> <strong>without invoking any move, copy, or swap operations on the individual container\n  elements</strong>.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2017-10-22T13:21:37.503", "Score": "2", "CreationDate": "2017-10-22T13:21:37.503", "ParentId": "46874310", "CommentCount": "1", "OwnerUserId": "27678"}});