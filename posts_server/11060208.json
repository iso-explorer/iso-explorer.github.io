post_cb({"11060208": {"CommentCount": "0", "AcceptedAnswerId": "11060242", "PostTypeId": "1", "LastEditorUserId": "981959", "CreationDate": "2012-06-16T02:04:11.060", "LastActivityDate": "2012-06-20T18:08:19.917", "LastEditDate": "2012-06-20T18:08:19.917", "ViewCount": "105", "FavoriteCount": "1", "Title": "Possible forms of template template argument in the template instantiation", "Id": "11060208", "Score": "2", "Body": "<p>One of the possible forms of template parameter is a class template. The C++ standard (C++2003) states that an argument for a template template parameter during the template instantiation is an \"id-expression\". This non-terminal is rather wide. It allows destructors, overloaded operators, etc. For example the following code should compile fine:</p>\n<pre><code>template &lt;template &lt;typename x&gt; class T&gt;\nstruct MyClass\n{\n    T&lt;int&gt; a;\n    T&lt;double&gt; b;\n};\n\ntemplate &lt;typename x&gt; struct Helper\n{\n    ~Helper() { }\n    x operator+(x p) { return(x[1]+p); }\n    x[4] c;\n};\n\n MyClass&lt;Helper&gt; p1;\n MyClass&lt;~Helper&gt; p2;\n MyClass&lt;Helper::operaror+&gt; p3;\n</code></pre>\n<p>The last 2 lines do not make any sense. But from the standpoint of the grammar they are fine. The grammar is not (and should not) describe the language exactly, but the paragraph 14.3.3, \"Template template argument\" does not mention any restrictions on the grammar rules in this context.</p>\n<p>Can anybody embrace or refute my statements:</p>\n<ol>\n<li>Template template argument can be ONLY an identifier, maybe qualified.</li>\n<li>If point one is true, this is definitely worth mentioning in the standard.</li>\n</ol>\n", "Tags": "<c++><template-templates>", "OwnerUserId": "1459996", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_11060208_11060242_1": {"section_id": 92, "quality": 1.0, "length": 8}, "so_11060208_11060242_0": {"section_id": 76, "quality": 0.9642857142857143, "length": 27}}, "n3337": {"so_11060208_11060242_1": {"section_id": 87, "quality": 1.0, "length": 8}, "so_11060208_11060242_0": {"section_id": 71, "quality": 0.9642857142857143, "length": 27}}, "n4659": {"so_11060208_11060242_1": {"section_id": 95, "quality": 1.0, "length": 8}, "so_11060208_11060242_0": {"section_id": 78, "quality": 0.9642857142857143, "length": 27}}}, "11060242": {"ParentId": "11060208", "CommentCount": "3", "Body": "<p>14.3 [temp.arg] p1</p>\n<blockquote>\n<p id=\"so_11060208_11060242_0\">\"There are three forms of <em>template-argument</em>, corresponding to the three forms of <em>template-parameter</em>: type, non-type and template. The type and form of each <em>template-argument</em> specified in a <em>template-id</em> shall match the type and form specified for the corresponding parameter declared by the template in its template-parameter-list.</p>\n</blockquote>\n<p>The argument <code>~Helper</code> does not have the right type for the template template parameter <code>template&lt;typename&gt; class T</code>, it's not a class template.</p>\n<p>14.3.3 [temp.arg.template] p1</p>\n<blockquote>\n<p id=\"so_11060208_11060242_1\">A <em>template-argument</em> for a template <em>template-parameter</em> shall be the name of a class template, expressed as <em>id-expression</em>.</p>\n</blockquote>\n<p><code>~Helper</code> is not the name of a class template.</p>\n<p>That pretty clearly rules out your examples.</p>\n", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "11060242", "Score": "1", "CreationDate": "2012-06-16T02:11:40.443", "LastActivityDate": "2012-06-16T02:11:40.443"}});