post_cb({"bq_ids": {"n4140": {"so_26749011_26749031_1": {"length": 5, "quality": 1.0, "section_id": 7141}}, "n3337": {"so_26749011_26749031_1": {"length": 5, "quality": 1.0, "section_id": 6885}}, "n4659": {"so_26749011_26749031_1": {"length": 5, "quality": 1.0, "section_id": 8642}}}, "26749011": {"ViewCount": "138", "Body": "<p>The following code compiles without errors/warnings when being built with C++11 mode, using GCC and Clang. However if I attempt to compile without C++11 mode and error occurs in the 2nd scope.</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nstruct astruct\n{\n   int v;\n};\n\nstruct astruct_cmp0\n{\n   bool operator()(const astruct&amp; a0, const astruct&amp; a1) {\n     return a0.v &lt; a1.v;\n   }\n};\n\nint main()\n{\n   std::vector&lt;astruct&gt; alist;\n   {\n      // Works - no errors\n      std::stable_sort(alist.begin(),alist.end(),astruct_cmp0());\n   }\n\n   {\n      struct astruct_cmp1\n      {\n         bool operator()(const astruct&amp; a0, const astruct&amp; a1) {\n           return a0.v &lt; a1.v;\n         }\n      };\n\n      // error: template argument uses local type 'astruct_cmp1'\n      std::stable_sort(alist.begin(),alist.end(),astruct_cmp1());\n   }\n\n   return 0;\n}\n</code></pre>\n<p>My question is: What was the C++11 change that allows the local struct definition? could someone please point me to the specific section in the standard (section 9.8 perhaps?)</p>\n", "AcceptedAnswerId": "26749031", "Title": "Class locals as predicates pre C++11", "CreationDate": "2014-11-05T03:02:19.660", "Id": "26749011", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-11-05T09:02:15.920", "LastEditorUserId": "2684539", "LastActivityDate": "2014-11-05T09:02:15.920", "Score": "4", "OwnerUserId": "655794", "Tags": "<c++><c++11><compiler-errors><language-lawyer><predicate>", "AnswerCount": "1"}, "26749031": {"Id": "26749031", "PostTypeId": "2", "Body": "<p>In C++03 function local types are not viable template arguments. In C++11 function local types are viable template arguments. The key quote in C++03 is 14.3.1 [temp.arg.type] paragraph 2:</p>\n<blockquote>\n<p id=\"so_26749011_26749031_0\">The following types shall not be used as a template-argument for a template type-parameter:</p>\n<ul>\n<li>a type whose name has no linkage</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>In C++11 this constraint is removed.</p>\n<p>The relevant section on when linkage is defined is 3.5 [basic.link] (in both standard) which is fairly long and points to entities without linkage by exclusion, paragraph 8 in C++03:</p>\n<blockquote>\n<p id=\"so_26749011_26749031_1\">Names not covered by these rules have no linkage. ...</p>\n</blockquote>\n<p>Types defined within a function are not listed in \"these rules\".</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2014-11-05T03:16:56.440", "Score": "6", "CreationDate": "2014-11-05T03:04:46.233", "ParentId": "26749011", "CommentCount": "0", "OwnerUserId": "1120273", "LastEditDate": "2014-11-05T03:16:56.440"}});