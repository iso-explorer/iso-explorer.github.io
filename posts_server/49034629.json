post_cb({"bq_ids": {"n4140": {"so_49034629_49034629_0": {"length": 26, "quality": 1.0, "section_id": 1908}}, "n3337": {"so_49034629_49034629_0": {"length": 26, "quality": 1.0, "section_id": 1897}}, "n4659": {"so_49034629_49034629_0": {"length": 26, "quality": 1.0, "section_id": 2178}}}, "49034629": {"ViewCount": "90", "Body": "<p>Can external I/O be relied upon as a form of cross-thread synchronization?</p>\n<p>To be specific, consider the pseudocode below, which assumes the existence of network/socket functions:</p>\n<pre><code>int a;          // Globally accessible data.\nsocket s1, s2;  // Platform-specific.\n\nint main() {\n  // Set up + connect two sockets to (the same) remote machine.\n  s1 = ...;\n  s2 = ...;\n\n  std::thread t1{thread1}, t2{thread2};\n  t1.join();\n  t2.join();\n}\n\nvoid thread1() {\n  a = 42;\n  send(s1, \"foo\");\n}\n\nvoid thread2() {\n  recv(s2);     // Blocking receive (error handling omitted).\n  f(a);         // Use a, should be 42.\n}\n</code></pre>\n<p>We assume that the remote machine only sends data to <code>s2</code> upon receiving the <code>\"foo\"</code> from <code>s1</code>. If this assumption fails, then certainly undefined behavior will result. But if it holds (and no other external failure occurs like network data corruption, etc.), does this program produce defined behavior?</p>\n<p>\"Never\", \"unspecified (depends on implementation)\", \"depends on the guarantees provided by the implementation of send/recv\" are example answers of the sort I'm expecting, preferably with justification from the C++ standard (or other relevant standards, such as POSIX for sockets/networking).</p>\n<p>If \"never\", then changing <code>a</code> to be a <code>std::atomic&lt;int&gt;</code> initialized to a definite value (say 0) would avoid undefined behaviour, but then is the value guaranteed to be read as 42 in <code>thread2</code> or could a stale value be read? Do POSIX sockets provide a further guarantee that ensures a stale value will not be read?</p>\n<p>If \"depends\", do POSIX sockets provide the relevant guarantee to make it defined behavior? (How about if <code>s1</code> and <code>s2</code> were the same socket instead of two separate sockets?)</p>\n<p>For reference, the standard I/O library has a clause which seems to provide an analogous guarantee when working with iostreams (27.2.3\u00b62 in N4604):</p>\n<blockquote>\n<p id=\"so_49034629_49034629_0\">If one thread makes a library call a that writes a value to a stream and, as a result, another thread reads this value from the stream through a library call b such that this does not result in a data race, then a\u2019s write synchronizes with b\u2019s read.</p>\n</blockquote>\n<p>So is it a matter of the underlying network library/functions being used providing a similar guarantee?</p>\n<p>In practical terms, it seems the compiler can't reorder accesses to the global <code>a</code> with respect to the <code>send</code> and<code>recv</code> functions (as they could use <code>a</code> in principle). However, the thread running <code>thread2</code> could still read a stale value of <code>a</code> unless there was some kind of memory barrier / synchronization guarantee provided by the <code>send</code>/<code>recv</code> pair itself.</p>\n", "Title": "Relying on network I/O to provide cross-thread synchronization in C++", "CreationDate": "2018-02-28T16:47:54.410", "LastActivityDate": "2018-02-28T18:08:31.117", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2018-02-28T18:08:31.117", "LastEditorUserId": "1395057", "Id": "49034629", "Score": "5", "OwnerUserId": "1395057", "Tags": "<c++><multithreading><sockets><network-programming><memory-model>", "AnswerCount": "1"}, "49035029": {"Id": "49035029", "PostTypeId": "2", "Body": "<p>Short answer: No, there is no generic guarantee that <code>a</code> will be updated. My suggestion would be to send the value of <code>a</code> along with <code>\"foo\"</code> - e.g. <code>\"foo, 42\"</code>, or something like it. That is guaranteed to work, and probably not that significant overhead. [There may of course be other reasons why that doesn't work well]</p>\n<p>Long rambling stuff that doesn't really answer the problem:</p>\n<p>Global data is not guaranteed to be \"visible\" immediately in different cores of multicore processors without further operations. Yes, most modern processors are \"coherent\", but not all models of all brands are guaranteed to do so. So if thread2 runs on a processor that has already cached a copy of <code>a</code>, it can not be guaranteed that the value of <code>a</code> is 42 at the point when you call <code>f</code>.</p>\n<p>The C++ standard guarantees that global variables are loaded after the function call, so the compiler is not allowed to do:</p>\n<pre><code> tmp = a;\n recv(...);\n f(tmp);\n</code></pre>\n<p>but as I said above, cache-operations may be needed to guarantee that all processors see the same value at the same time. If <code>send</code> and <code>recv</code> are long in time or big in accesses enough [there is no direct measure that says how long or big]  you may see the correct value most or even all of the time, but there is no guarantee for ordinary types that they are ACTUALLY updated outside of the thread that wrote the value last. </p>\n<p><code>std::atomic</code> will help on some types of processors, but there is no guarantee that this is \"visible\" in a second thread or on a second processor core at any reasonable time after it was changed.</p>\n<p>The only practical solution is to have some kind of \"repeat until I see it change\" type code - this may require one value that is (for example) a counter, and one value that is the actual value - if you want to be able to say that \"a is now 42. I've set a again, it's 42 this time too\". If <code>a</code> is reppresenting, for example the number of data items available in a buffer, it is probably \"it changed value\" that matters, and just checking \"is this the same as last time\". The <code>std::atomic</code> operations have guarantees with regard to ordering, which allows you to use them to ensure that \"if I update this field, the other field is guaranteed to appear at the same time or before this\". So you can use that to guarantee for example a pair of data items are set to the \"there is a new value\" (for example a counter to indicate the \"version number\" of the current data) and \"the new value is X\". </p>\n<p>Of course, if you KNOW what processor architectures your code will run on, you can plausibly make more advanced guesses as to what the behaviour will be. For example all x86 and many ARM processors use the cache-interface to implement atomic updates on a variable, so by doing an atomic update on one core, you can know that \"no other processor will have a stale value of this\". But there are processors available that do not have this implementation detail, and where an update, even with an atomic instruction, will not be updated on other cores or in other threads until \"some time in the future, uncertain when\".</p>\n", "LastEditorUserId": "1919155", "LastActivityDate": "2018-02-28T17:30:57.013", "Score": "0", "CreationDate": "2018-02-28T17:09:31.027", "ParentId": "49034629", "CommentCount": "4", "OwnerUserId": "1919155", "LastEditDate": "2018-02-28T17:30:57.013"}});