post_cb({"3179974": {"Id": "3179974", "PostTypeId": "2", "Body": "<p>The C++ Standard says:</p>\n<blockquote>\n<p id=\"so_3179936_3179974_0\">On exit from a scope (however\n  accomplished), destructors (12.4) are\n  called for all constructed objects\n  with automatic storage duration\n  (3.7.2) (named objects or temporaries)\n  that are declared in that scope, in\n  the reverse order of their\n  declaration.</p>\n</blockquote>\n<p>So the answer is \"yes\".</p>\n", "OwnerDisplayName": "anon", "LastActivityDate": "2010-07-05T13:47:42.533", "Score": "52", "CreationDate": "2010-07-05T13:47:42.533", "ParentId": "3179936", "CommentCount": "1"}, "15932290": {"Id": "15932290", "PostTypeId": "2", "Body": "<p>Yes, as everyone else says.  C++ specifies/mandates this.</p>\n<p>But just to add to that, for completeness: if your <code>goto</code> uses the computed-<code>goto</code> extension found in some compilers -- gcc, clang, possibly others but <em>not</em> including MSVC last I knew -- whether or not the object's destructor will be called is pretty hazy.  When a <code>goto</code> goes to a single location, it's very clear what destructors must be called before the control-flow transfer.  But with a computed <code>goto</code>, different destructors might need to dynamically be called, to give the \"expected\" semantics.  I'm not sure what compilers that implement this extension do, in those cases.  My memory from encountering this is that clang warns when a computed-<code>goto</code> might leave a scope with an object with a non-trival destructor, claiming the destructor won't be called.  In some cases that might be fine, in others not.  I don't know offhand what other compilers do.  Just be aware of the issue if you want to use computed <code>goto</code>s in concert with objects with non-trivial destructors.</p>\n", "LastActivityDate": "2013-04-10T17:14:55.970", "Score": "4", "CreationDate": "2013-04-10T17:14:55.970", "ParentId": "3179936", "CommentCount": "1", "OwnerUserId": "115698"}, "bq_ids": {"n4140": {"so_3179936_3179974_0": {"length": 12, "quality": 0.5217391304347826, "section_id": 3909}}, "n3337": {"so_3179936_3179974_0": {"length": 12, "quality": 0.5217391304347826, "section_id": 3769}}, "n4659": {"so_3179936_3179974_0": {"length": 12, "quality": 0.5217391304347826, "section_id": 4795}}}, "3179957": {"Id": "3179957", "PostTypeId": "2", "Body": "<p>1) Yes.\n2) Don't do this.</p>\n<p>Elaboration: conceptually, this is no different from leaving a loop via a <code>break</code>.  <code>goto</code>, however, is strongly, strongly discouraged.  It is almost never necessary to use <code>goto</code>, and any use should be scrutinized to find out what's going on.</p>\n", "LastActivityDate": "2010-07-05T13:44:48.037", "Score": "9", "CreationDate": "2010-07-05T13:44:48.037", "ParentId": "3179936", "CommentCount": "6", "OwnerUserId": "279130"}, "3179962": {"Id": "3179962", "PostTypeId": "2", "Body": "<p>Yes, they will be called.</p>\n<p><em>Update:</em>\n(it's okay to do this, gotos is not worse than throwing dummy exceptions or using bools/ifs to get out of things. A simple goto inside a function don't make it spaghetti code.)</p>\n", "LastActivityDate": "2010-07-05T13:45:24.120", "Score": "21", "CreationDate": "2010-07-05T13:45:24.120", "ParentId": "3179936", "CommentCount": "6", "OwnerUserId": "100724"}, "3179936": {"ViewCount": "4369", "Body": "<p>Consider the following code:</p>\n<pre><code>void foo()\n{\n    {\n        CSomeClass bar;\n\n        // Some code here...\n\n        goto label;\n\n        // and here...\n    }\n\nlabel:\n    // and here...\n}\n</code></pre>\n<p>Will the destructor of bar be called ?</p>\n", "AcceptedAnswerId": "3179974", "Title": "Goto out of a block: do destructors get called?", "CreationDate": "2010-07-05T13:41:33.083", "Id": "3179936", "CommentCount": "4", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2013-04-10T17:14:55.970", "Score": "37", "OwnerUserId": "373025", "Tags": "<c++><destructor><goto>", "AnswerCount": "4"}});