post_cb({"38441572": {"ParentId": "38441390", "LastEditDate": "2016-07-18T16:25:38.933", "CommentCount": "0", "CreationDate": "2016-07-18T16:17:24.857", "OwnerUserId": "4342498", "LastEditorUserId": "4342498", "PostTypeId": "2", "Id": "38441572", "Score": "11", "Body": "<p>Yes this is defined behavior.  First we have from [expr.add]/4</p>\n<blockquote>\n<p id=\"so_38441390_38441572_0\">For the purposes of these operators, a pointer to a nonarray object behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type.</p>\n</blockquote>\n<p>So a single object is treated as a array of length 1.  Then we have [expr.add]/5</p>\n<blockquote>\n<p id=\"so_38441390_38441572_1\">[...]<strong>Moreover, if the expression P points to the last element of an array object, the expression (P)+1 points one past the last element of the array object,</strong> and if the expression Q points one past the last element of an array object, the expression (Q)-1 points to the last element of the array object. <strong>If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow;</strong> otherwise, the behavior is undefined.</p>\n</blockquote>\n<p><sup>Emphasis mine</sup></p>\n<p>So since the first array element is also the last array element, and adding 1 to the last array element gives you the one past the object, it is legal.</p>\n", "LastActivityDate": "2016-07-18T16:25:38.933"}, "bq_ids": {"n4140": {"so_38441390_38441572_1": {"section_id": 6142, "quality": 1.0, "length": 50}, "so_38441390_38441572_0": {"section_id": 6141, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_38441390_38441572_1": {"section_id": 5906, "quality": 1.0, "length": 50}, "so_38441390_38441572_0": {"section_id": 5905, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_38441390_38441572_0": {"section_id": 7603, "quality": 0.5789473684210527, "length": 11}}}, "38441390": {"CommentCount": "7", "CreationDate": "2016-07-18T16:07:36.630", "PostTypeId": "1", "AcceptedAnswerId": "38441572", "LastEditorUserId": "6061422", "LastActivityDate": "2016-07-18T18:37:51.220", "LastEditDate": "2016-07-18T16:21:42.613", "ViewCount": "141", "FavoriteCount": "2", "Title": "Iterating over a single lvalue", "Id": "38441390", "Score": "6", "Body": "<p>I'd like to pass a single lvalue to a function which expects a pair of iterators, and for it to act as if I'd passed a pair of iterators to a range containing just this value.</p>\n<p>My approach is as follows:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ntemplate&lt;typename Iter&gt;\nvoid iterate_over(Iter begin, Iter end){\n    for(auto i = begin; i != end; ++i){\n        std::cout &lt;&lt; *i &lt;&lt; std::endl;\n    }\n}\n\nint main(){\n    std::vector&lt;int&gt; a{1,2,3,4};\n    iterate_over(a.cbegin(), a.cend());\n\n    int b = 5;\n    iterate_over(&amp;b, std::next(&amp;b));\n}\n</code></pre>\n<p>This appears to work correctly in g++5.2, but I'm wondering if this is actually defined behaviour and if there are any potential issues?</p>\n", "Tags": "<c++><c++11><iterator>", "OwnerUserId": "6061422", "AnswerCount": "1"}});