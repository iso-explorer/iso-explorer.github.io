post_cb({"bq_ids": {"n4140": {"so_2162510_2162593_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 72}}, "n3337": {"so_2162510_2162593_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 67}}}, "2162593": {"CreationDate": "2010-01-29T14:39:32.677", "CommentCount": "3", "Body": "<p>Prefix <code>get&lt;0&gt;()</code> with <code>template</code>:</p>\n<pre><code>const_iterator_0 begin0() const { return _container.template get&lt;0&gt;().begin(); }\nconst_iterator_0 end0  () const { return _container.template get&lt;0&gt;().end();   }\n</code></pre>\n<p>Similar to <code>typename</code> for dependent types, dependent templates have to be prefixed by <code>template</code>:</p>\n<pre><code>struct X {\n    template&lt;class T&gt; void f();\n};\n\ntemplate&lt;class T&gt;\nvoid test() {\n    T::f&lt;int&gt;(); // ill-formed\n    T::template f&lt;int&gt;(); // ok\n}\n\n// ...\ntest&lt;X&gt;();\n</code></pre>\n<p>And for the curious, that is <em>\u00a714.2/4</em>:</p>\n<blockquote>\n<p id=\"so_2162510_2162593_0\">When the name of a member template\n  specialization appears after . or -&gt;\n  in a postfix-expression, or after\n  nested-name-specifier in a\n  qualified-id, and the\n  postfix-expression or qualified-id\n  explicitly depends on a\n  template-parameter (14.6.2), the\n  member template name must be prefixed\n  by the keyword template. Otherwise the\n  name is assumed to name a\n  non-template.</p>\n</blockquote>\n", "Id": "2162593", "OwnerUserId": "168225", "LastEditDate": "2010-01-29T15:14:17.650", "ParentId": "2162510", "LastActivityDate": "2010-01-29T15:14:17.650", "PostTypeId": "2", "Score": "6", "LastEditorUserId": "168225"}, "2162510": {"CreationDate": "2010-01-29T14:28:49.303", "ViewCount": "1712", "Id": "2162510", "AcceptedAnswerId": "2162593", "Score": "1", "Title": "strange template namespace problem", "LastEditorUserId": "168225", "CommentCount": "3", "Body": "<p>I've got a strange problem with templates and namespaces...</p>\n<p>I have the following code which compiles fine..</p>\n<pre><code>using namespace boost::multi_index;\n\ntemplate &lt; typename OT, typename KT, KT (OT::* KM)() const, typename KC, typename CMP &gt;\nclass OrderBook\n{\npublic:\n    OrderBook() {}\n    ~OrderBook() {}\n\n    typedef multi_index_container&lt;\n        OT,\n        indexed_by&lt;\n            ordered_unique&lt;\n                const_mem_fun&lt; OT, KT, KM &gt;,\n                KC\n            &gt;,\n            ordered_unique&lt;\n                identity&lt; OT &gt;,\n                CMP\n            &gt;\n        &gt;\n    &gt; Container;\n\n    typedef typename Container::template nth_index&lt; 0 &gt;::type index_0;\n    typedef typename Container::template nth_index&lt; 1 &gt;::type index_1;\n\n    typedef typename index_0::const_iterator const_iterator_0;\n    typedef typename index_1::const_iterator const_iterator_1;\n\n    const_iterator_0 begin0() const { return _container.get&lt;0&gt;().begin(); }\n    const_iterator_0 end0() const { return _container.get&lt;0&gt;().end(); }\n\n\npublic:\n    Container _container;\n};\n</code></pre>\n<p>However, due to a namespace collision when I insert this code into another project I have to have... (Notice how I've had to remove the using <code>namespace boost::multi_index</code> and manually specify it where needed</p>\n<pre><code>template &lt; typename OT, typename KT, KT (OT::* KM)() const, typename KC, typename CMP &gt;\nclass OrderBook\n{\npublic:\n    OrderBook() {}\n    ~OrderBook() {}\n\n    typedef boost::multi_index::multi_index_container&lt;\n        OT,\n        boost::multi_index::indexed_by&lt;\n            boost::multi_index::ordered_unique&lt;\n                boost::multi_index::const_mem_fun&lt; OT, KT, KM &gt;,\n                KC\n            &gt;,\n            boost::multi_index::ordered_unique&lt;\n                boost::multi_index::identity&lt; OT &gt;,\n                CMP\n            &gt;\n        &gt;\n    &gt; Container;\n\n    typedef typename Container::template nth_index&lt; 0 &gt;::type index_0;\n    typedef typename Container::template nth_index&lt; 1 &gt;::type index_1;\n\n    typedef typename index_0::const_iterator const_iterator_0;\n    typedef typename index_1::const_iterator const_iterator_1;\n\n    const_iterator_0 begin0() const { return _container.get&lt;0&gt;().begin(); }\n    const_iterator_0 end0() const { return _container.get&lt;0&gt;().end(); }\n\n\npublic:\n    Container _container;\n};\n</code></pre>\n<p>Which gives me the following error from g++.</p>\n<pre><code>In member function 'typename boost::multi_index::multi_index_container&lt;OT, boost::multi_index::indexed_by&lt;boost::multi_index::ordered_unique&lt;boost::multi_index::const_mem_fun&lt;OT, KT, KM&gt;, KC, mpl_::na&gt;, boost::multi_index::ordered_unique&lt;boost::multi_index::identity&lt;Value&gt;, CMP, mpl_::na&gt;, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na&gt;, std::allocator&lt;_CharT&gt; &gt;::nth_index&lt;0&gt;::type::const_iterator OrderBook&lt;OT, KT, KM, KC, CMP&gt;::begin0() const':\n\nerror: expected primary-expression before ')' token\n\n\nIn member function 'typename boost::multi_index::multi_index_container&lt;OT, boost::multi_index::indexed_by&lt;boost::multi_index::ordered_unique&lt;boost::multi_index::const_mem_fun&lt;OT, KT, KM&gt;, KC, mpl_::na&gt;, boost::multi_index::ordered_unique&lt;boost::multi_index::identity&lt;Value&gt;, CMP, mpl_::na&gt;, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na&gt;, std::allocator&lt;_CharT&gt; &gt;::nth_index&lt;0&gt;::type::const_iterator OrderBook&lt;OT, KT, KM, KC, CMP&gt;::end0() const':\n\nerror: expected primary-expression before ')' token\n</code></pre>\n<p>Sorry for the long error messages, I did consider cleaning them up but I thought I'd better leave them intact in case I removed something crucial.</p>\n<p>I tried this...</p>\n<pre><code>typedef typename Container::template boost::multi_index::nth_index&lt; 0 &gt;::type index_0;\ntypedef typename Container::template boost::multi_index::nth_index&lt; 1 &gt;::type index_1;\n</code></pre>\n<p>and it just made g++ even madder :( </p>\n<p>Any ideas?</p>\n", "Tags": "<c++><templates><namespaces>", "LastEditDate": "2010-01-29T14:43:48.657", "LastActivityDate": "2010-01-29T15:14:17.650", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "66191"}, "2162554": {"CommentCount": "1", "Body": "<p>Maybe I can guess that some of these functions are not in the <code>boost::multi_index</code> namespace: <code>indexed_b</code>, <code>ordered_unique</code>, <code>const_mem_fun</code>, or <code>identity</code></p>\n", "CreationDate": "2010-01-29T14:35:05.420", "ParentId": "2162510", "Id": "2162554", "LastActivityDate": "2010-01-29T14:35:05.420", "PostTypeId": "2", "Score": "0", "OwnerUserId": "212063"}});