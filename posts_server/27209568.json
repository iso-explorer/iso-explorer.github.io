post_cb({"bq_ids": {"n4140": {"so_27209568_27209693_2": {"length": 29, "quality": 0.90625, "section_id": 31}, "so_27209568_27209693_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 32}}, "n3337": {"so_27209568_27209693_2": {"length": 29, "quality": 0.90625, "section_id": 28}, "so_27209568_27209693_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 29}}, "n4659": {"so_27209568_27209693_2": {"length": 29, "quality": 0.90625, "section_id": 31}, "so_27209568_27209693_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 32}}}, "27209693": {"Id": "27209693", "PostTypeId": "2", "Body": "<p>There are a few things going on here let's start out by saying that using the incorrect format specifier to <code>printf</code> is undefined behavior which means the results of your program are unpredictable, what actually happens will depends on many factors including your compiler, architecture, optimization level, etc...</p>\n<p>For signed/unsigned conversions, that is defined by the respective standards, both C and C++ make it implementation defined behavior to convert a value that is larger than be stored in a signed integer type, from the C++ draft standard:</p>\n<blockquote>\n<p id=\"so_27209568_27209693_0\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and\n  bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>for example <code>gcc</code> chooses to use the same <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html#Integers-implementation\" rel=\"nofollow\">convention as unsigned</a>:</p>\n<blockquote>\n<p id=\"so_27209568_27209693_1\">For conversion to a type of width N, the value is reduced modulo 2^N to be within range of the type; no signal is raised. </p>\n</blockquote>\n<p>When you assign <code>-1</code> to an unsigned value in both C and C++ the result will always be the maximum unsigned value of the type, from the draft C++ standard:</p>\n<blockquote>\n<p id=\"so_27209568_27209693_2\">If the destination type is unsigned, the resulting value is the least\n  unsigned integer congruent to the source integer (modulo 2n where n is\n  the number of bits used to represent the unsigned type). [ Note: In a\n  two\u2019s complement representation, this conversion is conceptual and\n  there is no change in the bit pattern (if there is no truncation).\n  \u2014end note ]</p>\n</blockquote>\n<p>The wording from C99 is easier to digest:</p>\n<blockquote>\n<p id=\"so_27209568_27209693_3\">Otherwise, if the new type is unsigned, the value is converted by\n  repeatedly adding or subtracting one more than the maximum value that\n  can be represented in the new type until the value is in the range of\n  the new type.</p>\n</blockquote>\n<p>So we have the following:</p>\n<pre><code>-1 + (UNSIGNED_MAX + 1)\n</code></pre>\n<p>the result of which is <code>UNSIGNED_MAX</code></p>\n<p>As for <code>printf</code> and incorrect format specifier we can see form the draft C99 standard section <code>7.19.6.1</code> <em>The fprintf function</em> says:</p>\n<blockquote>\n<p id=\"so_27209568_27209693_4\">If a conversion specification is invalid, the behavior is\n  undefined.248) If any argument is not the correct type for the\n  corresponding conversion specification, the behavior is undefined.</p>\n</blockquote>\n<p><code>fprintf</code> covers <code>printf</code> with respect to format specifiers and C++ falls back in C with respect to <code>printf</code>.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-11-30T03:41:21.907", "Score": "1", "CreationDate": "2014-11-30T03:30:05.757", "ParentId": "27209568", "CommentCount": "3", "OwnerUserId": "1708801", "LastEditDate": "2014-11-30T03:41:21.907"}, "27212567": {"Id": "27212567", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27209568_27212567_0\">That is why %u for signed prints 4294967295 by ignoring -ve leftmost bit. When used %d for signed int, it uses left most bit as -ve flag and prints -1.</p>\n</blockquote>\n<p>In the case of unsigned, the \"leftmost\" or <em>most significant</em> bit is not ignored, and is not negative; rather it has a <em>place value</em> of 2<sup>31</sup>.</p>\n<p>In the negative case, the sign bit is not a flag; instead it is a bit with a place value of -2<sup>31</sup>.</p>\n<p>In both cases the value of the integer is equal to the sum of the place values of all the binary digits (bits) set to 1.</p>\n<p>The encoding of signed values in this way is known as <em><a href=\"http://en.m.wikipedia.org/wiki/Two's_complement\" rel=\"nofollow\">two's complement</a></em>.  It is not the only possible encoding; what you described is known as <em>sign and magnitude</em> for example, and <em>one's complement</em> is another possibility. However, these alternative encodings are seldom encountered in practice, not least because two's complement is how arithmetic works on modern hardware in all but perhaps the most arcane architectures.</p>\n", "LastEditorUserId": "168986", "LastActivityDate": "2014-11-30T11:21:30.860", "Score": "2", "CreationDate": "2014-11-30T11:08:26.467", "ParentId": "27209568", "CommentCount": "1", "OwnerUserId": "168986", "LastEditDate": "2014-11-30T11:21:30.860"}, "27209568": {"ViewCount": "3632", "Body": "<p>I understand that I am assigning signed int a value that is larger than what it can handle. Also I should be using <code>%d</code> for signed and <code>%u</code> for unsigned. Similarly I should not be assigning <code>-ve</code> value to unsigned. But if I make such assignments and use printf as below, I get the results show below.</p>\n<p>My understanding is that in each case, the number of converted to its two's compliment binary representation which is same for <code>-1</code> or <code>4294967295</code>. That is why <code>%u</code> for signed prints <code>4294967295</code> by ignoring <code>-ve</code> leftmost bit. When used %d for signed int, it uses left most bit as <code>-ve</code> flag and prints <code>-1</code>. Similarly <code>%u</code> for unsigned prints unsigned value but <code>%d</code> causes it to treat the number as signed and thus prints <code>-1</code>. Is that correct?</p>\n<pre><code>signed int si = 4294967295;\nunsigned int  ui = 4294967295;\n\nprintf(\"si = u=%u d=%d\\n\", si, si);\nprintf(\"ui = u=%u d=%d\\n\", ui, ui);\n</code></pre>\n<p>Output:</p>\n<pre><code>si = u=4294967295 d=-1\nui = u=4294967295 d=-1\n</code></pre>\n<hr>\n<pre><code>signed int si = -1;\nunsigned int  ui = -1;\n\nprintf(\"si = u=%u d=%d\\n\", si, si);\nprintf(\"ui = u=%u d=%d\\n\", ui, ui);\n</code></pre>\n<p>Output:</p>\n<pre><code>si = u=4294967295 d=-1\nui = u=4294967295 d=-1\n</code></pre>\n</hr>", "Title": "Unsigned and Signed int and printf", "CreationDate": "2014-11-30T03:08:14.893", "LastActivityDate": "2014-12-17T11:43:05.743", "CommentCount": "3", "LastEditDate": "2014-12-17T11:43:05.743", "PostTypeId": "1", "LastEditorUserId": "2932052", "Id": "27209568", "Score": "1", "OwnerUserId": "1315418", "Tags": "<c++><c>", "AnswerCount": "2"}});