post_cb({"42375733": {"ParentId": "42373862", "CommentCount": "1", "Body": "<p>The designer of C++ have decided that this general principle should apply (Stroustrup, <em>The C++ Programming language</em>, chapter 18)</p>\n<blockquote>\n<p id=\"so_42373862_42375733_0\">User-defined conversions are considered only if a call cannot be resolved without them (i.e., using only built-in conversions). </p>\n</blockquote>\n<p>For better or worse, there is a built-in conversion from Derived to Base, so the user-defined operator is never considered. </p>\n<p>The standard generally follows the path devised by Stroustrup unless there is a very good reason not to.</p>\n<p>Stroustrup cites the following rationale for the overall type conversion design (ibid.):</p>\n<blockquote>\n<p id=\"so_42373862_42375733_1\">The rules for conversion are neither the simplest to implement, nor the simplest to document, nor the most general that could be devised. They are, however, considerably safer, and the resulting resolutions are typically less surprising than alternatives. It is far easier to manually resolve an\n  ambiguity than to find an error caused by an unsuspected conversion.</p>\n</blockquote>\n", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "42375733", "Score": "2", "CreationDate": "2017-02-21T18:58:44.077", "LastActivityDate": "2017-02-21T18:58:44.077"}, "42373862": {"CommentCount": "6", "ViewCount": "120", "PostTypeId": "1", "LastEditorUserId": "1816262", "CreationDate": "2017-02-21T17:17:41.573", "LastActivityDate": "2017-02-21T18:58:44.077", "Title": "Why does the C++ standard require compilers to ignore calls to convertion operators for base types?", "AcceptedAnswerId": "42375733", "LastEditDate": "2017-02-21T17:32:52.767", "Id": "42373862", "Score": "4", "Body": "<p>Take the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Base {\n    char x = 'b';  \n};\n\nstruct Derived : Base {\n    operator Base() { return Base { 'a' }; }\n};\n\nint main() {\n    Derived derived;\n    auto base = static_cast&lt;Base&gt;(derived);\n\n    std::cout &lt;&lt; \"BASE -&gt; \" &lt;&lt; base.x &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Under both g++ and clang++, this produces:</p>\n<pre><code>BASE -&gt; b\n</code></pre>\n<p>I was expecting the following:</p>\n<pre><code>BASE -&gt; a\n</code></pre>\n<p>Why? Because why I read this code, I see a conversion operator inside of <code>Derived</code> that returns an instance of <code>Base</code> containing <code>'a'</code>.</p>\n<p>clang++ did me the courtesy of emitting a warning:</p>\n<pre><code>main.cpp:9:5: warning: conversion function converting 'Derived' to its base class 'Base' will never be used\n    operator Base() { return Base { 'a' }; }\n</code></pre>\n<p>Researching this warning, I found that this was by design (paraphrased for clarity):</p>\n<blockquote>\n<p id=\"so_42373862_42373862_0\"><a href=\"http://eel.is/c++draft/class.conv.fct#1\" rel=\"noreferrer\">class.conv.fct</a></p>\n<p id=\"so_42373862_42373862_1\">The type of the conversion function ([dcl.fct]) is \u201cfunction taking no parameter returning conversion-type-id\u201d. A conversion function is never used to convert a (possibly cv-qualified) object [...] to a (possibly cv-qualified) base class of that type (or a reference to it) [...].</p>\n</blockquote>\n<p>So it would seem that both compilers are doing the right thing here.\nMy question is, why does the standard require this behaviour?</p>\n", "Tags": "<c++><type-conversion><language-lawyer>", "OwnerUserId": "1816262", "AnswerCount": "3"}, "42374042": {"ParentId": "42373862", "CommentCount": "0", "Body": "<p>If you could override the conversion-to-base-class in C++, then you could break lots and lots of stuff. For example, how exactly would you be able to get access to the actual base class instance of a class? You would need some <code>baseof</code> template, similar to <code>std::addressof</code> that's used to bypass the il-conceived <code>operator&amp;</code> overload.</p>\n<p>Allowing this would create confusion as to what code means. With this rule in place, it's clear that converting a class to its base class copies the base class instance, in all cases.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "42374042", "Score": "6", "CreationDate": "2017-02-21T17:28:52.800", "LastActivityDate": "2017-02-21T17:28:52.800"}, "bq_ids": {"n4140": {"so_42373862_42373862_1": {"section_id": 391, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_42373862_42373862_1": {"section_id": 382, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_42373862_42373862_1": {"section_id": 408, "quality": 0.9130434782608695, "length": 21}}}, "42374620": {"ParentId": "42373862", "CommentCount": "0", "Body": "<p>Let's I have a hierarchy of <code>Animal</code>s and I want to write a function that takes an modifiable <code>Animal</code>, without slicing. How would I do that? I have two options:</p>\n<pre><code>void by_ref(Animal&amp; );\nvoid by_ptr(Animal* );\n</code></pre>\n<p>Which I could call like:</p>\n<pre><code>Dog dog = ...;\nby_ref(dog);\nby_ptr(&amp;dog);\n</code></pre>\n<p>Today, the only difference between those two calls is going to be the syntax used inside of the two functions and possibly a check against <code>nullptr</code>. This is because the <code>Dog</code> to <code>Animal&amp;</code> and <code>Dog*</code> to <code>Animal*</code> are guaranteed standard derived-to-base conversions. There is no alternative. </p>\n<p>But imagine if I could actually write:</p>\n<pre><code>struct Dog : Animal {\n    operator Animal&amp;() { ... };\n};\n</code></pre>\n<p>Now those two calls could do totally different things! My <code>Dog*</code> to <code>Animal*</code> conversion is still the same dog, but my <code>Dog</code> to <code>Animal&amp;</code> conversion is an entirely different <code>Dog</code>. It could even be a <code>Cat</code>. Which would make all of this code basically impossible to reason about.</p>\n<p>You would need a special mechanism to definitely give you the base subobject of a particular type:</p>\n<pre><code>by_ref(std::base&lt;Animal&gt;(dog));\n</code></pre>\n<p>which would basically have to be used <em>everywhere</em> to guarantee correctness of any code that relies upon inheritance. Which is a lot of code. </p>\n<hr/>\n<p>And to what benefit? If you want a <em>different</em> base subobject, you can just write a differently named function:</p>\n<pre><code>struct Dog : Animal {\n    Animal&amp; foo();\n};\n</code></pre>\n<p>Naming may be one of the <a href=\"https://twitter.com/codinghorror/status/506010907021828096?lang=en\" rel=\"nofollow noreferrer\">two hard things about programming</a>, but better to just come up with your own name than to open up the bag of deplorables that would be allowing people to write their own derived-to-base-but-not-really conversions.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "42374620", "Score": "4", "CreationDate": "2017-02-21T18:00:28.533", "LastActivityDate": "2017-02-21T18:00:28.533"}});