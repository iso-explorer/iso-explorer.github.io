post_cb({"3785121": {"ParentId": "3784996", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The paragraph you copied is talking about unsigned types. The behavior <strong>is</strong> undefined in C++. From the last C++0x draft:</p>\n<blockquote>\n<p id=\"so_3784996_3785121_0\">The value of E1 &lt;&lt; E2 is E1\n  left-shifted E2 bit positions; vacated\n  bits are zero-filled. If E1 has an\n  unsigned type, the value of the result\n  is E1 \u00d7 2E^2, reduced modulo one more\n  than the maximum value representable\n  in the result type. Otherwise, if E1\n  has a signed type and non-negative\n  value, and E1\u00d72E^2 is representable in\n  the result type, then that is the\n  resulting value; <strong>otherwise, the\n  behavior is undefined</strong>.</p>\n</blockquote>\n<p>EDIT: got a look at C++98 paper. It just doesn't mention signed types at all. So it's still undefined behavior.</p>\n<p>Right-shift negative is implementation defined, right. Why? In my opinion: It's easy to implementation-define because there is no truncation from the left issues. When you shift left you must say not only what's shifted from the right but also what happens with the rest of the bits e.g. with two's complement representation, which is another story.</p>\n", "OwnerUserId": "277176", "LastEditorUserId": "277176", "LastEditDate": "2010-09-24T07:58:15.070", "Id": "3785121", "Score": "29", "CreationDate": "2010-09-24T07:46:46.893", "LastActivityDate": "2010-09-24T07:58:15.070"}, "36295130": {"ParentId": "3784996", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The result of shifting depends upon the numeric representation. Shifting behaves like multiplication only when numbers are represented as two's complement. But the problem is not exclusive to negative numbers. Consider a 4-bit signed number represented in excess-8 (aka offset binary). The number 1 is represented as 1+8 or\n    1001\nIf we left shift this as bits, we get\n    0010\nwhich is the representation for -6. Similarly, -1 is represented as -1+8\n    0111\nwhich becomes\n    1110\nwhen left-shifted, the representation for +6. The bitwise behavior is well-defined, but the numeric behavior is highly dependent on the system of representation.</p>\n", "OwnerUserId": "706634", "LastEditorUserId": "706634", "LastEditDate": "2016-03-29T21:34:42.767", "Id": "36295130", "Score": "-2", "CreationDate": "2016-03-29T21:09:28.800", "LastActivityDate": "2016-03-29T21:34:42.767"}, "3785318": {"ParentId": "3784996", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>To answer your real question as stated in the title: as for any operation on a signed type, this has undefined behavior if the result of the mathematical operation doesn't fit in the target type (under- or overflow). Signed integer types are designed like that.</p>\n<p>For the left shift operation if the value is positive or 0, the definition of the operator as a multiplication with a power of 2 makes sense, so everything is ok, unless the result overflows, nothing surprising.</p>\n<p>If the value is negative, you could have the same interpretation of multiplication with a power of 2, but if you just think in terms of bit shift, this would be perhaps surprising. Obviously the standards committee wanted to avoid such ambiguity.</p>\n<p>My conclusion:</p>\n<ul>\n<li>if you want to do real bit pattern\noperations use unsigned types</li>\n<li><p>if you want to multiply a\nvalue (signed or not) by a power of two, do just\nthat, something like</p>\n<p>i * (1u &lt;&lt; k)</p></li>\n</ul>\n<p>your compiler will transform this into decent assembler in any case.</p>\n", "OwnerUserId": "366377", "LastEditorUserId": "366377", "LastEditDate": "2016-03-26T23:27:53.647", "Id": "3785318", "Score": "6", "CreationDate": "2010-09-24T08:18:20.047", "LastActivityDate": "2016-03-26T23:27:53.647"}, "bq_ids": {"n4140": {"so_3784996_3785121_0": {"section_id": 6147, "quality": 0.9210526315789473, "length": 35}, "so_3784996_24844494_0": {"section_id": 5937, "quality": 1.0, "length": 13}, "so_3784996_3784996_0": {"section_id": 6147, "quality": 0.8157894736842105, "length": 31}}, "n3337": {"so_3784996_3785121_0": {"section_id": 5910, "quality": 0.9210526315789473, "length": 35}, "so_3784996_24844494_0": {"section_id": 5709, "quality": 1.0, "length": 13}, "so_3784996_3784996_0": {"section_id": 5910, "quality": 0.8157894736842105, "length": 31}}, "n4659": {"so_3784996_24844494_0": {"section_id": 7421, "quality": 1.0, "length": 13}, "so_3784996_3785121_0": {"section_id": 7643, "quality": 0.9210526315789473, "length": 35}, "so_3784996_3784996_0": {"section_id": 7643, "quality": 0.8157894736842105, "length": 31}}}, "22883966": {"ParentId": "3784996", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_3784996_22883966_0\">My question is why does left shift operation invoke Undefined Behaviour in C and why does right shift operator invoke just Implementation defined behaviour?</p>\n</blockquote>\n<p>The folks at LLVM speculate the shift operator has constraints because of the way the instruction is implemented on various platforms. From <a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html\" rel=\"nofollow\">What Every C Programmer Should Know About Undefined Behavior #1/3</a>:</p>\n<blockquote>\n<p id=\"so_3784996_22883966_1\">... My guess is that this originated because the underlying shift operations on various CPUs do different things with this: for example, X86 truncates 32-bit shift amount to 5 bits (so a shift by 32-bits is the same as a shift by 0-bits), but PowerPC truncates 32-bit shift amounts to 6 bits (so a shift by 32 produces zero). Because of these hardware differences, the behavior is completely undefined by C...</p>\n</blockquote>\n<p>Nate that the discussion was about shifting an amount greater than the register size. But its the closest I've found to explaining the shift constraints from an authority.</p>\n<p>I <em>think</em> a second reason is the potential sign change on a 2's compliment machine. But I've never read it anywhere (no offense to @sellibitze (and I happen to agree with him)).</p>\n", "OwnerUserId": "608639", "PostTypeId": "2", "Id": "22883966", "Score": "1", "CreationDate": "2014-04-05T17:03:50.817", "LastActivityDate": "2014-04-05T17:03:50.817"}, "29711167": {"ParentId": "3784996", "CommentCount": "6", "Body": "<p>Having the left-shift operator invoke Undefined Behavior when the left-hand operand is negative allows compilers to assume that the shift will only be reachable when the left-hand operand is non-negative.  This allows compilers which receive code like:</p>\n<pre><code>int do_something(int x)\n{\n  if (x &gt;= 0)\n  {\n    launch_missiles();\n    exit(1);\n  }\n  return x&lt;&lt;4;\n}\n</code></pre>\n<p>to recognize that such a method will never be called with a negative value for <code>x</code>, and thus the <code>if</code> test can be deleted and the <code>launch_missiles()</code> call made unconditional.  Since <code>exit</code> is known not to return, the compiler can also omit the computation of <code>x&lt;&lt;4</code>.  Were it not for such a rule, a programmer would have to insert some kind of clunky <code>__assume(x &gt;= 0);</code> directive to request such behavior, but making left-shifts of negative values Undefined Behavior eliminates the need to have a programmer who obviously wants such semantics (by virtue of performing the left-shift) to clutter up the code with them.</p>\n<p>Note, btw, in the hypothetical event that code did call <code>do_something(-1)</code>, it would be engaging in Undefined Behavior, so calling launch_missiles would be a perfectly legitimate thing to do.</p>\n", "OwnerUserId": "363751", "PostTypeId": "2", "Id": "29711167", "Score": "0", "CreationDate": "2015-04-17T23:43:26.603", "LastActivityDate": "2015-04-17T23:43:26.603"}, "3784996": {"CommentCount": "6", "AcceptedAnswerId": "3785121", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2010-09-24T07:26:22.233", "LastActivityDate": "2016-03-29T21:34:42.767", "LastEditDate": "2015-07-03T16:28:04.260", "ViewCount": "11488", "FavoriteCount": "4", "Title": "Why does left shift operation invoke Undefined Behaviour when the left side operand has negative value?", "Id": "3784996", "Score": "32", "Body": "<p>In C bitwise left shift operation invokes Undefined Behaviour when the left side operand has negative value.</p>\n<p>Relevant quote from ISO C99 (6.5.7/4)</p>\n<blockquote>\n<p id=\"so_3784996_3784996_0\">The  result  of E1 &lt;&lt; E2 is E1 left-shifted E2 bit  positions;  vacated  bits  are  \ufb01lled  with zeros.  If E1 has an unsigned type, the value of the result is E1 \u00d7 2<sup>E2</sup>, reduced modulo\n  one more than the maximum value representable in the result type.  If E1 has a signed\n  type and nonnegative value, and E1 \u00d7 2<sup>E2</sup> is representable in the result type, then that is\n  the resulting value; otherwise, <strong>the behavior is unde\ufb01ned</strong>.</p>\n</blockquote>\n<p>But in C++ the behaviour is well defined.</p>\n<p>ISO C++-03 (5.8/2)</p>\n<blockquote>\n<p id=\"so_3784996_3784996_1\">The value of E1 &lt;&lt; E2 is E1 (interpreted as a bit pattern) left-shifted E2 bit positions; vacated bits are zero-filled.  If E1 has an unsigned type, the value of the result is E1 multiplied by the quantity 2 raised to the power E2, reduced modulo ULONG_MAX+1 if E1 has type unsigned long, UINT_MAX+1 otherwise.\n  [Note: the constants ULONG_MAXand UINT_MAXare defined in the header ).  ]</p>\n</blockquote>\n<p>That means</p>\n<pre><code>int a = -1, b=2, c;\nc= a &lt;&lt; b ;\n</code></pre>\n<p>invokes Undefined Behaviour in C but the behaviour is well defined in C++.</p>\n<p>What forced the ISO C++ committee to consider that behaviour well defined as opposed to the behaviour in C?</p>\n<p>On the other hand the behaviour is <code>implementation defined</code> for bitwise right shift operation when the left operand is negative, right?</p>\n<p>My question is why does left shift operation invoke Undefined Behaviour in C and why does right shift operator invoke just Implementation defined behaviour?</p>\n<p>P.S : Please don't give answers like \"It is undefined behaviour because the Standard says so\". :P</p>\n", "Tags": "<c++><c><language-lawyer><undefined-behavior><bit-shift>", "OwnerUserId": "165520", "AnswerCount": "8"}, "3785051": {"ParentId": "3784996", "CommentCount": "4", "Body": "<p>A lot of these kind of things are a balance between what common CPUs can actually support in a single instruction and what's useful enough to expect compiler-writers to guarantee even if it takes extra instructions.  Generally, a programmer using bit-shifting operators expects them to map to single instructions on CPUs with such instructions, so that's why there's undefined or implementation behaviour where CPUs had various handling of \"edge\" conditions, rather than mandating a behaviour and having the operation be unexpectedly slow.  Keep in mind that the additional pre/post or handling instructions may be made even for the simpler use cases.  undefined behaviour may have been necessary where some CPUs generated traps/exceptions/interrupts (as distinct from C++ try/catch type exceptions) or generally useless/inexplicable results, while if the set of CPUs considered by the Standards Committee at the time all provided at least some defined behaviour, then they could make the behaviour implementation defined.</p>\n", "OwnerUserId": "410767", "PostTypeId": "2", "Id": "3785051", "Score": "3", "CreationDate": "2010-09-24T07:35:40.120", "LastActivityDate": "2010-09-24T07:35:40.120"}, "24844494": {"ParentId": "3784996", "CommentCount": "2", "Body": "<p>The behavior in C++03 is the same as in C++11 and C99, you just need to look beyond the rule for left-shift.</p>\n<p>Section 5p5 of the Standard says that:</p>\n<blockquote>\n<p id=\"so_3784996_24844494_0\">If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined</p>\n</blockquote>\n<p>The left-shift expressions which are specifically called out in C99 and C++11 as being undefined behavior, are the same ones that evaluate to a result outside the range of representable values.</p>\n<p>In fact, the sentence about unsigned types using modular arithmetic is there specifically to avoid generating values outside the representable range, which would automatically be undefined behavior.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "24844494", "Score": "0", "CreationDate": "2014-07-19T20:06:33.510", "LastActivityDate": "2014-07-19T20:06:33.510"}, "3789752": {"ParentId": "3784996", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_3784996_3789752_0\">In C bitwise left shift operation invokes Undefined Behaviour when the\n  left side operand has negative value.\n  [...] \n  But in C++ the behaviour is well defined.\n  [...] why [...]</p>\n</blockquote>\n<p>The easy answer is: Becuase the standards say so.</p>\n<p>A longer answer is: It has probably something to do with the fact that C and C++ both allow other representations for negative numbers besides 2's complement. Giving fewer guarantees on what's going to happen makes it possible to use the languages on other hardware including obscure and/or old machines.</p>\n<p>For some reason, the C++ standardization committee felt like adding a little guarantee about how the bit representation changes. But since negative numbers still may be represented via 1's complement or sign+magnitude the resulting value possibilities still vary.</p>\n<p>Assuming 16 bit ints, we'll have</p>\n<pre><code> -1 = 1111111111111111  // 2's complement\n -1 = 1111111111111110  // 1's complement\n -1 = 1000000000000001  // sign+magnitude\n</code></pre>\n<p>Shifted to the left by 3, we'll get</p>\n<pre><code> -8 = 1111111111111000  // 2's complement\n-15 = 1111111111110000  // 1's complement\n  8 = 0000000000001000  // sign+magnitude\n</code></pre>\n<blockquote>\n<p id=\"so_3784996_3789752_1\">What forced the ISO C++ committee to consider that behaviour well\n  defined as opposed to the behaviour in C?</p>\n</blockquote>\n<p>I guess they made this guarantee so that you can use &lt;&lt; appropriately when you know what you're doing (ie when you're sure your machine uses 2's complement).</p>\n<blockquote>\n<p id=\"so_3784996_3789752_2\">On the other hand the behaviour is implementation defined for bitwise\n  right shift operation when the left operand is negative, right?</p>\n</blockquote>\n<p>I'd have to check the standard. But you may be right. A right shift without sign extension on a 2's complement machine isn't particularly useful. So, the current state is definitely better than requiring vacated bits to be zero-filled because it leaves room for machines that do a sign extensions -- even though it is not guaranteed.</p>\n", "OwnerUserId": "172531", "PostTypeId": "2", "Id": "3789752", "Score": "14", "CreationDate": "2010-09-24T18:02:26.850", "LastActivityDate": "2010-09-24T18:02:26.850"}});