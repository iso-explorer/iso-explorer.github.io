post_cb({"33814842": {"Id": "33814842", "PostTypeId": "2", "Body": "<h1>C++ situation</h1>\n<p>In C++, each enum has an underlying integral type.   It can be fixed, if it is explicittly specified (ex: <code>enum test2 : long { a,b};</code>) or <code>int</code> by default in the case of a <strong>scoped</strong> enum (ex: <code>enum class test { a,b };</code>):   </p>\n<blockquote>\n<p id=\"so_33812998_33814842_0\"><strong>7.2/5:</strong> Each enumeration defines a type that is different from all other types. Each enumeration also has an underlying type. (...) if not\n  explicitly specified, the underlying type of a scoped enumeration type\n  is int. In these cases, the underlying type is said to be fixed.</p>\n</blockquote>\n<p>In the case of an <strong>unscoped</strong> enum where the underlying type was not explicitely fixed (<strong>your example</strong>), the standard gives more flexibility to your compiler:  </p>\n<blockquote>\n<p id=\"so_33812998_33814842_1\"><strong>7.2/6:</strong> For an enumeration whose underlying type is not fixed, the underlying type is an integral type that can represent all the\n  enumerator values defined in the enumeration.  (...) It is implementation-defined which integral type is used as the underlying\n  type except that the underlying type shall not be larger than int\n  unless the value of an enumerator cannot fit in an int or unsigned\n  int.</p>\n</blockquote>\n<p>Now a <strong>very tricky thing</strong>: the values that can be held by an enum variable depends on whether or not the underlying type is fixed:  </p>\n<ul>\n<li><p>if it's fixed, <em>\"the values of the enumeration are the values of the\nunderlying type.\"</em> </p></li>\n<li><p>otherwhise, it is the integral values within the minimum and the maximum of the smallest bit-field that can hold the smallest enumerator and the largest one.  </p></li>\n</ul>\n<p>You are in the second case, although your code will work on most compilers, the smalest bitfield has a size of 1 and so the only values that you can for sure hold on all compliant C++ compilers are those between 0 and 1... <strong>If you want to be sure that you can set the value of 2, you either have to make it a scoped enum, or explicitely indicate an underlying type.</strong> </p>\n<p><strong><em>More reading:</em></strong><br> </br></p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/4969233/how-to-check-if-enum-value-is-valid\">SO question on how to check if an enum value is valid</a><br/></li>\n<li><a href=\"https://www.securecoding.cert.org/confluence/display/cplusplus/INT50-CPP.+Do+not+cast+to+an+out-of-range+enumeration+value\" rel=\"nofollow noreferrer\">article on avoiding enum out-of-rang in <strong>secure coding</strong></a>.  </li>\n<li><a href=\"http://www.stroustrup.com/C++11FAQ.html#enum\" rel=\"nofollow noreferrer\">Stroutstrup's plaidoyer for scoped enum over unscoped ones</a></li>\n</ul>\n<h1>C situation</h1>\n<p>The C situation is much simpler: </p>\n<blockquote>\n<p id=\"so_33812998_33814842_2\"><strong>6.2.5/16:</strong> An enumeration comprises a set of named integer constant values. Each distinct enumeration constitutes a different enumerated\n  type.</p>\n</blockquote>\n<p>So basically, it is an int: </p>\n<blockquote>\n<p id=\"so_33812998_33814842_3\"><strong>6.7.2.2./2</strong> The expression that defines the value of an enumeration constant shall be an integer constant expression that has a value\n  representable as an int.</p>\n</blockquote>\n<p>With the following restriction: </p>\n<blockquote>\n<p id=\"so_33812998_33814842_4\">Each enumerated type shall be compatible with char, a signed integer\n  type, or an unsigned integer type. The choice of type is\n  implementation-defined, 128) but shall be capable of representing the\n  values of all the members of the enumeration.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-20T03:31:59.557", "Score": "16", "CreationDate": "2015-11-19T21:39:37.537", "ParentId": "33812998", "CommentCount": "4", "OwnerUserId": "3723423", "LastEditDate": "2017-05-23T12:24:06.107"}, "33812998": {"ViewCount": "1817", "Body": "<p>Say, we have</p>\n<pre><code>enum E\n{\n  Foo = 0,\n  Bar = 1\n};\n</code></pre>\n<p>Now, we do</p>\n<pre><code>enum E v = ( enum E ) 2;\n</code></pre>\n<p>And then</p>\n<pre><code>switch ( v )\n{\n  case Foo:\n    doFoo();\n  break;\n  case Bar:\n    doBar();\n  break;\n  default:\n    // Is the compiler required to honor this?\n    doOther();\n  break;\n}\n</code></pre>\n<p>Since the switch above handles every possible listed value of the enum, is it allowed for the compiler to optimize away the <code>default</code> branch above, or otherwise have an unspecified or undefined behavior in the case the value of enum is not in the list?</p>\n<p>As I am expecting that the behavior should be similar for C and C++, the question is about both languages. However, if there's a difference between C and C++ for that case, it would be nice to know about it, too.</p>\n", "Title": "Is it allowed for an enum to have an unlisted value?", "CreationDate": "2015-11-19T19:44:19.957", "LastActivityDate": "2015-11-20T03:31:59.557", "CommentCount": "13", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2015-11-19T20:23:26.977", "Tags": "<c++><c><enums><language-lawyer>", "Id": "33812998", "LastEditorUserId": "882478", "Score": "28", "OwnerUserId": "882478", "ClosedDate": "2015-11-20T19:08:59.947", "AnswerCount": "6"}, "33813672": {"Id": "33813672", "PostTypeId": "2", "Body": "<p>In C an <code>enum</code> type is an integer type large enough to hold all the <code>enum</code> constants:</p>\n<blockquote>\n<p id=\"so_33812998_33813672_0\">(C11, 6.7.2.2p4) \"Each enumerated type shall be compatible with char, a signed integer type, or an unsigned integer type. The choice of type is implementation-defined,110) but shall be capable of representing the values of all the members of the enumeration\".</p>\n</blockquote>\n<p>Let's say the selected type for <code>enum E</code> is <code>_Bool</code>. A <code>_Bool</code> object can only store the values <code>0</code> and <code>1</code>. It's not possible to have a <code>_Bool</code> object storing a value different than <code>0</code> or <code>1</code> without invoking undefined behavior.</p>\n<p>In that case the compiler is allowed to assume that an object of the <code>enum E</code> type can only hold <code>0</code> or <code>1</code> in a strictly conforming program and is so allowed to optimize out the <code>default</code> switch case.</p>\n", "LastActivityDate": "2015-11-19T20:22:29.463", "CommentCount": "3", "CreationDate": "2015-11-19T20:22:29.463", "ParentId": "33812998", "Score": "3", "OwnerUserId": "1119701"}, "bq_ids": {"n4140": {"so_33812998_33814842_3": {"length": 7, "quality": 0.5384615384615384, "section_id": 5464}, "so_33812998_33814842_1": {"length": 33, "quality": 0.9166666666666666, "section_id": 5466}, "so_33812998_33814842_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 5464}, "so_33812998_33814842_2": {"length": 11, "quality": 0.7333333333333333, "section_id": 7221}, "so_33812998_33813557_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 6036}, "so_33812998_33813420_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 5467}}, "n3337": {"so_33812998_33814842_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 5251}, "so_33812998_33814842_2": {"length": 11, "quality": 0.7333333333333333, "section_id": 6965}, "so_33812998_33813557_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 5804}, "so_33812998_33813420_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 5253}, "so_33812998_33814842_1": {"length": 33, "quality": 0.9166666666666666, "section_id": 5252}}, "n4659": {"so_33812998_33814842_3": {"length": 7, "quality": 0.5384615384615384, "section_id": 6898}, "so_33812998_33814842_1": {"length": 33, "quality": 0.9166666666666666, "section_id": 6900}, "so_33812998_33814842_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 6898}, "so_33812998_33814842_2": {"length": 10, "quality": 0.6666666666666666, "section_id": 8730}, "so_33812998_33813557_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 7535}, "so_33812998_33813420_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 6901}}}, "33813196": {"Id": "33813196", "PostTypeId": "2", "Body": "<p>In C enumerators have type <code>int</code>  . Thus any integer value can be assigned to an object of the enumeration type.</p>\n<p>From the C Standard (6.7.2.2 Enumeration specifiers)</p>\n<blockquote>\n<p id=\"so_33812998_33813196_0\">3 The identifiers in an enumerator list are declared as constants that\n  have type <strong>int</strong> and may appear wherever such are permitted.</p>\n</blockquote>\n<p>In C++ enumerators have type of the enumeration that defines it. In C++ you should either expliicitly  to specify the underlaying type or the compiler calculates itself the maximum allowed value.</p>\n<p>From the C++ Standard (7.2 Enumeration declarations)</p>\n<p>5 Each enumeration defines a type that is different from all other types. Each enumeration also has an underlying type. The underlying type can be explicitly specified using enum-base; if not explicitly specified, the underlying type of a scoped enumeration type is int. In these cases, the underlying type is said to be fixed. Following the closing brace of an enum-specifier, <strong>each enumerator has the type of its enumeration</strong>.</p>\n<p>Thus in C any possible value of a enum is any integer value. The compiler may not optimize a switch  removing the default label.</p>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2015-11-19T20:16:38.097", "Score": "-1", "CreationDate": "2015-11-19T19:55:19.787", "ParentId": "33812998", "CommentCount": "1", "OwnerUserId": "2877241", "LastEditDate": "2015-11-19T20:16:38.097"}, "33813557": {"Id": "33813557", "PostTypeId": "2", "Body": "<p>Also, 7.2/10:</p>\n<blockquote>\n<p id=\"so_33812998_33813557_0\">An expression of arithmetic or enumeration type can be converted to an\n  enumeration type explicitly. The value is unchanged if it is in the\n  range of enumeration values of the enumeration type; otherwise the\n  resulting enumeration value is unspecified.</p>\n</blockquote>\n", "LastActivityDate": "2015-11-19T20:16:28.643", "CommentCount": "2", "CreationDate": "2015-11-19T20:16:28.643", "ParentId": "33812998", "Score": "0", "OwnerUserId": "70930"}, "33813227": {"Id": "33813227", "PostTypeId": "2", "Body": "<p>In C and C++, this can work.</p>\n<p>Same code for both:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nenum E\n{\n  Foo = 0,\n  Bar = 1\n};\n\nint main()\n{\n    enum E v = (enum E)2;    // the cast is required for C++, but not for C\n    printf(\"v = %d\\n\", v);\n    switch (v) {\n    case Foo:\n        printf(\"got foo\\n\");\n        break;\n    case Bar:\n        printf(\"got bar\\n\");\n        break;\n    default:\n        printf(\"got \\n\", v);\n        break;\n    }\n}\n</code></pre>\n<p>Same output for both:</p>\n<pre><code>v = 2\ngot default\n</code></pre>\n<p>In C, an <code>enum</code> is an integral type, so you can assign an integer value to it without casting.  In C++, an <code>enum</code> is its own type.</p>\n", "LastEditorUserId": "1687119", "LastActivityDate": "2015-11-19T20:54:57.707", "Score": "-1", "CreationDate": "2015-11-19T19:56:49.027", "ParentId": "33812998", "CommentCount": "2", "OwnerUserId": "1687119", "LastEditDate": "2015-11-19T20:54:57.707"}, "33813420": {"Id": "33813420", "PostTypeId": "2", "Body": "<p>C++Std 7.2.7 [dcl.enum]:</p>\n<blockquote>\n<p id=\"so_33812998_33813420_0\">It is possible to de\ufb01ne an enumeration that has values not de\ufb01ned by any of its enumerators.</p>\n</blockquote>\n<p>So, you can have enumeration values which are not listed in enumerator list.</p>\n<p>But in your specific case, the 'underlying type' is not 'fixed' (7.2.5). The specification doesn't say which is the underlying type in that case, but it must be integral. Since char is the smallest such type, we can conclude that there are other values of the enum which are not specified in the enumerator list.</p>\n<p>Btw, I think that the compiler can optimize your case when it can determine that there are no other values ever assigned to v, which is safe, but I think there are no compilers which are that smart yet.</p>\n", "LastEditorUserId": "3204551", "LastActivityDate": "2015-11-19T20:15:42.757", "Score": "0", "CreationDate": "2015-11-19T20:08:51.597", "ParentId": "33812998", "CommentCount": "19", "OwnerUserId": "5582100", "LastEditDate": "2015-11-19T20:15:42.757"}});