post_cb({"28708829": {"ViewCount": "70", "Body": "<p>I would like to limit the access (or mutation) of a class field s.t. it can only be accessed (or set) from the given namespace via a dedicated function/method.</p>\n<p>Since friendship is not transitive or inherited, my idea was to use an internal namespace (the one which is supposed to be implementation detail) and make the corresponding functions as friends. For example, if  we want to store a secret and allow only the code inside the internal namespace to access it and everybody else to set it, I was hoping this would do the trick:</p>\n<pre><code>#include &lt;cassert&gt;\n\nnamespace detail {\n\n// forward declaration doesn't help\n// class SecretHolder;\n// int GetSecret(SecretHolder&amp; sh);\n\nclass SecretHolder {\n  int secret_;\n  friend int GetSecret(SecretHolder&amp; sh);\n public:\n  void SetSecret(int val) { secret_ = val; }\n};\n\n// nor does inlining as \"friend void GetSecret(SecretHolder&amp; sh) { ... }\"\nint GetSecret(SecretHolder&amp; sh) { return sh.secret_; }\nvoid DoNothing() { }\n\n} // namespace detail\n\nclass User : public detail::SecretHolder {\n  // ...\n};\n\nint main(int argc, char* argv[]) {\n  User u;\n  u.SetSecret(42);\n  assert(GetSecret(u) == 42); // XXX: why it works without detail:: ???\n  // DoNothing(); // this would indeed give a compile error\n  return 0;\n}\n</code></pre>\n<p>However, it seems like <code>detail::GetSecret</code> <em>escaped the enclosing namespace</em> <code>detail</code> where it is defined, so the above program compiles and the assertion passes. I am confused, especially after I reading 7.3.1.2/3 (of ISO/IEC 14882:2011):</p>\n<blockquote>\n<p id=\"so_28708829_28708829_0\">Every name first declared in a namespace is a member of that\n  namespace. If a friend declaration in a non-local class first declares\n  a class or function the friend class or function is a member of the\n  <strong>innermost enclosing namespace</strong>. The name of the friend is not found by\n  unqualified lookup (3.4.1) or by qualified lookup (3.4.3) until a\n  matching declaration is provided in that namespace scope (either\n  before or after the class definition granting friendship). If a friend\n  function is called, its name may be found by the name lookup that\n  considers functions from namespaces and classes associated with the\n  types of the function arguments (3.4.2). If the name in a friend\n  declaration is neither qualified nor a template-id and the declaration\n  is a function or an elaborated-type-specifier, the lookup to determine\n  whether the entity has been previously declared shall not consider any\n  scopes outside the innermost enclosing namespace.</p>\n</blockquote>\n<p>I checked with recent versions of three major compilers (GCC, CLANG &amp; ICC), and the behavior seems to be consistent. What am I missing here and how to achieve what I originally intended?</p>\n", "Title": "Restricting field mutation/access to a namespace", "CreationDate": "2015-02-25T00:08:30.070", "LastActivityDate": "2015-03-11T02:41:20.003", "CommentCount": "1", "PostTypeId": "1", "Id": "28708829", "Score": "4", "OwnerUserId": "395744", "Tags": "<c++><oop><namespaces><encapsulation><friend>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28708829_28708829_0": {"length": 77, "quality": 0.9058823529411765, "section_id": 5485}}, "n3337": {"so_28708829_28708829_0": {"length": 81, "quality": 0.9529411764705882, "section_id": 5271}}, "n4659": {"so_28708829_28708829_0": {"length": 70, "quality": 0.8235294117647058, "section_id": 6920}}}, "28977601": {"Id": "28977601", "PostTypeId": "2", "Body": "<p>So, I don't have a copy of the ISO to reference in my answer, but I'm going to take a stab at what is going on. Your problem does not exist with rules of friend, but rather visibility of functions defined in a namespace when they take as a parameter an object of a type declared in the namespace.</p>\n<p>To illustrate what I am talking about let me create another function to see if we can call it without specifying the namespace:</p>\n<pre><code>bool SeeYou(SecretHolder * sh)\n{\n    return sh != nullptr;\n\n}\n</code></pre>\n<p>These changes allow us to do a few more compile time checks:</p>\n<pre><code>int _tmain(int argc, _TCHAR * argv[])\n{\n    User u;\n    u.SetSecret(42);\n\n// The following works because GetSecret is being given an object that\n// exists within the detail namespace.\n    assert(GetSecret(u) == 42);\n\n// Let's try some things with see you.\n    assert(SeeYou(&amp;u));\n\n// This fails because nullptr is not of the detail namespace.\n    //assert(SeeYou(nullptr));  // Compile fails.\n    assert(detail::SeeYou(nullptr);  // Compile succeeds.\n\n// Let's see what an object of type SecretHolder does.\n    detail::SecretHolder * secretSecretsAreNoFun = new SecretHolder();\n    assert(CaughtYou(secretSecretsAreNoFun)); // This works.\n    secretSecretsAreNoFun = nullptr;\n    assert(CaughtYou(secretSecretsAreNoFun)); // Throws an assert.        \n\n    //assert(CaughtYou(nullptr)); // Compilation fails.\n\n    return 0;\n}\n</code></pre>\n<p>Edit:</p>\n<p>I forgot to mention, I do not have a good answer for the second part of your question, how to implement a private secret key, except that I would avoid inheriting the class that contains my secret keys. The variable <code>secret_</code> is going to always be at a particular offset on the <code>User</code> objects stack.</p>\n<p>I would suggest you map the object and secret in a way that everyone inside of the namespace could look it up.</p>\n", "LastEditorUserId": "4326145", "LastActivityDate": "2015-03-11T02:41:20.003", "Score": "0", "CreationDate": "2015-03-11T02:33:53.377", "ParentId": "28708829", "CommentCount": "0", "OwnerUserId": "4326145", "LastEditDate": "2015-03-11T02:41:20.003"}});