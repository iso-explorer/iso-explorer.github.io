post_cb({"bq_ids": {"n4140": {"so_20823911_20826020_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 5834}}, "n3337": {"so_20823911_20826020_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 5605}}, "n4659": {"so_20823911_20826020_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 7296}}}, "20824238": {"Id": "20824238", "PostTypeId": "2", "Body": "<p>I think the real reason for <code>count</code> to be an <code>atomic&lt;int&gt;</code> is that is is <em>read</em> in <code>aquire()</code> <strong>outside</strong> of the <code>mutex</code>-protected area in this line:</p>\n<pre><code>while (count &gt;= size) {}\n</code></pre>\n<p>Without <code>atomic</code>, the compile is allowed to assume that reading it once is enough and it will not poll it for changed values from other threads.</p>\n", "LastActivityDate": "2013-12-29T10:36:33.420", "CommentCount": "4", "CreationDate": "2013-12-29T10:36:33.420", "ParentId": "20823911", "Score": "7", "OwnerUserId": "2073257"}, "20823911": {"ViewCount": "1398", "Body": "<p>Given the code in <a href=\"https://stackoverflow.com/questions/20534782/implementing-semaphore-by-using-mutex-operations-and-primitives\">this post</a>, to implement <code>Semaphore</code> using only <code>atomic&lt;&gt;</code> and <code>mutex</code>.</p>\n<p>I'm just curious that since <code>count</code> is already guarded by <code>updateMutex</code>, is <code>atomic&lt;&gt;</code> necessary?</p>\n<pre><code>struct Semaphore {\n    int size;\n    atomic&lt;int&gt; count;\n    mutex updateMutex;\n\n    Semaphore(int n) : size(n) { count.store(0); }\n\n    void aquire() {\n        while (1) {\n            while (count &gt;= size) {}\n            updateMutex.lock();\n            if (count &gt;= size) {\n                updateMutex.unlock();\n                continue;\n            }\n            ++count;\n            updateMutex.unlock();\n            break;\n        }\n    }\n\n    void release() {\n        updateMutex.lock();\n        if (count &gt; 0) {\n            --count;\n        } // else log err\n        updateMutex.unlock();\n    }\n};\n</code></pre>\n<p>Without <code>atomic</code>, I think the constructor would get synchronization problem. Assignment to count might not be visible if other threads are using it right after the construction.</p>\n<p>If so, what about <code>size</code>? Does it also need to be protected by <code>atomic&lt;&gt;</code>?</p>\n<p>Or the <code>atomic&lt;&gt;</code> is totally useless because both <code>size</code> and <code>count</code> will be visible no matter when other threads use them.</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "20826020", "Title": "Do I need to use atomic<> if already guard by mutex", "CreationDate": "2013-12-29T09:52:43.793", "Id": "20823911", "CommentCount": "12", "LastEditDate": "2017-05-23T11:47:05.003", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2013-12-29T14:16:11.670", "Score": "8", "OwnerUserId": "2190129", "Tags": "<c++><multithreading><c++11>", "AnswerCount": "3"}, "20824034": {"Id": "20824034", "PostTypeId": "2", "Body": "<p>Yes. There is a theoretical risk that: </p>\n<p><code>count = 0;</code> </p>\n<p>in the constructor would not be observed by a different threading running on another CPU in time for a subsequent call to either <code>acquire()</code> or <code>release()</code>.    The possibility of this happening is likely to be vanishingly small as the in order to use the semaphore object, the constructor must complete and somehow another thread needs to get hold of the object.</p>\n<p>This is to say that the other CPU's view of the memory occupied by <code>count</code> would not be synchronised between CPUs, and another could read an old (e.g. uninitialised) value. </p>\n<p>Using an <code>std::atomic&lt;int&gt;</code> here by default generates memory barriers around the loads (in this case via overloaded operators) and stores.  By default, this is ultra-conservative. .</p>\n<p>You could also lock and unlock the mutex in the constructor for the same effect - but this is even more expensive. </p>\n<p>It must be said that this is a pretty nasty way of implementing a counting semaphore - but it was afterall an interview question, and as such has a lot of facets. </p>\n", "LastEditorUserId": "450758", "LastActivityDate": "2013-12-29T11:23:41.873", "Score": "3", "CreationDate": "2013-12-29T10:08:48.610", "ParentId": "20823911", "CommentCount": "8", "LastEditDate": "2013-12-29T11:23:41.873", "OwnerUserId": "450758"}, "20826020": {"Id": "20826020", "PostTypeId": "2", "Body": "<p>There are multiple questions asked. All require that the underlying concept is understood: you have a <em>data race</em> if one object is written by at least one thread which is accessed (read or written) by another thread and the write and the access are not synchronized. The formal definition of data races is in 1.10 [intro.multithread] paragraph 21:</p>\n<blockquote>\n<p id=\"so_20823911_20826020_0\">The execution of a program contains a <em>data race</em> if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. [...]</p>\n</blockquote>\n<p>A program which contains a data race has undefined behavior, i.e., the program needs to make sure that it is data race free. Now on to answering the different questions:</p>\n<ol>\n<li><p>Is it necessary to use synchronization in the constructor?</p>\n<p>It depends on whether the object may be access concurrently by different threads while it is still under construction. The only case I can imagine concurrent access to an object under construction is during static initialization where multiple thread are already kicked off accessing the shared object. Due to the weak constraints on the order of construction for global objects I can't imagine that global objects would be used anyway and construction of function local <code>static</code> objects is synchronized by the implementation. Otherwise, I would expect that a reference to the object would shared across threads using a suitably synchronized mechanism. That is, I would design the system such that the constructor doesn't require synchronization.</p></li>\n<li><p>There is a lock already. Does that mean that <code>count</code> doesn't have to be an atomic.</p>\n<p>Since <code>count</code> is accessed in the <code>acquire()</code> function before lock is obtained, it would be an unsynchronized access to an object which is written by another thread, i.e., you'd have a data race and, hence, undefined behavior. The <code>count</code> has to be atomic.</p></li>\n<li><p>Is it necessary for <code>size</code> to be synchronized, too.</p>\n<p>The <code>size</code> member is only modified in the constructor of <code>Semaphore</code> and it might be reasonable to enforce that by actually making it a <code>const</code> member. Assuming the object isn't concurrently accessed during construction (see 1. above) there is no potential for a data race when accessing <code>size</code>.</p></li>\n</ol>\n<p>Note that you shouldn't really make unguarded use of the <code>lock()</code> and <code>unlock()</code> members of the mutex. Instead, you should use <code>std::lock_guard&lt;std::mutex&gt;</code> or <code>std::unique_lock&lt;std::mutex&gt;</code>, potentially with an auxiliary block. These two classes guarantee that an acquired lock will always be released. I'd also question if a busy wait for a semaphore acquiring a lock anyway is the right way to go.</p>\n", "LastActivityDate": "2013-12-29T14:16:11.670", "CommentCount": "2", "CreationDate": "2013-12-29T14:16:11.670", "ParentId": "20823911", "Score": "5", "OwnerUserId": "1120273"}});