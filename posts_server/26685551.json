post_cb({"bq_ids": {"n4140": {"so_26685551_26963841_0": {"length": 65, "quality": 0.9154929577464789, "section_id": 3296}}, "n3337": {"so_26685551_26963841_0": {"length": 65, "quality": 0.9154929577464789, "section_id": 3166}}, "n4659": {"so_26685551_26963841_0": {"length": 46, "quality": 0.647887323943662, "section_id": 4058}}}, "28191610": {"Id": "28191610", "PostTypeId": "2", "Body": "<p>I agree with the comments that this seems to be a GCC bug (reported as <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63707\" rel=\"nofollow\">63707</a>).</p>\n<p>It only fails to compile when the type in the array has a user-defined destructor, which doesn't make sense to me.</p>\n", "LastActivityDate": "2015-01-28T11:52:31.093", "CommentCount": "2", "CreationDate": "2015-01-28T11:52:31.093", "ParentId": "26685551", "Score": "3", "OwnerUserId": "981959"}, "26963841": {"Id": "26963841", "PostTypeId": "2", "Body": "<p>I came through a similar issue, namely that this code</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Widget {\npublic:\n    Widget(int i) { std::cout &lt;&lt; \"Ctor \" &lt;&lt; i &lt;&lt; std::endl; }\n\n    Widget(const Widget&amp;); // = delete;\n};\n\nint main() {\n    Widget w = 123;\n}\n</code></pre>\n<p>compiled and gave the expected result, but after uncommenting the <code>= delete</code> it failed to compile with gcc-4.9.</p>\n<p>After reading the standard I <strong>believe</strong> the answer lies in the second item of highest indentation in <code>8.5/16</code>, which is cited below.</p>\n<p>What basically seems to happen is that the compiler conceptually wants to create a temporary of type <code>Widget</code> and <em>direct-initialize</em> the actual object <code>w</code> from that temporary through the copy constructor. Since the copy constructor is deleted, compilation stops. If the copy constructor was not deleted, the compiler would later realize that it may elide the copy, but it does not get that far.</p>\n<p>Here is the relevant part: </p>\n<blockquote>\n<p id=\"so_26685551_26963841_0\">[...] for the [...] copy-initialization cases [...] user-defined conversion sequences that can convert from the source type to the destination type [...] are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3). [...] The function selected is called with the initializer expression as its argument; if the function is a constructor, the call initializes a temporary of the cv-unqualified version of the destination type. [...] The result of the call (which is the temporary for the constructor case) is then used to direct-initialize, according to the rules above, the object that is the destination of the copy-initialization. In certain cases, an implementation is permitted to eliminate the copying inherent in this direct-initialization by constructing the\n  intermediate result directly into the object being initialized; see 12.2, 12.8.</p>\n</blockquote>\n<p>But I may be wrong since there is a lot in the <code>[...]</code> parts that I did not understand.</p>\n", "LastActivityDate": "2014-11-17T00:43:05.467", "CommentCount": "5", "CreationDate": "2014-11-17T00:43:05.467", "ParentId": "26685551", "Score": "-1", "OwnerUserId": "1171688"}, "26685551": {"ViewCount": "909", "Body": "<p>The existing question on <a href=\"https://stackoverflow.com/a/14543600/4086593\">Why can't I initialise an array of objects if they have private copy constructors?</a> specifically refers to C++03.  I know from that question that what I am trying to do is not allowed in C++03 but I thought that it should be possible in C++11</p>\n<p>I have a non-movable class (call it Child) and I need to initialize an array of Child in the constructor of another class (call it Parent).  By \"non-movable\" I mean that the address of a Child object has to remain the same during that object's lifetime.  What is the correct way to do this?</p>\n<p>With C++11 I've tried the following:</p>\n<pre><code>class Child\n{\npublic:\n    Child (int x) {}\n    ~Child () {}\n\n    Child (const Child &amp;) = delete;\n};\n\nclass Parent\n{\npublic:\n    Parent () : children {{5}, {7}} {}\n\nprivate:\n    Child children[2];\n};\n</code></pre>\n<p>This code compiles fine with Clang 3.5.0, but GCC 4.9.1 complains that I am trying to use the deleted copy constructor:</p>\n<pre><code>test.cc: In constructor \u2018Parent::Parent()\u2019:\ntest.cc:13:35: error: use of deleted function \u2018Child::Child(const Child&amp;)\u2019\n     Parent () : children {{5}, {7}} {}\n                                   ^\ntest.cc:7:5: note: declared here\n     Child (const Child &amp;) = delete;\n     ^\n</code></pre>\n<p>I've read about the difference between copy-initialization and direct-initialization (<a href=\"https://stackoverflow.com/a/15142929/4086593\">here</a> and <a href=\"https://stackoverflow.com/a/1051468/4086593\">here</a>, for example), and I want to avoid calling the copy constructor by using direct-initialization.  Am I getting the syntax wrong?  Is this a bug in GCC?  Or is what I am trying to do just not possible?</p>\n", "AcceptedAnswerId": "28191610", "Title": "How to initialize array of classes with deleted copy constructor (C++11)", "CreationDate": "2014-11-01T01:48:32.253", "Id": "26685551", "CommentCount": "7", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:00:32.103", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-28T11:52:31.093", "Score": "12", "OwnerUserId": "4086593", "Tags": "<c++><arrays><c++11><gcc><clang>", "AnswerCount": "2"}});