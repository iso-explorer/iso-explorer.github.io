post_cb({"17220643": {"Id": "17220643", "PostTypeId": "2", "Body": "<p>Here's how you get a copy constructor and copy assignment that allows a volatile source:</p>\n<pre><code>struct X {\n  X(const X&amp; o) : members(o.members) {}\n  X(const volatile X&amp; o) : members(o.members) {}\n  X&amp; operator=(const X&amp; o) {v=o.v; return *this;}\n  X&amp; operator=(const volatile X&amp; o) {v=o.v; return *this;}\n};\n</code></pre>\n<p>Note though that this has some consequences. The type is no longer POD or even trivially copyable, for one. Which might defeat the whole point of making it volatile.</p>\n", "LastEditorUserId": "845092", "LastActivityDate": "2013-06-20T18:59:34.257", "Score": "1", "CreationDate": "2013-06-20T18:04:00.740", "ParentId": "17220498", "CommentCount": "8", "OwnerUserId": "8922", "LastEditDate": "2013-06-20T18:59:34.257"}, "bq_ids": {"n4140": {"so_17220498_17220579_6": {"length": 11, "quality": 0.9166666666666666, "section_id": 467}, "so_17220498_17220579_1": {"length": 45, "quality": 0.9183673469387755, "section_id": 467}, "so_17220498_17220579_0": {"length": 11, "quality": 1.0, "section_id": 2}, "so_17220498_17220579_7": {"length": 9, "quality": 0.6923076923076923, "section_id": 467}, "so_17220498_17220579_4": {"length": 8, "quality": 1.0, "section_id": 467}}, "n3337": {"so_17220498_17220579_4": {"length": 8, "quality": 1.0, "section_id": 458}, "so_17220498_17220579_1": {"length": 45, "quality": 0.9183673469387755, "section_id": 458}, "so_17220498_17220579_0": {"length": 11, "quality": 1.0, "section_id": 2}, "so_17220498_17220579_7": {"length": 9, "quality": 0.6923076923076923, "section_id": 458}, "so_17220498_17220579_6": {"length": 11, "quality": 0.9166666666666666, "section_id": 458}}, "n4659": {"so_17220498_17220579_4": {"length": 8, "quality": 1.0, "section_id": 490}, "so_17220498_17220579_1": {"length": 45, "quality": 0.9183673469387755, "section_id": 490}, "so_17220498_17220579_0": {"length": 11, "quality": 1.0, "section_id": 2}, "so_17220498_17220579_7": {"length": 9, "quality": 0.6923076923076923, "section_id": 490}, "so_17220498_17220579_6": {"length": 11, "quality": 0.9166666666666666, "section_id": 490}}}, "17220645": {"Id": "17220645", "PostTypeId": "2", "Body": "<p>You can implement the assignment operator <code>=</code>:</p>\n<pre><code>T&amp; operator=(const volatile T &amp;rhs) {\n    m_x = rhs.m_x;\n    return *this;\n}\n</code></pre>\n", "LastActivityDate": "2013-06-20T18:04:09.203", "CommentCount": "0", "CreationDate": "2013-06-20T18:04:09.203", "ParentId": "17220498", "Score": "0", "OwnerUserId": "2489083"}, "17220498": {"ViewCount": "865", "Body": "<p><a href=\"http://ideone.com/Q1qswW\" rel=\"nofollow\">This code</a></p>\n<pre><code>struct T {\n    int m_x;\n    T(int x) : m_x(x) {}\n\n    operator T() {\n        return T(0);\n    }\n};\n\nint main() {\n    volatile T v(2);\n\n    T nv(1);\n    nv = v; // nv.m_x = 0\n}\n</code></pre>\n<p>Gives:</p>\n<pre><code>prog.cpp: In function \u2018int main()\u2019:\nprog.cpp:14:10: error: no match for \u2018operator=\u2019 in \u2018nv = v\u2019\nprog.cpp:14:10: note: candidates are:\nprog.cpp:1:8: note: T&amp; T::operator=(const T&amp;)\nprog.cpp:1:8: note:   no known conversion for argument 1 from \u2018volatile T\u2019 to \u2018const T&amp;\u2019\nprog.cpp:1:8: note: T&amp; T::operator=(T&amp;&amp;)\nprog.cpp:1:8: note:   no known conversion for argument 1 from \u2018volatile T\u2019 to \u2018T&amp;&amp;\u2019\n</code></pre>\n<p>What typecast overload do I need to define for this to work?</p>\n", "AcceptedAnswerId": "17220579", "Title": "Can I add an implicit conversion from a volatile T to a T?", "CreationDate": "2013-06-20T17:54:49.860", "Id": "17220498", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2013-06-22T03:02:35.557", "Score": "2", "OwnerUserId": "102441", "Tags": "<c++><casting><operator-overloading>", "AnswerCount": "3"}, "17220579": {"Id": "17220579", "PostTypeId": "2", "Body": "<h1>The short answer:</h1>\n<h2>Yes you can but the compiler won't do the job for you.</h2>\n<h3><strong>You cannot have an compiler-provided conversion from volatile T to T but a user-defined implicit conversion using a volatile-qualified constructor.</strong></h3>\n<p><hr>\n<em>It is also impossible to declare such a conversion by using explicitly-defaulted versions of the special member functions (see long answer for reference).</em></hr></p>\n<p>You'll have to provide a user-defined way of conversion to enable such assignments. You can either</p>\n<ul>\n<li>use a non-explicit copy constructor with a cv-qualified argument for implicit user-defined conversion or</li>\n<li>a copy assignment operator taking a v-qualified argument.</li>\n</ul>\n<p>Example:</p>\n<pre><code>X (X const volatile &amp; xo);\nX&amp; operator= (X const volatile &amp; xo);\n</code></pre>\n<p><hr/></p>\n<h1>The long answer with standard quotes 'n stuff or</h1>\n<h2>why doesn't the compiler do this for me?</h2>\n<h2>Way 1: User-provided constructor from volatile T</h2>\n<h3>Standard, ISO 14882:2011, 4/3</h3>\n<blockquote>\n<p id=\"so_17220498_17220579_0\">An expression <strong><code>e</code></strong> can be implicitly converted to a type T if and only if the declaration <strong><code>T t=e;</code></strong> is well-formed, for some invented temporary variable t (8.5).</p>\n</blockquote>\n<p>Since the declaration <code>T t = e;</code>, where in this case <code>e</code> is typed <code>volatile T</code>, requires such a copy-initialization to be valid, you'll need a copy constructor from a volatile T.</p>\n<p>I already answered (<a href=\"https://stackoverflow.com/questions/17217300/why-am-i-not-provided-with-a-default-copy-constructor-from-a-volatile/17218983#17218983\">Why am I not provided with a default copy constructor from a volatile?</a>).\nTherefore you'll need to provide a user-defined way of copy-initialization of T from volatile T.</p>\n<pre><code>X (X const volatile &amp; xo);\n</code></pre>\n<p><em>Note:</em> </p>\n<ul>\n<li>This is a declaration, you'll also have to provide a definition.</li>\n<li>The constructor must not be explicit.</li>\n<li>Providing an user-defined copy constructor taking a volatile argument will result in the abscence of an implicitly generated default assignment operator.</li>\n</ul>\n<p>This will make your assignment work.</p>\n<h2>Way 2: User-provided copy assignment operator from volatile T</h2>\n<p>Another way to make the assignment of your example code work is a copy assignment operator.</p>\n<p>Unfortunatelly, <strong>the standard also does say that a compiler will not provide implicit copy assignment operators for the conversion of volatile to non volatile objects.</strong></p>\n<h3>Standard, ISO 14882:2011, 12.8/18</h3>\n<blockquote>\n<p id=\"so_17220498_17220579_1\">If the class definition does not explicitly declare a copy assignment operator, one is declared implicitly. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy assignment operator is defined as deleted; otherwise, it is defined as defaulted (8.4). The latter case is deprecated if the class has a user-declared copy constructor or a user-declared destructor. The implicitly declared copy assignment operator for a class X will have the form</p>\n<p id=\"so_17220498_17220579_2\"><strong>X&amp; X::operator=(const X&amp;)</strong></p>\n<p id=\"so_17220498_17220579_3\">if</p>\n<ul>\n<li>each direct base class B of X has a copy assignment operator whose parameter is of type const B&amp;, const volatile B&amp; or B, and</li>\n<li>for all the non-static data members of X that are of a class type M (or array thereof), each such class type has a copy assignment operator whose parameter is of type const M&amp;, const volatile M&amp; or M. <strong><sup>122</sup></strong></li>\n</ul>\n<p id=\"so_17220498_17220579_4\">Otherwise, the implicitly-declared copy assignment operator will have the form</p>\n<p id=\"so_17220498_17220579_5\"><strong>X&amp; X::operator=(X&amp;)</strong></p>\n</blockquote>\n<h3>Note 122 on 12.8/18</h3>\n<blockquote>\n<p id=\"so_17220498_17220579_6\"><strong>the reference parameter of the implicitly-declared copy assignment operator cannot bind to a volatile lvalue; see <em>C.1.9</em>.</strong></p>\n</blockquote>\n<p>In the <a href=\"https://stackoverflow.com/questions/17217300/why-am-i-not-provided-with-a-default-copy-constructor-from-a-volatile/17218983#17218983\">other answer</a> I quoted C.1.9 where it says:</p>\n<blockquote>\n<p id=\"so_17220498_17220579_7\">The implicitly-declared copy constructor <strong>and implicitly-declared copy assignment operator</strong> cannot make a copy of a volatile lvalue. [ ... ]</p>\n</blockquote>\n<p>The result is that we'll have to provide a suitable copy assignment operator if we want to have one.</p>\n<pre><code>X&amp; operator= (X const volatile &amp; xo);\n</code></pre>\n<hr>\n<p><strong>Also note that you cannot declare an assignment/constructor from volatile explicitly-defaulted.</strong></p>\n<h3>C++11 Standard 8.4.2/1</h3>\n<blockquote>\n<p id=\"so_17220498_17220579_8\">A function that is explicitly defaulted shall</p>\n<ul>\n<li>be a special member function,</li>\n<li>have the same declared function type (except for possibly differing ref-qualifiers and except that in the case of a copy constructor or copy assignment operator, the parameter type may be \u201creference to non-const T\u201d, where T is the name of the member function\u2019s class) as if it had been implicitly declared, and</li>\n<li>not have default arguments.</li>\n</ul>\n</blockquote>\n<p>The following Note was removed from the final C++11 standard but was present in the Draft N3242. It still holds.</p>\n<blockquote>\n<p id=\"so_17220498_17220579_9\">[ Note: <strong>This implies that</strong> parameter types, return type, and <strong>cv-qualifiers must match the hypothetical implicit declaration.</strong> \u2014end note ]</p>\n</blockquote>\n<p>Since the hypothetical implicit declaration is non-volatile you cannot have the defaulted.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-06-22T03:02:35.557", "Score": "3", "CreationDate": "2013-06-20T17:59:16.927", "ParentId": "17220498", "CommentCount": "8", "OwnerUserId": "951423", "LastEditDate": "2017-05-23T11:50:01.573"}});