post_cb({"bq_ids": {"n4140": {"so_37064993_37065579_0": {"length": 48, "quality": 0.96, "section_id": 489}}, "n3337": {"so_37064993_37065579_0": {"length": 48, "quality": 0.96, "section_id": 480}}, "n4659": {"so_37064993_37064993_0": {"length": 48, "quality": 0.9411764705882353, "section_id": 464}}}, "37065579": {"Id": "37065579", "PostTypeId": "2", "Body": "<p>This appears to be a bug (reported as <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70972\" rel=\"nofollow\">bug 70972</a>). N4140 [class.inhctor]/8:</p>\n<blockquote>\n<p id=\"so_37064993_37065579_0\">An implicitly-defined inheriting constructor performs the set of\n  initializations of the class that would be performed by a user-written\n  inline constructor for that class with a <em>mem-initializer-list</em> whose\n  only <em>mem-initializer</em> has a <em>mem-initializer-id</em> that names the base\n  class denoted in the <em>nested-name-specifier</em> of the <em>using-declaration</em>\n  and an <em>expression-list</em> as specified below, and where the\n  <em>compound-statement</em> in its function body is empty (12.6.2). If that\n  user-written constructor would be ill-formed, the program is\n  ill-formed. Each <em>expression</em> in the <em>expression-list</em> is of the form\n  <code>static_cast&lt;T&amp;&amp;&gt;(p)</code>, where <code>p</code> is the name of the corresponding\n  constructor parameter and <code>T</code> is the declared type of <code>p</code>.</p>\n</blockquote>\n<p>In other words, the inheriting constructor at issue here should be moving, not copying, its parameter.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2016-05-06T06:32:17.227", "Score": "3", "CreationDate": "2016-05-06T06:17:39.760", "ParentId": "37064993", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2016-05-06T06:32:17.227"}, "37064993": {"ViewCount": "130", "Body": "<p>The following code doesn't compile <a href=\"http://coliru.stacked-crooked.com/a/e5281d63ac12d5c9\" rel=\"nofollow\"><code>GCC 6.1</code></a>, but works in <a href=\"http://coliru.stacked-crooked.com/a/65b46bd5b6b6a0bb\" rel=\"nofollow\"><code>Clang 3.8.0</code></a> and <a href=\"http://rextester.com\" rel=\"nofollow\"><code>Visual Studio 2015</code></a>:</p>\n<pre><code>#include &lt;memory&gt;\n\nclass base {\npublic:\n    base(std::unique_ptr&lt;int&gt;) {}\n};\n\nclass derived : public base {\npublic:\n    using base::base;\n};\n\nint main() {\n    derived df(std::make_unique&lt;int&gt;());\n}\n</code></pre>\n<p>With the following errors:</p>\n<pre><code>main.cpp: In constructor 'derived::derived(std::unique_ptr&lt;int&gt;)':\n\nmain.cpp:10:17: error: use of deleted function \n'std::unique_ptr&lt;_Tp, _Dp&gt;::unique_ptr(const std::unique_ptr&lt;_Tp, _Dp&gt;&amp;) \n[with _Tp = int; _Dp = std::default_delete&lt;int&gt;]'\n\n     using base::base;\n\n                 ^~~~\n\nIn file included from /usr/local/include/c++/6.1.0/memory:81:0,\n\n                 from main.cpp:1:\n\n/usr/local/include/c++/6.1.0/bits/unique_ptr.h:356:7: note: declared here\n\n       unique_ptr(const unique_ptr&amp;) = delete;\n\n       ^~~~~~~~~~\n\nmain.cpp: In function 'int main()':\n\nmain.cpp:14:39: note: synthesized method 'derived::derived(std::unique_ptr&lt;int&gt;)' \nfirst required here \n\n     derived df(std::make_unique&lt;int&gt;());\n</code></pre>\n<p>It appears to be trying to call the deleted copy constructor, but this works just fine:</p>\n<pre><code>void foo(std::unique_ptr&lt;int&gt;) {}\n\nint main() {\n    foo(std::make_unique&lt;int&gt;());\n}\n</code></pre>\n<p>And this example with <code>-fno-elide-constructors</code> prints out <code>move called.</code>:</p>\n<pre><code>struct move_only {\n    move_only() { std::cout &lt;&lt; \"default called.\"; }\n    move_only(move_only&amp;&amp;) { std::cout &lt;&lt; \"move called.\"; }\n};\n\nvoid foo(move_only) { }\n\nint main() {\n    foo(move_only{});\n}\n</code></pre>\n<p>I realize the two situations are not identical but it seems strange that <code>&amp;&amp;</code> is required to make the inherited constructor example compile but not the latter. As a sanity check, explicitly doing <code>move_only(const move_only&amp;) = delete;</code> and changing the signature to <code>void foo(const move_only&amp;) { }</code> still compiles, except this time the move constructor is not even called (elision perhaps).</p>\n<p><a href=\"http://eel.is/c++draft/class.inhctor.init#initialization!by~inherited~constructor\" rel=\"nofollow\">12.6.3</a> of the latest draft standard says:</p>\n<blockquote>\n<p id=\"so_37064993_37064993_0\">1 When a constructor for type <code>B</code> is invoked to initialize an object\n  of a different type <code>D</code> (that is, when the constructor was inherited\n  ([namespace.udecl])), initialization proceeds as if a defaulted\n  default constructor were used to initialize the D object and each base\n  class subobject from which the constructor was inherited, except that\n  the B subobject is initialized by the invocation of the inherited\n  constructor. The complete initialization is considered to be a single\n  function call; in particular, the initialization of the inherited\n  constructor's parameters is sequenced before the initialization of any\n  part of the <code>D</code> object. [ <em>Example:</em></p>\n<pre><code>struct B1 {\n  B1(int, ...) { }\n};\n\n// ...\n\nstruct D1 : B1 {\n  using B1::B1;  // inherits B1(int, ...)\n  int x;\n  // ...\n};\n\nvoid test() {\n  D1 d(2, 3, 4); // OK: B1 is initialized by calling B1(2, 3, 4),\n                 // then d.x is default-initialized (no initialization is performed),\n  // ...\n}\n\n// ...\n</code></pre>\n</blockquote>\n<p>So it should be exactly equivalent to <code>foo(move_only)</code> right? </p>\n", "Title": "Move only class parameter in inherited constructor", "CreationDate": "2016-05-06T05:34:44.793", "LastActivityDate": "2016-05-06T06:32:17.227", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "Id": "37064993", "Score": "4", "OwnerUserId": "6292850", "Tags": "<c++><gcc><c++14><move-semantics>", "AnswerCount": "1"}});