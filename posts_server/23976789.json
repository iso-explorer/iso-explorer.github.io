post_cb({"23976808": {"Id": "23976808", "PostTypeId": "2", "Body": "<p>In the standard (\u00a73.4/1)</p>\n<blockquote>\n<p id=\"so_23976789_23976808_0\">Name lookup shall\n  find an unambiguous declaration for the name (see 10.2). Name lookup may associate more than one declaration with a name if it finds the name to be a function name; the declarations are said to form a set\n  of overloaded functions (13.1). Overload resolution (13.3) takes place after name lookup has succeeded.\n  The access rules (Clause 11) are considered only once name lookup and function overload resolution (if\n  applicable) have succeeded.</p>\n</blockquote>\n<p>Which means the steps are as follows for methods:</p>\n<ol>\n<li>First collect all the matching names </li>\n<li>Do overload resolution</li>\n<li>Check for accessibility</li>\n</ol>\n<p>For method, name lookup does not return after finding <em>first match</em>, rather it searches for all matching names. It is clear from the statement <em>Name lookup may associate more than one declaration with a name if it finds the name to be a <strong>function name</strong></em></p>.\n", "LastActivityDate": "2014-06-01T04:39:10.423", "CommentCount": "8", "CreationDate": "2014-06-01T04:39:10.423", "ParentId": "23976789", "Score": "-1", "OwnerUserId": "1390091"}, "bq_ids": {"n4140": {"so_23976789_23976789_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 7087}, "so_23976789_23976808_0": {"length": 46, "quality": 0.92, "section_id": 7083}, "so_23976789_23976990_1": {"length": 21, "quality": 1.0, "section_id": 7100}, "so_23976789_23976822_0": {"length": 20, "quality": 1.0, "section_id": 7109}}, "n3337": {"so_23976789_23976789_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 6831}, "so_23976789_23976822_0": {"length": 20, "quality": 1.0, "section_id": 6853}, "so_23976789_23976990_1": {"length": 21, "quality": 1.0, "section_id": 6844}, "so_23976789_23976808_0": {"length": 46, "quality": 0.92, "section_id": 6827}}, "n4659": {"so_23976789_23976789_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 8588}, "so_23976789_23976822_0": {"length": 20, "quality": 1.0, "section_id": 8610}, "so_23976789_23976990_1": {"length": 21, "quality": 1.0, "section_id": 8601}, "so_23976789_23976808_0": {"length": 31, "quality": 0.62, "section_id": 8584}}}, "23976990": {"Id": "23976990", "PostTypeId": "2", "Body": "<p>You said</p>\n<blockquote>\n<p id=\"so_23976789_23976990_0\">It means that <code>int foo(char);</code> does not found by unqualified name look up but <code>int foo(int);</code> and <code>int foo()</code> can be found. So I assume that <strong>unqualified name look up for overloaded declaration ends as soon as all overloaded declarations is found for the name.</strong></p>\n</blockquote>\n<p>A similar question was asked in <a href=\"https://stackoverflow.com/questions/23941480/user-declared-namespace-member/23941748#23941748\">another SO post</a></p>\n<p>There is from 3.4.1/14:</p>\n<blockquote>\n<p id=\"so_23976789_23976990_1\">If a variable member of a namespace is defined outside of the scope of its namespace then any name that appears in the definition of the member (after the declarator-id) is looked up as if the definition of the member occurred in its namespace.</p>\n</blockquote>\n<p>Your posted code is equivalent to:</p>\n<pre><code>int foo(char a){ return 0; }\n\nnamespace A\n{\n    int foo(int a){ return a; }\n    int foo(){ return 2; }\n    extern int j;\n    extern int i;\n}\n\nnamespace A\n{\n  int j=foo('a');\n  int i=foo();\n}\n</code></pre>\n<p>When the definitions and initializations are put under the namespace, it becomes clear why functions used to initialize the variables are looked up in namespace <code>A</code> first. If an unambiguous match can be found for a function in namespace <code>A</code>, the search for it stops. That means, when compiling the line,</p>\n<pre><code>int A::j=foo('a');\n</code></pre>\n<p>The lookup for <code>foo</code> starts in namespace <code>A</code>, is resolved to <code>int A::foo(int);</code> and the search for <code>foo</code> stops.</p>\n<p>Hope this clears the confusion.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-01T05:20:12.497", "Score": "0", "CreationDate": "2014-06-01T05:20:12.497", "ParentId": "23976789", "CommentCount": "0", "OwnerUserId": "434551", "LastEditDate": "2017-05-23T11:49:25.410"}, "23976929": {"Id": "23976929", "PostTypeId": "2", "Body": "<p>You're mixing up <em>name lookup</em> with <em>overload resolution</em>. There is no such thing as \"unqualified name look up for overloaded declaration\". Name lookup and overload resolution are separate.</p>\n<p><em>Name lookup</em> means determining which scope the name is found in. Once that is completed, <em>overload resolution</em> determines which of the declarations visible in that scope should be used.</p>\n<p>In your code, <em>name lookup</em> determines that <code>foo</code> means <code>A::foo</code>. Then <em>overload resolution</em> selects between <code>A::foo()</code> and <code>A::foo(int)</code>.  The <code>::foo</code> is not considered for overload resolution because it is not a definition of <code>A::foo</code>.</p>\n<p>Another example:</p>\n<pre><code>namespace C { void f(); }\nnamespace B { void f(); void f(float); }\nnamespace C { void f(long); }\n\nusing namespace C;\n\nint main()\n{\n    f(1.0);\n}\n</code></pre>\n<p>When processing the line <code>f(1.0)</code>, <em>name lookup</em> sees <code>void f();</code> and stops. The result is that <code>f</code> means <code>C::f</code>.</p>\n<p>Then <em>overload resolution</em> kicks in, and all declarations of <code>C::f</code> are considered for overload resolution. <code>void f(long)</code> is chosen.</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2014-06-01T05:11:21.913", "Score": "2", "CreationDate": "2014-06-01T05:05:01.013", "ParentId": "23976789", "CommentCount": "0", "OwnerUserId": "1505939", "LastEditDate": "2014-06-01T05:11:21.913"}, "23976822": {"Id": "23976822", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_23976789_23976822_0\">In a declaration in which the <em>declarator-id</em> is a <em>qualified-id</em>, names used before the <em>qualified-id</em> being declared\n     are looked up in the defining namespace scope; names following the <em>qualified-id</em> are looked up in the scope\n        of the member\u2019s class or namespace.</p>\n</blockquote>\n<p>(C++11 \u00a73.4.3/3)</p>\n<p>So in both of</p>\n<pre><code>int A::j=foo('a');\nint A::i=foo();\n</code></pre>\n<p>the name <code>foo</code> is looked up in the scope of <code>A</code> just because you have <code>A::j</code> and <code>A::i</code> to the left, in the declarator.</p>\n<p>Note that if you do</p>\n<pre><code>int k = foo();\n</code></pre>\n<p>only the global <code>foo</code> will be found, and you'll get an error.</p>\n", "LastActivityDate": "2014-06-01T04:42:03.980", "CommentCount": "2", "CreationDate": "2014-06-01T04:42:03.980", "ParentId": "23976789", "Score": "1", "OwnerUserId": "481267"}, "23976789": {"ViewCount": "75", "Body": "<p>Here is an example which I'm trying to understand how does unqualified name look up work for overloaded declarations:</p>\n<pre><code>int foo(char a){ return 0; }\n\nnamespace A\n{\n    int foo(int a){ return a; }\n    int foo(){ return 2; }\n    extern int j;\n    extern int i;\n}\n\nint A::j=foo('a'); //97\nint A::i=foo(); //2\n</code></pre>\n<p>It means that <code>int foo(char);</code> does not found by unqualified name look up but <code>int foo(int);</code> and <code>int foo()</code> can be found. So I assume that <strong>unqualified name look up for overloaded declaration ends as soon as all overloaded declarations is found for the name.</strong> I can't find this into the standard, I can find only the following (sec. 3.4.1):</p>\n<blockquote>\n<p id=\"so_23976789_23976789_0\">name look up ends as soon as a declaration is found for the name.</p>\n</blockquote>\n<p>This quote doesn't say anything about overloaded declaration look up.</p>\n", "Title": "Why does unqualified name lookup find all overloaded declarations", "CreationDate": "2014-06-01T04:34:29.500", "LastActivityDate": "2014-06-01T06:36:18.427", "CommentCount": "1", "LastEditDate": "2014-06-01T06:36:18.427", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastEditorUserId": "661519", "Id": "23976789", "Score": "0", "Tags": "<c++><overloading><language-lawyer>", "AnswerCount": "4"}});