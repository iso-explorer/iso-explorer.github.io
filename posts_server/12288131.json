post_cb({"12288316": {"Id": "12288316", "PostTypeId": "2", "Body": "<p><code>t</code> <em>is</em> a local, named variable, and thus an lvalue. The comma operator behaves as documented.</p>\n<p>Rather, you should be asking why <code>return t;</code> allows <code>t</code> to bind to an rvalue reference - <em>that</em>'s the real magic.</p>\n", "LastActivityDate": "2012-09-05T19:19:40.120", "CommentCount": "0", "CreationDate": "2012-09-05T19:19:40.120", "ParentId": "12288131", "Score": "8", "OwnerUserId": "596781"}, "12288328": {"Id": "12288328", "PostTypeId": "2", "Body": "<p>Automatic move is based on eligibility for copy elision:</p>\n<p><code>\u00a712.8 [class.copy] p32</code></p>\n<blockquote>\n<p id=\"so_12288131_12288328_0\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. [...]</p>\n</blockquote>\n<p>And copy elision in turn is allowed when the return expressions is the <em>name of an automatic object</em>.</p>\n<p><code>\u00a712.8 [class.copy] p31</code></p>\n<blockquote>\n<p id=\"so_12288131_12288328_1\">in a <code>return</code> statement in a function with a class return type, <strong>when the expression is the name of a non-volatile automatic object</strong> (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value</p>\n</blockquote>\n<p>With the comma operator inserted, the expression is not the name of an automatic object anymore, but only a reference to one, which suppresses copy elision.</p>\n", "LastEditorUserId": "500104", "LastActivityDate": "2012-09-05T19:31:09.940", "Score": "14", "CreationDate": "2012-09-05T19:20:37.000", "ParentId": "12288131", "CommentCount": "0", "OwnerUserId": "500104", "LastEditDate": "2012-09-05T19:31:09.940"}, "bq_ids": {"n4140": {"so_12288131_12288328_0": {"length": 20, "quality": 0.6896551724137931, "section_id": 481}, "so_12288131_12288131_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 6182}, "so_12288131_12288328_1": {"length": 35, "quality": 1.0, "section_id": 480}}, "n3337": {"so_12288131_12288328_0": {"length": 29, "quality": 1.0, "section_id": 472}, "so_12288131_12288131_0": {"length": 16, "quality": 0.7619047619047619, "section_id": 5943}, "so_12288131_12288328_1": {"length": 35, "quality": 1.0, "section_id": 471}}, "n4659": {"so_12288131_12288328_0": {"length": 16, "quality": 0.5517241379310345, "section_id": 504}, "so_12288131_12288131_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 7684}, "so_12288131_12288328_1": {"length": 31, "quality": 0.8857142857142857, "section_id": 502}}}, "12288131": {"ViewCount": "347", "Body": "<p>This program:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct T {\n    T() {}\n    T(const T &amp;) { std::cout &lt;&lt; \"copy constructor \"; }\n    T(T &amp;&amp;) { std::cout &lt;&lt; \"move constructor \"; }\n};\nint main() {\n    ([](T t) -&gt; T { return t; })({}); std::cout &lt;&lt; '\\n';\n    ([](T t) -&gt; T { return void(), t; })({}); std::cout &lt;&lt; '\\n';\n    ([](T t) -&gt; T { return void(), std::move(t); })({}); std::cout &lt;&lt; '\\n';\n}\n</code></pre>\n<p>when compiled by gcc-4.7.1 outputs (<a href=\"http://liveworkspace.org/code/5ed5d0c99a4749d0b879721f3777c919\" rel=\"noreferrer\">link</a>):</p>\n<pre><code>move constructor \ncopy constructor \nmove constructor \n</code></pre>\n<p>Why does the comma operator have this effect? The standard says:</p>\n<blockquote>\n<h3>5.18 Comma operator [expr.comma]</h3>\n<p id=\"so_12288131_12288131_0\">1 - [...] The type\n  and value of the result are the type and value of the right operand; the result is of the same value category as its right operand [...]. If the value of the right operand is a temporary, the result is that temporary.</p>\n</blockquote>\n<p>Have I missed something that allows the comma operator to affect the semantics of the program, or is this a bug in gcc?</p>\n", "AcceptedAnswerId": "12288328", "Title": "Move constructor suppressed by comma operator", "CreationDate": "2012-09-05T19:05:52.133", "Id": "12288131", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2012-09-05T19:16:33.067", "LastEditorUserId": "46642", "LastActivityDate": "2012-09-05T19:31:09.940", "Score": "13", "OwnerUserId": "567292", "Tags": "<c++><c++11><return><move-semantics><comma-operator>", "AnswerCount": "2"}});