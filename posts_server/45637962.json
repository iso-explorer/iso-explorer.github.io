post_cb({"45642915": {"ParentId": "45637962", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2017-08-11T19:58:10.433", "Score": "1", "LastEditorUserId": "6651824", "LastEditDate": "2017-08-13T03:06:48.537", "Id": "45642915", "OwnerUserId": "6651824", "Body": "<p>Your code shows a basic spinlock mutex that lets each thread take the lock implicitly by recognizing its own value, rather than changing a state.  </p>\n<p>Memory ordering is correct and even stronger than it technically needs to be.\nThe <code>compare_exchange_strong</code> at the bottom is not necessary; a plain <code>store</code> with a release barrier would suffice:  </p>\n<pre><code>sync.store(i+1, std::memory_order_release);\n</code></pre>\n<p>Reordering of the relaxed operations is possible but does not change the output of your program. There is no undefined behavior and the same output is guaranteed on all platforms.<br>\nIn fact, <code>one</code>, <code>two</code> and <code>three</code> don't even have to be atomic because they are only accessed within your spinlock mutex and after all threads have joined.</br></p>\n<blockquote>\n<p id=\"so_45637962_45642915_0\">So if the first line of func() is load sync within a loop with memory_order_acquire, it should break the pair and make an unpredictable error on synchronization.</p>\n</blockquote>\n<p>Acquire/release pairing is correct since the release barrier at the bottom (in thread X) pairs with the acquire barrier at the top (in thread Y).\nThat the first thread acquires with no previous release is fine since there is nothing to release yet.  </p>\n<p>About the '<strong>Added</strong>' part:  </p>\n<blockquote>\n<p id=\"so_45637962_45642915_1\">How read-modify-write operation such as fetch_sub() participate in the release sequence?</p>\n</blockquote>\n<p>This is what standard says in 1.10.1-5:</p>\n<blockquote>\n<p id=\"so_45637962_45642915_2\">A release sequence headed by a release operation A on an atomic object M is a maximal contiguous subsequence of side effects in the modification order of M, where the first operation is A, and every subsequent operation:  </p>\n<ul>\n<li>is performed by the same thread that performed A, or</li>\n<li>is an atomic read-modify-write operation.</li>\n</ul>\n</blockquote>\n<p>So, in order to release data to another processor, a load/acquire operation needs to observe the value that was stored by the release operation or a later value as long as it satisfies one of these requirements.<br>\nApparently, read-modify-write operations have additional properties that prevent updates to the atomic variable from reaching other processors in a less-defined order.</br></p>\n<blockquote>\n<p id=\"so_45637962_45642915_3\">If I change it to load with memory_order_acquire, will store() still synchronizes-with load() in each independent thread?</p>\n</blockquote>\n<p>If you change the read-modify-write to a separate load/acquire (that sees the updated value) and a store/release, it is still correct, but it is no longer part of the same release sequence;\nyou have created a separate release sequence.</p>\n", "LastActivityDate": "2017-08-13T03:06:48.537"}, "45637962": {"CommentCount": "4", "ViewCount": "185", "PostTypeId": "1", "LastEditorUserId": "8397621", "CreationDate": "2017-08-11T14:43:29.277", "LastActivityDate": "2017-08-13T03:06:48.537", "Title": "C++ atomic increment with memory ordering", "AcceptedAnswerId": "45642915", "LastEditDate": "2017-08-12T01:53:54.057", "Id": "45637962", "Score": "1", "Body": "<p>After I have read C++ concurrency in action Chapter 5, I tried to write some code to test my understanding of memory ordering:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;thread&gt;\n#include &lt;atomic&gt;\n\nstd::atomic&lt;int&gt; one,two,three,sync;\n\nvoid func(int i){\n    while(i != sync.load(std::memory_order_acquire));\n    auto on = one.load(std::memory_order_relaxed); ++on;\n    auto tw = two.load(std::memory_order_relaxed); ++tw;\n    auto th = three.load(std::memory_order_relaxed); ++th;\n    std::cout &lt;&lt; on &lt;&lt; tw &lt;&lt; th &lt;&lt; std::endl;\n    one.store(on,std::memory_order_relaxed);\n    two.store(tw,std::memory_order_relaxed);\n    three.store(th,std::memory_order_relaxed);\n    int expected = i;\n    while(!sync.compare_exchange_strong(expected,i+1,\n            std::memory_order_acq_rel))\n        expected = i;\n}\n\nint main(){\n    std::vector&lt;std::thread&gt; t_vec;\n    for(auto i = 0; i != 5; ++i)\n        t_vec.push_back(std::thread(func,i));\n    for(auto i = 0; i != 5; ++i)\n        t_vec[i].join();\n    std::cout &lt;&lt; one &lt;&lt; std::endl;\n    std::cout &lt;&lt; two &lt;&lt; std::endl;\n    std::cout &lt;&lt; three &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>My question is: The book says memory_order_release and memory_order_acquire should be a pair to correctly read the right value.</p>\n<p>So if the first line of func() is load sync within a loop with memory_order_acquire, it should break the pair and make an unpredictable error on synchronization.</p>\n<p>However, as expected, it prints after being compiled on my x86 platform:</p>\n<pre><code>111\n222\n333\n444\n555\n5\n5\n5\n</code></pre>\n<p>The result shows no problem. So I just wonder what happens within func() (though I wrote it by myself...)?</p>\n<p><strong>Added</strong>: According to the code on C++ concurrency in action page 141:</p>\n<pre><code>#include &lt;atomic&gt;\n#include &lt;thread&gt;\n\nstd::vector&lt;int&gt; queue_code;\nstd::atomic&lt;int&gt; count;\n\nvoid populate_queue(){\n    unsigned const number_of_items = 20;\n    queue_data.clear();\n    for(unsigned i = 0; i &lt; number_of_items; ++i)\n        queue_data.push_back(i);\n    count.store(number_of_items, std::memory_order_release);\n}\n\nvoid consume_queue_items(){\n    while(true){\n        int item_index;\n        if((item_index=count.fetch_sub(1,memory_order_acquire))&lt;=0){\n            wait_for_more_items();\n            continue;\n        }\n        process(queue_data[item_index-1]);\n    }\n}\n\nint main(){\n    std::thread a(populate_queue);\n    std::thread b(consume_queue_items);\n    std::thread c(consume_queue_items);\n    a.join();\n    b.join();\n    c.join();\n}\n</code></pre>\n<p>Thread b and thread c will work just fine, no matter who access count first. Because:</p>\n<blockquote>\n<p id=\"so_45637962_45637962_0\">Thankfully, the first fetch_sub() does participate in the <strong>release</strong> <strong>sequence</strong>, and so the store() synchronizes-with the second fetch_sub(). There's still no synchronizes-with relationship between the two consumer threads\n  There can be any number of links in the chain, but provided they're all read-modify-write operation such as fetch_sub(), the store() will still synchronize-with each one that's tagged memory_order_acquire.In this example, all the links are the same, and all are acquire operations, but they could be a mix of different operations with different memory_ordering semantics.</p>\n</blockquote>\n<p>But I can't find related information about this, and How read-modify-write operation such as fetch_sub() participate in the release sequence? If I change it to load with memory_order_acquire, will store() still synchronizes-with load() in each independent thread?</p>\n", "Tags": "<c++><concurrency><atomic><memory-order>", "OwnerUserId": "8397621", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_45637962_45642915_2": {"section_id": 5820, "quality": 0.95, "length": 19}}, "n3337": {"so_45637962_45642915_2": {"section_id": 5591, "quality": 0.95, "length": 19}}, "n4659": {"so_45637962_45642915_2": {"section_id": 7281, "quality": 0.95, "length": 19}}}});