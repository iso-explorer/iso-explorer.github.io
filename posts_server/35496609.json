post_cb({"bq_ids": {"n4140": {"so_35496609_35497520_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 4706}, "so_35496609_35497520_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 5891}}, "n3337": {"so_35496609_35497520_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 5621}, "so_35496609_35497520_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 5662}}, "n4659": {"so_35496609_35497520_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 7330}, "so_35496609_35497520_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 7330}}}, "35496609": {"ViewCount": "101", "Body": "<p>I am reading  -- 3.4 Inheritance and the Data Member. It says \"the language guarantee of the integrity of the base class subobject within the derived class.\" Also it gives an example as follows:</p>\n<pre><code>class Concrete1\n{\nprivate:\n    int val;\n    char bit1;\n};\n\nclass Concrete2 : public Concrete1\n{\nprivate:\n    char bit2;\n};\n\nclass Concrete3 : public Concrete2\n{\nprivate:\n    char bit3;\n};\n</code></pre>\n<p>The Concrete1 object model is: </p>\n<pre><code>4 bytes for val, \n1 byte for bit1,\n3 bytes padding. \n// 8 bytes in total.\n</code></pre>\n<p>The Concrete2 object model is: </p>\n<pre><code>8 bytes for Concrete1 subobject, \n1 byte for bit2,\n3 bytes padding. \n// 12 bytes in total. \n</code></pre>\n<p>Similarly, the Concrete3 object model is 16 bytes. </p>\n<p>Concrete2 object member bit2 doesn't use the padding part of Concrete1 subobject, that's why it is 12 bytes. But when I tried the example in gcc 4.4.7, Concrete2 object and Concrete3 object are the same size as Concrete1 object -- 8 bytes. So I'm guessing gcc uses the padding part of Concrete1 object to store bit2 and bit3. I'm calling them \"not-use-padding\" way and \"use-padding\" way for short.  </p>\n<p>In order to explain why the padding part is not used, the book gives the following code:</p>\n<pre><code>Concrete2 *pc2; \nConcrete1 *pc1_1, *pc2_2; \npc1_1 = pc2;\n*pc1_1 = *pc2_2; // pc1_1 may point to a Concrete2 or Concrete3 object. \n</code></pre>\n<p>In \"not-use-padding\" way, the Concrete1 object pointed to by pc2_2 will be copied to the Concrete1 subobject of the Concrete2/Concrete3 object pointed to by pc1_1. The book also says it's a \"memberwise\" copy, but it looks more like an \"object\" copy because it implies the padding part is also copied. </p>\n<p>In \"use-padding\" way, the book says it will override the bit2 member because the corresponding byte of *pc2_2 is a padding byte. Again, I tried it with gcc 4.4.7, it turned out the bit2 member is not overridden. So I'm guessing the copy is a real \"memberwise\" copy, just val and bit1 are copied.  </p>\n<p>So my questions are:\n1. Am I correct about the gcc activities: \"use-padding\" way and real \"memberwise\" copy?\n2. The private members of a base class can't be accessed in derived class, but derived class object contains all the private members in its base class subobject (val and bit1) in object model. Why it is designed to contain base class private members even if they can not even be accessed in derived class object? Just for copy operations like *pc1_1 = *pc2_2; ?</p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "35497520", "Title": "C++ object model by gcc 4.4.7: base class subobject padding occupied in derived class object", "CreationDate": "2016-02-19T03:08:51.143", "Id": "35496609", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-02-19T04:48:09.740", "Score": "2", "OwnerUserId": "1070525", "Tags": "<c++><object><inheritance><gcc><padding>", "AnswerCount": "1"}, "35497520": {"Id": "35497520", "PostTypeId": "2", "Body": "<p>About your first question:</p>\n<p>I tried to reproduce the behaviour you described as \"use-padding\" at ideone.com with different compilers but failed. Clang, gcc 4.3 and gcc 5.1 seemed to not use the padding of the base class. But from the answers to <a href=\"https://stackoverflow.com/questions/25226347/gcc-clang-lay-out-fields-of-a-derived-struct-in-the-back-padding-of-base-struct\">this Question</a> one can read that gcc indeed makes use of this padding.</p>\n<p>The Standard introduces the concept of <a href=\"http://en.cppreference.com/w/cpp/concept/PODType\" rel=\"nofollow noreferrer\">POD-types</a>, but it states explicitly</p>\n<blockquote>\n<p id=\"so_35496609_35497520_0\"><strong>9 Classes</strong> [class]<br>\n   (...)<br>\n   7 A class S is a standard-layout class if it:\n  (...)<br>\n  (7.6)\n  has all non-static data members and bit-fields in the class and its base classes first declared in the same class (...)</br></br></br></p>\n</blockquote>\n<p>So this does not apply to your class, since you have data members in both base and derived classes. I couldn't find any references about how non-POD-types need to be layouted. One of the answers in the linked question states, that this has been subject of change.</p>\n<p>What is important about inheritance is, that - using pointers or references - you can use a derived object as if it were an object of the base class. That means you can use a <code>Concrete3*</code> just as if it were a <code>Concrete1*</code>. But this is independent wheter you use the padding or not, as long as you don't change the layout of <code>Concrete1</code> when adding the data members of <code>Concrete2</code> and <code>Concrete3</code>.</p>\n<hr>\n<p>About your second question:</p>\n<p>The standard states this: </p>\n<blockquote>\n<p id=\"so_35496609_35497520_1\"><strong>11 Member access control</strong> [class.access]<br>\n  1 A member of a class can be </br></p>\n<ul>\n<li>(1.1) private; that is, its name can be used only by members and friends of the class in which it is declared.</li>\n<li>(1.2) protected; that is, its name can be used only by members and friends of the class in which it is declared, by classes derived from that class, and by their friends (see 11.4).</li>\n<li>(1.3) public; that is, its name can be used anywhere without access restriction.</li>\n</ul>\n</blockquote>\n<p>As you can see, it only specifies where the name can be used. E.g. you can still return references or pointers to private members. This implies that they have to be present in the memory somewhere. In fact the state of an object is defined by the state of its members - private or public is just a matter of where in your code you are allowed to directly access them.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-02-19T04:48:09.740", "Score": "0", "CreationDate": "2016-02-19T04:48:09.740", "ParentId": "35496609", "CommentCount": "0", "OwnerUserId": "3193464", "LastEditDate": "2017-05-23T10:28:33.457"}});