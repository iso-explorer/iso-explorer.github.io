post_cb({"bq_ids": {"n4140": {"so_32013915_32014392_0": {"length": 54, "quality": 0.9818181818181818, "section_id": 6038}}, "n3337": {"so_32013915_32014392_0": {"length": 53, "quality": 0.9636363636363636, "section_id": 5806}}, "n4659": {"so_32013915_32014392_0": {"length": 47, "quality": 0.8545454545454545, "section_id": 7537}}}, "32014392": {"Id": "32014392", "PostTypeId": "2", "Body": "<p>From [expr.static.cast]:</p>\n<blockquote>\n<p id=\"so_32013915_32014392_0\">A prvalue of type \u201cpointer to member of <code>D</code> of type <em>cv1</em> <code>T</code>\u201d can be converted to a prvalue of type \u201cpointer to\n  member of <code>B</code>\u201d of type <em>cv2</em> <code>T</code>, where <code>B</code> is a base class (Clause 10) of <code>D</code>, if a valid standard conversion from\n  \u201cpointer to member of <code>B</code> of type <code>T</code>\u201d to \u201cpointer to member of <code>D</code> of type <code>T</code>\u201d exists (4.11), and <em>cv2</em> is the same\n  <em>cv</em>-qualification as, or greater <em>cv</em>-qualification than, <em>cv1</em>. [...] If class <code>B</code> contains the original member, or is a\n  base or derived class of the class containing the original member, the resulting pointer to member points to\n  the original member. <strong>Otherwise, the behavior is undefined.</strong></p>\n</blockquote>\n<p>In our case, <code>&amp;Base::reactToB</code> can be converted to <code>&amp;Child::reactToB</code>, but since <code>Base</code> does <em>not</em> contain the original member, the behavior is undefined. </p>\n<p>You'd have to store something like a <code>std::function&lt;void(Base*)&gt;</code> or <code>void(*)(Base*)</code>.</p>\n<p>If the former, you could add a member function to <code>Base</code> like:</p>\n<pre><code>template &lt;typename C&gt;\nvoid addMethod(std::string const&amp; name, void (C::*method)()) {\n    methods[name] = [method](Base* b){\n        (static_cast&lt;C*&gt;(b)-&gt;*method)();\n    };\n}\n\naddMethod(\"B\", &amp;Child::reactToB);\n</code></pre>\n<p>If the latter, you could do something like:</p>\n<pre><code>methods[ \"B\" ] = +[](Base* b){ \n   static_cast&lt;Child*&gt;(b)-&gt;reactToB();\n};\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-08-14T16:31:20.850", "Score": "4", "CreationDate": "2015-08-14T16:13:00.153", "ParentId": "32013915", "CommentCount": "4", "OwnerUserId": "2069064", "LastEditDate": "2015-08-14T16:31:20.850"}, "32013915": {"ViewCount": "262", "Body": "<p>Let's say I want to create a hierarchy that reacts to certain event encoded in string. For example commands coming from network. Idea is that there is a <code>Base</code> class that handling network connection, receiving buffer, splitting it etc and handling of commands reaction is in derived class (derived class can also add some new words to be handled). So my solution is:</p>\n<pre><code>class Base {\npublic:\n    typedef void (Base::*Method)();\n    typedef std::unordered_map&lt;std::string, Method&gt; Methods;\n\n    void reactToA();\n    void reactToB();\n\n    Base() :\n       methods{ \n          { \"A\", &amp;Base::reactToA },\n          { \"B\", &amp;Base::reactToB }\n       }\n    {\n    }\n    void action( const std::string &amp;s )\n    {\n        auto f = methods.find( s );\n        if( f != methods.end() )\n           (*this.*)(f-&gt;second)();\n    }\n\nprotected:\n    Methods methods;\n};\n\nclass Child : public Base {\npublic:\n    void reactToB();\n    void reactToC();\n\n    Child() {\n        methods[ \"B\" ] = static_cast&lt;Method&gt;( &amp;Child::reactToB );\n        methods[ \"C\" ] = static_cast&lt;Method&gt;( &amp;Child::reactToC );\n    }\n};\n</code></pre>\n<p>So I have to cast pointer to <code>Child</code> method to pointer to <code>Base</code> method. Is that cast well defined? Is there more elegant (or correct, if this leads to UB) solution?</p>\n", "AcceptedAnswerId": "32014392", "Title": "Casting pointer form derived class method to base class", "CreationDate": "2015-08-14T15:45:31.407", "Id": "32013915", "CommentCount": "9", "LastEditDate": "2015-08-14T16:27:54.577", "PostTypeId": "1", "LastEditorUserId": "432358", "LastActivityDate": "2015-08-14T16:34:38.077", "Score": "1", "OwnerUserId": "432358", "Tags": "<c++><pointer-to-member>", "AnswerCount": "2"}, "32014776": {"Id": "32014776", "PostTypeId": "2", "Body": "<p>With just a tiny bit of overhead of the generic function pointer <code>std::function</code>, you can have fully defined behavior and much more flexibility since you can call pretty much anything, not only methods:</p>\n<pre><code>class Base { \npublic:\n  typedef std::function&lt;void()&gt; Callable;\n  typedef std::unordered_map&lt;std::string, Callable&gt; Callables;\n  void action(const std::string &amp;s) {\n    auto f = callables.find(s);\n    if (f != callables.end()) f-&gt;second();\n  }\nprotected:\n  Callables callables;\n};\n\nclass Derived1 : public Base {\n  void reactToA() {}\n  void reactToB() {}\npublic:\n  Derived1() {\n    callables[\"A\"] = std::bind(&amp;Derived1::reactToA, *this);\n    callables[\"B\"] = std::bind(&amp;Derived1::reactToB, *this);\n  }\n};\n\nstatic void reactToE();    \n\nclass Derived2 : public Derived {\n  void reactToB() {}\n  void reactToC() {}\npublic:\n  Derived2() {\n    callables[\"B\"] = std::bind(&amp;Derived2::reactToB, *this);\n    callables[\"C\"] = std::bind(&amp;Derived2::reactToC, *this);\n    callables[\"D\"] = []{ std::cout &lt;&lt; \"Hey, what, D now?!\" &lt;&lt; std::endl; }\n    callables[\"E\"] = &amp;reactToE;\n  }\n};\n</code></pre>\n", "LastActivityDate": "2015-08-14T16:34:38.077", "CommentCount": "0", "CreationDate": "2015-08-14T16:34:38.077", "ParentId": "32013915", "Score": "2", "OwnerUserId": "1329652"}});