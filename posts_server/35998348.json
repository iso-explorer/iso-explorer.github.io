post_cb({"36012670": {"ParentId": "35998348", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2016-03-15T13:27:10.650", "Score": "3", "LastEditorUserId": "3747990", "LastEditDate": "2016-05-10T06:21:53.803", "Id": "36012670", "OwnerUserId": "3747990", "Body": "<p>Yes, the code is valid.</p>\n<p>This certainly does appear to be MSVC bug. I am able to reproduce this with a simple code sample;</p>\n<p>func.cpp</p>\n<pre><code>#include &lt;functional&gt;\nenum Code : int;\nCode func2();\nvoid func()\n{\n    std::function&lt;Code()&gt; f2 { func2 };\n}\n</code></pre>\n<p>main.cpp</p>\n<pre><code>enum Code : int {\n    Some = 0,\n    Error = 1,\n};\nCode func2() { return Some; }\nint main() {}\n</code></pre>\n<p>The error remains;</p>\n<blockquote>\n<p id=\"so_35998348_36012670_0\">error LNK2019: unresolved external symbol \"enum Code __cdecl std::_Invoke_ret(struct std::_Forced,enum Code (__cdecl*&amp;)(void))\" (??$_Invoke_ret@W4Code@@AEAP6A?AW41@XZ@std@@YA?AW4Code@@U?$_Forced@W4Code@@$0A@@0@AEAP6A?AW41@XZ@Z) referenced in function \"private: virtual enum Code __cdecl std::_Func_impl,enum Code&gt;::_Do_call(void)\" (?_Do_call@?$_Func_impl@P6A?AW4Code@@XZV?$allocator@H@std@@W41@$$V@std@@EEAA?AW4Code@@XZ)</p>\n</blockquote>\n<p>The error hints at an instantiation issue with <code>std::function&lt;Code()&gt;</code>, but no amount of explicit instantiation in either translation unit offers any resolution.</p>\n<p>The error also does not seem dependent on the un-scoped <code>enum</code> vs. the scoped <code>enum class</code>.</p>\n<p><em>The only work around at this time appears</em> to be not using an opaque enum declaration at all, but to supply the full enum with its enumerators.</p>\n<hr>\n<p>From Microsoft Connect (2016-05-09);</p>\n<blockquote>\n<p id=\"so_35998348_36012670_1\">A fix for this issue has been checked into the compiler sources. The fix should show up in the future release of Visual C++.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2016-05-10T06:21:53.803"}, "bq_ids": {"n4140": {"so_35998348_35998348_0": {"section_id": 5462, "quality": 0.8571428571428571, "length": 24}}, "n3337": {"so_35998348_35998348_0": {"section_id": 5249, "quality": 0.8571428571428571, "length": 24}}, "n4659": {"so_35998348_35998348_0": {"section_id": 6896, "quality": 0.8571428571428571, "length": 24}}}, "36015776": {"ParentId": "35998348", "CommentCount": "0", "CreationDate": "2016-03-15T15:38:20.740", "OwnerUserId": "420683", "PostTypeId": "2", "Id": "36015776", "Score": "1", "Body": "<p>Here are some more observations too large for a comment:</p>\n<p>This is indeed a compiler bug, not a bug of the Standard Library implementation. The following program reproduces the same issue on VS2015 Update 1 without using the StdLib:</p>\n<pre><code>template&lt;class T&gt;\nT create() {\n    return {};\n}\n\nenum class Code;\n\nint main() {\n    create&lt;Code&gt;();\n}\n</code></pre>\n<p>The linker complains about an unresolved symbol:</p>\n<p><code>enum Code __cdecl create&lt;enum Code&gt;(void)</code></p>\n<ul>\n<li>The linker issue disappears if you leave out the return value (replace <code>T</code> with <code>void</code>).</li>\n<li>The problem remains when explicitly specifying the underlying type.</li>\n<li>The problem remains if we replace the scoped enumeration with an unscoped enumeration. We do not have to specify the underlying type when using Microsoft's C++ extensions (<code>/Ze</code>). Nothing changes when specifying the underlying type.</li>\n</ul>\n", "LastActivityDate": "2016-03-15T15:38:20.740"}, "35998348": {"CommentCount": "11", "ViewCount": "206", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-03-14T21:22:51.900", "LastActivityDate": "2016-05-10T06:21:53.803", "Title": "Is It Valid To Return Forward Declared Enum Class? (Visual Studio 2015 Linker Error)", "AcceptedAnswerId": "36012670", "LastEditDate": "2017-05-23T12:19:14.517", "Id": "35998348", "Score": "3", "Body": "<p>I have an issue where the following code compiles on GCC (4.8+ tested) and Clang (3.4+ tested) but does not compile on Visual Studio 2015 (VC++ 14.0).</p>\n<p>Foo.h:</p>\n<pre><code>#include &lt;functional&gt;\n\nnamespace Error {\nenum class Code;\nstatic const Code None = static_cast&lt;Code&gt;(0);\n}\n\nclass Foo{\npublic:\n  std::function&lt;Error::Code()&gt; Run();\n};\n</code></pre>\n<p>Foo.cpp</p>\n<pre><code>#include \"Foo.h\"\n#include &lt;iostream&gt;\n\nstd::function&lt;Error::Code()&gt; Foo::Run() {\n  return [&amp;]() {\n    std::cout &lt;&lt; \"hello\\n\"; \n    return Error::None;\n  };\n}\n</code></pre>\n<p>main.cpp:</p>\n<pre><code>#include \"Foo.h\"\n\nnamespace Error {\nenum class Code {\n  None = 0,\n  Error = 1,\n};\n}\n\nint main() {\n  Foo foo;\n  foo.Run()();\n}\n</code></pre>\n<p>The resulting error in VC++ 14.0 is as follows:</p>\n<pre><code>Foo.obj : error LNK2001: unresolved external symbol \"enum Error::Code __cdecl std::_Invoke_ret&lt;enum Error::Code,class &lt;lambda_813e82254384ef384f6a5fe34e885f01&gt; &amp;&gt;(struct std::_Forced&lt;enum Error::Code,0&gt;,class &lt;lambda_813e82254384ef384f6a5fe34e885f01&gt; &amp;)\" (??$_Invoke_ret@W4Code@Error@@AAV&lt;lambda_813e82254384ef384f6a5fe34e885f01&gt;@@@std@@YA?AW4Code@Error@@U?$_Forced@W4Code@Error@@$0A@@0@AAV&lt;lambda_813e82254384ef384f6a5fe34e885f01&gt;@@@Z)\n</code></pre>\n<p>Which I believe is an internal std library function for implementng <code>std::function</code>.</p>\n<p>This code is similar to usage of an internal library I'm trying to use that shares a standard program interface for tools, but forward declares Error Codes so they can be customized.  I believe this should be valid code based on \u00a77.2 (see <a href=\"https://stackoverflow.com/questions/8911188/can-i-pass-value-of-forward-declared-enum\">this answer</a>)  The enum, though forward declared, should be a complete type and usable as a return value.  Here is the relevant bit in the standard:</p>\n<blockquote>\n<p id=\"so_35998348_35998348_0\">An opaque-enum-declaration is either a redeclaration of an enumeration in the current scope or a declaration of a new enumeration. [Note: An enumeration declared by an opaque-enum-declaration has fixed underlying type and is a complete type. The list of enumerators can be provided in a later redeclaration with an enum-specifier. \u2014end note ]</p>\n</blockquote>\n<p>Is this code valid?  If so, is there a work around to get VC++ to accept it?</p>\n", "Tags": "<c++><visual-studio-2015><language-lawyer><c++14>", "OwnerUserId": "1843316", "AnswerCount": "3"}, "36004186": {"ParentId": "35998348", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-03-15T06:32:33.630", "Score": "-2", "LastEditorUserId": "5689324", "LastEditDate": "2016-03-21T02:42:42.183", "Id": "36004186", "OwnerUserId": "5689324", "Body": "<p>I think you should declare <strong>None</strong> in header (.h) and define it in source file(.cpp)</p>\n<p>Foo.h</p>\n<pre><code>namespace Error {\n    extern const Code None;\n}\n</code></pre>\n<p>Foo.cpp</p>\n<pre><code>namespace Error {\n    const Code None = static_cast&lt;Code&gt;(0);\n}\n</code></pre>\n<p>Sometimes enum will be optimized and will have no instance or address, especially you declare it as a <strong>static</strong> variable.</p>\n", "LastActivityDate": "2016-03-21T02:42:42.183"}});