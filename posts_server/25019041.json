post_cb({"25019677": {"ParentId": "25019041", "CommentCount": "4", "CreationDate": "2014-07-29T15:55:03.543", "OwnerUserId": "3074786", "PostTypeId": "2", "Id": "25019677", "Score": "1", "Body": "<pre><code>A *a = new(5, 5) A[10]; \nA::operator delete[](a,5,5);\n</code></pre>\n<p>On Visual C++ 2013 this works great</p>\n", "LastActivityDate": "2014-07-29T15:55:03.543"}, "25019041": {"CommentCount": "3", "ViewCount": "677", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastEditorDisplayName": "user2953119", "CreationDate": "2014-07-29T15:23:22.893", "LastActivityDate": "2014-07-29T16:30:20.153", "LastEditDate": "2014-07-29T15:28:51.327", "AcceptedAnswerId": "25019598", "FavoriteCount": "1", "Title": "Placement deallocation function is not called", "Id": "25019041", "Score": "8", "Body": "<p>The following code I write must invoke both placement deallocation and allocation functions.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct A\n{\n    void * operator new [] (size_t t, int, int)\n    {\n        cout &lt;&lt; \"3 parameters allocation\" &lt;&lt; endl;\n        return ::operator new[](t);\n    }\n\n    void operator delete [] (void *p, int, int)\n    {\n        cout &lt;&lt; \"3 parameters deallocation\" &lt;&lt; endl;\n        return ::operator delete[](p);\n    }\n};\n\nint main() \n{\n    A *a = new (5,5) A[10]; //operator new [] (size_t, int, int) invoked\n    delete [] a; //Error. Overload resolution is failed.\n}\n</code></pre>\n<p><a href=\"http://ideone.com/gLJu0d\">demo</a></p>\n<p>5.3.4/22 says N3797:</p>\n<blockquote>\n<p id=\"so_25019041_25019041_0\">A declaration of a placement deallocation function matches the\n  declaration of a placement allocation function if it has the same\n  number of parameters and, after parameter transformations (8.3.5), all\n  parameter types except the first are identical. If the lookup finds a\n  single matching deallocation function, that function will be called;\n  otherwise, no deallocation function will be called.</p>\n</blockquote>\n<p>It is not implement in <code>C++11</code> or it is my misunderstanding?</p>\n", "Tags": "<c++><c++11><memory-management>", "AnswerCount": "3"}, "25019598": {"ParentId": "25019041", "CommentCount": "1", "CreationDate": "2014-07-29T15:50:54.317", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "25019598", "Score": "9", "Body": "<p>If a class-specific deallocation function is provided, a <em>delete-expression</em> that is not prefixed by the scope resolution operator is ill-formed unless a class-specific deallocation function with one or two parameters is available:</p>\n<blockquote>\n<p id=\"so_25019041_25019598_0\">10 - If the type is complete and if deallocation function lookup finds both a usual deallocation function with only a pointer parameter and a usual deallocation function with both a pointer parameter and a size parameter, then the selected deallocation function shall be the one with two parameters. Otherwise, <strong>the selected deallocation function shall be the function with one parameter</strong>.</p>\n</blockquote>\n<p>So you need to either:</p>\n<ul>\n<li>provide <code>void operator delete[](void*);</code>,</li>\n<li>provide <code>void operator delete[](void*, size_t);</code>, or</li>\n<li>write <code>::delete[] a</code>.</li>\n</ul>\n", "LastActivityDate": "2014-07-29T15:50:54.317"}, "bq_ids": {"n4140": {"so_25019041_25019598_0": {"section_id": 6114, "quality": 1.0, "length": 34}, "so_25019041_25019041_0": {"section_id": 6103, "quality": 0.9722222222222222, "length": 35}}, "n3337": {"so_25019041_25019598_0": {"section_id": 6925, "quality": 0.5294117647058824, "length": 18}, "so_25019041_25019041_0": {"section_id": 5869, "quality": 0.9722222222222222, "length": 35}}, "n4659": {"so_25019041_25019041_0": {"section_id": 7600, "quality": 0.9722222222222222, "length": 35}}}, "25020370": {"ParentId": "25019041", "CommentCount": "0", "CreationDate": "2014-07-29T16:30:20.153", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "25020370", "Score": "1", "Body": "<p>If you want to have access to the original placement new parameters in your <code>operator delete</code>, you will have to store them in the allocated memory block and retrieve them later. For example (<a href=\"http://ideone.com/s6JP2o\" rel=\"nofollow\">Live at Ideone</a>):</p>\n<pre><code>struct A\n{\n    static void * operator new [] (size_t t, int first, int second);\n    static void operator delete [] (void *p, size_t t);\n    static void operator delete [] (void *p, int first, int second)\n    {\n        cout &lt;&lt; \"3 parameters deallocation: \" &lt;&lt; first &lt;&lt; \", \" &lt;&lt; second &lt;&lt; endl;\n        return ::operator delete[](p);\n    }\n};\n\n// simple POD struct to store the placement parameters\nstruct info {\n    int first_param, second_param;\n};\n\nvoid* A::operator new [] (size_t t, int first, int second)\n{\n    cout &lt;&lt; \"3 parameters allocation: \" &lt;&lt; first &lt;&lt; \", \" &lt;&lt; second &lt;&lt; endl;\n    // allocate sizeof(info) extra space to store the parameters\n    auto const p = ::operator new[](t + sizeof(info));\n    auto const pinfo = reinterpret_cast&lt;char*&gt;(p) + t;\n    auto const tmp = info{first, second};\n    std::copy_n(reinterpret_cast&lt;const char*&gt;(&amp;tmp), sizeof(info), pinfo);\n    return p;\n}\n\nstatic void A::operator delete [] (void *p, std::size_t t) {\n    // retrieve the parameters that we stored in operator new [].\n    auto const pinfo = reinterpret_cast&lt;const char*&gt;(p) + t;\n    auto tmp = info{};\n    std::copy_n(pinfo, sizeof(info), reinterpret_cast&lt;char*&gt;(&amp;tmp));\n    cout &lt;&lt; \"Deleting with original parameters: \" &lt;&lt; tmp.first_param &lt;&lt; \", \" &lt;&lt; tmp.second_param &lt;&lt; endl;\n    ::operator delete[](p);\n}\n</code></pre>\n", "LastActivityDate": "2014-07-29T16:30:20.153"}});