post_cb({"36997351": {"CommentCount": "1", "AcceptedAnswerId": "36999861", "PostTypeId": "1", "LastEditorUserId": "73657", "CreationDate": "2016-05-03T06:39:54.610", "LastActivityDate": "2016-05-03T09:01:01.007", "LastEditDate": "2016-05-03T07:04:22.073", "ViewCount": "191", "FavoriteCount": "3", "Title": "Using a template before it's specialized?", "Id": "36997351", "Score": "14", "Body": "<p>I found out that you can specialize a template <strong>after</strong> it's first use if you use it using a wrapper template. Simple example:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nconst char* templateImpl();\n\ntemplate&lt;typename T&gt;\nconst char* templateGetter() { return templateImpl&lt;T&gt;(); }\n\nstruct S{};\n\nint main(){ std::cout &lt;&lt; templateGetter&lt;S&gt;() &lt;&lt; std::endl; return 0; }\n\ntemplate&lt;&gt;\nconst char* templateImpl&lt;S&gt;(){ return \"S\"; }\n</code></pre>\n<p>This works with every compiler - I'm not surprised MSVC compiles it since it handles templates differently, but GCC and clang allow it too. I thought the standard required the specialization to occur before the first use, which in this case would mean before main and expected them to report an error.</p>\n<p>Did I miss something, is this code standard compliant?</p>\n<p>To clarify, if I change <code>templateGetter&lt;S&gt;</code> to <code>templateImpl&lt;S&gt;</code> in main, the program won't compile with the error message I would expect from this too: </p>\n<blockquote>\n<p id=\"so_36997351_36997351_0\">main.cpp:14:29: error: specialization of 'const char* templateImpl()\n  [with T = S]' after instantiation</p>\n</blockquote>\n", "Tags": "<c++><templates>", "OwnerUserId": "73657", "AnswerCount": "2"}, "36999861": {"ParentId": "36997351", "CommentCount": "3", "CreationDate": "2016-05-03T09:01:01.007", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "36999861", "Score": "10", "Body": "<p>You got (un)lucky. This is ill-formed NDR.</p>\n<p><a href=\"http://eel.is/c++draft/temp.expl.spec#6\">[temp.expl.spec]/6-7</a>:</p>\n<blockquote>\n<p id=\"so_36997351_36999861_0\"><sup>6</sup> If a template, a member template or a member of a class template is\n  explicitly specialized <strong>then that specialization shall be declared\n  before the first use of that specialization that would cause an\n  implicit instantiation to take place, in every translation unit in\n  which such a use occurs</strong>; no diagnostic is required. [...]</p>\n<p id=\"so_36997351_36999861_1\"><sup>7</sup> The placement of explicit specialization declarations for function templates, class templates, variable templates, member functions of class templates, static data members of class templates, member classes of class templates, member enumerations of class templates, member class templates of class templates, member function templates of class templates, static data member templates of class templates, member functions of member templates of class templates, member functions of member templates of non-template classes, static data member templates of non-template classes, member function templates of member classes of class templates, etc., and the placement of partial specialization declarations of class templates, variable templates, member class templates of non-template classes, static data member templates of non-template classes, member class templates of class templates, etc., can affect whether a program is well-formed according to the relative positioning of the explicit specialization declarations and their points of instantiation in the translation unit as specified above and below. When writing a specialization, be careful about its location; or to make it compile will be such a trial as to kindle its self-immolation.</p>\n</blockquote>\n<p><sub> p7 isn't really useful here, but I can't resist quoting it :) </sub></p>\n<p>Instantiating <code>templateGetter&lt;S&gt;</code> causes the implicit instantiation of a declaration of <code>templateImpl&lt;S&gt;</code>. You didn't see an error with your code because many implementations like to defer template instantiations until the end of the translation unit when possible, which is a permitted implementation technique. (I'm not going to quote the standardese here, but you'll find that function template specializations have an extra point of instantiation at the end of the translation unit.)</p>\n<p>Giving <code>templateGetter</code> a deduced return type will force early instantiation of its body:</p>\n<pre><code>template&lt;typename T&gt;\nauto templateGetter() { return templateImpl&lt;T&gt;(); }\n</code></pre>\n<p>and <a href=\"http://coliru.stacked-crooked.com/a/201849bafc69dd91\">voila</a>:</p>\n<pre><code>+ g++ -std=c++14 -O2 -Wall -pedantic -pthread main.cpp\nmain.cpp:14:29: error: specialization of 'const char* templateImpl() [with T = S]' after instantiation\n const char* templateImpl&lt;S&gt;(){ return \"S\"; }\n                             ^\n+ clang++ -std=c++14 -O2 -Wall -pedantic -pthread main.cpp\nmain.cpp:14:13: error: explicit specialization of 'templateImpl&lt;S&gt;' after instantiation\nconst char* templateImpl&lt;S&gt;(){ return \"S\"; }\n            ^\nmain.cpp:7:32: note: implicit instantiation first required here\nauto templateGetter() { return templateImpl&lt;T&gt;(); }\n                               ^\n1 error generated.\n</code></pre>\n", "LastActivityDate": "2016-05-03T09:01:01.007"}, "36999343": {"ParentId": "36997351", "CommentCount": "1", "CreationDate": "2016-05-03T08:35:20.523", "OwnerUserId": "6284503", "PostTypeId": "2", "Id": "36999343", "Score": "1", "Body": "<p>I think it's legal. Quoting N4140, [temp.point]:</p>\n<blockquote>\n<p id=\"so_36997351_36999343_0\">For a function template specialization, ... if the specialization is\n  implicitly instantiated because it is referenced from within another\n  template specialization and the context from which it is referenced\n  depends on a template parameter, the point of instantiation of the\n  specialization is the point of instantiation of the enclosing\n  specialization. Otherwise, the point of instantiation for such a\n  specialization immediately follows the namespace scope declaration or\n  definition that refers to the specialization.</p>\n</blockquote>\n<p>Then in [temp.fct.spec]:</p>\n<blockquote>\n<p id=\"so_36997351_36999343_1\">A function instantiated from a function template is called a function\n  template specialization; so is an explicit specialization of a\n  function template. ...</p>\n</blockquote>\n<p>In other words, the error won't actually occur until <code>templateGetter()</code> and subsequently the specialization of <code>templateImpl</code> are instantiated, which is how you would expect templates to work.</p>\n", "LastActivityDate": "2016-05-03T08:35:20.523"}, "bq_ids": {"n4140": {"so_36997351_36999343_1": {"section_id": 282, "quality": 1.0, "length": 12}, "so_36997351_36999343_0": {"section_id": 216, "quality": 0.9736842105263158, "length": 37}, "so_36997351_36999861_0": {"section_id": 268, "quality": 1.0, "length": 29}, "so_36997351_36999861_1": {"section_id": 269, "quality": 0.9921875, "length": 127}}, "n3337": {"so_36997351_36999343_1": {"section_id": 273, "quality": 1.0, "length": 12}, "so_36997351_36999343_0": {"section_id": 210, "quality": 0.9736842105263158, "length": 37}, "so_36997351_36999861_0": {"section_id": 259, "quality": 1.0, "length": 29}, "so_36997351_36999861_1": {"section_id": 260, "quality": 0.8203125, "length": 105}}, "n4659": {"so_36997351_36999343_1": {"section_id": 289, "quality": 1.0, "length": 12}, "so_36997351_36999343_0": {"section_id": 224, "quality": 0.9736842105263158, "length": 37}, "so_36997351_36999861_0": {"section_id": 275, "quality": 1.0, "length": 29}, "so_36997351_36999861_1": {"section_id": 276, "quality": 0.9921875, "length": 127}}}});