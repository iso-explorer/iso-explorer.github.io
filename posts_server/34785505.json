post_cb({"bq_ids": {"n4140": {"so_34785505_34786621_2": {"length": 36, "quality": 0.9473684210526315, "section_id": 6171}, "so_34785505_34786621_3": {"length": 14, "quality": 1.0, "section_id": 6172}, "so_34785505_34786621_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 6170}, "so_34785505_34786621_0": {"length": 42, "quality": 0.9333333333333333, "section_id": 6169}}, "n3337": {"so_34785505_34786621_2": {"length": 36, "quality": 0.9473684210526315, "section_id": 5932}, "so_34785505_34786621_3": {"length": 14, "quality": 1.0, "section_id": 5933}, "so_34785505_34786621_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 5931}, "so_34785505_34786621_0": {"length": 42, "quality": 0.9333333333333333, "section_id": 5930}}, "n4659": {"so_34785505_34786621_2": {"length": 36, "quality": 0.9473684210526315, "section_id": 7669}, "so_34785505_34786621_3": {"length": 14, "quality": 1.0, "section_id": 7670}, "so_34785505_34786621_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 7668}, "so_34785505_34786621_0": {"length": 35, "quality": 0.7777777777777778, "section_id": 7667}}}, "34786621": {"Id": "34786621", "PostTypeId": "2", "Body": "<p>Martin Bonner explains why the address could be the same even for a copy of the string.</p>\n<p>To explain, why the <code>message and toPrint seem to refer to the same instance as I would expect.</code> is misguided, I shall quote the standard.</p>\n<p>Let's first explore what conversion is needed (I suppose it's not the question here, but just for completeness). Ignore the first <em>otherwise</em>. It refers to the case of <code>void</code> type expressions.</p>\n<blockquote>\n<p id=\"so_34785505_34786621_0\">[expr.cond]/3 Otherwise, if the second and third operand have different types and either has (possibly cv-qualified) class type, or if both are glvalues of the same value category and the same type except for cv-qualification, an attempt is made to convert each of those operands to the type of the other. The process for determining whether an operand expression <code>E1</code> of type <code>T1</code> can be converted to match an operand expression <code>E2</code> of type <code>T2</code> is de\ufb01ned as follows:</p>\n<ul>\n<li>If <code>E2</code> is an lvalue: <code>E1</code> can be converted to match <code>E2</code> if <code>E1</code> can be implicitly converted to the type \"lvalue reference to <code>T2</code>\", subject to the constraint that in the conversion the reference must bind directly to an lvalue. <strong>(cannot bind lvalue reference of type <code>std::string</code> to a strig literal)</strong></li>\n<li>If <code>E2</code> is an xvalue: <code>E1</code> can be converted to match <code>E2</code> if <code>E1</code> can be implicitly converted to the type \"rvalue reference to <code>T2</code>\", subject to the constraint that the reference must bind directly. <strong>(no xvalues here)</strong></li>\n<li>If <code>E2</code> is an rvalue or if neither of the conversions above can be done and at least one of the operands has (possibly cv-qualified) class type:\n  \n  <ul>\n<li>if <code>E1</code> and <code>E2</code> have class type, and the underlying class types are the same or one is a base class of the other: <code>E1</code> can be converted to match <code>E2</code> if the class of <code>T2</code> is the same type as, or a base class of, the class of <code>T1</code>, and the cv-qualification of <code>T2</code> is the same cv-qualification as, or a greater cv-qualification than, the cv-qualification of <code>T1</code>. If the conversion is applied, <code>E1</code> is changed to a prvalue of type <code>T2</code> by copy-initializing a temporary of type <code>T2</code> from <code>E1</code> and using that temporary as the converted operand. <strong>(string literal has no class type)</strong></li>\n<li>Otherwise (i.e., if <code>E1</code> or <code>E2</code> has a nonclass type, or if they both have class types but the underlying classes are not either the same or one a base class of the other): <code>E1</code> can be converted to match <code>E2</code> if <code>E1</code> can be implicitly converted to the type that expression <code>E2</code> would have if <code>E2</code> were converted to a prvalue (or the type it has, if <code>E2</code> is a prvalue). <strong>(this applies)</strong></li>\n</ul></li>\n</ul>\n</blockquote>\n<p>The final bullet covers this case. The string literal has a nonclass type and it can be converted to match a <code>std::string</code> prvalue. </p>\n<p>Now, let's explore how the conversion affects the result.</p>\n<blockquote>\n<p id=\"so_34785505_34786621_1\">4 If the second and third operands are glvalues of the same value category and have the same type <strong>(they are not)</strong>, the result\n  is of that type and value category and it is a bit-field if the second or the third operand is a bit-field, or if\n  both are bit-fields.</p>\n<p id=\"so_34785505_34786621_2\">5 Otherwise, the result is a prvalue. If the second and third operands do not have the same type, and either has (possibly cv-qualified) class type, overload resolution is used to determine the conversions (if any) to be applied to the operands (13.3.1.2, 13.6). If the overload resolution fails, the program is ill-formed. Otherwise, the conversions thus determined are applied, and the converted operands are used in place of the original operands for the remainder of this section.</p>\n</blockquote>\n<p>So, the result is a prvalue! It's not a lvalue reference. How do you get a prvalue from an lvalue?</p>\n<blockquote>\n<p id=\"so_34785505_34786621_3\">6 Lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the second and third operands. After those conversions, one of the following shall hold:</p>\n<ul>\n<li>The second and third operands have the same type; the result is of that type. If the operands have\n  class type  <strong>(they do after the conversion)</strong>, the result is a <strong>prvalue temporary</strong> of the result type, which is copy-initialized from either\n  the second operand or the third operand depending on the value of the first operand.</li>\n</ul>\n</blockquote>\n<p>So, we know that the result will be copy-initialized from the operand expression. Even though, we assign a reference, and the operand of the conditional is an lvalue reference to the same type, the reference will be bound to a temporary, copied from the operand.</p>\n<p>If you had used another lvalue reference to <code>const std::string</code> as the third operand, then you would have simply assigned the to the lvalue, rather than to a temporary prvalue.</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2016-01-14T10:08:53.727", "Score": "4", "CreationDate": "2016-01-14T10:03:40.880", "ParentId": "34785505", "CommentCount": "0", "OwnerUserId": "2079303", "LastEditDate": "2016-01-14T10:08:53.727"}, "34785505": {"ViewCount": "180", "Body": "<p>Can someone with a deeper understanding of the C++ standard than me please elaborate on this?</p>\n<p>This is my example program</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char* argv[]) {\n    const std::string message(\"hello world\");\n    std::cout &lt;&lt; std::hex &lt;&lt; (void*)message.c_str() &lt;&lt; std::endl;\n    const std::string&amp; toPrint = (argc &gt; 0) ? message : \"\";\n    std::cout &lt;&lt; std::hex &lt;&lt; (void*)toPrint.c_str() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>On one machine it does this:</p>\n<pre><code># g++ --version &amp;&amp; g++ str_test.cpp &amp;&amp; ./a.out                  \ng++ (Debian 4.7.2-5) 4.7.2\nCopyright (C) 2012 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n0x9851014\n0x9851014\n</code></pre>\n<p><code>message</code> and <code>toPrint</code> seem to refer to the same instance as I would expect. However, on another machine, this happens:</p>\n<pre><code># g++ --version &amp;&amp; g++ str_test.cpp &amp;&amp; ./a.out \ng++ (Ubuntu 5.2.1-22ubuntu2) 5.2.1 20151010\nCopyright (C) 2015 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n0x7ffeb9ab4ac0\n0x7ffeb9ab4ae0\n</code></pre>\n<p>Here it looks like the compiler constructed a copy of <code>message</code> for <code>toPrint</code> to point at.</p>\n<p>What behavior is correct according to the C++ standard? Or is it undefined in general?</p>\n", "AcceptedAnswerId": "34786621", "Title": "Conditional assignment of references", "CreationDate": "2016-01-14T09:11:37.213", "Id": "34785505", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-01-14T10:08:53.727", "Score": "4", "OwnerUserId": "990968", "Tags": "<c++><gcc>", "AnswerCount": "2"}, "34785879": {"Id": "34785879", "PostTypeId": "2", "Body": "<p>You are being confused by GLIBCs copy-on-write string sharing.  Change your test program to:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char* argv[]) {\n    const std::string message(\"hello world\");\n    std::cout &lt;&lt; std::hex &lt;&lt; (void*)&amp;message &lt;&lt; std::endl;\n    const std::string&amp; toPrint = (argc &gt; 0) ? message : \"\";\n    std::cout &lt;&lt; std::hex &lt;&lt; (void*)&amp;toPrint &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>(in other words print the address of the string object, not the address of the contained text), and both platforms will return different addresses.</p>\n<p>The latest standard has forbidden copy-on-write (although I don't understand how exactly).  Prior to that it was legal, but not mandatory.  (Current thinking is that 'small string optimization' does better than cow - particularly in a multithreaded world).</p>\n", "LastActivityDate": "2016-01-14T09:29:07.010", "CommentCount": "5", "CreationDate": "2016-01-14T09:29:07.010", "ParentId": "34785505", "Score": "6", "OwnerUserId": "771073"}});