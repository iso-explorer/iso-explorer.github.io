post_cb({"bq_ids": {"n4140": {"so_9364720_9364985_3": {"length": 8, "quality": 1.0, "section_id": 7043}, "so_9364720_9364799_3": {"length": 6, "quality": 1.0, "section_id": 7043}, "so_9364720_9364985_2": {"length": 46, "quality": 0.8846153846153846, "section_id": 7043}, "so_9364720_9364985_6": {"length": 23, "quality": 0.92, "section_id": 7043}, "so_9364720_9364799_1": {"length": 29, "quality": 0.8529411764705882, "section_id": 7041}, "so_9364720_9364799_2": {"length": 57, "quality": 0.8769230769230769, "section_id": 7043}, "so_9364720_9364985_5": {"length": 29, "quality": 0.9666666666666667, "section_id": 7043}, "so_9364720_9364985_1": {"length": 6, "quality": 1.0, "section_id": 7043}, "so_9364720_9364799_0": {"length": 14, "quality": 1.0, "section_id": 7038}, "so_9364720_9364985_4": {"length": 22, "quality": 0.9565217391304348, "section_id": 7043}, "so_9364720_9364985_0": {"length": 58, "quality": 0.8923076923076924, "section_id": 7043}}, "n3337": {"so_9364720_9364799_1": {"length": 29, "quality": 0.8529411764705882, "section_id": 6786}, "so_9364720_9364985_3": {"length": 8, "quality": 1.0, "section_id": 6788}, "so_9364720_9364985_1": {"length": 6, "quality": 1.0, "section_id": 6788}, "so_9364720_9364985_2": {"length": 49, "quality": 0.9423076923076923, "section_id": 6788}, "so_9364720_9364985_5": {"length": 29, "quality": 0.9666666666666667, "section_id": 6788}, "so_9364720_9364985_0": {"length": 58, "quality": 0.8923076923076924, "section_id": 6788}, "so_9364720_9364799_2": {"length": 57, "quality": 0.8769230769230769, "section_id": 6788}, "so_9364720_9364985_4": {"length": 22, "quality": 0.9565217391304348, "section_id": 6788}, "so_9364720_9364799_3": {"length": 6, "quality": 1.0, "section_id": 6788}, "so_9364720_9364799_0": {"length": 14, "quality": 1.0, "section_id": 6784}, "so_9364720_9364985_6": {"length": 23, "quality": 0.92, "section_id": 6788}}, "n4659": {"so_9364720_9364799_3": {"length": 6, "quality": 1.0, "section_id": 8540}, "so_9364720_9364799_2": {"length": 57, "quality": 0.8769230769230769, "section_id": 8540}, "so_9364720_9364985_5": {"length": 27, "quality": 0.9, "section_id": 8540}, "so_9364720_9364799_1": {"length": 29, "quality": 0.8529411764705882, "section_id": 8538}, "so_9364720_9364985_2": {"length": 43, "quality": 0.8269230769230769, "section_id": 8540}, "so_9364720_9364985_4": {"length": 22, "quality": 0.9565217391304348, "section_id": 8540}, "so_9364720_9364985_1": {"length": 6, "quality": 1.0, "section_id": 8540}, "so_9364720_9364799_0": {"length": 14, "quality": 1.0, "section_id": 8535}, "so_9364720_9364985_0": {"length": 58, "quality": 0.8923076923076924, "section_id": 8540}, "so_9364720_9364985_6": {"length": 19, "quality": 0.76, "section_id": 8540}, "so_9364720_9364985_3": {"length": 8, "quality": 1.0, "section_id": 8540}}}, "9364720": {"ViewCount": "1164", "Body": "<p>Consider the following example:  </p>\n<pre class=\"lang-c prettyprint-override\"><code>// usedclass1.hpp  \n#include &lt;iostream&gt;  \nclass UsedClass\n{  \npublic:\n  UsedClass() { }  \n  void doit() { std::cout &lt;&lt; \"UsedClass 1 (\" &lt;&lt; this &lt;&lt; \") doit hit\" &lt;&lt; std::endl; }\n};  \n\n// usedclass2.hpp  \n#include &lt;iostream&gt;\nclass UsedClass\n{\npublic:\n  UsedClass() { }\n  void doit() { std::cout &lt;&lt; \"UsedClass 2 (\" &lt;&lt; this &lt;&lt; \") doit hit\" &lt;&lt; std::endl; }\n};\n\n// object.hpp\nclass Object\n{\npublic:\n  Object();\n};\n\n// object.cpp\n#include \"object.hpp\"\n#include \"usedclass2.hpp\"\nObject::Object()\n{\n  UsedClass b;\n  b.doit();\n}\n\n// main.cpp\n#include \"usedclass1.hpp\"\n#include \"object.hpp\"\nint main()\n{\n  Object obj;\n  UsedClass a;\n  a.doit();\n}\n</code></pre>\n<p>The code compiles without any compiler or linker errors. But the output is strange for me:</p>\n<ul>\n<li><p>gcc (Red Hat 4.6.1-9) on Fedora x86_64 with no optimization [<strong>EG1</strong>]:</p>\n<blockquote>\n<p id=\"so_9364720_9364720_0\">UsedClass 1 (0x7fff0be4a6ff) doit hit<br>\n  UsedClass 1 (0x7fff0be4a72e) doit hit  </br></p>\n</blockquote></li>\n<li><p>same as [EG1] but with -O2 option enabled [<strong>EG2</strong>]:</p>\n<blockquote>\n<p id=\"so_9364720_9364720_1\">UsedClass 2 (0x7fffcef79fcf) doit hit<br>\n  UsedClass 1 (0x7fffcef79fff) doit hit</br></p>\n</blockquote></li>\n<li><p>msvc2005 (14.00.50727.762) on Windows XP 32bit with no optimization [<strong>EG3</strong>]:</p>\n<blockquote>\n<p id=\"so_9364720_9364720_2\">UsedClass 1 (0012FF5B) doit hit<br>\n  UsedClass 1 (0012FF67) doit hit</br></p>\n</blockquote></li>\n<li><p>same as [EG3] but with /O2 (or /Ox) enabled [<strong>EG4</strong>]:</p>\n<blockquote>\n<p id=\"so_9364720_9364720_3\">UsedClass 1 (0012FF73) doit hit<br>\n  UsedClass 1 (0012FF7F) doit hit</br></p>\n</blockquote></li>\n</ul>\n<p>I would expect either a linker error (assuming ODR rule is violated) or the output as in [EG2] (code is inlined, nothing is exported from the translation unit, ODR rule is held). Thus my questions:</p>\n<ol>\n<li>Why are outputs [EG1], [EG3], [EG4] possible? </li>\n<li>Why do I get different results from different compilers or even from the same compiler? That makes me think that the standard somehow doesn't specify the behaviour in this case.</li>\n</ol>\n<p>Thank you for any suggestions, comments and standard interpretations.</p>\n<p><strong>Update</strong><br>\nI would like to understand the compiler's behaviour. More precisely, why there are no errors generated if the ODR is violated. A hypothesis is that since all functions in classes <em>UsedClass1</em> and <em>UsedClass2</em> are marked as inline (and therefore C++03 3.2 is <strong>not</strong> violated) the linker doesn't report errors, but in this case outputs [EG1], [EG3], [EG4] seem strange.</br></p>\n", "Title": "C++: Different classes with the same name in different translation units", "CreationDate": "2012-02-20T16:35:23.490", "LastActivityDate": "2016-05-14T04:30:08.027", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-02-20T16:58:06.477", "LastEditorUserId": "1221434", "Id": "9364720", "Score": "6", "OwnerUserId": "1221434", "Tags": "<c++><one-definition-rule>", "AnswerCount": "3"}, "9364884": {"Id": "9364884", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_9364720_9364884_0\">Why are outputs [EG1], [EG3], [EG4] possible? </p>\n</blockquote>\n<p>The simple answer is that the behaviour is undefined, so anything is possible.</p>\n<p>Most compilers handle an inline function by generating a copy in each translation unit in which it's defined; the linker then arbitrarily chooses one to include in the final program. This is why, with optimisations disabled, it calls the same function in both cases. With optimisations enabled, the function might be inlined by the compiler, in which case each inlined call will use the version defined in the current translation unit.</p>\n<blockquote>\n<p id=\"so_9364720_9364884_1\">That makes me think that the standard somehow doesn't specify the behaviour in this case.</p>\n</blockquote>\n<p>That's correct. Breaking the one definition rule gives undefined behaviour, and no diagnostic is required.</p>\n", "LastActivityDate": "2012-02-20T16:45:29.833", "Score": "4", "CreationDate": "2012-02-20T16:45:29.833", "ParentId": "9364720", "CommentCount": "1", "OwnerUserId": "204847"}, "9364985": {"Id": "9364985", "PostTypeId": "2", "Body": "<p>This is the rule that prohibits what you're doing (the C++11 wording), from section 3.2 of the Standard:</p>\n<blockquote>\n<p id=\"so_9364720_9364985_0\"><strong>There can be more than one definition of a class type</strong> (Clause 9), enumeration type (7.2), <strong>inline function with external linkage</strong> (7.1.2), class template (Clause 14), non-static function template (14.5.6), static data member of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for which some template parameters are not speci\ufb01ed (14.7, 14.5.5) <strong>in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named <code>D</code> defined in more than one translation unit, then</strong></p>\n<ul>\n<li><p id=\"so_9364720_9364985_1\"><strong>each definition of <code>D</code> shall consist of the same sequence of tokens</strong>; and</p></li>\n<li><p id=\"so_9364720_9364985_2\">in each definition of <code>D</code>, corresponding names, looked up according to 3.4, shall refer to an entity defined within the definition of <code>D</code>, or shall refer to the same entity, after overload resolution (13.3) and after matching of partial template specialization (14.8.3), except that a name can refer to a <code>const</code> object with internal or no linkage if the object has the same literal type in all definitions of <code>D</code>, and the object is initialized with a constant expression (5.19), and the value (but not the address) of the object is used, and the object has the same value in all definitions of <code>D</code>; and </p></li>\n<li><p id=\"so_9364720_9364985_3\">in each definition of <code>D</code>, corresponding entities shall have the same language linkage; and</p></li>\n<li><p id=\"so_9364720_9364985_4\">in each definition of <code>D</code>, the overloaded operators referred to, the implicit calls to conversion functions, constructors, operator new functions and operator delete functions, shall refer to the same function, or to a function defined within the de\ufb01nition of D; and</p></li>\n<li><p id=\"so_9364720_9364985_5\">in each definition of <code>D</code>, a default argument used by an (implicit or explicit) function call is treated as if its token sequence were present in the de\ufb01nition of <code>D</code>; that is, the default argument is subject to the three requirements described above (and, if the default argument has sub-expressions with default arguments, this requirement applies recursively).</p></li>\n<li><p id=\"so_9364720_9364985_6\">if <code>D</code> is a class with an implicitly-declared constructor (12.1), it is as if the constructor was implicitly defined in every translation unit where it is odr-used, and the implicit de\ufb01nition in every translation unit shall call the same constructor for a base class or a class member of <code>D</code>.</p></li>\n</ul>\n</blockquote>\n<p>In your program, you're violating the ODR for <code>class UsedClass</code> because the tokens are different in different compilation units.  You could fix that by moving the definition of <code>UsedClass::doit()</code> outside the class body, but the same rule applies to the body of inline functions.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2012-02-20T16:56:36.910", "Score": "12", "CreationDate": "2012-02-20T16:51:14.200", "ParentId": "9364720", "CommentCount": "0", "LastEditDate": "2012-02-20T16:56:36.910", "OwnerUserId": "103167"}, "9364799": {"Id": "9364799", "PostTypeId": "2", "Body": "<p>Your program violates the One Definition Rule and invokes an Undefined Behavior.<br>\nThe standard does not mandate an diagnostic message if you break the ODR but the behavior is Undefined.</br></p>\n<p><strong>C++03 3.2 One definition rule</strong></p>\n<blockquote>\n<p id=\"so_9364720_9364799_0\">No translation unit shall contain more than one definition of any variable, function, class type, enumeration type or template.\n  ...</p>\n<p id=\"so_9364720_9364799_1\">Every program shall contain exactly one definition of every non-inline function or object that is used in that program; no diagnostic required. The definition can appear explicitly in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8). An inline function shall be defined in every translation unit in which it is used.</p>\n</blockquote>\n<p>Further the standard defines specific requirements for existence of multiple definitions of an symbol, those are aptly defined in Para #5 of 3.2.   </p>\n<blockquote>\n<p id=\"so_9364720_9364799_2\">There can be more than one definition of a class type (clause 9), enumeration type (7.2), inline function with external linkage (7.1.2), class template (clause 14), non-static function template (14.5.5), static data member of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for which some template parameters are not specified (14.7, 14.5.4) in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one translation unit, then</p>\n<p id=\"so_9364720_9364799_3\">\u2014 <strong>each definition of D shall consist of the same sequence of tokens;</strong> and\n  ...</p>\n</blockquote>\n", "LastEditorUserId": "3777958", "LastActivityDate": "2016-05-14T04:30:08.027", "Score": "7", "CreationDate": "2012-02-20T16:40:10.790", "ParentId": "9364720", "CommentCount": "5", "LastEditDate": "2016-05-14T04:30:08.027", "OwnerUserId": "452307"}});