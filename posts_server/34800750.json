post_cb({"34801237": {"ParentId": "34800750", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As suggested by immbis in the comment, this is defined by the standard:  </p>\n<blockquote>\n<p id=\"so_34800750_34801237_0\"><strong>3.4.2: Argument dependent name lookup</strong></p>\n<ol>\n<li><p id=\"so_34800750_34801237_1\">When the postfix-expression in a function call is an unqualified-id, other namespaces not considered during the usual\n  unqualified lookup may be searched, and in those namespaces,\n  namespace-scope friend function or function template declarations not\n  otherwise visible may be found. These modifications to the search\n  depend on the types of the arguments (and for template template\n  arguments, the namespace of the template argument). </p>\n<p id=\"so_34800750_34801237_2\">...</p></li>\n</ol>\n</blockquote>\n<p>If you want to defeat this mecanism, you have to use nested namespace like this, but it's tricky:  </p>\n<pre><code>namespace Test\n{\n    struct Magic\n    {\n        int poof;\n    };\n    struct Magic2\n    {\n        int poof;\n    };\n\n    namespace Test2 {   // use a nested namespace that will not be searched autoamtically \n        int Alakazam(const Magic&amp; m)\n        {\n            return m.poof;\n        }\n\n        int Alakazam(const Magic2&amp; m)\n        {\n            return m.poof;\n        }\n    } \n    using namespace Test2;  // but give some access to the enclosing namespace \n};\n</code></pre>\n<p><a href=\"http://ideone.com/KzYioP\" rel=\"nofollow\">Live Demo</a> :  Then, your two first calls will not be valid any longer.  However, the last call in your example is still possible:  you can't prevent the use of fully qualified names outside of the namespace.  </p>\n", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "LastEditDate": "2016-01-14T23:08:18.830", "Id": "34801237", "Score": "2", "CreationDate": "2016-01-14T22:48:22.507", "LastActivityDate": "2016-01-14T23:08:18.830"}, "bq_ids": {"n4140": {"so_34800750_34801237_1": {"section_id": 7103, "quality": 0.972972972972973, "length": 36}}, "n3337": {"so_34800750_34801237_1": {"section_id": 6847, "quality": 0.918918918918919, "length": 34}}, "n4659": {"so_34800750_34801237_1": {"section_id": 8604, "quality": 0.972972972972973, "length": 36}}}, "34800750": {"CommentCount": "5", "ViewCount": "33", "PostTypeId": "1", "LastEditorUserId": "3723423", "CreationDate": "2016-01-14T22:10:26.177", "LastActivityDate": "2016-01-14T23:08:53.287", "Title": "Namespace set as Used because of One Type Inside being Used?", "AcceptedAnswerId": "34801237", "LastEditDate": "2016-01-14T23:08:53.287", "Id": "34800750", "Score": "2", "Body": "<p>I just noticed this. I don't know why this is the case, if i use one element from a namespace i don't want anything else to be accessible without having to use the namespace. For example here, this code is valid:</p>\n<pre><code>namespace Test\n{\n    struct Magic\n    {\n        int poof;\n    };\n\n    struct Magic2\n    {\n        int poof;\n    };\n\n    int Alakazam(const Magic&amp; m)\n    {\n        return m.poof;\n    }\n\n    int Alakazam(const Magic2&amp; m)\n    {\n        return m.poof;\n    }\n};\n\nusing Magic = Test::Magic;\n\nint main()\n{\n\n    Alakazam(Magic());        // valid\n    Alakazam(Test::Magic2()); // valid\n\n    Test::Alakazam(Magic()); // what i want to only be valid\n    Test::Alakazam(Test::Magic2()); // this too\n}\n</code></pre>\n<p>Any reasoning behind this? Does the spec state that this has to be true?</p>\n", "Tags": "<c++><namespaces>", "OwnerUserId": "3901459", "AnswerCount": "1"}});