post_cb({"7915101": {"ParentId": "7914972", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2011-10-27T11:16:32.703", "Score": "7", "LastEditorUserId": "60281", "LastEditDate": "2011-10-27T14:36:58.883", "Id": "7915101", "OwnerUserId": "60281", "Body": "<p>Aside from what others already pointed out: Taking the title of your question in isolation - \"Create C++ integer class to act absolutely identical to integral integer type\" - I should point out a completely different reason why it is <strong>impossible</strong>.</p>\n<p>It is (to my knowledge) <em>not possible</em> to emulate the shortcut behaviour of the <strong>||</strong> and <strong>&amp;&amp;</strong> operators with classes, i.e. both sides of the operand will be evaluated no matter what.</p>\n<blockquote>\n<p id=\"so_7914972_7915101_0\"><strong>Edit:</strong> <em>Check out the comments. \"To my knowledge\" appears to not have been enough. However, Steve Jessop has a different example that makes the overall point stand valid.</em></p>\n</blockquote>\n<p>This is completely unrelated to your increment question, but topical to your question title, so I thought it should be mentioned.</p>\n", "LastActivityDate": "2011-10-27T14:36:58.883"}, "7915049": {"ParentId": "7914972", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_7914972_7915049_0\">The correct answer is ((2 + 2) + 1) + 1 = 6, i.e. post-increment is applied twice before assignment, but after addition.</p>\n</blockquote>\n<p>That is not the correct answer:</p>\n<blockquote>\n<p id=\"so_7914972_7915049_1\">Except where noted, the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified. Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be accessed only to determine the value to be stored. The requirements of this paragraph shall be met for each allowable ordering of the subexpressions of a full\n  expression; otherwise the behavior is undefined.<br>- <strong>ISO-IEC-14882</strong></br></p>\n</blockquote>\n", "OwnerUserId": "721269", "PostTypeId": "2", "Id": "7915049", "Score": "4", "CreationDate": "2011-10-27T11:11:30.003", "LastActivityDate": "2011-10-27T11:11:30.003"}, "7915003": {"ParentId": "7914972", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2011-10-27T11:07:56.847", "Score": "14", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:26:06.337", "Id": "7915003", "OwnerUserId": "500104", "Body": "<blockquote>\n<p id=\"so_7914972_7915003_0\">The initial interview question was: \"What will be the output of the following code?\"</p>\n</blockquote>\n<pre><code>int i = 2;\ni = i++ + i++;\n</code></pre>\n<p>The correct answer is <strong><a href=\"https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points/4176333#4176333\">undefined behaviour</a></strong>, because you're modifying the same variable multiple times without a sequence point in between.</p>\n<p>C++03 Standard <code>\u00a75 [expr] p4</code>:</p>\n<blockquote>\n<p id=\"so_7914972_7915003_1\">Except where noted, the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified.</p>\n</blockquote>\n<p>This may not answer your real question, but it will be similar even if you make an integer-like class and overload the <code>operator++(int)</code> and <code>operator+(A const&amp;)</code>. The order of evaluation of arguments to a function is unspecified, it may be done in any order the compiler likes, thus the result is unspecified.</p>\n", "LastActivityDate": "2011-10-27T11:49:53.267"}, "7915044": {"ParentId": "7914972", "CommentCount": "0", "Body": "<p>Actually, you made a pretty bad error early on.</p>\n<blockquote>\n<p id=\"so_7914972_7915044_0\">The initial interview question was: \"What will be the output of the following code?\"</p>\n</blockquote>\n<pre><code>int i = 2;\ni = i++ + i++;\n</code></pre>\n<p>The correct answer to this question is \"The output is undefined.\"</p>\n<p>By modifying and reading a variable without an interceding sequence point, you are invoking undefined behavior.</p>\n<hr>\n<p>More specifically, in this case what bites you in the ass is that the order in which parameters to the <code>+</code> operator are evaluated are undefined; and this is true in the general case of both operators and functions, with a few notable exceptions, namely short-circuiting logical operators.</p>\n</hr>", "OwnerUserId": "137080", "PostTypeId": "2", "Id": "7915044", "Score": "1", "CreationDate": "2011-10-27T11:11:10.523", "LastActivityDate": "2011-10-27T11:11:10.523"}, "7914972": {"CommentCount": "7", "ViewCount": "1303", "CreationDate": "2011-10-27T11:04:46.007", "LastActivityDate": "2011-10-28T13:34:06.140", "Title": "Create C++ integer class to act absolutely identical to integral integer type", "AcceptedAnswerId": "7915003", "PostTypeId": "1", "Id": "7914972", "Score": "6", "Body": "<p>Small and pretty nasty problem I've seen several days ago, asked to my friend on interview.</p>\n<p>The initial interview question was: \"What will be the output of the following code?\"</p>\n<pre><code>int i = 2;\ni = i++ + i++;\n</code></pre>\n<p>The correct answer is ((2 + 2) + 1) + 1 = 6, i.e. post-increment is applied twice before assignment, but after addition.</p>\n<p>Then I wanted to create a simple class carrying one integer and overload operator+() and operator++(int) to see in logs the exact order, in which operators will be executed.</p>\n<p>This is what I got:</p>\n<pre><code>class A\n{\npublic:\nA(int _data) : data(_data) { }\n\nA &amp;operator=(const A&amp; _rhs)\n{\n    data = _rhs.data;\n    cout&lt;&lt;\" -- assign: \"&lt;&lt;data&lt;&lt;endl;\n}\n\nA operator++(int _unused)\n{\n    A _tmp = data;\n    data++;\n\n    cout&lt;&lt;\" -- post-increment: \"&lt;&lt;data&lt;&lt;endl;\n    return _tmp;\n}\n\nA operator+(const A &amp;_rhs)\n{\n    A _tmp = data + _rhs.data;\n\n    cout&lt;&lt;\" -- addition: \"&lt;&lt;data&lt;&lt;\"+\"&lt;&lt;_rhs.data&lt;&lt;endl;\n    return _tmp;\n}\n\ninline operator int() const { return data; }\n\nprivate:\n    int data;\n};\n</code></pre>\n<p>The result was pretty discouraging:</p>\n<pre><code>-- post-increment: 3\n-- post-increment: 4\n-- addition: 3+2\n-- assign: 5\n</code></pre>\n<p>For less sophisticated constructions, such as (A _dt2 = a++; ), it acts as it should, but the order of operators execution is not as for integral types.</p>\n<p>It might be compiler specific problem, I guess: </p>\n<pre><code>$ gcc --version\ngcc (Ubuntu 4.4.3-4ubuntu5) 4.4.3\nCopyright (C) 2009 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n</code></pre>\n<p>So, I'm a bit lost :)</p>\n", "Tags": "<c++><operator-overloading>", "OwnerUserId": "1016299", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_7914972_7915003_1": {"section_id": 5811, "quality": 0.6470588235294118, "length": 11}}, "n3337": {"so_7914972_7915003_1": {"section_id": 5584, "quality": 0.6470588235294118, "length": 11}}, "n4659": {"so_7914972_7915003_1": {"section_id": 7272, "quality": 0.5882352941176471, "length": 10}}}});