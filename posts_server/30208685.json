post_cb({"bq_ids": {"n4140": {"so_30208685_30208883_0": {"length": 46, "quality": 0.92, "section_id": 5417}}, "n3337": {"so_30208685_30208883_0": {"length": 41, "quality": 0.82, "section_id": 5212}}, "n4659": {"so_30208685_30208883_0": {"length": 40, "quality": 0.8, "section_id": 6839}}}, "30208685": {"ViewCount": "3314", "Body": "<p>Is it possible to declare a variable <code>extern constexpr</code> and define it in another file?</p>\n<p>I tried it but the compiler gives error: </p>\n<blockquote>\n<p id=\"so_30208685_30208685_0\">Declaration of <code>constexpr</code> variable '<code>i</code>' is not a definition</p>\n</blockquote>\n<p>in .h:</p>\n<pre><code>extern constexpr int i;\n</code></pre>\n<p>in .cpp:</p>\n<pre><code>constexpr int i = 10; \n</code></pre>\n", "AcceptedAnswerId": "30208883", "Title": "How to declare constexpr extern?", "CreationDate": "2015-05-13T07:45:32.277", "Id": "30208685", "CommentCount": "1", "LastEditDate": "2016-08-11T06:40:30.057", "PostTypeId": "1", "LastEditorUserId": "2707359", "LastActivityDate": "2016-12-02T05:03:28.137", "Score": "18", "OwnerUserId": "4894591", "Tags": "<c++><extern><constexpr>", "AnswerCount": "4"}, "38869115": {"Id": "38869115", "PostTypeId": "2", "Body": "<p>Yes it <strong>somewhat</strong> is...</p>\n<pre><code>//===================================================================\n// afile.h\n\n#ifndef AFILE\n#define AFILE\n\n#include &lt;cstddef&gt;\n#include &lt;iostream&gt;\n\nenum class IDs {\n\n  id1,\n  id2,\n  id3,\n  END\n\n};\n\n// This is the extern declaration of a **constexpr**, use simply **const**\nextern const int ids[std::size_t(IDs::END)];\n\n// These functions will demonstrate its usage\n\ntemplate&lt;int id&gt; void Foo() { std::cout &lt;&lt; \"I am \" &lt;&lt; id &lt;&lt; std::endl; }\n\nextern void Bar();\n\n#endif // AFILE\n\n//===================================================================\n// afile.cpp\n\n#include \"afile.h\"\n\n// Here we define the consexpr. \n// It is **constexpr** in this unit and **const** in all other units\nconstexpr int ids[std::size_t(IDs::END)] = {\n\n  int(IDs::id1),\n  int(IDs::id2),\n  int(IDs::id3)\n\n};\n\n// The Bar function demonstrates that ids is really constexpr\nvoid Bar() {\n\n  Foo&lt;ids[0]      &gt;();\n  Foo&lt;ids[1] + 123&gt;();\n  Foo&lt;ids[2] / 2  &gt;();\n\n}\n\n//===================================================================\n// bfile.h\n\n#ifndef BFILE\n#define BFILE\n\n// These functions will demonstrate usage of constexpr ids in an extern unit\n\nextern void Baz();\nextern void Qux();\n\n\n#endif // BFILE\n\n//===================================================================\n// bfile.cpp\n\n#include \"afile.h\"\n\n// Baz demonstrates that ids is (or works as) an extern field\nvoid Baz() {\n\n  for (int i: ids) std::cout &lt;&lt; i &lt;&lt; \", \";\n  std::cout &lt;&lt; std::endl;\n\n}\n\n// Qux demonstrates that extern ids cannot work as constexpr, though\nvoid Qux() {\n\n#if 0 // changing me to non-0 gives you a compile-time error...\n\n  Foo&lt;ids[0]&gt;();\n\n#endif\n\n  std::cout &lt;&lt; \"Qux: 'I don't see ids as consexpr, indeed.'\" \n            &lt;&lt; std::endl;\n\n}\n\n//===================================================================\n// main.cpp\n\n#include \"afile.h\"\n#include \"bfile.h\"\n\nint main(int , char **)\n{\n\n  Bar();\n  Baz();\n  Qux();\n\n  return 0;\n}\n</code></pre>\n", "LastEditorUserId": "6671104", "LastActivityDate": "2016-08-10T09:33:32.090", "Score": "0", "CreationDate": "2016-08-10T09:18:27.637", "ParentId": "30208685", "CommentCount": "1", "OwnerUserId": "6671104", "LastEditDate": "2016-08-10T09:33:32.090"}, "30208883": {"Id": "30208883", "PostTypeId": "2", "Body": "<p>no you can't do it, here's what the standard says (section 7.1.5):</p>\n<blockquote>\n<p id=\"so_30208685_30208883_0\">1  The constexpr specifier shall be applied only to the definition of a\n  variable or variable template, the declaration of a function or\n  function template, or the declaration of a static data member of a\n  literal type (3.9). If any declaration of a function, function\n  template, or variable template has a constexpr specifier, then all its\n  declarations shall contain the constexpr specifier. [Note: An explicit\n  specialization can differ from the template declaration with respect\n  to the constexpr specifier. Function parameters cannot be declared\n  constexpr. \u2014 end note ]</p>\n</blockquote>\n<p>some examples given by the standard:</p>\n<pre><code>  constexpr void square(int &amp;x);  // OK: declaration\n  constexpr int bufsz = 1024;  // OK: definition\n  constexpr struct pixel {  // error: pixel is a type\n    int x;\n    int y;\n    constexpr pixel(int);  // OK: declaration\n  };\n\n  extern constexpr int memsz; // error: not a definition\n</code></pre>\n", "LastActivityDate": "2015-05-13T07:56:17.027", "CommentCount": "0", "CreationDate": "2015-05-13T07:56:17.027", "ParentId": "30208685", "Score": "8", "OwnerUserId": "1068497"}, "30208737": {"Id": "30208737", "PostTypeId": "2", "Body": "<p>No. Extern constexpr does not make any sense. Please read <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/constexpr</a></p>\n<p>i.e. the bit \" it must be immediately constructed or assigned a value. \"</p>\n", "LastActivityDate": "2015-05-13T07:48:11.607", "CommentCount": "1", "CreationDate": "2015-05-13T07:48:11.607", "ParentId": "30208685", "Score": "2", "OwnerUserId": "892256"}, "40925066": {"Id": "40925066", "PostTypeId": "2", "Body": "<p>I agree with 'swang' above, but there is a consequence. Consider:</p>\n<p>ExternHeader.hpp</p>\n<pre><code>extern int e; // Must be extern and defined in .cpp otherwise it is a duplicate symbol.\n</code></pre>\n<p>ExternHeader.cpp</p>\n<pre><code>#include \"ExternHeader.hpp\"\nint e = 0;\n</code></pre>\n<p>ConstexprHeader.hpp</p>\n<pre><code>int constexpr c = 0; // Must be defined in header since constexpr must be initialized.\n</code></pre>\n<p>Include1.hpp</p>\n<pre><code>void print1();\n</code></pre>\n<p>Include1.cpp</p>\n<pre><code>#include \"Include1.hpp\"\n#include \"ExternHeader.hpp\"\n#include \"ConstexprHeader.hpp\"\n#include &lt;iostream&gt;\n\nvoid print1() {\n    std::cout &lt;&lt; \"1: extern = \" &lt;&lt; &amp;e &lt;&lt; \", constexpr = \" &lt;&lt; &amp;c &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Include2.hpp</p>\n<pre><code>void print2();\n</code></pre>\n<p>Include2.cpp</p>\n<pre><code>#include \"Include2.hpp\"\n#include \"ExternHeader.hpp\"\n#include \"ConstexprHeader.hpp\"\n#include &lt;iostream&gt;\n\nvoid print2() {\n    std::cout &lt;&lt; \"2: extern = \" &lt;&lt; &amp;e &lt;&lt; \", constexpr = \" &lt;&lt; &amp;c &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>main.cpp</p>\n<pre><code>#include &lt;iostream&gt;\n#include \"Include1.hpp\"\n#include \"Include2.hpp\"\n\nint main(int argc, const char * argv[]) {\n    print1();\n    print2();\n    return 0;\n}\n</code></pre>\n<p>Which prints:</p>\n<pre><code>1: extern = 0x1000020a8, constexpr = 0x100001ed0\n2: extern = 0x1000020a8, constexpr = 0x100001ed4\n</code></pre>\n<p>IE the <code>constexpr</code> is allocated twice whereas the <code>extern</code> is allocated once.\nThis is counterintuitive to me, since I 'expect' <code>constexpr</code> to be more optimized than <code>extern</code>.</p>\n<p>Edit: <code>const</code> and <code>constexpr</code> have the same behaviour, with regard to allocation, therefore from that point of view the behaviour is as expected. Though, as I said, I was surprised when I came across the behaviour of <code>constexpr</code>.</p>\n", "LastEditorUserId": "1481689", "LastActivityDate": "2016-12-02T05:03:28.137", "Score": "1", "CreationDate": "2016-12-02T04:55:58.213", "ParentId": "30208685", "CommentCount": "1", "OwnerUserId": "1481689", "LastEditDate": "2016-12-02T05:03:28.137"}});