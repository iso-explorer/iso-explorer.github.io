post_cb({"40105806": {"ParentId": "40105746", "LastEditDate": "2016-10-18T10:35:19.343", "CommentCount": "25", "CreationDate": "2016-10-18T10:29:09.310", "OwnerUserId": "560648", "LastEditorUserId": "703016", "PostTypeId": "2", "Id": "40105806", "Score": "14", "Body": "<p>Not just under the hood\u2026 both <code>dst</code> and <code>src</code>, despite appearances, actually <em>are</em> pointers! The <code>[]</code> syntax in parameter lists is syntactic sugar (or syntactic pepper really) but it's lying to you; these are <code>char* dst</code> and <code>char const* src</code> for reals.</p>\n<p><strong>8.3.5/5 [dcl.fct] Functions:</strong></p>\n<blockquote>\n<p id=\"so_40105746_40105806_0\">After determining the type of each parameter, any parameter of type \u201carray of T\u201d or of function type T is adjusted to be \u201cpointer to T\u201d.</p>\n</blockquote>\n", "LastActivityDate": "2016-10-18T10:35:19.343"}, "40105906": {"ParentId": "40105746", "CommentCount": "1", "Body": "<p>This is the process of <em>decaying</em>.</p>\n<p>for the compiler, the <em>name</em> of the array becomes the pointer of the first element. </p>\n<p>do notice that arrays and pointers are not the same. it the the <em>name</em>, the <em>symbol</em> which is treated like a pointer to the first element of the array.</p>\n<p>so in your example, <code>char dest[]</code> is treated by the compiler as <code>&amp;dest[0]</code>, or in other words, <code>char* dest</code>.</p>\n<p>according the language rules, if <code>p</code> is a pointer, then <code>p[x]</code> is treated as <code>*(p+x)</code>, this is why the generated machine code in both example is almost identical.</p>\n", "OwnerUserId": "3613500", "PostTypeId": "2", "Id": "40105906", "Score": "-1", "CreationDate": "2016-10-18T10:34:33.307", "LastActivityDate": "2016-10-18T10:34:33.307"}, "40108223": {"ParentId": "40105746", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_40105746_40108223_0\">is there actually any difference between the two methods?</p>\n</blockquote>\n<p>Yes, the second one is just wrong:</p>\n<pre><code>void strcopy(char dst[], char const src[]){\n    size_t i = 0;\n    while (dst[i] = src[i++]) // (*)\n        ;\n}\n</code></pre>\n<p>The line marked <code>(*)</code> is undefined behavior for most of C++'s history. There is no specified ordering of the two reads of <code>i</code> with respect to the increment. It's possible that this will be ordered correctly on your compiler on your platform. It's possible the increment of <code>i</code> will happen before it's read as the index of <code>dst</code>, and your copy function will be off by one. In C++17, the right hand side will be evaluated first so the copy function will <em>definitely</em> be off by one.</p>\n<p>You will want to make the increment its own expression:</p>\n<pre><code>void strcopy(char dst[], char const src[]){\n    size_t i = 0;\n    while (dst[i] = src[i]) {\n        ++i;\n    }\n}\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "40108223", "Score": "3", "CreationDate": "2016-10-18T12:25:27.177", "LastActivityDate": "2016-10-18T12:25:27.177"}, "bq_ids": {"n4140": {"so_40105746_40105806_0": {"section_id": 3241, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_40105746_40105806_0": {"section_id": 3114, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_40105746_40105806_0": {"section_id": 3997, "quality": 1.0, "length": 12}}}, "40105746": {"CommentCount": "2", "ViewCount": "236", "PostTypeId": "1", "LastEditorUserId": "19405", "LastActivityDate": "2016-11-16T01:31:20.137", "Body": "<p>Here is an implementation of strCopy</p>\n<pre><code>void strcopy2(char *dst, char const *src){\n    while ((*dst++ = *src++))\n        ;\n}\n</code></pre>\n<p>Our professor asked us to reproduce this code without using pointers, so I came up with the following function:</p>\n<pre><code>void strcopy(char dst[], char const src[]){\n    size_t i = 0;\n    while (dst[i] = src[i++])\n        ;\n}\n</code></pre>\n<p>It works well, but I realised, that under the hood the function must still be using pointers, as we nowhere return any value. In other words, I though the last function would use pass by value but this is obviously not the case. So what is happening under water, and is there actually any difference between the two methods?</p>\n", "Title": "Why does my strCopy implementation work?", "FavoriteCount": "0", "LastEditDate": "2016-11-16T01:31:20.137", "Id": "40105746", "Score": "5", "CreationDate": "2016-10-18T10:26:12.093", "Tags": "<c++>", "OwnerUserId": "3147102", "AnswerCount": "3"}});