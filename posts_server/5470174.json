post_cb({"5470174": {"CommentCount": "1", "AcceptedAnswerId": "5470201", "PostTypeId": "1", "LastEditorUserId": "172531", "CreationDate": "2011-03-29T09:06:23.483", "LastActivityDate": "2011-04-01T12:51:47.450", "LastEditDate": "2011-03-29T13:26:20.410", "ViewCount": "1786", "FavoriteCount": "3", "Title": "Understanding C++0x lambda captures", "Id": "5470174", "Score": "11", "Body": "<p>In one of the recent C++0x drafts (n3225.pdf) we can find 5.1.2/10:</p>\n<blockquote>\n<p id=\"so_5470174_5470174_0\">The identifiers in a capture-list are looked up using the usual rules for unqualified name lookup (3.4.1); each such lookup shall find a variable with automatic storage duration declared in the reaching scope of the local lambda expression. An entity (i.e. a variable or this) is said to be explicitly captured if it appears in the lambda-expression\u2019s capture-list.</p>\n</blockquote>\n<p>That <em>seems</em> rather restrictive to me. For example, it <em>seems</em> to me that the following things are disallowed:</p>\n<pre><code>int global;\n\nstruct s {\n    int x;\n    void memfun() {\n        [x,global]{};\n    }\n};\n</code></pre>\n<p>since <code>x</code> is not necessarily a variable with automatic storage and neither is <code>global</code>. Note that the intention of this capture clause is to let the lambda object store a <em>copy</em> of <code>x</code> and <code>global</code> which might be desirable in case they are changed at a later stage. I am already aware of an alternative:</p>\n<pre><code>int global;\n\nstruct s {\n    int x;\n    void memfun() {\n        int copyx = x;\n        int copyglobal = global;\n        [copyx,copyglobal]{};\n    }\n};\n</code></pre>\n<p>But this boils down to extra copies and additional boiler plate just to capture <code>x</code> and <code>global</code> as copy.</p>\n<p>Also, i cannot find anything conclusive in the latest drafts about what happens if we name a local reference in the capture clause:</p>\n<pre><code>int main() {\n    int  i = 0;\n    int &amp;r = i;\n    assert([r]{return &amp;r;}() != &amp;i);\n}\n</code></pre>\n<p>Does the lambda object \"copy a reference\" or \"copy an int\"? If it captures the referred object by copy, this can save us the additional copies from the previous work-around.</p>\n<p>GCC apparently supports all these examples and stores a copy of an int in the last case (which is desirable, IMHO). But I would like to know whether this is in fact the intended behaviour according to the C++0x drafts or just a compiler-extension respectivly an implementatin bug.</p>\n<p><strong>Edit:</strong></p>\n<p>templatetypedef pointed out 5.1.2/14 which explains what happens when a reference is named in a capture-clause. As far as I can tell, this allows us to use the following work-around for the first example:</p>\n<pre><code>int global;\n\nstruct s {\n    int x;\n    void memfun() {\n        auto&amp; cx = x;\n        auto&amp; cglob = global;\n        [cx,cglob]{};\n    }\n};\n</code></pre>\n<p>Tia,\nsellibitze</p>\n", "Tags": "<lambda><c++11>", "OwnerUserId": "172531", "AnswerCount": "1"}, "5470201": {"ParentId": "5470174", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2011-03-29T09:10:02.727", "Score": "11", "LastEditorUserId": "172531", "LastEditDate": "2011-04-01T12:51:47.450", "Id": "5470201", "OwnerUserId": "501557", "Body": "<p>From what you've posted it seems like your first example is illegal since neither captured variable has automatic duration.  <strike>However, you can easily fix this.  To capture the data member, you can just capture this, and the global doesn't need to be captured as you can just reference it directly.</strike></p>\n<p><strong>EDIT</strong>: As you pointed out, this will not create a local copy of the value you want to capture.  <strike>To capture these variables while making a copy, you can capture this, then explicitly create a local copy of the data member inside of the lambda.</strike></p>\n<p>As for the second question about capturing references, \u00a75.1.2/14 says that capturing a variable of reference type by copy will create a copy of the value referenced instead of creating a copy of the reference.  Thus the lambda will have its own copy of the value that the reference was referencing when it was created.</p>\n", "LastActivityDate": "2011-04-01T12:51:47.450"}, "bq_ids": {"n4140": {"so_5470174_5470174_0": {"section_id": 5969, "quality": 0.6363636363636364, "length": 21}}, "n3337": {"so_5470174_5470174_0": {"section_id": 5738, "quality": 0.9090909090909091, "length": 30}}, "n4659": {"so_5470174_5470174_0": {"section_id": 7467, "quality": 0.6363636363636364, "length": 21}}}});