post_cb({"33855956": {"CommentCount": "1", "ViewCount": "122", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2015-11-22T14:36:29.833", "LastActivityDate": "2015-11-22T14:44:21.660", "Title": "Reference initialization and direct vs indirect binding", "FavoriteCount": "3", "LastEditDate": "2015-11-22T14:44:21.660", "Id": "33855956", "Score": "1", "Body": "<p>Consider the following case</p>\n<pre><code>struct A {\n   operator int();\n};\n\nint &amp;&amp;x = A();\n</code></pre>\n<p>The spec says at <a href=\"http://eel.is/c++draft/dcl.init.ref#5\" rel=\"nofollow\">http://eel.is/c++draft/dcl.init.ref#5</a> about whether the reference binding is direct or indirect</p>\n<blockquote>\n<p id=\"so_33855956_33855956_0\">In all cases except the last (i.e., creating and initializing a temporary from the initializer expression), the reference is said to bind directly to the initializer expression.</p>\n</blockquote>\n<p>The case above doesn't match the last, but the second last bullet.</p>\n<blockquote>\n<p id=\"so_33855956_33855956_1\">If T1 or T2 is a class type and T1 is not reference-related to T2, user-defined conversions are considered ... The result of the call to the conversion function, as described for the non-reference copy-initialization, is then used to direct-initialize the reference.</p>\n</blockquote>\n<p>Therefore the binding of <code>A()</code> to the reference is <em>indirect binding</em>. To carry on, we will recurse into reference initialization again, now with a prvalue of type <code>int</code>, trying to initialize <code>int&amp;&amp;</code>. Now we will end up with the last bullet, which means <em>direct binding</em>. </p>\n<p>So what can we say about the binding of the reference... does it bind directly or indirectly? Does it do both, depending on what expression you consider (initializer expression vs result of the conversion function call)?</p>\n<p>In our case in particular, the paragraphs seem to say <em>we bind directly to the initializer expression and bind indirectly to the result of the conversion on the initializer expression</em>. However, in the chapter on overload resulution <a href=\"http://eel.is/c++draft/over.ics.ref\" rel=\"nofollow\">http://eel.is/c++draft/over.ics.ref</a>, we only distinguish between</p>\n<ul>\n<li>When a parameter of reference type binds directly ([dcl.init.ref]) to an argument expression,</li>\n<li>If the parameter binds directly to the result of applying a conversion function to the argument expression,</li>\n<li>When a parameter of reference type is not bound directly to an argument expression, </li>\n</ul>\n<p>For a case like</p>\n<pre><code>void f(int &amp;&amp;);\nf(A());\n</code></pre>\n<p>Case 1 applies, but I'm pretty sure it is not intended to apply. My gut feeling is that \"In all cases except the last\" is not only intended to match the creation-of-temporary case, but also the second last bullet or alternatively to the whole \"Otherwise:\" branch that contains the two bullets (i.e the \"last\" refers to a different level on the bullet-hierarchy). Can you please clarify? </p>\n", "Tags": "<c++><initialization><overloading><reference-binding>", "OwnerUserId": "34509", "AnswerCount": "0"}, "bq_ids": {"n4140": {"so_33855956_33855956_1": {"section_id": 3321, "quality": 0.9375, "length": 15}, "so_33855956_33855956_0": {"section_id": 3321, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_33855956_33855956_1": {"section_id": 3191, "quality": 0.625, "length": 10}, "so_33855956_33855956_0": {"section_id": 3191, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_33855956_33855956_1": {"section_id": 4087, "quality": 0.9375, "length": 15}, "so_33855956_33855956_0": {"section_id": 4087, "quality": 0.7333333333333333, "length": 11}}}});