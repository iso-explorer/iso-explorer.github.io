post_cb({"34515589": {"ParentId": "34515544", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Because a <em>null pointer constant</em> is defined not just as a compile-time integral constant with value 0, but as an integer <strong>literal</strong> with value zero (or as a prvalue of type <code>std::nullptr_t</code>, of course). C++14 (N4140), 4.10/1.</p>\n<p>So actually, only the first line <code>f(0)</code> should compile, all the other ones should provoke at least a diagnostic message from a conforming compiler.</p>\n", "OwnerUserId": "1782465", "LastEditorUserId": "1782465", "LastEditDate": "2015-12-29T17:16:16.807", "Id": "34515589", "Score": "6", "CreationDate": "2015-12-29T17:04:42.210", "LastActivityDate": "2015-12-29T17:16:16.807"}, "34517233": {"ParentId": "34515544", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This is a gcc bug. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#903\" rel=\"nofollow\">Defect report 903: Value-dependent integral null pointer constants </a> which is a defect report against C++11(<em>it has CD3 status</em>),  makes it so that only an integer literal <code>0</code> is considered a null pointer constant. </p>\n<p>It changed section <code>4.10</code> [conv.ptr] paragraph <code>1</code> amongst other changes from:</p>\n<blockquote>\n<p id=\"so_34515544_34517233_0\">A null pointer constant is an integral constant expression (5.19 [expr.const]) prvalue of integer type that evaluates to zero [...]</p>\n</blockquote>\n<p>to:</p>\n<blockquote>\n<p id=\"so_34515544_34517233_1\">A null pointer constant is an integer literal (2.14.2 [lex.icon]) with value zero [...]</p>\n</blockquote>\n<p>This is listed as an incompatibility against C++03, from section <code>C.2.2</code> Clause 4: standard conversions <em>[diff.cpp03.conv]</em> which says:</p>\n<blockquote>\n<p id=\"so_34515544_34517233_2\"><strong>Change:</strong> Only literals are integer null pointer constants<br>\n<strong>Rationale:</strong> Removing surprising interactions with templates and\n  constant expressions<br>\n<strong>Effect on original feature:</strong> Valid C++ 2003 code may fail to compile or\n  produce different results in this International Standard, as the\n  following example illustrates:</br></br></p>\n<pre><code>void f(void *); // #1\nvoid f(...); // #2\ntemplate&lt;int N&gt; void g() {\n  f(0*N); // calls #2; used to call #1\n}\n</code></pre>\n</blockquote>\n<p>The following gcc bug report <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=52145\" rel=\"nofollow\">[C++11] [DR 903] zero-valued integer constant expression should prefer conversion to pointer</a> shows that the gcc team originally thought this was a C++17 change but later changed it to be in effect in C++11.</p>\n<p>We can see in the head revision of gcc(<em>6.0</em>) this is fixed (<em><a href=\"http://melpon.org/wandbox/permlink/bv11uodgGHlloJRE\" rel=\"nofollow\">see it live</a></em>) and produces a diagnostic for all the cases clang does:</p>\n<pre><code>error: could not convert '(1 - 1)' from 'int' to 'std::shared_ptr&lt;int&gt;'\n f( 1 - 1 );           // compiles fine in gcc, fails in clang\n    ~~^~~\n\nerror: could not convert 'i' from 'const int' to 'std::shared_ptr&lt;int&gt;'\n f( i );               // fails to compile in gcc and clang\n      ^\n\nerror: could not convert '(0 - 0)' from 'int' to 'std::shared_ptr&lt;int&gt;'\n f( i - 0 );           // compiles fine in gcc, fails in clang\n    ~~^~~\n</code></pre>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2016-01-11T12:56:06.843", "Id": "34517233", "Score": "20", "CreationDate": "2015-12-29T18:55:25.677", "LastActivityDate": "2016-01-11T12:56:06.843"}, "34515544": {"CommentCount": "4", "AcceptedAnswerId": "34517233", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2015-12-29T17:02:16.067", "LastActivityDate": "2016-01-11T12:56:06.843", "LastEditDate": "2015-12-30T04:48:58.607", "ViewCount": "525", "FavoriteCount": "0", "Title": "Conversion from integral constant expression to null-pointer", "Id": "34515544", "Score": "14", "Body": "<p>Consider following code:</p>\n<pre><code>#include &lt;memory&gt;\n\nvoid f( std::shared_ptr&lt;int&gt; ) {}\n\nint main()\n{\n    f( 0 );               // compiles fine in gcc and clang\n    f( 1 - 1 );           // compiles fine in gcc, fails in clang\n    constexpr int i = 0;\n    f( i );               // fails to compile in gcc and clang\n    f( i - 0 );           // compiles fine in gcc, fails in clang\n}\n</code></pre>\n<p>why only <code>f( i )</code> fails to compile, though <code>i</code> should be evaluated as compile time constant with value 0?</p>\n<p>PS checked with g++ v 5.1.0, it accepts all variants except <code>f(i);</code> in both c++11 and c++14 mode\nPPS checked with clang 3.7, it rejects all variants except literal 0 in both c++11 and c++14 mode</p>\n", "Tags": "<c++><c++11><gcc><null><c++14>", "OwnerUserId": "432358", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_34515544_34517233_1": {"section_id": 39, "quality": 0.6666666666666666, "length": 6}}, "n3337": {"so_34515544_34517233_1": {"section_id": 5947, "quality": 0.5555555555555556, "length": 5}, "so_34515544_34517233_0": {"section_id": 36, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_34515544_34517233_1": {"section_id": 39, "quality": 0.6666666666666666, "length": 6}}}});