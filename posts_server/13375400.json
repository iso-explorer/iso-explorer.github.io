post_cb({"13376620": {"ParentId": "13375400", "CommentCount": "0", "Body": "<p>First, it's perfectly legal to use the <code>inline</code> keyword for functions\ndefined within a class: </p>\n<pre><code>struct MyClass\n{\n    inline int someFunctions() { return 42; }\n};\n</code></pre>\n<p>The keyword here is redundant, but not illegal.</p>\n<p>Secondly, although the <code>inline</code> keyword is meant to be a hint to the\ncompiler, the only formal, required meaning that it has is to allow\nmultiple definitions of the function without causing undefined behavior\ndue to a violation of the one definition rule.  And compilers do ignore\nit in some cases:</p>\n<ul>\n<li><p>Most compilers will ignore it when options designed for debugging are\ngiven (or optimization is turned off), and will not actually inline\nanything.</p></li>\n<li><p>The best compilers will ignore it completely when maximum optimization\nis turned on; whether a function is inlined or not will depend uniquely\non the compiler's analysis of the code and profiling data, and a given\nfunction will be inlined at one location (where it is in the middle of a\ntight loop), and not at another.  (And unlike what some other posters\nhave said, this occurs even if the call site and the function definition\nare in two different translation units.)</p></li>\n</ul>\n<p>In between these two extremes, a lot of compilers do <em>not</em> do\ninter-module analysis, and will, at least when some degree of\noptimization is turned on, \"take the hint\", at least most of the time.\nA recursive inline function, for example, will almost certainly <em>not</em>\nbe generated inline if the compiler cannot determine the depth of the\nrecursion at compile times.  And most compilers are incapable of\ngenerating a virtual function inline if they cannot determine the actual\ntype of the object with a localized static analysis, although some of\nthe best, given profiler output that reveals that one particular\noverload will be called 99% of the time, may generate an <code>if</code>, and\ninline that one case.</p>\n<p>In general, you want to define as little as possible in the header file,\nso for \"exported\" classes, you won't use <code>inline</code> (explicit or implicit)\nunless the profiler says it is absolutely necessary.  For local classes,\ndefined in the source file, it's more a matter of style whether you\ndefine the functions in the class definition or not (and it may or may\nnot make a difference as to whether the compiler inlines them\u2014as I\nsaid, with the usual debugging options, most compilers won't inline\nanything).</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "13376620", "Score": "2", "CreationDate": "2012-11-14T10:01:32.577", "LastActivityDate": "2012-11-14T10:01:32.577"}, "13375400": {"CommentCount": "1", "ViewCount": "265", "CreationDate": "2012-11-14T08:36:42.790", "LastActivityDate": "2012-11-14T10:01:32.577", "Title": "C++implicity inline function", "AcceptedAnswerId": "13375551", "PostTypeId": "1", "Id": "13375400", "Score": "3", "Body": "<p>I have read in my document say about inline function. My document says that: there are two types of inline function: <code>implicity function</code> and <code>explicity function</code>. </p>\n<p><code>Explicity function</code>: you use <code>inline</code> keyword before function, and using outside of the class. for example: </p>\n<pre><code>inline int Math::add(int a, int b){ return a + b; }\n</code></pre>\n<p><code>Implicity function</code>: every method inside class is implicity. for example:</p>\n<pre><code>class Math {\n   int add(int a, int b) { return a + b;}   // implicity inline function\n};\n</code></pre>\n<p>So, if this true, so, every method that I don't want to use <code>inline</code>, I must declare outside of the class, right ? And if this true, can I implement a method inside class and don't want inline function.</p>\n<p>Thanks :)</p>\n", "Tags": "<c++><inline>", "OwnerUserId": "1192728", "AnswerCount": "4"}, "13375551": {"ParentId": "13375400", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The only way to guarantee that it is not inline is to make it unreachable at compilation time, for instance, by putting its body definition into cpp file instead of header.</p>\n<p>UPDATE: A commenter says that even putting function body into different compilation unit is not guaranteed to help. He is absolutely right. Usually it helps, but some compilers still may inline the function. <strong>So, there is no reliable way to disable inlining that is not compiler-dependent.</strong></p>\n<p>All the inlining is just a question of optimization. If appropriate optimization is on, by writing an inline keyword you just tell the compiler that you RECOMMEND to inline the function. You can neither force compiler to inline a function, nor force compiler not to inline it. For certain compilers, e.g. VC++, there are ways to do so (<code>__declspec(noinline)</code>), but they all are compiler-dependent.</p>\n<p>And why do you need to disable inlining? The compiler often knows better... If it is for debugging purposes, just disable the optimizations, or at least function inlining. You may even use pragmas to do so in a single file. Anyway, debugging a release version should usually be avoided, though sometimes it is impossible to avoid it, of course.</p>\n", "OwnerUserId": "1818868", "LastEditorUserId": "1818868", "LastEditDate": "2012-11-14T09:57:40.970", "Id": "13375551", "Score": "7", "CreationDate": "2012-11-14T08:48:19.313", "LastActivityDate": "2012-11-14T09:57:40.970"}, "13375689": {"ParentId": "13375400", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Reading from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow\">C++ standard</a>, how the \"implicit inline function\" is defined:</p>\n<blockquote>\n<p id=\"so_13375400_13375689_0\"><b>A member function may be defined (8.4) in its class definition, in\n  which case it is an inline member function</b> (7.1.2), or it may be\n  defined outside of its class definition if it has already been\n  declared but not defined in its class definition. A member function\n  definition that appears outside of the class definition shall appear\n  in a namespace scope enclosing the class definition. Except for member\n  function definitions that appear outside of a class definition, and\n  except for explicit specializations of member functions of class\n  templates and member function templates (14.7) appearing outside of\n  the class definition, a member function shall not be redeclared.</p>\n</blockquote>\n<p>Also compiler doesn't guarantee that it really will perform the substitution:</p>\n<blockquote>\n<p id=\"so_13375400_13375689_1\">A function declaration (8.3.5, 9.3, 11.4) with an inline specifier\n  declares an inline function. The inline specifier indicates to the\n  implementation that inline substitution of the function body at the\n  point of call is to be preferred to the usual function call mechanism.\n  <b>An implementation is not required to perform this inline substitution</b>\n  at the point of call; however, even if this inline substitution is\n  omitted, the other rules for inline functions defined by 7.1.2 shall\n  still be respected.</p>\n</blockquote>\n<p>Every other function will probably be \"non-inline\" although many weird things could happen once you turn on optimization, for example take a look at <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html\" rel=\"nofollow\"><code>gcc</code> - Optimize options</a>:</p>\n<ul>\n<li><p><code>-finline-small-functions</code> <sub>as a part of <code>O2</code></sub></p>\n<blockquote>\n<p id=\"so_13375400_13375689_2\">Integrate functions into their callers when their body is smaller than\n  expected function call code (so overall size of program gets smaller).\n  The compiler heuristically decides which functions are simple enough\n  to be worth integrating in this way. This inlining applies to all\n  functions, even those not declared inline.</p>\n</blockquote></li>\n<li><p><code>-finline-functions</code> <sub>as a part of <code>O3</code></sub></p>\n<blockquote>\n<p id=\"so_13375400_13375689_3\">Consider all functions for inlining, even if they are not declared\n  inline. The compiler heuristically decides which functions are worth\n  integrating in this way.<br/> If all calls to a given function are\n  integrated, and the function is declared static, then the function is\n  normally not output as assembler code in its own right.</p>\n</blockquote></li>\n<li><p><code>-finline-functions-called-once</code> <sub>as a part of <code>O1</code></sub></p>\n<blockquote>\n<p id=\"so_13375400_13375689_4\">Consider all static functions called once for inlining into their\n  caller even if they are not marked inline. If a call to a given\n  function is integrated, then the function is not output as assembler\n  code in its own right.</p>\n</blockquote></li>\n</ul>\n<p>And on the other hand you can tell compiler not to inline function (<code>-fno-inline</code>):</p>\n<blockquote>\n<p id=\"so_13375400_13375689_5\">Do not expand any functions inline apart from those marked with the\n  always_inline attribute. This is the default when not optimizing.<br/>\n  Single functions can be exempted from inlining by marking them with\n  the noinline attribute.</p>\n</blockquote>\n", "OwnerUserId": "1149736", "LastEditorUserId": "1149736", "LastEditDate": "2012-11-14T09:05:25.370", "Id": "13375689", "Score": "4", "CreationDate": "2012-11-14T08:58:07.493", "LastActivityDate": "2012-11-14T09:05:25.370"}, "13375430": {"ParentId": "13375400", "CommentCount": "1", "Body": "<p>Yes it's true, all methods <strong>defined</strong> inside a class definition are implicitly <code>inline</code>. </p>\n<p>Note that <code>inline</code> doesn't mean the compiler will actually inline it in the code. If you want it not be be inline, simply separate the implementation in an implementation file.</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "13375430", "Score": "3", "CreationDate": "2012-11-14T08:38:38.960", "LastActivityDate": "2012-11-14T08:38:38.960"}, "bq_ids": {"n4140": {"so_13375400_13375689_1": {"section_id": 5402, "quality": 0.8888888888888888, "length": 40}, "so_13375400_13375689_0": {"section_id": 5881, "quality": 0.9538461538461539, "length": 62}}, "n3337": {"so_13375400_13375689_1": {"section_id": 5197, "quality": 0.8888888888888888, "length": 40}, "so_13375400_13375689_0": {"section_id": 5652, "quality": 0.9538461538461539, "length": 62}}, "n4659": {"so_13375400_13375689_1": {"section_id": 6849, "quality": 0.8666666666666667, "length": 39}, "so_13375400_13375689_0": {"section_id": 7364, "quality": 0.9538461538461539, "length": 62}}}});