post_cb({"bq_ids": {"n4140": {"so_44118934_44125608_0": {"length": 24, "quality": 0.8, "section_id": 190}}, "n3337": {"so_44118934_44125608_0": {"length": 24, "quality": 0.8, "section_id": 184}}, "n4659": {"so_44118934_44125608_0": {"length": 19, "quality": 0.6333333333333333, "section_id": 195}}}, "44118934": {"ViewCount": "35", "Body": "<p>I have trouble to build a class which itself contains a subclass which self derives from class which needs template parameters from the top class. Sound horrible and it is indeed deep inside some MTP construction. But have a look on a simple example which I could shrink from the real code.</p>\n<p>I leave the names as is in my original source. They are not important here.</p>\n<pre><code>template &lt;typename ... T&gt;\nclass ConstructAll: public T...\n{\n    public:\n        using ConstructorParms = int;\n        using BASES_T = ConstructAll&lt;T...&gt;;\n        ConstructAll(int){}\n};\n\ntemplate &lt;typename T&gt;\nclass WithTemplate\n{\n};\n\nclass WithoutTemplate\n{\n};\n\n\ntemplate &lt;typename X&gt;\nclass CircuitFromNetlist\n{\n    private:\n        class SerialReader: public ConstructAll&lt;\n                            WithTemplate&lt;X&gt;    // use this-&gt; don't compile\n                            //WithoutTemplate  // but this works\n                            &gt;\n    {\n        public:\n            SerialReader( typename BASES_T::ConstructorParms p): BASES_T( p ) {}\n    };\n\n    public:\n        CircuitFromNetlist()\n        {\n            SerialReader ser{1};\n        }\n};\n\nint main()\n{\n    CircuitFromNetlist&lt;int&gt; c;\n}\n</code></pre>\n<p>If I use <code>WithTemplate&lt;X&gt;</code>it did not compile and runs into:</p>\n<p>main.cpp:31:40: error: 'BASES_T' has not been declared\n                 SerialReader( typename BASES_T::ConstructorParms p): BASES_T( p ) {}\n                                        ^~~~~~~\nmain.cpp: In constructor 'CircuitFromNetlist::SerialReader::SerialReader(int)':\nmain.cpp:31:70: error: class 'CircuitFromNetlist::SerialReader' does not have any field named 'BASES_T'\n                 SerialReader( typename BASES_T::ConstructorParms p): BASES_T( p ) {}</p>\n<p>If I flip the code to use non templated class it seems to work.</p>\n<p>Some idea to get the thing working?</p>\n", "AcceptedAnswerId": "44125608", "Title": "accessing definitions from sub class in templated class", "CreationDate": "2017-05-22T17:36:05.517", "Id": "44118934", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2017-05-23T04:02:54.013", "Score": "2", "OwnerUserId": "878532", "Tags": "<c++><templates>", "AnswerCount": "1"}, "44125608": {"Id": "44125608", "PostTypeId": "2", "Body": "<p>What you're seeing here is actually correct behavior according to the C++11 standard:</p>\n<blockquote>\n<p id=\"so_44118934_44125608_0\">In the de\ufb01nition of a class or class template, <strong>if a base class depends on a template-parameter, the base class scope is not examined during unquali\ufb01ed name lookup</strong> either at the point of de\ufb01nition of the class template or member or during an instantiation of the class template or member. -- [temp.dep] (emphasis mine)</p>\n</blockquote>\n<p>When you inherit from <code>ConstructAll&lt;WithoutTemplate&gt;</code>, the base class does not depend on the template parameter <code>X</code>, but obviously inheriting from <code>ConstructAll&lt;WithTemplate&lt;X&gt;&gt;</code> the base class does depend on this template parameter.</p>\n<p>You will have to explicitly refer to the type as <code>typename ConstructAll&lt;WithTemplate&lt;X&gt;&gt;::BASES_T</code>.</p>\n", "LastActivityDate": "2017-05-23T04:02:54.013", "CommentCount": "0", "CreationDate": "2017-05-23T04:02:54.013", "ParentId": "44118934", "Score": "0", "OwnerUserId": "501250"}});