post_cb({"20937337": {"ParentId": "20936574", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>There's a distinct difference in the behavior of value-initialization between C++11 and N3797 for classes with both a defaulted default constructor and another non-default constructor. C++11 \u00a7 8.5/7:</p>\n<blockquote>\n<p id=\"so_20936574_20937337_0\">To <em>value-initialize</em> an object of type T means:</p>\n<ul>\n<li>if T is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the\n  default constructor for T is called (and the initialization is ill-formed if T has no accessible default\n  constructor);</li>\n<li>if T is a (possibly cv-qualified) non-union class type without a user-provided constructor, then the object\n  is zero-initialized and, if T\u2019s implicitly-declared default constructor is non-trivial, that constructor is\n  called.</li>\n<li>if T is an array type, then each element is value-initialized;</li>\n<li>otherwise, the object is zero-initialized.</li>\n</ul>\n</blockquote>\n<p>N3797 \u00a7 8.5/8:</p>\n<blockquote>\n<p id=\"so_20936574_20937337_1\">To <em>value-initialize</em> an object of type T means:</p>\n<ul>\n<li>if T is a (possibly cv-qualified) class type (Clause 9) with either no default constructor (12.1) or a\n  default constructor that is user-provided or deleted, then the object is default-initialized;</li>\n<li>if T is a (possibly cv-qualified) class type without a user-provided or deleted default constructor, then\n  the object is zero-initialized and the semantic constraints for default-initialization are checked, and if\n  T has a non-trivial default constructor, the object is default-initialized;</li>\n<li>if T is an array type, then each element is value-initialized;</li>\n<li>otherwise, the object is zero-initialized.</li>\n</ul>\n</blockquote>\n<p>Your <code>struct A</code> has a user-declared default constructor <code>A() = default;</code> and a user-provided non-default constructor <code>A(int j) : i{j} {}</code>. In C++11, it's subject to the first bullet: it has a user-provided constructor, so the default constructor is called (which does nothing: <code>A</code>'s default constructor is trivial). In N3797, the <em>second</em> bullet applies since <code>A</code> is \"without a user-provided or deleted default constructor\" so the object is zero-initialized.</p>\n<p>Put simply, value-initialization in C++11 of an object of a class with <strong>any</strong> user-provided constructor will not perform zero-initialization before default-initialization. In N3797, value-initialization of an object of a class with no user-provided <strong>default</strong> constructor will perform zero-initialization before default-initialization.</p>\n<p>It appears that <a href=\"http://coliru.stacked-crooked.com/a/db86c6cc4f1dac8a\" rel=\"noreferrer\">the version of clang on Coliru</a> has been tracking the standard here post-C++11, but <a href=\"http://coliru.stacked-crooked.com/a/f7a49c3f3c9b3459\" rel=\"noreferrer\">GCC 4.8 has not</a>.</p>\n<p>EDIT: <a href=\"http://coliru.stacked-crooked.com/a/7fde826fc064bef8\" rel=\"noreferrer\">This test program</a> demonstrates that GCC 4.8 actually <em>does</em> follow the N3797 rules for value initialization. The problem seems to be that it is <em>default</em>-initializing the array elements for which no initializer is provided instead of <em>value</em>-initializing them as required by the standard. Note the difference in behavior between the second array element, which is explicitly provided an empty initializer, and the third which is provided no initializer.</p>\n<p>This is looking like a probable GCC bug.</p>\n<p>EDIT: <a href=\"http://ideone.com/gZX9CL\" rel=\"noreferrer\">The same test program compiled by the same GCC version on Ideone</a> doesn't demonstrate the bug. No idea what is going on here. Perhaps different compiler flags affecting the output on Ideone, I have no idea how to determine the compiler command line used.</p>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2014-01-05T20:58:43.727", "Id": "20937337", "Score": "7", "CreationDate": "2014-01-05T18:20:23.560", "LastActivityDate": "2014-01-05T20:58:43.727"}, "20936574": {"CommentCount": "17", "AcceptedAnswerId": "20937337", "PostTypeId": "1", "LastEditorUserId": "2548699", "CreationDate": "2014-01-05T17:15:41.633", "LastActivityDate": "2014-01-12T02:42:55.523", "LastEditDate": "2014-01-05T17:31:55.840", "ViewCount": "700", "FavoriteCount": "1", "Title": "The snippet compiles with warnings in Coliru, but compiles normally in Ideone. Which one is correct?", "Id": "20936574", "Score": "9", "Body": "<p>This code compiles in Coliru with warnings [unitialized members <code>a[1].i</code> and <code>a[2].i</code> in the <code>std::cout &lt;&lt;</code> expression in <code>main()</code>] but compiles normally in <a href=\"http://ideone.com/5XVKHE\">Ideone</a>.    </p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    int i;\n    A(int j) : i{j} {};\n    A() = default;\n};\n\nint main() {\n    A a[3] = { A(1) };\n    std::cout &lt;&lt; a[1].i &lt;&lt; ' ' &lt;&lt; a[2].i &lt;&lt; '\\n';\n}\n</code></pre>\n<p>According to my interpretation of iso \u00a7 8.5 p7, Ideone is correct, because of the 4th bullet point in this clause.</p>\n<p>This is \u00a7 8.5 p7 from N3797</p>\n<blockquote>\n<p id=\"so_20936574_20936574_0\">To value-initialize an object of type T means:</p>\n<ul>\n<li>if T is a (possibly cv-quali\ufb01ed) class type (Clause 9) with either no default constructor (12.1) or a default constructor that is\n  user-provided or deleted, then the object is default-initialized;</li>\n<li>if T is a (possibly cv-quali\ufb01ed) class type without a user-provided or deleted default constructor, then the object is zero-initialized\n  and the semantic constraints for default-initialization are checked,\n  and if T has a non-trivial default constructor, the object is\n  default-initialized;</li>\n<li>if T is an array type, then each element is value-initialized;</li>\n<li>otherwise, the object is zero-initialized.</li>\n</ul>\n<p id=\"so_20936574_20936574_1\">An object that is value-initialized is deemed to be constructed and\n  thus subject to provisions of this International Standard applying to\n  \u201cconstructed\u201d objects, objects \u201cfor which the constructor has\n  completed,\u201d etc., even if no constructor is invoked for the object\u2019s\n  initialization.</p>\n</blockquote>\n", "Tags": "<c++><c++11><initialization><language-lawyer>", "OwnerUserId": "2548699", "AnswerCount": "3"}, "20936695": {"ParentId": "20936574", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>Ideone is correct as far as C++14 (N3797) is concerned (see Casey's answer for C++11) because <code>a[1]</code> and <code>a[2]</code> are initialized with <code>A{}</code>, which is value initialization, causing <code>i</code> to be 0. This comes from N3797 \u00a7 8.5.1/7:</p>\n<blockquote>\n<p id=\"so_20936574_20936695_0\">If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from its brace-or-equal-initializer or, if there is no brace-or-equal initializer, from an empty initializer list (8.5.4). [ Example:</p>\n</blockquote>\n<pre><code>struct S { int a; const char* b; int c; int d = b[a]; };\nS ss = { 1, \"asdf\" };\n</code></pre>\n<blockquote>\n<p id=\"so_20936574_20936695_1\">initializes ss.a with 1, ss.b with \"asdf\", ss.c with the value of an expression of the form int{} (that is, 0), and ss.d with the value of ss.b[ss.a] (that is, \u2019s\u2019)</p>\n</blockquote>\n<p>An array is an aggregate per \u00a7 8.5.1/1 (<code>An aggregate is an array...</code>), so this applies to the array's initialization.</p>\n<p>The expression <code>T{}</code> (an empty initializer list) value-initializes the object per \u00a7 8.5.4 /3:</p>\n<blockquote>\n<p id=\"so_20936574_20936695_2\">Otherwise, if the initializer list has no elements and T is a class type with a default constructor, the object is value-initialized.</p>\n</blockquote>\n<p>We can confirm that the value-initialization leaves <code>i</code> with a value of 0 with \u00a7 8.5/8:</p>\n<blockquote>\n<p id=\"so_20936574_20936695_3\">If T is a (possibly cv-quali\ufb01ed) class type without a user-provided or deleted default constructor, then the object is zero-initialized and the semantic constraints for default-initialization are checked, and if T has a non-trivial default constructor, the object is default-initialized;</p>\n</blockquote>\n<p>Your class has no user-provided default constructor per \u00a7 8.4.2/4: </p>\n<blockquote>\n<p id=\"so_20936574_20936695_4\">A function is user-provided if it is user-declared and not explicitly defaulted or\n  deleted on its \ufb01rst declaration.</p>\n</blockquote>\n<p>An interesting point to note is that if your default constructor was user-provided and did not initialize <code>i</code>, the first point of 8.5/8 would be used and <code>i</code> would be left uninitialized, as you can see in this <a href=\"http://coliru.stacked-crooked.com/a/611f56a9bc399369\" rel=\"nofollow\">example</a>.</p>\n<p>Finally, a small note on the comparison. Ideone uses a few different versions of GCC. Which one is used makes a difference (you can check with <code>__VERSION__</code> if you need to). The compiler flags also make a slight difference in this case. If <code>-std=c++1y</code> is present (and I don't know a way to check that other than using an added feature), there will be some C++14 support, but not complete support, so the small changes (<code>T{}</code> vs. <code>T()</code>, initializing from a brace-or-equal-initializer and checking the semantic constraints for default-initialization) might not be implemented. In fact, you can even <a href=\"http://coliru.stacked-crooked.com/a/2c7985a1d27deb35\" rel=\"nofollow\">check the first</a>. Coliru lets you configure the build command, so just saying Coliru is extremely ambiguous. </p>\n<p>Either way, using N3797 to test for conforming behaviour isn't too worthwhile until enough C++14 support comes along (or at least until it's standardized). I'm tending to stick with N3485 until that happens. In this specific example, <s>I don't think there is any difference between the two standards' behaviours.</s> Check Casey's answer for how the two standards differ in this matter. You have a conversion constructor, so your objects would be default-initialized in C++11.</p>\n", "OwnerUserId": "962089", "LastEditorUserId": "962089", "LastEditDate": "2014-01-12T02:42:55.523", "Id": "20936695", "Score": "9", "CreationDate": "2014-01-05T17:25:17.453", "LastActivityDate": "2014-01-12T02:42:55.523"}, "bq_ids": {"n4140": {"so_20936574_20936695_1": {"section_id": 3304, "quality": 1.0, "length": 12}, "so_20936574_20937337_1": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_20936574_20937337_0": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_20936574_20936574_0": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_20936574_20936695_2": {"section_id": 3325, "quality": 1.0, "length": 10}, "so_20936574_20936695_0": {"section_id": 3304, "quality": 0.8333333333333334, "length": 20}, "so_20936574_20936574_1": {"section_id": 3287, "quality": 0.9523809523809523, "length": 20}, "so_20936574_20936695_3": {"section_id": 3287, "quality": 0.95, "length": 19}, "so_20936574_20936695_4": {"section_id": 3274, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_20936574_20936695_1": {"section_id": 3174, "quality": 0.75, "length": 9}, "so_20936574_20937337_1": {"section_id": 3157, "quality": 1.0, "length": 4}, "so_20936574_20936695_4": {"section_id": 3145, "quality": 0.7777777777777778, "length": 7}, "so_20936574_20936574_0": {"section_id": 3157, "quality": 1.0, "length": 4}, "so_20936574_20936695_2": {"section_id": 3195, "quality": 0.9, "length": 9}, "so_20936574_20936695_0": {"section_id": 3174, "quality": 0.7083333333333334, "length": 17}, "so_20936574_20936574_1": {"section_id": 3157, "quality": 0.9523809523809523, "length": 20}, "so_20936574_20937337_0": {"section_id": 3157, "quality": 1.0, "length": 4}}, "n4659": {"so_20936574_20936695_1": {"section_id": 4070, "quality": 1.0, "length": 12}, "so_20936574_20936695_0": {"section_id": 4070, "quality": 0.6666666666666666, "length": 16}, "so_20936574_20936695_4": {"section_id": 4032, "quality": 0.7777777777777778, "length": 7}, "so_20936574_20936695_3": {"section_id": 4049, "quality": 0.95, "length": 19}, "so_20936574_20936695_2": {"section_id": 4091, "quality": 1.0, "length": 10}}}, "20936704": {"ParentId": "20936574", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The default compilation command for Coliru is:</p>\n<pre><code>g++-4.8 -std=c++11 -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out\n</code></pre>\n<p>It uses <code>-Wall</code> which enables a wider range of warnings. To be pedantic, it enables the following warnings:</p>\n<pre><code>  -Waddress   \n  -Warray-bounds (only with -O2)  \n  -Wc++11-compat  \n  -Wchar-subscripts  \n  -Wenum-compare (in C/ObjC; this is on by default in C++) \n  -Wimplicit-int (C and Objective-C only) \n  -Wimplicit-function-declaration (C and Objective-C only) \n  -Wcomment  \n  -Wformat   \n  -Wmain (only for C/ObjC and unless -ffreestanding)  \n  -Wmaybe-uninitialized \n  -Wmissing-braces (only for C/ObjC) \n  -Wnonnull  \n  -Wopenmp-simd \n  -Wparentheses  \n  -Wpointer-sign  \n  -Wreorder   \n  -Wreturn-type  \n  -Wsequence-point  \n  -Wsign-compare (only in C++)  \n  -Wstrict-aliasing  \n  -Wstrict-overflow=1  \n  -Wswitch  \n  -Wtrigraphs  \n  -Wuninitialized  \n  -Wunknown-pragmas  \n  -Wunused-function  \n  -Wunused-label     \n  -Wunused-value     \n  -Wunused-variable  \n  -Wvolatile-register-var \n</code></pre>\n<p>More informations about those can be found <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#Warning-Options\" rel=\"nofollow\">here</a>.</p>\n<p>Even though, Ideone uses GCC 4.8 as well, chances are it doesn't set <code>-Wall</code>. As <a href=\"http://coliru.stacked-crooked.com/a/b28f451cd0f54e89\" rel=\"nofollow\">you can see</a>, without that flag, no warnings are risen on Coliru too.</p>\n<p>To be explicit: they are literally the same compiler and with the same flags they behave exactly the same, therefore they are both correct.</p>\n", "OwnerUserId": "493122", "LastEditorUserId": "493122", "LastEditDate": "2014-01-06T19:28:36.780", "Id": "20936704", "Score": "4", "CreationDate": "2014-01-05T17:25:53.887", "LastActivityDate": "2014-01-06T19:28:36.780"}});