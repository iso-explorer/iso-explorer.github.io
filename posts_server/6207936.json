post_cb({"6207936": {"CommentCount": "7", "AcceptedAnswerId": "6208032", "CreationDate": "2011-06-01T21:28:06.840", "LastActivityDate": "2011-06-01T21:48:57.873", "PostTypeId": "1", "ViewCount": "1124", "FavoriteCount": "1", "Title": "C++ typecasting vs implicit constructor", "Id": "6207936", "Score": "4", "Body": "<p>I'm implementing a c++-class representing a fraction. Here goes my code.</p>\n<pre><code>class Fraction\n{\n    public:\n        Fraction(char i);\n        Fraction(int i);\n        Fraction(short i);\n        Fraction(long int l);\n#ifdef __LP64__\n        Fraction(long long l);\n#endif\n        Fraction(float f);\n        Fraction(double d);\n        Fraction(double x, double y);\n\n        Fraction operator +() const;\n        Fraction operator -() const;\n\n        Fraction&amp; operator +=(const Fraction&amp; other);\n        Fraction&amp; operator -=(const Fraction&amp; other);\n        Fraction&amp; operator *=(const Fraction&amp; other);\n        Fraction&amp; operator /=(const Fraction&amp; other);\n\n        bool operator ==(const Fraction&amp; other);\n        bool operator !=(const Fraction&amp; other);\n        bool operator  &gt;(const Fraction&amp; other);\n        bool operator  &lt;(const Fraction&amp; other);\n        bool operator &gt;=(const Fraction&amp; other);\n        bool operator &lt;=(const Fraction&amp; other);\n\n        operator double();\n        operator float();\n\n        static void commonize(Fraction&amp; a, Fraction&amp; b);\n        void shorten();\n\n        double getNumerator();\n        double getDenominator();\n\n        friend Fraction operator +(Fraction const&amp; a, Fraction const&amp; b);\n        friend Fraction operator -(Fraction const&amp; a, Fraction const&amp; b);\n        friend Fraction operator *(Fraction const&amp; a, Fraction const&amp; b);\n        friend Fraction operator /(Fraction const&amp; a, Fraction const&amp; b);\n        friend ostream&amp; operator &lt;&lt;( ostream&amp; o, const Fraction f);\n\n    protected:\n        double numerator, denominator;\n\n};\n</code></pre>\n<p>I now have two little problems. \nNow trying to call</p>\n<pre><code>Fraction a(1, 2);\ncout &lt;&lt; (3 + a) &lt;&lt; endl;\n</code></pre>\n<p>simply results in this error:</p>\n<pre><code>fractiontest.cpp:26: error: ambiguous overload for \u2018operator+\u2019 in \u20183 + a\u2019\nfractiontest.cpp:26: note: candidates are: operator+(int, double) &lt;built-in&gt;\nfractiontest.cpp:26: note:                 operator+(int, float) &lt;built-in&gt;\n</code></pre>\n<p>All I'd really want is this:</p>\n<pre><code>explicit operator double();\nexplicit operator float();\n</code></pre>\n<p>But apparently, this doesn't work. I'd like these two cast-operators to be called iff I use the cast notation. For example <code>Fraction f(1, 2); double d = (double)(f);</code></p>\n", "Tags": "<c++><casting><type-conversion><implicit-conversion>", "OwnerUserId": "146003", "AnswerCount": "2"}, "6207966": {"ParentId": "6207936", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2011-06-01T21:31:31.827", "Score": "3", "LastEditorUserId": "500104", "LastEditDate": "2011-06-01T21:48:57.873", "Id": "6207966", "OwnerUserId": "500104", "Body": "<p>Remove the conversion operators and <code>3 + a</code> should use your friend <code>operator+</code> while implicitly converting <code>3</code> to <code>Fraction</code> via the implicit constructor <code>Fraction(int i);</code>.</p>\n<hr>\n<p><strong>Edit</strong>: On the case of the explicit conversion operators, C++0x specifically allows this:</p>\n<blockquote>\n<p id=\"so_6207936_6207966_0\">12.3.2 [class.conv.fct] p2<br>\n  A conversion function may be explicit, in which case it is only considered as a user-defined conversion for direct-initialization.</br></p>\n</blockquote>\n<p>The C++03 standard doesn't specifically mention this.</p>\n</hr>", "LastActivityDate": "2011-06-01T21:48:57.873"}, "6208032": {"ParentId": "6207936", "CommentCount": "2", "CreationDate": "2011-06-01T21:37:45.840", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "6208032", "Score": "3", "Body": "<p>By definition the conversion operators are <em>implicit</em>. You can't make them explicit.</p>\n<p>The normal solution is named member functions to do the conversion. I think you could also create a specialized template method that would look just like a <code>static_cast</code> and call through to the explicit class method.</p>\n", "LastActivityDate": "2011-06-01T21:37:45.840"}, "bq_ids": {"n4140": {"so_6207936_6207966_0": {"section_id": 392, "quality": 0.8, "length": 8}}, "n3337": {"so_6207936_6207966_0": {"section_id": 383, "quality": 0.8, "length": 8}}, "n4659": {"so_6207936_6207966_0": {"section_id": 409, "quality": 0.8, "length": 8}}}});