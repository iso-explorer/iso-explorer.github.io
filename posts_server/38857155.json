post_cb({"38857702": {"Id": "38857702", "PostTypeId": "2", "Body": "<p>To determine if the 2 expressions are equivalent for your purpose, you must study the domain of definition:</p>\n<ul>\n<li><p><code>abs(a) &lt;= b</code> is defined for all values of <code>int a</code> and <code>unsigned b</code>, with just one special case for <code>a = INT_MIN;</code>. On 2s complement architectures, <code>abs(INT_MIN)</code> is not defined but most likely evaluates to <code>INT_MIN</code>, which converted to <code>unsigned</code> as required for the <code>&lt;=</code> with an <code>unsigned</code> value, yields the correct value.</p></li>\n<li><p><code>(unsigned)(a+b) &lt;= 2*b</code> may produce a different result for <code>b &gt; UINT_MAX/2</code>.  For example, it will evaluate to false for <code>a = 1</code> and <code>b = UINT_MAX/2+1</code>. There might be more cases where you alternate formula gives an incorrect result.</p></li>\n</ul>\n<p><strong>EDIT:</strong> OK, the question was edited... and <code>b</code> is now an <code>int</code>.</p>\n<p>Note that <code>a+b</code> invokes undefined behavior in case of overflow and the same for <code>2*b</code>.  So you make the assumption that neither <code>a+b</code> nor <code>2*b</code> overflow.  Furthermore, if <code>b</code> is negative, you little trick does not work.</p>\n<p>If <code>a</code> is in the range <code>-INT_MAX/2..INT_MAX/2</code> and <code>b</code> in the range <code>0..INT_MAX/2</code>, it seems to function as expected.  The behavior is identical in C and C++.</p>\n<p>Whether it is an optimization depends completely on the compiler, command line options, hardware capabilities, surrounding code, inlining, etc.  You already address this part and tell us that you shave one or two instructions... Just remember that this kind of micro-optimization is not absolute.  Even counting instructions does not necessarily help find the <strong>best</strong> performance.  Did you perform some benchmarks to measure if this <em>optimization</em> is worthwhile? Is the difference even measurable?</p>\n<p>Micro-optimizing such a piece of code is self-defeating: it makes the code less readable and potentially incorrect. <code>b</code> might not be negative in the current version, but if the next maintainer changes that, he/she might not see the potential implications.</p>\n", "LastEditorUserId": "4593267", "LastActivityDate": "2016-08-10T10:09:10.507", "Score": "2", "CreationDate": "2016-08-09T18:11:01.377", "ParentId": "38857155", "CommentCount": "2", "OwnerUserId": "4593267", "LastEditDate": "2016-08-10T10:09:10.507"}, "38857537": {"Id": "38857537", "PostTypeId": "2", "Body": "<p>Starting with the original code with signature</p>\n<pre><code>char f2( int a, unsigned b );\n</code></pre>\n<p>this contains the expression </p>\n<pre><code>a + b\n</code></pre>\n<p>Since one of these operands has a signed and the other an (corresponding) unsigned integer type (thus they have the same \"integer conversion rank\"), then - following the \"Usual arithmetic conversions\" (\u00a7 6.3.1.8) - the operand with signed integer type is converted to the unsigned type of the other operand.</p>\n<p>Conversion to an unsigned integer type is well defined, even if the value in question cannot be represented by the new type:</p>\n<blockquote>\n<p id=\"so_38857155_38857537_0\">[..] if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type. 60</p>\n<p id=\"so_38857155_38857537_1\">\u00a7 6.3.1.3/2</p>\n</blockquote>\n<p><em>Footnote 60 just says that the described arithmetic works with the mathematical value, not the typed one.</em></p>\n<p>Now, with the updated code</p>\n<pre><code>char f2_updated( int a, int b ); // called f3 in the question\n</code></pre>\n<p>things would look different. But since <code>b</code> is assumed to be non-negative, and assuming that <code>INT_MAX &lt;= UINT_MAX</code> you can convert <code>b</code> to an <code>unsigned</code> without fearing it to have a different mathematical value afterwards. Thus you could write</p>\n<pre><code>char f2_updated( int a, int b ) {\n  return f2(a, (unsigned)b); // cast unnecessary but to make it clear\n}\n</code></pre>\n<p>Looking again at <code>f2</code> the expression <code>2*b</code> further limits the allowed range of <code>b</code> to be not larger than <code>UINT_MAX/2</code> (otherwise the mathematical result would be wrong).\nSo as long as you stay within these bounds, every thing is fine.</p>\n<p><em>Note: Unsigned types do not overflow, they \"wrap\" according to modular arithmetic.</em></p>\n<p><em>Quotes from N1570 (a C11 working draft)</em></p>\n<hr>\n<p>A final remark:</p>\n<p>IMO the only really reasonable choice to write this function is as</p>\n<pre><code>#include &lt;stdbool.h&gt;\n#include &lt;assert.h&gt;\nbool abs_bounded(int value, unsigned bound) {\n  assert(bound &lt;= (UINT_MAX / 2));\n  /* NOTE: Casting to unsigned makes the implicit conversion that\n           otherwise would happen explicit. */\n  return ((unsigned)value + bound) &lt;= (2 * bound);\n}\n</code></pre>\n<p>Using a signed type for the <code>bound</code> does not make much sense, because the absolute of a value cannot be less than a negative number. <code>abs_bounded(value, something_negative)</code> would be always false. If there's the possibility of a negative bound, then I'd catch this outside of this function (otherwise it does \"too much\"), like:</p>\n<pre><code>int some_bound;\n// ...\nif ((some_bound &gt;= 0) &amp;&amp; abs_bounded(my_value, some_bound)) {\n  // yeeeha\n}\n</code></pre>\n</hr>", "LastEditorUserId": "1116364", "LastActivityDate": "2016-08-10T08:03:20.757", "Score": "3", "CreationDate": "2016-08-09T18:00:57.210", "ParentId": "38857155", "CommentCount": "10", "OwnerUserId": "1116364", "LastEditDate": "2016-08-10T08:03:20.757"}, "38859234": {"Id": "38859234", "PostTypeId": "2", "Body": "<p>As OP wants fast and portable code (and <code>b</code> is positive), it <em>first</em> makes sense to code safely: </p>\n<pre><code>// return abs(a) &lt;= b;\ninline bool f1_safe(int a, unsigned b ) { \n  return (a &gt;= 0 &amp;&amp; a &lt;= b) || (a &lt; 0 &amp;&amp; 0u - a &lt;= b);\n}\n</code></pre>\n<p>This works for <strong>all</strong> <code>a,b</code> (assuming <code>UINT_MAX &gt; INT_MAX</code>).  Next, compare alternatives using an <em>optimized</em> compile (let the compiler do what it does best).</p>\n<hr>\n<p>The following slight variation on OP's code will work in C/C++ but risks portability issues unless \"Assuming non-negative b and no risk of overflow\" can be certain on <strong>all</strong> target machines.</p>\n<pre><code>bool f2(int a, unsigned b) { return a+b &lt;= b*2; }\n</code></pre>\n<p>In the end, OP goal of fast and portable code may find code the works optimally for the select platform, but not with others - such is micro-optimization.</p>\n</hr>", "LastEditorUserId": "2410359", "LastActivityDate": "2016-08-09T20:16:49.477", "Score": "2", "CreationDate": "2016-08-09T19:46:50.007", "ParentId": "38857155", "CommentCount": "1", "OwnerUserId": "2410359", "LastEditDate": "2016-08-09T20:16:49.477"}, "bq_ids": {"n4140": {"so_38857155_38862427_1": {"length": 9, "quality": 1.0, "section_id": 31}}, "n3337": {"so_38857155_38862427_1": {"length": 9, "quality": 1.0, "section_id": 28}}, "n4659": {"so_38857155_38862427_1": {"length": 9, "quality": 1.0, "section_id": 31}}}, "38857155": {"ViewCount": "267", "Body": "<p>I have the following function:</p>\n<pre><code>char f1( int a, unsigned b ) { return abs(a) &lt;= b; }\n</code></pre>\n<p>For execution speed, I want to rewrite it as follows:</p>\n<pre><code>char f2( int a, unsigned b ) { return (unsigned)(a+b) &lt;= 2*b; } // redundant cast\n</code></pre>\n<p>Or alternatively with this signature that could have subtle implications even for non-negative <code>b</code>:</p>\n<pre><code>char f3( int a, int b )      { return (unsigned)(a+b) &lt;= 2*b; }\n</code></pre>\n<p>Both of these alternatives work under a simple test on one platform, but I need it to portable.  Assuming non-negative <code>b</code> and no risk of overflow, is this a valid optimization for typical hardware and C compilers?  Is it also valid for C++?</p>\n<hr>\n<p><em>Note: As C++ on gcc 4.8 x86_64 with <code>-O3</code>, <code>f1()</code> uses 6 machine instructions and <code>f2()</code> uses 4.  The instructions for <code>f3()</code> are identical to those for <code>f2()</code>.  Also of interest: if <code>b</code> is given as a literal, both functions compile to 3 instructions that directly map to the operations specified in <code>f2()</code>.</em></p>\n</hr>", "Title": "Threshold an absolute value", "CreationDate": "2016-08-09T17:35:05.810", "LastActivityDate": "2016-08-10T15:34:43.640", "CommentCount": "33", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-08-09T19:20:23.820", "LastEditorUserId": "86967", "Id": "38857155", "Score": "6", "OwnerUserId": "86967", "Tags": "<c++><c><language-lawyer><undefined-behavior><micro-optimization>", "AnswerCount": "4"}, "38862427": {"Id": "38862427", "PostTypeId": "2", "Body": "<p>Yes, this is portable to compliant platforms.  The conversion from signed to unsigned is well defined:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/37450336/86967\">Conversion between signed integer and unsigned integer</a></li>\n<li><a href=\"https://stackoverflow.com/q/4975340/86967\">int to unsigned int conversion</a></li>\n<li><a href=\"https://stackoverflow.com/q/50605\">Signed to unsigned conversion in C - is it always safe?</a></li>\n</ul>\n<p>The description in the C spec is a bit contrived:</p>\n<blockquote>\n<p id=\"so_38857155_38862427_0\">if the new type is unsigned, the value is converted by repeatedly\n  adding or subtracting one more than the maximum value that can be\n  represented in the new type until the value is in the range of the new\n  type.</p>\n</blockquote>\n<p>The <a href=\"http://eel.is/c++draft/conv#integral-2\" rel=\"nofollow noreferrer\">C++ spec</a> addresses the same conversion in a more sensible way:</p>\n<blockquote>\n<p id=\"so_38857155_38862427_1\">In a two's complement representation, this conversion is conceptual\n  and there is no change in the bit pattern</p>\n</blockquote>\n<hr>\n<p>In the question, <code>f2()</code> and <code>f3()</code> achieve the same results in a <em>slightly</em> different way.</p>\n<ul>\n<li>In <code>f2()</code> the presence of the <code>unsigned</code> operand causes a conversion of the <code>signed</code> operand as required <a href=\"http://eel.is/c++draft/expr#11\" rel=\"nofollow noreferrer\">here</a> for C++.  The unsigned addition may-or-may-not then result in a wrap-around past zero, which is also well defined [citation needed].</li>\n<li>In <code>f3()</code> the addition occurs in signed representation with no trickiness, and then the result is (explicitly) converted to unsigned.  So  this is slightly simpler than <code>f2()</code> (and also more clear).</li>\n</ul>\n<p>In both cases, the you end up with the same unsigned representation of the sum, which can then be compared (as unsigned) to <code>2*b</code>.  And the <em>trick</em> of treating a signed value as an unsigned type allows you to check a two-sided range with only a single comparison.  Note also that this is a bit more flexible than using the <code>abs()</code> function since the trick doesn't require that the range be centered around zero.</p>\n<hr>\n<h2>Commentary on the \"usual arithmetic conversions\"</h2>\n<p>I think this question demonstrated that using unsigned types is generally a bad idea. Look at the confusion it caused here.</p>\n<p>It can be tempting to use <code>unsigned</code> for documentation purposes (or to take advantage of the shifted value range), but due to the conversion rules, this may tend to be a mistake. In my opinion, the \"usual arithmetic conversions\" are not sensible if you assume that arithmetic is more likely to involve negative values than to overflow signed values.</p>\n<p>I asked this followup question to clarify the point: <a href=\"https://stackoverflow.com/q/38861423/86967\">mixed-sign integer math depends on variable size</a>.  One new thing that I have learned is that mixed-sign operations are <em>not</em> generally portable because the conversion type will <a href=\"http://eel.is/c++draft/conv.prom#1\" rel=\"nofollow noreferrer\">depend on the size relative to that of <code>int</code></a>.</p>\n<p>In summary: <em>Using type declarations or casts to perform unsigned operations is a low-level coding style that should be approached with the requisite caution.</em></p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-08-10T15:34:43.640", "Score": "1", "CreationDate": "2016-08-10T00:26:50.453", "ParentId": "38857155", "CommentCount": "8", "OwnerUserId": "86967", "LastEditDate": "2017-05-23T12:02:31.270"}});