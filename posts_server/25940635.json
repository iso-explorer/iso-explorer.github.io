post_cb({"25940635": {"CommentCount": "1", "AcceptedAnswerId": "25941170", "ClosedDate": "2014-09-20T18:40:11.643", "CreationDate": "2014-09-19T18:55:00.390", "LastActivityDate": "2014-09-19T19:37:54.830", "PostTypeId": "1", "ViewCount": "347", "Title": "Should use of bit-fields of type int be discouraged?", "Id": "25940635", "Score": "1", "Body": "<p>From the Draft C++ Standard (N3337):</p>\n<blockquote>\n<p id=\"so_25940635_25940635_0\"><strong>9.6 Bit-fields</strong></p>\n<p id=\"so_25940635_25940635_1\">4 If the value <code>true</code> or <code>false</code> is stored into a bit-field of type <code>bool</code> of any size (including a one bit bit-field), the original <code>bool</code> value and the value of the bit-field shall compare equal. If the value of an enumerator is stored into a bit-field of the same enumeration type and the number of bits in the bit-field is large enough to hold all the values of that enumeration type (7.2), the original enumerator value and the value of the bit-field shall compare equal.</p>\n</blockquote>\n<p>The standard is non-committal about any such behavior for bit-fields of other types. To understand how g++ (4.7.3) deals with other types of bit-fields, I used the following test program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nenum TestEnum\n{\n   V1 = 0,\n   V2\n};\n\nstruct Foo\n{\n   bool          d1:1;\n   TestEnum      d2:1;\n   int           d3:1;\n   unsigned int  d4:1;\n};\n\nint main()\n{\n   Foo foo;\n   foo.d1 = true;\n   foo.d2 = V2;\n   foo.d3 = 1;\n   foo.d4 = 1;\n\n   std::cout &lt;&lt; std::boolalpha;\n\n   std::cout &lt;&lt; \"d1: \" &lt;&lt; foo.d1 &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"d2: \" &lt;&lt; foo.d2 &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"d3: \" &lt;&lt; foo.d3 &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"d4: \" &lt;&lt; foo.d4 &lt;&lt; std::endl;\n   std::cout &lt;&lt; std::endl;\n\n   std::cout &lt;&lt; (foo.d1 == true) &lt;&lt; std::endl;\n   std::cout &lt;&lt; (foo.d2 == V2) &lt;&lt; std::endl;\n   std::cout &lt;&lt; (foo.d3 == 1) &lt;&lt; std::endl;\n   std::cout &lt;&lt; (foo.d4 == 1) &lt;&lt; std::endl;\n\n   return 0;\n}\n</code></pre>\n<p>The output:</p>\n<pre>\nd1: true\nd2: 1\nd3: -1\nd4: 1\n\ntrue\ntrue\nfalse\ntrue\n</pre>\n<p>I was surprised by the lines of the output corresponding to <code>Foo::d3</code>. The output is the same at <a href=\"http://ideone.com/Jd1LY7\" rel=\"nofollow\">ideone.com</a>.</p>\n<p>Since the standard is non-committal about the comparision of bit-fields of type <code>int</code>, g++ does not seem to be in violation of the standard. That brings me to my questions.</p>\n<p>Is use of bit-fields of type <code>int</code> a bad idea? Should it be discouraged?</p>\n", "Tags": "<c++><bit-fields>", "OwnerUserId": "434551", "AnswerCount": "4"}, "25940744": {"ParentId": "25940635", "CommentCount": "2", "Body": "<p><code>int</code> is <code>signed</code>, and in C++ <a href=\"http://en.wikipedia.org/wiki/Two%27s_complement\" rel=\"nofollow\">Two's complement</a> can be used, so in first <code>int</code>'s byte sign may be stored. When there are 2 bits for an <code>signed int</code>, it can be equal to 1, <a href=\"http://rextester.com/RAHA98110\" rel=\"nofollow\">see it working</a>.</p>\n", "OwnerUserId": "3821804", "PostTypeId": "2", "Id": "25940744", "Score": "0", "CreationDate": "2014-09-19T19:02:43.853", "LastActivityDate": "2014-09-19T19:02:43.853"}, "25941240": {"ParentId": "25940635", "CommentCount": "0", "Body": "<p>You can absolutely use <code>unsigned</code> bit-fields of any size no greater than the size of an <code>unsigned int</code>. While <code>signed</code>  bit-fields are legal (at least if the width is greater than one), I personally prefer not to use them. If, however, you do want to use a signed bit-field, you should explicitly mark it as <code>signed</code> because it is implementation-dependent as to whether an unqualified <code>int</code> bit-field is signed or unsigned. (This is similar to <code>char</code>, but without the complicating feature of explicitly unqualified <code>char*</code> literals.)</p>\n<p>So to that extent, I agree that <code>int</code> bit-fields should be discouraged. [Note 1] While I don't know of any implementation in which an <code>int</code> bitfield is implicitly unsigned, it is certainly allowed by the standard, and consequently there is lots of opportunity for implementation-specific unanticipated behaviour if you are not explicit about signs.</p>\n<p>The standards specify that a signed integer representation consists of optional padding bits, exactly one sign bit, and value bits. While the standard does not guarantee that there is at least one value bit, -- and as the example in the OP shows, <code>gcc</code> does not insist that there be -- I think it is a plausible interpretation of the standard, since it explicitly allows there to be no padding bits, and does not have any such wording corresponding to value bits.</p>\n<p>In any case, there are only three possible signed representations allowed:</p>\n<ul>\n<li><p>2's complement, in which a single-bit field consisting of a <code>1</code> should be interpreted as <code>-1</code> </p></li>\n<li><p>1's complement and sign-magnitude. In both of these case, a single-bit field consisting of a <code>1</code> is allowed to be a trap representation, so the only number which can be represented in a 1-bit signed bit-field is <code>0</code>.</p></li>\n</ul>\n<p>Since portable code cannot assume that a 1-bit signed bit-field can represent any non-zero value, it seems reasonable to insist that a signed bit-field have at least 2 bits, regardless of whether you interpret the standard(s) to actually require that or not.</p>\n<hr>\n<p><em>Notes:</em></p>\n<ol>\n<li>Indeed, if it were not for the fact that string literals are explicitly unqualified, I would prefer to always specify <code>unsigned char</code>. But there's no way to roll-back history on that point.)</li>\n</ol>\n</hr>", "OwnerUserId": "1566221", "PostTypeId": "2", "Id": "25941240", "Score": "2", "CreationDate": "2014-09-19T19:37:54.830", "LastActivityDate": "2014-09-19T19:37:54.830"}, "25941170": {"ParentId": "25940635", "CommentCount": "0", "Body": "<p>Yes, bit fields of type <code>int</code> are a bad idea, because their signedness is implementation-defined. Use <code>signed int</code> or <code>unsigned int</code> instead.</p>\n<p>For non-bitfield declarations, the type name <code>int</code> is exactly equivalent to <code>signed int</code> (or <code>int signed</code>, or <code>signed</code>). The same pattern is followed for <code>short</code>, <code>long</code>, and <code>long long</code>: the unadorned type name is the <em>signed</em> version, and you have to add the <code>unsigned</code> keyword to name the corresponding unsigned type.</p>\n<p>Bit fields, for historical reasons, are a special case. A bit-field defined with the type <code>int</code> is equivalent <em>either</em> to the same declaration with <code>signed int</code>, or to the same declaration with <code>unsigned int</code>. The choice is implementation-defined (i.e., it's up to the compiler, not to the programmer). A bit field is the only context in which <code>int</code> and <code>signed int</code> aren't (necessarily) synonymous. The same applies to <code>char</code>, <code>short</code>, <code>long</code>, and <code>long long</code>.</p>\n<p>Quoting the C++11 standard, section 9.6 [class.bit]:</p>\n<blockquote>\n<p id=\"so_25940635_25941170_0\">It is implementation-defined whether a plain (neither explicitly\n  signed nor unsigned) <strong><code>char</code></strong>, <strong><code>short</code></strong>, <strong><code>int</code></strong>, <strong><code>long</code></strong>, or <strong><code>long long</code></strong> bit-field is\n  signed or unsigned.</p>\n</blockquote>\n<p>(I'm not entirely sure of the rationale for this. Very old versions of C didn't have the <code>unsigned</code> keyword, and unsigned bit fields are usually more useful than signed bit fields. It may be that some early C compilers implemented bit fields before the <code>unsigned</code> keyword was introduced. Making bit fields unsigned by default, even when declared as <code>int</code>, may have been just a matter of convenience. There's no real reason to keep the rule other than to avoid breaking old code.)</p>\n<p>Most bit fields are intended to be unsigned, which of course means that they should be defined that way.</p>\n<p>If you want a <em>signed</em> bit field (say, a 4-bit field that can represent values from -8 to +7, or from -7 to +7 on a non-two's-complement system), then you should explicitly define it as <code>signed int</code>. If you define it as <code>int</code>, then some compilers will treat it as <code>unsigned int</code>.</p>\n<p>If you don't care whether your bit field is signed or unsigned, then you can define it as <code>int</code> -- but if you're defining a bit field, then you almost certainly <em>do</em> care whether it's signed or unsigned.</p>\n", "OwnerUserId": "827263", "PostTypeId": "2", "Id": "25941170", "Score": "3", "CreationDate": "2014-09-19T19:33:44.910", "LastActivityDate": "2014-09-19T19:33:44.910"}, "25940931": {"ParentId": "25940635", "CommentCount": "3", "Body": "<p>This is perfectly logical. <code>int</code> is a signed integer type, and if the underlying architecture uses two's complement to represent signed integers (as all modern architectures do), then the high-order bit is the sign bit. So a 1-bit signed integer bitfield can take the values <code>0</code> or <code>-1</code>. And a 3-bit signed integer bitfield, for instance, can take values between <code>-4</code> and <code>3</code> inclusive.</p>\n<p>There is no reason for a blanket ban on signed integer bitfields, as long as you understand two's complement representation.</p>\n", "OwnerUserId": "428857", "PostTypeId": "2", "Id": "25940931", "Score": "0", "CreationDate": "2014-09-19T19:17:08.457", "LastActivityDate": "2014-09-19T19:17:08.457"}, "bq_ids": {"n4140": {"so_25940635_25940635_1": {"section_id": 5924, "quality": 1.0, "length": 45}, "so_25940635_25941170_0": {"section_id": 7212, "quality": 0.5882352941176471, "length": 10}}, "n3337": {"so_25940635_25940635_1": {"section_id": 5696, "quality": 1.0, "length": 45}, "so_25940635_25941170_0": {"section_id": 5695, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_25940635_25940635_1": {"section_id": 7398, "quality": 1.0, "length": 45}, "so_25940635_25941170_0": {"section_id": 8721, "quality": 0.5882352941176471, "length": 10}}}});