post_cb({"15185323": {"Id": "15185323", "PostTypeId": "2", "Body": "<p>It depends on your implementation, if you can do this. In portable C++ you can't. And even if you can, you need explicit casts (in this case <code>reinterpret_cast&lt;&gt;</code>) to convert between different pointer types.</p>\n<p>Note that this does not extend to real \"method\" pointers, that is to <strong>non-static</strong> member function pointers. You cannot convert between member function pointers and either object pointers or ordinary function pointers. The approach I present at the end can be used, if you <strong>only</strong> have non-static member function pointers.  </p>\n<p>Portably <code>reinterpret_cast&lt;&gt;</code> can freely convert between function pointer types and object pointer types - although any use of the result except conversion back to the original type is undefined in almost all cases.</p>\n<p>For conversions between object pointer types and function pointer types, the C++11 standard says (\u00a75.2.10 [expr.reinterpret.cast]/8):</p>\n<blockquote>\n<p id=\"so_15184050_15185323_0\">Converting a function pointer to an object pointer type or vice versa\n  is conditionally-supported. The meaning of such a conversion is\n  implementation-defined, except that if an implementation supports\n  conversions in both directions, converting a prvalue of one type to\n  the other type and back, possibly with different cv- qualification,\n  shall yield the original pointer value.</p>\n</blockquote>\n<p>So, it depends on your implementation (and should be documented in its documentation), if casting a function pointer to a <code>void *</code> compiles and back compiles at all. Alas, if it does, you should get the expected behavior.</p>\n<p>In your code the casts are missing. You need a cast to the generic type (in your case <code>void*</code>) in <code>getFunction</code> and you need to cast back to the original type in order to call the function. So you will need to know the original type in <code>main()</code>:</p>\n<pre><code>void* pluginFunction = getFunction(\"Bool\",\"\");\n// ....\ncout &lt;&lt; \"Bool function -&gt;\"&lt;&lt; (reinterpret_cast&lt;bool (*)()&gt;(pluginFunction))()&lt;&lt;endl;\n</code></pre>\n<p>A more portable solution would be to use an arbitrary function pointer type, for example <code>void (*)()</code> to pass plugin function pointers around, so that you have:</p>\n<pre><code>typedef void (*any_func_ptr)();\n\n// If you wanted to use this for non-static member functions, you could do\n//   struct AnyClass;\n//   typedef void (AnyClass::*any_memfun_ptr)();\n\nany_func_ptr getFunction(string pluginName, string functionName)\n{\n    if(pluginName ==\"Bool\"){\n        return reinterpret_cast&lt;any_func_ptr&gt;(&amp;Plugin::doBoolStuff);\n    }else{\n        return NULL;\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    any_func_ptr pluginFunction = getFunction(\"Bool\",\"\");\n\n    if(reinterpret_cast&lt;bool (*)()&gt;(pluginFunction) == \n         &amp;Plugin::doBoolStuff)\n             cout&lt;&lt;\"CastSuccesful!\"&lt;&lt;endl;\n\n    cout &lt;&lt; \"Bool function -&gt;\"&lt;&lt; (reinterpret_cast&lt;bool (*)()&gt;(pluginFunction))()&lt;&lt;endl;\n\n}\n</code></pre>\n", "LastActivityDate": "2013-03-03T11:48:52.933", "CommentCount": "0", "CreationDate": "2013-03-03T11:48:52.933", "ParentId": "15184050", "Score": "0", "OwnerUserId": "585729"}, "bq_ids": {"n4140": {"so_15184050_15185323_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 6047}}, "n3337": {"so_15184050_15185323_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 5815}}, "n4659": {"so_15184050_15185323_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 7546}}}, "15184050": {"ViewCount": "2872", "Body": "<p>Im learning C++ at the moment, and am having some issues with casting pointers. In the first place I am not sure that what I am trying to do is what I want to do.. </p>\n<p>I am trying to take a function that can return the appropriate pointer to various method pointers based on string parameters, and to then use the method pointer.</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\ntypedef void* (*plugin_function)(void*);\n\nstatic class Plugin\n{\npublic:\n    static bool doBoolStuff(){\n        return true;// A Simple function that returns true\n    }\n};\n\nvoid* getFunction(string pluginName, string functionName)\n{\n    if(pluginName ==\"Bool\"){\n        return &amp;Plugin::doBoolStuff;\n            //If the string is right it should return a method pointer.\n            //I think that void* has the ability to point to anything, I am trying\n            //to use that functionality to create a system where I am able to set \n            //some parameters and get the appropriate method pointer.\n    }else{\n        return NULL;\n    }\n}\n\nint main(int argc, _TCHAR* argv[])\n{\n    void* pluginFunction;\n    pluginFunction = getFunction(\"Bool\",\"\");\n\n    if(pluginFunction == &amp;Plugin::doBoolStuff)cout&lt;&lt;\"CastSuccesful!\"&lt;&lt;endl;\n\n    //This section right here is where my code is breaking.\n    //\n    // IntelliSense: expression preceding parentheses of apparent call must have              \n    //(pointer-to-) function type   \n    //c:\\Users\\Walter\\Dropbox\\Inscription\\MethodCasting\\MethodCasting\\MethodCasting.cpp \n    //MethodCasting\n\n    cout &lt;&lt; \"Bool function -&gt;\"&lt;&lt; pluginFunction()&lt;&lt;endl;\n    cout &lt;&lt; \"--------------------------------\"&lt;&lt;endl;\n    system(\"pause\");\n\n}\n</code></pre>\n<p>Any feedback would be helpful.</p>\n", "AcceptedAnswerId": "15184139", "Title": "c++ pointer casting help, void* to boolean", "CreationDate": "2013-03-03T08:52:33.010", "Id": "15184050", "CommentCount": "9", "LastEditDate": "2013-03-03T08:55:06.480", "PostTypeId": "1", "LastEditorUserId": "253056", "LastActivityDate": "2013-03-03T11:48:52.933", "Score": "2", "OwnerUserId": "1781412", "Tags": "<c++><pointers><plugins><casting>", "AnswerCount": "3"}, "15184139": {"Id": "15184139", "PostTypeId": "2", "Body": "<p><strong>Edit:</strong> Not true, sorry. As @Stephen Lin pointed out, I failed to read the <code>static</code> modifier... So while what you want doesn't work for non-static member functions, it usually does work for static members using <code>reinterpret_cast</code> (this behavior is implementation-defined):</p>\n<pre><code>class Plugin {\n    public:\n    static bool foo()\n    {\n        std::cout &lt;&lt; \"Foo called!\" &lt;&lt; std::endl;\n        return true;\n    }\n};\n\nvoid *get_func()\n{\n    return reinterpret_cast&lt;void *&gt;(&amp;Plugin::foo);\n}\n\nint main()\n{\n    void *pluginFunction = get_func();\n    (reinterpret_cast&lt;bool (*)()&gt;(pluginFunction))();\n    return 0;\n}\n</code></pre>\n<p><em>Original post:</em></p>\n<hr>\n<p>You can't. According to <a href=\"http://sphaleron.blogspot.hu/2012/01/evil-c-5-member-function-pointer.html\" rel=\"nofollow\">this article</a>:</p>\n<blockquote>\n<p id=\"so_15184050_15184139_0\">However, there is no way to cast the <code>void *</code> back to a member function pointer that you could actually use.</p>\n</blockquote>\n<p>I've tried it myself. Actually, all of <code>static_cast</code>, <code>reinterpret_cast</code> and even old C-style casts refused to work - neither with <code>void *</code>, nor with <code>bool (*)()</code> (yes, I've even tried to cast from a non-member function pointer type to a member function type)...</p>\n<p>Sorry, C++ doesn't seem to allow us to do this.</p>\n</hr>", "LastEditorDisplayName": "user529758", "OwnerDisplayName": "user529758", "LastActivityDate": "2013-03-03T09:53:10.037", "Score": "2", "CreationDate": "2013-03-03T09:06:50.860", "ParentId": "15184050", "CommentCount": "11", "LastEditDate": "2013-03-03T09:53:10.037"}, "15184094": {"Id": "15184094", "PostTypeId": "2", "Body": "<p>Some modifications, However we should minimize castings, but one possibility is:</p>\n<pre><code>plugin_function getFunction(string pluginName, string functionName)\n{\n    if (pluginName == \"Bool\")\n    {\n        return (plugin_function)Plugin::doBoolStuff;\n</code></pre>\n<p>And</p>\n<pre><code>int main(int argc, _TCHAR* argv[])\n{\n    typedef bool (*Func)();\n    Func pluginFunction = (Func)getFunction(\"Bool\", \"\");\n</code></pre>\n<p>The output</p>\n<blockquote>\n<p id=\"so_15184050_15184094_0\">CastSuccesful!</p>\n<p id=\"so_15184050_15184094_1\">Bool function -&gt;1</p>\n</blockquote>\n", "LastEditorUserId": "952747", "LastActivityDate": "2013-03-03T09:12:30.127", "Score": "0", "CreationDate": "2013-03-03T09:00:20.427", "ParentId": "15184050", "CommentCount": "2", "OwnerUserId": "952747", "LastEditDate": "2013-03-03T09:12:30.127"}});