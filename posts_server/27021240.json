post_cb({"bq_ids": {"n4140": {"so_27021240_27021316_0": {"length": 50, "quality": 0.9259259259259259, "section_id": 235}, "so_27021240_27021316_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 242}, "so_27021240_27021316_3": {"length": 63, "quality": 0.9692307692307692, "section_id": 175}, "so_27021240_27021316_4": {"length": 72, "quality": 0.9473684210526315, "section_id": 243}}, "n3337": {"so_27021240_27021316_0": {"length": 50, "quality": 0.9259259259259259, "section_id": 228}, "so_27021240_27021316_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 234}, "so_27021240_27021316_3": {"length": 63, "quality": 0.9692307692307692, "section_id": 169}, "so_27021240_27021316_4": {"length": 70, "quality": 0.9210526315789473, "section_id": 235}}, "n4659": {"so_27021240_27021316_0": {"length": 50, "quality": 0.9259259259259259, "section_id": 245}, "so_27021240_27021316_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 249}, "so_27021240_27021316_3": {"length": 42, "quality": 0.6461538461538462, "section_id": 180}, "so_27021240_27021316_4": {"length": 70, "quality": 0.9210526315789473, "section_id": 250}}}, "27021489": {"Id": "27021489", "PostTypeId": "2", "Body": "<p>This is not an answer from the inner question, but it is related about the assumption of the question: \"I would expect no compiler error if the first overload was not instantiated, however I get the error.\"</p>\n<p>Sure? so, why this code generate a compiler error?</p>\n<pre><code>template&lt;typename T&gt;\nvoid nil(T) {zzz}\n\ntemplate&lt;typename T&gt;\nvoid foo(T*) {}\n\nint main()\n{\n    int* blah;\n    foo(blah);\n}\n</code></pre>\n<p>because <code>nil</code> is not instantiated</p>\n", "LastActivityDate": "2014-11-19T16:08:26.053", "CommentCount": "3", "CreationDate": "2014-11-19T16:08:26.053", "ParentId": "27021240", "Score": "2", "OwnerUserId": "2293156"}, "27021316": {"Id": "27021316", "PostTypeId": "2", "Body": "<p>It seems as though you're expecting only one of those overloads to be instantiated because only one of them will be called, but the compiler clearly has to instantiate both of them in order to determine whether either of them can be called and, if so, which one to use.</p>\n<p>The more formal answer is that both templates are candidates because your <code>T</code> can always be pointerised, so both are \"used\" in that sense:</p>\n<blockquote>\n<p id=\"so_27021240_27021316_0\"><code>[C++14: 14.7.1/3]:</code> <strong>Unless a function template specialization has been explicitly instantiated or explicitly specialized, the function template specialization is implicitly instantiated when the specialization is referenced in a context that requires a function definition to exist.</strong> Unless a call is to a function template explicit specialization or to a member function of an explicitly specialized class template, a default argument for a function template or a member function of a class template is implicitly instantiated when the function is called in a context that requires the value of the default argument.</p>\n<p id=\"so_27021240_27021316_1\"><code>[C++14: 14.7.1/10]:</code> <strong>If a function template or a member function template specialization is used in a way that involves overload resolution, a declaration of the specialization is implicitly instantiated</strong> (14.8.3).</p>\n</blockquote>\n<p>So, basically:</p>\n<blockquote>\n<p id=\"so_27021240_27021316_2\">I guess this is required so that the compiler can perform overload resolution?</p>\n</blockquote>\n<p>Correct.</p>\n<p>Your question, however, already stems from a misconception that your first function template <em>can</em> be ignored: it can't be. <code>zzz</code> does not depend on any template parameters so SFINAE is not involved; even if SFINAE were involved, it could not help you with your invalid syntax. So, no matter what you do, that code is ill-formed:</p>\n<pre><code>template&lt;typename T&gt;\nvoid nil() {zzz}\n\n// g++ -c -std=c++11 -O2 -Wall -pedantic -pthread main.cpp\n// main.cpp: In function 'void nil()':\n// main.cpp:2:13: error: 'zzz' was not declared in this scope\n//  void nil() {zzz}\n//              ^\n</code></pre>\n<p>(<a href=\"http://coliru.stacked-crooked.com/a/851c3d9c222c5452\" rel=\"nofollow noreferrer\">live demo</a>)</p>\n<p>That being said, a diagnostic is not <em>required</em> in this case; in particular, <a href=\"https://stackoverflow.com/q/10323980/560648\">Microsoft Visual Studio has historically silently accepted such code</a>:</p>\n<blockquote>\n<p id=\"so_27021240_27021316_3\"><code>[C++14: 14.6/8]:</code> Knowing which names are type names allows the syntax of every template to be checked. No diagnostic shall be issued for a template for which a valid specialization can be generated. <strong>If no valid specialization can be generated for a template, and that template is not instantiated, the template is ill-formed, no diagnostic required.</strong> If every valid specialization of a variadic template requires an empty template parameter pack, the template is ill-formed, no diagnostic required. If a type used in a non-dependent name is incomplete at the point at which a template is defined but is complete at the point at which an instantiation is done, and if the completeness of that type affects whether or not the program is well-formed or affects the semantics of the program, the program is ill-formed; no diagnostic is required. <em>[..]</em></p>\n</blockquote>\n<p>The same wording may also be found in C++11 and C++03, so this has always been the case. Your misconception is therefore understandable.</p>\n<p>Incidentally, your observation regarding virtual functions is also not completely accurate:</p>\n<blockquote>\n<p id=\"so_27021240_27021316_4\"><code>[C++14: 14.7.1/11]</code>: An implementation shall not implicitly instantiate a function template, a variable template, a member template, a non-virtual member function, a member class, or a static data member of a class template that does not require instantiation. <strong>It is unspecified whether or not an implementation implicitly instantiates a virtual member function of a class template if the virtual member function would not otherwise be instantiated.</strong> The use of a template specialization in a default argument shall not cause the template to be implicitly instantiated except that a class template may be instantiated where its complete type is needed to determine the correctness of the default argument. The use of a default argument in a function call causes specializations in the default argument to be implicitly instantiated.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-19T16:58:03.900", "Score": "5", "CreationDate": "2014-11-19T15:59:32.297", "ParentId": "27021240", "CommentCount": "15", "OwnerUserId": "560648", "LastEditDate": "2017-05-23T12:12:44.983"}, "27021240": {"ViewCount": "152", "Body": "<p>I'm aware that the compiler will not instantiation unused template functions as long as they are not virtual in a class.</p>\n<p>In a simple case, if I have two overloaded template functions both of which take the same template arguments, it seems the compiler instantiates both overloads. I guess this is required so that the compiler can perform overload resolution? Are overloads exempt from the lazy-instantiation rule for function templates? I wasn't able to find the relevant text in the standard. Here is an example:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T) {zzz}\n\ntemplate&lt;typename T&gt;\nvoid foo(T*) {}\n\nint main()\n{\n    int* blah;\n    foo(blah);\n}\n</code></pre>\n<p>I would expect no compiler error if the first overload was not instantiated, however I get the error.</p>\n<p><a href=\"http://ideone.com/pQl0Wo\" rel=\"nofollow\">Live Sample</a></p>\n", "AcceptedAnswerId": "27021316", "Title": "Instantiation of template function overloads", "CreationDate": "2014-11-19T15:56:34.987", "Id": "27021240", "CommentCount": "4", "LastEditDate": "2014-11-19T16:03:33.977", "PostTypeId": "1", "LastEditorUserId": "560648", "LastActivityDate": "2014-11-19T16:58:03.900", "Score": "1", "OwnerUserId": "157971", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}});