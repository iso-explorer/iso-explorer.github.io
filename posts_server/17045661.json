post_cb({"17046231": {"ParentId": "17045661", "LastEditDate": "2013-06-11T14:39:03.597", "CommentCount": "5", "CreationDate": "2013-06-11T14:09:15.570", "OwnerUserId": "1838266", "LastEditorUserId": "2380830", "PostTypeId": "2", "Id": "17046231", "Score": "10", "Body": "<p>From the C++11 standard (<strong>\u00a77.2,6</strong>, emphasis mine):</p>\n<blockquote>\n<p id=\"so_17045661_17046231_0\">For an enumeration whose underlying type is not fixed, <strong>the underlying type is an integral type that can represent all the enumerator values</strong> defined in the enumeration. If no integral type can represent all the enumerator values, the enumeration is ill-formed. It is implementation-defined which integral type is used as the underlying type except that the underlying type shall not be larger than int unless the value of an enumerator cannot fit in an int or unsigned int.</p>\n</blockquote>\n<p>So the compiler will happily do The Right Thing if there is an integral type bigger than 32bit. If not, the enum is illformed. There will be no wrapping around.</p>\n<p>The values will be:</p>\n<pre><code>enum foo {\n    val1 =                       0x7FFFFFFF, \n    val2,              //        0x80000000   = 2^31\n    val3 =                       0xFFFFFFFF, \n    val4,              //0x0000000100000000   = 2^32\n    val5               //0x0000000100000001   = 2^32+1\n};\n</code></pre>\n<p>The increasing numbers are well defined as well (<strong>\u00a77.2,2</strong>):</p>\n<blockquote>\n<p id=\"so_17045661_17046231_1\">[...] An enumerator-definition without an initializer gives the enumerator the value obtained by increasing the value of the previous enumerator by one.</p>\n</blockquote>\n", "LastActivityDate": "2013-06-11T14:39:03.597"}, "17046145": {"ParentId": "17045661", "LastEditDate": "2013-06-11T14:31:42.670", "CommentCount": "4", "CreationDate": "2013-06-11T14:05:22.783", "OwnerUserId": "8922", "LastEditorUserId": "8922", "PostTypeId": "2", "Id": "17046145", "Score": "2", "Body": "<p>Here's the C++ answer: in 7.2/6, it states:</p>\n<blockquote>\n<p id=\"so_17045661_17046145_0\">[...] the underlying type is an integral type that can represent all\n  the enumerator values defined in the enumeration. If no integral type\n  can represent all the enumerator values, the enumeration is\n  ill-formed. It is implementation-defined which integral type is used\n  as the underlying type except that the underlying type shall not be\n  larger than int unless the value of an enumerator cannot fit in an int\n  or unsigned int.</p>\n</blockquote>\n<p>So compared to C: no undefined behavior if the compiler can't find a type, and the compiler can't just use its 512-bit extended integer type for your two-value enum.</p>\n<p>Which means that in your example, the underlying type will <em>probably</em> be some signed 64-bit type - most compilers always try the signed version of a type first.</p>\n", "LastActivityDate": "2013-06-11T14:31:42.670"}, "17046802": {"ParentId": "17045661", "LastEditDate": "2013-06-11T15:42:43.787", "CommentCount": "2", "CreationDate": "2013-06-11T14:36:36.940", "OwnerUserId": "420683", "LastEditorUserId": "420683", "PostTypeId": "2", "Id": "17046802", "Score": "4", "Body": "<h1>C99 / C11</h1>\n<h3>Prelude:</h3>\n<p><strong>5.2.4.2.1</strong> requires <code>int</code> to be <em>at least</em> 16 bits wide; AFAIK there's no upper bound (<code>long</code> must be longer or equal, though, 6.2.5 /8).</p>\n<p><strong>6.5 /5:</strong></p>\n<blockquote>\n<p id=\"so_17045661_17046802_0\">If an exceptional condition occurs during the evaluation of an expression (that is, if the result is not mathematically defined or <strong>not in the range of representable values for its type</strong>), the behavior is undefined.</p>\n</blockquote>\n<hr>\n<h3>If your `int` is 32 bits wide (or less)</h3>\n<p>then the example in the OP is a violation of <strong>constraint 6.7.2.2 /2</strong>:</p>\n<blockquote>\n<p id=\"so_17045661_17046802_1\">The expression that defines the value of an enumeration constant shall be an integer\n  constant expression that has a value representable as an <code>int</code>.</p>\n</blockquote>\n<p>Furthermore, the enumerators are defined as constant of type <code>int</code>, <strong>6.7.2.2 /3</strong>:</p>\n<blockquote>\n<p id=\"so_17045661_17046802_2\">The identifiers in an enumerator list are declared as constants that have type <code>int</code> and\n  may appear wherever such are permitted.</p>\n</blockquote>\n<p><br/></p>\n<p>Note, there's a difference between the <em>type of the enumeration</em> and the <em>type of an enumerator / enumeration constant</em>:</p>\n<pre><code>enum foo { val0 };\nenum foo myVariable;        // myVariable has the type of the enumeration\nuint_least8_t v = val0*'c'; // if val0 appears in any expression, it has type int\n</code></pre>\n<p><br/></p>\n<p>It seems to me this allows narrowing, e.g. reducing the size of the enum <em>type</em> to 8 bits:</p>\n<pre><code>enum foo { val1 = 1, val2 = 5 };\nenum foo myVariable = val1;    // allowed to be 8-bit\n</code></pre>\n<p>But it seems to <em>disallow</em> widening, e.g.</p>\n<pre><code>enum foo { val1 = INT_MAX+1 }; // constraint violation AND undefined behaviour\n// not sure about the following, we're already in UB-land\nenum foo myVariable = val1;    // maximum value of an enumerator still is INT_MAX\n                               // therefore myVariable will have sizeof int\n</code></pre>\n<hr>\n<h3>Auto-increment of enumerators</h3>\n<p>Because of 6.7.2.2 /3,</p>\n<blockquote>\n<p id=\"so_17045661_17046802_3\">[...] Each subsequent enumerator with no <code>=</code> defines its enumeration constant as the value of the <strong>constant expression obtained by adding 1</strong> to the value of the previous enumeration constant. [...]</p>\n</blockquote>\n<p>the example results in UB:</p>\n<pre><code>enum foo {\n    val0 = INT_MAX,\n    val1            // equivalent to `val1 = INT_MAX+1`\n};\n</code></pre>\n</hr></hr>", "LastActivityDate": "2013-06-11T15:42:43.787"}, "17045752": {"ParentId": "17045661", "CommentCount": "8", "Body": "<p>In C standard:</p>\n<blockquote>\n<h3>C11 (n1570), \u00a7 6.7.2.2 Enumeration specifiers</h3>\n<p id=\"so_17045661_17045752_0\">Each enumerated type shall be compatible with <code>char</code>, a signed integer type, or an unsigned integer type. The choice of type is implementation-defined, but <strong>shall be capable of representing the values of all the members of the enumeration</strong>. </p>\n</blockquote>\n<p>If the underlying type used by the compiler is not capable to represent these values, the behavior is undefined.</p>\n<blockquote>\n<h3>C11 (n1570), \u00a7 4. Conformance</h3>\n<p id=\"so_17045661_17045752_1\">If a \u2018\u2018shall\u2019\u2019 or \u2018\u2018shall not\u2019\u2019 requirement that appears outside of a constraint or runtime-constraint is violated, the behavior is undefined.</p>\n</blockquote>\n", "OwnerUserId": "1126268", "PostTypeId": "2", "Id": "17045752", "Score": "16", "CreationDate": "2013-06-11T13:46:46.013", "LastActivityDate": "2013-06-11T13:46:46.013"}, "bq_ids": {"n4140": {"so_17045661_17046231_1": {"section_id": 5461, "quality": 1.0, "length": 11}, "so_17045661_17046802_0": {"section_id": 5937, "quality": 0.8125, "length": 13}, "so_17045661_17046145_0": {"section_id": 5466, "quality": 0.9736842105263158, "length": 37}, "so_17045661_17046231_0": {"section_id": 5466, "quality": 0.9545454545454546, "length": 42}, "so_17045661_17046802_1": {"section_id": 5464, "quality": 0.5833333333333334, "length": 7}}, "n3337": {"so_17045661_17046231_1": {"section_id": 5248, "quality": 1.0, "length": 11}, "so_17045661_17046145_0": {"section_id": 5252, "quality": 0.9736842105263158, "length": 37}, "so_17045661_17046802_0": {"section_id": 5709, "quality": 0.8125, "length": 13}, "so_17045661_17046802_3": {"section_id": 5251, "quality": 0.5625, "length": 9}, "so_17045661_17046231_0": {"section_id": 5252, "quality": 0.9545454545454546, "length": 42}}, "n4659": {"so_17045661_17046231_1": {"section_id": 6895, "quality": 1.0, "length": 11}, "so_17045661_17046802_0": {"section_id": 7421, "quality": 0.8125, "length": 13}, "so_17045661_17046145_0": {"section_id": 6900, "quality": 0.9736842105263158, "length": 37}, "so_17045661_17046802_1": {"section_id": 6898, "quality": 0.5833333333333334, "length": 7}, "so_17045661_17046231_0": {"section_id": 6900, "quality": 0.9545454545454546, "length": 42}}}, "17045661": {"CommentCount": "12", "CreationDate": "2013-06-11T13:42:50.837", "PostTypeId": "1", "AcceptedAnswerId": "17046231", "LastEditorUserId": "573032", "LastActivityDate": "2016-03-15T19:12:50.827", "LastEditDate": "2016-03-15T19:12:50.827", "ViewCount": "1399", "FavoriteCount": "3", "Title": "Are there any guarantees on the representation of large enum values?", "Id": "17045661", "Score": "28", "Body": "<p>Suppose I have (on a 32 bit machine)</p>\n<pre><code>enum foo {\n    val1 = 0x7FFFFFFF, // originally '2^31 - 1'\n    val2,\n    val3 = 0xFFFFFFFF, // originally '2^32 - 1'\n    val4,\n    val5\n};\n</code></pre>\n<p>what is the value of val2, val4 and val5? I know I could test it, but is the result <em>standardized</em>?</p>\n", "Tags": "<c++><c><enums>", "OwnerUserId": "2380830", "AnswerCount": "4"}});