post_cb({"bq_ids": {"n4140": {"so_15031198_15032236_6": {"length": 5, "quality": 1.0, "section_id": 336}, "so_15031198_15032236_2": {"length": 9, "quality": 1.0, "section_id": 336}, "so_15031198_15032236_3": {"length": 14, "quality": 1.0, "section_id": 336}, "so_15031198_15032236_8": {"length": 11, "quality": 1.0, "section_id": 336}, "so_15031198_15032236_7": {"length": 9, "quality": 1.0, "section_id": 336}, "so_15031198_15032236_4": {"length": 18, "quality": 0.9473684210526315, "section_id": 336}, "so_15031198_15032236_10": {"length": 9, "quality": 1.0, "section_id": 336}, "so_15031198_15032236_9": {"length": 5, "quality": 1.0, "section_id": 336}, "so_15031198_15032236_5": {"length": 11, "quality": 1.0, "section_id": 336}, "so_15031198_15032236_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 336}}, "n3337": {"so_15031198_15032236_8": {"length": 11, "quality": 1.0, "section_id": 326}, "so_15031198_15032236_2": {"length": 9, "quality": 1.0, "section_id": 326}, "so_15031198_15032236_3": {"length": 14, "quality": 1.0, "section_id": 326}, "so_15031198_15032236_7": {"length": 9, "quality": 1.0, "section_id": 326}, "so_15031198_15032236_4": {"length": 18, "quality": 0.9473684210526315, "section_id": 326}, "so_15031198_15032236_10": {"length": 9, "quality": 1.0, "section_id": 326}, "so_15031198_15032236_9": {"length": 5, "quality": 1.0, "section_id": 326}, "so_15031198_15032236_6": {"length": 5, "quality": 1.0, "section_id": 326}, "so_15031198_15032236_5": {"length": 11, "quality": 1.0, "section_id": 326}, "so_15031198_15032236_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 326}}, "n4659": {"so_15031198_15032236_8": {"length": 11, "quality": 1.0, "section_id": 345}, "so_15031198_15032236_2": {"length": 9, "quality": 1.0, "section_id": 345}, "so_15031198_15032236_3": {"length": 14, "quality": 1.0, "section_id": 345}, "so_15031198_15032236_4": {"length": 18, "quality": 0.9473684210526315, "section_id": 345}, "so_15031198_15032236_10": {"length": 9, "quality": 1.0, "section_id": 345}, "so_15031198_15032236_9": {"length": 5, "quality": 1.0, "section_id": 345}, "so_15031198_15032236_6": {"length": 5, "quality": 1.0, "section_id": 345}, "so_15031198_15032236_5": {"length": 11, "quality": 1.0, "section_id": 345}, "so_15031198_15032236_7": {"length": 9, "quality": 1.0, "section_id": 345}, "so_15031198_15032236_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 345}}}, "15031198": {"ViewCount": "697", "Body": "<p>Consider the following code and the <code>apply</code> function :</p>\n<pre><code>// Include\n#include &lt;iostream&gt;\n#include &lt;array&gt;\n#include &lt;type_traits&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n\n// Just a small class to illustrate my question\ntemplate &lt;typename Type, unsigned int Size&gt;\nclass Array\n{\n    // Class body (forget that, this is just for the example)\n    public:\n        template &lt;class... Args&gt; Array(const Args&amp;... args) : _data({{args...}}) {;}\n        inline Type&amp; operator[](unsigned int i) {return _data[i];}\n        inline const Type&amp; operator[](unsigned int i) const {return _data[i];}\n        inline std::string str() \n        { \n            std::ostringstream oss; \n            for (unsigned int i = 0; i &lt; Size; ++i) \n                oss&lt;&lt;((*this)[i])&lt;&lt;\" \"; \n            return oss.str();\n        }\n    protected:\n        std::array&lt;Type, Size&gt; _data;\n    // Apply declaration\n    public:\n        template &lt;typename Return, \n                  typename SameType, \n                  class... Args, \n                  class = typename std::enable_if&lt;std::is_same&lt;typename std::decay&lt;SameType&gt;::type, Type&gt;::value&gt;::type&gt; \n        inline Array&lt;Return, Size&gt; apply(Return (*f)(SameType&amp;&amp;, Args&amp;&amp;...), const Array&lt;Args, Size&gt;&amp;... args) const;\n}; \n\n// Apply definition\ntemplate &lt;typename Type, unsigned int Size&gt;\ntemplate &lt;typename Return, typename SameType, class... Args, class&gt; \ninline Array&lt;Return, Size&gt; Array&lt;Type, Size&gt;::\napply(Return (*f)(SameType&amp;&amp;, Args&amp;&amp;...), const Array&lt;Args, Size&gt;&amp;... args) const\n{\n    Array&lt;Return, Size&gt; result; \n    for (unsigned int i = 0; i &lt; Size; ++i) {\n        result[i] = f((*this)[i], args[i]...);\n    }\n    return result;\n}\n\n// Example\nint main(int argc, char *argv[])\n{\n    Array&lt;int, 3&gt; x(1, 2, 3);\n    std::cout&lt;&lt;x.str()&lt;&lt;std::endl;\n    std::cout&lt;&lt;x.apply(std::sin).str()&lt;&lt;std::endl;\n    return 0;\n}\n</code></pre>\n<p>The compilation fails with :</p>\n<pre><code>universalref.cpp: In function \u2018int main(int, char**)\u2019:\nuniversalref.cpp:45:32: erreur: no matching function for call to \u2018Array&lt;int, 3u&gt;::apply(&lt;unresolved overloaded function type&gt;)\u2019\nuniversalref.cpp:45:32: note: candidate is:\nuniversalref.cpp:24:200: note: template&lt;class Return, class SameType, class ... Args, class&gt; Array&lt;Return, Size&gt; Array::apply(Return (*)(SameType&amp;&amp;, Args&amp;&amp; ...), const Array&lt;Args, Size&gt;&amp; ...) const [with Return = Return; SameType = SameType; Args = {Args ...}; &lt;template-parameter-2-4&gt; = &lt;template-parameter-1-4&gt;; Type = int; unsigned int Size = 3u]\nuniversalref.cpp:24:200: note:   template argument deduction/substitution failed:\nuniversalref.cpp:45:32: note:   mismatched types \u2018SameType&amp;&amp;\u2019 and \u2018long double\u2019\nuniversalref.cpp:45:32: note:   mismatched types \u2018SameType&amp;&amp;\u2019 and \u2018float\u2019\nuniversalref.cpp:45:32: note:   mismatched types \u2018SameType&amp;&amp;\u2019 and \u2018double\u2019\nuniversalref.cpp:45:32: note:   couldn't deduce template parameter \u2018Return\u2019\n</code></pre>\n<p>I am not very sure why it fails.\nIn that code, I would like :</p>\n<ul>\n<li>to keep universal references to have the most generic function</li>\n<li>to be able to use the syntax <code>apply(std::sin)</code> </li>\n</ul>\n<p>So what do I have to change to make it compile ?</p>\n", "AcceptedAnswerId": "15032236", "Title": "Templates, variadic function, universal references and function pointer : an explosive cocktail", "CreationDate": "2013-02-22T18:52:44.287", "Id": "15031198", "CommentCount": "2", "LastEditDate": "2013-02-22T23:19:40.087", "PostTypeId": "1", "LastEditorUserId": "636019", "LastActivityDate": "2013-02-22T23:19:40.087", "Score": "2", "OwnerUserId": "882932", "Tags": "<c++><templates><c++11><function-pointers><variadic-templates>", "AnswerCount": "1"}, "15032236": {"Id": "15032236", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/numeric/math/sin\" rel=\"nofollow\">Several overloads exist</a> of function <code>std::sin</code>, and your function template has no way of deducing one that would produce an <strong>exact match</strong> (in most situations, no conversions are not considered when deducing template arguments). </p>\n<p>First of all, none of those overlads accepts a <em>reference</em> to their first (and only) argument. The compiler is telling you this, so <code>Return</code> and <code>SameType</code> cannot be deduced from the type of argument <code>f</code>:</p>\n<pre><code>universalref.cpp:24:200: note:   template argument deduction/substitution failed:\nuniversalref.cpp:45:32: note:   mismatched types \u2018SameType&amp;&amp;\u2019 and \u2018long double\u2019\nuniversalref.cpp:45:32: note:   mismatched types \u2018SameType&amp;&amp;\u2019 and \u2018float\u2019\nuniversalref.cpp:45:32: note:   mismatched types \u2018SameType&amp;&amp;\u2019 and \u2018double\u2019\n</code></pre>\n<p>Therefore, the first step consists in changing the signature of your <code>apply()</code> function template:</p>\n<pre><code>[...] apply(Return (*f)(SameType, Args&amp;&amp;...), [...]\n                        ^^^^^^^^\n                        No URef!\n</code></pre>\n<p>Moreover, SFINAE is eliminating all instantiations of your function template where <code>Return</code> is not deduced to be <code>int</code> (you are invoking <code>apply()</code> on an instance of <code>Array&lt;int, 3&gt;</code>): unfortunately, none of the existing overloads of <code>std::sin</code> has <code>int</code> as a return type.</p>\n<p>You could try changing your instantiation into <code>Array&lt;double, 3&gt;</code>, but that alone won't help unfortunately, because of what Paragraph 14.8.2/5 of the C++11 Standard states:</p>\n<blockquote>\n<p id=\"so_15031198_15032236_0\">The <strong>non-deduced contexts</strong> are:</p>\n<p id=\"so_15031198_15032236_1\">\u2014 The nested-name-specifier of a type that was specified using a qualified-id.</p>\n<p id=\"so_15031198_15032236_2\">\u2014 A non-type template argument or an array bound in which a subexpression references a template\n  parameter.</p>\n<p id=\"so_15031198_15032236_3\">\u2014 A template parameter used in the parameter type of a function parameter that has a default argument\n  that is being used in the call for which argument deduction is being done.</p>\n<p id=\"so_15031198_15032236_4\">\u2014 A <strong>function parameter</strong> for which argument deduction cannot be done because the associated function\n  argument is a function, or a <strong>set of overloaded functions</strong> (13.4), and one or more of the following apply:</p>\n<blockquote>\n<p id=\"so_15031198_15032236_8\">\u2014 more than one function matches the function parameter type (resulting in an ambiguous deduction), or</p>\n<p id=\"so_15031198_15032236_9\">\u2014 no function matches the function parameter type, or</p>\n<p id=\"so_15031198_15032236_10\">\u2014 <strong>the set of functions supplied as an argument contains one or more function templates</strong>.</p>\n</blockquote>\n</blockquote>\n<p>Because of the overloads requiring <em>integral</em> types to be supported (this is new in C+11, see 26.8/11), your library implementation most likely <em>does</em> define a template overload for <code>std::sin</code>. This is how stdlibc++'s definition looks like:</p>\n<pre><code>template&lt;typename _Tp&gt;\ninline _GLIBCXX_CONSTEXPR\ntypename __gnu_cxx::__enable_if&lt;__is_integer&lt;_Tp&gt;::__value, \n                                double&gt;::__type\nsin(_Tp __x)\n{ return __builtin_sin(__x); }\n</code></pre>\n<p>There are ways to get out of here, but you probably would not like them. Apart from the above necessary (yet insufficient) changes, you would also need to explicitly cast <code>std::sin</code> to the desired type. I will also drop the SFINAE condition here, because it does not do anything else than enforcing <code>SameType</code> to be equal to <code>Type</code>:</p>\n<pre><code>// Declaration in the `Array` class\ntemplate &lt;typename Return, class... Args&gt;\ninline Array&lt;Return, Size&gt; apply(\n    Return (*f)(Type, Args&amp;&amp;...), \n    const Array&lt;Args, Size&gt;&amp;... args\n    ) const;\n\n[...]\n\n// Example\nint main(int argc, char *argv[])\n{\n    Array&lt;double, 3&gt; x(1, 2, 3);\n    //    ^^^^^^\n    //    NOTICE\n    //     THIS\n\n    std::cout&lt;&lt;x.str()&lt;&lt;std::endl;\n\n    std::cout&lt;&lt;x.apply((double(*)(double))std::sin).str()&lt;&lt;std::endl; // OK\n    //                 ^^^^^^^^^^^^^^^^^^^\n    //                     NOTICE THIS\n\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-02-22T20:02:05.723", "Score": "1", "CreationDate": "2013-02-22T19:56:20.107", "ParentId": "15031198", "CommentCount": "0", "OwnerUserId": "1932150", "LastEditDate": "2013-02-22T20:02:05.723"}});