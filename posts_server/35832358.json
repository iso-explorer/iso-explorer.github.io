post_cb({"bq_ids": {"n4140": {"so_35832358_35832454_0": {"length": 4, "quality": 0.8, "section_id": 4239}}, "n3337": {"so_35832358_35832454_0": {"length": 4, "quality": 0.8, "section_id": 4080}}, "n4659": {"so_35832358_35832454_0": {"length": 4, "quality": 0.8, "section_id": 5177}}}, "35832648": {"Id": "35832648", "PostTypeId": "2", "Body": "<p>Native support for alignment in C++ is still dismal.  You're aligning to a 4-float vector, from the look of it, so you're missing the hazard where C++14 can't do better than 16 byte alignments, but even so, it's not a feature reliably supported by all C++14 compilers.  If you need portable code that uses <code>new float[]</code>, you've lost the race right out of the gate.</p>\n<p>I think the closest you could get, within the current standard, would be to create a vector-sized and vector-aligned data type (e.g. with std::aligned_storage) and then get in the habit of using that, rather than arrays of individual floats, for your vector math.  If you need variable-length vectors, then you'd have to round up to the nearest 4 floats.</p>\n<p>(Sorry, it's not the answer you wanted, but I think it's the answer you need in order to move forward.)</p>\n", "LastActivityDate": "2016-03-06T21:12:57.970", "CommentCount": "0", "CreationDate": "2016-03-06T21:12:57.970", "ParentId": "35832358", "Score": "0", "OwnerUserId": "3308532"}, "35832358": {"ViewCount": "1892", "Body": "<p>I'd like to modify an array allocation:</p>\n<pre><code> float * a = new float[n] ;\n</code></pre>\n<p>to use an aligned allocator.  I was inclined to try to use placement new and posix_memalign (or the new c++11 equivalent), but see that <a href=\"https://stackoverflow.com/questions/15254/can-placement-new-for-arrays-be-used-in-a-portable-way\">placement new with arrays is problematic with array allocations</a>, because the <a href=\"https://stackoverflow.com/questions/8720425/array-placement-new-requires-unspecified-overhead-in-the-buffer\">compiler may need to have additional storage for count or other metadata</a>.</p>\n<p>I tried:</p>\n<pre><code>int main()\n{\n   float * a = new alignas(16) float[3] ;\n\n   a[2] = 0.0 ;\n\n   return a[2] ;\n}\n</code></pre>\n<p>but the compiler seems to indicate that the alignas is ignored:</p>\n<pre><code>$ g++ -std=c++11 t.cc -Werror\nt.cc: In function \u2018int main()\u2019:\nt.cc:4:39: error: attribute ignored [-Werror=attributes]\n    float * a = new alignas(16) float[3] ;\n                                       ^\nt.cc:4:39: note: an attribute that appertains to a type-specifier is ignored\n</code></pre>\n<p>It looks like the proper way to use alignas is in a <a href=\"https://stackoverflow.com/a/27517755/189270\">structure declaration declare a structure with alignas</a>, but that will only work with a fixed size.</p>\n<p>There is also a  aligned_storage template, but I think that will also only work with fixed sizes.</p>\n<p>Is there any standard way to do an aligned array allocation that will invoke the constructor on all the elements?</p>\n", "Title": "How to do c++ aligned array allocation?", "CreationDate": "2016-03-06T20:48:07.357", "LastActivityDate": "2016-03-06T21:55:52.987", "CommentCount": "0", "LastEditDate": "2017-05-23T11:50:27.753", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "35832358", "Score": "1", "OwnerUserId": "189270", "Tags": "<c++><arrays><alignment>", "AnswerCount": "3"}, "35832526": {"Id": "35832526", "PostTypeId": "2", "Body": "<p>As other people said, overaligned types are not required to be supported. Check your compiler documentation before using it.</p>\n<p>You can try to solve your problem using one of the following approaches:</p>\n<p>1) Overallocate your array (by <code>(desired aligment / sizeof element) - 1</code>) and use <a href=\"http://en.cppreference.com/w/cpp/memory/align\" rel=\"nofollow noreferrer\">std::align</a>. A link to <a href=\"https://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%2B%2B-v3/include/std/memory?view=markup#l114\" rel=\"nofollow noreferrer\"><code>libstdc++</code> implementation</a>.</p>\n<p>2) declare a struct containing array of <code>desired aligment / sizeof element</code> elements and aligned by desired aligment. It <em>should</em> give you compact representation in memory if you use array of such structs, but you will not be able to use normal array notation or pointer arithmetics (as it (a)  undefined behaviour, (b) there is a small chance that they will not be placed as you want)</p>\n<p>3) Write your own aligned allocation function. Notice that you can add your own versions of operator <code>new</code> and <code>delete</code>. </p>\n<pre><code>namespace my\n{\n    struct aligned_allocator_tag {};\n    aligned_allocator_tag aligned;\n}\n\nvoid* operator new( std::size_t count, my::aligned_allocator_tag, std::size_t aligment);\nvoid* operator new[]( std::size_t count, my::aligned_allocator_tag, std::size_t aligment)\n{\n    return ::operator new(count, my::aligned, aligment);\n}\n//Usage\nfoo* c = new(my::aligned, 16) foo[20];\n</code></pre>\n<p>You will need to allocate memory, reserve enough space to store original pointer (returned by malloc/whatever) or amount of bytes pointer was displaced, so subsequent delete will free corect pointer, align pointer to needed size and return it. </p>\n<p>Here is <a href=\"https://stackoverflow.com/a/6320500/3410396\">an answer</a>, <a href=\"https://stackoverflow.com/a/227900/3410396\">and another one</a>, which shows how to align memory. </p>\n<p>Notice that both of these answers uses implementation-defined behaviour of doing bitwise arithmetic on pointers converted to integers and converting them back. The only really completely standard way would be to cast memory to <code>char*</code> and add difference between its value and next aligned address. </p>\n<p>If you can use some nonstandard memory allocation functions, you can wrap them into custom operator <code>new</code> too.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-06T21:55:52.987", "Score": "1", "CreationDate": "2016-03-06T21:03:42.067", "ParentId": "35832358", "CommentCount": "0", "OwnerUserId": "3410396", "LastEditDate": "2017-05-23T12:31:05.750"}, "35832454": {"Id": "35832454", "PostTypeId": "2", "Body": "<p>Basically, you're stuck because, in [expr.new]:</p>\n<blockquote>\n<p id=\"so_35832358_35832454_0\">It is implementation-defined whether over-aligned types are supported.</p>\n</blockquote>\n<p>There is a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0035r1.html\" rel=\"nofollow\">proposal</a> to support this better. Until then, if you want to do what you're trying to do, you'll have to use <a href=\"http://en.cppreference.com/w/c/memory/aligned_alloc\" rel=\"nofollow\"><code>aligned_alloc</code></a>  instead of <code>new</code>.</p>\n<hr/>\n<p>If you stick your array in a struct:</p>\n<pre><code>struct S {\n    alignas(16) float _[3];\n};\n</code></pre>\n<p>then <code>new S</code> will give you the right alignment for <code>_</code>, though not necessarily for <code>S</code> itself. That may suffice. If it doesn't, then you can overload <code>operator new()</code> and <code>operator delete()</code> on <code>S</code> itself to guarantee the correct behavior. </p>\n", "LastActivityDate": "2016-03-06T20:56:53.780", "CommentCount": "2", "CreationDate": "2016-03-06T20:56:53.780", "ParentId": "35832358", "Score": "0", "OwnerUserId": "2069064"}});