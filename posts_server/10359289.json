post_cb({"bq_ids": {"n4140": {"so_10359289_10359339_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 7049}, "so_10359289_10359339_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 7049}, "so_10359289_10359328_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 3291}}, "n3337": {"so_10359289_10359339_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 6794}, "so_10359289_10359339_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 6794}, "so_10359289_10359328_2": {"length": 14, "quality": 1.0, "section_id": 3161}}, "n4659": {"so_10359289_10359339_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 8546}, "so_10359289_10359339_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 8546}, "so_10359289_10359328_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 4053}}}, "10359328": {"Id": "10359328", "PostTypeId": "2", "Body": "<p>Reading an uninitialized variable can lead to undefined behavior.</p>\n<p>The standard says this:</p>\n<blockquote>\n<p id=\"so_10359289_10359328_0\"><strong>Initializers [dcl.init]</strong></p>\n<p id=\"so_10359289_10359328_1\">.......</p>\n<p id=\"so_10359289_10359328_2\">If no initializer is specified for an object, the object is default-initialized; if no initialization is performed, an object with automatic or dynamic storage duration has indeterminate value.</p>\n</blockquote>\n", "LastEditorUserId": "505088", "LastActivityDate": "2012-04-28T00:36:47.227", "Score": "1", "CreationDate": "2012-04-28T00:02:33.730", "ParentId": "10359289", "CommentCount": "17", "LastEditDate": "2012-04-28T00:36:47.227", "OwnerUserId": "505088"}, "10359289": {"ViewCount": "126", "Body": "<p>I was debugging a program when I came across the following code I had erroneously typed similar to the following:</p>\n<pre><code>//Original (wrong)\nstd::string first(\"Hello\");\nstd::string second = first + second;\n\n//Instead of this (correct)\nstd::string first(\"Hello\");\nstd::string second = first + something_else;\n</code></pre>\n<p>Obviously I wasn't trying to do this (I can't think why anyone would want to do this), but it got me thinking.  It doesn't look like the original should work, and I would assume it is undefined.  Indeed, this was the source of my problem.  </p>\n<p>To make the problem more general, consider the following:</p>\n<pre><code>SomeType a;\nSomeType b = a + b;\n</code></pre>\n<p>Is the behavior undefined simply because <code>b</code> is not yet initialized (see <a href=\"https://stackoverflow.com/a/367662/1272627\" title=\"answer\">this answer</a>)?</p>\n<p>If the behavior is undefined, then my real question is, why?</p>\n<p>Is this only undefined for certain standard containers, like <code>std::string</code>, or is this undefined in a more general sense (STL classes, user-defined classes, PODs, fundamental types)?  </p>\n<p>What part of the standard applies to this?</p>\n<p>Assume this is c++11, if necessary.</p>\n", "AcceptedAnswerId": "10359339", "Title": "Why can't I initialize an object incorporating itself into its initial value in c++?", "CreationDate": "2012-04-27T23:55:31.053", "Id": "10359289", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:21:17.107", "LastEditorUserId": "-1", "LastActivityDate": "2013-11-30T20:07:15.457", "Score": "3", "OwnerUserId": "1272627", "Tags": "<c++><string><undefined-behavior>", "AnswerCount": "3"}, "10359339": {"Id": "10359339", "PostTypeId": "2", "Body": "<p>The C++11 standard has this to say about the scope of a newly declared name:</p>\n<blockquote>\n<p id=\"so_10359289_10359339_0\">3.3.2 Point of declaration [basic.scope.pdecl]</p>\n<p id=\"so_10359289_10359339_1\">The point of declaration for a name is immediately after its complete\n  declarator (Clause 8) and before its initializer (if any), except as\n  noted below. [ Example:</p>\n<pre><code>int x = 12;\n{ int x = x; }\n</code></pre>\n<p id=\"so_10359289_10359339_2\">Here the second x is initialized with its own (indeterminate) value. \u2014\n  end example ]</p>\n</blockquote>\n<p>There is similar wording in prior C++ standards.</p>\n<p>Off the top of my head, one rationale I can think of is that the name could be used in an initializer expression that takes the address of the object. </p>\n", "LastActivityDate": "2012-04-28T00:03:57.610", "Score": "6", "CreationDate": "2012-04-28T00:03:57.610", "ParentId": "10359289", "CommentCount": "5", "OwnerUserId": "12711"}, "20305067": {"Id": "20305067", "PostTypeId": "2", "Body": "<p>The why is simple: Because the syntax is sugar. What looks like simple assignment is, infact, copy construction; the right hand of the expression is evaluated and passed to the copy constructor of the left hand.</p>\n<pre><code>SomeType b = a + b;\n</code></pre>\n<p>is actually</p>\n<pre><code>SomeType b(a + b /*wat?*/);\n</code></pre>\n<p>Part of the motivation behind this is RVO. Consider instead the case of</p>\n<pre><code>SomeType a, b;\nSomeType c = a + b;\n</code></pre>\n<p><code>c</code> can actually be forwarded as the <code>temp</code> object that <code>a.operator+(b)</code> uses to construct the return value.</p>\n<pre><code>SomeType SomeType::operator+(const SomeType&amp; rhs) const\n{\n    SomeType temp(*this); // RVO will employ `c` here instead of a 4th object.\n    ...\n    return temp; // yeah, let's not and say we did.\n}\n</code></pre>\n<p>Note that you <em>can</em> take your own address:</p>\n<pre><code>inptr_t i = (intptr_t)&amp;i;\nvoid* ptr = &amp;ptr;\n</code></pre>\n<p><a href=\"http://ideone.com/GUJyio\" rel=\"nofollow\">http://ideone.com/GUJyio</a></p>\n", "LastActivityDate": "2013-11-30T20:07:15.457", "Score": "0", "CreationDate": "2013-11-30T20:07:15.457", "ParentId": "10359289", "CommentCount": "0", "OwnerUserId": "257645"}});