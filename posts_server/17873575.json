post_cb({"17883966": {"ParentId": "17873575", "CommentCount": "0", "Body": "<p>17.6.4.9 Function arguments [res.on.arguments]/p1/b3 says:</p>\n<blockquote>\n<p id=\"so_17873575_17883966_0\">1 Each of the following applies to all arguments to functions defined\n  in the C++ standard library, unless explicitly stated otherwise.</p>\n<p id=\"so_17873575_17883966_1\">...</p>\n<ul>\n<li>If a function argument binds to an rvalue reference parameter, the implementation may assume that this parameter is a unique reference to\n  this argument. [ <em>Note</em>: If the parameter is a generic parameter of\n  the form <code>T&amp;&amp;</code> and an lvalue of type <code>A</code> is bound, the argument binds\n  to an lvalue reference (14.8.2.1) and thus is not covered by the\n  previous sentence. \u2014 <em>end note</em> ] [ <em>Note</em>: If a program casts an\n  lvalue to an xvalue while passing that lvalue to a library function\n  (e.g. by calling the function with the argument <code>move(x)</code>), the\n  program is eectively asking that function to treat that lvalue as a\n  temporary. The implementation is free to optimize away aliasing checks\n  which might be needed if the argument was an lvalue. \u2014 <em>endnote</em>]</li>\n</ul>\n</blockquote>\n<p>In short, vector assumes the argument referenced by <code>&amp;&amp;</code> in both <code>insert</code> and <code>push_back</code> is a temporary and thus does no preventative aliasing checks.</p>\n<p>As it turns out, assuming you inserted or push_back'd an lvalue, the <code>push_back</code> algorithm never needs to check for aliasing anyway.  However the <code>insert</code> algorithm does (I'm specifically speaking of <code>vector</code>, and not other containers).  So when you use <code>move</code>, you don't notice the lack of aliasing checks on <code>push_back</code>, because they would not make a difference anyway.  However you do notice the lack of them on <code>insert</code>.</p>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "17883966", "Score": "3", "CreationDate": "2013-07-26T14:24:42.910", "LastActivityDate": "2013-07-26T14:24:42.910"}, "17873575": {"CommentCount": "5", "AcceptedAnswerId": "17883966", "PostTypeId": "1", "LastEditorUserId": "1532460", "CreationDate": "2013-07-26T05:26:50.833", "LastActivityDate": "2013-07-26T14:24:42.910", "LastEditDate": "2013-07-26T05:29:03.940", "ViewCount": "927", "FavoriteCount": "1", "Title": "std::move behaves differently on vector::insert and push_back", "Id": "17873575", "Score": "0", "Body": "<p>I noticed a difference in behavior between <code>vector::push_back</code> and <code>insert</code>.</p>\n<p>When I do</p>\n<pre><code>iter = myVector.begin() + 5;\nmyVector.push_back(std::move(*iter));\n</code></pre>\n<p>The 6th element in the vector is added to the bottom and gets deleted from the previous position.</p>\n<p>Whereas, if I do this:</p>\n<pre><code>iterBegin = myVector.begin();\nmyVector.insert(iterBegin,std::move(*(iterBegin + 5)));\n</code></pre>\n<p>The 6th element gets inserted in the first position, but it does not get deleted form the previous position.</p>\n<p>Why <code>std::move</code> does not work in <code>insert()</code> as in <code>push_back()</code>?</p>\n", "Tags": "<c++><c++11><std><stdvector>", "OwnerUserId": "1605999", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17873575_17883966_0": {"section_id": 6325, "quality": 1.0, "length": 11}}, "n3337": {"so_17873575_17883966_0": {"section_id": 6082, "quality": 1.0, "length": 11}}, "n4659": {"so_17873575_17883966_0": {"section_id": 7835, "quality": 1.0, "length": 11}}}, "17873624": {"ParentId": "17873575", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-07-26T05:30:47.307", "Score": "1", "LastEditorUserId": "780719", "LastEditDate": "2013-07-26T05:41:53.893", "Id": "17873624", "OwnerUserId": "780719", "Body": "<p>Iterators are only valid as long as the collection class, in this case <code>vector</code> isn't modified.  Once you insert the first time, you invalidate your iterators and the result is undefined.</p>\n<p>So in either case, <code>iter</code> becomes invalid and bad stuff will happen!  Or worse, it seems to work except on release builds, or on that one old machine, or when the moon is full, etc.</p>\n<p>Instead, consider copying the elements you want to add to a new container, and then add them.</p>\n", "LastActivityDate": "2013-07-26T05:41:53.893"}});