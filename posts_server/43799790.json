post_cb({"43799790": {"CommentCount": "0", "ViewCount": "111", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-05-05T08:11:45.860", "LastActivityDate": "2017-05-05T14:26:54.413", "Title": "Is destroying the last std::exception_ptr pointing to an exception after calling std::rethrow_exception portable?", "AcceptedAnswerId": "43802017", "LastEditDate": "2017-05-23T12:18:07.537", "Id": "43799790", "Score": "2", "Body": "<p>I have a portability question concerning the lifetime of exception. In the code below, an exception is thrown in one thread (mySlave) and transferred to another thread (myMaster) using a <code>std::exception_ptr</code>. myMaster is always waiting for different events via a <code>std::condition_variable</code>. An exception in mySlave is such an event. In the predicate function of the wait in myMaster, I check if the exception pointer is null. If an exception has been thrown in mySlave, I copy the exception pointer to a temporary variable in myMaster, set the original exception pointer to null and rethrow it in myMaster. This way, the original exception pointer is ready to serve in the predicate function once the program has recovered from the exception.</p>\n<p>This works fine  with VC14, but the final software is likely to be ported to other platforms in the future. In my code, all <code>exception_ptr</code> references to the exception will run out of scope after the rethrow, thus the original exception will be destroyed. My concern is if <code>std::rethrow_exception</code> is guaranteed to always generate a copy of the exception when rethrowing it, or if it could also use a reference to the exception, causing it to be no longer valid when I try to catch if in myMaster?</p>\n<pre><code>#include &lt;mutex&gt;\n#include &lt;thread&gt;\n#include &lt;atomic&gt;\n#include &lt;exception&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass SomeClass\n{\npublic:\n    /*...*/\n    void MaseterFunction();\n    void SlaveFunction();\n\nprivate:\n    /*...*/\n    std::mutex mutex_gotEvent;\n    std::condition_variable condVar_gotEvent;\n    std::exception_ptr slaveLoopException;\n    /*...*/\n    std::atomic&lt;bool&gt; running = true;\n};\n\nclass MyException : public std::runtime_error\n{\npublic:\n    MyException() : std::runtime_error(\"Ooops\") {}\n};\n\nvoid SomeClass::SlaveFunction()\n{\n    try\n    {\n        throw MyException();\n    }catch(const std::exception&amp; e)\n    {\n        std::unique_lock&lt;std::mutex&gt; lock(mutex_gotEvent);\n        slaveLoopException = std::current_exception();\n        condVar_gotEvent.notify_all();\n    }\n}\n\n\nvoid SomeClass::MaseterFunction()\n{\n    while (running)\n    {\n        try\n        {\n            {\n                /*Wait for something interesting to happen*/\n                std::unique_lock&lt;std::mutex&gt; lock(mutex_gotEvent);\n                condVar_gotEvent.wait(lock, [=]()-&gt;bool {\n                    return !(slaveLoopException == nullptr); // Real code waits for several events \n                });\n            }\n\n            /*Care for events*/\n            /*...*/\n            if (slaveLoopException)\n            {\n                std::exception_ptr temp_ptr = slaveLoopException;\n                slaveLoopException = nullptr;\n\n                std::rethrow_exception(temp_ptr);\n            }\n        }\n        catch (const MyException&amp; e)\n        {\n            std::cout &lt;&lt; e.what();\n            running = false;\n        }\n    }\n}\n\nint main()\n{\n    std::shared_ptr&lt;SomeClass&gt; someClass = std::make_shared&lt;SomeClass&gt;();\n    std::thread myMaster([someClass]() {someClass-&gt;MaseterFunction(); });\n    std::thread mySlave([someClass]() {someClass-&gt;SlaveFunction(); });\n\n    std::cin.ignore();\n\n    if (myMaster.joinable())\n    {\n        myMaster.join();\n    }\n    if (mySlave.joinable())\n    {\n        mySlave.join();\n    }\n    return 0;\n}\n</code></pre>\n<p>I thought about declaring <code>temp_ptr</code> at class level or use a <code>std::atomic&lt;bool&gt;</code> variable in addition to the exception pointer to be used in the predicate function. However both of these solutions would keep the exception alive after it is no longer used, which seem not very elegant to me. It would also be possible to set the exception pointer to null in each catch block in myMaster, but I think that this is likely to introduce bugs when new exceptions are added later on and the programmer forgets to null the exception pointer.</p>\n<p><strong>EDIT:</strong></p>\n<p>I found the following statements on this subject:</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/error/exception_ptr\" rel=\"nofollow noreferrer\">Statement 1</a>: </p>\n<blockquote>\n<p id=\"so_43799790_43799790_0\">The exception object referenced by an std::exception_ptr remains valid\n  as long as there remains at least one std::exception_ptr that is\n  referencing it</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/30580128/may-i-modify-the-value-of-an-exception-inside-a-stdexception-ptr/30582075#30582075\">Statement 2</a>:</p>\n<blockquote>\n<p id=\"so_43799790_43799790_1\">The VS implementation of rethrow_exception appears to make a copy of\n  the exception. Clang and gcc do not make copies.</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/21720579/lifetime-of-data-associated-with-stdcurrent-exception\">Statement 3</a></p>\n<blockquote>\n<p id=\"so_43799790_43799790_2\">The exception object is destroyed after either the last remaining\n  active handler for the exception exits by any means other than\n  rethrowing, or the last object of type std::exception_ptr (\u00a718.8.5)\n  that refers to the exception object is destroyed, whichever is later.</p>\n</blockquote>\n<p>From (1) I would expect the exception to be destroyed too early. From (2) I would expect this to be of no effect when using VC as a copy is used anyway. From 3, I can't tell if this could save me when using gcc or clang. I mean, the exit takes place by rethrowing, but it is not rethrown from a handler. Is the new handler already considered active when the temporary pointer is destroyed or is the pointer destroyed first and with it the exception, leaving the follow up catch blocks with an invalid exception reference?</p>\n", "Tags": "<c++><c++11><exception-handling><language-lawyer>", "OwnerUserId": "2722057", "AnswerCount": "1"}, "43802017": {"ParentId": "43799790", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>CppRef states that <a href=\"http://en.cppreference.com/w/cpp/error/rethrow_exception\" rel=\"nofollow noreferrer\"><code>rethrow_exception</code></a> -- <em>Throws the previously captured exception object</em>. I haven't checked the standard myself (but see below), but:</p>\n<h2>Speculation</h2>\n<p>It seems likely to me that from the point onwards where you rethrow the exception, exception handling is \"back to normal\", i.e. it is the job of the implementation to keep the thrown object around, and the language doesn't care whether you threw via a normal <code>throw</code>or via a <code>rethrow_exception</code>.</p>\n<p>Stated differently: The exception_ptr needs to be valid at the point of <code>rethrow_exception</code>, after this, the thrown exception is the same as any other and whether or not it shares with the original exception pointer shouldn't matter.</p>\n<hr>\n<p>OP provided a good <a href=\"https://stackoverflow.com/questions/21720579/lifetime-of-data-associated-with-stdcurrent-exception\">link</a> with a standard quote:</p>\n<blockquote>\n<p id=\"so_43799790_43802017_0\">4/ The memory for the exception object is allocated in an unspecified way, except as noted in \u00a73.7.4.1. If a handler exits by rethrowing, control is passed to another handler for the same exception. <strong>The exception object is destroyed after either the last remaining active handler for the exception exits by any means other than rethrowing, or the last object of type <code>std::exception_ptr</code> (\u00a718.8.5) that refers to the exception object is destroyed, whichever is later.</strong> In the former case, the destruction occurs when the handler exits, immediately after the destruction of the object declared in the <em>exception-declaration</em> in the handler, if any. In the latter case, the destruction occurs before the destructor of <code>std::exception_ptr</code> returns. The implementation may then deallocate the memory for the exception object; any such deallocation is done in an unspecified way. [ <em>Note:</em> a thrown exception does not propagate to other threads unless caught, stored, and rethrown using appropriate library functions; see \u00a718.8.5 and \u00a730.6. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p><strike>Which seems to imply what I wrote above: The exception object lives as long as necessary: the <em><code>whichever is later</code></em> part of the quote seems to explicitly call this out.</strike> </p>\n<p>Update: I missed that OP doesn't re-throw from the handler, so I am also unsure what is supposed to happen here.</p>\n<p>I <em>do</em> believe that after <code>rethrow_exception</code> the (new) exception in flight should be treated as-if it was generated by a normal <code>throw</code> expression - anything else makes little sense.</p>\n<p>The way I <em>speculate</em> here is that even prior to <code>std::exception_ptr</code> every implementation had an internal mechanism that was similar to <code>std::exception_ptr</code> in that it had to keep the thrown exception object (copy or not) alive <em>outside</em> of normal stack frames until it was no longer needed by any handler up the stack. So I can speculate that clang or gcc would not do a copy, but instead hold an \"internal exception_ptr\" as soon as you invoke throw/rethrow_exception.</p>\n</hr>", "OwnerUserId": "321013", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:26:12.517", "Id": "43802017", "Score": "1", "CreationDate": "2017-05-05T09:59:54.353", "LastActivityDate": "2017-05-05T14:26:54.413"}, "bq_ids": {"n4140": {"so_43799790_43799790_2": {"section_id": 3337, "quality": 0.9259259259259259, "length": 25}, "so_43799790_43802017_0": {"section_id": 3337, "quality": 0.9, "length": 90}}, "n3337": {"so_43799790_43799790_2": {"section_id": 3207, "quality": 0.9259259259259259, "length": 25}, "so_43799790_43802017_0": {"section_id": 3207, "quality": 0.89, "length": 89}}, "n4659": {"so_43799790_43802017_0": {"section_id": 4104, "quality": 0.64, "length": 64}, "so_43799790_43799790_2": {"section_id": 4104, "quality": 0.6296296296296297, "length": 17}}}});