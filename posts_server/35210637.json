post_cb({"bq_ids": {"n4140": {"so_35210637_35212445_0": {"length": 30, "quality": 0.9090909090909091, "section_id": 521}, "so_35210637_35212530_3": {"length": 45, "quality": 1.0, "section_id": 523}, "so_35210637_35212445_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 530}, "so_35210637_35212530_4": {"length": 24, "quality": 0.96, "section_id": 530}, "so_35210637_35212530_1": {"length": 16, "quality": 1.0, "section_id": 514}, "so_35210637_35212445_1": {"length": 41, "quality": 0.9761904761904762, "section_id": 523}, "so_35210637_35212530_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 521}, "so_35210637_35212530_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 519}}, "n3337": {"so_35210637_35212445_0": {"length": 30, "quality": 0.9090909090909091, "section_id": 512}, "so_35210637_35212530_3": {"length": 45, "quality": 1.0, "section_id": 514}, "so_35210637_35212445_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 521}, "so_35210637_35212530_4": {"length": 24, "quality": 0.96, "section_id": 521}, "so_35210637_35212530_1": {"length": 16, "quality": 1.0, "section_id": 505}, "so_35210637_35212445_1": {"length": 41, "quality": 0.9761904761904762, "section_id": 514}, "so_35210637_35212530_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 512}, "so_35210637_35212530_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 510}}, "n4659": {"so_35210637_35212445_0": {"length": 30, "quality": 0.9090909090909091, "section_id": 542}, "so_35210637_35212530_3": {"length": 45, "quality": 1.0, "section_id": 544}, "so_35210637_35212445_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 551}, "so_35210637_35212530_4": {"length": 24, "quality": 0.96, "section_id": 551}, "so_35210637_35212530_1": {"length": 16, "quality": 1.0, "section_id": 535}, "so_35210637_35212445_1": {"length": 41, "quality": 0.9761904761904762, "section_id": 544}, "so_35210637_35212530_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 542}, "so_35210637_35212530_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 540}}}, "35212530": {"Id": "35212530", "PostTypeId": "2", "Body": "<p>C11 says that each appearance of an object-like macro's name</p>\n<blockquote>\n<p id=\"so_35210637_35212530_0\">[is] replaced by the replacement list of preprocessing tokens that constitute the remainder of the directive.  The replacement list is then rescanned for more macro names as specified below.</p>\n</blockquote>\n<p>[6.10.3/9]</p>\n<p>Of function-like macros it says this:</p>\n<blockquote>\n<p id=\"so_35210637_35212530_1\">If the identifier-list in the macro definition does not end with an ellipsis, the number of arguments [...] in an invocation of a function-like macro shall equal the number of parameters in the macro definition.</p>\n</blockquote>\n<p>[6.10.3/4]</p>\n<p>and this:</p>\n<blockquote>\n<p id=\"so_35210637_35212530_2\">The sequence of preprocessing tokens bounded by the outside-most matching parentheses forms the list of arguments for the function-like macro.</p>\n</blockquote>\n<p>[6.10.3/11]</p>\n<p>and this:</p>\n<blockquote>\n<p id=\"so_35210637_35212530_3\">After the arguments for the invocation of a function-like  macro have been identified, argument substitution takes place.  A parameter in the replacement list [...] is replaced by the corresponding argument after all macros contained therein have been expanded.  Before being substituted, each argument\u2019s   preprocessing tokens are completely macro replaced as if they formed the rest of the preprocessing file; no other preprocessing tokens are available.</p>\n</blockquote>\n<p>[6.10.3.1/1]</p>\n<p>Of macros in general it also says this:</p>\n<blockquote>\n<p id=\"so_35210637_35212530_4\">After all parameters in the replacement list have been substituted [... t]he resulting preprocessing token sequence is then rescanned, along with all subsequent preprocessing tokens of the source file, for more macro names to replace.</p>\n</blockquote>\n<p>[6.10.3.4/1]</p>\n<p>MSVC++ does not properly expand the arguments to function-like macros before rescanning the expansion of such macros.  It seems unlikely that there is any easy workaround.</p>\n<p><strong>UPDATE:</strong></p>\n<p>In light of @dxiv's answer, however, it may be that there is a solution after all.  The problem with his solution with respect to standard-conforming behavior is that there needs to be one more expansion than is actually performed.  That can easily enough be supplied.  This variation on his approach works with GCC, as it should, and inasmuch as it is based on code that dxiv claims works with MSVC++, it seems likely to work there, too:</p>\n<pre><code>#define EXPAND(x) x\n#define PAREN(...) (__VA_ARGS__)\n#define EXPAND_F(m, ...) EXPAND(m PAREN(__VA_ARGS__))\n#define SUM3(a,b,c) a + b + c\n#define ARGS 1,2,3\n\nint sum = EXPAND_F(SUM3, ARGS);\n</code></pre>\n<p>I have of course made it a little more generic than perhaps it needs to be, but that may serve you well if you have a lot of these to deal with..</p>\n", "LastEditorUserId": "2402272", "LastActivityDate": "2016-02-04T23:37:33.310", "Score": "3", "CreationDate": "2016-02-04T22:03:27.380", "ParentId": "35210637", "CommentCount": "0", "OwnerUserId": "2402272", "LastEditDate": "2016-02-04T23:37:33.310"}, "35213289": {"Id": "35213289", "PostTypeId": "2", "Body": "<p>Curiuosly enough, the following appears to work in MSVC (tested with 2010 and 2015).</p>\n<pre><code>#define ARGS 1,2,3\n\n#define OUTER(...) INNER PARAN(__VA_ARGS__)\n#define PARAN(...) (__VA_ARGS__)\n#define INNER(A,B,C) A + B + C\n\nint a = OUTER(ARGS);\n</code></pre>\n<p>I don't know that it's supposed to work by the letter of the standard, in fact I have a hunch it's not. Could still be conditionally compiled just for MSVC, as a workaround.\n<hr>\n[EDIT] \u00a0P.S.\u00a0 As pointed out in the comments, the above is (another) non-standard MSVC behavior. Instead, the alternative workarounds posted by <a href=\"https://stackoverflow.com/a/35212445/5538420\">@rici</a> and <a href=\"https://stackoverflow.com/a/35212530/5538420\">@JohnBollinger</a> in the respective replies are compliant, thus recommended.</hr></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-02-05T02:13:53.123", "Score": "0", "CreationDate": "2016-02-04T22:56:26.910", "ParentId": "35210637", "CommentCount": "7", "OwnerUserId": "5538420", "LastEditDate": "2017-05-23T11:53:23.150"}, "35212445": {"Id": "35212445", "PostTypeId": "2", "Body": "<p>MSVC is non-conformant. The standard is actually clear on the point, although it does not feel the need to mention this particular case, which is not exceptional.</p>\n<p>When a function-like macro invocation is encountered, the preprocessor:</p>\n<ol>\n<li><p>\u00a76.10.3/11 identifies the arguments, which are possibly empty sequences of tokens separated by non-protected commas <kbd>,</kbd> (a comma is protected if it is inside parentheses <kbd>(</kbd><kbd>)</kbd>).</p></li>\n<li><p>\u00a76.10.3.1/1 does a first pass over the macro body, substituting each parameter which is not used in a <code>#</code> or <code>##</code> operation with the corresponding fully macro-expanded argument. (It does no other substitutions in the macro body in this step.)</p></li>\n<li><p>\u00a76.10.3.4/1 rescans the substituted replacement token sequence, performing more macro replacements as necessary.</p></li>\n</ol>\n<p>(The above mostly ignores stringification (<code>#</code>) and token concatenation (<code>##</code>), which are not relevant to this question.)</p>\n<p>This order of operations unambiguously leads to the behaviour expected by whoever wrote the software.</p>\n<p>Apparently (according to @dxiv, and verified <a href=\"http://webcompiler.cloudapp.net/\" rel=\"nofollow\">here</a>) the following standards-compliant workaround works on some versions of MS Visual Studio:</p>\n<pre><code>#define CALL(A,B) A B\n#define OUTER(PARAM) CALL(INNER,(PARAM))\n#define INNER(A,B,C) whatever\n</code></pre>\n<p>For reference, the actual language from the C11 standard, skipping over the references to <code>#</code> and <code>##</code> handling:</p>\n<blockquote>\n<p id=\"so_35210637_35212445_0\">\u00a76.10.3 11 The sequence of preprocessing tokens bounded by the outside-most matching parentheses forms the list of arguments for the function-like macro. The individual arguments within the list are separated by comma preprocessing tokens, but comma preprocessing tokens between matching inner parentheses do not separate arguments.\u2026</p>\n<p id=\"so_35210637_35212445_1\">\u00a76.10.3.1 1 After the arguments for the invocation of a function-like macro have been identified, argument substitution takes place. A parameter in the replacement list\u2026 is replaced by the corresponding argument after all macros contained therein have been expanded. Before being substituted, each argument\u2019s preprocessing tokens are completely macro replaced as if they formed the rest of the preprocessing file\u2026</p>\n<p id=\"so_35210637_35212445_2\">\u00a76.10.3.4 1 After all parameters in the replacement list have been substituted\u2026 [t]he resulting preprocessing token sequence is then rescanned, along with all subsequent preprocessing tokens of the source file, for more macro names to replace.</p>\n</blockquote>\n", "LastEditorUserId": "1566221", "LastActivityDate": "2016-02-05T01:12:11.633", "Score": "4", "CreationDate": "2016-02-04T21:57:59.973", "ParentId": "35210637", "CommentCount": "7", "OwnerUserId": "1566221", "LastEditDate": "2016-02-05T01:12:11.633"}, "35210637": {"ViewCount": "893", "Body": "<p>The code I'm working on uses some very convoluted macro voodoo in order to generate code, but in the end there is a construct that looks like this</p>\n<pre><code>#define ARGS 1,2,3\n\n#define MACROFUNC_OUTER(PARAMS) MACROFUNC_INNER(PARAMS)\n#define MACROFUNC_INNER(A,B,C) A + B + C\n\nint a = MACROFUNC_OUTER(ARGS);\n</code></pre>\n<p>What is expected is to get</p>\n<pre><code>int a = 1 + 2 + 3;\n</code></pre>\n<p>This works well for the compiler it has originally been written for (GHS) and also for GCC, but MSVC (2008) considers <code>PARAMS</code> as a single preprocessing token that it won't expand, setting then <code>A</code> to the whole <code>PARAM</code> and <code>B</code> and <code>C</code> to nothing. The result is this</p>\n<pre><code>int a = 1,2,3 +  + ;\n</code></pre>\n<p>while MSVC warns that <code>not enough actual parameters for macro 'MACROFUNC_INNER'</code>.</p>\n<ul>\n<li>Is it possible to get MSVC do the expansion with some tricks (another layer of macro to force a second expansion, some well placed ## or #, ...). Admitting that changing the way the construct work is not an option. (<em>i.e.: can I solve the problem myself?</em>)</li>\n<li>What does the C standard say about such corner case? I couldn't find in the C11 norm anything that explicitly tells how to handle arguments that contains a list of arguments. (<em>i.e.: can I argue with the author of the code that he has to write it again, or is just MVSC non-conform?</em>)</li>\n</ul>\n", "AcceptedAnswerId": "35212445", "Title": "Macro Expansion: Argument with Commas", "CreationDate": "2016-02-04T20:09:25.797", "Id": "35210637", "CommentCount": "3", "LastEditDate": "2016-02-04T22:07:30.053", "PostTypeId": "1", "LastEditorUserId": "5538420", "LastActivityDate": "2016-02-05T02:13:53.123", "Score": "3", "OwnerUserId": "1970751", "Tags": "<c><visual-c++><gcc><macros><language-lawyer>", "AnswerCount": "3"}});