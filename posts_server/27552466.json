post_cb({"bq_ids": {"n4140": {"so_27552466_27552592_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 7192}}, "n3337": {"so_27552466_27552592_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 6936}}, "n4659": {"so_27552466_27552592_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 8701}}}, "27552592": {"Id": "27552592", "PostTypeId": "2", "Body": "<p><strong><em>Generally, working with placement new in this way is not a good idea. Calling an initializer from the first new, or calling an initializer instead of placement new are both considered to be better form than the code you've provided.</em></strong> </p>\n<p><em>However, in this case, the behaviour of calling placement new over an existing object is well defined.</em></p>\n<blockquote>\n<p id=\"so_27552466_27552592_0\"><strong>A program may end the lifetime of any object by reusing the storage\n  which the object occupies</strong> or by explicitly calling the destructor for\n  an object of a class type with a non-trivial destructor. For an object\n  of a class type with a non-trivial destructor, the program is not\n  required to call the destructor explicitly before the storage which\n  the object occupies is reused or released; however, if there is no\n  explicit call to the destructor or if a delete-expression (5.3.5) is\n  not used to release the storage, the destructor shall not be\n  implicitly called and <strong>any program that depends on the side effects\n  produced by the destructor has undefined behavior.</strong></p>\n</blockquote>\n<p>So when this happens:</p>\n<pre><code>Foo* fooArray = new Foo[numFoos];   //allocate an array of default constructed Foo's\n\nfor(int i = 0; i &lt; numFoos; ++i)\n{\n    new( fooArray+ i) Foo( initialiser );    //use placement new to initialise\n}\n</code></pre>\n<p>The placement new operation will end the lifetime of the <code>Foo</code> that was there, and create a new one in it's place. In many circumstances this could be bad, but given the way your destructor works, this will be fine.</p>\n<p>Calling placement new on an existing object could be undefined behaviour, but it depends on the specific object.</p>\n<p><strong><em>This does not produce undefined behaviour, because you are not depending on the \"side effects\" produced by the destructor.</em></strong></p>\n<p>The only \"side-effect\" in the destructor of your object is to <code>delete</code> the contained <code>int</code> pointer, but in this case that object is never in a deletable state when placement <code>new</code> is called.</p>\n<p>If it was possible for the contained <code>int</code> pointer to be equal to something other than <code>nullptr</code> and could possibly require deleting, then calling placement <code>new</code> over the existing object would invoke undefined behaviour.</p>\n", "LastEditorUserId": "3561240", "LastActivityDate": "2014-12-21T21:55:47.423", "Score": "10", "CreationDate": "2014-12-18T17:43:01.223", "ParentId": "27552466", "CommentCount": "6", "OwnerUserId": "3561240", "LastEditDate": "2014-12-21T21:55:47.423"}, "27552466": {"ViewCount": "549", "Body": "<p>I have come across some code which has horrified me.\nEssentially it follows this pattern :</p>\n<pre><code>class Foo\n{\n  public:\n    //default constructor\n    Foo(): x(0), ptr(nullptr)  \n    {\n      //do nothing\n    }\n\n    //more interesting constructor\n    Foo( FooInitialiser&amp; init): x(0), ptr(nullptr) \n    {\n      x = init.getX();\n      ptr = new int;\n    }\n    ~Foo()\n    {\n      delete ptr;\n    }\n\n  private:\n    int x;\n    int* ptr;\n};\n\n\nvoid someFunction( FooInitialiser initialiser )\n{\n   int numFoos = MAGIC_NUMBER;\n   Foo* fooArray = new Foo[numFoos];   //allocate an array of default constructed Foo's\n\n   for(int i = 0; i &lt; numFoos; ++i)\n   {\n       new( fooArray+ i) Foo( initialiser );    //use placement new to initialise\n   }\n\n    //... do stuff\n\n   delete[] fooArray;\n}\n</code></pre>\n<p>This code has been in the code base for years and it would seem has never caused a problem. It's obviously a bad idea since someone could change the default constructor to allocate not expecting the second construction. Simply replacing the second constructor with an equivalent initialisation method would seem the sensible thing to do. eg. </p>\n<pre><code>void Foo::initialise(FooInitialiser&amp; init)\n{\n    x = init.getX();\n    ptr = new int;\n}\n</code></pre>\n<p>Although still subject to possible resource leaks, at least a defensive programmer might think to check for prior allocations in a normal method. </p>\n<p><strong>My question is:</strong></p>\n<p>Is constructing twice like this actually undefined behaviour/ outlawed by standard or simply just a bad idea? If undefined behaviour can you quote or point me to right place to look in the standard?</p>\n", "AcceptedAnswerId": "27552592", "Title": "C++ Is constructing object twice using placement new undefined behaviour?", "CreationDate": "2014-12-18T17:35:47.123", "Id": "27552466", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-12-22T11:13:32.207", "LastEditorUserId": "1773790", "LastActivityDate": "2014-12-22T11:13:32.207", "Score": "6", "OwnerUserId": "1773790", "Tags": "<c++><new-operator><language-lawyer><placement-new>", "AnswerCount": "1"}});