post_cb({"bq_ids": {"n4140": {"so_15047277_15047278_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 5440}, "so_15047277_15047278_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 5440}, "so_15047277_15047278_4": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_15047277_15047278_3": {"length": 5, "quality": 1.0, "section_id": 5440}}, "n3337": {"so_15047277_15047278_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 5235}, "so_15047277_15047278_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 5235}, "so_15047277_15047278_4": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_15047277_15047278_3": {"length": 5, "quality": 1.0, "section_id": 5235}}, "n4659": {"so_15047277_15047278_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6867}, "so_15047277_15047278_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 6867}, "so_15047277_15047278_4": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_15047277_15047278_3": {"length": 5, "quality": 1.0, "section_id": 6867}}}, "15047278": {"Id": "15047278", "PostTypeId": "2", "Body": "<p>[<em>Note: Originally, this was not meant to be a self-answered question; I just happened to find the answer myself while I was describing my attempts to investigate, and I thought it would have been nice to share it.</em>]</p>\n<p>According to Annex C (2.14.5) of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15047277_15047278_0\">The type of a string literal is changed from \u201carray of char\u201d to \u201c<strong>array of const char</strong>.\u201d [....]</p>\n</blockquote>\n<p>Moreover, Paragraph 7.1.6.2/4 specifies (about the result of <code>decltype</code>):</p>\n<blockquote>\n<p id=\"so_15047277_15047278_1\">The type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<p id=\"so_15047277_15047278_2\">\u2014 if <code>e</code> is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), <code>decltype(e)</code> is the type of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code> names a set of overloaded functions, the program is ill-formed;</p>\n<p id=\"so_15047277_15047278_3\">\u2014 otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n<p id=\"so_15047277_15047278_4\">\u2014 <strong>otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code></strong>;</p>\n<p id=\"so_15047277_15047278_5\">\u2014 otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</p>\n</blockquote>\n<p>Since <strong><a href=\"https://stackoverflow.com/questions/15036281/c11-value-category-of-string-literal/15036305#15036305\">string literals are lvalues</a></strong>, according to the above Paragraph and the Paragraph from Annex C, the result of <code>decltype(\"Hello\")</code> is an <strong><em>lvalue reference to</em></strong> an array of size 6 of constant narrow characters:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nint main()\n{\n    // This will NOT fire\n    static_assert(\n        std::is_same&lt;decltype(\"Hello\"), char const (&amp;)[6]&gt;::value, \n        \"Error!\"\n        );\n}\n</code></pre>\n<p>Finally, even though the <code>hello</code> variable <em>is</em> also an lvalue, the second compile-time assertion  from the question's text does not fire, because <code>hello</code> is an <em>unparenthesized id-expression</em>, which makes it fall into the first item of the above list from Paragraph 7.1.6.2/4. Therefore, the result of <code>decltype(hello)</code> is the type of the entity named by <code>hello</code>, which is <code>char const[6]</code>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-24T00:17:48.703", "Score": "29", "CreationDate": "2013-02-24T00:17:48.703", "ParentId": "15047277", "CommentCount": "5", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T12:32:01.897"}, "15047277": {"ViewCount": "1720", "Body": "<p>I'm getting unexpected results from all compilers on which I tried the following (GCC 4.7.2, GCC 4.8.0 beta, ICC 13.0.1, Clang 3.2, VC10):</p>\n<pre><code>#include &lt;type_traits&gt;\n\nint main()\n{\n    // This will fire\n    static_assert(\n        std::is_same&lt;decltype(\"Hello\"), char const[6]&gt;::value, \n        \"Error!\"\n        );\n}\n</code></pre>\n<p>I would have expected the compile-time assertion above <em>not</em> to fire, but it does. After all, this one does not (as expected):</p>\n<pre><code>#include &lt;type_traits&gt;\n\nint main()\n{\n    char const hello[6] = \"Hello\";\n\n    // This will not fire\n    static_assert(\n        std::is_same&lt;decltype(hello), char const[6]&gt;::value, \n        \"Error!\"\n        );\n}\n</code></pre>\n<p>So what is the result of <code>decltype(\"Hello\")</code> according to the C++11 Standard (references are highly appreciated)? What should I compare it to so that the compile-time assertion above doesn't fire?</p>\n", "AcceptedAnswerId": "15047278", "Title": "What is the result of decltype(\"Hello\")?", "CreationDate": "2013-02-24T00:17:48.703", "Id": "15047277", "CommentCount": "0", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-02-24T00:17:48.703", "Score": "35", "OwnerUserId": "1932150", "Tags": "<c++><c++11><string-literals><decltype>", "AnswerCount": "1"}});