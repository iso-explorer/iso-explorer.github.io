post_cb({"41295108": {"Id": "41295108", "PostTypeId": "2", "Body": "<p>Instead construct your <code>A</code> like so </p>\n<pre><code>B var(A{});\n</code></pre>\n<p>and it will not be confused for a function declaration.</p>\n", "LastActivityDate": "2016-12-23T04:15:02.933", "Score": "2", "CreationDate": "2016-12-23T04:15:02.933", "ParentId": "41295016", "CommentCount": "0", "OwnerUserId": "1540468"}, "bq_ids": {"n4140": {"so_41295016_41295089_1": {"length": 6, "quality": 1.0, "section_id": 3201}}, "n3337": {"so_41295016_41295089_1": {"length": 6, "quality": 1.0, "section_id": 3075}}, "n4659": {"so_41295016_41295089_2": {"length": 18, "quality": 0.8181818181818182, "section_id": 3962}, "so_41295016_41295089_1": {"length": 6, "quality": 1.0, "section_id": 3962}}}, "41295016": {"ViewCount": "192", "Body": "<pre><code>// Example program\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n\nclass A {\npublic:\n    int x; \n};\n\nclass B {\npublic:\n    B(A &amp;&amp;a) : m_a(std::move(a)) {}\n    A m_a;\n};\n\nint main()\n{\n    B var(std::move(A()));\n    // B var(A()); // does not compile why?\n\n    std::cout &lt;&lt; var.m_a.x &lt;&lt; \"\\n\";\n\n}\n</code></pre>\n<p>In the above snippet the commented out line doesn't compile. The error message appears that it's treating var like a function declaration. Even if A has a parameter for constructor it's still treated like a function declaration. Is there a way to write it so it won't be treated like function declaration? Using typename doesn't help in this case.</p>\n", "AcceptedAnswerId": "41295089", "Title": "Is there a way to initialize a class with constructed class without using std::move?", "CreationDate": "2016-12-23T04:02:08.347", "Id": "41295016", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-12-23T00:23:37.910", "Score": "4", "OwnerUserId": "884893", "Tags": "<c++>", "AnswerCount": "3"}, "41295120": {"Id": "41295120", "PostTypeId": "2", "Body": "<pre><code>B var = A();\n</code></pre>\n<p>Provided that the <code>B(A&amp;&amp;)</code> constructor is not <code>explicit</code> (in your case, it isn't, so, it is a working approach).</p>\n<p>The</p>\n<pre><code>B var(A{});\n</code></pre>\n<p>it's also a working approach to face your problem.</p>\n<p>The compiler thinks your original line is a function declaration, because in C++, you can declare anything locally, even functions or structs:</p>\n<pre><code>int f()\n{\n   void f(); // You declare that function exists.\n   class C; // You declare a class called `C` exists.\n}\n</code></pre>\n<p>In your case:</p>\n<pre><code>B var(A());\n</code></pre>\n<p>The compiler sees it exists a function called <code>var</code>, returning a <code>B</code>, and receiving a function which receives no parameters and returns an <code>A</code>.</p>\n<p>You must disambiguate this with any of the two approaches presented above.</p>\n", "LastActivityDate": "2016-12-23T04:16:29.507", "Score": "2", "CreationDate": "2016-12-23T04:16:29.507", "ParentId": "41295016", "CommentCount": "0", "OwnerUserId": "1794803"}, "41295089": {"Id": "41295089", "PostTypeId": "2", "Body": "<p>This problem is known as <a href=\"https://en.wikipedia.org/wiki/Most_vexing_parse\" rel=\"nofollow noreferrer\">the most vexing parse</a>, which exactly describes your situation, where the parser doesn't know if <strong>you</strong> want a function declaration, or the instantiation of an object. It's ambiguous in the sense that, to a human, some given piece of code does <em>X</em>, but to the compiler it's clearly doing <em>Y</em>.</p>\n<p>One way of getting around it is to use the <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow noreferrer\">list initialization</a> syntax:</p>\n<pre><code>B var{A()}; // note the use of brackets\n</code></pre>\n<p>This is no longer ambiguous, and it will call the constructor as you wanted. You also may use it in <code>A</code>, or in both:</p>\n<pre><code>B var(A{});\nB var{A{}};\n</code></pre>\n<p>Now, why is it ambiguous? Take for instance the declaration of a function parameter that is a <em>pointer to function</em>:</p>\n<pre><code>int foo(int (*bar)());\n</code></pre>\n<p>Here, the parameter is of type <em>pointer to function that takes no arguments and has return type of int</em>. Another way to declare pointers to function is by omitting the parentheses in the declarator:</p>\n<pre><code>int foo(int bar());\n</code></pre>\n<p>Which still declares a pointer to function identical to the previous one. As we're in the context of declaring parameters (<a href=\"http://eel.is/c++draft/dcl.fct#nt:parameter-declaration-clause\" rel=\"nofollow noreferrer\">parameter-declaration-clause</a>), the grammar being parsed is a <a href=\"http://eel.is/c++draft/dcl.name#nt:type-id\" rel=\"nofollow noreferrer\">type-id</a>, which is partly built on top of <a href=\"http://eel.is/c++draft/dcl.name#nt:abstract-declarator\" rel=\"nofollow noreferrer\">abstract-declarator</a>. Therefore, this allows us to remove the identifier:</p>\n<pre><code>int foo(int());\n</code></pre>\n<p>And we still end up with the same type.</p>\n<p>With that all said, let's examine your code and compare it to the examples above:</p>\n<pre><code>B var(A());\n</code></pre>\n<p>We have something that looks like a variable declaration of type <code>B</code> being initialized with <code>A()</code>. So far, so good. But wait, you said this doesn't compile!</p>\n<blockquote>\n<p id=\"so_41295016_41295089_0\">The error message appears that it's treating var like a function declaration.</p>\n</blockquote>\n<p><code>var</code> is in fact a function declaration, even though to you it didn't look like that in the first place. This behavior is due to <a href=\"http://eel.is/c++draft/dcl.decl#dcl.ambig.res-1.sentence-3\" rel=\"nofollow noreferrer\">[dcl.ambig.res]/1</a>:</p>\n<blockquote>\n<p id=\"so_41295016_41295089_1\">[\u2026] the resolution is to consider any construct that could possibly be a declaration a declaration.</p>\n</blockquote>\n<p>And that sentence applies here. Looking back at the previous examples:</p>\n<pre><code>int foo(int());\n</code></pre>\n<p>That is just as ambiguous as your code: <code>foo</code> could possibly be a declaration, so the resolution is to interpret this as one. Your <code>B var(A())</code> could possibly be a declaration just as well, so it holds the same resolution.</p>\n<p>The standard has a few examples of these cases on <a href=\"http://eel.is/c++draft/dcl.decl#dcl.ambig.res-1.example-1\" rel=\"nofollow noreferrer\">[dcl.ambig.res]/1, example #1</a>, and also gives some tips on how to disambiguate them on <a href=\"http://eel.is/c++draft/dcl.decl#dcl.ambig.res-1.note-1\" rel=\"nofollow noreferrer\">[dcl.ambig.res]/1, note #1</a>:</p>\n<blockquote>\n<p id=\"so_41295016_41295089_2\">[\u2009Note: A declaration can be explicitly disambiguated by adding parentheses around the argument.\n  The ambiguity can be avoided by use of copy-initialization or list-initialization syntax, or by use of a non-function-style cast.\n  \u2014\u2009end note\n  \u2009]</p>\n<p id=\"so_41295016_41295089_3\">[\u2009Example:</p>\n<pre><code>struct S {\n  S(int);\n};\n\nvoid foo(double a) {\n S w(int(a));                  // function declaration\n S x(int());                   // function declaration\n S y((int(a)));                // object declaration\n S y((int)a);                  // object declaration\n S z = int(a);                 // object declaration\n}\n</code></pre>\n<p id=\"so_41295016_41295089_4\">\u2014\u2009end example\n  \u2009]</p>\n</blockquote>\n", "LastEditorUserId": "3646096", "LastActivityDate": "2017-12-23T00:23:37.910", "Score": "9", "CreationDate": "2016-12-23T04:12:10.230", "ParentId": "41295016", "CommentCount": "0", "OwnerUserId": "3646096", "LastEditDate": "2017-12-23T00:23:37.910"}});