post_cb({"37514127": {"ParentId": "37493769", "CommentCount": "0", "Body": "<p>This is partly covered by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1725\" rel=\"nofollow\">CWG 1725</a>:</p>\n<blockquote>\n<p id=\"so_37493769_37514127_0\">The treatment of a declaration like the following is not clear:</p>\n<pre><code>auto (*f())() -&gt; int; // #1\n</code></pre>\n<p id=\"so_37493769_37514127_1\">8.3.5 [dcl.fct] paragraph 2 appears to require determining the type of the nested declarator</p>\n<pre><code>auto (*f()); // #2\n</code></pre>\n<p id=\"so_37493769_37514127_2\">which, because it does not have a\n  trailing-return-type, would be ill-formed by (C++11) 7.1.6.4\n  [dcl.spec.auto]. (In C++14, an auto return type without a\n  trailing-return-type is, of course, permitted.)</p>\n<p id=\"so_37493769_37514127_3\"><strong>Rationale (September, 2013): The intent of the C++11 wording is that the requirement for a trailing return type applies only at the top level of the declarator to which auto applies, not to each possible recursive stage in the declarator processing.</strong> [..]</p>\n</blockquote>\n<p>Furthermore, according to <a href=\"http://eel.is/c++draft/dcl.fct#2\" rel=\"nofollow\">[dcl.fct]/2</a>,</p>\n<blockquote>\n<p id=\"so_37493769_37514127_4\">In a declaration <code>T D</code> where <code>D</code> has the form</p>\n<p id=\"so_37493769_37514127_5\">\u00a0\u00a0\u00a0\u00a0\u00a0<code>D1</code> <code>(</code> <em>parameter-declaration-clause</em> <code>)</code> [...] <em>trailing-return-type</em></p>\n<p id=\"so_37493769_37514127_6\"><strong>and the type of the contained <em>declarator-id</em> in the declaration <code>T D1</code> is \u201c<em>derived-declarator-type-list</em> <code>T</code>\u201d</strong>, <code>T</code> shall be the single <em>type-specifier</em> <code>auto</code>.</p>\n</blockquote>\n<p>As mentioned in the DR, <code>T D1</code> is <code>auto (*f())</code>, which is of type \"function of <code>()</code> returning pointer to <code>auto</code>\" (i.e. matches the requirement). Hence your code is valid in both C++11 and 14, and <code>f</code>'s type is \"function of <code>()</code> returning pointer to function of <code>()</code> returning <code>int</code>\".</p>\n", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "37514127", "Score": "3", "CreationDate": "2016-05-29T19:37:28.533", "LastActivityDate": "2016-05-29T19:37:28.533"}, "bq_ids": {"n4140": {"so_37493769_37493769_1": {"section_id": 5446, "quality": 0.6428571428571429, "length": 9}, "so_37493769_37493769_0": {"section_id": 5965, "quality": 0.5454545454545454, "length": 6}, "so_37493769_37514127_6": {"section_id": 3238, "quality": 1.0, "length": 8}}, "n3337": {"so_37493769_37493769_1": {"section_id": 5241, "quality": 0.8571428571428571, "length": 12}, "so_37493769_37514127_6": {"section_id": 3111, "quality": 1.0, "length": 8}}, "n4659": {"so_37493769_37493769_1": {"section_id": 6873, "quality": 0.6428571428571429, "length": 9}, "so_37493769_37514127_6": {"section_id": 3994, "quality": 0.875, "length": 7}}}, "37493769": {"CommentCount": "5", "ViewCount": "832", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2016-05-27T23:45:35.723", "LastActivityDate": "2016-05-29T19:41:24.163", "Title": "Is this trailing return type legal in C++11?", "LastEditDate": "2016-05-29T19:41:24.163", "Id": "37493769", "Score": "8", "Body": "<p>The following:</p>\n<pre><code>auto (*f())() -&gt; int;\n</code></pre>\n<p>gives an error in C++11 mode with Clang saying:</p>\n<blockquote>\n<p id=\"so_37493769_37493769_0\">error: 'auto' return without trailing return type; deduced return\n  types are a C++14 extension</p>\n</blockquote>\n<p>but compiles in C++14 mode. GCC compiles without complaining in both modes with <code>-Wall -Wextra -pedantic</code>. </p>\n<p>n3337 7.1.6.4/2 says:</p>\n<blockquote>\n<p id=\"so_37493769_37493769_1\">The auto type-specifier may appear with a function declarator with a\n  trailing-return-type (8.3.5) in any context where such a declarator is\n  valid.</p>\n</blockquote>\n<p>8.3.5p2 talks about function declarators but I'm too inexperienced to figure it out. Can anyone explain if it's legal in C++11?</p>\n", "Tags": "<c++><c++11><language-lawyer><trailing-return-type>", "OwnerUserId": "6393063", "AnswerCount": "1"}});