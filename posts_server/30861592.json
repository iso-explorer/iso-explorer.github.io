post_cb({"30861864": {"Id": "30861864", "PostTypeId": "2", "Body": "<p>C does not support templates and the</p>\n<pre><code>typedef struct tagX {\n} X;\n</code></pre>\n<p>syntax in C++ is vestigial C, there to allow continued support for C headers etc, not for use in actual C++.</p>\n<p>The C++ syntax for the above is</p>\n<pre><code>struct X {};\n</code></pre>\n<p>(YMMV on brace placement)</p>\n", "LastActivityDate": "2015-06-16T07:57:41.500", "Score": "1", "CreationDate": "2015-06-16T07:57:41.500", "ParentId": "30861592", "CommentCount": "0", "OwnerUserId": "257645"}, "bq_ids": {"n4140": {"so_30861592_30861924_1": {"length": 19, "quality": 1.0, "section_id": 50}, "so_30861592_30861592_0": {"length": 31, "quality": 0.96875, "section_id": 48}}, "n3337": {"so_30861592_30861924_1": {"length": 19, "quality": 1.0, "section_id": 45}, "so_30861592_30861592_0": {"length": 29, "quality": 0.90625, "section_id": 43}}, "n4659": {"so_30861592_30861924_1": {"length": 19, "quality": 1.0, "section_id": 51}, "so_30861592_30861592_0": {"length": 31, "quality": 0.96875, "section_id": 49}}}, "30861592": {"ViewCount": "623", "Body": "<p>From a practical point of view, I understand that both <code>typedef</code> and <code>test</code> are somewhat \"superfluous\" and need to be removed if we want the following code to compile:</p>\n<pre><code>template&lt; typename type_t &gt;\ntypedef struct tagTest\n{\n    int a;\n} test;\n</code></pre>\n<p>However, I thought that the set of typedef declarations was a subset of the set of declarations. They just happened to have that specific <em>decl-specifier</em>. That was my rationalization for </p>\n<pre><code>typedef struct tagTest\n{\n    int a;\n} test;\n</code></pre>\n<p>introducing the identifier <code>test</code> <strong>and</strong> declaring the structure <code>tagTest</code>. If that interpretation is correct, then the following paragraph from the standard should allow <code>template</code> <code>typedef</code>'s (although not with the meaning given by the keyword <code>using</code>).</p>\n<blockquote>\n<p id=\"so_30861592_30861592_0\">The declaration in a template-declaration shall\n  \u2014\n  (1.1)\n  declare or define a function, a class, or a variable, or\n  \u2014\n  (1.2)\n  define a member function, a member class, a member enumeration, or a static data member of a class\n  template or of a class nested within a class template, or\n  \u2014\n  (1.3)\n  define a member template of a class or class template, or\n  \u2014\n  (1.4)\n  be an alias-declaration.</p>\n</blockquote>\n<p>I cannot see error in my reasoning, yet the conclusion is illegal.</p>\n<p>What are the relevant parts of the standard that solve the above conundrum?</p>\n<hr>\n<p><strong>UPDATE</strong>\nPart of the above reasoning uses the fact that <code>typedef</code> <code>struct</code> declares a structure. The <code>typedef</code> specifier, as far as I understand it, implies that any variables declared are really types. That is, the <code>typedef</code> upgrades <code>test</code> from a mere variable to a type that is equivalent to the declared <code>tagTest</code>. That is why the following code compiles (albeit with a warning).</p>\n<pre><code>typedef struct tagTest\n{\n    int a;\n};\ntagTest t;\n</code></pre>\n<p>One of the answers takes care of the superfluous <code>test</code>. But, it is possible to use typedef without a declarator <a href=\"http://en.cppreference.com/w/cpp/language/declarations\" rel=\"nofollow\">because</a> \"Init-declarator-list is optional when declaring a named class/struct/union or a named enumeration\"</p>\n</hr>", "AcceptedAnswerId": "30861924", "Title": "Why are typedef templates illegal?", "CreationDate": "2015-06-16T07:42:27.790", "Id": "30861592", "CommentCount": "8", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-07-15T19:27:27.863", "LastEditorUserId": "2549876", "LastActivityDate": "2015-08-06T06:56:37.193", "Score": "6", "OwnerUserId": "2549876", "Tags": "<c++><templates><language-lawyer>", "AnswerCount": "3"}, "30861924": {"Id": "30861924", "PostTypeId": "2", "Body": "<p><a href=\"http://www.gotw.ca/gotw/079.htm\" rel=\"nofollow noreferrer\">Template typedefs</a> weren't allowed pre-C++11 and with C++11 <a href=\"http://en.cppreference.com/w/cpp/language/type_alias\" rel=\"nofollow noreferrer\">template aliases</a> were introduced to address those issues. Cfr. <a href=\"https://stackoverflow.com/a/2795024/1938163\">C++ template typedefs</a> and <a href=\"https://en.wikipedia.org/wiki/C%2B%2B11#Template_aliases\" rel=\"nofollow noreferrer\">wikipedia</a>.</p>\n<p>Since, as you noted, the standard doesn't allow <code>typedef</code> to be in there, the code is invalid</p>\n<blockquote>\n<p id=\"so_30861592_30861924_0\">alias-declaration:</p>\n<pre><code> using identifier attribute-specifier-seqopt= type-id ;\n</code></pre>\n</blockquote>\n<p><code>typedef</code> declarations are not <em>alias declarations</em>.</p>\n<p>Furthermore you can't have a declarator if you're declaring a class template, it is explicitly forbidden by the standard</p>\n<p><em>[temp]/p3</em></p>\n<blockquote>\n<p id=\"so_30861592_30861924_1\">In a template-declaration, explicit specialization, or explicit instantiation the init-declarator-list in the declaration\n  shall contain at most one declarator. <strong>When such a declaration is used to declare a class template,\n  no declarator is permitted</strong>.</p>\n</blockquote>\n<p>so not even the following will compile</p>\n<pre><code>template&lt; typename type_t &gt;\nstruct tagTest\n{\n    int a;\n} test;\n</code></pre>\n<hr>\n<p>Edit: </p>\n<p>It is nowhere specified that </p>\n<pre><code>typedef struct S { };\n</code></pre>\n<p>should be an error, thus both gcc and clang accept it with a warning. I assume Clang counts on <em>[temp]/3</em> to issue an error in case typedef was being used with a template while gcc rejects this code immediately</p>\n<pre><code>template&lt;typename T&gt;\ntypedef struct S { };\n</code></pre>\n<p>cfr. clang bug <a href=\"http://lists.cs.uiuc.edu/pipermail/llvmbugs/2015-January/038013.html\" rel=\"nofollow noreferrer\">22249</a></p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-06T06:56:37.193", "Score": "3", "CreationDate": "2015-06-16T08:01:59.353", "ParentId": "30861592", "CommentCount": "4", "LastEditDate": "2017-05-23T11:53:02.863", "OwnerUserId": "1938163"}, "30861749": {"Id": "30861749", "PostTypeId": "2", "Body": "<p>Independently from what the <code>typedef</code> defines, that is a <code>typedef</code> declaration, which is not listed in those cases:</p>\n<ul>\n<li>[member] function</li>\n<li>[member] class</li>\n<li>variable</li>\n<li>member enumeration</li>\n<li>static data member of a class template/of a class nested within a class template</li>\n<li>member template of a class or class template</li>\n<li>alias declaration</li>\n</ul>\n<p>And just to be clear <code>typedef</code> declarations are not <em>alias declarations</em>. <em>Alias declaration</em>, as specified by the grammar at \u00a77 of the standard are:</p>\n<blockquote>\n<p id=\"so_30861592_30861749_0\"><em>alias-declaration</em>:</p>\n<p id=\"so_30861592_30861749_1\"><code>using identifier attribute-specifier-seqopt= type-id ;</code></p>\n</blockquote>\n<p>Not to mention that if this was possible, then template <code>using</code> declaration would not be nearly as \"cool\" as they are today, and <a href=\"https://stackoverflow.com/a/23196675/493122\">there would be little to no sense to have both</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-16T07:58:13.200", "Score": "1", "CreationDate": "2015-06-16T07:51:30.140", "ParentId": "30861592", "CommentCount": "1", "LastEditDate": "2017-05-23T12:13:44.170", "OwnerUserId": "493122"}});