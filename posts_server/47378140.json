post_cb({"47378140": {"Tags": "<c++><templates><operator-overloading><function-overloading><overload-resolution>", "ViewCount": "45", "LastEditDate": "2017-11-19T15:13:19.403", "CreationDate": "2017-11-19T14:45:35.750", "LastEditorUserId": "7920139", "Title": "Why do we not find the right operator overload when using the macro?", "CommentCount": "9", "AcceptedAnswerId": "47381158", "Score": "1", "OwnerUserId": "7920139", "Id": "47378140", "LastActivityDate": "2017-11-19T19:35:59.680", "Body": "<p>I am writing a class template which takes an arbitrary function pointer as non-type template argument. I would like to use</p>\n<pre><code>template &lt;auto F&gt; struct Foo;\n</code></pre>\n<p>but my compiler (MSVC 2017.5) does not support <code>auto</code> in the template parameter list (even though it supports many C++17 features). So I wrote a hack around this somehow like this:</p>\n<pre><code>template &lt;typename T&gt;\nusing Func = void (*)(T);\n\ntemplate &lt;typename TF, TF F&gt; struct Foo;\ntemplate &lt;typename T, Func&lt;T&gt; F&gt; \nstruct Foo&lt;Func&lt;T&gt;, F&gt; { ... };\n\n#define FOO(func) Foo&lt;decltype(func), func&gt;\n</code></pre>\n<p>I implemented a streaming operator (for <code>QDebug</code> or any other text stream) like this:</p>\n<pre><code>template &lt;typename T, Func&lt;T&gt; F&gt;\nQDebug &amp;operator &lt;&lt;(QDebug &amp;out, const FOO(F) &amp;foo)\n{\n    ...\n    return out;\n}\n</code></pre>\n<p>But my main code cannot find the right <code>operator&lt;&lt;</code> overload:</p>\n<pre><code>void func(int) { ... }\n\n...\n\nFOO(&amp;func) foo;\nqDebug() &lt;&lt; foo; // error\n</code></pre>\n<p>Surprisingly, everything works when defining the operator like</p>\n<pre><code>QDebug &amp;operator &lt;&lt;(QDebug &amp;out, const Foo&lt;Func&lt;T&gt;, F&gt; &amp;foo)\n//                                     ^^^^^^^^^^^^^^^\n</code></pre>\n<p>It seems that <code>Func&lt;T&gt;</code> from this last line and <code>decltype&lt;F&gt;</code> from the macro do not give the same type. But I checked this and <code>std::is_same_v&lt;Func&lt;int&gt;, decltype(&amp;func)&gt;</code> gives true. I cannot think why using the macro <code>FOO</code> gives me any other compile time behavior as when not using it.</p>\n<hr>\n<p>A minimal working example:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nusing Func = void (*)(T);\n\ntemplate &lt;typename TF, TF F&gt; struct Foo;\ntemplate &lt;typename T, Func&lt;T&gt; F&gt; \nstruct Foo&lt;Func&lt;T&gt;, F&gt; { };\n\n#define FOO(func) Foo&lt;decltype(func), func&gt;\n\ntemplate &lt;typename T, Func&lt;T&gt; F&gt;\nstd::ostream &amp;operator &lt;&lt;(std::ostream &amp;out, const FOO(F) &amp;foo)\n// std::ostream &amp;operator &lt;&lt;(std::ostream &amp;out, const Foo&lt;Func&lt;T&gt;,F&gt; &amp;foo)\n{\n    return out;\n}\n\nvoid func(int);\n\nint main(int argc, char **argv)\n{\n    FOO(&amp;func) foo;\n    std::cout &lt;&lt; foo &lt;&lt; std::endl; // error\n}\n</code></pre>\n</hr>", "PostTypeId": "1", "AnswerCount": "3"}, "47378404": {"ParentId": "47378140", "Score": "2", "CreationDate": "2017-11-19T15:12:00.320", "Id": "47378404", "OwnerUserId": "1774667", "LastActivityDate": "2017-11-19T15:12:00.320", "Body": "<p>A workaround:</p>\n<pre><code>template &lt;typename T, Func&lt;T&gt; F&gt; \nstruct Foo&lt;Func&lt;T&gt;, F&gt; {\n  friend QDebug &amp;operator &lt;&lt;(QDebug &amp;out, const Foo &amp;foo){\n    ...\n    return out;\n  }\n};\n</code></pre>\n", "PostTypeId": "2", "CommentCount": "0"}, "47381158": {"ParentId": "47378140", "Score": "1", "CreationDate": "2017-11-19T19:35:59.680", "Id": "47381158", "OwnerUserId": "2069064", "LastActivityDate": "2017-11-19T19:35:59.680", "Body": "<p>As part of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0127r2.html\" rel=\"nofollow noreferrer\"><code>template auto</code> paper</a>, we also got a new deduction rule in <a href=\"http://eel.is/c++draft/temp.deduct.type#13\" rel=\"nofollow noreferrer\">[temp.deduct.type]</a>:</p>\n<blockquote>\n<p id=\"so_47378140_47381158_0\">When the value of the argument corresponding to a non-type template parameter <code>P</code> that is declared with a dependent type is deduced from an expression, the template parameters in the type of <code>P</code> are deduced from the type of the value.</p>\n</blockquote>\n<p>This rule allows the following example to work in C++17, because we can deduce <code>T</code> from the type of <code>V</code>:</p>\n<pre><code>template &lt;typename T, T V&gt;\nstruct constant { };\n\ntemplate &lt;typename T, T V&gt;\nvoid foo(constant&lt;decltype(V), V&gt; ) { }\n\nint main() {\n    foo(constant&lt;int, 4&gt;{});\n}\n</code></pre>\n<p>In C++14 and earlier, this example is ill-formed because <code>T</code> isn't deduced. It is precisely this behavior that you are trying to use (implicitly) when you use that macro, which expands into:</p>\n<pre><code>template &lt;typename T, Func&lt;T&gt; F&gt;\nstd::ostream &amp;operator &lt;&lt;(std::ostream &amp;out, const Foo&lt;decltype(F), F&gt; &amp;foo);\n</code></pre>\n<p>You are trying to deduce <code>T</code> from <code>F</code>. Since MSVC doesn't support <code>template auto</code> yet, it's perhaps unsurprising that it also doesn't support other parts of the machinery requires to make <code>template auto</code> work. And that's the difference between the macro and the non-macro alternative, which can simply deduce <code>T</code>:</p>\n<pre><code>template &lt;typename T, Func&lt;T&gt; F&gt;\nstd::ostream &amp;operator &lt;&lt;(std::ostream &amp;out, const Foo&lt;Func&lt;T&gt;,F&gt; &amp;foo)\n</code></pre>\n<p>So the simple solution is to just... don't use a macro, since you have a working form, even it's more verbose. A longer solution is to use <a href=\"https://stackoverflow.com/a/47378404/2069064\">Yakk's answer</a> which side-steps the whole deduction question entirely. </p>\n", "PostTypeId": "2", "CommentCount": "0"}, "47378267": {"ParentId": "47378140", "Score": "0", "CreationDate": "2017-11-19T14:58:36.263", "LastActivityDate": "2017-11-19T15:21:47.910", "LastEditDate": "2017-11-19T15:21:47.910", "OwnerUserId": "7860670", "LastEditorUserId": "7860670", "Body": "<p>When no macro is used second template parameter <code>F</code> can be deduced from second function argument <code>foo</code>. When macro is used second template parameter <code>F</code> can not be deduced from second function argument because it will appear inside of <code>decltype</code>: <code>Foo&lt;decltype(F), F&gt; &amp; foo</code>. Your code can be simplified to</p>\n<pre><code>template&lt;typename T&gt;\nvoid f(decltype(T) v){}\n\nint v{};\nf(v);\n</code></pre>\n<p>Compiler knowns the type of argument (<code>int</code>) however template parameter <code>T</code> can not be deduced from known type of argument because when used inside of <code>decltype</code> <code>T</code> must be known at advance.</p>\n", "Id": "47378267", "PostTypeId": "2", "CommentCount": "4"}, "bq_ids": {"n4659": {"so_47378140_47381158_0": {"length": 18, "section_id": 353, "quality": 1.0}}}});