post_cb({"25882744": {"CommentCount": "1", "AcceptedAnswerId": "27261416", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-09-17T05:12:18.293", "LastActivityDate": "2014-12-03T00:12:39.257", "AnswerCount": "1", "LastEditDate": "2017-05-23T12:12:46.643", "ViewCount": "91", "FavoriteCount": "1", "Title": "Understanding derived-declarator-type-list and array decalrator", "Id": "25882744", "Score": "1", "Body": "<p>The section 8.3.4/1 N3797:</p>\n<blockquote>\n<p id=\"so_25882744_25882744_0\">In a declaration T D where D has the form</p>\n<p id=\"so_25882744_25882744_1\">D1 [ constant-expressionopt] attribute-specifier-seqopt</p>\n<p id=\"so_25882744_25882744_2\">and the type of the identifier in the\n  declaration T D1 is <code>\u201cderived-declarator-type-list T\u201d</code>, then the type\n  of the identifier of D is an array type;</p>\n</blockquote>\n<p>I've understood what is the <code>derived-declarator-type-list</code> from that <a href=\"https://stackoverflow.com/questions/13779273/in-the-standard-what-is-derived-declarator-type\"><strong>Q|A</strong></a>.</p>\n<p>But I'm interested in an example of the declaration <code>T D</code> such that the type of the identifier in the decalaration <code>T D1</code> hasn't form of <code>\u201cderived-declarator-type-list T\u201d</code>. </p>\n<p>That is the type of identifier of T D where D has the form </p>\n<pre><code>D1 [ constant-expressionopt] attribute-specifier-seqopt \n</code></pre>\n<p>isn't an array type. Is it possible at all?</p>\n", "Tags": "<c++><arrays>", "OwnerDisplayName": "user2953119"}, "bq_ids": {"n4140": {"so_25882744_25882744_2": {"section_id": 3228, "quality": 1.0, "length": 9}}, "n3337": {"so_25882744_25882744_2": {"section_id": 3101, "quality": 1.0, "length": 9}}, "n4659": {"so_25882744_25882744_2": {"section_id": 3985, "quality": 0.8888888888888888, "length": 8}}}, "27261416": {"ParentId": "25882744", "CommentCount": "0", "Body": "<p>First, we are in section 8 about declarators.  In this context <code>[]</code> cannot designate subscripting operator (expression, chapter 5.2.1) nor the lambda introducer (expression, chapter 5.1.2) but only arrays.  </p>\n<p>Next, we have to consider that we have simple and more complex declarators:  </p>\n<pre><code>int ndigit[10];    // T is int, D is ndigit[10] which is an array type \n                   // the type of the identifier ndigit is derived declarator type int \nchar *str[512];    // T is char*,  D is str[10] wich is an array type\n                   // the type of the identifier str is derived declarator type char*  \n</code></pre>\n<p>Knowing all this, we have to breathe in profundly and step back a little bit from our linguisic habits. </p>\n<p>As programmer, when we read an english sentence like </p>\n<pre><code>    If P1 and P2 then P3\n</code></pre>\n<p>we instinctively understand that there are two conditions and translate in c++ :</p>\n<pre><code>    if (P1 &amp;&amp; P2) P3;    // 2 conditions must be true and P3 will be done\n</code></pre>\n<p>But english is not C++ ! There are also other valid meanings.  Take this unrelated mathematical example :   </p>\n<pre><code>    ax\u00b2+bx+c =0   \n    if \u0394 =b\u00b2-4ac and \u0394 &gt;0 then there are two distinct roots \n</code></pre>\n<p>In this example, it is obvious, that <code>\u0394 =b\u00b2-4ac</code> is not an additional condition for having two roots.  It's just a way to introduce (without making an extra sentence) a naming convention that is used in the condition or the conclusion .  </p>\n<p>Of course one can argue that this style is not a good practice, and that we should have written:  </p>\n<pre><code>    ax\u00b2+bx+c =0   \n    let's define \u0394 =b\u00b2-4ac \n    If \u0394 &gt;0 then there are two distinct roots \n</code></pre>\n<p>I completely agree !  Now let's apply this kind of reading to the standard:  </p>\n<pre><code>    In a declaration T D where D has the form\n        D1 [ constant-expressionopt] attribute-specifier-seqopt\n    Let the type of the identifier in the declaration T D1 be \u201cderived-declarator-type-list T\u201d\n    Then the type of the identifier of D is an array type;\n</code></pre>\n<p>Would this be more understandable for you ?  </p>\n<p>This kind of sentences make it clear that the main goal of a standard is not to be easy to read, but to express unambiguously complex language constructs, and completely conver all their semantic and syntactic variants. </p>\n", "OwnerUserId": "3723423", "PostTypeId": "2", "Id": "27261416", "Score": "0", "CreationDate": "2014-12-03T00:12:39.257", "LastActivityDate": "2014-12-03T00:12:39.257"}});