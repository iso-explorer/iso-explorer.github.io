post_cb({"bq_ids": {"n4140": {"so_13272959_13272959_2": {"length": 11, "quality": 1.0, "section_id": 6779}, "so_13272959_13272959_1": {"length": 23, "quality": 0.92, "section_id": 6778}}, "n3337": {"so_13272959_13272959_2": {"length": 11, "quality": 1.0, "section_id": 6534}, "so_13272959_13272959_1": {"length": 23, "quality": 0.92, "section_id": 6533}}, "n4659": {"so_13272959_13272959_1": {"length": 22, "quality": 0.88, "section_id": 8272}}}, "13272959": {"ViewCount": "513", "Body": "<p>In <a href=\"https://stackoverflow.com/questions/13150449/\">another question</a>, the topic of <code>std::numeric_limits&lt;int&gt;::is_modulo</code> came up.  But the more I think about it, the more it seems like something is wrong with the spec or with GCC or both.</p>\n<p>Let me start with some code:</p>\n<pre><code>#include &lt;limits&gt;\n#include &lt;iostream&gt;\n\nbool test(int x)\n{\n    return x+1 &gt; x;\n}\n\nint main(int argc, char *argv[])\n{\n    int big = std::numeric_limits&lt;int&gt;::max();\n\n    std::cout &lt;&lt; std::numeric_limits&lt;int&gt;::is_modulo &lt;&lt; \" \";\n    std::cout &lt;&lt; big+1 &lt;&lt; \" \";\n    std::cout &lt;&lt; test(big) &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>When I compile this with <code>g++ -O3 -std=c++11</code> (x86_64 GCC 4.7.2), it produces the following output:</p>\n<pre><code>1 -2147483648 1\n</code></pre>\n<p>That is, <code>is_modulo</code> is true, one plus <code>INT_MAX</code> is negative, and one plus <code>INT_MAX</code> is greater than <code>INT_MAX</code>.</p>\n<p>If you are the sort of person with any realistic chance of answering this question, you already know what happened here.  The C++ specification says that integer overflow is Undefined Behavior; the compiler is allowed to assume you do not do that; therefore the argument to <code>x+1</code> cannot be <code>INT_MAX</code>; therefore the compiler may (and will) compile the <code>test</code> function to return <code>true</code> unconditionally.  So far, so good.</p>\n<p>However, the <a href=\"https://stackoverflow.com/questions/7238958/\">C++11 spec</a> also says (18.3.2.4 paragraphs 60-61):</p>\n<blockquote>\n<p id=\"so_13272959_13272959_0\"><strong><code>static constexpr is_modulo;</code></strong></p>\n<p id=\"so_13272959_13272959_1\">True if the type is modulo.222 A type is modulo if, for any operation\n  involving <code>+</code>, <code>-</code>, or <code>*</code> on values of that type whose result would\n  fall outside the range <code>[min(),max()]</code>, the value returned differs\n  from the true value by an integer multiple of <code>max() - min() + 1</code>.</p>\n<p id=\"so_13272959_13272959_2\">On most machines, this is <code>false</code> for floating types, <code>true</code> for\n  unsigned integers, and <code>true</code> for signed integers.</p>\n</blockquote>\n<p>Note that section 5 paragraph (4) still reads, \"If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined.\"  There is no mention of <code>is_modulo == true</code> creating an exception.</p>\n<p>So it looks to me like the standard is logically contradictory, because integer overflow cannot simultaneously be defined and undefined.  Or at the very least, GCC is non-conforming, because it has <code>is_modulo</code> as <code>true</code> even though signed arithmetic most certainly does not wrap around.</p>\n<p>Is the standard buggy?  Is GCC non-conforming?  Am I missing something?</p>\n", "AcceptedAnswerId": "13275027", "Title": "Is numeric_limits<int>::is_modulo logically contradictory?", "CreationDate": "2012-11-07T15:36:58.260", "Id": "13272959", "CommentCount": "15", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:15:48.897", "LastEditorUserId": "-1", "LastActivityDate": "2012-11-07T17:39:05.960", "Score": "26", "OwnerUserId": "768469", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "1"}, "13275027": {"Id": "13275027", "PostTypeId": "2", "Body": "<p>If <code>is_modulo</code> is <code>true</code> for a signed type (e.g. <code>int</code>) that is unchanged by the usual arithmetic conversions, then for any arithmetic operation other than division by zero there is a single correct result in the (mathematical) integers that modulo maps to a single value in the range of the type, and so the implementation is constrained to behave as if the actual result is the true result modulo the range of the type. So if an implementation wants to retain overflow arithmetic as being undefined it must set <code>is_modulo</code> to <code>false</code>.</p>\n<p>This was discussed <em>ad nauseam</em> on the gcc mailing list and then under <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200\" rel=\"noreferrer\">PR 22200</a> with the eventual conclusion that the value of <code>is_modulo</code> should be <code>false</code> for signed types; <a href=\"http://gcc.gnu.org/viewcvs?view=revision&amp;revision=186944\" rel=\"noreferrer\">the change</a> was made to libstdc++ in April of this year.</p>\n<p>Note that in C++03 the language was significantly different:</p>\n<blockquote>\n<h3><del>18.2.1.2 numeric_limits members [lib.numeric.limits.members]</del></h3>\n<p id=\"so_13272959_13275027_0\">56 - [...] A type is modulo if it is possible to add two positive numbers and have a result that\n  wraps around to a third number that is less.</p>\n</blockquote>\n<p>Given that with undefined behaviour <em>anything</em> is possible, it is arguable that the previous behaviour of libstdc++ (having <code>is_modulo</code> as <code>true</code>) was correct and consistent with the behaviour of g++; the earlier discussions on the linked PR should be read with this in mind.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-11-07T17:39:05.960", "Score": "18", "CreationDate": "2012-11-07T17:32:33.793", "ParentId": "13272959", "CommentCount": "3", "OwnerUserId": "567292", "LastEditDate": "2012-11-07T17:39:05.960"}});