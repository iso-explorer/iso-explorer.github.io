post_cb({"33825360": {"ParentId": "33824954", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>18446744073709551615</code> is not exactly representible in <code>double</code> (in IEEE754). This is not unexpected, as a 64-bit floating point obviously cannot represent all integers that are representible in 64 bits.</p>\n<p>According to the C++ Standard, it is <em>implementation-defined</em> whether the next-highest or next-lowest <code>double</code> value is used. Apparently on your system, it selects the next highest value, which seems to be <code>1.8446744073709552e19</code>.  You could confirm this by outputting the double with more digits of precision.</p>\n<p>Note that this is larger than the original number.</p>\n<p>When you convert this double to integer, the behaviour is covered by [conv.fpint]/1:</p>\n<blockquote>\n<p id=\"so_33824954_33825360_0\">A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates; that is, the fractional part is discarded. The <strong>behavior is undefined</strong> if the truncated value cannot be represented in the destination type.</p>\n</blockquote>\n<p>So this code potentially causes <a href=\"https://stackoverflow.com/a/4105123/1505939\">undefined behaviour</a>. When undefined behaviour has occurred, anything can happen, including (but not limited to) bogus output.</p>\n<hr>\n<p>The question was originally posted with <code>long double</code>, rather than <code>double</code>. On my gcc, the <code>long double</code> case behaves correctly, but on OP's MSVC it gave the same error.  This could be explained by gcc using 80-bit <code>long double</code>, but MSVC using 64-bit <code>long double</code>.</p>\n</hr>", "OwnerUserId": "1505939", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:02:31.193", "Id": "33825360", "Score": "12", "CreationDate": "2015-11-20T11:15:49.723", "LastActivityDate": "2015-11-20T11:24:09.853"}, "33824954": {"CommentCount": "15", "ViewCount": "1812", "PostTypeId": "1", "LastEditorUserId": "2692339", "CreationDate": "2015-11-20T10:57:04.177", "LastActivityDate": "2015-11-20T16:28:46.093", "Title": "Cast from unsigned long long to double and vice versa changes the value", "AcceptedAnswerId": "33825360", "LastEditDate": "2015-11-20T15:25:45.540", "Id": "33824954", "Score": "10", "Body": "<p>When writing a C++ code I suddenly realised that my numbers are incorrectly casted from <code>double</code> to <code>unsigned long long</code>.  </p>\n<p>To be specific, I use the following code:</p>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\nusing namespace std;\n\nint main()\n{\n  unsigned long long ull = numeric_limits&lt;unsigned long long&gt;::max();\n  double d = static_cast&lt;double&gt;(ull);\n  unsigned long long ull2 = static_cast&lt;unsigned long long&gt;(d);\n  cout &lt;&lt; ull &lt;&lt; endl &lt;&lt; d &lt;&lt; endl &lt;&lt; ull2 &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/B4V5St\" rel=\"nofollow\">Ideone live example</a>.</p>\n<p>When this code is executed on my computer, I have the following output:</p>\n<pre><code>18446744073709551615\n1.84467e+019\n9223372036854775808\nPress any key to continue . . .\n</code></pre>\n<p>I expected the first and third numbers to be exactly the same (just like on Ideone) because I was sure that <code>long double</code> took 10 bytes, and stored the mantissa in 8 of them. I would understand if the third number were truncated compared to first one - just for the case I'm wrong with the floating-point numbers format. But here the values are twice different!</p>\n<p>So, the main question is: why? And how can I predict such situations?</p>\n<p>Some details: I use Visual Studio 2013 on Windows 7, compile for x86, and <code>sizeof(long double) == 8</code> for my system.</p>\n", "Tags": "<c++><casting><floating-point>", "OwnerUserId": "1989995", "AnswerCount": "3"}, "33825298": {"ParentId": "33824954", "CommentCount": "2", "Body": "<p>It's due to <code>double</code> approximation to <code>long long</code>. Its precision means ~100 units error at 10^19; as you try to convert values around the upper limit of long long range, it overflows. Try to convert 10000 lower value instead :)</p>\n<p>BTW, at Cygwin, the third printed value is zero</p>\n", "OwnerUserId": "4819357", "PostTypeId": "2", "Id": "33825298", "Score": "1", "CreationDate": "2015-11-20T11:13:29.613", "LastActivityDate": "2015-11-20T11:13:29.613"}, "bq_ids": {"n4140": {"so_33824954_33825360_0": {"section_id": 37, "quality": 0.9166666666666666, "length": 22}}, "n3337": {"so_33824954_33825360_0": {"section_id": 34, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_33824954_33825360_0": {"section_id": 37, "quality": 0.8333333333333334, "length": 20}}}, "33825193": {"ParentId": "33824954", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>The problem is surprisingly simple. This is what is happening in <em>your</em> case:</p>\n<p><code>18446744073709551615</code> when converted to a <code>double</code> is round <strong>up</strong> to the nearest number that the floating point can represent. (The closest representable number is larger).</p>\n<p>When that's converted back to an <code>unsigned long long</code>, it's larger than <code>max()</code>. Formally, the behaviour of converting this back to an <code>unsigned long long</code> is <em>undefined</em> but what appears to be happening in your case is a wrap around.</p>\n<p>The observed significantly smaller number is the result of this.</p>\n", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "LastEditDate": "2015-11-20T11:19:44.103", "Id": "33825193", "Score": "1", "CreationDate": "2015-11-20T11:09:01.207", "LastActivityDate": "2015-11-20T11:19:44.103"}});