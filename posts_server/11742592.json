post_cb({"11742675": {"ParentId": "11742592", "CommentCount": "0", "Body": "<p>Been a long time since I've done C++, but my guess would be because <code>std::map</code> is expecting a set of individual objects, each object containing a key and a value pair. </p>\n<p>Having a single list of individual items doesn't make sense, and it's also difficult to read (to make sure that you have a number of items that is exactly divisible by two).</p>\n", "OwnerUserId": "930393", "PostTypeId": "2", "Id": "11742675", "Score": "3", "CreationDate": "2012-07-31T14:41:52.973", "LastActivityDate": "2012-07-31T14:41:52.973"}, "11742888": {"ParentId": "11742592", "CommentCount": "4", "Body": "<p>The C++11 standard allows braces to be elided only when the target is an aggregate:</p>\n<blockquote>\n<p id=\"so_11742592_11742888_0\">8.5.1 Aggregates [dcl.init.aggr]</p>\n<p id=\"so_11742592_11742888_1\">An aggregate is an array or a class (Clause 9) with no user-provided\n  constructors (12.1), no brace-or-equal- initializers for non-static\n  data members (9.2), no private or protected non-static data members\n  (Clause 11), no base classes (Clause 10), and no virtual functions\n  (10.3).</p>\n<p id=\"so_11742592_11742888_2\">...</p>\n<p id=\"so_11742592_11742888_3\"><em>(Paragraph 11)</em></p>\n<p id=\"so_11742592_11742888_4\">In a declaration of the form</p>\n<pre><code>T x = { a };\n</code></pre>\n<p id=\"so_11742592_11742888_5\">braces can be elided in an initializer-list as follows. If the\n  initializer-list begins with a left brace, then the succeeding\n  comma-separated list of initializer-clauses initializes the members of\n  a subaggregate; it is erroneous for there to be more\n  initializer-clauses than members. If, however, the initializer-list\n  for a sub- aggregate does not begin with a left brace, then only\n  enough initializer-clauses from the list are taken to initialize the\n  members of the subaggregate; any remaining initializer-clauses are\n  left to initialize the next member of the aggregate of which the\n  current subaggregate is a member.</p>\n</blockquote>\n", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "11742888", "Score": "8", "CreationDate": "2012-07-31T14:52:42.593", "LastActivityDate": "2012-07-31T14:52:42.593"}, "11742592": {"CommentCount": "0", "ViewCount": "4332", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-07-31T14:36:53.653", "LastActivityDate": "2012-07-31T18:34:45.023", "Title": "Why can not omit braces when initializing map?", "AcceptedAnswerId": "11742665", "LastEditDate": "2017-05-23T12:08:06.410", "Id": "11742592", "Score": "10", "Body": "<p>Inspired by <a href=\"https://stackoverflow.com/a/11735045/476681\">this answer</a>, I tried next example :</p>\n<pre><code>#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n  const std::map&lt; int, std::string &gt; mapping = {\n      1, \"ONE\",\n      2, \"TWO\",\n    };\n\n  const auto it = mapping.find( 1 );\n  if ( mapping.end() != it )\n  {\n    std::cout &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n  }\n  else\n  {\n    std::cout &lt;&lt; \"not found!\" &lt;&lt; std::endl;\n  }\n}\n</code></pre>\n<p>and the compilation failed with next error message (g++ 4.6.1) :</p>\n<pre><code>gh.cpp:11:5: error: could not convert '{1, \"ONE\", 2, \"TWO\"}' from '&lt;brace-enclosed initializer list&gt;' to 'const std::map&lt;int, std::basic_string&lt;char&gt; &gt;'\n</code></pre>\n<p>I know how to fix it :</p>\n<pre><code>  const std::map&lt; int, std::string &gt; mapping = {\n      {1, \"ONE\"},\n      {2, \"TWO\"},\n    };\n</code></pre>\n<p>but why the compilation fails in the top example?</p>\n", "Tags": "<c++><c++11><initializer-list>", "OwnerUserId": "476681", "AnswerCount": "3"}, "11742665": {"ParentId": "11742592", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Because the map is a non-aggregate, and contains non-aggregate elements (<code>std::pair&lt;key_type, mapped_type&gt;</code>), so it requires an initializer-list full of initializer-lists, one for each pair.</p>\n<pre><code>std::pair&lt;int,int&gt; p0{ 1,2 }; // single pair\nstd::map&lt;int, int&gt; m { { 1,2 } }; // map with one element\nstd::map&lt;int, int&gt; m { { 1,2 }, { 3,4} }; // map with two elements\n</code></pre>\n<p>Bear in mind that the rules for brace elision apply to aggregates, so they do not apply here.</p>\n", "OwnerUserId": "661519", "LastEditorUserId": "661519", "LastEditDate": "2012-07-31T18:34:45.023", "Id": "11742665", "Score": "22", "CreationDate": "2012-07-31T14:41:23.203", "LastActivityDate": "2012-07-31T18:34:45.023"}, "bq_ids": {"n4140": {"so_11742592_11742888_5": {"section_id": 3308, "quality": 0.9387755102040817, "length": 46}, "so_11742592_11742888_1": {"section_id": 3298, "quality": 0.6666666666666666, "length": 16}}, "n3337": {"so_11742592_11742888_5": {"section_id": 3178, "quality": 0.9591836734693877, "length": 47}, "so_11742592_11742888_1": {"section_id": 3168, "quality": 0.7916666666666666, "length": 19}}, "n4659": {"so_11742592_11742888_5": {"section_id": 4074, "quality": 0.8367346938775511, "length": 41}}}});