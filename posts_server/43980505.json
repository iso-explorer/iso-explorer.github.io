post_cb({"43980505": {"ViewCount": "243", "Body": "<p>N3690, \u00a7 14.8.2 paragraph 3 has this pretty mind blowing example:</p>\n<pre><code>template &lt;class Z&gt; void h(Z, Z*);\n// #5: function type is h(int, const int*)\nh&lt;const int&gt;(1,0);\n</code></pre>\n<p><strong>Question:</strong> why is it not <code>h(const int, const int*)</code>? </p>\n<p>From what know, <code>Z = const int</code>, so every occurence of <code>Z</code> in the template declaration can be read as <code>const int</code>, or am I missing something? Why pointer is different? I remember that when parameter has <code>T&amp;</code> or <code>T*</code> it preserves cv-qualifiers of <code>T</code>, but I don't see any possibility to apply it here.</p>\n", "AcceptedAnswerId": "43980711", "Title": "Surprise in template parameter substitution?", "CreationDate": "2017-05-15T13:12:25.647", "Id": "43980505", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-05-15T17:04:26.950", "Score": "6", "OwnerUserId": "4593721", "Tags": "<c++><templates><c++14><language-lawyer>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_43980505_43980668_0": {"length": 90, "quality": 0.9090909090909091, "section_id": 3241}, "so_43980505_43980657_1": {"length": 96, "quality": 0.9230769230769231, "section_id": 3241}, "so_43980505_43980711_0": {"length": 96, "quality": 0.9230769230769231, "section_id": 3241}}, "n3337": {"so_43980505_43980668_0": {"length": 90, "quality": 0.9090909090909091, "section_id": 3114}, "so_43980505_43980657_1": {"length": 96, "quality": 0.9230769230769231, "section_id": 3114}, "so_43980505_43980711_0": {"length": 96, "quality": 0.9230769230769231, "section_id": 3114}}, "n4659": {"so_43980505_43980668_0": {"length": 90, "quality": 0.9090909090909091, "section_id": 3997}, "so_43980505_43980657_1": {"length": 90, "quality": 0.8653846153846154, "section_id": 3997}, "so_43980505_43980711_0": {"length": 90, "quality": 0.8653846153846154, "section_id": 3997}}}, "43980668": {"Id": "43980668", "PostTypeId": "2", "Body": "<p>The reason is another standard paragraph:</p>\n<p><a href=\"http://eel.is/c++draft/dcl.fct#5\" rel=\"nofollow noreferrer\">[dcl.fct/5]</a></p>\n<blockquote>\n<p id=\"so_43980505_43980668_0\">A single name can be used for several different functions in a single\n  scope; this is function overloading. All declarations for a function\n  shall agree exactly in both the return type and the\n  parameter-type-list. The type of a function is determined using the\n  following rules. The type of each parameter (including function\n  parameter packs) is determined from its own decl-specifier-seq and\n  declarator. After determining the type of each parameter, any\n  parameter of type \u201carray of T\u201d or of function type T is adjusted to be\n  \u201cpointer to T\u201d. After producing the list of parameter types, <strong>any\n  top-level cv-qualifiers modifying a parameter type are deleted when\n  forming the function type.</strong> The resulting list of transformed\n  parameter types and the presence or absence of the ellipsis or a\n  function parameter pack is the function's parameter-type-list. [\u2009Note:\n  This transformation does not affect the types of the parameters. For\n  example, int(<em>)(const int p, decltype(p)</em>) and int(<em>)(int, const int</em>)\n  are identical types. \u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>The rationalization for this is that to the caller it makes no difference if the parameter is cv-qualified; the steps to call the function as well as the conversion sequences for overload resolution are identical. So retaining const can in fact lead to ambiguity.</p>\n<p>The cv-qualifier is in fact an implementation detail of the function, and has meaning only at the site of the functions definition (you won't be able to modify the parameter inside the function body).</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-05-15T14:13:48.637", "Score": "10", "CreationDate": "2017-05-15T13:18:41.590", "ParentId": "43980505", "CommentCount": "0", "OwnerUserId": "817643", "LastEditDate": "2017-05-15T14:13:48.637"}, "43980657": {"Id": "43980657", "PostTypeId": "2", "Body": "<p>Because in general you need to <a href=\"https://stackoverflow.com/a/43798620/468725\">remove cv-qualifiers</a> from basic non-POD types.</p>\n<p>In <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">C++11</a> from <code>\u00a7 8.3.5 Functions</code> (p. 181):</p>\n<blockquote>\n<p id=\"so_43980505_43980657_0\">5</p>\n<p id=\"so_43980505_43980657_1\">A single name can be used for several different functions in a\n  single scope; this is function overloading (Clause 13). All\n  declarations for a function shall agree exactly in both the return\n  type and the parametertype-list. The type of a function is determined\n  using the following rules. The type of each parameter (including\n  function parameter packs) is determined from its own\n  decl-specifier-seq and declarator. After determining the type of each\n  parameter, any parameter of type \u201carray of T\u201d or \u201cfunction returning\n  T\u201d is adjusted to be \u201cpointer to T\u201d or \u201cpointer to function returning\n  T,\u201d respectively. After producing the list of parameter types, any\n  top-level cv-qualifiers modifying a parameter type are deleted when\n  forming the function type. The resulting list of transformed parameter\n  types and the presence or absence of the ellipsis or a function\n  parameter pack is the function\u2019s parameter-type-list. [ Note: This\n  transformation does not affect the types of the parameters. For\n  example, int(<em>)(const int p, decltype(p)</em>) and int(<em>)(int, const int</em>)\n  are identical types. \u2014end note ]</p>\n</blockquote>\n<p>There was a <a href=\"https://stackoverflow.com/questions/43798210/why-do-primitive-and-user-defined-types-act-differently-when-returned-as-const\">similar question for cv-qualifiers</a> with basic non-POD types.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-05-15T13:50:56.337", "Score": "2", "CreationDate": "2017-05-15T13:18:07.473", "ParentId": "43980505", "CommentCount": "0", "OwnerUserId": "468725", "LastEditDate": "2017-05-23T12:34:42.373"}, "43980711": {"Id": "43980711", "PostTypeId": "2", "Body": "<p>You need to see [dcl.fct]/5 for the reason why:</p>\n<blockquote>\n<p id=\"so_43980505_43980711_0\">A single name can be used for several different functions in a single scope; this is function overloading (Clause 13). All declarations for a function shall agree exactly in both the return type and the parameter-type-list. The type of a function is determined using the following rules. The type of each parameter (including function parameter packs) is determined from its own decl-specifier-seq and declarator. After determining the type of each parameter, any parameter of type \u201carray of T\u201d or \u201cfunction returning T\u201d is adjusted to be \u201cpointer to T\u201d or \u201cpointer to function returning T,\u201d respectively. <strong>After producing the list of parameter types, any top-level cv-qualifiers modifying a parameter type are deleted when forming the function type</strong>. The resulting list of transformed parameter types and the presence or absence of the ellipsis or a function parameter pack is the function\u2019s parameter-type-list. [ Note: This transformation does not affect the types of the parameters. For example, int(<em>)(const int p, decltype(p)</em>) and int(<em>)(int, const int</em>) are identical types. \u2014end note ]</p>\n</blockquote>\n<p>And in <code>const type*</code> <a href=\"https://stackoverflow.com/questions/7914444/what-are-top-level-const-qualifiers\">the const is not a top level const qualifier</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-05-15T16:09:07.657", "Score": "10", "CreationDate": "2017-05-15T13:20:55.843", "ParentId": "43980505", "CommentCount": "10", "OwnerUserId": "4342498", "LastEditDate": "2017-05-23T12:26:23.810"}});