post_cb({"bq_ids": {"n4140": {"so_48463767_48465475_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 2154}}, "n3337": {"so_48463767_48465475_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 2142}}, "n4659": {"so_48463767_48465475_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 2427}}}, "48465475": {"Id": "48465475", "PostTypeId": "2", "Body": "<p>The default constructor of <code>std::basic_streambuf</code> sets the six pointers that define the get and put areas to null pointer values, so it will not \"create its own get/put area\" by default.</p>\n<p>The functions <code>setg</code>, <code>setp</code>, <code>gbump</code>, and <code>pbump</code> are protected members and would not be called by public member functions by default, so you needn't worry about them. Of course, overriding them to throw exceptions is not bad.</p>\n<p>In addition, a custom stream buffer class without intermediate buffer shall also override the <a href=\"http://en.cppreference.com/w/cpp/io/basic_streambuf/uflow\" rel=\"nofollow noreferrer\"><code>uflow</code></a> function, which may be invoked by public member functions to handle overflow cases where the value of the get pointer is required to be advanced. By default, its default behavior is (quoted from <a href=\"http://www.eel.is/c++draft/streambuf.virt.get#16\" rel=\"nofollow noreferrer\">[streambuf.virt.get]/16</a>):</p>\n<blockquote>\n<p id=\"so_48463767_48465475_0\"><em>Default behavior:</em> Calls <code>underflow()</code>. If <code>underflow()</code> returns <code>traits\u200b::\u200beof()</code>, returns <code>traits\u200b::\u200beof()</code>. Otherwise, returns the value of <code>traits\u200b::\u200bto_\u00adint_\u00adtype(*gptr())</code> and increment the value of the next pointer for the input sequence.</p>\n</blockquote>\n<p>So if you do not override this function, it results in undefined behavior for indirection through a null pointer.</p>\n", "LastEditorUserId": "5376789", "LastActivityDate": "2018-01-27T14:38:21.800", "Score": "2", "CreationDate": "2018-01-26T16:27:30.753", "ParentId": "48463767", "CommentCount": "3", "OwnerUserId": "5376789", "LastEditDate": "2018-01-27T14:38:21.800"}, "48463767": {"ViewCount": "63", "Body": "<p>I've seen the instructions for creating custom streambufs many times:  All you need to do is implement <code>overflow</code>, <code>underflow</code>, and <code>pbackfail</code> properly in a descendant of <code>std::basic_streambuf</code> and you can create a stream that formats data using it. Those three routines define your custom stream's 'controlled sequence'. </p>\n<p>But there are other monsters lurking in the protected member list of <code>std::basic_streambuf</code>, namely <code>setg</code> and <code>setp</code>.  These set up buffer areas for input and output.  The public members that get and set data try to access these areas first before going after the controlled sequence. </p>\n<p>For a couple of different custom streambufs there might be trouble if the stream sets up its own get/put areas. So I would like such streambufs to avoid using  the get/put areas and <strong><em>always</em></strong> use <code>overflow</code>, <code>underflow</code>, and <code>pbackfail</code> without any intermediate buffering.  </p>\n<p>For a naive simplified example, if you're wrapping another streambuf the implementation of <code>underflow</code> might look like this:</p>\n<pre><code>template &lt;class C, class TR&gt;\ntypename TR::int_type wrapping_streambuf&lt;C, TR&gt;::underflow()\n{\n return m_wrapped_streambuf-&gt;sgetc();\n}\n</code></pre>\n<p>Let the wrapped streambuf handle all of the dirty work.\nHere's another naive example for counting lines:</p>\n<pre><code>template &lt;class C, class TR&gt;\ntypename TR::int_type tracking_streambuf&lt;C, TR&gt;::uflow()\n{\n  auto rv = m_wrapped_streambuf-&gt;sbumpc();\n  if (rv == (TR::int_type)'\\n') ++ m_input_line_count;\n  return rv;\n}\n</code></pre>\n<p>For such streams, there is no useful implementation of <code>setg</code> because you can't get at the wrapped buffer's internal get area.  For <code>tracked_streambuf</code>, the imposition of  get/put areas would make counting lines, in sync with the stream's logical sequence, impossible. </p>\n<p>I think the answer is to <em>never call</em> <code>setg</code> or <code>setp</code> in the descendant classes. In fact, they probably should override <code>setg</code>, <code>setp</code>, <code>gbump</code>, and <code>pbump</code> to throw exceptions. </p>\n<p>Looking at the <code>&lt;streambuf&gt;</code> header I see that a custom streambuf \n in my favorite library implementation might work the way I want (there are checks for null gptr/pptr) if I do this. But is it a guarantee? </p>\n", "AcceptedAnswerId": "48465475", "Title": "Does `basic_streambuf` create its own get/put areas if you don't do it in a derived class implementation?", "CreationDate": "2018-01-26T14:51:17.433", "LastActivityDate": "2018-01-27T14:42:06.997", "CommentCount": "0", "LastEditDate": "2018-01-27T14:42:06.997", "PostTypeId": "1", "LastEditorUserId": "2654470", "Id": "48463767", "Score": "3", "OwnerUserId": "2654470", "Tags": "<c++><streambuf>", "AnswerCount": "1"}});