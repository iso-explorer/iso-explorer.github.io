post_cb({"21879776": {"ParentId": "21879691", "CommentCount": "3", "Body": "<p>When you print <code>&amp;b</code> you print the address of where the variable <code>b</code> is stored. And yes, this location will be occupied, by that variable. Even if an object have zero size during compilation (remember that <code>sizeof</code> is a compile-time operator), a variable of that object must be addressable during run-time, and so take up space in memory.</p>\n", "OwnerUserId": "440558", "PostTypeId": "2", "Id": "21879776", "Score": "0", "CreationDate": "2014-02-19T11:56:35.233", "LastActivityDate": "2014-02-19T11:56:35.233"}, "21879691": {"CommentCount": "4", "ViewCount": "195", "PostTypeId": "1", "LastEditorUserId": "969305", "CreationDate": "2014-02-19T11:52:41.223", "LastActivityDate": "2014-02-19T13:00:05.587", "Title": "Objects of size 0", "AcceptedAnswerId": "21879799", "LastEditDate": "2014-02-19T13:00:05.587", "Id": "21879691", "Score": "5", "Body": "<p>I understand that empty classes in C++ have a size of 1 byte. However, I noticed that sizeof() returns 0 for objects of this class(in g++):</p>\n<pre><code>    class Boom{\n        int n[0];\n    }\n</code></pre>\n<p>I can print a valid memory location for a Boom object:</p>\n<pre><code>    Boom b;\n    cout&lt;&lt;&amp;b;\n</code></pre>\n<p>Is this particular memory location occupied?\nIf I allocate memory later in the program, is there a chance that this location will be used?</p>\n", "Tags": "<c++>", "OwnerUserId": "1699711", "AnswerCount": "5"}, "21879850": {"ParentId": "21879691", "CommentCount": "1", "Body": "<p>Arrays cannot have zero size. If your compiler allows you to declare one, then the language doesn't specify how it behaves.</p>\n<p>In this case, with this compiler, it does indeed appear that this allows two objects to occupy the same location:</p>\n<pre><code>Boom b[2];\nstd::cout &lt;&lt; &amp;b[0] &lt;&lt; ' ' &lt;&lt; &amp;b[1] &lt;&lt; std::endl;\n\n// Output: 0x7fffffb23fdc 0x7fffffb23fdc\n</code></pre>\n<p>But other compilers may behave differently, or simply reject the invalid declaration (as GCC does if you specify <code>-pedantic -Werror</code>).</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "21879850", "Score": "8", "CreationDate": "2014-02-19T12:00:27.823", "LastActivityDate": "2014-02-19T12:00:27.823"}, "21880018": {"ParentId": "21879691", "CommentCount": "1", "Body": "<p>This is a g++ extension; the C++ standard doesn't allow arrays\nof <code>0</code> elements.  I think that this extension was originally\ndesigned to do what using an incomplete array type as the final\nelement does in C99, but in C99, it's only legal if the <code>struct</code>\ncontains more than one member.  As for what happens if you\ndeclare an array of <code>Boom</code>, you'll have to ask g++.  (C99 avoids\nthis issue by requiring at least one other member.)</p>\n<p>The only real use for this feature is for variable length\ndynmamically allocated objects, e.g.: </p>\n<pre><code>struct Array\n{\n    size_t size;\n    int data[];\n};\n\n//  ...\nArray* p = (Array*)malloc(sizeof(Array) + n * sizeof(int));\np-&gt;size = n;\n</code></pre>\n<p>(This uses the C standard syntax.)</p>\n<p>In C++, we'd normally just use <code>std::vector</code> and be done with\nit.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "21880018", "Score": "2", "CreationDate": "2014-02-19T12:07:37.733", "LastActivityDate": "2014-02-19T12:07:37.733"}, "21879799": {"ParentId": "21879691", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2014-02-19T11:57:54.530", "Score": "4", "LastEditorUserId": "76722", "LastEditDate": "2014-02-19T12:26:08.373", "Id": "21879799", "OwnerUserId": "76722", "Body": "<h1>Code not valid.</h1>\n<p>A size of 0 is invalid, both for classes and arrays. The C++ standard says:</p>\n<blockquote>\n<h3>Sizeof [expr.sizeof]</h3>\n<p id=\"so_21879691_21879799_0\">[...] The size of a most derived class shall be greater than zero [...]</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<h3>Arrays <em>[dcl.array]</em></h3>\n<p id=\"so_21879691_21879799_1\">In a declaration T D where D has the form</p>\n<pre><code>    D1 [ constant-expressionopt] attribute-specifier-seqopt\n</code></pre>\n<p id=\"so_21879691_21879799_2\">[...] If the constant-expression (5.19) is present,\n  it shall be an integral constant expression and its value shall be greater than zero [...]</p>\n</blockquote>\n<hr>\n<h1>Why compiles? Compiler extension!</h1>\n<p>If you turn on <code>-pedantic</code> with g++, you will receive the following warning (or error with <code>pedantic-errors</code>):</p>\n<pre><code>ISO C++ forbids zero-size array \u2018n\u2019\n</code></pre>\n<p>so your program is basically not valid, but can be compiled by means of a <em>compiler extension</em> to the C++ standard (unless you turn this extension off).</p>\n<p>Note: Even though your compiler can report <code>0</code> for the <code>class</code>, it won't do so for any instance (a.k.a. object) of that <code>class</code>:</p>\n<pre><code>#include &lt;iostream&gt;\nclass Boom {\n    int n[0];\n};\nint main() {\n    std::cout &lt;&lt; sizeof(Boom) &lt;&lt; '\\n';   // prints 0\n    std::cout &lt;&lt; sizeof(Boom()) &lt;&lt; '\\n'; // prints 1\n}\n</code></pre>\n<p>Having objects of size-0 would go simply too far off the standard.</p>\n<p><a href=\"http://www.stroustrup.com/bs_faq2.html#sizeof-empty\" rel=\"nofollow\">Citation by Stroustroup</a>:</p>\n<blockquote>\n<h2>Why is the size of an empty class not zero?</h2>\n<p id=\"so_21879691_21879799_3\">To ensure that the addresses of two different objects will be different. For the same reason, \"new\" always returns pointers to distinct objects. Consider:</p>\n<pre><code>class Empty { };\n\n  void f()\n  {\n      Empty a, b;\n      if (&amp;a == &amp;b) cout &lt;&lt; \"impossible: report error to compiler supplier\";\n      Empty* p1 = new Empty;\n      Empty* p2 = new Empty;\n      if (p1 == p2) cout &lt;&lt; \"impossible: report error to compiler supplier\";\n  } \n</code></pre>\n<p id=\"so_21879691_21879799_4\">There is an interesting rule that says that an empty base class need not be represented by a separate byte:</p>\n<pre><code>   struct X : Empty {\n        int a;\n        // ...\n   };\n\n   void f(X* p)\n   {\n       void* p1 = p;\n       void* p2 = &amp;p-&gt;a;\n       if (p1 == p2) cout &lt;&lt; \"nice: good optimizer\";\n   }\n</code></pre>\n<p id=\"so_21879691_21879799_5\">This optimization is safe and can be most useful. It allows a programmer to use empty classes to represent very simple concepts without overhead. Some current compilers provide this \"empty base class optimization\". </p>\n</blockquote>\n</hr>", "LastActivityDate": "2014-02-19T12:26:08.373"}, "21879825": {"ParentId": "21879691", "CommentCount": "3", "Body": "<p>In this definition </p>\n<pre><code>class Boom{\n    int n[0];\n}\n</code></pre>\n<p>there are two errors.:) 1. You forgot to place a semicolon after the closing brace. 2. The size of an array may not be set to zero.</p>\n<p>And even empty classes have sizes that are not equal to zero. For example</p>\n<pre><code>struct A {};\n\nstd::cout &lt;&lt; sizeof( A ) &lt;&lt; std::endl;\n</code></pre>\n<p>will return a value that greater than 0.</p>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "21879825", "Score": "1", "CreationDate": "2014-02-19T11:59:12.253", "LastActivityDate": "2014-02-19T11:59:12.253"}, "bq_ids": {"n4140": {"so_21879691_21879799_0": {"section_id": 6077, "quality": 0.875, "length": 7}, "so_21879691_21879799_2": {"section_id": 3228, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_21879691_21879799_0": {"section_id": 5845, "quality": 0.875, "length": 7}, "so_21879691_21879799_2": {"section_id": 3101, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_21879691_21879799_2": {"section_id": 3985, "quality": 0.8181818181818182, "length": 9}, "so_21879691_21879799_0": {"section_id": 7573, "quality": 0.875, "length": 7}}}});