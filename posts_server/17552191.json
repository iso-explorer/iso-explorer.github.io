post_cb({"17552626": {"Id": "17552626", "PostTypeId": "2", "Body": "<p>I couldn't find anything concrete, but as far as the standard goes regarding types defined by the STL (e.g., pair):</p>\n<blockquote>\n<p id=\"so_17552191_17552626_0\">17.6.5.15: Unless otherwise specified, such moved-from objects\n             shall be placed in a valid but unspecified state.</p>\n</blockquote>\n<p>Without satisfying that \"otherwise specified\", which I haven't been able to find for a \"failed\" map::insert, this would mean that by the standard you could not use the pair. In reality, based on sensical implementations, I imagine that the pair would remain unchanged, but relying on this would fall into the realm of undefined compiler/stl-specific behavior.</p>\n", "LastActivityDate": "2013-07-09T15:47:47.230", "CommentCount": "0", "CreationDate": "2013-07-09T15:47:47.230", "ParentId": "17552191", "Score": "3", "OwnerUserId": "694509"}, "17553066": {"Id": "17553066", "PostTypeId": "2", "Body": "<p>From <em>Table 102</em> in section <em>23.2.4 Associative containers</em> of the c++11 standard (draft n3337) the following is stated (for expression <code>a_uniq.insert(t)</code> which applies in this case):</p>\n<blockquote>\n<p id=\"so_17552191_17553066_0\">Requires: If t is a non-const rvalue expression, value_type shall be MoveInsertable into X; otherwise, value_type shall be CopyInsertable into X.  Effects: Inserts t if and only if there is no element in the container with key equivalent to the key of t. The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of t.</p>\n</blockquote>\n<p>It makes no statement on any effect on <code>t</code> if an insertion does not occur (I am unsure whether this falls under <em>unspecified</em> or <em>implementation-defined</em> behaviour). I was unable to locate any other clause that provided further clarification so it appears the standard does not supply a definitive answer. It would be possible to rewrite the posted code to only call <code>insert()</code> if the pair is not present or just use the returned iterator.</p>\n", "LastActivityDate": "2013-07-09T16:08:26.427", "CommentCount": "0", "CreationDate": "2013-07-09T16:08:26.427", "ParentId": "17552191", "Score": "2", "OwnerUserId": "1033896"}, "bq_ids": {"n4140": {"so_17552191_17553165_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 744}, "so_17552191_17552626_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6365}, "so_17552191_17553165_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 1018}, "so_17552191_17553165_2": {"length": 11, "quality": 1.0, "section_id": 744}, "so_17552191_17553066_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 744}}, "n3337": {"so_17552191_17553165_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 733}, "so_17552191_17553066_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 733}, "so_17552191_17553165_2": {"length": 11, "quality": 1.0, "section_id": 733}, "so_17552191_17552626_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6122}}, "n4659": {"so_17552191_17553165_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 802}, "so_17552191_17553066_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 802}, "so_17552191_17553165_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 802}, "so_17552191_17553165_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 1075}, "so_17552191_17552626_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 7876}}}, "17552191": {"ViewCount": "325", "Body": "<p>If I move a pair into a map, but the insert failed because the key already exists, can I safely use the pair afterwards?</p>\n<pre><code>//objects available: map, pair\n\nauto insert_pair = map.insert(std::move(pair));\n\nif (!insert_pair.second)\n{\n  //can I safely access pair here?\n}\n</code></pre>\n<p>Has this been documented in the standard?</p>\n", "AcceptedAnswerId": "17553165", "Title": "Accessing a pair after moving it into a map", "CreationDate": "2013-07-09T15:27:52.553", "Id": "17552191", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-07-09T16:34:12.260", "Score": "11", "OwnerUserId": "2521520", "Tags": "<c++><c++11><map><move-semantics><std-pair>", "AnswerCount": "4"}, "17553165": {"Id": "17553165", "PostTypeId": "2", "Body": "<p>For how non-sense this may seem (read below), given the current state of the specification you cannot make any assumption on the state of the argument after the function call returns.</p>\n<p>To see why, let's first point out that the <code>insert()</code> member function is defined in terms of <code>emplace()</code> (see 23.4.4.4/1):</p>\n<blockquote>\n<p id=\"so_17552191_17553165_0\">The first form is equivalent to <code>return emplace(std::forward&lt;P&gt;(x))</code>. [...]</p>\n</blockquote>\n<p>The post-conditions of <code>emplace()</code> are in turn specified as (see \u00a7 23.2.4, Table 102):</p>\n<blockquote>\n<p id=\"so_17552191_17553165_1\"><strong>Inserts a <code>value_type</code>\n  object <code>t</code> constructed with\n  <code>std::forward&lt;Args&gt;(args)...</code></strong>\n  if and only if there is no\n  element in the container with\n  key equivalent to the key of <code>t</code>.\n  The <code>bool</code> component of the\n  returned pair is <code>true</code> if and\n  only if the insertion takes\n  place, and the iterator\n  component of the pair points\n  to the element with key\n  equivalent to the key of <code>t</code>.</p>\n</blockquote>\n<p>The sentence in bold from the above quote (emphasis is mine) says that the pair that will become an element of the map if the key is not already present will be move-constructed <em>directly</em> from the rvalue pair you supply.</p>\n<p>This would make it <em>very very reasonable</em> to deduce that implementations will first have to check if the key is present and, only if not, move-construct the new map's element from the your pair.</p>\n<p>However, \"very very reasonable\" is not a valid argument when dealing with the specification of a formal language. In this case, from the formal viewpoint there is nothing that prevents an implementation from doing the following:</p>\n<ol>\n<li>First move-construct a pair <code>tmp</code> from your argument (which would mean you can't make assumptions on the state of your argument after the function returns);</li>\n<li>Check if the key is already present in the map;</li>\n<li>If not, do the necessary housekeeping to insert <code>tmp</code> into the container.</li>\n</ol>\n<p>Or even:</p>\n<ol>\n<li>Check if the key is present in the map;</li>\n<li>If so, insert a new element move-constructed from your argument;</li>\n<li>If not, move-construct a new object from your argument and do nothing with it.</li>\n</ol>\n<p>Point 3 above is absolutely meaningless, but it is not formally forbidden. Mind the phrasing:</p>\n<blockquote>\n<p id=\"so_17552191_17553165_2\">Inserts a <code>value_type</code>\n  object <code>t</code> constructed with\n  <code>std::forward&lt;Args&gt;(args)...</code>\n  if and only if there is no\n  element in the container with\n  key equivalent to the key of <code>t</code>.</p>\n</blockquote>\n<p>This only says that if there is no element in the container with key equivalent to the key of <code>t</code>, no object move-constructed from <code>t</code> will be inserted into the map - but, for how stupid this may sound, it does not say that <em>no object at all</em> shall be move-constructed from <code>t</code>: as long as it does not get inserted into the map, this is allowed.</p>\n<p>This said, since the Standard does not explicitly constrain implementations in this respect, you cannot make assumptions on whether or not your argument was moved from. Consequently, you cannot make assumptions on the state your pair will be in when the function call returns (per paragraph 17.6.5.15).</p>\n<p>If I can let a personal opinion sneak in, though, I believe this is a defect.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-07-09T16:34:12.260", "Score": "7", "CreationDate": "2013-07-09T16:13:16.943", "ParentId": "17552191", "CommentCount": "5", "OwnerUserId": "1932150", "LastEditDate": "2013-07-09T16:34:12.260"}, "17552308": {"Id": "17552308", "PostTypeId": "2", "Body": "<p>Yes, you can use the pair.  Insert will return a reference to the pair that already exists in the map.</p>\n<p>Documentation is here:\n<a href=\"http://www.cplusplus.com/reference/map/map/insert/\" rel=\"nofollow\">http://www.cplusplus.com/reference/map/map/insert/</a></p>\n", "LastActivityDate": "2013-07-09T15:32:59.963", "CommentCount": "1", "CreationDate": "2013-07-09T15:32:59.963", "ParentId": "17552191", "Score": "-2", "OwnerUserId": "2395088"}});