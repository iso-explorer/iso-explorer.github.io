post_cb({"28995278": {"ParentId": "24278803", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_24278803_28995278_0\">I read this as saying that all allocators must be copy-constructible in such a way that the copies are interchangeable with the originals. Worse, the same true across type boundaries. This seems to be a pretty onerous requirement; as far as I can tell, it makes impossible a large number of types of allocators.</p>\n</blockquote>\n<p>It is trivial to meet the requirements if allocators are a lightweight handle onto some memory resource. Just don't try to embed  the resource inside individual allocator objects.</p>\n<blockquote>\n<p id=\"so_24278803_28995278_1\">For example, say I had a freelist class that I wanted to use in my allocator, in order to cache freed objects. Unless I'm missing something, I couldn't include an instance of that class in the allocator, because the sizes or alignments of T and U might differ and therefore the freelist entries are not compatible.</p>\n</blockquote>\n<p>[allocator.requirements] paragraph 9:</p>\n<blockquote>\n<p id=\"so_24278803_28995278_2\">An allocator may constrain the types on which it can be instantiated and the arguments for which its <code>construct</code> member may be called. If a type cannot be used with a particular allocator, the allocator class or the call to <code>construct</code> may fail to instantiate.</p>\n</blockquote>\n<p>It's OK for your allocator to refuse to allocate memory for anything except a <code>T</code>. That will prevent it being used in node-based containers such as <code>std::list</code> which need to allocate their own internal node types (not just the container's <code>value_type</code>) but it will work fine for <code>std::vector</code></p>\n<blockquote id=\"so_24278803_28995278_3\">\n<ol>\n<li>Are my interpretations above correct?</li>\n</ol>\n</blockquote>\n<p>Not entirely.</p>\n<blockquote id=\"so_24278803_28995278_4\">\n<ol start=\"2\">\n<li>I've read in a few places that C++11 improved support for \"stateful allocators\". How is that the case, given these restrictions?</li>\n</ol>\n</blockquote>\n<p>The restrictions before C++11 were even worse!</p>\n<p>It is now clearly specified how allocators propagate between containers when copied and moved, and how various container operations behave when their allocator instance is replaced by a different instance that might not compare equal to the original. Without those clarifications it was not clear what was supposed to happen if e.g. you swapped two containers with stateful allocators.</p>\n<blockquote id=\"so_24278803_28995278_5\">\n<ol start=\"3\">\n<li>Do you have any suggestions for how to do the sort of thing I'm trying to do? That is, how do I include allocated-type-specific state in my allocator?</li>\n</ol>\n</blockquote>\n<p>Don't embed it directly in the allocator, store it separately and have the allocator refer to it by a pointer (possibly smart pointer, depending on how you design the lifetime management of the resource).</p>\n<p>Don't try to support allocation for all types if you only need to support it for one.</p>\n<blockquote id=\"so_24278803_28995278_6\">\n<ol start=\"4\">\n<li>In general, the language around allocators seems sloppy. (For example, the prologue to Table 28 says to assume that a is of type X&amp;, but some of the expressions redefine a.)</li>\n</ol>\n</blockquote>\n<p>Yes, as you reported at <a href=\"https://github.com/cplusplus/draft/pull/334\" rel=\"nofollow\">https://github.com/cplusplus/draft/pull/334</a> (thanks).</p>\n<blockquote>\n<p id=\"so_24278803_28995278_7\">Also, at least GCC's support is non-conformant.</p>\n</blockquote>\n<p>It's not 100%, but will be in the next release.</p>\n<blockquote>\n<p id=\"so_24278803_28995278_8\">What accounts for this weirdness around allocators? Is it just an infrequently used feature?</p>\n</blockquote>\n<p>Yes. And there's a lot of historical baggage, and it's difficult to specify to be widely useful. My <a href=\"http://accu.org/content/conf2012/JonathanWakely-CXX11_allocators.pdf\" rel=\"nofollow\">ACCU 2012 presentation</a> has some details, I'll be very surprised if after reading that you think you can make it simpler ;-)</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2015-06-19T10:34:18.480", "Id": "28995278", "Score": "7", "CreationDate": "2015-03-11T19:08:07.760", "LastActivityDate": "2015-06-19T10:34:18.480"}, "24279177": {"ParentId": "24278803", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_24278803_24279177_0\">1) Are my interpretations above correct?</p>\n</blockquote>\n<p>You are right that your free-list might not be a good fit for allocators, it need be able to handle multiple sizes (and alignments) to fit. That's a problem for the free-list to solve.</p>\n<blockquote>\n<p id=\"so_24278803_24279177_1\">2) I've read in a few places that C++11 improved support for \"stateful allocators\". How is that the case, given these restrictions?</p>\n</blockquote>\n<p>It is not so much improved, than born. In C++03 any instance of an allocator was supposed to be equivalent to another instance of the same type, effectively making stateful allocators impossible.</p>\n<blockquote>\n<p id=\"so_24278803_24279177_2\">3) Do you have any suggestions for how to do the sort of thing I'm trying to do? That is, how do I include allocated-type-specific state in my allocator?</p>\n</blockquote>\n<p>Your allocator <em>has to be flexible</em>, because you are not supposed to know exactly what memory (and what types) it is supposed to allocate. This requirement is necessary to insulate you (the user) from the internals of the container that uses the allocator.</p>\n<p>Yes, it is a costly requirement.</p>\n<blockquote>\n<p id=\"so_24278803_24279177_3\">4) In general, the language around allocators seems sloppy. (For example, the prologue to Table 28 says to assume that a is of type X&amp;, but some of the expressions redefine a.) Also, at least GCC's support is non-conformant. What accounts for this weirdness around allocators? Is it just an infrequently used feature?</p>\n</blockquote>\n<p>The Standard in general is not exactly easy to read, not only allocators. You do have to be careful.</p>\n<p>To be pedant, gcc does not support allocators (it's a compiler). I surmise that you are speaking about libstdc++ (the Standard Library implementation shipped with gcc). libstdc++ is <em>old</em>, and thus it was tailored to C++03. It has been adapted toward C++11, but is not fully conformant yet (still uses Copy-On-Write for strings, for example). The reason is that libstdc++ has a huge focus on binary compatibility, and a number of changes required by C++11 would break this compatibility; they must therefore be introduced carefully.</p>\n", "OwnerUserId": "147192", "LastEditorUserId": "147192", "LastEditDate": "2016-01-25T10:56:41.577", "Id": "24279177", "Score": "13", "CreationDate": "2014-06-18T07:11:22.360", "LastActivityDate": "2016-01-25T10:56:41.577"}, "24289614": {"ParentId": "24278803", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Equality of allocators does not imply that they must have exactly the same internal state, only that they must both be able to deallocate memory that was allocated with either allocator. <em>Cross-type</em> equality of allocators <code>a == b</code> for an allocator <code>a</code> of type <code>X</code> and allocator <code>b</code> of type <code>Y</code> is defined in table 28 as \"same as <code>a == Y::template rebind&lt;T&gt;::other(b)</code>\". In other words, <code>a == b</code> if memory allocated by <code>a</code> can be deallocated by an allocator instantiated by rebinding <code>b</code> to <code>a</code>'s <code>value_type</code>.</p>\n<p>Your freelist allocators need not be able to deallocate nodes of arbitrary type, you only need to ensure that memory allocated by <code>FreelistAllocator&lt;T&gt;</code> can be deallocated by <code>FreelistAllocator&lt;U&gt;::template rebind&lt;T&gt;::other</code>. Given that <code>FreelistAllocator&lt;U&gt;::template rebind&lt;T&gt;::other</code> is the same type as <code>FreelistAllocator&lt;T&gt;</code> in most sane implementations, this is fairly easy to achieve.</p>\n<p>Simple example (<a href=\"http://coliru.stacked-crooked.com/a/cfd0c5c5021596ad\">Live demo at Coliru</a>):</p>\n<pre><code>template &lt;typename T&gt;\nclass FreelistAllocator {\n    union node {\n        node* next;\n        typename std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type storage;\n    };\n\n    node* list = nullptr;\n\n    void clear() noexcept {\n        auto p = list;\n        while (p) {\n            auto tmp = p;\n            p = p-&gt;next;\n            delete tmp;\n        }\n        list = nullptr;\n    }\n\npublic:\n    using value_type = T;\n    using size_type = std::size_t;\n    using propagate_on_container_move_assignment = std::true_type;\n\n    FreelistAllocator() noexcept = default;\n    FreelistAllocator(const FreelistAllocator&amp;) noexcept {}\n    template &lt;typename U&gt;\n    FreelistAllocator(const FreelistAllocator&lt;U&gt;&amp;) noexcept {}\n    FreelistAllocator(FreelistAllocator&amp;&amp; other) noexcept :  list(other.list) {\n        other.list = nullptr;\n    }\n\n    FreelistAllocator&amp; operator = (const FreelistAllocator&amp;) noexcept {\n        // noop\n        return *this;\n    }\n\n    FreelistAllocator&amp; operator = (FreelistAllocator&amp;&amp; other) noexcept {\n        clear();\n        list = other.list;\n        other.list = nullptr;\n        return *this;\n    }\n\n    ~FreelistAllocator() noexcept { clear(); }\n\n    T* allocate(size_type n) {\n        std::cout &lt;&lt; \"Allocate(\" &lt;&lt; n &lt;&lt; \") from \";\n        if (n == 1) {\n            auto ptr = list;\n            if (ptr) {\n                std::cout &lt;&lt; \"freelist\\n\";\n                list = list-&gt;next;\n            } else {\n                std::cout &lt;&lt; \"new node\\n\";\n                ptr = new node;\n            }\n            return reinterpret_cast&lt;T*&gt;(ptr);\n        }\n\n        std::cout &lt;&lt; \"::operator new\\n\";\n        return static_cast&lt;T*&gt;(::operator new(n * sizeof(T)));\n    }\n\n    void deallocate(T* ptr, size_type n) noexcept {\n        std::cout &lt;&lt; \"Deallocate(\" &lt;&lt; static_cast&lt;void*&gt;(ptr) &lt;&lt; \", \" &lt;&lt; n &lt;&lt; \") to \";\n        if (n == 1) {\n            std::cout &lt;&lt; \"freelist\\n\";\n            auto node_ptr = reinterpret_cast&lt;node*&gt;(ptr);\n            node_ptr-&gt;next = list;\n            list = node_ptr;\n        } else {\n            std::cout &lt;&lt; \"::operator delete\\n\";\n            ::operator delete(ptr);\n        }\n    }\n};\n\ntemplate &lt;typename T, typename U&gt;\ninline bool operator == (const FreelistAllocator&lt;T&gt;&amp;, const FreelistAllocator&lt;U&gt;&amp;) {\n    return true;\n}\n\ntemplate &lt;typename T, typename U&gt;\ninline bool operator != (const FreelistAllocator&lt;T&gt;&amp;, const FreelistAllocator&lt;U&gt;&amp;) {\n    return false;\n}\n</code></pre>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2015-03-11T21:50:12.910", "Id": "24289614", "Score": "18", "CreationDate": "2014-06-18T15:33:11.177", "LastActivityDate": "2015-03-11T21:50:12.910"}, "24278803": {"CommentCount": "5", "AcceptedAnswerId": "24279177", "CreationDate": "2014-06-18T06:50:16.940", "LastActivityDate": "2016-01-25T10:56:41.577", "PostTypeId": "1", "ViewCount": "5831", "FavoriteCount": "10", "Title": "How can I write a stateful allocator in C++11, given requirements on copy construction?", "Id": "24278803", "Score": "24", "Body": "<p>As far as I can tell, the requirements on an allocator to be used with STL\ncontainers are laid out in Table 28 of section 17.6.3.5 of the C++11 standard.</p>\n<p>I'm a bit confused about the interaction between some of these requirements.\nGiven a type <code>X</code> that is an allocator for type <code>T</code>, a type <code>Y</code> that is \"the\ncorresponding allocator class\" for type <code>U</code>, instances <code>a</code>, <code>a1</code>, and <code>a2</code> of\n<code>X</code>, and an instance <code>b</code> of <code>Y</code>, the table says:</p>\n<ol>\n<li><p>The expression <code>a1 == a2</code> evaluates to <code>true</code> only if storage allocated\nfrom <code>a1</code> can be deallocated by <code>a2</code>, and vice versa.</p></li>\n<li><p>The expression <code>X a1(a);</code> is well-formed, doesn't exit via an exception,\nand afterward <code>a1 == a</code> is true.</p></li>\n<li><p>The expression <code>X a(b)</code> is well-formed, doesn't exit via an exception, and\nafterward <code>a == b</code>.</p></li>\n</ol>\n<p>I read this as saying that all allocators must be copy-constructible in such a\nway that the copies are interchangeable with the originals. Worse, the same\ntrue across type boundaries. This seems to be a pretty onerous requirement; as\nfar as I can tell, it makes impossible a large number of types of allocators.</p>\n<p>For example, say I had a freelist class that I wanted to use in my allocator,\nin order to cache freed objects. Unless I'm missing something, I couldn't\ninclude an instance of that class in the allocator, because the sizes or\nalignments of <code>T</code> and <code>U</code> might differ and therefore the freelist entries are\nnot compatible.</p>\n<p>My questions:</p>\n<ol>\n<li><p>Are my interpretations above correct?</p></li>\n<li><p>I've read in a few places that C++11 improved support for \"stateful\nallocators\". How is that the case, given these restrictions?</p></li>\n<li><p>Do you have any suggestions for how to do the sort of thing I'm trying to\ndo? That is, how do I include allocated-type-specific state in my allocator?</p></li>\n<li><p>In general, the language around allocators seems sloppy. (For example, the\nprologue to Table 28 says to assume that <code>a</code> is of type <code>X&amp;</code>, but some of the\nexpressions redefine <code>a</code>.) Also, at least GCC's support is non-conformant.\nWhat accounts for this weirdness around allocators? Is it just an infrequently\nused feature?</p></li>\n</ol>\n", "Tags": "<c++><c++11><stl><allocator>", "OwnerUserId": "1505451", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_24278803_28995278_2": {"section_id": 6296, "quality": 1.0, "length": 23}}, "n3337": {"so_24278803_28995278_2": {"section_id": 6053, "quality": 1.0, "length": 23}}, "n4659": {"so_24278803_28995278_2": {"section_id": 7804, "quality": 0.9565217391304348, "length": 22}}}});