post_cb({"bq_ids": {"n4140": {"so_38652155_38652313_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 7217}}, "n3337": {"so_38652155_38652313_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 6961}}, "n4659": {"so_38652155_38652313_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 8726}}}, "38652313": {"Id": "38652313", "PostTypeId": "2", "Body": "<p>You are lucky. You should never assume that a result of a floating point operation is of a specific value. When you compare you can use &lt; and &gt;, but if you want to check for equality use a small epsilon.</p>\n<pre><code>if (abs(a - b) &lt; epsilon) cout &lt;&lt; \"a and b are equal\" &lt;&lt; endl;\n</code></pre>\n<p>And even if you compare, depending on the situation you also might want to use an epsilon.</p>\n<p>You can use <code>std::numeric_limits&lt;float&gt;::epsilon()</code> or define your own.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">N3337</a> 3.9.1.8:</p>\n<blockquote>\n<p id=\"so_38652155_38652313_0\">The value representation of\n  floating-point types is implementation-defined</p>\n</blockquote>\n", "LastEditorDisplayName": "user3235832", "LastActivityDate": "2016-07-29T09:13:33.780", "Score": "2", "CreationDate": "2016-07-29T06:53:44.513", "ParentId": "38652155", "CommentCount": "3", "OwnerUserId": "6078745", "LastEditDate": "2016-07-29T09:13:33.780"}, "38652155": {"ViewCount": "52", "Body": "<p>A <a href=\"http://coliru.stacked-crooked.com/a/36101691246e0a05\" rel=\"nofollow\">test</a> is easy:</p>\n<pre><code>float a= 1.0f;\nfloat b = 1.576f;\nfloat c = a/b;\n\ncout &lt;&lt; c &lt;&lt; endl;\ncout &lt;&lt; c * b &lt;&lt; endl;\n</code></pre>\n<p>Results:</p>\n<pre><code>0.634518\n1\n</code></pre>\n<p>But <code>1/1.1576</code> is somethings like <code>0,63451776649746192893401015228426</code> (and sure much more digits).</p>\n<p>Of course rounding happens at some time. But once the value is truncated and than multiply back, I can get the original value anyway.</p>\n<p>Am I \"lucky\" or this is guaranteed every time?</p>\n", "AcceptedAnswerId": "38652313", "Title": "How is it managed \"rounding\" since divide (and than multiple) returns the same amount without any loss after truncation due to rounding?", "CreationDate": "2016-07-29T06:44:39.290", "Id": "38652155", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-07-29T09:13:33.780", "Score": "0", "OwnerUserId": "365251", "Tags": "<c++><math><rounding>", "AnswerCount": "2"}, "38652622": {"Id": "38652622", "PostTypeId": "2", "Body": "<p>You are (un)lucky.  This is absolutely not guaranteed.  </p>\n<p>Consider a floating point representation which only has space for four binary digits in the mantissa, and which doesn't suppress the leading one (because that just makes the representation more complicated, without changing the argument).  </p>\n<p><code>1/10 = 0.000110011...b</code>  which will be <code>1.100B-4</code> in our representation.  Now multiply by ten (<code>1010b</code>), and you get <code>1111.B-4</code> in extended precision,.  If you normalize the exponent the final result is <code>1.111B-1</code> - which is <em>not</em> the same as <code>1.000B0</code>.</p>\n<p>Similar arguments apply with longer precisions.  If you are using a x86 platform, float has 23 bits of precision (with one of them hidden), <em>however</em> the internal floating point registers have 63 bits of precision - which means that intermediate values are held <em>much</em> more precisely.  This means you can often not notice problems like this.</p>\n", "LastEditorUserId": "771073", "LastActivityDate": "2016-07-29T07:16:54.520", "Score": "1", "CreationDate": "2016-07-29T07:12:09.620", "ParentId": "38652155", "CommentCount": "2", "OwnerUserId": "771073", "LastEditDate": "2016-07-29T07:16:54.520"}});