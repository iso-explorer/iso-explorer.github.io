post_cb({"bq_ids": {"n4140": {"so_16711244_16712003_3": {"length": 40, "quality": 0.975609756097561, "section_id": 87}, "so_16711244_16712003_6": {"length": 4, "quality": 0.8, "section_id": 87}, "so_16711244_16712003_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 87}, "so_16711244_16712003_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 87}, "so_16711244_16712003_7": {"length": 5, "quality": 1.0, "section_id": 87}, "so_16711244_16712003_5": {"length": 7, "quality": 0.875, "section_id": 87}, "so_16711244_16712003_0": {"length": 5, "quality": 1.0, "section_id": 87}}, "n3337": {"so_16711244_16712003_3": {"length": 40, "quality": 0.975609756097561, "section_id": 82}, "so_16711244_16712003_6": {"length": 4, "quality": 0.8, "section_id": 82}, "so_16711244_16712003_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 36}, "so_16711244_16712003_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 82}, "so_16711244_16712003_7": {"length": 5, "quality": 1.0, "section_id": 5947}, "so_16711244_16712003_5": {"length": 7, "quality": 0.875, "section_id": 82}, "so_16711244_16712003_0": {"length": 5, "quality": 1.0, "section_id": 82}}, "n4659": {"so_16711244_16712003_4": {"length": 5, "quality": 0.7142857142857143, "section_id": 7690}, "so_16711244_16712003_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 90}, "so_16711244_16712003_5": {"length": 5, "quality": 0.625, "section_id": 42}}}, "16711244": {"ViewCount": "1087", "Body": "<p>Why arguments which are passed as nontype arguments should be global and not local? Isn't both created and allocated memory during compile time only?</p>\n<p>In this case p is a const pointer, so it cannot point to any other variable then also its giving error.Why?</p>\n<pre><code>template&lt;int* ptr&gt;\nclass A{};\n\nint x;\nint *const p = &amp;x;\n\nint main() {\n    x = 9;\n    A&lt;&amp;x&gt; ob;\n    A&lt;p&gt; ob2;//giving error\n    cin.get();\n}\n</code></pre>\n<p>Also why only integral type is allowed as nontype parameters, not char or float?</p>\n", "AcceptedAnswerId": "16712003", "Title": "Why template nontype parameter pointer and reference arguments needs to be global", "CreationDate": "2013-05-23T10:14:46.310", "Id": "16711244", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2013-05-23T10:50:25.093", "Score": "1", "OwnerUserId": "2045438", "Tags": "<c++><templates><global><local><non-type>", "AnswerCount": "1"}, "16712003": {"Id": "16712003", "PostTypeId": "2", "Body": "<p>Concerning the first question, I am not a compiler expert, but I can guess it makes the compiler's life easier, and perhaps it is a limitation that comes from older versions of C++, where <code>constexpr</code> was not available. </p>\n<p>Nevertheless, paragraph 14.3.2/1 of the C++11 Standard is quite clear as to what is allowed and what is not:</p>\n<blockquote>\n<p id=\"so_16711244_16712003_0\">A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<p id=\"so_16711244_16712003_1\">\u2014 for a non-type template-parameter of integral or enumeration type, a converted constant expression\n  (5.19) of the type of the template-parameter; or</p>\n<p id=\"so_16711244_16712003_2\">\u2014 the name of a non-type template-parameter; or</p>\n<p id=\"so_16711244_16712003_3\">\u2014 <strong>a constant expression (5.19) that designates the address of an object with static storage duration and\n  external or internal linkage</strong> or a function with external or internal linkage, including function templates\n  and function template-ids but excluding non-static class members, <strong>expressed (ignoring parentheses) as\n  &amp; id-expression</strong>, except that the &amp; may be omitted if the name refers to a function or array and shall\n  be omitted if the corresponding template-parameter is a reference; or</p>\n<p id=\"so_16711244_16712003_4\">\u2014 a constant expression that evaluates to a null pointer value (4.10); or</p>\n<p id=\"so_16711244_16712003_5\">\u2014 a constant expression that evaluates to a null member pointer value (4.11); or</p>\n<p id=\"so_16711244_16712003_6\">\u2014 a pointer to member expressed as described in 5.3.1; or</p>\n<p id=\"so_16711244_16712003_7\">\u2014 an address constant expression of type std::nullptr_t.</p>\n</blockquote>\n<p>Concerning your second question, instead, a <code>char</code> <em>is</em> allowed. For instance, the following is a legal program:</p>\n<pre><code>template&lt;char c&gt;\nstruct X\n{\n    // ...\n};\n\nint main()\n{\n    X&lt;'c'&gt; x;\n}\n</code></pre>\n<p>Concerning the reasons why floating point types are not allowed, you can find some information in <a href=\"https://stackoverflow.com/questions/16693994/understanding-of-non-type-template-parameters/16694256#16694256\">this Q&amp;A on StackOverflow</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-05-23T10:50:25.093", "Score": "1", "CreationDate": "2013-05-23T10:50:25.093", "ParentId": "16711244", "CommentCount": "12", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T11:43:15.267"}});