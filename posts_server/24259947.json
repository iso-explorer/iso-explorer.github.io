post_cb({"24263194": {"ParentId": "24259947", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><code>auto</code> is required when introducing a <em>trailing-return-type</em>.</p>\n<p>\u00a78.3.5 [dcl.fct] /2</p>\n<blockquote>\n<p id=\"so_24259947_24263194_0\">In a declaration <code>T D</code> where <code>D</code> has the form</p>\n<blockquote>\n<p id=\"so_24259947_24263194_4\"><code>D1 (</code> <em><code>parameter-declaration-clause</code></em> ) <em><code>cv-qualifier-seq</code><sub>opt</sub>\n<code>ref-qualifier</code><sub>opt</sub> <code>exception-specification</code><sub>opt</sub> <code>attribute-specifier-seq</code><sub>opt</sub> <code>trailing-return-type</code></em></p>\n<p id=\"so_24259947_24263194_5\">and the type of the contained <em>declarator-id</em> in the declaration <code>T D1</code> is \u201cderived-<em>declarator-type-list</em> <code>T</code>\u201d,</p>\n</blockquote>\n<p id=\"so_24259947_24263194_3\"><strong><code>T</code> shall be the single <em>type-specifier</em> auto.</strong> [...]</p>\n</blockquote>\n<p>See also <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_toc.html#1852\" rel=\"nofollow\">Core Issue 1852</a> for the apparent contradiction with [dcl.spec.auto]/1.</p>\n", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2015-05-28T14:55:37.567", "Id": "24263194", "Score": "14", "CreationDate": "2014-06-17T11:58:08.273", "LastActivityDate": "2015-05-28T14:55:37.567"}, "24259947": {"CommentCount": "0", "AcceptedAnswerId": "24263194", "PostTypeId": "1", "LastEditorUserId": "567292", "CreationDate": "2014-06-17T09:17:03.473", "LastActivityDate": "2015-05-28T14:55:37.567", "LastEditDate": "2014-08-20T13:37:20.027", "ViewCount": "285", "FavoriteCount": "1", "Title": "Does a placeholder in a trailing-return-type override an initial placeholder?", "Id": "24259947", "Score": "6", "Body": "<p>g++ appears to accept any combination of <code>auto</code> and <code>decltype(auto)</code> as initial and trailing return types:</p>\n<pre><code>int a;\nauto f() { return (a); }                             // int\nauto g() -&gt; auto { return (a); }                     // int\nauto h() -&gt; decltype(auto) { return (a); }           // int&amp;\ndecltype(auto) i() { return (a); }                   // int&amp;\ndecltype(auto) j() -&gt; auto { return (a); }           // int\ndecltype(auto) k() -&gt; decltype(auto) { return (a); } // int&amp;\n</code></pre>\n<p>However, clang rejects <code>j</code> and <code>k</code>, saying: <em>error: function with trailing return type must specify return type 'auto', not 'decltype(auto)'</em> (<a href=\"http://goo.gl/uw5h0b\" rel=\"nofollow\">demonstration</a>).</p>\n<p>Which compiler is correct? Which rule (<code>auto</code> or <code>decltype(auto)</code>) should be used in each case? And does it make any sense to use a placeholder type in a <em>trailing-return-type</em>?</p>\n", "Tags": "<c++><decltype><c++14><trailing-return-type><return-type-deduction>", "OwnerUserId": "567292", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24259947_24260964_1": {"section_id": 5446, "quality": 0.9512195121951219, "length": 39}, "so_24259947_24263194_5": {"section_id": 3237, "quality": 1.0, "length": 5}, "so_24259947_24260964_0": {"section_id": 5445, "quality": 0.9166666666666666, "length": 22}, "so_24259947_24263194_2": {"section_id": 3237, "quality": 1.0, "length": 5}}, "n3337": {"so_24259947_24263194_5": {"section_id": 3110, "quality": 1.0, "length": 5}, "so_24259947_24263194_2": {"section_id": 3110, "quality": 1.0, "length": 5}}, "n4659": {"so_24259947_24260964_1": {"section_id": 6873, "quality": 0.9512195121951219, "length": 39}, "so_24259947_24263194_5": {"section_id": 3967, "quality": 0.8, "length": 4}, "so_24259947_24263194_2": {"section_id": 3967, "quality": 0.8, "length": 4}, "so_24259947_24260964_0": {"section_id": 6872, "quality": 0.75, "length": 18}}}, "24260964": {"ParentId": "24259947", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Edit after <a href=\"https://stackoverflow.com/users/500104/xeo\">@Xeo</a> constructive comments:</p>\n<p>It seems that this issue is due a contradiction between two places of the draft standard. </p>\n<p>According to the draft standard <em>\u00a7 7.1.6.4 auto specifier [dcl.spec.auto]:</em></p>\n<blockquote>\n<p id=\"so_24259947_24260964_0\"><code>1</code> The <code>auto</code> and <code>decltype(auto)</code> <strong>type-specifiers designate a placeholder type</strong> that will be replaced later, either by deduction from an initializer or by explicit specification with a trailing-return-type. The auto type-specifier\n  is also used to signify that a lambda is a generic lambda.</p>\n<p id=\"so_24259947_24260964_1\"><code>2</code> The placeholder type can appear with a function declarator in the decl-specifier-seq, type-specifier-seq,\n  conversion-function-id, or <strong>trailing-return-type</strong>, in any context where such a declarator is valid. If the function\n  declarator includes a trailing-return-type (8.3.5), that specifies the declared return type of the function.\n  <strong>If the declared return type of the function contains a placeholder type, the return type of the function is\n  deduced from return statements in the body of the function, if any.</strong></p>\n</blockquote>\n<p>The sole interpretation of the above would suggest that Clang has a bug.</p>\n<p>However, as <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1852\" rel=\"nofollow noreferrer\">core issue 1852</a> specifies the above contradict with <em>\u00a7 8.3.5/2 Functions [dcl.fct]</em> and should be altered. The status of the issue is ready which suggests that the the changes have been accepted.</p>\n<p>As such, the GCC has a bug that should be reported.</p>\n", "OwnerUserId": "2352671", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:52:47.237", "Id": "24260964", "Score": "2", "CreationDate": "2014-06-17T10:03:00.903", "LastActivityDate": "2014-06-17T12:32:55.843"}});