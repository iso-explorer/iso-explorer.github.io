post_cb({"23341289": {"Id": "23341289", "PostTypeId": "2", "Body": "<p>Yes, this is allowed we can see this by going to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"noreferrer\">draft C++ standard</a> section <code>3.3.10</code> <em>Name hiding</em> paragraph <em>2</em> and it says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_23329382_23341289_0\">A class name (9.1) or enumeration name (7.2) can be hidden by the name of a variable, data member, function, or enumerator declared in the same scope. <strong>If a class or enumeration name and a variable, data member, function, or enumerator are declared in the same scope (in any order) with the same name, the class or enumeration name is hidden wherever the variable, data member, function, or enumerator name is visible</strong>.</p>\n</blockquote>\n<p>In this case using <code>struct</code> in the declaration would fix your issue:</p>\n<pre><code>struct foo a;\n</code></pre>\n", "LastActivityDate": "2014-04-28T12:33:39.437", "CommentCount": "0", "CreationDate": "2014-04-28T12:33:39.437", "ParentId": "23329382", "Score": "5", "OwnerUserId": "1708801"}, "23329382": {"ViewCount": "1900", "Body": "<p>The following code <a href=\"http://ideone.com/y6AxmM\" rel=\"noreferrer\">compiles</a> in C++</p>\n<pre><code>struct foo\n{\n    int a, b;\n};\n\nstruct foo foo()\n{\n    struct foo a;\n    return a;\n}\n\nint main(void) {\n    foo();\n    return 0;\n}\n</code></pre>\n<ol>\n<li>Is it supposed to be allowed to have a struct and a function with the same name ?</li>\n<li><p>Since it compiles I then go on and try to declare an object of type <code>foo</code>. Is there a way? It seems impossible to do :</p>\n<pre><code>foo a;   // error: expected \u2018;\u2019 before \u2018a\u2019\nfoo a{}; // error: expected \u2018;\u2019 before \u2018a\u2019\nfoo a(); // most vexing parse would kick in any way\n</code></pre></li>\n</ol>\n", "AcceptedAnswerId": "23341289", "Title": "Function and struct having the same name in c++", "CreationDate": "2014-04-27T21:42:07.407", "Id": "23329382", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-04-28T12:44:22.533", "Score": "7", "OwnerUserId": "2567683", "Tags": "<c++>", "AnswerCount": "5"}, "23329400": {"Id": "23329400", "PostTypeId": "2", "Body": "<p>Usually a bad habbit to do something like that. I would name it foo_s or whatever to distinguish it from the function. Other than that, there isn't really a way of doing it.</p>\n<p>In C this is possible, since it requires</p>\n<pre><code>struct foo\n</code></pre>\n<p>instead of just</p>\n<p>foo</p>\n<p>as the type name (unless it is typedef'd)</p>\n", "LastActivityDate": "2014-04-27T21:43:16.677", "CommentCount": "0", "CreationDate": "2014-04-27T21:43:16.677", "ParentId": "23329382", "Score": "1", "OwnerUserId": "2603057"}, "23329469": {"Id": "23329469", "PostTypeId": "2", "Body": "<p>Just do it like you would in C, using:</p>\n<pre><code>struct foo a;\n</code></pre>\n<p>You might even initialise it like this:</p>\n<pre><code>struct foo a{};\nstruct foo a = {0};\n</code></pre>\n<p>A workaround would be using a typedef, thus avoiding any ambiguity and other difficulties:</p>\n<pre><code>typedef struct foo s_foo;\n</code></pre>\n", "LastEditorUserId": "3204551", "LastActivityDate": "2014-04-28T12:26:42.237", "Score": "1", "CreationDate": "2014-04-27T21:49:27.740", "ParentId": "23329382", "CommentCount": "3", "OwnerUserId": "3204551", "LastEditDate": "2014-04-28T12:26:42.237"}, "23341502": {"Id": "23341502", "PostTypeId": "2", "Body": "<p>From The.C++.Programming.Language.Special.Edition $A.8:</p>\n<blockquote>\n<p id=\"so_23329382_23341502_0\">To preserve C compatibility, a class and a non-class of the same name can be declared in the same\n  scope ($5.7). For example:</p>\n</blockquote>\n<pre><code>struct stat { /* ... */ };\nint stat(char * name, struct stat * buf);\n</code></pre>\n<blockquote>\n<p id=\"so_23329382_23341502_1\">In this case, the plain name (stat) is the name of the non-class. The class must be referred to using\n  a class-key prefix .</p>\n</blockquote>\n", "LastActivityDate": "2014-04-28T12:44:22.533", "CommentCount": "0", "CreationDate": "2014-04-28T12:44:22.533", "ParentId": "23329382", "Score": "0", "OwnerUserId": "3309790"}, "23329484": {"Id": "23329484", "PostTypeId": "2", "Body": "<p>Yes, you can, but it's a really bad pattern to get into.</p>\n<pre><code>struct foo\n{\n};\n\nfoo foo(foo&amp; f)\n{\n    return f;\n}\n\nint main()\n{\n    struct foo f;\n    foo(f);\n    return 0;\n}\n</code></pre>\n<p>See livedemo: <a href=\"http://ideone.com/kRK19f\" rel=\"nofollow\">http://ideone.com/kRK19f</a></p>\n<p>The trick was to specify <code>struct foo</code> when we wanted to get at the type. Note that, until you create this ambiguity, it's actually not necessary to keep saying <code>struct</code>, this isn't C (as in the line <code>foo foo(foo&amp; f)</code>).</p>\n<p>Most developers choose a camel casing pattern, e.g they use an upper case letter to distinguish type names and a lowercase letter for a function name:</p>\n<pre><code>struct Foo\n{\n};\n\nFoo foo(); // no ambiguity.\n</code></pre>\n<p>Back in Microsoft's prime, many Windows developers acquired the habit of prefixing struct/class definitions, the definition of a class of thing if you will, with a capital C</p>\n<pre><code>struct CFoo\n{\n};\n</code></pre>\n<p>Now, even if you want to use upper-case first letters for your function names, there is no ambiguity.</p>\n", "LastActivityDate": "2014-04-27T21:50:32.877", "CommentCount": "0", "CreationDate": "2014-04-27T21:50:32.877", "ParentId": "23329382", "Score": "1", "OwnerUserId": "257645"}, "bq_ids": {"n4140": {"so_23329382_23341289_0": {"length": 41, "quality": 1.0, "section_id": 7079}}, "n3337": {"so_23329382_23341289_0": {"length": 41, "quality": 1.0, "section_id": 6823}}, "n4659": {"so_23329382_23341289_0": {"length": 41, "quality": 1.0, "section_id": 8580}}}});