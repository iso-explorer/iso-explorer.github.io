post_cb({"bq_ids": {"n4140": {"so_21443023_21443273_1": {"length": 11, "quality": 1.0, "section_id": 5971}, "so_21443023_21443273_2": {"length": 19, "quality": 0.8636363636363636, "section_id": 5982}, "so_21443023_21443273_3": {"length": 13, "quality": 1.0, "section_id": 5975}, "so_21443023_21443273_0": {"length": 29, "quality": 0.8787878787878788, "section_id": 5968}}, "n3337": {"so_21443023_21443273_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 5739}, "so_21443023_21443273_2": {"length": 19, "quality": 0.8636363636363636, "section_id": 5750}, "so_21443023_21443273_3": {"length": 13, "quality": 1.0, "section_id": 5743}, "so_21443023_21443273_0": {"length": 27, "quality": 0.8181818181818182, "section_id": 5737}}, "n4659": {"so_21443023_21443273_1": {"length": 11, "quality": 1.0, "section_id": 7470}, "so_21443023_21443273_2": {"length": 19, "quality": 0.8636363636363636, "section_id": 7479}, "so_21443023_21443273_3": {"length": 13, "quality": 1.0, "section_id": 7475}, "so_21443023_21443273_0": {"length": 29, "quality": 0.8787878787878788, "section_id": 7466}}}, "39215382": {"Id": "39215382", "PostTypeId": "2", "Body": "<p><strong>The code is guaranteed to work.</strong></p>\n<p>Before we delve into the standards wording: it's the C++ committee's intent that this code works. However, the wording as it stands was believed to be insufficiently clear on this (and indeed, bugfixes made to the standard post-C++14 broke the delicate arrangement that made it work), so <a href=\"http://wg21.link/cwg2011\" rel=\"noreferrer\">CWG issue 2011</a> was raised to clarify matters, and is making its way through the committee now. As far as I know, no implementation gets this wrong.</p>\n<hr>\n<p>I'd like to clarify a couple of things, because Ben Voigt's answer contains some factual errors that are creating some confusion:</p>\n<ol>\n<li>\"Scope\" is a static, lexical notion in C++, that describes a region of the program source code in which unqualified name lookup associates a particular name with a declaration. It has nothing to do with lifetime. See <a href=\"http://eel.is/c++draft/basic.scope.declarative#1\" rel=\"noreferrer\">[basic.scope.declarative]/1</a>.</li>\n<li><p>The \"reaching scope\" rules for lambdas are, likewise, a syntactic property that determine when capture is permitted. For example:</p>\n<pre><code>void f(int n) {\n  struct A {\n    void g() { // reaching scope of lambda starts here\n      [&amp;] { int k = n; };\n      // ...\n</code></pre>\n<p><code>n</code> is in scope here, but the reaching scope of the lambda does not include it, so it cannot be captured. Put another way, the reaching scope of the lambda is how far \"up\" it can reach and capture variables -- it can reach up to the enclosing (non-lambda) function and its parameters, but it can't reach outside that and capture declarations that appear outside.</p></li>\n</ol>\n<p>So the notion of \"reaching scope\" is irrelevant to this question. The entity being captured is <code>make_function</code>'s parameter <code>x</code>, which is within the reaching scope of the lambda.</p>\n<hr>\n<p>OK, so let's look at the standard's wording on this issue. Per [expr.prim.lambda]/17, only <em>id-expression</em>s referring to entities captured by copy are transformed into a member access on the lambda closure type; <em>id-expression</em>s referring to entities captured by reference are left alone, and still denote the same entity they would have denoted in the enclosing scope.</p>\n<p>This immediately seems bad: the reference <code>x</code>'s lifetime has ended, so how can we refer to it? Well, it turns out that there is almost (see below) no way to refer to a reference outside its lifetime (you can either see a declaration of it, in which case it's in scope and thus presumably OK to use, or it's a class member, in which case the class itself must be within its lifetime for the member access expression to be valid). As a result, the standard did not have any prohibitions on using a reference outside its lifetime until very recently.</p>\n<p>The lambda wording took advantage of the fact that there is no penalty for using a reference outside its lifetime, and so didn't need to give any explicit rules for what access to an entity captured by reference means -- it just means you use that entity; if it's a reference, the name denotes its initializer. And that's how this was guaranteed to work up until very recently (including in C++11 and C++14).</p>\n<p>However, it's not <em>quite</em> true that you can't mention a reference outside its lifetime; in particular, you can reference it from within its own initializer, from the initializer of a class member earlier than the reference, or if it is a namespace-scope variable and you access it from another global that is initialized before it is. <a href=\"http://wg21.link/cwg2012\" rel=\"noreferrer\">CWG issue 2012</a> was introduced to fix that oversight, but it inadvertantly broke the specification for lambda capture by reference of references. We should get this regression fixed before C++17 ships; I've filed a National Body comment to make sure it's suitably prioritized.</p>\n</hr></hr>", "LastEditorUserId": "1041090", "LastActivityDate": "2016-08-29T23:31:48.873", "Score": "16", "CreationDate": "2016-08-29T21:18:47.677", "ParentId": "21443023", "CommentCount": "1", "OwnerUserId": "1041090", "LastEditDate": "2016-08-29T23:31:48.873"}, "21443273": {"Id": "21443273", "PostTypeId": "2", "Body": "<p>TL;DR: The code in the question is not guaranteed by the Standard, and there are reasonable implementations of lambdas which cause it to break. Assume it is non-portable and instead use</p>\n<pre><code>std::function&lt;void()&gt; make_function(int&amp; x)\n{\n    const auto px = &amp;x;\n    return [/* = */ px]{ std::cout &lt;&lt; *px &lt;&lt; std::endl; };\n}\n</code></pre>\n<p>Beginning in C++14, you can do away with explicit use of a pointer using an initialized capture, which forces a new reference variable to be created for the lambda, instead of reusing the one in the enclosing scope:</p>\n<pre><code>std::function&lt;void()&gt; make_function(int&amp; x)\n{\n    return [&amp;x = x]{ std::cout &lt;&lt; x &lt;&lt; std::endl; };\n}\n</code></pre>\n<hr>\n<p>On first glance, it seems that <em>should</em> be safe, but the wording of the Standard causes a bit of a problem:</p>\n<blockquote>\n<p id=\"so_21443023_21443273_0\">A lambda-expression  whose smallest enclosing scope is a block scope (3.3.3) is a local  lambda  expression; any  other  lambda-expression  shall  not  have  a  capture-default  or  simple-capture  in  its  lambda-introducer. <strong>The  <em>reaching  scope</em>  of  a  local  lambda  expression  is  the  set  of  enclosing  scopes  up  to  and  including  the\n  innermost  enclosing  function  and  its  parameters.</strong></p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_21443023_21443273_1\"><strong>All  such  implicitly  captured  entities  shall  be  declared  within  the  reaching  scope  of  the lambda expression.</strong></p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_21443023_21443273_2\"><strong>[ Note:  If an entity is implicitly or explicitly captured by reference, invoking the function call operator of the corresponding lambda-expression after the lifetime of the entity has ended is likely to result in undefined behavior.  \u2014 end note ]</strong></p>\n</blockquote>\n<p>What we expect to happen is that <code>x</code>, as used inside <code>make_function</code>, refers to <code>i</code> in <code>main()</code> (since that is what references do), and the entity <code>i</code> is captured by reference.  Since that entity still lives at the time of the lambda call, everything is good.</p>\n<p>But!  \"implicitly captured entities\" must be \"within the reaching scope of the lambda expression\", and <code>i</code> in <code>main()</code> is not in the reaching scope.  :(  Unless the parameter <code>x</code> counts as \"declared within the reaching scope\" even though the entity <code>i</code> itself is outside the reaching scope.</p>\n<p>What this sounds like is that, <strong>unlike any other place in C++, a reference-to-reference is created</strong>, and the lifetime of a reference has meaning.</p>\n<p>Definitely something I would like to see the Standard clarify.</p>\n<p>In the meantime, the variant shown in the TL;DR section is definitely safe because the pointer is captured by value (stored inside the lambda object itself), and it is a valid pointer to an object which lasts through the call of the lambda.  I would also expect that capturing by reference actually ends up storing a pointer anyway, so there should be no runtime penalty for doing this.</p>\n<hr>\n<p>On closer inspection, we also imagine that it could break.  Remember that on x86, in the final machine code, both local variables and function parameters are accessed using EBP-relative addressing.  Parameters have a positive offset, while locals are negative.  (Other architectures have different register names but many work in the same way.)  Anyway, this means that capture-by-reference can be implemented by capturing only the value of EBP.  Then locals and parameters alike can again be found via relative addressing.  And in fact I believe I've heard of lambda implementations (in languages which had lambdas long before C++) doing exactly this: capturing the \"stack frame\" where the lambda was defined.</p>\n<p>What this implies is that when <code>make_function</code> returns and its stack frame goes away, so does all ability to access locals AND parameters, even those which are references.</p>\n<p>And the Standard contains the following rule, likely specifically to enable this approach:</p>\n<blockquote>\n<p id=\"so_21443023_21443273_3\">It is unspecified whether additional unnamed non-static data members are declared in the closure type for entities captured by reference.</p>\n</blockquote>\n<p>Conclusion: The code in the question is not guaranteed by the Standard, and there are reasonable implementations of lambdas which cause it to break.  Assume it is non-portable.</p>\n</hr></hr>", "LastEditorUserId": "103167", "LastActivityDate": "2014-09-03T22:39:17.433", "Score": "24", "CreationDate": "2014-01-29T21:43:10.517", "ParentId": "21443023", "CommentCount": "36", "OwnerUserId": "103167", "LastEditDate": "2014-09-03T22:39:17.433"}, "21443023": {"ViewCount": "9146", "Body": "<p>Consider this:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nstd::function&lt;void()&gt; make_function(int&amp; x) {\n    return [&amp;]{ std::cout &lt;&lt; x &lt;&lt; std::endl; };\n}\n\nint main() {\n    int i = 3;\n    auto f = make_function(i);\n    i = 5;\n    f();\n}\n</code></pre>\n<p>Is this program guaranteed to output <code>5</code> without invoking undefined behavior?</p>\n<p>I understand how it works if I capture <code>x</code> by value (<code>[=]</code>), but I am not sure if I am invoking undefined behavior by capturing it by reference. Could it be that I will end up with a dangling reference after <code>make_function</code> returns, or is the captured reference guaranteed to work as long as the originally referenced object is still there?</p>\n<p>Looking for definitive standards-based answers here :) It works well enough in practice <em>so far</em> ;)</p>\n", "AcceptedAnswerId": "39215382", "Title": "Capturing a reference by reference in a C++11 lambda", "CreationDate": "2014-01-29T21:28:05.880", "Id": "21443023", "CommentCount": "3", "FavoriteCount": "17", "PostTypeId": "1", "LastEditDate": "2017-12-01T12:05:17.383", "LastEditorUserId": "7703564", "LastActivityDate": "2017-12-01T12:05:17.383", "Score": "43", "OwnerUserId": "2971", "Tags": "<c++><c++11><lambda><language-lawyer>", "AnswerCount": "2"}});