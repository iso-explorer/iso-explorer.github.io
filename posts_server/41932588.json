post_cb({"41932667": {"ParentId": "41932588", "CommentCount": "0", "Body": "<p>The program is well-formed.</p>\n<p>You are allowed to set a pointer one past the end of an array or even just beyond the of the address of a scalar, as if it were a single element array.</p>\n<p>That second part is important here. So long as you don't actually <em>dereference</em> <code>last_thing</code>, which <code>std::copy</code> will not, your code will run perfectly.</p>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "41932667", "Score": "2", "CreationDate": "2017-01-30T09:37:45.367", "LastActivityDate": "2017-01-30T09:37:45.367"}, "41932676": {"ParentId": "41932588", "CommentCount": "0", "Body": "<p>According to 5.7 [expr.add] paragraph 4 a pointer to an object behaves like a pointer the first object of a one element array:</p>\n<blockquote>\n<p id=\"so_41932588_41932676_0\">For the purposes of these operators, a pointer to a nonarray object behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type.</p>\n</blockquote>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "41932676", "Score": "4", "CreationDate": "2017-01-30T09:38:09.907", "LastActivityDate": "2017-01-30T09:38:09.907"}, "41932588": {"CommentCount": "1", "ViewCount": "71", "PostTypeId": "1", "LastEditorUserId": "2015579", "CreationDate": "2017-01-30T09:33:04.380", "LastActivityDate": "2017-01-30T10:06:31.007", "Title": "c++ iterate one item - UB or defined behaviour?", "FavoriteCount": "0", "LastEditDate": "2017-01-30T10:06:31.007", "Id": "41932588", "Score": "2", "Body": "<p>I've been thinking about the rules for pointer arithmetic in c++ recently, having learned that pointer arithmetic is only defined for pointers that point at objects that exist in an array.</p>\n<p>This led me to wonder whether the following code's behaviour is strictly undefined according to the standard.</p>\n<p>Can anyone shed any light?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n#include &lt;utility&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nstruct Thing {\n    std::string val;\n};\n\nint main() {\n\n    Thing a_thing;\n\n    std::vector&lt;Thing&gt; things;\n\n    // take address\n    auto first_thing = std::addressof(a_thing);  \n\n    // take address of \"one past the end\" - UB?\n    auto last_thing = std::next(first_thing);    \n\n    // copying exactly one item, but is it UB?\n    std::copy(first_thing, last_thing, std::back_inserter(things));  \n}\n</code></pre>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "2015579", "AnswerCount": "4"}, "41932765": {"ParentId": "41932588", "CommentCount": "0", "Body": "<p>As the other answers mentioned, your program is well-formed. Here's the relevant standardese from the latest working paper:</p>\n<blockquote>\n<p id=\"so_41932588_41932765_0\"><a href=\"https://timsong-cpp.github.io/cppwp/expr.add#footnote-86\" rel=\"nofollow noreferrer\"><strong>\u00a75.7 (footnote 86) [expr.add]</strong></a></p>\n<blockquote>\n<p id=\"so_41932588_41932765_2\">An object that is not an array element is considered to belong to a single-element array for this purpose; see <a href=\"https://timsong-cpp.github.io/cppwp/expr.unary.op\" rel=\"nofollow noreferrer\">[expr.unary.op]</a>. A pointer past the last element of an array <code>x</code> of <code>n</code> elements is considered to be equivalent to a pointer to a hypothetical element <code>x[n]</code> for this purpose; see <a href=\"https://timsong-cpp.github.io/cppwp/basic.compound\" rel=\"nofollow noreferrer\">[basic.compound]</a>.</p>\n</blockquote>\n</blockquote>\n<p>In short, a non-array object behaves like a single-element array in the context of pointer arithmetic. Taking one-past-the-end address is therefore legal.</p>\n", "OwnerUserId": "598696", "PostTypeId": "2", "Id": "41932765", "Score": "3", "CreationDate": "2017-01-30T09:42:56.507", "LastActivityDate": "2017-01-30T09:42:56.507"}, "41932707": {"ParentId": "41932588", "CommentCount": "0", "Body": "<p>This is well-formed. </p>\n<p>[expr.add]/4 states:</p>\n<blockquote>\n<p id=\"so_41932588_41932707_0\">For the purposes of these operators, <strong>a pointer to a nonarray object behaves the same as a pointer to the first element of an array of length one</strong> with the type of the object as its element type.</p>\n</blockquote>\n<p>After which it is stated ([expr.add]/5):</p>\n<blockquote>\n<p id=\"so_41932588_41932707_1\"><strong>If both the pointer operand and the result point to</strong> elements of the same array object, or <strong>one past\n  the last element of the array object, the evaluation shall not produce an overflow</strong>; otherwise, the behavior is\n  undefined.</p>\n</blockquote>\n<p>Emphasis mine.</p>\n", "OwnerUserId": "1490355", "PostTypeId": "2", "Id": "41932707", "Score": "3", "CreationDate": "2017-01-30T09:39:57.093", "LastActivityDate": "2017-01-30T09:39:57.093"}, "bq_ids": {"n4140": {"so_41932588_41932707_0": {"section_id": 6141, "quality": 0.9473684210526315, "length": 18}, "so_41932588_41932707_1": {"section_id": 6142, "quality": 1.0, "length": 21}, "so_41932588_41932676_0": {"section_id": 6141, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_41932588_41932707_0": {"section_id": 5905, "quality": 0.9473684210526315, "length": 18}, "so_41932588_41932707_1": {"section_id": 5906, "quality": 1.0, "length": 21}, "so_41932588_41932676_0": {"section_id": 5905, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_41932588_41932765_1": {"section_id": 7638, "quality": 0.9090909090909091, "length": 20}, "so_41932588_41932707_0": {"section_id": 7603, "quality": 0.5789473684210527, "length": 11}, "so_41932588_41932707_1": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}, "so_41932588_41932676_0": {"section_id": 7603, "quality": 0.5789473684210527, "length": 11}, "so_41932588_41932765_2": {"section_id": 7638, "quality": 0.9090909090909091, "length": 20}}}});