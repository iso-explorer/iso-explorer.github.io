post_cb({"29412584": {"Id": "29412584", "PostTypeId": "2", "Body": "<p>Neither in C++ nor in C functions may have return type of an array. Arrays do not have a copy constructor or the copy assignment operator.</p>\n<p>Nevertheless in C++ you may return a reference to an array. </p>\n<p>Consider the following example</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n\nconst size_t N = 10;\n\nint ( &amp; init( int ( &amp;a )[N], int initial ) )[N]\n{\n    std::iota( a, a + N, initial );\n\n    return a;\n}\n\nstd::ostream &amp; print( const int ( &amp;a )[N], std::ostream &amp;os = std::cout )\n{\n    for ( int x : a ) os &lt;&lt; x &lt;&lt; ' ';\n\n    return os;\n}\n\nint main() \n{\n    int a[N];\n\n    print( init( a, 0 ) ) &lt;&lt; std::endl;\n    print( init( a, 10 ) ) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>The output is</p>\n<pre><code>0 1 2 3 4 5 6 7 8 9 \n10 11 12 13 14 15 16 17 18 19 \n</code></pre>\n<p>However you may not return reference to or pointer (to the first element) to a local array of a function. In this case the program will have undefined behaviour.</p>\n<p>But you can use standard wrapper for arrays <code>std::array</code> and return it from functions.</p>\n<p>Here is an example</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;array&gt;\n\nconst size_t N = 10;\n\nstd::array&lt;int, N&gt; init(int initial = 0 )\n{\n    std::array&lt;int, N&gt; a;\n    std::iota( a.begin(), a.end(), initial );\n\n    return a;\n}\n\nstd::ostream &amp; print( const std::array&lt;int, N&gt; &amp;a, std::ostream &amp;os = std::cout )\n{\n    for ( int x : a ) os &lt;&lt; x &lt;&lt; ' ';\n\n    return os;\n}\n\nint main() \n{\n    std::array&lt;int, N&gt; a;\n\n    a = init();\n    print( a ) &lt;&lt; std::endl;\n\n    a = init( 10 );\n    print( a ) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>The program output is the same as above</p>\n<pre><code>0 1 2 3 4 5 6 7 8 9 \n10 11 12 13 14 15 16 17 18 19 \n</code></pre>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2015-04-02T12:18:13.243", "Score": "1", "CreationDate": "2015-04-02T12:06:52.587", "ParentId": "29412146", "CommentCount": "0", "OwnerUserId": "2877241", "LastEditDate": "2015-04-02T12:18:13.243"}, "29412631": {"Id": "29412631", "PostTypeId": "2", "Body": "<p>As already said by Mike Seymour, a function cannot return an array but just a pointer to its first element.</p>\n<p>It is perfectly correct per se, but can lead to errors if misused. Some problems that could arise :</p>\n<ul>\n<li><p>return a pointer to an automatic array : if will be destroyed as soon as the function returns =&gt; UB when you try to access to it </p>\n<pre><code>int * arr() {\n    int arr[10]; // automatic array\n    ...\n    return arr;  // WRONG ! UB when accessed from caller ...\n}\n</code></pre></li>\n<li><p>return a pointer to a dynamically allocated array : fine but caller must free it when it is no longer used or you will have a memory leak</p>\n<pre><code>int * arr() {\n    int *arr = new int[10]; // automatic array\n    ...\n    return arr;  MUST be freed by caller ...\n}\nfor (int i=0; i&lt;5, i++) {\n    int *a = arr();\n    ... // use a\n}   // no delete[] a in loop =&gt; memory leak !\n</code></pre></li>\n<li><p>return a pointer to a static array : fine but it should not be used in a multi threaded context</p>\n<pre><code>int * arr() {\n    static int arr[10]; // automatic array\n    ...\n    return arr;  // as arr is static it will persist after function returns\n}\n</code></pre>\n<p>Thread a :</p>\n<pre><code>int *a = arr();\n</code></pre>\n<p>Thread b :</p>\n<pre><code>int *a = arr();\n</code></pre>\n<p>Both thread are now sharing the same array through their <code>a</code> pointer, what is generally <strong>not expected</strong> if array is not read only.</p></li>\n</ul>\n<p>As I said, it can be fine to return a pointer to a not automatic array. It must simply be used with caution because is often leads to problems.</p>\n", "LastActivityDate": "2015-04-02T12:09:39.703", "CommentCount": "2", "CreationDate": "2015-04-02T12:09:39.703", "ParentId": "29412146", "Score": "0", "OwnerUserId": "3545273"}, "29412592": {"Id": "29412592", "PostTypeId": "2", "Body": "<p>stop using this old things. start working with <b>STL</b>. you can always pass <code>vector or string</code> into the <code>function parameters</code> and always get that both as <code>return</code> value from function.</p>\n", "LastActivityDate": "2015-04-02T12:07:28.527", "CommentCount": "0", "CreationDate": "2015-04-02T12:07:28.527", "ParentId": "29412146", "Score": "0", "OwnerUserId": "3702021"}, "bq_ids": {"n4140": {"so_29412146_29412417_0": {"length": 18, "quality": 1.0, "section_id": 3244}}, "n3337": {"so_29412146_29412417_0": {"length": 18, "quality": 1.0, "section_id": 3117}}, "n4659": {"so_29412146_29412417_0": {"length": 18, "quality": 1.0, "section_id": 4002}}}, "29412146": {"ViewCount": "121", "Body": "<p>My question is what may go wrong if a function returns an array? Can we use such function?</p>\n", "AcceptedAnswerId": "29412631", "Title": "Why should not we use a function that returns an array or pointer in a class", "CreationDate": "2015-04-02T11:44:18.597", "Id": "29412146", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2015-04-02T12:19:27.620", "Score": "-1", "OwnerUserId": "4742305", "Tags": "<c++><class><pointers>", "AnswerCount": "5"}, "29412417": {"Id": "29412417", "PostTypeId": "2", "Body": "<p>C++ does not allow a function to return an array type as a prvalue; xvalues and lvalues are fine, though:</p>\n<pre><code>using T = int[10];\n\nT  &amp; foo();    // OK, returns lvalue\nT &amp;&amp; foo();    // OK, returns xvalue\nT    foo();    // Error, not allowed\n</code></pre>\n<p>The same is function types (although in that case the result of the function call expression is always an lvalue). See [dcl.fct]/10:</p>\n<blockquote>\n<p id=\"so_29412146_29412417_0\">Functions shall not have a return type of type array or function, although they may have a return type of type pointer or reference to such things.</p>\n</blockquote>\n<p>Similarly, array and function types cannot be function parameter types (but references to them can), but the meaning of declaration of a function parameter with such type is adjusted to \"pointer to {array element type, function type}\".</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2015-04-02T12:06:15.577", "Score": "1", "CreationDate": "2015-04-02T11:59:07.040", "ParentId": "29412146", "CommentCount": "0", "OwnerUserId": "596781", "LastEditDate": "2015-04-02T12:06:15.577"}, "29412240": {"Id": "29412240", "PostTypeId": "2", "Body": "<p>A function can't directly return an array, since arrays can't be simply copied or moved.</p>\n<p>It could return a pointer to the start of an array. This is fine if the array continues to exist once the function has returned. But it will go horribly wrong if the array is a local automatic variable, since it will be destroyed when the function returns, leaving the pointer dangling. Trying to access the remnants of the array will give undefined behaviour.</p>\n<p>Since you asked for an example:</p>\n<pre><code>int * bogus() {\n    int array[] = {1,2,3,4,5};\n    return array;  // Whoops! array is destroyed here\n}\n\nint * p = bogus();\nassert(p[2] == 3); // BOOM! undefined behaviour\n</code></pre>\n<p>If the array has a small, fixed size, you could wrap it in a class to return a copy of it; the standard library provides <code>std::array</code> for this.</p>\n<p>If you need the array to be dynamically allocated (because it's large, or the size is only known at runtime), then <code>std::vector</code> is your friend.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2015-04-02T12:19:27.620", "Score": "0", "CreationDate": "2015-04-02T11:49:39.750", "ParentId": "29412146", "CommentCount": "2", "OwnerUserId": "204847", "LastEditDate": "2015-04-02T12:19:27.620"}});