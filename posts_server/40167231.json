post_cb({"40168133": {"ParentId": "40167231", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In short: yes, it can be safe. But you need to know what to expect.</p>\n<p>Lvalue const references and rvalue references can be used to prolong the lifetime of temporary variables (minus exceptions referenced below).</p>\n<p>By the way, we have already learned from your <a href=\"https://stackoverflow.com/questions/40160904/difference-on-address-of-const-reference-to-ternary-operator-between-clang-and-g\">previous question</a> that gcc 4.9 series is not the best reference for this kind of test. Bonus example 1 compiled with gcc 6.1 or 5.3 gives exactly the same result as compiled with clang. As it's supposed to.</p>\n<p>Quotes from N4140 (selected fragments):</p>\n<blockquote>\n<p id=\"so_40167231_40168133_0\">[class.temporary]</p>\n<p id=\"so_40167231_40168133_1\">There are two contexts in which temporaries are destroyed at a\n  different point than the end of the full-expression. [...]</p>\n<p id=\"so_40167231_40168133_2\">The second context is when a reference is bound to a temporary. The\n  temporary to which the reference is bound or the temporary that is the\n  complete object of a subobject to which the reference is bound\n  persists for the lifetime of the reference except: [no relevant\n  clauses to this question]</p>\n</blockquote>\n<p>\u200b</p>\n<blockquote>\n<p id=\"so_40167231_40168133_3\">[expr.cond] </p>\n<p id=\"so_40167231_40168133_4\">3) Otherwise, if the second and third operand have different types and\n  either has (possibly cv-qualified) class type, or if both are glvalues\n  of the same value category and the same type except for\n  cv-qualification, an attempt is made to convert each of those operands\n  to the type of the other.</p>\n<ul>\n<li><p id=\"so_40167231_40168133_5\">If <code>E2</code> is an lvalue: <code>E1</code> can be converted to match <code>E2</code> if <code>E1</code> can be implicitly converted (Clause 4) to the type \u201clvalue reference\n  to <code>T2</code>\u201d, subject to the constraint that in the conversion the\n  reference must bind directly to an lvalue</p></li>\n<li><p id=\"so_40167231_40168133_6\">[...]</p></li>\n<li><p id=\"so_40167231_40168133_7\">If <code>E2</code> is a prvalue or if neither of the conversions above can be done and at least one of the operands has (possibly cv-qualified)\n  class type:</p></li>\n<li><ul>\n<li>Otherwise (i.e., if <code>E1</code> or <code>E2</code> has a nonclass type, or if they both have class types but the underlying classes are not either the\n  same or one a base class of the other): <code>E1</code> can be converted to match\n  <code>E2</code> if <code>E1</code> can be implicitly converted to the type that expression\n  <code>E2</code> would have if <code>E2</code> were converted to a prvalue (or the type it\n  has, if <code>E2</code> is a prvalue)</li>\n</ul></li>\n</ul>\n<p id=\"so_40167231_40168133_8\">[...] If neither can be converted, the operands are left unchanged and\n  further checking is performed as described below. If exactly one\n  conversion is possible, that conversion is applied to the chosen\n  operand and the converted operand is used in place of the original\n  operand for the remainder of this section.</p>\n<p id=\"so_40167231_40168133_9\">4) If the second and third operands are glvalues of the same value\n  category and have the same type, the result is of that type and value\n  category [...]</p>\n<p id=\"so_40167231_40168133_10\">5) Otherwise, the result is a prvalue. If the second and third\n  operands do not have the same type, and either has (possibly\n  cv-qualified) class type [...]. Otherwise, the conversions thus\n  determined are applied, and the converted operands are used in place\n  of the original operands for the remainder of this section.</p>\n<p id=\"so_40167231_40168133_11\">6) Lvalue-to-rvalue, array-to-pointer, and function-to-pointer\n  standard conversions are performed on the second and third operands.\n  After those conversions, one of the following shall hold:</p>\n<ul>\n<li>The second and third operands have arithmetic or enumeration type; the usual arithmetic conversions are performed to bring them to a\n  common type, and the result is of that type.</li>\n</ul>\n</blockquote>\n<hr>\n<p>So the first example is well defined to do exactly what you experienced:</p>\n<pre><code>float a = 1.;\nconst float &amp; x = true ? a : 2.; // Note: `2.` is a double\na = 4.;\nstd::cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; x;\n</code></pre>\n<p><code>x</code> is a reference bound to a temporary object of type <code>float</code>. It does not refer to <code>a</code>, because the expression <code>true ? float : double</code> is defined to yield a <code>double</code> - and only then you're converting that <code>double</code> back to a new and different <code>float</code> when assigning it to <code>x</code>.</p>\n<hr>\n<p>In your second example (bonus 1):</p>\n<pre><code>float a = 0;\nconst float b = 0;\nconst float &amp; x = true ? a : b;\n\na = 4;\ncout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; x;\n</code></pre>\n<p>the ternary operator doesn't have to do any conversions between <code>a</code> and <code>b</code> (except for matching cv-qualifiers) and it yields an lvalue referring to a const float. <code>x</code> aliases <code>a</code> and must reflect the changes made to <code>a</code>.</p>\n<hr>\n<p>In the third example (bonus 2):</p>\n<pre><code>double a = 3;\nconst double &amp; a_ref = a;\nconst double &amp; x = true ? a_ref : 2.;\n\na = 4.;\nstd::cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; x;\n</code></pre>\n<p>In this case <em><code>E1</code> can be converted to match <code>E2</code> if <code>E1</code> can be implicitly converted to the type that [...] [<code>E2</code>] has, if <code>E2</code> is a prvalue</em>. Now, that prvalue has the same value as <code>a</code>, but is a different object. <code>x</code> does not alias <code>a</code>.</p>\n</hr></hr></hr>", "OwnerUserId": "2456565", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:30:34.407", "Id": "40168133", "Score": "2", "CreationDate": "2016-10-21T03:56:30.840", "LastActivityDate": "2016-10-21T03:56:30.840"}, "40527027": {"ParentId": "40167231", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_40167231_40527027_0\">Is it safe to create a const reference to result of ternary operator in C++?</p>\n</blockquote>\n<p>As the Asker, I would summarize the discussion to; It's ok for non-templated code, on quite modern compilers, with Warnings on. For templated code, as a code reviewer, I would, in general discourage it.</p>\n", "OwnerUserId": "832887", "PostTypeId": "2", "Id": "40527027", "Score": "0", "CreationDate": "2016-11-10T11:56:02.627", "LastActivityDate": "2016-11-10T11:56:02.627"}, "40167573": {"ParentId": "40167231", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>First of all, the result of the conditional operator is either a glvalue designating the selected operand, or a prvalue whose value comes from the selected operand.  </p>\n<p><sup>Exception as noted by T.C.: if at least one operand is of class type and has a conversion-to-reference operator, the result may be an lvalue designating the object designated by the return value of that operator; and if the designated object is actually a temporary, a dangling reference may result. This is a problem with such operators that offer implicit conversion of prvalues to lvalues, not a problem introduced by the conditional operator per se.</sup></p>\n<p>In both cases it is safe to bind a reference to the result,  the usual rules for binding a reference to an lvalue or a prvalue apply. If the reference binds to a prvalue (either the prvalue result of the conditional, or a prvalue initialized from the lvalue result of the conditional), the lifetime of the prvalue is extended to match the lifetime of the reference.</p>\n<hr>\n<p>In your original case, the conditional is:</p>\n<pre><code>true ? a : 2.\n</code></pre>\n<p>The second and third operand are: \"lvalue of type <code>float</code>\" and \"prvalue of type <code>double</code>\". This is case 5 in the <a href=\"http://en.cppreference.com/w/cpp/language/operator_other\" rel=\"nofollow\">cppreference summary</a>, with the result being \"prvalue of type <code>double</code>\".</p>\n<p>Then, your code initializes a const reference with a prvalue of a different (non-reference-related) type. The behaviour of this is to copy-initialize a temporary of the same type as the reference. </p>\n<p>In summary, after <code>const float &amp; x = true ? a : 2.;</code>, <code>x</code> is an lvalue denoting a <code>float</code> whose value is the result of converting <code>a</code> to <code>double</code> and back. (Not sure off the top of my head whether that is guaranteed to compare equal to <code>a</code>).  <code>x</code> is not bound to <code>a</code>.</p>\n<hr>\n<p>In bonus case 1, the second and third operand of the conditional operator are \"lvalue of type <code>float</code>\" and \"lvalue of type <code>const float</code>\".  This is case 3 of the same cppreference link,</p>\n<blockquote>\n<p id=\"so_40167231_40167573_0\">both are glvalues of the same value category and have the same type except for cv-qualification</p>\n</blockquote>\n<p>The behavour is that the second operand is converted to \"lvalue of type <code>const float</code>\" (denoting the same object), and the result of the conditional is \"lvalue of type <code>const float</code>\" denoting the selected object.</p>\n<p>Then you bind <code>const float &amp;</code> to \"lvalue of type <code>const float</code>\", which binds directly. </p>\n<p>So after <code>const float &amp; x = true ? a : b;</code>,  <code>x</code> is directly bound to either <code>a</code> or <code>b</code>.</p>\n<hr>\n<p>In bonus case 2, <code>true ? a_ref : 2.</code>  . The second and third operands are \"lvalue of type <code>const double</code>\" and \"prvalue of type <code>double</code>\", so the result is \"prvalue of type <code>double</code>\". </p>\n<p>Then you bind this to <code>const double &amp; x</code>, which is a direct binding since <code>const double</code> is reference-related to <code>double</code>. </p>\n<p>So after <code>const double &amp; x = true ? a_ref : 2.;</code>   , then <code>x</code> is an lvalue denoting a double with the same value as <code>a_ref</code>  (but <code>x</code> is not bound to <code>a</code>).</p>\n</hr></hr></hr>", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2016-10-21T03:20:56.137", "Id": "40167573", "Score": "5", "CreationDate": "2016-10-21T02:48:11.387", "LastActivityDate": "2016-10-21T03:20:56.137"}, "40167231": {"CommentCount": "14", "CreationDate": "2016-10-21T02:02:44.337", "PostTypeId": "1", "AcceptedAnswerId": "40167573", "LastEditorUserId": "-1", "LastActivityDate": "2016-11-10T11:56:02.627", "LastEditDate": "2017-05-23T12:13:40.587", "ViewCount": "510", "FavoriteCount": "5", "Title": "Is it safe to create a const reference to result of ternary operator in C++?", "Id": "40167231", "Score": "19", "Body": "<p>There's something quite non-obvious going on in this code:</p>\n<pre><code>float a = 1.;\n\nconst float &amp; x = true ? a : 2.; // Note: `2.` is a double\n\na = 4.;\n\nstd::cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; x;\n</code></pre>\n<p>both clang and gcc output:</p>\n<pre><code>4, 1\n</code></pre>\n<p>One would naively expect the same value printed twice but this isn't the case. The issue here has nothing to do with the reference. There are some interesting rules dictating the type of <code>? :</code>. If the two arguments are of different type and can be casted, they will by using a temporary. The reference will point to the temporary of <code>? :</code>.</p>\n<p>The example above compiles fine and it might or might not issue a warning while  compiling with <code>-Wall</code> depending on the version of your compiler.</p>\n<p>Here's an example on how easy it's to get this wrong in legitimate-looking code:</p>\n<pre><code>template&lt;class Iterator, class T&gt;\nconst T &amp; min(const Iterator &amp; iter, const T &amp; b)\n{\n    return *iter &lt; b ? *iter : b;\n}\n\nint main()\n{\n    // Try to remove the const or convert to vector of floats\n    const std::vector&lt;double&gt; a(1, 3.0);\n\n    const double &amp; result = min(a.begin(), 4.);\n\n    cout &lt;&lt; &amp;a[0] &lt;&lt; \", \" &lt;&lt; &amp;result;\n}\n</code></pre>\n<p>If your logic after this code assumes that any changes on <code>a[0]</code> will be reflected to <code>result</code>, it will be wrong in cases where <code>?:</code> creates a temporary. Also, if at some point you make a pointer to <code>result</code> and you use it after <code>result</code> goes out of scope, there will be a segmentation fault despite the fact that your original <code>a</code> hasn't gone out of scope.</p>\n<p>I feel there're serious reasons NOT to use this form beyond \"maintainability and reading issues\" mentioned <a href=\"https://stackoverflow.com/questions/11494988/using-ternary-operator-to-initialize-a-reference-variable/40161097\">here</a> especially while writing templated code where some of your types and their const'ness might be out of your control.</p>\n<p>So my question is, is it safe to use <code>const &amp;</code>s on ternary operators?</p>\n<p>P.S. Bonus example 1, extra complications (see also <a href=\"https://stackoverflow.com/questions/40160904/difference-on-address-of-const-reference-to-ternary-operator-between-clang-and-g\">here</a>):</p>\n<pre><code>float a = 0;\nconst float b = 0;\nconst float &amp; x = true ? a : b;\n\na = 4;\ncout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; x;\n</code></pre>\n<p>clang output:</p>\n<pre><code>4, 4\n</code></pre>\n<p>gcc 4.9.3 output:</p>\n<pre><code>4, 0\n</code></pre>\n<p>With clang this example compiles and runs as expected but with up to recent versions of gcc (\n\n<p>P.S.2 Bonus example 2, great for interviews ;) :</p>\n<pre><code>double a = 3;\n\nconst double &amp; a_ref = a;\n\nconst double &amp; x = true ? a_ref : 2.;\n\na = 4.;\n\nstd::cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; x;\n</code></pre>\n<p>output:</p>\n<pre><code>4, 3\n</code></pre>\n</p>", "Tags": "<c++><c++11><gcc><ternary-operator><clang++>", "OwnerUserId": "832887", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_40167231_40168133_10": {"section_id": 6171, "quality": 1.0, "length": 26}, "so_40167231_40168133_2": {"section_id": 382, "quality": 0.7916666666666666, "length": 19}, "so_40167231_40168133_4": {"section_id": 6169, "quality": 1.0, "length": 29}, "so_40167231_40168133_7": {"section_id": 6169, "quality": 1.0, "length": 13}, "so_40167231_40168133_8": {"section_id": 6169, "quality": 1.0, "length": 26}, "so_40167231_40168133_11": {"section_id": 6172, "quality": 1.0, "length": 14}, "so_40167231_40167573_0": {"section_id": 6169, "quality": 0.9, "length": 9}, "so_40167231_40168133_9": {"section_id": 6170, "quality": 1.0, "length": 14}, "so_40167231_40168133_5": {"section_id": 6169, "quality": 1.0, "length": 19}, "so_40167231_40168133_1": {"section_id": 381, "quality": 1.0, "length": 10}}, "n3337": {"so_40167231_40168133_10": {"section_id": 5932, "quality": 1.0, "length": 26}, "so_40167231_40168133_5": {"section_id": 5930, "quality": 1.0, "length": 19}, "so_40167231_40168133_4": {"section_id": 5930, "quality": 1.0, "length": 29}, "so_40167231_40168133_7": {"section_id": 5930, "quality": 0.9230769230769231, "length": 12}, "so_40167231_40168133_8": {"section_id": 5930, "quality": 1.0, "length": 26}, "so_40167231_40168133_11": {"section_id": 5933, "quality": 1.0, "length": 14}, "so_40167231_40167573_0": {"section_id": 5930, "quality": 0.9, "length": 9}, "so_40167231_40168133_9": {"section_id": 5931, "quality": 1.0, "length": 14}, "so_40167231_40168133_2": {"section_id": 373, "quality": 0.7916666666666666, "length": 19}, "so_40167231_40168133_1": {"section_id": 372, "quality": 1.0, "length": 10}}, "n4659": {"so_40167231_40168133_10": {"section_id": 7669, "quality": 1.0, "length": 26}, "so_40167231_40168133_4": {"section_id": 7667, "quality": 0.9655172413793104, "length": 28}, "so_40167231_40168133_7": {"section_id": 7667, "quality": 0.8461538461538461, "length": 11}, "so_40167231_40168133_2": {"section_id": 397, "quality": 0.75, "length": 18}, "so_40167231_40168133_9": {"section_id": 7668, "quality": 1.0, "length": 14}, "so_40167231_40168133_11": {"section_id": 7670, "quality": 1.0, "length": 14}, "so_40167231_40167573_0": {"section_id": 7667, "quality": 0.9, "length": 9}, "so_40167231_40168133_8": {"section_id": 7667, "quality": 0.9230769230769231, "length": 24}, "so_40167231_40168133_5": {"section_id": 7667, "quality": 0.5789473684210527, "length": 11}, "so_40167231_40168133_1": {"section_id": 396, "quality": 0.9, "length": 9}}}});