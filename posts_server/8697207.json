post_cb({"8697223": {"Id": "8697223", "PostTypeId": "2", "Body": "<p>I'm not sure your code specifically is correct, but generally yes, it would solve the problem.</p>\n", "LastActivityDate": "2012-01-02T03:41:59.420", "CommentCount": "0", "CreationDate": "2012-01-02T03:41:59.420", "ParentId": "8697207", "Score": "0", "OwnerUserId": "618400"}, "bq_ids": {"n4140": {"so_8697207_8697219_0": {"length": 13, "quality": 1.0, "section_id": 3919}, "so_8697207_8697219_1": {"length": 50, "quality": 0.7575757575757576, "section_id": 3919}}, "n3337": {"so_8697207_8697219_1": {"length": 50, "quality": 0.7575757575757576, "section_id": 3779}, "so_8697207_8697219_0": {"length": 13, "quality": 1.0, "section_id": 3779}}, "n4659": {"so_8697207_8697219_0": {"length": 13, "quality": 1.0, "section_id": 4805}}}, "8697207": {"ViewCount": "3119", "Body": "<p>Background: One of the problems with using a local static variable in a function as an implementation of the singleton pattern is that if more than one thread calls the function for the first time at the same time, the initialisation of the static variable could be done twice.</p>\n<p>My question is, if you wrap the initialisations of the static variables in a critical section, will that prevent the double initialisation from happening? Example:</p>\n<pre><code>CRITICAL_SECTION cs;\n\nClass get_class_instance() {\n    EnterCriticalSection(&amp;cs);\n\n    // is the initialisation of c done inside the critical section?\n    static Class c = Class(data);\n\n    LeaveCriticalSection(&amp;cs);\n\n    return c;\n}\n</code></pre>\n<p>Or is the initialisation done magically (not at the point of the declaration/initialisation), like the initialisation of variables member before the beginning of a constructor?</p>\n<p>My question is specifically about pre-C++11 since, as per Xeo's answer, C++11 takes care of this by itself.</p>\n", "AcceptedAnswerId": "8697219", "Title": "Critical sections and the singleton pattern", "CreationDate": "2012-01-02T03:39:41.197", "Id": "8697207", "CommentCount": "2", "LastEditDate": "2012-01-02T03:47:17.393", "PostTypeId": "1", "LastEditorUserId": "726361", "LastActivityDate": "2012-01-02T21:20:21.240", "Score": "2", "OwnerUserId": "726361", "Tags": "<c++><multithreading><singleton><critical-section><c++03>", "AnswerCount": "4"}, "8697242": {"Id": "8697242", "PostTypeId": "2", "Body": "<p>Wrapping the initialization with critical sections would certainly help! I would use the code below to make sure the our static variable is initialized only once.</p>\n<pre><code>CRITICAL_SECTION cs;\n\nClass&amp; get_class_instance() {\n    static Class *c; //by default, global and static variables are assigned default values. Hence c will be NULL when the program starts.\n\n    EnterCriticalSection(&amp;cs);\n\n    if(c == NULL)\n        c = new Class(data);\n\n    LeaveCriticalSection(&amp;cs);\n\n    return *c;\n}\n</code></pre>\n", "LastEditorUserId": "524784", "LastActivityDate": "2012-01-02T03:57:46.773", "Score": "2", "CreationDate": "2012-01-02T03:47:03.307", "ParentId": "8697207", "CommentCount": "17", "OwnerUserId": "524784", "LastEditDate": "2012-01-02T03:57:46.773"}, "8697219": {"Id": "8697219", "PostTypeId": "2", "Body": "<p>C++11 removes the need for locking. Concurrent execution shall wait if a static local variable is already being initialized.</p>\n<p><code>\u00a76.7 [stmt.dcl] p4</code></p>\n<blockquote>\n<p id=\"so_8697207_8697219_0\">If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</p>\n</blockquote>\n<hr>\n<p>For C++03 we have this:</p>\n<p><code>\u00a76.7 [stmt.dcl] p4</code></p>\n<blockquote>\n<p id=\"so_8697207_8697219_1\">The zero-initialization (8.5) of all local objects with static storage duration (3.7.1) is performed before any other initialization takes place. A local object of POD type (3.9) with static storage duration initialized with constant-expressions is initialized before its block is first entered. An implementation is permitted to perform early initialization of other local objects with static storage duration under the same conditions that an\n  implementation is permitted to statically initialize an object with static storage duration in namespace scope (3.6.2). <strong>Otherwise such an object is initialized the first time control passes through its declaration</strong>;</p>\n</blockquote>\n<p>The last part is important, since it applies to your code. When control first enters <code>get_class_instance()</code>, it first passes through the initialization of the critical section, then through the declaration of the singleton (as such will initialize it inside the critical section), and then will pass through the deinitialization of the critical section.</p>\n<p>So from a theoretical point of view, your code should be safe.</p>\n<p>Now, this can be improved though, as to not enter the critical section on every function call. The basic idea of @Chethan is sound, so we'll base it on that. However, we're going to avoid the dynamic allocation too. For that, however, we're relying on Boost.Optional:</p>\n<pre><code>#include &lt;boost/optional.hpp&gt;\n\nClass&amp; get_class_instance() {\n    static boost::optional&lt;Class&gt; c;\n    static bool inited;\n\n    if (!inited){\n        EnterCriticalSection(&amp;cs);\n\n        if(!c)\n            c = Class(data);\n\n        LeaveCriticalSection(&amp;cs);\n        inited = true;\n    }\n\n    return *c;\n}\n</code></pre>\n<p>Boost.Optional avoids the default initialization, and the double check avoids entering the critical section on every function call. This version however introduces a call to the copy constructor of <code>Class</code> in the assignment. The solution to that are inplace factories:</p>\n<pre><code>#include &lt;boost/utility/in_place_factory.hpp&gt;\n#include &lt;boost/optional.hpp&gt;\n\nClass&amp; get_class_instance() {\n    static boost::optional&lt;Class&gt; c;\n    static bool inited;\n\n    if (!inited){\n        EnterCriticalSection(&amp;cs);\n\n        if(!c)\n            c = boost::in_place(data);\n\n        LeaveCriticalSection(&amp;cs);\n        inited = true;\n    }\n\n    return *c;\n}\n</code></pre>\n<p>My thanks go to @R. Martinho Fernandes and @Ben Voigt who collaborated to this final solution. If you're interested in the process, feel free to take a look at the <a href=\"http://chat.stackoverflow.com/transcript/message/2251976#2251976\">transcript</a>.</p>\n<hr>\n<p>Now, if your compiler supports some of the C++11 features already, but not the static initialization stuff, you can also use <code>std::unique_ptr</code> combined with placement new and a static aligned buffer:</p>\n<pre><code>#include &lt;memory&gt; // std::unique_ptr\n#include &lt;type_traits&gt; // alignment stuff\n\ntemplate&lt;class T&gt;\nstruct destructor{\n    void operator(T* p) const{\n    if(p) // don't destruct a null pointer\n        p-&gt;~T();\n    }\n};\n\nClass&amp; get_class_instance() {\n    typedef std::aligned_storage&lt;sizeof(Class),\n        std::alignment_of&lt;Class&gt;::value&gt;::type storage_type;\n    static storage_type buf;\n    static std::unique_ptr&lt;Class, destructor&gt; p;\n    static bool inited;\n\n    if (!inited){\n        EnterCriticalSection(&amp;cs);\n\n        if(!p)\n            p.reset(new (&amp;buf[0]) Class(data));\n\n        LeaveCriticalSection(&amp;cs);\n        inited = true;\n    }\n\n    return *p;\n}\n</code></pre>\n</hr></hr>", "LastEditorUserId": "103167", "LastActivityDate": "2012-01-02T18:07:26.983", "Score": "5", "CreationDate": "2012-01-02T03:41:46.103", "ParentId": "8697207", "CommentCount": "16", "OwnerUserId": "500104", "LastEditDate": "2012-01-02T18:07:26.983"}, "8705383": {"Id": "8705383", "PostTypeId": "2", "Body": "<p>For C++03, you need to <em>locklessly</em> update the state. This is because you cannot use a lock without initializing it, which will run into the exact same problem again recursively, since you need to thread-safe-initialize the lock you're going to use to thread-safe-initialize. Whoops. You can rely on only zero-initialization for globals and some lockless instructions. This is also much faster.</p>\n<p>You can solve this problem with a state variable and a lockless CAS instruction.</p>\n<pre><code>enum State {\n    ObjectUninitialized,\n    ObjectInitializing,\n    ObjectInitialized\n};\n\nvolatile std::size_t state; // Must be initialized to 0- done by compiler\n                            // before main(). All globals are 0\n                            // Also must be word sized\n\nT* func() {\n    static char buffer[sizeof(T)];\n    long result = InterlockedCompareExchange(&amp;state, ObjectInitializing, ObjectUninitialized);\n    if (result == ObjectInitialized) {\n        return reinterpret_cast&lt;T*&gt;(buffer);\n    }\n    if (result == ObjectInitializing) {\n        while (state == ObjectInitializing); // read is atomic for word-size variables\n        return reinterpret_cast&lt;T*&gt;(buffer); // and use volatile to force compiler to add     \n    }\n    if (result == ObjectUninitialized) {\n        new (buffer) T();\n        InterlockedExchange(&amp;state, ObjectInitialized);\n        return reinterpret_cast&lt;T*&gt;(buffer);\n    }\n}\n</code></pre>\n", "LastEditorUserId": "298661", "LastActivityDate": "2012-01-02T21:20:21.240", "Score": "2", "CreationDate": "2012-01-02T21:11:48.340", "ParentId": "8697207", "CommentCount": "0", "OwnerUserId": "298661", "LastEditDate": "2012-01-02T21:20:21.240"}});