post_cb({"bq_ids": {"n4140": {"so_9817806_9818136_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 2027}}, "n3337": {"so_9817806_9818136_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 2015}}, "n4659": {"so_9817806_9818136_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 2300}}}, "9817806": {"ViewCount": "2516", "Body": "<p>I have a program shown as follows.  For it I have several questions:</p>\n<p>1). <strong>Why does it produce different results on different platforms?</strong>  I'll paste the screen-shots later.</p>\n<p>2). <strong>I'm using a fail() method to check if the \"file.read()\" failed.  Is this correct?</strong>  I use fail() method because <a href=\"http://www.cplusplus.com/reference/iostream/ios/fail/\" rel=\"nofollow noreferrer\">this web page</a> says this:</p>\n<blockquote>\n<p id=\"so_9817806_9817806_0\">The function returns true if either the failbit or the badbit is set. At least one of these flags is set when some error <strong>other than reaching the End-Of-File occurs</strong> during an input operation.</p>\n</blockquote>\n<p>But later I read this page about istream::read() <a href=\"http://www.cplusplus.com/reference/iostream/istream/read/\" rel=\"nofollow noreferrer\">here</a>.  It says the eofbit and failbit would always be set at the same time.. <strong>Does this mean that a normal EOF situation would also result in that fail() returns true?  This seems to conflict with \"other than reaching the End-Of-File occurs\"..</strong></p>\n<p>Could anyone help me clarify how I am supposed to use these methods?  Should I use bad() instead?</p>\n<h2>My program</h2>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\n\n#ifdef WIN32\nchar * path=\"C:\\\\Workspace\\\\test_file.txt\";\n#else\nchar * path=\"/home/robin/Desktop/temp/test_file.txt\";\n#endif\n\nint main(int argc, char * argv[])\n{\n    ifstream file;\n\n    file.open(path);\n    if (file.fail())\n    {\n        cout &lt;&lt; \"File open failed!\" &lt;&lt; endl;\n        return -1;  // If the file open fails, quit!\n    }\n\n    // Calculate the total length of the file so I can allocate a buffer\n    file.seekg(0, std::ios::end);\n    size_t fileLen = file.tellg();\n    cout &lt;&lt; \"File length: \" &lt;&lt; fileLen &lt;&lt; endl;\n    file.seekg(0, std::ios::beg);\n\n    // Now allocate the buffer\n    char * fileBuf = new (std::nothrow) char[fileLen+1];\n    if (NULL == fileBuf)\n        return -1;\n    ::memset((void *)fileBuf, 0, fileLen+1);    // Zero the buffer\n\n    // Read the file into the buffer\n    file.read(fileBuf, fileLen);\n    cout &lt;&lt; \"eof: \" &lt;&lt; file.eof() &lt;&lt; endl\n         &lt;&lt; \"fail: \" &lt;&lt; file.fail() &lt;&lt; endl\n         &lt;&lt; \"bad: \" &lt;&lt; file.bad() &lt;&lt; endl;\n    if (file.fail())\n    {\n        cout &lt;&lt; \"File read failed!\" &lt;&lt; endl;\n        delete [] fileBuf;\n        return -1;\n    }\n\n    // Close the file\n    file.close();\n\n    // Release the buffer\n    delete [] fileBuf;\n\n    return 0;\n}\n</code></pre>\n<h2>The test_file.txt content(shown with \"vim -b\". It's a very simple file):</h2>\n<p><img alt=\"test_file.txt content\" src=\"https://i.stack.imgur.com/BYHZb.png\"/></p>\n<h2>Result on Windows(Visual Studio 2008 SP1):</h2>\n<p><img alt=\"Windows result\" src=\"https://i.stack.imgur.com/FEqfr.jpg\"/></p>\n<h2>Result on Linux(gcc 4.1.2):</h2>\n<p><img alt=\"Linux result\" src=\"https://i.stack.imgur.com/HUNDA.png\"/></p>\n", "AcceptedAnswerId": "9818136", "Title": "Why does my program produce different results on Windows and Linux, about file reading with ifstream?", "CreationDate": "2012-03-22T07:05:51.430", "Id": "9817806", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2012-03-22T07:58:26.663", "Score": "2", "OwnerUserId": "630364", "Tags": "<c++><ifstream>", "AnswerCount": "2"}, "9818218": {"Id": "9818218", "PostTypeId": "2", "Body": "<p>I guess, the problem here with the different execution is the DOS(Window) vs. UNIX text file convention.</p>\n<p>In DOS, a line ends with <code>&lt;CR&gt;&lt;LF&gt;</code>, and this is read/written together as <code>'\\n'</code>. Thus, in Windows your file is at the end, but in UNIX not, since there is one character left.</p>\n", "LastEditorUserId": "597607", "LastActivityDate": "2012-03-22T07:54:23.290", "Score": "2", "CreationDate": "2012-03-22T07:43:13.313", "ParentId": "9817806", "CommentCount": "7", "OwnerUserId": "1213227", "LastEditDate": "2012-03-22T07:54:23.290"}, "9818136": {"Id": "9818136", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_9817806_9818136_0\">Does this mean that a normal EOF situation would also result in that fail() returns true? This seems to conflict with \"other than reaching the End-Of-File occurs\".</p>\n</blockquote>\n<p>I recommend using a reference that isn't full of mistakes.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/io/basic_ios/fail\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/io/basic_ios/fail</a> says:</p>\n<blockquote>\n<p id=\"so_9817806_9818136_1\">Returns <code>true</code> if an error has occurred on the associated stream. Specifically, returns <code>true</code> if <code>badbit</code> or <code>failbit</code> is set in <code>rdstate()</code>. </p>\n</blockquote>\n<p>And the C++ standard says:</p>\n<blockquote>\n<p id=\"so_9817806_9818136_2\"><em>Returns:</em> <code>true</code> if failbit or <code>badbit</code> is set in <code>rdstate()</code>.</p>\n</blockquote>\n<p>There's no \"other than end-of-file\" thing. An operation that tries to read past the end of the file, will cause <code>failbit</code> to set as well. The <code>eofbit</code> only serves to distinguish that specific failure reason from others (and that is not as useful as one might think at first).</p>\n<hr>\n<blockquote>\n<p id=\"so_9817806_9818136_3\">I'm using a <code>fail()</code> method to check if the \"file.read()\" failed. Is this correct?</p>\n</blockquote>\n<p>You should simply test with conversion to <code>bool</code>.</p>\n<pre><code>if(file) { // file is not in an error state\n</code></pre>\n<p>It's synonymous with <code>!fail()</code>, but it's more usable, because you can use it to test directly the result of a read operation without extra parenthesis (things like <code>!(stream &gt;&gt; x).fail()</code> get awkward):</p>\n<pre><code>if(file.read(fileBuf, fileLen)) { // read succeeded\n</code></pre>\n<p>You will notice that all read operations on streams return the stream itself, which is what allows you to do this.</p>\n<hr>\n<blockquote>\n<p id=\"so_9817806_9818136_4\">Why does it produce different results on different platforms?</p>\n</blockquote>\n<p>The difference you're seeing between Windows and Linux is because the file is open in text mode: newline characters will be converted silently by the implementation. This means that the combination <code>\"\\r\\n\"</code> (used in Windows for newlines) will be converted to a single <code>'\\n'</code> character in Windows, making the file have only 8 characters. Note how vim shows a <code>^M</code> at the end of the first line: that's the <code>'\\r'</code> part. In Linux a newline is just <code>'\\n'</code>.</p>\n<p>You should open the file in binary mode if you want to preserve the original as is:</p>\n<pre><code>file.open(path, std::ios_base::in | std::ios_base::binary);\n</code></pre>\n</hr></hr>", "LastEditorUserId": "46642", "LastActivityDate": "2012-03-22T07:58:26.663", "Score": "8", "CreationDate": "2012-03-22T07:36:22.727", "ParentId": "9817806", "CommentCount": "5", "OwnerUserId": "46642", "LastEditDate": "2012-03-22T07:58:26.663"}});