post_cb({"19262081": {"Id": "19262081", "PostTypeId": "2", "Body": "<p>Quoting from the C++11 standard (emphasis mine):</p>\n<blockquote>\n<h3>8.3.2 References</h3>\n<p id=\"so_19262062_19262081_0\"><sup>1</sup> [...] A declarator that specifies the type\n  \u201c<strong>reference</strong> to cv <strong>void</strong>\u201d is <strong>ill-formed</strong>.</p>\n</blockquote>\n<hr>\n<p>As a side tidbit of info, this rule has been taken advantage by the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.txt\">N3421 <code>greater&lt;&gt;</code> proposal</a> (which was already accepted to be included into the future C++14 standard) by having <code>void</code> as the default template argument.</p>\n<blockquote>\n<p id=\"so_19262062_19262081_1\">B. The technique of using default template arguments and explicit\n  specializations for <code>void</code> was chosen for its non-intrusiveness. <code>greater&lt;void&gt;</code>\n  isn't valid C++11 (it would attempt to form a reference to <code>void</code>, forbidden by\n  8.3.2 [dcl.ref]/1). Additionally, while users are permitted to specialize\n  Standard Library machinery (17.6.4.2.1 [namespace.std]/1), such specializations\n  must involve user-defined types.</p>\n</blockquote>\n<hr>\n<p>Maybe I'm just a bit more indulged into these mind games, but for the rationale of why this rule is enforced -- and I must state that this is just my own humble opinion -- consider the following code:</p>\n<pre><code>sizeof(double&amp;);   // Results in double's size\n\nusing foo_ref = foo&amp;;\nsizeof(foo_ref);   // Results in foo's size\n\nsizeof(void);      // Error! void has no size!\nsizeof(void&amp;);     // Error! Tries to get the size of void\n</code></pre>\n<p>Most importantly, keep in mind that references are just aliases of other objects, and you cannot have an object of type <code>void</code>.</p>\n</hr></hr>", "LastEditorUserId": "56338", "LastActivityDate": "2013-10-09T02:56:23.363", "Score": "16", "CreationDate": "2013-10-09T02:35:34.357", "ParentId": "19262062", "CommentCount": "2", "OwnerUserId": "1619294", "LastEditDate": "2013-10-09T02:56:23.363"}, "19262143": {"Id": "19262143", "PostTypeId": "2", "Body": "<p>A reference to a <code>void</code> means the data pointed to, which doesn't have a type, therefore it cannot be referenced in any meaningful way.</p>\n<p>A reference is a reference to an instance of some type, which cannot be of type <code>void</code>.</p>\n", "LastActivityDate": "2013-10-09T02:41:28.673", "CommentCount": "0", "CreationDate": "2013-10-09T02:41:28.673", "ParentId": "19262062", "Score": "2", "OwnerUserId": "1870232"}, "bq_ids": {"n4140": {"so_19262062_19262081_0": {"length": 6, "quality": 1.0, "section_id": 3218}}, "n3337": {"so_19262062_19262081_0": {"length": 6, "quality": 1.0, "section_id": 3092}}, "n4659": {"so_19262062_19262081_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 3975}}}, "19262062": {"ViewCount": "920", "Body": "<p>Is this C++11 program ill-formed?</p>\n<pre><code>typedef void&amp; rv;\n\nint main() {}\n</code></pre>\n<p>I couldn't find anything disallowing it in the standard (looked in 3.9.2 and 8.3.2).</p>\n<p>Clang says \"cannot form a reference to 'void'\", gcc says \"cannot declare reference to \u2018void\u2019\"</p>\n<p>I would have expected [dcl.ref]/5 to give such a restriction, if it were intended.</p>\n<p>Are the implementations just \"reading between the lines\" because such a type can never be used in an object definition?</p>\n", "AcceptedAnswerId": "19262081", "Title": "C++11: reference-to-void?", "CreationDate": "2013-10-09T02:33:14.990", "Id": "19262062", "CommentCount": "0", "LastEditDate": "2013-10-11T02:26:27.360", "PostTypeId": "1", "LastEditorUserId": "1476062", "LastActivityDate": "2013-10-11T02:26:27.360", "Score": "14", "OwnerUserId": "1131467", "Tags": "<c++><c++11>", "AnswerCount": "2"}});