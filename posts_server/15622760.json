post_cb({"bq_ids": {"n4140": {"so_15622760_15622820_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 638}}, "n3337": {"so_15622760_15622820_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 628}}, "n4659": {"so_15622760_15622820_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 666}}}, "15622820": {"Id": "15622820", "PostTypeId": "2", "Body": "<p>The string literal <code>\"trigger_pt\"</code> is of type \"array of 11 <code>const char</code>\". The compiler considers it better to convert this to a <code>bool</code> than to convert it to a <code>std::string</code>. The reason is because converting to <code>bool</code> only uses standard conversions (array-to-pointer and then pointer to bool), whereas converting to <code>std::string</code> requires calling a constructor. A standard conversion sequence is always considered better than a user-defined conversion sequence (involving the conversion constructor).</p>\n<blockquote>\n<p id=\"so_15622760_15622820_0\">When comparing the basic forms of implicit conversion sequences (as defined in 13.3.3.1)</p>\n<ul>\n<li>a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence, and</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>You can force it to use the second overload by making that literal a <code>std::string</code>:</p>\n<pre><code>Node axis1 = handler-&gt;CreateNode(&amp;sparse,\"axis\",\"id\",std::string(\"trigger_pt\"));\n</code></pre>\n<p>The other alternative is to provide another overload that takes a <code>const char*</code>, which will be preferred over the <code>bool</code> version. This overload can simply forward to the <code>std::string</code> overload.</p>\n", "LastActivityDate": "2013-03-25T19:10:31.057", "CommentCount": "4", "CreationDate": "2013-03-25T19:10:31.057", "ParentId": "15622760", "Score": "7", "OwnerUserId": "150634"}, "15622760": {"ViewCount": "423", "Body": "<p>I am using Visual Studio 2012 (But using the VC++ 2010 build tools), and I have these two overloaded functions (signatures below) defined in a class which I later call in another class that instantiates the first class (also below):</p>\n<pre><code>Defined in the class:\nNode CreateNode(Node *parent,string name,string node_text,bool expects_node = true);\nNode CreateNode(Node *parent,string name, string attribute, string value,bool expects_node = true)\n\nCalling these functions in the macro:\nNode axis1 = handler-&gt;CreateNode(&amp;sparse,\"axis\",\"id\",\"trigger_pt\");\n</code></pre>\n<p>When I make the function call, it calls the first function, not the second! So it treats the second string as a boolean! However, when I add \"true\" to the function call, it calls the second function as expected. Can anyone explain this? Thanks!</p>\n", "AcceptedAnswerId": "15622820", "Title": "Visual C++ 2010 accepts string for bool in overloaded function", "CreationDate": "2013-03-25T19:07:05.467", "Id": "15622760", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-03-25T19:10:31.057", "Score": "5", "OwnerUserId": "2208795", "Tags": "<c++><visual-studio-2010><visual-c++>", "AnswerCount": "1"}});