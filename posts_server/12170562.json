post_cb({"12170694": {"ParentId": "12170562", "CommentCount": "5", "Body": "<p>The important bit here is that ADL only kicks in if lookup determines that the name <em>is</em> a function in the function call. In the second case, <code>bar</code> is found to be an <em>object</em> and not a function, so the expression <code>bar(N::A)</code> is not a function call, but the application of <code>operator()</code> to the object <code>bar</code>. Because it is not a function call, ADL does not kick in and <code>N::bar</code> is not considered.</p>\n<blockquote>\n<p id=\"so_12170562_12170694_0\">3.4.1/3</p>\n<p id=\"so_12170562_12170694_1\">The lookup for an unqualified name used as the postfix-expression of a function call is described in 3.4.2. [ Note: For purposes of determining (during parsing) whether an expression is a postfix-expression for a func- tion call, the usual name lookup rules apply. The rules in 3.4.2 <em>[ADL]</em> have no effect on the syntactic interpretation of an expression.</p>\n</blockquote>\n<p>Another way to look at it is to notice that ADL will add new functions to the <em>set of overloaded functions</em>, but in the second example there is no such set: lookup finds an object and a member of the object is called.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "12170694", "Score": "12", "CreationDate": "2012-08-29T04:01:30.100", "LastActivityDate": "2012-08-29T04:01:30.100"}, "12170562": {"CommentCount": "0", "ViewCount": "146", "LastActivityDate": "2012-08-30T21:26:44.273", "Body": "<p>Are function objects treated differently from regular functions during overload resolution? If so, how?</p>\n<p>I have run into the following case where replacing a function with an equivalently-callable function object changed the meaning of the code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace N\n{\n    enum E { A, B };\n\n    void bar(E mode) { std::cout &lt;&lt; \"N::bar\\n\"; }\n}\n\ntemplate &lt;typename... Args&gt;\nvoid bar(Args&amp;&amp;... args) { std::cout &lt;&lt; \"global bar\\n\"; }\n\nint main()\n{\n    bar(N::A);\n}\n</code></pre>\n<p>Here the output is \"N::bar\". So far, so good: N::bar is being found by ADL, both N::bar and the global bar are exact matches, and N::bar is preferred because it's not a template.</p>\n<p>But if I change the global bar to be a function object, like so:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace N\n{\n    enum E { A, B };\n\n    void bar(E mode) { std::cout &lt;&lt; \"N::bar\\n\"; }\n}\n\nstruct S\n{\n    template &lt;typename... Args&gt;\n    void operator()(Args&amp;&amp;... args) { std::cout &lt;&lt; \"global bar\\n\"; }\n};\nS bar;\n\nint main()\n{\n    bar(N::A);\n}\n</code></pre>\n<p>The output is now \"global bar\". Why the difference?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "12170694", "FavoriteCount": "0", "Title": "How do function objects affect overload resolution?", "Id": "12170562", "Score": "12", "CreationDate": "2012-08-29T03:42:04.657", "Tags": "<c++><c++11><overload-resolution><function-object>", "OwnerUserId": "141719", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_12170562_12170694_1": {"section_id": 7089, "quality": 0.7428571428571429, "length": 26}, "so_12170562_12205777_0": {"section_id": 7105, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_12170562_12170694_1": {"section_id": 6833, "quality": 0.7428571428571429, "length": 26}, "so_12170562_12205777_0": {"section_id": 6849, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_12170562_12170694_1": {"section_id": 8590, "quality": 0.7428571428571429, "length": 26}, "so_12170562_12205777_0": {"section_id": 8606, "quality": 0.9411764705882353, "length": 16}}}, "12205777": {"ParentId": "12170562", "CommentCount": "2", "Body": "<p>See 3.4.2p3, which says</p>\n<blockquote>\n<p id=\"so_12170562_12205777_0\">Let X be the lookup set produced by unqualified lookup (3.4.1) and let Y be the lookup set produced by argument dependent lookup (defined as follows). If X contains</p>\n<ul>\n<li>...</li>\n<li>a declaration that is neither a function or a function template</li>\n</ul>\n<p id=\"so_12170562_12205777_1\">then Y is empty.</p>\n</blockquote>\n<p>If there would not be such a rule, you are right: ADL would add your other function to the overload set. In fact, 13.3.1.1p1 relies on this: It has two branches; one for function call expressions where the operand denotes a class object, and another one where the operand denotes one or more functions or function templates. </p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "12205777", "Score": "4", "CreationDate": "2012-08-30T21:26:44.273", "LastActivityDate": "2012-08-30T21:26:44.273"}});