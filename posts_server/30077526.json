post_cb({"bq_ids": {"n4140": {"so_30077526_30078294_0": {"length": 49, "quality": 0.8909090909090909, "section_id": 603}, "so_30077526_30078292_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 603}, "so_30077526_30078292_1": {"length": 6, "quality": 0.75, "section_id": 603}}, "n3337": {"so_30077526_30078294_0": {"length": 49, "quality": 0.8909090909090909, "section_id": 593}, "so_30077526_30078292_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 593}, "so_30077526_30078292_1": {"length": 6, "quality": 0.75, "section_id": 593}}, "n4659": {"so_30077526_30078294_0": {"length": 49, "quality": 0.8909090909090909, "section_id": 629}, "so_30077526_30078292_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 629}, "so_30077526_30078292_1": {"length": 6, "quality": 0.75, "section_id": 629}}}, "30078292": {"Id": "30078292", "PostTypeId": "2", "Body": "<p>When comparing conversion sequences, the conversions on the parameters are considered before the conversion of the result type.  The implicit object parameter (the <code>this</code> pointer) is considered as a parameter, and a qualification conversion (<code>Foo -&gt; Foo const</code>) is worse than the identity conversion on the implicit object parameter.  From <strong>[over.match.best]</strong>:</p>\n<blockquote>\n<p id=\"so_30077526_30078292_0\">1 - [...] a viable function F1 is de\ufb01ned to be a better function than another viable function\n  F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<p id=\"so_30077526_30078292_1\">\u2014 for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that, [...]</p>\n</blockquote>\n<p>So a non-<code>const</code>-qualified member conversion operator will always be better than a <code>const</code>-qualified one, even if the result conversion is exact on the latter.</p>\n", "LastActivityDate": "2015-05-06T13:30:31.420", "CommentCount": "1", "CreationDate": "2015-05-06T13:30:31.420", "ParentId": "30077526", "Score": "3", "OwnerUserId": "567292"}, "30077526": {"ViewCount": "111", "Body": "<p>I have something along the lines of:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Foo;\n\nstruct Test\n{\n    template &lt;typename T&gt;\n    operator T() const //  &lt;----- This const is what puzzles me \n    {\n        std::cout &lt;&lt; \"Template conversion\" &lt;&lt; std::endl;\n        return T{};\n    }\n\n    operator Foo*()\n    {\n        std::cout &lt;&lt; \"Pointer conversion\" &lt;&lt; std::endl;\n        return nullptr;\n    }\n};\n\nint main()\n{\n    Test t;\n\n    if (t)\n    {\n        std::cout &lt;&lt; \"ahoy\" &lt;&lt; std::endl;\n    }\n    bool b = (bool)t;\n    Foo* f = (Foo*)t;\n}\n</code></pre>\n<p>It builds fine, but when I run it, while I would expect to get</p>\n<pre><code>$&gt; ./a.out\nTemplate conversion\nTemplate conversion\nPointer conversion\n</code></pre>\n<p>I instead get</p>\n<pre><code>$&gt; ./a.out\nPointer conversion\nPointer conversion\nPointer conversion\n</code></pre>\n<p>If I remove the const, or make the Test instance const, then everything works as expected.\nMore precisely, the overload selection seems to make sense strictly when both operators have the same const qualification.</p>\n<p>13.3.3.1.2 point of the standard makes me think I should get an identity conversion, converting to a bool, using the template conversion operator instantiation with a <code>T</code> = <code>bool</code>, though there is obviously a subtlety hiding somewhere. Could someone enlighten me as to what rule comes into play here?</p>\n", "AcceptedAnswerId": "30078292", "Title": "Template conversion operator priority & constness", "CreationDate": "2015-05-06T12:59:39.193", "Id": "30077526", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-05-06T13:48:47.020", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-06T13:48:47.020", "Score": "13", "OwnerUserId": "393922", "Tags": "<c++><templates><overload-resolution>", "AnswerCount": "2"}, "30078294": {"Id": "30078294", "PostTypeId": "2", "Body": "<p>The relevant rules are defined in [over.match.best]:</p>\n<blockquote>\n<p id=\"so_30077526_30078294_0\">Given these definitions, a viable function <code>F1</code> is defined to be a better function than another viable function\n  <code>F2</code> if for all arguments <em>i</em>, ICS<em>i</em>(<code>F1</code>) is not a worse conversion sequence than ICS<em>i</em>(<code>F2</code>), and then<br>\n  (1.3) \u2014 for some argument <em>j</em>, ICS<em>j</em>(<code>F1</code>) is a better conversion sequence than ICS<em>j</em>(<code>F2</code>), or, if not that,<br>\n  (1.4) \u2014 the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the standard conversion sequence from the return type of <code>F1</code> to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the standard conversion sequence from the return type of <code>F2</code> to the destination type.</br></br></p>\n</blockquote>\n<p>Let's just look at the first <code>bool</code> case. We have two viable candidates:</p>\n<pre><code>Test::operator T&lt;bool&gt;() const;\nTest::operator Foo*();\n</code></pre>\n<p>Both are called with a non-<code>const</code> <code>Test</code>. For the 2nd overload, no conversions are necessary - the conversion sequence is simply Exact Match. However, for the first overload, the implicit <code>this</code> argument needs to undergo a qualification conversion from <code>Test</code> to <code>const Test</code>. Thus, the second overload is preferred - we do not get to the second step which discusses return type.</p>\n<p>If we dropped the <code>const</code> however, the viable candidates become:</p>\n<pre><code>Test::operator T&lt;bool&gt;();\nTest::operator Foo*();\n</code></pre>\n<p>Here, both candidates are equally viable with identical conversion sequences, but the <code>bool</code> template is preferred since the conversion sequence from the return type <code>bool</code> to <code>bool</code> (Identity - the highest rank) is a better conversion sequence than from <code>Foo*</code> to <code>bool</code> (Boolean Conversion - the lowest).</p>\n", "LastActivityDate": "2015-05-06T13:30:37.387", "CommentCount": "1", "CreationDate": "2015-05-06T13:30:37.387", "ParentId": "30077526", "Score": "6", "OwnerUserId": "2069064"}});