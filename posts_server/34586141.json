post_cb({"bq_ids": {"n4140": {"so_34586141_34595754_1": {"length": 19, "quality": 0.95, "section_id": 7161}, "so_34586141_34595754_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 7044}}, "n3337": {"so_34586141_34595754_1": {"length": 19, "quality": 0.95, "section_id": 6905}, "so_34586141_34595754_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6789}}, "n4659": {"so_34586141_34595754_1": {"length": 18, "quality": 0.9, "section_id": 8668}, "so_34586141_34595754_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 8541}}}, "34587544": {"Id": "34587544", "PostTypeId": "2", "Body": "<pre><code>void foo()\n{\n    int obj1;\n    {\n        int obj2;\n        // obj1, obj2 can be used here\n        {\n            int obj1;\n            //in this scope obj1 is not the first obj1, it's the one declared in previous line\n        }\n        // obj1 in this will refer the first obj1\n    }\n}\n</code></pre>\n<p>Regarding second question by default when you create some object inside a function it will be on stack.It is preferred because we don't have to take care of memory allocated. It will be deleted from stack automatically.</p>\n<p>We can create memory on heap using new but in that case we have to make sure that once we are done we have deleted the allocated memory, or make sure that ownership of object is transferred so that it is deleted.</p>\n<p>Check the following case.</p>\n<pre><code>void foo1()\n{\n    int* i = new int(23);\n    // use i here ...\n    // .....\n    delete i; // once done delete the memory, it exception is thrown here i will not be deleted so make sure to use smart pointer(RAII)\n}\n\nvoid foo2()\n{\n    unique_ptr&lt;int&gt; iPtr(new int(23));\n    // use iPTr here ...\n    // .....\n    // no need to delete allocated memory, unique_ptr will handle that\n}\n</code></pre>\n<p>To avoid the unnecessary memory management we create objects on stack. Also in Embedded domain it is not advised to use dynamic memory allocation because its not safe.</p>\n", "LastEditorUserId": "1057286", "LastActivityDate": "2016-01-05T11:07:27.313", "Score": "1", "CreationDate": "2016-01-04T08:58:20.440", "ParentId": "34586141", "CommentCount": "2", "OwnerUserId": "1057286", "LastEditDate": "2016-01-05T11:07:27.313"}, "34586229": {"Id": "34586229", "PostTypeId": "2", "Body": "<p>This is object declared on the stack simply because of the fact that once this returning integer function is called it has lived it's purpose so to speak. I'll say that the way you're using the object in the first place is a bit odd. Why not just pass a reference to the object as input argument to the function. </p>\n<pre><code>int foo(object) {\n\n\n}\n</code></pre>\n<p>As for other cases where an object can be out of scope solely depends on the thread or location where an object is created. </p>\n", "LastActivityDate": "2016-01-04T07:07:52.107", "CommentCount": "0", "CreationDate": "2016-01-04T07:07:52.107", "ParentId": "34586141", "Score": "0", "OwnerUserId": "5369959"}, "34595754": {"Id": "34595754", "PostTypeId": "2", "Body": "<p>There are two important concepts in C++:</p>\n<ul>\n<li><em>scope</em> and</li>\n<li><em>storage duration</em>. </li>\n</ul>\n<p>The two interact but are distinct. (There is a third concept, <em>object lifetime,</em> which for \"normal\" programs is almost the same as the object's storage duration; let's ignore it for now.)</p>\n<p>Let's examine <em>scope</em>.</p>\n<p><strong>Scope</strong> means \"where is the <em>name</em> visible and valid\". The central concept is <strong>name.</strong> The standard says in 3.3.1</p>\n<blockquote>\n<p id=\"so_34586141_34595754_0\">In general, each particular <strong>name</strong> is valid only within some possibly\n  discontiguous portion of program text called its <em>scope.</em> [Emphasis by me.]</p>\n</blockquote>\n<p>A name like <code>i</code> can go out of scope. That means one cannot use it any longer to refer to the specific object. The example you gave is correct: when an enclosing block, like a function body, is left. Another example is when two entities have the same name, like a global <code>i</code> and a local loop variable <code>i</code>. The <em>scope</em>  of the global <code>i</code> does not include the loop (that's a different <code>i</code>). But the <em>storage duration</em> (and hence the lifetime) of the global <code>i</code> object of course includes the loop -- it is still \"there\" (one could, for example, use a pointer to access it).</p>\n<p>The <strong>storage duration</strong>, by contrast, is not a formal grammar thing but a hands-on run time issue. The central concept is <strong>storage</strong>: The aptly named storage duration describes how long the storage holding an object is valid. (See how we are not concerned with <em>names</em> here.) The standard says in 3.7:</p>\n<blockquote>\n<p id=\"so_34586141_34595754_1\"><em>Storage duration</em> is the property of an object that defines \n  the minimum potential lifetime of the <strong>storage</strong> containing \n  the object. The storage duration is determined by the \n  construct used to create the object and is one of the following:</p>\n<ul>\n<li>static storage duration</li>\n<li>thread storage duration </li>\n<li>automatic storage duration </li>\n<li>dynamic storage duration </li>\n</ul>\n<p id=\"so_34586141_34595754_2\">[Emphasis by me.]</p>\n</blockquote>\n<p>The easiest \"construct to create an object\" is to simply declare a local variable inside a function. The storage thus created has the aptly named \"automatic\" storage duration -- the implementation creates the object (latest?) when the definition is executed and destroys the object for you when the name's scope is left. For automatic variables the connection between name scope and storage duration is strong. </p>\n<p>But note that one can as well declare an external variable or a function inside a block and thus have a name with local scope for an external entity:</p>\n<pre><code>$ cat local-external.cpp &amp;&amp; g++  -Wall -o local-external local-external.cpp &amp;&amp; ./local-external\nint main()\n{\n        {\n                extern int i;\n        }\n        i=1;\n}\nlocal-external.cpp: In function \u2018int main()\u2019:\nlocal-external.cpp:4:14: warning: unused variable \u2018i\u2019 [-Wunused-variable]\n   extern int i;\n              ^\nlocal-external.cpp:6:2: error: \u2018i\u2019 was not declared in this scope\n  i=1;\n  ^\n</code></pre>\n<p>The <em>scope</em> of <code>i</code> \u00ecs the same as for a local variable -- from its declaration to the end of the enclosing block --, but its storage duration (if an object existed, for example defined in a different file) would be static, because it is an external variable and lives as long as the program. If the assignment is moved into the inner block so that the code compiles, the linker complains that it cannot find the external object <code>i</code> (the storage which should be set aside somewhere). </p>\n<p>Of course one rarely does such things; it is only a demonstration. (Declaring local functions is probably most often done <a href=\"https://en.wikipedia.org/wiki/Most_vexing_parse\" rel=\"nofollow\">inadvertently</a>.)</p>\n", "LastActivityDate": "2016-01-04T16:41:50.707", "CommentCount": "0", "CreationDate": "2016-01-04T16:41:50.707", "ParentId": "34586141", "Score": "0", "OwnerUserId": "3150802"}, "34586141": {"ViewCount": "763", "Body": "<p>I am aware of one situation in which an object goes out of scope. For example, assume we have called a function foo() from our main().</p>\n<pre><code>int foo()\n{\n   someobject obj;\n\n   //do something with this object\n\n   return -1;\n}\n</code></pre>\n<p>Now i know that since this object was declared on stack, when foo() ends this object will be removed from stack.\nCan someone please explain <strong><em>other situations where objects goes out of scope?</em></strong> Another thing, <strong><em>why is this object declared on stack?</em></strong></p>\n", "Title": "What does going out of scope means in c++ objects?", "CreationDate": "2016-01-04T07:00:28.893", "LastActivityDate": "2016-01-05T11:07:27.313", "CommentCount": "1", "LastEditDate": "2016-01-04T15:18:40.517", "PostTypeId": "1", "LastEditorUserId": "1593860", "Id": "34586141", "Score": "-3", "OwnerUserId": "2842549", "Tags": "<c++>", "AnswerCount": "3"}});