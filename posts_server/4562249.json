post_cb({"4562342": {"ParentId": "4562249", "CommentCount": "0", "CreationDate": "2010-12-30T11:48:12.577", "OwnerUserId": "82", "PostTypeId": "2", "Id": "4562342", "Score": "0", "Body": "<p>A <code>struct</code> can also be POD, in which case you can explicity control potential padding between members with <code>#pragma pack</code> on some compilers.</p>\n", "LastActivityDate": "2010-12-30T11:48:12.577"}, "4562518": {"ParentId": "4562249", "PostTypeId": "2", "CommentCount": "13", "CreationDate": "2010-12-30T12:17:07.970", "Score": "8", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:49.493", "Id": "4562518", "OwnerUserId": "23643", "Body": "<p>I think there are two parts to this question:</p>\n<ol>\n<li><p>What sizes primitive types are <em>allowed</em> to be.<br>\nThis <a href=\"https://stackoverflow.com/questions/589575/c-size-of-int-long-etc/589684#589684\">is specified by the C and C++ standards</a>: the types have allowed minimum value ranges they must have, which implicitly places a lower bound on their size <em>in bits</em> (e.g. <code>long</code> must be at least 32 bit to comply with the standard).<br>\nThe standards do not specify the size in bytes, because the <a href=\"https://stackoverflow.com/questions/437470/type-to-use-to-represent-a-byte-in-ansi-c89-90-c/437640#437640\">definition of the byte</a> is up to the implementation, e.g. <code>char</code> is byte, but byte size (<code>CHAR_BIT</code> macro) may be 16 bit.</br></br></p></li>\n<li><p>The actual size as defined by the implementation.<br>\nThis, as other answers have already pointed out, is dependent on the implementation: the compiler. And the compiler implementation, in turn, is heavily influenced by the target architecture. So it's plausible to have two compilers running on the same OS and architecture, but having different size of <code>int</code>. The only assumption you can make is the one stated by the standard (given that the compiler implements it).<br>\nThere also may be additional ABI requirements (e.g. fixed size of enums).</br></br></p></li>\n</ol>\n", "LastActivityDate": "2010-12-31T01:45:09.180"}, "4562705": {"ParentId": "4562249", "CommentCount": "2", "CreationDate": "2010-12-30T12:47:41.510", "OwnerUserId": "33213", "PostTypeId": "2", "Id": "4562705", "Score": "2", "Body": "<p>As I commented under @Nawaz's answer, it technically depends solely on the compiler.</p>\n<p>The compiler is just tasked with taking valid C++ code, and outputting valid machine code (or whatever language it targets).</p>\n<p>So a C++ compiler <em>could</em> decide to make an <code>int</code> have a size of 15, and require it to be aligned on 5-byte boundaries, and it <em>could</em> decide to insert arbitrary padding between the variables in a POD. Nothing in the standard prohibits this, and it could still generate working code.</p>\n<p>It'd just be much slower.</p>\n<p>So in practice, compilers take some hints from the system they're running on, in two ways:\n- the CPU has certain preferences: for example, it may have 32-bit wide registers, so making an <code>int</code> 32 bits wide would be a good idea, and it usually requires variables to be naturally aligned (a 4-byte wide variable must be aligned on an address divisible by 4, for example), so a <em>sensible</em> compiler respects these preferences because it yields faster code.\n- the OS may have some influence too, in that if it uses another ABI than the compiler, making system calls is going to be needlessly difficult. </p>\n<p>But those are just practical considerations to make life a bit easier for the programmer or to generate faster code. They're not <em>required</em>.</p>\n<p>The compiler has the final word, and it <em>can</em> choose to completely ignore both the CPU and the OS. As long as it generates a working executable with the semantics specified in the C++ standard.</p>\n", "LastActivityDate": "2010-12-30T12:47:41.510"}, "4562283": {"CommentCount": "21", "CreationDate": "2010-12-30T11:39:56.893", "CommunityOwnedDate": "2010-12-30T14:47:29.590", "LastEditorUserId": "415784", "LastActivityDate": "2011-01-05T10:52:04.960", "ParentId": "4562249", "PostTypeId": "2", "LastEditDate": "2011-01-05T10:52:04.960", "Id": "4562283", "Score": "6", "Body": "<p>First of all, it depends on Compiler. Compiler in turns usually depends on the architecture, processor, development environment etc because it takes them into account.  So you may say it's a combination of all. <strong>But I would NOT say that. I would say, Compiler</strong>, since on the same machine you may have different sizes of POD and <em>built-in</em> types, if you use different compilers. Also note that your source code is input to the compiler, so it's the compiler which makes <strong>final</strong> decision of the sizes of POD and built-in types. However, it's also true that this decision is influenced by the underlying architecture of the target machine. After all, the real <strong><em>useful</em></strong> compiler <strong>has to</strong> emit <em>efficient</em> code that eventually runs on the machine you target.</p>\n<p>Compilers provides <code>options</code> too. Few of them might effect sizes also!</p>\n<hr>\n<h1>EDIT:  What Standards say,</h1>\n<p><br/></p>\n<p>Size of <code>char</code>, <code>signed char</code> and <code>unsigned char</code> is defined by C++ Standard itself! Sizes of all other types are defined by the compiler.</p>\n<p>C++03 Standard $5.3.3/1 says,</p>\n<blockquote>\n<p id=\"so_4562249_4562283_0\">sizeof(char), sizeof(signed char) and\n  sizeof(unsigned char) are 1; the\n  result of sizeof applied to <strong>any other</strong>\n  fundamental type (3.9.1) is\n  implementation-defined. [Note: in\n  particular,sizeof(bool) and\n  sizeof(wchar_t) are\n  implementation-defined.69)</p>\n</blockquote>\n<p>C99 Standard ($6.5.3.4) also itself defines the size of <code>char</code>, <code>signed char</code> and <code>unsigned char</code> to be 1, but leaves the size of other types to be defined by the compiler!</p>\n<hr>\n<p>EDIT:</p>\n<p>I found this C++ FAQ chapter really good. The entire chapter. It's very tiny chapter though. :-)</p>\n<p><a href=\"http://www.parashift.com/c++-faq-lite/intrinsic-types.html\" rel=\"nofollow\">http://www.parashift.com/c++-faq-lite/intrinsic-types.html</a></p>\n<hr>\n<p>Also read the comments below, there are some good arguments!</p>\n</hr></hr></hr>", "OwnerUserId": "415784"}, "4562334": {"ParentId": "4562249", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2010-12-30T11:46:40.407", "Score": "0", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:30:40.063", "Id": "4562334", "OwnerUserId": "165520", "Body": "<p>It depends on the implementation (compiler).</p>\n<p><a href=\"https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior\"><code>Implementation-defined behavior</code></a> means unspecified behavior where each implementation documents how the choice is made.</p>\n", "LastActivityDate": "2010-12-30T11:46:40.407"}, "4562336": {"ParentId": "4562249", "CommentCount": "0", "CreationDate": "2010-12-30T11:47:19.700", "OwnerUserId": "214671", "PostTypeId": "2", "Id": "4562336", "Score": "2", "Body": "<p>If you're asking about the size of a <em>primitive</em> type like <code>int</code>, I'd say it depends on the factor you cited.</p>\n<p>The compiler/environment couple (where environment often means OS) is surely a part of it, since the compiler can map the various \"sensible\" sizes on the builtin types in different ways for various reasons: for example, compilers on x86_64 Windows will usually have a 32 bit <code>long</code> and a 64 bit <code>long long</code> to avoid breaking code thought for plain x86; on x86_64 Linux, instead, <code>long</code> is usually 64 bit because it's a more \"natural\" choice and apps developed for Linux are generally more architecture-neutral (because Linux runs on a much greater variety of architectures).</p>\n<p>The processor surely matters in the decision: <code>int</code> should be the \"natural size\" of the processor, usually the size of the general-purpose registers of the processor. This means that it's the type that will work faster on the current architecture. <code>long</code> instead is often thought as a type which trades performance for an extended range (this is rarely true on regular PCs, but on microcontrollers it's normal).</p>\n<p>If in instead you're also talking about <code>struct</code>s &amp; co. (which, if they respect some rules, <em>are</em> <code>POD</code>), again the compiler and the processor influence their size, since they are made of builtin types and of the appropriate padding chosen by the compiler to achieve the best performance on the target architecture.</p>\n", "LastActivityDate": "2010-12-30T11:47:19.700"}, "4562249": {"CommentCount": "3", "ViewCount": "8873", "PostTypeId": "1", "LastEditorUserId": "452307", "CreationDate": "2010-12-30T11:34:55.980", "LastActivityDate": "2011-01-05T10:52:04.960", "Title": "Size of Primitive data types", "FavoriteCount": "2", "LastEditDate": "2010-12-30T14:45:48.153", "Id": "4562249", "Score": "11", "Body": "<p>On what exactly does the size of a primitive data type like <code>int</code> depend on?   </p>\n<ul>\n<li>Compiler</li>\n<li>Processor</li>\n<li>Development Environment</li>\n</ul>\n<p>Or is it a combination of these or other factors?<br>\nAn explanation on the reason of the same will be really helpful.</br></p>\n<p>EDIT: Sorry for the confusion..I meant to ask about Primitive data type like int and not regarding PODs, I do understand PODs can include structure and with structure it is a whole different ball game with padding coming in to the picture.\nI have corrected the Q, the edit note here should ensure the answers regarding POD don't look irrelevant.</p>\n", "Tags": "<c++><c><sizeof>", "OwnerUserId": "452307", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_4562249_4562283_0": {"section_id": 6076, "quality": 0.7058823529411765, "length": 12}}, "n3337": {"so_4562249_4562283_0": {"section_id": 5844, "quality": 0.7058823529411765, "length": 12}}, "n4659": {"so_4562249_4562283_0": {"section_id": 7572, "quality": 0.7058823529411765, "length": 12}}}});