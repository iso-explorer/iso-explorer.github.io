post_cb({"26097083": {"Id": "26097083", "PostTypeId": "2", "Body": "<p>Here's a solution that doesn't fit all the criteria, along with analysis for\nwhy not. See <a href=\"https://stackoverflow.com/a/26584177/1505451\">the accepted answer</a> for a better answer.</p>\n<pre><code>// Define constants from the question.\nstatic constexpr int64_t kint64min = std::numeric_limits&lt;int64_t&gt;::min();\nstatic constexpr int64_t kint64max = std::numeric_limits&lt;int64_t&gt;::max();\n\nint64_t SafeCast(double d) {\n  // Handle NaN specially.\n  if (std::isnan(d)) return 0;\n\n  // Handle out of range below.\n  if (d &lt;= kint64min) return kint64min;\n\n  // Handle out of range above.\n  if (d &gt;= kint64max) return kint64max;\n\n  // At this point we know that d is in range.\n  return d;\n}\n</code></pre>\n<p>I believe this avoids undefined behavior. There is nothing to be wary of with\ncasting integers to doubles in the range checks. Assuming sanity in the way\nthat non-representable integers are converted (in particular that the mapping\nis monotonic), by the time the range checks are past, we can be sure that <code>d</code>\nis in <code>[-2^63, 2^63)</code>, as required for the implicit cast at the end of the\nfunction.</p>\n<p>I'm also confident that this clamps out of range values correctly.</p>\n<p>The issue is criteria #2 from the update to my question. Consider an\nimplementation where <code>kint64max</code> is not representable as a double, but\n<code>kint64max - 1</code> is. Further, assume that this is an implementation where\ncasting <code>kint64max</code> to a double yields the next lower representable value,\ni.e. <code>kint64max - 1</code>. Let <code>d</code> be 2^63 - 2 (i.e. <code>kint64max - 1</code>). Then\n<code>SafeCast(d)</code> is <code>kint64max</code>, because the range check converts <code>kint64max</code> to\na double, yielding a value equal to <code>d</code>. But <code>static_cast&lt;int64_t&gt;(d)</code> is\n<code>kint64max - 1</code>.</p>\n<p>Try as I might, I can't find a way to resolve this. Nor can I even write a\nunit test that checks my criteria, without the unit test executing undefined\nbehavior. I feel like there is a deeper lesson to be learned here\u2014something\nabout the impossibility of detecting whether an action in a system will cause\nundefined behavior from inside the system itself, without causing undefined\nbehavior.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-31T01:18:26.887", "Score": "1", "CreationDate": "2014-09-29T09:52:09.457", "ParentId": "25857843", "CommentCount": "1", "OwnerUserId": "1505451", "LastEditDate": "2017-05-23T10:27:45.283"}, "26086911": {"Id": "26086911", "PostTypeId": "2", "Body": "<p><code>boost::numeric_cast</code>, that's how.</p>\n<p><a href=\"http://www.boost.org/doc/libs/1_56_0/libs/numeric/conversion/doc/html/boost_numericconversion/improved_numeric_cast__.html\" rel=\"nofollow\">http://www.boost.org/doc/libs/1_56_0/libs/numeric/conversion/doc/html/boost_numericconversion/improved_numeric_cast__.html</a></p>\n", "LastActivityDate": "2014-09-28T16:16:46.043", "CommentCount": "4", "CreationDate": "2014-09-28T16:16:46.043", "ParentId": "25857843", "Score": "-1", "OwnerUserId": "749762"}, "bq_ids": {"n4140": {"so_25857843_25857843_0": {"length": 21, "quality": 0.84, "section_id": 37}, "so_25857843_25857843_1": {"length": 34, "quality": 0.9444444444444444, "section_id": 38}}, "n3337": {"so_25857843_25857843_0": {"length": 21, "quality": 0.84, "section_id": 34}, "so_25857843_25857843_1": {"length": 34, "quality": 0.9444444444444444, "section_id": 35}}, "n4659": {"so_25857843_25857843_0": {"length": 19, "quality": 0.76, "section_id": 37}, "so_25857843_25857843_1": {"length": 32, "quality": 0.8888888888888888, "section_id": 38}}}, "25858117": {"Id": "25858117", "PostTypeId": "2", "Body": "<p>How about:</p>\n<pre><code>constexpr uint64_t weird_high_limit = (double)kint64max == (double)(kint64max-1);\nint64_t clamped = (d &gt;= weird_high_limit + kint64max)? kint64max: (d &lt;= kint64min)? kint64min: int64_t(d);\n</code></pre>\n<p>I think this takes care of all the edge cases.  If <code>d &lt; (double)kint64max</code>, then <code>(exact)d &lt;= (exact)kint64max</code>.  Proof proceeds by contradiction of the fact that <code>(double)kint64max</code> is the next higher or lower representable value.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-09-15T23:19:51.557", "Score": "-1", "CreationDate": "2014-09-15T22:56:53.777", "ParentId": "25857843", "CommentCount": "6", "OwnerUserId": "103167", "LastEditDate": "2014-09-15T23:19:51.557"}, "25857843": {"ViewCount": "984", "Body": "<p>Let's say I've got a function that accepts a 64-bit integer, and I want to call\nit with a <code>double</code> with arbitrary numeric value (i.e. it may be very large in\nmagnitude, or even infinite):</p>\n<pre><code>void DoSomething(int64_t x);\n\ndouble d = [...];\nDoSomething(d);\n</code></pre>\n<p>Paragraph 1 of [conv.fpint] in the C++11 standard says this:</p>\n<blockquote>\n<p id=\"so_25857843_25857843_0\">A prvalue of a floating point type can be converted to a prvalue of an\n  integer type. The conversion trun- cates; that is, the fractional part\n  is discarded. The behavior is undefined if the truncated value cannot\n  be represented in the destination type.</p>\n</blockquote>\n<p>Therefore there are many values of <code>d</code> above that will cause undefined\nbehavior. I would like conversion to saturate, so that values greater than\n<code>std::numeric_limits&lt;int64_t&gt;::max()</code> (called <code>kint64max</code> below), including\ninfinity, become that value, and similarly with the minimum representable\nvalue. This seems the natural approach:</p>\n<pre><code>double clamped = std::min(d, static_cast&lt;double&gt;(kint64max));\nclamped = std::max(clamped, static_cast&lt;double&gt;(kint64min));\nDoSomething(clamped);\n</code></pre>\n<p>But, the next paragraph in the standard says this:</p>\n<blockquote>\n<p id=\"so_25857843_25857843_1\">A prvalue of an integer type or of an unscoped enumeration type can be\n  converted to a prvalue of a floating point type. The result is exact\n  if possible. If the value being converted is in the range of values\n  that can be represented but the value cannot be represented exactly,\n  it is an implementation-defined choice of either the next lower or\n  higher representable value.</p>\n</blockquote>\n<p>So <code>clamped</code> may still wind up being <code>kint64max + 1</code>, and behavior may still be\nundefined.</p>\n<p>What is the simplest portable way to do what I'm looking for? Bonus points if\nit also gracefully handles <code>NaN</code>s.</p>\n<p><strong>Update</strong>: To be more precise, I would like the following to all be true of an\n<code>int64_t SafeCast(double)</code> function that solves this problem:</p>\n<ol>\n<li><p>For any double <code>d</code>, calling <code>SafeCast(d)</code> does not perform undefined behavior\naccording to the standard, nor does it throw an exception or otherwise abort.</p></li>\n<li><p>For any double <code>d</code> in the range <code>[-2^63, 2^63)</code>,\n<code>SafeCast(d) == static_cast&lt;int64_t&gt;(d)</code>. That is, <code>SafeCast</code> agrees with C++'s\nconversion rules wherever the latter is defined.</p></li>\n<li><p>For any double <code>d &gt;= 2^63</code>, <code>SafeCast(d) == kint64max</code>.</p></li>\n<li><p>For any double <code>d &lt; -2^63</code>, <code>SafeCast(d) == kint64min</code>.</p></li>\n</ol>\n<p>I suspect the true difficulty here is in figuring out whether <code>d</code> is in the\nrange <code>[-2^63, 2^63)</code>. As discussed in the question and in comments to other\nanswers, I think using a cast of <code>kint64max</code> to <code>double</code> to test for the upper\nbound is a non-starter due to undefined behavior. It may be more promising to\nuse <code>std::pow(2, 63)</code>, but I don't know whether this is guaranteed to be exactly\n2^63.</p>\n", "AcceptedAnswerId": "26584177", "Title": "How do I convert an arbitrary double to an integer while avoiding undefined behavior?", "CreationDate": "2014-09-15T22:25:57.393", "Id": "25857843", "CommentCount": "8", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-09-16T21:08:29.293", "LastEditorUserId": "1505451", "LastActivityDate": "2015-07-20T09:38:08.520", "Score": "12", "OwnerUserId": "1505451", "Tags": "<c++><type-conversion><language-lawyer><undefined-behavior>", "AnswerCount": "4"}, "26584177": {"Id": "26584177", "PostTypeId": "2", "Body": "<p>It turns out this is simpler to do than I thought. Thanks to Michael O'Reilly\nfor the basic idea of this solution.</p>\n<p>The heart of the matter is figuring out whether the truncated double will be\nrepresentable as an <code>int64_t</code>. You can do this easily using <a href=\"http://en.cppreference.com/w/cpp/numeric/math/frexp\" rel=\"nofollow\"><code>std::frexp</code></a>:</p>\n<pre><code>#include &lt;cmath&gt;\n#include &lt;limits&gt;\n\nstatic constexpr int64_t kint64min = std::numeric_limits&lt;int64_t&gt;::min();\nstatic constexpr int64_t kint64max = std::numeric_limits&lt;int64_t&gt;::max();\n\nint64_t SafeCast(double d) {\n  // We must special-case NaN, for which the logic below doesn't work.\n  if (std::isnan(d)) {\n    return 0;\n  }\n\n  // Find that exponent exp such that\n  //     d == x * 2^exp\n  // for some x with abs(x) in [0.5, 1.0). Note that this implies that the\n  // magnitude of d is strictly less than 2^exp.\n  //\n  // If d is infinite, the call to std::frexp is legal but the contents of exp\n  // are unspecified.\n  int exp;\n  std::frexp(d, &amp;exp);\n\n  // If the magnitude of d is strictly less than 2^63, the truncated version\n  // of d is guaranteed to be representable. The only representable integer\n  // for which this is not the case is kint64min, but it is covered by the\n  // logic below.\n  if (std::isfinite(d) &amp;&amp; exp &lt;= 63) {\n    return d;\n  }\n\n  // Handle infinities and finite numbers with magnitude &gt;= 2^63.\n  return std::signbit(d) ? kint64min : kint64max;\n}\n</code></pre>\n", "LastEditorUserId": "410767", "LastActivityDate": "2015-05-12T03:40:48.023", "Score": "2", "CreationDate": "2014-10-27T09:09:21.827", "ParentId": "25857843", "CommentCount": "0", "OwnerUserId": "1505451", "LastEditDate": "2015-05-12T03:40:48.023"}});