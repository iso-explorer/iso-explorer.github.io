post_cb({"bq_ids": {"n4140": {"so_21900237_21900737_1": {"length": 11, "quality": 1.0, "section_id": 3286}, "so_21900237_21900237_0": {"length": 7, "quality": 0.7, "section_id": 3286}, "so_21900237_21900356_0": {"length": 11, "quality": 1.0, "section_id": 3286}, "so_21900237_21900737_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 3274}, "so_21900237_21901170_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 3286}}, "n3337": {"so_21900237_21900737_1": {"length": 11, "quality": 1.0, "section_id": 3156}, "so_21900237_21900737_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 3145}, "so_21900237_21900356_0": {"length": 11, "quality": 1.0, "section_id": 3156}, "so_21900237_21900237_0": {"length": 7, "quality": 0.7, "section_id": 3156}, "so_21900237_21901170_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 3156}}, "n4659": {"so_21900237_21900737_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 382}, "so_21900237_21900737_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 4032}, "so_21900237_21900356_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 382}, "so_21900237_21901170_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 382}}}, "21900737": {"Id": "21900737", "PostTypeId": "2", "Body": "<p>Note that you can turn your class easily into one which has a user-defined default constructor:</p>\n<pre><code>class A {\n  public:\n    A();\n\n  private:\n    int i = 1;\n};\n\ninline A::A() = default;\n</code></pre>\n<p>According to 8.4.2 [dcl.fct.def.default] paragraph 4:</p>\n<blockquote>\n<p id=\"so_21900237_21900737_0\">... A special member function is user-provided if it is user-declared and not explicitly\n  defaulted or deleted on its first declaration. ...</p>\n</blockquote>\n<p>This implicitly states that a function which is not explicitly defaulted on its first declaration is not user-provided. In combination with 8.5 [dcl.init] paragraph 6</p>\n<blockquote>\n<p id=\"so_21900237_21900737_1\">... If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type with a user-provided default constructor.</p>\n</blockquote>\n<p>it seems clear that you <em>cannot</em> use a default constructor defaulted on its first declaration to initialize a <code>const</code> object. However, you can use a defaulted definition if it isn't the first declaration as is done in the code above.</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2014-02-20T07:30:35.367", "Score": "22", "CreationDate": "2014-02-20T07:12:41.563", "ParentId": "21900237", "CommentCount": "5", "LastEditDate": "2014-02-20T07:30:35.367", "OwnerUserId": "1120273"}, "21900237": {"ViewCount": "2353", "Body": "<p>I have the code:</p>\n<pre><code>class A {\n  public:\n    A() = default;\n\n  private:\n    int i = 1;\n};\n\nint main() {\n  const A a;\n  return 0;\n}\n</code></pre>\n<p>It compiles fine on g++ (see <a href=\"http://ideone.com/PryGs5\" rel=\"noreferrer\">ideone</a>), but fails on clang++ with error:</p>\n<blockquote>\n<p id=\"so_21900237_21900237_0\">default initialization of an object of const type 'const A' requires a user-provided default constructor</p>\n</blockquote>\n<p>I reported this issue on <a href=\"http://llvm.org/bugs/show_bug.cgi?id=18882#c1\" rel=\"noreferrer\">LLVM bug-tracker</a> and got it INVALID.</p>\n<p>I see it absolutly pointless to try to convince the clang developers. On the other side, I don't see the reason for such restriction.</p>\n<hr>\n<p>Can anyone advise, if the C++11 Standard somehow implies this code to be invalid? Or should I just report a bug to g++? Or maybe there is enough freedom in language rules to handle this code in many ways?</p>\n</hr>", "AcceptedAnswerId": "21900356", "Title": "Do I really need to implement user-provided constructor for const objects?", "CreationDate": "2014-02-20T06:44:44.053", "Id": "21900237", "CommentCount": "8", "FavoriteCount": "7", "PostTypeId": "1", "LastActivityDate": "2014-02-20T08:54:40.767", "Score": "39", "OwnerUserId": "377393", "Tags": "<c++><c++11><constructor><const><language-lawyer>", "AnswerCount": "3"}, "21901170": {"Id": "21901170", "PostTypeId": "2", "Body": "<p><b>Edit:</b> The following is based on outdated information. I just went through N3797 and this is what I found:</p>\n<blockquote>\n<p id=\"so_21900237_21901170_0\">\u00a7 8.5/7 [dcl.init]<br>\n  If a program calls for the default initialization\n  of an object of a const-qualified type T, T shall be a class type with\n  a <b>user-provided default constructor.</b></br></p>\n</blockquote>\n<p>Note the standard quote in the link below says <b>user-declared</b>.</p>\n<hr/>\n<p>The following program compiles in g++ but not clang++:</p>\n<pre><code>struct A {};\n\nvoid f()\n{\n  A const a;\n}\n</code></pre>\n<p>And it might be related to this <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=42844\" rel=\"nofollow\">bug report</a> where it was \"fixed\". g++ fails to compile it once it contains data members unless they're initialized. Note that <code>int member = 1</code> will no longer make <code>A</code> a POD. Comparatively, clang++ rejects all permutations (empty classes and data members initialized or not.) For an interpretation of what the standard means by the following paragraph:</p>\n<blockquote>\n<p id=\"so_21900237_21901170_1\">\u00a7 8.5/9 [dcl.init] says:</p>\n<p id=\"so_21900237_21901170_2\">If no initializer is specified for an object, and the object is of\n  (possibly cv-qualified) non-POD class type (or array thereof), the\n  object shall be default-initialized; if the object is of\n  const-qualified type, the underlying class type shall have a\n  user-declared default constructor. Otherwise, if no initializer is\n  specified for an object, the object and its subobjects, if any, have\n  an indeterminate initial value; if the object or any of its subobjects\n  are of const-qualified type, the program is ill-formed.</p>\n</blockquote>\n<p>See <a href=\"https://stackoverflow.com/questions/7411515/why-does-c-require-a-user-provided-default-constructor-to-default-construct-a\">Why does C++ require a user-provided default constructor to default-construct a const object?</a>. Supposedly the program is ill-formed <code>if the object is of const-qualified POD type, and there is no initializer specified (because POD are not default initialized).</code> Note how g++ behaves for the following:</p>\n<pre><code>struct A {int a;};\nstruct B {int a = 1;};\nint main() \n{\n    A a;\n    B b;\n    const A c; // A is POD, error\n    const B d; // B is not POD, contains data member initializer, no error\n}\n</code></pre>\n", "LastEditorDisplayName": "user1508519", "OwnerDisplayName": "user1508519", "LastActivityDate": "2014-02-20T07:46:02.843", "Score": "4", "CreationDate": "2014-02-20T07:36:34.403", "ParentId": "21900237", "CommentCount": "1", "LastEditDate": "2014-02-20T07:46:02.843"}, "21900356": {"Id": "21900356", "PostTypeId": "2", "Body": "<p>N3797 \u00a78.5/7 says:</p>\n<blockquote>\n<p id=\"so_21900237_21900356_0\">If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type with a user-provided default constructor.</p>\n</blockquote>\n<p>There's no further example or explanation of this. I agree it seems pretty bizarre. Furthermore the rule was updated in C++11 to be more restrictive than it was in C++03, when class types needed <em>user-declared</em> constructors. (Your constructor is user-declared.)</p>\n<p>The workaround is be to ask for value initialization using <code>{}</code>, or use Dietmar's clever out-of-class <code>inline</code> definition.</p>\n<p>GCC does provide a diagnosis (and quite a nice one, referring to the newer C++11 requirements) if you add another member without an initializer.</p>\n<pre><code>  private:\n    int i = 1;\n    int j;\n</code></pre>\n<p>\u00a0</p>\n<pre><code>unmem.cpp:11:11: error: uninitialized const \u2018a\u2019 [-fpermissive]\n   const A a;\n           ^\nunmem.cpp:1:7: note: \u2018const class A\u2019 has no user-provided default constructor\n class A {\n       ^\nunmem.cpp:3:5: note: constructor is not user-provided because it is explicitly defaulted in the class body\n     A() = default;\n     ^\nunmem.cpp:7:9: note: and the implicitly-defined constructor does not initialize \u2018int A::j\u2019\n     int j;\n</code></pre>\n<p>The GCC <a href=\"http://gcc.gnu.org/viewcvs/gcc/branches/gcc-4_6-branch/gcc/cp/class.c?limit_changes=0&amp;r1=179170&amp;r2=179169&amp;pathrev=179170\">source</a> refers to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#253\">DR 253</a>, <em>Why must empty or fully-initialized const objects be initialized?</em> This is an open issue in the standard, last updated in August 2011 (post-C++11) with this note:</p>\n<blockquote>\n<p id=\"so_21900237_21900356_1\">If the implicit default constructor initializes all subobjects, no initializer should be required.</p>\n</blockquote>\n<p>Therefore whereas Clang complies with C++11 (and will comply as-is with C++14), GCC is implementing the latest thinking of the standardization committee.</p>\n<p>Filed a <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=60284\">GCC bug</a>. I predict that you'll need <code>-pedantic</code> to get a diagnosis when (and if) the bug is fixed.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2014-02-20T08:54:40.767", "Score": "23", "CreationDate": "2014-02-20T06:51:05.007", "ParentId": "21900237", "CommentCount": "7", "LastEditDate": "2014-02-20T08:54:40.767", "OwnerUserId": "153285"}});