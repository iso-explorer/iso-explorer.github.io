post_cb({"3682076": {"ParentId": "3682049", "PostTypeId": "2", "CommentCount": "15", "Body": "<p>\u00a713.1 where the Standard discusses about declarations that cannot be overloaded states -</p>\n<blockquote>\n<p id=\"so_3682049_3682076_0\"><strong>Parameter declarations that differ\n  only in the presence or absence of\n  const and/or volatile are equivalent.\n  That is, the const and volatile\n  type-specifiers for each parameter\n  type are ignored</strong> [...]</p>\n<p id=\"so_3682049_3682076_1\">Only the const and volatile\n  type-specifiers at the outermost level\n  of the parameter type specification\n  are ignored in this fashion; const and\n  volatile type-specifiers buried within\n  a parameter type specification are\n  significant and can be used to\n  distinguish overloaded function\n  declarations. [...]</p>\n<p id=\"so_3682049_3682076_2\">when determining which function is\n  being declared, defined, or called.\n  \"In particular, for any type T,\n  \u201cpointer to T,\u201d \u201cpointer to const T,\u201d\n  and \u201cpointer to volatile T\u201d are\n  considered distinct parameter types,\n  as are \u201creference to T,\u201d \u201creference to\n  const T,\u201d and \u201creference to volatile\n  T.\u201d</p>\n</blockquote>\n<p>EDIT 2:</p>\n<p>As the post is essentially the same as the <a href=\"https://stackoverflow.com/questions/3681188/why-does-a-function-declaration-with-a-const-argument-allow-calling-of-a-function\">reffered post</a>, except that the overloaded functions are now class member functions, I am trying to illustrate an additional aspect that could be useful to illustrate the concept of overloading which is not the same as overloading based on the 'constness' of the arguments (either in class scope or namespace scope). However the OP wanted to know how to differentiate the two overloads.</p>\n<p>A way to overload them successfully relies on the cv qualification of the implied first parameter in case of member function calls as shown. The 'const' member function can only be called when the object expression used to invoke the overloaded member function is also a const. When a non const object expression is used to invoke the overloaded member function call, the non const version is preferred as it is an exact match (the call to const member function overload will require cv qualification of the first implied argument)</p>\n<pre><code>#include &lt;iostream&gt; \nusing std::cout; \n\nclass Test { \n        public: \n        Test(){}\n        int foo (const int) const; \n        int foo (int ); \n}; \n\nint main () \n{ \n        Test obj;\n        Test const objc;  // const object\n        obj.foo(3);       // calls non const overload, object expression obj is non const\n        objc.foo(3);      // calls const overload, object expression objc is const\n} \n\nint Test::foo(int a) \n{ \n   a++; \n   return a; \n} \n\nint Test::foo (const int a) const\n{ \n   return a; \n} \n</code></pre>\n", "OwnerUserId": "418110", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:00:32.330", "Id": "3682076", "Score": "14", "CreationDate": "2010-09-10T03:26:19.593", "LastActivityDate": "2010-09-10T06:15:38.400"}, "3682049": {"CommentCount": "2", "ViewCount": "7551", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-09-10T03:16:53.240", "LastActivityDate": "2015-06-17T00:20:54.197", "Title": "Functions with const arguments and Overloading", "FavoriteCount": "5", "LastEditDate": "2017-05-23T12:00:32.330", "Id": "3682049", "Score": "4", "Body": "<p>Was tryin out <a href=\"https://stackoverflow.com/questions/3681188/why-does-a-function-declaration-with-a-const-argument-allow-calling-of-a-function\">the stackeroverflow qn</a> so it got me thinking why not overload the the function and I came up with a slightly different code but it says the function cannot be overloaded. My question is why? or is there a another way?</p>\n<pre><code> #include &lt;iostream&gt;\n using std::cout;\n\n class Test {\n         public:\n         Test(){ }\n         int foo (const int) const;\n         int foo (int );\n };\n\n int main ()\n {\n         Test obj;\n         Test const obj1;\n         int variable=0;\n     do{\n         obj.foo(3);        // Call the const function \n          obj.foo(variable); // Want to make it call the non const function \n         variable++;\n             usleep (2000000);\n        }while(1);\n }\n\n int Test::foo(int a)\n {\n    cout&lt;&lt;\"NON CONST\"&lt;&lt;std::endl;\n    a++;\n    return a;\n }\n\n int Test::foo (const int a) const\n {\n    cout&lt;&lt;\"CONST\"&lt;&lt;std::endl;\n    return a;\n }\n</code></pre>\n", "Tags": "<c++><class><const><overloading>", "OwnerUserId": "431434", "AnswerCount": "3"}, "3682098": {"ParentId": "3682049", "CommentCount": "0", "Body": "<p>As the answer to the other question explains, the two <code>foo</code>s do not differ because they have equivalent parameter definitions.</p>\n", "OwnerUserId": "10559", "PostTypeId": "2", "Id": "3682098", "Score": "1", "CreationDate": "2010-09-10T03:33:42.517", "LastActivityDate": "2010-09-10T03:33:42.517"}, "bq_ids": {"n4140": {"so_3682049_3682076_2": {"section_id": 558, "quality": 1.0, "length": 22}, "so_3682049_3682076_0": {"section_id": 558, "quality": 0.9411764705882353, "length": 16}, "so_3682049_3682076_1": {"section_id": 558, "quality": 0.96, "length": 24}}, "n3337": {"so_3682049_3682076_2": {"section_id": 549, "quality": 1.0, "length": 22}, "so_3682049_3682076_0": {"section_id": 549, "quality": 0.9411764705882353, "length": 16}, "so_3682049_3682076_1": {"section_id": 549, "quality": 0.96, "length": 24}}, "n4659": {"so_3682049_3682076_2": {"section_id": 581, "quality": 1.0, "length": 22}, "so_3682049_3682076_0": {"section_id": 581, "quality": 0.9411764705882353, "length": 16}, "so_3682049_3682076_1": {"section_id": 581, "quality": 0.96, "length": 24}}}, "3682081": {"ParentId": "3682049", "CommentCount": "5", "Body": "<p>You can't overload based only on the constness of a non pointer, non reference type. </p>\n<p>Think for instance if you were the compiler. \nFaced with the line:</p>\n<pre><code> cout &lt;&lt;obj.foo(3);\n</code></pre>\n<p>which function would you call?</p>\n<p>As you are passing by value the value gets copied either way. The const on the argument is only relevant to the function definition.</p>\n", "OwnerUserId": "366855", "PostTypeId": "2", "Id": "3682081", "Score": "19", "CreationDate": "2010-09-10T03:27:28.907", "LastActivityDate": "2010-09-10T03:27:28.907"}});