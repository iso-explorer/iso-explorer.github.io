post_cb({"37411089": {"ParentId": "37409590", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Your program has undefined behavior, because you are accessing an object's member outside the object and before the lifetime of the object commences.</p>\n<blockquote>\n<p id=\"so_37409590_37411089_0\"><a href=\"http://eel.is/c++draft/special#class.cdtor-1\" rel=\"nofollow\"><strong>$12.7: 1:</strong></a> For an object with a non-trivial constructor,\n  referring to any non-static member or base class of the object before\n  the constructor begins execution results in undefined behavior...</p>\n</blockquote>\n<p>As to why it compiles fine: A name can be used after its point of declaration ... And Quoting the C++ Standard draft... (emphasis mine):</p>\n<blockquote>\n<p id=\"so_37409590_37411089_1\"><a href=\"http://eel.is/c++draft/basic.scope.pdecl#1\" rel=\"nofollow\"><strong>$3.3.2 : 1:</strong></a> The point of declaration for a name is immediately\n  after its complete declarator (Clause <a href=\"http://eel.is/c++draft/dcl.decl\" rel=\"nofollow\">[dcl.decl]</a>) and <strong>before</strong> its\n  <a href=\"http://eel.is/c++draft/dcl.init#initializer\" rel=\"nofollow\"><em>initializer</em></a> (if any)...</p>\n</blockquote>\n<p>And <a href=\"http://eel.is/c++draft/dcl.init#initializer\" rel=\"nofollow\"><em>initalizer</em></a> is defined to have the syntax (reproduced here partially):</p>\n<blockquote>\n<p id=\"so_37409590_37411089_2\"><em>initializer</em>...</p>\n<pre><code>initializer:\n    brace-or-equal-initializer\n    ( expression-list )\n\nbrace-or-equal-initializer:\n    = initializer-clause\n    braced-init-list\n\ninitializer-clause:\n    assignment-expression\n    braced-init-list\n. . .\n</code></pre>\n</blockquote>\n<p>The above is the same reason why this will compile:</p>\n<pre><code>int k(k);\nint m{m};\nint b = b;\n</code></pre>\n", "OwnerUserId": "1621391", "LastEditorUserId": "1621391", "LastEditDate": "2016-06-05T18:52:55.467", "Id": "37411089", "Score": "2", "CreationDate": "2016-05-24T10:35:14.603", "LastActivityDate": "2016-06-05T18:52:55.467"}, "37409590": {"CommentCount": "7", "ViewCount": "71", "CreationDate": "2016-05-24T09:32:25.437", "LastActivityDate": "2016-06-05T19:19:07.987", "Title": "Is accessing a member of a struct in its own initializer undefined behaviour", "PostTypeId": "1", "Id": "37409590", "Score": "2", "Body": "<p>Consider:</p>\n<pre><code>struct A { void do_something() {} };\n\nstruct B {\n  A&amp; a;\n  B(A&amp; a) : a{a} { a.do_something(); }\n};\n\nstruct C {\n  A a; B b;\n  C(A&amp; a) : b{a} {}\n};\n\nint main() {\n  C c{ c.a };\n}\n</code></pre>\n<p>It seems possible that this <em>could</em> be made to work, because:</p>\n<ul>\n<li>even before <code>c</code> is initialized, we know its memory layout and the address of <code>c.a</code></li>\n<li>we don't actually <em>use</em> <code>c.a</code> until it is initialized.</li>\n</ul>\n<p>Additionally, I didn't get a warning under a few different compilers.</p>\n<p>However, I experienced some extremely odd behaviour (a bit later on) that could only be down to doing something undefined, and which only went away when I reorganised my program to avoid this pattern.</p>\n<p>Thanks.</p>\n", "Tags": "<c++><initialization>", "OwnerUserId": "4005238", "AnswerCount": "3"}, "37413516": {"ParentId": "37409590", "CommentCount": "3", "Body": "<p>C++ has a pretty well-defined order of construction. First (non-virtual) base classes are initialized. Members are initialized next, in order of their declaration in the class (and <strong>ignoring</strong> the order of the initializer list), and only after the last member has been initialized will the body of the constructor be entered.</p>\n<p>In this case, it means that the ctors are called in the order <code>A::A, B::B, C::C</code>.</p>\n<p>You <strong>would</strong> have an issue if C was declared as </p>\n<pre><code>struct C {\n  B b; A a; \n  C(A&amp; a) : b{a} {}\n};\n</code></pre>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "37413516", "Score": "0", "CreationDate": "2016-05-24T12:25:36.003", "LastActivityDate": "2016-05-24T12:25:36.003"}, "37412700": {"ParentId": "37409590", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>In addition to my previous answer, </p>\n<hr>\n<p>Your code is a crafty one... Because, despite the <em>supposed</em> UB with using an object before its initialized, the behaviour of your code is <em>apparently</em> well defined..</p>\n<p>How?\nIn the construction of <code>c</code>, the following sequence of events will happen:</p>\n<ol>\n<li><p>You call <code>C</code>'s constructor, <code>C(A&amp; a) : b{a} {}</code> which takes a reference to an object of type <code>A</code>. (A reference is just like an address, and as you rightly mentioned, the address of <code>c.a</code> is known at compile time). Your call is: <code>C c{ c.a };</code> and the compiler is fine with that since <code>c.a</code> is an accessible name</p></li>\n<li><p>Due to the order of declaration of <code>C</code>'s members...</p>\n<pre><code>struct C {\n  A a; B b;\n  C(A&amp; a) : b{a} {}\n};\n</code></pre>\n<p>the object <code>a</code> is initialized before <code>b</code>.</p></li>\n<li><p>Thus, <code>a</code> becomes alive before its use in the member initializer... <code>b{a}</code></p></li>\n</ol>\n<hr>\n<p>But again, you can be smoked by <a href=\"https://stackoverflow.com/questions/15718262/what-exactly-is-the-as-if-rule\">optimizers</a>...</p>\n</hr></hr>", "OwnerUserId": "1621391", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:58:46.867", "Id": "37412700", "Score": "2", "CreationDate": "2016-05-24T11:49:04.150", "LastActivityDate": "2016-06-05T19:19:07.987"}, "bq_ids": {"n4140": {"so_37409590_37411089_1": {"section_id": 7049, "quality": 0.7333333333333333, "length": 11}, "so_37409590_37411089_0": {"section_id": 444, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_37409590_37411089_1": {"section_id": 6794, "quality": 0.7333333333333333, "length": 11}, "so_37409590_37411089_0": {"section_id": 435, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_37409590_37411089_1": {"section_id": 8546, "quality": 0.7333333333333333, "length": 11}, "so_37409590_37411089_0": {"section_id": 467, "quality": 0.8888888888888888, "length": 16}}}});