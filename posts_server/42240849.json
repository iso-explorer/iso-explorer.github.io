post_cb({"bq_ids": {"n4140": {"so_42240849_42241015_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 336}, "so_42240849_42241015_1": {"length": 10, "quality": 1.0, "section_id": 335}, "so_42240849_42241015_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 5964}, "so_42240849_42241026_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 335}, "so_42240849_42241026_2": {"length": 14, "quality": 1.0, "section_id": 336}}, "n3337": {"so_42240849_42241015_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 326}, "so_42240849_42241015_1": {"length": 10, "quality": 1.0, "section_id": 325}, "so_42240849_42241026_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 325}, "so_42240849_42241026_2": {"length": 14, "quality": 1.0, "section_id": 326}}, "n4659": {"so_42240849_42241015_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 7453}, "so_42240849_42241015_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 345}, "so_42240849_42241026_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 344}, "so_42240849_42241026_2": {"length": 14, "quality": 1.0, "section_id": 345}, "so_42240849_42241015_1": {"length": 10, "quality": 1.0, "section_id": 344}}}, "42241015": {"Id": "42241015", "PostTypeId": "2", "Body": "<p>The compilers are correct to reject your code, it is indeed not valid C++14.</p>\n<p>In the standard (using N4141 here) we have</p>\n<blockquote>\n<p id=\"so_42240849_42241015_0\">For a generic lambda, the closure type has a public inline function call\n  operator member template (14.5.2) whose template-parameter-list consists of one invented type template-\n  parameter for each occurrence of auto in the lambda\u2019s parameter-declaration-clause, in order of appearance.</p>\n</blockquote>\n<p>(5.1.2/4 [expr.prim.lambda]). So your call is equivalent to a call to some</p>\n<pre><code>template &lt;class T1, class T2&gt;\nauto operator() (T1 x, T2 y = std::decay_t&lt;decltype(x)&gt;{});\n</code></pre>\n<p>Now</p>\n<blockquote>\n<p id=\"so_42240849_42241015_1\">If a template parameter is used only in non-deduced\n  contexts and is not explicitly specified, template argument deduction fails.</p>\n</blockquote>\n<p>(14.8.2/4 [temp.deduct.type]) and</p>\n<blockquote>\n<p id=\"so_42240849_42241015_2\">The non-deduced contexts are:<br>\n  [...]<br>\n      - A template parameter used in the parameter type of a function parameter that has a default argument\n  that is being used in the call for which argument deduction is being done.</br></br></p>\n</blockquote>\n<p>(14.8.2/5 [temp.deduct.type]) makes your call ill-formed.</p>\n", "LastEditorUserId": "3002139", "LastActivityDate": "2017-02-15T05:14:21.727", "Score": "8", "CreationDate": "2017-02-15T04:54:44.547", "ParentId": "42240849", "CommentCount": "1", "OwnerUserId": "3002139", "LastEditDate": "2017-02-15T05:14:21.727"}, "42241026": {"Id": "42241026", "PostTypeId": "2", "Body": "<p>I can't quote the spec, but I will quote cppreference which is an authoritative source and is often easier to read/follow. In particular, see <a href=\"http://en.cppreference.com/w/cpp/language/template_argument_deduction\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/template_argument_deduction</a>.</p>\n<blockquote>\n<p id=\"so_42240849_42241026_0\">Non-deduced contexts</p>\n<p id=\"so_42240849_42241026_1\">In the following cases, the types, templates, and non-type values that are used to compose P do not participate in template argument deduction...</p>\n</blockquote>\n<p>You probably are already aware that template parameters cannot always be deduced. Going down the list of entries, we see:</p>\n<blockquote>\n<p id=\"so_42240849_42241026_2\">4) A template parameter used in the parameter type of a function parameter that has a default argument that is being used in the call for which argument deduction is being done:</p>\n</blockquote>\n<p>Which gives the following example:</p>\n<pre><code>template&lt;typename T, typename F&gt;\nvoid f(const std::vector&lt;T&gt;&amp; v, const F&amp; comp = std::less&lt;T&gt;());\nstd::vector&lt;std::string&gt; v(3);\nf(v);\n</code></pre>\n<p>variadic lambdas are basically equivalent to function templates with a type template parameter substituted for each usage of auto, so this example (which does not compile) is equivalent to your example.</p>\n<p>So basically, the second type cannot be deduced because it is a non-deduced context.</p>\n<p>This answer could probably be improved by giving a very good example of why exactly it's been decided to make this a non-deduced context, since naively it seems like it's possible. My guess is that this is basically because a function template is just that, a template for creating function. Defaulted arguments in turn, essentially create multiple callable signatures for the same function. So you can't really deal with defaulting, until you have a function, but you can't have a function until you instantiate, which requires knowing the template parameters.</p>\n<p>It's instructive to note that this simpler example has the same issues:</p>\n<pre><code>template&lt;typename T, typename F&gt;\nvoid f(const std::vector&lt;T&gt;&amp; v, const F&amp; comp = int{});\n</code></pre>\n<p>So the dependence on the first template parameter actually has nothing to do with the issue.</p>\n", "LastActivityDate": "2017-02-15T04:56:05.147", "CommentCount": "1", "CreationDate": "2017-02-15T04:56:05.147", "ParentId": "42240849", "Score": "3", "OwnerUserId": "1908347"}, "42240849": {"ViewCount": "140", "Body": "<p>Is this not valid as C++14? </p>\n<pre><code>auto f = [](auto x, auto y = std::decay_t&lt;decltype(x)&gt;{}) { };\nf(0);\n</code></pre>\n<p>I was expecting it to be roughly equivalent to</p>\n<pre><code>auto f = [](int x, int y) { };\nf(0, int{});\n</code></pre>\n<p>Neither GCC 6.3 nor Clang 4.0 accepted my code.</p>\n<ul>\n<li><a href=\"http://ideone.com/b7b4SK\" rel=\"nofollow noreferrer\">http://ideone.com/b7b4SK</a> GCC</li>\n<li><a href=\"http://ideone.com/EyLYaL\" rel=\"nofollow noreferrer\">http://ideone.com/EyLYaL</a> Clang</li>\n</ul>\n<p>Is it related to my lack of understanding of C++ template deduction phases? Does the 1400 pages long spec actually has an explicit answer to my question?</p>\n<h2>Update</h2>\n<p>To summarize, my problem can in fact be reduced to this piece of code (free of lambda, single parameter) and it is invalid under C++14 (thanks @BaummitAugen and @NirFriedman)</p>\n<pre><code>template &lt;typename T&gt;\nvoid f(T x = 0) { }\n\nint main() {\n    f();\n}\n</code></pre>\n", "AcceptedAnswerId": "42241015", "Title": "C++14 lambda's default argument type deduction depending on preceding arguments", "CreationDate": "2017-02-15T04:38:24.263", "Id": "42240849", "CommentCount": "3", "LastEditDate": "2017-02-15T06:34:07.480", "PostTypeId": "1", "LastEditorUserId": "1190965", "LastActivityDate": "2017-02-15T06:34:07.480", "Score": "3", "OwnerUserId": "1190965", "Tags": "<c++><lambda><c++14><language-lawyer><default-parameters>", "AnswerCount": "2"}});