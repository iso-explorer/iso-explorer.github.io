post_cb({"27970833": {"Id": "27970833", "PostTypeId": "2", "Body": "<p>The <em>cv-qualifier</em> in return types is ignored only of the very first level, so <code>int const foo()</code> equals <code>int foo()</code> but <code>int const &amp;foo()</code> does not equal <code>int &amp;foo()</code>.</p>\n<p>In your case, your function <code>char *const InString()</code> is equivalent to <code>char *InString()</code>.</p>\n<p>And about the binding of the <code>char *&amp;&amp;str = InString(arr)</code>. The return of the function is a r-value (a temporary), and <code>str</code> is an r-value reference, so this is expected. Of course, the lifetime of the temporary is extended to the scope of the reference.</p>\n<p>BTW, your code, compiled with <code>-Wextra</code> gives in CLang++:</p>\n<blockquote>\n<p id=\"so_27970737_27970833_0\">warning: 'const' type qualifier on return type has no effect [-Wignored-qualifiers]</p>\n</blockquote>\n<p>And in G++:</p>\n<blockquote>\n<p id=\"so_27970737_27970833_1\">warning: type qualifiers ignored on function return type [-Wignored-qualifiers]</p>\n</blockquote>\n", "LastActivityDate": "2015-01-15T18:52:50.527", "Score": "1", "CreationDate": "2015-01-15T18:52:50.527", "ParentId": "27970737", "CommentCount": "5", "OwnerUserId": "865874"}, "bq_ids": {"n4140": {"so_27970737_27970833_0": {"length": 5, "quality": 0.625, "section_id": 5965}, "so_27970737_27971064_0": {"length": 14, "quality": 1.0, "section_id": 5939}, "so_27970737_27970833_1": {"length": 5, "quality": 0.625, "section_id": 641}}, "n3337": {"so_27970737_27970833_1": {"length": 5, "quality": 0.625, "section_id": 631}}, "n4659": {"so_27970737_27971064_0": {"length": 14, "quality": 1.0, "section_id": 7423}, "so_27970737_27970833_1": {"length": 5, "quality": 0.625, "section_id": 669}}}, "27971064": {"Id": "27971064", "PostTypeId": "2", "Body": "<p>After considering the quote mentioned by @dyp, which is [expr]/6:</p>\n<blockquote>\n<p id=\"so_27970737_27971064_0\">If a prvalue initially has the type \u201c<em>cv</em> <code>T</code>,\u201d where <code>T</code> is a\n  cv-unqualified non-class, non-array type, <strong>the type of\n       the expression is adjusted to <code>T</code> prior to any further analysis</strong>.</p>\n</blockquote>\n<p>The conclusion is rather simple: As the expression <code>InString(..)</code> is a prvalue, the type of <code>InString(..)</code> (which is the initializer of the reference) is simply adjusted to <code>char*</code>, which is clearly reference compatible to the target type of the reference (also <code>char*</code>). In other words, the <code>const</code> you added is simply ignored when determining the <strong>type of the function call expression</strong> (but it is <strong>not</strong> ignored when looking at the <strong>function type</strong> itself!).</p>\n<p>However, for scalar prvalues, references never bind <em>directly</em> to the initializer expression, but a temporary is initialized and the reference bound to it:</p>\n<pre><code>int&amp;&amp; i = 4; // Temporary initialized with 4 and bound to i\n\nint const f();\nint&amp;&amp; ref = f(); // Initializer expression has type int - same as above\n</code></pre>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-18T11:38:03.890", "Score": "8", "CreationDate": "2015-01-15T19:06:42.300", "ParentId": "27970737", "CommentCount": "10", "LastEditDate": "2016-03-18T11:38:03.890", "OwnerUserId": "3647361"}, "27970737": {"ViewCount": "156", "Body": "<p>At least in 'Clang' &amp; 'GCC'. Here is an example:</p>\n<pre><code>char *const InString(char *const p) {\n\n    return gets(p);\n}\n\nint main()\n{\n    static char arr[260];\n\n    char * &amp;&amp;str = InString(arr); //compiles without error - what??????\n}\n</code></pre>\n<p>As most of you probably knows in the second line of '<code>main'</code> we are bounding the return-value temporary ('prvalue') into an <strong>'rvalue reference'</strong>  thus extending its life time. So my question is what is happening here - is 'cv' for return-values really ignored and if so where in the standard this is written or else how <code>'char *const &amp;&amp;'</code> is converted to <code>'char * &amp;&amp;'</code>?</p>\n<p>*Need ISO C++ standard qualification.</p>\n<p>EDIT: The thing is that before 'C++ 11' you weren't allowed to modify the return-value whatsoever because 'rvalues' weren't introduced and also because something like:</p>\n<pre><code>InString(arr) = nullptr;\n</code></pre>\n<p>Was meaningless. However now you can extend the 'return-value' life-time and so modifying it becomes possible:</p>\n<pre><code>auto &amp;&amp;refRetVal = InString(arr);\n\nrefRetVal = nullptr;\n</code></pre>\n<p>From this it comes that the 'const' return 'cv' can be useful. If the return-type of 'InString' above is 'constant' then the second assignment to 'nullptr' will be illegal.</p>\n", "AcceptedAnswerId": "27971064", "Title": "Why return-type 'cv' is ignored?", "CreationDate": "2015-01-15T18:46:49.937", "Id": "27970737", "CommentCount": "4", "LastEditDate": "2016-03-18T11:23:35.720", "PostTypeId": "1", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-18T11:38:03.890", "Score": "3", "OwnerUserId": "4031604", "Tags": "<c++><c++11><const><language-lawyer><return-type>", "AnswerCount": "2"}});