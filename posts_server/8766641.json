post_cb({"8766753": {"ParentId": "8766641", "CommentCount": "0", "CreationDate": "2012-01-07T02:09:33.790", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "8766753", "Score": "3", "Body": "<p>This code is indeed clearly supposed to limit the input to 11 characters (the 12th character is used for the terminating null character). The standard clearly states in 27.7.2.2.3 [istream::extractors] paragraphs 7 and 8:</p>\n<blockquote>\n<p id=\"so_8766641_8766753_0\">... If width() is greater than zero, n is width(). ... Characters are extracted and stored until any of the following occurs: - n-1 characters are stored; ...</p>\n</blockquote>\n<p>I also tried it with gcc which clearly only reads 11 characters. I don't know what the best work-around for this problem is. Typically, I don't run into problems like this because I simple read <code>std::string</code> objects which can grow as big as they want. Well, there is some huge limit as well and I have never tried what happens when this would get exceeded. If you <strong>absolutely</strong> need to read into a <code>char</code> array you could do two things:</p>\n<ol>\n<li>you can create an adapter for <code>char</code> arrays and define a suitable input operator yourself</li>\n<li>you could create a filtering stream buffer which is temporarily installed and which limits the number of characters or pretends it read a space character.</li>\n</ol>\n<p>Below is an example on how to do the latter. The technique for creating the adapter can actually be used to set the width automatically based on the array's size.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cctype&gt;\n\nstruct adaptor\n{\n    template &lt;int Size&gt;\n    adaptor(char (&amp;array)[Size]): it(array), end(array + Size - 1) {}\n    mutable char*  it, * end;\n};\n\nstd::istream&amp; operator&gt;&gt; (std::istream&amp; in, adaptor const&amp; value)\n{\n    std::istreambuf_iterator&lt;char&gt; it(in), end;\n    if (it == end)\n    {\n        in.setstate(std::ios_base::failbit);\n    }\n    for (; it != end &amp;&amp; value.it != value.end &amp;&amp; !std::isspace(static_cast&lt;unsigned char&gt;(*it));\n         ++it, ++value.it)\n    {\n        *value.it = *it;\n    }\n    *value.it = 0;\n    return in;\n}\n\nint main()\n{\n    char buffer[12];\n    if (std::cin &gt;&gt; adaptor(buffer))\n        std::cout &lt;&lt; \"read='\" &lt;&lt; buffer &lt;&lt; \"'\\n\";\n    else\n        std::cout &lt;&lt; \"input failed\\n\";\n}\n</code></pre>\n", "LastActivityDate": "2012-01-07T02:09:33.790"}, "8766641": {"CommentCount": "8", "AcceptedAnswerId": "8766753", "ClosedDate": "2012-01-07T17:37:38.873", "CreationDate": "2012-01-07T01:43:16.630", "LastActivityDate": "2012-01-07T02:09:33.790", "PostTypeId": "1", "ViewCount": "3361", "Title": "Using cin in C++ with Width() to avoid buffer overflow", "Id": "8766641", "Score": "2", "Body": "<p>Here is an easy question.  I wrote this C++ code:</p>\n<pre><code>    char chaine[12];\n    cin.width(12);\n    cin &gt;&gt; chaine;\n</code></pre>\n<p>But if I enter some text longuer than 12 characters at runtime, visual studio inform me that the stack is now corrupted.</p>\n<p>I understand that the problem is a buffer overflow. But I thought that the \"width\" method would protect against this.   </p>\n<p>Could someone explain to me what is the function of the width method if it does not protect against the buffer overflow? I searched online but i did not find anything.</p>\n<p>Thanks!</p>\n", "Tags": "<c++><file><io><buffer-overflow>", "OwnerUserId": "661773", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_8766641_8766753_0": {"section_id": 1855, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_8766641_8766753_0": {"section_id": 1849, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_8766641_8766753_0": {"section_id": 2028, "quality": 0.7692307692307693, "length": 10}}}});