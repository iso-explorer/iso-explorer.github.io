post_cb({"34531620": {"ViewCount": "121", "Body": "<p>I have code written to create a linked list of dynamically created objects:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct X {\n  int i;\n  X* x;\n};\n\nvoid birth(X* head, int quant){\n  X* x = head;\n  for(int i=0;i&lt;quant-1;i++){\n    x-&gt;i = i+1;\n    x-&gt;x = new X;\n    x = x-&gt;x;\n  }\n  x-&gt;i = quant;\n  x-&gt;x = 0;\n}\n\nvoid kill(X* x){\n  X* next;\n  while(1==1){\n    cout &lt;&lt; x-&gt;i &lt;&lt; endl;\n    cout &lt;&lt; (long)x &lt;&lt; endl;\n    next = x-&gt;x;\n    delete x;\n    if(next == 0){\n      break;\n    } else {\n      x = next;\n    }\n  }\n}\n\nint main(){\n  cout &lt;&lt; (long)sizeof(X) &lt;&lt; endl;\n  X* x = new X;\n  birth(x, 10);\n  kill(x);\n  return 0;\n}\n</code></pre>\n<p>Which seems to be working, except for the fact that when you look at the addresses of each of the objects...</p>\n<pre><code>16\n1\n38768656\n2\n38768688\n3\n38768720\n4\n38768752\n5\n38768784\n6\n38768816\n7\n38768848\n8\n38768880\n9\n38768912\n10\n38768944\n</code></pre>\n<p>They seem to be created 32 bits apart despite the size of X being only 16 bits. Is there an issue with how I am creating the objects, or is this just a consequence of how dynamic allocation works?</p>\n", "Title": "Why are dynamically created objects twice as many bits apart as the object's size?", "CreationDate": "2015-12-30T14:42:10.857", "LastActivityDate": "2015-12-30T15:40:19.037", "CommentCount": "7", "LastEditDate": "2015-12-30T14:50:32.333", "PostTypeId": "1", "LastEditorUserId": "645128", "Id": "34531620", "Score": "3", "OwnerUserId": "5731015", "Tags": "<c++><heap-memory>", "AnswerCount": "4"}, "34532119": {"PostTypeId": "2", "Body": "<p>You are working in an environment with 8 bytes of allocation overhead and minimum dynamic memory alignment of 16 bytes.  So each 16 byte allocation has 8 bytes of allocation overhead and 8 bytes of alignment padding.  </p>\n<p>If you try again with a 24 byte object (making sure <code>sizeof</code> really is 24 not 32) you will find only 8 bytes of overhead and not an additional 8 bytes of alignment padding.  </p>\n<p>There is a minimum size (including overhead) of 32 bytes.  So if you try with a tiny object, you get a total of 32, not 16.  If you try with a 40 byte object, you get a total of 48 demonstrating the lack of 32 byte alignment.  </p>\n<p>That is all specific to the environment in which you are running.  The C++ standard allows for a much wider range of possible behavior.</p>\n<p>The 8 bytes immediately preceding the 16-byte aligned chunk returned by the allocator must hold the size of the allocation plus at least one status bit indicating whether the <strong>previous</strong> chunk is free.  That is the minimum overhead a 64-bit allocator needs and while the chunk is in use it is all the overhead needed.  But once a chunk is free, there is significant overhead at the beginning of the chunk to support consolidating adjacent free chunks and to support quickly finding a good size free chunk for new allocations.  That overhead wouldn't fit if the total were just 16 bytes.</p>\n", "LastActivityDate": "2015-12-30T15:40:19.037", "LastEditorUserId": "5089383", "Id": "34532119", "CommentCount": "0", "CreationDate": "2015-12-30T15:14:48.053", "ParentId": "34531620", "Score": "1", "OwnerUserId": "5089383", "LastEditDate": "2015-12-30T15:40:19.037"}, "bq_ids": {"n4140": {"so_34531620_34531811_0": {"length": 21, "quality": 0.5675675675675675, "section_id": 7177}}, "n3337": {"so_34531620_34531811_0": {"length": 21, "quality": 0.5675675675675675, "section_id": 6921}}}, "34531813": {"PostTypeId": "2", "Body": "<p>Addresses of allocated memory blocks are controlled by the heap manager. Only the heap manager's interface is defined (<code>new</code>/<code>delete</code>, <code>malloc</code>/<code>free</code>), not its implementation. The application has to accept the provided addresses and work with them.</p>\n<p>In other words, it is theoretically possible to implement a heap manager that allocates memory blocks at random-like addresses. The application, however, has to work equally well also in this case.</p>\n", "LastActivityDate": "2015-12-30T14:55:56.540", "Id": "34531813", "CommentCount": "0", "CreationDate": "2015-12-30T14:55:56.540", "ParentId": "34531620", "Score": "3", "OwnerUserId": "1881196"}, "34531811": {"PostTypeId": "2", "Body": "<p>The reason is stated in <strong>7.22.3 Memory management functions</strong> of the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\">C Standard</a>:</p>\n<blockquote>\n<p id=\"so_34531620_34531811_0\">The order and contiguity of storage allocated by successive calls to\n  the <code>aligned_alloc</code>, <code>calloc</code>, <code>malloc</code>,  and <code>realloc</code> functions is\n  unspecified.   The pointer returned if the allocation succeeds is\n  suitably aligned so that it may be assigned to a pointer to any type\n  of object with a fundamental alignment requirement and then used to\n  access such an object or an array of such objects in the space\n  allocated</p>\n</blockquote>\n<p>Since the memory must be \"suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental alignment requirement\", memory returned by <code>malloc</code> <em>et al</em> tends to start on distinct, platform-dependent multiples - usually 8- or 16-byte boundaries.</p>\n<p>And because <code>new</code> is usually implemented with <code>malloc</code>, this applies to C++ <code>new</code> also.</p>\n", "LastActivityDate": "2015-12-30T14:55:48.773", "Id": "34531811", "CommentCount": "2", "CreationDate": "2015-12-30T14:55:48.773", "ParentId": "34531620", "Score": "7", "OwnerUserId": "4756299"}, "34531837": {"PostTypeId": "2", "Body": "<p>The <a href=\"http://en.cppreference.com/w/cpp/memory/new/operator_new\" rel=\"nofollow\"><code>new</code> operator</a> does not guarantee contiguous allocation. Here is a more convincing example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    for (int i = 0 ; i &lt; 32 ; ++i)\n        std::cout &lt;&lt; std::hex &lt;&lt; new int() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output on a 64bit CPU:</p>\n<pre><code>0x22cac20\n0x22cac40\n0x22cac60\n0x22cac80\n...\n0x22cafe0\n0x22cb000\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/6fe96d5c1f6383ca\" rel=\"nofollow\">Demo</a></kbd></p>\n", "LastActivityDate": "2015-12-30T14:57:09.647", "Id": "34531837", "CommentCount": "8", "CreationDate": "2015-12-30T14:57:09.647", "ParentId": "34531620", "Score": "2", "OwnerUserId": "5470596"}});