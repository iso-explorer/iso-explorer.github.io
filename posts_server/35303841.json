post_cb({"bq_ids": {"n4140": {"so_35303841_35304967_1": {"length": 39, "quality": 1.0, "section_id": 223}}, "n3337": {"so_35303841_35304967_1": {"length": 39, "quality": 1.0, "section_id": 216}}, "n4659": {"so_35303841_35304967_1": {"length": 39, "quality": 1.0, "section_id": 231}}}, "35304967": {"Id": "35304967", "PostTypeId": "2", "Body": "<p>I'd guess that the following portion of C++14 standard is at work here</p>\n<blockquote>\n<p id=\"so_35303841_35304967_0\"><strong>14.6.4.1 Point of instantiation</strong></p>\n<p id=\"so_35303841_35304967_1\"><strong>8</strong> A specialization for a function template, a member function template, or of a member function or static data member of a class\n  template may have multiple points of instantiations within a\n  translation unit, and in addition to the points of instantiation\n  described above, <strong>for any such specialization that has a point of\n  instantiation within the translation unit, the end of the translation\n  unit is also considered a point of instantiation</strong>. [...]</p>\n</blockquote>\n<p>(Emphasis mine.)</p>\n<p>Note that this portion of document was changed significantly in C++14 compared to C++11. Also see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#993\" rel=\"nofollow\">DR#993</a>, which seems to imply that simply postponing such instantiations to the end of translation unit is a valid implementation technique.</p>\n<p>I would go as far as cautiously state that your code is ill-formed under C++11 instantiation rules, even though GCC accepts it in <code>-std=c++11</code> mode.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2016-02-10T01:04:06.323", "Score": "4", "CreationDate": "2016-02-10T00:45:07.457", "ParentId": "35303841", "CommentCount": "8", "OwnerUserId": "187690", "LastEditDate": "2016-02-10T01:04:06.323"}, "35304735": {"Id": "35304735", "PostTypeId": "2", "Body": "<p>Yes, this is legal C++ code. You declare <code>MyC</code> as forward declaration, and the definition is in the same scope later. And because the C++ compiler uses at least 2 passes to parse the source files, this is correct and will generate correct machine code. Your \"incomplete\" type <code>MyC</code> is not incomplete.</p>\n", "LastActivityDate": "2016-02-10T00:20:00.720", "CommentCount": "2", "CreationDate": "2016-02-10T00:20:00.720", "ParentId": "35303841", "Score": "-1", "OwnerUserId": "5817031"}, "35303841": {"ViewCount": "140", "Body": "<p>Is the following (in)correct c++ code and why?</p>\n<pre><code>class MyC;\nclass MyB {\npublic:\n     template &lt;class MyT&gt; static void Gimme() { MyT(); }\n     MyB() { Gimme&lt;MyC&gt;(); }\n} B_;\n\nclass MyC  {\npublic: MyC() { }\n};\n</code></pre>\n<p>g++ 4.7.2 does not complain.</p>\n", "AcceptedAnswerId": "35304967", "Title": "Function template instantiation using an incomplete type", "CreationDate": "2016-02-09T22:57:25.190", "Id": "35303841", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-02-10T09:13:34.720", "LastEditorUserId": "4326278", "LastActivityDate": "2016-02-10T09:13:34.720", "Score": "3", "OwnerUserId": "2447844", "Tags": "<c++><templates><language-lawyer><incomplete-type>", "AnswerCount": "2"}});