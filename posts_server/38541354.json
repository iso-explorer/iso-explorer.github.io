post_cb({"38541830": {"Id": "38541830", "PostTypeId": "2", "Body": "<p>N4140 (roughly C++14) says:</p>\n<blockquote>\n<p id=\"so_38541354_38541830_0\"><strong>5.1.2 Lambda expressions [expr.prim.lambda]</strong></p>\n<p id=\"so_38541354_38541830_1\">20 The closure type associated with a <em>lambda-expression</em> has a deleted (8.4.3) default constructor and a deleted copy assignment operator. It has an implicitly-declared copy constructor (12.8) and may have an implicitly-declared move constructor (12.8). [ <em>Note:</em> The copy/move constructor is implicitly defined in the same way as any other implicitly declared copy/move constructor would be implicitly defined. <em>-- end note</em> ]</p>\n</blockquote>\n<p>Note that this doesn't mention whether the deleted copy assignment operator is implicitly declared. The compiler turns the lambda into a class definition and instantiation, but that class can be cleverly defined in a way where the copy assignment operator is implicitly declared, but some other property of the class leads to that implicit copy assignment operator being deleted.</p>\n<p>Then:</p>\n<blockquote>\n<p id=\"so_38541354_38541830_2\"><strong>12.8 Copying and moving class objects [class.copy]</strong></p>\n<p id=\"so_38541354_38541830_3\">20 If the definition of a class <code>X</code> does not explicitly declare a move assignment operator, one will be implicitly declared as defaulted if and only if</p>\n<p id=\"so_38541354_38541830_4\">(20.1) -- <code>X</code> does not have a user-declared copy constructor,</p>\n<p id=\"so_38541354_38541830_5\">(20.2) -- <code>X</code> does not have a user-declared move constructor,</p>\n<p id=\"so_38541354_38541830_6\">(20.3) -- <code>X</code> does not have a user-declared copy assignment operator, and</p>\n<p id=\"so_38541354_38541830_7\">(20.4) -- <code>X</code> does not have a user-declared destructor.</p>\n</blockquote>\n<p>If the lambda's copy assignment operator is implicitly declared, it doesn't inhibit the generation of a move assignment operator. If it is explicitly declared, the move assignment operator is suppressed.</p>\n<p>Both behaviours are defensible based on the literal wording of the standard.</p>\n<p>This was partially addressed by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1891\" rel=\"nofollow\">CWG issue 1891</a>, which changed the text to:</p>\n<blockquote>\n<p id=\"so_38541354_38541830_8\">The closure type associated with a <em>lambda-expression</em> has no default constructor and a deleted copy assignment operator. It has a defaulted copy constructor and a defaulted move constructor (12.8 [class.copy]). [<em>Note:</em> These special member functions are implicitly defined as usual, and might therefore be defined as deleted. <em>-- end note</em>]</p>\n</blockquote>\n<p>However, despite the move assignment operator being raised as a concern in that issue, it doesn't change the answer, it continues to leave open the possibility.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2016-07-23T12:44:29.217", "Score": "4", "CreationDate": "2016-07-23T12:33:18.963", "ParentId": "38541354", "CommentCount": "0", "OwnerUserId": "743382", "LastEditDate": "2016-07-23T12:44:29.217"}, "bq_ids": {"n4140": {"so_38541354_38541830_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 458}, "so_38541354_38541830_8": {"length": 17, "quality": 0.5151515151515151, "section_id": 5979}, "so_38541354_38541830_3": {"length": 13, "quality": 1.0, "section_id": 469}, "so_38541354_38541830_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 458}, "so_38541354_38541830_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 458}, "so_38541354_38541830_7": {"length": 4, "quality": 0.8, "section_id": 458}, "so_38541354_38541830_1": {"length": 33, "quality": 0.8048780487804879, "section_id": 5979}}, "n3337": {"so_38541354_38541830_1": {"length": 33, "quality": 0.8048780487804879, "section_id": 5747}, "so_38541354_38541830_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 449}, "so_38541354_38541830_3": {"length": 13, "quality": 1.0, "section_id": 460}, "so_38541354_38541830_8": {"length": 17, "quality": 0.5151515151515151, "section_id": 5747}, "so_38541354_38541830_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 449}, "so_38541354_38541830_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 449}, "so_38541354_38541830_7": {"length": 4, "quality": 0.8, "section_id": 449}}, "n4659": {"so_38541354_38541830_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 481}, "so_38541354_38541830_8": {"length": 26, "quality": 0.7878787878787878, "section_id": 7461}, "so_38541354_38541830_3": {"length": 13, "quality": 1.0, "section_id": 492}, "so_38541354_38541830_6": {"length": 6, "quality": 0.8571428571428571, "section_id": 481}, "so_38541354_38541830_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 481}, "so_38541354_38541830_7": {"length": 4, "quality": 0.8, "section_id": 481}}}, "38541354": {"ViewCount": "121", "Body": "<p>I have this program:</p>\n<pre><code>int main()\n{\n  auto l([](){});\n\n  ::std::cout &lt;&lt; ::std::is_move_assignable&lt;decltype(l)&gt;{} &lt;&lt; ::std::endl;\n}\n</code></pre>\n<p>gcc-6.1.1 displays 0</p>\n<p>clang-3.8.0 displays 1</p>\n<p>This is causing a compile error in my program. Which of the compilers is right?</p>\n<p>The error:</p>\n<pre><code>error: object of type '(lambda at t.cpp:5:5)' cannot be assigned because its copy assignment operator is implicitly deleted\n</code></pre>\n<p>But this is not relevant to my question.</p>\n", "Title": "move assignable lambdas in clang and gcc", "CreationDate": "2016-07-23T11:38:46.567", "LastActivityDate": "2016-07-23T12:44:29.217", "CommentCount": "1", "LastEditDate": "2016-07-23T12:05:31.260", "PostTypeId": "1", "LastEditorUserId": "6394138", "Id": "38541354", "Score": "3", "OwnerUserId": "1095108", "Tags": "<c++><gcc><lambda><clang><c++1z>", "AnswerCount": "2"}, "38541628": {"Id": "38541628", "PostTypeId": "2", "Body": "<p>A lambda <em>with an empty capture list</em> is defined to be assignable to a function pointer type, so if your actual code has that type of lambda function too, you could just use a function pointer.</p>\n", "LastActivityDate": "2016-07-23T12:08:44.257", "CommentCount": "2", "CreationDate": "2016-07-23T12:08:44.257", "ParentId": "38541354", "Score": "-1", "OwnerUserId": "5711725"}});