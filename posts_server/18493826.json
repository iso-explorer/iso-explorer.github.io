post_cb({"18516246": {"ParentId": "18493826", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2013-08-29T16:25:23.990", "Score": "7", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:24:58.850", "Id": "18516246", "OwnerUserId": "420683", "Body": "<p>This problem is a result of an issue with the point of declaration (1) combined with dependent name lookup (2).</p>\n<p><strong>(1)</strong> In the declaration</p>\n<pre><code>template&lt;typename T&gt;\nconstexpr auto RemoveLinks(const Link&lt;T&gt;&amp; link) -&gt; decltype(RemoveLinks(link.val))\n</code></pre>\n<p>the name <code>RemoveLinks</code>, or more precisely, this overload of <code>RemoveLinks</code>, is only visible <em>after the complete declarator</em> according to [basic.scope.pdecl]/1. The <em>trailing-return-type</em> is part of the declarator as per [dcl.decl]/4. Also see <a href=\"https://stackoverflow.com/a/3744745/420683\">this answer</a>.</p>\n<p><strong>(2)</strong> In the expression <code>RemoveLinks(link.val)</code>, the name <code>RemoveLinks</code> is dependent as per [temp.dep]/1, as <code>link.val</code> is dependent.</p>\n<p>If we now look up how dependent names are resolved, we find [temp.dep.res]:</p>\n<blockquote>\n<p id=\"so_18493826_18516246_0\">In resolving dependent names, names from the following sources are considered:</p>\n<ul>\n<li>Declarations that are visible at the point of definition of the template.</li>\n<li>Declarations from namespaces associated with the types of the function arguments both from the instantiation context and from the definition context.</li>\n</ul>\n</blockquote>\n<p>The first bullet doesn't find the second overload of <code>RemoveLinks</code> because of the point of declaration (1). The second one doesn't find the overload because the namespace <code>Util</code> is not associated with any argument. This is why putting everything in the global namespace or in the namespace <code>Util</code> works as expected (<a href=\"http://coliru.stacked-crooked.com/view?id=f8c8d16751ad067c061c28b22a0c4afd-25dabfc2c190f5ef027f31d968947336\" rel=\"nofollow noreferrer\">Live example</a>).</p>\n<p>For the same reason, using a <em>qualified-id</em> in the <em>trailing-return-type</em> (like <code>-&gt; decltype(Util::RemoveLinks(link.val))</code> doesn't help here.</p>\n", "LastActivityDate": "2013-08-29T16:44:25.233"}, "18493826": {"CommentCount": "7", "ViewCount": "1009", "PostTypeId": "1", "LastEditorUserId": "1023390", "CreationDate": "2013-08-28T16:51:24.900", "LastActivityDate": "2013-08-29T16:44:25.233", "Title": "Template functions in namespace cause errors", "FavoriteCount": "3", "LastEditDate": "2013-08-28T17:46:10.603", "Id": "18493826", "Score": "8", "Body": "<p>Assume the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nstruct Link\n{\n    Link(T&amp;&amp; val) : val(std::forward&lt;T&gt;(val)) {}\n\n    T val;\n};\n\ntemplate&lt;typename T&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Link&lt;T&gt;&amp; link)\n{\n    out &lt;&lt; \"Link(\" &lt;&lt; link.val &lt;&lt; \")\";\n    return out;\n}\n\ntemplate&lt;typename T&gt;\nauto MakeLink(T&amp;&amp; val) -&gt; Link&lt;T&gt;\n{\n    return {std::forward&lt;T&gt;(val)};\n}\n\nnamespace Utils {\ntemplate&lt;typename Any&gt;\nconstexpr auto RemoveLinks(const Any&amp; any) -&gt; const Any&amp;\n{\n    return any;\n}\n\ntemplate&lt;typename T&gt;\nconstexpr auto RemoveLinks(const Link&lt;T&gt;&amp; link) -&gt; decltype(RemoveLinks(link.val))\n{\n    return RemoveLinks(link.val);\n}\n\n} /* Utils */\n\nint main()\n{\n    int k = 10;\n\n    auto link = MakeLink(MakeLink(k));\n\n    std::cout &lt;&lt; link &lt;&lt; std::endl;\n    std::cout &lt;&lt; Utils::RemoveLinks(link) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>For some reason I can't understand, it generates the following compilation errors with <code>g++-4.8</code>:</p>\n<pre><code>/home/allan/Codes/expr.cpp: In instantiation of \u2018constexpr decltype (Utils::RemoveLinks(link.val)) Utils::RemoveLinks(const Link&lt;T&gt;&amp;) [with T = int&amp;; decltype (Utils::RemoveLinks(link.val)) = const int&amp;]\u2019:\n/home/allan/Codes/expr.cpp:88:32:   required from \u2018constexpr decltype (Utils::RemoveLinks(link.val)) Utils::RemoveLinks(const Link&lt;T&gt;&amp;) [with T = Link&lt;int&amp;&gt;; decltype (Utils::RemoveLinks(link.val)) = const int&amp;]\u2019\n/home/allan/Codes/expr.cpp:100:41:   required from here\n/home/allan/Codes/expr.cpp:88:32: error: invalid initialization of reference of type \u2018const Link&lt;int&amp;&gt;&amp;\u2019 from expression of type \u2018const int\u2019\n     return RemoveLinks(link.val);\n                                ^\n/home/allan/Codes/expr.cpp:89:1: error: body of constexpr function \u2018constexpr decltype (Utils::RemoveLinks(link.val)) Utils::RemoveLinks(const Link&lt;T&gt;&amp;) [with T = int&amp;; decltype (Utils::RemoveLinks(link.val)) = const Link&lt;int&amp;&gt;&amp;]\u2019 not a return-statement\n }\n ^\n/home/allan/Codes/expr.cpp: In function \u2018constexpr decltype (Utils::RemoveLinks(link.val)) Utils::RemoveLinks(const Link&lt;T&gt;&amp;) [with T = int&amp;; decltype (Utils::RemoveLinks(link.val)) = const int&amp;]\u2019:\n/home/allan/Codes/expr.cpp:89:1: warning: control reaches end of non-void function [-Wreturn-type]\n }\n ^\n</code></pre>\n<p>while clang 3.3 gives:</p>\n<pre><code>test.cc:34:12: error: reference to type 'const Link&lt;int &amp;&gt;' could not bind to an lvalue of type 'const int'\nreturn RemoveLinks(link.val);\n       ^~~~~~~~~~~~~~~~~~~~~\ntest.cc:46:25: note: in instantiation of function template specialization 'Utils::RemoveLinks&lt;Link&lt;int &amp;&gt; &gt;' requested here\nstd::cout &lt;&lt; Utils::RemoveLinks(link) &lt;&lt; std::endl;\n</code></pre>\n<p>If, however, the namespace <code>Utils</code> is removed, then it compiles without errors (both gcc and clang), and execution outputs:</p>\n<pre><code>Link(Link(10))\n10\n</code></pre>\n<p>Why defining those template functions (<code>RemoveLinks</code>) in a namespace causes such errors?</p>\n", "Tags": "<c++><templates><c++11><namespaces><metaprogramming>", "OwnerUserId": "418875", "AnswerCount": "2"}, "18512966": {"ParentId": "18493826", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2013-08-29T13:55:18.003", "Score": "2", "LastEditorUserId": "1524457", "LastEditDate": "2013-08-29T15:05:37.150", "Id": "18512966", "OwnerUserId": "1524457", "Body": "<p>I tried compiling the sample code above with GCC 4.8.1, with clang and also Intel icpc and got the same error messages as you.</p>\n<p>I am able to get it to successfully compile without trouble if I revise the signature of the template specialization from:</p>\n<pre><code>template&lt;typename T&gt;\nconstexpr auto RemoveLinks(const Link&lt;T&gt;&amp; link) -&gt; decltype(RemoveLinks(link.val))\n</code></pre>\n<p>and make the return type as const.  This might cause a compiler warning since the const there is meaningless, but that can be ignored.  I tested it and it works fine for me with gcc, but not icpc or clang:</p>\n<pre><code>template&lt;typename T&gt;\nconstexpr auto RemoveLinks(const Link&lt;T&gt;&amp; link) -&gt; decltype(RemoveLinks(link.val)) const\n</code></pre>\n<p>I found the error message (with the original code) from Intel icpc to be the most informative:</p>\n<p>code.cc(48): error: template instantiation resulted in unexpected function type of \"<code>auto (const Link&lt;Link&lt;int &amp;&gt;&gt; &amp;)-&gt;const int &amp;</code>\" (the meaning of a name may have changed since the template declaration -- the type of the template is \"<code>auto (const Link&lt;T&gt; &amp;)-&gt;decltype((&lt;expression&gt;))</code>\")\n<code>std::cout &lt;&lt; Utils::RemoveLinks(link) &lt;&lt; std::endl;</code>\n                                                ^\n          detected during instantiation of \"Utils::RemoveLinks\" based on template argument <code>&lt;Link&lt;int &amp;&gt;&gt;</code> at line 48</p>\n<p>Unfortunately, the above answer is more of a workaround for gcc rather than an answer to your question.  I'll update this if I have anything more / better to add.</p>\n<p><strong>EDIT</strong></p>\n<p>It appears that decltype(RemoveLinks(link.val)) is actually following the recursion so that it returns int&amp; rather than Link.  </p>\n<p><strong>EDIT #2</strong></p>\n<p>There have been reported bugs in LLVM about crashes caused by decltype recursion problems.  It seems that this is definitely a bug of sorts, but one that seems to be present in multiple implementations of C++.</p>\n<p>The problem can be fixed quite easily if you create a an alias for type T in the link struct and have decltype refer to the alias rather than to the return type.  This will eliminate the recursion.  As follows:</p>\n<pre><code>template&lt;typename T&gt;\nstruct Link\n{\n    Link(T&amp;&amp; val) : val(std::forward&lt;T&gt;(val)) {}\n    using value_type = T;\n    T val;\n};\n</code></pre>\n<p>And then the RemoveLinks signature is changed accordingly to refer to this alias:</p>\n<pre><code>template&lt;typename T&gt;\nconstexpr auto RemoveLinks(const Link&lt;T&gt;&amp; link) -&gt; decltype(links.value_type)\n</code></pre>\n<p>This code successfully builds on all 3 compilers.</p>\n<p>I will file some bug reports with the compilers to see if there's anything they can do about it.</p>\n<p>Hope this helps.</p>\n", "LastActivityDate": "2013-08-29T15:05:37.150"}, "bq_ids": {"n4140": {"so_18493826_18516246_0": {"section_id": 215, "quality": 1.0, "length": 6}}, "n3337": {"so_18493826_18516246_0": {"section_id": 209, "quality": 1.0, "length": 6}}, "n4659": {"so_18493826_18516246_0": {"section_id": 223, "quality": 1.0, "length": 6}}}});