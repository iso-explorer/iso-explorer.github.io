post_cb({"4708444": {"CommentCount": "1", "AcceptedAnswerId": "4708477", "CreationDate": "2011-01-16T22:15:19.713", "LastActivityDate": "2014-12-15T16:13:01.743", "PostTypeId": "1", "ViewCount": "958", "FavoriteCount": "0", "Title": "Is there a good way to convert from unsigned char* to char*?", "Id": "4708444", "Score": "1", "Body": "<p>I've been reading a lot those days about <code>reinterpret_cast&lt;&gt;</code> and how on should use it (and avoid it on most cases).</p>\n<p>While I understand that using <code>reinterpret_cast&lt;&gt;</code> to cast from, say <code>unsigned char*</code> to <code>char*</code> is <em>implementation defined</em> (and thus <em>non-portable</em>) it seems to be no other way for <em>efficiently</em> convert one to the other.</p>\n<p>Lets say I use a library that deals with <code>unsigned char*</code> to process some computations. Internaly, I already use <code>char*</code> to store my data (And I can't change it because it would kill puppies if I did).</p>\n<p>I would have done something like:</p>\n<pre><code>char* mydata = getMyDataSomewhere();\nsize_t mydatalen = getMyDataLength();\n\n// We use it here\n// processData() takes a unsigned char*\nvoid processData(reinterpret_cast&lt;unsigned char*&gt;(mydata), mydatalen);\n\n// I could have done this:\nvoid processData((unsigned char*)mydata, mydatalen);\n// But it would have resulted in a similar call I guess ?\n</code></pre>\n<p>If I want my code to be highly portable, it seems I have no other choice than copying my data first. Something like:</p>\n<pre><code>char* mydata = getMyDataSomewhere();\nsize_t mydatalen = getMyDataLength();\nunsigned char* mydata_copy = new unsigned char[mydatalen];\nfor (size_t i = 0; i &lt; mydatalen; ++i)\n  mydata_copy[i] = static_cast&lt;unsigned char&gt;(mydata[i]);\n\nvoid processData(mydata_copy, mydatalen);\n</code></pre>\n<p>Of course, that is highly suboptimal and I'm not even sure that it is more portable than the first solution.</p>\n<p>So the question is, what would you do in this situation to have a highly-portable code ?</p>\n", "Tags": "<c++><casting><reinterpret-cast>", "OwnerUserId": "279259", "AnswerCount": "4"}, "4711198": {"ParentId": "4708444", "CommentCount": "0", "Body": "<p>For C compatibility, the <code>unsigned char*</code> and <code>char*</code> types have extra limitations. The rationale is that functions like <code>memcpy()</code> have to work, and this limits the freedom that compilers have. <code>(unsigned char*) &amp;foo</code> must still point to object foo. Therefore, don't worry in this specific case. </p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "4711198", "Score": "1", "CreationDate": "2011-01-17T08:21:29.397", "LastActivityDate": "2011-01-17T08:21:29.397"}, "4709195": {"ParentId": "4708444", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The difference between char and an unsigned char types is merely data semantics. This only affects how the compiler performs arithmetic on data elements of either type. The char type signals the compiler that the value of the high bit is to be interpreted as negative, so that the compiler should perform twos-complement arithmetic. Since this is the only difference between the two types, I cannot imagine a scenario where <code>reinterpret_cast &lt;unsigned char*&gt; (mydata)</code> would generate output any different than <code>(unsigned char*) mydata</code>. Moreover, there is no reason to copy the data if you are merely informing the compiler about a change in data sematics, i.e., switching from signed to unsigned arithmetic.</p>\n<p><strong>EDIT:</strong> While the above is true from a practical standpoint, I should note that the C++ standard states that char, unsigned char and sign char are three distinct data types. \u00a7 3.9.1.1:</p>\n<blockquote>\n<p id=\"so_4708444_4709195_0\">Objects declared as characters (char) shall be large enough to store\n  any member of the implementation\u2019s basic character set. If a character\n  from this set is stored in a character object, the integral value of\n  that character object is equal to the value of the single character\n  literal form of that character. It is implementation-defined whether a\n  char object can hold negative values. Characters can be explicitly\n  declared unsigned or signed. Plain char, signed char, and unsigned\n  char are three distinct types, collectively called narrow character\n  types. A char, a signed char, and an unsigned char occupy the same\n  amount of storage and have the same alignment requirements (3.11);\n  that is, they have the same object representation. For narrow\n  character types, all bits of the object representation participate in\n  the value representation. For unsigned narrow character types, all\n  possible bit patterns of the value representation represent numbers.\n  These requirements do not hold for other types. In any particular\n  implementation, a plain char object can take on either the same values\n  as a signed char or an unsigned char; which one is\n  implementation-defined.</p>\n</blockquote>\n", "OwnerUserId": "540815", "LastEditorUserId": "540815", "LastEditDate": "2014-12-15T16:13:01.743", "Id": "4709195", "Score": "2", "CreationDate": "2011-01-17T01:03:01.240", "LastActivityDate": "2014-12-15T16:13:01.743"}, "4708477": {"ParentId": "4708444", "CommentCount": "0", "Body": "<p>Portable is an in-practice matter. As such, <code>reinterpret_cast</code> for the specific usage of converting between <code>char*</code> and <code>unsigned char*</code> is portable. But still I'd wrap this usage in a pair of functions instead of doing the <code>reinterpret_cast</code> directly each place.</p>\n<p>Don't go overboard introducing inefficiencies when using a language where nearly all the warts (including the one about limited guarantees for <code>reinterpret_cast</code>) are in support of efficiency.</p>\n<p>That would be working against the spirit of the language, while adhering to the letter.</p>\n<p>Cheers &amp; hth.</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "4708477", "Score": "6", "CreationDate": "2011-01-16T22:19:35.443", "LastActivityDate": "2011-01-16T22:19:35.443"}, "4709264": {"ParentId": "4708444", "CommentCount": "1", "Body": "<p>Go with the cast, it's OK in practice.</p>\n<p>I just want to add that this:</p>\n<pre><code>for (size_t i = 0; i &lt; mydatalen; ++i)\n  mydata_copy[i] = static_cast&lt;unsigned char&gt;(mydata[i]);\n</code></pre>\n<p>while not being undefined behaviour, could change the contents of your string on machines without 2-complement arithmetic. The reverse would be undefined behaviour.</p>\n", "OwnerUserId": "51831", "PostTypeId": "2", "Id": "4709264", "Score": "1", "CreationDate": "2011-01-17T01:21:27.097", "LastActivityDate": "2011-01-17T01:21:27.097"}, "bq_ids": {"n4140": {"so_4708444_4709195_0": {"section_id": 7210, "quality": 0.9416666666666667, "length": 113}}, "n3337": {"so_4708444_4709195_0": {"section_id": 6954, "quality": 0.8916666666666667, "length": 107}}, "n4659": {"so_4708444_4709195_0": {"section_id": 8719, "quality": 0.9, "length": 108}}}});