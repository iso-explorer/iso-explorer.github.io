post_cb({"41353091": {"ParentId": "41331640", "CommentCount": "0", "Body": "<p>Universal references are the special context where a template parameter can be deduced as a reference type. Suppose we have</p>\n<pre><code>template &lt;typename T&gt; auto f(T &amp;&amp;) -&gt; T;\nint i;\nint g(int);\n</code></pre>\n<p><code>f(i)</code> deduces <code>T</code> as <code>int &amp;</code> to form <code>auto f&lt;int &amp;&gt;(int &amp;) -&gt; int &amp;</code>.<br>\n<code>f(std::move(i))</code> deduces <code>T</code> as <code>int</code> to form <code>auto f&lt;int&gt;(int &amp;&amp;) -&gt; int</code>.</br></p>\n<p>The rules for when this happens are given as:</p>\n<blockquote>\n<p id=\"so_41331640_41353091_0\"><strong>14.8.2.1 Deducing template arguments from a function call [temp.deduct.call]</strong></p>\n<p id=\"so_41331640_41353091_1\">3 [...] If <code>P</code> is an rvalue reference to a cv-unqualified template parameter and the argument is an lvalue, the type \"lvalue reference to <code>A</code>\" is used in place of <code>A</code> for type deduction. [...]</p>\n</blockquote>\n<p>The question is, when calling <code>f(g)</code>, is <code>g</code> an lvalue?</p>\n<p>Does it even make sense to ask the question? If <code>T</code> is a function type, then <code>T &amp;</code> and <code>T &amp;&amp;</code> can both be used to create references to named functions, without any need for <code>std::move</code>. The lvalue/rvalue distinction doesn't exist for functions.</p>\n<p>Arbitrarily, the C++ standard says that yes, <code>g</code> is an lvalue. Expressions of function type are never rvalues (whether xvalues or prvalues). It's possible to produce types that are rvalue references to function types, but even then, the expressions formed by them are lvalues. There are more explicit statements elsewhere in the standard, but they follow from:</p>\n<blockquote>\n<p id=\"so_41331640_41353091_2\"><strong>3.10 Lvalues and rvalues [basic.lval]</strong></p>\n<p id=\"so_41331640_41353091_3\">(1.1) -- An <em>lvalue</em> [...] designates a function or an object. [...]</p>\n<p id=\"so_41331640_41353091_4\">(1.2) -- An <em>xvalue</em> [...] also refers to an object, [...]</p>\n<p id=\"so_41331640_41353091_5\">(1.4) -- An <em>rvalue</em> [...] is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated with an object.</p>\n</blockquote>\n<p>(Note: <code>g</code> is not a \"value\" either, so that last part doesn't apply. \"Value\" is defined in [basic.types]p4 and applies to trivially copyable types, which function types are not.)</p>\n<p>Since <code>g</code> is an lvalue, <code>T</code> should be deduced as <code>int(&amp;)(int)</code>, and this is a bug in VC++. Quite a subtle one though.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "41353091", "Score": "2", "CreationDate": "2016-12-27T22:41:18.027", "LastActivityDate": "2016-12-27T22:41:18.027"}, "bq_ids": {"n4140": {"so_41331640_41353091_0": {"section_id": 282, "quality": 0.5714285714285714, "length": 4}, "so_41331640_41353091_1": {"section_id": 304, "quality": 1.0, "length": 13}, "so_41331640_41353091_5": {"section_id": 7230, "quality": 0.9, "length": 9}}, "n3337": {"so_41331640_41353091_3": {"section_id": 5947, "quality": 1.0, "length": 4}, "so_41331640_41353091_0": {"section_id": 273, "quality": 0.5714285714285714, "length": 4}, "so_41331640_41353091_1": {"section_id": 295, "quality": 1.0, "length": 13}, "so_41331640_41353091_5": {"section_id": 6974, "quality": 0.9, "length": 9}}, "n4659": {"so_41331640_41353091_0": {"section_id": 289, "quality": 0.5714285714285714, "length": 4}, "so_41331640_41353091_1": {"section_id": 311, "quality": 1.0, "length": 13}}}, "41331640": {"CommentCount": "3", "ViewCount": "69", "PostTypeId": "1", "LastEditorUserId": "445296", "CreationDate": "2016-12-26T12:55:26.943", "LastActivityDate": "2016-12-27T22:41:18.027", "Title": "VC++ Bug with Decltype and Universal Reference or Undefined Behavior?", "AcceptedAnswerId": "41353091", "LastEditDate": "2016-12-27T22:05:07.920", "Id": "41331640", "Score": "0", "Body": "<p>I have this code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\nusing namespace std;\ntemplate&lt;typename T&gt;\nT f2(T&amp;&amp;t) {\n    return t;\n}\nint rr(int i) {\n    return 40*i;\n}\nint main()\n{\n  cout &lt;&lt; is_function&lt; remove_reference&lt;decltype(f2(rr))&gt;::type&gt;::value &lt;&lt; endl;\n}\n</code></pre>\n<p>When compiled with VC++2015, i got this error:</p>\n<pre><code>error C2893: Failed to specialize function template 'T f2(T &amp;&amp;)'\n</code></pre>\n<p>The main issue is with using <code>decltype()</code> on the expression <code>f2(rr)</code>. Note that <code>f2</code>'s parameter is <code>T&amp;&amp;</code>.  This is called <strong>Universal Reference</strong> by Scott Meyers: <a href=\"https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers\" rel=\"nofollow noreferrer\">universal reference</a>.  I am expecting <code>f2(rr)</code> yields an expression whose type is a function reference.  In GCC, it runs normally and returns true, and hence, confirms that <code>f2(rr)</code> is a function reference. </p>\n<p>Is this simply a bug with VC++2015 rather than undefined behavior when the univeral reference is used with a function name?</p>\n<p>EDIT: This works correctly in VC++2015:</p>\n<pre><code>int main()\n{\n  cout &lt;&lt; f2(rr)(10) &lt;&lt;endl;\n}\n</code></pre>\n<p>result:</p>\n<pre><code>400\n</code></pre>\n", "Tags": "<c++><c++11><decltype><compiler-bug>", "OwnerUserId": "237575", "AnswerCount": "1"}});