post_cb({"28532535": {"CommentCount": "8", "ViewCount": "122", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-02-15T23:34:43.803", "LastActivityDate": "2015-02-16T02:47:05.750", "Title": "Defending against the danger of function name hiding class name", "FavoriteCount": "2", "LastEditDate": "2017-05-23T11:50:58.750", "Id": "28532535", "Score": "5", "Body": "<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n#include \"other_library.h\"\n\nstruct Foo\n{\n    Foo() { cout &lt;&lt; \"class\\n\"; }\n};\n\nint main()\n{\n    Foo();  // or Foo() in any expression\n}\n</code></pre>\n<p>This outputs <code>class</code>, or so we would think. The problem is that if <code>other_library.h</code> happens to have a function called <code>Foo</code> whose return type is suitable to appear in whatever expression we used <code>Foo</code> in then it silently changes the behaviour, e.g.:</p>\n<pre><code>int Foo() { cout &lt;&lt; \"func\\n\"; return 1; }\n</code></pre>\n<p>causes <code>func</code> to be output without any code changing in <code>main</code>.  This is bad because of the possibility for insidious and hard-to-detect bugs ; even if it is not malicious intent on the part of <code>other_library</code>, a name clash could go undetected.</p>\n<hr>\n<p>What is a good way to deal with this problem? It was originally raised by Dan Saks <a href=\"http://www.drdobbs.com/c-theory-and-practice/184403396\" rel=\"nofollow noreferrer\">in 1997</a>, and <a href=\"https://stackoverflow.com/a/612476/1505939\">one suggested resolution</a> is that <em>all</em> classes should be typedef'd:</p>\n<pre><code>typedef struct Foo Foo;\n</code></pre>\n<p>as the compiler does have to report a clash between a <em>typedef-name</em> and a function name. However this does not appear to be common practice - why not?</p>\n<p><strong>Clarification:</strong> this question is about good practices for our code to stop this undetected behaviour change happening without us noticing.  (As opposed to how to solve it once we have realized that it is happening, which is easier -- e.g. rename our class).</p>\n</hr>", "Tags": "<c++>", "OwnerUserId": "1505939", "AnswerCount": "3"}, "28532616": {"ParentId": "28532535", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Unfortunately, you cannot avoid this. From C++11 standard (3.3.10):</p>\n<blockquote>\n<p id=\"so_28532535_28532616_0\">A class name (9.1) or enumeration name (7.2) can be hidden by the name of a variable, data member, function, or enumerator declared in the same scope. If a class or enumeration name and a variable, data member, function, or enumerator are declared in the same scope (in any order) with the same name, the class or enumeration name is hidden wherever the variable, data member, function, or enumerator name is visible.</p>\n</blockquote>\n<p>The only way to guard against it is the typedef trick you pointed out (thanks for that!), using namespaces, or adhering to naming conventions (the latter not helping when dealing with 3rd party code). You could also try to wrap the include in a namespace (shown bellow), but as the comments pointed out, this could cause link errors in certain situations.</p>\n<pre><code>namespace otherlib {\n#include \"other_library.h\"\n}\n</code></pre>\n<p>Then:</p>\n<pre><code>otherlib::Foo();\n</code></pre>\n", "OwnerUserId": "123376", "LastEditorUserId": "123376", "LastEditDate": "2015-02-16T02:47:05.750", "Id": "28532616", "Score": "3", "CreationDate": "2015-02-15T23:45:37.380", "LastActivityDate": "2015-02-16T02:47:05.750"}, "28532592": {"ParentId": "28532535", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_28532535_28532592_0\"><code>typedef struct Foo Foo;</code></p>\n<p id=\"so_28532535_28532592_1\">as the compiler does have to report a clash between a typedef-name and\n  a function name. However this does not appear to be common practice -\n  why not?</p>\n</blockquote>\n<p>I hold this truth to be self-evident: cumbersome code is cumbersome. You can actually rather easily fix this by working in a namespace of your own (which, assuming the header file is C++, too, the <code>other_library</code> should also do.</p>\n", "OwnerUserId": "4433386", "PostTypeId": "2", "Id": "28532592", "Score": "4", "CreationDate": "2015-02-15T23:42:01.340", "LastActivityDate": "2015-02-15T23:42:01.340"}, "bq_ids": {"n4140": {"so_28532535_28532616_0": {"section_id": 7079, "quality": 1.0, "length": 41}}, "n3337": {"so_28532535_28532616_0": {"section_id": 6823, "quality": 1.0, "length": 41}}, "n4659": {"so_28532535_28532616_0": {"section_id": 8580, "quality": 1.0, "length": 41}}}, "28532995": {"ParentId": "28532535", "CommentCount": "3", "Body": "<p>current best practises protect against this already</p>\n<ul>\n<li><p>Naming Conventions, such as<br>\n<code>void camelCase()</code> vs <code>class PascalCase</code><br/></br></p></li>\n<li><p>namespaces</p></li>\n<li><p>wrapper libs for everything not modern C++</p></li>\n</ul>\n", "OwnerUserId": "3202093", "PostTypeId": "2", "Id": "28532995", "Score": "1", "CreationDate": "2015-02-16T00:41:26.583", "LastActivityDate": "2015-02-16T00:41:26.583"}});