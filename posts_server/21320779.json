post_cb({"21320814": {"ParentId": "21320779", "CommentCount": "2", "Body": "<p>You are calling virtual member functions via a pointer to <code>Base</code>. That means that you can only call methods that exist in the <code>Base</code> class. You cannot simply add methods to a type dynamically.</p>\n", "OwnerUserId": "661519", "PostTypeId": "2", "Id": "21320814", "Score": "2", "CreationDate": "2014-01-23T22:38:40.160", "LastActivityDate": "2014-01-23T22:38:40.160"}, "42915696": {"ParentId": "21320779", "CommentCount": "0", "Body": "<p>Although a little late as an answer, straight quote from <em>C++ Primer</em> on how function calls are resolved in relation to inheritance. <strong><em>Your code fails on name lookup (step 2 below), which is done statically.</em></strong> </p>\n<blockquote>\n<p id=\"so_21320779_42915696_0\">Understanding how function calls are resolved is crucial to\n  understanding inheritance in C++. Given the call p-&gt;mem() (or\n  obj.mem()), the following four steps happen:</p>\n<ol>\n<li><p id=\"so_21320779_42915696_1\">First determine the static type of p (or obj). Because we\u2019re calling\n  a member, that type must be a class type. </p></li>\n<li><p id=\"so_21320779_42915696_2\">Look for mem in the class that corresponds to the static type of p (or obj). If mem is not found, look in the direct base class and\n  continue up the chain of classes until mem is found or the last class\n  is searched. If mem is not found in the class or its enclosing base\n  classes, then the call will not compile.</p></li>\n<li><p id=\"so_21320779_42915696_3\">Once mem is found, do normal type checking (\u00a76.1, p. 203) to see if this call is legal given the definition that was found.</p></li>\n<li><p id=\"so_21320779_42915696_4\">Assuming the call is legal, the compiler generates code, which varies depending on whether the call is virtual or not:</p>\n<p id=\"so_21320779_42915696_5\">\u2013 If mem is virtual and the call is made through a reference or\n  pointer, then the compiler generates code to determine at run time\n  which version to run based on the dynamic type of the object.</p>\n<p id=\"so_21320779_42915696_6\">\u2013 Otherwise, if the function is nonvirtual, or if the call is on an\n  object (not a reference or pointer), the compiler generates a normal\n  function call.</p></li>\n</ol>\n</blockquote>\n", "OwnerUserId": "3650499", "PostTypeId": "2", "Id": "42915696", "Score": "1", "CreationDate": "2017-03-20T23:16:42.287", "LastActivityDate": "2017-03-20T23:16:42.287"}, "bq_ids": {"n4659": {"so_21320779_42915696_1": {"section_id": 7709, "quality": 0.5384615384615384, "length": 7}}}, "21320779": {"CommentCount": "0", "AcceptedAnswerId": "21320814", "CreationDate": "2014-01-23T22:36:26.010", "LastActivityDate": "2017-03-20T23:16:42.287", "Title": "Trying to understand dynamic binding and virtual functions", "ViewCount": "297", "PostTypeId": "1", "Id": "21320779", "Score": "-1", "Body": "<p>Given the codes below:</p>\n<pre><code>class Base\n{\npublic:    \n    virtual void f()\n    {\n        std::cout &lt;&lt; \"virtual Base::f()\\n\";\n    }\n};\n\nclass D1 : public Base\n{\npublic:\n    virtual void f()\n    {\n        std::cout &lt;&lt; \"virtual D1::f()\\n\";\n    }\n};\n\nint main()\n{\n    D1 d1;\n    Base *bp = &amp;d1;\n    bp-&gt;f();\n    return 0;\n}\n</code></pre>\n<p>The output was exactly what I had expected:</p>\n<pre><code>virtual D1::f()\nPress &lt;RETURN&gt; to close this window...\n</code></pre>\n<p>But once I removed the <code>virtual void f()</code> from <code>class Base</code>, the compiler complained that:</p>\n<pre><code>error: 'class Base' has no member named 'f'\n</code></pre>\n<p>Can anyone tell me why compiler didn't generate codes such that it can bind virtual functions at rum time?</p>\n", "Tags": "<c++><inheritance><polymorphism><virtual-functions><dynamic-binding>", "OwnerUserId": "1809544", "AnswerCount": "2"}});