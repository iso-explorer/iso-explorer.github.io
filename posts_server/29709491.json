post_cb({"29709769": {"ParentId": "29709491", "CommentCount": "4", "Body": "<p>You asked:</p>\n<pre><code>// why does this line call the correct operator delete?\ndelete pFoo_heap;\n\n// the line above seems to be equivalent to:\n// pFoo_heap-&gt;~Foo();\n// ::operator delete(buf_heap);\n</code></pre>\n<p>That is not true. Your code is subject to undefined behavior. From the C++ Standard:</p>\n<blockquote>\n<p id=\"so_29709491_29709769_0\"><strong>5.3.5 Delete</strong></p>\n<p id=\"so_29709491_29709769_1\">2 If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned conversion function, and the converted operand is used in place of the original operand for the remainder of this section. In the first alternative (<em>delete object</em>), the value of the operand of <code>delete</code> may be a null pointer value, a pointer to a non-array object created by a previous <em>new-expression</em>, or a pointer to a subobject (1.8) representing a base class of such an object (Clause 10). If not, the behavior is undefined.</p>\n</blockquote>\n<p>In your case, <code>pFoo_heap</code> was not created by a <em>new-expression</em>, <code>buf_heap</code> was created by a <em>new-expression</em>. You need to use:</p>\n<pre><code>pFoo_heap-&gt;~Foo();\ndelete [] buf_heap;\n</code></pre>\n<p>for a well behaved program.</p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "29709769", "Score": "3", "CreationDate": "2015-04-17T21:35:51.753", "LastActivityDate": "2015-04-17T21:35:51.753"}, "29709491": {"CommentCount": "2", "ViewCount": "90", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-04-17T21:17:01.523", "LastActivityDate": "2015-04-17T21:35:51.753", "Title": "Confusion about deleting objects created via placement new", "LastEditDate": "2017-05-23T12:22:10.533", "Id": "29709491", "Score": "2", "Body": "<p>I am not absolutely sure what is happening in the code below:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo\n{\n    double dummy{42};\n    static void* operator new(std::size_t size, void* p)\n    {\n        std::cout &lt;&lt; R\"(Calling placement \"operator new\" for size )\"\n                  &lt;&lt; size &lt;&lt; '\\n';\n        return ::operator new(size, p);\n    }\n\n    Foo()\n    {\n        std::cout &lt;&lt; \"Foo::Foo()\" &lt;&lt; std::endl;\n    }\n    ~Foo()\n    {\n        std::cout &lt;&lt; \"~Foo::Foo()\" &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    void* buf_heap = new char[128] {};\n    Foo* pFoo_heap = new(buf_heap) Foo; // placement allocation\n\n    // why does this line call the correct operator delete?\n    delete pFoo_heap;\n\n    // the line above seems to be equivalent to:\n    // pFoo_heap-&gt;~Foo();\n    // ::operator delete(buf_heap);\n}\n</code></pre>\n<p>I know that whenever one uses placement <code>new</code> when constructing an object, the destructor should be manually called, followed by a call to release the memory (usually via <code>::operator delete</code> or <code>::operator delete[]</code>, or <code>free</code>, depending on how placement <code>new</code> is implemented), see e.g. <a href=\"https://stackoverflow.com/q/6730403/3093378\">How to delete object constructed via placement new operator?</a></p>\n<p>However, in my code above, I created a <code>Foo</code> object which I placed in heap-allocated memory. Then, when I call <code>delete pFoo_heap</code>, the destructor is automatically invoked (this I understand), however it seems also that the memory is also released (<code>buf_heap</code> in this case). That is, if I try after to do <code>::operator delete[](buf_heap);</code> I'm getting a segfault.</p>\n<p>So basically the line</p>\n<pre><code>delete pFoo_heap;\n</code></pre>\n<p>seems to be equivalent to</p>\n<pre><code>pFoo_heap-&gt;~Foo(); \n::operator delete[](buf_heap);\n</code></pre>\n<p>Is this indeed the case (or it is just UB)? Why is the memory allocated in <code>buf_heap</code> de-allocated? Or, in other words, does <code>delete pFoo_heap;</code> know where the memory came from, even if allocated via a placement <code>new</code>?</p>\n", "Tags": "<c++><memory-management><placement-new>", "OwnerUserId": "3093378", "AnswerCount": "2"}, "29709547": {"ParentId": "29709491", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_29709491_29709547_0\">Why is the memory allocated in <code>buf_heap</code> de-allocated? </p>\n</blockquote>\n<p>Because you're de-allocating it. Note that <code>buf_heap == pFoo_heap</code>, so when you do <code>delete pFoo_heap</code> that happens to work exactly as if you had done <code>new Foo</code> to begin with - the pointer you're deleting is pointing to memory that was previously allocated with <code>new</code>. So it... \"works\"... </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "29709547", "Score": "1", "CreationDate": "2015-04-17T21:21:33.413", "LastActivityDate": "2015-04-17T21:21:33.413"}, "bq_ids": {"n4140": {"so_29709491_29709769_1": {"section_id": 6106, "quality": 0.9777777777777777, "length": 44}}, "n3337": {"so_29709491_29709769_1": {"section_id": 5872, "quality": 0.9777777777777777, "length": 44}}, "n4659": {"so_29709491_29709769_1": {"section_id": 7603, "quality": 0.9777777777777777, "length": 44}}}});