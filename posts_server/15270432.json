post_cb({"15270432": {"CommentCount": "4", "AcceptedAnswerId": "15271217", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-03-07T11:49:08.513", "LastActivityDate": "2013-03-07T13:52:33.343", "LastEditDate": "2017-05-23T12:16:39.207", "ViewCount": "1628", "FavoriteCount": "1", "Title": "What is a consume operation in the C++11 Standard?", "Id": "15270432", "Score": "14", "Body": "<p>I have seen that <a href=\"https://stackoverflow.com/questions/10526419/does-the-c11-standard-formally-define-acquire-release-and-consume-operations\">this question on acquire, release, consume, etc</a> exists, however, no answer really defines what a \"consume operation\" actually is.</p>\n<p>In 1.10 paragraph 5 it states:</p>\n<blockquote>\n<p id=\"so_15270432_15270432_0\">A synchronization operation on one or more memory locations is either a consume operation, an acquire operation, a release operation, or both an acquire and release operation.</p>\n</blockquote>\n<p>I wondered if someone can explain what this is as it is used in section 1.10 of the C++11 standard?</p>\n", "Tags": "<c++><multithreading><c++11><semantics><memory-model>", "OwnerUserId": "174614", "AnswerCount": "1"}, "15271217": {"ParentId": "15270432", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Apparently, after some searching around, a \"consume operation\" is a memory operation where a value read from memory is used after the load in several operations, and creates a data dependency.</p>\n<p>Being able to order operations without introducing explicit memory fences, is what the apparent (from my understanding) goal is of <code>memory_order_consume</code>.</p>\n<blockquote>\n<p id=\"so_15270432_15271217_0\">With <code>memory_order_consume</code>, the compiler and CPU are <em>required</em> to order the load in question against only those subsequent loads and stores whose address or value are computed from the value loaded. \n  <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1525.htm\">source</a></p>\n</blockquote>\n<p>Later in this text it says:</p>\n<pre><code>/*Example code elided */\n</code></pre>\n<blockquote>\n<p id=\"so_15270432_15271217_1\">The key point is that the <code>atomic_load_explicit()</code> using <code>memory_order_consume</code> guarantees that subsequent accesses will see any initialization carried out by <code>insert_foo()</code>, even if they are executing concurrently, and without the overhead of explicit memory-fence instructions. In constrast, <code>memory_order_acquire</code> would require explicit memory barriers on weakly ordered systems and would overconstrain compiler optimizations on all systems.</p>\n</blockquote>\n<p>C++11 Standard draft n3485 defines <code>memory_order_consume</code> as:</p>\n<p><strong>29.3 Order and consistency [atomics.order]</strong></p>\n<blockquote>\n<p id=\"so_15270432_15271217_2\">memory_order_consume: a load operation performs a consume operation on the affected memory location.</p>\n</blockquote>\n<p>So from my understanding it is to order memory loads so that subsequent loads and stores using that load are indeed <em>subsequent</em>.  In other words, the load is being <em>consumed</em>.</p>\n", "OwnerUserId": "174614", "LastEditorUserId": "560648", "LastEditDate": "2013-03-07T12:35:50.097", "Id": "15271217", "Score": "8", "CreationDate": "2013-03-07T12:26:20.487", "LastActivityDate": "2013-03-07T12:35:50.097"}, "bq_ids": {"n4140": {"so_15270432_15270432_0": {"section_id": 5818, "quality": 1.0, "length": 17}, "so_15270432_15271217_2": {"section_id": 1148, "quality": 1.0, "length": 9}}, "n3337": {"so_15270432_15270432_0": {"section_id": 5589, "quality": 1.0, "length": 17}, "so_15270432_15271217_2": {"section_id": 1145, "quality": 1.0, "length": 9}}, "n4659": {"so_15270432_15270432_0": {"section_id": 7279, "quality": 1.0, "length": 17}, "so_15270432_15271217_2": {"section_id": 1242, "quality": 1.0, "length": 9}}}});