post_cb({"40462003": {"ParentId": "40461797", "CommentCount": "3", "Body": "<p>You can't have direct references in a container. However, if you have access to C++11 <a href=\"http://coliru.stacked-crooked.com/a/02b38f7dcee7bcd5\" rel=\"nofollow noreferrer\">you can use <code>std::reference_wrapper</code></a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;vector&gt;\n#include &lt;array&gt;\n\nint main() {\n  std::array&lt;double,3&gt; a = {1, 4, 5};\n  std::vector&lt;std::reference_wrapper&lt;double&gt;&gt; b;\n  int pos[2] = {0,2};\n  for (unsigned int i = 0; i &lt; sizeof(pos) / sizeof(pos[0]); ++i) \n  {\n      b.emplace_back(a[pos[i]]);\n  }\n\n  for(const auto&amp; viewer: b)\n  {\n      std::cout &lt;&lt; viewer &lt;&lt; \"\\n\";\n  }\n}\n</code></pre>\n<p>Otherwise, just use <code>double*</code>.</p>\n", "OwnerUserId": "1870760", "PostTypeId": "2", "Id": "40462003", "Score": "1", "CreationDate": "2016-11-07T09:41:39.330", "LastActivityDate": "2016-11-07T09:41:39.330"}, "40461797": {"CommentCount": "2", "ViewCount": "34", "CreationDate": "2016-11-07T09:30:35.567", "LastActivityDate": "2016-11-07T09:45:35.053", "Title": "Get sparse subset of array as references", "AcceptedAnswerId": "40462003", "PostTypeId": "1", "Id": "40461797", "Score": "0", "Body": "<p>Is it possible to get a sparse (non-contiguous) subset of references to array elements? </p>\n<p>Suppose I have array <code>a = [1,4,5]</code> and indices <code>pos = [0,1]</code>. I would like to get <code>b = [1,5]</code> without copying elements from <code>a</code>. In other words, I would like to slice into <code>a</code> and create a view called <code>b</code>.  </p>\n<p>The following errors since \"<em>expression is not assignable</em>\":</p>\n<pre><code>#include &lt;array&gt;\n\nint main() {\n  std::array&lt;double,3&gt; a = {1, 4, 5};\n  std::array&lt;double, 2&gt; b;\n  int c = 0;\n  int pos[2] = {0,2};\n  for (auto i = a.begin(); i != a.end(); i++) {\n    &amp;b[c] = i;\n    i++;\n  }\n  return 0;\n}\n</code></pre>\n", "Tags": "<c++><arrays>", "OwnerUserId": "2180721", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_40461797_40461927_0": {"section_id": 3222, "quality": 1.0, "length": 7}}, "n3337": {"so_40461797_40461927_0": {"section_id": 3096, "quality": 1.0, "length": 7}}, "n4659": {"so_40461797_40461927_0": {"section_id": 3979, "quality": 1.0, "length": 7}}}, "40461927": {"ParentId": "40461797", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>C++ Standard 8.3.2/4:</p>\n<blockquote>\n<p id=\"so_40461797_40461927_0\">There shall be no references to references, no arrays of references,\n  and no pointers to references.</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/1164266/why-are-arrays-of-references-illegal\">Answered here</a> </p>\n<p>However you can have a container array of a class with a referance member (initlized on constractor) and implement a =operator, if it's worth the effort</p>\n", "OwnerUserId": "1850903", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:19:17.220", "Id": "40461927", "Score": "0", "CreationDate": "2016-11-07T09:37:11.303", "LastActivityDate": "2016-11-07T09:45:35.053"}});