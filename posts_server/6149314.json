post_cb({"6149413": {"Id": "6149413", "PostTypeId": "2", "Body": "<p>It is <em>not</em> allowed per the ISO standard. This is a bug in Microsoft's product. Even their <a href=\"http://msdn.microsoft.com/en-us/library/6aw8xdf2.aspx\" rel=\"nofollow\">page describing that particular feature</a> makes no mention of this aberrant (or abhorrent, depending on your viewpoint) behaviour.</p>\n<p>The definition for a character literal (as taken from <code>2.14.3</code> of C++0x but the relevant bit is unchanged from C++03) contains:</p>\n<pre><code>character-literal:\n    L\u2019 c-char-sequence \u2019\nc-char-sequence:\n    c-char\n    c-char-sequence c-char\nc-char:\n    any member of the source character set except\n      the single-quote \u2019, backslash \\, or new-line character\n    escape-sequence\n    universal-character-name\nescape-sequence:\n    simple-escape-sequence\n    octal-escape-sequence\n    hexadecimal-escape-sequence\nsimple-escape-sequence: one of\n    \\\u2019 \\\" \\? \\\\ \\a \\b \\f \\n \\r \\t \\v\noctal-escape-sequence:\n    \\ octal-digit\n    \\ octal-digit octal-digit\n    \\ octal-digit octal-digit octal-digit\nhexadecimal-escape-sequence:\n    \\x hexadecimal-digit\n    hexadecimal-escape-sequence hexadecimal-digit\n</code></pre>\n<p>As you can see, there is <em>no</em> way that you can end up with nothing between the <code>'</code> characters in <code>L'x'</code>. It has to be one or more of the <code>c_char</code> characters. In fact, this is made explicit in the following paragraph (my emphasis):</p>\n<blockquote>\n<p id=\"so_6149314_6149413_0\">A character literal is <em>one or more</em> characters enclosed in single quotes, as in <code>\u2019x\u2019</code>, optionally preceded by one of the letters <code>u</code>, <code>U</code>, or <code>L</code>, as in <code>u\u2019y\u2019</code>, <code>U\u2019z\u2019</code>, or <code>L\u2019x\u2019</code>, respectively.</p>\n</blockquote>\n", "LastEditorUserId": "14860", "LastActivityDate": "2011-05-27T08:26:06.693", "Score": "4", "CreationDate": "2011-05-27T07:59:48.050", "ParentId": "6149314", "CommentCount": "0", "OwnerUserId": "14860", "LastEditDate": "2011-05-27T08:26:06.693"}, "6149362": {"Id": "6149362", "PostTypeId": "2", "Body": "<p>This is <a href=\"http://social.msdn.microsoft.com/Forums/en-CA/vcgeneral/thread/f9a25806-54a8-4733-ad55-38c47a419e5c\" rel=\"noreferrer\">a bug in VC++</a>.</p>\n", "LastActivityDate": "2011-05-27T07:54:18.663", "CommentCount": "3", "CreationDate": "2011-05-27T07:54:18.663", "ParentId": "6149314", "Score": "11", "OwnerUserId": "20862"}, "6149365": {"Id": "6149365", "PostTypeId": "2", "Body": "<p>I would argue that the first example is not allowed, per 2.23.2.1 of the C++ standard:</p>\n<blockquote>\n<p id=\"so_6149314_6149365_0\">A character literal is <strong>one or more</strong>\n  characters enclosed in single quotes,\n  as in <code>\u2019x\u2019</code>, optionally preceded by the\n  letter <code>L</code>, as in <code>L\u2019x\u2019</code>.</p>\n</blockquote>\n<p>(Emphasis mine.)</p>\n", "LastActivityDate": "2011-05-27T07:54:32.387", "CommentCount": "0", "CreationDate": "2011-05-27T07:54:32.387", "ParentId": "6149314", "Score": "3", "OwnerUserId": "160206"}, "bq_ids": {"n4140": {"so_6149314_6149413_0": {"length": 13, "quality": 1.0, "section_id": 5343}, "so_6149314_6149365_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 5343}}, "n3337": {"so_6149314_6149413_0": {"length": 13, "quality": 1.0, "section_id": 5140}, "so_6149314_6149365_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 5140}}, "n4659": {"so_6149314_6149413_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 6764}, "so_6149314_6149365_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 6764}}}, "6149314": {"ViewCount": "2281", "Body": "<p>Look at the following code:</p>\n<pre><code>int main(int argc, char* argv[])\n{\n    // This works: (Disable Lang Ext = *Yes* (/Za))\n    wchar_t wc0 = L'\\0';\n    wchar_t wc_ = L'';\n    assert(wc0 == wc_);\n\n    // This doesn't compile (VC++ 2010):\n    char c0 = '\\0';\n    char c_ = ''; // error C2137: empty character constant\n    assert(c0 == c_);\n    return 0;\n}\n</code></pre>\n<p>Why does the compiler allow defining an <em>empty <strong>character</strong> literal</em> for wide characters? This doesn't make sense for wide, just as it doesn't make sense for <code>char</code> where the compiler flags an error.</p>\n<p>Is this allowed by the Standard?</p>\n", "AcceptedAnswerId": "6149362", "Title": "Why is an empty wchar_t literal allowed?", "CreationDate": "2011-05-27T07:46:53.737", "Id": "6149314", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-05-27T08:26:06.693", "Score": "12", "OwnerUserId": "321013", "Tags": "<c++><character><literals>", "AnswerCount": "3"}});