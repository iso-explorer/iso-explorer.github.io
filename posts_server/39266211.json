post_cb({"39266310": {"ParentId": "39266211", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><code>test</code> subclasses <code>string</code> privately, so <code>test</code> \"knows\" it is a <code>string</code>, but anyone outside doesn't.</p>\n<p>In your first case, what happens is as follows:</p>\n<ol>\n<li><p>Outside of <code>test</code> (in <code>main</code>), you call the <code>show</code> method. That's OK, because it's public.</p></li>\n<li><p>Now, inside <code>show</code>, the code \"knows\" it's of type <code>string</code>, because it's a method of <code>test</code>. The conversion is OK.</p></li>\n</ol>\n<p>In your third case, though, you're trying to do the conversion outside, from <code>main</code>. Outside of <code>test</code>, <code>main</code> \"doesn't know\" that <code>test</code> is a <code>string</code>.</p>\n<p>How does your second case work, then? You're performing a <a href=\"https://stackoverflow.com/questions/17925124/can-i-cast-a-derived-class-to-a-private-base-class-using-c-style-cast\">C-style cast from a derived to public base</a>. Surprisingly, this is allowed (although not necessarily good style!). Quoting from the accepted answer there: \u00a75.4/7 of the standard:</p>\n<blockquote>\n<p id=\"so_39266211_39266310_0\">... the following static_cast and reinterpret_cast operations (optionally followed by a const_cast operation) may be performed using the cast notation of explicit type conversion, even if the base class type is not accessible: a pointer to an object of derived class type or an lvalue of derived class type may be explicitly converted to a pointer or reference to an unambiguous base class type, respectively;</p>\n</blockquote>\n", "OwnerUserId": "3510736", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:00:49.750", "Id": "39266310", "Score": "2", "CreationDate": "2016-09-01T08:21:40.217", "LastActivityDate": "2016-09-01T08:38:32.053"}, "39266211": {"CommentCount": "7", "ViewCount": "56", "CreationDate": "2016-09-01T08:16:15.507", "LastActivityDate": "2016-09-01T08:38:32.053", "Title": "Difference among three explicit upcasting to a private base class", "AcceptedAnswerId": "39266310", "PostTypeId": "1", "Id": "39266211", "Score": "3", "Body": "<p>I have the following three typecastings between the private inherited base class object and the child object, two of them work, but the last one doesn't. I am wondering what causes the different results.</p>\n<pre><code>#include&lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\nclass test :private string\n{\npublic:\n    test(string st) :string(st){}\n    void show();\n};\n\nvoid test::show()\n{\n    cout &lt;&lt; (string)*this &lt;&lt; endl; // typecasting 1, works, display \"abcd\"\n}\nint main()\n{\n    test a(\"abcd\");\n    a.show();\n\n    cout &lt;&lt; (string &amp;)a &lt;&lt; endl; //typecasting 2, works, display \"abcd\"\n\n    cout&lt;&lt;(string )a&lt;&lt;endl;   //typecasting 3;  error C2243: 'type cast' : conversion from 'test *' to 'const std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt; &amp;' exists, but is inaccessible     \n}\n</code></pre>\n<p>Isn't <code>a</code> the same as '*this' - since both are objects? So why does No.1 work?<br>\nIf it's because of scope, then why No.2 works? Could anyone please explain the mechanism behind each of them that make the difference among them? </br></p>\n<p>Also, the first method seems to create a string object. In the private inherited case, base class reference can't be set to the derived class object.  So how the temporary string object is created?</p>\n<p>Thanks in advance.</p>\n", "Tags": "<c++><typecasting-operator><private-inheritance>", "OwnerUserId": "5465395", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_39266211_39266310_0": {"section_id": 6126, "quality": 0.825, "length": 33}}, "n3337": {"so_39266211_39266310_0": {"section_id": 5890, "quality": 0.825, "length": 33}}, "n4659": {"so_39266211_39266310_0": {"section_id": 7623, "quality": 0.825, "length": 33}}}});