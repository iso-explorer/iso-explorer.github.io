post_cb({"bq_ids": {"n4140": {"so_27949748_27949748_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 4716}, "so_27949748_27949844_1": {"length": 17, "quality": 0.85, "section_id": 7207}}, "n3337": {"so_27949748_27949748_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 4523}, "so_27949748_27949844_1": {"length": 17, "quality": 0.85, "section_id": 6951}}, "n4659": {"so_27949748_27949748_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 6114}, "so_27949748_27949844_1": {"length": 17, "quality": 0.85, "section_id": 8716}}}, "27949806": {"Id": "27949806", "PostTypeId": "2", "Body": "<p>If <code>B</code>'s member variables are declared private, then that would stop <code>D1</code> from having <code>B</code>'s values.</p>\n<p>As far as your second question, You can assign <code>Base B1 = D;</code> because the compiler knows <code>D</code> is a derived class from <code>B</code>. However, in <code>Derived D1 = B;</code>, the compiler has no indication of that relationship.</p>\n<p>As far as to your question of what a scalar is, scalars are ints, chars, pointers, etc. They are different from structs and classes, which are user-defined types.</p>\n", "LastEditorUserId": "3987536", "LastActivityDate": "2015-01-14T18:24:42.280", "Score": "0", "CreationDate": "2015-01-14T18:19:33.213", "ParentId": "27949748", "CommentCount": "0", "OwnerUserId": "3987536", "LastEditDate": "2015-01-14T18:24:42.280"}, "27949748": {"ViewCount": "274", "Body": "<pre><code>    class Base{};\n    class Derived: public Base{};\n\n    int main()\n    {\n        Base B;\n        Derived D;\n\n        Base B1 = D;//OK\n        Derived D1 = B;//error: conversion from \u2018Base\u2019 to non-scalar \n                       //type \u2018Derived\u2019 requested\n        return 1;\n    }\n</code></pre>\n<p>I know derived class has a is-a relationship with base class.</p>\n<p>What stops the Derived D1 having values from B and remaining member variables(if any) with some garbage value?</p>\n<p>Or</p>\n<p>What does the error message </p>\n<blockquote>\n<p id=\"so_27949748_27949748_0\">conversion from \u2018Base\u2019 to non-scalar type \u2018Derived\u2019 requested Derived D1 = B;</p>\n</blockquote>\n<p>say? What is a scalar type?</p>\n", "AcceptedAnswerId": "27949844", "Title": "Assigning base class object to derived class object", "CreationDate": "2015-01-14T18:16:23.790", "Id": "27949748", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2015-01-14T18:44:06.690", "Score": "1", "OwnerUserId": "3880254", "Tags": "<c++><inheritance>", "AnswerCount": "2"}, "27949844": {"Id": "27949844", "PostTypeId": "2", "Body": "<p>The statement</p>\n<pre><code>Derived D1 = B;\n</code></pre>\n<p>is an initialization, not an assignment (even if it looks like an assignment).</p>\n<p>It attempts to use the <code>Derived</code> copy constructor, but that copy constructor takes an argument <code>Derived const&amp;</code>. And the <code>B</code> instance can't be automatically converted down to a full <code>Derived</code>.</p>\n<p>If you really want a slice assignment \u2013 assigning only to the <code>Base</code> slice of <code>D1</code> \u2013 then you can explicitly use the <code>Base::operator=</code>:</p>\n<pre><code>Derived D1;\nD1.Base::operator=( B );\n</code></pre>\n<p>Another way to express that:</p>\n<pre><code>Derived D1;\nstatic_cast&lt;Base&amp;&gt;( D1 ) = B;\n</code></pre>\n<p>But it smells bad. ;-)</p>\n<hr>\n<p>Re</p>\n<blockquote>\n<p id=\"so_27949748_27949844_0\"><strong>\u201d</strong> What is a scalar type?</p>\n</blockquote>\n<p>That's the same word as in \u201cscale\u201d. A scalar type provides a single magnitude value, so that values of the type can be compared with <code>==</code> (and ideally also <code>&lt;</code>). However, in C++ pointers and even member pointers are regarded as scalar types:</p>\n<p><strong>C++11 \u00a73.9/9</strong> [basic.types]:</p>\n<blockquote>\n<p id=\"so_27949748_27949844_1\"><strong>\u201d</strong> Arithmetic types (3.9.1), enumeration types, pointer types, pointer to member types (3.9.2), std::nullptr_t, and cv-qualified versions of these types (3.9.3) are collectively called <em>scalar types</em>.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2015-01-14T18:28:13.737", "Score": "3", "CreationDate": "2015-01-14T18:21:18.997", "ParentId": "27949748", "CommentCount": "0", "OwnerUserId": "464581", "LastEditDate": "2015-01-14T18:28:13.737"}});