post_cb({"bq_ids": {"n4140": {"so_26707897_26708137_1": {"length": 11, "quality": 1.0, "section_id": 5811}, "so_26707897_26708137_0": {"length": 18, "quality": 1.0, "section_id": 5810}}, "n3337": {"so_26707897_26708137_1": {"length": 11, "quality": 1.0, "section_id": 5584}, "so_26707897_26708137_0": {"length": 18, "quality": 1.0, "section_id": 5583}}, "n4659": {"so_26707897_26708137_1": {"length": 11, "quality": 1.0, "section_id": 7272}, "so_26707897_26708137_0": {"length": 18, "quality": 1.0, "section_id": 7271}}}, "26707897": {"ViewCount": "80", "Body": "<p>Suppose I have types <code>T</code> and <code>U</code>, and functions <code>U f(T)</code> and <code>T g()</code>, and I write the expression <code>f(g())</code>. Under what circumstances is it possible that code in nearby unsequenced expressions may execute after <code>g</code> but before <code>f</code>?</p>\n<p>I understand that one circumstance is in a function call like <code>h(f(g()), j())</code>, <code>j</code> may execute at any time relative to <code>g</code> and <code>f</code>. Is this essentially the <em>only</em> example, or are there others?</p>\n<p>For motivation, the functions <code>std::make_shared&lt;T&gt;</code> and <code>std::make_unique&lt;T&gt;</code> can be used to write more exception-safe code, as shown in this example of unsafe code from <a href=\"http://herbsutter.com/gotw/_102/\" rel=\"nofollow\">http://herbsutter.com/gotw/_102/</a>: </p>\n<pre><code>// In some header file:\nvoid f( std::unique_ptr&lt;T1&gt;, std::unique_ptr&lt;T2&gt; );\n\n// At some call site:\nf( std::unique_ptr&lt;T1&gt;{ new T1 }, std::unique_ptr&lt;T2&gt;{ new T2 } );\n</code></pre>\n<p>The <code>T2</code> constructor may throw an exception after the <code>T1</code> constructor but before the <code>std::unique_ptr&lt;T1&gt;</code> constructor, causing the <code>T1</code> to be leaked. The solution is to write <code>f( make_unique&lt;T1&gt;(), make_unique&lt;T2&gt;() );</code> instead.</p>\n<p>Every discussion I've found of the exception safety provided by <code>std::unique_ptr</code> uses the same example. This makes me wonder if argument expressions in multiple-argument functions (including certain operators like <code>+</code> and <code>[]</code>) are the only situation in which this behavior is expected.</p>\n", "AcceptedAnswerId": "26708137", "Title": "When can unsequenced code be interleaved between a function and its argument?", "CreationDate": "2014-11-03T04:44:56.307", "Id": "26707897", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2014-11-03T05:11:06.560", "Score": "0", "OwnerUserId": "2611123", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "26708137": {"Id": "26708137", "PostTypeId": "2", "Body": "<p><code>[intro.execution]</code> (\u00a71.9) contains the rules, which are actually pretty simple.</p>\n<blockquote>\n<p id=\"so_26707897_26708137_0\">14 Every value computation and side effect associated with a full-expression is sequenced before every value computation and side effect associated with the next full-expression to be evaluated.</p>\n<p id=\"so_26707897_26708137_1\">15 Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced.</p>\n</blockquote>\n<p>A full expression is just what it says it is: an expression which is not a subexpression of any other expression. So only subexpressions of an expression can be unsequenced, and not all of them. For example, certain operators sequence the execution of their arguments, and function calls are indeterminately sequenced (that is, not interleaved).</p>\n", "LastActivityDate": "2014-11-03T05:11:06.560", "CommentCount": "0", "CreationDate": "2014-11-03T05:11:06.560", "ParentId": "26707897", "Score": "5", "OwnerUserId": "1566221"}});