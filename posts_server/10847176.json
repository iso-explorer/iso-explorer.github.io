post_cb({"10847368": {"ParentId": "10847176", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_10847176_10847368_0\"><strong>How to add a function definition in header file?</strong> </p>\n</blockquote>\n<p>This can be achieved in 3 possible ways:</p>\n<ol>\n<li>Marking the function <code>inline</code> or </li>\n<li>Making the function <code>static</code> or </li>\n<li>Putting the functions in anonymous namespace.   </li>\n</ol>\n<blockquote>\n<p id=\"so_10847176_10847368_1\"><strong>What is the correct way to do so?</strong></p>\n</blockquote>\n<p><code>#1</code> i.e: Marking the function <code>inline</code> is the correct way to this without breaking the <strong><em>One Definition Rule</em></strong>.   </p>\n<blockquote>\n<p id=\"so_10847176_10847368_2\"><strong>What is wrong with the other two appraoches?</strong></p>\n</blockquote>\n<p>In both <code>#2</code> &amp; <code>#3</code> each Translation Unit will contain it's own version of the function, and the program will contain several different versions of the function thus leading to a increase in size of the generated binary.<br>\ni.e:  For a <code>static</code> function <code>fun()</code>, <code>&amp;fun</code> will be different in each translation unit, and the program will contain <code>N</code> different versions of the function.<br>\nAlso,  If the function contains static local variables then there will be <code>N</code> different static local variables, one for each function instance.</br></br></p>\n<blockquote>\n<p id=\"so_10847176_10847368_3\"><strong>How the first approach avoids this problem?</strong> </p>\n</blockquote>\n<p>An <code>inline</code> function has external linkage.<br>\nWhen you mark a function <code>inline</code> the function will have the same address in all translation units. Also, Static locals and string literals defined within the body of an inline function are treated as the same object across translation units.<br>\nIn short, a inline function will have the same address across all translation units.</br></br></p>\n<blockquote>\n<p id=\"so_10847176_10847368_4\"><strong>What is the deal with <code>static inline</code> function definitions in header?</strong> </p>\n</blockquote>\n<p>The <code>static</code> keyword forces the function to have a internal linkage.<br>\nEach instance of function defined as inline is treated as a separate function and each instance has its own copy of static locals and string literals. Thus, this would be similar to <code>#2</code>.</br></p>\n<p><strong>Note:</strong><br>\nThe standard mandates that all definitions of <code>inline</code> function in an user program You must have the exact same definition in all translation units in which the function is used or called.</br></p>\n<hr>\n<p>Relevant Standerdese references:    </p>\n<p><strong>C++03 Standard</strong> </p>\n<p><strong>3.2 One definition rule:</strong><br>\n<strong>Para 3:</strong> </br></p>\n<blockquote>\n<p id=\"so_10847176_10847368_5\"><strong>Every program shall contain exactly one definition of every non-inline function or object that is used in that program; no diagnostic required</strong>. The definition can appear explicitly in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8). <strong>An inline function shall be defined in every translation unit in which it is used.</strong></p>\n</blockquote>\n<p><strong>7.1.2 Function specifiers</strong><br>\n<strong>Para 4:</strong> </br></p>\n<blockquote>\n<p id=\"so_10847176_10847368_6\">An inline function shall be defined in every translation unit in which it is used and shall have exactly the same definition in every case (3.2). [Note: a call to the inline function may be encountered before its definition appears in the translation unit. ] If a function with external linkage is declared inline in one translation unit, it shall be declared inline in all translation units in which it appears; no diagnostic is required. <strong>An inline function with external linkage shall have the same address in all translation units. A static local variable in anextern inline function always refers to the same object. A string literal in an extern inline function is the same object in different translation units.</strong></p>\n</blockquote>\n</hr>", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2012-06-02T08:51:39.573", "Id": "10847368", "Score": "31", "CreationDate": "2012-06-01T09:02:21.793", "LastActivityDate": "2012-06-02T08:51:39.573"}, "10847372": {"ParentId": "10847176", "CommentCount": "9", "Body": "<blockquote>\n<p id=\"so_10847176_10847372_0\">(1) I can't define the static inline method out side of the class\n  definition or at the .cpp file.</p>\n</blockquote>\n<p>You can define a <code>static inline</code> method outside the class within the header file. <a href=\"http://ideone.com/tE6AH\">Demo</a>. You cannot define them in .cpp file.</p>\n<blockquote>\n<p id=\"so_10847176_10847372_1\">(2) should I bother to use static inline methods at all</p>\n</blockquote>\n<p>I would say, they can be easily avoided. If you need to see the body in the header file for your own purpose, then only make them <code>inline</code>.</p>\n<blockquote>\n<p id=\"so_10847176_10847372_2\">(3) Should I even define anything method or variable in a header file\n  (what about constants)</p>\n</blockquote>\n<ol>\n<li>Inside the class body, you can define <code>static const</code> data of integral\ntype.</li>\n<li><code>static</code> methods can be defined inside the class body</li>\n<li><code>static inline</code> methods can be defined inside class body or outside\nthe class body within the header file</li>\n<li><code>static</code> data members must be defined in single <code>.cpp</code> file to adhere with <em>One Definition Rule</em></li>\n</ol>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "10847372", "Score": "5", "CreationDate": "2012-06-01T09:02:30.413", "LastActivityDate": "2012-06-01T09:02:30.413"}, "bq_ids": {"n4140": {"so_10847176_10847368_6": {"section_id": 5404, "quality": 0.9714285714285714, "length": 68}, "so_10847176_10847368_5": {"section_id": 7041, "quality": 0.8529411764705882, "length": 29}}, "n3337": {"so_10847176_10847368_6": {"section_id": 5199, "quality": 0.9714285714285714, "length": 68}, "so_10847176_10847368_5": {"section_id": 6786, "quality": 0.8529411764705882, "length": 29}}, "n4659": {"so_10847176_10847368_6": {"section_id": 6853, "quality": 0.8857142857142857, "length": 62}, "so_10847176_10847368_5": {"section_id": 8538, "quality": 0.8529411764705882, "length": 29}}}, "10847176": {"CommentCount": "3", "CreationDate": "2012-06-01T08:49:52.127", "PostTypeId": "1", "AcceptedAnswerId": "10847368", "LastEditorUserId": "255688", "LastActivityDate": "2014-09-25T15:52:11.430", "LastEditDate": "2014-09-25T15:52:11.430", "ViewCount": "13967", "FavoriteCount": "16", "Title": "Should I define static inline methods in header file?", "Id": "10847176", "Score": "16", "Body": "<p>I've read about how it is usually best not to define anything in header files because redundant copies are made for every other file that includes the header file. However, in the case of static inline methods, it appears that I have to define it on the spot (at least visual studio 2010 doesn't let me do that). So if I write an interface at the header file, I can't define the static inline method out side of the class definition or at the .cpp file.</p>\n<p>So, should I bother to use static inline methods at all? And a relate question: Should I even define anything method or variable in a header file (what about constants)?</p>\n<p>Anyway, strangely, it's not something that's covered in great detail in my C++ books.</p>\n<p>Edit: I read through similar questions about static inline methods but none of them seem to directly address this issue.</p>\n", "Tags": "<c++><static><inline><header-files>", "OwnerUserId": "1193562", "AnswerCount": "2"}});