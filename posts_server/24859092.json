post_cb({"24859092": {"CommentCount": "4", "AcceptedAnswerId": "24859383", "CreationDate": "2014-07-21T06:46:45.407", "LastActivityDate": "2014-07-21T10:45:46.240", "PostTypeId": "1", "ViewCount": "550", "FavoriteCount": "2", "Title": "One-past-end-of-object pointers", "Id": "24859092", "Score": "6", "Body": "<p>I know that pointer comparisons are only defined if the two pointers\npoint somewhere \"into\" the storage allocated to the same object, or if\nthey are NULL, or one-past the end of the object as long as it isn't\ndereferenced.</p>\n<p>I use \"object\" in the standard 'C' sense.</p>\n<p>Is there some special dispensation given to comparing two pointers\nthat are -each- one past the end of the object as opposed to\ncomparing a one-past-end pointer and an pointer expression derived\nreferencing the actual object. Given the following definitions:</p>\n<pre><code> char arr[100];\n char *pend = &amp;arr[99];\n char *pa = pend+1;\n char *pb = pend+1;\n</code></pre>\n<p>is the comparison <code>pa == pb</code> guaranteed to be meaningful or does it\ninvoke UB because -neither- pa nor pb point into arr.</p>\n<p>In otherwords, from the standard's point of view, is there a\nsemantic difference between comparing pa and pb and comparing,\nsay, pa and <code>&amp;arr[99]+1</code> ?\nit might seem obvious but :)</p>\n", "Tags": "<c++><c>", "OwnerUserId": "3783574", "AnswerCount": "2"}, "24859898": {"ParentId": "24859092", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>In C++, that's guaranteed only for <em>forward iterators</em>:</p>\n<blockquote>\n<p id=\"so_24859092_24859898_0\"><strong>24.2.5 Forward iterators</strong></p>\n<p id=\"so_24859092_24859898_1\">A class or pointer type X satisfies the requirements of a forward iterator if\n  [...] objects of type X offer the multi-pass guarantee, described below.\n  [...]</p>\n<p id=\"so_24859092_24859898_2\">The domain of == for forward iterators is that of iterators over the\n  same underlying sequence. [...]</p>\n<p id=\"so_24859092_24859898_3\">Two\n  dereferenceable iterators a and b of type X offer the multi-pass\n  guarantee if:</p>\n<p id=\"so_24859092_24859898_4\">\u2014 a == b implies ++a == ++b and [...]</p>\n</blockquote>\n<p>From 24.4.1 (specialization of <code>iterator_traits</code> for pointers) it follows that pointers are random access iterators and thus, forward iterators.</p>\n<p>Alternatively, but maybe less convincing, for arrays you can implicitly infer that <code>(p+1) == (q+1)</code> if both <code>p</code> and <code>q</code> point to the last element of the array, from the wording of the following:</p>\n<blockquote>\n<p id=\"so_24859092_24859898_5\"><strong>5.7 Additive operators</strong>\n  [...]\n  Moreover, if the expression P points to the last element of an array\n  object, the expression (P)+1 points one past the last element of the\n  array object, and if the expression Q points one past the last element\n  of an array object, the expression (Q)-1 points to the last element of\n  the array object.</p>\n</blockquote>\n<p>This implicitly assumes that there is a single well-defined address representing \"one past the last element\". (Arrays are linear, \"one past the last element\" includes the fiction that the linear thing <em>array</em> is extended, and the natural extension of a linear thing is, again, linear, so there can be only one thing <em>\"one past the last element\"</em>. Note the distinction the standard makes between \"one past the last element\" and simply \"past the last element\" elsewhere.)</p>\n", "OwnerUserId": "1419315", "LastEditorUserId": "1419315", "LastEditDate": "2014-07-21T09:05:10.570", "Id": "24859898", "Score": "2", "CreationDate": "2014-07-21T07:40:07.343", "LastActivityDate": "2014-07-21T09:05:10.570"}, "24859383": {"ParentId": "24859092", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This is a good example of why you shouldn't tag your questions both as C and as C++:</p>\n<p>For C, this is covered by the standard.</p>\n<blockquote>\n<p id=\"so_24859092_24859383_0\"><strong>6.5.9 Equality operators</strong></p>\n<p id=\"so_24859092_24859383_1\">6 Two pointers compare equal if and only if both are null pointers, both are pointers to the same object (including a pointer to an object and a subobject at its beginning) or function, <strong>both are pointers to one past the last element of the same array object</strong>, or one is a pointer to one past the end of one array object and the other is a pointer to the start of a different array object that happens to immediately follow the first array object in the address space.</p>\n</blockquote>\n<p>For C++, it is not so clear:</p>\n<blockquote>\n<p id=\"so_24859092_24859383_2\"><strong>5.10 Equality operators [expr.eq]</strong></p>\n<p id=\"so_24859092_24859383_3\">1 The <code>==</code> (equal to) and the <code>!=</code> (not equal to) operators have the same semantic restrictions, conversions, and result type as the relational operators except for their lower precedence and truth-value result. [ <em>Note:</em> <code>a&lt;b == c&lt;d</code> is <code>true</code> whenever <code>a&lt;b</code> and <code>c&lt;d</code> have the same truth-value. -- <em>end note</em> ] Pointers of the same type (after pointer conversions) can be compared for equality. Two pointers of the same type compare equal if and only if they are both null, both point to the same function, <strong>or both represent the same address (3.9.2)</strong>.</p>\n</blockquote>\n<p>Technically, I don't see where the standard requires that two past-the-end pointers represent the same address. I can find where the standard requires that an object has an address, and the <code>&amp;</code> operator returns that specific address (so taking the address twice produces the same pointer value), but a past-the-end pointer does not point to an object, so that does not apply. They might be different, so long as subtracting works to get back to the same array base.</p>\n<p>In practice, though, you won't have to worry about that, and it will work in C++ just as well as in C.</p>\n<p><em>Update:</em> per JohnB's answer and the comments there, the C++ standard may have intended to require this much more explicitly, but it does require it indirectly nonetheless.</p>\n", "OwnerUserId": "743382", "LastEditorUserId": "743382", "LastEditDate": "2014-07-21T10:45:46.240", "Id": "24859383", "Score": "6", "CreationDate": "2014-07-21T07:06:52.050", "LastActivityDate": "2014-07-21T10:45:46.240"}, "bq_ids": {"n4140": {"so_24859092_24859898_3": {"section_id": 5575, "quality": 0.8571428571428571, "length": 6}, "so_24859092_24859898_1": {"section_id": 5573, "quality": 1.0, "length": 14}, "so_24859092_24859898_5": {"section_id": 6142, "quality": 0.9354838709677419, "length": 29}, "so_24859092_24859898_2": {"section_id": 5574, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_24859092_24859898_3": {"section_id": 5357, "quality": 0.8571428571428571, "length": 6}, "so_24859092_24859898_1": {"section_id": 5355, "quality": 1.0, "length": 14}, "so_24859092_24859898_5": {"section_id": 5906, "quality": 0.9354838709677419, "length": 29}, "so_24859092_24859383_3": {"section_id": 5917, "quality": 0.9074074074074074, "length": 49}, "so_24859092_24859898_2": {"section_id": 5356, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_24859092_24859898_3": {"section_id": 7022, "quality": 0.8571428571428571, "length": 6}, "so_24859092_24859898_1": {"section_id": 7020, "quality": 1.0, "length": 14}, "so_24859092_24859898_2": {"section_id": 7021, "quality": 0.8888888888888888, "length": 8}}}});