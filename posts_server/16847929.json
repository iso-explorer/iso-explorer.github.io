post_cb({"bq_ids": {"n4140": {"so_16847929_16848001_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 5817}, "so_16847929_16848001_0": {"length": 20, "quality": 0.7692307692307693, "section_id": 5834}}, "n3337": {"so_16847929_16848001_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 5588}, "so_16847929_16848001_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 5605}}, "n4659": {"so_16847929_16848001_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 7278}, "so_16847929_16848001_0": {"length": 20, "quality": 0.7692307692307693, "section_id": 7296}}}, "16847929": {"ViewCount": "130", "Body": "<p>I heard people say that statements such as var++ and ++var are not threads safe, so I wrote an application to have the test. Code is as below:</p>\n<pre><code>   unsigned long gCounter = 0;\n   const unsigned long WORKS = 1048576;  // pow(2, 20)\n   const unsigned long MAX_THREADS = 100;\n   const unsigned long WORKER_THREADS = 2;\n\n   unsigned long GetCounter(){\n           return gCounter++;\n   }\n\n   void *WorkerThread(void *){\n           unsigned long items = 0;\n           do {\n                GetCounter();\n                items++;\n           } while(items &lt; WORKS);\n\n           printf(\"Exiting thread: %lu\\n\", pthread_self());\n           return NULL;\n    }\n\n\n    int main(int argc, char* argv[]){\n         pthread_t workers[MAX_THREADS];\n\n         //create two threads\n         for (int i = 0; i &lt; WORKER_THREADS; i++){\n            pthread_create(&amp;workers[i], NULL, WorkerThread, NULL);\n         }\n\n         //wait for above threads to exit\n         for (int i = 0; i &lt; WORKER_THREADS; i++){\n               pthread_join(workers[i], NULL);\n         }\n\n\n         assert( gCounter == (WORKER_THREADS * WORKS));\n         return 0;\n    }\n</code></pre>\n<p>If the post-increment operation is not thread safe, then above test application will fail sometimes (might be successful). But to my surprise, it always succeeds during 200 tests when running on our server, while on my PC it never succeeds. </p>\n<p>Why would this happen? Why would above appcation succeed all the time on our server? Below is information about the Server and my PC:     </p>\n<pre><code>     Server machine:\n     System: Redhat 3.4.2 - 6.FC3  Kernel: LINUX.2.6.10 \n     GCC Version: 3.4.2 20041017   \n     CPU: AMD Opteron Processor 144 X86_64\n\n     My PC:\n     System: ubuntu 3.2.0-40-generic  Kernel: LINUX.3.4\n     GCC Version: 4.6.3 (Ubuntu/Linaro )    \n     CPU: Intel(R) Pentium(R) Dual  CPU  T2370        \n\n     Build Command (both are the same, turn off optimization)\n     g++ -O0 -o test test.cpp -lpthread\n</code></pre>\n<p><strong>UPDATE</strong><br>\nToday I found that <strong>the server whose CPU is AMD Opteron 144 is a single-cpu-single-core machine</strong>, maybe it is the reason why this test application never fails on it. As my understanding, a single-cpu-single-core machine doesn't support real thread Parallelism, the threads run in order in a very fast pace that they seem to run parallelly, but they really are not and some thread synchronization problems are not likely to occur easily on this kind of machines.</br></p>\n", "Title": "Why this test application gives different results on different machines? (about post-increment and thread-safe)", "CreationDate": "2013-05-31T00:16:00.700", "LastActivityDate": "2013-05-31T11:31:32.647", "CommentCount": "4", "LastEditDate": "2013-05-31T11:31:32.647", "PostTypeId": "1", "LastEditorUserId": "1773471", "Id": "16847929", "Score": "0", "OwnerUserId": "1773471", "Tags": "<c++><linux><multithreading><gcc><thread-safety>", "AnswerCount": "1"}, "16848001": {"Id": "16848001", "PostTypeId": "2", "Body": "<p>Your code has undefined behaviour since it contains a data race. </p>\n<blockquote>\n<p id=\"so_16847929_16848001_0\"><code>[intro.multithread]/21</code> The execution of a program contains a data race if it contains two conflicting actions in dierent threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior.</p>\n<p id=\"so_16847929_16848001_1\"><code>[intro.multithread]/4</code> Two expression evaluations conflict if one of them modifies a memory location (1.7) and the other one accesses or modifies the same memory location.</p>\n</blockquote>\n<p>Since your code has undefined behaviour, you cannot rely on it having any behaviour in particular. Don't be surprised that it always \"works\" on one platform and never works on another.</p>\n<blockquote>\n<p id=\"so_16847929_16848001_2\"><code>[defns.undefined]</code> <strong>Undefined Behavior:</strong>  Behavior for which this International Standard imposes <strong>no requirements</strong>.</p>\n</blockquote>\n", "LastActivityDate": "2013-05-31T00:25:05.697", "CommentCount": "4", "CreationDate": "2013-05-31T00:25:05.697", "ParentId": "16847929", "Score": "6", "OwnerUserId": "485561"}});