post_cb({"24770875": {"CommentCount": "5", "CreationDate": "2014-07-16T01:37:26.803", "PostTypeId": "1", "AcceptedAnswerId": "24771100", "LastEditorUserId": "701092", "LastActivityDate": "2014-08-20T15:34:18.803", "LastEditDate": "2014-07-16T01:56:20.703", "ViewCount": "1334", "FavoriteCount": "5", "Title": "The answer is not clear c++", "Id": "24770875", "Score": "25", "Body": "<p>Here is a test question:</p>\n<p>Consider the following code:</p>\n<pre><code>class A {\n    typedef int I; // private member\n    I f();\n    friend I g(I);\n    static I x;\n};\n</code></pre>\n<p>Which of the following are valid:</p>\n<pre><code>a. A::I A::f() { return 0; }\nb. A::I g(A::I p = A::x);\nc. A::I g(A::I p) { return 0; }\nd. A::I A::x = 0;\n</code></pre>\n<p>Answer to this question is considered correct only the first version (a.), but why? All them are valid in my opinion. Even tested all they compile successfully. Why only the first answer is correct?</p>\n", "Tags": "<c++>", "OwnerUserId": "163394", "AnswerCount": "2"}, "24771100": {"ParentId": "24770875", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Whoever wrote the original answer to the test is wrong.</p>\n<ul>\n<li>This example comes (exactly) from the <strong>C++ standard itself</strong>, section \u00a7 11/7, [class.access], and has been copied by the one who wrote the \"test\"</li>\n</ul>\n<p>The example goes even further in the standard, with templates (I'll omit them here):</p>\n<pre><code>      class A {\n          typedef int I;      // private member\n          I f();\n          friend I g(I);\n          static I x;\n      };\n\n      A::I A::f() { return 0; }\n      A::I g(A::I p = A::x);\n      A::I g(A::I p) { return 0; }\n      A::I A::x = 0;\n</code></pre>\n<ul>\n<li>Quoting the standard for the explanation:</li>\n</ul>\n<blockquote>\n<p id=\"so_24770875_24771100_0\">Here, all the uses of <code>A::I</code> are well-formed because <code>A::f</code> and  <code>A::x</code>  are\n  members  of  class  A and g is a friend of class A.  This implies, for\n  example, that access checking  on  the  first  use  of  <code>A::I</code>  must  be\n  deferred until it is determined that this use of <code>A::I</code> is as the return\n  type of a member of class A.  ]</p>\n</blockquote>\n<ul>\n<li><a href=\"http://coliru.stacked-crooked.com/a/29044ea9180c723e\" rel=\"nofollow noreferrer\">It compiles with both gcc and clang</a></li>\n</ul>\n", "OwnerUserId": "3510483", "LastEditorUserId": "3510483", "LastEditDate": "2014-08-20T15:34:18.803", "Id": "24771100", "Score": "27", "CreationDate": "2014-07-16T02:06:32.303", "LastActivityDate": "2014-08-20T15:34:18.803"}, "bq_ids": {"n4140": {"so_24770875_24771100_0": {"section_id": 6670, "quality": 0.92, "length": 23}}, "n3337": {"so_24770875_24771100_0": {"section_id": 6425, "quality": 0.92, "length": 23}}, "n4659": {"so_24770875_24771100_0": {"section_id": 8145, "quality": 0.92, "length": 23}}}, "24770996": {"ParentId": "24770875", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>They are all valid C++.</p>\n<p>Here is the exact code, it is an example from the standard itself:</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/open/n2356/access.html\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/open/n2356/access.html</a></p>\n<p>This is how I parse them:</p>\n<pre><code>a. A::I A::f() { return 0; } // defines A::f() which was previously prototyped\n\nb. A::I g(A::I p = A::x);    // declares prototype g(A::I), but doesn't define it\n\nc. A::I g(A::I p) { return 0; } // defines g(A::I)\n\nd. A::I A::x = 0; // defines static storage for A::x which was previously declared in A\n</code></pre>\n<p>These all compile, both individually, and collectively.</p>\n", "OwnerUserId": "257090", "LastEditorUserId": "257090", "LastEditDate": "2014-07-16T02:21:30.560", "Id": "24770996", "Score": "4", "CreationDate": "2014-07-16T01:52:54.903", "LastActivityDate": "2014-07-16T02:21:30.560"}});