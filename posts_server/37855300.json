post_cb({"bq_ids": {"n4140": {"so_37855300_37857288_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 3325}}, "n3337": {"so_37855300_37857288_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 40}}, "n4659": {"so_37855300_37857288_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 4091}}}, "37857288": {"Id": "37857288", "PostTypeId": "2", "Body": "<p>This is the same as <a href=\"https://stackoverflow.com/questions/33970892/list-initialization-priority-from-object-of-same-type\">List-initialization priority from object of same type</a>; clang is correct.</p>\n<p><strong>[dcl.init.list]</strong>/3:</p>\n<blockquote>\n<p id=\"so_37855300_37857288_0\">[...] If T is a class type and the initializer list has a single element of type cv U, where U is T or a class derived from T, the object is initialized from that element [...]</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-06-16T11:01:56.027", "Score": "1", "CreationDate": "2016-06-16T11:01:56.027", "ParentId": "37855300", "CommentCount": "4", "OwnerUserId": "567292", "LastEditDate": "2017-05-23T11:58:47.177"}, "37855300": {"ViewCount": "107", "Body": "<p>A few days ago I watched Sean Parent's talk \"Inheritance is the Base Class of Evil\" and I decided to try his code out. While making  a few changes I stumbled upon this weird behavior: </p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;memory&gt;\nusing namespace std;\nclass object_t {\n  public:\n    template &lt;typename T&gt;\n    object_t(T x) : self_{make_unique&lt;model&lt;T&gt;&gt;(move(x))} {}\n    //explicit object_t(T x) : self_{make_unique&lt;model&lt;T&gt;&gt;(move(x))} {} //this \"solves\" the problem\n    object_t(const object_t &amp;x) : self_(x.self_-&gt;copy_()) {}\n\n  private:\n    struct concept_t {\n        virtual ~concept_t() = default;\n        virtual unique_ptr&lt;concept_t&gt; copy_() const = 0;\n    };\n    template &lt;typename T&gt; struct model : concept_t {\n        model(T x) : data_{move(x)} {} //*the behavior is caused by\n                                       //this brace-initialization\n        //model(T x) : data_(move(x)) {} //this works fine\n        unique_ptr&lt;concept_t&gt; copy_() const override {\n            return make_unique&lt;model&lt;T&gt;&gt;(*this);\n        }\n        T data_;\n    };\n    unique_ptr&lt;const concept_t&gt; self_;\n};\n\nint main() {\n    object_t i{5};\n    object_t v{vector&lt;int&gt;{1, 2, 3, 4}};\n    object_t ic{i};\n    object_t vc{v};\n\n    vector&lt;object_t&gt; vv;\n    vector&lt;object_t&gt; vvv1(vv);\n    vector&lt;object_t&gt; vvv2 = vv;\n    vector&lt;object_t&gt; vvv3{vv}; //this fails with a stack overflow in GCC 6.1.1 but only if brace-initialization is used in model&lt;T&gt;\n}\n</code></pre>\n<p>I used GCC 6.1.1, Clang 3.8.0 and Clang 3.9.0 (a very recent build). The stack overflow only occurs when the code is compiled with GCC and only if brace initialization is used in model's constructor. </p>\n<p>Here's the address sanitizer's output:</p>\n<pre><code>ASAN:DEADLYSIGNAL\n=================================================================\n==21125==ERROR: AddressSanitizer: stack-overflow on address 0x7fff8d492ff8 (pc 0x7f41c188eb02 bp 0x000000000020 sp 0x7fff8d493000 T0)\n    #0 0x7f41c188eb01 in __sanitizer::StackDepotBase&lt;__sanitizer::StackDepotNode, 1, 20&gt;::Put(__sanitizer::StackTrace, bool*) /build/gcc-multilib/src/gcc/libsanitizer/sanitizer_common/sanitizer_stackdepotbase.h:96\n    #1 0x7f41c188e657 in __sanitizer::StackDepotPut(__sanitizer::StackTrace) /build/gcc-multilib/src/gcc/libsanitizer/sanitizer_common/sanitizer_stackdepot.cc:110\n    #2 0x7f41c17cffee in __asan::Allocator::Allocate(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType, bool) /build/gcc-multilib/src/gcc/libsanitizer/asan/asan_allocator.cc:420\n    #3 0x7f41c17cffee in __asan::asan_memalign(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType) /build/gcc-multilib/src/gcc/libsanitizer/asan/asan_allocator.cc:703\n    #4 0x7f41c1871df7 in operator new(unsigned long) /build/gcc-multilib/src/gcc/libsanitizer/asan/asan_new_delete.cc:60\n    #5 0x406018 in std::_MakeUniq&lt;object_t::model&lt;std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt; &gt; &gt;::__single_object std::make_unique&lt;object_t::model&lt;std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt; &gt;, std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt; &gt;(std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt;&amp;&amp;) /usr/include/c++/6.1.1/bits/unique_ptr.h:787\n    #6 0x40356b in object_t::object_t&lt;std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt; &gt;(std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt;) /home/theo/test/valuepoly.cpp:16\n    #7 0x409169 in object_t::model&lt;std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt; &gt;::model(std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt;) /home/theo/test/valuepoly.cpp:25\n\n//The same calls repeat again and again...\n\n    #251 0x406046 in std::_MakeUniq&lt;object_t::model&lt;std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt; &gt; &gt;::__single_object std::make_unique&lt;object_t::model&lt;std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt; &gt;, std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt; &gt;(std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt;&amp;&amp;) /usr/include/c++/6.1.1/bits/unique_ptr.h:787\n    #252 0x40356b in object_t::object_t&lt;std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt; &gt;(std::vector&lt;object_t, std::allocator&lt;object_t&gt; &gt;) /home/theo/test/valuepoly.cpp:16\n\nSUMMARY: AddressSanitizer: stack-overflow /build/gcc-multilib/src/gcc/libsanitizer/sanitizer_common/sanitizer_stackdepotbase.h:96 in __sanitizer::StackDepotBase&lt;__sanitizer::StackDepotNode, 1, 20&gt;::Put(__sanitizer::StackTrace, bool*)\n==21125==ABORTING\n</code></pre>\n<p>If I annotate object_t's constructor as explicit the problem goes away. I'm guessing that using the brace-initializer causes gcc to implicitly convert everything to object_t and use vector's std::initializer_list constructor; and this happens recursively.</p>\n<p>My question is which of the two compilers behaves correctly? </p>\n", "AcceptedAnswerId": "37857288", "Title": "Using brace-initialization in member initializer list causes stack overflow in std::vector copy construction (with GCC but not with Clang)", "CreationDate": "2016-06-16T09:35:06.917", "Id": "37855300", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-06-16T10:09:14.423", "LastEditorUserId": "1040690", "LastActivityDate": "2016-06-16T11:01:56.027", "ClosedDate": "2016-06-16T11:02:11.307", "Score": "0", "OwnerUserId": "1040690", "Tags": "<c++><copy-constructor><stdvector><brace-initialization>", "AnswerCount": "1"}});