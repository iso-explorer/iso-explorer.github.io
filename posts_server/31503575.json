post_cb({"31503575": {"CommentCount": "9", "AcceptedAnswerId": "31503709", "PostTypeId": "1", "LastEditorUserId": "4681361", "CreationDate": "2015-07-19T16:51:17.550", "LastActivityDate": "2015-07-19T18:33:44.043", "LastEditDate": "2015-07-19T17:40:34.810", "ViewCount": "505", "FavoriteCount": "1", "Title": "Are the elements of an array saved continuously in memory?", "Id": "31503575", "Score": "-5", "Body": "<p>I am following a programming paradigm tutorial and doing some memory related exercises. I just extracted two questions (please forget about what the codes look like, sorry it is bad code but I just want to learn the pointer stuff from it). The original codes make lsearch as generic as possible so it uses all pointers.  </p>\n<ol>\n<li><p>I have a question about accessing an element of an array:</p>\n<p>When we access the fourth element of array <code>a[]</code>, we use <code>*(a+3)</code>;\nWhen we access the 3rd element of string array <code>char * names[]</code>, we use <code>*(char**)((char*)names+sizeof(char*)*2)</code>.\nDo we assume the elements of an array are saved continuously in the memory?</p></li>\n<li><p>Question 2 about accessing string array element: why do we need to add <code>(char*)</code> in front of <code>names</code> (the base address), I tried not to add <code>(char*)</code> and the codes crashed with segmentation fault error. I printed the size of <code>(char*)</code>, it is 8, while <code>sizeof(names)</code> is 32. Why do we need <code>(char*)</code> here? I really think the address is 32 bits and if we cast it into 8 bits, the computer should have trouble finding the element it points to. \nThank you   </p></li>\n</ol>\n<p></p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;typeinfo&gt;\nint main()\n{\n        int a[5] = {1,2,3,4,5};\n        std::cout &lt;&lt; *(a+3) &lt;&lt; std::endl;\n\n\n        char* names[4] = {\"James\", \"Dustin\", \"Rich\", \"Ed\"};\n        std::cout &lt;&lt; *(char**)((char*)names+2*sizeof(char*)) &lt;&lt; std::endl;\n        //std::cout &lt;&lt; sizeof(names) &lt;&lt; \" \" &lt;&lt; sizeof(char*) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Here is the original codes from stanford 107.  </p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;string.h&gt;\n#include&lt;stdio.h&gt;\nusing namespace std;\n\nint StrCmp(void* vp1, void* vp2)\n{\n        char *s1 = *(char**)vp1;\n        char *s2 = *(char**)vp2;\n        if(strcmp(s1,s2)==0){\n                return 0;\n        }\n        return 1;\n}\n\nchar ** lsearch(void *key, void* base, int size, int elemSize, int (*cmpFn)(void *, void *))\n{\n        for(int i=0; i&lt;size; ++i){\n                char* addr = (char*) base + elemSize *i;\n                if (cmpFn(key, addr)==0) return (char**)addr;\n        }\n        return NULL;\n}\n\nint main()\n{\n        char *notes[] = {\"Ab\", \"F#\", \"B\", \"Gb\", \"D\"};\n        char* favorStr = \"F#\";\n        char ** found = lsearch(&amp;favorStr,notes,5,sizeof(char*),StrCmp);\n        if(found!=NULL) cout &lt;&lt; *(char**)found &lt;&lt; endl;\n        else cout &lt;&lt; \"not found\" &lt;&lt; endl;\n}\n</code></pre>\n", "Tags": "<c++><arrays><string><memory>", "OwnerUserId": "4681361", "AnswerCount": "1"}, "31503709": {"ParentId": "31503575", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>According to the C++ Standard (8.3.4 Arrays)</p>\n<blockquote>\n<p id=\"so_31503575_31503709_0\">1...An object of array type contains a contiguously allocated non-empty set \n  of N subobjects of type T.</p>\n</blockquote>\n<p>Applying to the array definition from your post it means only that four pointers (the elements of the array) to string literals are allocated in contiguous extent of memory. This extent of memory does not include the string literals themselves.</p>\n<p>In C++ string literals have types of constant character arrays. When they are used as initializers like this</p>\n<pre><code>char* names[4] = {\"James\", \"Dustin\", \"Rich\", \"Ed\"};\n</code></pre>\n<p>then they are implicitly converted to pointers of type <code>const char *</code> that point to the first elements of the arrays.</p>\n<p>So it would be better to define the array like</p>\n<pre><code>const char* names[4] = {\"James\", \"Dustin\", \"Rich\", \"Ed\"};\n</code></pre>\n<p>If you want to output the third element of the array (take into account that it is a pointer) then you have to write</p>\n<pre><code>std::cout &lt;&lt; ( const void * ) ( names + 2 ) &lt;&lt; std::endl;\n</code></pre>\n<p>If you want to output the string literal that is pointed to by this element you should write simply</p>\n<pre><code>std::cout &lt;&lt; *( names + 2 ) &lt;&lt; std::endl;\n</code></pre>\n<p>As for expression</p>\n<pre><code>*(char**)((char*)names+2*sizeof(char*)) \n</code></pre>\n<p>then subexpression <code>(char*)names</code> reinterprets the array of type  <code>char *[4] like an array pf type</code>char [4 * sizeof( char * )]. So expression </p>\n<pre><code>(char*)names+2*sizeof(char*)\n</code></pre>\n<p>yields the same value as expression</p>\n<pre><code>( names + 2 )\n</code></pre>\n<p>For example statements</p>\n<pre><code>std::cout &lt;&lt; ( const void * )( names + 2 ) &lt;&lt; std::endl;\n</code></pre>\n<p>and</p>\n<pre><code>std::cout &lt;&lt; ( void * )( (char*)names + 2*sizeof(char*) ) &lt;&lt; std::endl;\n</code></pre>\n<p>will produce the same output</p>\n<p>I think if to run this demonstrative program it will be more clear</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    const char* names[4] = {\"James\", \"Dustin\", \"Rich\", \"Ed\"};\n\n    for ( size_t i = 0; i &lt; 4; i++ ) \n    {        \n        std::cout &lt;&lt; ( const void * )( names + i ) &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; std::endl;\n\n    for ( size_t i = 0; i &lt; 4; i++ ) \n    {        \n        std::cout &lt;&lt; ( const void * )*( names + i ) &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; std::endl;\n\n    for ( size_t i = 0; i &lt; 4; i++ ) \n    {        \n        std::cout &lt;&lt; ( const void * )( ( char * )names + i * sizeof( char * ) ) &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; std::endl;\n\n    for ( size_t i = 0; i &lt; 4; i++ ) \n    {        \n        std::cout &lt;&lt; ( const void * )*( ( const char ** )( ( const char * )names + i * sizeof( char * ) ) ) &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The program output might look like</p>\n<pre><code>0x7fffc0f639f0\n0x7fffc0f639f8\n0x7fffc0f63a00\n0x7fffc0f63a08\n\n0x40d884\n0x40d88a\n0x40d891\n0x40d896\n\n0x7fffc0f639f0\n0x7fffc0f639f8\n0x7fffc0f63a00\n0x7fffc0f63a08\n\n0x40d884\n0x40d88a\n0x40d891\n0x40d896\n</code></pre>\n<p>In this program expressions <code>( names + 0 )</code>, <code>( names + 1 )</code>, <code>( names + 2 )</code>, <code>( names + 3 )</code> are addresses of correspondingly elements of array names with indices <code>0, 1, 2, 3</code>.\nExpressions <code>*( names + 0 )</code>, <code>*( names + 1 )</code>, <code>*( names + 2 )</code>, <code>*( names + 3 )</code> are the values stored in this elements.</p>\n<p>Expressions <code>( char * )names + i * sizeof( char * )</code> where i in the range <code>0-3</code>\nare the same addresses of the array elements. And  expressions \n*( ( const char ** )( ( const char * )names + i * sizeof( char * ) ) ) give the same values of the elements of the array.</p>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2015-07-19T18:33:44.043", "Id": "31503709", "Score": "3", "CreationDate": "2015-07-19T17:05:26.123", "LastActivityDate": "2015-07-19T18:33:44.043"}, "bq_ids": {"n4140": {"so_31503575_31503709_0": {"section_id": 3228, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_31503575_31503709_0": {"section_id": 3101, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_31503575_31503709_0": {"section_id": 3985, "quality": 0.9090909090909091, "length": 10}}}});