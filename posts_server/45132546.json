post_cb({"bq_ids": {"n4140": {"so_45132546_45132840_0": {"section_id": 6292, "quality": 1.0, "length": 10}}, "n3337": {"so_45132546_45132840_0": {"section_id": 6052, "quality": 0.8, "length": 8}}, "n4659": {"so_45132546_45132840_0": {"section_id": 7800, "quality": 1.0, "length": 10}}}, "45132840": {"ParentId": "45132546", "CommentCount": "3", "CreationDate": "2017-07-16T20:04:41.523", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "45132840", "Score": "1", "Body": "<p>Yes, you are required to implement all requirements of a <a href=\"http://en.cppreference.com/w/cpp/concept/RandomAccessIterator\" rel=\"nofollow noreferrer\">Random Access Iterator</a>.  C++ Standard [allocator.requirements]/5:</p>\n<blockquote>\n<p id=\"so_45132546_45132840_0\">An allocator type <code>X</code> shall....  <code>X::pointer</code> and <code>X::const_pointer</code> shall also satisfy the requirements for a random access iterator.</p>\n</blockquote>\n<p>So in particular, your fancy pointer type needs the five member types required of every <a href=\"http://en.cppreference.com/w/cpp/concept/Iterator\" rel=\"nofollow noreferrer\">iterator</a>.</p>\n<p>You also seem to be missing <code>fancy_memory_resource&lt;Ptr&gt;::value_type</code>, several needed non-member functions, and a number of <code>noexcept</code> keywords.  Please review the <a href=\"http://en.cppreference.com/w/cpp/concept/Allocator\" rel=\"nofollow noreferrer\">requirements for allocator types</a> and their pointer types carefully.</p>\n", "LastActivityDate": "2017-07-16T20:04:41.523"}, "45132546": {"CommentCount": "0", "ViewCount": "72", "CreationDate": "2017-07-16T19:28:45.250", "LastActivityDate": "2017-07-16T20:04:41.523", "Title": "Should every fancy pointer be an iterator?", "AcceptedAnswerId": "45132840", "PostTypeId": "1", "Id": "45132546", "Score": "1", "Body": "<p>I'm working on a segment-based memory allocator for C++. In this allocator, when you deallocate a chunk of memory, you have to know which <em>segment</em> it came from. Therefore, I'm storing a pointer to the segment as a member of the fancy <code>pointer</code> returned from the allocator's <code>allocate</code> function.</p>\n<p>Just to show the interface I'm talking about: here's the <code>fancy_memory_resource</code> that backs my allocator...</p>\n<pre><code>template&lt;class Ptr&gt;\nclass fancy_memory_resource {\npublic:\n    Ptr allocate(size_t bytes, size_t align = alignof(max_align_t)) {\n        return do_allocate(bytes, align);\n    }\n    void deallocate(Ptr p, size_t bytes, size_t align = alignof(max_align_t)) {\n        return do_deallocate(p, bytes, align);\n    }\n    bool is_equal(const fancy_memory_resource&amp; rhs) const noexcept {\n        return do_is_equal(rhs);\n    }\n    virtual ~fancy_memory_resource() = default;\nprivate:\n    virtual Ptr do_allocate(size_t bytes, size_t align) = 0;\n    virtual void do_deallocate(Ptr p, size_t bytes, size_t align) = 0;\n    virtual bool do_is_equal(const fancy_memory_resource&amp; rhs) const noexcept = 0;\n};\n</code></pre>\n<p>(Notice that <code>std::pmr::memory_resource</code> can be implemented as a typedef for <code>fancy_memory_resource&lt;void*&gt;</code>. This is intentional on my part.)</p>\n<p>Meanwhile, the <code>Ptr</code> in question is a fancy pointer type named <code>segmented_fancy_pointer&lt;T&gt;</code> (not pictured) that inherits from the CRTP type <code>fancy_ptr_base&lt;T, segmented_fancy_pointer&lt;T&gt;&gt;</code>...</p>\n<pre><code>template&lt;class T, class CRTP&gt;\nstruct fancy_ptr_base {\n    constexpr T *ptr() const noexcept { return m_ptr; }\n    constexpr explicit operator T*() const noexcept { return ptr(); }\n    constexpr explicit operator bool() const noexcept { return ptr() != nullptr; }\n    constexpr bool operator==(CRTP b) const { return ptr() == b.ptr(); }\n    constexpr bool operator!=(CRTP b) const { return ptr() != b.ptr(); }\n    constexpr bool operator==(decltype(nullptr)) const { return ptr() == nullptr; }\n    constexpr bool operator!=(decltype(nullptr)) const { return ptr() != nullptr; }\n    constexpr bool operator&lt;(CRTP b) const { return ptr() &lt; b.ptr(); }\n    constexpr bool operator&lt;=(CRTP b) const { return ptr() &lt;= b.ptr(); }\n    constexpr bool operator&gt;(CRTP b) const { return ptr() &gt; b.ptr(); }\n    constexpr bool operator&gt;=(CRTP b) const { return ptr() &gt;= b.ptr(); }\n    constexpr T&amp; operator*() const noexcept { return *ptr(); }\n    constexpr T* operator-&gt;() const noexcept { return ptr(); }\n    constexpr CRTP&amp; operator+=(ptrdiff_t i) { m_ptr += i; return as_crtp(); }\n    constexpr CRTP&amp; operator-=(ptrdiff_t i) { m_ptr -= i; return as_crtp(); }\n    constexpr CRTP&amp; operator++() { ++m_ptr; return as_crtp(); }\n    constexpr CRTP&amp; operator--() { --m_ptr; return as_crtp(); }\n    constexpr CRTP operator++(int) { auto r(as_crtp()); ++*this; return r; }\n    constexpr CRTP operator--(int) { auto r(as_crtp()); --*this; return r; }\n    constexpr CRTP operator+(ptrdiff_t i) const { auto r(as_crtp()); r += i; return r; }\n    constexpr CRTP operator-(ptrdiff_t i) const { auto r(as_crtp()); r -= i; return r; }\n    constexpr ptrdiff_t operator-(CRTP b) const { return ptr() - b.ptr(); }\n\nprotected:\n    T *m_ptr = nullptr;\nprivate:\n    constexpr CRTP&amp; as_crtp() { return *static_cast&lt;CRTP*&gt;(this); }\n    constexpr const CRTP&amp; as_crtp() const { return *static_cast&lt;const CRTP*&gt;(this); }\n};\n\ntemplate&lt;class CRTP&gt;\nstruct fancy_ptr_base&lt;void, CRTP&gt; {\n    constexpr void *ptr() const noexcept { return m_ptr; }\n    constexpr explicit operator void*() const noexcept { return ptr(); }\n    constexpr explicit operator bool() const noexcept { return ptr() != nullptr; }\n    constexpr bool operator==(CRTP b) const { return ptr() == b.ptr(); }\n    constexpr bool operator!=(CRTP b) const { return ptr() != b.ptr(); }\n    constexpr bool operator==(decltype(nullptr)) const { return ptr() == nullptr; }\n    constexpr bool operator!=(decltype(nullptr)) const { return ptr() != nullptr; }\n    constexpr bool operator&lt;(CRTP b) const { return ptr() &lt; b.ptr(); }\n    constexpr bool operator&lt;=(CRTP b) const { return ptr() &lt;= b.ptr(); }\n    constexpr bool operator&gt;(CRTP b) const { return ptr() &gt; b.ptr(); }\n    constexpr bool operator&gt;=(CRTP b) const { return ptr() &gt;= b.ptr(); }\nprotected:\n    void *m_ptr = nullptr;\n};\n</code></pre>\n<p>Now for the real question. When I go to use my <code>segmented_allocator&lt;T&gt;</code> (not pictured) with libc++'s <code>std::vector</code>, it all works fine. When I try to use it with libstdc++'s <code>std::vector</code>, it fails:</p>\n<pre><code>In file included from /opt/wandbox/gcc-head/include/c++/8.0.0/bits/stl_algobase.h:67:0,\n                 from /opt/wandbox/gcc-head/include/c++/8.0.0/vector:60,\n                 from prog.cc:1984:\n/opt/wandbox/gcc-head/include/c++/8.0.0/bits/stl_iterator.h: In instantiation of 'class __gnu_cxx::__normal_iterator&lt;scratch::segmented_fancy_pointer&lt;int&gt;, std::vector&lt;int, scratch::pmr::propagating_polymorphic_allocator&lt;int, scratch::segmented_fancy_pointer&lt;int&gt; &gt; &gt; &gt;':\n/opt/wandbox/gcc-head/include/c++/8.0.0/bits/vector.tcc:105:25:   required from 'std::vector&lt;_Tp, _Alloc&gt;::reference std::vector&lt;_Tp, _Alloc&gt;::emplace_back(_Args&amp;&amp; ...) [with _Args = {int}; _Tp = int; _Alloc = scratch::pmr::propagating_polymorphic_allocator&lt;int, scratch::segmented_fancy_pointer&lt;int&gt; &gt;; std::vector&lt;_Tp, _Alloc&gt;::reference = int&amp;]'\n/opt/wandbox/gcc-head/include/c++/8.0.0/bits/stl_vector.h:954:21:   required from 'void std::vector&lt;_Tp, _Alloc&gt;::push_back(std::vector&lt;_Tp, _Alloc&gt;::value_type&amp;&amp;) [with _Tp = int; _Alloc = scratch::pmr::propagating_polymorphic_allocator&lt;int, scratch::segmented_fancy_pointer&lt;int&gt; &gt;; std::vector&lt;_Tp, _Alloc&gt;::value_type = int]'\nprog.cc:1990:18:   required from here\n/opt/wandbox/gcc-head/include/c++/8.0.0/bits/stl_iterator.h:770:57: error: no type named 'iterator_category' in 'struct std::iterator_traits&lt;scratch::segmented_fancy_pointer&lt;int&gt; &gt;'\n       typedef typename __traits_type::iterator_category iterator_category;\n                                                         ^~~~~~~~~~~~~~~~~\n</code></pre>\n<p>Now, I <em>can</em> fix this by adding the \"iterator traits\" typedefs into <code>fancy_ptr_base&lt;T, CRTP&gt;</code>, like this:</p>\n<pre><code>    using pointer = CRTP;\n    using reference = T&amp;;\n    using value_type = std::remove_cv_t&lt;T&gt;;\n    using iterator_category = std::random_access_iterator_tag;\n    using difference_type = ptrdiff_t;\n</code></pre>\n<p>But should I have to? Is it <em>required</em> that every fancy pointer type be an iterator type as well? Or is libc++ doing the right thing and libstdc++'s <code>vector</code> just has a bug?</p>\n<p>(I have already convinced myself that <a href=\"https://github.com/Quuxplusone/from-scratch/blob/master/include/scratch/bits/traits-classes/pointer-traits.md#what-is-a-pointer\" rel=\"nofollow noreferrer\">most <em>iterators</em> are not fancy pointers</a>. This question is motivated by my sudden doubt that perhaps all <em>fancy pointers</em> are indeed iterators.)</p>\n", "Tags": "<c++><crtp><allocator><fancy-pointers>", "OwnerUserId": "1424877", "AnswerCount": "1"}});