post_cb({"31435835": {"Id": "31435835", "PostTypeId": "2", "Body": "<p>(The C and C++ standards have essentially identical wording in \u00a76.10.3.3 and \u00a716.3.3 respectively. In case there are minor differences, I took the quotes from C11.)</p>\n<p>The order in which <code>##</code> operators are processed is explicitly unspecified: (\"The order of evaluation of ## operators is unspecified.\", last sentence of paragraph 3; also see paragraph 2 of the preceding section). So you can't say that the \"preprocesor first tries to concat x with second ##\"; it might first try to concat the first <code>##</code> with the <code>3</code>. That wouldn't produce a valid token, either, so it's a bit of a quibble. But it's important to remember.</p>\n<p>The question is whether the statement that the order of evaluation being unspecified permits the evaluation to be <em>interleaved</em>. In other words, could a preprocessor satisfy the standard by first deleting the second <code>##</code>, then deleting the first one, and finally producing a single concatenation? Certainly, in the execution model, it is clear that <em>unsequenced</em> operations are allowed to interleave. (See note 13 in \u00a75.1.2.3. In C++, the words are \"can overlap\"; \u00a71.9/13)</p>\n<p>That might be a bit of a stretch, but it's also worth noting that after concatenation:</p>\n<blockquote>\n<p id=\"so_31433101_31435835_0\">If the result is not a valid preprocessing token, the behavior is undefined.</p>\n</blockquote>\n<p>This is <em>not</em> marked as a constraint, so an error message is not required. And since undefined behaviour relieves the compiler from any obligation to the standard, I suppose gcc is totally within its rights to produce the observed behaviour.</p>\n<p>In short, the macro replacement string provided in the original question either involves unspecified or undefined behaviour, but not a constraint violation. Consequently, the compiler is under no obligation to produce a diagnostic.</p>\n<p>Not producing a diagnostic in this case could be considered a quality-of-implementation issue. On the other hand, I don't know of any compiler which produces a warning for macros with ambiguous <code>##</code> order of evaluation. Aside from the constraint that a macro expansion list cannot start or end with a <code>##</code> token, which must be diagnosed by the compiler, it is wholly the responsibility of the programmer to ensure that concatenation expressions are well-defined.</p>\n", "LastActivityDate": "2015-07-15T16:20:15.867", "CommentCount": "2", "CreationDate": "2015-07-15T16:20:15.867", "ParentId": "31433101", "Score": "2", "OwnerUserId": "1566221"}, "31433101": {"ViewCount": "289", "Body": "<p>Can someone explain me why having 2 concatenation operators does not produce any error by a preprocessor?:</p>\n<pre><code>#define Z(x) x ## ## 3\nZ(3)\n</code></pre>\n<p>results in:</p>\n<pre><code>33\n</code></pre>\n<p>Standards say that:</p>\n<blockquote>\n<p id=\"so_31433101_31433101_0\">...each instance of a ## preprocessing token in the replacement list\n  (not from an argument) is deleted and the preceding preprocessing\n  token is concatenated with the following preprocessing token</p>\n</blockquote>\n<p>so I would expect that preprocesor first tries to concat <code>x</code> with second <code>##</code> which seems strange. This does not produce any valid token so I would expect at least a warning. Neither gcc, nor VC produce any warning.</p>\n<p>I would appreciate some explanation of how this works and why.\nStandard mentions <code>placemaker</code> temporary tokens which would explain why this works but there would have to be one such token between both 'double-sharps'. The problem is that <code>placemaker</code> tokens are generated when parameter contains no tokens and there is no parameter between both concat operators.</p>\n", "Title": "Two adjacent ## operators", "CreationDate": "2015-07-15T14:22:33.273", "LastActivityDate": "2015-07-15T16:20:15.867", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "Id": "31433101", "Score": "13", "OwnerUserId": "488700", "Tags": "<c++><c><c-preprocessor>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31433101_31433101_0": {"length": 15, "quality": 1.0, "section_id": 529}, "so_31433101_31435835_0": {"length": 6, "quality": 1.0, "section_id": 529}}, "n3337": {"so_31433101_31433101_0": {"length": 15, "quality": 1.0, "section_id": 520}, "so_31433101_31435835_0": {"length": 6, "quality": 1.0, "section_id": 520}}, "n4659": {"so_31433101_31433101_0": {"length": 15, "quality": 1.0, "section_id": 550}, "so_31433101_31435835_0": {"length": 6, "quality": 1.0, "section_id": 550}}}});