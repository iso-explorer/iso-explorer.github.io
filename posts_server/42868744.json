post_cb({"42868831": {"ParentId": "42868744", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2017-03-17T23:56:44.383", "Score": "1", "LastEditorUserId": "2079303", "LastEditDate": "2017-03-18T00:11:43.500", "Id": "42868831", "OwnerUserId": "2079303", "Body": "<blockquote>\n<p id=\"so_42868744_42868831_0\">Is this undefined?</p>\n</blockquote>\n<p>Each case is well defined.</p>\n<blockquote>\n<p id=\"so_42868744_42868831_1\">What happens in this case?</p>\n</blockquote>\n<p>In each case, the lifetime of the temporary object is extended to match the lifetime of the const reference as is described in the [class.temporary] section of the standard.</p>\n<blockquote>\n<p id=\"so_42868744_42868831_2\">[class.temporary] (standard draft)</p>\n<p id=\"so_42868744_42868831_3\">4 There are two contexts in which temporaries are destroyed at a different point than the end of the full-\n  expression. The first context is ... [irrelevant to your cases]</p>\n<p id=\"so_42868744_42868831_4\">5 The second context is when a reference is bound to a temporary. The temporary to which the reference is\n  bound or the temporary that is the complete object of a subobject to which the reference is bound persists\n  for the lifetime of the reference except ... [a few exceptions which do not apply to your cases]</p>\n</blockquote>\n", "LastActivityDate": "2017-03-18T00:11:43.500"}, "bq_ids": {"n4140": {"so_42868744_42868831_3": {"section_id": 381, "quality": 0.6470588235294118, "length": 11}, "so_42868744_42868831_4": {"section_id": 382, "quality": 0.7307692307692307, "length": 19}}, "n3337": {"so_42868744_42868831_3": {"section_id": 372, "quality": 0.6470588235294118, "length": 11}, "so_42868744_42868831_4": {"section_id": 373, "quality": 0.7307692307692307, "length": 19}}, "n4659": {"so_42868744_42868831_3": {"section_id": 396, "quality": 0.5882352941176471, "length": 10}, "so_42868744_42868831_4": {"section_id": 397, "quality": 0.6923076923076923, "length": 18}}}, "42868744": {"CommentCount": "2", "ViewCount": "145", "CreationDate": "2017-03-17T23:45:13.677", "LastActivityDate": "2017-03-18T00:11:43.500", "Title": "What happens when assigning an rvalue to 'const auto&'", "PostTypeId": "1", "Id": "42868744", "Score": "0", "Body": "<p>What happens in this case?</p>\n<pre><code>// assume WeakPtr is valid and has not expired\nconst auto&amp; something = WeakPtr.lock();\nsomething-&gt;doStuff();\n</code></pre>\n<p>Is this undefined?</p>\n<p>Does it change in this scenario?</p>\n<pre><code>std::shared_ptr&lt;Something&gt; getSomething() { return mSomething.lock(); }\nconst auto&amp; something = getSomething();\n</code></pre>\n<p>And how about this?</p>\n<pre><code>std::vector&lt;int&gt; getInts() { return std::vector&lt;int&gt;{ 1, 2, 3 }; }\nconst auto&amp; ints = getInts();\n</code></pre>\n<p>In each of these cases <code>const auto&amp;</code> implies that I want to bind a reference to the object, but in each of these cases I am binding it to a temporary rvalue object.  Am I inviting disaster?</p>\n", "Tags": "<c++><c++11><reference><lvalue><rvalue>", "OwnerUserId": "2779792", "AnswerCount": "1"}});