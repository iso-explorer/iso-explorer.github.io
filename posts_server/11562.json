post_cb({"2684544": {"ParentId": "11562", "CommentCount": "18", "Body": "<p>The right way to overload swap is to write it in the same namespace as what you're swapping, so that it can be found via argument-dependent lookup (ADL).  One particularly easy thing to do is:</p>\n<pre><code>class X\n{\n    // ...\n    friend void swap(X&amp; a, X&amp; b)\n    {\n        using std::swap; // bring in swap for built-in types\n\n        swap(a.base1, b.base1);\n        swap(a.base2, b.base2);\n        // ...\n        swap(a.member1, b.member1);\n        swap(a.member2, b.member2);\n        // ...\n    }\n};\n</code></pre>\n", "OwnerUserId": "125349", "PostTypeId": "2", "Id": "2684544", "Score": "104", "CreationDate": "2010-04-21T16:02:22.350", "LastActivityDate": "2010-04-21T16:02:22.350"}, "109613": {"CommentCount": "2", "CreationDate": "2008-09-20T22:24:12.633", "LastEditorUserId": "14312", "LastActivityDate": "2008-09-20T22:37:47.017", "ParentId": "11562", "PostTypeId": "2", "LastEditorDisplayName": "puetzk", "LastEditDate": "2008-09-20T22:37:47.017", "Id": "109613", "Score": "27", "Body": "<p>While it's correct that one shouldn't generally add stuff to the std:: namespace, adding template specializations for user-defined types is specifically allowed. Overloading the functions is not. This is a subtle difference :-)</p>\n<blockquote>\n<p id=\"so_11562_109613_0\">17.4.3.1/1\n    It is undefined for a C++ program to add declarations or definitions\n    to namespace std or namespaces with namespace std unless otherwise\n    specified.  A program may add template specializations for any\n    standard library template to namespace std. Such a specialization\n    (complete or partial) of a standard library results in undefined\n    behaviour unless the declaration depends on a user-defined name of\n    external linkage and unless the template specialization meets the\n    standard library requirements for the original template. </p>\n</blockquote>\n<p>A specialization of std::swap would look like:</p>\n<pre><code>namespace std\n{\n    template&lt;&gt;\n    void swap(myspace::mytype&amp; a, myspace::mytype&amp; b) { ... }\n}\n</code></pre>\n<p>Without the template&lt;&gt; bit it would be an overload, which is undefined, rather than a specialization, which is permitted. @Wilka's suggest approach of changing the default namespace may work with user code (due to Koenig lookup preferring the namespace-less version) but it's not guaranteed to, and in fact isn't really supposed to (the STL implementation ought to use the fully-qualified std::swap).</p>\n<p>There is a <a href=\"http://groups.google.ca/group/comp.lang.c++.moderated/browse_thread/thread/b396fedad7dcdc81\" rel=\"noreferrer\">thread on comp.lang.c++.moderated</a> with a <strong>long</strong> dicussion of the topic. Most of it is about partial specialization, though (which there's currently no good way to do).</p>\n", "OwnerUserId": "14312", "OwnerDisplayName": "puetzk"}, "8439357": {"ParentId": "11562", "PostTypeId": "2", "CommentCount": "17", "Body": "<p><strong>Attention Mozza314</strong></p>\n<p>Here is a simulation of the effects of a generic <code>std::algorithm</code> calling <code>std::swap</code>, and having the user provide their swap in namespace std.  As this is an experiment, this simulation uses <code>namespace exp</code> instead of <code>namespace std</code>.</p>\n<pre><code>// simulate &lt;algorithm&gt;\n\n#include &lt;cstdio&gt;\n\nnamespace exp\n{\n\n    template &lt;class T&gt;\n    void\n    swap(T&amp; x, T&amp; y)\n    {\n        printf(\"generic exp::swap\\n\");\n        T tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    template &lt;class T&gt;\n    void algorithm(T* begin, T* end)\n    {\n        if (end-begin &gt;= 2)\n            exp::swap(begin[0], begin[1]);\n    }\n\n}\n\n// simulate user code which includes &lt;algorithm&gt;\n\nstruct A\n{\n};\n\nnamespace exp\n{\n    void swap(A&amp;, A&amp;)\n    {\n        printf(\"exp::swap(A, A)\\n\");\n    }\n\n}\n\n// exercise simulation\n\nint main()\n{\n    A a[2];\n    exp::algorithm(a, a+2);\n}\n</code></pre>\n<p>For me this prints out:   </p>\n<pre><code>generic exp::swap\n</code></pre>\n<p>If your compiler prints out something different then it is not correctly implementing \"two-phase lookup\" for templates.</p>\n<p>If your compiler is conforming (to any of C++98/03/11), then it will give the same output I show.  And in that case exactly what you fear will happen, does happen.  And putting your <code>swap</code> into namespace <code>std</code> (<code>exp</code>) did not stop it from happening.</p>\n<p>Dave and I are both committee members and have been working this area of the standard for a decade (and not always in agreement with each other).  But this issue has been settled for a long time, and we both agree on how it has been settled.  Disregard Dave's expert opinion/answer in this area at your own peril.</p>\n<p>This issue came to light after C++98 was published.  Starting about 2001 Dave and I began to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2001/n1289.html\">work this area</a>.  And this is the modern solution:</p>\n<pre><code>// simulate &lt;algorithm&gt;\n\n#include &lt;cstdio&gt;\n\nnamespace exp\n{\n\n    template &lt;class T&gt;\n    void\n    swap(T&amp; x, T&amp; y)\n    {\n        printf(\"generic exp::swap\\n\");\n        T tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    template &lt;class T&gt;\n    void algorithm(T* begin, T* end)\n    {\n        if (end-begin &gt;= 2)\n            swap(begin[0], begin[1]);\n    }\n\n}\n\n// simulate user code which includes &lt;algorithm&gt;\n\nstruct A\n{\n};\n\nvoid swap(A&amp;, A&amp;)\n{\n    printf(\"swap(A, A)\\n\");\n}\n\n// exercise simulation\n\nint main()\n{\n    A a[2];\n    exp::algorithm(a, a+2);\n}\n</code></pre>\n<p>Output is:</p>\n<pre><code>swap(A, A)\n</code></pre>\n<p><strong>Update</strong></p>\n<p>An observation has been made that:</p>\n<pre><code>namespace exp\n{    \n    template &lt;&gt;\n    void swap(A&amp;, A&amp;)\n    {\n        printf(\"exp::swap(A, A)\\n\");\n    }\n\n}\n</code></pre>\n<p>works!  So why not use that?</p>\n<p>Consider the case that your <code>A</code> is a class template:</p>\n<pre><code>// simulate user code which includes &lt;algorithm&gt;\n\ntemplate &lt;class T&gt;\nstruct A\n{\n};\n\nnamespace exp\n{\n\n    template &lt;class T&gt;\n    void swap(A&lt;T&gt;&amp;, A&lt;T&gt;&amp;)\n    {\n        printf(\"exp::swap(A, A)\\n\");\n    }\n\n}\n\n// exercise simulation\n\nint main()\n{\n    A&lt;int&gt; a[2];\n    exp::algorithm(a, a+2);\n}\n</code></pre>\n<p>Now it doesn't work again. :-(</p>\n<p>So you could put <code>swap</code> in namespace std and have it work.  But you'll need to remember to put <code>swap</code> in <code>A</code>'s namespace for the case when you have a template: <code>A&lt;T&gt;</code>.  And since both cases will work if you put <code>swap</code> in <code>A</code>'s namespace, it is just easier to remember (and to teach others) to just do it that one way.</p>\n", "OwnerUserId": "576911", "LastEditorUserId": "1913824", "LastEditDate": "2015-08-31T17:13:17.170", "Id": "8439357", "Score": "60", "CreationDate": "2011-12-08T23:52:13.473", "LastActivityDate": "2015-08-31T17:13:17.170"}, "11599": {"CommentCount": "8", "CreationDate": "2008-08-14T19:46:32.113", "LastEditorUserId": "368896", "LastActivityDate": "2014-01-27T14:15:05.883", "ParentId": "11562", "PostTypeId": "2", "LastEditorDisplayName": "Wilka", "LastEditDate": "2014-01-27T14:15:05.883", "Id": "11599", "Score": "50", "Body": "<p>You're not allowed (by the C++ standard) to overload std::swap, however you are specifically allowed to add template specializations for your own types to the std namespace. E.g.</p>\n<pre><code>namespace std\n{\n    template&lt;&gt;\n    void swap(my_type&amp; lhs, my_type&amp; rhs)\n    {\n       // ... blah\n    }\n}\n</code></pre>\n<p>then the usages in the std containers (and anywhere else) will pick your specialization  instead of the general one.</p>\n<p>Also note that providing a base class implementation of swap isn't good enough for your derived types. E.g. if you have</p>\n<pre><code>class Base\n{\n    // ... stuff ...\n}\nclass Derived : public Base\n{\n    // ... stuff ...\n}\n\nnamespace std\n{\n    template&lt;&gt;\n    void swap(Base&amp; lha, Base&amp; rhs)\n    {\n       // ...\n    }\n}\n</code></pre>\n<p>this will work for Base classes, but if you try to swap two Derived objects it will use the generic version from std because the templated swap is an exact match (and it avoids the problem of only swapping the 'base' parts of your derived objects).</p>\n<p>NOTE: I've updated this to remove the wrong bits from my last answer. D'oh! (thanks puetzk and j_random_hacker for pointing it out)</p>\n", "OwnerUserId": "1367", "OwnerDisplayName": "Wilka"}, "11562": {"CommentCount": "0", "AcceptedAnswerId": "2684544", "PostTypeId": "1", "LastEditorUserId": "140719", "LastEditorDisplayName": "Brian R. Bondy", "CreationDate": "2008-08-14T19:24:17.260", "LastActivityDate": "2015-08-31T17:13:17.170", "AnswerCount": "4", "LastEditDate": "2013-03-22T18:30:07.997", "ViewCount": "23704", "FavoriteCount": "42", "Title": "How to overload std::swap()", "Id": "11562", "Score": "97", "Body": "<p><code>std::swap()</code> is used by many std containers (such as <code>std::list</code> and <code>std::vector</code>) during sorting and even assignment.</p>\n<p>But the std implementation of <code>swap()</code> is very generalized and rather inefficient for custom types.</p>\n<p>Thus efficiency can be gained by overloading <code>std::swap()</code> with a custom type specific implementation. But how can you implement it so it will be used by the std containers?</p>\n", "Tags": "<c++><performance><optimization><stl><c++-faq>", "OwnerUserId": "1366", "OwnerDisplayName": "Adam"}, "bq_ids": {"n4140": {"so_11562_109613_0": {"section_id": 6299, "quality": 0.5853658536585366, "length": 24}}, "n3337": {"so_11562_109613_0": {"section_id": 6056, "quality": 0.5853658536585366, "length": 24}}, "n4659": {"so_11562_109613_0": {"section_id": 7808, "quality": 0.5853658536585366, "length": 24}}}});