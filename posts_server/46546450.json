post_cb({"bq_ids": {"n4140": {"so_46546450_47854464_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 3296}, "so_46546450_47850802_1": {"length": 35, "quality": 0.8333333333333334, "section_id": 378}, "so_46546450_47854464_3": {"length": 8, "quality": 0.6666666666666666, "section_id": 5451}}, "n3337": {"so_46546450_47854464_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 3166}, "so_46546450_47850802_1": {"length": 29, "quality": 0.6904761904761905, "section_id": 369}, "so_46546450_47854464_3": {"length": 8, "quality": 0.6666666666666666, "section_id": 5541}}, "n4659": {"so_46546450_47854464_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 4058}, "so_46546450_47850802_0": {"length": 13, "quality": 1.0, "section_id": 392}, "so_46546450_47850802_1": {"length": 36, "quality": 0.8571428571428571, "section_id": 392}, "so_46546450_47854464_3": {"length": 9, "quality": 0.75, "section_id": 4799}, "so_46546450_46546450_0": {"length": 72, "quality": 0.935064935064935, "section_id": 394}}}, "46546450": {"ViewCount": "94", "Body": "<p>GCC 7.2 and Clang 5.0 do not agree in this case:</p>\n<pre><code>struct A;\n\nA foo();\n\nstruct A\n  {\n  static void bar()\n     {\n     foo();\n     }\n  private:\n  ~A()=default;\n  };\n\nA foo()\n  {\n  return {};\n  //GCC error: A::~A() is private in this context.\n  };\n</code></pre>\n<p>This behavior is part of the \"c++17 guaranteed (copy elision and is not related RVO or NRVO).\"</p>\n<p>GCC does not compile this code but Clang does. Which one is wrong?</p>\n<p>Maybe this paragraph says that the bot Clang and GCC are standard compliant [class.temporary]:</p>\n<blockquote>\n<p id=\"so_46546450_46546450_0\">When an object of class type X is passed to or returned from a function, if each copy constructor, move\n  constructor, and destructor of X is either trivial or deleted, and X has at least one non-deleted copy or move\n  constructor, implementations are permitted to create a temporary object to hold the function parameter or\n  result object. The temporary object is constructed from the function argument or return value, respectively,\n  and the function\u2019s parameter or return object is initialized as if by using the non-deleted trivial constructor\n  to copy the temporary (even if that constructor is inaccessible or would not be selected by overload resolution\n  to perform a copy or move of the object). [ Note: This latitude is granted to allow objects of class type to be\n  passed to or returned from functions in registers. \u2014 end note ]</p>\n</blockquote>\n", "Title": "Does an unmaterialized temporary needs the destructor to be accessible?", "CreationDate": "2017-10-03T13:59:23.790", "LastActivityDate": "2017-10-03T14:57:23.520", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-10-03T14:34:59.877", "LastEditorUserId": "5632316", "Id": "46546450", "Score": "4", "OwnerUserId": "5632316", "Tags": "<c++><c++1z><temporary>", "AnswerCount": "0"}});