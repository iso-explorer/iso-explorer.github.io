post_cb({"20208591": {"CommentCount": "7", "CreationDate": "2013-11-26T04:35:23.257", "PostTypeId": "1", "AcceptedAnswerId": "20211971", "LastEditorUserId": "2797826", "LastActivityDate": "2013-11-26T08:48:23.317", "LastEditDate": "2013-11-26T05:26:41.687", "ViewCount": "1369", "FavoriteCount": "3", "Title": "Wherefore inline unnamed namespaces?", "Id": "20208591", "Score": "15", "Body": "<p>A quick one for the gurus: C++11 allows unnamed namespaces to be declared <code>inline</code>. This seems redundant to me; things declared in an unnamed namespace are already used as if they were declared in the enclosing namespace.</p>\n<p>So my question is this: what does it mean to say</p>\n<pre><code>inline namespace /*anonymous*/ {\n    // stuff\n}\n</code></pre>\n<p>and how is it different from the traditional</p>\n<pre><code>namespace /*anonymous*/ {\n    // stuff\n}\n</code></pre>\n<p>that we know and love from C++98? Can anyone give an example of different behaviour when <code>inline</code> is used?</p>\n<p><strong>EDIT:</strong> Just to clarify, since this question has been marked as a duplicate: I'm not asking about <em>named</em> inline namespaces in general. I understand the use-case there, and I think they're great. I'm specifically asking what it means to declare an <em>unnamed</em> namespace as <code>inline</code>. Since unnamed namespaces are necessarily always local to a TU, the symbol versioning rational doesn't seem to apply, so I'm curious about what adding <code>inline</code> actually <em>does</em>.</p>\n<hr>\n<p>As an aside, the standard [7.3.1.1], regarding unnamed namespaces, says:</p>\n<blockquote>\n<p id=\"so_20208591_20208591_0\"><code>inline</code> appears if and only if it appears in the <em>unnamed-namespace-definition</em></p>\n</blockquote>\n<p>but this seems like a tautology to my non-language lawyer eyes -- \"it appears in the definition iff it appears in the definition\"! For bonus points, can anyone explain what this bit of standardese is actually saying?</p>\n<p><strong>EDIT:</strong> Cubbi claimed the bonus point in the comments:</p>\n<blockquote>\n<p id=\"so_20208591_20208591_1\">the standard is saying that <em>unnamed-namespace-definition</em> behaves as if it were replaced by <strong>X</strong> where <code>inline</code> appears in <strong>X</strong> iff it appears in the <em>unnamed-namespace-definition</em></p>\n</blockquote>\n</hr>", "Tags": "<c++><c++11><namespaces><inline-namespaces>", "OwnerUserId": "2797826", "AnswerCount": "2"}, "20212062": {"ParentId": "20208591", "CommentCount": "0", "Body": "<p>I don't know whether it's the done thing to answer your own question on SO, but after some playing around my curiosity has been satisfied, so I may as well share it.</p>\n<p>The definition of an inline namespace includes not only the hoisting of names into the enclosing namespace (which happens anyway for unnamed namespaces), but also allows templates defined within an inline namespace to be specialised outside it. It turns out that this applies to unnamed namespaces too:</p>\n<pre><code>inline // comment this out to change behaviour\nnamespace { \n    template &lt;typename T&gt; struct A {};\n}\n\ntemplate &lt;&gt; struct A&lt;int&gt; {};\n</code></pre>\n<p>Without the <code>inline</code>, g++ complains about trying to specialise a template from a different namespace (though Clang does not). With <code>inline</code>, it compiles just fine. With both compilers, anything defined within the specialisation is still marked as having <em>internal linkage</em> (according to <code>nm</code>), as if it were within the unnamed namespace, but I guess this is to be expected. I can't really think of any reason why this would be useful, but there we go.</p>\n<p>An arguably more useful effect comes from the change regarding <em>argument-dependent lookup</em> for inline namespaces, which also affects unnamed inline namespaces. Consider the following case:</p>\n<pre><code>namespace NS {\n    // Pretend this is defined in some header file\n    template &lt;typename T&gt;\n    void func(const T&amp;) {}\n\n    // Some type definition private to this TU\n    inline namespace {\n        struct A {};\n    }\n\n} // end namespace NS\n\nint main()\n{\n    NS::A a;\n    func(a);\n}\n</code></pre>\n<p>Without <code>inline</code>, ADL fails and we have to explicitly write <code>NS::func(a)</code>. Of course, if we defined the unnamed namespace at the toplevel (as one normally would), then we wouldn't get ADL whether it was inline or not, but still...</p>\n", "OwnerUserId": "2797826", "PostTypeId": "2", "Id": "20212062", "Score": "6", "CreationDate": "2013-11-26T08:41:48.723", "LastActivityDate": "2013-11-26T08:41:48.723"}, "bq_ids": {"n4140": {"so_20208591_20208591_0": {"section_id": 5482, "quality": 1.0, "length": 4}, "so_20208591_20208591_1": {"section_id": 5482, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_20208591_20208591_0": {"section_id": 5268, "quality": 1.0, "length": 4}, "so_20208591_20208591_1": {"section_id": 5268, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_20208591_20208591_0": {"section_id": 6917, "quality": 1.0, "length": 4}, "so_20208591_20208591_1": {"section_id": 6917, "quality": 0.8181818181818182, "length": 9}}}, "20211971": {"ParentId": "20208591", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Here is one use that I have found:</p>\n<pre><code>namespace widgets { inline namespace {\n\nvoid foo();\n\n} } // namespaces\n\nvoid widgets::foo()\n{\n}\n</code></pre>\n<p>In this example, <code>foo</code> has internal linkage and we can define the function later on by using the <code>namespace::function</code> syntax to ensure that the function's signature is correct. If you were to not use the <code>widgets</code> namespace then the <code>void foo()</code> definition would define a totally different function. You also don't need to re-open the namespace saving you a level of indentation.</p>\n<p>If there is another function called <code>foo</code> in the widgets <code>namespace</code> already then this will give you an ambiguity instead rather than a nasty ODR violation.</p>\n", "OwnerUserId": "2491746", "LastEditorUserId": "2491746", "LastEditDate": "2013-11-26T08:48:23.317", "Id": "20211971", "Score": "5", "CreationDate": "2013-11-26T08:35:40.617", "LastActivityDate": "2013-11-26T08:48:23.317"}});