post_cb({"47577123": {"ParentId": "47573564", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Yes, MSVC's <code>std::async</code> seem to have exactly that property, at least as of MSVC2015.</p>\n<p>I don't know if they fixed it in an 2017 update.</p>\n<p>This is against the spirit of the standard.  However, the standard is extremely vague about thread forward progress guarantees (at least as of C++14).  So while <code>std::async</code> must behave as if it wraps a <code>std::thread</code>, the guarantees on <code>std::thread</code> forward progress are sufficiently weak that this isn't much of a guarantee under the as-if rule.</p>\n<p>In practice, this has led me to replace <code>std::async</code> in my thread pool implementations with raw calls to <code>std::thread</code>, as raw use of <code>std::thread</code> in MSVC2015 doesn't appear to have that problem.</p>\n<p>I find that a thread pool (with a task queue) is far more practical than raw calls to either <code>std::async</code> or <code>std::thread</code>, and as it is really easy to write a thread pool with either <code>std::thread</code> or <code>std::async</code>, I'd advise writing one with <code>std::thread</code>.</p>\n<p>Your thread pool can return <code>std::future</code>s just like <code>std::async</code> does (but without the auto-blocking on destruction feature, as the pool itself manages the thread lifetimes).</p>\n<p>I have read that C++17 added better forward progress guarantees, but I lack sufficient understanding to conclude if MSVC's behavior is now against the standard requirements.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2017-11-30T15:42:17.897", "Id": "47577123", "Score": "0", "CreationDate": "2017-11-30T15:36:37.713", "LastActivityDate": "2017-11-30T15:42:17.897"}, "47574759": {"ParentId": "47573564", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The standard reads:</p>\n<blockquote>\n<p id=\"so_47573564_47574759_0\">[<a href=\"https://timsong-cpp.github.io/cppwp/futures.async#3.1\" rel=\"nofollow noreferrer\">futures.async#3.1</a>] If launch\u200b::\u200basync is set in policy, calls <code>INVOKE(DECAY_\u00adCOPY(std\u200b::\u200bforward&lt;F&gt;(f)), DECAY_\u00adCOPY(std\u200b::\u200bforward&lt;Args&gt;(args))...)</code> ([func.require], [thread.thread.constr]) <strong>as if in a new thread of execution represented by a thread object with the calls to DECAY_\u00adCOPY being evaluated in the thread that called async.</strong>[...]</p>\n</blockquote>\n<p>so, under the <em>as-if</em> rule, <strong>new</strong> threads must be spawned when <code>async()</code> is invoked with <code>\u200basync</code> launch policy. Of course, an implementation may use a thread pool internally but, usual thread creation overhead aside, no special 'starving' can occur. Moreover, things like the initialization of thread locals should always happen.</p>\n<p>In fact, clang libc++ trunk async implementation reads:</p>\n<pre><code>unique_ptr&lt;__async_assoc_state&lt;_Rp, _Fp&gt;, __release_shared_count&gt;\n        __h(new __async_assoc_state&lt;_Rp, _Fp&gt;(_VSTD::forward&lt;_Fp&gt;(__f)));\n\nVSTD::thread(&amp;__async_assoc_state&lt;_Rp, _Fp&gt;::__execute, __h.get()).detach();\n\nreturn future&lt;_Rp&gt;(__h.get());\n</code></pre>\n<p>as you can see, no 'explicit' thread pool is used internally.</p>\n<p>Moreover, as you can read <a href=\"https://gcc.gnu.org/onlinedocs/gcc-5.4.0/libstdc++/api/a01286_source.html#1654\" rel=\"nofollow noreferrer\">here</a> also the libstdc++ implementation shipping with gcc 5.4.0 just invokes a plain thread.</p>\n", "OwnerUserId": "8631381", "LastEditorUserId": "2069064", "LastEditDate": "2017-11-30T16:30:47.670", "Id": "47574759", "Score": "2", "CreationDate": "2017-11-30T13:34:47.213", "LastActivityDate": "2017-11-30T16:30:47.670"}, "bq_ids": {"n4140": {"so_47573564_47574759_0": {"section_id": 3161, "quality": 0.6818181818181818, "length": 15}}, "n3337": {"so_47573564_47574759_0": {"section_id": 3034, "quality": 0.6818181818181818, "length": 15}}, "n4659": {"so_47573564_47574759_0": {"section_id": 3923, "quality": 0.7272727272727273, "length": 16}}}, "47573564": {"CommentCount": "2", "ViewCount": "69", "CreationDate": "2017-11-30T12:31:28.103", "LastActivityDate": "2017-11-30T16:30:47.670", "Title": "Can long-running std::asyncs starve other std::asyncs?", "AcceptedAnswerId": "47574759", "PostTypeId": "1", "Id": "47573564", "Score": "3", "Body": "<p>As I understand it, usual implementations of std::async schedule these jobs on threads from a pre-allocated thread pool.</p>\n<p>So lets say I first create and schedule enough long-running <code>std::async</code>s to keep all threads from that thread pool occupied. Directly afterwards (before long they finished executing) I also create and schedule some short-running <code>std::async</code>s. Could it happen that the short-running ones aren't executed at all until at least one of the long-running ones has finished? Or is there some guarantee in the standard (specifically C++11) that prevents this kind of situation (like spawning more threads so that the OS can schedule them in a round-robin fasion)?</p>\n", "Tags": "<c++><multithreading><c++11><asynchronous><stdasync>", "OwnerUserId": "3736861", "AnswerCount": "2"}});