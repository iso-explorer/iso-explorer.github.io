post_cb({"15780011": {"CommentCount": "6", "AcceptedAnswerId": "15780493", "PostTypeId": "1", "LastEditorUserId": "1349295", "CreationDate": "2013-04-03T06:07:24.177", "LastActivityDate": "2013-04-03T13:21:39.733", "LastEditDate": "2013-04-03T06:26:47.997", "ViewCount": "347", "FavoriteCount": "1", "Title": "resolve address from overloaded function std::real<float>", "Id": "15780011", "Score": "7", "Body": "<pre><code>std::vector&lt;std::complex&lt;float&gt; &gt; c;\nstd::vector&lt;float&gt; d;\nstd::transform(c.begin(), c.end(), d.begin(), std::real&lt;float&gt;);\n</code></pre>\n<p>Why couldn't the compiler resolve the address from the overloaded function <code>real&lt;float&gt;</code>?</p>\n<p>Which overloaded functions does the compiler mean? </p>\n", "Tags": "<c++><algorithm><stl><overloading>", "OwnerUserId": "2238965", "AnswerCount": "2"}, "15780493": {"ParentId": "15780011", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Your library implementation has provided additional overloads for <code>std::real&lt;float&gt;</code>. </p>\n<h2>Why the overloads?</h2>\n<blockquote>\n<h3>26.4.9 Additional overloads [cmplx.over]</h3>\n<ul>\n<li><p id=\"so_15780011_15780493_0\">1 The following function templates shall have additional overloads:</p>\n<pre><code>arg norm\nconj proj\nimag real\n</code></pre></li>\n<li>2 The additional overloads shall be sufficient to ensure:\n  <ol>\n<li>If the argument has type <code>long double</code>, then it is effectively cast to <code>complex&lt;long double&gt;</code>.</li>\n<li>Otherwise, if the argument has type <code>double</code> or an integer type, then it is effectively cast to <code>complex&lt;double&gt;</code>.</li>\n<li>Otherwise, if the argument has type <code>float</code>, then it is effectively cast to <code>complex&lt;float&gt;</code>.</li>\n</ol></li>\n</ul>\n<p id=\"so_15780011_15780493_1\">[...]</p>\n</blockquote>\n<h2>Solutions to problem:</h2>\n<p>You could just use a range based for ...</p>\n<pre><code>for (auto v : c) d.push_back(real(v));\n</code></pre>\n<p>... or pack the call to <code>real</code> into a functor or another function ...</p>\n<pre><code>struct my_caller {\n    template &lt;typename T&gt; T operator() (std::complex&lt;T&gt; const &amp;c) {\n        return real(c);\n    }\n};\n</code></pre>\n<p>... or use the member function ...</p>\n<pre><code>std::transform(c.begin(), c.end(), d.begin(), [](std::complex&lt;T&gt; const &amp;c) { \n    return c.real();\n});\n</code></pre>\n<hr>\n<p>IMPORTANT:</p>\n<p>Note that you have to have enough space in the target when using <code>transform</code>:</p>\n<pre><code>std::vector&lt;float&gt; d (c.size());\n</code></pre>\n<p>or use a back inserter:</p>\n<pre><code>std::transform(c.begin(), c.end(), back_inserter(d), ...);\n</code></pre>\n<p>Otherwise you are iterating over undefined memory, yielding undefined behaviour.</p>\n</hr>", "OwnerUserId": "76722", "LastEditorUserId": "15416", "LastEditDate": "2013-04-03T13:21:39.733", "Id": "15780493", "Score": "5", "CreationDate": "2013-04-03T06:40:05.887", "LastActivityDate": "2013-04-03T13:21:39.733"}, "15780737": {"ParentId": "15780011", "CommentCount": "0", "Body": "<p><strong>\u00a726.4.9</strong> states that (amongst others), <code>real</code> shall have additional overloads, for arguments of type float, double and long double. It seems your libraray implementation made a template for these overloads, maybe like</p>\n<pre><code>template &lt;typename T&gt;\nT real(T const&amp; t)\n{\n  return std::real(std::complex&lt;T&gt;{t});\n}\n</code></pre>\n<p>In addition to the solutions phresnel priovided, you could explicitly tell the compiler which kind of function pointer you mean:</p>\n<pre><code>std::transform(c.begin(), c.end(), d.begin(), (float(*)(std::complex&lt;float&gt; const&amp;))std::real&lt;float&gt;);\n</code></pre>\n<p>The compiler then looks for a <code>std::real</code> that can be converted into a function pointer of the given type and will find the correct one.</p>\n<p>I tell you this only for completeness - I consider this explicit cast ugly and would prefer the ranged based for or transform with a lambda.</p>\n", "OwnerUserId": "1838266", "PostTypeId": "2", "Id": "15780737", "Score": "4", "CreationDate": "2013-04-03T06:55:07.673", "LastActivityDate": "2013-04-03T06:55:07.673"}, "bq_ids": {"n4140": {"so_15780011_15780493_0": {"section_id": 3474, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_15780011_15780493_0": {"section_id": 3343, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_15780011_15780493_0": {"section_id": 4238, "quality": 0.8571428571428571, "length": 6}}}});