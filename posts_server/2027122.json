post_cb({"2027141": {"ParentId": "2027122", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-01-08T11:12:05.773", "Score": "2", "LastEditorUserId": "60281", "LastEditDate": "2010-01-08T11:28:43.117", "Id": "2027141", "OwnerUserId": "207716", "Body": "<p>Yes, it's not possible to take the address of a reference. You always get the address of the referred object.</p>\n", "LastActivityDate": "2010-01-08T11:28:43.117"}, "2027235": {"ParentId": "2027122", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2010-01-08T11:32:13.017", "Score": "9", "LastEditorUserId": "125672", "LastEditDate": "2010-01-08T13:17:53.243", "Id": "2027235", "OwnerUserId": "125672", "Body": "<p>First sentence of standard 8.3.2/4:</p>\n<blockquote>\n<p id=\"so_2027122_2027235_0\">There shall be no references to\n  references, no arrays of references,\n  and <strong>no pointers to references</strong></p>\n</blockquote>\n<p>(My emphasis)</p>\n<p>This doesn't mean you can't take the address of a variable declared as a reference, it just means that there's no separate type for a pointer to a reference.</p>\n", "LastActivityDate": "2010-01-08T13:17:53.243"}, "2027153": {"ParentId": "2027122", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-01-08T11:15:02.553", "Score": "2", "LastEditorUserId": "60281", "LastEditDate": "2010-01-08T11:29:21.943", "Id": "2027153", "OwnerUserId": "221955", "Body": "<p>Yes it is equivalent.\nTaking the address of a reference returns the address of the original thing.\nSince there is no way to get any other address out of a reference, \nthere is no seperate type for a pointer to a reference.</p>\n", "LastActivityDate": "2010-01-08T11:29:21.943"}, "bq_ids": {"n4140": {"so_2027122_2027235_0": {"section_id": 3222, "quality": 1.0, "length": 7}}, "n3337": {"so_2027122_2027235_0": {"section_id": 3096, "quality": 1.0, "length": 7}}, "n4659": {"so_2027122_2027235_0": {"section_id": 3979, "quality": 1.0, "length": 7}}}, "2027122": {"CommentCount": "0", "ViewCount": "203", "CreationDate": "2010-01-08T11:08:00.767", "LastActivityDate": "2010-01-08T13:17:53.243", "Title": "Can Pointer to reference and Pointer to the actual variable be treated as same?", "FavoriteCount": "1", "PostTypeId": "1", "Id": "2027122", "Score": "5", "Body": "<p>I recently saw the below code ( simplified version given below) in my code base and got this doubt:</p>\n<pre><code>class B;\nclass A\n{\n  public:\n     A():m_A(\"testA\"){}\n     B&amp; getB()\n     {\n       return m_B;\n     }\n     B* getBPtr() //== &gt; written to explain the problem clearly\n     {\n       return &amp;m_B;\n     }\nprivate:\n    B m_B;\n};\n\nclass B\n{\n  public:\n    B(const std::string&amp; name):m_Name(name){}\n    std::string getName() const\n    {\n      return m_Name;\n    }\nprivate:\n    std::string m_Name;\n};\n\nclass C\n{\n public:\n   void testFunc(B* ptr)\n   {\n   }\n};\n\n\nint main()\n{\n  A a;\n  C c;\n c.testFunc(&amp;a.getB()); ===&gt; is it equivalent to c.testFunc(a.getBPtr()) ?\n}\n</code></pre>\n<ol>\n<li>The pointer to reference and pointer to actual variable can be treated as same?</li>\n<li>Does standard says anything on the address of reference to be interchangeable used for address of variable. </li>\n</ol>\n", "Tags": "<c++><reference>", "OwnerUserId": "64960", "AnswerCount": "3"}});