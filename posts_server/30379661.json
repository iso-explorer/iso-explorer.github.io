post_cb({"30379661": {"CommentCount": "4", "ViewCount": "122", "PostTypeId": "1", "LastEditorUserId": "3545273", "CreationDate": "2015-05-21T16:42:00.833", "LastActivityDate": "2015-07-01T22:45:05.370", "Title": "Is modifying the pointed value and the pointer at the same time UB", "AcceptedAnswerId": "30379834", "LastEditDate": "2015-05-21T20:42:33.790", "Id": "30379661", "Score": "1", "Body": "<p>I know that C and C++ and different languages, but the following applies to both.</p>\n<p><strong>TL/DR</strong></p>\n<p>I know that <code>i = i++;</code> is UB, because i is modified twice in the expression and C and C++ forbids it.</p>\n<p>References :</p>\n<blockquote>\n<p id=\"so_30379661_30379661_0\">C99 6.5 :</p>\n<p id=\"so_30379661_30379661_1\">If a side effect on a scalar object is unsequenced relative to either a different side effect\n  on the same scalar object or a value computation using the value of the same scalar\n  object, the behavior is undefined. If there are multiple allowable orderings of the\n  subexpressions of an expression, the behavior is undefined if such an unsequenced side\n  effect occurs in any of the orderings</p>\n<p id=\"so_30379661_30379661_2\">C++ 11 - 1.9 15 : </p>\n<p id=\"so_30379661_30379661_3\">If a side effect on a scalar\n  object is unsequenced relative to either another side effect on the same scalar object or a value computation\n  using the value of the same scalar object, and they are not potentially concurrent, the behavior is\n  undefined.</p>\n</blockquote>\n<p>So I understand that <code>*i = *i++ + *j++;</code> causes UB, because post incrementation on <code>i</code> and affectation to <code>*i</code> may be unsequenced, and CLang issues a warning in C or C++ mode : <em>warning: unsequenced modification and access to 'i' [-Wunsequenced] <code>*i = *i++ + *j++;</code></em></p>\n<p>But I do not understand the same warning on  <code>*i++ = *i + *j++;</code>. Because here, we first compute the right part, affect it, and increment after the affectation.</p>\n<p>And specs for both language say (same paragraph, just above) :</p>\n<blockquote>\n<p id=\"so_30379661_30379661_4\">The value computations of the operands of an operator\n  are sequenced before the value computation of the result of the operator</p>\n</blockquote>\n<p><strong>END TL/DR</strong></p>\n<p>So the question is :</p>\n<p>Is this line</p>\n<pre><code>*i++ = *i + *j++;\n</code></pre>\n<p>undefined behaviour, or is Clang (version 3.4.1) too conservative in issuing a warning on it ?</p>\n", "Tags": "<c++><c><language-lawyer><undefined-behavior>", "OwnerUserId": "3545273", "AnswerCount": "2"}, "30379834": {"ParentId": "30379661", "CommentCount": "2", "Body": "<p>The reason both</p>\n<pre><code>*i = *i++ + *j++;\n</code></pre>\n<p>and</p>\n<pre><code>*i++ = *i + *j++;\n</code></pre>\n<p>are undefined is that you are attempting to use the pointer <code>i</code> in an expression that's a value computation (dereference, <code>*i</code>) and an expression with a side effect (dereference and increment, <code>*i++</code>) without an intervening sequence point.  Remember <code>*i++</code> is evaluated as <code>*(i++)</code>; you're incrementing the pointer value, not the thing being pointed to.</p>\n", "OwnerUserId": "134554", "PostTypeId": "2", "Id": "30379834", "Score": "2", "CreationDate": "2015-05-21T16:51:09.373", "LastActivityDate": "2015-05-21T16:51:09.373"}, "bq_ids": {"n4140": {"so_30379661_30379661_1": {"section_id": 5811, "quality": 0.5833333333333334, "length": 21}, "so_30379661_30379661_4": {"section_id": 5811, "quality": 0.9090909090909091, "length": 10}, "so_30379661_30379661_3": {"section_id": 5811, "quality": 1.0, "length": 25}}, "n3337": {"so_30379661_30379661_1": {"section_id": 5584, "quality": 0.5833333333333334, "length": 21}, "so_30379661_30379661_4": {"section_id": 5584, "quality": 0.9090909090909091, "length": 10}, "so_30379661_30379661_3": {"section_id": 5584, "quality": 0.8, "length": 20}}, "n4659": {"so_30379661_30379661_4": {"section_id": 7272, "quality": 0.9090909090909091, "length": 10}, "so_30379661_30379661_3": {"section_id": 7272, "quality": 0.76, "length": 19}}}, "30384728": {"ParentId": "30379661", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Given <code>x = *i + *i++;</code> it would be legitimate for the sub-expression <code>i++</code> to be broken down into seven pieces:</p>\n<ol>\n<li>Capture the state of the pointer for the *i++ part of the expression</li>\n<li>Read that address</li>\n<li>Capture the state of the pointer for the *i part of the expression</li>\n<li>Read that address</li>\n<li>Add the two values read</li>\n<li>Store the result in X.</li>\n<li>Put the pointer into an invalid state (e.g. for pointers larger than <code>int</code>, start by incrementing the bottom half, which might wrap)</li>\n<li>Put the pointer into a valid state which identifies the next object (finish writing an updated pointer value)</li>\n</ol>\n<p>Steps #1 must be first, and must precede #7, which must in turn precede #8, but the compiler may rearrange any or all of the operations #2-#6 so they occur before, after, or between #7 and #8.  Nothing in the Standard would require a compiler to make any effort to ensure that all other accesses to that same pointer will occur before #7 or after #8; if a compiler does happen to put a different access between steps #7 and #8, there's no telling what the consequences of using the temporarily-invalid pointer might be.</p>\n", "OwnerUserId": "363751", "LastEditorUserId": "363751", "LastEditDate": "2015-07-01T22:45:05.370", "Id": "30384728", "Score": "0", "CreationDate": "2015-05-21T21:31:40.553", "LastActivityDate": "2015-07-01T22:45:05.370"}});