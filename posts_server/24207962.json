post_cb({"bq_ids": {"n4140": {"so_24207962_24208281_0": {"length": 20, "quality": 0.6896551724137931, "section_id": 481}}, "n3337": {"so_24207962_24208281_0": {"length": 29, "quality": 1.0, "section_id": 472}}, "n4659": {"so_24207962_24208281_0": {"length": 16, "quality": 0.5517241379310345, "section_id": 504}}}, "24208281": {"Id": "24208281", "PostTypeId": "2", "Body": "<p>12.8 <strong>[class.copy]</strong>:</p>\n<blockquote>\n<p id=\"so_24207962_24208281_0\">32 - When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. [...]</p>\n</blockquote>\n<p>NRVO permits copy elision, so <code>temp</code> is treated as an rvalue.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2014-06-13T14:59:57.147", "Score": "4", "CreationDate": "2014-06-13T14:53:35.700", "ParentId": "24207962", "CommentCount": "2", "OwnerUserId": "567292", "LastEditDate": "2014-06-13T14:59:57.147"}, "24207962": {"ViewCount": "56", "Body": "<p>Recently someone asked me a question about the constructing of a return value of a function. After a few of discussions I found that something seems not right. Here is the sample:</p>\n<pre><code>#include &lt;conio.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n\n/*\nstruct A // Won't be compiled\n{\n    A(void) {};\n    A(const A &amp;) {};\n    A(A &amp;&amp;) = delete;\n};\n*/\n\nstruct A // Compiled but...\n{\n    A(void) {};\n    A(const A &amp;) = delete;\n    A(A &amp;&amp;) {};\n};\n\nA func(void)\n{\n    A temp;\n\n    return temp;// 'temp' is a named object, so it should be a lvalue and the A(const A &amp;) should have been invoked.\n    //return std::move(temp); // OK.\n}\n\nint main(void)\n{\n    func();\n\n    _getch();\n    return(0);\n}\n</code></pre>\n<p>It will be compiled (either by VC or by gcc)... But it looks wrong.</p>\n<p>The question is: Even any copy-deducing condition has been triggered, There seems no reason to let the 'A(const A &amp;)' be ignored, isn't it?</p>\n", "AcceptedAnswerId": "24208281", "Title": "A code which seems wrong being compiled (about object return)", "CreationDate": "2014-06-13T14:39:37.657", "Id": "24207962", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2014-06-13T14:59:57.147", "Score": "2", "OwnerUserId": "2848654", "Tags": "<c++><return-value-optimization>", "AnswerCount": "1"}});