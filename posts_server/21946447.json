post_cb({"21946711": {"ParentId": "21946447", "LastEditDate": "2014-02-21T22:57:50.963", "CommentCount": "1", "CreationDate": "2014-02-21T22:46:59.077", "OwnerUserId": "2445184", "LastEditorUserId": "2445184", "PostTypeId": "2", "Id": "21946711", "Score": "4", "Body": "<p>The <code>snprintf()</code> version will almost certainly be quite a bit faster. Why? Simply because no memory allocation takes place. The <code>new</code> operator is surprisingly expensive, roughly 250ns on my system - <code>snprintf()</code> will have finished quite a bit of work in the meantime.</p>\n<p>That is not to say that you should use the <code>snprintf()</code> approach: The price you pay is safety. It is just so easy to get things wrong with the fixed buffer size you are supplying to <code>snprintf()</code>, and you absolutely need to supply code for the case that the buffer is not large enough. So, only think about using <code>snprintf()</code> when you have identified this part of code to be really performance critical.</p>\n<p>If you have a POSIX-2008 compliant system, you may also think about trying <code>asprintf()</code> instead of <code>snprintf()</code>, it will <code>malloc()</code> the memory for you, giving you pretty much the same comfort as C++ <code>string</code>s. At least on my system, <code>malloc()</code> is quite a bit faster than the builtin <code>new</code>-operator (don't ask me why, though).</p>\n<hr>\n<p>Edit:<br>\nJust saw, that you used filenames in your example. If filenames are your concern, forget about the performance of string operation! Your code will spend virtually no time in them. Unless you have on the order of 100000 such string operations <em>per second</em>, they are irrelevant to your performance.</br></p>\n</hr>", "LastActivityDate": "2014-02-21T22:57:50.963"}, "21946486": {"ParentId": "21946447", "LastEditDate": "2014-02-21T22:38:47.727", "CommentCount": "1", "CreationDate": "2014-02-21T22:28:35.980", "OwnerUserId": "1919155", "LastEditorUserId": "1919155", "PostTypeId": "2", "Id": "21946486", "Score": "2", "Body": "<p>If it's REALLY important, measure the two solutions. If not, whichever you think makes most sense from what data you have, company/private coding style standards, etc. Make sure you use an optimised build [with the same optimisation you are going to use in the actual production build, not -O3 because that is the highest, if your production build is using -O1]</p>\n<p>I expect that either will be pretty close if you only do a few. If you have several millions, there may be a difference. Which is faster? I'd guess the second [1], but it depends on who wrote the implementation of <code>snprintf</code> and who wrote the <code>std::string</code> implementation. Both certainly have the potential to take a lot longer than you would expect from a naive approach to how the function works (and possibly also run faster than you'd expect)</p>\n<p>[1] Because I have worked with printf, and it's not a simple function, it spends a lot of time messing about with various groking of the format string. It's not very efficient (and I have looked at the ones in glibc and such too, and they are not noticeably better). \nOn the other hand <code>std::string</code> functions are often inlined since they are template implementations, which improves the efficiency. The joker in the pack is whether the memory allocation for <code>std::string</code> that is likely to happen. Of course, if somehow <code>baselocation</code> turns to be rather large, you probably don't want to store it as a fixed size local array anyway, so that evens out in that case. </p>\n", "LastActivityDate": "2014-02-21T22:38:47.727"}, "21946709": {"ParentId": "21946447", "LastEditDate": "2015-08-10T16:03:30.737", "CommentCount": "5", "CreationDate": "2014-02-21T22:46:51.183", "OwnerUserId": "27678", "LastEditorUserId": "27678", "PostTypeId": "2", "Id": "21946709", "Score": "15", "Body": "<p>Let's run the numbers:</p>\n<p>The code (I used <a href=\"http://icl.cs.utk.edu/projects/papi/wiki/Timers\">PAPI</a> Timers)</p>\n<h3>main.cpp</h3>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;stdio.h&gt;\n#include \"papi.h\"\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n#define TRIALS 10000000\n\nclass Clock\n{\n  public:\n    typedef long_long time;\n    time start;\n    Clock() : start(now()){}\n    void restart(){ start = now(); }\n    time usec() const{ return now() - start; }\n    time now() const{ return PAPI_get_real_usec(); }\n};\n\n\nint main()\n{\n  int eventSet = PAPI_NULL;\n  PAPI_library_init(PAPI_VER_CURRENT);\n  if(PAPI_create_eventset(&amp;eventSet)!=PAPI_OK) \n  {\n    std::cerr &lt;&lt; \"Failed to initialize PAPI event\" &lt;&lt; std::endl;\n    return 1;\n  }\n\n  Clock clock;\n  std::vector&lt;long_long&gt; usecs;\n\n  const char* baseLocation = \"baseLocation\";\n  //std::string baseLocation = \"baseLocation\";\n  char fname[255] = {};\n  for (int i=0;i&lt;TRIALS;++i)\n  {\n    clock.restart();\n    snprintf(fname, 255, \"%s_test_no.%d.txt\", baseLocation, i);\n    //std::string fname = baseLocation + \"_test_no.\" + std::to_string(i) + \".txt\";\n    usecs.push_back(clock.usec());\n  }\n\n  long_long sum = 0;\n  for(auto vecIter = usecs.begin(); vecIter != usecs.end(); ++vecIter)\n  {\n    sum+= *vecIter;\n  }\n\n  double average = static_cast&lt;double&gt;(sum)/static_cast&lt;double&gt;(TRIALS);\n  std::cout &lt;&lt; \"Average: \" &lt;&lt; average &lt;&lt; \" microseconds\" &lt;&lt; std::endl;\n\n  //compute variance\n  double variance = 0;\n  for(auto vecIter = usecs.begin(); vecIter != usecs.end(); ++vecIter)\n  {\n    variance += (*vecIter - average) * (*vecIter - average);\n  }\n\n  variance /= static_cast&lt;double&gt;(TRIALS);\n  std::cout &lt;&lt; \"Variance: \" &lt;&lt; variance &lt;&lt; \" microseconds\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"Std. deviation: \" &lt;&lt; sqrt(variance) &lt;&lt; \" microseconds\" &lt;&lt; std::endl;\n  double CI = 1.96 * sqrt(variance)/sqrt(static_cast&lt;double&gt;(TRIALS));\n  std::cout &lt;&lt; \"95% CI: \" &lt;&lt; average-CI &lt;&lt; \" usecs to \" &lt;&lt; average+CI &lt;&lt; \" usecs\" &lt;&lt; std::endl;  \n}\n</code></pre>\n<p>Play with the comments to get one way or the other.\n10 million iterations of both methods on my machine with the compile line:</p>\n<blockquote>\n<p id=\"so_21946447_21946709_0\">g++ main.cpp -lpapi -DUSE_PAPI -std=c++0x -O3</p>\n</blockquote>\n<p>Using char array:</p>\n<pre><code>Average: 0.240861 microseconds\nVariance: 0.196387microseconds\nStd. deviation: 0.443156 microseconds\n95% CI: 0.240586 usecs to 0.241136 usecs\n</code></pre>\n<p>Using string approach:</p>\n<pre><code>Average: 0.365933 microseconds\nVariance: 0.323581 microseconds\nStd. deviation: 0.568842 microseconds\n95% CI: 0.365581 usecs to 0.366286 usecs\n</code></pre>\n<p>So at least on MY machine with MY code and MY compiler settings, <s>I saw about a 50% slowdown when moving to strings.</s> that character arrays incur a 34% speedup over strings using the following formula:</p>\n<blockquote>\n<p id=\"so_21946447_21946709_1\">((time for string) - (time for char array) ) / (time for string) </p>\n</blockquote>\n<p>Which gives the difference in time between the approaches as a percentage on time for string alone. My original percentage was correct; I used the character array approach as a reference point instead, which shows a 52% slowdown when moving to string, but I found it misleading.</p>\n<p>I'll take any and all comments for how I did this wrong :)</p>\n<hr>\n<h2>Edit: Compiled with GCC 4.8.4:</h2>\n<h3>string</h3>\n<pre><code>Average: 0.338876 microseconds\nVariance: 0.853823 microseconds\nStd. deviation: 0.924026 microseconds\n95% CI: 0.338303 usecs to 0.339449 usecs\n</code></pre>\n<h3>character array</h3>\n<pre><code>Average: 0.239083 microseconds\nVariance: 0.193538 microseconds\nStd. deviation: 0.439929 microseconds\n95% CI: 0.238811 usecs to 0.239356 usecs\n</code></pre>\n<p>So the character array approach remains significantly faster although less so. In these tests, it was about 29% faster.</p>\n</hr>", "LastActivityDate": "2015-08-10T16:03:30.737"}, "bq_ids": {"n4140": {"so_21946447_21946709_1": {"section_id": 550, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_21946447_21946709_1": {"section_id": 541, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_21946447_21946709_1": {"section_id": 571, "quality": 0.5714285714285714, "length": 4}}}, "21946447": {"CommentCount": "2", "CreationDate": "2014-02-21T22:24:56.167", "PostTypeId": "1", "AcceptedAnswerId": "21946709", "LastEditorUserId": "809387", "LastActivityDate": "2015-08-10T16:03:30.737", "LastEditDate": "2014-02-21T22:42:59.997", "ViewCount": "7227", "FavoriteCount": "2", "Title": "How much performance difference when using string vs char array?", "Id": "21946447", "Score": "3", "Body": "<p>I have the following code:</p>\n<pre><code>char fname[255] = {0}\nsnprintf(fname, 255, \"%s_test_no.%d.txt\", baseLocation, i);\n</code></pre>\n<p>vs</p>\n<pre><code>std::string fname = baseLocation + \"_test_no.\" + std::to_string(i) + \".txt\";\n</code></pre>\n<p>Which one performs better? Does the second one involve temporary creation? Is there any better way to do this?</p>\n", "Tags": "<c++><std>", "OwnerUserId": "1270003", "AnswerCount": "3"}});