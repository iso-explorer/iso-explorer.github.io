post_cb({"44475329": {"ParentId": "44475056", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2017-06-10T15:57:36.200", "Score": "17", "LastEditorUserId": "3980929", "LastEditDate": "2017-06-10T18:42:08.027", "Id": "44475329", "OwnerUserId": "951890", "Body": "<p>This appears to be a bug in Clang.  I believe the code is correct.</p>\n<p>Clang 4.0.0 reports:</p>\n<pre><code>&lt;source&gt;:13:16: error: unknown type name 'p'; did you mean 'S::p'?\n    s.operator p()();\n           ^\n</code></pre>\n<p>However, from C++14 3.4.5/7 [basic.lookup.classref]</p>\n<blockquote>\n<p id=\"so_44475056_44475329_0\">If the id-expression is a conversion-function-id, its conversion-type-id is first looked up in the class of the\n  object expression and the name, if found, is used. Otherwise it is looked up in the context of the entire\n  postfix-expression. In each of these lookups, only names that denote types or templates whose specializations\n  are types are considered.</p>\n<p id=\"so_44475056_44475329_1\">[ Example:</p>\n<pre><code>struct A { };\nnamespace N {\nstruct A {\n    void g() { }\n    template &lt;class T&gt; operator T();\n};\n}\n\n\nint main() {\n    N::A a;\n    a.operator A();\n       // calls N::A::operator N::A\n}\n</code></pre>\n<p id=\"so_44475056_44475329_2\">\u2014 end example ]</p>\n</blockquote>\n<p>In your example, the type <code>p</code> should have been found in the class without requiring qualification.</p>\n", "LastActivityDate": "2017-06-10T18:42:08.027"}, "44475056": {"CommentCount": "6", "AcceptedAnswerId": "44475329", "PostTypeId": "1", "LastEditorUserId": "4532996", "CreationDate": "2017-06-10T15:31:11.030", "LastActivityDate": "2017-06-10T23:38:22.197", "LastEditDate": "2017-06-10T23:38:22.197", "ViewCount": "541", "FavoriteCount": "1", "Title": "I believe this is a bug in clang++ related to the access to a class's public member function", "Id": "44475056", "Score": "10", "Body": "<p>The following <a href=\"http://coliru.stacked-crooked.com/a/99fdd4f58779d6e8\" rel=\"nofollow noreferrer\">doesn't compile</a> in clang:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid f() { std::cout &lt;&lt; \"f()\\n\"; }\n\nstruct S {\n    typedef void(*p)();\n    operator p() { return f; }\n};\n\nint main()\n{\n    S s;\n    s.operator p()();\n}\n</code></pre>\n<p>Yields:</p>\n<blockquote id=\"so_44475056_44475056_0\">\n<pre><code>main.cpp:13:16: error: unknown type name 'p'; did you mean 'S::p'?\n    s.operator p()();\n               ^\n               S::p\n\nmain.cpp:6:19: note: 'S::p' declared here\n    typedef void(*p)();\n                  ^\n</code></pre>\n</blockquote>\n<p>But it should, as the expression <code>s.operator p()()</code> accesses a public member function of the object <code>S::s</code>. Am I missing something?</p>\n<p>If I'm wrong, I would appreciate a quote from the Standard supporting the answer.</p>\n", "Tags": "<c++><language-lawyer><public><clang++>", "OwnerUserId": "5479741", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44475056_44475329_0": {"section_id": 7132, "quality": 1.0, "length": 25}}, "n3337": {"so_44475056_44475329_0": {"section_id": 6876, "quality": 1.0, "length": 25}}, "n4659": {"so_44475056_44475329_0": {"section_id": 8633, "quality": 1.0, "length": 25}}}});