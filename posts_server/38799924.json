post_cb({"bq_ids": {"n4140": {"so_38799924_38799957_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 7225}, "so_38799924_38799954_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 7225}}, "n3337": {"so_38799924_38799957_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 6969}, "so_38799924_38799954_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 6969}}, "n4659": {"so_38799924_38799957_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 8735}, "so_38799924_38799954_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 8735}}}, "38799954": {"Id": "38799954", "PostTypeId": "2", "Body": "<p>Yes, this is guaranteed by [basic.type.qualifier] / 1</p>\n<blockquote>\n<p id=\"so_38799924_38799954_0\">The cv-qualified or cv-unqualified versions of a type are distinct types; however, <strong>they shall have the same representation and alignment requirements</strong> (3.11).</p>\n</blockquote>\n", "LastActivityDate": "2016-08-06T02:09:22.577", "CommentCount": "0", "CreationDate": "2016-08-06T02:09:22.577", "ParentId": "38799924", "Score": "31", "OwnerUserId": "657267"}, "38799924": {"ViewCount": "1193", "Body": "<p>It seems reasonable to assume that <code>T</code> and <code>const T</code> would be two types that would be the same size and have the same alignment, but after thinking about some real systems, it seems that they could be different.</p>\n<p>Let me explain:</p>\n<p>Suppose you have a system with two types of memory: RAM and Flash (which is read only).  The RAM is 8 bit addressable, while the Flash is only 16 bit addressable.  Suppose this is <code>T</code>:</p>\n<pre><code>struct T\n{\n  uint8_t x;\n  uint16_t y;\n};\n</code></pre>\n<p>In the byte addressable RAM this struct would be 3 bytes long.... but in the double byte addressable Flash (which is where a <code>const</code> variable would reside) this struct would have to be at least 4 bytes long, because of alignment issues.</p>\n<p>So here is my question:</p>\n<p>Do the c and c++ standards guarantee the sizes and alignment of <code>const</code> and non<code>const</code> types?</p>\n", "AcceptedAnswerId": "38799957", "Title": "Does sizeof(T) == sizeof(const T) and alignof(T) == alignof(const T)", "CreationDate": "2016-08-06T02:04:19.997", "Id": "38799924", "CommentCount": "14", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-08-06T12:54:26.623", "Score": "36", "OwnerUserId": "6149078", "Tags": "<c++><c><alignment><sizeof>", "AnswerCount": "3"}, "38802940": {"Id": "38802940", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_38799924_38802940_0\">In the byte addressable RAM this struct would be 3 bytes long.... but\n  in the double byte addressable Flash (which is where a const variable\n  would reside) this struct would have to be at least 4 bytes long,\n  because of alignment issues.</p>\n</blockquote>\n<p>However, the compiler <em>cannot</em> infer that just because it's <code>const</code> here, it is stored in ROM. There's lots of other things that can prevent that, like <code>mutable</code>, or you could just dynamically place the <code>const T</code> on the stack or manually place it into heap memory in RAM or a thousand other things. You could also have a <code>const T&amp;</code> that could be in either location.</p>\n", "LastEditorUserId": "298661", "LastActivityDate": "2016-08-06T12:54:26.623", "Score": "3", "CreationDate": "2016-08-06T09:55:55.770", "ParentId": "38799924", "CommentCount": "2", "OwnerUserId": "298661", "LastEditDate": "2016-08-06T12:54:26.623"}, "38799957": {"Id": "38799957", "PostTypeId": "2", "Body": "<p>Section 3.9.3:</p>\n<blockquote>\n<p id=\"so_38799924_38799957_0\">The cv-qualified or cv-unqualified versions of a type are distinct\n  types; however, they shall have the same representation and alignment\n  requirements (3.11). 53</p>\n</blockquote>\n<p>\"cv-qualified\" here refers to <code>const</code> and <code>volatile</code>. So the answer is, yes.</p>\n<p><code>const</code> and <code>volatile</code> only specify the limitations/attributes of access to the specified object. They are not considered to be a part of the base type itself; hence they cannot affect the type's properties.</p>\n", "LastActivityDate": "2016-08-06T02:09:50.857", "CommentCount": "5", "CreationDate": "2016-08-06T02:09:50.857", "ParentId": "38799924", "Score": "33", "OwnerUserId": "3943312"}});