post_cb({"bq_ids": {"n4140": {"so_7194127_7194137_1": {"length": 49, "quality": 0.9607843137254902, "section_id": 7177}, "so_7194127_7194149_0": {"length": 41, "quality": 0.7592592592592593, "section_id": 7178}, "so_7194127_7194137_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 7177}, "so_7194127_7195226_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 7183}, "so_7194127_7195226_0": {"length": 45, "quality": 0.8181818181818182, "section_id": 7182}}, "n3337": {"so_7194127_7194137_1": {"length": 49, "quality": 0.9607843137254902, "section_id": 6921}, "so_7194127_7194149_0": {"length": 41, "quality": 0.7592592592592593, "section_id": 6922}, "so_7194127_7194137_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 6921}, "so_7194127_7195226_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 6927}, "so_7194127_7195226_0": {"length": 45, "quality": 0.8181818181818182, "section_id": 6926}}, "n4659": {"so_7194127_7194137_1": {"length": 49, "quality": 0.9607843137254902, "section_id": 8685}, "so_7194127_7194137_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 8685}, "so_7194127_7194149_0": {"length": 39, "quality": 0.7222222222222222, "section_id": 8686}, "so_7194127_7195226_1": {"length": 16, "quality": 0.6666666666666666, "section_id": 8691}}}, "7194154": {"Id": "7194154", "PostTypeId": "2", "Body": "<h1>Part III</h1>\n<p><a href=\"https://stackoverflow.com/questions/7194127/how-should-i-write-iso-c-standard-conformant-custom-new-and-delete-operators/7194149#7194149\">... continued</a></p>\n<p>Note that we cannot get the new handler function pointer directly, we have to call <code>set_new_handler</code> to find out what it is. This is crude but effective, at least for single-threaded code. In a multithreaded environment, probably some kind of lock to safely manipulate the (global) data structures behind the new-handling function will be needed. (<em>More citation/details are welcome on this.</em>)</p>\n<p>Also, we have an infinite loop and the only way out of the loop is for memory to be successfully allocated, or for the new-handling function to do one of the things we inferred before. Unless the <code>new_handler</code> does one of those things, this loop inside <code>new</code> operator will never terminate.</p>\n<p><strong>A caveat:</strong>  Note that the standard (<code>\u00a73.7.4.1.3</code>, quoted above) does not explicitly say that the overloaded <code>new</code> operator <strong>must</strong> implement an infinite loop, but it merely says that such is the default behaviour. <s>So this detail is open to interpretation, but most of the compilers (<a href=\"http://en.wikipedia.org/wiki/GNU_Compiler_Collection\" rel=\"nofollow noreferrer\">GCC</a> and <a href=\"http://en.wikipedia.org/wiki/Visual_C++\" rel=\"nofollow noreferrer\">Microsoft Visual C++</a>) do implement this loop functionality (you can compile the code samples provided earlier).</s> Also, since an C++ authory such as <a href=\"http://en.wikipedia.org/wiki/Scott_Meyers\" rel=\"nofollow noreferrer\">Scott Meyers</a> suggests this approach, it is reasonable enough.</p>\n<h2>Special scenarios</h2>\n<p>Let us consider the following scenario.</p>\n<pre><code>class Base\n{\n    public:\n        static void * operator new(std::size_t size) throw(std::bad_alloc);\n};\n\nclass Derived: public Base\n{\n   //Derived doesn't declare operator new\n};\n\nint main()\n{\n    // This calls Base::operator new!\n    Derived *p = new Derived;\n\n    return 0;\n}\n</code></pre>\n<p>As <strong><a href=\"https://stackoverflow.com/questions/7149461/why-should-one-replace-default-new-and-delete-operators\">this</a></strong> FAQ, explains, a common reason for writing a custom memory manager is to optimize allocation for objects of a specific class, not for a class or any of\nits derived classes, which basically means that our operator new for the Base class is typically tuned for objects of size <code>sizeof(Base)</code> -nothing larger and nothing smaller.</p>\n<p>In the above sample, because of inheritance the derived class <code>Derived</code> inherits the new operator of the Base class. This makes calling operator new in a base class to allocate memory for an object of a derived class possible. The best way for our <code>operator new</code> to handle this situation is to divert such calls requesting the \"wrong\" amount of memory to the standard operator new, like this:</p>\n<pre><code>void * Base::operator new(std::size_t size) throw(std::bad_alloc)\n{\n    if (size != sizeof(Base))          // If size is \"wrong,\", that is, != sizeof Base class\n    {\n         return ::operator new(size);  // Let std::new handle this request\n    }\n    else\n    {\n         //Our implementation\n    }\n}\n</code></pre>\n<p>Note that, the check for size also incoprporates our <strong>requirement #3</strong>. This is because all freestanding objects have a non-zero size in C++, so <code>sizeof(Base)</code> can never be zero, so if size is zero, the request will be forwarded to <code>::operator new</code>, and it is gauranteed that it will handle it in standard compliant way.</p>\n<p>Citation: <strong><a href=\"http://www2.research.att.com/~bs/bs_faq2.html#sizeof-empty\" rel=\"nofollow noreferrer\">From the creator of C++ himself, Dr Bjarne Stroustrup.</a></strong></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-12-23T18:55:54.750", "Score": "15", "CreationDate": "2011-08-25T16:45:27.517", "ParentId": "7194127", "CommentCount": "0", "OwnerUserId": "452307", "LastEditDate": "2017-05-23T12:09:42.210"}, "7195226": {"Id": "7195226", "PostTypeId": "2", "Body": "<h2>Implementing a custom delete operator</h2>\n<p>The C++ Standard(<code>\u00a718.4.1.1</code>) library defines <code>operator delete</code> as:</p>\n<pre><code>void operator delete(void*) throw();\n</code></pre>\n<p>Let us repeat the exercise of gathering the requirements for writing our custom <code>operator delete</code>:</p>\n<p><strong>Requirement #1:</strong>\nIt shall return <code>void</code> and its first parameter shall be <code>void*</code>. A custom <code>delete operator</code> can have more than one parameter as well but well we just need one parameter to pass the pointer pointing to the allocated memory.</p>\n<p>Citation from the C++ Standard:</p>\n<p><strong>Section \u00a73.7.3.2.2:</strong></p>\n<p>\"Each deallocation function shall return void and its first parameter shall be void*. A deallocation function can have more than one parameter.....\"</p>\n<p>Requirement #2: It should guarantee that it is safe to delete a null pointer passed as an argument.</p>\n<p>Citation from C++ Standard:\n<strong>Section \u00a73.7.3.2.3:</strong></p>\n<blockquote>\n<p id=\"so_7194127_7195226_0\">The value of the first argument supplied to one of the deallocation functions provided in the standard library may be a null pointer value; if so, the call to the deallocation function has no effect.  Otherwise, the value supplied to <code>operator delete(void*)</code> in the standard library shall be one of the values returned by a previous invocation of either <code>operator new(size_t)</code> or <code>operator new(size_t, const std::nothrow_t&amp;)</code> in the standard library, and the value supplied to <code>operator delete[](void*)</code> in the standard library shall be one of the values returned by a previous invocation of either <code>operator new[](size_t)</code> or <code>operator new[](size_t,  const  std::nothrow_t&amp;)</code> in the standard library.</p>\n</blockquote>\n<p><strong>Requirement #3:</strong>\nIf the pointer being passed is not <code>null</code>, then the <code>delete operator</code> should deallocate the dynamic memory allocated and assigned to the pointer.</p>\n<p>Citation from C++ Standard:\n<strong>Section \u00a73.7.3.2.4:</strong></p>\n<blockquote>\n<p id=\"so_7194127_7195226_1\">If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value (4.10), the deallocation function shall deallocate the storage referenced by the pointer, render-ing invalid all pointers referring to any part of the deallocated storage.</p>\n</blockquote>\n<p><strong>Requirement #4:</strong>\nAlso, since our class-specific operator new forwards requests of the \"wrong\" size to <code>::operator new</code>, We <strong>MUST</strong> forward \"wrongly sized\" deletion requests to <code>::operator delete</code>.</p>\n<p>So based on the requirements we summarized above here is an standard conformant pseudo code for a custom <code>delete operator</code>:</p>\n<pre><code>class Base\n{\n    public:\n        //Same as before\n        static void * operator new(std::size_t size) throw(std::bad_alloc);\n        //delete declaration\n        static void operator delete(void *rawMemory, std::size_t size) throw();\n\n        void Base::operator delete(void *rawMemory, std::size_t size) throw()\n        {\n            if (rawMemory == 0)\n            {\n                return;                            // No-Op is null pointer\n            }\n\n            if (size != sizeof(Base))\n            {\n                // if size is \"wrong,\"\n                ::operator delete(rawMemory);      //Delegate to std::delete\n                return;\n            }\n            //If we reach here means we have correct sized pointer for deallocation\n            //deallocate the memory pointed to by rawMemory;\n\n            return;\n        }\n};\n</code></pre>\n", "LastEditorUserId": "63550", "LastActivityDate": "2011-12-23T18:58:19.950", "Score": "10", "CreationDate": "2011-08-25T18:15:03.883", "ParentId": "7194127", "CommentCount": "1", "OwnerUserId": "452307", "LastEditDate": "2011-12-23T18:58:19.950"}, "7194149": {"Id": "7194149", "PostTypeId": "2", "Body": "<h1>Part II</h1>\n<p><a href=\"https://stackoverflow.com/questions/7194127/how-should-i-write-iso-c-standard-conformant-custom-new-and-delete-operators/7194137#7194137\">... continued</a></p>\n<p>Given the behavior of <code>operator new</code> from the example, a well designed <code>new_handler</code> <strong>must</strong> do one of the following:</p>\n<p><strong>Make more memory available:</strong> This may allows the next memory allocation attempt inside operator new's loop to succeed. One way to implement this is to allocate a large block of memory at program start-up, then release it for use in the program the first time the new-handler is invoked.</p>\n<p><strong>Install a different new-handler:</strong> If the current new-handler can't make any more memory available, and of there is another new-handler that can, then the current new-handler can install the other new-handler in its place (by calling <code>set_new_handler</code>). The next time operator new calls the new-handler function, it will get the one most recently installed.</p>\n<p>(A variation on this theme is for a new-handler to modify its own behavior, so the next time it's invoked, it does something different. One way to achieve this is to have the new-handler modify static, namespace-specific, or global data that affects the new-handler's behavior.)</p>\n<p><strong>Uninstall the new-handler:</strong>  This is done by passing a null pointer to <code>set_new_handler</code>. With no new-handler installed, <code>operator new</code> will throw an exception ((convertible to) <code>std::bad_alloc</code>) when memory allocation is unsuccessful.</p>\n<p><strong>Throw an exception</strong> convertible to <code>std::bad_alloc</code>. Such exceptions are not be caught by <code>operator new</code>, but will propagate to the site originating the request for memory.</p>\n<p><strong>Not return:</strong> By calling <code>abort</code> or <code>exit</code>.  </p>\n<p>To implement an class-specific <code>new_handler</code> we have to provide a class with its own versions of <code>set_new_handler</code> and <code>operator new</code>. The class's <code>set_new_handler</code> allows clients to specify the new-handler for the class (exactly like the standard <code>set_new_handler</code>allows clients to specify the global new-handler). The class's <code>operator new</code> ensures that the class-specific new-handler is used in place of the global new-handler when memory for class objects is allocated.</p>\n<hr>\n<p>Now that we understand <code>new_handler</code> &amp; <code>set_new_handler</code> better we are able to modify the <strong>Requirement #4</strong> suitably as:     </p>\n<p><strong><em>Requirement #4 (Enhanced):</em></strong><br>\nOur <code>operator new</code> should try to allocate memory more than once, calling the new-handling function after each failure. The assumption here is that the new-handling function might be able to do something to free up some memory. Only when the pointer to the new-handling function is <code>null</code> does <code>operator new</code> throw an exception. </br></p>\n<p>As promised, the citation from the Standard:<br>\n<strong>Section 3.7.4.1.3:</strong></br></p>\n<blockquote>\n<p id=\"so_7194127_7194149_0\"><em>An allocation function that fails to allocate storage can invoke the currently installed <code>new_handler</code>(<code>18.4.2.2</code>), if any.  [Note: A program-supplied allocation function can obtain the address of the currently installed <code>new_handler</code> using the <code>set_new_handler</code> function (<code>18.4.2.3</code>).] If an allocation function declared with an empty exception-specification (<code>15.4</code>), <code>throw()</code>, fails to allocate storage, it shall return a null pointer.  Any other allocation function that fails to allocate storage shall only indicate failure by throw-ing an exception of class <code>std::bad_alloc</code> (<code>18.4.2.1</code>) or a class derived from <code>std::bad_alloc</code>.</em></p>\n</blockquote>\n<p>Armed with the <strong>#4</strong> requirements, let us attempt the pseudo code for our <code>new operator</code>:  </p>\n<pre><code>void * operator new(std::size_t size) throw(std::bad_alloc)\n{  \n   // custom operator new might take additional params(3.7.3.1.1)\n\n    using namespace std;                 \n    if (size == 0)                     // handle 0-byte requests\n    {                     \n        size = 1;                      // by treating them as\n    }                                  // 1-byte requests\n\n    while (true) \n    {\n        //attempt to allocate size bytes;\n\n        //if (the allocation was successful)\n\n        //return (a pointer to the memory);\n\n        //allocation was unsuccessful; find out what the current new-handling function is (see below)\n        new_handler globalHandler = set_new_handler(0);\n\n        set_new_handler(globalHandler);\n\n\n        if (globalHandler)             //If new_hander is registered call it\n             (*globalHandler)();\n        else \n             throw std::bad_alloc();   //No handler is registered throw an exception\n\n    }\n\n}\n</code></pre>\n<p><strong><a href=\"https://stackoverflow.com/questions/7194127/how-should-i-write-iso-c-standard-conformant-custom-new-and-delete-operators/7194154#7194154\">Continuation 2</a></strong></p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2011-08-26T00:05:06.010", "Score": "18", "CreationDate": "2011-08-25T16:44:56.177", "ParentId": "7194127", "CommentCount": "18", "OwnerUserId": "452307", "LastEditDate": "2017-05-23T10:30:51.207"}, "7194137": {"Id": "7194137", "PostTypeId": "2", "Body": "<h1>Part I</h1>\n<p><a href=\"https://stackoverflow.com/questions/7149461/why-should-one-replace-default-new-and-delete-operators\">This C++ FAQ entry</a> explained <em>why</em> one might want to overload <code>new</code> and <code>delete</code> operators for one's own class. This present FAQ tries to explain <em>how</em> one does so in a standard-conforming way.</p>\n<h2>Implementing a custom <code>new</code> operator</h2>\n<p>The C++ standard (\u00a718.4.1.1) defines <code>operator new</code> as:</p>\n<pre><code>void* operator new (std::size_t size) throw (std::bad_alloc);\n</code></pre>\n<p>The C++ standard specifies the semantics that custom versions of these operators have to obey in \u00a73.7.3 and \u00a718.4.1</p>\n<p>Let us summarize the requirements.</p>\n<p><strong>Requirement #1:</strong> It should dynamically allocate at least <code>size</code> bytes of memory and return a pointer to the allocated memory. Quote from the C++ standard, section 3.7.4.1.3:</p>\n<blockquote>\n<p id=\"so_7194127_7194137_0\">The allocation function attempts to allocate the requested amount of storage. If it is successful, it shall return the address of the start of a block of storage whose length in bytes shall be at least as large as the requested size...</p>\n</blockquote>\n<p>The standard further imposes:</p>\n<blockquote>\n<p id=\"so_7194127_7194137_1\">...The pointer returned shall be suitably aligned so that it can be converted to a pointer of any complete object type and then used to access the object or array in the storage allocated (until the storage is explicitly deallocated by a call to a corresponding deallocation function). Even if the size of the space requested is zero, the request can fail. If the request succeeds, the value returned shall be a non-null pointer value (4.10) p0 different from any previously returned value p1, unless that value p1 was sub-sequently passed to an operator <code>delete</code>.</p>\n</blockquote>\n<p>This gives us further important requirements:</p>\n<p><strong>Requirement #2:</strong> The memory allocation function we use (usually <code>malloc()</code> or some other custom allocator) should return a <em>suitably aligned</em> pointer to the allocated memory, which can be converted to a pointer of an complete object type and used to access the object.</p>\n<p><strong>Requirement #3:</strong> Our custom operator <code>new</code> must return a legitimate pointer even when zero bytes are requested.</p>\n<p>One of the evident requirements that can even be inferred from <code>new</code> prototype is:</p>\n<p><strong>Requirement #4:</strong> If <code>new</code> cannot allocate dynamic memory of the requested size, then it should throw an exception of type <code>std::bad_alloc</code>.</p>\n<p><strong>But!</strong> There is more to that than what meets the eye: If you take a closer look at the <code>new</code> operator <a href=\"http://www.cplusplus.com/reference/std/new/operator%20new/\" rel=\"nofollow noreferrer\">documentation</a> (citation from standard follows further down), it states:</p>\n<blockquote>\n<p id=\"so_7194127_7194137_2\">If <strong><a href=\"http://www.cplusplus.com/reference/std/new/set_new_handler/\" rel=\"nofollow noreferrer\">set_new_handler</a></strong> has been used to define a <strong><a href=\"http://www.cplusplus.com/reference/std/new/new_handler/\" rel=\"nofollow noreferrer\">new_handler</a></strong> function, this <code>new_handler</code> function is called by the standard default definition of <code>operator new</code> if it cannot allocate the requested storage by its own.</p>\n</blockquote>\n<p>To understand how our custom <code>new</code> needs to support this requirement, we should understand: </p>\n<h2>What is the <code>new_handler</code> and <code>set_new_handler</code>?</h2>\n<p><code>new_handler</code> is a typedef for a pointer to a function that takes and returns nothing, and \n<code>set_new_handler</code> is a function that takes and returns a <code>new_handler</code>. </p>\n<p><code>set_new_handler</code>'s parameter is a pointer to the function operator new should call if it can't allocate the requested memory. Its return value is a pointer to the previously registered handler function, or null if there was no previous handler.</p>\n<p>An opportune moment for an code sample to make things clear:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\n// function to call if operator new can't allocate enough memory or error arises\nvoid outOfMemHandler()\n{\n    std::cerr &lt;&lt; \"Unable to satisfy request for memory\\n\";\n\n    std::abort();\n}\n\nint main()\n{\n    //set the new_handler\n    std::set_new_handler(outOfMemHandler);\n\n    //Request huge memory size, that will cause ::operator new to fail\n    int *pBigDataArray = new int[100000000L];\n\n    return 0;\n}\n</code></pre>\n<p>In the above example, <code>operator new</code> (most likely) will be unable to allocate space for 100,000,000 integers, and the function <code>outOfMemHandler()</code> will be called, and the program will abort after <a href=\"http://www.ideone.com/TsciL\" rel=\"nofollow noreferrer\">issuing an error message</a>.</p>\n<p>It is important to note here that when <code>operator new</code> is unable to fulfill a memory request, it calls the <code>new-handler</code> function repeatedly until it <em>can</em> find enough memory or there is no more new handlers. In the above example, unless we call <code>std::abort()</code>, <code>outOfMemHandler()</code> would be <a href=\"http://www.ideone.com/nF4iy\" rel=\"nofollow noreferrer\">called repeatedly</a>. Therefore, the handler should either ensure that the next allocation succeeds, or register another handler, or register no handler, or not return (i.e. terminate the program). If there is no new handler and the allocation fails, the operator will throw an exception.</p>\n<p><strong><a href=\"https://stackoverflow.com/questions/7194127/how-should-i-write-iso-c-standard-conformant-custom-new-and-delete-operators/7194149#7194149\">Continuation 1</a></strong></p>\n<hr>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2011-12-28T11:29:32.337", "Score": "29", "CreationDate": "2011-08-25T16:43:51.713", "ParentId": "7194127", "CommentCount": "3", "OwnerUserId": "452307", "LastEditDate": "2017-05-23T12:17:30.827"}, "7194127": {"ViewCount": "9166", "Body": "<h3>How should I write ISO C++ standard conformant custom <code>new</code> and <code>delete</code> operators?</h3>\n<p>This is in continuation of <a href=\"https://stackoverflow.com/questions/4421706/operator-overloading/4421791#4421791\">Overloading new and delete</a> in the immensely illuminating C++ FAQ, <a href=\"https://stackoverflow.com/questions/4421706/operator-overloading\">Operator overloading</a>, and its follow-up, <a href=\"https://stackoverflow.com/questions/7149461/why-should-one-replace-default-new-and-delete-operators\">Why should one replace default new and delete operators?</a></p>\n<p><strong>Section 1:</strong> Writing a standard-conformant <code>new</code> operator</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/7194127/7194137#7194137\">Part 1: Understanding the requirements for writing a custom <code>new</code> operator</a></li>\n<li><a href=\"https://stackoverflow.com/questions/7194127/7194149#7194149\">Part 2: Understanding the <code>new_handler</code> requirements</a></li>\n<li><a href=\"https://stackoverflow.com/questions/7194127/7194154#7194154\">Part 3: Understanding specific scenario requirements</a></li>\n</ul>\n<p><strong>Section 2:</strong> Writing a standard-conformant <code>delete</code> operator  </p>\n<ul>\n<li><p><a href=\"https://stackoverflow.com/questions/7194127/how-should-i-write-iso-c-standard-conformant-custom-new-and-delete-operators/7195226#7195226\">Implementing Custom delete operator</a></p></li>\n</ul>\n<p><sub>\n<em>(Note: This is meant to be an entry to <a href=\"https://stackoverflow.com/questions/tagged/c++-faq\">Stack Overflow's C++ FAQ</a>. If you want to critique the idea of providing an FAQ in this form, then <a href=\"https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag\">the posting on meta that started all this</a> would be the place to do that. Answers to that question are monitored in the <a href=\"http://chat.stackoverflow.com/rooms/10/c-lounge\">C++ chatroom</a>, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)</em><br>\n<em>Note: The answer is based on learnings from Scott Meyers' More Effective C++ and the ISO C++ Standard.</em></br></sub></p>\n<p></p>\n", "AcceptedAnswerId": "7194137", "Title": "How should I write ISO C++ Standard conformant custom new and delete operators?", "CreationDate": "2011-08-25T16:43:13.993", "Id": "7194127", "CommentCount": "20", "FavoriteCount": "66", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:09:42.210", "LastEditorUserId": "-1", "LastActivityDate": "2014-08-18T09:38:56.013", "Score": "56", "OwnerUserId": "452307", "Tags": "<c++><operator-overloading><new-operator><c++-faq><delete-operator>", "AnswerCount": "4"}});