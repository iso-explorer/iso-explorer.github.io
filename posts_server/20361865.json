post_cb({"20362378": {"ParentId": "20361865", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>For purposes of name lookup, the body of the lambda is considered to be in the context of the lambda expression. That is, name lookup happens as if you used the name outside the lambda. See [expr.prim.lambda]/7. For example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint x = 13;\nint y = 0;\n\nint main()\n{\n  static int y = 42;\n  int z = 1729;\n\n  auto l = [/*forget about the capture for a moment*/]()\n  { return x+y+z; };\n  // find the names x,y,z as if they had been mentioned outside the lambda\n  // find the locals y, z and the global x\n\n  std::cout &lt;&lt; l() &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>Now, you <em>need</em> to capture variables of automatic storage duration. I guess this makes it a bit less error-prone, as you can copy and return lambdas, so that the automatic variables have been destroyed when the lambda is called:</p>\n<pre><code>int main()\n{\n  static int y = 42;\n\n  std::function&lt;int()&gt; f;\n  {\n    int z = 1729;\n\n    f = [](){ return x+y+z; }; // imagine we could do this\n  }\n\n  std::cout &lt;&lt; f() &lt;&lt; std::endl; // uh-oh!\n\n  return 0;\n}\n</code></pre>\n<p>Of course, this problem does not appear for variables with static storage duration.</p>\n<p>Specifically, [expr.prim.lambda]/12 says:</p>\n<blockquote>\n<p id=\"so_20361865_20362378_0\">If a <em>lambda-expression</em> or an instantiation of the function call\n  operator template of a generic lambda odr-uses (3.2) <code>this</code> or a\n  variable with automatic storage duration from its reaching scope, that\n  entity shall be captured by the <em>lambda-expression</em>.</p>\n</blockquote>\n<p>Non-automatic variables will be found by name lookup as well, but are not affected by this rule. You can use them without capturing.</p>\n<hr>\n<p>N.B. the <em>odr-use</em> relaxation allows some uses of automatic variables w/o capturing them, such as:</p>\n<pre><code>int main()\n{\n  int x = 42;\n  constexpr int y = 1789;\n\n  auto l = []() -&gt; int\n  {\n      decltype(x) my_var = 100;  // no odr-use of `x`\n      return my_var*y;           // no odr-use of `y`\n  };\n\n  std::cout &lt;&lt; l() &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n</hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2014-06-29T12:30:06.043", "Id": "20362378", "Score": "4", "CreationDate": "2013-12-03T21:46:56.687", "LastActivityDate": "2014-06-29T12:30:06.043"}, "20361865": {"CommentCount": "4", "ViewCount": "1699", "PostTypeId": "1", "LastEditorUserId": "701092", "CreationDate": "2013-12-03T21:17:52.943", "LastActivityDate": "2014-06-29T12:30:06.043", "Title": "Can a C++11 lambda capture a file scope variable?", "AcceptedAnswerId": "20362378", "LastEditDate": "2013-12-03T21:21:09.287", "Id": "20361865", "Score": "5", "Body": "<p>Section 5.1.2 p10 of the ISO C++11 specification states:</p>\n<blockquote>\n<p id=\"so_20361865_20361865_0\">The identifiers in a capture-list are looked up using the usual rules\n  for unqualified name lookup (3.4.1); each such lookup shall find a\n  variable with automatic storage duration declared in the reaching\n  scope of the local lambda expression. An entity (i.e. a variable or\n  this) is said to be explicitly captured if it appears in the\n  lambda-expression\u2019s capture-list.</p>\n</blockquote>\n<p>This seems to imply that a lambda cannot capture a file scope variable. For example, this program should be illegal:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint x = 13;\n\nint main()\n{\n  auto l = [](){ return x; };\n\n  std::cout &lt;&lt; l() &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>However, <code>g++</code> 4.7.1 produces the result I expect:</p>\n<pre><code>$ g++ --version\ng++ (Ubuntu/Linaro 4.7.2-2ubuntu1) 4.7.2\nCopyright (C) 2012 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n$ g++ -std=c++11 lambda.cpp \n$ ./a.out \n13\n</code></pre>\n<p>But <code>clang</code> 3.0 crashes:</p>\n<pre><code>$ clang --version\nUbuntu clang version 3.0-6ubuntu3 (tags/RELEASE_30/final) (based on LLVM 3.0)\nTarget: i386-pc-linux-gnu\nThread model: posix\n$ clang -std=c++11 lambda.cpp \n0  libLLVM-3.0.so.1 0xb70a59e8\n1  libLLVM-3.0.so.1 0xb70a5f34\n2                   0xb775d400 __kernel_sigreturn + 0\n3  clang            0x0869f2e9 clang::Sema::DeduceAutoType(clang::TypeSourceInfo*, clang::Expr*, clang::TypeSourceInfo*&amp;) + 73\n&lt;snip&gt;\n</code></pre>\n<p>Is my program illegal or not? If it is illegal, what is the rationale for the proscription on capturing file scope variables?</p>\n", "Tags": "<c++><c++11><lambda>", "OwnerUserId": "722294", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_20361865_20361865_0": {"section_id": 5969, "quality": 0.6363636363636364, "length": 21}, "so_20361865_20362378_0": {"section_id": 5972, "quality": 1.0, "length": 19}}, "n3337": {"so_20361865_20361865_0": {"section_id": 5738, "quality": 0.9090909090909091, "length": 30}, "so_20361865_20362378_0": {"section_id": 5740, "quality": 0.6842105263157895, "length": 13}}, "n4659": {"so_20361865_20361865_0": {"section_id": 7467, "quality": 0.6363636363636364, "length": 21}, "so_20361865_20362378_0": {"section_id": 7471, "quality": 1.0, "length": 19}}}});