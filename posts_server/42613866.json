post_cb({"42614016": {"ParentId": "42613866", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-03-05T21:06:46.927", "Score": "1", "LastEditorUserId": "2877241", "LastEditDate": "2017-03-05T21:16:04.990", "Id": "42614016", "OwnerUserId": "2877241", "Body": "<p>From the C++ Standard (4 Standard conversions )</p>\n<blockquote>\n<p id=\"so_42613866_42614016_0\">4 Certain language constructs require that an expression be converted\n  to a Boolean value. An expression e appearing in such a context is\n  said to be <strong>contextually converted to bool</strong> and is well-formed if\n  and only if the declaration bool t(e); is well-formed, for some\n  invented temporary variable t (8.5).</p>\n</blockquote>\n<p>and (5.15 Logical OR operator)</p>\n<blockquote>\n<p id=\"so_42613866_42614016_1\">1 The || operator groups left-to-right. The operands are both\n  <strong>contextually converted to bool</strong> (Clause 4). It returns true if either of its operands is true, and false otherwise. Unlike |, ||\n  guarantees left-to-right evaluation; moreover, the second operand is\n  not evaluated if the \ufb01rst operand evaluates to true.</p>\n</blockquote>\n<p>and at last (12.3.2 Conversion functions)</p>\n<blockquote>\n<p id=\"so_42613866_42614016_2\">2 A conversion function may be explicit(7.1.2), in which case it is\n  only considered as a user-de\ufb01ned conversion for\n  <strong>direct-initialization</strong> (8.5). Otherwise, user-de\ufb01ned conversions are not restricted to use in assignments and initializations.</p>\n</blockquote>\n<p>Relative to your example the invented declaration of the variable <code>t</code></p>\n<pre><code>C c( true );\n\nbool t( c ); \n</code></pre>\n<p>is well-formed because there is used the direct initialization.</p>\n", "LastActivityDate": "2017-03-05T21:16:04.990"}, "42613928": {"ParentId": "42613866", "CommentCount": "0", "CreationDate": "2017-03-05T20:59:32.070", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "42613928", "Score": "6", "Body": "<p>From [expr.log.or]:</p>\n<blockquote>\n<p id=\"so_42613866_42613928_0\">The operands are both contextually converted to <code>bool</code></p>\n</blockquote>\n<p>Contextual conversion to bool is allowed to use explicit conversions. That's the point of the concept of \"contextuality\": The explicit conversion is allowed precisely when it makes sense, and not otherwise, so you don't accidentally form arbitrary integral or pointer values from the bool conversion, but when you actually ask for a bool, you get it.</p>\n<p>See [conv]/4 for details:</p>\n<blockquote>\n<p id=\"so_42613866_42613928_1\">Certain language constructs require that an expression be converted to a Boolean value. An expression <code>e</code>\n  appearing in such a context is said to be <em>contextually converted to <code>bool</code></em> and is well-formed if and only if the\n  declaration <code>bool t(e);</code> is well-formed, for some invented temporary variable <code>t</code></p>\n</blockquote>\n", "LastActivityDate": "2017-03-05T20:59:32.070"}, "bq_ids": {"n4140": {"so_42613866_42614016_0": {"section_id": 3, "quality": 0.9583333333333334, "length": 23}, "so_42613866_42614016_1": {"section_id": 6165, "quality": 0.9032258064516129, "length": 28}, "so_42613866_42613928_0": {"section_id": 6163, "quality": 0.8333333333333334, "length": 5}, "so_42613866_42614016_2": {"section_id": 392, "quality": 0.8, "length": 12}, "so_42613866_42613928_1": {"section_id": 3, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_42613866_42614016_0": {"section_id": 2, "quality": 0.9583333333333334, "length": 23}, "so_42613866_42614016_1": {"section_id": 5926, "quality": 0.9032258064516129, "length": 28}, "so_42613866_42613928_0": {"section_id": 5924, "quality": 0.8333333333333334, "length": 5}, "so_42613866_42614016_2": {"section_id": 383, "quality": 0.8, "length": 12}, "so_42613866_42613928_1": {"section_id": 2, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_42613866_42614016_0": {"section_id": 3, "quality": 0.9583333333333334, "length": 23}, "so_42613866_42614016_1": {"section_id": 7662, "quality": 0.9032258064516129, "length": 28}, "so_42613866_42613928_0": {"section_id": 7660, "quality": 0.8333333333333334, "length": 5}, "so_42613866_42614016_2": {"section_id": 409, "quality": 0.8, "length": 12}, "so_42613866_42613928_1": {"section_id": 3, "quality": 0.9583333333333334, "length": 23}}}, "42613866": {"CommentCount": "3", "ViewCount": "141", "PostTypeId": "1", "LastEditorUserId": "2345484", "CreationDate": "2017-03-05T20:55:01.590", "LastActivityDate": "2017-03-05T21:16:04.990", "Title": "Explicit conversion operator bool", "AcceptedAnswerId": "42613928", "LastEditDate": "2017-03-05T21:08:26.010", "Id": "42613866", "Score": "3", "Body": "<p>I have the following code</p>\n<pre><code>  class C\n    {\n    public:\n        C(bool v_):v(v_){};\n        explicit operator bool() const {return v;}\n        bool v = false;    \n    };\n\n int main(){\n  C a{true};\n  C b{false};\n  // C d = true; // doesn't compile, since requires explicit conversion\n  C d = static_cast&lt;bool&gt;(true); // fine\n\n  if(a || b) std::cout &lt;&lt; \"conversion happened!\" &lt;&lt; std::endl; // why it doesn't require explicit conversion here?\n\n }\n</code></pre>\n<p>It outputs \"conversion happened!\". My question is why <code>||</code> is considered to be a explicit conversion?</p>\n<p><strong>Edit</strong></p>\n<pre><code>  // C d = true; // actually this line compiles because of the constructor\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "2345484", "AnswerCount": "2"}});