post_cb({"bq_ids": {"n4140": {"so_49208173_49208212_0": {"length": 41, "quality": 0.5857142857142857, "section_id": 6668}}, "n3337": {"so_49208173_49208212_0": {"length": 41, "quality": 0.5857142857142857, "section_id": 6423}}, "n4659": {"so_49208173_49208212_0": {"length": 41, "quality": 0.5857142857142857, "section_id": 8143}}}, "49208212": {"Id": "49208212", "PostTypeId": "2", "Body": "<p>When you inherite privately, you make all public and protected members of your base class private for your derived class. So Bar can use its own private method and public and protected methods of its private base class. But their private still and you can't access them from Bar's public interface.</p>\n<blockquote>\n<p id=\"so_49208173_49208212_0\">14.2 <strong>Accessibility of base classes</strong> and base class members <strong>[class.access.base]</strong><br>\n  ... If a class is declared to be a base class for another class using the private access specifier, the public and protected members of the base class are accessible as private members of the derived class.<br>\n  ...<br>\n<strong>It should be noted that it is access to members and base classes that is controlled, not their visibility.</strong> Names\n  of members are still visible, and implicit conversions to base classes are still considered, when those members and base classes are inaccessible. The interpretation of a given construct is established without regard to\n  access control. If the interpretation established makes use of inaccessible member names or base classes, the construct is ill-formed.</br></br></br></p>\n</blockquote>\n", "LastEditorUserId": "312896", "LastActivityDate": "2018-03-10T11:19:12.687", "Score": "0", "CreationDate": "2018-03-10T10:52:25.567", "ParentId": "49208173", "CommentCount": "2", "OwnerUserId": "312896", "LastEditDate": "2018-03-10T11:19:12.687"}, "49208173": {"ViewCount": "113", "Body": "<p>I have a question regarding C++'s private inheritance.\nSee the following code example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Foo {\n  public:\n    virtual void doSomething(int value) {\n      std::cout &lt;&lt; value &lt;&lt; std::endl;\n    }\n\n};\n\nvoid foobar(Foo&amp; foo, int value) {\n  foo.doSomething(value);\n}\n\nclass Bar : Foo {\n  public:\n    Bar() {\n      foobar(*this, 42);  // &lt;--- is OK despite private inheritance\n    }\n};\n\nint main() {\n  Bar b;\n  foobar(b, 42); // &lt;--- is NOT OK because of private inheritance\n}\n</code></pre>\n<p>At the moment, I can't understand (or find the right C++ specification) why the function <code>foobar</code> can be called in the <code>Bar</code>'s constructor with <code>*this</code> <strong>despite private inheritance</strong>.\nIf I try to call the <code>foobar</code> function with <code>Bar</code> object <code>b</code> in the <code>main</code> function, the compiler gives an error as expected because of the private inheritance.</p>\n<p>What is here the difference between <code>foobar(*this, 42)</code> and <code>foobar(b, 42)</code> that I overlook?</p>\n", "Title": "With private inheritance, when is it ok to upcast?", "CreationDate": "2018-03-10T10:47:26.233", "LastActivityDate": "2018-03-10T12:09:03.947", "CommentCount": "1", "LastEditDate": "2018-03-10T10:56:55.463", "PostTypeId": "1", "LastEditorUserId": "5470596", "Id": "49208173", "Score": "4", "OwnerUserId": "960404", "Tags": "<c++><inheritance>", "AnswerCount": "3"}, "49208215": {"Id": "49208215", "PostTypeId": "2", "Body": "<p>It all comes from the fact that <code>foobar</code> receives a <code>Foo</code> and is ignorant of the fact that <code>Bar</code> (privatly) inherits from <code>Foo</code>. This trait is taken care of by the callers:</p>\n<ul>\n<li>Inside <code>Bar</code>'s constructor, in order to call <code>foobar</code> with <code>*this</code>, a conversion is necessary; specifically, <code>*this</code> of type <code>Bar</code> needs to be converted to <code>Foo&amp;</code>, which is possible since the caller is <em>aware</em> of the inheritance relation between the two types.</li>\n<li>In <code>main()</code>, outside <code>class Bar</code>  scope then, the call to <code>foobar</code> with <code>b</code> which is of type <code>Bar</code> also needs a conversion. But in this context, the relation between <code>Bar</code> and <code>Foo</code> is unknown, and there is no conversion possible.</li>\n</ul>\n<p>Private inheritance means only the derived type knows of this inheritance. In its scope, everything happens as if it was a public inheritance. But outside the scope of the derived type, this relation is unknown and everything happens as if there was no inheritance at all.</p>\n", "LastActivityDate": "2018-03-10T10:52:46.293", "Score": "2", "CreationDate": "2018-03-10T10:52:46.293", "ParentId": "49208173", "CommentCount": "4", "OwnerUserId": "5470596"}, "49208890": {"Id": "49208890", "PostTypeId": "2", "Body": "<p>The question boils down to other question: <strong>What does private inheritance mean?</strong>. \nAnd it means, in simplifying words, that none except the inheriting class is aware that inheritance takes place. So down to Your example - <code>Bar</code> <em>knows</em> it is derived from <code>Foo</code> so there is no trouble upcasting in constructor. On the other hand <code>main</code> is not part of inheriting <code>Bar</code> and so it cannot implicitly cast <code>Bar</code> to <code>Foo</code>. </p>\n", "LastActivityDate": "2018-03-10T12:09:03.947", "Score": "0", "CreationDate": "2018-03-10T12:09:03.947", "ParentId": "49208173", "CommentCount": "0", "OwnerUserId": "3414900"}});