post_cb({"35680976": {"CommentCount": "7", "ViewCount": "117", "PostTypeId": "1", "LastEditorUserId": "6612932", "CreationDate": "2016-02-28T09:47:01.773", "LastActivityDate": "2016-09-08T13:46:11.050", "Title": "Iterator requirements satisfaction", "AcceptedAnswerId": "35747288", "LastEditDate": "2016-09-08T13:46:11.050", "Id": "35680976", "Score": "3", "Body": "<p>Consider the following class:</p>\n<pre><code>template &lt;class T&gt;\nstruct X {\n    T&amp; operator*() &amp; { return t; }\n    T&amp; operator*() &amp;&amp; = delete; \n    X&amp; operator++() { return *this; }\n    T t;\n};\n</code></pre>\n<p>Does this class satisfy requirements of Iterator concept by the C++ Standard?\nObject of this class is incrementable and dereferenceable. But dereference of rvalue object is forbidden.</p>\n<pre><code>int main() {\n    X&lt;int&gt; x;\n    *x; // ok\n    *X&lt;int&gt;(); // fail. But is it really necessary for Iterator by Standard?\n}\n</code></pre>\n", "Tags": "<c++><iterator><language-lawyer><c++14>", "OwnerUserId": "3240681", "AnswerCount": "2"}, "35747288": {"ParentId": "35680976", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>With a strict reading of the standard; <a href=\"http://eel.is/c++draft/iterator.requirements#iterator.iterators-2\" rel=\"nofollow\">[iterator.iterators]/2 (\u00a724.2.2/2)</a> does hint at the type <code>X</code> qualifying as an iterator;</p>\n<blockquote>\n<p id=\"so_35680976_35747288_0\">...<code>a</code> and <code>b</code> denote values of type <code>X</code> or <code>const X</code></p>\n<p id=\"so_35680976_35747288_1\">...<code>r</code> denotes a value of <code>X&amp;</code>...</p>\n<p id=\"so_35680976_35747288_2\">A type <code>X</code> satisfies the Iterator requirements if:</p>\n<ul>\n<li>X satisfies the <code>CopyConstructible</code>, <code>CopyAssignable</code>, and <code>Destructible</code> requirements ([utility.arg.requirements]) and lvalues of type <code>X</code> are swappable ([swappable.requirements]), and</li>\n<li><p id=\"so_35680976_35747288_3\">the expressions in Table (below) are valid and have the indicated semantics.</p>\n<ul>\n<li><code>*r</code> (<code>r</code> is dereferenceable)</li>\n<li><code>++r</code> (returns <code>X&amp;</code>)</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>Given the code;</p>\n<pre><code>template &lt;class T&gt;\nstruct X {\n    T&amp; operator*() &amp; { return t; }\n    T&amp; operator*() &amp;&amp; = delete; \n    X&amp; operator++() { return *this; }\n    T t;\n};\nint main()\n{\n    X&lt;int&gt; x;\n    ++x;\n    int i = *x;\n    X&lt;int&gt; y(x);\n    using std::swap;\n    std::swap(x, y);\n}\n</code></pre>\n<p>Certainly does seem to satisfy those requirements.</p>\n<p>However, the story continues, the <em>Iterator</em> concept, as defined above, is not listed as one of the Iterator Categories in the standard <a href=\"http://eel.is/c++draft/iterator.requirements#iterator.requirements.general-2\" rel=\"nofollow\">\u00a724.2.1/2</a>;</p>\n<blockquote>\n<p id=\"so_35680976_35747288_4\">This International Standard defines five categories of iterators, according to the operations defined on them: input iterators, output iterators, forward iterators, bidirectional iterators and random access iterators...</p>\n</blockquote>\n<p>They all define an operation <a href=\"http://eel.is/c++draft/iterator.requirements#tab:iterator.input.requirements\" rel=\"nofollow\"><code>*a</code> and <code>*r++</code></a> for which the type <code>X</code> fails to compile;</p>\n<pre><code>int j = *x++; // fails to compile even with the inclusion of the post increment operator\nconst X&lt;int&gt; xc {};\nint ic = *x1; // no const overloads\n</code></pre>\n<p>For an iterator to be usable within one of the defined categories, it needs to include further members for de-referencing <code>const</code> values, lvalues and rvalues, post increment etc. In the <a href=\"http://eel.is/c++draft/iterator.requirements#iterator.requirements.general-1\" rel=\"nofollow\">spirit of the standard</a>;</p>\n<blockquote>\n<p id=\"so_35680976_35747288_5\">Iterators are a generalization of pointers that allow a C++ program to work with different data structures (containers) in a uniform manner.</p>\n</blockquote>\n<p>The guidance here for the overloaded members and operators is that they can/should be added to enforce compliance and optimise (if possible) the implementation of the semantics of the generalised pointer - not to disallow the semantics; limiting the semantics could have unintended consequences.</p>\n", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2016-03-02T13:25:38.520", "Id": "35747288", "Score": "2", "CreationDate": "2016-03-02T12:28:56.883", "LastActivityDate": "2016-03-02T13:25:38.520"}, "bq_ids": {"n4140": {"so_35680976_35681139_0": {"section_id": 5567, "quality": 0.8, "length": 4}, "so_35680976_35681139_2": {"section_id": 3491, "quality": 0.7142857142857143, "length": 5}, "so_35680976_35747288_4": {"section_id": 5556, "quality": 0.6818181818181818, "length": 15}, "so_35680976_35747288_3": {"section_id": 3491, "quality": 0.7142857142857143, "length": 5}, "so_35680976_35747288_2": {"section_id": 5567, "quality": 1.0, "length": 4}, "so_35680976_35747288_0": {"section_id": 705, "quality": 1.0, "length": 4}, "so_35680976_35681139_1": {"section_id": 5567, "quality": 0.8, "length": 8}, "so_35680976_35747288_5": {"section_id": 5555, "quality": 1.0, "length": 11}}, "n3337": {"so_35680976_35681139_0": {"section_id": 5349, "quality": 0.8, "length": 4}, "so_35680976_35681139_2": {"section_id": 3356, "quality": 0.7142857142857143, "length": 5}, "so_35680976_35747288_4": {"section_id": 5338, "quality": 0.6818181818181818, "length": 15}, "so_35680976_35747288_3": {"section_id": 3356, "quality": 0.7142857142857143, "length": 5}, "so_35680976_35747288_2": {"section_id": 5349, "quality": 1.0, "length": 4}, "so_35680976_35747288_0": {"section_id": 695, "quality": 1.0, "length": 4}, "so_35680976_35681139_1": {"section_id": 5349, "quality": 0.8, "length": 8}, "so_35680976_35747288_5": {"section_id": 5337, "quality": 1.0, "length": 11}}, "n4659": {"so_35680976_35681139_0": {"section_id": 7014, "quality": 0.8, "length": 4}, "so_35680976_35681139_2": {"section_id": 4254, "quality": 0.7142857142857143, "length": 5}, "so_35680976_35747288_4": {"section_id": 7001, "quality": 0.6818181818181818, "length": 15}, "so_35680976_35747288_3": {"section_id": 4254, "quality": 0.7142857142857143, "length": 5}, "so_35680976_35747288_2": {"section_id": 7014, "quality": 1.0, "length": 4}, "so_35680976_35747288_0": {"section_id": 734, "quality": 1.0, "length": 4}, "so_35680976_35681139_1": {"section_id": 7014, "quality": 0.8, "length": 8}, "so_35680976_35747288_5": {"section_id": 7000, "quality": 1.0, "length": 11}}}, "35681139": {"ParentId": "35680976", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Well, the standard doesn't say anything about <code>rvalue</code> referenced iterators. And did not even recognize iterators whose members are overloaded by their reference types. But your code <em>seems</em> acceptable to be an <a href=\"http://en.cppreference.com/w/cpp/concept/Iterator\" rel=\"nofollow\">iterator</a>*, because in defining the requirements for an iterator...</p>\n<p>Quoting section <strong>24.2.2</strong> of the latest <a href=\"http://eel.is/c++draft/iterator.requirements#iterator.iterators-2\" rel=\"nofollow\">C++14 standard draft</a>, (emphasis are mine)</p>\n<blockquote>\n<p id=\"so_35680976_35681139_0\"><strong>24.2.2.2</strong>: A type X satisfies the Iterator requirements if: </p>\n<p id=\"so_35680976_35681139_1\">\u2014 X satisfies the\n  CopyConstructible, CopyAssignable, and Destructible requirements\n  (17.6.3.1) and <em>lvalues</em> of type X are swappable (17.6.3.2), and </p>\n<p id=\"so_35680976_35681139_2\">\u2014 the expressions in Table 106 are valid and have the indicated semantics.</p>\n<ul>\n<li><p id=\"so_35680976_35681139_3\">*r : r is dereferenceable</p></li>\n<li><p id=\"so_35680976_35681139_4\">++r : r is incrementable</p></li>\n</ul>\n</blockquote>\n<p>Other than this, there is no extra constraint on iterator.</p>\n<hr>\n<p>* Of cause, assuming the resulting <code>X&lt;typename ...&gt;</code> satisfies the first listed condition</p>\n</hr>", "OwnerUserId": "1621391", "LastEditorUserId": "1621391", "LastEditDate": "2016-02-28T10:25:55.313", "Id": "35681139", "Score": "1", "CreationDate": "2016-02-28T10:06:21.483", "LastActivityDate": "2016-02-28T10:25:55.313"}});