post_cb({"28410620": {"ParentId": "28410567", "LastEditDate": "2015-02-09T13:31:11.290", "CommentCount": "6", "CreationDate": "2015-02-09T13:10:38.350", "Score": "12", "LastEditorUserId": "1932150", "PostTypeId": "2", "Id": "28410620", "OwnerUserId": "1932150", "Body": "<blockquote>\n<p id=\"so_28410567_28410620_0\">I thought that the return value of <code>f()</code> was copy-initialized by <code>x</code>, but <code>std::unique_ptr</code> is a move-only type</p>\n</blockquote>\n<p>The return value of <code>f()</code> is indeed copy-initialized from the expression <code>x</code>, but copy-initialization does not always imply copy-<em>construction</em>. If the expression is an rvalue, then the move constructor will be picked by overload resolution (assuming a move constructor is present).</p>\n<p>Now although it is true that the expression <code>x</code> in the <code>return x;</code> statement is an lvalue (which may lead you to think that what I just wrote does not apply), in situations where a named object with automatic storage duration is returned, the compiler shall first try to treat the <em>id-expression</em> as an rvalue for overload resolution.</p>\n<blockquote>\n<p id=\"so_28410567_28410620_1\">What is the relevant clause in the standard? Is there somewhere that says if <code>f()</code> is a move-only type than a <code>return</code> statement becomes a move construction instead of a copy construction?</p>\n</blockquote>\n<p>Per paragraph 12.8/32 of the C++ Standard ([class.copy]/32, draft N4296):</p>\n<blockquote>\n<p id=\"so_28410567_28410620_2\">When the criteria for elision of a copy/move operation are met, but not for an exception-declaration, and the object to be copied is designated by an lvalue, or <strong>when the expression in a <code>return</code> statement is a (possibly parenthesized) <em>id-expression</em> that names an object with automatic storage duration declared in the body</strong> or parameter-declaration-clause of the innermost enclosing function or lambda-expression, <strong>overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue.</strong> [...]</p>\n</blockquote>\n", "LastActivityDate": "2015-02-09T13:31:11.290"}, "bq_ids": {"n4140": {"so_28410567_28410620_2": {"section_id": 481, "quality": 0.9761904761904762, "length": 41}}, "n4659": {"so_28410567_28410620_2": {"section_id": 504, "quality": 0.7142857142857143, "length": 30}}}, "28410567": {"CommentCount": "4", "ViewCount": "636", "PostTypeId": "1", "LastEditorUserId": "492336", "CreationDate": "2015-02-09T13:07:14.597", "LastActivityDate": "2015-02-09T13:31:11.290", "Title": "Returning move-only type compiles even though copy-constructor is unavailable", "AcceptedAnswerId": "28410620", "LastEditDate": "2015-02-09T13:28:54.147", "Id": "28410567", "Score": "6", "Body": "<p>The following compiles without error:</p>\n<pre><code>#include &lt;memory&gt;\n\nstd::unique_ptr&lt;int&gt; f() {\n    std::unique_ptr&lt;int&gt; x(new int(42));\n    return x;\n}\n\nint main() {\n    std::unique_ptr&lt;int&gt; y = f();\n}\n</code></pre>\n<p>I thought that the return value of <code>f()</code> was copy-initialized by <code>x</code>, but <code>std::unique_ptr</code> is a move-only type.  How is it that this isn't ill-formed because the copy constructor isn't available?  What is the relevant clause in the standard?  Is there somewhere that says if <code>f()</code> is a move-only type than a return statement becomes a move construction instead of a copy construction?</p>\n", "Tags": "<c++><c++14>", "OwnerUserId": "1131467", "AnswerCount": "1"}});