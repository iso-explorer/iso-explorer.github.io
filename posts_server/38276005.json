post_cb({"bq_ids": {"n4140": {"so_38276005_38280119_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 3208}}, "n3337": {"so_38276005_38280119_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 3082}}, "n4659": {"so_38276005_38280119_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 3965}}}, "38280119": {"Id": "38280119", "PostTypeId": "2", "Body": "<p>MSVC is wrong to accept the code; Clang and GCC (and EDG) are right to reject it. </p>\n<p>This case is similar to the one in <a href=\"https://stackoverflow.com/q/38215737/4326278\">this question</a>, but it involves a different syntactic construct (and different code paths in the compilers, yielding different Standard conformance results, with only EDG being consistent).</p>\n<p>In <code>template&lt;&gt; void Thing::TObserve&lt;0&gt;(Parameter p)</code>, <code>Thing::TObserve&lt;0&gt;</code> is a <em>declarator-id</em>, with <code>Thing::</code> being a <em>nested-name-specifier</em>. [8.3p1] says:</p>\n<blockquote>\n<p id=\"so_38276005_38280119_0\">[...] When the <em>declarator-id</em> is qualified, the declaration shall refer\n  to a previously declared member of the class or namespace to which the\n  qualifier refers (or, in the case of a namespace, of an element of the\n  inline namespace set of that namespace (7.3.1)) or to a specialization\n  thereof; the member shall not merely have been introduced by a\n  <em>using-declaration</em> in the scope of the class or namespace nominated by\n  the <em>nested-name-specifier</em> of the <em>declarator-id</em>. [...]</p>\n</blockquote>\n<p>So, you have to use <code>template&lt;&gt; void TaggedDispatch::TObserve&lt;0&gt;</code>. As noted in the question, using <code>Thing::</code> could create the false impression that you can provide different explicit specializations of <code>TObserve</code> for different derived classes, which is not the case. There's only one <code>TObserve</code> member function template, the one declared in <code>TaggedDispatch</code>, and all such explicit specializations (and implicit or explicit instantiations, and partial specializations) are \"attached\" to that declaration.</p>\n<hr>\n<p>One solution to make things work the way you expect is to declare an <code>Observe</code> member function template in each derived <code>Thing</code>-like class,  possibly providing explicit specializations for relevant <code>Tag</code>s if necessary, and let specializations of the template be automatically wired up to the corresponding <code>Observer</code> interface instance using CRTP:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstddef&gt;\n\nusing Parameter = int;\n\nstruct Observer \n{\n   virtual void Observe(Parameter p) = 0;\n};\n\ntemplate&lt;std::size_t Tag&gt; struct TaggedObserver : Observer { };\n\ntemplate&lt;class Derived, std::size_t Tag&gt; struct CrtpObserver : TaggedObserver&lt;Tag&gt;\n{\n   void Observe(Parameter p) override\n   {\n      static_cast&lt;Derived*&gt;(this)-&gt;template Observe&lt;Tag&gt;(p);\n   }\n};\n\nstruct Thing : CrtpObserver&lt;Thing, 0&gt;, CrtpObserver&lt;Thing, 1&gt;\n{\n   template&lt;std::size_t N&gt; void Observe(Parameter p);\n};\n\ntemplate&lt;&gt; void Thing::Observe&lt;0&gt;(Parameter p)\n{\n   std::cout &lt;&lt; \"Interface #0, Parameter \" &lt;&lt; p &lt;&lt; '\\n';\n}\n\ntemplate&lt;&gt; void Thing::Observe&lt;1&gt;(Parameter p)\n{\n   std::cout &lt;&lt; \"Interface #1, Parameter \" &lt;&lt; p &lt;&lt; '\\n';\n}\n\nint main()\n{\n   Thing test;\n   TaggedObserver&lt;0&gt;* p0 = &amp;test;\n   TaggedObserver&lt;1&gt;* p1 = &amp;test;\n   p0-&gt;Observe(7);\n   p1-&gt;Observe(3);\n}\n</code></pre>\n<p>This places the implementations of the <code>Observer</code> interface in <code>Thing</code> where they belong, while requiring minimal plumbing in each derived class - not much more than what you would have to do anyway if you could separately override each <code>Observer::Observe</code> directly. </p>\n</hr>", "LastEditorUserId": "4326278", "LastActivityDate": "2016-07-09T11:22:19.370", "Score": "1", "CreationDate": "2016-07-09T09:00:14.200", "ParentId": "38276005", "CommentCount": "0", "OwnerUserId": "4326278", "LastEditDate": "2016-07-09T11:22:19.370"}, "38276005": {"ViewCount": "235", "Body": "<p><em>[ EDIT ]</em> I changed the title from <code>works</code> to <code>compiles</code> since it turns out that it doesn't truly work after all (thanks @bogdan for the comments). I added code at the end of the post showing why and how.</p>\n<p>The second part of the question still stands - is there a way to \"<em>fix</em>\" it? The crux of the matter is having a virtual function <code>Observe</code> in a base <code>template&lt;int N&gt; class X</code> be rerouted to a templated function <code>Observe&lt;N&gt;</code> in classes derived from <code>X&lt;N&gt;</code>, without requiring any supporting code in <code>X</code>.</p>\n<p>For an example of how it can be done by requiring <code>X</code> to cooperate see <a href=\"https://stackoverflow.com/a/38275593/5538420\">this answer</a> to the other question (which basically requires that <code>Observe&lt;N&gt;</code> be declared into the most derived class).\n<hr>\nWhile looking at this other question <a href=\"https://stackoverflow.com/questions/38271718/choosing-which-base-class-to-override-method-of\">Choosing which base class to override method of</a> I found out that the following snippet compiles cleanly on <code>vc++ 2015</code> (with <code>/W4 /Za</code>) and returns the expected output, yet fails to compile on  <code>gcc-5.1</code> and <code>clang 3.7</code> (tried at <a href=\"https://ideone.com\" rel=\"nofollow noreferrer\">ideone.com</a>).</hr></p>\n<p>I am aware that specialization of template functions has many pitfalls, but I am still curious which letter of the C++ standard applies in this case, and - in the likely case that the code is not fully compliant - whether there is an easy way to \"fix\" it.</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\ntypedef int Parameter;\n\nclass Observer\n{\npublic:\n    virtual void Observe(Parameter p) = 0;\n};\n\nclass TaggedDispatch\n{\npublic:\n    template&lt;size_t Tag&gt; void TObserve(Parameter p);\n};\n\ntemplate&lt;size_t Tag&gt;\nclass TaggedObserver : virtual public TaggedDispatch, public Observer \n{ \npublic:\n    virtual void Observe(Parameter p) override\n    {   TObserve&lt;Tag&gt;(p); }\n};\n\nclass Thing : public TaggedObserver&lt;0&gt;, TaggedObserver&lt;11&gt;\n{   };\n\ntemplate&lt;&gt; void Thing::TObserve&lt;0&gt;(Parameter p)\n{   cout &lt;&lt; \"Parent #  0, Parameter \" &lt;&lt; p &lt;&lt; endl; }\n\ntemplate&lt;&gt; void Thing::TObserve&lt;11&gt;(Parameter p)\n{   cout &lt;&lt; \"Parent # 11, Parameter \" &lt;&lt; p &lt;&lt; endl; }\n\nint main(int, char **)\n{\n    Thing test;\n    test.TObserve&lt;0&gt;(101);\n    test.TObserve&lt;11&gt;(999);\n\n    return 0;\n}\n</code></pre>\n<p>Output when compiled with <code>vc++ 2015</code>.</p>\n<pre><code>Parent #  0, Parameter 101\nParent # 11, Parameter 999\n</code></pre>\n<p>Compile errors from<code>gcc-5.1</code></p>\n<pre><code>prog.cpp:29:17: error: template-id 'TObserve&lt;0&gt;' for 'void Thing::TObserve(Parameter)' does not match any template declaration\n template&lt;&gt; void Thing::TObserve&lt;0&gt;(Parameter p)\n                 ^\nprog.cpp:32:17: error: template-id 'TObserve&lt;11&gt;' for 'void Thing::TObserve(Parameter)' does not match any template declaration\n template&lt;&gt; void Thing::TObserve&lt;11&gt;(Parameter p)\n</code></pre>\n<p>Compile errors from <code>clang 3.7</code>.</p>\n<pre><code>prog.cpp:22:36: warning: 'override' keyword is a C++11 extension [-Wc++11-extensions]\n        virtual void Observe(Parameter p) override\n                                          ^\nprog.cpp:29:24: error: no function template matches function template specialization 'TObserve'\ntemplate&lt;&gt; void Thing::TObserve&lt;0&gt;(Parameter p)\n                       ^\nprog.cpp:32:1: error: extraneous 'template&lt;&gt;' in declaration of variable 'TObserve'\ntemplate&lt;&gt; void Thing::TObserve&lt;11&gt;(Parameter p)\n^~~~~~~~~~\nprog.cpp:32:24: error: variable has incomplete type 'void'\ntemplate&lt;&gt; void Thing::TObserve&lt;11&gt;(Parameter p)\n                       ^\nprog.cpp:32:32: error: expected ';' at end of declaration\ntemplate&lt;&gt; void Thing::TObserve&lt;11&gt;(Parameter p)\n                               ^\n                               ;\nprog.cpp:32:32: error: expected unqualified-id\n1 warning and 5 errors generated.\n</code></pre>\n<p><hr>\n<em>[ EDIT ]</em> It doesn't truly work in <code>vc++ 2015</code> after all. What appears to happen is that the compiler allows the <code>void Thing::TObserve&lt;0&gt;</code> definition, but internally maps it to <code>void TaggedDispatch::TObserve&lt;0&gt;</code>. This becomes obvious if adding another derived class e.g.</hr></p>\n<pre><code>class Other : public TaggedObserver&lt;0&gt;\n{    };\n\ntemplate&lt;&gt; void Other::TObserve&lt;0&gt;(Parameter p)\n{    cout &lt;&lt; \"Parent # 00, Parameter \" &lt;&lt; p &lt;&lt; endl; }\n</code></pre>\n<p>Then the <code>vc++ 2015</code> compile fails with the error message:</p>\n<pre><code>error C2766: explicit specialization; 'void TaggedDispatch::TObserve&lt;0&gt;(Parameter)' has already been defined\n</code></pre>\n", "AcceptedAnswerId": "38280119", "Title": "case of template member function specialization that compiles on msvc, not others", "CreationDate": "2016-07-08T22:04:20.500", "Id": "38276005", "CommentCount": "5", "LastEditDate": "2017-05-23T12:08:09.503", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-09T11:22:19.370", "Score": "1", "OwnerUserId": "5538420", "Tags": "<c++><gcc><visual-c++><clang><language-lawyer>", "AnswerCount": "1"}});