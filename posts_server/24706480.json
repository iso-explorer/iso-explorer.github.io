post_cb({"24706610": {"Id": "24706610", "PostTypeId": "2", "Body": "<p>Minimized example:</p>\n<pre><code>class A { };\nclass B : public A { };\nclass C : public A { };\n\nint main() {\n    B b;\n    C c;\n    A&amp; refA = true? b : c;\n}\n</code></pre>\n<p>Clang reports:</p>\n<pre><code>main.cpp:13:19: error: incompatible operand types ('B' and 'C')\n    A&amp; refA = true? b : c;\n</code></pre>\n<p>The relevant rule is found in \u00a75.16 [expr.cond]/p3-6 of the standard:</p>\n<blockquote>\n<p id=\"so_24706480_24706610_0\">3 Otherwise, if the second and third operand have different types and\n  either has (possibly cv-qualified) class type, or if both are glvalues\n  of the same value category and the same type except for\n  cv-qualification, an attempt is made to convert each of those operands\n  to the type of the other. The process for determining whether an\n  operand expression E1 of type T1 can be converted to match an operand\n  expression E2 of type T2 is defined as follows:</p>\n<ul>\n<li>If E2 is an lvalue: E1 can be converted to match E2 if E1 can be implicitly converted (Clause 4) to the type \u201clvalue reference to T2\u201d,\n  subject to the constraint that in the conversion the reference must\n  bind directly (8.5.3) to an lvalue.</li>\n<li>If E2 is an xvalue: E1 can be converted to match E2 if E1 can be implicitly converted to the type \u201crvalue reference to T2\u201d, subject to\n  the constraint that the reference must bind directly.</li>\n<li>If E2 is a prvalue or if neither of the conversions above can be done and at least one of the operands has (possibly cv-qualified)\n  class type:\n  <ul>\n<li>if E1 and E2 have class type, and the underlying class types are the same or one is a base class of the other: E1 can be converted to\n  match E2 if the class of T2 is the same type as, or a base class of,\n  the class of T1, and the cv-qualification of T2 is the same\n  cv-qualification as, or a greater cv-qualification than, the\n  cv-qualification of T1. If the conversion is applied, E1 is changed to\n  a prvalue of type T2 by copy-initializing a temporary of type T2 from\n  E1 and using that temporary as the converted operand.</li>\n<li>Otherwise (i.e., if E1 or E2 has a nonclass type, or if they both have class types but the underlying classes are not either the same or\n  one a base class of the other): E1 can be converted to match E2 if E1\n  can be implicitly converted to the type that expression E2 would have\n  if E2 were converted to a prvalue (or the type it has, if E2 is a\n  prvalue).</li>\n</ul></li>\n</ul>\n<p id=\"so_24706480_24706610_1\">Using this process, it is determined whether the second operand can be\n  converted to match the third operand, and whether the third operand\n  can be converted to match the second operand. If both can be\n  converted, or one can be converted but the conversion is ambiguous,\n  the program is ill-formed. If neither can be converted, the operands\n  are left unchanged and further checking is performed as described\n  below. If exactly one conversion is possible, that conversion is\n  applied to the chosen operand and the converted operand is used in\n  place of the original operand for the remainder of this section.</p>\n<p id=\"so_24706480_24706610_2\">4 If the second and third operands are glvalues of the same value\n  category and have the same type, the result is of that type and value\n  category and it is a bit-field if the second or the third operand is a\n  bit-field, or if both are bit-fields.</p>\n<p id=\"so_24706480_24706610_3\">5 Otherwise, the result is a prvalue. If the second and third operands\n  do not have the same type, and either has (possibly cv-qualified)\n  class type, overload resolution is used to determine the conversions\n  (if any) to be applied to the operands (13.3.1.2, 13.6). If the\n  overload resolution fails, the program is ill-formed. Otherwise, the\n  conversions thus determined are applied, and the converted operands\n  are used in place of the original operands for the remainder of this\n  section.</p>\n<p id=\"so_24706480_24706610_4\">6 Lvalue-to-rvalue (4.1), array-to-pointer (4.2), and\n  function-to-pointer (4.3) standard conversions are performed on the\n  second and third operands. After those conversions, one of the\n  following shall hold:</p>\n<ul>\n<li>The second and third operands have the same type; the result is of that type. If the operands have class type, the result is a prvalue\n  temporary of the result type, which is copy-initialized from either\n  the second operand or the third operand depending on the value of the\n  first operand.</li>\n<li>The second and third operands have arithmetic or enumeration type; the usual arithmetic conversions are performed to bring them to a\n  common type, and the result is of that type.</li>\n<li>One or both of the second and third operands have pointer type; pointer conversions (4.10) and qualification conversions (4.4) are\n  performed to bring them to their composite pointer type (Clause 5).\n  The result is of the composite pointer type.</li>\n<li>One or both of the second and third operands have pointer to member type; pointer to member conversions (4.11) and qualification\n  conversions (4.4) are performed to bring them to their composite\n  pointer type (Clause 5). The result is of the composite pointer type.</li>\n<li>Both the second and third operands have type <code>std::nullptr_t</code> or one has that type and the other is a null pointer constant. The result is\n  of type <code>std::nullptr_t</code>.</li>\n</ul>\n</blockquote>\n<p>The crucial point is that this will always attempt to convert one operand to match the type of the other, rather than convert both to a third type, until you hit paragraph 5, at which point the compiler starts looking for user-defined implicit conversions to pointer or arithmetic types (those are only possible arguments to the built-in candidate functions for <code>operator?:</code> defined in \u00a713.6), and for your purposes, you really don't want it to get there.</p>\n<p>In the minimized example, which correlates directly to your error case (<code>A</code> = <code>istream</code>, <code>B</code> = <code>ifstream</code>, <code>C</code> = <code>istringstream</code>), converting one to the type of the other is not possible, and so the logic goes down to p5, and the compiler looks for user-defined implicit conversions. In the minimized example there's no conversion, overload resolution fails, and the whole thing is ill-formed. In your error case, pre-C++11 (and in libstdc++ post-C++11, apparently) there's an implicit conversion from a stream to <code>void *</code>, so the compiler does that, giving the whole expression a <code>void *</code> type, but that obviously can't bind to a reference to <code>std::istream</code>, so that's the error you see.</p>\n<p>In your second case:</p>\n<pre><code>ifs.is_open() ? ifs : true ? iss : std::cin;\n</code></pre>\n<p><code>std::cin</code> has type <code>std::istream</code>, and <code>std::istringstream</code> can be converted to its base class <code>std::istream</code>, so the inner conditional expression is well-formed and has type <code>std::istream</code>. Then with the outer conditional expression, again the type of the second operand, <code>std::ifstream</code>, is convertible to the type of the third operand, <code>std::istream</code>, so the entire expression is well-formed and has the right type to bind to the reference.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-10-11T17:07:13.883", "Score": "26", "CreationDate": "2014-07-11T21:10:42.617", "ParentId": "24706480", "CommentCount": "4", "LastEditDate": "2014-10-11T17:07:13.883", "OwnerUserId": "2756719"}, "24706569": {"Id": "24706569", "PostTypeId": "2", "Body": "<p>gcc is complaining because the ifs and iss are two different types.  static_casting the types to std::istream&amp; will solve your problem.</p>\n", "LastActivityDate": "2014-07-11T21:07:34.090", "CommentCount": "1", "CreationDate": "2014-07-11T21:07:34.090", "ParentId": "24706480", "Score": "1", "OwnerUserId": "3830929"}, "24706585": {"Id": "24706585", "PostTypeId": "2", "Body": "<p>If you have a base class and a derived class, the ternary conditional operator knows to convert the derived class to the base class. But if you have two derived classes, it doesn't know to convert them to their common base class. This isn't gcc acting up; this is just how the ternary conditional operator is specified to work in the standard.</p>\n<pre><code>std::istream&amp; is = ifs.is_open() ? ifs : std::cin;\n</code></pre>\n<p>This works fine because <code>std::cin</code> has type <code>std::istream</code>, which is a base class of <code>std::ifstream</code>.</p>\n<pre><code>std::istream&amp; is = ifs.is_open() ? ifs : iss; // won't compile\n</code></pre>\n<p>This doesn't work because <code>std::ifstream</code> and <code>std::istringstream</code> \"only\" have a common base class.</p>\n<pre><code>std::istream&amp; is = ifs.is_open() ? ifs : true ? iss : std::cin; // fudge works\n</code></pre>\n<p>This works because it is parsed as:</p>\n<pre><code>std::istream&amp; is = ifs.is_open() ? ifs : (true ? iss : std::cin);\n</code></pre>\n<p>and the parenthesized expression has type <code>std::istream</code>. So <code>iss</code> is converted into an lvalue of type <code>std::istream</code>, if selected, and <code>ifs</code> is also converted similarly.</p>\n", "LastActivityDate": "2014-07-11T21:08:36.497", "CommentCount": "0", "CreationDate": "2014-07-11T21:08:36.497", "ParentId": "24706480", "Score": "13", "OwnerUserId": "481267"}, "bq_ids": {"n4140": {"so_24706480_24706610_0": {"length": 43, "quality": 0.9772727272727273, "section_id": 6169}, "so_24706480_24706610_3": {"length": 36, "quality": 0.9473684210526315, "section_id": 6171}, "so_24706480_24706610_1": {"length": 55, "quality": 1.0, "section_id": 6169}, "so_24706480_24706610_2": {"length": 21, "quality": 1.0, "section_id": 6170}, "so_24706480_24706610_4": {"length": 14, "quality": 1.0, "section_id": 6172}}, "n3337": {"so_24706480_24706610_0": {"length": 43, "quality": 0.9772727272727273, "section_id": 5930}, "so_24706480_24706610_4": {"length": 14, "quality": 1.0, "section_id": 5933}, "so_24706480_24706610_1": {"length": 55, "quality": 1.0, "section_id": 5930}, "so_24706480_24706610_3": {"length": 36, "quality": 0.9473684210526315, "section_id": 5932}, "so_24706480_24706610_2": {"length": 21, "quality": 1.0, "section_id": 5931}}, "n4659": {"so_24706480_24706610_0": {"length": 35, "quality": 0.7954545454545454, "section_id": 7667}, "so_24706480_24706610_4": {"length": 14, "quality": 1.0, "section_id": 7670}, "so_24706480_24706610_1": {"length": 38, "quality": 0.6909090909090909, "section_id": 7667}, "so_24706480_24706610_3": {"length": 36, "quality": 0.9473684210526315, "section_id": 7669}, "so_24706480_24706610_2": {"length": 21, "quality": 1.0, "section_id": 7668}}}, "24706480": {"ViewCount": "1515", "Body": "<p>I am used to writing little command line tools that take either a file name or read from <code>std::cin</code>, so I have been using this pattern for quite a while:</p>\n<pre><code>int main(int argc, char* argv[])\n{\n    std::string filename;\n\n    // args processing ...\n\n    std::ifstream ifs;\n\n    if(!filename.empty())\n        ifs.open(filename);\n\n    std::istream&amp; is = ifs.is_open() ? ifs : std::cin;\n\n    std::string line;\n    while(std::getline(is, line))\n    {\n        // process line...\n    }\n\n    return 0;\n}\n</code></pre>\n<p>After reading a question on Stack Overflow, I tried to modify my usual pattern to suit the need to read either from a file or from a <code>std::istringstream</code>. To my surprise it won't compile and gives this error:</p>\n<blockquote id=\"so_24706480_24706480_0\">\n<pre><code>temp.cpp:164:47: error: invalid initialization of non-const reference of type \u2018std::istream&amp; {aka std::basic_istream&lt;char&gt;&amp;}\u2019 from an rvalue of type \u2018void*\u2019\n      std::istream&amp; is = ifs.is_open() ? ifs : iss; // won't compile\n</code></pre>\n</blockquote>\n<p>Which looks to me like it's trying to convert the <code>std::istringstream</code> object (<code>iss</code>) to a boolean and getting its <code>operator void*()</code>.</p>\n<pre><code>int main(int argc, char* argv[])\n{\n    std::string filename;\n    std::string data;\n\n    // args processing ...\n\n    std::ifstream ifs;\n    std::istringstream iss;\n\n    if(!filename.empty())\n        ifs.open(filename);\n\n    std::istream&amp; is = ifs.is_open() ? ifs : iss; // won't compile\n\n    std::string line;\n    while(std::getline(is, line))\n    {\n        // process line...\n    }\n\n    return 0;\n}\n</code></pre>\n<ol>\n<li><p>Why is it treating <code>std::istringstream</code> differently from <code>std::cin</code> and <code>std::ifstream</code>? They all derive from <code>std::istream</code>.</p>\n<p>Then I remembered having converted my pattern to accommodate three possibilities, reading from file, string or <code>std::cin</code>. And I remember that worked (although it's pretty clumsy). So applying the triple solution to this problem I came up with a fudge that totally works:</p>\n<pre><code>int main(int argc, char* argv[])\n{\n    std::string filename;\n    std::string data;\n\n    // args processing ...\n\n    std::ifstream ifs;\n    std::istringstream iss;\n\n    if(!filename.empty())\n        ifs.open(filename);\n\n    std::istream&amp; is = ifs.is_open() ? ifs : true ? iss : std::cin; // fudge works\n\n    std::string line;\n    while(std::getline(is, line))\n    {\n        // process line...\n    }\n\n    return 0;\n}\n</code></pre></li>\n<li><p>Why does this fudge work? Is GCC breaking any rules on how the ternary operator (<code>?:</code>) resolves its types? Or am I missing something?</p></li>\n</ol>\n", "AcceptedAnswerId": "24706610", "Title": "Why does std::istringstream appear to resolve differently to std::ifstream in the ternary (?:) operator?", "CreationDate": "2014-07-11T21:00:22.793", "Id": "24706480", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-07-12T04:15:53.223", "LastEditorUserId": "2756719", "LastActivityDate": "2014-10-11T17:07:13.883", "Score": "24", "OwnerUserId": "3807729", "Tags": "<c++><c++11><conditional-operator>", "AnswerCount": "4"}, "24706557": {"Id": "24706557", "PostTypeId": "2", "Body": "<p>The compiler tries to find a common type for both result from the ternary operator, and if you see e.g. <a href=\"http://en.cppreference.com/w/cpp/io/basic_ios\">this reference</a> you will see there is a <a href=\"http://en.cppreference.com/w/cpp/io/basic_ios/operator_bool\">casting operator override for <code>void*</code> (or <code>bool</code> for C++11 and later)</a>, so the compiler uses that.</p>\n<p>But then when it tries to do the assignment, it errors out because on the right-hand side of the initialization you have a <code>void*</code> (alternatively <code>bool</code>) type, and on the left-hand side there's a reference to <code>std::istream</code>.</p>\n<p>To solve it you have to manually cast each stream to a reference to <code>std::istream</code> with e.g. <code>static_cast</code>.</p>\n", "LastActivityDate": "2014-07-11T21:06:44.877", "CommentCount": "4", "CreationDate": "2014-07-11T21:06:44.877", "ParentId": "24706480", "Score": "6", "OwnerUserId": "440558"}});