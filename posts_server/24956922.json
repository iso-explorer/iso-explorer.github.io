post_cb({"bq_ids": {"n4140": {"so_24956922_24957263_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 669}}, "n3337": {"so_24956922_24957263_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 659}}, "n4659": {"so_24956922_24957263_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 697}}}, "24957263": {"Id": "24957263", "PostTypeId": "2", "Body": "<p>The C++ Standard, section \u00a7 13.5.8 ( User-defined literals), lists all the valid types :</p>\n<blockquote>\n<p id=\"so_24956922_24957263_0\">The declaration of a literal operator shall have a\n  parameter-declaration-clause equivalent to one of the following: </p>\n<ul>\n<li>const char*</li>\n<li>unsigned long long int</li>\n<li>long double</li>\n<li>char</li>\n<li>wchar_t</li>\n<li>char16_t</li>\n<li>char32_t</li>\n<li>const char*, std::size_t</li>\n<li>const wchar_t*, std::size_t</li>\n<li>const char16_t*, std::size_t</li>\n<li>const char32_t*, std::size_t</li>\n</ul>\n</blockquote>\n<p>Neither <code>double</code> or <code>double&amp;</code> , <code>const long double&amp;</code> are listed here : so they are not allowed.</p>\n", "LastEditorUserId": "3510483", "LastActivityDate": "2014-07-25T14:14:01.917", "Score": "5", "CreationDate": "2014-07-25T13:47:20.693", "ParentId": "24956922", "CommentCount": "2", "OwnerUserId": "3510483", "LastEditDate": "2014-07-25T14:14:01.917"}, "24956922": {"ViewCount": "370", "Body": "<p>I'm experimenting with C++ custom literals. I'm finding it strange that the simple function below stops working when I change the type from <code>long double</code> type to <code>double</code>, or when try to pass by reference. </p>\n<p>At first I thought it had to do with the use of <code>constexpr</code> but that does not seem to be the case, as both of these work fine if it's not on an <code>operator \"\"</code>, and removing the <code>constexpr</code> from the <code>operator \"\"</code> does not remove the error.</p>\n<p>Are these well-thought-out decisions in the design of the language, or just nuances that my compiler (gcc 4.8.2) can't deal with?</p>\n<pre><code>// Conversion function, works fine with both long double and\n// double, and with or without pass by reference.\nconstexpr long double to_deg (const long double&amp; deg)\n{\n    return deg*M_PI/180.0;\n}\n\n// Custom literal with long double types and pass by value,\n// works fine.\nconstexpr long double operator \"\" _deg (long double deg)\n{\n    return deg*M_PI/180.0;\n}\n\n// Custom literal with double types, gives \"Invalid argument list.\"\n// error.\nconstexpr double operator \"\" _deg (double deg)\n{\n    return deg*M_PI/180.0;\n}\n\n// Custom literal with pass by reference, gives \"Invalid argument list.\" \n// error. Removing the const does not remove the error.\nconstexpr long double operator \"\" _deg (const long double&amp; deg)\n{\n    return deg*M_PI/180.0;\n}\n</code></pre>\n", "AcceptedAnswerId": "24957263", "Title": "Custom literal works with long double but not double, and with pass by value but not pass by reference", "CreationDate": "2014-07-25T13:30:44.827", "Id": "24956922", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-07-25T14:14:01.917", "Score": "4", "OwnerUserId": "1391081", "Tags": "<c++><c++11><literals><constexpr><user-defined-literals>", "AnswerCount": "1"}});