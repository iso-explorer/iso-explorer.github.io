post_cb({"2722898": {"ParentId": "2722879", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Both lines are in fact correct but do subtly different things.  </p>\n<p>The first line creates a new object on the stack by calling a constructor of the format <code>Thing(const char*)</code>.  </p>\n<p>The second one is a bit more complex.  It essentially does the following</p>\n<ol>\n<li>Create an object of type <code>Thing</code> using the constructor <code>Thing(const char*)</code></li>\n<li>Create an object of type <code>Thing</code> using the constructor <code>Thing(const Thing&amp;)</code></li>\n<li>Call <code>~Thing()</code> on the object created in step #1</li>\n</ol>\n", "OwnerUserId": "23283", "LastEditorUserId": "23283", "LastEditDate": "2010-04-27T16:18:16.037", "Id": "2722898", "Score": "104", "CreationDate": "2010-04-27T16:12:24.740", "LastActivityDate": "2010-04-27T16:18:16.037"}, "2722960": {"ParentId": "2722879", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I assume with the second line you actually mean:</p>\n<pre><code>Thing *thing = new Thing(\"uiae\");\n</code></pre>\n<p>which would be the standard way of creating new <em>dynamic</em> objects (necessary for dynamic binding and polymorphism) and storing their address to a pointer. Your code does what JaredPar described, namely creating two objects (one passed a <code>const char*</code>, the other passed a <code>const Thing&amp;</code>), and then calling the destructor (<code>~Thing()</code>) on the first object (the <code>const char*</code> one).</p>\n<p>By contrast, this:</p>\n<pre><code>Thing thing(\"uiae\");\n</code></pre>\n<p>creates a static object which is destroyed automatically upon exiting the current scope.</p>\n", "OwnerUserId": "112968", "LastEditorUserId": "112968", "LastEditDate": "2015-10-14T07:30:02.917", "Id": "2722960", "Score": "27", "CreationDate": "2010-04-27T16:20:16.453", "LastActivityDate": "2015-10-14T07:30:02.917"}, "2723266": {"ParentId": "2722879", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The compiler may well optimize the second form into the first form, but it doesn't have to.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n\nclass A\n{\n    public:\n        A() { std::cerr &lt;&lt; \"Empty constructor\" &lt;&lt; std::endl; }\n        A(const A&amp;) { std::cerr &lt;&lt; \"Copy constructor\" &lt;&lt; std::endl; }\n        A(const char* str) { std::cerr &lt;&lt; \"char constructor: \" &lt;&lt; str &lt;&lt; std::endl; }\n        ~A() { std::cerr &lt;&lt; \"destructor\" &lt;&lt; std::endl; }\n};\n\nvoid direct()\n{\n    std::cerr &lt;&lt; std::endl &lt;&lt; \"TEST: \" &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;\n    A a(__FUNCTION__);\n    static_cast&lt;void&gt;(a); // avoid warnings about unused variables\n}\n\nvoid assignment()\n{\n    std::cerr &lt;&lt; std::endl &lt;&lt; \"TEST: \" &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;\n    A a = A(__FUNCTION__);\n    static_cast&lt;void&gt;(a); // avoid warnings about unused variables\n}\n\nvoid prove_copy_constructor_is_called()\n{\n    std::cerr &lt;&lt; std::endl &lt;&lt; \"TEST: \" &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;\n    A a(__FUNCTION__);\n    A b = a;\n    static_cast&lt;void&gt;(b); // avoid warnings about unused variables\n}\n\nint main()\n{\n    direct();\n    assignment();\n    prove_copy_constructor_is_called();\n    return 0;\n}\n</code></pre>\n<p>Output from gcc 4.4:</p>\n<pre><code>TEST: direct\nchar constructor: direct\ndestructor\n\nTEST: assignment\nchar constructor: assignment\ndestructor\n\nTEST: prove_copy_constructor_is_called\nchar constructor: prove_copy_constructor_is_called\nCopy constructor\ndestructor\ndestructor\n</code></pre>\n", "OwnerUserId": "3978", "LastEditorUserId": "3087601", "LastEditDate": "2016-05-12T13:50:06.473", "Id": "2723266", "Score": "16", "CreationDate": "2010-04-27T17:00:18.587", "LastActivityDate": "2016-05-12T13:50:06.473"}, "30948607": {"ParentId": "2722879", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In append to <strong>JaredPar</strong> answer</p>\n<p>1-usual ctor, 2nd-function-like-ctor with temporary object.</p>\n<p>Compile this source somewhere here <a href=\"http://melpon.org/wandbox/\" rel=\"nofollow\">http://melpon.org/wandbox/</a> with different compilers</p>\n<pre><code>// turn off rvo for clang, gcc with '-fno-elide-constructors'\n\n#include &lt;stdio.h&gt;\nclass Thing {\npublic:\n    Thing(const char*){puts(__FUNCTION__ );}\n    Thing(const Thing&amp;){puts(__FUNCTION__ );}   \n    ~Thing(){puts(__FUNCTION__);}\n};\nint main(int /*argc*/, const char** /*argv*/) {\n    Thing myThing = Thing(\"asdf\");\n}\n</code></pre>\n<p>And you will see the result.</p>\n<p>From ISO/IEC 14882 2003-10-15</p>\n<blockquote>\n<p id=\"so_2722879_30948607_0\">8.5,  part 12</p>\n</blockquote>\n<p>Your 1st,2nd construction are called direct-initialization</p>\n<blockquote>\n<p id=\"so_2722879_30948607_1\">12.1, part 13</p>\n<p id=\"so_2722879_30948607_2\">A functional notation type conversion (5.2.3) can be used to create\n  new objects of its type. [Note: The syntax looks like an explicit call\n  of the constructor. ] ... An object created in this way is unnamed. \n  [Note: 12.2 describes the lifetime of temporary objects. ]  [Note:\n  explicit constructor calls do not yield lvalues, see 3.10. ]</p>\n</blockquote>\n<hr>\n<p>Where to read about RVO:</p>\n<blockquote>\n<p id=\"so_2722879_30948607_3\">12 Special member functions / 12.8 Copying class objects/ Part 15 </p>\n<p id=\"so_2722879_30948607_4\">When certain criteria are met, an implementation is allowed to omit\n  the copy construction of a class object, <strong>even</strong> if the copy constructor\n  and/or destructor for the object have <strong>side effects</strong>.</p>\n</blockquote>\n<p>Turn off it with compiler flag from comment to view such copy-behavior)</p>\n</hr>", "OwnerUserId": "1154447", "LastEditorUserId": "1154447", "LastEditDate": "2015-07-02T10:10:11.970", "Id": "30948607", "Score": "1", "CreationDate": "2015-06-19T23:16:27.173", "LastActivityDate": "2015-07-02T10:10:11.970"}, "2727379": {"ParentId": "2722879", "CommentCount": "1", "Body": "<p>I played a bit with it and the syntax seems to get quite strange when a constructor takes no arguments. Let me give an example:</p>\n<pre><code>#include &lt;iostream&gt; \n\nusing namespace std;\n\nclass Thing\n{\npublic:\n    Thing();\n};\n\nThing::Thing()\n{\n    cout &lt;&lt; \"Hi\" &lt;&lt; endl;\n}\n\nint main()\n{\n    //Thing myThing(); // Does not work\n    Thing myThing; // Works\n\n}\n</code></pre>\n<p>so just writing Thing myThing w/o brackets actually calls the constructor, while Thing myThing() makes the compiler thing you want to create a function pointer or something ??!!</p>\n", "OwnerUserId": "44232", "PostTypeId": "2", "Id": "2727379", "Score": "0", "CreationDate": "2010-04-28T06:57:58.033", "LastActivityDate": "2010-04-28T06:57:58.033"}, "2722958": {"ParentId": "2722879", "CommentCount": "0", "Body": "<p>Quite simply, both lines create the object on the stack, rather than on the heap as 'new' does. The second line actually involves a second call to a copy constructor, so it should be avoided (it also needs to be corrected as indicated in the comments). You should use the stack for small objects as much as possible since it is faster, however if your objects are going to survive for longer than the stack frame, then it's clearly the wrong choice.</p>\n", "OwnerUserId": "142088", "PostTypeId": "2", "Id": "2722958", "Score": "7", "CreationDate": "2010-04-27T16:19:59.293", "LastActivityDate": "2010-04-27T16:19:59.293"}, "2722879": {"CommentCount": "4", "AcceptedAnswerId": "2722898", "PostTypeId": "1", "LastEditorUserId": "1469954", "CreationDate": "2010-04-27T16:09:58.567", "LastActivityDate": "2016-05-12T13:50:06.473", "LastEditDate": "2015-01-13T06:51:53.640", "ViewCount": "82975", "FavoriteCount": "34", "Title": "Calling constructors in c++ without new", "Id": "2722879", "Score": "96", "Body": "<p>I've often seen that people create objects in C++ using</p>\n<pre><code>Thing myThing(\"asdf\");\n</code></pre>\n<p>Instead of this:</p>\n<pre><code>Thing myThing = Thing(\"asdf\");\n</code></pre>\n<p>This seems to work (using gcc), at least as long as there are no templates involved. My question now, is the first line correct and if so should I use it?</p>\n", "Tags": "<c++>", "OwnerUserId": "44232", "AnswerCount": "7"}, "2722968": {"ParentId": "2722879", "CommentCount": "3", "Body": "<p>Ideally, a compiler would optimize the second, but it's not required. The first is the best way. However, it's pretty critical to understand the distinction between stack and heap in C++, sine you must manage your own heap memory.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "2722968", "Score": "2", "CreationDate": "2010-04-27T16:21:35.610", "LastActivityDate": "2010-04-27T16:21:35.610"}, "bq_ids": {"n4140": {"so_2722879_30948607_4": {"section_id": 480, "quality": 0.9, "length": 18}}, "n3337": {"so_2722879_30948607_4": {"section_id": 471, "quality": 0.9, "length": 18}}, "n4659": {"so_2722879_30948607_4": {"section_id": 502, "quality": 0.9, "length": 18}}}});