post_cb({"bq_ids": {"n4140": {"so_32016483_32016834_1": {"length": 15, "quality": 1.0, "section_id": 434}}, "n3337": {"so_32016483_32016834_1": {"length": 15, "quality": 1.0, "section_id": 426}}, "n4659": {"so_32016483_32016834_1": {"length": 15, "quality": 1.0, "section_id": 452}}}, "32016834": {"Id": "32016834", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32016483_32016834_0\">I know that here the most derived class calls the Parent class default constructor unless specified otherwise.</p>\n</blockquote>\n<p>There's more to it than that. The most derived class <strong>always</strong> has the sole responsibility to initialize the virtual base classes. No exceptions!</p>\n<p>If the most derived class's constructor doesn't specify a <em>mem-initializer</em> for the virtual base class, the virtual base class is default-constructed. It doesn't matter if the \"intermediate\" classes specify <em>mem-initializers</em> for the virtual base class. Those are simply ignored. They are <strong>only</strong> used when that class is the most derived class being constructed.</p>\n<blockquote>\n<p id=\"so_32016483_32016834_1\">A <em>mem-initializer</em> where the <em>mem-initializer-id</em> denotes a virtual base class is ignored during execution of a constructor of any class that is not the most derived class.</p>\n</blockquote>\n<p>(C++14 standard, [class.base.init]/7)</p>\n", "LastActivityDate": "2015-08-14T18:46:58.437", "CommentCount": "6", "CreationDate": "2015-08-14T18:46:58.437", "ParentId": "32016483", "Score": "2", "OwnerUserId": "481267"}, "32016483": {"ViewCount": "74", "Body": "<p>My Code:</p>\n<pre><code>class Parent\n{\npublic: Parent() { cout &lt;&lt; \"Default Parent\" &lt;&lt; endl; }\n        Parent(int x) { cout &lt;&lt; \"Parameterized Parent\" &lt;&lt; endl; }\n};\nclass Child1: virtual public Parent\n{\npublic: Child1() :Parent(10) { cout &lt;&lt; \"Default Child1\" &lt;&lt; endl; }\n};\nclass Child2: virtual public Parent\n{\npublic: Child2() :Parent(10) { cout &lt;&lt; \"Default Child1\" &lt;&lt; endl; }\n};\nclass GrandChild: public Child1, public Child2\n{\npublic:\n    GrandChild() { cout &lt;&lt; \"Default GrandChild\" &lt;&lt; endl; }\n};\nint main()\n{\n    GrandChild G;\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>default Parent\ndefault Child1\ndefault Child2\ndefault GrandChild\n</code></pre>\n<p>I know that here the most derived class calls the Parent class default constructor unless specified otherwise.</p>\n<p>But why do the ChildX classes' parameterized Parent constructor calls never got executed? Without the ChildX classes the GrandChild class can not exist(?). Without the parameterized call the ChildX classes will not get created(?).</p>\n", "AcceptedAnswerId": "32016834", "Title": "Existence of intermediate class without executing the parameterized base class constructor", "CreationDate": "2015-08-14T18:24:03.840", "Id": "32016483", "CommentCount": "0", "LastEditDate": "2015-08-14T18:54:42.920", "PostTypeId": "1", "LastEditorUserId": "3880254", "LastActivityDate": "2015-08-14T18:54:42.920", "Score": "1", "OwnerUserId": "3880254", "Tags": "<c++><constructor><virtual-inheritance>", "AnswerCount": "1"}});