post_cb({"3077761": {"CommentCount": "6", "Body": "<p>Yes. Given:</p>\n<pre><code>std::vector&lt;int&gt; arr;\n</code></pre>\n<p>you can be sure that</p>\n<pre><code>&amp;arr[0]\n</code></pre>\n<p>will give you a pointer to a contiguous array of ints that can (for instance) be passed legacy APIs.</p>\n", "CreationDate": "2010-06-20T00:34:57.917", "ParentId": "3077748", "Id": "3077761", "LastActivityDate": "2010-06-20T00:34:57.917", "PostTypeId": "2", "Score": "5", "OwnerUserId": "18882"}, "3077767": {"CommentCount": "0", "Body": "<p>For all types except bool, the standard requires the elements are contiguous in memory:</p>\n<blockquote>\n<p id=\"so_3077748_3077767_0\">23.2.4/1 ... The elements of a vector are stored contiguously, meaning that if v is a vector where T is some type other than bool, then it obeys the identity &amp;v[n] == &amp;v[0] + n for all 0 &lt;= n &lt; v.size()</p>\n</blockquote>\n<p>Do keep in mind that <code>std::vector&lt;bool&gt;</code> has special requirements and is not the same as an array of bool.</p>\n", "CreationDate": "2010-06-20T00:35:52.877", "ParentId": "3077748", "Id": "3077767", "LastActivityDate": "2010-06-20T00:35:52.877", "PostTypeId": "2", "Score": "6", "OwnerUserId": "29809"}, "bq_ids": {"n4140": {"so_3077748_3077767_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 955}}, "n3337": {"so_3077748_3077767_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 943}}}, "3077749": {"CommentCount": "2", "Body": "<p>Yes. It does not, however, allocate on the stack.</p>\n", "CreationDate": "2010-06-20T00:30:50.517", "ParentId": "3077748", "Id": "3077749", "LastActivityDate": "2010-06-20T00:30:50.517", "PostTypeId": "2", "Score": "1", "OwnerUserId": "82320"}, "3077805": {"CreationDate": "2010-06-20T00:52:11.690", "Body": "<p>When you use the standard allocator, you can be sure that the allocated memory is continuous when using std::vector. In other words, foo[n+1] is the next element in the sequence after foo[n]. But std::vector is <em>not</em> an array, just like</p>\n<pre><code>int* blah = new int[100];\n</code></pre>\n<p>is not an array. But</p>\n<pre><code>int blah[100];\n</code></pre>\n<p>made on the stack is an array.\nPointers to allocated memory and arrays just happen to share semantics. They are not equal per the standard, so don't confuse the two.</p>\n", "PostTypeId": "2", "OwnerDisplayName": "Mads Elvheim", "ParentId": "3077748", "LastActivityDate": "2010-06-20T00:52:11.690", "Id": "3077805", "CommentCount": "2", "Score": "0"}, "3077804": {"CommentCount": "0", "Body": "<p>Yes, the vector use sequential memory for all the elements stored. That means random access is almost as fast as normal array's index. </p>\n<p>But vector allocate its memory in heap instead of stack. So it could be less less efficient in some cases.</p>\n", "CreationDate": "2010-06-20T00:51:58.387", "ParentId": "3077748", "Id": "3077804", "LastActivityDate": "2010-06-20T00:51:58.387", "PostTypeId": "2", "Score": "0", "OwnerUserId": "334999"}, "3077748": {"CreationDate": "2010-06-20T00:29:36.227", "ViewCount": "1080", "Id": "3077748", "AcceptedAnswerId": "3077767", "Score": "3", "Title": "is std::vector same as array[number]?", "LastEditorUserId": "-1", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_3077748_3077748_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/849168/are-stdvector-elements-guaranteed-to-be-contiguous\">Are std::vector elements guaranteed to be contiguous?</a> </br></p>\n</blockquote>\n<p>does std::vector always contain the data in sequential memory addresses as array[number]?</p>\n", "ClosedDate": "2010-06-23T00:49:54.027", "LastEditDate": "2017-05-23T12:28:18.240", "Tags": "<c++><stl><vector>", "LastActivityDate": "2010-06-20T00:52:11.690", "PostTypeId": "1", "AnswerCount": "5", "OwnerUserId": "371266"}});