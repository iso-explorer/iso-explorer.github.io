post_cb({"32856650": {"ParentId": "32856481", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>char</code> is a fundamental type. <code>wchar_t</code> evolved as first a library solution (in C), and then became a built in type <em>with an underlying type</em>, corresponding to the type that earlier was used to <code>typedef</code> it:</p>\n<b>C++11 $3.9.1/5</b>\n<blockquote>\n<p id=\"so_32856481_32856650_0\"><strong>\u201d</strong> Type <code>wchar_t</code> shall have the same\n  size, signedness, and alignment requirements (3.11) as one of the other integral types, called its <em>underlying\n  type</em>.</p>\n</blockquote>\n<p>This explains why you cannot change the signedness of <code>wchar_t</code>, but it does not explain why there is a <code>char</code> type with unspecified signedness.</p>\n<hr>\n<p>Also, the choice of signed <code>char</code> that most compilers default to, is impractical for several reasons. One reason is that the negative values are annoying and generally have to be cast to unsigned in order to compare them. Another reason is that the C character classification functions require non-negative values (except when being passed <code>EOF</code>). A third reason is that on old magnitude-and-sign or one's complement machines there's one unusable value.</p>\n<p>There may be some explanation of that in Stroustrup's \u201cThe design and evolution of C++\u201d, but I doubt it. </p>\n<p>It sounds like <em>frozen history</em>, something that at one point made some kind of sense, for the technology at the time.</p>\n</hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2015-09-30T02:54:04.707", "Id": "32856650", "Score": "3", "CreationDate": "2015-09-30T02:10:56.257", "LastActivityDate": "2015-09-30T02:54:04.707"}, "32856481": {"CommentCount": "7", "AcceptedAnswerId": "32856568", "PostTypeId": "1", "LastEditorUserId": "908939", "CreationDate": "2015-09-30T01:49:10.790", "LastActivityDate": "2015-09-30T02:54:04.707", "LastEditDate": "2015-09-30T01:52:38.340", "ViewCount": "660", "FavoriteCount": "1", "Title": "Why is char neither signed or unsigned, but wchar_t is?", "Id": "32856481", "Score": "6", "Body": "<p>The following C++ program compiles without errors:  </p>\n<pre><code>void f(char){}\nvoid f(signed char){}\nvoid f(unsigned char){}\nint main(){}  \n</code></pre>\n<p>The <code>wchar_t</code> version of the same program does not:  </p>\n<pre><code>void f(wchar_t){}\nvoid f(signed wchar_t){}\nvoid f(unsigned wchar_t){}\nint main(){}\n</code></pre>\n<p><strong>error: redefinition of \u2018void f(wchar_t)\u2019<br>\nvoid f(signed wchar_t){}</br></strong> </p>\n<p>It seems that <code>wchar_t</code> is <code>unsigned</code>.<br>\nWhy is there an inconsistency in overloading?  </br></p>\n", "Tags": "<c++><implicit-conversion><function-overloading><wchar-t>", "OwnerUserId": "908939", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_32856481_32856568_0": {"section_id": 7210, "quality": 1.0, "length": 14}, "so_32856481_32856568_4": {"section_id": 5438, "quality": 0.875, "length": 7}, "so_32856481_32856568_5": {"section_id": 7214, "quality": 0.8823529411764706, "length": 15}, "so_32856481_32856650_0": {"section_id": 7214, "quality": 0.8823529411764706, "length": 15}, "so_32856481_32856592_2": {"section_id": 7214, "quality": 0.9459459459459459, "length": 35}, "so_32856481_32856568_3": {"section_id": 5427, "quality": 1.0, "length": 8}, "so_32856481_32856592_0": {"section_id": 7210, "quality": 1.0, "length": 9}, "so_32856481_32856568_1": {"section_id": 5427, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_32856481_32856568_0": {"section_id": 6954, "quality": 0.7857142857142857, "length": 11}, "so_32856481_32856568_4": {"section_id": 5233, "quality": 0.875, "length": 7}, "so_32856481_32856568_5": {"section_id": 6958, "quality": 0.8823529411764706, "length": 15}, "so_32856481_32856650_0": {"section_id": 6958, "quality": 0.8823529411764706, "length": 15}, "so_32856481_32856592_2": {"section_id": 6958, "quality": 0.9459459459459459, "length": 35}, "so_32856481_32856568_3": {"section_id": 5222, "quality": 1.0, "length": 8}, "so_32856481_32856592_0": {"section_id": 6954, "quality": 1.0, "length": 9}, "so_32856481_32856568_1": {"section_id": 5222, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_32856481_32856568_4": {"section_id": 6865, "quality": 0.875, "length": 7}, "so_32856481_32856568_0": {"section_id": 8719, "quality": 1.0, "length": 14}, "so_32856481_32856568_5": {"section_id": 8723, "quality": 0.8823529411764706, "length": 15}, "so_32856481_32856568_3": {"section_id": 6855, "quality": 1.0, "length": 8}, "so_32856481_32856650_0": {"section_id": 8723, "quality": 0.8823529411764706, "length": 15}, "so_32856481_32856592_2": {"section_id": 8723, "quality": 0.9459459459459459, "length": 35}, "so_32856481_32856592_0": {"section_id": 8719, "quality": 1.0, "length": 9}, "so_32856481_32856568_1": {"section_id": 6855, "quality": 0.8, "length": 12}}}, "32856592": {"ParentId": "32856481", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>char</code> is a distinct type from both <code>signed char</code> and <code>unsigned char</code>. <code>wchar_t</code> is yet another distinct type (for type identity purposes), but which has exactly the same properties (size, signedness and alignment) as some other integral type.</p>\n<p>From ISO 14882:2003, 3.9.1:</p>\n<blockquote>\n<p id=\"so_32856481_32856592_0\">Plain <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> are three distinct types.</p>\n<p id=\"so_32856481_32856592_1\">(...)</p>\n<p id=\"so_32856481_32856592_2\">Type <code>wchar_t</code> is a distinct type whose values can represent distinct\n  codes for all members of the largest extended character set specified\n  among the supported locales (22.1.1). Type <code>wchar_t</code> shall have the same\n  size, signedness, and alignment requirements (3.9) as one of the other\n  integral types, called its underlying type.</p>\n</blockquote>\n<p>There is no such thing as <code>signed wchar_t</code> or <code>unsigned wchar_t</code>. It is not mentioned anywhere in the document.</p>\n", "OwnerUserId": "259543", "LastEditorUserId": "259543", "LastEditDate": "2015-09-30T02:14:26.633", "Id": "32856592", "Score": "3", "CreationDate": "2015-09-30T02:03:05.857", "LastActivityDate": "2015-09-30T02:14:26.633"}, "32856568": {"ParentId": "32856481", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The <code>char</code>s are all distinct types and can be overloaded</p>\n<p>[basic.fundamental] / 1</p>\n<blockquote>\n<p id=\"so_32856481_32856568_0\">[...] Plain <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> are three distinct types,\n  collectively called narrow character types. [...]</p>\n</blockquote>\n<p><code>wchar_t</code> is also a distinct type, but it cannot be qualified with <code>signed</code> or <code>unsigned</code>, which can only be used with the standard integer types.</p>\n<p>[dcl.type] / 2</p>\n<blockquote>\n<p id=\"so_32856481_32856568_1\">As a general rule, at most one <em>type-specifier</em> is allowed in\n  the complete <em>decl-specifier-seq</em> of a declaration or in a\n  <em>type-specifier-seq</em> or <em>trailing-type-specifier-seq</em>. The only exceptions\n  to this rule are the following:</p>\n<p id=\"so_32856481_32856568_2\">[...]</p>\n<p id=\"so_32856481_32856568_3\"><code>signed</code> or <code>unsigned</code> can be combined with <code>char</code>, <code>long</code>, <code>short</code>, or <code>int</code>.</p>\n</blockquote>\n<p>[dcl.type.simple] / 2</p>\n<blockquote>\n<p id=\"so_32856481_32856568_4\">[...] Table 9 summarizes the valid combinations of <em>simple-type-specifiers</em> and the types they specify.</p>\n</blockquote>\n<p><a href=\"https://i.stack.imgur.com/b1Joi.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/b1Joi.png\"/></a></p>\n<p>The signedness of <code>wchar_t</code> is implementation defined:</p>\n<p>[basic.fundamental] / 5</p>\n<blockquote>\n<p id=\"so_32856481_32856568_5\">[...] Type <code>wchar_t</code> shall have the same size, signedness, and alignment\n  requirements (3.11) as one of the other integral types, called its\n  underlying type.</p>\n</blockquote>\n", "OwnerUserId": "657267", "LastEditorUserId": "657267", "LastEditDate": "2015-09-30T02:20:53.113", "Id": "32856568", "Score": "8", "CreationDate": "2015-09-30T02:01:08.193", "LastActivityDate": "2015-09-30T02:20:53.113"}});