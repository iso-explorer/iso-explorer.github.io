post_cb({"bq_ids": {"n4140": {"so_28131172_28131248_0": {"length": 22, "quality": 1.0, "section_id": 391}}, "n3337": {"so_28131172_28131248_0": {"length": 22, "quality": 1.0, "section_id": 382}}, "n4659": {"so_28131172_28131248_0": {"length": 22, "quality": 1.0, "section_id": 408}}}, "28131317": {"Id": "28131317", "PostTypeId": "2", "Body": "<pre><code>void foo(C&amp;&amp;){}\nint main(){\n  C c;\n  foo(c.operator C&amp;&amp;());\n}\n</code></pre>\n<p>so, basically useless, but not completely.</p>\n", "LastActivityDate": "2015-01-24T23:09:17.047", "CommentCount": "0", "CreationDate": "2015-01-24T23:09:17.047", "ParentId": "28131172", "Score": "3", "OwnerUserId": "1774667"}, "28131248": {"Id": "28131248", "PostTypeId": "2", "Body": "<pre><code>struct C\n{\n    operator C()\n    {\n    }\n};\n</code></pre>\n<p>is also allowed and gives the same warning. It's referred to in \u00a712.3.2/1:</p>\n<blockquote>\n<p id=\"so_28131172_28131248_0\">A conversion function is never used to convert a (possibly\n  cv-qualified) object to the (possibly cv-qualified) same object type\n  (or a reference to it), to a (possibly cv-qualified) base class of\n  that type (or a reference to it), or to (possibly cv-qualified) void.</p>\n</blockquote>\n<p>In other words, it isn't forbidden, but it simply doesn't do anything. Yakk and Wintermute have already shown examples of member function call syntax, but <a href=\"http://en.cppreference.com/w/cpp/language/cast_operator#Explanation\">cppreference</a> shows an example of virtual dispatch as alluded to in footnote 116 (N3337, footnote 118 in N4140):</p>\n<pre><code>struct D;\nstruct B {\n    virtual operator D() = 0;\n};\nstruct D : B\n{\n    operator D() override { return D(); }\n};\n\nint main()\n{\n    D obj;\n    D obj2 = obj; // does not call D::operator D()\n    B&amp; br = obj;\n    D obj3 = br; // calls D::operator D() through virtual dispatch\n}\n</code></pre>\n", "LastEditorDisplayName": "user3920237", "OwnerDisplayName": "user3920237", "LastActivityDate": "2015-01-24T23:12:15.040", "Score": "12", "CreationDate": "2015-01-24T22:59:41.463", "ParentId": "28131172", "CommentCount": "5", "LastEditDate": "2015-01-24T23:12:15.040"}, "28131172": {"ViewCount": "274", "Body": "<p>I was surprised to see that the following compiles:</p>\n<pre><code>struct C {\n    operator C&amp;&amp;() {\n        std::cerr &lt;&lt; \"ref'd\\n\";\n        throw std::runtime_error(\"what is happening?\");\n    }\n};\n</code></pre>\n<p>A type with an operator for its own rvalue-reference conversion.  However, I can't get the operator called using what I thought may do it.  Passing a value to a function taking an rvalue reference fails, and calling <code>std::move</code> on an object doesn't trigger anything.</p>\n<p>Why is this code able to compile at all, and is there any way to actually get this function to run?</p>\n<p>clang gives <code>warning: conversion function converting 'C' to itself will never be used</code> with or without the reference on the type.</p>\n", "AcceptedAnswerId": "28131248", "Title": "Type having conversion to Type&& operator", "CreationDate": "2015-01-24T22:51:23.450", "Id": "28131172", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-01-25T22:27:03.233", "LastEditorUserId": "1013719", "LastActivityDate": "2015-01-25T22:27:03.233", "Score": "10", "OwnerUserId": "1013719", "Tags": "<c++><c++11>", "AnswerCount": "2"}});