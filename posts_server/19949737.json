post_cb({"19949872": {"ParentId": "19949737", "CommentCount": "18", "Body": "<p>There is no such requirement.</p>\n<p>The only relevant part of the language I can think of is that <em>every</em> object, whether complete or not, and whether most-derived or not, has an <em>identity</em>, which is given by the pair of its address and its type. Cf. C++11 1.8/6:</p>\n<blockquote>\n<p id=\"so_19949737_19949872_0\">Two objects that are not bit-fields may have the same address if one is a subobject\n  of the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, they shall have distinct addresses.</p>\n</blockquote>\n<p>So both the most-derived object and the base subobject of your example must have distinct identities.</p>\n<p>It would certainly make sense for a compiler to give both <code>Base</code> and <code>Derived</code> a size of <code>1</code>, but this is not mandatory. It would be acceptable if the <code>Base</code> had size 1729 and <code>Derived</code> had size 2875.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "19949872", "Score": "13", "CreationDate": "2013-11-13T09:21:05.777", "LastActivityDate": "2013-11-13T09:21:05.777"}, "bq_ids": {"n4140": {"so_19949737_19950151_0": {"section_id": 6077, "quality": 0.875, "length": 21}, "so_19949737_19949872_0": {"section_id": 5795, "quality": 1.0, "length": 25}, "so_19949737_19950151_2": {"section_id": 6077, "quality": 0.9583333333333334, "length": 23}, "so_19949737_19950151_1": {"section_id": 5794, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_19949737_19950151_0": {"section_id": 5845, "quality": 0.875, "length": 21}, "so_19949737_19950151_1": {"section_id": 5567, "quality": 0.9259259259259259, "length": 25}, "so_19949737_19949872_0": {"section_id": 5568, "quality": 1.0, "length": 25}, "so_19949737_19950151_2": {"section_id": 5845, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_19949737_19950151_1": {"section_id": 7253, "quality": 0.9259259259259259, "length": 25}, "so_19949737_19949872_0": {"section_id": 7254, "quality": 0.96, "length": 24}, "so_19949737_19950151_0": {"section_id": 7573, "quality": 0.875, "length": 21}, "so_19949737_19950151_2": {"section_id": 7573, "quality": 0.9583333333333334, "length": 23}}}, "19949737": {"CommentCount": "9", "ViewCount": "1968", "PostTypeId": "1", "LastEditorUserId": "2157640", "CreationDate": "2013-11-13T09:14:11.210", "LastActivityDate": "2014-07-03T10:03:07.240", "Title": "Is C++ allowed to increase the derived class size if there're no new member variables compared to the base class?", "FavoriteCount": "6", "LastEditDate": "2014-07-03T10:03:07.240", "Id": "19949737", "Score": "50", "Body": "<p>Suppose I have a base class with some member variables and no virtual functions:</p>\n<pre><code>class Base {\n   int member;\n};\n</code></pre>\n<p>and a derived class that derives in a non-virtual way from <code>Base</code> and has no new member variables an again no virtual functions:</p>\n<pre><code>class Derived : Base {\n};\n</code></pre>\n<p>Obviously <code>sizeof(Derived)</code> can't be smaller than <code>sizeof(Base)</code>.</p>\n<p>Is <code>sizeof(Derived)</code> required to be equal to <code>sizeof(Base)</code>?</p>\n", "Tags": "<c++><inheritance><sizeof><language-lawyer>", "OwnerUserId": "57428", "AnswerCount": "4"}, "19951957": {"ParentId": "19949737", "CommentCount": "0", "Body": "<pre><code>class Base {\n // int member;            I have just created an empty base class.\n};\n\nclass Derived : Base {\n};\n</code></pre>\n<p>Now gcc compiler would give \"size&gt;0\" for the both the objects created by Base and Derived classes. gcc compiler just provides the presence of address for the objects to the user.  </p>\n<pre><code>  Note:Derived class would contain base class members, so obviously we can think of \n  sizeof(derived class) greater then sizeof(base class). But this depends on the compiler \n  if it allocates some extra space while defining the derived class. \n</code></pre>\n<p>My present gcc compiler showed the sizeof objects of both Base and Derived to be same. </p>\n", "OwnerUserId": "2168706", "PostTypeId": "2", "Id": "19951957", "Score": "-1", "CreationDate": "2013-11-13T10:59:28.147", "LastActivityDate": "2013-11-13T10:59:28.147"}, "19950151": {"ParentId": "19949737", "CommentCount": "5", "Body": "<p>From 5.3.2 [expr.sizeof]</p>\n<blockquote>\n<p id=\"so_19949737_19950151_0\">When applied to a class, the result [of <code>sizeof</code>] is the number of bytes in an object of that class including any padding required for placing objects of that type in an array. The size of a most derived class shall be greater than zero (1.8).</p>\n</blockquote>\n<p>From 1.8 [intro.object]</p>\n<blockquote>\n<p id=\"so_19949737_19950151_1\">Unless it is a bit-field (9.6), a most derived object shall have a non-zero size and shall occupy one or more bytes of storage. Base class sub-objects may have zero size. An object of POD type (3.9) shall occupy contiguous bytes of storage.</p>\n</blockquote>\n<p>and a note:</p>\n<blockquote>\n<p id=\"so_19949737_19950151_2\">The actual size of a base class subobject may be less than the result of applying sizeof to the subobject, due to virtual base classes and less strict padding requirements on base class subobjects.</p>\n</blockquote>\n<p>Put these together and I think what it's telling you is that you have no guarantees whatsoever as to what <code>sizeof</code> might tell you, other than the result will be greater than zero. In fact, it doesn't even seem to guarantee that <code>sizeof(Derived) &gt;= sizeof(Base)</code>!</p>\n", "OwnerUserId": "2797826", "PostTypeId": "2", "Id": "19950151", "Score": "18", "CreationDate": "2013-11-13T09:34:31.867", "LastActivityDate": "2013-11-13T09:34:31.867"}, "19950401": {"ParentId": "19949737", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Interesting question.  I have an example where <strong>a derived class with an extra field is the <em>same size</em> as an <em>empty</em> base class.</strong>  (This should be a comment but is much too large; please accept one of the other answers, although upvotes are welcome if it's interesting.)</p>\n<p>Consider this trivial C++ program:</p>\n<pre><code>class A {};\n\nclass B : public A {\n    int m_iInteger;\n};\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    printf(\"A: %d\\r\\n\", sizeof(A));\n    printf(\"B: %d\\r\\n\", sizeof(B));\n    printf(\"int: %d\\r\\n\", sizeof(int));\n\n    return 0;\n}\n</code></pre>\n<p>What would you expect the output to be, if <code>sizeof(int)</code> is 4?  Perhaps something like:</p>\n<pre><code>A: 0\nB: 4\nint: 4\n</code></pre>\n<p>?</p>\n<p>My compiler - <a href=\"http://www.embarcadero.com/products/cbuilder\">Embarcadero C++ Builder</a> 2010 - gives the output:</p>\n<pre><code>A: 8\nB: 8\nint: 4\n</code></pre>\n<p>In other words, <strong>adding an extra field in the derived class does not make the derived class bigger.</strong></p>\n<p>There is some insight into why with the help file topic on the <a href=\"http://docwiki.embarcadero.com/RADStudio/XE5/en/C++_Compiler_Compatibility\">compatibility option Zero-length empty base class</a>.</p>\n<blockquote>\n<p id=\"so_19949737_19950401_0\">Usually the size of a class is at least one byte, even if the class\n  does not define any data members. When you set this option, the\n  compiler ignores this unused byte for the memory layout and the total\n  size of any derived classes; empty base classes do not consume space\n  in derived classes. Default = False</p>\n</blockquote>\n<p>It appears that the size of a class with default compiler settings for this compiler is 8 bytes, not one, and in fact changing this setting <em>for this code example</em> has no effect.</p>\n<p>You may also find <a href=\"http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=319\">this article on base class sizes and the above optimization</a> interesting.  It discusses why classes must have a size of at least one byte, what the optimization does, and delves into representation of member functions etc too:</p>\n<blockquote>\n<p id=\"so_19949737_19950401_1\">Indeed, the standard requires that the size of an object shall never\n  be zero; it also requires that in a derived object data members of the\n  base class(es) shall appear before user-declared data members of the\n  derived class. However, <strong>a base class subobject isn\u2019t considered a\n  complete object.</strong> Therefore, it\u2019s possible to remove the base class\n  subobject from the derived object without violating the rules. In\n  other words, in the object t, the offset of S and x may overlap...</p>\n</blockquote>\n<p>Please read the article for the full context of that quote.</p>\n", "OwnerUserId": "121689", "LastEditorUserId": "121689", "LastEditDate": "2013-11-13T10:21:40.520", "Id": "19950401", "Score": "9", "CreationDate": "2013-11-13T09:45:59.930", "LastActivityDate": "2013-11-13T10:21:40.520"}});