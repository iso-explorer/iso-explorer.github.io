post_cb({"22147925": {"CommentCount": "10", "AcceptedAnswerId": "22148550", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-03-03T13:21:23.057", "LastActivityDate": "2014-03-03T18:50:01.623", "LastEditDate": "2017-05-23T12:16:02.923", "ViewCount": "1846", "FavoriteCount": "4", "Title": "Possibility of COW std::string implementation in C++11", "Id": "22147925", "Score": "18", "Body": "<p>Today I passed by this SO question: <a href=\"https://stackoverflow.com/questions/12199710/legality-of-cow-stdstring-implementation-in-c11\">Legality of COW std::string implementation in C++11</a></p>\n<p>The most voted answer (35 upvotes) for that question says:</p>\n<blockquote>\n<p id=\"so_22147925_22147925_0\">It's not allowed, because as per the standard 21.4.1 p6, invalidation\n  of iterators/references is only allowed for</p>\n<p id=\"so_22147925_22147925_1\">\u2014 as an argument to any standard library function taking a reference\n  to non-const basic_string as an argument.</p>\n<p id=\"so_22147925_22147925_2\">\u2014 Calling non-const member functions, except operator[], at, front,\n  back, begin, rbegin, end, and rend.</p>\n<p id=\"so_22147925_22147925_3\">For a COW string, calling non-const operator[] would require making a\n  copy (and invalidating references), which is disallowed by the\n  paragraph above. Hence, it's no longer legal to have a COW string in\n  C++11.</p>\n</blockquote>\n<p>I wonder whether that justification is valid or not because it seems C++03 has similar requirements for string iterator invalidation:</p>\n<blockquote>\n<p id=\"so_22147925_22147925_4\">References, pointers, and iterators referring to the elements of a\n  basic_string sequence may be invalidated by the following uses of that\n  basic_string object:  </p>\n<ul>\n<li>As an argument to non-member functions swap() (21.3.7.8), operator&gt;&gt;() (21.3.7.9), and getline() (21.3.7.9).  </li>\n<li>As an argument to basic_string::swap().  </li>\n<li>Calling data() and c_str() member functions.  </li>\n<li>Calling non-const member functions, except operator[](), at(), begin(), rbegin(), end(), and rend().  </li>\n<li>Subsequent to any of the above uses except the forms of insert() and erase() which return iterators, the first call to non-const member\n  functions operator[](), at(), begin(), rbegin(), end(), or rend().</li>\n</ul>\n</blockquote>\n<p>These are not exactly the same as those of C++11's, but at least the same for the part of <code>operator[]()</code>, which the original answer took as the major justification.  So I guess, in order to justify the illegality of COW std::string implementation in C++11, some other standard requirements need to be cited.  Help needed here.</p>\n<hr>\n<p>That SO question has been inactive for over a year, so I've decided to raise this as a separate question.  Please let me know if this is inappropriate and I will find some other way to clear my doubt.</p>\n</hr>", "Tags": "<c++><string><c++11><language-lawyer><standard-library>", "OwnerUserId": "3237645", "AnswerCount": "1"}, "22148550": {"ParentId": "22147925", "PostTypeId": "2", "CommentCount": "19", "Body": "<p>The key point is the last point in the C++03 standard.  The\nwording could be a lot clearer, but the intent is that the first\ncall to <code>[]</code>, <code>at</code>, etc. (but only the first call) after\nsomething which established new iterators (and thus invalidated\nold ones) could invalidate iterators, but only the first.  The\nwording in C++03 was, in fact, a quick hack, inserted in\nresponse to comments by the French national body on the CD2 of\nC++98.  The original problem is simple: consider: </p>\n<pre><code>std::string a( \"some text\" );\nstd::string b( a );\nchar&amp; rc = a[2];\n</code></pre>\n<p>At this point, modifications through <code>rc</code> must affect <code>a</code>, but\nnot <code>b</code>.  If COW is being used, however, when <code>a[2]</code> is called,\n<code>a</code> and <code>b</code> share a representation; in order for writes through\nthe returned reference not to affect <code>b</code>, <code>a[2]</code> must be\nconsidered a \"write\", and be allowed to invalidate the\nreference.  Which is what CD2 said: any call to a non-const\n<code>[]</code>, <code>at</code>, or one of the <code>begin</code> or <code>end</code> functions could\ninvalidate iterators and references.  The French national body\ncomments pointed out that this rendered <code>a[i] == a[j]</code> invalid,\nsince the reference returned by one of the <code>[]</code> would be\ninvalidated by the other.  The last point you cite of C++03 was\nadded to circumvent this\u2014only the first call to <code>[]</code> et\nal. could invalidate the iterators. </p>\n<p>I don't think anyone was totally happy with the results.  The\nwording was done quickly, and while the intent was clear to\nthose who were aware of the history, and the original problem,\nI don't think it was fully clear from standard.  In addition,\nsome experts began to question the value of COW to begin with,\ngiven the relative impossibility of the string class itself to\nreliably detect all writes.  (If <code>a[i] == a[j]</code> is the complete\nexpression, there is no write.  But the string class itself must\nassume that the return value of <code>a[i]</code> may result in a write.)\nAnd in a multi-threaded environment, the cost of managing the\nreference count needed for copy on write was deemed a relatively\nhigh cost for something you usually don't need.  The result is\nthat most implementations (which supported threading long before\nC++11) have been moving away from COW anyway; as far as I know,\nthe only major implementation still using COW was g++ (but there\nwas a known bug in their multithreaded implementation) and\n(maybe) Sun CC (which the last time I looked at it, was\ninordinately slow, because of the cost of managing the counter).\nI think the committee simply took what seemed to them the\nsimplest way of cleaning things up, by forbidding COW.</p>\n<h2>EDIT:</h2>\n<p>Some more clarification with regards to why a COW implementation\nhas to invalidate iterators on the first call to <code>[]</code>.  Consider\na na\u00efve implementation of COW.  (I will just call it String, and\nignore all of the issues involving traits and allocators, which\naren't really relevant here.  I'll also ignore exception and\nthread safety, just to make things as simple as possible.)</p>\n<pre><code>class String\n{\n    struct StringRep\n    {\n        int useCount;\n        size_t size;\n        char* data;\n        StringRep( char const* text, size_t size )\n            : useCount( 1 )\n            , size( size )\n            , data( ::operator new( size + 1 ) )\n        {\n            std::memcpy( data, text, size ):\n            data[size] = '\\0';\n        }\n        ~StringRep()\n        {\n            ::operator delete( data );\n        }\n    };\n\n    StringRep* myRep;\npublic:\n    String( char const* initial_text )\n        : myRep( new StringRep( initial_text, strlen( initial_text ) ) )\n    {\n    }\n    String( String const&amp; other )\n        : myRep( other.myRep )\n    {\n        ++ myRep-&gt;useCount;\n    }\n    ~String()\n    {\n        -- myRep-&gt;useCount;\n        if ( myRep-&gt;useCount == 0 ) {\n            delete myRep;\n        }\n    }\n    char&amp; operator[]( size_t index )\n    {\n        return myRep-&gt;data[index];\n    }\n};\n</code></pre>\n<p>Now imagine what happens if I write:</p>\n<pre><code>String a( \"some text\" );\nString b( a );\na[4] = '-';\n</code></pre>\n<p>What is the value of <code>b</code> after this?  (Run through the code by\nhand, if you're not sure.)</p>\n<p>Obviously, this doesn't work.  The solution is to add a flag,\n<code>bool uncopyable;</code> to <code>StringRep</code>, which is initialized to\n<code>false</code>, and to modify the following functions:</p>\n<pre><code>String::String( String const&amp; other )\n{\n    if ( other.myRep-&gt;uncopyable ) {\n        myRep = new StringRep( other.myRep-&gt;data, other.myRep-&gt;size );\n    } else {\n        myRep = other.myRep;\n        ++ myRep-&gt;useCount;\n    }\n}\n\nchar&amp; String::operator[]( size_t index )\n{\n    if ( myRep-&gt;useCount &gt; 1 ) {\n        -- myRep-&gt;useCount;\n        myRep = new StringRep( myRep-&gt;data, myRep-&gt;size );\n    }\n    myRep-&gt;uncopyable = true;\n    return myRep-&gt;data[index];\n}\n</code></pre>\n<p>This means, of course, that <code>[]</code> will invalidate iterators and\nreferences, <em>but</em> only the first time it is called on an object.\nThe next time, the <code>useCount</code> will be one (and the image will be\nuncopyable).  So <code>a[i] == a[j]</code> works; regardless of which the\ncompiler actually evaluates first (<code>a[i]</code> or <code>a[j]</code>), the second\none will find a <code>useCount</code> of 1, and will not have to duplicate.\nAnd because of the <code>uncopyable</code> flag,</p>\n<pre><code>String a( \"some text\" );\nchar&amp; c = a[4];\nString b( a );\nc = '-';\n</code></pre>\n<p>will also work, and not modify <code>b</code>.</p>\n<p>Of course, the above is enormously simplified.  Getting it to\nwork in a multithreaded environment is extremely difficult,\nunless you simply grab a mutex for the entire function for any\nfunction which might modify anything (in which case, the\nresulting class is extremely slow).  G++ tried, and\nfailed\u2014there is on particular use case where it breaks.\n(Getting it to handle the other issues I've ignored is not\nparticularly difficult, but does represent a lot of lines of\ncode.)</p>\n", "OwnerUserId": "649665", "LastEditorUserId": "649665", "LastEditDate": "2014-03-03T18:50:01.623", "Id": "22148550", "Score": "27", "CreationDate": "2014-03-03T13:52:15.900", "LastActivityDate": "2014-03-03T18:50:01.623"}, "bq_ids": {"n4140": {"so_22147925_22147925_2": {"section_id": 1567, "quality": 1.0, "length": 12}, "so_22147925_22147925_1": {"section_id": 1567, "quality": 1.0, "length": 8}, "so_22147925_22147925_4": {"section_id": 1567, "quality": 1.0, "length": 13}}, "n3337": {"so_22147925_22147925_2": {"section_id": 1562, "quality": 1.0, "length": 12}, "so_22147925_22147925_1": {"section_id": 1562, "quality": 1.0, "length": 8}, "so_22147925_22147925_4": {"section_id": 1562, "quality": 1.0, "length": 13}}, "n4659": {"so_22147925_22147925_2": {"section_id": 1716, "quality": 1.0, "length": 12}, "so_22147925_22147925_1": {"section_id": 1716, "quality": 1.0, "length": 8}, "so_22147925_22147925_4": {"section_id": 1716, "quality": 1.0, "length": 13}}}});