post_cb({"bq_ids": {"n4140": {"so_29762813_29762987_0": {"length": 8, "quality": 0.8, "section_id": 336}}, "n3337": {"so_29762813_29762987_0": {"length": 8, "quality": 0.8, "section_id": 326}}, "n4659": {"so_29762813_29762987_0": {"length": 8, "quality": 0.8, "section_id": 345}}}, "29762987": {"Id": "29762987", "PostTypeId": "2", "Body": "<p>You're using the template argument <code>T</code> in a non-deduced context. </p>\n<p>From <em>\u00a714.8.2.5/5 <strong>[temp.deduct.type]</strong></em></p>\n<blockquote>\n<p id=\"so_29762813_29762987_0\">The non-deduced contexts are:<br/>\n  \u2014 The <em>nested-name-specifier</em> of a type that was specified using a <em>qualified-id</em>.<br/>\n  \u2014 ...</p>\n</blockquote>\n<p>To fix the problem move the <code>enable_if</code> to a dummy template parameter</p>\n<pre><code>template&lt;typename T,\n         typename = typename std::enable_if&lt; std::is_enum&lt;T&gt;::value, T &gt;::type&gt;\nbool func( T &amp;t, int x )\n{\n  // ...\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/7f099ec1a4a208d3\" rel=\"nofollow\">Live demo</a></p>\n<hr>\n<p>Looking at the question you linked to, you're trying to switch between two definitions of <code>func</code> based on whether the first argument is an <code>enum</code>. In that case the above solution will not work because a default template argument is not part of the function template's signature, and you'll end up with multiple definition errors.</p>\n<p>There are two different ways to fix that, use a dummy template parameter</p>\n<pre><code>template&lt;typename T,\n         typename std::enable_if&lt; std::is_enum&lt;T&gt;::value, int &gt;::type* = nullptr&gt;\nbool func( T &amp;t, int x )\n{\n  // ...\n}\n</code></pre>\n<p>or use the <code>enable_if</code> expression in the return type</p>\n<pre><code>template&lt;typename T&gt;\ntypename std::enable_if&lt; std::is_enum&lt;T&gt;::value, bool &gt;::type \n    func( T &amp;t, int x )\n{\n    // ...\n}\n</code></pre>\n</hr>", "LastEditorUserId": "241631", "LastActivityDate": "2015-04-21T04:49:17.647", "Score": "2", "CreationDate": "2015-04-21T04:34:40.123", "ParentId": "29762813", "CommentCount": "1", "OwnerUserId": "241631", "LastEditDate": "2015-04-21T04:49:17.647"}, "29762958": {"Id": "29762958", "PostTypeId": "2", "Body": "<pre><code>template&lt;typename T&gt;\nbool func( typename std::enable_if&lt; std::is_enum&lt;T&gt;::value, T &gt;::type &amp;t, int x )\n</code></pre>\n<p><code>T</code> is used above in a non-deduced context.  This means it won't deduct the <code>T</code>, as it (in the general case) requires reversing an arbitrary turing-complete transformation, which is impossible.</p>\n<p>What <code>func</code> has is that the first argument is a <code>enum class Bar</code>, and the second is an <code>int</code>.  From this you expect it to deduce <code>T</code>.</p>\n<p>While setting <code>T</code> to <code>enum class Bar</code> does solve the problem, C++ doesn't guess.  It pattern matches.</p>\n<p>Suppose we had:</p>\n<pre><code>template&lt;class T&gt;\nstruct blah { using type=int; };\ntemplate&lt;&gt;\nstruct blah&lt;int&gt; { using type=double; };\n</code></pre>\n<p>then</p>\n<pre><code>template&lt;class T&gt;\nbool func( typename blah&lt;T&gt;::type );\n</code></pre>\n<p>If someone passes a <code>int</code> to <code>func</code>, what type should be deduced for <code>T</code>?  This is a toy example: <code>foo&lt;T&gt;::type</code> can execute a Turing-complete algorithm to map <code>T</code> to the type in question.  Inverting that or even determining if the inverse is ambiguous, is not possible in the general case.  So C++ doesn't even try, even in the simple cases, as the edge between simple and complex gets fuzzy quickly.</p>\n<p>To fix your problem:</p>\n<pre><code>template&lt;class T,class=typename std::enable_if&lt; std::is_enum&lt;T&gt;::value &gt;::type&gt;\nbool func( T &amp;t, int x ) {\n}\n</code></pre>\n<p>now <code>T</code> is used in a deduced context.  The SFINAE still occurs, but doesn't block template type deduction.</p>\n<p>Or you can wait for C++1z concepts, which automate the above construct (basically).</p>\n<hr>\n<p>Looking at the linked question, the easy way to solve your problem is with tag dispatching.</p>\n<pre><code>template&lt;typename T&gt; \nbool func(T &amp;t, int x)\n{\n    // do stuff...\n}\n</code></pre>\n<p>However I would like to have three different function bodies:</p>\n<p>We have 3 cases:</p>\n<ul>\n<li><p>T being an enum</p></li>\n<li><p>T being unsigned char</p></li>\n<li><p>Everything else</p></li>\n</ul>\n<p>so, dispatch:</p>\n<pre><code>namespace details {\n  template&lt;class T&gt;\n  bool func( T&amp; t, int x, std::true_type /* is_enum */, std::false_type ) {\n  }\n  template&lt;class T&gt;\n  bool func( T&amp; t, int x, std::false_type, std::true_type /* unsigned char */ ) {\n  }\n  template&lt;class T&gt;\n  bool func( T&amp; t, int x, std::false_type, std::false_type ) {\n    // neither\n  }\n}\ntemplate&lt;class T&gt;\nbool func( T&amp; t, int x ) {\n  return details::func( t, x, std::is_enum&lt;T&gt;{}, std::is_same&lt;unsigned char, T&gt;{} );\n}\n</code></pre>\n<p>now normal overload rules are used to pick between the 3 functions.  If you somehow have a type that is both <code>enum</code> and <code>unsigned char</code> (impossible), you get a compile-time error.</p>\n</hr>", "LastEditorUserId": "1774667", "LastActivityDate": "2016-12-03T15:36:28.023", "Score": "7", "CreationDate": "2015-04-21T04:32:18.940", "ParentId": "29762813", "CommentCount": "0", "OwnerUserId": "1774667", "LastEditDate": "2016-12-03T15:36:28.023"}, "29762813": {"ViewCount": "1698", "Body": "<p>MCVE:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;typename T&gt;\nbool func( typename std::enable_if&lt; std::is_enum&lt;T&gt;::value, T &gt;::type &amp;t, int x )\n{\n}\n\nenum class Bar { a,b,c };\n\nint main()\n{\n    Bar bar{Bar::a};\n    func(bar, 1);\n}\n</code></pre>\n<p>I expect <code>func(bar, 1);</code> to match my definition of <code>func</code> however g++ reports:</p>\n<pre><code>sfi.cc: In function 'int main()':\nsfi.cc:13:17: error: no matching function for call to 'func(Bar&amp;, int)'\n      func(bar, 1);\n                 ^\nsfi.cc:13:17: note: candidate is:\nsfi.cc:4:10: note: template&lt;class T&gt; bool func(typename std::enable_if&lt;std::is_e\nnum&lt;_Tp&gt;::value, T&gt;::type&amp;, int)\n     bool func( typename std::enable_if&lt; std::is_enum&lt;T&gt;::value, T &gt;::type &amp;t, int x )\n          ^\nsfi.cc:4:10: note:   template argument deduction/substitution failed:\nsfi.cc:13:17: note:   couldn't deduce template parameter 'T'\n      func(bar, 1);\n                 ^\n</code></pre>\n<p>Why isn't this working and how do I fix it?</p>\n<p><em>Background:</em> This was an attempted solution to <a href=\"https://stackoverflow.com/questions/29762892/how-to-specialize-a-template-function-for-enum-and-specific-type\">this problem</a></p>\n", "Title": "enable_if with is_enum does not work", "CreationDate": "2015-04-21T04:17:21.900", "LastActivityDate": "2016-12-03T15:36:28.023", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:02:39.190", "LastEditorUserId": "-1", "Id": "29762813", "Score": "3", "OwnerUserId": "1505939", "Tags": "<c++><c++11><sfinae>", "AnswerCount": "3"}, "29762924": {"Id": "29762924", "PostTypeId": "2", "Body": "<p>The errors you are seeing have to do with automatic type deduction than <code>enable_if</code> and <code>is_enum</code>.</p>\n<p>The following works.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\ntemplate&lt;typename T&gt;\nbool func( typename std::enable_if&lt; std::is_enum&lt;T&gt;::value, T &gt;::type &amp;t, int x )\n{\n   return true;\n}\n\nenum class Bar { a,b,c };\n\nint main()\n{\n    Bar bar{Bar::a};\n    std::cout &lt;&lt; func&lt;decltype(bar)&gt;(bar, 1) &lt;&lt; std::endl;\n}\n</code></pre>\n<p><strong>Update</strong></p>\n<p>As already discovered by the OP, use of <code>decltype</code> can be avoided by using a wrapper function.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\ntemplate &lt;typename T&gt;\nbool func( typename std::enable_if&lt; std::is_enum&lt;T&gt;::value, T &gt;::type &amp;t, int x )\n{\n   return true;\n}\n\ntemplate &lt;typename T&gt;\nbool func2( T &amp;t, int x )\n{\n   return func&lt;T&gt;(t,x);\n}\n\nenum class Bar { a,b,c };\n\nint main()\n{\n    Bar bar{Bar::a};\n    std::cout &lt;&lt; func2(bar, 1) &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastEditorUserId": "434551", "LastActivityDate": "2015-04-21T04:37:11.310", "Score": "1", "CreationDate": "2015-04-21T04:29:00.950", "ParentId": "29762813", "CommentCount": "1", "OwnerUserId": "434551", "LastEditDate": "2015-04-21T04:37:11.310"}});