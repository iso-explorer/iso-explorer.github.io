post_cb({"14186518": {"Id": "14186518", "PostTypeId": "2", "Body": "<p>Typically, one only tests the public interface as discussed in the question's comments.  </p>\n<p>There are times however when it is helpful to test private or protected methods.  For example, the implementation may have some non-trivial complexities that are hidden from users and that can be tested more precisely with access to non-public members.  Often it's better to figure out a way to remove that complexity or figure out how to expose the relevant portions publicly, but not always.</p>\n<p>One way to allow unit tests access to non-public members is via the <a href=\"http://www.cplusplus.com/doc/tutorial/inheritance/\" rel=\"noreferrer\">friend</a> construct.</p>\n", "LastEditorUserId": "25050", "LastActivityDate": "2013-01-06T21:10:08.550", "Score": "34", "CreationDate": "2013-01-06T20:40:53.960", "ParentId": "14186245", "CommentCount": "3", "OwnerUserId": "25050", "LastEditDate": "2013-01-06T21:10:08.550"}, "21167147": {"Id": "21167147", "PostTypeId": "2", "Body": "<p>Notwithstanding the comments regarding the appropriateness of testing private methods, suppose you really need to... this is often the case for example when working with legacy code prior to refactoring it into something more appropriate. Here is the pattern i've used:</p>\n<pre><code>// In testable.hpp:\n#if defined UNIT_TESTING\n#   define ACCESSIBLE_FROM_TESTS : public\n#   define CONCRETE virtual\n#else\n#   define ACCESSIBLE_FROM_TESTS\n#   define CONCRETE\n#endif\n</code></pre>\n<p>Then, within the code:</p>\n<pre><code>#include \"testable.hpp\"\n\nclass MyClass {\n...\nprivate ACCESSIBLE_FROM_TESTS:\n    int someTestablePrivateMethod(int param);\n\nprivate:\n    // Stuff we don't want the unit tests to see...\n    int someNonTestablePrivateMethod();\n\n    class Impl;\n    boost::scoped_ptr&lt;Impl&gt; _impl;\n}\n</code></pre>\n<p>Is it better than defining test friends? It seems less verbose than the alternative, and is clear within the header what is happening. Both solutions have nothing to do with security: if you are really concerned about the methods or members, then these need to be hidden inside an opaque implementation possibly with other protections.</p>\n", "LastActivityDate": "2014-01-16T16:18:47.830", "CommentCount": "0", "CreationDate": "2014-01-16T16:18:47.830", "ParentId": "14186245", "Score": "3", "OwnerUserId": "736981"}, "14263326": {"Id": "14263326", "PostTypeId": "2", "Body": "<p>The desire to test private members is a design smell, generally indicating that there is a class trapped inside your class struggling to get out.  All of the functionality of a class should be exercisable through its public methods; functionality that can't be accessed publicly doesn't actually exist.</p>\n<p>There are a couple of approaches to realizing that you need to test that your private methods do what they say on the tin.  Friend classes are the worst of these; they tie the test to the implementation of the class under test in a way that is prima facie fragile.  Somewhat better is dependency injection:  Making the private methods' dependencies class attributes that the test can supply mocked-up versions of so as to allow the testing of private methods through the public interface.  Best is to extract a class that encapsulates the behavior your private methods have as its public interface, and then test the new class as you normally would.</p>\n<p>For more details, consult <a href=\"http://books.google.com.br/books/about/Clean_Code.html?id=_i6bDeoCQzsC\" rel=\"nofollow\">Clean Code</a>.</p>\n", "LastActivityDate": "2013-01-10T17:06:33.743", "CommentCount": "2", "CreationDate": "2013-01-10T17:06:33.743", "ParentId": "14186245", "Score": "4", "OwnerUserId": "9719"}, "34318721": {"Id": "34318721", "PostTypeId": "2", "Body": "<p>There's a simple solution in C++ using #define. Just wrap the include of your \"ClassUnderTest\" like this: </p>\n<pre><code>#define protected public\n #define private   public\n    #include &lt;ClassUnderTest.hpp&gt;\n #undef protected\n#undef private\n</code></pre>\n<p>[Credit goes to this article and RonFox][1]</p>\n", "LastActivityDate": "2015-12-16T17:45:35.110", "CommentCount": "0", "CreationDate": "2015-12-16T17:45:35.110", "ParentId": "14186245", "Score": "0", "OwnerUserId": "180742"}, "24445370": {"Id": "24445370", "PostTypeId": "2", "Body": "<p>Answering this question touches many other topics. Beside any religiosity in CleanCode, TDD and others:</p>\n<p>There are several ways to access private members. In any case you have to overrule the tested code! This is possible on both levels of parsing C++ (preprocessor and language itself):</p>\n<p><strong>Define all to public</strong></p>\n<p>By using the preprocessor you are able to break encapsulation.</p>\n<pre><code>#define private public\n#define protected public\n#define class struct\n</code></pre>\n<p>The disadvantage is, that <strong>the class of the delivered code is not the same as in the test</strong>!\nThe C++ Standard in chapter 9.2.13 says:</p>\n<blockquote>\n<p id=\"so_14186245_24445370_0\">The order of allocation of non-static data members with different\n  access control is unspecified.</p>\n</blockquote>\n<p>This means, that the compiler has the right to reorder the member variables and virtual functions for the test. You may struggle, that this won't harm your classes if no buffer overflow happens, but it means, that you won't test the same code as you deliver. It means, that if you access members of an object, that was initialized by code, compiled with <code>private</code> not defined to <code>public</code>, the offset of your member may differ!</p>\n<p><strong>Friends</strong></p>\n<p>This method needs to change the tested class for befriending it with the test class or the test function. Some testing frameworks like gtest (<code>FRIEND_TEST(..);</code>) have special functionality to support this way of accessing private things.</p>\n<pre><code>class X\n{\nprivate:\n    friend class Test_X;\n};\n</code></pre>\n<p>It opens the class only for the test and does not open up the world, but you have to modify the code that gets delivered. In my opinion this is a bad thing, because a test should never change the tested code. As a further disadvantage it gives other classes of the delivered code the possibility to intrude your class by naming themselves like a test class (this would also harm the ODR rule of the C++ Standard).</p>\n<p><strong>Declaring the private things protected and derive from the class for tests</strong></p>\n<p>Not a very elegant way, very intrusive, but works also:</p>\n<pre><code>class X\n{\nprotected:\n    int myPrivate;\n};\n\nclass Test_X: public X\n{\n    // Now you can access the myPrivate member.\n};\n</code></pre>\n<p><strong>Any other way with macros</strong></p>\n<p>Works, but has the same disadvantages on standard conformity like the first way. e.g.:</p>\n<pre><code>class X\n{\n#ifndef UNITTEST\nprivate:\n#endif\n};\n</code></pre>\n<p>I think that the last both ways are no alternatives to the first two ways, because they have no advantages over the first ones, but are more intrusive on the tested code. The first way is very risky, so you may use the befriending approach.</p>\n<hr>\n<p>Some words on the never-test-private-things-discussion. One of the upsides of unit testing at all is, that you will reach very early the point, where you have to improve the design of your code. This is also sometimes one of the downsides of unit testing. It makes object orientation sometimes more complicated, than it has to be. Especially if you follow the rule to design classes in the same way the real world objects are.</p>\n<p>Then you have to change the code sometimes into something ugly, because the unit testing approach forces you to do so. Working on complex frameworks, that are used to control physical processes, is one example. There you want to map the code on the physical process, because often parts of the process are already very complex. The dependency list on that processes gets sometimes very long. This is one possible moment, where testing private members is getting nice. You have to trade-off with the advantages and disadvantages of each approach.</p>\n<p>Classes are getting sometimes complex! Then you have to decide to split them or to take them as they are. Sometimes the second decision makes more sense. In the end it is always a question of which goals you want to achieve (e.g. perfect design, quick incorporation times, low development costs...).</p>\n<hr>\n<p><strong>My Opinion</strong></p>\n<p>My decision process for accessing private members looks like this:</p>\n<ol>\n<li>Do you need to test private members themselves? (Often this reduces the total number of tests needed)</li>\n<li>If yes, do you see any design advantage to refactor the class?</li>\n<li>If no, befriend the test in your class (use this because of the missing alternatives).</li>\n</ol>\n<p>I don't like the befriending approach, because it changes the tested code, but the risk to test something, that may not be the same as delivered (as possible with the first approach), will not justify the cleaner code.</p>\n<p>BTW: Testing only the public interface is also a fluent matter, because in my experience it changes as often as the private implementation does. So you have no advantage to reduce the test on public members.</p>\n</hr></hr>", "LastEditorUserId": "3781684", "LastActivityDate": "2015-12-16T06:31:07.857", "Score": "20", "CreationDate": "2014-06-27T06:32:52.743", "ParentId": "14186245", "CommentCount": "4", "OwnerUserId": "3781684", "LastEditDate": "2015-12-16T06:31:07.857"}, "bq_ids": {"n4140": {"so_14186245_24445370_0": {"length": 9, "quality": 0.9, "section_id": 5873}}, "n3337": {"so_14186245_24445370_0": {"length": 9, "quality": 0.9, "section_id": 5644}}, "n4659": {"so_14186245_24445370_0": {"length": 9, "quality": 0.9, "section_id": 7356}}}, "36928995": {"Id": "36928995", "PostTypeId": "2", "Body": "<p>I would prefer adding -Dprivate=public option in Makefile of unit-test, avoiding to modify anything in my original projects</p>\n", "LastActivityDate": "2016-04-29T03:21:41.940", "CommentCount": "1", "CreationDate": "2016-04-29T03:21:41.940", "ParentId": "14186245", "Score": "-1", "OwnerUserId": "3395301"}, "14186634": {"Id": "14186634", "PostTypeId": "2", "Body": "<p>I haven't found a golden solution myself, but you can use <code>friend</code> to test private members, if you know how the testing framework names it's methods. I use the following to test private members with Google test. While this works quite well, note that it's a hack, and I don't use it in production code.</p>\n<p>In the header of the code I want to test (stylesheet.h), I have:</p>\n<pre><code>#ifndef TEST_FRIENDS\n#define TEST_FRIENDS\n#endif\n\nclass Stylesheet {\nTEST_FRIENDS;\npublic:\n    // ...\nprivate:\n    // ...\n};\n</code></pre>\n<p>and in the test I have:</p>\n<pre><code>#include &lt;gtest/gtest.h&gt;\n\n#define TEST_FRIENDS \\\n    friend class StylesheetTest_ParseSingleClause_Test; \\\n    friend class StylesheetTest_ParseMultipleClauses_Test;\n\n#include \"stylesheet.h\"\n\nTEST(StylesheetTest, ParseSingleClause) {\n    // can use private members of class Stylesheet here.\n}\n</code></pre>\n<p>You always add a new line to TEST_FRIENDS if you add a new test that accesses private members. The benefits of this technique are that it is fairly unobstrusive in the tested code, as you only add a few #defines, which have no effect when not testing. The downside is that it is a bit verbose in the tests.</p>\n<p>Now one word as to why you would want to do this. Ideally of course, you have small classes with well-defined responsibilities, and the classes have easily testable interfaces. However, in practice that's not always easy. If you are writing a library, what is <code>private</code> and <code>public</code> is dictated by what you want the consumer of the library to be able to use (your public API), and not by what's in need of testing or not. You can have invariants that are very unlikely to change, and need to be tested, but are of no interest to the consumer of your API. Then, black-box-testing of the API is not enough. Also if you encounter bugs and write additional tests to prevent regressions, it can be neccessary to test <code>private</code> stuff.</p>\n", "LastActivityDate": "2013-01-06T20:54:30.777", "CommentCount": "2", "CreationDate": "2013-01-06T20:54:30.777", "ParentId": "14186245", "Score": "18", "OwnerUserId": "143091"}, "14186245": {"ViewCount": "20775", "Body": "<p>I would like to make unit tests for my C++ application.</p>\n<p>What is the correct form to test private members of a class? Make a friend class which will test the private members, use a derived class, or some other trick?</p>\n<p>Which technique does the testing APIs use?</p>\n", "AcceptedAnswerId": "14186518", "Title": "Unit testing c++. How to test private members?", "CreationDate": "2013-01-06T20:11:08.117", "Id": "14186245", "CommentCount": "14", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2015-12-16T06:34:14.140", "LastEditorUserId": "908939", "LastActivityDate": "2016-04-29T03:21:41.940", "Score": "33", "OwnerUserId": "1930404", "Tags": "<c++><unit-testing><testing>", "AnswerCount": "7"}});