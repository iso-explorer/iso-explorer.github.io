post_cb({"7394492": {"ViewCount": "4042", "Body": "<p>In C++0x, you can use the <code>using</code> keyword to inherit constructors, like so:</p>\n<pre><code>class B { B(int) {} };\n\nclass A : public B { using B::B; };\n</code></pre>\n<p>Which will implicitly declare an <code>A(int)</code> constructor. Does this work with templates?</p>\n<pre><code>class B { B(int) {} };\n\ntemplate&lt;class T&gt; class A : public T { using T::T; };\n</code></pre>\n<p>Within <code>T::T</code>, I expect the compiler to figure out the left hand <code>T</code> since using the scope operator on template arguments is normal, but figuring out that the right hand <code>T</code> is the constructor is a special case. In fact it appears there's an ambiguity: what if I have a method called <code>T</code> in <code>B</code> that I'm trying to add overloads to in <code>A</code> (that's how a compiler would interpret such a using declaration pre-C++0x)?</p>\n", "AcceptedAnswerId": "7408582", "Title": "Does inheriting constructors work with templates in C++0x?", "CreationDate": "2011-09-12T21:52:07.343", "Id": "7394492", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2011-09-12T22:02:29.030", "LastEditorUserId": "235825", "LastActivityDate": "2011-09-13T21:26:02.667", "Score": "23", "OwnerUserId": "50385", "Tags": "<c++><inheritance><constructor><standards><c++11>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_7394492_7394577_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 490}, "so_7394492_7408582_0": {"length": 5, "quality": 0.625, "section_id": 7114}, "so_7394492_7408582_1": {"length": 5, "quality": 1.0, "section_id": 7114}}, "n3337": {"so_7394492_7394577_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 481}, "so_7394492_7408582_0": {"length": 8, "quality": 1.0, "section_id": 6858}, "so_7394492_7408582_1": {"length": 5, "quality": 1.0, "section_id": 6858}}, "n4659": {"so_7394492_7394577_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 464}, "so_7394492_7408582_0": {"length": 5, "quality": 0.625, "section_id": 8615}, "so_7394492_7408582_1": {"length": 5, "quality": 1.0, "section_id": 8615}}}, "7408582": {"Id": "7408582", "PostTypeId": "2", "Body": "<p>Yes it works, and the reason is the name lookup mechanism. The mechanism a inheriting-constructors declaration works is simple: If the using declaration's name refers to base class constructors, that's an inheriting constructors declaration. At 3.4.3.1[class.qual]p2 we find:</p>\n<blockquote>\n<p id=\"so_7394492_7408582_0\">In a lookup in which the constructor is an acceptable lookup result and the nested-name-specifier nominates a class C</p>\n<ul>\n<li>if the name specified after the nested-name-speci\ufb01er, when looked up in C, is the injected-class-name of C (Clause 9), or</li>\n<li>in a using-declaration (7.3.3) that is a member-declaration, if the name specified after the nested-name-specifier is the same as the identifier or the simple-template-id's template-name in the last component of the nested-name-specifier</li>\n</ul>\n<p id=\"so_7394492_7408582_1\">the name is instead considered to name the constructor of class C. </p>\n</blockquote>\n<p>This is the paragraph that makes out of class constructor definitions work, and this is also the paragraph that makes inheriting constructor declarations work. The second bullet applies in this case:</p>\n<pre><code>struct B {\n  B(int) { }\n};\n\ntypedef B mytype;\n\nstruct A : B {\n  // \"name ... is the same as the identifier ... in the last component ...\"\n  using mytype::mytype;\n};\n\n\ntemplate&lt;typename T&gt; using same = T;\n\nstruct C : B {\n  // \"name ... is the same as the template-name ... in the last component ...\"\n  same&lt;B&gt;::same;\n};\n</code></pre>\n<p>The latter example proves also useful in cases such as the following</p>\n<pre><code>template&lt;template&lt;typename&gt; class Base&gt;\nstruct X : Base&lt;int&gt; {\n  using Base&lt;int&gt;::Base;\n};\n</code></pre>\n<p>In summary: </p>\n<ul>\n<li><p>The first bullet above is a semantic rule - if the name after the nested name specifier refers to the injected class name (<code>B::B</code> or <code>mytype::B</code>), then it will be translated to refer to the constructor(s). </p></li>\n<li><p>The second bullet is a syntactic rule - the names just must match - their meaning is irrelevant otherwise - there could have been a member called <code>Base</code> in the template argument provided to <code>X</code>, such as in the following, but the using declaration would still import the constructors and do <em>not</em> name the member <code>Base</code>:</p>\n<pre><code>template&lt;typename T&gt; struct D { private: T Base; };\nX&lt;D&gt; x; // valid, the private member is *not* touched!\n</code></pre></li>\n</ul>\n", "LastEditorUserId": "34509", "LastActivityDate": "2011-09-13T21:26:02.667", "Score": "10", "CreationDate": "2011-09-13T21:13:39.900", "ParentId": "7394492", "CommentCount": "0", "OwnerUserId": "34509", "LastEditDate": "2011-09-13T21:26:02.667"}, "7394577": {"Id": "7394577", "PostTypeId": "2", "Body": "<p>Yes, it appears it does, from the standard (Feb 2011 Draft), section 12.9:</p>\n<pre><code>template&lt; class T &gt;\nstruct D : T {\nusing T::T; // declares all constructors from class T\n~D() { std::clog &lt;&lt; \"Destroying wrapper\" &lt;&lt; std::endl; }\n};\n</code></pre>\n<blockquote>\n<p id=\"so_7394492_7394577_0\">Class template D wraps any class and forwards all of its constructors,\n  while writing a message to the standard log whenever an object of\n  class D is destroyed. \u2014end example</p>\n</blockquote>\n<p>Another thing to note, while the standard allows it, according to <a href=\"http://wiki.apache.org/stdcxx/C++0xCompilerSupport\" rel=\"nofollow\">this list</a>, only 1 compiler, IBM XLC++, supports this feature in a release version.  GCC only currently supports it with a patch.</p>\n<p>Edit:  AJG85 pointed out that the T in the template always refers to the placeholder, so the 'using T::T' always refers to the template argument.</p>\n", "LastEditorUserId": "862231", "LastActivityDate": "2011-09-13T10:48:56.950", "Score": "7", "CreationDate": "2011-09-12T22:02:27.360", "ParentId": "7394492", "CommentCount": "3", "OwnerUserId": "862231", "LastEditDate": "2011-09-13T10:48:56.950"}});