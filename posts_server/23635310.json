post_cb({"bq_ids": {"n4140": {"so_23635310_23635362_1": {"length": 11, "quality": 0.6875, "section_id": 6151}, "so_23635310_23635362_2": {"length": 10, "quality": 1.0, "section_id": 3228}, "so_23635310_23635310_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 955}, "so_23635310_23635362_3": {"length": 4, "quality": 0.8, "section_id": 955}, "so_23635310_23635362_0": {"length": 21, "quality": 1.0, "section_id": 6142}}, "n3337": {"so_23635310_23635362_1": {"length": 16, "quality": 1.0, "section_id": 5913}, "so_23635310_23635362_2": {"length": 10, "quality": 1.0, "section_id": 3101}, "so_23635310_23635310_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 943}, "so_23635310_23635362_3": {"length": 4, "quality": 0.8, "section_id": 943}, "so_23635310_23635362_0": {"length": 21, "quality": 1.0, "section_id": 5906}}, "n4659": {"so_23635310_23635362_1": {"length": 10, "quality": 0.625, "section_id": 7648}, "so_23635310_23635362_2": {"length": 10, "quality": 1.0, "section_id": 3985}, "so_23635310_23635362_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 7638}}}, "23635310": {"ViewCount": "699", "Body": "<p>I need to be able to access (read-only, no resizing involved or anything like that) the elements of a an <code>std::vector</code> via pointers. E.g.,</p>\n<pre><code>std::vector&lt;int&gt; foo(10);\nint *ptr_begin = &amp;foo[0];\n</code></pre>\n<p>So far so good, this is guaranteed to work in the current standard (23.3.6.1):</p>\n<blockquote>\n<p id=\"so_23635310_23635310_0\">The elements of a vector are stored contiguously, meaning that if v is a vector where T is some type other than bool, then it obeys the identity &amp;v[n] == &amp;v[0] + n for all 0 &lt;= n &lt; v.size().</p>\n</blockquote>\n<p>So we can access all elements of the vector using pointers, since they are stored in a contiguous chunk of memory. But what about the one-past-the-last element? I mean, it is legal to perform this operation?</p>\n<pre><code>int *ptr_end = ptr_begin + foo.size()\n</code></pre>\n<p>(Note, I am not trying to access the past-the-last value, merely to define a pointer to it - an equivalent to <code>foo.end()</code> if you like). The standard mentions only accessing elements via pointer arithmetics, but clearly here we are not accessing any element.</p>\n<p>(As a side note, the definition of the existence of a past-the-last something seems tightly connected to the base concept of array (see for instance 5.7/5), but throughout the standard it seems like the concepts of contiguous storage and array are used interchangeably. Am I reading wrong?)</p>\n", "AcceptedAnswerId": "23635362", "Title": "Accessing std::vector elements via pointers vs end()", "CreationDate": "2014-05-13T15:20:48.860", "Id": "23635310", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-05-13T23:50:09.247", "Score": "7", "OwnerUserId": "453925", "Tags": "<c++><pointers><c++11>", "AnswerCount": "3"}, "23636396": {"Id": "23636396", "PostTypeId": "2", "Body": "<p>You should remember about existence of <code>std::vector::data()</code>, which explicitly gives you the pointer to this continuous memory. So yes, read only operations are available (if you're not mixing them with other vector methods, which could do some reallocation etc. underneath).</p>\n<p>I would even go further - changing contents of memory under <code>std::vector::data()</code> should also be legal.</p>\n", "LastActivityDate": "2014-05-13T16:10:24.447", "Score": "1", "CreationDate": "2014-05-13T16:10:24.447", "ParentId": "23635310", "CommentCount": "0", "OwnerUserId": "2641513"}, "23635362": {"Id": "23635362", "PostTypeId": "2", "Body": "<p>Yes, as long as you only use ptr_end in comparisons<sup>*</sup> and don't attempt to deference it, this is fine. Quoting from \u00a7 5.7 in the C++11 draft standard regarding additive operations with pointers (emphasis mine):</p>\n<blockquote>\n<p id=\"so_23635310_23635362_0\">If both the pointer operand and the result point to elements of the\n  same array object, <em>or one past the last element of the array object</em>,\n  the evaluation shall not produce an overflow; otherwise, the behavior\n  is undefined.</p>\n</blockquote>\n<p>Similar provisions are listed for the relational operators in \u00a7 5.9:</p>\n<blockquote>\n<p id=\"so_23635310_23635362_1\">If two pointers point to elements of the same array <em>or one beyond the\n  end of the array</em>, the pointer to the object with the higher subscript\n  compares higher.</p>\n</blockquote>\n<p>As to whether <code>vector</code>'s buffer counts as an array for the purposes of the above, \u00a7 8.3.4 states:</p>\n<blockquote>\n<p id=\"so_23635310_23635362_2\">An object of array type contains a contiguously allocated non-empty\n  set of N subobjects of type T.</p>\n</blockquote>\n<p>which is consistent with what \u00a7 23.3.6.1 has to say about <code>vector</code>:</p>\n<blockquote>\n<p id=\"so_23635310_23635362_3\">The elements of a vector are stored contiguously</p>\n</blockquote>\n<hr>\n<p>Since pointers are <code>iterator</code>s, this sort of thing is a handy trick for using standard library algorithms with an arbitrary block of memory as the input. For example, say you want to use the <code>lower_bound</code> algorithm, but your data is stored in an MFC CArray:</p>\n<pre><code>CArray&lt;int&gt; someInts;\n// populate and check for empty\nint* begin = someInts.GetData();\nint* end = begin + someInts.GetSize(); // for bounds-checking only; don't dereference\nint* answer = std::lower_bound(begin, end, 100);\n</code></pre>\n<hr/>\n<p><sup>*</sup>There are a couple other operations that are legal too; e.g. since you know your vector isn't empty, you could subtract one to get a pointer to the last element. The important thing is don't dereference.</p>\n</hr>", "LastEditorUserId": "3549027", "LastActivityDate": "2014-05-13T23:50:09.247", "Score": "13", "CreationDate": "2014-05-13T15:23:04.283", "ParentId": "23635310", "CommentCount": "16", "LastEditDate": "2014-05-13T23:50:09.247", "OwnerUserId": "3549027"}, "23639846": {"Id": "23639846", "PostTypeId": "2", "Body": "<p>Yep, it is legal to form the address to the one-past-the-end element.  It is not legal to deference it.  The draft standard even has a footnote which notes that \"an implementation need only provide one extra byte (which might overlap another object in the program) just after the end of the object in order to satisfy the \u201cone past the last element\u201d requirements\".  You are also allowed to do pointer math with it (at least all of the legal stuff that you could do if you were dealing with a pointer into the array).</p>\n", "LastActivityDate": "2014-05-13T19:23:39.923", "Score": "1", "CreationDate": "2014-05-13T19:23:39.923", "ParentId": "23635310", "CommentCount": "0", "OwnerUserId": "1987633"}});