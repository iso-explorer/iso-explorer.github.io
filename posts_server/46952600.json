post_cb({"46952862": {"Id": "46952862", "PostTypeId": "2", "Body": "<p>In short if you want to achieve <code>polymorphism</code> use virtual methods and pointers to base classes.</p>\n<pre><code>class A{\n    public:\n        virtual void F(){std::cout &lt;&lt; \"Base A::Foo()\" &lt;&lt; std::endl;}\n};\n\nclass B : public A{\n    public:\n       void F(){std::cout &lt;&lt; \"B::Foo()\" &lt;&lt; std::endl;}\n};\n</code></pre>\n<p>Now in main:</p>\n<pre><code>int main(){\n\n    A* ptrA = new B;\n    ptrA-&gt;Foo();\n\n    return 0;\n}\n</code></pre>\n<p>As you can see above the method <code>Foo</code> is invoked depending on the object type that <code>ptrA</code> points to.</p>\n<ul>\n<li>Method overriding requires re-declaring virtual methods in derived classes.</li>\n</ul>\n", "LastEditorUserId": "2874856", "LastActivityDate": "2017-10-26T11:20:55.383", "Score": "1", "CreationDate": "2017-10-26T11:15:35.023", "ParentId": "46952600", "CommentCount": "0", "OwnerUserId": "2874856", "LastEditDate": "2017-10-26T11:20:55.383"}, "bq_ids": {"n4140": {"so_46952600_46952852_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 5861}}, "n3337": {"so_46952600_46952852_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 5631}}, "n4659": {"so_46952600_46952852_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 7340}}}, "46952852": {"Id": "46952852", "PostTypeId": "2", "Body": "<p>You have to add the declaration, because the C++ standard demands that each and every member of a class be declared in the class definition itself:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/class#mem-1\" rel=\"noreferrer\">[class.mem]/1</a>:</p>\n<blockquote>\n<p id=\"so_46952600_46952852_0\">The member-specification in a class definition declares the full set of members of the class; no member can be added elsewhere.</p>\n</blockquote>\n<p><em>Members</em> refers to both functions and data. The fact there is a pure virtual function in <code>Algorithm</code> doesn't automatically mean that <code>SelectAlgorithmRandom</code> is also going to define it. Classes can be kept abstract through several layers of an inheritance hierarchy.</p>\n<p>To define the <code>run</code> function, you must specify that intent explicitly in the class definition. </p>\n<p>And by the way, in modern C++, it's best to declare the function is <em>meant</em> as an override:</p>\n<pre><code>void run() override;\n</code></pre>\n<p>That way the compiler checks it against the definition of the base class version, to ensure you are really overriding something in the base, and not adding an overload or some unrelated function.</p>\n", "LastActivityDate": "2017-10-26T11:14:54.230", "CommentCount": "0", "CreationDate": "2017-10-26T11:14:54.230", "ParentId": "46952600", "Score": "6", "OwnerUserId": "817643"}, "46953292": {"Id": "46953292", "PostTypeId": "2", "Body": "<p>You have to declare the <code>run()</code> function in the declaration of <code>SelectAlgorithmRandom</code> to show that you actually intend to define it for that class. </p>\n<p>If not, <code>SelectAlgorithmRandom</code> would also be an abstract class and the function could be defined in a further derived class. Perhaps several levels down.</p>\n", "LastActivityDate": "2017-10-26T11:37:57.277", "CommentCount": "0", "CreationDate": "2017-10-26T11:37:57.277", "ParentId": "46952600", "Score": "1", "OwnerUserId": "597607"}, "46952600": {"ViewCount": "61", "Body": "<p>Can somebody explain, if we have an abstract class with a <code>virtual</code> member function, <strong><em>why</em></strong> do we need to declare it again in our sub-class? For instance, see example below</p>\n<h2>Abstract Class</h2>\n<p><strong>.h file</strong></p>\n<pre><code>#ifndef ALGORITHM_H\n#define ALGORITHM_H\n\n#include &lt;vector&gt;\n#include \"Event.h\"\n\nusing std::vector;\n\nclass Algorithm{\nprotected:\n  vector&lt;Event&gt;* dataset;\npublic:\n  Algorithm(vector&lt;Event&gt;&amp; dataset);\n  virtual ~Algorithm();\n\n  virtual void run() = 0;\n};\n\n#endif\n</code></pre>\n<p><strong>.cpp file</strong></p>\n<pre><code>#include \"../include/Algorithm.h\"\n\nAlgorithm::Algorithm(vector&lt;Event&gt;&amp; dataset):dataset(&amp;dataset){}\nAlgorithm::~Algorithm(){}\n</code></pre>\n<p>Given the pure virtual function <code>run</code> is declared, by extending this class, my expectation was it will <strong><em>only</em></strong> require implementation. However, it still requires declaration in class that extends this abstract-class. </p>\n<h2>Sub-Class</h2>\n<p><strong>.h file</strong></p>\n<pre><code>#ifndef SELECT_ALGORITHM_RANDOM_H\n#define SELECT_ALGORITHM_RANDOM_H\n\n#include \"Algorithm.h\"\n\nclass SelectAlgorithmRandom : public Algorithm{\npublic:\n  SelectAlgorithmRandom(vector&lt;Event&gt;&amp; dataset);\n  ~SelectAlgorithmRandom();\n\n  void run(); // &lt;-- why do I need this here, and doesn't it defy the purpose of me declaring virtual `run` function in `Algorithm`? \n};\n\n#endif\n</code></pre>\n<p><strong>.cpp file</strong></p>\n<pre><code>#include \"../include/SelectAlgorithmRandom.h\"\n\nSelectAlgorithmRandom::SelectAlgorithmRandom(vector&lt;Event&gt;&amp; dataset):Algorithm(dataset){}\nSelectAlgorithmRandom::~SelectAlgorithmRandom(){}\n\nvoid SelectAlgorithmRandom::run(){\n  //  TODO\n}\n</code></pre>\n", "AcceptedAnswerId": "46952852", "Title": "Why do I need to re-declare `virtual` methods in my Sub-Class? [C++ / Polymorphism]", "CreationDate": "2017-10-26T11:01:15.443", "Id": "46952600", "CommentCount": "3", "LastEditDate": "2017-10-26T11:06:11.917", "PostTypeId": "1", "LastEditorUserId": "2346144", "LastActivityDate": "2017-10-26T11:37:57.277", "Score": "0", "OwnerUserId": "2346144", "Tags": "<c++><polymorphism>", "AnswerCount": "3"}});