post_cb({"46117858": {"ParentId": "46117714", "CommentCount": "0", "CreationDate": "2017-09-08T13:39:42.113", "OwnerUserId": "121747", "PostTypeId": "2", "Id": "46117858", "Score": "2", "Body": "<p>Since you are using <code>Frame</code> just as a pointer the compiler doesn't need to know anything about <code>Frame</code> structure itself. It's like using an opaque pointer to something without caring what's pointed.</p>\n<p>The cast fails because <code>unsigned long</code> is not guaranteed to be the same size of a pointer according to operating system and data model (eg LLP64 vs LP64). You should consider using <code>intptr_t</code> from <code>&lt;stdint.h&gt;</code> which is guaranteed to be able to store all the bits of a pointer but I don't see how you could need to reinterpred a literal to a memory address.</p>\n", "LastActivityDate": "2017-09-08T13:39:42.113"}, "46117767": {"ParentId": "46117714", "PostTypeId": "2", "CommentCount": "13", "CreationDate": "2017-09-08T13:35:30.393", "Score": "3", "LastEditorUserId": "2380830", "LastEditDate": "2017-09-08T14:00:34.300", "Id": "46117767", "OwnerUserId": "2380830", "Body": "<p>The program behaviour is <em>undefined</em>, as a conversion from an <code>unsigned long</code> to <code>Frame*</code> where the former is set to a value not associated with a pointer value that you can set is not in accordance with one of the possibilities mentioned in <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/reinterpret_cast</a>.</p>\n<p>The fact that <code>printf</code> appears to output the address of a pointer is a manifestation of that undefined behaviour.</p>\n<p>The fact that <code>Frame</code> is an <em>incomplete type</em> does not matter here. With the exception of <code>nullptr</code>, one past the address of a scalar (i.e. single object or a plain-old-data object), and one past the end of an array, the behaviour on setting a pointer type to memory you don't own is also <em>undefined</em>.</p>\n", "LastActivityDate": "2017-09-08T14:00:34.300"}, "46117714": {"CommentCount": "1", "ViewCount": "41", "CreationDate": "2017-09-08T13:32:45.240", "LastActivityDate": "2017-09-08T14:00:34.300", "Title": "Struct without definition used as pointer", "AcceptedAnswerId": "46117767", "PostTypeId": "1", "Id": "46117714", "Score": "1", "Body": "<p>I have come across some code that looks like it is forward declaring a struct but I can not find any definition for the struct in the code base. It seems to be used as though the struct was defined. Could someone explain why the below code is valid c++?</p>\n<p>What type is Frame? What is the size? I cannot use sizeof() as it will complain it is undefined. </p>\n<p>I am trying to convert a similar piece of code to Visual Studio 2015 from 2010. The reinterpret_cast cast is complaining that it cannot be converted due to the fact that </p>\n<blockquote>\n<p id=\"so_46117714_46117714_0\">'reinterpret_cast': conversion from 'unsigned long' to 'Frame *' of\n  greater size</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\n\nstruct Frame;\n\nint main()\n{\n    unsigned long currentFrame = 5;\n    Frame* frame = reinterpret_cast&lt;Frame*&gt;(currentFrame);\n    printf(\"%p\", frame);\n}\n</code></pre>\n<p>GCC 4.9.2 was used to compile this example.</p>\n<p>I understand the error, but do not understand how the struct is being used. Is it defaulting to int? </p>\n", "Tags": "<c++><visual-studio-2010><visual-studio-2015><struct>", "OwnerUserId": "4027338", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_46117714_46117714_0": {"section_id": 45, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_46117714_46117714_0": {"section_id": 42, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_46117714_46117714_0": {"section_id": 46, "quality": 0.5714285714285714, "length": 4}}}});