post_cb({"bq_ids": {"n4140": {"so_16479281_16479400_0": {"length": 23, "quality": 0.92, "section_id": 6365}}, "n3337": {"so_16479281_16479400_0": {"length": 23, "quality": 0.92, "section_id": 6122}}, "n4659": {"so_16479281_16479400_0": {"length": 23, "quality": 0.92, "section_id": 7876}}}, "16479400": {"Id": "16479400", "PostTypeId": "2", "Body": "<p>You should not make concrete assumptions on the state of a moved-from object of the standard library, other than the fact that it is a legal state (unless further post-conditions of the move-assignment operator or move constructor are specified). </p>\n<p>Per paragraph 17.6.5.15 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16479281_16479400_0\">Objects of types defined in the C++ standard library may be moved from (12.8). Move operations may\n  be explicitly specified or implicitly generated. Unless otherwise specified, such moved-from objects shall be\n  placed in a valid but unspecified state.</p>\n</blockquote>\n<p>Moreover, paragraphs 21.4.2/21-23 about the move-assignment operator of the <code>basic_string</code> class template do not specify anything about whether the moved-from string shall be left in a state such that invoking <code>empty()</code> on it returns <code>true</code>.</p>\n<p>Calling <code>empty()</code> is legal in this case, since it does not have any pre-conditions on the state of the <code>string</code> object it is invoked on; on the other hand, you cannot make assumptions on what its return value shall be.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-05-10T09:56:52.547", "Score": "9", "CreationDate": "2013-05-10T09:43:43.980", "ParentId": "16479281", "CommentCount": "3", "OwnerUserId": "1932150", "LastEditDate": "2013-05-10T09:56:52.547"}, "16479980": {"Id": "16479980", "PostTypeId": "2", "Body": "<p>Aside from what the others said about moving and using the moved object after that, a move is not exactly what you want to do here. What you <em>conceptually</em> want to is assign the content of <code>_longest</code> to <code>longest_phrase</code> and clear <code>_longest</code>. You were right in trying to avoid copying and reallocation, but you can achieve that easily by swapping:</p>\n<pre><code> if ( _longest.size() &gt; longest_phrase.size() )\n {\n    longest_phrase.clear(); // don't need the old content any more\n    longest_phrase.swap(_longest); //move the data of _longest to longest_phrase\n }\n assert(_longest.empty());  \n</code></pre>\n", "LastActivityDate": "2013-05-10T10:15:13.030", "CommentCount": "5", "CreationDate": "2013-05-10T10:15:13.030", "ParentId": "16479281", "Score": "1", "OwnerUserId": "1838266"}, "16480657": {"Id": "16480657", "PostTypeId": "2", "Body": "<p>Other answers have pointed out that by the standard you cannot rely on a move operation from a string object leaving that object empty.</p>\n<p>However, you should expect that something more efficient than a copy is taking place.  What is certainly happening is that your compiler's <code>basic_string&lt;&gt;&amp; operator=(basic_string&lt;&gt;&amp;&amp;)</code> (the string 'move assignment') is implemented by swapping the two string objects (which is exactly what the standard sort of suggests: \"Note: A\nvalid implementation is swap(str).\").</p>\n<p>g++ apparently implements the string move assignment this way.</p>\n<p>So you don't need to worry about efficiency - there should be no unnecessary copying of the string going on.  However, you do need to make sure that the moved from string is cleared after the move, if you're going to use that object anymore. </p>\n", "LastActivityDate": "2013-05-10T10:52:44.580", "CommentCount": "1", "CreationDate": "2013-05-10T10:52:44.580", "ParentId": "16479281", "Score": "3", "OwnerUserId": "12711"}, "16479281": {"ViewCount": "384", "Body": "<p>Look at this code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;iterator&gt;\n\nusing namespace std;\n\nint main()\n{\nifstream text(\"text.txt\");\n\nistreambuf_iterator&lt;char&gt; iis(text);\nstring longest_phrase, _longest;\n\nwhile (iis != istreambuf_iterator&lt;char&gt;()) {\n    if ( *iis != '.' ) {\n        _longest.push_back(*iis);\n        ++iis;\n        continue;\n    }\n    if ( _longest.size() &gt; longest_phrase.size() )\n        longest_phrase = move(_longest); //I want to move the data of _longest to longest_phrase. Just move! Not to copy!\n    cout &lt;&lt; _longest.empty(); //why _longest is not empty??\n            //_longest.clear();\n    ++iis;\n}\ntext.close();\nlongest_phrase.push_back('.');\ncout &lt;&lt; \"longest phrase is \" &lt;&lt; longest_phrase;\nreturn 0;\n}\n</code></pre>\n<p>This code searches for the longest phrase in file. \nSo why the conversion from lvalue to rvalue doesnt work?</p>\n<p>Edit:\nThat's why I thought that it did not work:    </p>\n<pre><code>class Vector {\npublic:\n    Vector(vector&lt;int&gt; &amp;&amp;v): vec( move(v) ) {}\n    vector&lt;int&gt; vec;\n};\n\nint main()\n{\n    vector&lt;int&gt; ints(50, 44);\n    Vector obj( move(ints) );\n    cout &lt;&lt; ints.empty();\n    return 0;\n}\n</code></pre>\n<p>Thank you all for the quick and helpful answers!</p>\n", "AcceptedAnswerId": "16479400", "Title": "C++11 string assignment operator", "CreationDate": "2013-05-10T09:37:17.303", "Id": "16479281", "CommentCount": "2", "LastEditDate": "2013-05-10T13:50:28.510", "PostTypeId": "1", "LastEditorUserId": "2369428", "LastActivityDate": "2013-05-10T13:50:28.510", "Score": "2", "OwnerUserId": "2369428", "Tags": "<c++><string><c++11>", "AnswerCount": "3"}});