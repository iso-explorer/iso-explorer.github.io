post_cb({"9747010": {"ViewCount": "1383", "Body": "<p>Does this code violate strict aliasing?</p>\n<pre><code>struct {int x;} a;\n*(int*)&amp;a = 3\n</code></pre>\n<p>More abstractly, is it legal to cast between different types as long as the primitive read/write operations are type correct?</p>\n", "AcceptedAnswerId": "9747062", "Title": "Does accessing the first field of a struct via a C cast violate strict aliasing?", "CreationDate": "2012-03-17T03:31:28.327", "Id": "9747010", "CommentCount": "8", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2012-07-21T17:36:52.330", "LastEditorUserId": "16480", "LastActivityDate": "2012-07-21T17:36:52.330", "Score": "14", "OwnerUserId": "16480", "Tags": "<c++><c><language-lawyer><reinterpret-cast><strict-aliasing>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_9747010_9747062_1": {"length": 6, "quality": 0.5454545454545454, "section_id": 7230}}, "n3337": {"so_9747010_9747062_1": {"length": 6, "quality": 0.5454545454545454, "section_id": 6974}, "so_9747010_9747062_0": {"length": 23, "quality": 0.575, "section_id": 5650}}}, "9747062": {"PostTypeId": "2", "Body": "<p>First, it is legal to cast in C. \u00a76.7.2.1/13:</p>\n<blockquote>\n<p id=\"so_9747010_9747062_0\">Within a structure object, the non-bit-field members and the units in\n  which bit-fields reside have addresses that increase in the order in\n  which they are declared. A pointer to a structure object, suitably\n  converted, points to its initial member (or if that member is a\n  bit-field, then to the unit in which it resides), and vice versa.\n  There may be unnamed padding within a structure object, but not at its\n  beginning.</p>\n</blockquote>\n<p>The aliasing rule reads as follows (\u00a76.5/7):</p>\n<blockquote>\n<p id=\"so_9747010_9747062_1\">An object shall have its stored value accessed only by an lvalue expression that has one of\n  the following types:</p>\n<ul>\n<li>a type compatible with the effective type of the object,</li>\n<li>a qualified version of a type compatible with the effective type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the effective type of the\n  object,</li>\n<li>a type that is the signed or unsigned type corresponding to a qualified version of the\n  effective type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its\n  members (including, recursively, a member of a subaggregate or contained union), or</li>\n<li>a character type.</li>\n</ul>\n</blockquote>\n<p>Here you would be accessing it via pointers of a \"type compatible with the effective type of the object\" and \"an aggregate or union type that includes one of the aforementioned types among its members\", so no problem with aliasing either. So in C, it is indeed perfectly legal to access the first member of a structure by casting the pointer to the structure to the type of the member in question.</p>\n<p>In C++, however, you'll often find vtables and other things at the start of a C++ object. In your specific case, however, your structure is of standard layout, and so this is explicitly allowed (\u00a79.2/20 in n3290, thanks Luc Danton! - C++03 apparently has a similar rule, expressed in terms of POD objects).</p>\n", "LastActivityDate": "2012-03-17T05:47:52.353", "LastEditorUserId": "36723", "Id": "9747062", "CommentCount": "6", "CreationDate": "2012-03-17T03:45:14.453", "ParentId": "9747010", "Score": "24", "OwnerUserId": "36723", "LastEditDate": "2012-03-17T05:47:52.353"}});