post_cb({"8924034": {"CommentCount": "6", "AcceptedAnswerId": "8924348", "PostTypeId": "1", "LastEditorUserId": "229686", "CreationDate": "2012-01-19T09:56:46.360", "LastActivityDate": "2012-01-22T09:03:21.223", "LastEditDate": "2012-01-22T09:03:21.223", "ViewCount": "219", "FavoriteCount": "2", "Title": "Can copy elision happen across synchronize-with statements?", "Id": "8924034", "Score": "13", "Body": "<p>In the example below, if we ignore the mutex for a second, copy elision may eliminate the two calls to the copy constructor.</p>\n<pre><code>user_type foo()\n{\n  unique_lock lock( global_mutex );\n  return user_type(...);\n}\n\nuser_type result = foo();\n</code></pre>\n<p>Now the rules for copy elision don't mention threading, but I'm wondering whether it should actually happen across such boundaries. In the situation above, the final copy, in the logical abstract machine inter-thread happens after the mutex is released. If however the copies are omitted the result data structure is initialized within the mutex, thus it inter-thread happens before the mutex is released.</p>\n<p>I have yet to think of a concrete example how copy elision could truly result in a race condition, but the interference in the memory sequence seems like it might be problem. Can anybody definitively say it can not cause a problem, or can somebody produce an example that can indeed break?</p>\n<hr>\n<p>To ensure the answer doesn't just address a special case, note that copy elision is (according to my reading) still allowed to occur if I have a statement like <code>new (&amp;result)( foo() )</code>. That is, <code>result</code> does not need to be a stack object. <code>user_type</code> itself may also work with data shared between threads.</p>\n<hr>\n<p><strong>Answer</strong>: I've chosen the first answer as the most relevant discussion. Basically since the standard says elision can happen, the programmer just has to be careful when it happens across synchronization bounds. There is no indication of whether this is an intentional or accidental requirement. We're still lacking in any example showing what could go wrong, so perhaps it isn't an issue either way.</p>\n</hr></hr>", "Tags": "<c++><c++11>", "OwnerUserId": "229686", "AnswerCount": "2"}, "8924348": {"ParentId": "8924034", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Threads have nothing to do with it, but the order of constructors/destructors of the lock may affect you.</p>\n<p>Looking at the low level steps your code does, with out copy elision, one by one (using the GCC option -fno-elide-constructors):</p>\n<ol>\n<li>Construct <code>lock</code>.</li>\n<li>Construct the temporary <code>user_type</code> with <code>(...)</code> arguments.</li>\n<li>Copy-construct the temporary return value of the function, of type <code>user_type</code> using the value from step 2.</li>\n<li>Destroy the temporary from step 2.</li>\n<li>Destroy <code>lock</code>.</li>\n<li>Copy construct the <code>user_type result</code> using the value from step 3.</li>\n<li>Destroy the temporary from step 3.</li>\n<li>Later on, destroy <code>result</code>.</li>\n</ol>\n<p>Naturally, with the multiple copy elision optimizations, it will be just:</p>\n<ol>\n<li>Construct <code>lock</code>.</li>\n<li>Construct the <code>result</code> object directly with <code>(...)</code>.</li>\n<li>Destroy <code>lock</code>.</li>\n<li>Later on, destroy <code>result</code>.</li>\n</ol>\n<p>Note that in both cases the <code>user_type</code> constructor with <code>(...)</code> is protected by the lock. Any other copy constructor or destructor call may not be protected.</p>\n<p><strong>Afterthoughts</strong>:</p>\n<p>I think that the most likely place where it can cause problems is in the destructors. That is, if your original object, that constructed with <code>(...)</code> handles any shared resource differently than its copies, and does something in the destructor that needs the lock, then you have a problem.</p>\n<p>Naturally, that would mean that your object is badly design in the first place, as copies do not behave as the original object.</p>\n<p><strong>Reference</strong>:</p>\n<p>In the C++11 draft, 12.8.31 (a similar wording without all the \"moves\" is in C++98:</p>\n<blockquote>\n<p id=\"so_8924034_8924348_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class\n  object, even if the copy/move constructor and/or destructor for the object have side effects. In such cases,\n  the implementation treats the source and target of the omitted copy/move operation as simply two different\n  ways of referring to the same object, and the destruction of that object occurs at the later of the times\n  when the two objects would have been destroyed without the optimization. This elision of copy/move\n  operations, called copy elision, is permitted in the following circumstances (which may be combined to\n  eliminate multiple copies):</p>\n<ul>\n<li><p id=\"so_8924034_8924348_1\">in a return statement in a function with a class return type, when the expression is the name of a\n  non-volatile automatic object (other than a function or catch-clause parameter) with the same cvunqualified\n  type as the function return type, the copy/move operation can be omitted by constructing\n  the automatic object directly into the function\u2019s return value</p></li>\n<li><p id=\"so_8924034_8924348_2\">a function or catch-clause parameter) whose scope does not extend beyond the end of the innermost\n  enclosing try-block (if there is one), the copy/move operation from the operand to the exception\n  object can be omitted by constructing the automatic object directly into the exception object</p></li>\n<li><p id=\"so_8924034_8924348_3\">when a temporary class object that has not been bound to a reference would be copied/moved\n  to a class object with the same cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the omitted copy/move</p></li>\n<li><p id=\"so_8924034_8924348_4\">when the exception-declaration of an exception handler declares an object of the same type\n  (except for cv-qualification) as the exception object, the copy/move operation can be omitted by treating the exception-declaration as an alias for the exception object if the meaning of the program\n  will be unchanged except for the execution of constructors and destructors for the object declared by\n  the exception-declaration.</p></li>\n</ul>\n</blockquote>\n<p>Points 1 and 3 collaborate in your example to elide all the copies.</p>\n", "OwnerUserId": "865874", "LastEditorUserId": "865874", "LastEditDate": "2012-01-19T11:09:07.890", "Id": "8924348", "Score": "5", "CreationDate": "2012-01-19T10:18:28.450", "LastActivityDate": "2012-01-19T11:09:07.890"}, "bq_ids": {"n4140": {"so_8924034_8924348_0": {"section_id": 480, "quality": 0.96875, "length": 62}, "so_8924034_8924348_1": {"section_id": 480, "quality": 1.0, "length": 35}, "so_8924034_8924348_4": {"section_id": 480, "quality": 0.8709677419354839, "length": 27}, "so_8924034_8924348_2": {"section_id": 480, "quality": 1.0, "length": 28}, "so_8924034_8924348_3": {"section_id": 480, "quality": 1.0, "length": 26}}, "n3337": {"so_8924034_8924348_0": {"section_id": 471, "quality": 0.984375, "length": 63}, "so_8924034_8924348_1": {"section_id": 471, "quality": 1.0, "length": 35}, "so_8924034_8924348_4": {"section_id": 471, "quality": 0.9032258064516129, "length": 28}, "so_8924034_8924348_2": {"section_id": 471, "quality": 1.0, "length": 28}, "so_8924034_8924348_3": {"section_id": 471, "quality": 1.0, "length": 26}}, "n4659": {"so_8924034_8924348_2": {"section_id": 502, "quality": 1.0, "length": 28}, "so_8924034_8924348_1": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}, "so_8924034_8924348_4": {"section_id": 502, "quality": 0.967741935483871, "length": 30}, "so_8924034_8924348_0": {"section_id": 502, "quality": 0.96875, "length": 62}, "so_8924034_8924348_3": {"section_id": 502, "quality": 0.6538461538461539, "length": 17}}}, "8947178": {"ParentId": "8924034", "CommentCount": "0", "Body": "<p>\"To ensure the answer doesn't just address a special case, note that copy elision is (according to my reading) still allowed to occur if I have a statement like <code>new (&amp;result)( foo() )</code>. That is, result does not need to be a stack object. <code>user_type</code> itself may also work with data shared between threads.\"</p>\n<p>There's the rub: if <code>result</code> is shared, you have a data race even without elision. The behavior is undefined to begin with.</p>\n", "OwnerUserId": "90088", "PostTypeId": "2", "Id": "8947178", "Score": "0", "CreationDate": "2012-01-20T20:01:49.943", "LastActivityDate": "2012-01-20T20:01:49.943"}});