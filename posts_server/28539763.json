post_cb({"bq_ids": {"n4140": {"so_28539763_28539763_0": {"section_id": 480, "quality": 0.972972972972973, "length": 36}, "so_28539763_28539763_1": {"section_id": 481, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_28539763_28539763_0": {"section_id": 471, "quality": 0.972972972972973, "length": 36}, "so_28539763_28539763_1": {"section_id": 472, "quality": 1.0, "length": 21}}, "n4659": {"so_28539763_28539763_0": {"section_id": 502, "quality": 0.9459459459459459, "length": 35}, "so_28539763_28539763_1": {"section_id": 504, "quality": 0.6190476190476191, "length": 13}}}, "28542618": {"ParentId": "28539763", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The purpose of unique_ptr is to point to a resource from a unique place. If you need to point to this resource from multiple places, unique_ptr is no longer appropriate. You should use shared_ptr in that case.<br>\nIf releasing ownership of the resource is appropriate for your logic, then just use:</br></p>\n<pre><code>unique_ptr&lt;int&gt; get()\n{\n   return move(pInt);// this will move the ownership of the resource away from the member field\n}\n</code></pre>\n<p>... but from now on, the pInt is no longer valid.</p>\n<p>If you are careful with resources (if you are not worried of dangling pointers), than just return raw pointer to the resource (but please don't prefer this to use of shared_ptr).</p>\n<p>In case of using shared_ptr, be careful of cyclic dependency, use weak_ptr do counter it. Here is something about it: <a href=\"http://geekwentfreak-raviteja.rhcloud.com/blog/2014/07/06/c11-how-to-create-cyclic-dependencies-with-shared_ptr-and-how-to-avoid-them/?_sm_au_=irVM6PVF1TR4nGMW\" rel=\"nofollow\">http://geekwentfreak-raviteja.rhcloud.com/blog/2014/07/06/c11-how-to-create-cyclic-dependencies-with-shared_ptr-and-how-to-avoid-them/?_sm_au_=irVM6PVF1TR4nGMW</a> </p>\n<p>Post edit:\nWhen you use unique_ptr as a member field, you are loosing copy constructor, because unique_ptr cannot be copied. FYI</p>\n<p>But still, use of unique_ptr seems to me as extra overhead already, in which just use shared_ptr or int directly.</p>\n", "OwnerUserId": "3319335", "LastEditorUserId": "3319335", "LastEditDate": "2015-02-16T13:39:01.180", "Id": "28542618", "Score": "0", "CreationDate": "2015-02-16T13:33:44.440", "LastActivityDate": "2015-02-16T13:39:01.180"}, "28539763": {"CommentCount": "4", "AcceptedAnswerId": "28540376", "PostTypeId": "1", "LastEditorUserId": "977038", "CreationDate": "2015-02-16T10:53:02.940", "LastActivityDate": "2015-02-17T19:15:48.903", "LastEditDate": "2015-02-16T11:03:13.083", "ViewCount": "659", "FavoriteCount": "2", "Title": "How do we return a unique_pointer member from a member function?", "Id": "28539763", "Score": "5", "Body": "<p>I have a base class with a pointer member. I would have to make an educated guess to determine whether it should be an <code>unique_ptr</code> or a <code>shared_ptr</code>. None of them seems to solve my particular use case.</p>\n<pre><code>class Base\n{\npublic:\n    Base(): pInt(std::unique_ptr&lt;int&gt;(new int(10))) {};\n    virtual std::unique_ptr&lt;int&gt; get() = 0;\n    //Base(): pInt(std::shared_ptr&lt;int&gt;(new int(10))) {}; // Alternate implementation\n    //virtual std::shared_ptr&lt;int&gt; get() = 0; // Alternate implementation\nprivate:\n    std::unique_ptr&lt;int&gt; pInt;\n    //std::shared_ptr&lt;int&gt; pInt; // Alternate implementation\n};\n</code></pre>\n<p>The base class has been derived onto <code>Derived1</code> and <code>Derived2</code>. The former returns the <code>unique_ptr</code> member <code>pInt</code> where the later returns a local <code>unique_ptr</code> object.</p>\n<pre><code>class Derived1: public Base\n{\npublic:\n    Derived1() {};\n    virtual std::unique_ptr&lt;int&gt; get()\n    {\n        //return std::move(pInt);  Will compile but the ownership is lost\n        return pInt;\n    }\nprivate:\n    std::unique_ptr&lt;int&gt; pInt;\n};\nclass Derived2: public Base\n{\npublic:\n    Derived2() {};\n    virtual std::unique_ptr&lt;int&gt; get()\n    {\n        std::unique_ptr&lt;int&gt; pInt(new int());\n        return pInt;\n    }\nprivate:\n    std::unique_ptr&lt;int&gt; pInt;\n};\n</code></pre>\n<p><code>Derived1</code>'s implementation of get would not implicitly transfer the ownership as the member pointer variable is not an <strong>eXpiring</strong> value, where as the <code>Derived2</code>'s implementation can. This behaviour is well documented in the standard</p>\n<p>see 12.8 \u00a734 and \u00a735:</p>\n<blockquote>\n<p id=\"so_28539763_28539763_0\">When certain criteria are met, an implementation is allowed to omit\n  the copy/move construction of a class object [...] This elision of\n  copy/move operations, called copy elision, is permitted [...] in a\n  return statement in a function with a class return type, when the\n  expression is the name of a non-volatile automatic object with the\n  same cv-unqualified type as the function return type [...]</p>\n<p id=\"so_28539763_28539763_1\">When the criteria for elision of a copy operation are met and the\n  object to be copied is designated by an lvalue, overload resolution to\n  select the constructor for the copy is first performed as if the\n  object were designated by an rvalue.</p>\n</blockquote>\n<p>Nevertheless, if I explicitly transfer the ownership via the <code>std::move</code>, the member pointer would be unusable in the future. </p>\n<p>Alternatively, I would have to make the definition of the pointer as <code>shared_ptr</code> but that would be an extra overhead for the implementation of <code>Derived2::get</code>.</p>\n<p><strong>Note</strong> It should be considered that the occurrence of <code>Derived2::get</code> is more compared to <code>Derived1::get</code> so the design decision of using <code>std:: shared_ptr</code> can have a considerable relative impact. </p>\n", "Tags": "<c++><pointers><c++11><shared-ptr><unique-ptr>", "OwnerUserId": "977038", "AnswerCount": "2"}, "28540376": {"ParentId": "28539763", "CommentCount": "1", "Body": "<p>Your <code>Derived1</code> case cannot be handled the way you want by <code>unique_ptr</code>. You want multiple smart pointers to the same resource. <code>unique_ptr</code> is simply not an option for that. There's no way around that.</p>\n<p>You could stick with a <code>unique_ptr</code> member, but make your function return a raw pointer.</p>\n<pre><code>virtual int *get() = 0;\n</code></pre>\n<p>This is troublesome for your <code>Derived2</code> class, because it is not clear whether the caller should free the pointed-to memory. I recommend you <strong>do not</strong> do this.</p>\n<p>You could use a <code>shared_ptr</code> member, as you suggested, and make your function return that. This is fully functional in your <code>Derived2</code> class, but as you point out, sub-optimal.</p>\n<p>It is still the cleanest solution, though. For callers that only know they've got a <code>Base</code>, you <em>need</em> some way of informing them (either manually or through the returned type) what they should do when they're done with <code>get()</code>'s result, so you cannot return <code>unique_ptr&lt;int&gt;</code> anyway.</p>\n<p>The only way a function returning <code>unique_ptr&lt;int&gt;</code> could be useful is if the caller already knows you've got a <code>Derived2</code>. But then, you can just add a new member:</p>\n<pre><code>virtual shared_ptr&lt;int&gt; get() {\n  return get_unique();\n}\nvirtual unique_ptr&lt;int&gt; get_unique() {\n    std::unique_ptr&lt;int&gt; pInt(new int());\n    return pInt;\n}\n</code></pre>\n<p>I would only do that if profiling shows that the <code>shared_ptr&lt;int&gt; get()</code> member actually adds measurable overhead, though. There's a good chance that your <code>shared_ptr&lt;int&gt;</code> implementation is sufficient, performance-wise, and then readibility should probably be a reason for <em>not</em> adding a new member.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "28540376", "Score": "4", "CreationDate": "2015-02-16T11:25:22.420", "LastActivityDate": "2015-02-16T11:25:22.420"}});