post_cb({"48969915": {"Id": "48969915", "PostTypeId": "2", "Body": "<h1>C++14</h1>\n<p>According to N3797 [expr.static.cast] paragraph 4:</p>\n<blockquote>\n<p id=\"so_48914772_48969915_0\">An expression <code>e</code> can be explicitly converted to a type <code>T</code> using a <code>static_cast</code> of the form <code>static_cast&lt;T&gt;(e)</code> if the declaration <code>T t(e);</code> is well-formed, for some invented temporary variable <code>t</code> (8.5). The effect of such an explicit conversion is the same as performing the declaration and initialization and then using the temporary variable as the result of the conversion. </p>\n</blockquote>\n<p>The expression <code>static_cast&lt;B&gt;(a)</code> performs a direct-initialization of a temporary variable of type <code>B</code> from the initializer <code>a</code>. Then the following bullet from N3797 [dcl.init] paragraph 17 applies:</p>\n<blockquote>\n<p id=\"so_48914772_48969915_1\">If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered. <strong>The applicable constructors are enumerated (13.3.1.3), and the best one is chosen through overload resolution (13.3).</strong> The constructor so selected is called to initialize the object, with the initializer expression or <em>expression-list</em> as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</p>\n</blockquote>\n<p>And \"applicable constructors\" are defined by N3797 [over.match.ctor]:</p>\n<blockquote>\n<p id=\"so_48914772_48969915_2\">For direct-initialization, the candidate functions are all the constructors of the class of the object being initialized.</p>\n</blockquote>\n<p>So all the three constructors: <code>B::B(int)</code>, <code>B::B(const B&amp;)</code>, <code>B::B(B&amp;&amp;)</code> are candidates during overload resolution. Then three corresponding implicit conversion sequences: <code>A-&gt;int</code>, <code>A-&gt;const B&amp;</code>, <code>A-&gt;B&amp;&amp;</code> are compared. As a result, <code>A-&gt;int</code> is distinguishable from the other two since the conditions of the following bullet from N3797 [over.ics.rank] paragraph 3 are not met:</p>\n<blockquote>\n<p id=\"so_48914772_48969915_3\">User-defined conversion sequence <code>U1</code> is a better conversion sequence than another user-defined conversion sequence <code>U2</code> if <strong>they contain the same user-defined conversion function or constructor</strong> or they initialize the same class in an aggregate initialization and in either case the second standard conversion\n  sequence of U1 is better than the second standard conversion sequence of <code>U2</code>.</p>\n</blockquote>\n<p>In addition, no special rules of determining the best viable function in N3797 [over.match.best] paragraph 1 apply, so the overload resolution is ambiguous, which causes the compiler error.</p>\n<h1>C++17</h1>\n<p>The deduction above also holds, so this is a compiler bug (for now). The wording for [expr.static.cast] paragraph 4 has changed due to <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#242\" rel=\"nofollow noreferrer\">CWG 242</a>, but it does not affect our conclusion.</p>\n<p>Note guaranteed copy elision does not apply here because it is not an initialization from a prvalue of the same type.</p>\n<h1>C++20 or later</h1>\n<p>There is already a <a href=\"https://groups.google.com/a/isocpp.org/forum/#!msg/std-discussion/rpOG44MGH7s/n55SAATcBgAJ\" rel=\"nofollow noreferrer\">discussion</a> about adding guaranteed copy elision to such direct-initialization cases, so maybe the behavior of selecting <code>a.operator B()</code> will be legal in the future.</p>\n", "LastActivityDate": "2018-02-25T03:24:27.990", "Score": "1", "CreationDate": "2018-02-25T03:24:27.990", "ParentId": "48914772", "CommentCount": "2", "OwnerUserId": "5376789"}, "bq_ids": {"n4140": {"so_48914772_48969915_2": {"length": 9, "quality": 0.9, "section_id": 592}, "so_48914772_48969915_3": {"length": 34, "quality": 1.0, "section_id": 639}, "so_48914772_48948802_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 5451}, "so_48914772_48969915_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 6030}, "so_48914772_48969915_1": {"length": 41, "quality": 0.9111111111111111, "section_id": 3296}}, "n3337": {"so_48914772_48969915_2": {"length": 9, "quality": 0.9, "section_id": 582}, "so_48914772_48969915_3": {"length": 28, "quality": 0.8235294117647058, "section_id": 629}, "so_48914772_48948802_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 5541}, "so_48914772_48969915_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 5798}, "so_48914772_48969915_1": {"length": 41, "quality": 0.9111111111111111, "section_id": 3166}}, "n4659": {"so_48914772_48969915_2": {"length": 9, "quality": 0.9, "section_id": 615}, "so_48914772_48969915_3": {"length": 34, "quality": 1.0, "section_id": 667}, "so_48914772_48948802_1": {"length": 9, "quality": 0.75, "section_id": 4799}, "so_48914772_48969915_1": {"length": 41, "quality": 0.9111111111111111, "section_id": 4058}}}, "48948802": {"Id": "48948802", "PostTypeId": "2", "Body": "<p>This is because the rules of <code>direct initialization</code> (wrt <code>copy elision</code> in particular) are slightly altered in C++17, and <code>static_cast&lt;B&gt;(a);</code> simply results in:</p>\n<pre><code>a.operator B();\n</code></pre>\n<p>As mentioned on <a href=\"http://en.cppreference.com/w/cpp/language/direct_initialization\" rel=\"nofollow noreferrer\">cppreference/direct_initialization</a>:</p>\n<blockquote>\n<p id=\"so_48914772_48948802_0\">if the initializer is a prvalue expression whose type is the same class as T (ignoring cv-qualification), the initializer expression itself, rather than a temporary materialized from it, is used to initialize the destination object: see copy elision (since C++17)</p>\n</blockquote>\n<p>And when reading further in <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow noreferrer\">cppreference/copy_elision</a>, it says that since C++17, the compilers are required to omit the copy- and move- construction if </p>\n<blockquote>\n<p id=\"so_48914772_48948802_1\">In a function call, if the operand of a return statement is a prvalue and the return type of the function is the same as the type of that prvalue.</p>\n</blockquote>\n<p>Thus, while <code>static_cast&lt;B&gt;(a);</code> pre C++17 can be interpreted both as <code>B(a.operator int())</code> and <code>a.operator B()</code>, C++17 has to pick the second option, since the return value of <code>a.operator B()</code> is <code>prvalue</code> of type <code>B</code> and it can omit copy-/move- construction.</p>\n", "LastEditorUserId": "1338667", "LastActivityDate": "2018-02-23T15:40:02.260", "Score": "2", "CreationDate": "2018-02-23T13:19:11.447", "ParentId": "48914772", "CommentCount": "3", "OwnerUserId": "1338667", "LastEditDate": "2018-02-23T15:40:02.260"}, "48914772": {"ViewCount": "325", "Body": "<p>I have some code like this</p>\n<pre><code>struct B\n{\n    B() {}\n    B(int v) {}\n};\n\nstruct A\n{\n    operator int() const { return 1; }\n    operator B() const { return B(); }\n};\n\nint main()\n{\n    A a;\n    static_cast&lt;B&gt;(a); // Error here\n    a.operator B(); // This is OK\n    return 0;\n}\n</code></pre>\n<p>It produces such compilation error:</p>\n<pre><code>main.cpp: In function \u2018int main()\u2019:\nmain.cpp:16:21: error: call of overloaded \u2018B(A&amp;)\u2019 is ambiguous\n     static_cast&lt;B&gt;(a);\n                     ^\nmain.cpp:4:5: note: candidate: B::B(int)\n     B(int v) {}\n     ^\nmain.cpp:1:8: note: candidate: constexpr B::B(const B&amp;)\n struct B\n        ^\nmain.cpp:1:8: note: candidate: constexpr B::B(B&amp;&amp;)\n</code></pre>\n<p>I don't ask how to fix this. Just want to understand why compiler doesn't take it? From my POV <code>static_cast&lt;B&gt;(a)</code> is equal with <code>a.operator B()</code> but seems compilator reads it differently.</p>\n<p><strong>Update:</strong></p>\n<p>This behavior happens pre c++17. With c++17 this code doesn't produce any compilation error.</p>\n", "AcceptedAnswerId": "48969915", "Title": "Call of overloaded static_cast is ambiguous", "CreationDate": "2018-02-21T20:20:05.393", "LastActivityDate": "2018-02-25T03:24:27.990", "CommentCount": "6", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2018-02-21T20:34:45.983", "LastEditorUserId": "2805305", "Id": "48914772", "Score": "14", "OwnerUserId": "2808783", "Tags": "<c++><static-cast>", "AnswerCount": "2"}});