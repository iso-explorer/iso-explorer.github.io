post_cb({"45485028": {"ParentId": "45481484", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The actual code is used to initialize shared memory under Windows (Win32). That means that the code will most probably be ported (if at all) to some platform that has appropriate IEEE 754 support. </p>\n<p>That's why I suggest to <strong>couple the non-portabilities</strong>: </p>\n<ol>\n<li><p>Use the <a href=\"https://msdn.microsoft.com/library/windows/desktop/aa366920(v=vs.85).aspx\" rel=\"nofollow noreferrer\"><code>ZeroMemory</code> macro</a> defined in <code>WinBase.h</code> (via <code>Windows.h</code>) as to explicitly state that you are not attempting to store some fancy bit patterns into floating point data.</p></li>\n<li><p>Disable the portability warning of Cppcheck right before that call.</p></li>\n</ol>\n<p>In other words:</p>\n<pre><code>#include &lt;windows.h&gt;\n\n// ...\n\nvoid clear(SharedMem* p)\n{\n    // cppcheck-suppress memsetClassFloat\n    ZeroMemory(p, sizeof *p);\n}\n</code></pre>\n", "OwnerUserId": "2932052", "LastEditorUserId": "2932052", "LastEditDate": "2017-08-03T13:10:19.653", "Id": "45485028", "Score": "1", "CreationDate": "2017-08-03T13:02:22.450", "LastActivityDate": "2017-08-03T13:10:19.653"}, "45481484": {"CommentCount": "14", "ViewCount": "320", "PostTypeId": "1", "LastEditorUserId": "2932052", "CreationDate": "2017-08-03T10:23:25.590", "LastActivityDate": "2017-08-03T13:10:19.653", "Title": "Using memset() on struct which contains a floating point number", "LastEditDate": "2017-08-03T12:42:34.643", "Id": "45481484", "Score": "4", "Body": "<p>In a C/C++ hybrid project, I found some code that I could reduce to</p>\n<pre><code>#include &lt;mem.h&gt;\n\nstruct StructContainingDouble\n{\n    double d;\n    /// other elements omitted\n};\n\nvoid clear(StructContainingDouble* p)\n{\n    memset(p, 0, sizeof *p);\n}\n</code></pre>\n<p>without stopping Cppcheck to raise the portability warning</p>\n<blockquote>\n<p id=\"so_45481484_45481484_0\">Using memset() on struct which contains a floating point number.</p>\n</blockquote>\n<p>The message is correct, but since the floating-point number is declared double, it seems to be false positive, because in double the (positive) zero value is encoded following the IEEE 754 standard:<sup>[*]</sup></p>\n<pre><code>0 00000000000 0000000000000000000000000000000000000000000000000000\n</code></pre>\n<p>So I'd tend to simply suppress the warning and forget about it</p>\n<pre><code>void clear(ContainingDouble* p)\n{\n    // cppcheck-suppress memsetClassFloat\n    memset(p, 0, sizeof *p);\n}\n</code></pre>\n<p>But maybe there is <strong>really a portability issue here?</strong></p>\n<h2>Addendum:</h2>\n<p>The actual code is based on the Win32 platform. The structure is used for managing access to <a href=\"https://msdn.microsoft.com/library/windows/desktop/aa366551(v=vs.85).aspx\" rel=\"nofollow noreferrer\">shared memory</a>, that's why constructors are useless. And it's not only one object of that structure that has to be zeroed, but an array of it that is embedded in another structure, something like this:</p>\n<pre><code>#include &lt;mem.h&gt;\n\nstruct Slot\n{\n    double d;\n    // more members...\n};\n\nstruct SharedMem\n{\n    Slot slots[2048];\n    // more members...\n};\n\nvoid clear(SharedMem* p)\n{\n    memset(p, 0, sizeof *p);\n}\n</code></pre>\n<hr>\n<p><sup>[*]</sup> from: <a href=\"https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Double-precision_examples\" rel=\"nofollow noreferrer\">Double-precision floating-point format - Wikipedia</a></p>\n</hr>", "Tags": "<c++><c><double><portability><cppcheck>", "OwnerUserId": "2932052", "AnswerCount": "4"}, "45482591": {"ParentId": "45481484", "CommentCount": "2", "Body": "<p>Is it a problem? Yes. No, not really. A very remote maybe.</p>\n<p>As pointed out in the comments by interjay C does not mandate format of floating-point values. So in theory 'zeroes' could be an invalid value or not represent zero.</p>\n<p>All modern platforms implement IEEE 754 if they have an FPU. Any (likely embedded) system that doesn't will implement IEEE 754 in its library (unless it's a degenerate implementation and simply doesn't have floating-point...).</p>\n<p>So while there is no guarantee it's very unlikely you'll encounter a problem here.\nThere are issues on some platforms regarding fine detail of how precisely they conform to the letter for IEEE 754 but having asked before and never got any answer I'll be excited to here of a platform where <code>memset()</code> a double with zeroes isn't setting it to the value of zero.</p>\n<p>That said, don't forget endianness if you start chopping double up but with zero that's not an issue.</p>\n<p>Remember C is getting near to 50 years old and things that are now almost universal such as a byte is 8 bits hadn't settled down and I think quite rightly in order to offer maximum support (don't forget embedded) it's never committed to these standards.</p>\n<p>In paranoia mode you could go with:</p>\n<pre><code>memset(&amp;obj,0,sizeof obj);\n#ifndef __STDC_IEC_559__\n    obj.dbl_val=0.0;\n#endif\n</code></pre>\n<p>Where <code>dbl_val</code> is the <code>double</code> member of <code>obj</code>. However the only likely reason for that to be undefined isn't because block zeroing isn't zero but some other fine point of the standard isn't fully implemented.</p>\n", "OwnerUserId": "4213662", "PostTypeId": "2", "Id": "45482591", "Score": "5", "CreationDate": "2017-08-03T11:14:04.840", "LastActivityDate": "2017-08-03T11:14:04.840"}, "45482138": {"ParentId": "45481484", "CommentCount": "5", "Body": "<p>It was already mentioned that C does not guarantee any particular floating point implementation.</p>\n<p>Well, neither does C++. No specific implementation of floating point values is required.</p>\n<blockquote>\n<p id=\"so_45481484_45482138_0\">[basic.fundamental]</p>\n<p id=\"so_45481484_45482138_1\">There are three floating point types: float, double, and long double.\n  [...] The value representation of floating-point types is\n  implementation-defined.</p>\n</blockquote>\n<p>So, <code>memset</code>-ing a floating point value is not portable, in either C or C++.</p>\n", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "45482138", "Score": "3", "CreationDate": "2017-08-03T10:53:06.960", "LastActivityDate": "2017-08-03T10:53:06.960"}, "45482893": {"ParentId": "45481484", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I think that the portability considerations have gone too far in this particular case. I have not seen in my life (I do programming for 30+years) any hardware or C implementation where zero means something else than zero. Of course it is possible to create any number format where zero is not zero (for example BDC with the numbers represented by the ASCII digit codes - but it is not the case here), but we discuss the real existing hardware and software.</p>\n<p>So IMO memset to zeroes is safe and portable even if the Standard says that the float point numbers are implementation defined, as I do not know any existing implementations where zero means something else than zero, and such implementation would extremely impractical. </p>\n", "OwnerUserId": "6110094", "LastEditorUserId": "6110094", "LastEditDate": "2017-08-03T11:41:50.503", "Id": "45482893", "Score": "4", "CreationDate": "2017-08-03T11:28:22.170", "LastActivityDate": "2017-08-03T11:41:50.503"}, "bq_ids": {"n4140": {"so_45481484_45482138_1": {"section_id": 7217, "quality": 0.8, "length": 12}}, "n3337": {"so_45481484_45482138_1": {"section_id": 6961, "quality": 0.8, "length": 12}}, "n4659": {"so_45481484_45482138_1": {"section_id": 8726, "quality": 0.7333333333333333, "length": 11}}}});