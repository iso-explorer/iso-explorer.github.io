post_cb({"17464011": {"ParentId": "17458421", "CommentCount": "6", "Body": "<p>I don't know of an \"elegant and portable\" solution, but I don't think there is anything wrong with the solution you propose in the question, which is to make your own copy of <code>what_arg</code>.</p>\n<p>The exception object will not last very long: typically, only long enough to unwind the stack. Furthermore, the string in <code>what_arg</code> is not likely to be very long, given that a megabyte of <code>what</code> is not going to be very readable. And finally, the exception object will only be created in exceptional circumstances, so the \"unnecessary\" duplication of a small string is not going to have any noticeable impact on your program's performance.</p>\n<p>Basically, the class designers have chosen to make the class's state opaque, and -- to put it bluntly -- you don't trust them to produce a usable result (a readable message) from that state. In that case, you will have to duplicate the state. This is a not uncommon consequence of state encapsulation, and the general solution is almost always to duplicate the state. In the case, the cost is minor, so if controlling the value of <code>what()</code> is important to you, you should just accept the cost and move on.</p>\n", "OwnerUserId": "1566221", "PostTypeId": "2", "Id": "17464011", "Score": "6", "CreationDate": "2013-07-04T07:14:27.427", "LastActivityDate": "2013-07-04T07:14:27.427"}, "17458421": {"CommentCount": "13", "AcceptedAnswerId": "17464011", "PostTypeId": "1", "LastEditorUserId": "2547845", "CreationDate": "2013-07-03T21:28:30.667", "LastActivityDate": "2013-07-05T17:28:38.317", "LastEditDate": "2013-07-05T11:49:44.140", "ViewCount": "560", "FavoriteCount": "1", "Title": "What is the standard conforming way to decide what will be returned by what() from a class inherited from std::system_error without duplicating data?", "Id": "17458421", "Score": "8", "Body": "<p>I use a class inherited from <code>std::system_error</code> for error handling and I'd like to control what is returned when <code>what()</code> is called. Reason: the standard (both C++11 and the draft C++1y CD - N3690, \u00a7 references below are into the latter) does not specify how exactly the string returned by <code>what()</code> shall look like, it just give a note in \u00a719.5.6.2 (14): </p>\n<blockquote>\n<p id=\"so_17458421_17458421_0\">Note: The returned NTBS might be the contents of <code>what_arg + \": \" +\n  code.message()</code>. \u2014 end note</p>\n</blockquote>\n<p>so it shall be considered implementation dependent. (By the way, shouldn't it be <code>code().message()</code> instead of <code>code.message()</code>?)</p>\n<p>So, the question is: how can I define precisely the string that <code>what()</code> returns if I want to be standard conformant and not relying on the implementation (i.e. want to be portable)?</p>\n<p>For those, who prefer the code:</p>\n<pre><code>class my_class : public std::system_error {\n    public:\n        my_class(std::error_code ec, std::string const &amp; what_arg)\n            : system_error(ec, /* this string is not required to be equal to what is returned by what() */)\n        {\n            // ok, try it here\n            // but what is the name of the member storing the string?\n        }\n        const char * what() const noexcept\n        {\n            // ok, try it here\n            // but how to access what_arg in its unaltered form?\n        }\n};\n</code></pre>\n<p>Ok, a trivial solution which I do not like could be the following:</p>\n<pre><code>class my_class : public std::system_error {\n        std::string my_what;\n    public:\n        my_class(std::error_code ec, std::string const &amp; what_arg)\n            : system_error(ec, what_arg),\n              my_what( /* construct my what string */ )\n        { }\n        const char * what() const noexcept\n        { return my_what.c_str(); }\n};\n</code></pre>\n<p>Since <code>std::exception::what()</code> is virtual, it will work, but is there a more elegant way without using any implementation detail? I do not like the idea of having two strings stored: one in <code>std::system_error</code> and the other in <code>my_what</code>.</p>\n<p>The root of the problem: std::runtime_error \u2014 which happens to be std::system_error's parent class \u2014 has an exact requirement in \u00a71.9.2.6 (3), a postcondition of the constructor: </p>\n<pre><code>strcmp(what(), what_arg.c_str()) == 0\n</code></pre>\n<p>Which, in the case of <code>std::system_error</code> becomes the following in \u00a719.5.6.2 (2):</p>\n<pre><code>string(what()).find(what_arg) != string::npos\n</code></pre>\n<p>Does anybody have a clue why the standard tries so hard to include <code>code().message()</code> into <code>what()</code>? Note that <code>code()</code> returns the error code object, so anybody can include <code>code().message()</code> in the string at any time (even at the time when an exception of this class is catched).</p>\n<p>If the requirement of <code>std::system_error</code> was the same as of <code>std::runtime_error</code>, I could just write:</p>\n<pre><code>class my_class : public std::system_error {\n    public:\n        my_class(std::error_code ec, std::string const &amp; what_arg)\n            : system_error(ec, /* build my what string here */ )\n        { }\n};\n</code></pre>\n<p>Is there any elegant and portable solution?</p>\n<p>UPDATE:\nLots of the comments below are stating that the error messages are implementation defined. I understand that, I just want to <strong>format</strong> the string returned by <code>what()</code>, I do not want to be it byte-by-byte equivalent on all systems. Just think about that I want to log it or pass it to a 3rd party, and it shall obey some fixed format (which is not what is suggested by the standard).</p>\n<p>UPDATE2:\nI believe that std::system_error is not just for OS or STL errors. I can (and suppose to) derive my own classes from it and use them for error reporting. What if I am writing a low level API? By the way, why is it forbidden to use it in a high level API?</p>\n<p>If I pass all the arguments to its constructor in the error handling part of my API, there is <strong>no</strong> implementation defined (i.e. unknown) error strings involved, but I still can not format it without duplicating data.</p>\n", "Tags": "<c++><c++11><c++14><system-error>", "OwnerUserId": "2547845", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17458421_17474694_1": {"section_id": 2574, "quality": 0.9444444444444444, "length": 17}, "so_17458421_17474694_0": {"section_id": 2641, "quality": 0.9583333333333334, "length": 23}, "so_17458421_17458421_0": {"section_id": 2656, "quality": 0.6, "length": 6}}, "n3337": {"so_17458421_17474694_1": {"section_id": 2539, "quality": 0.9444444444444444, "length": 17}, "so_17458421_17474694_0": {"section_id": 2604, "quality": 0.9583333333333334, "length": 23}, "so_17458421_17458421_0": {"section_id": 2619, "quality": 0.6, "length": 6}}, "n4659": {"so_17458421_17474694_1": {"section_id": 3312, "quality": 0.9444444444444444, "length": 17}, "so_17458421_17474694_0": {"section_id": 3381, "quality": 0.9583333333333334, "length": 23}}}, "17474694": {"CommentCount": "4", "CreationDate": "2013-07-04T16:18:00.977", "CommunityOwnedDate": "2013-07-04T16:18:00.977", "LastEditorUserId": "420683", "LastActivityDate": "2013-07-05T17:28:38.317", "ParentId": "17458421", "PostTypeId": "2", "LastEditDate": "2013-07-05T17:28:38.317", "Id": "17474694", "Score": "2", "Body": "<p>I want to make a longer comment, so I'll post this as community wiki answer.</p>\n<p>The Standard (C++14 draft N3690) describes <code>system_error</code> in [syserr.syserr.overview]/1:</p>\n<blockquote>\n<p id=\"so_17458421_17474694_0\">The class <code>system_error</code> describes an exception object used to report error conditions that have an associated error code. Such error conditions typically originate from the operating system or other low-level application program interfaces.</p>\n</blockquote>\n<p>Errors and error messages originating from the <em>operating system or other low-level APIs</em> are necessarily <strong>non-portable</strong>.</p>\n<p>Furthermore, if you derive from <code>system_error</code>, someone who catches the exception by ref might expect the error codes from the OS / low level APIs as specified by the C++ implementation; at least this user knows the result of <code>what()</code> isn't guaranteed by the Standard. If this user catches an exception of your derived type, you might as well provide another <code>what2()</code> function that precisely returns your string.</p>\n<p>The solution I'd propose is <strong>not</strong> to derive from <code>system_error</code>. As far as I can see, your analysis of the guarantees (and the typo <code>code().message()</code>) is correct, i.e. you cannot precisely specify the return of <code>what()</code> for <code>system_error</code>.\nIf you want to have an error code in your exception, you could use the <code>error_code</code> facilities; yet, as with <code>system_error</code>, the Standard specifies in [syserr]/1</p>\n<blockquote>\n<p id=\"so_17458421_17474694_1\">This subclause describes components that the standard library and C ++ programs may use to report error conditions originating from the operating system or other low-level application program interfaces.</p>\n</blockquote>\n<p>Therefore, it might be better to use another error code type.</p>\n<p>As far as I can see, deriving from <code>system_error</code> is useful if you want to enhance the error message from <code>system_error</code>s originating from the OS / low-level APIs. In that case, you might want to add some description to the message (<code>what()</code>), and this is what <code>system_error</code> guarantees for the message passed to the ctor.</p>\n<hr>\n<p>Another \"comment\" to answer how you could derive from <code>system_error</code> and precisely specify the return of <code>what()</code>:</p>\n<pre><code>class my_class : public std::system_error\n{\n    std::string my_what;\npublic:\n    my_class(std::error_code ec, std::string const&amp; what_arg)\n        : system_error(ec)\n        //            ^^^^ note: NOT passing the string\n          , my_what( /* construct my what string */ )\n    { }\n    const char* what() const noexcept\n    { return my_what.c_str(); }\n};\n</code></pre>\n<p>Yes, there's data duplication in the sense that there are (probably) two string objects, but there's no data duplication of the contents of the string.\nIf you don't need to pass a string to the ctor of the exception (e.g. the type of the exception and the error code are descriptive enough), then you can even leave out the string object; something like</p>\n<pre><code>class my_class : public std::system_error\n{\npublic:\n    my_class(std::error_code ec)\n        : system_error(ec)\n        //            ^^^^ note: NOT passing the string\n    { }\n    const char* what() const noexcept\n    { return \"description of error\"; }\n};\n</code></pre>\n<p>Although it's probably better to include the error code in the description returned by <code>what()</code> (requires some sort of storage in <code>my_class</code>).</p>\n<p>It might be worthwhile to mention that construction the string <em>on demand</em> (i.e. when <code>what()</code> is called) might be favourable.</p>\n</hr>", "OwnerUserId": "420683"}});