post_cb({"24925451": {"ParentId": "24925137", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>I believe that the problem is that instantiations of</p>\n<pre><code>template&lt;class ...Args&gt;\nC(Args&amp;&amp; ... args) {std::cout &lt;&lt; \"Ctr\\n\";}  \n</code></pre>\n<p>are not copy/move constructors as far as the language is concerned and therefore calls to them cannot be elided by the compiler. From \u00a712.8 [class.copy]/p2-3, emphasis added and examples omitted:</p>\n<blockquote>\n<p id=\"so_24925137_24925451_0\">A <strong>non-template constructor</strong> for class <code>X</code> is a copy constructor if\n  its first parameter is of type <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>,\n  and either there are no other parameters or else all\n  other parameters have default arguments (8.3.6).</p>\n<p id=\"so_24925137_24925451_1\">A <strong>non-template constructor</strong> for class <code>X</code> is a move constructor if\n  its first parameter is of type <code>X&amp;&amp;</code>, <code>const X&amp;&amp;</code>, <code>volatile X&amp;&amp;</code>, or\n  <code>const volatile X&amp;&amp;</code>, and either there are no other parameters or else all\n  other parameters have default arguments (8.3.6).</p>\n</blockquote>\n<p>In other words, a constructor that is a template can never be a copy or move constructor.</p>\n<p>The return value optimization is a special case of copy elision, which is described as (\u00a712.8 [class.copy]/p31):</p>\n<blockquote>\n<p id=\"so_24925137_24925451_2\">When certain criteria are met, an implementation is allowed to omit\n  the copy/move construction of a class object, even if the constructor\n  selected for the copy/move operation and/or the destructor for the\n  object have side effects.</p>\n</blockquote>\n<p>This allows implementations to elide \"copy/move construction\"; constructing an object using something that's neither a copy constructor nor a move constructor is not \"copy/move construction\".</p>\n<p>Because <code>C</code> has a user-defined destructor, an implicit move constructor is not generated. Thus, overload resolution will select the templated constructor with <code>Args</code> deduced as <code>C</code>, which is a better match than the implicit copy constructor for rvalues. However, the compiler can't elide calls to this constructor, as it has side effects and is neither a copy constructor nor a move constructor.</p>\n<p>If the templated constructor is instead</p>\n<pre><code>template&lt;class ...Args&gt;\nC(Args ... args) {std::cout &lt;&lt; \"Ctr\\n\";} \n</code></pre>\n<p>Then it can't be instantiated with <code>Args</code> = <code>C</code> to produce a copy constructor, as that would lead to infinite recursion. There's a special rule in the standard prohibiting such constructors and  instantiations (\u00a712.8 [class.copy]/p6):</p>\n<blockquote>\n<p id=\"so_24925137_24925451_3\">A declaration of a constructor for a class <code>X</code> is ill-formed if its\n  first parameter is of type (optionally cv-qualified) <code>X</code> and either\n  there are no other parameters or else all other parameters have\n  default arguments. A member function template is never instantiated to\n  produce such a constructor signature.</p>\n</blockquote>\n<p>Thus, in that case, the only viable constructor would be the implicitly defined copy constructor, and calls to that constructor can be elided.</p>\n<p>If we instead <a href=\"http://coliru.stacked-crooked.com/a/80778e0f42acc087\" rel=\"nofollow\">remove</a> the custom destructor from <code>C</code>, and add another class to track when <code>C</code>'s destructor is called instead:</p>\n<pre><code>struct D {\n    ~D() { std::cout &lt;&lt; \"D's Dstr\\n\"; }\n};\n\ntemplate&lt;class ...ArgsIn&gt;\nstruct C {\n  template&lt;class ...Args&gt;\n  C(Args&amp;&amp; ... args) {std::cout &lt;&lt; \"Ctr\\n\";}\n  D d;\n};\n</code></pre>\n<p>We see only one call to <code>D</code>'s destructor, indicating that only one <code>C</code> object is constructed. Here <code>C</code>'s move constructor is implicitly generated and selected by overload resolution, and you see RVO kick in again.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-07-24T23:20:51.080", "Id": "24925451", "Score": "9", "CreationDate": "2014-07-24T04:59:35.270", "LastActivityDate": "2014-07-24T23:20:51.080"}, "bq_ids": {"n4140": {"so_24925137_24925451_3": {"section_id": 455, "quality": 1.0, "length": 30}, "so_24925137_24925451_2": {"section_id": 480, "quality": 1.0, "length": 22}, "so_24925137_24925451_0": {"section_id": 451, "quality": 0.96, "length": 24}, "so_24925137_24925451_1": {"section_id": 452, "quality": 0.96, "length": 24}}, "n3337": {"so_24925137_24925451_3": {"section_id": 446, "quality": 1.0, "length": 30}, "so_24925137_24925451_2": {"section_id": 471, "quality": 0.8636363636363636, "length": 19}, "so_24925137_24925451_0": {"section_id": 442, "quality": 0.96, "length": 24}, "so_24925137_24925451_1": {"section_id": 443, "quality": 0.96, "length": 24}}, "n4659": {"so_24925137_24925451_3": {"section_id": 478, "quality": 1.0, "length": 30}, "so_24925137_24925451_0": {"section_id": 474, "quality": 0.96, "length": 24}, "so_24925137_24925451_2": {"section_id": 502, "quality": 1.0, "length": 22}, "so_24925137_24925451_1": {"section_id": 475, "quality": 0.96, "length": 24}}}, "24925137": {"CommentCount": "15", "AcceptedAnswerId": "24925451", "PostTypeId": "1", "LastEditorUserId": "1559666", "CreationDate": "2014-07-24T04:27:32.527", "LastActivityDate": "2014-07-24T23:20:51.080", "LastEditDate": "2014-07-24T04:39:37.037", "ViewCount": "690", "FavoriteCount": "0", "Title": "C++ universal reference in constructor and return value optimization (rvo)", "Id": "24925137", "Score": "8", "Body": "<p>Why does rvalue optimization not occur in classes with constructor with universal reference arguments?</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/672f10c129fe29a0\">http://coliru.stacked-crooked.com/a/672f10c129fe29a0</a></p>\n<pre><code>#include &lt;iostream&gt;\n\n template&lt;class ...ArgsIn&gt;\nstruct C {\n\n  template&lt;class ...Args&gt;\n  C(Args&amp;&amp; ... args) {std::cout &lt;&lt; \"Ctr\\n\";}        // rvo occurs without &amp;&amp;\n\n  ~C(){std::cout &lt;&lt; \"Dstr\\n\";}\n};\n\ntemplate&lt;class ...Args&gt; \nauto f(Args ... args) {\n    int i = 1;\n  return C&lt;&gt;(i, i, i);\n}\n\nint main() {\n  auto obj = f();\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Ctr\nCtr\nDstr\nCtr\nDstr\nDstr\n</code></pre>\n", "Tags": "<c++><templates><rvalue-reference><rvo><universal-reference>", "OwnerUserId": "1559666", "AnswerCount": "1"}});