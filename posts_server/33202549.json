post_cb({"bq_ids": {"n4140": {"so_33202549_33202656_0": {"length": 85, "quality": 0.9883720930232558, "section_id": 6142}}, "n3337": {"so_33202549_33202656_0": {"length": 85, "quality": 0.9883720930232558, "section_id": 5906}}}, "33202656": {"LastActivityDate": "2015-10-18T20:23:51.920", "CommentCount": "0", "Body": "<p>The standard specifies in \u00a75.7/4 that:</p>\n<blockquote>\n<p id=\"so_33202549_33202656_0\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integral expression. [...] Moreover, if the expression P points to the last element of an array object, the expression (P)+1 points one past the last element of the array object, and if the expression Q points one past the last element of an array object, the expression (Q)-1 points to the last element of the array object. <strong>If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behaviour is undefined.</strong></p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>A similar quote can be found for subtraction in \u00a75.7/5. So given that overflow and underflow are special cases of pointers that exceed the bounds of object to which they originally point to, the behaviour would simply be undefined.</p>\n<p>I'd say that it's therefore possible for you to declare those functions <code>noexcept</code>.</p>\n<p>As a side note, pointer-like types in the standard library, like <code>std::unique_ptr</code>, do not define the functions that could cause the above mentioned undefined behaviour as <code>noexcept</code> (for example <code>operator[]</code> for <code>std::unique_ptr</code>) due to the fact that some implementations decide to throw an exception in debug mode.</p>\n", "CreationDate": "2015-10-18T20:06:58.990", "LastEditDate": "2015-10-18T20:23:51.920", "ParentId": "33202549", "Id": "33202656", "LastEditorUserId": "493122", "PostTypeId": "2", "Score": "5", "OwnerUserId": "493122"}, "33202549": {"CreationDate": "2015-10-18T19:57:02.273", "ViewCount": "154", "Id": "33202549", "AcceptedAnswerId": "33202656", "Score": "3", "Title": "What happens to a pointer which underflows or overflows?", "LastEditorUserId": "15168", "CommentCount": "2", "Body": "<p>I have a class that is just a raw pointer wrapper. I am wondering whether I can declare:</p>\n<ul>\n<li><code>operator++()</code></li>\n<li><code>operator--()</code></li>\n<li><code>operator++(int)</code></li>\n<li><code>operator--(int)</code></li>\n</ul>\n<p>as <code>noexcept</code>. The only reason these operators could throw is because the raw pointer would throw. So the question is: what is happening when <code>--</code> is called on a pointer that is already <code>0</code>, and what is happening when <code>++</code> is called on a pointer that is at its maximum?</p>\n", "Tags": "<c++><pointers><c++11><exception><standards>", "LastEditDate": "2015-10-18T20:08:34.627", "LastActivityDate": "2015-10-18T20:23:51.920", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "882932"}, "33202624": {"CommentCount": "0", "Body": "<p>Raw pointer arithmetic doesn't throw anything.  It'll just let you screw yourself.  So yeah, you can.</p>\n", "CreationDate": "2015-10-18T20:03:34.587", "ParentId": "33202549", "Id": "33202624", "LastActivityDate": "2015-10-18T20:03:34.587", "PostTypeId": "2", "Score": "1", "OwnerUserId": "301883"}});