post_cb({"32362904": {"CommentCount": "5", "AcceptedAnswerId": "32362968", "PostTypeId": "1", "LastEditorUserId": "3800154", "CreationDate": "2015-09-02T20:53:16.873", "LastActivityDate": "2016-01-14T00:50:54.297", "LastEditDate": "2015-09-17T12:03:37.697", "ViewCount": "761", "FavoriteCount": "4", "Title": "Static Variables Initialization Quiz", "Id": "32362904", "Score": "16", "Body": "<pre><code>#include &lt;stdio.h&gt;\n\nclass C\n{\n   public:\n          static int i;\n          static int j;\n};\n\nint i = 10;\nint C::i = 20;\nint C::j = i + 1;\n\nint main ()\n{\n    printf(\"%d\", C::j);\n\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_32362904_32362904_0\">What is the value of: C::j</p>\n</blockquote>\n<p>I was reading a c++ quiz and came across the following question. I thought that the answer is <code>11</code>.</p>\n<p><code>int C::j = i + 1;</code> </p>\n<p>Since it is accessing the non static <code>i</code> which is 10? So, I thought <code>11</code> should be the answer? </p>\n<p>I compiled and ran this code through visual studio and it prints <code>21</code>. Which is confusing to me. Can someone please explain why this is happening? What am I missing?</p>\n", "Tags": "<c++><static-members><scoping>", "OwnerUserId": "4027338", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32362904_32362968_0": {"section_id": 7109, "quality": 1.0, "length": 20}}, "n3337": {"so_32362904_32362968_0": {"section_id": 6853, "quality": 1.0, "length": 20}}, "n4659": {"so_32362904_32362968_0": {"section_id": 8610, "quality": 1.0, "length": 20}}}, "32362968": {"ParentId": "32362904", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>[basic.lookup.qual]/3</p>\n<blockquote>\n<p id=\"so_32362904_32362968_0\">In a declaration in which the <em>declarator-id</em> is a <em>qualified-id,</em> names used before the <em>qualified-id</em> being declared\n  are looked up in the defining namespace scope; names following the <em>qualified-id</em> are looked up in the scope\n  of the member\u2019s class or namespace.</p>\n</blockquote>\n<p>In</p>\n<pre><code>int C::j = i + 1;\n</code></pre>\n<p>the <em>declarator-id,</em> <em>i.e.,</em> the name of the entity being declared, is <code>C::j</code>, which is a <em>qualified-id</em>. Therefore, the <code>i</code> following it is looked up in the scope of <code>C</code>, and refers to <code>C::i</code>.</p>\n<p>Less technically, when you define a static data member, the initializer can be thought of as being in the scope of the class, and will find class members before globals.</p>\n<p>This is the same rule that ensures that when a member function is defined out-of-line, names after the name of the function will be looked up in class scope and won't require explicit qualification if they refer to class members. It is more unusual seeing this being applied to definitions of static data members, but it is perfectly consistent.</p>\n", "OwnerUserId": "481267", "LastEditorUserId": "481267", "LastEditDate": "2015-09-02T21:27:02.760", "Id": "32362968", "Score": "23", "CreationDate": "2015-09-02T20:56:33.783", "LastActivityDate": "2015-09-02T21:27:02.760"}});