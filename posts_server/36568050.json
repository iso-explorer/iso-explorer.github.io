post_cb({"36568050": {"CommentCount": "2", "AcceptedAnswerId": "36568565", "PostTypeId": "1", "LastEditorUserId": "514235", "CreationDate": "2016-04-12T08:48:01.293", "LastActivityDate": "2016-04-12T09:14:06.463", "LastEditDate": "2016-04-12T09:08:08.493", "ViewCount": "227", "FavoriteCount": "1", "Title": "SFINAE not happening with std::underlying_type", "Id": "36568050", "Score": "9", "Body": "<p>Below SFINAE code with variadic templates compiles nicely using clang 3.7.1, C++14:</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cstdint&gt;\n\nenum class Bar : uint8_t {\n    ay, bee, see\n};\n\nstruct S {\n\nstatic void foo() {}\n\n// std::begin(h) is defined for h of type H\ntemplate&lt;typename H, typename... T&gt;\nstatic typename std::enable_if&lt;std::is_pointer&lt;decltype(std::begin(std::declval&lt;H&gt;()))*&gt;::value&gt;::type \nfoo(const H&amp;, T&amp;&amp;... t) \n{ std::cout &lt;&lt; \"container\\n\"; foo(std::forward&lt;T&gt;(t)...); }\n\n// H is integral\ntemplate&lt;typename H, typename... T&gt;\nstatic typename std::enable_if&lt;std::is_integral&lt;typename std::remove_reference&lt;H&gt;::type&gt;::value&gt;::type \nfoo(const H&amp;, T&amp;&amp;... t) \n{ std::cout &lt;&lt; \"integer\\n\"; foo(std::forward&lt;T&gt;(t)...); }\n\n// H is an enum with underlying type = uint8_t\n/*\ntemplate&lt;typename H, typename... T&gt;\nstatic typename std::enable_if&lt;std::is_same&lt;typename std::underlying_type&lt;H&gt;::type,uint8_t&gt;::value&gt;::type \nfoo(const H&amp;, T&amp;&amp;... t)\n{ std::cout &lt;&lt; \"enum\\n\"; foo(std::forward&lt;T&gt;(t)...); }\n*/\n};\n\n\nint main()\n{\n    S::foo(std::array&lt;int,8&gt;(), 5, 5L, std::vector&lt;int&gt;{}, 5L);\n}\n</code></pre>\n<p>I want the correct overload of <code>foo</code> to be called recursively, based on the type <code>H</code>: </p>\n<ol>\n<li>if <code>std::begin(h)</code> is defined for an <code>h</code> of type <code>H</code>, I want the\noverload number 1 to be chosen</li>\n<li>if <code>H</code> is an \"integral type\", I want overload number 2.</li>\n</ol>\n<p>This works as it is. But if I add another overload for <em>enum</em> types (you can try to un-comment the third overload), then I get:</p>\n<blockquote>\n<p id=\"so_36568050_36568050_0\">error: only enumeration types have underlying types</p>\n</blockquote>\n<p>I agree that only <em>enums</em> got an underlying type, hence why is Not the third overload (with <code>std::underlying_type</code>) get SFINAE-d away?</p>\n", "Tags": "<c++><enums><variadic-templates><sfinae><overload-resolution>", "OwnerUserId": "2508150", "AnswerCount": "1"}, "36568565": {"ParentId": "36568050", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/types/underlying_type\"><code>std::underlying_type</code></a> is not SFINAE friendly. Attempting to access <code>std::underlying_type&lt;T&gt;::type</code> for a non-enumeration type results in undefined behavior (often a hard error), not substitution failure. </p>\n<p>You need to ascertain that the type at issue is an enumeration type first, before attempting to access its underlying type. Writing this in line would be something along the lines of <code>typename std::enable_if&lt;std::is_enum&lt;H&gt;::value, std::underlying_type&lt;H&gt;&gt;::type::type</code>. Replacing the <code>typename std::underlying_type&lt;H&gt;::type</code> in your return type with this hideous mess and you get an even more hideous mess that works :)</p>\n<p>If you find yourself needing to do this often - or just don't want to write <code>typename std::enable_if&lt;std::is_same&lt;typename std::enable_if&lt;std::is_enum&lt;H&gt;::value, std::underlying_type&lt;H&gt;&gt;::type::type, uint8_t&gt;::value&gt;::type</code> - you can write a SFINAE-friendly <code>underlying_type</code>:</p>\n<pre><code>template&lt;class T, bool = std::is_enum&lt;T&gt;::value&gt;\nstruct safe_underlying_type : std::underlying_type&lt;T&gt; {};\ntemplate&lt;class T&gt;\nstruct safe_underlying_type&lt;T, false /* is_enum */&gt; {};\n</code></pre>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2016-04-12T09:14:06.463", "Id": "36568565", "Score": "12", "CreationDate": "2016-04-12T09:07:42.807", "LastActivityDate": "2016-04-12T09:14:06.463"}, "bq_ids": {"n4140": {"so_36568050_36568050_0": {"section_id": 45, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_36568050_36568050_0": {"section_id": 42, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_36568050_36568050_0": {"section_id": 46, "quality": 0.6666666666666666, "length": 4}}}});