post_cb({"12608599": {"ParentId": "12608360", "CommentCount": "1", "Body": "<p>Forward iterators can conform the the specifications of an output iterator if they're mutable, depending on the type of the sequence. It's not explicitly spelled out (unlike the fact that they to input iterator requirements), but if we take a look at the requirements table</p>\n<p><img alt=\"Output iterator requirements\" src=\"https://i.stack.imgur.com/C01SR.jpg\"/></p>\n<p>we can go and check if a given forward iterator conforms to them:</p>\n<blockquote>\n<p id=\"so_12608360_12608599_0\"><code>*r = o</code><br>\n<code>(\u00a724.2.5/1)</code>: if <code>X</code> is a mutable iterator, <code>reference</code> is a reference to <code>T</code></br></p>\n</blockquote>\n<p>A mutable reference is assignable (unless you have a non-assignable type, obviously).</p>\n<blockquote>\n<p id=\"so_12608360_12608599_1\"><code>++r</code>, <code>r++</code>, <code>*r++ = o</code><br>\n<code>(\u00a724.2.5 Table 109)</code>\n<img alt=\"Forward iterator requirements\" src=\"https://i.stack.imgur.com/wClD7.jpg\"/></br></p>\n</blockquote>\n<p>The first line in Table 109 is the same requirement as for output iterators, except that forward iterators don't have the remark. The second line is more restrictive than for output iterators, since it specifies that a <code>reference</code> must be returned.</p>\n<p>Bottom line, <strong>if you have a mutable forward iterator into a sequence of copy-assignable types, you have a valid output iterator</strong>.</p>\n<p>(Technically, a constant iterator into a sequence of types that have a <code>operator=(...) const</code> and mutable members would also qualify, but let's hope nobody does something like that.)</p>\n", "OwnerUserId": "500104", "PostTypeId": "2", "Id": "12608599", "Score": "8", "CreationDate": "2012-09-26T19:00:56.650", "LastActivityDate": "2012-09-26T19:00:56.650"}, "12608360": {"CommentCount": "2", "ViewCount": "236", "PostTypeId": "1", "LastEditorUserId": "150634", "CreationDate": "2012-09-26T18:43:44.040", "LastActivityDate": "2012-09-26T19:11:17.813", "Title": "Is regular overwrite copy mode undefined for Container iterators?", "AcceptedAnswerId": "12608599", "LastEditDate": "2012-09-26T19:11:17.813", "Id": "12608360", "Score": "3", "Body": "<p>The following code compiles just fine, overwriting the values in <code>v2</code> with those from <code>v1</code>:</p>\n<pre><code>std::vector&lt;int&gt; v1 = {1, 2, 3, 4, 5};\nstd::vector&lt;int&gt; v2 = {6, 7, 8, 9, 10};\n\nstd::copy(v1.begin(), v1.end(), v2.begin());\n</code></pre>\n<p>The third argument of <code>std::copy</code> is an OutputIterator. However, the Container requirements specify that <code>a.begin()</code>, where <code>a</code> is a Container object, should have a return type of <code>iterator</code> which is defined as:</p>\n<blockquote>\n<p id=\"so_12608360_12608360_0\">any iterator category that meets the forward iterator requirements.</p>\n</blockquote>\n<p>Forward iterator requirements do not include the requirements of output iterators, so is the example above undefined? I'm using the iterator as an output iterator even though there's no obvious guarantee that it will be one.</p>\n<p>I'm fairly certain the above code is valid, however, so my guess is that you can infer from the details about containers that the forward iterator returned by <code>begin()</code> will in fact also support the output iterator requirements. In that case, when does <code>begin()</code> <em>not</em> return an output iterator? Only when the container is <code>const</code> or are there other situations?</p>\n", "Tags": "<c++><c++11><iterator><containers>", "OwnerUserId": "150634", "AnswerCount": "2"}, "12608431": {"ParentId": "12608360", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_12608360_12608431_0\">Forward iterator requirements do not include the requirements of output iterators</p>\n</blockquote>\n<p>This sounds backwards. OutputIterators need to satisfy <em>fewer</em> criteria than ForwardIterators.\n(Forward iterators should be reusable after increment, i.e. incrementing them twice should yield the same result).</p>\n<p>Therefore, it is ok <em>provided</em> that the output iterator <em>stays</em> valid until the algorithm completes. IOW:</p>\n<pre><code>auto outit = std::begin(v2);\nstd::advance(outit, v1.size()); // or: std::distance(std::begin(v1), std::end(v2))\n// outit should still be valid here\n</code></pre>\n<p><strong>Edit</strong> To the comment:</p>\n<blockquote>\n<h3>\u00a7 24.2.1</h3>\n<p id=\"so_12608360_12608431_1\">Iterators that further satisfy the requirements of output iterators are called <code>mutable</code> <code>iterators</code>. Nonmutable iterators are referred to as <code>constant</code> <code>iterators</code>.</p>\n</blockquote>\n<p>Now, let me find the bit that ties this together saying <code>vector::begin()</code> returns <em>mutable</em> Random Access iterator.</p>\n<p>For info</p>\n<blockquote>\n<h3>\u00a7 24.2.5 Forward iterators [forward.iterators]</h3>\n<p id=\"so_12608360_12608431_2\"><sup>1</sup> A class or pointer type X satisfies the requirements of a forward iterator if</p>\n<ul>\n<li>X satisfies the requirements of an input iterator (24.2.3),</li>\n<li>X satisfies the DefaultConstructible requirements (17.6.3.1),</li>\n<li>if X is a mutable iterator, reference is a reference to T; if X is a const iterator, reference is a reference to const T,</li>\n<li>the expressions in Table 109 are valid and have the indicated semantics, and</li>\n<li>objects of type X offer the multi-pass guarantee, described below.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "85371", "LastEditorUserId": "85371", "LastEditDate": "2012-09-26T18:59:13.717", "Id": "12608431", "Score": "4", "CreationDate": "2012-09-26T18:49:20.327", "LastActivityDate": "2012-09-26T18:59:13.717"}, "bq_ids": {"n4140": {"so_12608360_12608431_2": {"section_id": 5573, "quality": 1.0, "length": 7}, "so_12608360_12608360_0": {"section_id": 705, "quality": 1.0, "length": 6}, "so_12608360_12608431_1": {"section_id": 5558, "quality": 0.8571428571428571, "length": 12}, "so_12608360_12608431_0": {"section_id": 5557, "quality": 0.7142857142857143, "length": 5}, "so_12608360_12608599_0": {"section_id": 3844, "quality": 0.8, "length": 4}}, "n3337": {"so_12608360_12608431_2": {"section_id": 5355, "quality": 1.0, "length": 7}, "so_12608360_12608360_0": {"section_id": 695, "quality": 1.0, "length": 6}, "so_12608360_12608431_1": {"section_id": 5340, "quality": 0.8571428571428571, "length": 12}, "so_12608360_12608431_0": {"section_id": 5339, "quality": 0.7142857142857143, "length": 5}, "so_12608360_12608599_0": {"section_id": 3706, "quality": 0.8, "length": 4}}, "n4659": {"so_12608360_12608431_2": {"section_id": 7020, "quality": 1.0, "length": 7}, "so_12608360_12608360_0": {"section_id": 734, "quality": 1.0, "length": 6}, "so_12608360_12608431_0": {"section_id": 7002, "quality": 0.7142857142857143, "length": 5}, "so_12608360_12608599_0": {"section_id": 4612, "quality": 0.8, "length": 4}, "so_12608360_12608431_1": {"section_id": 7003, "quality": 0.7142857142857143, "length": 10}}}});