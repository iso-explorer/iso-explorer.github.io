post_cb({"41097868": {"CommentCount": "2", "AcceptedAnswerId": "41097958", "ClosedDate": "2016-12-12T14:21:02.170", "CreationDate": "2016-12-12T09:39:05.803", "LastActivityDate": "2016-12-12T10:38:30.007", "PostTypeId": "1", "ViewCount": "429", "FavoriteCount": "1", "Title": "Why is it possible to use the dereferencing operator multiple times when assigning a function to a function pointer?", "Id": "41097868", "Score": "7", "Body": "<p>I was wondering about the specific reason for which it is possible to use multiple times the dereferencing operator <code>*</code> when we want to assign a function to a function pointer.<br>\nAs an example, the following code perfectly compiles and runs:</br></p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid f() { std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl; }\n\nint main() {\n    void(*f_ptr)(void) = ***************************************f;\n    f_ptr();\n    return 0;\n} \n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "6920880", "AnswerCount": "3"}, "41097958": {"ParentId": "41097868", "CommentCount": "0", "Body": "<p>Functions and references to functions decay to a function pointer whenever necessary. There is no dereference operator defined for functions but there is one for function pointer: the function or reference to function happily decays to a pointer just to become derefernced again.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "41097958", "Score": "12", "CreationDate": "2016-12-12T09:45:19.220", "LastActivityDate": "2016-12-12T09:45:19.220"}, "41098916": {"ParentId": "41097868", "CommentCount": "0", "Body": "<p>On the one hand, according to the C Standard (6.3.2.1 Lvalues, arrays, and function designators)</p>\n<blockquote>\n<p id=\"so_41097868_41098916_0\">4 A function designator is an expression that has function type. Except\n  when it is the operand of the sizeof operator65) or the unary &amp;\n  operator, <strong>a function designator with type \u2018\u2018function returning type\u2019\u2019\n  is converted to an expression that has type \u2018\u2018pointer to function\n  returning type</strong>\u2019\u2019.</p>\n</blockquote>\n<p>and according to the C++ Standard (4.3 Function-to-pointer conversion)</p>\n<blockquote>\n<p id=\"so_41097868_41098916_1\">1 <strong>An lvalue of function type T can be converted to a prvalue of type\n  \u201cpointer to T.\u201d The result is a pointer to the function</strong></p>\n</blockquote>\n<p>On the other hand according to the C Standard(6.5.3.2 Address and indirection operators)</p>\n<blockquote>\n<p id=\"so_41097868_41098916_2\">4 The unary * operator denotes indirection. <strong>If the operand points to\n  a function, the result is a function designator</strong>;</p>\n</blockquote>\n<p>and the C++ Standard (5.3.1 Unary operators)</p>\n<blockquote>\n<p id=\"so_41097868_41098916_3\">1 The unary * operator performs indirection: the expression to which\n  it is applied shall be a pointer to an object type, or a pointer to a\n  function type and <strong>the result is an lvalue referring to the object or\n  function to which the expression points</strong>. If the type of the\n  expression is \u201cpointer to T,\u201d the type of the result is \u201cT.\u201d</p>\n</blockquote>\n<p>Thus there are recursive conversions.at first from the function designator to pointer and then from the pointer to the function designator (or as written in the C++ Standard to lvalue referring the function) and again from the function designator or lvalue to function pointer and so on.</p>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "41098916", "Score": "3", "CreationDate": "2016-12-12T10:38:30.007", "LastActivityDate": "2016-12-12T10:38:30.007"}, "bq_ids": {"n4140": {"so_41097868_41098916_3": {"section_id": 6064, "quality": 0.92, "length": 23}, "so_41097868_41098916_1": {"section_id": 12, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_41097868_41098916_3": {"section_id": 5832, "quality": 0.92, "length": 23}, "so_41097868_41098916_1": {"section_id": 9, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_41097868_41098916_3": {"section_id": 7560, "quality": 0.92, "length": 23}, "so_41097868_41098916_1": {"section_id": 13, "quality": 0.9166666666666666, "length": 11}}}, "41098175": {"ParentId": "41097868", "CommentCount": "5", "Body": "<p>You are initialising <code>f_ptr</code>to be a pointer to a pointer to a pointer... to a pointer. Hence you can chain as many as you like, the address of the parent pointer will simply hold the address of its child pointer. Double pointers are often used to initialise variables in a function.</p>\n", "OwnerUserId": "2141687", "PostTypeId": "2", "Id": "41098175", "Score": "-4", "CreationDate": "2016-12-12T09:57:03.573", "LastActivityDate": "2016-12-12T09:57:03.573"}});