post_cb({"2432111": {"CommentCount": "5", "AcceptedAnswerId": "2435557", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-03-12T10:45:24.907", "LastActivityDate": "2010-03-13T10:16:54.160", "LastEditDate": "2017-05-23T12:13:27.767", "ViewCount": "976", "FavoriteCount": "1", "Title": "Fundamental types", "Id": "2432111", "Score": "2", "Body": "<p>I always thought the following types are \"fundamental types\", so I thought my answer to this <a href=\"https://stackoverflow.com/questions/2144012/explicit-type-conversion-and-multiple-simple-type-specifiers\">question</a> would be correct, but surprisingly it got downvoted...</p>\n<p>Searching the web, I found <a href=\"http://publib.boulder.ibm.com/infocenter/iadthelp/v7r0/topic/com.ibm.etools.iseries.langref.doc/as400clr54.htm\" rel=\"nofollow noreferrer\">this</a>. So, IBM says as well those types are fundamental types..</p>\n<p>Well how do you interpret the Standard?  <b>Are the following types (and similar types), <i>\"fundamental types\"</i> according to the C++ standard ?</b></p>\n<pre><code>unsigned int\nsigned char\nlong double\nshort int\nunsigned short int\n</code></pre>\n<p>EDIT: <br>\nAgain related to this <a href=\"https://stackoverflow.com/questions/2144012/explicit-type-conversion-and-multiple-simple-type-specifiers\">question</a>:\nComceau and gcc dont treat types like \"long double\", \"short int\" or \"unsigned int\" as \"fundamental type\"! (whereas ibm, intel and microsoft compilers do..)\nIf they did treat such types as fundamental types, following code should compile: <code>short int i = short int()</code><br/></br></p>\n<p>EDIT:<br>\nremoved <code>long long</code> types, as i forgot they are not officially standard yet..</br></p>\n", "Tags": "<c++><types><standards>", "OwnerUserId": "231717", "AnswerCount": "4"}, "2437926": {"ParentId": "2432111", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I just took a look in the newest draft of the standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3035.pdf\" rel=\"nofollow noreferrer\">N3035</a> and it includes an additional table (\u00a77.1.6.2) which lists all valid <i>simple type specifiers</i> and shows that <code>unsigned int</code> and similar types are in fact combinations of <i>simple type specifiers</i>.</p>\n<blockquote id=\"so_2432111_2437926_0\">\n<pre><code>simple-type-specifier:\n    ::opt nested-name-specifieropt type-name\n    ::opt nested-name-specifier template simple-template-id\n    char\n    char16_t\n    char32_t\n    wchar_t\n    bool\n    short\n    int\n    long\n    signed\n    unsigned\n    float\n    double\n    void\n    auto\n    decltype ( expression )\ntype-name:\n    class-name\n    enum-name\n    typedef-name\n</code></pre>\n</blockquote>\n", "OwnerUserId": "231717", "LastEditorUserId": "231717", "LastEditDate": "2010-03-13T10:16:54.160", "Id": "2437926", "Score": "0", "CreationDate": "2010-03-13T10:02:58.733", "LastActivityDate": "2010-03-13T10:16:54.160"}, "2432126": {"ParentId": "2432111", "CommentCount": "2", "Body": "<p>Infact, unsigned/long/short are variant of the int type. So you can use any combination of those keywords together ( like unsigned short int ) ;</p>\n<p>But long long is not yet standard : it's supported by many compilers and will be standard in C++0x (the coming standard).</p>\n", "OwnerUserId": "2368", "PostTypeId": "2", "Id": "2432126", "Score": "1", "CreationDate": "2010-03-12T10:47:31.173", "LastActivityDate": "2010-03-12T10:47:31.173"}, "2432149": {"ParentId": "2432111", "CommentCount": "2", "Body": "<p><code>long long</code> is not supported by the current ISO C++03 standard. However, the C++0x draft standard does include this type:</p>\n<blockquote>\n<p id=\"so_2432111_2432149_0\"><strong>3.9.1 Fundamental types</strong></p>\n<p id=\"so_2432111_2432149_1\"><strong>2</strong> There are five standard signed integer types : \u201csigned char\u201d, \u201cshort\n  int\u201d, \u201cint\u201d, \u201clong int\u201d, and \u201clong\n  long int\u201d.</p>\n</blockquote>\n<p>ISO C99 added this particular data-type (though this was/is available on many compilers as a non-standard extension). C++03 does not fully support all C99 features. Quite a few C++ compilers do however allow this as an extension (e.g. Comeau requires <code>--long_long</code>).</p>\n", "OwnerUserId": "66692", "PostTypeId": "2", "Id": "2432149", "Score": "5", "CreationDate": "2010-03-12T10:52:39.063", "LastActivityDate": "2010-03-12T10:52:39.063"}, "bq_ids": {"n4140": {"so_2432111_2435557_0": {"section_id": 5438, "quality": 0.8, "length": 8}, "so_2432111_2432149_1": {"section_id": 7211, "quality": 1.0, "length": 15}}, "n3337": {"so_2432111_2435557_0": {"section_id": 5233, "quality": 0.9, "length": 9}, "so_2432111_2432149_1": {"section_id": 6955, "quality": 1.0, "length": 15}}, "n4659": {"so_2432111_2435557_0": {"section_id": 6865, "quality": 0.8, "length": 8}, "so_2432111_2432149_1": {"section_id": 8720, "quality": 0.9333333333333333, "length": 14}, "so_2432111_2437926_0": {"section_id": 6865, "quality": 0.6071428571428571, "length": 17}}}, "2435557": {"ParentId": "2432111", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Your logic error in your other answer was already explained by others. To let me explain to you again, given this statement:</p>\n<blockquote>\n<p id=\"so_2432111_2435557_0\">The simple-type-specifiers specify either a previously-declared user-defined type or one of the fundamental types.</p>\n</blockquote>\n<p>It does not mean that there are simple-type-specifiers for all fundamental types. It just means that each simple-type-specifier (or a combination of those - i think this sentence is not very clear) specify either a user defined type or one of the fundamental types. That statement also would apply to the following \"sample-specifiers\":</p>\n<pre><code>sample-specifier:\n  int\n  class-name\n</code></pre>\n<p>Each of my sample-specifiers specify either a previously declared user defined type, or one of the fundamental types (in my case, it's <code>int</code>). It does not mean that all previously declared user defined types can be denoted, nor does it mean that all fundamental types can be denoted. Now if another paragraph in the Standard says that <code>type()</code> works for <code>type</code> being a simple-type-specifier, that does not mean that it also must work for a combination of these. That's a totally invalid conclusion to do.</p>\n<p>It's like when i say \"decimal digits specify exclusively numbers from 0 to 9\" and you say \"you are wrong because they can't specify number 10\". But what you did was to take a combination of two digits and then claim something i've never said. I think this is a pretty clear logical fallacy you do. </p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2010-03-12T20:51:09.400", "Id": "2435557", "Score": "4", "CreationDate": "2010-03-12T20:11:36.907", "LastActivityDate": "2010-03-12T20:51:09.400"}});