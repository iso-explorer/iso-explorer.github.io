post_cb({"4690919": {"ParentId": "4690886", "LastEditDate": "2011-01-14T12:24:10.347", "CommentCount": "2", "CreationDate": "2011-01-14T12:13:19.743", "OwnerUserId": "300805", "LastEditorUserId": "300805", "PostTypeId": "2", "Id": "4690919", "Score": "2", "Body": "<p>Yes, <code>typedef</code> requires another argument. That <code>typedef</code> won't do anything.</p>\n<p>Anyway it's not an error, just a deprecate usage of <code>typedef</code>.</p>\n<hr>\n<p>C standard (n1256 in 6.7.7) talks about <code>typedef</code>. It doesn't say this usage is deprecated, but compilers report it is, since such statement has no effect.</p>\n</hr>", "LastActivityDate": "2011-01-14T12:24:10.347"}, "4690942": {"ParentId": "4690886", "CommentCount": "0", "Body": "<p>Indeed, that's not valid. You're using the keyword <code>typedef</code> to create an alias, then not specifying what the alias should be!</p>\n<p>(Strictly speaking it's deprecated, not invalid. But hey.)</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "4690942", "Score": "1", "CreationDate": "2011-01-14T12:16:52.220", "LastActivityDate": "2011-01-14T12:16:52.220"}, "4690933": {"ParentId": "4690886", "CommentCount": "3", "Body": "<p>You are most likely using very old compiler, which allows you to compile that line. Using g++ 4.3.0 (which is already fairly old), without any additional options, give this :</p>\n<pre><code>g++ dfg.cpp\ndfg.cpp:2: warning: \u2018typedef\u2019 was ignored in this declaration\n</code></pre>\n<p>So, try to compile that using a compiler which is more c++ standard compliant.</p>\n", "OwnerUserId": "476681", "PostTypeId": "2", "Id": "4690933", "Score": "2", "CreationDate": "2011-01-14T12:15:30.690", "LastActivityDate": "2011-01-14T12:15:30.690"}, "4690902": {"ParentId": "4690886", "CommentCount": "0", "Body": "<pre><code>Thank you for testing your code with Comeau C/C++!\nTell others about http://www.comeaucomputing.com/tryitout !\n\nYour Comeau C/C++ test results are as follows:\n\n\nComeau C/C++ 4.3.10.1 (Oct  6 2008 11:28:09) for ONLINE_EVALUATION_BETA2\nCopyright 1988-2008 Comeau Computing.  All rights reserved.\nMODE:strict errors C++ C++0x_extensions\n\n\"ComeauTest.c\", line 1: warning: declaration requires a typedef name\n  typedef struct C { int i; };\n                             ^\n</code></pre>\n", "OwnerUserId": "412080", "PostTypeId": "2", "Id": "4690902", "Score": "2", "CreationDate": "2011-01-14T12:11:44.437", "LastActivityDate": "2011-01-14T12:11:44.437"}, "4703247": {"ParentId": "4690886", "LastEditDate": "2011-01-16T19:20:58.497", "CommentCount": "0", "CreationDate": "2011-01-16T01:26:22.930", "OwnerUserId": "15168", "LastEditorUserId": "15168", "PostTypeId": "2", "Id": "4703247", "Score": "1", "Body": "<p>Consider the parallels between:</p>\n<pre><code>typedef struct C { int i; };\nextern  struct P { int i; };\n</code></pre>\n<p>GCC 4.2.1 with no explicit warnings enabled (<code>gcc -c xxx.c</code>) says of the first:</p>\n<pre><code>xxx.c:1: warning: useless storage class specifier in empty declaration\nxxx.c:2: warning: useless storage class specifier in empty declaration\n</code></pre>\n<p>Note that they are only warnings; they are not an error because the standard allows the notation, though it does not do very much.  In each case, the example simply declares a structure type, which can be used by the name <code>struct C</code> or <code>struct P</code>.  The storage classes are irrelevant because no object is named.  In C++, those declarations also declare types <code>C</code> and <code>P</code> (but that would also happen if the <code>typedef</code> or extern<code>was not there); in C, those types (</code>C<code>and</code>P`) are not declared.</p>\n<p>In the C standard, <code>typedef</code> is treated as a storage class, like <code>extern</code> and <code>static</code> are storage classes.  That means that the following code is legitimate:</p>\n<pre><code>typedef struct C { int i; } name1;\nextern  struct P { int i; } name2;\n</code></pre>\n<p>It declares the same two structure types as before, but now the <code>typedef</code> declares an alias for <code>struct C</code> which is <code>name1</code>, and the <code>extern</code> line states that another translation unit (TU) defines a variable called <code>name2</code> of the type <code>struct P</code>.  Neither is vacuous (except that the definitions are not used later in the 2-line TU shown).</p>\n<p>The C standard allows many weird things.  For example:</p>\n<pre><code>int unsigned typedef u;\n</code></pre>\n<p>It's a perfectly valid - but totally abnormal - way of writing:</p>\n<pre><code>typedef unsigned int u;\n</code></pre>\n<p>There is a section in C99 \u00a76.11.5 (under Future Language Directions) which says:</p>\n<blockquote>\n<p id=\"so_4690886_4703247_0\">6.11.5 Storage-class specifiers</p>\n<p id=\"so_4690886_4703247_1\">The placement of a storage-class specifier other than at the beginning of the declaration\n  specifiers in a declaration is an obsolescent feature.</p>\n</blockquote>\n<p>That makes my weird example in violation of \u00a76.11.5.</p>\n<h3>Summary</h3>\n<ul>\n<li>The code reviewed is syntactically correct in C, both C89 and C99.</li>\n<li>It is also, AFAIK, syntactically valid in C++ - but it is even more pointless there than in C since <code>struct C { int i; };</code> with no typedef introduces the type C (as well as <code>struct C</code>).</li>\n<li>The code reviewed should not be accepted - it is reasonable to require it to be fixed.</li>\n</ul>\n<p>The correct fix might be to remove the storage class (<code>typedef</code>), or it might be to introduce a name as an alias for <code>struct C</code>.  Since the code compiles without the alias, it is more likely correct to remove the storage class.</p>\n", "LastActivityDate": "2011-01-16T19:20:58.497"}, "4690944": {"ParentId": "4690886", "CommentCount": "2", "Body": "<p>A quick glance over n3225 doesn't show any requirement that a name is required to be present. The text that comes the most near just says</p>\n<blockquote>\n<p id=\"so_4690886_4690944_0\">In a simple-declaration, the optional init-declarator-list can be omitted only when declaring a class (clause 9) or enumeration (7.2), that is, when the decl-specifier-seq contains either a class-specifier, an elaborated- type-specifier with a class-key (9.1), or an enum-specifier. </p>\n</blockquote>\n<p>So your code seems to be valid, but I think it smells bad. </p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "4690944", "Score": "5", "CreationDate": "2011-01-14T12:17:18.850", "LastActivityDate": "2011-01-14T12:17:18.850"}, "bq_ids": {"n4140": {"so_4690886_4690944_0": {"section_id": 5381, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_4690886_4690944_0": {"section_id": 5175, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_4690886_4690944_0": {"section_id": 6805, "quality": 0.8421052631578947, "length": 16}}}, "4690886": {"CommentCount": "3", "ViewCount": "1930", "CreationDate": "2011-01-14T12:09:47.677", "LastActivityDate": "2011-01-16T19:20:58.497", "Title": "is the `synonym` in a `typedef` mandatory?", "AcceptedAnswerId": "4690919", "PostTypeId": "1", "Id": "4690886", "Score": "8", "Body": "<p>I encountered this in a code review:</p>\n<pre><code>typedef struct C { int i; };\n</code></pre>\n<p>It compiles.</p>\n<p>Apart from it being C-style, where structs are in a separate 'namespace', and need to be typedeffed in order to use later on, I found it weird that there is nothing defined with this typedef...</p>\n<p>So: doesn't <code>typedef</code> require a type argument and an alias argument?</p>\n", "Tags": "<c++><syntax><typedef>", "OwnerUserId": "6610", "AnswerCount": "6"}});