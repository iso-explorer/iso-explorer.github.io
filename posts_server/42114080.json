post_cb({"bq_ids": {"n4140": {"so_42114080_42114080_0": {"section_id": 6325, "quality": 0.8615384615384616, "length": 56}}, "n3337": {"so_42114080_42114080_0": {"section_id": 6082, "quality": 0.8615384615384616, "length": 56}}, "n4659": {"so_42114080_42114080_0": {"section_id": 7835, "quality": 0.8769230769230769, "length": 57}}}, "42114080": {"CommentCount": "3", "ViewCount": "95", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2017-02-08T13:09:50.487", "LastActivityDate": "2017-02-10T08:04:14.953", "Title": "How to force rvalue reference to be \"restricted\" alias?", "FavoriteCount": "1", "LastEditDate": "2017-02-10T08:04:14.953", "Id": "42114080", "Score": "3", "Body": "<p>In the C++ standard (N4618, $17.5.4.9, [res.on.argument], (1.3)) it is said that implementation are free not to perform aliasing check on rvalue reference:</p>\n<blockquote>\n<p id=\"so_42114080_42114080_0\">If a function argument binds to an rvalue reference parameter, the implementation may assume that\n  this parameter is a unique reference to this argument. [\n  Note:\n  If the parameter is a generic parameter\n  of the form\n  T&amp;&amp;\n  and an lvalue of type\n  A\n  is bound, the argument binds to an lvalue reference (14.8.2.1)\n  and thus is not covered by the previous sentence.\n  \u2014 end note\n  ] [\n  Note:\n  If a program casts an lvalue to\n  an xvalue while passing that lvalue to a library function (e.g. by calling the function with the argument\n  std::move(x)\n  ), the program is effectively asking that function to treat that lvalue as a temporary.\n  The implementation is free to optimize away aliasing checks which might be needed if the argument\n  was an lvalue.\n  \u2014 end note\n  ]</p>\n</blockquote>\n<p>I would like such an assumption to be applied to an entire translation unit. For example, the function <code>f</code>:</p>\n<pre><code> class A{\n    int a;\n      //....\n };\n int f(A&amp;&amp; r1,A&amp;&amp; r2){\n   r1.a=10;\n   r2.a=3;\n   return r1.a;\n }\n</code></pre>\n<p>Produces the following assembly:</p>\n<pre><code>    movl    $10, (%rdi)\n    movl    $3, (%rsi)\n    movl    (%rdi), %eax\n    retq\n</code></pre>\n<p>Where the return value is a load of <code>r1.a</code>, because the compiler take into account that <code>f</code> might be called this way: <code>f(move(an_A),move(an_A))</code></p>\n<p>Now if I declare one of the parameter as restricted:</p>\n<pre><code>int f(A&amp;&amp; __restrict__ r1,A&amp;&amp; r2){\n   r1.a=10;\n   r2.a=3;\n   return r1.a;\n }\n</code></pre>\n<p>We get the following assembly:</p>\n<pre><code>    movl    $10, (%rdi)\n    movl    $3, (%rsi)\n    movl    $10, %eax\n    retq\n</code></pre>\n<p>In this case we say to the compiler to assumes that the parameter <code>r1</code> and <code>r2</code> are never bounded to the same object. So it returns directly the value stored in <code>a.a</code>.</p>\n<p>This is exactly the kind of optimization that is allowed by the C++ standard for any library function taking rvalue reference parameters.</p>\n<p>I believe that in most (if not all) real case program, a call like <code>f(move(an_A),move(an_A))</code> will certainly cause \"undocumented behavior\" because as a programmer I will never expect a user to pass two rvalue reference arguments both bounded to the same object.</p>\n<p>So I have few questions:</p>\n<ol>\n<li>Is their real case where a call like <code>f(move(an_A),move(an_A))</code> happens, so that when implementing <code>f</code> the programmer had to take care of this call case?</li>\n<li>If no, why compiler does not make the assumption that all rvalue reference parameters are \"restricted\"?</li>\n<li>Is their any optimization option to force the compiler to assumes that all rvalue reference parameters are \"restricted\"?</li>\n</ol>\n", "Tags": "<c++><move-semantics><rvalue-reference><strict-aliasing>", "OwnerUserId": "5632316", "AnswerCount": "0"}});