post_cb({"5719636": {"CommentCount": "6", "AcceptedAnswerId": "6180198", "PostTypeId": "1", "LastEditorUserId": "6210", "CreationDate": "2011-04-19T16:31:34.527", "LastActivityDate": "2011-05-30T19:43:07.657", "LastEditDate": "2011-04-20T22:22:09.087", "ViewCount": "505", "FavoriteCount": "2", "Title": "Lifetime of temporary bound to aggregate initialized struct member", "Id": "5719636", "Score": "12", "Body": "<p>Given the following code:</p>\n<pre><code>class foo\n{\n};\n\nclass bar: public foo\n{\npublic: \n    ~bar() { printf(\"~bar()\\n\"); }\n};\n\nclass zab: public foo\n{\npublic: \n    ~zab() { printf(\"~zab()\\n\"); }\n};\n\nstruct foo_holder\n{\n    const foo &amp;f;\n};\n\nint main()\n{\n    foo_holder holder[]= { {bar()}, {zab()} };\n    printf(\"done!\\n\");\n    return 0;\n}\n</code></pre>\n<p>the output is:</p>\n<pre><code>~bar()\n~zab()\ndone!\n</code></pre>\n<p>C++0x has a clause that dictates this can create dangling references when used as a new initializer, but it says nothing (at least nothing I can find) about aggregate initialization of const references with temporaries.</p>\n<p>Is this unspecified behavior then?</p>\n", "Tags": "<c++><reference><struct><lifetime>", "OwnerUserId": "6210", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_5719636_5730378_1": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_5719636_5730378_0": {"section_id": 7188, "quality": 0.9230769230769231, "length": 12}, "so_5719636_5730378_2": {"section_id": 7189, "quality": 0.875, "length": 7}, "so_5719636_5730378_3": {"section_id": 7189, "quality": 1.0, "length": 5}, "so_5719636_5730378_4": {"section_id": 3221, "quality": 1.0, "length": 5}}, "n3337": {"so_5719636_5730378_4": {"section_id": 3095, "quality": 1.0, "length": 5}, "so_5719636_5730378_0": {"section_id": 6932, "quality": 0.9230769230769231, "length": 12}, "so_5719636_5730378_2": {"section_id": 6933, "quality": 0.875, "length": 7}, "so_5719636_5730378_1": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_5719636_5730378_3": {"section_id": 6933, "quality": 1.0, "length": 5}}, "n4659": {"so_5719636_5730378_4": {"section_id": 3978, "quality": 1.0, "length": 5}, "so_5719636_5730378_2": {"section_id": 8697, "quality": 0.875, "length": 7}, "so_5719636_5730378_3": {"section_id": 8701, "quality": 1.0, "length": 5}, "so_5719636_5730378_1": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}}}, "6180198": {"ParentId": "5719636", "CommentCount": "1", "Body": "<p>I got an answer on comp.std.c++:</p>\n<p><a href=\"http://groups.google.com/group/comp.std.c++/msg/9e779c0154d2f21b\" rel=\"nofollow\">http://groups.google.com/group/comp.std.c++/msg/9e779c0154d2f21b</a></p>\n<p>Basically, the standard does not explicitly address it; therefore, it should behave the same as a reference declared locally.</p>\n", "OwnerUserId": "6210", "PostTypeId": "2", "Id": "6180198", "Score": "1", "CreationDate": "2011-05-30T19:43:07.657", "LastActivityDate": "2011-05-30T19:43:07.657"}, "5730378": {"ParentId": "5719636", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It isn't mentioned in the list of exceptions, therefore the lifetime to temporary should be extended to match lifetime of (array of) <code>foo_holder</code>s. However, this looks like oversight to me, perhaps submitting Defect Report might be good idea.</p>\n<hr>\n<p>\u00a712.2/5 states, that when reference is bound to a temporary, the lifetime of temporary is extended to match lifetime of the reference and because <code>const foo&amp; f</code> is member of <code>foo_holder</code>, the lifetime of the reference is matching lifetime of <code>foo_holder</code>, according to \u00a73.7.5/1: </p>\n<blockquote>\n<p id=\"so_5719636_5730378_0\">The storage duration of member subobjects, base class subobjects and array elements is that of their complete object (1.8).</p>\n</blockquote>\n<p>This might be little bit tricky to interpret considering references, because \u00a73.8/1 states, that lifetime of object ends when the storage is released or reused:</p>\n<blockquote>\n<p id=\"so_5719636_5730378_1\">The lifetime of an object of type T ends when:</p>\n<p id=\"so_5719636_5730378_2\">\u2014 if T is a class type with a non-trivial destructor (12.4), the destructor call starts, or</p>\n<p id=\"so_5719636_5730378_3\">\u2014 the storage which the object occupies is reused or released.</p>\n</blockquote>\n<p>however, it is left unspecified whether references use storage or not; \u00a78.3.2/4 says</p>\n<blockquote>\n<p id=\"so_5719636_5730378_4\">It is unspecified whether or not a reference requires storage (3.7).</p>\n</blockquote>\n<p>Perhaps someone with better knowledge of standard would know this better.</p>\n</hr>", "OwnerUserId": "700253", "LastEditorUserId": "700253", "LastEditDate": "2011-04-20T17:31:07.857", "Id": "5730378", "Score": "1", "CreationDate": "2011-04-20T12:35:45.123", "LastActivityDate": "2011-04-20T17:31:07.857"}});