post_cb({"12512961": {"ViewCount": "363", "Body": "<p>This is a follow-up to <a href=\"https://stackoverflow.com/q/12472556/57428\">this question</a>. Suppose I have this code:</p>\n<pre><code>class Class {\n    public virtual method()\n    {\n        this-&gt;~Class();\n        new( this ) Class();\n    }\n};\n\nClass* object = new Class();\nobject-&gt;method();\ndelete object;\n</code></pre>\n<p>which is a simplified version of what <a href=\"https://stackoverflow.com/a/12472665/57428\">this answer</a> suggests.</p>\n<p>Now once a destructor is invoked from within <code>method()</code> the object lifetime ends and the pointer variable <code>object</code> in the calling code becomes invalid. Then the new object gets created at the same location.</p>\n<p>Does this make the pointer to the object in the calling valid again?</p>\n", "AcceptedAnswerId": "12513772", "Title": "Does destroying and recreating an object make all pointers to this object invalid?", "CreationDate": "2012-09-20T12:48:34.417", "Id": "12512961", "CommentCount": "8", "LastEditDate": "2017-05-23T10:26:50.747", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2012-09-20T13:33:43.380", "Score": "7", "OwnerUserId": "57428", "Tags": "<c++><pointers><destructor><object-lifetime>", "AnswerCount": "6"}, "12513038": {"Id": "12513038", "PostTypeId": "2", "Body": "<p>Strictly, this is fine. However, without <em>extreme</em> care, it will become a hideous piece of UB. For example, any derived classes calling this method won't get the right type re-constructed- or what happens if <code>Class()</code> throws an exception. Furthermore, this doesn't really accomplish anything.</p>\n<p>It's not strictly UB, but is a giant pile of crap and fail and should be burned on sight.</p>\n", "LastActivityDate": "2012-09-20T12:53:47.923", "CommentCount": "2", "CreationDate": "2012-09-20T12:53:47.923", "ParentId": "12512961", "Score": "4", "OwnerUserId": "298661"}, "12513772": {"Id": "12513772", "PostTypeId": "2", "Body": "<p>This is explicitly approved in 3.8:7:</p>\n<blockquote>\n<h3>3.8 Object lifetime [basic.life]</h3>\n<p id=\"so_12512961_12513772_0\">7 - If, after the lifetime of an object has ended [...], a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object [...] can be used to manipulate the new object, if: <em>(various requirements which are satisfied in this case)</em></p>\n</blockquote>\n<p>The example given is:</p>\n<pre><code>struct C {\n  int i;\n  void f();\n  const C&amp; operator=( const C&amp; );\n};\nconst C&amp; C::operator=( const C&amp; other) {\n  if ( this != &amp;other ) {\n    this-&gt;~C(); // lifetime of *this ends\n    new (this) C(other); // new object of type C created\n    f(); // well-defined\n  }\n  return *this;\n}\n</code></pre>\n", "LastActivityDate": "2012-09-20T13:33:43.380", "CommentCount": "2", "CreationDate": "2012-09-20T13:33:43.380", "ParentId": "12512961", "Score": "7", "OwnerUserId": "567292"}, "12513146": {"Id": "12513146", "PostTypeId": "2", "Body": "<p>Creating a new object at the location of a destroyed one does not make any pointers valid again. They may point to a valid new object, but not the object you were originally referencing.</p>\n<p>You should guarantee that all references were removed or somehow marked as invalid before destroying the original object.</p>\n<p>This would be a particularly difficult situation to debug.</p>\n", "LastActivityDate": "2012-09-20T12:58:57.560", "CommentCount": "4", "CreationDate": "2012-09-20T12:58:57.560", "ParentId": "12512961", "Score": "-2", "OwnerUserId": "243643"}, "bq_ids": {"n4140": {"so_12512961_12513772_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 7195}, "so_12512961_12513118_0": {"length": 43, "quality": 1.0, "section_id": 7195}}, "n3337": {"so_12512961_12513772_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 6939}, "so_12512961_12513118_0": {"length": 43, "quality": 1.0, "section_id": 6939}}, "n4659": {"so_12512961_12513772_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 8704}, "so_12512961_12513118_0": {"length": 43, "quality": 1.0, "section_id": 8704}}}, "12513724": {"Id": "12513724", "PostTypeId": "2", "Body": "<p>You may want to reconsider explicitly calling the destructor.  If there's code you want executed that happens to be in the destructor, move that code to a new method and call that method from the destructor to preserve the current functionality.  The destructor is really meant to be used for objects going out of scope.</p>\n", "OwnerDisplayName": "user1653241", "LastActivityDate": "2012-09-20T13:30:50.397", "Score": "0", "CreationDate": "2012-09-20T13:30:50.397", "ParentId": "12512961", "CommentCount": "0"}, "12513118": {"Id": "12513118", "PostTypeId": "2", "Body": "<p>The <code>object</code> pointer doesn't become invalid at any time (assuming your destructor doesn't call <code>delete this</code>). Your object was never deallocated, it has only called it's destructor, i.e. it has cleaned up its internal state (with regard to implementation, please note that standard strictly defines that the object is destroyed after destructor call). As you have used placement new to instantiate the new object at the exactly same address, it is technically ok. </p>\n<p>This exact scenario is covered by section 3.8.7 of C++ standard:</p>\n<blockquote>\n<p id=\"so_12512961_12513118_0\">If, after the lifetime of an object has ended and before the storage\n  which the object occupied is reused or released, a new object is\n  created at the storage location which the original object occupied, a\n  pointer that pointed to the original object, a reference that referred\n  to the original object, or the name of the original object will\n  automatically refer to the new object and, once the lifetime of the\n  new object has started, can be used to manipulate the new object [...]</p>\n</blockquote>\n<p>That said, this is interesting only as learning code, as production code, this is horrible :)</p>\n", "LastEditorUserId": "1663919", "LastActivityDate": "2012-09-20T13:30:47.777", "Score": "4", "CreationDate": "2012-09-20T12:57:26.387", "ParentId": "12512961", "CommentCount": "2", "OwnerUserId": "1663919", "LastEditDate": "2012-09-20T13:30:47.777"}, "12513067": {"Id": "12513067", "PostTypeId": "2", "Body": "<p>The pointer only knows its address and as soon as you can confirm that the address of the new object is the one the pointer is pointing to, the answer is yes.</p>\n<p>There are some cases where people would believe the address does not change, but in some cases it does change, e.g. when using C's <code>realloc()</code>. But that's another story.</p>\n", "LastActivityDate": "2012-09-20T12:55:00.967", "CommentCount": "2", "CreationDate": "2012-09-20T12:55:00.967", "ParentId": "12512961", "Score": "0", "OwnerUserId": "21974"}});