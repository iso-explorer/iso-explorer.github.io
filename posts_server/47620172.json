post_cb({"47621004": {"Id": "47621004", "PostTypeId": "2", "Body": "<p>In short, the lifetime of a temporary object is <strong>normally</strong> <strong>not</strong> extended if it <strong>has been previously materialized</strong> when a reference is bound to it (i.e. the materialization is not caused by this reference bounding). </p>\n<p>In the first case, the temporary object is materialized from <code>f1(A())</code> (as @BoPersson said, this is a different temporary object from that materialized from <code>A()</code>) when <code>r</code> is bound to it, so its lifetime is the same as <code>r</code>. In the second case, when <code>r</code> is bound to the temporary object, it has been previously materialized from <code>A()</code>, so its lifetime is not extended.</p>\n<p>Strictly speaking, consider <a href=\"http://www.eel.is/c++draft/class.temporary#6\" rel=\"nofollow noreferrer\">[class.temporary]/6</a>:</p>\n<blockquote>\n<p id=\"so_47620172_47621004_0\">The third context is when a reference is bound to a temporary object. The temporary object to which the reference is bound or the temporary object that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference if the glvalue to which the reference is bound was obtained through one of the following:</p>\n<ul>\n<li>a temporary materialization conversion ([conv.rval]),</li>\n<li>( expression ), where expression is one of these expressions,</li>\n<li>subscripting ([expr.sub]) of an array operand, where that operand is one of these expressions,</li>\n<li>a class member access ([expr.ref]) using the . operator where the left operand is one of these expressions and the right operand designates a non-static data member of non-reference type,</li>\n<li>a pointer-to-member operation ([expr.mptr.oper]) using the .* operator where the left operand is one of these expressions and the right operand is a pointer to data member of non-reference type,</li>\n<li><p id=\"so_47620172_47621004_1\">a </p>\n<ul>\n<li>const_\u00adcast ([expr.const.cast]),</li>\n<li>static_\u00adcast ([expr.static.cast]),</li>\n<li>dynamic_\u00adcast ([expr.dynamic.cast]), or</li>\n<li>reinterpret_\u00adcast ([expr.reinterpret.cast])</li>\n</ul>\n<p id=\"so_47620172_47621004_2\">converting, without a user-defined conversion, a glvalue operand that is one of these expressions to a glvalue that refers to the object designated by the operand, or to its complete object or a subobject thereof,</p></li>\n<li>a conditional expression ([expr.cond]) that is a glvalue where the second or third operand is one of these expressions, or</li>\n<li>a comma expression ([expr.comma]) that is a glvalue where the right operand is one of these expressions.</li>\n</ul>\n</blockquote>\n<p>In the first case, the glvalue to which <code>r</code> is bound is obtained through a temporary materialization conversion from the prvalue <code>f1(A())</code>, so its lifetime is the same as <code>r</code>. In the second case, the glvalue to which <code>r</code> is bound is <code>f2(A())</code> (note <code>f2(A())</code> is an lvalue, so this time no temporary materialization conversion occurs), where none of the cases listed in the quoted paragraph applies, so its lifetime is not extended. </p>\n<p>Note I use the word <strong>normally</strong> in the beginning of this answer. The cases listed in the above quoted paragraph, except the \"temporary materialization conversion\" case, are all exceptions.</p>\n", "LastActivityDate": "2017-12-03T17:16:16.483", "Score": "2", "CreationDate": "2017-12-03T17:16:16.483", "ParentId": "47620172", "CommentCount": "0", "OwnerUserId": "5376789"}, "bq_ids": {"n4140": {"so_47620172_47621004_0": {"length": 20, "quality": 0.6451612903225806, "section_id": 382}}, "n3337": {"so_47620172_47621004_0": {"length": 19, "quality": 0.6129032258064516, "section_id": 373}}, "n4659": {"so_47620172_47621004_0": {"length": 20, "quality": 0.6451612903225806, "section_id": 397}}}, "47620172": {"ViewCount": "64", "Body": "<p>Consider</p>\n<pre><code>struct A {\n   ~A() {std::cout &lt;&lt; \"A's dtor called\\n\";}\n};\n\nA f1(const A&amp; a) \n{\n   return a;\n}\n\nint main()\n{\n   {\n      const A&amp; r = f1(A());\n      std::cout &lt;&lt; \"XXX\\n\";\n   }\n   std::cout &lt;&lt; \"YYY\\n\";\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>A's dtor called\nXXX\nA's dtor called\nYYY\n</code></pre>\n<p>Now let</p>\n<pre><code>const A&amp; f2(const A&amp; a) \n{\n   return a;\n}\n</code></pre>\n<p>and consider the output of the same main-function except that <code>f1</code> is replaced with <code>f2</code>:</p>\n<p>Output this time:</p>\n<pre><code>A's dtor called\nXXX\nYYY\n</code></pre>\n<p>Why is that? Shouldn't - in the second case - the temporary <code>A()</code> that is passed through <code>f2</code> \"live\" until the <em>entire</em> expression <code>const A&amp; r = f2(A())</code> has been executed? In that case I'd expect that the lifetime of the temporary should be extended until <code>r</code> dies (as in the first case), but it dies already before <code>cout &lt;&lt; \"XXX\"</code> gets executed. Or is the initialization of <code>r</code> not part of the expression into which the evaluation of <code>f2</code> is involved, so that <code>A()</code> is already dead before it can be bound to <code>r</code>?</p>\n", "AcceptedAnswerId": "47621004", "Title": "C++11 - is initialization of a reference not (part of) an expression?", "CreationDate": "2017-12-03T15:55:26.613", "LastActivityDate": "2017-12-04T00:24:58.317", "CommentCount": "0", "LastEditDate": "2017-12-03T15:58:44.840", "PostTypeId": "1", "LastEditorUserId": "4672588", "Id": "47620172", "Score": "2", "OwnerUserId": "3953148", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "47620441": {"Id": "47620441", "PostTypeId": "2", "Body": "<p>The temporary <code>A()</code> is bound to the parameter <code>a</code> in the function call. The lifetime extension is not transferred by passing it on to some other reference.</p>\n<p>In the first case <em>another</em> temporary is created for the return value, as we can perhaps understand from the second destructor call.</p>\n", "LastEditorUserId": "597607", "LastActivityDate": "2017-12-04T00:24:58.317", "Score": "2", "CreationDate": "2017-12-03T16:21:13.547", "ParentId": "47620172", "CommentCount": "0", "OwnerUserId": "597607", "LastEditDate": "2017-12-04T00:24:58.317"}});