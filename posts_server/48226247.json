post_cb({"48226247": {"ViewCount": "1151", "Body": "<p>I cannot figure out why in the last case is the <strong>move constructor called when copy elision is enabled</strong> (or even mandatory such as in C++17):</p>\n<pre><code>class X {\n  public:\n    X(int i) { std::clog &lt;&lt; \"converting\\n\"; }\n    X(const X &amp;) { std::clog &lt;&lt; \"copy\\n\"; }\n    X(X &amp;&amp;) { std::clog &lt;&lt; \"move\\n\"; }\n};\n\ntemplate &lt;typename T&gt;\nX make_X(T&amp;&amp; arg) {\n  return X(std::forward&lt;T&gt;(arg));\n}\n\nint main() {\n  auto x1 = make_X(1);    // 1x converting ctor invoked\n  auto x2 = X(X(1));      // 1x converting ctor invoked\n  auto x3 = make_X(X(1)); // 1x converting and 1x move ctor invoked\n}\n</code></pre>\n<p>What rules hinder the move constructor to be elided in this case?</p>\n<p><strong>UPDATE</strong></p>\n<p>Maybe more straightforward cases when move constructors are called:</p>\n<pre><code>X x4 = std::forward&lt;X&gt;(X(1));\nX x5 = static_cast&lt;X&amp;&amp;&gt;(X(1));\n</code></pre>\n", "AcceptedAnswerId": "48227942", "Title": "Why isn't move constructor elided whenever possible with `make_x()` functions?", "CreationDate": "2018-01-12T12:23:40.020", "LastActivityDate": "2018-01-12T20:36:42.680", "CommentCount": "13", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2018-01-12T20:36:42.680", "LastEditorUserId": "1593077", "Id": "48226247", "Score": "20", "OwnerUserId": "580083", "Tags": "<c++><language-lawyer><move-semantics><perfect-forwarding><copy-elision>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_48226247_48227536_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 3296}, "so_48226247_48227270_1": {"length": 35, "quality": 1.0, "section_id": 480}, "so_48226247_48227536_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 480}, "so_48226247_48227536_3": {"length": 8, "quality": 0.6666666666666666, "section_id": 5451}, "so_48226247_48227270_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 480}, "so_48226247_48227270_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 480}}, "n3337": {"so_48226247_48227536_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 3166}, "so_48226247_48227270_1": {"length": 35, "quality": 1.0, "section_id": 471}, "so_48226247_48227536_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 471}, "so_48226247_48227270_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 471}, "so_48226247_48227270_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 471}, "so_48226247_48227536_3": {"length": 8, "quality": 0.6666666666666666, "section_id": 5541}}, "n4659": {"so_48226247_48227270_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 502}, "so_48226247_48227536_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 4058}, "so_48226247_48227270_1": {"length": 31, "quality": 0.8857142857142857, "section_id": 502}, "so_48226247_48227270_2": {"length": 17, "quality": 0.6296296296296297, "section_id": 502}, "so_48226247_48227536_3": {"length": 9, "quality": 0.75, "section_id": 4799}}}, "48227270": {"Id": "48227270", "PostTypeId": "2", "Body": "<p>Because in the expression <code>X(std::forward&lt;T&gt;(arg))</code>, even if, in the last case, <code>arg</code> is a reference bound to a temporary, it is still not a temporary. Inside the function body, the compiler cannot ensure that <code>arg</code> is not bound to an lvalue. Consider what would happen if the move constructor was elided and you would perform this call:</p>\n<pre><code>auto x4 = make_X(std::move(x2));\n</code></pre>\n<p><code>x4</code> would become an alias for <code>x2</code>.</p>\n<p>The rules for move elision of the return value is described in <a href=\"https://timsong-cpp.github.io/cppwp/n3337/class.copy#31\" rel=\"nofollow noreferrer\">[class.copy]/32</a>:</p>\n<blockquote>\n<p id=\"so_48226247_48227270_0\">[...]This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<ul>\n<li><p id=\"so_48226247_48227270_1\">in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function's return value</p></li>\n<li><p id=\"so_48226247_48227270_2\">when a temporary class object that has not been bound to a reference ([class.temporary]) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move</p></li>\n</ul>\n</blockquote>\n<p>In the call <code>make_X(X(1))</code> copy elision actualy happens, but only once:</p>\n<ol>\n<li>First X(1) creates a temporary that is bound to <code>arg</code>.</li>\n<li>Then <code>X(std::forward&lt;T&gt;(arg))</code> invokes the move constructor. <code>arg</code> is not a temporary so the second rule above does not apply.</li>\n<li>Then the result the expression <code>X(std::forward&lt;T&gt;(arg))</code> should also be moved to construct the return value but this move is elided.</li>\n</ol>\n<hr>\n<p>About your UPDATE, <code>std::forward</code> cause materialisation of the temporary <code>X(1)</code> that is bound to an xvalue: the return of <code>std::forward</code>. This returned xvalue is not a temporary so copy/elision is not anymore applicable.</p>\n<p>Again what would happen in this case if move elision occured. (The c++ grammar is not contextual):</p>\n<pre><code>auto x7 = std::forward&lt;X&gt;(std::move(x2));\n</code></pre>\n<hr>\n<p>Nota: After I have seen a new answer about C++17 I wanted to add to confusion.</p>\n<p>In C++17, the definition of <code>prvalue</code> is that changed that there are not any more any move constructor to elide inside your example code. Here example of <a href=\"https://godbolt.org/g/AigACV\" rel=\"nofollow noreferrer\">result code</a> of GCC with the option <code>fno-elide-constructors</code> in C++14 and then in C++17:</p>\n<pre><code>#c++ -std=c++14 -fno-elide-constructors | #c++ -std=c++17 -fno-elide-constructors\nmain:                                   | main:\n  sub rsp, 24                           |   sub rsp, 24\n  mov esi, 1                            |   mov esi, 1\n  lea rdi, [rsp+15]                     |   lea rdi, [rsp+12]\n  call X::X(int)                        |   call X::X(int)\n  lea rsi, [rsp+15]                     |   lea rdi, [rsp+13]\n  lea rdi, [rsp+14]                     |   mov esi, 1\n  call X::X(X&amp;&amp;)                        |   call X::X(int)\n  lea rsi, [rsp+14]                     |   lea rdi, [rsp+15]\n  lea rdi, [rsp+11]                     |   mov esi, 1\n  call X::X(X&amp;&amp;)                        |   call X::X(int)\n  lea rdi, [rsp+14]                     |   lea rsi, [rsp+15]\n  mov esi, 1                            |   lea rdi, [rsp+14]\n  call X::X(int)                        |   call X::X(X&amp;&amp;)\n  lea rsi, [rsp+14]                     |   xor eax, eax\n  lea rdi, [rsp+15]                     |   add rsp, 24\n  call X::X(X&amp;&amp;)                        |   ret               \n  lea rsi, [rsp+15]\n  lea rdi, [rsp+12]\n  call X::X(X&amp;&amp;)\n  lea rdi, [rsp+13]\n  mov esi, 1\n  call X::X(int)\n  lea rsi, [rsp+13]\n  lea rdi, [rsp+15]\n  call X::X(X&amp;&amp;)\n  lea rsi, [rsp+15]\n  lea rdi, [rsp+14]\n  call X::X(X&amp;&amp;)\n  lea rsi, [rsp+14]\n  lea rdi, [rsp+15]\n  call X::X(X&amp;&amp;)\n  xor eax, eax\n  add rsp, 24\n  ret\n</code></pre>\n</hr></hr>", "LastEditorUserId": "5632316", "LastActivityDate": "2018-01-12T19:38:32.317", "Score": "5", "CreationDate": "2018-01-12T13:28:11.993", "ParentId": "48226247", "CommentCount": "1", "OwnerUserId": "5632316", "LastEditDate": "2018-01-12T19:38:32.317"}, "48227536": {"Id": "48227536", "PostTypeId": "2", "Body": "<p>To simplify your example:</p>\n<pre><code>auto x1 = make_X(1);                // converting\nauto x2 = X(X(1));                  // converting\nauto x4 = X(std::forward&lt;X&gt;(X(1))); // converting + move\n</code></pre>\n<p>From the cppreference's <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow noreferrer\">copy elision documentation</a> (emphasis mine):</p>\n<p><strong>Before c++17:</strong></p>\n<blockquote>\n<p id=\"so_48226247_48227536_0\">Under the following circumstances, the compilers are permitted, but\n  not required to omit the copy- and move- (since C++11)construction of\n  class objects ...</p>\n<ul>\n<li>If a <strong>function returns a class type by value</strong>, and the return\n  statement's expression is the name of a non-volatile object with\n  automatic storage duration, which isn't a function parameter, or a\n  catch clause parameter, and which has the same type (ignoring\n  top-level cv-qualification) as the return type of the function, then\n  copy/move (since C++11) is omitted. When that local object is\n  constructed, it is constructed directly in the storage where the\n  function's return value would otherwise be moved or copied to. This\n  variant of copy elision is known as NRVO, \"named return value\n  optimization\".</li>\n</ul>\n</blockquote>\n<p><strong>Since c++17:</strong></p>\n<blockquote>\n<p id=\"so_48226247_48227536_1\">Under the following circumstances, the compilers are required to omit\n  the copy- and move- construction...</p>\n<p id=\"so_48226247_48227536_2\">a) In initialization, if the initializer expression is a prvalue and the\n  cv-unqualified version of the source type is the same class as the\n  class of the destination, the initializer expression is used to\n  initialize the destination object:</p>\n<pre><code>T x = T(T(T())); // only one call to default constructor of T, to initialize x\n</code></pre>\n<p id=\"so_48226247_48227536_3\">b) In a function call, if the operand of a <strong>return statement is a <em>prvalue</em></strong>\n  and the return type of the function is the same as the type of that\n  prvalue. </p>\n<pre><code>T f() { return T{}; }\nT x = f();         // only one call to default constructor of T, to initialize x\nT* p = new T(f()); // only one call to default constructor of T, to initialize *p\n</code></pre>\n</blockquote>\n<p>In any case <code>std::forward</code> does not fit requirements, because it's result is an <em>xvalue</em>, not a <em>prvalue</em>: it does not return class type by value. Thus no elision happens.</p>\n", "LastEditorUserId": "1597714", "LastActivityDate": "2018-01-12T13:57:11.537", "Score": "4", "CreationDate": "2018-01-12T13:44:55.980", "ParentId": "48226247", "CommentCount": "1", "OwnerUserId": "1597714", "LastEditDate": "2018-01-12T13:57:11.537"}, "48227942": {"Id": "48227942", "PostTypeId": "2", "Body": "<p>The two cases are subtly different, and it's important to understand why. With the new value semantics in C++17, the basic idea is that we delay the process of turning prvalues into objects as long as possible.</p>\n<pre><code>template &lt;typename T&gt;\nX make_X(T&amp;&amp; arg) {\n  return X(std::forward&lt;T&gt;(arg));\n}\n\nint main() {\n  auto x1 = make_X(1);\n  auto x2 = X(X(1));\n  auto x3 = make_X(X(1));\n}\n</code></pre>\n<p>For <code>x1</code>, the first expression we have of type <code>X</code> is the one in the body of <code>make_X</code>, which is basically <code>return X(1)</code>. That's a prvalue of type <code>X</code>. We're initializing the return object of <code>make_X</code> with that prvalue, and then <code>make_X(1)</code> is itself a prvalue of type <code>X</code>, so we're delaying the materialization. Initializing an object of type <code>T</code> from a prvalue of type <code>T</code> means directly initializing <a href=\"http://eel.is/c++draft/dcl.init#17.6.1\" rel=\"noreferrer\">from the initializer</a>, so <code>auto x1 = make_X(1)</code> reduces to just <code>X x1(1)</code>.</p>\n<p>For <code>x2</code>, the reduction is even simpler, we just directly apply the rule.</p>\n<p>For <code>x3</code>, the scenario is different. We have a prvalue of type <code>X</code> <em>earlier</em> (the <code>X(1)</code> argument) and that prvalue binds to a reference! At the point of binding, we apply <a href=\"http://eel.is/c++draft/dcl.init#ref-5.2.1.sentence-2\" rel=\"noreferrer\">the temporary materialization conversion</a> - which means we actually create <a href=\"http://eel.is/c++draft/conv.rval\" rel=\"noreferrer\">a temporary object</a>. <em>That</em> object is then moved into the return object, and we can do prvalue reduction on the subsequent expression all the way. So this reduces to basically:</p>\n<pre><code>X __tmp(1);\nX x3(std::move(__tmp));\n</code></pre>\n<p>We still have one move, but only one (we can elide chained moves). It's the binding to a reference that necessitates the existence of a separate <code>X</code> object. The argument <code>arg</code> and the return object of <code>make_X</code> must be different objects - which means a move must happen. </p>\n<hr/>\n<p>For the last two cases:</p>\n<pre><code>X x4 = std::forward&lt;X&gt;(X(1));\nX x5 = static_cast&lt;X&amp;&amp;&gt;(X(1));\n</code></pre>\n<p>In both cases, we're binding a reference to a prvalue, which again necessitates the temporary materialization conversion. And then in both cases, the initializer is an xvalue, so we don't get the prvalue reduction - we just have move construction from the xvalue that was a materialized temporary object from a prvalue. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2018-01-12T14:15:03.360", "Score": "16", "CreationDate": "2018-01-12T14:08:40.493", "ParentId": "48226247", "CommentCount": "4", "OwnerUserId": "2069064", "LastEditDate": "2018-01-12T14:15:03.360"}});