post_cb({"bq_ids": {"n4140": {"so_16720201_16720201_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 80}}, "n3337": {"so_16720201_16720201_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 75}}, "n4659": {"so_16720201_16720201_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 82}}}, "16720577": {"Id": "16720577", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_16720201_16720577_0\">It seems to me that we can call destructor explicitly in this case, could you explain to me why?</p>\n</blockquote>\n<p>Do you mean why can we? Because the language allows explicit destructor calls on any object. As you say, it usually gives undefined behaviour since most objects will be destroyed in some other way, and it's undefined behaviour to destroy anything twice (or more generally to access it after destruction). But that just means that you mustn't do it, not that the language will prevent you from doing it.</p>\n<p>Or do you mean why would we want to? Because that's how you destroy an object created by placement new.</p>\n<blockquote>\n<p id=\"so_16720201_16720577_1\">What does those destructor call mean in this example?</p>\n</blockquote>\n<p>They both mean the same thing, and are equivalent to <code>p-&gt;~A()</code>; they call the object's destructor. The example is demonstrating that you can provide template arguments here if you want to. I'm not sure why you'd want to.</p>\n<blockquote>\n<p id=\"so_16720201_16720577_2\">What are the cases that we can call destructors explicitly besides placement delete?</p>\n</blockquote>\n<p>I <em>think</em> that you're allowed to call a trivial destructor (one that doesn't do anything) whenever you like; but there's no point. I think destroying something created with placement new is the only legitimate reason to do it.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2013-05-23T18:26:52.260", "Score": "30", "CreationDate": "2013-05-23T17:46:30.947", "ParentId": "16720201", "CommentCount": "9", "LastEditDate": "2013-05-23T18:26:52.260", "OwnerUserId": "204847"}, "16720201": {"ViewCount": "64638", "Body": "<p>I understand that in most cases, we should not call a destructor explicitly. However, I saw an example from C++11 Standard N3485 Section 13.4.5 Template arguments:</p>\n<blockquote>\n<p id=\"so_16720201_16720201_0\">An explicit destructor call for an object that has a type that\n  is a class template specialization may explicitly specify the\n  template-arguments.  Example:  </p>\n<pre><code>template&lt;class T&gt; struct A {\n    ~A();\n}; \n\nvoid f(A&lt;int&gt;* p, A&lt;int&gt;* q) {\n    p-&gt;A&lt;int&gt;::~A();      // OK: destructor call\n    q-&gt;A&lt;int&gt;::~A&lt;int&gt;(); // OK: destructor call\n}\n</code></pre>\n</blockquote>\n<p>It seems to me that we can call destructor explicitly in this case, could you explain to me why? What does those destructor call mean in this example? Why they are reasonable?</p>\n<p>Another question:</p>\n<p><strong>What are the cases that we can call destructors explicitly besides when we are implementing <code>placement delete</code>?</strong></p>\n<p>Thank you.</p>\n<p><strong>EDIT:</strong> I found from <a href=\"http://www.parashift.com/c++-faq/dont-call-dtor-on-local.html\" rel=\"noreferrer\"> C++ FAQ </a>that we should not explicitly call a destructor on a local variable. </p>\n", "AcceptedAnswerId": "16720577", "Title": "calling destructor explicitly", "CreationDate": "2013-05-23T17:24:13.367", "Id": "16720201", "CommentCount": "8", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2016-04-04T08:24:02.747", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-04T08:24:02.747", "Score": "36", "OwnerUserId": "1760345", "Tags": "<c++><destructor>", "AnswerCount": "2"}, "16721094": {"Id": "16721094", "PostTypeId": "2", "Body": "<p><strong>It seems to me that we can call destructor explicitly in this case, could you explain to me why?</strong></p>\n<p>Because it's allowed by the language to be able to invoke the destructor of any object whenever you want (assuming you have access, e.g. it's not a private destructor).</p>\n<p><strong>What does those destructor call mean in this example?</strong></p>\n<p>It just invokes the destructor. Logically, it means that the object is destructed and should be considered to be garbage from that point on and should not be dereferenced or used. Technically it means that the object is in whatever state the destructor leaves it in, which for some objects <em>may</em> be identical to default construction (but you should never, ever rely on that).</p>\n<p><strong>Why they are reasonable?</strong></p>\n<p>Sometimes you need to destroy objects without releasing their memory.  This happens in a lot of class like variant/any, various script binding and reflection system, some singleton implementations, etc.</p>\n<p>For example, you might use <code>std::aligned_storage</code> to allocate a buffer for an object and then use placement new to construct an object in that buffer.  You cannot call <code>delete</code> on this object since that will both invoke the destructor and try to free the memory backing it. You <em>must</em> explicitly invoke the destructor in this case to properly destruct the object.</p>\n<p><strong>What are the cases that we can call destructors explicitly besides placement delete?</strong></p>\n<p>There's not really such a thing as 'placement delete', other than the corresponding operator to placement new (and any calls to <code>delete</code> will implicitly invoke the destructor except those the compiler invokes for failed construction, e.g. your 'placement delete' notion).</p>\n<p>One example I gave above. Another example is <code>std::vector</code>. You can call member functions like <code>pop_back()</code>. This needs to destroy the last element in the vector but it can't use <code>delete</code> since the memory backing the object is part of a larger buffer that must be managed separately. The same goes for many other containers, like open-addressing hash tables, <code>deque</code>, and so on. This is an example of where you'd want to use the <code>template typename</code> in order to invoke the destructor explicitly.</p>\n<p>It's a feature that a user of a library is very rarely going to need but the implementor of a low-level library like the STL or even some application frameworks is going to need to use here and there.</p>\n", "LastEditorUserId": "1140976", "LastActivityDate": "2014-10-30T14:31:23.993", "Score": "19", "CreationDate": "2013-05-23T18:15:17.967", "ParentId": "16720201", "CommentCount": "0", "LastEditDate": "2014-10-30T14:31:23.993", "OwnerUserId": "720860"}});