post_cb({"42440126": {"ParentId": "36779466", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The scope resolution operator is left-associative (though it doesn't allow parentheses).</p>\n<p>So whereas you want to refer to <code>A::tell</code> inside <code>B</code>, the id-expression refers to <code>tell</code> inside <code>B::A</code>, which is simply <code>A</code>, which is ambiguous.</p>\n<p>The workaround is to first cast to the unambiguous base <code>B</code>, then cast again to <code>A</code>.</p>\n<p>Language-lawyering:</p>\n<p>[basic.lookup.qual]/1 says,</p>\n<blockquote>\n<p id=\"so_36779466_42440126_0\">The name of a class or namespace member or enumerator can be referred to after the <code>::</code> scope resolution operator applied to a <em>nested-name-specifier</em> that denotes its class, namespace, or enumeration.</p>\n</blockquote>\n<p>The relevant grammar for <em>nested-name-specifier</em> is,</p>\n<blockquote>\n<p id=\"so_36779466_42440126_1\"><em>nested-name-specifier:</em></p>\n<p id=\"so_36779466_42440126_2\">\u00a0\u00a0\u00a0\u00a0<em>type-name</em> <code>::</code></p>\n<p id=\"so_36779466_42440126_3\">\u00a0\u00a0\u00a0\u00a0<em>nested-name-specifier</em> <em>identifier</em> <code>::</code></p>\n</blockquote>\n<p>So, the first <em>nested-name-specifier</em> is <code>B::</code> and <code>A</code> is looked up within it. Then <code>B::A</code> is a nested-name-specifier denoting <code>A</code> and <code>tell</code> is looked up within it.</p>\n<p>Apparently MSVC accepts the example. Probably it has a nonstandard extension, to resolve ambiguity by backtracking through such specifiers.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2017-02-24T13:58:54.540", "Id": "42440126", "Score": "3", "CreationDate": "2017-02-24T13:41:05.567", "LastActivityDate": "2017-02-24T13:58:54.540"}, "36779466": {"CommentCount": "4", "ViewCount": "282", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-04-21T20:09:13.737", "LastActivityDate": "2016-04-21T20:25:55.090", "Title": "Diamond of death and Scope resolution operator (c++)", "FavoriteCount": "1", "LastEditDate": "2016-04-21T20:14:22.893", "Id": "36779466", "Score": "11", "Body": "<p>I have this code (diamond problem):</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Top\n{\n    void print() { cout &lt;&lt; \"Top::print()\" &lt;&lt; endl; }\n};\n\nstruct Right : Top \n{\n    void print() { cout &lt;&lt; \"Right::print()\" &lt;&lt; endl; }\n};\n\nstruct Left : Top \n{\n    void print() { cout &lt;&lt; \"Left::print()\" &lt;&lt; endl; }\n};\n\nstruct Bottom: Right, Left{};\n\nint main()\n{\n    Bottom b;\n    b.Right::Top::print();\n}\n</code></pre>\n<p>I want to call <code>print()</code> in <code>Top</code> class.</p>\n<p>When I try to compile it I get error: <code>'Top' is an ambiguous base of 'Bottom'</code> on this line: <code>b.Right::Top::print();</code> \nWhy is it ambiguous? I explicitly specified that I want <code>Top</code> from <code>Right</code> and not from <code>Left</code>.</p>\n<p>I don't want to know HOW to do it, yes it can be done with references, virtual inheritance, etc. I just want to know why is <code>b.Right::Top::print();</code> ambiguous.</p>\n", "Tags": "<c++><inheritance><multiple-inheritance><diamond-problem>", "OwnerUserId": "4932834", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_36779466_42440126_0": {"section_id": 7107, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_36779466_42440126_0": {"section_id": 6851, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_36779466_42440126_0": {"section_id": 8608, "quality": 0.9473684210526315, "length": 18}}}, "36779766": {"ParentId": "36779466", "CommentCount": "8", "Body": "<blockquote>\n<p id=\"so_36779466_36779766_0\">Why is it ambiguous? I explicitly specified that I want <code>Top</code> from <code>Right</code> and not from <code>Left</code>.</p>\n</blockquote>\n<p>That was your intent, but that's not what actually happens. <code>Right::Top::print()</code> explicitly names the member function that you want to call, which is <code>&amp;Top::print</code>. But it does not specify on which subobject of <code>b</code> we are calling that member function on. Your code is equivalent conceptually to:</p>\n<pre><code>auto print = &amp;Bottom::Right::Top::print;  // ok\n(b.*print)();                             // error\n</code></pre>\n<p>The part that selects <code>print</code> is unambiguous. It's the implicit conversion from <code>b</code> to <code>Top</code> that's ambiguous. You'd have to explicitly disambiguate which direction you're going in, by doing something like:</p>\n<pre><code>static_cast&lt;Right&amp;&gt;(b).Top::print();\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "36779766", "Score": "15", "CreationDate": "2016-04-21T20:25:55.090", "LastActivityDate": "2016-04-21T20:25:55.090"}});