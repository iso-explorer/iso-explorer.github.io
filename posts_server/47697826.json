post_cb({"bq_ids": {"n4140": {"so_47697826_47697826_0": {"length": 38, "quality": 0.95, "section_id": 5965}, "so_47697826_47697898_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 0}}, "n3337": {"so_47697826_47697826_0": {"length": 38, "quality": 0.95, "section_id": 5734}, "so_47697826_47697898_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 0}}, "n4659": {"so_47697826_47697826_0": {"length": 34, "quality": 0.85, "section_id": 7456}, "so_47697826_47697898_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 0}}}, "47697826": {"ViewCount": "212", "Body": "<p>I am trying to implicitly construct an object from a lambda function. The constructor of the object takes a function pointer as parameter. But the code [ 1 ] doesn't compile with the message:</p>\n<pre><code>6 : &lt;source&gt;:6:5: note: candidate constructor not viable: no known conversion from '(lambda at /tmp/compiler-explorer-compiler117117-54-dfxyju.lkw98/example.cpp:22:14)' to 'Bar' (aka 'bool (*)()') for 1st argument\n    Foo(Bar b) : m_b{b} {}\n</code></pre>\n<p>But the standard states that a lambda function is implicitly convertible to a function pointer with the same parameter and return type [ 2 ]. This should be applicable here and therefore I would expect the constructor to be callable.</p>\n<p>So why doesn't the code compile? Thanks for your explanations!</p>\n<hr>\n<p>[ 1 ] Code example:</p>\n<pre><code>using Bar = bool(*)();\n\nclass Foo\n{\npublic:\n    Foo(Bar b) : m_b{b} {}\nprivate:\n    Bar m_b;\n};\n\nint main()\n{   \n    // working\n    Foo f1 ( [](){ return true; });\n    Foo f2 = Bar( [](){ return true; });\n\n    // working implicit conversion\n    bool(*tmp)() = []() { return true; };\n    Foo f3 = tmp;\n\n    // not working\n    Foo f4 = [](){ return true; };\n\n    return 0;\n}\n</code></pre>\n<p><a href=\"https://godbolt.org/g/QE4v1Z\" rel=\"nofollow noreferrer\">https://godbolt.org/g/QE4v1Z</a></p>\n<hr>\n<p>[ 2 ] The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">C++14 Standard</a> states in section 5.1.2 that:</p>\n<blockquote>\n<p id=\"so_47697826_47697826_0\">The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\u2019s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>Which means the lambda should be implicitly (non-explicit) convertable to the function pointer. </p>\n<hr>\n<p>tested with:</p>\n<ul>\n<li>Clang5.0.0 -std=c++14</li>\n<li>MSVC14.12 /permissive-</li>\n</ul>\n</hr></hr></hr>", "AcceptedAnswerId": "47697898", "Title": "C++ Using lambda for implicit constructor call expecting a function pointer", "CreationDate": "2017-12-07T14:57:19.903", "LastActivityDate": "2017-12-08T14:02:13.373", "CommentCount": "1", "LastEditDate": "2017-12-07T15:24:07.137", "PostTypeId": "1", "LastEditorUserId": "3309790", "Id": "47697826", "Score": "4", "OwnerUserId": "1207306", "Tags": "<c++><c++11><lambda><c++14><language-lawyer>", "AnswerCount": "1"}, "47697898": {"Id": "47697898", "PostTypeId": "2", "Body": "<p>Yes it <strong>is</strong> implicitly convertible to the function pointer; that's why <code>bool(*tmp)() = []() { return true; };</code> works. The point is that in one <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion#Order_of_the_conversions\" rel=\"nofollow noreferrer\">implicit conversion sequence</a>, only one user-defined conversion is allowed.</p>\n<blockquote>\n<p id=\"so_47697826_47697898_0\">Implicit conversion sequence consists of the following, in this order:</p>\n<ol>\n<li>zero or one standard conversion sequence;</li>\n<li>zero or one user-defined conversion;</li>\n<li>zero or one standard conversion sequence.</li>\n</ol>\n<p id=\"so_47697826_47697898_1\">When considering the argument to a constructor or to a user-defined\n  conversion function, only one standard conversion sequence is allowed\n  (otherwise user-defined conversions could be effectively chained).</p>\n</blockquote>\n<p>For <code>Foo f4 = [](){ return true; };</code>, which is <a href=\"http://en.cppreference.com/w/cpp/language/copy_initialization\" rel=\"nofollow noreferrer\">copy initialization</a>, the <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow noreferrer\">lambda</a> has to be converted to the function pointer via the user-defined conversion function of lambda, then converted to <code>Foo</code> via the converting constructor of <code>Foo</code>, two user-defined conversions are required, but not allowed.</p>\n<p>BTW:</p>\n<ol>\n<li><p><code>Foo f1 ( [](){ return true; });</code> works because for <a href=\"http://en.cppreference.com/w/cpp/language/direct_initialization\" rel=\"nofollow noreferrer\">direct intialization</a> the constructor of <code>Foo</code> will be invoked directly; the lambda is converted to the function pointer and then passed as the argument to the constructor, this is fine.</p></li>\n<li><p><code>Foo f2 = Bar( [](){ return true; });</code> works because lambda is explicitly converted to function pointer, which is converted to <code>Foo</code> implicitly later.</p></li>\n<li><p><code>bool(*tmp)() = []() { return true; }; Foo f3 = tmp;</code> works because the lambda is implicitly converted to function pointer as <code>tmp</code>, then <code>tmp</code> is converted <code>Foo</code>; only one user-defined conversion is required for either implicit conversion sequence, then it's fine.</p></li>\n<li><p><code>Foo f5 = +[](){ return true; };</code> works because <code>operator+</code> causes <a href=\"https://stackoverflow.com/q/18889028/3309790\">lambda converted to function pointer</a>, that means for <code>+[](){ return true; }</code> you'll get the function pointer with type <code>bool(*)()</code>, then the story is same as <code>f2</code>.</p></li>\n</ol>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2017-12-08T14:02:13.373", "Score": "14", "CreationDate": "2017-12-07T15:00:56.623", "ParentId": "47697826", "CommentCount": "2", "OwnerUserId": "3309790", "LastEditDate": "2017-12-08T14:02:13.373"}});