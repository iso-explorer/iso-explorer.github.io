post_cb({"bq_ids": {"n4140": {"so_39860732_39861534_2": {"length": 21, "quality": 1.0, "section_id": 6142}, "so_39860732_39861534_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3233}, "so_39860732_39861534_1": {"length": 11, "quality": 1.0, "section_id": 6142}, "so_39860732_39860802_1": {"length": 19, "quality": 0.95, "section_id": 6064}, "so_39860732_39861534_3": {"length": 5, "quality": 1.0, "section_id": 6064}, "so_39860732_39861534_4": {"length": 16, "quality": 0.8888888888888888, "section_id": 7223}}, "n3337": {"so_39860732_39861534_2": {"length": 21, "quality": 1.0, "section_id": 5906}, "so_39860732_39861534_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3106}, "so_39860732_39861534_1": {"length": 11, "quality": 1.0, "section_id": 5906}, "so_39860732_39860802_1": {"length": 19, "quality": 0.95, "section_id": 5832}, "so_39860732_39861534_3": {"length": 5, "quality": 1.0, "section_id": 5832}, "so_39860732_39861534_4": {"length": 16, "quality": 0.8888888888888888, "section_id": 6967}}, "n4659": {"so_39860732_39861534_2": {"length": 11, "quality": 0.5238095238095238, "section_id": 7638}, "so_39860732_39861534_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3990}, "so_39860732_39861534_1": {"length": 11, "quality": 1.0, "section_id": 7638}, "so_39860732_39860802_1": {"length": 18, "quality": 0.9, "section_id": 7560}, "so_39860732_39861534_3": {"length": 5, "quality": 1.0, "section_id": 242}, "so_39860732_39861534_4": {"length": 10, "quality": 0.5555555555555556, "section_id": 8732}}}, "39860732": {"ViewCount": "91", "Body": "<p>It has been asked before in various forms, but since the language specification appears to be quite dynamic in this regard (or at least <em>was</em> dynamic when some SO discussions of this matter took place), it might make sense to revisit the matter in light of any more recent developments, if any exist.</p>\n<p>So, the question is, again, whether a combination of <code>&amp;</code> and subscript is a valid way to obtain a pointer to the imaginary past-the-end element of an array</p>\n<pre><code>int a[42] = {};\n&amp;a[42];\n</code></pre>\n<p>It was considered undefined in C++98. But what about modern C++? We have seen <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\" rel=\"nofollow noreferrer\">DR#232</a>, which nevertheless is still in \"drafting\" state for some reason and definitely not in the standard text (as of C++14). Is the matter still hanging in the air or has it been resolved by some alternative means?</p>\n<p>What is interesting is that <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#315\" rel=\"nofollow noreferrer\">DR#315</a> seem to openly permit calling non-static member functions through a null pointer <code>p</code> (!) on the basis that \"<code>*p</code> is not an error when <code>p</code> is null unless the lvalue is converted to an rvalue\". It feels like the resolution of DR#315 was tentatively based on the supposedly slam-dunk future resolution of DR#232, but the latter failed to materialize. In that light, is DR#315 really a NAD?</p>\n<p>Also, since C++11 the library specification defines <em>dereferenceable</em> iterators simply as iterators for which <code>*it</code> expression is valid, which in case of <code>std::vector</code> would/might largely delegate the matter to the above issue for raw arrays, and apparently open the door for dererenceable <code>std::vector::end()</code> iterators. This potentially makes the following code valid</p>\n<pre><code>std::vector&lt;int&gt; v(42);\n&amp;v[42];\n</code></pre>\n<p>Is it really valid? Some older answers on SO categorically state that dereferencing standard <code>end()</code> iterators is always undefined. But it does not appear to be so clear-cut in post-C++11 versions of the language. The standard says that the library implementation \"never assumes\" end-iterators to be dereferenceable, which means that they are not unconditionally non-dereferenceable anymore.</p>\n<p>P.S. I have already seen this discussion <a href=\"https://stackoverflow.com/questions/26290598/lvalues-which-do-not-designate-objects-in-c14\">Lvalues which do not designate objects in C++14</a>, but it seems to be focused specifically on the validity of reference initialization, which I don't want to bring here.</p>\n", "Title": "The apparent underspecification of one-past-the-end subscripting: for both raw arrays and std::vector. Has it been resolved decisively already?", "CreationDate": "2016-10-04T19:56:24.083", "LastActivityDate": "2016-10-05T07:30:38.630", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:00:56.823", "LastEditorUserId": "-1", "Id": "39860732", "Score": "3", "OwnerUserId": "187690", "Tags": "<c++><arrays><iterator><standards><language-lawyer>", "AnswerCount": "2"}, "39861534": {"Id": "39861534", "PostTypeId": "2", "Body": "<p>My best guess:</p>\n<blockquote>\n<p id=\"so_39860732_39861534_0\">Except where it has been declared for a class (13.5.5), the subscript operator [] is interpreted in such\n  a way that E1[E2] is identical to *((E1)+(E2)).</p>\n</blockquote>\n<p><code>a[42]</code> is equal to a <code>*(a + 42)</code></p>\n<p>[\u00a7 5.7 Additive operators]</p>\n<blockquote>\n<p id=\"so_39860732_39861534_1\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type\n  of the pointer operand. \n  ...</p>\n<p id=\"so_39860732_39861534_2\">... If both the pointer operand and the result point to elements of the same array object, <strong>or one past\n  the last element of the array object</strong>, the evaluation shall not produce an overflow; otherwise, the behavior is\n  undefined.</p>\n</blockquote>\n<p>So <code>a + 42</code> seems to return a valid <code>T*</code> pointer, which would dereference into a <code>T</code> (per [expr.unary.op])</p>\n<blockquote>\n<p id=\"so_39860732_39861534_3\">If the type of the expression is \u201cpointer to T,\u201d the type of the result is\n  \u201cT.\u201d</p>\n</blockquote>\n<p>There is also the following note: </p>\n<p>[\u00a7 3.9.2 Compound types]</p>\n<blockquote>\n<p id=\"so_39860732_39861534_4\">Note: For instance,\n  the address one past the end of an array (5.7) would be considered to point to an unrelated object of the array\u2019s element type that might be located at that address.</p>\n</blockquote>\n<p>It seems like it is valid. I still think assigning to it would be undefined behavior (due to the note, that it is an unrelated object), but getting the address appears to be defined.</p>\n<p>That being said, <code>&amp;a[41] + 1</code> is defined (thanks to 5.7) and avoids this completely, maybe just do that.</p>\n", "LastEditorUserId": "1020484", "LastActivityDate": "2016-10-04T21:10:58.367", "Score": "0", "CreationDate": "2016-10-04T20:51:37.460", "ParentId": "39860732", "CommentCount": "3", "OwnerUserId": "1020484", "LastEditDate": "2016-10-04T21:10:58.367"}, "39860802": {"Id": "39860802", "PostTypeId": "2", "Body": "<p>To the best of my understanding you are dereferencing it in the <code>&amp;v[42]</code> (or <code>&amp;a[42]</code>) expression and it is undefined.</p>\n<p>Basing on N4140:</p>\n<blockquote>\n<p id=\"so_39860732_39860802_0\">[expr.unary.op]/1</p>\n<p id=\"so_39860732_39860802_1\">The unary * operator performs indirection : the\n  expression to which it is applied shall be a pointer to an object\n  type, or a pointer to a function type and the <strong>result is an lvalue</strong>\n<strong>referring to the object</strong> or function to which the expression points.</p>\n</blockquote>\n<p>I don't think the non-element past the last element of an array is considered an object.</p>\n", "LastEditorUserId": "2456565", "LastActivityDate": "2016-10-04T20:25:39.593", "Score": "0", "CreationDate": "2016-10-04T20:00:22.937", "ParentId": "39860732", "CommentCount": "10", "OwnerUserId": "2456565", "LastEditDate": "2016-10-04T20:25:39.593"}});