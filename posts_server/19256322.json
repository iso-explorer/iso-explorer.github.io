post_cb({"19257352": {"Id": "19257352", "PostTypeId": "2", "Body": "<p>Bit fields can't have references but are sometimes treated sorta like lvalues because they can be assigned to. Bit fields are messy IMO and you should avoid them.</p>\n<p>but if you need to convert a bitfield to behaving exactly like an rvalue of the same type you can use a function like below.</p>\n<pre><code>template&lt;class T&gt;\nT frombits(const T&amp; x)  {\n    return x;\n}\n//...\nstd::make_shared&lt;Foo&gt;(frombits(p-&gt;DUMMY.Field1));\n</code></pre>\n<p>I'm rather against specifying the template type. When you can, and always when it is intended, let the compiler deduce the type. Template argument deduction can get messy in C++11 but it has been engineered to work very well and work as it should in almost every case. Don't help the compiler and don't think you know better than it; eventually you will loose.</p>\n", "LastActivityDate": "2013-10-08T20:09:16.997", "CommentCount": "0", "CreationDate": "2013-10-08T20:09:16.997", "ParentId": "19256322", "Score": "0", "OwnerUserId": "2406646"}, "bq_ids": {"n4140": {"so_19256322_19257938_0": {"length": 41, "quality": 0.8913043478260869, "section_id": 628}}, "n3337": {"so_19256322_19257938_0": {"length": 41, "quality": 0.8913043478260869, "section_id": 618}}, "n4659": {"so_19256322_19257938_0": {"length": 41, "quality": 0.8913043478260869, "section_id": 654}}}, "19256728": {"Id": "19256728", "PostTypeId": "2", "Body": "<p>The compiler's error message is correct insofar as it really can't create a <code>DWORD&amp;</code> from the value you pass in. The bitfield isn't the right size to be a <em>real</em> reference to <code>DWORD</code>. Whether the compiler is correct to reject your program, I can't say.</p>\n<p>It's easy to work around, though. Simply specify the second template parameter when you call <code>make_shared</code>:</p>\n<pre><code>auto sp2 = std::make_shared&lt;Foo, int&gt;(p-&gt;DUMMY.Field1);\n</code></pre>\n<p>I used <code>int</code> because that's the constructor's argument type. You could say <code>DWORD</code> instead; any non-reference numeric type would probably be sufficient. You can then also forego the type-casting to <code>DWORD</code>. It doesn't do anything more.</p>\n", "LastEditorUserId": "33732", "LastActivityDate": "2013-10-09T07:03:44.480", "Score": "2", "CreationDate": "2013-10-08T19:35:21.040", "ParentId": "19256322", "CommentCount": "0", "LastEditDate": "2013-10-09T07:03:44.480", "OwnerUserId": "33732"}, "19257938": {"Id": "19257938", "PostTypeId": "2", "Body": "<p>Here's more of a comment than an answer. It may shed some light on what's happening.</p>\n<p>Example by Xeo</p>\n<pre><code>struct {\n  unsigned field:1;\n  unsigned nonfield;\n} dummy = {0};\n\ntemplate&lt;class T&gt;\nvoid foo(T&amp;&amp;){}\n</code></pre>\n<hr>\n<p>Step one: Type deduction.</p>\n<p>[class.bit]/1 specifies \"The bit-field attribute is not part of the type of the class member.\" Consequently, type deduction for <code>foo(dummy.field)</code> deduces the template parameter to be <code>unsigned&amp;</code>.</p>\n<hr>\n<p>Step two: overload resolution.</p>\n<p>Although not strictly necessary here, the Standard has a nice example concerning this in [over.ics.ref]/4</p>\n<blockquote>\n<p id=\"so_19256322_19257938_0\">[Example: a function with an \u201clvalue reference to <code>int</code>\u201d parameter can be a viable candidate even if the corresponding argument is an <code>int</code> bit-field. The formation of implicit conversion sequences treats the <code>int</code> bit-field as an <code>int</code> lvalue and finds an exact match with the parameter. If the function is selected by overload resolution, the call will nonetheless be ill-formed because of the prohibition on binding a non-const lvalue reference to a bit-field (8.5.3). \u2014end example ]</p>\n</blockquote>\n<p>So this function is well-formed and will be selected, but the call will be ill-formed nevertheless.</p>\n<hr>\n<p>Step three: Workarounds.</p>\n<p>The OP's conversion should resolve the problem, <code>foo( (unsigned)dummy.field )</code>, as it yields an rvalue which leads to <code>T</code> being deduced as <code>unsigned</code> and the parameter <code>unsigned&amp;&amp;</code> is initialized from a temporary. But it seems that MSVC ignores the lvalue-to-rvalue conversion if source and destination have the same type. Writing <code>foo( (unsigned)dummy.nonfield )</code> deduced <code>T</code> as <code>T&amp;</code> as well (even with a <code>static_cast</code>).</p>\n<p>The lvalue-to-rvalue conversion required to deduce <code>T</code> to <code>unsigned</code> rather than <code>unsigned&amp;</code> can be enforced by using a unary <code>+</code>: <code>foo( +dummy.field )</code></p>\n</hr></hr></hr>", "LastActivityDate": "2013-10-08T20:40:21.887", "CommunityOwnedDate": "2013-10-08T20:40:21.887", "Score": "2", "CreationDate": "2013-10-08T20:40:21.887", "ParentId": "19256322", "CommentCount": "0", "OwnerUserId": "420683"}, "19257509": {"Id": "19257509", "PostTypeId": "2", "Body": "<p>This is an odd one. The following snippet compiles under the <code>/Za</code> (disable language extensions) compiler flag, but not without:</p>\n<pre><code>struct {\n  unsigned field:1;\n} dummy = {0};\n\ntemplate&lt;class T&gt;\nvoid foo(T&amp;&amp;){}\n\nint main(){\n  foo((unsigned)dummy.field);\n}\n</code></pre>\n<p>Error without <code>/Za</code>:</p>\n<blockquote>\n<p id=\"so_19256322_19257509_0\">error C2664: 'foo' : cannot convert parameter 1 from 'unsigned int' to 'unsigned int &amp;'</p>\n</blockquote>\n<p>This is obviously a bug, since the cast to <code>unsigned</code> should simply create an rvalue, which should not be deduced as an lvalue-reference and which should not be treated as a bit-field. I have a feeling the extension for \"rvalues bind to lvalue-references\" plays a role here.</p>\n<p>Please file a bug report on Microsoft Connect.</p>\n", "LastActivityDate": "2013-10-08T20:18:13.880", "CommentCount": "12", "CreationDate": "2013-10-08T20:18:13.880", "ParentId": "19256322", "Score": "9", "OwnerUserId": "500104"}, "19256322": {"ViewCount": "902", "Body": "<p>Consider the following Smallest Recreate-able Standard Compliant Code</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;memory&gt;\nstruct Foo\n{\n    int m_field1;\n    Foo(int field1):m_field1(field1){};\n};\ntypedef unsigned long DWORD;\ntypedef unsigned short WORD;\nstruct BitField {\n    struct {\n        DWORD   Field1:31;\n        DWORD   Field2:1;\n    } DUMMY;\n};\nint main()\n{\n    std::vector&lt;std::shared_ptr&lt;Foo&gt;&gt; bar;\n    BitField *p = new BitField();\n    //This Line compiles\n    auto sp1 = std::shared_ptr&lt;Foo&gt;(new Foo((DWORD)p-&gt;DUMMY.Field1));\n    //But std::make_shared fails to compile\n    auto sp2 = std::make_shared&lt;Foo&gt;((DWORD)p-&gt;DUMMY.Field1);\n    return 0;\n}\n</code></pre>\n<p>This code fails to compile in VC11 Update 2 with the following error message</p>\n<pre><code>1&gt;Source.cpp(23): error C2664: 'std::shared_ptr&lt;_Ty&gt; std::make_shared&lt;Foo,DWORD&amp;&gt;(_V0_t)' : cannot convert parameter 1 from 'DWORD' to 'unsigned long &amp;'\n1&gt;          with\n1&gt;          [\n1&gt;              _Ty=Foo,\n1&gt;              _V0_t=DWORD &amp;\n1&gt;          ]\n</code></pre>\n<p>I cross checked on <a href=\"http://ideone.com/WBT8AW#sthash.hLFqKvgK.dpuf\" rel=\"nofollow\">IDEONE</a>, and it compiled successfully. Am I missing something obvious? </p>\n<p>A connect Bug was opened <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/804888/with-language-extension-enabled-vc11-an-explicit-cast-is-not-creating-an-rvalue-from-bit-fields\" rel=\"nofollow\">https://connect.microsoft.com/VisualStudio/feedback/details/804888/with-language-extension-enabled-vc11-an-explicit-cast-is-not-creating-an-rvalue-from-bit-fields</a></p>\n", "AcceptedAnswerId": "19257509", "Title": "std::make_shared fails to compile when constructing with parameters from Bitfields", "CreationDate": "2013-10-08T19:14:01.523", "Id": "19256322", "CommentCount": "2", "LastEditDate": "2013-10-09T06:50:42.937", "PostTypeId": "1", "LastEditorUserId": "977038", "LastActivityDate": "2013-10-09T07:03:44.480", "Score": "2", "OwnerUserId": "977038", "Tags": "<c++><visual-c++><c++11>", "AnswerCount": "4"}});