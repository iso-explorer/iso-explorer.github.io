post_cb({"7793897": {"LastActivityDate": "2011-10-17T12:43:31.633", "ParentId": "7793820", "Id": "7793897", "Score": "3", "Body": "<p>This is true for a struct, but changes in C++ as soon as you introduce access specifiers. The compiler is allowed to reorder whole blocks delimited by access specifiers.</p>\n", "CommentCount": "2", "PostTypeId": "2", "OwnerUserId": "105672", "CreationDate": "2011-10-17T12:43:31.633"}, "7793843": {"LastActivityDate": "2011-10-17T12:38:24.333", "ParentId": "7793820", "Id": "7793843", "Score": "1", "Body": "<p>In C++ you can be certain that these assumptions will hold. In struct like this, the compiler is not allowed to change the order of the members.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "160206", "CreationDate": "2011-10-17T12:38:24.333"}, "7793820": {"AcceptedAnswerId": "7793859", "Tags": "<c++><c>", "AnswerCount": "5", "OwnerUserId": "999127", "Body": "<p>If I have a struct like this:</p>\n<pre><code>struct S {\n    ANY_TYPE a;\n    ANY_TYPE b;\n    ANY_TYPE c;\n} s;\n</code></pre>\n<p>Can I safely assume that the following assumptions will always be true on all platforms?</p>\n<pre><code>((char *)&amp;s.a) &lt; ((char *)&amp;s.c)\n((char *)&amp;s.a + sizeof(s.a) + sizeof(s.b)) &lt;= ((char *)&amp;s.c)\n</code></pre>\n<p>In C++ too?</p>\n", "CommentCount": "3", "CreationDate": "2011-10-17T12:35:54.353", "PostTypeId": "1", "LastActivityDate": "2011-10-17T12:53:36.510", "Id": "7793820", "Title": "struct members memory layout", "Score": "5", "ViewCount": "5365"}, "7793845": {"LastActivityDate": "2011-10-17T12:38:47.587", "ParentId": "7793820", "Id": "7793845", "Score": "0", "Body": "<p>Yes, by default C++ compilers aren't allowed to move around elements in a struct which makes both statements trivially true.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "565635", "CreationDate": "2011-10-17T12:38:47.587"}, "7793859": {"CreationDate": "2011-10-17T12:40:04.707", "LastActivityDate": "2011-10-17T12:53:36.510", "LastEditorUserId": "14860", "ParentId": "7793820", "Score": "3", "Id": "7793859", "OwnerUserId": "14860", "Body": "<p>Yes, in C at least. The compiler is free to insert padding after any structure member but it must not reorder the members.</p>\n<p>It must also not insert padding before the first member.</p>\n<p>From C99, <code>6.7.2.1</code>:</p>\n<blockquote>\n<p id=\"so_7793820_7793859_0\"><strong>13/</strong> Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in the order in which they are declared. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. There may be unnamed padding within a structure object, but not at its beginning.</p>\n<p id=\"so_7793820_7793859_1\"><strong>15/</strong> There may be unnamed padding at the end of a structure or union.</p>\n</blockquote>\n", "CommentCount": "2", "PostTypeId": "2", "LastEditDate": "2011-10-17T12:53:36.510"}, "7793846": {"CreationDate": "2011-10-17T12:38:52.130", "LastActivityDate": "2011-10-17T12:38:52.130", "LastEditorUserId": "-1", "ParentId": "7793820", "Score": "0", "Id": "7793846", "OwnerUserId": "3937", "Body": "<ol>\n<li><p>Yes (as long as sizeof(ANY_TYPE) is not 0. Some compilers allow it, which is non-standard -- see <a href=\"https://stackoverflow.com/questions/2632021/can-sizeof-return-0-zero\">Can sizeof return 0 (zero)</a>).  You'd be safe with &lt;= or just assume a standard compiler.</p></li>\n<li><p>Yes</p></li>\n</ol>\n<p>And in C++ too.</p>\n<p>Pointer comparison only makes sense inside of arrays and structs/classes, not generally.</p>\n", "CommentCount": "0", "PostTypeId": "2", "LastEditDate": "2017-05-23T11:44:11.680"}, "bq_ids": {"n3337": {"so_7793820_7793859_0": {"section_id": 5650, "quality": 0.575, "length": 23}}}});