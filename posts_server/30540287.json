post_cb({"30540376": {"ParentId": "30540287", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Flushing copies data from the stream's internal buffer to the underlying file.</p>\n<p>So the flushing function needs to know the source and the destination to copy.</p>\n<p>This depends on I/O implementation, for C++ <code>&lt;iostream&gt;</code> see Jerry Coffin's answer - the buffers in <code>&lt;iostream&gt;</code> are more smart.</p>\n<p>With C-style <code>&lt;cstdio&gt;</code>, if you want to flush with just one argument, either <code>FILE*</code> or the char array needs to know about the file it should copy to.</p>\n<p>Your buffer is a dumb array, it just stores data for reading/writing. Since there are no additional info there, the function that gets a pointer to the buffer can't know the destination where to write it - so the imaginary <code>fflush</code> call would look like <code>fflush(buffer, file);</code> which doesn't get you anywhere. On the other hand, the <code>FILE*</code> stores the pointer to your buffer (you set the pointer with the <code>setbuf(file,buffer)</code> function call).</p>\n", "OwnerUserId": "1012936", "LastEditorUserId": "65863", "LastEditDate": "2015-05-30T01:00:02.000", "Id": "30540376", "Score": "6", "CreationDate": "2015-05-29T23:06:24.793", "LastActivityDate": "2015-05-30T01:00:02.000"}, "30540674": {"ParentId": "30540287", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The following deals only with iostreams and their buffer objects. For information about the buffers related to C-style I/O, please see @milleniumbug's answer.</p>\n<p>Mostly because you (at least normally) want the stream's badbit set if attempting to flush the underlying buffer fails.</p>\n<p>There's also a slightly complex little dance that streams use when interacting with the underlying stream, where the stream creates a sentry object, then carries out an action, then the sentry object is destroyed. The sentry is intended to make prefix and suffix operations exception safe.</p>\n<p>So the overall sequence is something like this:</p>\n<pre><code>create sentry\nif that succeeds (sentry converts to true) call rdbuf()-&gt;pubsync()\n    if that fails (returns -1) setstate(badbit);\n</code></pre>\n<p>A stream buffer (e.g., a <code>basic_filebuf</code>) is directly attached to the underlying file system object--in fact, all the interaction between the iostream object and the underlying file object is done <em>via</em> the file buffer. As shown above, when the stream object does need to flush the buffer, all it needs to do it tell the buffer to flush itself by calling the buffer's <code>pubsync()</code> member function.</p>\n<p>[For reference: [ostream.unformatted]/7:</p>\n<blockquote>\n<p id=\"so_30540287_30540674_0\">basic_ostream&amp; flush();<br/></p>\n<blockquote>\n<p id=\"so_30540287_30540674_3\">Effects: Behaves as an unformatted output function (as described in 27.7.3.6.1, paragraph 1). If rdbuf() is not a null pointer, constructs a sentry object. If this object returns true when converted to a value of type bool the function calls rdbuf()-&gt;pubsync(). If that function returns -1 calls setstate(badbit) (which may throw ios_base::failure (27.5.5.4)). Otherwise, if the sentry object returns false, does nothing.<br/></p>\n<p id=\"so_30540287_30540674_4\">Returns: *this.</p>\n</blockquote>\n</blockquote>\n<p>...and [ofstream.cons]/2:</p>\n<blockquote>\n<p id=\"so_30540287_30540674_5\">explicit basic_ofstream(const char* s,\n  ios_base::openmode mode = ios_base::out);</p>\n<blockquote>\n<p id=\"so_30540287_30540674_7\">Effects: Constructs an object of class basic_ofstream, initializing the base class with basic_ostream(&amp;sb) and initializing sb with basic_filebuf()) (27.7.3.2, 27.9.1.2), then calls rdbuf()-&gt;open(s, mode|ios_base::out). If that function returns a null pointer, calls setstate(failbit).</p>\n</blockquote>\n</blockquote>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2015-05-30T02:12:15.303", "Id": "30540674", "Score": "2", "CreationDate": "2015-05-29T23:46:04.520", "LastActivityDate": "2015-05-30T02:12:15.303"}, "30541186": {"ParentId": "30540287", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_30540287_30541186_0\">I can't understand why would people flush a stream but not a buffer.</p>\n</blockquote>\n<p>Because a buffer has no knowledge of where it should be flushed to.  A stream does.</p>\n<blockquote id=\"so_30540287_30541186_1\">\n<pre><code>FILE* file=fopen(\"mytext.txt\",\"wr\");\nsetbuf(file,buffer);\n</code></pre>\n</blockquote>\n<p>By default, a <code>FILE</code> structure contains a pointer to its own internal buffer.  <code>setbuf()</code> replaces that buffer with one that the caller provides.  But either way, <code>fwrite()</code>, <code>fput...()</code> and other similar functions write data into the stream's current buffer, and <code>fflush()</code> flushes the content of that buffer to the underlying file.</p>\n<p>BTW, <code>setbuf()</code> requires the caller-provided buffer to be at least <code>BUFSIZ</code> in size:</p>\n<pre><code>char buffer[BUFSIZ]=\"\";\n</code></pre>\n<blockquote>\n<p id=\"so_30540287_30541186_2\">So I wonder, since we actually store things in the buffer, why do we flush the stream it is associated to rather than flush the buffer directly, which actually store something and should be flushed.</p>\n</blockquote>\n<p>Because the buffer is just data storage.  It does not know anything about how the data is being used.  The stream knows what its buffer is being used for (cache written data), and where it needs to be flushed to (the associated file).  So you have to flush the stream so it can utilize that information.</p>\n<blockquote>\n<p id=\"so_30540287_30541186_3\">For example, we can't write things like fflush(buffer). Why?</p>\n</blockquote>\n<p>And where would you expect the buffer to flush its content to?  It has no such information.</p>\n", "OwnerUserId": "65863", "PostTypeId": "2", "Id": "30541186", "Score": "0", "CreationDate": "2015-05-30T01:09:45.747", "LastActivityDate": "2015-05-30T01:09:45.747"}, "30540287": {"CommentCount": "4", "ViewCount": "292", "CreationDate": "2015-05-29T22:55:24.640", "LastActivityDate": "2015-05-30T02:12:15.303", "Title": "Why we flush a stream but not a buffer?", "PostTypeId": "1", "Id": "30540287", "Score": "5", "Body": "<p>I know this is gonna be quite a stupid question, but after reading so many document about the whole \"buffer\" system, I can't understand why would people flush a stream but not a buffer.</p>\n<p>I have seen people write thing like this:</p>\n<pre><code>FILE* file=fopen(\"mytext.txt\",\"wr\");\nchar buffer[10]=\"\";\nsetbuf(file,buffer);\n\n//do some stuff....\n\nfflush(file);\n....\nfclose(file);\n</code></pre>\n<p>So I wonder, since we actually store things in the buffer, why do we flush the stream it is associated to rather than flush the buffer directly, <strong>which actually store something and should be flushed</strong>.( well, some people tell me that if things go like what I said it will just be the same thing so bother myself......)</p>\n<p>For example, we can't write things like<code>fflush(buffer)</code>.Why?</p>\n", "Tags": "<c++><c><buffer><fflush>", "OwnerUserId": "4845608", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_30540287_30540674_3": {"section_id": 2314, "quality": 0.925, "length": 37}, "so_30540287_30540674_6": {"section_id": 2457, "quality": 0.6956521739130435, "length": 16}, "so_30540287_30540674_7": {"section_id": 2457, "quality": 0.6956521739130435, "length": 16}, "so_30540287_30540674_5": {"section_id": 2470, "quality": 1.0, "length": 6}, "so_30540287_30540674_1": {"section_id": 2314, "quality": 0.925, "length": 37}}, "n3337": {"so_30540287_30540674_3": {"section_id": 2302, "quality": 0.925, "length": 37}, "so_30540287_30540674_6": {"section_id": 2442, "quality": 0.6956521739130435, "length": 16}, "so_30540287_30540674_7": {"section_id": 2442, "quality": 0.6956521739130435, "length": 16}, "so_30540287_30540674_5": {"section_id": 2455, "quality": 1.0, "length": 6}, "so_30540287_30540674_1": {"section_id": 2302, "quality": 0.925, "length": 37}}, "n4659": {"so_30540287_30540674_1": {"section_id": 2588, "quality": 0.9, "length": 36}, "so_30540287_30540674_6": {"section_id": 2733, "quality": 0.6956521739130435, "length": 16}, "so_30540287_30540674_7": {"section_id": 2733, "quality": 0.6956521739130435, "length": 16}, "so_30540287_30540674_5": {"section_id": 2746, "quality": 1.0, "length": 6}, "so_30540287_30540674_3": {"section_id": 2588, "quality": 0.9, "length": 36}}}});