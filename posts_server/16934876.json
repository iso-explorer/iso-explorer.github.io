post_cb({"16934946": {"Id": "16934946", "PostTypeId": "2", "Body": "<p>Yes, when casting to <code>bool</code>, the value gets evaluated, not copying.</p>\n<p>In fact, in your example, as long as <code>value</code> is not <code>0</code>, <code>b</code> will be <code>true</code>.</p>\n<p>Update: Quoting from <strong>C++ Primer</strong> 5th Edition Chapter 2.1.2:</p>\n<p><code>When we assign one of the nonbool arithmetic types to a bool object, the\nresult is false if the value is 0 and true otherwise.</code></p>\n", "LastEditorUserId": "1009479", "LastActivityDate": "2013-06-05T08:36:12.967", "Score": "4", "CreationDate": "2013-06-05T08:24:42.927", "ParentId": "16934876", "CommentCount": "1", "OwnerUserId": "1009479", "LastEditDate": "2013-06-05T08:36:12.967"}, "16934987": {"Id": "16934987", "PostTypeId": "2", "Body": "<p>There's nothing magical about it. The conversion from <code>int</code> to <code>unsigned char</code> is defined as <code>value % 256</code> (for 8-bit <code>char</code>s), so that is what you get. It can be implemented as copying the LSB, but you should still think about it in the semantic sense, not the implementation.</p>\n<p>On the same vein, conversion of <code>int</code> to <code>bool</code> is defined as <code>value != 0</code>, so again, that is what you get.</p>\n<p>Integral (and boolean) conversions are covered by the C++11 standard in <code>[conv.integral]</code> and <code>[conv.bool]</code>. For the C-style cast, see <code>[expr.cast]</code> and <code>[expr.static.cast]</code>.</p>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2013-06-05T08:32:14.560", "Score": "8", "CreationDate": "2013-06-05T08:26:57.973", "ParentId": "16934876", "CommentCount": "2", "OwnerUserId": "1782465", "LastEditDate": "2013-06-05T08:32:14.560"}, "16935270": {"Id": "16935270", "PostTypeId": "2", "Body": "<p>ISO/IEC C++ Standard: </p>\n<blockquote>\n<p id=\"so_16934876_16935270_0\">4.12 Boolean conversions [conv.bool] 1 A prvalue of arithmetic... type can be converted to a prvalue of type bool. A zero value... is converted to false; any other value is converted to true.</p>\n</blockquote>\n<p>So, since a <em>prvalue</em> is a value, you might say that the value gets evaluated, albeit that's kind of pleonastic.</p>\n", "LastActivityDate": "2013-06-05T08:42:41.793", "CommentCount": "0", "CreationDate": "2013-06-05T08:42:41.793", "ParentId": "16934876", "Score": "0", "OwnerUserId": "2413201"}, "bq_ids": {"n4140": {"so_16934876_16935270_0": {"length": 16, "quality": 0.8, "section_id": 44}, "so_16934876_16935023_1": {"length": 39, "quality": 1.0, "section_id": 44}}, "n3337": {"so_16934876_16935270_0": {"length": 16, "quality": 0.8, "section_id": 41}, "so_16934876_16935023_1": {"length": 39, "quality": 1.0, "section_id": 41}}, "n4659": {"so_16934876_16935270_0": {"length": 16, "quality": 0.8, "section_id": 45}, "so_16934876_16935023_1": {"length": 39, "quality": 1.0, "section_id": 45}}}, "16935023": {"Id": "16935023", "PostTypeId": "2", "Body": "<p>It is a part of the standard:</p>\n<blockquote>\n<p id=\"so_16934876_16935023_0\"><strong>4.12 Boolean conversions [conv.bool]</strong></p>\n<p id=\"so_16934876_16935023_1\">1 A prvalue of arithmetic, unscoped enumeration, pointer, or pointer\n  to member type can be converted to a prvalue of type bool. A zero\n  value, null pointer value, or null member pointer value is converted\n  to false; any other value is converted to true. A prvalue of type\n  std::nullptr_t can be converted to a prvalue of type bool; the\n  resulting value is false.</p>\n</blockquote>\n", "LastActivityDate": "2013-06-05T08:29:03.060", "CommentCount": "0", "CreationDate": "2013-06-05T08:29:03.060", "ParentId": "16934876", "Score": "4", "OwnerUserId": "1663919"}, "16935179": {"Id": "16935179", "PostTypeId": "2", "Body": "<p>Casting to <code>bool</code> is a feature inherited from plain old C. Originally, C didn't have a <code>bool</code> type, and it was useful to use other types in <code>if</code> statements, like so:</p>\n<pre><code>int myBool = 1;\nif(myBool) {\n    // C didn't have bools, so we had to use ints!\n}\n\nvoid* p = malloc(sizeof(int));\nif(!p) {\n    // malloc failed to allocate memory!\n}\n</code></pre>\n<p>When you're converting to <code>bool</code>, it acts just like you're putting the statement in an <code>if</code>.</p>\n<p>Of course, C++ is backwards compatible with C, so it adopted the feature. C++ also added the ability to overload the conversion to <code>bool</code> on your classes. <code>iostream</code> does this to indicate when the stream is in an invalid state:</p>\n<pre><code>if(!cout) {\n    // Something went horribly wrong with the standard output stream!\n}\n</code></pre>\n", "LastActivityDate": "2013-06-05T08:37:47.860", "CommentCount": "1", "CreationDate": "2013-06-05T08:37:47.860", "ParentId": "16934876", "Score": "0", "OwnerUserId": "754093"}, "16935060": {"Id": "16935060", "PostTypeId": "2", "Body": "<p>According to the <a href=\"http://en.cppreference.com/w/cpp/language/explicit_cast\" rel=\"nofollow\">rules for C-style casts</a>, <code>(bool)value</code> is effectively a <code>static_cast</code>. The first rule for <code>static_cast</code> then kicks in, which computes the value of a temporary \"declared and initialized ... as by <code>new_type Temp(expression);</code>\", i.e. <code>bool Temp(value);</code>. That's well-defined: <code>Temp</code> is <code>true</code> iff <code>value != 0</code>. So yes, <code>value</code> is \"evaluated\" in a sense.</p>\n", "LastActivityDate": "2013-06-05T08:31:03.483", "CommentCount": "1", "CreationDate": "2013-06-05T08:31:03.483", "ParentId": "16934876", "Score": "3", "OwnerUserId": "166749"}, "16934876": {"ViewCount": "330", "Body": "<p>Today I realized that casting a value to a bool is a kind of magic:</p>\n<pre><code>int value = 0x100;\nunsigned char uc = static_cast&lt;unsigned char&gt;(value);\nbool b = static_cast&lt;bool&gt;(value);\n</code></pre>\n<p>Both <code>sizeof(uc)</code> and <code>sizeof(b)</code> return <code>1</code>. I know that <code>uc</code> will contain 0x00, because only the LSB is copied. But <code>b</code> will be <code>true</code>, so my assumption is that, when casting to <code>bool</code>, the value gets evaluated instead of copied.</p>\n<p>Is this assumption correct? And is this a standard C++ behavior?</p>\n", "AcceptedAnswerId": "16934987", "Title": "Magic of casting value to bool", "CreationDate": "2013-06-05T08:21:21.407", "Id": "16934876", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-06-05T08:26:27.267", "LastEditorUserId": "1300910", "LastActivityDate": "2013-06-05T08:42:41.793", "Score": "2", "OwnerUserId": "1300910", "Tags": "<c++><windows>", "AnswerCount": "6"}});