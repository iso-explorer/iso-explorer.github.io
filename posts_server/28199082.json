post_cb({"bq_ids": {"n4140": {"so_28199082_28199654_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 1336}, "so_28199082_28199654_0": {"length": 23, "quality": 1.0, "section_id": 5659}}, "n3337": {"so_28199082_28199654_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 1330}, "so_28199082_28199654_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 5442}}, "n4659": {"so_28199082_28199654_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 1466}, "so_28199082_28199654_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 7103}}}, "28199082": {"ViewCount": "162", "Body": "<p>Is it permittable to use <code>std::unique</code> with iterators created by means of <code>std::make_move_iterator</code> function? I tried <a href=\"http://coliru.stacked-crooked.com/a/8257229d75ef5f69\">the following</a>, and got success:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;ostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;limits&gt;\n#include &lt;iterator&gt;\n\n#include &lt;cstdlib&gt;\n\nstruct A\n{\n\n    A() : i(std::numeric_limits&lt; double &gt;::quiet_NaN()) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\"; }\n    A(double ii) : i(ii) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\"; }\n    A(A const &amp; a) : i(a.i) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\"; }\n    A(A &amp;&amp; a) : i(std::move(a.i)) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\"; a.i = std::numeric_limits&lt; double &gt;::quiet_NaN(); }\n    A &amp; operator = (A const &amp; a) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\"; i = a.i; return *this; }\n    A &amp; operator = (A &amp;&amp; a) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\"; i = std::move(a.i); a.i = std::numeric_limits&lt; double &gt;::quiet_NaN(); return *this; }\n    bool operator &lt; (A const &amp; a) const { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\"; return (i &lt; a.i); }\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wfloat-equal\"\n    bool operator == (A const &amp; a) const { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\"; return (i == a.i); }\n#pragma clang diagnostic pop\n\n    friend\n    std::ostream &amp;\n    operator &lt;&lt; (std::ostream &amp; o, A const &amp; a)\n    {\n        return o &lt;&lt; a.i;\n    }\n\nprivate :\n\n    double i;\n\n};\n\nint\nmain()\n{\n    std::vector&lt; A &gt; v{1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 4.0, 4.0, 5.0, 6.0, 6.0, 7.0};\n    std::cout &lt;&lt; \"v constructed\\n\\n\\n\\n\";\n    std::sort(v.begin(), v.end());\n    auto const end = std::unique(std::make_move_iterator(v.begin()), std::make_move_iterator(v.end())).base();\n    std::copy(v.begin(), end, std::ostream_iterator&lt; A &gt;(std::cout, \" \"));\n    std::cout &lt;&lt; std::endl;\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>But maybe is it implementation-dependent success?</p>\n<p>And what regarding other algorithms from <code>&lt;numeric&gt;</code> and <code>&lt;algorithm&gt;</code>?</p>\n", "AcceptedAnswerId": "28199654", "Title": "unique algorithm with move iterators", "CreationDate": "2015-01-28T17:54:22.997", "Id": "28199082", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-01-28T18:37:46.540", "Score": "6", "OwnerUserId": "1430927", "Tags": "<c++><algorithm><stl><iterator><c++14>", "AnswerCount": "1"}, "28199654": {"Id": "28199654", "PostTypeId": "2", "Body": "<p>The program is guaranteed to work by the standard.<br>\n<code>std::unique</code> requires forward iterators.  The easiest way to show up that move iterators satisfy that requirement is to inspect the <code>iterator_category</code> typedef of <code>move_iterator</code>:</br></p>\n<pre><code>typedef typename iterator_traits&lt;Iterator&gt;::iterator_category iterator_category;\n</code></pre>\n<p>As you can see, the iterator category of the underlying iterator type is directly adapted. In fact, the behavior of move iterators is almost equivalent to their underlying ones, [move.iterators]/1:</p>\n<blockquote>\n<p id=\"so_28199082_28199654_0\">Class template <code>move_iterator</code> is an iterator adaptor with the same\n  behavior as the underlying iterator except that its indirection\n  operator implicitly converts the value returned by the underlying\n  iterator\u2019s indirection operator to an rvalue reference.</p>\n</blockquote>\n<p>There are no other noteworthy requirements: Clearly <code>vector&lt;&gt;::iterator</code> is an input iterator (as required by [move.iter.requirements]). The only relevant requirement imposed by <code>unique</code> itself is</p>\n<blockquote>\n<p id=\"so_28199082_28199654_1\">The type of <code>*first</code> shall satisfy the <code>MoveAssignable</code> requirements\n  (Table 22).</p>\n</blockquote>\n<p>... which is straightforwardly met.</p>\n<p>Note that using move iterators should not bring any advantage over normal ones. Internally the duplicate elements are move-assigned (hence the <code>MoveAssignable</code> requirement), so returning an rvalue reference from <code>operator*</code> is superfluous.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-01-28T18:37:46.540", "Score": "5", "CreationDate": "2015-01-28T18:25:29.630", "ParentId": "28199082", "CommentCount": "7", "OwnerUserId": "3647361", "LastEditDate": "2015-01-28T18:37:46.540"}});