post_cb({"27909109": {"CommentCount": "13", "AcceptedAnswerId": "28764887", "PostTypeId": "1", "LastEditorUserId": "743382", "CreationDate": "2015-01-12T19:14:22.020", "LastActivityDate": "2015-02-27T13:07:06.870", "LastEditDate": "2015-02-26T12:43:19.267", "ViewCount": "1048", "FavoriteCount": "5", "Title": "Must template argument functions be treated as potentially constexpr?", "Id": "27909109", "Score": "30", "Body": "<p>Consider this program:</p>\n<pre><code>template &lt;int F(), int N = F()&gt;\nvoid f() { }\nconstexpr int g() { return 1; }\nint main() { f&lt;g&gt;(); }\n</code></pre>\n<p>Is this valid? Are compilers required to see at template definition time, that <code>F</code> could potentially refer to a <code>constexpr</code> function, and therefore the default argument for <code>N</code> could be valid?</p>\n<p>gcc and clang accept this, but Intel<sup>1</sup> rejects the template function at template definition time because <code>F()</code> is not a constant expression. Intel does accept <code>f&lt;g, g()&gt;()</code> if the default argument is removed, so clearly it understands that <code>g()</code> is usable in a constant expression in general.</p>\n<p>It's not clear to me what the standard says. It's clear that (C++11 [expr.const]p2)</p>\n<blockquote>\n<p id=\"so_27909109_27909109_0\">an invocation of a function other than a <code>constexpr</code> constructor for a literal class or a <code>constexpr</code> function</p>\n</blockquote>\n<p>renders an expression non-constant, but it's not clear to me whether that applies here. At template definition time, it certainly does seem to apply, since <code>F</code> is not declared to be a <code>constexpr</code> function, but at the same time, errors at template definition time are supposed to be diagnosed only if there is no possible valid instantiation of the template, and there does appear to be a valid instantiation here.</p>\n<p>I can see the arguments for both answers, so I'm getting confused. Is there a definitive answer to this question?</p>\n<p><sub><sup>1.</sup> Re-testing with the current release of Intel's compiler shows that it works just fine, so presumably the Intel developers considered it a bug and have since fixed it. This is a huge hint that the code is meant to be valid. It would still be nice to get a conclusive answer based on the standard, though.</sub></p>\n", "Tags": "<c++><templates><c++11><language-lawyer><constexpr>", "OwnerUserId": "743382", "AnswerCount": "1"}, "28764887": {"ParentId": "27909109", "PostTypeId": "2", "CommentCount": "11", "Body": "<h3>Introduction</h3>\n<pre><code>template&lt;int F(), int N = F()&gt; void func ();\n</code></pre>\n<p>In this answer we will go through the relevant sections of the International Standard, step by step, to prove that the above snippet is well-formed.</p>\n<hr>\n<h3>What does the International Standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\">N3337</a>) say?</h3>\n<p><strong>The Standardese</strong></p>\n<blockquote>\n<p id=\"so_27909109_28764887_0\">14.1p9 <strong>Template parameters</strong> <code>[temp.param]</code></p>\n<blockquote>\n<p id=\"so_27909109_28764887_2\">A <em>default template-argument</em> is a <em>template-argument</em> (14.3) specified after <code>=</code> in a <em>template-parameter</em>. <strong>[...]</strong></p>\n</blockquote>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_27909109_28764887_3\">14.3p6 <strong>Template arguments</strong> <code>[temp.arg]</code></p>\n<p id=\"so_27909109_28764887_4\">If the use of a <em>template-argument</em> gives rise to an ill-formed construct in the instantiation of a template specialization, the program is ill-formed.</p>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_27909109_28764887_5\">14.3.2p1 <strong>Template non-type arguments</strong> <code>[temp.arg.nontype]</code></p>\n<blockquote>\n<p id=\"so_27909109_28764887_7\">A <em>template-argument</em> for a non-type, non-template <em>template-parameter</em> shall be one of:</p>\n<ul>\n<li>for a non-type <em>template-parameter</em> of integral or enumeration type, a converted constant expression (5.19) of the type of the <em>template-parameter</em>; or</li>\n<li>the name of a non-type <em>template-parameter</em>; or</li>\n<li>a constant expression (5.19) that designates the address of an object <strong>[...]</strong>; or</li>\n<li>a constant expression that evaluates to a null pointer value (4.10); or</li>\n<li>a constant expression that evaluates to a null member pointer value (4.11); or</li>\n<li>a pointer to member expressed as described in 5.3.1</li>\n</ul>\n</blockquote>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_27909109_28764887_8\">5.19p3 <strong>Constant expressions</strong> <code>[expr.const]</code></p>\n<blockquote>\n<p id=\"so_27909109_28764887_10\">A <em>literal constant expression</em> is a prvalue core constant expression of\n    literal type, but not pointer type. An <em>integral constant expression</em> is a\n    literal constant expression of integral or unscoped enumeration type. A <em>converted constant expression</em> of type <code>T</code> is a literal constant expression,\n    implicitly converted to the type <code>T</code>, <strong>[...]</strong></p>\n</blockquote>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_27909109_28764887_11\">8.3.6p3 <strong>Default arguments</strong> <code>[dcl.fct.default]</code></p>\n<blockquote>\n<p id=\"so_27909109_28764887_13\">A default argument shall be specified only in the <em>parameter-declaration-clause</em> of a function declaration or in a <em>template-parameter</em> (14.1); in the latter case, the <em>initializer-clause</em> shall be an <em>assignment-expression</em>.</p>\n</blockquote>\n</blockquote>\n<p><br/></p>\n<p><strong>The Verdict</strong></p>\n<p>The above sections makes us come to the following conclusions:</p>\n<ul>\n<li>A <em>default template-argument</em> is a <em>template-argument</em>, and;</li>\n<li>when instantiating a template, all <em>template-arguments</em> must be usable in the context where they appear, and;</li>\n<li>every <em>template-argument</em> for a non-type, non-template <em>template-parameter</em> that appears in a program must be a <em>literal constant expression</em>, and;</li>\n<li>the <em>default-argument</em> for a <em>template-parameter</em> shall be an <em>assignment-expression</em>.</li>\n</ul>\n<hr>\n<h3>The Explanation</h3>\n<pre><code>template&lt;int F(), int N = F()&gt;\nvoid func ();\n</code></pre>\n<p><sup></sup></p>\n<pre><code>constexpr int (*F)() = &lt;some_initializer&gt;;                    // (A)\nconstexpr int N      = &lt;explicit_template_argument&gt; OR &lt;F()&gt;  // (B)\n</code></pre>\n<p>The snippet above can be used as a mental helper to ease reasoning about what the <em>template-parameters</em> will be equivalent to, given a set of <em>template-arguments</em>.</p>\n<p>To see whether <em>(B)</em> is valid or not, where an explicit <em>template-argument</em> is not given for <em>N</em>, we must evaluate <em>(A)</em> - and the evaluation of <em>(A)</em> might yield a value for <em>F</em> that is usable in the <em>constant-expression</em> required by <em>(B)</em>.</p>\n<p>With that said; <strong>Yes</strong>, the template is legal C++11.</p>\n<p><sub><strong>Legal</strong></sub></p>\n<pre><code>constexpr int g () { ... }\n</code></pre>\n<p><sup></sup></p>\n<pre><code>// func&lt;&amp;g&gt; \nconstexpr int (*F)() = &amp;g;  // ok\nconstexpr int N      = F(); // ok\n</code></pre>\n<p><sub><strong>Ill-formed</strong></sub></p>\n<pre><code>          int f () { ... }\n</code></pre>\n<p><sup></sup></p>\n<pre><code>// func&lt;&amp;f&gt;\nconstexpr int (*F)() = &amp;f;  // ok\nconstexpr int N      = F(); // ill-formed, not a constant-expression\n</code></pre>\n<hr>\n<h3>Bonus</h3>\n<p>The same set of rules apply to the following template;</p>\n<pre><code>template&lt;int X, int N = 100/X&gt;\nvoid gunc ();\n</code></pre>\n<p><sup></sup></p>\n<pre><code>gunc&lt;0&gt; (); // ill-formed, `100/0` is not mathematically defined,\n            //              and is therefore not a constant-expression\n</code></pre>\n<p><sub><br/><strong>For the language-lawyer</strong></sub></p>\n<p>And this, pointless use of a default <em>template-argument</em>, is actually legal since <code>F()</code> might be a <em>constant-expression</em>.</p>\n<p><code>F()</code> can however <strong>not</strong> be a <em>converted constant-expression</em> to give <em>N</em> a value, but this doesn't happen until (if ever) the <em>default argument</em> is actually used.</p>\n<pre><code>template&lt;void F(), int N = F()&gt;\nvoid hunc ();\n</code></pre>\n<p><sup></sup></p>\n<pre><code>void f ();\n\nhunc&lt;&amp;f, 10&gt; (); // legal\nhunc&lt;&amp;f    &gt; (); // ill-formed\n</code></pre>\n</hr></hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2015-02-27T13:07:06.870", "Id": "28764887", "Score": "6", "CreationDate": "2015-02-27T12:14:25.320", "LastActivityDate": "2015-02-27T13:07:06.870"}, "bq_ids": {"n4140": {"so_27909109_27909109_0": {"section_id": 6185, "quality": 1.0, "length": 10}, "so_27909109_28764887_7": {"section_id": 87, "quality": 1.0, "length": 5}, "so_27909109_28764887_12": {"section_id": 3254, "quality": 0.9166666666666666, "length": 11}, "so_27909109_28764887_4": {"section_id": 81, "quality": 1.0, "length": 10}, "so_27909109_28764887_1": {"section_id": 62, "quality": 0.7142857142857143, "length": 5}, "so_27909109_28764887_6": {"section_id": 87, "quality": 1.0, "length": 5}, "so_27909109_28764887_13": {"section_id": 3254, "quality": 0.9166666666666666, "length": 11}, "so_27909109_28764887_2": {"section_id": 62, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_27909109_27909109_0": {"section_id": 5946, "quality": 1.0, "length": 10}, "so_27909109_28764887_7": {"section_id": 82, "quality": 1.0, "length": 5}, "so_27909109_28764887_12": {"section_id": 3126, "quality": 0.9166666666666666, "length": 11}, "so_27909109_28764887_4": {"section_id": 76, "quality": 1.0, "length": 10}, "so_27909109_28764887_13": {"section_id": 3126, "quality": 0.9166666666666666, "length": 11}, "so_27909109_28764887_9": {"section_id": 5947, "quality": 0.90625, "length": 29}, "so_27909109_28764887_1": {"section_id": 57, "quality": 0.7142857142857143, "length": 5}, "so_27909109_28764887_10": {"section_id": 5947, "quality": 0.90625, "length": 29}, "so_27909109_28764887_6": {"section_id": 82, "quality": 1.0, "length": 5}, "so_27909109_28764887_2": {"section_id": 57, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_27909109_27909109_0": {"section_id": 7687, "quality": 1.0, "length": 10}, "so_27909109_28764887_4": {"section_id": 83, "quality": 1.0, "length": 10}, "so_27909109_28764887_2": {"section_id": 64, "quality": 0.7142857142857143, "length": 5}, "so_27909109_28764887_9": {"section_id": 7689, "quality": 0.53125, "length": 17}, "so_27909109_28764887_1": {"section_id": 64, "quality": 0.7142857142857143, "length": 5}, "so_27909109_28764887_10": {"section_id": 7689, "quality": 0.53125, "length": 17}, "so_27909109_28764887_13": {"section_id": 4012, "quality": 0.9166666666666666, "length": 11}, "so_27909109_28764887_12": {"section_id": 4012, "quality": 0.9166666666666666, "length": 11}}}});