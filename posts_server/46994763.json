post_cb({"bq_ids": {"n4140": {"so_46994763_46994830_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 5808}, "so_46994763_46994830_0": {"length": 4, "quality": 0.8, "section_id": 5804}}, "n3337": {"so_46994763_46994830_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 5581}, "so_46994763_46994830_0": {"length": 4, "quality": 0.8, "section_id": 5577}}, "n4659": {"so_46994763_46994830_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 7269}, "so_46994763_46994830_0": {"length": 4, "quality": 0.8, "section_id": 7262}}}, "47043127": {"Id": "47043127", "PostTypeId": "2", "Body": "<p>From the point of view of the Standard, there is no requirement that implementations document anything about how any objects are physically stored in memory.  Even if an implementation documents the behavior of using pointers of type <code>unsigned char*</code> to access objects of a certain type, an implementation would be allowed to physically store data some other way and then have the code for character-based reads and writes adjust behaviors suitably.</p>\n<p>If an execution platform specifies a relationship between abstract-machine objects and storage seen by the CPU, and defines ways by which accesses to certain CPU addresses might trigger side effects the compiler doesn't know about, a quality compiler suitable for low-level programming on that platform should generate code where the behavior of <code>volatile</code>-qualified objects is consistent with that specification.  The Standard makes no attempt to mandate that all implementations be suitable for low-level programming (or any other particular purpose, for that matter).</p>\n<p>If the address of an automatic variable is never exposed to outside code, a <code>volatile</code> qualifier need only have only two effects:</p>\n<ol>\n<li><p>If <code>setjmp</code> is called within a function, a compiler must do whatever is necessary to ensure that <code>longjmp</code> will not disrupt the values of any <code>volatile</code>-qualified objects, even if they were written between the <code>setjmp</code> and <code>longjmp</code>.  Absent the qualifier, the value of objects written between <code>setjmp</code> and <code>longjmp</code> would become indeterminate when a <code>longjmp</code> is executed.</p></li>\n<li><p>Rules which would allow a compiler to presume that any loops which don't have side effects will run to completion do not apply in cases where a volatile object is accessed within the loop, whether or not an implementation would define any means by which such access would be observable.</p></li>\n</ol>\n<p>Except in those cases, the as-if rule would allow a compiler to implement the <code>volatile</code> qualifier in the abstract machine in a way that has no relation to the physical machine.</p>\n", "LastActivityDate": "2017-10-31T19:22:58.327", "CommentCount": "0", "CreationDate": "2017-10-31T19:22:58.327", "ParentId": "46994763", "Score": "2", "OwnerUserId": "363751"}, "46994763": {"ViewCount": "152", "Body": "<p>I noticed that clang and gcc optimize away the construction of or assignment to a volatile <code>struct</code> declared on the stack, in some scenarios. For example, the following code:</p>\n<pre><code>struct nonvol2 {\n    uint32_t a, b;\n};\n\nvoid volatile_struct2()\n{\n    volatile nonvol2 temp = {1, 2};\n}\n</code></pre>\n<p><a href=\"https://godbolt.org/g/GE15JX\" rel=\"nofollow noreferrer\">Compiles</a> on clang to:</p>\n<pre><code>volatile_struct2(): # @volatile_struct2()\n  ret\n</code></pre>\n<p>On the other hand, gcc does not remove the stores, although it does optimize the two implied stores into a single one:</p>\n<pre><code>volatile_struct2():\n        movabs  rax, 8589934593\n        mov     QWORD PTR [rsp-8], rax\n        ret\n</code></pre>\n<p>Oddly, clang won't optimize away a volatile store to a single <code>int</code> variable:</p>\n<pre><code>void volatile_int() {\n    volatile int x = 42;\n}\n</code></pre>\n<p>Compiles to:</p>\n<pre><code>volatile_int(): # @volatile_int()\n  mov dword ptr [rsp - 4], 1\n  ret\n</code></pre>\n<p>Furthermore a struct with 1 member rather than 2 is not optimized away.</p>\n<p>Although gcc doesn't remove the construction in this particular case, it does perhaps even more aggressive optimizations in the case that the <code>struct</code> members themselves are declared <code>volatile</code>, rather than the <code>struct</code> itself at the point of construction:</p>\n<pre><code>typedef struct {\n    volatile uint32_t a, b;\n} vol2;\n\nvoid volatile_def2()\n{\n    vol2 temp = {1, 2};\n    vol2 temp2 = {1, 2};\n    temp.a = temp2.a;\n    temp.a = temp2.a;\n}\n</code></pre>\n<p>simply compiles down to a simple <code>ret</code>.</p>\n<p>While it seems entirely \"reasonable\" to remove these stores which are pretty much impossible to observe by any reasonable process, my impression was that in the standard <code>volatile</code> loads and stores are assumed to be part of the <em>observable behavior</em> of the program (in addition to calls to IO functions), full stop. The implication being they are not subject to removal by \"as if\", since it would by definition change the <em>observable behavior</em> of the program.</p>\n<p>Am I wrong about that, or is clang breaking the rules here? Perhaps <em>construction</em> is excluded from the cases where <code>volatile</code> must be assumed to have side effects? </p>\n", "Title": "Is it legal to optimize away stores/construction of volatile stack variables?", "CreationDate": "2017-10-28T21:41:50.593", "LastActivityDate": "2017-10-31T19:22:58.327", "CommentCount": "11", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-10-30T06:57:37.683", "LastEditorUserId": "149138", "Id": "46994763", "Score": "8", "OwnerUserId": "149138", "Tags": "<c++><optimization><x86><language-lawyer><volatile>", "AnswerCount": "2"}, "46994830": {"Id": "46994830", "PostTypeId": "2", "Body": "<p>Let us investigate what the standard directly says.  The behavior of <code>volatile</code> is defined by a pair of statements. [intro.execution]/7:</p>\n<blockquote>\n<p id=\"so_46994763_46994830_0\">The least requirements on a conforming implementation are:</p>\n<ul>\n<li>Accesses through volatile glvalues are evaluated strictly according to the rules of the abstract machine.</li>\n</ul>\n<p id=\"so_46994763_46994830_1\">...</p>\n</blockquote>\n<p>And [intro.execution]/14:</p>\n<blockquote>\n<p id=\"so_46994763_46994830_2\">Reading an object designated by a volatile glvalue (6.10), modifying an object, calling a library I/O function, or calling a function that does any of those operations are all side effects, which are changes in the state of the execution environment.</p>\n</blockquote>\n<p>Well, [intro.execution]/14 does not apply because nothing in the above code constitutes \"reading an object\". You initialize it and destroy it; it is never read.</p>\n<p>So that leaves [intro.execution]/7. The phrase of importance here is \"accesses <em>through</em> volatile glvalues\". While <code>temp</code> certainly is a <code>volatile</code> value, and it certainly is a glvalue... you never actually access through it. Oh yes, you initialize the object, but that doesn't actually access \"though\" <code>temp</code> as a glvalue.</p>\n<p>That is, <code>temp</code> as an expression is a glvalue, per the definition of glvalue: \"an expression whose evaluation determines the identity of an object, bit-field, or function.\" The statement creating and initializing <code>temp</code> <em>results</em> in a glvalue, but the initialization of <code>temp</code> isn't accessing through a glvalue.</p>\n<p>Think of <code>volatile</code> like <code>const</code>. The rules about <code>const</code> objects don't apply  until <em>after</em> it is initialized. Similarly, the rules about <code>volatile</code> objects don't apply until after it is initialized.</p>\n<p>So there's a difference between <code>volatile nonvol2 temp = {1, 2};</code> and <code>volatile nonvol2 temp; temp.a = 1; temp.b = 2;</code>. And Clang certainly <a href=\"https://godbolt.org/g/BJGEGn\" rel=\"nofollow noreferrer\">does the right thing in that case</a>.</p>\n<p>That being said, the inconsistency of Clang with regard to this behavior (optimizing it out only when using a struct, and only when using a struct that contains more than one member) suggests that this is probably not a formal optimization by the writers of Clang. That is, they're not taking advantage of the wording so much as this just being an odd quirk of some accidental code coming together.</p>\n<hr>\n<blockquote>\n<p id=\"so_46994763_46994830_3\">Although gcc doesn't remove the construction in this particular case, it does perhaps even more aggressive optimizations in the case that the <code>struct</code> members themselves are declared <code>volatile</code>, rather than the <code>struct</code> itself at the point of construction:</p>\n</blockquote>\n<p>GCC's behavior here is:</p>\n<ol>\n<li>Not in accord with the standard, as it is in violation of [intro.execution]/7, but</li>\n<li>There's absolutely no way to <em>prove</em> that it isn't compliant with the standard.</li>\n</ol>\n<p>Given the code you wrote, there is simply no way for a user to detect whether or not those reads and writes are actually happening. And I rather suspect that the moment you do anything to allow the outside world to see it, those changes will suddenly appear in the compiled code. However much the standard wishes to call it \"observable behavior\", the fact is that by C++'s own memory model, <em>nobody can see it</em>.</p>\n<p>GCC gets away with the crime due to lack of witnesses. Or at least credible witnesses (anyone who could see it would be guilty of invoking UB).</p>\n<p>So you should not treat <code>volatile</code> like some optimization off-switch.</p>\n</hr>", "LastEditorUserId": "734069", "LastActivityDate": "2017-10-29T06:59:10.847", "Score": "3", "CreationDate": "2017-10-28T21:50:08.137", "ParentId": "46994763", "CommentCount": "1", "OwnerUserId": "734069", "LastEditDate": "2017-10-29T06:59:10.847"}});