post_cb({"bq_ids": {"n4140": {"so_41401092_41401279_0": {"length": 52, "quality": 0.9285714285714286, "section_id": 302}}, "n3337": {"so_41401092_41401279_0": {"length": 52, "quality": 0.9285714285714286, "section_id": 293}}, "n4659": {"so_41401092_41401279_0": {"length": 52, "quality": 0.9285714285714286, "section_id": 309}}}, "41401092": {"ViewCount": "74", "Body": "<p>I created a factory function template:</p>\n<pre><code>template &lt;typename M, typename... Args&gt;\nstd::shared_ptr&lt;M&gt; create(Args... args)\n{\n    return std::make_shared&lt;M&gt;(args...);\n}\n</code></pre>\n<p>And a simple container:</p>\n<pre><code>struct Group {\n    std::vector&lt;int&gt; vec;\n    Group(std::initializer_list&lt;int&gt; il) : vec(il) {}\n};\n</code></pre>\n<p>Then I try to create a Group</p>\n<pre><code>int main()\n{\n    auto gr = create&lt;Group&gt;({1, 2, 3});\n    return 0;\n}\n</code></pre>\n<p>This doesn't compile, </p>\n<pre><code>error: no matching function for call to 'create'\n    auto gr = create&lt;Group&gt;({1, 2, 3});\ncandidate function not viable: requires 0 arguments, but 1 was provided\nstd::shared_ptr&lt;M&gt; create(Args... args)\n                   ^\n</code></pre>\n<p>but if I use a temporary variable:</p>\n<pre><code>int main(int argc, char *argv[])\n{\n    std::initializer_list&lt;int&gt; il = {1, 2, 3};\n    auto gr = create&lt;Group&gt;(il);\n    return 0;\n}\n</code></pre>\n<p>it does. Why?</p>\n<p>What is the recommended solution for such case?</p>\n", "AcceptedAnswerId": "41401279", "Title": "Variadic template not working with an initializer list", "CreationDate": "2016-12-30T18:40:46.187", "Id": "41401092", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-12-30T19:05:54.643", "LastEditorUserId": "1060159", "LastActivityDate": "2016-12-30T19:05:54.643", "Score": "3", "OwnerUserId": "1060159", "Tags": "<c++><c++11><variadic-templates><variadic-functions>", "AnswerCount": "2"}, "41401277": {"Id": "41401277", "PostTypeId": "2", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow noreferrer\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_41401092_41401277_0\">A <em>braced-init-list</em> is not an expression and therefore has no type, e.g. <code>decltype({1,2})</code> is ill-formed. Having no type implies that template type deduction cannot deduce a type that matches a <em>braced-init-list</em>, so given the declaration <code>template&lt;class T&gt; void f(T);</code> the expression <code>f({1,2,3})</code> is ill-formed.</p>\n</blockquote>\n<p>There is one exception though: <code>auto a = { 1, 2 };</code> results in <code>a</code> being a <code>std::initializer_list</code>. But this is only in <code>auto</code> type deducing, not for templates.</p>\n", "LastActivityDate": "2016-12-30T18:56:15.733", "CommentCount": "1", "CreationDate": "2016-12-30T18:56:15.733", "ParentId": "41401092", "Score": "0", "OwnerUserId": "3980929"}, "41401279": {"Id": "41401279", "PostTypeId": "2", "Body": "<p>A template parameter cannot be deduced from an initializer list (it's a non-deduced context), but can from an expression of type <code>std::initializer_list&lt;something&gt;</code>. The two are not the same.</p>\n<blockquote>\n<p id=\"so_41401092_41401279_0\"><strong>[temp.deduct.call]/1</strong> Template argument deduction is done by comparing each function template parameter type (call it <code>P</code>) with the type of the corresponding argument of the call (call it <code>A</code>) as described below. If removing references and cv-qualifiers from <code>P</code> gives <code>std::initializer_list&lt;P'&gt;</code> for some <code>P'</code> and the argument is an initializer list (8.5.4), then deduction is performed instead for each element of the initializer list, taking <code>P'</code> as a function template parameter type and the initializer element as its argument. Otherwise, an initializer list argument causes the parameter to be considered a non-deduced context (14.8.2.5). [ <em>Example:</em></p>\n<pre><code>template&lt;class T&gt; void f(std::initializer_list&lt;T&gt;);\nf({1,2,3}); // T deduced to int\nf({1,\"asdf\"}); // error: T deduced to both int and const char*\n\ntemplate&lt;class T&gt; void g(T);\ng({1,2,3}); // error: no argument deduced for T\n</code></pre>\n<p id=\"so_41401092_41401279_1\"><em>\u2014end example</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2016-12-30T18:56:23.860", "CommentCount": "2", "CreationDate": "2016-12-30T18:56:23.860", "ParentId": "41401092", "Score": "4", "OwnerUserId": "1670129"}});