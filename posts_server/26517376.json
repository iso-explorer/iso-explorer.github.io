post_cb({"26517912": {"ParentId": "26517376", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-10-22T22:05:06.273", "Score": "1", "LastEditorUserId": "3723423", "LastEditDate": "2014-10-23T22:12:59.830", "Id": "26517912", "OwnerUserId": "3723423", "Body": "<p>It's explained in C++ standard, section \"13.3.1.2 Operators in expressions\", point 2:   </p>\n<blockquote>\n<p id=\"so_26517376_26517912_0\">If either operand has a type that is a class or an enumeration, a\n  user-defined operator function might be declared that implements this\n  operator or a user-defined conversion can be necessary to convert the\n  operand to a type that is appropriate for a built-in operator.</p>\n</blockquote>\n<p>According to the further explanations <code>a+1</code> would be transformed in either <code>a.operator+(1)</code> (member function) or <code>operator+(a,1)</code> (non-member function). </p>\n<p>The point 3 explains that:  </p>\n<blockquote>\n<p id=\"so_26517376_26517912_1\">for a binary operator @ with a left operand of a type whose\n  cv-unqualified version is T1 and a right operand of a type whose\n  cv-unqualified version is T2, three sets of candidate functions,\n  designated member candidates, nonmember candidates and built-in\n  candidates, are constructed as follows:</p>\n<ul>\n<li>if T1 is a complete class type, the set of member candidates is the result of the qualified lookup of T1::operator@</li>\n</ul>\n</blockquote>\n<p>This explains why (1) is choosen when it's active.  When you comment it out,  the set of member candidates is empty.  Then, according to the next bullet in the standard:  </p>\n<blockquote id=\"so_26517376_26517912_2\">\n<ul>\n<li>The set of non-member candidates is the result of the unqualified lookup of operator@ in the context of the expression according to the\n  usual rules for name lookup in unqualified function calls except that\n  all member functions are ignored.</li>\n</ul>\n</blockquote>\n<p>According to these rules, as your expression is in <code>main()</code> and not included in a namespace, the two candidate functions are found and of course, it's ambiguous for the compiler. </p>\n<p>You could easily disambiguate which operator to use with the following statement in <code>main()</code>:  </p>\n<pre><code>    using A::operator+;\n</code></pre>\n<p>If you would have the expression a+1 inside a function in namespace A there would be no ambiguity either :  </p>\n<pre><code>//...your code preceding the main()\nnamespace A{  // reopen the namespace \n    void f()\n    {\n        A a;\n        a + 1; // version of the namespace is taken first \n    }\n}\n</code></pre>\n<p>The operator definied in the namespace would be taken first (as long as (1) remains commented out).   </p>\n<p><strong>About second question</strong></p>\n<p>First remark: if the member function would use <code>int</code> as argument, like the two other functions,  there would be no ambiguity, and (4) would be chosen for both expressions as in your first question.  The same would happen if all three functions would use <code>long</code> as argument instead of <code>int</code>.  </p>\n<p>The fact that you have the same name but different arguments requires us to digg more in depth of name hiding and overloading rules in section 13.3.1.2 of standard.  The point 6 states that :  </p>\n<blockquote>\n<p id=\"so_26517376_26517912_3\">The set of candidate functions for overload resolution is the union of\n  the member candidates, the non-member candidates, and the built-in\n  candidates. The argument list contains all of the operands of the\n  operator. The best function from the set of candidate functions is\n  selected according to 13.3.2 and 13.3.3</p>\n</blockquote>\n<p>13.3.2 is about viable functions, i.e. having the same number of arguments and an implicit conversion between the argument type and the parameter type. </p>\n<p>13.3.3 is about selecting the best viable function. \"<em>If there is exactly one viable function that is a better function than all other viable functions, then it is the\none selected by overload resolution; otherwise the call is ill-formed</em>\".  </p>\n<p>In the case of (a) there are two best viable functions:  the member function with a conversion (4) or the non member function without conversion, within the namespace (5) (because test() is in the namespace).  Hence the ambiguity.  </p>\n<p>In the case of b) there are three best viable functions:  the same as in (a) as well as (6).  But note that ,  if (6) would use long,  it would not cause an ambiguity since the member function would win.     </p>\n", "LastActivityDate": "2014-10-23T22:12:59.830"}, "26517604": {"ParentId": "26517376", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-10-22T21:39:41.430", "Score": "-1", "LastEditorUserId": "3309482", "LastEditDate": "2014-10-23T00:57:58.227", "Id": "26517604", "OwnerUserId": "3309482", "Body": "<p>Resolving a call to function +, a compiler performs an argument dependent lookup which includes construction of a set of candidate functions and overload resolution. The candidate functions include member, non-member and built-in candidates, and non-member candidates include all declarations found by the unqualified name lookup. If 1 is not commented, normal lookup of a qualified name finds a matching class member function. If 1 is commented, the ADL looks in the set of namespaces associated with the types of the function arguments. It finds two candidates which are both viable functions and have identical ranking of implicit conversion sequences, which results in the ambiguous overload error. The same example is given here <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup#Criticism\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Argument-dependent_name_lookup#Criticism</a></p>\n", "LastActivityDate": "2014-10-23T00:57:58.227"}, "26517376": {"CommentCount": "0", "ViewCount": "115", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-10-22T21:23:06.323", "LastActivityDate": "2014-10-23T22:12:59.830", "Title": "Operator overload resolution work within namespaces", "LastEditDate": "2017-05-23T11:49:37.353", "Id": "26517376", "Score": "2", "Body": "<pre><code>namespace A{\n   struct A{\n    inline void operator+(const int B) {};   // 1)\n };\n    inline void operator+(const A&amp; a,const int B) {};  // 2)\n }\n\n    inline void operator+(const A::A&amp; a,const int B) {};  // 3)\n\nint main()\n{\n A::A a;\n a+1; // compile questions\n return 1;\n}\n</code></pre>\n<p>The above codes can be compiled without any problem.</p>\n<p>But if 1) is commented, it fails to be compiled due to \"ambiguous overload for 'operator+' in 'a + 1'\" at 2) and 3). I can understand that the operator+ is first searched in class, there is the reason if 1) is not commented, no problem to be compiled. Aren't I right? </p>\n<p>Main question: If 1) is commented, why compiler has found one matched operator+, it continues to find the others? I am also curious that which one should be found first as well. (I thought it should stopped immediately based on the information <a href=\"https://stackoverflow.com/questions/11359562/how-does-the-operator-overload-resolution-work-within-namespaces\">How does the operator overload resolution work within namespaces?</a>)</p>\n<p><strong>Second questions:</strong></p>\n<pre><code>namespace A{\n   struct A{\n    inline void operator+(const long int B) {};   // 4), the input parameter type has been changed to long int\n };\n    inline void operator+(const A&amp; a,const int B) {};  // 5)\n    void test();\n }\n\n    inline void operator+(const A::A&amp; a,const int B) {};  // 6)\n\n void A::test()\n {\n    A a; // a)\n    a+ 1; \n }\n\n\nint main()\n{\n A::A a;\n a+1;  // b) \n return 1;\n}\n</code></pre>\n<p>Compilation ambiguous error at a) due to 4) and 5).</p>\n<p>Compilation ambiguous error at b) due to 4) ,5) and 6).</p>\n<p>Question i)</p>\n<p>For a) and b) , why compiler has already found operator+ with (const long int input parameter type ) at 4), which is member operator funciton in struct A, it still keeps going to find out others. In my mind, compiler should stopped there gives out the type error information. It should be the same as in the case the memeber fucntion's input parameter type is exactly matched, it stops searching for others.</p>\n<p>Question 2)</p>\n<p>I thought the compiler should stop at 4) and give out type error information.\nIn the case it continues, why member function overloading function (long int) has the same resolution ranking as non-memmber with exact matched input parameter ?  In this case, I thought the non-member case with exact matched input parameter should win if compiler decides to continue searching, which makes more sense.</p>\n", "Tags": "<c++><templates><namespaces><overloading>", "OwnerUserId": "4127047", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_26517376_26517912_3": {"section_id": 587, "quality": 0.8333333333333334, "length": 25}, "so_26517376_26517912_0": {"section_id": 583, "quality": 1.0, "length": 22}, "so_26517376_26517912_2": {"section_id": 584, "quality": 0.9565217391304348, "length": 22}, "so_26517376_26517912_1": {"section_id": 584, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_26517376_26517912_3": {"section_id": 577, "quality": 0.8333333333333334, "length": 25}, "so_26517376_26517912_0": {"section_id": 573, "quality": 1.0, "length": 22}, "so_26517376_26517912_2": {"section_id": 574, "quality": 0.9565217391304348, "length": 22}, "so_26517376_26517912_1": {"section_id": 574, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_26517376_26517912_1": {"section_id": 607, "quality": 0.8888888888888888, "length": 24}, "so_26517376_26517912_0": {"section_id": 606, "quality": 1.0, "length": 22}, "so_26517376_26517912_2": {"section_id": 607, "quality": 0.9565217391304348, "length": 22}, "so_26517376_26517912_3": {"section_id": 610, "quality": 0.8333333333333334, "length": 25}}}});