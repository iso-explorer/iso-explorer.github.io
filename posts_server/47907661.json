post_cb({"bq_ids": {"n4140": {"so_47907661_47907892_2": {"length": 13, "quality": 0.8125, "section_id": 5451}, "so_47907661_47907892_1": {"length": 5, "quality": 0.625, "section_id": 5451}}, "n4659": {"so_47907661_47907892_2": {"length": 14, "quality": 0.875, "section_id": 6890}, "so_47907661_47907892_1": {"length": 8, "quality": 1.0, "section_id": 6887}}}, "47907892": {"PostTypeId": "2", "LastEditDate": "2017-12-20T14:17:17.800", "ParentId": "47907661", "CommentCount": "2", "LastEditorUserId": "817643", "LastActivityDate": "2017-12-20T14:17:17.800", "CreationDate": "2017-12-20T14:08:43.263", "Id": "47907892", "Score": "4", "Body": "<blockquote>\n<p id=\"so_47907661_47907892_0\">Or are they the same?</p>\n</blockquote>\n<p>Assuming you write it correctly:</p>\n<pre><code>constexpr decltype(auto) operator ()(T &amp;&amp; i)\n{\n    return std::forward&lt;T&gt;(i);\n}\n</code></pre>\n<p>They are the same. <a href=\"https://timsong-cpp.github.io/cppwp/n4659/dcl.type.auto.deduct\" rel=\"nofollow noreferrer\">[dcl.type.auto.deduct]</a>:</p>\n<blockquote>\n<p id=\"so_47907661_47907892_1\">A type <code>T</code> containing a placeholder type, and a corresponding\n  initializer <code>e</code>, are determined as follows:</p>\n<ul>\n<li>for a non-discarded return statement that occurs in a function declared with a return type that contains a placeholder type, <strong><code>T</code> is the\n  declared return type and <code>e</code> is the operand of the return statement</strong>. If\n  the return statement has no operand, then <code>e</code> is <code>void()</code>;</li>\n</ul>\n<p id=\"so_47907661_47907892_2\">If the placeholder is the <code>decltype(auto)</code> type-specifier, <code>T</code> shall be\n  the placeholder alone. The type deduced for <code>T</code> is determined as\n  described in [dcl.type.simple], as though <code>e</code> had been the operand of\n  the <code>decltype</code></p>\n</blockquote>\n<p>The return type of the function is deduced from <code>return e;</code> as though by <code>decltype(e)</code>. So it would be the same as an explicit <code>decltype(std::forward&lt;T&gt;(i))</code>.</p>\n<blockquote>\n<p id=\"so_47907661_47907892_3\">What is better</p>\n</blockquote>\n<p>In this case, I'll go with \"less is more\". <code>decltype(auto)</code> gives you what you are after with less verbosity.</p>\n", "OwnerUserId": "817643"}, "47907661": {"ViewCount": "86", "LastEditDate": "2017-12-20T14:01:06.953", "AcceptedAnswerId": "47907892", "Title": "c++ decltype(auto) or decltype(std::forward<T>(value))?", "CreationDate": "2017-12-20T13:56:58.327", "LastActivityDate": "2017-12-20T14:17:17.800", "CommentCount": "5", "FavoriteCount": "1", "OwnerUserId": "1555823", "PostTypeId": "1", "LastEditorUserId": "1555823", "Id": "47907661", "Score": "3", "Body": "<p>For example, simple identity functor:</p>\n<pre><code>template &lt;typename T&gt;\nclass identity\n{\npublic:\n    constexpr auto operator ()(T &amp;&amp; i) -&gt; decltype(std::forward&lt;T&gt;(i))\n    {\n        return std::forward&lt;T&gt;(i);\n    }\n};\n</code></pre>\n<p>What is better (C++14 and newer) for return value:</p>\n<ul>\n<li><code>-&gt; decltype(std::forward&lt;T&gt;(i))</code> or</li>\n<li><code>-&gt; decltype(auto)</code></li>\n</ul>\n<p>Or are they the same?</p>\n", "Tags": "<c++><c++14><auto><decltype>", "AnswerCount": "1"}});