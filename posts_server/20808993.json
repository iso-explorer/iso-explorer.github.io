post_cb({"20809467": {"Id": "20809467", "PostTypeId": "2", "Body": "<p>The whole issue here is name lookup (I think this also has been the case <a href=\"https://stackoverflow.com/q/20693848/420683\">in one of your previous questions</a>). I'll try to illustrate my understanding of what's happening:</p>\n<p>Every (named) class gets an <em>injected-class-name</em>. For example:</p>\n<pre><code>struct GrandParent\n{\n    // using GrandParent = ::GrandParent;\n    enum {n = 0};\n};\n</code></pre>\n<p>You can use this injected-class-name to refer to the class itself. It is not that useful for ordinary classes (where unqualified lookup could find the name <code>GrandParent</code> in the surrounding scope anyway), but for derived classes and class templates:</p>\n<pre><code>namespace A\n{\n    struct Foo\n    {\n        // using Foo = ::A::Foo;\n    };\n};\n\nstruct Bar : A::Foo\n{\n    void woof(Foo); // using the injected-class-name `::A::Foo::Foo`\n};\n\ntemplate&lt;class T, int N, bool b&gt;\nstruct my_template\n{\n    // using my_template = ::my_template&lt;T, N, b&gt;;\n    void meow(my_template); // using the injected-class-name\n};\n</code></pre>\n<p>This isn't inheritance as in \"it's part of the base class subobject\", but the way unqualified lookup is specified: If the name isn't found in the current class' scope, the base class scopes will be searched.</p>\n<p>Now, for the first (non-template) example in the OP:</p>\n<pre><code>struct Parent : private GrandParent\n{\n    // using Parent = ::Parent;\n\n    enum {n = 1}; // hides GrandParent::n\n};\n\nstruct GrandChild : private Parent {\n    // using GrandChild = ::GrandChild;\n\n    enum {n = 2};\n    void f() {cout &lt;&lt; GrandParent::n &lt;&lt; endl;}\n    // ^ error: 'struct GrandParent GrandParent::GrandParent'\n    // is inaccessible\n};\n</code></pre>\n<p>Here, the expression <code>GrandParent::n</code> invokes unqualified name lookup of the name <code>GrandParent</code>. As unqualified lookup stops when the name is found (and doesn't consider surrounding scopes), it will find the injected-class-name <code>GrandParent::GrandParent</code>. That is, lookup searches the scope of <code>GrandChild</code> (name not found), then the scope of <code>Parent</code> (name not found) and finally the scope of <code>GrandParent</code> (where it finds the injected-class-name). This is done <em>before</em> and <em>independent of</em> access checking.</p>\n<p>After the name <code>GrandParent</code> has been found, accessibility is checked eventually. Name lookup required to go from <code>Parent</code> to <code>GrandParent</code> to find the name. This path is blocked for anyone but members and friends of <code>Parent</code>, as the inheritance is private. (You can see through that path, but you may not use it; visibility and accessibility are orthogonal concepts.)</p>\n<hr>\n<p>Here's the standardese [basic.lookup.unqual]/8:</p>\n<blockquote>\n<p id=\"so_20808993_20809467_0\">For the members of a class <code>X</code>, a name used in a member function body [...] shall be declared in one of the following ways:</p>\n<ul>\n<li>before its use in the block in which it is used or in an enclosing block, or</li>\n<li>shall be a member of class <code>X</code> or be a member of a base class of <code>X</code>, or</li>\n<li>if <code>X</code> is a nested class of class <code>Y</code> [...]</li>\n<li>[...]</li>\n<li>if <code>X</code> is a member of namespace <code>N</code>, or [...], before the use of the name,\n  in namespace <code>N</code> or in one of <code>N</code>\u2019s enclosing namespaces.</li>\n</ul>\n</blockquote>\n<p>Name lookup in base classes is rather complicated as multiple base classes might have to be considered. For single inheritance and a member looked up in the scope of a member function body, it starts with the class which this function is a member of, and then traverses the base classes up (base, base of base, base of base of base, ..). See [class.member.lookup]</p>\n<hr>\n<p>The template case is different, as <code>bar</code> is the name of a class template:</p>\n<pre><code>template &lt;unsigned int N&gt;\nstruct bar : private bar&lt;N - 1&gt; {\n    enum {num = N};\n    void g() {\n        static_assert(N &gt;= 2, \"range error\");\n        cout &lt;&lt; bar&lt;N - 2&gt;::num &lt;&lt; endl;\n    }\n};\n</code></pre>\n<p>Here, <code>bar&lt;N - 2&gt;</code> is used. It is a dependent name, as <code>N</code> is a template parameter. Name lookup is therefore postponed until the point of instantiation of <code>g</code>. The specialization <code>bar&lt;0&gt;</code> can be found, even it is declared after the function.</p>\n<p>The injected-class-name of <code>bar</code> can be used as a template-name (referring to the class template) or as a type-name (referring to the current instantiation) [temp.local]/1:</p>\n<blockquote>\n<p id=\"so_20808993_20809467_1\">Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injected-\n  class-name can be used as a <em>template-name</em> or a <em>type-name</em>. When it is used with a <em>template-argument-list</em>,\n  as a <em>template-argument</em> for a template <em>template-parameter</em>, or as the final identifier in the <em>elaborated-type-\n  specifier</em> of a friend class template declaration, it refers to the class template itself. Otherwise, it is equivalent\n  to the <em>template-name</em> followed by the <em>template-parameters</em> of the class template enclosed in <code>&lt;&gt;</code>.</p>\n</blockquote>\n<p>That is, <code>bar&lt;N - 2&gt;</code> finds <code>bar</code> as the injected-class-name of the <em>current</em> class (instantiation). As it is used with a <em>template-argument-list</em>, it refers to another, unrelated specialization of <code>bar</code>. The injected-class-name of the base class is hidden.</p>\n<p><code>bar&lt;0&gt;::num</code> is accessed <em>not</em> through an access path that goes through a private inheritance, but directly through the injected-class-name of the current class, referring to the class template itself. <code>num</code> being a public member of <code>bar&lt;0&gt;</code> is accessible.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-12-28T15:01:41.493", "Score": "3", "CreationDate": "2013-12-27T23:56:03.363", "ParentId": "20808993", "CommentCount": "5", "OwnerUserId": "420683", "LastEditDate": "2017-05-23T12:28:41.727"}, "bq_ids": {"n4140": {"so_20808993_20809467_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 7094}, "so_20808993_20809467_1": {"length": 35, "quality": 0.875, "section_id": 179}}, "n3337": {"so_20808993_20809467_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 6837}, "so_20808993_20809467_1": {"length": 35, "quality": 0.875, "section_id": 173}}, "n4659": {"so_20808993_20809467_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 8595}, "so_20808993_20809467_1": {"length": 35, "quality": 0.875, "section_id": 184}}}, "20808993": {"ViewCount": "396", "Body": "<p>I want to understand the access modifiers' 4 different behaviors regarding inheritance when it comes to the 4 combinations of using and/or omitting <code>template</code>s and the <code>this</code> keyword. All following code is done in g++ 4.8:</p>\n<p>Here's a <code>GrandChild</code> class, which <code>private</code>ly inherits from <code>Parent</code>, which <code>private</code>ly inherits from <code>GrandParent</code>, which has a <code>public</code> <code>enum</code> <code>n</code>. Non-object, client code can access <code>GrandParent::n</code>, because the latter is a <code>public</code> <code>enum</code>. But <code>GrandParent::n</code> is inaccessible from within <code>GrandChild</code>:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct GrandParent { enum {n = 0}; };\n\nstruct Parent : private GrandParent { enum {n = 1}; };\n\nstruct GrandChild : private Parent {\n    enum {n = 2};\n    void f() {cout &lt;&lt; GrandParent::n &lt;&lt; endl;}\n    // ^ error: 'struct GrandParent GrandParent::GrandParent'\n    // is inaccessible\n};\nint main() {\n    cout &lt;&lt; GrandParent::n &lt;&lt; endl;\n    // ^ non-object access would have outputted `0` had `GrandChild`'s\n    // definition compiled or been commented out.\n}\n</code></pre>\n<p>1.) Is <code>GrandParent::n</code>'s inaccessibility from within <code>GrandChild</code> caused by <code>GrandChild</code>'s possession of a <code>GrandParent</code> base subobject, which hides non-object access to <code>GrandParent::num</code>, and whose 2-generational <code>private</code>ness makes the base subobject\u2019s <code>n</code> also inaccessible? I'd expected the error message to be about that.</p>\n<p>2.) But apparently, it isn't. Why does the error complain about <code>GrandParent</code>'s constructor?</p>\n<p>3.) Prepending <code>this-&gt;</code> to <code>GrandParent::n</code> in <code>f()</code>'s definition will add the error I expected in #1 but won't remove the ctor complaint. <em>Why?</em> I assumed that including <code>this-&gt;</code> is redundant and that its omission will cause the lookup to attempt to find the <code>n</code> of the <code>GrandParent</code> subobject within <code>GrandChild</code>'s scope before the less-immediately-scoped non-object <code>n</code> anyway.</p>\n<p>4.) Why does this template variant compile? It seems functionally similar to the non-template one:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;unsigned int N&gt;\nstruct bar : private bar&lt;N - 1&gt; {\n    enum {num = N};\n    void g() {\n        static_assert(N &gt;= 2, \"range error\");\n        cout &lt;&lt; bar&lt;N - 2&gt;::num &lt;&lt; endl;\n    }\n};\n\ntemplate &lt;&gt;\nstruct bar&lt;0&gt; { enum {num = 0}; };\n\nint main() {\n    bar&lt;2&gt; b2;\n    b2.g(); // Output: 0\n}\n</code></pre>\n<p>5.) Prepending <code>this-&gt;</code> to <code>bar&lt;N - 2&gt;::num</code> in <code>g()</code>'s definition causes the compiler error I expected in #1 only. But why doesn't it include the error of #2? And why doesn't its omission yield #2's error?</p>\n", "AcceptedAnswerId": "20809467", "Title": "Access modifier's different behaviors in inheritance depend on \"this\" keyword and templates or lack thereof", "CreationDate": "2013-12-27T23:00:42.133", "Id": "20808993", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-12-28T15:01:41.493", "Score": "5", "OwnerUserId": "2090317", "Tags": "<c++><templates><inheritance><this><access-modifiers>", "AnswerCount": "2"}, "20809648": {"Id": "20809648", "PostTypeId": "2", "Body": "<p>For a good explanation of why private inheritance is not like public and protected inheritance, see two good answers from <a href=\"https://stackoverflow.com/questions/1576978/private-inheritance\">private inheritance</a>.</p>\n<blockquote>\n<p id=\"so_20808993_20809648_0\">From a common understanding of inheritance, C++\u2019 \u201cprivate inheritance\u201d\n  is a horrible misnomer: it is not inheritance (as far as everything\n  outside of the class is concerned) but a complete implementation\n  detail of the class.</p>\n<p id=\"so_20808993_20809648_1\">Seen from the outside, private inheritance is actually pretty much the\n  same as composition. Only on the inside of the class do you get\n  special syntax that is more reminiscent of inheritance than\n  composition.</p>\n<p id=\"so_20808993_20809648_2\">There\u2019s a caveat though: C++ syntactically treats this as inheritance,\n  with all the benefits and problems that this entails, such as scope\n  visibility and accessibility. Furthermore, C-style casts (but no C++\n  cast!) actually ignores visibility and thus succeeds in casting your\n  Derived pointer to Base:</p>\n<p id=\"so_20808993_20809648_3\"><code>Base* bPtr = (Base*) new Derived();</code></p>\n<p id=\"so_20808993_20809648_4\">Needless to say, this is evil.</p>\n<hr/>\n<p id=\"so_20808993_20809648_5\">Public inheritance means that everyone knows that Derived is derived\n  from Base.</p>\n<p id=\"so_20808993_20809648_6\">Protected inheritance means that only Derived, friends of Derived, and\n  classes derived from Derived know that Derived is derived from Base.*</p>\n<p id=\"so_20808993_20809648_7\">Private inheritance means that only Derived and friends of Derived\n  know that Derived is derived from Base.</p>\n<p id=\"so_20808993_20809648_8\">Since you have used private inheritance, your main() function has no\n  clue about the derivation from base, hence can't assign the pointer.</p>\n<p id=\"so_20808993_20809648_9\">Private inheritance is usually used to fulfill the\n  \"is-implemented-in-terms-of\" relationship. One example might be that\n  Base exposes a virtual function that you need to override -- and thus\n  must be inherited from -- but you don't want clients to know that you\n  have that inheritance relationship.</p>\n</blockquote>\n<p>As well as <a href=\"https://stackoverflow.com/questions/8011090/inaccessible-type-due-to-private-inheritance\">Inaccessible type due to private inheritance</a>.</p>\n<blockquote>\n<p id=\"so_20808993_20809648_10\">This is due to the injected class name from A hiding the global A\n  inside C. Although A is visible, it is not accessible (since it is\n  imported as private), hence the error. You can access A by looking it\n  up in the global namespace:</p>\n<p id=\"so_20808993_20809648_11\"><code>void foo(::A const&amp; a) {}</code></p>\n</blockquote>\n<p>So for example, this will work:</p>\n<pre><code>class GrandChild;\nstruct GrandParent { enum {n = 0}; };\n\nstruct Parent : private GrandParent { \n   enum {n = 1}; \n   friend GrandChild; \n};\n\nstruct GrandChild : private Parent {\n    void f() {cout &lt;&lt; GrandParent::n &lt;&lt; endl;}\n};\n</code></pre>\n<p>Otherwise you need to use global scope or the <code>using</code> directive to bring <code>::GrandParent</code> into scope.</p>\n", "OwnerDisplayName": "user1508519", "LastEditorUserId": "-1", "LastActivityDate": "2013-12-28T00:21:14.963", "Score": "1", "CreationDate": "2013-12-28T00:21:14.963", "ParentId": "20808993", "CommentCount": "1", "LastEditDate": "2017-05-23T12:19:09.577"}});