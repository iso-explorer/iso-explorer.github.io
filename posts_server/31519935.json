post_cb({"bq_ids": {"n4140": {"so_31519935_31519935_3": {"length": 20, "quality": 1.0, "section_id": 6187}, "so_31519935_31519935_0": {"length": 31, "quality": 0.96875, "section_id": 5425}, "so_31519935_31519935_2": {"length": 7, "quality": 0.5833333333333334, "section_id": 6187}, "so_31519935_31519935_1": {"length": 21, "quality": 0.75, "section_id": 6187}}, "n3337": {"so_31519935_31519935_3": {"length": 14, "quality": 0.7, "section_id": 5947}, "so_31519935_31519935_0": {"length": 31, "quality": 0.96875, "section_id": 5220}}, "n4659": {"so_31519935_31519935_3": {"length": 19, "quality": 0.95, "section_id": 7690}, "so_31519935_31519935_0": {"length": 18, "quality": 0.5625, "section_id": 6847}, "so_31519935_31519935_1": {"length": 23, "quality": 0.8214285714285714, "section_id": 7690}, "so_31519935_31519935_4": {"length": 20, "quality": 1.0, "section_id": 7690}, "so_31519935_31519935_2": {"length": 12, "quality": 1.0, "section_id": 7690}}}, "31519935": {"ViewCount": "224", "Body": "<p>N4527 7.1.5[dcl.constexpr]p9</p>\n<blockquote>\n<p id=\"so_31519935_31519935_0\">A constexpr specifier used in an object declaration declares the object as const. Such an object shall have literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant\n  expression (5.20). <strong>Otherwise, or if a constexpr specifier is used in a reference declaration, every full-expression that appears in its initializer shall be a constant expression.</strong></p>\n</blockquote>\n<p>5.20[expr.const]p5</p>\n<blockquote>\n<p id=\"so_31519935_31519935_1\">A constant expression is either a glvalue core constant expression whose value refers to an entity that is a\n  permitted result of a constant expression (as defined below), or a prvalue core constant expression whose\n  value is an object where, for that object and its subobjects: </p>\n<p id=\"so_31519935_31519935_2\">\u2014 each non-static data member of reference type refers to an entity that is a permitted result of a constant expression, and</p>\n<p id=\"so_31519935_31519935_3\">\u2014 if the object or subobject is of pointer type, it contains the address of an object with static storage duration, the address past the end of such an object (5.7), the address of a function, or a null pointer value.</p>\n<p id=\"so_31519935_31519935_4\">An entity is a permitted result of a constant expression if it is an object with static storage duration that is either not a temporary object or is a temporary object whose value satisfies the above constraints, or it is a\n  function.</p>\n</blockquote>\n<pre><code>void foo(){\n    constexpr const int &amp;a = 1;//error\n    constexpr static const int &amp;b = 1;//ok in gcc 5.1.0 and clang 3.8.0\n\n}\n</code></pre>\n<p>Question: Why <code>constexpr const int &amp;a = 1;</code> failed in block scope?</p>\n", "AcceptedAnswerId": "31520440", "Title": "Why `constexpr const int &a = 1;` failed in block scope?", "CreationDate": "2015-07-20T15:04:53.633", "Id": "31519935", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-07-20T20:11:26.957", "LastEditorUserId": "4958516", "LastActivityDate": "2015-07-23T20:22:07.523", "Score": "6", "OwnerUserId": "4958516", "Tags": "<c++><language-lawyer><constexpr>", "AnswerCount": "1"}, "31520440": {"Id": "31520440", "PostTypeId": "2", "Body": "<p>This is covered in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#2005\" rel=\"nofollow\">cwg defect report 2005: Incorrect constexpr reference initialization requirements</a> which says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_31519935_31520440_0\">Consider an example like:</p>\n<pre><code>  constexpr int f() { return 5; } // function must be constexpr\n  constexpr int &amp;&amp; q = f();       // but result is not constant\n  constexpr int const &amp; r = 2;    // temporary is still not constant\n  int main() {\n    q = 11;                       // OK\n    const_cast&lt; int &amp; &gt;( r ) = 3; // OK (temporary object is not ROMable)\n\n    constexpr int &amp;&amp; z = 7;       // Error? Temporary does not have static storage duration?\n  }\n</code></pre>\n<p id=\"so_31519935_31520440_1\">A constexpr reference must be initialized by a constant expression\n  (7.1.5 [dcl.constexpr] paragraph 9), yet it may refer to a modifiable\n  temporary object. Such a temporary is guaranteed static\n  initialization, but it's not ROMable.</p>\n<p id=\"so_31519935_31520440_2\">A non-const constexpr reference initialized with an lvalue expression\n  is useful, because it indicates that the underlying storage of the\n  reference may be statically initialized, or that no underlying storage\n  is required at all.</p>\n<p id=\"so_31519935_31520440_3\">When the initializer is a temporary, finding its address is trivial.\n  There is no reason to declare any intent the computation of its\n  address. On the other hand, an initial value is provided, and that is\n  also required to be a constant expression, although it's never treated\n  as a constant.</p>\n<p id=\"so_31519935_31520440_4\">The situation is worse for local constexpr references. The initializer\n  generates a temporary when the declaration is executed. The temporary\n  is a locally scoped, unique object. This renders constexpr\n  meaningless, because although the address computation is trivial, it\n  still must be done dynamically.</p>\n<p id=\"so_31519935_31520440_5\">C++11 constexpr references required initialization by reference\n  constant expressions, which had to \u201cdesignate an object with static\n  storage duration or a function\u201d (C++11 5.20 [expr.const] paragraph 3).\n  A temporary with automatic storage duration granted by the reference\n  fails this requirement.</p>\n<p id=\"so_31519935_31520440_6\">C++14 removes reference constant expressions and the static storage\n  requirement, rendering the program well-defined with an apparently\n  defeated constexpr specifier. (GCC and Clang currently provide the\n  C++11 diagnosis.)</p>\n<p id=\"so_31519935_31520440_7\">Suggested resolution: <strong>a temporary bound to a constexpr reference\n  should itself be constexpr, implying const-qualified type. Forbid\n  binding a constexpr reference to a temporary unless both have static\n  storage duration. (In local scope, the static specifier fixes the\n  issue nicely.)</strong></p>\n</blockquote>\n<p>The response is that this is already forbidden by <code>5.20</code> paragraph 4:</p>\n<blockquote>\n<p id=\"so_31519935_31520440_8\">This issue is already covered by 5.20 [expr.const] paragraph 4, which includes conversions and temporaries in the analysis.</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-07-23T20:22:07.523", "Score": "4", "CreationDate": "2015-07-20T15:26:46.997", "ParentId": "31519935", "CommentCount": "8", "OwnerUserId": "1708801", "LastEditDate": "2015-07-23T20:22:07.523"}});