post_cb({"25461713": {"ParentId": "25460275", "CommentCount": "0", "Body": "<p>I propose you a small template to handle these kind of issues easily:  </p>\n<pre><code>template &lt;typename T&gt;\nclass Buffer { \n    size_t sz;      // size\n    T* addr;        // pointed\npublic: \n    Buffer(const T*source, size_t l) : sz(l), addr(new T[l]) { std::copy(source, source + l, addr);  }  // allocate and copy\n    ~Buffer() { delete[]addr; }   // destroy memory \n    operator T* () { return addr; }  // convert to pointer\n};\n</code></pre>\n<p>You may use your existing code almost as is:  </p>\n<pre><code>Buffer&lt;char&gt; pDataToStore(pValueData, iMaxValueSize);  // create the automatic buffer\nint iActualSiz = ProcessData(pDataToStore, iMaxValueSize);  // automatic use of pointer to buffer\ncout &lt;&lt; \"modified copy: \" &lt;&lt; pDataToStore &lt;&lt; endl;\ncout &lt;&lt; \"original:      \" &lt;&lt; pValueData &lt;&lt; endl;\n</code></pre>\n<p>The buffer will be automatically released once pDataToStore is no longer in scope. </p>\n<p>If you have similar issues with <code>wchar_t</code> buffers or anything else, it will work as well.   </p>\n<p>For explanations on the evil of casting away const, see my other answer </p>\n", "OwnerUserId": "3723423", "PostTypeId": "2", "Id": "25461713", "Score": "0", "CreationDate": "2014-08-23T12:02:39.537", "LastActivityDate": "2014-08-23T12:02:39.537"}, "25460275": {"CommentCount": "5", "ViewCount": "200", "PostTypeId": "1", "LastEditorUserId": "1009479", "CreationDate": "2014-08-23T09:03:07.143", "LastActivityDate": "2014-08-23T12:02:39.537", "Title": "const char* getting modified after assigning to char*", "LastEditDate": "2014-08-23T09:05:11.207", "Id": "25460275", "Score": "0", "Body": "<pre><code>int FunctionName(const char *pValueName, const char *pValueData, long iMaxValueSize)\n{\n  char *pDataToStore = const_cast&lt;char *&gt;(pValueData);\n  int iActualSiz = ProcessData(pDataToStore, iMaxValueSize);\n...\n...\n}\n</code></pre>\n<p>In the upper code snippet ProcessData() function modifies the char*, which it receives as parameter. Now even after assigning pValueData into pDataToStore, after ProcessData() get executed, value of pValueData is being same as pDataToStore. </p>\n<p>My aim is to keep intact value of pValueData which is being passed as const char*</p>\n", "Tags": "<c++>", "OwnerUserId": "3859951", "AnswerCount": "4"}, "25460845": {"ParentId": "25460275", "CommentCount": "6", "Body": "<p>Well I have solved the issue by creating the heap memory.</p>\n<pre><code>char *pDataToStore = new char[iMaxValueSize];\nmemcpy(pDataToStore, pValueData, iMaxValueSize*sizeof(char));\nint iActualSiz = ProcessData(pDataToStore, iMaxValueSize);\n...\n....\ndelete []pDataToStore;\n</code></pre>\n", "OwnerUserId": "3859951", "PostTypeId": "2", "Id": "25460845", "Score": "0", "CreationDate": "2014-08-23T10:15:08.877", "LastActivityDate": "2014-08-23T10:15:08.877"}, "25461090": {"ParentId": "25460275", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_25460275_25461090_0\">My aim is to keep intact value of pValueData which is being passed as\n  const char*</p>\n</blockquote>\n<p>That's impossible. Passing via <code>const</code> means it cannot be modified, except when it was originally not constant.</p>\n<p>Example:</p>\n<pre><code>char *ptr1 = new char[100]; // not const\nchar *ptr2 = new char[100]; // not const\nint i = FunctionName(ptr1, ptr2, 123);\n</code></pre>\n<p>In this case, you could technically keep the <code>const_cast</code>. But what for? Just change your function parameters to take <code>char *</code>:</p>\n<pre><code>int FunctionName(char *pValueName, char *pValueData, long iMaxValueSize)\n{\n  int iActualSiz = ProcessData(pValueData, iMaxValueSize);\n  // ...\n}\n</code></pre>\n<p>However, you most likely <em>want</em> to be able to pass constant strings. For example string literals:</p>\n<pre><code>int i = FunctionName(\"name\", \"data\", 123);\n</code></pre>\n<p>String literals are unmodifiable and thus require your function to take <code>char const *</code>. A later attempt to modify them causes undefined behaviour.</p>\n<hr>\n<p>As you can see, the error is in the general architecture and code logic. <strong>You want to modify something and at the same time you do not want to allow to modify it.</strong></p>\n<p>The question is: What happens with your <code>pDataToStore</code> when <code>ProcessData</code> is done with it? Does the caller of <code>FunctionName</code> need to be aware of the modifications? Or is it just internal business of <code>FunctionName</code>?</p>\n<p>If it's just internal business of <code>FunctionName</code>, then you can keep its signature intact and have <code>ProcessData</code> modify a copy of the passed data. Here is a <strong>simplified</strong> (not exception-safe, no error checks) example: </p>\n<pre><code>int FunctionName(const char *pValueName, const char *pValueData, long iMaxValueSize)\n{\n   char *copy = new char[strlen(pValueData) + 1];\n   strcpy(copy, pValueData):\n   int iActualSiz = ProcessData(copy, iMaxValueSize);\n\n   // ...\n\n   delete[] copy;\n}\n</code></pre>\n<p>The nice thing is that you can now massively improve the interface of <code>FunctionName</code> by hiding all the low-level pointer business. In fact, why use so many pointers at all when C++ standard classes can do all the work for you?</p>\n<pre><code>int FunctionName(std::string const &amp;valueName, std::string const &amp;valueData, long maxValueSize)\n{\n   std::vector&lt;char&gt; copy(valueData.begin(), valueData.end());\n   int actualSize = ProcessData(&amp;copy[0], maxValueSize);\n\n   // ...\n   // no more delete[] needed here\n}\n</code></pre>\n<p>The <code>std::vector&lt;char&gt;</code> automatically allocates enough memory to hold a copy of <code>valueData</code>, and performs the copy. It fully automatically frees the memory when it is no longer needed, even if exceptions are thrown. And <code>&amp;copy[0]</code> (which in C++11 can be written as <code>copy.data()</code>) is guaranteed to yield a pointer to the internally used data, so that low-level C functions can modify the vector's elements.</p>\n<p><em>(I've also taken the chance to remove the Microsoft-style Hungarian Notation. It's a failed experiment from the 90s, and you've even used it incorrectly, supposing that a leading <code>i</code> is supposed to indicate an <code>int</code>.)</em></p>\n<hr>\n<p>The bottom line is really:</p>\n<p><strong>If you need a <code>const_cast</code> <em>anywhere</em> in your code to make it compile, then somewhere else there is at least either one <code>const</code> <em>missing</em> or one <em>too much</em>.</strong> A <code>const_cast</code> always makes up for a mistake in another piece of code. It is always a workaround and never a solution designed up front.</p>\n</hr></hr>", "OwnerUserId": "3313064", "PostTypeId": "2", "Id": "25461090", "Score": "2", "CreationDate": "2014-08-23T10:46:42.037", "LastActivityDate": "2014-08-23T10:46:42.037"}, "bq_ids": {"n4140": {"so_25460275_25460987_0": {"section_id": 5432, "quality": 1.0, "length": 31}}, "n3337": {"so_25460275_25460987_0": {"section_id": 5227, "quality": 1.0, "length": 31}}, "n4659": {"so_25460275_25460987_0": {"section_id": 6860, "quality": 1.0, "length": 31}}}, "25460987": {"ParentId": "25460275", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You have to make a difference between a <strong><em>const qualified type</em></strong> and a <strong><em>const qualified object</em></strong>.  </p>\n<p>The standard  states in section <em>7.1.6.1: cv-qualifiers</em>: (cv = const or volatile)</p>\n<blockquote>\n<p id=\"so_25460275_25460987_0\">A pointer or reference to a cv-qualified type need not actually point\n  or refer to a cv-qualified object, but it is treated as if it does; a\n  const-qualified access path cannot be used to modify an object even if\n  the object referenced is a non-const object and can be modified\n  through some other access path.</p>\n</blockquote>\n<p>If your pointer points to a non const object,  the casting away will enable you to modifiy the objet, but as someone told, you are lying to the user of your function.  </p>\n<p>It your pointer points to a real const object (i.e. in const protected memory), the compiler will compile your code, but you might have a segmentation fault, typical for undefined behaviour.  </p>\n<p>Here an example, using the fact that <em>\"Ordinary string literal (...) has type \u201carray of n const char\u201d, where n is the size of the string (...)\"</em> (see standard, section 2.14.5):  </p>\n<pre><code>char *my_realconst = \"This is a real constant string\";    // pointer does not claim that it points to const object \n\n(*my_realconst)++;  // Try to increment the first letter, will compile but will not run properly !! \n</code></pre>\n<p>So if your function ProcessData() is legacy code that is only reading the data but has forgotten to mention a const in the parameter list,  your cast-away will work. If your function is however altering the data, it might work or it might fail, depending how the data poitned to was created !  </p>\n<p>So try to avoid casting const away if you are not 100% sure of what the effects will be !  Better clone your object the hard way creating a temporary object and copying the content.  </p>\n", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "LastEditDate": "2014-08-23T10:45:58.473", "Id": "25460987", "Score": "0", "CreationDate": "2014-08-23T10:33:25.217", "LastActivityDate": "2014-08-23T10:45:58.473"}});