post_cb({"bq_ids": {"n4140": {"so_24307512_24307629_3": {"length": 27, "quality": 1.0, "section_id": 190}, "so_24307512_24308040_0": {"length": 27, "quality": 1.0, "section_id": 190}, "so_24307512_24307629_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 179}, "so_24307512_24307629_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 181}}, "n3337": {"so_24307512_24307629_3": {"length": 27, "quality": 1.0, "section_id": 184}, "so_24307512_24308040_0": {"length": 27, "quality": 1.0, "section_id": 184}, "so_24307512_24307629_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 175}, "so_24307512_24307629_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 173}}, "n4659": {"so_24307512_24307629_3": {"length": 22, "quality": 0.8148148148148148, "section_id": 195}, "so_24307512_24308040_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 195}, "so_24307512_24307629_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 186}, "so_24307512_24307629_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 184}}}, "24307512": {"ViewCount": "337", "Body": "<p>The following code is accepted by VC++ 2013, but rejected by clang 3.4.</p>\n<p>Which compiler is right as per the C++ standard?</p>\n<pre><code>template&lt;class T&gt;\nstruct A\n{\n    T n;\n};\n\ntemplate&lt;class T&gt;\nstruct B : A&lt;T&gt;\n{\n    // VC++ 2013 : OK\n    // clang : error : use of class template 'A' requires template arguments\n    B&amp; f1(const A&amp; obj) \n    {\n        return *this;\n    }\n\n    // VC++ : OK\n    // clang : OK\n    B&amp; f2(const A&lt;T&gt;&amp; obj)\n    {\n        return *this;\n    }\n};\n\nint main()\n{\n    B&lt;int&gt; b;\n}\n</code></pre>\n", "AcceptedAnswerId": "24307629", "Title": "Is it required to specify the template argument of a base class if the base class is a parameter type of a member function?", "CreationDate": "2014-06-19T13:13:39.653", "Id": "24307512", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-06-19T13:40:31.863", "Score": "17", "OwnerUserId": "508343", "Tags": "<c++><templates><visual-c++><clang><standards>", "AnswerCount": "2"}, "24307629": {"Id": "24307629", "PostTypeId": "2", "Body": "<p>My first instinct is to say VC++ is right in this one. Lookup of the name <code>A</code> in <code>B</code> should find the <em>injected-class-name</em> <code>A</code> inside <code>A&lt;T&gt;</code>, which can also be used as a <em>type-name</em> to refer to <code>A&lt;T&gt;</code>.</p>\n<p>C++11 [temp.local]:</p>\n<blockquote>\n<p id=\"so_24307512_24307629_0\">1 Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injected-class-name can be used as a <em>template-name</em> or a <em>type-name.</em> When it is used with a <em>template-argument-list,</em> as a <em>template-argument</em> for a template <em>template-parameter,</em> or as the final identifier in the <em>elaborated-type-specifier</em>\n  of a friend class template declaration, it refers to the class template itself. Otherwise, it is equivalent\n  to the <em>template-name</em> followed by the <em>template-parameters</em> of the class template enclosed in <code>&lt;&gt;</code>.</p>\n<p id=\"so_24307512_24307629_1\">2 ...</p>\n<p id=\"so_24307512_24307629_2\">3 The injected-class-name of a class template or class template specialization can be used either as a <em>template-name</em>\n  or a <em>type-name</em> wherever it is in scope. [ <em>Example:</em></p>\n<pre><code>template &lt;class T&gt; struct Base {\n  Base* p;\n};\n\ntemplate &lt;class T&gt; struct Derived: public Base&lt;T&gt; {\n  typename Derived::Base* p; // meaning Derived::Base&lt;T&gt;\n};\n</code></pre>\n</blockquote>\n<p>However, at the same time, [temp.dep]\u00a73 states:</p>\n<blockquote>\n<p id=\"so_24307512_24307629_3\">3 In the definition of a class or class template, if a base class depends on a <em>template-parameter,</em> the base class\n  scope is not examined during unqualified name lookup either at the point of definition of the class template\n  or member or during an instantiation of the class template or member.</p>\n</blockquote>\n<p>Based on this, I'd more inclined to say that clang is actually right, since the injected-class-name <code>A</code> is inside the scope of <code>A&lt;T&gt;</code>, which depends on <code>B</code>'s template parameter <code>T</code> and is thus <em>not</em> searched during unqualified name lookup. Secondary evidence to support this would be the fact that the example from [temp.local] uses <code>Derived::Base</code> instead of just <code>Base</code>.</p>\n<p>So in total, I'd say that</p>\n<ol>\n<li><p>it's a nice corner-case, and</p></li>\n<li><p>clang is actually right not to examine the scope of <code>A&lt;T&gt;</code></p></li>\n</ol>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2014-06-19T13:29:23.730", "Score": "14", "CreationDate": "2014-06-19T13:19:24.070", "ParentId": "24307512", "CommentCount": "2", "OwnerUserId": "1782465", "LastEditDate": "2014-06-19T13:29:23.730"}, "24308040": {"Id": "24308040", "PostTypeId": "2", "Body": "<p>Clang is correct; although the <em>injected-class-name</em> of the class template <code>A</code> is certainly visible within <code>A&lt;T&gt;</code> and so visible within the derived class <code>B&lt;T&gt;</code>, it is a <em>dependent</em> name and so the base class scope is not examined within <code>B&lt;T&gt;</code>.</p>\n<p>Dependent name base class scope lookup is discussed in 14.6.2p3:</p>\n<blockquote>\n<p id=\"so_24307512_24308040_0\">In the definition of a class or class template, if a base class depends on a <em>template-parameter</em>, the base class scope is not examined during unqualified name lookup either at the point of definition of the class template or member or during an instantiation of the class template or member.</p>\n</blockquote>\n", "LastActivityDate": "2014-06-19T13:40:31.863", "CommentCount": "0", "CreationDate": "2014-06-19T13:40:31.863", "ParentId": "24307512", "Score": "5", "OwnerUserId": "567292"}});