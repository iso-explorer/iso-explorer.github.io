post_cb({"bq_ids": {"n4140": {"so_26608611_26608611_0": {"length": 16, "quality": 1.0, "section_id": 6109}}, "n3337": {"so_26608611_26608611_0": {"length": 16, "quality": 1.0, "section_id": 5875}}, "n4659": {"so_26608611_26608611_0": {"length": 16, "quality": 1.0, "section_id": 7606}}}, "26608840": {"Id": "26608840", "PostTypeId": "2", "Body": "<p>The expression <code>delete p;</code> does two things:</p>\n<ol>\n<li>Destroy the complete object which contains <code>*p</code>.</li>\n<li>Deallocate the memory used to store said object.</li>\n</ol>\n<p>Item 2 <em>may</em> be possible when all you know is the address of the object, without any further information. The memory allocator only cares about addresses. But determining the complete object's address may be difficult; you essentially need to promise that you are actually providing the address of a complete object.</p>\n<p>But there's more. Before deallocating the object's storage, you must run destructors (Item 1). If the destructor has no effect, then it is acceptable to not run destructors, since that has the same behaviour <em>as if</em> you did run them. But if running destructors does have an effect, omitting Item 1 leads do undefined behaviour, and you need to know the complete type in order to know how to run destrutors. Incidentially, you also need to know the complete type in order to determine the address of the most-derived object for Item 2.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2014-10-28T12:57:47.427", "Score": "3", "CreationDate": "2014-10-28T12:50:55.010", "ParentId": "26608611", "CommentCount": "2", "OwnerUserId": "596781", "LastEditDate": "2014-10-28T12:57:47.427"}, "26608611": {"ViewCount": "274", "Body": "<p>Why is the deletion of an incomplete type <em>defined as \"undefined behaviour\"</em>?</p>\n<p>From the C++ specification; \u00a75.3.5/5;</p>\n<blockquote>\n<p id=\"so_26608611_26608611_0\">If the object being deleted has incomplete class type at the point of deletion and the complete class has a non-trivial destructor or a deallocation function, <strong>the behavior is undefined</strong>.</p>\n</blockquote>\n<p>Given the code example (I understand why it is an error);</p>\n<pre><code>class ABC;\n\nint main()\n{\n    ABC* p = nullptr;\n    delete p;\n}\n</code></pre>\n<p>Why is it defined as <em>being undefined behaviour</em> when gcc, clang and msvc all warn on it being an incomplete type? Why not just error at that point, i.e. <em>why is it not a diagnosable error</em>?</p>\n", "AcceptedAnswerId": "26608840", "Title": "Why is the deletion of an incomplete type defined as \"undefined behaviour\"?", "CreationDate": "2014-10-28T12:40:04.450", "Id": "26608611", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-11-12T07:25:43.207", "LastEditorUserId": "3747990", "LastActivityDate": "2014-11-12T07:25:43.207", "Score": "2", "OwnerUserId": "3747990", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}, "26608704": {"Id": "26608704", "PostTypeId": "2", "Body": "<p>Because, as your quote says, it's only undefined behaviour if it has a non-trivial destructor or deallocation function. If it's incomplete, the compiler doesn't know whether or not that's the case, so doesn't know whether or not the program is well-defined.</p>\n", "LastActivityDate": "2014-10-28T12:44:15.167", "CommentCount": "3", "CreationDate": "2014-10-28T12:44:15.167", "ParentId": "26608611", "Score": "5", "OwnerUserId": "204847"}});