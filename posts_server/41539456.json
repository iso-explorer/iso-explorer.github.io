post_cb({"41539456": {"ViewCount": "229", "Body": "<p>I have a base class with a pure virtual method implemented by two classes:</p>\n<pre><code>// base_class.hpp\nclass base_class {\npublic:\n  virtual std::string hello() = 0;\n};\n\n// base_implementer_1.hpp\nclass base_implementer1 : base_class {\npublic:\n  std::string hello();\n};\n\n// base_implementer_2.hpp\nclass base_implementer2 : base_class {\npublic:\n  std::string hello();\n};\n\n// base_implementer_1.cpp\nstd::string hello() {\n  return(std::string(\"Hello!\"));\n}\n\n// base_implementer_2.cpp\nstd::string hello() {\n  return(std::string(\"Hola!\"));\n}\n</code></pre>\n<p>Note the lack of <code>base_implementer1::</code> and <code>base_implementer2::</code> in the implementations. This is deliberate.</p>\n<p>By adding in the <code>base_implementer1::</code> and <code>base_implementer2::</code> I do not get a multiple definition error. However, leaving them off the linker complains I have two definitions of the same function (<code>hello()</code>).</p>\n<p>Since these two implementations are not featured in the header files, I would think that (even though they are not correct in terms of ACTUALLY implementing <code>hello()</code>) they would be allowed since there's no reason you couldn't have two <code>hello()</code> functions in two distinct <code>.cpp</code> files. But this doesn't seem to be the case. Can anyone tell me what's happening in the linker to make this multiple definition error happen?</p>\n", "AcceptedAnswerId": "41539584", "Title": "Understanding what causes this multiple definition error", "CreationDate": "2017-01-09T00:31:21.597", "Id": "41539456", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2017-01-09T09:58:03.223", "Score": "0", "OwnerUserId": "6467981", "Tags": "<c++><linker><one-definition-rule>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_41539456_41539584_0": {"length": 13, "quality": 0.5652173913043478, "section_id": 7043}, "so_41539456_41539584_3": {"length": 14, "quality": 1.0, "section_id": 7142}}, "n3337": {"so_41539456_41539584_0": {"length": 13, "quality": 0.5652173913043478, "section_id": 6788}, "so_41539456_41539584_3": {"length": 14, "quality": 1.0, "section_id": 6886}}, "n4659": {"so_41539456_41539584_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 8643}}}, "41539551": {"Id": "41539551", "PostTypeId": "2", "Body": "<p>You have two different definitions of a function named <code>hello</code> in two different translation units.  When it comes to link time, the linker has no idea which <code>hello</code> function to link to.</p>\n<p>Consider:</p>\n<p>A.cpp</p>\n<pre><code>#include &lt;string&gt;\nstd::string hello() {\n    return \"A\";\n}\n</code></pre>\n<p>B.cpp</p>\n<pre><code>#include &lt;string&gt;\nstd::string hello() {\n    return \"B\";\n}\n</code></pre>\n<p>C.cpp</p>\n<pre><code>#include &lt;iostream&gt;\nstd::string hello();\nint main() {\n    std::cout &lt;&lt; hello() &lt;&lt; '\\n';\n}\n</code></pre>\n<p>How could the linker possibly know which <code>hello</code> to call in <code>main</code>?  It can't because the One Definition Rule has been violated.</p>\n", "LastActivityDate": "2017-01-09T00:48:21.053", "CommentCount": "0", "CreationDate": "2017-01-09T00:48:21.053", "ParentId": "41539456", "Score": "0", "OwnerUserId": "4151599"}, "41539584": {"Id": "41539584", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/language/definition\" rel=\"nofollow noreferrer\">One-Definition-Rule</a> defines rules for two scopes, i.e. translation unit scope and program scope.</p>\n<p>The following rule with translation unit scope states that the same translation unit must not comprise two different definitions of the same function:  </p>\n<blockquote>\n<p id=\"so_41539456_41539584_0\">Only one definition of any variable, function, class type, enumeration\n  type, or template is allowed in any one translation unit (some of\n  these may have multiple declarations, but only one definition is\n  allowed).</p>\n</blockquote>\n<p>So, if you have two different .cpp-files, than you have two different translation units, and each of them may have their own definition of <code>hello()</code>; ODR is not violated in the scope of a translation unit.</p>\n<p>The following rule with program scope defines that an odr-used function must be defined exactly once in the program:</p>\n<blockquote>\n<p id=\"so_41539456_41539584_1\">One and only one definition of every non-inline function or variable\n  that is odr-used (see below) is required to appear in the entire\n  program (including any standard and user-defined libraries). The\n  compiler is not required to diagnose this violation, but the behavior\n  of the program that violates it is undefined.</p>\n</blockquote>\n<p>The definition of odr-used informally states that for every function that is called or which's address is taken must be defined in the program:  </p>\n<blockquote>\n<p id=\"so_41539456_41539584_2\">Informally, an object is odr-used if its address is taken, or a\n  reference is bound to it, and a <strong>function is odr-used if a function\n  call to it is made or its address is taken</strong>. If an object or a\n  function is odr-used, its definition must exist somewhere in the\n  program; a violation of that is a link-time error.</p>\n</blockquote>\n<p>So, if more than one .cpp-file exposes an implementation of <code>hello()</code>, and if this function is called or referenced, then ODR from program scope is clearly violated.</p>\n<p>If the respective function is not odr-used (i.e. called or referenced), ODR should - to my understanding - not be violated;</p>\n<p>If a compiler complains about duplicate symbols, than this is because the program violates linkage rules (please confer also <a href=\"https://stackoverflow.com/a/12979016/2630032\">SO answer</a>  concerning \"If I don't odr-use a variable\"). C++11 \u00a73.5[basic.link]/9 states:</p>\n<blockquote>\n<p id=\"so_41539456_41539584_3\">Two names that are the same and that are declared in different scopes\n  shall denote the same variable, function, type, enumerator, template\n  or namespace if</p>\n<ul>\n<li>both names have external linkage or else both names have internal linkage and are declared in the same translation unit; and ...</li>\n</ul>\n</blockquote>\n<p>To avoid this, make sure that at most one implementation of <code>hello()</code> is exposed, and make all others <code>static</code> or use an unnamed namespace.</p>\n<p>In the C programming language, <code>static</code> is used with global variables and functions to set their scope to the containing file, i.e. it does not expose this implementation and name clashes with other binaries are avoided.</p>\n<p>So a reasonable suggestion would be: Make function definitions, that are solely used within a translation unit, visible only to this translation unit; and define functions that are exposed within a namespace or class in order to avoid unintended or unforeseeable name clashes / duplicate symbol problems in the linker.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-01-09T09:58:03.223", "Score": "2", "CreationDate": "2017-01-09T00:54:57.690", "ParentId": "41539456", "CommentCount": "5", "OwnerUserId": "2630032", "LastEditDate": "2017-05-23T12:07:20.130"}, "41539537": {"Id": "41539537", "PostTypeId": "2", "Body": "<p>You define a global function called <code>hello</code> in base_implementor_1.cpp.  You define another global function called <code>hello</code> in base_implementor_2.cpp.  This results in the multiple definition and the required error for violation of the ODR.  Why is this a problem?  If you have a 3rd source file that calls <code>hello()</code>, which function should be called?</p>\n<p>If you want to define distinct functions with the same name in multiple source files, you can preface them with the <code>static</code> keyword</p>\n<pre><code>static void hello() { }\n</code></pre>\n<p>or within an anonymous namespace</p>\n<pre><code>namespace {\n    void hello() { }\n}\n</code></pre>\n", "LastEditorUserId": "5231607", "LastActivityDate": "2017-01-09T05:26:12.130", "Score": "0", "CreationDate": "2017-01-09T00:45:55.713", "ParentId": "41539456", "CommentCount": "1", "OwnerUserId": "5231607", "LastEditDate": "2017-01-09T05:26:12.130"}});