post_cb({"3895662": {"ParentId": "3895647", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2010-10-09T04:05:29.097", "Score": "13", "LastEditorUserId": "187690", "LastEditDate": "2010-10-09T04:10:32.233", "Id": "3895662", "OwnerUserId": "187690", "Body": "<p>It doesn't really have much to do with the conversion being <em>implicit</em>. Moreover, it doesn't really have much to do with <em>conversions</em>. It is really about <em>rvalues</em> vs. <em>lvalues</em>.</p>\n<p>When you convert <code>99</code> to type <code>X</code>, the result is an <em>rvalue</em>. In C++ results of conversions are always rvalues (unless you convert to reference type). It is illegal in C++ to attach non-const references to rvalues.</p>\n<p>For example, this code will not compile</p>\n<pre><code>X&amp; r = X(99); // ERROR\n</code></pre>\n<p>because it attempts to attach a non-const reference to an rvalue. On the other hand, this code is fine</p>\n<pre><code>const X&amp; cr = X(99); // OK\n</code></pre>\n<p>because it is perfectly OK to attach a const reference to an rvalue.</p>\n<p>The same thing happens in your code as well. The fact that it involves an implicit conversion is kinda beside the point. You can replace implicit conversion with an explicit \none</p>\n<pre><code>implicit_conversion_func(X(99));\n</code></pre>\n<p>and end up with the same situation: with <code>const</code> it compiles, without <code>const</code> it doesn't. </p>\n<p>Again, the only role the conversion (explicit or implicit) plays here is that it helps us to produce an rvalue. In general, you can produce an rvalue in some other way and run into the same issue</p>\n<pre><code>int &amp;ir = 3 + 2; // ERROR\nconst int &amp;cir = 3 + 2; // OK\n</code></pre>\n", "LastActivityDate": "2010-10-09T04:10:32.233"}, "bq_ids": {"n4140": {"so_3895647_3895647_2": {"section_id": 384, "quality": 0.75, "length": 6}, "so_3895647_3895647_1": {"section_id": 3286, "quality": 1.0, "length": 11}}, "n3337": {"so_3895647_3895647_0": {"section_id": 2, "quality": 0.8769230769230769, "length": 57}, "so_3895647_3895647_1": {"section_id": 3156, "quality": 1.0, "length": 11}, "so_3895647_3895647_2": {"section_id": 375, "quality": 0.75, "length": 6}}, "n4659": {"so_3895647_3895647_2": {"section_id": 401, "quality": 0.75, "length": 6}, "so_3895647_3895647_1": {"section_id": 382, "quality": 0.6363636363636364, "length": 7}}}, "3895647": {"CommentCount": "1", "AcceptedAnswerId": "3895662", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2010-10-09T03:58:12.850", "LastActivityDate": "2011-12-27T23:31:40.930", "LastEditDate": "2011-12-23T06:20:25.513", "ViewCount": "2450", "FavoriteCount": "5", "Title": "Why const for implicit conversion?", "Id": "3895647", "Score": "11", "Body": "<p>After extensive reading of <a href=\"http://www.research.att.com/~bs/SC22-N-4411.pdf\" rel=\"nofollow\">ISO/IEC 14882, Programming language \u2013 C++</a> I'm still unsure why <code>const</code> is needed for implicit conversion to a user-defined type with a single argument constructor like the following</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass X {\npublic:\n   X( int value ) {\n      printf(\"constructor initialized with %i\",value);\n   }\n}\n\nvoid implicit_conversion_func( const X&amp; value ) {\n   //produces \"constructor initialized with 99\"\n}\n\nint main (int argc, char * const argv[]) {\n   implicit_conversion_func(99);\n}\n</code></pre>\n<p><br/><br/>\nStarting with section 4 line 3</p>\n<blockquote>\n<p id=\"so_3895647_3895647_0\">An expression e can be implicitly converted to a type T if and only if the declaration T t=e; is well-formed, for some invented temporary variable t (8.5). Certain language constructs require that an expression be converted to a Boolean value. An expression e appearing in such a context is said to be contextually converted to bool and is well-formed if and only if the declaration bool t(e); is well-formed, for some invented temporary variable t (8.5). The effect of either implicit conversion is the same as performing the declaration and initialization and then using the temporary variable as the result of the conversion. The result is an lvalue if T is an lvalue reference type (8.3.2), and an rvalue otherwise. The expression e is used as an lvalue if and only if the initialization uses it as an lvalue.</p>\n</blockquote>\n<p>Following that I found the section on initializers related to user-defined types in 8.5 line 6</p>\n<blockquote>\n<p id=\"so_3895647_3895647_1\">If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type with a user-provided default constructor.</p>\n</blockquote>\n<p>Finally I ended up at 12.3 line 2 about user-defined conversions which states</p>\n<blockquote>\n<p id=\"so_3895647_3895647_2\">User-defined conversions are applied only where they are unambiguous (10.2, 12.3.2).</p>\n</blockquote>\n<p>Needless to say, 10.2 and 12.3.2 didn't answer my question.\n<br/><br/></p>\n<ol>\n<li>Can someone shed some light on what effect <code>const</code> has on implicit conversions?</li>\n<li>Does the use of <code>const</code> make the conversion \"unambiguous\" per 12.3 line 2?</li>\n<li>Does <code>const</code> somehow affect lvalue vs. rvalue talked about in section 4?</li>\n</ol>\n", "Tags": "<c++><constructor><const><implicit-conversion><rvalue>", "OwnerUserId": "418828", "AnswerCount": "2"}, "3895680": {"ParentId": "3895647", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-10-09T04:15:03.450", "Score": "0", "LastEditorUserId": "55637", "LastEditDate": "2011-12-27T23:31:40.930", "Id": "3895680", "OwnerUserId": "55637", "Body": "<p>Per section 5.2.2 paragraph 5, when an argument to a function is of <code>const</code> reference type, a temporary variable is automatically introduced if needed.  In your example, the rvalue result of <code>X(99)</code> has to be put into a temporary variable so that that variable can be passed by <code>const</code> reference to <code>implicit_conversion_func</code>.</p>\n", "LastActivityDate": "2011-12-27T23:31:40.930"}});