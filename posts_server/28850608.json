post_cb({"bq_ids": {"n4140": {"so_28850608_28850776_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 114}}, "n3337": {"so_28850608_28850776_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 109}}, "n4659": {"so_28850608_28850776_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 118}}}, "28850776": {"Id": "28850776", "PostTypeId": "2", "Body": "<p><code>[temp.arg.explicit]/7</code> reads:</p>\n<blockquote>\n<p id=\"so_28850608_28850776_0\">[ <em>Note:</em> Because the explicit template argument list follows the function template name, and because conversion\n  member function templates and constructor member function templates are called without using a\n  function name, there is no way to provide an explicit template argument list for these function templates.\n  <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>So you have to either pass <code>size_t idx</code> as a regular parameter, or add it as <code>struct Foo</code>'s template parameter.</p>\n", "LastActivityDate": "2015-03-04T09:27:06.830", "CommentCount": "2", "CreationDate": "2015-03-04T09:27:06.830", "ParentId": "28850608", "Score": "4", "OwnerUserId": "3959454"}, "28850608": {"ViewCount": "112", "Body": "<p>I am creating a <code>std::tuple</code> equivalent for a <code>union</code> (instead of a <code>struct</code>). To do so, I also added a constructor template, where the first template argument is <code>size_t idx</code>, to initize the idx<sup>th</sup> element of the <code>union</code>. Moreover, there is another <code>variadic template</code> to specify what the argments of the actual type constructor are.</p>\n<p>Unfortunately, I can't seem to specify the <code>idx</code> template argument when calling the constructor, and it is also not implied (as it is not part of the argument list). Is there any way around this? How can I specify a <code>size_t</code> contructor template argument?</p>\n<p>Example code:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nstruct Foo\n{\n    T d_val;\n    size_t d_other_val;\n    template&lt;size_t idx&gt;\n    Foo(T val)\n    {\n        d_val = val;\n        d_other_val = idx;\n    }\n};\n\n\nint main() {\n    Foo&lt;double&gt; f = Foo&lt;4&gt;(2.6);\n\n    std::cout &lt;&lt; f.d_val &lt;&lt; \" \" &lt;&lt; f.d_other_val &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Source: <a href=\"http://ideone.com/UeBvF5\" rel=\"nofollow\">http://ideone.com/UeBvF5</a></p>\n<p>Of course, the 4 is matched on the class template, and not the constructor template. Is this fixable? Note that idx should be a compile time thing, and not a normal constructor argument. Although in this example, that would be the trivial solution.</p>\n<p>PS: the problem of course is, that in general constructor templates are implied by the arguments with which the constructor is called. Implicit specification is to the best of my knowledge not possible for the idx template argument.</p>\n", "AcceptedAnswerId": "28850776", "Title": "Specify integral template argument of constructor template inside a class template", "CreationDate": "2015-03-04T09:18:47.647", "Id": "28850608", "CommentCount": "5", "LastEditDate": "2015-03-04T09:21:48.983", "PostTypeId": "1", "LastEditorUserId": "2659313", "LastActivityDate": "2015-03-04T09:27:06.830", "Score": "1", "OwnerUserId": "853462", "Tags": "<c++><templates><c++11><constructor>", "AnswerCount": "1"}});