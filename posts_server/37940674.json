post_cb({"bq_ids": {"n4140": {"so_37940674_37963648_3": {"length": 7, "quality": 0.6363636363636364, "section_id": 4560}, "so_37940674_37963648_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 4560}, "so_37940674_37963648_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 4643}}, "n3337": {"so_37940674_37963648_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 4390}, "so_37940674_37963648_3": {"length": 7, "quality": 0.6363636363636364, "section_id": 4390}, "so_37940674_37963648_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 4454}}, "n4659": {"so_37940674_37963648_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 5932}, "so_37940674_37963648_3": {"length": 11, "quality": 1.0, "section_id": 5932}, "so_37940674_37963648_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 6014}}}, "37940674": {"ViewCount": "96", "Body": "<p>I've got the following code as an experiment:</p>\n<pre><code>int f1() { return 0; }\n\nstruct Bar {\n    Bar() = delete;\n    int f() { return 0; }\n    int operator()() { return 1; }\n};\n\nint main()\n{\n    decltype(f1()) x = 3;//f1() is expression\n    result_of&lt;decltype(&amp;f1)()&gt;::type x1 = 3;//type+param\n    result_of&lt;Bar()&gt;::type x3 = 3;//type+param\n    decltype(declval&lt;Bar&gt;().f()) y = 4;//expression\n    decltype((((Bar*)nullptr)-&gt;*(&amp;Bar::f))()) z = 5;//expression\n\n    result_of&lt;decltype(std::mem_fn(&amp;Bar::f))()&gt;::type y2 = 3;//error!!!!!!\n}\n</code></pre>\n<p>Everything is OK except the last <code>result_of</code>:\nI was trying to get the return type of <code>Bar::f</code>, using <code>result_of</code>.</p>\n<p>Why it failed, and how to correct it?</p>\n", "Title": "C++11 applies result_of on member function, failed, why?", "CreationDate": "2016-06-21T09:33:26.203", "LastActivityDate": "2016-06-22T09:19:20.660", "CommentCount": "3", "LastEditDate": "2016-06-22T09:19:20.660", "PostTypeId": "1", "LastEditorUserId": "3953764", "Id": "37940674", "Score": "1", "OwnerUserId": "5890784", "Tags": "<c++><c++11><types><decltype><result-of>", "AnswerCount": "1"}, "37963648": {"Id": "37963648", "PostTypeId": "2", "Body": "<p>The <em>unspecified</em> return type of <code>mem_fn</code>:</p>\n<pre>\ntemplate &lt;class R, class T&gt;\n<i>unspecified</i> mem_fn(R T::* pm) noexcept;\n</pre>\n<p>is defined in terms of <code>INVOKE</code> <a href=\"http://eel.is/c++draft/func.memfn#1\" rel=\"nofollow\">[func.memfn]/p1</a>:</p>\n<blockquote>\n<p id=\"so_37940674_37963648_0\"><sup>1</sup> <em>Returns</em>: A simple call wrapper (<a href=\"http://eel.is/c++draft/func.def\" rel=\"nofollow\">[func.def]</a>) <code>fn</code> such that the expression <code>fn(t, a2, ..., aN)</code> is equivalent to <code>INVOKE(pm, t, a2, ..., aN)</code> (<a href=\"http://eel.is/c++draft/func.require\" rel=\"nofollow\">[func.require]</a>).</p>\n</blockquote>\n<p>where the definition of <code>INVOKE</code> includes the following two bullets <a href=\"http://eel.is/c++draft/func.require#1\" rel=\"nofollow\">[func.require]/p1</a>:</p>\n<blockquote>\n<p id=\"so_37940674_37963648_1\">Define <code><i>INVOKE</i>(f, t1, t2, ..., tN)</code> as follows:</p>\n<p id=\"so_37940674_37963648_2\">\u2014 <code>(t1.*f)(t2, ..., tN)</code> when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>is_base_of&lt;T, decay_t&lt;decltype(t1)&gt;&gt;::value</code> is <code>true</code>;</p>\n<p id=\"so_37940674_37963648_3\">\u2014 <code>((*t1).*f)(t2, ..., tN)</code> when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>t1</code> does not satisfy the previous two items;</p>\n</blockquote>\n<p>That is, the first argument of what <code>mem_fn</code> returns must be the type of the implicit object parameter (<code>t1</code>), either a reference or a pointer, e.g.:</p>\n<pre><code>std::result_of&lt;decltype(std::mem_fn(&amp;Bar::f))(Bar&amp;)&gt;::type y2;\n//                                            ~~~^\n\nstd::result_of&lt;decltype(std::mem_fn(&amp;Bar::f))(Bar*)&gt;::type y2;\n//                                            ~~~^\n</code></pre>\n<p>You could also remove <code>std::mem_fn</code> altogether:</p>\n<pre><code>std::result_of&lt;decltype(&amp;Bar::f)(Bar*)&gt;::type y2;\n</code></pre>\n", "LastActivityDate": "2016-06-22T09:17:49.240", "CommentCount": "0", "CreationDate": "2016-06-22T09:17:49.240", "ParentId": "37940674", "Score": "0", "OwnerUserId": "3953764"}});