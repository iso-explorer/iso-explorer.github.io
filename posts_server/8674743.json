post_cb({"8674762": {"ParentId": "8674743", "CommentCount": "0", "Body": "<p>Plain <code>int</code> is equivalent to <code>signed int</code>.  That much is standard.  Anything past that is not guaranteed; <code>int</code> and <code>long</code> are different types, even if your particular compiler makes them the same size.  The only guarantee you have is that a <code>long</code> is <em>at least</em> as big as an <code>int</code>.</p>\n", "OwnerUserId": "319403", "PostTypeId": "2", "Id": "8674762", "Score": "6", "CreationDate": "2011-12-29T23:38:47.423", "LastActivityDate": "2011-12-29T23:38:47.423"}, "8674765": {"ParentId": "8674743", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The <code>long</code> and <code>short</code> modifiers are not exactly like <code>signed</code> and <code>unsigned</code>. The latter two can be put on any integer type, but if you leave them off, then <code>signed</code> is the <em>default</em> for each integer type (except <code>char</code>). So <code>int</code> and <code>signed int</code> are the same type.</p>\n<p>For <code>long</code> and <code>short</code>, if you leave them off, neither is chosen, but the resulting type is different. <code>long int</code>, <code>short int</code> and <code>int</code> are all different types, with <code>short int</code> &lt;= <code>int</code> &lt;= <code>long int</code>.</p>\n<p>The <code>int</code> after <code>long</code>, <code>short</code>, <code>signed</code> and <code>unsigned</code> is optional: <code>signed int</code> and <code>signed</code> are the same type.</p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2011-12-29T23:46:16.197", "Id": "8674765", "Score": "4", "CreationDate": "2011-12-29T23:40:07.197", "LastActivityDate": "2011-12-29T23:46:16.197"}, "8674783": {"ParentId": "8674743", "CommentCount": "0", "Body": "<p>In C++ <code>int</code> is <code>signed int</code> by default, so there is no problem with that. However, <code>int</code> and <code>long int</code> are different types in C++, so this is not the same from the point of view of the language. Implementation of <code>int</code> and <code>long int</code> is platform/compiler specific - they are both integral types which might be identical. The only limitation C++ standard imposes is that <code>sizeof( long int ) &gt;= sizeof( int )</code>.</p>\n", "OwnerUserId": "917249", "PostTypeId": "2", "Id": "8674783", "Score": "2", "CreationDate": "2011-12-29T23:42:30.647", "LastActivityDate": "2011-12-29T23:42:30.647"}, "8674753": {"ParentId": "8674743", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>plain <code>int</code> is signed, whether or not it's the same size as <code>long int</code> is platform-dependent.</p>\n<p>What's guaranteed is that</p>\n<pre><code>sizeof (int) &lt;= sizeof (long)\n</code></pre>\n<p>and <code>int</code> is big enough to hold at least all values from -32767 to 32767.</p>\n<hr>\n<p>What the standard says: (section <code>[basic.fundamental]</code>:</p>\n<blockquote>\n<p id=\"so_8674743_8674753_0\">There are five standard signed integer types : <code>signed  char</code>, <code>short int</code>, <code>int</code>, <code>long  int</code>, and <code>long long int</code>.   In this list, each type provides at least as much storage as those preceding it in the list. There may also be implementation-defined extended signed integer types. The standard and extended signed integer types are collectively called signed integer types.  Plain <code>int</code>s have the natural size suggested by the architecture of the execution environment; the other signed integer types are provided to meet special needs.</p>\n</blockquote>\n</hr>", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2011-12-30T00:39:55.617", "Id": "8674753", "Score": "23", "CreationDate": "2011-12-29T23:37:30.693", "LastActivityDate": "2011-12-30T00:39:55.617"}, "8674743": {"CommentCount": "5", "AcceptedAnswerId": "8674974", "PostTypeId": "1", "LastEditorUserId": "1150778", "CreationDate": "2011-12-29T23:34:56.730", "LastActivityDate": "2011-12-30T02:38:44.400", "LastEditDate": "2011-12-29T23:46:56.103", "ViewCount": "11031", "FavoriteCount": "1", "Title": "Is `int` by default `signed long int` in C++?", "Id": "8674743", "Score": "9", "Body": "<p>Is <code>int</code> by default <code>signed long int</code> in C++?</p>\n<p>Is it platform and/or compiler dependent? If so, how?</p>\n<p>[EDIT]</p>\n<p>Are any of the following guaranteed to be duplicate?</p>\n<pre><code>signed short int\nsigned int\nsigned long int\nsigned long long int\nunsigned short int\nunsigned int\nunsigned long int\nunsigned long long int\n</code></pre>\n", "Tags": "<c++><types>", "OwnerUserId": "1150778", "AnswerCount": "6"}, "8674974": {"ParentId": "8674743", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>All of the integer <strong>types</strong> are different, i.e. you can safely overload functions for all of them and you won't get any conflict. However, some times use the same number of bits for their representation. Even if they use the same number of bits signed and unsigned types always have a different range. Except for <code>char</code>, using any integer type without <code>signed</code> is equivalent to using it with <code>signed</code>, i.e. <code>signed int</code> and <code>int</code> are equivalent. <code>char</code> is a different type as <code>signed char</code> and <code>unsigned char</code> but <code>char</code> has the same representation and range of either <code>signed char</code> or <code>unsigned char</code>. You can use <code>std::numeric_limits&lt;char&gt;::is_signed</code> to find out which it uses.</p>\n<p>On to the more interesting aspects. The following conditions are all true:</p>\n<ul>\n<li><code>7 &lt;= std::numeric_limits&lt;signed char&gt;::digits</code></li>\n<li><code>sizeof(char) == 1</code></li>\n<li><code>sizeof(char) == sizeof(signed char)</code></li>\n<li><code>sizeof(char) == sizeof(unsigned char)</code></li>\n<li><code>15 &lt;= std::numeric_limits&lt;short&gt;::digits</code></li>\n<li><code>sizeof(char) &lt;= sizeof(short)</code></li>\n<li><code>sizeof(short) &lt;= sizeof(int)</code></li>\n<li><code>31 &lt;= std::numeric_limits&lt;long&gt;::digits</code></li>\n<li><code>sizeof(int) &lt;= sizeof(long)</code></li>\n<li><code>63 &lt;= std::numeric_limits&lt;long long&gt;::digits</code></li>\n<li><code>sizeof(long) &lt;= sizeof(long long)</code></li>\n<li><code>sizeof(X) == sizeof(signed X)</code></li>\n<li><code>sizeof(signed X) == sizeof(unsigned X)</code></li>\n</ul>\n<p>(where \"X\" is one of <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, and <code>long long</code>).</p>\n<p>This means that the size of <strong>all</strong> integer types can be the same as long as this types hold at least 64 bits (and apparently the <a href=\"http://en.wikipedia.org/wiki/Cray_X-MP\" rel=\"noreferrer\">Cray X-MP</a> was such a beast). On contemporary machines typically <code>sizeof(int) == sizeof(long)</code> but there are machines where <code>sizeof(int) == sizeof(short)</code>. Whether <code>long</code> is 32 or 64 bits depends on the actual architecture and both kinds are currently around.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "65863", "LastEditDate": "2011-12-30T02:38:44.400", "Id": "8674974", "Score": "8", "CreationDate": "2011-12-30T00:28:47.643", "LastActivityDate": "2011-12-30T02:38:44.400"}, "bq_ids": {"n4140": {"so_8674743_8674753_0": {"section_id": 7211, "quality": 0.9333333333333333, "length": 56}}, "n3337": {"so_8674743_8674753_0": {"section_id": 6955, "quality": 0.9333333333333333, "length": 56}}, "n4659": {"so_8674743_8674753_0": {"section_id": 8720, "quality": 0.9, "length": 54}}}, "8674769": {"ParentId": "8674743", "CommentCount": "0", "Body": "<p><code>signed</code> and <code>int</code> are both the same as <code>signed int</code> by default.</p>\n<p>Neither is the same type as <code>signed short int</code> or <code>signed long int</code>.</p>\n", "OwnerUserId": "541686", "PostTypeId": "2", "Id": "8674769", "Score": "1", "CreationDate": "2011-12-29T23:40:49.010", "LastActivityDate": "2011-12-29T23:40:49.010"}});