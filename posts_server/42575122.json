post_cb({"42575409": {"ParentId": "42575122", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>In addition to the catch-all case regarding UB, towards the end of the list of forbidden expressions in [expr.const] is,</p>\n<blockquote>\n<p id=\"so_42575122_42575409_0\">\u2014 a relational or equality operator where the result is unspecified</p>\n</blockquote>\n<p>This also appears in cppreference list, currently numbered #19.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2017-03-03T12:35:41.127", "Id": "42575409", "Score": "4", "CreationDate": "2017-03-03T09:42:30.860", "LastActivityDate": "2017-03-03T12:35:41.127"}, "42575122": {"CommentCount": "4", "ViewCount": "169", "PostTypeId": "1", "LastEditorUserId": "4324224", "CreationDate": "2017-03-03T09:29:06.170", "LastActivityDate": "2017-03-03T12:35:41.127", "Title": "Can expression using pointers causing unspecified (not undefined!) behaviour be used in constexpr context?", "AcceptedAnswerId": "42575409", "LastEditDate": "2017-03-03T10:39:11.563", "Id": "42575122", "Score": "6", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/language/constant_expression\" rel=\"nofollow noreferrer\">cppreference</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_42575122_42575122_0\">A core constant expression is any expression that does not have any\n  one of the following in any subexpression<br>\n  (...)  </br></p>\n<ol start=\"7\">\n<li>An expression whose evaluation leads to <strong>any form of core language\n  undefined behavior</strong> (including signed integer overflow, division by\n  zero, pointer arithmetic outside array bounds, etc). Whether standard\n  library undefined behavior is detected is unspecified.</li>\n</ol>\n</blockquote>\n<p>On the other hand there are several expressions on pointers with a result that isn't undefined but <strong>unspecified</strong> (cf. <a href=\"http://eel.is/c++draft/expr.rel\" rel=\"nofollow noreferrer\">[expr.rel]/3</a>) e.g.:</p>\n<pre><code>struct A {\n    int v;\n};\n\nstruct B {\n    int v;\n};\n\nstruct C: A, B {} c;\n\nint main() {\n    constexpr bool result = &amp;c.A::v &lt; &amp;c.B::v;\n    (void)result;\n}\n</code></pre>\n<p>The code compiles without issues with <a href=\"http://melpon.org/wandbox/permlink/I4MIxTUIYdL8PXST\" rel=\"nofollow noreferrer\">gcc</a> but not in <a href=\"http://melpon.org/wandbox/permlink/BVpxfRgsxPgQdTJd\" rel=\"nofollow noreferrer\">clang</a> which states what is doubtlessly true that:</p>\n<blockquote>\n<p id=\"so_42575122_42575122_1\">comparison of addresses of subobjects of different base classes has unspecified</p>\n</blockquote>\n<p>But (as I understand it) according to cppreference it should not stop compiler from compiling the code. </p>\n<p>Which compiler is right here - gcc or clang? Am I over-interpreting cppreference?</p>\n", "Tags": "<c++><c++11><language-lawyer><constexpr><unspecified-behavior>", "OwnerUserId": "4324224", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42575122_42575122_1": {"section_id": 477, "quality": 0.5714285714285714, "length": 4}, "so_42575122_42575122_0": {"section_id": 500, "quality": 0.6666666666666666, "length": 6}, "so_42575122_42575409_0": {"section_id": 6185, "quality": 1.0, "length": 6}}, "n3337": {"so_42575122_42575122_1": {"section_id": 468, "quality": 0.5714285714285714, "length": 4}, "so_42575122_42575122_0": {"section_id": 491, "quality": 0.6666666666666666, "length": 6}, "so_42575122_42575409_0": {"section_id": 5946, "quality": 1.0, "length": 6}}, "n4659": {"so_42575122_42575122_1": {"section_id": 500, "quality": 0.5714285714285714, "length": 4}, "so_42575122_42575122_0": {"section_id": 7709, "quality": 0.6666666666666666, "length": 6}, "so_42575122_42575409_0": {"section_id": 7687, "quality": 1.0, "length": 6}}}});