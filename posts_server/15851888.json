post_cb({"15851948": {"ParentId": "15851888", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_15851888_15851948_0\">I got an error when trying to use <code>std::vector::get_allocator()</code> with an non-copyable allocator. </p>\n</blockquote>\n<p>The standard forbids you to do so.  The allocator requirements in <code>17.6.3.5</code> state that an allocator shall be copyable.</p>\n<pre><code>X a1(a);         Shall not exit via an exception.\n                 post: a1 == a\nX a1(move(a));   Shall not exit via an exception.\n                 post: a1 equals the prior value\n                 of a.\n</code></pre>\n<p>So return by value is a correct way of returning an allocator, concerning the allocator requirements defined by the standard.</p>\n<p>I'm not sure <em>why</em> this is a requirement but if noncopyable allocators would have been allowed, the empty base optimization would no more work.</p>\n", "OwnerUserId": "1176973", "PostTypeId": "2", "Id": "15851948", "Score": "7", "CreationDate": "2013-04-06T14:12:53.980", "LastActivityDate": "2013-04-06T14:12:53.980"}, "bq_ids": {"n4140": {"so_15851888_15851978_0": {"section_id": 709, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_15851888_15851978_0": {"section_id": 698, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_15851888_15851978_0": {"section_id": 738, "quality": 0.9047619047619048, "length": 19}}}, "15851888": {"CommentCount": "1", "ViewCount": "716", "PostTypeId": "1", "OwnerDisplayName": "user142019", "CreationDate": "2013-04-06T14:05:01.797", "LastActivityDate": "2013-04-06T14:15:30.790", "Title": "Why does std::vector::get_allocator() return by-value?", "LastEditorDisplayName": "user142019", "LastEditDate": "2013-04-06T14:10:49.600", "Id": "15851888", "Score": "9", "Body": "<p>To my surprise, I got an error when trying to use <code>std::vector::get_allocator()</code> with an non-copyable allocator. Why does <code>std::vector::get_allocator()</code> return by-value and not by-reference?</p>\n<pre><code>template&lt;typename T&gt;\nclass nc_allocator {\npublic:\n    using value_type = T;\n\n    nc_allocator(nc_allocator const&amp;) = delete;\n    nc_allocator&amp; operator=(nc_allocator const&amp;) = delete;\n\n    // Other required members.\n};\n\nstd::vector&lt;int, nc_allocator&lt;int&gt;&gt; v;\n// boom: use of deleted function\n//           'nc_allocator&lt;T&gt;::nc_allocator(const nc_allocator&lt;T&gt;&amp;) [with T = int]'\nv.get_allocator();\n</code></pre>\n", "Tags": "<c++><allocator>", "AnswerCount": "2"}, "15851978": {"ParentId": "15851888", "CommentCount": "3", "Body": "<p>The standard simply dictates so:</p>\n<blockquote>\n<p id=\"so_15851888_15851978_0\"><code>[C++11: 23.2.1/7]:</code> <em>[..]</em> In all container types defined in this Clause, the\n  member get_allocator() returns a copy of the allocator used to construct the container or, if that allocator has been replaced, a copy of the most recent replacement <em>[..]</em></p>\n</blockquote>\n<p>I suspect @Vaughn's correct in his hypothesis that allocators are meant to be used as \"handles\".</p>\n<p>By <em>very</em> loose analogy, would you ever write a non-copyable functor for use with standard algorithms?</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "15851978", "Score": "1", "CreationDate": "2013-04-06T14:15:30.790", "LastActivityDate": "2013-04-06T14:15:30.790"}});