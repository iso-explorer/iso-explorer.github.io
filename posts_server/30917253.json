post_cb({"bq_ids": {"n4140": {"so_30917253_30917254_0": {"length": 30, "quality": 0.5882352941176471, "section_id": 158}}, "n3337": {"so_30917253_30917254_0": {"length": 30, "quality": 0.5882352941176471, "section_id": 152}}, "n4659": {"so_30917253_30917254_0": {"length": 30, "quality": 0.5882352941176471, "section_id": 162}}}, "30917254": {"Id": "30917254", "PostTypeId": "2", "Body": "<p>I can't find any part of the standard that explicitly specifies when redeclarations of class templates (or a class template and its specifier in an out-of-line definition of members) are the same.</p>\n<p>Compilers actually follow the rules for redeclaration of function template, as specified in C++11 14.5.6.1/5+6:</p>\n<blockquote>\n<p id=\"so_30917253_30917254_0\">5 Two expressions involving template parameters are considered <em>equivalent</em> if two function definitions containing the expressions would satisfy the one definition rule (3.2), except [template parameter renaming].\n  6 Two function template are <em>equivalent</em> if they are declared in the same scope, have the same name, have identical template parameter lists, and have return types and parameter lists that are equivalent using the rules described above to compare expressions involving template parameters.</p>\n</blockquote>\n<p>I can't find any rule that makes this apply to expressions in the types of non-type template parameters for redeclarations of class templates, though.</p>\n", "OwnerDisplayName": "Sebastian Redl", "LastActivityDate": "2015-06-15T12:27:41.103", "Score": "2", "CreationDate": "2015-06-15T12:27:41.103", "ParentId": "30917253", "CommentCount": "1", "OwnerUserId": "8922"}, "30917253": {"ViewCount": "68", "Body": "<p>The following compiles runs and executes as expected:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nclass Freaky {\npublic:\n    template&lt;\n        typename UNSIGNED_TYPE,\n        typename std::enable_if&lt;(sizeof(UNSIGNED_TYPE)&gt;=sizeof(int)),int&gt;::type X = 0 \n    &gt;\n    static UNSIGNED_TYPE copyThing(int  x) ;\n};\n\ntemplate&lt;\n    typename UNSIGNED_TYPE,\n    typename std::enable_if&lt;(sizeof(UNSIGNED_TYPE)&gt;=sizeof(int)),int&gt;::type X\n&gt; \nUNSIGNED_TYPE Freaky::copyThing(int x) {\n    UNSIGNED_TYPE r(0);\n    std::memcpy(&amp;r,&amp;x,sizeof(int));//Please ignore. Not the point of the question...\n    return r;   \n}\n\nint main(int argc, char*argv[]) {\n    std::cout &lt;&lt; \"The answer is ... \" &lt;&lt;\n         Freaky::copyThing&lt;unsigned long&gt;(10)&lt;&lt;std::endl;\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>Specimen output (actual output may depend on endian-ness and integer sizes):</p>\n<pre><code>The answer is .... 10\n</code></pre>\n<p>The following won't compile and complains about the prototype for the implementation of <code>copyThing()</code> doesn't match the one declared in the class.</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nclass Freaky {\npublic:\n    template&lt;\n        typename UNSIGNED_TYPE,\n        typename std::enable_if&lt;(sizeof(UNSIGNED_TYPE)&gt;=sizeof(int)),int&gt;::type X = 0 \n    &gt;\n    static UNSIGNED_TYPE copyThing(int  x) ;\n};\n\ntemplate&lt;\n    typename UNSIGNED_TYPE,\n    typename std::enable_if&lt;(sizeof(int)&lt;=sizeof(UNSIGNED_TYPE)),int&gt;::type X\n&gt; \nUNSIGNED_TYPE Freaky::copyThing(int x) {\n    UNSIGNED_TYPE r(0);\n    std::memcpy(&amp;r,&amp;x,sizeof(int));//Please ignore. Not the point of the question...\n    return r;   \n}\n\nint main(int argc, char*argv[]) {\n    std::cout &lt;&lt; \"The answer is ... \" &lt;&lt;\n         Freaky::copyThing&lt;unsigned long&gt;(10)&lt;&lt;std::endl;\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>The only difference between the two is that <code>sizeof(UNSIGNED_TYPE)&gt;=sizeof(int)</code> has been replaced with <code>sizeof(int)&lt;=sizeof(UNSIGNED_TYPE)</code> in that implementation.</p>\n<p>Obviously the two statements are <strong>semantically</strong> equivalent. \nWhere can I find the formal definition of how template prototypes are determined to be equal?</p>\n<p>It's clearly some level of lexical equivalence rather than semantic equivalence.</p>\n", "AcceptedAnswerId": "30917254", "Title": "C++ Template Equivalence of Prototypes", "CreationDate": "2015-06-15T09:27:16.737", "Id": "30917253", "CommentCount": "2", "PostTypeId": "1", "OwnerDisplayName": "Dan Allen", "LastActivityDate": "2015-06-18T13:48:29.077", "Score": "1", "OwnerUserId": "4213662", "Tags": "<c++><c++11><templates><language-specifications>", "AnswerCount": "1"}});