post_cb({"29307521": {"CommentCount": "1", "AcceptedAnswerId": "29307679", "PostTypeId": "1", "LastEditorUserId": "3959454", "CreationDate": "2015-03-27T18:15:36.967", "LastActivityDate": "2015-03-27T20:46:59.040", "LastEditDate": "2015-03-27T20:46:59.040", "ViewCount": "495", "FavoriteCount": "2", "Title": "why is an uninitialized constexpr variable not constant?", "Id": "29307521", "Score": "6", "Body": "<p>I'm not sure if this is a compiler bug or if I misunderstand constexpr:</p>\n<pre><code>struct S{};\nconstexpr S s1{};\nconstexpr S s2;\n\nstruct test{\n    static constexpr auto t1 = s1;\n    static constexpr auto t2 = s2;  //error here\n};\n</code></pre>\n<p>GCC 4.8 is giving me an odd error \"error: field initializer is not constant\". Is s2 really not a constant? If so why?</p>\n<p>For clarity I actually am using a bunch of empty structs in my code (for meta programming <a href=\"https://github.com/porkybrain/Kvasir\" rel=\"nofollow\">https://github.com/porkybrain/Kvasir</a>) so I really am interested in this specific example. </p>\n", "Tags": "<c++><c++11><gcc><constexpr>", "OwnerUserId": "893819", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29307521_29307679_0": {"section_id": 370, "quality": 0.9032258064516129, "length": 28}, "so_29307521_29307679_1": {"section_id": 5425, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_29307521_29307679_0": {"section_id": 360, "quality": 0.9032258064516129, "length": 28}, "so_29307521_29307679_1": {"section_id": 5220, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_29307521_29307679_0": {"section_id": 384, "quality": 0.9032258064516129, "length": 28}, "so_29307521_29307679_1": {"section_id": 6847, "quality": 0.9285714285714286, "length": 13}}}, "29307679": {"ParentId": "29307521", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><strong>Update:</strong> The code should compile, because <code>[class.ctor]/5</code> reads:</p>\n<blockquote>\n<p id=\"so_29307521_29307679_0\">The implicitly-defined default constructor performs the set of initializations of the class that would be performed by a user-written default constructor for that class with no <em>ctor-initializer</em> (12.6.2) and an empty <em>compound-statement</em>. If that user-written default constructor would satisfy the requirements of a <code>constexpr</code> constructor (7.1.5), the implicitly-defined default constructor is <code>constexpr</code>.</p>\n</blockquote>\n<p>And since <code>S</code> is just an empty struct, the implicitly defined default constructor is empty and thus satisfying <code>constexpr</code> requirements.</p>\n<p>So here you are dealing with imperfection of the compilers, which you have to workaround somehow.</p>\n<hr>\n<p>Old answer:</p>\n<p>Clang emits more sensible error message:</p>\n<pre><code>main.cpp:3:13: error: default initialization of an object of const type 'const S' \nrequires a user-provided default constructor\nconstexpr S s2;\n            ^\n</code></pre>\n<p>[dcl.constexpr]/9 provides the explanation and even almost exactly your code as an example:</p>\n<blockquote>\n<p id=\"so_29307521_29307679_1\">A <code>constexpr</code> specifier used in an object declaration declares the object as const. Such an object shall have\n  literal type and shall be initialized.(...)\n  [ <em>Example:</em></p>\n</blockquote>\n<pre><code>struct pixel {\n    int x, y;\n};\nconstexpr pixel ur = { 1294, 1024 };// OK\nconstexpr pixel origin; // error: initializer missing\n</code></pre>\n<blockquote>\n<p id=\"so_29307521_29307679_2\"><em>\u2014end example</em> ]</p>\n</blockquote>\n</hr>", "OwnerUserId": "3959454", "LastEditorUserId": "3959454", "LastEditDate": "2015-03-27T19:27:45.700", "Id": "29307679", "Score": "4", "CreationDate": "2015-03-27T18:25:23.543", "LastActivityDate": "2015-03-27T19:27:45.700"}});