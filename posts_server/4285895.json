post_cb({"4431915": {"Id": "4431915", "PostTypeId": "2", "Body": "<p>The OP's question is nonsense. There is no requirement that the Standard say certain behaviours are undefined, and indeed I would argue that all such wording be removed from the Standard because it confuses people and makes the Standard more verbose than necessary.</p>\n<p>The Standard defines certain behaviour. The question is, does it specify any behaviour in this case? If it does not, the behaviour is undefined whether or not it says so explicitly.</p>\n<p>In fact the specification that some things are undefined is left in the Standard primarily as a debugging aid for the Standards writers, the idea being to generate a contradiction if there is a requirement in one place which conflicts with an explicit statement of undefined behaviour in another: that's a way to prove a defect in the Standard. Without the explicit statement of undefined behaviour, the other clause prescribing behaviour would be normative and unchallenged.</p>\n", "LastActivityDate": "2010-12-13T18:01:50.773", "CommentCount": "1", "CreationDate": "2010-12-13T18:01:50.773", "ParentId": "4285895", "Score": "5", "OwnerUserId": "518287"}, "bq_ids": {"n4140": {"so_4285895_20614158_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 5564}, "so_4285895_30700051_0": {"length": 21, "quality": 1.0, "section_id": 3291}, "so_4285895_20614158_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 5559}, "so_4285895_20614158_4": {"length": 19, "quality": 0.95, "section_id": 6064}, "so_4285895_20614158_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 7230}, "so_4285895_4285991_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 3222}, "so_4285895_30700051_1": {"length": 9, "quality": 1.0, "section_id": 3291}}, "n3337": {"so_4285895_20614158_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 5346}, "so_4285895_4286034_0": {"length": 30, "quality": 0.8333333333333334, "section_id": 5}, "so_4285895_20614158_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 5341}, "so_4285895_20614158_4": {"length": 19, "quality": 0.95, "section_id": 5832}, "so_4285895_30700051_2": {"length": 26, "quality": 1.0, "section_id": 5}, "so_4285895_20614158_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 6974}, "so_4285895_4285991_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 3096}}, "n4659": {"so_4285895_20614158_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 7011}, "so_4285895_30700051_0": {"length": 21, "quality": 1.0, "section_id": 4053}, "so_4285895_20614158_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 7006}, "so_4285895_20614158_4": {"length": 18, "quality": 0.9, "section_id": 7560}, "so_4285895_4285991_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 3979}, "so_4285895_30700051_1": {"length": 9, "quality": 1.0, "section_id": 4053}}}, "30714539": {"Id": "30714539", "PostTypeId": "2", "Body": "<p>Even if the normal storage of something in memory would have no \"room\" for any trap bits or trap representations, implementations are not required to store automatic variables the same way as static-duration variables except when there is a possibility that user code might hold a pointer to them somewhere.  This behavior is most visible with integer types.  On a typical 32-bit system, given the code:</p>\n<pre><code>uint16_t foo(void);\nuint16_t bar(void);\nuint16_t blah(uint32_t q)\n{\n  uint16_t a;\n  if (q &amp; 1) a=foo();\n  if (q &amp; 2) a=bar();\n  return a;\n}\nunsigned short test(void)\n{\n  return blah(65540);\n}\n</code></pre>\n<p>it would not be particularly surprising for <code>test</code> to yield 65540 even though that value is outside the representable range of <code>uint16_t</code>, a type which has no trap representations.  If a local variable of type <code>uint16_t</code> holds Indeterminate Value, there is no requirement that reading it yield a value within the range of <code>uint16_t</code>.  Since unexpected behaviors could result when using even unsigned integers in such fashion, there's no reason to expect that pointers couldn't behave in even worse fashion.</p>\n", "LastActivityDate": "2015-06-08T16:31:40.827", "CommentCount": "0", "CreationDate": "2015-06-08T16:31:40.827", "ParentId": "4285895", "Score": "1", "OwnerUserId": "363751"}, "30700051": {"Id": "30700051", "PostTypeId": "2", "Body": "<p><em>Evaluating</em> an uninitialized pointer causes undefined behaviour.  Since dereferencing the pointer first requires evaluating it, this implies that dereferencing also causes undefined behaviour.</p>\n<p>This was true in both C++11 and C++14, although the wording changed.</p>\n<p>In C++14 it is fully covered by [dcl.init]/12:</p>\n<blockquote>\n<p id=\"so_4285895_30700051_0\">When storage for an object with automatic or dynamic storage duration is obtained, the object has an indeterminate value, and if no initialization is performed for the object, that object retains an indeterminate value until that value is replaced.</p>\n<p id=\"so_4285895_30700051_1\">If an indeterminate value is produced by an evaluation, the behavior is undefined except in the following cases:</p>\n</blockquote>\n<p>where the \"following cases\" are particular operations on <code>unsigned char</code>.</p>\n<hr>\n<p>In C++11, [conv.lval/2] covered this under the lvalue-to-rvalue conversion procedure (i.e. retrieving the pointer value from the storage area denoted by <code>ptr</code>):</p>\n<blockquote>\n<p id=\"so_4285895_30700051_2\">A glvalue of a non-function, non-array type T can be converted to a prvalue. If T is an incomplete type, a program that necessitates this conversion is ill-formed. If the object to which the glvalue refers is not\n  an object of type T and is not an object of a type derived from T, <strong>or if the object is uninitialized,</strong> a program that necessitates this conversion has undefined behavior.</p>\n</blockquote>\n<p>The bolded part was removed for C++14 and replaced with the extra text in [dcl.init/12].</p>\n</hr>", "LastActivityDate": "2015-06-08T01:11:51.837", "CommentCount": "0", "CreationDate": "2015-06-08T01:11:51.837", "ParentId": "4285895", "Score": "3", "OwnerUserId": "1505939"}, "4286034": {"Id": "4286034", "PostTypeId": "2", "Body": "<p>Section 4.1 looks like a candidate (<strong>emphasis mine</strong>):</p>\n<blockquote>\n<p id=\"so_4285895_4286034_0\">An lvalue (3.10) of a\n  non-function, non-array type T can be\n  converted to an rvalue. If T is an\n  incomplete type, a program that\n  necessitates this conversion is\n  ill-formed. If the object to which the\n  lvalue refers is not an object of type\n  T and is not an object of a type\n  derived from T, or <strong>if the object is\n  uninitialized</strong>, a program that\n  necessitates this conversion <strong>has\n  undefined behavior</strong>. If T is a\n  non-class type, the type of the rvalue\n  is the cv-unqualified version of T.\n  Otherwise, the type of the rvalue is\n  T.</p>\n</blockquote>\n<p>I'm sure just searching on \"uninitial\" in the spec can find you more candidates.</p>\n", "LastActivityDate": "2010-11-26T14:18:39.060", "CommentCount": "6", "CreationDate": "2010-11-26T14:18:39.060", "ParentId": "4285895", "Score": "11", "OwnerUserId": "282658"}, "4285895": {"ViewCount": "2805", "Body": "<p>So far I can't find how to deduce that the following:</p>\n<pre><code>int* ptr;\n*ptr = 0;\n</code></pre>\n<p>is undefined behavior.</p>\n<p>First of all, there's 5.3.1/1 that states that <code>*</code> means indirection which converts <code>T*</code> to <code>T</code>. But this doesn't say anything about UB.</p>\n<p>Then there's often quoted 3.7.3.2/4 saying that using deallocation function on a non-null pointer renders the pointer invalid and later usage of the invalid pointer is UB. But in the code above there's nothing about deallocation.</p>\n<p>How can UB be deduced in the code above?</p>\n", "Title": "Where exactly does C++ standard say dereferencing an uninitialized pointer is undefined behavior?", "CreationDate": "2010-11-26T14:01:53.413", "LastActivityDate": "2016-03-28T13:57:00.930", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "Id": "4285895", "Score": "10", "OwnerUserId": "57428", "Tags": "<c++><standards><undefined-behavior><language-lawyer>", "AnswerCount": "7"}, "4285991": {"Id": "4285991", "PostTypeId": "2", "Body": "<p>I'm not going to pretend I know a lot about this, but some compilers would initialize the pointer to NULL and dereferencing a pointer to NULL is UB.</p>\n<p>Also considering that uninitialized pointer could point to anything (this includes NULL) you could concluded that it's UB when you dereference it.</p>\n<p>A note in section 8.3.2 [dcl.ref]</p>\n<blockquote>\n<p id=\"so_4285895_4285991_0\">[Note: in particular, a null reference\n  cannot exist in a well-defined\n  program, because the only way to\n  create such a reference would be to\n  bind it to the \u201cobject\u201d obtained by\n  <strong>dereferencing a null pointer, which\n  causes undefined behavior</strong>. As\n  described in 9.6, a reference cannot\n  be bound directly to a bitfield. ]</p>\n</blockquote>\n<p>\u2014ISO/IEC 14882:1998(E), the ISO C++ standard, in section 8.3.2 [dcl.ref]</p>\n<p>I think I should have written this as comment instead, I'm not really that sure.</p>\n", "LastEditorUserId": "54091", "LastActivityDate": "2010-11-26T14:22:49.507", "Score": "3", "CreationDate": "2010-11-26T14:13:52.423", "ParentId": "4285895", "CommentCount": "7", "OwnerUserId": "54091", "LastEditDate": "2010-11-26T14:22:49.507"}, "4286187": {"Id": "4286187", "PostTypeId": "2", "Body": "<p>To dereference the pointer, you need to read from the pointer variable (not talking about the object it points to). Reading from an uninitialized variable is undefined behaviour.</p>\n<p>What you do with the value of pointer after you have read it, doesn't matter anymore at this point, be it writing to (like in your example) or reading from the object it points to.</p>\n", "LastActivityDate": "2010-11-26T14:41:28.553", "CommentCount": "0", "CreationDate": "2010-11-26T14:41:28.553", "ParentId": "4285895", "Score": "3", "OwnerUserId": "154980"}, "20614158": {"Id": "20614158", "PostTypeId": "2", "Body": "<p>I found the answer to this question is a unexpected corner of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\">C++ draft standard</a>, section <code>24.2</code> <em>Iterator requirements</em>, specifically section <code>24.2.1</code> <em>In general</em> paragraph <em>5</em> and <em>10</em>  which respectively say (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_4285895_20614158_0\">[...][ Example: After the declaration of an <strong>uninitialized pointer</strong> x (as with int* x;), x <strong>must always be assumed to have a singular value of a pointer</strong>. \u2014end example ] [...] <strong>Dereferenceable values are always non-singular.</strong></p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_4285895_20614158_1\">An invalid iterator is an iterator that may be singular.<sup>268</sup></p>\n</blockquote>\n<p>and footnote <code>268</code> says:</p>\n<blockquote>\n<p id=\"so_4285895_20614158_2\">This definition applies to pointers, <strong>since pointers are iterators</strong>. The effect of dereferencing an iterator that has been invalidated is undefined.</p>\n</blockquote>\n<p>Although it does look like there is some controversy over <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-unresolved.html#1213\">whether a null pointer is singular or not</a> and it looks like the term <em>singular value</em> needs to be properly defined in a more general manner.</p>\n<p>The intent of <em>singular</em> is seems to be summed up well in defect report <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278\">278. What does iterator validity mean?</a> under the rationale section which says:</p>\n<blockquote>\n<p id=\"so_4285895_20614158_3\">Why do we say <strong>\"may be singular\"</strong>, instead of \"is singular\"? That's becuase a <strong>valid iterator is one that is known to be nonsingular</strong>. Invalidating an iterator means changing it in such a way that it's no longer known to be nonsingular. An example: inserting an element into the middle of a vector is correctly said to invalidate all iterators pointing into the vector. That <strong>doesn't necessarily mean they all become singular</strong>.</p>\n</blockquote>\n<p>So <em>invalidation</em> and being <em>uninitialized</em> <code>may</code> create a value that is <em>singular</em> but since we can not prove they are <em>nonsingular</em> we must assume they are <em>singular</em>. </p>\n<p><b>Update</b></p>\n<p>An alternative common sense approach would be to note that the draft standard section <code>5.3.1</code> <em>Unary operators</em> paragraph <em>1</em> which says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_4285895_20614158_4\">The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and <strong>the result is an lvalue referring to the object</strong> or function to which the expression points.[...]</p>\n</blockquote>\n<p>and if we then go to section <code>3.10</code> <em>Lvalues and rvalues</em> paragraph <em>1</em> says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_4285895_20614158_5\">An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object. [...]</p>\n</blockquote>\n<p>but <code>ptr</code> will not, except by chance, point to a valid <em>object</em>.</p>\n", "LastEditorUserId": "213489", "LastActivityDate": "2014-01-19T05:55:38.627", "Score": "6", "CreationDate": "2013-12-16T15:10:49.513", "ParentId": "4285895", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-01-19T05:55:38.627"}});