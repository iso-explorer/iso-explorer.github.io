post_cb({"bq_ids": {"n4140": {"so_35139114_35139114_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 3321}, "so_35139114_35139114_0": {"length": 19, "quality": 0.95, "section_id": 6169}, "so_35139114_35140295_0": {"length": 14, "quality": 1.0, "section_id": 3321}}, "n3337": {"so_35139114_35139114_1": {"length": 22, "quality": 1.0, "section_id": 3191}, "so_35139114_35139114_0": {"length": 19, "quality": 0.95, "section_id": 5930}, "so_35139114_35140295_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3191}}, "n4659": {"so_35139114_35139114_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 4087}, "so_35139114_35139114_0": {"length": 11, "quality": 0.55, "section_id": 7667}, "so_35139114_35140295_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 4087}}}, "35139114": {"ViewCount": "225", "Body": "<p>I'm looking at the standard 5.16 paragraph 3, trying to understand what is going on.  Consider the type <code>M</code> defined as</p>\n<pre><code>struct M {\n  M();\n  M(const M&amp;);\n  M(M&amp;&amp;);\n};\n</code></pre>\n<p>If I have a ternary expression <code>pred ? E1 : E2</code>, where the type of <code>E1</code> is <code>const M&amp;</code> and the type of <code>E2</code> is <code>M&amp;&amp;</code> does 5.16 paragraph 3 bullet 1 apply?</p>\n<blockquote>\n<p id=\"so_35139114_35139114_0\">\u2014 If E2 is an lvalue: E1 can be converted to match E2 if E1 can be implicitly converted (Clause 4) to the\n  type \u201clvalue reference to T2\u201d, subject to the constraint that in the conversion the reference must bind\n  directly (8.5.3) to an lvalue.</p>\n</blockquote>\n<p>I think it doesn't, because to have an implicit conversion to <code>const M&amp;</code>, which requires <code>M</code> to have the member function <code>operator const M&amp;()</code>.\nHowever, I'm not sure, because it could be converted to <code>const M</code> implicitly, can the reference be implicitly added?</p>\n<p>If it is implicitly convertible, does <code>M&amp;&amp;</code> bind directly to <code>const M&amp;</code>?\nI went through the procedure in 8.5.3, and I think that paragraph 5 bullet 2 is where this case falls, so it does bind directly, but I'm not certain.</p>\n<blockquote>\n<p id=\"so_35139114_35139114_1\">\u2014 If the initializer expression [..] has a class type (i.e., T2 is a class type), where T1 is not reference-related to T2, and can be\n  implicitly converted to an xvalue, class prvalue, or function lvalue of type \u201ccv3 T3\u201d, where\n  \u201ccv1 T1\u201d is reference-compatible with \u201ccv3 T3\u201d</p>\n</blockquote>\n", "AcceptedAnswerId": "35140295", "Title": "Implicit conversion to lvalue reference", "CreationDate": "2016-02-01T19:52:52.903", "Id": "35139114", "CommentCount": "4", "LastEditDate": "2016-02-01T20:57:07.097", "PostTypeId": "1", "LastEditorUserId": "3163831", "LastActivityDate": "2016-02-01T21:04:14.093", "Score": "4", "OwnerUserId": "3163831", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "1"}, "35140295": {"Id": "35140295", "PostTypeId": "2", "Body": "<p>You don't have expressions of type <code>M&amp;&amp;</code>, instead it would be adjusted to be an <em>xvalue of type <code>M</code></em>.</p>\n<p>So the question is: if you have an xvalue of type <code>M</code>, can it be implicitly converted to lvalue reference to <code>const M</code>? The answer is yes, since a const lvalue reference can be initialized with an rvalue. Such a reference binding is direct since it falls under the following case:</p>\n<blockquote>\n<p id=\"so_35139114_35140295_0\">If the initializer expression\n  \u2014 is an xvalue (but not a bit-field), class prvalue, array prvalue or function lvalue and \u201c<em>cv1</em> <code>T1</code>\u201d\n  is reference-compatible with \u201c<em>cv2</em> <code>T2</code>\u201d, ...</p>\n</blockquote>\n<p>rather than the last case that involves construction of a temporary, which is the indirect binding case.</p>\n<p>Therefore this use of the conditional operator will be well-formed. The xvalue of type <code>M</code> will be converted to an lvalue of type <code>const M</code>. Then the lvalue-to-rvalue conversion will be applied and the result will be a prvalue of type <code>const M</code>.</p>\n", "LastActivityDate": "2016-02-01T21:04:14.093", "Score": "5", "CreationDate": "2016-02-01T21:04:14.093", "ParentId": "35139114", "CommentCount": "2", "OwnerUserId": "481267"}});