post_cb({"704780": {"ViewCount": "1373", "Body": "<p>In an answer to <a href=\"https://stackoverflow.com/questions/700588/is-it-safe-to-store-objects-of-a-class-which-has-an-stdautoptr-as-its-member-v\">Is it safe to store objects of a class which has an std::auto_ptr as its member variable in std::vector?</a> I stated that a class that contained  an auto_ptr could be stored in a vector <strong>provided the class had a user-defined copy constructor</strong>.</p>\n<p>There were several comment suggesting that this was not the case, so this question is an attempt to clear the issue up. Consider the following code:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct Z {};\n\nstruct A {\n\n    A( Z z ) \n        : p( new Z(z) ) {} \n\n    A( const A &amp; a ) \n        : p( a.p.get() ? new Z( *a.p.get()) : 0 ) {}\n\n    // no assigment op or dtor defined by intent\n\n    auto_ptr &lt;Z&gt; p;\n};\n\nint main() {\n    vector &lt;A&gt; av;              \n    Z z;                    \n    A a(z);\n    av.push_back( a );      \n    av.push_back( A(z) );   \n    av.clear();             \n}                           \n</code></pre>\n<p>Please examine the above &amp; in your reply indicate where undefined \nbehaviour in the meaning of the C++ Standard could occur for this particular class used in this particular way. I am not interested whether the class is useful, well-behaved, sortable, or how it performs under exceptions.</p>\n<p><strong>Please also note that this is not  a question about the validity of creating a vector of auto_ptrs - I am well aware of the issues regarding that.</strong></p>\n<blockquote>\n<p id=\"so_704780_704780_0\">Thanks all for your inputs on what in\n  retrospect is probably a rather silly\n  question. I guess I focussed too much\n  on the copy ctor &amp; forgot about\n  assignment. The lucky winner of my\n  acceptance points (and points mean\n  prizes!) is <strong>litb</strong> for a typically\n  exhaustive explanation (sorry\n  earwicker)</p>\n</blockquote>\n", "AcceptedAnswerId": "705611", "Title": "Class containing auto_ptr stored in vector", "CreationDate": "2009-04-01T09:35:09.763", "LastActivityDate": "2009-05-23T08:59:52.753", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:32:49.587", "LastEditorDisplayName": "Neil Butterworth", "OwnerDisplayName": "anon", "LastEditorUserId": "-1", "Id": "704780", "Score": "3", "Tags": "<c++><stl>", "AnswerCount": "5"}, "705166": {"Id": "705166", "PostTypeId": "2", "Body": "<p>What about the following?</p>\n<pre><code>cout &lt;&lt; av[ 0 ] &lt;&lt; endl;\n</code></pre>\n<p>Also, conceptually, a copy should leave the item copied from unchanged. This is being violated in your implementation.</p>\n<p>(It is quite another thing that your original code compiles fine with <code>g++ -pedantic ...</code> and Comeau but not VS2005.)</p>\n", "OwnerDisplayName": "dirkgently", "LastActivityDate": "2009-04-01T11:57:13.963", "Score": "0", "CreationDate": "2009-04-01T11:57:13.963", "ParentId": "704780", "CommentCount": "4", "OwnerUserId": "66692"}, "705611": {"Body": "<p>Trying to put the list of places together that makes the example undefined behavior.</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct Z {};\n\nstruct A {\n\n    A( Z z ) \n        : p( new Z(z) ) {} \n\n    A( const A &amp; a ) \n        : p( a.p.get() ? new Z( *a.p.get()) : 0 ) {}\n\n    // no assigment op or dtor defined by intent\n\n    auto_ptr &lt;Z&gt; p;\n};\n\nint main() {\n    vector &lt;A&gt; av;  \n    ...\n}\n</code></pre>\n<p>I will examine the lines up to the one where you instantiate the vector with your type <code>A</code>. The Standard has to say</p>\n<p>In <code>23.1/3</code>:</p>\n<blockquote>\n<p id=\"so_704780_705611_0\">The type of objects stored in these components must meet the requirements of CopyConstructible types (20.1.3), and the additional requirements of Assignable types.</p>\n</blockquote>\n<p>In <code>23.1/4</code> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_704780_705611_1\">In Table 64, T is the type used to instantiate the container, t is a value of T, and u is a value of (<em>possibly const</em>) T.</p>\n<pre><code>+-----------+---------------+---------------------+\n|expression |return type    |postcondition        |\n+-----------+---------------+---------------------+\n|t = u      |T&amp;             |t is equivalent to u |\n+-----------+---------------+---------------------+\n</code></pre>\n<p id=\"so_704780_705611_2\">Table 64</p>\n</blockquote>\n<p>In <code>12.8/10</code>:</p>\n<blockquote>\n<p id=\"so_704780_705611_3\">If the class definition does not explicitly declare a copy assignment operator, one is declared implicitly. The implicitly-declared copy assignment operator for a class X will have the form</p>\n<pre><code>X&amp; X::operator=(const X&amp;)\n</code></pre>\n<p id=\"so_704780_705611_4\">if</p>\n<ul>\n<li>each direct base class B of X has a copy assignment operator whose parameter is of type const B&amp;,\n  const volatile B&amp; or B, and</li>\n<li>for all the nonstatic data members of X that are of a class type M (or array thereof), each such class type has a copy assignment operator whose parameter is of type const M&amp;, const volatile M&amp; or M.</li>\n</ul>\n<p id=\"so_704780_705611_5\">Otherwise, the implicitly declared copy assignment operator will have the form</p>\n<pre><code>X&amp; X::operator=(X&amp;)\n</code></pre>\n</blockquote>\n<p>(Note the last and second last sentence)</p>\n<p>In <code>17.4.3.6/1 and /2</code>:</p>\n<blockquote>\n<p id=\"so_704780_705611_6\">In certain cases (replacement functions, handler functions, operations on types used to instantiate standard library template components), the C++ Standard Library depends on components supplied by a C++ program. If these components do not meet their requirements, the Standard places no requirements on the implementation.</p>\n<p id=\"so_704780_705611_7\">In particular, the effects are undefined in the following cases:</p>\n<ul>\n<li>for types used as template arguments when instantiating a template component, if the operations on the type do not implement the semantics of the applicable Requirements subclause (20.1.5, 23.1, 24.1, 26.1). Operations on such types can report a failure by throwing an exception unless otherwise specified.</li>\n</ul>\n</blockquote>\n<p>Now, if you look at the specification of <code>auto_ptr</code> you will note it has a copy-assignment operator that takes a non-const <code>auto_ptr</code>. Thus, the implicitly declared copy assignment operator of your class will <em>also</em> take a non-const type as its parameter. If you read the above places carefully, you will see how it says that instantiating a vector with your type as written is undefined behavior. </p>\n", "CreationDate": "2009-04-01T13:57:15.250", "ParentId": "704780", "CommentCount": "4", "LastEditDate": "2009-04-01T14:38:57.273", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2009-04-01T14:38:57.273", "LastEditorUserId": "34509", "Id": "705611", "OwnerDisplayName": "litb", "Score": "3", "OwnerUserId": "34509"}, "705153": {"Id": "705153", "PostTypeId": "2", "Body": "<p>I don't think it's necessarily the case that the above code will even compile. Surely the implementor of <code>std::vector</code> is at liberty to require an assignment operator to be available, from <code>const A&amp;</code>?</p>\n<p>And having just tried it, it doesn't compile on Visual Studio C++ 2008 Service Pack 1:</p>\n<blockquote>\n<p id=\"so_704780_705153_0\">binary '=' : no operator found which\n  takes a right-hand operand of type\n  'const A' (or there is no acceptable\n  conversion)</p>\n</blockquote>\n<p>My guess is that, on the guidance of Herb Sutter, the container classes in VC++ make every effort to impose the standard requirements on their type parameters, specifically to make it hard to use <code>auto_ptr</code> with them. They may have overstepped the boundaries set by the standard of course, but I seem to remember it mandating true assignment as well as true copy construction.</p>\n<p>It does compile in g++ 3.4.5, however.</p>\n", "OwnerDisplayName": "Earwicker", "LastActivityDate": "2009-04-01T11:51:44.100", "Score": "3", "CreationDate": "2009-04-01T11:51:44.100", "ParentId": "704780", "CommentCount": "6", "OwnerUserId": "27423"}, "bq_ids": {"n4140": {"so_704780_705611_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 467}, "so_704780_705611_6": {"length": 22, "quality": 0.88, "section_id": 6323}, "so_704780_705611_7": {"length": 5, "quality": 1.0, "section_id": 6324}, "so_704780_705611_3": {"length": 19, "quality": 0.95, "section_id": 467}, "so_704780_705611_1": {"length": 5, "quality": 0.625, "section_id": 763}}, "n3337": {"so_704780_705611_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 458}, "so_704780_705611_6": {"length": 22, "quality": 0.88, "section_id": 6080}, "so_704780_705611_1": {"length": 5, "quality": 0.625, "section_id": 750}, "so_704780_705611_7": {"length": 5, "quality": 1.0, "section_id": 6081}, "so_704780_705611_3": {"length": 19, "quality": 0.95, "section_id": 458}}, "n4659": {"so_704780_705611_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 490}, "so_704780_705611_6": {"length": 22, "quality": 0.88, "section_id": 7833}, "so_704780_705611_1": {"length": 5, "quality": 0.625, "section_id": 823}, "so_704780_705611_7": {"length": 5, "quality": 1.0, "section_id": 7834}, "so_704780_705611_3": {"length": 19, "quality": 0.95, "section_id": 490}}}, "705543": {"Body": "<p>Objects stored in containers are required to be \"CopyConstructable\" as well as \"Assignable\" (C++2008 23.1/3).</p>\n<p>Your class tries to deal with the CopyConstructable requirement (though I'd argue it still doesn't meet it - I edited that argument out since it's not required and because it's arguable I suppose), but it doesn't deal with the Assignable requirement. To be Assignable (C++2008 23.1/4), the following must be true where <code>t</code> is a value of <code>T</code> and <code>u</code> is a value of (possibly <code>const</code>) <code>T</code>:</p>\n<blockquote>\n<p id=\"so_704780_705543_0\"><code>t = u</code>  returns a <code>T&amp;</code>  and <code>t</code> is equivalent to <code>u</code></p>\n</blockquote>\n<p>The standard also says in a note (20.4.5/3): \"<code>auto_ptr</code> does not meet the CopyConstructible and Assignable requirements for Standard Library container elements and thus instantiating a Standard Library container with an <code>auto_ptr</code> results in undefined behavior.\"</p>\n<p>Since you don't declare or define an assignment operator, an implicit one will be provided that uses the <code>auto_ptr</code>'s assignment operator, which definitely makes <code>t</code> not equivalent to <code>u</code>, not to mention that it won't work at all for \"<code>const T u</code>\" values (which is what <a href=\"https://stackoverflow.com/questions/704780/class-containing-autoptr-stored-in-vector/705153#705153\">Earwicker's answer</a> points out - I'm just pointing out the exact portion(s) of the standard).</p>\n", "CreationDate": "2009-04-01T13:43:42.087", "ParentId": "704780", "CommentCount": "0", "LastEditDate": "2017-05-23T12:03:00.070", "PostTypeId": "2", "LastEditorDisplayName": "Michael Burr", "LastActivityDate": "2009-04-01T14:28:07.330", "LastEditorUserId": "-1", "Id": "705543", "OwnerDisplayName": "Michael Burr", "Score": "4", "OwnerUserId": "12711"}, "704867": {"Id": "704867", "PostTypeId": "2", "Body": "<p>Since the regular <code>auto_ptr</code> semantic could suggests that the ownership is passed during the copying, I would rather use here <code>boost::scoped_ptr</code>. Of course the assignment operator is missing.</p>\n", "OwnerDisplayName": "o-l-o", "LastActivityDate": "2009-04-01T10:05:20.643", "Score": "0", "CreationDate": "2009-04-01T10:05:20.643", "ParentId": "704780", "CommentCount": "0", "OwnerUserId": "76857"}});