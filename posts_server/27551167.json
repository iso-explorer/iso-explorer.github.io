post_cb({"bq_ids": {"n4140": {"so_27551167_27551413_0": {"length": 107, "quality": 0.9469026548672567, "section_id": 5340}}, "n3337": {"so_27551167_27551413_0": {"length": 71, "quality": 0.6283185840707964, "section_id": 5137}}, "n4659": {"so_27551167_27551413_0": {"length": 98, "quality": 0.8672566371681416, "section_id": 6761}}}, "27551217": {"Id": "27551217", "PostTypeId": "2", "Body": "<p>Short answer: <strong>there isn't one</strong>.</p>\n<p>Long answer:\nEndianness is never exposed directly in the code unless you really try to get it out (such as using pointer tricks). <code>0b0111</code> is 7, it's the same rules as hex, writing</p>\n<pre class=\"lang-c prettyprint-override\"><code>int i = 0xAA77;\n</code></pre>\n<p>doesn't mean <code>0x77AA</code> on some platforms because that would be absurd.  Where would the extra 0s that are missing go anyway? would they get padded on the front, then the whole thing flipped, or would they get added after?  I have no idea what someone would expect if that were the case.</p>\n<p>The point is that C++ doesn't make any assumptions about the endianness of the machine, if you write code using primitives and the literals it provides, the behavior will be the same from machine to machine (unless you start circumventing the type system, which you may need to do)</p>\n<p><em>To address your update:</em> the number will be the way you write it out.  The bits will not be reordered or any such thing, the most significant bit is on the left and the least significant bit is on the right.</p>\n<hr>\n<p><strong>There seems to be a misunderstanding here about what endianness is</strong>.  Endianness refers to how <strong>bytes</strong> are ordered in memory and how they must be interpretted.  If I gave you the number \"4172\" and said \"if this is four-thousand one-hundred seventy-two, what is the endianness\" you can't really give an answer because the question doesn't make sense.  (<em>some might argue that the largest digit on the left means big endian, but without memory addresses the question of endianness is not answerable r relevant</em>).  This is just a number, there are no bytes to interpret, there are no memory addresses.  Assuming 4 byte integer representation, the bytes that correspond to it are:</p>\n<pre class=\"lang-none prettyprint-override\"><code>        low address ----&gt; high address\nBig endian:    00 00 10 4c\nLittle endian: 4c 10 00 00\n</code></pre>\n<p>so, given either of those and told \"this is the computer's internal representation of 4172\" you could determine if its little or big endian.</p>\n<p>So now consider your binary literal <code>0b0111</code>  these 4 bits represent one nybble, and can be stored as either</p>\n<pre class=\"lang-none prettyprint-override\"><code>              low ---&gt; high\nBig endian:    00 00 00 07\nLittle endian: 07 00 00 00\n</code></pre>\n<p>But you don't have to care because this is also handled by the hardware, the language dictates that the compiler reads from left to right, most significant bit to least significant bit</p>\n<p><strong>Endianness is not about individual bits</strong>. Given that a byte is 8 bits, if I hand you <code>0b00000111</code> and say \"is this little or big endian?\" again you can't say because you only have one byte.  Endianness doesn't reorder bits in a byte, refers to the reordering of entire bytes (unless of course you have one-bit bytes).</p>\n<p>You don't have to care about what your computer is using internally.  <code>0b0111</code> just saves you the time from having to write stuff like</p>\n<pre><code>unsigned int mask = 7 // only keep the lowest 3 bits\n</code></pre>\n<p>by writing</p>\n<pre><code>unsigned int mask = 0b0111;\n</code></pre>\n<p>Without needing to comment explaining the significance of the number.</p>\n</hr>", "LastEditorUserId": "1013719", "LastActivityDate": "2017-08-13T22:07:02.657", "Score": "69", "CreationDate": "2014-12-18T16:23:53.380", "ParentId": "27551167", "CommentCount": "20", "OwnerUserId": "1013719", "LastEditDate": "2017-08-13T22:07:02.657"}, "27551413": {"Id": "27551413", "PostTypeId": "2", "Body": "<p><strong><em>All integer literals, including binary ones are interpreted in the same way as we normally read numbers (left most digit being most significant).</em></strong></p>\n<p><em>The C++ standard guarantees the same interpretation of literals without having to be concerned with the specific environment you're on.</em> Thus, you don't have to concern yourself with endianness in this context.</p>\n<p>Your example of <code>0b0111</code> is always equal to seven.</p>\n<p>The C++ standard doesn't use terms of endianness in regards to number literals. Rather, it simply describes that literals have a consistent interpretation, and that the interpretation is the one you would expect.</p>\n<p><strong><em>C++ Standard - Integer Literals - 2.14.2 - paragraph 1</em></strong></p>\n<blockquote>\n<p id=\"so_27551167_27551413_0\">An integer literal is a sequence of digits that has no period or\n  exponent part, with optional separating single quotes that are ignored\n  when determining its value. An integer literal may have a prefix that\n  specifies its base and a suffix that specifies its type. <strong>The lexically\n  first digit of the sequence of digits is the most significant. A\n  binary integer literal (base two) begins with 0b or 0B and consists of\n  a sequence of binary digits.</strong> An octal integer literal (base eight)\n  begins with the digit 0 and consists of a sequence of octal digits.\n  A decimal integer literal (base ten) begins with a digit other than 0\n  and consists of a sequence of decimal digits. A hexadecimal integer\n  literal (base sixteen) begins with 0x or 0X and consists of a sequence\n  of hexadecimal digits, which include the decimal digits and the\n  letters a through f and A through F with decimal values ten through\n  fifteen. [Example: The number twelve can be written 12, 014, 0XC, or\n  0b1100. The literals 1048576, 1\u2019048\u2019576, 0X100000, 0x10\u20190000, and\n  0\u2019004\u2019000\u2019000 all have the same value. \u2014 end example ]</p>\n</blockquote>\n<p><a href=\"http://en.wikipedia.org/wiki/Endianness\" rel=\"noreferrer\">Wikipedia describes what endianness is, and uses our number system as an example to understand <em>big-endian</em>.</a></p>\n<blockquote>\n<p id=\"so_27551167_27551413_1\">The terms endian and endianness refer to the convention used to\n  interpret the bytes making up a data word when those bytes are stored\n  in computer memory.</p>\n<p id=\"so_27551167_27551413_2\"><strong>Big-endian systems store the most significant byte of a word in the\n  smallest address and the least significant byte is stored in the\n  largest address</strong> (also see Most significant bit). Little-endian\n  systems, in contrast, store the least significant byte in the smallest\n  address.</p>\n<p id=\"so_27551167_27551413_3\">An example on endianness is to think of how a decimal number is\n  written and read in place-value notation. Assuming a writing system\n  where numbers are written left to right, the leftmost position is\n  analogous to the smallest address of memory used, and rightmost\n  position the largest. For example, the number one hundred twenty three\n  is written 1 2 3, with the hundreds place left-most. <strong>Anyone who reads\n  this number also knows that the leftmost digit has the biggest place\n  value. This is an example of a big-endian convention followed in daily\n  life.</strong></p>\n</blockquote>\n<p>In this context, we are considering a digit of an integer literal to be a \"byte of a word\", and the word to be the literal itself. Also, the left-most character in a literal is considered to have the smallest address.</p>\n<p>With the literal <code>1234</code>, the digits one, two, three and four are the \"bytes of a word\", and <code>1234</code> is the \"word\". With the binary literal <code>0b0111</code>, the digits zero, one, one and one are the \"bytes of a word\", and the word is <code>0111</code>.</p>\n<p>This consideration allows us to understand endianness in the context of the C++ language, and shows that integer literals are similar to \"big-endian\".</p>\n", "LastEditorUserId": "3561240", "LastActivityDate": "2014-12-19T03:33:00.943", "Score": "39", "CreationDate": "2014-12-18T16:34:57.313", "ParentId": "27551167", "CommentCount": "7", "OwnerUserId": "3561240", "LastEditDate": "2014-12-19T03:33:00.943"}, "27552222": {"Id": "27552222", "PostTypeId": "2", "Body": "<p>The C/C++ languages don't care about endianness of multi-byte integers. C/C++ compilers do. Compilers parse your source code and generate machine code for the specific target platform. The compiler, in general, stores integer literals the same way it stores an integer; such that the target CPU's instructions will directly support reading and writing them in memory.</p>\n<p>The compiler takes care of the differences between target platforms so you don't have to.</p>\n<p>The only time you need to worry about endianness is when you are sharing binary values with other systems that have different byte ordering.Then you would read the binary data in, byte by byte, and arrange the bytes in memory in the correct order for the system that your code is running on. </p>\n", "LastActivityDate": "2014-12-18T17:22:22.407", "CommentCount": "5", "CreationDate": "2014-12-18T17:22:22.407", "ParentId": "27551167", "Score": "7", "OwnerUserId": "2591820"}, "27553122": {"Id": "27553122", "PostTypeId": "2", "Body": "<p>You might want to think about C or C++ or any other language as being intrinsically little endian (think about how the bitwise operators work). If the underlying HW is big endian, the compiler ensures that the data is stored in big endian (ditto for other endianness) however your bit wise operations work as if the data is little endian. Thing to remember is that as far as the language is concerned, data is in little endian. Endianness related problems arise when you cast the data from one type to the other. As long as you don't do that you are good.</p>\n<p>I was questioned about the statement \"C/C++ language as being intrinsically little endian\", as such I am providing an example which many knows how it works but well here I go.</p>\n<pre><code>typedef union\n{\n    struct {\n        int a:1;\n        int reserved:31;\n    } bits;\n\n    unsigned int value;\n} u;\n\nu test;\ntest.bits.a = 1;\ntest.bits.reserved = 0;\n\nprintf(\"After bits assignment, test.value = 0x%08X\\n\", test.value);\n\ntest.value = 0x00000001;\n\nprintf(\"After value assignment, test.value = 0x%08X\\n\", test.value);\n</code></pre>\n<p>Output on a little endian system:</p>\n<pre><code>After bits assignment, test.value = 0x00000001\nAfter value assignment, test.value = 0x00000001\n</code></pre>\n<p>Output on a big endian system:</p>\n<pre><code>After bits assignment, test.value = 0x80000000\nAfter value assignment, test.value = 0x00000001\n</code></pre>\n<p>So, <strong>if you do not know the processor's endianness</strong>, where does everything come out right? in the little endian system! Thus, I say that the C/C++ language is intrinsically little endian.</p>\n", "LastEditorUserId": "2623102", "LastActivityDate": "2014-12-18T22:11:16.420", "Score": "-6", "CreationDate": "2014-12-18T18:17:23.013", "ParentId": "27551167", "CommentCount": "2", "OwnerUserId": "2623102", "LastEditDate": "2014-12-18T22:11:16.420"}, "27587921": {"Id": "27587921", "PostTypeId": "2", "Body": "<p>in adition I will say even compiler take no care about, for example in LLVM platform only the backend (technically not a compiler) will take care of endianess.</p>\n", "LastActivityDate": "2014-12-21T08:45:53.900", "CommentCount": "0", "CreationDate": "2014-12-21T08:45:53.900", "ParentId": "27551167", "Score": "-1", "OwnerUserId": "927333"}, "37255062": {"Id": "37255062", "PostTypeId": "2", "Body": "<p>One picture is sometimes more than thousand words.</p>\n<p><a href=\"https://i.stack.imgur.com/hHz2j.png\" rel=\"nofollow noreferrer\"><img alt=\"source vs. memory endianness\" src=\"https://i.stack.imgur.com/hHz2j.png\"/></a></p>\n", "LastActivityDate": "2016-05-16T13:26:43.043", "CommentCount": "1", "CreationDate": "2016-05-16T13:26:43.043", "ParentId": "27551167", "Score": "3", "OwnerUserId": "1522062"}, "27551167": {"ViewCount": "3953", "Body": "<p>I have tried searching around but have not been able to find much about binary literals and endianness. Are binary literals little-endian, big-endian or something else (such as matching the target platform)?</p>\n<p>As an example, what is the decimal value of <code>0b0111</code>? Is it 7? Platform specific? Something else? <em>Edit:</em> I picked a bad value of 7 since it is represented within one byte. The question has been sufficiently answered despite this fact.</p>\n<p>Some background: Basically I'm trying to figure out what the value of the least significant bits are, and masking it with binary literals seemed like a good way to go... but only if there is some guarantee about endianness.</p>\n", "AcceptedAnswerId": "27551217", "Title": "What is the endianness of binary literals in C++14?", "CreationDate": "2014-12-18T16:21:17.650", "Id": "27551167", "CommentCount": "11", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-01-17T04:38:46.153", "LastEditorUserId": "538216", "LastActivityDate": "2017-08-13T22:07:02.657", "Score": "40", "OwnerUserId": "538216", "Tags": "<c++><endianness><c++14>", "AnswerCount": "7"}, "27552837": {"Id": "27552837", "PostTypeId": "2", "Body": "<p>You're missing the distinction between endianness as written in the source code and endianness as represented in the object code.  The answer for each is unsurprising: source-code literals are bigendian because that's how humans read them, in object code they're written however the target reads them.</p>\n<p>Since a byte is by definition the smallest unit of memory access I don't believe it would be possible to even ascribe an endianness to any internal representation of bits in a byte -- the only way to discover endianness for larger numbers (whether intentionally or by surprise) is by accessing them from storage piecewise, and the byte is by definition the smallest accessible storage unit.</p>\n", "LastEditorUserId": "1290731", "LastActivityDate": "2014-12-18T18:06:21.693", "Score": "10", "CreationDate": "2014-12-18T17:58:48.377", "ParentId": "27551167", "CommentCount": "2", "OwnerUserId": "1290731", "LastEditDate": "2014-12-18T18:06:21.693"}});