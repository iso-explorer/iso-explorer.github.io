post_cb({"bq_ids": {"n4140": {"so_46107480_46107646_0": {"length": 65, "quality": 0.9848484848484849, "section_id": 481}}, "n3337": {"so_46107480_46107646_0": {"length": 41, "quality": 0.6212121212121212, "section_id": 472}}, "n4659": {"so_46107480_46107646_0": {"length": 54, "quality": 0.8181818181818182, "section_id": 504}}}, "46107480": {"ViewCount": "49", "Body": "<p><em>Context:</em> I was making experiments to learn when does gcc perform <a href=\"https://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"nofollow noreferrer\">RVO</a>, and if not, when does it use move semantics. My version of gcc is <code>g++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-4)</code>.</p>\n<p><em>Question:</em> I have a function that returns a <code>Foo</code> by value. Compiler cannot perform RVO because there are two possible named return values. When I use the ternary operator to select which of <code>Foo</code> to return, then I need to explicitly call <code>std::move</code> to avoid the copy. I do not need the <code>std::move</code> when using an if statement. Why the discrepancy?</p>\n<p>Code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct Foo {\n    std::string s;\n    Foo()                                        { cout &lt;&lt; \"Foo()\\n\"; }\n    ~Foo()                                       { cout &lt;&lt; \"~Foo()\\n\"; }\n    Foo(const Foo&amp; other)     : s(other.s)       { cout &lt;&lt; \"Foo(const Foo&amp;)\\n\"; }\n    Foo(Foo&amp;&amp; other) noexcept : s(move(other.s)) { cout &lt;&lt; \"Foo(Foo&amp;&amp;)\\n\"; }\n};\n\nFoo makeFooIf(bool which) {\n    Foo foo1; foo1.s = \"Hello, World1!\";\n    Foo foo2; foo2.s = \"Hello, World2!\";\n    if (which) return foo1;\n    else       return foo2;\n}\n\nFoo makeFooTernary(bool which) {\n    Foo foo1; foo1.s = \"Hello, World1!\";\n    Foo foo2; foo2.s = \"Hello, World2!\";\n    return which ? foo1 : foo2;\n}\n\nFoo makeFooTernaryMove(bool which) {\n    Foo foo1; foo1.s = \"Hello, World1!\";\n    Foo foo2; foo2.s = \"Hello, World2!\";\n    return which ? move(foo1) : move(foo2);\n}\n\nint main()\n{\n    cout &lt;&lt; \"----- makeFooIf -----\\n\";\n    Foo fooIf = makeFooIf(true);\n    cout &lt;&lt; fooIf.s &lt;&lt; endl;\n\n    cout &lt;&lt; \"\\n----- makeFooTernary -----\\n\";\n    Foo fooTernary = makeFooTernary(true);\n    cout &lt;&lt; fooTernary.s &lt;&lt; endl;\n\n    cout &lt;&lt; \"\\n----- makeFooTernaryMove -----\\n\";\n    Foo fooTernaryMove = makeFooTernaryMove(true);\n    cout &lt;&lt; fooTernaryMove.s &lt;&lt; endl;\n\n    cout &lt;&lt; \"\\n----- Cleanup -----\\n\";\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>----- makeFooIf -----\nFoo()\nFoo()\nFoo(Foo&amp;&amp;)\n~Foo()\n~Foo()\nHello, World1!\n\n----- makeFooTernary -----\nFoo()\nFoo()\nFoo(const Foo&amp;)\n~Foo()\n~Foo()\nHello, World1!\n\n----- makeFooTernaryMove -----\nFoo()\nFoo()\nFoo(Foo&amp;&amp;)\n~Foo()\n~Foo()\nHello, World1!\n\n----- Cleanup -----\n~Foo()\n~Foo()\n~Foo()\n</code></pre>\n", "AcceptedAnswerId": "46107646", "Title": "Move constructor with if-statement but copy constructor with ternary operator", "CreationDate": "2017-09-08T01:54:16.520", "Id": "46107480", "CommentCount": "2", "LastEditDate": "2017-09-08T02:41:57.097", "PostTypeId": "1", "LastEditorUserId": "1951907", "LastActivityDate": "2017-09-08T02:41:57.097", "Score": "1", "OwnerUserId": "1951907", "Tags": "<c++><c++11><move-semantics>", "AnswerCount": "1"}, "46107646": {"Id": "46107646", "PostTypeId": "2", "Body": "<p>There is an implicit move in certain situations:</p>\n<p><strong>\u00a712.8.32</strong></p>\n<blockquote>\n<p id=\"so_46107480_46107646_0\">When the criteria for elision of a copy/move operation are met, but\n  not for an exception-declaration, and the object to be copied is\n  designated by an lvalue, or when the <strong>expression in a return statement</strong>\n  is a (possibly parenthesized) id-expression <strong>that names an object</strong> with\n  automatic storage duration <strong>declared in the body</strong> or\n  parameter-declaration-clause of the <strong>innermost enclosing function</strong> or\n  lambda-expression, overload resolution to select the constructor for\n  the copy is first performed <strong>as if</strong> the object were designated by an\n  <strong>rvalue</strong>. If the first overload resolution fails or was not performed,\n  or if the type of the first parameter of the selected constructor is\n  not an rvalue reference to the object\u2019s type (possibly cv-qualified),\n  overload resolution is performed again, considering the object as an\n  lvalue.</p>\n</blockquote>\n<p>My bolding</p>\n", "LastActivityDate": "2017-09-08T02:15:00.337", "CommentCount": "3", "CreationDate": "2017-09-08T02:15:00.337", "ParentId": "46107480", "Score": "1", "OwnerUserId": "3202093"}});