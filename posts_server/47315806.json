post_cb({"47315806": {"CommentCount": "10", "ViewCount": "203", "PostTypeId": "1", "LastEditorUserId": "3294674", "CreationDate": "2017-11-15T19:33:09.317", "LastActivityDate": "2017-11-15T21:50:56.110", "Title": "Difference in initializing char-array and char with integer literals", "FavoriteCount": "3", "LastEditDate": "2017-11-15T21:50:56.110", "Id": "47315806", "Score": "9", "Body": "<p>On my system (<em>4.13.11-1-ARCH, gcc 7.2.0</em>) <code>char</code> is <code>signed</code>. When initializing an array of <code>char</code> with an <code>integer literal</code> like this: </p>\n<pre><code>const char mydata[] = {\n    0x80\n};\n</code></pre>\n<p>I get the following error:</p>\n<pre><code>error: narrowing conversion of \u2018128\u2019 from \u2018int\u2019 to \u2018char\u2019 inside { } [-Wnarrowing]\n</code></pre>\n<p>However, when I instead do <code>const char data = 0x80</code> the compiler is not worried of any narrowing, although it happens of course. The output is <code>7F</code>, the highest positive <code>signed char</code> value.</p>\n<h1>Question</h1>\n<p>Why is the compiler not equally worried about truncation in both cases?</p>\n", "Tags": "<c++><arrays><char><initialization><compiler-warnings>", "OwnerUserId": "3294674", "AnswerCount": "2"}, "47316402": {"ParentId": "47315806", "CommentCount": "3", "Body": "<p>An initializer of the form <code>const char c = 0x80</code> is a much older construct than \ninitializer lists, which have been introduced later. So it was possible to define stricter rules for initializer lists, while these rules where not applied to \"older\" initializers (probably because of not to break \"older\" code more than necessary). </p>\n<p>Hence, initializer lists as defined in <a href=\"https://timsong-cpp.github.io/cppwp/n3337/dcl.init.aggr#2\" rel=\"nofollow noreferrer\">this online c++ standard draft</a> forbid such narrowing:</p>\n<blockquote>\n<p id=\"so_47315806_47316402_0\"><strong>8.5.1 Aggregates</strong></p>\n<p id=\"so_47315806_47316402_1\">(2) When an aggregate is initialized by an initializer list, as\n  specified in [dcl.init.list], the elements of the initializer list are\n  taken as initializers for the members of the aggregate, in increasing\n  subscript or member order. Each member is copy-initialized from the\n  corresponding initializer-clause. <strong>If the initializer-clause is an\n  expression and a narrowing conversion ([dcl.init.list]) is required to\n  convert the expression, the program is ill-formed.</strong> ...</p>\n</blockquote>\n<p>BTW: If you use a brace initializer like <code>const char data { 0x80 }</code>, you will get an error, too. So the stricter rules are due to brace-initializers / initializer lists, and not due to whether you initialize an array or a scalar value.</p>\n", "OwnerUserId": "2630032", "PostTypeId": "2", "Id": "47316402", "Score": "1", "CreationDate": "2017-11-15T20:10:44.413", "LastActivityDate": "2017-11-15T20:10:44.413"}, "bq_ids": {"n4140": {"so_47315806_47316402_1": {"section_id": 3299, "quality": 0.9375, "length": 30}}, "n3337": {"so_47315806_47316402_1": {"section_id": 3169, "quality": 0.9375, "length": 30}}, "n4659": {"so_47315806_47316402_1": {"section_id": 4065, "quality": 0.78125, "length": 25}}}, "47316016": {"ParentId": "47315806", "CommentCount": "0", "Body": "<p>This is actually one of the reasons why <code>{}</code> initialization should be prefered: It does not allow narrowing conversions. In contrast to this, the old way of initalization (as in <code>const char data = 0x80</code>) does allow narrowing conversions.</p>\n", "OwnerUserId": "4117728", "PostTypeId": "2", "Id": "47316016", "Score": "5", "CreationDate": "2017-11-15T19:46:00.790", "LastActivityDate": "2017-11-15T19:46:00.790"}});