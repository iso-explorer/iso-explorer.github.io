post_cb({"8363040": {"ParentId": "8362921", "CommentCount": "0", "CreationDate": "2011-12-02T21:41:54.473", "OwnerUserId": "343443", "PostTypeId": "2", "Id": "8363040", "Score": "0", "Body": "<p><code>C::data</code> isn't initialized there, so order doesn't matter.</p>\n<p>The shorter solution is to use static function and dummy variable:</p>\n<pre><code>class C {\nprivate:\n\n    static void Init() {\n        /* compute data once here */\n    }\n\n    static bool data_init_helper;\n    static int data[];\npublic:\n    /* interface for reading data */\n};\n\nbool C::data_init_helper = (C::Init(), false);\nint C::data[200];\n</code></pre>\n", "LastActivityDate": "2011-12-02T21:41:54.473"}, "8363056": {"ParentId": "8362921", "CommentCount": "0", "CreationDate": "2011-12-02T21:43:15.460", "OwnerUserId": "476681", "PostTypeId": "2", "Id": "8363056", "Score": "0", "Body": "<blockquote>\n<p id=\"so_8362921_8363056_0\">Is C::i always initialized after C::data no matter the order of the\n  definition of both?</p>\n</blockquote>\n<p>The order is guaranteed if they are defined in the same compilation\nunit, otherwise not.</p>\n<blockquote>\n<p id=\"so_8362921_8363056_1\">Is this solution the most elegant one for computing static data once?</p>\n</blockquote>\n<p>No. If you really have to have it static, then a better way (and to prevent a possible static initialization order fiasco) is to do it like this : </p>\n<pre><code>struct someDataStr\n{\n  int data[200];\n};\nsomeDataStr&amp; AccessData()\n{\n  static someDataStr *ptr = NULL;\n  if ( NULL == ptr )\n  {\n    ptr = new someDataStr;\n    // initialize value\n  }\n  return *ptr;\n}\n</code></pre>\n<p>If it doesn't have to be static, then use dependency injection, and pass the object containing data to all classes using it.</p>\n", "LastActivityDate": "2011-12-02T21:43:15.460"}, "bq_ids": {"n4140": {"so_8362921_8363026_0": {"section_id": 7151, "quality": 0.9333333333333333, "length": 28}}, "n3337": {"so_8362921_8363026_0": {"section_id": 6895, "quality": 0.9333333333333333, "length": 28}}, "n4659": {"so_8362921_8363026_0": {"section_id": 8652, "quality": 0.6, "length": 18}}}, "8362921": {"CommentCount": "2", "ViewCount": "746", "CreationDate": "2011-12-02T21:29:29.120", "LastActivityDate": "2011-12-02T21:43:15.460", "Title": "Static data member initialization order", "AcceptedAnswerId": "8363026", "PostTypeId": "1", "Id": "8362921", "Score": "3", "Body": "<p>Consider the code below in a single translation unit:</p>\n<pre><code>class C {\nprivate:\n\n    struct Init {\n\n        Init() {\n            /* compute data once here */\n        }\n    };\n    static const Init&amp; i;\n    static int data[];\npublic:\n    /* interface for reading data */\n};\n\nconst C::Init&amp; C::i = Init();\nint C::data[200];\n</code></pre>\n<ol>\n<li>Is C::i always initialized after C::data no matter the order of the definition of both?</li>\n<li>Is this solution the most elegant one for computing static data once?</li>\n</ol>\n", "Tags": "<c++>", "OwnerUserId": "989331", "AnswerCount": "3"}, "8363026": {"ParentId": "8362921", "CommentCount": "2", "CreationDate": "2011-12-02T21:40:13.037", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "8363026", "Score": "6", "Body": "<p><code>int C::data[200]</code> is <em>zero-initialized</em>, which means that it is <em>statically initialized</em>. Static initialization comes before dynamic initialization. Since <code>C::Init::Init()</code> is not a constant expression, <code>C::i</code> is dynamically initialized, necessarily <em>after</em> <code>C::data</code>.</p>\n<p>See 3.6.2 for details.</p>\n<p>A bootleg quote:</p>\n<blockquote>\n<p id=\"so_8362921_8363026_0\">Variables with static storage duration [...] shall be zero-initialized before any other initialization takes place. [...] Together, zero-initialization and constant initialization are called static initialization; all other initialization is dynamic initialization. Static initialization shall be performed before any dynamic initialization takes place.</p>\n</blockquote>\n", "LastActivityDate": "2011-12-02T21:40:13.037"}});