post_cb({"41048564": {"ParentId": "41046986", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2016-12-08T20:49:47.277", "Score": "-1", "LastEditorUserId": "1023390", "LastEditDate": "2016-12-08T21:01:20.827", "Id": "41048564", "OwnerUserId": "1023390", "Body": "<p>Let's first simplify the problem and consider</p>\n<pre><code>template &lt;class...&gt; struct pack {};\n\ntemplate &lt;class T&gt;\nvoid foo(pack&lt;T&gt;) {}\n\ntemplate &lt;class T, class... Ts&gt;\nvoid foo(pack&lt;T,Ts...&gt;) {}\n\nint main() {\n  foo(pack&lt;int&gt;{});\n}\n</code></pre>\n<p>which clang complains about and refused to compile, claiming that there is\nambiguity between <code>void foo(pack&lt;T&gt;)</code> [with <code>T=int</code>] and <code>void foo(pack&lt;T,Ts...&gt;)</code> [with <code>T=int</code>, <code>Ts=&lt;&gt;</code>]. Situations like this are resolved using <a href=\"http://en.cppreference.com/w/cpp/language/function_template\" rel=\"nofollow noreferrer\"><em>partial ordering of overloaded function templates</em></a>, which essentially tries to find the most specialized overload. </p>\n<p>In the case at hand, I think the following applies:</p>\n<p><strong>In case of a tie, if one function template has a trailing parameter pack and the other does not, the one with the omitted parameter is considered to be more specialized than the one with the empty parameter pack.</strong></p>\n<p>Thus it appears that the first should be preferred and clang was wrong.</p>\n", "LastActivityDate": "2016-12-08T21:01:20.827"}, "41049584": {"ParentId": "41046986", "CommentCount": "8", "CreationDate": "2016-12-08T21:59:26.737", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "41049584", "Score": "4", "Body": "<p>I believe now that clang is correct to reject and gcc is incorrect to accept those forms that it does. Here's a simplified example:</p>\n<pre><code>template &lt;class...&gt; struct pack { };\n\n// (1)\ntemplate &lt;class T&gt;\nvoid foo(pack&lt;T&gt; ) { }\n\n// (2)\ntemplate &lt;class T, class... Ts&gt;\nvoid foo(pack&lt;T, Ts...&gt; ) { }\n\nint main() {\n    foo(pack&lt;int&gt;{});\n}\n</code></pre>\n<p>Both overloads are valid, and deducing (2) from (1) succeeds straightforwardly. The only issue is can we deduce (1) from (2). I'd initially think no... But [temp.deduct.type]/9 states:</p>\n<blockquote>\n<p id=\"so_41046986_41049584_0\">If <code>P</code> has a form that contains <code>&lt;T&gt;</code> or <code>&lt;i&gt;</code>, then each argument P<sub><em>i</em></sub> of the respective template argument list of <code>P</code> is compared with the corresponding argument A<sub><em>i</em></sub> of the corresponding template argument list of <code>A</code>. [...] During partial ordering (14.8.2.4), if A<sub><em>i</em></sub> was originally a pack expansion:<br>\n  \u2014 if <code>P</code> does not contain a template argument corresponding to A<sub><em>i</em></sub> then A<sub><em>i</em></sub> is ignored;</br></p>\n</blockquote>\n<p>So when we synthesize types for <code>&lt;T, Ts...&gt;</code> (say <code>&lt;U, Xs...&gt;</code>), we deduce <code>T=U</code> and then there is no template argument corresponding to the pack expension <code>Xs...</code>, so we ignore it. All the non-ignored template parameters succeeded in template deduction, so we consider deducing (1) from (2) to be success.</p>\n<p>Since deduction succeeds in both directions, neither function template is considered more specialized than the other, and the call should be ambiguous. </p>\n<hr/>\n<p>I have not yet submitted a bug report, waiting on some confirmation from the community. </p>\n", "LastActivityDate": "2016-12-08T21:59:26.737"}, "bq_ids": {"n4140": {"so_41046986_41049584_0": {"section_id": 340, "quality": 0.967741935483871, "length": 30}}, "n3337": {"so_41046986_41049584_0": {"section_id": 330, "quality": 0.967741935483871, "length": 30}}, "n4659": {"so_41046986_41049584_0": {"section_id": 349, "quality": 0.967741935483871, "length": 30}}}, "41046986": {"CommentCount": "2", "ViewCount": "200", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-12-08T19:05:55.813", "LastActivityDate": "2016-12-08T21:59:26.737", "Title": "Ambiguous overload - partial function template ordering with parameter packs", "FavoriteCount": "1", "LastEditDate": "2016-12-08T19:29:36.460", "Id": "41046986", "Score": "10", "Body": "<p>Consider the following contrived piece of code:</p>\n<pre><code>template &lt;class... &gt; struct pack { };\n\ntemplate &lt;class R, class T, class... Args&gt;\nint foo(pack&lt;T&gt;, Args...)\n{\n    return sizeof(R);\n}\n\ntemplate &lt;class R, class T, class... Ts, class... Args&gt;\nint foo(pack&lt;T, Ts...&gt;, Args... args)\n{\n    return foo&lt;T&gt;(pack&lt;Ts...&gt;{}, args...);\n}\n\nint main() {\n    // gcc: OK, clang: ambiguous\n    foo&lt;int&gt;(pack&lt;int&gt;{});\n\n    // gcc: ambiguous, clang: ambiguous\n    foo&lt;int&gt;(pack&lt;int&gt;{}, 0);\n}\n</code></pre>\n<p>Both gcc and clang accept both calls if the 2nd overload is changed to take a pack of at least 2 types instead of a pack of at least one type:</p>\n<pre><code>template &lt;class R, class T, class T2, class... Ts, class... Args&gt;\nint foo(pack&lt;T, T2, Ts...&gt;, Args... args)\n{\n    return foo&lt;T&gt;(pack&lt;T2, Ts...&gt;{}, args...);\n}\n</code></pre>\n<p>If the non-deduced template parameter is moved to a deduced template parameter, then:</p>\n<pre><code>template &lt;class... &gt; struct pack { };\n\ntemplate &lt;class R, class T, class... Args&gt;\nint foo(pack&lt;R&gt;, pack&lt;T&gt;, Args...)\n{\n    return sizeof(R);\n}\n\ntemplate &lt;class R, class T, class... Ts, class... Args&gt;\nint foo(pack&lt;R&gt;, pack&lt;T, Ts...&gt;, Args... args)\n{\n    return foo(pack&lt;T&gt;{}, pack&lt;Ts...&gt;{}, args...);\n}\n\nint main() {\n    // gcc ok with both, clang rejects both as ambiguous\n    foo(pack&lt;int&gt;{}, pack&lt;int&gt;{});\n    foo(pack&lt;int&gt;{}, pack&lt;int&gt;{}, 0);\n}\n</code></pre>\n<p>I'd expect all the calls to be OK in every version of this. What is the expected outcome of the above code examples?</p>\n", "Tags": "<c++><templates><gcc><clang><language-lawyer>", "OwnerUserId": "2069064", "AnswerCount": "2"}});