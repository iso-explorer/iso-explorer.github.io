post_cb({"43609232": {"ParentId": "43608823", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_43608823_43609232_0\">But when I want to get the pointer to the array as the pointer to the\n  fixed size array, I must use &amp; symbol.</p>\n</blockquote>\n<p>Here your statement is completely wrong in particular case and half-wrong in  general. You already obtained it and assigned to pointer variable parray, then... tried to treat address of that variable as a pointer to array?  In particular case name of array decays to pointer to array. In general pointer to array is same as pointer to first element of array, so you can use <code>&amp;array[0]</code> or just <code>array</code></p>\n", "OwnerUserId": "2742717", "PostTypeId": "2", "Id": "43609232", "Score": "0", "CreationDate": "2017-04-25T11:18:03.437", "LastActivityDate": "2017-04-25T11:18:03.437"}, "43609050": {"ParentId": "43608823", "LastEditDate": "2017-04-25T11:54:03.573", "CommentCount": "2", "CreationDate": "2017-04-25T11:09:44.067", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "PostTypeId": "2", "Id": "43609050", "Score": "7", "Body": "<p>This is a feature called <em>array decaying</em>. The array variable is said to <em>decay</em> into a pointer to first element, when the variable name is used in a value context.</p>\n<p>Here the array is used in a value context: <code>parray = array</code>, so it decays. You could write the decay explicitly: <code>parray = &amp;(array[0])</code>. Former (implicit decay) is just syntactic sugar for the latter.</p>\n<p>Operand of the addressof operator is not a value context. As such, the array name does not decay.<code>&amp;array</code> is different from <code>&amp;(array[0])</code>. First takes the address of an array type, the latter takes an address of the element type. <code>parray</code> on the other hand is a completely different variable, and <code>&amp;parray</code> returns the address where the pointer is stored, which is not the address where the array is stored.</p>\n<blockquote id=\"so_43608823_43609050_0\">\n<pre><code>uint8_t (*p1)[4]  = (uint8_t (*)[4])&amp;array;\n</code></pre>\n</blockquote>\n<p>This is correct, although the conversion is redundant because <code>&amp;array</code> is already of type <code>uint8_t (*)[4]</code>.</p>\n<blockquote id=\"so_43608823_43609050_1\">\n<pre><code>uint8_t (*p2)[4]  = (uint8_t (*)[4])&amp;parray;\n</code></pre>\n</blockquote>\n<p>This is wrong. <code>parray</code> is of type <code>uint8_t*</code> and the address where it is stored doesn't contain an object of type <code>uint8_t[4]</code>. Instead it contains the pointer.</p>\n<blockquote id=\"so_43608823_43609050_2\">\n<pre><code>uint8_t (*p3)[4]  = (uint8_t (*)[4])parray;\n</code></pre>\n</blockquote>\n<p>This is a bit dubious. <code>parray</code> is a pointer to <code>uint8_t</code>, not a pointer to <code>uint8_t[4]</code>. However, it happens to point to an address that also contains a <code>uint8_t[4]</code> object, so this works.</p>\n<hr>\n<blockquote>\n<p id=\"so_43608823_43609050_3\">parray is obviously nearly the same as array</p>\n</blockquote>\n<p>But clearly not exactly same, as evidenced by the behaviour of your program.</p>\n<p><code>array</code> is an array of four <code>uint8_t</code> elements, and <code>parray</code> is a pointer to <code>uint8_t</code>, which points to the first element of <code>array</code>. This distinction is important to understand.</p>\n<hr>\n<p>Conclusion: It is important to understand what array decaying is, and what is the difference between an array and a pointer, and most importantly: Explicit conversions can hide mistakes from the compiler - avoid them when you can.</p>\n<hr>\n<p>For the edit:</p>\n<blockquote>\n<p id=\"so_43608823_43609050_4\">When I get the param in another function as a pointer, can I pass it to foo this way?</p>\n</blockquote>\n<p>Only if you can prove that <code>param</code> points to the first element of a \n<code>uint8_t[4]</code>. That is essentially a pre-condition of <code>bar</code>.</p>\n<p>However, it is better to not rely on verbal pre-conditions, when you could use the type system to communicate the requirements:</p>\n<blockquote>\n<p id=\"so_43608823_43609050_5\">Is there a better way?</p>\n</blockquote>\n<p>Change the parameter type of <code>bar</code>, so that users know to pass a pointer of correct type:</p>\n<pre><code>void bar(uint8_t (*param)[4]) {\n    foo(param);\n}\n</code></pre>\n<p>Of course, this makes <code>bar</code> redundant in this simple example.</p>\n</hr></hr></hr>", "LastActivityDate": "2017-04-25T11:54:03.573"}, "43608823": {"CommentCount": "7", "CreationDate": "2017-04-25T11:00:22.057", "PostTypeId": "1", "AcceptedAnswerId": "43609050", "LastEditorUserId": "4601945", "LastActivityDate": "2017-04-25T11:54:03.573", "LastEditDate": "2017-04-25T11:39:09.020", "ViewCount": "143", "FavoriteCount": "1", "Title": "Pointer to fixed size array behaviour", "Id": "43608823", "Score": "2", "Body": "<p>Why does this work as it does?</p>\n<pre><code>uint8_t array[4] = {1,2,3,4};\nuint8_t* parray = array;\nuint8_t (*p1)[4]  = (uint8_t (*)[4])&amp;array;\nuint8_t (*p2)[4]  = (uint8_t (*)[4])&amp;parray;\nuint8_t (*p3)[4]  = (uint8_t (*)[4])parray;\nuint8_t test1 = **p1;    // test1 = 1\nuint8_t test2 = **p2;    // test2 = something random\nuint8_t test3 = **p3;    // test3 = 1\n</code></pre>\n<p><strong>parray</strong> is obviously nearly the same as <strong>array</strong>. For example, array[0] == parray[0]. But when I want to get the pointer to the <strong>array</strong> as the pointer to the fixed size array, I must use <strong>&amp;</strong> symbol. When I want to get the pointer to the <strong>parray</strong>, I must not.</p>\n<p><strong>Practical example.</strong></p>\n<p>There is the function that accepts a pointer to the fixed size array</p>\n<pre><code>void foo(uint8_t (*param)[4])\n{\n    ...\n}\n</code></pre>\n<p>When I get the param in another function as a pointer, can I pass it to <strong>foo</strong> this way?</p>\n<pre><code>void bar(uint8_t param*)\n{\n    uint8_t (*p)[4]  = (uint8_t (*)[4])param;\n    foo(p);\n}\n</code></pre>\n<p>Is there a better way?</p>\n", "Tags": "<c++><c><arrays><pointers><strict-aliasing>", "OwnerUserId": "4601945", "AnswerCount": "4"}, "43609190": {"ParentId": "43608823", "CommentCount": "0", "Body": "<p>\"<strong>parray</strong> is obviously nearly the same as <strong>array</strong>\" &lt;- this part is incorrect</p>\n<p>There is an implicit conversion from the type of <code>array</code> to the type of <code>parray</code>, such that initialising (or assigning), e.g. <code>uint8_t* parray = array;</code> sets <code>parray</code> to be equal to <code>&amp;array[0]</code>. The conversion doesn't exist in the opposite direction.</p>\n<p>In your initialisation of <code>p1 p2 p3</code>, you are masking the types of your expressions with your casts</p>\n<pre><code>uint8_t (*p1)[4]  = (uint8_t (*)[4])&amp;array; \n</code></pre>\n<p>Here the cast is superfluous, <code>&amp;array</code> is already a <code>(uint8_t (*)[4])</code></p>\n<pre><code>uint8_t (*p2)[4]  = (uint8_t (*)[4])&amp;parray;\n</code></pre>\n<p>Here the cast is <em>a lie</em>, <code>&amp;parray</code> is a <code>uint8_t**</code></p>\n<pre><code>uint8_t (*p3)[4]  = (uint8_t (*)[4])parray;\n</code></pre>\n<p>Here the cast is safe only because of the value of <code>parray</code></p>\n", "OwnerUserId": "2610810", "PostTypeId": "2", "Id": "43609190", "Score": "2", "CreationDate": "2017-04-25T11:15:31.157", "LastActivityDate": "2017-04-25T11:15:31.157"}, "43608969": {"ParentId": "43608823", "LastEditDate": "2017-04-25T11:16:11.557", "CommentCount": "0", "CreationDate": "2017-04-25T11:06:51.013", "OwnerUserId": "2173917", "LastEditorUserId": "2173917", "PostTypeId": "2", "Id": "43608969", "Score": "2", "Body": "<p>The  assignment statement,</p>\n<pre><code>  uint8_t (*p2)[4]  = (uint8_t (*)[4])&amp;parray;\n</code></pre>\n<p>and later doing</p>\n<pre><code>  uint8_t test2 = **p2; \n</code></pre>\n<p>violates strict aliasing.</p>\n<p>To elaborate, <code>&amp;parray</code> is of type <code>uint8_t**</code>, you're casting that to be of type <code>(uint8_t (*)[4])</code> (they both are not of compatible type) and you try to dereference the target pointer. This causes <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow noreferrer\">undefined behavior</a>.</p>\n<p>Related, <code>C11</code>, chapter \u00a76.5/P7</p>\n<blockquote>\n<p id=\"so_43608823_43608969_0\">An object shall have its stored value accessed only by an lvalue expression that has one of\n  the following types: <sup>88)</sup></p>\n<p id=\"so_43608823_43608969_1\">\u2014 a type compatible with the effective type of the object,</p>\n<p id=\"so_43608823_43608969_2\">\u2014 a qualified version of a type compatible with the effective type of the object,</p>\n<p id=\"so_43608823_43608969_3\">\u2014 a type that is the signed or unsigned type corresponding to the effective type of the\n  object,</p>\n<p id=\"so_43608823_43608969_4\">\u2014 a type that is the signed or unsigned type corresponding to a qualified version of the\n  effective type of the object,</p>\n<p id=\"so_43608823_43608969_5\">\u2014 an aggregate or union type that includes one of the aforementioned types among its\n  members (including, recursively, a member of a subaggregate or contained union), or</p>\n<p id=\"so_43608823_43608969_6\">\u2014 a character type.</p>\n</blockquote>\n", "LastActivityDate": "2017-04-25T11:16:11.557"}, "bq_ids": {"n4140": {"so_43608823_43608969_0": {"section_id": 7230, "quality": 0.5454545454545454, "length": 6}, "so_43608823_43608969_2": {"section_id": 576, "quality": 0.5714285714285714, "length": 4}, "so_43608823_43608969_4": {"section_id": 7239, "quality": 0.8, "length": 8}, "so_43608823_43608969_3": {"section_id": 7239, "quality": 0.875, "length": 7}, "so_43608823_43608969_5": {"section_id": 7239, "quality": 1.0, "length": 16}}, "n3337": {"so_43608823_43608969_0": {"section_id": 6974, "quality": 0.5454545454545454, "length": 6}, "so_43608823_43608969_2": {"section_id": 407, "quality": 0.5714285714285714, "length": 4}, "so_43608823_43608969_4": {"section_id": 6983, "quality": 0.8, "length": 8}, "so_43608823_43608969_3": {"section_id": 6983, "quality": 0.875, "length": 7}, "so_43608823_43608969_5": {"section_id": 6983, "quality": 1.0, "length": 16}}, "n4659": {"so_43608823_43608969_2": {"section_id": 599, "quality": 0.5714285714285714, "length": 4}, "so_43608823_43608969_5": {"section_id": 8748, "quality": 1.0, "length": 16}, "so_43608823_43608969_4": {"section_id": 8748, "quality": 0.8, "length": 8}, "so_43608823_43608969_3": {"section_id": 8748, "quality": 0.875, "length": 7}, "so_43608823_43608969_1": {"section_id": 802, "quality": 0.8, "length": 4}}}});