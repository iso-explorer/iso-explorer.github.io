post_cb({"bq_ids": {"n4140": {"so_34622698_34623467_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6549}}, "n3337": {"so_34622698_34623467_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6304}}, "n4659": {"so_34622698_34623467_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 8031}}}, "34622698": {"ViewCount": "124", "Body": "<p>Depending on which compiler I use, I get a different out put for this function at n=0. </p>\n<pre><code>std::string ToStrWPrec(double a_value, const int n)\n{\n    std::ostringstream out; \n    out &lt;&lt; std::setprecision(n) &lt;&lt; a_value; \n    return out.str();\n}\n</code></pre>\n<p>(GCC) 4.8.3 20140911 (Red Hat 4.8.3-9) returns 1 for ToStrWPrec(1.2345678,0). VS2013 returns 1.2346 for same code.</p>\n<p>my question are:</p>\n<ol>\n<li>What is the correct/standard behavior for setprecision?</li>\n<li>what would be good alternative to using setprecision? </li>\n</ol>\n<hr>\n<p>here is the updated code based on comment below</p>\n<pre><code>std::string ToStrWPrec(double a_value, const int n)\n{\n    std::ostringstream out; \n    out &lt;&lt; std::setprecision(n) &lt;&lt; std::fixed&lt;&lt; a_value; \n    return out.str();\n}\n</code></pre>\n</hr>", "AcceptedAnswerId": "34623467", "Title": "Correct behavior for std::setprecision(0) in GCC vs VS2013", "CreationDate": "2016-01-05T22:50:34.510", "Id": "34622698", "CommentCount": "2", "LastEditDate": "2016-01-06T03:10:36.340", "PostTypeId": "1", "LastEditorUserId": "4468480", "LastActivityDate": "2016-01-06T03:10:36.340", "Score": "4", "OwnerUserId": "4468480", "Tags": "<c++><gcc><visual-studio-2013>", "AnswerCount": "1"}, "34623467": {"Id": "34623467", "PostTypeId": "2", "Body": "<p>According to 22.4.2.2.2 [facet.num.put.virtuals] paragraph 5, Stage 1, this is said about the precision:</p>\n<blockquote>\n<p id=\"so_34622698_34623467_0\">For conversion from a floating-point type, if <code>floatfield != (ios_base::fixed | ios_base::scientific), str.precision()</code> is specified as precision in the conversion specification. Otherwise, no precision is specified.</p>\n</blockquote>\n<p>The same paragraph specifies elsewhere that the format specifier defining the result is <code>%g</code>.</p>\n<p>The default value for the <code>floatfield</code> is nothing set according to 27.5.5.2 [basic.ios.cons] paragraph 3, Table 128:</p>\n<blockquote>\n<p id=\"so_34622698_34623467_1\"><code>flags()</code> <code>skipws | dec</code></p>\n</blockquote>\n<p>Thus, it boils down how a format string of <code>\"%.0g\"</code> formats the value. The C standard in 7.21.6.1 paragraph 8 states this:</p>\n<blockquote>\n<p id=\"so_34622698_34623467_2\">Let <em>P</em> equal the precision if nonzero, 6 if the precision is omitted, or 1 if the precision is zero.</p>\n</blockquote>\n<p>It seems, the correct result is <code>1</code>.</p>\n", "LastActivityDate": "2016-01-06T00:03:47.030", "Score": "2", "CreationDate": "2016-01-06T00:03:47.030", "ParentId": "34622698", "CommentCount": "0", "OwnerUserId": "1120273"}});