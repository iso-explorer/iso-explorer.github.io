post_cb({"20131290": {"ParentId": "20130571", "CommentCount": "0", "Body": "<p>Memory order only dictates which writes or reads to other variables than the atomic one are being seen by other threads. If you don't care about the other writes or reads in your thread in relation to your member variable, you can even use <code>std::memory_order_relaxed</code>.</p>\n<p>To question how fast other threads see writes on your atomic variable, the standard says the following: (\u00a7 29.3.13)</p>\n<blockquote>\n<p id=\"so_20130571_20131290_0\">Implementations should make atomic stores visible to atomic loads within a reasonable amount of time.</p>\n</blockquote>\n", "OwnerUserId": "893693", "PostTypeId": "2", "Id": "20131290", "Score": "1", "CreationDate": "2013-11-21T20:32:37.620", "LastActivityDate": "2013-11-21T20:32:37.620"}, "20130571": {"CommentCount": "0", "ViewCount": "216", "PostTypeId": "1", "LastEditorUserId": "893693", "CreationDate": "2013-11-21T19:51:26.643", "LastActivityDate": "2013-11-27T16:33:08.810", "Title": "C++11: Ensuring defined semantics of write-once read-many?", "LastEditDate": "2013-11-21T20:33:34.500", "Id": "20130571", "Score": "2", "Body": "<p>I'm wondering if I need to use <code>std::atomic</code> in the following case:</p>\n<ul>\n<li>a (pointer to a) member variable is initialized in an object's constructor</li>\n<li>at some point in the future, there is <em>exactly one</em> write by some thread</li>\n<li>several other threads are reading it concurrently (reads happen both before and after the write)</li>\n</ul>\n<p>if I'm only looking for the following type of consistency:</p>\n<ul>\n<li>a thread sees either the initial value of the member variable or the value after the write</li>\n<li>each thread eventually sees the value after write (provided it runs long enough)</li>\n</ul>\n<p>If yes, which memory order should I use in load/store (out of <code>memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, memory_order_seq_cst</code>) to get as little overhead as possible?</p>\n<p>As an example, suppose I want to implement a \"static\" singly-linked list which can only insert at tail and never delete or change any of the next pointers, i.e.:</p>\n<pre><code> Entry {\n  ...\n  const Entry* next; // or std::atomic&lt;const Entry*&gt; next;\n  Entry() : next(NULL) { ... }\n  ...\n};\nvoid Insert(Entry* tail, const Entry* e) {\n  tail-&gt;next = e;  // assuming tail != NULL (i.e. we always have a dummy node)\n}\n</code></pre>\n", "Tags": "<c++><multithreading><c++11><concurrency><memory-model>", "OwnerUserId": "395744", "AnswerCount": "2"}, "20247963": {"ParentId": "20130571", "CommentCount": "0", "Body": "<p>To decide what memory ordering you need, you need to provide more information about what you will use the member variable for.  If you are using a atomic pointer field to reference a newly created object and that the object has fields you want to the readers to access, then you need to make sure synchronization is established.  That means that store needs to be a release, and the loads probably should be acquires.  Though depending on the details consume might work.  At this point, there isn't really any advantage of using consume performance wise so I'd probably stick to acquire.</p>\n<p>Try playing around with examples using CDSChecker to get an idea of what you need to do.</p>\n", "OwnerUserId": "2364204", "PostTypeId": "2", "Id": "20247963", "Score": "0", "CreationDate": "2013-11-27T16:33:08.810", "LastActivityDate": "2013-11-27T16:33:08.810"}, "bq_ids": {"n4140": {"so_20130571_20131290_0": {"section_id": 1159, "quality": 1.0, "length": 11}}, "n3337": {"so_20130571_20131290_0": {"section_id": 1157, "quality": 1.0, "length": 11}}, "n4659": {"so_20130571_20131290_0": {"section_id": 1253, "quality": 1.0, "length": 11}}}});