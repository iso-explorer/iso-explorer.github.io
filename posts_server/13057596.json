post_cb({"13057883": {"LastActivityDate": "2012-10-24T21:22:00.537", "CommentCount": "2", "Body": "<p>6.5.4/1 says:</p>\n<pre><code>for ( for-range-declaration : braced-init-list ) statement\n</code></pre>\n<blockquote>\n<p id=\"so_13057596_13057883_0\">let range-init be equivalent to the braced-init-list. In each case, a\n  range-based for statement is equivalent to</p>\n</blockquote>\n<pre><code>{\n    auto &amp;&amp; __range = range-init;\n    for ( auto __begin = begin-expr,\n                __end = end-expr;\n            __begin != __end;\n            ++__begin ) {\n        for-range-declaration = *__begin;\n        statement\n    }\n}\n</code></pre>\n<p>(further explanation follows of the meanings of all that <code>__</code> gubbins).</p>\n<p>The standard doesn't make any <em>guarantees</em> whether that line <code>const auto &amp;e = *__begin</code> introduces a performance overhead, of course, compared with directly using <code>*__begin</code> instead of <code>e</code> inside <em>statement</em>. Implementations are permitted to implement references by laboriously copying a pointer into some stack slot and then reading it back each time the reference is used, and are not required to optimize.</p>\n<p>But there's no reason why there should be an overhead in a sensible compiler, in the case where <code>__begin</code> is a container iterator (whose <code>operator*</code> returns a reference), and then <code>e</code> is passed by value in <em>statement</em>.</p>\n", "CreationDate": "2012-10-24T21:16:40.287", "LastEditDate": "2012-10-24T21:22:00.537", "ParentId": "13057596", "Id": "13057883", "LastEditorUserId": "13005", "PostTypeId": "2", "Score": "11", "OwnerUserId": "13005"}, "bq_ids": {"n4140": {"so_13057596_13057883_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 3906}}, "n3337": {"so_13057596_13057883_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 3766}}}, "13057846": {"CommentCount": "6", "Body": "<p>The standard containers all return references from their iterator (note, however, that some \"containers aren't really container, e.g., <code>std::vector&lt;bool&gt;</code> which returns a proxy). Other iterators might return proxies or values although this isn't strictly supported.</p>\n<p>Of course, the standard doesn't make any guarantees with respect to performance. Any sort of performance related feature (beyond complexity guarantees) are considered to be quality of implementation.</p>\n<p>That said, you might want to consider having the compiler make the choice for you as it did before:</p>\n<pre><code>for (auto&amp;&amp; e: coll) { f(e); }\n</code></pre>\n<p>The main issue here is that <code>f()</code> may receive a non-<code>const</code> reference. This can be prevented if necessary using a <code>const</code> version of <code>coll</code>.</p>\n", "CreationDate": "2012-10-24T21:13:53.203", "ParentId": "13057596", "Id": "13057846", "LastActivityDate": "2012-10-24T21:13:53.203", "PostTypeId": "2", "Score": "12", "OwnerUserId": "1120273"}, "13057596": {"CreationDate": "2012-10-24T20:55:50.053", "ViewCount": "2328", "FavoriteCount": "8", "Id": "13057596", "AcceptedAnswerId": "13057846", "Score": "32", "Title": "Any disadvantage of using const reference when iterating over basic types?", "LastEditorUserId": "454406", "CommentCount": "0", "Body": "<p>I find myself using C++11 more and more lately, and where I would have been using iterators in  the past, I now am using <a href=\"http://en.cppreference.com/w/cpp/language/range-for\">range-based for loops</a> whenever possible:</p>\n<pre><code>std::vector&lt;int&gt; coll(10);\nstd::generate(coll.begin(), coll.end(), []() { return rand(); } );\n</code></pre>\n<p>C++03:</p>\n<pre><code>for (std::vector&lt;int&gt;::const_iterator it = coll.begin(); it != coll.end(); ++it) {\n   foo_func(*it);\n}\n</code></pre>\n<p>C++11:</p>\n<pre><code>for (auto e : coll) { foo_func(e); }\n</code></pre>\n<p>But what if the collection element type is a template parameter? <code>foo_func()</code> probably will be overloaded to pass complex (= expensive to copy) types by const reference, and simple ones by value:</p>\n<pre><code>foo_func(const BigType&amp; e) { ... };\nfoo_func(int e) { ... };\n</code></pre>\n<p>I didn't give this much thought while I was using the the C++03-style code above. I would iterate the same way, and since dereferencing a const_iterator produces a const reference, everything was fine. But using the C++11 range-based for loop, I need to use a const reference loop variable to obtain the same behavior:</p>\n<pre><code>for (const auto&amp; e : coll) { foo_func(e); }\n</code></pre>\n<p>And suddenly I wasn't sure anymore, if this wouldn't introduce unnecessary assembly instructions if <code>auto</code> was a simple type (such as a behind-the-scene pointer to implement the reference).</p>\n<p>But compiling a sample application confirmed that there is no overhead for simple types, and that this seems to be the generic way to use range-based for loops in templates. If this hadn't been the case, <a href=\"http://www.boost.org/doc/libs/1_51_0/libs/utility/call_traits.htm\">boost::call_traits::param_type</a> would have been the way to go.</p>\n<p><strong>Question:</strong> Are there any guarantees in the standard?</p>\n<p>(I realize that the issue is not really related to range-based for loops. It's also present when using const_iterators.)</p>\n", "Tags": "<c++><templates><c++11>", "LastEditDate": "2012-10-24T21:05:40.510", "LastActivityDate": "2012-10-24T21:22:00.537", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "454406"}});