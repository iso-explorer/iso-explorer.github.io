post_cb({"30392041": {"CommentCount": "2", "ViewCount": "130", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-05-22T08:37:36.213", "LastActivityDate": "2015-05-28T13:11:20.980", "Title": "Should the destructor be always virtual when a class is part of a larger framework?", "AcceptedAnswerId": "30394552", "LastEditDate": "2017-05-23T11:58:34.770", "Id": "30392041", "Score": "3", "Body": "<p>There is <a href=\"https://stackoverflow.com/questions/461203/when-to-use-virtual-destructors\">this question</a> on stackoverflow which advocates Scott Meyers rule of only making a destructor virtual if there are virtual functions in that class.</p>\n<p>I am working in a company with a large framework and it is unclear at coding time if your class might be extended in the future. At that point in time it might also be impossible to change that class (because it is part of a released bundle).</p>\n<p>Now imagine the following scenario:</p>\n<pre><code>class A {\npublic:\n  A();\n  virtual ~A();\n  virtual m();\n};\n\nclass B : public A {\npublic:\n  B();\n  ~B();\n};\n\nclass C : public B {\npublic:\n  C();\n  virtual ~C();\n  virtual m();\n};\n</code></pre>\n<p>So I created <code>class B</code> and by now, it cannot be changed.\nNow <code>class C</code> is created, and is used as a <code>B</code>:</p>\n<pre><code>B * b = new C();\ndelete b;\n</code></pre>\n<p>What will happen is that the destructor of C is never called, right?</p>\n<p><strong>Within this scenario</strong>:\nShould a class <strong>always have a virtual destructor</strong>?</p>\n", "Tags": "<c++>", "OwnerUserId": "275195", "AnswerCount": "3"}, "30394347": {"ParentId": "30392041", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-05-22T10:28:32.297", "Score": "0", "LastEditorUserId": "1928515", "LastEditDate": "2015-05-22T10:33:57.563", "Id": "30394347", "OwnerUserId": "1928515", "Body": "<p>Scott Meyers in his book \"Effective C++: 55 Specific Ways to Improve Your Programs and Designs (3rd Edition)\" says that a destructor should be declared <code>virtual</code> if the class has another virtual function. Otherwise for only <code>virtual destructor</code> v-table will be created, which will cause to some extra resource consumption.</p>\n<pre><code>\u2726Polymorphic  base  classes  should  declare  virtual  destructors.  If  a\nclass has any virtual functions, it should have a virtual destructor.\n\u2726Classes not designed to be base classes or not designed to be used\npolymorphically should not declare virtual destructors.\n</code></pre>\n", "LastActivityDate": "2015-05-22T10:33:57.563"}, "30392081": {"ParentId": "30392041", "CommentCount": "0", "CreationDate": "2015-05-22T08:39:42.773", "OwnerUserId": "1630041", "PostTypeId": "2", "Id": "30392081", "Score": "9", "Body": "<p>when base class have virtual destructor, all classes inheriting from it automatically have virtual destructor (so in your example - B's destructor is implicit virtual)</p>\n<p>if class is intended to be extended/inherited it should have virtual destructor.</p>\n", "LastActivityDate": "2015-05-22T08:39:42.773"}, "bq_ids": {"n4140": {"so_30392041_30394552_0": {"section_id": 405, "quality": 0.8846153846153846, "length": 23}}, "n3337": {"so_30392041_30394552_0": {"section_id": 396, "quality": 0.8846153846153846, "length": 23}}, "n4659": {"so_30392041_30394552_0": {"section_id": 423, "quality": 0.8846153846153846, "length": 23}}}, "30394552": {"ParentId": "30392041", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-05-22T10:38:43.827", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:05:58.690", "Id": "30394552", "OwnerUserId": "3493731", "Body": "<p>As @Konrad Grochowski's answer states, the destructor of <code>B</code> is implictly virtual, so the behavior is well defined. In your example, <code>C::~C()</code> <em>will</em> be called. From the C++ spec \u00a7 12.4.8:</p>\n<blockquote id=\"so_30392041_30394552_0\">\nA destructor can be declared virtual (10.3) or pure virtual (10.4); if any objects of that class or any derived class are created in the program, the destructor shall be de\ufb01ned. If a class has a base class with a virtual destructor, its destructor (whether user- or implicitly-declared) is virtual.\n</blockquote>\n<p>The more pertinent question, is what happens when your framework base class actually has a non-virtual destructor (which I think is what you were driving at), and your user derives from it. For example:</p>\n<pre><code>// Your framework:\nclass A\n{\npublic:\n   A();\n   ~A(); // non-virtual\n};\n\n// User's class:\nclass B : public A\n{\n   B();\n   virtual ~B(); // virtual\n   virtual void UserMethod();\n};\n</code></pre>\n<p>As discussed in this question (<a href=\"https://stackoverflow.com/questions/19542202/non-virtual-destructor-in-base-class-but-virtual-destructor-in-derived-class-ca\">Non virtual destructor in base class, but virtual destructor in derived class cause segmentation fault</a>), this could cause your users to run into problems. If you unsure whether the user will derive from your class, it should have a virtual destructor, otherwise there is a potential for problems. </p>\n<p>To enforce proper behavior with non-virtual destructors, you could disallow the user from deriving from the class, in which case a non-virtual destructor could be safe, assuming you use the class properly within your framework. In C++11, you can use <code>final</code> to disallow derivation. In C++03 and below, you can use the trick <a href=\"http://www.drdobbs.com/cc-tip-6-making-classes-non-derivable/184401394\" rel=\"nofollow noreferrer\">here</a> to disallow derivation. </p>\n", "LastActivityDate": "2015-05-28T13:11:20.980"}});