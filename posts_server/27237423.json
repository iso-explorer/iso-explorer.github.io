post_cb({"bq_ids": {"n4140": {"so_27237423_27237787_1": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_27237423_27237787_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 382}}, "n3337": {"so_27237423_27237787_1": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_27237423_27237787_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 373}}, "n4659": {"so_27237423_27237787_1": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_27237423_27237787_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 397}}}, "27237787": {"Id": "27237787", "PostTypeId": "2", "Body": "<p>This is well-formed and well-defined. <code>{}</code> is used to copy-list-initialize an rvalue reference to <code>char [12]</code>, which creates a temporary <code>char [12]</code> array to which the reference is bound. This temporary lives until the end of the full expression - in this case, until the semicolon, so a pointer to an element in the array can be safely returned and used for printing within that expression. (The lambda returns a <code>char *</code> pointing to the first element of this array.)</p>\n<p>Standardese:</p>\n<p>\u00a78.5 [dcl.init]/p17: </p>\n<blockquote>\n<p id=\"so_27237423_27237787_0\">The semantics of initializers are as follows. [...]</p>\n<ul>\n<li>If the initializer is a (non-parenthesized) <em>braced-init-list</em>, the object or reference is list-initialized (8.5.4).</li>\n</ul>\n</blockquote>\n<p>\u00a78.5.4 [dcl.init.list]/p3:</p>\n<blockquote>\n<p id=\"so_27237423_27237787_1\">List-initialization of an object or reference of type <code>T</code> is defined\n  as follows:</p>\n<ul>\n<li>[...]</li>\n<li>Otherwise, if <code>T</code> is a reference type, a prvalue temporary of the type referenced by <code>T</code> is copy-list-initialized or\n  direct-list-initialized, depending on the kind of initialization for\n  the reference, and the reference is bound to that temporary. [ <em>Note</em>:\n  As usual, the binding will fail and the program is ill-formed if the\n  reference type is an lvalue reference to a non-const type. \u2014<em>end note</em>\n  ]</li>\n</ul>\n</blockquote>\n<p>\u00a712.2 [class.temporary]/p5:</p>\n<blockquote>\n<p id=\"so_27237423_27237787_2\">A temporary bound to a reference parameter in a function call (5.2.2)\n  persists until the completion of the full-expression containing the\n  call.</p>\n</blockquote>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-12-01T21:44:02.553", "Score": "7", "CreationDate": "2014-12-01T21:36:39.883", "ParentId": "27237423", "CommentCount": "1", "OwnerUserId": "2756719", "LastEditDate": "2014-12-01T21:44:02.553"}, "27237423": {"ViewCount": "164", "Body": "<p>I was wondering if I could use <code>snprintf</code> formatting in an <code>ostream</code> such that I could embed the call to <code>snprintf</code> in the stream expression itself. This compiles in GCC 4.9, but is it OK?   </p>\n<pre><code>    cout &lt;&lt; [](char (&amp;&amp;buf) [12], int d) { snprintf(buf, 12, \"%d\", d); return buf; } ({ }, 15) &lt;&lt; endl;\n</code></pre>\n", "AcceptedAnswerId": "27237787", "Title": "C++ using snprintf in ostream with rvalue buffer, is this well-formed?", "CreationDate": "2014-12-01T21:13:07.850", "Id": "27237423", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-12-01T21:26:16.747", "LastEditorUserId": "540815", "LastActivityDate": "2014-12-01T22:13:12.023", "Score": "6", "OwnerUserId": "540815", "Tags": "<c++><arrays><c++11><rvalue-reference>", "AnswerCount": "2"}, "27237591": {"Id": "27237591", "PostTypeId": "2", "Body": "<p>I'm pretty sure this is OK.  If I understand correctly, the lambda will return an object of type <code>char[12]</code> as a temporary (from automatic return type deduction).  That temporary can then be passed into another function, in this case <code>operator&lt;&lt;()</code>.</p>\n<p>It does potentially mean copies are made, but RVO may take care of that.</p>\n<p>UPDATE</p>\n<p>As noted in the comments and in the better answer provided by T.C., the return type deduced by this lambda is actually a char* rather than a char[12].  I have confirmed this with code in GCC.</p>\n", "LastEditorUserId": "1738399", "LastActivityDate": "2014-12-01T22:13:12.023", "Score": "3", "CreationDate": "2014-12-01T21:24:01.593", "ParentId": "27237423", "CommentCount": "2", "OwnerUserId": "1738399", "LastEditDate": "2014-12-01T22:13:12.023"}});