post_cb({"34024297": {"Id": "34024297", "PostTypeId": "2", "Body": "<p>To complete the other answers, here is the part of the C++ standard that explicitly prohibits operator overloading with two pointers (emphasis mine):</p>\n<blockquote>\n<p id=\"so_34023464_34024297_0\">An operator function shall either be a non-static member function or\n  be a non-member function <strong>that has at least one parameter whose type is\n  a class, a reference to a class, an enumeration, or a reference to an\n  enumeration.</strong> It is not possible to change the precedence, grouping, or\n  number of operands of operators. The meaning of the operators\n  = , (unary) &amp; , and , (comma), predefined for each type, can be changed for specific class and enumeration types by defining operator\n  functions that implement these operators. Operator functions are\n  inherited in the same manner as other base class functions.</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf#page.325\" rel=\"nofollow\">[over.oper]/6</a></p>\n<p>That explains why you can't use an overloaded <code>operator==</code> without changing the code in your <code>main</code> function.</p>\n", "LastEditorUserId": "3854322", "LastActivityDate": "2015-12-30T09:10:22.527", "Score": "2", "CreationDate": "2015-12-01T15:44:16.720", "ParentId": "34023464", "CommentCount": "0", "OwnerUserId": "3854322", "LastEditDate": "2015-12-30T09:10:22.527"}, "34023595": {"Id": "34023595", "PostTypeId": "2", "Body": "<p>The common implementation of == operator would be </p>\n<pre><code>bool operator==(const VAR &amp; lhs)\n</code></pre>\n<p>Even if you allocate a point to VAR object, you can \"call\" the == operator using * operator. </p>\n<pre><code>VAR *v1 = new VAR(5);\nVAR *v2 = new VAR(5);\n\nif (*v1 == *v2)\n    std::cout &lt;&lt; \"Success\\n\";\nelse\n    std::cout &lt;&lt; \"Fail\\n\";\n</code></pre>\n", "LastActivityDate": "2015-12-01T15:10:32.433", "CommentCount": "0", "CreationDate": "2015-12-01T15:10:32.433", "ParentId": "34023464", "Score": "1", "OwnerUserId": "1410246"}, "34023868": {"Id": "34023868", "PostTypeId": "2", "Body": "<pre><code>#include &lt;iostream&gt;\n\n\nstruct VAR\n{\n    int x;\n\nVAR()\n{\n    x = 0;\n}\n\nVAR(int val)\n{\n    x = val;\n}\n\nbool operator==(VAR &amp;lhs)\n{\n    std::cout &lt;&lt; \"operator called\\n\";\n    return (x == lhs.x);\n}\n\nbool operator==(VAR *lhs)\n{\n    std::cout &lt;&lt; \"ptr operator called\\n\";\n    return (x == lhs-&gt;x);\n}\n};\n\nint main()\n{\n    VAR *v1 = new VAR(5);\n    VAR *v2 = new VAR(5);\n\n   if (v1-&gt;operator==(v2))\n       std::cout &lt;&lt; \"Success\\n\";\n    else\n        std::cout &lt;&lt; \"Fail\\n\";\n\n    delete v1;\n    delete v2;\n\n    v1 = nullptr;\n    v2 = nullptr;\n\n\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2015-12-01T15:23:31.600", "CommentCount": "1", "CreationDate": "2015-12-01T15:23:31.600", "ParentId": "34023464", "Score": "-1", "OwnerUserId": "1950606"}, "bq_ids": {"n4140": {"so_34023464_34024297_0": {"length": 53, "quality": 0.9814814814814815, "section_id": 653}}, "n3337": {"so_34023464_34024297_0": {"length": 53, "quality": 0.9814814814814815, "section_id": 643}}, "n4659": {"so_34023464_34024297_0": {"length": 53, "quality": 0.9814814814814815, "section_id": 681}}}, "34023867": {"Id": "34023867", "PostTypeId": "2", "Body": "<p>Your <code>==</code> compares two pointers. Pointers are primitive types, <strong>regardless of what they point to</strong>, and <a href=\"https://isocpp.org/wiki/faq/intrinsic-types#intrinsics-and-operator-overloading\" rel=\"nofollow\">you cannot overload operators when all operands are of primitive types</a>.</p>\n<p>In other words: Your overloaded operators work if the left operand is a <code>VAR</code> and not a <code>VAR*</code>.</p>\n<p>Of course, your code does not make a convincing point for using pointers or dynamic memory allocation anyway. Just remove all of that:</p>\n<pre><code>int main()\n{\n    VAR v1(5);\n    VAR v2(5);\n\n    if (v1 == v2)\n        std::cout &lt;&lt; \"Success\\n\";\n    else\n        std::cout &lt;&lt; \"Fail\\n\";\n}\n</code></pre>\n<p>This way, you also don't need the second operator anymore. For the sake of completeness, you could invoke it like this:</p>\n<pre><code>int main()\n{\n    VAR v1(5);\n    VAR v2(5);\n\n    if (v1 == &amp;v2)\n        std::cout &lt;&lt; \"Success\\n\";\n    else\n        std::cout &lt;&lt; \"Fail\\n\";\n}\n</code></pre>\n", "LastEditorUserId": "3313064", "LastActivityDate": "2015-12-01T15:30:10.017", "Score": "1", "CreationDate": "2015-12-01T15:23:31.037", "ParentId": "34023464", "CommentCount": "1", "OwnerUserId": "3313064", "LastEditDate": "2015-12-01T15:30:10.017"}, "34023464": {"ViewCount": "144", "Body": "<p>I'm trying to compare two dynamically allocated struct pointers using operator overloading. It is to my understanding that operator overloads are supposed to be using pass by reference, so does that mean overloading the == operator to accomplish this particular goal isn't possible?</p>\n<p>The goal is to print out Success without editing the code in main()</p>\n<pre><code>#include &lt;iostream&gt;\n\n\nstruct VAR\n{\n    int x;\n\nVAR()\n{\n    x = 0;\n}\n\nVAR(int val)\n{\n    x = val;\n}\n\nbool operator==(VAR &amp;lhs)\n{\n    std::cout &lt;&lt; \"operator called\\n\";\n    return (x == lhs.x);\n}\n\nbool operator==(VAR *lhs)\n{\n    std::cout &lt;&lt; \"ptr operator called\\n\";\n    return (x == lhs-&gt;x);\n}\n};\n\nint main()\n{\n    VAR *v1 = new VAR(5);\n    VAR *v2 = new VAR(5);\n\n    if (v1 == v2)\n        std::cout &lt;&lt; \"Success\\n\";\n    else\n        std::cout &lt;&lt; \"Fail\\n\";\n\n    delete v1;\n    delete v2;\n\n    v1 = nullptr;\n    v2 = nullptr;\n\n    system(\"pause\");\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "34024297", "Title": "Operator Overloading for struct pointers", "CreationDate": "2015-12-01T15:03:09.780", "Id": "34023464", "CommentCount": "9", "LastEditDate": "2015-12-01T15:19:41.923", "PostTypeId": "1", "LastEditorUserId": "2159206", "LastActivityDate": "2015-12-30T09:10:22.527", "Score": "0", "OwnerUserId": "2159206", "Tags": "<c++><pointers><struct><operator-overloading>", "AnswerCount": "5"}, "34023579": {"Id": "34023579", "PostTypeId": "2", "Body": "<p>Consider the following code, almost the same as yours but without pointers:</p>\n<pre><code>VAR v1(5);\nVAR v2(5);\n\nif (v1 == v2) { ... }\n</code></pre>\n<p>That condition is actually handled by the compiler as</p>\n<pre><code>if (v1.operator==(v2)) { ... }\n</code></pre>\n<p>When you turn <code>v1</code> into a pointer, the compiler doesn't automatically dereference the pointer, i.e. it doesn't to</p>\n<pre><code>v1-&gt;operator==(v2)\n</code></pre>\n<p>The simple solution is to dereference the pointers yourself:</p>\n<pre><code>*v1 == *v2\n</code></pre>\n", "LastEditorUserId": "440558", "LastActivityDate": "2015-12-01T15:14:52.487", "Score": "2", "CreationDate": "2015-12-01T15:10:04.483", "ParentId": "34023464", "CommentCount": "3", "OwnerUserId": "440558", "LastEditDate": "2015-12-01T15:14:52.487"}});