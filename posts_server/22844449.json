post_cb({"22845309": {"PostTypeId": "2", "Body": "<p>In essence <code>static_cast&lt;&gt;</code> always creates something new with type provided between the angle brackets. Consider:</p>\n<pre><code>class base { int x; };\nclass derived: base { int y; };\n</code></pre>\n<p>Now the following code will not compile:</p>\n<pre><code>base *b;\nderived *d = &amp;static_cast&lt;derived&gt;(*b);   // wrong\n</code></pre>\n<p>The reason is simple: this code tries to create new instance of <code>derived</code> and pass a <code>base</code> to its constructor. It would compile if <code>derived</code> had the constructor for that. For example:</p>\n<pre><code>class derived: base\n{\n  int y;\n  derived(const base &amp;){}\n};\n</code></pre>\n<p>But now you have a temporary that is going to be deleted immediately.</p>\n<p>Obviously you don't want to create new <code>derived</code> instances here, but to reach the derived instance your base is part of. You need to create either a reference or a pointer to <code>derived</code> when performing the cast, and not a whole new instance of it. The following is going to work:</p>\n<pre><code>derived d;\nbase *bp = &amp;d;\nbase &amp;br =  d;\nderived &amp;dr = static_cast&lt;derived &amp;&gt;(br);\nderived *dp = static_cast&lt;derived *&gt;(bp);\n</code></pre>\n<p>Now both <code>dr</code> and <code>dp</code> point to the same <code>d</code> above.</p>\n", "LastActivityDate": "2014-04-03T18:11:55.257", "LastEditorUserId": "1587418", "Id": "22845309", "CommentCount": "0", "CreationDate": "2014-04-03T17:53:00.017", "ParentId": "22844449", "Score": "0", "OwnerUserId": "1587418", "LastEditDate": "2014-04-03T18:11:55.257"}, "22844647": {"PostTypeId": "2", "Body": "<p>The reason is: it doesn't, it can be pointers or references. This has to do with the following problem:</p>\n<pre><code> struct Base\n {\n\n };\n\n\n struct Derived : public Base\n {\n   int A;\n };\n\n //sizeof(Base)==0\n //sizeof(Derived)==4\n Base B;\n Derived X;\n X.A = 10;\n B=X;//what happens to Derived::A? There is no space to put it. This is called slicing.\n</code></pre>\n<p>Basically, you cannot make an INSTANCE of a based class with a derived class without risking slicing. But references/pointers are another matter. in that case, you are just interpreting how the memory pointed to is interpreted. Static cast doesn't actually do any operations in this case! Because of the way C++ classes are layed out (intentionally) everything that inherits from a Base class has t'she same memory layout from offset of 0 to sizeof(Base). Only after that do you add Derived stuff.</p>\n", "LastActivityDate": "2014-04-03T17:19:07.747", "Id": "22844647", "CommentCount": "1", "CreationDate": "2014-04-03T17:19:07.747", "ParentId": "22844449", "Score": "0", "OwnerUserId": "1756405"}, "bq_ids": {"n4140": {"so_22844449_22844672_1": {"length": 34, "quality": 0.918918918918919, "section_id": 6030}}, "n3337": {"so_22844449_22844672_1": {"length": 35, "quality": 0.9459459459459459, "section_id": 5798}}}, "22844827": {"PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_22844449_22844827_0\">Why does static_cast always require pointers?</p>\n</blockquote>\n<p>Well, not always. As you pointed out, the following is possible:</p>\n<pre><code>int i = static_cast&lt;int&gt;(3.14);\n</code></pre>\n<p><code>static_cast</code> can also be used to convert between references, just like with pointers.</p>\n<p>However, you have to take the following into account: When converting between two types, you can loose information. Suppose you have a class <code>Animal</code> and another class <code>Dog</code> that happens to inherit from it. What would this mean?</p>\n<pre><code>Dog d;\nAnimal a = static_cast&lt;Animal&gt;(d);\n</code></pre>\n<p>You're creating an <code>Animal</code> out of a <code>Dog</code>, but the <code>Dog</code>'s specific information will be thrown away. This is called <em>slicing</em>.</p>\n<p>Casting between pointers usually just involves reinterpreting memory; the underlying object stays the same.</p>\n", "OwnerDisplayName": "user2033018", "LastActivityDate": "2014-04-03T17:28:36.030", "Id": "22844827", "CommentCount": "1", "CreationDate": "2014-04-03T17:28:36.030", "ParentId": "22844449", "Score": "0"}, "22844449": {"ViewCount": "819", "Body": "<p>I recently had a situation where i had to use static_cast to cast a parent class to a child class, because i knew the object instance was that child class. I knew this based on an if condition.</p>\n<p>Something like this:</p>\n<pre><code>parent* foo;\nchild* bar;\nif(foo is instance of child class)\n   bar = static_cast&lt;child*&gt;(foo)\n</code></pre>\n<p>My question is:\nWhy does static_cast always require pointers? This did not work when i tried it with non-pointer variables.\nAn exception seems to be primitive data types.</p>\n<p>Is this because every pointer can be cast as a void*? Is that how static_cast works?</p>\n<p>Edit: I forgot to mention that it works with references. So the question, as it is currently framed, is wrong. Reframing the question to \"Why does static_cast require pointers or references?\"</p>\n", "Title": "Why does static_cast require pointers or references?", "CreationDate": "2014-04-03T17:10:14.153", "LastActivityDate": "2014-04-03T20:58:26.003", "CommentCount": "2", "LastEditDate": "2014-04-03T20:58:26.003", "PostTypeId": "1", "LastEditorUserId": "257065", "Id": "22844449", "Score": "0", "OwnerUserId": "257065", "Tags": "<c++><pointers><casting><static-cast>", "AnswerCount": "4"}, "22844672": {"PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_22844449_22844672_0\">Why does static_cast always require pointers?</p>\n</blockquote>\n<p>The operator <code>static_cast</code> doesn't require pointers, nor references.</p>\n<p><strong>C++ Standard n3337 \u00a7 5.2.9/4:</strong> </p>\n<blockquote>\n<p id=\"so_22844449_22844672_1\">Otherwise, <strong>an expression e can be explicitly converted to a type T\n  using a static_cast of the form <code>static_cast&lt;T&gt;(e)</code> if the declaration\n  <code>T t(e)</code>; is well-formed</strong>, for some invented temporary variable <code>t</code> (8.5).\n  The effect of such an explicit conversion is the same as performing\n  the declaration and initialization and then using the temporary\n  variable as the result of the conversion. The expression e is used as\n  a glvalue if and only if the initialization uses it as a glvalue.</p>\n</blockquote>\n<pre><code>parent* foo;\nchild* bar;\nif(foo is instance of child class)\n   bar = static_cast&lt;child*&gt;(foo)\n</code></pre>\n<blockquote>\n<p id=\"so_22844449_22844672_2\">This did not work when i tried it with non-pointer variables.</p>\n</blockquote>\n<p>For example? How you tried it?\nIf you mean</p>\n<pre><code>child c;\nparent p = static_cast&lt;parent&gt;( c);\n</code></pre>\n<p>then this is called <em>slicing</em>, what means p will only get those data from c which comes from parent class (how could object of class parent receive also child part, since child is addition to derived parent data?). </p>\n", "LastActivityDate": "2014-04-03T18:01:16.797", "LastEditorUserId": "147192", "Id": "22844672", "CommentCount": "4", "CreationDate": "2014-04-03T17:20:09.127", "ParentId": "22844449", "Score": "4", "OwnerUserId": "1141471", "LastEditDate": "2014-04-03T18:01:16.797"}});