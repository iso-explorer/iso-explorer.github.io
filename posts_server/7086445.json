post_cb({"7086445": {"CommentCount": "2", "ViewCount": "166", "PostTypeId": "1", "LastEditorUserId": "1228", "CreationDate": "2011-08-16T23:42:39.550", "LastActivityDate": "2013-06-26T20:17:13.120", "Title": "Is it safe to \"initialize\" an object of type T with *this = T() in a constructor of T?", "FavoriteCount": "1", "LastEditDate": "2013-06-26T20:17:13.120", "Id": "7086445", "Score": "4", "Body": "<p>Is the constructor Year() safe in this case ?</p>\n<pre><code>struct Year {\n   int year;\n   Year(int y) : year(y) {}\n   Year() { *this = Year(1970); } // *this = this-&gt;operator=(Year(1970));\n};\n\nYear y;\n</code></pre>\n<p>I think yes, because year has already been initialized with int() once the execution flows reaches the constructor body. Are there other problems to consider?</p>\n<p>Don't consider other cases in which the same trick might cause troubles. </p>\n", "Tags": "<c++>", "OwnerUserId": "896156", "AnswerCount": "3"}, "7086498": {"ParentId": "7086445", "PostTypeId": "2", "CommentCount": "21", "Body": "<p>Sure, <a href=\"http://codepad.org/gtSjCx8c\" rel=\"nofollow\">this will work</a>, and is valid.</p>\n<hr>\n<h3>Explanation</h3>\n<p>All data members and bases have already been constructed by the time your ctor-body runs, and:</p>\n<blockquote>\n<p id=\"so_7086445_7086498_0\"><code>[n3290: 12.7/4]</code> <strong>Member functions</strong>, including virtual functions\n  (10.3), <strong>can be called during construction or destruction</strong> (12.6.2). [..]</p>\n</blockquote>\n<p>Not to be confused with:</p>\n<blockquote>\n<p id=\"so_7086445_7086498_1\"><code>[n3290: 12.7/1]</code> For an object with a non-trivial constructor, <strong>referring to any\n  non-static member or base class of the object before the constructor\n  begins execution results in undefined behavior</strong>.</p>\n</blockquote>\n<p>(NB. \"before the constructor begins\"; this clause does not apply here.)</p>\n<p>And there's nothing in <code>12.8 \"Copying and moving class objects\"</code> to prohibit assignment during construction.</p>\n<hr>\n<h3>Caveat</h3>\n<p>Note that this does <em>not</em> mean that the object has begun its \"lifetime\":</p>\n<blockquote>\n<p id=\"so_7086445_7086498_2\"><code>[n3290: 3.8/1]:</code> The lifetime of an object of type <code>T</code> begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type <code>T</code> is obtained, and</li>\n<li>if the object has non-trivial initialization, its initialization is complete.</li>\n</ul>\n</blockquote>\n<p>And the final step in \"initialization\" for a non-delegating ctor:</p>\n<blockquote>\n<p id=\"so_7086445_7086498_3\"><code>[n3290: 12.6.2/10]:</code> [..] Finally, the compound-statement of the constructor body is executed.</p>\n</blockquote>\n<p>Put altogether, this means that an object's \"lifetime\" doesn't begin until its most derived constructor body has finished executing.</p>\n<p>In particular, passing a pointer to the object before it has started its life is not very useful, as doing almost anything through that pointer invokes Undefined Behaviour:</p>\n<blockquote>\n<p id=\"so_7086445_7086498_4\"><code>[n3290: 3.5/8]:</code> Before the lifetime of an object has started but\n  after the storage which the object will occupy has been allocated\n  or, after the lifetime of an object has ended and before the storage\n  which the object occupied is reused or released, any pointer that\n  refers to the storage location where the object will be or was located\n  may be used but only in limited ways. [..]</p>\n</blockquote>\n<p>However:</p>\n<blockquote>\n<p id=\"so_7086445_7086498_5\"><code>[n3290: 3.8/3]:</code> [..] [ Note: [..] Also, the behavior of an object\n  under construction and destruction might not be the same as the\n  behavior of an object whose lifetime has started and not ended. 12.6.2\n  and 12.7 describe the behavior of objects during the construction and\n  destruction phases. \u2014end note ]</p>\n</blockquote>\n<p>And, as we've already explored, <code>12.7</code> kindly informs us that members <em>may</em> be accessed during this phase of construction.</p>\n<hr>\n<h3>Suggestion</h3>\n<p>Your approach is hard to follow, though; I also had to look up the above passage before I could be sure that it's valid, so it's clearly not entirely intuitive.</p>\n<p>Fortunately C++0x introduces constructor delegation, so that you can write:</p>\n<pre><code>struct Year {\n   Year()      : Year(1970) {}\n   Year(int y) : year(y)    {}\n\n   int year;\n};\n</code></pre>\n<p><sup>(Alas, GCC 4.5.1 doesn't support this, so <a href=\"http://www.ideone.com/fv8Ns\" rel=\"nofollow\">I cannot demonstrate it to you on ideone.com</a>. In fact, <a href=\"http://gcc.gnu.org/projects/cxx0x.html\" rel=\"nofollow\">for GCC as a whole there's only a \"partial patch\" at time of writing</a>.)</sup></p>\n</hr></hr></hr>", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2011-08-18T15:45:49.177", "Id": "7086498", "Score": "5", "CreationDate": "2011-08-16T23:52:10.710", "LastActivityDate": "2011-08-18T15:45:49.177"}, "7086492": {"ParentId": "7086445", "PostTypeId": "2", "CommentCount": "12", "Body": "<p><em>This answer is probably wrong; see Tomalak's answer and the comments. I'll leave it for historic reasons, but you're probably OK calling member functions during the constructor.</em></p>\n<p>Most definitely not. If you have any <code>T*</code>, say <code>p</code>, then you may only invoke member functions via <code>p-&gt;</code> if <code>p</code> points to an object. But an object only begins its life when its constructor has finished. So while you're in the middle of the constructor, <code>this</code> does not point to an object! Therefore, you can most certainly not invoke any member functions like the assignment operator on this not-yet object.</p>\n<p>[Curiosum: It <em>is</em> legit to say <code>delete this;</code> in certain situations, you just have to make sure that the destructor does not refer to <code>this</code> in any way. It is also OK to pass <code>this</code> to some other place during the constructor, as long as it is not <em>dereferenced</em>, much like you can pass any garbage pointer around as long as you don't use it.]</p>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2011-08-17T00:14:25.743", "Id": "7086492", "Score": "0", "CreationDate": "2011-08-16T23:51:08.573", "LastActivityDate": "2011-08-17T00:14:25.743"}, "bq_ids": {"n4140": {"so_7086445_7086498_4": {"section_id": 7193, "quality": 0.9459459459459459, "length": 35}, "so_7086445_7086498_5": {"section_id": 7191, "quality": 0.75, "length": 21}, "so_7086445_7086498_0": {"section_id": 447, "quality": 0.7142857142857143, "length": 10}, "so_7086445_7086498_3": {"section_id": 438, "quality": 0.7142857142857143, "length": 5}, "so_7086445_7086498_1": {"section_id": 444, "quality": 0.8421052631578947, "length": 16}, "so_7086445_7086498_2": {"section_id": 7189, "quality": 0.625, "length": 5}}, "n3337": {"so_7086445_7086498_4": {"section_id": 6937, "quality": 0.9459459459459459, "length": 35}, "so_7086445_7086498_5": {"section_id": 6935, "quality": 0.75, "length": 21}, "so_7086445_7086498_0": {"section_id": 438, "quality": 0.7142857142857143, "length": 10}, "so_7086445_7086498_3": {"section_id": 429, "quality": 0.7142857142857143, "length": 5}, "so_7086445_7086498_1": {"section_id": 435, "quality": 0.8421052631578947, "length": 16}, "so_7086445_7086498_2": {"section_id": 6933, "quality": 0.625, "length": 5}}, "n4659": {"so_7086445_7086498_4": {"section_id": 8702, "quality": 0.918918918918919, "length": 34}, "so_7086445_7086498_3": {"section_id": 458, "quality": 0.7142857142857143, "length": 5}, "so_7086445_7086498_0": {"section_id": 469, "quality": 0.7142857142857143, "length": 10}, "so_7086445_7086498_5": {"section_id": 8700, "quality": 0.75, "length": 21}, "so_7086445_7086498_1": {"section_id": 467, "quality": 0.8421052631578947, "length": 16}, "so_7086445_7086498_2": {"section_id": 8697, "quality": 0.625, "length": 5}}}, "7086565": {"ParentId": "7086445", "CommentCount": "1", "Body": "<p>What you're doing works, but what wouldn't work would be if you somehow recursively called a constructor ... that would cause problems.  But since the constructor is called after all non-static data-members of the object have been constructed, and the <code>this</code> pointer is pointing to valid memory that can be copied into, what you've done is okay--it's not standard practice, but it's okay.</p>\n", "OwnerUserId": "649233", "PostTypeId": "2", "Id": "7086565", "Score": "2", "CreationDate": "2011-08-17T00:00:24.720", "LastActivityDate": "2011-08-17T00:00:24.720"}});