post_cb({"3236408": {"ParentId": "3236199", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-07-13T10:54:30.380", "Score": "4", "LastEditorUserId": "123111", "LastEditDate": "2010-07-13T11:02:57.113", "Id": "3236408", "OwnerUserId": "123111", "Body": "<p>This is according to C++ Standard 14.7.3/18:</p>\n<blockquote>\n<p id=\"so_3236199_3236408_0\">In an explicit specialization declaration for a member of a class template or a member template that appears\n  in namespace scope, the member template and some of its enclosing class templates may remain unspecialized,\n  <strong>except that the declaration shall not explicitly specialize a class member template if its enclosing class\n  templates are not explicitly specialized as well</strong>. &lt;...&gt;</p>\n</blockquote>\n<p>It is not allowed to specialize <code>Spec</code> without specializing <code>TDataType</code>.</p>\n", "LastActivityDate": "2010-07-13T11:02:57.113"}, "3236586": {"ParentId": "3236199", "CommentCount": "2", "Body": "<p>Workaround</p>\n<pre><code>template &lt;bool v&gt; struct Bool2Type { static const bool value = v; }; \n\ntemplate &lt;typename TDataType&gt; \nclass TSpecWrapper \n{  \npublic: \n    typedef typename TDataType::parent_type index_type; \n\n\npublic: \n    template &lt;bool THasTriangles&gt; \n    void Spec(index_type&amp; io_index) \n    { \n        return SpecHelp(io_index, Bool2Type&lt;THasTriangles&gt;());\n    } \n\nprivate:\n    void SpecHelp(index_type&amp; io_index, Bool2Type&lt;false&gt;) \n    { std::cout &lt;&lt; \"False version\" &lt;&lt; std::endl; } \n\n    void SpecHelp(index_type&amp; io_index, Bool2Type&lt;true&gt;) \n    { std::cout &lt;&lt; \"True version\" &lt;&lt; std::endl; } \n\n}; \n</code></pre>\n", "OwnerUserId": "124161", "PostTypeId": "2", "Id": "3236586", "Score": "7", "CreationDate": "2010-07-13T11:14:59.890", "LastActivityDate": "2010-07-13T11:14:59.890"}, "bq_ids": {"n4140": {"so_3236199_3236408_0": {"section_id": 278, "quality": 1.0, "length": 35}}, "n3337": {"so_3236199_3236408_0": {"section_id": 269, "quality": 1.0, "length": 35}}, "n4659": {"so_3236199_3236408_0": {"section_id": 285, "quality": 1.0, "length": 35}}}, "3236199": {"CommentCount": "4", "ViewCount": "1445", "PostTypeId": "1", "LastEditorUserId": "151292", "CreationDate": "2010-07-13T10:27:40.370", "LastActivityDate": "2010-07-13T17:23:12.037", "Title": "VS2010 C++ member template function specialization error", "AcceptedAnswerId": "3236586", "LastEditDate": "2010-07-13T17:23:12.037", "Id": "3236199", "Score": "2", "Body": "<p>I have the following (minimized) code, which worked in VC2005, but no longer works in 2010.  </p>\n<pre><code>template &lt;typename TDataType&gt;\nclass TSpecWrapper\n  { \n  public:\n    typedef typename TDataType::parent_type index_type;\n\n\n  public:\n\n    template &lt;bool THasTriangles&gt;\n    void Spec(index_type&amp; io_index)\n      { std::cout &lt;&lt; \"False version\" &lt;&lt; std::endl; }\n\n    template &lt;&gt;\n    void Spec&lt;true&gt;(index_type&amp; io_index)\n      { std::cout &lt;&lt; \"True version\" &lt;&lt; std::endl; }\n  };\n</code></pre>\n<p>It seems that when \"index_type\" is a dependent type, I always get a  C2770: invalid explicit template argument(s) error on the specialization.  Note that this code is actually enough to generate the error - an empty main is sufficient to compile it, the template need not even be instantiated.</p>\n<p>It works fine if index_type is not a dependent type.  Any ideas why this is so in VC2010, if this is actually standard behaviour or a bug, and if I can work around it?</p>\n", "Tags": "<c++><visual-studio-2010><templates><specialization>", "OwnerUserId": "33987", "AnswerCount": "2"}});