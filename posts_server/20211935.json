post_cb({"bq_ids": {"n4140": {"so_20211935_20212155_1": {"length": 22, "quality": 0.7333333333333333, "section_id": 1907}}, "n3337": {"so_20211935_20212155_1": {"length": 22, "quality": 0.7333333333333333, "section_id": 1896}}, "n4659": {"so_20211935_20212155_1": {"length": 22, "quality": 0.7333333333333333, "section_id": 2177}}}, "20212155": {"Id": "20212155", "PostTypeId": "2", "Body": "<p>From <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2760.htm\" rel=\"nofollow\">C++ standards</a> (Input/Output Library Thread Safety):</p>\n<blockquote>\n<p id=\"so_20211935_20212155_0\">27.1.3 Thread safety [iostreams.thread-safety]</p>\n<p id=\"so_20211935_20212155_1\">Concurrent access to a stream object [string.streams, file.streams], stream buffer object\n  [stream.buffers], or C Library stream [c.files] by multiple threads may result in a data \n  race [intro.multithread] unless otherwise specified [iostream.objects]. [Note: Data races \n  result in undefined behavior [intro.multithread]. </p>\n</blockquote>\n", "LastEditorUserId": "1468366", "LastActivityDate": "2014-02-25T07:48:41.797", "Score": "6", "CreationDate": "2013-11-26T08:46:31.853", "ParentId": "20211935", "CommentCount": "2", "LastEditDate": "2014-02-25T07:48:41.797", "OwnerUserId": "1570711"}, "20212068": {"Id": "20212068", "PostTypeId": "2", "Body": "<p>If I haven't misunderstood you - no, nothing in the standard library is thread safe (except the <code>std::thread</code> specific things, of course (from C++11 and later)). You need additional synchronization. </p>\n<p>Even more - if there are several processes, reading from/writing to these files, you need to lock the files, to sync the access.</p>\n", "LastActivityDate": "2013-11-26T08:41:54.917", "Score": "7", "CreationDate": "2013-11-26T08:41:54.917", "ParentId": "20211935", "CommentCount": "8", "OwnerUserId": "435800"}, "40371965": {"Id": "40371965", "PostTypeId": "2", "Body": "<p>Yes. It is.</p>\n<p>For Windows:\nit is safe to write to fstream from multiple threads on windows. Please see the msdn document: <a href=\"https://msdn.microsoft.com/en-us/library/c9ceah3b.aspx\" rel=\"nofollow noreferrer\">Thread Safety in the C++ Standard Library</a></p>\n<p>For Linux:\nIn short, it is. From the <a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_concurrency.html\" rel=\"nofollow noreferrer\">document of libstdc++</a>: \"if your platform's C library is threadsafe, then your fstream I/O operations will be threadsafe at the lowest level\". Is your platform's C library threadsafe? Yes. The POSIX standard requires that C stdio FILE* operations(such as fread/fwrite) are atomic, and glibc did so.</p>\n", "LastEditorUserId": "523503", "LastActivityDate": "2016-11-03T02:32:39.913", "Score": "0", "CreationDate": "2016-11-02T03:21:41.993", "ParentId": "20211935", "CommentCount": "0", "LastEditDate": "2016-11-03T02:32:39.913", "OwnerUserId": "523503"}, "20211935": {"ViewCount": "7402", "Body": "<p>I am working on a program, which uses multiple <code>std::ifstream</code>s for reading a binary file, one <code>std::ifstream</code> for each thread. Now I need to know, if <code>std::ofstream</code> is thread-safe on Windows and Linux for writing in a same file. I am using using only one <code>std::ofstream</code> and using for multiple threads.<br>\nI am reading different blocks using using each thread and writing those block in output file using <code>seekp()</code> and <code>write()</code>. Currently it is working for me but whether it is problematic for big files. </br></p>\n<p>Is <code>std::ofstream</code> thread safe?</p>\n", "AcceptedAnswerId": "20212155", "Title": "Is ofstream thread safe?", "CreationDate": "2013-11-26T08:33:11.807", "Id": "20211935", "CommentCount": "3", "LastEditDate": "2016-09-08T06:03:21.053", "PostTypeId": "1", "LastEditorUserId": "435800", "LastActivityDate": "2016-11-03T02:32:39.913", "Score": "3", "OwnerUserId": "3020368", "Tags": "<c++><multithreading>", "AnswerCount": "3"}});