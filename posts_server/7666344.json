post_cb({"bq_ids": {"n4140": {"so_7666344_7674214_0": {"length": 11, "quality": 1.0, "section_id": 514}, "so_7666344_7674214_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 526}, "so_7666344_7673994_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 521}, "so_7666344_7673994_1": {"length": 15, "quality": 1.0, "section_id": 523}}, "n3337": {"so_7666344_7673994_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 512}, "so_7666344_7674214_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 517}, "so_7666344_7674214_0": {"length": 11, "quality": 1.0, "section_id": 505}, "so_7666344_7673994_1": {"length": 15, "quality": 1.0, "section_id": 514}}, "n4659": {"so_7666344_7673994_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 542}, "so_7666344_7674214_0": {"length": 11, "quality": 1.0, "section_id": 535}, "so_7666344_7674214_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 547}, "so_7666344_7673994_1": {"length": 15, "quality": 1.0, "section_id": 544}}}, "7666344": {"ViewCount": "5789", "Body": "<p>I sometimes deliberately omit macro arguments. For example, for a function-like macro like</p>\n<pre><code>#define MY_MACRO(A, B, C)  ...\n</code></pre>\n<p>I might call it as:</p>\n<pre><code>MY_MACRO(, bar, baz)\n</code></pre>\n<p>There are still technically 3 arguments; it's just that the first one is \"empty\". This question is not about variadic macros.</p>\n<p>When I do this I get warnings from g++ when compiling with <code>-ansi</code> (aka <code>-std=c++98</code>), but not when I use <code>-std=c++0x</code>. Does this mean that empty macro args are legal in the new C++ standard? </p>\n<p>That's the entirety of my question, but anticipating the \"why would you want to?\" response, here's an example. I like keeping .h files uncluttered by function bodies, but implementing simple accessors outside of the .h file is tedious. I therefore wrote the following macro:</p>\n<pre><code>#define IMPLEMENT_ACCESSORS(TEMPLATE_DECL, RETURN_TYPE, CLASS, FUNCTION, MEMBER) \\\n  TEMPLATE_DECL                                                         \\\n  inline RETURN_TYPE* CLASS::Mutable##FUNCTION() {                      \\\n    return &amp;MEMBER;                                                     \\\n  }                                                                     \\\n                                                                        \\\n  TEMPLATE_DECL                                                         \\\n  inline const RETURN_TYPE&amp; CLASS::FUNCTION() const {                   \\\n    return MEMBER;                                                      \\\n  }\n</code></pre>\n<p>This is how I would use it for a class template that contains an <code>int</code> called <code>int_</code>:</p>\n<pre><code>IMPLEMENT_ACCESSORS(template&lt;typename T&gt;, int, MyTemplate&lt;T&gt;, Int, int_)\n</code></pre>\n<p>For a non-template class, I don't need <code>template&lt;typename T&gt;</code>, so I omit that macro argument:</p>\n<pre><code>IMPLEMENT_ACCESORS(, int, MyClass, Int, int_)\n</code></pre>\n", "AcceptedAnswerId": "7674214", "Title": "Are empty macro arguments legal in C++11?", "CreationDate": "2011-10-05T19:08:08.383", "Id": "7666344", "CommentCount": "7", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2011-10-06T12:09:38.363", "LastEditorUserId": "256138", "LastActivityDate": "2016-06-04T20:03:57.173", "Score": "17", "OwnerUserId": "399397", "Tags": "<c++><macros><c++11>", "AnswerCount": "3"}, "7666667": {"Id": "7666667", "PostTypeId": "2", "Body": "<p><strike>When I do that I normally put a comment in place of the argument.</strike></p>\n<p>Place a macro that will be expanded to the empty string.</p>\n<pre><code>#define NOARG\n...\nMY_MACRO(/*Ignore this Param*/ NOARG, bar, baz)\n</code></pre>\n<p>PS. I got no warning with g++ with or without the -std=c++98 flag.</p>\n<ul>\n<li>g++ (Ubuntu 4.4.3-4ubuntu5) 4.4.3</li>\n<li>g++ (Apple Inc. build 5666) 4.2.1 </li>\n</ul>\n", "LastEditorUserId": "14065", "LastActivityDate": "2016-06-04T20:03:57.173", "Score": "3", "CreationDate": "2011-10-05T19:31:52.940", "ParentId": "7666344", "CommentCount": "3", "OwnerUserId": "14065", "LastEditDate": "2016-06-04T20:03:57.173"}, "7673994": {"Id": "7673994", "PostTypeId": "2", "Body": "<p>Yes. The relevant bit is 16.3/11 </p>\n<blockquote>\n<p id=\"so_7666344_7673994_0\">The sequence of preprocessing tokens bounded by the outside-most\n  matching parentheses forms the list of arguments for the function-like\n  macro. The individual arguments within the list are separated by comma\n  preprocessing tokens.</p>\n</blockquote>\n<p>There's no requirement that a single argument corresponds to precisely one token. In fact, the following section makes it clear that there can be more than one token per argument:</p>\n<blockquote>\n<p id=\"so_7666344_7673994_1\">Before being substituted, each argument\u2019s preprocessing tokens are\n  completely macro replaced as if they formed the rest of the\n  preprocessing file</p>\n</blockquote>\n<p>In your case, one argument happens to correspond to zero tokens. That doesn't cause any contradiction. </p>\n<p>[edit]\nThis was changed by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1566.htm\" rel=\"noreferrer\">N1566</a> to bring C++11 in line with C99.</p>\n", "LastEditorUserId": "15416", "LastActivityDate": "2011-10-06T14:34:57.860", "Score": "6", "CreationDate": "2011-10-06T12:03:50.417", "ParentId": "7666344", "CommentCount": "5", "OwnerUserId": "15416", "LastEditDate": "2011-10-06T14:34:57.860"}, "7674214": {"Id": "7674214", "PostTypeId": "2", "Body": "<p>If I understand correctly, empty macro argument is allowed since C99 and\nC++0x(11).<br>\nC99 6.10.3/4 says:</br></p>\n<blockquote>\n<p id=\"so_7666344_7674214_0\">... the number of arguments (including those arguments consisting of\n  no preprocessing tokens) shall equal the number of parameters ...</p>\n</blockquote>\n<p>and C++ N3290 16.3/4 has the same statement, while C++03 16.3/10 mentions:<br/></p>\n<blockquote>\n<p id=\"so_7666344_7674214_1\">... any argument consists of no preprocessing tokens, the behavior is\n  undefined.</p>\n</blockquote>\n<p>I think empty argument comes under the representation <em>arguments consisting of\nno preprocessing tokens</em> above.<br>\nAlso, 6.10.3 in Rationale for International Standard Programming Languages C rev. 5.10\n says:<br/></br></p>\n<blockquote>\n<p id=\"so_7666344_7674214_2\">A new feature of C99: Function-like macro invocations may also now\n  have empty arguments, that is, an argument may consist of no\n  preprocessing tokens.</p>\n</blockquote>\n", "LastEditorUserId": "547710", "LastActivityDate": "2011-10-06T12:35:16.243", "Score": "12", "CreationDate": "2011-10-06T12:26:00.173", "ParentId": "7666344", "CommentCount": "2", "OwnerUserId": "547710", "LastEditDate": "2011-10-06T12:35:16.243"}});