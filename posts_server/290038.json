post_cb({"292390": {"Body": "<p>It depends if the function is a <em>function template</em> or not. </p>\n<p>In <strong>C++ Templates -- the complete guides</strong>, Jusuttis provides a different definition of that given in the C++ standard, but with equivalent consequences:</p>\n<p>We define the signature of a function as the the following information:</p>\n<ol>\n<li>The <em>unqualified name</em> of the function</li>\n<li>The <em>class</em> or <em>namespace</em> scope of that name, and if the name has internal linkage, the translation unit in which the name is declared</li>\n<li>The <code>const</code>, <code>volatile</code>, or <code>const volatile</code> qualification of the function</li>\n<li>The <em>types</em> of the function parameters</li>\n<li><strong>its return <em>type</em>, if the function is generated from a function template</strong></li>\n<li>The <em>template parameters</em> and the <em>template arguments</em>, if the function is generated from a function template</li>\n</ol>\n<p>As <strong>litb</strong> suggested, it's worth to clarify why the return type is part of the signature of a template function. </p>\n<blockquote>\n<p id=\"so_290038_292390_0\">Functions can coexist in a program if\n  they have distinct signatures.</p>\n</blockquote>\n<p>. That said, if the return type is a template parameter:</p>\n<pre><code>template &lt;typename T&gt;\nT foo(int a)\n{return T();}\n</code></pre>\n<p>it's possibile to instantiate two function which differ only in the return type:</p>\n<pre><code>foo&lt;int&gt;(0);\nfoo&lt;char&gt;(0);\n</code></pre>\n<p>Not only: as rightly reported by <strong>litb</strong>, it is also possible to overload two template functions, which differ only in the return type, even if the return type is not a dependent name. Here's his example:</p>\n<pre><code>template&lt;class T&gt; int foo(T)\n{}\n\ntemplate&lt;class T&gt; bool foo(T)\n{}\n\n// at the instantiation point it is necessary to specify the cast\n// in order not to face ambiguous overload\n\n((int(*)(char))foo&lt;char&gt;)('a'); \n</code></pre>\n", "CreationDate": "2008-11-15T10:29:10.397", "ParentId": "290038", "CommentCount": "7", "LastEditDate": "2008-11-15T12:14:34.973", "PostTypeId": "2", "LastEditorDisplayName": "Nicola Bonelli", "LastActivityDate": "2008-11-15T12:14:34.973", "LastEditorUserId": "19630", "Id": "292390", "OwnerDisplayName": "Nicola Bonelli", "Score": "9", "OwnerUserId": "19630"}, "290048": {"Body": "<p>Normal functions do not include the return type in their signature. </p>\n<p><sub>(<em>note</em>: i've rewritten this answer, and the comments below don't apply to this revision - see the edit-history for details).</sub></p>\n<h3>Introduction</h3>\n<p>However, the matter about functions and function declarations in the Standard is complicated. There are two layers that have to be considered:</p>\n<ul>\n<li>Declarations</li>\n<li>Entities</li>\n</ul>\n<p>The so-called <em>function declaration</em> may declare a function entity or a template entity. If a function entity is declared, then you either have to do with an explicit specialization of a function template (with all arguments specified), or a declaration of an ordinary function. If a template entity is declared, then you are declaring a primary function template, or an explicit specialization where some arguments are not specified. (This is very similar to the relation of \"object declaration\" and objects or references: The former may declare either an object or a reference. So an <em>object declaration</em> may not necessarily declare an object!). </p>\n<p>The Standard defines the signature of a function to include the following at <code>1.3.10</code>:</p>\n<blockquote>\n<p id=\"so_290038_290048_0\">The types of its parameters and, if the function is a class member, the cv- qualifiers (if any) on the function itself and the class in which the member function is declared. The signature of a function template specialization includes the types of its template arguments. (14.5.5.1)</p>\n</blockquote>\n<p>It's missing the return type in this definition, which <em>is</em> part of the signature of a function template specialization (i.e a function declaration that declares a function which is a specialization of a template), as pointed out by <code>14.5.5.1</code> (recent C++0x working papers fixed that already to mention the return type in <code>1.3.10</code> too):</p>\n<blockquote>\n<p id=\"so_290038_290048_1\">The signature of a function template specialization consists of the signature of the function template and of the actual template arguments (whether explicitly specified or deduced).</p>\n<p id=\"so_290038_290048_2\">The signature of a function template consists of its function signature, its return type and its template parameter list. </p>\n</blockquote>\n<h3>So what exactly does a signature contain, again?</h3>\n<p>So, when we ask about the signature of a <em>function</em>, we have to give two answers:</p>\n<ul>\n<li>For functions that are specializations of function templates, the signature includes the return type. </li>\n<li>For functions that are not specializations, the return type is not part of the signature. </li>\n</ul>\n<p>Notice, however, that the return type, in any case, <em>is</em> a significant part of the type of a function. That is, the following is not valid:</p>\n<pre><code>void f();\nint (*pf)() = &amp;f; // different types!\n</code></pre>\n<h3>When is an overload invalid if only the return type differs?</h3>\n<p>Major compilers currently reject the following code:</p>\n<pre><code>int f();\ndouble f(); // invalid\n</code></pre>\n<p>But accept the following code:</p>\n<pre><code>template&lt;typename T&gt; int f();\ntemplate&lt;typename T&gt; double f(); // invalid?\n</code></pre>\n<p>However, the <strong>Standard does forbid a function declaration that only differs in the return type</strong> (when defining when an overload is valid, and when not). It does not define precisely what \"differs only by return type\" means, though.</p>\n<hr>\n<p>Standard paragraph references:</p>\n<ul>\n<li>When can a function declaration be overloaded: <code>13.1</code></li>\n<li>What is a function declaration: <code>7/2</code> and <code>7/5</code></li>\n<li>What is the signature of a function template/specialization: <code>14.5.5.1</code></li>\n</ul>\n<p>For reference, here is what the most recent C++0x draft n3000 says about \"signature\" in <code>1.3.11</code>, which is much more complete in its coverage of the different type of entities:</p>\n<blockquote>\n<p id=\"so_290038_290048_3\">the name and the parameter type list (8.3.5) of a function, as well as the class or namespace of which it is a member. If a function or function template is a class member its signature additionally includes the cv-quali\ufb01ers (if any) and the ref-quali\ufb01er (if any) on the function or function template itself. The signature of a function template additionally includes its return type and its template parameter list. The signature of a function template specialization includes the signature of the template of which it is a specialization and its template arguments (whether explicitly speci\ufb01ed or deduced). [ Note: Signatures are used as a basis for name mangling and linking. \u2014 end note ]</p>\n</blockquote>\n</hr>", "CreationDate": "2008-11-14T13:20:33.453", "ParentId": "290038", "CommentCount": "9", "LastEditDate": "2009-12-18T12:09:20.477", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2009-12-18T12:09:20.477", "LastEditorUserId": "34509", "Id": "290048", "OwnerDisplayName": "litb", "Score": "77", "OwnerUserId": "34509"}, "bq_ids": {"n4140": {"so_290038_290048_1": {"length": 11, "quality": 0.6875, "section_id": 5768}, "so_290038_290048_2": {"length": 9, "quality": 0.6, "section_id": 5768}}, "n3337": {"so_290038_290048_1": {"length": 11, "quality": 0.6875, "section_id": 5541}, "so_290038_290048_2": {"length": 9, "quality": 0.6, "section_id": 5541}}, "n4659": {"so_290038_290048_1": {"length": 11, "quality": 0.6875, "section_id": 7225}, "so_290038_290048_2": {"length": 9, "quality": 0.6, "section_id": 7225}}}, "309660": {"Id": "309660", "PostTypeId": "2", "Body": "<p>They are enough a part of the type that you can overload functions based on function pointer types that differ only by return type:</p>\n<pre><code>int IntFunc() { return 0; }\nchar CharFunc() { return 0; }\n\nvoid FuncFunc(int(*func)()) { cout &lt;&lt; \"int\\n\"; }\nvoid FuncFunc(char(*func)()) { cout &lt;&lt; \"char\\n\"; }\n\n\nint main()\n{\n    FuncFunc(&amp;IntFunc); // calls void FuncFunc(int_func func)\n    FuncFunc(&amp;CharFunc); // calls void FuncFunc(char_func func)\n}\n</code></pre>\n", "OwnerDisplayName": "Josh", "LastActivityDate": "2008-11-21T18:11:50.443", "Score": "2", "CreationDate": "2008-11-21T18:11:50.443", "ParentId": "290038", "CommentCount": "0", "OwnerUserId": "8701"}, "290038": {"ViewCount": "33652", "Body": "<p>In C++, is the return type considered part of the function signature? and no overloading is allowed with just return type modified.</p>\n", "AcceptedAnswerId": "290048", "Title": "Is the return type part of the function signature?", "CreationDate": "2008-11-14T13:17:16.487", "Id": "290038", "CommentCount": "0", "FavoriteCount": "32", "PostTypeId": "1", "LastEditDate": "2008-11-14T13:21:09.863", "LastEditorDisplayName": "yesraaj", "OwnerDisplayName": "yesraaj", "LastEditorUserId": "22076", "LastActivityDate": "2009-12-18T12:09:20.477", "Score": "57", "OwnerUserId": "22076", "Tags": "<c++><function>", "AnswerCount": "3"}});