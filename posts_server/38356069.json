post_cb({"bq_ids": {"n4140": {"so_38356069_38356176_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 603}}, "n3337": {"so_38356069_38356176_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 593}}, "n4659": {"so_38356069_38356176_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 629}}}, "38356069": {"ViewCount": "107", "Body": "<p>If I have a <code>struct A</code> defined as:</p>\n<pre><code>struct A {\n    const char *data;\n    operator const char * () const { return data; }\n    friend bool operator== (const A &amp;s1, const char *s2)\n    { return /* typical string comparison result */; }\n};\n</code></pre>\n<p>And I write <code>A{\"hello\"} == \"test2\"</code>, is <code>A::operator==</code> called? What in the standard states that (and why isn't the <code>A</code> implicitly converted to <code>const char *</code>?)</p>\n<p>What about <code>\"test2\" == A{\"hello\"}</code>? Is the <code>A</code> converted in this case?</p>\n<p><strong>EDIT</strong>: What about if <code>struct A</code> also has member:</p>\n<pre><code>friend bool operator== (const char *s1, const A &amp;s2)\n</code></pre>\n", "AcceptedAnswerId": "38356176", "Title": "C++ operator == and implicit conversion resolution", "CreationDate": "2016-07-13T15:35:48.110", "Id": "38356069", "CommentCount": "9", "LastEditDate": "2016-07-13T16:01:08.037", "PostTypeId": "1", "LastEditorUserId": "2069064", "LastActivityDate": "2016-07-13T16:01:08.037", "Score": "3", "OwnerUserId": "2390010", "Tags": "<c++><operator-overloading><implicit-conversion><overload-resolution>", "AnswerCount": "1"}, "38356176": {"Id": "38356176", "PostTypeId": "2", "Body": "<p>When you do</p>\n<pre><code>A{\"hello\"} == \"test2\"\n</code></pre>\n<p>we perform overload resolution on <code>operator==</code>. First, we find the viable candidates ([over.match.viable]), via name lookup:</p>\n<pre><code>operator==(A const&amp;, const char*);    // yours\noperator==(const char*, const char*); // built-in\n</code></pre>\n<p>Next, we determine which candidate has the best implicit conversion sequence. This is the first tiebreaker in [over.match.best]:</p>\n<blockquote>\n<p id=\"so_38356069_38356176_0\">Given these definitions, a viable function <code>F1</code> is defined to be a <em>better</em> function than another viable function <code>F2</code> if for all arguments <em>i</em>, ICS<sub>i</sub>(F1) is not a worse conversion sequence than ICS<sub>i</sub>(F2), and then<br>\n  (1.3) \u2014 for some argument <em>j</em>, ICS<sub>j</sub>(F1) is a better conversion sequence than ICS<sub>j</sub>(F2), or, if not that, [...]</br></p>\n</blockquote>\n<p>Both operators are Exact Match on the 2nd argument. On the first argument, your <code>operator==</code> is an Exact Match whereas the built-in requires a user-defined conversion. Exact Match is the best kind of conversion, and user-defined is the worst - hence, yours has the better conversion sequence and becomes the best viable function. </p>\n<p>In broader terms, the <code>A</code> isn't implicitly converted to a <code>const char*</code> because there's a better option where it doesn't have to be. </p>\n<hr/>\n<p>When you do:</p>\n<pre><code>\"test2\" == A{\"hello\"};\n</code></pre>\n<p>Your candidate isn't viable - there is no implicit conversion from <code>const char*</code> to <code>A const&amp;</code> (first argument), so the only viable candidate is the built-in comparison for <code>const char*</code>, which requires the user-defined conversion from <code>A</code> to <code>const char*</code>.</p>\n<p>If you'd like your <code>A::operator==</code> to be invoked, you'd have to add a new overload for <code>operator==(const char*, A const&amp;)</code>. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-07-13T15:53:14.130", "Score": "4", "CreationDate": "2016-07-13T15:41:11.210", "ParentId": "38356069", "CommentCount": "9", "LastEditDate": "2016-07-13T15:53:14.130", "OwnerUserId": "2069064"}});