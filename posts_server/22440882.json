post_cb({"bq_ids": {"n4140": {"so_22440882_22528423_0": {"length": 11, "quality": 1.0, "section_id": 703}}, "n3337": {"so_22440882_22528423_0": {"length": 11, "quality": 1.0, "section_id": 693}}, "n4659": {"so_22440882_22528423_0": {"length": 11, "quality": 1.0, "section_id": 732}}}, "22528423": {"Id": "22528423", "PostTypeId": "2", "Body": "<p>This is a very tricky question that has been discussed at some length in <a href=\"https://stackoverflow.com/questions/8631531/what-does-constant-complexity-really-mean-time-count-of-copies-moves\">this thread</a>.</p>\n<p>If I could try to summarize it: The standard makes some subtle distinctions. If you read it precisely, some operations <em>are</em> indeed specified to be \"constant time\", but <code>std::list</code> insertion is <em>not</em> among them. It is specified to be \"constant\" (<strong>Edit</strong>: wrong, see below)  and the \"General Container Requirements\" clause (23.2.1 in <a href=\"http://isocpp.org/files/papers/N3690.pdf\" rel=\"nofollow noreferrer\">this draft of the C++ standard</a>) explains that</p>\n<blockquote>\n<p id=\"so_22440882_22528423_0\">All of the complexity requirements in this Clause are stated solely in terms of the number of operations on the contained objects.</p>\n</blockquote>\n<p>(<strong>Edit</strong>: as Filip Ros\u00e9en pointed out, I was mistaken; <code>std::list</code> insertion <em>is</em> specified to be \"constant time\", but I believe the General Requirements clause still governs). So because list insertion only has to work on a single object and its neighbors, it's \"constant complexity\" even though it may not necessarily be \"constant <em>time</em> complexity\" because there are no time complexity guarantees for the allocation.</p>\n<p>Pragmatically, a decent memory allocator will <em>not</em> be linear in the number of objects allocated, though it probably is not constant time either.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-20T09:54:22.760", "Score": "1", "CreationDate": "2014-03-20T09:21:27.407", "ParentId": "22440882", "CommentCount": "4", "LastEditDate": "2017-05-23T11:43:33.403", "OwnerUserId": "2332553"}, "22527303": {"Id": "22527303", "PostTypeId": "2", "Body": "<p><sup> <strong>Note:</strong> It is important to note the difference between \"real life time\" and the \"time\" talked about when diving into time complexity. When time complexity is the topic it's important that one doesn't confuse the usage of <em>\"time\"</em> with <em>\"milliseconds spent doing something\"</em>.</sup></p>\n<hr>\n<p><strong>WHAT IS THE DEFINITION OF <em>constant time</em>?</strong></p>\n<p>Wikipedia is often said to be a bad reference in many contexts, but in this case (and a lot of others) the definitions available is correct and will help to describe how things work.</p>\n<p>The article about <a href=\"http://en.wikipedia.org/wiki/Time_complexity\" rel=\"nofollow\">time complexity</a> says the following about <em>constant time</em>:</p>\n<blockquote>\n<p id=\"so_22440882_22527303_0\"><a href=\"http://en.wikipedia.org/wiki/Time_complexity#Constant_time\" rel=\"nofollow\"><strong>Wikipedia - Constant Time</strong></a></p>\n<p id=\"so_22440882_22527303_1\">An algorithm is said to be constant time (also written as O(1) time) if the value of T(n) is bounded by a value that does not depend on the size of the input. For example, accessing any single element in an array takes constant time as only one operation has to be performed to locate it.</p>\n</blockquote>\n<hr>\n<p>Since the insertion into a <code>std::list</code> does not depend on the number of elements in the list we say that insertion is constant time; each insertion, no matter where or when, consists of the same number of elementary operations; none related to the size of the list.</p>\n<hr>\n<hr>\n<p><strong>But what if <code>operator new</code> is not <code>O(1)</code>?</strong></p>\n<p>Honestly it doesn't matter, even if the complexity of <code>new</code> would implicitly depend on how many previous entities we have allocated, the complexity of our <em>list-insertion</em> will be unchanged. The allocation is indifferent to the size of the list.</p>\n<p><code>O(1)</code>, <em>constant time</em>, means that the time to execute something is unrelated to the size of input in any given algorithm. Even if <code>new</code> isn't <code>O(1)</code>, our insertation is <code>O(1)</code> since it only describes itself.</p>\n<p>The paths taken inside our <em>list inseration</em> all includes <code>operator new</code>. The path doesn't change because of the size of our list, the path's complexity is <em>constant time</em>.</p>\n<hr>\n<hr>\n<p><strong>So what are we dealing with?</strong></p>\n<p><code>Hannibal_Smith</code> in <code>##c++ at freenode</code> said something clever, and I liked it so much that I will include it in this post: <em>The cost model is a pointer machine.</em></p>\n<p>Even though the sentence might be a little bit misleading it does serve the purpose of explaining how the insertion is <code>O(1)</code> even though parts of the algorithm isn't <em>constant time</em>.</p>\n<p>The insertion into a <code>std::list</code> is described from the perspective of being a machine who only deals with pointers, and from this perspective one cannot say that it is nothing other than <code>O(1)</code>. The allocation done inside this algorithm is not related to the complexity of the algorithm itself.</p>\n</hr></hr></hr></hr></hr></hr>", "LastEditorUserId": "1090079", "LastActivityDate": "2014-03-20T14:03:57.970", "Score": "3", "CreationDate": "2014-03-20T08:27:57.320", "ParentId": "22440882", "CommentCount": "5", "LastEditDate": "2014-03-20T14:03:57.970", "OwnerUserId": "1090079"}, "22440882": {"ViewCount": "969", "Body": "<p>Insertion on std::list is claimed to be constant time, regardless whether it is\nmade in the front, middle or back of the container.</p>\n<p>On the other hand, acquisition of memory for the new inserted item is handled by\nthe standard allocator, which uses operator new. AFAIK operator new is not guaranteed\nto have constant time.</p>\n<p>When operator new looks for available space in the heap, it must be sure that it\nwill not override previously allocated memory, therefore it has to keep track\nof what has already been allocated on the heap. I conclude that insertion\nmust be at least linear on the number of elements already in the list.</p>\n<p>What is wrong with this reasoning?</p>\n<hr>\n<p>My question reads:</p>\n<ul>\n<li>How is it possible to say that insertion on lists is constant\ntime, when acquiring memory for each new node is not guaranteed to be constant time? </li>\n</ul>\n</hr>", "Title": "Time complexity and insertion into std::list", "CreationDate": "2014-03-16T18:19:56.670", "LastActivityDate": "2014-03-20T14:03:57.970", "CommentCount": "7", "LastEditDate": "2014-03-20T13:59:22.610", "PostTypeId": "1", "LastEditorUserId": "1090079", "Id": "22440882", "Score": "7", "OwnerUserId": "1077832", "Tags": "<c++><list><new-operator><time-complexity>", "AnswerCount": "2"}});