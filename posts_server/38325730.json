post_cb({"38325730": {"CommentCount": "3", "ViewCount": "934", "PostTypeId": "1", "LastEditorUserId": "1464444", "CreationDate": "2016-07-12T10:04:45.777", "LastActivityDate": "2016-07-12T14:23:15.573", "LastEditDate": "2016-07-12T14:23:15.573", "AcceptedAnswerId": "38326110", "FavoriteCount": "4", "Title": "Why does auto return type deduction work with not fully defined types?", "Id": "38325730", "Score": "37", "Body": "<p>Consider the following:</p>\n<pre><code>template&lt;typename Der&gt;\nstruct Base {\n    // NOTE: if I replace the decltype(...) below with auto, code compiles\n    decltype(&amp;Der::operator()) getCallOperator() const {\n        return &amp;Der::operator();\n    }\n};\n\nstruct Foo : Base&lt;Foo&gt; {\n    double operator()(int, int) const {\n        return 0.0;\n    }\n};\n\nint main() {\n    Foo f;\n    auto callOp = f.getCallOperator();\n}\n</code></pre>\n<p>I want to create a member function in CRTP base class with a return type depending on signature of the <code>operator()</code> in the derived class. However <code>decltype(&amp;Der::operator())</code> fails to compile; The <code>operator()</code> member function in <code>Foo</code> is not visible. I assume that this is because the base class template is instantiated before <code>Foo</code> is fully defined.</p>\n<p>Surprisingly, if I place <code>auto</code> for the return type it compiles. I assumed that <code>auto</code> would make the compiler deduce the return type from the function body and fail - because the body uses the not fully defined <code>Foo</code> type.</p>\n<p>This behavior is the same for both MSVC 2015.3 and Clang 3.8</p>\n<p>Why did the code start to work with <code>auto</code>? Does <code>auto</code> type deduction somehow \"delay\" the instantiation? Or use a different context than a hand-written return type expression?</p>\n", "Tags": "<c++><c++14><crtp><return-type-deduction>", "OwnerUserId": "2617356", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_38325730_38326110_0": {"section_id": 5456, "quality": 1.0, "length": 21}}, "n4659": {"so_38325730_38326110_0": {"section_id": 6882, "quality": 1.0, "length": 21}}}, "38326110": {"ParentId": "38325730", "CommentCount": "0", "CreationDate": "2016-07-12T10:22:11.260", "OwnerUserId": "8922", "PostTypeId": "2", "Id": "38326110", "Score": "24", "Body": "<p>Your guess is correct. A deduced return type is not actually deduced until the signature of the function is needed. This means that it will be deduced in the context of the call to <code>getCallOperator</code>, at which point <code>Foo</code> is fully defined.</p>\n<p>This is specified in 7.1.6.4p12:</p>\n<blockquote>\n<p id=\"so_38325730_38326110_0\">Return type deduction for a function template with a placeholder in its declared type occurs when the definition is instantiated even if the function body contains a return statement with a non-type-dependent operand.</p>\n</blockquote>\n", "LastActivityDate": "2016-07-12T10:22:11.260"}});