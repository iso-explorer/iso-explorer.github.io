post_cb({"24869510": {"CommentCount": "8", "AcceptedAnswerId": "24870003", "CreationDate": "2014-07-21T16:01:24.403", "LastActivityDate": "2014-07-21T16:32:40.020", "PostTypeId": "1", "ViewCount": "187", "FavoriteCount": "1", "Title": "Is this strict aliasing example correct?", "Id": "24869510", "Score": "11", "Body": "<p>I've been reading up on the strict aliasing rules over the last week or so and ran into this article: <a href=\"http://dbp-consulting.com/tutorials/StrictAliasing.html\">Understanding C/C++ Strict Aliasing</a>.</p>\n<p>The article goes through several ways two swap the halves of a 32-bit integer, giving both good examples and ones that violate the strict aliasing rule.  I'm having trouble understanding one of the examples, though.</p>\n<p>This code is described as broken.</p>\n<pre><code>uint32_t\nswaphalves(uint32_t a)\n{\n    a = (a &gt;&gt; 16) | (a &lt;&lt; 16);\n    return a;\n}\n</code></pre>\n<p>The reason given is:</p>\n<blockquote>\n<p id=\"so_24869510_24869510_0\">This version looks reasonable, but you don't know if the right and left sides of the\n  | will each get the original version of <code>a</code> or if one of them will get the result of \n  the other. There's no sequence point here, so we don't know anything about the order of\n  operations here, and you may get different results from the same compiler using different\n  levels of optimization.</p>\n</blockquote>\n<p>I disagree.  This code looks fine to me.  There is only one write to <code>a</code> in the <code>a = (a &gt;&gt; 16 | (a &lt;&lt; 16);</code> line, and I expect that both reads of <code>a</code> take place before that write.  Further, there are no pointers or references and no incompatible types.</p>\n<p>Am I missing a strict aliasing violation in this code, or is the article incorrect?</p>\n", "Tags": "<c++><c><strict-aliasing>", "OwnerUserId": "914991", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24869510_24870003_0": {"section_id": 5811, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_24869510_24870003_0": {"section_id": 5584, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_24869510_24870003_0": {"section_id": 7272, "quality": 0.8333333333333334, "length": 10}}}, "24870003": {"ParentId": "24869510", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>There are no pointers and references anywhere in this code, so strict aliasing rules don't even enter the picture. And indeed the author invokes <em>sequence points</em> rather than strict aliasing to justify the assertion that it's undefined. However, it seems this reasoning is wrong and the code snippet has perfectly defined semantics. As <a href=\"https://stackoverflow.com/a/4183735/395760\">Prasoon Saurav explains in more detail</a>:</p>\n<blockquote>\n<p id=\"so_24869510_24870003_0\">(\u00a71.9/15) The value computations of the operands of an operator are sequenced before the value computation of the result of the operator.</p>\n</blockquote>\n<p>So regarding the <code>=</code> operator, the evaluation of <code>a</code> and  <code>(a &gt;&gt; 16) | (a &lt;&lt; 16)</code> are sequenced before the assignment. Neither of those is problematic: Although its parts are all unsequenced relative to each other, no write to <code>a</code> remains that would need to be sequenced.</p>\n<p>(Technically this raises the question of how the side effect of the assignment is sequenced w.r.t. its value computation, but I couldn't find anything on this. Presumably it's somewhere in the standard but I don't have a copy handy. I <em>strongly</em> suspect it's sequenced after the value computation for the reasons in the next paragraph.)</p>\n<p>You could also apply common sense: The write to <code>a</code> needs to evaluate <code>(a &gt;&gt; 16) | (a &lt;&lt; 16)</code> first <em>to write the right value</em> and hence it can't happen in the middle of that evaluation. Another issue with the article is that even if </p>\n<pre><code>uint32_t\nswaphalves(uint32_t a)\n{\n    a = (a &gt;&gt; 16) | (a &lt;&lt; 16);\n    return a;\n}\n</code></pre>\n<p>had undefined behavior due to sequence points,</p>\n<pre><code>uint32_t\nswaphalves(uint32_t a)\n{\n    return (a &gt;&gt; 16) | (a &lt;&lt; 16);\n}\n</code></pre>\n<p>wouldn't (there are no writes to be sequenced) and hence the far more complicated versions (unions, memcpy) that take up most of the rest of the article are pointless.</p>\n", "OwnerUserId": "395760", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:57:45.217", "Id": "24870003", "Score": "4", "CreationDate": "2014-07-21T16:26:11.457", "LastActivityDate": "2014-07-21T16:32:40.020"}});