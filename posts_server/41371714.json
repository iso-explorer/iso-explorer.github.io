post_cb({"41416686": {"ParentId": "41371714", "CommentCount": "4", "CreationDate": "2017-01-01T15:49:30.783", "OwnerUserId": "1639256", "PostTypeId": "2", "Id": "41416686", "Score": "1", "Body": "<p>Your implementation using a single, global <code>shared_future</code> is completely fine, if slightly unusual, and the book appears to be mistaken.</p>\n<blockquote>\n<p id=\"so_41371714_41416686_0\"><strong>[futures.shared_future] \u00b62</strong></p>\n<p id=\"so_41371714_41416686_1\">[ <em>Note:</em> Member functions of <code>shared_future</code> do not synchronize with themselves, but they synchronize with the shared state. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>Notes are non-normative, so the above is redundantly making explicit a fact which is already implicit in the normative wording.</p>\n<blockquote>\n<p id=\"so_41371714_41416686_2\"><strong>[intro.races] \u00b62</strong></p>\n<p id=\"so_41371714_41416686_3\">Two expression evaluations <em>conflict</em> if one of them modifies a memory location and the other one reads or modifies the same memory location.</p>\n<p id=\"so_41371714_41416686_4\"><strong>\u00b66</strong></p>\n<p id=\"so_41371714_41416686_5\">Certain library calls <em>synchronize with</em> other library calls performed by another thread.</p>\n<p id=\"so_41371714_41416686_6\">[...Additional paragraphs defining <em>happens before</em> in terms of synchronizes with...]</p>\n<p id=\"so_41371714_41416686_7\"><strong>\u00b619</strong></p>\n<p id=\"so_41371714_41416686_8\">Two actions are <em>potentially concurrent</em> if they are performed by different threads... The execution of a program contains a <em>data race</em> if it contains two potentially concurrent conflicting actions, at least one of which is not atomic, and neither happens before the other...</p>\n<p id=\"so_41371714_41416686_9\"><strong>[res.on.data.races] \u00b63</strong></p>\n<p id=\"so_41371714_41416686_10\">A C++ standard library function shall not directly or indirectly modify objects accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s non-const arguments, including <code>this</code>.</p>\n</blockquote>\n<p>So we know that calls to <code>global_sf.get()</code> in different threads are potentially concurrent unless you accompany them with additional synchronization (e.g. a mutex). But we also know that calls to <code>global_sf.get()</code> in different threads do not conflict, because it is a <code>const</code> method and hence forbidden from modifying objects accessible from multiple threads, including <code>*this</code>. So the definition of a data race (unsequenced, potentially concurrent conflicting actions) is not satisfied, the program does not contain a data race.</p>\n<p>One would usually wish to avoid global variables anyway, but that is a separate issue.</p>\n<p>Note that if the book is correct, then it contains a contradiction. The code which it claims is correct <em>still contains a global <code>shared_future</code></em> which is accessed from multiple threads when they create their local copies:</p>\n<pre><code>void worker_thread()\n{\n    auto local_sf = global_sf; // &lt;-- unsynchronized access of global_sf here\n\n    const bigdata *ptr = local_sf.get();\n    ...\n}\n</code></pre>\n", "LastActivityDate": "2017-01-01T15:49:30.783"}, "41371714": {"CommentCount": "2", "AcceptedAnswerId": "41416686", "PostTypeId": "1", "LastEditorUserId": "6651824", "CreationDate": "2016-12-29T00:42:05.460", "LastActivityDate": "2017-01-01T15:49:30.783", "LastEditDate": "2017-01-01T06:10:58.430", "ViewCount": "245", "FavoriteCount": "0", "Title": "why are multiple shared_future objects needed to synchronize data", "Id": "41371714", "Score": "0", "Body": "<p>A pointer to a data structure is shared with multiple threads via <code>std::promise</code> and <code>std::shared_future</code>.\nFrom the book '<em>C++ concurrency in action</em>' by Anthony Williams (pg. 85-86), it seems that data is only correctly synchronized when each receiving thread uses a copy\nof the <code>std::shared_future</code> object as opposed to each thread accessing a single, global <code>std::shared_future</code>.</p>\n<p>To illustrate, consider a thread creating <code>bigdata</code> and passing a pointer to multiple threads that have read-only access.\nIf data synchronization between threads is not handled correctly, memory reordering may lead to undefined behavior (eg. a <code>worker_thread</code> reading incomplete data).</p>\n<p>This (incorrect ?) implementation uses a single, global <code>std::shared_future</code>:</p>\n<pre><code>#include &lt;future&gt;\n\nstruct bigdata { ... };\n\nstd::shared_future&lt;bigdata *&gt; global_sf;\n\nvoid worker_thread()\n{\n    const bigdata *ptr = global_sf.get();\n    ...  // ptr read-only access\n}\n\nint main()\n{\n    std::promise&lt;bigdata *&gt; pr;\n    global_sf = pr.get_future().share();\n\n    std::thread t1{worker_thread};\n    std::thread t2{worker_thread};\n\n    pr.set_value(new bigdata);\n    ...\n}\n</code></pre>\n<p>And in this (correct) implementation, each <code>worker_thread</code> gets a copy of <code>std::shared_future</code>:</p>\n<pre><code>void worker_thread(std::shared_future&lt;bigdata *&gt; sf)\n{\n    const bigdata *ptr = sf.get();\n    ...\n}\n\nint main()\n{\n    std::promise&lt;bigdata *&gt; pr;\n    auto sf = pr.get_future().share();\n\n    std::thread t1{worker_thread, sf};\n    std::thread t2{worker_thread, sf};\n\n    pr.set_value(new bigdata);\n    ....\n</code></pre>\n<p>I am wondering why the first version is incorrect.  </p>\n<p>If <code>std::shared_future::get()</code> was a non-const member function, it would make sense since accessing a single <code>std::shared_future</code> from multiple threads would then be a data race itself.\nBut since this member function is declared const, and the <code>global_sf</code> object is synchronized with the threads, it is safe to access concurrently from multiple threads.</p>\n<p>My question is, why exactly is this only guaranteed to work correctly if each <code>worker_thread</code> receives a copy of the <code>std::shared_future</code> ?  </p>\n", "Tags": "<c++><multithreading><c++11><future>", "OwnerUserId": "6651824", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41371714_41416686_3": {"section_id": 5817, "quality": 0.875, "length": 14}, "so_41371714_41416686_8": {"section_id": 5834, "quality": 0.8846153846153846, "length": 23}, "so_41371714_41416686_10": {"section_id": 6348, "quality": 1.0, "length": 21}, "so_41371714_41416686_5": {"section_id": 5821, "quality": 0.9, "length": 9}, "so_41371714_41416686_1": {"section_id": 3132, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_41371714_41416686_3": {"section_id": 5588, "quality": 0.875, "length": 14}, "so_41371714_41416686_8": {"section_id": 5605, "quality": 0.5384615384615384, "length": 14}, "so_41371714_41416686_10": {"section_id": 6105, "quality": 1.0, "length": 21}, "so_41371714_41416686_5": {"section_id": 5592, "quality": 0.9, "length": 9}, "so_41371714_41416686_1": {"section_id": 3007, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_41371714_41416686_8": {"section_id": 7296, "quality": 0.8846153846153846, "length": 23}, "so_41371714_41416686_10": {"section_id": 7857, "quality": 1.0, "length": 21}, "so_41371714_41416686_5": {"section_id": 7282, "quality": 0.9, "length": 9}, "so_41371714_41416686_1": {"section_id": 3894, "quality": 0.7692307692307693, "length": 10}, "so_41371714_41416686_3": {"section_id": 7278, "quality": 0.9375, "length": 15}}}});