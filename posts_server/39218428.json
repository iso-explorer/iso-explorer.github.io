post_cb({"39218428": {"CommentCount": "8", "ViewCount": "161", "PostTypeId": "1", "LastEditorUserId": "207421", "CreationDate": "2016-08-30T03:41:53.030", "LastActivityDate": "2016-08-31T12:16:18.890", "Title": "Why we have to use a reference in argument of copy constructor instead of a pointer?", "LastEditDate": "2016-08-30T04:07:36.220", "Id": "39218428", "Score": "5", "Body": "<p>Why we have to use a reference in argument of copy constructor instead of a pointer? This questions was asked in an interview. I replied the following points:<br/></p>\n<ol>\n<li>References can not be NULL.</li>\n<li>If we use pointer, then it would not be a copy constructor.</li>\n<li>The standard specifies so (section 12.8.2).</li>\n</ol>\n<p>But the interviewer was not satisfied. He said it was 'related to inheritance and virtual functions'. I need help or some relevant points with which I can be able to think of an answer in that direction.</p>\n", "Tags": "<c++><inheritance><copy-constructor><virtual-functions>", "OwnerUserId": "1652295", "AnswerCount": "2"}, "39218464": {"ParentId": "39218428", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your interviewer was wrong, and you are correct.</p>\n<p>The most important aspect of your answer is 2. and 3 (which are essentially the same points, but worded differently): <strong>because the standard says so</strong> (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">see 12.8.2</a>):</p>\n<blockquote>\n<p id=\"so_39218428_39218464_0\">A non-template constructor for class <code>X</code> is a copy constructor if its first parameter is of type <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>, and either there are no other parameters or else all other parameters have default arguments (...).</p>\n</blockquote>\n<p>We use references instead of pointers <strong>because the standard says so</strong>. It's not a copy constructor otherwise.</p>\n<p>When it comes to inheritance and virtual functions, references can do everything that a pointer can.</p>\n<p>The only other reason you could've provided, as <a href=\"https://stackoverflow.com/questions/39218428/why-we-have-to-use-a-reference-in-argument-of-copy-constructor-instead-of-a-poin/39218464#comment65775377_39218428\">Gautam Jha points out in the comments</a>, is that a reference allows you to make a copy from temporaries.</p>\n", "OwnerUserId": "4143855", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:51:41.777", "Id": "39218464", "Score": "2", "CreationDate": "2016-08-30T03:47:55.313", "LastActivityDate": "2016-08-31T12:16:18.890"}, "39218600": {"ParentId": "39218428", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You points look sensible, and I cannot figure out what your interviewer wanted to hear from you.</p>\n<p>But, as far as I know, enabling a uniform syntax for copy constructors and assignment operators was a significant reason why Stroustrup introduced references. For example, let's assume we have no references in C++ and we want to do some copy-construction, passing an argument by pointer:</p>\n<pre><code>class MyClass {\n    // Copy ctor and assignment operator are declared\n    // like this in our referenceless \"C with classes\" language:\n    MyClass(const MyClass* const);\n    MyClass* operator=(const MyClass* const);\n};\n\nMyClass a, b, c;\n\n//Let's copy-construct:\nMyClass d = &amp;a; // Dereferencing looks ugly.\n\n//Let's assign:\na = &amp;b; // Dereferencing again.\n\n// Even worse example:\na = b = c = &amp;d; // Only the last variable should be dereferenced.\na = b = &amp;c; // Awfully inhomogeneous code.\n/*\nThe above line is equivalent to a = (b = &amp;c),\nwhere (b = &amp;c) returns a pointer, so we don't need to\ndereference the value passed to assignment operator of a.\n*/\n</code></pre>\n<p>And this is obviously not how built-in types work:</p>\n<pre><code>int a, b, c;\nint d = a;\na = b = c = d;\n</code></pre>\n<p>So references were introduced to resolve these inhomogeneities.</p>\n<p><strong>UPD</strong></p>\n<p>For an authoritative proof of this point, please refer to the \u00a7 3.7 of Stroustrup's The Design and Evolution of C++. Unfortunately, I have no English text of the book, but the first sentence in the chapter is (back-translated into English):</p>\n<blockquote>\n<p id=\"so_39218428_39218600_0\">References were introduced basically for operator overloading support.</p>\n</blockquote>\n<p>And in the next few pages Stroustrup covers the topic in-depth.</p>\n", "OwnerUserId": "1690777", "LastEditorUserId": "1690777", "LastEditDate": "2016-08-30T09:34:07.067", "Id": "39218600", "Score": "2", "CreationDate": "2016-08-30T04:05:46.740", "LastActivityDate": "2016-08-30T09:34:07.067"}, "bq_ids": {"n4140": {"so_39218428_39218464_0": {"section_id": 451, "quality": 1.0, "length": 24}}, "n3337": {"so_39218428_39218464_0": {"section_id": 442, "quality": 1.0, "length": 24}}, "n4659": {"so_39218428_39218464_0": {"section_id": 474, "quality": 1.0, "length": 24}}}});