post_cb({"bq_ids": {"n4140": {"so_17832815_17833338_0": {"length": 28, "quality": 0.9032258064516129, "section_id": 5943}, "so_17832815_17833338_2": {"length": 25, "quality": 1.0, "section_id": 5943}, "so_17832815_17834317_0": {"length": 13, "quality": 1.0, "section_id": 5943}, "so_17832815_17833338_1": {"length": 23, "quality": 1.0, "section_id": 5943}, "so_17832815_17833338_3": {"length": 13, "quality": 1.0, "section_id": 5943}}, "n3337": {"so_17832815_17833338_0": {"length": 28, "quality": 0.9032258064516129, "section_id": 5714}, "so_17832815_17833338_2": {"length": 25, "quality": 1.0, "section_id": 5714}, "so_17832815_17834317_0": {"length": 13, "quality": 1.0, "section_id": 5714}, "so_17832815_17833338_1": {"length": 23, "quality": 1.0, "section_id": 5714}, "so_17832815_17833338_3": {"length": 13, "quality": 1.0, "section_id": 5714}}, "n4659": {"so_17832815_17833338_0": {"length": 28, "quality": 0.9032258064516129, "section_id": 7428}, "so_17832815_17833338_1": {"length": 23, "quality": 1.0, "section_id": 7428}, "so_17832815_17834317_0": {"length": 13, "quality": 1.0, "section_id": 7428}, "so_17832815_17833338_2": {"length": 25, "quality": 1.0, "section_id": 7428}, "so_17832815_17833338_3": {"length": 13, "quality": 1.0, "section_id": 7428}}}, "17832815": {"ViewCount": "10041", "Body": "<p>I understand that, regarding implicit conversions, if we have an unsigned type operand and a signed type operand, and the type of the unsigned operand is the same as (or larger) than the type of the signed operand, the signed operand will be converted to unsigned.</p>\n<p>So:</p>\n<pre><code>unsigned int u = 10;  \nsigned int s = -8;\n\nstd::cout &lt;&lt; s + u &lt;&lt; std::endl;\n\n//prints 2 because it will convert `s` to `unsigned int`, now `s` has the value\n//4294967288, then it will add `u` to it, which is an out-of-range value, so,\n//in my machine, `4294967298 % 4294967296 = 2`\n</code></pre>\n<p>What I don't understand - I read that if the signed operand has a larger type than the unsigned operand:</p>\n<ul>\n<li><p>if all values in the unsigned type fit in the larger type then the unsigned operand is converted to the signed type</p></li>\n<li><p>if the values in the unsigned type don't fit in the larger type, then the signed operand will be converted to the unsigned type</p></li>\n</ul>\n<p>so in the following code:</p>\n<pre><code>signed long long s = -8;\nunsigned int u = 10;\nstd::cout &lt;&lt; s + u &lt;&lt; std::endl;\n</code></pre>\n<p><code>u</code> will be converted to signed long long because int values can fit in signed long long??</p>\n<p>If that's the case, in what scenario the smaller type values won't fit in the larger one?</p>\n", "AcceptedAnswerId": "17833338", "Title": "C++ Implicit Conversion (Signed + Unsigned)", "CreationDate": "2013-07-24T11:33:54.600", "Id": "17832815", "CommentCount": "1", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2013-07-24T13:27:25.853", "LastEditorUserId": "819272", "LastActivityDate": "2013-11-06T20:54:30.353", "Score": "10", "OwnerUserId": "2264920", "Tags": "<c++><type-conversion><unsigned-integer><arithmetic-expressions>", "AnswerCount": "3"}, "17834317": {"Id": "17834317", "PostTypeId": "2", "Body": "<p>Note that the C++11 standard doesn't talk about the larger or smaller types here, it talks about types with lower or higher rank.</p>\n<p>Consider the case of <code>long int</code> and <code>unsigned int</code> where both are 32-bit. The <code>long int</code> has a larger rank than the <code>unsigned int</code>, but since <code>long int</code> and <code>unsigned int</code> are both 32-bit, <code>long int</code> can't represent all the values of <code>unsigned int</code>.  </p>\n<p>Therefore we fall into to the last case (C++11: 5.6p9):</p>\n<blockquote id=\"so_17832815_17834317_0\">\n<ul>\n<li>Otherwise, both operands shall be converted to the unsigned integer type corresponding to the\n  type of the operand with signed integer type.</li>\n</ul>\n</blockquote>\n<p>This means that both the <code>long int</code> and the <code>unsigned int</code> will be converted to <code>unsigned long int</code>.</p>\n", "LastEditorUserId": "951890", "LastActivityDate": "2013-07-24T12:55:47.893", "Score": "0", "CreationDate": "2013-07-24T12:40:09.187", "ParentId": "17832815", "CommentCount": "2", "OwnerUserId": "951890", "LastEditDate": "2013-07-24T12:55:47.893"}, "17833338": {"Id": "17833338", "PostTypeId": "2", "Body": "<p>Relevant quote from the Standard:</p>\n<p><strong>5 Expressions [expr]</strong></p>\n<blockquote>\n<p id=\"so_17832815_17833338_0\">10 Many binary operators that expect operands of arithmetic or\n  enumeration type cause conversions and yield result types in a similar\n  way. The purpose is to yield a common type, which is also the type of\n  the result. This pattern is called the usual arithmetic conversions,\n  which are de\ufb01ned as follows:</p>\n</blockquote>\n<p>[2 clauses about equal types or types of equal sign omitted]</p>\n<blockquote>\n<p id=\"so_17832815_17833338_1\">\u2014 Otherwise, if the operand that has unsigned integer type has rank\n  greater than or equal to the rank of the type of the other operand,\n  the operand with signed integer type shall be converted to the type of\n  the operand with unsigned integer type.</p>\n<p id=\"so_17832815_17833338_2\">\u2014 Otherwise, if the type of\n  the operand with signed integer type can represent all of the values\n  of the type of the operand with unsigned integer type, the operand\n  with unsigned integer type shall be converted to the type of the\n  operand with signed integer type. </p>\n<p id=\"so_17832815_17833338_3\">\u2014 Otherwise, both operands shall be\n  converted to the unsigned integer type corresponding to the type of\n  the operand with signed integer type.</p>\n</blockquote>\n<p>Let's consider the following 3 example cases for each of the 3 above clauses <em>on a system where <code>sizeof(int) &lt; sizeof(long) == sizeof(long long)</code></em> (easily adaptable to other cases)</p>\n<pre><code>#include &lt;iostream&gt;\n\nsigned int s1 = -4;\nunsigned int u1 = 2;\n\nsigned long int s2 = -4;\nunsigned int u2 = 2;\n\nsigned long long int s3 = -4;\nunsigned long int u3 = 2;\n\nint main()\n{\n    std::cout &lt;&lt; (s1 + u1) &lt;&lt; \"\\n\"; // 4294967294\n    std::cout &lt;&lt; (s2 + u2) &lt;&lt; \"\\n\"; // -2 \n    std::cout &lt;&lt; (s3 + u3) &lt;&lt; \"\\n\"; // 18446744073709551614  \n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/view?id=69b9c14fd4cc3b7b66ca660675f3732e-ce6b7b81d29c30e32c78aebe6e642254\" rel=\"noreferrer\">Live example</a></strong> with output.</p>\n<p>First clause: types of equal rank, so the <code>signed int</code> operand is converted to <code>unsigned int</code>. This entails a value-transformation which (using two's complement) gives te printed value. </p>\n<p>Second clause: signed type has higher rank, and (on this platform!) can represent all values of the unsigned type, so unsigned operand is converted to signed type, and you get -2</p>\n<p>Third clause: signed type again has higher rank, but (on this platform!) cannot represent all values of the unsigned type, so both operands are converted to <code>unsigned long long</code>, and after the value-transformation on the signed operand, you get the printed value.</p>\n<p>Note that when the unsigned operand would be large enough (e.g. 6 in these examples), then the end result would give 2 for all 3 examples because of unsigned integer overflow.</p>\n<p>(Added) Note that you get even more unexpected results when you do comparisons on these types. Lets consider the above example 1 with <code>&lt;</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nsigned int s1 = -4;\nunsigned int u1 = 2;\nint main()\n{\n    std::cout &lt;&lt; (s1 &lt; u1 ? \"s1 &lt; u1\" : \"s1 !&lt; u1\") &lt;&lt; \"\\n\";  // \"s1 !&lt; u1\"\n    std::cout &lt;&lt; (-4 &lt; 2u ? \"-4 &lt; 2u\" : \"-4 !&lt; 2u\") &lt;&lt; \"\\n\";  // \"-4 !&lt; 2u\"\n}\n</code></pre>\n<p>Since <code>2u</code> is made <code>unsigned</code> explicitly by the <code>u</code> suffix the same rules apply. And the result is probably not what you expect when comparing <strong>-4 &lt; 2</strong> when writing in C++ <code>-4 &lt; 2u</code>...</p>\n", "LastEditorUserId": "472245", "LastActivityDate": "2013-11-06T20:54:30.353", "Score": "15", "CreationDate": "2013-07-24T11:56:49.697", "ParentId": "17832815", "CommentCount": "6", "OwnerUserId": "819272", "LastEditDate": "2013-11-06T20:54:30.353"}, "17833050": {"Id": "17833050", "PostTypeId": "2", "Body": "<p><code>signed int</code> does not fit into <code>unsigned long long</code>. So you will have this conversion:\n<code>signed int</code> -&gt; <code>unsigned long long</code>.</p>\n", "LastActivityDate": "2013-07-24T11:44:05.383", "CommentCount": "0", "CreationDate": "2013-07-24T11:44:05.383", "ParentId": "17832815", "Score": "2", "OwnerUserId": "2149111"}});