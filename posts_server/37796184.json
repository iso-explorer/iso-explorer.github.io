post_cb({"37796184": {"CommentCount": "1", "AcceptedAnswerId": "37796283", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2016-06-13T17:52:32.987", "LastActivityDate": "2017-01-19T23:52:05.843", "LastEditDate": "2017-01-19T23:52:05.843", "ViewCount": "974", "FavoriteCount": "1", "Title": "Is accessing a static out of scope undefined behavior?", "Id": "37796184", "Score": "21", "Body": "<p>While speaking with a colleague of mine, they said that:  </p>\n<blockquote>\n<pre><code>foo() {\n    int *p;\n    {\n        int x = 5;\n        p = &amp;x;\n    }\n    int y = *p;\n}\n</code></pre>\n<p id=\"so_37796184_37796184_0\">creates undefined behavior because lifetime rules and scope rules do\n  not specify.</p>\n<p id=\"so_37796184_37796184_1\">However:  </p>\n<pre><code>foo() {\n    int *p;\n    {\n        static int x = 5;\n        p = &amp;x;\n    }\n    int y = *p;\n}\n</code></pre>\n<p id=\"so_37796184_37796184_2\">is not undefined! You end up with \"indirect scoping\" issues.</p>\n</blockquote>\n<p>The use of terminology does not sound correct.<br>\nI know that static has nothing to do with scoping.<br>\nIs it true that the second case has defined behavior?  </br></br></p>\n", "Tags": "<c++><scope><static><undefined-behavior><lifetime>", "OwnerUserId": "908939", "AnswerCount": "2"}, "37796362": {"ParentId": "37796184", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>quoting from \n<a href=\"http://www.tutorialspoint.com/cprogramming/c_storage_classes.htm\" rel=\"nofollow\">here</a></p>\n<blockquote>\n<p id=\"so_37796184_37796362_0\">The static storage class instructs the compiler to keep a local variable in existence during the life-time of the program instead of creating and destroying it each time it comes into and goes out of scope. Therefore, making local variables static allows them to maintain their values between function calls.</p>\n</blockquote>\n<p>so yes in the second case <code>x</code> is in existence during the complete life-time of the program. </p>\n<p>hence has defined behavior.</p>\n", "OwnerUserId": "5746194", "LastEditorUserId": "5746194", "LastEditDate": "2016-06-13T18:25:05.050", "Id": "37796362", "Score": "1", "CreationDate": "2016-06-13T18:03:25.820", "LastActivityDate": "2016-06-13T18:25:05.050"}, "bq_ids": {"n4140": {"so_37796184_37796283_0": {"section_id": 7164, "quality": 0.9, "length": 18}}, "n3337": {"so_37796184_37796283_0": {"section_id": 6908, "quality": 0.9, "length": 18}}, "n4659": {"so_37796184_37796283_0": {"section_id": 8672, "quality": 0.9, "length": 18}}}, "37796283": {"ParentId": "37796184", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes the second case has well defined behavior.  A <code>static</code> variable is basically a global variable whose name is scoped to the scope it is declared in.  It is initialized the first time the scope is entered and then it lives on for the life of the program.</p>\n<p>So when we reach</p>\n<pre><code>int y = *p;\n</code></pre>\n<p><code>p</code> points to a variable that you can no longer reach (can't get back to that code) but still has a valid lifetime.  </p>\n<p>To quote the standard [basic.stc.static]</p>\n<blockquote>\n<p id=\"so_37796184_37796283_0\">All variables which do not have dynamic storage duration, do not have thread storage duration, and are not local have static storage duration. <strong>The storage for these entities shall last for the duration of the program</strong></p>\n</blockquote>\n<p><sup>emphasis mine</sup></p>\n<p>The first case is undefined as the lifetime of the local scope <code>x</code> ends at the <code>}</code> and trying to refer to it after its lifetime ends is undefined behavior.</p>\n", "OwnerUserId": "4342498", "LastEditorUserId": "2069064", "LastEditDate": "2016-06-13T18:19:48.313", "Id": "37796283", "Score": "31", "CreationDate": "2016-06-13T17:59:01.460", "LastActivityDate": "2016-06-13T18:19:48.313"}});