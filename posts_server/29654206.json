post_cb({"29654499": {"ParentId": "29654206", "CommentCount": "0", "Body": "<p>Your understanding of capacity isn't quote correct:</p>\n<pre><code>v.resize(n); // from my understanding v now has size n and capacity n\n</code></pre>\n<p><code>v</code> has size <code>n</code>, yes, but all you can say about the capacity is that it is <code>&gt;= n</code>. It could be <code>n</code>, it could be <code>n + 1</code>, it could be <code>3 * n</code>. Similarly:</p>\n<pre><code>v.resize(n + 2); // from my understanding v now has size n + 2 and capacity n + 2 \nv.pop_back();\nv.pop_back(); // v now has size n and most probably still has capacity 2 (unless n is pretty small)\n</code></pre>\n<p>At this point, what we can say with certainty is <code>v.size() == n &amp;&amp; v.capacity() &gt;= n + 2</code>.</p>\n<p>If what you want to do is</p>\n<blockquote>\n<p id=\"so_29654206_29654499_0\">I would love to prealloacte a vector with size n and capacity n + 2</p>\n</blockquote>\n<p>then that's simply:</p>\n<pre><code>v.reserve(n + 2); // capacity &gt;= n+2, size == 0\nv.resize(n);      // capacity &gt;= n+2, size == n\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "29654499", "Score": "1", "CreationDate": "2015-04-15T15:33:45.543", "LastActivityDate": "2015-04-15T15:33:45.543"}, "29654899": {"ParentId": "29654206", "CommentCount": "0", "Body": "<p>You want</p>\n<pre><code>v.reserve(n+2);\nv.resize(n);\n</code></pre>\n<p>This is <em>guaranteed</em> to give you a vector with a size of <code>n</code> and a capacity of at least <code>n+2</code>:</p>\n<blockquote>\n<p id=\"so_29654206_29654899_0\"><strong>23.3.7.3 vector capacity</strong></p>\n<p id=\"so_29654206_29654899_1\">void reserve(size_type n)</p>\n<p id=\"so_29654206_29654899_2\">...No reallocation shall take place during insertions that happen after a call to reserve()\n  until the time when an insertion would make the size of the vector greater than the value of capacity().</p>\n<p id=\"so_29654206_29654899_3\">void resize(size_type n)</p>\n<p id=\"so_29654206_29654899_4\">...If <code>size() &lt; sz</code> appaends <code>sz - size()</code> default-inserted elements to the sequence</p>\n</blockquote>\n<p>So resize to a larger than current size is equivalent to inserting elements, and after a reserve, no insertion operation can reallocate memory until its size would exceed the reserved capacity...</p>\n", "OwnerUserId": "16406", "PostTypeId": "2", "Id": "29654899", "Score": "0", "CreationDate": "2015-04-15T15:48:34.507", "LastActivityDate": "2015-04-15T15:48:34.507"}, "29654245": {"ParentId": "29654206", "CommentCount": "3", "Body": "<p>You can use <code>v.reserve(n + 2)</code> to change the <code>vector</code>'s capacity without altering its size. Take a look at the <a href=\"http://www.cplusplus.com/reference/vector/vector/reserve/\" rel=\"nofollow\">documentation</a> to better understand what is going on. </p>\n", "OwnerUserId": "812912", "PostTypeId": "2", "Id": "29654245", "Score": "3", "CreationDate": "2015-04-15T15:23:15.403", "LastActivityDate": "2015-04-15T15:23:15.403"}, "bq_ids": {"n4140": {"so_29654206_29654899_2": {"section_id": 972, "quality": 1.0, "length": 21}, "so_29654206_29654899_4": {"section_id": 810, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_29654206_29654899_2": {"section_id": 961, "quality": 0.9523809523809523, "length": 20}, "so_29654206_29654899_4": {"section_id": 801, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_29654206_29654899_2": {"section_id": 1034, "quality": 1.0, "length": 21}, "so_29654206_29654899_4": {"section_id": 868, "quality": 0.8333333333333334, "length": 5}}}, "29654206": {"CommentCount": "3", "ViewCount": "275", "PostTypeId": "1", "LastEditorUserId": "762567", "CreationDate": "2015-04-15T15:21:13.580", "LastActivityDate": "2015-04-15T15:48:34.507", "Title": "std::vector preallocation (size n, capacity n + 2)", "AcceptedAnswerId": "29654245", "LastEditDate": "2015-04-15T15:30:34.160", "Id": "29654206", "Score": "1", "Body": "<p>My use-case is the following:\nA vector of size <code>n</code> read from a binary file.</p>\n<p>Among other variants (iostreams, in my case custom code doing decompression), I can do something with semantics like this:</p>\n<pre><code>vector&lt;myElem&gt; v;\nv.resize(n); // from my understanding v now has size n and capacity n\nfread(v.data(), sizeof(myElem), n, myFile);\n</code></pre>\n<p>However, later I will have to (repeatedly) add and remove two elements to such a vector. (While this sounds pretty stupid, it can have positive effects to add sentinel values to lists so that intersections of sorted lists do not have to add comparisons for bound-checking).</p>\n<p>For that, I would love to prealloacte a vector with size <code>n</code> and capacity <code>n + 2</code>.\nI think I could do something like:</p>\n<pre><code>vector&lt;myElem&gt; v;\nv.resize(n + 2); // from my understanding v now has size n + 2 and capacity n + 2 \nv.pop_back();\nv.pop_back(); // v now has size n and most probably still has capacity 2 (unless n is pretty small)\nfread(v.data(), sizeof(myElem), n, myFile);\n</code></pre>\n<p>Obviously, this is neither pretty nor guaranteed to behave as I would liek it to. In practice, I think it really should behave that way for big <code>n</code> and if small <code>n</code> should ever occur, a reallocation doesn't matter.</p>\n<p>Still, it would be great to hear if there are better ways.</p>\n<p>edit:</p>\n<p>I am unsure how I can make use of <code>reserve</code> in my case. If I reserve a capacity of <code>n + 2</code>, the vector still has size <code>0</code>. If I resize to <code>n</code>, i also change the capacity.</p>\n<p>If I resize first and then reserv, I allocate memory two times and copy the whole vector in the process.</p>\n", "Tags": "<c++><vector><std><stdvector><allocation>", "OwnerUserId": "762567", "AnswerCount": "3"}});