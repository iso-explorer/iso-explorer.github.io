post_cb({"18818315": {"CommentCount": "2", "AcceptedAnswerId": "19146868", "PostTypeId": "1", "LastEditorUserId": "141719", "CreationDate": "2013-09-15T22:54:35.577", "LastActivityDate": "2013-10-03T09:19:18.557", "LastEditDate": "2013-09-16T02:59:06.550", "ViewCount": "350", "FavoriteCount": "1", "Title": "Out-of-line definition of base class' nested class", "Id": "18818315", "Score": "2", "Body": "<p>Is the following code valid?</p>\n<pre><code>struct A \n{\n    struct nested;\n};\n\nstruct B : public A {};\n\nstruct B::nested {};\n</code></pre>\n<p>gcc accepts it, but clang rejects it with the following error:</p>\n<pre><code>test.cpp:8:14: error: no struct named 'nested' in 'B'\n    class B::nested {};\n          ~~~^\n</code></pre>\n", "Tags": "<c++><inheritance><gcc><clang><nested-class>", "OwnerUserId": "141719", "AnswerCount": "3"}, "18818344": {"ParentId": "18818315", "CommentCount": "0", "Body": "<p>B has no nested class named <code>nested</code>.  only A has a nested class named <code>nested</code> <code>class A::nested { };</code> should work just fine</p>\n", "OwnerUserId": "2728148", "PostTypeId": "2", "Id": "18818344", "Score": "1", "CreationDate": "2013-09-15T22:59:39.713", "LastActivityDate": "2013-09-15T22:59:39.713"}, "19146868": {"ParentId": "18818315", "CommentCount": "1", "Body": "<p>Yup, it's invalid.  Here's the quote.</p>\n<p>Section 9 paragraph 11, emphasis mine:</p>\n<blockquote>\n<p id=\"so_18818315_19146868_0\">If a <em>class-head-name</em> contains a <em>nested-name-specifier</em>, the <em>class-specifier</em> shall refer to a class that was <strong>previously declared directly in the class or namespace to which the <em>nested-name-specifier</em> refers</strong>, or in an element of the inline namespace set (7.3.1) of that namespace (i.e., not merely inherited or introduced by a <em>using-declaration</em>), and the <em>class-specifier</em> shall appear in a namespace enclosing the previous declaration.  In such cases, the <em>nested-name-specifier</em> of the <em>class-head-name</em> of the definition shall not begin with a <em>decltype-specifier</em>.</p>\n</blockquote>\n<p>In your example, the <em>class-head-name</em> is the tokens <code>B::nested</code>, which comprises the <em>nested-name-specifier</em> <code>B::</code> and the <em>class-name</em> <code>nested</code>.  The <em>class-specifier</em> is the entire <code>struct B::nested {</code> ... <code>}</code>.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "19146868", "Score": "6", "CreationDate": "2013-10-02T21:09:03.820", "LastActivityDate": "2013-10-02T21:09:03.820"}, "bq_ids": {"n4140": {"so_18818315_19146868_0": {"section_id": 5855, "quality": 0.972972972972973, "length": 36}}, "n3337": {"so_18818315_19146868_0": {"section_id": 5625, "quality": 0.972972972972973, "length": 36}}, "n4659": {"so_18818315_19146868_0": {"section_id": 7334, "quality": 0.972972972972973, "length": 36}}}, "19155372": {"ParentId": "18818315", "CommentCount": "0", "Body": "<p>You inherit from <code>A</code> so you don't encapsulated <code>nested</code> struct in <code>B</code>. </p>\n<p>From created struct of type <code>B</code> you can only reach struct named <code>nested</code> as it is part of struct <code>B</code>, however to construct struct named <code>nested</code> is responsible <code>A</code>, because it encapsulated <code>nested</code>.</p>\n<p>All-in-all your code is invalid.</p>\n", "OwnerUserId": "1237747", "PostTypeId": "2", "Id": "19155372", "Score": "0", "CreationDate": "2013-10-03T09:19:18.557", "LastActivityDate": "2013-10-03T09:19:18.557"}});