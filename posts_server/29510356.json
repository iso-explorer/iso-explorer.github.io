post_cb({"29510921": {"ParentId": "29510356", "CommentCount": "1", "CreationDate": "2015-04-08T09:32:16.090", "OwnerUserId": "822669", "PostTypeId": "2", "Id": "29510921", "Score": "1", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/digits10\" rel=\"nofollow\"><code>std::numeric_limits&lt;float&gt;::digits10</code></a> equates to <a href=\"http://en.cppreference.com/w/cpp/types/climits\" rel=\"nofollow\"><code>FLT_DIG</code></a>, which is defined by the C standard :</p>\n<blockquote>\n<p id=\"so_29510356_29510921_0\">number of decimal digits, q, such that any floating-point number with q decimal digits can be rounded into a floating-point number with p radix b digits and back again without change to the q decimal digits,</p>\n<p id=\"so_29510356_29510921_1\">\u23a7 p log10 b if b is a power of 10</p>\n<p id=\"so_29510356_29510921_2\">\u23a8</p>\n<p id=\"so_29510356_29510921_3\">\u23a9 \u23a3( p \u2212 1) log10 b\u23a6 otherwise</p>\n<p id=\"so_29510356_29510921_4\">FLT_DIG     6</p>\n<p id=\"so_29510356_29510921_5\">DBL_DIG     10</p>\n<p id=\"so_29510356_29510921_6\">LDBL_DIG     10</p>\n</blockquote>\n<p>The reason for the value 6 (and not 7), is due to rounding errors - not all floating point values with 7 decimal digits can be losslessly represented by a 32-bit <code>float</code>. Rounding errors are limited to 1 bit though, so the <code>FLT_DIG</code> value was calculated based on 23 bits (instead of the full 24) :</p>\n<pre><code>23 * log10(2) = 6.92\n</code></pre>\n<p>which is rounded down to <code>6</code>.</p>\n", "LastActivityDate": "2015-04-08T09:32:16.090"}, "29510356": {"CommentCount": "3", "ViewCount": "223", "PostTypeId": "1", "LastEditorUserId": "4365117", "CreationDate": "2015-04-08T09:06:31.270", "LastActivityDate": "2015-04-08T09:32:16.090", "Title": "Why do compilers fix the digits of floating point number to 6?", "AcceptedAnswerId": "29510663", "LastEditDate": "2015-04-08T09:16:38.330", "Id": "29510356", "Score": "1", "Body": "<p>According to <strong><em>The C++ Programming Language - 4th</em></strong>, <em>section 6.2.5</em>:  </p>\n<blockquote>\n<p id=\"so_29510356_29510356_0\">There are three floating-points types: <strong><em>float (single-precision)</em></strong>, double (double-precision), and long double (extended-precision)  </p>\n</blockquote>\n<p>Refer to: <a href=\"http://en.wikipedia.org/wiki/Single-precision_floating-point_format\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Single-precision_floating-point_format</a> </p>\n<blockquote>\n<p id=\"so_29510356_29510356_1\">The true significand includes 23 fraction bits to the right of the binary point and an implicit leading bit (to the left of the binary point) with value 1 unless the exponent is stored with all zeros. <strong><em>Thus only 23 fraction bits of the significand appear in the memory format but the total precision is 24 bits (equivalent to log10(224) \u2248 7.225 decimal digits).</em></strong> </p>\n</blockquote>\n<p>\u2192 The maximum digits of floating point number is <code>7</code> digits on <code>binary32 interchange format</code>. <strong><em>(a computer number format that occupies 4 bytes (32 bits) in computer memory)</em></strong> </p>\n<p>When I test on different compilers (like GCC, VC compiler)<br>\n\u2192 It always outputs <code>6</code> as the value.  </br></p>\n<p>Take a look into <code>float.h</code> of each compiler<br>\n\u2192 I found that <code>6</code> is <strong><em>fixed</em></strong>.  </br></p>\n<p><strong>Question:</strong> </p>\n<ul>\n<li>Do you know why there is a different here (between actual value theoretical value - 7 - and actual value - 6)?<br>\nIt sounds like <b><i>\"7\"</i></b> is more reasonable because when I test using below code, the value is still valid, while <b><i>\"8\"</i></b> is invalid</br></li>\n<li>Why <b><i>don't the compilers check</i></b> the interchange format for giving decision about the numbers of digits represented in floating-point (instead of using a fixed value)?\n</li></ul>\n<p><strong><em>Code:</em></strong> </p>\n<pre><code>#include &lt;iostream&gt; \n#include &lt;limits&gt;\n\nusing namespace std;\n\nint main( )\n{\n    cout &lt;&lt; numeric_limits&lt;float&gt; :: digits10 &lt;&lt; endl;\n\n    float f = -9999999;\n\n    cout.precision ( 10 );\n\n    cout &lt;&lt; f &lt;&lt; endl;\n}\n</code></pre>\n", "Tags": "<c++><c++11><iso>", "OwnerUserId": "4365117", "AnswerCount": "2"}, "29510663": {"ParentId": "29510356", "CommentCount": "1", "CreationDate": "2015-04-08T09:19:54.113", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "29510663", "Score": "9", "Body": "<p>You're not <em>reading the documentation</em>.</p>\n<hr>\n<h3><a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/digits10\"><code>std::numeric_limits&lt;float&gt;::digits10</code></a> is 6:</h3>\n<blockquote>\n<p id=\"so_29510356_29510663_0\">The value of <code>std::numeric_limits&lt;T&gt;::digits10</code> is the number of base-<code>10</code> digits that can be represented by the type <code>T</code> without change, that is, any number with this many decimal digits can be converted to a value of type <code>T</code> and back to decimal form, without change due to rounding or overflow. For base-radix types, it is the value of digits (<code>digits-1</code> for floating-point types) multiplied by <em>log</em><sub>10</sub><em>(radix)</em> and rounded down.</p>\n<p id=\"so_29510356_29510663_1\">The standard 32-bit IEEE 754 floating-point type has a 24 bit fractional part (23 bits written, one implied), which may suggest that it can represent 7 digit decimals (<code>24 * std::log10(2)</code> is 7.22), but <strong>relative rounding errors are non-uniform and some floating-point values with 7 decimal digits do not survive conversion to 32-bit float and back</strong>: the smallest positive example is <code>8.589973e9</code>, which becomes <code>8.589974e9</code> after the roundtrip. <strong>These rounding errors cannot exceed one bit in the representation, and digits10 is calculated as <code>(24-1)*std::log10(2)</code>, which is 6.92. Rounding down results in the value 6.</strong></p>\n</blockquote>\n<hr>\n<h3><a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/max_digits10\"><code>std::numeric_limits&lt;float&gt;::max_digits10</code></a> is 9:</h3>\n<blockquote>\n<p id=\"so_29510356_29510663_2\">The value of <code>std::numeric_limits&lt;T&gt;::max_digits10</code> is the number of base-<code>10</code> digits that are necessary to uniquely represent all distinct values of the type <code>T</code>, such as necessary for serialization/deserialization to text. This constant is meaningful for all floating-point types.</p>\n<p id=\"so_29510356_29510663_3\">Unlike most mathematical operations, the conversion of a floating-point value to text and back is exact as long as at least <code>max_digits10</code> were used (<code>9</code> for <code>float</code>, <code>17</code> for <code>double</code>): it is guaranteed to produce the same floating-point value, even though the intermediate text representation is not exact. It may take over a hundred decimal digits to represent the precise value of a float in decimal notation.</p>\n</blockquote>\n</hr></hr>", "LastActivityDate": "2015-04-08T09:19:54.113"}, "bq_ids": {"n4140": {"so_29510356_29510356_0": {"section_id": 7217, "quality": 0.6363636363636364, "length": 7}}, "n3337": {"so_29510356_29510356_0": {"section_id": 6961, "quality": 0.6363636363636364, "length": 7}}, "n4659": {"so_29510356_29510356_0": {"section_id": 8726, "quality": 0.6363636363636364, "length": 7}}}});