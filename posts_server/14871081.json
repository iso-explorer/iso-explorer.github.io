post_cb({"14871162": {"Id": "14871162", "PostTypeId": "2", "Body": "<p>The Standard only defines so-called \"observable behavior\" which is the sequence of I/O library calls and reads and writes of volatile data. No speed requirements are there.</p>\n<p>You can't be sure which is faster in practice. Decent compilers should emit the same code but sometimes there're bugs in compilers and those may affect code emission.</p>\n", "LastActivityDate": "2013-02-14T09:06:22.923", "CommentCount": "0", "CreationDate": "2013-02-14T09:06:22.923", "ParentId": "14871081", "Score": "3", "OwnerUserId": "57428"}, "14871395": {"Id": "14871395", "PostTypeId": "2", "Body": "<p>The C++11 standard doesn't even guarantee that <code>int a[8] = {};</code> is as fast as <code>int aVeryLongName[8] = {};</code>. </p>\n", "LastActivityDate": "2013-02-14T09:19:15.593", "CommentCount": "4", "CreationDate": "2013-02-14T09:19:15.593", "ParentId": "14871081", "Score": "0", "OwnerUserId": "15416"}, "14871081": {"ViewCount": "446", "Body": "<p>In C++11, both of the following statements are legal:</p>\n<p>statement 1. <code>int a[8] = {};</code></p>\n<p>statement 2. <code>int a[8]{};</code></p>\n<p>However, I like statement 1 better than statement 2 because I think statement 1 is more expressive.</p>\n<p>Does the C++11 standard guarantee that both statements are semantically equivalent?</p>\n", "Title": "Does C++11 guarantee that \"int a[8] = {};\" is semantically equivalent to \"int a[8]{};\"?", "CreationDate": "2013-02-14T09:01:02.130", "LastActivityDate": "2013-02-14T22:45:53.820", "CommentCount": "11", "LastEditDate": "2013-02-14T09:22:35.570", "PostTypeId": "1", "LastEditorUserId": "508343", "Id": "14871081", "Score": "14", "OwnerUserId": "508343", "Tags": "<c++><performance><c++11><initialization><standards>", "AnswerCount": "4"}, "14871112": {"Id": "14871112", "PostTypeId": "2", "Body": "<p>Semantically, they are not the same, much like copy/direct initialization:</p>\n<h3>8.5.4 List-initialization [dcl.init.list]</h3>\n<blockquote>\n<p id=\"so_14871081_14871112_0\">1 List-initialization is initialization of an object or reference from a braced-init-list. Such an initializer is\n  called an initializer list, and the comma-separated initializer-clauses of the list are called the elements of the\n  initializer list. An initializer list may be empty. <strong>List-initialization can occur in direct-initialization or copyinitialization\n  contexts; list-initialization in a direct-initialization context is called direct-list-initialization and\n  list-initialization in a copy-initialization context is called copy-list-initialization.</strong> [...] (emphasis mine)</p>\n</blockquote>\n<p>Original answer, dealing with the comparative performance:\nNo, the standard specifies some complexity restraints on algorithms, but not performance on such issues. This is better left to the compiler, but all compilers will likely generate the same code.</p>\n<p>Think about copy-initialization vs direct-initialization. The standard specifies only what they are, it never says one has to be faster then the other or that they must behave the same. It's entirely up to the compiler.</p>\n<p><strong>And that's a good thing, because the compiler know what's best for that platform.</strong> If the standard did impose such restraints, it could say <code>+</code> has to be faster than <code>*</code>, which is pretty intuitive. But think of a platform built for multiplication, where it's actually faster to compute <code>*</code> in machine code. The compiler would have to go out of its way to translate <code>*</code> into a slower instruction, just to conform to the standards.</p>\n", "LastEditorUserId": "673730", "LastActivityDate": "2013-02-14T09:53:22.940", "Score": "19", "CreationDate": "2013-02-14T09:03:10.227", "ParentId": "14871081", "CommentCount": "0", "OwnerUserId": "673730", "LastEditDate": "2013-02-14T09:53:22.940"}, "bq_ids": {"n4140": {"so_14871081_14871112_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 3323}}, "n3337": {"so_14871081_14871112_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 3193}}, "n4659": {"so_14871081_14871112_0": {"length": 34, "quality": 0.8717948717948718, "section_id": 4089}}}, "14879228": {"Id": "14879228", "PostTypeId": "2", "Body": "<p>Yes, they are semantically equivalent.</p>\n<p>List-initialization (8.5.4) on an aggregate (8.5.1, e.g. an array) performs aggregate initialization (8.5.4p3b1).  Aggregate initialization <em>does not care</em> whether the syntactic form is that of direct-initialization or copy-initialization; the rules of aggregate initialization apply identically in either case.  In particular, the members of the aggregate are always <em>copy-initialized</em> from the corresponding clause of the initializer list.</p>\n<p>There is an exception, which almost but not quite applies in your case; where there are insufficient elements to initialize all members of the aggregate, the standard is unclear on how to initialize the remaining members; they are list-initialized from <code>{}</code> (the empty list-initializer) but it is not specified whether they are copy-list-initialized or direct-list-initialized, or whether this depends on the original list-initialization (see comments); in fact, clang and gcc differ on their behaviour in this corner case.  However, this is irrelevant in your case, since the aggregate member type is <code>int</code>, and for nonclass types list-initialization from <code>{}</code> invokes value-initialization i.e. zero-initialization, which is direct regardless of the syntactic form (i.e., <code>int i{};</code> and <code>int i = {};</code> are semantically identical).</p>\n<p>There are a few reasons to prefer the <code>=</code> (copy-initialization) syntax: first, it is the form used by the standard in almost all examples (the exceptions being the last two examples in 8.5.4p3, where one demonstrates an error in narrowing conversion and the other demonstrates initialization from an empty initializer-list).  Also, as you have said, it is more expressive; I also find that when list-initializing an aggregate, the copy-initialization syntax better reflects the fact that the elements of the aggregate are themselves copy-initialized.</p>\n<p>Finally, the syntax without <code>=</code> is necessary in one case: where the object is a <em>non-aggregate</em> class type with an <code>explicit</code> constructor.  As such, the direct-list-initialization syntax should be reserved for that case.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2013-02-14T22:45:53.820", "Score": "3", "CreationDate": "2013-02-14T16:17:42.067", "ParentId": "14871081", "CommentCount": "5", "OwnerUserId": "567292", "LastEditDate": "2013-02-14T22:45:53.820"}});