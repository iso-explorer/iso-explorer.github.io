post_cb({"10828333": {"Id": "10828333", "PostTypeId": "2", "Body": "<p>The linked gcc documentation does not talk of <strong>Partial Initialization</strong> it just talks of <strong>(Complete)Initialization</strong> or <strong>No Initialization</strong>.     </p>\n<blockquote>\n<p id=\"so_10828294_10828333_0\"><strong>What is partial Initialization?</strong> </p>\n</blockquote>\n<p>The standards do not define Partial initialization of objects, either there is Complete initialization or No-initialization. Partial Initialization is a non-standard terminology which commonly refers a situation where you provide some initializers but not all i.e: Fewer initializers than the size of the array or the number of structure elements being initialized. </p>\n<p>Example: </p>\n<pre><code>int array[10] = {1,2};                    //Case 1:Partial Initialization\n</code></pre>\n<blockquote>\n<p id=\"so_10828294_10828333_1\"><strong>What is (Complete)Initialization or No Initialization?</strong> </p>\n</blockquote>\n<p>Initialization means providing some initial value to the variable being created at the same time when it is being created. ie: in the same code statement.</p>\n<p>Example:   </p>\n<pre><code>int array[10] = {0,1,2,3,4,5,6,7,8,9};    //Case 2:Complete Initialization\nint array[10];                            //Case 3:No Initialization\n</code></pre>\n<p>The quoted paragraph describes the behavior for <code>Case 3</code>.</p>\n<p>The rules regarding Partial Initialization(<code>Case 1</code>) are well defined by the standard and these rules do not depend on the storage type of the variable being initialized.<br>\nAFAIK, All mainstream compilers have 100% compliance to these rules.</br></p>\n<hr>\n<blockquote>\n<p id=\"so_10828294_10828333_2\"><strong>Can someone please tell me what the C and C++ standards say regarding partial automatic structure and automatic array initialization?</strong></p>\n</blockquote>\n<p>The C and C++ standards guarantee that even if an integer array is located on automatic storage and if there are fewer initializers in a brace-enclosed list then the uninitialized elements <strong>must</strong> be initialized to <code>0</code>.</p>\n<p><strong>C99 Standard 6.7.8.21</strong> </p>\n<blockquote>\n<p id=\"so_10828294_10828333_3\">If there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array, the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration.</p>\n</blockquote>\n<hr>\n<p>In C++ the rules are stated with a little difference.     </p>\n<p><strong>C++03 Standard 8.5.1 Aggregates</strong><br>\n<strong>Para 7:</strong> </br></p>\n<blockquote>\n<p id=\"so_10828294_10828333_4\">If there are fewer initializers in the list than there are members in the aggregate, then each member not explicitly initialized shall be <strong>value-initialized</strong> (8.5). \n  [Example:</p>\n<pre><code> struct S { int a; char* b; int c; };\n S ss = { 1, \"asdf\" };\n</code></pre>\n<p id=\"so_10828294_10828333_5\">initializes <code>ss.a</code> with <code>1</code>, <code>ss.b</code> with <code>\"asdf\"</code>, and <code>ss.c</code> with the value of an expression of the form <code>int()</code>, that is,<code>0</code>. ]</p>\n</blockquote>\n<p>While Value Initialization is defined in,<br>\n<strong>C++03 8.5 Initializers</strong><br>\n<strong>Para 5:</strong> </br></br></p>\n<blockquote>\n<p id=\"so_10828294_10828333_6\">To <strong>value-initialize</strong> an object of type T means:<br>\n  \u2014 if T is a class type (clause 9) with a user-declared constructor (12.1), then the default constructor for T is called (and the initialization is ill-formed if T has no accessible \n    default constructor);<br>\n  \u2014 if T is a non-union class type without a user-declared constructor, then every non-static \n    data member and base-class component of T is value-initialized;<br>\n  \u2014 if T is an array type, then each element is value-initialized;<br>\n  \u2014 otherwise, the object is zero-initialized  </br></br></br></br></p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "452307", "LastActivityDate": "2013-02-08T09:22:48.977", "Score": "81", "CreationDate": "2012-05-31T06:13:35.253", "ParentId": "10828294", "CommentCount": "5", "OwnerUserId": "452307", "LastEditDate": "2013-02-08T09:22:48.977"}, "47108723": {"Id": "47108723", "PostTypeId": "2", "Body": "<pre><code>// You can use something like this:\ntypedef struct {\n\n    ...;\n\n    ...;\n\n} somestruct;\n\n// Declaration of struct\nsomestruct st;\n\n// Initialising with 0. It does not depend on the size of the\n// structure and the number of elements in it.\n// memset() initialisation doesn't care if struct is static or dynamic.\n// but don't forget to use st instead &amp;st to dynamic.\nmemset(&amp;st, 0, sizeof(somestruct));\n</code></pre>\n", "LastEditorUserId": "7104681", "LastActivityDate": "2017-11-04T08:13:30.727", "Score": "0", "CreationDate": "2017-11-04T08:02:08.117", "ParentId": "10828294", "CommentCount": "0", "OwnerUserId": "7104681", "LastEditDate": "2017-11-04T08:13:30.727"}, "10828294": {"ViewCount": "30596", "Body": "<p>For example, if <code>somestruct</code> has three integer members, I had always thought that it was OK to do this in C (or C++) function:</p>\n<pre><code>somestruct s = {123,};\n</code></pre>\n<p>The first member would be initialized to 123 and the last two would be initialized to 0. I often do the same thing with automatic arrays, writing <code>int arr[100] = {0,};</code> so that all integers in an array are initialized to zero. </p>\n<p><br>\nRecently I read in the <a href=\"http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Initializing-Structure-Members\">GNU C Reference Manual</a> that:</br></p>\n<blockquote>\n<p id=\"so_10828294_10828294_0\">If you do not initialize a structure variable, the effect depends on\n  whether it is has static storage (see Storage Class Specifiers) or\n  not. If it is, members with integral types are initialized with 0 and\n  pointer members are initialized to NULL; otherwise, the value of the\n  structure's members is indeterminate.</p>\n</blockquote>\n<p><br>\nCan someone please tell me what the C and C++ standards say regarding partial automatic structure and automatic array initialization? I do the above code in Visual Studio without a problem but I want to be compatible with gcc/g++, and maybe other compilers as well. Thanks</br></p>\n", "AcceptedAnswerId": "10828333", "Title": "C and C++ : Partial initialization of automatic structure", "CreationDate": "2012-05-31T06:10:44.227", "Id": "10828294", "CommentCount": "1", "FavoriteCount": "40", "PostTypeId": "1", "LastActivityDate": "2017-11-04T08:13:30.727", "Score": "57", "OwnerUserId": "4704515", "Tags": "<c++><c>", "AnswerCount": "5"}, "15097885": {"Id": "15097885", "PostTypeId": "2", "Body": "<p>newest gcc versions also allow to \"partially\" initialize and zeromem at the same time:</p>\n<pre><code>typedef struct{\n  int a,b,c;\n}T;\n\nT s = {0, .b=5};\n</code></pre>\n<p>the struct members now will have these values: <code>a=0, b=5, c=0</code></p>\n<p>i don't have any info on whether other compilers allow this or not :p</p>\n", "LastActivityDate": "2013-02-26T19:44:34.673", "CommentCount": "1", "CreationDate": "2013-02-26T19:44:34.673", "ParentId": "10828294", "Score": "4", "OwnerUserId": "612533"}, "bq_ids": {"n4140": {"so_10828294_10828333_4": {"length": 12, "quality": 0.8, "section_id": 3304}, "so_10828294_10828333_6": {"length": 22, "quality": 0.5365853658536586, "section_id": 3287}, "so_10828294_10828333_5": {"length": 9, "quality": 0.9, "section_id": 3304}}, "n3337": {"so_10828294_10828333_4": {"length": 12, "quality": 0.8, "section_id": 3174}, "so_10828294_10828333_5": {"length": 9, "quality": 0.9, "section_id": 3174}, "so_10828294_10828333_6": {"length": 30, "quality": 0.7317073170731707, "section_id": 3157}}, "n4659": {"so_10828294_10828333_4": {"length": 10, "quality": 0.6666666666666666, "section_id": 4070}, "so_10828294_10828333_5": {"length": 9, "quality": 0.9, "section_id": 4070}, "so_10828294_10828333_6": {"length": 21, "quality": 0.5121951219512195, "section_id": 4049}}}, "10828530": {"Id": "10828530", "PostTypeId": "2", "Body": "<p>In C, objects are <em>never</em> partially initialised - if any part of them is initialised, the entire object (and all sub-objects recursively) are initialised.  If no explicit initialiser is provided then elements are initialised to \"zero of the appropriate type\".</p>\n<p>The quote in your question is referring to when the initialiser for the entire object is completely left out, not when a sub-object lacks an initialiser.  For example, assuming that <code>arr</code> has automatic storage duration, then this:</p>\n<pre><code>int arr[100] = { 123 };\n</code></pre>\n<p>initialises <code>arr[0]</code> to <code>123</code> and every other element of <code>arr</code> to <code>0</code>.  Whereas this:</p>\n<pre><code>int arr[100];\n</code></pre>\n<p>leaves every element of <code>arr</code> uninitialised.  It is this latter case that the quote is in reference to.</p>\n", "LastActivityDate": "2012-05-31T06:31:18.643", "CommentCount": "0", "CreationDate": "2012-05-31T06:31:18.643", "ParentId": "10828294", "Score": "15", "OwnerUserId": "134633"}, "10828382": {"Id": "10828382", "PostTypeId": "2", "Body": "<p>If the variable is global and static, it allocates in global area of binaries which is initialized to zero.\nIf the variable is local, it allocates in stack, the compiler doesn't initialize the memory in stack.(some debug version may initialize, but release version never do it)</p>\n<p>If the variable is allocated in Heap, the compiler doesn't initialize it either.</p>\n", "LastActivityDate": "2012-05-31T06:17:44.663", "CommentCount": "0", "CreationDate": "2012-05-31T06:17:44.663", "ParentId": "10828294", "Score": "0", "OwnerUserId": "818399"}});