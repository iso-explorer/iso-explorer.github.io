post_cb({"bq_ids": {"n4140": {"so_12881210_25321049_0": {"length": 62, "quality": 0.96875, "section_id": 480}}, "n3337": {"so_12881210_25321049_0": {"length": 63, "quality": 0.984375, "section_id": 471}}, "n4659": {"so_12881210_25321049_0": {"length": 62, "quality": 0.96875, "section_id": 502}}}, "25321049": {"Id": "25321049", "PostTypeId": "2", "Body": "<p>This question is about copy elision and return value optimization in C++. </p>\n<p>I suggest you do not spend to much time on it because the assembly code generated depends on the compiler.</p>\n<p>Copy elision is defined in the standard:</p>\n<blockquote>\n<p id=\"so_12881210_25321049_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the copy/move constructor and/or destructor for the object have side effects. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization. This elision of copy/move operations, called <em>copy elision</em>, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<p id=\"so_12881210_25321049_1\">[...]</p>\n<p id=\"so_12881210_25321049_2\">\u00a712.8 [class.copy]</p>\n</blockquote>\n<p>There is already a question you can refer on stackoverflow, <a href=\"https://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization\">see here</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-08-15T04:22:55.747", "Score": "1", "CreationDate": "2014-08-15T03:58:03.767", "ParentId": "12881210", "CommentCount": "0", "OwnerUserId": "3736983", "LastEditDate": "2017-05-23T12:29:48.937"}, "12881210": {"ViewCount": "273", "Body": "<p>test environment: vs 2008, debug mode</p>\n<p>test code is:</p>\n<pre><code>// a demo for return value\n\nclass C\n{\npublic:\n    int value;\n    int value2;\n    int value3;\n\n    //C(int v=0): value(v) {};\n};\n\nC getC(int v)\n{\n    C c1;\n\n    return c1;\n}\n\n\n\nint main()\n{\n    C c1 = getC(10);\n\n    return 0;\n}\n</code></pre>\n<p>and the asm output is:</p>\n<pre><code>; 39   :    C c1 = getC(10);\n\npush    10                  ; 0000000aH\nlea eax, DWORD PTR $T2595[ebp]\npush    eax\ncall    ?getC@@YA?AVC@@H@Z          ; getC\nadd esp, 8\nmov ecx, DWORD PTR [eax]\nmov DWORD PTR $T2594[ebp], ecx\nmov edx, DWORD PTR [eax+4]\nmov DWORD PTR $T2594[ebp+4], edx\nmov eax, DWORD PTR [eax+8]\nmov DWORD PTR $T2594[ebp+8], eax\nmov ecx, DWORD PTR $T2594[ebp]\nmov DWORD PTR _c1$[ebp], ecx\nmov edx, DWORD PTR $T2594[ebp+4]\nmov DWORD PTR _c1$[ebp+4], edx\nmov eax, DWORD PTR $T2594[ebp+8]\nmov DWORD PTR _c1$[ebp+8], eax\n</code></pre>\n<p>From the asm output, we can see the compile create 2 temporary object.</p>\n<p>However, when I define the constructor as follow:</p>\n<pre><code>C(int v=0): value(v) {};\n</code></pre>\n<p>and recompiled the program, the asm output is become:</p>\n<pre><code>; 39   :    C c1 = getC(10);\n\npush    10                  ; 0000000aH\nlea eax, DWORD PTR _c1$[ebp]\npush    eax\ncall    ?getC@@YA?AVC@@H@Z          ; getC\nadd esp, 8\n</code></pre>\n<p>Obviously, the compiler optimize the code, and my question is:</p>\n<p>Why does adding the user-written constructor affect the generated assembly so much?</p>\n", "Title": "Why a user-written constructor affects the generated assembly?", "CreationDate": "2012-10-14T10:07:10.657", "LastActivityDate": "2014-08-24T20:28:05.487", "CommentCount": "4", "LastEditDate": "2014-07-29T08:44:35.377", "PostTypeId": "1", "LastEditorUserId": "1505939", "Id": "12881210", "Score": "7", "OwnerUserId": "1249412", "Tags": "<c++><compiler-construction><compilation>", "AnswerCount": "1"}});