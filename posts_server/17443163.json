post_cb({"bq_ids": {"n4140": {"so_17443163_17443575_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5809}, "so_17443163_17443575_0": {"length": 49, "quality": 1.0, "section_id": 7151}}, "n3337": {"so_17443163_17443575_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5582}, "so_17443163_17443575_0": {"length": 49, "quality": 1.0, "section_id": 6895}}, "n4659": {"so_17443163_17443575_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7270}}}, "17443163": {"ViewCount": "131", "Body": "<p>I want to build a templated class with only static data members and functions, basically a collection of functions with some internal data I want to fill in various parts of the code. I am trying to insert content into the data members prior to arriving in <code>main()</code>. This works fine for non-templated classes, but for templated classes I can't seem to figure out how to make it work.</p>\n<p>Here's the code:</p>\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass Foo{\nprivate:\n    static std::vector&lt;unsigned&gt; content;\npublic:\n    static void insert(unsigned u){ content.push_back(u); }\n    static size_t size(){ return content.size(); }\n};\nstd::vector&lt;unsigned&gt; Foo::content=std::vector&lt;unsigned&gt;();\n\nstruct Bar{ \n    Bar(){ Foo::insert(0);  }\n} bar; \n// this works fine in gcc, but is this consistent or am I lucky?\n// Foo::content will contain 0 prior to entering main\n\ntemplate &lt;typename T&gt;\nclass Quux{\nprivate:\n    static std::vector&lt;T&gt; content;\npublic:\n    static void insert(T t){ content.push_back(t); }\n    static size_t size(){ return content.size(); }\n};\ntemplate &lt;typename T&gt;\nstd::vector&lt;T&gt; Quux&lt;T&gt;::content=std::vector&lt;T&gt;();\n\nstruct Wobble{ \n    Wobble(){ Quux&lt;unsigned&gt;::insert(0);    }\n} wobble;  \n// this does not work\n// Quux&lt;unsigned&gt;::content will be empty prior to entering main\n\nint main(){\n\n    std::cout &lt;&lt; Foo::size() &lt;&lt; std::endl;  \n    // outputs 1, as desired\n\n    std::cout &lt;&lt; Quux&lt;unsigned&gt;::size() &lt;&lt; std::endl;   \n    // outputs 0, makes me sad :(\n\n    Wobble wobble2;\n    std::cout &lt;&lt; Quux&lt;unsigned&gt;::size() &lt;&lt; std::endl;   \n    // outputs 1, as desired\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>1\n0\n1\n</code></pre>\n<p><code>Foo</code> is the non-templated class and I can insert stuff in <code>Foo::content</code> prior to running <code>main()</code> via the struct <code>Bar</code> just fine. I hope this is consistent behaviour instead of me being lucky?</p>\n<p>When I try to do the same thing for a templated class <code>Quux&lt;T&gt;</code>, however, it seems that I have to wait until <code>main()</code> before I can add stuff. Can someone explain why this is necessary and (hopefully) a way around that? I assume it has something to do with the time of template instantiation, but I can't figure out exactly why. I would expect <code>Quux&lt;unsigned&gt;</code> to be fully available after the following:</p>\n<pre class=\"lang-c prettyprint-override\"><code>struct Wobble{ \n    Wobble(){ Quux&lt;unsigned&gt;::insert(0); }\n} wobble;  \n</code></pre>\n<p>What am I missing here? Why can I add content to the non-templated class prior to <code>main</code> via <code>bar</code> but can't I do the same through <code>wobble</code>? Is there any way to get the same behaviour as in <code>Foo</code> and <code>Bar</code> with templated classes?</p>\n", "AcceptedAnswerId": "17443575", "Title": "Insert content in static containers of a templated class prior to main", "CreationDate": "2013-07-03T08:28:16.663", "Id": "17443163", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2013-07-03T09:04:37.527", "Score": "2", "OwnerUserId": "2148672", "Tags": "<c++><templates>", "AnswerCount": "3"}, "17443564": {"Id": "17443564", "PostTypeId": "2", "Body": "<p>You should add explicit instantiation of content vector for unsigned before defining first wobble, i.e.</p>\n<pre><code>template&lt;&gt;\nstd::vector&lt;unsigned&gt; Quux&lt;unsigned&gt;::content=std::vector&lt;unsigned&gt;();\n</code></pre>\n<p>Then it works like intended, outputting 1, 1, 2.</p>\n", "LastActivityDate": "2013-07-03T08:49:38.560", "CommentCount": "1", "CreationDate": "2013-07-03T08:49:38.560", "ParentId": "17443163", "Score": "1", "OwnerUserId": "1616776"}, "17443575": {"Id": "17443575", "PostTypeId": "2", "Body": "<p>[basic.start.init]/2</p>\n<blockquote>\n<p id=\"so_17443163_17443575_0\">Definitions of explicitly specialized class template static data members have ordered initialization. Other class template static data members (i.e., implicitly or explicitly instantiated specializations) have unordered initialization. [...] Variables with ordered initialization defined within a single translation unit shall be initialized in the order\n  of their definitions in the translation unit. [...]  Otherwise, the unordered initialization of a variable is indeterminately sequenced with respect to every other dynamic initialization.</p>\n</blockquote>\n<p>As far as I understand that, you have undefined behaviour, as the initialization of <code>Quux&lt;unsigned&gt;::content</code> is indeterminately sequenced with the initialization of <code>wobble</code>:</p>\n<p>[intro.execution]/13</p>\n<blockquote>\n<p id=\"so_17443163_17443575_1\">Evaluations A and B are indeterminately sequenced when either A\n  is sequenced before B or B is sequenced before A, but it is unspecified which.</p>\n</blockquote>\n<p>That is, it is possible your program accesses a not dynamically initialized <code>Quux&lt;unsigned&gt;::content</code>.</p>\n<p>Explicit specialization solves the problem.</p>\n<hr>\n<p>Note that before any dynamic initialization, zero-initialization occurs. Therefore, it is possible to use pointers and dynamic memory allocation to overcome the problem of initialization order:</p>\n<pre><code>template &lt;typename T&gt;\nclass Quux{\nprivate:\n    static std::vector&lt;T&gt;* content;\n    static void create() { if(!content) content = new std::vector&lt;T&gt;; };\npublic:\n    static void insert(T t){ create(); content-&gt;push_back(t); }\n    static size_t size(){ create(); return content-&gt;size(); }\n};\ntemplate &lt;typename T&gt;\nstd::vector&lt;T&gt;* Quux&lt;T&gt;::content;\n</code></pre>\n<p>This will introduce a \"memory-leak\" at the end of the program; if that's a problem you might add a deleter object, i.e. another static data member that deletes <code>content</code> on its own destruction (half an RAII).</p>\n</hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-07-03T09:04:37.527", "Score": "3", "CreationDate": "2013-07-03T08:50:14.373", "ParentId": "17443163", "CommentCount": "2", "OwnerUserId": "420683", "LastEditDate": "2013-07-03T09:04:37.527"}, "17443548": {"Id": "17443548", "PostTypeId": "2", "Body": "<p>You can add explicit template instantiation prior to usage in Wobble <code>template class Quux&lt;unsigned&gt;;</code><br>\nSomething like this\n<a href=\"http://ideone.com/clone/mkJo0W\" rel=\"nofollow\">http://ideone.com/clone/mkJo0W</a></br></p>\n", "LastActivityDate": "2013-07-03T08:48:18.117", "CommentCount": "1", "CreationDate": "2013-07-03T08:48:18.117", "ParentId": "17443163", "Score": "1", "OwnerUserId": "2254782"}});