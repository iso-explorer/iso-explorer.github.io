post_cb({"30798278": {"CommentCount": "0", "ViewCount": "190", "PostTypeId": "1", "LastEditorUserId": "31615", "CreationDate": "2015-06-12T08:07:21.510", "LastActivityDate": "2015-06-12T08:36:21.227", "Title": "Why doesn't aliasing constructor of std::shared_ptr initialize std::enabled_shared_from_this?", "LastEditDate": "2015-06-12T08:09:28.247", "Id": "30798278", "Score": "4", "Body": "<p>Consider the following code:</p>\n<pre><code>struct Foo : std::enable_shared_from_this&lt;Foo&gt;\n{\n\n};\n\nstruct Bar\n{\n    Foo foo;\n};\n\nint main()\n{\n    std::shared_ptr&lt;Bar&gt; bar_p(new Bar);\n\n    //make shared_ptr to member with aliasing constructor\n    std::shared_ptr&lt;Foo&gt; foo_p(bar_p, &amp;bar_p-&gt;foo);\n    assert(bar_p-&gt;foo.shared_from_this()); //fail! throws bad_weak_ptr\n}\n</code></pre>\n<p>Unfortunately, it doesn't work as expected (at least in GCC 4.8.2). I looked into code and it seems that aliasing constructor simply doesn't call <code>__enable_shared_from_this_helper()</code> which is necessary for proper work of <code>shared_from_this()</code>.</p>\n<p>Does anybody have any idea why it was designed in such a way? Is there something wrong with returning shared_ptr to member from shared_from_this?</p>\n", "Tags": "<c++><c++11><std><shared-ptr>", "OwnerUserId": "200121", "AnswerCount": "1"}, "30798799": {"ParentId": "30798278", "CommentCount": "3", "CreationDate": "2015-06-12T08:36:21.227", "OwnerUserId": "657267", "PostTypeId": "2", "Id": "30798799", "Score": "6", "Body": "<p>[util.smartptr.shared.const]</p>\n<blockquote>\n<p id=\"so_30798278_30798799_0\"><code>template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r, T* p) noexcept;</code></p>\n<p id=\"so_30798278_30798799_1\">Effects: Constructs a <code>shared_ptr</code> instance that <strong>stores</strong> <code>p</code> and <strong>shares ownership</strong> with <code>r</code>.</p>\n</blockquote>\n<p><code>foo_p</code> takes no ownership of <code>bar_p-&gt;foo</code> when you call the aliasing constructor, which in this case is a <em>very</em> good thing because otherwise it would try to <code>delete</code> it on destruction.</p>\n<p>[util.smartptr.enab]</p>\n<blockquote>\n<p id=\"so_30798278_30798799_2\"><code>shared_ptr&lt;T&gt; shared_from_this();</code> </p>\n<p id=\"so_30798278_30798799_3\"><code>shared_ptr&lt;T const&gt; shared_from_this() const;</code> </p>\n<p id=\"so_30798278_30798799_4\">Requires: [...]There shall be at least one <code>shared_ptr</code> instance p that owns <code>&amp;t</code>.</p>\n</blockquote>\n<p>As <code>bar_p-&gt;foo</code> isn't owned by at least one <code>shared_ptr</code> you end up with undefined behavior, gcc throws <code>bad_weak_ptr</code> but it isn't obliged to do anything helpful.</p>\n", "LastActivityDate": "2015-06-12T08:36:21.227"}, "bq_ids": {"n4140": {"so_30798278_30798799_1": {"section_id": 4390, "quality": 0.7142857142857143, "length": 5}, "so_30798278_30798799_0": {"section_id": 4389, "quality": 1.0, "length": 4}, "so_30798278_30798799_3": {"section_id": 4502, "quality": 1.0, "length": 4}, "so_30798278_30798799_4": {"section_id": 4503, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_30798278_30798799_1": {"section_id": 4227, "quality": 0.7142857142857143, "length": 5}, "so_30798278_30798799_0": {"section_id": 4226, "quality": 1.0, "length": 4}, "so_30798278_30798799_3": {"section_id": 4333, "quality": 1.0, "length": 4}, "so_30798278_30798799_4": {"section_id": 4334, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_30798278_30798799_1": {"section_id": 5655, "quality": 0.8571428571428571, "length": 6}, "so_30798278_30798799_0": {"section_id": 5654, "quality": 1.0, "length": 4}, "so_30798278_30798799_3": {"section_id": 5765, "quality": 1.0, "length": 4}}}});