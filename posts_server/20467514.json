post_cb({"20469655": {"CommentCount": "5", "CreationDate": "2013-12-09T11:37:06.987", "LastEditorUserId": "-1", "LastActivityDate": "2013-12-09T16:00:02.823", "ParentId": "20467514", "LastEditDate": "2017-05-23T12:23:40.127", "LastEditorDisplayName": "user1508519", "PostTypeId": "2", "Id": "20469655", "Score": "3", "Body": "<p><a href=\"https://stackoverflow.com/questions/20467514/c-char-to-char-conversion#comment30585757_20467514\">Jefffrey's comment</a> references the standard, here it is:</p>\n<blockquote>\n<p id=\"so_20467514_20469655_0\">4.2 Array-to-pointer conversion [conv.array] </p>\n<p id=\"so_20467514_20469655_1\">An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound of T\u201d can be converted\n  to a prvalue of type \u201cpointer to T\u201d. The result is a pointer to the\n  \ufb01rst element of the array.</p>\n</blockquote>\n<p>And a prvalue is:</p>\n<blockquote>\n<p id=\"so_20467514_20469655_2\">A prvalue (\"pure\" rvalue) is an expression that identifies a temporary\n  object (or a subobject thereof) or is a value not associated with any\n  object.</p>\n</blockquote>\n<p>You cannot bind a non-const reference to a temporary.</p>\n<pre><code>int&amp; i = int(); // error\n\nchar* argv[] = { \"\", \"\", nullptr };\n// the result of the conversion is a prvalue\nchar**&amp; test = argv; // error\n</code></pre>\n<p>Therefore the following code will happily compile:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid f(int&amp; argc, char** const&amp; argv){\n    std::cout &lt;&lt; argv[0] &lt;&lt; std::endl; // a\n}\n\nint main()\n{\n    int argc = 2;\n    char* argv[] = { \"a\", \"b\", nullptr };\n    f(argc, argv); \n    return 0;\n}\n</code></pre>\n<hr/>\n<p>One important thing I glazed over is pointed out in <a href=\"https://stackoverflow.com/questions/20467514/c-char-to-char-conversion/20469655?noredirect=1#comment30596711_20469655\">Kanze's comment</a>.</p>\n<p>In the first example provided in the OP, <code>char* argv[]</code> and <code>char** argv</code> are equivalent. Therefore, there is no conversion.</p>\n<pre><code>std::cout &lt;&lt; std::is_array&lt;decltype(argv)&gt;::value &lt;&lt; std::endl; // false\nstd::cout &lt;&lt; std::is_array&lt;char**&gt;::value &lt;&lt; std::endl; // false\nstd::cout &lt;&lt; std::is_array&lt;char*[]&gt;::value &lt;&lt; std::endl; // true\nstd::cout &lt;&lt; std::is_same&lt;decltype(argv), char**&gt;::value &lt;&lt; std::endl; // true\nstd::cout &lt;&lt; std::is_same&lt;decltype(argv), char*[]&gt;::value &lt;&lt; std::endl; // false\n</code></pre>\n", "OwnerDisplayName": "user1508519"}, "20467514": {"CommentCount": "9", "AcceptedAnswerId": "20469655", "PostTypeId": "1", "LastEditorUserId": "336578", "CreationDate": "2013-12-09T09:42:57.107", "LastActivityDate": "2013-12-09T16:00:02.823", "LastEditDate": "2013-12-09T09:55:27.057", "ViewCount": "2703", "FavoriteCount": "2", "Title": "C++ char*[] to char** conversion", "Id": "20467514", "Score": "14", "Body": "<p>I have this simple code that compiles without errors/warnings:</p>\n<pre><code>void f(int&amp;, char**&amp;){}\n\nint main(int argc, char* argv[])\n{\n    f(argc, argv);\n    return 0;\n}\n</code></pre>\n<p>And next similar code that doesn't compile:</p>\n<pre><code>void f(int&amp;, char**&amp;){}\n\nint main()\n{\n    int argc = 2;\n    char* argv[] = { \"\", \"\", nullptr };\n    f(argc, argv); \n    //@VS2013 error: cannot convert argument 2 from 'char *[3]' to 'char **&amp;'\n    //@GCC error: invalid initialization of non-const reference of type 'char**&amp;' from an rvalue of type 'char**'\n    return 0;\n}\n</code></pre>\n<p>Why <code>char*[]</code> can be converted to <code>char**&amp;</code> in the first sample and can't be converted in the second sample? Does it matter if the size is known at compile time?</p>\n<p>EDIT: I think there are 2 conversions needed in the second case, and only one implicit conversion can be done by compiler. </p>\n<p>This code compiles fine:</p>\n<pre><code>void f(int&amp;, char**&amp;){}\n\nint main()\n{\n    int argc = 2;\n    char* temp[] = { \"\", \"\", nullptr };\n    char** argv = temp;\n    f(argc, argv);\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><type-conversion>", "OwnerUserId": "336578", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_20467514_20469655_2": {"section_id": 7230, "quality": 0.5833333333333334, "length": 7}, "so_20467514_20469655_1": {"section_id": 11, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_20467514_20469655_2": {"section_id": 6974, "quality": 0.6666666666666666, "length": 8}, "so_20467514_20469655_1": {"section_id": 8, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_20467514_20469655_1": {"section_id": 12, "quality": 0.8888888888888888, "length": 16}}}, "20468036": {"ParentId": "20467514", "CommentCount": "1", "Body": "<p>Because despite appearances, the second argument to <code>main</code> has\ntype <code>char**</code>.  When used as the declaration of a function\nargument, a top level array is rewritten to a pointer, so <code>char\n*[]</code> is, in fact, <code>char**</code>.  This only applies to function\nparameters, however.</p>\n<p>A <code>char*[]</code> (as in your second case) can convert to a <code>char**</code>,\nbut the results of the conversion (as with any conversion) is an\nrvalue, and cannot be used to initialize a non-const reference.\nWhy do you want the reference?  If it is to modify the pointer,\nmodifying the <code>char**</code> argument to <code>main</code> is undefined behavior\n(formally, in C, at least\u2014I've not checked if C++ is more\nliberal here).  And of course, there's no way you can possibly\nmodify the constant address of an array.  And if you don't want\nto modify it, why use a reference? </p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "20468036", "Score": "8", "CreationDate": "2013-12-09T10:16:54.010", "LastActivityDate": "2013-12-09T10:16:54.010"}, "20468501": {"ParentId": "20467514", "CommentCount": "0", "Body": "<p>The type of <code>temp</code> in </p>\n<blockquote>\n<p id=\"so_20467514_20468501_0\"><code>char* temp[] = { \"\", \"\", nullptr };</code></p>\n</blockquote>\n<p>is <strong>not</strong> char*[], it's </p>\n<blockquote>\n<p id=\"so_20467514_20468501_1\"><code>char*[3]</code></p>\n</blockquote>\n<p>The latter can't be implicitly converted to `char**'.</p>\n<p>In <code>main</code>, the type of <code>argv</code> is an unbound <code>char*</code> array which is equivalent to <code>char**</code></p>\n<p>I admit, it's confusing :)</p>\n", "OwnerUserId": "3005057", "PostTypeId": "2", "Id": "20468501", "Score": "0", "CreationDate": "2013-12-09T10:40:09.087", "LastActivityDate": "2013-12-09T10:40:09.087"}});