post_cb({"18011621": {"ParentId": "18010848", "CommentCount": "2", "Body": "<p>As you probably know, reallocations invalidate all pointers and iterators to the elements of the <code>vector</code>, according to the standard. If the old memory was kept somehow, the pointers and iterators would continue to be valid, since they would point at the same objects as before. Therefore, the standard implicitly says that memory is immediately released.</p>\n<p>Of course, this does not mean that the runtime is forced to immediately wipe out that memory. In fact, it will most likely remain as it was until your product is deployed at the customer's site. Then it will explode in his face.</p>\n", "OwnerUserId": "25824", "PostTypeId": "2", "Id": "18011621", "Score": "0", "CreationDate": "2013-08-02T07:54:11.500", "LastActivityDate": "2013-08-02T07:54:11.500"}, "18010848": {"CommentCount": "1", "ViewCount": "453", "CreationDate": "2013-08-02T07:11:19.777", "LastActivityDate": "2013-08-02T07:54:11.500", "Title": "STL vector: When vector capacity is increased due to insert, does the old contiguous memory deleted or kept after allocating new contiguous memory?", "AcceptedAnswerId": "18011621", "PostTypeId": "1", "Id": "18010848", "Score": "2", "Body": "<p>Recently got into confusion on whether old memory will be freed or not after STL::vector size is increased.</p>\n<p>When stl::vector capacity is increased due to insert, a new contiguous memory is allocated (=2*current vector capacity) and old contents are copied to new memory. And the old memory is freed.</p>\n<p>Now recently we get into discussion and some believe that old memory is not freed instead it is kept for reference. So over multiple resize's the stl::vector start accumulating memory which is not really needed.</p>\n<p>To my understanding it frees old memory but I don't have any concrete documentation on it. However my understanding may be wrong! I would appreciate if anyone who knows the details,  share the same!</p>\n", "Tags": "<c++><vector>", "OwnerUserId": "492607", "AnswerCount": "3"}, "18011413": {"ParentId": "18010848", "CommentCount": "2", "Body": "<p>from  <a href=\"http://isocpp.org/files/papers/N3690.pdf\" rel=\"nofollow\">N3690</a></p>\n<blockquote>\n<p id=\"so_18010848_18011413_0\">23.3.7.5 vector modifiers [vector.modifiers] </p>\n<p id=\"so_18010848_18011413_1\">iterator insert(const_iterator position, const T&amp; x);</p>\n<p id=\"so_18010848_18011413_2\">iterator insert(const_iterator position, T&amp;&amp; x);</p>\n<p id=\"so_18010848_18011413_3\">iterator insert(const_iterator position, size_type n, const T&amp; x);</p>\n<p id=\"so_18010848_18011413_4\">template  iterator insert(const_iterator\n  position, InputIterator first, InputIterator last);</p>\n<p id=\"so_18010848_18011413_5\">iterator insert(const_iterator position, initializer_list);</p>\n<p id=\"so_18010848_18011413_6\">template  void emplace_back(Args&amp;&amp;... args);</p>\n<p id=\"so_18010848_18011413_7\">template  iterator emplace(const_iterator position,\n  Args&amp;&amp;... args);</p>\n<p id=\"so_18010848_18011413_8\">void push_back(const T&amp; x);</p>\n<p id=\"so_18010848_18011413_9\">void push_back(T&amp;&amp; x);</p>\n<p id=\"so_18010848_18011413_10\">1 Remarks: Causes reallocation if the new size is greater than the old\n  capacity. If no reallocation happens, all the iterators and references\n  before the insertion point remain valid. If an exception is thrown\n  other than by the copy constructor, move constructor, assignment\n  operator, or move assignment operator of T or by any InputIterator\n  operation there are no effects. If an exception is thrown by the move\n  constructor of a non-CopyInsertable T, the effects are unspecified.</p>\n<p id=\"so_18010848_18011413_11\">2 Complexity: The complexity is linear in the number of elements\n  inserted plus the distance to the end of the vector.</p>\n</blockquote>\n", "OwnerUserId": "2368240", "PostTypeId": "2", "Id": "18011413", "Score": "0", "CreationDate": "2013-08-02T07:41:53.570", "LastActivityDate": "2013-08-02T07:41:53.570"}, "bq_ids": {"n4140": {"so_18010848_18011413_11": {"section_id": 987, "quality": 0.8181818181818182, "length": 9}, "so_18010848_18011413_3": {"section_id": 847, "quality": 0.8, "length": 4}, "so_18010848_18011413_7": {"section_id": 855, "quality": 0.8333333333333334, "length": 5}, "so_18010848_18011413_10": {"section_id": 986, "quality": 0.9767441860465116, "length": 42}, "so_18010848_18011413_4": {"section_id": 850, "quality": 0.875, "length": 7}}, "n3337": {"so_18010848_18011413_4": {"section_id": 841, "quality": 0.875, "length": 7}, "so_18010848_18011413_3": {"section_id": 838, "quality": 0.8, "length": 4}, "so_18010848_18011413_7": {"section_id": 846, "quality": 0.8333333333333334, "length": 5}, "so_18010848_18011413_10": {"section_id": 971, "quality": 0.9767441860465116, "length": 42}, "so_18010848_18011413_11": {"section_id": 972, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_18010848_18011413_7": {"section_id": 915, "quality": 0.8333333333333334, "length": 5}, "so_18010848_18011413_3": {"section_id": 823, "quality": 0.8, "length": 4}, "so_18010848_18011413_11": {"section_id": 1050, "quality": 0.8181818181818182, "length": 9}, "so_18010848_18011413_10": {"section_id": 1049, "quality": 0.9767441860465116, "length": 42}, "so_18010848_18011413_4": {"section_id": 910, "quality": 0.875, "length": 7}}}, "18010877": {"ParentId": "18010848", "CommentCount": "3", "Body": "<p>The <code>vector</code> definitely does not keep the memory. The allocator might, or <code>operator new/delete</code> might. Even the OS might keep the memory reserved for your program. </p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "18010877", "Score": "8", "CreationDate": "2013-08-02T07:13:03.057", "LastActivityDate": "2013-08-02T07:13:03.057"}});