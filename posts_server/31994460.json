post_cb({"bq_ids": {"n4140": {"so_31994460_31995269_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 5310}, "so_31994460_31995269_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 5310}}, "n3337": {"so_31994460_31995269_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 5107}, "so_31994460_31995269_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 5107}}, "n4659": {"so_31994460_31995269_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 6734}, "so_31994460_31995269_1": {"length": 30, "quality": 1.0, "section_id": 6734}}}, "31995269": {"Id": "31995269", "PostTypeId": "2", "Body": "<p>Based on the rules described in [re.grammar], we have:</p>\n<blockquote>\n<p id=\"so_31994460_31995269_0\">\u2014 During matching of a regular expression finite state machine against a <strong>sequence of characters</strong>, two\n  characters <code>c</code> and <code>d</code> are compared using the following rules:<br>\n  1. if <code>(flags() &amp; regex_constants::icase)</code> the two characters are equal if <code>traits_inst.translate_nocase(c) == traits_inst.translate_nocase(d)</code>;<br>\n  2. otherwise, if <code>flags() &amp; regex_constants::collate</code> the two characters are equal if <code>traits_inst.translate(c) == traits_inst.translate(d);</code><br>\n  3. otherwise, the two characters are equal if <code>c == d</code>.</br></br></br></p>\n</blockquote>\n<p>This applies to your <code>pattern2</code>, we're matching a sequence of characters and we have <code>flags() &amp; icase</code>, so we do a nocase comparison. Since each character in the sequence matches, it \"works\".</p>\n<p>However, with <code>pattern</code>, we don't have a sequence of characters. So we instead use this rule:</p>\n<blockquote>\n<p id=\"so_31994460_31995269_1\">\u2014 During matching of a regular expression finite state machine against a sequence of characters, <strong>comparison\n  of a collating element range <code>c1-c2</code> against a character <code>c</code></strong> is conducted as follows: if <code>flags() &amp; regex_constants::collate</code> is false then the character <code>c</code> is matched if <code>c1 &lt;= c &amp;&amp; c &lt;= c2</code>, otherwise\n  <code>c</code> is matched in accordance with the following algorithm:</p>\n<pre><code>string_type str1 = string_type(1,\n    flags() &amp; icase ?\n        traits_inst.translate_nocase(c1) : traits_inst.translate(c1);\nstring_type str2 = string_type(1,\n    flags() &amp; icase ?\n        traits_inst.translate_nocase(c2) : traits_inst.translate(c2);\nstring_type str = string_type(1,\n    flags() &amp; icase ?\n        traits_inst.translate_nocase(c) : traits_inst.translate(c);\nreturn traits_inst.transform(str1.begin(), str1.end())\n        &lt;= traits_inst.transform(str.begin(), str.end())\n    &amp;&amp; traits_inst.transform(str.begin(), str.end())\n        &lt;= traits_inst.transform(str2.begin(), str2.end());\n</code></pre>\n</blockquote>\n<p>Since you don't have <code>collate</code> set, the character is matched literally for the range <code>a-z</code>. There is no accounting for <code>icase</code> here, that is why it \"doesn't work.\" If you provide <code>collate</code> however:</p>\n<pre><code>std::regex pattern(\"[a-z]+\", \n                   std::regex_constants::icase | std::regex_constants::collate);\n</code></pre>\n<p>Then we use the algorithm described, which will do a no-case comparison, and the result will be \"works\". Both compilers are correct - though I find the expected behavior confusing in this case. </p>\n", "LastActivityDate": "2015-08-13T17:55:36.763", "CommentCount": "1", "CreationDate": "2015-08-13T17:55:36.763", "ParentId": "31994460", "Score": "2", "OwnerUserId": "2069064"}, "31994890": {"Id": "31994890", "PostTypeId": "2", "Body": "<p>The problem is caused by case sensitiveness: </p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/ac21a962ee9f28fc\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/ac21a962ee9f28fc</a></p>\n<p>The flag <code>std::regex_constants::icase</code> is ignored by <code>std::regex_match</code>.</p>\n<hr>\n<p><strong>Edit:</strong></p>\n<p>Adding the flag <code>std::regex_constants::collate</code> solves the problem:</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/f57a2f2ff840c8be\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/f57a2f2ff840c8be</a></p>\n</hr>", "LastEditorUserId": "717124", "LastActivityDate": "2015-08-13T17:40:47.317", "Score": "0", "CreationDate": "2015-08-13T17:32:48.423", "ParentId": "31994460", "CommentCount": "0", "OwnerUserId": "717124", "LastEditDate": "2015-08-13T17:40:47.317"}, "31994860": {"Id": "31994860", "PostTypeId": "2", "Body": "<pre><code>std::regex pattern(\"[a-z]+\", std::regex_constants::icase);\n</code></pre>\n<p>still restricts pattern matching for lower case letters. I'd suppose <em>character matching</em> as mentioned in the <a href=\"http://en.cppreference.com/w/cpp/regex/syntax_option_type\" rel=\"nofollow\">reference</a> seems not to apply for explicitly specified character sets, which is what I would expect and makes sense to handle these if specified explicitly.</p>\n", "LastActivityDate": "2015-08-13T17:31:31.607", "CommentCount": "0", "CreationDate": "2015-08-13T17:31:31.607", "ParentId": "31994460", "Score": "1", "OwnerUserId": "1413395"}, "31994460": {"ViewCount": "163", "Body": "<p>I am trying regexes in C++, and here is some code</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;regex&gt;\n\n\nint main (int argc, char *argv[]) {\n  std::regex pattern(\"[a-z]+\", std::regex_constants::icase);\n  std::regex pattern2(\"excelsior\", std::regex_constants::icase);\n  std::string text = \"EXCELSIOR\";\n\n  if (std::regex_match(text, pattern)) std::cout &lt;&lt; \"works\" &lt;&lt; std::endl;\n  else std::cout &lt;&lt; \"doesn't work\" &lt;&lt; std::endl;\n\n  if (std::regex_match(text, pattern2)) std::cout &lt;&lt; \"works\" &lt;&lt; std::endl;\n  else std::cout &lt;&lt; \"doesn't work\" &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>Now, from what I understand, both those matches should output <code>works</code>, but the first one outputs <code>doesn't work</code>, while the second one outputs <code>works</code> as expected. Why?</p>\n", "AcceptedAnswerId": "31995269", "Title": "matching text ranges with C++11 regexes", "CreationDate": "2015-08-13T17:07:52.293", "Id": "31994460", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-08-13T17:55:36.763", "Score": "2", "OwnerUserId": "3673043", "Tags": "<c++><regex><c++11>", "AnswerCount": "3"}});