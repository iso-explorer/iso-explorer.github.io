post_cb({"26212451": {"ParentId": "26212338", "LastEditDate": "2014-10-06T09:22:24.140", "CommentCount": "1", "CreationDate": "2014-10-06T08:29:39.943", "OwnerUserId": "440558", "LastEditorUserId": "440558", "PostTypeId": "2", "Id": "26212451", "Score": "3", "Body": "<p>The expression <code>12_x</code> creates a temporary object, creating a reference to a temporary object will obviously not work, what is referenced when the temporary object is destructed (which it will be once the expression it is in is done)?</p>\n<p>However, making a <code>const</code> reference will cause the compiler to prolong the lifetime of the temporary object for as long as the reference variable is in scope.</p>\n<p>The longer expression with the additions also create temporary objects, but since the <code>operator+</code> function is defined to return a reference the result of the whole expression is a reference. Unfortunately, it will be a reference to a temporary object, and using it will lead to <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\"><em>undefined behavior</em></a>, so you're just lucky it works.</p>\n<hr>\n<p>As noted by Potatoswatter a rvalue-reference should work with the temporary object. This is a new kind of reference introduced in C++11 and is denoted by double ampersands, like</p>\n<pre><code>Point&amp;&amp; p = 12_x;\n</code></pre>\n</hr>", "LastActivityDate": "2014-10-06T09:22:24.140"}, "26212924": {"ParentId": "26212338", "LastEditDate": "2014-10-06T11:00:20.747", "CommentCount": "3", "CreationDate": "2014-10-06T09:02:21.463", "OwnerUserId": "442284", "LastEditorUserId": "442284", "PostTypeId": "2", "Id": "26212924", "Score": "4", "Body": "<p>Your operator signature for + is not normal, it should return a new temporary not a reference to LHS. You have actually implemented +=.</p>\n<p>That is why your plus operator will bind to the non-const reference.</p>\n<p>Although you cannot bind a temporary to a non-const reference, you can perform a non-const operation on one. Thus it will compile your + operator when the first term is actually a temporary.</p>\n<p>It's the same construct that lets you do <code>vector&lt;int&gt;().swap( myVec )</code> to clear the memory from <code>myVec</code>, even though <code>swap()</code> is a non-const function.</p>\n<p>It can also be useful for string-building functions when you want to create them in a one-liner and underneath your object uses <code>operator&lt;&lt;</code> on a member <code>ostringstream</code>. That turns out safe because the final call you make in such a case is a <code>str()</code> call which returns a value not a member reference.</p>\n<p>In your case you can also use this construct in your implementation to <code>operator+</code></p>\n<pre><code>class Point\n{\n    public:\n      Point &amp; operator+=( const Point&amp; ); // as you implemented +\n\n      Point operator+( const Point &amp; rhs ) const\n      {\n        return Point( *this ) += rhs;\n      }\n};\n</code></pre>\n", "LastActivityDate": "2014-10-06T11:00:20.747"}, "26212338": {"CommentCount": "6", "ViewCount": "90", "PostTypeId": "1", "LastEditorUserId": "1084199", "CreationDate": "2014-10-06T08:22:27.150", "LastActivityDate": "2014-10-06T11:00:20.747", "Title": "Creating a reference out of multiple temporaries", "AcceptedAnswerId": "26212924", "LastEditDate": "2014-10-06T08:31:44.850", "Id": "26212338", "Score": "1", "Body": "<p>I was trying out user-defined literals (introduced in gcc 4.7.1 I believe) and got stuck on how temporaries work.</p>\n<p>Consider the following code:</p>\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;iostream&gt;\n\nclass Point\n{\npublic:    \n    Point(float x = 0, float y = 0, float z = 0)\n    :_x(x), _y(y), _z(z) \n    {\n        std::cout &lt;&lt; \"Constructor\\n\";    \n    }\n    ~Point()\n    {\n        std::cout &lt;&lt; \"Destructor\\n\";\n    }\n    Point&amp; operator=(Point p)\n    {\n        std::cout &lt;&lt; \"Assignment op\\n\";\n        return *this;\n    }\n\n    Point&amp; operator+(const Point&amp; p)\n    {\n        std::cout &lt;&lt; \"Returning ref: operator+\\n\";\n       _x += p._x; \n       _y += p._y; \n       _z += p._z; \n       return *this;\n    }\n\n    void print() const\n    {\n        std::cout &lt;&lt; \"(\" &lt;&lt; _x &lt;&lt; \", \" &lt;&lt; _y &lt;&lt; \", \" &lt;&lt; _z &lt;&lt;\")\\n\";\n    }\n\nprotected:\n    float _x, _y, _z;\n};\n\nPoint operator \"\" _x(const char* l)\n{\n    float x = atof(l);\n    std::cout&lt;&lt;\"literal _x\\n\";\n    Point p(x);\n    return p;\n}\n\nPoint operator \"\" _y(const char* l)\n{\n    float y = atof(l);\n    std::cout&lt;&lt;\"literal _y\\n\";\n    Point p(0, y);\n    return p;\n}\n\nPoint operator \"\" _z(const char* l)\n{\n    float z = atof(l);\n    std::cout&lt;&lt;\"literal _z\\n\";\n    Point p(0, 0, z);\n    return p;\n}\n\nint main(int argc, char **argv)\n{\n    Point&amp; p = 12_x + 2_x + 3_y + 4_z;\n    p.print();\n}\n</code></pre>\n<p>Upon executing I get the following output:</p>\n<pre class=\"lang-none prettyprint-override\"><code>literal _z\nConstructor\nliteral _y\nConstructor\nliteral _x\nConstructor\nliteral _x\nConstructor\nReturning ref: operator+\nReturning ref: operator+\nReturning ref: operator+\nDestructor\nDestructor\nDestructor\nDestructor\n(14, 3, 4)\n</code></pre>\n<p>When I change the line to <code>Point&amp; p = 12_x;</code> an error is emitted saying that you cannot initialize reference from an rvalue. </p>\n<p>When I change it to <code>const Point&amp; p = 12_x;</code> I get:</p>\n<pre class=\"lang-none prettyprint-override\"><code>literal _x\nConstructor\n(12, 0, 0)\nDestructor\n</code></pre>\n<p>I would expect either of these cases instead of the very first one, so my question is: what exactly happens in the first case?</p>\n<p>P.S. I'm using MinGW with gcc 4.8.1. Compilation string: <code>g++ --std=c++11 -Wall main.cpp -o out.exe</code></p>\n", "Tags": "<c++><gcc><c++11><mingw>", "OwnerUserId": "1084199", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_26212338_26212515_0": {"section_id": 381, "quality": 0.7222222222222222, "length": 13}, "so_26212338_26212515_1": {"section_id": 382, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_26212338_26212515_0": {"section_id": 372, "quality": 0.7222222222222222, "length": 13}, "so_26212338_26212515_1": {"section_id": 373, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_26212338_26212515_0": {"section_id": 396, "quality": 0.6666666666666666, "length": 12}, "so_26212338_26212515_1": {"section_id": 399, "quality": 0.8888888888888888, "length": 8}}}, "26212515": {"ParentId": "26212338", "LastEditDate": "2014-10-06T08:57:55.123", "CommentCount": "0", "CreationDate": "2014-10-06T08:34:26.467", "OwnerUserId": "3959454", "LastEditorUserId": "3959454", "PostTypeId": "2", "Id": "26212515", "Score": "3", "Body": "<p>In this line:</p>\n<pre><code>Point&amp; p = 12_x + 2_x + 3_y + 4_yz;\n</code></pre>\n<p>You get a reference to temporary object which is destroyed immediately after the execution of that line, resulting in undefined behavior. You can actually see that in your log: four constructors are called, then four destructors - so all created objects are destroyed <em>before you call <code>print()</code></em>.</p>\n<p>When you write:</p>\n<pre><code>const Point&amp; p = 12_x;\n</code></pre>\n<p>it results in prolonged lifetime of a temporary returned by <code>12_x</code>, according to <code>12.2/5 ([class.temporary])</code>, so the destructor is called only when that reference goes out of scope, that is, this time after you call <code>print()</code>.</p>\n<p>PS: Excerpt from <code>12.2/4</code> and <code>12.2/5</code>:</p>\n<blockquote>\n<p id=\"so_26212338_26212515_0\">There are two contexts in which temporaries are destroyed at a different point than the end of the full-expression. (...) The second context is when a reference is bound to a temporary. (...)  [ Example:</p>\n</blockquote>\n<pre><code>struct S {\n    S();\n    S(int);\n    friend S operator+(const S&amp;, const S&amp;);\n    ~S();\n};\nS obj1;\nconst S&amp; cr = S(16)+S(23);\nS obj2;\n</code></pre>\n<blockquote>\n<p id=\"so_26212338_26212515_1\">(...) The temporary <code>T3</code> bound to the reference <code>cr</code> is destroyed at the end of <code>cr</code>\u2019s lifetime, that is, at the end of the program. (...)</p>\n</blockquote>\n<p>BTW the example here also provides a right way to implement <code>operator+</code> (except that you may not even need it to be <code>friend</code>). What you wrote in your code should be <code>operator+=</code>.</p>\n", "LastActivityDate": "2014-10-06T08:57:55.123"}});