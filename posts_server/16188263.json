post_cb({"16188846": {"ParentId": "16188263", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_16188263_16188846_0\">is still overflow of these types an undefined behavior?</p>\n</blockquote>\n<p><strong>Yes.</strong> Per Paragraph 5/4 of the C++11 Standard (regarding any expression in general):</p>\n<blockquote>\n<p id=\"so_16188263_16188846_1\">If during the evaluation of an expression, the result is not mathematically defined or not in the range of\n  representable values for its type, <strong>the behavior is undefined</strong>. [...]</p>\n</blockquote>\n<p>The fact that a two's complement representation is used for those signed types does not mean that arithmetic modulo 2^n is used when evaluating expressions of those types.</p>\n<p>Concerning <em>unsigned</em> arithmetic, on the other hand, the Standard explicitly specifies that (Paragraph 3.9.1/4):</p>\n<blockquote>\n<p id=\"so_16188263_16188846_2\">Unsigned integers, declared <code>unsigned</code>, <strong>shall obey the laws of arithmetic modulo 2^n</strong> where n is the number\n  of bits in the value representation of that particular size of integer</p>\n</blockquote>\n<p>This means that the result of an unsigned arithmetic operation is always \"<em>mathematically defined</em>\", and the result is always within the representable range; therefore, 5/4 does not apply. Footnote 46 explains this:</p>\n<blockquote>\n<p id=\"so_16188263_16188846_3\">46) This implies that <strong>unsigned</strong> arithmetic does not overflow because a result that cannot be represented by the resulting\n  unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the\n  resulting unsigned integer type.</p>\n</blockquote>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-04-24T10:03:13.483", "Id": "16188846", "Score": "51", "CreationDate": "2013-04-24T09:51:44.553", "LastActivityDate": "2013-04-24T10:03:13.483"}, "16188263": {"CommentCount": "4", "AcceptedAnswerId": "16188846", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-04-24T09:24:05.397", "LastActivityDate": "2013-09-25T11:50:20.387", "LastEditDate": "2017-05-23T10:29:59.470", "ViewCount": "13837", "FavoriteCount": "13", "Title": "Is signed integer overflow still undefined behavior in C++?", "Id": "16188263", "Score": "48", "Body": "<p>As we know, <a href=\"https://stackoverflow.com/questions/4240748/allowing-signed-integer-overflows-in-c-c\">signed integer overflow is undefined behavior</a>. But there is something interesting in C++11 <code>cstdint</code> documentation:</p>\n<blockquote>\n<p id=\"so_16188263_16188263_0\">signed integer type with width of exactly 8, 16, 32 and 64 bits respectively with no padding bits and <strong>using 2's complement for negative values</strong> (provided only if the implementation directly supports the type)</p>\n</blockquote>\n<p><sub><a href=\"http://en.cppreference.com/w/cpp/types/integer\" rel=\"noreferrer\">See link</a></sub></p>\n<p>And here is my question: since the standard says explicitly that for <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code> and <code>int64_t</code> negative numbers are 2's complement, is still overflow of these types an undefined behavior?</p>\n<p><strong>Edit</strong> I checked C++11 and C11 Standards and here is what I found:</p>\n<p>C++11, \u00a718.4.1:</p>\n<blockquote>\n<p id=\"so_16188263_16188263_1\">The header defines all functions, types, and macros the same as 7.20 in the C standard.</p>\n</blockquote>\n<p>C11, \u00a77.20.1.1:</p>\n<blockquote>\n<p id=\"so_16188263_16188263_2\">The typedef name <code>intN_t</code> designates a signed integer type with width N, no padding bits, and a two\u2019s complement representation. Thus, <code>int8_t</code> denotes such a signed integer type with a width of exactly 8 bits.</p>\n</blockquote>\n", "Tags": "<c++><c++11><undefined-behavior><integer-overflow>", "OwnerUserId": "224059", "AnswerCount": "3"}, "16188924": {"ParentId": "16188263", "CommentCount": "9", "Body": "<p>Just because a type is defined to use 2s complement representation, it doesn't follow that arithmetic overflow in that type becomes defined.</p>\n<p>The undefined behaviour of signed arithmetic overflow is used to enable optimisations; for example, the compiler can assume that if <code>a &gt; b</code> then <code>a + 1 &gt; b</code> also; this doesn't hold in unsigned arithmetic where the second check would need to be carried out because of the possibility that <code>a + 1</code> might wrap around to <code>0</code>.  Also, some platforms can generate a trap signal on arithmetic overflow (see e.g. <a href=\"http://www.gnu.org/software/libc/manual/html_node/Program-Error-Signals.html\" rel=\"noreferrer\">http://www.gnu.org/software/libc/manual/html_node/Program-Error-Signals.html</a>); the standard continues to allow this to occur.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "16188924", "Score": "18", "CreationDate": "2013-04-24T09:54:59.703", "LastActivityDate": "2013-04-24T09:54:59.703"}, "bq_ids": {"n4140": {"so_16188263_16188263_1": {"section_id": 3396, "quality": 0.7777777777777778, "length": 7}, "so_16188263_16188602_2": {"section_id": 5768, "quality": 0.9272727272727272, "length": 51}, "so_16188263_16188602_1": {"section_id": 5768, "quality": 0.8, "length": 4}, "so_16188263_16188846_1": {"section_id": 5937, "quality": 1.0, "length": 13}, "so_16188263_16188846_2": {"section_id": 7213, "quality": 0.875, "length": 14}, "so_16188263_16188846_3": {"section_id": 7213, "quality": 0.9642857142857143, "length": 27}}, "n3337": {"so_16188263_16188263_1": {"section_id": 3265, "quality": 0.7777777777777778, "length": 7}, "so_16188263_16188602_2": {"section_id": 5541, "quality": 0.9272727272727272, "length": 51}, "so_16188263_16188602_1": {"section_id": 5541, "quality": 0.8, "length": 4}, "so_16188263_16188846_1": {"section_id": 5709, "quality": 1.0, "length": 13}, "so_16188263_16188846_2": {"section_id": 6957, "quality": 1.0, "length": 16}, "so_16188263_16188846_3": {"section_id": 6957, "quality": 0.9642857142857143, "length": 27}}, "n4659": {"so_16188263_16188263_1": {"section_id": 8287, "quality": 0.6666666666666666, "length": 6}, "so_16188263_16188602_2": {"section_id": 7225, "quality": 0.9272727272727272, "length": 51}, "so_16188263_16188602_1": {"section_id": 7225, "quality": 0.8, "length": 4}, "so_16188263_16188846_1": {"section_id": 7421, "quality": 1.0, "length": 13}, "so_16188263_16188846_2": {"section_id": 8722, "quality": 0.875, "length": 14}, "so_16188263_16188846_3": {"section_id": 8722, "quality": 0.9642857142857143, "length": 27}}}, "16188602": {"ParentId": "16188263", "CommentCount": "0", "Body": "<p>I would bet so.</p>\n<p>From the standard documentation (pg.4 and 5):</p>\n<blockquote>\n<p id=\"so_16188263_16188602_0\"><strong>1.3.24 undefined behavior</strong></p>\n<p id=\"so_16188263_16188602_1\">behavior for which this International Standard imposes no requirements</p>\n<p id=\"so_16188263_16188602_2\">[ Note: Undefined behavior may be expected when this International\n  Standard omits any explicit definition of behavior or when a program\n  uses an erroneous construct or erroneous data. Permissible undefined\n  behavior ranges from ignoring the situation completely with\n  unpredictable results, to behaving during translation or program\n  execution in a documented manner characteristic of the environment\n  (with or without the issuance of a diagnostic message), to terminating\n  a translation or execution (with the issuance of a diagnostic\n  message). Many erroneous program constructs do not engender undefined\n  behavior; they are required to be diagnosed.-- end note]</p>\n</blockquote>\n", "OwnerUserId": "625111", "PostTypeId": "2", "Id": "16188602", "Score": "1", "CreationDate": "2013-04-24T09:39:57.130", "LastActivityDate": "2013-04-24T09:39:57.130"}});