post_cb({"17872273": {"ParentId": "17872224", "CommentCount": "1", "Body": "<p>With <a href=\"http://coliru.stacked-crooked.com/view?id=8e543e6138ccc0ed7710d3f4b7937763-f674c1a6d04c632b71a62362c0ccfc51\" rel=\"nofollow\">your code compiled in GCC 4.8.1</a>, and with the <code>-Wall</code> flag, compilation gives out the following warning:</p>\n<blockquote>\n<p id=\"so_17872224_17872273_0\">main.cpp: In member function \u2018std::function\n  sample::get_simple(int)\u2019:</p>\n<p id=\"so_17872224_17872273_1\">main.cpp:10:19: <strong>warning</strong>: explicit by-copy capture of \u2018this\u2019 redundant\n  with by-copy capture default <strong>[enabled by default]</strong></p>\n<pre><code>     return [=,this]() {\n               ^\n</code></pre>\n</blockquote>\n<p>I think this is made by GCC to be compatible with pre-C++11 standard lambdas.</p>\n", "OwnerUserId": "1619294", "PostTypeId": "2", "Id": "17872273", "Score": "3", "CreationDate": "2013-07-26T03:12:25.483", "LastActivityDate": "2013-07-26T03:12:25.483"}, "17872224": {"CommentCount": "2", "AcceptedAnswerId": "17872567", "CreationDate": "2013-07-26T03:06:48.317", "LastActivityDate": "2013-07-26T03:46:08.640", "PostTypeId": "1", "ViewCount": "322", "FavoriteCount": "0", "Title": "Why is a lambda with = and this disallowed (yet GCC accepts)", "Id": "17872224", "Score": "2", "Body": "<p>I created a simple lambda as below and it works as expected (GCC 4.6.4 and 4.7.2 -- <a href=\"http://ideone.com/E7L9Br\" rel=\"nofollow\">demo</a>). But then I checked the standard and 5.1.2-8 explicitly forbids using an <code>=</code> and <code>this</code> in the lambda captures.</p>\n<blockquote>\n<p id=\"so_17872224_17872224_0\">... If a <em>lambda-capture</em> includes a <em>capture-default</em> that is =, the <em>lambda-capture</em> shall not contain <strong>this</strong> and each identifier it contains shall be preceded by &amp;. ...</p>\n</blockquote>\n<p>Am I reading something wrong and this is actually allowed (though the example definitely shows this as forbidden)? If no, then I'm having trouble understanding why it isn't allowed. And also, does that mean GCC is wrong to allow it?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nusing namespace std;\n\nstruct sample {\n    int a;\n\n    std::function&lt;int()&gt; get_simple(int o) {\n        return [=,this]() {\n            return a + o;\n        };\n    }\n};\n\nint main() {\n    sample s;\n    auto f = s.get_simple(5);\n    s.a = 10;\n    cout &lt;&lt; f() &lt;&lt; endl; //prints 15 as expected\n}\n</code></pre>\n", "Tags": "<c++><gcc><c++11>", "OwnerUserId": "229686", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17872224_17872224_0": {"section_id": 5967, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_17872224_17872224_0": {"section_id": 5736, "quality": 1.0, "length": 9}}, "n4659": {"so_17872224_17872224_0": {"section_id": 7465, "quality": 0.5555555555555556, "length": 5}}}, "17872567": {"ParentId": "17872224", "CommentCount": "1", "Body": "<p>You don't need to capture the \"this\" field if you are already specifying a default capture mode as you are in this case by setting [=].  See below where I am explicitly passing the \"this\" and the o by value.  Therefore, the warning is telling you that you are redundantly passing the \"this\" in this case because you automatically get a \"this\" when specifying either = or &amp; as a default capture mode.  Therefore only specify \"this\" when you are not specifying a default capture mode.  See below.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nusing namespace std;\n\nstruct sample {\n  int a;\n\n  std::function&lt;int()&gt; get_simple(int o)\n  {\n   return [o,this]{ return a + o; };\n  }\n};\n\nint main() {\n  sample s;\n  auto f = s.get_simple(5);\n  s.a = 10;\n  cout &lt;&lt; f() &lt;&lt; endl; //prints 15 as expected\n}\n</code></pre>\n", "OwnerUserId": "708803", "PostTypeId": "2", "Id": "17872567", "Score": "4", "CreationDate": "2013-07-26T03:46:08.640", "LastActivityDate": "2013-07-26T03:46:08.640"}});