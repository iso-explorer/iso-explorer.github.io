post_cb({"34468284": {"ParentId": "34468090", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-12-26T03:38:40.907", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:04:02.513", "Id": "34468284", "OwnerUserId": "464581", "Body": "<p>In practice: you can simply assign the signed value to the <code>uint8_t</code>,</p>\n<pre><code>u = i;\n</code></pre>\n<p>or you can initialize it with the signed value,</p>\n<pre><code>uint8_t u = i;\n</code></pre>\n<p>This assumes a <em>two's complement</em> signed integer representation, which is universally used today. With that representation the bits are preserved exactly. The \u201cin practice\u201d qualification refers to that assumption.</p>\n<hr>\n<p>E.g., on a modern machine, the 8-bit signed representation of e.g. \u221242, is bitpattern number \u221242 + 256, which is (bitpattern number) 214. Converting that to unsigned is guaranteed by the standard to yield the same value modulo 256. And so it's the same bitpattern, namely bitpattern 214.</p>\n<hr>\n<p>Going from signed to unsigned is well defined by the standard, although the preservation of the bit pattern <sup>(1)</sup>generally is just an in-practice effect (all modern computers are designed that way). However, going in the opposite direction you encounter compiler-specific effects if the unsigned value cannot be represented. More care is needed for this conversion, because it's a matter of compiler discretion and not a practical guarantee at the hardware level.</p>\n<hr>\n<p><sup>\n(1) As M.M. explains in <a href=\"https://stackoverflow.com/a/34468484/464581\">his answer</a> the particular signed type in your example, <code>int8_t</code>, is one that since C11 has been guaranteed two's complement in C. I do not see that language in the final draft of the C99 standard, so presumably it was not there in C99, and thus not in either C++11 or C++14, which are based on C99, but is probably there in C++17, which I believe is based on C11.\n</sup></p>\n</hr></hr></hr>", "LastActivityDate": "2015-12-26T13:04:57.907"}, "34468668": {"ParentId": "34468090", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-12-26T05:10:24.787", "Score": "0", "LastEditorUserId": "3452530", "LastEditDate": "2015-12-26T05:51:55.970", "Id": "34468668", "OwnerUserId": "3452530", "Body": "<p>Try with explicit type conversion. The (unsafe) type conversion using static_cast is necessary to get to the \"raw bytes\" of a variable.\nTo convert the value of an to a given type, you write the following:</p>\n<pre><code>static_cast&lt;type_to_convert_to&gt;(expression)\n</code></pre>\n<p>With static_cast cast is checked statically in compile time.</p>\n<pre><code>#include &lt;iostream&gt;\n\n\nint main() {\n\n    int8_t i {11};\n    uint8_t i2 = static_cast&lt;uint8_t&gt;(i);\n    std::cout &lt;&lt; \"i occupies \" &lt;&lt;  sizeof(i) &lt;&lt; \" bytes.\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"i2 occupies \" &lt;&lt; sizeof(i2) &lt;&lt; \" bytes.\" &lt;&lt; std::endl;\n\n\n}\n</code></pre>\n", "LastActivityDate": "2015-12-26T05:51:55.970"}, "34468090": {"CommentCount": "2", "ViewCount": "94", "CreationDate": "2015-12-26T02:49:28.297", "LastActivityDate": "2015-12-26T13:04:57.907", "Title": "How to turn a signed integer value to unsigned, according to its bits?", "AcceptedAnswerId": "34468284", "PostTypeId": "1", "Id": "34468090", "Score": "1", "Body": "<p>I want to turn a signed value into an unsigned one (for example, <code>int8_t</code> to <code>uint8_t</code>), but also it must keep its bits.</p>\n<p>How can I do it?</p>\n", "Tags": "<c++><integer><int><uint8t>", "OwnerUserId": "4996964", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_34468090_34468484_0": {"section_id": 6797, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_34468090_34468484_0": {"section_id": 6552, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_34468090_34468484_0": {"section_id": 8287, "quality": 0.6666666666666666, "length": 6}}}, "34468484": {"ParentId": "34468090", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-12-26T04:22:17.940", "Score": "0", "LastEditorUserId": "1505939", "LastEditDate": "2015-12-26T04:43:23.483", "Id": "34468484", "OwnerUserId": "1505939", "Body": "<p>With the <code>intN_t</code> types you can simply write:</p>\n<pre><code>int8_t i = something;\nuint8_t u = i;\n</code></pre>\n<p>because those types are required to use 2's complement representation, where this conversion is defined to preserve the bits.</p>\n<p>Reference: C++14 [cstdint.syn]/2:</p>\n<blockquote>\n<p id=\"so_34468090_34468484_0\">The header defines all functions, types, and macros the same as 7.18 in the C standard</p>\n</blockquote>\n<p>And C11 7.20.1.1/1 (C99 7.18.1.1):</p>\n<blockquote>\n<p id=\"so_34468090_34468484_1\">The typedef name <code>intN_t</code> designates a signed integer type with width <code>N</code>, no padding bits, and a two\u2019s complement representation.</p>\n</blockquote>\n<hr>\n<p>To preserve the representation for other integer types, use:</p>\n<pre><code>int i = something;\nunsigned int i = *(unsigned int *)&amp;i;\n</code></pre>\n<p>You can do this with any pair of corresponding signed and unsigned types. It is safe except for the possibility of generating a trap representation.</p>\n</hr>", "LastActivityDate": "2015-12-26T04:43:23.483"}});