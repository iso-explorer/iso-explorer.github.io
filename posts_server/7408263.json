post_cb({"bq_ids": {"n4140": {"so_7408263_7409500_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 4634}, "so_7408263_7409500_4": {"length": 11, "quality": 1.0, "section_id": 4560}, "so_7408263_7409500_3": {"length": 15, "quality": 1.0, "section_id": 4560}}, "n3337": {"so_7408263_7409500_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 4445}, "so_7408263_7409500_4": {"length": 11, "quality": 1.0, "section_id": 4390}, "so_7408263_7409500_3": {"length": 15, "quality": 1.0, "section_id": 4390}}, "n4659": {"so_7408263_7409500_4": {"length": 7, "quality": 0.6363636363636364, "section_id": 5932}, "so_7408263_7409500_3": {"length": 9, "quality": 0.6, "section_id": 7709}}}, "7409196": {"Id": "7409196", "PostTypeId": "2", "Body": "<p>The function will expect <code>-&gt;*</code> to be overloaded to use a pointer-to-member. I believe that <code>shared_ptr</code> does not provide this functionality. The TR1 specification might have mandated a specialization but the C++11 might not. In Visual Studio then the C++11 <code>shared_ptr</code> is defined to be their TR1 versions, which would explain the difference.</p>\n", "LastActivityDate": "2011-09-13T22:13:22.727", "CommentCount": "2", "CreationDate": "2011-09-13T22:13:22.727", "ParentId": "7408263", "Score": "0", "OwnerUserId": "298661"}, "7408263": {"ViewCount": "866", "Body": "<pre><code>#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Foo\n{\npublic:\n    void Bar() { std::cout &lt;&lt; \"Foo::Bar\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    shared_ptr&lt;Foo&gt; foo(new Foo);\n    function&lt;void(Foo*)&gt; f1(bind(&amp;Foo::Bar, placeholders::_1));\n    function&lt;void(shared_ptr&lt;Foo&gt;)&gt; f2(bind(&amp;Foo::Bar, placeholders::_1));\n    return 0;\n}\n</code></pre>\n<p>GCC objects to the second bind statement being assigned to the function object with the shared_ptr signature. Here is the error output.</p>\n<blockquote>\n<p id=\"so_7408263_7408263_0\">/usr/include/c++/4.5/functional:2103|6|instantiated from\n  \u2018std::function&lt;_Res(_ArgTypes ...)&gt;::function(_Functor, typename\n  std::enable_if&lt;(! std::is_integral&lt;_Functor&gt;::value),\n  std::function&lt;_Res(_ArgTypes ...)&gt;::_Useless&gt;::type) [with _Functor =\n  std::_Bind(std::_Placeholder&lt;1&gt;)&gt;, _Res\n  = void, _ArgTypes = {std::shared_ptr}, typename std::enable_if&lt;(!\n  std::is_integral&lt;_Functor&gt;::value), std::function&lt;_Res(_ArgTypes\n  ...)&gt;::_Useless&gt;::type =\n  std::function)&gt;::_Useless]\u2019|\n  /home/craig/work/litd/test/main.cpp:29|97|instantiated from here|\n  /usr/include/c++/4.5/functional|1713|error: no match for call to\n  \u2018(std::_Bind(std::_Placeholder&lt;1&gt;)&gt;)\n  (std::shared_ptr)\u2019| ||=== Build finished: 1 errors, 0 warnings\n  ===|</p>\n</blockquote>\n<p>Edit:\nMore mystery, when I change the include headers to their tr1 equivalents, it does compile.</p>\n<pre><code>#include &lt;tr1/functional&gt;\n#include &lt;tr1/memory&gt;\n#include &lt;iostream&gt;\n\nusing namespace std::tr1;\n\nclass Foo\n{\npublic:\n    void Bar() { std::cout &lt;&lt; \"Foo::Bar\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    shared_ptr&lt;Foo&gt; foo(new Foo);\n    function&lt;void(Foo*)&gt; f1(bind(&amp;Foo::Bar, placeholders::_1));\n    function&lt;void(shared_ptr&lt;Foo&gt;)&gt; f2(bind(&amp;Foo::Bar, placeholders::_1));\n    return 0;\n}\n</code></pre>\n", "Title": "Why does this code fragment compile with VS2010 but not GCC 4.5.2?", "CreationDate": "2011-09-13T20:47:13.473", "LastActivityDate": "2011-09-13T23:13:25.137", "CommentCount": "3", "LastEditDate": "2011-09-13T22:00:09.163", "PostTypeId": "1", "LastEditorUserId": "943379", "Id": "7408263", "Score": "1", "OwnerUserId": "943379", "Tags": "<c++><visual-studio-2010><function><gcc><bind>", "AnswerCount": "2"}, "7409500": {"Id": "7409500", "PostTypeId": "2", "Body": "<p>It looks like a bug in g++'s implementation of <code>std::function</code> or maybe <code>std::bind</code>, depending on whether you can invoke the object returned by <code>bind(&amp;Foo::Bar, placeholders::_1)</code> with <code>foo</code>; if this works:</p>\n<pre><code>auto fn2 = bind(&amp;Foo::Bar, placeholders::_1);\nfn2(foo);\n</code></pre>\n<p>then it would seem that g++'s <code>std::function</code> implementation is incomplete. Otherwise, it would seem that the implementation of <code>std::bind</code> is incomplete.</p>\n<p>[20.8.9.1.2] Function template <code>bind</code> states:</p>\n<blockquote>\n<pre><code>template&lt;class F, class... BoundArgs&gt;\n  unspecified bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);\n</code></pre>\n<p id=\"so_7408263_7409500_0\">...</p>\n<p id=\"so_7408263_7409500_1\"><em>Returns</em>: A forwarding call wrapper <code>g</code> with a weak result type (20.8.2). The effect of <code>g(u1, u2, ..., uM)</code> shall be <code><em>INVOKE</em>(fd, v1, v2, ..., vN, result_of::type)</code></p>\n</blockquote>\n<p>[20.8.2] Requirements states:</p>\n<blockquote>\n<p id=\"so_7408263_7409500_2\">Define <code><em>INVOKE</em>(f, t1, t2, ..., tN)</code> as follows:</p>\n<p id=\"so_7408263_7409500_3\">\u2014 <code>(t1.*f)(t2, ..., tN)</code> when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>t1</code> is an object of type <code>T</code> or a reference to an object of type <code>T</code> or a reference to an object of a type derived from <code>T</code>;</p>\n<p id=\"so_7408263_7409500_4\">\u2014 <code>((*t1).*f)(t2, ..., tN)</code> when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>t1</code> is not one of the types described in the previous item;</p>\n<p id=\"so_7408263_7409500_5\">...</p>\n</blockquote>\n<p>When binding <code>&amp;Foo::Bar</code>, the returned \"forwarding call wrapper\" takes one argument, <code>u1</code>. Call its type <code>U1</code>. Further on in [20.8.9.1.2] it states that because the 1st template argument type in <code>BoundArgs</code> was the <code>_1</code> placeholder type, the type <code>V1</code> is <code>U1&amp;&amp;</code>.</p>\n<p>Passing a <code>std::shared_ptr&lt;Foo&gt;</code> to the forwarding call wrapper returned by <code>bind(&amp;Foo::Bar, placeholders::_1)</code> should be allowed because case 2 of [20.8.2] applies.</p>\n<p><strong>EDIT:</strong> I am using the same version of g++ as you, 4.5.2, on Windows (MinGW). For me, the following compiles just fine:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Foo\n{\npublic:\n    void Bar() { std::cout &lt;&lt; \"Foo::Bar\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    shared_ptr&lt;Foo&gt; foo(new Foo);\n    function&lt;void(Foo*)&gt; f1(bind(&amp;Foo::Bar, placeholders::_1));\n    //function&lt;void(shared_ptr&lt;Foo&gt;)&gt; f2(bind(&amp;Foo::Bar, placeholders::_1));\n    auto fn2 = bind(&amp;Foo::Bar, placeholders::_1);\n    fn2(foo);\n    return 0;\n}\n</code></pre>\n<p><s>It thus appears to be g++'s implementation of <code>std::function</code> that is to blame.</s></p>\n<p><strong>EDIT2:</strong> The following fails:</p>\n<pre><code>auto fn2 = bind(&amp;Foo::Bar, placeholders::_1);\nfn2(std::shared_ptr&lt;Foo&gt;(foo));\n</code></pre>\n<blockquote>\n<p id=\"so_7408263_7409500_6\">SO7408263.cpp:19:31: error: no match for call to '(std::_Bind(std::_Placeholder&lt;1&gt;)&gt;) (std::shared_ptr)'</p>\n</blockquote>\n<p>Perhaps it's <code>std::bind</code> after all.</p>\n", "LastEditorUserId": "196844", "LastActivityDate": "2011-09-13T23:13:25.137", "Score": "1", "CreationDate": "2011-09-13T22:53:56.123", "ParentId": "7408263", "CommentCount": "2", "OwnerUserId": "196844", "LastEditDate": "2011-09-13T23:13:25.137"}});