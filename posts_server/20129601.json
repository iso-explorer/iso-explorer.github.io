post_cb({"20129601": {"ViewCount": "1700", "Body": "<p>The following code doesn't compile:</p>\n<pre><code>#include &lt;functional&gt;\n\nstruct X\n{\n    std::function&lt;X()&gt; _gen;\n};\n\nint main()\n{\n    X x;\n    x._gen = [] { return X(); }; //this line is causing problem!\n}\n</code></pre>\n<p>I don't understand why assignment to <code>x._gen</code> is causing problem. Both <a href=\"http://coliru.stacked-crooked.com/a/85bdaa8349d2c7eb\">gcc</a> and <a href=\"http://coliru.stacked-crooked.com/a/d278fb63cc2dadb9\">clang</a> are giving similar error messages. Could anyone please explain it? </p>\n<hr>\n<h3>Compiler error messages</h3>\n<p><a href=\"http://coliru.stacked-crooked.com/a/85bdaa8349d2c7eb\">GCC's error</a>:</p>\n<pre><code>In file included from main.cpp:1:0:\n/usr/include/c++/4.8/functional: In instantiation of \u2018std::function&lt;_Res(_ArgTypes ...)&gt;::_Requires&lt;std::function&lt;_Res(_ArgTypes ...)&gt;::_CheckResult&lt;std::function&lt;_Res(_ArgTypes ...)&gt;::_Invoke&lt;_Functor&gt;, _Res&gt;, std::function&lt;_Res(_ArgTypes ...)&gt;&amp;&gt; std::function&lt;_Res(_ArgTypes ...)&gt;::operator=(_Functor&amp;&amp;) [with _Functor = main()::__lambda0; _Res = X; _ArgTypes = {}; std::function&lt;_Res(_ArgTypes ...)&gt;::_Requires&lt;std::function&lt;_Res(_ArgTypes ...)&gt;::_CheckResult&lt;std::function&lt;_Res(_ArgTypes ...)&gt;::_Invoke&lt;_Functor&gt;, _Res&gt;, std::function&lt;_Res(_ArgTypes ...)&gt;&amp;&gt; = std::function&lt;X()&gt;&amp;]\u2019:\nmain.cpp:11:12:   required from here\n/usr/include/c++/4.8/functional:2333:4: error: no matching function for call to \u2018std::function&lt;X()&gt;::function(main()::__lambda0)\u2019\n    function(std::forward&lt;_Functor&gt;(__f)).swap(*this);\n    ^\n/usr/include/c++/4.8/functional:2333:4: note: candidates are:\n/usr/include/c++/4.8/functional:2255:2: note: template&lt;class _Functor, class&gt; std::function&lt;_Res(_ArgTypes ...)&gt;::function(_Functor)\n  function(_Functor);\n  ^\n/usr/include/c++/4.8/functional:2255:2: note:   template argument deduction/substitution failed:\n/usr/include/c++/4.8/functional:2230:7: note: std::function&lt;_Res(_ArgTypes ...)&gt;::function(std::function&lt;_Res(_ArgTypes ...)&gt;&amp;&amp;) [with _Res = X; _ArgTypes = {}]\n       function(function&amp;&amp; __x) : _Function_base()\n       ^\n/usr/include/c++/4.8/functional:2230:7: note:   no known conversion for argument 1 from \u2018main()::__lambda0\u2019 to \u2018std::function&lt;X()&gt;&amp;&amp;\u2019\n/usr/include/c++/4.8/functional:2433:5: note: std::function&lt;_Res(_ArgTypes ...)&gt;::function(const std::function&lt;_Res(_ArgTypes ...)&gt;&amp;) [with _Res = X; _ArgTypes = {}]\n     function&lt;_Res(_ArgTypes...)&gt;::\n     ^\n/usr/include/c++/4.8/functional:2433:5: note:   no known conversion for argument 1 from \u2018main()::__lambda0\u2019 to \u2018const std::function&lt;X()&gt;&amp;\u2019\n/usr/include/c++/4.8/functional:2210:7: note: std::function&lt;_Res(_ArgTypes ...)&gt;::function(std::nullptr_t) [with _Res = X; _ArgTypes = {}; std::nullptr_t = std::nullptr_t]\n       function(nullptr_t) noexcept\n       ^\n/usr/include/c++/4.8/functional:2210:7: note:   no known conversion for argument 1 from \u2018main()::__lambda0\u2019 to \u2018std::nullptr_t\u2019\n/usr/include/c++/4.8/functional:2203:7: note: std::function&lt;_Res(_ArgTypes ...)&gt;::function() [with _Res = X; _ArgTypes = {}]\n       function() noexcept\n       ^\n/usr/include/c++/4.8/functional:2203:7: note:   candidate expects 0 arguments, 1 provided\n</code></pre>\n<p>Likewise, <a href=\"http://coliru.stacked-crooked.com/a/d278fb63cc2dadb9\">Clang throws</a> this:</p>\n<pre><code>main.cpp:11:12: error: no viable overloaded '='\n    x._gen = [] { return X(); };\n    ~~~~~~ ^ ~~~~~~~~~~~~~~~~~~\n/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional:2270:7: note: candidate function not viable: no known conversion from '&lt;lambda at main.cpp:11:14&gt;' to 'const std::function&lt;X ()&gt;' for 1st argument\n      operator=(const function&amp; __x)\n      ^\n/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional:2288:7: note: candidate function not viable: no known conversion from '&lt;lambda at main.cpp:11:14&gt;' to 'std::function&lt;X ()&gt;' for 1st argument\n      operator=(function&amp;&amp; __x)\n      ^\n/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional:2302:7: note: candidate function not viable: no known conversion from '&lt;lambda at main.cpp:11:14&gt;' to 'nullptr_t' for 1st argument\n      operator=(nullptr_t)\n      ^\n/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional:2192:39: note: candidate template ignored: disabled by 'enable_if' [with _Functor = &lt;lambda at main.cpp:11:14&gt;]\n        using _Requires = typename enable_if&lt;_Cond::value, _Tp&gt;::type;\n                                             ^\n/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/functional:2340:2: note: candidate template ignored: could not match 'reference_wrapper&lt;type-parameter-0-0&gt;' against '&lt;lambda at main.cpp:11:14&gt;'\n        operator=(reference_wrapper&lt;_Functor&gt; __f) noexcept\n        ^\n</code></pre>\n</hr>", "AcceptedAnswerId": "29457380", "Title": "Why assignment to std::function<X()> doesn't compile when it is a member of class X?", "CreationDate": "2013-11-21T18:56:10.463", "Id": "20129601", "CommentCount": "10", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2013-11-21T19:01:40.123", "LastEditorUserId": "415784", "LastActivityDate": "2015-04-05T13:54:59.160", "Score": "16", "OwnerUserId": "415784", "Tags": "<c++><c++11><lambda><std-function>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_20129601_29457380_3": {"length": 15, "quality": 0.8333333333333334, "section_id": 4651}, "so_20129601_29457380_1": {"length": 10, "quality": 0.7692307692307693, "section_id": 4660}}, "n3337": {"so_20129601_29457380_3": {"length": 15, "quality": 0.8333333333333334, "section_id": 4462}}, "n4659": {"so_20129601_29457380_3": {"length": 14, "quality": 0.7777777777777778, "section_id": 6020}, "so_20129601_29457380_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 6030}}}, "20129997": {"Id": "20129997", "PostTypeId": "2", "Body": "<p>This may be a gcc bug, but maybe not.  It isn't <em>directly</em> in <code>=</code> but rather in the conversion constructor for <code>std::function</code> (which the <code>operator=</code> invokes).</p>\n<p>Here is a pathological example of it happening:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nstruct X\n{\n  std::function&lt;X()&gt; _gen;\n};\n\nX func() {return {};};\n\nint main()\n{\n  std::function&lt;X()&gt; foo1( &amp;func ); // compiles\n  X unused = X{}; // copy ctor invoked\n  std::function&lt;X()&gt; foo2( &amp;func ); // does not compile!\n}\n</code></pre>\n<p>note that the first <code>foo1</code> works fine, it is not until I cause some code somewhere to invoke the copy ctor that the second one generates errors.  Even <code>auto unused =[]{ return X{}; };</code> is enough.  (<code>func</code> direct constructs and never copies).</p>\n<p>It is the use/\"creation\" of the copy ctor that seems to cause the problem. </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nstruct X\n{\n  std::function&lt;X()&gt; _gen;\n  X( X const&amp; ) = default;\n  X() = default;\n};\nX func() {return {};};\n\nint main()\n{\n  std::function&lt;X()&gt; foo1( &amp;func ); // does not compile\n}\n</code></pre>\n<p>that copy constructor ends up calling the copy ctor of <code>_gen</code>, possibly before <code>X</code> is a complete type.</p>\n<p>If we explicitly delay instantiation of <code>X::X(X const&amp;)</code> until <code>X</code> is a complete type:</p>\n<pre><code>#include &lt;functional&gt;\n\nstruct X\n{\n  std::function&lt;X()&gt; _gen;\n  X( X const&amp; );\n  X() {}\n};\nX::X( X const&amp; o ):_gen(o._gen){} // or =default *here*\n\nX func() {return {};};\n\nint main()\n{\n  std::function&lt;X()&gt; foo1( &amp;func ); // compiles!\n  []{ return X{}; }; // or X unused = X{};\n  std::function&lt;X()&gt; foo2( &amp;func ); // compiles!\n}\n</code></pre>\n<p>the problem goes away.</p>\n<p>I suspect that the implicit copy constructor of <code>X</code> created in the body of <code>X</code> when <code>X</code> is an incomplete type implicitly invokes <code>std::function&lt;X()&gt;</code>'s copy constructor, which is in a context where <code>X</code> is incomplete, which breaks the preconditions of its copy constructor being invoked (at least in practice in how it was implemented in gcc -- by the standard?  I am unsure.)</p>\n<p>By explicitly making a copy ctor outside of <code>X</code> I avoid this, and everything works.</p>\n<p>So as a work around to your problem, declare and implement <code>X::X(X const&amp;)</code> outside of <code>X</code>, and the magic error goes away.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2015-04-05T13:54:59.160", "Score": "6", "CreationDate": "2013-11-21T19:19:19.470", "ParentId": "20129601", "CommentCount": "8", "OwnerUserId": "1774667", "LastEditDate": "2015-04-05T13:54:59.160"}, "29457380": {"Id": "29457380", "PostTypeId": "2", "Body": "<p>This was <a href=\"https://gcc.gnu.org/PR60594\">PR60594</a>, which got fixed in GCC 4.8.3. The comments on that bug point out why it is valid: although the standard requires template arguments for standard library templates to be a complete type (with some exceptions), <code>X()</code> is a complete type even if <code>X</code> is not.</p>\n<p>There are several members of <code>std::function&lt;X()&gt;</code> that do implicitly require <code>X</code> to be a complete type. The template constructor you're using is one of them: it requires the return type of your lambda to be implicitly convertible to <code>X</code>, but whether <code>X</code> is convertible to itself depends on whether <code>X</code> is a complete type: if it's incomplete, the compiler can't rule out the possibility that it is an uncopyable unmovable type.</p>\n<p>This requirement follows from:</p>\n<blockquote>\n<p id=\"so_20129601_29457380_0\"><strong>20.9.11.2.1 function construct/copy/destroy [func.wrap.func.con]</strong></p>\n<p id=\"so_20129601_29457380_1\">8 <em>Remarks:</em> These constructors shall not participate in overload resolution unless <code>f</code> is Callable (20.9.11.2) for argument types <code>ArgTypes...</code> and return type <code>R</code>.</p>\n<p id=\"so_20129601_29457380_2\"><strong>20.9.11.2 Class template function [func.wrap.func]</strong></p>\n<p id=\"so_20129601_29457380_3\">2 A callable object <code>f</code> of type <code>F</code> is <em>Callable</em> for argument types <code>ArgTypes</code> and return type <code>R</code> if the expression <em><code>INVOKE</code></em><code>(f, declval&lt;ArgTypes&gt;()..., R)</code>, considered as an unevaluated operand (Clause 5), is well formed (20.9.2).</p>\n<p id=\"so_20129601_29457380_4\"><strong>20.9.2 Requirements [func.require]</strong></p>\n<p id=\"so_20129601_29457380_5\">2 Define <em><code>INVOKE</code></em><code>(f, t1, t2, ..., tN, R)</code> as <em><code>INVOKE</code></em><code>(f, t1, t2, ..., tN)</code> implicitly converted to <code>R</code>.</p>\n</blockquote>\n<p>Several other members of <code>std::function</code> also require <code>X</code> to be a complete type.</p>\n<p>You're only using that constructor <em>after</em> type <code>X</code> has already completed, though, so there's no problem: at that point, <code>X</code> certainly can be implicitly converted to <code>X</code>.</p>\n<p>The problem was that <code>std::function</code> was performing checks that depend on <code>X</code> being a complete type, in a context where the standard doesn't support performing such checks, and this did not account for the possibility that <code>X</code> would become a complete type after the instantiation of <code>std::function&lt;X()&gt;</code> had already completed.</p>\n", "LastActivityDate": "2015-04-05T12:41:33.810", "CommentCount": "0", "CreationDate": "2015-04-05T12:41:33.810", "ParentId": "20129601", "Score": "8", "OwnerUserId": "743382"}});