post_cb({"27777332": {"ParentId": "27777071", "PostTypeId": "2", "CommentCount": "11", "CreationDate": "2015-01-05T10:13:09.890", "Score": "97", "LastEditorUserId": "703019", "LastEditDate": "2015-01-07T06:27:25.353", "Id": "27777332", "OwnerUserId": "335858", "Body": "<p>Since the question is double-tagged as C and C++, the reasoning for C++ and C would be different:</p>\n<ul>\n<li>C++ uses name mangling to help linker distinguish between textually identical symbols of different types, e.g. a global variable <code>xyz</code> and a free-standing global function <code>xyz(int)</code>. However, the name <code>main</code> is never mangled.</li>\n<li>C does not use mangling, so it is possible for a program to confuse linker by providing a symbol of one kind in place of a different symbol, and have the program successfully link.</li>\n</ul>\n<p>That is what's going on here: the linker expects to find symbol <code>main</code>, and it does. It \"wires\" that symbol as if it were a function, because it does not know any better. The portion of runtime library that passes control to <code>main</code> asks linker for <code>main</code>, so linker gives it symbol <code>main</code>, letting the link phase to complete. Of course this fails at runtime, because <code>main</code> is not a function.</p>\n<p>Here is another illustration of the same issue:</p>\n<p>file x.c:</p>\n<pre><code>#include &lt;stdio.h&gt;\nint foo(); // &lt;&lt;== main() expects this\nint main(){\n    printf(\"%p\\n\", (void*)&amp;foo);\n    return 0;\n}\n</code></pre>\n<p>file y.c:</p>\n<pre><code>int foo; // &lt;&lt;== external definition supplies a symbol of a wrong kind\n</code></pre>\n<p>compiling:</p>\n<pre><code>gcc x.c y.c\n</code></pre>\n<p>This compiles, and it would probably run, but it's undefined behavior, because the type of the symbol promised to the compiler is different from the actual symbol supplied to the linker.</p>\n<p>As far as the warning goes, I think it is reasonable: C lets you build libraries that have no <code>main</code> function, so the compiler frees up the name <code>main</code> for other uses if you need to define a variable <code>main</code> for some unknown reason.</p>\n", "LastActivityDate": "2015-01-07T06:27:25.353"}, "27786866": {"ParentId": "27777071", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-01-05T19:55:29.607", "Score": "19", "LastEditorUserId": "775806", "LastEditDate": "2015-01-05T21:28:37.627", "Id": "27786866", "OwnerUserId": "775806", "Body": "<p><em>Is <code>int main;</code> a valid C/C++ program?</em></p>\n<p>It is not entirely clear what a C/C++ program is.</p>\n<p><em>Is <code>int main;</code> a valid C program?</em></p>\n<p>Yes. A freestanding implementation is allowed to accept such program. <code>main</code> doesn't have to have any special meaning in a freestanding environment.</p>\n<p>It is <em>not</em> valid in a hosted environment.</p>\n<p><em>Is <code>int main;</code> a valid C++ program?</em></p>\n<p>Ditto.</p>\n<p><em>Why does it crash?</em></p>\n<p>The program doesn't have to make sense in <em>your</em> environment. In a freestanding environment the program startup and termination, and the meaning of <code>main</code>, are implementation-defined.</p>\n<p><em>Why does the compiler warn me?</em></p>\n<p>The compiler may warn you about whatever it pleases, as long as it doesn't reject conforming programs. On the other hand, warning is all that's required to diagnose a non-conforming program. Since this translation unit cannot be a part of a valid hosted program, a diagnostic message is justified.</p>\n<p><em>Is <code>gcc</code> a freestanding environment, or is it a hosted environment?</em></p>\n<p>Yes.</p>\n<p><code>gcc</code> documents the <code>-ffreestanding</code> compilation flag. Add it, and the warning goes away. You may want to use it when building e.g. kernels or firmware.</p>\n<p><code>g++</code> doesn't document such flag. Supplying it seems to have no effect on this program. It is probably safe to assume that the environment provided by g++ is hosted. Absence of diagnostic in this case is a bug.</p>\n", "LastActivityDate": "2015-01-05T21:28:37.627"}, "27814127": {"ParentId": "27777071", "CommentCount": "0", "Body": "<p>For C so far it is implementation defined behavior.</p>\n<p>As the ISO/IEC9899 says:</p>\n<blockquote>\n<p id=\"so_27777071_27814127_0\">5.1.2.2.1 Program startup</p>\n<p id=\"so_27777071_27814127_1\">1 The function called at program startup is named main. The implementation declares no\n  prototype for this function. It shall be defined with a return type of int and with no\n  parameters:</p>\n<p id=\"so_27777071_27814127_2\"><code>int main(void) { /* ... */ }</code></p>\n<p id=\"so_27777071_27814127_3\">or with two parameters (referred to here as argc and argv, though any names may be\n  used, as they are local to the function in which they are declared):</p>\n<p id=\"so_27777071_27814127_4\"><code>int main(int argc, char *argv[]) { /* ... */ }</code></p>\n<p id=\"so_27777071_27814127_5\">or equivalent; or in some other implementation-defined manner.</p>\n</blockquote>\n", "OwnerUserId": "2003898", "PostTypeId": "2", "Id": "27814127", "Score": "4", "CreationDate": "2015-01-07T07:06:38.260", "LastActivityDate": "2015-01-07T07:06:38.260"}, "27785607": {"ParentId": "27777071", "PostTypeId": "2", "CommentCount": "11", "CreationDate": "2015-01-05T18:27:42.767", "Score": "9", "LastEditorUserId": "3561240", "LastEditDate": "2015-01-06T00:10:28.777", "Id": "27785607", "OwnerUserId": "3561240", "Body": "<p><strong><em>Is it a valid program?</em></strong></p>\n<p><em>No.</em></p>\n<p>It is not a program as it has no executable parts.</p>\n<p><strong><em>Is it valid to compile?</em></strong></p>\n<p><em>Yes.</em></p>\n<p><strong><em>Can it be used with a valid program?</em></strong></p>\n<p><em>Yes.</em></p>\n<p>Not all compiled code is required to be executable to be valid. Examples are static and dynamic libraries.</p>\n<p>You have effectively built an object file. It is not a valid executable, however another program could link to the object <code>main</code> in the resultant file by loading it at runtime.</p>\n<p><strong><em>Should this be an error?</em></strong></p>\n<p>Traditionally, C++ allows the user to do things that may be seem like they have no valid use but that fit with the syntax of the language.</p>\n<p>I mean that sure, this could be reclassified as an error, but why? What purpose would that serve that the warning does not?</p>\n<p>So long as there is a theoretical possibility of this functionality being used in actual code, it is very unlikely that having a non-function object called <code>main</code> would result in an error according to the language.</p>\n", "LastActivityDate": "2015-01-06T00:10:28.777"}, "27807579": {"ParentId": "27777071", "CommentCount": "0", "Body": "<p>I would like to add to the answers already given by citing the actual language standards.</p>\n<h2>Is \u2018int main;\u2019 a valid C program?</h2>\n<p>Short answer (my opinion): only if your implementation uses a \"freestanding execution environment\".</p>\n<p>All following quotes from <a href=\"http://open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\">C11</a></p>\n<p><strong>5. Environment</strong></p>\n<blockquote>\n<p id=\"so_27777071_27807579_0\">An implementation translates C source files and executes <em>C programs</em> in\n  two dataprocessing-system environments, which will be called the\n  translation environment and the execution environment [...]</p>\n</blockquote>\n<p><strong>5.1.2 Execution environments</strong></p>\n<blockquote>\n<p id=\"so_27777071_27807579_1\">Two execution environments are defined: freestanding and hosted. In\n  both cases, program startup occurs when a designated C function is\n  called by the execution environment.</p>\n</blockquote>\n<p><strong>5.1.2.1 Freestanding environment</strong></p>\n<blockquote>\n<p id=\"so_27777071_27807579_2\">In a freestanding environment (in which C program execution may take\n  place without any benefit of an operating system), the name and type\n  of the function called at program startup are implementation-defined.</p>\n</blockquote>\n<p><strong>5.1.2.2 Hosted environment</strong></p>\n<blockquote>\n<p id=\"so_27777071_27807579_3\">A hosted environment need not be provided, but shall conform to the\n  following specifications if present.</p>\n</blockquote>\n<p><strong>5.1.2.2.1 Program startup</strong></p>\n<blockquote>\n<p id=\"so_27777071_27807579_4\">The function called at program startup is named <em>main</em>. [...] It shall\n  be defined with a return type of int and with no parameters [...] or\n  with two parameters [...] or equivalent or in some other\n  implementation-defined manner.</p>\n</blockquote>\n<p>From these, the following is observed:</p>\n<ul>\n<li>A C11 program can have a freestanding or a hosted execution environment and be valid.</li>\n<li>If it has a freestanding one, there need not exist a main function.</li>\n<li>Otherwise, there must be one with a return vale of type <em>int</em>.</li>\n</ul>\n<p>In a freestanding execution environment, I would argue that it is a valid program that does not allow startup to happen, because there is no function present for that as required in 5.1.2.\nIn a hosted execution environment, while your code introduces an object named <em>main</em>, it cannot provide a return value, so I would argue that it is not a valid program in this sense, although one could also argue like before that if the program is not meant to be executed (on might want to provide data only for example), then it just does not allow to do just that.</p>\n<h2>Is \u2018int main;\u2019 a valid C++ program?</h2>\n<p>Short answer (my opinion): only if your implementation uses a \"freestanding execution environment\".</p>\n<p>Quote from <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\">C++14</a></p>\n<p><strong>3.6.1 Main function</strong></p>\n<blockquote>\n<p id=\"so_27777071_27807579_5\">A program shall contain a global function called main, which is the\n  designated start of the program. It is implementation-defined whether\n  a program in a freestanding environment is required to define a main\n  function. [...] It shall have a return type of type int, but otherwise\n  its type is implementation-defined. [...] The name main is not\n  otherwise reserved.</p>\n</blockquote>\n<p>Here, as opposed to the C11 standard, less restrictions apply to the freestanding execution environment, as no startup function is mentioned at all, while for a hosted execution environment, the case is pretty much the same as for C11.</p>\n<p>Again, I would argue that for the hosted case, your code is not a valid C++14 program, but I am sure that it is for the freestanding case.</p>\n<p>Since my answer only considers the <em>execution</em> environment, I think the answer by dasblinkenlicht comes into play, as name mangling occuring in the <em>translation</em> environment happens beforehand. Here, I am not so sure that the quotes above are observed so strictly.</p>\n", "OwnerUserId": "797551", "PostTypeId": "2", "Id": "27807579", "Score": "6", "CreationDate": "2015-01-06T21:36:15.437", "LastActivityDate": "2015-01-06T21:36:15.437"}, "27777071": {"CommentCount": "10", "AcceptedAnswerId": "27777332", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-01-05T09:58:20.497", "LastActivityDate": "2016-08-26T08:18:05.217", "LastEditDate": "2017-05-23T12:17:11.370", "ViewCount": "8799", "FavoriteCount": "13", "Title": "Is \u2018int main;\u2019 a valid C/C++ program?", "Id": "27777071", "Score": "110", "Body": "<p>I ask because my compiler seems to think so, even though I don\u2019t.</p>\n<p><code>echo 'int main;' | cc -x c - -Wall</code><br>\n<code>echo 'int main;' | c++ -x c++ - -Wall</code></br></p>\n<p>Clang issues no warning or error with this, and gcc issues only the meek warning: <code>'main' is usually a function [-Wmain]</code>, but only when compiled as C. Specifying a <code>-std=</code> doesn\u2019t seem to matter.</p>\n<p>Otherwise, it compiles and links fine. But on execution, it terminates immediately with <code>SIGBUS</code> (for me). </p>\n<p>Reading through the (excellent) answers at <a href=\"https://stackoverflow.com/questions/204476/what-should-main-return-in-c-and-c\">What should main() return in C and C++?</a> and a quick grep through the language specs, it would certainly <strong>seem</strong> to me that a main <em>function</em> is required. But the verbiage from gcc\u2019s <code>-Wmain</code> (\u2018main\u2019 is <strong><em>usually</em></strong> a function) (and the dearth of errors here) seems to possibly suggest otherwise.</p>\n<p>But why? Is there some strange edge-case or \u201chistorical\u201d use for this? Anyone know what gives?</p>\n<p>My point, I suppose, is that I really think this should be an <strong>error</strong> in a hosted environment, eh?</p>\n", "Tags": "<c++><c><function><main><entry-point>", "OwnerUserId": "2351351", "AnswerCount": "9"}, "27801443": {"ParentId": "27777071", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_27777071_27801443_0\">My point, I suppose, is that I really think this should be an error in a hosted environment, eh?</p>\n</blockquote>\n<p>The error is yours. You didn't specify a function named <code>main</code> that returns an <code>int</code> and tried to use your program in a hosted environment.</p>\n<p>Suppose you have a compilation unit that defines a global variable named <code>main</code>. This might well be legal in a freestanding environment because what constitutes a program is left up to the implementation in freestanding environments.</p>\n<p>Suppose you have another compilation unit that defines a global function named <code>main</code> that returns an <code>int</code> and takes no arguments. This is exactly what a program in a hosted environment needs.</p>\n<p>Everything's fine if you only use the first compilation unit in a freestanding environment and only use the second in a hosted environment. What if you use both in one program? In C++, you've violated the one definition rule. That is undefined behavior. In C, you've violated the rule that dictates that all references to a single symbol must be consistent; if they aren't it's undefined behavior. Undefined behavior is a \"get out of jail, free!\" card to developers of an implementation. Anything an implementation does in response to undefined behavior is compliant with the standard. The implementation doesn't have to warn about, let alone detect, undefined behavior.</p>\n<p>What if you use only one of those compilation units, but you use the wrong one (which is what you did)? In C, the situation is clear-cut. Failure to define the function <code>main</code> in one of the two standard forms in a hosted environment is undefined behavior. Suppose you didn't define <code>main</code> at all. The compiler/linker doesn't haven't to say a thing about this error. That they do complain is a nicety on their behalf. That the C program compiled and linked without error is your fault, not the compiler's.</p>\n<p>It's a bit less clear in C++ because failure to define the function <code>main</code> in a hosted environment is an error rather than undefined behavior (in other words, it must be diagnosed). However, the one definition rule in C++ means linkers can be rather dumb. The linker's job is resolving external references, and thanks to the one definition rule, the linker doesn't have to know what those symbols mean. You provided a symbol named <code>main</code>, the linker is expecting to see a symbol named <code>main</code>, so all is good as far as the linker is concerned.</p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "27801443", "Score": "4", "CreationDate": "2015-01-06T15:08:32.257", "LastActivityDate": "2015-01-06T15:08:32.257"}, "32970511": {"ParentId": "27777071", "CommentCount": "2", "Body": "<p>No, this is not a valid program.</p>\n<p>For C++ this was recently explicitly made ill-formed by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1886\" rel=\"nofollow\">defect report 1886:  Language linkage for main()</a> which says:</p>\n<blockquote>\n<p id=\"so_27777071_32970511_0\">There does not appear to be any restriction on giving main() an explicit language linkage, but it should probably be either ill-formed or conditionally-supported.</p>\n</blockquote>\n<p>and part of the resolution included the following change:</p>\n<blockquote>\n<p id=\"so_27777071_32970511_1\">A program that declares a variable main at global scope or that declares the name main with C language linkage (in any namespace) is ill-formed.</p>\n</blockquote>\n<p>We can find this wording in the latest <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">C++ draft standard N4527</a> which is the the C++1z draft.</p>\n<p>The latest versions of both clang and gcc now make this an error (<em><a href=\"http://melpon.org/wandbox/permlink/yzSaIOZ41lZCgcxt\" rel=\"nofollow\">see it live</a></em>):</p>\n<pre><code>error: main cannot be declared as global variable\nint main;\n^\n</code></pre>\n<p>Before this defect report, it was undefined behavior which does not require a diagnostic. On the other hand ill-formed code requires a diagnostic, the compiler can either make this a warning or an error.</p>\n", "OwnerUserId": "1708801", "PostTypeId": "2", "Id": "32970511", "Score": "3", "CreationDate": "2015-10-06T12:53:01.443", "LastActivityDate": "2015-10-06T12:53:01.443"}, "27780060": {"ParentId": "27777071", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2015-01-05T12:58:43.363", "Score": "17", "LastEditorUserId": "272708", "LastEditDate": "2016-08-26T08:18:05.217", "Id": "27780060", "OwnerUserId": "272708", "Body": "<p>It is a warning as it is not technically disallowed. The startup code will use the symbol location of \"main\" and jump to it with the three standard arguments (argc, argv and envp). It does not, and at link time cannot check that it's actually a function, nor even that it has those arguments. This is also why int main(int argc, char **argv) works - the compiler doesn't know about the envp argument and it just happens not to be used, and it is caller-cleanup.</p>\n<p>As a joke, you could do something like</p>\n<pre><code>int main = 0xCBCBCBCB;\n</code></pre>\n<p>on an x86 machine and, ignoring warnings and similar stuff, it will not just compile but actually work too.</p>\n<p>Somebody used a technique similar to this to write an executable (sort of) that runs on multiple architectures directly - <a href=\"http://phrack.org/issues/57/17.html#article\" rel=\"nofollow\">http://phrack.org/issues/57/17.html#article</a> . It was also used to win the IOCCC - <a href=\"http://www.ioccc.org/1984/mullender/mullender.c\" rel=\"nofollow\">http://www.ioccc.org/1984/mullender/mullender.c</a> .</p>\n", "LastActivityDate": "2016-08-26T08:18:05.217"}, "bq_ids": {"n4140": {"so_27777071_32970511_1": {"section_id": 5522, "quality": 0.5833333333333334, "length": 7}, "so_27777071_27807579_2": {"section_id": 5775, "quality": 0.5333333333333333, "length": 8}, "so_27777071_27777306_0": {"section_id": 7147, "quality": 0.8055555555555556, "length": 29}, "so_27777071_27777306_2": {"section_id": 6307, "quality": 0.8888888888888888, "length": 8}, "so_27777071_27777306_1": {"section_id": 5335, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_27777071_32970511_1": {"section_id": 5308, "quality": 0.5833333333333334, "length": 7}, "so_27777071_27807579_2": {"section_id": 5548, "quality": 0.5333333333333333, "length": 8}, "so_27777071_27777306_0": {"section_id": 6891, "quality": 0.8055555555555556, "length": 29}, "so_27777071_27777306_1": {"section_id": 5132, "quality": 0.8181818181818182, "length": 9}, "so_27777071_27777306_2": {"section_id": 6064, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_27777071_32970511_1": {"section_id": 8648, "quality": 1.0, "length": 12}, "so_27777071_27807579_2": {"section_id": 7232, "quality": 0.5333333333333333, "length": 8}, "so_27777071_27777306_2": {"section_id": 7844, "quality": 0.5555555555555556, "length": 5}, "so_27777071_27777306_1": {"section_id": 6756, "quality": 0.7272727272727273, "length": 8}, "so_27777071_27777306_0": {"section_id": 8648, "quality": 0.7777777777777778, "length": 28}}}, "27777306": {"ParentId": "27777071", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2015-01-05T10:11:31.440", "Score": "30", "LastEditorUserId": "3235496", "LastEditDate": "2015-01-07T14:19:43.580", "Id": "27777306", "OwnerUserId": "3235496", "Body": "<p><code>main</code> isn't a <em>reserved word</em> it's just a <em>predefined identifier</em> (like <code>cin</code>, <code>endl</code>, <code>npos</code>...), so you could declare a variable called <code>main</code>, initialize it and then print out its value.</p>\n<p>Of course:</p>\n<ul>\n<li>the warning is useful since this is quite error prone;</li>\n<li>you can have a source file without the <code>main()</code> function (libraries).</li>\n</ul>\n<p>EDIT</p>\n<p>Some references:</p>\n<ul>\n<li><p><code>main</code> is not a reserved word (C++11):</p>\n<blockquote>\n<p id=\"so_27777071_27777306_0\">The function <code>main</code> shall not be used within a program. The linkage\n  (3.5) of <code>main</code> is implementation-defined. A program that defines main\n  as deleted or that declares main to be <code>inline</code>, <code>static</code>, or\n  <code>constexpr</code> is ill-formed. <strong>The name <code>main</code> is not otherwise\n  reserved. [ Example: member functions, classes and enumerations can be\n  called <code>main</code>, as can entities in other namespaces. \u2014 end example ]</strong></p>\n</blockquote>\n<p><sup>C++11 - [basic.start.main] 3.6.1.3</sup></p>\n<blockquote>\n<p id=\"so_27777071_27777306_1\"><strong>[2.11/3]</strong> [...] some identifiers are reserved for use by C++ implementations and standard libraries (17.6.4.3.2) and shall not be used otherwise; no diagnostic is required.</p>\n<p id=\"so_27777071_27777306_2\"><strong>[17.6.4.3.2/1]</strong> Certain sets of names and function signatures are always reserved to the implementation:</p>\n<ul>\n<li>Each name that contains a double underscore __ or begins with an underscore followed by an uppercase letter (2.12) is reserved to the implementation for any use.</li>\n<li>Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace.</li>\n</ul>\n</blockquote></li>\n<li><p><a href=\"http://en.wikipedia.org/wiki/Reserved_word\" rel=\"noreferrer\">Reserved words in programming languages</a>.</p>\n<p>Reserved words may not be redefined by the programmer, but predefineds can often be overridden in some capacity. This is the case of <code>main</code>: there are scopes in which a declaration using that identifier redefines its meaning.</p></li>\n</ul>\n", "LastActivityDate": "2015-01-07T14:19:43.580"}});