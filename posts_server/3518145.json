post_cb({"3518343": {"ParentId": "3518145", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_3518145_3518343_0\">$13.3.1.5/2 states- \"The conversion\n  functions of S and its base classes\n  are considered. Those that are not\n  hidden within S and yield type T or a\n  type that can be converted to type T\n  via a standard conversion sequence\n  (13.3.3.1.1) are candidate functions.\n  Conversion functions that return a\n  cv-qualified type are considered to\n  yield the cv-unqualified version of\n  that type for this process of\n  selecting candidate functions.\n  Conversion functions that return\n  \u201creference to cv2 X\u201d return lvalues of\n  type \u201ccv2 X\u201d and are therefore\n  considered to yield X for this process\n  of selecting candidate functions.\"</p>\n</blockquote>\n<p>The assignment s = t works as follows:</p>\n<p>a) All members in the type of 't' (testClass) are considered which can convert 't' to 's'.</p>\n<pre><code>Candidate 1: operator string();   // s created using member string::operator=(string const&amp;)\nCandidate 2: operator char *()    // s created using member string::operator=(char const*)\nCandidate 3: operator char *()    // s created using member string::operator=(char *)\n</code></pre>\n<p>b) All of the above candidates are viable (that is, in absence of other candidates, the compiler can successfully resolve the function call to either of them)</p>\n<p>c) However, now the best viable candidate has to be determined. The Conversion sequences involved are:</p>\n<pre><code>Candidate 1: U1 : operator string()\nCandidate 2: U2 : operator char*()-&gt;const qualification to match string::operator=(char const*)\nCandidate 3: U3 : operator char*()\n</code></pre>\n<blockquote>\n<p id=\"so_3518145_3518343_1\">$13.3.3.1.1/3 states - \"The rank of a\n  conversion sequence is determined by\n  considering the rank of each\n  conversion in the sequence and the\n  rank of any reference binding\n  (13.3.3.1.4). If any of those has\n  Conversion rank, the sequence has\n  Conversion rank;\"</p>\n</blockquote>\n<p>This means that U1, U2 and U3 are all having Conversion rank and at a first level neither s better than the other. However, the standard also states</p>\n<blockquote>\n<p id=\"so_3518145_3518343_2\">User-defined conversion sequence U1 is\n  a better conversion sequence than\n  another user-defined conversion\n  sequence U2 if they contain the same\n  user-defined conversion function or\n  constructor and if the second standard\n  conversion sequence of U1 is better\n  than the second standard conversion\n  sequence of U2.</p>\n</blockquote>\n<p>So, let's see what this means.</p>\n<p>Between U1 and U2, they involve, different conversion functions and hence none is better than the other</p>\n<p>Between U1 and U3, they involve, different conversion functions and hence none is better than the other</p>\n<p>So what about U1 and U2. They involve the same conversion function, which satisfies the first part of the \"and\" condition above</p>\n<p>So what about the part \"and if the second standard conversion sequence of U1 is better than the second standard conversion sequence of U2.\"</p>\n<p>In U2, the second standard conversion sequence requires a const qualification, where in U3 this is not required. The second standard conversion sequence of U3 is an Exact Match.</p>\n<p>But as Table 9 in the Standard states, CV qualification is also considered to be an Exact Match.</p>\n<p>Therefore U2 and U3 are also really indistinguisable as far as overload resolution is considered.</p>\n<p>This means U1, U2 and U3 are all really as good as each other and the compiler finds resolving the call(as part of assignment statement) as ambiguous, as there is no unambiguous <em>best</em> viable function</p>\n", "OwnerUserId": "418110", "LastEditorUserId": "33345", "LastEditDate": "2010-08-19T04:19:29.113", "Id": "3518343", "Score": "9", "CreationDate": "2010-08-19T02:46:19.110", "LastActivityDate": "2010-08-19T04:19:29.113"}, "3518165": {"ParentId": "3518145", "CommentCount": "2", "Body": "<p>Actually, it's because <code>std::string</code> offers an assignment operator that takes a <code>const char*</code>.</p>\n", "OwnerUserId": "131926", "PostTypeId": "2", "Id": "3518165", "Score": "1", "CreationDate": "2010-08-19T01:54:47.587", "LastActivityDate": "2010-08-19T01:54:47.587"}, "3518171": {"ParentId": "3518145", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>What the error is trying to explain is that your assignment \"<code>s = t</code>\", where <code>s</code> is a <code>std::string</code>, would be valid if <code>t</code> were a <code>std::string</code> too, or if <code>t</code> were a [<code>const</code>] <code>char*</code>.  Your conversion operators can convert a <code>t</code> into either, so the compiler has no basis on which to choose one over the other....</p>\n<p>You can disambiguate this explicitly by selecting the conversion you want:</p>\n<pre><code>s = t.operator std::string();\ns = static_cast&lt;std::string&gt;(t);\n</code></pre>\n<p>Or you can provide only one of the conversions and let the user do a further conversion when necessary.</p>\n<p>You may find though - in the end - that any conversion operator is more trouble than it's worth... it's telling that <code>std::string</code> itself doesn't provide a conversion operator to <code>const char*</code>.</p>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2012-05-08T08:59:58.300", "Id": "3518171", "Score": "10", "CreationDate": "2010-08-19T01:56:52.753", "LastActivityDate": "2012-05-08T08:59:58.300"}, "3518186": {"ParentId": "3518145", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>There's no exact std::string::operator=. The candidates are, paraphrased,</p>\n<pre><code>s = (const std::string)(std::string)t;\ns = (const char*)t;\ns = (char)(int)t;\n</code></pre>\n<p><strike>I think things will work if you change it to return const std::string.</strike> (<strong>EDIT:</strong> I'm wrong.) Also note that the first function should return const char *. If you need to cast a string literal to char*, you're doing something wrong; string literals are <em>not</em> writeable.</p>\n", "OwnerUserId": "349112", "LastEditorUserId": "349112", "LastEditDate": "2010-08-19T13:48:38.647", "Id": "3518186", "Score": "3", "CreationDate": "2010-08-19T02:00:59.310", "LastActivityDate": "2010-08-19T13:48:38.647"}, "3518145": {"CommentCount": "0", "ViewCount": "20284", "PostTypeId": "1", "LastEditorUserId": "47773", "CreationDate": "2010-08-19T01:48:40.063", "LastActivityDate": "2012-05-08T08:59:58.300", "Title": "C++ overloading conversion operator for custom type to std::string", "FavoriteCount": "4", "LastEditDate": "2010-08-19T01:53:00.593", "Id": "3518145", "Score": "12", "Body": "<p>I hope someone might be able to answer why the following doesn't work. Bear with me though, I am still very much a noob...\nI just cannot get to the bottom of why the following</p>\n<pre><code>using namespace std;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nclass testClass\n{\npublic:\n operator char* () {return (char*)\"hi\";};\n operator int ()  {return 77;};\n operator std::string  () {return \"hello\";};\n};\n\nint main()\n{\n char* c;\n int i;\n std::string s = \"goodday\";\n\n testClass t;\n\n c = t;\n i = t;\n s = t;\n\n cout&lt;&lt; \"char: \" &lt;&lt; c &lt;&lt; \" int: \" &lt;&lt; i &lt;&lt; \" string: \"&lt;&lt;s&lt;&lt;endl;\n\n return 0;\n}\n</code></pre>\n<p>gives me a compile time error:</p>\n<pre><code>myMain.cpp: In function \u2018int main()\u2019:\nmyMain.cpp:23: error: ambiguous overload for \u2018operator=\u2019 in \u2018s = t\u2019\n/usr/include/c++/4.2.1/bits/basic_string.h:500: note: candidates are: std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; std::basic_string&lt;_CharT, _Traits, _Alloc&gt;::operator=(const std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;, _Alloc = std::allocator&lt;char&gt;]\n/usr/include/c++/4.2.1/bits/basic_string.h:508: note:                 std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; std::basic_string&lt;_CharT, _Traits, _Alloc&gt;::operator=(const _CharT*) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;, _Alloc = std::allocator&lt;char&gt;]\n/usr/include/c++/4.2.1/bits/basic_string.h:519: note:                 std::basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp; std::basic_string&lt;_CharT, _Traits, _Alloc&gt;::operator=(_CharT) [with _CharT = char, _Traits = std::char_traits&lt;char&gt;, _Alloc = std::allocator&lt;char&gt;]\n</code></pre>\n<p>If I do not attempt the assignment </p>\n<pre><code>s = t;\n</code></pre>\n<p>it does work.</p>\n<p>I've been trying for hours to even comprehend the error message, but what's puzzling me most is that is does work for char*.</p>\n<p>I'm grateful for any hint.\nThanks!\nMarkus</p>\n", "Tags": "<c++><overloading><operator-keyword>", "OwnerUserId": "2088446", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_3518145_3518343_0": {"section_id": 595, "quality": 0.8823529411764706, "length": 45}, "so_3518145_3518343_1": {"section_id": 619, "quality": 0.8181818181818182, "length": 18}, "so_3518145_3518343_2": {"section_id": 639, "quality": 1.0, "length": 26}}, "n3337": {"so_3518145_3518343_0": {"section_id": 585, "quality": 0.8823529411764706, "length": 45}, "so_3518145_3518343_1": {"section_id": 609, "quality": 0.8181818181818182, "length": 18}, "so_3518145_3518343_2": {"section_id": 629, "quality": 1.0, "length": 26}}, "n4659": {"so_3518145_3518343_0": {"section_id": 618, "quality": 0.8823529411764706, "length": 45}, "so_3518145_3518343_1": {"section_id": 645, "quality": 0.8181818181818182, "length": 18}, "so_3518145_3518343_2": {"section_id": 667, "quality": 1.0, "length": 26}}}, "3518979": {"ParentId": "3518145", "CommentCount": "2", "Body": "<p>Alright, thanks a lot already everyone. I think I am starting to get the hang of it, kind of...</p>\n<p>First of all I wasn't aware of the fact, that char is just an 8-bit int. Thanks for that clarification.</p>\n<p>So I understand that, because there are three assignment operators defined for std::string, each with different argument (string, char*, const char*) the right-hand-side of my expression</p>\n<pre><code>s=t\n</code></pre>\n<p>doesn't know, which type is has to convert into, since there are multiple, potentially matching (for this assignment to std::string) conversions defined with either</p>\n<pre><code>operator int ()  {return 77;};\noperator std::string  () {return \"hello\";};\n</code></pre>\n<p>(since char : 8bit int)</p>\n<p>or </p>\n<pre><code>operator char* () {return (char*)\"hi\";};\noperator std::string  () {return \"hello\";};\n</code></pre>\n<p>Is that right? So in idiots terms, the left-hand-side of the assignment isn't telling the right-hand-side which type it expects, so rhs has to choose from its options, where one is as good as some other? std::string operator= is being to tolerant for my intents?</p>\n<p>So far so good, I thought I got it - but then, why does the following create ambiguity as well?</p>\n<pre><code> using namespace std;\n #include &lt;string&gt;\n #include &lt;iostream&gt;\n\n class testClass\n  {\n   public:\n     operator float ()  {return float(77.333);};\n     operator std::string  () {return \"hello\";};\n  };\n\n  int main()\n  {\n    std::string s = \"goodday\";\n    testClass t;\n\n    s = t;\n\n    cout&lt;&lt; \" string: \"&lt;&lt;s &lt;&lt;endl;\n\n    return 0;\n  }\n</code></pre>\n<p>Now there is only one matching conversion operator defined by me, right?\nstd::string operator= cannot take floats, or can it? Or is float in some way equivalent to some variant of char again?</p>\n<p>I understand the code as 's=' telling the rhs: \"give me a string, char* or const char*\"</p>\n<p>Rhs checks what it can provide given an instance of testClass, and the only match is testClass::operator std::string</p>\n<p>Again, thanks for your patience, expertise and time guys - I really appreciate it.</p>\n", "OwnerUserId": "2088446", "PostTypeId": "2", "Id": "3518979", "Score": "0", "CreationDate": "2010-08-19T05:30:17.040", "LastActivityDate": "2010-08-19T05:30:17.040"}});