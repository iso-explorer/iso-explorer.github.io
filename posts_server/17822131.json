post_cb({"bq_ids": {"n4140": {"so_17822131_17822241_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6070}, "so_17822131_17822241_2": {"length": 38, "quality": 0.95, "section_id": 5965}, "so_17822131_17822241_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 5962}}, "n3337": {"so_17822131_17822241_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 5838}, "so_17822131_17822241_2": {"length": 38, "quality": 0.95, "section_id": 5734}, "so_17822131_17822241_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 5731}}, "n4659": {"so_17822131_17822241_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 7566}, "so_17822131_17822241_2": {"length": 34, "quality": 0.85, "section_id": 7456}, "so_17822131_17822241_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 7451}}}, "17822241": {"Id": "17822241", "PostTypeId": "2", "Body": "<p>The <code>+</code> in the expression <code>+[](){}</code> is the unary <code>+</code> operator. It is defined as follows in \n[expr.unary.op]/7:</p>\n<blockquote>\n<p id=\"so_17822131_17822241_0\">The operand of the unary <code>+</code> operator shall have arithmetic, unscoped enumeration, or pointer type and the result is the value of the argument.</p>\n</blockquote>\n<p>The lambda is not of arithmetic type etc., but it can be converted:</p>\n<p>[expr.prim.lambda]/3</p>\n<blockquote>\n<p id=\"so_17822131_17822241_1\">The type of the <em>lambda-expression</em> [...] is a unique, unnamed non-union class type \u2014 called the <em>closure type</em> \u2014 whose properties are described below.</p>\n</blockquote>\n<p>[expr.prim.lambda]/6</p>\n<blockquote>\n<p id=\"so_17822131_17822241_2\">The closure type for a <em>lambda-expression</em> with no <em>lambda-capture</em> has a <code>public</code> non-<code>virtual</code> non-<code>explicit</code> <code>const</code> conversion function to <em>pointer to function</em> having the same parameter and return types as the closure type's function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>Therefore, the unary <code>+</code> forces the conversion to the function pointer type, which is for this lambda <code>void (*)()</code>. Therefore, the type of the expression <code>+[](){}</code> is this function pointer type <code>void (*)()</code>.</p>\n<p>The second overload <code>void foo(void (*f)())</code> becomes an Exact Match in the ranking for overload resolution and is therefore chosen unambiguously (as the first overload is NOT an Exact Match).</p>\n<hr>\n<p>The lambda <code>[](){}</code> can be converted to <code>std::function&lt;void()&gt;</code> via the non-explicit template ctor of <code>std::function</code>, which takes any type that fulfils the <code>Callable</code> and <code>CopyConstructible</code> requirements.</p>\n<p>The lambda can also be converted to <code>void (*)()</code> via the conversion function of the <em>closure type</em> (see above).</p>\n<p>Both are user-defined conversion sequences, and of the same rank. That's why overload resolution fails in the <em>first</em> example due to ambiguity.</p>\n<hr>\n<p>According to Cassio Neri, backed up by an argument by Daniel Kr\u00fcgler, this unary <code>+</code> trick should be specified behaviour, i.e. you can rely on it (see discussion in the comments).</p>\n<p>Still, I'd recommend using an explicit cast to the function pointer type if you want to avoid the ambiguity: you don't need to ask on SO what is does and why it works ;)</p>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-07-24T16:47:06.017", "Score": "66", "CreationDate": "2013-07-23T22:41:02.063", "ParentId": "17822131", "CommentCount": "10", "OwnerUserId": "420683", "LastEditDate": "2013-07-24T16:47:06.017"}, "17822131": {"ViewCount": "4143", "Body": "<p>In the following code, the first call to <code>foo</code> is ambiguous, and therefore fails to compile.</p>\n<p>The second, with the added <code>+</code> before the lambda, resolves to the function pointer overload.</p>\n<pre><code>#include &lt;functional&gt;\n\nvoid foo(std::function&lt;void()&gt; f) { f(); }\nvoid foo(void (*f)()) { f(); }\n\nint main ()\n{\n    foo(  [](){} ); // ambiguous\n    foo( +[](){} ); // not ambiguous (calls the function pointer overload)\n}\n</code></pre>\n<p>What is the <code>+</code> notation doing here?</p>\n", "AcceptedAnswerId": "17822241", "Title": "Resolving ambiguous overload on function pointer and std::function for a lambda using +", "CreationDate": "2013-07-23T22:31:32.483", "Id": "17822131", "CommentCount": "0", "FavoriteCount": "25", "PostTypeId": "1", "LastActivityDate": "2013-07-24T16:47:06.017", "Score": "62", "OwnerUserId": "955273", "Tags": "<c++11><lambda><overloading>", "AnswerCount": "1"}});