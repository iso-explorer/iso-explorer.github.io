post_cb({"25616693": {"CommentCount": "10", "ViewCount": "136", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-09-02T05:52:47.397", "LastActivityDate": "2014-09-02T06:23:06.520", "Title": "Why won't this compile in VS Express 2013, though it compiles in MinGW?", "AcceptedAnswerId": "25617043", "LastEditDate": "2017-05-23T11:57:15.460", "Id": "25616693", "Score": "3", "Body": "<p>Here's a compilable sample I stitched together from several header files. The code won't make sense because I gutted all the irrelevant parts, but the gist is that I'm implementing Scott Meyers' data proxy technique (mentioned <a href=\"https://stackoverflow.com/questions/7410559/c-overloading-operators-based-on-the-side-of-assignment/7411385#7411385\">here</a>), though it's evolved into more of a wrapper than a temporary proxy. None of that should matter though\u2014my question seems to be purely regarding a difference in compiler behaviors.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ntemplate&lt;typename T&gt;\nclass Proxy\n{\npublic:\n    enum class State\n    {\n        NEVER_SET = 0,\n        SET,\n        UNSET\n    };\n    operator const T&amp; () const\n    {\n        if ( _state != State::SET )\n        {\n            std::cout &lt;&lt; \"EXCEPTION\" &lt;&lt; std::endl;\n            // TODO throw exception\n        }\n        return _data;\n    }\n    Proxy&lt;T&gt;&amp; operator=(const T&amp; val)\n    {\n        _data = val;\n        _state = State::SET;\n        return (*this);\n    }\n    Proxy&lt;T&gt;&amp; operator+=(const T&amp; val)\n    {\n        _data = (*this) + val;\n        _state = State::SET;\n        return (*this);\n    }\nprivate:\n    T _data;\n    State _state = State::NEVER_SET;\n};\n\nclass Tape\n{\n};\n\ntemplate&lt;typename T&gt;\nclass tape : public Tape\n{\npublic:\n    const Proxy&lt;T&gt;&amp; operator[](int idx) const\n    {\n        return operator[](idx);\n    }\n    Proxy&lt;T&gt;&amp; operator[](int idx)\n    {\n        if ( idx &gt;= data.size() )\n        {\n            data.resize(idx + 1);\n        }\n        return data[idx];\n    }\nprivate:\n    std::vector&lt; Proxy&lt;T&gt; &gt; data;\n};\n\nclass CRIXUS\n{\npublic:\n    virtual void Go() final {};\nprotected:\n    virtual void Pre() {};\n    virtual void Post() {};\n    virtual void Step() = 0;\n};\n\nclass CRIXUS_MA : public CRIXUS\n{\npublic:\n    int window = 30;\n    tape&lt;double&gt; input;\n    tape&lt;double&gt; output;\nprotected:\n    virtual void Step()\n    {\n        double sum = 0;\n        for ( int j = 0; j &lt; window; j++ )\n        {\n            sum += input[-j];\n        }\n        output[0] = sum / window;\n    }\n};\n\nint main()\n{\n}\n</code></pre>\n<p>It compiles fine on <a href=\"http://ideone.com/EC8gwB\" rel=\"nofollow noreferrer\">Ideone</a> as well as via Jetbrain's CLion (Toolchain: MinGW 3.20, CMake 2.8.12.2):</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/gq7ma.png\"/></p>\n<p>However it won't compile on VS Express 2013:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/d8yhg.png\"/></p>\n<p>Running the full code from CLion (which involves reading a .csv file of numbers and outputting a moving average), I can verify that the output is correct. It's just that VS won't compile the code.</p>\n<p>As far as I can tell, the cast operator</p>\n<pre><code>    operator const T&amp; () const\n    {\n        if ( _state != State::SET )\n        {\n            std::cout &lt;&lt; \"EXCEPTION\" &lt;&lt; std::endl;\n            // TODO throw exception\n        }\n        return _data;\n    }\n</code></pre>\n<p>should convert the <code>Proxy&lt;T&gt;</code> to <code>T</code>, <em>i.e.</em> <code>Proxy&lt;double&gt;</code> to <code>double</code>. And when I forcibly cast the offending line,</p>\n<pre><code>        sum += (double)input[-j];\n</code></pre>\n<p>it works fine. Any ideas?</p>\n", "Tags": "<c++><compiler-errors><visual-studio-2013><mingw><visual-studio-express>", "OwnerUserId": "925913", "AnswerCount": "1"}, "25617043": {"ParentId": "25616693", "CommentCount": "2", "Body": "<p>This appears to be more MSVC template brokenness. It refuses to instantiate <code>Proxy&lt;double&gt;</code> in this code, causing overload resolution to fail. Simply adding a <code>Proxy&lt;double&gt; p;</code> right before the definition of <code>CRIXUS_MA</code>, which forces an implicit instantiation, is sufficient to make the code compile. According to \u00a714.7.1 [temp.inst]/p6:</p>\n<blockquote>\n<p id=\"so_25616693_25617043_0\">A class template specialization is implicitly instantiated if the\n  class type is used in a context that requires a completely-defined\n  object type or if the completeness of the class type might affect the\n  semantics of the program. [ <em>Note</em>: In particular, if the semantics of\n  an expression depend on the member or base class lists of a class\n  template specialization, the class template specialization is\n  implicitly generated. For instance, deleting a pointer to class type\n  depends on whether or not the class declares a destructor, and\n  conversion between pointer to class types depends on the inheritance\n  relationship between the two classes involved. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>Since the semantics of <code>sum += input[-j];</code> obviously depends on the definition of <code>Proxy&lt;double&gt;</code>, it should have been implicitly instantiated.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "25617043", "Score": "4", "CreationDate": "2014-09-02T06:23:06.520", "LastActivityDate": "2014-09-02T06:23:06.520"}, "bq_ids": {"n4140": {"so_25616693_25617043_0": {"section_id": 238, "quality": 0.9333333333333333, "length": 56}}, "n3337": {"so_25616693_25617043_0": {"section_id": 230, "quality": 0.9333333333333333, "length": 56}}, "n4659": {"so_25616693_25617043_0": {"section_id": 242, "quality": 0.8333333333333334, "length": 50}}}});