post_cb({"12690678": {"ParentId": "12690413", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Think about the XOR truth table, try it out, does it even matter?</p>\n<pre><code>x | y | XOR\n-----------\n0 | 0 |  0\n1 | 0 |  1\n0 | 1 |  1\n1 | 1 |  0\n</code></pre>\n<p>So if you had say <code>b = 10; //1010</code> and <code>c = 7; //0111</code> and <code>a = 3; //0011</code></p>\n<pre><code>b ^ c =     1010 ^ 0111 = 1101 \na ^ (b^c) = 0011 ^ 1101 = 1110 (14)\n\n\na ^ b =     0011 ^ 1010 = 1001\n(a^b) ^c =  1001 ^ 0111 = 1110 (14)\n</code></pre>\n<p>Given your specific example, assuming no operator-overloading, and only using the associative XOR operator... it doesn't really matter. </p>\n<p>Being a little less specific\n<code>^=</code> is applied first, so:</p>\n<p><code>a ^= b^c</code> is equivalent to <code>a = a ^ (b^c)</code></p>\n", "OwnerUserId": "1348709", "LastEditorUserId": "1348709", "LastEditDate": "2012-10-02T13:07:44.193", "Id": "12690678", "Score": "2", "CreationDate": "2012-10-02T12:55:20.427", "LastActivityDate": "2012-10-02T13:07:44.193"}, "12690984": {"ParentId": "12690413", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>\"C and C++\" covers a lot of ground, but taking one example, the C99 standard says (6.5.16.2):</p>\n<blockquote>\n<p id=\"so_12690413_12690984_0\">A compound assignment of the form <code>E1 op= E2</code> differs from the simple\n  assignment expression <code>E1 = E1 op (E2)</code> only in that the lvalue <code>E1</code> is\n  evaluated only once.</p>\n</blockquote>\n<p>In C++, operator overloading means that the first expression might be equivalent to neither of the other two depending on the types of the operands. But for built-in compound operators the same rule applies. C++03 says (5.17/7):</p>\n<blockquote>\n<p id=\"so_12690413_12690984_1\">The behavior of an expression of the form <code>E1 op=  E2</code> is equivalent to\n  <code>E1  =  E1 op E2</code> except that <code>E1</code> is evaluated only once.</p>\n</blockquote>\n<p>Note that only the C standard bothers to include the necessary parentheses to directly answer your question: it's nominally <code>a ^ (b ^ c)</code> rather than <code>(a ^ b) ^ c</code>.</p>\n<p>But I think we can assume that in the ad hoc BNF-like grammatical language that the C++ standard is using here, a BNF-non-terminal such as <code>E2</code> is always considered to be a subexpression of the expression it appears in. So in a case with left-to-right associativity (and all of the operators with compound-assignment version associate left-to-right), which would split <code>E2</code> such that it's no longer a sub-expression, we must mentally insert enough parentheses to prevent that.</p>\n<p>In practice it's not going to matter for XOR, since the values are the same anyway <em>unless</em> you generate a trap representation along the way, and that causes a fault. This could happen on a non-2's-complement implementation of C or C++, and an implementation for which that's the case could <em>not</em> compute <code>a ^= b^c</code> as <code>a = (a^b)^c</code> even if it wanted to. Non-2's-complement implementations are approximately non-existent, but the standard permits them.</p>\n<p>Importantly, <code>a -= b - c</code> is <em>not</em> equivalent to <code>a = (a - b) - c</code> in the case where <code>a</code>, <code>b</code>, <code>c</code> are integers. Unless <code>c</code> is equal to <code>0</code>.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2012-10-02T13:31:49.490", "Id": "12690984", "Score": "3", "CreationDate": "2012-10-02T13:15:02.793", "LastActivityDate": "2012-10-02T13:31:49.490"}, "12690507": {"ParentId": "12690413", "CommentCount": "2", "Body": "<p>There is no operator precedence here. Your question is about associativity, and as the operator is associative it doesn't make any difference.</p>\n", "OwnerUserId": "207421", "PostTypeId": "2", "Id": "12690507", "Score": "1", "CreationDate": "2012-10-02T12:45:21.653", "LastActivityDate": "2012-10-02T12:45:21.653"}, "12690413": {"CommentCount": "4", "ViewCount": "298", "PostTypeId": "1", "LastEditorUserId": "555045", "CreationDate": "2012-10-02T12:38:56.130", "LastActivityDate": "2012-10-02T15:28:21.630", "Title": "C++ XOR operator precendence", "LastEditDate": "2012-10-02T12:53:41.427", "Id": "12690413", "Score": "-7", "Body": "<p>So I am confused here, does : \n is </p>\n<pre><code> a ^= b^c \n</code></pre>\n<p>equivalent to </p>\n<pre><code> a = a ^ (b ^ c) \n</code></pre>\n<p>or is it <code>a = (a ^ b) ^ c</code>?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "1714315", "AnswerCount": "4"}, "12690438": {"ParentId": "12690413", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Any short form operator:</p>\n<pre><code>LHS OP= RHS;\n</code></pre>\n<p>works very much like:</p>\n<pre><code>LHS = LHS OP RHS;\n</code></pre>\n<p>As pointed out in comments, there are differences with the number of evaluations done and so on, so if you start to have side-effects in the evaluation of <code>LHS</code>, this simple equivalence is not so simple anymore. Or equivalent. Which is why I've re-worded the above to make it less iron-clad.</p>\n<p>So it's the former, i.e. <code>a = a ^ (b ^ c)</code>.</p>\n", "OwnerUserId": "28169", "LastEditorUserId": "28169", "LastEditDate": "2012-10-02T15:28:21.630", "Id": "12690438", "Score": "5", "CreationDate": "2012-10-02T12:40:27.993", "LastActivityDate": "2012-10-02T15:28:21.630"}, "bq_ids": {"n4140": {"so_12690413_12690984_1": {"section_id": 6179, "quality": 0.875, "length": 7}}, "n3337": {"so_12690413_12690984_1": {"section_id": 5940, "quality": 0.875, "length": 7}}, "n4659": {"so_12690413_12690984_1": {"section_id": 7681, "quality": 0.875, "length": 7}}}});