post_cb({"bq_ids": {"n4140": {"so_30645436_30645436_4": {"length": 29, "quality": 0.9354838709677419, "section_id": 5943}, "so_30645436_30645436_1": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}}, "n3337": {"so_30645436_30645436_4": {"length": 29, "quality": 0.9354838709677419, "section_id": 5714}, "so_30645436_30645436_1": {"length": 38, "quality": 0.9743589743589743, "section_id": 18}}, "n4659": {"so_30645436_30645436_4": {"length": 29, "quality": 0.9354838709677419, "section_id": 7428}, "so_30645436_30645436_1": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}}}, "30654122": {"Id": "30654122", "PostTypeId": "2", "Body": "<p>It is perfectly legitimate, and at one time was extremely commonplace, for <code>short</code> and <code>int</code> to have identical ranges and representations; even in today it's not uncommon for embedded systems to use the same 16-bit representation for both.  The C specification does contain some language which is specific to such implementations, since on such platforms <code>unsigned short</code> promotes to <code>unsigned int</code> whereas it promotes to <code>signed int</code> on platforms where the latter type can represent all values of <code>unsigned short</code>.  It does not exempt such implementations from the rule requiring that types smaller than <code>int</code> or <code>unsigned int</code> be promoted to one of those because nothing would be gained from such an exemption.</p>\n<p>The standard allows that an implementation may perform computations in any fashion it sees fit if, in all cases where the indicated promotions to <code>int</code> or <code>unsigned int</code> would yield defined behavior, the implementations' computations yield that same behavior (the <em>as-if</em> rule).  If the behaviors of rvalues of types <code>int</code> and <code>short</code> would be indistinguishable, that would imply that an implementation could perform computations on <code>short</code> rather than <code>int</code> if it chose to do so.  There's no need to add a rule to the standard exempting <code>int</code>-sized <code>short</code> types from promotion since the as-if rule is already adequate.</p>\n", "LastActivityDate": "2015-06-04T21:04:20.587", "Score": "2", "CreationDate": "2015-06-04T21:04:20.587", "ParentId": "30645436", "CommentCount": "3", "OwnerUserId": "363751"}, "30645436": {"ViewCount": "94", "Body": "<h3>Background</h3>\n<p>I'm looking into integer promotion rules in C++, and came across the following (taken from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">n4296</a>):</p>\n<blockquote>\n<p id=\"so_30645436_30645436_0\"><strong>4.5.1 [pconv.prom]</strong></p>\n<p id=\"so_30645436_30645436_1\">A prvalue of an integer type other than <code>bool</code>, <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> whose integer conversion rank (4.13) is less than the rank of <code>int</code> can be converted to a prvalue of type <code>int</code> if <code>int</code> can represent all the values of the source type;\n  otherwise, the source prvalue can be converted to a prvalue of type\n  <code>unsigned int</code>.</p>\n</blockquote>\n<p>\u00a0</p>\n<blockquote>\n<p id=\"so_30645436_30645436_2\"><strong>4.13.1.3 [conv.rank]</strong></p>\n<ul>\n<li>The rank of <code>long long int</code> shall be greater than the rank of <code>long int</code>, which shall be greater than the rank of <code>int</code>, which\n  shall be greater than the rank of <code>short int</code>, which shall be greater\n  than the rank of <code>signed char</code>.</li>\n</ul>\n</blockquote>\n<p>\u00a0</p>\n<blockquote>\n<p id=\"so_30645436_30645436_3\"><strong>5.10 [expr]</strong></p>\n<p id=\"so_30645436_30645436_4\">Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result\n  types in a similar way. The purpose is to yield a common type, which\n  is also the type of the result. This pattern is called the usual\n  arithmetic conversions , which are defined as follows:</p>\n<p id=\"so_30645436_30645436_5\"><em>[many points omitted]</em></p>\n<ul>\n<li>Otherwise, the integral promotions (4.5) shall be performed on both operands.</li>\n</ul>\n<p id=\"so_30645436_30645436_6\"><em>[further omissions]</em></p>\n</blockquote>\n<h3>Question</h3>\n<p>Given that both the size and range of <code>short int</code> may be equal to that of <code>int</code>, it seems unecessary to promote a <code>short int</code> to an <code>int</code> in those circumstances. Yet, the above makes no mention of such an exception.</p>\n<p>Does the standard require that <code>short int</code> is promoted to <code>int</code> in these circumstances (even if implementation optimisations presult in the same executable being produced)?</p>\n<h3>Note / additional question</h3>\n<p>I've also noticed that the wording uses \"can be\" rather than \"shall be\", is this intentional?</p>\n", "AcceptedAnswerId": "30654122", "Title": "Integer promotion for implementations where sizeof(short) == sizeof(int)", "CreationDate": "2015-06-04T13:42:21.463", "Id": "30645436", "CommentCount": "12", "LastEditDate": "2015-06-05T13:00:43.453", "PostTypeId": "1", "LastEditorUserId": "584518", "LastActivityDate": "2015-06-05T13:00:43.453", "Score": "1", "OwnerUserId": "1816262", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}});