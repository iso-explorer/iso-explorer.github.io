post_cb({"13431912": {"Id": "13431912", "PostTypeId": "2", "Body": "<p>I think there is a misinterpretation about the scope of what <em>copy constructor</em> means.</p>\n<p>A copy constructor is not responsible for allocating the memory where the object itself will be built, this is provided externally, by the caller.</p>\n<p>The requirement, therefore, is that the <strong>body</strong> of the copy constructor (be it written or generated) does not throw. It is known in C++ that built-in types (<code>int</code>, <code>T*</code>, ...) can be copied without throwing, and from there one can built types that are thus copyable without throwing exceptions (as long as one avoids dynamic resource allocation and/or IO it's automatic).</p>\n", "LastActivityDate": "2012-11-17T15:19:11.917", "CommentCount": "1", "CreationDate": "2012-11-17T15:19:11.917", "ParentId": "13428851", "Score": "0", "OwnerUserId": "147192"}, "13430036": {"Id": "13430036", "PostTypeId": "2", "Body": "<p>That paragraph talks about the iterators used by the containers in the standard library. These iterators are known to be implementable in ways so that they don't throw exception while being copied. For example, none of them have to use any dynamically allocated memory.</p>\n<p>The guarantee is just for these iterators, not for iterators in general (even though it is a good idea to follow the example).</p>\n", "LastActivityDate": "2012-11-17T11:17:29.887", "CommentCount": "0", "CreationDate": "2012-11-17T11:17:29.887", "ParentId": "13428851", "Score": "1", "OwnerUserId": "597607"}, "13428851": {"ViewCount": "158", "Body": "<p>Clause 23.2.1.10 of C++11 standard says that</p>\n<blockquote>\n<p id=\"so_13428851_13428851_0\">\"no copy ctor of a returned iterator throws an exception\"</p>\n</blockquote>\n<p>Does this basically state that is it possible for a copy ctor of an iterator not to throw even a bad_alloc presumably (leaving the case where iterator could be just a pointer and here no issues) because it will use the information already constructed in the \"returned iterator\"? because it is passed by value will the stack be allocated in the called function hence can <strong>guarantee</strong> no memory issues ?</p>\n", "AcceptedAnswerId": "13430036", "Title": "How can an implementation guarantee that copy constructor of an iterator is no throw?", "CreationDate": "2012-11-17T08:09:05.647", "Id": "13428851", "CommentCount": "9", "LastEditDate": "2012-11-17T10:05:55.097", "PostTypeId": "1", "LastEditorUserId": "774499", "LastActivityDate": "2012-11-17T15:19:11.917", "Score": "4", "OwnerUserId": "1831533", "Tags": "<c++><exception-safety>", "AnswerCount": "3"}, "13429122": {"Id": "13429122", "PostTypeId": "2", "Body": "<p>Legal answer: no. Thtat's just your interpretation. It is technically correct, but it may be not the one and only technically correct interpretation. </p>\n<p>Technical answer: The point, here, is avoid that an exception thrown by a mutating iterator (think to an inserter or to an output iterator) causes an algorithm to be abandoned while letting a container in an undefined and inconsistent state (think, for example, to a linked list with the links not yet completely re-linked)</p>\n<p>It's not just a matter of bad_alloc for iterators that have a dynamically allocated state, but also of an iterator that -during it's own copy- tries to modify a referred item failing in that (for example, because the item assignment throws).</p>\n<p>When such a case happens, the iterator is not required to \"complete the algorithm\" (that would be impossible) but to left the container in a consistent and still manageable state.</p>\n", "LastActivityDate": "2012-11-17T08:56:57.893", "CommentCount": "0", "CreationDate": "2012-11-17T08:56:57.893", "ParentId": "13428851", "Score": "1", "OwnerUserId": "924727"}, "bq_ids": {"n4140": {"so_13428851_13428851_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 712}}, "n3337": {"so_13428851_13428851_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 701}}, "n4659": {"so_13428851_13428851_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 741}}}});