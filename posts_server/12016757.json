post_cb({"12016897": {"ParentId": "12016757", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_12016757_12016897_0\">Why is x deduced to be a pointer when string literals are actually arrays?</p>\n</blockquote>\n<p>Because of array-to-pointer conversion.</p>\n<p>If <code>x</code> is to be deduced as array, only if the following is allowed:</p>\n<pre><code>const char m[]          = \"ABC\";\n\nconst char n[sizeof(m)] = m; //error\n</code></pre>\n<p>In C++, an arrray cannot be initialized with another array (like above). In such cases, the source array decays into pointer type, and you're allowed to do this instead:</p>\n<pre><code>const char* n = m; //ok\n</code></pre>\n<p>The rules for type-inference with <code>auto</code> is same as the rules of type-deduction in function template:</p>\n<pre><code>template&lt;typename T&gt;\nvoid f(T n);\n\nf(m);     //T is deduced as const char*\nf(\"ABC\"); //T is deduced as const char*\n\nauto n = m;     //n's type is inferred as const char*\nauto n = \"ABC\"; //n's type is inferred as const char*\n</code></pre>\n<p>\u00a77.1.6.4/6  says about <code>auto</code> specifier:</p>\n<blockquote>\n<p id=\"so_12016757_12016897_1\">The type deduced for the variable d is then the deduced A determined using the rules of template argument deduction from a function call (14.8.2.1) ...</p>\n</blockquote>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2012-08-18T08:20:24.000", "Id": "12016897", "Score": "4", "CreationDate": "2012-08-18T07:49:26.780", "LastActivityDate": "2012-08-18T08:20:24.000"}, "12017022": {"ParentId": "12016757", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The feature <code>auto</code> is based on template argument deduction and template argument deduction behaves the same, specifically according to \u00a714.8.2.1/2 (C++11 standard):</p>\n<ul>\n<li>If P is not a reference type\n<ul>\n<li>If A is an array type, the pointer type produced by the array-to-pointer conversion is used in place of A for type deduction</li>\n</ul></li>\n</ul>\n<p>If you want the type of the expression <code>x</code> to be an array type, just add <code>&amp;</code> after <code>auto</code>:</p>\n<pre><code>auto&amp; x = \"Hello world!\";\n</code></pre>\n<p>Then, the <code>auto</code> placeholder will be deduced to be <code>const char[13]</code>. This is also similar to function templates taking a reference as parameter. Just to avoid any confusion: The declared type of x will be <em>reference</em>-to-array.</p>\n", "OwnerUserId": "172531", "LastEditorUserId": "172531", "LastEditDate": "2012-08-18T08:34:08.553", "Id": "12017022", "Score": "20", "CreationDate": "2012-08-18T08:09:01.480", "LastActivityDate": "2012-08-18T08:34:08.553"}, "bq_ids": {"n4140": {"so_12016757_12016897_1": {"section_id": 5451, "quality": 0.8, "length": 12}, "so_12016757_12016757_0": {"section_id": 5356, "quality": 0.6363636363636364, "length": 7}}, "n3337": {"so_12016757_12016897_1": {"section_id": 5245, "quality": 0.8666666666666667, "length": 13}, "so_12016757_12016757_0": {"section_id": 5153, "quality": 0.6363636363636364, "length": 7}}, "n4659": {"so_12016757_12016897_1": {"section_id": 6889, "quality": 0.6, "length": 9}, "so_12016757_12016757_0": {"section_id": 6781, "quality": 0.6363636363636364, "length": 7}}}, "12016757": {"CommentCount": "1", "AcceptedAnswerId": "12017022", "CreationDate": "2012-08-18T07:25:44.670", "LastActivityDate": "2012-08-18T08:52:26.337", "PostTypeId": "1", "ViewCount": "2480", "FavoriteCount": "4", "Title": "auto with string literals", "Id": "12016757", "Score": "15", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nint main()\n{\n    const char a[] = \"hello world\";\n    const char * p = \"hello world\";\n    auto x = \"hello world\";\n\n    if (typeid(x) == typeid(a))\n        std::cout &lt;&lt; \"It's an array!\\n\";\n\n    else if (typeid(x) == typeid(p))\n        std::cout &lt;&lt; \"It's a pointer!\\n\";   // this is printed\n\n    else\n        std::cout &lt;&lt; \"It's Superman!\\n\";\n}\n</code></pre>\n<p>Why is <code>x</code> deduced to be a pointer when string literals are actually arrays?</p>\n<blockquote>\n<p id=\"so_12016757_12016757_0\">A narrow string literal has type \"array of <em>n</em> <code>const char</code>\" [2.14.5 String Literals [lex.string] \u00a78]</p>\n</blockquote>\n", "Tags": "<c++><c++11><type-inference><auto><string-literals>", "OwnerUserId": "252000", "AnswerCount": "2"}});