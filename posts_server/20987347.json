post_cb({"20987347": {"CommentCount": "2", "ViewCount": "239", "PostTypeId": "1", "LastEditorUserId": "531954", "CreationDate": "2014-01-08T04:56:33.810", "LastActivityDate": "2014-02-06T07:50:26.257", "Title": "Why the common template method definition doesn't match the template class specialization?", "FavoriteCount": "1", "LastEditDate": "2014-02-06T07:50:26.257", "Id": "20987347", "Score": "7", "Body": "<p>I have the following code:</p>\n<pre><code>template &lt;class T, class U = T&gt;\nclass A {\n  public:\n    void f();\n};\n\ntemplate &lt;class T&gt;\nclass A&lt;T, T&gt; {\n  public:\n    void f();  // Unaltered method.\n\n    // Some differences.\n};\n\ntemplate &lt;class T, class U&gt;\nvoid A&lt;T, U&gt;::f() {}\n\nint main() {\n  A&lt;int&gt; a;\n  a.f();\n  return 0;\n}\n</code></pre>\n<p>The <code>clang++ -std=c++11 test.cc</code> gives me an error: <code>undefined reference to 'A&lt;int, int&gt;::f()'</code></p>\n<p>Why the provided definition of method <code>f()</code> doesn't apply to the class <code>A&lt;int, int&gt;</code>?</p>\n", "Tags": "<c++><templates><c++11>", "OwnerUserId": "377393", "AnswerCount": "2"}, "20987751": {"ParentId": "20987347", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The primary class template <code>template &lt;class T, class U = T&gt; class A</code> and the partial specialization <code>template &lt;class T&gt; class A&lt;T, T&gt;</code> are two distinct template definitions. After they've been defined, whenever you refer to the class template name <code>A</code>, the primary template and all partial specializations will always be considered.</p>\n<p>Whenever you instantiate <code>A</code> with either a single template argument, or two arguments of the same type, it'll form a better match for the specialization you've provided, and the primary template is not considered.</p>\n<p>In your example, because of the partial specialization you've provided, there's no way to match the primary template, regardless of the default template argument, if you try to instantiate <code>A</code> with a single template argument, or two of the same type.</p>\n<p>The solution, of course, is to provide the definition for <code>A&lt;T, T&gt;::f()</code></p>\n<pre><code>template &lt;class T&gt;\nvoid A&lt;T, T&gt;::f() {}\n</code></pre>\n<p>EDIT:<br/>In the presence of partial specializations, the rules for matching them are given by (from N3797) <em>\u00a714.5.5.1/1 [temp.class.spec.match]</em></p>\n<blockquote>\n<p id=\"so_20987347_20987751_0\">When a class template is used in a context that requires an\n  instantiation of the class, it is necessary to determine whether the\n  instantiation is to be generated using the primary template or one of\n  the partial specializations. This is done by matching the template\n  arguments of the class template specialization with the template\n  argument lists of the partial specializations.\n  <br/>    \u2014 If exactly one matching specialization is found, the instantiation is generated from that specialization.\n  <br/>    \u2014 If more than one matching specialization is found, the partial order rules (14.5.5.2) are used to determine whether one of the\n  specializations is more specialized than the others. ...\n  <br/>    \u2014 If no matches are found, the instantiation is generated from the primary template.</p>\n</blockquote>\n<p>In your example the first rule applies, and the compiler doesn't even get to the 3rd rule.</p>\n", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2014-01-08T06:03:03.627", "Id": "20987751", "Score": "6", "CreationDate": "2014-01-08T05:34:30.687", "LastActivityDate": "2014-01-08T06:03:03.627"}, "bq_ids": {"n4140": {"so_20987347_20987751_0": {"section_id": 143, "quality": 0.9682539682539683, "length": 61}}, "n3337": {"so_20987347_20987751_0": {"section_id": 137, "quality": 0.9682539682539683, "length": 61}}, "n4659": {"so_20987347_20987751_0": {"section_id": 147, "quality": 0.9682539682539683, "length": 61}}}, "20997864": {"ParentId": "20987347", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>When you define a member function of a class template outside the class, you are just defining the function for the corresponding function that was declared in the class template.  You are not creating a new function template which might match other parameters.  In your example:</p>\n<pre><code>template &lt;class T, class U = T&gt;\nclass A {\n  public:\n    void f(); // This is the declaration of A&lt;T,U&gt;::f()\n};\n\ntemplate &lt;class T&gt;\nclass A&lt;T, T&gt; {\n  public:\n    void f();  // This is the declaration of A&lt;T,T&gt;::f()\n};\n\ntemplate &lt;class T, class U&gt;\nvoid A&lt;T, U&gt;::f() {} // This is the definition of A&lt;T,U&gt;::f()\n\n// There is no definition of A&lt;T,T&gt;::f()\n</code></pre>\n<p>I believe what you are thinking is that the compiler will see that you are calling <code>A&lt;int,int&gt;::f()</code> and will look through the member function definitions and find one that matches, but this is not what happens.  The compiler always looks through the class templates to find which function to call, and once it has found a match, it then looks for the corresponding definition.  In your case, you are calling <code>A&lt;int,int&gt;::f()</code>, so it first looks for a class definition that matches <code>A&lt;int,int&gt;</code> and it finds your <code>A&lt;T,T&gt;</code> class template specialization.  It sees that <code>A&lt;T,T&gt;</code> does indeed have a member function called <code>f</code> which matches your function call, which means <code>A&lt;T,T&gt;::f()</code> needs to be instantiated.  To instantiate <code>A&lt;T,T&gt;::f()</code>, the compiler looks for the definition of <code>A&lt;T,T&gt;::f()</code>, however it doesn't find it.  It only finds the definition of <code>A&lt;T,U&gt;::f</code>, which isn't a match.  The template parameter matching that is used to find a proper function declaration doesn't apply.</p>\n", "OwnerUserId": "951890", "LastEditorUserId": "951890", "LastEditDate": "2014-01-08T14:23:52.967", "Id": "20997864", "Score": "1", "CreationDate": "2014-01-08T14:04:17.827", "LastActivityDate": "2014-01-08T14:23:52.967"}});