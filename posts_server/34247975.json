post_cb({"bq_ids": {"n4140": {"so_34247975_34248633_14": {"length": 15, "quality": 0.7142857142857143, "section_id": 7049}, "so_34247975_34248633_5": {"length": 51, "quality": 0.7611940298507462, "section_id": 7047}, "so_34247975_34248633_24": {"length": 41, "quality": 0.5857142857142857, "section_id": 5481}, "so_34247975_34248633_9": {"length": 21, "quality": 0.6363636363636364, "section_id": 7035}, "so_34247975_34248633_16": {"length": 14, "quality": 0.875, "section_id": 7049}, "so_34247975_34248633_7": {"length": 44, "quality": 0.6567164179104478, "section_id": 7034}, "so_34247975_34249649_1": {"length": 8, "quality": 1.0, "section_id": 3194}, "so_34247975_34248633_1": {"length": 52, "quality": 0.8387096774193549, "section_id": 7067}, "so_34247975_34248633_15": {"length": 7, "quality": 0.7777777777777778, "section_id": 7049}, "so_34247975_34248633_23": {"length": 61, "quality": 0.5648148148148148, "section_id": 5480}, "so_34247975_34247975_1": {"length": 14, "quality": 0.875, "section_id": 7049}, "so_34247975_34248633_22": {"length": 25, "quality": 0.8333333333333334, "section_id": 5478}, "so_34247975_34249649_4": {"length": 28, "quality": 0.7, "section_id": 5471}, "so_34247975_34249649_3": {"length": 52, "quality": 0.9122807017543859, "section_id": 7067}, "so_34247975_34247975_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 7067}, "so_34247975_34248633_10": {"length": 10, "quality": 0.5555555555555556, "section_id": 7034}, "so_34247975_34248633_3": {"length": 67, "quality": 0.8375, "section_id": 7044}, "so_34247975_34248633_6": {"length": 38, "quality": 0.9047619047619048, "section_id": 7033}}, "n3337": {"so_34247975_34248633_16": {"length": 14, "quality": 0.875, "section_id": 6794}, "so_34247975_34248633_14": {"length": 15, "quality": 0.7142857142857143, "section_id": 6794}, "so_34247975_34248633_5": {"length": 51, "quality": 0.7611940298507462, "section_id": 6792}, "so_34247975_34248633_22": {"length": 25, "quality": 0.8333333333333334, "section_id": 5264}, "so_34247975_34248633_9": {"length": 21, "quality": 0.6363636363636364, "section_id": 6781}, "so_34247975_34247975_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 6811}, "so_34247975_34248633_7": {"length": 44, "quality": 0.6567164179104478, "section_id": 6780}, "so_34247975_34247975_1": {"length": 14, "quality": 0.875, "section_id": 6794}, "so_34247975_34248633_1": {"length": 52, "quality": 0.8387096774193549, "section_id": 6811}, "so_34247975_34248633_15": {"length": 7, "quality": 0.7777777777777778, "section_id": 6794}, "so_34247975_34248633_23": {"length": 61, "quality": 0.5648148148148148, "section_id": 5266}, "so_34247975_34248633_3": {"length": 67, "quality": 0.8375, "section_id": 6789}, "so_34247975_34248633_24": {"length": 41, "quality": 0.5857142857142857, "section_id": 5267}, "so_34247975_34249649_4": {"length": 28, "quality": 0.7, "section_id": 5257}, "so_34247975_34249649_3": {"length": 52, "quality": 0.9122807017543859, "section_id": 6811}, "so_34247975_34248633_10": {"length": 10, "quality": 0.5555555555555556, "section_id": 6780}, "so_34247975_34248633_6": {"length": 38, "quality": 0.9047619047619048, "section_id": 6779}, "so_34247975_34249649_1": {"length": 8, "quality": 1.0, "section_id": 3068}}, "n4659": {"so_34247975_34248633_14": {"length": 15, "quality": 0.7142857142857143, "section_id": 8546}, "so_34247975_34248633_5": {"length": 51, "quality": 0.7611940298507462, "section_id": 8544}, "so_34247975_34248633_9": {"length": 20, "quality": 0.6060606060606061, "section_id": 8532}, "so_34247975_34248633_22": {"length": 25, "quality": 0.8333333333333334, "section_id": 6911}, "so_34247975_34248633_16": {"length": 14, "quality": 0.875, "section_id": 8546}, "so_34247975_34249649_5": {"length": 26, "quality": 0.5098039215686274, "section_id": 6909}, "so_34247975_34248633_7": {"length": 52, "quality": 0.7761194029850746, "section_id": 8531}, "so_34247975_34247975_1": {"length": 14, "quality": 0.875, "section_id": 8546}, "so_34247975_34248633_1": {"length": 52, "quality": 0.8387096774193549, "section_id": 8564}, "so_34247975_34248633_15": {"length": 7, "quality": 0.7777777777777778, "section_id": 8546}, "so_34247975_34248633_23": {"length": 63, "quality": 0.5833333333333334, "section_id": 6914}, "so_34247975_34248633_3": {"length": 67, "quality": 0.8375, "section_id": 8541}, "so_34247975_34248633_24": {"length": 41, "quality": 0.5857142857142857, "section_id": 6915}, "so_34247975_34249649_4": {"length": 28, "quality": 0.7, "section_id": 6906}, "so_34247975_34249649_3": {"length": 52, "quality": 0.9122807017543859, "section_id": 8564}, "so_34247975_34248633_10": {"length": 10, "quality": 0.5555555555555556, "section_id": 8531}, "so_34247975_34248633_6": {"length": 38, "quality": 0.9047619047619048, "section_id": 8530}, "so_34247975_34249649_1": {"length": 8, "quality": 1.0, "section_id": 3956}}}, "34248633": {"Id": "34248633", "PostTypeId": "2", "Body": "<p>Based on your initial assumption:</p>\n<blockquote>\n<p id=\"so_34247975_34248633_0\">It seems that there is no clear definition over the point of\n  declaration, declarative region, scope of a namespace identifier,\n  except those of an identifier inside a namespace\u2014according to the\n  standard(\u00a73.3.6/1).</p>\n</blockquote>\n<p>I was reading this from the standard found at <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">open-std.org/pdf</a></p>\n<blockquote>\n<p id=\"so_34247975_34248633_1\">3.3.6 Namespace scope [basic.scope.namespace] 1 The declarative region of a namespace-definition is its namespace-body. Entities declared in\n  a namespace-body are said to be members of the namespace, and names\n  introduced by these declarations into the declarative region of the\n  namespace are said to be member names of the namespace. A namespace\n  member name has namespace scope. Its potential scope includes its\n  namespace from the name\u2019s point of declaration (3.3.2) onwards; and\n  for each using-directive (7.3.4) that nominates the member\u2019s\n  namespace, the member\u2019s potential scope includes that portion of the\n  potential scope of the using-directive that follows the member\u2019s point\n  of declaration. [ Example: </p>\n</blockquote>\n<pre><code>namespace N { \n    int i; \n    int g(int a) { return a; } \n    int j(); \n    void q(); \n} \n\nnamespace { int l=1; } \n// the potential scope of l is from its point of declaration \n// to the end of the translation unit \n\nnamespace N { \n    int g(char a) { // overloads N::g(int)\n        return l+a; // l is from unnamed namespace \n    } \n\n    int i; // error: duplicate definition \n    int j(); // OK: duplicate function declaration\n\n    int j() { // OK: definition of N::j() \n        return g(i); // calls N::g(int)\n    } \n    int q(); // error: different return type \n} \n</code></pre>\n<blockquote>\n<p id=\"so_34247975_34248633_2\">\u2014end example ]</p>\n</blockquote>\n<p>Which lead me to read the following sections:</p>\n<p><strong>3.3</strong></p>\n<blockquote>\n<p id=\"so_34247975_34248633_3\">3.3 Scope [basic.scope]\n  3.3.1 Declarative regions and scopes [basic.scope.declarative] 1 Every name is introduced in some portion of program text called a\n  declarative region, which is the largest part of the program in which\n  that name is valid, that is, in which that name may be used as an\n  unqualified name to refer to the same entity. In general, each\n  particular name is valid only within some possibly discontiguous\n  portion of program text called its scope. To determine the scope of a\n  declaration, it is sometimes convenient to refer to the potential\n  scope of a declaration. The scope of a declaration is the same as its\n  potential scope unless the potential scope contains another\n  declaration of the same name. In that case, the potential scope of the\n  declaration in the inner (contained) declarative region is excluded\n  from the scope of the declaration in the outer (containing)\n  declarative region.\n  2 [ Example: in</p>\n</blockquote>\n<pre><code>int j = 24;\nint main() {\n    int i = j, j;\n    j = 42;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_34247975_34248633_4\">the identifier j is declared twice as a name (and used twice). The\n  declarative region of the first j includes the entire example. The\n  potential scope of the first j begins immediately after that j and\n  extends to the end of the program, but its (actual) scope excludes the\n  text between the , and the }. The declarative region of the second\n  declaration of j (the j immediately before the semicolon) includes all\n  the text between { and }, but its potential scope excludes the\n  declaration of i. The scope of the second declaration of j is the same\n  as its potential scope. \u2014end example ] 3 The names declared by a\n  declaration are introduced into the scope in which the declaration\n  occurs, except that the presence of a friend specifier (11.3), certain\n  uses of the elaborated-type-specifier (7.1.6.3), and using-directives\n  (7.3.4) alter this general behavior. 4 Given a set of declarations in\n  a single declarative region, each of which specifies the same\n  unqualified name, (4.1) \u2014 they shall all refer to the same entity, or\n  all refer to functions and function templates; or (4.2) \u2014 exactly one\n  declaration shall declare a class name or enumeration name that is not\n  a typedef name and the other declarations shall all refer to the same\n  variable or enumerator, or all refer to functions and function\n  templates; in this case the class name or enumeration name is hidden\n  (3.3.10). [ Note: A namespace name or a class template name must be\n  unique in its declarative region (7.3.2, Clause 14). \u2014end note ] \u00a7\n  3.3.1 38</p>\n<p id=\"so_34247975_34248633_5\">c ISO/IEC N4527 [ Note: These restrictions apply to the declarative\n  region into which a name is introduced, which is not necessarily the\n  same as the region in which the declaration occurs. In particular,\n  elaborated-type-specifiers (7.1.6.3) and friend declarations (11.3)\n  may introduce a (possibly not visible) name into an enclosing\n  namespace; these restrictions apply to that region. Local extern\n  declarations (3.5) may introduce a name into the declarative region\n  where the declaration appears and also introduce a (possibly not\n  visible) name into an enclosing namespace; these restrictions apply to\n  both regions. \u2014end note ] 5 [ Note: The name lookup rules are\n  summarized in 3.4. \u2014end note ]</p>\n</blockquote>\n<p><strong>3.1</strong></p>\n<blockquote>\n<p id=\"so_34247975_34248633_6\">3.1 Declarations and definitions [basic.def] 1 A declaration (Clause 7) may introduce one or more names into a translation unit or\n  redeclare names introduced by previous declarations. If so, the\n  declaration specifies the interpretation and attributes of these\n  names. A declaration may also have effects including: (1.1) \u2014 a static\n  assertion (Clause 7), (1.2) \u2014 controlling template instantiation\n  (14.7.2), (1.3) \u2014 use of attributes (Clause 7), and (1.4) \u2014 nothing\n  (in the case of an empty-declaration). \u00a7 3.1 33</p>\n<p id=\"so_34247975_34248633_7\">c ISO/IEC N4527 2 A declaration is a definition unless it declares a\n  function without specifying the function\u2019s body (8.4), it contains the\n  extern specifier (7.1.1) or a linkage-specification25 (7.5) and\n  neither an initializer nor a functionbody, it declares a static data\n  member in a class definition (9.2, 9.4), it is a class name\n  declaration (9.1), it is an opaque-enum-declaration (7.2), it is a\n  template-parameter (14.1), it is a parameter-declaration (8.3.5) in a\n  function declarator that is not the declarator of a\n  function-definition, or it is a typedef declaration (7.1.3), an\n  alias-declaration (7.1.3), a using-declaration (7.3.3), a\n  static_assert-declaration (Clause 7), an attributedeclaration (Clause\n  7), an empty-declaration (Clause 7), a using-directive (7.3.4), an\n  explicit instantiation declaration (14.7.2), or an explicit\n  specialization (14.7.3) whose declaration is not a definition. [\n  Example: all but one of the following are definitions:</p>\n</blockquote>\n<pre><code>int a; // defines a\nextern const int c = 1; // defines c\nint f(int x) { return x+a; } // defines f and defines x\nstruct S { int a; int b; }; // defines S, S::a, and S::b\nstruct X { // defines X\n    int x; // defines non-static data member x\n    static int y; // declares static data member y\n    X(): x(0) { } // defines a constructor of X\n};\nint X::y = 1; // defines X::y\nenum { up, down }; // defines up and down\nnamespace N { int d; } // defines N and N::d\nnamespace N1 = N; // defines N1\nX anX; // defines anX\n</code></pre>\n<blockquote>\n<p id=\"so_34247975_34248633_8\">whereas these are just declarations:</p>\n</blockquote>\n<pre><code>extern int a; // declares a\nextern const int c; // declares c\nint f(int); // declares f\nstruct S; // declares S\ntypedef int Int; // declares Int\nextern X anotherX; // declares anotherX\nusing N::d; // declares d\n</code></pre>\n<blockquote>\n<p id=\"so_34247975_34248633_9\">\u2014end example ] 3 [ Note: In some circumstances, C++ implementations\n  implicitly define the default constructor (12.1), copy constructor\n  (12.8), move constructor (12.8), copy assignment operator (12.8), move\n  assignment operator (12.8), or destructor (12.4) member functions.\n  \u2014end note ] [ Example: given</p>\n</blockquote>\n<pre><code>#include &lt;string&gt;\n\nstruct C {\n    std::string s; // std::string is the standard library class (Clause 21)\n};\n\nint main() {\n    C a;\n    C b = a;\n    b = a;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_34247975_34248633_10\">the implementation will implicitly define functions to make the\n  definition of C equivalent to 25) Appearing inside the braced-enclosed\n  declaration-seq in a linkage-specification does not affect whether a\n  declaration is a definition. \u00a7 3.1 34</p>\n<p id=\"so_34247975_34248633_11\">c ISO/IEC N4527</p>\n</blockquote>\n<pre><code>struct C {\n    std::string s;\n    C() : s() { }\n    C(const C&amp; x): s(x.s) { }\n    C(C&amp;&amp; x): s(static_cast&lt;std::string&amp;&amp;&gt;(x.s)) { }\n        // : s(std::move(x.s)) { }\n    C&amp; operator=(const C&amp; x) { s = x.s; return *this; }\n    C&amp; operator=(C&amp;&amp; x) { s = static_cast&lt;std::string&amp;&amp;&gt;(x.s); return *this; }\n        // { s = std::move(x.s); return *this; }\n    ~C() { }\n};\n</code></pre>\n<blockquote>\n<p id=\"so_34247975_34248633_12\">\u2014end example ] 4 [ Note: A class name can also be implicitly declared\n  by an elaborated-type-specifier (7.1.6.3). \u2014end note ] 5 A program is\n  ill-formed if the definition of any object gives the object an\n  incomplete type (3.9).</p>\n</blockquote>\n<p>Then you precede to state:</p>\n<blockquote>\n<p id=\"so_34247975_34248633_13\">Although the standard indeed talks about those of a declaration\u2014a\n  namespace-definition is declaration, that is not applicable to the\n  case of namespace-definition because it has no declarator, nor\n  initializer\u2014according to the standard(\u00a73.3.2/1).</p>\n</blockquote>\n<p>Then I read this:</p>\n<blockquote>\n<p id=\"so_34247975_34248633_14\">3.3.2 Point of declaration [basic.scope.pdecl] 1 The point of declaration for a name is immediately after its complete declarator\n  (Clause 8) and before its initializer (if any), except as noted below.\n  [ Example:</p>\n</blockquote>\n<pre><code>unsigned char x = 12;\n{ unsigned char x = x; }\n</code></pre>\n<blockquote>\n<p id=\"so_34247975_34248633_15\">Here the second x is initialized with its own (indeterminate) value.\n  \u2014end example ]</p>\n</blockquote>\n<p>and then you quote this:</p>\n<blockquote>\n<p id=\"so_34247975_34248633_16\">The point of declaration for a name is immediately after its complete\n  declarator (Clause 8) and before its initializer (if any), except as\n  noted below...</p>\n</blockquote>\n<p>I finally read this:</p>\n<blockquote>\n<p id=\"so_34247975_34248633_17\">8 Declarators [dcl.decl] 1 A declarator declares a single variable,\n  function, or type, within a declaration. The init-declarator-list\n  appearing in a declaration is a comma-separated sequence of\n  declarators, each of which can have an initializer.\n  init-declarator-list: init-declarator init-declarator-list ,\n  init-declarator init-declarator: declarator initializeropt 2 The three\n  components of a simple-declaration are the attributes (7.6), the\n  specifiers (decl-specifier-seq; 7.1) and the declarators\n  (init-declarator-list). The specifiers indicate the type, storage\n  class or other properties of the entities being declared. The\n  declarators specify the names of these entities and (optionally)\n  modify the type of the specifiers with operators such as * (pointer\n  to) and () (function returning). Initial values can also be specified\n  in a declarator; initializers are discussed in 8.5 and 12.6. 3 Each\n  init-declarator in a declaration is analyzed separately as if it was\n  in a declaration by itself.100 4 Declarators have the syntax\n  declarator: ptr-declarator noptr-declarator parameters-and-qualifiers\n  trailing-return-type ptr-declarator: noptr-declarator ptr-operator\n  ptr-declarator noptr-declarator: declarator-id\n  attribute-specifier-seqopt noptr-declarator parameters-and-qualifiers\n  noptr-declarator [ constant-expressionopt] attribute-specifier-seqopt\n  ( ptr-declarator ) parameters-and-qualifiers: (\n  parameter-declaration-clause ) cv-qualifier-seqopt ref-qualifieropt\n  exception-specificationopt attribute-specifier-seqopt 100) A\n  declaration with several declarators is usually equivalent to the\n  corresponding sequence of declarations each with a single declarator.\n  That is T D1, D2, ... Dn; is usually equivalent to T D1; T D2; ... T\n  Dn; where T is a decl-specifier-seq and each Di is an init-declarator.\n  An exception occurs when a name introduced by one of the declarators\n  hides a type name used by the decl-specifiers, so that when the same\n  decl-specifiers are used in a subsequent declaration, they do not have\n  the same meaning, as in struct S ... ; S S, T; // declare two\n  instances of struct S which is not equivalent to struct S ... ; S S; S\n  T; // error Another exception occurs when T is auto (7.1.6.4), for\n  example: auto i = 1, j = 2.0; // error: deduced types for i and j do\n  not match as opposed to auto i = 1; // OK: i deduced to have type int\n  auto j = 2.0; // OK: j deduced to have type double Declarators 190</p>\n<p id=\"so_34247975_34248633_18\">c ISO/IEC N4527 trailing-return-type:\n  -&gt; trailing-type-specifier-seq abstract-declaratoropt ptr-operator:\n  * attribute-specifier-seqopt cv-qualifier-seqopt &amp; attribute-specifier-seqopt &amp;&amp; attribute-specifier-seqopt\n  nested-name-specifier * attribute-specifier-seqopt cv-qualifier-seqopt\n  cv-qualifier-seq: cv-qualifier cv-qualifier-seqopt cv-qualifier: const\n  volatile ref-qualifier: &amp; &amp;&amp; declarator-id: ...opt id-expression 5 The\n  optional attribute-specifier-seq in a trailing-return-type appertains\n  to the indicated return type. The type-id in a trailing-return-type\n  includes the longest possible sequence of abstract-declarators. [\n  Note: This resolves the ambiguous binding of array and function\n  declarators. [ Example: auto f()-&gt;int(*)[4]; // function returning a\n  pointer to array[4] of int // not function returning array[4] of\n  pointer to int \u2014end example ] \u2014end note ]</p>\n</blockquote>\n<p>You finally ask this: </p>\n<blockquote>\n<p id=\"so_34247975_34248633_19\">Then, how can I determine those of a namespace identifier?</p>\n</blockquote>\n<p>Did you proceed to read this section?</p>\n<blockquote>\n<p id=\"so_34247975_34248633_20\">7.3 Namespaces [basic.namespace] 1 A namespace is an optionally-named declarative region. The name of a namespace can be used to access\n  entities declared in that namespace; that is, the members of the\n  namespace. Unlike other declarative regions, the definition of a\n  namespace can be split over several parts of one or more translation\n  units. 2 The outermost declarative region of a translation unit is a\n  namespace; see 3.3.6.\n  7.3.1 Namespace definition [namespace.def] 1 The grammar for a namespace-definition is namespace-name: identifier namespace-alias\n  namespace-definition: named-namespace-definition\n  unnamed-namespace-definition nested-namespace-definition\n  named-namespace-definition: inlineopt namespace\n  attribute-specifier-seqopt identifier { namespace-body }\n  unnamed-namespace-definition: inlineopt namespace\n  attribute-specifier-seqopt{ namespace-body }\n  nested-namespace-definition: namespace enclosing-namespace-specifier\n  :: identifier { namespace-body } enclosing-namespace-specifier:\n  identifier enclosing-namespace-specifier :: identifier \u00a7 7.3.1 168</p>\n<p id=\"so_34247975_34248633_21\">c ISO/IEC N4527 namespace-body: declaration-seqopt 2 Every\n  namespace-definition shall appear in the global scope or in a\n  namespace scope (3.3.6). 3 In a named-namespace-definition, the\n  identifier is the name of the namespace. If the identifier, when\n  looked up (3.4.1), refers to a namespace-name (but not a\n  namespace-alias) introduced in the declarative region in which the\n  named-namespace-definition appears, the namespace-definition extends\n  the previously-declared namespace. Otherwise, the identifier is\n  introduced as a namespace-name into the declarative region in which\n  the named-namespace-definition appears. 4 Because a\n  namespace-definition contains declarations in its namespace-body and a\n  namespace-definition is itself a declaration, it follows that\n  namespace-definitions can be nested. [ Example:</p>\n</blockquote>\n<pre><code>namespace Outer {\n    int i;\n    namespace Inner {\n        void f() { i++; } // Outer::i\n        int i;\n        void g() { i++; } // Inner::i\n    }\n}\n</code></pre>\n<blockquote>\n<p id=\"so_34247975_34248633_22\">\u2014end example ]\n  5 The enclosing namespaces of a declaration are those namespaces in\n  which the declaration lexically appears, except for a redeclaration of\n  a namespace member outside its original namespace (e.g., a definition\n  as specified in 7.3.1.2). Such a redeclaration has the same enclosing\n  namespaces as the original declaration. [ Example:</p>\n</blockquote>\n<pre><code>namespace Q {\n    namespace V {\n        void f(); // enclosing namespaces are the global namespace, Q, and Q::V\n        class C { void m(); };\n    }\n    void V::f() { // enclosing namespaces are the global namespace, Q, and Q::V\n        extern void h(); // ... so this declares Q::V::h\n    }\n    void V::C::m() { // enclosing namespaces are the global namespace, Q, and Q::V\n    }\n}\n</code></pre>\n<blockquote>\n<p id=\"so_34247975_34248633_23\">\u2014end example ] 6 If the optional initial inline keyword appears in a\n  namespace-definition for a particular namespace, that namespace is\n  declared to be an inline namespace. The inline keyword may be used on\n  a namespacedefinition that extends a namespace only if it was\n  previously used on the namespace-definition that initially declared\n  the namespace-name for that namespace. 7 The optional\n  attribute-specifier-seq in a named-namespace-definition appertains to\n  the namespace being defined or extended. 8 Members of an inline\n  namespace can be used in most respects as though they were members of\n  the enclosing namespace. Specifically, the inline namespace and its\n  enclosing namespace are both added to the set of associated namespaces\n  used in argument-dependent lookup (3.4.2) whenever one of them is, and\n  a usingdirective (7.3.4) that names the inline namespace is implicitly\n  inserted into the enclosing namespace as for an unnamed namespace\n  (7.3.1.1). Furthermore, each member of the inline namespace can\n  subsequently be partially specialized (14.5.5), explicitly\n  instantiated (14.7.2), or explicitly specialized (14.7.3) as though it\n  were a member of the enclosing namespace. Finally, looking up a name\n  in the enclosing namespace via \u00a7 7.3.1 169</p>\n<p id=\"so_34247975_34248633_24\">c ISO/IEC N4527 explicit qualification (3.4.3.2) will include members\n  of the inline namespace brought in by the using-directive even if\n  there are declarations of that name in the enclosing namespace. 9\n  These properties are transitive: if a namespace N contains an inline\n  namespace M, which in turn contains an inline namespace O, then the\n  members of O can be used as though they were members of M or N. The\n  inline namespace set of N is the transitive closure of all inline\n  namespaces in N. The enclosing namespace set of O is the set of\n  namespaces consisting of the innermost non-inline namespace enclosing\n  an inline namespace O, together with any intervening inline\n  namespaces. 10 A nested-namespace-definition with an\n  enclosing-namespace-specifier E, identifier I and namespace-body B is\n  equivalent to namespace E { namespace I { B } }\n  [ Example:</p>\n</blockquote>\n<pre><code>namespace A::B::C {\n    int i;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_34247975_34248633_25\">The above has the same effect as:</p>\n</blockquote>\n<pre><code>namespace A {\n    namespace B {\n        namespace C {\n            int i;\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<p id=\"so_34247975_34248633_26\">\u2014end example ]</p>\n</blockquote>\n<p>I think the lines of importance that answers your question is found from its definition 7.3 - 1 &amp; 2 and 7.3.1 - 2,3 &amp; 4. Provided you are working with a named namespace and you already understand scope, translation unit, declaration, definition and declarative space. There is no mention of a  declarator of a name space in the declarator section because it is listed in the declaration section under the namespace section because the named namespace or its definition is its declaration, thus the identifier is the name of the namespace itself or its definition - declaration.</p>\n", "LastActivityDate": "2015-12-13T06:39:51.810", "CommentCount": "13", "CreationDate": "2015-12-13T06:39:51.810", "ParentId": "34247975", "Score": "1", "OwnerUserId": "1757805"}, "34247975": {"ViewCount": "672", "Body": "<p>It seems that there is no clear definition over the <em>point of declaration</em>, <em>declarative region</em>, <em>scope</em> of <strong>a namespace identifier</strong>, except those of <strong>an identifier inside a namespace</strong>\u2014according to the standard(\u00a73.3.6/1).</p>\n<blockquote>\n<p id=\"so_34247975_34247975_0\">The declarative region of a namespace-definition is its namespace-body. The potential scope denoted by\n  an original-namespace-name is the concatenation of the declarative regions established by each of the\n  namespace-definitions in the same...</p>\n</blockquote>\n<p>Although the standard indeed talks about those of a <em>declaration</em>\u2014a <em>namespace-definition</em> is declaration, that is not applicable to the case of namespace-definition because it has no <em>declarator</em>, nor <em>initializer</em>\u2014according to the standard(\u00a73.3.2/1).</p>\n<blockquote>\n<p id=\"so_34247975_34247975_1\">The point of declaration for a name is immediately after <strong>its complete declarator</strong> (Clause 8) and before <strong>its\n  initializer</strong> (if any), except as noted below...</p>\n</blockquote>\n<p>Then, how can I determine those of a namespace identifier?</p>\n", "Title": "What is the scope of a namespace identifier?", "CreationDate": "2015-12-13T04:26:01.627", "LastActivityDate": "2015-12-13T10:55:30.650", "CommentCount": "22", "FavoriteCount": "1", "PostTypeId": "1", "Id": "34247975", "Score": "11", "OwnerUserId": "5645940", "Tags": "<c++><language-lawyer>", "AnswerCount": "3"}, "34248521": {"Id": "34248521", "PostTypeId": "2", "Body": "<p>From the text you quoted from the standard, my interpretation would be that you have answered your own question.</p>\n<p>As you say, a namespace cannot have a complete declarator, since an additional declarative region for it can be created in any compilation unit (i.e. source file or header included by that source file) for any namespace <code>X</code> by <code>namespace X { &lt;new names within this declarative region&gt; }</code>.</p>\n<p>Since there can never be a complete declaration of a namespace, there can never be a point of declaration for a namespace.    Since there is no point of declaration, there is no such thing as a namespace identifier, and no such thing as a scope of one.</p>\n<p>Which means that a namespace is just a label which can be part of an identifier.   <code>istream</code> is an identifier within namespace <code>std</code>, the complete name of that identifier (as referenced from code outside a declarative region of namespace <code>std</code>) is <code>std::istream</code>.    All the <code>using namespace std;</code> does is, when trying to find a match for a potential identifier <code>foo</code> is tell the compiler to look within namespace <code>std</code> (or the declarative regions it has visibility of) for an identifier named <code>foo</code> which will be a candidate match.   [Which is why <code>using namespace</code> for multiple namespaces can result in ambiguity, if more than one namespace contains the same identifier].</p>\n", "LastEditorUserId": "4706785", "LastActivityDate": "2015-12-13T10:55:30.650", "Score": "4", "CreationDate": "2015-12-13T06:15:39.980", "ParentId": "34247975", "CommentCount": "6", "OwnerUserId": "4706785", "LastEditDate": "2015-12-13T10:55:30.650"}, "34249649": {"Id": "34249649", "PostTypeId": "2", "Body": "<p>I will try to break this down into parts based on the misunderstanding of the op.</p>\n<p>He stated:</p>\n<blockquote>\n<p id=\"so_34247975_34249649_0\">It seems that there is no clear definition over the point of\n  declaration, declarative region, scope of a namespace identifier</p>\n</blockquote>\n<pre><code>// File A.h\nnamespace foo {        // Resides At Global Scope\n    // some code here.\n    void bar();        // Resided At foo:: Scope\n}\n\n// File A.cpp\nnamespace foo {\n    // some more code here\n    void bar() { \n        std::cout &lt;&lt; \"Hell World\" &lt;&lt; std::endl; \n    }\n}\n</code></pre>\n<p>Here the declarative region spans multiple files for <code>foo</code> its definition and declaration is <code>foo</code> and <code>foo</code> is its identifier. Since this is a named namespace there is no declarator as you would see with a variable, function or type as defined in section 8.1</p>\n<blockquote>\n<p id=\"so_34247975_34249649_1\">A declarator declares a single variable, function, or type, within a\n  declaration</p>\n</blockquote>\n<p>And there is no initializer either since it is a namespace. It is a declarative region that has scope. </p>\n<p>And what I believe that the op is asking is this:</p>\n<blockquote>\n<p id=\"so_34247975_34249649_2\">Then, how can I determine those of a namespace identifier?</p>\n</blockquote>\n<p>The namespace identifier is the name of the namespace which is also its definition and declaration. In a sense all 3 are one and the same, and the declarative region of a namespace and its scope is one and the same.</p>\n<p>No, the standard doesn't draw a clear picture of the point of declaration for a namespace because it refers to the use of a declator which a namespace doesn't have. In some cases a namespace can be initialized by another namespace upon its definition - declaration as in: Typically an alias!</p>\n<pre><code>namespace someLongName{\n}\n\nnamespace shortVersion = someLongName {\n}\n</code></pre>\n<p>Where the point of declaration is found in 3.3.2.1, If you continue through this section in secession it moves on to Block Scope, Function Prototype Scope, Function Scope, Namespace Scope, Class Scope, Enumeration Scope, Template Parameter Scope, however if you refer back to 3.1 under definitions of Declarations and Definitions; a name space is defined and not declared, but in section 3.3.6</p>\n<blockquote>\n<p id=\"so_34247975_34249649_3\">The declarative region of a namespace-definition is its\n  namespace-body. Entities declared in a namespace-body are said to be\n  members of the namespace, and names introduced by these declarations\n  into the declarative region of the namespace are said to be member\n  names of the namespace. A namespace member name has namespace scope.\n  Its potential scope includes its namespace from the name\u2019s point of\n  declaration (3.3.2) onwards; and for each using-directive (7.3.4) that\n  nominates the member\u2019s namespace, the member\u2019s potential scope\n  includes that portion of the potential scope of the using-directive\n  that follows the member\u2019s point of declaration.</p>\n</blockquote>\n<p>and</p>\n<p>7.3 1 &amp; 2</p>\n<blockquote>\n<p id=\"so_34247975_34249649_4\">7.3 Namespaces [basic.namespace] 1 A namespace is an optionally-named declarative region. The name of a namespace can be used to access\n  entities declared in that namespace; that is, the members of the\n  namespace. Unlike other declarative regions, the definition of a\n  namespace can be split over several parts of one or more translation\n  units. 2 The outermost declarative region of a translation unit is a\n  namespace; see 3.3.6.</p>\n</blockquote>\n<p>and </p>\n<p>7.3.1 2-4</p>\n<blockquote>\n<p id=\"so_34247975_34249649_5\">2 Every namespace-definition shall appear in the global scope or in a\n  namespace scope (3.3.6).\n  3 In a named-namespace-definition, the identifier is the name of the\n  namespace. If the identifier, when looked up (3.4.1), refers to a\n  namespace-name (but not a namespace-alias) introduced in the\n  declarative region in which the named-namespace-definition appears,\n  the namespace-definition extends the previously-declared namespace.\n  Otherwise, the identifier is introduced as a namespace-name into the\n  declarative region in which the named-namespace-definition appears.\n  4 Because a namespace-definition contains declarations in its\n  namespace-body and a namespace-definition is itself a declaration, it\n  follows that namespace-definitions can be nested.</p>\n</blockquote>\n<p>Here I'll try to suggest even without a clear definition that the point of declaration for a namespace is immediately after its identifier - definition - declaration!</p>\n<pre><code>namespace /*keyword*/ std /*definition, declaration, identifier*/ (point of declaration) { /*beginning of declarative region &amp; scope*/  \n    .... // some code\n\n} // End of declarative region or scope until another matching identifier at same level of scope is found. \n  // And this can span multiple translations units.\n</code></pre>\n<p>I hope this clears up the confusion.</p>\n", "LastEditorUserId": "1757805", "LastActivityDate": "2015-12-13T09:31:42.270", "Score": "1", "CreationDate": "2015-12-13T09:26:37.410", "ParentId": "34247975", "CommentCount": "2", "OwnerUserId": "1757805", "LastEditDate": "2015-12-13T09:31:42.270"}});