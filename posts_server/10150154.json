post_cb({"10150154": {"ViewCount": "272", "Body": "<p>About the STL container <strong>set</strong> and <strong>multiset</strong>,the return types of the <strong>insert</strong> functions are not all the same. \n<strong>set</strong> provides the following interface:</p>\n<pre><code>pair&lt;iterator,bool&gt; insert(const value_type&amp; elem); \niterator  insert(iterator pos_hint, const value_type&amp; elem); \n</code></pre>\n<p><strong>multiset</strong> provides the following interface:</p>\n<pre><code>iterator  insert(const value_type&amp; elem); \niterator  insert(iterator pos_hint, const value_type&amp; elem);\n</code></pre>\n<p>In the first function of <strong>set</strong>, the member <strong>second</strong> of the <strong>pair</strong> structure returns whether the insertion is successful.The insertion of an element might fail for a set if it already contains an element with the same value.But in the second function of <strong>set</strong>,the insert function just returns an iterator.What will happen if the insertion fails?Could someone tell me that?\nThanks a lot.</p>\n", "AcceptedAnswerId": "10150172", "Title": "C++ STL container set&multiset:the insert operation with different return types", "CreationDate": "2012-04-14T01:07:39.437", "Id": "10150154", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-04-14T01:29:54.610", "Score": "2", "OwnerUserId": "1211152", "Tags": "<c++><stl><set><containers>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_10150154_10150172_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 744}}, "n3337": {"so_10150154_10150172_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 733}}, "n4659": {"so_10150154_10150172_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 802}}}, "10150172": {"Id": "10150172", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_10150154_10150172_0\">But in the second function of set,the insert function just returns an iterator.What will happen if the insertion fails?</p>\n</blockquote>\n<p>In the <code>set::insert</code> version that just returns a plain <code>iterator</code> (and not a <code>pair&lt;iterator,bool&gt;</code>), when an existing element is found the set is left unchanged and the <code>insert</code> will return an iterator to the existing element (that prevented the insertion).</p>\n<p>In <code>multiset::insert</code>, the function is always successful.</p>\n<h3>23.2.4 Associative Container Requirements</h3>\n<h3><code>iterator a.insert(p, t)</code></h3>\n<blockquote>\n<p id=\"so_10150154_10150172_1\"><em>Effects</em>: Inserts t if and only if there is no element with key\n  equivalent to the key of t in containers with unique keys; always\n  inserts t in containers with equivalent keys. always returns the\n  iterator pointing to the element with key equivalent to the key of t.\n  t is inserted as close as possible to the position just prior to p.</p>\n</blockquote>\n", "LastEditorUserId": "1131467", "LastActivityDate": "2012-04-14T01:21:29.613", "Score": "1", "CreationDate": "2012-04-14T01:12:36.803", "ParentId": "10150154", "CommentCount": "0", "OwnerUserId": "1131467", "LastEditDate": "2012-04-14T01:21:29.613"}});