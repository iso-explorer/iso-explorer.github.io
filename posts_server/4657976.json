post_cb({"4658065": {"Id": "4658065", "PostTypeId": "2", "Body": "<p>Although the comparison is valid only for pointers within the array and \"one past the end\", it is valid to use a set or map with a pointer as the key, which uses <code>std::less&lt;T*&gt;</code></p>\n<p>There was a big discussion on this way back in 1996 on <a href=\"http://groups.google.com/group/comp.std.c++/browse_thread/thread/604972347050fbd6/2c5509bf63bb3e7d?lnk=gst&amp;q=pointer+less+set#2c5509bf63bb3e7d\" rel=\"noreferrer\">comp.std.c++</a></p>\n", "LastEditorUserId": "442284", "LastActivityDate": "2011-01-11T13:28:56.440", "Score": "10", "CreationDate": "2011-01-11T13:22:34.393", "ParentId": "4657976", "CommentCount": "5", "OwnerUserId": "442284", "LastEditDate": "2011-01-11T13:28:56.440"}, "4657976": {"ViewCount": "3365", "Body": "<p>Can I check whether or not a given pointer points to an object within an array, specified by its bounds?</p>\n<pre><code>template &lt;typename T&gt;\nbool points_within_array(T* p, T* begin, T* end)\n{\n    return begin &lt;= p &amp;&amp; p &lt; end;\n}\n</code></pre>\n<p>Or do the pointer comparisons invoke undefined behavior if <code>p</code> points outside the bounds of the array? In that case, how do I solve the problem? Does it work with void pointers? Or is it impossible to solve?</p>\n", "AcceptedAnswerId": "4658065", "Title": "checking if pointer points within an array", "CreationDate": "2011-01-11T13:14:42.127", "Id": "4657976", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2011-01-13T08:11:46.830", "Score": "12", "OwnerUserId": "252000", "Tags": "<c++><arrays><pointers><comparison>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_4657976_4658026_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 5795}}, "n3337": {"so_4657976_4658026_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 5568}}, "n4659": {"so_4657976_4658026_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 7254}}}, "4668757": {"Id": "4668757", "PostTypeId": "2", "Body": "<p>The only correct way to do this is an approach like this.</p>\n<pre><code>template &lt;typename T&gt;\nbool points_within_array(T* p, T* begin, T* end)\n{\n    for (; begin != end; ++begin)\n    {\n        if (p == begin)\n            return true;\n    }\n    return false;\n}\n</code></pre>\n<p>Fairly obviously, this doesn't work if <code>T == void</code>. I'm not sure whether two <code>void*</code> technically define a range or not. Certainly if you had <code>Derived[n]</code>, it would be incorrect to say that <code>(Base*)Derived, (Base*)(Derived + n)</code> defined a valid range so I can't see it being valid to define a range with anything other than a pointer to the actual array element type.</p>\n<p>The method below fails because it is unspecified what <code>&lt;</code> returns if the two operands don't point to members of the same object or elements of the same array. (5.9 [expr.rel] / 2)</p>\n<pre><code>template &lt;typename T&gt;\nbool points_within_array(T* p, T* begin, T* end)\n{\n    return !(p &lt; begin) &amp;&amp; (p &lt; end);\n}\n</code></pre>\n<p>The method below fails because it is also unspecified what <code>std::less&lt;T*&gt;::operator()</code> returns if the two operands don't point to members of the same object or elements of the same array.</p>\n<p>It is true that a <code>std::less</code> must be specialized for any pointer type to yield a total order if the built in <code>&lt;</code> does not but this is only useful for uses such as providing a key for a <code>set</code> or <code>map</code>. It is not guaranteed that the total order won't interleave distinct arrays or objects together.</p>\n<p>For example, on a segmented memory architecture the object offset could be used for <code>&lt;</code> and as the most significant differentiator for <code>std::less&lt;T*&gt;</code> with the segment index being used to break ties. In such a system an element of one array could be ordered between the bounds of a second distinct array.</p>\n<pre><code>template &lt;typename T&gt;\nbool points_within_array(T* p, T* begin, T* end)\n{\n    return !(std::less&lt;T*&gt;()(p, begin)) &amp;&amp; (std::less&lt;T*&gt;()(p, end));\n}\n</code></pre>\n", "LastEditorUserId": "19563", "LastActivityDate": "2011-01-13T08:11:46.830", "Score": "4", "CreationDate": "2011-01-12T12:25:53.293", "ParentId": "4657976", "CommentCount": "2", "OwnerUserId": "19563", "LastEditDate": "2011-01-13T08:11:46.830"}, "4658107": {"Id": "4658107", "PostTypeId": "2", "Body": "<p>comparisions on pointer types don't neccesarily result in a total order. std::less/std::greater_equal do, however. So ...</p>\n<pre><code>template &lt;typename T&gt;\nbool points_within_array(T* p, T* begin, T* end)\n{\n    return std::greater_equal&lt;T*&gt;()(p, begin) &amp;&amp; std::less&lt;T*&gt;()(p, end);\n}\n</code></pre>\n<p>will work.</p>\n", "LastActivityDate": "2011-01-11T13:27:29.937", "CommentCount": "4", "CreationDate": "2011-01-11T13:27:29.937", "ParentId": "4657976", "Score": "1", "OwnerUserId": "524436"}, "4658496": {"Id": "4658496", "PostTypeId": "2", "Body": "<p>Could you not do this with <code>std::distance</code>, i.e. your problem effectively boils down to:</p>\n<pre><code>return distance(begin, p) &gt;= 0 &amp;&amp; distance(begin, p) &lt; distance(begin, end);\n</code></pre>\n<p>Given this random access iterator (pointer) is being passed in, it should boil down to some pointer arithmetic rather than pointer comparisons? (I'm assuming end really is end and not the last item in the array, if the last then change the less than to <code>&lt;=</code>).</p>\n<p>I could be way off the mark...</p>\n", "LastEditorUserId": "266198", "LastActivityDate": "2011-01-11T14:19:03.530", "Score": "0", "CreationDate": "2011-01-11T14:11:18.073", "ParentId": "4657976", "CommentCount": "0", "OwnerUserId": "266198", "LastEditDate": "2011-01-11T14:19:03.530"}, "4658026": {"Id": "4658026", "PostTypeId": "2", "Body": "<p>Straight from the <a href=\"http://msdn.microsoft.com/en-us/library/ya5wt12d.aspx\" rel=\"nofollow noreferrer\">MSDN documentation</a>:</p>\n<blockquote>\n<p id=\"so_4657976_4658026_0\">Two pointers of different types cannot be compared unless:</p>\n<ul>\n<li>One type is a class type derived from the other type.</li>\n<li>At least one of the pointers is explicitly converted (cast) to type void *. (The other pointer is implicitly converted to type void * for the conversion.)</li>\n</ul>\n</blockquote>\n<p>So a <code>void*</code> can be compared to anything else (including another <code>void*</code>). But will the comparison produce meaningful results?</p>\n<blockquote>\n<p id=\"so_4657976_4658026_1\">If two pointers point to elements of\n  the same array or to the element one\n  beyond the end of the array, the\n  pointer to the object with the higher\n  subscript compares higher. Comparison\n  of pointers is guaranteed valid only\n  when the pointers refer to objects in\n  the same array or to the location one\n  past the end of the array.</p>\n</blockquote>\n<p>Looks like not. If you don't <em>already know</em> that you are comparing items inside the array (or just past it), then the comparison is not guaranteed to be meaningful.</p>\n<p>There is, however, a solution: The STL provides <code>std::less&lt;&gt;</code> and <code>std::greater&lt;&gt;</code>, which will work with any pointer type and will produce valid results in all cases:</p>\n<pre><code>if (std::less&lt;T*&gt;()(p, begin)) {\n    // p is out of bounds\n}\n</code></pre>\n<p><strong>Update:</strong></p>\n<p>The answer to <a href=\"https://stackoverflow.com/q/1098966/50079\">this question</a> gives the same suggestion (<code>std::less</code>) and also quotes the standard.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-01-11T13:42:18.097", "Score": "6", "CreationDate": "2011-01-11T13:18:40.887", "ParentId": "4657976", "CommentCount": "7", "OwnerUserId": "50079", "LastEditDate": "2017-05-23T12:07:46.833"}, "4658080": {"Id": "4658080", "PostTypeId": "2", "Body": "<p>The C++ standard does not specify what happens when you are comparing pointers to objects that do not reside in the same array, hence undefined behaviour. However, the C++ standard is not the only standard your platform must conform. Other standards like POSIX specify things that C++ standard leaves as undefined behaviour.\nOn platforms with virtual address space like Linux and Win32/64 you can compare any pointers without causing any undefined behaviour.</p>\n", "LastActivityDate": "2011-01-11T13:23:59.557", "CommentCount": "0", "CreationDate": "2011-01-11T13:23:59.557", "ParentId": "4657976", "Score": "4", "OwnerUserId": "412080"}});