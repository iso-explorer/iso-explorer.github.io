post_cb({"bq_ids": {"n4140": {"so_8943782_8956525_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 6045}}, "n3337": {"so_8943782_8956525_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 5813}}, "n4659": {"so_8943782_8956525_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 7544}}}, "8943782": {"ViewCount": "93", "Body": "<p>I have an header, where I put the <em>definition</em> of a function template:</p>\n<pre><code>template &lt;typename FT, typename std::enable_if&lt; !std::is_array&lt;FT&gt;::value, int &gt;::type =0 &gt;\nint fieldRW(lua_State* l, FT* ptr, bool write){ return scalarFieldRW&lt;FT&gt;(l, ptr, write); }\n</code></pre>\n<p>in a .cpp unit I get a pointer to this template function, and I expect the compiler to instantiate the template:</p>\n<pre><code>typedef int (*_fieldRW)(lua_State*, void*, bool);\nint dummy=3;\n_fieldRW aFunctionPointer=_fieldRW(fieldRW&lt;decltype(dummy)&gt;);\n</code></pre>\n<p>Everything compiles. But I get the following link-time error:</p>\n<blockquote>\n<p id=\"so_8943782_8943782_0\">/home/pisto/sorgenti/hopmodv4/src/fpsgame/server.cpp:39: undefined\n  reference to `int fieldRW(lua_State*, int*, bool)'</p>\n</blockquote>\n<p>Notice that the compiler correctly picks the template defined in the header (because it adds the default second argument of the template), but apparently it fails to actually instantiate the template.</p>\n<p>EDIT:\nthis looks definitely like a bug. See these tests: <a href=\"http://pastebin.com/5Yjsv47H\" rel=\"nofollow\">http://pastebin.com/5Yjsv47H</a>\nAlso, another clue that this is likely to be a bug in g++ is that if I do this:</p>\n<pre><code>int main() {\n        int dummy=3;\n        int (*inted)(int*)=asd&lt;decltype(dummy)&gt;;\n        int (*voided)(void*)=(int (*)(void*))asd&lt;decltype(dummy)&gt;;\n        voided(&amp;dummy);\n}\n</code></pre>\n<p>g++ warns about the unused variable <code>inted</code> but compiles finely.</p>\n", "AcceptedAnswerId": "8956525", "Title": "template linking error", "CreationDate": "2012-01-20T15:29:19.610", "Id": "8943782", "CommentCount": "7", "LastEditDate": "2012-01-24T22:55:54.127", "PostTypeId": "1", "LastEditorUserId": "636019", "LastActivityDate": "2012-01-24T22:55:54.127", "Score": "0", "OwnerUserId": "1073006", "Tags": "<c++><g++><c++11>", "AnswerCount": "1"}, "8956525": {"Id": "8956525", "PostTypeId": "2", "Body": "<p>The answer is probably a subtleness in the specs of function pointer casting:</p>\n<blockquote>\n<p id=\"so_8943782_8956525_0\">The standard says in [expr.reinterpret.cast]\n  \"A function pointer can be explicitly converted to a function pointer of a\n  different type. The effect of calling a function through a pointer to a\n  function type (8.3.5) that is not the same as the type used in the definition\n  of the function is undefined.\"</p>\n<p id=\"so_8943782_8956525_1\">So I think the program has undefined behaviour.  Because you never call\n  asd as part of a valid expression it doesn't need to be instantiated.</p>\n<p id=\"so_8943782_8956525_2\">Clang++ fails in the same way as G++ 4.6, but it works with G++ 4.7</p>\n</blockquote>\n<p>(Thanks to Jonathan Wakely)</p>\n", "LastActivityDate": "2012-01-21T20:42:31.043", "CommentCount": "3", "CreationDate": "2012-01-21T20:42:31.043", "ParentId": "8943782", "Score": "1", "OwnerUserId": "1073006"}});