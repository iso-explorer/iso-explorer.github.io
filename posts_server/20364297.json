post_cb({"20364391": {"Id": "20364391", "PostTypeId": "2", "Body": "<p>Universal references work because of the reference collapsing rules in c++11. if you have </p>\n<pre><code>template &lt;typename T&gt; func (T &amp; t)\n</code></pre>\n<p>Reference collapsing still occurs but it won't work with a temporary hence the reference is not \"universal\". A universal reference is called \"universal\" because it can accept lvals and rvals (also preserves other qualifiers). <code>T &amp; t</code> is not universal as it cannot accept rvals.  </p>\n<p>So to sum it up universal references are a product of reference collapsing, and a universal reference is named as such because it is universal it what it can be</p>\n", "LastActivityDate": "2013-12-04T00:16:39.170", "CommentCount": "0", "CreationDate": "2013-12-04T00:16:39.170", "ParentId": "20364297", "Score": "0", "OwnerUserId": "2167655"}, "20364375": {"Id": "20364375", "PostTypeId": "2", "Body": "<p>You answered your own question: \"universal reference\" is just a name for the rvalue reference case of reference collapsing. If another syntax were required for reference collapsing, it wouldn't be reference collapsing any more. Reference collapsing is simply applying a reference qualifier to a reference type.</p>\n<blockquote>\n<p id=\"so_20364297_20364375_0\">so I wondered what g++ thinks about it. Of course it didn't compiled.</p>\n</blockquote>\n<p>Your first example is well-formed. GCC 4.9 compiles it without complaint, and the output agrees with MSVC.</p>\n<blockquote>\n<p id=\"so_20364297_20364375_1\">Almost, because I thought about what if I will want to change something in object's state which is passing by rvalue reference?</p>\n</blockquote>\n<p>Rvalue references do not apply <code>const</code> semantics; you can always change the state of an object passed by <code>move</code>. Mutability is necessary to their purpose. Although there is such a thing as <code>const &amp;&amp;</code>, you should never need it.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2016-05-03T03:00:57.170", "Score": "6", "CreationDate": "2013-12-04T00:14:47.010", "ParentId": "20364297", "CommentCount": "5", "OwnerUserId": "153285", "LastEditDate": "2016-05-03T03:00:57.170"}, "20378876": {"Id": "20378876", "PostTypeId": "2", "Body": "<p>Others have already mentioned that reference collapsing rules are key for universal references to work but there's another (arguably) equally important aspect: template argument deduction when the template parameter is of the form <code>T&amp;&amp;</code>.</p>\n<p>Actually, in relation to the question:</p>\n<blockquote>\n<blockquote>\n<p id=\"so_20364297_20378876_1\">Why \u201cuniversal references\u201d have the same syntax as rvalue references?</p>\n</blockquote>\n</blockquote>\n<p>in my opinion the form of the template parameter is more important because this is all about syntax. In C++03 there was no way to a template function to know the value category (rvalue or lvalue) of the passed object. C++11 changed the template argument deduction to account for that: 14.8.2.1 [temp.deduct.call]/p3</p>\n<blockquote>\n<blockquote>\n<p id=\"so_20364297_20378876_3\">[...] If <code>P</code> is an rvalue reference to a cv-unqualified template parameter and the argument is an lvalue, the type \"lvalue reference to <code>A</code>\" is used in place of <code>A</code> for type deduction.</p>\n</blockquote>\n</blockquote>\n<p>This a bit more complicated than the originally proposed wording (given by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1770.html\" rel=\"noreferrer\">n1770</a>):</p>\n<blockquote>\n<blockquote>\n<p id=\"so_20364297_20378876_6\">If <code>P</code> is an rvalue-reference type of the form <strike>cv</strike> <code>T&amp;&amp;</code> where <code>T</code> is a template type-parameter, and the argument is an lvalue, the deduced template argument value for <code>T</code> is <code>A&amp;</code>. [Example:</p>\n<pre><code>template&lt;typename T&gt; int f(T&amp;&amp;);\nint i;\nint j = f(i);   // calls f&lt;int&amp;&gt;(i)\n</code></pre>\n<p id=\"so_20364297_20378876_7\">--- end example] </p>\n</blockquote>\n</blockquote>\n<p>In more detail, the call above triggers the instantiation of <code>f&lt;int&amp;&gt;(int&amp; &amp;&amp;)</code> which, after  reference collapsing is applied, becomes <code>f&lt;int&amp;&gt;(int&amp;)</code>. On the other hand <code>f(0)</code> instantiates <code>f&lt;int&gt;(int&amp;&amp;)</code>. (Notice there's no <code>&amp;</code> inside <code>&lt; ... &gt;</code>.)</p>\n<p>No other form of declaration would deduce <code>T</code> to <code>int&amp;</code> and trigger the instantiation of <code>f&lt;int&amp;&gt;( ... )</code>. (Notice that a <code>&amp;</code> can appear between <code>( ... )</code> but not between <code>&lt; ... &gt;</code>.)</p>\n<p>In summary, when type deduction is performed the syntactic form <code>T&amp;&amp;</code> is what allows the value category of the original object to be available inside the function template body.</p>\n<p>Related to this fact, notice that one must use <code>std::forward&lt;T&gt;(arg)</code> and not <code>std::forward(arg)</code> exactly because it's <code>T</code> (not <code>arg</code>) that records the value category of the original object. (As a mesaure of caution, the definition of <code>std::forward</code> \"artificially\" forces the latter compilation to fail to prevent programmers making this mistake.)</p>\n<p>Back to the original question: <em>\"Why the committee decided to use the form <code>T&amp;&amp;</code> rather than choose a new syntax?\"</em></p>\n<p>I can't tell the real reason but I can speculate. First this is backward compatible with C++03. Second and, most importantly, this was a very simple solution to state in the Standard (one paragraph change) and to implement by compilers. Please, don't get me wrong. I'm not saying the committee members are lazy (they certainly aren't). I'm just saying that they minimized the risk of collateral damage.</p>\n", "LastActivityDate": "2013-12-04T15:08:09.717", "CommentCount": "0", "CreationDate": "2013-12-04T15:08:09.717", "ParentId": "20364297", "Score": "7", "OwnerUserId": "1137388"}, "bq_ids": {"n4140": {"so_20364297_20378876_2": {"length": 13, "quality": 1.0, "section_id": 304}, "so_20364297_20378876_3": {"length": 13, "quality": 1.0, "section_id": 304}}, "n3337": {"so_20364297_20378876_2": {"length": 13, "quality": 1.0, "section_id": 295}, "so_20364297_20378876_3": {"length": 13, "quality": 1.0, "section_id": 295}}, "n4659": {"so_20364297_20378876_2": {"length": 13, "quality": 1.0, "section_id": 311}, "so_20364297_20378876_3": {"length": 13, "quality": 1.0, "section_id": 311}}}, "20371167": {"Id": "20371167", "PostTypeId": "2", "Body": "<p>I think it happened the other way around. The initial idea was to introduce rvalue-references into the language, meaning that \"the code providing the double-ampersand reference does not care about what will happen to the referred-to object\". This permits move semantics. This is nice.</p>\n<p>Now. The standard forbids constructing a reference to a reference, but this was always possible. Consider:</p>\n<pre><code>template&lt;typename T&gt;\nvoid my_func(T, T&amp;) { /* ... */ }\n\n// ...\n\nmy_func&lt;int&amp;&gt;(a, b);\n</code></pre>\n<p>In this case the type of the second parameter should be <code>int &amp; &amp;</code>, but this is explicitly forbidden in the standard. So the references have to be collapsed, even in C++98. In C++98, there was only one kind of reference, so the collapsing rule was simple:</p>\n<pre><code>&amp; &amp; -&gt; &amp;\n</code></pre>\n<p>Now, we have two kinds of references, where <code>&amp;&amp;</code> means \"I don't care about what may happen to the object\", and <code>&amp;</code> meaning \"I may care about what may happen to the object, so you better watch what you're doing\". With this in mind, the collapsing rules flow naturally: C++ should collapse referecnces to <code>&amp;&amp;</code> only if no one cares about what happens to the object:</p>\n<pre><code>&amp; &amp; -&gt; &amp;\n&amp; &amp;&amp; -&gt; &amp;\n&amp;&amp; &amp; -&gt; &amp;\n&amp;&amp; &amp;&amp; -&gt; &amp;&amp;\n</code></pre>\n<p>With these rules in place, I think it's Scott Meyers who noticed that this subset of rules:</p>\n<pre><code>&amp; &amp;&amp; -&gt; &amp;\n&amp;&amp; &amp;&amp; -&gt; &amp;&amp;\n</code></pre>\n<p>Shows that <code>&amp;&amp;</code> is right-neutral with regards to reference collapsing, and, when type deduction occurs, the <code>T&amp;&amp;</code> construct can be used to match any type of reference, and coined the term \"Universal reference\" for these references. It is not something that has been invented by the Committee. It is only a side-effect of other rules, not a Committee design.</p>\n<p>And the term has therefore been introduced to distinguish between REAL rvalue-references, when no type deduction occurs, which are guaranteed to be <code>&amp;&amp;</code>, and those type-deduced UNIVERSAL references, which are not guaranteed to remain <code>&amp;&amp;</code> at template specialization time.</p>\n", "LastEditorUserId": "1459996", "LastActivityDate": "2016-07-11T12:30:27.570", "Score": "35", "CreationDate": "2013-12-04T09:11:10.483", "ParentId": "20364297", "CommentCount": "2", "OwnerUserId": "2071258", "LastEditDate": "2016-07-11T12:30:27.570"}, "20364297": {"ViewCount": "7207", "Body": "<p>I just made some research about those (quite) new features and I wonder why C++ Committee decided to introduce the same syntax for both of them? It seems that developers unnecessary have to waste some time to understand how it works, and one solution lets to think about further problems. In my case it started from problem which can be simplified to this:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nvoid f(T&amp; a)\n{\n    std::cout &lt;&lt; \"f(T&amp; a) for lvalues\\n\";\n}\n\ntemplate &lt;typename T&gt;\nvoid f(T&amp;&amp; a)\n{\n    std::cout &lt;&lt; \"f(T&amp;&amp; a) for rvalues\\n\";\n}\n\nint main()\n{\n    int a;\n    f(a);\n    f(int());\n\n    return 0;\n}\n</code></pre>\n<p>I compiled it firstly on VS2013 and it worked as I expected, with this results:</p>\n<pre><code>f(T&amp; a) for lvalues\nf(T&amp;&amp; a) for rvalues\n</code></pre>\n<p>But there was one suspicious thing: intellisense underlined f(a). I made some research and I understood that it is because type collapsing (universal references as Scott Meyers named it), so I wondered what g++ thinks about it. Of course it didn't compiled. It is very nice that Microsoft implemented their compiler to work in more intuitive way, but I'm not sure if it is according to the standard and if there should be this kind of difference in IDE (compiler vs intellisense, but in fact there may be some sense in it). Ok, return to the problem. I solved it in this way:</p>\n<pre><code>template &lt;typename T&gt;\nvoid f(T&amp; a)\n{\n    std::cout &lt;&lt; \"f(T&amp; a) for lvalues\\n\";\n}\n\ntemplate &lt;typename T&gt;\nvoid f(const T&amp;&amp; a)\n{\n    std::cout &lt;&lt; \"f(T&amp;&amp; a) for rvalues\\n\";\n}\n</code></pre>\n<p>Now there wasn't any type collapsing, just normal overloading for (r/l)values. It compiled on g++, intellisense stopped complaining and I was almost satisfied. Almost, because I thought about what if I will want to change something in object's state which is passed by rvalue reference? I could describe some situation when it could be necessary, but this description is too long to present it here. I solved it in this way:</p>\n<pre><code>template &lt;typename T&gt;\nvoid f(T&amp;&amp; a, std::true_type)\n{\n    std::cout &lt;&lt; \"f(T&amp;&amp; a) for rvalues\\n\";\n}\n\ntemplate &lt;typename T&gt;\nvoid f(T&amp;&amp; a, std::false_type)\n{\n    std::cout &lt;&lt; \"f(T&amp;&amp; a) for lvalues\\n\";\n}\n\ntemplate &lt;typename T&gt;\nvoid f(T&amp;&amp; a)\n{\n    f(std::forward&lt;T&gt;(a), std::is_rvalue_reference&lt;T&amp;&amp;&gt;());\n}\n</code></pre>\n<p>Now it compiles on all tested compilers and it lets me to change object state in rvalue reference implementation, but it doesn't looks very nice, and this is because of the same syntax for universal references and rvalue references. So my question is: Why C++ Committee didn't introduce some another syntax for universal references? I think that this feature should be signalized, for example, by T?, auto?, or something similar, but not as T&amp;&amp; and auto&amp;&amp; which just collide with rvalue references. Using this approach my first implementation would be perfectly correct, not only for MS compiler. Can anyone explain Committee decision?</p>\n", "Title": "Why \"universal references\" have the same syntax as rvalue references?", "CreationDate": "2013-12-04T00:06:56.583", "LastActivityDate": "2016-12-01T20:50:16.373", "CommentCount": "7", "FavoriteCount": "12", "PostTypeId": "1", "LastEditDate": "2016-12-01T20:50:16.373", "LastEditorUserId": "5507349", "Id": "20364297", "Score": "31", "OwnerUserId": "3063500", "Tags": "<c++><c++11><reference><universal><rvalue>", "AnswerCount": "5"}, "36985065": {"Id": "36985065", "PostTypeId": "2", "Body": "<p><strong>First and foremost</strong>, the reason the first example didn't compile with gcc 4.8 is that this is a bug in gcc 4.8. (I'll expand on this later). The first example compiles, runs, and produces the same output as VS2013 with post-4.8 versions of gcc, clang 3.3 and later, and Apple's LLVM-based c++ compiler.</p>\n<p><strong>On universal references:</strong><br>\nOne reason Scott Meyer's coined the term \"universal references\" is because <code>T&amp;&amp;</code> as a function template argument matches lvalues as well as rvalues. The universality of <code>T&amp;&amp;</code> in templates can be seen by removing the first function from the first example in the question:</br></p>\n<pre><code>// Example 1, sans f(T&amp;):\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\ntemplate &lt;typename T&gt;\nvoid f(T&amp;&amp;)   {\n    std::cout &lt;&lt; \"f(T&amp;&amp;) for universal references\\n\";\n    std::cout &lt;&lt; \"T&amp;&amp; is an rvalue reference: \"\n              &lt;&lt; std::boolalpha\n              &lt;&lt; std::is_rvalue_reference&lt;T&amp;&amp;&gt;::value\n              &lt;&lt; '\\n';\n}\n\nint main() {\n    int a;\n    const int b = 42;\n    f(a);\n    f(b);\n    f(0);\n}\n</code></pre>\n<p>The above compiles and runs on all the aforementioned compilers, and on gcc 4.8 as well. This one function universally accepts lvalues and rvalues as arguments. In the case of the calls to <code>f(a)</code> and <code>f(b)</code>, the function reports that <code>T&amp;&amp;</code> is not an rvalue reference. The calls to <code>f(a)</code>, <code>f(b)</code> and <code>f(0)</code> respectively become calls to the functions <code>f&lt;int&amp;&gt;(int&amp;)</code>, <code>f&lt;const int&amp;&gt;(const int&amp;)</code>, <code>f&lt;int&amp;&amp;&gt;(int&amp;&amp;)</code>. Only in the case of <code>f(0)</code> is does the <code>T&amp;&amp;</code> become an rvalue reference. Since an argument <code>T&amp;&amp; foo</code> may or may not be an rvalue reference in the case of a function template, it's best to call those something else. Meyers chose to call them \"universal references.\"</p>\n<p><strong>Why this is a bug in gcc 4.8:</strong><br>\nIn the first example code in the question, the function templates <code>template &lt;typename T&gt; void f(T&amp;)</code> and <code>template &lt;typename T&gt; void f(T&amp;&amp;)</code> become <code>f&lt;int&gt;(int&amp;)</code> and <code>f&lt;int&amp;&gt;(int&amp;)</code> with regard to the call to <code>f(a)</code>, the latter thanks to C++11 reference collapsing rules. These two functions have the exact same signature, so perhaps gcc 4.8 is correct, that the call to <code>f(a)</code> is ambiguous. It is not.</br></p>\n<p>The reason the call is not ambiguous is that <code>template &lt;typename T&gt; void f(T&amp;)</code> is more specialized than is <code>template &lt;typename T&gt; void f(T&amp;&amp;)</code> per the rules of sections 13.3 (Overload resolution), 14.5.6.2 (Partial ordering of function templates), and 14.8.2.4 (Deducing template arguments during partial ordering). When comparing <code>template &lt;typename T&gt; void f(T&amp;&amp;)</code> to <code>template &lt;typename T&gt; void f(T&amp;)</code> with <code>T=int&amp;</code>, both product <code>f(int&amp;)</code>. No distinction can be made here. However, when comparing <code>template&lt;typename T&gt; void f(T&amp;)</code> to <code>template &lt;typename T&gt; void f(T&amp;&amp;)</code> with <code>T=int</code>, the former is more specialized because now we have <code>f(int&amp;)</code> versus <code>f(int&amp;&amp;)</code>. Per 14.8.2.4 paragraph 9, \"if the type from the argument template was an lvalue reference and the type from the parameter template was not, the argument type is considered to be more specialized than the other\".</p>\n", "LastEditorUserId": "774499", "LastActivityDate": "2016-05-02T15:52:44.113", "Score": "0", "CreationDate": "2016-05-02T14:36:10.243", "ParentId": "20364297", "CommentCount": "3", "OwnerUserId": "774499", "LastEditDate": "2016-05-02T15:52:44.113"}});