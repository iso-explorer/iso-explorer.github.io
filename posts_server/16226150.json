post_cb({"16226151": {"Id": "16226151", "PostTypeId": "2", "Body": "<p>The example you are looking for is a <strong>range-based <code>for</code> statement</strong>:</p>\n<pre><code>MyString a, b, c;\nfor( MyCharacter mc : a + b + c ) { ... }\n</code></pre>\n<p>In this case the result of <code>a + b + c</code> is bound to a reference, but the nested temporary (generated by <code>a + b</code> and returned as an rvalue reference by <code>(a + b) + c</code>) is destroyed before the range-based for loop is executed.</p>\n<p>The standard defines range-based for loops in</p>\n<blockquote>\n<h3>6.5.4 The range-based for statement [stmt.ranged]</h3>\n<p id=\"so_16226150_16226151_0\"><sup>1</sup> For a range-based <code>for</code> statement of the form</p>\n<p id=\"so_16226150_16226151_1\"><code>for (</code><em>for-range-declaration</em><code>:</code><em>expression</em><code>)</code><em>statement</em></p>\n<p id=\"so_16226150_16226151_2\">let <em>range-init</em> be equivalent to the <em>expression</em> surrounded by parentheses</p>\n<p id=\"so_16226150_16226151_3\"><code>( expression )</code></p>\n<p id=\"so_16226150_16226151_4\">and for a range-based <code>for</code> statement of the form</p>\n<p id=\"so_16226150_16226151_5\"><code>for (</code><em>for-range-declaration</em><code>:</code><em>braced-init-list</em><code>)</code><em>statement</em></p>\n<p id=\"so_16226150_16226151_6\">let <em>range-init</em> be equivalent to the <em>braced-init-list</em>. In each case, a range-based <code>for</code> statement is equivalent to</p>\n<pre><code>{\n   auto &amp;&amp; __range = range-init;\n   for ( auto __begin = begin-expr,\n              __end = end-expr;\n         __begin != __end;\n         ++__begin ) {\n      for-range-declaration = *__begin;\n      statement\n   }\n}\n</code></pre>\n</blockquote>\n<p>Note that <code>auto &amp;&amp; __range = range-init;</code> would extend the lifetime of a temporary returned from <em>range-init</em>, but it does not extend the lifetime of nested temporaries <em>inside</em> of <em>range-init</em>.</p>\n", "LastEditorUserId": "2073257", "LastActivityDate": "2013-04-26T19:37:56.747", "Score": "8", "CreationDate": "2013-04-25T23:02:15.447", "ParentId": "16226150", "CommentCount": "0", "OwnerUserId": "2073257", "LastEditDate": "2013-04-26T19:37:56.747"}, "16226183": {"Id": "16226183", "PostTypeId": "2", "Body": "<p>Instead of asking for trouble, you should trust the string's own move constructor:</p>\n<pre><code>MyString operator+(MyString lhs, MyString rhs)\n{\n    lhs += std::move(rhs);\n    return std::move(lhs);\n}\n</code></pre>\n<p>Now both <code>MyString x = a + b;</code> and <code>MyString y = MyString(\"a\") + MyString(\"b\");</code> work efficiently.</p>\n", "LastActivityDate": "2013-04-25T23:05:57.977", "CommentCount": "4", "CreationDate": "2013-04-25T23:05:57.977", "ParentId": "16226150", "Score": "5", "OwnerUserId": "596781"}, "bq_ids": {"n4140": {"so_16226150_16226151_6": {"length": 8, "quality": 0.8888888888888888, "section_id": 3906}, "so_16226150_16226151_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 3906}}, "n3337": {"so_16226150_16226151_6": {"length": 8, "quality": 0.8888888888888888, "section_id": 3766}, "so_16226150_16226151_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 3766}}, "n4659": {"so_16226150_16226151_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 4792}}}, "16226150": {"ViewCount": "964", "Body": "<p>Consider the following code:</p>\n<pre><code>struct MyString\n{\n  // some ctors\n\n  MyString&amp; operator+=( const MyString&amp; other ); // implemented correctly\n};\n\nMyString operator+( const MyString&amp; lhs, const MyString&amp; rhs )\n{\n  MyString nrv( lhs );\n  nrv += rhs;\n  return nrv;\n}\n\nMyString&amp;&amp; operator+( MyString&amp;&amp; lhs, const MyString&amp; rhs )\n{\n  lhs += rhs;\n  return std::move( lhs ); // return the rvalue reference we received as a parameter!\n}\n</code></pre>\n<p>This works for the following use-case</p>\n<pre><code>MyString a, b, c; // initialized properly\nMyString result = a + b + c;\n</code></pre>\n<p>But it creates a dangling reference for</p>\n<pre><code>const MyString&amp; result = a + b + c;\n</code></pre>\n<p>Now, I understand why that is and how to fix it (returning an ravlue instead of an rvalue reference) but I consider it a usage error if someone writes the above as the code looks like it is asking for trouble. Is there any \"canonical\" real-world example where the above operator returning a rvalue reference is a problem? What is a convincing reason why I should always return an rvalue from operators?</p>\n", "AcceptedAnswerId": "16226151", "Title": "Can I reuse an rvalue reference parameter to return an rvalue reference?", "CreationDate": "2013-04-25T23:02:15.447", "Id": "16226150", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-04-26T19:37:56.747", "Score": "6", "OwnerUserId": "2073257", "Tags": "<c++><c++11><operator-overloading><rvalue-reference>", "AnswerCount": "2"}});