post_cb({"4297110": {"Id": "4297110", "PostTypeId": "2", "Body": "<p>The standard (9.6/2) only allows 0 length bit-fields as a <strong>special case</strong> :</p>\n<blockquote>\n<p id=\"so_4297095_4297110_0\">As a special case, an unnamed\n  bit-field with a width of zero\n  specifies alignment of the next\n  bit-field at an allocation unit\n  boundary. <strong>Only when declaring an\n  unnamed bit-field may the\n  constant-expression be a value equal\n  to zero</strong>.</p>\n</blockquote>\n<p>The only use is described in this quote, although I've never encountered it in practical code yet.</p>\n<hr>\n<p>For the record, I just tried the following code under VS 2010 :</p>\n<pre><code>struct X {\n    int i : 3, j : 5;\n};\n\nstruct Y {\n    int i : 3, : 0, j : 5; // nice syntax huh ?\n};\n\nint main()\n{\n    std::cout &lt;&lt; sizeof(X) &lt;&lt; \" - \" &lt;&lt; sizeof(Y) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The output on my machine is indeed : <code>4 - 8</code>.</p>\n</hr>", "LastEditorUserId": "451980", "LastActivityDate": "2010-11-28T14:14:09.600", "Score": "18", "CreationDate": "2010-11-28T14:04:46.890", "ParentId": "4297095", "CommentCount": "1", "OwnerUserId": "451980", "LastEditDate": "2010-11-28T14:14:09.600"}, "4297095": {"ViewCount": "4199", "Body": "<p>I am not totally sure about C, but C++ allows unnamed bit-fields of 0 length. For example:</p>\n<pre><code>struct X\n{\n    int : 0;\n};\n</code></pre>\n<ul>\n<li><strong>Question one: What practical uses of this can <em>you</em> think of?</strong> </li>\n<li><strong>Question two: What real-world practical uses (if any) are you aware of?</strong></li>\n</ul>\n<p><em><strong>Edited</strong></em></p> the example after ice-crime's answer\n<p><em><strong>Edit:</strong></em></p> OK, thanks to the current answers I now know the theoretical purpose. But the questions are about practical uses so they still hold :)\n", "AcceptedAnswerId": "4298148", "Title": "Practical Use of Zero-Length Bitfields", "CreationDate": "2010-11-28T13:58:33.540", "Id": "4297095", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2011-11-29T23:52:25.007", "LastEditorUserId": "469935", "LastActivityDate": "2016-05-05T07:05:27.830", "Score": "18", "OwnerUserId": "469935", "Tags": "<c++><c><bit-fields>", "AnswerCount": "4"}, "12918937": {"Id": "12918937", "PostTypeId": "2", "Body": "<pre><code>struct X { int : 0; };\n</code></pre>\n<p>is undefined behavior in C.</p>\n<p>See (emphasis mine):</p>\n<blockquote>\n<p id=\"so_4297095_12918937_0\">(C99, 6.7.2.1p2) \"The presence of a struct-declaration-list in a struct-or-union-specifier declares a new type, within a translation unit. The struct-declaration-list is a sequence of declarations for the members of the structure or union. <strong>If the struct-declaration-list contains no named members, the behavior is undefined</strong>\"</p>\n</blockquote>\n<p>(C11 has the same wording.)</p>\n<p>You can use an unnamed bit-field with <code>0</code> width but not if there is no other named member in the structure.</p>\n<p>For example:</p>\n<pre><code>struct W { int a:1; int :0; };  // OK\nstruct X { int :0; };           // Undefined Behavior\n</code></pre>\n<p>By the way for the second declaration, <code>gcc</code> issues a diagnostic (not required by the C Standard) with <code>-pedantic</code>.</p>\n<p>On the other hand:</p>\n<pre><code> struct X { int :0; };\n</code></pre>\n<p>is defined in GNU C. It is used for example by the Linux kernel (<code>include/linux/bug.h</code>) to force a compilation error using the following macro if the condition is true:</p>\n<pre><code>#define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))\n</code></pre>\n", "LastActivityDate": "2012-10-16T16:08:58.157", "CommentCount": "1", "CreationDate": "2012-10-16T16:08:58.157", "ParentId": "4297095", "Score": "6", "OwnerUserId": "1119701"}, "4297118": {"Id": "4297118", "PostTypeId": "2", "Body": "<p>This is from MSDN and not marked as Microsoft Specific, so I guess this is common C++ standard:</p>\n<p>An unnamed bit field of width 0 forces alignment of the next bit field to the next type boundary, where type is the type of the member.</p>\n", "LastActivityDate": "2010-11-28T14:05:49.120", "CommentCount": "0", "CreationDate": "2010-11-28T14:05:49.120", "ParentId": "4297095", "Score": "5", "OwnerUserId": "279313"}, "bq_ids": {"n4140": {"so_4297095_4297110_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 5922}}, "n3337": {"so_4297095_4297110_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 5694}}, "n4659": {"so_4297095_4297110_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 7396}}}, "4298148": {"Id": "4298148", "PostTypeId": "2", "Body": "<p>You use a zero-length bitfield as a hacky way to get your compiler to lay out a structure to match some external requirement, be it another compiler's or architecture's notion of the layout (cross-platform data structures, such as in a binary file format) or a bit-level standard's requirements (network packets or instruction opcodes).</p>\n<p>A real-world example is when NeXT ported the xnu kernel from the Motorola 68000 (m68k) architecture to the i386 architecture. NeXT had a working m68k version of their kernel. When they ported it to i386, they found that the i386's alignment requirements differed from the m68k's in such a way that an m68k machine and an i386 machine did not agree on the layout of the NeXT vendor-specific BOOTP structure. In order to make the i386 structure layout agree with the m68k, they added an unnamed bitfield of length zero to force the <code>NV1</code> structure/<code>nv_U</code> union to be 16-bit aligned.</p>\n<p>Here are the relevant parts from the Mac OS X 10.6.5 xnu source code:</p>\n<pre><code>/* from xnu/bsd/netinet/bootp.h */\n/*\n * Bootstrap Protocol (BOOTP).  RFC 951.\n */\n/*\n * HISTORY\n *\n * 14 May 1992 ? at NeXT\n *  Added correct padding to struct nextvend.  This is\n *  needed for the i386 due to alignment differences wrt\n *  the m68k.  Also adjusted the size of the array fields\n *  because the NeXT vendor area was overflowing the bootp\n *  packet.\n */\n/* . . . */\nstruct nextvend {\n  u_char nv_magic[4]; /* Magic number for vendor specificity */\n  u_char nv_version;  /* NeXT protocol version */\n  /*\n   * Round the beginning\n   * of the union to a 16\n   * bit boundary due to\n   * struct/union alignment\n   * on the m68k.\n   */\n  unsigned short  :0;\n  union {\n    u_char NV0[58];\n    struct {\n      u_char NV1_opcode;  /* opcode - Version 1 */\n      u_char NV1_xid; /* transcation id */\n      u_char NV1_text[NVMAXTEXT]; /* text */\n      u_char NV1_null;  /* null terminator */\n    } NV1;\n  } nv_U;\n};\n</code></pre>\n", "LastActivityDate": "2010-11-28T17:59:02.683", "CommentCount": "0", "CreationDate": "2010-11-28T17:59:02.683", "ParentId": "4297095", "Score": "25", "OwnerUserId": "72508"}});