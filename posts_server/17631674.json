post_cb({"17631885": {"ParentId": "17631674", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The C++ standard states that it is assumed that no non-constant function will be applied via the dereferenced iterators, first by stating it in terms of the <code>Compare</code> functor that can be passed to <code>sort</code>:</p>\n<blockquote>\n<p id=\"so_17631674_17631885_0\"><code>Compare</code> is a function object type (20.8). The return value of the function call operation applied to an object\n  of type <code>Compare</code>, when contextually converted to bool (4), yields true if the first argument of the call is\n  less than the second, and false otherwise. <code>Compare</code> <code>comp</code> is used throughout for algorithms assuming an\n  ordering relation. <strong>It is assumed that <code>comp</code> will not apply any non-constant function through the dereferenced\n  iterator</strong>.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>and then, by stating the relation between <code>Compare</code> and <code>operator&lt;</code>:</p>\n<blockquote>\n<p id=\"so_17631674_17631885_1\">For all algorithms that take <code>Compare</code>, there is a version that uses <code>operator&lt;</code> instead. That is, <code>comp(*i,\n  *j) != false</code> defaults to <code>*i &lt; *j != false</code>. For algorithms other than those described in 25.4.3 to work\n  correctly, <code>comp</code> has to induce a strict weak ordering on the values.</p>\n</blockquote>\n<p>Both quotes from . From <strong>25.4 Sorting and related operations</strong>.</p>\n<p>So, although it is not explicitly stated that a member <code>operator&lt;</code> has to be <code>const</code>, the assumption that it is means it must be. It would not make sense to place restrictions on <code>comp</code> and not on <code>operator&lt;</code>.</p>\n<p>I would say Visual C++ is at fault here since it allows for non-const functions to be called on the dereferenced iterators.</p>\n", "OwnerUserId": "661519", "LastEditorUserId": "661519", "LastEditDate": "2013-07-13T16:10:59.793", "Id": "17631885", "Score": "3", "CreationDate": "2013-07-13T16:05:29.033", "LastActivityDate": "2013-07-13T16:10:59.793"}, "bq_ids": {"n4140": {"so_17631674_17631885_0": {"section_id": 1394, "quality": 0.9555555555555556, "length": 43}, "so_17631674_17631885_1": {"section_id": 1395, "quality": 0.8666666666666667, "length": 26}}, "n3337": {"so_17631674_17631885_1": {"section_id": 1389, "quality": 0.8666666666666667, "length": 26}, "so_17631674_17631885_0": {"section_id": 1388, "quality": 0.9555555555555556, "length": 43}}, "n4659": {"so_17631674_17631885_0": {"section_id": 1512, "quality": 0.9555555555555556, "length": 43}, "so_17631674_17631885_1": {"section_id": 1513, "quality": 0.8, "length": 24}}}, "17631674": {"CommentCount": "1", "ViewCount": "400", "CreationDate": "2013-07-13T15:40:59.963", "LastActivityDate": "2013-07-13T16:10:59.793", "Title": "Visual C++ relational operator overloading const correctness (with std::sort)", "AcceptedAnswerId": "17631885", "PostTypeId": "1", "Id": "17631674", "Score": "3", "Body": "<p>In the example code below, the overloaded operator&lt; was not const qualified, and it compiles under Visual C++ (all versions up to 2013 Preview), but under Clang, it throws an error - note: candidate function not viable: 'this' argument has type 'const Entry', but method is not marked const bool operator&lt;( const Entry&amp; other ).</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nstruct Entry\n{\n    unsigned int age;\n    bool operator&lt;( const Entry&amp; other ) // !!! no const qualification here !!!\n    {\n        return age &lt; other.age;\n    }\n};\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    std::vector&lt;Entry&gt; entries;\n    for( unsigned int i = 0; i &lt; 100; ++i )\n    {\n        Entry entry;\n        entry.age = i;\n        entries.push_back( entry );\n    }\n    // Sort by age\n    std::sort( entries.begin(), entries.end() );\n    return 0;\n}\n</code></pre>\n<p>Is Visual C++ not standard conforming in enforcing the const-correctness of the comparison/relational operators? Or this is something to do with std::sort?</p>\n", "Tags": "<c++><operator-overloading><const-correctness>", "OwnerUserId": "1559050", "AnswerCount": "1"}});