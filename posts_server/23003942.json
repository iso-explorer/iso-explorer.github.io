post_cb({"bq_ids": {"n4140": {"so_23003942_23013978_1": {"length": 18, "quality": 1.0, "section_id": 4718}, "so_23003942_23013978_0": {"length": 4, "quality": 1.0, "section_id": 4710}, "so_23003942_23013978_2": {"length": 11, "quality": 1.0, "section_id": 2}}, "n3337": {"so_23003942_23013978_1": {"length": 18, "quality": 1.0, "section_id": 4525}, "so_23003942_23013978_0": {"length": 4, "quality": 1.0, "section_id": 4518}, "so_23003942_23013978_2": {"length": 11, "quality": 1.0, "section_id": 2}}, "n4659": {"so_23003942_23013978_1": {"length": 18, "quality": 1.0, "section_id": 6117}, "so_23003942_23013978_2": {"length": 11, "quality": 1.0, "section_id": 2}}}, "23013978": {"Id": "23013978", "PostTypeId": "2", "Body": "<p><code>is_convertible</code> is defined as follows in [meta.rel]/4 from n3485:</p>\n<blockquote>\n<p id=\"so_23003942_23013978_0\">Given the following function prototype:</p>\n<pre><code>template &lt;class T&gt; typename\nadd_rvalue_reference&lt;T&gt;::type create();\n</code></pre>\n<p id=\"so_23003942_23013978_1\">the predicate condition for a template specialization <code>is_convertible&lt;From, To&gt;</code>\n  shall be satisfied if and only if the return expression in the following code would be\n  well-formed, including any implicit conversions to the return type of\n  the function:</p>\n<pre><code>To test() {\n    return create&lt;From&gt;();\n}\n</code></pre>\n</blockquote>\n<p>and here, you need a movable/copyable <code>To</code>: The return-statement applies an implicit conversion, and this requires an accessible copy/move constructor if <code>To</code> is a class type (<code>T&amp;</code> is not a class type).</p>\n<p>Compare to [conv]/3</p>\n<blockquote>\n<p id=\"so_23003942_23013978_2\">An expression <code>e</code> can be implicitly converted to a type <code>T</code> if and only if the declaration <code>T t=e;</code> is well-formed, for some invented temporary variable <code>t</code>.</p>\n</blockquote>\n<hr>\n<p>If <code>From</code> is <code>T&amp;</code>, you get something like</p>\n<pre><code>To test() {\n    return create&lt;T&amp;&gt;();\n}\n</code></pre>\n<p>which, similar to <code>std::declval</code>, is an lvalue: The expression <code>create&lt;T&amp;&gt;()</code> is/yields an lvalue, since <code>T&amp; &amp;&amp;</code> (via <code>add_rvalue_reference</code>) is collapsed to <code>T&amp;</code>.</p>\n</hr>", "LastEditorUserId": "420683", "LastActivityDate": "2014-04-11T13:41:31.347", "Score": "6", "CreationDate": "2014-04-11T13:27:49.597", "ParentId": "23003942", "CommentCount": "2", "OwnerUserId": "420683", "LastEditDate": "2014-04-11T13:41:31.347"}, "23003942": {"ViewCount": "508", "Body": "<p>I'm trying to understand <code>std::is_convertible</code> in C++11. According to <a href=\"http://en.cppreference.com/w/cpp/types/is_convertible\" rel=\"nofollow\">cppreference.com</a>, <code>std::is_convertible&lt;T,U&gt;::value</code> should evaluate to 1 iff \"If an imaginary rvalue of type <code>T</code> can be used in the return statement of a function returning <code>U</code>\". The wording says nothing about where that function might be declared, though. What should one expect when the copy constructor of <code>U</code> is private? What should one expect when <code>T</code> is an lvalue reference?</p>\n<p>E.g., consider this code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\nstruct Fact_A;\nstruct A {\n    friend struct Fact_A;\n    A() = default;\n    A(A&amp;&amp;) = delete;\nprivate:\n    A(const A&amp;) = default;\n};\nstruct Ref_A {\n    A* _ptr;\n    Ref_A(A* ptr) : _ptr(ptr) {}\n    operator A&amp; () { return *_ptr; }\n};\nstruct Fact_A {\n    static A* make_A(const A&amp; a) { return new A(a); }\n    static A f(A* a_ptr) { return Ref_A(a_ptr); }\n    //static A g(A&amp;&amp; a) { return std::move(a); }\n};\nint main() {\n    A a1;\n    A* a2_ptr = Fact_A::make_A(a1);\n    (void)a2_ptr;\n    std::cout &lt;&lt; std::is_convertible&lt; Ref_A, A &gt;::value &lt;&lt; \"\\n\"  // =&gt; 0\n              &lt;&lt; std::is_convertible&lt; Ref_A, A&amp; &gt;::value &lt;&lt; \"\\n\" // =&gt; 1\n              &lt;&lt; std::is_convertible&lt; A&amp;, A &gt;::value &lt;&lt; \"\\n\";    // =&gt; 0\n}\n</code></pre>\n<p>I'm using <code>gcc-4.8.2</code> or <code>clang-3.4</code> (no difference in output), and I compile with:</p>\n<pre><code>{g++|clang++} -std=c++11 -Wall -Wextra eg.cpp -o eg\n</code></pre>\n<p>Here, <code>std::is_convertible&lt; Ref_A, A &gt;</code> reports <code>0</code>. However, you can see that <code>Fact_A::f</code> returns an object of type <code>A</code>, and an rvalue of type <code>Ref_A</code> is used in its return statement. The problem is that the copy constructor of <code>A</code> is <code>private</code>, so that function cannot be placed anywhere else. Is the current behaviour correct with respect to the standard?</p>\n<p>Second question. If I remove <code>private</code>, the output turns into <code>1 1 1</code>. What does the last <code>1</code> mean? What is an \"rvalue of type <code>A&amp;</code>\"? Is that an rvalue reference? Because you might notice I explicitly deleted the move constructor of <code>A</code>. As a result of this, I cannot declare <code>Fact_A::g</code>. But still, <code>std::is_convertible&lt; A&amp;, A &gt;</code> reports <code>1</code>.</p>\n", "AcceptedAnswerId": "23013978", "Title": "C++11 std::is_convertible behaviour with private copy constructor", "CreationDate": "2014-04-11T05:06:51.727", "Id": "23003942", "CommentCount": "0", "LastEditDate": "2014-04-11T13:21:29.867", "PostTypeId": "1", "LastEditorUserId": "717706", "LastActivityDate": "2014-04-11T13:41:31.347", "Score": "7", "OwnerUserId": "717706", "Tags": "<c++><c++11><std><language-lawyer><typetraits>", "AnswerCount": "1"}});