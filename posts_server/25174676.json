post_cb({"bq_ids": {"n4140": {"so_25174676_25174744_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 3921}}, "n3337": {"so_25174676_25174744_1": {"length": 20, "quality": 0.7692307692307693, "section_id": 3781}}, "n4659": {"so_25174676_25174744_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 4807}}}, "25174676": {"ViewCount": "231", "Body": "<p>In c++11, constructor can be forwarded to another constructor in the initialization list.</p>\n<p>It is fine to call function in initialization list as in this <a href=\"https://stackoverflow.com/questions/4162021/is-it-ok-to-call-a-function-in-constructor-initializer-list\">question</a></p>\n<p>Is it also fine to call function in the constructor delegate?</p>\n<p>I tried code like this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;yaml-cpp/yaml.h&gt;\n\nusing namespace std;\n\nYAML::Node ParseFromFile(const string&amp; filepath) {\n  YAML::Node yaml;\n  try {\n    return YAML::LoadFile(filepath);\n  } catch(const YAML::BadFile&amp; e) {\n    cout &lt;&lt; \"error\";\n  }\n}\n\nclass A {\n public:\n  A(YAML::Node yaml) {\n    cout  &lt;&lt; \"Got\" &lt;&lt; endl;\n  }\n  A(const string&amp; filepath) : A(ParseFromFile(filepath)) {}\n};\n\n\nint main(int argc, char** argv) {\n  A a(string(argv[1]));\n  YAML::Node yaml = ParseFromFile(string(argv[1]));\n  A b(yaml);\n  return 0;\n}\n</code></pre>\n<p>For the above code, just pass an empty file to it, it will only print one \"Got\" during the initialization of b.</p>\n<p>=======================================================================</p>\n<p>Replacing string(argv[1]) with argv[1] makes it work, any ideas why?</p>\n", "AcceptedAnswerId": "25174744", "Title": "C++ calling function in constructor delegate", "CreationDate": "2014-08-07T05:16:44.513", "Id": "25174676", "CommentCount": "14", "LastEditDate": "2017-05-23T11:57:11.717", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-08-07T22:51:08.733", "Score": "-1", "OwnerUserId": "700535", "Tags": "<c++><c++11><constructor><initialization-list>", "AnswerCount": "1"}, "25174744": {"Id": "25174744", "PostTypeId": "2", "Body": "<h3> Answer to the edited question </h3>\n<hr>\n<p>The problem is the first line in the main it's treated as a function declaration and not as a variable initialization, in fact have you compiled it with clang it would've give you a warning about this: </p>\n<blockquote>\n<p id=\"so_25174676_25174744_0\">warning: parentheses were disambiguated as a function declaration</p>\n</blockquote>\n<p>This is due what is defined in <em>\u00a7 6.8  Ambiguity resolution</em> in the standard (AKA <a href=\"http://en.wikipedia.org/wiki/Most_vexing_parse\" rel=\"nofollow\">Most vexing parse</a>) (emphasis mine... ):</p>\n<blockquote>\n<p id=\"so_25174676_25174744_1\">There is an ambiguity in the grammar involving expression-statements\n  and declarations: An expression-statement with a function-style\n  explicit type conversion (5.2.3) as its leftmost subexpression can be\n  indistinguishable from a declaration where the first declarator starts\n  with a (. <strong>In those cases the statement is a declaration</strong>.</p>\n</blockquote>\n<p>Consider the following example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;exception&gt;\nusing namespace std;\n\nstruct A{\n    string a;\n    A(string s) : a(s){ cout&lt;&lt; \"Ctor\" &lt;&lt;endl;}\n    A(int i) : A(to_string(i)){ }\n};\n\nvoid foo (A (*a)(string*)){\n    cout&lt;&lt;\"yay\"&lt;&lt;endl;\n}\n\nint main(int argc, char** argv) {\n    A         a1(     string(argv[1]) ); // function A a1(std::string*) declaration not a variable \n/*  ^         ^       ^\n    |         |       |\nreturn type   name   arg type \nSame as foo\n*/\n    // foo(a1);//  &lt;- compiles but fails only due to linkage         \n    A  a2 = A(string(argv[1])); // works\n    A  a3{string(argv[1])}; // works\n    A  a4(string{argv[1]}); // works\n    A         a5(     ( string(argv[1]) ) ); // works allso but confusing imho\n/*                    ^                 ^\nnotice extra paren.   |                 |\n*/  \n    return 0;\n}\n</code></pre>\n<h3> Answer to the original question FWIW </h3>\n<hr>\n<p>Why not just try? </p>\n<p>There should be no problem unless you call a function that will use members that are still uninitialized.</p>\n<p>E.g (<a href=\"http://ideone.com/Uph36T\" rel=\"nofollow\">demo</a>):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nclass A {\n public:\n  A(string x) {\n    cout  &lt;&lt; \"Got \"  &lt;&lt; x &lt;&lt; endl;\n  }\n  A(int x) : A(std::to_string(x)) {}\n};\n\n\nint main() {\n    A a(15);\n    return 0;\n}\n</code></pre>\n</hr></hr>", "LastEditorUserId": "1941161", "LastActivityDate": "2014-08-07T22:51:08.733", "Score": "3", "CreationDate": "2014-08-07T05:22:58.593", "ParentId": "25174676", "CommentCount": "4", "OwnerUserId": "1941161", "LastEditDate": "2014-08-07T22:51:08.733"}});