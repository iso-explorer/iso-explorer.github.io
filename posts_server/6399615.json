post_cb({"36094047": {"Body": "<h3><strong>Language Features</strong></h3>\n<ol>\n<li>Uniform and general initialization using {}</li>\n<li>auto</li>\n<li>Prevention of narrowing</li>\n<li>constexpr</li>\n<li>Range based for loop</li>\n<li>nullptr</li>\n<li>enum class</li>\n<li>static_assert</li>\n<li>std::initializer_list</li>\n<li>Rvalue references (move semantics)</li>\n<li><code>&gt;&gt;</code></li>\n<li>Lambdas</li>\n<li>Variadic templates</li>\n<li>Type and template aliases</li>\n<li>Unicode characters</li>\n<li>long long integer type</li>\n<li>alignas and alignof</li>\n<li>decltype</li>\n<li>Raw string literals</li>\n<li>Generalized POD</li>\n<li>Generalized unions</li>\n<li>Local classes as template arguments</li>\n<li>Suffix return type syntax</li>\n<li>[[carries_dependency]] and [[noreturn]]</li>\n<li>noexcept specifier</li>\n<li>noexcept operator.</li>\n<li>C99 features: \n\n<ul>\n<li>extended integral types</li>\n<li>concatenation of narrow/wide string</li>\n<li>_ _ STDC_HOSTED _ _</li>\n<li>_Pragma(X)</li>\n<li>vararg macros and empty macro arguments</li>\n</ul></li>\n<li>_ _ func _ _ </li>\n<li>Inline namespaces</li>\n<li>Delegating constructors</li>\n<li>In-class member initializers</li>\n<li>default and delete</li>\n<li>Explicit conversion operators</li>\n<li>User-defined literals</li>\n<li>Extern templates</li>\n<li>Default template arguments for function templates</li>\n<li>Inheriting constructors</li>\n<li>override and final</li>\n<li>Simpler and more general SFINAE rule</li>\n<li>Memory model</li>\n<li>thread_local</li>\n</ol>\n<h3><strong>Standard-Library Components</strong></h3>\n<ol>\n<li>initializer_list for containers</li>\n<li>Move semantics for containers</li>\n<li>forward_list</li>\n<li>Hash containers\n\n<ul>\n<li>unordered_map</li>\n<li>unordered_multimap</li>\n<li>unordered_set</li>\n<li>unordered_multiset</li>\n</ul></li>\n<li>Resource management pointers\n\n<ul>\n<li>unique_ptr</li>\n<li>shared_ptr</li>\n<li>weak_ptr</li>\n</ul></li>\n<li>Concurrency support\n\n<ul>\n<li>thread</li>\n<li>mutexes</li>\n<li>locks</li>\n<li>condition variables</li>\n</ul></li>\n<li>Higher-level concurrency support\n\n<ul>\n<li>packaged_thread</li>\n<li>future</li>\n<li>promise</li>\n<li>async</li>\n</ul></li>\n<li>tuples</li>\n<li>regex</li>\n<li>Random numbers\n\n<ul>\n<li>uniform_int_distribution</li>\n<li>normal_distribution</li>\n<li>random_engine</li>\n<li>etc.</li>\n</ul></li>\n<li>Integer type names, such as int16_t , uint32_t , and int_fast64_t</li>\n<li>array</li>\n<li>Copying and rethrowing exceptions</li>\n<li>system_error</li>\n<li>emplace() operations for containers</li>\n<li>constexpr functions</li>\n<li>Systematic use of noexcept functions</li>\n<li>function and bind</li>\n<li>String to numeric value conversions</li>\n<li>Scoped allocators</li>\n<li>Type traits</li>\n<li>Time utilities: duration and time_point</li>\n<li>ratio</li>\n<li>quick_exit</li>\n<li>More algorithms, such as move() , copy_if() , and is_sorted()</li>\n<li>Garbage collection ABI</li>\n<li>atomics</li>\n</ol>\n<h3><strong>Deprecated Features</strong></h3>\n<ol>\n<li>Generation of the copy constructor and the copy assignment for a class with a destructor.</li>\n<li>Assign a string literal to a char *.</li>\n<li>C++98 exception specification\n\n<ul>\n<li>unexcepted_handler</li>\n<li>set_unexpected</li>\n<li>get_unexpected</li>\n<li>unexpected</li>\n</ul></li>\n<li>Function objects and associated functions</li>\n<li>auto_ptr</li>\n<li>register</li>\n<li>++ on a bool</li>\n<li>export</li>\n<li>C-style casts</li>\n</ol>\n", "CreationDate": "2016-03-18T20:54:37.243", "ParentId": "6399615", "CommentCount": "1", "LastEditDate": "2016-03-20T19:29:11.910", "Id": "36094047", "PostTypeId": "2", "LastActivityDate": "2016-03-20T19:29:11.910", "LastEditorUserId": "3111051", "CommunityOwnedDate": "2016-03-18T20:54:37.243", "Score": "0", "OwnerUserId": "3111051"}, "6402166": {"Body": "<p>The FDIS has a section for incompatibilities, at appendix <code>C.2</code> \"C++ and ISO C++ 2003\".</p>\n<p>Summary, paraphrasing the FDIS here, to make it (better) suitable as a SO answer. I added some examples of my own to illustrate the differences. </p>\n<p>There are a few library-related incompatibilities where I don't exactly know the implications of, so I leave those for others to elaborate on. </p>\n<h2>Core language</h2>\n<hr>\n<pre><code>#define u8 \"abc\"\nconst char *s = u8\"def\"; // Previously \"abcdef\", now \"def\"\n</code></pre>\n<hr>\n<pre><code>#define _x \"there\"\n\"hello\"_x // now a user-defined-string-literal. Previously, expanded _x .\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_0\">New keywords: alignas, alignof, char16_t, char32_t, constexpr, decltype, noexcept, nullptr, static_assert, and thread_local</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_1\">Certain integer literals larger than can be represented by long could change from an unsigned integer type to signed long long.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_2\">Valid C++ 2003 code that uses integer division rounds the result toward 0 or toward negative infinity, whereas C++0x always rounds the result toward 0.</p>\n</blockquote>\n<p>(admittedly not really a compatibility problem for most people).</p>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_3\">Valid C++ 2003 code that uses the keyword <code>auto</code> as a storage class specifier may be invalid in C++0x.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_4\">Narrowing conversions cause incompatibilities with C++03. For example, the following code is valid in C++ 2003 but invalid in this International Standard because double to int is a narrowing conversion:</p>\n</blockquote>\n<pre><code>int x[] = { 2.0 };\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_5\">Implicitly-declared special member functions are de\ufb01ned as deleted when the implicit definition would have been ill-formed.</p>\n<p id=\"so_6399615_6402166_6\">A valid C++ 2003 program that uses one of these special member functions in a context where the definition is not required (e.g., in an expresion that is not potentially evaluated) becomes ill-formed.</p>\n</blockquote>\n<p>Example by me:</p>\n<pre><code>struct A { private: A(); };\nstruct B : A { };\nint main() { sizeof B(); /* valid in C++03, invalid in C++0x */ }\n</code></pre>\n<p>Such sizeof tricks have been used by some SFINAE, and needs to be changed now :)</p>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_7\">User-declared destructors have an implicit exception specification.</p>\n</blockquote>\n<p>Example by me:</p>\n<pre><code>struct A {\n  ~A() { throw \"foo\"; }\n};\n\nint main() { try { A a; } catch(...) { } }\n</code></pre>\n<p>This code calls <code>terminate</code> in C++0x, but does not in C++03. Because the implicit exception specification of <code>A::~A</code> in C++0x is <code>noexcept(true)</code>. </p>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_8\">A valid C++ 2003 declaration containing <code>export</code> is ill-formed in C++0x. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_9\">A valid C++ 2003 expression containing <code>&gt;</code> followed immediately by another <code>&gt;</code> may now be treated as closing two templates.</p>\n</blockquote>\n<p>In C++03, <code>&gt;&gt;</code> would always be the shift-operator token. </p>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_10\">Allow dependent calls of functions with internal linkage.</p>\n</blockquote>\n<p>Example by me:</p>\n<pre><code>static void f(int) { }\nvoid f(long) { }\n\ntemplate&lt;typename T&gt;\nvoid g(T t) { f(t); }\n\nint main() { g(0); }\n</code></pre>\n<p>In C++03, this calls <code>f(long)</code>, but in C++0x, this calls <code>f(int)</code>. It should be noted that in both C++03 and C++0x, the following calls <code>f(B)</code> (the instantiation context still only considers extern linkage declarations).</p>\n<pre><code>struct B { };\nstruct A : B { };\n\ntemplate&lt;typename T&gt;\nvoid g(T t) { f(t); }\n\nstatic void f(A) { }\nvoid f(B) { }\n\nint main() { A a; g(a); }\n</code></pre>\n<p>The better matching <code>f(A)</code> is not taken, because it does not have external linkage.</p>\n<hr>\n<h2>Library changes</h2>\n<blockquote>\n<p id=\"so_6399615_6402166_11\">Valid C++ 2003 code that uses any identifiers added to the C++ standard\n  library of C++0x may fail to compile or produce different results in This International Standard. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_12\">Valid C++ 2003 code that <code>#includes</code> headers with names of new C++0x standard library headers may be invalid in this International Standard.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_13\">Valid C++ 2003 code that has been compiled expecting swap to be in <code>&lt;algorithm&gt;</code> may have to instead include <code>&lt;utility&gt;</code></p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_14\">The global namespace <code>posix</code> is now reserved for standardization.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_6399615_6402166_15\">Valid C++ 2003 code that defines <code>override</code>, <code>final</code>, <code>carries_dependency</code>, or <code>noreturn</code> as macros is invalid in C++0x.</p>\n</blockquote>\n</hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr>", "CreationDate": "2011-06-19T11:47:39.270", "ParentId": "6399615", "CommentCount": "9", "LastEditDate": "2011-06-19T14:16:16.153", "Id": "6402166", "PostTypeId": "2", "LastActivityDate": "2011-06-19T14:16:16.153", "LastEditorUserId": "34509", "CommunityOwnedDate": "2011-06-19T15:01:26.517", "Score": "164", "OwnerUserId": "34509"}, "6399740": {"Body": "<p>There are numerous changes to the containers library that allow more efficient code but silently break backwards compatibility for a few corner cases.  </p>\n<p>Consider, for example, <a href=\"https://stackoverflow.com/questions/5759232/stdvector-default-construction-c0x-and-breaking-changes/5759296#5759296\"><code>std::vector</code>, default construction, C++0x, and breaking changes</a>.</p>\n", "CreationDate": "2011-06-19T00:19:47.903", "ParentId": "6399615", "CommentCount": "0", "LastEditDate": "2017-05-23T12:17:29.030", "Id": "6399740", "PostTypeId": "2", "LastActivityDate": "2011-06-19T00:19:47.903", "LastEditorUserId": "-1", "CommunityOwnedDate": "2011-06-19T15:01:26.517", "Score": "8", "OwnerUserId": "151292"}, "6399657": {"Id": "6399657", "PostTypeId": "2", "Body": "<p>The meaning of the auto keyword changed.</p>\n", "LastActivityDate": "2011-06-19T00:00:26.683", "Score": "27", "CreationDate": "2011-06-19T00:00:26.683", "ParentId": "6399615", "CommentCount": "4", "OwnerUserId": "353253", "CommunityOwnedDate": "2011-06-19T15:01:26.517"}, "6399665": {"Id": "6399665", "PostTypeId": "2", "Body": "<pre><code>struct x {\n   x(int) {}\n};\n\nvoid f(auto x = 3) { }\n\nint main() {\n   f();\n}\n</code></pre>\n<p><strong>C++03:</strong> valid.</p>\n<p><strong>C++0x:</strong> <code>error: parameter declared 'auto'</code></p>\n", "LastActivityDate": "2011-06-19T00:02:22.093", "Score": "6", "CreationDate": "2011-06-19T00:02:22.093", "ParentId": "6399615", "CommentCount": "9", "OwnerUserId": "560648", "CommunityOwnedDate": "2011-06-19T15:01:26.517"}, "6399720": {"Body": "<p>There's been a lot of discussion of <a href=\"http://web.archive.org/web/20130127123111/http://cpp-next.com/archive/2011/02/w00t-w00t-nix-nix/\" rel=\"nofollow\">implicit move breaking backward compatibility</a></p>\n<p>(<a href=\"http://web.archive.org/web/20140110035813/http://cpp-next.com/archive/2010/10/implicit-move-must-go/\" rel=\"nofollow\">an older page with relevant discussion</a>)</p>\n<p>If you read down into the comments, implicit move return is also a breaking change.</p>\n", "CreationDate": "2011-06-19T00:15:26.673", "ParentId": "6399615", "CommentCount": "5", "LastEditDate": "2015-09-24T06:58:37.817", "Id": "6399720", "PostTypeId": "2", "LastActivityDate": "2015-09-24T06:58:37.817", "LastEditorUserId": "880928", "CommunityOwnedDate": "2011-06-19T15:01:26.517", "Score": "7", "OwnerUserId": "103167"}, "6399639": {"Id": "6399639", "PostTypeId": "2", "Body": "<p>Breaking change?</p>\n<p>Well, for one thing, if you used <code>decltype</code>, <code>constexpr</code>, <code>nullptr</code>, etc. as identifiers then you may be in trouble...</p>\n", "LastActivityDate": "2011-06-18T23:54:01.223", "Score": "23", "CreationDate": "2011-06-18T23:54:01.223", "ParentId": "6399615", "CommentCount": "0", "OwnerUserId": "791928", "CommunityOwnedDate": "2011-06-19T15:01:26.517"}, "bq_ids": {"n4140": {"so_6399615_19523324_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 6536}, "so_6399615_19523324_1": {"length": 5, "quality": 0.625, "section_id": 6536}, "so_6399615_6402166_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 5336}}, "n3337": {"so_6399615_19523324_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 6291}, "so_6399615_19523324_1": {"length": 5, "quality": 0.625, "section_id": 6291}, "so_6399615_6402166_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 5133}}, "n4659": {"so_6399615_19523324_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 8018}, "so_6399615_6402166_7": {"length": 4, "quality": 0.6666666666666666, "section_id": 384}, "so_6399615_19523324_1": {"length": 5, "quality": 0.625, "section_id": 8018}, "so_6399615_6402166_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 6757}}}, "6399615": {"ViewCount": "22665", "FavoriteCount": "86", "Title": "What breaking changes are introduced in C++11?", "CreationDate": "2011-06-18T23:48:26.233", "LastActivityDate": "2016-03-20T19:29:11.910", "CommentCount": "20", "Body": "<p>I know that at least one of the changes in C++11 that will cause some old code to stop compiling: the introduction of <code>explicit operator bool()</code> in the standard library, replacing old instances of <code>operator void*()</code>. Granted, the code that this will break is probably code that should not have been valid in the first place, but it's still a breaking change nonetheless: programs that used to be valid no longer are.</p>\n<p>Are there any other breaking changes?</p>\n", "CommunityOwnedDate": "2011-06-19T15:01:26.517", "PostTypeId": "1", "LastEditDate": "2013-04-15T03:25:31.723", "LastEditorUserId": "1131435", "Id": "6399615", "Score": "211", "OwnerUserId": "46642", "Tags": "<c++><c++11>", "AnswerCount": "10"}, "6402410": {"Body": "<p>Some core incompatibilities that are not covered by the incompatibilities section:</p>\n<hr>\n<p>C++0x treats the injected class name as a template, if the name is passed as an argument to a template template parameter, and as a type if it is passed to a template type parameter. </p>\n<p>Valid C++03 code may behave differently if it relies on the injected class name to be always a type in these scenarios. Example code <a href=\"http://llvm.org/bugs/show_bug.cgi?id=9551\" rel=\"noreferrer\">taken from my clang PR</a></p>\n<pre><code>template&lt;template&lt;typename&gt; class X&gt;\nstruct M { };\n\ntemplate&lt;template&lt;typename&gt; class X&gt;\nvoid g(int = 0); // #1\n\ntemplate&lt;typename T&gt;\nvoid g(long = 0); // #2\n\ntemplate&lt;typename T&gt;\nstruct A {\n  void f() {\n    g&lt;A&gt;(); /* is ambiguous in C++0x */\n    g&lt;A&gt;(1); /* should choose #1 in C++0x */\n  }\n};\n\nvoid h() {\n  A&lt;int&gt; a;\n  a.f();\n}\n</code></pre>\n<p>In C++03, the code calls the second <code>g</code> both times.</p>\n<hr>\n<p>C++0x makes some names that were dependent in C++03 to be now non-dependent. And requires name lookup for non-dependent qualified names that refer to members of the current class template to be repeated at instantiation, and requires verification that these names lookup the same way as done at the template definition context. </p>\n<p>Valid C++03 code that depends on the dominance rule may now not compile anymore because of this change.</p>\n<p>Example:</p>\n<pre><code>struct B { void f(); };\n\ntemplate&lt;typename T&gt;\nstruct A : virtual B { void f(); };\n\ntemplate&lt;typename T&gt;\nstruct C : virtual B, A&lt;T&gt; {\n  void g() { this-&gt;f(); }\n};\n\nint main() { C&lt;int&gt; c; c.g(); }\n</code></pre>\n<p>This valid C++03 code that calls <code>A&lt;int&gt;::f</code> is not valid in C++0x, because name lookup when instantiating will find <code>A&lt;int&gt;::f</code> as opposed to <code>B::f</code>, causing a conflict with the at-definition lookup.</p>\n<p>At this point, it is not clear whether that is a defect in the FDIS. The committee is aware of this and will evaluate the situation.</p>\n<hr>\n<p>A using declaration where the last part is the same as the identifier in the last part of the qualifier in the qualified name denoting a base class, that using declaration now names the constructor, instead of members with that name. </p>\n<p>Example:</p>\n<pre><code>struct A { protected: int B; };\ntypedef A B;\n\nstruct C : B {\n  // inheriting constructor, instead of bringing A::B into scope\n  using B::B;\n};\n\nint main() { C c; c.B = 0; }\n</code></pre>\n<p>The above example code is well-formed in C++03, but ill-formed in C++0x, as <code>A::B</code> is still inaccessible in <code>main</code>.</p>\n</hr></hr></hr>", "CreationDate": "2011-06-19T12:42:11.543", "ParentId": "6399615", "CommentCount": "0", "LastEditDate": "2012-03-23T10:09:43.310", "Id": "6402410", "PostTypeId": "2", "LastActivityDate": "2012-03-23T10:09:43.310", "LastEditorUserId": "34509", "CommunityOwnedDate": "2011-06-19T15:01:26.517", "Score": "21", "OwnerUserId": "34509"}, "19523324": {"Body": "<p>Stream extraction failure is treated differently.</p>\n<h3>Example</h3>\n<pre><code>#include &lt;sstream&gt;\n#include &lt;cassert&gt;\n\nint main()\n{\n   std::stringstream ss;\n   ss &lt;&lt; '!';\n\n   int x = -1;\n\n   assert(!(ss &gt;&gt; x)); // C++03 and C++11\n   assert(x == -1);    // C++03\n   assert(x == 0);     // C++11\n}\n</code></pre>\n<h3>Change proposal</h3>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3246.html#23\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3246.html#23</a></p>\n<h3>Standard reference</h3>\n<blockquote>\n<p id=\"so_6399615_19523324_0\"><code>[C++03: 22.2.2.1.2/11]:</code> The result of stage 2 processing can be one of</p>\n<ul>\n<li>A sequence of chars has been accumulated in stage 2 that is converted (according to the rules of <code>scanf</code>) to a value of the type of <code>val</code>. This value is stored in <code>val</code> and <code>ios_base::goodbit</code> is stored in <code>err</code>.</li>\n<li>The sequence of chars accumulated in stage 2 would have caused <code>scanf</code> to report an input failure. <code>ios_base::failbit</code> is assigned to <code>err</code>. <em>[ed: Nothing is stored in <code>val</code>.]</em></li>\n</ul>\n<p id=\"so_6399615_19523324_1\"><code>[C++11: 22.4.2.1.2/3]:</code> <em>[..]</em> The numeric value to be stored can be one of:</p>\n<ul>\n<li><strong>zero, if the conversion function fails to convert the entire field</strong>. <code>ios_base::failbit</code> is assigned to <code>err</code>.</li>\n<li>the most positive representable value, if the field represents a value too large positive to be represented in <code>val</code>. <code>ios_base::failbit</code> is assigned to <code>err</code>.</li>\n<li>the most negative representable value or zero for an unsigned integer type, if the field represents a value too large negative to be represented in <code>val</code>. <code>ios_base::failbit</code> is assigned to <code>err</code>.</li>\n<li>the converted value, otherwise.</li>\n</ul>\n<p id=\"so_6399615_19523324_2\">The resultant numeric value is stored in <code>val</code>.</p>\n</blockquote>\n<h3>Implementations</h3>\n<ul>\n<li><p><em>GCC 4.8</em> <a href=\"http://coliru.stacked-crooked.com/a/f3803a0f75a716b8\">correctly outputs for C++11</a>:</p>\n<blockquote>\n<p id=\"so_6399615_19523324_3\">Assertion `x == -1' failed</p>\n</blockquote></li>\n<li><p><em>GCC 4.5-4.8</em> <a href=\"http://coliru.stacked-crooked.com/a/f3803a0f75a716b8\">all output for C++03</a> the following, which would appear to be a bug:</p>\n<blockquote>\n<p id=\"so_6399615_19523324_4\">Assertion `x == -1' failed</p>\n</blockquote></li>\n<li><p><em>Visual C++ 2008 Express</em> correctly outputs for C++03:</p>\n<blockquote>\n<p id=\"so_6399615_19523324_5\">Assertion failed: x == 0</p>\n</blockquote></li>\n<li><p><em>Visual C++ 2012 Express</em> incorrectly outputs for C++11, which would appear to be a status-of-implementation issue:</p>\n<blockquote>\n<p id=\"so_6399615_19523324_6\">Assertion failed: x == 0</p>\n</blockquote></li>\n</ul>\n", "CreationDate": "2013-10-22T16:25:27.977", "ParentId": "6399615", "CommentCount": "0", "LastEditDate": "2013-10-22T16:58:11.590", "Id": "19523324", "PostTypeId": "2", "LastActivityDate": "2013-10-22T16:58:11.590", "LastEditorUserId": "560648", "CommunityOwnedDate": "2013-10-22T16:25:27.977", "Score": "13", "OwnerUserId": "560648"}, "6399633": {"Body": "<p><strike>How is the introduction of explicit conversion operators a breaking change? The old version will still just be as \"valid\" as before.</strike></p>\n<p>Yes, the change from <code>operator void*() const</code> to <code>explicit operator bool() const</code> will be a breaking change, but only if it is used in a way that is wrong in and out of itself. Conforming code won't be broken.</p>\n<p>Now, another breaking change is <a href=\"https://stackoverflow.com/questions/4434140/narrowing-conversions-in-c0x-is-it-just-me-or-does-this-sound-like-a-breaking\">the banning of narrowing conversions during aggregate initialization</a>:</p>\n<pre><code>int a[] = { 1.0 }; // error\n</code></pre>\n<hr>\n<p><strong>Edit</strong>: Just rememberer, <a href=\"https://stackoverflow.com/questions/5513110/why-use-identity-in-forward-definition-for-c0x-rvalue-reference/5513685#5513685\"><code>std::identity&lt;T&gt;</code> will be removed in C++0x</a> (see the note). It's a convenience struct to make types dependent. Since the struct really doesn't do much, this should fix it:</p>\n<pre><code>template&lt;class T&gt;\nstruct identity{\n  typedef T type;\n};\n</code></pre>\n</hr>", "CreationDate": "2011-06-18T23:52:27.410", "ParentId": "6399615", "CommentCount": "5", "LastEditDate": "2017-05-23T12:09:45.650", "Id": "6399633", "PostTypeId": "2", "LastActivityDate": "2011-06-19T07:42:07.320", "LastEditorUserId": "-1", "CommunityOwnedDate": "2011-06-19T15:01:26.517", "Score": "13", "OwnerUserId": "500104"}});