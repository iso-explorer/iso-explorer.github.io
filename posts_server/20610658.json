post_cb({"bq_ids": {"n4140": {"so_20610658_20616637_6": {"length": 56, "quality": 0.9824561403508771, "section_id": 3376}, "so_20610658_20616637_1": {"length": 13, "quality": 0.65, "section_id": 3271}, "so_20610658_20616637_4": {"length": 6, "quality": 1.0, "section_id": 3365}, "so_20610658_20616637_3": {"length": 7, "quality": 1.0, "section_id": 3365}, "so_20610658_20616637_5": {"length": 7, "quality": 1.0, "section_id": 3365}}, "n3337": {"so_20610658_20616637_6": {"length": 49, "quality": 0.8596491228070176, "section_id": 3246}, "so_20610658_20616637_3": {"length": 7, "quality": 1.0, "section_id": 3235}, "so_20610658_20616637_4": {"length": 6, "quality": 1.0, "section_id": 3235}, "so_20610658_20616637_1": {"length": 19, "quality": 0.95, "section_id": 3143}, "so_20610658_20616637_5": {"length": 7, "quality": 1.0, "section_id": 3235}}, "n4659": {"so_20610658_20616637_1": {"length": 13, "quality": 0.65, "section_id": 4029}, "so_20610658_20616637_5": {"length": 4, "quality": 0.5714285714285714, "section_id": 581}}}, "20610658": {"ViewCount": "1252", "Body": "<p>This code fails to compile with gcc 4.8.2 (-std=c++11) but compiles with clang 3.4 (trunk) (-std=c++11):</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\nstruct X {\n  X&amp; operator=(X&amp;&amp;) noexcept = default;\n  // adding noexcept this leads to an error in gcc, but works in clang:\n  // function \u2018X&amp; X::operator=(X&amp;&amp;)\u2019 defaulted on its first\n  // declaration with an exception-specification that differs from the\n  // implicit declaration \u2018X&amp; X::operator=(X&amp;&amp;)\u2019\n\n  std::vector&lt;char&gt; m;\n};\n\n// this assert holds, even without noexcept\nstatic_assert(std::is_nothrow_move_assignable&lt;X&gt;::value, \n              \"type-specification violation\");\n\nint main()\n{\n  return 0;\n}\n</code></pre>\n<p>The <code>static_assert</code> is the interesting part on gcc: the defaulted move assignment will be <code>noexcept</code>, but I cannot declare it that way.</p>\n<p>A variant not involving <code>vector</code> is:</p>\n<pre><code>template&lt;bool b&gt;\nstruct F {\n  F&amp; operator=(F&amp;&amp;) noexcept(b) {return *this;}\n};\n\nstruct X {\n  X&amp; operator=(X&amp;&amp;) noexcept = default;\n  F&lt;true&gt; f;\n};\n</code></pre>\n<p>What is the expected behavior here? Intuitively clang seems correct.</p>\n", "AcceptedAnswerId": "20616637", "Title": "Defaulted move assignment cannot be explicitly noexcept if a member has a non-trivial noexcept assignment operator", "CreationDate": "2013-12-16T12:10:28.883", "Id": "20610658", "CommentCount": "3", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-12-17T16:28:52.750", "Score": "14", "OwnerUserId": "105672", "Tags": "<c++><c++11><move-semantics><assignment-operator>", "AnswerCount": "1"}, "20616637": {"Id": "20616637", "PostTypeId": "2", "Body": "<p>The example not involving <code>vector</code> should compile.  clang is correct on this one.</p>\n<p>The example involving <code>vector</code> may or may not compile, depending on whether the std::lib vendor has marked the move assignment operator of <code>vector</code> as <code>noexcept</code> or not.  The standard does not require this signature to be <code>noexcept</code>.  The standard does allow vendors to add <code>noexcept</code> if the function will never throw.</p>\n<p><a href=\"http://libcxx.llvm.org\" rel=\"nofollow\">libc++</a> marks the <code>vector</code> move assignment operator as <code>noexcept</code> if <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</code> is true and <code>is_nothrow_move_assignable&lt;allocator_type&gt;::value</code> is true (as a conforming extension).  Both of these are true in the libc++ implementation for <code>std::allocator&lt;T&gt;</code>.</p>\n<p><strong>Update</strong></p>\n<p>Pulling out the language lawyer hat on request.</p>\n<p><code>&lt;disclaimer&gt;</code></p>\n<p>I'm poking around in the half of the standard that is not my area of expertise.</p>\n<p><code>&lt;/disclaimer&gt;</code></p>\n<blockquote>\n<p id=\"so_20610658_20616637_0\">Could you be more explicit on why the example should compile?</p>\n</blockquote>\n<p>All quotes are from the latest C++1y working draft, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">N3797</a>.</p>\n<hr>\n<p>This specifies that an exception-specification is allowed on an explicitly defaulted special member:</p>\n<p>8.4.2 <strong>Explicitly-defaulted functions</strong> [dcl.fct.def.default]/p2</p>\n<blockquote>\n<p id=\"so_20610658_20616637_1\">2 An explicitly-defaulted function may be declared <code>constexpr</code> only if\n  it would have been implicitly declared as <code>constexpr</code>, and may have an\n  explicit <em>exception-specification</em> only if it is compatible (15.4)\n  with the <em>exception-specification</em> on the implicit declaration.</p>\n</blockquote>\n<hr>\n<p>This defines \"compatible exception-specifications:\"</p>\n<p>15.4 <strong>Exception specifications</strong> [except.spec]/p3</p>\n<blockquote>\n<p id=\"so_20610658_20616637_2\">3 Two <em>exception-specifications</em> are <em>compatible</em> if:</p>\n<ul>\n<li><p id=\"so_20610658_20616637_3\">both are non-throwing (see below), regardless of their form,</p></li>\n<li><p id=\"so_20610658_20616637_4\">both have the form <code>noexcept</code>(<em>constant-expression</em>) and the <em>constant-expressions</em> are equivalent, or</p></li>\n<li><p id=\"so_20610658_20616637_5\">both are <em>dynamic-exception-specifications</em> that have the same set of adjusted types.</p></li>\n</ul>\n</blockquote>\n<p>Bullet 2 covers your case.</p>\n<hr>\n<p>This explains why the implicitly declared special member is <code>noexcept</code> in your example:</p>\n<p>15.4 <strong>Exception specifications</strong> [except.spec]/p14</p>\n<blockquote>\n<p id=\"so_20610658_20616637_6\">14 An inheriting constructor (12.9) and an implicitly declared special\n  member function (Clause 12) have an <em>exception-specification</em>. If f is\n  an inheriting constructor or an implicitly declared default\n  constructor, copy constructor, move constructor, destructor, copy\n  assignment operator, or move assignment operator, its implicit\n  <em>exception-specification</em> specifies the <em>type-id</em> <code>T</code> if and only if <code>T</code> is allowed by the <em>exception-specification</em> of a function directly\n  invoked by <code>f</code>\u2019s implicit definition; <code>f</code> allows all exceptions if any\n  function it directly invokes allows all exceptions, and <code>f</code> has the\n  <em>exception-specification</em> <code>noexcept(true)</code> if every function it directly invokes allows no exceptions.</p>\n</blockquote>\n<p>Because every function invoked by an implicitly declared <code>X&amp; operator=(X&amp;&amp;)</code> allows no exceptions (i.e. the move assignment operator of <code>F&lt;true&gt;</code>), this special member is <code>noexcept(true)</code>.</p>\n<hr>\n<p>I <em>believe</em> that nails it down.</p>\n</hr></hr></hr></hr>", "LastEditorUserId": "576911", "LastActivityDate": "2013-12-17T16:28:52.750", "Score": "4", "CreationDate": "2013-12-16T17:13:18.900", "ParentId": "20610658", "CommentCount": "5", "LastEditDate": "2013-12-17T16:28:52.750", "OwnerUserId": "576911"}});