post_cb({"39758335": {"CommentCount": "7", "ViewCount": "286", "PostTypeId": "1", "LastEditorUserId": "4407569", "CreationDate": "2016-09-28T21:58:21.373", "LastActivityDate": "2016-11-17T00:11:54.163", "Title": "Private member access in template substitution and SFINAE", "FavoriteCount": "0", "LastEditDate": "2016-09-28T22:35:29.200", "Id": "39758335", "Score": "14", "Body": "<pre><code>class A { int a; };\n\ntemplate&lt;typename, typename = void&gt;\nclass test {};\n\ntemplate&lt;typename T&gt;\nclass test&lt;T,decltype(T::a)&gt; {};\n\nint main() { test&lt;A&gt; a; }\n</code></pre>\n<p>The code above compiles without error on <code>clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)</code>, but fails to compile on <code>g++-5 (Ubuntu 5.4.1-2ubuntu1~16.04) 5.4.1 20160904</code> and <code>g++-6 (Ubuntu 6.2.0-3ubuntu11~16.04) 6.2.0 20160901</code> with errors like this:</p>\n<pre><code>main.cpp: In function \u2018int main()\u2019:\nmain.cpp:9:22: error: \u2018int A::a\u2019 is private within this context\n int main() { test&lt;A&gt; a; }\n                      ^\nmain.cpp:1:15: note: declared private here\n class A { int a; };\n</code></pre>\n<p>In both cases I compiled with <code>-std=c++11</code>, but the effect is the same for <code>-std=c++14</code> and <code>-std=c++1z</code>.</p>\n<p>Which compiler is correct here? I assumed that, at least since C++11, accessing private members during template substitution should trigger SFINAE, implying that clang is correct and gcc is not. Is there some additional rule I am unaware of?</p>\n<p>For referencce, I am thinking of the note in \u00a714.8.2/8 of the current standard draft N4606:</p>\n<blockquote>\n<p id=\"so_39758335_39758335_0\">If a substitution results in an invalid type or expression, type\n  deduction fails. An invalid type or expression is one that would be\n  ill-formed, with a diagnostic required, if written using the\n  substituted arguments. [ Note: If no diagnostic is required, the\n  program is still ill-formed. Access checking is done as part of the\n  substitution process. \u2014 end note ]</p>\n</blockquote>\n<p>Using a member function and a member function pointer instead is accepted by both compilers:</p>\n<pre><code>class A { void a() {}; };\n\ntemplate&lt;typename, typename = void&gt;\nclass test {};\n\ntemplate&lt;typename T&gt;\nclass test&lt;T,decltype(&amp;T::a)&gt; {};\n\nint main() { test&lt;A&gt; a; }\n</code></pre>\n", "Tags": "<c++><templates><gcc><clang><sfinae>", "OwnerUserId": "4407569", "AnswerCount": "1"}, "40644634": {"ParentId": "39758335", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is very interesting! <strong>I think</strong> it's a g++ compiler bug and <strong>I think</strong> that this is what happens. I've tried several alterations of your code with g++ 4.9.3 and clang 3.7.0 . </p>\n<p>Although there are somewhat different rules to function vs class template instantiation, I believe that these are the general steps to a template instantiation:</p>\n<ol>\n<li>Compiler reads source file with template definitions.</li>\n<li>Name lookup (may trigger ADL) : It is the procedure by which a name,\nwhen encountered in a program, is associated with the declaration\nthat introduced it.\n(<a href=\"http://en.cppreference.com/w/cpp/language/lookup\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/lookup</a>)</li>\n<li>Template argument specification / deduction : In order to\ninstantiate a function template, every template argument must be\nknown, but not every template argument has to be specified. When\npossible, the compiler will deduce the missing template arguments\nfrom the function arguments.\n(<a href=\"http://en.cppreference.com/w/cpp/language/template_argument_deduction\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/template_argument_deduction</a>)</li>\n<li>Template substitution (may trigger SFINAE) : Every uses of a\ntemplate parameter in the function parameter list is replaced with\nthe corresponding template arguments.Substitution failure (that is,\nfailure to replace template parameters with the deduced or provided\ntemplate arguments) of a function template removes the function\ntemplate from the overload set. (<a href=\"http://en.cppreference.com/w/cpp/language/function_template#Template_argument_substitution\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/function_template#Template_argument_substitution</a>)</li>\n<li>Forming the overload set: Before overload resolution begins, the\nfunctions selected by name lookup and template argument deduction\nare combined to form the set of candidate functions.\n(<a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution#Details\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/overload_resolution#Details</a>)</li>\n<li>Overload resolution : In general, the candidate function whose\nparameters match the arguments most closely is the one that is\ncalled.\n(<a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/overload_resolution</a>)</li>\n<li>Template Instantiation : the template arguments must be determined\nso that the compiler can generate an actual function (or class, from\na class template). (<a href=\"http://en.cppreference.com/w/cpp/language/function_template#Function_template_instantiation\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/function_template#Function_template_instantiation</a>)</li>\n<li>Compiler generates code.</li>\n</ol>\n<p>I'll keep these bullet-points as guidelines and references for later on. Furthermore, I'll refer to <em>template evaluation</em> from steps 1-6. If you find anything wrong in the above list <strong>please please please</strong> feel free to change it or comment so that I can make the changes. </p>\n<p>In the following example:</p>\n<pre><code>class A {};\n\ntemplate&lt;typename, typename = void&gt;\nstruct test\n{ test(){std::cout&lt;&lt; \"Using None\" &lt;&lt;std::endl;} };\n\ntemplate&lt;typename T&gt;\nstruct test&lt;T, decltype(T::a)&gt;\n{ test(){std::cout&lt;&lt; \"Using T::a\" &lt;&lt;std::endl;} };\n\nint main()\n{ test&lt;A&gt; a; }\n</code></pre>\n<p>Output from both compilers:</p>\n<pre><code>Using None\n</code></pre>\n<p>This example compiles fine in both g++ and clang, because, when the compiler completes the evaluation process of all the templates, it will only choose to instantiate the first template for being the best match to the template arguments used to create the object in main(). Also, the template substitution process fails when the compiler fails to deduce T::a (SFINAE). Furthermore, due to the argument mismatch, the specialization will not be included in the overload set and will not be instantiated. </p>\n<p>Should we add the second template argument, like this:</p>\n<pre><code>test&lt;A , decltype(A::a)&gt; a;\n</code></pre>\n<p>The code will not compile and both compilers would complain of:</p>\n<pre><code>error: no member named 'a' in 'A'\n</code></pre>\n<p>In the following example however, things start becoming weird:</p>\n<pre><code>class A { int a; };\n\ntemplate&lt;typename, typename = void&gt;\nstruct test\n{ test(){std::cout&lt;&lt; \"Using None\" &lt;&lt;std::endl;} };\n\ntemplate&lt;typename T&gt;\nstruct test&lt;T, decltype(T::a)&gt;\n{ test(){std::cout&lt;&lt; \"Using T::a\" &lt;&lt;std::endl;} };\n\nint main()\n{ test&lt;A&gt; a; }\n</code></pre>\n<p>Output from clang:</p>\n<pre><code>Using None\n</code></pre>\n<p>Output from g++:</p>\n<pre><code>error: \u2018int A::a\u2019 is private\n</code></pre>\n<p>To begin with, I think that this would have been a nice warning. But why an error? The template won't even get instantiated. Considering the previous example, and the fact that pointers-to-members are constant values known at compile time, it seems, that when clang completes the template evaluation stage, with the SFINAE occuring at template substitution, it accurately instantiates the first template and ignores the specialization. But when g++ goes through the substitution process, and looks for the variable T::a, it sees that it is a private member, and instead of saying SFINAE, it prompts with the error above. I think that this is where the bug is, considering this bug report: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61806\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61806</a></p>\n<p>Now, the curious part is in the next example, which uses the private member function:</p>\n<pre><code>class A{ void a() {}; };\n\ntemplate&lt;typename, typename = void&gt;\nstruct test\n{ test(){std::cout&lt;&lt; \"Using None\" &lt;&lt;std::endl;} };\n\ntemplate&lt;typename T&gt;\nstruct test&lt;T,decltype(&amp;T::a)&gt;\n{ test(){std::cout&lt;&lt; \"Using A::a\" &lt;&lt;std::endl;} };\n\nint main()\n{ test&lt;A&gt; a; }\n</code></pre>\n<p>Output by both compilers:</p>\n<pre><code>Using None\n</code></pre>\n<p>If the previous explanation is true, then why doesn't g++ prompt an error when the private member function is used? Again, this is only an assumption based on the outputs, but I think that this bit actually works as it should. Long story short, SFINAE kicks in, the specialization is discarded from the overload set, and only the first template gets instantiated. Maybe there's more to it than meets the eye, but if we explicitly specify the second template argument, both compilers will prompt the same error.</p>\n<pre><code>int main()\n{ test&lt;A , decltype(&amp;A::a)&gt; b; }\n</code></pre>\n<p>Output by both compilers:</p>\n<pre><code>error: \u2018void A::a()\u2019 is private\n</code></pre>\n<p>Anyway, this is the final code I've been using. To demonstrate the outputs, I've made the class public. As an interesting event, I've added a nullptr to point to the member function directly. The type from <strong>decltype(((T*)nullptr)-&gt;f())</strong> is <strong>void</strong>, and from the example below, <em>a</em> and <em>c</em> are both invoked by the specialization rather than the first template. The reason is because the second template is more specialized than the first and therefore is the best match for both of them (kill two birds with one stone) (Template Formal Ordering Rules : <a href=\"https://stackoverflow.com/a/9993549/2754510\">https://stackoverflow.com/a/9993549/2754510</a>). The type from <strong>decltype(&amp;T::f)</strong> is <strong>M4GolfFvvE</strong> (possible translation: Men 4 Golf Fear very vicious Elk), which thanks to boost::typeindex::type_id_with_cvr, it is demangled into <strong>void (Golf::*)()</strong>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;boost/type_index.hpp&gt;\n\nclass Golf\n{\n    public:\n        int v;\n\n        void f()\n        {};\n};\n\n\ntemplate&lt;typename T&gt;\nusing var_t = decltype(T::v);\n\ntemplate&lt;typename T&gt;\nusing func_t = decltype(&amp;T::f);\n//using func_t = decltype(((T*)nullptr)-&gt;f()); //void\n\n\ntemplate&lt;typename, typename = void&gt;\nstruct test\n{\n    test(){std::cout&lt;&lt; \"Using None\" &lt;&lt;std::endl;}\n};\n\ntemplate&lt;typename T&gt;\nstruct test&lt;T,var_t&lt;T&gt; &gt;\n{\n    test(){std::cout&lt;&lt; \"Using Golf::v\" &lt;&lt;std::endl;}\n};\n\ntemplate&lt;typename T&gt;\nstruct test&lt;T,func_t&lt;T&gt; &gt;\n{\n    test(){std::cout&lt;&lt; \"Using Golf::f\" &lt;&lt;std::endl;}\n};\n\n\nint main()\n{\n    test&lt;Golf&gt; a;\n    test&lt;Golf,var_t&lt;Golf&gt; &gt; b;\n    test&lt;Golf,func_t&lt;Golf&gt; &gt; c;\n\n    using boost::typeindex::type_id_with_cvr;\n    std::cout&lt;&lt; typeid(func_t&lt;Golf&gt;).name() &lt;&lt; \" -&gt; \" &lt;&lt; type_id_with_cvr&lt;func_t&lt;Golf&gt;&gt;().pretty_name() &lt;&lt;std::endl;\n}\n</code></pre>\n<p>Output from both compilers (func_t = decltype(&amp;T::f)):</p>\n<pre><code>Using None\nUsing Golf::v\nUsing Golf::f\nM4GolfFvvE -&gt; void (Golf::*)()\n</code></pre>\n<p>Output from both compilers (func_t = decltype(((T*)nullptr)-&gt;f())):</p>\n<pre><code>Using Golf::f\nUsing Golf::v\nUsing Golf::f\nv -&gt; void\n</code></pre>\n", "OwnerUserId": "2754510", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:09:33.273", "Id": "40644634", "Score": "2", "CreationDate": "2016-11-17T00:11:54.163", "LastActivityDate": "2016-11-17T00:11:54.163"}, "bq_ids": {"n4140": {"so_39758335_39758335_0": {"section_id": 300, "quality": 0.9090909090909091, "length": 30}}, "n3337": {"so_39758335_39758335_0": {"section_id": 291, "quality": 0.7272727272727273, "length": 24}}, "n4659": {"so_39758335_39758335_0": {"section_id": 307, "quality": 0.9090909090909091, "length": 30}}}});