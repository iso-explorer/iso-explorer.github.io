post_cb({"37708167": {"ParentId": "37701321", "CommentCount": "0", "CreationDate": "2016-06-08T16:34:39.830", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "37708167", "Score": "8", "Body": "<p>The expression <code>void()</code> is a prvalue of type <code>void</code> and can be used anywhere such an expression may be used, which <a href=\"http://eel.is/c++draft/basic.fundamental#9\">[basic.fundamental]/9</a> helpfully provides a list:</p>\n<ul>\n<li>As an expression-statement: <code>void();</code></li>\n<li>As the second or third operand of a conditional operator: <code>true ? throw 1 : void()</code></li>\n<li>As an operand of the comma operator: <code>++it1, void(), ++it2</code></li>\n<li>As the operand of <code>decltype</code> or <code>noexcept</code>: <code>using my_void = decltype(void()); static_assert(noexcept(void()), \"WAT\");</code></li>\n<li>In a <code>return</code> statement of a function returning (possibly cv-qualified) <code>void</code>: <code>const void f() { return void(); }</code></li>\n<li>As an operand of an explicit conversion to (possibly cv-qualified) <code>void</code>: <code>static_cast&lt;const void&gt;(void())</code></li>\n</ul>\n<p>An expression of type <code>void</code> can also be used as the operand of <code>typeid</code>, but <code>void()</code> in particular would be parsed as a type, not an expression, in this context.</p>\n", "LastActivityDate": "2016-06-08T16:34:39.830"}, "37701421": {"ParentId": "37701321", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2016-06-08T11:36:31.263", "Score": "11", "LastEditorUserId": "1608816", "LastEditDate": "2016-06-08T11:40:15.937", "Id": "37701421", "OwnerUserId": "1608816", "Body": "<p>You can take a <code>void()</code> as function parameter:</p>\n<pre><code>void test(void()) { ... }\n</code></pre>\n<p>Which expands to:</p>\n<pre><code>void test(void (*)())\n</code></pre>\n<p>Which is a function pointer to a method which returns void and takes no arguments.</p>\n<p>Full example:</p>\n<pre><code>void abc() {}\nvoid test(void()) { }\n\nint main() {\n    test(abc);\n}\n</code></pre>\n", "LastActivityDate": "2016-06-08T11:40:15.937"}, "37707777": {"ParentId": "37701321", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-06-08T16:15:41.453", "Score": "1", "LastEditorUserId": "3309790", "LastEditDate": "2016-06-08T16:32:20.283", "Id": "37707777", "OwnerUserId": "3309790", "Body": "<blockquote>\n<p id=\"so_37701321_37707777_0\">There is no place for void() in C++ is there?</p>\n</blockquote>\n<p>As an expression, <code>void()</code> is valid in C++.</p>\n<p>From the standard, <code>$5.2.3/2 Explicit type conversion (functional notation) [expr.type.conv]</code>:</p>\n<blockquote>\n<p id=\"so_37701321_37707777_1\">The expression <code>T()</code>, where <code>T</code> is a simple-type-specifier or\n  typename-specifier for a non-array complete object type or the\n  (possibly cv-qualified) <code>void</code> type, creates a prvalue of the specified\n  type, whose value is that produced by value-initializing (8.5) an\n  object of type <code>T</code>; no initialization is done for the <code>void()</code> case.</p>\n</blockquote>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/language/explicit_cast#Explanation\" rel=\"nofollow\">cppreference.com</a>:</p>\n<blockquote>\n<p id=\"so_37701321_37707777_2\">new_type ( )  </p>\n<p id=\"so_37701321_37707777_3\">If <code>new_type</code> is an object type, the object is value-initialized;\n  otherwise, no initialization is done. If <code>new_type</code> is (possibly\n  cv-qualified) <code>void</code>, the expression is a <code>void</code> prvalue.</p>\n</blockquote>\n", "LastActivityDate": "2016-06-08T16:32:20.283"}, "37701321": {"CommentCount": "5", "AcceptedAnswerId": "37708167", "PostTypeId": "1", "LastEditorUserId": "2692339", "CreationDate": "2016-06-08T11:32:24.430", "LastActivityDate": "2016-06-09T09:07:04.370", "LastEditDate": "2016-06-09T09:07:04.370", "ViewCount": "1557", "FavoriteCount": "4", "Title": "Construction of a void Type?", "Id": "37701321", "Score": "21", "Body": "<p>I was given a piece of code that uses <code>void()</code> as an argument. The code doesn't compile... obviously?</p>\n<p>Can we instantiate anything of type <code>void</code>? I believed the answer was no, with the exception of a <code>void*</code>. For example:</p>\n<ol>\n<li>Writing the function <code>void askVoid(void param) {}</code> errors:</li>\n</ol>\n<blockquote>\n<p id=\"so_37701321_37701321_0\">A parameter may not have <code>void</code> type</p>\n</blockquote>\n<ol start=\"2\">\n<li>Writing the function <code>void askNaught() {}</code> and calling it with askNaught(void())` errors:</li>\n</ol>\n<blockquote>\n<p id=\"so_37701321_37701321_1\">error C2660: <code>takeNaught</code>: function does not take 1 arguments</p>\n</blockquote>\n<ol start=\"3\">\n<li>Writing the templatized function <code>template &lt;typename T&gt; void takeGeneric(T param) {}</code> and calling it with <code>takeGeneric(void())</code> errors:</li>\n</ol>\n<blockquote>\n<p id=\"so_37701321_37701321_2\">error C2893: Failed to specialize function template <code>void takeGeneric(T)</code></p>\n</blockquote>\n<ol start=\"4\">\n<li>Declaring <code>void voidType</code> errors:</li>\n</ol>\n<blockquote>\n<p id=\"so_37701321_37701321_3\">Incomplete type is not allowed</p>\n</blockquote>\n<ol start=\"5\">\n<li>Declaring <code>auto autoVoid = void()</code> errors:</li>\n</ol>\n<blockquote>\n<p id=\"so_37701321_37701321_4\">Cannot deduce <code>auto</code> type</p>\n</blockquote>\n<ol start=\"6\">\n<li>Declaring <code>void* voidPtr</code> works fine, but <code>remove_pointer_t&lt;decltype(voidPtr)&gt; decltypeVoid</code> errors:</li>\n</ol>\n<blockquote>\n<p id=\"so_37701321_37701321_5\">error C2182: <code>decltypeVoid</code>: illegal use of type <code>void</code></p>\n</blockquote>\n<p>That's it, right? There is no place for <code>void()</code> in C++ is there? This is just bad code I've been given, right?</p>\n", "Tags": "<c++><void>", "OwnerUserId": "2642059", "AnswerCount": "5"}, "37701760": {"ParentId": "37701321", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-06-08T11:53:18.483", "Score": "4", "LastEditorUserId": "4987285", "LastEditDate": "2016-06-08T11:59:18.047", "Id": "37701760", "OwnerUserId": "4987285", "Body": "<p>You can use <code>void()</code> as a callable type, as an example <code>std::function&lt;void()&gt; f;</code> is a valid statement.</p>\n<p>Moreover, as from <a href=\"http://eel.is/c++draft/dcl.fct#4\" rel=\"nofollow\">8.3.5/4</a>:</p>\n<blockquote>\n<p id=\"so_37701321_37701760_0\">A parameter list consisting of a single unnamed parameter of non-dependent type void is equivalent to an empty parameter list.</p>\n</blockquote>\n<p>That means that this is valid:</p>\n<pre><code>template&lt;typename T&gt;\nstruct F;\n\ntemplate&lt;typename R, typename... A&gt;\nstruct F&lt;R(A...)&gt; { };\n\nint main () {\n   F&lt;void(void)&gt; s;\n}\n</code></pre>\n<p>Here you are not instantiating anything of type <code>void</code>, but you are using it (let me say) as a parameter list of a callable type.</p>\n<p>Not sure if this replies to your question, I've not clear what the question actually is.</p>\n", "LastActivityDate": "2016-06-08T11:59:18.047"}, "bq_ids": {"n4140": {"so_37701321_37707777_3": {"section_id": 3296, "quality": 0.5333333333333333, "length": 8}, "so_37701321_37701321_0": {"section_id": 300, "quality": 0.8, "length": 4}, "so_37701321_37707777_1": {"section_id": 6000, "quality": 0.9629629629629629, "length": 26}, "so_37701321_37701760_0": {"section_id": 3240, "quality": 1.0, "length": 13}}, "n3337": {"so_37701321_37707777_3": {"section_id": 3166, "quality": 0.5333333333333333, "length": 8}, "so_37701321_37701321_0": {"section_id": 291, "quality": 0.8, "length": 4}, "so_37701321_37707777_1": {"section_id": 5768, "quality": 0.7037037037037037, "length": 19}, "so_37701321_37701760_0": {"section_id": 3113, "quality": 0.5384615384615384, "length": 7}}, "n4659": {"so_37701321_37707777_3": {"section_id": 4058, "quality": 0.5333333333333333, "length": 8}, "so_37701321_37701321_0": {"section_id": 8689, "quality": 1.0, "length": 5}, "so_37701321_37701760_0": {"section_id": 3996, "quality": 1.0, "length": 13}}}, "37701815": {"ParentId": "37701321", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-06-08T11:55:49.647", "Score": "11", "LastEditorUserId": "2692339", "LastEditDate": "2016-06-08T15:50:08.327", "Id": "37701815", "OwnerUserId": "2692339", "Body": "<p>C++ (and I say C++, not C) allows (<a href=\"http://eel.is/c++draft/stmt.return#2\" rel=\"nofollow\">\u00a76.6.3 comma 2</a>) functions with <code>void</code> return type to return a <code>void</code> expression, that is:</p>\n<pre><code>void foo() { return void(); }\n</code></pre>\n<p>But notice it is <em>not</em> constructing a temporary <code>void</code>!</p>\n", "LastActivityDate": "2016-06-08T15:50:08.327"}});