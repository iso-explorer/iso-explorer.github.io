post_cb({"28529185": {"CommentCount": "3", "ViewCount": "88", "CreationDate": "2015-02-15T17:56:15.573", "LastActivityDate": "2015-02-15T18:38:57.897", "Title": "C++ Inheritance and Initialisation order", "PostTypeId": "1", "Id": "28529185", "Score": "0", "Body": "<p>I am studying for my final exam. I stumbled upon this question from previous years and I can't seem to fully understand whats happening.\n<em>Given this code, determine the output</em></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nstruct A {\n    A(int a): _a(a) {cout &lt;&lt; \"A::A, a=\" &lt;&lt; _a &lt;&lt; endl;} \n    ~A() { cout &lt;&lt; \"A::~\" &lt;&lt; endl; }\n    int _a;\n};\n\nstruct B: public A\n{\n    B(int b):A(b) { cout &lt;&lt; \"B::B\" &lt;&lt; endl; }\n    ~B() { cout &lt;&lt; \"B::~\" &lt;&lt; endl; } \n};\n\nstruct C: public B\n{\n    A a;\n    B b;\n    C(int a=10, int b=20):a(a), b(a*b), B(b) {} \n    ~C() { cout &lt;&lt; \"C::~\" &lt;&lt; endl; }\n};\n\nint main() {\n    C allTogetherNow;\n    return 0; \n}\n</code></pre>\n<p>I tried to compile the code and I was given a warning:</p>\n<blockquote>\n<p id=\"so_28529185_28529185_0\">warning: field 'b' will be initialized after base 'B'\n        [-Wreorder] C(int a=10, int b=20):a(a), b(a*b), B(b) {} ~C() { cout &lt;&lt; \"C::~\" &lt;&lt; endl; }\n                              ^ 1 warning generated.</p>\n</blockquote>\n<p>and the following output:</p>\n<pre><code>A::A, a=20\nB::B\nA::A, a=10\nA::A, a=200\nB::B\nC::~\nB::~\nA::~\nA::~\nB::~\nA::~\n</code></pre>\n<p>The destruction order is kind of clear (last constructed - first destructed), but I can't seem to get ahold of the construction order/pattern.. What am I missing? A clarification of the <em>Warning</em> I received would be extra helpful. Also, if you could refer me to extra reading material on this particular subject.</p>\n<p>Thank you.</p>\n", "Tags": "<c++><inheritance>", "OwnerUserId": "3688173", "AnswerCount": "2"}, "28529355": {"ParentId": "28529185", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The initialization order is precisely defined in the standard:</p>\n<blockquote>\n<p id=\"so_28529185_28529355_0\"><strong>12.6.2./10:</strong>  In a non-delegating constructor, initialization proceeds in the following order: </p>\n<p id=\"so_28529185_28529355_1\">\u2014 First, and only for the constructor\n  of the most derived class (1.8), <strong>virtual base classes</strong> are\n  initialized in the order they appear on a depth-first left-to-right\n  traversal of the directed acyclic graph of base classes, where\n  \u201cleft-to-right\u201d is the order of appearance of the base classes in the\n  derived class base-specifier-list. </p>\n<p id=\"so_28529185_28529355_2\">\u2014 Then, <strong>direct base classes</strong> are\n  initialized in declaration order as they appear in the\n  base-specifier-list (regardless of the order of the mem-initializers).</p>\n<p id=\"so_28529185_28529355_3\">\u2014 Then, <strong>non-static data members</strong> are initialized in the order they\n  were declared in the class definition (again regardless of the order\n  of the mem-initializers). </p>\n<p id=\"so_28529185_28529355_4\">\u2014 Finally, the compound-statement of the\n  constructor body is executed.</p>\n</blockquote>\n<p>So when you intialize C,  its base class is first initialised, i.e. <code>B</code> with default 20 which itself requires <code>A</code> to be initialised first with 20. Only then is initialisation of <code>B</code> completed. </p>\n<p>Then, <code>A</code> and <code>B</code> being intialized, the members of <code>C</code> are initalized, starting first with <code>a</code> with the default parameter 10, then with <code>b(200)</code>.  As <code>b</code> is a <code>B</code>, it will first require the initializeation of its own base <code>A</code>. Then initialisation of of <code>b</code> can be completed.  And finally the initialisation of <code>C</code> is completed.   </p>\n<p>By the way, it's not part of the question but remember  for your exam:  </p>\n<blockquote>\n<p id=\"so_28529185_28529355_5\"><strong>12.4/7:</strong> Bases and members are destroyed in the reverse order of the completion of their constructor.</p>\n</blockquote>\n<p><strong><em>Note about the warning:</em></strong></p>\n<p><em>My compiler doesn't generate this warning. There is no reason for it, as the mem-initilizer <code>B(b)</code> clearly uses the parameter <code>b</code> of your consturctor.  It's only an hypotheses, but I suspect your compiler raise a false positive because <code>b</code> is also the name of a member (which would indeed not be initialised when calling the base).  If I'm right, the following change should not raise a warning anymore:</em></p>\n<pre><code> C(int a=10, int bbb=20):a(a), b(a*bbb), B(bbb) { cout &lt;&lt; \"C::C\" &lt;&lt; endl;} \n</code></pre>\n", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "LastEditDate": "2015-02-15T18:38:57.897", "Id": "28529355", "Score": "2", "CreationDate": "2015-02-15T18:10:55.013", "LastActivityDate": "2015-02-15T18:38:57.897"}, "bq_ids": {"n4140": {"so_28529185_28529355_4": {"section_id": 438, "quality": 1.0, "length": 5}, "so_28529185_28529355_2": {"section_id": 438, "quality": 1.0, "length": 13}, "so_28529185_28529355_3": {"section_id": 438, "quality": 1.0, "length": 15}, "so_28529185_28529355_1": {"section_id": 438, "quality": 1.0, "length": 29}, "so_28529185_28529355_0": {"section_id": 438, "quality": 0.8571428571428571, "length": 6}, "so_28529185_28529355_5": {"section_id": 404, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_28529185_28529355_4": {"section_id": 429, "quality": 1.0, "length": 5}, "so_28529185_28529355_2": {"section_id": 429, "quality": 1.0, "length": 13}, "so_28529185_28529355_3": {"section_id": 429, "quality": 1.0, "length": 15}, "so_28529185_28529355_1": {"section_id": 429, "quality": 1.0, "length": 29}, "so_28529185_28529355_0": {"section_id": 429, "quality": 0.8571428571428571, "length": 6}, "so_28529185_28529355_5": {"section_id": 395, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_28529185_28529355_4": {"section_id": 458, "quality": 1.0, "length": 5}, "so_28529185_28529355_2": {"section_id": 458, "quality": 1.0, "length": 13}, "so_28529185_28529355_3": {"section_id": 458, "quality": 1.0, "length": 15}, "so_28529185_28529355_1": {"section_id": 458, "quality": 1.0, "length": 29}, "so_28529185_28529355_0": {"section_id": 458, "quality": 0.8571428571428571, "length": 6}, "so_28529185_28529355_5": {"section_id": 422, "quality": 0.8888888888888888, "length": 8}}}, "28529278": {"ParentId": "28529185", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This line:</p>\n<pre><code>C(int a=10, int b=20):a(a), b(a*b), B(b) {} \n</code></pre>\n<p>Should be:</p>\n<pre><code>C(int a=10, int b=20): B(b), a(a), b(a*b) {} \n</code></pre>\n<p>In C++, the initialization order is fixed. For your type <code>C</code>, it will always be:</p>\n<ol>\n<li>Base Class <code>B</code></li>\n<li>Member variable <code>A a;</code></li>\n<li>Member variable <code>B b;</code></li>\n</ol>\n<p>In your initializer list you ordered it differently. And so your compiler warned you in case you expected the initializer list's order to matter.</p>\n", "OwnerUserId": "47453", "LastEditorUserId": "47453", "LastEditDate": "2015-02-15T18:09:32.013", "Id": "28529278", "Score": "3", "CreationDate": "2015-02-15T18:04:13.490", "LastActivityDate": "2015-02-15T18:09:32.013"}});