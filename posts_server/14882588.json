post_cb({"bq_ids": {"n4140": {"so_14882588_14884118_0": {"length": 9, "quality": 1.0, "section_id": 6356}, "so_14882588_14884118_1": {"length": 10, "quality": 1.0, "section_id": 6341}, "so_14882588_14884118_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 6341}}, "n3337": {"so_14882588_14884118_0": {"length": 9, "quality": 1.0, "section_id": 6113}, "so_14882588_14884118_1": {"length": 10, "quality": 1.0, "section_id": 6098}, "so_14882588_14884118_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 6098}}, "n4659": {"so_14882588_14884118_0": {"length": 9, "quality": 1.0, "section_id": 7865}, "so_14882588_14884118_1": {"length": 6, "quality": 0.6, "section_id": 49}, "so_14882588_14884118_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 7709}}}, "14884118": {"Id": "14884118", "PostTypeId": "2", "Body": "<p>All the standard says about inheritance from base classes is that it is allowed:</p>\n<blockquote>\n<h3>17.6.5.11 Derived classes [derivation]</h3>\n<p id=\"so_14882588_14884118_0\">1 - An implementation may derive any class in the C++ standard library from a class with a name reserved to the implementation.</p>\n</blockquote>\n<p>It doesn't say either way whether methods (and, indeed, other members such as typedefs) are allowed to be inherited from a base class; obviously, since implementations do so, the standard should describe this behaviour.</p>\n<p>In any case, detecting e.g. <code>reserve</code> by cast to a member function type is not guaranteed to work even if a member of the most derived type, since:</p>\n<blockquote>\n<h3>17.6.5.5 Member functions [member.functions]</h3>\n<p id=\"so_14882588_14884118_1\">2 - An implementation may declare additional non-virtual member function signatures within a class:</p>\n<ul>\n<li>by adding arguments with default values to a member function signature<sup>186</sup>; [...]</li>\n</ul>\n<p id=\"so_14882588_14884118_2\">186) Hence, the address of a member function of a class in the C++ standard library has an unspecified type.</p>\n</blockquote>\n<p>The correct way to check whether <code>reserve</code> exists is to attempt to call it:</p>\n<pre><code>template&lt; typename C, typename = void &gt;\nstruct has_reserve\n  : std::false_type\n{};\n\ntemplate&lt; typename C &gt;\nstruct has_reserve&lt; C, typename std::enable_if&lt;\n                         std::is_same&lt;\n                           decltype( std::declval&lt;C&gt;().reserve( std::declval&lt;typename C::size_type&gt;() ) ),\n                           void\n                         &gt;::value\n                       &gt;::type &gt;\n  : std::true_type\n{};\n</code></pre>\n<p>This has the advantage of paralleling the container <em>requirements</em> (table 103 for <code>unordered_set</code>), which are normative where the synopses tend more to the informative.</p>\n", "LastEditorUserId": "2073257", "LastActivityDate": "2013-02-14T22:04:03.127", "Score": "11", "CreationDate": "2013-02-14T21:11:33.533", "ParentId": "14882588", "CommentCount": "2", "LastEditDate": "2013-02-14T22:04:03.127", "OwnerUserId": "567292"}, "14882588": {"ViewCount": "649", "Body": "<p>Given a type <code>C</code> which is an STL-conforming container, how do I correctly detect if <code>C</code> contains a member function <code>reserve</code>? I tried the following approach (with GCC 4.6.3):</p>\n<pre><code>template&lt; typename C, typename = void &gt;\nstruct has_reserve\n  : std::false_type\n{};\n\ntemplate&lt; typename C &gt;\nstruct has_reserve&lt; C, typename std::enable_if&lt;\n                         std::is_same&lt;\n                           decltype( &amp;C::reserve ),\n                           void (C::*)( typename C::size_type )\n                         &gt;::value\n                       &gt;::type &gt;\n  : std::true_type\n{};\n</code></pre>\n<p>This works for <code>C</code> being <code>std::vector</code>, but not for the unordered containers, e.g. <code>std::unordered_set</code>. The reason is, that <code>reserve</code> is a (direct) member function of <code>std::vector</code>, but for the unordered containers it is inherited from a base class, i.e., its signature is not <code>void (C::*)( typename C::size_type )</code> but <code>void (B::*)( typename C::size_type )</code> for some unspecified base class <code>B</code> of <code>C</code>.</p>\n<p>I know how to work around it and detect <code>reserve</code> even if inherited, but it looks clumsy and I wonder what is allowed by the standard. So...</p>\n<p>My question is: Does the standard allow <code>reserve</code> to be inherited from an unspecified base class or is the synopsis binding and requires a direct member function?</p>\n", "AcceptedAnswerId": "14884118", "Title": "Correct signature of / detect presence of Container::reserve()", "CreationDate": "2013-02-14T19:31:00.013", "Id": "14882588", "CommentCount": "0", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-02-20T23:09:44.353", "LastEditorUserId": "636019", "LastActivityDate": "2013-12-11T12:10:55.433", "Score": "11", "OwnerUserId": "2073257", "Tags": "<c++><c++11><std><enable-if>", "AnswerCount": "1"}});