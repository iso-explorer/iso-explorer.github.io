post_cb({"9086451": {"Id": "9086451", "PostTypeId": "2", "Body": "<p>Lets say you have to pointers:</p>\n<pre><code>int *a = something1;\nint *b = something2;\n</code></pre>\n<p>You know the address of something1 which is &amp;something1.\nAlso the address of something2 is &amp;something2.</p>\n<p>So what you have to do is check if the two addresses that that the pointers point to are correct.</p>\n<p>so you use something like </p>\n<pre><code>if(&amp;something1 == &amp;something2) {\n//do something\n}\n</code></pre>\n<p>or you can use the == operator to check whether pointer a has an equal value with pointer b.</p>\n", "LastActivityDate": "2012-01-31T20:27:52.207", "CommentCount": "2", "CreationDate": "2012-01-31T20:27:52.207", "ParentId": "9086372", "Score": "-4", "OwnerUserId": "1180558"}, "9099485": {"Id": "9099485", "PostTypeId": "2", "Body": "<p>To sum up. If we want to see if two pointers point to the same memory location we can do that. Also if we want to compare the contents of the memory pointed to by two pointers we can do that too, just remeber to dereference them first.</p>\n<p>If we have </p>\n<pre><code>int *a = something; \nint *b = something;\n</code></pre>\n<p>which are two pointers of the same type we can:</p>\n<p>Compare memory address:</p>\n<pre><code>a==b\n</code></pre>\n<p>and compare contents:</p>\n<pre><code>*a==*b\n</code></pre>\n", "LastActivityDate": "2012-02-01T16:32:02.790", "CommentCount": "0", "CreationDate": "2012-02-01T16:32:02.790", "ParentId": "9086372", "Score": "10", "OwnerUserId": "862973"}, "9086393": {"Id": "9086393", "PostTypeId": "2", "Body": "<p>The <code>==</code> operator on pointers will compare their numeric address and hence determine if they point to the same object. </p>\n", "LastActivityDate": "2012-01-31T20:24:11.027", "CommentCount": "2", "CreationDate": "2012-01-31T20:24:11.027", "ParentId": "9086372", "Score": "14", "OwnerUserId": "23283"}, "bq_ids": {"n4140": {"so_9086372_9086675_0": {"length": 17, "quality": 0.6296296296296297, "section_id": 6155}}, "n3337": {"so_9086372_9086675_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 5917}, "so_9086372_9086675_3": {"length": 13, "quality": 1.0, "section_id": 5913}}, "n4659": {"so_9086372_9086675_3": {"length": 7, "quality": 0.5384615384615384, "section_id": 7709}}}, "9086675": {"Id": "9086675", "PostTypeId": "2", "Body": "<p>For a bit if <em>facts</em> here is the relevant text from the specifications</p>\n<h2>Equality operator (==,!=)</h2>\n<p>Pointers to objects of the same type can be compared for equality with the 'intuitive' expected results:</p>\n<p>From <strong>\u00a7 5.10</strong>  of the C++11 standard:</p>\n<blockquote>\n<p id=\"so_9086372_9086675_0\">Pointers of the same type\n  (after pointer conversions) can be compared for equality. Two pointers of the same type compare equal if\n  and only if they are both null, both point to the same function, or both represent the same address (<em>3.9.2</em>).</p>\n<p id=\"so_9086372_9086675_1\"><em>(leaving out details on comparison of pointers to member and or the null pointer constants - they continue down the same line of 'Do What I Mean':)</em></p>\n<ul>\n<li>[...] If both operands are null, they compare equal. Otherwise if only one is null, they compare unequal.[...] </li>\n</ul>\n<p id=\"so_9086372_9086675_2\">The most 'conspicuous' caveat has to do with virtuals, and it does seem to be the logical thing to expect too:</p>\n<ul>\n<li>[...] if either is a pointer to a virtual member function, the result is unspecified. Otherwise they\n  compare equal if and only if they would refer to the same member of the same most derived object (1.8)\n  or the same subobject if they were dereferenced with a hypothetical object of the associated class type. [...] </li>\n</ul>\n</blockquote>\n<h2>Relational operators (&lt;,&gt;,&lt;=,&gt;=)</h2>\n<p>From <strong>\u00a7 5.9</strong> of the C++11 standard:</p>\n<blockquote>\n<p id=\"so_9086372_9086675_3\">Pointers to objects or functions of the same type (after pointer conversions) can be compared,\n  with a result defined as follows:</p>\n<ol>\n<li>If two pointers p and q of the same type point to the same object or\n  function, or both point one past the end of the same array, or are both\n  null, then <code>p&lt;=q</code> and <code>p&gt;=q</code> both yield true and <code>p&lt;q</code> and <code>p&gt;q</code> both yield false.</li>\n<li>If two pointers p and q of the same type point to different objects that <strong>are\n  not members of the same object or elements of the same array</strong> or to different\n  functions, or if only one of them is null, the results of <code>p&lt;q,</code> <code>p&gt;q,</code> <code>p&lt;=q,</code> and\n  <code>p&gt;=q</code> <strong>are unspecified</strong>.</li>\n<li>If two pointers point to non-static data members of the same object, or to\n  subobjects or array elements of such members, recursively, the pointer to the\n  later declared member compares greater provided the two members have the same\n  access control (Clause 11) and provided their class is not a union.</li>\n<li>If two pointers point to non-static data members of the same object with\n  different access control (Clause 11) the result is unspecified.</li>\n<li>If two pointers point to non-static data members of the same union object,\n  they compare equal (after conversion to <code>void*</code>, if necessary). If two pointers\n  point to elements of the same array or one beyond the end of the array, the\n  pointer to the object with the higher subscript compares higher.</li>\n<li>Other pointer comparisons are unspecified.</li>\n</ol>\n</blockquote>\n<p>So, if you had:</p>\n<pre><code>int arr[3];\nint *a = arr;\nint *b = a + 1;\nassert(a != b); // OK! well defined\n</code></pre>\n<p>Also OK:</p>\n<pre><code>struct X { int x,y; } s;\nint *a = &amp;s.x;\nint *b = &amp;s.y;\nassert(b &gt; a); // OK! well defined\n</code></pre>\n<p>But it depends on the <em><code>something</code></em> in your question:</p>\n<pre><code>int g; \nint main()\n{\n     int h;\n     int i;\n\n     int *a = &amp;g;\n     int *b = &amp;h; // can't compare a &lt;=&gt; b\n     int *c = &amp;i; // can't compare b &lt;=&gt; c, or a &lt;=&gt; c etc.\n     // but a==b, b!=c, a!=c etc. are supported just fine\n}\n</code></pre>\n<h2>Bonus: what else is there in the standard library?</h2>\n<p><strong>\u00a7 20.8.5/8</strong>: \"For templates <code>greater</code>, <code>less</code>, <code>greater_equal</code>, and <code>less_equal</code>, the specializations for any pointer type  yield a total order, even if the built-in operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> do not.\"</p>\n<p>So, you can globally <em>order</em> any odd <code>void*</code> as long as you use <code>std::less&lt;&gt;</code> and friends, not bare <code>operator&lt;</code>.</p>\n", "LastEditorUserId": "7232508", "LastActivityDate": "2017-11-14T05:52:28.787", "Score": "71", "CreationDate": "2012-01-31T20:47:02.597", "ParentId": "9086372", "CommentCount": "3", "OwnerUserId": "85371", "LastEditDate": "2017-11-14T05:52:28.787"}, "9086372": {"ViewCount": "77261", "Body": "<p>Suppose I have 2 pointers:</p>\n<pre><code>int *a = something;\nint *b = something;\n</code></pre>\n<p>If I want to compare them and see if they point at the same place does (a == b) work?</p>\n", "AcceptedAnswerId": "9086388", "Title": "How to compare pointers?", "CreationDate": "2012-01-31T20:22:46.600", "Id": "9086372", "CommentCount": "1", "FavoriteCount": "20", "PostTypeId": "1", "LastActivityDate": "2017-11-14T05:52:28.787", "Score": "44", "OwnerUserId": "1181215", "Tags": "<c++><pointers>", "AnswerCount": "5"}, "9086388": {"Id": "9086388", "PostTypeId": "2", "Body": "<p>Yes, that is the definition of pointer equality: they both point to the same location (or are <a href=\"http://en.wikipedia.org/wiki/Pointer_aliasing\" rel=\"noreferrer\">pointer aliases</a>)</p>\n", "LastActivityDate": "2012-01-31T20:23:43.673", "CommentCount": "2", "CreationDate": "2012-01-31T20:23:43.673", "ParentId": "9086372", "Score": "40", "OwnerUserId": "841108"}});