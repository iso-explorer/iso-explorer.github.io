post_cb({"6620386": {"ParentId": "6620348", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>1.You do need to guard it and even if you don't, of course, OS wouldn't do it for you. Use following code for thread-safety:</p>\n<pre><code>DataCenter* DataCenter::getInstance()\n{\n    MutexLocker locker(DataCenter::m_mutex);\n    if(!m_instanceFlag)\n    {\n        m_instance = new DataCenter();\n        m_instanceFlag = true;\n    }\n    return m_instance;\n}\n</code></pre>\n<p><strong>Edit:</strong></p>\n<p>Where <code>MutexLocker</code> is something like this:</p>\n<pre><code>class MutexLocker\n{\n    pthread_mutex_t &amp;mutex;\n    public:\n    MutexLocker(pthread_mutex_t &amp;mutex):mutex(mutex)\n    {\n        if(pthread_mutex_lock(&amp;this-&gt;mutex)!=0)\n            throw std::runtime_error(\"mutex locking filed\");\n    }\n    ~MutexLocker(void)\n    {\n        if(pthread_mutex_unlock(&amp;this-&gt;mutex)!=0)\n            throw std::runtime_error(\"mutex unlocking filed\");\n    }\n}\n</code></pre>\n<p>2.First method looks ok, but not thread-safe.</p>\n", "OwnerUserId": "509233", "LastEditorUserId": "509233", "LastEditDate": "2011-07-08T06:08:34.673", "Id": "6620386", "Score": "5", "CreationDate": "2011-07-08T05:45:04.290", "LastActivityDate": "2011-07-08T06:08:34.673"}, "6620638": {"ParentId": "6620348", "CommentCount": "6", "Body": "<p>You only need to guard the singleton access if calling <code>getSingleton</code> may also initialise the singleton -- otherwise, multiple threads may try to create it simultaneously.</p>\n<p>A mutex is sufficient to prevent the race condition, however, each subsequent call to <code>getSingleton</code> must also acquire the lock, which puts a damper on performance. If this is an issue and you can deal with the additional complexity, <a href=\"http://blogs.msdn.com/b/oldnewthing/\" rel=\"nofollow\">Raymond Chen</a> shows a way that the lock can be avoided, by allowing multiple threads to create the singleton instance and determining which to keep <a href=\"http://blogs.msdn.com/b/oldnewthing/archive/2011/04/06/10150261.aspx\" rel=\"nofollow\">using interlocked operations</a> (code inlined below):</p>\n<pre><code>Widget *g_pwidCached;\n\nWidget *GetSingletonWidget()\n{\n Widget *pwid = g_pwidCached;\n if (!pwid) {\n  pwid = new(nothrow) Widget();\n  if (pwid) {\n   Widget *pwidOld = reinterpret_cast&lt;Widget*&gt;\n       (InterlockedCompareExchangePointerRelease(\n          &amp;reinterpret_cast&lt;PVOID&amp;&gt;(g_pwidCached),\n          pwid, NULL));\n   if (pwidOld) {\n    delete pwid; // lost the race - destroy the redundant copy\n    pwid = pwidOld; // use the old one\n   }\n  }\n }\n return pwid;\n}\n</code></pre>\n<p>Of course, this is Windows-specific, but the code can be replaced with platform-specific interlocked operations without changing the meaning. (As a bonus: if you <em>are</em> coding on Windows, you can simply use the provided <a href=\"http://msdn.microsoft.com/en-us/library/aa363808.aspx\" rel=\"nofollow\">One-Time Initialization</a> API to do the hard work for you!)</p>\n<p>Note that the singleton's constructor must not have side-effects, otherwise you will get unexpected results. (There are more details in Raymond's <a href=\"http://blogs.msdn.com/b/oldnewthing/archive/2011/04/06/10150261.aspx\" rel=\"nofollow\">full blog post</a>.)</p>\n", "OwnerUserId": "230575", "PostTypeId": "2", "Id": "6620638", "Score": "1", "CreationDate": "2011-07-08T06:22:23.247", "LastActivityDate": "2011-07-08T06:22:23.247"}, "6620630": {"ParentId": "6620348", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As people mentioned in comments, the double-checked lock is not a thread safe solution. You really need to use some kind of a mechanism that will serialize access to the resource. Interlocked exchange is probably one of the simplest ways.</p>\n<pre><code>template &lt;typename T&gt;\nclass Singleton\n{\n  private:\n    Singleton();\n    ~Singleton();\n    Singleton&amp; operator=(const Singleton&amp; item);\n\n  protected:\n    static volatile long m_locker;\n\n    static T* GetPointer()\n    {\n      T* pTmp = NULL;\n      try\n      {\n         static T var;\n         pTmp = &amp;var;\n      }\n      catch(...)\n      {\n         //assert(false);\n         pTmp = NULL;\n      }\n      return pTmp;\n    }\n\n  public:\n    static T* Get()\n    {\n       while(::InterlockedExchange(&amp;m_locker, 1) != 0)\n         ::SwitchToThread();\n\n       T* pTmp = GetPointer();\n       ::InterlockedExchange(&amp;m_locker, 0);\n       return pTmp;\n    }\n};\n\ntemplate &lt;typename T&gt;\n  volatile long Singleton&lt;T&gt;::m_locker = 0;\n</code></pre>\n", "OwnerUserId": "136720", "LastEditorUserId": "136720", "LastEditDate": "2011-07-08T06:26:56.967", "Id": "6620630", "Score": "1", "CreationDate": "2011-07-08T06:21:13.010", "LastActivityDate": "2011-07-08T06:26:56.967"}, "6620367": {"ParentId": "6620348", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, you really do need to do this. If thread 1 checks the instance flag and get swapped out for thread 2, which then executes the entire <code>getInstance()</code> method, thread 1 will then proceed to get <em>another</em> instance.</p>\n<p>This is because it's already checked the flag when it was false and will not recheck it just because of a context switch.</p>\n<p>If there's the chance that multiple threads may call <code>getInstance()</code> concurrently, you need to protect the operation of checking and setting the flag as an atomic unit.</p>\n<p>Of course, you can get away with no protection if you call <code>getInstance</code> from your main thread before any other threads start.</p>\n<p>You may also want to ditch the idea of using a separate flag variable as well. You can set the instance to NULL on load and just use that:</p>\n<pre><code>DataCenter* DataCenter::getInstance(){\n    static DataCenter *m_instance = 0;\n    // begin atomic unit\n    if(m_instance == 0)\n        m_instance = new DataCenter();\n    // end atomic unit\n    return m_instance;\n}\n</code></pre>\n", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2011-07-08T05:46:52.077", "Id": "6620367", "Score": "0", "CreationDate": "2011-07-08T05:41:29.860", "LastActivityDate": "2011-07-08T05:46:52.077"}, "6620348": {"CommentCount": "8", "AcceptedAnswerId": "6620386", "PostTypeId": "1", "LastEditorUserId": "534005", "CreationDate": "2011-07-08T05:37:57.917", "LastActivityDate": "2012-11-22T12:12:42.663", "LastEditDate": "2011-07-08T06:34:07.883", "ViewCount": "3915", "FavoriteCount": "2", "Title": "safe way to get a singleton instance from multithreads", "Id": "6620348", "Score": "9", "Body": "<p><strong>Method 1</strong></p>\n<pre><code>DataCenter* DataCenter::getInstance()\n{\n    static DataCenter instance;\n    return &amp;instance;    \n}\n</code></pre>\n<p><strong>Method 2</strong></p>\n<pre><code>DataCenter* DataCenter::getInstance()\n{\n    if (!m_instanceFlag)\n    {\n        m_instance = new DataCenter();\n        m_instanceFlag = true;\n    }    \n    return m_instance;      \n}\n</code></pre>\n<p>I am working on a multi threaded programming and DataCenter will be accessed by more than one thread. I used to have method 2 to get the instance of DataCenter and it worked fine. But I noted that I need to guard the singleton instance from being called by multi threads.</p>\n<p>My question is first do I really need to guard the singleton instance? or does OS do this for me? Second questions is that, is the first method a right way to get the singleton instance? </p>\n<p>Thanks in advance...</p>\n", "Tags": "<c++><multithreading>", "OwnerUserId": "800799", "AnswerCount": "6"}, "6626706": {"ParentId": "6620348", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I suppose I might as well provide my answer...</p>\n<p>First, \"Method 1\" works fine on C++0x.  From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf#page=151\" rel=\"nofollow\">draft standard</a>, section 6.7 (4) (emphasis mine):</p>\n<blockquote>\n<p id=\"so_6620348_6626706_0\">The zero-initialization (8.5) of all block-scope variables with static storage duration (3.7.1) or thread storage duration (3.7.2) is performed before any other initialization takes place. ... Otherwise such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. ... <strong>If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</strong></p>\n</blockquote>\n<p>So if you have C++0x, \"Method 1\" is a simple, correct, and 100% portable way to implement a thread-safe singleton.  (Even prior to C++0x, g++ on Unix ensures this idiom will work.  I do not know about MSVC.)  This is also very likely to be the fastest solution, since the compiler can see exactly what you are doing and it knows more than you about your CPU's architecture.</p>\n<p>The easy way to fix \"Method 2\" is to put a mutex around the entire function, as Mihran suggests.  But that might have unfortunate performance consequences, so people are always looking for ways to optimize it.  Most of those ways introduce subtle bugs...</p>\n<p>The \"double-checked locking pattern\" is the classic example.  It looks like this:</p>\n<pre><code>if (m_instance == NULL) {\n    grab_mutex();\n    if (m_instance == NULL)\n        m_instance = new Whatsit();\n    release_mutex();\n}\n\nreturn m_instance;\n</code></pre>\n<p>There are two problems with this pattern.  First, individual memory accesses are not guaranteed to be <em>atomic</em> in general; simultaneous loads and stores of a single memory location by different threads can result in garbage being read.  (I grant this is unlikely for a pointer value -- and certainly it will not happen on x86/x86_64 -- but do you really want your code to work on just one platform for one day?)</p>\n<p>Second, both the compiler and the CPU are free to <em>reorder</em> memory accesses.  So the thread that runs the <code>Whatsit</code> constructor and then fills in <code>m_instance</code> might actually perform those writes out-of-order...  Meaning another thread can test <code>m_instance</code>, observe it to be non-NULL, and then access the object before it has been initialized.  This is <em>not</em> hypothetical; it really happens on modern CPUs.  Worse, the more modern the CPU, the more likely it is to be a problem, because CPUs keep getting more and more aggressive about reordering memory accesses.</p>\n<p>To fix this pattern, the first read of <code>m_instance</code> needs to have \"acquire semantics\", and the write to <code>m_instance</code> needs to have \"release semantics\".  Definitions:  If a memory load L has \"acquire semantics\", then <em>subsequent</em> loads may not be reordered to happen before L.  Similarly, if a store S has \"release semantics\", then <em>previous</em> stores must not be reordered to happen after S.</p>\n<p><em>Both</em> of these are required in order for \"double-checked locking\" to be thread-safe.  (Plus the individual loads and stores must be atomic.)</p>\n<p>As Justin points out, declaring <code>m_instance</code> <a href=\"http://msdn.microsoft.com/zh-cn/library/12a04hfd.aspx#CodeSpippet1\" rel=\"nofollow\">\"volatile\"</a> will provide these semantics on MSVC.  But this is <em>not</em> guaranteed by any standard, and in fact it is not true for many compilers (e.g. g++ on Unix).  But if you are certain you will never care about any platform other than x86 Windows -- which you aren't -- then \"volatile\" will work.</p>\n<p>What about using a compare-and-swap operation like <a href=\"http://msdn.microsoft.com/en-us/library/ms683568%28v=vs.85%29.aspx\" rel=\"nofollow\">InterlockedCompareExchangePointer</a>?</p>\n<pre><code>if (m_instance == NULL) {\n    Whatsit *p = new Whatsit();\n    if (InterlockedCompareExchangePointer(&amp;m_instance, p, NULL) != NULL)\n        delete p;\n}\n\nreturn m_instance;\n</code></pre>\n<p>The documentation says InterlockedCompareExchangePointer provides a \"full memory barrier\", which means it definitely has release semantics.  So is this correct?</p>\n<p>No, not in general.  The problem is that the outer read of <code>m_instance</code> does <em>not</em> necessarily have \"acquire semantics\".  So in principle, another thread could still read the members of the object before they have been initialized.  Modern CPUs <em>do</em> perform \"speculative loads\"; that is, they try to \"guess\" what you are going to need in order to load it from memory ahead of time.  Granted, on a cache-coherent platform like x86, the CPU would have to be near-psychic to read an object before its pointer had even been computed...  But if you use this pattern just because it happens to work on your system today, when it breaks on some future system and introduces night-impossible-to-debug failures, somebody will be cursing your name.  So please do not do this.</p>\n<p>Finally, you can use an API designed for one-time initialization, like the <a href=\"http://msdn.microsoft.com/en-us/library/aa363808.aspx\" rel=\"nofollow\">\"One-Time Initialization API\"</a> on Windows or <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_once.html\" rel=\"nofollow\">pthread_once</a> on Unix.  These work correctly by definition, but obviously they are platform-specific.</p>\n<p>Bottom line: Use \"Method 1\" if your system supports it for this purpose.</p>\n", "OwnerUserId": "768469", "LastEditorUserId": "151641", "LastEditDate": "2012-11-22T12:12:42.663", "Id": "6626706", "Score": "2", "CreationDate": "2011-07-08T15:26:52.753", "LastActivityDate": "2012-11-22T12:12:42.663"}, "6620359": {"ParentId": "6620348", "PostTypeId": "2", "CommentCount": "16", "Body": "<p>You need to use double checked lock mechanism but it may not be 100% safe as well.</p>\n<pre><code>DataCenter* DataCenter::getInstance()\n{\n  if (m_instance == null)\n  {\n    // some sort of synchronization lock    //1\n     {  \n\n        if (m_instance == null)             //2\n            m_instance  = new DataCenter(); //3 \n    }\n  }\n  return m_instance ;\n}\n</code></pre>\n<p>A little more explanation:</p>\n<p>Thread 1 enters the getInstance() method. </p>\n<p>Thread 1 enters the synchronized block at //1 because instance is null.</p>\n<p>Thread 1 is preempted by thread 2.</p>\n<p>Thread 2 enters the getInstance() method.</p>\n<p>Thread 2 attempts to acquire the lock at //1 because instance is still null. However, because thread 1 holds the lock, thread 2 blocks at //1.</p>\n<p>Thread 2 is preempted by thread 1.</p>\n<p>Thread 1 executes and because instance is still null at //2, creates a Singleton object and assigns its reference to instance. </p>\n<p>Thread 1 exits the synchronized block and returns instance from the getInstance() method. </p>\n<p>Thread 1 is preempted by thread 2.</p>\n<p>Thread 2 acquires the lock at //1 and checks to see if instance is null. </p>\n<p>Because instance is non-null, a second Singleton object is not created and the one created by thread 1 is returned. </p>\n", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2011-07-08T05:56:12.913", "Id": "6620359", "Score": "0", "CreationDate": "2011-07-08T05:40:32.267", "LastActivityDate": "2011-07-08T05:56:12.913"}, "bq_ids": {"n4140": {"so_6620348_6626706_0": {"section_id": 3919, "quality": 0.94, "length": 47}}, "n3337": {"so_6620348_6626706_0": {"section_id": 3779, "quality": 0.94, "length": 47}}, "n4659": {"so_6620348_6626706_0": {"section_id": 4805, "quality": 0.7, "length": 35}}}});