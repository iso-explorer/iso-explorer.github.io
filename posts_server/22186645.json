post_cb({"22186645": {"CreationDate": "2014-03-05T01:21:59.707", "CommentCount": "10", "ViewCount": "163", "PostTypeId": "1", "ClosedDate": "2014-03-05T01:59:03.930", "LastEditorUserId": "501557", "LastActivityDate": "2014-03-05T02:04:46.780", "LastEditDate": "2014-03-05T01:46:19.363", "AcceptedAnswerId": "22187059", "FavoriteCount": "2", "Title": "Why must (), [], ->, and = be overloaded only as member functions?", "Id": "22186645", "Score": "2", "Body": "<p>I tried to analyse why some of the operators ((), [], -&gt;, =) should be overloaded as member functions only. I failed and I tried to search on internet but of no use. Can any one please help me to understand this restriction?</p>\n", "Tags": "<c++><operator-overloading>", "OwnerUserId": "3137388", "AnswerCount": "3"}, "22186953": {"ParentId": "22186645", "LastEditDate": "2014-03-05T01:59:23.427", "CommentCount": "0", "CreationDate": "2014-03-05T01:53:27.647", "OwnerUserId": "198164", "LastEditorUserId": "198164", "PostTypeId": "2", "Id": "22186953", "Score": "2", "Body": "<p>Although maybe not very satisfying, here's what the standard has to say about it:</p>\n<p>(<em>emphasis</em> is mine)</p>\n<p><strong>\u00a73.5.3 Assignment</strong></p>\n<blockquote>\n<p id=\"so_22186645_22186953_0\">An assignment operator shall be implemented by a non-static member function with exactly one parameter.</p>\n</blockquote>\n<p><strong>\u00a73.5.4 Function call</strong></p>\n<blockquote>\n<p id=\"so_22186645_22186953_1\">operator() shall be a <em>non-static member</em> function with an arbitrary number of parameters.</p>\n</blockquote>\n<p><strong>\u00a73.5.5 Subscripting</strong></p>\n<blockquote>\n<p id=\"so_22186645_22186953_2\">operator[] shall be a <em>non-static member</em> function with exactly one parameter.</p>\n</blockquote>\n<p><strong>\u00a73.5.6 Class member acess</strong></p>\n<blockquote>\n<p id=\"so_22186645_22186953_3\">operator-&gt; shall be a <em>non-static member</em> function taking no parameters.</p>\n</blockquote>\n<p>I can't speak to the reasoning behind these requirements, so I will leave that aspect to those that are more familiar with how compilers are designed.</p>\n", "LastActivityDate": "2014-03-05T01:59:23.427"}, "22187059": {"ParentId": "22186645", "LastEditDate": "2017-05-23T12:28:44.797", "CommentCount": "0", "CreationDate": "2014-03-05T02:04:46.780", "OwnerUserId": "1884138", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "22187059", "Score": "1", "Body": "<p>I think this is most likely why that portion of the standard was written that way. </p>\n<p>but if it is not forbidden, the friend version would never be called, in my testing code ,when </p>\n<pre><code> Complex operator+(const Complex &amp;other);\n</code></pre>\n<p>is defined as private, the compiler would \ngive error message </p>\n<pre><code>\u2018Complex Complex::operator+(const Complex&amp;)\u2019 is private\n Complex Complex::operator+(const Complex &amp;other)\n</code></pre>\n<p>instead of using the friend version</p>\n<p>refer to <a href=\"https://stackoverflow.com/questions/3933637/why-friend-function-cant-be-used-for-overloading-assignment-operator\">Why cannot a non-member function be used for overloading the assignment operator?</a></p>\n<p>Because the default operator= provided by the compiler (the memberwise copy one) would always take precedence. I.e. your friend operator= would never be called.</p>\n<p>(If the assignment was performed inside a class method, because of the lookup rules, the member function (in this case generated by the compiler) would take precedence)</p>\n<p>I try to using operator + for test. it prove the precedence</p>\n<p>it outputs:</p>\n<pre><code>member function called\n7+11i\n</code></pre>\n<p>testing code:</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nclass Complex\n{\npublic:\n    Complex(int real, int imag);\n    Complex(void);\n    ~Complex(void);\n\n    Complex &amp;Add(const Complex &amp;other);\n\n    void Display() const;\n\n    Complex operator+(const Complex &amp;other);\n\n    friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2);\n\nprivate:\n    int real_;\n    int imag_;\n};\nComplex::Complex(int real, int imag): imag_(imag), real_(real)\n{\n\n}\nComplex::Complex(void)\n{\n}\n\nComplex::~Complex(void)\n{\n}\n\nComplex &amp;Complex::Add(const Complex &amp;other)\n{\n    real_ += other.real_;\n    imag_ += other.imag_;\n    return *this;\n}\n\n\nvoid Complex::Display() const\n{\n    cout &lt;&lt; real_ &lt;&lt; \"+\" &lt;&lt; imag_ &lt;&lt; \"i\" &lt;&lt; endl;\n}\n\n\nComplex Complex::operator+(const Complex &amp;other)\n{\n    int r = real_ + other.real_;\n    int i = imag_ + other.imag_;\n    std::cout &lt;&lt; \"member function called\"&lt;&lt; std::endl;\n    return Complex(r, i);\n}\n\nComplex operator+(const Complex &amp;c1, const Complex &amp;c2)\n{\n    int r = c1.real_ + c2.real_;\n    int i = c1.imag_ + c2.imag_;\n    std::cout &lt;&lt; \"friend function called\"&lt;&lt;std::endl;\n    return Complex(r, i);\n}\n\nint main(void)\n{\n    Complex c1(3, 5);\n    Complex c2(4, 6);\n\n\n    Complex c3 = c1 + c2;\n\n    c3.Display();\n\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2014-03-05T02:04:46.780"}, "bq_ids": {"n4140": {"so_22186645_22186953_2": {"section_id": 466, "quality": 1.0, "length": 7}, "so_22186645_22186953_3": {"section_id": 664, "quality": 1.0, "length": 6}, "so_22186645_22186953_0": {"section_id": 660, "quality": 1.0, "length": 9}, "so_22186645_22186953_1": {"section_id": 662, "quality": 1.0, "length": 7}}, "n3337": {"so_22186645_22186953_3": {"section_id": 654, "quality": 1.0, "length": 6}, "so_22186645_22186953_1": {"section_id": 652, "quality": 1.0, "length": 7}, "so_22186645_22186953_2": {"section_id": 457, "quality": 1.0, "length": 7}, "so_22186645_22186953_0": {"section_id": 650, "quality": 1.0, "length": 9}}, "n4659": {"so_22186645_22186953_1": {"section_id": 690, "quality": 1.0, "length": 7}, "so_22186645_22186953_3": {"section_id": 692, "quality": 1.0, "length": 6}, "so_22186645_22186953_0": {"section_id": 688, "quality": 1.0, "length": 9}, "so_22186645_22186953_2": {"section_id": 489, "quality": 1.0, "length": 7}}}, "22186813": {"ParentId": "22186645", "LastEditDate": "2014-03-05T01:45:00.880", "CommentCount": "7", "CreationDate": "2014-03-05T01:39:45.210", "OwnerUserId": "1925939", "LastEditorUserId": "1925939", "PostTypeId": "2", "Id": "22186813", "Score": "2", "Body": "<p>Certain forms of operators require access to the \"this\" pointer of an instance of a class in order to operate directly on that instance as they only take a single argument to the same type.</p>\n<pre><code>class A{\npublic:\n\n    int x;\n\n    // only takes a reference to another 'A' type, so we need the 'this' pointer\n    A&amp; operator=(const A&amp; other){\n        this-&gt;x = other.x;\n        return *this;\n    }\n};\n</code></pre>\n", "LastActivityDate": "2014-03-05T01:45:00.880"}});