post_cb({"26192284": {"ViewCount": "1275", "Body": "<pre><code>int z = 1;\nz &lt;&lt;= 31;\nz &gt;&gt;= 31;\nprintf (\"%d\\n\",z);\n</code></pre>\n<p>When I run the code, <code>z=-1</code>, why?</p>\n", "AcceptedAnswerId": "26192303", "Title": "Why does (1 << 31) >> 31 result in -1?", "CreationDate": "2014-10-04T11:18:38.203", "Id": "26192284", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-10-06T07:01:16.070", "LastEditorUserId": "3747990", "LastActivityDate": "2014-10-06T07:01:16.070", "ClosedDate": "2017-06-16T12:58:07.123", "Score": "3", "OwnerUserId": "4018639", "Tags": "<c++><c><bit-shift>", "AnswerCount": "6"}, "26193261": {"Id": "26193261", "PostTypeId": "2", "Body": "<p>this is because sign copy mechanism, when ever you are left shifting z by 31 times, 1 is shifted from 0th bit position to 31st bit position. now on you are having 1 in 31st bit which will be treated as negative numbers. and in negative numbers, sign copy mechanism is used, in which if you right shift on negative numbers, sign bit is preserved. so you are having 1's in every bit position which is -1 in decimal.</p>\n", "LastActivityDate": "2014-10-04T13:23:24.563", "CommentCount": "0", "CreationDate": "2014-10-04T13:23:24.563", "ParentId": "26192284", "Score": "0", "OwnerUserId": "4108473"}, "bq_ids": {"n4140": {"so_26192284_26192492_0": {"length": 18, "quality": 0.782608695652174, "section_id": 6147}, "so_26192284_26192303_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 6088}, "so_26192284_26193183_1": {"length": 28, "quality": 0.9333333333333333, "section_id": 6147}, "so_26192284_26192492_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 6148}, "so_26192284_26192303_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 6147}, "so_26192284_26193183_0": {"length": 18, "quality": 0.782608695652174, "section_id": 6147}}, "n3337": {"so_26192284_26192492_0": {"length": 18, "quality": 0.782608695652174, "section_id": 5910}, "so_26192284_26192303_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 5911}, "so_26192284_26192492_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 5911}, "so_26192284_26193183_1": {"length": 21, "quality": 0.7, "section_id": 5910}, "so_26192284_26192303_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 5910}, "so_26192284_26193183_0": {"length": 18, "quality": 0.782608695652174, "section_id": 5910}}, "n4659": {"so_26192284_26192492_0": {"length": 18, "quality": 0.782608695652174, "section_id": 7643}, "so_26192284_26192303_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 7644}, "so_26192284_26192492_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 7644}, "so_26192284_26193183_1": {"length": 28, "quality": 0.9333333333333333, "section_id": 7643}, "so_26192284_26192303_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 7643}, "so_26192284_26193183_0": {"length": 18, "quality": 0.782608695652174, "section_id": 7643}}}, "26192492": {"Id": "26192492", "PostTypeId": "2", "Body": "<p>Assuming you are talking about <code>int</code> being 32-bit or smaller here. (If <code>int</code> is larger then this code is well-defined and results in <code>z</code> being <code>1</code>).</p>\n<p>In C and C++, <code>z &lt;&lt;= 31</code> is defined as <code>z = z &lt;&lt; 31</code>.</p>\n<p>In C11, <code>&lt;&lt;</code> is explained as (6.5.7/4):</p>\n<blockquote>\n<p id=\"so_26192284_26192492_0\">The result of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions; vacated bits are filled with\n  zeros. [...] If <code>E1</code> has a signed type and nonnegative value, and <code>E1</code> \u00d7 <code>2</code><sup><code>E2</code></sup> is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>In this case <code>E1</code> is <code>z</code> which is <code>1</code>, and <code>E2</code> is <code>31</code>.  However, 2<sup>31</sup> is not representable in a 32-bit <code>int</code> whose maximum value is 2<sup>31</sup> - 1, therefore <strong>the behaviour is undefined</strong>.</p>\n<p>When undefined behaviour occurs anything can happen, ranging from you seeing unexpected output, to the program crashing, to missiles being launched, and so on.</p>\n<p>In C99, C++98 and C++03 <code>&lt;&lt;</code> has a similar definition; <code>1 &lt;&lt; 31</code> is undefined behaviour in all of those (for 32-bit or smaller ints).</p>\n<hr>\n<p>In C++11 and C++14 there is an option you can test, <code>std::numeric_limits&lt;int&gt;::is_modulo</code> . If this is <code>true</code> then in some people's opinion, it means that integer overflow is no longer undefined, and so the result of <code>1 &lt;&lt; 31</code> must be <code>INT_MIN</code>.  For further discussion of this topic <a href=\"https://stackoverflow.com/questions/13272959/is-numeric-limitsintis-modulo-logically-contradictory\">see this thread</a>.</p>\n<p>Supposing we get this far (i.e. your system has 32-bit ints, and <code>std::numeric_limits&lt;int&gt;::is_modulo == true</code>, and you side with those who interpret the standard as saying that there is no UB on signed int overflow in this situation) then we have the following:</p>\n<pre><code>assert( CHAR_BIT * sizeof(int) == 32 );\nassert( std::numeric_limits&lt;int&gt;::is_modulo == true );\nint z = 1;\nz &lt;&lt;= 31;\nassert(z == INT_MIN);\n</code></pre>\n<p>Now to discuss <code>z &gt;&gt;= 31</code>. This is defined as <code>z = z &gt;&gt; 31;</code>. In C++11 5.8/3:</p>\n<blockquote>\n<p id=\"so_26192284_26192492_1\">The value of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. [...] If E1 has a signed type and a negative value, the resulting value is implementation-defined.</p>\n</blockquote>\n<p>Since <code>INT_MIN</code> is a negative value, the behaviour is implementation-defined. This means that your implementation must document what it does, so you can consult your compiler's documentation to find out what is happening here.</p>\n<p>A likely explanation is that it performs an <a href=\"http://en.wikipedia.org/wiki/Arithmetic_shift\" rel=\"nofollow noreferrer\">arithmetic shift</a>, which means that the bits are shifted right, but the sign bit retains its value. This means you end up with all-bits-one, which is <code>-1</code> in two's complement.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-04T11:47:01.243", "Score": "0", "CreationDate": "2014-10-04T11:47:01.243", "ParentId": "26192284", "CommentCount": "1", "LastEditDate": "2017-05-23T10:26:32.563", "OwnerUserId": "1505939"}, "26192295": {"Id": "26192295", "PostTypeId": "2", "Body": "<p>Right, shifting a signed integer and negative numbers is implementation defined I believe.</p>\n<p>Your implementation is probably doing a sign bit extension when you shift to the right.</p>\n<p>So instead of shifting in zeros from the left, it's shifting in the sign bit. <code>z &lt;&lt;= 31;</code> is probably setting the sign bit to 1, then <code>z &gt;&gt;= 31;</code> is shifting in ones from the left so you end up with a bit pattern of <code>0xFFFFFFFF</code> which is interpreted as the value <code>-1</code> on your platform (which probably uses two's complement).</p>\n", "LastEditorUserId": "268025", "LastActivityDate": "2014-10-04T12:46:02.190", "Score": "5", "CreationDate": "2014-10-04T11:19:53.327", "ParentId": "26192284", "CommentCount": "2", "LastEditDate": "2014-10-04T12:46:02.190", "OwnerUserId": "268025"}, "26193183": {"Id": "26193183", "PostTypeId": "2", "Body": "<p>Assuming 32-bit <code>int</code>s, this is undefined behavior in C11 and C++11, but implementation-defined in C++14.</p>\n<p>C11 \u00a76.5.7/p4 (quoting N1570):</p>\n<blockquote>\n<p id=\"so_26192284_26193183_0\">The result of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions;\n  vacated bits are filled with zeros. [...] If <code>E1</code> has a signed type\n  and nonnegative value, and <code>E1 \u00d7 2</code><sup><code>E2</code></sup> is representable in\n  the result type, then that is the resulting value; otherwise, the\n  behavior is undefined.</p>\n</blockquote>\n<p>The C++11 rule in N3337 \u00a75.8 [expr.shift]/p2  is pretty much identical. Since 2<sup>31</sup> isn't usually representable in a signed 32-bit <code>int</code>, the behavior is undefined.</p>\n<p>C++14  \u00a75.8 [expr.shift]/p2 (quoting N3936; see also <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1457\" rel=\"nofollow\">CWG issue 1457</a>):</p>\n<blockquote>\n<p id=\"so_26192284_26193183_1\">The value of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions;\n  vacated bits are zero-filled. [...] Otherwise, if <code>E1</code> has a signed\n  type and non-negative value, and <code>E1\u00d72</code><sup><code>E2</code></sup>is representable\n  in the corresponding unsigned type of the result type, then that\n  value, converted to the result type, is the resulting value;\n  otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>As 2<sup>31</sup> is representable in an unsigned 32-bit <code>int</code>, the behavior is defined and the result is 2<sup>31</sup> converted to (signed) <code>int</code>; this conversion is implementation-defined per \u00a74.7 [conv.integral]/p3. In a typical system using two's complement you'd get -2<sup>31</sup>, in which case the subsequent right shift is also implementation defined since the value is negative. If an arithmetic shift is performed, then the sign bit is shifted in, and you end up with <code>-1</code>.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-10-04T13:23:07.487", "Score": "2", "CreationDate": "2014-10-04T13:13:38.657", "ParentId": "26192284", "CommentCount": "0", "LastEditDate": "2014-10-04T13:23:07.487", "OwnerUserId": "2756719"}, "26192303": {"Id": "26192303", "PostTypeId": "2", "Body": "<pre><code>int z = 1;\nz &lt;&lt;= 31;\n</code></pre>\n<p>Assuming <code>int</code> is 32 bit and <a href=\"http://en.wikipedia.org/wiki/Two%27s_complement\" rel=\"nofollow noreferrer\">two's complement</a> representation is used, the left shift is undefined behavior in <strong>C</strong> because the result if not representable in the <code>int</code> type. From the standard:</p>\n<blockquote>\n<p id=\"so_26192284_26192303_0\">The result of <strong>E1 &lt;&lt; E2</strong> is <strong>E1</strong> left-shifted <strong>E2</strong> bit positions</p>\n<p id=\"so_26192284_26192303_1\">...</p>\n<p id=\"so_26192284_26192303_2\">If <strong>E1</strong> has a signed type and nonnegative value, and <strong>E1 \u00d7 2<sup>E2</sup></strong> is representable in the result type, then that is\n  the resulting value; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>In practice, it is likely to result in <code>0x80000000</code>, which is treated as a negative number.</p>\n<p>And right-shifting of <em>negative</em> integers is implementation-defined behavior:</p>\n<blockquote>\n<p id=\"so_26192284_26192303_3\">The result of <strong>E1 &gt;&gt; E2</strong> is <strong>E1</strong> right-shifted <strong>E2</strong> bit positions.</p>\n<p id=\"so_26192284_26192303_4\">...</p>\n<p id=\"so_26192284_26192303_5\">If <strong>E1</strong> has a signed type and a negative value, the resulting value is implementation-defined.</p>\n</blockquote>\n<hr>\n<p>In <strong>C++</strong> left shift is defined in a similar way till <strong>C++14</strong>, as <a href=\"https://stackoverflow.com/a/26193183/3246555\"><strong>@T.C.</strong></a> mentioned (or, with some restrictions, might be even till <strong>C++11</strong>, as <a href=\"https://stackoverflow.com/a/26192492/3246555\"><strong>@MattMcNabb</strong></a> wrote).</p>\n<p>But even if left-shift is defined and <code>0x8000000</code> is the expected value, the result of a right shift of a negative number is still implementation-defined.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-04T19:35:39.130", "Score": "9", "CreationDate": "2014-10-04T11:21:12.433", "ParentId": "26192284", "CommentCount": "3", "LastEditDate": "2017-05-23T12:27:08.867", "OwnerUserId": "3246555"}, "26210930": {"Id": "26210930", "PostTypeId": "2", "Body": "<p>If you were using <code>unsigned int</code> you'll get the same results.  The issue is you have used <code>&lt;&lt;</code> to left shift a 31 bits plus a bit sign 31 times to the left.  This is unsigned behaviour, as you have lost the most significant bit on the left side into the sign bit (this is what are you getting as the result of that undefined behaviour)</p>\n<p>When you do a right shift, this is made differently when you have signed integers (you get a copy of the sign bit into the most significant bit) than when you have unsigned ones (you get a zero bit shifted from the left side).  Normally, this means you get a right arithmetical shift instruction for signed integers (equivalent to a divide by two) when you do a right shift and a right logical shift instruction (equivalent also to a divide by two, but with unsigned numbers) when you do a right shift with unsigned numbers.</p>\n<p>just try the same declaring z as <code>unsigned int z;</code> and you'll get the expected behaviour.</p>\n", "LastActivityDate": "2014-10-06T06:27:23.670", "CommentCount": "0", "CreationDate": "2014-10-06T06:27:23.670", "ParentId": "26192284", "Score": "0", "OwnerUserId": "3899431"}});