post_cb({"bq_ids": {"n4140": {"so_30617158_30617677_2": {"length": 7, "quality": 1.0, "section_id": 5768}, "so_30617158_30617677_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 4605}}, "n3337": {"so_30617158_30617677_2": {"length": 7, "quality": 1.0, "section_id": 5541}, "so_30617158_30617158_0": {"length": 20, "quality": 1.0, "section_id": 5913}, "so_30617158_30617677_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 4423}}, "n4659": {"so_30617158_30617677_2": {"length": 7, "quality": 1.0, "section_id": 7225}, "so_30617158_30617677_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 5962}, "so_30617158_30617677_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 5962}}}, "30617158": {"ViewCount": "873", "Body": "<p>Pointer relational operators do not define a total order (<a href=\"https://stackoverflow.com/a/9086675/1987178\">\u00a7 5.9 of the C++11 standard</a>):</p>\n<blockquote>\n<p id=\"so_30617158_30617158_0\">If two pointers <code>p</code> and <code>q</code> of the same type point to different objects that are not members of the same object or elements of the same array or to different functions, or if only one of them is null, the results of <code>p&lt;q</code>, <code>p&gt;q</code>, <code>p&lt;=q</code>, and <code>p&gt;=q</code> are unspecified.</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/utility/functional/less\" rel=\"nofollow noreferrer\">std::less</a> documentation says:</p>\n<blockquote>\n<p id=\"so_30617158_30617158_1\">The partial specialization of <code>std::less</code> for any pointer type yields a total order, even if the built-in <code>operator&lt;</code> does not.</p>\n</blockquote>\n<p>How does it yield this total order from a partial order?</p>\n<hr>\n<p>I am unable to answer to this question by looking at <code>/usr/include/c++/4.9/bits/stl_function.h</code> for <code>struct less</code> definitions:</p>\n<pre><code>  template&lt;typename _Tp = void&gt;\n    struct less;\n\n  template&lt;typename _Tp&gt;\n    struct less : public binary_function&lt;_Tp, _Tp, bool&gt;\n    {\n      bool\n      operator()(const _Tp&amp; __x, const _Tp&amp; __y) const\n      { return __x &lt; __y; }\n    };\n\n  template&lt;&gt;\n    struct less&lt;void&gt;\n    {\n      template &lt;typename _Tp, typename _Up&gt;\n        auto\n        operator()(_Tp&amp;&amp; __t, _Up&amp;&amp; __u) const\n        noexcept(noexcept(std::forward&lt;_Tp&gt;(__t) &lt; std::forward&lt;_Up&gt;(__u)))\n        -&gt; decltype(std::forward&lt;_Tp&gt;(__t) &lt; std::forward&lt;_Up&gt;(__u))\n        { return std::forward&lt;_Tp&gt;(__t) &lt; std::forward&lt;_Up&gt;(__u); }\n\n      typedef __is_transparent is_transparent;\n    };\n</code></pre>\n</hr>", "AcceptedAnswerId": "30617677", "Title": "How does `std::less` work?", "CreationDate": "2015-06-03T10:13:16.013", "Id": "30617158", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:08:11.280", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-03T10:50:42.963", "Score": "6", "OwnerUserId": "1987178", "Tags": "<c++><c++11><stl><relational><partial-ordering>", "AnswerCount": "1"}, "30617677": {"Id": "30617677", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_30617158_30617677_0\">How does it yield this total order from a partial order?</p>\n</blockquote>\n<p>The standard rarely says <em>how</em> something should be accomplished. Instead, it says what is required. And this is exactly the case. The standard is requiring <code>std::less</code> to provide a total order, in \u00a720.9.6/14:</p>\n<blockquote>\n<p id=\"so_30617158_30617677_1\">For templates greater, less, greater_equal, and less_equal, the specializations for any pointer type yield a total order, even if the built-in operators &lt;, &gt;, &lt;=, &gt;= do not.</p>\n</blockquote>\n<p>while <code>operator&lt;</code>'s behaviour in this regard is <em>unspecified</em> according to \u00a75.9/4 (the quote you have in your question). </p>\n<p><em>Unspecified behaviour</em> is defined in \u00a71.3.25 to mean:</p>\n<blockquote>\n<p id=\"so_30617158_30617677_2\">behavior, for a well-formed program construct and correct data, that depends on the implementation [...]</p>\n</blockquote>\n<p>In your specific implementation, <code>operator&lt;</code> already provides a total order (probably because your pointer type is implemented as a 32 bits or 64 bits address, which can be easily interpreted as something similar to an unsigned integer, yielding a total order), therefore <code>std::less</code> simply forwards its arguments to that operator.</p>\n", "LastEditorUserId": "493122", "LastActivityDate": "2015-06-03T10:50:42.963", "Score": "4", "CreationDate": "2015-06-03T10:36:16.537", "ParentId": "30617158", "CommentCount": "4", "OwnerUserId": "493122", "LastEditDate": "2015-06-03T10:50:42.963"}});