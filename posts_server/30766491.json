post_cb({"30766492": {"ParentId": "30766491", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><b>TL;DR</b></p>\n<p>According to the standard it is valid to pass non-arithmetic types as arguments to <code>cmath</code> functions but defect report <code>2068</code> argues the original intent was that <code>cmath</code> functions should be restricted to arithmetic types and it appears possible using non-arithmetic arguments will eventually be made ill-formed. So although technically valid using non-arithmetic types as arguments seems questionable in light of defect report <code>2068</code>.</p>\n<p><b>Details</b></p>\n<p>The <a href=\"http://en.cppreference.com/w/cpp/numeric/math\" rel=\"nofollow\">cmath</a> header is covered in the draft standard section <code>26.8</code> <em>[c.math]</em> provides an additional <em>float</em> and <em>long double</em> overload for the each function defined in <a href=\"http://en.cppreference.com/w/c/numeric/math\" rel=\"nofollow\">math.h</a> that takes a <em>double</em> argument and further, paragraph <code>11</code> provides for <em>sufficient overloads</em> and says:</p>\n<blockquote>\n<p id=\"so_30766491_30766492_0\">Moreover, there shall be additional overloads sufficient to ensure:</p>\n<ol>\n<li>If any argument corresponding to a double parameter has type long double, then all arguments corresponding to double parameters are\n  effectively cast to long double.</li>\n<li>Otherwise, if any argument corresponding to a double parameter has type double or an integer type, then all arguments corresponding to\n  double parameters are effectively cast to double.</li>\n<li>Otherwise, all arguments corresponding to double parameters are effectively cast to float.</li>\n</ol>\n</blockquote>\n<p><b>This seems valid in C++11</b></p>\n<p>In C++11  section <code>26.8</code> <em>[c.math]</em> does not include any restrictions disallowing non-arithmetic arguments to <code>cmath</code> functions. In each case from the question we have an overload available which takes <em>double</em> argument(s) and these should be selected via <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow\">overload resolution</a>. </p>\n<p><b>Defect report 2086</b></p>\n<p>But for C++14 we have <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#2086\" rel=\"nofollow\">defect report 2086: Overly generic type support for math functions</a>, which argues that the original intent of section <code>26.8</code> <em>[c.math]</em> was to limit <code>cmath</code> functions to be valid only for <em>arithmetic types</em>, which would mimic how they worked in <em>C</em>:</p>\n<blockquote>\n<p id=\"so_30766491_30766492_1\">My impression is that this rule set is probably more generic as\n  intended, my assumption is that it is written to mimic the C99/C1x\n  rule set in 7.25 p2+3 in the \"C++\" way [...] (note that C constraints\n  the valid set to types that C++ describes as arithmetic types, but see\n  below for one important difference) [...]</p>\n</blockquote>\n<p>and says:</p>\n<blockquote>\n<p id=\"so_30766491_30766492_2\">My current suggestion to fix these problems would be to constrain the\n  valid argument types of these functions to arithmetic types.</p>\n</blockquote>\n<p>and reworded section <code>26.8</code> paragraph <code>11</code> to say (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_30766491_30766492_3\">Moreover, there shall be additional overloads sufficient to ensure:</p>\n<ol>\n<li>If any <strong>arithmetic</strong> argument corresponding to a double parameter has type long double, then all <strong>arithmetic</strong> arguments corresponding to\n  double parameters are effectively cast to long double.</li>\n<li>Otherwise, if any <strong>arithmetic</strong> argument corresponding to a double parameter has type double or an integer type, then all <strong>arithmetic</strong>\n  arguments corresponding to double parameters are effectively cast to\n  double.</li>\n<li>Otherwise, all <strong>arithmetic</strong> arguments corresponding to double parameters are effectively cast to <strong><s>are effectively cast to</s> have type</strong> float.</li>\n</ol>\n</blockquote>\n<p><b>So this is invalid in C++14?</b></p>\n<p>Well, despite the intent it looks technically to still be valid as argued in this comment from the discussion in <a href=\"https://llvm.org/bugs/show_bug.cgi?id=18218#c8\" rel=\"nofollow\">libc++ bug report:  incorrect implementation of isnan and similar functions</a>:</p>\n<blockquote>\n<p id=\"so_30766491_30766492_4\">That may have been the intent, but I don't see any way to read the\n  standard's wording that way. From the example in comment#0:</p>\n<pre><code>std::isnan(A());\n</code></pre>\n<p id=\"so_30766491_30766492_5\">There are no arguments of arithmetic type, so none of the bullets in\n  26.8/11 apply. The overload set contains 'isnan(float)', 'isnan(double)', and 'isnan(long double)', and 'isnan(float)' should\n  be selected.</p>\n</blockquote>\n<p>So, the rewording by <code>DR 2086</code> of paragraph <em>11</em> does not make it ill-formed to call the <em>float</em>, <em>double</em> and <em>long double</em> overloads available otherwise with non-arithmetic arguments.</p>\n<p><b>Technically valid but questionable to use</b></p>\n<p>So although the C++11 and C++14 standard do not restrict <code>cmath</code> functions to arithmetic arguments <code>DR 2068</code> argues the intent of <code>26.8</code> paragraph <code>11</code> was to restrict <code>cmath</code> functions to take only arithmetic arguments and apparently intended to close the loophole in C++14, but did not provide strong enough restrictions.</p>\n<p>It seems questionable to rely on a feature which could become ill-formed in a future version of the standard. Since we have implementation divergence any code that relies on passing non-arithmetic arguments to <code>cmath</code> functions for those cases is non-portable and so will be useful only in limited situations. We have an alternative solution, which is to explicitly cast non-arithmetic types to arithmetic types, which bypasses the whole issue, we no longer have to worry about the code becoming ill-formed and it is portable:</p>\n<pre><code>std::isgreater( static_cast&lt;double&gt;(s) ,1.0)\n                ^^^^^^^^^^^^^^^^^^^^^^\n</code></pre>\n<p>As Potatoswatter points out using unary <code>+</code> is also an option:</p>\n<pre><code>std::isgreater( +s ,1.0)\n</code></pre>\n<p><b>Update</b></p>\n<p>As T.C. points out in C++11 it can be argued that <code>26.8</code> paragraph <code>11</code> bullet <code>3</code> applies since the argument is neither <em>long double</em>, <em>double</em> nor an integer and should therefore the arguments of type <code>S</code> should be cast to <em>float</em> first. Note, as indicated by the defect report <code>gcc</code> never implemented this and as far I know neither did <code>clang</code>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-06-12T11:41:27.840", "Id": "30766492", "Score": "7", "CreationDate": "2015-06-10T20:18:15.740", "LastActivityDate": "2015-06-12T11:41:27.840"}, "bq_ids": {"n4140": {"so_30766491_30766492_3": {"section_id": 3876, "quality": 1.0, "length": 6}, "so_30766491_30766492_0": {"section_id": 3876, "quality": 1.0, "length": 6}}, "n3337": {"so_30766491_30766492_3": {"section_id": 3736, "quality": 1.0, "length": 6}, "so_30766491_30766492_0": {"section_id": 3736, "quality": 1.0, "length": 6}}, "n4659": {"so_30766491_30766492_3": {"section_id": 4690, "quality": 0.8333333333333334, "length": 5}, "so_30766491_30766492_0": {"section_id": 4690, "quality": 0.8333333333333334, "length": 5}}}, "30766491": {"CommentCount": "0", "ViewCount": "211", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-06-10T20:18:15.740", "LastActivityDate": "2015-06-12T11:41:27.840", "Title": "Is it valid to pass non-arithmetic types as arguments to cmath functions?", "LastEditDate": "2015-06-10T22:16:19.010", "Id": "30766491", "Score": "5", "Body": "<p>Given the following user-defined type <code>S</code> with a conversion function to <em>double</em>:</p>\n<pre><code>struct S\n{\n   operator double() { return 1.0;}\n};\n</code></pre>\n<p>and the following calls to <a href=\"http://en.cppreference.com/w/cpp/header/cmath\" rel=\"nofollow\">cmath</a> functions using the type <code>S</code>:</p>\n<pre><code>#include &lt;cmath&gt;\n\nvoid test(S s) {\n   std::sqrt(s); \n   std::log(s); \n   std::isgreater(s,1.0);\n   std::isless(s,1.0);\n   std::isfinite(s) ;\n}\n</code></pre>\n<p>This code compiles with <code>gcc</code> using <code>libstdc++</code> (<em><a href=\"http://melpon.org/wandbox/permlink/15CSejElegZAf85f\" rel=\"nofollow\">see it live</a></em>) but with <code>clang</code> using <code>libc++</code> it generates errors for several of the calls (<em><a href=\"http://melpon.org/wandbox/permlink/ImDK79QNvnVG0hnn\" rel=\"nofollow\">see it live</a></em>) with the following error for <a href=\"http://en.cppreference.com/w/cpp/numeric/math/isgreater\" rel=\"nofollow\">isgreater</a>:</p>\n<pre><code>error: no matching function for call to 'isgreater'\n   std::isgreater(s,1.0);\n   ^~~~~~~~~~~~~~\n\nnote: candidate template ignored: disabled by 'enable_if' [with _A1 = S, _A2 = double]\nstd::is_arithmetic&lt;_A1&gt;::value &amp;&amp;\n^\n</code></pre>\n<p>and similar errors for <a href=\"http://en.cppreference.com/w/cpp/numeric/math/isless\" rel=\"nofollow\">isless</a> and <a href=\"http://en.cppreference.com/w/cpp/numeric/math/isfinite\" rel=\"nofollow\">isfinite</a>, so <code>libc++</code> expects the arguments for those calls to be <a href=\"http://en.cppreference.com/w/cpp/types/is_arithmetic\" rel=\"nofollow\">arithmetic types</a> which <code>S</code> is not, we can confirm this by going to the source for <a href=\"https://github.com/llvm-mirror/libcxx/blob/0b6f8ed1c772afbdb2c28451e67ac5ee7b6092fe/include/cmath\" rel=\"nofollow\">libc++ cmath header</a>. Although, the requirement for arithmetic types is not consistent across all the <code>cmath</code> functions in <code>libc++</code>.</p>\n<p>So the question is, is it valid to pass non-arithmetic types as arguments to <code>cmath</code> functions?</p>\n", "Tags": "<c++><c++11><language-lawyer><c++14><cmath>", "OwnerUserId": "1708801", "AnswerCount": "1"}});