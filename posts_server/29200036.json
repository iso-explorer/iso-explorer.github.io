post_cb({"bq_ids": {"n4140": {"so_29200036_29200718_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 6342}, "so_29200036_29200036_0": {"length": 31, "quality": 1.0, "section_id": 3327}, "so_29200036_29200718_0": {"length": 13, "quality": 1.0, "section_id": 6342}}, "n3337": {"so_29200036_29200718_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 6099}, "so_29200036_29200036_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 3197}, "so_29200036_29200718_0": {"length": 13, "quality": 1.0, "section_id": 6099}}, "n4659": {"so_29200036_29200718_1": {"length": 16, "quality": 0.7272727272727273, "section_id": 7847}, "so_29200036_29200036_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 4093}, "so_29200036_29200718_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 7851}}}, "29200426": {"Id": "29200426", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_29200036_29200426_0\">Is the synopsis under-specified?</p>\n</blockquote>\n<p>No, it documents the user-facing bits of the <code>initializer_list</code> class template, the parts you're actually allowed to make use of in your code. According to the synopsis the template only contains a default constructor, allowing you to create empty <code>initializer_list</code>s, which is clearly not very useful. However, <code>initializer_list&lt;T&gt;</code> is a type that depends on some <em>magic</em> being done by the compiler. By magic, I'm referring to \u00a78.5.4/5 that you've quoted. This allows the following statement to be legal and compile.</p>\n<pre><code>std::initializer_list&lt;int&gt; numbers{1, 2, 3, 4}; // no such constructor in the synopsis\n</code></pre>\n<p>Here, as explained in \u00a78.5.4/5, the compiler will create an array containing the four integers, and then initialize the <code>initializer_list&lt;int&gt;</code> instance with either a pair of pointers (first element and one past the end element) or a pointer and length (which is what both libstdc++ and libc++ seem to do).</p>\n<p>Once the instance has been created, your code is allowed to access all the member functions listed in the synopsis.</p>\n<blockquote>\n<p id=\"so_29200036_29200426_1\">Does the library need a private constructor? What does it do that the compiler can't?</p>\n</blockquote>\n<p>As the comment above the libstdc++ private constructor definition implies, the compiler is capable of emitting code that bypasses normal access control, so no, I'd say it's not essential to have that constructor. The compiler could use the default constructor to construct an empty <code>initializer_list</code> instance, and then assign appropriate values to the private data members (these aren't listed in the synopsis either, but are necessary).</p>\n<p>But why bother with that clumsiness when a private constructor provides a clean interface that the compiler can call?</p>\n", "LastActivityDate": "2015-03-22T22:08:09.957", "Score": "2", "CreationDate": "2015-03-22T22:08:09.957", "ParentId": "29200036", "CommentCount": "1", "OwnerUserId": "241631"}, "29200036": {"ViewCount": "336", "Body": "<p>This draft standard shows the synopsis for <code>initializer_list</code>. It has no private constructor.</p>\n<p><img alt=\"http://i.stack.imgur.com/5bc61.png\" src=\"https://i.stack.imgur.com/5bc61.png\"/></p>\n<p>But two standard library implementations I have looked at, libstdc++ and libc++, both provide private constructors:</p>\n<pre><code>  // The compiler can call a private constructor.\n  constexpr initializer_list(const_iterator __a, size_type __l)\n  : _M_array(__a), _M_len(__l) { }\n\n_LIBCPP_ALWAYS_INLINE\n_LIBCPP_CONSTEXPR_AFTER_CXX11\ninitializer_list(const _Ep* __b, size_t __s) _NOEXCEPT\n    : __begin_(__b),\n      __size_(__s)\n    {}\n</code></pre>\n<p>I believe the part where this private constructor is \"implied\" stems from \u00a78.5.4/5: </p>\n<blockquote>\n<p id=\"so_29200036_29200036_0\">An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an\n  initializer list as if the implementation allocated a temporary array\n  of <em>N</em> elements of type <code>const E</code>, where <em>N</em> is the number of elements\n  in the initializer list. Each element of that array is\n  copy-initialized with the corresponding element of the initializer\n  list, and the <code>std::initializer_list&lt;E&gt;</code> object is constructed to\n  refer to that array.</p>\n</blockquote>\n<p>So my questions are:</p>\n<ul>\n<li><p>Is the synopsis under-specified?</p></li>\n<li><p>Does the library need a private constructor? What does it do that the compiler can't?</p></li>\n</ul>\n", "Title": "Is providing a private constructor for initializer_list conforming?", "CreationDate": "2015-03-22T21:24:10.023", "LastActivityDate": "2015-03-22T22:40:03.497", "CommentCount": "2", "LastEditDate": "2015-03-22T22:07:52.163", "PostTypeId": "1", "LastEditorUserId": "1505939", "Id": "29200036", "Score": "8", "OwnerUserId": "4700874", "Tags": "<c++><c++11><language-lawyer><c++-standard-library>", "AnswerCount": "2"}, "29200718": {"Id": "29200718", "PostTypeId": "2", "Body": "<p>The question boils down to whether an implementation may define something beyond what the standard dictated. Yes, that is possible.  </p>\n<p>Indeed <strong>\u00a717.6.5.5</strong> (draft n\u00b0 3797) states:</p>\n<blockquote>\n<p id=\"so_29200036_29200718_0\">A call to a member function signature described in the C ++ standard\n  library behaves as if the implementation declares no additional member\n  function signatures.</p>\n</blockquote>\n<p>Footnote 189:</p>\n<blockquote>\n<p id=\"so_29200036_29200718_1\">189) A valid C++ program always calls the expected library member\n  function, or one with equivalent behavior. An implementation may\n  also define additional member functions that would otherwise not be\n  called by a valid C++ program.</p>\n</blockquote>\n<p>You are not allowed to call to call those additional member functions, even if they were accessible. </p>\n<h2>Regarding <code>std::initializer_list</code></h2>\n<blockquote>\n<p id=\"so_29200036_29200718_2\">Does the library need a private constructor? What does it do that the compiler can't?</p>\n</blockquote>\n<p>The standard defines what you'd expect when constructing a <code>std::initializer_list&lt;T&gt;</code> from an initializer list. The way it's done is implementation-defined and, for what said above, it may therefore call a <code>private</code> constructor.</p>\n", "LastActivityDate": "2015-03-22T22:40:03.497", "Score": "1", "CreationDate": "2015-03-22T22:40:03.497", "ParentId": "29200036", "CommentCount": "0", "OwnerUserId": "2692339"}});