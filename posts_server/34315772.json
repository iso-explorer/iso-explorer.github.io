post_cb({"34315889": {"CreationDate": "2015-12-16T15:27:52.660", "CommentCount": "0", "Body": "<p>No, the result of <code>foo()[1]</code> is an lvalue. According to \u00a73.10:</p>\n<blockquote>\n<p id=\"so_34315772_34315889_0\">An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object. [ Example: If E is an expression of pointer type, then *E is an lvalue expression referring to the object or function to which E points. <strong>As another example, the result of calling a function whose return type is an lvalue reference is an lvalue.</strong> \u2014 end example ]</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>On the other hand you can make it so it returns an rvalue reference in that case, by using:</p>\n<pre><code>struct Obj\n{\n    int&amp;&amp; operator[](int i) &amp;&amp;\n    //                      ^^\n    {   \n        return std::move(data_[i]); \n        //     ^^^^^^^^^^        ^\n    }\n    int data_[20];\n};\n</code></pre>\n<p>or declare the function to be not allowed on r-values by</p>\n<pre><code>struct Obj\n{\n    int&amp; operator[](int i) &amp;\n    //                      ^^\n    {   \n        return data_[i];\n    }\n    int data_[20];\n};\n</code></pre>\n<p>This will now trigger a compile-time error when you do <code>bar()[0]</code>.</p>\n", "Id": "34315889", "OwnerUserId": "493122", "LastEditDate": "2015-12-16T17:33:52.987", "ParentId": "34315772", "LastActivityDate": "2015-12-16T17:33:52.987", "PostTypeId": "2", "Score": "2", "LastEditorUserId": "2169853"}, "34315772": {"CreationDate": "2015-12-16T15:22:37.680", "ViewCount": "51", "Id": "34315772", "AcceptedAnswerId": "34315875", "Score": "1", "Title": "Any member function invoked from a rvalue will return a rvalue?", "LastEditorUserId": "440403", "CommentCount": "1", "Body": "<p>I am wondering if any member function invoked from a rvalue will  return a rvalue in c++11 standard.</p>\n<p>for example:</p>\n<pre><code>Obj foo();\nstruct Obj\n{\n    int&amp; operator[](int i)\n    {   \n        return data_[i]; \n    }\n    int data_[20];\n};\nfoo()[1]; // this expression will be treated as rvalue, right? \n          // althrough operator[] return a reference\n</code></pre>\n<p><strong>UPDATE:</strong></p>\n<p>if not, it will be very easy to make the mistake below:</p>\n<pre><code>decltype(foo()[1]) ai = foo()[1];  //both reference to an obj destroied\ndecltype(auto) ai = foo()[1];\n</code></pre>\n", "Tags": "<c++11>", "LastEditDate": "2015-12-16T15:48:39.867", "LastActivityDate": "2015-12-16T17:33:52.987", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "440403"}, "34315875": {"CreationDate": "2015-12-16T15:27:16.707", "CommentCount": "0", "Body": "<p>Nope, it'll be an lvalue and if you store a reference to it some place you're on the fast-track to undefined behaviour.</p>\n<p>A similar relatively common mistake is storing the result of <code>std::string::c_str()</code>:</p>\n<pre><code>const char* dont_do_this = getStdString().c_str();\n</code></pre>\n<p>Regarding your update code, the solution is to be aware of object lifetimes when you could be creating a reference. <code>decltype(x)</code> can be a reference type, so you better be sure that if it is, you aren't referencing something which is going to be blasted into oblivion.</p>\n", "Id": "34315875", "OwnerUserId": "496161", "LastEditDate": "2015-12-16T15:54:37.483", "ParentId": "34315772", "LastActivityDate": "2015-12-16T15:54:37.483", "PostTypeId": "2", "Score": "3", "LastEditorUserId": "496161"}, "bq_ids": {"n4140": {"so_34315772_34315889_0": {"length": 36, "quality": 0.9473684210526315, "section_id": 7230}}, "n3337": {"so_34315772_34315889_0": {"length": 36, "quality": 0.9473684210526315, "section_id": 6974}}}});