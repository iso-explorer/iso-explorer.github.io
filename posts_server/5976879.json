post_cb({"5976946": {"ParentId": "5976879", "CommentCount": "9", "Body": "<p>5.3.3/1:</p>\n<blockquote>\n<p id=\"so_5976879_5976946_0\">The sizeof operator yields the number\n  of bytes in the object representation\n  of its operand. The operand is either\n  an expression, <strong>which is not evaluated</strong>,\n  or a parenthesized type-id.</p>\n</blockquote>\n<p>The above means the following construct is well defined:</p>\n<pre><code>sizeof( ((foo *) 0)-&gt;a);\n</code></pre>\n", "OwnerUserId": "616700", "PostTypeId": "2", "Id": "5976946", "Score": "25", "CreationDate": "2011-05-12T10:55:54.433", "LastActivityDate": "2011-05-12T10:55:54.433"}, "5987150": {"ParentId": "5976879", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>C++-0x allows you to do this:</p>\n<pre><code>  std::cout &lt;&lt; sizeof( foo::a ) &lt;&lt; std::endl;\n  std::cout &lt;&lt; sizeof( foo::b ) &lt;&lt; std::endl;\n  std::cout &lt;&lt; sizeof( foo::c ) &lt;&lt; std::endl;\n</code></pre>\n<p>C++-0x allows sizeof to work on members of classes without an explicit object.</p>\n<p>The paper is here: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2253.html\" rel=\"nofollow\">Extending sizeof to apply to non-static data members without an object (revision 1)</a></p>\n<p>I saw the post about this above too late.  Sorry.</p>\n", "OwnerUserId": "680359", "LastEditorUserId": "680359", "LastEditDate": "2011-05-13T04:22:07.397", "Id": "5987150", "Score": "1", "CreationDate": "2011-05-13T04:12:45.423", "LastActivityDate": "2011-05-13T04:22:07.397"}, "5976987": {"ParentId": "5976879", "CommentCount": "2", "Body": "<p>Use this form: <code>sizeof(foo::a)</code> instead. </p>\n", "OwnerUserId": "746961", "PostTypeId": "2", "Id": "5976987", "Score": "10", "CreationDate": "2011-05-12T10:59:08.767", "LastActivityDate": "2011-05-12T10:59:08.767"}, "5976985": {"ParentId": "5976879", "CommentCount": "1", "Body": "<p>You can do that in C++0x:</p>\n<pre><code>sizeof(foo::a);\n</code></pre>\n", "OwnerUserId": "16102", "PostTypeId": "2", "Id": "5976985", "Score": "32", "CreationDate": "2011-05-12T10:59:05.340", "LastActivityDate": "2011-05-12T10:59:05.340"}, "5976988": {"ParentId": "5976879", "PostTypeId": "2", "CommentCount": "4", "Body": "<pre><code>struct foo\n{\n   short a;\n   int b;\n   char c[50];\n   // ...\n   static const size_t size_a = sizeof(a);\n   static const size_t size_b = sizeof(b);\n   static const size_t size_c = sizeof(c);\n};\n</code></pre>\n<p>Usage:</p>\n<pre><code>foo::size_a\n</code></pre>\n", "OwnerUserId": "514235", "LastEditorUserId": "514235", "LastEditDate": "2015-07-31T13:26:10.743", "Id": "5976988", "Score": "-2", "CreationDate": "2011-05-12T10:59:15.940", "LastActivityDate": "2015-07-31T13:26:10.743"}, "5976879": {"CommentCount": "2", "AcceptedAnswerId": "5976946", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2011-05-12T10:50:05.993", "LastActivityDate": "2015-07-31T13:26:10.743", "LastEditDate": "2015-07-15T17:50:51.413", "ViewCount": "9296", "FavoriteCount": "2", "Title": "Getting the size of member variable", "Id": "5976879", "Score": "21", "Body": "<p>If there is a <a href=\"http://en.wikipedia.org/wiki/Plain_old_data_structure\">POD</a> structure, with some member variables, for example like this:</p>\n<pre><code>struct foo\n{\n   short a;\n   int b;\n   char c[50];\n   // ...\n};\n</code></pre>\n<p>Is there a way to get the size of a member variable in bytes, without creating an object of this type?</p>\n<p>I know that this will work:</p>\n<pre><code>foo fooObj;\nstd::cout &lt;&lt; sizeof( fooObj.a ) &lt;&lt; std::endl;\nstd::cout &lt;&lt; sizeof( fooObj.b ) &lt;&lt; std::endl;\nstd::cout &lt;&lt; sizeof( fooObj.c ) &lt;&lt; std::endl;\n</code></pre>\n<p>Would the following be optimized by the compiler and prevent the construction of an object?</p>\n<pre><code>std::cout &lt;&lt; sizeof( foo().a ) &lt;&lt; std::endl;\n</code></pre>\n", "Tags": "<c++><c++11>", "OwnerUserId": "476681", "AnswerCount": "7"}, "5977039": {"ParentId": "5976879", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>You can create macro wrapper of what @Erik suggested as:</p>\n<pre><code>#define SIZE_OF_MEMBER(cls, member) sizeof( ((cls*)0)-&gt;member )\n</code></pre>\n<p>And then use it as:</p>\n<pre><code>cout &lt;&lt; SIZE_OF_MEMBER(foo, c) &lt;&lt; endl;\n</code></pre>\n<p>Output:</p>\n<pre><code>50\n</code></pre>\n<p>Demo : <a href=\"http://www.ideone.com/ZRiMe\" rel=\"nofollow\">http://www.ideone.com/ZRiMe</a></p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-05-12T11:45:31.407", "Id": "5977039", "Score": "0", "CreationDate": "2011-05-12T11:04:28.570", "LastActivityDate": "2011-05-12T11:45:31.407"}, "5976970": {"ParentId": "5976879", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>Use the obvious:</p>\n<pre><code>sizeof( foo::a )\n</code></pre>\n<p>In C++, sizeof is ALWAYS evaluated at compile time, so there is no runtime cost whatsoever.</p>\n", "OwnerUserId": "2100815", "LastEditorUserId": "63550", "LastEditDate": "2015-07-15T17:51:54.450", "Id": "5976970", "Score": "6", "CreationDate": "2011-05-12T10:58:10.863", "LastActivityDate": "2015-07-15T17:51:54.450"}, "bq_ids": {"n4140": {"so_5976879_5976946_0": {"section_id": 6076, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_5976879_5976946_0": {"section_id": 5844, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_5976879_5976946_0": {"section_id": 7572, "quality": 0.8235294117647058, "length": 14}}}});