post_cb({"21077213": {"ParentId": "21077140", "LastEditDate": "2014-01-13T17:07:56.073", "CommentCount": "5", "CreationDate": "2014-01-12T16:34:26.270", "OwnerUserId": "2344584", "LastEditorUserId": "2344584", "PostTypeId": "2", "Id": "21077213", "Score": "8", "Body": "<p>The implementation of <code>delete</code> and <code>delete[]</code> is composed of two phases:</p>\n<ol>\n<li>recursive call to destructors (if any)</li>\n<li>memory deallocation for deleted object </li>\n</ol>\n<p>Let alone the chain of calls to destructors, whose complexity is essentially governed by you, we are left with how the memory is freed to consider.</p>\n<p>The second point is not covered by the C++ specification. So, any compiler suite/OS is free to adopt its own strategy.</p>\n<p>A common memory allocation/deallocation strategy is allocating a whole memory page when needed from the OS, then at each <code>new</code>/<code>new[]</code>, returning a chunk of the appropriate size, whose length and attributes are then stored inside the page as a header/footer. A corresponding <code>delete</code>/<code>delete[]</code> can be as simple as marking that same chunk as \"free\", which is clearly O(1).</p>\n<p><strong>If the complexity of memory deallocation is O(1), then the complexity of a <code>delete</code> is essentially governed by calls to destructors</strong>. The default implementation does (almost) nothing, and it's a O(1) for a single call, thus an overall <strong>O(n)</strong>, where n is the toal number of calls (e.g. if the object being destructed has two fields whose destructor is called, then <code>n = 1 (object) + 2 (o. fields) = 3</code>).</p>\n<p>Putting all pieces together: you can arbitrarily increment complexity by performing operations in the destructor (which can be written by you), but you cannot \"perform better\"\u00b9  than  O(n) (n defined in the previous paragraph). <strong>The formally correct way to state this is: \"the complexity of <code>delete</code> is an Omega(n)\"</strong>.</p>\n<hr>\n<p>\u00b9 allow me to be a bit informal on this point</p>\n</hr>", "LastActivityDate": "2014-01-13T17:07:56.073"}, "21077140": {"CreationDate": "2014-01-12T16:27:15.177", "CommentCount": "8", "ViewCount": "2388", "PostTypeId": "1", "ClosedDate": "2014-01-13T20:14:46.497", "LastEditorUserId": "514235", "LastActivityDate": "2014-01-18T04:10:20.333", "LastEditDate": "2014-01-12T18:16:45.587", "AcceptedAnswerId": "21077195", "FavoriteCount": "6", "Title": "Time complexity of delete[] operator", "Id": "21077140", "Score": "40", "Body": "<p>What is the <em>Time Complexity</em> of the <code>delete[]</code> operator? </p>\n<p>I mean how is it implemented - does it iterate over all the elements in the array and calls destructor for every element?</p>\n<p>Does this operator do the same for <em>primitive types</em> (<code>int</code>, etc.) and user defined types?</p>\n", "Tags": "<c++><destructor><time-complexity><delete-operator>", "OwnerUserId": "2436295", "AnswerCount": "4"}, "21077258": {"ParentId": "21077140", "CommentCount": "3", "Body": "<p>For class types, the theoretical complexity is <code>O(n)</code>. The destructor is called for each element. Of course, it's up to the implementation to adhere to the observable behavior, so if the destructor is a no-op or the behavior is the same as with just marking the whole chunk as freed, the complexity could be just <code>O(1)</code>.</p>\n<p>For primitive types, the compiler will likely just release the whole chunk of memory at once, thus the complexity <code>O(1)</code>.</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "21077258", "Score": "1", "CreationDate": "2014-01-12T16:37:59.807", "LastActivityDate": "2014-01-12T16:37:59.807"}, "21078439": {"ParentId": "21077140", "LastEditDate": "2017-05-23T11:44:36.663", "CommentCount": "0", "CreationDate": "2014-01-12T18:14:44.860", "OwnerUserId": "514235", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "21078439", "Score": "0", "Body": "<blockquote>\n<p id=\"so_21077140_21078439_0\">What is the Time Complexity of the <code>delete[]</code> operator?</p>\n</blockquote>\n<p>The amount of the time required is of course implementation defined. <strike>However, the operator applies only to the pointer to the 1D array and thus it's O(1). </strike></p>\n<blockquote>\n<p id=\"so_21077140_21078439_1\">I mean how is it implemented - does it iterate over all the elements\n  in the array and calls destructor for every element?</p>\n</blockquote>\n<p>Yes.<br>\nProvided that it's called only on the <strong>exact</strong> pointer which is assigned a memory created using <code>new[]</code>. For primitive types there are no user defined destructors.</br></p>\n<blockquote>\n<p id=\"so_21077140_21078439_2\">Does this operator do the same for primitive types (int, etc.) and\n  user defined types?</p>\n</blockquote>\n<p>The comparison is not fair, because primitive types don't have user defined destructor and they cannot be polymorhpic.<br>\nFor example, <code>delete[]</code> on a <a href=\"https://stackoverflow.com/questions/6171814/why-is-it-undefined-behavior-to-delete-an-array-of-derived-objects-via-a-base\">polymorphic class is an undefined behavior</a>. i.e.</br></p>\n<pre><code>Base* p1 = new Derived, *p2 = new Derived[2];\ndelete p1; // ok\ndelete[] p2;  // bad\n</code></pre>\n", "LastActivityDate": "2014-01-18T04:10:20.333"}, "bq_ids": {"n4140": {"so_21077140_21077195_1": {"section_id": 6110, "quality": 0.9666666666666667, "length": 29}}, "n3337": {"so_21077140_21077195_1": {"section_id": 5876, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_21077140_21077195_1": {"section_id": 7607, "quality": 0.9666666666666667, "length": 29}}}, "21077195": {"CommentCount": "10", "CreationDate": "2014-01-12T16:33:17.733", "CommunityOwnedDate": "2014-01-13T06:02:12.787", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-13T06:02:12.787", "ParentId": "21077140", "PostTypeId": "2", "LastEditDate": "2017-05-23T11:59:08.557", "Id": "21077195", "Score": "32", "Body": "<p><a href=\"http://www.cplusplus.com/reference/new/operator%20delete%5B%5D/\" rel=\"nofollow noreferrer\"><code>::operator delete[]</code></a> is documented on <a href=\"http://www.cplusplus.com/\" rel=\"nofollow noreferrer\">cplusplus.com</a> (which is sometimes frowned upon) as:</p>\n<blockquote>\n<p id=\"so_21077140_21077195_0\"><code>operator delete[]</code> can be called explicitly as a regular function, but in C++, <code>delete[]</code> is an operator with a very <em>specific behavior</em>: An expression with the <code>delete[]</code> operator, first <em>calls the appropriate destructors</em> for <em>each</em> element in the array (if these are of a class type), and then calls function  <code>operator delete[]</code> (i.e., this function) to release the storage.</p>\n</blockquote>\n<p>so the destructor is called <em>n</em> times (once for each element), and then the memory freeing \"function\" is called once.</p>\n<p><sup>Notice that each destruction might take a different time (or even complexity) than the others. Generally most destructions are quick, and have the same complexity.... But that won't be the case if each destroyed element is a complex tree or node or graph...</sup></p>\n<p>For primitive types like <code>int</code> the fictitious destructor of <code>int</code> is a no-op. The compiler probably would optimize that (if asked).</p>\n<p>You should check the real <a href=\"http://en.wikipedia.org/wiki/C++11\" rel=\"nofollow noreferrer\">C++11</a> standard, or at least its late <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">n3337</a> working draft, which says (thanks to <a href=\"https://stackoverflow.com/users/214671/matteo-italia\">Matteo Italia</a> for pointing that in a comment) in \u00a75.3.5.6 page 110 of n3337: </p>\n<blockquote>\n<p id=\"so_21077140_21077195_1\">If the value of the operand of the <em>delete-expression</em> is not a null pointer value, the <em>delete-expression</em> will\n  invoke the destructor (if any) for the object or the elements of the array being deleted. In the case of an\n  array, the elements will be destroyed in order of decreasing address (that is, in reverse order of the completion\n  of their constructor; see 12.6.2)</p>\n</blockquote>\n<p>If you use -and trust enough- <a href=\"http://gcc.gnu.org/gcc-4.8/\" rel=\"nofollow noreferrer\">GCC 4.8</a> or better, you could have used the <code>g++</code> compiler with the <code>-fdump-tree-phiopt</code> or <code>-fdump-tree-all</code> option (beware, they are dumping a lot of files!), or the <a href=\"http://gcc-melt.org/\" rel=\"nofollow noreferrer\">MELT</a> plugin, to query the intermediate Gimple representation of some example. Or use <code>-S -fverbose-asm</code> to get the assembler code. And you also want to add optimization flags like <code>-O1</code> or <code>-O2</code> ...</p>\n<p><sup>NB: IMHO, <a href=\"http://cppreference.com/\" rel=\"nofollow noreferrer\">cppreference.com</a> is also an interesting site about C++, see <a href=\"http://en.cppreference.com/w/cpp/language/delete\" rel=\"nofollow noreferrer\">there</a> about <code>delete</code> (as commented by <a href=\"https://stackoverflow.com/users/273767/cubbi\">Cubbi</a>)</sup></p>\n", "OwnerUserId": "841108"}});