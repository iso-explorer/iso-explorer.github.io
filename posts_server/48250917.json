post_cb({"bq_ids": {"n4140": {"so_48250917_48250917_0": {"length": 88, "quality": 0.946236559139785, "section_id": 481}}, "n3337": {"so_48250917_48250917_0": {"length": 64, "quality": 0.6881720430107527, "section_id": 472}}, "n4659": {"so_48250917_48250917_0": {"length": 77, "quality": 0.8279569892473119, "section_id": 504}}}, "48251975": {"Id": "48251975", "PostTypeId": "2", "Body": "<p>What happen in your example is not linked to RVO, but to the ternary <code>operator ?</code>. If you rewrite your example code using an <code>if</code> statement, the behavior of the program will be the one expected. Change <code>foo</code> definition to:</p>\n<pre><code>Test foo(int param)\n  {\n  Test test1;\n  Test test2;\n  if (param &gt; 5)\n    return std::move(test2);\n  else\n    return test1;\n  }\n</code></pre>\n<p>will output <code>Test(Test&amp;&amp;)</code>.</p>\n<hr>\n<p>What happens if you write <code>(param&gt;5)?std::move(test1):test2</code> is:</p>\n<ol>\n<li>The ternary operator result is deduced to be a <em>prvalue</em> <a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.cond#5\" rel=\"nofollow noreferrer\">[expr.cond]/5</a></li>\n<li>Then <code>test2</code> pass through <a href=\"https://timsong-cpp.github.io/cppwp/n4140/conv.lval#2.4\" rel=\"nofollow noreferrer\"><em>lvalue-to-rvalue</em></a> conversion which causes <a href=\"https://timsong-cpp.github.io/cppwp/n4140/dcl.init#15\" rel=\"nofollow noreferrer\">copy-initialization</a> as required in <a href=\"https://timsong-cpp.github.io/cppwp/n4140/expr.cond#6\" rel=\"nofollow noreferrer\">[expr.cond]/6</a></li>\n<li>Then the move construction of the return value is elided <a href=\"https://timsong-cpp.github.io/cppwp/n4140/class.copy#31.3\" rel=\"nofollow noreferrer\">[class.copy]/31.3</a></li>\n</ol>\n<p>So in your example code, move elision occurs, nevertheless after the copy-initialization required to form the result of the ternary operator.</p>\n</hr>", "LastEditorUserId": "5632316", "LastActivityDate": "2018-01-14T17:45:00.947", "Score": "5", "CreationDate": "2018-01-14T16:59:32.393", "ParentId": "48250917", "CommentCount": "0", "OwnerUserId": "5632316", "LastEditDate": "2018-01-14T17:45:00.947"}, "48250917": {"ViewCount": "138", "Body": "<p>It is known that <code>std::move</code> should not be applied to the function return values because it can prevent RVO (return value optimization). I am interested in the question what should we do if we certainly know that RVO will not happen.</p>\n<p>This is what the C++14 standard says [12.8/32] </p>\n<blockquote>\n<p id=\"so_48250917_48250917_0\">When the criteria for elision of a copy/move operation are met, but\n  not for an exception-declaration, and the object to be copied is\n  designated by an lvalue, or when the expression in a return statement\n  is a (possibly parenthesized) id-expression that names an object with\n  automatic storage duration declared in the body or\n  parameter-declaration-clause of the innermost enclosing function or\n  lambda-expression, overload resolution to select the constructor for\n  the copy is first performed as if the object were designated by an\n  rvalue. If the first overload resolution fails or was not performed,\n  or if the type of the first parameter of the selected constructor is\n  not an rvalue reference to the object\u2019s type (possibly cv-qualified),\n  overload resolution is performed again, considering the object as an\n  lvalue. [ Note: This two-stage overload resolution must be performed\n  regardless of whether copy elision will occur. It determines the\n  constructor to be called if elision is not performed, and the selected\n  constructor must be accessible even if the call is elided. \u2014 end note\n  ]</p>\n</blockquote>\n<p>Here is the explanation from the book <code>Effective Modern C++</code></p>\n<blockquote>\n<p id=\"so_48250917_48250917_1\">The part of the Standard blessing the RVO goes on to say that if the\n  conditions for the RVO are met, but compilers choose not to perform\n  copy elision, the object being returned must be treated as an rvalue.\n  In effect, the Standard requires that when the RVO is permitted,\n  either copy elision takes place or std::move is implicitly applied to\n  local objects being returned</p>\n</blockquote>\n<p>As I understand when return object can't be elided at first it should be regarded as <code>rvalue</code>. In these example we can see that when we pass argument greater than <code>5</code> object is moved otherwise it is copied. Does it mean that we should explicitly write <code>std::move</code> when we know that RVO will not happen?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n\nstruct Test\n{\n    Test() {}\n\n    Test(const Test&amp; other)\n    {\n        std::cout &lt;&lt; \"Test(const Test&amp;)\" &lt;&lt; std::endl;\n    }\n\n    Test(Test&amp;&amp; other)\n    {\n        std::cout &lt;&lt; \"Test(const Test&amp;&amp;)\" &lt;&lt; std::endl;\n    }\n};\n\nTest foo(int param)\n{\n    Test test1;\n    Test test2;\n    return param &gt; 5 ? std::move(test1) : test2;\n}\n\nint main()\n{\n    Test res = foo(2);\n}\n</code></pre>\n<p>The output of this program is <code>Test(const Test&amp;)</code>.</p>\n", "AcceptedAnswerId": "48251975", "Title": "Should we write `std::move` in the cases when RVO can not be done?", "CreationDate": "2018-01-14T15:04:47.763", "LastActivityDate": "2018-01-14T17:45:00.947", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-14T16:43:55.343", "LastEditorUserId": "5632316", "Id": "48250917", "Score": "6", "OwnerUserId": "1356110", "Tags": "<c++><return-value><move-semantics><copy-elision><return-value-optimization>", "AnswerCount": "1"}});