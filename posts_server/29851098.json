post_cb({"bq_ids": {"n4140": {"so_29851098_29851257_1": {"length": 17, "quality": 1.0, "section_id": 166}, "so_29851098_29851257_0": {"length": 13, "quality": 1.0, "section_id": 304}}, "n3337": {"so_29851098_29851257_1": {"length": 17, "quality": 1.0, "section_id": 160}, "so_29851098_29851257_0": {"length": 13, "quality": 1.0, "section_id": 295}}, "n4659": {"so_29851098_29851257_1": {"length": 17, "quality": 1.0, "section_id": 170}, "so_29851098_29851257_0": {"length": 13, "quality": 1.0, "section_id": 311}, "so_29851098_29857495_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 171}}}, "29851257": {"Id": "29851257", "PostTypeId": "2", "Body": "<p>It is not a forwarding reference. C++14 (n4140) 14.8.2.1/3 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_29851098_29851257_0\">... If <code>P</code> is an <strong>rvalue reference to a cv-unqualified\n  template parameter</strong> and the argument is an lvalue, the type \u201clvalue reference to <code>A</code>\u201d is used in\n  place of <code>A</code> for type deduction.</p>\n</blockquote>\n<p>This is the piece of the standard which specifies how forwarding references work. <code>P</code>, the type of the function parameter, is of type \"rvalue reference to <code>identity&lt;T&gt;</code>.\" <code>identity&lt;T&gt;</code> is the type of the template parameter, but it is not a template parameter itself, so the forwarding reference deduction rule does not apply.</p>\n<p>We can also look at what 14.5.7/2 has to say about alias templates:</p>\n<blockquote>\n<p id=\"so_29851098_29851257_1\">When a <em>template-id</em> refers to the specialization of an alias template, it is equivalent to the associated <strong>type</strong>\n  obtained by substitution of its <em>template-arguments</em> for the <em>template-parameters</em> in the <em>type-id</em> of the alias\n  template.</p>\n</blockquote>\n<p>So the substituted alias is equivalent to the <strong>type</strong> of <code>T</code>, but 14.8.2.1/3 reads \"reference to ... template parameter,\" not \"reference to ... the type of a template parameter.\"</p>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2015-04-27T08:44:19.813", "Score": "7", "CreationDate": "2015-04-24T15:16:42.533", "ParentId": "29851098", "CommentCount": "7", "OwnerUserId": "1782465", "LastEditDate": "2015-04-27T08:44:19.813"}, "29851098": {"ViewCount": "362", "Body": "<p>Consider the following snippet below:</p>\n<pre><code>template &lt;class T&gt;\nusing identity = T;\n\ntemplate &lt;class T&gt;\nvoid foo(identity&lt;T&gt;&amp;&amp;) {}\n\nint main()\n{\n  int i{};\n  foo(i);\n}\n</code></pre>\n<p><code>i</code> is an lvalue, hence if <code>foo</code> declares a forwarding reference parameter, it should compile. However, if <code>identity&lt;T&gt;&amp;&amp;</code> is turned to be <code>int&amp;&amp;</code>, it should raise an error instead.</p>\n<p>The code compiles in GCC 6.0.0 (<a href=\"http://melpon.org/wandbox/permlink/XQg1vhNx0MSrgHT2\" rel=\"nofollow noreferrer\">demo</a>).</p>\n<p>The code fails to compile in Clang 3.7.0 (<a href=\"http://melpon.org/wandbox/permlink/OGCUVTrh37XPHFdh\" rel=\"nofollow noreferrer\">demo</a>) with error message:</p>\n<pre><code>error: no known conversion from 'int' \nto 'identity&lt;int&gt; &amp;&amp;' (aka 'int &amp;&amp;') for 1st argument\n</code></pre>\n<p>Which one is right?</p>\n", "AcceptedAnswerId": "29857495", "Title": "Can an identity alias template be a forwarding reference?", "CreationDate": "2015-04-24T15:09:50.623", "Id": "29851098", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-05-22T18:50:49.053", "LastEditorUserId": "518530", "LastActivityDate": "2015-05-22T18:50:49.053", "Score": "16", "OwnerUserId": "391022", "Tags": "<c++><templates><alias><c++14><forwarding-reference>", "AnswerCount": "2"}, "29857495": {"Id": "29857495", "PostTypeId": "2", "Body": "<p>Consider this code:</p>\n<pre><code>template&lt;class T&gt; using identity = T;\n\ntemplate&lt;class T&gt; void foo(identity&lt;T&gt;&amp;&amp;) { } //#1\n\ntemplate&lt;class T&gt; void foo(T&amp;&amp;) { } //#2\n\nint main()\n{\n  int i{};\n  foo(i);\n}\n</code></pre>\n<p>Both GCC and Clang reject it because <code>#2</code> is a redefinition of <code>#1</code>. If they're actually the same template, we could expect <code>#1</code> to behave in the exact same way as <code>#2</code>, meaning that <code>identity&lt;T&gt;&amp;&amp;</code> should act as a forwarding reference. Following this logic, we don't know which one is right, but GCC is at least consistent.</p>\n<p>This is also consistent with a very similar example in the standard at [14.5.7p2].</p>\n<p>We should also consider the way template argument deduction can work in this case. If <code>identity</code> were a class template, its form could be matched against the type of the function argument without looking at its definition, allowing the compiler to deduce the template argument for <code>T</code>. However, here we have an alias template; <code>T</code> cannot be deduced to <code>int</code> or <code>int&amp;</code> or anything else unless <code>identity&lt;T&gt;</code> is replaced by <code>T</code>. Otherwise, what are we matching against? Once the replacement is done, the function parameter becomes a forwarding reference.</p>\n<p>All of the above supports the idea of <code>identity&lt;T&gt;&amp;&amp;</code> (and <code>identity&lt;T&amp;&amp;&gt;</code>) being treated as equivalent to a forwarding reference.</p>\n<p>However, it seems that there's more to this that the immediate replacement of the alias template-id with the corresponding type-id. Paragraph [14.5.7p3] says:</p>\n<blockquote>\n<p id=\"so_29851098_29857495_0\">However, if the template-id is dependent, subsequent template argument\n  substitution still applies to the template-id. [ Example:</p>\n<pre><code>template&lt;typename...&gt; using void_t = void; \ntemplate&lt;typename T&gt; void_t&lt;typename T::foo&gt; f(); \nf&lt;int&gt;(); // error, int does not have a nested type foo \n</code></pre>\n<p id=\"so_29851098_29857495_1\">\u2014end example ]</p>\n</blockquote>\n<p>This might not seem to have much to do with your example, but it actually indicates that the initial form of the template-id is still taken into account in some cases, independently of the substituted type-id. I guess this opens the possibility that <code>identity&lt;T&gt;&amp;&amp;</code> could actually not be treated as a forwarding reference after all.</p>\n<p>This area seems to be underspecified in the standard. This shows in the number of open issues dealing with similar problems, all in the same category in my opinion: in what cases should the initial form of the template-id be taken into account upon instantiation, even though it's supposed to be replaced by the corresponding type-id immediately when encountered. See issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1980\" rel=\"nofollow noreferrer\">1980</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#2021\" rel=\"nofollow noreferrer\">2021</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2025\" rel=\"nofollow noreferrer\">2025</a>. Even issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1430\" rel=\"nofollow noreferrer\">1430</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1554\" rel=\"nofollow noreferrer\">1554</a> could be seen as dealing with similar problems.</p>\n<p>In particular, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1980\" rel=\"nofollow noreferrer\">issue 1980</a> contains the following example:</p>\n<pre><code>template&lt;typename T, typename U&gt; using X = T;\ntemplate&lt;typename T&gt; X&lt;void, typename T::type&gt; f();\ntemplate&lt;typename T&gt; X&lt;void, typename T::other&gt; f();\n</code></pre>\n<p>with the note:</p>\n<blockquote>\n<p id=\"so_29851098_29857495_2\">CWG felt that these two declarations should not be equivalent.</p>\n</blockquote>\n<p>(CWG - the Core working group)</p>\n<p>A similar line of reasoning could apply to your example, making <code>identity&lt;T&gt;&amp;&amp;</code> not equivalent to a forwarding reference. This could even have practical value, as a straightforward way of avoiding the greediness of a forwarding reference when all you want is an rvalue reference to a deduced T.</p>\n<p>So, I think you've raised a very interesting problem. Your example may be worth adding as a note to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1980\" rel=\"nofollow noreferrer\">issue 1980</a>, to make sure this is taken into account when drafting the resolution.</p>\n<p>In my opinion, the answer to your question is, for now, a resounding \"who knows?\".</p>\n<hr>\n<p>Update: In the comments to the other, related, <a href=\"https://stackoverflow.com/q/29867841/4326278\">question</a>, <a href=\"https://stackoverflow.com/users/3953764/piotr-s\">Piotr S.</a> pointed out <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1700\" rel=\"nofollow noreferrer\">issue 1700</a>, which was closed as \"not a defect\". It refers to the very similar case described in that question, and contains the following rationale:</p>\n<blockquote>\n<p id=\"so_29851098_29857495_3\">Because the types of the function parameters are the same, regardless of whether written directly or via an alias template, deduction must be handled the same way in both cases.</p>\n</blockquote>\n<p>I think it applies just as well to the cases discussed here, and settles the issue for now: all these forms should be treated as equivalent to a forwarding reference.</p>\n<p>(It will be interesting to see if this is changed indirectly by the resolutions for the other open issues, but they mostly deal with substitution failures rather than deduction by itself, so I guess such an indirect effect is rather unlikely.)</p>\n<hr>\n<p>All standard references are to the current working draft, N4431, the second draft after final C++14. </p>\n<p>Note that the quote from [14.5.7p3] is a recent addition, included right after the final C++14 version as the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1558\" rel=\"nofollow noreferrer\">DR1558</a>. I think we can expect further additions in this area as the other issues are resolved in one way or another.</p>\n<p>Until then, it may be worth asking this question in the <a href=\"https://groups.google.com/a/isocpp.org/forum/#!forum/std-discussion\" rel=\"nofollow noreferrer\">ISO C++ Standard - Discussion</a> group; that should bring it to the attention of the right people.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-04-27T07:58:15.140", "Score": "8", "CreationDate": "2015-04-24T21:07:15.263", "ParentId": "29851098", "CommentCount": "4", "OwnerUserId": "4326278", "LastEditDate": "2017-05-23T12:25:06.277"}});