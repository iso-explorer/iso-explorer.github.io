post_cb({"bq_ids": {"n4140": {"so_43304188_44145375_2": {"length": 30, "quality": 1.0, "section_id": 286}, "so_43304188_44145375_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 322}, "so_43304188_44145375_3": {"length": 11, "quality": 1.0, "section_id": 603}}, "n3337": {"so_43304188_44145375_2": {"length": 30, "quality": 1.0, "section_id": 277}, "so_43304188_44145375_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 312}, "so_43304188_44145375_3": {"length": 11, "quality": 1.0, "section_id": 593}}, "n4659": {"so_43304188_44145375_2": {"length": 30, "quality": 1.0, "section_id": 293}, "so_43304188_44145375_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 330}, "so_43304188_44145375_3": {"length": 11, "quality": 1.0, "section_id": 629}}}, "43304188": {"ViewCount": "162", "Body": "<p>I am trying to reproduce the result from video <a href=\"https://www.youtube.com/watch?v=1gNzhE-Tn40\" rel=\"nofollow noreferrer\">C++ Weekly - Ep 48 - C++17's Variadic <code>using</code></a>, but failed. The problem can be simplified to the following code piece.</p>\n<p>Suppose I have such generic structure:</p>\n<pre><code>template &lt;class... T&gt;\nstruct Container {\n    template &lt;class... U&gt;\n    Container(U... us) {}\n};\n</code></pre>\n<p>Now I can initialize a <code>Container</code> with any arguments, like</p>\n<pre><code>auto d = Container(1,2,3);\n</code></pre>\n<p>However, the compiler will never know what type the <code>d</code> is. To resolve this, we should provide a deduction guide, e.g.</p>\n<pre><code>template &lt;class... U&gt;\nContainer(U...) -&gt; Container&lt;double, int, bool&gt;\n</code></pre>\n<p>According to the video, the compiler now should know <code>d</code> has type <code>Container&lt;double, int, bool&gt;</code>. </p>\n<p>However, the code does not work as expected. When printing <code>typeid(d).name()</code>, the output will always be <code>9ContainerIJEE</code>, which is translated to <code>Container&lt;&gt;</code>, no matter how I change the return type in the deduction guide, indicating that such guide does not guide the compiler at all.</p>\n<p>I am using <code>gcc-7-snapshot-20170402</code>, the compiler in the video is <code>gcc-7-snapshot-20170130</code>.</p>\n<p>Could anyone tell me what is wrong here?</p>\n<h2>Update:</h2>\n<p>By the way, if I explicitly write</p>\n<pre><code>Container&lt;bool, int&gt; d = Container(1,2,3);\nContainer&lt;char, char, char&gt; d = Container(1,2,3);\n...\n</code></pre>\n<p>the code will always compile, and provide outputs like <code>9containerIJbiEE\n</code> and <code>9containerIJcccEE</code>.</p>\n", "Title": "Deduction guide for variadic template constructor fails", "CreationDate": "2017-04-09T07:34:33.560", "LastActivityDate": "2017-05-23T21:31:02.980", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-04-09T11:59:59.377", "LastEditorUserId": "797225", "Id": "43304188", "Score": "5", "OwnerUserId": "797225", "Tags": "<c++><gcc><c++1z>", "AnswerCount": "1"}, "44145375": {"Id": "44145375", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_43304188_44145375_0\">Now I can initialize a Container with any arguments, like</p>\n<pre><code>auto d = Container(1,2,3);\n</code></pre>\n<p id=\"so_43304188_44145375_1\">However, the compiler will never know what type the <code>d</code> is. </p>\n</blockquote>\n<p>That's not <em>entirely</em> accurate. The type of <code>d</code> is <code>Container&lt;&gt;</code> here. Let's move away from template deduction for constructors and go to just simple function templates:</p>\n<pre><code>template &lt;class... Ts, class... Us&gt;\nvoid foo(Us... );\n\nfoo(1, 2, 3);\n</code></pre>\n<p>That function call is perfectly ok - we deduce <code>Us</code> to be <code>{int,int,int}</code> and we deduce <code>Ts</code> to be <code>{}</code>. That is because of <a href=\"http://eel.is/c++draft/temp.arg.explicit#3\" rel=\"nofollow noreferrer\">[temp.arg.explicit]/3</a>:</p>\n<blockquote>\n<p id=\"so_43304188_44145375_2\">A trailing template parameter pack not otherwise deduced will be deduced to an empty sequence of template arguments. If all of the template arguments can be deduced, they may all be omitted; in this case, the empty template argument list <code>&lt;&gt;</code> itself may also be omitted.</p>\n</blockquote>\n<p>Now, what's a <strong>trailing</strong> template parameter pack? It's unspecified. But here <code>Ts...</code> can be deduced as empty, so it is. Note that this has some odd implications, like:</p>\n<pre><code>template &lt;class... Ts&gt; void g(std::tuple&lt;Ts...&gt; );\ng({}); // ok, calls g&lt;&gt;?\n</code></pre>\n<p>See also <a href=\"https://groups.google.com/a/isocpp.org/d/msg/std-discussion/PtJbyeG6W9g/OVKKykzQBgAJ\" rel=\"nofollow noreferrer\">this brief discussion</a>.</p>\n<hr/>\n<p>Getting back to the original question. The declaration</p>\n<pre><code>Container d(1, 2, 3);\n</code></pre>\n<p>without any deduction guides is well-formed, because we can succeed in doing template deduction and deduce <code>Ts...</code> as being empty. That is, it's exactly equivalent to:</p>\n<pre><code>Container&lt;&gt; d(1, 2, 3);\n</code></pre>\n<p>So what happens when we add a deduction guide? Now, we're effectively performing overload resolution between:</p>\n<pre><code>template &lt;class... Ts, class... Us&gt;\nContainer&lt;Ts...&gt; f(Us... );             // the constructor template\n\ntemplate &lt;class... Us&gt;\nContainer&lt;double, int, bool&gt; f(Us... ); // the deduction guide \n\nf(1, 2, 3);                             // what does this return?\n</code></pre>\n<p>The tiebreakers in determining the best viable candidate are in <a href=\"http://eel.is/c++draft/over.match.best\" rel=\"nofollow noreferrer\">[over.match.best]</a>, where the relevant two are:</p>\n<blockquote>\n<p id=\"so_43304188_44145375_3\">Given these definitions, a viable function <code>F1</code> is defined to be a <em>better</em> function than another viable function <code>F2</code> if [...]  </p>\n<ul>\n<li><code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized than the template for <code>F2</code> according to the partial ordering rules described in [temp.func.order], or, if not that,  </li>\n<li><code>F1</code> is generated from a deduction-guide ([over.match.class.deduct]) and <code>F2</code> is not, or, if not that, [...]</li>\n</ul>\n</blockquote>\n<p>Function template partial ordering <a href=\"https://stackoverflow.com/q/31497357/2069064\">is</a> <a href=\"https://stackoverflow.com/q/31391172/2069064\">really</a> <a href=\"https://stackoverflow.com/q/42416993/2069064\">quite</a> <a href=\"https://stackoverflow.com/q/31394260/2069064\">complicated</a> and the compilers don't quite agree on what to do in all cases. But in this case, I'd say this is a gcc bug (I submitted <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80871\" rel=\"nofollow noreferrer\">80871</a>). According to <a href=\"http://eel.is/c++draft/temp.deduct.partial\" rel=\"nofollow noreferrer\">[temp.deduct.partial]</a>:</p>\n<blockquote>\n<p id=\"so_43304188_44145375_4\">The types used to determine the ordering depend on the context in which the partial ordering is done:  </p>\n<ul>\n<li>In the context of a function call, the types used are those function parameter types for which the function call has arguments.</li>\n</ul>\n</blockquote>\n<p>That is, the <code>Ts...</code> in the first function template (the one synthesized from the constructor) aren't used for partial ordering. This makes both function templates identical, and so neither is more specialized than the other. We <em>should</em> then fall into the next bullet, which tells us to prefer the deduction guide over the constructor and end up with <code>Container&lt;double, int, bool&gt;</code>. gcc, however, believes for some reason that the first function template is more specialized and hence picks it before getting to the deduction-guide tiebreaker, which is why it ends up with <code>Container&lt;&gt;</code>. </p>\n", "LastActivityDate": "2017-05-23T21:31:02.980", "CommentCount": "0", "CreationDate": "2017-05-23T21:31:02.980", "ParentId": "43304188", "Score": "2", "OwnerUserId": "2069064"}});