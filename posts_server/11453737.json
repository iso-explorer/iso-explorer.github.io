post_cb({"11454817": {"ParentId": "11453737", "CommentCount": "0", "Body": "<p>If you turn your standard (C++98 anyway) to 14.6.4.2/1 you read:</p>\n<blockquote>\n<p id=\"so_11453737_11454817_0\">For a function call that depends on a template parameter, if the\n  function name is an unqualified-id but not a template-id, the\n  candidate functions are found using the usual lookup rules (3.4.1,\n  3.4.2) except that:</p>\n<p id=\"so_11453737_11454817_1\">\u2014 For the part of the lookup using unqualified name lookup (3.4.1),\n  only function declarations with external linkage  from the template\n  definition context are found.</p>\n</blockquote>\n<p>In this case <code>template-id</code> means a <code>&lt;template-params&gt;</code> qualified template-name. This pretty much clearly states exactly what you observed in your program, that only functions visible in the context of the template definition are considered. And when you think about it, if this weren't the case it would be ridiculously easy to change meanings of a template based on what <em>followed</em> it, leading to a violation of the one definition rule.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "11454817", "Score": "3", "CreationDate": "2012-07-12T15:06:07.917", "LastActivityDate": "2012-07-12T15:06:07.917"}, "bq_ids": {"n4140": {"so_11453737_11454817_1": {"section_id": 224, "quality": 0.75, "length": 12}}, "n3337": {"so_11453737_11454817_1": {"section_id": 217, "quality": 0.75, "length": 12}, "so_11453737_11454817_0": {"section_id": 217, "quality": 0.6190476190476191, "length": 13}}, "n4659": {"so_11453737_11454817_1": {"section_id": 232, "quality": 0.75, "length": 12}}}, "11453737": {"CommentCount": "2", "CreationDate": "2012-07-12T14:12:00.903", "PostTypeId": "1", "AcceptedAnswerId": "11454817", "LastEditorUserId": "99089", "LastActivityDate": "2012-07-12T15:06:07.917", "LastEditDate": "2012-07-12T14:27:44.633", "ViewCount": "114", "FavoriteCount": "1", "Title": "Adding specializations of template functions later", "Id": "11453737", "Score": "3", "Body": "<p>Suppose I have functions like:</p>\n<pre><code>template&lt;typename T&gt; inline\ntypename std::enable_if&lt;has_member_foo&lt;T&gt;::value,int&gt;::type\nfoo( T const &amp;t ) {\n  return t.foo();\n}\n\ntemplate&lt;typename T&gt; inline\ntypename std::enable_if&lt;!has_member_foo&lt;T&gt;::value,int&gt;::type\nfoo( T const&amp; ) {\n  return 0;\n}\n\ntemplate&lt;typename T&gt; inline\nint call_foo( T const &amp;t ) {\n  return sizeof( T ) + foo( t );\n}\n</code></pre>\n<p>This mostly works fine, but if I later add an overload for a particular type:</p>\n<pre><code>inline int foo( std::string const &amp;s ) {\n  return s.size();\n}\n</code></pre>\n<p>and I add it <em>after</em> the definition of <code>call_foo()</code>,\nthe overload isn't used by <code>call_foo()</code>.\nHowever, if I move the overload code before the definition of <code>call_foo()</code>, it is used.</p>\n<p>Why isn't the overload used in the first case?\nBy the time <code>call_foo()</code> is instantiated at a point of use elsewhere in the code,\nthe compiler <em>has already seen</em> the overload,\nso why doesn't it use it?</p>\n<p>Note that my original code had the <code>foo()</code> functions as static member functions of a templated <code>foo_traits</code> classes similarly guarded using <code>enable_if</code>. <em>That</em> code worked, i.e., template class specializations, even when provided <em>after</em> <code>call_foo()</code> was used, so why not for free-standing overloaded functions?</p>\n<p>If it matters, I'm using <code>g++</code> 4.6 on Mac OS X 10.7.4.</p>\n", "Tags": "<c++><templates><template-specialization>", "OwnerUserId": "99089", "AnswerCount": "1"}});