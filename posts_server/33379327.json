post_cb({"bq_ids": {"n4140": {"so_33379327_33379327_0": {"length": 48, "quality": 0.8727272727272727, "section_id": 464}, "so_33379327_33379327_1": {"length": 7, "quality": 1.0, "section_id": 464}, "so_33379327_33379327_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 464}, "so_33379327_33379327_3": {"length": 7, "quality": 1.0, "section_id": 464}, "so_33379327_34486446_0": {"length": 9, "quality": 1.0, "section_id": 464}}, "n3337": {"so_33379327_33379327_0": {"length": 48, "quality": 0.8727272727272727, "section_id": 455}, "so_33379327_33379327_1": {"length": 7, "quality": 1.0, "section_id": 455}, "so_33379327_33379327_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 455}, "so_33379327_33379327_3": {"length": 7, "quality": 1.0, "section_id": 455}, "so_33379327_34486446_0": {"length": 9, "quality": 1.0, "section_id": 455}}, "n4659": {"so_33379327_33379327_0": {"length": 47, "quality": 0.8545454545454545, "section_id": 487}, "so_33379327_33379327_1": {"length": 7, "quality": 1.0, "section_id": 487}, "so_33379327_33379327_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 487}, "so_33379327_33379327_3": {"length": 7, "quality": 1.0, "section_id": 487}, "so_33379327_34486446_0": {"length": 9, "quality": 1.0, "section_id": 487}}}, "33379327": {"ViewCount": "936", "Body": "<p>From [12.8] [11] of N3337:</p>\n<blockquote>\n<p id=\"so_33379327_33379327_0\">The implicitly-defined copy/move constructor for a non-union class X performs a memberwise copy/move of its bases and members. [ Note: brace-or-equal-initializers of non-static data members are ignored. See also the example in 12.6.2. \u2014end note ] The order of initialization is the same as the order of initialization of bases and members in a user-defined constructor (see 12.6.2). Let <code>x</code> be either the parameter of the constructor or, for the move constructor, an xvalue referring to the parameter. Each base or non-static data member is copied/moved in the manner appropriate to its type:</p>\n<p id=\"so_33379327_33379327_1\">\u2014 if the member is an array, each element is direct-initialized with the corresponding subobject of x;</p>\n<p id=\"so_33379327_33379327_2\">\u2014 if a member m has rvalue reference type T&amp;&amp;, it is direct-initialized with <code>static_cast&lt;T&amp;&amp;&gt;(x.m)</code>;</p>\n<p id=\"so_33379327_33379327_3\">\u2014 otherwise, the base or member is direct-initialized with the corresponding base or member of x.</p>\n</blockquote>\n<p>This is really more of a clarification, but I can't see any mention of lvalue reference members in that clause. Since it doesn't mention them, by default it seems to say that they are part of the implicit memberwise move, yet the following would not work;</p>\n<pre><code>int x = 5;\nint&amp; y = x;\nint&amp; z(std::move(y)); //error: invalid initialization of non-const reference of type 'int&amp;' from an rvalue of type 'std::remove_reference&lt;int&amp;&gt;::type {aka int}'\n</code></pre>\n<p>So is it safe to assume that the default move constructor distinguishes that a member is a reference and would simply just do</p>\n<pre><code>int&amp; z = y;\n</code></pre>\n<p>with no call to <code>std::move</code>?</p>\n", "AcceptedAnswerId": "34486446", "Title": "Default move constructor and reference members", "CreationDate": "2015-10-27T22:06:36.977", "Id": "33379327", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-12-28T00:29:54.633", "LastEditorUserId": "2756719", "LastActivityDate": "2015-12-28T00:47:56.017", "Score": "6", "OwnerUserId": "3348786", "Tags": "<c++><c++11><constructor><reference><move>", "AnswerCount": "1"}, "34486446": {"Id": "34486446", "PostTypeId": "2", "Body": "<p>It's handled by the specification of class member access expressions. The key part is </p>\n<blockquote>\n<p id=\"so_33379327_34486446_0\">Let <code>x</code> be either the parameter of the constructor or, for the move constructor, an xvalue referring to the parameter.</p>\n</blockquote>\n<p>In other words, a defaulted move constructor for </p>\n<pre><code>struct X { int x, &amp;y; };\n</code></pre>\n<p>does the equivalent of</p>\n<pre><code>X::X(X&amp;&amp; other) : x(std::move(other).x), y(std::move(other).y) {}\n</code></pre>\n<p>The important thing here is that the result of a class member access expression <code>x.m</code>, where <code>m</code> names a non-static data member, is always an lvalue if <code>m</code> has reference type, but an xvalue if <code>x</code> is an rvalue and <code>m</code> has non-reference type. (See [expr.ref]/4.) This ensures that lvalue reference members will be initialized with lvalues.</p>\n", "LastActivityDate": "2015-12-28T00:47:56.017", "CommentCount": "2", "CreationDate": "2015-12-28T00:47:56.017", "ParentId": "33379327", "Score": "6", "OwnerUserId": "2756719"}});