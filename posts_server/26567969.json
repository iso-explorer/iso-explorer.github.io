post_cb({"26571935": {"ParentId": "26567969", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From the standard:</p>\n<blockquote>\n<p id=\"so_26567969_26571935_0\">\u2014 If T is an aggregate, aggregate initialization is performed.</p>\n<p id=\"so_26567969_26571935_1\">[...]</p>\n<p id=\"so_26567969_26571935_2\">\u2014 Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7). If a narrowing conversion (see below) is required to convert any of the arguments, the program is ill-formed.</p>\n</blockquote>\n<p>In the context above, <code>x_{x}</code> will not call the copy constructor, because <code>X</code> is an aggregate. It will attempt aggregate initialization, which:</p>\n<ul>\n<li><p>In MSVC, is not implemented. MSVC also seems to fail compilation when <code>X</code> is <code>std::string</code>, which is not an aggregate, so it may have some C++11 compliance issues.</p></li>\n<li><p>In gcc, it is implemented, but the program is ill-formed and cannot compile (attempting to initialize an aggregate expecting <code>{int, int}</code> from a <code>{const X}</code>.</p></li>\n</ul>\n", "OwnerUserId": "598465", "LastEditorUserId": "598465", "LastEditDate": "2014-10-26T12:14:42.633", "Id": "26571935", "Score": "2", "CreationDate": "2014-10-26T10:18:18.520", "LastActivityDate": "2014-10-26T12:14:42.633"}, "bq_ids": {"n4140": {"so_26567969_26571935_2": {"section_id": 3325, "quality": 0.875, "length": 21}, "so_26567969_26571935_0": {"section_id": 3325, "quality": 1.0, "length": 4}}, "n3337": {"so_26567969_26571935_2": {"section_id": 3195, "quality": 0.875, "length": 21}, "so_26567969_26571935_0": {"section_id": 3195, "quality": 1.0, "length": 4}}, "n4659": {"so_26567969_26571935_2": {"section_id": 4091, "quality": 0.875, "length": 21}, "so_26567969_26571935_0": {"section_id": 4091, "quality": 1.0, "length": 4}}}, "26568353": {"ParentId": "26567969", "CommentCount": "2", "Body": "<p>As you noted, gcc <em>does</em> know what that syntax means, gives a specific error message:</p>\n<pre><code>cannot convert \u2018const X\u2019 to \u2018int\u2019 in initialization\n</code></pre>\n<p>That's because curly braces <code>{}</code> trigger list-initialization, and list-initialization for an aggregate type (your <code>struct X</code> is an aggregate, if you don't know why, just think \"like an array, it just holds stuff without any behavior of its own\") performs aggregate initialization.  Aggregate initialization means that initializers get paired with data members in order, and any extra data members get value initialized.</p>\n<p><code>x_.a</code> is paired with <code>x</code>\n<code>x_.b</code> is paired with nothing, so value initialized</p>\n<p>That's not what you want, because you can't stick all of <code>x</code> into <code>x_.a</code> (which is what gcc tells you).  What you did want is direct initialization using the copy constructor, written as <code>_x(x)</code>.</p>\n<p>The story in Visual C++ is a bit different.  Microsoft engineers are still working on adding in C++11 support, and this is one of the things they haven't finished yet (at least in your version).  The compiler knows that when it sees <code>{}</code> in a ctor initializer list, that means list-initialization, but it doesn't know how to do that, so it gives up.</p>\n<p>In particular, it doesn't get to the point of seeing that <code>X</code> is an aggregate, pairing initializers with data members, and finding out whether pairing <code>x_.a</code> with <code>x</code> is possible.</p>\n<p>When a compiler tells you \"this is not implemented\", it doesn't mean the code is good, it doesn't mean the code is bad.  It means compiling that code needed logic that isn't released yet (could be not yet written, could be not yet tested, no one outside Microsoft knows).  Your code got delivered to the factory, loaded on the conveyor belt, started moving down the assembly line, and... fell off the end of the belt, because the machine that deals with that kind of code isn't in the factory yet.  No one knows whether if the machine were there to pick it up, it would have dropped it in the error pile or gotten it on another conveyor.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "26568353", "Score": "1", "CreationDate": "2014-10-25T23:38:36.407", "LastActivityDate": "2014-10-25T23:38:36.407"}, "26567969": {"CommentCount": "7", "AcceptedAnswerId": "26571935", "PostTypeId": "1", "LastEditorUserId": "598465", "CreationDate": "2014-10-25T22:35:01.530", "LastActivityDate": "2014-10-26T12:14:42.633", "LastEditDate": "2014-10-26T09:40:47.520", "ViewCount": "1024", "FavoriteCount": "2", "Title": "Why do I get error C2797 in this example?", "Id": "26567969", "Score": "2", "Body": "<p>I have the following code:</p>\n<pre><code>struct X\n{\n    int a, b;\n};\n\nclass Y\n{\npublic:\n    Y(const X&amp; x) : x_{x} {};  // C2797 error\n\nprivate:\n    X x_;\n};\n</code></pre>\n<p>Compiled with MSVC2013 Update 3, it complains about a <a href=\"http://msdn.microsoft.com/en-us/library/dn793970.aspx\" rel=\"nofollow\">C2797 error</a>. If I replace the curly braces with parantheses (i.e. <code>x_(x)</code>) the program compiles successfully.</p>\n<p>Why does this happen? Is this compiler behaviour C++11-compliant? What about C++14? </p>\n<p><strong>Edit:</strong> To be more clear, I am not sure if <code>x_{x}</code> above should, according to the standard, call <code>X(std::initializer_list)</code> or if it's a valid syntax for calling <code>X(const X&amp;)</code>. As far as I know, it is the latter. Am I right?</p>\n", "Tags": "<c++><c++11><visual-studio-2013><initialization><uniform-initialization>", "OwnerUserId": "598465", "AnswerCount": "2"}});