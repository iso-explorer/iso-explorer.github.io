post_cb({"28127759": {"ParentId": "28127126", "LastEditDate": "2015-01-24T16:54:34.537", "CommentCount": "2", "CreationDate": "2015-01-24T16:43:23.583", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "PostTypeId": "2", "Id": "28127759", "Score": "6", "Body": "<p>\u00a714.6.4.1 [temp.point]/p1,8, emphasis mine:</p>\n<blockquote>\n<p id=\"so_28127126_28127759_0\">1 For a function template specialization, a member function template\n  specialization, or a specialization for a member function or static\n  data member of a class template, if the specialization is implicitly\n  instantiated because it is referenced from within another template\n  specialization and the context from which it is referenced depends on\n  a template parameter, the point of instantiation of the specialization\n  is the point of instantiation of the enclosing specialization.\n  Otherwise, <strong>the point of instantiation for such a specialization\n  immediately follows the namespace scope declaration or definition that\n  refers to the specialization.</strong></p>\n<p id=\"so_28127126_28127759_1\">8 A specialization for a function template, a member function template,\n  or of a member function or static data member of a class template may\n  have multiple points of instantiations within a translation unit, and\n  <strong>in addition to the points of instantiation described above, for any\n  such specialization that has a point of instantiation within the\n  translation unit, the end of the translation unit is also considered a\n  point of instantiation</strong>. A specialization for a class template has at\n  most one point of instantiation within a translation unit. A\n  specialization for any template may have points of instantiation in\n  multiple translation units. <strong>If two different points of instantiation\n  give a template specialization different meanings according to the one\n  definition rule (3.2), the program is ill-formed, no diagnostic\n  required.</strong></p>\n</blockquote>\n<p>There are two points of instantiation of <code>my_new&lt;A&gt;</code>, one at the end of the definition of <code>B</code>, and one at the end of the translation unit. Since those two points will result in different meanings (for snippets 3 and 5), the program is ill-formed NDR (i.e., it has undefined behavior).</p>\n", "LastActivityDate": "2015-01-24T16:54:34.537"}, "28127126": {"CommentCount": "3", "ViewCount": "363", "CreationDate": "2015-01-24T15:37:38.753", "LastActivityDate": "2015-01-24T16:54:34.537", "PostTypeId": "1", "AcceptedAnswerId": "28127759", "FavoriteCount": "1", "Title": "new of incomplete type compiles when wrapped in template", "Id": "28127126", "Score": "10", "Body": "<p>Consider this code, with an obvious compile error: (1)</p>\n<pre><code>struct A;\nstruct B {\n  B() { new A(); } // error: allocation of incomplete type 'A'\n};\n</code></pre>\n<p>Using a <code>unique_ptr</code> will not help either: (2)</p>\n<pre><code>struct A;\nstruct B {\n  B() { std::make_unique&lt;A&gt;(); } // error: due to ~unique_ptr()\n};\n</code></pre>\n<p>Then (to my great surprise) I found out, that this <strong>will</strong> compile: (3)</p>\n<pre><code>struct A;\nstruct B {\n  B() { std::make_unique&lt;A&gt;(); }\n};\nstruct A {}; // OK, when a definition is added **below**\n</code></pre>\n<p>Then I checked, whether this helps with <code>new</code> as well - <strong>nope</strong>: (4)</p>\n<pre><code>struct A;\nstruct B {\n  B() { new A(); } // error: allocation of incomplete type 'A'\n};\nstruct A {};\n</code></pre>\n<p>I figured it has something to do with <code>template</code>s and in fact: wrapping <code>new</code> inside a <code>template</code> <strong>does</strong> compile: (5)</p>\n<pre><code>template &lt;typename T&gt; \nT* my_new() { return new T(); } // OK, when wrapped in template\nstruct A;\nstruct B {\n  B() { my_new&lt;A&gt;(); }\n};\nstruct A {};\n</code></pre>\n<p>And just for the sake of completeness, removing the definition of <code>A</code> raises an error again: (6)</p>\n<pre><code>template &lt;typename T&gt; \nT* my_new() { return new T(); } // error: allocation of incomplete type 'A'\nstruct A;\nstruct B {\n  B() { my_new&lt;A&gt;(); }\n}; \n// do note: definition of A removed\n</code></pre>\n<p>What's going on here? As far as I <em>understood</em>, the compiler <strong>must</strong> know the size/definition of <code>A</code> to allocate it, thus merely declaring it, is not sufficient. In addition I believed, that the definition must <strong>precede</strong> the allocation.</p>\n<p>This seems to be correct, when using <code>new</code> <em>directly</em> (1,4). But when <code>new</code> is wrapped, it is apparent that I am mistaken (2,3,5,6).</p>\n<p>Possible explanations I found so far are:</p>\n<ul>\n<li>The check for completed types is delayed until the <code>template</code> instantiation occurs. I think this is correct, but in my case the <em>direct</em> use of <code>new A()</code> and the call to <code>my_new&lt;A&gt;()</code> occur virtually on the same position. So this cannot be the reason. Right?</li>\n<li>Using incomplete types as <code>template</code> Arguments might be <em>undefined behavior</em>. Is this really true? Even when enabling all warnings, the compiler will not complain. Also comparing 5 and 6 seems to suggest, that the compiler is smart enough to figure out, that the definition follows below (thus virtually making the type complete).</li>\n</ul>\n<p>Why 4 is considered to be incorrect, whilst 5 compiles (or is 5 just spuriously compiling undefined behavior [but then 3 must be flawed as well, right?])?</p>\n<p>btw: tested with clang++-3.5.0 and g++-4.9.2</p>\n", "Tags": "<c++><templates><forward-declaration>", "OwnerUserId": "4489791", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28127126_28127759_0": {"section_id": 216, "quality": 0.98, "length": 49}, "so_28127126_28127759_1": {"section_id": 223, "quality": 1.0, "length": 74}}, "n3337": {"so_28127126_28127759_0": {"section_id": 210, "quality": 0.98, "length": 49}, "so_28127126_28127759_1": {"section_id": 216, "quality": 1.0, "length": 74}}, "n4659": {"so_28127126_28127759_0": {"section_id": 224, "quality": 0.98, "length": 49}, "so_28127126_28127759_1": {"section_id": 231, "quality": 0.972972972972973, "length": 72}}}});