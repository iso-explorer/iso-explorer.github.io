post_cb({"3396082": {"ParentId": "3395180", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>By convention a \"NULL iterator\" for containers, which is used to indicate no result, compares equal to the result of <code>container.end()</code>. </p>\n<pre><code> std::vector&lt;X&gt;::iterator iter = std::find(my_vec.begin(), my_vec.end(), x);\n if (iter == my_vec.end()) {\n     //no result found; iter points to \"nothing\"\n }\n</code></pre>\n<p>However, since a default-constructed container iterator is not associated with any particular container, there is no good value it could take. Therefore it is just an uninitialized variable and the only legal operation to do with it is to assign a valid iterator to it.</p>\n<pre><code> std::vector&lt;X&gt;::iterator iter;  //no particular value\n iter = some_vector.begin();  //iter is now usable\n</code></pre>\n<hr>\n<p>For other kinds of iterators this might not be true. E.g in case of <code>istream_iterator</code>, a default-constructed iterator represents (compares equal to) an <code>istream_iterator</code> which has reached the EOF of an input stream.</p>\n</hr>", "OwnerUserId": "155693", "LastEditorUserId": "155693", "LastEditDate": "2010-08-03T12:04:06.217", "Id": "3396082", "Score": "39", "CreationDate": "2010-08-03T11:38:22.657", "LastActivityDate": "2010-08-03T12:04:06.217"}, "3395180": {"CommentCount": "2", "AcceptedAnswerId": "3396082", "PostTypeId": "1", "LastEditorUserId": "373025", "CreationDate": "2010-08-03T09:26:41.903", "LastActivityDate": "2017-04-26T02:31:39.320", "LastEditDate": "2010-08-03T09:27:52.790", "ViewCount": "37698", "FavoriteCount": "2", "Title": "What is an iterator's default value?", "Id": "3395180", "Score": "48", "Body": "<p>For any STL container that I'm using, if I declare an iterator (of this particular container type) using the iterator's default constructor, what will the iterator be initialised to? </p>\n<p>For example, I have: </p>\n<pre><code>std::list&lt;void*&gt; address_list;\nstd::list&lt;void*&gt;::iterator iter;\n</code></pre>\n<p>What will iter be initialised to? </p>\n", "Tags": "<c++><stl><default><containers><iterator>", "OwnerUserId": "325332", "AnswerCount": "3"}, "3395203": {"ParentId": "3395180", "CommentCount": "8", "Body": "<p>The iterator is not initialized, just as <code>int x;</code> declares an integer which isn't initialized. It does not have a properly defined value.</p>\n", "OwnerUserId": "13051", "PostTypeId": "2", "Id": "3395203", "Score": "10", "CreationDate": "2010-08-03T09:29:49.670", "LastActivityDate": "2010-08-03T09:29:49.670"}, "bq_ids": {"n4140": {"so_3395180_3395263_0": {"section_id": 5559, "quality": 0.8666666666666667, "length": 26}}, "n3337": {"so_3395180_3395263_0": {"section_id": 5341, "quality": 0.8666666666666667, "length": 26}}, "n4659": {"so_3395180_3395263_0": {"section_id": 7006, "quality": 0.8666666666666667, "length": 26}}}, "3395263": {"ParentId": "3395180", "CommentCount": "11", "Body": "<p>The default constructor initializes an iterator to a <em>singular value</em>:</p>\n<blockquote>\n<p id=\"so_3395180_3395263_0\">Iterators can also have singular values that are not associated with any sequence.\n  [ Example: After the declaration of an uninitialized pointer x (as with int* x;),\n  x must always be assumed to have a singular value of a pointer. \u2014end example ]\n  <strong>Results of most expressions are undefined for singular values</strong>\n  [24.2.1 \u00a75]</p>\n</blockquote>\n", "OwnerUserId": "252000", "PostTypeId": "2", "Id": "3395263", "Score": "19", "CreationDate": "2010-08-03T09:38:18.513", "LastActivityDate": "2010-08-03T09:38:18.513"}});