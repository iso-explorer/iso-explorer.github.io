post_cb({"32102585": {"ParentId": "32102486", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Where do you want to put local types other than the unnamed namespace? Types can't have a linkage specifier like <code>static</code>. If they are not publicly known, e.g., because they are declared in a header, there is a fair chance that names of local types conflict, e.g., when two translation units define types with the same name. In that case you'd end up with an ODR violation. Defining the types inside an unnamed namespace eliminates this possibility.</p>\n<p>To be a bit more concrete. Consider you have</p>\n<pre><code>// file demo.h\nint foo();\ndouble bar();\n\n// file foo.cpp\nstruct helper { int i; };\nint foo() { helper h{}; return h.i; }\n\n// file bar.cpp\nstruct helper { double d; }\ndouble bar() { helper h{}; return h.d; }\n\n// file main.cpp\n#include \"demo.h\"\nint main() {\n     return foo() + bar();\n}\n</code></pre>\n<p>If you link these three translation units, you have mismatching definitions of <code>helper</code> from <code>foo.cpp</code> and <code>bar.cpp</code>. The compiler/linker is not required to detect these but each type which is used in the program needs to have a consistent definition. Violating this constraints is known as violation of the \"one definition rule\" (ODR). Any violation of the ODR rule results in undefined behavior.</p>\n<p>Given the comment it seems a bit more convincing is needed. The relevant section of the standard is 3.2 [basic.def.odr] paragraph 6:</p>\n<blockquote>\n<p id=\"so_32102486_32102585_0\">There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with external linkage (7.1.2), class template (Clause 14), non-static function template (14.5.6), static data member\n  of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one translation unit, then each definition of D shall consist of the same sequence of tokens; and\n  [...]</p>\n</blockquote>\n<p>There are plenty of further constraints but \"shall consist of the same sequence of tokens\" is clearly sufficient to rule out e.g. the definitions in the demo above from being legal.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2015-08-19T18:35:49.940", "Id": "32102585", "Score": "12", "CreationDate": "2015-08-19T18:05:50.057", "LastActivityDate": "2015-08-19T18:35:49.940"}, "32102652": {"ParentId": "32102486", "PostTypeId": "2", "CommentCount": "9", "Body": "<blockquote>\n<p id=\"so_32102486_32102652_0\">So what's the use of putting types in unnamed namespaces?</p>\n</blockquote>\n<p>You can create short, meaningful classes with names that maybe used in more than one file without the problem of name conflicts.</p>\n<p>For example, I use two classes often in unnamed namespaces - <code>Initializer</code> and <code>Helper</code>.</p>\n<pre><code>namespace\n{\n   struct Initializer\n   {\n      Initializer()\n      {\n         // Take care of things that need to be initialized at static\n         // initialization time.\n      }\n   };\n\n   struct Helper\n   {\n      // Provide functions that are useful for the implementation\n      // but not exposed to the users of the main interface.\n   };\n\n   // Take care of things that need to be initialized at static\n   // initialization time.\n   Initializer initializer;\n}\n</code></pre>\n<p>I can repeat this pattern of code in as many files as I want without the names <code>Initializer</code> and <code>Helper</code> getting in the way.</p>\n<p><strong>Update, in response to comment by OP</strong></p>\n<p>file-1.cpp:</p>\n<pre><code>struct Initializer\n{\n   Initializer();\n};\n\nInitializer::Initializer()\n{\n}\n\nint main()\n{\n   Initializer init;\n}\n</code></pre>\n<p>file-2.cpp:</p>\n<pre><code>struct Initializer\n{\n   Initializer();\n};\n\nInitializer::Initializer()\n{\n}\n</code></pre>\n<p>Command to build:</p>\n<pre class=\"lang-none prettyprint-override\"><code>g++ file-1.cpp file-2.cpp\n</code></pre>\n<p>I get linker error message about multiple definitions of <code>Initializer::Initializer()</code>. Please note that the standard does not require the linker to produce this error. From section 3.2/4:</p>\n<blockquote>\n<p id=\"so_32102486_32102652_1\">Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required.</p>\n</blockquote>\n<p>The linker does not produce an error if the functions are defined inline:</p>\n<pre><code>struct Initializer\n{\n   Initializer() {}\n};\n</code></pre>\n<p>That's OK for a simple case like this since the implementations are identical. If the inline implementations are different, the program is subject to undefined behavior.</p>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2015-08-19T18:45:28.720", "Id": "32102652", "Score": "4", "CreationDate": "2015-08-19T18:09:26.953", "LastActivityDate": "2015-08-19T18:45:28.720"}, "46421666": {"ParentId": "32102486", "CommentCount": "0", "Body": "<p>I might be a bit late for answering the question the OP made but since I think the answer is not fully clear, I would like to help future readers.</p>\n<p>Lets try a test... compile the following files:</p>\n<pre><code>//main.cpp\n#include &lt;iostream&gt;\n#include \"test.hpp\"\n\nclass Test {\npublic:\n     void talk() {\n      std::cout&lt;&lt;\"I'm test MAIN\\n\";\n     }\n};\n\nint main()\n{\n     Test t;\n     t.talk();\n     testfunc();    \n}\n</code></pre>\n<hr>\n<pre><code>//test.hpp\nvoid testfunc();\n</code></pre>\n<hr>\n<pre><code>//test.cpp\n#include &lt;iostream&gt;\n\nclass Test {\npublic:\n     void talk()\n      {\n           std::cout&lt;&lt;\"I'm test 2\\n\";\n      }\n};\n\n\nvoid testfunc() {\n     Test t;\n     t.talk();\n}\n</code></pre>\n<p>Now run the executable.\nYou would expect to see:</p>\n<pre><code>I'm test MAIN\nI'm test 2\n</code></pre>\n<p>What you should see thought is:</p>\n<pre><code>I'm test MAIN\nI'm test MAIN\n</code></pre>\n<p><strong>What happened?!?!!</strong></p>\n<p>Now try putting an unnamed namespace around the \"Test\" class in \"test.cpp\" like so:</p>\n<pre><code>#include &lt;iostream&gt;\n#include \"test.hpp\"\n\nnamespace{\n     class Test {\n     public:\n      void talk()\n           {\n            std::cout&lt;&lt;\"I'm test 2\\n\";\n           }\n     };\n}\n\nvoid testfunc() {\n     Test t;\n     t.talk();\n}\n</code></pre>\n<p>Compile it again and run.\nThe output should be:</p>\n<pre><code>I'm test MAIN\nI'm test 2\n</code></pre>\n<p><strong>Wow! It works!</strong></p>\n<hr>\n<p>As it turns out, it <strong>is</strong> important to define classes inside unnamed namespaces so that you get the proper functionality out of them when two class names in different translation units are identical.\nNow as to <em>why</em> that is the case, I haven't done any research on it (maybe someone could help here?) and so I can't really tell you for sure. I'm answering purely from a practical standpoint.</p>\n<p>What I would suspect though is that, while it is <em>true</em> that C structs are indeed local to a translation unit, they are a bit different from classes since classes in c++ usually have behavior assigned to them. Behavior means functions and as we know, functions are <strong>not</strong> local to the translation unit.</p>\n<p><em>This is just my assumption.</em></p>\n</hr></hr></hr>", "OwnerUserId": "7162251", "PostTypeId": "2", "Id": "46421666", "Score": "0", "CreationDate": "2017-09-26T08:42:31.447", "LastActivityDate": "2017-09-26T08:42:31.447"}, "32102486": {"CommentCount": "2", "AcceptedAnswerId": "32102585", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-08-19T17:58:36.757", "LastActivityDate": "2017-09-26T08:42:31.447", "LastEditDate": "2017-05-23T12:30:53.810", "ViewCount": "562", "FavoriteCount": "3", "Title": "Why should types be put in unnamed namespaces?", "Id": "32102486", "Score": "8", "Body": "<p>I understand the use of unnamed namespaces to make functions and variables have internal linkage. Unnamed namespaces are not used in header files; only source files. Types declared in a source file cannot be used outside. So what's the use of putting types in unnamed namespaces?</p>\n<p>See these links where it's mentioned that types can be put in unnamed namespaces:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/4422507/superiority-of-unnamed-namespace-over-static\">Superiority of unnamed namespace over static?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions\">Unnamed/anonymous namespaces vs. static functions</a></li>\n<li><a href=\"https://stackoverflow.com/questions/4977252/why-unnamed-namespace-is-a-superior-alternative-to-static\">Why an unnamed namespace is a \"superior\" alternative to static?</a></li>\n</ul>\n", "Tags": "<c++><unnamed-namespace>", "OwnerUserId": "3357851", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_32102486_32102652_1": {"section_id": 7041, "quality": 1.0, "length": 12}, "so_32102486_32102585_0": {"section_id": 7043, "quality": 0.9154929577464789, "length": 65}}, "n3337": {"so_32102486_32102652_1": {"section_id": 6786, "quality": 1.0, "length": 12}, "so_32102486_32102585_0": {"section_id": 6788, "quality": 0.9154929577464789, "length": 65}}, "n4659": {"so_32102486_32102652_1": {"section_id": 8538, "quality": 1.0, "length": 12}, "so_32102486_32102585_0": {"section_id": 8540, "quality": 0.9154929577464789, "length": 65}}}});