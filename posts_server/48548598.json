post_cb({"bq_ids": {"n4140": {"so_48548598_48548598_1": {"length": 22, "quality": 0.9166666666666666, "section_id": 37}}, "n3337": {"so_48548598_48548598_1": {"length": 22, "quality": 0.9166666666666666, "section_id": 34}}, "n4659": {"so_48548598_48548598_1": {"length": 20, "quality": 0.8333333333333334, "section_id": 37}}}, "48548598": {"ViewCount": "219", "Body": "<p>I just read this from the C++14 standard (my emphasis):</p>\n<blockquote>\n<p id=\"so_48548598_48548598_0\"><strong>4.9 Floating-integral conversions [conv.fpint]</strong></p>\n<p id=\"so_48548598_48548598_1\"><strong>1</strong> A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates; that is, the fractional part is discarded. <em>The behavior is undefined if the truncated value cannot be\n  represented in the destination type.</em> <em>[...]</em></p>\n</blockquote>\n<p>Which got me thinking</p>\n<ol>\n<li>Which, if any, <code>float</code> values could not be represented as <code>int</code> after truncation? (Does that depend on the implementation?)</li>\n<li>If there are any, does this mean that <code>auto x = static_cast&lt;int&gt;(float)</code> is unsafe?</li>\n<li>what is the proper/safe way of converting <code>float</code> to <code>int</code> then (assuming you want truncation)?</li>\n</ol>\n", "AcceptedAnswerId": "48549360", "Title": "What float values could not be converted to int without undefined behavior [c++]?", "CreationDate": "2018-01-31T17:58:59.057", "LastActivityDate": "2018-01-31T19:07:16.560", "CommentCount": "10", "LastEditDate": "2018-01-31T19:07:16.560", "PostTypeId": "1", "LastEditorUserId": "563765", "Id": "48548598", "Score": "6", "OwnerUserId": "563765", "Tags": "<c++><type-conversion><c++14><implicit-conversion>", "AnswerCount": "2"}, "48549243": {"Id": "48549243", "PostTypeId": "2", "Body": "<p>We hit this a while back and I manually made some tables that have the exact bit patterns of floats at the edges of various conversions to various sizes of integers. Note this assumes iee754 4 byte <code>floats</code> and 8 bytes <code>doubles</code> and 2's complement signed integers (<code>int32_t</code> of 4 bytes and <code>int64_t</code> of 8 bytes).</p>\n<p>If you need to convert the bit patterns to floats or doubles you'll need to either type pun them (technically UB) or <code>memcpy</code> them.</p>\n<p>And to answer your question anything which is too big to fit in the target integer is UB on conversion, and the only time when the truncating to zero matters is <code>double</code> -&gt; <code>int32_t</code>. So using the following values you can compare the float against the relevant min/max and only cast if they're in range.</p>\n<p>Note that using <code>INT_MIN</code>/<code>INT_MAX</code> (or their modern limit counterparts) to cross convert and then compare doesn't always work as the accuracy of floats for those sized values are very low.</p>\n<p>Inf/NaN are also UB on conversion.</p>\n<pre><code>// float-&gt;int64 edgecases\nstatic const uint32_t FloatbitsMaxFitInt64 = 0x5effffff; // [9223371487098961920] Largest float which still fits int an signed int64\nstatic const uint32_t FloatbitsMinNofitInt64 = 0x5f000000; // [9223372036854775808] the bit pattern of the smallest float which is too big for a signed int64\nstatic const uint32_t FloatbitsMinFitInt64 = 0xdf000000; // [-9223372036854775808] Smallest float which still fits int an signed int64\nstatic const uint32_t FloatbitsMaxNotfitInt64 = 0xdf000001; // [-9223373136366403584] Largest float which to small for a signed int64\n\n// float-&gt;int32 edgecases\nstatic const uint32_t FloatbitsMaxFitInt32 = 0x4effffff; // [2147483520] the bit pattern of the largest float which still fits int an signed int32\nstatic const uint32_t FloatbitsMinNofitInt32 = 0x4f000000; // [2147483648] the bit pattern of the smallest float which is too big for a signed int32\nstatic const uint32_t FloatbitsMinFitInt32 = 0xcf000000; // [-2147483648] the bit pattern of the smallest float which still fits int an signed int32\nstatic const uint32_t FloatbitsMaxNotfitInt32 = 0xcf000001; // [-2147483904] the bit pattern of the largest float which to small for a signed int32\n\n// double-&gt;int64 edgecases\nstatic const uint64_t DoubleBitsMaxFitInt64 = 0x43dfffffffffffff; // [9223372036854774784] Largest double which fits into an int64\nstatic const uint64_t DoubleBitsMinNofitInt64 = 0x43e0000000000000; // [9223372036854775808] Smallest double which is too big for an int64\nstatic const uint64_t DoubleBitsMinFitInt64 = 0xc3e0000000000000; // [-9223372036854775808] Smallest double which fits into an int64\nstatic const uint64_t DoubleBitsMaxNotfitInt64 = 0xc3e0000000000001; // [-9223372036854777856] largest double which is too small to fit into an int64\n\n// double-&gt;int32 edgecases[when truncating(round towards zero)]\nstatic const uint64_t DoubleBitsMaxTruncFitInt32 = 0x41dfffffffffffff; // [~2147483647.9999998] Largest double that when truncated will fit into an int32\nstatic const uint64_t DoubleBitsMinTruncNofitInt32 = 0x41e0000000000000; // [2147483648.0000000] Smallest double that when truncated wont fit into an int32\nstatic const uint64_t DoubleBitsMinTruncFitInt32 = 0xc1e00000001fffff; // [~2147483648.9999995] Smallest double that when truncated will fit into an int32\nstatic const uint64_t DoubleBitsMaxTruncNofitInt32 = 0xc1e0000000200000; // [2147483649.0000000] Largest double that when truncated wont fit into an int32\n\n// double-&gt;int32 edgecases [when rounding via bankers method(round to nearest, round to even on half)]\nstatic const uint64_t DoubleBitsMaxRoundFitInt32 = 0x41dfffffffdfffff; // [2147483647.5000000] Largest double that when rounded will fit into an int32\nstatic const uint64_t DoubleBitsMinRoundNofitInt32 = 0x41dfffffffe00000; // [~2147483647.5000002] Smallest double that when rounded wont fit into an int32\nstatic const uint64_t DoubleBitsMinRoundFitInt32 = 0xc1e0000000100000; // [-2147483648.5000000] Smallest double that when rounded will fit into an int32\nstatic const uint64_t DoubleBitsMaxRoundNofitInt32 = 0xc1e0000000100001; // [~2147483648.5000005] Largest double that when rounded wont fit into an int32\n</code></pre>\n<p>So for your example you want:</p>\n<pre><code>if( f &gt;= B2F(FloatbitsMinFitInt32) &amp;&amp; f &lt;= B2F(FloatbitsMaxFitInt32))\n    // cast is valid.\n</code></pre>\n<p>Where B2F is something like:</p>\n<pre><code>float B2F(uint32_t bits)\n{\n    static_assert(sizeof(float) == sizeof(uint32_t), \"Weird arch\");\n    float f;\n    memcpy(&amp;f, &amp;bits, sizeof(float));\n    return f;\n}\n</code></pre>\n<p>Note that this conversion picks up nans/inf correctly (as comparisons with them are false) <em>unless</em> you're using a non-iee754 mode of your compiler (e.g. ffast-math on gcc or /fp:fast on msvc)</p>\n", "LastEditorUserId": "2331956", "LastActivityDate": "2018-01-31T19:04:26.983", "Score": "7", "CreationDate": "2018-01-31T18:37:01.700", "ParentId": "48548598", "CommentCount": "7", "OwnerUserId": "2331956", "LastEditDate": "2018-01-31T19:04:26.983"}, "48549360": {"Id": "48549360", "PostTypeId": "2", "Body": "<p>It shouldn't be surprising at all that <code>float</code> has values outside of <code>int</code> range. Floating-point values were invented to represent very large (and also very small) values adequately.</p>\n<ol>\n<li><code>INT_MAX + 1</code> (usually equal to <code>2147483648</code>) cannot be represented by <code>int</code>, but can be represented by <code>float</code>.</li>\n<li>Yes, <code>static_cast&lt;int&gt;(float)</code> is as unsafe as undefined behavior can be. However, something as simple as <code>x + y</code> for sufficiently large integers <code>x</code> and <code>y</code> is also UB, so no big surprise here either.</li>\n<li><p>The proper way to do stuff depends on the application, as always in C++. Boost has <code>numeric_cast</code> that throws an exception on overflow; this might be good for you. To do saturation (convert too big values to <code>INT_MIN</code> and <code>INT_MAX</code>), write some code like this</p>\n<pre><code>float f;\nint i;\n...\nif (static_cast&lt;double&gt;(INT_MIN) &lt;= f &amp;&amp; f &lt; static_cast&lt;double&gt;(INT_MAX))\n    i = static_cast&lt;int&gt;(f);\nelse if (f &lt; 0)\n    i = INT_MIN;\nelse\n    i = INT_MAX;\n</code></pre>\n<p>However, this is not ideal. Does your system have <code>double</code> type that can represent the maximal value of <code>int</code>? If yes, it will work. Also, how exactly do you want to round values that are close to minimum or maximum of <code>int</code>? If you don't want to consider such questions, use <code>boost::numeric_cast</code>, as described <a href=\"https://stackoverflow.com/a/4424208/509868\">here</a>.</p></li>\n</ol>\n", "LastActivityDate": "2018-01-31T18:45:31.920", "Score": "2", "CreationDate": "2018-01-31T18:45:31.920", "ParentId": "48548598", "CommentCount": "1", "OwnerUserId": "509868"}});