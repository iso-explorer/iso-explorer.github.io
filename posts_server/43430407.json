post_cb({"bq_ids": {"n4140": {"so_43430407_43430605_1": {"length": 10, "quality": 1.0, "section_id": 986}}, "n3337": {"so_43430407_43430605_1": {"length": 10, "quality": 1.0, "section_id": 971}}, "n4659": {"so_43430407_43430605_1": {"length": 10, "quality": 1.0, "section_id": 1049}}}, "43432115": {"Id": "43432115", "PostTypeId": "2", "Body": "<p>Ok so following a lot of looking around, it seems like the standard library is under obligation to make this work. The idea being that since the standard does not explicitly say this shouldn't work, so it must work.</p>\n<p><a href=\"http://www.drdobbs.com/cpp/copying-container-elements-from-the-c-li/240155771\" rel=\"nofollow noreferrer\">Andrew Koenig</a> wrote a bit about it here and proposes a solution where new memory is allocated, the elements moved over, and only then will the old memory be deallocated.</p>\n<p>There are also other discussion <a href=\"https://www.reddit.com/r/cpp/comments/vog1p/a_commonly_unknown_stdvector_pitfall/\" rel=\"nofollow noreferrer\">here</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526\" rel=\"nofollow noreferrer\">here (#526)</a>.</p>\n<p>As for the second case, it seems like the standard library (clang on MacOS) also accounts for the situation where you try to insert a reference to an element in the vector that is positioned after the point where you are trying to insert. To test this I wrote a wrapper class for ints called Integer that behaves exactly like an int except the destructor sets it's internal value to -5. So we should see a -5 inserted instead of the actual value if the std::vector insert doesn't account for the situation.</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\n\nusing std::cout;    using std::endl;\nusing std::ostream; using std::vector;\n\n\nclass Integer {\n\npublic:\n    Integer() {\n        x = -1;     // default value\n    }\n\n    ~Integer() {\n        x = -5;     // destructed value. Not 0 so we can clearly see it\n    }\n\n    Integer(int r) {\n        x = r;\n    }\n\n    Integer(const Integer&amp; other) {\n        x = other.x;\n    }\n\n    Integer operator=(const Integer&amp; other) {\n        x = other.x;\n        return *this;\n    }\n\n    operator int() const{\n        return x;\n    }\n\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Integer&amp; thing) {\n        os &lt;&lt; thing.x;\n        return os;\n    }\n\nprivate:\n    int x;\n};\n\n\nostream&amp; operator&lt;&lt;(ostream&amp; os, const vector&lt;Integer&gt; &amp;v) {\n    std::copy(v.begin(), v.end(), std::ostream_iterator&lt;Integer&gt;(os, \", \"));\n    return os;\n}\n\nint main() {\n    std::vector&lt;Integer&gt; ret {18, 7, 4, 24,11};\n    cout &lt;&lt; \"Before: \" &lt;&lt; ret &lt;&lt; endl;\n    ret.insert(ret.begin(), ret[1]);\n    cout &lt;&lt; \"After: \" &lt;&lt;  ret &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>This gives us the correct output:</p>\n<pre><code>Before: 18, 7, 4, 24, 11, \nAfter: 7, 18, 7, 4, 24, 11, \n</code></pre>\n", "LastEditorUserId": "5718020", "LastActivityDate": "2017-04-16T01:51:14.020", "Score": "3", "CreationDate": "2017-04-15T23:06:03.257", "ParentId": "43430407", "CommentCount": "2", "OwnerUserId": "5718020", "LastEditDate": "2017-04-16T01:51:14.020"}, "43430407": {"ViewCount": "381", "Body": "<p>I was wondering if someone more experienced might be able to clarify if this is a buggy operation to do on a vector:</p>\n<pre><code>std::vector&lt;int&gt; v{1, 2, 3, 4, 5};\nv.insert(v.begin() + 1, v[0]);\n</code></pre>\n<p>The reason I ask is because the element to insert is a reference to the 0th element in the vector. If the insertion forces the vector to resize (because its capacity is full), then the reference to <code>v[0]</code> would be invalidated, and the code might insert an incorrect value. Here is some pseudo-code  that might demonstrate:</p>\n<pre><code>template &lt;typename T&gt;\nvoid vector_insert_method(Iterator pos, const T&amp; value) {\n    if capacity full:\n        reallocate array and copy over element\n        // if value was reference to elem in this vector,\n        // that reference might be invalidated\n\n\n    insert element\n\n    ++size\n}\n</code></pre>\n<p>This issue might be more realistic on a concurrent system.</p>\n<p>A similar, and related question is what happens if you try inserting an element that comes after the position you are trying to insert. For example, doing something like <code>v.insert(v.begin(), v[2])</code> because the standard points out that references to elements after the insertion point are invalidated. Is this guaranteed to work?</p>\n", "AcceptedAnswerId": "43430605", "Title": "Inserting into vector by reference to element of same vector", "CreationDate": "2017-04-15T19:33:20.453", "Id": "43430407", "CommentCount": "10", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-04-16T01:32:22.413", "LastEditorUserId": "5718020", "LastActivityDate": "2017-04-18T07:37:31.257", "Score": "13", "OwnerUserId": "5718020", "Tags": "<c++><vector><reference>", "AnswerCount": "2"}, "43430605": {"Id": "43430605", "PostTypeId": "2", "Body": "<p>The original question asked ...</p>\n<blockquote>\n<p id=\"so_43430407_43430605_0\">[..] whether this is a buggy operation to do on a vector:</p>\n<pre><code>v.insert(v.begin(), v[0]);\n//              ^^^ no + 1 here!\n</code></pre>\n</blockquote>\n<p><strong>Probably yes</strong>, it could be undefined behavior. Quoting <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">N3337</a> (\"almost C++11\" AFAIK):</p>\n<blockquote>\n<p id=\"so_43430407_43430605_1\">[..] If no reallocation happens, all the iterators and references before the insertion point remain valid. [..]</p>\n<p id=\"so_43430407_43430605_2\">\u00a723.3.6.5/1</p>\n</blockquote>\n<p>While this is not the clear wording one is used to when reading the standard, I'd interpret this as: iterators and references to and after the insertion point are invalidated.</p>\n<p>Thus, the reference to <code>v[0]</code> is invalidated by the call(*) to <code>insert</code>. Even if no reallocation happens, <code>insert</code> <em>has to shift all elements</em> to higher indices (so <code>v[0]</code> is re-positioned to <code>v[1]</code>).</p>\n<p><strong>Assuming the element type is <em>not</em> trivially destructible</strong>, then no matter how that re-positioning is done (either via moving or copying), after <code>v[1]</code> has been assigned / constructed from <code>v[0]</code>, the destructor of <code>v[0]</code> needs to be called (and its lifetime ended) <em>before</em> a new object (the one you want to insert) can be placed in the memory location of <code>v[0]</code>. Thus, here your reference turns into a dangling reference, which leads to undefined behavior when it's used directly afterwards to construct the new <code>v[0]</code>. No, as far as I can see, this issue could be circumvented by having <code>std::vector::insert()</code> not <em>construct</em> the new object but rather <em>assign</em> the new object to the \"old\" one. I'm not sure whether there's a requirement for <code>std::vector</code> to behave that way, though its element type having to be <code>CopyInsertable</code> gives a hint that this might be the case.</p>\n<p><strong>UPDATE:</strong> <a href=\"http://ideone.com/YVwJHF\" rel=\"nofollow noreferrer\">I've played around with the code</a> provided in the other answer, adding some print debugging. This showed <em>not</em> what I was expecting (destructing one element and then accessing it) <strong>but</strong> still shows that the standard library implementation (used here by ideone) does <strong>not</strong> conform to the standard: It invalidates references to elements before the point of insertion <em>even if</em> the capacity is large enough. That way it circumvents above issues (but breaks the standard ... so).</p>\n<p>(*): One could argue about <em>when</em> that invalidation happens. The best answer to that question is IMO that the reference is valid right before calling the <code>insert</code> function, and is invalid (for sure) after returning from that function. The exact point of invalidation is unspecified.</p>\n<hr>\n<p>The edited question asked the same question but with a extremely important modification:</p>\n<blockquote id=\"so_43430407_43430605_3\">\n<pre><code>v.insert(v.begin() + 1, v[0]);\n//                ^^^^^\n</code></pre>\n</blockquote>\n<p>Now this is a completely different situation. The reference to <code>v[0]</code> will not necessarily be invalidated by the call to <code>insert</code> because the point of insertion is \"behind\" <code>v[0]</code>. The only issue that may arise is if the <code>std::vector</code> has to reallocate its internal buffer, but in that case the following sequence of operations should guarantee correct behavior:</p>\n<ol>\n<li>Allocate new memory of larger capacity</li>\n<li>Construct new element at it's correct index in the newly allocated memory region.</li>\n<li>Copy/Move elements from old (too small) memory to the newly allocated memory region.</li>\n<li>Free old memory.</li>\n</ol>\n</hr>", "LastEditorUserId": "1116364", "LastActivityDate": "2017-04-18T07:37:31.257", "Score": "6", "CreationDate": "2017-04-15T19:51:29.527", "ParentId": "43430407", "CommentCount": "13", "OwnerUserId": "1116364", "LastEditDate": "2017-04-18T07:37:31.257"}});