post_cb({"bq_ids": {"n4140": {"so_27754396_27754474_1": {"length": 6, "quality": 0.6, "section_id": 6686}, "so_27754396_27754474_2": {"length": 5, "quality": 1.0, "section_id": 133}, "so_27754396_27754474_0": {"length": 9, "quality": 1.0, "section_id": 6686}}, "n3337": {"so_27754396_27754474_1": {"length": 6, "quality": 0.6, "section_id": 6441}, "so_27754396_27754474_2": {"length": 5, "quality": 1.0, "section_id": 127}, "so_27754396_27754474_0": {"length": 9, "quality": 1.0, "section_id": 6441}}, "n4659": {"so_27754396_27754474_1": {"length": 6, "quality": 0.6, "section_id": 8161}, "so_27754396_27754474_2": {"length": 5, "quality": 1.0, "section_id": 137}, "so_27754396_27754474_0": {"length": 9, "quality": 1.0, "section_id": 8161}}}, "27754474": {"Id": "27754474", "PostTypeId": "2", "Body": "<p>If you want any specialization of <code>Vec</code> to be a friend of the current <code>Vec&lt;T&gt;</code> instantiation, the friend declaration should be:</p>\n<pre><code>template &lt;typename X&gt; friend struct Vec;\n//                                     ^ ok, plain identifier\n</code></pre>\n<p>instead of:</p>\n<pre><code>template &lt;typename X&gt; friend class Vec&lt;X&gt;;\n//                                    ^~~ wrong!\n</code></pre>\n<p>\u00a711.3 [class.friend]/p3:</p>\n<blockquote>\n<p id=\"so_27754396_27754474_0\">A friend declaration that does not declare a function shall have one of the following forms:</p>\n<pre><code>friend elaborated-type-specifier ;\nfriend simple-type-specifier ;\nfriend typename-specifier ;\n</code></pre>\n<p id=\"so_27754396_27754474_1\">[ <em>Note:</em> A friend declaration may be the <em>declaration</em> in a <em>template-declaration</em> (Clause 14, 14.5.4).\u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>The syntax you're currently using matches a declaration of a partial specialization of <code>Vec</code>, which is forbidden by \u00a714.5.4 [temp.friend]/p8:</p>\n<blockquote>\n<p id=\"so_27754396_27754474_2\">Friend declarations shall not declare partial specializations.</p>\n</blockquote>\n", "LastEditorUserId": "3953764", "LastActivityDate": "2015-06-27T21:21:15.983", "Score": "3", "CreationDate": "2015-01-03T11:46:07.443", "ParentId": "27754396", "CommentCount": "1", "OwnerUserId": "3953764", "LastEditDate": "2015-06-27T21:21:15.983"}, "27754464": {"Id": "27754464", "PostTypeId": "2", "Body": "<p>You just have the wrong <code>friend</code> syntax there:</p>\n<pre><code>template &lt;typename U&gt; friend struct Vec;\n</code></pre>\n", "LastActivityDate": "2015-01-03T11:45:31.060", "CommentCount": "0", "CreationDate": "2015-01-03T11:45:31.060", "ParentId": "27754396", "Score": "2", "OwnerUserId": "542190"}, "27754396": {"ViewCount": "385", "Body": "<p>Below is a simplified version of code I have.</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\ntemplate &lt;typename T&gt; struct Foo {\n  using Value = T;\n  constexpr Foo() = delete;\n  constexpr Foo(T v) : value(v) {}\n  T value;\n};\n\ntemplate &lt;typename T&gt; struct Vec {\n  using Elem = Foo&lt;T&gt;;\n  using Container = std::vector&lt;Elem&gt;;\n\n  Vec() = delete;\n  template &lt;typename... Elems&gt;\n  Vec(Elem a, Elem b, Elems... rest)\n      : elems_{a, b, rest...} {}\n\n  void add(const Elem &amp;e) { elems_.push_back(e); }\n\n  template &lt;typename F&gt; auto map(const F &amp;f) const;\n\nprivate:\n  Vec(Container &amp;&amp;c) : elems_(std::move(c)) {}\n  Container elems_;\n};\n\ntemplate &lt;typename C&gt;\ntemplate &lt;typename F&gt;\nauto Vec&lt;C&gt;::map(const F &amp;f) const {\n  using ReturnedFoo = decltype(f(std::declval&lt;typename Vec&lt;C&gt;::Elem&gt;()));\n  using ValueType = typename ReturnedFoo::Value;\n  using Container = typename Vec&lt;ValueType&gt;::Container;\n  Container mapped_elems;\n  mapped_elems.reserve(elems_.size());\n  std::transform(elems_.begin(), elems_.end(), std::back_inserter(mapped_elems),\n                 f);\n  return Vec&lt;ValueType&gt;{std::move(mapped_elems)};\n}\n\nFoo&lt;int&gt; mul2(Foo&lt;int&gt; x) {\n    return Foo&lt;int&gt;{2 * x.value};\n}\nFoo&lt;double&gt; to_d(Foo&lt;int&gt; x) {\n  return Foo&lt;double&gt;{static_cast&lt;double&gt;(x.value)};\n}\n\nint main() {\n  constexpr auto f1 = Foo&lt;int&gt;(1);\n  constexpr auto f2 = Foo&lt;int&gt;(2);\n  constexpr auto f3 = Foo&lt;int&gt;(3);\n  const auto v1 = Vec&lt;int&gt;{f1, f2, f3};\n  const auto v2 = v1.map(mul2);\n  // const auto v3 = v1.map(to_d); // call to private constructor from here\n}\n</code></pre>\n<p>My class <code>Vec&lt;T&gt;</code> internally holds elements of type <code>Foo&lt;T&gt;</code> in <code>std::vector</code> and it always holds at least 2 elements.</p>\n<p>I wrote  a <code>map</code> function that maps/tranforms every element and returns a new <code>Vec</code> object. Everything works fine for mapping functions which do not change a type of element (<code>F : (T) -&gt; T</code>), like <code>mul2</code>. But general case (<code>F : (T) -&gt; U</code>) doesn't work because there's a call to private constructor in class <code>Vec&lt;U&gt;</code> from <code>Vec&lt;T&gt;::map</code> function. Making this constructor public would make it possible to create <code>Vec</code> object with fewer than 2 elements so that's not what I want.</p>\n<p>My first attempt of solving this problem was</p>\n<pre><code>  template &lt;typename X&gt; friend class Vec&lt;X&gt;;\n</code></pre>\n<p>but it seems it's not allowed. Here's clang++'s output:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>vec.cpp:23:14: error: partial specialization cannot be declared as a friend\n      friend class Vec&lt;X&gt;;\n</code></pre>\n<p>Is there a way of making it work?\nDuring writing this question I came up with an idea of rewriting the last line of map as:</p>\n<pre><code>  Vec&lt;ValueType&gt; result{mapped_elems[0], mapped_elems[1]};\n  for (auto it = mapped_elems.begin() + 2 ; it != mapped_elems.end(); ++it) {\n      result.add(*it);\n  }\n  return result;\n</code></pre>\n<p>But is there another way?</p>\n<p>(Btw. I have clang 3.5.0 and g++ 4.9.2)</p>\n", "AcceptedAnswerId": "27754474", "Title": "Calling private constructor of Class<T> from Class<U>", "CreationDate": "2015-01-03T11:36:41.577", "Id": "27754396", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-06-27T21:21:15.983", "Score": "1", "OwnerUserId": "3046011", "Tags": "<c++><templates><g++><c++14><clang++>", "AnswerCount": "2"}});