post_cb({"bq_ids": {"n4140": {"so_31047860_31048865_6": {"length": 31, "quality": 0.96875, "section_id": 603}, "so_31047860_31048865_5": {"length": 18, "quality": 0.9, "section_id": 603}, "so_31047860_31048865_1": {"length": 19, "quality": 0.95, "section_id": 639}, "so_31047860_31048865_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 603}, "so_31047860_31048865_4": {"length": 21, "quality": 0.9545454545454546, "section_id": 639}, "so_31047860_31048865_3": {"length": 16, "quality": 1.0, "section_id": 639}, "so_31047860_31048865_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 639}}, "n3337": {"so_31047860_31048865_6": {"length": 22, "quality": 0.6875, "section_id": 593}, "so_31047860_31048865_5": {"length": 18, "quality": 0.9, "section_id": 593}, "so_31047860_31048865_4": {"length": 21, "quality": 0.9545454545454546, "section_id": 629}, "so_31047860_31048865_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 593}, "so_31047860_31048865_3": {"length": 16, "quality": 1.0, "section_id": 629}, "so_31047860_31048865_1": {"length": 19, "quality": 0.95, "section_id": 629}, "so_31047860_31048865_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 629}}, "n4659": {"so_31047860_31048865_6": {"length": 31, "quality": 0.96875, "section_id": 629}, "so_31047860_31048865_5": {"length": 18, "quality": 0.9, "section_id": 629}, "so_31047860_31048865_4": {"length": 21, "quality": 0.9545454545454546, "section_id": 667}, "so_31047860_31048865_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 629}, "so_31047860_31048865_3": {"length": 16, "quality": 1.0, "section_id": 667}, "so_31047860_31048865_1": {"length": 19, "quality": 0.95, "section_id": 667}, "so_31047860_31048865_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 667}}}, "31048065": {"Id": "31048065", "PostTypeId": "2", "Body": "<p>You declare in the second function that you second argument to be <code>const</code>. The below example of your with applied correction calls the second one:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class U, class T&gt;\nvoid foo(U&amp;, T&amp;)\n{\n    std::cout &lt;&lt; \"first\";\n}\n\ntemplate &lt;class T&gt;\nvoid foo(int&amp;, T&amp;)\n{\n    std::cout &lt;&lt; \"second\";\n}\n\nint main()\n{\n    int a;\n    double g = 2.;\n    foo(a, g);\n\n    return 0;\n}\n</code></pre>\n<p>On the other hand, when you explicitly declare second argument do be <code>const</code> in <code>main()</code>, the application calls second function in your above example as expected:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class U, class T&gt;\nvoid foo(U&amp;, T&amp;)\n{\n    std::cout &lt;&lt; \"first\";\n}\n\ntemplate &lt;class T&gt;\nvoid foo(int&amp;, const T&amp;)\n{\n    std::cout &lt;&lt; \"second\";\n}\n\nint main()\n{\n    int a;\n    const double g = 2.;\n    foo(a, g);\n\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2015-06-25T10:41:46.550", "CommentCount": "0", "CreationDate": "2015-06-25T10:41:46.550", "ParentId": "31047860", "Score": "7", "OwnerUserId": "1390260"}, "31047860": {"ViewCount": "1249", "Body": "<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class U, class T&gt;\nvoid foo(U&amp;, T&amp;)\n{\n    std::cout &lt;&lt; \"first\";\n}\n\ntemplate &lt;class T&gt;\nvoid foo(int&amp;, const T&amp;)\n{\n    std::cout &lt;&lt; \"second\";\n}\n\nint main()\n{\n    int a;\n    double g = 2.;\n    foo(a, g); // prints \"first\"\n\n    return 0;\n}\n</code></pre>\n<p>To call the second <code>foo</code> overload, the compiler needs to perform only one template type deduction, but for the first overload, it needs to perform two. Can you please explain why the first overload is called?</p>\n", "AcceptedAnswerId": "31048865", "Title": "C++ template functions priority", "CreationDate": "2015-06-25T10:33:03.113", "Id": "31047860", "CommentCount": "1", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2015-06-25T18:25:57.443", "LastEditorUserId": "2069064", "LastActivityDate": "2015-06-25T18:25:57.443", "Score": "19", "OwnerUserId": "1356110", "Tags": "<c++><function><templates><overload-resolution>", "AnswerCount": "3"}, "31048038": {"Id": "31048038", "PostTypeId": "2", "Body": "<p>Observe:</p>\n<ul>\n<li>The first overload takes a non-const lvalue as second argument</li>\n<li>The second overload take a const lvalue as second argument</li>\n</ul>\n<p>Because you're passing <code>g</code> as a non-const lvalue, the compiler chooses the first overload.</p>\n", "LastActivityDate": "2015-06-25T10:40:37.137", "CommentCount": "0", "CreationDate": "2015-06-25T10:40:37.137", "ParentId": "31047860", "Score": "3", "OwnerUserId": "1170277"}, "31048865": {"Id": "31048865", "PostTypeId": "2", "Body": "<p>Overload resolution is done in multiple steps. </p>\n<p>First, through name lookup, we select the list of viable candidates. In this case, that is:</p>\n<pre><code>template &lt;class U, class T&gt;\nvoid foo(U&amp;, T&amp;);            // with U = int, T = double\n\ntemplate &lt;class T&gt;\nvoid foo(int&amp;, const T&amp;)     // with T = double\n</code></pre>\n<p>Next, we determine the conversion sequence necessary for each argument for each viable candidate. This is [over.ics.rank]:</p>\n<blockquote>\n<p id=\"so_31047860_31048865_0\">Standard conversion sequence <code>S1</code> is a better conversion sequence than standard conversion sequence\n  <code>S2</code> if [...]</p>\n<ul>\n<li>S1 is a proper subsequence of S2 (comparing the conversion sequences in the canonical form\n  defined by 13.3.3.1.1, excluding any Lvalue Transformation; the identity conversion sequence is\n  considered to be a subsequence of any non-identity conversion sequence) or, if not that,</li>\n<li>the rank of S1 is better than the rank of S2, or S1 and S2 have the same rank and are distinguishable\n  by the rules in the paragraph below, or, if not that,</li>\n</ul>\n</blockquote>\n<p>For the first call, the conversion sequence is (Identity, Identity). For the second call, the conversion sequence is (Identity, Identity). So we're equal there. Neither of those bullet points distinguish the two calls. So we move on.</p>\n<blockquote id=\"so_31047860_31048865_1\">\n<ul>\n<li>S1 and S2 are reference bindings (8.5.3) and neither refers to an implicit object parameter of a\n  non-static member function declared without a ref-qualifier, and S1 binds an rvalue reference to\n  an rvalue and S2 binds an lvalue reference.</li>\n</ul>\n</blockquote>\n<p>Irrelevant.</p>\n<blockquote id=\"so_31047860_31048865_2\">\n<ul>\n<li>S1 and S2 are reference bindings (8.5.3) and S1 binds an lvalue reference to a function lvalue and\n  S2 binds an rvalue reference to a function lvalue.</li>\n</ul>\n</blockquote>\n<p>Nope.</p>\n<blockquote id=\"so_31047860_31048865_3\">\n<ul>\n<li>S1 and S2 differ only in their qualification conversion and yield similar types T1 and T2 (4.4),\n  respectively, and the cv-qualification signature of type T1 is a proper subset of the cv-qualification\n  signature of type T2.</li>\n</ul>\n</blockquote>\n<p>Qualification conversion is a pointer thing, nope.</p>\n<blockquote id=\"so_31047860_31048865_4\">\n<ul>\n<li>S1 and S2 are reference bindings (8.5.3), and the types to which the references refer are the same\n  type except for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers\n  is more cv-qualified than the type to which the reference initialized by S1 refers.</li>\n</ul>\n</blockquote>\n<p>In this case, the first overload takes its second argument as <code>double&amp;</code> while the second overload takes a <code>const double&amp;</code>. The former is less <em>cv</em>-qualified than the latter, so we stop here - preferring <code>foo(U&amp;,T&amp;)</code>.</p>\n<p>Only after the steps to determine which conversion sequence is better do we get to the step that the more specialized template is preferred. The full rule ordering in [over.match.best] is:</p>\n<blockquote>\n<p id=\"so_31047860_31048865_5\">Given these definitions, a viable function F1 is defined to be a better function than another viable function\n  F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<ul>\n<li>for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,</li>\n</ul>\n</blockquote>\n<p>That's what we just went through.</p>\n<blockquote id=\"so_31047860_31048865_6\">\n<ul>\n<li>the context is an initialization by user-defined conversion [ ... ]</li>\n<li>the context is an initialization by conversion function for direct reference binding [ ... ]</li>\n<li>F1 is not a function template specialization and F2 is a function template specialization, or, if not that,</li>\n<li>F1 and F2 are function template specializations, and the function template for F1 is more specialized\n  than the template for F2 according to the partial ordering rules described in 14.5.6.2. </li>\n</ul>\n</blockquote>\n<p>That's why we pick <code>foo(U&amp;, T&amp;)</code>. If you remove the <code>const</code>, however, then both conversion sequences are identical across all steps - so at that point, the more specialized template (<code>foo(int&amp;, T&amp;)</code>) would win. </p>\n<p>Note that more specialized is the <strong>very last</strong>  mechanism to determine best candidate. It's the most final of tie breakers. </p>\n<p>Also note that the <em>number</em> of template deductions is irrelevant. It <em>may</em> matter in selecting between overload that is a template and an overload that is not a template - but it does not matter in selecting between an overload that has <em>x</em> template parameters and an overload that has <em>y &gt; x</em> template parameters. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-06-25T11:57:14.090", "Score": "15", "CreationDate": "2015-06-25T11:18:12.060", "ParentId": "31047860", "CommentCount": "1", "OwnerUserId": "2069064", "LastEditDate": "2015-06-25T11:57:14.090"}});