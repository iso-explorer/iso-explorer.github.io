post_cb({"22581352": {"ViewCount": "74", "Body": "<p>I'm specializing member functions of a template class in a header file like so:</p>\n<pre><code>#pragma once\n\n#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nstruct Test\n{\n    void Print() { }\n};\n\ntemplate&lt;&gt;\nvoid Test&lt;int&gt;::Print()\n{\n    std::cout &lt;&lt; \"int\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Is it correct to put the specialization in a header file (without it being inline), or should it be in a cpp file? It compiles fine as shown above (using VS2012), but I'm rather surprised I don't get multiple definition linker errors.</p>\n", "AcceptedAnswerId": "22581639", "Title": "Class template member specialization", "CreationDate": "2014-03-22T17:54:14.767", "Id": "22581352", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-03-22T18:19:08.503", "Score": "2", "OwnerUserId": "673679", "Tags": "<c++><specialization><class-template>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_22581352_22581639_1": {"length": 29, "quality": 1.0, "section_id": 7043}, "so_22581352_22581639_0": {"length": 12, "quality": 1.0, "section_id": 7041}}, "n3337": {"so_22581352_22581639_1": {"length": 29, "quality": 1.0, "section_id": 6788}, "so_22581352_22581639_0": {"length": 12, "quality": 1.0, "section_id": 6786}}, "n4659": {"so_22581352_22581639_1": {"length": 29, "quality": 1.0, "section_id": 8540}, "so_22581352_22581639_0": {"length": 12, "quality": 1.0, "section_id": 8538}}}, "22581639": {"Id": "22581639", "PostTypeId": "2", "Body": "<p>The ODR requires exactly one definition for non-inline functions that are <em>ODR-used</em> (that roughy means, for functions, being potentially called).</p>\n<p>Quoting n3485, [basic.def.odr]</p>\n<blockquote>\n<p id=\"so_22581352_22581639_0\"><sup>4</sup> Every program shall contain exactly one definition of\n  every non-inline function or variable that is odr-used in that\n  program; no diagnostic required.</p>\n</blockquote>\n<p>Then, there's an exception for <em>templates</em> (i.e. not for functions):</p>\n<blockquote>\n<p id=\"so_22581352_22581639_1\"><sup>6</sup> There can be more than one definition of a class type [...], class template, non-static function template, static data member\n  of a class template, <strong>member function of a class template, or template specialization for\n  which some template parameters are not specified</strong> in a program provided that [...]</p>\n</blockquote>\n<p>[emphasis mine]</p>\n<p>An explicit specialization of a template is not a template. For example, an explicitly specialized class template is a class (with a strange name). Therefore, your assumption is correct and multiple definitions for explicitly specialized members of class templates violate the ODR.</p>\n<p>With g++4.8.1, I even get a linker error in such a program; note that I have ODR-used the function. No diagnostic is required for a violation of the ODR.</p>\n", "LastActivityDate": "2014-03-22T18:19:08.503", "CommentCount": "0", "CreationDate": "2014-03-22T18:19:08.503", "ParentId": "22581352", "Score": "2", "OwnerUserId": "420683"}, "22581474": {"Id": "22581474", "PostTypeId": "2", "Body": "<p>Putting the specialisation in the header file is the canonical form (as <code>boost</code> does), it doesn't violate the ODR. </p>\n", "LastActivityDate": "2014-03-22T18:04:13.280", "CommentCount": "1", "CreationDate": "2014-03-22T18:04:13.280", "ParentId": "22581352", "Score": "1", "OwnerUserId": "1312406"}});