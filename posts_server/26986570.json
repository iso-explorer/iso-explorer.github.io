post_cb({"26986664": {"ParentId": "26986570", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The problem is that the constructor of <code>B</code> is deleted by the compiler, as otherwise the default definition would be ill-formed. That's because <code>A</code> has no destructor, and the default constructor of <code>B</code> cannot construct a <code>B</code> from <code>A</code> if <code>A</code> cannot be destroyed. That's the error you are getting if you compile with g++:</p>\n<p><code>note: 'B::B()' is implicitly deleted because the default definition would be ill-formed:</code></p>\n<p>or clang++:</p>\n<p><code>error: call to implicitly-deleted default constructor of 'B'</code></p>\n<p>And if you declare the constructor <code>B(){}</code> explicitly, then it complains because it cannot destroy the <code>A</code> part of <code>B</code>, due to the deletion of <code>A::~A()</code>. \nThe ability of <code>B</code> to bury its parent <code>A</code> is checked at compile time, so you are getting an error.</p>\n<p>+1 for the question. It seems that you cannot inherit (then use an instance) from a class with a deleted destructor, although it is the first time I'm bumping into this issue.</p>\n", "OwnerUserId": "3093378", "LastEditorUserId": "2411320", "LastEditDate": "2015-05-05T15:01:16.520", "Id": "26986664", "Score": "16", "CreationDate": "2014-11-18T04:36:51.200", "LastActivityDate": "2015-05-05T15:01:16.520"}, "26988492": {"ParentId": "26986570", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Based on the first code:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct A\n{\n  A(){ };\n  ~A(){ std::cout &lt;&lt; \"~A::A()\" &lt;&lt; std::endl; };\n};\n\nstruct B: A { };\n\nB *b = new B; //Doesn't produce any side-effect.\n\nint main(){ }\n</code></pre>\n<ol>\n<li>Object b is declared as global, so its lifecycle is as long as program runs.</li>\n<li>Object b is allocated dynamically, so 'naked' deletion is needed.</li>\n</ol>\n<p>Try the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A \n{\n    A(){ };\n    ~A(){ std::cout &lt;&lt; \"~A::A()\" &lt;&lt; std::endl; };\n};\n\nstruct B: A { };\n\nint main(){\n    B b;\n}\n</code></pre>\n", "OwnerUserId": "4259415", "LastEditorUserId": "63550", "LastEditDate": "2014-11-18T19:43:48.913", "Id": "26988492", "Score": "5", "CreationDate": "2014-11-18T07:05:34.127", "LastActivityDate": "2014-11-18T19:43:48.913"}, "26995870": {"ParentId": "26986570", "CommentCount": "0", "Body": "<p>C++14 is clear about this:</p>\n<blockquote>\n<p id=\"so_26986570_26995870_0\"><code>[C++14: 12.6.2/10]:</code> In a non-delegating constructor, the destructor for each potentially constructed subobject of class type is potentially invoked (12.4). <em>[ Note:</em> This provision ensures that destructors can be called for fully-constructed sub-objects in case an exception is thrown (15.2). <em>\u2014end note ]</em></p>\n</blockquote>\n<p>There is no such wording in C++11 as <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1424\" rel=\"nofollow\">it was added in issue 1424</a>, but since this fact cannot be ignored, it is also true in practice in C++11 and C++98/03 implementations.</p>\n<p>So, although you're still not ever invoking the destructor, the presence of <em>inheritance</em> means <code>B()</code> requires <code>~A()</code> to be invokable: basically, that means <em>accessible</em> and <em>not deleted</em>.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "26995870", "Score": "2", "CreationDate": "2014-11-18T13:46:04.907", "LastActivityDate": "2014-11-18T13:46:04.907"}, "26992515": {"ParentId": "26986570", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In answer to your headline question: if you don't call <code>delete</code> then no deletion takes place, although the memory utilised by the object can be freed by the termination of the program which created it, which can cause one of several things to happen:</p>\n<ul>\n<li>memory is marked as free/available by the OS, as the owning process has terminated, and the memory is then available to the OS/other processes again</li>\n<li>the destructors for all objects are called, either implicit destructors or explicit where declared, as the main process terminates (and the memory is then available to the OS/other processes again).</li>\n<li>sheer raw willpower from the original code transcends programmatic function and obliterates the contents of memory allocated by the un-deleted objects and returns the memory to the OS.</li>\n</ul>\n<p>Well, other than the last one, you get the gist, the last is merely a fond sentimentality to bolster a coders ego:D</p>\n<p>The only provisos to this would be orphaned objects (where the pointer to a memory location is lost at some point in the code, <a href=\"https://stackoverflow.com/a/15400767/1903417\">see here for example</a>) and object with a deleted destructor(<a href=\"https://stackoverflow.com/a/18847789/1903417\">see here for a brief explanation</a>): these can't be deleted because in the first instance they are no longer addressable, and in the second they are an erroneous* object as there is no destructor for them (* erroneous as in not conforming to standard use/spec, however there are times when you may want to stop an object from being deleted on its own/before the owning process has terminated, for example a special case <a href=\"https://stackoverflow.com/a/1008289/1903417\">singleton</a>, however, good programming/logic should prevent the need for a destructor being unavailable at all).</p>\n<p>Let me know if you need more information, or if any of the above needs clarification, and I shall be only too happy to help:)</p>\n", "OwnerUserId": "1903417", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:07:20.107", "Id": "26992515", "Score": "0", "CreationDate": "2014-11-18T10:53:23.890", "LastActivityDate": "2014-11-18T10:53:23.890"}, "26995474": {"ParentId": "26986570", "CommentCount": "2", "Body": "<p>The applicable parts of the standard are (quoting N4140):</p>\n<p>\u00a712.4 [class.dtor]/p11:</p>\n<blockquote>\n<p id=\"so_26986570_26995474_0\">A destructor is <em>potentially invoked</em> if it is invoked or as specified\n  in 5.3.4 and 12.6.2. A program is ill-formed if a destructor that is\n  potentially invoked is deleted or not accessible from the context of\n  the invocation.</p>\n</blockquote>\n<p>\u00a712.6.2 [class.base.init]/p10:</p>\n<blockquote>\n<p id=\"so_26986570_26995474_1\">In a non-delegating constructor, the destructor for each potentially\n  constructed subobject of class type is potentially invoked (12.4). [\n  <em>Note</em>: This provision ensures that destructors can be called for fully-constructed sub-objects in case an exception is thrown (15.2).\n  \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>\u00a712 [special]/p5:</p>\n<blockquote>\n<p id=\"so_26986570_26995474_2\">For a class, its non-static data members, its non-virtual direct base\n  classes, and, if the class is not abstract (10.4), its virtual base\n  classes are called its <em>potentially constructed subobjects</em>.</p>\n</blockquote>\n<p>Since <code>A</code> is a non-virtual direct base of <code>B</code> and hence a <em>potentially constructed subobject</em> of <code>B</code>, its destructor is <em>potentially invoked</em> in <code>B::B()</code>, and since that destructor is deleted, the program is ill-formed.</p>\n<p>See also <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1424\">CWG issue 1424</a>.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "26995474", "Score": "15", "CreationDate": "2014-11-18T13:26:16.703", "LastActivityDate": "2014-11-18T13:26:16.703"}, "26986570": {"CommentCount": "13", "AcceptedAnswerId": "26995474", "PostTypeId": "1", "LastEditorUserId": "1748450", "CreationDate": "2014-11-18T04:26:43.927", "LastActivityDate": "2015-05-05T15:01:16.520", "AnswerCount": "6", "LastEditDate": "2014-11-18T14:29:40.187", "ViewCount": "2819", "FavoriteCount": "4", "Title": "Why is a destructor called if it's deleted and not called if it's not deleted?", "Id": "26986570", "Score": "27", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A \n{\n    A(){ };\n    ~A(){ std::cout &lt;&lt; \"~A::A()\" &lt;&lt; std::endl; };\n};\n\nstruct B: A { };\n\nB *b = new B; //Doesn't produce any side-effect.\n\nint main(){ }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/29842316b0179741\" rel=\"noreferrer\">DEMO</a></strong></p>\n<p>The program doesn't produce any output which means the destructor isn't being called. But if we replace the destructor's body with the <code>delete</code> specifier, the program won't even compile. </p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A \n{\n    A(){ };\n    ~A() = delete; //{ std::cout &lt;&lt; \"~A::A()\" &lt;&lt; std::endl; };\n};\n\nstruct B: A { };\n\nB *b = new B; //Error: use of deleted function\n\nint main(){ }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/9cf074c19572a3fb\" rel=\"noreferrer\">DEMO</a></strong></p>\n<p>due to call to the deleted function. That's the destructor that is being called in that case. Why is there such a difference?</p>\n<p>It won't work even if we define <code>B</code>'s constructor explicitly:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A \n{\n    A(){ };\n    ~A() = delete; //{ std::cout &lt;&lt; \"~A::A()\" &lt;&lt; std::endl; };\n};\n\nstruct B: A \n{ \n    B(){ };\n};\n\nB *b = new B;\n\nint main(){ }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/99a16549b4c21738\" rel=\"noreferrer\">DEMO</a></strong></p>\n", "Tags": "<c++><c++11><destructor>", "OwnerDisplayName": "user2953119"}, "bq_ids": {"n4140": {"so_26986570_26995474_2": {"section_id": 365, "quality": 0.8695652173913043, "length": 20}, "so_26986570_26995870_0": {"section_id": 437, "quality": 0.7241379310344828, "length": 21}, "so_26986570_26995474_1": {"section_id": 437, "quality": 0.7777777777777778, "length": 21}, "so_26986570_26995474_0": {"section_id": 407, "quality": 0.8, "length": 12}}, "n3337": {"so_26986570_26995474_2": {"section_id": 359, "quality": 0.5652173913043478, "length": 13}}, "n4659": {"so_26986570_26995474_2": {"section_id": 377, "quality": 0.8695652173913043, "length": 20}, "so_26986570_26995870_0": {"section_id": 457, "quality": 0.7241379310344828, "length": 21}, "so_26986570_26995474_1": {"section_id": 457, "quality": 0.7777777777777778, "length": 21}, "so_26986570_26995474_0": {"section_id": 425, "quality": 0.8, "length": 12}}}, "26993006": {"ParentId": "26986570", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Concerning what I think is your basic question: why you cannot construct\na <code>B</code>, even though it is only the <em>destructor</em> of <code>A</code> which doesn't\nexist: In the constructor of <code>B</code>, the compiler automatically generates\ncode to call the destructor of <code>A</code> if there is an exception.  If <code>A</code> is\nto be used as a base class, it <em>must</em> have an accessible destructor\n(public or protected).</p>\n<p>In your case, of course, the constructor of <code>B</code> cannot throw, and so\n<code>A::~A()</code> will never actually be called.  But the compiler can't always\ndetermine if this is the case or not, and the standard doesn't require\nit to even try.  The compiler must assume that the body of <code>B::B()</code> may\nthrow (after having completely constructed <code>A</code>).  And even if it can\ndetermine that <code>B::B()</code> cannot throw, and does not generate the code to\ncall the destructor of <code>A</code>, this is an optimization, which is not\nallowed to change the legality of the code.</p>\n", "OwnerUserId": "649665", "LastEditorUserId": "2756719", "LastEditDate": "2014-11-18T13:15:58.420", "Id": "26993006", "Score": "11", "CreationDate": "2014-11-18T11:16:48.363", "LastActivityDate": "2014-11-18T13:15:58.420"}});