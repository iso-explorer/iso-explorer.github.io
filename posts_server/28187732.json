post_cb({"bq_ids": {"n4140": {"so_28187732_28187927_1": {"section_id": 6859, "quality": 0.8, "length": 4}}, "n3337": {"so_28187732_28187927_1": {"section_id": 6605, "quality": 0.8, "length": 4}}, "n4659": {"so_28187732_28187927_1": {"section_id": 8351, "quality": 0.8, "length": 4}}}, "28187732": {"CommentCount": "0", "AcceptedAnswerId": "28191421", "CreationDate": "2015-01-28T08:33:01.793", "LastActivityDate": "2016-09-19T22:51:06.557", "PostTypeId": "1", "ViewCount": "1747", "FavoriteCount": "6", "Title": "Placement new in std::aligned_storage?", "Id": "28187732", "Score": "15", "Body": "<p>Suppose I have a type template parameter T.</p>\n<p>And suppose I have a <code>std::aligned_storage</code> as follows:</p>\n<pre><code>typename std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type storage;\n</code></pre>\n<p>I want to placement new a T into the <code>storage</code>.</p>\n<p>What is the standard-compliant pointer value/type to pass to the placement new operator, and how do I derive that from <code>storage</code>?</p>\n<pre><code>new (&amp; ???) T(a,b,c);\n</code></pre>\n<p>For example:</p>\n<pre><code>new (&amp;storage) T(a,b,c);\nnew (static_cast&lt;void*&gt;(&amp;storage)) T(a,b,c);\nnew (reinterpret_cast&lt;T*&gt;(&amp;storage)) T(a,b,c);\nnew (static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;storage));\n</code></pre>\n<p>Which of the above (if any) are compliant, and if none, what is the better way?</p>\n", "Tags": "<c++><c++14>", "OwnerUserId": "1131467", "AnswerCount": "2"}, "28191421": {"ParentId": "28187732", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The most paranoid way is</p>\n<pre><code>::new ((void *)::std::addressof(storage)) T(a, b, c);\n</code></pre>\n<p>Explanation:</p>\n<ul>\n<li><code>::std::addressof</code> guards against overloaded unary <code>operator&amp;</code> on <code>storage</code>, which is technically allowed by the standard. (Though no sane implementation would do it.) The <code>::std</code> guards against any non-top-level namespaces (or classes) called <code>std</code> that might be in scope.</li>\n<li><code>(void *)</code> (which in this case is a <code>static_cast</code>) ensures that you call the placement <code>operator new</code> taking a <code>void *</code> rather than something else like <code>decltype(storage) *</code>.</li>\n<li><code>::new</code> skips any class-specific placement <code>operator new</code>s, ensuring that the call goes to the global one.</li>\n</ul>\n<p>Together, this guarantees that the call goes to the library placement <code>operator new</code> taking a <code>void *</code>, and that the <code>T</code> is constructed at where <code>storage</code> is.</p>\n<p>In most sane programs, though,</p>\n<pre><code>new (&amp;storage) T(a,b,c);\n</code></pre>\n<p>should be sufficient.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2016-09-19T22:51:06.557", "Id": "28191421", "Score": "25", "CreationDate": "2015-01-28T11:43:48.940", "LastActivityDate": "2016-09-19T22:51:06.557"}, "28187927": {"ParentId": "28187732", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The placement allocation function is described as follows (C++14 n4140 18.6.1.3):</p>\n<blockquote>\n<pre><code>void* operator new(std::size_t size, void* ptr) noexcept;\n</code></pre>\n<p id=\"so_28187732_28187927_0\"><em>Returns:</em> <code>ptr</code>.</p>\n<p id=\"so_28187732_28187927_1\"><em>Remarks:</em> Intentionally performs no other action.</p>\n</blockquote>\n<p>20.10.7.6 table 57 describes <code>aligned_storage&lt;Len, Align&gt;</code> thus:</p>\n<blockquote>\n<p id=\"so_28187732_28187927_2\">The member typedef <code>type</code>\n  shall be a POD type suitable for use\n  as uninitialized storage for any object\n  whose size is at most <em>Len</em> and whose\n  alignment is a divisor of <em>Align.</em></p>\n</blockquote>\n<p>This implies that in your case, <code>&amp;storage</code> is suitably aligned for holding an object of type <code>T</code>. Therefore, under normal circumstances<sup>1</sup>, all 4 ways you've listed of calling placement <code>new</code> are valid and equivalent. I would use the first one (<code>new (&amp;storage)</code>) for brevity.</p>\n<hr>\n<p><sup>1</sup> T.C. correctly pointed out in the comments that it is technically possible for your program to declare an overload of the allocation function taking a <code>typename std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type*</code>, which would then be selected by overload resolution instead of the library-provided 'placement new' version.</p>\n<p>I would say this unlikely in at least 99.999% of cases, but if you need to guard against that as well, use one of the casts to <code>void*</code>. The direct <code>static_cast&lt;void*&gt;(&amp;storage)</code> is enough.</p>\n<p>Also, if you're paranoid to this level, you should probably use <code>::new</code> instead of just <code>new</code> to bypass any class-specific allocation functions.</p>\n</hr>", "OwnerUserId": "1782465", "LastEditorUserId": "1782465", "LastEditDate": "2015-01-28T12:40:22.260", "Id": "28187927", "Score": "4", "CreationDate": "2015-01-28T08:45:25.893", "LastActivityDate": "2015-01-28T12:40:22.260"}});