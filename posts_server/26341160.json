post_cb({"bq_ids": {"n4140": {"so_26341160_26344975_0": {"length": 11, "quality": 1.0, "section_id": 5890}}, "n3337": {"so_26341160_26344975_0": {"length": 11, "quality": 1.0, "section_id": 5661}}, "n4659": {"so_26341160_26344975_0": {"length": 11, "quality": 1.0, "section_id": 7373}}}, "26341160": {"ViewCount": "249", "Body": "<p>I'm trying to write C++11 impostors (as best termed by @jrok, because these classes have no fields like wrappers do) for bunch of C \"classes\", similarly to this:</p>\n<pre><code>extern \"C\" {\n  struct cfoo;\n  cfoo * cfoo_new();\n  void cfoo_free(cfoo *);\n  int cfoo_bar(cfoo *, int);\n} // extern \"C\" {\nclass Foo final {\n    Foo() = delete;                        // Prevents\n    Foo(Foo &amp;&amp;) = delete;                  // construction\n    Foo(const Foo &amp;) = delete;             // of this\n    Foo &amp; operator=(Foo &amp;&amp;) = delete;      // C++\n    Foo &amp; operator=(const Foo &amp;) = delete; // object\npublic: /* Methods: */\n    int bar(int v) noexcept { return cfoo_bar(cPtr(), v); }\n    cfoo * cPtr() noexcept { return reinterpret_cast&lt;cfoo *&gt;(this); }\n    static Foo * create() {\n       cfoo * const f = cfoo_new();\n       if (!f) throw std::bad_alloc();\n       return reinterpret_cast&lt;Foo *&gt;(f);\n    }\n    // No member fields! No double dereference! No extra memory!\n}; // class Foo {\n</code></pre>\n<p>However, in C++11 code I also want to do something like:</p>\n<pre><code>Foo * foo = Foo::create();\nfoo-&gt;bar(42);\ndelete foo;                                 // (1)\n{\n  std::unique_ptr&lt;Foo&gt; pFoo(Foo::create()); // no custom deleter!\n  pFoo-&gt;bar(3);\n} // pFoo goes out of scope                 // (2)\n</code></pre>\n<p>so that (1) and (2) would only call <code>ctest_free(x-&gt;cPtr())</code> where <code>Test * x</code> is the pointer passed to the <code>delete</code> operator.</p>\n<p>What would be the proper/safest way to implement this in C++11?</p>\n<p><strong>Edit:</strong> Thank you for your answers so far, but please lets keep this on topic and refrain from rant on coding practices. Please just answer the question, tell me why this is impossible to archieve, or show me where my code has undefined behaviour according to ISO/IEC 14482/2011.</p>\n", "AcceptedAnswerId": "26344975", "Title": "How to implement operator delete for C++11 impostors of C \"classes\"?", "CreationDate": "2014-10-13T13:28:26.300", "Id": "26341160", "CommentCount": "17", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-10-13T15:23:49.157", "LastEditorUserId": "3919155", "LastActivityDate": "2016-04-09T16:39:05.260", "Score": "-3", "OwnerUserId": "3919155", "Tags": "<c++><c++11><interface><operator-overloading><porting>", "AnswerCount": "3"}, "26341407": {"Id": "26341407", "PostTypeId": "2", "Body": "<p>Following may help:</p>\n<pre><code>class Foo {\npublic:\n    Foo() : p(cfoo_new()) {\n       if (!p) { throw std::bad_alloc(); }\n    }\n    ~Foo() { cfoo_free(p); }\n\n    Foo(const Foo&amp;) = delete;\n    Foo&amp; operator = (const Foo&amp;) = delete;\n\n    int bar(int v) noexcept { return cfoo_bar(p, v); }\nprivate:\n    cfoo* p;\n};\n</code></pre>\n<p>Or even better with <code>std::unique_ptr</code> as mentionned by quantdev</p>\n<pre><code>class Foo {\npublic:\n    Foo() : p(cfoo_new(), cfoo_free) {\n       if (!p) { throw std::bad_alloc(); }\n    }\n    int bar(int v) noexcept { return cfoo_bar(p.get(), v); }\nprivate:\n    std::unique_ptr&lt;Foo, void(*)(Foo*)&gt; p;\n};\n</code></pre>\n<p>And so your calling code becomes:</p>\n<pre><code>{\n    Foo foo;\n    foo.bar(42);\n} // foo goes out of scope\n{\n  std::unique_ptr&lt;Foo&gt; pFoo(new Foo()); // no custom deleter!\n  pFoo-&gt;bar(3);\n} // pFoo goes out of scope\n</code></pre>\n", "LastEditorUserId": "2684539", "LastActivityDate": "2014-10-13T16:48:45.157", "Score": "3", "CreationDate": "2014-10-13T13:39:39.697", "ParentId": "26341160", "CommentCount": "7", "OwnerUserId": "2684539", "LastEditDate": "2014-10-13T16:48:45.157"}, "26344975": {"Id": "26344975", "PostTypeId": "2", "Body": "<p>This is undefined behavior because you are invoking a non-static member function of <code>Foo</code> on an object that is not a <code>Foo</code> (a <code>cfoo</code>). The relevant standard-ese is \u00a79.3.1/2:</p>\n<blockquote>\n<p id=\"so_26341160_26344975_0\">If a non-static member function of a class <strong><code>X</code></strong> is called for an object that is not of type <strong><code>X</code></strong>, or of a type derived from <strong><code>X</code></strong>, the behavior is undefined.</p>\n</blockquote>\n<p>There is no exception made for member functions of empty classes.</p>\n<hr>\n<p>The safest and proper way to do what you are trying is to write a wrapper type, as many others have pointed out already. For example:</p>\n<pre><code>class Foo {\n    std::unique_ptr&lt;cfoo, void(*)(cfoo*)&gt; p;\npublic:\n    Foo() : p{cfoo_new(), cfoo_free} { if (!p) throw std::bad_alloc{}; }\n    int bar(int i) noexcept { return cfoo_bar(p.get(), i); }\n};\n</code></pre>\n<p>Comparing its usage to the C interface:</p>\n<pre><code>// Using the C interface\n{\n    cfoo* foo = cfoo_new();\n    if (!foo) throw std::bad_alloc{};\n    cfoo_bar(foo, 42);\n    cfoo_free(foo);\n}\n\n// Using a C++ wrapper\n{\n    Foo foo;\n    foo.bar(42);\n}\n</code></pre>\n<p>This will be zero overhead over the C interface when using any optimizing compiler. For example, the assembly output by GCC is <em>identical</em> for both blocks above.</p>\n</hr>", "LastEditorUserId": "3311013", "LastActivityDate": "2014-10-13T16:55:46.913", "Score": "6", "CreationDate": "2014-10-13T16:48:29.173", "ParentId": "26341160", "CommentCount": "2", "OwnerUserId": "3311013", "LastEditDate": "2014-10-13T16:55:46.913"}, "26342259": {"Id": "26342259", "PostTypeId": "2", "Body": "<pre><code>// No member fields! No double dereference! No extra memory!\n</code></pre>\n<p>You seem to think that having a member in your class will somehow increase your memory usage. This is simply not going to be true. Compare your code sample:</p>\n<pre><code>Foo * foo = Foo::create();\nfoo-&gt;bar(42);\n</code></pre>\n<p>To what it should look like:</p>\n<pre><code>Foo foo;\nfoo.bar();\n</code></pre>\n<p>In the first we are using stack memory to store <code>foo</code> which will be <code>sizeof(Foo*)</code>, in the second we are using stack memory to store <code>foo</code> which will be <code>sizeof(Foo)</code>. If <code>Foo</code> contains one member of either <code>Foo*</code> type or <code>std::unique_ptr&lt;Foo&gt;</code> type then how big will <code>Foo</code> be? That's right, it will be <code>Foo*</code> big.</p>\n<p>The key difference is that the second example is exception safe, safe from memory leak errors, clear and compact.</p>\n<p>As for the worry about extra de-referencing, how many de-references are in your <code>foo-&gt;bar()</code> example? No de-references happen within the function itself. How many occur in <code>foo.bar()</code> where <code>bar</code> is defined as:</p>\n<pre><code>int bar(int v) noexcept { return cfoo_bar(p.get(), v); }\n</code></pre>\n<p>by Jarod42? Again no de-references happen within the function itself, only once <code>cfoo_bar</code> uses that pointer.</p>\n<p><strong>Edit:</strong> So from reading the comments you later left on the question it appears to be that what you are <em>actually</em> optimizing for is the overhead of passing a reference to the wrapper object to a function. Yes this does have some overhead. If I define: </p>\n<pre><code>void foobar(cfoo * f)\n{\n  cfoo_bar(f, 0);\n}\n</code></pre>\n<p>Then <code>g++ -O3</code> generates:</p>\n<pre><code>foobar(cfoo*):\n    xorl    %esi, %esi\n    jmp cfoo_bar\n</code></pre>\n<p>Whereas:</p>\n<pre><code>void foobar(Foo&amp; f)\n{\n  f.bar(0);\n}\n</code></pre>\n<p>generates:</p>\n<pre><code>foobar(Foo&amp;):\n    movq    8(%rdi), %rdi\n    xorl    %esi, %esi\n    jmp cfoo_bar\n</code></pre>\n<p>But this is simply the price you pay for the deterministic destruction that comes with C++ classes. Your proposed solution will indeed produce the same assembly as the C version but will have the same memory safety problems as it as well. That's not to say coding in a C style is ever wrong when you do need that extra instruction of performance but you do not get it for free.</p>\n<p><em>N.B.</em> I had to <code>__attribute__((noinline))</code> the above functions just to prevent the compiler from inlining them and thus eliminating the overhead.</p>\n", "LastEditorUserId": "2558027", "LastActivityDate": "2016-04-09T16:39:05.260", "Score": "4", "CreationDate": "2014-10-13T14:20:55.350", "ParentId": "26341160", "CommentCount": "1", "OwnerUserId": "2558027", "LastEditDate": "2016-04-09T16:39:05.260"}});