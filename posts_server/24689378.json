post_cb({"24689549": {"ParentId": "24689378", "CommentCount": "1", "Body": "<p>At the end of stage 2, it says:</p>\n<blockquote>\n<p id=\"so_24689378_24689549_0\">If it is not discarded, then a check is made to determine if c is\n  allowed as the next character of an input \ufb01eld of the conversion\n  speci\ufb01er returned by Stage 1. If so, it is accumulated.</p>\n<p id=\"so_24689378_24689549_1\">If the character is either discarded or accumulated then in is advanced by ++in and processing returns to the beginning of stage 2.</p>\n</blockquote>\n<p>So perhaps <code>a</code> is not allowed in the <code>%g</code> specifier and it is not accumulated or ignored.</p>\n", "OwnerUserId": "390913", "PostTypeId": "2", "Id": "24689549", "Score": "4", "CreationDate": "2014-07-11T03:18:52.317", "LastActivityDate": "2014-07-11T03:18:52.317"}, "24689378": {"CommentCount": "10", "AcceptedAnswerId": "24689817", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-07-11T02:53:51.593", "LastActivityDate": "2014-07-11T04:20:28.703", "LastEditDate": "2017-05-23T12:05:45.040", "ViewCount": "319", "FavoriteCount": "1", "Title": "Characters extracted by istream >> double", "Id": "24689378", "Score": "6", "Body": "<p>Sample code <a href=\"http://coliru.stacked-crooked.com/a/16f746cdff6bb5fa\" rel=\"nofollow noreferrer\">at Coliru</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    double d; std::string s;\n\n    std::istringstream iss(\"234cdefipxngh\");\n    iss &gt;&gt; d;\n    iss.clear();\n    iss &gt;&gt; s;\n    std::cout &lt;&lt; d &lt;&lt; \", '\" &lt;&lt; s &lt;&lt; \"'\\n\";\n}\n</code></pre>\n<p>I'm reading off N3337 here (presumably that is the same as C++11). In [istream.formatted.arithmetic] we have (paraphrased):</p>\n<blockquote>\n<p id=\"so_24689378_24689378_0\"><code>operator&gt;&gt;(double&amp; val);</code></p>\n<p id=\"so_24689378_24689378_1\">As in the case of the inserters, these extractors depend on the locale\u2019s num_get&lt;&gt; (22.4.2.1) object\n  to perform parsing the input stream data. These extractors behave as formatted input functions (as\n  described in 27.7.2.2.1). After a sentry object is constructed, the conversion occurs as if performed by the following code fragment:</p>\n<p id=\"so_24689378_24689378_2\"><code>typedef num_get&lt; charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;</code><br>\n<code>iostate err = iostate::goodbit;</code><br>\n<code>use_facet&lt; numget &gt;(loc).get(*this, 0, *this, err, val);</code><br>\n<code>setstate(err);</code><br/></br></br></br></p>\n</blockquote>\n<p>Looking over to 22.4.2.1:</p>\n<blockquote>\n<p id=\"so_24689378_24689378_3\">The details of this operation occur in three stages<br>\n  \u2014 Stage 1: Determine a conversion specifier<br>\n  \u2014 Stage 2: Extract characters from in and determine a corresponding char value for the format\n  expected by the conversion specification determined in stage 1.<br>\n  \u2014 Stage 3: Store results<br/></br></br></br></p>\n</blockquote>\n<p>In the description of Stage 2, it's too long for me to paste the whole thing here. However it clearly says that all characters should be extracted before conversion is attempted; and further that exactly the following characters should be extracted:</p>\n<ul>\n<li>any of <code>0123456789abcdefxABCDEFX+-</code></li>\n<li>The locale's <code>decimal_point()</code></li>\n<li>The locale's <code>thousands_sep()</code></li>\n</ul>\n<p>Finally, the rules for Stage 3 include:</p>\n<blockquote>\n<p id=\"so_24689378_24689378_4\">\u2014 For a floating-point value, the function <code>strtold</code>.</p>\n<p id=\"so_24689378_24689378_5\">The numeric value to be stored can be one of:</p>\n<p id=\"so_24689378_24689378_6\">\u2014 zero, if the conversion function fails to convert the entire field.</p>\n</blockquote>\n<p>This all seems to clearly specify that the output of my code should be <code>0, 'ipxngh'</code>.  However, it actually outputs something else.</p>\n<p>Is this a compiler/library bug? Is there any provision that I'm overlooking for a locale to change the behaviour of Stage 2?  (In <a href=\"https://stackoverflow.com/questions/24640314/why-are-some-strings-cutoff-when-attempting-to-read-a-mixture-of-numeric-and-non/24689271#24689271\">another question</a> someone posted an example of a system that does actually extract the characters, but also extracts <code>ipxn</code> which are not in the list specified in N3337).</p>\n<h2>Update</h2>\n<p>As pointed out by perreal, this text from Stage 2 is relevant:</p>\n<blockquote>\n<p id=\"so_24689378_24689378_7\">If discard is true, then if \u2019.\u2019 has not yet been accumulated, then the position of the character\n  is remembered, but the character is otherwise ignored. Otherwise, if \u2019.\u2019 has already been\n  accumulated, the character is discarded and Stage 2 terminates. If it is not discarded, then a\n  check is made to determine if <code>c</code> is allowed as the next character of an input field of the conversion specifier returned by Stage 1. If so, it is accumulated.</p>\n<p id=\"so_24689378_24689378_8\">If the character is either discarded or accumulated then in is advanced by ++in and processing\n  returns to the beginning of stage 2.</p>\n</blockquote>\n<p>So, Stage 2 can terminate if the character is in the list of allowed characters, but is not a valid character for <code>%g</code>. It doesn't say exactly, but presumably this refers to the definition of <code>fscanf</code> from C99 , which allows:</p>\n<blockquote id=\"so_24689378_24689378_9\">\n<ul>\n<li>a nonempty sequence of decimal digits optionally containing a decimal-point\n  character, then an optional exponent part as defined in 6.4.4.2;</li>\n<li>a 0x or 0X, then a nonempty sequence of hexadecimal digits optionally containing a\n  decimal-point character, then an optional binary exponent part as defined in 6.4.4.2;</li>\n<li>INF or INFINITY, ignoring case</li>\n<li>NAN or NAN(n-char-sequence opt ), ignoring case in the NAN part, where:</li>\n</ul>\n</blockquote>\n<p>and also</p>\n<blockquote>\n<p id=\"so_24689378_24689378_10\">In other than the \"C\" locale, additional locale-specific subject sequence forms may be accepted.</p>\n</blockquote>\n<p>So, actually the Coliru output is correct; and in fact the processing <em>must</em> attempt to validate the sequence of characters extracted so far as a valid input to <code>%g</code>, while extracting each character.</p>\n<p>Next question: is it permitted, as in the thread I linked to earlier, to accept <code>i</code> , <code>n</code>, <code>p</code> etc in Stage 2? </p>\n<p>These are valid characters for <code>%g</code> , however they are not in the list of atoms which Stage 2 is allowed to read (i.e. <code>c == 0</code> for my latest quote, so the character is neither discarded nor accumulated).</p>\n", "Tags": "<c++><c++11><iostream><facets>", "OwnerUserId": "1505939", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24689378_24689378_1": {"section_id": 2189, "quality": 0.9032258064516129, "length": 28}, "so_24689378_24689549_1": {"section_id": 6536, "quality": 1.0, "length": 10}, "so_24689378_24689378_4": {"section_id": 6536, "quality": 0.8, "length": 4}, "so_24689378_24689378_6": {"section_id": 6536, "quality": 1.0, "length": 7}, "so_24689378_24689378_5": {"section_id": 6536, "quality": 0.8333333333333334, "length": 5}, "so_24689378_24689378_7": {"section_id": 6536, "quality": 1.0, "length": 37}, "so_24689378_24689378_3": {"section_id": 6535, "quality": 0.9615384615384616, "length": 25}, "so_24689378_24689549_0": {"section_id": 6536, "quality": 0.8666666666666667, "length": 13}, "so_24689378_24689378_8": {"section_id": 6536, "quality": 1.0, "length": 10}}, "n3337": {"so_24689378_24689378_1": {"section_id": 2177, "quality": 0.9032258064516129, "length": 28}, "so_24689378_24689549_1": {"section_id": 6291, "quality": 1.0, "length": 10}, "so_24689378_24689378_4": {"section_id": 6291, "quality": 0.8, "length": 4}, "so_24689378_24689378_6": {"section_id": 6291, "quality": 1.0, "length": 7}, "so_24689378_24689378_5": {"section_id": 6291, "quality": 0.8333333333333334, "length": 5}, "so_24689378_24689378_7": {"section_id": 6291, "quality": 1.0, "length": 37}, "so_24689378_24689378_3": {"section_id": 6290, "quality": 0.9615384615384616, "length": 25}, "so_24689378_24689549_0": {"section_id": 6291, "quality": 0.8666666666666667, "length": 13}, "so_24689378_24689378_8": {"section_id": 6291, "quality": 1.0, "length": 10}}, "n4659": {"so_24689378_24689378_1": {"section_id": 2462, "quality": 0.9032258064516129, "length": 28}, "so_24689378_24689549_1": {"section_id": 8018, "quality": 1.0, "length": 10}, "so_24689378_24689378_7": {"section_id": 8018, "quality": 1.0, "length": 37}, "so_24689378_24689378_6": {"section_id": 8018, "quality": 0.8571428571428571, "length": 6}, "so_24689378_24689378_5": {"section_id": 8018, "quality": 0.8333333333333334, "length": 5}, "so_24689378_24689378_8": {"section_id": 8018, "quality": 1.0, "length": 10}, "so_24689378_24689549_0": {"section_id": 8018, "quality": 0.8666666666666667, "length": 13}, "so_24689378_24689378_3": {"section_id": 8017, "quality": 0.9615384615384616, "length": 25}}}, "24689817": {"ParentId": "24689378", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>This is a mess because it's likely that neither gcc/libstdc++'s nor clang/libc++'s implementation is conforming. It's unclear \"a check is made to determine if c is allowed as the next character of an input field of the conversion specifier returned by Stage 1\" means, but I think that the use of the phrase \"next character\" indicates that check should be context-sensitive (i.e., dependent on the characters that have already been accumulated), and so an attempt to parse, e.g., <code>\"21abc\"</code>, should stop when <code>'a'</code> is encountered. This is consistent with the discussion in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2041\" rel=\"nofollow\">LWG issue 2041</a>, which added this sentence back to the standard after it had been deleted during the drafting of C++11. libc++'s failure to do so is <a href=\"http://llvm.org/bugs/show_bug.cgi?id=17782\" rel=\"nofollow\">bug 17782</a>.</p>\n<p>libstdc++, on the other hand, refuses to parse <code>\"0xABp-4\"</code> past the <code>0</code>, which is actually clearly nonconforming based on the standard (it should parse <code>\"0xAB\"</code> as a hexfloat, as clearly allowed by the C99 <code>fscanf</code> specification for <code>%g</code>).</p>\n<p>The accepting of <code>i</code>, <code>p</code>, and <code>n</code> is not allowed by the standard. See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2381\" rel=\"nofollow\">LWG issue 2381</a>.</p>\n<p>The standard describes the processing very precisely - it must be done \"as if\" by the specified code fragment, which does not accept those characters. Compare the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#221\" rel=\"nofollow\">LWG issue 221</a>, in which they added <code>x</code> and <code>X</code> to the list of characters because <code>num_get</code> as then-described won't otherwise parse <code>0x</code> for integer inputs.</p>\n<p>Clang/libc++ accepts \"inf\" and \"nan\" along with hexfloats but not \"infinity\" as an extension. See <a href=\"http://llvm.org/bugs/show_bug.cgi?id=19611\" rel=\"nofollow\">bug 19611</a>.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-07-11T04:20:28.703", "Id": "24689817", "Score": "5", "CreationDate": "2014-07-11T03:50:03.757", "LastActivityDate": "2014-07-11T04:20:28.703"}});