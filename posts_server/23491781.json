post_cb({"23491781": {"CommentCount": "0", "ViewCount": "1794", "PostTypeId": "1", "LastEditorUserId": "1770418", "CreationDate": "2014-05-06T10:11:13.987", "LastActivityDate": "2017-07-10T19:42:17.870", "Title": "When is a variable odr-used in C++14?", "FavoriteCount": "11", "LastEditDate": "2014-05-06T12:19:58.760", "Id": "23491781", "Score": "22", "Body": "<p>The C++14 draft (N3936) states in \u00a73.2/3:</p>\n<blockquote>\n<p id=\"so_23491781_23491781_0\">A variable x whose name appears as a potentially-evaluated expression ex is odr-used unless applying the lvalue-to-rvalue conversion (4.1) to x yields a constant expression (5.19) that does not invoke any non-trivial functions and, if x is an object, ex is an element of the set of potential results of an expression e, where either the lvalue-to-rvalue conversion (4.1) is applied to e, or e is a discarded-value expression (Clause 5).</p>\n</blockquote>\n<p>This doesn't make any sense to me: If an expression <code>e</code> is a <em>discarded-value expression</em> depends on the context, in which <code>e</code> is used. Every expression used in an <em>expression-statement</em> (\u00a76.2) is a <em>discarded-value expression</em>. If the <em>lvalue-to-rvalue conversion</em> is applied to <code>e</code> also depends on the context <code>e</code> is used in.</p>\n<p>Moreover, what does it mean for an expression to be in the set of <em>potential results</em> of another expression. One needs a notion of equality of expressions to be able to determine membership of a set. But we don't have <em>referential transparency</em>, so I cannot see how this could be achieved.</p>\n<p>Why was this changed from C++11 to C++14? And how should this be interpreted? As it stands, it doesn't make sense.</p>\n", "Tags": "<c++><c++14><one-definition-rule>", "OwnerUserId": "1770418", "AnswerCount": "1"}, "23655125": {"ParentId": "23491781", "PostTypeId": "2", "CommentCount": "7", "Body": "<h2>The purpose of odr-use</h2>\n<p>Informally, <em>odr-use</em> of a variable means the following:</p>\n<blockquote>\n<p id=\"so_23491781_23655125_0\">If any expression anywhere in the program takes the address of or binds a reference directly to an object, this object must be defined.</p>\n</blockquote>\n<h2>Clarification in the latest draft</h2>\n<p>In the latest version of the spec \u00a73.2 has been clarified (see <a href=\"https://github.com/cplusplus/draft/commit/aaaf8ae73d38389d25becc4a97f88f26a76457c1\" rel=\"nofollow noreferrer\">Draft C++14 on GitHub</a>):</p>\n<blockquote>\n<p id=\"so_23491781_23655125_1\">2 An expression is potentially evaluated unless it is an unevaluated operand (Clause 5) or a subexpression thereof. The set of potential results of an expression <code>e</code> is defined as follows:</p>\n<ul>\n<li>If <code>e</code> is an id-expression (5.1.1), the set contains only <code>e</code>.</li>\n<li>If <code>e</code> is a class member access expression (5.2.5), the set contains the potential results of the object expression.</li>\n<li>If <code>e</code> is a pointer-to-member expression (5.5) whose second operand is a constant expression, the set contains the potential results of the object expression.</li>\n<li>If <code>e</code> has the form (e1), the set contains the potential results of e1.</li>\n<li>If <code>e</code> is a glvalue conditional expression (5.16), the set is the union of the sets of potential results of the second and third operands.</li>\n<li>If <code>e</code> is a comma expression (5.18), the set contains the potential results of the right operand.</li>\n<li>Otherwise, the set is empty.</li>\n</ul>\n<p id=\"so_23491781_23655125_2\">[ Note: This set is a (possibly-empty) set of id-expressions, each of which is either <code>e</code> or a subexpression of <code>e</code>.</p>\n<p id=\"so_23491781_23655125_3\">[ Example: In the following example, the set of potential results of the initializer of <code>n</code> contains the first <code>S::x</code> subexpression, but not the second <code>S::x</code> subexpression.</p>\n<pre><code>struct S { static const int x = 0; };\nconst int &amp;f(const int &amp;r);\nint n = b ? (1, S::x) // S::x is not odr-used here\n          : f(S::x);  // S::x is odr-used here, so\n                      // a definition is required\n</code></pre>\n<p id=\"so_23491781_23655125_4\">\u2014end example ] \u2014end note ]</p>\n<p id=\"so_23491781_23655125_5\">3 A variable <code>x</code> whose name appears as a potentially-evaluated expression <code>ex</code> is odr-used <strong>by <code>ex</code></strong> unless applying the lvalue-to-rvalue conversion (4.1) to <code>x</code> yields a constant expression (5.19) that does not invoke any nontrivial functions and, if <code>x</code> is an object, <code>ex</code> is an element of the set of potential results of an expression <code>e</code>, where either the lvalue-to-rvalue conversion (4.1) is applied to <code>e</code>, or <code>e</code> is a discarded-value expression (Clause 5).</p>\n</blockquote>\n<h2>What was the situation in C++11?</h2>\n<p>\u00a73.2/2 in C++11 reads:</p>\n<blockquote>\n<p id=\"so_23491781_23655125_6\">An expression is potentially evaluated unless it is an unevaluated operand (Clause 5) or a subexpression thereof. A variable whose name appears as a potentially-evaluated expression is odr-used unless it is an object that satisfies the requirements for appearing in a constant expression (5.19) and the lvalue-to-rvalue conversion (4.1) is <strong>immediately</strong> applied.</p>\n</blockquote>\n<p>The problem with these wordings was <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#712\" rel=\"nofollow noreferrer\">DR 712</a>. Consider this example:</p>\n<pre><code>struct S {\n  static const int a = 1;\n  static const int b = 2;\n};\nint f(bool x) {\n  return x ? S::a : S::b;\n}\n</code></pre>\n<p>Since <code>S::a</code> and <code>S::b</code> are lvalues the conditional expression <code>x ? S::a : S::b</code> is also an lvalue. This means that the lvalue-to-rvalue conversion is <strong>not immediately</strong> applied to <code>S::a</code> and <code>S::b</code>, but to the result of the conditional expression. This means that by the wording of C++11, these static data members are odr-used and a definition is required. But actually only the values are used, hence it is not neccessary to define the static data members - a declaration would suffices. The new wording of draft C++14 solves this.</p>\n<h2>Does the new wording resolve all issues?</h2>\n<p>No. In the following example the variable <code>S::a</code> is still odr-used:</p>\n<pre><code>struct S { static constexpr int a[2] = {0, 1}; };\nvoid f() {\n    auto x = S::a[0];\n}\n</code></pre>\n<p>Hence I submitted a new <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1926\" rel=\"nofollow noreferrer\">issue</a> to add the following bullet to \u00a73.2/2:</p>\n<blockquote id=\"so_23491781_23655125_7\">\n<ul>\n<li>if <code>e</code> is a glvalue subscripting expression (5.2.1) of the form <code>E1[E2]</code>, the set contains the potential results of <code>E1</code>.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "1770418", "LastEditorUserId": "3980929", "LastEditDate": "2017-07-10T19:42:17.870", "Id": "23655125", "Score": "20", "CreationDate": "2014-05-14T12:44:26.810", "LastActivityDate": "2017-07-10T19:42:17.870"}, "bq_ids": {"n4140": {"so_23491781_23655125_2": {"section_id": 7039, "quality": 0.7777777777777778, "length": 7}, "so_23491781_23655125_7": {"section_id": 7039, "quality": 0.6, "length": 6}, "so_23491781_23655125_5": {"section_id": 7040, "quality": 0.9375, "length": 30}, "so_23491781_23491781_0": {"section_id": 7040, "quality": 0.9375, "length": 30}, "so_23491781_23655125_1": {"section_id": 7039, "quality": 0.8, "length": 12}, "so_23491781_23655125_3": {"section_id": 7039, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_23491781_23655125_1": {"section_id": 6785, "quality": 0.5333333333333333, "length": 8}, "so_23491781_23655125_6": {"section_id": 6785, "quality": 0.8846153846153846, "length": 23}}, "n4659": {"so_23491781_23655125_2": {"section_id": 8536, "quality": 0.7777777777777778, "length": 7}, "so_23491781_23655125_7": {"section_id": 8536, "quality": 0.7, "length": 7}, "so_23491781_23655125_5": {"section_id": 8537, "quality": 0.9375, "length": 30}, "so_23491781_23491781_0": {"section_id": 8537, "quality": 0.9375, "length": 30}, "so_23491781_23655125_3": {"section_id": 8536, "quality": 0.9230769230769231, "length": 12}, "so_23491781_23655125_1": {"section_id": 8536, "quality": 0.8, "length": 12}}}});