post_cb({"2747141": {"Id": "2747141", "PostTypeId": "2", "Body": "<p>MSDN says that the  header defines has_default_constructor and such traits.</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/bb982179.aspx\" rel=\"nofollow noreferrer\">http://msdn.microsoft.com/en-us/library/bb982179.aspx</a></p>\n", "LastActivityDate": "2010-04-30T19:33:58.327", "CommentCount": "2", "CreationDate": "2010-04-30T19:33:58.327", "ParentId": "2733377", "Score": "0", "OwnerUserId": "298661"}, "7834757": {"Id": "7834757", "PostTypeId": "2", "Body": "<p>You may want to check this code example taken from <strong>libstdc++ in Gcc 4.6.1</strong> and which I slightly modified to work with <strong>MSVC 2010</strong> :</p>\n<p><strong>/!\\ : is_default_constructible returns true even if the default constructor is private or protected, i still can't find a way to solve this, any idea ?) :</strong></p>\n<pre><code>namespace std {\n\nnamespace detail {\n\ntemplate&lt;typename _B1, typename _B2&gt;\nstruct __and_\n  : public conditional&lt;_B1::value, _B2, _B1&gt;::type\n{ };\n\ntemplate&lt;typename _Pp&gt;\nstruct __not_\n  : public integral_constant&lt;bool, !_Pp::value&gt;\n{ };\n\n\ntemplate&lt;typename _Tp&gt;\nstruct __is_array_known_bounds\n  : public integral_constant&lt;bool, (extent&lt;_Tp&gt;::value &gt; 0)&gt;\n{ };\n\ntemplate&lt;typename _Tp&gt;\nstruct __is_array_unknown_bounds\n  : public __and_&lt;is_array&lt;_Tp&gt;, __not_&lt;extent&lt;_Tp&gt;&gt;&gt;::type\n{ };\n\nstruct __do_is_default_constructible_impl\n{\n\n  template&lt;typename _Tp&gt;\n  static true_type __test(int,decltype(_Tp())* a = 0);\n\n  template&lt;typename&gt;\n  static false_type __test(...);\n};\n\ntemplate&lt;typename _Tp&gt;\n  struct __is_default_constructible_impl\n  : public __do_is_default_constructible_impl\n  {\n    typedef decltype(__test&lt;_Tp&gt;(0)) type;\n  };\n\ntemplate&lt;typename _Tp&gt;\n  struct __is_default_constructible_atom\n  : public __and_&lt;__not_&lt;is_void&lt;_Tp&gt;&gt;,\n                  __is_default_constructible_impl&lt;_Tp&gt;&gt;::type\n  { };\n\ntemplate&lt;typename _Tp, bool = is_array&lt;_Tp&gt;::value&gt;\n  struct __is_default_constructible_safe;\n\n// The following technique is a workaround for a current core language\n// restriction, which does not allow for array types to occur in \n// functional casts of the form T().  Complete arrays can be default-\n// constructed, if the element type is default-constructible, but \n// arrays with unknown bounds are not.\ntemplate&lt;typename _Tp&gt;\n  struct __is_default_constructible_safe&lt;_Tp, true&gt;\n  : public __and_&lt;__is_array_known_bounds&lt;_Tp&gt;,\n          __is_default_constructible_atom&lt;typename\n                    remove_all_extents&lt;_Tp&gt;::type&gt;&gt;::type\n  { };\n\ntemplate&lt;typename _Tp&gt;\n  struct __is_default_constructible_safe&lt;_Tp, false&gt;\n  : public __is_default_constructible_atom&lt;_Tp&gt;::type\n  { };\n} // namespace detail\n/// is_default_constructible\ntemplate&lt;typename _Tp&gt;\n  struct is_default_constructible\n: public integral_constant&lt;bool, (detail::__is_default_constructible_safe&lt;\n                _Tp&gt;::value)&gt;\n{ };\n\n}\n</code></pre>\n<p><strong>use :</strong> </p>\n<pre><code>class DefaultConstructible\n{\npublic:\n  DefaultConstructible() {}\n};\n\nclass NotDefaultConstructible\n{\npublic:\n  NotDefaultConstructible(int i) {}\n};\n\nstd::is_default_constructible&lt;DefaultConstructible&gt;::value // -&gt; true\nstd::is_default_constructible&lt;NotDefaultConstructible&gt;::value // -&gt; false\n</code></pre>\n", "LastActivityDate": "2011-10-20T10:43:25.433", "CommentCount": "0", "CreationDate": "2011-10-20T10:43:25.433", "ParentId": "2733377", "Score": "0", "OwnerUserId": "809199"}, "2742729": {"Id": "2742729", "PostTypeId": "2", "Body": "<p>Sorry for answering may own question.</p>\n<p>Googling I have found that the actual reason we can not check if a class has constructor or a destructors is that, the known technique used to detect if a class has a member is based on taking the address of the member. But constructors and destructors have no name, we can not take the address of them.</p>\n<p>If we can not take the address, I don't see a way to make the compiler react to a construction without instantiating it directly, but in this case there is no detection at compile time but an error.</p>\n<p>So to answer my own question, I would say that with the current techniques it is not possible to detect them and compiler support is needed. But C++ has revealed a lot of surprises, and things that were not possible at a given time, were revealed are possible using another technique.</p>\n<p>I hope a C++ language expert is reading that and can give a more clear explanation.</p>\n", "LastActivityDate": "2010-04-30T06:35:04.737", "CommentCount": "3", "CreationDate": "2010-04-30T06:35:04.737", "ParentId": "2733377", "Score": "4", "OwnerUserId": "320757"}, "25238472": {"Id": "25238472", "PostTypeId": "2", "Body": "<p>After shedding much blood, sweat, and tears, I finally found a way that works on every compiler I tried:</p>\n<pre><code>template&lt;class T = void&gt; struct is_default_constructible;\n\ntemplate&lt;&gt; struct is_default_constructible&lt;void&gt;\n{\nprotected:\n    // Put base typedefs here to avoid pollution\n    struct twoc { char a, b; };\n    template&lt;bool&gt; struct test { typedef char type; };\npublic:\n    static bool const value = false;\n};\ntemplate&lt;&gt; struct is_default_constructible&lt;&gt;::test&lt;true&gt; { typedef twoc type; };\n\ntemplate&lt;class T&gt; struct is_default_constructible : is_default_constructible&lt;&gt;\n{\nprivate:\n    template&lt;class U&gt; static typename test&lt;!!sizeof(::new U())&gt;::type sfinae(U*);\n    template&lt;class U&gt; static char sfinae(...);\npublic:\n    static bool const value = sizeof(sfinae&lt;T&gt;(0)) &gt; 1;\n};\n</code></pre>\n", "LastEditorUserId": "541686", "LastActivityDate": "2014-08-12T11:27:02.487", "Score": "-1", "CreationDate": "2014-08-11T08:06:09.023", "ParentId": "2733377", "CommentCount": "1", "OwnerUserId": "541686", "LastEditDate": "2014-08-12T11:27:02.487"}, "bq_ids": {"n4140": {"so_2733377_2770326_0": {"length": 69, "quality": 0.8214285714285714, "section_id": 300}}, "n3337": {"so_2733377_2770326_0": {"length": 69, "quality": 0.8214285714285714, "section_id": 291}}, "n4659": {"so_2733377_2770326_0": {"length": 65, "quality": 0.7738095238095238, "section_id": 307}}}, "5054629": {"Id": "5054629", "PostTypeId": "2", "Body": "<p>A modification of Potatoswatter's answer</p>\n<p>Works on gcc-4.6</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt; class T &gt;\nstruct identity {\ntypedef T type;\n};\n\ntemplate&lt;bool, typename T, typename F&gt;\nstruct if_c : identity&lt;F&gt; {};\n\ntemplate&lt; typename T, typename F&gt;\nstruct if_c&lt;true,T,F&gt; : identity&lt;T&gt; {};\n\ntemplate&lt;typename Bool, typename T, typename F&gt;\nstruct if_ : if_c&lt; Bool::value, T, F&gt; {};\n\ntemplate&lt; class T &gt;\nstruct is_default_constructible_;\n\ntemplate&lt; class T &gt;\nstruct is_default_constructible :\n  if_&lt; std::is_arithmetic&lt;T&gt;,\n    std::true_type,\n    is_default_constructible_&lt;T&gt; &gt;::type { };\n\n\ntemplate&lt; class T &gt;\nstruct is_default_constructible_ {\n\n    template&lt;class D&gt; class Acessible : public D\n    {\n      friend class is_default_constructible_&lt;D&gt;;\n      public:\n      //using D::D; may be needed once N2540 is implemented \n    };\n\n    template&lt;int x&gt;\n    class receive_size{};\n\n    template&lt; class U &gt;\n    static int sfinae( receive_size&lt; sizeof Acessible&lt;U&gt;() &gt; * );\n\n    template&lt; class U &gt;\n    static char sfinae( ... );\n\npublic:\n    enum { value = sizeof( sfinae&lt;T&gt;(0) ) == sizeof(int) };\n\n};\n\nstruct p { p(); };\nclass q { q(); };\nclass r { r(int); };\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cerr &lt;&lt; is_default_constructible&lt;int&gt;::value &lt;&lt; endl // outputs 1\n        &lt;&lt; is_default_constructible&lt;p&gt;::value &lt;&lt; endl\n        &lt;&lt; is_default_constructible&lt;q&gt;::value &lt;&lt; endl\n        &lt;&lt; is_default_constructible&lt;r&gt;::value &lt;&lt; endl; // outputs 0\n}\n</code></pre>\n<blockquote>\n<p id=\"so_2733377_5054629_0\"># g++-mp-4.6 --std=c++0x -Wall test.cpp &amp;&amp; ./a.out<br>\n  1<br>\n  1<br>\n  0<br>\n  0  </br></br></br></br></p>\n</blockquote>\n", "LastActivityDate": "2011-02-20T01:06:37.020", "CommentCount": "1", "CreationDate": "2011-02-20T01:06:37.020", "ParentId": "2733377", "Score": "2", "OwnerUserId": "86515"}, "2770326": {"Id": "2770326", "PostTypeId": "2", "Body": "<p><strong>Warning:</strong> some analysis below is obsolete as of C++11. In C++11, access checking <em>is</em> done prior to instantiation and access violation is-not-an-error. Therefore the attached code may be more compliant. I haven't re-analyzed it.</p>\n<hr>\n<p>I'm pretty new to SFINAE. Today it occurred to me to put a test expression inside a <code>sizeof</code> inside a template parameter in a function argument type.</p>\n<p>According to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html\" rel=\"nofollow noreferrer\">N2634</a> this is not wrong, but highly unportable. (<strong>EDIT:</strong> appears to be compliant to C++0x FCD.) It can only return positive or fail to compile in GCC 4.2; GCC 4.5 scores a 3 out of 3 for my test cases.</p>\n<p>The SFINAE rules were broadened (in this case) since C++03 in the FCD. New \u00a714.8.2/8 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_2733377_2770326_0\">If a substitution results in an invalid type <strong>or expression,</strong> type deduction fails. An invalid type <strong>or expression</strong> is one that would be ill-formed if written using the substituted arguments. <strong>Access checking is not done as part of the substitution process.</strong> Consequently, when deduction succeeds, an access error could still result when the function is instantiated. Only invalid types and expressions in the immediate context of the function type and its template parameter types can result in a deduction failure. [ Note: The evaluation of the substituted types and expressions can result in side effects such as the instantiation of class template specializations and/or function template specializations, the generation of implicitly-defined functions, etc. Such side effects are not in the \u201cimmediate context\u201d and can result in the program being ill-formed.</p>\n</blockquote>\n<pre><code>template&lt; class T &gt;\nclass is_default_constructible {\n    template&lt;int x&gt;\n    class receive_size{};\n\n    template&lt; class U &gt;\n    static int sfinae( receive_size&lt; sizeof U() &gt; * );\n\n    template&lt; class U &gt;\n    static char sfinae( ... );\n\npublic:\n    enum { value = sizeof( sfinae&lt;T&gt;(0) ) == sizeof(int) };\n};\n\nclass q { q(); };\nclass r { r(int); };\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cerr &lt;&lt; is_default_constructible&lt;int&gt;::value &lt;&lt; endl // outputs 1\n        // fails to compile: access violation\n        // FCD demands that access violations be unrecoverable\n        // indeed, it's murky: q is default-constructible, but only \"rarely\"\n        //&lt;&lt; is_default_constructible&lt;q&gt;::value &lt;&lt; endl\n        &lt;&lt; is_default_constructible&lt;r&gt;::value &lt;&lt; endl; // outputs 0\n}\n</code></pre>\n</hr>", "LastEditorUserId": "153285", "LastActivityDate": "2012-09-28T09:07:46.603", "Score": "2", "CreationDate": "2010-05-05T02:51:56.050", "ParentId": "2733377", "CommentCount": "3", "OwnerUserId": "153285", "LastEditDate": "2012-09-28T09:07:46.603"}, "2751256": {"Id": "2751256", "PostTypeId": "2", "Body": "<p>Concept Traits is no more maintained, but become part of Type Traits. And in docs of <a href=\"http://www.boost.org/doc/libs/1_42_0/libs/type_traits/doc/html/boost_typetraits/reference/has_trivial_constructor.html\" rel=\"nofollow noreferrer\">has_trivial_constructor</a> and <a href=\"http://www.boost.org/doc/libs/1_42_0/libs/type_traits/doc/html/boost_typetraits/reference/has_trivial_destructor.html\" rel=\"nofollow noreferrer\">has_trivial_destructor</a>, Boost authors explain clearly that compiler support is required to make this work.</p>\n", "LastActivityDate": "2010-05-01T19:11:41.810", "CommentCount": "3", "CreationDate": "2010-05-01T19:11:41.810", "ParentId": "2733377", "Score": "2", "OwnerUserId": "53974"}, "2733377": {"ViewCount": "5599", "Body": "<p>Traits classes can be defined to check if a C++ class has a member variable, function or a type (see <a href=\"https://stackoverflow.com/questions/1005476/how-to-detect-whether-there-is-a-specific-member-variable-in-class/2694110#2694110\">here</a>).</p>\n<p>Curiously, the <a href=\"https://svn.boost.org/trac/boost/wiki/LibrariesUnderConstruction#Boost.ConceptTraits\" rel=\"nofollow noreferrer\">ConceptTraits</a> do not include traits to check if a C++ class defines a default constructor or given constructor? </p>\n<p>Can traits be used to check the constructor presence? \nIf yes, how? \nIf not, why it is not possible?</p>\n", "AcceptedAnswerId": "2742729", "Title": "Is there a way to test whether a C++ class has a default constructor (other than compiler-provided type traits)?", "CreationDate": "2010-04-28T21:53:13.257", "Id": "2733377", "CommentCount": "4", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:00:17.880", "LastEditorUserId": "-1", "LastActivityDate": "2014-08-12T11:27:02.487", "Score": "21", "OwnerUserId": "320757", "Tags": "<c++><boost>", "AnswerCount": "7"}});