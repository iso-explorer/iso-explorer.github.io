post_cb({"47655754": {"Id": "47655754", "PostTypeId": "2", "Body": "<p>Access through <code>a</code> is legal while <code>b</code> is not. From <a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.compound#4\" rel=\"nofollow noreferrer\">[basic.compound]</a></p>\n<blockquote>\n<p id=\"so_47653305_47655754_0\">Two objects <code>a</code> and <code>b</code> are pointer-interconvertible if:</p>\n<ul>\n<li><p id=\"so_47653305_47655754_1\">they are the same object, or</p></li>\n<li><p id=\"so_47653305_47655754_2\">one is a standard-layout union object and the other is a non-static data member of that object, or</p></li>\n<li><p id=\"so_47653305_47655754_3\">one is a standard-layout class object and the other is the first non-static data member of that object, or, if the object has no non-static data members, the first base class subobject of that object ([class.mem]), or</p></li>\n<li><p id=\"so_47653305_47655754_4\">there exists an object <code>c</code> such that <code>a</code> and <code>c</code> are pointer-interconvertible, and <code>c</code> and <code>b</code> are pointer-interconvertible.</p></li>\n</ul>\n<p id=\"so_47653305_47655754_5\">If two objects are pointer-interconvertible, then they have the same address, and it is possible to obtain a pointer to one from a pointer to the other via a <code>reinterpret_\u00adcast</code>. [\u2009Note: An array object and its first element are not pointer-interconvertible, even though they have the same address. \u2009\u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>They are not the same object, not unions and not subobjects to each other, therefore not pointer-interconvertible. </p>\n<p>Note <a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr.reinterpret.cast#7\" rel=\"nofollow noreferrer\">[expr.reinterpret.cast]</a> only guarantees <code>reinterpret_cast&lt;char*&gt;(b) == buffer</code>.</p>\n<blockquote>\n<p id=\"so_47653305_47655754_6\">An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue <code>v</code>of object pointer type is converted to the object pointer type \u201cpointer to <code>cv T</code>\u201d, the result is <code>static_\u00adcast&lt;cv T*&gt;(static_\u00adcast&lt;cv void*&gt;(v))</code>. [\u2009Note: Converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value. \u2009\u2014\u2009end note\u2009]</p>\n</blockquote>\n", "LastEditorUserId": "4832499", "LastActivityDate": "2017-12-05T16:55:46.687", "Score": "2", "CreationDate": "2017-12-05T14:16:50.670", "ParentId": "47653305", "CommentCount": "0", "OwnerUserId": "4832499", "LastEditDate": "2017-12-05T16:55:46.687"}, "bq_ids": {"n4140": {"so_47653305_47655754_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 5913}, "so_47653305_47655754_6": {"length": 44, "quality": 0.88, "section_id": 6046}, "so_47653305_47655754_3": {"length": 12, "quality": 0.6, "section_id": 5879}, "so_47653305_48164192_3": {"length": 14, "quality": 0.875, "section_id": 6039}, "so_47653305_48164192_2": {"length": 21, "quality": 1.0, "section_id": 6039}, "so_47653305_48164192_0": {"length": 7, "quality": 0.875, "section_id": 6082}}, "n3337": {"so_47653305_48164192_3": {"length": 10, "quality": 0.625, "section_id": 6967}, "so_47653305_47655754_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 5685}, "so_47653305_47655754_6": {"length": 40, "quality": 0.8, "section_id": 5814}, "so_47653305_48164192_2": {"length": 21, "quality": 1.0, "section_id": 5807}, "so_47653305_48164192_0": {"length": 7, "quality": 0.875, "section_id": 5850}}, "n4659": {"so_47653305_48164192_4": {"length": 14, "quality": 1.0, "section_id": 7538}, "so_47653305_47655754_2": {"length": 9, "quality": 1.0, "section_id": 8733}, "so_47653305_47655754_6": {"length": 43, "quality": 0.86, "section_id": 7545}, "so_47653305_48164192_0": {"length": 7, "quality": 0.875, "section_id": 7578}, "so_47653305_48164192_1": {"length": 4, "quality": 0.8, "section_id": 40}, "so_47653305_47655754_5": {"length": 28, "quality": 0.9032258064516129, "section_id": 8733}, "so_47653305_47655754_4": {"length": 6, "quality": 1.0, "section_id": 8733}, "so_47653305_47655754_3": {"length": 19, "quality": 0.95, "section_id": 8733}, "so_47653305_48164192_3": {"length": 16, "quality": 1.0, "section_id": 7538}, "so_47653305_48164192_2": {"length": 21, "quality": 1.0, "section_id": 7538}, "so_47653305_48164192_5": {"length": 5, "quality": 1.0, "section_id": 7538}}}, "48164192": {"Id": "48164192", "PostTypeId": "2", "Body": "<p>Only <code>a</code> can safely be used to directly access the <code>Foo</code> object created by the placement <em>new-expression</em> (which we'll call <code>x</code> for ease of reference). Using <code>b</code> requires <code>std::launder</code>.</p>\n<p>The value of <code>a</code> is specified in <a href=\"https://timsong-cpp.github.io/cppwp/expr.new#1.sentence-7\" rel=\"nofollow noreferrer\">[expr.new]/1</a>:</p>\n<blockquote>\n<p id=\"so_47653305_48164192_0\">If the entity is a non-array object, the result of the <em>new-expression</em>\n  is a pointer to the object created.</p>\n</blockquote>\n<p>The value of <code>a</code> is therefore \"pointer to <code>x</code>\". This pointer, of course, can safely be used to access <code>x</code>.</p>\n<p><code>reinterpret_cast&lt;Foo*&gt;(buffer)</code> applies the array-to-pointer conversion to <code>buffer</code> (see <a href=\"https://timsong-cpp.github.io/cppwp/expr.reinterpret.cast#1.sentence-2\" rel=\"nofollow noreferrer\">[expr.reinterpret.cast]/1</a>). The resulting value after the conversion is applied is \"pointer to the first element of <code>buffer</code>\". \nThis is a <code>reinterpret_cast</code> of an object pointer to an object pointer of a different type, and is defined as equivalent to <code>static_cast&lt;Foo*&gt;(static_cast&lt;void*&gt;(buffer))</code> by <a href=\"https://timsong-cpp.github.io/cppwp/expr.reinterpret.cast#7.sentence-2\" rel=\"nofollow noreferrer\">[expr.reinterpret.cast]/7</a>.</p>\n<p>The inner cast to <code>void*</code> is actually an implicit conversion. Per <a href=\"https://timsong-cpp.github.io/cppwp/conv.ptr#2\" rel=\"nofollow noreferrer\">[conv.ptr]/2</a>,</p>\n<blockquote>\n<p id=\"so_47653305_48164192_1\">The pointer value is unchanged by this conversion.</p>\n</blockquote>\n<p>Therefore the inner cast yields a <code>void*</code> with the value \"pointer to the first element of <code>buffer</code>\".</p>\n<p>The outer cast is governed by <a href=\"https://timsong-cpp.github.io/cppwp/expr.static.cast#13\" rel=\"nofollow noreferrer\">[expr.static.cast]/13</a>, which I've lightly reformatted into bullet points:</p>\n<blockquote>\n<p id=\"so_47653305_48164192_2\">A prvalue of type \u201cpointer to <em>cv1</em> <code>void</code>\u201d can be converted to a prvalue of type \u201cpointer to <em>cv2</em> <code>T</code>\u201d, where <code>T</code> is an object type and <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>. </p>\n<ul>\n<li><p id=\"so_47653305_48164192_3\">If the original pointer value represents the address <code>A</code> of a byte in memory and <code>A</code> does not satisfy the alignment requirement of <code>T</code>,\n  then the resulting pointer value is unspecified.</p></li>\n<li><p id=\"so_47653305_48164192_4\">Otherwise, if the original pointer value points to an object <code>a</code>, and there is an object <code>b</code> of type <code>T</code> (ignoring cv-qualification)\n  that is pointer-interconvertible with <code>a</code>, the result is a pointer to\n  <code>b</code>. </p></li>\n<li><p id=\"so_47653305_48164192_5\">Otherwise, the pointer value is unchanged by the conversion.</p></li>\n</ul>\n</blockquote>\n<p>Assuming that <code>buffer</code> is suitably aligned (you'd be in trouble well before this point if it's not), the first bullet is inapplicable. The second bullet is likewise inapplicable as there's no <a href=\"https://timsong-cpp.github.io/cppwp/basic.compound#4\" rel=\"nofollow noreferrer\">pointer-interconvertiblity</a> here. It follows that we hit the third bullet - \"the pointer value is unchanged by the conversion\" and remains \"pointer to the first element of <code>buffer</code>\".</p>\n<p>Thus, <code>b</code> does not point to the <code>Foo</code> object <code>x</code>; it points instead to the first <code>char</code> element of <code>buffer</code>, even though its type is <code>Foo*</code>. It therefore cannot be used to access <code>x</code>; attempting to do so yields undefined behavior (for the non-static data member case, by omission from <a href=\"https://timsong-cpp.github.io/cppwp/expr.ref#4.2\" rel=\"nofollow noreferrer\">[expr.ref]</a>; for the non-static member function case, by <a href=\"https://timsong-cpp.github.io/cppwp/class.mfct.non-static#2\" rel=\"nofollow noreferrer\">[class.mfct.non-static]/2</a>). </p>\n<p>To recover a pointer to <code>x</code> from <code>b</code>, <code>std::launder</code> can be used:</p>\n<pre><code>b = std::launder(b); // value of b is now \"pointer to x\"\n                     // and can be used to access x\n</code></pre>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2018-01-12T21:52:02.633", "Score": "6", "CreationDate": "2018-01-09T08:38:06.063", "ParentId": "47653305", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2018-01-12T21:52:02.633"}, "47653305": {"ViewCount": "184", "Body": "<p>Is there a (semantic) difference between the return value of placement new and the casted value of its operand?</p>\n<pre><code>struct Foo { ... };\nchar buffer[...];\n\nFoo *a = new(buffer) Foo;\nFoo *b = reinterpret_cast&lt;Foo *&gt;(buffer);\n</code></pre>\n<p>Does <code>a</code> and <code>b</code> differ in some way?</p>\n<hr>\n<p>EDIT: Based on DaBler's comment, this question tells that there is a difference, if const/reference members used: <a href=\"https://stackoverflow.com/questions/47473621/placement-new-and-assignment-of-class-with-const-member\">Placement new and assignment of class with const member</a></p>\n<p>So, my little-bit updated question: Does <code>a</code> and <code>b</code> differ in any way, if <code>Foo</code> doesn't have const or reference members?</p>\n</hr>", "Title": "Is there a (semantic) difference between the return value of placement new and the casted value of its operand?", "CreationDate": "2017-12-05T12:09:43.300", "LastActivityDate": "2018-01-12T21:52:02.633", "CommentCount": "3", "LastEditDate": "2018-01-09T14:33:49.727", "PostTypeId": "1", "LastEditorUserId": "2684539", "Id": "47653305", "Score": "9", "OwnerUserId": "8157187", "Tags": "<c++><language-lawyer><placement-new>", "AnswerCount": "2"}});