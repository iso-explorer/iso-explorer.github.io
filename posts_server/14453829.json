post_cb({"14454305": {"ParentId": "14453829", "CommentCount": "8", "Body": "<p>Your reasoning is correct when these two types are competing in a partial ordering of class template partial specializations, and it is how things work there.</p>\n<p>But when a reference type is compared against a nonreference type, the general gist is that they are ambiguous in a call scenario if nothing else makes one be preferred over the other. That is, the kind of reference of the reference type doesn't matter in overload resolution when compared against the other, so partial ordering doesnt consider it either. </p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "14454305", "Score": "4", "CreationDate": "2013-01-22T08:26:00.477", "LastActivityDate": "2013-01-22T08:26:00.477"}, "14453829": {"CommentCount": "1", "AcceptedAnswerId": "14454256", "CreationDate": "2013-01-22T07:48:25.950", "LastActivityDate": "2013-01-22T09:06:13.653", "PostTypeId": "1", "ViewCount": "165", "FavoriteCount": "1", "Title": "partial ordering with L-value-ref", "Id": "14453829", "Score": "6", "Body": "<p>Why this is ambiguous?</p>\n<pre><code>template&lt;class T&gt; void g(T)  {}   // 1\ntemplate&lt;class T&gt; void g(T&amp;) {}   // 2\n\nint main() {\n    int  q;\n    g(q);\n}\n</code></pre>\n<p>I understand that this is partial ordering context. And my, possibly erroneous, thinking is: any T&amp; from #2 can be put in #1, but not any T from #1 is legit in #2.  So partial ordering should work.</p>\n", "Tags": "<c++><templates><function-overriding><partial-ordering>", "OwnerUserId": "1173542", "AnswerCount": "2"}, "14454256": {"ParentId": "14453829", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>OK. I <em>think</em> this is what you're looking for. Not diving into the twice-application of the parameter vs. argument type comparison, the following in the standard leaps out at me:</p>\n<blockquote>\n<p id=\"so_14453829_14454256_0\"><strong>C++11 \u00a714.8.2.4p5</strong></p>\n<p id=\"so_14453829_14454256_1\">Before the partial ordering is done, certain transformations are performed on the types used for partial ordering:</p>\n<ul>\n<li>If P is a reference type, P is replaced by the type referred to.</li>\n<li>If A is a reference type, A is replaced by the type referred to.</li>\n</ul>\n</blockquote>\n<p>C++11 \u00a714.8.2.4p6 goes on to talk about what happens when <em>both</em> are reference types, but that isn't applicable here (though also an interesting read). in your case, only one is, so it is stripped. From there:</p>\n<blockquote>\n<p id=\"so_14453829_14454256_2\"><strong>C++11 \u00a714.8.2.4p7</strong></p>\n<p id=\"so_14453829_14454256_3\">Remove any top-level cv-qualifiers:</p>\n<ul>\n<li>If P is a cv-qualified type, P is replaced by the cv-unqualified version of P.</li>\n<li>If A is a cv-qualified type, A is replaced by the cv-unqualified version of A.</li>\n</ul>\n</blockquote>\n<p>Now both are completely equal, and thus you have your ambiguity, which I believe is solidified from C++11 \u00a714.8.2.4p10. The text of C++11 \u00a714.8.2.4p9 covers both being reference types which, again, is not the case here:</p>\n<blockquote>\n<p id=\"so_14453829_14454256_4\"><strong>C++11 \u00a714.8.2.4p10</strong></p>\n<p id=\"so_14453829_14454256_5\">If for each type being considered a given template is at least as specialized for all types and more specialized for some set of types and the other template is not more specialized for any types or is not at least as specialized for any types, then the given template is more specialized than the other template. <strong>Otherwise, neither template is more specialized than the other.</strong></p>\n</blockquote>\n<p>But reading the standard in this section is like deciphering greek to me, so I may be <em>way</em> off base. (no offense to the Greeks =P). </p>\n<p>It did, however, make me think \"a <code>const T&amp;</code> against a <code>T</code>, given the same invoke condition <code>g(q)</code>, should also be ambiguous if everything I just read is enforced as-written.\" Sure enough, I tried it, and the same ambiguity was flagged.</p>\n", "OwnerUserId": "1322972", "LastEditorUserId": "1322972", "LastEditDate": "2013-01-22T09:06:13.653", "Id": "14454256", "Score": "7", "CreationDate": "2013-01-22T08:22:54.783", "LastActivityDate": "2013-01-22T09:06:13.653"}, "bq_ids": {"n4140": {"so_14453829_14454256_5": {"section_id": 329, "quality": 1.0, "length": 37}, "so_14453829_14454256_1": {"section_id": 324, "quality": 1.0, "length": 10}}, "n3337": {"so_14453829_14454256_5": {"section_id": 319, "quality": 1.0, "length": 37}, "so_14453829_14454256_1": {"section_id": 314, "quality": 1.0, "length": 10}}, "n4659": {"so_14453829_14454256_1": {"section_id": 332, "quality": 1.0, "length": 10}}}});