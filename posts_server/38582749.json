post_cb({"38582749": {"ViewCount": "200", "Body": "<p>I am interrested wheather standard says anything about possible values of <code>bool</code> type type after casting it to <code>integer</code> type.</p>\n<p>For example following code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    bool someValue=false;\n    *((int*)(&amp;someValue)) = 50;\n\n    cout &lt;&lt; someValue &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>prints 1 even though it's forced to store value 50. Does standard specify anything about it? Or is compiler generating some method for type bool as:</p>\n<pre><code>operator int(){\n    return myValue !=0 ? 1 : 0;\n}\n</code></pre>\n<p>Also why is casting like following:</p>\n<pre><code>reinterpret_cast&lt;int&gt;(someValue) = 50;\n</code></pre>\n<p>forbidden with error </p>\n<blockquote>\n<p id=\"so_38582749_38582749_0\">error: invalid cast from type 'bool' to type 'int'</p>\n</blockquote>\n<p>(For all above I user GCC 5.1 compiler.)</p>\n", "AcceptedAnswerId": "38583310", "Title": "C++ casting bool to int - standard", "CreationDate": "2016-07-26T06:44:10.657", "Id": "38582749", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2016-07-26T07:24:08.840", "Score": "0", "OwnerUserId": "4764736", "Tags": "<c++><casting><boolean>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_38582749_38583542_1": {"length": 14, "quality": 1.0, "section_id": 26}, "so_38582749_38582749_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 21}}, "n3337": {"so_38582749_38583542_1": {"length": 14, "quality": 1.0, "section_id": 23}, "so_38582749_38582749_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 18}}, "n4659": {"so_38582749_38583542_1": {"length": 14, "quality": 1.0, "section_id": 26}, "so_38582749_38582749_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 21}}}, "38583310": {"Id": "38583310", "PostTypeId": "2", "Body": "<p>The way you are using it exhibits UB, because you write outside of the bool variable's boundaries AND you break strict aliasing rule.</p>\n<p>However, if you have a bool and want to use it as a an int (this usually happens when you want to index into an array based on some condition), the standard mandates that a <code>true</code> bool converts into <code>1</code> and <code>false</code> bool converts into <code>0</code>, no matter what (UB obviously excluded).</p>\n<p>For example, this is guaranteed to output <code>52</code> as long as <code>should_add == true</code>.</p>\n<pre><code>int main(){\n    int arr[] = {0, 10};\n    bool should_add = 123;\n    int result = 42 + arr[should_add];\n    std::cout &lt;&lt; result &lt;&lt; '\\n';\n}\n</code></pre>\n", "LastActivityDate": "2016-07-26T07:12:24.540", "CommentCount": "0", "CreationDate": "2016-07-26T07:12:24.540", "ParentId": "38582749", "Score": "3", "OwnerUserId": "3276485"}, "38583542": {"Id": "38583542", "PostTypeId": "2", "Body": "<p>This line <code>*((int*)(&amp;someValue)) = 50;</code> is  at least non standard. The implementation could use a lesser rank for bool (say 1 or 2 bytes) that for int (say 4 bytes). In that case, you would write past the variable possibly erasing an other variable.</p>\n<p>And anyway, as you were said in comment, thanks to the <em>strict aliasing rule</em> almost any access through a casted pointer can be seen as Undefined Behaviour by a compiler. The only almost <em>legal</em> one (for the strict aliasing rule) would be:</p>\n<pre><code>*((char *) &amp;someValue) = 50; \n</code></pre>\n<p>on a little endian system, and</p>\n<pre><code>*(((char *) &amp;someValue) + sizeof(bool) - 1) = 50; \n</code></pre>\n<p>on a big endian one (byte access has still not be forbidden).</p>\n<p>Anyway, as the representation of bool is not specified by the standard directly writing something in a bool can lead to true or false depending on implementation. For example an implementation could considere only the lowest level bit (true if val&amp;1 is 1, else 0), another one could considere all bits (true for any non 0 value, false for only 0). The only thing that standard says is that a <em>conversion</em> of a 0 leads to false and of a non 0 leads to true.</p>\n<hr>\n<p>But was is mandated by standard is the conversion from bool to int:</p>\n<blockquote>\n<p id=\"so_38582749_38583542_0\">4.5 Integral promotions [conv.prom]</p>\n<p id=\"so_38582749_38583542_1\">...<br/>A prvalue of type bool can be converted to a prvalue of type int, with false becoming zero and true\n  becoming one.</p>\n</blockquote>\n<p>So this fully explains that displaying a bool can only give 0 or 1 - even if as the previous operation invoked UB, anything could have happen here including this display </p>\n<pre class=\"lang-none prettyprint-override\"><code>You invoked Undefined Behaviour - shame on you\n</code></pre>\n</hr>", "LastActivityDate": "2016-07-26T07:24:08.840", "CommentCount": "6", "CreationDate": "2016-07-26T07:24:08.840", "ParentId": "38582749", "Score": "2", "OwnerUserId": "3545273"}});