post_cb({"8619391": {"ParentId": "8619356", "CommentCount": "1", "Body": "<p>A common answer might be to provide an \"application\" singleton class, like e.g. <a href=\"http://developer.qt.nokia.com/doc/qt-4.8/QApplication.html\" rel=\"nofollow\">QApplication</a> in Qt, an reduce your <code>main</code> to something like</p>\n<pre><code>int main (int argc, char** argv) {\n    YourApplication app (argc, argv);\n    return app.execute();\n}\n</code></pre>\n<p>Then you reduce your friendness concern to <code>class YourApplication</code> vs your other classes, and you know how to do that.</p>\n", "OwnerUserId": "841108", "PostTypeId": "2", "Id": "8619391", "Score": "0", "CreationDate": "2011-12-23T18:24:02.707", "LastActivityDate": "2011-12-23T18:24:02.707"}, "8620289": {"ParentId": "8619356", "CommentCount": "0", "Body": "<p>@parapura provided a solution, but doesn't explain <em>why</em> you first have to declare <code>main</code> in the global scope.</p>\n<p><code>\u00a77.3.1.2 [namespace.memdef] p3</code></p>\n<blockquote>\n<p id=\"so_8619356_8620289_0\">[...] If a <code>friend</code> declaration in a nonlocal class first declares a class or function the friend class or function is a member of the innermost enclosing namespace. [...]</p>\n</blockquote>\n<p>So with that in mind, your code would look somewhat like this:</p>\n<pre><code>namespace MyNamespace\n{ // MyNamespace is the innermost enclosing namespace\n  // 'main' from the friend declaration is treated\n  // as if it was a member of 'MyNamespace'\n  int main(int argc, char** argv);\n\n  class ProcessManager\n  {\n  public:\n    friend int main(int argc, char** argv);\n  private:\n    void test();\n  };\n};\n</code></pre>\n<p>Now it should be clear why the global <code>main</code> function wasn't your friend.</p>\n", "OwnerUserId": "500104", "PostTypeId": "2", "Id": "8620289", "Score": "2", "CreationDate": "2011-12-23T20:20:15.863", "LastActivityDate": "2011-12-23T20:20:15.863"}, "8619390": {"ParentId": "8619356", "CommentCount": "3", "Body": "<p>Just declare the main outside the <code>MyNamespace</code> and specify global namespace <code>::</code> in friend statement</p>\n<pre><code>//in header file of ProcessManager\n//your pf.h\n\nint main(int argc, char** argv);\n\nnamespace MyNamespace\n{\n  class ProcessManager\n  {\n  public:\n    friend int ::main(int argc, char** argv);\n  private:\n    void test();\n  };\n};\n</code></pre>\n", "OwnerUserId": "764882", "PostTypeId": "2", "Id": "8619390", "Score": "9", "CreationDate": "2011-12-23T18:23:57.730", "LastActivityDate": "2011-12-23T18:23:57.730"}, "8619356": {"CommentCount": "4", "ViewCount": "963", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-12-23T18:18:52.287", "LastActivityDate": "2011-12-23T20:20:15.863", "Title": "How do I make main a friend of my class from within a library?", "AcceptedAnswerId": "8619390", "LastEditDate": "2017-05-23T11:59:28.787", "Id": "8619356", "Score": "8", "Body": "<p>Please see <a href=\"https://stackoverflow.com/questions/8619133/how-do-i-make-main-a-friend-of-my-class\">my first attempt at answering this</a>\n. I neglected to tell the whole story before in an attempt to simplify things. Turns out my example works! Sorry.</p>\n<p>The whole story is that this is a library the contains a class in one file and the main in another file, all linked into my library. The library is providing the basis for a Process Framework, which is why the main is in the library and not the process.</p>\n<p>Below is a stripped down version of what I have.</p>\n<p>pf.hpp</p>\n<pre><code>using namespace std;\n\nnamespace MyNamespace\n{\n  class ProcessManager\n  {\n  public:\n    friend int main(int argc, char** argv);\n  private:\n    void test();\n  };\n};\n</code></pre>\n<p>pf.cpp</p>\n<pre><code>#include \"pf.h\"\n\nnamespace MyNamespace\n{\n  ProcessManager::test()\n  {\n    cout &lt;&lt; \"My friend has accessed my member\" &lt;&lt; endl;\n  }\n};\n</code></pre>\n<p>pfmain.cpp</p>\n<pre><code>#include \"pf.hpp\"\n\nint main(int argc, char** argv)\n{\n   ProcessManager pm;\n\n   pm.test();\n}\n</code></pre>\n<p>Note that this fails on the compilation of the library</p>\n<p>What I have tried is:</p>\n<ul>\n<li>Moving the friend all over the place</li>\n<li>Making the friend reference to main use global scope (e.g. ::main)</li>\n<li>Making friend and main declarations use global scope</li>\n</ul>\n<p>What am I missing?</p>\n<p>Thanks!</p>\n", "Tags": "<c++><main><friend>", "OwnerUserId": "580590", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_8619356_8620289_0": {"section_id": 5485, "quality": 1.0, "length": 15}}, "n3337": {"so_8619356_8620289_0": {"section_id": 5271, "quality": 1.0, "length": 15}}, "n4659": {"so_8619356_8620289_0": {"section_id": 6920, "quality": 1.0, "length": 15}}}, "8619437": {"ParentId": "8619356", "CommentCount": "9", "Body": "<p>I don't think you actually want to do what you are doing.  This really seems like a hack and a design problem.  If you really want to expose the internals of your class in some specialized circumstance, you could make an accessor class which is also defined inside your library.</p>\n<p>Something like this might work (may need appropriate forward declarations, etc. -- this is just a starting point):</p>\n<pre><code>class ProcessManagerAccessor\n{\npublic:\n    ProcessManagerAccessor(ProcessManager &amp; pm) : pm_(pm) { }\n\n    // add public methods to expose internals\n    void test() { pm_.test(); }\n\nprivate:\n    ProcessManager &amp; pm_;\n};\n\nclass ProcessManager\n{\npublic:\n    friend class ProcessManagerAccessor;\n\n    // ...\n};\n\n// ...\n\nProcessManager pm;\nProcessManagerAccessor pma(pm);\npma.test();\n</code></pre>\n", "OwnerUserId": "161201", "PostTypeId": "2", "Id": "8619437", "Score": "0", "CreationDate": "2011-12-23T18:30:03.080", "LastActivityDate": "2011-12-23T18:30:03.080"}});