post_cb({"32413859": {"ParentId": "32413700", "LastEditDate": "2015-09-05T14:19:26.517", "CommentCount": "0", "CreationDate": "2015-09-05T13:56:07.810", "OwnerUserId": "3613500", "LastEditorUserId": "1385661", "PostTypeId": "2", "Id": "32413859", "Score": "3", "Body": "<p>most of the OS will partition your program memory into few parts</p>\n<ul>\n<li>The Stack</li>\n<li>The Heap</li>\n<li>The Data segment</li>\n<li>The BSS segment</li>\n<li>The Code segment</li>\n</ul>\n<p>you already know about the stack and the heap, but what about the others?</p>\n<p><strong>the code segment</strong> keeps all the operations in binary form.<br/></p>\n<p>now it gets interesting:\nlet's see the following code:</p>\n<pre><code>int x;\nclass Y{  static int y;  };\nint main(){\n  printf(\"hello world\");\n  return 0;\n}\n</code></pre>\n<p>where does the program allocates <code>x</code> and <code>y</code>? they are not local or dynamically allocated, so where?</p>\n<p><strong>The Data segment</strong> keeps all the static and global variables, when the program is being loaded, this segments keeps enough bytes to hold all the static and global variables. if the variable is an object, when the program goes up it allocates enough bytes for all the variables, including the objects. before <code>main</code> the program calls each global object constructor, and after the <code>main</code> finishes it call each object destructor in reverse order it called the constructor. </p>\n<p><strong>The BSS segment</strong> is a sub-set of the Data segment which keeps global and static pointers which are null-intitalized.</p>\n<p>So assuming the string literal wasn't optimized away, the program stores it in the data segment. It will live on as long as the program lives. moreover, if it's a string literal, most likely you can even see it inside the exe! open the exe as a text file. some point along the way, you will see the string clearly. </p>\n<p>Now what about \n<code>std::string str = \"hello world\";</code> ?</p>\n<p>This is a funky situation. <code>str</code> itself lives on the stack. The actual inner buffer lives on the heap, but the string literal which used to assign the string lives in the data segment and the code which makes <code>str</code> value turn into <code>hello world</code> lives in the code segment. needless to say, if we were to program in assembly, we would need to build this ecosystem with our own bare-hands.</p>\n", "LastActivityDate": "2015-09-05T14:19:26.517"}, "32413700": {"CommentCount": "2", "ViewCount": "3438", "LastActivityDate": "2015-09-05T23:14:08.797", "Body": "<p>I am aware that the following code will create an array of characters and remain in memory until the program ends:</p>\n<pre><code>char* str = \"this is a string\";\n</code></pre>\n<p>As for this statement, creates a local array of characters and will be freed when str goes out of scope:</p>\n<pre><code>char str[] = \"this is a string\";\n</code></pre>\n<p>What I'm curious is, what happens when I write it like this:</p>\n<pre><code>std::string str = \"this is a string\";\n</code></pre>\n<p>str should make a copy of the string in it's own memory (local), but what about the string literal itself? Will it have the lifetime of the program or will it be freed when str goes out of scope?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "32413774", "FavoriteCount": "2", "Title": "Assigning a string literal to std::string", "Id": "32413700", "Score": "7", "CreationDate": "2015-09-05T13:38:28.793", "Tags": "<c++><string><const>", "OwnerUserId": "4980643", "AnswerCount": "4"}, "32413774": {"ParentId": "32413700", "LastEditDate": "2015-09-05T23:14:08.797", "CommentCount": "2", "CreationDate": "2015-09-05T13:45:59.037", "OwnerUserId": "335858", "LastEditorUserId": "335858", "PostTypeId": "2", "Id": "32413774", "Score": "6", "Body": "<p>When you write this</p>\n<pre><code>std::string str = \"this is a string\";\n</code></pre>\n<p>C++ should find a constructor of <code>std::string</code> that takes <code>const char*</code>, calls it to make a temporary object, invokes the copy constructor to copy that temporary into <code>str</code>, and then destroys the temporary object.</p>\n<p>However, there is an optimization that allows C++ compiler to skip construction and destruction of the temporary object, so the result is the same as</p>\n<pre><code>std::string str(\"this is a string\");\n</code></pre>\n<blockquote>\n<p id=\"so_32413700_32413774_0\">but what about the string literal itself? Will it have the lifetime of the program or will it be freed when str goes out of scope?</p>\n</blockquote>\n<p>String literal itself when used in this way is not accessible to your program. Typically, C++ places it in the same segment as other string literals, uses it to pass to the constructor of <code>std::string</code>, and forgets about it. The optimizer is allowed to eliminate duplicates among all string literals, including ones used only in the initialization of other objects.</p>\n", "LastActivityDate": "2015-09-05T23:14:08.797"}, "32416123": {"ParentId": "32413700", "CommentCount": "0", "Body": "<p>I will offer a counter question: <em>why do you care?</em></p>\n<p>The C++ Standard specifies the behavior of the language, and the first core principle when it comes to implementations is basically known as the as-if rule:</p>\n<blockquote>\n<p id=\"so_32413700_32416123_0\"><strong>\u00a7 1.9 Program execution</strong></p>\n<p id=\"so_32413700_32416123_1\"><strong>1/</strong> The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine. This International Standard places no requirement on the structure of conforming implementations. In particular, they need not copy or emulate the structure of the abstract machine. Rather, conforming implementations are required to emulate (only) the observable behavior of the abstract machine as explained below.</p>\n</blockquote>\n<hr>\n<p>In your case:</p>\n<pre><code>std::string str = \"this is a string\";\n</code></pre>\n<p>There are various valid scenarios:</p>\n<ul>\n<li>you do not use <code>str</code> afterward? then this whole code portion may be completely elided</li>\n<li>you immediately assign <code>'T'</code> to <code>str[0]</code> afterward? then the two might be coalesced into <code>std::string str = \"This is a string\";</code></li>\n<li>...</li>\n</ul>\n<p>and there is no guarantee as to what <em>your</em> compiler will do. It may depend on the compiler you use, the standard library implementation you use, the architecture/OS you are compiling for and even the arguments passed to the compiler...</p>\n<p>Thus, if you want to know <em>in your case</em>, you will have to inspect the machine code generated. Asking <a href=\"http://coliru.stacked-crooked.com/a/9efd577d7a94f9e9\" rel=\"nofollow\">coliru</a>, for the following code:</p>\n<pre><code>#include &lt;string&gt;\n\nint main(int argc, char** argv) {\n    std::string str = \"this is a string\";\n}\n</code></pre>\n<p>Clang produces the following in the IR:</p>\n<blockquote id=\"so_32413700_32416123_2\">\n<pre><code>@.str = private unnamed_addr constant [17 x i8] c\"this is a string\\00\", align 1\n</code></pre>\n</blockquote>\n<p>which in turn gives the following assembly:</p>\n<blockquote id=\"so_32413700_32416123_3\">\n<pre><code>.L.str:\n    .asciz    \"this is a string\"\n    .size .L.str, 17\n</code></pre>\n</blockquote>\n<p>So you have it, for these specific conditions, <code>\"this is a string\"</code> will be as-is in the binary and will be loaded in read-only memory. It will stay in the address space of the process until the end, the OS may page it out or not depending on RAM pressure.</p>\n</hr>", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "32416123", "Score": "0", "CreationDate": "2015-09-05T18:00:16.067", "LastActivityDate": "2015-09-05T18:00:16.067"}, "32413813": {"ParentId": "32413700", "CommentCount": "0", "Body": "<p>A few of your initial statements are not quite correct:</p>\n<p>For the <code>char *</code> and <code>char []</code> example, in both cases the variable itself, <code>str</code> remains in scope and accessible until the program ends if it's declared in the global namespace.</p>\n<p>If it's declared in a function or a method's scope, it's accessible while the scope remains active. Both of them.</p>\n<p>As far as what actually happens to the memory that's used to store the actual literal strings, that's unspecified. A particular C++ implementation is free to manage runtime memory in whatever manner is more convenient for it, as long as the results are compliant with the C++ standard. As far as C++ goes, you are not accessing the memory used by the <code>str</code> object, you're only referencing the <code>str</code> object itself.</p>\n<p>Of course, you are free to take a native <code>char *</code> pointer, pointing to one of the character in the <code>str</code>. But whether or not the pointer is valid is tied directly to the scope of the underlying object. When the corresponding <code>str</code> object goes out of scope, the pointer is no longer valid, and accessing the contents of the pointer becomes undefined behavior.</p>\n<p>Note that in the case where <code>str</code> is in the global namespace, the scope of <code>str</code> is the lifetime of the program, so the point is moot. But when <code>str</code> is in a local scope, and it goes out of scope, using the pointer becomes undefined behavior. What happens to the underlying memory is irrelevant. The C++ standard doesn't really define much what should or should not happen to memory in the underlying implementation, but what is or is not undefined behavior.</p>\n<p>Based on that, you can pretty much figure out the answer for the <code>std::string</code> case yourself. It's the same thing. You are accessing the <code>std::string</code> object, and not the underlying memory, and the same principle applies.</p>\n<p>But note that in addition to the scoping issue, some, but not all, methods of the <code>std::string</code> object are also specified as invalidating all existing direct pointers, and iterators, to its contents, so this also affects whether or not a direct <code>char *</code> to one of the characters in the <code>std::string</code> remains valid.</p>\n", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "32413813", "Score": "0", "CreationDate": "2015-09-05T13:50:43.197", "LastActivityDate": "2015-09-05T13:50:43.197"}, "bq_ids": {"n4140": {"so_32413700_32416123_1": {"section_id": 5797, "quality": 0.8918918918918919, "length": 33}}, "n3337": {"so_32413700_32416123_1": {"section_id": 5570, "quality": 0.8918918918918919, "length": 33}}, "n4659": {"so_32413700_32416123_1": {"section_id": 7256, "quality": 0.8918918918918919, "length": 33}}}});