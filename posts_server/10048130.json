post_cb({"10048185": {"ParentId": "10048130", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>If <code>byte</code> stands for <code>char</code> type, the behavior will depend on whether <code>char</code> is signed or unsigned on your platform.</p>\n<p>If <code>char</code> is unsigned, the original <code>int</code> value is reduced to the <code>unsigned char</code> range modulo <code>UCHAR_MAX+1</code>. Values in <code>[0, UCHAR_MAX]</code> range are preserved. C language specification describes this process as</p>\n<blockquote>\n<p id=\"so_10048130_10048185_0\">... the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.</p>\n</blockquote>\n<p>If <code>char</code> type is signed, then values within <code>[SCHAR_MIN, SCHAR_MAX]</code> range are preserved, while any values outside this range are converted in some implementation-defined way. (C language additionally explicitly allows an implementation-defined signal to be raised in such situations.) I.e. there's no universal answer. Consult your platform's documentation. Or, better, write code that does not rely on any specific conversion behavior.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "1011995", "LastEditDate": "2012-04-06T20:40:05.037", "Id": "10048185", "Score": "7", "CreationDate": "2012-04-06T19:19:04.670", "LastActivityDate": "2012-04-06T20:40:05.037"}, "10048276": {"ParentId": "10048130", "CommentCount": "0", "Body": "<p>Here's an example:</p>\n<p>1) Code:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid\nmethod1 (unsigned char b)\n{\n  int a = 10;\n  printf (\"a=%d, b=%d...\\n\", a, b);\n}\n\nvoid\nmethod2 (unsigned char * b)\n{\n  int a = 10;\n  printf (\"a=%d, b=%d...\\n\", a, *b);\n}\n\nint\nmain (int argc, char *argv[])\n{\n  int i=3;\n  method1 (i);\n  method2 (i);\n  return 0;\n}\n</code></pre>\n<p>2) Compile (with warning):</p>\n<pre><code>$ gcc -o x -Wall -pedantic x.c\nx.c: In function `main':\nx.c:22: warning: passing arg 1 of `method2' makes pointer from integer without a cast\n</code></pre>\n<p>3) Execute (with crash):</p>\n<pre><code>$ ./x\na=10, b=3...\nSegmentation fault (core dumped)\n</code></pre>\n<p>'Hope that helps - both with your original question, and with related issues.</p>\n", "OwnerUserId": "421195", "PostTypeId": "2", "Id": "10048276", "Score": "0", "CreationDate": "2012-04-06T19:26:49.907", "LastActivityDate": "2012-04-06T19:26:49.907"}, "10048295": {"ParentId": "10048130", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Quoting the C++ 2003 standard:</p>\n<blockquote>\n<p id=\"so_10048130_10048295_0\">Clause 5.2.2 paragrah 4: When a function is called, each parameter (8.3.5) shall be initialized (8.5, 12.8, 12.1) with its corresponding\n  argument.</p>\n</blockquote>\n<p>So, <code>b</code> is <em>initialized</em> with <code>i</code>. What does that mean?</p>\n<blockquote>\n<p id=\"so_10048130_10048295_1\">8.5/14 the initial value of the object being initialized is the (possibly converted) value of the initializer\n  expression. Standard conversions (clause 4) will be used, if necessary, to convert the initializer\n  expression to the \u2026 destination type; no user-defined conversions are considered</p>\n</blockquote>\n<p>Oh, <code>i</code> is <em>converted</em>, using the <em>standard conversions</em>. What does that mean? Among many other standard conversions are these:</p>\n<blockquote>\n<p id=\"so_10048130_10048295_2\">4.7/2 If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source\n  integer (modulo 2<sup>n</sup> where n is the number of bits used to represent the unsigned type).</p>\n<p id=\"so_10048130_10048295_3\">4.7/3 If the destination type is signed, the value is unchanged if it can be represented in the destination type (and\n  bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>Oh, so if <code>char</code> is unsigned, the value is truncated to the number of bits in a char (or computed modulo UCHAR_MAX+1, whichever way you want to think about it.)</p>\n<p>And if <code>char</code> is signed, then the value is unchanged, if it fits; implementation-defined otherwise.</p>\n<p>In practice, on the computers and compilers you care about, the value is always truncated to fit in 8 bits, regardless of whether <code>char</code>s are signed or unsigned. </p>\n", "OwnerUserId": "8747", "LastEditorUserId": "8747", "LastEditDate": "2012-04-06T19:33:50.587", "Id": "10048295", "Score": "1", "CreationDate": "2012-04-06T19:28:50.107", "LastActivityDate": "2012-04-06T19:33:50.587"}, "10048130": {"CommentCount": "8", "AcceptedAnswerId": "10048157", "CreationDate": "2012-04-06T19:14:02.853", "LastActivityDate": "2012-04-06T20:40:05.037", "PostTypeId": "1", "ViewCount": "1482", "FavoriteCount": "0", "Title": "What happens if you pass an int to a byte parameter in C?", "Id": "10048130", "Score": "2", "Body": "<p>How does C/C++ deal if you pass an int as a parameter into a method that takes in a byte (a char)? Does the int get truncated? Or something else?</p>\n<p>For example:</p>\n<pre><code>void method1()\n{\n    int i = //some int;\n    method2(i);\n}\n\nvoid method2(byte b)\n{\n     //Do something\n}\n</code></pre>\n<p>How does the int get \"cast\" to a byte (a char)? Does it get truncated?</p>\n", "Tags": "<c++><c><int><byte>", "OwnerUserId": "1174719", "AnswerCount": "7"}, "10048157": {"ParentId": "10048130", "CommentCount": "0", "Body": "<p>Just truncated AS bit pattern (byte is in general unsigned char, however, you have to check)</p>\n<p>int i = -1;</p>\n<p>becomes</p>\n<p>byte b = 255; when byte = unsigned char</p>\n<p>byte b = -1; when byte = signed char</p>\n<p>i = 0; b = 0;</p>\n<p>i = 1024; b = 0;</p>\n<p>i = 1040; b = 16;</p>\n", "OwnerUserId": "732454", "PostTypeId": "2", "Id": "10048157", "Score": "3", "CreationDate": "2012-04-06T19:16:45.463", "LastActivityDate": "2012-04-06T19:16:45.463"}, "10048184": {"ParentId": "10048130", "CommentCount": "1", "Body": "<p>There are two cases to worry about:</p>\n<pre><code>// Your input \"int i\" gets truncated\nvoid method2(byte b)\n{\n  ...\n\n// Your \"method2()\" stack gets overwritten\nvoid method2(byte * b)\n{\n  ...\n</code></pre>\n", "OwnerUserId": "421195", "PostTypeId": "2", "Id": "10048184", "Score": "-1", "CreationDate": "2012-04-06T19:19:03.417", "LastActivityDate": "2012-04-06T19:19:03.417"}, "10048195": {"ParentId": "10048130", "CommentCount": "0", "Body": "<p>It will be cast to a byte the same as if you casted it explicitly as <code>(byte)i</code>.</p>\n<p>Your sample code above might be a different case though, unless you have a forward declaration for <code>method2</code> that is not shown. Because <code>method2</code> is not yet declared at the time it is called, the compiler doesn't know the type of its first parameter. In C, functions should be declared (or defined) before they are called. What happens in this case is that the compiler assumes (as an implicit declaration) that <code>method2</code>'s first parameter is an <code>int</code> and <code>method2</code> receives an <code>int</code>. Officially that results in undefined behaviour, but on most architectures, both <code>int</code> and <code>byte</code> would be passed in the same size register anyway and it will happen to work.</p>\n", "OwnerUserId": "675129", "PostTypeId": "2", "Id": "10048195", "Score": "-1", "CreationDate": "2012-04-06T19:19:37.700", "LastActivityDate": "2012-04-06T19:19:37.700"}, "bq_ids": {"n4140": {"so_10048130_10048295_1": {"section_id": 3296, "quality": 0.8695652173913043, "length": 20}, "so_10048130_10048295_3": {"section_id": 32, "quality": 0.8666666666666667, "length": 13}, "so_10048130_10048295_2": {"section_id": 31, "quality": 0.9473684210526315, "length": 18}, "so_10048130_10048295_0": {"section_id": 5991, "quality": 0.6, "length": 9}}, "n3337": {"so_10048130_10048295_1": {"section_id": 3166, "quality": 0.8695652173913043, "length": 20}, "so_10048130_10048295_3": {"section_id": 29, "quality": 0.8666666666666667, "length": 13}, "so_10048130_10048295_2": {"section_id": 28, "quality": 0.9473684210526315, "length": 18}, "so_10048130_10048295_0": {"section_id": 5759, "quality": 0.6, "length": 9}}, "n4659": {"so_10048130_10048295_3": {"section_id": 32, "quality": 0.7333333333333333, "length": 11}, "so_10048130_10048295_1": {"section_id": 4058, "quality": 0.8695652173913043, "length": 20}, "so_10048130_10048295_2": {"section_id": 31, "quality": 0.9473684210526315, "length": 18}, "so_10048130_10048295_0": {"section_id": 7491, "quality": 0.6, "length": 9}}}, "10048189": {"ParentId": "10048130", "CommentCount": "0", "Body": "<p>You don't tell what a <code>byte</code> is,  but if you pass a parameter that is convertible to the parameter type, the value will be converted.</p>\n<p>If the types have different value ranges there is a risk that the value is outside the range of the parameter type, and then it will not work. If it is within the range, it will be safe.</p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "10048189", "Score": "0", "CreationDate": "2012-04-06T19:19:20.787", "LastActivityDate": "2012-04-06T19:19:20.787"}});