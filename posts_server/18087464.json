post_cb({"bq_ids": {"n4140": {"so_18087464_18087591_0": {"length": 58, "quality": 0.9206349206349206, "section_id": 5908}}, "n3337": {"so_18087464_18087591_0": {"length": 58, "quality": 0.9206349206349206, "section_id": 5680}}}, "18087591": {"PostTypeId": "2", "Body": "<p>I've tracked it down to section 9.4.2 \"Static data members\" of the C++ language specification (<a href=\"http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS/ISO/IEC%2014882-2012\" rel=\"nofollow\">INCITS/ISO/IEC 14882-2011[2012]</a>):</p>\n<blockquote>\n<p id=\"so_18087464_18087591_0\">If a non-volatile <code>const static</code> data member is of integral or enumeration type, its declaration in the class definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression (5.19). A <code>static</code> data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression. [ <em>Note:</em> In both these cases, the member may appear in constant expressions. <em>\u2014end note</em> ] The member shall still be defined in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not contain an <em>initializer</em>.</p>\n</blockquote>\n<p>So, for <em>integral</em> types (e.g. <code>int</code> and <code>char</code> in your example), you <em>can</em> initialize in the class definition. If you do so, you <em>must</em> also define it at namespace scope (i.e. in your <code>.cpp</code> file) and <em>without</em> an initializer. Elsewhere in that section of the spec it is stated that declaration of a <code>static</code> data member in its class is <em>not</em> a definition and <em>must</em>, therefore, be accompanied by a definition at namespace scope, which is what you're doing in your example.</p>\n<p>GCC follows this part of the specification, Visual C++ doesn't. I tested with Visual Studio 2012.</p>\n<p><a href=\"http://bytes.com/topic/c/answers/516245-static-const-variables\" rel=\"nofollow\">Here's another discussion of Visual C++'s noncompliance in this regard.</a> The workaround described here is exactly what you're doing: guard the definition of the integral variables, although they're using <code>_MSC_VER</code>.</p>\n", "LastActivityDate": "2013-08-06T19:11:12.647", "LastEditorUserId": "394167", "Id": "18087591", "CommentCount": "3", "CreationDate": "2013-08-06T18:18:23.210", "ParentId": "18087464", "Score": "2", "OwnerUserId": "394167", "LastEditDate": "2013-08-06T19:11:12.647"}, "18087464": {"ViewCount": "2445", "Body": "<p>We have been compiling a library on both Linux (gcc) and Windows (Visual Studio), and as expected, finding minor, but not significant differences between what it takes to get a clean compile on both platforms.</p>\n<p>Today, I changed gcc compiler flag to use <code>-fPIC</code> (to enable making a shared library).  When we tested linking a program against the library, we started getting errors (for the first time), with  <code>undefined reference</code> to 2 static constants which are declared and initialized in the header file (but not in .cpp file).  </p>\n<p>I found <a href=\"https://stackoverflow.com/a/7092830/376527\">this StackOverflow answer</a> which seemed to address the problem, explaining that, even if <code>static const</code> is initialized in header file, it still needs to be defined in the code file. And making that change did remove the gcc linker error.</p>\n<p>Visual Studio, however, didn't like that change, and generated <code>multiple definition</code> errors.  We had to wrap the definition needed a preprocessor conditional to get Visual Studio to compile cleanly.</p>\n<p>Can someone enlighten me as to what the difference is here?  (Code excerpt is below.)</p>\n<p><strong>msg.h</strong></p>\n<pre><code>class msg\n{\n  public:\n    static const int EMPTY_INT_VALUE = INT_MAX;\n    static const char EMPTY_STRING_VALUE = '\\002';\n    // can't define value in header, defined in cpp file\n    static const double EMPTY_DOUBLE_VALUE;   \n    ...\n}\n</code></pre>\n<p><strong>msg.cpp</strong></p>\n<pre><code>#include \"msg.h\"\n\nconst double msg::EMPTY_DOUBLE_VALUE(DBL_MAX);\n\n#ifndef _WIN32\n// g++ requires these definitions, vs 2010 doesn't like them\nconst int msg::EMPTY_INT_VALUE;\nconst char msg::EMPTY_STRING_VALUE;\n#endif\n</code></pre>\n", "AcceptedAnswerId": "18087591", "Title": "Difference between Linux gcc and Windows Visual Studio handling of static constants?", "CreationDate": "2013-08-06T18:12:30.360", "Id": "18087464", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:17:23.060", "LastEditorUserId": "-1", "LastActivityDate": "2013-08-06T19:24:06.057", "Score": "4", "OwnerUserId": "376527", "Tags": "<c++><visual-studio-2010><linker><compiler-errors><g++>", "AnswerCount": "1"}});