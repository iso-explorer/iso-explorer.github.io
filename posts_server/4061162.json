post_cb({"4061162": {"CommentCount": "2", "AcceptedAnswerId": "4061262", "CreationDate": "2010-10-30T23:43:34.553", "LastActivityDate": "2010-10-31T00:30:30.160", "PostTypeId": "1", "ViewCount": "3055", "FavoriteCount": "1", "Title": "Calling primitive operator-functions explicitly in C++", "Id": "4061162", "Score": "6", "Body": "<pre><code>int a, b, c; \n\n//do stuff. For e.g., cin &gt;&gt; b &gt;&gt; c; \n\nc = a + b;          //works \nc = operator+(a,b); //fails to compile, 'operator+' not defined. \n</code></pre>\n<p>This on the other hand works - </p>\n<pre><code>class Foo\n{\n int x; \npublic:\n Foo(int x):x(x) {} \n\n Foo friend operator+(const Foo&amp; f, const Foo&amp; g)\n {\n  return Foo(f.x + g.x); \n }\n\n};    \n\nFoo l(5), m(10); \n\nFoo n = operator+(l,m); //compiles ok! \n</code></pre>\n<ul>\n<li>Is it even possible to invoke operator+ (and other operators) of primitive types (like int) directly?</li>\n<li>If yes, how?</li>\n<li>If not, is there a C++ reference verbiage that makes it clear that this is not doable? </li>\n</ul>\n", "Tags": "<c++><function><operator-keyword>", "OwnerUserId": "492471", "AnswerCount": "2"}, "4061262": {"ParentId": "4061162", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Firstly, invoking built-in operators as functions will not work simply because the language specification never says that such functions exist. Built-in operators are just operators. There are no implementing functions behind them simply because the language specification never suggests their existence. Function-based implementations are specific to <em>overloaded</em> operators only.</p>\n<p>Secondly, during overload resolution the built-in operators are indeed represented by their imaginary function-like counterparts, but the wording that prohibits \"explicit\" function-like invocation of built-in operators is present in 13.6/1</p>\n<blockquote>\n<p id=\"so_4061162_4061262_0\">The candidate operator functions that\n  represent the built-in operators\n  defined in clause 5 are specified in\n  this subclause. These candidate\n  functions participate in the operator\n  overload resolution process as\n  described in 13.3.1.2 <strong>and are used\n  for no other purpose</strong>.</p>\n</blockquote>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2010-10-31T00:30:30.160", "Id": "4061262", "Score": "7", "CreationDate": "2010-10-31T00:13:48.407", "LastActivityDate": "2010-10-31T00:30:30.160"}, "bq_ids": {"n4140": {"so_4061162_4061262_0": {"section_id": 675, "quality": 0.8260869565217391, "length": 19}, "so_4061162_4061201_3": {"section_id": 653, "quality": 0.9636363636363636, "length": 53}}, "n3337": {"so_4061162_4061262_0": {"section_id": 665, "quality": 0.8260869565217391, "length": 19}, "so_4061162_4061201_3": {"section_id": 643, "quality": 0.9818181818181818, "length": 54}}, "n4659": {"so_4061162_4061262_0": {"section_id": 703, "quality": 0.8260869565217391, "length": 19}, "so_4061162_4061201_3": {"section_id": 681, "quality": 0.9636363636363636, "length": 53}}}, "4061201": {"ParentId": "4061162", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>From <a href=\"http://www.parashift.com/c++-faq-lite/intrinsic-types.html\" rel=\"nofollow\">http://www.parashift.com/c++-faq-lite/intrinsic-types.html</a></p>\n<h2>Can I define an operator overload that works with built-in / intrinsic / primitive types?</h2>\n<blockquote>\n<p id=\"so_4061162_4061201_0\">No, the C++ language requires that\n  your operator overloads take at least\n  one operand of a \"class type\" or\n  enumeration type. The C++ language\n  will not let you define an operator\n  all of whose operands / parameters are\n  of primitive types.</p>\n<p id=\"so_4061162_4061201_1\">For example, you can't define an\n  operator== that takes two char*s and\n  uses string comparison. That's good\n  news because if s1 and s2 are of type\n  char*, the expression s1 == s2 already\n  has a well defined meaning: it\n  compares the two pointers, not the two\n  strings pointed to by those pointers.\n  You shouldn't use pointers anyway. Use\n  std::string instead of char*.</p>\n<p id=\"so_4061162_4061201_2\">If C++ let you redefine the meaning of\n  operators on built-in types, you\n  wouldn't ever know what 1 + 1 is: it\n  would depend on which headers got\n  included and whether one of those\n  headers redefined addition to mean,\n  for example, subtraction.</p>\n</blockquote>\n<h2>C++ Standard \u00a713.5.6</h2>\n<blockquote>\n<p id=\"so_4061162_4061201_3\">An operator function shall either be a non-static member function or be a non-member function and have at least one parameter whose type is a class, a reference to a class, an enumeration, or a reference to an enumeration. It is not possible to change the precedence, grouping, or number of operands of operators. The meaning of the operators =, (unary) &amp;, and , (comma), predefined for each type, can be changed for specific class and enumeration types by defining operator functions that implement these operators. Operator functions are inherited in the same manner as other base class functions.</p>\n</blockquote>\n", "OwnerUserId": "243613", "LastEditorUserId": "243613", "LastEditDate": "2010-10-31T00:02:27.637", "Id": "4061201", "Score": "2", "CreationDate": "2010-10-30T23:53:10.463", "LastActivityDate": "2010-10-31T00:02:27.637"}});