post_cb({"37254813": {"CommentCount": "21", "ViewCount": "269", "PostTypeId": "1", "LastEditorUserId": "3235496", "CreationDate": "2016-05-16T13:13:25.127", "LastActivityDate": "2016-05-18T15:15:44.753", "Title": "Evaluation order of elements in an initializer list", "AcceptedAnswerId": "37254866", "LastEditDate": "2016-05-17T07:53:25.870", "Id": "37254813", "Score": "1", "Body": "<p>Why is function <code>g()</code> called first? I defined <code>g()</code> as the second element in the initializer list.</p>\n<p>Is the following quote from the standard, relating to initializer-lists, relevant?</p>\n<blockquote>\n<p id=\"so_37254813_37254813_0\">\u00a78.5.4.4: Within the initializer-list of a braced-init-list, the\n  initializer-clauses, including any that result from pack expansions\n  (\u00a714.5.3), are evaluated in the order in which they appear.</p>\n</blockquote>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint f() { std::cout &lt;&lt; \"f\"; return 0;}\nint g() { std::cout &lt;&lt; \"g\"; return 0;}\n\nvoid h(std::vector&lt;int&gt; v) {}\n\nint main() {\n\n   h({f(), g()});\n}\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code>gf\n</code></pre>\n", "Tags": "<c++><gcc><order-of-evaluation>", "OwnerUserId": "5905343", "AnswerCount": "2"}, "37255880": {"ParentId": "37254813", "CommentCount": "4", "Body": "<p>This is not a <em>braced-init-list</em>, so that rule does not apply.</p>\n<blockquote>\n<p id=\"so_37254813_37255880_0\"><code>[C++14: 5.17/9]:</code> A <em>braced-init-list</em> may appear on the right-hand side of</p>\n<ul>\n<li>an assignment to a scalar, in which case the initializer list shall have at most a single element. The meaning of <code>x={v}</code>, where <code>T</code> is the scalar type of the expression <code>x</code>, is that of <code>x=T{v}</code>. The meaning of <code>x={}</code> is <code>x=T{}</code>.</li>\n<li>an assignment to an object of class type, in which case the initializer list is passed as the argument to the assignment operator function selected by overload resolution (13.5.3, 13.3).</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "37255880", "Score": "2", "CreationDate": "2016-05-16T14:06:38.460", "LastActivityDate": "2016-05-16T14:06:38.460"}, "bq_ids": {"n4140": {"so_37254813_37254866_3": {"section_id": 3294, "quality": 0.7647058823529411, "length": 13}, "so_37254813_37254813_0": {"section_id": 3326, "quality": 0.8571428571428571, "length": 12}, "so_37254813_37255880_0": {"section_id": 6181, "quality": 0.7142857142857143, "length": 5}, "so_37254813_37254866_6": {"section_id": 3296, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_37254813_37255880_0": {"section_id": 5942, "quality": 0.7142857142857143, "length": 5}, "so_37254813_37254813_0": {"section_id": 3196, "quality": 0.8571428571428571, "length": 12}, "so_37254813_37254866_3": {"section_id": 3164, "quality": 0.7647058823529411, "length": 13}, "so_37254813_37254866_6": {"section_id": 3166, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_37254813_37255880_0": {"section_id": 7683, "quality": 0.7142857142857143, "length": 5}, "so_37254813_37254813_0": {"section_id": 4092, "quality": 0.8571428571428571, "length": 12}, "so_37254813_37254866_3": {"section_id": 4056, "quality": 0.7647058823529411, "length": 13}, "so_37254813_37254866_6": {"section_id": 4058, "quality": 0.7777777777777778, "length": 7}}}, "37254866": {"ParentId": "37254813", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><del>It seems to me that</del> the quote is relevant (the compiler sees an initializer list):</p>\n<blockquote>\n<p id=\"so_37254813_37254866_0\">8.5/14,16:</p>\n<p id=\"so_37254813_37254866_1\">The initialization that occurs in the form</p>\n<p id=\"so_37254813_37254866_2\">T x = a;</p>\n<p id=\"so_37254813_37254866_3\"><strong>as well as in argument passing</strong>, function return, throwing an exception (15.1), handling an exception (15.3), and aggregate member initialization (8.5.1) is called copy-initialization.</p>\n<p id=\"so_37254813_37254866_4\">.</p>\n<p id=\"so_37254813_37254866_5\">.</p>\n<p id=\"so_37254813_37254866_6\">The semantics of initializers are as follows[...]: If the initializer is a braced-init-list, the object is list-initialized (8.5.4).</p>\n</blockquote>\n<p>(more details in <a href=\"https://stackoverflow.com/q/2357452/3235496\">std::initializer_list as function argument</a> and <a href=\"http://articles.emptycrate.com/2016/05/14/folds_in_cpp11_ish.html\" rel=\"nofollow noreferrer\">Folds (ish) In C++11</a>)</p>\n<p>Moreover any <code>{}</code>-list should be sequenced (the standard uses a very strong wording about this fact. See also <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1030\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1030</a>).</p>\n<p>So it's <a href=\"https://stackoverflow.com/q/36852367/3235496\">probably a GCC bug</a> (fixed after gcc v4.9.0).</p>\n<p>Indeed, trying various GCC version, I get:</p>\n<pre><code>GCC      with --std=c++11   without (--std=c++98)\n4.7.3        fg                    gf  &lt;-\n4.8.1        fg                    gf  &lt;-\n4.8.2        fg                    gf  &lt;-\n4.9.0        fg                    gf  &lt;-\n4.9.2        fg                    fg\n5.1.0        fg                    fg\n5.2.0        fg                    fg\n6.1.0        fg                    fg\n</code></pre>\n<p>Extended initializer lists are only available with C++11 but GCC compiles the code anyway (with a warning, e.g. see <a href=\"https://godbolt.org/g/8Hll7t\" rel=\"nofollow noreferrer\"><code>gcc -Wall -Wextra</code></a> vs <a href=\"https://godbolt.org/g/5DL8Gf\" rel=\"nofollow noreferrer\"><code>gcc -Wall -Wextra -std=c++11</code></a>).</p>\n", "OwnerUserId": "3235496", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:53:03.517", "Id": "37254866", "Score": "0", "CreationDate": "2016-05-16T13:15:37.913", "LastActivityDate": "2016-05-18T15:15:44.753"}});