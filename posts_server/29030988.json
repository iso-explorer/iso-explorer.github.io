post_cb({"29031231": {"ParentId": "29030988", "CommentCount": "0", "Body": "<p>Because the base class is a template, whose instantiation depends on a template parameter of the derived class, and you're trying to name a member of the base class, two-phase lookup mandates that you write <code>this-&gt;b</code>, not <code>b</code>.</p>\n<p>(And that default constructor call is not needed.)</p>\n<pre><code>stack()\n{\n    this-&gt;b = this-&gt;a;\n}\n\nvoid pop()\n{\n    this-&gt;b--;\n}\n</code></pre>\n<h3>(<a href=\"http://coliru.stacked-crooked.com/a/107c09eee1cd31b2\" rel=\"nofollow\">live demo</a>)</h3>\n<p>Welcome to C++\u2026 :P</p>\n<hr>\n<blockquote>\n<p id=\"so_29030988_29031231_0\"><code>[C++11: 14.6.2/3]:</code> In the definition of a class or class template, if a base class depends on a <em>template-parameter</em>, the base class scope is not examined during unqualified name lookup either at the point of definition of the class template or member or during an instantiation of the class template or member. <em>[..]</em></p>\n</blockquote>\n</hr>", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "29031231", "Score": "2", "CreationDate": "2015-03-13T11:36:40.883", "LastActivityDate": "2015-03-13T11:36:40.883"}, "29030988": {"CommentCount": "3", "ViewCount": "76", "PostTypeId": "1", "LastEditorUserId": "1782465", "CreationDate": "2015-03-13T11:24:49.153", "LastActivityDate": "2015-03-13T12:46:43.313", "Title": "Deriving a class from a class template", "LastEditDate": "2015-03-13T12:46:43.313", "Id": "29030988", "Score": "2", "Body": "<p>I am new to C++. During my learning phase I encountered with below issue.\nI am trying to derive a class <code>stack</code> from a class template <code>Queue</code>.\nCompiler throws below error in constructor of <code>stack</code></p>\n<pre><code>..\\src\\TrainingDay2.cpp:44:3: error: 'b' was not declared in this scope\n   b=a;\n</code></pre>\n<p>Please help to find out the root cause.</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\ntemplate&lt;class T&gt; class Queue //Base class\n{\nprivate:\n    T ArrQueue[20];\nprotected:\n    T* a;\n    T* b;\npublic:\n\n    Queue() { cout&lt;&lt;\"QUEUE CONST \"&lt;&lt;  endl; }\n    void push(T x);\n    void pop(void);\n};\n\n\ntemplate &lt;class T&gt;\nclass stack :public Queue&lt;T&gt; // Derived class\n{\npublic:\n    stack():Queue&lt;T&gt;() {\n        b=a;\n    }\n    void pop() {\n        b--;\n    }\n};\n\n\nint main()\n{\n    stack&lt;int&gt; S;\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates>", "OwnerUserId": "4666957", "AnswerCount": "3"}, "29031256": {"ParentId": "29030988", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_29030988_29031256_0\">In a template definition, unqualified names will no longer find members of a  dependent base (as specified by [temp.dep]/3 in the C++ standard). For example,\n  You must make the names dependent, e.g. by prefixing them with this-&gt;. </p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/11405/gcc-problem-using-a-member-of-a-base-class-that-depends-on-a-template-argument\">gcc-problem-using-a-member-of-a-base-class-that-depends-on-a-template-argument</a></p>\n<p>And yes, it can be valid in VS.</p>\n", "OwnerUserId": "2534793", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:43:36.243", "Id": "29031256", "Score": "0", "CreationDate": "2015-03-13T11:37:56.437", "LastActivityDate": "2015-03-13T11:37:56.437"}, "bq_ids": {"n4140": {"so_29030988_29031231_0": {"section_id": 190, "quality": 0.9310344827586207, "length": 27}}, "n3337": {"so_29030988_29031231_0": {"section_id": 184, "quality": 0.9310344827586207, "length": 27}}, "n4659": {"so_29030988_29031231_0": {"section_id": 195, "quality": 0.7586206896551724, "length": 22}}}, "29031322": {"ParentId": "29030988", "CommentCount": "2", "Body": "<p>The reason is that inside a template, two-phase name lookup rules apply:</p>\n<ul>\n<li><p>Names which do not depend on template parameters are looked up (=resolved) when the template is defined (=parsed).</p></li>\n<li><p>Names which do depend on template parameters are looked up when the template is instantiated (when you provide the template arguments).</p></li>\n<li><p>Base classes which depend on template parameters are only searched during name lookup at instantiation time.</p></li>\n</ul>\n<p>The reason for this two-phase lookup is that until the template arguments are known, the compiler cannot know what the definition of the base class (or other dependent construct) will be. Remember that template specialisation exists.</p>\n<p>You need to somehow tell the compiler that the name <code>b</code> is dependent. You basically have three ways to do that:</p>\n<ol>\n<li><p>Prefix the name with <code>this-&gt;</code>; since you're in a class template, all your members depend on template parameters implicitly:</p>\n<pre><code>this-&gt;b = a;\n</code></pre></li>\n<li><p>Use full qualification for the name. This will make the dependency on template parameters explicit:</p>\n<pre><code>Queue&lt;T&gt;::b = a;\n</code></pre></li>\n<li><p>Put a <code>using</code> declaration into your class to inform the compiler that the name comes from a dependent base class:</p>\n<pre><code>template &lt;class T&gt;\nclass stack :public Queue&lt;T&gt; // Derived class\n{\nprotected:\n    using Queue&lt;T&gt;::b;\n\npublic:\n    stack():Queue&lt;T&gt;()\n    {\n        b=a;\n    }\n     void pop()\n    {\n        b--;\n    }\n};\n</code></pre></li>\n</ol>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "29031322", "Score": "2", "CreationDate": "2015-03-13T11:41:19.397", "LastActivityDate": "2015-03-13T11:41:19.397"}});