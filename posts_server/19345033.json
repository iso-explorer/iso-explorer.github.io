post_cb({"19345033": {"ViewCount": "578", "Body": "\n<p>The code</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;int n&gt; struct Fibo { static int x; };\ntemplate&lt;&gt; int Fibo&lt;0&gt;::x = 1;\ntemplate&lt;&gt; int Fibo&lt;1&gt;::x = 1;\ntemplate&lt;int n&gt; int Fibo&lt;n&gt;::x = Fibo&lt;n-1&gt;::x + Fibo&lt;n-2&gt;::x; //marked line\n\nint main() {\n    cout &lt;&lt; Fibo&lt;5&gt;::x &lt;&lt; endl;\n    cout &lt;&lt; Fibo&lt;4&gt;::x &lt;&lt; endl;\n    cout &lt;&lt; Fibo&lt;3&gt;::x &lt;&lt; endl;\n    cout &lt;&lt; Fibo&lt;2&gt;::x &lt;&lt; endl;\n    cout &lt;&lt; Fibo&lt;1&gt;::x &lt;&lt; endl;\n    cout &lt;&lt; Fibo&lt;0&gt;::x &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>outputs</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>0\n0\n1\n2\n1\n1\n</code></pre>\n<p>in VC++. (According to user <a href=\"https://stackoverflow.com/users/952747/m-m\">M M.</a> it compiles as expected in gcc). When the compiler gets to the marked line with <code>n=5</code> it doesn't compile that same line again for <code>n=4</code>, but just treats <code>Fibo&lt;4&gt;::x</code> as if it were declared with</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>template&lt;&gt; int Fibo&lt;4&gt;::x; // x defaults to 0\n</code></pre>\n<p>Why is that? Why does it work as expected when using</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>template&lt;int n&gt; struct Fibo { enum { x = Fibo&lt;n-1&gt;::x + Fibo&lt;n-2&gt;::x }; };\ntemplate&lt;&gt; struct Fibo&lt;0&gt; { enum { x = 1 }; };\ntemplate&lt;&gt; struct Fibo&lt;1&gt; { enum { x = 1 }; };\n</code></pre>\n<p>instead, but not with a static variable? And how do you fix the first code (without <code>enum</code>)?</p>\n", "AcceptedAnswerId": "19361939", "Title": "Recursive templates don't work as expected with static variables", "CreationDate": "2013-10-13T12:10:02.310", "Id": "19345033", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:31:45.640", "LastEditorUserId": "-1", "LastActivityDate": "2013-10-16T13:37:21.747", "Score": "6", "OwnerUserId": "624480", "Tags": "<c++><templates><visual-c++><recursion><static-members>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_19345033_19361939_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 241}}, "n3337": {"so_19345033_19361939_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 233}}, "n4659": {"so_19345033_19361939_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 55}}}, "19361939": {"Id": "19361939", "PostTypeId": "2", "Body": "<p>The Standard is very clear on this:</p>\n<blockquote>\n<p id=\"so_19345033_19361939_0\"><strong>14.7.1 Implicit instantiation [temp.inst]</strong></p>\n<p id=\"so_19345033_19361939_1\">9 The implicit instantiation of a class template does not cause any\n  static data members of that class to be implicitly instantiated.</p>\n</blockquote>\n<p>All the calls in <code>main()</code> to your <code>Fibo&lt;n&gt;::x</code> for <code>n &gt; 1</code>, are explicit instantiations, that through the Fibonnaci recursion will implicitly instantiate <code>Fibo&lt;n-1&gt;</code> and <code>Fibo&lt;n-2&gt;</code> but not their members <code>x</code>. This means that at those points, the <code>static</code> members <code>x</code> will be evaluated to their default initialization of <code>0</code>. For <code>n=1</code> and <code>n=0</code>, the compiler will see the explicit initialization values of 1. So effectively, you get the following computation</p>\n<pre><code>Fibo&lt;5&gt;::x --&gt; Fibo&lt;4&gt;::x + Fibo&lt;3&gt;::x --&gt; 0 + 0 = 0\nFibo&lt;4&gt;::x --&gt; Fibo&lt;3&gt;::x + Fibo&lt;2&gt;::x --&gt; 0 + 0 = 0\nFibo&lt;3&gt;::x --&gt; Fibo&lt;2&gt;::x + Fibo&lt;1&gt;::x --&gt; 0 + 1 = 1\nFibo&lt;2&gt;::x --&gt; Fibo&lt;1&gt;::x + Fibo&lt;0&gt;::x --&gt; 1 + 1 = 2\nFibo&lt;1&gt;::x --&gt; 1\nFibo&lt;0&gt;::x --&gt; 1\n</code></pre>\n<p>You need to instantiate the static member <code>x</code> before evaluating the Fibonacci recursion. You can do this through a <code>static const int</code> or <code>enum</code> member <code>x</code>, or through a function (possibly <code>constexpr</code> in C++11) as shown by @Jarod42.</p>\n", "LastEditorUserId": "1090079", "LastActivityDate": "2013-10-16T13:37:21.747", "Score": "3", "CreationDate": "2013-10-14T13:57:04.753", "ParentId": "19345033", "CommentCount": "0", "OwnerUserId": "819272", "LastEditDate": "2013-10-16T13:37:21.747"}, "19345665": {"Id": "19345665", "PostTypeId": "2", "Body": "<p>I'm not sure if the initialization order of the <em>static variables</em> of <code>template&lt;int n&gt; int Fibo&lt;n&gt;::x = Fibo&lt;n-1&gt;::x + Fibo&lt;n-2&gt;::x;</code> is specified...</p>\n<p>You may write this:</p>\n<pre><code>template &lt;int N&gt; struct Fibo { int operator()() const { static int x = Fibo&lt;N - 1&gt;()() + Fibo&lt;N - 2&gt;()(); return x; } };\n\ntemplate &lt;&gt; struct Fibo&lt;1&gt; { int operator()() const { static int x = 1; return x; } };\ntemplate &lt;&gt; struct Fibo&lt;0&gt; { int operator()() const { static int x = 1; return x; } };\n</code></pre>\n<p>The dependencies are respected.</p>\n<p>[Edit]</p>\n<p>In a case where the value may be modified (according to your comment), you may use similar technique but returning reference:</p>\n<pre><code>template &lt;int N&gt; struct Fibo {\nprivate:\n    int&amp; operator()() { static int x = Fibo&lt;N - 1&gt;()() + Fibo&lt;N - 2&gt;()(); return x; }\n\npublic:\n    int operator()() const { return const_cast&lt;Fibo&amp;&gt;(*this)(); }\n    // This change Fibo&lt;0&gt; and Fibo&lt;1&gt; and then update value up to Fibo&lt;N&gt;.\n    int operator(int fibo0, int fibo1) {\n        int n_1 = Fibo&lt;N - 1&gt;()(fibo1, fibo2);\n        (*this)() = n_1 + Fibo&lt;N - 2&gt;()();\n    }\n};\n\ntemplate &lt;&gt; struct Fibo&lt;1&gt; {\nprivate:\n    int&amp; operator()() { static int x = 1; return x; }\npublic:\n    int operator()() const { return const_cast&lt;Fibo&amp;&gt;(*this)(); }\n    void operator(int fibo0, int fibo1) { Fibo&lt;0&gt;()(fibo0); (*this)() = fibo1; }\n};\n\ntemplate &lt;&gt; struct Fibo&lt;0&gt; {\nprivate:\n    int&amp; operator()() { static int x = 1; return x; }\npublic:\n    int operator()() const { return const_cast&lt;Fibo&amp;&gt;(*this)(); }\n    void operator(int fibo0) { (*this)() = fibo0; }\n};\n</code></pre>\n", "LastEditorUserId": "2684539", "LastActivityDate": "2013-10-13T18:05:38.343", "Score": "2", "CreationDate": "2013-10-13T13:13:08.613", "ParentId": "19345033", "CommentCount": "2", "OwnerUserId": "2684539", "LastEditDate": "2013-10-13T18:05:38.343"}});