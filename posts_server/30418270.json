post_cb({"bq_ids": {"n4140": {"so_30418270_30418339_0": {"length": 29, "quality": 0.5087719298245614, "section_id": 5485}, "so_30418270_30418323_0": {"length": 24, "quality": 1.0, "section_id": 5485}, "so_30418270_30418323_1": {"length": 22, "quality": 1.0, "section_id": 5485}}, "n3337": {"so_30418270_30418323_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 5271}, "so_30418270_30418323_1": {"length": 22, "quality": 1.0, "section_id": 5271}}, "n4659": {"so_30418270_30418339_0": {"length": 29, "quality": 0.5087719298245614, "section_id": 6920}, "so_30418270_30418323_0": {"length": 17, "quality": 0.7083333333333334, "section_id": 6920}, "so_30418270_30418323_1": {"length": 22, "quality": 1.0, "section_id": 6920}}}, "30418270": {"ViewCount": "864", "Body": "<p>The following code which doesn't compile under clang but does under gcc and VS:</p>\n<pre><code>template&lt;typename T&gt; class bar;\n\nnamespace NS\n{\n    template&lt;typename T&gt;\n    class foo\n    {\n        foo() {}\n\n        template&lt;typename U&gt; friend class bar;\n    };\n}\n\ntemplate&lt;typename R&gt;\nclass bar\n{\npublic:\n    bar()\n    {\n        NS::foo&lt;int&gt; f;\n    }\n};\n\n\nint main(int, char **)\n{\n    bar&lt;int&gt; b;        \n    return 0;\n}\n</code></pre>\n<p>It fails with:</p>\n<pre><code>main.cpp:20:22: error: calling a private constructor of class 'NS::foo&lt;int&gt;'\n\n        NS::foo&lt;int&gt; f;    \n                     ^\n\nmain.cpp:8:9: note: implicitly declared private here\n\n        foo() {}   \n        ^\n</code></pre>\n<p><code>bar</code> should have access to <code>foo</code>'s private constructor but it looks like it doesn't. If I remove <code>namespace NS</code>, it compiles.</p>\n<p>Code looks fine to me, but maybe I'm misunderstanding the C++ standard. Which compiler is correct?</p>\n", "AcceptedAnswerId": "30418323", "Title": "clang bug? namespaced template class' friend", "CreationDate": "2015-05-23T22:41:42.590", "Id": "30418270", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-05-23T23:02:45.620", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-23T23:02:45.620", "Score": "13", "OwnerUserId": "1749713", "Tags": "<c++><g++><language-lawyer><clang++>", "AnswerCount": "3"}, "30418339": {"Id": "30418339", "PostTypeId": "2", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/namespace\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_30418270_30418339_0\">Names introduced by friend declarations within a non-local class X\n  become members of the innermost enclosing namespace of X, but they do\n  not become visible to lookup (neither unqualified nor qualified)\n  unless a matching declaration is provided at namespace scope, either\n  before or after the class definition. Such name may be found through\n  ADL which considers both namespaces and classes. Only the innermost\n  enclosing namespace is considered by such friend declaration when\n  deciding whether the name would conflict with a previously declared\n  name.</p>\n<pre><code>void h(int);\nnamespace A {\n  class X {\n    friend void f(X); // A::f is a friend\n    class Y {\n        friend void g(); // A::g is a friend\n        friend void h(int); // A::h is a friend, no conflict with ::h\n    };\n  };\n  // A::f, A::g and A::h are not visible at namespace scope\n  // even though they are members of the namespace A\n  X x;\n  void g() {  // definition of A::g\n     f(x); // A::X::f is found through ADL\n  }\n  void f(X) {}       // definition of A::f\n  void h(int) {}     // definition of A::h\n  // A::f, A::g and A::h are now visible at namespace scope\n  // and they are also friends of A::X and A::X::Y\n}\n</code></pre>\n</blockquote>\n<p>It's not the standard, but it is in general correct. So clang seems to be right.</p>\n", "LastActivityDate": "2015-05-23T22:52:16.460", "CommentCount": "0", "CreationDate": "2015-05-23T22:52:16.460", "ParentId": "30418270", "Score": "5", "OwnerUserId": "3093378"}, "30418305": {"Id": "30418305", "PostTypeId": "2", "Body": "<p>Changing the code to</p>\n<pre><code>template&lt;typename T&gt; class bar;\n\nnamespace NS\n{\n    template&lt;typename T&gt;\n    class foo\n    {\n        foo() {}\n\n        template&lt;typename U&gt; friend class ::bar;\n    };\n}\n\ntemplate&lt;typename R&gt;\nclass bar\n{\npublic:\n    bar()\n    {\n        NS::foo&lt;int&gt; f;\n    }\n};\n\n\nint main(int, char **)\n{\n    bar&lt;int&gt; b;\n\n    return 0;\n}\n</code></pre>\n<p>compiles with clang. The problem seems to be the namespace lookup.\nThe code</p>\n<pre><code>template&lt;typename U&gt; friend class bar;\n</code></pre>\n<p>actually declared the class NS::bar a friend of NS::foo, so foo should not have been affected. My guess would be that clang is standard conformant and the code should not compile.</p>\n", "LastEditorUserId": "4926844", "LastActivityDate": "2015-05-23T22:51:08.453", "Score": "2", "CreationDate": "2015-05-23T22:48:12.330", "ParentId": "30418270", "CommentCount": "1", "OwnerUserId": "4926844", "LastEditDate": "2015-05-23T22:51:08.453"}, "30418323": {"Id": "30418323", "PostTypeId": "2", "Body": "<p>I believe that clang is correct. According to [namespace.memdef]/3:</p>\n<blockquote>\n<p id=\"so_30418270_30418323_0\">Every name first declared in a namespace is a member of that namespace. If a <code>friend</code> declaration in a\n  non-local class first declares a class, function, class template or function template the friend is a member\n  of the innermost enclosing namespace.</p>\n</blockquote>\n<p>In your case, the name wouldn't appear to be \"first declared\" by the <code>friend</code> declaration. Later in that paragraph, however, emphasis mine:</p>\n<blockquote>\n<p id=\"so_30418270_30418323_1\">If the name in a <code>friend</code> declaration is neither qualified nor a <em>template-id</em> and\n  the declaration is a function or an <em>elaborated-type-specifier</em>, the lookup to determine whether the entity has\n  been previously declared <strong>shall not consider any scopes outside the innermost enclosing namespace</strong>.</p>\n</blockquote>\n<p>That is, this declaration:</p>\n<pre><code>template&lt;typename U&gt; friend class bar;\n</code></pre>\n<p>will not look for <code>bar</code> outside of <code>namespace NS</code>, so it will not find your earlier declaration. As such, it declares a class template <code>NS::bar&lt;typename &gt;</code> to be a <code>friend</code> of <code>foo</code>. You will have to <em>qualify</em> the name <code>bar</code> in order for it to be found:</p>\n<pre><code>template&lt;typename U&gt; friend class ::bar;\n</code></pre>\n<p>This seems related to <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37804\" rel=\"noreferrer\">GCC Bug 37804</a>.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-23T22:55:03.570", "Score": "14", "CreationDate": "2015-05-23T22:50:36.560", "ParentId": "30418270", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2015-05-23T22:55:03.570"}});