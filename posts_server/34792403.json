post_cb({"34792403": {"CommentCount": "5", "ViewCount": "528", "CreationDate": "2016-01-14T14:46:27.080", "LastActivityDate": "2016-01-14T15:58:27.330", "Title": "Having a constexpr static string gives a linker error", "AcceptedAnswerId": "34792443", "PostTypeId": "1", "Id": "34792403", "Score": "5", "Body": "<p>The following program gives me a link-time error:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Test { static constexpr char text[] = \"Text\"; };\n\nint main()\n{\n    std::cout &lt;&lt; Test::text &lt;&lt; std::endl; // error: undefined reference to `Test::text'\n}\n</code></pre>\n<p>The error message is</p>\n<pre><code>/tmp/main-35f287.o: In function `main':\nmain.cpp:(.text+0x4): undefined reference to `Test::text'\nmain.cpp:(.text+0x13): undefined reference to `Test::text'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre>\n<p>Ok. Let's try to fix that: I add a definition outside the <code>struct</code> body:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Test { static constexpr char text[] = \"Text\"; };\nconstexpr char Test::text[] = \"Text\";\n\nint main()\n{\n    std::cout &lt;&lt; Test::text &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Clang gives me the following error message. </p>\n<pre><code>main.cpp:4:35: error: static data member 'text' already has an initializer\n    constexpr char Test::text[] = \"Text\";\n                                  ^\nmain.cpp:3:50: note: previous initialization is here\n    struct Test { static constexpr char text[] = \"Text\"; };\n</code></pre>\n<p>Oh, well, I thought, now I know what you want:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Test { static constexpr char text[]; };\nconstexpr char Test::text[] = \"Text\";\n\nint main()\n{\n    std::cout &lt;&lt; Test::text &lt;&lt; std::endl;\n}\n</code></pre>\n<p>And again an error: </p>\n<pre><code>main.cpp:3:41: error: declaration of constexpr static data member 'text' requires an initializer\n    struct Test { static constexpr char text[]; };\n</code></pre>\n<p>And there the dog bites its own tail. :( </p>\n<p>Is there a way to use compile-time constant character arrays that are declared inside a class? The reason, I want the data inside a class, is that I need a type traits class that helps me do template stuff. </p>\n", "Tags": "<c++><string><c++11><constexpr><typetraits>", "OwnerUserId": "1335865", "AnswerCount": "2"}, "34793818": {"ParentId": "34792403", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2016-01-14T15:49:46.073", "Score": "2", "LastEditorUserId": "3772835", "LastEditDate": "2016-01-14T15:58:27.330", "Id": "34793818", "OwnerUserId": "3772835", "Body": "<p>As said in comments, this version works fine:</p>\n<pre><code>struct Test { static constexpr auto text = \"Text\"; };\n</code></pre>\n<p>But <code>text</code> will be a <code>const char*</code> instead of a <code>char[]</code>.</p>\n", "LastActivityDate": "2016-01-14T15:58:27.330"}, "bq_ids": {"n4140": {"so_34792403_34792443_0": {"section_id": 5908, "quality": 0.9047619047619048, "length": 38}}, "n3337": {"so_34792403_34792443_0": {"section_id": 5680, "quality": 0.9047619047619048, "length": 38}}, "n4659": {"so_34792403_34792443_0": {"section_id": 7390, "quality": 0.5714285714285714, "length": 24}}}, "34792443": {"ParentId": "34792403", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-01-14T14:48:42.210", "Score": "7", "LastEditorUserId": "471160", "LastEditDate": "2016-01-14T15:16:27.027", "Id": "34792443", "OwnerUserId": "471160", "Body": "<p>Should work:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Test { static constexpr char text[] = \"Text\"; };\nconstexpr char Test::text[];\n\nint main()\n{\n    std::cout &lt;&lt; Test::text &lt;&lt; std::endl;\n}\n</code></pre>\n<p>In standard (n4140 \u00a79.4.2/3) you can find:</p>\n<blockquote>\n<p id=\"so_34792403_34792443_0\"><strong><em>A static data member of literal type can be declared in the class\n  definition with the constexpr specifier</em></strong>; if so, its declaration shall\n  specify a brace-or-equal-initializer in which every initializer-clause\n  that is an assignment-expression is a constant expression. [ Note: In\n  both these cases, the member may appear in constant expressions. \u2014end\n  note ] <strong><em>The member shall still be defined in a namespace scope if it is\n  odr-used (3.2) in the program and the namespace scope definition shall\n  not contain an initializer</em></strong>.</p>\n</blockquote>\n", "LastActivityDate": "2016-01-14T15:16:27.027"}});