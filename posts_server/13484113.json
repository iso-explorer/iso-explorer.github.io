post_cb({"bq_ids": {"n4140": {"so_13484113_13484201_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 5795}, "so_13484113_13484201_1": {"length": 30, "quality": 0.8823529411764706, "section_id": 5787}, "so_13484113_13484285_0": {"length": 20, "quality": 0.5555555555555556, "section_id": 5879}}, "n3337": {"so_13484113_13484201_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 5568}, "so_13484113_13484285_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 5650}, "so_13484113_13484201_1": {"length": 30, "quality": 0.8823529411764706, "section_id": 5560}}, "n4659": {"so_13484113_13484201_1": {"length": 30, "quality": 0.8823529411764706, "section_id": 7244}, "so_13484113_13484285_0": {"length": 20, "quality": 0.5555555555555556, "section_id": 7363}, "so_13484113_13484201_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 7254}}}, "13484113": {"ViewCount": "1390", "Body": "<p>I recently tried debugging a small program by printing the values of several pointers to the console. The first was the memory address of a struct, and the others were the memory addresses of its fields. A stripped-down version of the code is as follows:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct testingPointers\n{\n    int i;\n    float f;\n    double d;\n} test;\n\nint main()\n{\n   std::cout &lt;&lt; &amp;test &lt;&lt; '\\n' &lt;&lt; &amp;(test.i) &lt;&lt; '\\n' &lt;&lt; \n            &amp;(test.f) &lt;&lt; '\\n' &lt;&lt; &amp;(test.d);\n}\n</code></pre>\n<p>And the output is:</p>\n<pre><code>0x681110\n0x681110\n0x681114\n0x681118\n</code></pre>\n<p>(obviously the exact values are different for different runs but they always have the same positions relative to each other).</p>\n<p>I am confused because the value of first pointer--the memory location of <code>test</code>--is the same as that of the second one (the first field of <code>test</code>). Does this mean that objects have no real unique memory address, and that a pointer to a struct or class simply points to its first field? If so, how do statements like </p>\n<pre><code>a.b\na-&gt;b\na.b()\n</code></pre>\n<p>make sense if <code>a</code> is actually just its first field, and therefore does not have any fields or methods?</p>\n", "AcceptedAnswerId": "13484201", "Title": "pointer to struct or class versus pointer to first field", "CreationDate": "2012-11-20T23:40:53.677", "Id": "13484113", "CommentCount": "4", "LastEditDate": "2016-07-13T16:16:23.270", "PostTypeId": "1", "LastEditorUserId": "1530508", "LastActivityDate": "2016-07-13T16:16:23.270", "Score": "6", "OwnerUserId": "1530508", "Tags": "<c++><oop><pointers><struct><field>", "AnswerCount": "4"}, "13484201": {"Id": "13484201", "PostTypeId": "2", "Body": "<p>A class or struct just describes a collection of fields that should be kept together in memory, and have some semantic relationship between them and some operations that operate over them. There is, in the simple case, nothing much more to the content of a class type object in memory than the members it is made up of (and some padding). When you have a <code>testingPointers</code> object in memory, it is really just an <code>int</code>, a <code>float</code> and a <code>double</code>. The concept of the class was only used to generate the correct executable code - it does not exist at run time (at least not for this purpose).</p>\n<p>The important part from the standard regarding whether objects can share memory addresses is \u00a71.8/6:</p>\n<blockquote>\n<p id=\"so_13484113_13484201_0\">Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the first byte it occupies. Two objects that are not bit-fields may have the same address if one is a subobject of the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, they shall have distinct addresses.</p>\n</blockquote>\n<p>We can infer from this that because member <code>test.i</code> is a subobject of <code>test</code>, they may well have the same address.</p>\n<p>Once you look inside all of the objects of your program as deep as you can go, what you really have is a big collection of scalar values and adjacent bit-fields. These are known as <em>memory locations</em> in the standard. These are the things that really take up space. The rest of your objects are all in some way composed of these.</p>\n<blockquote>\n<p id=\"so_13484113_13484201_1\">A <em>memory location</em> is either an object of scalar type or a maximal sequence of adjacent bit-fields all having non-zero width. [ <em>Note:</em> Various features of the language, such as references and virtual functions, might involve additional memory locations that are not accessible to programs but are managed by the implementation. \u2014 <em>end note</em> ]</p>\n</blockquote>\n", "LastEditorUserId": "150634", "LastActivityDate": "2012-11-20T23:54:55.727", "Score": "5", "CreationDate": "2012-11-20T23:47:54.127", "ParentId": "13484113", "CommentCount": "0", "OwnerUserId": "150634", "LastEditDate": "2012-11-20T23:54:55.727"}, "13484612": {"Id": "13484612", "PostTypeId": "2", "Body": "<p>Just to clarify your confusions:</p>\n<p><strong>1).value of first pointer--the memory location of test--is the same as that of the second one (the first field of test).</strong><br>\nAddress of Struct and its first field got to be the same since struct is nothing both the collection of its fields contiguously. </br></p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/9xLjh.jpg\"/></p>\n<p>You can also consider the case of arrays to further simplify the understanding, wherein the address of the array will obviously be equal to the first element (field) of the array.  </p>\n<p><strong>2).Does this mean that objects have no real unique memory address, and that a pointer to a struct or class simply points to its first field?</strong><br>\nI think you are confusing it with that of JAVA wherein the Object is always allocated on Heap. In C++, struct/class is always allocated on Stack unless it's dynamic memory allocation (using 'new' operator) where the object is allocated in heap and a pointer variable (in Stack) will point to that object in heap. Therefore, in the former case the struct variable will always have the same address as that of its first element (field).</br></p>\n<p>Hope that helps.</p>\n", "LastActivityDate": "2012-11-21T00:38:57.090", "CommentCount": "1", "CreationDate": "2012-11-21T00:38:57.090", "ParentId": "13484113", "Score": "3", "OwnerUserId": "254567"}, "13484285": {"Id": "13484285", "PostTypeId": "2", "Body": "<p>The address of an object shall always be the address of the first non-static member within that object. Quoting from the standard (C++11-9.2-20):</p>\n<blockquote>\n<p id=\"so_13484113_13484285_0\"><strong>A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa.</strong> [ Note: There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment.</p>\n</blockquote>\n<p>The requirements for <em>standard-layout</em> are mentioned here: <a href=\"http://en.cppreference.com/w/cpp/concept/StandardLayoutType\" rel=\"nofollow\">StandardLayoutType</a>.</p>\n<p>This can certainly be applied via nesting. The standard makes no exceptions for the <em>type</em> of the first member <em>except</em> for bit-fields. I.e.:</p>\n<pre><code>class X\n{\npublic:\n    int x;\n};\n\nclass Y\n{\npublic:\n    X x;\n    int y;\n};\n\nY yobj;\n</code></pre>\n<p>By the standard, <code>&amp;yobj == &amp;yobj.x == &amp;yobj.x.x</code>.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2016-07-13T08:00:48.827", "Score": "6", "CreationDate": "2012-11-20T23:58:13.367", "ParentId": "13484113", "CommentCount": "1", "OwnerUserId": "1322972", "LastEditDate": "2016-07-13T08:00:48.827"}, "13484205": {"Id": "13484205", "PostTypeId": "2", "Body": "<p>A struct in memory consists of nothing more than its fields strung together.  There may be padding before the struct and/or between the fields, based on alignment needs, but there's not usually any extra \"stuff\" before the first field.   So the first field and the struct itself have the same address.</p>\n<p>Remember that in C, types exist only at compile time.</p>\n", "LastActivityDate": "2012-11-20T23:48:41.013", "CommentCount": "2", "CreationDate": "2012-11-20T23:48:41.013", "ParentId": "13484113", "Score": "1", "OwnerUserId": "797049"}});