post_cb({"12343846": {"ParentId": "12343690", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2012-09-09T23:34:18.207", "Score": "1", "LastEditorUserId": "15168", "LastEditDate": "2012-09-10T01:52:38.183", "Id": "12343846", "OwnerUserId": "15168", "Body": "<p>This adaptation of your code produces the answer you need.  Your code is apt to produce the answer with the bits in the wrong order.  Exhaustive testing of decimal values 123, 1234567890, 12345678901234567 show it working OK (G++ 4.7.1 on Mac OS X 10.7.4).</p>\n<pre><code>#include &lt;iostream&gt;\n#include&lt;sstream&gt;\nusing namespace std;\nint main()\n{\n    long long int answer;\n    long long dec;\n    string binNum;\n    cout&lt;&lt;\"Enter the decimal to be converted:\"&lt;&lt; endl;;\n    cin&gt;&gt;dec;\n    cout&lt;&lt;\"The dec number is: \"&lt;&lt;dec&lt;&lt;endl;\n    while(dec&gt;0)\n    {\n        stringstream ss;\n        answer = dec%2;\n        dec=dec/2;\n        ss&lt;&lt;answer;\n        binNum.insert(0, ss.str());\n//      cout &lt;&lt; \"ss&lt;&lt;\" &lt;&lt; ss.str() &lt;&lt; \"&gt;&gt;   bn&lt;&lt;\" &lt;&lt; binNum.c_str() &lt;&lt; \"&gt;&gt;\" &lt;&lt; endl;\n    }\n    cout&lt;&lt;\"The binary of the given number is: \" &lt;&lt; binNum.c_str() &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Test runs:</p>\n<pre><code>$ ./bd\nEnter the decimal to be converted:\n123\nThe dec number is: 123\nThe binary of the given number is: 1111011\n$ ./bd\nEnter the decimal to be converted:\n1234567890\nThe dec number is: 1234567890\nThe binary of the given number is: 1001001100101100000001011010010\n$ ./bd\nEnter the decimal to be converted:\n12345678901234567\nThe dec number is: 12345678901234567\nThe binary of the given number is: 101011110111000101010001011101011010110100101110000111\n$ bc\nbc 1.06\nCopyright 1991-1994, 1997, 1998, 2000 Free Software Foundation, Inc.\nThis is free software with ABSOLUTELY NO WARRANTY.\nFor details type `warranty'. \nobase=2\n123\n1111011\n1234567890\n1001001100101100000001011010010\n12345678901234567\n101011110111000101010001011101011010110100101110000111\n$\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_12343690_12343846_0\">When I compile this with the largest value possible for a 64 bit machine, nothing shows up for my binary value.</p>\n</blockquote>\n<pre><code>$ bc 1.06\nCopyright 1991-1994, 1997, 1998, 2000 Free Software Foundation, Inc.\nThis is free software with ABSOLUTELY NO WARRANTY.\nFor details type `warranty'. \n2^63-1\n9223372036854775807\nquit\n$ ./bd\nEnter the decimal to be converted:\n9223372036854775807\nThe dec number is: 9223372036854775807\nThe binary of the given number is: 111111111111111111111111111111111111111111111111111111111111111\n$\n</code></pre>\n<p>If you choose a larger value for the largest value that can be represented, all bets are off; you may get a 0 back from <code>cin &gt;&gt; dec;</code> and the code does not handle 0 properly.</p>\n<hr>\n<h3>Prelude</h3>\n<p>The original code in the question was:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    int rem,i=1,sum=0;\n    long long int dec = 9223372036854775808; // = 2^63     9223372036854775807 =  2^63-1\n    cout&lt;&lt;\"The dec number is\"&lt;&lt;dec&lt;&lt;endl;\n    while(dec&gt;0)\n    {\n        rem=dec%2;\n        sum=sum + (i*rem);\n        dec=dec/2;\n        i=i*10;\n    }\n    cout&lt;&lt;\"The binary of the given number is:\"&lt;&lt;sum&lt;&lt;endl;\n    return 0;\n}\n</code></pre>\n<p>I gave this analysis of the earlier code:</p>\n<blockquote>\n<p id=\"so_12343690_12343846_1\">You are multiplying the plain <code>int</code> variable <code>i</code> by 10 for every bit position in the 64-bit number.  Given that <code>i</code> is probably a 32-bit quantity, you are running into signed integer overflow, which is undefined behaviour.  Even if <code>i</code> was a 128-bit quantity, it would not be big enough to handle all possible 64-bit numbers (such as 2<sup>63</sup>-1) accurately.</p>\n</blockquote>\n</hr></hr>", "LastActivityDate": "2012-09-10T01:52:38.183"}, "12343690": {"CommentCount": "12", "ViewCount": "919", "PostTypeId": "1", "LastEditorUserId": "707126", "CreationDate": "2012-09-09T23:00:34.093", "LastActivityDate": "2012-09-10T04:38:18.213", "Title": "Undefined behavior when exceed 64 bits", "AcceptedAnswerId": "12343849", "LastEditDate": "2012-09-10T04:38:18.213", "Id": "12343690", "Score": "0", "Body": "<p>I have written a function that converts a decimal number to a binary number. I enter my decimal number as a <code>long long int</code>. It works fine with small numbers, but my task is to determine how the computer handles overflow so when I enter (2^63) - 1 the function outputs that the decimal value is  9223372036854775808 and in binary it is equal to -954437177. When I input 2^63 which is a value a 64 bit machine can't hold, I get warnings that the integer constant is so large that it is unsigned and that the decimal constant is unsigned only in ISO C90 and the output of the decimal value is negative 2^63 and binary number is 0. I'm using gcc as a compiler. Is that outcome correct? </p>\n<p>The code is provided below:</p>\n<pre><code>#include &lt;iostream&gt;\n#include&lt;sstream&gt;\nusing namespace std;\nint main()\n{\nlong long int answer;\nlong long dec;\nstring binNum;\nstringstream ss;\ncout&lt;&lt;\"Enter the decimal to be converted:\"&lt;&lt; endl;;\ncin&gt;&gt;dec;\ncout&lt;&lt;\"The dec number is: \"&lt;&lt;dec&lt;&lt;endl;\nwhile(dec&gt;0)\n{\n     answer = dec%2;\n     dec=dec/2;\n     ss&lt;&lt;answer;\n     binNum=ss.str();\n}\ncout&lt;&lt;\"The binary of the given number is: \";\nfor (int i=sizeof(binNum);i&gt;=0;i--){\n     cout&lt;&lt;binNum[i];}\nreturn 0;\n    }\n</code></pre>\n", "Tags": "<c++><64bit><overflow>", "OwnerUserId": "707126", "AnswerCount": "2"}, "12343849": {"ParentId": "12343690", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2012-09-09T23:35:13.090", "Score": "7", "LastEditorUserId": "464581", "LastEditDate": "2012-09-09T23:45:50.150", "Id": "12343849", "OwnerUserId": "464581", "Body": "<p>First, \u201con a 64-bit computer\u201d is meaningless: <code>long long</code> is guaranteed at least 64 bits regardless of computer. If could press a modern C++ compiler onto a Commodore 64 or a Sinclair ZX80, or for that matter a KIM-1, a <code>long long</code> would still be at least 64 bits. This is a machine-independent guarantee given by <em>the C++ standard</em>.</p>\n<p>Secondly, specifying a too large value is <em>not</em> the same as \u201coverflow\u201d.</p>\n<p>The only thing that makes this question a little bit interesting is that there is a difference. And that the standard treats these two cases differently. For the case of initialization of a signed integer with an integer value a <em>conversion</em> is performed if necessary, with implementation-defined effect if the value cannot be represented, \u2026</p>\n<blockquote>\n<p id=\"so_12343690_12343849_0\"><strong>C++11 \u00a74.7/3</strong>: \n  \u201cIf the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined\u201d</p>\n</blockquote>\n<p>while for the case of e.g. a multiplication that produces a value that cannot be represented by the argument type, the effect is undefined (e.g., might even crash) \u2026</p>\n<blockquote>\n<p id=\"so_12343690_12343849_1\"><strong>C++11 \u00a75/4</strong>: \n  \u201cIf during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined.\u201d</p>\n</blockquote>\n<p>Regarding the code I I only discovered it after writing the above, but it does look like it will necessarily produce overflow (i.e. Undefined Behavior) for sufficiently large number. Put your digits in a <code>vector</code> or <code>string</code>. Note that you can also just use a <code>bitset</code> to display the binary digits.</p>\n<p>Oh, the KIM-1. Not many are familiar with it, so here\u2019s a photo:</p>\n<p><img alt=\"KIM-1 single-board computer\" src=\"https://i.stack.imgur.com/ibwRF.jpg\"/></p>\n<p>It was, reportedly, very nice, in spite of the somewhat restricted keyboard.</p>\n", "LastActivityDate": "2012-09-09T23:45:50.150"}, "bq_ids": {"n4140": {"so_12343690_12343849_1": {"section_id": 5937, "quality": 0.9285714285714286, "length": 13}, "so_12343690_12343849_0": {"section_id": 32, "quality": 0.8125, "length": 13}}, "n3337": {"so_12343690_12343849_1": {"section_id": 5709, "quality": 0.9285714285714286, "length": 13}, "so_12343690_12343849_0": {"section_id": 29, "quality": 0.8125, "length": 13}}, "n4659": {"so_12343690_12343849_1": {"section_id": 7421, "quality": 0.9285714285714286, "length": 13}, "so_12343690_12343849_0": {"section_id": 32, "quality": 0.6875, "length": 11}}}});