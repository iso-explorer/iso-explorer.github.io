post_cb({"1483027": {"LastActivityDate": "2009-09-27T07:38:43.687", "CommentCount": "0", "Body": "<p><strong>set_terminate</strong></p>\n<p>function installs term_func as the function called by terminate. set_terminate is used with C++ exception handling and may be called at any point in your program before the exception is thrown. terminate calls abort by default. You can change this default by writing your own termination function and calling set_terminate with the name of your function as its argument. terminate calls the last function given as an argument to set_terminate. After performing any desired cleanup tasks, </p>\n<p><strong>term_func should exit the program</strong>. </p>\n<p><strong>If it does not exit (if it returns to its caller), abort is called</strong>.</p>\n<p>my_terminate() should look like :</p>\n<pre><code>void my_terminate() \n{\n  cout &lt;&lt; \"Call to my_terminate\" &lt;&lt; endl;\n  *\n  *\n  *\n  exit(-1);\n\n}\n</code></pre>\n", "PostTypeId": "2", "LastEditDate": "2009-09-27T07:38:43.687", "ParentId": "1482908", "Id": "1483027", "OwnerUserId": "177584", "Score": "1", "CreationDate": "2009-09-27T07:32:56.520", "LastEditorUserId": "177584"}, "1483193": {"LastActivityDate": "2009-09-27T17:35:57.023", "CommentCount": "1", "Body": "<p>Here is the problem. Your A's destructor throws, which is a <strong>bad thing</strong>. Re-throwing exceptions, or throwing a new exception in an exception handler is kosher because the stack-unwinding is well-behaved. In that case, only <strong>one</strong> exception is alive at the current stack frame. When a destructor throws an exception during the stack unwinding process however, <strong>two</strong> exceptions are alive the same stack frame, i.e they unwind the stack on the same level. In your case, that's two E objects. So which one does one choose to follow? You cannot follow both, so the standard says that <strong><code>terminate()</code></strong> will be called. You can make the exception system use your custom terminate routine by passing one with <strong><code>std::set_terminate()</code></strong> from the header <strong><code>&lt;exception&gt;</code></strong>.</p>\n<p>You seem to think that your <strong><code>std::terminate()</code></strong> handler can resume your program by returning, but that's undefined behavior.<br>\nIf you absolutely positively need to throw from a destructor and can't contain it with an exception handler inside the destructor itself, here is a workaround:</br></p>\n<p>The function <strong><code>uncaught_exception()</code></strong> from the header <strong><code>&lt;exception&gt;</code></strong> returns true if an exception has been thrown, but not yet caught. If it returns true, that means that the process is in the middle of a stack unwinding, unwinding the stack and calling destructors until it finds a proper exception handler. Use the function inside destructors which throw, so that they <strong>only throw</strong> when a stack unwinding is not happening.</p>\n<p><em>Here's an example on how to use</em> <strong><code>uncaught_exception()</code></strong> (Though, it's an extremely bad idea):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;exception&gt;\n#include &lt;stdexcept&gt;\n#include &lt;sstream&gt;\n#include &lt;cstdlib&gt;\n\nvoid termhandler()\n{\n    std::cout &lt;&lt; \"Inside terminate()\" &lt;&lt; std::endl;\n    abort();\n}\n\nclass Foo\n{\npublic:\n    Foo(int val) : i(val){ std::cout &lt;&lt; \"Created Foo object \" &lt;&lt; i &lt;&lt; std::endl; }\n    ~Foo()\n    {\n        if(std::uncaught_exception()){\n            std::cout &lt;&lt; \"~Foo::Foo() object \" &lt;&lt; i &lt;&lt; \" : \" &lt;&lt; \"Stack unwinding in progress. Can't throw!\" &lt;&lt; std::endl;\n        } else {\n            std::cout &lt;&lt; \"~Foo::Foo() object \" &lt;&lt; i &lt;&lt; \" : \" &lt;&lt; \"Throwing test exception.\" &lt;&lt; std::endl;\n            std::ostringstream strm;\n            strm &lt;&lt; i;\n            std::runtime_error e(\"Exception from ~Foo::Foo() object \" + strm.str());\n            throw e;\n        }\n    }\n    int i;\n};\n\nint main()\n{\n    try {\n        std::set_terminate(termhandler);    \n        Foo A(1);\n        Foo B(2);\n    } catch(std::exception&amp; e){\n        std::cout &lt;&lt; \"Caught exception in main() : \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>Which gives the following output:</p>\n<p>Created Foo object 1<br>\nCreated Foo object 2<br>\n~Foo::Foo() object 2 : Throwing test exception.<br>\n~Foo::Foo() object 1 : Stack unwinding in progress. Can't throw!<br>\nCaught exception in main() : Exception from ~Foo::Foo() object 2<br/></br></br></br></br></p>\n", "CreationDate": "2009-09-27T09:36:09.190", "OwnerDisplayName": "Mads Elvheim", "LastEditDate": "2009-09-27T17:35:57.023", "ParentId": "1482908", "Id": "1483193", "LastEditorDisplayName": "Mads Elvheim", "PostTypeId": "2", "Score": "0"}, "1482964": {"LastActivityDate": "2009-09-27T07:27:10.850", "CommentCount": "1", "Body": "<p>When you throw the original <code>E</code> temporary from the <code>try</code> block in <code>main</code>, the runtime implementation constructs an exception object of type <code>E</code> and searches for the first <code>catch</code> block that can handle the exception. In this case, this is the immediately following <code>catch (E&amp; e)</code> block.</p>\n<p>When the implementation finds the correct <code>catch</code> to handle the exception, it then destroys all automatic variables which must go out of scope by moving out of the scope where the <code>throw</code> occurred to the scope in which the catch resides.</p>\n<p>In this case the objects <code>a</code> and <code>b</code> which are local to the catch block go out of scope, so must be destroyed (in the reverse order that they were created). However, destroying <code>a</code> causes another exception to be thrown. Because the implementation already has an uncaught exception and has already chosen a catch handler for that exception which it is trying to reach, there is no mechanism to handle this new exception. The rule in this case is that <code>std::terminate</code>, and in your case your terminate handler, is called immediately.</p>\n<p>You should note that your <code>my_terminate</code> function is not a conforming <code>terminate_handler</code>, as a <code>terminate_handler</code> must not <code>return</code> and must terminate the program execution (i.e. must not <code>throw</code> either). Yours returns implicitly.</p>\n", "PostTypeId": "2", "LastEditDate": "2009-09-27T07:27:10.850", "ParentId": "1482908", "Id": "1482964", "OwnerUserId": "19563", "Score": "3", "CreationDate": "2009-09-27T06:57:37.350", "LastEditorUserId": "19563"}, "bq_ids": {"n4140": {"so_1482908_1482933_0": {"length": 28, "quality": 0.7777777777777778, "section_id": 3345}}, "n3337": {"so_1482908_1482933_0": {"length": 29, "quality": 0.8055555555555556, "section_id": 3215}}}, "1482908": {"FavoriteCount": "0", "ViewCount": "583", "Id": "1482908", "AcceptedAnswerId": "1482916", "Score": "3", "Title": "Confusion in exception handling", "LastEditorUserId": "165520", "CommentCount": "4", "Body": "<p>Consider the following program</p>\n<pre><code>#include &lt;iostream&gt;\n#include&lt;cstdlib&gt;\nusing namespace std;\n\nclass E {\n   public:\n      const char* error;\n      E(const char* arg) : error(arg) { }\n};\n\nvoid my_terminate() {\n  cout &lt;&lt; \"Call to my_terminate\" &lt;&lt; endl;\n}\n\nstruct A {\n  A() { cout &lt;&lt; \"In constructor of A\" &lt;&lt; endl; }\n  ~A(){\n    cout &lt;&lt; \"In destructor of A\" &lt;&lt; endl;\n    throw E(\"Exception thrown in ~A()\");\n  }\n};\n\nstruct B {\n  B() { cout &lt;&lt; \"In constructor of B\" &lt;&lt; endl; }\n  ~B() { cout &lt;&lt; \"In destructor of B\" &lt;&lt; endl; }\n};\n\nint main() {\n\n  set_terminate(my_terminate);\n\n  try {\n    cout &lt;&lt; \"In try block\" &lt;&lt; endl;\n    A a;\n    B b;\n    throw E(\"Exception thrown in try block of main()\"); // Line 36\n  }\n  catch (E&amp; e) {\n    cout &lt;&lt; \"Exception: \" &lt;&lt; e.error &lt;&lt; endl;\n  }\n  catch (...) {\n    cout &lt;&lt; \"Some exception caught in main()\" &lt;&lt; endl;\n  }\n\n  cout &lt;&lt; \"Resume execution of main()\" &lt;&lt; endl;\n\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>In try block\nIn constructor of A\nIn constructor of B\nIn destructor of B\nIn destructor of A\nCall to my_terminate\n\nDisallowed system call: SYS_kill\n</code></pre>\n<p>In line 36 an exception is thrown from the try block in main. Now why is this exception not caught by the handler?</p>\n<p>Rather the 'stack unwinding' process continues.The destructor of A throws an exception too which is again not caught by any handler,instead a call to <code>my_terminate</code> is made, why?</p>\n<p>Why is the handler not called in the two cases?</p>\n", "Tags": "<c++>", "CreationDate": "2009-09-27T06:01:30.027", "LastEditDate": "2010-01-01T12:17:53.760", "LastActivityDate": "2010-01-01T12:17:53.760", "PostTypeId": "1", "AnswerCount": "5", "OwnerUserId": "165520"}, "1482933": {"LastActivityDate": "2009-09-27T06:32:23.283", "CommentCount": "2", "Body": "<p>In section 15.2 of my draft standard it states:</p>\n<blockquote>\n<p id=\"so_1482908_1482933_0\">3 The process of calling destructors\n  for automatic objects constructed on\n  the path from a try block to a\n  throw-expression is called \u201cstack\n  unwinding.\u201d [ Note: If a destructor\n  called during stack unwinding exits\n  with an exception, std::terminate is\n  called (15.5.1). So destructors should\n  generally catch exceptions and not let\n  them propagate out of the destructor.\n  \u2014end note ]</p>\n</blockquote>\n<p>They have defined <em>\"stack unwinding\"</em> broadly enough that it seems to cover this case, even if it is all happening within one function. I guess it's somewhat clear that implementations expect destructors not to try and propagate exceptions outward.</p>\n", "PostTypeId": "2", "LastEditDate": "2009-09-27T06:32:23.283", "ParentId": "1482908", "Id": "1482933", "OwnerUserId": "140740", "Score": "0", "CreationDate": "2009-09-27T06:25:39.023", "LastEditorUserId": "140740"}, "1482916": {"CommentCount": "8", "CreationDate": "2009-09-27T06:10:24.613", "Body": "<p><a href=\"http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.3\" rel=\"nofollow noreferrer\">The C++ rule is that you must never throw an exception from a destructor that is being called during the \"stack unwinding\" process of another exception.</a></p>\n<p>You throw an exception in <code>A</code>'s destructor, which is something you are not supposed to do.</p>\n", "PostTypeId": "2", "ParentId": "1482908", "Id": "1482916", "LastActivityDate": "2009-09-27T06:10:24.613", "Score": "17", "OwnerUserId": "19254"}});