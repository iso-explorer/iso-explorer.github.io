post_cb({"13912666": {"ParentId": "13910747", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can't deduce the type of a non-type template argument in template argument deduction.  This is explicitly stated in the standard:</p>\n<blockquote>\n<h3>14.8.2.5 Deducing template arguments from a type [temp.deduct.type]</h3>\n<p id=\"so_13910747_13912666_0\">13 - A template type argument cannot be deduced from the type of a non-type template-argument.<br/>\n  14 - [Example:</p>\n<pre><code>template&lt;class T, T i&gt; void f(double a[10][i]);\nint v[10][20];\nf(v); // error: argument for template-parameter T cannot be deduced\n</code></pre>\n<p id=\"so_13910747_13912666_1\">\u2014 end example ]</p>\n</blockquote>\n<p>This works:</p>\n<pre><code>// Version C\ntemplate&lt;typename T1, template&lt;typename, size_t...&gt; class T, size_t... N&gt;\nvoid f(const T&lt;T1, N...&gt;&amp;) {\n    std::cout&lt;&lt;\"Version C\"&lt;&lt;std::endl;\n}\n</code></pre>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2012-12-17T15:47:18.890", "Id": "13912666", "Score": "3", "CreationDate": "2012-12-17T10:49:51.307", "LastActivityDate": "2012-12-17T15:47:18.890"}, "13910747": {"CommentCount": "5", "ViewCount": "235", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-12-17T08:38:31.030", "LastActivityDate": "2012-12-17T15:47:18.890", "Title": "Force a specific overload when template<typename, value...>", "AcceptedAnswerId": "13912666", "LastEditDate": "2017-05-23T11:57:46.360", "Id": "13910747", "Score": "3", "Body": "<p>This question follows : <a href=\"https://stackoverflow.com/q/13910355/882932\">Force a specific overload when template template</a></p>\n<p>Consider the following code :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;array&gt;\n#include &lt;type_traits&gt;\n\n// Version A\ntemplate&lt;typename T&gt;\nvoid f(const T&amp; x)\n{\n    std::cout&lt;&lt;\"Version A\"&lt;&lt;std::endl;\n}\n\n// Version B\ntemplate&lt;typename... T1, template&lt;typename...&gt; class T&gt;\nvoid f(const T&lt;T1...&gt;&amp; x)\n{\n    std::cout&lt;&lt;\"Version B\"&lt;&lt;std::endl;\n}\n\n// Version C\ntemplate&lt;typename T1, typename TN, template&lt;typename, TN...&gt; class T, TN... N&gt;\nvoid f(const T&lt;T1, N...&gt;&amp; x)\n{\n    std::cout&lt;&lt;\"Version C\"&lt;&lt;std::endl;\n}\n\n// Main\nint main(int argc, char* argv[])\n{\n    f(double());\n    f(std::vector&lt;double&gt;());\n    f(std::array&lt;double, 3&gt;()); // &lt;- How to force the use of Version C ?\n    return 0;\n}\n</code></pre>\n<p>By default, it will produce (with GCC 4.7.1) :</p>\n<pre><code>Version A\nVersion B\nVersion A\n</code></pre>\n<p>How to force the use of <code>Version C</code> when the passed type is a template with the good shape (I can add new versions of <code>f</code>, I can add <code>std::enable_if</code> or other C++11 type traits syntax, but if possible I would like to avoid adding an helper class) ?</p>\n<p>Note : The trick should work for every integral type TN...</p>\n", "Tags": "<c++><templates><c++11><metaprogramming>", "OwnerUserId": "882932", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_13910747_13912666_0": {"section_id": 344, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_13910747_13912666_0": {"section_id": 334, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_13910747_13912666_0": {"section_id": 309, "quality": 0.5555555555555556, "length": 5}}}});