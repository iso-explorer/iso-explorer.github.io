post_cb({"9259119": {"Id": "9259119", "PostTypeId": "2", "Body": "<p>I don't see why it could not be possible, however it is a quality of implementation detail.</p>\n<p>It has been traditional to use memoization for templates for example, so that compilers no longer choke on:</p>\n<pre><code>template &lt;size_t N&gt;\nstruct Fib { static size_t const value = Fib &lt;N-1&gt;::value + Fib&lt;N-2&gt;::value; };\n\ntemplate &lt;&gt;\nstruct Fib&lt;1&gt; { static size_t const value = 1; }\n\ntemplate &lt;&gt;\nstruct Fib&lt;0&gt; { static size_t const value = 0; }\n</code></pre>\n<p>but instead memoize the already computed value to reduce the complexity of its evaluation to O(N).</p>\n<p>Tail-recursion (and pseudo tail-recursion) are optimizations, and like most optimizations are not subjected to the Standard, so there is no reason it would not be possible. Whether a particular compiler uses it or not, however, is hard to predict.</p>\n<p>The Standard says in 5.19 <strong>[expr.const]</strong>:</p>\n<blockquote>\n<p id=\"so_9258525_9259119_0\">2/ A conditional-expression is a core constant expression unless it involves one of the following as a potentially evaluated subexpression (3.2) [...]:</p>\n<ul>\n<li>an invocation of a constexpr function or a constexpr constructor that would exceed the implementationdefined recursion limits (see Annex B);</li>\n</ul>\n</blockquote>\n<p>And reading Annex B:</p>\n<blockquote>\n<p id=\"so_9258525_9259119_1\">2/ The limits may constrain quantities that include those described below or others. The bracketed number following each quantity is recommended as the minimum for that quantity. However, these quantities are only guidelines and do not determine compliance.</p>\n<ul>\n<li>Recursive constexpr function invocations [512].</li>\n</ul>\n</blockquote>\n<p>Tail recursion is not brooched.</p>\n", "LastActivityDate": "2012-02-13T10:45:19.267", "CommentCount": "2", "CreationDate": "2012-02-13T10:45:19.267", "ParentId": "9258525", "Score": "4", "OwnerUserId": "147192"}, "bq_ids": {"n4140": {"so_9258525_9259119_0": {"length": 7, "quality": 0.7, "section_id": 6185}, "so_9258525_9320911_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6185}, "so_9258525_9259119_1": {"length": 22, "quality": 0.9166666666666666, "section_id": 47}}, "n3337": {"so_9258525_9259119_0": {"length": 10, "quality": 1.0, "section_id": 5946}, "so_9258525_9320911_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5946}}, "n4659": {"so_9258525_9320911_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 7687}, "so_9258525_9259119_1": {"length": 22, "quality": 0.9166666666666666, "section_id": 48}}}, "9258525": {"ViewCount": "3142", "Body": "<p>I wonder whether for long loops we can take advantage of tail recursion for constexpr in C++11?</p>\n", "AcceptedAnswerId": "9320911", "Title": "Can constexpr function evaluation do tail recursion optimization", "CreationDate": "2012-02-13T09:56:17.540", "Id": "9258525", "CommentCount": "9", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-03-04T15:22:03.203", "LastEditorUserId": "179910", "LastActivityDate": "2015-10-23T23:05:12.563", "Score": "14", "OwnerUserId": "34509", "Tags": "<c++><c++11><language-lawyer><constexpr>", "AnswerCount": "5"}, "9258978": {"Id": "9258978", "PostTypeId": "2", "Body": "<p>I've seen GCC perform this optimization. Here's an example:</p>\n<pre><code>constexpr unsigned long long fun1(unsigned long long n, unsigned long long sum = 0) {\n  return (n != 0) ? fun1(n-1,sum+n) : sum;\n}\nfun1(0xFFFFFFFF);\n</code></pre>\n<p>Works on -O2, crashes otherwise.</p>\n<p>Surprisingly, it is also optimizing this:</p>\n<pre><code>constexpr unsigned long long fun2(unsigned long long n) {\n  return (n != 0) ? n + fun2(n-1) : 0;\n}\n</code></pre>\n<p>I've check the disassembly of the non-conspexpr form and I can confirm that it is being optimized into a loop. </p>\n<p>But not this:</p>\n<pre><code>constexpr unsigned long long fun3(unsigned long long n) {\n  return (n != 0) ? n + fun3(n-1) + fun3(n-1) : 0;\n}\n</code></pre>\n<p>So in conclusion, GCC will optimize into a loop the same it does for non-consexpr functions. Use at least -O2 and up.</p>\n", "LastEditorUserId": "964135", "LastActivityDate": "2012-02-13T10:39:18.007", "Score": "-1", "CreationDate": "2012-02-13T10:33:31.780", "ParentId": "9258525", "CommentCount": "3", "OwnerUserId": "964135", "LastEditDate": "2012-02-13T10:39:18.007"}, "9259455": {"Id": "9259455", "PostTypeId": "2", "Body": "<p>I'm not sure I understand what you're asking.  If it concerns whether\nthe compiler will convert tail recursion into a loop, it's unspecified,\nwhether the function is a <code>constexpr</code> or not.  If it is whether a\nrecursive function can be a <code>constexpr</code>, then I don't think tail \nrecursion is relevant.  If I read the standard correctly: </p>\n<pre><code>constexpr unsigned ack( unsigned m, unsigned n )\n{\n    return m == 0\n        ? n + 1\n        : n == 0\n        ? ack( m - 1, 1 )\n        : ack( m - 1, ack( m, n - 1 ) );\n}\n</code></pre>\n<p>is a valid constexpr (although I expect the compiler will complain about\na lack of resources for all but the smallest <code>n</code> and <code>m</code>, at least if\nthe function is used in a context which requires a constant expression).</p>\n", "LastActivityDate": "2012-02-13T11:10:10.033", "CommentCount": "1", "CreationDate": "2012-02-13T11:10:10.033", "ParentId": "9258525", "Score": "2", "OwnerUserId": "649665"}, "9259900": {"Id": "9259900", "PostTypeId": "2", "Body": "<p>\"Tail call\" is probably a misnomer to start with. <code>constexpr</code> functions are much closer to mathematical functions. For mathematical functions, the following two functions are identical:</p>\n<pre><code>constexpr unsigned long long fun1(unsigned long long n) {\n  if (n == 0) return 0 ;\n  return n + fun1(n-1);\n}\nconstexpr unsigned long long fun2(unsigned long long n) {\n  if (n != 0) return n + fun2(n-1);\n  return  0;\n}\n</code></pre>\n<p>yet from a procedural programming viewpoint they're definitely not. Only the first would appear to lend itself to tail call optimization.</p>\n", "LastActivityDate": "2012-02-13T11:44:04.390", "CommentCount": "1", "CreationDate": "2012-02-13T11:44:04.390", "ParentId": "9258525", "Score": "-2", "OwnerUserId": "15416"}, "9320911": {"Id": "9320911", "PostTypeId": "2", "Body": "<p>By the rules in <code>[implimits]</code>, an implementation is permitted to put a recursion depth limit on <code>constexpr</code> calculations. The two compilers which have complete <code>constexpr</code> implementations (gcc and clang) both apply such a limit, using the default of 512 recursive calls as suggested by the standard. For both of these compilers, as well as any other implementation which follows the standard's suggestion, a tail recursion optimization would be essentially undetectable (unless the compiler would otherwise crash before reaching its recursion limit).</p>\n<p>An implementation could instead choose to only count calls for which it could not apply a tail-recursion optimization in its recursion depth limit, or to not provide such a limit. However, such an implementation would probably be doing a disservice to its users, since it would be likely to either crash (due to a stack overflow) or fail to terminate on <code>constexpr</code> evaluations which recurse deeply or infinitely.</p>\n<p>With regard to what happens when the recursion depth limit is reached, Pubby's example raises an interesting point. <code>[expr.const]p2</code> specifies that</p>\n<blockquote>\n<p id=\"so_9258525_9320911_0\">an invocation of a constexpr function or a constexpr constructor that would exceed the implementation-de\ufb01ned recursion limits (see Annex B);</p>\n</blockquote>\n<p>is not a constant expression. Therefore, if the recursion limit is reached in a context which requires a constant expression, the program is ill-formed. If a <code>constexpr</code> function is called in a context which does not require a constant expression, the implementation is not generally required to attempt to evaluate it at translation time, but if it chooses to, and the recursion limit is reached, it is required to instead perform the call at runtime. On a complete, compilable test program:</p>\n<pre><code>constexpr unsigned long long f(unsigned long long n, unsigned long long s=0) {\n  return n ? f(n-1,s+n) : s;\n}\nconstexpr unsigned long long k = f(0xffffffff);\n</code></pre>\n<p>GCC says:</p>\n<pre><code>depthlimit.cpp:4:46:   in constexpr expansion of \u2018f(4294967295ull, 0ull)\u2019\ndepthlimit.cpp:2:23:   in constexpr expansion of \u2018f((n + -1ull), (s + n))\u2019\ndepthlimit.cpp:2:23:   in constexpr expansion of \u2018f((n + -1ull), (s + n))\u2019\n[... over 500 more copies of the previous message cut ...]\ndepthlimit.cpp:2:23:   in constexpr expansion of \u2018f((n + -1ull), (s + n))\u2019\ndepthlimit.cpp:4:46: error: constexpr evaluation depth exceeds maximum of 512 (use -fconstexpr-depth= to increase the maximum)\n</code></pre>\n<p>and clang says:</p>\n<pre><code>depthlimit.cpp:4:30: error: constexpr variable 'k' must be initialized by a constant expression\nconstexpr unsigned long long k = f(0xffffffff);\n                             ^   ~~~~~~~~~~~~~\ndepthlimit.cpp:2:14: note: constexpr evaluation exceeded maximum depth of 512 calls\n  return n ? f(n-1,s+n) : s;\n             ^\ndepthlimit.cpp:2:14: note: in call to 'f(4294966784, 2194728157440)'\ndepthlimit.cpp:2:14: note: in call to 'f(4294966785, 2190433190655)'\ndepthlimit.cpp:2:14: note: in call to 'f(4294966786, 2186138223869)'\ndepthlimit.cpp:2:14: note: in call to 'f(4294966787, 2181843257082)'\ndepthlimit.cpp:2:14: note: in call to 'f(4294966788, 2177548290294)'\ndepthlimit.cpp:2:14: note: (skipping 502 calls in backtrace; use -fconstexpr-backtrace-limit=0 to see all)\ndepthlimit.cpp:2:14: note: in call to 'f(4294967291, 17179869174)'\ndepthlimit.cpp:2:14: note: in call to 'f(4294967292, 12884901882)'\ndepthlimit.cpp:2:14: note: in call to 'f(4294967293, 8589934589)'\ndepthlimit.cpp:2:14: note: in call to 'f(4294967294, 4294967295)'\ndepthlimit.cpp:4:34: note: in call to 'f(4294967295, 0)'\nconstexpr unsigned long long k = f(0xffffffff);\n                                 ^\n</code></pre>\n<p>If we modify the code so that the evaluation is not required to occur at translation time:</p>\n<pre><code>constexpr unsigned long long f(unsigned long long n, unsigned long long s=0) {\n  return n ? f(n-1,s+n) : s;\n}\nint main(int, char *[]) {\n  return f(0xffffffff);\n}\n</code></pre>\n<p>then both compilers accept it, and generate code which computes the result at runtime. When building with <code>-O0</code>, this code fails due to stack overflow. When building with <code>-O2</code>, the compilers' optimizers transform the code to use tail recursion and the code functions correctly (but note that this tail recursion is unrelated to <code>constexpr</code> evaluation).</p>\n", "LastEditorUserId": "1041090", "LastActivityDate": "2012-02-16T23:56:29.697", "Score": "19", "CreationDate": "2012-02-16T23:49:45.563", "ParentId": "9258525", "CommentCount": "0", "OwnerUserId": "1041090", "LastEditDate": "2012-02-16T23:56:29.697"}});