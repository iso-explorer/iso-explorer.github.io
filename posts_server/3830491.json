post_cb({"3830647": {"Id": "3830647", "PostTypeId": "2", "Body": "<p>To pick apart a type, any type, use partial specialization. There is no function template partial specialization, so you'll need to directly parameterize the function on its argument type and retrieve the class type inside.</p>\n<pre><code>template&lt; typename T &gt;\nstruct get_host_class; // most types are not ptmfs: don't implement this\n\ntemplate&lt; typename C &gt;\nstruct get_host_class&lt; bool (C::*)() &gt; { // implement partial specialization\n     typedef C host;\n     typedef void sfinae; // disallow function for non ptmf arguments\n};\n\ntemplate&lt; typename T &gt;\ntypename get_host_class&lt;T&gt;::sfinae Run( T check) {\n    typedef T BoolMethodPtr; // or something\n    typedef typename get_host_class&lt; T &gt;::host host;\n}\n</code></pre>\n", "LastEditorUserId": "153285", "LastActivityDate": "2010-09-30T13:29:32.397", "Score": "4", "CreationDate": "2010-09-30T12:55:42.793", "ParentId": "3830491", "CommentCount": "3", "OwnerUserId": "153285", "LastEditDate": "2010-09-30T13:29:32.397"}, "3830570": {"Id": "3830570", "PostTypeId": "2", "Body": "<p>When the compiler tries to match a template argument, it only considers the primary class type.  In other words, when it encounters the expression:</p>\n<pre><code>Run(&amp;Base::foo);\n</code></pre>\n<p>...and it's trying to figure out the template parameter for <code>Run</code>, it only considers the type of <code>foo</code> itself, and doesn't consider whatever class <code>foo</code> is a part of.</p>\n<p>EDIT:</p>\n<p>And the type of <code>foo</code> is <code>bool(Base::*)(void)</code>, but what you want the compiler to find is just <code>Base</code></p>\n", "LastActivityDate": "2010-09-30T12:44:01.973", "CommentCount": "1", "CreationDate": "2010-09-30T12:44:01.973", "ParentId": "3830491", "Score": "2", "OwnerUserId": "241536"}, "bq_ids": {"n4140": {"so_3830491_3830564_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 336}}, "n3337": {"so_3830491_3830564_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 326}}, "n4659": {"so_3830491_3830564_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 345}}}, "3830564": {"Id": "3830564", "PostTypeId": "2", "Body": "<p>I think this is a non deduced context.</p>\n<blockquote>\n<p id=\"so_3830491_3830564_0\">$14.8.2.5/5- \"The non-deduced contexts\n  are: \u2014 The nested-name-specifier of a\n  type that was specified using a\n  qualified-id.\"</p>\n</blockquote>\n<p>I think this is the quote that applies in this case. But some template gods need to ratify my understanding.</p>\n", "LastActivityDate": "2010-09-30T12:43:10.273", "CommentCount": "1", "CreationDate": "2010-09-30T12:43:10.273", "ParentId": "3830491", "Score": "2", "OwnerUserId": "418110"}, "3830652": {"Id": "3830652", "PostTypeId": "2", "Body": "<p>The <code>T</code> in <code>Traits&lt;T&gt;::BoolMethodPtr</code> is in a non-deduced context, so the compiler will not deduce automatically from the call what type T should be.\nThis is because there could be code like this:</p>\n<pre><code>template&lt;typename T&gt;\nstruct Traits {\n  typedef bool (T::*BoolMethodPtr)();\n};\n\ntemplate&lt;&gt;\nstruct Traits&lt;int&gt; {\n  typedef bool (Base::*BoolMethodPtr)();\n};\n\nRun(&amp;Base::foo); /* What should T be deduced to? Base and int are both equally possible */\n</code></pre>\n<p>If you can do without the <code>Traits&lt;T&gt;</code> class, you can write <code>Run</code> as:</p>\n<pre><code>template&lt;class Class&gt;\nvoid Run(bool (Class::*check)()) {\n  Class* y = dynamic_cast&lt;Class*&gt;(x);\n  std::cout &lt;&lt; (y-&gt;*check)();\n}\n</code></pre>\n<p>In this context, <code>Class</code> can be deduced to mean <code>Base</code></p>\n", "LastActivityDate": "2010-09-30T12:55:57.597", "CommentCount": "2", "CreationDate": "2010-09-30T12:55:57.597", "ParentId": "3830491", "Score": "9", "OwnerUserId": "430719"}, "3830491": {"ViewCount": "986", "Body": "<p>In templates as shown below, I would like the call <code>Run(&amp;Base::foo)</code> succeed without the need to name the Base type twice (as is done in the compiling <code>Run&lt;Base&gt;(&amp;Base::foo)</code> call). Can I have that? Possibly without adding a ton of <a href=\"http://boost.org\" rel=\"nofollow\">Boost</a> headers?</p>\n<p>With the provided code, I get an error of:</p>\n<pre><code>prog.cpp:26: error: no matching function for call to \u2018Run(bool (Base::*)())\u2019\n</code></pre>\n<p>(you can fiddle with the snippet at <a href=\"http://ideone.com/8NZkq\" rel=\"nofollow\">http://ideone.com/8NZkq</a>):</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Base {\npublic:\n  bool foo() { return true; }\n};\n\nBase* x;\n\ntemplate&lt;typename T&gt;\nstruct Traits {\n  typedef bool (T::*BoolMethodPtr)();\n};\n\ntemplate&lt;typename T&gt;\nvoid Run(typename Traits&lt;T&gt;::BoolMethodPtr check) {\n  T* y = dynamic_cast&lt;T*&gt;(x);\n  std::cout &lt;&lt; (y-&gt;*check)();\n}\n\nint main() {\n  Base y;\n  x = &amp;y;\n  Run&lt;Base&gt;(&amp;Base::foo);\n  Run(&amp;Base::foo); // why error?\n}\n</code></pre>\n", "AcceptedAnswerId": "3830652", "Title": "How to deduce class type from method type in C++ templates?", "CreationDate": "2010-09-30T12:34:14.473", "Id": "3830491", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2010-09-30T13:29:32.397", "Score": "2", "OwnerUserId": "98528", "Tags": "<c++><templates><generics><traits>", "AnswerCount": "4"}});