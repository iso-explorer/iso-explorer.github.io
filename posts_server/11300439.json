post_cb({"bq_ids": {"n4140": {"so_11300439_11300596_0": {"length": 25, "quality": 1.0, "section_id": 5795}}, "n3337": {"so_11300439_11300596_0": {"length": 25, "quality": 1.0, "section_id": 5568}, "so_11300439_11300596_1": {"length": 19, "quality": 1.0, "section_id": 5650}}, "n4659": {"so_11300439_11300596_0": {"length": 24, "quality": 0.96, "section_id": 7254}}}, "11300596": {"Id": "11300596", "PostTypeId": "2", "Body": "<p>The reason is that standard layout types effectively mandate the \"empty base class optimization\" where base classes with no data members take up no space and have the same address as the first data member (if any) of the derived class.</p>\n<p>However, attempting doing this when the base class has the same type as the first data member violates the C++ memory model which requires that distinct objects of the same type must have distinct addresses.</p>\n<p>From ISO/IEC 14882:2011 1.8 [intro.object]/6:</p>\n<blockquote>\n<p id=\"so_11300439_11300596_0\">Two objects that are not bit-fields may have the same address if one is a subobject of the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, they shall have distinct addresses</p>\n</blockquote>\n<p>effectively mandating the empty base class, 9.2 [class.mem] /20:</p>\n<blockquote>\n<p id=\"so_11300439_11300596_1\">A pointer to a standard-layout struct object, suitably converted using a <code>reinterpret_cast</code>, points to its\n  initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa.</p>\n</blockquote>\n<p>It would be impossible for the following types (<code>Type1</code> and <code>Type2</code>) to be layout-compatible (although they would otherwise be standard-layout classes) without this restriction.</p>\n<pre><code>struct S1 {};\nstruct S2 {};\n\nstruct Type1 : S1 {\n    S1 s;\n    int k;\n};\n\nstruct Type2 : S1 {\n    S2 s;\n    int m;\n};\n</code></pre>\n", "LastEditorUserId": "19563", "LastActivityDate": "2012-07-02T20:31:45.760", "Score": "15", "CreationDate": "2012-07-02T20:19:35.677", "ParentId": "11300439", "CommentCount": "2", "OwnerUserId": "19563", "LastEditDate": "2012-07-02T20:31:45.760"}, "11300439": {"ViewCount": "1598", "Body": "<p>I was going through great articles on <a href=\"https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special\">C++ POD, Trivial and Standard Layout classes</a>\nOne property I haven't clearly understood about standard layout is the following:-</p>\n<pre><code> A standard layout has no base classes of the same type as the first \n    non-static data member\n</code></pre>\n<p>So the following will not be a Standard Layout as it has the first member same as the base class</p>\n<pre><code>struct NonStandardLayout3 : StandardLayout1 {\n    StandardLayout1 x; // first member cannot be of the same type as base\n};\n</code></pre>\n<p>But performance-wise and property-wise how is the above struct any different than</p>\n<pre><code>struct StandardLayout5 : StandardLayout1 {\n    int x;\n    StandardLayout1 y; // can have members of base type if they're not the first   \n};\n</code></pre>\n<p>which is the correction of the one above this.</p>\n", "AcceptedAnswerId": "11300596", "Title": "Standard Layout c++", "CreationDate": "2012-07-02T20:06:45.077", "Id": "11300439", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:25:22.830", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-02T20:31:45.760", "Score": "15", "OwnerUserId": "1004239", "Tags": "<c++><c++11><pod><standard-layout>", "AnswerCount": "1"}});