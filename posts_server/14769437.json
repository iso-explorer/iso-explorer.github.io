post_cb({"bq_ids": {"n4140": {"so_14769437_14769630_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 4560}}, "n3337": {"so_14769437_14769630_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 4390}}}, "14769437": {"ViewCount": "411", "Body": "<p>I have come across a use case where <code>std::mem_fn</code> cannot do something that a hand-rolled wrapper function can. It comes up when the wrapper function is used on something that's not of the method's class, but a type implicitly convertible to it:</p>\n<pre><code>#include &lt;functional&gt;\n\nstruct A\n{\n};\n\nstruct B\n{\n    B(A);  // implicit conversion from A to B\n    void foo() const;\n};\n\n\nauto foo1 = std::mem_fn(&amp;B::foo);     // std::mem_fn\n\nvoid foo2(const B&amp; b) { b.foo(); }    // hand-rolled wrapper\n\nint main()\n{\n    A a;\n    foo1(a);  // doesn't work\n    foo2(a);  // works fine\n}\n</code></pre>\n<p>The compiler error for the call to foo1 is the following (with GCC 4.8):</p>\n<pre><code>In file included from test.cpp:1:0:\nfunctional: In instantiation of '_Res std::_Mem_fn&lt;_Res (_Class::*)(_ArgTypes ...)const&gt;::_M_call(_Tp&amp;, const volatile void*, _ArgTypes ...) const [with _Tp = A; _Res = void; _Class = B; _ArgTypes = {}]':\nfunctional:608:42:   required from '_Res std::_Mem_fn&lt;_Res (_Class::*)(_ArgTypes ...)const&gt;::operator()(_Tp&amp;, _ArgTypes ...) const [with _Tp = A; _Res = void; _Class = B; _ArgTypes = {}]'\ntest.cpp:21:11:   required from here\nfunctional:586:13: error: no match for 'operator*' (operand type is 'A')\n  { return ((*__ptr).*__pmf)(std::forward&lt;_ArgTypes&gt;(__args)...); }\n             ^\n</code></pre>\n<p>Would it have been possible to implement <code>std::mem_fn</code> in such a way that this use case works just like it does with the hand-rolled wrapper?</p>\n", "AcceptedAnswerId": "14769630", "Title": "Deficiency in std::mem_fn compared to hand-rolled functor", "CreationDate": "2013-02-08T09:29:43.760", "Id": "14769437", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-02-09T14:05:41.307", "Score": "1", "OwnerUserId": "141719", "Tags": "<c++><c++11><implicit-conversion><mem-fun>", "AnswerCount": "1"}, "14769630": {"PostTypeId": "2", "Body": "<p>It would be possible, yes, but it's not how the C++ standard specifies <code>mem_fn</code>.</p>\n<p>The standard says that <code>foo1(a)</code> calls <code>INVOKE(&amp;B::foo, a)</code> where that is defined in [func.require] as:</p>\n<blockquote>\n<p id=\"so_14769437_14769630_0\">Define <code>INVOKE (f, t1, t2, ..., tN)</code> as follows:<br>\n  \u2014 <code>(t1.*f)(t2, ..., tN)</code> when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>t1</code> is an object of type <code>T</code> or a reference to an object of type <code>T</code> or a reference to an object of a type derived from <code>T</code>;<br>\n  \u2014 <code>((*t1).*f)(t2, ..., tN)</code> when f is a pointer to a member function of a class <code>T</code> and <code>t1</code> is not one of the types described in the previous item;<br>\n  \u2014 ...  </br></br></br></p>\n</blockquote>\n<p>Your case fails to meet the conditions of the first bullet, because <code>a</code> is not an object of class <code>B</code>, nor a reference to a <code>B</code> or a class derived from <code>B</code>, so the second bullet applies and so it's equivalent to <code>((*a).*f)()</code> which isn't valid.</p>\n<p>It's defined this way to allow smart pointers to be used, e.g.</p>\n<pre><code>auto foo1 = std::mem_fn(B::foo);\nauto p = std::make_shared&lt;B&gt;();\nfoo1(p);\n</code></pre>\n<p>The definition of <em><code>INVOKE</code></em> (which is also used by <code>bind</code>, <code>function</code>, <code>async</code> and other parts of the library that create call wrappers) means that when invoking a wrapped pointer-to-member, if the first argument <code>t1</code> isn't a <code>T</code> then it is assumed to be some kind of pointer and gets dereferenced.  This means it works with <code>std::shared_ptr</code> and <code>std::unique_ptr</code> but also with types that <code>std::mem_fn</code> knows nothing about, such as <code>boost::shared_ptr</code> and <code>MyVeryOwnSmartPtr</code>.</p>\n<p>To make your code work it would be possible to add extra cases to handle when <code>t1</code> is not a <code>T</code> or a type derived from <code>T</code>, but <code>is_convertible&lt;T&gt;::value</code> is true, and to invoke <code>T(t1).*f)()</code>, but that would complicate the specification and might have undesirable consequences in some cases.</p>\n<p>Your \"wrapper\" will force the implicit conversion of its argument, but it can't handle smart pointers or rvalues of type <code>B</code>, which are both supported by <code>mem_fn</code>.   If you have a specific case where you want to convert <code>A</code> objects to <code>B</code> to call the function, then just do that, the generic <code>mem_fn</code> template isn't suitable, but it is more flexible and generic and works in plenty of other situations.</p>\n<p>(N.B. the definition of <em><code>INVOKE</code></em> is actually defective because it dereferences <code>std::reference_wrapper</code> objects in the same way as it dereferences your <code>a</code> argument. I've proposed a fix at <a href=\"http://cplusplus.github.com/LWG/lwg-active.html#2219\" rel=\"nofollow\">http://cplusplus.github.com/LWG/lwg-active.html#2219</a>, but that doesn't affect your example.)</p>\n", "LastActivityDate": "2013-02-09T14:05:41.307", "LastEditorUserId": "981959", "Id": "14769630", "CommentCount": "0", "CreationDate": "2013-02-08T09:41:26.307", "ParentId": "14769437", "Score": "5", "OwnerUserId": "981959", "LastEditDate": "2013-02-09T14:05:41.307"}});