post_cb({"bq_ids": {"n4140": {"so_21045518_21046043_4": {"length": 10, "quality": 1.0, "section_id": 381}, "so_21045518_21046043_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 3321}, "so_21045518_21046043_2": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_21045518_21046043_5": {"length": 18, "quality": 0.9, "section_id": 382}}, "n3337": {"so_21045518_21046043_4": {"length": 10, "quality": 1.0, "section_id": 372}, "so_21045518_21046043_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 3191}, "so_21045518_21046043_2": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_21045518_21046043_5": {"length": 18, "quality": 0.9, "section_id": 373}}, "n4659": {"so_21045518_21046043_4": {"length": 9, "quality": 0.9, "section_id": 396}, "so_21045518_21046043_3": {"length": 11, "quality": 0.7333333333333333, "section_id": 4087}, "so_21045518_21046043_2": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_21045518_21046043_5": {"length": 17, "quality": 0.85, "section_id": 397}}}, "21045877": {"Id": "21045877", "PostTypeId": "2", "Body": "<p><code>(2)</code> Doesn't work because <code>\"asd\"</code> is a <code>char const[]</code>. The compiler will implicitly convert it (indeed) to a temporary <code>string</code> rvalue. You cannot assign a non-const reference to a value which will immediately go out of scope. So your analysis there is correct.</p>\n<p>For <code>(1)</code> I had to do a little lookup myself, but I think I've found the answer here : <a href=\"https://stackoverflow.com/questions/2784262/does-a-const-reference-prolong-the-life-of-a-temporary\">Does a const reference prolong the life of a temporary?</a></p>\n<p>It appears that the standard allows a copy to occur when binding a temporary to a const reference. Unexpexted, I agree :) So there will be an implicit conversion again to a temporary <code>string</code> rvalue again, and because the reference is now <code>const</code>, this rvalue will be copied so it persists.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-10T13:41:54.153", "Score": "3", "CreationDate": "2014-01-10T13:41:54.153", "ParentId": "21045518", "CommentCount": "0", "OwnerUserId": "556997", "LastEditDate": "2017-05-23T10:33:22.767"}, "21045518": {"ViewCount": "206", "Body": "<p>Although I thought I understand the <code>rvalue</code> and <code>lvalue</code> semantics in C++, I seem to stomp over and over again into strange examples that prove to me that I don't know squat.</p>\n<p>However there are two very simple and basic ones that I don't understand how they work. Before I compiled them I thought none would be ok, after I saw that <code>(1)</code> works, I thought that <code>(2)</code> would work too. However, <code>(1)</code> works, <code>(2)</code> doesn't:</p>\n<pre><code>(1) const std::string &amp;s = \"asd\";\n</code></pre>\n<p>What happens here? My guess is that a temporary <code>const string</code> object is constructed from <code>\"asd\"</code>, and then <code>s</code> is bound to that temporary object. But wouldn't then the temporary object be destroyed right after this line so we would be left with an invalid reference?</p>\n<p>When I drop the <code>const</code> qualifier:</p>\n<pre><code>(2) std::string &amp;s = \"asd\";\n</code></pre>\n<p>I get a compiler error (VS 2013): <code>cannot convert from 'const char [4]' to 'std::string &amp;'</code>. Which seems to disprove my theory, because, according to it (my guess), a temporary <code>string</code> object would be constructed from <code>\"asd\"</code> and then <code>s</code> assigned to it, which wouldn't generate any compile error.</p>\n<p>So to sum up:</p>\n<ul>\n<li>To what is <code>s</code> bound?</li>\n<li>What is the lifespan of the object that <code>s</code> is bound to?</li>\n<li>What makes <code>(1)</code> compile and <code>(2)</code> not (is it some conversion operators defined in <code>std::string</code> or is it a C++ semantic)?</li>\n</ul>\n", "AcceptedAnswerId": "21046043", "Title": "Initializing a reference", "CreationDate": "2014-01-10T13:25:31.717", "Id": "21045518", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-01-10T17:27:48.010", "LastEditorUserId": "2805305", "LastActivityDate": "2014-01-10T17:27:48.010", "Score": "4", "OwnerUserId": "2805305", "Tags": "<c++><reference>", "AnswerCount": "3"}, "21046043": {"Id": "21046043", "PostTypeId": "2", "Body": "<h2>TL;DR</h2>\n<blockquote id=\"so_21045518_21046043_0\">\n<ul>\n<li>To what is s binded?</li>\n<li>What is the lifespan of the object that s is binded to?</li>\n</ul>\n</blockquote>\n<p>To a newly created temporary <code>std::string</code>, that will life as long as <code>s</code>. </p>\n<blockquote>\n<p id=\"so_21045518_21046043_1\">What makes (1) compile and (2) not?</p>\n</blockquote>\n<p>You may not make a non-const reference to non-lvalues.</p>\n<h2>Relevant quotes</h2>\n<p>Quoting from 8.5.3 [dcl.init.ref]:</p>\n<blockquote>\n<p id=\"so_21045518_21046043_2\">A reference to type \u201c<code>cv1 T1</code>\u201d is initialized by an expression of type\n  \u201c<code>cv2 T2</code>\u201d as follows:</p>\n<ul>\n<li>[ .. snip, not relevant .. ]</li>\n<li>Otherwise [if the right hand side is not an lvalue], the reference shall be an lvalue reference to a <strong>non-volatile const type (i.e., <code>cv1</code>\n  shall be <code>const</code>)</strong>, or the reference shall be an rvalue reference.\n  <ul>\n<li>[ .. snip, not relevant .. ] </li>\n<li>Otherwise, a temporary of type \u201c<code>cv1</code> T1\u201d is created and initialized from the initializer expression using\n  the rules for a non-reference copy-initialization (8.5). The reference\n  is then bound to the temporary. If T1 is reference-related to T2, cv1\n  shall be the same cv-qualification as, or greater cv-qualification\n  than, cv2. If T1 is reference-related to T2 and the reference is an\n  rvalue reference, the initializer expression shall not be an lvalue.</li>\n</ul></li>\n</ul>\n<p id=\"so_21045518_21046043_3\">In all cases except the last (i.e., creating and initializing a\n  temporary from the initializer expression), the reference is said to\n  bind directly to the initializer expression.</p>\n</blockquote>\n<p>In your case, you need to convert <code>const char*</code> to <code>std::string</code>, which introduces a temporary of type <code>std::string</code>. Since this is not an <em>lvalue</em>, the reference is shall be <code>const</code>. This concludes why (2) doesn't work.</p>\n<p>For the lifetime, have a look at 12.2 [class.temporary]:</p>\n<blockquote>\n<p id=\"so_21045518_21046043_4\">There are two contexts in which temporaries are destroyed at a different point than the end of the full-expression. [...]</p>\n<p id=\"so_21045518_21046043_5\">The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference [...]</p>\n</blockquote>\n<p>This means that the temporary will as long as your <code>const</code> reference. This concludes why (1) does work.</p>\n<p>Note that there are many more details in the standard, which include some corner cases, so you might want to read those sections completely.</p>\n", "LastEditorUserId": "1139697", "LastActivityDate": "2014-01-10T13:55:18.717", "Score": "2", "CreationDate": "2014-01-10T13:49:59.927", "ParentId": "21045518", "CommentCount": "0", "OwnerUserId": "1139697", "LastEditDate": "2014-01-10T13:55:18.717"}, "21046275": {"Id": "21046275", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_21045518_21046275_0\">To what is <code>s</code> binded?</p>\n</blockquote>\n<p>To a temporary <code>std::string</code> constructed from the string literal, as you surmised.</p>\n<blockquote>\n<p id=\"so_21045518_21046275_1\">What is the lifespan of the object that <code>s</code> is binded to?</p>\n</blockquote>\n<p>The temporary's lifetime is extended to match the reference's. Usually, temporaries are destroyed at the end of the full-expression that creates them; this is an exception to that rule.</p>\n<blockquote>\n<p id=\"so_21045518_21046275_2\">What makes (1) compile and (2) not?</p>\n</blockquote>\n<p>Another language rule: temporaries can't be bound to non-<code>const</code> references. This rule is a bit quirky, but useful: it prevents subtle bugs if you were to accidentally modify a temporary instead of a more persistent object.</p>\n", "LastActivityDate": "2014-01-10T14:01:32.910", "CommentCount": "0", "CreationDate": "2014-01-10T14:01:32.910", "ParentId": "21045518", "Score": "2", "OwnerUserId": "204847"}});