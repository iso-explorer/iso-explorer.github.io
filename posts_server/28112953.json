post_cb({"bq_ids": {"n4140": {"so_28112953_28113043_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 3304}}, "n3337": {"so_28112953_28113043_0": {"length": 17, "quality": 0.7083333333333334, "section_id": 3174}}, "n4659": {"so_28112953_28113043_0": {"length": 16, "quality": 0.6666666666666666, "section_id": 4070}}}, "28113043": {"Id": "28113043", "PostTypeId": "2", "Body": "<p><strong>corrected</strong></p>\n<p>If the structure is an aggregate, the 2 definitions perform the same thing. From the C++11 standard (N3337):</p>\n<blockquote>\n<p id=\"so_28112953_28113043_0\">8.5.1/7 If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from its brace-or-equal-initializer or, if there is no brace-or-equal- initializer, from an empty initializer list (8.5.4).</p>\n</blockquote>\n<p>If the structure contains two members, like </p>\n<pre><code>struct S\n{\n    int x;\n    double y;\n};\n</code></pre>\n<p>then <code>structVar = {}</code> will value-initialize the members, i.e. they will become zero (or if the members are non-PODs, the default ctor will be called). </p>\n<p>The line <code>structVar = {0}</code> will initialize only the first member of the struct with zero. Since in this case you have an aggregate, the rest of the members are value-initialized by empty lists, so effectively you have</p>\n<pre><code>structVar = {0, {} };\n</code></pre>\n<p>C++14 added the possibility of aggregate initialization for aggregates containing brace-or-equal initialized members, i.e.</p>\n<pre><code>struct S\n{\n    int x;\n    double y{1.1}; // or double y = 1.1;\n}\n</code></pre>\n<p>In this case, </p>\n<pre><code>structVar = {0};\n</code></pre>\n<p>initializes <code>x</code> with 0 and <code>y</code> with 1.1. This was not possible before C++14.</p>\n<p>PS: just tested the code above, clang++ compiles it with <code>-std=c++1y</code>, however g++ 4.9.2 rejects it even if I compile with <code>-std=c++14</code>.</p>\n", "LastEditorUserId": "3093378", "LastActivityDate": "2015-01-23T15:51:53.103", "Score": "4", "CreationDate": "2015-01-23T15:21:38.247", "ParentId": "28112953", "CommentCount": "6", "OwnerUserId": "3093378", "LastEditDate": "2015-01-23T15:51:53.103"}, "28113027": {"Id": "28113027", "PostTypeId": "2", "Body": "<p>It really depends on the nature of the struct. </p>\n<p>If it is an aggregate, the two are largely equivalent. However, the first one is general in that it simply value-initializes the struct. The second one requires that the struct's first member be initializable with <code>0</code>, and initializes the rest of elements as if they were each initialized by an empty initializer <code>{}</code>, in other words,</p>\n<pre><code>structVar = {0, {}, {}, {}, ..... };\n</code></pre>\n<p>so each remaining element is <em>value-initialized</em>.</p>\n<p>If it is not an aggregate, then it depends on what constructors, if any, have been provided. There simply isn't enough information to say.</p>\n", "LastEditorUserId": "661519", "LastActivityDate": "2015-01-23T15:41:33.227", "Score": "5", "CreationDate": "2015-01-23T15:20:49.347", "ParentId": "28112953", "CommentCount": "0", "OwnerUserId": "661519", "LastEditDate": "2015-01-23T15:41:33.227"}, "28112953": {"ViewCount": "95", "Body": "<p>Is there a difference between initializing a structure these two ways:</p>\n<pre><code>structVar = {}\n</code></pre>\n<p>and</p>\n<pre><code>structVar = {0}\n</code></pre>\n", "AcceptedAnswerId": "28113043", "Title": "Initializing a C++ Structure", "CreationDate": "2015-01-23T15:16:56.253", "Id": "28112953", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-01-23T15:51:53.103", "Score": "0", "OwnerUserId": "1124014", "Tags": "<c++><struct><initialization>", "AnswerCount": "2"}});