post_cb({"7543001": {"CommentCount": "0", "ViewCount": "353", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-09-25T01:12:52.473", "LastActivityDate": "2011-09-25T18:45:44.330", "Title": "How does \"contextual conversion\" with `&&` and `||` operators work in conjunction with user-defined operator overloads?", "LastEditDate": "2017-05-23T10:34:29.643", "Id": "7543001", "Score": "4", "Body": "<p>From @Xeo's excellent <code>c++-faq</code> question: <a href=\"https://stackoverflow.com/questions/6242768/is-the-safe-bool-idiom-obsolete\">Is the safe-bool idiom obsolete in C++11?</a> I learned that the safe bool idiom is no longer needed, because an <code>explicit</code> user-defined conversion to <code>bool</code> will be automatically invoked in contexts where the safe bool was needed in C++03.</p>\n<p>However, the ability to overload operators such as <code>&amp;&amp;</code>, <code>||</code> and <code>!</code> seems to circumvent this.</p>\n<p>Cases where <code>operator!</code> is necessary beyond provision of conversion to <code>bool</code> are rare, as are <code>operator&amp;&amp;</code> and <code>operator||</code>, but C++ expression tree implementations (used for deferred execution and symbolic math techniques) do need to override these.</p>\n<p>Does \"contextual conversion\" take place when a user-defined operator is being invoked?  What sort of SFINAE incantation is needed to make sure that a definition of <code>operator&amp;&amp;</code> or <code>operator||</code> will work correctly both with types implementing \"safe bool\" and those designed for \"contextual conversion\"?</p>\n<hr>\n<p>To clarify, given:</p>\n<pre><code>class uses_safe_bool\n{\n    void f() {};\n    typedef void (uses_safe_bool::* safe_bool)();\n\npublic:\n    operator safe_bool() const { return (rand() &amp; 1)? &amp;uses_safe_bool::f: 0; }\n};\n\nclass uses_explicit_bool\n{\npublic:\n    explicit operator bool() const { return rand() &amp; 1; }\n};\n\ntemplate&lt;typename T&gt;\nclass deferred_expression\n{\n    // Not convertible to bool\npublic:\n    T evaluate() const;\n};\n</code></pre>\n<p>What signatures are required for <code>operator||</code> such that the following expressions are all valid:</p>\n<pre><code>deferred_expression&lt;bool&gt; db;\nuses_safe_bool sb;\nuses_explicit_bool eb;\nint i;\n\nauto test1 = sb || db;\nauto test2 = eb || db;\nauto test3 = true || db;\nauto test4 = false || db;\nauto test5 = i || db;\n</code></pre>\n<p>these use a different overload:</p>\n<pre><code>auto test6 = db || db;\n\ndeferred_expression&lt;int&gt; di;\nauto test7 = di || db;\n</code></pre>\n<p>and the following are rejected at compile-time:</p>\n<pre><code>std::string s;\nauto test7 = s || db;\n\nstd::vector&lt;int&gt; v;\nauto test8 = v || db;\n\ndeferred_expression&lt;std::string&gt; ds;\nauto test9 = ds || db;\n</code></pre>\n</hr>", "Tags": "<c++><operator-overloading><c++11><safe-bool-idiom>", "OwnerUserId": "103167", "AnswerCount": "1"}, "7543549": {"ParentId": "7543001", "LastEditDate": "2011-09-25T04:40:13.663", "CommentCount": "8", "CreationDate": "2011-09-25T03:56:46.770", "OwnerUserId": "726300", "LastEditorUserId": "726300", "PostTypeId": "2", "Id": "7543549", "Score": "4", "Body": "<p>The rule is the same for C++03 (safe-bool idiom) and for C++11 (explicit conversion operator): don't overload the boolean operators for this (so as to not lose short circuit behaviour, plus the defaults work just fine). The latter will work because the operands of the built-in boolean operators are eligible for a contextual conversion, for instance for <code>&amp;&amp;</code> from n3290, 5.14 Logical AND operator [expr.log.and]:</p>\n<blockquote>\n<p id=\"so_7543001_7543549_0\">1 The &amp;&amp; operator groups left-to-right. <strong>The operands are both contextually converted to type bool (Clause 4)</strong>.</p>\n</blockquote>\n<p>(emphasis mine, similar text for other operators)</p>\n<hr>\n<p>Overloaded operators are regular function calls, so no contextual conversion takes place. Make sure your overloaded boolean operators are <em>always</em> picked through overload resolution and you're good to go. For instance, this is neglecting lvalues:</p>\n<pre><code>struct evil {\n    explicit operator bool() const;\n};\nvoid operator||(evil&amp;&amp;, evil&amp;&amp;);\n\nevil e;\n// built-in operator||\ne || e;\n\n// overloaded operator||\nevil() || evil()\n</code></pre>\n<p>Note that <code>template&lt;typename Lhs, typename Rhs&gt; void operator||(Lhs&amp;&amp;, Rhs&amp;&amp;);</code> will be selected via ADL when any one of the operand type is of class type, regardless of <em>cv</em>-qualifiers and of value-category.</p>\n</hr>", "LastActivityDate": "2011-09-25T04:40:13.663"}, "bq_ids": {"n4140": {"so_7543001_7543549_0": {"section_id": 6163, "quality": 0.75, "length": 9}}, "n3337": {"so_7543001_7543549_0": {"section_id": 5924, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_7543001_7543549_0": {"section_id": 7660, "quality": 0.75, "length": 9}}}});