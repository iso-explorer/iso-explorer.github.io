post_cb({"6972233": {"Id": "6972233", "PostTypeId": "2", "Body": "<p>In c#, a <code>class</code> always lives on the heap. A <code>struct</code> can be  either on the heap <em>or</em> stack:</p>\n<ul>\n<li>variables (except captures and iterator blocks), and fields on a struct that is <em>itself</em> on the stack live on the stack</li>\n<li>captures, iterator blocks, fields of something that is on the heap, and values in an array live on the heap, as do \"boxed\" values</li>\n</ul>\n", "LastActivityDate": "2011-08-07T10:37:54.030", "CommentCount": "7", "CreationDate": "2011-08-07T10:37:54.030", "ParentId": "6972111", "Score": "3", "OwnerUserId": "23354"}, "6972155": {"Id": "6972155", "PostTypeId": "2", "Body": "<p>I don't know precisely about Java (and it seems quite difficult to get a documentation about it).</p>\n<p>In C#, <code>new</code> invokes the constructor and returns a fresh object. If it is of value type, it is allocated on the stack (eg. local variable) or on the heap (eg. boxed object, member of a reference type object). If it is of reference type, it always goes on the heap and is managed by the garbage collector. See <a href=\"http://msdn.microsoft.com/en-us/library/fa0ab757(v=vs.80).aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/fa0ab757(v=vs.80).aspx</a> for more details.</p>\n<p>In C++, a <em>\"new expression\"</em> returns a pointer to an object with <em>dynamic storage duration</em> (ie. that you must destroy yourself). There is no mention of heap (with this meaning) in the C++ standard, and the mechanism through which such an object is obtained is implementation defined.</p>\n", "LastEditorUserId": "373025", "LastActivityDate": "2011-08-07T10:55:38.533", "Score": "7", "CreationDate": "2011-08-07T10:20:35.053", "ParentId": "6972111", "CommentCount": "7", "OwnerUserId": "373025", "LastEditDate": "2011-08-07T10:55:38.533"}, "6972175": {"Id": "6972175", "PostTypeId": "2", "Body": "<p>(Referring to Java) What you said is correct- primitives are allocated on the stack (there are exceptions e.g. closures). However, you might be referring to objects such as:</p>\n<pre><code>Integer n = new Integer(2);\n</code></pre>\n<p>This refers to an Integer object, and not a primitive int. Perhaps this was your source of confusion? In this case, n will be allocated on the heap. Perhaps your confusion was due to <a href=\"http://download.oracle.com/javase/1.5.0/docs/guide/language/autoboxing.html\" rel=\"nofollow noreferrer\">autoboxing</a> rules? Also see <a href=\"https://stackoverflow.com/questions/766468/autoboxing-so-i-can-write-integer-i-0-instead-of-integer-i-new-integer0\">this</a> question for more details on autoboxing. Check out comments on this answer for exceptions to the rule where primitives are allocated on the heap.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-08-07T10:47:23.723", "Score": "2", "CreationDate": "2011-08-07T10:25:45.370", "ParentId": "6972111", "CommentCount": "7", "OwnerUserId": "495545", "LastEditDate": "2017-05-23T12:25:57.563"}, "6972131": {"Id": "6972131", "PostTypeId": "2", "Body": "<p>In Java and C#, we don't need to allocate primitive types on the heap. They can be allocated on the stack ( not that they are restricted to stack ). Whereas, in C++ we can have primitive as well as user defined types to be allocated on both stack and heap. </p>\n", "LastActivityDate": "2011-08-07T10:17:05.027", "CommentCount": "1", "CreationDate": "2011-08-07T10:17:05.027", "ParentId": "6972111", "Score": "0", "OwnerUserId": "124797"}, "6972269": {"Id": "6972269", "PostTypeId": "2", "Body": "<p>Regarding c#, read <a href=\"http://blogs.msdn.com/b/ericlippert/archive/2010/09/30/the-truth-about-value-types.aspx\" rel=\"nofollow noreferrer\">The Truth About Value Types</a>. \nYou will see that value types can go on the heap as well. </p>\n<p>And <a href=\"https://stackoverflow.com/questions/477101/heap-versus-stack-allocation-implications-net/477333#477333\">at this question</a> is suggested that reference types <em>could</em> go on the stack. (but it does not happen at the moment)</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-08-07T10:43:32.337", "Score": "2", "CreationDate": "2011-08-07T10:43:32.337", "ParentId": "6972111", "CommentCount": "0", "OwnerUserId": "33499", "LastEditDate": "2017-05-23T11:54:33.733"}, "bq_ids": {"n4140": {"so_6972111_6972405_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 6085}}, "n3337": {"so_6972111_6972405_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 5853}}, "n4659": {"so_6972111_6972405_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 7581}}}, "6972111": {"ViewCount": "9412", "Body": "<p>My understanding has always been, regardless of C++ or C# or Java, that when we use the <code>new</code> keyword to create an object it allocates memory on the heap.  I thought that <code>new</code> is only needed for reference types (classes), and that primitive types (int, bool, float, etc.) never use <code>new</code> and always go on the stack (except when they're a member variable of a class that gets instantiated with <code>new</code>).  However, I have been reading <a href=\"http://msdn.microsoft.com/en-us/library/s1ax56ch.aspx\">information</a> that makes me doubt this long standing assumption, at least for Java and C#.</p>\n<p>For example, I just noticed that in C# the <code>new</code> operator can be used to initialize a value type, see <a href=\"http://msdn.microsoft.com/en-us/library/s1ax56ch.aspx\">here</a>. Is this an exception to the rule, a helper feature of the language, and if so, what other exceptions would there be? </p>\n<p>Can someone please clarify this?</p>\n", "AcceptedAnswerId": "6972261", "Title": "Does new always allocate on the heap in C++ / C# / Java", "CreationDate": "2011-08-07T10:12:00.980", "Id": "6972111", "CommentCount": "2", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2011-08-07T10:29:02.167", "LastEditorUserId": "421611", "LastActivityDate": "2011-08-07T22:10:14.557", "Score": "11", "OwnerUserId": "265877", "Tags": "<c#><java><c++><memory><memory-management>", "AnswerCount": "9"}, "6972820": {"Id": "6972820", "PostTypeId": "2", "Body": "<p>In C++, there's an additional way to use the new operator, and that's via 'placement new'. The memory you point it to could exist anywhere.</p>\n<p>See <a href=\"https://stackoverflow.com/questions/222557/cs-placement-new\">What uses are there for \"placement new\"?</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-08-07T12:32:01.167", "Score": "0", "CreationDate": "2011-08-07T12:32:01.167", "ParentId": "6972111", "CommentCount": "1", "OwnerUserId": "472792", "LastEditDate": "2017-05-23T11:47:01.187"}, "6972203": {"Id": "6972203", "PostTypeId": "2", "Body": "<p>Java 7 does escape analysis to determine if an object can be allocated on the stack, according to <a href=\"http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html\" rel=\"nofollow\">http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html</a>.</p>\n<p>However, you cannot instruct the runtime to allocate an object on heap or on stack. It's done automatically.</p>\n", "LastActivityDate": "2011-08-07T10:32:06.760", "CommentCount": "1", "CreationDate": "2011-08-07T10:32:06.760", "ParentId": "6972111", "Score": "1", "OwnerUserId": "150339"}, "6972261": {"Id": "6972261", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_6972111_6972261_0\">I thought that new is only needed for reference types (classes), and that primitive types (int, bool, float, etc.) never use new</p>\n</blockquote>\n<p>In C++, you can allocate primitive types on the heap if you want to:</p>\n<pre><code>int* p = new int(42);\n</code></pre>\n<p>This is useful if you want a shared counter, for example in the implementation of <code>shared_ptr&lt;T&gt;</code>.</p>\n<p>Also, you are not forced to use new with classes in C++:</p>\n<pre><code>void function()\n{\n    MyClass myObject(1, 2, 3);\n}\n</code></pre>\n<p>This will allocate <code>myObject</code> on the stack. Note that <code>new</code> is rarely used in modern C++.</p>\n<p>Furthermore, you can overload <code>operator new</code> (either globally or class-specific) in C++, so even if you say <code>new MyClass</code>, the object does not necessarily get allocated on the heap.</p>\n", "LastActivityDate": "2011-08-07T10:41:40.590", "CommentCount": "6", "CreationDate": "2011-08-07T10:41:40.590", "ParentId": "6972111", "Score": "22", "OwnerUserId": "252000"}, "6972405": {"Id": "6972405", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_6972111_6972405_0\"><em>My understanding has always been, regardless of C++ or C# or Java, that when we use the <code>new</code> keyword to create an object it allocates memory on the heap.</em></p>\n</blockquote>\n<p>Your understanding has been incorrect:</p>\n<ul>\n<li><p><code>new</code> may work differently in different programming languages, even when these languages are superficially alike. Don't let the similar syntax of C#, C++, and Java mislead you!</p></li>\n<li><p>The terms \"heap\" and \"stack\" (as they are understood in the context of internal memory management) are simply not relevant to all programming languages. Arguably, these two concepts are more often implementation details than that they are part of a programming language's official specification.</p>\n<p>(IIRC, this is true for at least C# and C++. I don't know about Java.)</p>\n<p>The fact that they are such <em>widespread</em> implementation details doesn't imply that you should rely on that distinction, nor that you should even know about it! (However, I admit that I usually find it beneficial to know \"how things work\" internally.)</p></li>\n</ul>\n<p>I would suggest that you stop worrying too much about these concepts. The important thing that you need to get right is to understand a language's semantics; e.g., for C# or any other .NET language, the difference in reference and value type semantics.</p>\n<h2>Example: What the C# specification says about operator <code>new</code>:</h2>\n<p>Note how the following part of the <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-334.pdf\">C# specification published by ECMA (4th edition)</a> does not mention any \"stack\" or \"heap\":</p>\n<blockquote>\n<p id=\"so_6972111_6972405_1\"><em><strong>14.5.10 The new operator</strong></em></p>\n<p id=\"so_6972111_6972405_2\"><em>The new operator is used to create new instances of types. [\u2026]</em></p>\n<p id=\"so_6972111_6972405_3\"><em>The new operator implies creation of an instance of a type, but does not necessarily imply dynamic allocation of memory. In particular, instances of value types require no additional memory beyond the variables in which they reside, and no dynamic allocations occur when new is used to create instances of value types.</em></p>\n</blockquote>\n<p>Instead, it talks of \"dynamic allocation of memory\", but that is not the same thing: You could dynamically allocate memory on a stack, on the heap, or anywhere else (e.g. on a  hard disk drive) for that matter.</p>\n<p>What it <em>does</em> say, however, is that instances of value types are stored in-place, which is exactly what value type semantics are all about: Value type instances get copied during an assignment, while reference type instances are referenced / \"aliased\". <em>That</em> is the important thing to understand, not the \"heap\" or the \"stack\"!</p>\n", "LastEditorUserId": "240733", "LastActivityDate": "2011-08-07T22:10:14.557", "Score": "7", "CreationDate": "2011-08-07T11:10:27.543", "ParentId": "6972111", "CommentCount": "1", "OwnerUserId": "240733", "LastEditDate": "2011-08-07T22:10:14.557"}});