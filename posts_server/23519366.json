post_cb({"23519366": {"CommentCount": "4", "ViewCount": "689", "PostTypeId": "1", "LastEditorUserId": "3612380", "CreationDate": "2014-05-07T13:34:40.263", "LastActivityDate": "2014-05-21T22:02:50.577", "Title": "Division by complex<double> in clang++ versus g++", "FavoriteCount": "2", "LastEditDate": "2014-05-21T22:02:50.577", "Id": "23519366", "Score": "12", "Body": "<p>When I compile the following code with g++ (4.8.1 or 4.9.0) or clang++ (3.4) I get different outputs.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;complex&gt;\n\nint main() {\n  std::complex&lt;double&gt; c = {1.e-162,0};\n  std::cout &lt;&lt; 1.0/c &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p>g++:</p>\n<pre><code>(1e+162,0)\n</code></pre>\n<p>clang++:</p>\n<pre><code>(inf,-nan)\n</code></pre>\n<p>Is this a bug in clang?  </p>\n<p>Update:</p>\n<p>Thank you for your answers! I reported the bug: <a href=\"http://llvm.org/bugs/show_bug.cgi?id=19820\" rel=\"nofollow\">http://llvm.org/bugs/show_bug.cgi?id=19820</a></p>\n", "Tags": "<c++><clang><complex-numbers>", "OwnerUserId": "3612380", "AnswerCount": "4"}, "23519898": {"ParentId": "23519366", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Ok so I have this wild guess, that in clang the complex number division is implemented like described on wiki: <a href=\"http://en.wikipedia.org/wiki/Complex_number#Multiplication_and_division\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Complex_number#Multiplication_and_division</a>.</p>\n<p>One can see that the denominator is in the form <code>c^2 + d^2</code>. So <code>1.e-162</code> squared actually falls out of the IEE754 representable range for <code>double</code> which is <code>std::numeric_limits&lt;double&gt;::min()</code> - <code>2.22507e-308</code>, and we have an underflow.</p>\n<p><code>gcc</code> somehow works this out, but if <code>clang</code> does simple square, as per @40two's standard quotation it enters into UB, and treats it as <code>0</code> after performing <code>1.e-162^2 + 0.0^2</code>.</p>\n<p>I tested <code>clang</code> and <code>gcc</code> for a number that should not result with underflow when squared.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;complex&gt;\n\nint main() {\n  std::complex&lt;double&gt; c = {1.e-104,0};\n  std::cout &lt;&lt; 1.0/c &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p>Results are fine:</p>\n<pre><code>luk32:~/projects/tests$ g++ --std=c++11 ./complex_div.cpp \nluk32:~/projects/tests$ ./a.out \n(1e+104,0)\nluk32:~/projects/tests$ clang++ --std=c++11 ./complex_div.cpp \nluk32:~/projects/tests$ ./a.out \n(1e+104,0)\n</code></pre>\n<p>Not sure if this is a bug. But I think this is what is going on.</p>\n<p>Addendum:</p>\n<p><code>(inf,-nan)</code> is also consistent if one evaluates those expressions by hand </p>\n<p>We get:</p>\n<pre><code>real = (ac+bd) / (o)  - real part \nimag = (bc-ad) / (o)  - imaginary part\n\n{a,b} = {1.0, 0.0}\n{c,d} = {1.e-104, 0.0}\n\no is (c^2 + d^2) and we assume it is 0.0.\n\nreal / o = (1.e-104 * 1.0 + 0.0 * 0.0) / o = 1/o = inf\nimag / o = (0.0 * 1.e-104 - 1.0 * 0.0) / o = -0.0 / o = -nan\n</code></pre>\n<p>I am just not absolutetly sure about the sign of <code>-0.0</code> and <code>-nan</code>, I don't know IEE754 enough to evaluate <code>(0.0 * 1.e-104 - 1.0 * 0.0)</code>. But everything seems consistent.</p>\n", "OwnerUserId": "1133179", "LastEditorUserId": "1133179", "LastEditDate": "2014-05-07T14:16:58.157", "Id": "23519898", "Score": "4", "CreationDate": "2014-05-07T13:58:29.910", "LastActivityDate": "2014-05-07T14:16:58.157"}, "23520299": {"ParentId": "23519366", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The standard says in <code>[complex.numbers]</code> (26.4/3):</p>\n<blockquote>\n<p id=\"so_23519366_23520299_0\">If the result of a function is not mathematically defined or not in\n  the range of representable values for its type, the behavior is\n  undefined.</p>\n</blockquote>\n<p>There are no specifics on how division should be implemented for complex numbers. Only in <code>[complex.member.ops]</code> it says:</p>\n<blockquote>\n<pre><code>complex&lt;T&gt;&amp; operator/=(const complex&lt;T&gt;&amp; rhs);\n</code></pre>\n<p id=\"so_23519366_23520299_1\">Effects: Divides the complex value <code>rhs</code> into the complex value <code>*this</code>\n  and stores the quotient in <code>*this</code>.\n  Returns: <code>*this</code>.</p>\n</blockquote>\n<p>and in <code>[complex.ops]</code>:</p>\n<blockquote>\n<pre><code>template&lt;class T&gt; complex&lt;T&gt; operator/(const T&amp; lhs, const complex&lt;T&gt;&amp; rhs);\n</code></pre>\n<p id=\"so_23519366_23520299_2\">Returns: <code>complex&lt;T&gt;(lhs) /= rhs</code>.</p>\n</blockquote>\n<hr>\n<p>As the inverse of <code>1.e-162</code> is <code>1.e+162</code> and this number is in the range of representable values for a <code>double</code>, the behavior is well defined.</p>\n<p>Thus gcc gets it right and clang has a bug.</p>\n</hr>", "OwnerUserId": "316448", "LastEditorUserId": "316448", "LastEditDate": "2014-05-07T16:57:04.617", "Id": "23520299", "Score": "5", "CreationDate": "2014-05-07T14:16:11.623", "LastActivityDate": "2014-05-07T16:57:04.617"}, "23520226": {"ParentId": "23519366", "CommentCount": "0", "Body": "<p>Yes. You should report a bug.</p>\n<p>The complex number 1e-162+0i is identical to the real number 1e-162. This falls well within the range of double. The reciprocal of this value is and should be 1e+162. Any other value represents a bug in the arithmetic libraries.</p>\n<p>The value returned by clang is wrong. It's a bug.</p>\n", "OwnerUserId": "1105562", "PostTypeId": "2", "Id": "23520226", "Score": "1", "CreationDate": "2014-05-07T14:13:04.727", "LastActivityDate": "2014-05-07T14:13:04.727"}, "bq_ids": {"n4140": {"so_23519366_23519448_0": {"section_id": 5937, "quality": 0.8717948717948718, "length": 34}, "so_23519366_23520299_1": {"section_id": 3419, "quality": 0.8181818181818182, "length": 9}, "so_23519366_23520299_0": {"section_id": 3401, "quality": 1.0, "length": 11}}, "n3337": {"so_23519366_23519448_0": {"section_id": 5709, "quality": 0.8717948717948718, "length": 34}, "so_23519366_23520299_1": {"section_id": 3288, "quality": 0.8181818181818182, "length": 9}, "so_23519366_23520299_0": {"section_id": 3270, "quality": 1.0, "length": 11}}, "n4659": {"so_23519366_23519448_0": {"section_id": 7421, "quality": 0.6923076923076923, "length": 27}, "so_23519366_23520299_0": {"section_id": 4158, "quality": 1.0, "length": 11}, "so_23519366_23520299_1": {"section_id": 4181, "quality": 0.8181818181818182, "length": 9}}}, "23519448": {"ParentId": "23519366", "PostTypeId": "2", "CommentCount": "10", "Body": "<p><strong>Update:</strong></p>\n<p><strong>Quoting from the standard:</strong></p>\n<blockquote>\n<p id=\"so_23519366_23519448_0\">If during the evaluation of an expression, the result is not\n  mathematically de\ufb01ned or not in the range of representable values for\n  its type, <strong>the behavior is unde\ufb01ned</strong>. [ Note: most existing\n  implementations of C++ ignore integer over\ufb02ows. Treatment of division\n  by zero, forming a remainder using a zero divisor, and all \ufb02oating\n  point exceptions vary among machines, and is usually adjustable by a\n  library function].</p>\n</blockquote>\n<p><strong>Quoting from</strong> <a href=\"http://lists.freebsd.org/pipermail/freebsd-numerics/2014-March/000549.html\" rel=\"nofollow noreferrer\">http://lists.freebsd.org/pipermail/freebsd-numerics/2014-March/000549.html</a>:</p>\n<blockquote>\n<p id=\"so_23519366_23519448_1\">It appears that clang developers have chosen the naive complex\n  division algorithm.</p>\n<p id=\"so_23519366_23519448_2\">...</p>\n<p id=\"so_23519366_23519448_3\">I did a bit of grepping.  Could it be that the division algorithm is\n  contained in the file\n  src/contrib/llvm/tools/clang/lib/CodeGen/CGExprComplex.cpp inside the\n  function ComplexExprEmitter::EmitBinDiv ?</p>\n<p id=\"so_23519366_23519448_4\">If you look at the code, it certainly looks like it is generating code\n  to perform complex division, and it definitely looks like they are\n  using the naive algorithm.</p>\n</blockquote>\n<p>Assuming that indeed the clang uses naive complex division the expression <code>1.0 / c</code> evaluates according to the naive implementation of complex division to the following expression \n<img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/UVMaK.gif\">,</img></p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/UHhLq.gif\"/></p>\n<p>1.e-324 is out of the double range. This results according to the standard to <strong>undefined behaviour</strong>.</p>\n<p>Also making a search in the <a href=\"http://llvm.org/bugs/buglist.cgi?query_format=specific&amp;order=relevance%20desc&amp;bug_status=__open__&amp;product=&amp;content=complex%20division\" rel=\"nofollow noreferrer\">LLVM/Clang bug list</a>, it appears that there are quite some issues concerning <em>complex division.</em></p>\n<p><strong>As such your case is a bug and you should report it.</strong></p>\n<p>For anyone who is interested on how robust complex division is implemented take a look at</p>\n<ol>\n<li><a href=\"http://ideone.com/bqFk8j\" rel=\"nofollow noreferrer\">http://ideone.com/bqFk8j</a> and</li>\n<li><a href=\"http://arxiv.org/abs/1210.4539\" rel=\"nofollow noreferrer\">A Robust Complex Division in Scilab.</a></li>\n</ol>\n", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "LastEditDate": "2014-05-08T17:10:37.567", "Id": "23519448", "Score": "2", "CreationDate": "2014-05-07T13:38:43.810", "LastActivityDate": "2014-05-08T17:10:37.567"}});