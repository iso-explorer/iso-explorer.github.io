post_cb({"6085531": {"CommentCount": "1", "AcceptedAnswerId": "6085570", "CreationDate": "2011-05-22T01:45:55.207", "LastActivityDate": "2014-04-03T14:23:58.750", "PostTypeId": "1", "ViewCount": "3577", "FavoriteCount": "1", "Title": "C++ SegFault when dereferencing a pointer for cout", "Id": "6085531", "Score": "4", "Body": "<p>I'm new to C++ and just trying to get a hang of it. It generally seems not too bad, but I stumbled upon this weird/pathological segfaulting behavior:</p>\n<pre><code>int main () {\n  int* b;\n  *b = 27;\n  int c = *b;\n  cout &lt;&lt; \"c points to \" &lt;&lt; c &lt;&lt; endl; //OK                                                                                                                                      \n  printf( \"b points to %d\\n\", *b); //OK                                                                                                                                          \n  // cout &lt;&lt; \"b points to \" &lt;&lt; (*b) &lt;&lt; endl; - Not OK: segfaults!                                                                                                               \n  return 0;\n}\n</code></pre>\n<p>This program, as given, produces what you'd expect:</p>\n<pre><code>c points to 27\nb points to 27\n</code></pre>\n<p>On the other hand, if you uncomment the second-to-last line, you get a program that crashes (seg-fault) in runtime. Why? This is a valid pointer. </p>\n", "Tags": "<c++><pointers><segmentation-fault><cout>", "OwnerUserId": "764410", "AnswerCount": "5"}, "6085570": {"ParentId": "6085531", "CommentCount": "0", "Body": "<p><code>int* b</code> points to an unknown memory address because it wasn't initialized.  If you initialized it to whatever null value exists for your compiler (0 or NULL in C++, nullptr in C++0x), you'd most certainly get a segfault earlier.  The problem lies in the fact that you allocated space for the pointer but not the data it points to.  If you instead did this:</p>\n<pre><code>int c = 27;\nint* b = &amp;c;\n\ncout &lt;&lt; \"c points to \" &lt;&lt; c &lt;&lt; endl;\nprintf (\"b points to %d\\n\", *b);\ncout &lt;&lt; \"b points to \" &lt;&lt; (*b) &lt;&lt; endl;\n</code></pre>\n<p>Things would work because <code>int* b</code> refers to a memory location that is accessible by your program (since the memory is actually a part of your program).</p>\n<p>If you leave a pointer uninitialized or assign a null value to it, you can't use it until it points to a memory address that you KNOW you can access.  For example, using dynamic allocation with the <code>new</code> operator will reserve memory for the data for you:</p>\n<pre><code>int* b = new int();\n*b = 27;\nint c = *b;\n\n//output\n\ndelete b;\n</code></pre>\n", "OwnerUserId": "539810", "PostTypeId": "2", "Id": "6085570", "Score": "6", "CreationDate": "2011-05-22T01:57:48.463", "LastActivityDate": "2011-05-22T01:57:48.463"}, "6085538": {"ParentId": "6085531", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The pointer is valid in as much it's got a value. But the memory is probably not. It's your OS telling you that you are touching memory which isn't yours.</p>\n<p>I'm frankly surprised it doesn't crash earlier than that. </p>\n<hr>\n<p>Here's why:</p>\n<pre><code>int* b; // b is uninitialized.\n*b = 27;\n</code></pre>\n<p>Where does <code>b</code> point? It might be somewhere valid, or somewhere totally off-limits. You can usually bet on the latter. </p>\n<p>Here's a better way to do what you want.</p>\n<pre><code>int b1 = 27;\nint *b = &amp;b1;\n</code></pre>\n<p>Now <code>b</code> points to the location on the stack where <code>b1</code>s value is stored.</p>\n</hr>", "OwnerUserId": "12183", "LastEditorUserId": "12183", "LastEditDate": "2011-05-22T02:06:28.303", "Id": "6085538", "Score": "3", "CreationDate": "2011-05-22T01:48:03.803", "LastActivityDate": "2011-05-22T02:06:28.303"}, "19257423": {"ParentId": "6085531", "CommentCount": "1", "Body": "<p>General rule: <strong>initialize variable before using it</strong></p>\n<p><code>char* f;</code> is a variable. <code>*f</code> is usage of this variable. Like any variable, <code>f</code> must be initialized before usage.</p>\n", "OwnerUserId": "2333290", "PostTypeId": "2", "Id": "19257423", "Score": "1", "CreationDate": "2013-10-08T20:13:18.837", "LastActivityDate": "2013-10-08T20:13:18.837"}, "19257002": {"ParentId": "6085531", "CommentCount": "1", "Body": "<p>This is because <code>f</code> is a pointer and it need to be allocated some memory for it.</p>\n", "OwnerUserId": "1153165", "PostTypeId": "2", "Id": "19257002", "Score": "1", "CreationDate": "2013-10-08T19:50:40.800", "LastActivityDate": "2013-10-08T19:50:40.800"}, "19257003": {"ParentId": "6085531", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><b>Update 3</b></p>\n<p>My answer to <a href=\"https://stackoverflow.com/a/20614158/1708801\">Where exactly does C++ standard say dereferencing an uninitialized pointer is undefined behavior?</a> gives a much better answer to why using an uninitialized pointer is undefined behavior. The basic logic from  the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">C++ draft standard</a>, section <code>24.2</code> <em>Iterator requirements</em>, specifically section <code>24.2.1</code> <em>In general</em> paragraph <em>5</em> and <em>10</em>  which respectively say (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_6085531_19257003_0\">[...][ Example: After the declaration of an <strong>uninitialized pointer</strong> x (as with int* x;), x <strong>must always be assumed to have a singular value of a pointer</strong>. \u2014end example ] [...] <strong>Dereferenceable values are always non-singular.</strong></p>\n</blockquote>\n<p><b>Update 2</b></p>\n<p>This was originally an answer to a <em>C</em> question with nearly identical circumstances but the original question I answered was merged with this one. I am updating my answer to include an answer specific to the new question and to the <em>C++</em> draft standard.</p>\n<p><code>b</code> has not be initialized and therefore it's value is <em>indeterminate</em> but you used indirection on <code>b</code> which is <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow noreferrer\">undefined behavior</a>.</p>\n<p>One possible simple fix would be to assign <code>b</code> to the address of an existing variable, for example:</p>\n<pre><code>int a ;\nint* b = &amp;a;\n</code></pre>\n<p>Another option would have been to use dynamic allocation via <em>new</em>.</p>\n<p>For completeness sake we can see this is <em>undefined behavior</em> by going to the draft C++ standard section <code>5.3.1</code> <em>Unary operators</em> paragraph <em>1</em> which says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_6085531_19257003_1\">The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and <strong>the result is an lvalue referring to the object</strong> or function to which the expression points.[...]</p>\n</blockquote>\n<p>and if we then go to section <code>3.10</code> <em>Lvalues and rvalues</em> paragraph <em>1</em> says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_6085531_19257003_2\">An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object. [...]</p>\n</blockquote>\n<p>but <code>b</code> does not point to a valid <em>object</em>.</p>\n<p><b>Original Answer</b></p>\n<p>You did not allocate any memory to <code>f</code> nor <code>b</code> but you used indirection on both which is <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow noreferrer\">undefined behavior</a>.</p>\n<p><b>Update</b></p>\n<p>It is worth noting that cranking up the warning levels should have indicated this was a problem, for example using <code>gcc -Wall</code> gives me the following warning for this code:</p>\n<pre><code>warning: 'f' is used uninitialized in this function [-Wuninitialized]\n</code></pre>\n<p>The simplest fix would be to assign <code>f</code> to point to a valid object like so:</p>\n<pre><code>char a ;\nchar *f = &amp;a ;\n</code></pre>\n<p>Another options would be to use dynamic allocation, if you don't have a handy reference the <a href=\"http://c-faq.com/ptrs/index.html\" rel=\"nofollow noreferrer\">C FAQ</a> is not a bad place to start.</p>\n<p>for completeness sake, if we look at the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow noreferrer\">C99 draft standard</a> Annex <code>J.2</code> <em>Undefined behavior</em> paragraph <em>1</em> says:</p>\n<blockquote>\n<p id=\"so_6085531_19257003_3\">The behavior is undefined in the following circumstances:</p>\n</blockquote>\n<p>and includes the following bullet:</p>\n<blockquote>\n<p id=\"so_6085531_19257003_4\">The value of an object with automatic storage duration is used while it is\n  indeterminate (6.2.4, 6.7.8, 6.8).</p>\n</blockquote>\n<p>The value of <code>f</code> and <code>b</code> are both automatic variables and are indeterminate since they are not initialized.  </p>\n<p>It is not clear from reading the referenced sections which statement makes it undefined but section <code>6.5.2.5</code> <em>Compound literals</em> paragraph <em>17</em> which is part of normative text has an example with the following text which uses the same language and says:</p>\n<blockquote>\n<p id=\"so_6085531_19257003_5\">[...]next time around p would have an indeterminate value, which would result in undefined behavior. </p>\n</blockquote>\n<p>In the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow noreferrer\">C11 draft standard</a> the paragraph is <em>16</em>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:18.380", "Id": "19257003", "Score": "8", "CreationDate": "2013-10-08T19:50:41.363", "LastActivityDate": "2014-04-03T14:23:58.750"}, "bq_ids": {"n4140": {"so_6085531_19257003_2": {"section_id": 7230, "quality": 0.9285714285714286, "length": 13}, "so_6085531_19257003_1": {"section_id": 6064, "quality": 0.9, "length": 18}, "so_6085531_19257003_0": {"section_id": 5559, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_6085531_19257003_2": {"section_id": 6974, "quality": 0.9285714285714286, "length": 13}, "so_6085531_19257003_1": {"section_id": 5832, "quality": 0.9, "length": 18}, "so_6085531_19257003_0": {"section_id": 5341, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_6085531_19257003_1": {"section_id": 7560, "quality": 0.9, "length": 18}, "so_6085531_19257003_4": {"section_id": 4053, "quality": 0.6, "length": 6}, "so_6085531_19257003_0": {"section_id": 7006, "quality": 0.8421052631578947, "length": 16}}}});