post_cb({"6464441": {"ParentId": "6464404", "CommentCount": "1", "Body": "<p>your variable is of type B, so the function of B will be called. To call D, you have to either declare your variable as D, or cast to D.</p>\n", "OwnerUserId": "788824", "PostTypeId": "2", "Id": "6464441", "Score": "0", "CreationDate": "2011-06-24T06:56:33.233", "LastActivityDate": "2011-06-24T06:56:33.233"}, "6464404": {"CommentCount": "1", "AcceptedAnswerId": "6464551", "PostTypeId": "1", "LastEditorUserId": "160206", "CreationDate": "2011-06-24T06:52:45.650", "LastActivityDate": "2017-04-10T21:10:45.990", "LastEditDate": "2011-06-24T06:54:23.480", "ViewCount": "3780", "FavoriteCount": "7", "Title": "virtual function default arguments behaviour", "Id": "6464404", "Score": "32", "Body": "<p>I have a strange situation over the following code. Please help me to get it clarified.</p>\n<pre><code>class B\n{\n       public:\n            B();\n            virtual void print(int data=10)\n            {\n                  cout &lt;&lt; endl &lt;&lt; \"B--data=\" &lt;&lt; data;\n            }\n};\nclass D:public B\n{\n       public:\n            D();\n            void print(int data=20)\n            {\n                  cout &lt;&lt; endl &lt;&lt; \"D--data=\" &lt;&lt; data;\n            }\n};\n\nint main()\n{\n     B *bp = new D();\n     bp-&gt;print();\nreturn 0;\n}\n</code></pre>\n<p>Regarding the output I expected</p>\n<pre><code>[ D--data=20 ]\n</code></pre>\n<p>But in practical it is</p>\n<pre><code>[ D--data=10 ]\n</code></pre>\n<p>Please help. It may seem obvious for you but I am not aware of the internal mechanism.</p>\n", "Tags": "<c++>", "OwnerUserId": "646210", "AnswerCount": "6"}, "6464503": {"ParentId": "6464404", "CommentCount": "0", "Body": "<p>Generally, those default arguments are used that are visible at a certain scope. You can do (but shouldn't) funky things:</p>\n<pre><code>#include &lt;iostream&gt;\nvoid frob (int x) {\n    std::cout &lt;&lt; \"frob(\" &lt;&lt; x &lt;&lt; \")\\n\";\n}\n\nvoid frob (int = 0);\nint main () {\n    frob();                     // using 0\n    {\n        void frob (int x=5) ;\n        frob();                 // using 5\n    }\n    {\n        void frob (int x=-5) ;\n        frob();                 // using -5\n    }\n}\n</code></pre>\n<p>In your case, the base class signature is visible. In order to use the derived default arguments, you must explicitly call that function through a pointer to your derived class, either by declaring it that way, or by casting it rightly.</p>\n", "OwnerUserId": "76722", "PostTypeId": "2", "Id": "6464503", "Score": "3", "CreationDate": "2011-06-24T07:02:24.707", "LastActivityDate": "2011-06-24T07:02:24.707"}, "6464470": {"ParentId": "6464404", "CommentCount": "0", "Body": "<p>Default argument value is passed on behalf of the caller. From the caller viewpoint it works with class B (not D), so it passes 10 (as for class B)</p>\n", "OwnerUserId": "396672", "PostTypeId": "2", "Id": "6464470", "Score": "1", "CreationDate": "2011-06-24T06:59:12.887", "LastActivityDate": "2011-06-24T06:59:12.887"}, "6464440": {"ParentId": "6464404", "CommentCount": "1", "Body": "<p>The standard says (8.3.6.10):</p>\n<blockquote>\n<p id=\"so_6464404_6464440_0\">A virtual function call (10.3) uses\n  the default arguments in the\n  declaration of the virtual function\n  determined by the static type of the\n  pointer or reference denoting the\n  object. An overriding function in a\n  derived class does not acquire default\n  arguments from the function it\n  overrides.</p>\n</blockquote>\n<p>This means, since you are calling <code>print</code> through a pointer of type <code>B</code>, it uses the default argument of <code>B::print</code>.</p>\n", "OwnerUserId": "160206", "PostTypeId": "2", "Id": "6464440", "Score": "30", "CreationDate": "2011-06-24T06:56:30.097", "LastActivityDate": "2011-06-24T06:56:30.097"}, "29483458": {"ParentId": "6464404", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The dynamic binding is using vpointer and vtable. However, the dynamic binding only applies to function pointer. There is no mechanism to dynamic bind argument.</p>\n<p>Thus, the default argument is determined statically at compiler time. In this case, it is statically determined by bp type, which is a pointer to Base class. Thus data = 10 is passed as function argument, while the function pointer is pointing to Derived class member function: D::print. Essentially, it calls D::print(10).</p>\n<p>The following code snippet and the resulting outputs clearly demonstrate the point: even though it calls the Derived call member function Derived::resize(int), it passes the Base class default argument: size=0.</p>\n<p>virtual void Derived::resize(int) size 0</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\nusing namespace std;\n\n#define pr_dbgc(fmt,args...) \\\n    printf(\"%d %s \" fmt \"\\n\",__LINE__,__PRETTY_FUNCTION__, ##args);\n\nclass Base {\n   public:\n       virtual void resize(int size=0){\n           pr_dbgc(\"size %d\",size);\n       }\n};\n\nclass Derived : public Base {\n   public:\n       void resize(int size=3){\n           pr_dbgc(\"size %d\",size);\n       }\n};\n\nint main()\n{   \n    Base * base_p = new Base;\n    Derived * derived_p = new Derived;\n\n    base_p-&gt;resize();           /* calling base member function   \n                                   resize with default\n                                   argument value --- size 0 */\n    derived_p-&gt;resize();        /* calling derived member      \n                                   function resize with default \n                                   argument default --- size 3 */\n\n    base_p = derived_p;         /* dynamic binding using vpointer \n                                   and vtable */\n                                /* however, this dynamic binding only\n                                   applied to function pointer. \n                                   There is no mechanism to dynamic \n                                   binding argument. */\n                                /* So, the default argument is determined\n                                   statically by base_p type,\n                                   which is pointer to base class. Thus\n                                   size = 0 is passed as function \n                                   argument */\n\n    base_p-&gt;resize();           /* polymorphism: calling derived class   \n                                   member function \n                                   however with base member function  \n                                   default value 0 --- size 0 */\n\n     return 0;\n}\n\n\n #if 0\n The following shows the outputs:\n 17 virtual void Base::resize(int) size 0\n 24 virtual void Derived::resize(int) size 3\n 24 virtual void Derived::resize(int) size 0\n #endif\n</code></pre>\n", "OwnerUserId": "4756974", "LastEditorUserId": "4756974", "LastEditDate": "2015-04-07T03:59:41.530", "Id": "29483458", "Score": "0", "CreationDate": "2015-04-07T03:54:26.463", "LastActivityDate": "2015-04-07T03:59:41.530"}, "bq_ids": {"n4140": {"so_6464404_6464440_0": {"section_id": 3261, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_6464404_6464440_0": {"section_id": 3133, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_6464404_6464440_0": {"section_id": 4019, "quality": 0.9629629629629629, "length": 26}}}, "6464551": {"ParentId": "6464404", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Default arguments are entirely compile-time feature. I.e. the substitution of default arguments in place of missing arguments is performed at compile time. For this reason, obviously, there's no way default argument selection for member functions can depend on the <em>dynamic</em> (i.e. run-time) type of the object. It always depends on <em>static</em> (i.e. compile-time) type of the object. </p>\n<p>The call you wrote in your code sample is immediately interpreted by the compiler as <code>bp-&gt;print(10)</code> regardless of anything else.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2017-04-10T21:10:45.990", "Id": "6464551", "Score": "22", "CreationDate": "2011-06-24T07:07:30.607", "LastActivityDate": "2017-04-10T21:10:45.990"}});