post_cb({"bq_ids": {"n4140": {"so_48501490_48502508_1": {"length": 22, "quality": 1.0, "section_id": 480}}, "n3337": {"so_48501490_48502508_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 471}}, "n4659": {"so_48501490_48502508_1": {"length": 22, "quality": 1.0, "section_id": 502}}}, "48502508": {"Id": "48502508", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48501490_48502508_0\">So, talking performance and (in case it matters) C++14, can I return a SetOfSets here or should I just pass it by reference as an out parameter?</p>\n</blockquote>\n<p>If you use a decent compiler, you can safely return it by value as copy elision will occur. But. But copy elision is not guaranteed<sup>1</sup> and your compiler might do it only when the right optimization flags are given.</p>\n<blockquote>\n<h3><a href=\"http://eel.is/c++draft/class.copy.elision#1.sentence-1\" rel=\"nofollow noreferrer\"><code>[class.copy.elision]/1</code></a></h3>\n<p id=\"so_48501490_48502508_1\">When certain criteria are met, an implementation <strong>is allowed</strong> to omit the copy/move construction of a class object, even if the constructor selected for the copy/move operation and/or the destructor for the object have side effects.</p>\n</blockquote>\n<p>This means you should only rely on copy elision if your program still makes sense if it is not performed.</p>\n<hr>\n<p><sup>1)</sup> except for <code>constexpr</code> objects</p>\n</hr>", "LastEditorUserId": "5470596", "LastActivityDate": "2018-01-29T13:39:52.500", "Score": "0", "CreationDate": "2018-01-29T13:33:11.223", "ParentId": "48501490", "CommentCount": "0", "OwnerUserId": "5470596", "LastEditDate": "2018-01-29T13:39:52.500"}, "48502579": {"Id": "48502579", "PostTypeId": "2", "Body": "<p>Not really. It is really common, though not guaranteed, so it all depends on your required confidence level.</p>\n<p>AFAIK this description is up-to date and covers your topic <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow noreferrer\">copy_elision</a>.</p>\n<p>The key sentences are: \"<em>Under the following circumstances,  <strong>the compilers are permitted, but not required</strong> to omit the copy- and move- construction of class objects even if the copy/move constructor and the destructor have observable side-effects.</em>\"</p>\n<p>Then there is a description of NRVO (which you present). And, at the next bullet there is a description of <strong>anonymous temporary RVO</strong>, and a bullet that this one <strong>is mandatory since c++17. Otherwise none are guaranteed.</strong></p>\n<p>It doesn't matter how complicated type is<sup>\u2020</sup>, whatever \"<em>complicated</em>\" means. Those optimization kick in based on the status of the variable e.g: \"<em>a nameless temporary, not bound to any references, would be copied or moved into an object of the same type (ignoring top-level cv-qualification)</em>\". Note that none of this related to the inner working of the type of variable<sup>\u2020</sup>, but rather the context in which it is used.</p>\n<p>What you can do, is to make a minimal example and put it through compiler and analyze assembly to see if the optimization kicked in, or <a href=\"https://clang.llvm.org/docs/UsersManual.html#options-to-emit-optimization-reports\" rel=\"nofollow noreferrer\">generate optimization report</a>, and see yourself.</p>\n<hr>\n<p><sup>\u2020</sup> The only reference is explicit statement that optimization is allowed for types with side-effects on construction and destruction. But this serves as exceptional enabling clause. For types with no side-effects those are already possible by default.</p>\n</hr>", "LastActivityDate": "2018-01-29T13:37:22.503", "Score": "0", "CreationDate": "2018-01-29T13:37:22.503", "ParentId": "48501490", "CommentCount": "0", "OwnerUserId": "1133179"}, "48501490": {"ViewCount": "174", "Body": "<p>Consider something like this:</p>\n<pre><code>typedef std::unordered_multiset&lt;int&gt; Set;\ntypedef std::set&lt;Set&gt; SetOfSets;\n\nSetOfSets somethingRecursive(SomeType somethingToAnalyze) {\n    Set s;\n    // ...\n    // check base cases, reduce somethingToAnalyze, fill in s\n    // ...\n    SetOfSets ss = somethingRecursive(somethingToAnalyze);\n    ss.insert(s);\n    return ss;\n}\n</code></pre>\n<p>This approach is fairly standard for problems like generating subsets, permutations, etc. However, I tried making a diagram of what exactly Return Value Optimization should optimize here given the fairly complex internal data structure of the type (<code>std::unordered_multiset</code> is a hash table and <code>std::set</code> is 'typically' a binary search tree) and, well, I can only hope that compilers are smarter than me.</p>\n<p>So, talking performance and (in case it matters) <code>C++14</code>, can I return a <code>SetOfSets</code> here or should I just pass it by reference as an out parameter?</p>\n", "AcceptedAnswerId": "48502460", "Title": "Can I rely on named return value optimisation for complicated return types?", "CreationDate": "2018-01-29T12:39:20.633", "LastActivityDate": "2018-01-29T14:09:56.863", "CommentCount": "14", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-29T13:00:22.950", "LastEditorUserId": "2380830", "Id": "48501490", "Score": "4", "OwnerUserId": "6885358", "Tags": "<c++><rvo><nrvo>", "AnswerCount": "3"}, "48502460": {"Id": "48502460", "PostTypeId": "2", "Body": "<p>Before C++17, you cannot rely on copy elision at all, since it is optional. However, all mainstream compilers will very likely apply it (e.g., GCC applies it even with <code>-O0</code> optimization flag, you need to explicitly disable copy elision by <code>-fno-elide-constructors</code> if you want to).</p>\n<p>However, <code>std::set</code> supports move semantics, so even without NRVO, your code would be fine.</p>\n<p>Note that in C++17, NRVO is optional as well. <s>RVO is mandatory.</s></p>\n<hr>\n<p>To be technically correct, IMO, there is no RVO in C++17, since when prvalue is returned, no temporary is materialized to be moved/copied from. The rules are kind of different, but the effect is more or less the same. Or, even stronger, since there is no need for copy/move constructor to return prvalue by value in C++17:</p>\n<pre><code>#include &lt;atomic&gt;\n\nstd::atomic&lt;int&gt; f() {\n  return std::atomic&lt;int&gt;{0};\n}\n\nint main() {\n  std::atomic&lt;int&gt; i = f();\n}\n</code></pre>\n<p>In C++14, this code does not compile.</p>\n</hr>", "LastEditorUserId": "580083", "LastActivityDate": "2018-01-29T14:09:56.863", "Score": "4", "CreationDate": "2018-01-29T13:30:53.953", "ParentId": "48501490", "CommentCount": "6", "OwnerUserId": "580083", "LastEditDate": "2018-01-29T14:09:56.863"}});