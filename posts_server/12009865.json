post_cb({"bq_ids": {"n4140": {"so_12009865_12009901_0": {"length": 30, "quality": 0.9375, "section_id": 660}}, "n3337": {"so_12009865_12009901_0": {"length": 30, "quality": 0.9375, "section_id": 650}}, "n4659": {"so_12009865_12009901_0": {"length": 30, "quality": 0.9375, "section_id": 688}}}, "12010297": {"Id": "12010297", "PostTypeId": "2", "Body": "<p>The assignment operator <em>is</em> inherited, sort of, but... In any given\nclass, if you do not provide a copy assignment operator, the compiler\ngenerates one for you.  That means that your derived classes effectively\nhave an assignment operator:</p>\n<pre><code>Derived&amp; operator=( Derived const&amp; );\n</code></pre>\n<p>And the usual hiding rules apply; this hides all of the base class\nassignment operators.  (If the base class had an assignment operator\nwith this signature, the derived class would inherit it normally.) </p>\n", "LastActivityDate": "2012-08-17T17:22:52.453", "CommentCount": "0", "CreationDate": "2012-08-17T17:22:52.453", "ParentId": "12009865", "Score": "7", "OwnerUserId": "649665"}, "12009901": {"Id": "12009901", "PostTypeId": "2", "Body": "<p>The assignment operator is technically inherited; however, it is always hidden by an explicitly or implicitly defined assignment operator for the derived class (see comments below).</p>\n<blockquote>\n<p id=\"so_12009865_12009901_0\">(13.5.3 Assignment) An assignment operator shall be implemented by a\n  non-static member function with exactly one parameter. Because a copy\n  assignment operator <code>operator=</code> is implicitly declared for a a class if\n  not declared by the user, a base class assignment operator is always\n  hidden by the copy assignment operator of the derived class.</p>\n</blockquote>\n<p>You can implement a dummy assignment operator which simply forwards the call to the base class <code>operator=</code>, like this:</p>\n<pre><code>// Derived class\ntemplate&lt;typename T, unsigned int N&gt; class Derived : public Base&lt;Derived, T, N&gt;\n{\npublic:\n    template&lt;typename T0, class = typename std::enable_if&lt;std::is_convertible&lt;T0, T&gt;::value&gt;::type&gt;\n    inline Derived&amp; operator=(const T0&amp; rhs)\n    {\n        return Base&lt;Derived, T, N&gt;::operator=(rhs);\n    }\n};\n</code></pre>\n", "LastEditorUserId": "463074", "LastActivityDate": "2012-08-17T17:41:42.023", "Score": "25", "CreationDate": "2012-08-17T16:52:48.597", "ParentId": "12009865", "CommentCount": "5", "OwnerUserId": "463074", "LastEditDate": "2012-08-17T17:41:42.023"}, "12009865": {"ViewCount": "15829", "Body": "<p>Until a test I've just made, I believed that only Constructors were not inherited in C++. But apparently, the assignment <code>operator=</code> is not too... </p>\n<ol>\n<li>What is the reason of that ?  </li>\n<li>Is there any workaround to inherit the assignment operator ?  </li>\n<li>Is it also the case for <code>operator+=</code>, <code>operator-=</code>, ... ? </li>\n<li>Are all other functions (apart from constructors/operator=) inherited ?</li>\n</ol>\n<p>In fact, I encountered this problem as I was doing some CRTP :</p>\n<pre><code>template&lt;class Crtp&gt; class Base\n{\n    inline Crtp&amp; operator=(const Base&lt;Crtp&gt;&amp; rhs) {/*SOMETHING*/; return static_cast&lt;Crtp&amp;&gt;(*this);}\n};\n\nclass Derived1 : public Base&lt;Derived1&gt;\n{\n};\n\nclass Derived2 : public Base&lt;Derived2&gt;\n{\n};\n</code></pre>\n<p>Is there any solution to get that working ?</p>\n<p>EDIT : OK, I have isolated the problem. Why the following isn't working ? How to solve the problem ?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\n// Base class\ntemplate&lt;template&lt;typename, unsigned int&gt; class CRTP, typename T, unsigned int N&gt; class Base\n{\n    // Cast to base\n    public:\n        inline Base&lt;CRTP, T, N&gt;&amp; operator()()\n        {\n            return *this;\n        }\n\n    // Operator =\n    public:\n        template&lt;typename T0, class = typename std::enable_if&lt;std::is_convertible&lt;T0, T&gt;::value&gt;::type&gt;\n        inline CRTP&lt;T, N&gt;&amp; operator=(const T0&amp; rhs)\n        {\n            for (unsigned int i = 0; i &lt; N; ++i) {\n                _data[i] = rhs;\n            }\n            return static_cast&lt;CRTP&lt;T, N&gt;&amp;&gt;(*this);\n        }\n\n    // Data members\n    protected:\n        T _data[N];\n};\n\n// Derived class\ntemplate&lt;typename T, unsigned int N&gt; class Derived : public Base&lt;Derived, T, N&gt;\n{\n};\n\n// Main\nint main()\n{\n    Derived&lt;double, 3&gt; x;\n    x() = 3; // &lt;- This is OK\n    x = 3;   // &lt;- error: no match for 'operator=' in ' x=3 '\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "12009901", "Title": "operator= and functions that are not inherited in C++?", "CreationDate": "2012-08-17T16:50:16.803", "Id": "12009865", "CommentCount": "8", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2012-08-17T17:15:06.467", "LastEditorUserId": "882932", "LastActivityDate": "2012-08-17T17:41:42.023", "Score": "24", "OwnerUserId": "882932", "Tags": "<c++><inheritance><operator-overloading><crtp>", "AnswerCount": "3"}, "12010455": {"Id": "12010455", "PostTypeId": "2", "Body": "<ol>\n<li><p>Your assignment operator is technically inherited, but then it's hidden by the default copy assignment operator in the derived class. This default copy assignment then tries to call the base class's copy assignment which doesn't exist since you hid it with your own assignment.</p></li>\n<li><p>The sanest way to resolve this is to not use operator overloading in non-obvious ways (<code>=</code> not meaning copy assignment for example). In this case, don't use <code>operator=</code>: Call it something like <code>assign</code> or <code>set</code> and then it will inherit and not be hidden by the child copy assignment.</p></li>\n<li><p>These operators are inherited and there are no compiler versions so they will never be automatically hidden like <code>operator=</code>.</p></li>\n<li><p>It really is only constructors that aren't inherited, and I can't think of any other compiler-generated functions that could hide something from the parent as in <code>operator=</code>.</p></li>\n</ol>\n", "LastActivityDate": "2012-08-17T17:33:14.633", "CommentCount": "0", "CreationDate": "2012-08-17T17:33:14.633", "ParentId": "12009865", "Score": "5", "OwnerUserId": "251738"}});