post_cb({"4404753": {"ParentId": "4404725", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>All standard C++ headers don't want the <code>.h</code> in the end. I read somewhere that the concept is that they don't need to be actual files, <s>even if I never saw an implementation do it in another manner</s> <strong><em>edit:</em></strong> <i>actually the compiler intrinsics should work considering the headers included but not actually including them as files; see <em>@Yttrill</em>'s comment</i>.</p>\n<p>For the <code>stdio.h</code> thing, in a C++ application you shouldn't include <code>&lt;stdio.h&gt;</code>, but you should instead include <code>&lt;cstdio&gt;</code>. In general, you shouldn't include the \"normal\" C headers, but their C++-ized counterparts, which haven't got the <code>.h</code> in the end, have a <code>c</code> in front and <em>put all the symbols defined in them in the <code>std</code> namespace</em>. So, <code>&lt;math.h&gt;</code> becomes <code>&lt;cmath&gt;</code>, <code>&lt;stdlib.h&gt;</code> becomes <code>&lt;cstdlib&gt;</code>, and so on.</p>\n<p>In general, you should use the C++-ized versions of C headers both to avoid to pollute the global namespace (assuming you're not one of those guys who put <code>using namespace std;</code> everywhere) and to benefit of some C++ improvements to the standard C headers (e.g. added overloading to some math functions).\n<hr/>\nIn general, the implementation of this whole thing is simply done by having such files without extension in the directory in which the compiler looks for the header files. In my g++ 4.4 installation, for example, you have:</p>\n<pre><code>matteo@teoubuntu:/usr/include/c++/4.4$ ls\nalgorithm           cstdarg              functional        sstream\narray               cstdatomic           initializer_list  stack\nbackward            cstdbool             iomanip           stdatomic.h\nbits                cstddef              ios               stdexcept\nbitset              cstdint              iosfwd            streambuf\nc++0x_warning.h     cstdio               iostream          string\ncassert             cstdlib              istream           system_error\nccomplex            cstring              iterator          tgmath.h\ncctype              ctgmath              limits            thread\ncerrno              ctime                list              tr1\ncfenv               cwchar               locale            tr1_impl\ncfloat              cwctype              map               tuple\nchrono              cxxabi-forced.h      memory            typeinfo\ncinttypes           cxxabi.h             mutex             type_traits\nciso646             debug                new               unordered_map\nclimits             deque                numeric           unordered_set\nclocale             exception            ostream           utility\ncmath               exception_defines.h  parallel          valarray\ncomplex             exception_ptr.h      queue             vector\ncomplex.h           ext                  random            x86_64-linux-gnu\ncondition_variable  fenv.h               ratio\ncsetjmp             forward_list         regex\ncsignal             fstream              set\n</code></pre>\n<p>The C++-ized C headers <em>in theory</em> could just be a</p>\n<pre><code>namespace std\n{\n#include &lt;original_C_header.h&gt;\n};\n</code></pre>\n<p>but in general they are more complicated to deal with implementation-specific problems (especially regarding macros) and to add C++-related functionality (see e.g. the previous example of added overloads in <code>&lt;cmath&gt;</code>).</p>\n<p><hr/>\nBy the way, the C++ standard (\u00a7D.5) do not say that the <code>&lt;c***&gt;</code> headers should behave as if they included the <code>&lt;***.h&gt;</code> headers in a <code>namespace std</code> directive, but the opposite:</p>\n<blockquote>\n<p id=\"so_4404725_4404753_0\">For compatibility with the Standard C library, the C++ Standard library provides the 18 C headers [...]\n  Each C header, whose name has the form name.h, behaves as if each name placed in the Standard library namespace by the corresponding cname header is also placed within the namespace scope of the name-space std and is followed by an explicit using-declaration (7.3.3)</p>\n</blockquote>\n<p>Notice that such headers are considered deprecated (\u00a7C.2.1), so this is the main reason you shouldn't use them:</p>\n<blockquote>\n<p id=\"so_4404725_4404753_1\"><strong>C.2.1 Modifications to headers</strong>\n  For compatibility with the Standard C library, the C++ Standard library provides the 18 C headers (D.5),\n  but their use is deprecated in C++.</p>\n</blockquote>\n", "OwnerUserId": "214671", "LastEditorUserId": "214671", "LastEditDate": "2010-12-10T14:19:51.060", "Id": "4404753", "Score": "26", "CreationDate": "2010-12-10T01:07:24.853", "LastActivityDate": "2010-12-10T14:19:51.060"}, "4404725": {"CommentCount": "13", "AcceptedAnswerId": "4404753", "CreationDate": "2010-12-10T01:02:51.310", "LastActivityDate": "2010-12-10T14:19:51.060", "PostTypeId": "1", "ViewCount": "3428", "FavoriteCount": "4", "Title": "Why do some includes need the .h and others not?", "Id": "4404725", "Score": "25", "Body": "<p>Why is map imported as <code>#include &lt;map&gt;</code>, but stdio imported as <code>#include &lt;stdio.h&gt;</code>?</p>\n", "Tags": "<c++><include>", "OwnerUserId": "165495", "AnswerCount": "3"}, "4404751": {"ParentId": "4404725", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It's just the way it's defined by the C++ Standard -- as it happens, <code>map</code> and <code>stdio.h</code> don't even have to be real files.</p>\n<p>As a side-note, <code>stdio.h</code> is the header that was originally imported into C++ from the C standard libraries -- the C++ version is <code>cstdio</code>. In practical terms, this generally means that when you include <code>cstdio</code> instead, you get the stuff from <code>stdio.h</code>, but it's in namespace std.</p>\n<p>Just to clarify: the <code>stdio.h</code> you include in C++ is the C++ version of what was originally a C header. But the C++ way of writing the include is <code>cstdio</code>.</p>\n", "OwnerUserId": "499449", "LastEditorUserId": "499449", "LastEditDate": "2010-12-10T10:13:11.943", "Id": "4404751", "Score": "2", "CreationDate": "2010-12-10T01:06:52.813", "LastActivityDate": "2010-12-10T10:13:11.943"}, "4404744": {"ParentId": "4404725", "CommentCount": "3", "Body": "<p>It's simply the name of the actual file on disk. There is (probably) no file called <code>map.h</code> or <code>stdio</code> in your standard include directory.</p>\n<p>The C++ standard library moved away from the previous style of using <code>.h</code> toward not having <code>.h</code> at the end of the file names. This may <em>possibly</em> have been related to making the syntax look more like templates:</p>\n<pre><code>#include&lt;vector&gt;\n\nvector&lt;int&gt; v;\n</code></pre>\n<p><sup>(Preemptive comment: Yes, I know the above needs <code>std::</code> to build, but it's just an illustration.)</sup></p>\n", "OwnerUserId": "893", "PostTypeId": "2", "Id": "4404744", "Score": "2", "CreationDate": "2010-12-10T01:06:04.807", "LastActivityDate": "2010-12-10T01:06:04.807"}, "bq_ids": {"n4140": {"so_4404725_4404753_1": {"section_id": 2511, "quality": 0.6, "length": 9}, "so_4404725_4404753_0": {"section_id": 4907, "quality": 0.5142857142857142, "length": 18}}, "n3337": {"so_4404725_4404753_0": {"section_id": 4702, "quality": 0.5142857142857142, "length": 18}}, "n4659": {"so_4404725_4404753_1": {"section_id": 3239, "quality": 0.6, "length": 9}, "so_4404725_4404753_0": {"section_id": 6316, "quality": 0.5142857142857142, "length": 18}}}});