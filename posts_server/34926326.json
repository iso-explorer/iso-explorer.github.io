post_cb({"34926538": {"ParentId": "34926326", "CommentCount": "0", "Body": "<p>This will work because you are capturing all local variables by value by typing <strong>[=]</strong>. So f, s and d will be visible inside f2, but it would be only the copies, not the actual variables</p>\n", "OwnerUserId": "3943956", "PostTypeId": "2", "Id": "34926538", "Score": "0", "CreationDate": "2016-01-21T14:34:06.167", "LastActivityDate": "2016-01-21T14:34:06.167"}, "34926461": {"ParentId": "34926326", "CommentCount": "0", "Body": "<p>The code in question as asked (notwithstanding typo in inner lambda declaration) is correct. Since the first lambda is going to capture everything from the enclosing function, the second lambda is going to have access to it through 'capture all' of the enclosing lambda.</p>\n", "OwnerUserId": "5245033", "PostTypeId": "2", "Id": "34926461", "Score": "4", "CreationDate": "2016-01-21T14:30:08.087", "LastActivityDate": "2016-01-21T14:30:08.087"}, "34926996": {"ParentId": "34926326", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to the C++ Standard (5.1.2 Lambda expressions)</p>\n<blockquote>\n<p id=\"so_34926326_34926996_0\">9 A lambda-expression whose smallest enclosing scope is a block scope\n  (3.3.3) is a local lambda expression; any other lambda-expression\n  shall not have a capture-default or simple-capture in its\n  lambda-introducer. The reaching scope of a local lambda expression is\n  the set of enclosing scopes up to and <strong>including the innermost\n  enclosing function and its parameters.</strong> [ Note: <strong>This reaching scope\n  includes any intervening lambda-expressions</strong>. \u2014end note ]</p>\n</blockquote>\n<p>So the reaching scope of the second lambda is the scope of the member function <code>foo()</code>. As the lambda expression has default capture then it can capture local variables in this reaching scope.</p>\n<p>It is important also to pay attention to the following part of paragraph #13 of the same section</p>\n<blockquote>\n<p id=\"so_34926326_34926996_1\">13 ... If a lambda-expression captures an entity and that entity is\n  not defined or captured in the immediately enclosing lambda expression\n  or function, the program is ill-formed.</p>\n</blockquote>\n<p>In your example the enclosing lambda captures implicitly all required variables for the inner lambda from the function block scope using the default capture.</p>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2016-01-21T16:47:39.900", "Id": "34926996", "Score": "2", "CreationDate": "2016-01-21T14:54:51.610", "LastActivityDate": "2016-01-21T16:47:39.900"}, "34926326": {"CommentCount": "8", "ViewCount": "132", "PostTypeId": "1", "LastEditorUserId": "163394", "CreationDate": "2016-01-21T14:23:38.823", "LastActivityDate": "2016-03-10T07:06:55.377", "Title": "Is it legal to re-capture variables with Lambda function?", "AcceptedAnswerId": "34926461", "LastEditDate": "2016-03-10T07:06:55.377", "Id": "34926326", "Score": "1", "Body": "<p>Is it correct to write such code:</p>\n<pre><code>class A\n{\nprivate:\n    int m_int;\n\npublic:\n    void foo()\n    {\n        int a = 1;\n        int b = 2;\n        int c = 3;\n        float f = 3.14f;\n        std::string s(\"Something\");\n\n        const auto f1 = [=] ()\n        {\n            // use only a, b, c\n            int d = a + b + c;\n\n            const auto f2 = [=] \n            {\n                // use f, s and also d\n                std::cout &lt;&lt; f &lt;&lt; s &lt;&lt; d ;\n            }\n        };\n    }\n};\n</code></pre>\n<p>The problem is inner lambda uses some variables that outer one does not require. If this is not valid, then how I should write?</p>\n<p>NOTE: I could also capture pointer variables. So <code>a</code>, <code>b</code>, <code>c</code>, <code>f</code>, and <code>s</code> could be pointers too.</p>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "163394", "AnswerCount": "4"}, "34926463": {"ParentId": "34926326", "CommentCount": "7", "Body": "<p>Quoting from <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/lambda</a></p>\n<blockquote>\n<p id=\"so_34926326_34926463_0\">[=] captures all automatic variables odr-used in the body of the\n  lambda by value</p>\n</blockquote>\n<p>Because you capture <em>all the variables</em> of <code>foo</code> in <code>f1</code> , there is not problem using them in <code>f2</code>.</p>\n<p>so it is valid, although you might want to consider catching them by refernece.</p>\n", "OwnerUserId": "3613500", "PostTypeId": "2", "Id": "34926463", "Score": "0", "CreationDate": "2016-01-21T14:30:15.210", "LastActivityDate": "2016-01-21T14:30:15.210"}, "bq_ids": {"n4140": {"so_34926326_34926996_1": {"section_id": 5972, "quality": 1.0, "length": 12}, "so_34926326_34926996_0": {"section_id": 5968, "quality": 0.8095238095238095, "length": 34}}, "n3337": {"so_34926326_34926996_1": {"section_id": 5740, "quality": 1.0, "length": 12}, "so_34926326_34926996_0": {"section_id": 5737, "quality": 0.7619047619047619, "length": 32}}, "n4659": {"so_34926326_34926996_1": {"section_id": 7471, "quality": 1.0, "length": 12}, "so_34926326_34926996_0": {"section_id": 7466, "quality": 0.8095238095238095, "length": 34}}}});