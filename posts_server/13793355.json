post_cb({"13793447": {"ParentId": "13793355", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The relevant section is 2.2 [lex.phases] paragraph 1, items 8 and 9:</p>\n<blockquote>\n<p id=\"so_13793355_13793447_0\">.8. Translated translation units and instantiation units are combined as follows: [ Note: Some or all of these may be supplied from a library. \u2014end note ] Each translated translation unit is examined to produce a list of required instantiations. [ Note: This may include instantiations which have been explicitly requested (14.7.2). \u2014end note ] The definitions of the required templates are located. It is implementation-defined whether the source of the translation units containing these definitions is required to be available. [ Note: An implementation could encode sufficient information into the translated translation unit so as to ensure the source is not required here. \u2014end note ] All the required instantiations are performed to produce instantiation units. [ Note: These are similar to translated translation units, but contain no references to uninstantiated templates and no template definitions. \u2014end note ] The program is ill-formed if any instantiation fails.</p>\n<p id=\"so_13793355_13793447_1\">.9. All external entity references are resolved. Library components are linked to satisfy external references to entities not defined in the current translation. All such translator output is collected into a program image which contains information needed for execution in its execution environment.</p>\n</blockquote>\n<p>Item 8 is the best I could find indicating that all translation units are required to be included. Item 9 just states that everything necessary to resolve symbols is also pulled in. Effectively this means that explicitly including translation units has the desired effect. Putting the translation units into libraries, however, does not. I guess that this is what you experienced in past: putting, e.g., implementations into a library and hoping they'd register during start-up. Since no symbol in the corresponding translation unit resolves an unreferenced symbol, the object file from the library isn't pulled in and correspondingly the global objects don't get initialized.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "777186", "LastEditDate": "2012-12-10T01:02:35.663", "Id": "13793447", "Score": "2", "CreationDate": "2012-12-10T00:31:08.287", "LastActivityDate": "2012-12-10T01:02:35.663"}, "bq_ids": {"n4140": {"so_13793355_13793447_0": {"section_id": 5313, "quality": 0.7934782608695652, "length": 73}, "so_13793355_13793447_1": {"section_id": 5313, "quality": 1.0, "length": 29}, "so_13793355_13793460_0": {"section_id": 7153, "quality": 0.9714285714285714, "length": 34}}, "n3337": {"so_13793355_13793447_0": {"section_id": 5110, "quality": 0.7934782608695652, "length": 73}, "so_13793355_13793447_1": {"section_id": 5110, "quality": 1.0, "length": 29}, "so_13793355_13793460_0": {"section_id": 6897, "quality": 0.9714285714285714, "length": 34}}, "n4659": {"so_13793355_13793447_0": {"section_id": 6737, "quality": 0.7934782608695652, "length": 73}, "so_13793355_13793447_1": {"section_id": 6737, "quality": 1.0, "length": 29}, "so_13793355_13793460_0": {"section_id": 8657, "quality": 0.6571428571428571, "length": 23}}}, "13793355": {"CommentCount": "4", "AcceptedAnswerId": "13793460", "PostTypeId": "1", "LastEditorUserId": "1131467", "CreationDate": "2012-12-10T00:16:27.480", "LastActivityDate": "2012-12-10T01:02:35.663", "LastEditDate": "2012-12-10T00:25:29.077", "ViewCount": "243", "FavoriteCount": "0", "Title": "C++11 Calling Register Function on Link?", "Id": "13793355", "Score": "9", "Body": "<p>Is there any way to make a function get called just by linking its .o file?</p>\n<p>For example:</p>\n<p>foo.cpp:</p>\n<pre><code>extern int x;\n\nvoid f() { x = 42; }\n\nstruct T { T() { f(); } } t; // we use constructor of global\n                             // object to call f during initialization\n</code></pre>\n<p>bar.cpp:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint x;\n\nint main()\n{\n    std::cout &lt;&lt; x;\n}\n</code></pre>\n<p>To compile/link/run:</p>\n<pre><code>$ g++ -c foo.cpp\n$ g++ -c bar.cpp\n$ g++ foo.o bar.o\n$ ./a.out\n42\n</code></pre>\n<p>This seems to work with gcc 4.7.  It outputs 42 as expected.  However I remember on some old compilers I had a problem with this pattern that because nothing was really \"using\" foo.o it was optimized out at link time.  (perhaps this particular example is not representative of the problem for some reason)</p>\n<p>What does the C++11 standard have to say about this pattern?  Is it guaranteed to work?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1131467", "AnswerCount": "3"}, "13793475": {"ParentId": "13793355", "CommentCount": "0", "Body": "<p>The standard doesn't really say how translation units are selected to combine into a whole program, and, as far as I know, nothing important about this changed between C++98 and C++11.</p>\n<p>In practice, when you link a TU as a <code>.o</code>, you'll get its static initializers no matter what, while if you link it as a piece of a <code>.a</code>, you'll only get its static initializers if something else in the TU was referenced transitively from <code>main()</code> or another file linked as a <code>.o</code>. <code>ld</code>'s <code>--whole-archive</code> flag overrides this and pulls in each member of the archive as if you listed it as an individual <code>.o</code>. Other linkers may handle this differently.</p>\n", "OwnerUserId": "943619", "PostTypeId": "2", "Id": "13793475", "Score": "3", "CreationDate": "2012-12-10T00:36:03.967", "LastActivityDate": "2012-12-10T00:36:03.967"}, "13793460": {"ParentId": "13793355", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I believe you're not off the hook. The standard doesn't <em>guarantee</em> that your code works as intended, although many people rely on that behaviour for various \"self-registering\" constructions.</p>\n<p>Your object <code>t</code> is dynamically initialized, which has the side effect of calling <code>f</code>. The standard has this to say about dynamic initialization of statically-stored objects (3.6.2/4, \"Initialization of non-local variables\"):</p>\n<blockquote>\n<p id=\"so_13793355_13793460_0\">It is implementation-defined whether the dynamic initialization of a non-local variable with static storage\n  duration is done before the first statement of main. If the initialization is deferred to some point in time\n  after the first statement of main, it shall occur before the first odr-use (3.2) of any function or variable\n  defined in the same translation unit as the variable to be initialized.</p>\n</blockquote>\n<p>In your code, only <code>x</code> is odr-used, but <code>x</code> is defined in the main translation unit. No variable or function from the other TU is odr-used in your program, so technically there is no guarantee that <code>t</code> will ever be initialized. Technically, <em>something</em> from every TU must be referred to by the static control flow of your program in order for everything to be initialized.</p>\n<p>As I said, there's lots of real-world code out there with \"self-registering\" translation units (which for example register a factory function pointer in a string-keyed map), so that by simply adding TUs to the final program you end up with more functionality. I'm told that most compilers will unconditionally initialize all global variables just because not doing so would break a lot of real-world code. But don't rely on it!</p>\n", "OwnerUserId": "596781", "LastEditorUserId": "777186", "LastEditDate": "2012-12-10T00:52:47.447", "Id": "13793460", "Score": "8", "CreationDate": "2012-12-10T00:34:14.890", "LastActivityDate": "2012-12-10T00:52:47.447"}});