post_cb({"17622767": {"ParentId": "17582667", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-07-12T19:37:55.037", "Score": "13", "LastEditorUserId": "34509", "LastEditDate": "2013-07-12T22:56:15.223", "Id": "17622767", "OwnerUserId": "34509", "Body": "<p>There are two important reasons for templates not to do any deduction (the two that I remember in a discussion with the guy in charge)</p>\n<ul>\n<li><p>Concerns about future language extensions (there are multiple meanings you could invent - what about if we wanted to introduce perfect forwarding for braced init list function arguments?)</p></li>\n<li><p>The braces can sometimes validly initialize a function parameter that is dependent</p></li>\n</ul>\n<blockquote id=\"so_17582667_17622767_0\">\n<pre><code>template&lt;typename T&gt;\nvoid assign(T &amp;d, const T&amp; s);\n</code></pre>\n</blockquote>\n<pre><code>int main() {\n  vector&lt;int&gt; v;\n  assign(v, { 1, 2, 3 });\n}\n</code></pre>\n<p>If <code>T</code> would be deduced at the right side to <code>initializer_list&lt;int&gt;</code> but at the left side to <code>vector&lt;int&gt;</code>, this would fail to work because of a contradictional argument deduction.</p>\n<p>The deduction for <code>auto</code> to <code>initializer_list&lt;T&gt;</code> is controversial. There exist a proposal for C++-after-14 to remove it (and to ban initialization with <code>{ }</code> or <code>{a, b}</code>, and to make <code>{a}</code> deduce to the type of <code>a</code>).</p>\n", "LastActivityDate": "2013-07-12T22:56:15.223"}, "17582667": {"CommentCount": "3", "ViewCount": "633", "CreationDate": "2013-07-10T23:29:36.640", "LastActivityDate": "2013-07-12T22:56:15.223", "Title": "Why do auto and template type deduction differ for braced initializers?", "FavoriteCount": "3", "PostTypeId": "1", "Id": "17582667", "Score": "14", "Body": "<p>I understand that, given a braced initializer, <code>auto</code> will deduce a type of <code>std::initializer_list</code>, while template type deduction will fail:</p>\n<pre><code>auto var = { 1, 2, 3 };   // type deduced as std::initializer_list&lt;int&gt;\n\ntemplate&lt;class T&gt; void f(T parameter);\n\nf({ 1, 2, 3 });          // doesn't compile; type deduction fails\n</code></pre>\n<p>I even know where this is specified in the C++11 standard: 14.8.2.5/5 bullet 5:</p>\n<blockquote>\n<p id=\"so_17582667_17582667_0\">[It's a non-deduced context if the program has] A function parameter for which the associated argument is an initializer list (8.5.4) but the parameter\n  does not have std::initializer_list or reference to possibly cv-qualified std::initializer_list\n  type. [ <em>Example:</em></p>\n<p id=\"so_17582667_17582667_1\">template void g(T);</p>\n<p id=\"so_17582667_17582667_2\">g({1,2,3}); // error: no argument deduced for T</p>\n<p id=\"so_17582667_17582667_3\">\u2014<em>end example</em> ]</p>\n</blockquote>\n<p>What I don't know or understand is <em>why</em> this difference in type deduction behavior exists. The specification in the C++14 CD is the same as in C++11, so presumably the standardization committee doesn't view the C++11 behavior as a defect. </p>\n<p>Does anybody know why <code>auto</code> deduces a type for a braced initializer, but templates are not permitted to? While speculative explanations of the form \"this could be the reason\" are interesting, I'm especially interested in explanations from people who <em>know</em> why the standard was written the way it was.</p>\n", "Tags": "<c++><c++11><templates-deduction><brace-initialization>", "OwnerUserId": "1426649", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17582667_17582667_0": {"section_id": 336, "quality": 0.8095238095238095, "length": 17}}, "n3337": {"so_17582667_17582667_0": {"section_id": 326, "quality": 0.8095238095238095, "length": 17}}, "n4659": {"so_17582667_17582667_0": {"section_id": 345, "quality": 0.5714285714285714, "length": 12}}}, "17603257": {"ParentId": "17582667", "CommentCount": "3", "CreationDate": "2013-07-11T20:50:25.923", "OwnerUserId": "768110", "PostTypeId": "2", "Id": "17603257", "Score": "0", "Body": "<p>First of all it's \"speculative explanations of the form \"this could be the reason\"\" as you call it.</p>\n<p><code>{1,2,3}</code> is not only <code>std::initializer_list&lt;int&gt;</code> but also allow initialize types without constructor. For example:</p>\n<pre><code>#include &lt;initializer_list&gt;\n\nstruct x{\n    int a,b,c;\n};\n\nvoid f(x){\n\n}\nint main() {\n    f({1,2,3});\n}\n</code></pre>\n<p>is correct code. To show that it isn't <code>initializer_list</code> let's see the following code:</p>\n<pre><code>#include &lt;initializer_list&gt;\n\nstruct x{int a,b,c;};\n\nvoid f(x){\n\n}\nint main() {\n    auto il = {1, 2, 3};\n    f(il);\n}\n</code></pre>\n<p>Error is: </p>\n<pre><code>prog.cpp: In function \u2018int main()\u2019:\nprog.cpp:10:9: error: could not convert \u2018il\u2019 from \u2018std::initializer_list&lt;int&gt;\u2019 to \u2018x\u2019\n</code></pre>\n<p>And now to the question \"What is the difference?\"</p>\n<p>in <code>auto x = {1, 2, 3};</code> code it's OK to determine type, because coder explicitly said \"It's not important what's type it is\" using <code>auto</code></p>\n<p>While in case of function template he may be sure that he is using different type. And it's good to prevent errors in ambiguous cases (It doesn't seem like C++ style , through).</p>\n<p>Especially bad it will be in case when there was 1 function <code>f(x)</code> and then it was changed to template one. Programmer wrote to use it as <code>x</code>, and after adding new function for other type it slightly change to call completely different one.</p>\n", "LastActivityDate": "2013-07-11T20:50:25.923"}});