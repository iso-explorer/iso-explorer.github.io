post_cb({"31412007": {"CommentCount": "11", "ViewCount": "156", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2015-07-14T16:15:16.363", "LastActivityDate": "2015-07-14T16:47:59.460", "Title": "Does this C++ program invoke undefined behavior?", "AcceptedAnswerId": "31412110", "LastEditDate": "2015-07-14T16:36:53.283", "Id": "31412007", "Score": "-6", "Body": "<p>I was reading about <a href=\"https://msdn.microsoft.com/en-us/library/c36yw7x9.aspx\" rel=\"nofollow\">static_cast</a> operator. </p>\n<p>Consider following example:</p>\n<pre><code>#include &lt;iostream&gt;\nclass B { };\nclass D : public B \n{\n    public:\n        void fun()\n        {\n            std::cout&lt;&lt;\"fun() is called\\n\";\n        }\n};\nvoid f(B* pb,D* pd)\n{\n    D* pd2=static_cast&lt;D*&gt;(pb);\n    B* pb2=static_cast&lt;B*&gt;(pd);\n    pd2-&gt;fun();\n}\nint main()\n{\n    B b;\n    D d;\n    f(&amp;b,&amp;d);\n}\n</code></pre>\n<p>It says that:</p>\n<blockquote>\n<p id=\"so_31412007_31412007_0\">In the example that follows, the line D* pd2 = static_cast(pb); is\n  not safe because D can have fields and methods that are not in B.\n  However, the line B* pb2 = static_cast(pd); is a safe conversion\n  because D always contains all of B. </p>\n<p id=\"so_31412007_31412007_1\">In contrast to dynamic_cast, no run-time check is made on the\n  static_cast conversion of pb. The object pointed to by pb may not be\n  an object of type D, in which case the use of *pd2 could be\n  disastrous. For instance, calling a function that is a member of the D\n  class, but not the B class, could result in an access violation.</p>\n</blockquote>\n<p>I tried it on gcc 4.8.1 &amp; MSVS 2010 &amp; get output <strong>fun() is called</strong>. So does this program invoke undefined behavior? Can my program crash at runtime? What does the C++ standard says about this? Please correct me If I understood something incorrectly. </p>\n", "Tags": "<c++><inheritance><language-lawyer><undefined-behavior><static-cast>", "OwnerUserId": "3777958", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31412007_31412110_0": {"section_id": 6037, "quality": 0.8591549295774648, "length": 61}}, "n3337": {"so_31412007_31412110_0": {"section_id": 5805, "quality": 0.8450704225352113, "length": 60}}, "n4659": {"so_31412007_31412110_0": {"section_id": 7536, "quality": 0.7605633802816901, "length": 54}}}, "31412110": {"ParentId": "31412007", "CommentCount": "2", "Body": "<p>Yes, of course it is.</p>\n<p>You are invoking a member function of <code>D</code> on an object that's only a <code>B</code>, by forcing a conversion from <code>B*</code> to <code>D*</code>.</p>\n<p>It \"appears to work\" because the function involved does not attempt to access any actual data and, therefore, there is no memory access for your computer to notice and complain about at runtime.</p>\n<hr>\n<p>In fact, we don't even need to bother talking about whether the function call has undefined behaviour; the cast itself is bad enough:</p>\n<blockquote>\n<p id=\"so_31412007_31412110_0\"><code>[C++14: 5.4.9/11]:</code> <strong>A prvalue of type \u201cpointer to <em>cv1</em> <code>B</code>,\u201d where <code>B</code> is a class type, can be converted to a prvalue of type \u201cpointer to <em>cv2</em> <code>D</code>,\u201d where <code>D</code> is a class derived (Clause 10) from <code>B</code>, if a valid standard conversion from \u201cpointer to <code>D</code>\u201d to \u201cpointer to <code>B</code>\u201d exists (4.10)</strong>, <em>cv2</em> is the same <em>cv-qualification</em> as, or greater <em>cv-qualification</em> than, <em>cv1</em>, and <code>B</code> is neither a virtual base class of <code>D</code> nor a base class of a virtual base class of <code>D</code>. The null pointer value (4.10) is converted to the null pointer value of the destination type. <strong>If the prvalue of type \u201cpointer to <em>cv1</em> <code>B</code>\u201d points to a <code>B</code> that is actually a subobject of an object of type <code>D</code>, the resulting pointer points to the enclosing object of type <code>D</code>. Otherwise, the behavior is undefined.</strong></p>\n</blockquote>\n</hr>", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "31412110", "Score": "11", "CreationDate": "2015-07-14T16:20:15.117", "LastActivityDate": "2015-07-14T16:20:15.117"}, "31412175": {"ParentId": "31412007", "CommentCount": "0", "Body": "<p>When you use <code>static_cast</code> to upcast <code>B*</code> to <code>D*</code> the compiler trusts you to have checked that this is a correct things to do and the pointer indeed points to a <code>D</code>. There is no way for the compiler or runtime to check it on your behalf (without RTTI). So when you call <code>foo</code> it happily puts in the code to call it and because it is not a virtuall method then correct <code>D::foo</code> is called. If you access any <code>D</code> specific members in <code>foo</code> the application will crash, burn etc. That's the reality.</p>\n<p>The theory is that of course you're invoking an undefined behaviour.</p>\n", "OwnerUserId": "4999494", "PostTypeId": "2", "Id": "31412175", "Score": "0", "CreationDate": "2015-07-14T16:23:07.430", "LastActivityDate": "2015-07-14T16:23:07.430"}});