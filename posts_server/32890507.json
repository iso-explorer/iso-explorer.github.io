post_cb({"32890507": {"CommentCount": "0", "ViewCount": "325", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2015-10-01T14:46:43.470", "LastActivityDate": "2015-10-02T22:11:03.333", "Title": "Override default unhandled exception behaviour", "LastEditDate": "2015-10-02T22:11:03.333", "Id": "32890507", "Score": "3", "Body": "<p>I have this code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;exception&gt;\n\nclass TestException : public std::exception\n{\npublic:\n    char const* what() const throw() override { return msg_.c_str(); }\n\nprotected:\n    std::string &amp; message() throw() { return msg_; }\n\nprivate:\n    std::string msg_;\n};\n\nvoid ThrowIt()\n{\n    throw TestException();\n}\n\nint main()\n{\n    ThrowIt();\n}\n</code></pre>\n<p>Running this when built in either Release or Debug on Windows compiled with Visual Studio results in program termination, same goes for when compiled with GCC on a Linux machine, the result is :</p>\n<blockquote>\n<p id=\"so_32890507_32890507_0\">terminate called after throwing an instance of 'TestException'<br>\n  what(): Aborted</br></p>\n</blockquote>\n<p>Both terminate the program once an unhandled exception is caught. Is this behaviour strictly system specific or is this specified by the standard? Is there a cross-platform way that I can reroute every exception not handled by <code>catch</code> to a handler instead of just terminating the program?</p>\n", "Tags": "<c++><c++11><exception-handling><g++><visual-studio-2015>", "OwnerUserId": "1870760", "AnswerCount": "2"}, "32890888": {"ParentId": "32890507", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-10-01T15:04:43.350", "Score": "0", "LastEditorUserId": "1312406", "LastEditDate": "2015-10-01T15:15:13.677", "Id": "32890888", "OwnerUserId": "1312406", "Body": "<p><strong>15.5.1</strong> of the C++11 standard states:</p>\n<blockquote>\n<p id=\"so_32890507_32890888_0\">[...] when the exception handling mechanism cannot find a handler for a thrown exception [...] <code>std::terminate()</code> is called. In the situation where no matching handler is found,\n  it is implementation-defined whether or not the stack is unwound before <code>std::terminate()</code> is called.</p>\n</blockquote>\n<p>So the termination is standard behavior, but whether or not you could recover from this situation is implementation-defined.  In any case there's no rerouting of the exception object.</p>\n<p>You can also change the handler function (<code>typedef void (*terminate_handler)();</code>) called by <code>std::terminate()</code> with <code>terminate_handler set_terminate(terminate_handler f) noexcept;</code>and view it with <code>terminate_handler get_terminate() noexcept;</code>.</p>\n", "LastActivityDate": "2015-10-01T15:15:13.677"}, "bq_ids": {"n4140": {"so_32890507_32890966_1": {"section_id": 3383, "quality": 0.8823529411764706, "length": 15}, "so_32890507_32890966_2": {"section_id": 3351, "quality": 1.0, "length": 16}, "so_32890507_32890966_0": {"section_id": 3382, "quality": 0.875, "length": 21}, "so_32890507_32890888_0": {"section_id": 3383, "quality": 0.5652173913043478, "length": 13}}, "n3337": {"so_32890507_32890966_1": {"section_id": 3252, "quality": 0.8823529411764706, "length": 15}, "so_32890507_32890966_2": {"section_id": 3221, "quality": 1.0, "length": 16}, "so_32890507_32890966_0": {"section_id": 3251, "quality": 0.875, "length": 21}, "so_32890507_32890888_0": {"section_id": 3252, "quality": 0.5652173913043478, "length": 13}}, "n4659": {"so_32890507_32890966_1": {"section_id": 4143, "quality": 0.8823529411764706, "length": 15}, "so_32890507_32890966_2": {"section_id": 4118, "quality": 1.0, "length": 16}, "so_32890507_32890966_0": {"section_id": 4142, "quality": 0.875, "length": 21}, "so_32890507_32890888_0": {"section_id": 4143, "quality": 0.5652173913043478, "length": 13}}}, "32890966": {"ParentId": "32890507", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-10-01T15:08:19.780", "Score": "0", "LastEditorUserId": "4342498", "LastEditDate": "2015-10-01T15:14:42.827", "Id": "32890966", "OwnerUserId": "4342498", "Body": "<p>In your code you have an uncaught exception as there are no matching handle for your exception.  the behavior of this is covered in [except.terminate]</p>\n<blockquote>\n<p id=\"so_32890507_32890966_0\">In some situations exception handling must be abandoned for less subtle error handling techniques. [ Note: These situations are:<br>\n  [...]<br>\n  - when the exception handling mechanism cannot find a handler for a thrown exception (15.3), or\n  [...]<br/></br></br></p>\n</blockquote>\n<p>And then we have</p>\n<blockquote>\n<p id=\"so_32890507_32890966_1\">In such cases, std::terminate() is called (18.8.3). In the situation where no matching handler is found,\n  it is implementation-defined whether or not the stack is unwound before std::terminate() is called.</p>\n</blockquote>\n<p>If you want to have \"Top level\" <code>catch</code> that will handle all exceptions in your program if the are not caught you could wrap the code in <code>main()</code> in a <code>try...catch</code> block.  Any exception not caught will move up per [except.handle]</p>\n<blockquote>\n<p id=\"so_32890507_32890966_2\">If no match is found among the handlers for a try block, the search for a matching handler continues in a\n  dynamically surrounding try block of the same thread.</p>\n</blockquote>\n<p>You could also change the <code>std::terminate_handler</code> using <a href=\"http://en.cppreference.com/w/cpp/error/set_terminate\" rel=\"nofollow\"><code>std::set_terminate</code></a></p>\n", "LastActivityDate": "2015-10-01T15:14:42.827"}});