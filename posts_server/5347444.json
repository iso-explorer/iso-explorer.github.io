post_cb({"5347444": {"ViewCount": "1549", "Body": "<p>Consider the following program:</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;cstdio&gt;\n\nvoid f(char const*&amp;&amp;)      { std::puts(\"char const*&amp;&amp;\");      } // (1)\nvoid f(char const* const&amp;) { std::puts(\"char const* const&amp;\"); } // (2)\n\ntemplate &lt;std::size_t N&gt;\nvoid f(char const (&amp;)[N])  { std::puts(\"char const(&amp;)[N]\");   } // (3)\n\nint main()\n{\n    const char data[] = \"a\";\n    f(data);\n}\n</code></pre>\n<p><strong>Which <code>f</code> should be called?  Why?</strong></p>\n<p>The latest released versions of three compilers disagree on the answer to this question:</p>\n<ul>\n<li><strong>(1)</strong> is called when the program is compiled using <strong>g++ 4.5.2</strong></li>\n<li><strong>(2)</strong> is called when the program is compiled using <strong>Visual C++ 2010 SP1</strong></li>\n<li><strong>(3)</strong> is called when the program is compiled using <strong>Clang 3.0 (trunk 127530)</strong></li>\n</ul>\n<p>Have the overload resolution rules changed substantially in different C++0x drafts?  Or, are two of these compilers really just completely wrong?  Which overload is the correct overload to be selected per the latest C++0x draft?</p>\n", "AcceptedAnswerId": "5352236", "Title": "Overload resolution and arrays: which function should be called?", "CreationDate": "2011-03-18T02:33:18.137", "Id": "5347444", "CommentCount": "16", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2011-10-02T10:26:27.930", "LastEditorUserId": "34509", "LastActivityDate": "2011-10-02T10:26:27.930", "Score": "29", "OwnerUserId": "151292", "Tags": "<c++><arrays><reference><c++11><overload-resolution>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_5347444_5352236_0": {"length": 19, "quality": 0.95, "section_id": 639}}, "n3337": {"so_5347444_5352236_0": {"length": 19, "quality": 0.95, "section_id": 629}}, "n4659": {"so_5347444_5352236_0": {"length": 19, "quality": 0.95, "section_id": 667}}}, "5352236": {"Id": "5352236", "PostTypeId": "2", "Body": "<p>First, the conversion sequence of all three is the same, except that for the first two, there is an lvalue transformation (lvalue to rvalue conversion), which however is not used in ordering conversion sequences. All three are exact matches (the function template specialization has parameter type <code>char const(&amp;)[2]</code>). </p>\n<p>If you iterate over the rules at <code>13.3.3.2p3</code>, you stop at this paragraph</p>\n<blockquote>\n<p id=\"so_5347444_5352236_0\">S1 and S2 are reference bindings (8.5.3) and neither refers to an implicit object parameter of a non-static member function declared without a ref-qualifier, and S1 binds an rvalue reference to an rvalue and S2 binds an lvalue reference.</p>\n</blockquote>\n<p>A conversion sequence cannot be formed if it requires binding an rvalue reference to an lvalue, the spec says at 13.3.3.1.4p3. If you look at how reference binding works at 8.5.3p5 last bullet, it will create a temporary (I think they meant <em>rvalue</em> temporary) of type <code>char const*</code> from the array lvalue and bind the reference to that temporary. Therefor, I think <code>(1)</code> is better than <code>(2)</code>. Same holds for <code>(1)</code> against <code>(3)</code>, although we wouldn't need this because <code>(3)</code> is a template so in a tie, we would choose <code>(1)</code> again. </p>\n<p>In <code>n3225</code>, they changed the reference binding rules so that rvalue references can bind to initializer expressions that are lvalues, as long as the reference will be bound to an rvalue (possibly created by converting the initializer properly before). This could influence the handling by Visual C++, which may not be up to date here. </p>\n<p>I'm not sure about clang. Even if it would ignore <code>(1)</code>, then it would end up in a tie between <code>(2)</code> and <code>(3)</code>, and would need to choose <code>(2)</code> because it's a non-template.</p>\n<hr>\n<p>I think that 8.5.3p5 last bullet is confusing because it says \"Otherwise a temporary of type ..\". It's not clear whether the temporary is regarded as an lvalue or as an rvalue by 13.3.3.1.4p3, which means I'm not sure how the following should really behave according to the exact words of the spec</p>\n<pre><code>void f(int &amp;);\nvoid f(int &amp;&amp;);\n\nint main() {\n  int n = 0;\n  f(n);\n}\n</code></pre>\n<p>If we assume the temporary is treated as an rvalue by clause 13, then we bind an rvalue ref to an rvalue in the second function and an lvalue in the first. Therefor, we will choose the second function and then get a diagnostic by 8.5.3p5 last bullet because <code>T1</code> and <code>T2</code> are reference-related. If we assume the temporary is treated as an lvalue by clause 13, then the following would not work</p>\n<pre><code>void f(int &amp;&amp;);\nint main() {\n  f(0);\n}\n</code></pre>\n<p>Because we would bind an rvalue ref to an lvalue which by clause 13 will make the function non-viable. And if we interpret \"binding an rvalue ref to an lvalue\" to refer to the initializer expression instead of the final expression bound to, we won't accept the following</p>\n<pre><code>void f(float &amp;&amp;);\nint main() {\n  int n = 0;\n  f(n);\n}\n</code></pre>\n<p>This however is valid as of n3225. So there seems to be some confusion - I sent a DR to the committee about this. </p>\n</hr>", "LastEditorUserId": "34509", "LastActivityDate": "2011-03-18T13:09:29.923", "Score": "12", "CreationDate": "2011-03-18T12:53:19.130", "ParentId": "5347444", "CommentCount": "2", "OwnerUserId": "34509", "LastEditDate": "2011-03-18T13:09:29.923"}, "5347680": {"Id": "5347680", "PostTypeId": "2", "Body": "<p>I claim that #3 is the function chosen by a conforming compiler.</p>\n<p>(1) is better than (2) because \"Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if S1 and S2 are reference bindings (8.5.3) and neither refers to an implicit object parameter of a non-static member function declared without a ref-quali\ufb01er, and S1 binds an rvalue reference to an rvalue and S2 binds an lvalue reference.\"</p>\n<p>(3) is better than both (1) and (2) because it is an identity conversion (the others are exact match conversions) and \"Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if S1 is a proper subsequence of S2 (comparing the conversion sequences in the canonical form defined by 13.3.3.1.1, excluding any Lvalue Transformation; the identity conversion sequence is considered to be a subsequence of any non-identity conversion sequence)\"</p>\n<p>Template vs non-template is only considered when neither conversion is better \"or, if not that...\"</p>\n<p>oddly enough though, Comeau prefers (2) over (3).  This test case fails to compile:</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;cstdio&gt;\n\n// (1) removed because Comeau doesn't support rvalue-references yet\nchar f(char const* const&amp;) { std::puts(\"char const* const&amp;\"); return 0; } // (2)\n\ntemplate &lt;std::size_t N&gt;\nint f(char const (&amp;)[N])  { std::puts(\"char const(&amp;)[N]\"); return 0; } // (3)\n\nint main()\n{\n    const char data[] = \"a\";\n    switch (0) {\n       case sizeof(char):\n           break;\n       case sizeof(f(data)):\n           break;\n    }\n}\n</code></pre>\n", "LastEditorUserId": "103167", "LastActivityDate": "2011-03-18T03:32:58.317", "Score": "4", "CreationDate": "2011-03-18T03:16:17.613", "ParentId": "5347444", "CommentCount": "1", "OwnerUserId": "103167", "LastEditDate": "2011-03-18T03:32:58.317"}, "5347544": {"Body": "<p>This is a community wiki answer for collecting snippets from the standard (draft 3225).</p>\n<p><strong>section 13.3.3 \"Best viable function\" <code>[over.match.best]</code></strong></p>\n<ol>\n<li><p>De\ufb01ne ICSi(F) as follows:</p>\n<ul>\n<li><p>if <code>F</code> is a static member function, ICS1(F) is de\ufb01ned such that ICS1(F) is neither better nor worse than\nICS1(G) for any function <code>G</code>, and, symmetrically, ICS1(G) is neither better nor worse than ICS1(F); otherwise,</p></li>\n<li><p>let ICSi(F) denote the implicit conversion sequence that converts the i-th argument in the list to the\ntype of the i-th parameter of viable function <code>F</code>. 13.3.3.1 de\ufb01nes the implicit conversion sequences and\n13.3.3.2 de\ufb01nes what it means for one implicit conversion sequence to be a better conversion sequence or worse conversion sequence than another.</p></li>\n</ul>\n<p>Given these de\ufb01nitions, a viable function <code>F1</code> is de\ufb01ned to be a better function than another viable function <code>F2</code> if for all arguments <em>i</em>, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<ul>\n<li>for some argument <em>j</em>, ICSj(F1) is a better conversion sequence than ICSj(F2)</li>\n</ul>\n<p>or, if not that,</p>\n<ul>\n<li>the context is an initialization by user-defined conversion (see 8.5,  13.3.1.5,  and 13.3.1.6) and the standard conversion sequence from the return type of <code>F1</code> to the destination type (i.e., the type of the entity being initialized) is a better conversion sequence than the standard conversion sequence from the return type of <code>F2</code> to the destination type</li>\n</ul>\n<p>or, if not that,</p>\n<ul>\n<li><code>F1</code> is a non-template function and <code>F2</code> is a function template specialization</li>\n</ul>\n<p>or, if not that,</p>\n<ul>\n<li><code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized\nthan the template for <code>F2</code> according to the partial ordering rules described in 14.5.6.2.</li>\n</ul></li>\n<li><p>If there is exactly one viable function that is a better function than all other viable functions, then it is the one selected by overload resolution; otherwise the call is ill-formed.</p></li>\n</ol>\n<p><strong>section 13.3.3.1.4 \"Reference binding\" <code>[over.ics.ref]</code></strong></p>\n<ol>\n<li><p>When a parameter of reference type binds directly (8.5.3) to an argument expression, the implicit conversion\nsequence is the identity conversion, unless the argument expression has a type that is a derived class of the\nparameter type, in which case the implicit conversion sequence is a derived-to-base conversion  (13.3.3.1).  If the parameter binds directly to the result of applying a conversion function to the\nargument expression, the implicit conversion sequence is a user-de\ufb01ned conversion sequence (13.3.3.1.2), with the second standard conversion sequence either an identity conversion or, if the conversion function\nreturns an entity of a type that is a derived class of the parameter type, a derived-to-base Conversion.</p></li>\n<li><p>When a parameter of reference type is not bound directly to an argument expression, the conversion sequence\nis the one required to convert the argument expression to the underlying type of the reference according\nto 13.3.3.1.   Conceptually,  this conversion sequence corresponds to copy-initializing a temporary of the\nunderlying type with the argument expression.  Any di\ufb00erence in top-level cv-quali\ufb01cation is subsumed by\nthe initialization itself and does not constitute a conversion.</p></li>\n</ol>\n<p><strong>section 13.3.3.2 \"Ranking implicit conversion sequences\" <code>[over.ics.rank]</code></strong></p>\n<ol>\n<li><p>13.3.3.2 de\ufb01nes a partial ordering of implicit conversion sequences based on the relationships better conversion\nsequence and better conversion. If an implicit conversion sequence <code>S1</code> is de\ufb01ned by these rules to be a better\nconversion sequence than <code>S2</code>, then it is also the case that <code>S2</code> is a worse conversion sequence than <code>S1</code>.  If\nconversion sequence <code>S1</code> is neither better than nor worse than conversion sequence <code>S2</code>, <code>S1</code> and <code>S2</code> are said to\nbe indistinguishable conversion sequences.</p></li>\n<li><p>When comparing the basic forms of implicit conversion sequences (as de\ufb01ned in 13.3.3.1)</p>\n<ul>\n<li><p>a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence, and</p></li>\n<li><p>a user-de\ufb01ned conversion sequence (13.3.3.1.2) is a better conversion sequence than an ellipsis conversion sequence (13.3.3.1.3).</p></li>\n</ul></li>\n<li><p>Two implicit conversion sequences of the same form are indistinguishable conversion sequences unless one of\nthe following rules applies:</p>\n<ul>\n<li><p>Standard conversion sequence <code>S1</code> is a better conversion sequence than standard conversion sequence <code>S2</code> if</p>\n<ul>\n<li>S1 is a proper subsequence of  S2 (comparing the conversion sequences in the canonical form defined by 13.3.3.1.1, excluding any Lvalue Transformation; the identity conversion sequence is considered to be a subsequence of any non-identity conversion sequence)</li>\n</ul>\n<p>or, if not that,</p>\n<ul>\n<li>the rank of <code>S1</code> is better than the rank of <code>S2</code>, or <code>S1</code> and <code>S2</code> have the same rank and are distinguishable by the rules in the paragraph below</li>\n</ul>\n<p>or, if not that,</p>\n<ul>\n<li><code>S1</code> and <code>S2</code> differ only in their qualification conversion and yield similar types <code>T1</code> and <code>T2</code> (4.4), respectively, and the cv-qualification signature of type <code>T1</code> is a proper subset of the cv-qualification signature of type <code>T2</code>.</li>\n</ul>\n<p>or, if not that,</p>\n<ul>\n<li><code>S1</code> and <code>S2</code> are reference bindings (8.5.3) and neither refers to an implicit object parameter of a\nnon-static member function declared without a ref-quali\ufb01er, and <code>S1</code> binds an rvalue reference to\nan rvalue and <code>S2</code> binds an lvalue reference.</li>\n</ul></li>\n</ul></li>\n</ol>\n", "CreationDate": "2011-03-18T02:52:29.133", "ParentId": "5347444", "CommentCount": "0", "LastEditDate": "2011-03-18T03:25:49.510", "Id": "5347544", "PostTypeId": "2", "LastActivityDate": "2011-03-18T03:25:49.510", "LastEditorUserId": "103167", "CommunityOwnedDate": "2011-03-18T02:52:29.133", "Score": "2", "OwnerUserId": "103167"}});