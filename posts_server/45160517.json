post_cb({"bq_ids": {"n4140": {"so_45160517_45160517_3": {"length": 7, "quality": 0.875, "section_id": 7136}, "so_45160517_45160517_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 7135}, "so_45160517_45160517_4": {"length": 7, "quality": 1.0, "section_id": 7136}, "so_45160517_45160517_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 7135}}, "n3337": {"so_45160517_45160517_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6879}, "so_45160517_45160517_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 6879}, "so_45160517_45160517_4": {"length": 7, "quality": 1.0, "section_id": 6880}, "so_45160517_45160517_3": {"length": 7, "quality": 0.875, "section_id": 6880}}, "n4659": {"so_45160517_45160517_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 8636}, "so_45160517_45160517_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 8636}, "so_45160517_45160517_4": {"length": 7, "quality": 1.0, "section_id": 8637}, "so_45160517_45160517_3": {"length": 7, "quality": 0.875, "section_id": 8637}}}, "45160635": {"Id": "45160635", "PostTypeId": "2", "Body": "<p>What you're doing should be fine. The optimizer will probably avoid creating any storage for the constants, and will instead replace any uses of it with the value, as long as you never take the address of the variable (e.g. <code>&amp;myConstant</code>).</p>\n", "LastActivityDate": "2017-07-18T07:52:06.143", "CommentCount": "0", "CreationDate": "2017-07-18T07:52:06.143", "ParentId": "45160517", "Score": "4", "OwnerUserId": "1491895"}, "45160517": {"ViewCount": "286", "Body": "<p>I see a common pattern in many C++ codebases:</p>\n<p>Header.h:</p>\n<pre><code>static const int myConstant = 1;\n</code></pre>\n<p>Source1.cpp:</p>\n<pre><code>#include \"Header.h\"\n</code></pre>\n<p>Source2.cpp:</p>\n<pre><code>#include \"Header.h\"\n</code></pre>\n<p>Based on:</p>\n<blockquote>\n<p id=\"so_45160517_45160517_0\">3.5 Program and linkage</p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_45160517_45160517_1\">(2.1) \u2014 When a name has external linkage , the entity it denotes can be referred to by names from scopes of\n  other translation units or from other scopes of the same translation unit.</p>\n<p id=\"so_45160517_45160517_2\">(2.2) \u2014 When a name has internal linkage , the entity it denotes can be referred to by names from other scopes\n  in the same translation unit.</p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_45160517_45160517_3\">3 A name having namespace scope (3.3.6) has internal linkage if it is the name of</p>\n<p id=\"so_45160517_45160517_4\">(3.1) \u2014 a variable, function or function template that is explicitly declared static; or,</p>\n</blockquote>\n<p><code>myConstant</code> is accessible only from the same translation unit and the compiler will generate multiple instances of it, one for each translation unit that included <code>Header.h</code>. </p>\n<p>Is my understanding correct - multiple instances of <code>myConstant</code> are created? If this is the case can you please point me to better alternatives of using constants in C++</p>\n<p>EDIT:</p>\n<p>Some suggested to make <code>myConstant</code> <code>extern</code> in the header and define it in one <code>cpp</code> file. Is this a good practice? I <strong>guess</strong> this will make the value invisible to the compiler and prevent many optimizations, for example when the value appears in arithmetic operations.</p>\n", "Title": "How to correctly define constants in C++", "CreationDate": "2017-07-18T07:44:15.563", "LastActivityDate": "2017-07-18T09:06:17.160", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-07-18T07:50:59.397", "LastEditorUserId": "336578", "Id": "45160517", "Score": "5", "OwnerUserId": "336578", "Tags": "<c++>", "AnswerCount": "2"}, "45160726": {"Id": "45160726", "PostTypeId": "2", "Body": "<p>A pattern <code>static const int myConstant = 1</code> arising in header files is a little bit strange, because keyword <code>static</code> restricts the scope of a variable definition to the specific translation unit. Hence, this variable can then not be accessed from other translation units. So I don't see why someone might expose a variable in a header file though this variable can never be addressed from \"outside\".</p>\n<p>Note that if different translation units include the header, then each translation unit will define <em>its own</em>, somewhat \"private\" instance of this variable.</p>\n<p>I think that the common pattern should be:</p>\n<p>In the header file:</p>\n<pre><code>extern const int myConstant;\n</code></pre>\n<p>In exactly <em>one</em> implementation file of the whole program:</p>\n<pre><code>const int myConstant = 1;\n</code></pre>\n<p>The comments say, however, that this will prevent the compiler from optimisations, as the value of the constant is not know at the time a translation unit is compiled (and this sounds reasonable).</p>\n<p>So it seems that \"global/shared\" constants are not possible and that one might have to live with the - somewhat contradicting - keyword <code>static</code> in a header file.</p>\n<p>Additionally, I'd use <code>constexr</code> to indicate a compile time constant (though the compiler might derive this anyway):</p>\n<pre><code> static constexpr int x = 1;\n</code></pre>\n<p>Because the <code>static</code>-keyword still disturbs me somehow, I did some research and experiments on <code>constexpr</code> without a <code>static</code> keyword but with an <code>extern</code> keyword. Unfortunately, an <code>extern constexpr</code> still requires an initialisation (which makes it a definition then and leads to duplicate symbol errors). Interestingly , at least with my compiler, I can actually define <code>constexpr int x = 1</code> in different translation units without introducing a compiler/linker error. But I do not find a support for this behaviour in the standard. But defining <code>constexpr int x = 1</code> in a header file is even more curious than <code>static constexpr int x = 1</code>.</p>\n<p>So - many words, few findings. I think <code>static constexpr int x = 1</code> is the best choice.</p>\n", "LastEditorUserId": "2630032", "LastActivityDate": "2017-07-18T09:06:17.160", "Score": "1", "CreationDate": "2017-07-18T07:56:54.350", "ParentId": "45160517", "CommentCount": "9", "OwnerUserId": "2630032", "LastEditDate": "2017-07-18T09:06:17.160"}});