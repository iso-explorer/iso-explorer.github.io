post_cb({"bq_ids": {"n4140": {"so_13955677_13955874_0": {"length": 4, "quality": 0.8, "section_id": 4706}}, "n3337": {"so_13955677_13955874_0": {"length": 4, "quality": 0.8, "section_id": 4515}}, "n4659": {"so_13955677_13955874_0": {"length": 4, "quality": 0.8, "section_id": 6103}}}, "13955677": {"ViewCount": "168", "Body": "<blockquote>\n<p id=\"so_13955677_13955677_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/13952404/what-is-the-difference-between-is-convertible-is-assignable\">What is the difference between is_convertible is_assignable</a> </br></p>\n</blockquote>\n<p>I use this test code:</p>\n<pre><code>cout&lt;&lt;std::is_assignable&lt;int, int&gt;::value&lt;&lt;endl;\ncout&lt;&lt;std::is_assignable&lt;int, char&gt;::value&lt;&lt;endl;\ncout&lt;&lt;std::is_assignable&lt;int&amp;, int&gt;::value&lt;&lt;endl;\ncout&lt;&lt;std::is_assignable&lt;int&amp;, char&gt;::value&lt;&lt;endl;\ncout&lt;&lt;std::is_assignable&lt;int, int&amp;&gt;::value&lt;&lt;endl;\ncout&lt;&lt;std::is_assignable&lt;int, char&amp;&gt;::value&lt;&lt;endl;\n</code></pre>\n<p>The result in vs2012 is:</p>\n<pre><code>true\ntrue\ntrue\ntrue\ntrue\ntrue\n</code></pre>\n<p>In gcc4.7.2 I get:</p>\n<pre><code>false\nfalse\ntrue\ntrue\nfalse\nfalse\n</code></pre>\n<p>Which result is correct according to the standard?</p>\n", "Title": "Inconsistent results of is_assignable<>", "CreationDate": "2012-12-19T15:29:33.037", "LastActivityDate": "2012-12-19T15:40:10.503", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:24:45.547", "Tags": "<c++>", "Id": "13955677", "LastEditorUserId": "-1", "Score": "6", "OwnerUserId": "1870044", "ClosedDate": "2012-12-19T17:15:58.747", "AnswerCount": "2"}, "13955889": {"Id": "13955889", "PostTypeId": "2", "Body": "<p><code>is_assignable&lt;T,U&gt;::value</code> is defined as true when <code>declval&lt;T&gt;() = declval&lt;U&gt;()</code> is well-formed and <code>declval&lt;T&gt;</code> is defined as a function returning <code>add_rvalue_reference&lt;T&gt;::type</code>.</p>\n<p>We must remember that an assignment is only valid for a modifiable lvalue as the left operand. Also remember the rules of reference collapsing (especially the last two):</p>\n<pre><code>T&amp;  &amp;  -&gt; T&amp;\nT&amp;&amp; &amp;  -&gt; T&amp;\nT&amp;  &amp;&amp; -&gt; T&amp;\nT&amp;&amp; &amp;&amp; -&gt; T&amp;&amp;\n</code></pre>\n<p>So each case:</p>\n<ol>\n<li><p><code>is_assignable&lt;int, int&gt;</code> and <code>is_assignable&lt;int, char&gt;</code></p>\n<p>Can we assign the result of a function returning an rvalue reference (an xvalue) to the result of another function returning an rvalue reference (another xvalue). No we can't. This should be <code>false</code>.</p></li>\n<li><p><code>std::is_assignable&lt;int&amp;, int&gt;</code> and <code>std::is_assignable&lt;int&amp;, char&gt;</code></p>\n<p>Can we assign the result of a function returning an rvalue reference (an xvalue) to the result of a function returning an lvalue reference (an lvalue). We sure can. This should be <code>true</code>.</p></li>\n<li><p><code>std::is_assignable&lt;int, int&amp;&gt;</code> and <code>std::is_assignable&lt;int, char&amp;&gt;</code></p>\n<p>Can we assign the result of a function returning an lvalue reference (an lvalue) to the result of a function returning an rvalue reference (an xvalue). No we can't. This should be <code>false</code>.</p></li>\n</ol>\n<p>So I say GCC is right here.</p>\n", "LastActivityDate": "2012-12-19T15:40:10.503", "CommentCount": "0", "CreationDate": "2012-12-19T15:40:10.503", "ParentId": "13955677", "Score": "3", "OwnerUserId": "150634"}, "13955874": {"Id": "13955874", "PostTypeId": "2", "Body": "<p><code>is_assignable&lt;T,U&gt;</code> is true if:</p>\n<blockquote>\n<p id=\"so_13955677_13955874_0\">The expression <code>declval&lt;T&gt;() = declval&lt;U&gt;()</code> is well-formed</p>\n</blockquote>\n<p><code>declval&lt;T&gt;</code> is declared as a function returning a reference to <code>T</code>:</p>\n<pre><code>template &lt;class T&gt;\n  typename add_rvalue_reference&lt;T&gt;::type declval() noexcept;\n</code></pre>\n<p>where <code>add_rvalue_reference&lt;T&gt;::type</code> is an <em>rvalue</em> reference type (<code>T&amp;&amp;</code>) if <code>T</code> is an object or function type, or <code>T</code> itself if it is a reference type.</p>\n<p>This means that <code>is_assignable&lt;T,U&gt;</code> can only be true if <code>T</code> is a non-const <em>lvalue</em> reference type. If it's an object type, then <code>add_rvalue_reference&lt;T&gt;::type</code> is an <em>rvalue</em> reference type; so the expression <code>declval&lt;T&gt;()</code> is an <em>xvalue</em>, which cannot be assigned to.</p>\n<p>So, unless I've misread the standard, GCC is correct and VS2012 is wrong. Even if it might seem to make more sense for <code>is_assignable&lt;int,int&gt;</code> to be true, it is not.</p>\n", "LastActivityDate": "2012-12-19T15:39:31.207", "CommentCount": "2", "CreationDate": "2012-12-19T15:39:31.207", "ParentId": "13955677", "Score": "5", "OwnerUserId": "204847"}});