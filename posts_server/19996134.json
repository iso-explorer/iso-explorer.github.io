post_cb({"19996354": {"ParentId": "19996134", "CommentCount": "0", "Body": "<p>I guess, that the following parts of the C++ standard apply:</p>\n<blockquote id=\"so_19996134_19996354_0\">\n<b>5.1.2.14:</b> <br/>\nAn entity is captured by copy if it is implicitly captured and the capture-default is = or if it is explicitly\ncaptured with a capture that does not include an &amp;. <b>For each entity captured by copy, an unnamed nonstatic\ndata member is declared in the closure type.</b> The declaration order of these members is unspecified.\nThe type of such a data member is the type of the corresponding captured entity if the entity is not a\nreference to an object, or the referenced type otherwise. [ Note: If the captured entity is a reference to a\nfunction, the corresponding data member is also a reference to a function. \u2014end note ]</blockquote>\n<blockquote id=\"so_19996134_19996354_1\">\n<b>5.1.2.21:</b> <br/>\n<b>When the lambda-expression is evaluated, the entities that are captured by copy are used to direct-initialize\neach corresponding non-static data member of the resulting closure object.</b> (For array members, the array\nelements are direct-initialized in increasing subscript order.) These initializations are performed in the\n(unspecified) order in which the non-static data members are declared. [ Note: This ensures that the\ndestructions will occur in the reverse order of the constructions. \u2014end note ]\n</blockquote>\n", "OwnerUserId": "453803", "PostTypeId": "2", "Id": "19996354", "Score": "1", "CreationDate": "2013-11-15T08:09:00.713", "LastActivityDate": "2013-11-15T08:09:00.713"}, "19996134": {"CommentCount": "0", "ViewCount": "185", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2013-11-15T07:55:44.413", "LastActivityDate": "2013-11-15T19:44:11.230", "Title": "When is a variable reference in a C++11 lambda expression resolved?", "AcceptedAnswerId": "19996191", "LastEditDate": "2013-11-15T19:44:11.230", "Id": "19996134", "Score": "2", "Body": "<p>I have a (hopefully) simple question about lambda expressions:\n</p>\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n//----------------------------------------------------------------\nvoid DoSomething()\n//----------------------------------------------------------------\n{\n  std::vector&lt;int&gt; elements;\n  elements.push_back(1);\n  elements.push_back(2);\n\n  int ref = 1;\n  auto printhit = [=](int iSomeNumber)\n  {\n    if (ref == iSomeNumber)\n    {\n      printf(\"Hit: %d\\n\", iSomeNumber);\n    }\n    else\n    {\n      printf(\"No Hit: %d\\n\", iSomeNumber);\n    }\n  };\n\n  ref = 2;\n  std::for_each(elements.begin(), elements.end(), printhit);   \n}\n</code></pre>\n<p>Now, my question is: When I define printhit with capture [=], it prints \"Hit: 1\". If I pass it by reference [&amp;], it prints \"Hit: 2\". \nI somehow expected, that the substitution is done within for_each, so that \"Hit: 2\" is printed no matter how I grant access to \"ref\".</p>\n<p>Can anyone explain this to me? </p>\n<p>Thanks,\n  Markus</p>\n", "Tags": "<c++><c++11><lambda>", "OwnerUserId": "2995275", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_19996134_19996354_1": {"section_id": 5981, "quality": 0.8444444444444444, "length": 38}, "so_19996134_19996354_0": {"section_id": 5974, "quality": 0.8245614035087719, "length": 47}}, "n3337": {"so_19996134_19996354_1": {"section_id": 5749, "quality": 0.8444444444444444, "length": 38}, "so_19996134_19996354_0": {"section_id": 5742, "quality": 0.8596491228070176, "length": 49}}, "n4659": {"so_19996134_19996354_1": {"section_id": 7478, "quality": 0.8444444444444444, "length": 38}, "so_19996134_19996354_0": {"section_id": 7473, "quality": 0.6666666666666666, "length": 38}}}, "19996639": {"ParentId": "19996134", "CommentCount": "0", "Body": "<p>What would be the point of having them both operate the same way?  The point of <code>[=]</code> is to support capture by copy <em>instead</em> of by reference.</p>\n<p>Imagine if <code>[=]</code> wasn't available: if you know a runtime value at the point in the code where the lambda's defined and want the lambda to use it ever after, how could that value be made available to the lambda code?  While <code>DoSomething()</code> is running by-ref <code>[&amp;]</code> access to its local <code>ref</code> variable might serve, but what if you want to have the lambda's lifetime outlive the local scope in <code>DoSomething()</code> that contains it, or want to change the value of <code>ref</code> without that affecting future calls to the lambda?  Conceptually, you could have the language forbid all these things (use after <code>ref</code> is changed or changes to <code>ref</code> or calls of the lambda after <code>ref</code> is changed or out of scope), or the programmer could go to elaborate lengths to put the value of <code>ref</code> somewhere for the lambda to use (e.g. on the heap, with the need to manage deallocation, or in some static buffer with re-entrance and thread-safety issues), but to make it convenient the language provides <code>[=]</code>.  The compiler-generated lambda effectively takes responsibility for storing and destructing/deallocating the copy of <code>ref</code>.</p>\n", "OwnerUserId": "410767", "PostTypeId": "2", "Id": "19996639", "Score": "1", "CreationDate": "2013-11-15T08:29:17.917", "LastActivityDate": "2013-11-15T08:29:17.917"}, "19996191": {"ParentId": "19996134", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The capture happens at the location where you declare the lambda.  Just like if you were to create a class object at that point and pass <code>ref</code> to its constructor.</p>\n<p>Your example is equivalent to this:</p>\n<pre><code>class Functor\n{\npublic:\n    Functor(int r) :ref(r) {}\n\n    void operator()(int iSomeNumber) const\n    {\n        if (ref == iSomeNumber)\n        {\n            printf(\"Hit: %d\\n\", iSomeNumber);\n        }\n        else\n        {\n            printf(\"No Hit: %d\\n\", iSomeNumber);\n        }    \n    }\nprivate:\n    int ref;\n};\n\nvoid DoSomething()\n//----------------------------------------------------------------\n{\n  std::vector&lt;int&gt; elements;\n  elements.push_back(1);\n  elements.push_back(2);\n\n  int ref = 1;\n  Functor printhit(ref);\n\n  ref = 2;\n  std::for_each(elements.begin(), elements.end(), printhit);   \n}\n</code></pre>\n", "OwnerUserId": "440119", "LastEditorUserId": "440119", "LastEditDate": "2013-11-15T08:04:23.730", "Id": "19996191", "Score": "5", "CreationDate": "2013-11-15T07:59:06.267", "LastActivityDate": "2013-11-15T08:04:23.730"}});