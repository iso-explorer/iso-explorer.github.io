post_cb({"9842857": {"ParentId": "2111667", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>This is a little bit late, but I succeeded in implementing a compile-time CRC32 function with the use of <code>constexpr</code>. The problem with it is that at the time of writing, it only works with GCC and not MSVC nor Intel compiler.</p>\n<p>Here is the code snippet:</p>\n<pre><code>// CRC32 Table (zlib polynomial)\nstatic constexpr uint32_t crc_table[256] = {\n    0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,\n    0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,\n    0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,\n...\n};\ntemplate&lt;size_t idx&gt;\nconstexpr uint32_t crc32(const char * str)\n{\n    return (crc32&lt;idx-1&gt;(str) &gt;&gt; 8) ^ crc_table[(crc32&lt;idx-1&gt;(str) ^ str[idx]) &amp; 0x000000FF];\n}\n\n// This is the stop-recursion function\ntemplate&lt;&gt;\nconstexpr uint32_t crc32&lt;size_t(-1)&gt;(const char * str)\n{\n    return 0xFFFFFFFF;\n}\n\n// This doesn't take into account the nul char\n#define COMPILE_TIME_CRC32_STR(x) (crc32&lt;sizeof(x) - 2&gt;(x) ^ 0xFFFFFFFF)\n\nenum TestEnum\n{\n    CrcVal01 = COMPILE_TIME_CRC32_STR(\"stack-overflow\"),\n};\n</code></pre>\n<p><code>CrcVal01</code> is equal to 0x335CC04A</p>\n<p>Hope this will help you!</p>\n", "OwnerUserId": "1288680", "LastEditorUserId": "1288680", "LastEditDate": "2014-05-23T13:02:52.580", "Id": "9842857", "Score": "69", "CreationDate": "2012-03-23T16:25:32.433", "LastActivityDate": "2014-05-23T13:02:52.580"}, "2111667": {"CommentCount": "4", "AcceptedAnswerId": "9842857", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2010-01-21T18:08:14.850", "LastActivityDate": "2017-07-21T00:02:38.343", "LastEditDate": "2011-12-19T00:00:16.823", "ViewCount": "27083", "FavoriteCount": "38", "Title": "Compile time string hashing", "Id": "2111667", "Score": "75", "Body": "<p>I have read in few different places that using C++11's new string literals it might be possible to compute a string's hash at compile time.  However, no one seems to be ready to come out and say that it will be possible or how it would be done.</p>\n<ul>\n<li>Is this possible?</li>\n<li>What would the operator look like?</li>\n</ul>\n<hr>\n<p>I'm particularly interested use cases like this.</p>\n<pre><code>void foo( const std::string&amp; value )\n{\n   switch( std::hash(value) )\n   {\n      case \"one\"_hash: one(); break;\n      case \"two\"_hash: two(); break;\n      /*many more cases*/\n      default: other(); break;\n   }\n}\n</code></pre>\n<p>Note: the compile time hash function doesn't have to look exactly as I've written it.  I did my best to guess what the final solution would look like, but <code>meta_hash&lt;\"string\"_meta&gt;::value</code> could also be a viable solution.</p>\n</hr>", "Tags": "<c++><metaprogramming><c++11><hash>", "OwnerUserId": "28817", "AnswerCount": "8"}, "7869639": {"ParentId": "2111667", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The following works in GCC 4.6.1, and you can use either <code>hash</code> or <code>pack</code> in switch blocks.</p>\n<pre><code>/* Fast simple string hash (Bernstein?) */                                       \nconstexpr unsigned int hash(const char *s, int off = 0) {                        \n    return !s[off] ? 5381 : (hash(s, off+1)*33) ^ s[off];                           \n}                                                                                \n\n/* Pack the string into an unsigned int                                          \n * Using 7 bits (ascii) it packs 9 chars into a uint64_t                         \n */                                                                              \ntemplate &lt;class T = uint64_t, unsigned int Bits = 7&gt;                             \nconstexpr T pack(const char *s, unsigned int off = 0) {                          \n    return (Bits*off &gt;= CHAR_BIT*sizeof(T) || !s[off]) ? 0 :                     \n        (((T)s[off] &lt;&lt; (Bits*off)) | pack(s,off+1));                             \n}  \n</code></pre>\n<p>GCC seemingly(?) does not allow recursive calls where we pass on <code>s+1</code> with <code>s</code> a pointer, which is why I use the <code>off</code> variable.</p>\n", "OwnerUserId": "137317", "LastEditorUserId": "137317", "LastEditDate": "2011-10-27T21:19:14.607", "Id": "7869639", "Score": "5", "CreationDate": "2011-10-23T22:17:27.927", "LastActivityDate": "2011-10-27T21:19:14.607"}, "2112101": {"CommentCount": "5", "CreationDate": "2010-01-21T19:14:05.097", "CommunityOwnedDate": "2010-01-22T03:11:29.873", "LastEditorUserId": "-1", "LastActivityDate": "2010-05-13T12:22:52.307", "ParentId": "2111667", "PostTypeId": "2", "LastEditDate": "2017-05-23T12:02:14.820", "Id": "2112101", "Score": "7", "Body": "<p><strong>Note that the form shown here wasn't accepted into the standard, as noted below.</strong></p>\n<p>Compile time string processing is guessed to become possible through <em>user-defined literals</em> proposed in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2765.pdf\" rel=\"nofollow noreferrer\">N2765</a>.<br>\nAs i already mentioned, i don't know of any compiler that currently implements it and without compiler support there can be only guess work.</br></p>\n<p>In \u00a72.13.7.3 and 4 of the <a href=\"http://www2.research.att.com/~bs/SC22-N-4411.pdf\" rel=\"nofollow noreferrer\">draft</a> we have the following:</p>\n<blockquote>\n<p id=\"so_2111667_2112101_0\">Otherwise (S contains a literal operator template), L is treated as a call of the form<br>\n   operator \"\" X&lt;'c1', 'c2', ... , 'ck'&gt;() \n  where n is the source character sequence c1c2...ck. [Note: The sequence c1c2...ck can\n  only contain characters from the basic source character set. \u2014end note] </br></p>\n</blockquote>\n<p>Combine that with <code>constexpr</code> and we should have compile time string processing.</p>\n<p><em>update: i overlooked that i was reading the wrong paragraph, this form is allowed for user-defined-integer-literals and -floating-literals, but apparently not for -string-literals (\u00a72.13.7.5).<br>\nThis part of the proposal seems to have not been accepted.</br></em></p>\n<p>That being said, with my limited glimpse at C++0x, it <strong>might</strong> look something like this (i most likely got something wrong):</p>\n<pre><code>template&lt;char c, char... str&gt;\nstruct hash {\n    static const unsigned result = c + hash&lt;str...&gt;::result;\n};\n\ntemplate&lt;char c&gt;\nstruct hash {\n    static const unsigned result = c;\n};\n\ntemplate&lt;char... str&gt; \nconstexpr unsigned\noperator \"\" _hash() {\n    return hash&lt;str&gt;::result;\n}\n\n// update: probably wrong, because the above \n// form is not allowed for string-literals:    \nconst unsigned h = \"abcd\"_hash;\n</code></pre>\n<hr>\n<p>If <a href=\"https://stackoverflow.com/questions/2111667/compile-time-string-hashing/2112111#2112111\">Jerrys approach</a> works, then the following should work however:</p>\n<pre><code>constexpr unsigned operator \"\" _hash(const char* s, size_t) {\n    return const_hash(s);\n}\n</code></pre>\n</hr>", "OwnerUserId": "168225"}, "23684632": {"ParentId": "2111667", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This is an attempt to solve the OP's problem as exactly as possible.</p>\n<pre><code>namespace my_hash {\n  template&lt;class&gt;struct hasher;\n  template&lt;&gt;\n  struct hasher&lt;std::string&gt; {\n    std::size_t constexpr operator()(char const *input)const {\n      return *input ?\n        static_cast&lt;unsigned int&gt;(*input) + 33 * (*this)(input + 1) :\n        5381;\n    }\n    std::size_t operator()( const std::string&amp; str ) const {\n      return (*this)(str.c_str());\n    }\n  };\n  template&lt;typename T&gt;\n  std::size_t constexpr hash(T&amp;&amp; t) {\n    return hasher&lt; typename std::decay&lt;T&gt;::type &gt;()(std::forward&lt;T&gt;(t));\n  }\n  inline namespace literals {\n    std::size_t constexpr operator \"\" _hash(const char* s,size_t) {\n      return hasher&lt;std::string&gt;()(s);\n    }\n  }\n}\nusing namespace my_hash::literals;\nvoid one() {} void two() {} void other() {}\n\nvoid foo( const std::string&amp; value )\n{\n  switch( my_hash::hash(value) )\n  {\n    case \"one\"_hash: one(); break;\n    case \"two\"_hash: two(); break;\n    /*many more cases*/\n    default: other(); break;\n  }\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/eeb53a0061d71df2\" rel=\"nofollow noreferrer\">live example</a>.</p>\n<p>Note the main difference -- <code>std::hash</code> cannot be used, as we do not have control over <code>std::hash</code>'s algorithm, and we <strong>must</strong> reimplement it as a <code>constexpr</code> in order to evaluate it at compile time.  In addition, there are no \"transparent\" hashes in <code>std</code>, so you cannot (without creating a <code>std::string</code>) hash a raw character buffer as a <code>std::string</code>.</p>\n<p>I stuck the <code>std::string</code> custom hasher (with transparent <code>const char*</code> support) into a <code>my_hash</code> namespace, so you can store it in a <code>std::unordered_map</code> if you need consistency.</p>\n<p>Based off of @JerryCoffin's excellent answer and the comment thread below it, but with an attempt to write it with current C++11 best practices (as opposed to anticipating them!).</p>\n<p>Note that using a \"raw hash\" for a <code>switch</code> statement <code>case</code> is dangerous.  You'll want to do an <code>==</code> comparison afterwards to confirm it worked.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2017-01-31T14:10:56.150", "Id": "23684632", "Score": "9", "CreationDate": "2014-05-15T17:07:27.343", "LastActivityDate": "2017-01-31T14:10:56.150"}, "43253227": {"ParentId": "2111667", "CommentCount": "0", "Body": "<p>This is a nice question.</p>\n<p>Based on Jerry Coffin's answer, I've created another one that's compatible with Visual Studio 2017's std::hash.</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;cassert&gt;\nusing namespace std;\n\n\nconstexpr size_t cx_hash(const char* input) {\n    size_t hash = sizeof(size_t) == 8 ? 0xcbf29ce484222325 : 0x811c9dc5;\n    const size_t prime = sizeof(size_t) == 8 ? 0x00000100000001b3 : 0x01000193;\n\n    while (*input) {\n        hash ^= static_cast&lt;size_t&gt;(*input);\n        hash *= prime;\n        ++input;\n    }\n\n    return hash;\n}\n\n\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n\n    auto a = cx_hash(\"test\");\n    hash&lt;string&gt; func;\n    auto b = func(\"test\");\n    assert(a == b);\n\n    return 0;\n}\n</code></pre>\n<p><a href=\"https://github.com/manuelgustavo/cx_hash\" rel=\"nofollow noreferrer\">https://github.com/manuelgustavo/cx_hash</a></p>\n", "OwnerUserId": "7598384", "PostTypeId": "2", "Id": "43253227", "Score": "1", "CreationDate": "2017-04-06T10:59:56.930", "LastActivityDate": "2017-04-06T10:59:56.930"}, "23683218": {"ParentId": "2111667", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This snippet based on Clement JACOB's one. But works with clang too. And it should be faster on compilation (it have only one recursive call, not two like in original post).</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nstatic constexpr unsigned int crc_table[256] = {\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\n    0xe963a535, 0x9e6495a3,    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\n    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\n    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\n    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\n    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\n    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\n    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\n    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\n    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\n    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\n    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\n    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\n    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\n    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\n    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\n    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\n    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\n    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n};\n\n\ntemplate&lt;int size, int idx = 0, class dummy = void&gt;\nstruct MM{\n  static constexpr unsigned int crc32(const char * str, unsigned int prev_crc = 0xFFFFFFFF)\n  {\n      return MM&lt;size, idx+1&gt;::crc32(str, (prev_crc &gt;&gt; 8) ^ crc_table[(prev_crc ^ str[idx]) &amp; 0xFF] );\n  }\n};\n\n// This is the stop-recursion function\ntemplate&lt;int size, class dummy&gt;\nstruct MM&lt;size, size, dummy&gt;{\n  static constexpr unsigned int crc32(const char * str, unsigned int prev_crc = 0xFFFFFFFF)\n  {\n      return prev_crc^ 0xFFFFFFFF;\n  }\n};\n\n// This don't take into account the nul char\n#define COMPILE_TIME_CRC32_STR(x) (MM&lt;sizeof(x)-1&gt;::crc32(x))\n\n\ntemplate&lt;unsigned int crc&gt;\nvoid PrintCrc()\n{\n    std::cout &lt;&lt; crc &lt;&lt; std::endl;\n}\n\n\nint main()\n{\n\n    PrintCrc&lt;COMPILE_TIME_CRC32_STR(\"HAH\")&gt;();\n}\n</code></pre>\n<p>See proof of concept <a href=\"https://gcc.godbolt.org/#%7B%22version%22%3A3%2C%22filterAsm%22%3A%7B%22labels%22%3Atrue%2C%22directives%22%3Atrue%2C%22commentOnly%22%3Atrue%2C%22colouriseAsm%22%3Atrue%7D%2C%22compilers%22%3A%5B%7B%22sourcez%22%3A%22MQSwdgxgNgrgJgUwAQB4QHsDOAXATggQwFsA%2BAKFElkVR13AHNzLp5kUA3BCbdXcsjgLYQEJBHRgcCAB4AHXEhhSQDMAjhJw2cbggB9bAQBGUBAG0ATAFYAbAF0kAXiQBvMkk9IADDO%2F%2BA%2FwAaHxkAdjDvMIBmbwBOWxDfBARvBFsARksIJJk4uPjrDOMCXKjbOAgAFgy43MjbAgAzKoAOJqCPL2SE6IJraOtcuPSquOsCaJDuvw1jVtboy3q4yvmCKtzUuGsEOIyEYbC4Szg4hc6ASF9441sqiEtjeoRjDLCIYzgtsPnTqOG3mMTQyZwyuVBxjCGW891yjWM3ks3iayzI1xkTWixji0LauVaVWMCBqiCCGIyBDgVKqx3hcAZJNeuRacCJ1iKBOicGirWsEDCV18GWitgg5zs8KqthKrQg3hZcFsliauNKoVaBFs%2FJGOQpVW8GX5VQ6oVssVsYrOQsxBBR3PNBLg3la3jgTSGGOxtgQyIgrVyD1s%2B28u1yO1s3hqJNyBEstgi7zRXvl0RJcHBoSJUbZtPDyLgfKa31C%2FW8Jjszy91mME3a6t8VSelnOYptcGMnfFStjnwgqoN5N8S0LYoQUyz1nd%2FLCQ1ClSVbv7sa%2BIp2dXRvnjZ1iBByoSKiH8fVy%2Frgs4yrtywOdmQyiVClmKJvZuUr0Wqlimm5k%2FZK43ya9Wi%2BMtTS3V0nlaEY3yaUMFhdU9IwgM5jGWUI3iBPZLE2H8VVsJoPlaQUD1aWxCQgDJM18Ci72pZ50MtZUeW%2BDEwgqapagVUJDQ7aFYRtc4TmRYx92SYsiiRBtwmKS9rCgsoZRlIowLyJpgRJfotmA1o2Wib9WNdD44jjMpYJROJok2UIEniAgFkOUIEBhPZWkveomkaN1OzKUjmNOAT72lcViOSS1BnlKiZEU2sMhaCEIDFTJlQJOwBjdANQlRZV%2FCqQ4fzFWFxg0CFEUpaxfgJZF2geSKPRRapyvhGs3TiBKISeMI9msBUf2A4l5kIFlPnOIjRKi04MwZFSjWpU4xgJZDog%2BLEWS%2BKogyGH8qg7eMjQy4cKyKCAHN8SYRP8MIrN8NlO1iX1AypJp%2BhqXJuULcZzxtDYM2qCpwwdFo1MDUURgSKTLJ9M4mjGqkEwWaVwy1IEdJ6jF1qjU4Yle2JolBBA51Ou0NggawVIZN0PnFN9%2FHKkUxssSJsMpUof2JIEYRhU8CkeF0H18cqyNrGxcmRfC%2BWMCdfBxS02XiU90gOMYOh%2FXZEFVNIRdWVr8n2mREWdc5LDQ6jjjCOzjCumRrDiCXuXeEXXgNQtwVZ34dggbFTyBLUICpLYOwWJYuN8YzgQlu4ym9X1vDGy63hOYybUIHZaWiOprIZBmzZUnNUMyAnwm5GjFi2UVYjeY28mlKpsUJG03QqRo03qLV%2BgIOytgNbhYPokPYjiJpVRLG47XLX0QvCZ0whGN4bTM1VLMtoiXUmE4IVSWL4114NYUeJoTsxNibFnYeZFdbUE0%2BG1ajFUVoXhdJER9Cf97ZYo2IJVYljZiE3QIM2JjwmOGyPcOQfyqhxO6fCBJXgpEHunYUvxfgkkllFIELoNAFyVEqSYCBdYEFBLUJaeUvQ6TlNkS2Jp3SomsJXDMnYEwgljDKEmbEJ7RDUt1Cop82ioVFESdsroTggVjLBAhFsxqim8JZZofMZA1CjGbSM4YPJpGhqguyCZpybS9PePBcDAyWhtggaep47jFF5GNESlpFiUhFnYYslg7Rvi3r6UUNoIDygFNPAunYgS0mkSLZET4ZQIKtt1WhyoVIkxKNiYk14njOlQgGXCnYqgTDiJXfkEtPKW0eOeQe%2F9rxThjliSK2QzgjGAm%2BL4hAnLfB%2FDbe4jxERbAShwo2cjZyNEmK1Mo24LLlmGPKAojQwmvDSGXZWrFkRsL5GUbqoZoSoPGMCKodlK6%2BnmGbDIltfgVxKAfGO5iJYpIxJkk4rQ9i9xkPjHYbNT4fEqAgNSE8gQdndE%2BAkFRuRzRZKCXK2Fky%2BDIgyCWTRdaxWpIsH0BJihOStCyUJ8YazwjUlETqkVLxQlpBEG08E%2BQEHSCyWCHl%2F7ByipGc0IkpKUUNECfkBIPLWxeSpCFyoiXBhtElYExZUH3jFP2dJsZ%2FBEoZrrc8boTgpEDKkNogxLZp2kRLR4X02HxkyOGWEhp8ITzGMGWk21XrpBMccG5RKMyNHWeGVY2oqRgLRm6HulpXrHEWMCClBAba%2B3xqgxAnZdQF1pKhfsYQVLl1JvvDcGIvhfFRBkMavsSiPE1G%2BbEac9IUuwhbSYWprxUmkZGAuyFJXBn0vzba%2BMwgthFtyBIvwVI5ITHGA%2Bv1dkmF1lOMixQkQiy1KiHEOEY0Gk7OOCeHsY5XIIW%2BO0U4QQ3P%2BJYF5OkyAAF8ADcZAt3YAQEQOQUBhAIDQGAHQmAQAAC8HLaC0HAGQzgfAhGgAQTAmAkBwBgEQIgABPe9HB0AgDgOQOgMAeBIAALJgfcJ4IQIgxASCkDu%2BQihlBnrUBoLQJ7dAe0sAACngzgcQAALAgigABUSA6AhBQ6odQmhr0KAQBwfQEA9D3t8AAMU41xzjABKLoUGvCeHwNgGAuAwDgbAygM9l6QgAZkAAagyCQAAXMplj2GcOUaQDhhjTH1NIBICQJArQeNIAAHpYcMCYMw5gdP4D06xizdBzByfsKZgAZKETjjgeObs8Kutdm6yAAHpgtIAACqEZAK%2B6LSBsCEeQDgdAcgAC0%2BAICibPZIJATRlA8AwGAMgO690Hp3ce09F6HJPpfW%2Bj936gN4BAzoCDUnKshGkw5d9n6v0kAEzB0Q4hJDSCQ0oFQaG6OYfU0sPDQ2dAQGI2RijeAqNjdoxhnQunmOsZcBx7jXG%2BOeAE4J4TonxObfUxZ3be32N%2BaQAFjdW7QsRai6%2BuAkgADkOgjAAGtkDaHQEgUB6BlBfYS0gMAMAoBEZIxQNW4BkAAGEADyYGAAKABJAAMgAUX0OF9HYHccI4AEoI6WPoAAyuF4nOGZCmZwy1jr6Ami054ylpTqmpu4bp3x7du792HvK1h8gf6ANIFR%2FQE9CO9A4b40dpbcBOfA50CgFAWHUBq5wIr5TCAwBwCgJugLW7r1EAIOAWXZABNdE8BL7Q0uIAoGR2jrHuP8eE%2F0CTsnlhKfU5wwAIgABIAEEA9%2B54yQWXhuyBAAA%22%2C%22compiler%22%3A%22%2Fopt%2Fclang%2Bllvm-3.4.1-x86_64-unknown-ubuntu12.04%2Fbin%2Fclang%2B%2B%22%2C%22options%22%3A%22-std%3Dc%2B%2B11%20-O2%22%7D%5D%7D\" rel=\"nofollow noreferrer\">here</a> </p>\n", "OwnerUserId": "1559666", "LastEditorUserId": "1904419", "LastEditDate": "2017-07-21T00:02:38.343", "Id": "23683218", "Score": "8", "CreationDate": "2014-05-15T15:55:31.570", "LastActivityDate": "2017-07-21T00:02:38.343"}, "bq_ids": {"n4140": {"so_2111667_2112101_0": {"section_id": 5369, "quality": 0.7142857142857143, "length": 20}}, "n3337": {"so_2111667_2112101_0": {"section_id": 5165, "quality": 0.7142857142857143, "length": 20}}, "n4659": {"so_2111667_2112101_0": {"section_id": 6794, "quality": 0.7142857142857143, "length": 20}}}, "35672317": {"ParentId": "2111667", "CommentCount": "1", "Body": "<p>Another solution based on Clement JACOB's one, using C++11 constexpr (not the extended C++14) but having only one recursion.</p>\n<pre><code>namespace detail {\n// CRC32 Table (zlib polynomial)\nstatic constexpr uint32_t crc_table[256] = { 0x00000000L, 0x77073096L, ... }\n\ntemplate&lt;size_t idx&gt;\nconstexpr uint32_t combine_crc32(const char * str, uint32_t part) {\n  return (part &gt;&gt; 8) ^ crc_table[(part ^ str[idx]) &amp; 0x000000FF];\n}\n\ntemplate&lt;size_t idx&gt;\nconstexpr uint32_t crc32(const char * str) {\n  return combine_crc32&lt;idx&gt;(str, crc32&lt;idx - 1&gt;(str));\n}\n\n// This is the stop-recursion function\ntemplate&lt;&gt;\nconstexpr uint32_t crc32&lt;size_t(-1)&gt;(const char * str) {\n  return 0xFFFFFFFF;\n}\n\n} //namespace detail\n\ntemplate &lt;size_t len&gt;\nconstexpr uint32_t ctcrc32(const char (&amp;str)[len]) {\n  return detail::crc32&lt;len - 2&gt;(str) ^ 0xFFFFFFFF;\n}\n</code></pre>\n<p>Some explanation</p>\n<ul>\n<li>We are using a single recursion, so that the function works well even for longer strings.</li>\n<li>The extra function <code>combine_crc32</code> allows us to store the result of a recursion under a variable <code>part</code> and using it twice. This function is a walkaround for  C++11 limitaton disallowing local variable declarations.</li>\n<li>The <code>ctcrc32</code> function expects a string literal, which is passed as a <code>const char (&amp;)[len]</code>. This way we can get the string length as a template parameter and do not have to rely on macros.</li>\n</ul>\n", "OwnerUserId": "635654", "PostTypeId": "2", "Id": "35672317", "Score": "4", "CreationDate": "2016-02-27T16:32:45.863", "LastActivityDate": "2016-02-27T16:32:45.863"}, "2112111": {"ParentId": "2111667", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>At least by my reading of \u00a77.1.5/3 and \u00a75.19, the following might be legitimate:</p>\n<pre><code>unsigned constexpr const_hash(char const *input) {\n    return *input ?\n        static_cast&lt;unsigned int&gt;(*input) + 33 * const_hash(input + 1) :\n        5381;\n}\n</code></pre>\n<p>This does seem to follow the basic rules in \u00a77.1.5/3:</p>\n<ol><li>The form is: \"return expression;\"</li>\n<li>Its only parameter is a pointer, which is a scalar type, and therefore a literal type.</li>\n<li>Its return is unsigned int, which is also scalar (and therefore literal).</li>\n<li>There is no implicit conversion to the return type.</li>\n</ol>\n<p>There is some question whether the <code>*input</code>s involve an illegal lvalue to rvalue conversion, and I'm not sure I understand the rules in \u00a75.19/2/6/2<sup>1</sup> and \u00a74.1 well enough to be sure about that.</p>\n<p>From a practical viewpoint, this code is accepted by (for one example) g++, at least as far back as g++ 4.7.1.</p>\n<p>Usage would be something like:</p>\n<pre><code>switch(std::hash(value)) {\n    case const_hash(\"one\"): one(); break;\n    case const_hash(\"two\"): two(); break;\n    // ...\n    default: other(); break;\n}\n</code></pre>\n<p>To comply with the requirements of \u00a75.19/2/6/2 you might have to do something like this though:</p>\n<pre><code>// one of the `constexpr`s is probably redundant, but I haven't figure out which.\nchar constexpr * constexpr v_one = \"one\"; \n\n// ....\n\ncase const_hash(v_one): one(); break;\n</code></pre>\n<ol>\n<li>I'm using the extra 'slash' numbers to refer to unnumbered bullet points, so this is the second bullet point inside if the sixth bullet point under \u00a75.19/2. I think I might have to talk to Pete Becker about whether it's possible to add some sort of numbers/letters/roman numerals down the hierarchy to identify pieces like this...</li>\n</ol>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2013-10-01T19:03:16.397", "Id": "2112111", "Score": "24", "CreationDate": "2010-01-21T19:15:44.363", "LastActivityDate": "2013-10-01T19:03:16.397"}});