post_cb({"38823713": {"Id": "38823713", "PostTypeId": "2", "Body": "<p>Yes, it's guaranteed by the standard. <code>Wrapper&lt;T&gt;::call_f()</code> will be implicitly instantiated only when it gets called.</p>\n<p><a href=\"http://eel.is/c++draft/temp.inst#2\" rel=\"nofollow\">$14.7.1/2 Implicit instantiation\n[temp.inst]</a>:</p>\n<blockquote>\n<p id=\"so_38823513_38823713_0\">Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist;</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/temp.inst#8\" rel=\"nofollow\">$14.7.1/8 Implicit instantiation\n[temp.inst]</a>:</p>\n<blockquote>\n<p id=\"so_38823513_38823713_1\">An implementation shall not implicitly instantiate a function template, a variable template, a member template, a non-virtual member function, a member class, a static data member of a class template, or a substatement of a constexpr if statement ([stmt.if]), unless such instantiation is required.</p>\n</blockquote>\n", "LastActivityDate": "2016-08-08T07:42:07.970", "CommentCount": "0", "CreationDate": "2016-08-08T07:42:07.970", "ParentId": "38823513", "Score": "2", "OwnerUserId": "3309790"}, "bq_ids": {"n4140": {"so_38823513_38823713_1": {"length": 19, "quality": 0.7307692307692307, "section_id": 243}, "so_38823513_38823713_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 234}}, "n3337": {"so_38823513_38823713_1": {"length": 17, "quality": 0.6538461538461539, "section_id": 235}, "so_38823513_38823713_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 227}}, "n4659": {"so_38823513_38823713_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 250}, "so_38823513_38823713_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 244}}}, "38823575": {"Id": "38823575", "PostTypeId": "2", "Body": "<p>Yes, this is part of the C++ standard.</p>\n<p>The rules of template instantiation are long and complex, but the short version is that a member function of a template class is only instantiated when needed. If nothing calls it, or tries to take a pointer to it, or explicitly instantiates it (and probably a few other cases that I'm forgetting), then it won't be instantiated and your code is well-formed.</p>\n<p>As @dyp points out, it is only the <em>declaration</em> of the member function which is instantiated when the class definition is instantiated (<code>[temp.inst]/1</code>), but the return type deduction is only carried out when the function <em>definition</em> is instantiated (<code>[dcl.spec.auto]/12</code>).</p>\n<p>This is extremely helpful both for minimising the overhead of templates and being permissive about type requirements. It's this feature which lets you do something like this:</p>\n<pre><code>struct Foo {\n    //no default constructor\n    Foo(int);\n};\n\nstd::vector&lt;Foo&gt; foos;\n</code></pre>\n<p>Some <code>std::vector</code> functions (<code>resize</code>, for example) require <code>T</code> to be default-constructible, but as long as you don't call those functions you can still use other features of <code>std::vector</code>. </p>\n", "LastEditorUserId": "496161", "LastActivityDate": "2016-08-08T08:02:15.867", "Score": "11", "CreationDate": "2016-08-08T07:33:24.277", "ParentId": "38823513", "CommentCount": "0", "OwnerUserId": "496161", "LastEditDate": "2016-08-08T08:02:15.867"}, "38823513": {"ViewCount": "151", "Body": "<pre><code>struct Value {\n    using a_type = int;\n    a_type f() { return 1; }\n};\n\ntemplate&lt;typename T&gt;\nstruct Wrapper {\n    T t;\n    auto call_f() { return t.f(); }\n};\n\nint main() {\n    Wrapper&lt;Value&gt; w;\n    Wrapper&lt;int&gt; w2;\n    w.call_f();\n}\n</code></pre>\n<p>This compiles fine on Clang and GCC. <code>Wrapper&lt;int&gt;</code> gets instantiated even though the return type of <code>Wrapper&lt;int&gt;::call_f()</code> can not be deduced (there is no <code>int::f()</code>). It fails only when <code>w2.call_f()</code> gets called.</p>\n<p>Is this part of the C++ standard, and can it be expected to work on all compilers?</p>\n", "AcceptedAnswerId": "38823575", "Title": "Template instantiation with undefined member function return types", "CreationDate": "2016-08-08T07:30:23.260", "Id": "38823513", "CommentCount": "0", "LastEditDate": "2016-08-08T07:49:29.267", "PostTypeId": "1", "LastEditorUserId": "3309790", "LastActivityDate": "2016-08-08T08:02:15.867", "Score": "4", "OwnerUserId": "4108376", "Tags": "<c++><templates><c++11><c++14><auto>", "AnswerCount": "2"}});