post_cb({"39203657": {"ParentId": "37219984", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-08-29T10:08:41.230", "Score": "0", "LastEditorUserId": "817643", "LastEditDate": "2016-08-29T10:17:02.707", "Id": "39203657", "OwnerUserId": "817643", "Body": "<p>Well, the standard provides an answer as usual. And mandates it explicitly.</p>\n<p>Quoting <a href=\"http://eel.is/c++draft/basic.lookup.elab\" rel=\"nofollow\">3.4.4 [basic.lookup.elab]</a> paragraph 2 (empahsis mine):</p>\n<blockquote>\n<p id=\"so_37219984_39203657_0\">If the <em>elaborated-type-specifier</em> has no <em>nested-name-specifier</em>, and <strong>unless the <em>elaborated-type-specifier</em> appears in a declaration with the following form</strong>:</p>\n<p id=\"so_37219984_39203657_1\"><em>class-key attribute-specifier-seqopt identifier ;</em> </p>\n<p id=\"so_37219984_39203657_2\"><strong>the identifier is looked up according to [basic.lookup.unqual]</strong> but ignoring any non-type names that have been declared<br>\n  (...)<br>\n  If the <em>elaborated-type-specifier</em> is introduced by the <em>class-key</em> <strong>and this lookup does not find a previously declared type-name</strong>, or if the <em>elaborated-type-specifier</em> appears in a declaration with the form:</br></br></p>\n<p id=\"so_37219984_39203657_3\"><em>class-key attribute-specifier-seqopt identifier ;</em> </p>\n<p id=\"so_37219984_39203657_4\"><strong>the <em>elaborated-type-specifier</em> is a declaration that introduces the class-name as described in</strong> [basic.scope.pdecl].</p>\n</blockquote>\n<p>And <a href=\"http://eel.is/c++draft/basic.scope.pdecl\" rel=\"nofollow\">3.3.2 [basic.scope.pdecl]</a> paragraph 7 (emphasis again mine):</p>\n<blockquote>\n<p id=\"so_37219984_39203657_5\">The point of declaration of a class first declared in an <em>elaborated-type-specifier</em> is as follows:</p>\n<p id=\"so_37219984_39203657_6\">-- for a declaration of the form</p>\n<p id=\"so_37219984_39203657_7\"><em>class-key attribute-specifier-seqopt identifier ;</em></p>\n<p id=\"so_37219984_39203657_8\">the identifier is declared to be a class-name in the scope that contains the declaration, otherwise</p>\n<p id=\"so_37219984_39203657_9\">-- for an <em>elaborated-type-specifier</em> of the form</p>\n<p id=\"so_37219984_39203657_10\"><em>class-key identifier</em></p>\n<p id=\"so_37219984_39203657_11\">if the elaborated-type-specifier is used in the <em>decl-specifier-seq</em> or <em>parameter-declaration-clause</em> of a function defined in namespace scope, the identifier is declared as a class-name in the namespace that contains the declaration; <strong>otherwise</strong>, except as a friend declaration, <strong>the identifier is declared in the smallest namespace or block scope that contains the declaration</strong>. [ Note: These rules also apply within templates.  \u2014 end note ] [ Note: Other forms of elaborated-type-specifier do not declare a new name, and therefore must refer to an existing type-name. See [basic.lookup.elab] and [dcl.type.elab].  \u2014 end note ]</p>\n</blockquote>\n<p><strong>The declaration</strong> in the last emphasized line seems to refer to the declaration of the class where the elaborated class specifier appears. So in our case it adds the <code>Impl</code> into the namespace that contains the class <code>A</code>, the global scope. But the same will apply to any namespace. <a href=\"http://ideone.com/VVBlNO\" rel=\"nofollow\">Case and point</a>:</p>\n<pre><code>namespace E\n{\n    class A\n    {\n        class Impl *pImpl;  \n    };\n}\n\nclass E::Impl\n{\n\n};\n\nint main() {\n    // your code goes here\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2016-08-29T10:17:02.707"}, "37219984": {"CommentCount": "0", "ViewCount": "132", "PostTypeId": "1", "LastEditorUserId": "817643", "CreationDate": "2016-05-13T22:04:22.310", "LastActivityDate": "2016-08-29T10:17:02.707", "Title": "Declare inner class name as part of another declaration", "AcceptedAnswerId": "39203657", "LastEditDate": "2016-06-09T10:01:39.020", "Id": "37219984", "Score": "2", "Body": "<p>While attempting to define a class by the pimpl idiom, I tried to save a line of code by rolling the class forward declaration into the pimpl definition.</p>\n<pre><code>class A\n{\npublic:\n    class Impl *pimpl;\n};\n</code></pre>\n<p>The above declaration compiles fine. What doesn't work, is the attempt to <em>define</em> <code>A::Impl</code>. <a href=\"https://ideone.com/Zd8R2B\" rel=\"nofollow\">As the program bellow demonstrates</a>:</p>\n<pre><code>class A\n{\npublic:\n    class Impl *pimpl;\n};\n\nclass A::Impl\n{\n\n};\n\nint main() {\n    // your code goes here\n    return 0;\n}\n</code></pre>\n<p>It results with:</p>\n<blockquote>\n<p id=\"so_37219984_37219984_0\">error: qualified name does not name a class before '{' token</p>\n</blockquote>\n<p>Now, one can introduce a new class name, by an elaborate type specifier, as part of another declaration. But it is in fact <code>Class ::Impl</code> which is <a href=\"https://ideone.com/SfScvK\" rel=\"nofollow\">introduced</a>. </p>\n<pre><code>class A\n{\npublic:\n    class Impl *pimpl;\n};\n\nclass Impl\n{\n\n};\n\nint main() {\n    Impl i;\n    A a;\n    a.pimpl = &amp;i;\n    return 0;\n}\n</code></pre>\n<p>Why is it that a forward declaration on it's own line (as the idiom is often used), will introduce <code>A::Impl</code>, but when declared as part of the pointer definition, will introduce <code>::Impl</code>?</p>\n<p><strong>Update</strong></p>\n<p>I'm not asking how to make the idiom work. My question is why the single line</p>\n<pre><code>class Impl *pimpl;\n</code></pre>\n<p>doesn't have the same effect as the two lines</p>\n<pre><code>class Impl;\nImpl *pimpl;\n</code></pre>\n<p>In the context of a class definition.</p>\n<p>I'm baffled because the name becomes properly qualified when <a href=\"https://ideone.com/K4bv3X\" rel=\"nofollow\">something similar is done in the context of a namespace</a>.</p>\n<pre><code>namespace A\n{\n    class Impl *pimpl;\n};\n\nclass A::Impl\n{\n\n};\n\nint main() {\n    // your code goes here\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "817643", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_37219984_39203657_11": {"section_id": 7055, "quality": 0.8235294117647058, "length": 42}, "so_37219984_39203657_8": {"section_id": 7055, "quality": 1.0, "length": 7}, "so_37219984_39203657_4": {"section_id": 7124, "quality": 0.8333333333333334, "length": 5}, "so_37219984_39203657_0": {"section_id": 7124, "quality": 1.0, "length": 7}, "so_37219984_39203657_2": {"section_id": 7124, "quality": 0.9583333333333334, "length": 23}, "so_37219984_39203657_5": {"section_id": 7055, "quality": 0.875, "length": 7}}, "n3337": {"so_37219984_39203657_11": {"section_id": 6799, "quality": 0.8235294117647058, "length": 42}, "so_37219984_39203657_8": {"section_id": 6799, "quality": 1.0, "length": 7}, "so_37219984_39203657_4": {"section_id": 6868, "quality": 0.8333333333333334, "length": 5}, "so_37219984_39203657_0": {"section_id": 6868, "quality": 1.0, "length": 7}, "so_37219984_39203657_2": {"section_id": 6868, "quality": 0.9583333333333334, "length": 23}, "so_37219984_39203657_5": {"section_id": 6799, "quality": 0.875, "length": 7}}, "n4659": {"so_37219984_39203657_11": {"section_id": 8552, "quality": 0.8235294117647058, "length": 42}, "so_37219984_39203657_8": {"section_id": 8552, "quality": 1.0, "length": 7}, "so_37219984_39203657_4": {"section_id": 8625, "quality": 0.8333333333333334, "length": 5}, "so_37219984_39203657_0": {"section_id": 8625, "quality": 1.0, "length": 7}, "so_37219984_39203657_2": {"section_id": 8625, "quality": 0.9583333333333334, "length": 23}, "so_37219984_39203657_5": {"section_id": 8552, "quality": 0.875, "length": 7}, "so_37219984_37219984_0": {"section_id": 6924, "quality": 0.625, "length": 5}}}, "37220014": {"ParentId": "37219984", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2016-05-13T22:06:32.343", "Score": "5", "LastEditorUserId": "3943312", "LastEditDate": "2016-05-13T22:07:23.623", "Id": "37220014", "OwnerUserId": "3943312", "Body": "<p>Change your <code>A</code> declaration slightly:</p>\n<pre><code>class A\n{\npublic:\n    class Impl;\n\n    Impl *pimpl;\n};\n</code></pre>\n<p>Now, everything will work as expected.</p>\n<p>You have to tell the compiler that <code>Impl</code> is an inner class, first.</p>\n<pre><code>class A\n{\npublic:\n    class Impl *pimpl;\n};\n</code></pre>\n<p>This tells the compiler that <code>pimpl</code> is a pointer to some top level class named <code>Impl</code>, rather than an inner class.</p>\n", "LastActivityDate": "2016-05-13T22:07:23.623"}});