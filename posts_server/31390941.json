post_cb({"bq_ids": {"n4140": {"so_31390941_31391619_0": {"length": 29, "quality": 0.8529411764705882, "section_id": 5966}}, "n3337": {"so_31390941_31391619_0": {"length": 29, "quality": 0.8529411764705882, "section_id": 5735}}, "n4659": {"so_31390941_31391619_0": {"length": 29, "quality": 0.8529411764705882, "section_id": 7460}}}, "31390993": {"Id": "31390993", "PostTypeId": "2", "Body": "<p>You're missing that compilers are not perfect and sometimes emit silly warnings for relatively new language features in circumstances where they don't make much sense.</p>\n<p>On the other hand, warnings are often all about ensuring that you <em>really</em> meant to write the code you wrote, instead of some other code. Perhaps you meant to capture the outer <code>value</code> but \u2014 for whatever reason: perhaps you weren't paying attention \u2014 failed to capture it and redeclared it instead.</p>\n<p>In this code that does seem like a bit of a stretch, but the point is that warnings don't <em>always</em> tell you about the code you wrote: they sometimes tell you about the code the compiler thinks you possibly <em>meant</em> to write.</p>\n<p>And then it's pretty trivial to use a different name for this parameter to say \"hey, yeah, I know\".</p>\n<p>That would also make for much clearer code with a well-documented intent.</p>\n", "LastActivityDate": "2015-07-13T18:40:15.703", "CommentCount": "2", "CreationDate": "2015-07-13T18:40:15.703", "ParentId": "31390941", "Score": "2", "OwnerUserId": "560648"}, "31390941": {"ViewCount": "534", "Body": "<p>I have a code that looks like this - it's heavily simplified but this snippet compiles and exhibits the same behaviour:</p>\n<pre><code>template &lt;typename TFunc&gt;\nfloat FloatSelect( const float in_value, TFunc&amp;&amp; Predicate) {\n  return std::forward&lt;TFunc&gt;(Predicate)(in_value) ? in_value : 0.0f;\n};\n\nvoid DisplayFloatSelect() {\n  const float value = FloatSelect(\n    -1.0f,\n    [] (const float value) { return value &gt; 0.0f; }\n  );\n\n  std::cout &lt;&lt; value &lt;&lt; std::endl;\n}\n</code></pre>\n<p>With -Wshadow enabled the compiler emits the following warning (as seen <a href=\"http://goo.gl/6dRVnE\" rel=\"nofollow\">here</a>):</p>\n<pre><code>12 : warning: declaration shadows a local variable [-Wshadow]\n\n[] (const float value) { return value &gt; 0.0f; }\n\n^\n\n10 : note: previous declaration is here\n\nconst float value = FloatSelect(\n\n^\n</code></pre>\n<p>Which is not really helpful - I understand what shadowing a variable is about but as the lambda does not capture anything, it should be fine here.</p>\n<p>What am I missing?</p>\n", "AcceptedAnswerId": "31391619", "Title": "Can a non-captured variable be shadowed by a lambda parameter?", "CreationDate": "2015-07-13T18:37:40.397", "Id": "31390941", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2015-07-13T19:27:55.400", "Score": "4", "OwnerUserId": "5112265", "Tags": "<c++><lambda><shadow><clang++>", "AnswerCount": "2"}, "31391619": {"Id": "31391619", "PostTypeId": "2", "Body": "<p>Yes, a non-captured variable can be shadowed by a lambda parameter.</p>\n<p>In the particular case of the lambda in the OP, you might argue that the inner declaration of <code>value</code> does not shadow the scope of the outer declaration because the lambda has no captures. Nonetheless, the outer <code>value</code> can be seen inside the body of the lambda, because the body of the lambda is still inside the scope of the enclosing block:</p>\n<blockquote>\n<p id=\"so_31390941_31391619_0\">(C++14 \u00a75.1.2/p.7): The lambda-expression\u2019s compound-statement yields the function-body (8.4) of the function call operator, but <strong><em>for purposes of name lookup</em></strong> (3.4), determining the type and value of this (9.3.2) and transforming idexpressions referring to non-static class members into class member access expressions using (*this) (9.3.1), <strong><em>the compound-statement is considered in the context of the lambda-expression</em></strong>.</p>\n</blockquote>\n<p>The odr-use of a non-captured variable from the outer scope is an error, but it is possible for a lambda without captures to make use of a name defined in an outer scope if it is not an odr-use (and in such a case, the variable is <em>not</em> captured.) In particular, it is possible to use <code>const</code> variables from an outer scope:</p>\n<pre><code>const int i = 20;\nint f = ([](){return i + 3;})();\n</code></pre>\n<p>So even though the lambda has no captures, an explicit argument named <code>i</code> would certainly shadow the outer <code>i</code>. (See <a href=\"http://coliru.stacked-crooked.com/a/006f5f20cca841d5\">http://coliru.stacked-crooked.com/a/006f5f20cca841d5</a>; you might want to try enabling -Wshadow.)</p>\n<p>Since <code>-Wshadow</code> is precisely intended to reveal this sort of ambiguous name usage, it doesn't seem too surprising that it triggers a warning in the case in the OP.</p>\n<p><code>-Wshadow</code> is not enabled by either <code>-Wall</code> nor by <code>-Wextra</code> precisely because it is often going to warn you about something you don't really care about.</p>\n", "LastEditorUserId": "1566221", "LastActivityDate": "2015-07-13T19:27:55.400", "Score": "9", "CreationDate": "2015-07-13T19:16:34.860", "ParentId": "31390941", "CommentCount": "1", "OwnerUserId": "1566221", "LastEditDate": "2015-07-13T19:27:55.400"}});