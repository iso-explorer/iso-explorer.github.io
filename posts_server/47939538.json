post_cb({"bq_ids": {"n4140": {"so_47939538_47939584_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 311}}, "n3337": {"so_47939538_47939584_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 302}}, "n4659": {"so_47939538_47939584_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 319}}}, "47939538": {"ViewCount": "1363", "Body": "<pre><code>template &lt;typename T&gt;\nvoid func(T&amp;){\n}\n\nint main(){\n    void (*p)(int&amp;) = func;//or &amp;func\n    return 0;\n}\n</code></pre>\n<p>I wonder why this code compiles (with g++). It seems the argument of template function is deduced from the type of p? Is this standard behavior?</p>\n<p>Edit:\nI came up with a possible explanation. That assignment has signature:</p>\n<pre><code>void(*&amp;)(int&amp;)operator=(void(*)(int&amp;));\n</code></pre>\n<p>So func is actually deduced from the input argument type of operator=, rather than from type of <em>p</em> directly. Is that correct?</p>\n", "AcceptedAnswerId": "47939584", "Title": "Why can C++ deduce template arguments on the right side of an assignment operator from the left side?", "CreationDate": "2017-12-22T10:03:49.730", "LastActivityDate": "2018-01-17T18:49:27.403", "CommentCount": "1", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2018-01-17T18:49:27.403", "LastEditorUserId": "1971003", "Id": "47939538", "Score": "31", "OwnerUserId": "1770142", "Tags": "<c++><templates><language-lawyer>", "AnswerCount": "1"}, "47939584": {"Id": "47939584", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_47939538_47939584_0\">Is this standard behavior?</p>\n</blockquote>\n<p>Yes it is. Template argument deduction also happens when you take the address of a function template (such as you do when assigning to or initializing a function pointer). It's explicitly allowed in <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.deduct.funcaddr\" rel=\"noreferrer\">[temp.deduct.funcaddr]/1</a>:</p>\n<blockquote>\n<p id=\"so_47939538_47939584_1\">Template arguments can be deduced from the type specified when taking\n  the address of an overloaded function. The function template's\n  function type and the specified type are used as the types of P and A,\n  and the deduction is done as described in [temp.deduct.type].</p>\n</blockquote>\n<p>The function pointer type provides the argument (<code>A</code> in the above paragraph).</p>\n<blockquote>\n<p id=\"so_47939538_47939584_2\">So func is actually deduced from the input argument type of operator=, rather than from type of p directly. Is that correct?</p>\n</blockquote>\n<p>Not really. For one, it's not assignment, it's initialization that you are doing. And even if it was using an overloaded <code>operator=</code> function, you'd need deduction to initialize the argument for the assignment operator, which brings you back to square one.</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-12-22T10:15:10.480", "Score": "29", "CreationDate": "2017-12-22T10:07:03.400", "ParentId": "47939538", "CommentCount": "9", "OwnerUserId": "817643", "LastEditDate": "2017-12-22T10:15:10.480"}});