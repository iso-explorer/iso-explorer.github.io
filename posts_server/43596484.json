post_cb({"43596484": {"ViewCount": "301", "Body": "<p>I have the following code: </p>\n<pre><code>struct CommonVariables\n{/*some common variables that need to be proceed*/};\n\nstruct CommonHandler\n{\n    static void foo(const CommonVariables&amp; vars) {/*processed vars*/}\n    void bar(const CommonVariables&amp; vars) {/*processed vars*/}\n};\n\nstruct AnotherVariables\n{/*another variables*/};\n\nstruct AnotherHandler\n{\n    static void foo(const AnotherVariables&amp; vars) {/*processed vars*/}\n    void bar(const AnotherVariables&amp; vars) {/*processed vars*/}\n};\n\nstruct Derived : CommonHandler, AnotherHandler\n{};\n</code></pre>\n<p>And when I try to call Derived::foo(/<em>any variable type</em>/) or Derived d; d.bar(/<em>any variable type</em>/), the compiler gives me an error: \"reference to 'foo(or bar)' is ambiguous\".</p>\n<p>Yet below I have almost the same situation:</p>\n<pre><code>struct DifferentHandler\n{\nstatic void foo(const CommonVariables&amp; vars) {}\nstatic void foo(const AnotherVariables&amp; vars) {}\nvoid bar(const AnotherVariables&amp; vars) {}\nvoid bar(const CommonVariables&amp; vars) {}\n};\n</code></pre>\n<p>And calling DifferentHandler::foo(/<em>any variable type</em>/) or 'bar' works just fine.</p>\n<p>There are plenty of solutions to work around the first code block (<a href=\"https://stackoverflow.com/questions/515763/how-can-derived-class-inherit-a-static-function-from-base-class\">template traits</a>, etc.). What I specifically want is to overload methods through inheritance. And I don't understand why calls from Derived are ambiguous (since input parameters have different types, from compiler point of view those functions are different. Like in DifferentHandler)</p>\n<p>NOTE: I've tried MinGW5.8 (in Qt Creator), and MSVC2015 in VS2015. Both compilers generated same error.</p>\n", "AcceptedAnswerId": "43596754", "Title": "c++ static member function overloading with inheritance", "CreationDate": "2017-04-24T19:44:29.403", "Id": "43596484", "CommentCount": "3", "LastEditDate": "2017-05-23T10:31:20.830", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-25T00:00:51.480", "Score": "0", "OwnerUserId": "7915479", "Tags": "<c++><inheritance><static-methods>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_43596484_43596754_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 6996}, "so_43596484_43596754_2": {"length": 9, "quality": 1.0, "section_id": 6991}, "so_43596484_43596754_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 6975}, "so_43596484_43596754_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 6989}}, "n3337": {"so_43596484_43596754_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 6742}, "so_43596484_43596754_2": {"length": 9, "quality": 1.0, "section_id": 6737}, "so_43596484_43596754_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 6721}, "so_43596484_43596754_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 6735}}, "n4659": {"so_43596484_43596754_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 8494}, "so_43596484_43596754_2": {"length": 9, "quality": 1.0, "section_id": 8489}, "so_43596484_43596754_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 8474}, "so_43596484_43596754_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 8487}}}, "43596754": {"Id": "43596754", "PostTypeId": "2", "Body": "<p>Here you go:</p>\n<pre><code>struct Derived : CommonHandler, AnotherHandler\n{\n    using CommonHandler::foo;\n    using CommonHandler::bar;\n    using AnotherHandler::foo;\n    using AnotherHandler::bar;\n};\n</code></pre>\n<p>Fixes your problem. </p>\n<p>The reason for original code not working is found in C++ standard. Here are interesting quotes:</p>\n<p>In 10/2:</p>\n<blockquote>\n<p id=\"so_43596484_43596754_0\">The base class members are said to be inherited by the derived class.\n  Inherited members can be referred to in expressions in the same manner\n  as other members of the derived class, unless their names are hidden\n  or ambiguous (10.2).</p>\n</blockquote>\n<p>Continuing reading to 10.2:</p>\n<blockquote>\n<p id=\"so_43596484_43596754_1\">Member name lookup determines the meaning of a name (id-expression) in\n  a class scope (3.3.7). Name lookup can result in an ambiguity, in\n  which case the program is ill-formed....</p>\n<p id=\"so_43596484_43596754_2\">...consists of two component sets: the declaration set, a\n  set of members <strong>named</strong> f...</p>\n<p id=\"so_43596484_43596754_3\">If the name of an overloaded function is unambiguously found, overloading resolution (13.3) also takes place before access control</p>\n</blockquote>\n<p>Basically, it goes by name first and applies resolution later. Introducing them to derived class through <code>using</code> declaration puts them all in the scope of derived class, where normal resolution rules kick-in.</p>\n", "LastEditorUserId": "5245033", "LastActivityDate": "2017-04-24T20:22:50.463", "Score": "2", "CreationDate": "2017-04-24T20:01:27.190", "ParentId": "43596484", "CommentCount": "3", "OwnerUserId": "5245033", "LastEditDate": "2017-04-24T20:22:50.463"}, "43597116": {"Id": "43597116", "PostTypeId": "2", "Body": "<p>In C++, if a member function of a derived class has the same name as a member function of a base class, then the derived class's version <em>hides</em> the base version -- even if the function signatures are different, and you would otherwise expect them to overload. (If the base class member function is virtual, then the derived class's signature must match exactly*, or it will (usually unintentionally) hide the base class's version -- this is the reason C++11 added the <code>override</code> psuedo-keyword).</p>\n<p>For example:</p>\n<pre><code>struct base {\n    void foo(std::string s) {}\n};\n\nstruct derived : base {\n    void foo(int i) {}\n};\n\nint main() {\n    derived d;\n    d.foo(\"hello\"); // Error -- cannot convert const char* to int\n}\n</code></pre>\n<p>The solution is to use a <code>using</code> directive to bring the base class's member function into the derived class scope, i.e.</p>\n<pre><code>struct derived : base {\n    using base::foo;\n    void foo(int i) {}\n};\n</code></pre>\n<p>(An alternative is to use the obscure</p>\n<pre><code>derived d;\nd.base::foo(\"hello\"); // works\n</code></pre>\n<p>syntax to specify that you want to call the base class version, but this is rarely seen in the real world.)</p>\n", "LastEditorUserId": "2797826", "LastActivityDate": "2017-04-24T20:31:36.503", "Score": "0", "CreationDate": "2017-04-24T20:25:00.567", "ParentId": "43596484", "CommentCount": "1", "OwnerUserId": "2797826", "LastEditDate": "2017-04-24T20:31:36.503"}});