post_cb({"bq_ids": {"n4140": {"so_38951362_38951441_2": {"length": 44, "quality": 0.6875, "section_id": 3201}}, "n3337": {"so_38951362_38951441_2": {"length": 44, "quality": 0.6875, "section_id": 3075}}, "n4659": {"so_38951362_38951441_2": {"length": 56, "quality": 0.875, "section_id": 3962}}}, "38951441": {"Id": "38951441", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_38951362_38951441_0\">what is this syntax <code>int(x)</code> in statement <code>Foo f( int(x) );</code> means?</p>\n</blockquote>\n<p>The parentheses around <code>x</code> are superfluous and will be ignored. So <code>int(x)</code> is same as <code>int x</code> here, means a parameter named <code>x</code> with type <code>int</code>.</p>\n<blockquote>\n<p id=\"so_38951362_38951441_1\">Is it same as <code>Foo f( int x );</code>? </p>\n</blockquote>\n<p>Yes. <code>Foo f( int(x) );</code>, is a function declaration which is named <code>f</code>, returns <code>Foo</code>, takes one parameter named <code>x</code> with type <code>int</code>.</p>\n<p>Here's the explanation from the standard. <a href=\"http://eel.is/c++draft/dcl.ambig.res#1\" rel=\"nofollow\">$8.2/1 Ambiguity resolution\n[dcl.ambig.res]</a>:</p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_38951362_38951441_2\">The ambiguity arising from the similarity between a function-style\n  cast and a declaration mentioned in [stmt.ambig] can also occur in the\n  context of a declaration. In that context, the choice is between a\n  function declaration with a redundant set of parentheses around a\n  parameter name and an object declaration with a function-style cast as\n  the initializer. Just as for the ambiguities mentioned in\n  [stmt.ambig], <strong>the resolution is to consider any construct that could\n  possibly be a declaration a declaration</strong>. [ Note: A declaration can be\n  explicitly disambiguated by adding parentheses around the argument.\n  The ambiguity can be avoided by use of copy-initialization or\n  list-initialization syntax, or by use of a non-function-style cast.  \u2014\n  end note ] [ Example:</p>\n<pre><code>struct S {\n  S(int);\n};\n\nvoid foo(double a) {\n  S w(int(a));      // function declaration\n  S x(int());       // function declaration\n  S y((int(a)));    // object declaration\n  S y((int)a);      // object declaration\n  S z = int(a);     // object declaration\n}\n</code></pre>\n<p id=\"so_38951362_38951441_3\">\u2014 end example ]</p>\n</blockquote>\n<p>So, <code>int(x)</code> will be considered as a declaration (of parameter) rather than a function style cast.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2016-08-15T08:25:44.330", "Score": "2", "CreationDate": "2016-08-15T08:06:58.977", "ParentId": "38951362", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2016-08-15T08:25:44.330"}, "38951362": {"ViewCount": "500", "Body": "<p>I saw a code here at <a href=\"http://www.mycppquiz.com\" rel=\"nofollow\">Cpp Quiz</a> [Question #38]</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo\n{\n  Foo(int d) : x(d) {}\n  int x;\n};\n\nint main() \n{ \n  double x = 3.14;\n\n  Foo f( int(x) );\n\n  std::cout &lt;&lt; f.x &lt;&lt; std::endl;\n\n  return 0;\n} \n</code></pre>\n<p>It is said there that this code is ill formed because <code>Foo f( int(x) );</code> will be treated as a function declaration rather than an object declaration of type <code>Foo</code>. As far as I know, this is an instance of most vexing parse. My question is what is this syntax <strong><em>int(x)</em></strong> in statement <code>Foo f( int(x) );</code> means? So far I only saw function declarations like:</p>\n<ol>\n<li><p><code>Foo f( int );</code> and</p></li>\n<li><p><code>Foo f( int x );</code></p></li>\n</ol>\n<p>Is it same as <code>Foo f( int x );</code>? </p>\n", "AcceptedAnswerId": "38951441", "Title": "Most vexing parse", "CreationDate": "2016-08-15T08:01:00.227", "LastActivityDate": "2016-08-15T08:30:22.517", "CommentCount": "0", "LastEditDate": "2016-08-15T08:30:22.517", "PostTypeId": "1", "Tags": "<c++><most-vexing-parse>", "Id": "38951362", "AnswerCount": "2", "Score": "3", "OwnerUserId": "1859443", "ClosedDate": "2016-08-15T08:07:32.383", "LastEditorUserId": "3309790"}, "38951449": {"Id": "38951449", "PostTypeId": "2", "Body": "<p>The problem is that, for reasons unknown to me, it's valid to wrap parameter names into parenthesis in prototypes. So</p>\n<pre><code>Foo f(int(x));\n</code></pre>\n<p>can be interpreted as</p>\n<pre><code>Foo f(int x);\n</code></pre>\n<p>that is considered as</p>\n<pre><code>Foo f(int);\n</code></pre>\n<p>The real issue is however that C++ authors, also for reasons unknown to me, decided that it was cool to have two different syntax forms for the almost very same semantic (instance initialization).</p>\n<p>This introduces an syntax ambiguity that is \"resolved\" by saying that \"if something can be both a declaration and a definition, then it's a declaration\", triggering the trap.</p>\n<p>Because of that a C++ parser therefore must be able to parse an arbitrarily large number of tokens before being able to decide what is the semantic meaning of the very first of them.</p>\n<p>This apparently wouldn't have been too much of an issue except for compiler writers, but however it means that also who reads C++ code to understand it must be able to do the same, and for we humans this is harder. From that the \"most vexing\".</p>\n", "LastEditorUserId": "320726", "LastActivityDate": "2016-08-15T08:19:42.320", "Score": "4", "CreationDate": "2016-08-15T08:07:24.763", "ParentId": "38951362", "CommentCount": "4", "OwnerUserId": "320726", "LastEditDate": "2016-08-15T08:19:42.320"}});