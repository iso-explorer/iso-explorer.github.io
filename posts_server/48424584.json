post_cb({"bq_ids": {"n4140": {"so_48424584_48433100_0": {"length": 20, "quality": 1.0, "section_id": 569}}, "n3337": {"so_48424584_48433100_0": {"length": 20, "quality": 1.0, "section_id": 560}}, "n4659": {"so_48424584_48433100_0": {"length": 20, "quality": 1.0, "section_id": 592}}}, "48433100": {"Id": "48433100", "PostTypeId": "2", "Body": "<p>In the expression <code>a+b+c+d</code> 6 temporaries will be created and destroyed, this is mandatory (with and without RVO). You can check it <a href=\"https://godbolt.org/g/AUcPfs\" rel=\"nofollow noreferrer\">here</a>.</p>\n<p>Inside <code>operator +</code> definition, in the expression <code>Rational(lhs)+=a</code>, the prvalue <code>Rational(lhs)</code> will be bound to the <em>implied object parameter</em> of <code>operator+=</code> which is authorized according to this very specific rule <a href=\"https://timsong-cpp.github.io/cppwp/over.match.funcs#5.1\" rel=\"nofollow noreferrer\">[over.match.func]/5.1</a> (refered in <a href=\"https://timsong-cpp.github.io/cppwp/expr.ref#4.3\" rel=\"nofollow noreferrer\">[expr.call]/4</a>)</p>\n<blockquote>\n<p id=\"so_48424584_48433100_0\">even if the implicit object parameter is not const-qualified, an rvalue can be bound to the parameter as long as in all other respects the argument can be converted to the type of the implicit object parameter.</p>\n</blockquote>\n<p>Then to bind a prvalue to a reference, temporary materialization must occurs <a href=\"https://timsong-cpp.github.io/cppwp/class.temporary#2.1\" rel=\"nofollow noreferrer\">[class.temporary]/2.1</a></p>\n<blockquote>\n<p id=\"so_48424584_48433100_1\">Temporary objects are materialized [...]:</p>\n<ul>\n<li>when binding a reference to a prvalue</li>\n</ul>\n</blockquote>\n<p>So a temporary is created during the excution of each <code>operator +</code> call.</p>\n<p>Then the expression <code>Rational(lhs)+=a</code> which once is returned can <em>conceptualy</em> seen as <code>Rational(Rational(lhs)+=a)</code> is a prvalue (a <a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.lval#1.2\" rel=\"nofollow noreferrer\">prvalue</a> is an <em>expression whose evaluation initializes an object</em> - phi:an object in power) which is then bound to the first argument of the 2 subsequent calls to <code>operator +</code>. The cited rule [class.temporary]/2.1 applies twice again and will create 2 temporaries:</p>\n<ol>\n<li>One for materializing the result of <code>a+b</code>,</li>\n<li>the other for materializing the result of <code>(a+b)+c</code></li>\n</ol>\n<p>So at this point 4 temporaries have been created. Then, the third call to <code>operator+</code> creates the 5th temporary inside the function body</p>\n<p>Finaly the result of the last call to <code>operator +</code> is a <em>discarded value expression</em>. This last rule of the standard applies [class.temporary]/2.6:</p>\n<blockquote>\n<p id=\"so_48424584_48433100_2\">Temporary objects are materialized [...]:</p>\n<ul>\n<li>when a prvalue appears as a discarded-value expression.</li>\n</ul>\n</blockquote>\n<p>Which produces the 6th temporaries.</p>\n<p>Without RVO the return value is directly materialized, which makes temporary materialization of the return prvalues not necessary anymore. This is why GCC produces the exact same assembly with and without <code>-fno-elide-constructors</code> compiler option.</p>\n<p>In order to avoid temporary materialization, you could define <code>operator +</code>:</p>\n<pre><code>const Rational operator+(Rational lhs, const Rational&amp; rhs)\n{\n    return lhs += rhs;\n}\n</code></pre>\n<p>With such a definition, the prvalue <code>a+b</code> and <code>(a+b)+c</code> would be directly used to initialize to first parameter of <code>operator +</code> which would save you from the materialization of 2 temporaries. See the assembly <a href=\"https://godbolt.org/g/3mVswx\" rel=\"nofollow noreferrer\">here</a>.</p>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2018-01-24T23:27:25.577", "Score": "1", "CreationDate": "2018-01-24T22:58:29.333", "ParentId": "48424584", "CommentCount": "0", "OwnerUserId": "5632316", "LastEditDate": "2018-01-24T23:27:25.577"}, "48425449": {"Id": "48425449", "PostTypeId": "2", "Body": "<p>No variables are created by the compiler. Because variables are those appearing in the source code, and <strong>variables don't exist at execution time</strong>, or in the executable (they might become memory locations, or be \"ignored\").</p>\n<p>Read about the <a href=\"https://en.wikipedia.org/wiki/As-if_rule\" rel=\"nofollow noreferrer\">as-if rule</a>. Compilers are often <a href=\"https://en.wikipedia.org/wiki/Optimizing_compiler\" rel=\"nofollow noreferrer\">optimizing</a>.</p>\n<p>See CppCon 2017 <a href=\"https://youtu.be/bSkpMdDe4g4\" rel=\"nofollow noreferrer\">Matt Godbolt \u201cWhat Has My Compiler Done for Me Lately? Unbolting the Compiler's Lid\u201d talk</a>.</p>\n", "LastActivityDate": "2018-01-24T14:56:39.427", "CommentCount": "0", "CreationDate": "2018-01-24T14:56:39.427", "ParentId": "48424584", "Score": "1", "OwnerUserId": "841108"}, "48424584": {"ViewCount": "131", "Body": "<p>I decided to ask this question after reading items 20 and 22 of the book \"More Effective C++\" by Scott Meyers.</p>\n<p>Let's say you wrote a class to represent rational numbers:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Rational\n{\npublic:\n    Rational(int numerator = 0, int denominator = 1);\n\n    int numerator() const;\n    int denominator() const;\n\n    Rational&amp; operator+=(const Rational&amp; rhs); // Does not create any temporary objects\n    ...\n};\n</code></pre>\n<p>Now let's say that you decided to implement <code>operator+</code> using <code>operator+=</code>:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>const Rational operator+(const Rational&amp; lhs, const Rational&amp; rhs)\n{\n    return Rational(lhs) += rhs;\n}\n</code></pre>\n<p>My question is: if the <em>return value optimization</em> were disabled, how many temporary variables would be created by <code>operator+</code>?</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>Rational result, a, b;\n...\nresult = a + b;\n</code></pre>\n<p>I believe 2 temporaries are created: one when <code>Rational(lhs)</code> is executed inside the body of <code>operator+</code>, and another when the value returned by <code>operator+</code> is created by copying the first temporary.</p>\n<p>My confusion arose when Scott presented this operation:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>Rational result, a, b, c, d;\n...\nresult = a + b + c + d;\n</code></pre>\n<p>And wrote: \"Probably uses 3 temporary objects, one for each call to <code>operator+</code>\". I believe that if the <em>return value optimization</em> were disabled, the operation above would use 6 temporary objects (2 for each call to <code>operator+</code>), while if it were enabled, the operation above would use no temporaries at all. How did Scott arrive at his result? I think the only way to do so would be to partially apply the <em>return value optimization</em>.</p>\n", "AcceptedAnswerId": "48424753", "Title": "How many temporary objects are created when two objects are added together without the return value optimization?", "CreationDate": "2018-01-24T14:15:23.377", "LastActivityDate": "2018-01-24T23:27:25.577", "CommentCount": "15", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-24T15:12:21.840", "LastEditorUserId": "3309790", "Id": "48424584", "Score": "6", "OwnerUserId": "3266738", "Tags": "<c++><operator-keyword><copy-elision><return-value-optimization><effective-c++>", "AnswerCount": "4"}, "48425339": {"Id": "48425339", "PostTypeId": "2", "Body": "<p>Compiler may detect accumulation and apply optimizations but generally shifting and reducing an expression from left to right is somehow tricky as it may be hit by an expression of style a + b * c * d</p>\n<p>It is more cautious to take approach of form: </p>\n<blockquote>\n<p id=\"so_48424584_48425339_0\">a + (b + (c + d))</p>\n</blockquote>\n<p>which will not consume a variable before it might be required by an operator with higher priority. But evaluating it requires temporaries.</p>\n", "LastActivityDate": "2018-01-24T14:52:11.427", "CommentCount": "0", "CreationDate": "2018-01-24T14:52:11.427", "ParentId": "48424584", "Score": "1", "OwnerUserId": "239189"}, "48424753": {"Id": "48424753", "PostTypeId": "2", "Body": "<p>I think you're just considering too much, especially with the details of optimization. </p>\n<p>For <code>result = a + b + c + d;</code>, the author just want to state that 3 temporaries will be created, the 1st one is for the result of <code>a + b</code>, then 2nd one is for the result of <code>temporary#1 + c</code>, the 3rd one is for <code>temporary#2 + d</code> and then it's assigned to <code>result</code>. After that, 3 temporaries are destroyed. All the temporaries are only used as the intermediate results.</p>\n<p>On the other hand, some idioms such like <a href=\"https://stackoverflow.com/a/2598596/3309790\">expression templates</a> could make it possible to get the final result directly with elimination of temporaries.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2018-01-24T15:37:12.077", "Score": "3", "CreationDate": "2018-01-24T14:23:28.267", "ParentId": "48424584", "CommentCount": "2", "OwnerUserId": "3309790", "LastEditDate": "2018-01-24T15:37:12.077"}});