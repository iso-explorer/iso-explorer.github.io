post_cb({"32085371": {"CommentCount": "2", "ViewCount": "73", "PostTypeId": "1", "LastEditorUserId": "5241471", "CreationDate": "2015-08-19T02:00:21.227", "LastActivityDate": "2015-08-20T11:23:20.410", "Title": "Can we say that cout only prints the first address of a variable", "LastEditDate": "2015-08-19T03:11:49.047", "Id": "32085371", "Score": "2", "Body": "<p>Below is a code that clarifies my question:</p>\n<pre><code>int value = 5;\nint value2 = 7;\ncout &lt;&lt; &amp;value &lt;&lt; \"\\n\";\ncout &lt;&lt; &amp;value2 &lt;&lt; \"\\n\";\n</code></pre>\n<p>This prints:</p>\n<pre><code>0\u00d705fee80\n0\u00d705fee84\n</code></pre>\n<p>In my machine, integers are of 4 bytes. So each int is reserving 4 memory addresses. But when cout prints, it prints the very first address reserved by the integer. This is my observation. Am I right or wrong? If I am wrong, please give a little explanation. I am facing a lot of confusions, especially from when arrays came in my C++ life.</p>\n", "Tags": "<c++><memory-address>", "OwnerUserId": "5241471", "AnswerCount": "3"}, "32116931": {"ParentId": "32085371", "CommentCount": "1", "Body": "<p>That's right. No matter the sze of an object the value of it's address is the address of it's first byte. If you had an array of int's you could get the adress of the subsequent elements by using &amp;array[1], &amp;array[2], etc. Wich would give values 4 bytes bigger than the previous in your machine.</p>\n", "OwnerUserId": "4667104", "PostTypeId": "2", "Id": "32116931", "Score": "0", "CreationDate": "2015-08-20T11:23:20.410", "LastActivityDate": "2015-08-20T11:23:20.410"}, "32085434": {"ParentId": "32085371", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>As per ISO C++11, section <code>1.8 The C++ object model</code> (my bold):</p>\n<blockquote>\n<p id=\"so_32085371_32085434_0\">6/ Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the <strong><em>first</em></strong> byte it occupies.</p>\n</blockquote>\n<p>So you're correct, it will give you the address of the first byte. If you're concerned about a possible disconnect between a <em>pointer</em> to an object and its <em>address,</em> <code>5.3.1 Unary operators</code> shows the connection between the two terms.</p>\n<hr>\n<p>In terms of possible confusion with arrays, it may be best to show an example. Let's say you have:</p>\n<pre><code>int arr[3];\n</code></pre>\n<p>In your four-byte integer implementation, this could be stored as:</p>\n<pre><code>0x0000: | byte 0.0 | byte 0.1 | byte 0.2 | byte 0.3 |\n0x0004: | byte 1.0 | byte 1.1 | byte 1.2 | byte 1.3 |\n0x0008: | byte 2.0 | byte 2.1 | byte 2.2 | byte 2.3 |\n0x000c:\n</code></pre>\n<p>Here, both <code>&amp;arr</code> and <code>&amp;arr[0]</code> would give you <code>0x0000</code> since that's the first byte where both the entire array and the first element of that array is stored.</p>\n<p>However, <code>&amp;arr[2]</code> would actually give you <code>0x0008</code>, since the object in question here is the <em>third</em> element of the array.</p>\n</hr>", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2015-08-19T02:29:08.233", "Id": "32085434", "Score": "1", "CreationDate": "2015-08-19T02:09:09.320", "LastActivityDate": "2015-08-19T02:29:08.233"}, "bq_ids": {"n4140": {"so_32085371_32085434_0": {"section_id": 5795, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_32085371_32085434_0": {"section_id": 5568, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_32085371_32085434_0": {"section_id": 7254, "quality": 0.9285714285714286, "length": 13}}}, "32085388": {"ParentId": "32085371", "CommentCount": "1", "Body": "<p>You are correct. The address points to the beginning of the space occupied by the value.</p>\n", "OwnerUserId": "3908710", "PostTypeId": "2", "Id": "32085388", "Score": "2", "CreationDate": "2015-08-19T02:03:09.830", "LastActivityDate": "2015-08-19T02:03:09.830"}});