post_cb({"2594151": {"ViewCount": "2703", "Body": "<p>I'm confused about the errors generated by the <a href=\"http://codepad.org/dGA5KLYs\" rel=\"nofollow noreferrer\">following code</a>.\nIn Derived::doStuff, I can access Base::output directly by calling it.</p>\n<p>Why can't I create a pointer to <code>output()</code> in the same context that I can call <code>output()</code>?</p>\n<p>(I thought protected / private governed whether you could use a name in a specific context, but apparently that is incomplete?)  </p>\n<p>Is my fix of writing <code>callback(this, &amp;Derived::output);</code> instead of <code>callback(this, Base::output)</code> the correct solution?</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout; using std::endl;\n\ntemplate &lt;typename T, typename U&gt;\nvoid callback(T obj, U func)\n{\n  ((obj)-&gt;*(func))();\n}\n\nclass Base\n{\nprotected:\n  void output() { cout &lt;&lt; \"Base::output\" &lt;&lt; endl; }\n};\n\nclass Derived : public Base\n{\npublic:\n  void doStuff()\n  {\n// call it directly:\n    output();\n    Base::output();\n\n// create a pointer to it:\n//    void (Base::*basePointer)() = &amp;Base::output;\n// error: 'void Base::output()' is protected within this context\n    void (Derived::*derivedPointer)() = &amp;Derived::output;\n\n// call a function passing the pointer:\n//    callback(this, &amp;Base::output);\n// error: 'void Base::output()' is protected within this context\n    callback(this, &amp;Derived::output);\n  }\n};\n\nint main()\n{\n  Derived d;\n  d.doStuff();\n}\n</code></pre>\n<p>Edit: I'd love to know where this is in the stardard, but mostly I'm just trying to wrap my head around the concept.  I think my problem is that <code>callback</code> doesn't have access to protected members of <code>Derived</code>, but it is able to call <code>Derived::output</code> if you pass it a pointer.  How is a protected member of <code>Derived</code> that comes from <code>Derived</code> different from a protected member of <code>Derived</code> that comes from <code>Base</code>?</p>\n", "AcceptedAnswerId": "2595268", "Title": "error: 'void Base::output()' is protected within this context", "CreationDate": "2010-04-07T16:28:35.083", "Id": "2594151", "CommentCount": "1", "LastEditDate": "2010-04-07T17:01:30.633", "PostTypeId": "1", "LastEditorUserId": "102", "LastActivityDate": "2010-04-07T19:31:21.303", "Score": "3", "OwnerUserId": "102", "Tags": "<c++><access-modifiers>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_2594151_2595268_0": {"length": 56, "quality": 0.9491525423728814, "section_id": 6695}}, "n3337": {"so_2594151_2595268_0": {"length": 56, "quality": 0.9491525423728814, "section_id": 6450}}, "n4659": {"so_2594151_2595268_0": {"length": 56, "quality": 0.9491525423728814, "section_id": 8170}}}, "2595268": {"Id": "2595268", "PostTypeId": "2", "Body": "<p>In short, it's \"because the standard says so.\" Why? I don't know, I've emailed a couple of the standards guys, but haven't received a response, yet.</p>\n<p>Specifically, 11.5.1 (from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf\" rel=\"nofollow noreferrer\">C++0x FCD</a>):</p>\n<blockquote>\n<p id=\"so_2594151_2595268_0\">An additional access check beyond\n  those described earlier in Clause 11\n  is applied when a non-static data\n  member or non-static member function\n  is a protected member of its naming\n  class (11.2)114 As described earlier,\n  access to a protected member is\n  granted because the reference occurs\n  in a friend or member of some class C.\n  If the access is to form a pointer to\n  member (5.3.1), the\n  nested-name-specifier shall denote C\n  or a class derived from C. All other\n  accesses involve a (possibly implicit)\n  object expression (5.2.5). In this\n  case, the class of the object\n  expression shall be C or a class\n  derived from C.</p>\n</blockquote>\n<p><strong>Edit:</strong></p>\n<p>Also, you'll see that you change the code to the following, according to what the standard specifies, it will compile (and run) cleanly:</p>\n<pre><code>void (Base::*derivedPointer)() = &amp;Derived::output;\n</code></pre>\n", "LastEditorUserId": "311314", "LastActivityDate": "2010-04-07T19:31:21.303", "Score": "2", "CreationDate": "2010-04-07T19:26:01.400", "ParentId": "2594151", "CommentCount": "0", "OwnerUserId": "311314", "LastEditDate": "2010-04-07T19:31:21.303"}, "2594182": {"Id": "2594182", "PostTypeId": "2", "Body": "<p>Edit: I'm not sure if this is a \"Where is this in the standard?\" question or a \"Why is it designed that way?\" question, this answers the latter (I don't have a copy of the standard itself to play with)</p>\n<p>I believe this is because a function with protected or friend access to <code>base</code> would be able to circumvent access protection by passing the function pointer to methods which should not have access to <code>base</code>'s private members.</p>\n<p>In this example, <code>callback</code> does not have access to <code>base</code>, and therefore should not be able to call one of it's private functions.</p>\n", "LastActivityDate": "2010-04-07T16:32:06.497", "CommentCount": "1", "CreationDate": "2010-04-07T16:32:06.497", "ParentId": "2594151", "Score": "1", "OwnerUserId": "82320"}});