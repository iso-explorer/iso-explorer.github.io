post_cb({"bq_ids": {"n4140": {"so_30745684_30745684_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 6039}, "so_30745684_30746964_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 6039}}, "n4659": {"so_30745684_30745684_0": {"length": 29, "quality": 0.7631578947368421, "section_id": 7538}, "so_30745684_30746964_1": {"length": 18, "quality": 0.6666666666666666, "section_id": 7538}}}, "30746964": {"Id": "30746964", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_30745684_30746964_0\">My question is: in the case where alignment is not satisfied, what are the possible results? </p>\n</blockquote>\n<p>As far as I can tell <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4303.html\" rel=\"nofollow\">N4303: Pointer safety and placement new</a> partially answers this question, although somewhat indirectly. This paper refers to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3539.html#1412\" rel=\"nofollow\">CWG issue 1412: Problems in specifying pointer conversions </a> which brought about the changes to <em>[expr.static.cast]/13</em> that you reference, specifically adding:</p>\n<blockquote>\n<p id=\"so_30745684_30746964_1\">[...]If the original pointer value represents the address A of a byte in memory and A satisfies the alignment requirement of T, then the resulting pointer value represents the same address as the original pointer value, that is, A. The result of any other such pointer conversion is unspecified.[...]</p>\n</blockquote>\n<p>In reference to this change <code>N4303</code> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_30745684_30746964_2\">Prior to the adoption of the resolution for DR 1412 [CWG1412], the value of bp is unspecified at the point of its initialization and its subsequent passing to operator new via the new-expression. <strong>Said pointer may be null, insufficiently aligned or otherwise dangerous to use.</strong></p>\n</blockquote>\n<p>So an unspecified conversion can results in:</p>\n<ul>\n<li>A null pointer</li>\n<li>An insufficiently aligned pointer</li>\n<li>A pointer that is dangerous to use</li>\n</ul>\n", "Score": "3", "LastActivityDate": "2015-06-10T04:11:17.657", "CreationDate": "2015-06-10T04:11:17.657", "ParentId": "30745684", "CommentCount": "5", "OwnerUserId": "1708801"}, "30745684": {"ViewCount": "143", "FavoriteCount": "2", "Title": "How does an unspecified pointer conversion behave in C++14?", "CreationDate": "2015-06-10T01:41:41.257", "LastActivityDate": "2015-06-10T04:11:17.657", "CommentCount": "5", "Body": "<p>The result of some pointer casts are described as unspecified. For example, [expr.static.cast]/13:</p>\n<blockquote>\n<p id=\"so_30745684_30745684_0\">A prvalue of type \u201cpointer to cv1 void\u201d can be converted to a prvalue of type \u201cpointer to cv2 T,\u201d [...] If the original pointer value represents the address A of a byte in memory and A satisfies the alignment requirement of T, then the resulting pointer value represents the same address as the original pointer value, that is, A. <strong>The result of any other such pointer conversion is unspecified</strong>.</p>\n</blockquote>\n<p>My question is: in the case where alignment is <em>not</em> satisfied, what are the possible results? </p>\n<p>For example, are the following results permitted?</p>\n<ul>\n<li>a null pointer</li>\n<li>an invalid pointer value  (i.e. pointer which does not point to allocated storage of size <code>T</code>)</li>\n<li>a valid pointer to a <code>T</code> in a completely separate part of memory</li>\n</ul>\n<hr>\n<p>Code sample for reference:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main(int argc, char **argv)\n{\n    int *b = (int *)\"Hello, world\";   // (1)\n\n    *b = -1;                           // (2)\n    std::cout &lt;&lt; argc &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Line <code>(1)</code> triggers my above quote from [expr.static.cast]/13 because it is a <code>reinterpret_cast</code> which is covered by [expr.reinterpret.cast]/7 which defines the conversion in terms of <code>static_cast</code>ing through <code>void *</code>.</p>\n<p>If the unspecified result may be an invalid pointer value, then line <code>(1)</code> may cause a hardware trap. (Reference: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4430.html\">N4430</a> which clarifies similar wording that was in C++14 and C++11).</p>\n<p><em>Corollary question:</em> is there any case in which line <code>1</code> would cause undefined behaviour? (I don't think so at this stage; since C++14 invalid pointer value reading is implementation-defined or causes a hardware trap).</p>\n<hr>\n<p>Also interesting is that line <code>(2)</code> would in most cases be undefined behaviour due to strict aliasing violation (and perhaps other reasons too), however if the unspecified result may be <code>&amp;argc</code> then this program could output <code>-1</code> without triggering undefined behaviour!</p>\n</hr></hr>", "PostTypeId": "1", "Id": "30745684", "Score": "6", "OwnerUserId": "1505939", "Tags": "<c++><pointers><language-lawyer><c++14><reinterpret-cast>", "AnswerCount": "1"}});