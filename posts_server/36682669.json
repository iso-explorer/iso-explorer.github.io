post_cb({"bq_ids": {"n4140": {"so_36682669_36699933_0": {"length": 59, "quality": 0.921875, "section_id": 5836}, "so_36682669_36699933_1": {"length": 43, "quality": 0.9148936170212766, "section_id": 5837}}, "n3337": {"so_36682669_36699933_0": {"length": 58, "quality": 0.90625, "section_id": 5606}, "so_36682669_36699933_1": {"length": 43, "quality": 0.9148936170212766, "section_id": 5607}}, "n4659": {"so_36682669_36699933_0": {"length": 59, "quality": 0.921875, "section_id": 7298}, "so_36682669_36699933_1": {"length": 43, "quality": 0.9148936170212766, "section_id": 7299}}}, "36682669": {"ViewCount": "69", "Body": "<p>In C11 and C++11 standard there appear a statement <em>potentially shared memory location</em>. What does this mean? Are all global variables potentially shared in a multithreaded environment?</p>\n", "AcceptedAnswerId": "36699933", "Title": "What is a potentially shared memory location?", "CreationDate": "2016-04-17T21:55:55.190", "Id": "36682669", "CommentCount": "5", "LastEditDate": "2016-04-18T06:01:09.957", "PostTypeId": "1", "LastEditorUserId": "5249858", "LastActivityDate": "2016-04-18T17:44:00.007", "Score": "2", "OwnerUserId": "1784168", "Tags": "<multithreading><c++11><c11>", "AnswerCount": "1"}, "36699933": {"Id": "36699933", "PostTypeId": "2", "Body": "<p>Not very familiar with the C standard. In C++14, the phrase \"potentially shared memory location\" appears twice, in two non-normative notes:</p>\n<blockquote>\n<p id=\"so_36682669_36699933_0\"><strong>[intro.multithread]/25</strong> [ <em>Note:</em> Compiler transformations that introduce assignments to a <strong>potentially shared memory location</strong> that would not be modified by the abstract machine are generally precluded by this standard, since such an assignment might overwrite another assignment by a different thread in cases in which an abstract machine execution would not have encountered a data race. This includes implementations of data member assignment that overwrite adjacent members in separate memory locations. Reordering of atomic loads in cases in which the atomics in question may alias is also generally precluded, since this may violate the coherence rules. \u2014 <em>end note</em> ]</p>\n<p id=\"so_36682669_36699933_1\"><strong>[intro.multithread]/26</strong> [ <em>Note:</em> Transformations that introduce a speculative read of a <strong>potentially shared memory location</strong> may not preserve the semantics of the C++ program as defined in this standard, since they potentially introduce a data race. However, they are typically valid in the context of an optimizing compiler that targets a specific machine with well-defined semantics for data races. They would be invalid for a hypothetical machine that is not tolerant of races or provides hardware race detection. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>From context, it's pretty clear that \"potentially shared memory location\" is supposed to mean \"a memory location for which the optimizer cannot rule out the possibility that other threads may access it, and therefore should proceed on the pessimistic assumption that they might.\" The two notes then discuss the legality of certain optimizations that may or may not be done under such an assumption.</p>\n<p>Re: global variables. Yes, a global variable would generally be accessible to arbitrary threads. It is conceivable, in principle, that a sophisticated optimizer performing whole program optimization might be able to prove that a particular global variable is never accessed concurrently from multiple threads (I'm not aware of any actual compilers currently in existence capable of achieving such a feat, but then I wouldn't call myself a compiler expert by any stretch). Barring that, memory locations occupied by a global variable should be treated by an optimizer as potentially shared.</p>\n", "LastEditorUserId": "1670129", "LastActivityDate": "2016-04-18T17:44:00.007", "Score": "2", "CreationDate": "2016-04-18T16:55:15.223", "ParentId": "36682669", "CommentCount": "0", "OwnerUserId": "1670129", "LastEditDate": "2016-04-18T17:44:00.007"}});