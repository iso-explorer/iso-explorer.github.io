post_cb({"bq_ids": {"n4140": {"so_14191989_14192162_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 121}}, "n3337": {"so_14191989_14192162_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 116}}, "n4659": {"so_14191989_14192162_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 125}}}, "14191989": {"ViewCount": "3674", "Body": "<p>I have a working function template that calls a lambda.</p>\n<p>I would like to generalize this function template to take variadic arguments and forward them perfectly into the lambda, but I am having trouble getting this code to compile.</p>\n<p>I am using gcc 4.7.2.</p>\n<p><strong>UPDATE</strong></p>\n<p>Using R. Martinho Fernandes's suggestion, I looked up the error in bugzilla - <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=41933\">it does look like a bug that's been around for a while</a>.  If anyone knows of a workaround (I'm digging around for one now), please post an answer - ty.</p>\n<p><strong>ERRORS</strong></p>\n<pre><code>junk.cpp: In lambda function:\njunk.cpp:32:68: error: parameter packs not expanded with \u2018...\u2019:\njunk.cpp:32:68: note:         \u2018args\u2019\njunk.cpp: In instantiation of \u2018std::pair&lt;std::basic_string&lt;char&gt;, typename T::Lambda&gt; MP(const string&amp;, M, Args&amp;&amp; ...) [with T = Integer; M = int (Integer::*)()const; Args = {}; typename T::Lambda = std::function&lt;std::function&lt;int()&gt;(const Integer&amp;)&gt;; std::string = std::basic_string&lt;char&gt;]\u2019:\njunk.cpp:47:42:   required from here\njunk.cpp:34:2: error: using invalid field \u2018MP(const string&amp;, M, Args&amp;&amp; ...)::&lt;lambda(const T&amp;)&gt;::__args\u2019\nmake: *** [junk] Error 1\n</code></pre>\n<p><strong>CODE</strong></p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nstruct Integer\n{\n    typedef std::function&lt;int()&gt;                            Function;\n    typedef std::function&lt;Function( Integer const&amp; inst )&gt;  Lambda;\n\n    virtual int getInt() const = 0;\n};\n\nstruct IntImpl : public Integer\n{\n    virtual int getInt() const { return 42; }\n};\n\ntypedef std::function&lt;int()&gt;                               IntFunction;\ntypedef std::function&lt;IntFunction( Integer const&amp; inst )&gt;  IntLambda;\n\n#define WONT_COMPILE\n\ntemplate&lt;typename T,typename M,typename... Args&gt;\nstd::pair&lt;std::string,typename T::Lambda&gt;\nMP( std::string const&amp; str, M method, Args&amp;&amp;... args )\n{\n#ifdef WONT_COMPILE \n    return std::make_pair( str, \n        [=]( T const&amp; inst ) \n        {\n            // COMPILE ERROR (Line 32) on next line\n            return std::bind( method, std::cref( inst ), std::forward&lt;Args&gt;(args)...);\n        } \n    );\n#else\n    return std::make_pair( str, \n        [method]( T const&amp; inst ) \n        {\n            return std::bind( method, std::cref( inst ));\n        } \n    );\n#endif\n}\n\nstd::map&lt;std::string,IntLambda&gt; const g_intTbl =\n{\n    MP&lt;Integer&gt;( \"getInt\", &amp;Integer::getInt )\n};\n\nint\nmain( int argv, char* argc[] )\n{\n    IntImpl x;\n    std::cerr &lt;&lt; g_intTbl.find(\"getInt\")-&gt;second( x )() &lt;&lt; std::endl;\n}\n</code></pre>\n", "Title": "How do I use variadic perfect forwarding into a lambda?", "CreationDate": "2013-01-07T08:00:50.150", "LastActivityDate": "2013-07-16T04:12:52.030", "CommentCount": "8", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2013-01-07T08:47:50.487", "LastEditorUserId": "975129", "Id": "14191989", "Score": "17", "OwnerUserId": "975129", "Tags": "<c++><binding><c++11><lambda><variadic-templates>", "AnswerCount": "2"}, "14192162": {"Id": "14192162", "PostTypeId": "2", "Body": "<p>This appears to be a fault of the compiler (please report it if it isn't already). The standard says:</p>\n<blockquote>\n<p id=\"so_14191989_14192162_0\">A <em>pack expansion</em> consists of a pattern and an ellipsis, the\n  instantiation of which produces zero or more instantiations of the\n  pattern in a list (described below). The form of the pattern depends\n  on the context in which the expansion occurs. Pack expansions can\n  occur in the following contexts:</p>\n<p id=\"so_14191989_14192162_1\">\u2014 [...]<br>\n  \u2014 In a <em>capture-list</em> (5.1.2); the pattern is a capture.<br>\n  \u2014 [...]  </br></br></p>\n</blockquote>\n<p>This makes your code correct.</p>\n<p>Until you get a compiler that can handle this, you will have capture everything as a workaround, with <code>[=]</code>.</p>\n", "LastActivityDate": "2013-01-07T08:19:01.953", "CommentCount": "2", "CreationDate": "2013-01-07T08:19:01.953", "ParentId": "14191989", "Score": "7", "OwnerUserId": "46642"}, "17667880": {"Id": "17667880", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_14191989_17667880_0\">If anyone knows of a workaround (I'm digging around for one now), please post an answer</p>\n</blockquote>\n<p>I ran into the exact same problem and found a workaround. It's kind of a late answer, hope you found a solution in the meantime, but here it is anyway (it could at the very least be useful to others).</p>\n<p>The idea is to change the lambda's parameters so that it also accepts the same variadic arguments as the outer function (eg. <code>[](int) {}</code> becomes <code>[](int, Args&amp;&amp;... args) {}</code>) and <code>bind</code> the lambda to the outer function's variadic arguments. Once this is done, no more problem forwarding the variadic arguments inside the lambda.</p>\n<p>To sum it up:</p>\n<pre><code>template&lt;typename... Args&gt;\nstd::function&lt;void (int)&gt; foo(Args&amp;&amp;... args) {\n    return [&amp;](int bar) {\n                  // COMPILER BUG: doesn't work with GCC 4.7 despite the capture\n                  doSomething(bar, std::forward&lt;Args&gt;(args)...);\n              };\n}\n\ntemplate&lt;typename... Args&gt;\nstd::function&lt;void (int)&gt; foo(Args&amp;&amp;... args) {\n    return std::bind([](int bar, Args&amp;&amp;... args) {\n                            // now this works with GCC 4.7\n                            doSomething(bar, std::forward&lt;Args&gt;(args)...);\n                       },\n                     std::placeholders::_1, std::forward&lt;Args&gt;(args)...);\n}\n</code></pre>\n<p>Sure this is an ugly hack, but at least you can still get the intended functionality even when you're stuck with a buggy compiler.</p>\n", "LastActivityDate": "2013-07-16T04:12:52.030", "CommentCount": "5", "CreationDate": "2013-07-16T04:12:52.030", "ParentId": "14191989", "Score": "11", "OwnerUserId": "2070725"}});