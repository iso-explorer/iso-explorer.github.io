post_cb({"bq_ids": {"n4140": {"so_20513692_20513752_0": {"length": 4, "quality": 1.0, "section_id": 112}}, "n3337": {"so_20513692_20513752_0": {"length": 4, "quality": 1.0, "section_id": 107}}, "n4659": {"so_20513692_20513752_0": {"length": 4, "quality": 1.0, "section_id": 116}}}, "20514133": {"Id": "20514133", "PostTypeId": "2", "Body": "<p>Let's consider what would happen if this was allowed.</p>\n<p>The definition of the class <code>TemplateChild</code> may be present in multiple translation units (source files).  In each of these translation units, the compiler needs to be able to generate the virtual function table (vtable) for <code>TemplateChild</code>, to ensure that the vtable is present for the linker to consume.</p>\n<p>The vtable says, \"for an object whose dynamic type is <code>TemplateChild</code>, these are the final overriders for all virtual functions.\"  For example, for <code>RegularChild</code>, the vtable maps the two overrides <code>RegularChild::method(int)</code> and <code>RegularChild::method(float)</code>.</p>\n<p>Your explicit instantiations for <code>TemplateChild::method</code> will only appear in one translation unit, and the compiler only knows that they exist in that one translation unit.  When compiling other translation units, it doesn't know that the explicit instantiations exist.  This means that you'll end up with two <em>different</em> vtables for the class:</p>\n<p>In the translation unit where the explicit instantiations are present, you'll have a vtable that maps the two overrides <code>TemplateChild::method&lt;int&gt;(int)</code> and <code>TemplateChild::method&lt;float&gt;(float)</code>.  This is okay.</p>\n<p>But in the translation units where the explicit instantiations are not present, you'll have a vtable that maps to the base class virtual functions (which in your example are pure virtual; let's just pretend there are base class definitions).</p>\n<p>You might even have more than two different vtables, e.g. if the explicit instantiations for <code>int</code> and <code>float</code> each appear in their own translation unit.</p>\n<p>In any case, now we have multiple <em>different</em> definitions for the same thing, which is a major problem.  At best the linker might pick one and discard the rest.  Even if there was some way to tell the linker to pick the one with the explicit instantiations, you'll still have the problem that the compiler may devirtualize virtual function calls, but to do that, the compiler needs to know what the final overriders are (in effect, it needs to know what's in the vtable).</p>\n<p>So, there are major issues that would arise if this was allowed, and given the C++ compilation model, I don't think these issues are resolvable (at least not without major changes to the way C++ compilation is done).</p>\n", "LastEditorUserId": "151292", "LastActivityDate": "2013-12-11T08:45:09.787", "Score": "7", "CreationDate": "2013-12-11T08:30:09.240", "ParentId": "20513692", "CommentCount": "4", "OwnerUserId": "151292", "LastEditDate": "2013-12-11T08:45:09.787"}, "20513692": {"ViewCount": "741", "Body": "<p>Why does TemplateChild in the following code not work? I know that virtual methods cannot be templates, but why can explicitly-instantiated template methods not override virtual methods?</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass VirtBase\n{\npublic:\n    VirtBase() {};\n    virtual ~VirtBase() {};\n\n    virtual void method( int input ) = 0;\n    virtual void method( float input ) = 0;\n};\n\nclass RegularChild : public VirtBase\n{\npublic:\n    RegularChild() {};\n    ~RegularChild() {};\n\n    void method( int input ) {\n        std::cout &lt;&lt; \"R\" &lt;&lt; input &lt;&lt; std::endl;\n    }\n    void method( float input ) {\n        std::cout &lt;&lt; \"R\" &lt;&lt; input &lt;&lt; std::endl;\n    }\n};\n\nclass TemplateBounceChild : public VirtBase\n{\npublic:\n    TemplateBounceChild() {};\n    ~TemplateBounceChild() {};\n\n    void method( int input ) {\n        this-&gt;method&lt;&gt;( input );\n    }\n    void method( float input ) {\n        this-&gt;method&lt;&gt;( input );\n    }\n    template&lt; typename INPUT &gt;\n    void method( INPUT input ) {\n        std::cout &lt;&lt; \"B\" &lt;&lt; input &lt;&lt; std::endl;\n    };\n};\n\nclass TemplateChild : public VirtBase\n{\npublic:\n    TemplateChild() {};\n    ~TemplateChild() {};\n\n    template&lt; typename INPUT &gt;\n    void method( INPUT input ) {\n        std::cout &lt;&lt; \"T\" &lt;&lt; input &lt;&lt; std::endl;\n    };\n};\n\ntemplate void TemplateChild::method&lt; int &gt;( int );\ntemplate void TemplateChild::method&lt; float &gt;( float );\n\nint main( int, char**, char** )\n{\n    int i = 1;\n    float f = 2.5f;\n\n    VirtBase * v;\n\n    RegularChild r;\n    v = &amp;r;\n\n    r.method( i );\n    r.method( f );\n    v-&gt;method( i );\n    v-&gt;method( f );\n\n    TemplateChild c; // TemplateBounceChild here works correctly.\n    v = &amp;c;\n\n    c.method( i );\n    c.method( f );\n    v-&gt;method( i );\n    v-&gt;method( f );\n\n    return 0;\n}\n</code></pre>\n<p>gcc 4.4.7 (CentOS 6) and Clang 3.3 (trunk 177401) agree that the two pure virtual methods are not implemented in TemplateChild, although at this point in the compilation TemplateChild explicitly has a method named 'method' that takes a float, and a method named 'method' that takes an int.</p>\n<p>Is it just because the explicit instantiation has come too late for TemplateChild to be considered non-pure virtual?</p>\n<p>Edit: C++11 14.5.2 [temp.mem]/4 says that this isn't allowed for specialisations. But I can't find anything so clear in the [temp.explicit] section for the same thing.</p>\n<pre><code>4 A specialization of a member function template does not override a virtual function from a base class.\n</code></pre>\n<p>I also edited TemplateBounceChild to match the example used in that section of the C++11 draft.</p>\n", "AcceptedAnswerId": "20513752", "Title": "Why can't C++ explicitly-instantiated template methods override virtual methods?", "CreationDate": "2013-12-11T08:06:13.423", "Id": "20513692", "CommentCount": "0", "LastEditDate": "2013-12-11T10:23:21.487", "PostTypeId": "1", "LastEditorUserId": "166389", "LastActivityDate": "2013-12-11T10:23:21.487", "Score": "6", "OwnerUserId": "166389", "Tags": "<c++><templates><virtual-inheritance>", "AnswerCount": "3"}, "20514864": {"Id": "20514864", "PostTypeId": "2", "Body": "<p>An explicit instantiation does nothing more than cause the template to be instantiated. For a function template, this is the same effect as using it. There is no reason to expect anything to work differently whether a member function is explicitly instantiated or used regularly.</p>\n<p>The template specialization cannot override the non-template function because they do not have the same name. The specialization is named by the template-id including template arguments. Ignoring the template arguments in the signature, several specializations with different arguments could have the same signature.</p>\n<p>If the language wanted to determine that a specialization should be a virtual override because the signature coincides with a base class virtual member, it would have to determine that all the template arguments could have been deduced if the function were called with some arguments matching some virtual function. It wouldn't be able to rely on inspecting the way you actually called the function (which looks like a virtual dispatch because of deduction), because you could call it in a more obscure way using template arguments, or never call it at all (which is the problem you're trying to work around using explicit instantiation).</p>\n<p>The combination of N base class <code>virtual</code> functions and M derived class templates potentially matching them would have O(N*M) complexity. The special feature would scale poorly in this case.</p>\n<p>So, it's better just to be explicit with a regular <code>virtual</code> function declaration per actual override. (It would perhaps be nice to be able to alias such functions together so their addresses would compare equal, though; although pointers to virtual member functions work differently, identical functions could be a micro-optimization.)</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2013-12-11T09:12:11.393", "Score": "4", "CreationDate": "2013-12-11T09:07:05.870", "ParentId": "20513692", "CommentCount": "5", "OwnerUserId": "153285", "LastEditDate": "2013-12-11T09:12:11.393"}, "20513752": {"Id": "20513752", "PostTypeId": "2", "Body": "<p>Because the Standard Says So. See C++11 14.5.2 [temp.mem]/3:</p>\n<blockquote>\n<p id=\"so_20513692_20513752_0\">A member function template shall not be virtual.</p>\n</blockquote>\n", "LastActivityDate": "2013-12-11T08:09:10.543", "CommentCount": "6", "CreationDate": "2013-12-11T08:09:10.543", "ParentId": "20513692", "Score": "3", "OwnerUserId": "82320"}});