post_cb({"11313437": {"ViewCount": "255", "Body": "<p>Just when I thought I understand the multi-pass move construction of iostreams in C++11 (thanks to <a href=\"https://stackoverflow.com/a/8156356/273767\">https://stackoverflow.com/a/8156356/273767</a> for the intro), I ran into this:</p>\n<p><strong>\u00a727.7.2.5.1[iostream.cons]/3</strong></p>\n<blockquote>\n<p id=\"so_11313437_11313437_0\"><code>basic_iostream(basic_iostream&amp;&amp; rhs);</code></p>\n<p id=\"so_11313437_11313437_1\"><code>3</code> Effects: Move constructs from the rvalue rhs by constructing the <code>basic_istream</code> base class with <code>move(rhs)</code>.</p>\n</blockquote>\n<p>So what happens to the other base, <code>basic_ostream</code>?</p>\n<p>I see libc++ gave <code>std::basic_ostream</code> a <a href=\"http://llvm.org/svn/llvm-project/libcxx/trunk/include/ostream\" rel=\"nofollow noreferrer\">protected default constructor</a>, which is called here (and also, in contradiction to the letter of \u00a727.7.2.5.1/1, in the normal <a href=\"http://llvm.org/svn/llvm-project/libcxx/trunk/include/istream\" rel=\"nofollow noreferrer\">constructor of basic_iostream</a>), and does nothing. Is that how it's supposed to be?</p>\n", "AcceptedAnswerId": "11314590", "Title": "What happens to the basic_ostream base when basic_iostream is moved?", "CreationDate": "2012-07-03T14:46:25.110", "Id": "11313437", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:06:24.277", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-03T16:26:27.330", "Score": "3", "OwnerUserId": "273767", "Tags": "<c++><c++11><iostream>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_11313437_11313437_1": {"length": 9, "quality": 0.9, "section_id": 2257}}, "n3337": {"so_11313437_11313437_1": {"length": 9, "quality": 0.9, "section_id": 2245}}, "n4659": {"so_11313437_11313437_1": {"length": 9, "quality": 0.9, "section_id": 2532}}}, "11314590": {"Id": "11314590", "PostTypeId": "2", "Body": "<p>As you point out, the spec for:</p>\n<pre><code>explicit basic_iostream(basic_streambuf&lt;charT,traits&gt;* sb);\n</code></pre>\n<p>initializes both bases.  I've never been ok with that:</p>\n<p><a href=\"http://cplusplus.github.com/LWG/lwg-closed.html#135\">http://cplusplus.github.com/LWG/lwg-closed.html#135</a></p>\n<p>as it causes the <strong>single</strong> <code>basic_ios::init()</code> function to be called twice on the same virtual base object.  The committee ruled that this double initialization was harmless.  I disagreed strongly enough that I refused to implement the specification in regards to this detail.  But the spec says to double initialize the virtual base class.</p>\n<p>When it came time to specify the <code>basic_iostream</code> move constructor, I was in the driver's seat.  And so I specified it how I thought best (to not doubly initialize <code>basic_ios</code>).  That decision has yet to be challenged, but probably will be eventually.</p>\n<p>Note that in order to avoid the double initialization, the <code>basic_ostream</code> default constructor has to be carefully crafted to do absolutely nothing.  And by nothing I really mean nothing.  No zero initialization:</p>\n<pre><code>protected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ostream() {}  // extension, intentially does not initialize\n</code></pre>\n<p>Fortunately the base classes of <code>basic_ostream</code> are actually specified to do nothing in their default constructors.  So everything just works:  <code>basic_ostream</code> default constructs and doesn't touch memory.  Then derived clients call <code>init(basic_streambuf&lt;char_type, traits_type&gt;*)</code> <em>exactly once</em> to do the actual construction of <code>basic_ios</code>/<code>ios_base</code>.</p>\n<p>It's a really messy design.  By refusing to double initialize the virtual base, I feel libc++ makes the design a little less messy, and a little more reliable.  This is standard behavior for the move constructor, and not standard behavior for the constructor taking a <code>streambuf*</code>.</p>\n", "LastActivityDate": "2012-07-03T15:47:58.517", "CommentCount": "1", "CreationDate": "2012-07-03T15:47:58.517", "ParentId": "11313437", "Score": "7", "OwnerUserId": "576911"}, "11315205": {"Id": "11315205", "PostTypeId": "2", "Body": "<p>I agree with Howard that this is kind of a wart on the standard spec.</p>\n<p>In my implementation, I chose to use a more specific call to a constructor extension</p>\n<pre><code>basic_iostream(basic_iostream&amp;&amp; _Other)\n   : std::basic_istream&lt;char_type, traits_type&gt;(std::move(_Other)),\n     std::basic_ostream&lt;char_type, traits_type&gt;(basic_ostream::_NoInit)\n{ }\n</code></pre>\n<p>using a special <code>protected</code> constructor in the base class</p>\n<pre><code>protected:    \n    // special interface for basic_iostream\n\n    enum __no_init_t { _NoInit };\n\n    basic_ostream(__no_init_t)\n    { }\n</code></pre>\n<p>The net effect is the same.</p>\n", "LastActivityDate": "2012-07-03T16:26:27.330", "CommentCount": "1", "CreationDate": "2012-07-03T16:26:27.330", "ParentId": "11313437", "Score": "3", "OwnerUserId": "597607"}});