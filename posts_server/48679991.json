post_cb({"bq_ids": {"n4140": {"so_48679991_48680579_5": {"length": 8, "quality": 1.0, "section_id": 7043}, "so_48679991_48680579_0": {"length": 6, "quality": 1.0, "section_id": 7043}, "so_48679991_48680579_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 7043}, "so_48679991_48680579_2": {"length": 6, "quality": 1.0, "section_id": 7043}}, "n3337": {"so_48679991_48680579_5": {"length": 8, "quality": 1.0, "section_id": 6788}, "so_48679991_48680579_0": {"length": 6, "quality": 1.0, "section_id": 6788}, "so_48679991_48680579_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 6788}, "so_48679991_48680579_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 6788}}, "n4659": {"so_48679991_48680579_5": {"length": 8, "quality": 1.0, "section_id": 8540}, "so_48679991_48680579_0": {"length": 6, "quality": 1.0, "section_id": 8540}, "so_48679991_48680579_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 8540}, "so_48679991_48680579_6": {"length": 17, "quality": 0.7083333333333334, "section_id": 180}, "so_48679991_48680579_2": {"length": 6, "quality": 1.0, "section_id": 8540}}}, "48680579": {"Id": "48680579", "PostTypeId": "2", "Body": "<p>I don't see any reason to believe that the <em>program in question</em> is ill-formed. Simply having something in the code depend on the completeness of a type, then having something else later on depend on the completeness of the same type where the type has since been completed, does not violate the standard.</p>\n<p>A problem arises if we have something like</p>\n<pre><code>inline Something something;  // external linkage\ninline void foo() {\n    auto&amp; [one] = something;\n}\n</code></pre>\n<p>defined in multiple translation units, where, in some of those, <code>std::tuple_size&lt;Something&gt;</code> is already complete at the point where <code>foo</code> is defined, and in others, it isn't. This seems like it should definitely violate the ODR, since the entity <code>one</code> receives different types in different copies of <code>foo</code>, however, I can't actually find a place in the standard that says so. The criteria for the multiple definitions to be merged into one are:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_48679991_48680579_0\">each definition of D shall consist of the same sequence of tokens; and</p></li>\n<li><p id=\"so_48679991_48680579_1\">in each definition of D, corresponding names, looked up according to 6.4, shall refer to an entity defined\n  within the definition of D, or shall refer to the same entity, after overload resolution (16.3) and after\n  matching of partial template specialization (17.8.3), except that a name can refer to</p>\n<ul>\n<li><p id=\"so_48679991_48680579_2\">a non-volatile const object with internal or no linkage if the object</p>\n<ul>\n<li>has the same literal type in all definitions of D,</li>\n<li>is initialized with a constant expression (8.20),</li>\n<li>is not odr-used in any definition of D, and</li>\n<li>has the same value in all definitions of D,</li>\n</ul>\n<p id=\"so_48679991_48680579_3\">or</p></li>\n<li>a reference with internal or no linkage initialized with a constant expression such that the reference\n  refers to the same entity in all definitions of D;</li>\n</ul>\n<p id=\"so_48679991_48680579_4\">and</p></li>\n<li><p id=\"so_48679991_48680579_5\">in each definition of D, corresponding entities shall have the same language linkage; and</p></li>\n<li>in each definition of D, the overloaded operators referred to, the implicit calls to conversion functions,\n  constructors, operator new functions and operator delete functions, shall refer to the same function, or\n  to a function defined within the definition of D; and</li>\n<li>in each definition of D, a default argument used by an (implicit or explicit) function call is treated as if\n  its token sequence were present in the definition of D; that is, the default argument is subject to the\n  requirements described in this paragraph (and, if the default argument has subexpressions with default\n  arguments, this requirement applies recursively) 28 ; and</li>\n<li>if D is a class with an implicitly-declared constructor (15.1), it is as if the constructor was implicitly\n  defined in every translation unit where it is odr-used, and the implicit definition in every translation\n  unit shall call the same constructor for a subobject of D.</li>\n</ul>\n</blockquote>\n<p>If there's a rule here that makes my code ill-formed, I don't know which one it is. Perhaps the standard needs to be amended, because it cannot have been intended that this was allowed.</p>\n<p>Another way to make the program ill-formed NDR involves the use of a template:</p>\n<pre><code>template &lt;int unused&gt;\nvoid foo() {\n    auto&amp; [one] = something;\n}\n// define tuple_element and tuple_size\nfoo&lt;42&gt;(); // instantiate foo\n</code></pre>\n<p>This would run afoul of [temp.res]/8.4, according to which</p>\n<blockquote>\n<p id=\"so_48679991_48680579_6\">The program is ill-formed, no diagnostic required, if ... the interpretation of [a construct that does not depend on a template parameter] in [the hypothetical instantiation of a template immediately following its definition] is different from the interpretation of the corresponding construct in any actual instantiation of the template</p>\n</blockquote>\n", "LastEditorUserId": "481267", "LastActivityDate": "2018-02-08T09:11:00.860", "Score": "4", "CreationDate": "2018-02-08T08:12:17.857", "ParentId": "48679991", "CommentCount": "2", "OwnerUserId": "481267", "LastEditDate": "2018-02-08T09:11:00.860"}, "48679991": {"ViewCount": "142", "Body": "<p>The structured bindings feature says that it goes with the tuple like decomposition if the <code>tuple_size</code> template is a complete type.  What happens when <code>std::tuple_size</code> is a complete type for the given type at one point in the program and is not complete at another point? </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n\nusing std::cout;\nusing std::endl;\n\nclass Something {\npublic:\n    template &lt;std::size_t Index&gt;\n    auto get() {\n        cout &lt;&lt; \"Using member get\" &lt;&lt; endl;\n        return std::get&lt;Index&gt;(this-&gt;a);\n    }\n\n    std::tuple&lt;int&gt; a{1};\n};\n\nnamespace {\n    auto something = Something{};\n}\n\nvoid foo() {\n    auto&amp; [one] = something;\n    std::get&lt;0&gt;(one)++;\n    cout &lt;&lt; std::get&lt;0&gt;(one) &lt;&lt; endl;\n}\n\nnamespace std {\ntemplate &lt;&gt;\nclass tuple_size&lt;Something&gt; : public std::integral_constant&lt;std::size_t, 1&gt; {};\ntemplate &lt;&gt;\nclass tuple_element&lt;0, Something&gt; {\npublic:\n    using type = int;\n};\n}\n\nint main() {\n    foo();\n    auto&amp; [one] = something;\n    cout &lt;&lt; one &lt;&lt; endl;\n}\n</code></pre>\n<p>(Reproduced here <a href=\"https://wandbox.org/permlink/4xJUEpTAyUxrizyU\" rel=\"nofollow noreferrer\">https://wandbox.org/permlink/4xJUEpTAyUxrizyU</a>)</p>\n<p>In the above program the type <code>Something</code> is decomposed via the public data members at one point in the program and falls back to the tuple like decomposition at another.  Are we violating ODR with the implicit \"is <code>std::tuple_size</code> complete\" check behind the scenes?</p>\n", "Title": "Can you violate ODR with structured bindings on a class type", "CreationDate": "2018-02-08T07:36:16.757", "LastActivityDate": "2018-02-08T09:11:00.860", "CommentCount": "3", "PostTypeId": "1", "Id": "48679991", "Score": "4", "OwnerUserId": "5501675", "Tags": "<c++><undefined-behavior><one-definition-rule><c++17><structured-bindings>", "AnswerCount": "1"}});