post_cb({"19252773": {"PostTypeId": "2", "Body": "<p>You're using gcc's C extension to define your alignment. That will affect the size of the object (which needs to be a multiple of the alignment) and <em>might</em> affect the storage layout of objects with static alignment, but only to the extent to which the linker is prepared to align such objects. It does not affect the alignment of dynamically allocate objects, even in C++.</p>\n<p>The C++ <code>new</code> operator calls an allocator function to provide storage, and then proceeds to initialize the storage by invoking the object constructor. The standard requires the allocation function to return a pointer \"suitably aligned so that it can be converted to a pointer of any complete object type with a fundamental alignment requirement.\" (\u00a73.7.4.1p2). The default standard library global allocator must conform to this requirement (\u00a718.6.1). The definition of \"fundamental alignment requirement\" is implementation-specific, but it must be at least as large as the alignment requirement of any <em>scalar</em> type, and does not need to be any larger.</p>\n<p>The global allocation function, as specified by the C++ standard, has only a single parameter, which is the size of the requested object. It is not passed any information about the alignment of the object, or the type, so it cannot perform an alignment-specific allocation.</p>\n<p>You're free to define an allocation function for a given type, which can take that type's alignment into account. However, it would have to either use a non-standard (i.e. system-specific) underlying allocator, or over-allocate and then adjust the pointer. (C++11 provides a standard-library function <a href=\"http://en.cppreference.com/w/cpp/memory/align\" rel=\"nofollow\"><code>align</code></a> for this purpose.)</p>\n<p>As I read the standard, C++11 requires the <code>new</code> expression to fail if the alignment of the object type exceeds the capability of the underlying allocator:</p>\n<blockquote>\n<p id=\"so_19251360_19252773_0\">\u00a73.11p9 If a request for a specific extended alignment in a specific context is not supported by an implementation, the program is ill-formed. Additionally, a request for runtime allocation of dynamic storage for which the requested alignment cannot be honored shall be treated as an allocation failure.</p>\n</blockquote>\n<p>That won't apply to your program, since you are using a GCC-specific C-oriented alignment attribute, and certainly not C++11, so I suppose the compiler is within its rights to call an allocator which will return insufficiently aligned storage rather than throwing <code>bad_alloc</code>.</p>\n<p>By the way, gcc 4.2.2 just celebrated its sixth birthday. You should consider sending it off to grade school and updating to something more modern.</p>\n", "LastActivityDate": "2013-10-08T16:04:18.630", "Id": "19252773", "CommentCount": "1", "CreationDate": "2013-10-08T16:04:18.630", "ParentId": "19251360", "Score": "4", "OwnerUserId": "1566221"}, "bq_ids": {"n4140": {"so_19251360_19252773_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 7248}}, "n3337": {"so_19251360_19252773_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 6992}}}, "45229102": {"PostTypeId": "2", "Body": "<pre><code>attribute(__aligned__())\n</code></pre>\n<p>is pretty horrible.I call it a bug. No traction at all on the gcc list. Not even acknowledgement that anybody read it.</p>\n<p><a href=\"https://gcc.gnu.org/ml/gcc/2014-06/msg00308.html\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/ml/gcc/2014-06/msg00308.html</a></p>\n<p>note that you can't even check that what you got was aligned because it will calculate the maths incorrectly. </p>\n<pre><code>0xxxxxx30 % 0x40 == 0x0 //really? that's aligned to 64b?\n</code></pre>\n<p>posix_memalign() or bust</p>\n", "LastActivityDate": "2017-07-21T04:41:58.177", "Id": "45229102", "CommentCount": "0", "CreationDate": "2017-07-21T04:41:58.177", "ParentId": "19251360", "Score": "1", "OwnerUserId": "3995687"}, "19251360": {"ViewCount": "655", "Body": "<p>I'm trying to build a simple linked list where each element would be aligned to some round address. \nI've tried the following code (shortened as much as possible to be SSCCE):</p>\n<pre><code>#include \"stdio.h\"\n#define N 10\n\ntypedef struct  __attribute__((aligned(0x100)) _element {\n  int val;\n  char padding[64];\n  struct _element *next;\n\n}  element;\n\n\nint main() {\n\n    element* head = new element;\n    element* current = head;\n    for (int i = 0; i &lt; N; ++i) {\n        current-&gt;val = i;\n        if (i == N - 1)\n            break;\n        current-&gt;next = new element;\n        current = current-&gt;next;\n    }\n    current-&gt;next = NULL;\n\n    current = head;\n    printf(\"sizeof(element) = 0x%x\\n\", (unsigned int)sizeof(element));\n    while (current) {\n        printf(\"*(%p) = %d\\n\", &amp;current-&gt;val, current-&gt;val);\n        current = current-&gt;next;\n    }\n\n    return 0;\n}\n</code></pre>\n<p>Built with g++ 4.2.2, no optimizations, and produced:</p>\n<pre><code>sizeof(element) = 0x100\n*(0x501010) = 0\n*(0x501120) = 1\n*(0x501230) = 2\n*(0x501340) = 3\n*(0x501450) = 4\n*(0x501560) = 5\n*(0x501670) = 6\n*(0x501780) = 7\n*(0x501890) = 8\n*(0x5019a0) = 9\n</code></pre>\n<p>Why aren't the addresses aligned to 0x100? Note that it did affect the struct \"size\", looks like it's being padded somehow, but it doesn't start at aligned addresses like I wanted.</p>\n<p>From <a href=\"https://stackoverflow.com/questions/1468513/attribute-aligned-not-working-with-static-variables\">this answer</a> I understood that there might be a max alignment, but even lowering it to 0x20 didn't change the alignment (only the sizeof). \n<a href=\"https://stackoverflow.com/questions/841433/gcc-attribute-alignedx-explanation\">This answer</a> doesn't help since it's about stack allocation. Couldn't find any other source to explain this. Am I asking too much from this attribute? or doing something else wrong?</p>\n<p>Thanks in advance!</p>\n", "AcceptedAnswerId": "19252773", "Title": "__attribute__((aligned(x)) doesn't work on dynamic allocations", "CreationDate": "2013-10-08T15:02:30.103", "Id": "19251360", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:31:35.407", "LastEditorUserId": "-1", "LastActivityDate": "2017-07-21T04:41:58.177", "Score": "1", "OwnerUserId": "2016408", "Tags": "<c++><memory><memory-management><alignment>", "AnswerCount": "2"}});