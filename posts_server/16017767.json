post_cb({"bq_ids": {"n4140": {"so_16017767_16018026_0": {"length": 56, "quality": 0.9032258064516129, "section_id": 3326}}, "n3337": {"so_16017767_16018026_0": {"length": 56, "quality": 0.9032258064516129, "section_id": 3196}}, "n4659": {"so_16017767_16018026_0": {"length": 56, "quality": 0.9032258064516129, "section_id": 4092}}}, "16018026": {"Id": "16018026", "PostTypeId": "2", "Body": "<p>This seems to be a <strong>bug</strong>. The output should be the one you are expecting.</p>\n<p>While there is no guarantee on the order of evaluation of the arguments of a constructor call <em>in general</em>, there is a guarantee on the order of evaluation of expressions in an braced initializer list. </p>\n<p>Per Paragraph 8.5.4/4 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16017767_16018026_0\"><strong>Within the initializer-list of a braced-init-list, the initializer-clauses, including any that result from pack\n  expansions (14.5.3), are evaluated in the order in which they appear</strong>. That is, every value computation and\n  side effect associated with a given initializer-clause is sequenced before every value computation and side\n  effect associated with any initializer-clause that follows it in the comma-separated list of the initializer-list.\n  [ Note: This evaluation ordering holds regardless of the semantics of the initialization; for example, <strong>it applies\n  when the elements of the initializer-list are interpreted as arguments of a constructor call, even though\n  ordinarily there are no sequencing constraints on the arguments of a call</strong>. \u2014end note ]</p>\n</blockquote>\n", "LastActivityDate": "2013-04-15T14:39:44.923", "CommentCount": "4", "CreationDate": "2013-04-15T14:39:44.923", "ParentId": "16017767", "Score": "12", "OwnerUserId": "1932150"}, "16017998": {"Id": "16017998", "PostTypeId": "2", "Body": "<p>As noted, your problem is a compiler bug.  Your code, as written, should evaluate its arguments in order.</p>\n<p>My advice would be to be explicit about what you want to do, and what order you are doing it in, and avoid abusing the comma operator (as an aside, your code could behave strangely if <code>some_function</code> returned a type that overrides <code>operator,</code>) or using initializer lists guarantees (which, while standard, are also relatively obscure).</p>\n<p>My go to solution is to write and then use <code>do_in_order</code>:</p>\n<pre><code>// do nothing in order means do nothing:\nvoid do_in_order() {}\n// do the first passed in nullary object, then the rest, in order:\ntemplate&lt;typename F0, typename... Fs&gt;\nvoid do_in_order(F0&amp;&amp; f0, Fs&amp;&amp;... fs) {\n  std::forward&lt;F0&gt;(f0)();\n  do_in_order( std::forward&lt;Fs&gt;(fs)... );\n}\n</code></pre>\n<p>which you use like this:</p>\n<pre><code>do_in_order( [&amp;]{ some_function(std::forward&lt;Args&gt;(args)); }... );\n</code></pre>\n<p>you wrap the action you want to do in an anonymous nullary full-capture lambda, then use <code>...</code> to create a whole set of instances of said lambdas and pass to <code>do_in_order</code>, which calls them in order via perfect forwarding.</p>\n<p>This should be easy for a compiler to inline and reduce to a sequence of calls.  And it says what it does directly, and doesn't require strange void casts, the use of the comma operator, or arrays whose value is discarded.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2013-04-15T14:47:10.653", "Score": "4", "CreationDate": "2013-04-15T14:38:57.073", "ParentId": "16017767", "CommentCount": "0", "OwnerUserId": "1774667", "LastEditDate": "2013-04-15T14:47:10.653"}, "16017767": {"ViewCount": "1219", "Body": "<p>Enclosing a variadic template's parameters in initializer lists should assure that they're evaluated in order, but isn't happening here:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n\ntemplate&lt;class T&gt; void some_function(T var)\n{\n   cout &lt;&lt; var &lt;&lt; endl;\n}\n\nstruct expand_aux {\n    template&lt;typename... Args&gt; expand_aux(Args&amp;&amp;...) { }\n};\n\ntemplate&lt;typename... Args&gt; inline void expand(Args&amp;&amp;... args) \n{\n   bool b[] = {(some_function(std::forward&lt;Args&gt;(args)),true)...}; // This output is 42, \"true\", false and is correct\n   cout &lt;&lt; \"other output\" &lt;&lt; endl;\n   expand_aux  temp3 { (some_function(std::forward&lt;Args&gt;(args)),true)...  }; // This output isn't correct, it is false, \"true\", 42\n}\n\nint main()\n{\n   expand(42, \"true\", false);\n\n   return 0;\n}\n</code></pre>\n<p>How come?</p>\n", "AcceptedAnswerId": "16018026", "Title": "C++11 initializer lists on variadic template's parameters: why isn't this working", "CreationDate": "2013-04-15T14:29:39.547", "Id": "16017767", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-08-15T02:20:10.340", "LastEditorUserId": "16287", "LastActivityDate": "2015-08-15T02:20:10.340", "Score": "11", "OwnerUserId": "2154732", "Tags": "<c++><templates><c++11><variadic-templates>", "AnswerCount": "2"}});