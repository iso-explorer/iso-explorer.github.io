post_cb({"32938686": {"CommentCount": "2", "ViewCount": "124", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-10-04T21:38:30.200", "LastActivityDate": "2015-10-05T12:52:14.427", "Title": "Using aliases for strictly typing function parameters", "AcceptedAnswerId": "32938769", "LastEditDate": "2017-05-23T11:52:08.903", "Id": "32938686", "Score": "2", "Body": "<p>It's possible to use an alias to change the literal signature of a function:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>using String = std::string;\n\nvoid Print(String s) { ... };\n</code></pre>\n<p>But this doesn't disallow calling <code>Print</code> with a <code>std::string</code>:</p>\n<pre><code>Print(std::string{\"Hello world\"}); // Still works\n</code></pre>\n<p>This makes sense -- an alias is strictly for simplifying a name for a type, it does not define a new type.</p>\n<p>Besides subclassing, which is <a href=\"https://stackoverflow.com/a/6007040/2297365\">not a good idea</a>, is there a mechanism by which it's possible to achieve strict typing by name for function parameters? An immediate consequence of this is that this would be possible as well:</p>\n<pre><code>using StringA = std::string;\nusing StringB = std::string;\n\nvoid Print(StringA s) { ... };\nvoid Print(StringB s) { ... };\n\nPrint(StringA{\"Hello world\"});\nPrint(StringB{\"Hi everyone\"});\n</code></pre>\n<p>My current solution is to define simple wrapper classes that hold the type I want to alias as a member. This isn't ideal because it requires duplicating the interface for the member class into the wrapper, something that isn't necessary when using an alias.</p>\n", "Tags": "<c++><c++11><overloading><alias><typedef>", "OwnerUserId": "2297365", "AnswerCount": "3"}, "32939276": {"ParentId": "32938686", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-10-04T22:59:30.893", "Score": "2", "LastEditorUserId": "499359", "LastEditDate": "2015-10-05T12:52:14.427", "Id": "32939276", "OwnerUserId": "5407933", "Body": "<p>You are taking the right approach.  Wrapping an object of the original type is the best that you can currently do.</p>\n<p>I recently talked about this topic at CppCon 2015, and have open-sourced a library that makes it convenient to make an \"opaque typedef\" for integer types:\n<a href=\"https://sourceforge.net/projects/opaque-typedef/\" rel=\"nofollow\">https://sourceforge.net/projects/opaque-typedef/</a></p>\n<p>Be aware that it can be beneficial to customize the interface of your new type, to remove operations that would be errors for your purposes, and to add deliberate interoperability with other types.  <a href=\"https://github.com/CppCon/CppCon2015/blob/master/Lightning%20Talks%20and%20Lunch%20Sessions/Extreme%20Type%20Safety%20with%20Opaque%20Typedefs/Extreme%20Type%20Safety%20with%20Opaque%20Typedefs%20-%20Kyle%20Markley%20-%20CppCon%202015.pdf\" rel=\"nofollow\">Slides from my presentation</a>.</p>\n", "LastActivityDate": "2015-10-05T12:52:14.427"}, "32938769": {"ParentId": "32938686", "CommentCount": "0", "CreationDate": "2015-10-04T21:47:51.647", "OwnerUserId": "3723423", "PostTypeId": "2", "Id": "32938769", "Score": "2", "Body": "<p>The standard makes typedefs and alias a synonym for another type and not a new type:  </p>\n<blockquote>\n<p id=\"so_32938686_32938769_0\"><strong>7.1.3/1:</strong> A name declared with the typedef speci\ufb01er becomes a typedef-name. Within the scope of its declaration, a typedef-name is\n  syntactically equivalent to a keyword and names the type associated\n  with the identi\ufb01er in the way described in Clause 8. <strong>A typedef-name\n  is thus a synonym for another type. A typedef-name does not introduce\n  a new type</strong> the way a class declaration or enum declaration does.</p>\n</blockquote>\n<p>and </p>\n<blockquote>\n<p id=\"so_32938686_32938769_1\"><strong>7.1.3/2:</strong>  A typedef-name can also be introduced by an alias-declaration. The identi\ufb01er following the using keyword becomes a\n  typedef-name. It has the same semantics as if it were introduced by\n  the typedef speci\ufb01er. In particular, it does not de\ufb01ne a new type and\n  it shall not appear in the type-id.</p>\n</blockquote>\n<p>So unfortunately, you'll have to continue to use your class wrapper to introduce different types and being able to overload function on this base. </p>\n", "LastActivityDate": "2015-10-04T21:47:51.647"}, "bq_ids": {"n4140": {"so_32938686_32938769_0": {"section_id": 5407, "quality": 0.9210526315789473, "length": 35}, "so_32938686_32938769_1": {"section_id": 5408, "quality": 0.8076923076923077, "length": 21}}, "n3337": {"so_32938686_32938769_0": {"section_id": 5202, "quality": 0.9210526315789473, "length": 35}, "so_32938686_32938769_1": {"section_id": 5203, "quality": 0.8076923076923077, "length": 21}}, "n4659": {"so_32938686_32938769_0": {"section_id": 6829, "quality": 0.9210526315789473, "length": 35}, "so_32938686_32938769_1": {"section_id": 6830, "quality": 0.7307692307692307, "length": 19}}}, "32938782": {"ParentId": "32938686", "CommentCount": "0", "CreationDate": "2015-10-04T21:49:18.583", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "32938782", "Score": "2", "Body": "<p>No, there is no way to get a new type without actually creating a new type (class, struct, enum).</p>\n<p>However, there is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0027r0.pdf\" rel=\"nofollow\">a brand new proposal</a> to add such a mechanism, perhaps using <code>newtype</code> as a keyword instead of <code>typedef</code>.</p>\n", "LastActivityDate": "2015-10-04T21:49:18.583"}});