post_cb({"18631651": {"ParentId": "18631574", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>What you are seeing is probably <a href=\"http://en.wikipedia.org/wiki/Arithmetic_shift\" rel=\"nofollow\">arithmetic bit shift</a>.</p>\n<blockquote>\n<p id=\"so_18631574_18631651_0\">when shifting to the right, the leftmost bit (usually the sign bit in\n  signed integer representations) is replicated to fill in all the\n  vacant positions (this is a kind of sign extension).</p>\n</blockquote>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow\">C99 standard</a> 6.5.7\u00a75 says:</p>\n<blockquote>\n<p id=\"so_18631574_18631651_1\">The result of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. [...] If E1 has a signed type and a negative value, the resulting value\n  is implementation-defined.</p>\n</blockquote>\n<p>So the result could be anything the compiler writers decided it to be. They probably decided to extend the sign bit, the compiler doc should mention it.</p>\n", "OwnerUserId": "108802", "LastEditorUserId": "108802", "LastEditDate": "2013-09-05T08:54:03.083", "Id": "18631651", "Score": "8", "CreationDate": "2013-09-05T08:42:38.800", "LastActivityDate": "2013-09-05T08:54:03.083"}, "bq_ids": {"n4140": {"so_18631574_18631651_1": {"section_id": 6148, "quality": 0.75, "length": 9}}, "n3337": {"so_18631574_18631651_1": {"section_id": 5911, "quality": 0.75, "length": 9}}, "n4659": {"so_18631574_18631651_1": {"section_id": 7644, "quality": 0.75, "length": 9}}}, "18631574": {"CommentCount": "8", "ViewCount": "208", "PostTypeId": "1", "LastEditorUserId": "183120", "CreationDate": "2013-09-05T08:38:12.450", "LastActivityDate": "2013-09-05T09:12:54.107", "Title": "Bitshift operation with signed and unsigned", "AcceptedAnswerId": "18631651", "LastEditDate": "2013-09-05T09:12:54.107", "Id": "18631574", "Score": "3", "Body": "<p>I was doing a bitshift operation of an int and was surprised that it didn't come out as expected.</p>\n<pre><code>int i, res;\ni = 0x80000000;\nres = i&gt;&gt;1;                //results in 0xc0000000\nres = (unsigned int) i&gt;&gt;1; //results in 0x40000000\n</code></pre>\n<p>how is it possible that a shift of a bit in an integer does only work to the 31st bit? </p>\n", "Tags": "<c++><c><visual-c++><visual-studio-2005>", "OwnerUserId": "1835706", "AnswerCount": "1"}});