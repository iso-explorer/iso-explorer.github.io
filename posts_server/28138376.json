post_cb({"bq_ids": {"n4140": {"so_28138376_28138436_6": {"length": 12, "quality": 0.9230769230769231, "section_id": 3317}, "so_28138376_28138436_2": {"length": 9, "quality": 1.0, "section_id": 6174}, "so_28138376_28138436_8": {"length": 21, "quality": 0.9130434782608695, "section_id": 3319}, "so_28138376_28138436_4": {"length": 13, "quality": 1.0, "section_id": 6178}, "so_28138376_28138436_7": {"length": 21, "quality": 0.9130434782608695, "section_id": 3318}}, "n3337": {"so_28138376_28138436_4": {"length": 13, "quality": 1.0, "section_id": 5939}, "so_28138376_28138436_7": {"length": 21, "quality": 0.9130434782608695, "section_id": 3188}, "so_28138376_28138436_2": {"length": 9, "quality": 1.0, "section_id": 5935}, "so_28138376_28138436_8": {"length": 21, "quality": 0.9130434782608695, "section_id": 3189}, "so_28138376_28138436_6": {"length": 12, "quality": 0.9230769230769231, "section_id": 3187}}, "n4659": {"so_28138376_28138436_4": {"length": 7, "quality": 0.5384615384615384, "section_id": 7408}, "so_28138376_28138436_7": {"length": 15, "quality": 0.6521739130434783, "section_id": 4084}, "so_28138376_28138436_2": {"length": 9, "quality": 1.0, "section_id": 7676}, "so_28138376_28138436_8": {"length": 21, "quality": 0.9130434782608695, "section_id": 4085}, "so_28138376_28138436_6": {"length": 7, "quality": 0.5384615384615384, "section_id": 502}}}, "28138687": {"Id": "28138687", "PostTypeId": "2", "Body": "<p>To answer you question in a simple and short way.... <strong>yes</strong> the <strong>original value</strong> of \"<strong>s1</strong>\" is \"<strong>lost</strong>\" in really is changed.\nWhy?\nWhen you create a reference variable, you are creating a variable that will have another variable as an alias. This reference variable will keep the address of the alias variable. It's like having a pointer. The R. Variable will always point to the A. Variable. However, the difference between a pointer and a R.Variable is that for pointers you dereference in a different manner, with R.Variable you treat them like normal variables, and second is that for R.Variable you don't do anything special to address its memory, as you do in Pointers.</p>\n<pre><code>int AliasV = 70;\nint&amp; RefeV = AliasV;\n\ncout&lt;&lt;RefeV &lt;&lt;\" \"&lt;&lt; AliasV;\n\n//Now RefeV is addressing to AliasV memory. (Similar to Pointer but no equal)\n\nRefeV = 100;\n\n//Because RefeV is addressing to AliasV memory, AliasV now has as value 100\ncout&lt;&lt;RefeV&lt;&lt;\" \"&lt;&lt;AliasV;\n</code></pre>\n<p>Output:</p>\n<pre><code>70 70\n100 100\n</code></pre>\n<p>Tip:</p>\n<ul>\n<li>Keep in mind that a RefeVariable will always address to its alias memory behind the scenes.</li>\n<li>Any changes to RefeVariable will affect its alias. </li>\n</ul>\n", "LastActivityDate": "2015-01-25T16:33:48.403", "CommentCount": "0", "CreationDate": "2015-01-25T16:33:48.403", "ParentId": "28138376", "Score": "0", "OwnerUserId": "4471786"}, "28138376": {"ViewCount": "69", "Body": "<p>I was reading <em>Effective C++</em> by Scott Meyers and came across this. The reasons for using references/pointers over each other contained this:</p>\n<pre><code>string s1(\"Nancy\");\nstring s2(\"Clancy\");\nstring&amp; rs = s1; // rs refers to s1\nrs = s2; //rs still refers to s1, but s1's value is now \"Clancy\".\n</code></pre>\n<p>So, I tried this out:</p>\n<pre><code>string s1(\"Nancy\");\nstring s2(\"Clancy\");\nstring&amp; rs = s1;\ncout &lt;&lt; rs &lt;&lt; endl;\nrs = s2;\ncout &lt;&lt; rs &lt;&lt; endl;\ncout &lt;&lt; s1 &lt;&lt; endl;\n</code></pre>\n<p>Output seen:</p>\n<pre><code>nancy\nclancy\nclancy\n</code></pre>\n<p>That means s1's value is now changed and\nThe original value of s1 is lost forever??</p>\n<p>This is one of the things that differentiates references from pointers then??Use references over pointers only when you are sure that you are not going to refer to different objects at different time??</p>\n", "AcceptedAnswerId": "28138436", "Title": "Effects of reference usage in C++", "CreationDate": "2015-01-25T16:04:18.470", "LastActivityDate": "2017-05-12T13:26:13.243", "CommentCount": "3", "LastEditDate": "2017-05-12T13:26:13.243", "PostTypeId": "1", "Tags": "<c++><reference>", "Id": "28138376", "AnswerCount": "2", "Score": "0", "OwnerUserId": "1163462", "ClosedDate": "2015-01-26T00:42:33.323", "LastEditorUserId": "63550"}, "28138436": {"Id": "28138436", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_28138376_28138436_0\">C++ Standard n3337 </p>\n<p id=\"so_28138376_28138436_1\"><strong>\u00a7</strong> 5.17 <strong>Assignment and compound assignment operators</strong></p>\n<p id=\"so_28138376_28138436_2\">2) In simple assignment (=), the value of the expression replaces that\n  of the object referred to by the left operand.</p>\n<p id=\"so_28138376_28138436_3\">(...)</p>\n<p id=\"so_28138376_28138436_4\">6) When the left operand of an assignment operator denotes a reference\n  to T, the operation assigns to the object of type T denoted by the\n  reference.</p>\n<p id=\"so_28138376_28138436_5\"><strong>\u00a7</strong> 8.5.3 <strong>References</strong></p>\n<p id=\"so_28138376_28138436_6\">1) A variable declared to be a T&amp; or T&amp;&amp;, that is, \u201creference to type\n  T\u201d (8.3.2), shall be initialized by an object, or function, of type T\n  or by an object that can be converted into a T.(...)</p>\n<p id=\"so_28138376_28138436_7\">2) A reference cannot be changed to refer to another object after\n  initialization. Note that initialization of a reference is treated\n  very differently from assignment to it. Argument passing (5.2.2) and\n  function value return (6.6.3) are initializations.</p>\n<p id=\"so_28138376_28138436_8\">3) The initializer can be omitted for a reference only in a parameter\n  declaration (8.3.5), in the declaration of a function return type, in\n  the declaration of a class member within its class definition (9.2),\n  and where the extern specifier is explicitly used.</p>\n</blockquote>\n<p>You cannot reinitialize a reference in C++ <sup>1</sup>. You can assign different value to the object it refers to. This is one and the same object for that reference forever. And this is what you did in your example.</p>\n<pre><code>string s1(\"Nancy\")   // s1 Nancy\nstring s2(\"Clancy\"); // s2 Clancy\nstring&amp; rs = s1;     // rs-&gt; s1\ncout&lt;&lt;rs&lt;&lt;endl;      // ==cout s1\nrs=s2;               // == s1=s2  \n                     // s1 Clancy\n                     // s2 Clancy\ncout&lt;&lt;rs&lt;&lt;endl;      // ==cout s1\ncout&lt;&lt;s1&lt;&lt;endl;\n</code></pre>\n<blockquote>\n<p id=\"so_28138376_28138436_9\">That means s1's value is now changed and The original value of s1 is\n  lost forever??</p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p id=\"so_28138376_28138436_10\">This is one of the things that differentiates references from pointers\n  then?</p>\n</blockquote>\n<p>Yes. A pointer can be reinitialized and the reference cannot. This is the first difference pointed out here</p>\n<p><a href=\"https://stackoverflow.com/a/57492/1141471\">What are the differences between a pointer variable and a reference variable in C++?</a></p>\n<p><a href=\"https://stackoverflow.com/questions/7058339/c-when-to-use-references-vs-pointers\">When to use references vs. pointers</a></p>\n<blockquote>\n<p id=\"so_28138376_28138436_11\">Use references over pointers only when not reinitialising it?</p>\n</blockquote>\n<p>Use them when you want always point to the same object. Use them as well if it is a member of a class and you want to preserve an invariant that valid object of that class always contains a reference to something. Reference member must always be initialized when class instance is constructed so in that way reference enforces you to preserve invariant.</p>\n<hr>\n<p><sub>1 As @James Kanze pointed out in the comments you cannot in fact reinitialize anything in C++ in proper technical meaning of this word. In most cases initialization involves constructor and that (ctor) is called only once, at the beginning of object's lifetime (initialization of a reference is special in this context as <strong>\u00a7</strong> 8.5.3/2 points out in that reference is initialized by passing an argument or returned value from function). After this happened there is only an assignment, i.e call to T&amp; operator=(T const&amp;)</sub></p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-26T09:51:58.440", "Score": "5", "CreationDate": "2015-01-25T16:09:38.440", "ParentId": "28138376", "CommentCount": "6", "OwnerUserId": "1141471", "LastEditDate": "2017-05-23T10:31:30.213"}});