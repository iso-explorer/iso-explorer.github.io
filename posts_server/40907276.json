post_cb({"bq_ids": {"n4140": {"so_40907276_40908958_1": {"length": 6, "quality": 0.5454545454545454, "section_id": 480}}, "n3337": {"so_40907276_40908958_1": {"length": 6, "quality": 0.5454545454545454, "section_id": 471}}}, "40908958": {"PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_40907276_40908958_0\">GCC ignores copy constructor s(const s &amp;other).</p>\n</blockquote>\n<p>It may well do that, as a copy-elision optimization.</p>\n<blockquote>\n<p id=\"so_40907276_40908958_1\">GCC automatically creates a move constructor for class s and then std::vector.push_back() calls that move constructor.</p>\n</blockquote>\n<p>No. A move constructor is not generated.</p>\n<blockquote>\n<p id=\"so_40907276_40908958_2\">My question here is that class s apparently has a user-declared destructor ~s(), meaning class s does not meet the forth condition</p>\n</blockquote>\n<p>Correct. The class also doesn't meet the first condition (user declared copy constructor).</p>\n<blockquote>\n<p id=\"so_40907276_40908958_3\">How does GCC behaves so?</p>\n</blockquote>\n<p>GCC seems to behave as it should. There is no move construction or assignment involved.</p>\n<blockquote>\n<p id=\"so_40907276_40908958_4\">Destructor ~s() is called two times</p>\n</blockquote>\n<p>In the gdb log that you show, I only see one instance of <code>s::~s</code> being called.</p>\n<blockquote>\n<p id=\"so_40907276_40908958_5\">question 1: Why the program does not crash? Am I simply lucky?</p>\n</blockquote>\n<p>I would consider you unlucky. It seems that <code>push_back</code> didn't use the copy assignment operator, so the conditions for double free didn't occur.</p>\n<blockquote>\n<p id=\"so_40907276_40908958_6\">question 2: According to gdb log, does it mean that codes designed for prior C++11 meeting rule of three but not meeting rule of five, like this example...</p>\n</blockquote>\n<p>This example doesn't meet the rule of three, so this appears not to be example of what you're asking for.</p>\n<blockquote>\n<p id=\"so_40907276_40908958_7\">are very likely to crash when they are compiled to C++11 executables?</p>\n</blockquote>\n<p>No. As long as code follows the rule of three, it is safe to copy the objects. Following the rule of five is only necessary in order to make the object movable (to avoid copying).</p>\n", "LastActivityDate": "2016-12-01T11:08:54.437", "LastEditorUserId": "2079303", "Id": "40908958", "CommentCount": "1", "CreationDate": "2016-12-01T11:02:57.767", "ParentId": "40907276", "Score": "8", "OwnerUserId": "2079303", "LastEditDate": "2016-12-01T11:08:54.437"}, "40908244": {"PostTypeId": "2", "Body": "<p>If a copy constructor is explicitly declared (as in your case) no move constructor or assignment constructor are automatically generated by the compiler.</p>\n<p>The copy constructor is the best candidate and is used to copy the temporary generated element (both default and copy constructor are invoked).</p>\n<p>This also gives you <a href=\"https://en.wikipedia.org/wiki/Exception_safety\" rel=\"nofollow noreferrer\">strong exception safety guarantee</a>.</p>\n", "LastActivityDate": "2016-12-01T10:30:13.610", "Id": "40908244", "CommentCount": "1", "CreationDate": "2016-12-01T10:30:13.610", "ParentId": "40907276", "Score": "3", "OwnerUserId": "1938163"}, "40907820": {"PostTypeId": "2", "Body": "<p>hmmm, check this:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;cstring&gt; //memcpy()\n#include &lt;iostream&gt;\nclass s\n{\n    char *p;\n    size_t size;\npublic:\n    s(){\n        std::cout&lt;&lt;this&lt;&lt;\"\\tdefault constructor\\n\";\n        size=10;\n        p=new char[size];\n    }\n    s(const s &amp;other){\n        std::cout&lt;&lt;this&lt;&lt;\"\\tcopy constructor\\n\";\n        size=other.size;\n        p=new char[size];\n        memcpy(p,other.p,other.size);\n    }\n    ~s(){ \n         std::cout&lt;&lt;this&lt;&lt;\"\\tdestructor\\n\";\n         delete [] p; \n    }   \n};\n\nint main()\n{\n    std::vector&lt;s&gt; ss;\n    ss.push_back(s());\n}\n</code></pre>\n<p>For me, I am getting destructed 2 different object:<br>\n<em>0x7fffc879aa50 default constructor<br>\n0x1668c40   copy constructor<br>\n0x7fffc879aa50  destructor<br>\n0x1668c40   destructor</br></br></br></em> </br></p>\n<blockquote>\n<p id=\"so_40907276_40907820_0\">question 1: Why the program does not crash? Am I simply lucky?</p>\n</blockquote>\n<p>There is no double free of coraption.</p>\n<p>compiled with:\ng++ -O3 --std=c++11 file2.cpp -o file2.out<br>\nG++ 4.7.3</br></p>\n", "LastActivityDate": "2016-12-01T10:18:51.017", "LastEditorUserId": "6770159", "Id": "40907820", "CommentCount": "1", "CreationDate": "2016-12-01T10:12:14.263", "ParentId": "40907276", "Score": "3", "OwnerUserId": "6770159", "LastEditDate": "2016-12-01T10:18:51.017"}, "40907276": {"ViewCount": "784", "Body": "<p>I compile the following code using command <code>g++ -std=c++11 t.cpp</code>:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;cstring&gt; //memcpy()\nclass s\n{\n    char *p;\n    size_t size;\npublic:\n    s(){\n        size=10;\n        p=new char[size];\n    }\n    s(const s &amp;other){\n        size=other.size;\n        p=new char[size];\n        memcpy(p,other.p,other.size);\n    }\n    ~s(){ delete [] p; }\n};\n\nint main()\n{\n    std::vector&lt;s&gt; ss;\n    ss.push_back(s());\n}\n</code></pre>\n<p>This is <code>gdb</code> log:</p>\n<pre><code>Breakpoint 1, main () at t.cpp:23\n23          ss.push_back(s());\ns::s (this=0x7fffffffe370) at t.cpp:9\n9               size=10;\n10              p=new char[size];\n11          }\nstd::vector&lt;s, std::allocator&lt;s&gt; &gt;::push_back(s&amp;&amp;) (this=0x7fffffffe350, \n    __x=&lt;unknown type in /tmp/a.out, CU 0x0, DIE 0x20d0&gt;)\n    at /usr/include/c++/4.9/bits/stl_vector.h:932\n932       { emplace_back(std::move(__x)); }\nstd::move&lt;s&amp;&gt; (__t=...) at /usr/include/c++/4.9/bits/move.h:102\n102     { return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); }\nstd::vector&lt;s, std::allocator&lt;s&gt; &gt;::emplace_back&lt;s&gt;(s&amp;&amp;) (this=0x7fffffffe350)\n    at /usr/include/c++/4.9/bits/vector.tcc:94\n94      if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage)\n101       _M_emplace_back_aux(std::forward&lt;_Args&gt;(__args)...);\n102       }\ns::~s (this=0x7fffffffe370, __in_chrg=&lt;optimized out&gt;) at t.cpp:17\n17          ~s(){ delete [] p; }\nstd::vector&lt;s, std::allocator&lt;s&gt; &gt;::~vector (this=0x7fffffffe350, __in_chrg=&lt;optimized out&gt;)\n    at /usr/include/c++/4.9/bits/stl_vector.h:425\n</code></pre>\n<p>From the log, I am in the following impression:</p>\n<ol>\n<li>GCC ignores copy constructor <code>s(const s &amp;other)</code>.</li>\n<li><p>GCC automatically creates a <code>move</code> constructor for <code>class s</code> and then <code>std::vector.push_back()</code> calls that <code>move</code> constructor.</p>\n<p><a href=\"http://www.informit.com/articles/article.aspx?p=1916419\" rel=\"nofollow noreferrer\">This article</a> states</p>\n<p>Thus, if the definition of class C doesn't explicitly\ndeclare a move assignment operator, one will be implicitly\ndeclared as defaulted only if all of the following conditions\nare met:</p>\n<p>My question here is that <code>class s</code> apparently has a user-declared destructor <code>~s()</code>, meaning <code>class s</code> does not meet the forth condition and thus GCC should not enforce <code>move</code> on <code>std::vector.push_back()</code>. How does GCC behaves so?</p></li>\n<li><p>Destructor <code>~s()</code> is called two times: first immediately after temporary <code>s()</code> has been passed as argument to <code>ss.push_back(s());</code> <strong>and moved</strong>, and second after the destructor of <code>std::vector&lt;s&gt;</code> is called.</p></li>\n<li>Because this code does not meet <a href=\"https://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29\" rel=\"nofollow noreferrer\">rule of three</a>, it is doomed to crash when the destructor of <code>std::vector&lt;s&gt;</code> is called. The content pointed to by <code>p</code> in object <code>s</code> is already deleted by the first <code>~s()</code>. Therefore, <code>std::vector&lt;s&gt;</code> destructor calling <code>~s()</code> must crash with error like <code>double free or corruption</code>.</li>\n</ol>\n<p>However, much to my surprise, somehow this program runs and terminates normally.</p>\n<p><strong>question 1</strong>: Why the program does not crash? Am I simply lucky?</p>\n<p><strong>question 2</strong>: According to <code>gdb</code> log, does it mean that codes designed for prior C++11 meeting <code>rule of three</code> but not meeting <a href=\"https://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29\" rel=\"nofollow noreferrer\">rule of five</a>, like this example, are very likely to crash when they are compiled to C++11 executables?</p>\n<p><strong>EDIT</strong>:</p>\n<p>This question was raised due to my misinterpretation of <code>gdb</code> messages like these:</p>\n<pre><code>std::vector&lt;s, std::allocator&lt;s&gt; &gt;::push_back(s&amp;&amp;)\nemplace_back(std::move(__x));\nstd::vector&lt;s, std::allocator&lt;s&gt; &gt;::emplace_back&lt;s&gt;(s&amp;&amp;)\n</code></pre>\n<p>which lead me to think that GCC creates a move constructor. I just did as many these experts told me to - setting a break point in <code>s(const s &amp;other)</code>, and noticed that the program does stop there. This finding invalidates all my questions.</p>\n<p>As every expert here suggested, the facts are:\n 1. GCC does not create any move constructor.\n 2. The existing copy constructor is called.</p>\n<p>Thank you all for the big helps!</p>\n", "AcceptedAnswerId": "40907820", "Title": "Does C++11 force move unconditionally?", "CreationDate": "2016-12-01T09:48:17.887", "Id": "40907276", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-12-01T11:45:52.210", "LastEditorUserId": "464487", "LastActivityDate": "2016-12-01T11:45:52.210", "Score": "7", "OwnerUserId": "464487", "Tags": "<c++><c++11><gcc>", "AnswerCount": "3"}});