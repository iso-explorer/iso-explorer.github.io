post_cb({"1110463": {"Id": "1110463", "PostTypeId": "2", "Body": "<p>You're not actually declaring any objects in that code.</p>\n<p>You need extra code:</p>\n<pre><code>s0 one;\ns1 two;\n</code></pre>\n<p>In that case, the two objects are now actually declared, and should work correctly.</p>\n<p>Are you explicitly declaring a s0?</p>\n<p>Try following the typedefs with a s0 dummy; and see if the problem is resolved.</p>\n", "LastActivityDate": "2009-07-10T16:01:15.287", "CommentCount": "3", "CreationDate": "2009-07-10T16:01:15.287", "ParentId": "1110418", "Score": "0", "OwnerUserId": "133758"}, "1110418": {"ViewCount": "904", "Body": "<p>Within the same compilation unit, the C++ standard says that static initialization order is well defined -- it's the order of the declarations of the static objects. But using the Sun Studio 12 compiler I'm encountering unintuitive behavior. I've define a templated class <code>helper&lt;T&gt;</code> which contains a static member <code>_data</code> of type <code>T</code> and a static member function that uses <code>_data</code> called <code>foo</code>. In my .cpp file I have this above main():</p>\n<pre><code>struct A { /* some definition */ };\n\ntypedef helper&lt;int&gt; s0;\ntypedef helper&lt;A&gt; s1;\n</code></pre>\n<p>Notice that the typedef for <code>helper&lt;int&gt;</code> comes <em>before</em> the typedef for <code>helper&lt;A&gt;</code>. Thus according to the standard I would expect that <code>helper&lt;int&gt;::_data</code> will be constructed before <code>helper&lt;A&gt;::_data</code> (remember <code>_data</code> is a static member). On GCC this is the case, on Sun it is not.</p>\n<p>This is problematic because A's constructor uses <code>helper&lt;int&gt;::_data</code>. I only have one compilation unit, with no earlier potential instantiation of <code>helper&lt;A&gt;</code>, so I thought the order should be well defined. Is this a Sun compiler bug, or does the typedef not constitute a definition/instantiation technically? What I mean is, is the Sun compiler's behavior allowed by the standard?</p>\n<p>I have the following main():</p>\n<pre><code>int main()\n{\n    //Swapping the order of these has no effect on Sun\n    s0::foo();\n    s1::foo();\n}\n</code></pre>\n<p>There are no other uses of s0 or s1.</p>\n", "AcceptedAnswerId": "1110485", "Title": "Do typedefs of templates preserve static initialization order?", "CreationDate": "2009-07-10T15:54:27.813", "Id": "1110418", "CommentCount": "0", "LastEditDate": "2009-07-10T17:00:31.737", "PostTypeId": "1", "LastEditorUserId": "50385", "LastActivityDate": "2009-07-10T17:00:31.737", "Score": "3", "OwnerUserId": "50385", "Tags": "<c++><templates><static><initialization><typedef>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_1110418_1110485_2": {"length": 37, "quality": 0.9736842105263158, "section_id": 216}}, "n3337": {"so_1110418_1110485_2": {"length": 37, "quality": 0.9736842105263158, "section_id": 210}}, "n4659": {"so_1110418_1110485_2": {"length": 37, "quality": 0.9736842105263158, "section_id": 224}}}, "1110485": {"Id": "1110485", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_1110418_1110485_0\">Within the same compilation unit, the C++ standard says that static initialization order is well defined -- it's the order of the declarations of the static objects.</p>\n</blockquote>\n<p>In your shown code you have no declaration of a static data member. You have a declaration of a typedef-name. These have nothing to do with that, and don't influence any order. <em>You probably think along this way</em>:</p>\n<blockquote>\n<p id=\"so_1110418_1110485_1\">If i make that typedef declaration, it will instantiate <code>helper&lt;int&gt;</code>, and thus instantiate its static data member declaration first.</p>\n</blockquote>\n<p>The problem is, that line does not cause an instantiation of <code>helper&lt;int&gt;</code>. For that to happen, you would need an explicit instantiation or manage to make it instantiate it implicitly (creating an object of <code>helper&lt;int&gt;</code> for example, or using it as a nested name specifier as in <code>helper&lt;int&gt;::...</code> and explicitly referencing the static member - otherwise, creation of it is omitted). </p>\n<p>But there is a much deeper problem. The order is <em>not</em> the declaration of the static data-members. The order is <em>their definition</em>. Consider the following</p>\n<pre><code>struct C { C() { printf(\"hey\\n\"); } };\nstruct A { \n  static C a;\n  static C b;\n};\n\nC A::b;\nC A::a;\n</code></pre>\n<p>In this code, <strong>b is created before a</strong>, even though <strong>a is declared before b</strong>. </p>\n<p>The following code prints <code>2 1</code>:</p>\n<pre><code>struct C { C(int n) { printf(\"%d\\n\", n); } };\n\ntemplate&lt;int N&gt;\nstruct A {\n  static C c;\n};\n\ntemplate&lt;int N&gt;\nC A&lt;N&gt;::c(N);\n\n// explicit instantiation of declaration and definition\ntemplate struct A&lt;2&gt;;\ntemplate struct A&lt;1&gt;;\n\nint main() {\n\n}\n</code></pre>\n<p>But the following code prints nothing, unless you comment in the line in <code>main</code>.</p>\n<pre><code>struct C { C(int n) { printf(\"%d\\n\", n); } };\n\ntemplate&lt;int N&gt;\nstruct A {\n  static C c;\n};\n\ntemplate&lt;int N&gt;\nC A&lt;N&gt;::c(N);\n\n// implicit instantiation of declarations\nA&lt;2&gt; a2;\nA&lt;1&gt; a1;\n\nint main() {\n  // A&lt;1&gt;::c; A&lt;2&gt;::c;\n}\n</code></pre>\n<p>I'm not actually sure what the correct output for this second snippet is. Reading the Standard, i can't determine an order. It says at <code>14.6.4.1</code> \"Point of Instantiation\":</p>\n<blockquote>\n<p id=\"so_1110418_1110485_2\">For a function template specialization, a member function template specialization, or a specialization for a member function or static data member of a class template, if the specialization is implicitly instantiated because it is referenced from within another template specialization [...]. Otherwise, the point of instantiation for such a specialization immediately follows the namespace scope declaration or definition that refers to the specialization.</p>\n</blockquote>\n<p>The point of instantiation of their definitions both appear immediately after the definition of <code>main</code>. Which definition is instantiated before the other definition seems to be left unspecified. If anyone knows the answer and khow other compilers behave (GCC prints <code>1 2</code> but with the order of the expressions in <code>main</code> swapped, prints <code>2 1</code>), please let me know in the comment.</p>\n<p>For details, see <a href=\"https://stackoverflow.com/questions/1079623/what-is-the-lifetime-of-class-static-variables-in-c/1080211#1080211\">this answer about static object's lifetime</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2009-07-10T16:38:47.880", "Score": "6", "CreationDate": "2009-07-10T16:05:59.677", "ParentId": "1110418", "CommentCount": "12", "OwnerUserId": "34509", "LastEditDate": "2017-05-23T11:44:19.520"}});