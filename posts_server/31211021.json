post_cb({"31216487": {"ParentId": "31211021", "CommentCount": "5", "CreationDate": "2015-07-04T03:07:13.220", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "31216487", "Score": "4", "Body": "<p>First, something very important: You have two different kinds of constructors. The first in particular, <code>C(std::initializer_list&lt;int&gt;)</code>, is called an <em>initializer-list</em> constructor. The second is just a normal user-defined constructor.</p>\n<p>[dcl.init.list]/p2</p>\n<blockquote>\n<p id=\"so_31211021_31216487_0\">A constructor is an <em>initializer-list</em> constructor if its first parameter is of type <code>std::initializer_list&lt;E&gt;</code> or reference to possibly cv-qualified <code>std::initializer_list&lt;E&gt;</code> for some type <code>E</code>, and either there are no other parameters or else all other parameters have default arguments (8.3.6).</p>\n</blockquote>\n<p>In a list-initialization containing one or more <em>initializer-clauses</em>, initializer-list constructors are considered before any other constructors. That is, initializer-list constructors are initially the only candidates during overload resolution.</p>\n<p>[over.match.list]/p1</p>\n<blockquote>\n<p id=\"so_31211021_31216487_1\">When objects of non-aggregate class type <code>T</code> are list-initialized such that 8.5.4 specifies that overload resolution is performed according to the rules in this section, overload resolution selects the constructor in two phases:</p>\n<ul>\n<li><p id=\"so_31211021_31216487_2\">Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class <code>T</code> and the argument list consists of the initializer list as a single argument.</p></li>\n<li><p id=\"so_31211021_31216487_3\">If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class <code>T</code> and the argument list consists of the elements\n  of the initializer list.</p></li>\n</ul>\n</blockquote>\n<p>So for both declarations of <code>c1</code> and <code>c2</code> the candidate set consists only of the <code>C(std::initializer_list&lt;int&gt;)</code> constructor.</p>\n<p>After the constructor is selected the arguments are evaluated to see if there exists an implicit conversion sequence to convert them to the parameter types. This takes us to the rules for initializer-list conversions:</p>\n<p>[over.ics.list]/p4 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_31211021_31216487_4\">Otherwise, if the parameter type is <code>std::initializer_list&lt;X&gt;</code> <strong>and all the elements of the initializer list can be implicitly converted to <code>X</code></strong>, the implicit conversion sequence is the worst conversion necessary to convert an\n  element of the list to <code>X</code>, or if the initializer list has no elements, the identity conversion.</p>\n</blockquote>\n<p>This means a conversion exists if each element of the initializer list can be converted to <code>int</code>.</p>\n<p>Let's focus on <code>c1</code> for now: For the initializer-list <code>{{1, 2}, {3}}</code>, the initializer-clause <code>{3}</code> can be converted to <code>int</code> ([over.ics.list]/p9.1), but not <code>{1, 2}</code> (i.e <code>int i = {1,2}</code> is ill-formed). This means the condition for the above quote is violated. Since there is no conversion, overload resolution fails since there are no other viable constructors and we are taken back to the second phase of [over.match.list]/p1:</p>\n<blockquote id=\"so_31211021_31216487_5\">\n<ul>\n<li>If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class <code>T</code> and the argument list consists of the elements\n  of the initializer list.</li>\n</ul>\n</blockquote>\n<p>Notice the change in wording at the end. The argument list in the second phase is no longer a single initializer-list, but the arguments of the braced-init-list used in the declaration. This means we can evaluate the implicit conversions in terms of the initializer-lists <em>individually</em> instead of at the same time.</p>\n<p>In the initializer-list <code>{1, 2}</code>, both initializer-clauses can be converted to <code>int</code>, so the entire initializer-clause can be converted to <code>initializer_list&lt;int&gt;</code>, the same for <code>{3}</code>. Overload resolution is then resolved with the second constructor being chosen.</p>\n<p>Now let's focus on <code>c2</code>, which should be easy now. The initializer-list constructor is first evaluated, and, using <code>{ {1}, {2} }</code> there surely exists a conversion to <code>int</code> from <code>{1}</code> and <code>{2}</code>, so the first constructor is chosen.</p>\n", "LastActivityDate": "2015-07-04T03:07:13.220"}, "31211021": {"CommentCount": "0", "AcceptedAnswerId": "31216487", "CreationDate": "2015-07-03T16:27:06.397", "LastActivityDate": "2015-07-04T03:07:13.220", "PostTypeId": "1", "ViewCount": "134", "FavoriteCount": "0", "Title": "Why scalar in braces are not interpeted as initializer_list", "Id": "31211021", "Score": "6", "Body": "<p>Consider the following code snippet:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;initializer_list&gt;\n\nstruct C\n{\n    C(std::initializer_list&lt;int&gt;) { std::cout &lt;&lt; \"list\\n\"; }\n    C(std::initializer_list&lt;int&gt;, std::initializer_list&lt;int&gt;) { std::cout &lt;&lt; \"twice-list\\n\"; }\n};\n\nint main()\n{\n    C c1 { {1,2}, {3} }; // twice-list ctor\n    C c2 { {1}, {2} }; // why not twice-list ?\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/efd37cedbd881785\">Live</a> demo.</p>\n<p>Why scalar values in braces for <code>c2</code> variable are not interpreted as separate std::initializer_list?</p>\n", "Tags": "<c++><language-lawyer><initializer-list>", "OwnerUserId": "3240681", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31211021_31216487_3": {"section_id": 599, "quality": 1.0, "length": 20}, "so_31211021_31216487_2": {"section_id": 599, "quality": 0.9285714285714286, "length": 13}, "so_31211021_31216487_4": {"section_id": 630, "quality": 0.96, "length": 24}, "so_31211021_31216487_0": {"section_id": 3324, "quality": 0.9615384615384616, "length": 25}, "so_31211021_31216487_1": {"section_id": 599, "quality": 0.5714285714285714, "length": 12}, "so_31211021_31216487_5": {"section_id": 599, "quality": 1.0, "length": 20}}, "n3337": {"so_31211021_31216487_4": {"section_id": 621, "quality": 0.8, "length": 20}, "so_31211021_31216487_2": {"section_id": 589, "quality": 0.9285714285714286, "length": 13}, "so_31211021_31216487_3": {"section_id": 589, "quality": 1.0, "length": 20}, "so_31211021_31216487_0": {"section_id": 3194, "quality": 0.9615384615384616, "length": 25}, "so_31211021_31216487_1": {"section_id": 589, "quality": 0.5714285714285714, "length": 12}, "so_31211021_31216487_5": {"section_id": 589, "quality": 1.0, "length": 20}}, "n4659": {"so_31211021_31216487_4": {"section_id": 658, "quality": 1.0, "length": 25}, "so_31211021_31216487_2": {"section_id": 622, "quality": 0.9285714285714286, "length": 13}, "so_31211021_31216487_3": {"section_id": 622, "quality": 1.0, "length": 20}, "so_31211021_31216487_0": {"section_id": 4090, "quality": 0.9230769230769231, "length": 24}, "so_31211021_31216487_1": {"section_id": 622, "quality": 0.9523809523809523, "length": 20}, "so_31211021_31216487_5": {"section_id": 622, "quality": 1.0, "length": 20}}}, "31211100": {"ParentId": "31211021", "CommentCount": "3", "CreationDate": "2015-07-03T16:32:56.720", "OwnerUserId": "3776174", "PostTypeId": "2", "Id": "31211100", "Score": "0", "Body": "<p><code>C c2 { {1}, {2} };</code></p>\n<p>This line does not pass in two arguments of <code>std::initializer_list&lt;int&gt;</code>, but rather, it is passing in one <code>std::initializer_list&lt;std::initializer_list&lt;int&gt; &gt;</code>. A solution would be to instead instantiate <code>c2</code> like so:</p>\n<p><code>C c2({1}, {2});</code></p>\n", "LastActivityDate": "2015-07-03T16:32:56.720"}});