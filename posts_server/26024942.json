post_cb({"bq_ids": {"n4140": {"so_26024942_26025026_1": {"length": 15, "quality": 0.5172413793103449, "section_id": 6186}}}, "26025026": {"PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow noreferrer\">constexpr</a> and <em>constant expressions</em> are related in that <em>constexpr</em> tells us that a variable or function can be used where a <em>constant expression</em> can be used. This is what cppreference tell us:</p>\n<blockquote>\n<p id=\"so_26024942_26025026_0\">The constexpr specifier declares that it is possible to evaluate the\n  value of the function or variable at compile time. Such variables and\n  functions can then be used where only compile time constant\n  expressions are allowed.</p>\n</blockquote>\n<p><em>Constant expresions</em> were present before C++11 and the rules governing constant expressions pre C++11 are covered in the same place in the <a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2005/n1804.pdf\" rel=\"nofollow noreferrer\">C++03 draft standard</a>(<em>this is the earliest public draft available closest to C++03</em>)<sup>1</sup> as the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">draft C++11 standard</a> which is section <code>5.19</code> <em>Constant expressions</em>, cppreference has a good summary on this topic in <a href=\"http://en.cppreference.com/w/cpp/language/constant_expression\" rel=\"nofollow noreferrer\">Constant expressions</a> page but it is geared toward C++11 and C++14 and it hard to tell what applies pre C++11.</p>\n<p>The standard pre C++11 lists where a constant expression is required, in first paragraph of <code>5.19</code> and it looks complete:</p>\n<blockquote>\n<p id=\"so_26024942_26025026_1\">In several places, C++ requires expressions that evaluate to an\n  integral or enumeration constant: as array bounds (8.3.4,\n  5.3.4), as case expressions (6.4.2), as bit-field lengths (9.6), as enumerator initializers (7.2), as static member initializers (9.4.2),\n  and as integral or enumeration non-type template arguments (14.3).</p>\n</blockquote>\n<p>the rest of paragraph <em>1</em> says:</p>\n<blockquote>\n<p id=\"so_26024942_26025026_2\">An integral constant-expression can involve only literals of\n  arithmetic types (2.13, 3.9.1), enumerators, non-volatile const\n  variables or static data members of integral or enumeration types\n  initialized with constant expressions (8.5), non-type template\n  parameters of integral or enumeration types, and sizeof expressions.\n  Floating literals (2.13.3) can appear only if they are cast to\n  integral or enumeration types. Only type conversions to integral or\n  enumeration types can be used. In particular, except in sizeof\n  expressions, functions, class objects, pointers, or references shall\n  not be used, and assignment, increment, decrement, function-call, or\n  comma operators shall not be used.</p>\n</blockquote>\n<p>and is followed by <code>5</code> more paragraphs that list further requirements.</p>\n<p>In C++11 there is a list of where constant expressions can be used in paragraph <em>3</em> but it does not clarify where they are required. You probably have to search for the term <em>constant expression</em> to find all the places where it is required and usually there will be a phrase similar to:</p>\n<blockquote>\n<p id=\"so_26024942_26025026_3\">shall be a constant expression</p>\n</blockquote>\n<p>The <em>shall</em> being the important term since violating a <em>shall</em> requirement makes the program ill-formed.</p>\n<p>Alternatively you can use <code>Annex A</code> <em>Grammar summary</em> and search for <em>constant-expression</em> and that should cover all the places in the grammar where a <em>constant expression</em> is required, for example:</p>\n<pre><code>enumerator = constant-expression\n</code></pre>\n<hr>\n<p>Footnote:</p>\n<ol>\n<li>This <a href=\"https://stackoverflow.com/a/4653479/1708801\">answer to Where do I find the current C or C++ standard documents?</a> has a complete list of the draft standards. Unfortunately the closest that is available to the public is from early <code>2005</code>. The earlier versions require authentication. As far as I know section <code>5.19</code> did not change much.</li>\n</ol>\n</hr>", "LastActivityDate": "2014-09-26T12:29:59.063", "LastEditorUserId": "-1", "Id": "26025026", "Score": "12", "CreationDate": "2014-09-24T19:34:10.923", "ParentId": "26024942", "CommentCount": "2", "LastEditDate": "2017-05-23T12:08:56.580", "OwnerUserId": "1708801"}, "26024942": {"ViewCount": "786", "Body": "<p>The <code>constexpr</code> keyword was introduced in C++11, as (I think) was the corresponding idea of \"constant expressions.\" However, this concept was implicitly present in C++98/c++03, since array declarations require a constant expression:</p>\n<pre><code>// valid:\nint a[sizeof(int)];\nint b[3+7];\nint c[13/4];\nconst int n = 3;\nint d[n];\n// invalid:\nint m = 4;\nint e[m];\n</code></pre>\n<p>There are other \"constant expressions\", i.e., expressions that can be (and/or must be) evaluated at compile-time; one example is template arguments.</p>\n<p>For pre-C++11, do the following exist, either in the C++98/03 standards or elsewhere?</p>\n<ul>\n<li>A complete list of syntactic constructs requiring constant expressions (e.g. array declarations and template instantiations)</li>\n<li>The rules governing such constant expressions (presumably this would just be a mapping from the items in the above list to their definitions in the standard)</li>\n</ul>\n", "AcceptedAnswerId": "26025026", "Title": "\"Constant expressions\" prior to C++11", "CreationDate": "2014-09-24T19:28:55.647", "Id": "26024942", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-09-26T12:29:59.063", "Score": "13", "OwnerUserId": "1858225", "Tags": "<c++><c++03><c++98><compile-time-constant><constant-expression>", "AnswerCount": "1"}});