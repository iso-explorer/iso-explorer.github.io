post_cb({"15235700": {"Id": "15235700", "PostTypeId": "2", "Body": "<p>I'm not a C programmer so I can't give you information on the uses of static in a C program properly, but when it comes to Object Oriented programming static basically declares a variable, or a function or a class to be the same throughout the life of the program. Take for example.</p>\n<pre><code>class A\n{\npublic:\n    A();\n    ~A();\n    void somePublicMethod();\nprivate:\n    void somePrivateMethod();\n};\n</code></pre>\n<p>When you instantiate this class in your Main you do something like this.</p>\n<pre><code>int main()\n{\n   A a1;\n   //do something on a1\n   A a2;\n   //do something on a2\n}\n</code></pre>\n<p>These two class instances are completely different from each other and operate independently from one another. But if you were to recreate the class A like this.</p>\n<pre><code>class A\n{\npublic:\n    A();\n    ~A();\n    void somePublicMethod();\n    static int x;\nprivate:\n    void somePrivateMethod();\n};\n</code></pre>\n<p>Lets go back to the main again.</p>\n<pre><code>int main()\n{\n   A a1;\n   a1.x = 1;\n   //do something on a1\n   A a2;\n   a2.x++;\n   //do something on a2\n}\n</code></pre>\n<p>Then a1 and a2 would share the same copy of int x whereby any operations on x in a1 would directly influence the operations of x in a2. So if I was to do this</p>\n<pre><code>int main()\n{\n   A a1;\n   a1.x = 1;\n   //do something on a1\n   cout &lt;&lt; a1.x &lt;&lt; endl; //this would be 1\n   A a2;\n   a2.x++;\n   cout &lt;&lt; a2.x &lt;&lt; endl; //this would be 2 \n   //do something on a2\n}\n</code></pre>\n<p>Both instances of the class A share static variables and functions. Hope this answers your question. My limited knowledge of C allows me to say that defining a function or variable as static means it is only visible to the file that the function or variable is defined as static in. But this would be better answered by a C guy and not me. C++ allows both C and C++ ways of declaring your variables as static because its completely backwards compatible with C.</p>\n", "LastActivityDate": "2013-03-05T22:52:18.447", "Score": "1", "CreationDate": "2013-03-05T22:52:18.447", "ParentId": "15235526", "CommentCount": "0", "OwnerUserId": "1480396"}, "15235626": {"Id": "15235626", "PostTypeId": "2", "Body": "<h1>Variables:</h1>\n<p><code>static</code> variables exist for the \"lifetime\" of the <em>translation unit that it's defined in</em>, and:  </p>\n<ul>\n<li>If it's in a namespace scope (i.e. outside of functions and classes), then it can't be accessed from any other translation unit.  This is known as \"internal linkage\". (Dont' do this in headers, it's just a terrible idea, you end up with a separate variable in each translation unit, which is crazy confusing)</li>\n<li>If it's a variable <em>in a function</em>, it can't be accessed from outside of the function, just like any other local variable. (this is the local they mentioned)</li>\n<li>class members have no restricted scope due to <code>static</code>, but can be addressed from the class as well as an instance (like <code>std::string::npos</code>).  [Note: you can <em>declare</em> static members in a class, but they should usually still be <em>defined</em> in a translation unit (cpp file), and as such, there's only one per class]</li>\n</ul>\n<p>Before any function in a translation unit is executed (possibly after <code>main</code> began execution), the variables with static storage duration in that translation unit will be \"constant initialized\" (to <code>constexpr</code> where possible, or zero otherwise), and then non-locals are \"dynamically initialized\" properly <em>in the order they are defined in the translation unit</em>  (for things like <code>std::string=\"HI\";</code> that aren't <code>constexpr</code>).  Finally, function-local statics are initialized the first time execution \"reaches\" the line where they are declared.  They are all destroyed in the reverse order of initialization.</p>\n<p>The easiest way to get all this right is to make all static variables that are not <code>constexpr</code> initialized into function static locals, which makes sure all of your statics/globals are initialized properly when you try to use them no matter what, thus preventing the <a href=\"https://stackoverflow.com/questions/3035422/static-initialization-order-fiasco\">static initialization order fiasco</a>.</p>\n<pre><code>T&amp; get_global() {\n    static T global = initial_value();\n    return global;\n}\n</code></pre>\n<p>Be careful, because when the spec says namespace-scope variables have \"static storage duration\" by default, they mean the \"lifetime of the translation unit\" bit, but that does <em>not</em> mean it can't be accessed outside of the file.</p>\n<h1>Functions</h1>\n<p>Significantly more straightforward, <code>static</code> is often used as a class member function, and only very rarely used for a free-standing function.  </p>\n<p>A static member function differs from a regular member function in that it can be called without an instance of a class, and since it has no instance, it cannot access non-static members of the class.  Static variables are useful when you want to have a function for a class that definitely absolutely does not refer to any instance members, or for managing <code>static</code> member variables.</p>\n<pre><code>struct A {\n    A() {++A_count;}\n    A(const A&amp;) {++A_count;}\n    A(A&amp;&amp;) {++A_count;}\n    ~A() {--A_count;}\n\n    static int get_count() {return A_count;}\nprivate:\n    static int A_count;\n}\n\nint main() {\n    A var;\n\n    int c0 = var.get_count(); //some compilers give a warning, but it's ok.\n    int c1 = A::get_count(); //normal way\n}\n</code></pre>\n<p>A <code>static</code> free-function means that the function will not be referred to by any other translation unit, and thus the linker can ignore it entirely.  This has a small number of purposes:</p>\n<ul>\n<li>Can be used in a cpp file to guarantee that the function is never used from any other file.</li>\n<li>Can be put in a header and every file will have it's own copy of the function.  Not useful, since inline does pretty much the same thing.</li>\n<li>Speeds up link time by reducing work</li>\n<li>Can put a function with the same name in each TU, and they can all do different things.  For instance, you could put a <code>static void log(const char*) {}</code> in each cpp file, and they could each all log in a different way.</li>\n</ul>\n", "LastEditorUserId": "845092", "LastActivityDate": "2017-10-22T06:09:39.587", "Score": "91", "CreationDate": "2013-03-05T22:46:29.530", "ParentId": "15235526", "CommentCount": "16", "LastEditDate": "2017-10-22T06:09:39.587", "OwnerUserId": "845092"}, "15235889": {"Id": "15235889", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15235526_15235889_0\">What does it mean with local variable? Is that a function local variable?</p>\n</blockquote>\n<p>Yes - Non-global, such as a function local variable.</p>\n<blockquote>\n<p id=\"so_15235526_15235889_1\">Because there's also that when you declare a function local as static that it is only initialized once, the first time it enters this function.</p>\n</blockquote>\n<p>Right.</p>\n<blockquote>\n<p id=\"so_15235526_15235889_2\">It also only talks about storage duration with regards to class members, what about it being non instance specific, that's also a property of static no? Or is that storage duration?</p>\n</blockquote>\n<pre><code>class R { static int a; }; // &lt;&lt; static lives for the duration of the program\n</code></pre>\n<p>that is to say, all instances of <code>R</code> share <code>int R::a</code> -- <code>int R::a</code> is never copied.</p>\n<blockquote>\n<p id=\"so_15235526_15235889_3\">Now what about the case with static and file scope?</p>\n</blockquote>\n<p>Effectively a global which has constructor/destructor where appropriate -- initialization is not deferred until access.</p>\n<blockquote>\n<p id=\"so_15235526_15235889_4\">How does static relate to the linkage of a variable?</p>\n</blockquote>\n<p>For a function local, it is external. Access: It's accessible to the function (unless of course, you return it).</p>\n<p>For a class, it is external. Access: Standard access specifiers apply (public, protected, private).</p>\n<p><code>static</code> can also specify internal linkage, depending on where it's declared (file/namespace).</p>\n<blockquote>\n<p id=\"so_15235526_15235889_5\">This whole static keyword is downright confusing</p>\n</blockquote>\n<p>It has too many purposes in C++.</p>\n<blockquote>\n<p id=\"so_15235526_15235889_6\">can someone clarify the different uses for it English and also tell me when to initialize a static class member?</p>\n</blockquote>\n<p>It's automatically initialized before <code>main</code> if it's loaded and has a constructor. That might sound like a good thing, but initialization\u00a0order is largely beyond your control, so complex initialization becomes very difficult to maintain, and you want to minimize this -- if you must have a static, then function local scales much better across libraries and projects. As far as data with static storage duration, you should try to minimize this design, particularly if mutable (global variables). Initialization 'time' also varies for a number of reasons -- the loader and kernel have some tricks to minimize memory footprints and defer initialization, depending on the data in question.</p>\n", "LastEditorUserId": "191596", "LastActivityDate": "2013-03-05T23:18:49.297", "Score": "1", "CreationDate": "2013-03-05T23:06:29.200", "ParentId": "15235526", "CommentCount": "0", "LastEditDate": "2013-03-05T23:18:49.297", "OwnerUserId": "191596"}, "30119602": {"Id": "30119602", "PostTypeId": "2", "Body": "<p><strong>Static Object:</strong> We can define class members static using static keyword. When we declare a member of a class as static it means no matter how many objects of the class are created, there is only one copy of the static member.</p>\n<p>A static member is shared by all objects of the class. All static data is initialized to zero when the first object is created, if no other initialization is present. We can't put it in the class definition but it can be initialized outside the class as done in the following example by redeclaring the static variable, using the scope resolution operator :: to identify which class it belongs to.</p>\n<p>Let us try the following example to understand the concept of static data members:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Box\n{\n   public:\n      static int objectCount;\n      // Constructor definition\n      Box(double l=2.0, double b=2.0, double h=2.0)\n      {\n         cout &lt;&lt;\"Constructor called.\" &lt;&lt; endl;\n         length = l;\n         breadth = b;\n         height = h;\n         // Increase every time object is created\n         objectCount++;\n      }\n      double Volume()\n      {\n         return length * breadth * height;\n      }\n   private:\n      double length;     // Length of a box\n      double breadth;    // Breadth of a box\n      double height;     // Height of a box\n};\n\n// Initialize static member of class Box\nint Box::objectCount = 0;\n\nint main(void)\n{\n   Box Box1(3.3, 1.2, 1.5);    // Declare box1\n   Box Box2(8.5, 6.0, 2.0);    // Declare box2\n\n   // Print total number of objects.\n   cout &lt;&lt; \"Total objects: \" &lt;&lt; Box::objectCount &lt;&lt; endl;\n\n   return 0;\n}\n</code></pre>\n<p>When the above code is compiled and executed, it produces the following result:</p>\n<pre><code>Constructor called.\nConstructor called.\nTotal objects: 2\n</code></pre>\n<p><strong>Static Function Members:</strong>\nBy declaring a function member as static, you make it independent of any particular object of the class. A static member function can be called even if no objects of the class exist and the static functions are accessed using only the class name and the scope resolution operator ::.</p>\n<p>A static member function can only access static data member, other static member functions and any other functions from outside the class.</p>\n<p>Static member functions have a class scope and they do not have access to the this pointer of the class. You could use a static member function to determine whether some objects of the class have been created or not.</p>\n<p>Let us try the following example to understand the concept of static function members:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Box\n{\n   public:\n      static int objectCount;\n      // Constructor definition\n      Box(double l=2.0, double b=2.0, double h=2.0)\n      {\n         cout &lt;&lt;\"Constructor called.\" &lt;&lt; endl;\n         length = l;\n         breadth = b;\n         height = h;\n         // Increase every time object is created\n         objectCount++;\n      }\n      double Volume()\n      {\n         return length * breadth * height;\n      }\n      static int getCount()\n      {\n         return objectCount;\n      }\n   private:\n      double length;     // Length of a box\n      double breadth;    // Breadth of a box\n      double height;     // Height of a box\n};\n\n// Initialize static member of class Box\nint Box::objectCount = 0;\n\nint main(void)\n{\n\n   // Print total number of objects before creating object.\n   cout &lt;&lt; \"Inital Stage Count: \" &lt;&lt; Box::getCount() &lt;&lt; endl;\n\n   Box Box1(3.3, 1.2, 1.5);    // Declare box1\n   Box Box2(8.5, 6.0, 2.0);    // Declare box2\n\n   // Print total number of objects after creating object.\n   cout &lt;&lt; \"Final Stage Count: \" &lt;&lt; Box::getCount() &lt;&lt; endl;\n\n   return 0;\n}\n</code></pre>\n<p>When the above code is compiled and executed, it produces the following result:</p>\n<pre><code>Inital Stage Count: 0\nConstructor called.\nConstructor called.\nFinal Stage Count: 2\n</code></pre>\n", "LastActivityDate": "2015-05-08T08:49:27.730", "Score": "1", "CreationDate": "2015-05-08T08:49:27.730", "ParentId": "15235526", "CommentCount": "1", "OwnerUserId": "1952158"}, "43442151": {"Id": "43442151", "PostTypeId": "2", "Body": "<p>In order to clarify the question, I would rather categorize the usage of 'static' keyword in three different forms: </p>\n<p><strong>(A). variables</strong></p>\n<p><strong>(B). functions</strong></p>\n<p><strong>(C). member variables/functions of classes</strong></p>\n<p>the explanation follows below for each of the sub headings:</p>\n<p><strong>(A) 'static' keyword for variables</strong></p>\n<p>This one can be little tricky however if explained and understood properly, it's pretty straightforward.</p>\n<p>To explain this, first it is really useful to know about the <strong>scope, duration\n and linkage</strong> of variables, without which things are always difficult to see\n through the murky concept of staic keyword</p>\n<p><strong>1. Scope</strong> : Determines where in the file, the variable is accessible. It can be of two types: (i) <strong>Local or Block Scope</strong>. (ii) <strong>Global Scope</strong></p>\n<p><strong>2. Duration</strong> : Determines when a variable is created and destroyed. Again it's of two types: (i) <strong>Automatic Duration</strong> (for variables having Local or Block scope). (ii) <strong>Static Duration</strong> (for variables having Global Scope). </p>\n<p><strong>3. Linkage</strong>: Determines whether a variable can be accessed (or linked ) in another file. Again ( and luckily) it is of two types: (i) <strong>Internal Linkage</strong> \n(for variables having Block Scope and Global Scope) (ii) <strong>External Linkage</strong> (for variables having only for Global Scope)</p>\n<p>Let's refer an example below for better understanding:</p>\n<pre><code>//main file\n#include &lt;iostream&gt;\n\nint global_var1; //has global scope\nconst global_var2(1.618); //has global scope\n\nint main()\n{\n//these variables are local to the block main.\n//they have automatic duration, i.e, they are created when the main() is \n//  executed and destroyed, when main goes out of scope\n int local_var1(23);\n const double local_var2(3.14);\n\n {\n/* this is yet another block, all variables declared within this block are \n have local scope limited within this block. */\n// all variables declared within this block too have automatic duration, i.e, \n/*they are created at the point of definition within this block,\n and destroyed as soon as this block ends */\n   char block_char1;\n   int local_var1(32) //NOTE: this has been re-declared within the block, \n//it shadows the local_var1 declared outside\n\n std::cout &lt;&lt; local_var1 &lt;&lt;\"\\n\"; //prints 32\n\n  }//end of block\n  //local_var1 declared inside goes out of scope\n\n std::cout &lt;&lt; local_var1 &lt;&lt; \"\\n\"; //prints 23\n\n global_var1 = 29; //global_var1 has been declared outside main (global scope)\n std::cout &lt;&lt; global_var1 &lt;&lt; \"\\n\"; //prints 29\n std::cout &lt;&lt; global_var2 &lt;&lt; \"\\n\"; //prints 1.618\n\n return 0;\n}  //local_var1, local_var2 go out of scope as main ends\n//global_var1, global_var2 go out of scope as the program terminates \n//(in this case program ends with end of main, so both local and global\n//variable go out of scope together\n</code></pre>\n<p>(Readers please be patient: This is the foundation needed to understand the usage of 'static' keyword for various cases in variables) </p>\n<p>Now comes the concept of Linkage. When a global variable defined in one file is intended to be used in another file, the linkage of the variable plays an important role. </p>\n<p>The Linkage of global variables is specified by the keywords: \n(i) <strong>static</strong> , and, (ii) <strong>extern</strong> </p>\n<p>( Now you get the explanation ;-) )</p>\n<p>static keyword can be applied to variables with local and global scope, and in both the cases, they mean different things. I will first explain the usage of 'static' keyword in variables with global scope ( where I also clarify the usage of keyword 'extern') and later the for those with local scope. </p>\n<p><strong>1. Static Keyword for variables with global scope</strong></p>\n<p>Global variables have static duration, meaning they don't go out of scope when a particular block of code (for e.g main() ) in which it is used ends . Depending upon the linkage, they can be either accessed only within the same file where they are declared (for static global variable), or outside the file even outside the file in which they are declared (extern type global variables)</p>\n<p>In the case of a global variable having extern specifier, and if this variable is being accessed outside the file in which it has been initialized, it has to be forward declared in the file where it's being used, just like a function has to be forward declared if it's definition is in a file different from where it's being used. </p>\n<p>In contrast, if the global variable has static keyword, it cannot be used in a file outside of which it has been declared. </p>\n<p>(see example below for clarification)</p>\n<p>eg: </p>\n<pre><code>//main2.cpp\n static int global_var3 = 23;  /*static global variable, cannot be                            \n                                accessed in anyother file */\n extern double global_var4 = 71; /*can be accessed outside this file                  linked to main2.cpp */\n int main() { return 0; }\n</code></pre>\n<p>main3.cpp</p>\n<pre><code>//main3.cpp\n#include &lt;iostream&gt;\n\nint main()\n{\n   extern int gloabl_var4; /*this variable refers to the gloabal_var4\n                            defined in the main2.cpp file */\n  std::cout &lt;&lt; global_var4 &lt;&lt; \"\\n\"; //prints 71;\n\n  return 0;\n}\n</code></pre>\n<p>now any variable in c++ can be either a const or a non-const and for each 'const-ness' we get two case of default c++ linkage, in case none is specified:</p>\n<p>(i) <strong>If a global variable is non-const, its linkage  is extern by default</strong>, i.e, the non-const global variable can be accessed in another .cpp file by forward declaration using the extern keyword (in other words, non const global variables have external linkage ( with static duration of course)). Also usage of extern keyword in the original file where it has been defined is redundant.\n    In this case <strong><em>to make a non-const global variable inaccessible to external file, use the specifier 'static' before the type of the variable</em></strong>.</p>\n<p>(ii) <strong>If a global variable is const, its linkage is static by default</strong>, i.e a const global variable cannot be accessed in a file other than where it is defined, (in other words, const global variables have internal linkage (with static duration of course)). Also usage of static keyword to prevent a const global variable from being accessed in another file is redundant. \n    Here, <strong><em>to make a const global variable have an external linkage, use the specifier 'extern' before the type of the variable</em></strong></p>\n<p>Here's a summary for global scope variables with various linkages</p>\n<pre><code>//globalVariables1.cpp \n\n// defining uninitialized vairbles\nint globalVar1; //  uninitialized global variable with external linkage \nstatic int globalVar2; // uninitialized global variable with internal linkage\nconst int globalVar3; // error, since const variables must be initialized upon declaration\nconst int globalVar4 = 23; //correct, but with static linkage (cannot be accessed outside the file where it has been declared*/\nextern const double globalVar5 = 1.57; //this const variable ca be accessed outside the file where it has been declared\n</code></pre>\n<p>Next we investigate how the above global variables behave when accessed in a different file.</p>\n<pre><code>//using_globalVariables1.cpp (eg for the usage of global variables above)\n\n// Forward declaration via extern keyword:\n extern int globalVar1; // correct since globalVar1 is not a const or static\n extern int globalVar2; //incorrect since globalVar2 has internal linkage\n extern const int globalVar4; /* incorrect since globalVar4 has no extern \n                         specifier, limited to internal linkage by\n                         default (static specifier for const variables) */\n extern const double globalVar5; /*correct since in the previous file, it \n                           has extern specifier, no need to initialize the\n                       const variable here, since it has already been\n                       legitimately defined perviously */\n</code></pre>\n<p><strong>2. Static Keyword for variables with Local Scope</strong></p>\n<p>Earlier, I mentioned that variables with local scope have automatic duration, i.e they come to exist when the block is entered ( be it a normal block, be it a function block) and cease to exist when the block ends, long story short, <strong><em>variables with local scope have automatic duration</em></strong></p>\n<p>If <strong>static</strong> specifier is applied to a local variable within a block, it <strong>changes the duration of the variable from automatic to static</strong></p>\n<p>lets take a look at an example. </p>\n<pre><code>//localVarDemo.cpp\n #include &lt;iostream&gt;\n\n int localNextID()\n{\n  int tempID = 1;  //tempID created here\n  return tempID++; //copy of tempID returned and tempID incremented to 2\n} //tempID destroyed here, hence value of tempID lost\n\nint newNextID()\n{\n  static int newID = 0;//newID has static duration, with internal linkage\n  return newID++; //copy of newID returned and newID incremented by 1\n}  //newID doesn't get destroyed here :-)\n\n\nint main()\n{\n  int employeeID1 = nextID();  //employeeID1 = 1\n  int employeeID2 = nextID();  // employeeID2 = 1 again (not desired)\n  int employeeID3 = newNextID(); //employeeID3 = 0;\n  int employeeID4 = newNextID(); //employeeID4 = 1;\n  int employeeID5 = newNextID(); //employeeID5 = 2;\n  return 0;\n}\n</code></pre>\n<p>this concludes my explanation for the static keyword applied to variables. pheww!!!</p>\n<p><strong>B. 'static' keyword used for functions</strong> </p>\n<p>in terms of functions, the static keyword has a straightforward meaning. Here, it <strong>refers to linkage of the function</strong> \nNormally all functions declared within a cpp file have external linkage by default, i.e a function defined in one file can be used in another cpp file by forward declaration. </p>\n<p><strong>using a static keyword before the function declaration limits its linkage to internal</strong> , i.e a static function cannot be used within a file outside of its definition.</p>\n<p><strong>C. Staitc Keyword used for member variables and functions of classes</strong></p>\n<p><strong>1. 'static' keyword for member variables of classes</strong></p>\n<p>I start directly with an example here</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass DesignNumber\n{\n  private:\n\n      static int m_designNum;  //design number\n      int m_iteration;     // number of iterations performed for the design\n\n  public:\n    DesignNumber() {     }  //default constructor\n\n   int  getItrNum() //get the iteration number of design\n   {\n      m_iteration = m_designNum++;\n      return m_iteration;\n   }\n     static int m_anyVariable;  //public static variable\n};\nint DesignNumber::m_designNum = 0; // starting with design id = 0\n                     // note : no need of static keyword here\n                     //causes compiler error if static keyword used\nint DesignNumber::m_anyNumber = 99; /* initialization of inclass public \n                                    static member  */\nenter code here\n\nint main()\n{\n   DesignNumber firstDesign, secondDesign, thirdDesign;\n   std::cout &lt;&lt; firstDesign.getItrNum() &lt;&lt; \"\\n\";  //prints 0\n   std::cout &lt;&lt; secondDesign.getItrNum() &lt;&lt; \"\\n\"; //prints 1\n   std::cout &lt;&lt; thirdDesign.getItrNum() &lt;&lt; \"\\n\";  //prints 2\n\n   std::cout &lt;&lt; DesignNumber::m_anyNumber++ &lt;&lt; \"\\n\";  /* no object\n                                        associated with m_anyNumber */\n   std::cout &lt;&lt; DesignNumber::m_anyNumber++ &lt;&lt; \"\\n\"; //prints 100\n   std::cout &lt;&lt; DesignNumber::m_anyNumber++ &lt;&lt; \"\\n\"; //prints 101\n\n   return 0;\n}\n</code></pre>\n<p>In this example, the static variable m_designNum retains its value and this single private member variable (because it's static) is shared b/w all the variables of the object type DesignNumber</p>\n<p>Also like other member variables, static member variables of a class are not associated with any class object, which is demonstrated by the printing of anyNumber in the main function</p>\n<p><strong>const vs non-const static member variables in class</strong></p>\n<p><strong>(i) non-const class static member variables</strong>\nIn the previous example the static members (both public and private) were non constants. ISO standard forbids non-const static members to be initialized in the class. Hence as in previous example, they must be initalized after the class definition, with the caveat that the static keyword needs to be omitted</p>\n<p><strong>(ii) const-static member variables of class</strong>\nthis is straightforward and goes with the convention of other const member variable initialization, i.e the const static member variables of a class <em>can be</em> initialized at the point of declaration and they can be initialized at the end of the class declaration with one caveat that the keyword const needs to be added to the static member when being initialized after the class definition. </p>\n<p>I would however, recommend to initialize the const static member variables at the point of declaration. This goes with the standard C++ convention and makes the code look cleaner</p>\n<p>for more examples on static member variables in a class look up the following link from learncpp.com \n<a href=\"http://www.learncpp.com/cpp-tutorial/811-static-member-variables/\" rel=\"nofollow noreferrer\">http://www.learncpp.com/cpp-tutorial/811-static-member-variables/</a></p>\n<p><strong>2. 'static' keyword for member function of classes</strong></p>\n<p>Just like member variables of classes can ,be static, so can member functions of classes. Normal member functions of classes are always associated with a object of the class type. In contrast, static member functions of a class are not associated with any object of the class, i.e they have no *this pointer. </p>\n<p>Secondly since the static member functions of the class have no *this pointer, they can be called using the class name and scope resolution operator in the main function (ClassName::functionName(); ) </p>\n<p>Thirdly static member functions of a class can only access static member variables of a class, since non-static member variables of a class must belong to a class object. </p>\n<p>for more examples on static member functions in a class look up the following link from learncpp.com</p>\n<p><a href=\"http://www.learncpp.com/cpp-tutorial/812-static-member-functions/\" rel=\"nofollow noreferrer\">http://www.learncpp.com/cpp-tutorial/812-static-member-functions/</a></p>\n", "LastEditorUserId": "4726537", "LastActivityDate": "2017-08-15T13:10:33.997", "Score": "4", "CreationDate": "2017-04-16T21:06:56.720", "ParentId": "15235526", "CommentCount": "0", "LastEditDate": "2017-08-15T13:10:33.997", "OwnerUserId": "4726537"}, "15235526": {"ViewCount": "105705", "Body": "<p>The keyword <code>static</code> is one which has several meanings in C++ that I find very confusing and I can never bend my mind around how its actually supposed to work.</p>\n<p>From what I understand there is <code>static</code> storage duration, which means that it lasts for the lifetime of the program in the case of a global, but when you're talking about a local, it means that it's zero initialized by default.</p>\n<p>The C++ Standard says this for class data members with the keyword <code>static</code>:</p>\n<p><strong>3.7.1 Static storage duration [basic.stc.static]</strong></p>\n<blockquote>\n<p id=\"so_15235526_15235526_0\">3 The keyword static can be used to declare a local variable with static storage duration.</p>\n<p id=\"so_15235526_15235526_1\">4 The keyword static applied to a class data member in a class definition gives the data member static storage duration.</p>\n</blockquote>\n<p>What does it mean with <em>local variable</em>? Is that a function local variable? Because there's also that when you declare a function local as <code>static</code> that it is only initialized once, the first time it enters this function.</p>\n<p>It also only talks about storage duration with regards to class members, what about it being non instance specific, that's also a property of <code>static</code> no? Or is that storage duration?</p>\n<p>Now what about the case with <code>static</code> and file scope? Are all global variables considered to have static storage duration by default? The following (from section 3.7.1)  seems to indicate so:</p>\n<blockquote>\n<p id=\"so_15235526_15235526_2\">1 All variables which do not have dynamic storage duration, do not have thread storage duration, and are <strong>not local</strong> have static storage duration. The storage for these entities shall last for the duration of the program (3.6.2, 3.6.3)</p>\n</blockquote>\n<p>How does <code>static</code> relate to the linkage of a variable?  </p>\n<p>This whole <code>static</code> keyword is downright confusing, can someone clarify the different uses for it English and also tell me <em>when</em> to initialize a <code>static</code> class member? </p>\n", "AcceptedAnswerId": "15235626", "Title": "The static keyword and its various uses in C++", "CreationDate": "2013-03-05T22:38:26.797", "Id": "15235526", "CommentCount": "0", "FavoriteCount": "97", "PostTypeId": "1", "LastEditDate": "2013-03-05T22:43:28.787", "LastEditorUserId": "174614", "LastActivityDate": "2017-10-22T06:09:39.587", "Score": "122", "OwnerUserId": "174614", "Tags": "<c++><static>", "AnswerCount": "9"}, "15235708": {"Id": "15235708", "PostTypeId": "2", "Body": "<p>It's actually quite simple. If you declare a variable as static in the scope of a function, its value is preserved between successive calls to that function. So:</p>\n<pre><code>int myFun()\n{\nstatic int i=5;\ni++;\nreturn i;\n}\nint main()\n{\nprintf(\"%d\", myFun());\nprintf(\"%d\", myFun());\nprintf(\"%d\", myFun());\n}\n</code></pre>\n<p>will show <code>678</code> instead of <code>666</code>, because it remembers the incremented value.</p>\n<p>As for the static members, they preserve their value across instances of the class. So the following code:</p>\n<pre><code>struct A\n{\nstatic int a;\n};\nint main()\n{\nA first;\nA second;\nfirst.a = 3;\nsecond.a = 4;\nprintf(\"%d\", first.a);\n}\n</code></pre>\n<p>will print 4, because first.a and second.a are essentially the same variable. As for the initialization, see <a href=\"https://stackoverflow.com/questions/185844/initializing-private-static-members\">this question.</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-03-05T22:52:59.523", "Score": "14", "CreationDate": "2013-03-05T22:52:59.523", "ParentId": "15235526", "CommentCount": "0", "LastEditDate": "2017-05-23T12:10:39.227", "OwnerUserId": "1299367"}, "bq_ids": {"n4140": {"so_15235526_15235526_2": {"length": 18, "quality": 0.8181818181818182, "section_id": 7164}, "so_15235526_15235526_0": {"length": 9, "quality": 0.9, "section_id": 7166}, "so_15235526_15235526_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 7167}}, "n3337": {"so_15235526_15235526_2": {"length": 18, "quality": 0.8181818181818182, "section_id": 6908}, "so_15235526_15235526_0": {"length": 9, "quality": 0.9, "section_id": 6910}, "so_15235526_15235526_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 6911}}, "n4659": {"so_15235526_15235526_2": {"length": 18, "quality": 0.8181818181818182, "section_id": 8672}, "so_15235526_15235526_0": {"length": 9, "quality": 0.9, "section_id": 8674}, "so_15235526_15235526_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 8675}}}, "15235701": {"Id": "15235701", "PostTypeId": "2", "Body": "<p>Static storage duration means that the variable resides in the same place in memory through the lifetime of the program. </p>\n<p>Linkage is orthogonal to this. </p>\n<p><strong>I think this is the most important distinction you can make.</strong> Understand this and the rest, as well as remembering it, should come easy (not addressing @Tony directly, but whoever might read this in the future).</p>\n<p>The keyword <code>static</code> can be used to denote internal linkage <strong>and</strong> static storage, but in essence these are different.</p>\n<blockquote>\n<p id=\"so_15235526_15235701_0\">What does it mean with local variable? Is that a function local variable?</p>\n</blockquote>\n<p>Yes. Regardless of when the variable is initialized (on first call to the function and when execution path reaches the declaration point), it will reside in the same place in memory for the life of the program. In this case, <code>static</code> gives it static storage.</p>\n<blockquote>\n<p id=\"so_15235526_15235701_1\">Now what about the case with static and file scope? Are all global variables considered to have static storage duration by default? </p>\n</blockquote>\n<p>Yes, all globals have by definition static storage duration (now that we cleared up what that means). <strong>But</strong> namespace scoped variables aren't declared with <code>static</code>, because that would give them internal linkage, so a variable per translation unit.</p>\n<blockquote>\n<p id=\"so_15235526_15235701_2\">How does static relate to the linkage of a variable?</p>\n</blockquote>\n<p>It gives namespace-scoped variables internal linkage. It gives members and local variables static storage duration.</p>\n<p>Let's expand on all this:</p>\n<pre><code>//\n\nstatic int x; //internal linkage\n              //non-static storage - each translation unit will have its own copy of x\n              //NOT A TRUE GLOBAL!\n\nint y;        //static storage duration (can be used with extern)\n              //actual global\n              //external linkage\nstruct X\n{\n   static int x;     //static storage duration - shared between classes\n};\n\nvoid foo()\n{\n   static int x;     //static storage duration - shared between calls\n}\n</code></pre>\n<blockquote>\n<p id=\"so_15235526_15235701_3\">This whole static keyword is downright confusing</p>\n</blockquote>\n<p>Definitely, unless you're familiar with it. :) Trying to avoid adding new keywords to the language, the committee re-used this one, IMO, to this effect - confusion. It's used to signify different things (might I say, probably opposing things).</p>\n", "LastEditorUserId": "673730", "LastActivityDate": "2013-03-05T23:23:15.697", "Score": "50", "CreationDate": "2013-03-05T22:52:20.890", "ParentId": "15235526", "CommentCount": "0", "LastEditDate": "2013-03-05T23:23:15.697", "OwnerUserId": "673730"}, "15235869": {"Id": "15235869", "PostTypeId": "2", "Body": "<p>When you a declare a <code>static</code> variable at file scope, then that variable is only available in <em>that</em> particular file (technically, the *translation unit, but let's not complicate this too much). For example:</p>\n<p><strong>a.cpp</strong></p>\n<pre><code>static int x = 7;\n\nvoid printax()\n{\n    cout &lt;&lt; \"from a.cpp: x=\" &lt;&lt; x &lt;&lt; endl;\n}\n</code></pre>\n<p><strong>b.cpp</strong></p>\n<pre><code>static int x = 9;\n\nvoid printbx()\n{\n    cout &lt;&lt; \"from b.cpp: x=\" &lt;&lt; x &lt;&lt; endl;\n}\n</code></pre>\n<p><strong>main.cpp:</strong></p>\n<pre><code>int main(int, char **)\n{\n    printax(); // Will print 7\n    printbx(); // Will print 9\n\n    return 0;\n}\n</code></pre>\n<p>For a <em>local</em> variable, <code>static</code> means that the variable will be zero-initialized <em>and</em> retain its value between calls:</p>\n<pre><code>unsigned int powersoftwo()\n{\n    static unsigned lastpow;\n\n    if(lastpow == 0)\n        lastpow = 1;\n    else\n        lastpow *= 2;\n\n    return lastpow;\n}\n\nint main(int, char **)\n{\n    for(int i = 0; i != 10; i++)\n        cout &lt;&lt; \"2^\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; powersoftwo() &lt;&lt; endl;\n}\n</code></pre>\n<p>For <em>class</em> variables, it means that there is only a single instance of that variable that is shared among all members of that class. Depending on permissions, the variable can be accessed from outside the class using its fully qualified name.</p>\n<pre><code>class Test\n{\nprivate:\n    static char *xxx;\n\npublic:\n    static int yyy;\n\npublic:\n    Test()\n    {        \n        cout &lt;&lt; this &lt;&lt; \"The static class variable xxx is at address \"\n             &lt;&lt; static_cast&lt;void *&gt;(xxx) &lt;&lt; endl;\n        cout &lt;&lt; this &lt;&lt; \"The static class variable yyy is at address \"\n             &lt;&lt; static_cast&lt;void *&gt;(&amp;y) &lt;&lt; endl;\n    }\n};\n\n// Necessary for static class variables.\nchar *Test::xxx = \"I'm Triple X!\";\nint Test::yyy = 0;\n\nint main(int, char **)\n{\n    Test t1;\n    Test t2;\n\n    Test::yyy = 666;\n\n    Test t3;\n};\n</code></pre>\n<p>Marking a non-class function as <code>static</code> makes the function only accessible from that file and inaccessible from other files. </p>\n<p><strong>a.cpp</strong></p>\n<pre><code>static void printfilename()\n{ // this is the printfilename from a.cpp - \n  // it can't be accessed from any other file\n    cout &lt;&lt; \"this is a.cpp\" &lt;&lt; endl;\n}\n</code></pre>\n<p><strong>b.cpp</strong></p>\n<pre><code>static void printfilename()\n{ // this is the printfilename from b.cpp - \n  // it can't be accessed from any other file\n    cout &lt;&lt; \"this is b.cpp\" &lt;&lt; endl;\n}\n</code></pre>\n<p>For class member functions, marking them as <code>static</code> means that the function doesn't need to be called on a particular instance of an object (i.e. it doesn't have a <code>this</code> pointer).</p>\n<pre><code>class Test\n{\nprivate:\n    static int count;\n\npublic:\n    static int GetTestCount()\n    {\n        return count;\n    };\n\n    Test()\n    {\n        cout &lt;&lt; this &lt;&lt; \"Created an instance of Test\" &lt;&lt; endl;\n        count++;\n    }\n\n    ~Test()\n    {\n        cout &lt;&lt; this &lt;&lt; \"Destroyed an instance of Test\" &lt;&lt; endl;\n        count--;\n    }\n};\n\nint Test::count = 0;\n\nint main(int, char **)\n{\n    Test *arr[10] = { NULL };\n\n    for(int i = 0; i != 10; i++)\n        arr[i] = new Test();\n\n    cout &lt;&lt; \"There are \" &lt;&lt; Test::GetTestCount() &lt;&lt; \" instances of the Test class!\" &lt;&lt; endl;\n\n    // now, delete them all except the first and last!\n    for(int i = 1; i != 9; i++)\n        delete arr[i];        \n\n    cout &lt;&lt; \"There are \" &lt;&lt; Test::GetTestCount() &lt;&lt; \" instances of the Test class!\" &lt;&lt; endl;\n\n    delete arr[0];\n\n    cout &lt;&lt; \"There are \" &lt;&lt; Test::GetTestCount() &lt;&lt; \" instances of the Test class!\" &lt;&lt; endl;\n\n    delete arr[9];\n\n    cout &lt;&lt; \"There are \" &lt;&lt; Test::GetTestCount() &lt;&lt; \" instances of the Test class!\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "2092947", "LastActivityDate": "2015-04-14T14:31:07.973", "Score": "6", "CreationDate": "2013-03-05T23:04:58.170", "ParentId": "15235526", "CommentCount": "0", "LastEditDate": "2015-04-14T14:31:07.973", "OwnerUserId": "970543"}, "15235578": {"Id": "15235578", "PostTypeId": "2", "Body": "<p>Static variables are shared between every instance of a class, instead of each class having their own variable.   </p>\n<pre><code>class MyClass\n{\n    public:\n    int myVar; \n    static int myStaticVar;\n};\n\n//Static member variables must be initialized. Unless you're using C++11, or it's an integer type,\n//they have to be defined and initialized outside of the class like this:\nMyClass::myStaticVar = 0;\n\nMyClass classA;\nMyClass classB;\n</code></pre>\n<p>Each instance of 'MyClass' has their own 'myVar', but share the same 'myStaticVar'.\nIn fact, you don't even need an instance of MyClass to access 'myStaticVar', and you can access it outside of the class like this:</p>\n<pre><code>MyClass::myStaticVar //Assuming it's publicly accessible.\n</code></pre>\n<p>When used inside a function as a local variable (and not as a class member-variable) the static keyword does something different. It allows you to create a persistent variable, without giving global scope.</p>\n<pre><code>int myFunc()\n{\n   int myVar = 0; //Each time the code reaches here, a new variable called 'myVar' is initialized.\n   myVar++;\n\n   //Given the above code, this will *always* print '1'.\n   std::cout &lt;&lt; myVar &lt;&lt; std::endl;\n\n   //The first time the code reaches here, 'myStaticVar' is initialized. But ONLY the first time.\n   static int myStaticVar = 0;\n\n   //Each time the code reaches here, myStaticVar is incremented.\n   myStaticVar++;\n\n   //This will print a continuously incrementing number,\n   //each time the function is called. '1', '2', '3', etc...\n   std::cout &lt;&lt; myStaticVar &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It's a global variable in terms of persistence... but without being global in scope/accessibility.</p>\n<p>You can also have static member functions. Static functions are basically non-member functions, but inside the class name's namespace, and with private access to the class's members.</p>\n<pre><code>class MyClass\n{\n    public:\n    int Func()\n    {\n        //...do something...\n    }\n\n    static int StaticFunc()\n    {\n        //...do something...\n    }\n};\n\nint main()\n{\n   MyClass myClassA;\n   myClassA.Func(); //Calls 'Func'.\n   myClassA.StaticFunc(); //Calls 'StaticFunc'.\n\n   MyClass::StaticFunc(); //Calls 'StaticFunc'.\n   MyClass::Func(); //Error: You can't call a non-static member-function without a class instance!\n\n   return 0;\n}\n</code></pre>\n<p>When you call a member-function, there's a hidden parameter called 'this', that is a pointer to the instance of the class calling the function.\nStatic member functions <strong>don't</strong> have that hidden parameter... they are callable without a class instance, but also cannot access non-static member variables of a class, because they don't have a 'this' pointer to work with. They aren't being called on any specific class instance.</p>\n", "LastEditorUserId": "1177073", "LastActivityDate": "2016-09-09T15:33:54.000", "Score": "6", "CreationDate": "2013-03-05T22:42:51.453", "ParentId": "15235526", "CommentCount": "7", "LastEditDate": "2016-09-09T15:33:54.000", "OwnerUserId": "1177073"}});