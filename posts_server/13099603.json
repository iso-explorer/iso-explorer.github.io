post_cb({"13099603": {"CommentCount": "2", "AcceptedAnswerId": "13099664", "CreationDate": "2012-10-27T11:06:10.553", "LastActivityDate": "2012-10-27T11:27:20.410", "PostTypeId": "1", "ViewCount": "3485", "FavoriteCount": "4", "Title": "C++11 move constructor not called, default constructor preferred", "Id": "13099603", "Score": "14", "Body": "<p>Suppose we have this class:</p>\n<pre><code>class X {\npublic:\n    explicit X (char* c) { cout&lt;&lt;\"ctor\"&lt;&lt;endl; init(c); };\n    X (X&amp; lv)  { cout&lt;&lt;\"copy\"&lt;&lt;endl;  init(lv.c_); };\n    X (X&amp;&amp; rv) { cout&lt;&lt;\"move\"&lt;&lt;endl;  c_ = rv.c_; rv.c_ = nullptr; };\n\n    const char* c() { return c_; };\n\nprivate:\n    void init(char *c) { c_ = new char[strlen(c)+1]; strcpy(c_, c); };\n    char* c_;\n\n};\n</code></pre>\n<p>and this sample usage:</p>\n<pre><code>X x(\"test\");\ncout &lt;&lt; x.c() &lt;&lt; endl;\nX y(x);\ncout &lt;&lt; y.c() &lt;&lt; endl;\nX z( X(\"test\") );\ncout &lt;&lt; z.c() &lt;&lt; endl;\n</code></pre>\n<p>The output is:</p>\n<pre><code>ctor\ntest\ncopy\ntest\nctor   &lt;-- why not move?\ntest\n</code></pre>\n<p>I am using VS2010 with default settings. I'd expect the last object (<code>z</code>) to be move-constructed, but it's not! If I use <code>X z( move(X(\"test\")) );</code> then the last lines of the output are <code>ctor move test</code>, as I'd expect. Is it a case of (N)RVO?</p>\n<p><strong>Q</strong>: Should the move-ctor be called according to the standard? If so, why isn't it called?</p>\n", "Tags": "<c++><c++11><move-semantics>", "OwnerUserId": "767843", "AnswerCount": "3"}, "13099752": {"ParentId": "13099603", "CommentCount": "1", "Body": "<p>The <code>ctor</code> output you get in your third code line is for the construction of the temporary object. After that, indeed, the temporary is moved into the new variable <code>z</code>. In such a situation the compiler may choose to elide the copy/move, and it seems that is what it did.</p>\n<p>The Standard states:</p>\n<blockquote>\n<p id=\"so_13099603_13099752_0\">(\u00a712.8/31) When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the copy/move constructor and/or destructor for the object have side e\ufb00ects. [...] This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies):<br>\n  [...]<br>\n   - when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unquali\ufb01ed type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move<br>\n  [...]</br></br></br></p>\n</blockquote>\n<p>One important condition is that the source object and the destination are of the same type (apart from cv-qualification, i.e. things like <code>const</code>).</p>\n<p>Therefore, one way you can force the move constructor to be called is to combine the object initialization with <em>implicit type conversion:</em></p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct B\n{};\n\nstruct A\n{\n  A() {}\n  A(A&amp;&amp; a) {\n    std::cout &lt;&lt; \"move\" &lt;&lt; std::endl;\n  }\n  A(B&amp;&amp; b) {\n    std::cout &lt;&lt; \"move from B\" &lt;&lt; std::endl;\n  }\n};\n\n\nint main()\n{\n  A a1 = A(); // move elided\n  A a2 = B(); // move not elided because of type conversion\n  return 0;\n}\n</code></pre>\n", "OwnerUserId": "777186", "PostTypeId": "2", "Id": "13099752", "Score": "3", "CreationDate": "2012-10-27T11:27:20.410", "LastActivityDate": "2012-10-27T11:27:20.410"}, "13099664": {"ParentId": "13099603", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>What you are seeing is <a href=\"http://en.wikipedia.org/wiki/Copy_elision\">copy elision</a>, which allows the compiler to directly construct a temporary into a target it is to be copied/moved into and thus elide a copy (or move) constructor/destructor pair. The situations in which the compiler is allowed to apply copy elision are specified in \u00a712.8.32 of the C++11 standard:</p>\n<blockquote>\n<p id=\"so_13099603_13099664_0\">When certain criteria are met, an implementation is allowed to omit\n  the copy/move construction of a class  object, even if the copy/move\n  constructor and/or destructor for the object have side e\ufb00ects. In such\n  cases,  the implementation treats the source and target of the omitted\n  copy/move operation as simply two di\ufb00erent  ways of referring to the\n  same object, and the destruction of that object occurs at the later of\n  the times when the two objects would have been destroyed without the\n  optimization. This elision of copy/move \n  operations, called copy elision, is permitted in the following\n  circumstances (which maybe combined to  eliminate multiple copies):</p>\n<ul>\n<li>in a return statement in a function with a class return type, when    the expression is the name of a non-volatile automatic object with<br>\n  the same cv-unquali\ufb01ed type as the function return type, the<br>\n  copy/move operation can be omitted by constructing the automatic<br>\n  object directly into the function\u2019s return value</br></br></br></li>\n<li>in a throw-expression, when the operand is the name of a non-volatile    automatic object whose scope does not extend beyond\n  the end of the    innermost enclosing try-block (if there is one), the\n  copy/move    operation from the operand to the exception object (15.1)\n  can be    omitted by constructing the automatic object directly into\n  the    exception object</li>\n<li>when a temporary class object that has not been bound to  a reference    (12.2) would be copied/moved to a class object with he\n  same    cv-unquali\ufb01ed type, the copy/move operation can be omitted by \n  constructing the temporary object directly into the target of the<br>\n  omitted copy/move </br></li>\n<li>when the exception-declaration of an exception handler (Clause 15)       declares an object of the same type (except for cv-quali\ufb01cation) as<br>\n  the exception object (15.1), the copy/move operation can be omitted<br>\n  bytreatingthe exception-declaration as an alias for the exception<br>\n  object if the meaning of the program will be unchanged except for the \n  execution of constructors and destructors for the object declared by<br>\n  the exception-declaration.</br></br></br></br></li>\n</ul>\n</blockquote>\n", "OwnerUserId": "201270", "LastEditorUserId": "201270", "LastEditDate": "2012-10-27T11:21:17.123", "Id": "13099664", "Score": "19", "CreationDate": "2012-10-27T11:15:36.827", "LastActivityDate": "2012-10-27T11:21:17.123"}, "bq_ids": {"n4140": {"so_13099603_13099752_0": {"section_id": 480, "quality": 0.9047619047619048, "length": 57}, "so_13099603_13099664_0": {"section_id": 480, "quality": 0.921875, "length": 59}}, "n3337": {"so_13099603_13099752_0": {"section_id": 471, "quality": 0.9206349206349206, "length": 58}, "so_13099603_13099664_0": {"section_id": 471, "quality": 0.9375, "length": 60}}, "n4659": {"so_13099603_13099752_0": {"section_id": 502, "quality": 0.7142857142857143, "length": 45}, "so_13099603_13099664_0": {"section_id": 502, "quality": 0.921875, "length": 59}}}, "13099666": {"ParentId": "13099603", "CommentCount": "1", "Body": "<p>You are calling <code>X's</code> <code>char*</code> constructor <code>X(\"test\")</code> explicitly.</p>\n<p>Therefore it is printing <code>ctor</code></p>\n", "OwnerUserId": "598420", "PostTypeId": "2", "Id": "13099666", "Score": "0", "CreationDate": "2012-10-27T11:16:07.210", "LastActivityDate": "2012-10-27T11:16:07.210"}});