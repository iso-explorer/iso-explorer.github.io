post_cb({"bq_ids": {"n4140": {"so_47600716_47601116_0": {"length": 15, "quality": 1.0, "section_id": 6173}}, "n3337": {"so_47600716_47601116_0": {"length": 15, "quality": 1.0, "section_id": 5934}}, "n4659": {"so_47600716_47601116_0": {"length": 15, "quality": 1.0, "section_id": 7675}}}, "47600716": {"ViewCount": "903", "Body": "<p>I read this <a href=\"https://stackoverflow.com/a/4176333/6935629\">answer</a> about undefined behaviour, where I saw following statement:</p>\n<pre><code>++++++i;     // UB, parsed as (++(++(++i)))\n</code></pre>\n<p>I don't think it is undefined behaviour. I have a doubt, Is it really UB in C++? If yes, then How?</p>\n<p>Also, I made program and compiled using <code>g++ prog.cpp -Wall -Wextra -std=gnu++1z -pedantic</code> command, it's working fine without any warning. It's give an expected output.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int i = 0;\n    cout&lt;&lt;++++++i&lt;&lt;endl;\n}\n</code></pre>\n", "AcceptedAnswerId": "47601116", "Title": "Undefined behaviour in repeated use of prefix ++ operator", "CreationDate": "2017-12-01T20:05:04.500", "Id": "47600716", "CommentCount": "21", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-12-02T15:51:12.277", "LastEditorUserId": "734069", "LastActivityDate": "2017-12-02T15:51:12.277", "Score": "18", "OwnerUserId": "6935629", "Tags": "<c++><c++11><undefined-behavior><c++1z>", "AnswerCount": "2"}, "47601102": {"Id": "47601102", "PostTypeId": "2", "Body": "<p>Sometimes behavior is undefined even though it's hard to imagine how it could be mishandled. But pre-C++11, this was undefined because the same object is modified multiple times without an intervening sequence pointed.</p>\n<p>One could imagine a compiler that \"optimized\" the code by consolidating all the modifications to <code>i</code>. Thus each increment winds up incrementing the original value. But that's not the point. UB is UB if the standard says so. It doesn't matter whether or not we can imagine ways it can fail.</p>\n", "LastActivityDate": "2017-12-01T20:35:33.927", "CommentCount": "3", "CreationDate": "2017-12-01T20:35:33.927", "ParentId": "47600716", "Score": "7", "OwnerUserId": "721269"}, "47601116": {"Id": "47601116", "PostTypeId": "2", "Body": "<p>In C++03 it is undefined behavior. In C++11 it is not. There is no sequence point between the various pre-increments. If <code>i</code> was a user-defined type, it would be well-defined behavior because then there would be a function call (a sequence point).</p>\n<p>In C++11, the idea of sequence points was replaced with sequenced before/sequenced after. Defect 637 (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#637\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#637</a>) provides an example of a previously undefined construct becoming well-defined (<code>i = ++i + 1</code>).</p>\n<p>To understand why it's not undefined behavior, let's look at the pieces we need. <code>++i</code> is equivalent to <code>i = i + 1</code> (except <code>i</code> is evaluated only once). Further if we substitute <code>i = i + 1</code> with <code>inc</code>, <code>++(i = i + 1)</code> becomes <code>inc = inc + 1</code>. </p>\n<p>[expr.ass] states:</p>\n<blockquote>\n<p id=\"so_47600716_47601116_0\">In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression.</p>\n</blockquote>\n<p>Thus the assignment in <code>i = i + 1</code> is sequenced before value computation of <code>inc</code>; however, the assignment in <code>inc = inc + 1</code> is sequenced <strong>after</strong> value computation of <code>inc</code>. There is no undefined behavior because the assignments are sequenced.</p>\n", "LastEditorUserId": "9041001", "LastActivityDate": "2017-12-01T20:59:27.830", "Score": "32", "CreationDate": "2017-12-01T20:36:23.573", "ParentId": "47600716", "CommentCount": "6", "OwnerUserId": "9041001", "LastEditDate": "2017-12-01T20:59:27.830"}});