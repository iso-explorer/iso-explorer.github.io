post_cb({"25173462": {"ViewCount": "1551", "Body": "<p>What does the C++ standard say about what <code>sizeof(std::array&lt;char, N&gt;)</code> should be (for some constant <code>N</code>)?</p>\n<p>In a <a href=\"https://stackoverflow.com/questions/25172879/memory-layout-2d-nm-data-as-pointer-to-nm-buffer-or-as-array-of-n-pointers-t/25173173#comment39195129_25173173\">comment to a different question</a>, it was mentioned that <code>std::array</code> is not always \"stack allocated\". The comment was in response to a different comment that speculated that putting a too large of a constant for <code>std::array</code> that is declared as a local variable could cause the program to abort due to insufficient resources for the \"stack allocated\" variable. I assume the followup comment meant that it would be possible for <code>std::array</code> to somehow switch to a dynamic allocation mode.</p>\n<p>I could imagine that there could be some kind of SFINAE could be applied for an array size threshold that triggers a specialization of <code>std::array</code> that actually dynamically allocates an array and manages it. In that case, the <code>sizeof(std::array&lt;...&gt;)</code> might just be the size of a pointer. Is that allowed to happen?</p>\n", "AcceptedAnswerId": "25173547", "Title": "What is the sizeof std::array<char, N>?", "CreationDate": "2014-08-07T03:03:13.957", "LastActivityDate": "2014-08-07T03:57:23.857", "CommentCount": "5", "LastEditDate": "2017-05-23T12:02:34.210", "PostTypeId": "1", "Tags": "<c++><c++11><sizeof><stdarray>", "Id": "25173462", "AnswerCount": "1", "Score": "4", "OwnerUserId": "315052", "ClosedDate": "2014-08-07T03:43:59.160", "LastEditorUserId": "-1"}, "bq_ids": {"n4140": {"so_25173462_25173547_2": {"length": 7, "quality": 0.875, "section_id": 775}, "so_25173462_25173547_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 775}, "so_25173462_25173547_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 774}, "so_25173462_25173547_3": {"length": 17, "quality": 0.8947368421052632, "section_id": 3298}}, "n3337": {"so_25173462_25173547_2": {"length": 7, "quality": 0.875, "section_id": 762}, "so_25173462_25173547_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 762}, "so_25173462_25173547_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 761}, "so_25173462_25173547_3": {"length": 17, "quality": 0.8947368421052632, "section_id": 3168}}, "n4659": {"so_25173462_25173547_0": {"length": 17, "quality": 0.5151515151515151, "section_id": 835}, "so_25173462_25173547_3": {"length": 12, "quality": 0.631578947368421, "section_id": 4063}}}, "25173547": {"Id": "25173547", "PostTypeId": "2", "Body": "<p>Obviously <code>sizeof(std::array&lt;char, N&gt;) != N</code> if <code>N == 0</code>. It also doesn't necessarily hold for <code>N &gt; 0</code>.\n\u00a723.3.2.1 [array.overview]/p1-2:</p>\n<blockquote>\n<p id=\"so_25173462_25173547_0\">The header <code>&lt;array&gt;</code> defines a class template for storing fixed-size\n  sequences of objects. An array supports random access iterators. An\n  instance of <code>array&lt;T, N&gt;</code> stores <code>N</code> elements of type <code>T</code>, so that\n  <code>size() == N</code> is an invariant. The elements of an array are stored\n  contiguously, meaning that if <code>a</code> is an <code>array&lt;T, N&gt;</code> then it obeys\n  the identity <code>&amp;a[n] == &amp;a[0] + n</code> for all <code>0 &lt;= n &lt; N</code>.</p>\n<p id=\"so_25173462_25173547_1\">An array is an\n  aggregate (8.5.1) that can be initialized with the syntax</p>\n<pre><code>array&lt;T, N&gt; a = { initializer-list };\n</code></pre>\n<p id=\"so_25173462_25173547_2\">where <code>initializer-list</code> is a comma-separated list of up to <code>N</code>\n  elements whose types are convertible to <code>T</code>.</p>\n</blockquote>\n<p>\u00a78.5.1 [dcl.init.aggr]/p1:</p>\n<blockquote>\n<p id=\"so_25173462_25173547_3\">An aggregate is an array or a class (Clause 9) with no user-provided\n  constructors (12.1), no private or protected non-static data members\n  (Clause 11), no base classes (Clause 10), and no virtual functions\n  (10.3).</p>\n</blockquote>\n<p>Since <code>array</code> is an aggregate type, it can't have a custom constructor that performs dynamic allocation, and it must store the elements directly since it must be able to be initialized from a initializer list using aggregate initialization. However, nothing in the standard prevents the implementation from adding extra stuff after its C-style array member, as long as <code>array&lt;T, N&gt; a = { initializer-list };</code> has the defined semantics when the <em>initializer-list</em> contains at most <code>N</code> members. An implementation that looks like</p>\n<pre><code>template&lt;typename T, size_t N&gt;\nstruct array {\n    //typedefs and member functions omitted\n\n    T _Elems[N];\n    double _Because_I_can;\n};\n// specialization for N == 0 case omitted\n</code></pre>\n<p>is perfectly legal. Therefore, there's no guarantee that <code>sizeof(std::array&lt;char, N&gt;) == N</code>.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-07T03:44:37.167", "Score": "9", "CreationDate": "2014-08-07T03:15:48.697", "ParentId": "25173462", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2014-08-07T03:44:37.167"}});