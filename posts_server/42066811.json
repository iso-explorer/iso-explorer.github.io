post_cb({"42067082": {"ParentId": "42066811", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_42066811_42067082_0\">Where am I wrong?</p>\n</blockquote>\n<p>An <em>rvalue reference</em> has the following form: <code>T&amp;&amp;</code>. </p>\n<p><code>decltype(string(\"\"))</code> evaluates to <code>string</code>, not <code>string&amp;&amp;</code> - therefore it is not an <em>rvalue reference</em>. </p>\n<pre><code>is_same&lt;decltype(string(\"Hello world!\")), string&gt;::value // true\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_42066811_42067082_1\">string(\"Hello world!\") may be a rvalue but does not seem to be a \"reference of any kind\" </p>\n</blockquote>\n<p><code>string(\"Hello world!\")</code> is an expression with <em>rvalue</em> value category - more specifically it is a <em>prvalue</em>. Expressions <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow noreferrer\">are <strong>non-references</strong></a>. <em>(More information: <a href=\"https://stackoverflow.com/questions/17241614/in-c-what-expressions-yield-a-reference-type-when-decltype-is-applied-to-them\">\"In C++, what expressions yield a reference type when decltype is applied to them?\"</a>.)</em></p>\n<hr>\n<blockquote>\n<p id=\"so_42066811_42067082_2\">Is there a way to get a true answer in case of a rvalue ?</p>\n</blockquote>\n<p>You can use a transformation that:</p>\n<ul>\n<li><p>Given an <em>lvalue</em>, returns an <em>lvalue reference</em>.</p></li>\n<li><p>Given an <em>rvalue</em>, returns an <em>rvalue reference</em>.</p></li>\n</ul>\n<p>The behavior mentioned above can be obtained thanks to <a href=\"http://en.cppreference.com/w/cpp/language/template_argument_deduction\" rel=\"nofollow noreferrer\"><em>template argument deduction rules</em></a>:</p>\n<pre><code>template &lt;typename T&gt;\nusing is_rvalue = std::is_rvalue_reference&lt;T&amp;&amp;&gt;;\n\nis_rvalue&lt;decltype(string(\"\"))&gt;::value // true\nis_rvalue&lt;decltype(std::declval&lt;string&amp;&amp;&gt;())&gt;::value // true\nis_rvalue&lt;decltype(std::declval&lt;string&amp;&gt;())&gt;::value // false\n</code></pre>\n<p>The code above works because:</p>\n<ul>\n<li><p><code>T&amp;&amp;</code> is deduced as <code>T&amp;&amp;</code> both for <em>xvalues</em> and <em>prvalues</em>.</p></li>\n<li><p><code>T&amp;&amp;</code> is deduced as <code>T&amp;</code> otherwise <em>(i.e. for lvalues)</em>.</p></li>\n</ul>\n<hr>\n<blockquote>\n<p id=\"so_42066811_42067082_3\">Is there copy elision or not in his example ?</p>\n</blockquote>\n<p>In C++14, the compiler <strong>is allowed to</strong> <em>(but not required)</em> to elide the copies in your example.</p>\n<p><em>(Credits to Jonathan Wakely for identifying the relevant C++14 standard draft quotes cited below.)</em></p>\n<p>Relevant C++14 standard draft <em>(<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">N4296</a>)</em> quotes:</p>\n<ul>\n<li><blockquote>\n<p id=\"so_42066811_42067082_4\"><strong>\u00a712.8 [class.copy] p.31</strong></p>\n<p id=\"so_42066811_42067082_5\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class\n  object, even if the constructor selected for the copy/move operation and/or the destructor for the object\n  have side effects. In such cases, the implementation treats the source and target of the omitted copy/move\n  operation as simply two different ways of referring to the same object, and the destruction of that object\n  occurs at the later of the times when the two objects would have been destroyed without the optimization. This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which\n  may be combined to eliminate multiple copies):</p>\n<p id=\"so_42066811_42067082_6\"><em>[...]</em></p>\n<blockquote>\n<p id=\"so_42066811_42067082_8\"><em>[p.31.3]</em> when a temporary class object that has not been bound to a reference would be copied/moved\n    to a class object with the same cv-unqualified type, the copy/move operation can be omitted by\n    constructing the temporary object directly into the target of the omitted copy/move</p>\n</blockquote>\n</blockquote></li>\n<li><blockquote>\n<p id=\"so_42066811_42067082_9\"><strong>\u00a75.2.2 [expr.call] p.4</strong></p>\n<p id=\"so_42066811_42067082_10\">When a function is called, each parameter shall be initialized with its corresponding\n  argument. <em>[...]</em>  During\n  the initialization of a parameter, an implementation may avoid the construction of extra temporaries by\n  combining the conversions on the associated argument and/or the construction of temporaries with the\n  initialization of the parameter. <em>[...]</em></p>\n</blockquote></li>\n</ul>\n<p>ISO/IEC. (2014). ISO International Standard ISO/IEC 14882:2014(E) \u2013 Programming Language C++. [Working draft]. Geneva, Switzerland: International Organization for Standardization (ISO). <em>(Retrieved from <a href=\"https://isocpp.org/std/the-standard\" rel=\"nofollow noreferrer\">https://isocpp.org/std/the-standard</a>)</em></p>\n</hr></hr></hr>", "OwnerUserId": "598696", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:24:27.177", "Id": "42067082", "Score": "8", "CreationDate": "2017-02-06T11:49:17.197", "LastActivityDate": "2017-02-06T14:00:34.763"}, "42066811": {"CommentCount": "0", "ViewCount": "1066", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-02-06T11:35:08.487", "LastActivityDate": "2017-02-11T07:50:04.603", "Title": "Is constructed string(\"Plain Old C chain\") a rvalue?", "AcceptedAnswerId": "42067038", "LastEditDate": "2017-05-23T12:33:41.987", "Id": "42066811", "Score": "12", "Body": "<p>I was wondering if a copy elision is made in the call of <code>foo(string)</code> below.\n(Note: <code>foo(string)</code> belongs to an interface that I can not change).</p>\n<p>For this I attempted to check whether constructed <code>string(\"Hello world!\")</code> is a <code>rvalue</code>.</p>\n<p>I searched on SO how to do this programmatically and found this post: <a href=\"https://stackoverflow.com/questions/36296425/how-to-determine-programmatically-if-an-expression-is-rvalue-or-lvalue-in-c\">How to determine programmatically if an expression is rvalue or lvalue in C++?</a> </p>\n<pre><code>void foo( string str)\n{\n    cout &lt;&lt; str &lt;&lt; endl;\n}\n\nint main()\n{\n    foo(\"Hello world!\");\n    cout &lt;&lt; is_rvalue_reference&lt;decltype(string(\"Hello world!\"))&gt;::value  &lt;&lt; endl;\n}\n</code></pre>\n<p>result is</p>\n<pre><code>Hello world!\n0\n</code></pre>\n<p>I thought I would get <code>true</code> to <code>is_rvalue_reference&lt; xxx &gt;::value</code></p>\n<ul>\n<li>Where am I wrong?</li>\n<li><code>string(\"Hello world!\")</code> may be a <code>rvalue</code> but does not seem to be a \"reference of any kind\" (either <code>lvalue</code>, <code>rvalue</code>, universal ... ) so that I got <code>false</code> result. Is there a way to get a <code>true</code> answer in case of a <code>rvalue</code>?</li>\n<li>Is there copy elision or not in his example?</li>\n</ul>\n", "Tags": "<c++>", "OwnerUserId": "3972710", "AnswerCount": "2"}, "42067038": {"ParentId": "42066811", "PostTypeId": "2", "CommentCount": "18", "Body": "<blockquote id=\"so_42066811_42067038_0\">\n<ul>\n<li>Where am I wrong?</li>\n</ul>\n</blockquote>\n<p><code>std::string(\"\")</code> is an rvalue, but <code>decltype(std::string(\"\"))</code> is not an rvalue reference. The type of a <code>std::string</code> object is ... <code>std::string</code>, of course.</p>\n<p>You have a category error. An rvalue is a kind of expression, an rvalue reference is a kind of type.</p>\n<p>A temporary <code>string</code> object is an rvalue. The type <code>string&amp;&amp;</code> is an rvalue reference type.</p>\n<p>Your <code>decltype</code> expression is not useful for what you're trying to do. Consider:</p>\n<pre><code>std::string s;\nusing type1 = decltype(s);\nusing type2 = decltype(std::string(\"\"));\nstatic_assert(std::is_same&lt;type1, type2&gt;::value, \"same\");\n</code></pre>\n<p>In both these cases <code>decltype</code> gives the same type: <code>std::string</code>. That's because <code>decltype</code> tells you about types, not value categories (i.e. whether an expression is an rvalue or an lvalue).</p>\n<p>If you want to know whether an expression is an rvalue or an lvalue you need to know more than just its type. In the case of <code>decltype(std::string(\"\"))</code> you are creating an unnamed temporary, which is an rvalue. You don't need to ask its type to know that.</p>\n<blockquote id=\"so_42066811_42067038_1\">\n<ul>\n<li><em>string(\"Hello world!\")</em> may be a rvalue but does not seem to be a \"reference of any kind\" (either lvalue, rvalue, universal ... ) so that I got <strong>false</strong> result. Is there a way to get a <em>true</em> answer in case of a rvalue ?</li>\n</ul>\n</blockquote>\n<p>What do you mean by \"true\" answer? Do you just mean a type trait that will give the result <code>true</code>?</p>\n<p>You can ask if the type is convertible to an rvalue reference:</p>\n<pre><code>std::is_convertible&lt;decltype(std::string(\"\")), std::string&amp;&amp;&gt;::value\n</code></pre>\n<p>That will tell you if you can bind an rvalue reference to the object. But it's a silly question: of course you can bind an rvalue reference of type X&amp;&amp; to a temporary of type X. You would never need to ask that.</p>\n<p>And anyway, you function doesn't take an argument of type <code>string&amp;&amp;</code> so asking that question doesn't even tell you anything about your call to <code>foo(std::string)</code>.</p>\n<blockquote id=\"so_42066811_42067038_2\">\n<ul>\n<li>Is there copy elision or not in his example ?</li>\n</ul>\n</blockquote>\n<p>Yes, initializing the function argument from a temporary string should not make any copies or moves, they should be elided. The C++14 standard says in [class.copy] p31 that a copy/move can be elided when a temporary object (that has not been bound to a reference) would be copied/moved to a class object of the same type. That condition is met when initializing a function argument of class type from a temporary of the same type. A compiler that doesn't perform that elision (at least when optimisations are enabled, or in \"release\" builds) is a bad compiler.</p>\n<p>There is an explanation of the copy elision rules at <a href=\"http://en.cppreference.com/w/cpp/language/copy_elision\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/copy_elision</a> -- see the part about a nameless temporary.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "2756719", "LastEditDate": "2017-02-07T07:34:04.007", "Id": "42067038", "Score": "20", "CreationDate": "2017-02-06T11:47:38.840", "LastActivityDate": "2017-02-07T07:34:04.007"}, "bq_ids": {"n4140": {"so_42066811_42067082_8": {"section_id": 480, "quality": 0.9629629629629629, "length": 26}, "so_42066811_42067082_7": {"section_id": 480, "quality": 0.9629629629629629, "length": 26}, "so_42066811_42067082_10": {"section_id": 5991, "quality": 1.0, "length": 27}, "so_42066811_42067082_5": {"section_id": 480, "quality": 0.9848484848484849, "length": 65}}, "n3337": {"so_42066811_42067082_8": {"section_id": 471, "quality": 0.9629629629629629, "length": 26}, "so_42066811_42067082_7": {"section_id": 471, "quality": 0.9629629629629629, "length": 26}, "so_42066811_42067082_10": {"section_id": 5759, "quality": 1.0, "length": 27}, "so_42066811_42067082_5": {"section_id": 471, "quality": 0.9393939393939394, "length": 62}}, "n4659": {"so_42066811_42067082_8": {"section_id": 502, "quality": 0.6296296296296297, "length": 17}, "so_42066811_42067082_1": {"section_id": 7709, "quality": 0.5555555555555556, "length": 5}, "so_42066811_42067082_5": {"section_id": 502, "quality": 0.9848484848484849, "length": 65}, "so_42066811_42067082_7": {"section_id": 502, "quality": 0.6296296296296297, "length": 17}}}});