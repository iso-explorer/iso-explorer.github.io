post_cb({"22106744": {"Id": "22106744", "PostTypeId": "2", "Body": "<p>They both are the same (they both check if the pointer is <code>0</code>), the difference is that you would normally use the first example if you want to protect against inadvertent assignment:</p>\n<pre><code>if (pointer = NULL) // This compiles, but probably not what you meant\n\nif (NULL = pointer) // Syntax error!\n</code></pre>\n", "LastActivityDate": "2014-02-28T22:07:02.127", "CommentCount": "0", "CreationDate": "2014-02-28T22:07:02.127", "ParentId": "22106713", "Score": "4", "OwnerUserId": "701092"}, "22106713": {"ViewCount": "747", "Body": "<p>What is the difference between using:</p>\n<pre><code>if (NULL == pointer) \n</code></pre>\n<p>and using:</p>\n<pre><code>if (pointer == NULL)    \n</code></pre>\n<p>My professor says to use the former over the latter but I don't see the difference between the two.</p>\n", "AcceptedAnswerId": "22106732", "Title": "What is the difference between if (NULL == pointer) vs if (pointer == NULL)?", "CreationDate": "2014-02-28T22:04:54.367", "Id": "22106713", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-03-01T01:51:22.717", "LastEditorUserId": "1708801", "LastActivityDate": "2015-01-14T13:27:37.983", "Score": "6", "OwnerUserId": "1637664", "Tags": "<c++><coding-style><conditional-statements>", "AnswerCount": "5"}, "22106737": {"Id": "22106737", "PostTypeId": "2", "Body": "<p>There's no difference for the compiler. The only slight advantage is that if you ever forget a \"=\", the first form will cause a syntax error (you cannot assign a pointer to NULL), while the second might give no warning and happily blast your pointer.</p>\n", "LastActivityDate": "2014-02-28T22:06:43.417", "CommentCount": "0", "CreationDate": "2014-02-28T22:06:43.417", "ParentId": "22106713", "Score": "6", "OwnerUserId": "1428679"}, "22107408": {"Id": "22107408", "PostTypeId": "2", "Body": "<p>If this course is touting to be <em>C++11</em> compliant, then what really should be used is not the NULL macro check that has been around forever (at least in the C language lifetime).  What should be compared to is the nullptr type.  For reference: <a href=\"http://www.cplusplus.com/reference/cstddef/nullptr_t/\" rel=\"nofollow noreferrer\">nullptr</a> and <a href=\"https://stackoverflow.com/questions/1282295/what-exactly-is-nullptr\">What exactly is nullptr?</a>.</p>\n<p>From the cplusplus.com page cited above, as of February 28, 2014: <br/></p>\n<blockquote>\n<p id=\"so_22106713_22107408_0\">Null pointer type (C++) Type of the null pointer constant nullptr.</p>\n<p id=\"so_22106713_22107408_1\">This type can only take one value: nullptr, which when converted to a pointer type takes the proper null pointer value.</p>\n<p id=\"so_22106713_22107408_2\">Even though nullptr_t it is not a keyword, it identifies a distinct fundamental type: the type of nullptr. As such, it participates in overload resolution as a different type.</p>\n<p id=\"so_22106713_22107408_3\">This type is only defined for C++ (since C++11).<br/></p>\n</blockquote>\n<p>A short sample in C++11 (clang++, C++Builder 64-bit (based on clang++), Visual Studio 2010 and newer; maybe only 64-bit too, GCC 4.7.3 maybe, not sure, could be GCC 4.8, ...):</p>\n<pre><code>if (pointer == nullptr)\n\n// this looks odd, but does compile\nif (nullptr == pointer)\n</code></pre>\n<p>If this is a strict C11 course, then it looks like there is no improved way to replace the NULL macro.  The C99 standard says the NULL macro can be portably expressed as integer value zero converted implicitly or explicitly to the void* type (<a href=\"https://en.wikipedia.org/wiki/Null_pointer#Null_pointer\" rel=\"nofollow noreferrer\">from Wikipedia: Null pointer</a>).  To the best of my knowledge, the C11 standard has not modified this aspect of the C99 standard.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-01T12:50:09.367", "Score": "2", "CreationDate": "2014-02-28T22:57:05.680", "ParentId": "22106713", "CommentCount": "1", "OwnerUserId": "3316922", "LastEditDate": "2017-05-23T12:15:07.500"}, "bq_ids": {"n4140": {"so_22106713_22107408_0": {"length": 5, "quality": 0.625, "section_id": 39}}, "n3337": {"so_22106713_22107408_0": {"length": 5, "quality": 0.625, "section_id": 36}}, "n4659": {"so_22106713_22107408_0": {"length": 5, "quality": 0.625, "section_id": 39}}}, "22610554": {"Id": "22610554", "PostTypeId": "2", "Body": "<pre><code>String pointer = \"Some value\";\n</code></pre>\n<p>Initially value of <code>pointer</code> is <code>\"Some value\"</code>, so if you mistakenly check it with \n<code>if(pointer = NULL)</code> instead of <code>if(pointer == NULL)</code>, the null value will be assign to <code>pointer</code>; but in case of <code>(NULL = pointer )</code> the compiler will never allow you to assign anything to NULL. So keep using <code>NULL == pointer</code> in conditional statements.</p>\n", "LastEditorUserId": "3244185", "LastActivityDate": "2015-01-14T04:29:07.247", "Score": "0", "CreationDate": "2014-03-24T13:17:18.377", "ParentId": "22106713", "CommentCount": "0", "OwnerUserId": "3244185", "LastEditDate": "2015-01-14T04:29:07.247"}, "22106732": {"Id": "22106732", "PostTypeId": "2", "Body": "<p>There is no difference, it is called <a href=\"http://en.wikipedia.org/wiki/Yoda_conditions\" rel=\"nofollow noreferrer\">Yoda conditions</a> also see <a href=\"http://www.dodgycoder.net/2011/11/yoda-conditions-pokemon-exception.html\" rel=\"nofollow noreferrer\">\"Yoda Conditions\", \"Pok\u00e9mon Exception Handling\" and other programming classics</a>.</p>\n<p>It is supposed to prevent the usage of assignment(<code>=</code>) by mistake over equality(<code>==</code>) in a comparison, but modern compilers should warn about this now, so this type of defensive programming should not be needed. For example:</p>\n<pre><code>if( pointer = NULL )\n</code></pre>\n<p>will assign <code>NULL</code> to <code>pointer</code> when what the programmer really meant was:</p>\n<pre><code>if( pointer == NULL )\n</code></pre>\n<p>it should have been a comparison, Oops. Make this an error using <em>Yoda conditions</em> you will (<em><a href=\"http://coliru.stacked-crooked.com/a/85231376a0bb3eb5\" rel=\"nofollow noreferrer\">see it live</a></em>), with a similar message to this:</p>\n<blockquote>\n<p id=\"so_22106713_22106732_0\">error: expression is not assignable</p>\n</blockquote>\n<p>As jrok points out using:</p>\n<pre><code>if (!pointer)\n</code></pre>\n<p>avoids this problem all together in this case.</p>\n<p>Here is a concrete example of why with a modern compilers we don't need this technique anymore(<em><a href=\"http://coliru.stacked-crooked.com/a/4a7a1731ed942457\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    int *ptr1 = NULL ;\n\n    if( ptr1 = NULL )\n    {\n            std::cout &lt;&lt; \"It is NULL\" &lt;&lt; std::endl ;\n    }\n\n}\n</code></pre>\n<p>Note all the warnings:</p>\n<pre><code>warning: using the result of an assignment as a condition without parentheses [-Wparentheses]\n    if( ptr1 = NULL )\n        ~~~~~^~~~~~\n\nnote: place parentheses around the assignment to silence this warning\n    if( ptr1 = NULL )\n             ^\n        (          )\n\nuse '==' to turn this assignment into an equality comparison\n    if( ptr1 = NULL )\n             ^\n             ==\n</code></pre>\n<p>which makes it pretty hard to miss the problem. It is worth noting that in <em>C++</em> <a href=\"http://en.cppreference.com/w/cpp/language/nullptr\" rel=\"nofollow noreferrer\">nullptr</a> should be preferred over <code>NULL</code>, you can look at <a href=\"https://stackoverflow.com/questions/13816385/what-are-the-advantages-of-using-nullptr\">What are the advantages of using nullptr?</a> for all the details.</p>\n<p>Note, in <em>C++</em> there is the unlikely case with operator overloading that there could be some contrived case where they are not the same.</p>\n<p>Note, the <a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Warning-Options.html\" rel=\"nofollow noreferrer\">-Wparentheses warning</a> in some ways forces a style choice, you either need to give up potentially valid uses of assignment in places where the warning is generated, for example if you use <code>-Werror</code> or choose to parenthesize those cases, which some may find <em>ugly</em> as the comment below suggests. We can turn of the warning in <code>gcc</code> and <code>clang</code> using <code>-Wno-parentheses</code> but I would not recommend that choice since the warning in general will indicate a real bug.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-14T13:27:37.983", "Score": "13", "CreationDate": "2014-02-28T22:06:35.227", "ParentId": "22106713", "CommentCount": "3", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:06:51.347"}});