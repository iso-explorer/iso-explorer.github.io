post_cb({"16639218": {"LastActivityDate": "2013-05-19T20:34:00.913", "ParentId": "16639131", "Id": "16639218", "Score": "18", "Body": "<blockquote>\n<p id=\"so_16639131_16639218_0\">This object is really heavyweight, so it's marked as uncopyable, but it does have a move constructor. </p>\n</blockquote>\n<p>If a functor is non-copyable, it does not meet the necessary requirements for being used with <code>std::function</code>. Paragraph 20.8.11.2.1/7 of the C++11 Standard specifies:</p>\n<blockquote>\n<pre><code>template&lt;class F&gt; function(F f);\ntemplate &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);\n</code></pre>\n<p id=\"so_16639131_16639218_1\">7 <em>Requires</em>: <strong><code>F</code> shall be <code>CopyConstructible</code></strong>. <code>f</code> shall be <code>Callable</code> (20.8.11.2) for argument types <code>ArgTypes</code>\n  and return type <code>R</code>. The copy constructor and destructor of <code>A</code> shall not throw exceptions.</p>\n</blockquote>\n", "CommentCount": "12", "PostTypeId": "2", "OwnerUserId": "1932150", "CreationDate": "2013-05-19T20:34:00.913"}, "44442474": {"CreationDate": "2017-06-08T17:48:47.333", "LastActivityDate": "2017-10-10T19:27:25.123", "LastEditorUserId": "5371704", "ParentId": "16639131", "Score": "2", "Id": "44442474", "OwnerUserId": "5371704", "Body": "<p>std::function can be move-constructed from rvalue of a functor object. And most implementations do that. </p>\n<p>The \"my target must be copy-constructable\" requirement of std::function is due to its own requirement of being copy-constructable. std::function's type is defined only by its target's signature(eg: void(int)) and std::function itself is defined by the standard to be copy-constructable. So when you copy-construct a std::function, it needs to call the copy-ctor of the its target(the underlying functor). So it requires its target having one. It has no other choices. </p>\n<p>Having the requirement that the target being copy-constructable, the standard does not say that the implementations should copy, instead of move, when you construct a std::function from a rvalue callable object. The implemention will probably only call the move-ctor of your callable object.</p>\n<hr>\n<p>More detailed additional information with examples and tests:</p>\n<p>For example in gcc(MSVC is similar) implementation for the ctor of std::function from any callable object:</p>\n<pre><code>template&lt;typename _Res, typename... _ArgTypes&gt;\n  template&lt;typename _Functor, typename&gt;\n    function&lt;_Res(_ArgTypes...)&gt;::\n    function(_Functor __f)\n    : _Function_base()\n    {\n        typedef _Function_handler&lt;_Signature_type, _Functor&gt; _My_handler;\n\n        // don't need to care about details below, but when it uses __f, it \n        // either uses std::move, or passes it by references\n        if (_My_handler::_M_not_empty_function(__f))\n        {\n           _My_handler::_M_init_functor(_M_functor, std::move(__f));\n           _M_invoker = &amp;_My_handler::_M_invoke;\n           _M_manager = &amp;_My_handler::_M_manager;\n        }\n    }\n</code></pre>\n<p>passing by value of the argument of \"_Functor __f\" will use its move constructor if it has one, and it will use its copy constructor if it does not have a move ctor. As the following test program can demonstrate:</p>\n<pre><code>int main(){\n    using namespace std;\n    struct TFunctor\n    {\n        TFunctor() = default;\n        TFunctor(const TFunctor&amp;) { cout &lt;&lt; \"cp ctor called\" &lt;&lt; endl; }\n        TFunctor(TFunctor&amp;&amp;) { cout &lt;&lt; \"mv ctor called\" &lt;&lt; endl; };\n        void operator()(){}\n    };\n\n    {   //!!!!COPY CTOR of TFunctor is NEVER called in this scope\n        TFunctor myFunctor;\n\n        //TFunctor move ctor called here\n        function&lt;void()&gt; myStdFuncTemp{ std::move(myFunctor) }; \n\n        function&lt;void()&gt; myStdFunc{ move(myStdFuncTemp) }; \n    }\n\n    {   //TFunctor copy ctor is called twice in this scope\n        TFunctor myFunctor;\n\n        //TFunctor copy ctor called once here\n        function&lt;void()&gt; myStdFuncTemp{ myFunctor };\n\n        //TFunctor copy ctor called once here\n        function&lt;void()&gt; myStdFunc{ myStdFuncTemp };\n    }\n}\n</code></pre>\n<hr>\n<p>Finally, you could make a unstd::function_only_movable which has almost everything the same with std::function but deletes its own copy ctor so it does not need to require the target callable object to have one copy ctor. You also need to only construct it from rvalue of callable objects.</p>\n<p><a href=\"https://github.com/longpractice/move_only_std_function.git\" rel=\"nofollow noreferrer\">This</a> is my implementation. </p>\n</hr></hr>", "CommentCount": "1", "PostTypeId": "2", "LastEditDate": "2017-10-10T19:27:25.123"}, "bq_ids": {"n3337": {"so_16639131_16639218_1": {"section_id": 4470, "quality": 0.8, "length": 12}}}, "16639131": {"AcceptedAnswerId": "16639218", "Tags": "<c++><c++11><std><rvalue-reference>", "AnswerCount": "2", "OwnerUserId": "53543", "Body": "<p>I have an untemplated functor object that I'm trying to store as a <code>std::function</code> inside another object. This object is really heavyweight, so it's marked as uncopyable, but it does have a move constructor. However, trying to construct a std::function, or assign it, from a temporary constructor fails. </p>\n<p>Here is a minimal example to provoke the error.</p>\n<pre><code>// pretend this is a really heavyweight functor that can't be copied.\nstruct ExampleTest\n{\n    int x;\n    int operator()(void) const {return x*2;}\n    ExampleTest(  ) :x(0){}\n    ExampleTest( int a ) :x(a){}\n\n    // allow move\n    ExampleTest( ExampleTest &amp;&amp;other ) :x(other.x) {};\n\nprivate: // disallow copy, assignment\n    ExampleTest( const ExampleTest &amp;other );\n    void operator=( const ExampleTest &amp;other );\n};\n\n// this sometimes stores really big functors and other times stores tiny lambdas.\nstruct ExampleContainer\n{\n    ExampleContainer( int );\n    std::function&lt;int(void)&gt; funct;\n};\n\n/******** ERROR:\n Compiler error: 'ExampleTest::ExampleTest' : cannot access private member \n declared in class 'ExampleTest'\n******************/\nExampleContainer::ExampleContainer( int x )\n    : funct( ExampleTest( x ) ) \n{}\n\n/******** ERROR:\n Compiler error: 'ExampleTest::ExampleTest' : cannot access private member \n declared in class 'ExampleTest'\n******************/\nint SetExample( ExampleContainer *container )\n{\n    container-&gt;funct = ExampleTest();\n    return container-&gt;funct();\n}\n</code></pre>\n<p>In an even simpler construction, where I'm just making a local function, I also get the error:</p>\n<pre><code>int ContrivedExample(  )\n{\n    // extra parens to sidestep most vexing parse \n    std::function&lt;int()&gt; zug( (ExampleTest()) );\n    /*** ERROR: 'ExampleTest::ExampleTest' : cannot access private member\n         declared in class 'ExampleTest' */\n    int troz = zug(  ) ;\n    return troz;\n}\n</code></pre>\n<p>So far as I can tell, in all of these cases, a temporary ExampleTest ought to be passed to the function constructor as an rvalue. Yet the compiler wants to copy them. </p>\n<p>What gives? Is it possible to pass uncopyable (but move-copyable) functor objects to a std::function constructor? There are workarounds with pointers and so on, but I want to understand what is going on here.</p>\n<p>The specific errors above are from Visual Studio 2012 with the CTP C++11 patch. GCC 4.8 and Clang 3 also fall down, with their own error messages.</p>\n", "CommentCount": "4", "CreationDate": "2013-05-19T20:24:39.637", "PostTypeId": "1", "FavoriteCount": "1", "LastActivityDate": "2017-10-10T19:27:25.123", "Id": "16639131", "Title": "Can std::function be move-constructed from rvalue reference to a temporary functor object?", "Score": "18", "ViewCount": "2006"}});