post_cb({"16300432": {"CommentCount": "7", "AcceptedAnswerId": "16300433", "CreationDate": "2013-04-30T12:55:04.143", "LastActivityDate": "2013-04-30T21:43:48.853", "PostTypeId": "1", "ViewCount": "2029", "FavoriteCount": "8", "Title": "Are static class members guaranteed to be initialized before `main` is called?", "Id": "16300432", "Score": "14", "Body": "<p>Is there any guarantee that static class members are initialized before <code>main</code> is called?</p>\n", "Tags": "<c++><language-lawyer><c++03>", "OwnerUserId": "560648", "AnswerCount": "2"}, "16300433": {"ParentId": "16300432", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>I think <strong>no</strong>:</p>\n<blockquote>\n<p id=\"so_16300432_16300433_0\"><code>[C++03: 3.6.2/3]:</code> <strong>It is implementation-defined whether or not the dynamic initialization</strong> (8.5, 9.4, 12.1, 12.6.1) <strong>of an object of namespace scope is done before the first statement of <code>main</code>.</strong> If the initialization is deferred to some point in time after the first statement of <code>main</code>, it shall occur before the first use of any function or object defined in the same translation unit as the object to be initialized.</p>\n</blockquote>\n<hr>\n<h3>Hmm, <em>really</em>?</h3>\n<p>Well, arguably, \"defined in namespace scope\" is not quite the same thing as \"an object of namespace scope\":</p>\n<blockquote>\n<p id=\"so_16300432_16300433_1\"><code>[C++03: 9.4.2/2]:</code> The declaration of a <code>static</code> data member in its class definition is not a definition and may be of an incomplete type other than cv-qualified <code>void</code>. <strong>The definition for a <code>static</code> data member shall appear in a namespace scope</strong> enclosing the member's class definition. In the definition at namespace scope, the name of the <code>static</code> data member shall be qualified by its class name using the <code>::</code> operator. The <em>initializer</em>\n  expression in the definition of a static data member is in the scope of its class (3.3.6).</p>\n</blockquote>\n<p>However, it's the <em>initializer</em> that's in the class's scope; there's no mention of the <code>static</code> member itself having anything other than namespace scope (unless we mentally inject the word <em>\"lexically\"</em> everywhere).</p>\n<p>There <em>is</em> this pleasing paragraph:</p>\n<blockquote>\n<p id=\"so_16300432_16300433_2\"><code>[C++03: 9.4.2/7]:</code> Static data members are initialized and destroyed exactly like non-local objects (3.6.2, 3.6.3).</p>\n</blockquote>\n<p>However, unfortunately, the only further definition of the sequencing of <code>main</code> and static initialisation, with respect to \"non-local objects\", is the aforementioned <code>[C++03: 3.6.2/3]</code>.</p>\n<hr>\n<h3>So what then?</h3>\n<p>I believe that the intent of this otherwise potentially ambiguous rule is clearly shown by the new wording in C++11, which resolves everything:</p>\n<blockquote>\n<p id=\"so_16300432_16300433_3\"><code>[C++11: 9.4.2/6]:</code> Static data members are initialized and destroyed exactly like non-local variables (3.6.2, 3.6.3).</p>\n<p id=\"so_16300432_16300433_4\"><code>[C++11: 3.6.2/4]:</code> It is implementation-defined whether the dynamic initialization of a non-local variable with static storage duration is done before the first statement of main. <em>[..]</em></p>\n</blockquote>\n</hr></hr>", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2013-04-30T13:51:14.047", "Id": "16300433", "Score": "11", "CreationDate": "2013-04-30T12:55:04.143", "LastActivityDate": "2013-04-30T13:51:14.047"}, "bq_ids": {"n4140": {"so_16300432_16302929_3": {"section_id": 7153, "quality": 0.7428571428571429, "length": 26}, "so_16300432_16300433_1": {"section_id": 5907, "quality": 0.8888888888888888, "length": 48}, "so_16300432_16300433_2": {"section_id": 5911, "quality": 0.6153846153846154, "length": 8}, "so_16300432_16300433_0": {"section_id": 7153, "quality": 0.7027027027027027, "length": 26}, "so_16300432_16302929_2": {"section_id": 7151, "quality": 0.6875, "length": 11}, "so_16300432_16302929_4": {"section_id": 5907, "quality": 0.9166666666666666, "length": 11}, "so_16300432_16302929_5": {"section_id": 7152, "quality": 0.5263157894736842, "length": 10}, "so_16300432_16302929_1": {"section_id": 3289, "quality": 0.8181818181818182, "length": 9}, "so_16300432_16302929_0": {"section_id": 7151, "quality": 0.7692307692307693, "length": 10}, "so_16300432_16300433_4": {"section_id": 7153, "quality": 0.8125, "length": 13}, "so_16300432_16300433_3": {"section_id": 5911, "quality": 0.6923076923076923, "length": 9}}, "n3337": {"so_16300432_16302929_3": {"section_id": 6897, "quality": 0.7428571428571429, "length": 26}, "so_16300432_16300433_1": {"section_id": 5679, "quality": 0.8888888888888888, "length": 48}, "so_16300432_16300433_2": {"section_id": 5683, "quality": 0.6153846153846154, "length": 8}, "so_16300432_16300433_0": {"section_id": 6897, "quality": 0.7027027027027027, "length": 26}, "so_16300432_16302929_2": {"section_id": 6895, "quality": 0.625, "length": 10}, "so_16300432_16302929_4": {"section_id": 5679, "quality": 0.9166666666666666, "length": 11}, "so_16300432_16302929_5": {"section_id": 6896, "quality": 0.5263157894736842, "length": 10}, "so_16300432_16302929_1": {"section_id": 3159, "quality": 0.8181818181818182, "length": 9}, "so_16300432_16302929_0": {"section_id": 6895, "quality": 0.7692307692307693, "length": 10}, "so_16300432_16300433_4": {"section_id": 6897, "quality": 0.8125, "length": 13}, "so_16300432_16300433_3": {"section_id": 5683, "quality": 0.6923076923076923, "length": 9}}, "n4659": {"so_16300432_16300433_1": {"section_id": 7389, "quality": 0.8518518518518519, "length": 46}, "so_16300432_16300433_4": {"section_id": 8657, "quality": 0.75, "length": 12}, "so_16300432_16300433_2": {"section_id": 7393, "quality": 0.6153846153846154, "length": 8}, "so_16300432_16302929_1": {"section_id": 4051, "quality": 0.8181818181818182, "length": 9}, "so_16300432_16302929_4": {"section_id": 7389, "quality": 0.9166666666666666, "length": 11}, "so_16300432_16302929_2": {"section_id": 8652, "quality": 0.5625, "length": 9}, "so_16300432_16302929_0": {"section_id": 8652, "quality": 0.6923076923076923, "length": 9}, "so_16300432_16300433_3": {"section_id": 7393, "quality": 0.6923076923076923, "length": 9}}}, "16302929": {"ParentId": "16300432", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>C++03: In short, no guarantee</p>\n<p>C++11: No guarantee, see Lightness' answer.</p>\n<p>My interpretation/analysis of the C++03 statements:</p>\n<hr>\n<h3>Terminology: [basic.start.init]/1</h3>\n<blockquote>\n<p id=\"so_16300432_16302929_0\">Zero-initialization and initialization with a constant expression are collectively called static initialization; all other initialization is dynamic initialization.</p>\n</blockquote>\n<hr>\n<h3>Order of initialization on non-local objects:</h3>\n<blockquote>\n<p id=\"so_16300432_16302929_1\">Objects with static storage duration (3.7.1) shall be zero-initialized (8.5) before any other initialization takes place.</p>\n</blockquote>\n<p>But it doesn't mention when \"any other initialization\" takes place, i.e. there's no guarantee it'll be before the first statement of main, <strong>even for zero-initialization</strong>.</p>\n<blockquote>\n<p id=\"so_16300432_16302929_2\">Objects of POD types (3.9) with static storage duration initialized with constant expressions (5.19) shall be initialized before any dynamic initialization takes place.</p>\n</blockquote>\n<p>But again, no guarantee.</p>\n<hr>\n<h3>Dynamic initialization</h3>\n<p>[basic.start.init]/3</p>\n<blockquote>\n<p id=\"so_16300432_16302929_3\">It is implementation-defined whether or not the dynamic initialization (8.5, 9.4, 12.1, 12.6.1) of an object of namespace scope is done before the first statement of main. If the initialization is deferred to some point in time after the first statement of main, it shall occur before the first use of any function or object defined in the same translation unit as the object to be initialized.</p>\n</blockquote>\n<p>But what is an \"object of namespace scope\"? I have not found any clear definition in the Standard. <em>scope</em> is actually a property of a <em>name</em>, not of an <em>object</em>. Therefore we could read this as \"object defined in namespace scope\" or \"object introduced by a name of namespace scope\". Note the reference \"9.4\" after dynamic initialization. It refers to \"Static members\", which can only mean <em>static data members</em>. So I'd say it means \"object defined at namespace scope\", as static data members are defined at namespace scope:</p>\n<p>[class.static.data]/2</p>\n<blockquote>\n<p id=\"so_16300432_16302929_4\">The definition for a static data member shall appear in a namespace scope enclosing the member\u2019s class definition.</p>\n</blockquote>\n<p>Even if you don't agree on this interpretation, there's still\n[basic.start.init]/1</p>\n<blockquote>\n<p id=\"so_16300432_16302929_5\">Objects with static storage duration defined in namespace scope in the same translation\n  unit and dynamically initialized shall be initialized in the order in which their definition appears in the translation unit.</p>\n</blockquote>\n<p>This clearly applies to static data members, which means that they cannot be initialized differently than <em>objects introduced by names of namespace scope</em> if there's such an object before the definition of the static data member. That is, if there was no guarantee at all on the dynamic initialization of static data members, the guarantees of any preceding <em>object introduced by a name of namespace scope</em> would apply - which are: none (it does not have to be initialized before the first statement of main).</p>\n<p>If there's no such object preceding the definition of the static data member <strong>and</strong> you disagree on the interpretation - there would be no guarantee on the dynamic initialization of static data members at all.</p>\n<hr>\n<h3>Conclusion</h3>\n<p>So we only have a guarantee that dynamic initialization happens sometime (before any usage) plus an exception that initialization with side-effects must not be eliminated. Still, we have no guarantee that <strong>any kind of initialization</strong> of non-local objects is performed before the first statement of <code>main</code>.</p>\n<hr>\n<p>Note: There are workarounds, like:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct my_class\n{\n    static int&amp; my_var()\n    {\n        static int i = 42;\n        return i;\n    }\n};\n\nint j = ++my_class::my_var();\nint k = ++my_class::my_var();\n\nint main()\n{\n    std::cout &lt;&lt; j &lt;&lt; \" : \" &lt;&lt; k &lt;&lt; std::endl;\n}\n</code></pre>\n</hr></hr></hr></hr></hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2013-04-30T21:43:48.853", "Id": "16302929", "Score": "4", "CreationDate": "2013-04-30T14:55:40.110", "LastActivityDate": "2013-04-30T21:43:48.853"}});