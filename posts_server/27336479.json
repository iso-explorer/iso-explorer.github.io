post_cb({"bq_ids": {"n4140": {"so_27336479_27336856_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 3875}, "so_27336479_27336856_1": {"length": 6, "quality": 1.0, "section_id": 3876}}, "n3337": {"so_27336479_27336856_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 3735}, "so_27336479_27336856_1": {"length": 6, "quality": 1.0, "section_id": 3736}}, "n4659": {"so_27336479_27336856_0": {"length": 13, "quality": 0.5652173913043478, "section_id": 4695}, "so_27336479_27336856_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 4690}}}, "27336479": {"ViewCount": "290", "Body": "<p>I just ran into a compilation failure when porting some code from VS2013 to GGC 4.9 and Clang 3.5 ( using libc++ ). The gist of the code is</p>\n<pre><code>#include &lt;cmath&gt;\n\nstruct Foo\n{\n    operator double() const { return( 101.0 ); } // Implicit conversion to double\n};\n\nint main( int, char** )\n{\n    Foo foo;\n\n    std::exp( foo );      // Compiles\n    std::isfinite( foo ); // Does not\n\n    return( 0 );\n}\n</code></pre>\n<p>I believe the <code>isfinite</code> call does not compile because the <code>isfinite</code> funtion in cmath has return type declared as:</p>\n<pre><code>typename std::enable_if&lt;std::is_arithmetic&lt;_A1&gt;::value, bool&gt;::type\n</code></pre>\n<p>and because <code>Foo</code> is not <code>is_arithmetic</code>, <code>isfinite</code> gets removed from the overload set. The same is true of friends of <code>isfinite</code> like <code>isnan</code>. So my question is whether this is expected.</p>\n<p>Does the standard require that arguments to functions like <code>isfinite</code> as actually directly <code>double</code> or <code>float</code> as opposed to being implicitly convertible to them?</p>\n<p>Also I'm a bit unsure why is <code>std::is_arithmetic</code> not <code>std::is_floating_point</code>, doesn't <code>is_arithmetic</code> imply <code>isfinite</code> on integers?</p>\n<p>As an extra question what is the best way of specifying a constraint like <em>is_convertible_to_floating_point</em>?</p>\n", "Title": "SFINAE std::isfinite and similar functions using std::is_arithmetic", "CreationDate": "2014-12-06T21:02:08.973", "LastActivityDate": "2014-12-06T21:37:50.913", "CommentCount": "4", "LastEditDate": "2014-12-06T21:09:21.097", "PostTypeId": "1", "LastEditorUserId": "3953764", "Id": "27336479", "Score": "5", "OwnerUserId": "849856", "Tags": "<c++><c++11><clang++><libc++>", "AnswerCount": "1"}, "27336856": {"Id": "27336856", "PostTypeId": "2", "Body": "<p>\u00a726.8 [c.math]/p10-11:</p>\n<blockquote>\n<p id=\"so_27336479_27336856_0\">The classification/comparison functions behave the same as the C\n  macros with the corresponding names defined in 7.12.3, Classification\n  macros, and 7.12.14, Comparison macros in the C Standard. Each\n  function is overloaded for the three floating-point types, as follows:</p>\n<pre><code>// other functions omitted\nbool isfinite(float x);\n\nbool isfinite(double x);\n\nbool isfinite(long double x);\n</code></pre>\n<p id=\"so_27336479_27336856_1\">Moreover, there shall be additional overloads sufficient to ensure:</p>\n<ol>\n<li>If any arithmetic argument corresponding to a double parameter has type <code>long double</code>, then all arithmetic arguments corresponding to\n  <code>double</code> parameters are effectively cast to <code>long double</code>.</li>\n<li>Otherwise, if any arithmetic argument corresponding to a <code>double</code> parameter has type <code>double</code> or an integer type, then all arithmetic\n  arguments corresponding to <code>double</code> parameters are effectively cast to\n  <code>double</code>.</li>\n<li>Otherwise, all arithmetic arguments corresponding to <code>double</code> parameters have type <code>float</code>.</li>\n</ol>\n</blockquote>\n<p>I'd file a bug against libc++.</p>\n", "LastActivityDate": "2014-12-06T21:37:50.913", "CommentCount": "7", "CreationDate": "2014-12-06T21:37:50.913", "ParentId": "27336479", "Score": "5", "OwnerUserId": "2756719"}});