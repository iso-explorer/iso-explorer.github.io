post_cb({"8949282": {"Id": "8949282", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_8948443_8949282_0\">I just want to export unmangled function names from my dynamic\n  libraries.</p>\n</blockquote>\n<p>Have you considered using a .def file, which will allow you to export the decorated-named-functions by different names?\nThis way you can enjoy the benefits of overloading, and at the same time give your functions \"friendly\" names as you like.</p>\n<pre><code>EXPORTS\nfuncOfInt=?func@a@@AAEXH@Z\nfuncOfSomethingElse=?func@a@@XYZ@W\n</code></pre>\n", "LastActivityDate": "2012-01-20T23:42:04.010", "CommentCount": "1", "CreationDate": "2012-01-20T23:42:04.010", "ParentId": "8948443", "Score": "1", "OwnerUserId": "125997"}, "8949164": {"Id": "8949164", "PostTypeId": "2", "Body": "<h3>5.2.2 Function call  [expr.call]</h3>\n<blockquote>\n<p id=\"so_8948443_8949164_0\">There are two kinds of function call: ordinary function call and member function62 (9.3) call. A function call is a postfix expression followed by parentheses containing a possibly empty, comma-separated list of expressions which constitute the arguments to the function. For an ordinary function call, the postfix expression shall be either an lvalue that refers to a function (in which case the function-to-pointer standard conversion (4.3) is suppressed on the postfix expression), or it shall have pointer to function type. <strong>Calling a function through an expression whose function type has a language linkage that is different from the language linkage of the function type of the called function\u2019s definition is undefined (7.5)</strong>.</p>\n</blockquote>\n<p>So if the type of your function at the call point (ie the type of the function you are calling) is different from the type of the function at the definition point the result is undefined.</p>\n<h3>7.5 Linkage specifications (Paragraph 1) [dcl.link]</h3>\n<blockquote>\n<p id=\"so_8948443_8949164_1\">All function types, function names with external linkage, and variable names with external linkage have a language linkage.</p>\n</blockquote>\n<p>From this we see that the language linkage is part of the type of the function. So both call site and call implementation must have exactly the same language linkage.</p>\n<h3>7.5 Linkage specifications (Paragraph 9) [dcl.link]</h3>\n<blockquote>\n<p id=\"so_8948443_8949164_2\">Linkage from C++ to objects defined in other languages and to objects defined in C++ from other languages is implementation-defined and language-dependent. Only where the object layout strategies of two language implementations are similar enough can such linkage be achieved.</p>\n</blockquote>\n<p>Since C does not support C++ types, No C++ objects can be passed across the interface in a meaningful way. The function can not have C language linkage and be passed C++ objects. Thus we are breaking the type rules defined above.</p>\n<p>But: Not only do we have to consider the layout of the object but how the object is passed/returned. Are values passed on the stack or by register this is all defined by the ABI and since C/C++ have different API there is no guarantee how the object is passed from one to the other or that the expectations of function cleanup are the same.</p>\n", "LastActivityDate": "2012-01-20T23:27:20.850", "CommentCount": "10", "CreationDate": "2012-01-20T23:27:20.850", "ParentId": "8948443", "Score": "3", "OwnerUserId": "14065"}, "8948443": {"ViewCount": "2348", "Body": "<p>Can an <code>extern \"C\"</code> function accept or return C++-specific data types, such as references, pointers-to-members, or non-POD classes (by value)? I cannot find anything in the C++ standard that forbids this. Logically, I would expect the standard to say something about it, as the C ABI is not necessarily suitable for passing such types around.</p>\n<p>The reason for me wanting to use C linkage has nothing to do with C compilers. The function is called only from C++ code. I just want to export unmangled function names from my dynamic libraries.</p>\n<p>A silly code example:</p>\n<pre><code>class Foo {\n  public:\n    virtual void doit() = 0;\n};\n\nclass Bar : public Foo {\n  public:\n    void doit() { std::cout &lt;&lt; \"Bar\" &lt;&lt; std::endl; }\n};\n\nextern \"C\" Foo&amp; getFoo() { static Bar bar; return bar; }\n\nextern \"C\" Bar getBar() { return Bar(); }\n</code></pre>\n<p>This compiles with GCC on Linux, and works as expected. Should it, standard-wise?</p>\n<p>The question is a follow-up to a discussion in the comments to <a href=\"https://stackoverflow.com/q/8945327/775806\">this question</a>.</p>\n<p><strong>Update</strong> I have tested this with the Comeau compiler, it didn't complain.</p>\n", "AcceptedAnswerId": "8948820", "Title": "Interface to C++ objects through extern \"C\" functions", "CreationDate": "2012-01-20T22:02:23.610", "Id": "8948443", "CommentCount": "0", "LastEditDate": "2017-05-23T12:14:54.497", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2012-01-21T10:53:32.870", "Score": "13", "OwnerUserId": "775806", "Tags": "<c++><standards><linkage>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_8948443_8949164_1": {"length": 14, "quality": 1.0, "section_id": 5517}, "so_8948443_8949164_2": {"length": 23, "quality": 0.92, "section_id": 5525}, "so_8948443_8949164_0": {"length": 50, "quality": 0.78125, "section_id": 5988}}, "n3337": {"so_8948443_8949164_1": {"length": 14, "quality": 1.0, "section_id": 5303}, "so_8948443_8949164_2": {"length": 23, "quality": 0.92, "section_id": 5311}, "so_8948443_8949164_0": {"length": 62, "quality": 0.96875, "section_id": 5756}}, "n4659": {"so_8948443_8949164_1": {"length": 14, "quality": 1.0, "section_id": 6952}, "so_8948443_8949164_2": {"length": 23, "quality": 0.92, "section_id": 6960}, "so_8948443_8949164_0": {"length": 48, "quality": 0.75, "section_id": 7488}}}, "8948553": {"Id": "8948553", "PostTypeId": "2", "Body": "<p>I don't have a definitive answer to this but extrapolating from <a href=\"http://en.wikipedia.org/wiki/Compatibility_of_C_and_C++\" rel=\"nofollow\">Wikipedia</a>, I'd say that this isn't guaranteed to work. The article (I don't have a copy of the standard) says <code>extern \"C\"</code> specs both the mangling and the ABI. C ABIs presumably don't spec non-C types so you're off in unspec'd behavior. (The article also cites cases where the C and C++ ABIs are different though that doesn't seem like it'd be an issue here.)</p>\n<p>So while I imagine it might work in virtually all cases, I doubt you could cite chapter and verse from the standards that say it must. I'd not be terribly surprised to see a compiler that refused to compile it.</p>\n", "LastActivityDate": "2012-01-20T22:15:19.353", "CommentCount": "4", "CreationDate": "2012-01-20T22:15:19.353", "ParentId": "8948443", "Score": "1", "OwnerUserId": "191215"}, "8948820": {"Id": "8948820", "PostTypeId": "2", "Body": "<p>According to section 7.5.9 Linkage specifications (c++11 draft) <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf</a></p>\n<p>\"Linkage from C++ to objects defined in other languages and to objects defined in C++ from other languages is implementation-defined and language-dependent. Only where the object layout strategies of two language implementations are similar enough can such linkage be achieved.\"</p>\n", "LastActivityDate": "2012-01-20T22:46:06.160", "CommentCount": "6", "CreationDate": "2012-01-20T22:46:06.160", "ParentId": "8948443", "Score": "7", "OwnerUserId": "1149664"}});