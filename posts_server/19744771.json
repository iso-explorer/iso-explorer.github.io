post_cb({"19744771": {"CommentCount": "2", "ViewCount": "117", "CreationDate": "2013-11-02T17:33:27.737", "LastActivityDate": "2013-11-02T18:27:36.233", "Title": "Vector`s end iterator content", "AcceptedAnswerId": "19744777", "PostTypeId": "1", "Id": "19744771", "Score": "1", "Body": "<p>I have 2 questions regarding following examples:\n1)</p>\n<pre><code>std::vector&lt;int&gt; v(5,1);\ncout &lt;&lt; *v.end();\n</code></pre>\n<p>Is a printed result is undefined (depends on compiler)</p>\n<p>2)</p>\n<pre><code>int x = 5,y = 6;\nstd::vector&lt;int*&gt; pv;\npv.push_back(&amp;x);\npv.push_back(&amp;y);\ncout &lt;&lt; *pv.end();\n</code></pre>\n<p>Is a printed result is undefined (depends on compiler) or NULL</p>\n", "Tags": "<c++><stl><iterator>", "OwnerUserId": "466056", "AnswerCount": "6"}, "19744941": {"ParentId": "19744771", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Firstly, in both cases the <em>behavior</em> is undefined. Note, that is not \"the printed result\" that is undefined. You code does not even get a chance to print anything. A mere application of <code>*</code> operator to end iterator already causes undefined behavior. E.g. this alone</p>\n<pre><code>*v.end();\n</code></pre>\n<p>is already undefined behavior.</p>\n<p>Secondly, undefined in this case does not mean \"depends on the compiler\". <em>Implementation-defined</em> behavior depends on the compiler. <em>Undefined</em> means \"completely unpredictable\", even if you are using the same compiler.</p>\n<p>P.S. There's seems to be a bit of ongoing work in the standard commitee with reagard to some closely related issues. </p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208</a></p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1213\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1213</a></p>\n<p>Hopefully it will result in a clearer specification of what is legal and what is not for the past-the-end iterators. But it is clear that in general case past-the-end iterator can legally be a singular iterator, meaning that in general case it can be non-dereferenceable.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2013-11-02T18:25:22.317", "Id": "19744941", "Score": "1", "CreationDate": "2013-11-02T17:53:49.433", "LastActivityDate": "2013-11-02T18:25:22.317"}, "19744835": {"ParentId": "19744771", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><code>vector::end</code> - Return iterator to end (public member function )</p>\n<p>You can read more <a href=\"http://www.cplusplus.com/reference/vector/vector/end/\" rel=\"nofollow noreferrer\">here</a>.</p>\n<hr>\n<p>Your <strong>first example</strong>:</p>\n<pre><code>    std::vector&lt;int&gt; v(5,1);\n    cout &lt;&lt; *(v.end()-1);\n</code></pre>\n<p>It's <strong>undefined</strong> (look at the picture), <code>v.end()</code> is pointing to the address after the last element and if the container is empty, this function returns the same as <code>v.begin()</code>.\n<img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/dCK9O.jpg\"/></p>\n<p>And your <strong>second example</strong>:</p>\n<pre><code>    int x = 5,y = 6;\n    std::vector&lt;int*&gt; pv;\n    pv.push_back(&amp;x);\n    pv.push_back(&amp;y);\n    cout &lt;&lt; **(pv.end()-1);\n</code></pre>\n</hr>", "OwnerUserId": "2258268", "LastEditorUserId": "2258268", "LastEditDate": "2013-11-02T18:27:36.233", "Id": "19744835", "Score": "0", "CreationDate": "2013-11-02T17:40:35.367", "LastActivityDate": "2013-11-02T18:27:36.233"}, "19744777": {"ParentId": "19744771", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You have no item at <code>end()</code>, it's an iterator right after the last valid item in your vector.</p>\n<pre><code>*v.end();\n</code></pre>\n<p>It's <strong><em>undefined behavior</em></strong>. You can use <code>end()</code> for comparing an iterator whether it's pointing to the item after last item or not.</p>\n<p>Easy way to access the value of last item is <a href=\"http://en.cppreference.com/w/cpp/container/vector/back\" rel=\"nofollow\"><code>back()</code></a>, for example:</p>\n<pre><code>cout &lt;&lt; v.back();\n</code></pre>\n", "OwnerUserId": "952747", "LastEditorUserId": "952747", "LastEditDate": "2013-11-02T17:42:37.223", "Id": "19744777", "Score": "3", "CreationDate": "2013-11-02T17:34:15.860", "LastActivityDate": "2013-11-02T17:42:37.223"}, "19744858": {"ParentId": "19744771", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Dereferencing past the end is will probably end badly but it looks like it is <em>implementation defined</em>, if we look at the draft C++ standard section <code>24.21</code> <em>Iterator requirements</em> and then to <code>24.2.1</code> <em>In general</em> paragraph <em>5</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19744771_19744858_0\">Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array, so for any iterator type there is an iterator value that points past the last element of a corresponding sequence. These values are called past-the-end values. <strong>Values of an iterator i for which the expression <em>i is defined are called dereferenceable. The library never assumes that past-the-end values are dereferenceable.</em></strong> Iterators can also have singular values that are not associated with any sequence. [ Example: After the declaration of an uninitialized pointer x (as with int</p></blockquote> x;), x must always be assumed to have a singular value of a pointer. \u2014end example ] <strong>Results of most expressions are undefined for singular values</strong>; [...] <strong>Dereferenceable values are always non-singular.</strong>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2013-11-02T17:55:33.473", "Id": "19744858", "Score": "1", "CreationDate": "2013-11-02T17:43:19.740", "LastActivityDate": "2013-11-02T17:55:33.473"}, "19744792": {"ParentId": "19744771", "CommentCount": "0", "Body": "<p>The <code>end()</code> iterator points to a position that is one element <strong>after</strong> the last element of the container. Accessing the data that it points to will invoke <strong>undefined behavior</strong> and this is the case in both your examples.</p>\n", "OwnerUserId": "812912", "PostTypeId": "2", "Id": "19744792", "Score": "2", "CreationDate": "2013-11-02T17:35:49.957", "LastActivityDate": "2013-11-02T17:35:49.957"}, "19744776": {"ParentId": "19744771", "CommentCount": "0", "Body": "<p>Yes, both of those are undefined.</p>\n", "OwnerUserId": "1212596", "PostTypeId": "2", "Id": "19744776", "Score": "0", "CreationDate": "2013-11-02T17:34:15.803", "LastActivityDate": "2013-11-02T17:34:15.803"}, "bq_ids": {"n4140": {"so_19744771_19744858_0": {"section_id": 5559, "quality": 0.9107142857142857, "length": 51}}, "n3337": {"so_19744771_19744858_0": {"section_id": 5341, "quality": 0.9107142857142857, "length": 51}}, "n4659": {"so_19744771_19744858_0": {"section_id": 7006, "quality": 0.9107142857142857, "length": 51}}}});