post_cb({"33849744": {"Id": "33849744", "PostTypeId": "2", "Body": "<p>Yes, it does.</p>\n<p>Neither C nor C++ special case accesses via pointers vs. other accesses, the strict aliasing rules apply regardless of whether you use a pointer, a reference, or any other lvalue.</p>\n<p>If you run into trouble, the easiest solution is to use memcpy to copy the memory location into a local variable - any self-respectable compiler will completely optimise this mempcy away and only treat it as an aliasing hint (memcpy is also preferable over unions, because the union method is not as portable).</p>\n", "LastActivityDate": "2015-11-21T23:13:33.077", "CommentCount": "0", "CreationDate": "2015-11-21T23:13:33.077", "ParentId": "33849613", "Score": "1", "OwnerUserId": "1303846"}, "33849613": {"ViewCount": "182", "Body": "<p>I know that <code>int* ptr = (int*)buffer</code> (where <code>buffer</code> is <code>char*</code>) breaks\nstrict-aliasing rule.</p>\n<p>Does this syntax <code>int&amp; ref = (int&amp;)(*buffer)</code> also break the rule?</p>\n<p>I <a href=\"https://stackoverflow.com/questions/33843444/segfault-in-o3-mode\">had</a> some SEGFAULTs due to violation of the strict aliasing rule, and this syntax has eliminated that. Though probably still is incorrect, is it?</p>\n", "AcceptedAnswerId": "33849671", "Title": "Does access by reference violate strict aliasing rule?", "CreationDate": "2015-11-21T22:57:25.750", "Id": "33849613", "CommentCount": "3", "LastEditDate": "2017-05-23T11:51:53.150", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-21T23:14:11.140", "Score": "1", "OwnerUserId": "3465049", "Tags": "<c++><strict-aliasing>", "AnswerCount": "3"}, "33849737": {"Id": "33849737", "PostTypeId": "2", "Body": "<p>This is not ok (assuming you're going to use said reference to access the value). \u00a7 3.10 [basic.lval] \u00b6 10 of the C++14 standard (quoting N4140) says (emphasis mine):</p>\n<blockquote>\n<p id=\"so_33849613_33849737_0\"><strong>If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</strong></p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type\n  of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or non-static data members (including, recursively, an element or non-static data member of a subaggregate\n  or contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a <code>char</code> or <code>unsigned char</code> type.</li>\n</ul>\n</blockquote>\n<p>It doesn't matter whether you attempt to access via a pointer or a reference. For a stored object of type <code>char</code>, none of the bullet points apply to make it allowed accessing it as an <code>int</code>.</p>\n<p>The last bullet point only says that you may alias any <em>other</em> type as <code>char</code> but not vice versa. It makes sense because a <code>char</code> is the smallest addressable unit with the weakest alignment requirements.</p>\n<p>If you want, using a pointer is the same as using a reference except that you need to dereference explicitly in order to access the value.</p>\n", "LastActivityDate": "2015-11-21T23:12:47.873", "CommentCount": "0", "CreationDate": "2015-11-21T23:12:47.873", "ParentId": "33849613", "Score": "2", "OwnerUserId": "1392132"}, "33849671": {"Id": "33849671", "PostTypeId": "2", "Body": "<p>Strict aliasing rules mean that you should not dereference pointers of different types pointing to the same memory location.</p>\n<p>Since in your posted code you never dereference, it's not possible to tell if this violates the rule without seeing all the code.</p>\n<p>Also, aliasing to the char* type is an exception and does not violate the rule. Which means you can access a memory location containing any type by converting its pointer to char*, and dereferencing it.</p>\n<p>To conclude:</p>\n<ul>\n<li>If <code>buffer</code> points on a memory location which contains an int, and was converted from <code>int*</code> to <code>char*</code>, this is valid. However, you should use <code>reinterpret_cast</code> for this</li>\n<li>If buffer points to a memory location which contains chars, dereferencing the <code>int* ptr</code> does violate the rule.</li>\n<li>The reference version is likely to suffer from the same problem. But the compiler has no obligation to prevent or warn you from doing this</li>\n<li>Don't use C style casts, use reinterpret_cast instead, and read the standard about which uses have defined behavior.</li>\n</ul>\n", "LastEditorUserId": "2042388", "LastActivityDate": "2015-11-21T23:14:11.140", "Score": "1", "CreationDate": "2015-11-21T23:04:50.930", "ParentId": "33849613", "CommentCount": "2", "OwnerUserId": "2042388", "LastEditDate": "2015-11-21T23:14:11.140"}, "bq_ids": {"n4140": {"so_33849613_33849737_0": {"length": 14, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_33849613_33849737_0": {"length": 14, "quality": 1.0, "section_id": 6983}}, "n4659": {"so_33849613_33849737_0": {"length": 14, "quality": 1.0, "section_id": 8748}}}});