post_cb({"bq_ids": {"n4140": {"so_25345206_25345359_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 4695}}, "n3337": {"so_25345206_25345359_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 4504}}, "n4659": {"so_25345206_25345359_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 6090}}}, "25345255": {"Id": "25345255", "PostTypeId": "2", "Body": "<p>If you're willing to use <a href=\"http://www.boost.org/doc/libs/1_56_0/libs/type_traits/doc/html/index.html\" rel=\"nofollow\">Boost.TypeTraits</a>, they provide <code>boost::is_complex</code> for use with <code>std::complex</code>.</p>\n<pre><code>#include &lt;complex&gt;\n#include &lt;type_traits&gt;\n#include &lt;boost/type_traits.hpp&gt;\n\nint main()\n{\n    static_assert(std::is_floating_point&lt;float&gt;::value, \"some message\");\n    static_assert(std::is_floating_point&lt;double&gt;::value, \"some message\");\n    static_assert(boost::is_complex&lt;std::complex&lt;float&gt;&gt;::value, \"some message\");\n    static_assert(boost::is_complex&lt;std::complex&lt;double&gt;&gt;::value, \"some message\");\n}\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/68562371db8c8cbb\" rel=\"nofollow\">Live example</a></kbd></p>\n", "OwnerDisplayName": "user3920237", "LastActivityDate": "2014-08-17T00:31:09.110", "Score": "1", "CreationDate": "2014-08-17T00:31:09.110", "ParentId": "25345206", "CommentCount": "0"}, "25345359": {"Id": "25345359", "PostTypeId": "2", "Body": "<p>It is generally illegal to add specializations for standard library type trait classes, even for user-defined types. \u00a720.10.2 [meta.type.synop]/p1:</p>\n<blockquote>\n<p id=\"so_25345206_25345359_0\">The behavior of a program that adds specializations for any of the\n  class templates defined in this subclause is undefined unless\n  otherwise specified.</p>\n</blockquote>\n<p>Currently, the only type trait class that users are allowed to add specializations for is <code>std::common_type</code>, if at least one template parameter in the specialization is a user-defined type (\u00a720.10.7.6 [meta.trans.other], Table 57).</p>\n<p>You need to write your own trait, which isn't hard:</p>\n<pre><code>template&lt;class T&gt;\nstruct is_complex_or_floating_point : std::is_floating_point&lt;T&gt; { };\n\ntemplate&lt;class T&gt;\nstruct is_complex_or_floating_point&lt;std::complex&lt;T&gt;&gt; : std::is_floating_point&lt;T&gt; { };\n</code></pre>\n<p><a href=\"http://ideone.com/y7U2p5\">Demo</a>.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-17T01:04:54.273", "Score": "9", "CreationDate": "2014-08-17T00:50:52.880", "ParentId": "25345206", "CommentCount": "1", "OwnerUserId": "2756719", "LastEditDate": "2014-08-17T01:04:54.273"}, "25345206": {"ViewCount": "409", "Body": "<p>I want the types <code>double</code>, <code>float</code>, <code>complex&lt;double&gt;</code> and <code>complex&lt;float&gt;</code> to pass a <code>static_assert</code> condition. I figured <code>static_assert(std::is_floating&lt;T&gt;::value, \"some message\")</code> would do the trick, but the complex types do not pass this test (at least under gcc-4.10). </p>\n<p>What predicate would I add to make sure these four types (and perhaps <code>long double</code>s as well) are allowed as template instantiations, but nothing else?</p>\n", "AcceptedAnswerId": "25345359", "Title": "Getting std::complex<double> to pass std::is_floating_point test", "CreationDate": "2014-08-17T00:17:57.380", "Id": "25345206", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-08-17T01:04:54.273", "Score": "5", "OwnerUserId": "904050", "Tags": "<c++><templates><c++11><static-assert>", "AnswerCount": "2"}});