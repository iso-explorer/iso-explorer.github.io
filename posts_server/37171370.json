post_cb({"37171600": {"ParentId": "37171370", "CommentCount": "3", "Body": "<p><code>delete[]</code> must be used for arrays and <code>delete</code> for non-arrays. Since <code>x</code> is a pointer to an array, you must use <code>delete[]</code>. The citation is [expr.delete]/2. The first Note makes this crystal clear.</p>\n<blockquote>\n<p id=\"so_37171370_37171600_0\">If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned\n  conversion function, and the converted operand is used in place of the original operand for the remainder of\n  this section. In the first alternative (<em>delete object</em>), the value of the operand of <code>delete</code> may be a null pointer\n  value, a pointer to a non-array object created by a previous new-expression, or a pointer to a subobject (1.8)\n  representing a base class of such an object (Clause 10). If not, the behavior is undefined. In the second\n  alternative (<em>delete array</em>), the value of the operand of <code>delete</code> may be a null pointer value or a pointer\n  value that resulted from a previous array <em>new-expression.</em> If not, the behavior is undefined. [ <em>Note:</em> this\n  means that the syntax of the <em>delete-expression</em> must match the type of the object allocated by <code>new</code>, not\n  the syntax of the <em>new-expression.</em> \u2014 <em>end note</em> ] [ <em>Note:</em> a pointer to a <code>const</code> type can be the operand of a\n  <em>delete-expression;</em> it is not necessary to cast away the constness (5.2.11) of the pointer expression before it\n  is used as the operand of the <em>delete-expression.</em> \u2014 <em>end note</em> ]</p>\n</blockquote>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "37171600", "Score": "8", "CreationDate": "2016-05-11T19:22:21.153", "LastActivityDate": "2016-05-11T19:22:21.153"}, "bq_ids": {"n4140": {"so_37171370_37171600_0": {"section_id": 6106, "quality": 0.9072164948453608, "length": 88}}, "n3337": {"so_37171370_37171600_0": {"section_id": 5872, "quality": 0.9072164948453608, "length": 88}}, "n4659": {"so_37171370_37171600_0": {"section_id": 7603, "quality": 0.9072164948453608, "length": 88}}}, "37171370": {"CommentCount": "4", "AcceptedAnswerId": "37171600", "PostTypeId": "1", "LastEditorUserId": "1413395", "CreationDate": "2016-05-11T19:08:56.980", "LastActivityDate": "2016-05-11T19:22:56.230", "LastEditDate": "2016-05-11T19:22:56.230", "ViewCount": "89", "FavoriteCount": "1", "Title": "Is this deletion expected to destruct each array object?", "Id": "37171370", "Score": "2", "Body": "<p>Suppose I use a variation of using <code>new</code> to return a pointer to an array:</p>\n<pre><code>class Type { /* ... */ };\n\ntypedef Type Type_42[1][42];\nType (*x)[42] = new Type_42;\n</code></pre>\n<p>Since I used <code>new</code> to create, I use <code>delete</code> to destroy:</p>\n<pre><code>delete x;\n</code></pre>\n<p>Is it expected that each of the destructors for the 42 objects will be called?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "315052", "AnswerCount": "1"}});