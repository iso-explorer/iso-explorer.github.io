post_cb({"1380602": {"ParentId": "1380567", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><code>std::map</code> has a third template argument, after key and value, to denote what function is going to be used to compare keys.  By default, it is <code>std::less</code>, which in it's turn uses <code>operator&lt;</code>.  So if your class has an operator&lt;, it's ok, else you can provide a comparator of your own.</p>\n", "OwnerUserId": "6610", "LastEditorUserId": "6610", "LastEditDate": "2009-11-03T09:39:01.337", "Id": "1380602", "Score": "8", "CreationDate": "2009-09-04T17:37:50.967", "LastActivityDate": "2009-11-03T09:39:01.337"}, "1380611": {"ParentId": "1380567", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The full type for map is</p>\n<pre><code>template &lt; class Key, class T, class Compare = less&lt;Key&gt;,\n       class Allocator = allocator&lt;pair&lt;const Key,T&gt; &gt; &gt; class map;\n</code></pre>\n<p>It uses  less than by default but as long as you pass in a class that has operator () overloaded to take two instances of the object and returns a bool all is well. note if you give it comp(a,b) and it returns true, then a should come before b in the ordering.</p>\n", "OwnerUserId": "92601", "LastEditorUserId": "123111", "LastEditDate": "2009-09-04T18:21:21.487", "Id": "1380611", "Score": "3", "CreationDate": "2009-09-04T17:38:57.250", "LastActivityDate": "2009-09-04T18:21:21.487"}, "1380586": {"ParentId": "1380567", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>All of you need is to define <code>operator&lt;</code> for <code>MyClassObj</code>. For more information about std::map you could read <a href=\"http://www.cplusplus.com/reference/stl/map/\" rel=\"nofollow noreferrer\">here</a>.</p>\n<p>According to C++ Standard 23.1.2:</p>\n<blockquote>\n<p id=\"so_1380567_1380586_0\">The phrase \u2018\u2018equivalence of keys\u2019\u2019 means the equivalence relation imposed by the comparison and not the\n  operator== on keys.  That is, two keys k1 and k2 are considered to be equivalent if for the comparison\n  object comp, comp(k1, k2) == false &amp;&amp; comp(k2, k1) == false.</p>\n</blockquote>\n<p>By default <code>comp</code> is <code>std::less</code>.</p>\n<p>According to C++ Standard 20.3.3:</p>\n<blockquote id=\"so_1380567_1380586_1\">\n<pre><code>template &lt;class T&gt; struct less : binary_function&lt;T,T,bool&gt; {\nbool operator()(const T&amp; x, const T&amp; y) const;\n};\n\n// operator() returns x &lt; y.\n</code></pre>\n</blockquote>\n<p>Surely, you could define stand alone functor <code>comp</code> for comparison.</p>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2009-09-04T18:11:26.950", "Id": "1380586", "Score": "6", "CreationDate": "2009-09-04T17:34:51.190", "LastActivityDate": "2009-09-04T18:11:26.950"}, "1380595": {"ParentId": "1380567", "CommentCount": "0", "Body": "<p>Yes, you can use your own type/object as a key. They'll have to implement the less-than operator (operator&lt;) as all ordered standard C++ containers do use this operator to test for ordering and equality.</p>\n", "OwnerUserId": "29068", "PostTypeId": "2", "Id": "1380595", "Score": "2", "CreationDate": "2009-09-04T17:36:33.730", "LastActivityDate": "2009-09-04T17:36:33.730"}, "1380567": {"CommentCount": "0", "ViewCount": "946", "PostTypeId": "1", "LastEditorUserId": "123111", "CreationDate": "2009-09-04T17:30:44.053", "LastActivityDate": "2009-11-03T09:39:01.337", "Title": "Can I use an stl map if I plan to use arbitrary class objects as the key?", "AcceptedAnswerId": "1380602", "LastEditDate": "2009-09-04T17:31:46.390", "Id": "1380567", "Score": "4", "Body": "<p>I'm new to STL. The thing stumping me about using a map to store arbitrary objects:</p>\n<pre><code>std::map&lt;MyClassObj, MyDataObject&gt; MyMap;\n</code></pre>\n<p>is how I find objects.  How would MyMap.find (MyClassObjInstance) work for instance?  Do I need to implement my own iterator and provide some standard functions which would include some equivalence function?  Any examples would be appreciated.</p>\n<p>Is there another method to store an associated list of arbitrary objects using standard libraries?  I'm already using stl to maintain platform portability, and would prefer not to add another library dependency like BOOST.</p>\n", "Tags": "<c++><stl><associative-array>", "OwnerUserId": "8761", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_1380567_1380586_0": {"section_id": 739, "quality": 0.9090909090909091, "length": 20}, "so_1380567_1380586_1": {"section_id": 4595, "quality": 0.7272727272727273, "length": 8}}, "n3337": {"so_1380567_1380586_0": {"section_id": 728, "quality": 0.9090909090909091, "length": 20}, "so_1380567_1380586_1": {"section_id": 4419, "quality": 0.7272727272727273, "length": 8}}, "n4659": {"so_1380567_1380586_0": {"section_id": 797, "quality": 0.9090909090909091, "length": 20}, "so_1380567_1380586_1": {"section_id": 7926, "quality": 0.5454545454545454, "length": 6}}}});