post_cb({"bq_ids": {"n4140": {"so_28780307_28780498_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 11}}, "n3337": {"so_28780307_28780498_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 8}}, "n4659": {"so_28780307_28780498_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 12}}}, "28780307": {"ViewCount": "104", "Body": "<p>May I know why's the reason that when I declare a pointer array like</p>\n<pre><code>char *suits[]={\"abc\",\"cab\",\"bca\"}\n</code></pre>\n<p>there is no error even I am assigning a string instead of the address to pointer?\nBecause from what I have learnt, the pointer can only be assigned by address(&amp;) or another pointer(*). Even more puzzling part is when I print out the pointer array </p>\n<pre><code>cout&lt;&lt;suits[1]; \n</code></pre>\n<p>I got the string \"cab\", instead of the address even I do not use the dereference operator. And when I use the dereference operator</p>\n<pre><code>cout&lt;&lt;*suits[1];\n</code></pre>\n<p>I got 'c' only. </p>\n<p>To sum up the questions are 1)why I can assign a string to char type pointer instead of an address or pointer, and 2) why when I print out the char type pointer, instead of giving me the address, it shows out the string. 3)Finally,why is that when I dereference the char type pointer, it give me the value of the first char in the string. </p>\n<p>Really wanna know why char type pointer is so different from others?</p>\n", "AcceptedAnswerId": "28780511", "Title": "Assign string to the pointer array", "CreationDate": "2015-02-28T09:44:15.973", "Id": "28780307", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-02-28T10:14:18.520", "Score": "0", "OwnerUserId": "2066253", "Tags": "<c++><arrays><string><pointers>", "AnswerCount": "2"}, "28780498": {"Id": "28780498", "PostTypeId": "2", "Body": "<p>According to the C++ Standard</p>\n<blockquote>\n<p id=\"so_28780307_28780498_0\">4.2 Array-to-pointer conversion [conv.array]</p>\n<p id=\"so_28780307_28780498_1\">1 An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown\n  bound of T\u201d can be converted to a prvalue of type \u201cpointer to T\u201d. <strong>The\n  result is a pointer to the first element of the array.</strong></p>\n</blockquote>\n<p>In this declaration</p>\n<pre><code>char *suits[]={\"abc\",\"cab\",\"bca\"}\n</code></pre>\n<p>all string literals have type <code>const char[4]</code> and initializer expressions based on these string literals are converted to pointers to first elements of the string literals. In C++ they have type <code>const char *</code>. Thus it would be more correctly to declare the array like</p>\n<pre><code>const char *suits[]={\"abc\",\"cab\",\"bca\"}\n</code></pre>\n<p>For pointers to char <code>operator &lt;&lt;</code> is explicitly overloaded and performs output characters pointed to by the pointer until the zero-terminating character will be encountered. That is it is supposed that if you use a pointer to char in operator &lt;&lt; then you are going to output a string pointed to by this pointer.</p>\n<p>As for this record </p>\n<p>cout&lt;&lt;*suits[1];</p>\n<p>then according to the definition of suits as an array of pointers suits[1] is the second element of the array and it is the pointer that points to the first element of string literal \"cab\".  So dereferencing the pointer you will get the first element of the string literal that is character 'c'.</p>\n", "LastActivityDate": "2015-02-28T10:05:48.557", "CommentCount": "4", "CreationDate": "2015-02-28T10:05:48.557", "ParentId": "28780307", "Score": "2", "OwnerUserId": "2877241"}, "28780511": {"Id": "28780511", "PostTypeId": "2", "Body": "<p>You seem to be confused about what a string is in C.</p>\n<p>A string is an array of chars, where the last char is <code>'\\0'</code>.</p>\n<p>If you write <code>\"abc\"</code> in your source code, anywhere, then the compiler will create an array for you, almost as if you had declared a global variable:</p>\n<pre><code>char abc_string[4] = {'a', 'b', 'c', '\\0'};\n</code></pre>\n<p>(although it won't actually be called <code>abc_string</code>).</p>\n<p>Same for \"cab\" and \"bca\".</p>\n<p>Then, your definition is equivalent to this:</p>\n<pre><code>char *suits[]={abc_string, cab_string, bca_string};\n// where abc_string, cab_string and bca_string are the arrays created by the compiler.\n</code></pre>\n<p>Now, when you use an array name in C, most of the time it is automatically converted (it \"decays\") to a pointer to its first element. So in the above definition, <code>abc_string</code> actually means <code>&amp;abc_string[0]</code> - a pointer to the first element of <code>abc_string</code>.</p>\n<pre><code>char *suits[] = {&amp;abc_string[0], &amp;cab_string[0], &amp;bca_string[0]};\n</code></pre>\n<p>Now it should be clear what the elements of <code>suits</code> point to - they point to the first character of each string.</p>\n<p>This isn't specific to arrays - if you write:</p>\n<pre><code>char *thing = \"hello world\";\n</code></pre>\n<p>then the compiler generates an array containing <code>{'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\\0'}</code>, and sets <code>thing</code> to point to its first element.</p>\n", "LastActivityDate": "2015-02-28T10:07:27.430", "CommentCount": "1", "CreationDate": "2015-02-28T10:07:27.430", "ParentId": "28780307", "Score": "0", "OwnerUserId": "106104"}});