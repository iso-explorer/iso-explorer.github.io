post_cb({"bq_ids": {"n4140": {"so_26241397_26241397_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7210}, "so_26241397_26241397_0": {"length": 35, "quality": 0.8333333333333334, "section_id": 7202}, "so_26241397_26241397_2": {"length": 14, "quality": 0.875, "section_id": 7210}}, "n3337": {"so_26241397_26241397_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 6954}, "so_26241397_26241397_0": {"length": 35, "quality": 0.8333333333333334, "section_id": 6946}, "so_26241397_26241397_2": {"length": 13, "quality": 0.8125, "section_id": 6954}}, "n4659": {"so_26241397_26241397_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 8719}, "so_26241397_26241397_0": {"length": 35, "quality": 0.8333333333333334, "section_id": 8711}, "so_26241397_26241397_2": {"length": 14, "quality": 0.875, "section_id": 8719}}}, "26241445": {"Id": "26241445", "PostTypeId": "2", "Body": "<p>This is probably meant to give the compiler headroom for optimizations on some platforms.</p>\n<p>Consider for example a 64 bit platform where handling non-64 bit values incurs a large penalty, then it would make sense to have e.g. short only use 16 bits (value repr), but still use 64 bit storage (obj repr).</p>\n<p>Similar rationale applies to the <em>Fastest minimum-width integer types</em> mandated by <code>&lt;stdint&gt;</code>. Sometimes larger types are not slower, but faster to use.</p>\n", "LastActivityDate": "2014-10-07T17:08:04.730", "CommentCount": "2", "CreationDate": "2014-10-07T17:08:04.730", "ParentId": "26241397", "Score": "3", "OwnerUserId": "675646"}, "26241786": {"Id": "26241786", "PostTypeId": "2", "Body": "<p>As far as I understand at least one case for this is dealing with trap representations, usually on exotic architectures. This issue is covered in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2631.html\" rel=\"nofollow\">N2631: Resolving the difference between C and C++ with regards to object representation of integers</a>. It is is very long but I will quote some sections(<em>The author is James Kanze, so if we are lucky maybe he will drop by and comment further</em>) which says (<em>emphasis mine</em>). </p>\n<blockquote>\n<p id=\"so_26241397_26241786_0\">In recent discussions in comp.lang.c++, it became clear that C and C++ have different requirements <strong>concerning the object representation of integers,</strong> and that at least one real implementation of C does not meet the C++ requirements. The purpose of this paper is to suggest wording to align the C++ standard with C.</p>\n<p id=\"so_26241397_26241786_1\">It should be noted that the issue only concerns some fairly \u201cexotic\u201d hardware. In this regard, it raises a somewhat larger issue</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_26241397_26241786_2\">If C compatibility is desired, it seems to me that the simplest and surest way of attaining this is by incorporating the exact words from the C standard, in place of the current wording. I thus propose that we adopt the wording from the C standard, as follows </p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_26241397_26241786_3\">Certain object representations need not represent a value of the object type. If the stored value of an object has such a representation and is read by an <strong>lvalue expression that does not have character type, the behavior is undefined.</strong> If such a representation is produced by a side effect that modifies all or any part of the object by an lvalue expression that does not have character type, the behavior is undefined. <strong>Such a representation is called a trap representation.</strong></p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_26241397_26241786_4\">For signed integer types [...] <strong>Which of these applies is implementation-defined, as is whether the value with sign bit 1 and all value bits zero (for the first two), or with sign bit and all value bits 1 (for one's complement), is a trap representation or a normal value</strong>. In the case of sign and magnitude and one's complement, if this representation is a normal value it is called a negative zero.</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-10-07T20:14:57.460", "Score": "2", "CreationDate": "2014-10-07T17:31:26.427", "ParentId": "26241397", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-10-07T20:14:57.460"}, "26241397": {"ViewCount": "298", "Body": "<p><code>N3797::3.9/4  [basic.types]</code> :</p>\n<blockquote>\n<p id=\"so_26241397_26241397_0\">The <em>object representation</em> of an object of type T is the sequence of N\n  unsigned char objects taken up by the object of type T, where N equals\n  sizeof(T). The <em>value representation</em> of an object is the set of bits\n  that hold the value of type T. For trivially copyable types, the value\n  representation is a set of bits in the object representation that\n  determines a value, which is one discrete element of an\n  implementation-defined set of values</p>\n</blockquote>\n<p><code>N3797::3.9.1  [basic.fundamental]</code> says:</p>\n<blockquote>\n<p id=\"so_26241397_26241397_1\">For narrow character types, all bits of the object representation\n  participate in the value representation.</p>\n</blockquote>\n<p>Consider the following struct:</p>\n<pre><code>struct A\n{\n    char a;\n    int b;\n}\n</code></pre>\n<p>I think for <code>A</code> not all bits of the object representation participate in the value representation because of padding added by implementation. But what about others fundamentals type? \nThe Standard says:\n<code>N3797::3.9.1  [basic.fundamental]</code></p>\n<blockquote>\n<p id=\"so_26241397_26241397_2\">For narrow character types, all bits of the object representation\n  participate in the value representation.\n  These requirements <em>do not</em> hold for other types.</p>\n</blockquote>\n<p>I can't imagine why it doesn't hold for say <code>int</code> or <code>long</code>. What's the reason? Could you clarify?</p>\n", "AcceptedAnswerId": "26241722", "Title": "Difference between object and value representation by example", "CreationDate": "2014-10-07T17:05:35.867", "Id": "26241397", "CommentCount": "2", "LastEditDate": "2014-10-07T17:33:28.750", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastEditorUserId": "1708801", "LastActivityDate": "2014-10-07T20:14:57.460", "Score": "4", "Tags": "<c++><memory><language-lawyer>", "AnswerCount": "3"}, "26241722": {"Id": "26241722", "PostTypeId": "2", "Body": "<p>An example might be the Unisys mainframes, where an <code>int</code> has 48\nbits, but only 40 participate in the <em>value representation</em> (and <code>INT_MAX</code> is 2^39-1); the\nothers must be 0.  I imagine that any machine with a tagged\narchitecture would have similar issues.</p>\n<p>EDIT:</p>\n<p>Just some further information: the Unisys mainframes are\nprobably the only remaining architectures which are really\nexotic: the Unisys Libra (ex-Burroughs) have a 48 bit word, use signed\nmagnitude for integers, and have a tagged architecture, where\nthe data itself contains information concerning its type.  The\nUnisys Dorado are the ex-Univac: 36 bit one's complement (but no\nreserved bits for tagging) and 9 bit char's.</p>\n<p>From what I understand, however, Unisys is phasing them out (or\nhas phased them out in the last year) in favor of Intel based\nsystems.  Once they disappear, pretty much all systems will be\n2's complement, 32 or 64 bits, and all but the IBM mainframes\nwill use IEEE floating poing (and IBM is moving or has moved in\nthat direction as well).  So there won't be any motivation for\nthe standard to continue with special wording to support them;\nin the end, in a couple of years at lesat, C/C++ could probably\nfollow the Java path, and impose a representation on all of its\nbasic data types.</p>\n", "LastEditorUserId": "649665", "LastActivityDate": "2014-10-07T18:15:02.790", "Score": "5", "CreationDate": "2014-10-07T17:27:17.353", "ParentId": "26241397", "CommentCount": "2", "OwnerUserId": "649665", "LastEditDate": "2014-10-07T18:15:02.790"}});