post_cb({"24779929": {"ViewCount": "3324", "Body": "<p>I'm interested if these two lines of code are the same:</p>\n<pre><code>shared_ptr&lt;int&gt; sp(new int(1)); // double allocation?\nshared_ptr&lt;int&gt; sp(make_shared&lt;int&gt;(1)); // just one allocation?\n</code></pre>\n<p>If this is true could someone please explain why is it only one allocation in the second line?</p>\n", "AcceptedAnswerId": "24780012", "Title": "What happens when using make_shared", "CreationDate": "2014-07-16T11:42:42.983", "Id": "24779929", "CommentCount": "6", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2014-07-16T21:26:33.143", "LastEditorUserId": "1708801", "LastActivityDate": "2014-07-17T09:50:26.017", "Score": "24", "OwnerUserId": "1659758", "Tags": "<c++><c++11><smart-pointers><make-shared>", "AnswerCount": "3"}, "24780149": {"Id": "24780149", "PostTypeId": "2", "Body": "<p>Explanation from <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow\">cppreference std::shared_ptr</a> in <code>Implementation notes</code> section</p>\n<blockquote>\n<p id=\"so_24779929_24780149_0\">In a typical implementation, std::shared_ptr holds only two pointers:</p>\n<ol>\n<li>a pointer to the managed object</li>\n<li>a pointer to control block</li>\n</ol>\n<p id=\"so_24779929_24780149_1\">When shared_ptr is created by calling std::make_shared or\n  std::allocate_shared, the memory for both the control block and the\n  managed object is created with a single allocation. The managed object\n  is constructed in-place in a data member of the control block. When\n  shared_ptr is created via one of the shared_ptr constructors, the\n  managed object and the control block must be allocated separately. In\n  this case, the control block stores a pointer to the managed object.</p>\n</blockquote>\n", "LastEditorUserId": "2328763", "LastActivityDate": "2014-07-16T12:06:56.770", "Score": "4", "CreationDate": "2014-07-16T11:54:28.290", "ParentId": "24779929", "CommentCount": "0", "OwnerUserId": "2328763", "LastEditDate": "2014-07-16T12:06:56.770"}, "24800228": {"Id": "24800228", "PostTypeId": "2", "Body": "<p>There is also a potential subtle bug: in <code>sp(new int)</code> you fist allocate an int (whose pointer is given to <code>sp</code>), than sp itself has to allocate a control block (will contain the counters and the deleter).</p>\n<p>Now, if doing this last allocation <code>sp</code> fails (low memory) you are left with a heap allocated int whose pointer is not held by anyone, and thus impossible to delete. (memory leak).</p>\n", "LastActivityDate": "2014-07-17T09:50:26.017", "CommentCount": "0", "CreationDate": "2014-07-17T09:50:26.017", "ParentId": "24779929", "Score": "0", "OwnerUserId": "924727"}, "bq_ids": {"n4140": {"so_24779929_24780012_4": {"length": 15, "quality": 0.7894736842105263, "section_id": 4444}, "so_24779929_24780012_3": {"length": 13, "quality": 0.7222222222222222, "section_id": 4443}}, "n3337": {"so_24779929_24780012_4": {"length": 15, "quality": 0.7894736842105263, "section_id": 4281}, "so_24779929_24780012_3": {"length": 13, "quality": 0.7222222222222222, "section_id": 4280}}, "n4659": {"so_24779929_24780012_4": {"length": 15, "quality": 0.7894736842105263, "section_id": 5709}, "so_24779929_24780012_3": {"length": 13, "quality": 0.7222222222222222, "section_id": 5708}}}, "24780012": {"Id": "24780012", "PostTypeId": "2", "Body": "<p>The first case does not perform a double allocation, it performs two allocations, one for the <em>managed object</em> and one for the <em>control block</em> of the <code>shared_ptr</code>.</p>\n<p>For the second case, <a href=\"http://en.cppreference.com/w/\">cppreference</a> has a good explanation for why <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\">std::make_shared</a> <strong>usually</strong> only performs one memory allocation it says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_24779929_24780012_0\">This function typically allocates memory for the T object and for the\n  shared_ptr's control block with a single memory allocation <strong>(it is a\n  non-binding requirement in the Standard)</strong>. In contrast, the declaration\n  std::shared_ptr p(new T(Args...)) performs at least two memory\n  allocations, which may incur unnecessary overhead.</p>\n</blockquote>\n<p>and from <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\">std::shared_ptr</a> section it says:</p>\n<blockquote>\n<p id=\"so_24779929_24780012_1\">When shared_ptr is created by calling std::make_shared or\n  std::allocate_shared, the memory for both the control block and the\n  managed object is created with a single allocation. The managed object\n  is constructed in-place in a data member of the control block. When\n  shared_ptr is created via one of the shared_ptr constructors, the\n  managed object and the control block must be allocated separately. In\n  this case, the control block stores a pointer to the managed object.</p>\n</blockquote>\n<p>This <code>make_shared</code> description is consistent with the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\">C++11 draft standard</a> which says in section <code>20.7.2.2.6</code> <em>shared_ptr creation</em></p>\n<blockquote>\n<pre><code>template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);\ntemplate&lt;class T, class A, class... Args&gt;\n  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);\n</code></pre>\n<p id=\"so_24779929_24780012_2\">[...]</p>\n<p id=\"so_24779929_24780012_3\">Remarks: Implementations should perform no more than one memory\n  allocation. [ Note: This provides efficiency equivalent to an\n  intrusive smart pointer. \u2014end note ]</p>\n<p id=\"so_24779929_24780012_4\">[ Note: These functions will typically allocate more memory than\n  sizeof(T) to allow for internal bookkeeping structures such as the\n  reference counts. \u2014end note ]</p>\n</blockquote>\n<p>Herb Sutter has a more detailed explanation of the advantages of using <code>make_shared</code> in <a href=\"http://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/\">GotW #89 Solution: Smart Pointers</a> and points out some advantages:</p>\n<ul>\n<li>It reduces allocation overhead</li>\n<li>It improves locality. </li>\n<li>Avoids an explicit new.</li>\n<li>Avoids an exception safety issue.</li>\n</ul>\n<p>Be aware that when using <a href=\"http://en.cppreference.com/w/cpp/memory/weak_ptr\">std::weak_ptr</a> <a href=\"http://lanzkron.wordpress.com/2012/04/22/make_shared-almost-a-silver-bullet/\">using make_shared has some disadvantages</a>.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-07-17T09:23:36.237", "Score": "31", "CreationDate": "2014-07-16T11:46:59.560", "ParentId": "24779929", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-07-17T09:23:36.237"}});