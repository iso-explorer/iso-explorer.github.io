post_cb({"32763826": {"ParentId": "32763062", "Score": "10", "CreationDate": "2015-09-24T14:20:55.930", "LastActivityDate": "2015-09-24T14:46:40.617", "LastEditDate": "2015-09-24T14:46:40.617", "OwnerUserId": "2069064", "LastEditorUserId": "420683", "Body": "<p>This is bad:</p>\n<pre><code>auto q = std::tuple&lt;A&amp;&amp;,A&amp;&amp;&gt;(A{100},A{200});\n</code></pre>\n<p>you are constructing a <code>tuple</code> of rvalue references to temporaries that get destroyed at the end of the expression, so you're left with dangling references. </p>\n<p>The correct statement would be:</p>\n<pre><code>std::tuple&lt;A, A&gt; q(100, 200);\n</code></pre>\n<hr/>\n<p>However, until quite recently, the above was not supported by the standard. In N4296, the wording around the relevant constructor for <code>tuple</code> is [tuple.cnstr]:</p>\n<blockquote>\n<pre><code>template &lt;class... UTypes&gt;\n  constexpr explicit tuple(UTypes&amp;&amp;... u);\n</code></pre>\n<p id=\"so_32763062_32763826_0\"><em>Requires</em>: <code>sizeof...(Types) == sizeof...(UTypes)</code>. <code>is_constructible&lt;Ti, Ui&amp;&amp;&gt;::value</code> is true\n  for all <code>i</code>.<br>\n<em>Effects</em>: Initializes the elements in the tuple with the corresponding value in <code>std::forward&lt;UTypes&gt;(u)</code>.<br>\n<em>Remark</em>: This constructor shall not participate in overload resolution <strong>unless each type in <code>UTypes</code> is\n  implicitly convertible to its corresponding type in <code>Types</code></strong>.</br></br></p>\n</blockquote>\n<p>So, this constructor was not participating in overload resolution because <code>int</code> is not implicitly convertible to <code>A</code>. This has been resolved by the adoption of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4387.html\">Improving <code>pair</code> and <code>tuple</code></a>, which addressed precisely your use-case:</p>\n<pre><code>struct D { D(int); D(const D&amp;) = delete; };    \nstd::tuple&lt;D&gt; td(12); // Error\n</code></pre>\n<p>The new wording for this constructor is, from N4527:</p>\n<blockquote>\n<p id=\"so_32763062_32763826_1\"><em>Remarks</em>: This constructor shall not participate in overload resolution <strong>unless <code>sizeof...(Types) &gt;= 1</code> and <code>is_constructible&lt;Ti, Ui&amp;&amp;&gt;::value</code> is true for all <code>i</code></strong>. The constructor is explicit if and only\n  if <code>is_convertible&lt;Ui&amp;&amp;, Ti&gt;::value</code> is <code>false</code> for at least one <em>i</em>.</p>\n</blockquote>\n<p>And <code>is_constructible&lt;A, int&amp;&amp;&gt;::value</code> is true. </p>\n<p>To present the difference another way, here is an extremely stripped down tuple implementation:</p>\n<pre><code>struct D { D(int ) {} D(const D&amp; ) = delete; };\n\ntemplate &lt;typename T&gt;\nstruct Tuple {\n    Tuple(const T&amp; t)\n    : T(t)\n    { }\n\n    template &lt;typename U,\n#ifdef USE_OLD_RULES\n              typename = std::enable_if_t&lt;std::is_convertible&lt;U, T&gt;::value&gt;\n#else\n              typename = std::enable_if_t&lt;std::is_constructible&lt;T, U&amp;&amp;&gt;::value&gt;\n#endif\n              &gt;\n    Tuple(U&amp;&amp; u)\n    : t(std::forward&lt;U&gt;(u))\n    { }\n\n    T t;\n};\n\nint main()\n{\n    Tuple&lt;D&gt; t(12);\n}\n</code></pre>\n<p>If <code>USE_OLD_RULES</code> is defined, the first constructor is the only viable constructor and hence the code will not compile since <code>D</code> is noncopyable. Otherwise, the second constructor is the best viable candidate and that one is well-formed. </p>\n<hr/>\n<p>The adoption was recent enough that neither gcc 5.2 nor clang 3.6 actually will compile this example yet. So you will either need a newer compiler than that (gcc 6.0 works) or come up with a different design. </p>\n", "Id": "32763826", "PostTypeId": "2", "CommentCount": "7"}, "32763062": {"Tags": "<c++><c++11><tuples>", "ViewCount": "391", "LastEditDate": "2015-09-24T14:44:08.460", "CreationDate": "2015-09-24T13:47:26.110", "LastEditorUserId": "2069064", "Title": "std::tuple for non-copyable and non-movable object", "CommentCount": "12", "AcceptedAnswerId": "32763826", "Score": "8", "OwnerUserId": "4373992", "Id": "32763062", "LastActivityDate": "2015-09-24T15:04:00.257", "Body": "<p>I have a class with copy &amp; move ctor deleted.</p>\n<pre><code>struct A\n{\n    A(int a):data(a){}\n    ~A(){ std::cout &lt;&lt; \"~A()\" &lt;&lt; this &lt;&lt; \" : \" &lt;&lt; data &lt;&lt; std::endl; }\n\n    A(A const &amp;obj) = delete;\n    A(A &amp;&amp;obj) = delete;\n\n    friend std::ostream &amp; operator &lt;&lt; ( std::ostream &amp; out , A const &amp; obj);\n\n    int data;\n};\n</code></pre>\n<p>And I want to create a tuple with objects of this class. But the following does not compile:</p>\n<pre><code>auto p = std::tuple&lt;A,A&gt;(A{10},A{20}); \n</code></pre>\n<p>On the other hand, the following <em>does</em> compile, but gives a surprising output.</p>\n<pre><code>int main() {\n    auto q = std::tuple&lt;A&amp;&amp;,A&amp;&amp;&gt;(A{100},A{200});\n    std::cout &lt;&lt; \"q created\\n\";\n}\n</code></pre>\n<p>Output</p>\n<pre><code>~A()0x22fe10 : 100\n~A()0x22fe30 : 200\nq created\n</code></pre>\n<p>It means that dtor for objects is called as soon as tuple construction line ends. So, what is significance of a tuple of destroyed objects?</p>\n", "PostTypeId": "1", "FavoriteCount": "3", "AnswerCount": "2"}, "32763866": {"ParentId": "32763062", "Score": "1", "CreationDate": "2015-09-24T14:22:56.540", "LastActivityDate": "2015-09-24T15:04:00.257", "LastEditDate": "2015-09-24T15:04:00.257", "OwnerUserId": "3545273", "LastEditorUserId": "2069064", "Body": "<p>Your problem is that you explicitly asked for a tuple of rvalue references, and a rvalue reference is not that far from a pointer.</p>\n<p>So <code>auto q = std::tuple&lt;A&amp;&amp;,A&amp;&amp;&gt;(A{100},A{200});</code> creates two A objects, takes (rvalue) references to them, build the tuple with the references... and destroys the temporary objects, leaving you with two dangling references</p>\n<p>Even if it is said to be more secure than good old C and its dangling pointers, C++ still allows programmer to write wrong programs.</p>\n<p>Anyway, the following would make sense (note usage of A&amp; and not A&amp;&amp;):</p>\n<pre><code>int main() {\n    A a(100), b(100); // Ok, a and b will leave as long as main\n    auto q = tuple&lt;A&amp;, A&amp;&gt;(a, b);  // ok, q contains references to a and b\n    ...\n    return 0; // Ok, q, a and b will be destroyed\n}\n</code></pre>\n", "Id": "32763866", "PostTypeId": "2", "CommentCount": "0"}, "bq_ids": {"n4659": {"so_32763062_32763826_1": {"length": 12, "section_id": 4926, "quality": 0.631578947368421}}}});