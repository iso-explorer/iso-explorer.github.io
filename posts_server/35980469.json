post_cb({"35980469": {"CommentCount": "28", "ViewCount": "187", "PostTypeId": "1", "LastEditorUserId": "2397809", "CreationDate": "2016-03-14T05:59:55.253", "LastActivityDate": "2016-03-14T09:25:23.840", "Title": "Does the C++ standard explicitly disallow default arguments in calls through constexpr member function pointers?", "AcceptedAnswerId": "35983656", "LastEditDate": "2016-03-14T09:05:57.827", "Id": "35980469", "Score": "3", "Body": "<p>Consider the code below:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>struct foo {\n    int bar(int, int = 0) {\n        return 0;\n    }\n};\n\nconstexpr auto ptr = &amp;foo::bar;\n\nint main() { \n    return (foo{}.*ptr)(0);\n}\n</code></pre>\n<p>As expected, this code fails to compile with recent versions of GCC, Clang, and MSVC.</p>\n<p>It is, however, plausible that a hypothetical compiler be capable of passing default arguments through a<code>constexpr</code> member function pointer. If this compiler successfully compiled the code above <strong>&lt;edit&gt;</strong> without warnings <strong>&lt;/edit&gt;</strong>, effectively passing <code>0, 0</code> to <code>foo::bar</code>, would it still conform to the ISO C++ standard?</p>\n<p>An acceptable answer will reference the standard (or a working draft thereof). I have not yet found an answer in working draft N4567.</p>\n<p><strong>Edit:</strong> If the standard has no comment on this issue, I'll accept that as an answer as well.</p>\n", "Tags": "<c++><c++11><language-lawyer><constexpr>", "OwnerUserId": "2397809", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_35980469_35983656_1": {"section_id": 3255, "quality": 0.9, "length": 9}}, "n3337": {"so_35980469_35983656_1": {"section_id": 3127, "quality": 0.9, "length": 9}}, "n4659": {"so_35980469_35983656_1": {"section_id": 4013, "quality": 0.9, "length": 9}}}, "35983656": {"ParentId": "35980469", "CommentCount": "1", "Body": "<p>The C++ standard does not explicitly disallow most ill-formed constructs, including this one. It is enough for it to not be explicitly or implicitly allowed to be ill-formed.</p>\n<p>A conforming C++ implementation is allowed to accept anything at all, including ill-formed C++ programs. It is, however, require to issue at least one diagnostic if the input is not a well-formed C++ program (except in cases where an explicit \"no diagnostic required\" clause is present in the standard). So the question of what a conforming compiler is allowed to do rests on the question of whether the program in question is well-formed.</p>\n<p>In order to address this latter question, we should establish whether <code>constexpr</code> bears any relevance. The answer to this is a definite \"no\". The <code>constexpr</code> keyword causes certain expressions that are otherwise not constant-expressions to become such, and has no other meaning. In turn, constant-expressions are different from plain vanilla expressions in a strictly limited number of well-defined contexts, such as array declarations or template instantiations. In such contexts a non-constant expression would render the program ill-formed. Since no such context is present in the program in question, we must conclude that <code>constexpr</code> bears no relevance on well-formedness of the program.</p>\n<p>In particular, being a constant-expression does not free an expression from its obligation to be type-correct. As a trivial example,</p>\n<pre><code>`(int*)nullptr - (int*)nullptr`\n</code></pre>\n<p>is well-formed, while</p>\n<pre><code>`(int*)nullptr - (double*)nullptr`\n</code></pre>\n<p>is type-incorrect and thus ill-formed, despite both operands being constant expressions, known at compile-time to be equal to <code>nullptr</code>.</p>\n<blockquote>\n<p id=\"so_35980469_35983656_0\">Disclaimer: C-style casts are for demonstration purpose only, as they read better in short code snippets. Don't use them in production code.</p>\n</blockquote>\n<p>So we have to examine whether the program sans <code>constexpr</code> is well-formed or not. This question, surprisingly, doesn't have a direct answer in the standard, and may in fact have no answer at all. According to the statically-typed nature of C++, the call should be ill-formed, but I could not find a direct statement to this effect. Rather than pondering potential implications of this, I would rather declare this a technical defect of the standard and call it a day.</p>\n<p>The standard does indirectly state that default function arguments are properties of function <em>declarations</em> rather than functions themselves:</p>\n<blockquote>\n<p id=\"so_35980469_35983656_1\">(8.3.6/4) Declarations in different scopes have completely distinct sets of default arguments</p>\n</blockquote>\n<p>Thus, a function pointer, being an entity that references a function rather than a function declaration, should not have default arguments applied.</p>\n", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "35983656", "Score": "6", "CreationDate": "2016-03-14T09:25:23.840", "LastActivityDate": "2016-03-14T09:25:23.840"}});