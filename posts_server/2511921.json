post_cb({"2511941": {"Id": "2511941", "PostTypeId": "2", "Body": "<p>An integer constant expression that evaluates to 0 is valid as a null pointer, so the first case is also dereferencing a null pointer.</p>\n<p>A pointer which is set to 0 via some arithmetic calculation is not necessarily a null pointer. In most implementations it will behave in the same way as a null pointer, but this is not guaranteed by the standard.</p>\n", "LastEditorUserId": "61974", "LastActivityDate": "2010-03-24T23:17:26.790", "Score": "12", "CreationDate": "2010-03-24T22:36:17.093", "ParentId": "2511921", "CommentCount": "4", "OwnerUserId": "61974", "LastEditDate": "2010-03-24T23:17:26.790"}, "2511921": {"ViewCount": "7453", "Body": "<p>The standard says that dereferencing the null pointer leads to undefined behaviour. But what is \"the null pointer\"? In the following code, what we call \"the null pointer\":</p>\n<pre><code>struct X\n{\n  static X* get() { return reinterpret_cast&lt;X*&gt;(1); }\n  void f() { }\n};\n\nint main()\n{\n  X* x = 0;\n  (*x).f(); // the null pointer?  (1)\n\n  x = X::get();\n  (*x).f(); // the null pointer?  (2)\n\n  x = reinterpret_cast&lt;X*&gt;( X::get() - X::get() );\n  (*x).f(); // the null pointer?  (3)\n\n  (*(X*)0).f(); // I think that this the only null pointer here (4)\n}\n</code></pre>\n<p>My thought is that dereferencing of the null pointer takes place only in the last case. Am I right? Is there difference between compile time null pointers and runtime according to C++ Standard?</p>\n", "AcceptedAnswerId": "2511939", "Title": "Which of these will create a null pointer?", "CreationDate": "2010-03-24T22:32:12.250", "Id": "2511921", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2010-05-24T13:40:13.520", "LastEditorUserId": "34509", "LastActivityDate": "2010-05-24T13:40:13.520", "Score": "14", "OwnerUserId": "194510", "Tags": "<c++><dereference><null-pointer>", "AnswerCount": "4"}, "2514087": {"Id": "2514087", "PostTypeId": "2", "Body": "<p>C++ Standard (2003) 4.10 </p>\n<p><strong>4.10 Pointer conversions</strong></p>\n<blockquote>\n<p id=\"so_2511921_2514087_0\">1 A null pointer constant is an\n  integral constant expression (5.19)\n  rvalue of integer type that evaluates\n  to zero.  A null pointer constant can\n  be converted to a pointer type; the\n  result is the null pointer value of\n  that type and is distinguishable from\n  every other value of pointer to object\n  or pointer to function type.  Two null\n  pointer values of the same type shall\n  compare equal.  The conversion of a\n  null pointer constant to a pointer to\n  cv-qualified type is a single\n  conversion, and not the sequence of a\n  pointer conversion followed by a\n  qualification conversion (4.4).</p>\n</blockquote>\n<p><strong>5.2.10 Reinterpret cast</strong></p>\n<blockquote>\n<p id=\"so_2511921_2514087_1\">Note 64) Converting an integral constant\n  expression (5.19) with value zero\n  always yields a null pointer (4.10),\n  but converting other expressions\n  that happen to have value zero need\n  not yield a null pointer.</p>\n</blockquote>\n<p>1)  <code>X* x = 0; (*x).f();</code> Yes.\n0 is integral constant expression and is converted to the null pointer constant.\nThen null pointer constant can be converted to the null pointer value.</p>\n<p>2) <code>x = X::get();</code> no, see note 64 in 5.2.10</p>\n<p>3) <code>x = reinterpret_cast&lt;X*&gt;( X::get() - X::get() );</code> no, see note 64 in 5.2.10</p>\n<p>4) (<em>(X</em>)0).f(); Yes.\n 0 (integral constant expression) --&gt; the null pointer constant --&gt;\nthe null pointer value.</p>\n", "LastActivityDate": "2010-03-25T08:53:51.693", "CommentCount": "1", "CreationDate": "2010-03-25T08:53:51.693", "ParentId": "2511921", "Score": "7", "OwnerUserId": "124161"}, "bq_ids": {"n4140": {"so_2511921_2514087_0": {"length": 48, "quality": 0.8421052631578947, "section_id": 39}}, "n3337": {"so_2511921_2514087_0": {"length": 53, "quality": 0.9298245614035088, "section_id": 36}}, "n4659": {"so_2511921_2514087_0": {"length": 48, "quality": 0.8421052631578947, "section_id": 39}}}, "2511939": {"Id": "2511939", "PostTypeId": "2", "Body": "<p>Only the first and the last are null pointers. The others are results of <code>reinterpret_cast</code> and thus operate on implementation defined pointer values. Whether the behavior is undefined for them depends on whether there is an object at the address you casted to. </p>\n", "LastActivityDate": "2010-03-24T22:36:10.620", "CommentCount": "3", "CreationDate": "2010-03-24T22:36:10.620", "ParentId": "2511921", "Score": "12", "OwnerUserId": "34509"}, "2511955": {"Id": "2511955", "PostTypeId": "2", "Body": "<pre><code>X* x = 0;\n(*x).f(); // the null pointer?  (1)\n</code></pre>\n<p>I think this qualifies as dereference, even though <code>f()</code> never actually uses the <code>this</code> pointer, and there are no virtual methods in <code>X</code>. My reflex was to say that this is a crash, but now that I think of it, I'm not so sure.</p>\n<pre><code>x = X::get();\n(*x).f(); // the null pointer?  (2)\n</code></pre>\n<p>Probably an invalid pointer. not sure whether it will crash (see above for reasoning). </p>\n<pre><code>x = reinterpret_cast&lt;X*&gt;( X::get() - X::get() );\n(*x).f(); // the null pointer?  (3)\n</code></pre>\n<p>Does the expression <code>X::get() - X::get()</code> compile? I didn't think it was legal to subtract a pointer from another pointer like that.</p>\n<p>EDIT: D'oh! Of course it's legal. What was I thinking? Clearly, I am a maroon.</p>\n", "LastEditorUserId": "264540", "LastActivityDate": "2010-03-25T01:00:57.803", "Score": "0", "CreationDate": "2010-03-24T22:38:39.807", "ParentId": "2511921", "CommentCount": "7", "OwnerUserId": "264540", "LastEditDate": "2010-03-25T01:00:57.803"}});