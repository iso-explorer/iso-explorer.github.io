post_cb({"bq_ids": {"n4140": {"so_15578935_15579050_3": {"length": 23, "quality": 0.7666666666666667, "section_id": 6046}, "so_15578935_15579185_0": {"length": 39, "quality": 0.639344262295082, "section_id": 6046}, "so_15578935_15579050_2": {"length": 23, "quality": 0.7666666666666667, "section_id": 6046}}, "n3337": {"so_15578935_15579050_3": {"length": 29, "quality": 0.9666666666666667, "section_id": 5814}, "so_15578935_15579185_0": {"length": 56, "quality": 0.9180327868852459, "section_id": 5814}, "so_15578935_15579050_2": {"length": 28, "quality": 0.9333333333333333, "section_id": 5814}}, "n4659": {"so_15578935_15579050_3": {"length": 23, "quality": 0.7666666666666667, "section_id": 7545}, "so_15578935_15579185_0": {"length": 38, "quality": 0.6229508196721312, "section_id": 7545}, "so_15578935_15579050_2": {"length": 23, "quality": 0.7666666666666667, "section_id": 7545}}}, "15579185": {"Id": "15579185", "PostTypeId": "2", "Body": "<p>You should <code>static_cast</code>. <strong>Use <code>static_cast</code> in cases where you're undoing an implicit conversion.</strong></p>\n<p>In this particular case, however, there is no difference because you're converting from <code>void*</code>. But in general, <code>reinterpret_cast</code>ing between two object pointers is defined to be (\u00a75.2.10/7):</p>\n<blockquote>\n<p id=\"so_15578935_15579185_0\">An object pointer can be explicitly converted to an object pointer of a di\ufb00erent type. When a prvalue <code>v</code> of type \u201cpointer to <code>T1</code>\u201d is converted to the type \u201cpointer to cv <code>T2</code>\u201d, <strong>the result is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code></strong> if both <code>T1</code> and <code>T2</code> are standard-layout types and the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>, or if either type is <code>void</code>. Converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value. The result of any other such pointer conversion is unspeci\ufb01ed. </p>\n</blockquote>\n<p>Emphasis mine. Since <code>T1</code> for you is already <code>void*</code>, the cast to <code>void*</code> in <code>reinterpret_cast</code> does nothing. This is not true in general, which is what <a href=\"https://stackoverflow.com/a/15579008/87234\">Drew Dormann is saying</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nvoid print_pointer(const volatile T* ptr)\n{\n    // this is needed by oversight in the standard\n    std::cout &lt;&lt; static_cast&lt;void*&gt;(const_cast&lt;T*&gt;(ptr)) &lt;&lt; std::endl;\n}\n\nstruct base_a {};\nstruct base_b {};\nstruct derived : base_a, base_b {};\n\nint main()\n{\n    derived d;\n\n    base_b* b = &amp;d; // implicit cast\n\n    // undo implicit cast with static_cast\n    derived* x = static_cast&lt;derived*&gt;(b);\n\n    // reinterpret the value with reinterpret_cast\n    derived* y = reinterpret_cast&lt;derived*&gt;(b);\n\n    print_pointer(&amp;d);\n    print_pointer(x);\n    print_pointer(y);\n}\n</code></pre>\n<p>Output:</p>\n<blockquote>\n<p id=\"so_15578935_15579185_1\">00CBFD5B<br>\n  00CBFD5B<br>\n  00CBFD5C  </br></br></p>\n</blockquote>\n<p>(Note that because <code>y</code> doesn't actually point to a <code>derived</code>, using it is undefined behavior.)</p>\n<p>Here, <code>reinterpret_cast</code> comes up with a different value because it goes through <code>void*</code>. This is why you should use <code>static_cast</code> when you can, and <code>reinterpret_cast</code> when you have to.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-03-22T20:18:46.120", "Score": "18", "CreationDate": "2013-03-22T20:18:46.120", "ParentId": "15578935", "CommentCount": "2", "OwnerUserId": "87234", "LastEditDate": "2017-05-23T12:26:04.590"}, "15579050": {"Id": "15579050", "PostTypeId": "2", "Body": "<p>Using <code>static_cast</code> to cast a pointer to and from <code>void*</code> is guaranteed to preserve the address.</p>\n<p><code>reinterpret_cast</code> on the other hand guarantees that if you cast the pointer from one type to other, and back to the original type, the address is preserved.</p>\n<p>Although with most implementations, you would see the same results in using either of these, <code>static_cast</code> should be preferred.</p>\n<p>And with <code>C++11</code> I remember that, using <code>reinterpret_cast</code> for <code>void*</code> has a well defined behavior. Before that this behavior was prohibited.</p>\n<pre><code>It is not permitted to use reinterpret_cast to convert between pointers to object type and pointers to void.\n</code></pre>\n<blockquote>\n<p id=\"so_15578935_15579050_0\">Proposed resolution (August, 2010):</p>\n<p id=\"so_15578935_15579050_1\">Change 5.2.10 [expr.reinterpret.cast] paragraph 7 as follows:</p>\n<p id=\"so_15578935_15579050_2\">An object pointer can be explicitly converted to an object pointer of\n  a different type. When a prvalue v of type \u201cpointer to T1\u201d is\n  converted to the type \u201cpointer to cv T2\u201d, the result is <strong>static_cast(static_cast(v))</strong> if both T1 and T2 are standard-layout\n  types (3.9 [basic.types]) and the alignment requirements of T2 are no\n  stricter than those of T1, or if either type is void.</p>\n<p id=\"so_15578935_15579050_3\">Converting a prvalue of type \u201cpointer to T1\u201d to the type \u201cpointer to\n  T2\u201d (where T1 and T2 are object types and where the alignment\n  requirements of T2 are no stricter than those of T1) and back to its\n  original type yields the original pointer value. The result of any\n  other such pointer conversion is unspecified.</p>\n</blockquote>\n<p>More info <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1120\" rel=\"nofollow noreferrer\">here</a>.</p>\n<p>Thanks to <a href=\"https://stackoverflow.com/users/906773/jesse-good\">Jesse Good</a> for the link.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-03-22T20:19:02.977", "Score": "5", "CreationDate": "2013-03-22T20:09:31.577", "ParentId": "15578935", "CommentCount": "1", "OwnerUserId": "380757", "LastEditDate": "2017-05-23T12:17:55.067"}, "15578935": {"ViewCount": "30249", "Body": "<p>Considering the <a href=\"http://blogs.msdn.com/b/oldnewthing/archive/2005/05/19/420038.aspx\" rel=\"noreferrer\">following code</a> (and the fact that <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/aa366887%28v=vs.85%29.aspx\" rel=\"noreferrer\"><code>VirtualAlloc()</code> returns a <code>void*</code></a>):</p>\n<pre><code>BYTE* pbNext = reinterpret_cast&lt;BYTE*&gt;(\n    VirtualAlloc(NULL, cbAlloc, MEM_COMMIT, PAGE_READWRITE));\n</code></pre>\n<p>why is <code>reinterpret_cast</code> chosen instead of <code>static_cast</code>?</p>\n<p>I used to think that <code>reinterpret_cast</code> is OK for e.g. casting pointers to and from integer types (like e.g. <code>DWORD_PTR</code>), but to cast from a <code>void*</code> to a <code>BYTE*</code>, isn't <code>static_cast</code> OK?</p>\n<p>Are there any (subtle?) differences in this particular case, or are they just both valid pointer casts?</p>\n<p>Does the C++ standard have a preference for this case, suggesting a way instead of the other?</p>\n", "AcceptedAnswerId": "15579008", "Title": "Proper way of casting pointer types", "CreationDate": "2013-03-22T20:01:46.093", "Id": "15578935", "CommentCount": "3", "FavoriteCount": "8", "PostTypeId": "1", "LastActivityDate": "2017-09-08T11:52:11.400", "Score": "34", "OwnerUserId": "1629821", "Tags": "<c++><pointers><casting><reinterpret-cast><static-cast>", "AnswerCount": "3"}, "15579008": {"Id": "15579008", "PostTypeId": "2", "Body": "<p>Either cast is acceptable for pointers to fundamental types, so you are correct that <code>static_cast</code> is okay.</p>\n<p>When converting between two pointer types, <em>it's possible that the specific memory address held in the pointer needs to change</em>.</p>\n<p>That's where the two casts differ.  <code>static_cast</code> will make the appropriate adjustment.  <code>reinterpret_cast</code> will avoid changing the pointer's stored value.</p>\n<p>For that reason, it's a good general rule to <code>static_cast</code> between pointer types unless you <strong>know</strong> that <code>reinterpret_cast</code> is desired.  </p>\n", "LastEditorUserId": "16287", "LastActivityDate": "2017-09-08T11:52:11.400", "Score": "25", "CreationDate": "2013-03-22T20:06:46.767", "ParentId": "15578935", "CommentCount": "0", "OwnerUserId": "16287", "LastEditDate": "2017-09-08T11:52:11.400"}});