post_cb({"9114751": {"ParentId": "9114657", "CommentCount": "1", "Body": "<p>I believe that legally, you may treat a single object as an array of size one. In addition, it is most definitely legal to take a pointer one past the end of any array as long as it's not de-referenced. So I believe that it is not UB.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "9114751", "Score": "4", "CreationDate": "2012-02-02T15:14:37.490", "LastActivityDate": "2012-02-02T15:14:37.490"}, "9114933": {"ParentId": "9114657", "CommentCount": "0", "Body": "<p>In general it would be undefined behaviour to point beyond the memory space, however there is an exception for \"one past the end\", which is valid according to the standard.</p>\n<p>Therefore in the particular example, <code>&amp;c+1</code> is a valid pointer but cannot be safely dereferenced.</p>\n", "OwnerUserId": "442284", "PostTypeId": "2", "Id": "9114933", "Score": "0", "CreationDate": "2012-02-02T15:26:41.313", "LastActivityDate": "2012-02-02T15:26:41.313"}, "9114657": {"CommentCount": "14", "AcceptedAnswerId": "9114776", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-02-02T15:08:20.330", "LastActivityDate": "2012-02-02T16:37:55.627", "LastEditDate": "2017-05-23T11:54:23.387", "ViewCount": "590", "FavoriteCount": "0", "Title": "Is it undefined behavior to form a pointer range from a stack address?", "Id": "9114657", "Score": "9", "Body": "<p>Some C or C++ programmers are surprised to find out that even <a href=\"https://stackoverflow.com/questions/3838855/is-storing-an-invalid-pointer-automatically-undefined-behavior\">storing an invalid pointer is undefined behavior</a>.  However, for heap or stack arrays, it's okay to store the address of one past the end of the array, which allows you to store \"end\" positions for use in loops.</p>\n<p>But is it undefined behavior to form a pointer range from a single stack variable, like:</p>\n<pre><code>char c = 'X';\nchar* begin = &amp;c;\nchar* end = begin + 1;\n\nfor (; begin != end; ++begin) { /* do something */ }\n</code></pre>\n<p>Although the above example is pretty useless, this might be useful in the event that some function expects a pointer range, and you have a case where you simply have a single value to pass it.</p>\n<p>Is this undefined behavior?</p>\n", "Tags": "<c++><c><pointers><undefined-behavior><language-lawyer>", "OwnerUserId": "469408", "AnswerCount": "6"}, "9114715": {"ParentId": "9114657", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>5.7-5 of ISO14882:2011(e) states:</p>\n<blockquote>\n<p id=\"so_9114657_9114715_0\">When an expression that has integral type is added to or subtracted\n  from a pointer, the result has the type of the pointer operand. If the\n  pointer operand points to an element of an array object, and the array\n  is large enough, the result points to an element offset from the\n  original element such that the difference of the subscripts of the\n  resulting and original array elements equals the integral expression.\n  In other words, if the expression P points to the i-th element of an\n  array object, the expressions (P)+N (equivalently, N+(P)) and (P)-N\n  (where N has the value n) point to, respectively, the i + n-th and i \u2212\n  n-th elements of the array object, provided they exist. Moreover, if\n  the expression P points to the last element of an array object, the\n  expression (P)+1 points one past the last element of the array object,\n  and if the expression Q points one past the last element of an array\n  object, the expression (Q)-1 points to the last element of the array\n  object. If both the pointer operand and the result point to elements\n  of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is\n  undefined.</p>\n</blockquote>\n<p>Unless I overlooked something there, the addition only applies to pointers pointing to the same array. For everything else, the last sentence applies: \"otherwise, the behaviour is undefined\"</p>\n<p><strong>edit:</strong>\nIndeed, when you add 5.7-4 it turns out that the operation you do is (virtually) on an array, thus the sentence does not apply:</p>\n<blockquote>\n<p id=\"so_9114657_9114715_1\">For the purposes of these operators, a pointer to a nonarray object\n  behaves the same as a pointer to the first element of an array of\n  length one with the type of the object as its element type.</p>\n</blockquote>\n", "OwnerUserId": "833362", "LastEditorUserId": "833362", "LastEditDate": "2012-02-02T15:21:24.213", "Id": "9114715", "Score": "2", "CreationDate": "2012-02-02T15:12:18.850", "LastActivityDate": "2012-02-02T15:21:24.213"}, "9114776": {"ParentId": "9114657", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>This is allowed, the behavior is defined and both <code>begin</code> and <code>end</code> are <em>safely-derived pointer values</em>.</p>\n<p>In the C++ standard section 5.7 (<code>[expr.add]</code>) paragraph 4:</p>\n<blockquote>\n<p id=\"so_9114657_9114776_0\"><strong>For the purposes of these operators, a pointer to a nonarray object behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type.</strong></p>\n</blockquote>\n<p>When using C a similar clause can be found in the the C99/N1256 standard section 6.5.6 paragraph 7.</p>\n<blockquote>\n<p id=\"so_9114657_9114776_1\"><strong>For the purposes of these operators, a pointer to an object that is not an element of an array behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type.</strong></p>\n</blockquote>\n<hr>\n<p>As an aside, in section 3.7.4.3 (<code>[basic.stc.dynamic.safety]</code>) \"Safely-derived pointers\" there is a footnote:</p>\n<blockquote>\n<p id=\"so_9114657_9114776_2\">This section does not impose restrictions on dereferencing pointers to memory not allocated by <code>::operator new</code>.  This maintains the ability of many C++  implementations to use binary libraries and components written in other languages.  In particular, this applies to C binaries, because dereferencing pointers to memory allocated by <code>malloc</code> is not restricted.</p>\n</blockquote>\n<p>This suggests that pointer arithmetic throughout the stack is implementation-defined behavior, not undefined behavior.</p>\n</hr>", "OwnerUserId": "103167", "LastEditorUserId": "583044", "LastEditDate": "2012-02-02T16:37:55.627", "Id": "9114776", "Score": "14", "CreationDate": "2012-02-02T15:16:57.913", "LastActivityDate": "2012-02-02T16:37:55.627"}, "9114929": {"ParentId": "9114657", "CommentCount": "3", "Body": "<p>You could define c as an array of size 1:</p>\n<p><code>char c[1] = { 'X' };</code></p>\n<p>Then the undefined behavior would become defined behavior. \nResulting code should be identical.   </p>\n", "OwnerUserId": "858150", "PostTypeId": "2", "Id": "9114929", "Score": "-3", "CreationDate": "2012-02-02T15:26:30.033", "LastActivityDate": "2012-02-02T15:26:30.033"}, "bq_ids": {"n4140": {"so_9114657_9114776_0": {"section_id": 6141, "quality": 0.9473684210526315, "length": 18}, "so_9114657_9114715_1": {"section_id": 6141, "quality": 0.9473684210526315, "length": 18}, "so_9114657_9114715_0": {"section_id": 6142, "quality": 0.9814814814814815, "length": 106}, "so_9114657_9114776_1": {"section_id": 6141, "quality": 0.85, "length": 17}, "so_9114657_9114776_2": {"section_id": 7185, "quality": 0.8484848484848485, "length": 28}}, "n3337": {"so_9114657_9114715_0": {"section_id": 5906, "quality": 0.9814814814814815, "length": 106}, "so_9114657_9114715_1": {"section_id": 5905, "quality": 0.9473684210526315, "length": 18}, "so_9114657_9114776_0": {"section_id": 5905, "quality": 0.9473684210526315, "length": 18}, "so_9114657_9114776_1": {"section_id": 5905, "quality": 0.85, "length": 17}, "so_9114657_9114776_2": {"section_id": 6929, "quality": 0.9393939393939394, "length": 31}}, "n4659": {"so_9114657_9114776_0": {"section_id": 7603, "quality": 0.5789473684210527, "length": 11}, "so_9114657_9114715_1": {"section_id": 7603, "quality": 0.5789473684210527, "length": 11}, "so_9114657_9114776_1": {"section_id": 7603, "quality": 0.55, "length": 11}, "so_9114657_9114776_2": {"section_id": 8693, "quality": 0.8484848484848485, "length": 28}}}, "9114685": {"ParentId": "9114657", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It is not Undefined Behavior as long as you don't dereference the <em>invalid</em> iterator.<br>\nYou are allowed to hold a pointer to memory beyond your allocation but not allowed to dereference it.</br></p>\n", "OwnerUserId": "452307", "LastEditorUserId": "85371", "LastEditDate": "2012-02-02T15:11:54.640", "Id": "9114685", "Score": "3", "CreationDate": "2012-02-02T15:09:52.010", "LastActivityDate": "2012-02-02T15:11:54.640"}});