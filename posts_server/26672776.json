post_cb({"26672776": {"ViewCount": "55", "Body": "<p>I'm writing a resource management class, called <code>Wraiiper</code>. End goal is to be able to write things like</p>\n<pre><code>Wraiiper wr(new ClassA(), destroyA); // cleanup with destroyA \nwr.push_back(new ClassB());          // cleanup with delete\n</code></pre>\n<p>so it's basically of dynamic size, accepts any type, and deletes with either <code>delete</code> or a custom deallocator. I guess it does the same job that a <code>std::vector&lt;boost:any&gt;</code> would do if I inserted unique pointers to the various elements. The code (<strong><a href=\"http://coliru.stacked-crooked.com/a/848eba39dd48181b\" rel=\"nofollow\">coliru link</a></strong>) follows</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\n\nnamespace dpol\n{ // destruction policies\n    template&lt;typename Func&gt;\n    struct Destruction\n    {\n        Func finalize; \n\n        Destruction(Func f) : finalize(f)\n        {\n        }\n        template&lt;typename T&gt;\n        void apply(T* data)\n        {\n            if (data) finalize(data); \n        }\n    };\n    template&lt;&gt;\n    struct Destruction&lt;void&gt;\n    {\n        template&lt;typename T&gt;\n        void apply(T* data)\n        {\n            delete data; \n        }\n    };\n} // destruction policies\n\nclass Wraiiper\n{\n    struct ResourceConcept\n    {\n        virtual ~ResourceConcept() {}\n        virtual void* get() = 0; \n    };    \n\n    template&lt;typename T, typename Func&gt;\n    struct ResourceModel : ResourceConcept, dpol::Destruction&lt;Func&gt;\n    {\n        T* data; \n\n        ResourceModel(T* data)\n            : dpol::Destruction&lt;Func&gt;()\n            , data(data)\n        { // a. One arg constructor\n        }\n        ResourceModel(T* data, Func f)\n            : dpol::Destruction&lt;Func&gt;(f)\n            , data(data)\n        { // b. Two args constructor\n        }\n        ~ResourceModel()\n        {\n            dpol::Destruction&lt;Func&gt;::apply(data); \n        }\n\n        void* get()\n        {\n            return data; \n        }\n    };\n\n    std::vector&lt;ResourceConcept*&gt; resource; \n\npublic:\n\n  template&lt;typename T, typename Func&gt;\n  Wraiiper(T* data, Func f)\n  {\n      resource.push_back(new ResourceModel&lt;T, Func&gt;(data, f)); \n  }\n  template&lt;typename T&gt;\n  Wraiiper(T* data)\n  {\n      resource.push_back(new ResourceModel&lt;T, void&gt;(data)); \n  }\n  ~Wraiiper()\n  {\n      while (!resource.empty())\n      {\n          delete resource.back(); \n          resource.pop_back(); \n      }\n  }\n\n  template&lt;typename T, typename Func&gt;\n  T* push_back(T* data, Func f)\n  {\n      resource.push_back(new ResourceModel&lt;T, Func&gt;(data, f)); \n      return get&lt;T*&gt;(resource.size()-1); \n  }\n  template&lt;typename T&gt;\n  T* push_back(T* data)\n  {\n      resource.push_back(new ResourceModel&lt;T, void&gt;(data)); \n      return get&lt;T*&gt;(resource.size()-1); \n  }\n\n  template&lt;typename T&gt;\n  T  get(std::size_t i = 0)\n  {\n      return (T)resource.at(0)-&gt;get(); \n  }\n};\n\nstruct A\n{\n    int val; \n    A(int x) : val(x) {}\n};\n\nvoid dela(A *arg) { delete arg; }\n\nint main()\n{\n    Wraiiper wr(new A(2), dela); // compiles fine\n    Wraiiper wr2(new double);    // error !\n\n    return 0;\n}\n</code></pre>\n<h2>Question</h2>\n<p>The following error bothers me </p>\n<blockquote>\n<p id=\"so_26672776_26672776_0\">main.cpp: In instantiation of 'struct Wraiiper::ResourceModel':</p>\n<p id=\"so_26672776_26672776_1\">main.cpp:79:7:   required from 'Wraiiper::Wraiiper(T*) [with T = double]'</p>\n<p id=\"so_26672776_26672776_2\">main.cpp:121:28:   required from here</p>\n<p id=\"so_26672776_26672776_3\">main.cpp:51:9: error: invalid parameter type 'void'</p>\n<pre><code>    ResourceModel(T* data, Func f)\n\n    ^\n</code></pre>\n<p id=\"so_26672776_26672776_4\">main.cpp:51:9: error: in declaration 'Wraiiper::ResourceModel::ResourceModel(T*, Func)'</p>\n</blockquote>\n<p>My argument is that the constructor (a) with one argument <code>ResourceModel(T* data)</code> should be selected when instantiating <code>Wraiiper::ResourceModel&lt;double, void&gt;</code> since <strong>I explicitly call it with one argument</strong></p>\n<p>What is happening here, why is there an error and how could I overcome it ? </p>\n<p>FWIW this also fails (the same error) in Visual Studio 2012</p>\n", "AcceptedAnswerId": "26672859", "Title": "Is this an error in gcc's overload resolution?", "CreationDate": "2014-10-31T10:44:33.390", "Id": "26672776", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-10-31T10:54:43.317", "Score": "0", "OwnerUserId": "2567683", "Tags": "<c++><templates>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26672776_26672859_1": {"length": 26, "quality": 0.896551724137931, "section_id": 233}, "so_26672776_26672776_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 300}}, "n3337": {"so_26672776_26672859_1": {"length": 26, "quality": 0.896551724137931, "section_id": 226}, "so_26672776_26672776_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 291}}, "n4659": {"so_26672776_26672859_1": {"length": 26, "quality": 0.896551724137931, "section_id": 243}, "so_26672776_26672776_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 307}}}, "26672859": {"Id": "26672859", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26672776_26672859_0\">My argument is that the constructor (a) with one argument ResourceModel(T* data) should be selected when instantiating Wraiiper::ResourceModel since I explicitly call it with one argument</p>\n</blockquote>\n<p>Calling the function is not the problem; instantiating <code>ResourceModel&lt;double, void&gt;</code> is. You may not be calling that problematic function but it still has to be semantically valid at the point of instantiation:</p>\n<blockquote>\n<p id=\"so_26672776_26672859_1\"><code>[C++11: 14.7.1/1]:</code> <em>[..]</em> <strong>The implicit instantiation of a class template specialization causes the implicit instantiation of the declarations</strong>, but not of the definitions or default arguments, <strong>of the class member functions</strong>, member classes, scoped member enumerations, static data members and member templates; <em>[..]</em></p>\n</blockquote>\n<p>\u2026 and as long as it tries to take a <code>double*</code> and a <code>void</code>, that criterion is not met.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/4fa5dbb736b2dfbe\" rel=\"nofollow\">Clang's diagnostic output makes this marginally clearer</a>:</p>\n<blockquote id=\"so_26672776_26672859_2\">\n<pre><code>clang++ -std=c++11 -O2 -pedantic -pthread main.cpp &amp;&amp; ./a.out\nmain.cpp:51:37: error: argument may not have 'void' type\n        ResourceModel(T* data, Func f)\n                                    ^\nmain.cpp:79:30: note: in instantiation of template class 'Wraiiper::ResourceModel&lt;double, void&gt;' requested here\n      resource.push_back(new ResourceModel&lt;T, void&gt;(data)); \n                             ^\nmain.cpp:121:14: note: in instantiation of function template specialization 'Wraiiper::Wraiiper&lt;double&gt;' requested here\n    Wraiiper wr2(new double);    // error !\n             ^\n1 error generated.\n</code></pre>\n</blockquote>\n<p>You <em>may</em> able to disable it for this specialisation with <code>std::enable_if</code>. Otherwise I guess you'll need to specialise <code>ResourceModel</code> for the <code>&lt;..., void&gt;</code> case. An alternative is to send a singular function into <code>ResourceModel</code> rather than none at all, though you'd still need to pick a passable type for it.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2014-10-31T10:54:43.317", "Score": "1", "CreationDate": "2014-10-31T10:49:27.420", "ParentId": "26672776", "CommentCount": "3", "OwnerUserId": "560648", "LastEditDate": "2014-10-31T10:54:43.317"}});