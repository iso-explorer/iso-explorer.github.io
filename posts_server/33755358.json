post_cb({"bq_ids": {"n4140": {"so_33755358_33755546_0": {"length": 56, "quality": 0.8888888888888888, "section_id": 5974}}, "n3337": {"so_33755358_33755546_0": {"length": 47, "quality": 0.746031746031746, "section_id": 5742}}, "n4659": {"so_33755358_33755546_0": {"length": 46, "quality": 0.7301587301587301, "section_id": 7473}}}, "33755546": {"Id": "33755546", "PostTypeId": "2", "Body": "<p>According to the draft standard <em>\u00a75.1.2/p15 Lambda expressions [expr.prim.lambda]</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_33755358_33755546_0\"><strong>An entity is captured by copy if it is implicitly captured and the capture-default is = or if it is explicitly captured with a capture\n  that is not of the form &amp; identifier or &amp; identifier initializer.</strong>\n  For each entity captured by copy, an unnamed non-static data member is\n  declared in the closure type. The declaration order of these members\n  is unspecified. <strong>The type of such a data member is the type of the\n  corresponding captured entity if the entity is not a reference to an\n  object, or the referenced type otherwise.</strong> [ Note: If the captured\n  entity is a reference to a function, the corresponding data member is\n  also a reference to a function. \u2014 end note ] A member of an anonymous\n  union shall not be captured by copy.</p>\n</blockquote>\n<p>Consequently, in:</p>\n<pre><code>void test_lambda(TestLambda&amp; obj) {\n    [=]() mutable {\n        obj.data.push_back(0x01);\n    }();\n}\n</code></pre>\n<p><code>obj</code> is captured by copy, and thus you get rightfully the described results. In other words this is the behaviour that the standard dictates for <code>[=]</code> capture default.</p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2015-11-17T12:48:22.310", "Score": "3", "CreationDate": "2015-11-17T11:16:32.567", "ParentId": "33755358", "CommentCount": "5", "OwnerUserId": "2352671", "LastEditDate": "2015-11-17T12:48:22.310"}, "33755358": {"ViewCount": "195", "Body": "<p>Consider this:</p>\n<pre><code>class TestLambda {\npublic:\n    std::vector&lt;char&gt; data;\n};\n\nvoid test_lambda(TestLambda&amp; obj) {\n    [=]() mutable {\n        obj.data.push_back(0x01);\n    }();\n}\n\nint main() {\n    TestLambda tst;\n    tst.data.push_back(0x99);\n    test_lambda(tst);\n\n    // tst.data is unchanged at this point\n\n    return 0;\n}\n</code></pre>\n<p>After calling <code>test_lambda</code> what I expected was to see the change in <code>tst.data</code>, but this is not the case. To see the changes, I had to create lambda passing again a reference of <code>obj</code>, ie. <code>[&amp;obj]()</code>.</p>\n<p>Why do we need this? I mean, again a reference?</p>\n<p><code>obj</code> is already a reference. Then, <code>lambda</code> is capturing <code>obj</code> by copying it. So, <code>obj</code> within the <code>lambda</code> itself is not a reference? Why?</p>\n<p>Could somebody explain me this? Thank you.</p>\n", "AcceptedAnswerId": "33755553", "Title": "why do we need to capture reference for a reference in lambda?", "CreationDate": "2015-11-17T11:06:42.610", "Id": "33755358", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-11-17T11:15:54.700", "LastEditorUserId": "3982001", "LastActivityDate": "2015-11-17T12:48:22.310", "Score": "4", "OwnerUserId": "1887691", "Tags": "<c++><c++11><lambda><pass-by-reference>", "AnswerCount": "3"}, "33755553": {"Id": "33755553", "PostTypeId": "2", "Body": "<p>When used in the right hand side of an assigment, a reference works just as a \"normal\" variable. Whenever you define a lambda capturing by value, the lambda owns a copy of the outer variables, as if the lambda started with these lines:</p>\n<pre><code>auto my_inner_variable = my_outer_reference;\nauto my_inner_other_variable = my_outer_other_variable;\n</code></pre>\n<p>If you want the reference to \"remain\" a reference, you have to capture it by reference, thus instructing the compiler to emit code like this:</p>\n<pre><code>auto&amp; my_inner_variable = my_outer_reference;\nauto&amp; my_inner_other_variable = my_outer_other_variable; // if we instructed to capture everything by reference\n</code></pre>\n", "LastActivityDate": "2015-11-17T11:16:59.473", "CommentCount": "0", "CreationDate": "2015-11-17T11:16:59.473", "ParentId": "33755358", "Score": "5", "OwnerUserId": "2339551"}, "33755607": {"Id": "33755607", "PostTypeId": "2", "Body": "<p>Your function <code>test_lambda</code> contains a nested lambda function. Inside <code>test_lambda</code>, the reference <code>obj</code> refers to <code>tst</code> in main. Then you call an anonymous lambda function that captures by value. Inside the lambda function <code>obj</code> is an copy of the <code>obj</code> that was inside test_lambda. Why not simply write:</p>\n<pre><code>void test_lambda(TestLambda&amp; obj) {\n   obj.data.push_back(0x01);\n}\n</code></pre>\n<p>What you are doing now is perhaps illustrated by</p>\n<pre><code>void test_lambda(TestLambda&amp; obj) {\n    [=]() mutable {\n        objCopy.data.push_back(0x01);\n    }();\n}\n</code></pre>\n<p>where <code>objCopy</code> was created by the value capturing lambda.</p>\n", "LastActivityDate": "2015-11-17T11:19:10.397", "CommentCount": "1", "CreationDate": "2015-11-17T11:19:10.397", "ParentId": "33755358", "Score": "0", "OwnerUserId": "1693829"}});