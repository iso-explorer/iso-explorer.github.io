post_cb({"4637914": {"ParentId": "4637774", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I am unsure if this is in the actual C/C++ standard, and I am inclined to say that it is up to the compiler (just to be on the safe side). However, I had a \"fun\" time figuring that out a few months ago, where I had to send dynamically generated C structs as byte arrays across a network as part of a protocol, to communicate with a chip. The alignment and size of all the structs had to be consistent with the structs in the code running on the chip, which was compiled with a variant of GCC for the MIPS architecture. I'll attempt to give the algorithm, and it <em>should</em> apply to all variants of gcc (and hopefully most other compilers).</p>\n<p>All base types, like <strong>char</strong>, <strong>short</strong> and <strong>int</strong> align to their size, and they <em>align to the next available position, regardless of the alignment of the parent</em>. And to answer the original question, yes the total size is a multiple of the alignment.</p>\n<pre><code>// size 8\nstruct {\n    char A; //byte 0\n    char B; //byte 1\n    int C; //byte 4\n};\n</code></pre>\n<p>Even though the alignment of the struct is 4 bytes, the chars are still packed as close as possible.</p>\n<p>The alignment of a struct is <em>equal to the largest alignment of its members</em>.</p>\n<p>Example:</p>\n<pre><code>//size 4, but alignment is 2!\nstruct foo {\n    char A; //byte 0\n    char B; //byte 1\n    short C; //byte 3\n}\n\n//size 6\nstruct bar {\n    char A;         //byte 0\n    struct foo B;   //byte 2\n}\n</code></pre>\n<p>This also applies to unions, and in a curious way. The size of a union can be larger than any of the sizes of its members, simply due to alignment:</p>\n<pre><code>//size 3, alignment 1\nstruct foo {\n    char A; //byte 0\n    char B; //byte 1\n    char C; //byte 2\n};\n\n//size 2, alignment 2\nstruct bar {\n    short A; //byte 0\n};\n\n//size 4! alignment 2\nunion foobar {\n    struct foo A;\n    struct bar B;\n}\n</code></pre>\n<p>Using these simple rules, you <em>should</em> be able to figure out the alignment/size of any horribly nested union/struct you come across. This is all from memory, so if I have missed a corner case that can't be decided from these rules please let me know!</p>\n", "OwnerUserId": "436025", "LastEditorUserId": "436025", "LastEditDate": "2011-01-09T06:53:27.260", "Id": "4637914", "Score": "2", "CreationDate": "2011-01-09T05:59:51.430", "LastActivityDate": "2011-01-09T06:53:27.260"}, "bq_ids": {"n4140": {"so_4637774_4638295_0": {"section_id": 6077, "quality": 0.875, "length": 14}, "so_4637774_4639568_1": {"section_id": 7240, "quality": 0.5925925925925926, "length": 16}, "so_4637774_4639568_2": {"section_id": 3228, "quality": 1.0, "length": 10}, "so_4637774_4637870_0": {"section_id": 6077, "quality": 0.7777777777777778, "length": 14}, "so_4637774_4638285_0": {"section_id": 3228, "quality": 1.0, "length": 10}, "so_4637774_4639568_0": {"section_id": 7189, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_4637774_4638295_0": {"section_id": 5845, "quality": 0.875, "length": 14}, "so_4637774_4639568_1": {"section_id": 6984, "quality": 0.5925925925925926, "length": 16}, "so_4637774_4639568_2": {"section_id": 3101, "quality": 1.0, "length": 10}, "so_4637774_4637870_0": {"section_id": 5845, "quality": 0.7777777777777778, "length": 14}, "so_4637774_4638285_0": {"section_id": 3101, "quality": 1.0, "length": 10}, "so_4637774_4639568_0": {"section_id": 6933, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_4637774_4638295_0": {"section_id": 7573, "quality": 0.875, "length": 14}, "so_4637774_4639568_1": {"section_id": 8749, "quality": 0.5555555555555556, "length": 15}, "so_4637774_4638285_0": {"section_id": 3985, "quality": 1.0, "length": 10}, "so_4637774_4637870_0": {"section_id": 7573, "quality": 0.7777777777777778, "length": 14}, "so_4637774_4639568_2": {"section_id": 3985, "quality": 1.0, "length": 10}, "so_4637774_4639568_0": {"section_id": 8697, "quality": 0.9166666666666666, "length": 11}}}, "4639568": {"ParentId": "4637774", "CommentCount": "0", "Body": "<p>C++ doesn't explicitly says so, but it is a consequence of two other requirements:</p>\n<p>First, <em>all</em> objects must be well-aligned.</p>\n<p>3.8/1 says</p>\n<blockquote>\n<p id=\"so_4637774_4639568_0\">The lifetime of an object of type <code>T</code> begins when [...] <strong>storage with the proper alignment</strong> and size for type <code>T</code> is obtained</p>\n</blockquote>\n<p>and 3.9/5: </p>\n<blockquote>\n<p id=\"so_4637774_4639568_1\">Object types have *alignnment requirements (3.9.1, 3.9.2). The <em>alignment</em> of a complete object type is an implementation-defined integer value representing a number of bytes; an object is allocated at an address that meets the alignment requirements of its object type.</p>\n</blockquote>\n<p>So every object must be aligned according to its alignment requirements.</p>\n<p>The other requirement is that objects in an array are allocated contigulously:</p>\n<p>8.3.4/1:</p>\n<blockquote>\n<p id=\"so_4637774_4639568_2\">An object of array type contains a contiguously allocated non-empty set of <code>N</code> subobjects of type <code>T</code>.</p>\n</blockquote>\n<p>For the objects in an array to be contiguously allocated, there can be no padding <em>between</em> them. But for every object in the array to be properly aligned, each individual object must be padded so that the byte immediately after the end of the object is also well aligned. In other words, the size of the object must be a multiple of its alignment.</p>\n", "OwnerUserId": "33213", "PostTypeId": "2", "Id": "4639568", "Score": "1", "CreationDate": "2011-01-09T14:05:12.593", "LastActivityDate": "2011-01-09T14:05:12.593"}, "4638152": {"ParentId": "4637774", "CommentCount": "0", "Body": "<p>Seems the C++03 standard didn't say (or I didn't find) whether the alignment padding bytes should be included in the object representation.  </p>\n<p>And the C99 standard says the \"sizeof\" a struct type or union type includes internal and trailing padding, but I'm not sure if all alignment padding is included in that \"trailing padding\".  </p>\n<p>Now back to your example. There is really no confusion. <code>sizeof(example) == 8</code> means the structure does take 8 bytes to represent itself, including the tailing 3 padding bytes. If the char in the second structure has an offset of 6, it will overwrite the space used by <code>m_Example</code>. The layout of a certain type is implementation-defined, and should be kept stable in the whole implementation.  </p>\n<p>Still, whether <code>p+1</code> equals <code>(T*)((char*)p + sizeof(T))</code> is unsure. And I'm hoping to find the answer.</p>\n", "OwnerUserId": "154939", "PostTypeId": "2", "Id": "4638152", "Score": "0", "CreationDate": "2011-01-09T07:27:38.603", "LastActivityDate": "2011-01-09T07:27:38.603"}, "4637870": {"ParentId": "4637774", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>So to split your question up into two:</p>\n<p><strong>1. Is it legal?</strong> </p>\n<blockquote>\n<p id=\"so_4637774_4637870_0\">[5.3.3.2] <em>When applied to a class, the result</em> [of the sizeof() operator] <em>is the number of bytes in an object of that class including any padding required for placing objects of that type in an array.</em></p>\n</blockquote>\n<p>So, no, it's not. </p>\n<p><strong>2. Well, why isn't it?</strong> </p>\n<p>Here, I cna only speculate.</p>\n<p><em>2.1. Pointer arithmetics get weirder</em><br>\nIf alignment would be \"between array elements\" but would not affect the size, zthigns would get needlessly complicated, e.g.</br></p>\n<pre><code>(char *)(X+1) != ((char *)X) + sizeof(X)\n</code></pre>\n<p>(I have a hunch that this is required implicitely by the standard even without above statement, but I can't put it to proof)</p>\n<p><strong>2.2 Simplicity</strong><br>\nIf alignment affects size, alignment and size can be decided by looking at a single type. Consider this:</br></p>\n<pre><code>struct A  {  int x; char y;  }\nstruct B  { A left, right;   }\n</code></pre>\n<p>With the current standard, I just need to know sizeof(A) to determine size and layout of B.<br>\nWith the alternate you suggest I need to know the internals of A. Similar to your <code>example2</code>: for a \"better packing\", sizeof(example) is not enough, you need to consider the internals of example. </br></p>\n", "OwnerUserId": "31317", "LastEditorUserId": "31317", "LastEditDate": "2011-01-09T08:35:40.700", "Id": "4637870", "Score": "1", "CreationDate": "2011-01-09T05:42:27.803", "LastActivityDate": "2011-01-09T08:35:40.700"}, "4637774": {"CommentCount": "2", "AcceptedAnswerId": "4637788", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-01-09T05:02:56.920", "LastActivityDate": "2011-01-09T14:05:12.593", "LastEditDate": "2017-05-23T12:02:47.340", "ViewCount": "3628", "FavoriteCount": "5", "Title": "Is the size of a struct required to be an exact multiple of the alignment of that struct?", "Id": "4637774", "Score": "16", "Body": "<p>Once again, I'm questioning a longstanding belief.</p>\n<p>Until today, I believed that the alignment of the following struct would normally be 4 and the size would normally be 5...</p>\n<pre><code>struct example\n{\n  int   m_Assume_32_Bits;\n  char  m_Assume_8_Bit_Bytes;\n};\n</code></pre>\n<p>Because of this assumption, I have data structure code that uses offsetof to determine the distance in bytes between two adjacent items in an array. Today, I spotted some old code that was using sizeof where it shouldn't, couldn't understand why I hadn't had bugs from it, coded up a unit test - and the test surprised me by passing.</p>\n<p>A bit of investigation showed that the sizeof the type I used for the test (similar to the struct above) was an exact multiple of the alignment - ie 8 bytes. It had padding after the final member. Here is an example of why I never expected this...</p>\n<pre><code>struct example2\n{\n  example m_Example;\n  char    m_Why_Cant_This_Be_At_Offset_6_Bytes;\n};\n</code></pre>\n<p>A bit of Googling showed examples that make it clear that this padding after the final member is allowed - for example <a href=\"http://en.wikipedia.org/wiki/Data_structure_alignment#Data_structure_padding\" rel=\"nofollow noreferrer\">http://en.wikipedia.org/wiki/Data_structure_alignment#Data_structure_padding</a> (the \"or at the end of the structure\" bit).</p>\n<p>This is a bit embarrassing, as I recently posted this comment - <a href=\"https://stackoverflow.com/questions/4587470/use-of-struct-padding/4587489#4587489\">Use of struct padding</a> (my first comment to that answer).</p>\n<p>What I can't seem to determine is whether this padding to an exact multiple of the alignment is guaranteed by the C++ standard, or whether it is just something that is permitted and that some (but maybe not all) compilers do.</p>\n<p>So - is the size of a struct required to be an exact multiple of the alignment of that struct according to the C++ standard?</p>\n<p>If the C standard makes different guarantees, I'm interested in that too, but the focus is on C++.</p>\n", "Tags": "<c++><struct><alignment><sizeof>", "OwnerUserId": "180247", "AnswerCount": "8"}, "4638295": {"ParentId": "4637774", "CommentCount": "2", "Body": "<p>5.3.3/2</p>\n<blockquote>\n<p id=\"so_4637774_4638295_0\">When applied to a class, the result [of sizeof] is the number of bytes in an object of that class, including any padding required for placing objects of that type in an array.</p>\n</blockquote>\n<p>So yes, object size is a multiple of its alignment.</p>\n", "OwnerUserId": "136208", "PostTypeId": "2", "Id": "4638295", "Score": "16", "CreationDate": "2011-01-09T08:16:29.647", "LastActivityDate": "2011-01-09T08:16:29.647"}, "4638285": {"ParentId": "4637774", "CommentCount": "3", "Body": "<p>The standard says (section <code>[dcl.array]</code>:</p>\n<blockquote>\n<p id=\"so_4637774_4638285_0\">An object of array type contains a contiguously allocated non-empty set of N subobjects of type T.</p>\n</blockquote>\n<p>Therefore there is no padding between array elements.</p>\n<p>Padding inside structures is not required by the standard, but the standard doesn't permit any other way of aligning array elements.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "4638285", "Score": "5", "CreationDate": "2011-01-09T08:13:12.957", "LastActivityDate": "2011-01-09T08:13:12.957"}, "4637810": {"ParentId": "4637774", "CommentCount": "6", "Body": "<p>The standard says very little about padding and alignment.  Very little is guaranteed.  About the only thing you can bet on is that the first element is at the beginning of the structure.  After that...alignment and padding can be anything.</p>\n", "OwnerUserId": "301883", "PostTypeId": "2", "Id": "4637810", "Score": "0", "CreationDate": "2011-01-09T05:15:20.437", "LastActivityDate": "2011-01-09T05:15:20.437"}, "4637788": {"ParentId": "4637774", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>One definition of <strike>alignment</strike> size:</p>\n<blockquote>\n<p id=\"so_4637774_4637788_0\">The <strike>alignment</strike> size of a struct is the offset from one element to the next element when you have an array of that struct.</p>\n</blockquote>\n<p>By its nature, if you have an array of a struct with two elements, then both need to have aligned members, so that means that yes, the size has to be a multiple of the alignment. (I'm not sure if any standard explicitly enforce this, but because the size and alignment of a struct don't depend on whether the struct is alone or inside an array, the same rules apply to both, so it can't really be any other way.)</p>\n", "OwnerUserId": "541686", "LastEditorUserId": "541686", "LastEditDate": "2011-01-09T05:39:24.507", "Id": "4637788", "Score": "9", "CreationDate": "2011-01-09T05:06:28.293", "LastActivityDate": "2011-01-09T05:39:24.507"}});