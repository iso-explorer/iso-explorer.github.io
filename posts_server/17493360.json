post_cb({"bq_ids": {"n4140": {"so_17493360_17497984_0": {"length": 19, "quality": 0.8260869565217391, "section_id": 5979}}, "n3337": {"so_17493360_17497984_0": {"length": 19, "quality": 0.8260869565217391, "section_id": 5747}}, "n4659": {"so_17493360_17497984_0": {"length": 14, "quality": 0.6086956521739131, "section_id": 7461}}}, "17494235": {"Id": "17494235", "PostTypeId": "2", "Body": "<p>I can reproduce a similar error with the following code:</p>\n<pre><code>struct A\n{\n    A() = default;\n    A(A&amp;&amp;) = default;\n    //A &amp; operator=(A&amp;&amp;) = default;\n    A(A const &amp; ) = delete;\n};\n\nint main()\n{\n    A a, b;\n    std::swap(a,b);\n}\n</code></pre>\n<p>Uncomment the move assignment operator and the error goes away. I'm guessing gcc doesn't allow move assignment of lambas (I'm using version 4.7.2). Change the lambda to an actual function or functor and you should be alright.</p>\n", "LastActivityDate": "2013-07-05T17:36:46.053", "Score": "2", "CreationDate": "2013-07-05T17:36:46.053", "ParentId": "17493360", "CommentCount": "4", "OwnerUserId": "1968586"}, "17497984": {"Id": "17497984", "PostTypeId": "2", "Body": "<p>This has nothing to do with <code>unique_ptr</code> or <code>tuple</code>, you can reduce the error to this:</p>\n<pre><code>int main()\n{\n  auto deleter = []() { };\n  auto del2 = deleter;\n  deleter = static_cast&lt;decltype(deleter)&gt;(del2);\n}\n</code></pre>\n<p>Which compiles with Clang but fails with G++, giving this error:</p>\n<pre><code>t.cc: In function \u2018int main()\u2019:\nt.cc:5:11: error: use of deleted function \u2018main()::&lt;lambda()&gt;&amp; main()::&lt;lambda()&gt;::operator=(const main()::&lt;lambda()&gt;&amp;)\u2019\n   deleter = static_cast&lt;decltype(deleter)&gt;(del2);\n           ^\nt.cc:3:19: note: a lambda closure type has a deleted copy assignment operator\n   auto deleter = []() { };\n                   ^\n</code></pre>\n<p>The last C++11 standard says in [expr.prim.lambda]/19:</p>\n<blockquote>\n<p id=\"so_17493360_17497984_0\">The closure type associated with a lambda-expression has a deleted (8.4.3) default constructor and a deleted copy assignment operator. It has an implicitly-declared copy constructor (12.8) and may have an implicitly-declared move constructor (12.8). </p>\n</blockquote>\n<p>So it is up to the compiler whether the type is move-assignable or not.</p>\n", "LastActivityDate": "2013-07-05T23:14:51.080", "Score": "5", "CreationDate": "2013-07-05T23:14:51.080", "ParentId": "17493360", "CommentCount": "0", "OwnerUserId": "981959"}, "17493360": {"ViewCount": "1898", "Body": "<p>Can we use a lambda as a deleter with a std::unique_ptr ? Actualy, I did it with clang++ and it was happy to do so.</p>\n<p>I'm using <code>std::swap</code> to swap to <code>std::unique_ptr&lt;ObjType, decltyp(deleter)&gt;;</code> where <code>auto deleter = [](struct addrinfo* ptr){if (ptr != nullptr) {freeaddrinfo(ptr);} };</code>. Clang's swap seems to do not need a copy assignment operator, but gcc's std::swap did, as you can see in those logs :</p>\n<pre><code>In file included from /usr/include/c++/4.8.1/memory:81:0,\n                 from /home/zenol/proj/src/PROJ/TCPClient.cpp:28:\n/usr/include/c++/4.8.1/bits/unique_ptr.h: In instantiation of \u2018std::unique_ptr&lt;_Tp, _Dp&gt;&amp; std::unique_ptr&lt;_Tp, _Dp&gt;::operator=(std::unique_ptr&lt;_Tp, _Dp&gt;&amp;&amp;) [with _Tp = addrinfo; _Dp = Proj::TCPClient::connect(const Proj::SocketAddress&amp;, int)::__lambda0]\u2019:\n/usr/include/c++/4.8.1/bits/move.h:176:11:   required from \u2018void std::swap(_Tp&amp;, _Tp&amp;) [with _Tp = std::unique_ptr&lt;addrinfo, Proj::TCPClient::connect(const Proj::SocketAddress&amp;, int)::__lambda0&gt;]\u2019\n/home/zenol/proj/src/Proj/SocketHelp.hpp:109:50:   required from \u2018void Proj::retrieve_addresses(std::string, int, addrinfo&amp;, addrinfo*&amp;, T&amp;, U) [with T = std::unique_ptr&lt;addrinfo, Proj::TCPClient::connect(const Proj::SocketAddress&amp;, int)::__lambda0&gt;; U = Proj::TCPClient::connect(const Proj::SocketAddress&amp;, int)::__lambda0; std::string = std::basic_string&lt;char&gt;]\u2019\n/home/zenol/proj/src/PROJ/TCPClient.cpp:65:49:   required from here\n/usr/include/c++/4.8.1/bits/unique_ptr.h:193:16: erreur: use of deleted function \u2018Proj::TCPClient::connect(const Proj::SocketAddress&amp;, int)::__lambda0&amp; Proj::TCPClient::connect(const Proj::SocketAddress&amp;, int)::__lambda0::operator=(const Proj::TCPClient::connect(const Proj::SocketAddress&amp;, int)::__lambda0&amp;)\u2019\n  get_deleter() = std::forward&lt;deleter_type&gt;(__u.get_deleter());\n                ^\n/home/zenol/proj/src/Proj/TCPClient.cpp:56:21: note: a lambda closure type has a deleted copy assignment operator\n     auto deleter = [](struct addrinfo* ptr)\n                     ^\n</code></pre>\n<p>What says the standard? Can I manage to wap those two std::unique_ptr ? Are they a workaround ? (Maybe encapsulating the lambda inside a std::function? ...)</p>\n<p>Edit :\nHere is a small example that should be more or less the same thing :</p>\n<pre><code>auto deleter = [](struct addrinfo* ptr)\n{if (ptr != nullptr) {freeaddrinfo(ptr);} };\n\nstd::unique_ptr&lt;struct addrinfo, decltype(deleter)&gt;\nresources_keeper(nullptr, deleter);\n\nint main()\n{\n    decltype(resources_keeper) plouf1(nullptr, deleter);\n    decltype(resources_keeper) plouf2(nullptr, deleter);\n\n    std::swap(plouf1, plouf2);\n    return 0;\n}\n</code></pre>\n<p>The error :</p>\n<pre><code>In file included from /usr/include/c++/4.8.1/bits/stl_pair.h:59:0,\n                 from /usr/include/c++/4.8.1/bits/stl_algobase.h:64,\n                 from /usr/include/c++/4.8.1/memory:62,\n                 from mini.cpp:1:\n/usr/include/c++/4.8.1/bits/move.h: In instantiation of \u2018void std::swap(_Tp&amp;, _Tp&amp;) [with _Tp = __lambda0]\u2019:\n/usr/include/c++/4.8.1/tuple:381:36:   required from \u2018void std::_Tuple_impl&lt;_Idx, _Head, _Tail ...&gt;::_M_swap(std::_Tuple_impl&lt;_Idx, _Head, _Tail ...&gt;&amp;) [with long unsigned int _Idx = 1ul; _Head = __lambda0; _Tail = {}]\u2019\n/usr/include/c++/4.8.1/tuple:382:35:   required from \u2018void std::_Tuple_impl&lt;_Idx, _Head, _Tail ...&gt;::_M_swap(std::_Tuple_impl&lt;_Idx, _Head, _Tail ...&gt;&amp;) [with long unsigned int _Idx = 0ul; _Head = addrinfo*; _Tail = {__lambda0}]\u2019\n/usr/include/c++/4.8.1/tuple:667:33:   required from \u2018void std::tuple&lt;_T1, _T2&gt;::swap(std::tuple&lt;_T1, _T2&gt;&amp;) [with _T1 = addrinfo*; _T2 = __lambda0]\u2019\n/usr/include/c++/4.8.1/tuple:1050:7:   required from \u2018void std::swap(std::tuple&lt;_Elements ...&gt;&amp;, std::tuple&lt;_Elements ...&gt;&amp;) [with _Elements = {addrinfo*, __lambda0}]\u2019\n/usr/include/c++/4.8.1/bits/unique_ptr.h:269:21:   required from \u2018void std::unique_ptr&lt;_Tp, _Dp&gt;::swap(std::unique_ptr&lt;_Tp, _Dp&gt;&amp;) [with _Tp = addrinfo; _Dp = __lambda0]\u2019\n/usr/include/c++/4.8.1/bits/unique_ptr.h:484:7:   required from \u2018void std::swap(std::unique_ptr&lt;_Tp, _Dp&gt;&amp;, std::unique_ptr&lt;_Tp, _Dp&gt;&amp;) [with _Tp = addrinfo; _Dp = __lambda0]\u2019\nmini.cpp:21:29:   required from here\n/usr/include/c++/4.8.1/bits/move.h:176:11: erreur: use of deleted function \u2018__lambda0&amp; __lambda0::operator=(const __lambda0&amp;)\u2019\n       __a = _GLIBCXX_MOVE(__b);\n           ^\nmini.cpp:9:17: note: a lambda closure type has a deleted copy assignment operator\n auto deleter = [](struct addrinfo* ptr)\n                 ^\nIn file included from /usr/include/c++/4.8.1/bits/stl_pair.h:59:0,\n                 from /usr/include/c++/4.8.1/bits/stl_algobase.h:64,\n                 from /usr/include/c++/4.8.1/memory:62,\n                 from mini.cpp:1:\n/usr/include/c++/4.8.1/bits/move.h:177:11: erreur: use of deleted function \u2018__lambda0&amp; __lambda0::operator=(const __lambda0&amp;)\u2019\n       __b = _GLIBCXX_MOVE(__tmp);\n           ^\n</code></pre>\n", "AcceptedAnswerId": "17497262", "Title": "swap std::unique_ptr with lambda as deleter -- GCC", "CreationDate": "2013-07-05T16:33:28.653", "Id": "17493360", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-08-20T22:18:58.980", "LastEditorUserId": "2535207", "LastActivityDate": "2013-08-20T22:18:58.980", "Score": "8", "OwnerUserId": "2535207", "Tags": "<c++><gcc><c++11><lambda><unique-ptr>", "AnswerCount": "4"}, "17497262": {"Id": "17497262", "PostTypeId": "2", "Body": "<p>To expand on <a href=\"https://stackoverflow.com/a/17497984/341970\">Jonathan Wakely's answer</a>:</p>\n<p><strong>When you swap to <code>unique_ptr</code>s, you also have to swap their deleters.</strong> The problem you are seeing boils down to this: <strong>clang can swap two lambdas of the same type, gcc cannot</strong> (and the standard allows both as Jonathan quotes it). Demonstration:</p>\n<pre><code>#include &lt;utility&gt;\n\nint main() {\n  auto f = [](){};\n  auto g(f);\n  std::swap(f, g);\n}\n</code></pre>\n<p>This code works with clang but fails to compile with gcc. (And that is OK.)</p>\n<p><strong>That is why it is happening.</strong></p>\n<hr>\n<p><strong>I suggest the following:</strong></p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;utility&gt;\n\nstruct addrinfo { };\n\nvoid freeaddrinfo(addrinfo* ) { }\n\nstruct deleter {\n  void operator()(struct addrinfo* ptr) {\n    if (ptr != nullptr)\n      freeaddrinfo(ptr);\n  }\n};\n\nusing resources_keeper = std::unique_ptr&lt;struct addrinfo, deleter&gt;;\n\nint main() {\n\n    resources_keeper plouf1(nullptr);\n    resources_keeper plouf2(nullptr);\n\n    std::swap(plouf1, plouf2);\n    return 0;\n}\n</code></pre>\n<p>Note that the code became cleaner and more readable as well.</p>\n<hr>\n<p>If you <em>absolutely have to</em> solve this with lambdas, then perhaps you could try something <strong>hackish</strong> like this: Swap only the pointers but not the deleters.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\ntemplate &lt;class T, class D&gt;\nvoid swap_pointers_but_not_deleters(unique_ptr&lt;T,D&gt;&amp; x, unique_ptr&lt;T,D&gt;&amp; y) noexcept {\n\n  T* x_ptr = x.release();\n\n  x.reset(y.release());\n\n  y.reset(x_ptr);\n}\n\nint main() {\n\n  auto deleter = [](int* p){ delete p; };\n\n  unique_ptr&lt;int,decltype(deleter)&gt; a(new int(1),deleter);\n\n  unique_ptr&lt;int,decltype(deleter)&gt; b(new int(2),deleter);\n\n  swap_pointers_but_not_deleters(a, b);\n\n  cout &lt;&lt; \"a = \" &lt;&lt; *a &lt;&lt; \", b = \" &lt;&lt; *b &lt;&lt; endl;\n}\n</code></pre>\n<p>Although this code seems to work, I really don't like it. I suggest the first solution that does not use lambdas.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-06T09:14:44.417", "Score": "3", "CreationDate": "2013-07-05T21:47:50.553", "ParentId": "17493360", "CommentCount": "4", "LastEditDate": "2017-05-23T12:14:09.357", "OwnerUserId": "341970"}, "17503434": {"Id": "17503434", "PostTypeId": "2", "Body": "<p>As it turns out, you can solve it with lambdas, as long as they can be converted to function pointers (lambdas capturing nothing).</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;utility&gt;\n\nstruct addrinfo { };\n\nvoid freeaddrinfo(addrinfo* ) { }\n\nauto deleter = [](struct addrinfo* ptr) {\n  if (ptr != nullptr)\n    freeaddrinfo(ptr);\n};\n\nusing resources_keeper = std::unique_ptr&lt;struct addrinfo, void(*)(struct addrinfo*)&gt;;\n\nint main() {\n\n    resources_keeper plouf1(nullptr,deleter);\n    resources_keeper plouf2(nullptr,deleter);\n\n    std::swap(plouf1, plouf2);\n    return 0;\n}\n</code></pre>\n<p>However, I still like my <a href=\"https://stackoverflow.com/a/17497262/341970\">other solution</a> with the struct better. It is likely to be the most efficient one (thanks to inlining), followed by the solution presented here. Passing a heavy-weight <code>std::function</code> looks like an overkill to me if the deleter implementation is really simple. Whether these performance considerations matter, it is the profiler's job to tell.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-06T13:27:09.130", "Score": "1", "CreationDate": "2013-07-06T13:27:09.130", "ParentId": "17493360", "CommentCount": "2", "LastEditDate": "2017-05-23T10:26:48.487", "OwnerUserId": "341970"}});