post_cb({"bq_ids": {"n4140": {"so_26440493_26440687_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 149}}, "n3337": {"so_26440493_26440687_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 143}}, "n4659": {"so_26440493_26440687_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 153}}}, "26440493": {"ViewCount": "84", "Body": "<p>I have a class template <code>name</code> to detect type names. It works for simple types such as <code>int</code>, <code>float</code>. However, for some template type like <code>std:pair</code>, the compiler (VS2013) reports error at the line when I try to define its static member variable.</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\ntemplate&lt;class T&gt; struct name{ static const char* value; };\n\ntemplate&lt;class T&gt; const char* name&lt;T&gt;::value = \"unknown\";\ntemplate&lt;&gt; const char* name&lt;int&gt;::value = \"int\";\ntemplate&lt;&gt; const char* name&lt;float&gt;::value = \"float\";\ntemplate&lt;class T1, class T2&gt; const char* name&lt;pair&lt;T1, T2&gt; &gt;::value = \"pair\"; //compilation error\n\nvoid main()\n{\n    assert(name&lt;int&gt;::value == \"int\");\n    assert(name&lt;float&gt;::value == \"float\");\n    assert(name&lt;double&gt;::value == \"unknown\");\n    assert((name&lt;pair&lt;int, char&gt; &gt;::value) == \"pair\");\n}\n</code></pre>\n<p>If I replace that line with the following four lines, the program works as expected.</p>\n<pre><code>template&lt;class T1, class T2&gt; struct name &lt; pair&lt;T1, T2&gt; &gt; {\n    static const char* value;\n};\ntemplate&lt;class T1, class T2&gt; const char* name&lt;pair&lt;T1, T2&gt; &gt;::value = \"pair\";\n</code></pre>\n<p>But this way looks ugly due to some duplicate code. Is there any way to walk around?</p>\n<p><strong>Updated</strong> to have fixed some apparent standard compliant issues.</p>\n", "AcceptedAnswerId": "26440687", "Title": "class template specialization with template", "CreationDate": "2014-10-18T13:55:05.783", "Id": "26440493", "CommentCount": "3", "LastEditDate": "2014-10-18T14:47:31.183", "PostTypeId": "1", "LastEditorUserId": "1444658", "LastActivityDate": "2014-10-18T14:47:31.183", "Score": "0", "OwnerUserId": "1444658", "Tags": "<c++><templates>", "AnswerCount": "2"}, "26440687": {"Id": "26440687", "PostTypeId": "2", "Body": "<p>First of all: Any explicit specialization has to be introduced by <code>template&lt;&gt;</code>. Try to stay standard-compliant.</p>\n<blockquote>\n<p id=\"so_26440493_26440687_0\">But this way looks ugly due to some duplicate code. Is there any way\n  to walk around?</p>\n</blockquote>\n<p>No. The parameter and argument list in a member definition that is not an explicit specialization must match the lists of the primary template or one of its partial specializations, and it corresponds to the member of the template whose lists it matches. [temp.class.spec.mfunc]:</p>\n<blockquote>\n<p id=\"so_26440493_26440687_1\">The template parameter list of a member of a class template partial\n  specialization shall match the template parameter list of the class\n  template partial specialization. The template argument list of a\n  member of a class template partial specialization shall match the\n  template argument list of the class template partial specialization.</p>\n</blockquote>\n<p>So you have to partially specialize the template. You could use a macro for that though:</p>\n<pre><code>#define REM_PAR(...) __VA_ARGS__\n#define PART_SPEC(string, params, ...) \\\n    template&lt;REM_PAR params&gt; struct name &lt;__VA_ARGS__ &gt; \\\n    {  static const char* value; }; \\\n    \\\n    template&lt;REM_PAR params&gt; const char* name&lt;__VA_ARGS__&gt;::value = string;\n\nPART_SPEC(\"pair\", (class T, class U), pair&lt;T,U&gt;)\n</code></pre>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-10-18T14:29:10.650", "Score": "2", "CreationDate": "2014-10-18T14:14:55.350", "ParentId": "26440493", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2014-10-18T14:29:10.650"}, "26440833": {"Id": "26440833", "PostTypeId": "2", "Body": "<p>First of all, for reference, this is how your pseudo code looks in C++:</p>\n<pre><code>#include &lt;cassert&gt;  // for assert\n#include &lt;cstring&gt;  // for std::strcmp\n#include &lt;utility&gt;  // for std::pair\n\ntemplate &lt;class T&gt; struct name\n{ static const char * const value; };\n\ntemplate &lt;class T&gt;\nconst char * const name&lt;T&gt;::value = \"unknown\";\n\ntemplate &lt;&gt;         // \"template &lt;&gt;\" for specialization\nconst char * const name&lt;int&gt;::value = \"int\";\n\ntemplate &lt;&gt;         // \"template &lt;&gt;\" for specialization\nconst char * const name&lt;float&gt;::value = \"float\";\n\n// template &lt;class T1, class T2&gt;                               // Error here (partial\n// const char * const name&lt;std::pair&lt;T1, T2&gt;&gt;::value = \"pair\"; // spec'n not allowed)\n\nint main()  // return type int\n{\n    assert(std::strcmp(name&lt;int&gt;::value, \"int\") == 0);      // strcmp!\n    assert(std::strcmp(name&lt;float&gt;::value,\"float\") == 0);\n    assert(std::strcmp(name&lt;double&gt;::value, \"unknown\") == 0);\n    assert(std::strcmp(name&lt;std::pair&lt;int, char&gt;&gt;::value,\"pair\") == 0);\n}\n</code></pre>\n<p>Now, here's a way you can make partial specialization work: Specialize the entire template.</p>\n<pre><code>template &lt;class T1, class T2&gt; struct name&lt;std::pair&lt;T1, T2&gt;&gt;\n{ static const char * const value; };\n\ntemplate &lt;class T1, class T2&gt;\nconst char * const name&lt;std::pair&lt;T1, T2&gt;&gt;::value = \"pair\";\n</code></pre>\n", "LastActivityDate": "2014-10-18T14:31:01.847", "CommentCount": "0", "CreationDate": "2014-10-18T14:31:01.847", "ParentId": "26440493", "Score": "2", "OwnerUserId": "596781"}});