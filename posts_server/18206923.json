post_cb({"bq_ids": {"n4140": {"so_18206923_18207975_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 7129}, "so_18206923_18206923_1": {"length": 6, "quality": 1.0, "section_id": 7129}, "so_18206923_18206923_5": {"length": 6, "quality": 1.0, "section_id": 215}, "so_18206923_18206923_6": {"length": 5, "quality": 1.0, "section_id": 215}, "so_18206923_18206923_7": {"length": 11, "quality": 0.9166666666666666, "section_id": 215}}, "n3337": {"so_18206923_18207975_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 6873}, "so_18206923_18206923_1": {"length": 6, "quality": 1.0, "section_id": 5724}, "so_18206923_18206923_5": {"length": 6, "quality": 1.0, "section_id": 209}, "so_18206923_18206923_6": {"length": 5, "quality": 1.0, "section_id": 209}, "so_18206923_18206923_7": {"length": 11, "quality": 0.9166666666666666, "section_id": 209}}, "n4659": {"so_18206923_18207975_0": {"length": 31, "quality": 0.8611111111111112, "section_id": 8630}, "so_18206923_18206923_1": {"length": 6, "quality": 1.0, "section_id": 8630}, "so_18206923_18206923_5": {"length": 6, "quality": 1.0, "section_id": 223}, "so_18206923_18206923_6": {"length": 5, "quality": 1.0, "section_id": 223}, "so_18206923_18206923_7": {"length": 11, "quality": 0.9166666666666666, "section_id": 223}}}, "18207975": {"Id": "18207975", "PostTypeId": "2", "Body": "<p>This is something that was changed in C++11.  The text you quote\nis from C++03; before C++11, this was ambiguous, because both\nlookups were used, and it was an error if they found different\nnames.  In C++11, the text is: </p>\n<blockquote>\n<p id=\"so_18206923_18207975_0\">If the id-expression in a class member access is a qualified-id\n  of the form class-name-or-namespace-name::...  the\n  class-name-or-namespace-name following the . or -&gt; operator is\n  first looked up in the class of the object expression and the\n  name, if found, is used. Otherwise it is looked up in the\n  context of the entire postfix-expression. [ Note: See 3.4.3,\n  which describes the lookup of a name before ::, which will only\n  find a type or namespace name. \u2014end note ]</p>\n</blockquote>\n<p>Basically, this privileges the lookup in class scope, and\ndoesn't do the other one if the name is found.</p>\n<p>As to why this only affected the template in the older versions\nof the standard: I think (it's hard to be sure about anything\nhere) that it is because in the case of the non-template, the\nlookup in the context of the entire postfix-expression also\nfinds the <code>typedef</code> in the base class, so both lookups resolve\nto the same entity.  In the case of the template, the lookup in\nthe context of the entire postfix-expression doesn't take into\naccount the dependent base class, and only finds the namespace\n<code>N</code>.  After instantiation of <code>C</code>, however, the lookup in the\nscope of the class finds the <code>typedef</code>.  Since the two lookups\nfind different entities, the name binding is ambiguous.</p>\n", "LastActivityDate": "2013-08-13T11:32:56.060", "CommentCount": "3", "CreationDate": "2013-08-13T11:32:56.060", "ParentId": "18206923", "Score": "5", "OwnerUserId": "649665"}, "18206923": {"ViewCount": "336", "Body": "<p>With the following code, clang 3.0 gives <code>error: lookup of 'N' in member access expression is ambiguous</code>, while clang 3.4 and gcc 4.8 both accept the code without error.</p>\n<pre><code>struct B\n{\n    struct M\n    {\n        void f()\n        {\n        }\n    };\n};\n\nnamespace N\n{\n    struct M\n    {\n        void f()\n        {\n        }\n    };\n}\n\ntemplate&lt;typename&gt;\nstruct A : N::M, B::M\n{\n    typedef B N;\n};\n\nstruct D : A&lt;int&gt;\n{\n    A&lt;int&gt; m;\n    void f()\n    {\n        m.N::M::f(); // found class-name 'A&lt;int&gt;::N' (unambiguous)\n    }\n};\n\ntemplate&lt;typename T&gt;\nstruct C : A&lt;T&gt;\n{\n    A&lt;T&gt; m;\n    void f()\n    {\n        m.N::M::f(); // found namespace-name 'N' (ambiguous?)\n    }\n};\n\ntemplate struct C&lt;int&gt;;\n</code></pre>\n<p>After consulting the standard it is not clear to me which behaviour is correct with regards to the expression in <code>C&lt;T&gt;::f()</code>.</p>\n<p>Because <code>N</code> is looked up both in the scope of the class of the object expression <code>n</code> (which is dependent) and in the context of the entire postfix expression (i.e. the scope of the function <code>C&lt;T&gt;::f()</code>), it is necessary to delay the lookup until the point of instantiation.</p>\n<p>At the point of instantiation, the lookup will be ambiguous if it finds both the namespace <code>N</code> and the typedef <code>A&lt;T&gt;::N</code>. The declaration of <code>N</code> is only visible if it is not hidden by the declaration of <code>A&lt;T&gt;::N</code>.</p>\n<p>The question is whether or not the namespace <code>N</code> should be considered to be hidden by the typedef <code>A&lt;T&gt;::N</code> when looking up <code>N</code> \"in the context of the entire postfix-expression\" and \"at the point of definition of the template\".</p>\n<p>Quoted from C++ Working Draft standard N3242=11-0012 (Feb 2011):</p>\n<blockquote>\n<p id=\"so_18206923_18206923_0\">3.4.5 Class member access [basic.lookup.classref]</p>\n<p id=\"so_18206923_18206923_1\">If the id-expression in a class member access is a qualified-id of the form</p>\n<p id=\"so_18206923_18206923_2\"><code>class-name-or-namespace-name::...</code></p>\n<p id=\"so_18206923_18206923_3\">the class-name-or-namespace-name following the <code>.</code> or <code>-&gt;</code> operator is looked up both <strong>in the context of the\n  entire postfix-expression</strong> and in the scope of the class of the object expression. If the name is found only in\n  the scope of the class of the object expression, the name shall refer to a class-name. If the name is found\n  only in the context of the entire postfix-expression, the name shall refer to a class-name or namespace-name. <strong>If the name is found in both contexts, the class-name-or-namespace-name shall refer to the same\n  entity.</strong></p>\n<p id=\"so_18206923_18206923_4\">14.6.4 Dependent name resolution [temp.dep.res]</p>\n<p id=\"so_18206923_18206923_5\">In resolving dependent names, names from the following sources are considered:</p>\n<p id=\"so_18206923_18206923_6\">\u2014 <strong>Declarations that are visible at the point of definition of the template.</strong></p>\n<p id=\"so_18206923_18206923_7\">\u2014 Declarations from namespaces associated with the types of the function arguments both from the\n  instantiation context (14.6.4.1) and from the definition context.</p>\n</blockquote>\n", "AcceptedAnswerId": "18207975", "Title": "Should a name found in a dependent base class hide a namespace name at the point of instantiation?", "CreationDate": "2013-08-13T10:40:02.680", "Id": "18206923", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-08-13T12:18:29.610", "LastEditorUserId": "1690864", "LastActivityDate": "2013-08-13T12:18:29.610", "Score": "10", "OwnerUserId": "1690864", "Tags": "<c++><templates><language-lawyer>", "AnswerCount": "1"}});