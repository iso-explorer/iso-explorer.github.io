post_cb({"bq_ids": {"n4140": {"so_24621954_24622052_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 3223}}, "n3337": {"so_24621954_24622052_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 3097}}, "n4659": {"so_24621954_24622052_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 3980}}}, "24622058": {"Id": "24622058", "PostTypeId": "2", "Body": "<p>The way universal references work is like this: if you pass in an rvalue, then <code>T</code> will be deduced as <code>int</code> (or some other non-reference type), because then <code>T&amp;&amp;</code> is an rvalue reference type. But if you pass in an lvalue, then <code>T</code> will be deduced as <code>int&amp;</code> (or some other lvalue reference type), because then <code>T&amp;&amp;</code> will be an lvalue reference type (since an lvalue reference and an rvalue reference \"collapse\" together into an lvalue reference).</p>\n<p>So in the case that you pass in an lvalue, you have a problem because you can't have <code>vector&lt;T&gt;</code> when <code>T</code> is a reference type.</p>\n<p>You should just pass by value,</p>\n<pre><code>template &lt;typename T&gt;\nstd::vector&lt;T&gt; attach_(std::vector&lt;T&gt; xs, T x) {\n  xs.push_back(std::move(x));\n  return xs;\n}\n</code></pre>\n<p>This might look less efficient, but it isn't. If you pass in an rvalue, it'll be moved once into <code>x</code>, and moved once again into the vector. If you pass in an lvalue, it'll be copied once into <code>x</code>, and them moved into the vector. It's the same as if you passed by reference: one copy for an lvalue, zero copies for an rvalue.</p>\n<p>For educational purposes, you could do this with your universal reference:</p>\n<pre><code>template &lt;typename T, typename E = typename std::remove_reference&lt;T&gt;::type&gt;\nstd::vector&lt;E&gt; attach_(std::vector&lt;E&gt; xs, T&amp;&amp; x) {\n  xs.push_back(std::forward&lt;T&gt;(x));\n  return xs;\n}\n</code></pre>\n<p>This ensures that when you pass an lvalue, the vector element type is the non-reference type. But it really is better to just pass by value.</p>\n", "LastActivityDate": "2014-07-08T00:40:45.720", "CommentCount": "2", "CreationDate": "2014-07-08T00:40:45.720", "ParentId": "24621954", "Score": "6", "OwnerUserId": "481267"}, "24621954": {"ViewCount": "2949", "Body": "<p>I am testing universal reference with the following code,</p>\n<pre><code>template &lt;typename T&gt;\nvector&lt;T&gt; attach_(vector&lt;T&gt; xs, T&amp;&amp; x) {\n  xs.push_back(std::forward&lt;T&gt;(x));\n  return xs;\n}\n\nint main() {\n   int k = 2;\n   attach_(std::move(vector&lt;int&gt;{1,2,3}),k);          //not OK\n   attach_(std::move(vector&lt;int&gt;{1,2,3}),(int&amp;)k);    //not OK\n   attach_(std::move(vector&lt;int&gt;{1,2,3}),(int)k);     //OK\n   attach_(std::move(vector&lt;int&gt;{1,2,3}),2);          //OK\n}\n</code></pre>\n<p>and got an error:</p>\n<pre><code>no matching function for call to 'attach_(std::remove_reference&lt;std::vector&lt;int&gt; &gt;::type, int&amp;)'\nattach_(std::move(vector&lt;int&gt;{1,2,3}),k);\nnote:   template argument deduction/substitution failed:\nnote:   deduced conflicting types for parameter 'T' ('int' and 'int&amp;')\n   attach_(std::move(vector&lt;int&gt;{1,2,3}),k);\n</code></pre>\n<p>SO has a question for a similar error <a href=\"https://stackoverflow.com/questions/21926678/error-message-deduced-conflicting-types-for-parameter-const-t\">Error message \"deduced conflicting types for parameter 'const T'\"</a> about const references. </p>\n<p>I also tested a few other cases, some with type conversions. Some work and others don't.</p>\n<p>I heard that universal references like <code>T&amp;&amp;</code> matches everything. Why does it fail here?</p>\n<p>A second question is, how to type <code>attach_</code> to make sure that move semantics work both for <code>xs</code> and <code>x</code> for the appropriate input? Ultimately, I'd like to have variant of the following:</p>\n<pre><code>for(int i = 0; i &lt; 100; i++)\n   xs = attach_(xs,values[i])\n</code></pre>\n<p>work without making unnecessary copies.</p>\n<p>(This is tested with gcc4.8.1, using g++ -std=c++11 test.cpp)</p>\n<p>Thanks</p>\n<p>-- EDIT ---</p>\n<p>Thanks everyone for the excellent answers.</p>\n<p>So I understand now that for this case, it's efficient just to use pass-by-value, and move the <code>T</code>. It take it that the vector xs is not copied unnecessarily in parameter-passing and returning back, if used in a loop, right?</p>\n<p>I asked a related question <a href=\"https://stackoverflow.com/questions/24543330/when-is-const-reference-better-than-pass-by-value-in-c11\">When is a const reference better than pass-by-value in C++11?</a>. There, I had this example where everyone said pass-by-vale is a bad idea:</p>\n<pre><code>int hd(vector&lt;int&gt; a) {\n   return a[0];\n}\n</code></pre>\n<p>Is it possible at all to use universal reference to handle both the <code>hd</code> case and the <code>attach_</code> case in this post to avoid unnecessary copies?</p>\n<p>Thanks again.</p>\n<p>--- EDIT2 ---</p>\n<p>So, I tested the versions in the answers plus a <code>const</code> reference version below. Optimization is not used to expose any potential issues. The <code>const</code> ref version is the worst as it forces copying. Everything else has the same speed if <code>std::move(a)</code> is used for the vector, except raw <code>push_call</code> calls are faster. I guess optimization can remove that difference. I guess the test (or maybe the int type) is not big enough to show the difference between <code>push_back(x)</code> and <code>push_back(std::move(x))</code></p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;chrono&gt;\nusing namespace std;\n\ntemplate &lt;class T&gt;\nvector&lt;T&gt; attach(vector&lt;T&gt; v, T x) {\n  v.push_back(x);\n  return v;\n}\n\ntemplate &lt;typename T&gt;\nvector&lt;T&gt; attach1(vector&lt;T&gt; xs, T x) {\n  xs.push_back(std::move(x));\n  return xs;\n}\n\ntemplate &lt;typename T, typename E = typename std::remove_reference&lt;T&gt;::type&gt;\nstd::vector&lt;E&gt; attach2(std::vector&lt;E&gt; xs, T&amp;&amp; x) {\n  xs.push_back(std::forward&lt;T&gt;(x));\n  return xs;\n}\n\ntemplate &lt;typename C, typename T&gt; C attach3(C&amp;&amp; xs, T&amp;&amp; x) {\n  xs.push_back(std::move&lt;T&gt;(x));\n  return std::forward&lt;C&gt;(xs);\n}\n\ntemplate &lt;class T&gt;\nvector&lt;T&gt; attach4(const vector&lt;T&gt;&amp; v, T x) {\n  vector&lt;T&gt; ret = v;\n  ret.push_back(x);\n  return std::move(ret);\n}\n\nusing namespace std::chrono;\nint main() {\n  int N = 100000;\n  vector&lt;int&gt; a;\n  auto time = high_resolution_clock::now();\n  for (int i = 0; i &lt; N; i++) {\n    //a.push_back(i);    //0s\n    //a = attach(a,i);    //15s\n    //a = attach(std::move(a),i);    //0.03s\n    //a = attach2(std::move(a),i);   //0.03s\n    a = attach3(std::move(a),i);   //0.03s\n    //a = attach4(std::move(a),i);   //14.9s\n  }\n  cout &lt;&lt; duration_cast&lt;duration&lt;double&gt;&gt;(high_resolution_clock::now() - time).count() &lt;&lt; endl;\n\n}\n</code></pre>\n", "AcceptedAnswerId": "24622058", "Title": "deduced conflicting types for parameter 'T' for universal reference", "CreationDate": "2014-07-08T00:24:39.890", "Id": "24621954", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:53:35.010", "LastEditorUserId": "-1", "LastActivityDate": "2014-07-08T03:02:59.613", "Score": "4", "OwnerUserId": "683218", "Tags": "<c++><c++11><type-deduction>", "AnswerCount": "3"}, "24622026": {"Id": "24622026", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24621954_24622026_0\">I heard that universal references like T&amp;&amp; matches everything. Why does it fail here?</p>\n</blockquote>\n<p>The reason universal references match everything is because the template argument deduction rules say that when <code>T &amp;&amp;</code> is paired with an lvalue of type <code>X</code>, T is deduced to be <code>X&amp;</code>, and then reference collapsing makes <code>X&amp; &amp;&amp;</code> become <code>X&amp;</code>.</p>\n<p>In <code>attach_(std::move(vector&lt;int&gt;{1,2,3}),k);</code>, the compiler deduces <code>T</code> as <code>int</code> from the first parameter (<code>vector&lt;T&gt;</code> &lt;-&gt; <code>vector&lt;int&gt;</code>), while from the second parameter T is deduced as <code>int &amp;</code> since <code>k</code> is an lvalue. Thus you get an error.</p>\n<blockquote>\n<p id=\"so_24621954_24622026_1\">A second question is, how to type <code>attach_</code> to make sure that move semantics work both for <code>xs</code> and <code>x</code> for the appropriate input?</p>\n</blockquote>\n<p>Simplest would be to simply pass it by value and move it into the vector:</p>\n<pre><code>template &lt;typename T&gt;\nvector&lt;T&gt; attach_(vector&lt;T&gt; xs, T x) {\n  xs.push_back(std::move(x));\n  return xs;\n}\n</code></pre>\n<p><code>x</code> will still be move-constructed if it's passed with <code>std::move</code>.</p>\n<hr>\n<p>Edit: If you are working with a large copy-only legacy type, then making two copies as in the above case isn't ideal. In that case you can do what @Deduplicator showed in his answer:</p>\n<pre><code>template &lt;typename T&gt;\nvector&lt;typename std::remove_reference&lt;T&gt;::type&gt;\nattach_(vector&lt;typename std::remove_reference&lt;T&gt;::type&gt; xs, T&amp;&amp; x) {\n  xs.push_back(std::forward&lt;T&gt;(x));\n  return xs;\n}\n</code></pre>\n<hr>\n<p>Edit 2:</p>\n<blockquote>\n<p id=\"so_24621954_24622026_2\">So I understand now that for this case, it's efficient just to use pass-by-value, and move the <code>T</code>. It take it that the vector <code>xs</code> is not copied unnecessarily in parameter-passing and returning back, if used in a loop, right?</p>\n</blockquote>\n<p>The general rule is \"pass by value if it's small or if you need to make a copy anyway, and by reference otherwise\". In <code>attach_</code>, you <em>need to</em> make a copy of <code>x</code> (by <code>push_back</code>ing it into the vector), so passing it by value and then moving it is fine. </p>\n<p>Whether you should pass the vector by value depends on your intended semantics. If <code>attach_(xs, x)</code> <em>should not</em> alter <code>xs</code>, then you would <em>need to</em> make a copy of the vector to return anyway, and thus you should pass it by value. However, when you do <code>xs = attach_(xs, x);</code>, you'll incur a copy. <code>xs = attach_(std::move(xs), x);</code> would not incur a copy, but does have some small additional overhead from move construction follwed by move assignment.</p>\n<p>If <code>attach_(xs, x)</code> <em>should</em> alter <code>xs</code>, then pass it by non-const reference. No overhead involved.</p>\n<blockquote>\n<p id=\"so_24621954_24622026_3\">Is it possible at all to use universal reference to handle both the <code>hd</code> case and the <code>attach_</code> case in this post to avoid unnecessary copies?</p>\n</blockquote>\n<p><code>hd</code> needs no universal reference. You are just indexing a vector so just pass it by const reference.</p>\n</hr></hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2014-07-08T01:49:03.377", "Score": "4", "CreationDate": "2014-07-08T00:35:56.740", "ParentId": "24621954", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2014-07-08T01:49:03.377"}, "24622052": {"Id": "24622052", "PostTypeId": "2", "Body": "<p>Universal reference semantics work according to this quote:</p>\n<blockquote>\n<h3>8.3.2 References \u00a76</h3>\n<p id=\"so_24621954_24622052_0\">If a typedef-name (7.1.3, 14.1) or a decltype-specifier (7.1.6.2) denotes a type TR that is a reference to a type T, an attempt to create the type \u201clvalue reference to cv TR\u201d creates the type \u201clvalue reference to T\u201d, while an attempt to create the type \u201crvalue reference to cv TR\u201d creates the type TR. [ Example:</p>\n<pre><code>int i;\ntypedef int&amp; LRI;\ntypedef int&amp;&amp; RRI;\nLRI&amp; r1 = i; // r1 has the type int&amp;\nconst LRI&amp; r2 = i; // r2 has the type int&amp;\nconst LRI&amp;&amp; r3 = i; // r3 has the type int&amp;\nRRI&amp; r4 = i; // r4 has the type int&amp;\nRRI&amp;&amp; r5 = 5; // r5 has the type int&amp;&amp;\ndecltype(r2)&amp; r6 = i; // r6 has the type int&amp;\ndecltype(r2)&amp;&amp; r7 = i; // r7 has the type int&amp;\n</code></pre>\n<p id=\"so_24621954_24622052_1\">\u2014end example ]</p>\n</blockquote>\n<p>Judicious use of <code>std::remove_reference</code> solves your error handily:</p>\n<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nvector&lt;typename std::remove_reference&lt;T&gt;::type&gt;\nattach_(vector&lt;typename std::remove_reference&lt;T&gt;::type&gt; xs, T&amp;&amp; x) {\n  xs.push_back(std::forward&lt;T&gt;(x));\n  return xs;\n}\n\nint main() {\n   int k = 2;\n   attach_(std::move(vector&lt;int&gt;{1,2,3}),k);          //now OK\n   attach_(std::move(vector&lt;int&gt;{1,2,3}),(int&amp;)k);    //now OK\n   attach_(std::move(vector&lt;int&gt;{1,2,3}),(int)k);     //OK\n   attach_(std::move(vector&lt;int&gt;{1,2,3}),2);          //OK\n}\n</code></pre>\n<p>Anyway, are you quite sure you want t pass the container by value?<br>\nAlso, why not give it its own template parameter to make the function more generic?</br></p>\n<pre><code>template &lt;typename T, typename C&gt; void attach_(C&amp; xs, T&amp;&amp; x) {\n    xs.push_back(std::forward&lt;T&gt;(x));\n}\n</code></pre>\n<p>Returning the container is no longer needed...</p>\n", "LastEditorUserId": "3204551", "LastActivityDate": "2014-07-08T01:37:49.203", "Score": "2", "CreationDate": "2014-07-08T00:39:49.603", "ParentId": "24621954", "CommentCount": "3", "OwnerUserId": "3204551", "LastEditDate": "2014-07-08T01:37:49.203"}});