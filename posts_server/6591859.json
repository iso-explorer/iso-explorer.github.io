post_cb({"22612047": {"ParentId": "6591859", "CommentCount": "1", "Body": "<p><a href=\"http://msdn.microsoft.com/en-us/magazine/cc301398.aspx\" rel=\"nofollow\">This msdn article explains it in great detali</a></p>\n<p>There it says : </p>\n<blockquote>\n<p id=\"so_6591859_22612047_0\">\"And the final answer is... as you'd expect. It happens in the constructor.\"</p>\n</blockquote>\n<p>so.. <br>\nA::A () : i(0), j(0) <br>\n{<br>\n  --&gt;&gt; here ! <br>\n  //...<br>\n //<br>\n}</br></br></br></br></br></br></p>\n<p>But be careful, let's say you have the class A, and a class A1 derived from A. </p>\n<ul>\n<li>If you create a new A object, the vptr will be set right at the beginning of the constructor of the A class</li>\n<li>But if you  were to create a new object A1:</li>\n</ul>\n<blockquote>\n<p id=\"so_6591859_22612047_1\">\"Here's the entire sequence of events when you construct an instance of class A1: </p>\n<ol>\n<li>A1::A1 calls A::A </li>\n<li>A::A sets vtable to A's vtable </li>\n<li>A::A executes and returns</li>\n<li>A1::A1 sets vtable to A1's vtable </li>\n<li>A1::A1 executes and returns \"</li>\n</ol>\n</blockquote>\n", "OwnerUserId": "3254083", "PostTypeId": "2", "Id": "22612047", "Score": "0", "CreationDate": "2014-03-24T14:20:14.800", "LastActivityDate": "2014-03-24T14:20:14.800"}, "6591905": {"ParentId": "6591859", "CommentCount": "0", "Body": "<p>it's initialized between the constructors of base and derived classes:</p>\n<pre><code>class Base { Base() { } virtual void f(); };\nclass Derived {\u00a0Derived(); virtual void f(); };\n</code></pre>\n<p>It happens when raw memory is converted to Base object.\nIt happens when Base object is converted to Derived object during construction of an object.\nSame obviously happens in reverse when destroying object. I.e. every time when type changes, the vtable\npointer is changed. (I'm sure someone comments that vtables don't need to exists according to the std..)</p>\n", "OwnerUserId": "813009", "PostTypeId": "2", "Id": "6591905", "Score": "2", "CreationDate": "2011-07-06T05:26:23.823", "LastActivityDate": "2011-07-06T05:26:23.823"}, "6591952": {"ParentId": "6591859", "CommentCount": "1", "Body": "<p>The machinery for virtual calls (usually a v-table, but doesn't need to be) is set up during the <em>ctor-initializer</em>, after construction of base subobjects and before construction of members.  Section <code>[class.base.init]</code> decrees:</p>\n<blockquote>\n<p id=\"so_6591859_6591952_0\">Member functions (including virtual member functions, 10.3) can be called for an object under construction. Similarly, an object under construction can be the operand of the <code>typeid</code> operator (5.2.8) or of a <code>dynamic_cast</code> (5.2.7). However, if these operations are performed in a <em>ctor-initializer</em> (or in a function called directly or indirectly from a <em>ctor-initializer</em>) before all the <em>mem-initializers</em> for base classes have completed, the result of the operation is undefined.</p>\n</blockquote>\n<p>Actually, during construction of the base subobjects, the virtual function machinery exists, but it is set up for the base class.  Section [<code>class.cdtor</code>] says:</p>\n<blockquote>\n<p id=\"so_6591859_6591952_1\">Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2). When a virtual function is called directly or indirectly from a constructor or from a destructor, including during the construction or destruction of the class\u2019s non-static data members, and the object to which the call applies is the object (call it <code>x</code>) under construction or destruction, the function called is the final overrider\n  in the constructor\u2019s or destructor\u2019s class and not one overriding it in a more-derived class.  If the virtual function call uses an explicit class member access (5.2.5) and the object expression refers to the complete object of <code>x</code> or one of that object\u2019s base class subobjects but not <code>x</code> or one of its base class subobjects, the behavior is undefined.</p>\n</blockquote>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "6591952", "Score": "14", "CreationDate": "2011-07-06T05:32:35.870", "LastActivityDate": "2011-07-06T05:32:35.870"}, "bq_ids": {"n4140": {"so_6591859_6591952_0": {"section_id": 441, "quality": 0.9285714285714286, "length": 39}, "so_6591859_6591952_1": {"section_id": 447, "quality": 0.9594594594594594, "length": 71}}, "n3337": {"so_6591859_6591952_0": {"section_id": 432, "quality": 0.9285714285714286, "length": 39}, "so_6591859_6591952_1": {"section_id": 438, "quality": 0.9594594594594594, "length": 71}}, "n4659": {"so_6591859_6591952_0": {"section_id": 461, "quality": 0.8809523809523809, "length": 37}, "so_6591859_6591952_1": {"section_id": 469, "quality": 0.9594594594594594, "length": 71}}}, "6591859": {"CommentCount": "0", "AcceptedAnswerId": "6591952", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-07-06T05:19:38.987", "LastActivityDate": "2014-03-24T14:20:14.800", "LastEditDate": "2017-05-23T10:30:35.090", "ViewCount": "2944", "FavoriteCount": "4", "Title": "When does the vptr (pointing to vtable) get initialized for a polymorphic class?", "Id": "6591859", "Score": "5", "Body": "<p>This is not about <a href=\"https://stackoverflow.com/questions/3849498/when-is-vtable-in-c-created\">\"When VTABLE is created?\"</a>. Rather, when the VPTR should be initialized? Is it at the beginning/end of the constructor or before/after the constructor?</p>\n<pre><code>A::A () : i(0), j(0)  --&gt;&gt; here ?\n{\n  --&gt;&gt; here ?\n  //...\n  --&gt;&gt; here ?\n}\n</code></pre>\n", "Tags": "<c++><virtual><vptr>", "OwnerUserId": "514235", "AnswerCount": "3"}});