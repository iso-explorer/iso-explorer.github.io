post_cb({"27931157": {"CommentCount": "7", "ViewCount": "332", "CreationDate": "2015-01-13T20:44:24.320", "LastActivityDate": "2015-01-13T21:16:10.833", "Title": "Why is static_cast on an expression acting distributively?", "AcceptedAnswerId": "27931385", "PostTypeId": "1", "Id": "27931157", "Score": "7", "Body": "<p>I need to take 2 unsigned 8-bit values and subtract them, then add this value to a 32-bit accumulator. The 8-bit subtraction may underflow, and that's ok (unsigned int underflow is defined behavior, so no problems there).</p>\n<p>I would expect that <code>static_cast&lt;uint32_t&gt;(foo - bar)</code> should do what I want (where <code>foo</code> and <code>bar</code> are both <code>uint8_t</code>). But it would appear that this casts them first and <em>then</em> performs a 32-bit subtraction, whereas I need it to underflow as an 8-bit variable. I know I could just mod 256, but I'm trying to figure out <em>why</em> it works this way.</p>\n<p>Example here: <a href=\"https://ideone.com/TwOmTO\" rel=\"noreferrer\">https://ideone.com/TwOmTO</a></p>\n<pre><code>uint8_t foo = 5;\nuint8_t bar = 250;\n\nuint8_t diff8bit = foo - bar;\nuint32_t diff1 = static_cast&lt;uint32_t&gt;(diff8bit);\n\nuint32_t diff2 = static_cast&lt;uint32_t&gt;(foo) - static_cast&lt;uint32_t&gt;(bar);\n\nuint32_t diff3 = static_cast&lt;uint32_t&gt;(foo - bar);\n\nprintf(\"diff1 = %u\\n\", diff1);\nprintf(\"diff2 = %u\\n\", diff2);\nprintf(\"diff3 = %u\\n\", diff3);\n</code></pre>\n<p>Output:</p>\n<pre><code>diff1 = 11\ndiff2 = 4294967051\ndiff3 = 4294967051\n</code></pre>\n<p>I would suspect <code>diff3</code> would have the same behavior as <code>diff1</code>, but it's actually the same as <code>diff2</code>.</p>\n<p>So why does this happen? As far as I can tell the compiler should be subtracting the two 8-bit values and then casting to 32-bit, but that's clearly not the case. Is this something to do with the specification of how <code>static_cast</code> behaves on an expression?</p>\n", "Tags": "<c++><casting><static-cast>", "OwnerUserId": "4450862", "AnswerCount": "2"}, "27931385": {"ParentId": "27931157", "CommentCount": "2", "Body": "<p>For most of the arithmetic operators (including <code>-</code>), the operands undergo the <em>usual arithmetic conversions</em>.  One of these conversions is that any value of type narrower than <code>int</code> is promoted to <code>int</code>.   (Standard reference: <code>[expr]/10</code>).</p>\n<p>So the expression <code>foo - bar</code> becomes <code>(int)foo - (int)bar</code> giving <code>(int)-245</code>.  Then you cast that to <code>uint32_t</code> which will give a large positive number.</p>\n<p>To get the result you are intending , cast to <code>uint8_t</code> instead of <code>uint32_t</code>. Alternatively, use the modulus operator <code>%</code> on the result of the cast to <code>uint32_t</code>.</p>\n<p>It is not possible to do a calculation directly in narrower precision than <code>int</code></p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "27931385", "Score": "8", "CreationDate": "2015-01-13T20:59:45.437", "LastActivityDate": "2015-01-13T20:59:45.437"}, "27931379": {"ParentId": "27931157", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The issue is not the <a href=\"http://en.cppreference.com/w/cpp/language/static_cast\" rel=\"nofollow noreferrer\">static_cast</a> but the subtraction, the operands of additive operators have the usual arithmetic conversions applied to them and in this case the integral promotions which results in both operands of the subtraction being promoted to <em>int</em>:</p>\n<pre><code>static_cast&lt;uint32_t&gt;(foo - bar);\n                      ^^^   ^^^\n</code></pre>\n<p>On the other hand:</p>\n<pre><code>static_cast&lt;uint8_t&gt;(foo - bar);\n</code></pre>\n<p>would produce desired result.</p>\n<p>from the draft C++ standard section <code>5.7</code> <em>[expr.add]</em> says:</p>\n<blockquote>\n<p id=\"so_27931157_27931379_0\">The additive operators + and - group left-to-right. The usual arithmetic conversions are performed for\n  operands of arithmetic or enumeration type.</p>\n</blockquote>\n<p>this results in the integral promotions, section <code>5</code> <em>[expr]</em> says:</p>\n<blockquote>\n<p id=\"so_27931157_27931379_1\">Otherwise, the integral promotions (4.5) shall be performed on both operands</p>\n</blockquote>\n<p>which results in both operands being converted to <em>int</em>, section <code>4.5</code> <em>[conv.prom]</em> says:</p>\n<blockquote>\n<p id=\"so_27931157_27931379_2\">A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer conversion\n  rank (4.13) is less than the rank of int can be converted to a prvalue of type int if int can represent all\n  the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned\n  int.</p>\n</blockquote>\n<p>and then the static_cast to <em>uint32_t</em> is applied which results in a conversion which is defined as follows in section <code>4.7</code> <em>[conv.integral]</em>:</p>\n<blockquote>\n<p id=\"so_27931157_27931379_3\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source\n  integer (modulo 2n where n is the number of bits used to represent the unsigned type). [</p>\n</blockquote>\n<p>The questions <a href=\"https://stackoverflow.com/q/24371868/1708801\">Why must a short be converted to an int before arithmetic operations in C and C++?</a> explains why types smaller than <em>int</em> are promoted for arithmetic operations.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:53:24.403", "Id": "27931379", "Score": "4", "CreationDate": "2015-01-13T20:59:27.837", "LastActivityDate": "2015-01-13T21:16:10.833"}, "bq_ids": {"n4140": {"so_27931157_27931379_3": {"section_id": 31, "quality": 1.0, "length": 18}, "so_27931157_27931379_2": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}, "so_27931157_27931379_0": {"section_id": 6138, "quality": 0.8571428571428571, "length": 12}, "so_27931157_27931379_1": {"section_id": 5943, "quality": 1.0, "length": 6}}, "n3337": {"so_27931157_27931379_3": {"section_id": 28, "quality": 1.0, "length": 18}, "so_27931157_27931379_2": {"section_id": 18, "quality": 0.9743589743589743, "length": 38}, "so_27931157_27931379_0": {"section_id": 5902, "quality": 0.8571428571428571, "length": 12}, "so_27931157_27931379_1": {"section_id": 5714, "quality": 1.0, "length": 6}}, "n4659": {"so_27931157_27931379_3": {"section_id": 31, "quality": 1.0, "length": 18}, "so_27931157_27931379_2": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}, "so_27931157_27931379_0": {"section_id": 7635, "quality": 0.8571428571428571, "length": 12}, "so_27931157_27931379_1": {"section_id": 7428, "quality": 1.0, "length": 6}}}});