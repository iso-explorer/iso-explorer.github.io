post_cb({"9018685": {"ParentId": "9018460", "CommentCount": "1", "Body": "<p>I don't know if what you write is legal, but there are some other ways of achieving what you want:</p>\n<pre><code>  template &lt;typename F&gt;\n  auto apply(F&amp; f) -&gt; decltype(f(*(MyClass*)0, (int)0)) {\n    return f(*this, _arg);\n  }\n</code></pre>\n<p>Or:</p>\n<pre><code>  template &lt;typename F&gt;\n  typename std::result_of&lt;F(MyClass,int)&gt;::type apply(F&amp; f) {\n    return f(*this, _arg);\n  }\n</code></pre>\n", "OwnerUserId": "6918", "PostTypeId": "2", "Id": "9018685", "Score": "1", "CreationDate": "2012-01-26T13:22:14.310", "LastActivityDate": "2012-01-26T13:22:14.310"}, "9018460": {"CommentCount": "4", "CreationDate": "2012-01-26T13:03:27.177", "PostTypeId": "1", "AcceptedAnswerId": "9018668", "LastEditorUserId": "-1", "LastActivityDate": "2012-01-27T19:35:21.253", "LastEditDate": "2017-05-23T12:31:05.750", "ViewCount": "1948", "FavoriteCount": "1", "Title": "Using this and attributes in member function trailing return types?", "Id": "9018460", "Score": "6", "Body": "<p>In this <a href=\"https://stackoverflow.com/questions/9017139/is-it-possible-to-base-the-template-specialization-on-the-presence-or-absence-of/9018068#9018068\">answer</a> I gave, it made sense to use <code>this</code> and the attribute of the class <code>_arg</code> in the trailing return type as part of the <code>decltype</code> expression. It's possible to do without, but inconvenient.</p>\n<p>Neither clang 3.0 (see below) nor <a href=\"http://ideone.com/qYJ4r\" rel=\"nofollow noreferrer\">gcc 4.5.2</a> accepted it though.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass MyClass {\npublic:\n  MyClass(int i): _arg(i) {}\n\n  template &lt;typename F&gt;\n  auto apply(F&amp; f) -&gt; decltype(f(_arg)) {\n    return f(_arg);\n  }\n\n  template &lt;typename F&gt;\n  auto apply(F&amp; f) -&gt; decltype(f(*this, _arg)) {\n    return f(*this, _arg);\n  }\n\nprivate:\n  int _arg;\n};\n\nstruct Id {\n  template &lt;typename V&gt;\n  V operator()(V v) const { return v; }\n};\n\nstruct ComplexId {\n  template &lt;typename C, typename V&gt;\n  V operator()(C const&amp;, V v) { return v + 1; }\n};\n\nint main() {\n  Id id; ComplexId complex;\n\n  MyClass c(0);\n\n  std::cout &lt;&lt; c.apply(id) &lt;&lt; \" \" &lt;&lt; c.apply(complex) &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>clang 3.0 says:</p>\n<pre><code>$ clang++ -std=c++11 -Weverything test.cpp\ntest.cpp:8:38: error: use of undeclared identifier '_arg'\n      auto apply(F&amp; f) -&gt; decltype(f(_arg)) {\n                                     ^\ntest.cpp:8:45: error: type name requires a specifier or qualifier\n      auto apply(F&amp; f) -&gt; decltype(f(_arg)) {\n                                            ^\ntest.cpp:8:45: error: C++ requires a type specifier for all declarations\n      auto apply(F&amp; f) -&gt; decltype(f(_arg)) {\n                          ~~~~~~~~          ^\ntest.cpp:8:7: error: 'auto' return without trailing return type\n      auto apply(F&amp; f) -&gt; decltype(f(_arg)) {\n      ^\ntest.cpp:13:39: error: invalid use of 'this' outside of a nonstatic member function\n      auto apply(F&amp; f) -&gt; decltype(f(*this, _arg)) {\n                                      ^\ntest.cpp:13:52: error: type name requires a specifier or qualifier\n      auto apply(F&amp; f) -&gt; decltype(f(*this, _arg)) {\n                                                   ^\ntest.cpp:13:52: error: C++ requires a type specifier for all declarations\n      auto apply(F&amp; f) -&gt; decltype(f(*this, _arg)) {\n                          ~~~~~~~~                 ^\ntest.cpp:13:7: error: 'auto' return without trailing return type\n      auto apply(F&amp; f) -&gt; decltype(f(*this, _arg)) {\n      ^\n8 errors generated.\n</code></pre>\n<p>Hum... not so great.</p>\n<p>However, the support of C++11 is hacky at best in most compilers and I could not find specific restrictions mentionned in the Standard (n3290).</p>\n<p>In the comments, Xeo suggested that it might have been a defect in the Standard...</p>\n<p><strong>So, is this allowed or not ?</strong></p>\n<p><em>Bonus: and do more recent versions of clang / gcc support this ?</em></p>\n", "Tags": "<c++><c++11><trailing-return-type>", "OwnerUserId": "147192", "AnswerCount": "3"}, "9025913": {"ParentId": "9018460", "CommentCount": "5", "Body": "<p>Your code <em>is</em> invalid C++11, because the class is not consider complete in the return type of a member function. You can only access members that have previously been declared. Like so</p>\n<pre><code>class MyClass {\nprivate:\n  int _arg;\n\npublic:\n  MyClass(int i): _arg(i) {}\n\n  template &lt;typename F&gt;\n  auto apply(F&amp; f) -&gt; decltype(f(_arg)) {\n    return f(_arg);\n  }\n\n  template &lt;typename F&gt;\n  auto apply(F&amp; f) -&gt; decltype(f(*this, _arg)) {\n    return f(*this, _arg);\n  }\n};\n</code></pre>\n<p>Modulo that, yes using <code>this</code> is valid in C++11 in a trailing return type.</p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "9025913", "Score": "5", "CreationDate": "2012-01-26T21:51:03.443", "LastActivityDate": "2012-01-26T21:51:03.443"}, "9018668": {"ParentId": "9018460", "LastEditDate": "2012-01-26T13:35:18.367", "CommentCount": "0", "CreationDate": "2012-01-26T13:20:54.197", "OwnerUserId": "500104", "LastEditorUserId": "500104", "PostTypeId": "2", "Id": "9018668", "Score": "9", "Body": "<p>I misremembered. It was <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#945\" rel=\"noreferrer\">a defect at some point</a>, but was eventually <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1207\" rel=\"noreferrer\">resolved and voted into the FDIS</a>.</p>\n<p><code>\u00a75.1.1 [expr.prim.general]</code></p>\n<blockquote>\n<p id=\"so_9018460_9018668_0\">If a declaration declares a member function or member function template of a class <code>X</code>, the expression <code>this</code> is a prvalue of type \u201cpointer to <em>cv-qualifier-seq</em> <code>X</code>\u201d between the optional <em>cv-qualifer-seq</em> and the end of the <em>function-definition</em>, <em>member-declarator</em>, or <em>declarator</em>.</p>\n</blockquote>\n<p>As such, Clang and GCC just don't implement it correctly yet.</p>\n<pre><code>struct X{\n  // 'this' exists between the | markers\n  void f() const volatile | {\n  } |\n  auto g() const volatile | -&gt; void {\n  } |\n};\n</code></pre>\n", "LastActivityDate": "2012-01-26T13:35:18.367"}, "bq_ids": {"n4140": {"so_9018460_9018668_0": {"section_id": 5949, "quality": 1.0, "length": 20}}, "n3337": {"so_9018460_9018668_0": {"section_id": 5719, "quality": 1.0, "length": 20}}, "n4659": {"so_9018460_9018668_0": {"section_id": 7435, "quality": 0.95, "length": 19}}}});