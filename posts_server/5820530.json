post_cb({"5820770": {"Id": "5820770", "PostTypeId": "2", "Body": "<p>Using memcpy with anything other than POD structures/objects (\"plain old data\"--things with no non-default constructors or destructors, and with virtual methods) is a recipe for disaster.  If you fix your program so that you're using memcpy to copy a POD structure which contains an \"ordinary\" pointer to a class item, any pointers copied as part of that structure must be handled the same as pointers copied via other means.  Exactly one copy (or the original) of any such pointer must be \"deleted\"--no more and no less.  If you copy the pointer and abandon the original without calling \"delete\" on it, you should then call \"delete\" on exactly one copy.</p>\n<p>In general, one should avoid using memcpy in C++; in C, structures never had any \"hidden\" information which could be left in an inconsistent state by memcpy, but in C++ they often do (with the exception of POD structures).  Although C++ is designed to be mostly compatible with C, the fact that something is legal in C does not mean that it is proper in C++.</p>\n", "LastActivityDate": "2011-04-28T15:07:10.693", "CommentCount": "0", "CreationDate": "2011-04-28T15:07:10.693", "ParentId": "5820530", "Score": "1", "OwnerUserId": "363751"}, "5820653": {"Id": "5820653", "PostTypeId": "2", "Body": "<p>It's valid, as in it will compile.  But it is stricken with errors.  You never allocated any memory, so you'd need to do that first.  But there is absolutely no reason to use memcpy, and in most cases, it does the wrong thing.  Just do this:</p>\n<pre><code>Foo(const Foo&amp; rhs)\n    :a(rhs.a),\n     pb(new SomeClass(*rhs.pb))\n{    \n}\n</code></pre>\n<p>Or better yet, use a smart pointer, and you don't have to worry about deleting.  Or better yet, don't use a pointer at all if you retain sole ownership of the object.</p>\n", "LastActivityDate": "2011-04-28T14:58:18.013", "CommentCount": "1", "CreationDate": "2011-04-28T14:58:18.013", "ParentId": "5820530", "Score": "1", "OwnerUserId": "440119"}, "5820633": {"Id": "5820633", "PostTypeId": "2", "Body": "<p>You haven't actually allocated anything for <code>pb</code>. If you allocate it with <code>new</code>, then using <code>delete</code> in the destructor is perfectly valid.</p>\n<p>But why oh why are you doing a <code>memcpy</code>? You should be using the copy constructor of the class and letting it copy itself in the appropriate fashion. The <em>only</em> time a memcpy would be remotely acceptable is when the class is a simple struct of POD types.</p>\n", "LastActivityDate": "2011-04-28T14:56:58.693", "CommentCount": "9", "CreationDate": "2011-04-28T14:56:58.693", "ParentId": "5820530", "Score": "3", "OwnerUserId": "5987"}, "5820752": {"Id": "5820752", "PostTypeId": "2", "Body": "<p>You haven't allocated memory for that pointer using <code>new</code>, so you absolutely shouldn't be using <code>delete</code> on it. <code>memcpy</code> isn't allocating any memory for you.</p>\n<p>Specifically, the only pointers you should be invoking <code>delete</code> on are pointers that have previously been returned by <code>new</code>, or a null pointer. To use <code>delete</code> on any other pointer is undefined behaviour, according to the C++03 standard, 3.7.3.2/3-4.</p>\n<blockquote>\n<p id=\"so_5820530_5820752_0\">The value of the first argument\n  supplied to one of the deallocation\n  functions provided in the standard\n  library may be a null pointer value;\n  if so, the call to the deallocation\n  function has no effect. <strong>Otherwise, the\n  value supplied to operator\n  delete(void*) in the standard library\n  shall be one of the values returned by\n  a previous invocation of either\n  operator new(size_t)</strong> or operator\n  new(size_t, const std::nothrow_t&amp;)</p>\n<p id=\"so_5820530_5820752_1\">...[snip]...</p>\n<p id=\"so_5820530_5820752_2\">The effect of using an invalid pointer\n  value (including passing it to a\n  deallocation function) is\n  undefined.)</p>\n</blockquote>\n", "LastEditorUserId": "27615", "LastActivityDate": "2011-04-28T15:11:38.053", "Score": "0", "CreationDate": "2011-04-28T15:05:46.023", "ParentId": "5820530", "CommentCount": "0", "OwnerUserId": "27615", "LastEditDate": "2011-04-28T15:11:38.053"}, "bq_ids": {"n4140": {"so_5820530_5820752_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 7187}, "so_5820530_5820752_0": {"length": 28, "quality": 0.7777777777777778, "section_id": 7182}}, "n3337": {"so_5820530_5820752_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 6927}, "so_5820530_5820752_0": {"length": 28, "quality": 0.7777777777777778, "section_id": 6926}}, "n4659": {"so_5820530_5820752_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 8695}}}, "5820672": {"Id": "5820672", "PostTypeId": "2", "Body": "<p>This code snippet is wrong because you can't call <code>delete</code> without calling to <code>new</code> for allocation of memory. </p>\n<p>Also your <code>memcpy</code> call can cause segmentation fault in most cases, because you are copying to unintialized pointer. You should allocate memort for <code>SomeClass</code> pointer before calling to <code>memcpy</code>.</p>\n", "LastActivityDate": "2011-04-28T15:00:16.863", "CommentCount": "0", "CreationDate": "2011-04-28T15:00:16.863", "ParentId": "5820530", "Score": "1", "OwnerUserId": "710964"}, "5820572": {"Id": "5820572", "PostTypeId": "2", "Body": "<p>You can't copy classes using <code>memcpy</code>. And <code>memcpy</code> is just copying memory, not allocating anything.</p>\n", "LastActivityDate": "2011-04-28T14:52:40.097", "CommentCount": "1", "CreationDate": "2011-04-28T14:52:40.097", "ParentId": "5820530", "Score": "3", "OwnerUserId": "211659"}, "5820530": {"ViewCount": "2107", "Body": "<p>Is the following snippet of code valid?</p>\n<pre><code>class Foo\n{\npublic:\n    int a;\n    SomeClass* pb;\n\n    Foo() {...}\n    Foo(const Foo&amp; rhs)\n    {\n         this-&gt;a = rhs.a;\n         memcpy(this-&gt;pb, rhs.pb, sizeof(SomeClass));\n    }\n    ~Request()\n    {\n        delete this-&gt;pb; // Suppose pb is a result of copy constructor,\n                         // Is this valid or is there a better way?\n    }\n};\n</code></pre>\n", "AcceptedAnswerId": "5820633", "Title": "Can I delete class pointer copied using memcpy()?", "CreationDate": "2011-04-28T14:50:22.233", "Id": "5820530", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2011-04-28T15:11:38.053", "Score": "3", "OwnerUserId": "398621", "Tags": "<c++><memcpy>", "AnswerCount": "6"}});