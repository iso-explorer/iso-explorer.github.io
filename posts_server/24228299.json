post_cb({"24228299": {"CommentCount": "0", "ViewCount": "132", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2014-06-15T09:36:01.293", "LastActivityDate": "2014-06-15T12:05:54.057", "LastEditDate": "2014-06-15T10:06:42.803", "AcceptedAnswerId": "24229413", "OwnerDisplayName": "user2953119", "Title": "Unqualified name lookup finds inline namespace member", "Id": "24228299", "Score": "5", "Body": "<p>I've written the following code:</p>\n<pre><code>   #include &lt;iostream&gt;\n\n    inline namespace M\n    {\n        int j=42;\n    }\n\n    int main(){ std::cout &lt;&lt; j &lt;&lt; \"\\n\"; } //j is unqualified name here. \n                 //Hence, unqualified name lookup rules will be applied.\n                 //This implies that member of inline namespace shall not be considered. \n                 //But it is not true\n</code></pre>\n<p>And it works fine. But I'm expected that the that program is ill-formed. It is because the Standard said (N3797, sec. 7.3.1/7):</p>\n<blockquote>\n<p id=\"so_24228299_24228299_0\">Finally, looking up a name in the enclosing namespace <strong>via explicit\n  qualification</strong> (3.4.3.2) will include members of the inline namespace\n  brought in by the using-directive even if there are declarations of\n  that name in the enclosing namespace.</p>\n</blockquote>\n<p>Also the section 3.4.1/6 does not said anything about involving of inline namespace in the unqualified name lookup:</p>\n<blockquote>\n<p id=\"so_24228299_24228299_1\">A name used in the definition of a function following the function\u2019s\n  declarator-id 28 that is a member of namespace N (where, only for the\n  purpose of exposition, N could represent the global scope) shall be\n  declared before its use in the block in which it is used or in one of\n  its enclosing blocks (6.3) or, shall be declared before its use in\n  namespace N or, if N is a nested namespace, shall be declared before\n  its use in one of N\u2019s enclosing namespaces.</p>\n</blockquote>\n<p>It is a <code>g++</code> bug or I understood that rules incorrectly?</p>\n", "Tags": "<c++><c++11><namespaces><inline><language-lawyer>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24228299_24228299_1": {"section_id": 7092, "quality": 1.0, "length": 38}, "so_24228299_24229413_1": {"section_id": 5480, "quality": 0.9047619047619048, "length": 38}, "so_24228299_24228299_0": {"section_id": 5480, "quality": 0.9545454545454546, "length": 21}, "so_24228299_24229413_2": {"section_id": 5480, "quality": 0.9047619047619048, "length": 38}}, "n3337": {"so_24228299_24228299_1": {"section_id": 6836, "quality": 1.0, "length": 38}, "so_24228299_24229413_1": {"section_id": 5266, "quality": 0.9047619047619048, "length": 38}, "so_24228299_24228299_0": {"section_id": 5266, "quality": 0.9545454545454546, "length": 21}, "so_24228299_24229413_2": {"section_id": 5266, "quality": 0.9047619047619048, "length": 38}}, "n4659": {"so_24228299_24228299_1": {"section_id": 8593, "quality": 0.7105263157894737, "length": 27}, "so_24228299_24229413_1": {"section_id": 6914, "quality": 0.9047619047619048, "length": 38}, "so_24228299_24228299_0": {"section_id": 6914, "quality": 0.9545454545454546, "length": 21}, "so_24228299_24229413_2": {"section_id": 6914, "quality": 0.9047619047619048, "length": 38}}}, "24229413": {"ParentId": "24228299", "CommentCount": "2", "Body": "<h3>There's no bug..</h3>\n<p>No, it's not a bug in neither <code>g++</code> (or <code>clang++</code>) which has the behavior described, the compiler is supposed to find <code>j</code>.</p>\n<pre><code>inline namespace N {\n  int j;\n}\n\nint main () {\n  int a = j; // legal, `j` == `N::j`\n}\n</code></pre>\n<hr>\n<h3>What does the Standard say?</h3>\n<p>You are missing a very important section of the standard, namely <em>7.3.1\u00a78</em>, where it states that the enclosing namespace of an inline namespace <em>implicitly</em> has a <em>using directive</em> that refers to the inline namespace.</p>\n<blockquote>\n<p id=\"so_24228299_24229413_0\"><code>[7.3.1]p8</code> <strong>namespace definition</strong> <code>[namespace.def]</code></p>\n<blockquote>\n<p id=\"so_24228299_24229413_2\">Members of an inline namespace can be used in most respects as thought they were members of the enclosing namespace. Specifically, the inline namespace and its enclosing namespace are both added to the set of associated namespaces used in argument-dependent lookup (3.4.2) whenever one of them is, and <strong>a <em>using-directive</em> (7.3.4) that names the inline namespace is implicitly inserted into the enclosing namespace</strong> as for an unnamed namespace (7.3.1.1).</p>\n</blockquote>\n</blockquote>\n<hr>\n<h3>Elaboration</h3>\n<p>This means that our previous example is semantically equivalent to the below, where we have introduced a <em>using-directive</em> to bring the names from our nested namespace into the global namespace:</p>\n<pre><code>inline namespace N {\n  int j;\n}\n\nusing namespace N; // the implicit using-directive    \n\nint main () {\n  int a = j; // legal\n}\n</code></pre>\n</hr></hr>", "OwnerUserId": "1090079", "PostTypeId": "2", "Id": "24229413", "Score": "3", "CreationDate": "2014-06-15T12:05:54.057", "LastActivityDate": "2014-06-15T12:05:54.057"}});