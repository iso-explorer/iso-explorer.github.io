post_cb({"23149343": {"CommentCount": "10", "AcceptedAnswerId": "23149421", "PostTypeId": "1", "LastEditorUserId": "1919155", "CreationDate": "2014-04-18T07:19:31.577", "LastActivityDate": "2014-04-18T08:48:20.287", "LastEditDate": "2014-04-18T08:48:20.287", "ViewCount": "715", "FavoriteCount": "4", "Title": "Why aren't pointers to member functions just memory address like data pointers", "Id": "23149343", "Score": "15", "Body": "<p>I realized from <a href=\"http://www.parashift.com/c++-faq-lite/cant-cvt-memfnptr-to-voidptr.html\">this</a> FAQ entry that one cannot convert a pointer to member function to/from <code>void*</code>. The reason being pointers to members are not memory addresses exactly like pointers to data! Why so? Please help me get clarified. And this isn't necessarily with member functions but any normal C functions as well, isn't?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "2606938", "AnswerCount": "2"}, "23149518": {"ParentId": "23149343", "PostTypeId": "2", "CommentCount": "1", "Body": "<h3>In the C++ standard</h3>\n<p>As the <a href=\"http://www.parashift.com/c++-faq-lite/cant-cvt-fnptr-to-voidptr.html\" rel=\"nofollow\">next FAQ</a> says:</p>\n<blockquote>\n<p id=\"so_23149343_23149518_0\">The language does not require functions and data to be in the same address space, so, by way of example and not limitation, on architectures that have them in different address spaces, the two different pointer types will not be comparable.</p>\n</blockquote>\n<p>In \u00a75.2.10/8 (of N3936 specifically) the standard specifies that this is indeed <em>implementation defined</em>:</p>\n<blockquote>\n<p id=\"so_23149343_23149518_1\">Converting a function pointer to an object pointer type or vice versa is conditionally-supported. The meaning of such a conversion is implementation-defined, except that if an implementation supports conversions in both directions, converting a prvalue of one type to the other type and back, possibly with different cv- qualification, shall yield the original pointer value.</p>\n</blockquote>\n<p>Here the behavior is well specified.</p>\n<h3>In the C standard</h3>\n<p>The C standard doesn't appear to contemplate the conversion from a function pointer to an object pointer. In fact it barely draws a line between them. </p>\n<p>It just states, at \u00a76.3.2.3/8, that:</p>\n<blockquote>\n<p id=\"so_23149343_23149518_2\">A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. If a converted pointer is used to call a function whose type is not compatible with the referenced type, the behavior is undefined.</p>\n</blockquote>\n<p>At this point the behavior almost seems to be <em>unspecified</em>.</p>\n<p>And then later in \u00a76.5.9/6:</p>\n<blockquote>\n<p id=\"so_23149343_23149518_3\">Two pointers compare equal if and only if both are null pointers, both are pointers to the same object (including a pointer to an object and a subobject at its beginning) or function, both are pointers to one past the last element of the same array object, or one is a pointer to one past the end of one array object and the other is a pointer to the start of a different array object that happens to immediately follow the first array object in the address space.</p>\n</blockquote>\n<p>Here we can see the only trace of an actual difference in:</p>\n<blockquote>\n<p id=\"so_23149343_23149518_4\">Two pointers compare equal if and only if both are [..] pointers to the same object (..) <strong>or</strong> function [..].</p>\n</blockquote>\n<h3>The why</h3>\n<p>As for the \"why\", it appears to be dependent on the fact that some architectures simply have functions and objects in two address space.</p>\n", "OwnerUserId": "493122", "LastEditorUserId": "493122", "LastEditDate": "2014-04-18T08:01:50.163", "Id": "23149518", "Score": "4", "CreationDate": "2014-04-18T07:30:10.713", "LastActivityDate": "2014-04-18T08:01:50.163"}, "23149421": {"ParentId": "23149343", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_23149343_23149421_0\">pointers to members are not memory addresses exactly like pointers to data! Why so? </p>\n</blockquote>\n<p>Pointers to member functions need to indicate whether the function is virtual, and allow virtual dispatch (perhaps by specifying the index into the vtable, rather than the address of a specific function) if so. This makes them more complicated than just an address.</p>\n<blockquote>\n<p id=\"so_23149343_23149421_1\">And this isn't necessarily with member functions but any normal C functions as well, isn't?</p>\n</blockquote>\n<p>Pointers to \"normal\" (non-member) functions may be converted to object pointers, but not portably. Quoting the standard:</p>\n<blockquote>\n<p id=\"so_23149343_23149421_2\">C++11 5.2.10/8 Converting a function pointer to an object pointer type or vice versa is conditionally-supported. The meaning of such a conversion is implementation-defined, [...]</p>\n</blockquote>\n<p>On many platforms, a (non-member) function pointer is simply a memory address, and the conversion is well-defined. Some platforms have more exotic memory architectures - for example, separate memory spaces for instructions and data - and the conversion may not be allowed on those platforms.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2014-04-18T07:30:20.863", "Id": "23149421", "Score": "13", "CreationDate": "2014-04-18T07:24:28.160", "LastActivityDate": "2014-04-18T07:30:20.863"}, "bq_ids": {"n4140": {"so_23149343_23149518_1": {"section_id": 6047, "quality": 0.9117647058823529, "length": 31}, "so_23149343_23149421_2": {"section_id": 6047, "quality": 0.75, "length": 12}, "so_23149343_23149518_4": {"section_id": 6155, "quality": 0.6666666666666666, "length": 6}}, "n3337": {"so_23149343_23149518_1": {"section_id": 5815, "quality": 0.9117647058823529, "length": 31}, "so_23149343_23149421_2": {"section_id": 5815, "quality": 0.75, "length": 12}, "so_23149343_23149518_4": {"section_id": 5917, "quality": 0.6666666666666666, "length": 6}}, "n4659": {"so_23149343_23149518_1": {"section_id": 7546, "quality": 0.9117647058823529, "length": 31}, "so_23149343_23149421_2": {"section_id": 7546, "quality": 0.75, "length": 12}, "so_23149343_23149518_4": {"section_id": 7653, "quality": 0.7777777777777778, "length": 7}}}});