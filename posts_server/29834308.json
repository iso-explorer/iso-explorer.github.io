post_cb({"bq_ids": {"n4140": {"so_29834308_29834426_0": {"length": 44, "quality": 0.9777777777777777, "section_id": 481}, "so_29834308_29834426_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 592}, "so_29834308_29834426_3": {"length": 17, "quality": 1.0, "section_id": 388}, "so_29834308_29834426_1": {"length": 16, "quality": 0.6956521739130435, "section_id": 3294}}, "n3337": {"so_29834308_29834426_0": {"length": 40, "quality": 0.8888888888888888, "section_id": 472}, "so_29834308_29834426_3": {"length": 17, "quality": 1.0, "section_id": 379}, "so_29834308_29834426_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 582}, "so_29834308_29834426_1": {"length": 16, "quality": 0.6956521739130435, "section_id": 3164}}, "n4659": {"so_29834308_29834426_0": {"length": 35, "quality": 0.7777777777777778, "section_id": 504}, "so_29834308_29834426_3": {"length": 17, "quality": 1.0, "section_id": 405}, "so_29834308_29834426_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 615}, "so_29834308_29834426_1": {"length": 18, "quality": 0.782608695652174, "section_id": 4056}}}, "29834308": {"ViewCount": "190", "Body": "<p>GCC (tested with 4.9) accepts the following testcase:</p>\n<pre><code>struct Base {};\n\nstruct Derived : Base {\n    Derived();\n    explicit Derived(const Derived&amp;);\n    explicit Derived(Derived&amp;&amp;);\n    explicit Derived(const Base&amp;);\n    Derived(Base&amp;&amp;);\n};\n\nDerived foo() {\n  Derived result;\n  return result;\n}\n\nint main() {\n  Derived result = foo();\n}\n</code></pre>\n<p>Clang (tested with 3.5) rejects it with the following error message:</p>\n<pre><code>test.cpp:13:10: error: no matching constructor for initialization of 'Derived'\n  return result;\n         ^~~~~~\ntest.cpp:8:5: note: candidate constructor not viable: no known conversion from 'Derived' to 'Base &amp;&amp;' for 1st argument\n    Derived(Base&amp;&amp;);\n    ^\ntest.cpp:4:5: note: candidate constructor not viable: requires 0 arguments, but 1 was provided\n    Derived();\n    ^\n</code></pre>\n<p>Who is right?</p>\n", "AcceptedAnswerId": "29834426", "Title": "Overload resolution difference between gcc and clang involving move constructor and 'Derived(Base&&)' constructor", "CreationDate": "2015-04-23T21:06:16.063", "Id": "29834308", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2015-04-23T21:34:10.150", "Score": "17", "OwnerUserId": "141719", "Tags": "<c++><c++11><gcc><clang><overload-resolution>", "AnswerCount": "1"}, "29834426": {"Id": "29834426", "PostTypeId": "2", "Body": "<p>I believe Clang is correct here. GCC should not be accepting the code.</p>\n<p>The reason is the way overload resolution for constructors for the object copy occurring in a <code>return</code> statement is specified in <code>[class.copy] p32</code> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_29834308_29834426_0\">When the criteria for elision of a copy/move constructor are met,\n  [...], and the object to be copied is designated by an lvalue, [...],\n  overload resolution to select the constructor for the copy is first\n  performed as if the object were designated by an rvalue. If the first\n  overload resolution fails or was not performed, <strong>or if the type of\n  the first parameter of the selected constructor is not an rvalue\n  reference to the object's type (possibly cv-qualified)</strong>, overload\n  resolution is performed again, considering the object as an lvalue.</p>\n</blockquote>\n<p>In this example, the criteria for elision are met (by the first bullet in <code>[class.copy] p31</code>) and the object to be copied is designated by an lvalue, so this paragraph applies.</p>\n<p>Overload resolution is first attempted as if the object were designated by an rvalue. The <code>explicit</code> constructors are not candidates (see below for an explanation of why), so the <code>Derived(Base&amp;&amp;)</code> constructor is selected. However, this falls under \"the type of the first parameter of the selected constructor is not an rvalue reference to the object's type\" (instead, it's an rvalue reference to the type of the object's base class), so overload resolution should be performed again, considering the object as an lvalue.</p>\n<p>This second overload resolution fails, because the only viable constructor (again, the <code>explicit</code> constructors are not candidates) has an rvalue reference parameter, which cannot bind to the lvalue. Clang shows the resulting overload resolution failure error.</p>\n<hr>\n<p>To complete the explanation, here's why <code>explicit</code> constructors are not candidates for either overload resolution (all emphasis is mine).</p>\n<p>First, <code>[dcl.init] p15</code> says that:</p>\n<blockquote>\n<p id=\"so_29834308_29834426_1\">The initialization that occurs in the = form of a\n  <em>brace-or-equal-initializer</em> or <em>condition</em> (6.4), as well as in argument\n  passing, <strong>function return</strong>, throwing an exception (15.1), handling an\n  exception (15.3), and aggregate member initialization (8.5.1), <strong>is\n  called <em>copy-initialization</em></strong>.\"</p>\n</blockquote>\n<p>Next, we look at <code>[over.match.ctor] p1</code>:</p>\n<blockquote>\n<p id=\"so_29834308_29834426_2\"><strong>For copy-initialization</strong>, the candidate functions are <strong>all the converting \n  constructors</strong> (12.3.1) of that class.</p>\n</blockquote>\n<p>Finally, we see that <code>explicit</code> constructors are not converting constructors in <code>[class.conv.ctor] p1</code>:</p>\n<blockquote>\n<p id=\"so_29834308_29834426_3\">A constructor declared <strong>without the <em>function-specifier</em>\n<code>explicit</code></strong> specifies a conversion from the types of its parameters to the type of its class. Such a constructor is called a <strong><em>converting\n  constructor</em></strong>.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "141719", "LastActivityDate": "2015-04-23T21:34:10.150", "Score": "14", "CreationDate": "2015-04-23T21:14:24.577", "ParentId": "29834308", "CommentCount": "5", "OwnerUserId": "141719", "LastEditDate": "2015-04-23T21:34:10.150"}});