post_cb({"2671483": {"ParentId": "2671460", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2010-04-19T23:03:31.827", "Score": "12", "LastEditorUserId": "153285", "LastEditDate": "2010-04-20T19:07:25.413", "Id": "2671483", "OwnerUserId": "153285", "Body": "<p>Function template calls can usually avoid explicit template arguments (ie <code>make_pair&lt;\u2026&gt;</code>) by argument deduction, which is defined by C++03 \u00a714.8.2. Excerpt:</p>\n<blockquote>\n<p id=\"so_2671460_2671483_0\">When a function template\n  specialization is referenced, all of\n  the template arguments must have\n  values. The values can be either\n  explicitly specified or, in some\n  cases, deduced from the use.</p>\n</blockquote>\n<p>The specific rules are a bit complicated, but typically it \"just works\" as long as you have only one specialization which is generally qualified enough.</p>\n<p>Your example uses two steps of deduction and one implicit conversion.</p>\n<ul>\n<li><code>make_pair</code> returns a <code>pair&lt;char const*, int&gt;</code>,</li>\n<li>then <code>template&lt;class U, classV&gt; pair&lt;string,int&gt;::pair( pair&lt;U,V&gt; const &amp; )</code> kicks in with <code>U = char*, V = int</code> and performs member-wise initialization,</li>\n<li>invoking <code>string::string(char*)</code>.</li>\n</ul>\n", "LastActivityDate": "2010-04-20T19:07:25.413"}, "2671490": {"ParentId": "2671460", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2010-04-19T23:04:23.607", "Score": "1", "LastEditorUserId": "187584", "LastEditDate": "2010-04-19T23:47:54.863", "Id": "2671490", "OwnerUserId": "187584", "Body": "<p>It relies on the fact that the constructor of std::string accepts a const char*.\nIt doesn't matter if this constructor of std::string is explicit or not. The template deducts the type and uses the copy constructor of pair to convert it. It also doesn't matter whether or not the pair constructor is explicit.</p>\n<p>If you turn the constructor of std::string into:</p>\n<pre><code>class string\n{\npublic:\n    string(char* s)\n    {\n    }   \n};\n</code></pre>\n<p>you get this error:</p>\n<pre><code>/usr/include/c++/4.3/bits/stl_pair.h: In constructor \u2018std::pair&lt;_T1, _T2&gt;::pair(const std::pair&lt;_U1, _U2&gt;&amp;) [with _U1 = const char*, _U2 = int, _T1 = const string, _T2 = int]\u2019:\nfoo.cpp:27:   instantiated from here\n/usr/include/c++/4.3/bits/stl_pair.h:106: error: invalid conversion from \u2018const char* const\u2019 to \u2018char*\u2019\n/usr/include/c++/4.3/bits/stl_pair.h:106: error:   initializing argument 1 of \u2018string::string(char*)\u2019\n</code></pre>\n<p>The constructor looks like this:</p>\n<pre><code>  template&lt;class _U1, class _U2&gt;\n    pair(const pair&lt;_U1, _U2&gt;&amp; __p)\n    : first(__p.first),\n      second(__p.second) { }\n</code></pre>\n<p>The copy constructor looks like this:</p>\n<pre><code>template&lt;class _U1, class _U2&gt;\npair(const pair&lt;_U1, _U2&gt;&amp; __p)\n    : first(__p.first),\n      second(__p.second) { }\n</code></pre>\n", "LastActivityDate": "2010-04-19T23:47:54.863"}, "2671484": {"ParentId": "2671460", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-04-19T23:03:42.307", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:58:27.510", "Id": "2671484", "OwnerUserId": "12711", "Body": "<p><code>make_pair()</code> exists precisely so that argument type deduction can be used to determine the template parameter types.</p>\n<p>See this SO question: <a href=\"https://stackoverflow.com/questions/2466507/using-free-function-as-pseudo-constructors-to-exploit-template-parameter-deductio\">Using free function as pseudo-constructors to exploit template parameter deduction</a></p>\n", "LastActivityDate": "2010-04-19T23:03:42.307"}, "2671500": {"ParentId": "2671460", "CommentCount": "6", "Body": "<p>It doesn't.  make_pair generated a pair&lt;char*,int&gt; (or maybe a pair&lt;char const*,int&gt;).  </p>\n<p>However, if you'll note in the implementation of pair there's a templated copy constructor:</p>\n<pre><code>\ntemplate &lt; typename Other1, typename Other2 &gt; \npair(pair&lt;Other1,Other2&gt;&amp; other) \n  : first(other.first), second(other.second)\n{}\n</code></pre>\n<p>This may be implemented in slightly different ways but amounts to the same thing.  Since this constructor is implicit, the compiler attempts to create pair&lt;std::string,int&gt; out of your pair&lt;char*,int&gt; - since the necessary types are convertible this works.</p>\n", "OwnerUserId": "301883", "PostTypeId": "2", "Id": "2671500", "Score": "9", "CreationDate": "2010-04-19T23:06:16.097", "LastActivityDate": "2010-04-19T23:06:16.097"}, "bq_ids": {"n4140": {"so_2671460_2671483_0": {"section_id": 293, "quality": 0.8571428571428571, "length": 18}}, "n3337": {"so_2671460_2671483_0": {"section_id": 284, "quality": 0.8571428571428571, "length": 18}}, "n4659": {"so_2671460_2671483_0": {"section_id": 300, "quality": 0.8571428571428571, "length": 18}}}, "2671460": {"CommentCount": "1", "ViewCount": "1616", "PostTypeId": "1", "LastEditorUserId": "77915", "CreationDate": "2010-04-19T22:59:35.443", "LastActivityDate": "2012-05-02T21:07:09.557", "Title": "How does make_pair know the types of its args?", "AcceptedAnswerId": "2671483", "LastEditDate": "2012-05-02T21:07:09.557", "Id": "2671460", "Score": "3", "Body": "<p>The definition for make_pair in the MSVC++ \"utility\" header is:</p>\n<pre>\ntemplate&lt;class _Ty1,\n class _Ty2&gt; inline\n pair&lt;_Ty1, _Ty2&gt; make_pair(_Ty1 _Val1, _Ty2 _Val2)\n { // return pair composed from arguments\n return (pair&lt;_Ty1, _Ty2&gt;(_Val1, _Val2));\n }\n</pre>\n<p>I use make_pair all the time though <em>without</em> putting the argument types in angle brackets:</p>\n<pre>\n    map&lt;string,int&gt; theMap ;\n\n    theMap.insert( make_pair( \"string\", 5 ) ) ;\n</pre>\n<p>Shouldn't I have to tell <code>make_pair</code> that the first argument is <code>std::string</code> and not <code>char*</code> ?</p>\n<p>How does it know?</p>\n", "Tags": "<c++><stdmap><std-pair>", "OwnerUserId": "111307", "AnswerCount": "4"}});