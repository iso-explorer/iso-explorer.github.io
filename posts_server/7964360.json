post_cb({"7964428": {"ParentId": "7964360", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The standard library headers for gcc 4.6 seem to be wrong in this case as the standard requires the following constructor (\u00a720.7.2.2.1/16):</p>\n<pre><code>shared_ptr(const shared_ptr&amp; r) noexcept;\n</code></pre>\n<p>Which is a copy-constructor that seem to be missing from the gcc implementation. The implementation I have at hand (g++-4.6.0) offers (in <code>bits/shared_ptr.h</code>):</p>\n<pre><code>template&lt;typename _Tp1&gt;\nshared_ptr(const shared_ptr&lt;_Tp1&gt;&amp; __r)\n</code></pre>\n<p>But does not have a proper copy-constructor (a templated constructor cannot be used by the compiler as a copy constructor). I find it strange, though, that such an error would come up with a production compiler...</p>\n<p><strong>EDIT</strong> I have been trying to figure out why exactly g++ 4.6 compiles the above code with it's own standard library. It seems that it is picking up the <code>template</code>d constructor as a viable overload for copy construction, which made me look back to the standard to verify whether that is a bug --I have always been under the impression that a template could not been used as a copy constructor-- or not.</p>\n<p>In the C++03 standard, there is a footnote <sup>106)</sup></p>\n<blockquote>\n<p id=\"so_7964360_7964428_0\">Because <strong>a template constructor is never a copy constructor</strong>, the presence of such a template does not suppress the implicit declara-\n  tion of a copy constructor. Template constructors participate in overload resolution with other constructors, including copy construc-\n  tors, and a template constructor may be used to copy an object if it provides a better match than other constructors.</p>\n</blockquote>\n<p>That footnote is not present in C++11. Footnotes are not normative, so there has to be other quote supporting that note. A couple of paragraphs below there you can find: </p>\n<blockquote>\n<p id=\"so_7964360_7964428_1\">12.8/3 A declaration of a constructor for a class X is ill-formed if its first parameter is of type (optionally cv-qualified) X and either there are no other parameters or else all other parameters have default arguments. <strong>A member function template is never instantiated to perform the copy of a class object to an object of its class type.</strong></p>\n</blockquote>\n<p>The first part of the paragraph means that a constructor cannot take the same type as argument (copy constructors take references, and allowing such constructor would cause an ambiguity, that and the fact that it would require <em>copying</em> into the argument, for which the best overload --assuming that this inhibited the copy constructor-- would be the same function, which in turns would require... infinite loop). </p>\n<p>The second part of the clause states that a templated constructor cannot be used to create copies of the type, which seems to be the normative section supporting footnote <sup>106)</sup>. Now, that has been carefully reworded in C++11 to state:</p>\n<blockquote>\n<p id=\"so_7964360_7964428_2\">12.8/6 A declaration of a constructor for a class X is ill-formed if its first parameter is of type (optionally cv-qualified) X and either there are no other parameters or else all other parameters have default arguments. <strong>A member function template is never instantiated to produce such a constructor signature.</strong></p>\n</blockquote>\n<p>Now, what this means is that the restriction <em>a template cannot be used to copy</em> has been removed, and replaced by the less strict restriction: a template will not be instantitated to generate a constructor of the form <code>S( S )</code>, i.e. one that would cause an ambiguity with the copy constructor.</p>\n<p>With this lesser restriction, it seems that the templated constructor above can actually be used as a <em>copy-constructor</em>, as the signature that it generates is compatible. This supports the behavior of the g++ 4.6 compiler when processing the <code>bits/shared_ptr.h</code> header, and would imply that <code>clang++</code> is failing to use the template as a valid constructor.</p>\n<p>Now the next question is whether the standard library implementation shipped with g++4.6 is actually compliant or not. I cannot say off the top of my head. On one side, it is missing the signature of constructor that I mentioned above, so you can argue that it is not compliant. But on the other hand, a compliant compiler should pick up the templated constructor to achieve the same functionality, and the implementation would behave <em>as-if</em> that constructor was present.</p>\n", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2011-11-01T12:44:14.927", "Id": "7964428", "Score": "6", "CreationDate": "2011-11-01T09:13:28.257", "LastActivityDate": "2011-11-01T12:44:14.927"}, "7968090": {"ParentId": "7964360", "CommentCount": "4", "Body": "<p>The implicitly-declared copy constructor for shared_ptr is deleted because shared_ptr has a move constructor or a move assignment operator (or both), per C++11 12.8p7:</p>\n<p>If the class definition does not explicitly declare a copy constructor, one is declared implicitly. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted; otherwise, it is defined as defaulted (8.4).</p>\n<p>GCC 4.6.x does not implement this rule, which came into the C++11 working paper very late in the process as <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3203.htm\" rel=\"noreferrer\">N3203=10-0193</a>. The shared_ptr in libstdc++ 4.6.x was correct at the time it was written, but C++11 changed after that.. Boost had <a href=\"https://svn.boost.org/trac/boost/changeset/73202\" rel=\"noreferrer\">exactly the same issue</a> with it's shared_ptr, and this is one of the <a href=\"http://clang.llvm.org/compatibility.html#deleted-special-func\" rel=\"noreferrer\">common incompatibilities</a> between GCC and Clang.</p>\n<p>Adding a defaulted copy constructor and copy assignment operator to shared_ptr will fix the problem.</p>\n", "OwnerUserId": "985684", "PostTypeId": "2", "Id": "7968090", "Score": "20", "CreationDate": "2011-11-01T14:36:08.073", "LastActivityDate": "2011-11-01T14:36:08.073"}, "bq_ids": {"n4140": {"so_7964360_7964428_1": {"section_id": 455, "quality": 0.7428571428571429, "length": 26}, "so_7964360_7964428_2": {"section_id": 455, "quality": 0.967741935483871, "length": 30}}, "n3337": {"so_7964360_7964428_1": {"section_id": 446, "quality": 0.7428571428571429, "length": 26}, "so_7964360_7964428_2": {"section_id": 446, "quality": 0.967741935483871, "length": 30}}, "n4659": {"so_7964360_7964428_1": {"section_id": 478, "quality": 0.7428571428571429, "length": 26}, "so_7964360_7964428_2": {"section_id": 478, "quality": 0.967741935483871, "length": 30}}}, "7964360": {"CommentCount": "3", "AcceptedAnswerId": "7968090", "CreationDate": "2011-11-01T09:06:31.297", "LastActivityDate": "2011-11-01T14:36:08.073", "PostTypeId": "1", "ViewCount": "5328", "FavoriteCount": "2", "Title": "Using std::shared_ptr with clang++ and libstdc++", "Id": "7964360", "Score": "12", "Body": "<p>I'm trying to use the std::shared_ptr in clang++(clang version 3.1 (trunk 143100)) using libstdc++(4.6.1). I have a little demo program:</p>\n<pre><code>#include &lt;memory&gt;\n\nint main()\n{\n    std::shared_ptr&lt;int&gt; some(new int);\n    std::shared_ptr&lt;int&gt; other(some);\n    return 0;\n}\n</code></pre>\n<p>which can be build using:</p>\n<pre><code>clang++ -std=c++0x -o main main.cpp\n</code></pre>\n<p>and gives the following error output:</p>\n<pre><code>main.cpp:6:23: error: call to deleted constructor of 'std::shared_ptr&lt;int&gt;'\n    std::shared_ptr&lt;int&gt; other(some);\n                         ^     ~~~~\n/usr/include/c++/4.6/bits/shared_ptr.h:93:11: note: function has been explicitly marked\ndeleted here\nclass shared_ptr : public __shared_ptr&lt;_Tp&gt;\n</code></pre>\n<p>For some reason it needs the constructor which is deleted because a move constructor is provided (which is correct behaviour).\nBut why does it work compile with (g++ (Ubuntu/Linaro 4.6.1-9ubuntu3) 4.6.1.)? Somebody any ideas on how to fix this?</p>\n", "Tags": "<c++><shared-ptr><clang><libstdc++>", "OwnerUserId": "639017", "AnswerCount": "2"}});