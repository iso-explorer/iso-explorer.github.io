post_cb({"bq_ids": {"n4140": {"so_37191293_37191397_4": {"length": 30, "quality": 1.0, "section_id": 3270}, "so_37191293_37191397_2": {"length": 6, "quality": 1.0, "section_id": 3270}}, "n3337": {"so_37191293_37191397_4": {"length": 30, "quality": 1.0, "section_id": 3142}, "so_37191293_37191397_2": {"length": 6, "quality": 1.0, "section_id": 3142}}, "n4659": {"so_37191293_37191397_4": {"length": 30, "quality": 1.0, "section_id": 4028}, "so_37191293_37191397_2": {"length": 6, "quality": 1.0, "section_id": 4028}}}, "37191293": {"ViewCount": "389", "Body": "<p>I am curious why, in C++ 11, use of \"= default\" on a derived virtual method does not select the pure base class implementation. </p>\n<p>For example, the following test code produces the message \"error: 'virtual void B::tst()' cannot be defaulted\" from \"g++ -std=c++11\". </p>\n<pre><code>struct A {\n  virtual ~A () = default;\n  virtual void tst () = 0;\n};\n\nvoid A :: tst () {}\n\nstruct B : public A {\n  virtual void tst () = default;\n};\n</code></pre>\n<p>We can of course provide a B::tst that invokes the default base implementation, but one is concerned that this might be the higher overhead implementation compared to a hypothetical \"= default\" based coding. </p>\n<p>Sorry to ask questions about what might or might not be within the minds of the c++ standards committee persons, but nevertheless perhaps someone here at stack overflow will have some wisdom concerning the impracticality of using the default keyword in this way that would be interesting to hear.</p>\n<p>Thanks!</p>\n", "Title": "c++ 11 =default keyword on virtual function for specifying default pure implementation", "CreationDate": "2016-05-12T15:24:24.727", "LastActivityDate": "2016-05-12T15:53:28.810", "CommentCount": "2", "PostTypeId": "1", "Id": "37191293", "Score": "0", "OwnerUserId": "3988443", "Tags": "<c++11><default><keyword><pure-virtual>", "AnswerCount": "1"}, "37191397": {"Id": "37191397", "PostTypeId": "2", "Body": "<p>According to the standard <em>\u00a78.4.2/p1 Explicitly-defaulted functions [dcl.fct.def.default]</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_37191293_37191397_0\">A function definition of the form:</p>\n<p id=\"so_37191293_37191397_1\"><code>attribute-specifier-seqopt decl-specifier-seqopt declarator\n  virt-specifier-seqopt = default;</code></p>\n<p id=\"so_37191293_37191397_2\">is called an explicitly-defaulted definition. A function that is\n  explicitly defaulted shall</p>\n<p id=\"so_37191293_37191397_3\">(1.1) \u2014 <strong>be a special member function,</strong></p>\n<p id=\"so_37191293_37191397_4\">(1.2) \u2014 have the same declared function type (except for possibly differing ref-qualifiers and except that in\n  the case of a copy constructor or copy assignment operator, the parameter type may be \u201creference to\n  non-const T\u201d, where T is the name of the member function\u2019s class) as if it had been implicitly declared,\n  and</p>\n<p id=\"so_37191293_37191397_5\">(1.3) \u2014 not have default arguments</p>\n</blockquote>\n<p>Member function <code>tst()</code> is not a <a href=\"http://en.cppreference.com/w/cpp/language/member_functions#Special_member_functions\" rel=\"nofollow\">special member function</a>. Thus, it cannot be defaulted.</p>\n<p>Now specifying a member function of a class (e.g., <code>class A</code>) as pure virtual entails that any class that inherits from that class and you don't wan't it to be abstract as well must override that member function.</p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2016-05-12T15:53:28.810", "Score": "1", "CreationDate": "2016-05-12T15:29:43.137", "ParentId": "37191293", "CommentCount": "1", "LastEditDate": "2016-05-12T15:53:28.810", "OwnerUserId": "2352671"}});