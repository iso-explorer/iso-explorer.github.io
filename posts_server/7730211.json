post_cb({"7730211": {"CommentCount": "0", "ViewCount": "811", "CreationDate": "2011-10-11T17:46:03.903", "LastActivityDate": "2011-10-11T19:19:06.933", "Title": "C++ class method, returns vector<subclass>", "AcceptedAnswerId": "7730244", "PostTypeId": "1", "Id": "7730211", "Score": "1", "Body": "<p>I'm having a bit of trouble with a method I'm trying to write for a class.  I have class symbol and class terminal.  class terminal extends class symbol, but one of the methods of class symbol needs to return a vector.  E.g.:</p>\n<pre><code>#ifndef SYMBOL_H\n#define SYMBOL_H\n\n#include \"terminal.h\"\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass symbol {\n   public:\n        vector&lt;terminal&gt; first();\n        virtual void polymorphable();\n};\n\n#endif\n</code></pre>\n<p>With class terminal defined:</p>\n<pre><code>#ifndef TERMINAL_H\n#define TERMINAL_H\n\n#include \"symbol.h\"\n\nusing namespace std;\n\nclass terminal: public symbol {\n    // ...\n};\n\n#endif\n</code></pre>\n<p>However, when doing this, I get two errors when building, with one or the other coming first: \"'terminal' : undeclared identifier\" on the line that defines the vector function, and \"'symbol' : base class undefined\" on the line with the terminal class definition.</p>\n<p>How do I solve this 'a requires b', 'b requires a' issue?</p>\n", "Tags": "<c++><stl><polymorphism>", "OwnerUserId": "936083", "AnswerCount": "7"}, "7730263": {"ParentId": "7730211", "CommentCount": "8", "Body": "<p>I think Curiously Recurring Template Pattern can get you out of this one:</p>\n<pre><code>template&lt;typename terminal_type&gt;\nclass symbol_pattern\n{\n   public:\n        std::vector&lt;terminal_type&gt; first();\n        virtual void polymorphable();\n};\n\nclass terminal : public symbol_pattern&lt;terminal&gt;\n{\n};\n\ntypedef symbol_pattern&lt;terminal&gt; symbol;\n</code></pre>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "7730263", "Score": "0", "CreationDate": "2011-10-11T17:50:49.650", "LastActivityDate": "2011-10-11T17:50:49.650"}, "7730420": {"ParentId": "7730211", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Use forward declarations. </p>\n<p>James - note declarations differ from instantion. This code works fine</p>\n<pre><code>#include &lt;vector&gt;\n\nclass terminal; &lt;--- TELLING THE COMPILER MAY USE terminal in the future.\n\nclass symbol \n{        \n  std::vector&lt;terminal&gt; first(); &lt;--- NOTE THE COMPILER DOES NOT NEED TO KNOW HOW TO CONSTRUCT EITHER\n  // ... \n};           \n\nclass terminal: public symbol  &lt; --- TELLS COMPILER THAT terminal INHERITS symbol i.e. CONTAINING THE METHOD first\n{\n   int wibble; \n};  \n\nint main()\n{\n    symbol s;\n    return 0;\n}\n</code></pre>\n<p>Als - You are correct.</p>\n", "OwnerUserId": "892256", "LastEditorUserId": "892256", "LastEditDate": "2011-10-11T18:33:51.513", "Id": "7730420", "Score": "1", "CreationDate": "2011-10-11T18:03:55.083", "LastActivityDate": "2011-10-11T18:33:51.513"}, "7730318": {"ParentId": "7730211", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Forward declaration + smart pointer (although this will now store things on the heap instead of stack... could be undesirable)</p>\n<pre><code>#ifndef SYMBOL_H\n#define SYMBOL_H\n\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nclass terminal; // Make a forward declaration like this\n\nclass symbol {\n   public:\n        vector&lt;shared_ptr&lt;terminal&gt;&gt; first();\n        virtual void polymorphable();\n};\n\n#endif\n</code></pre>\n", "OwnerUserId": "985032", "LastEditorUserId": "985032", "LastEditDate": "2011-10-11T18:16:27.677", "Id": "7730318", "Score": "0", "CreationDate": "2011-10-11T17:55:12.127", "LastActivityDate": "2011-10-11T18:16:27.677"}, "7730266": {"ParentId": "7730211", "PostTypeId": "2", "CommentCount": "20", "Body": "<p><em>Edit:</em> The following may not be allowed by the standard (see the comments). In that case, you simply cannot have a proper circular dependency: If the size of <code>A</code> depends on the size of a member of type <code>B</code>, but the size of <code>B</code> depends on the size of a member of type <code>A</code>, then such a definition simply doesn't make sense.</p>\n<p>I'm not entirely certain if that applies to your situation, though, since you only declare a function whose return type is incomplete, which <em>is</em> allowed. See the attendant <a href=\"https://stackoverflow.com/questions/7730874/in-the-declaration-stdvectorx-f-is-stdvectorx-an-instantiation\">question by James</a>; hopefully we'll get a definite answer there.</p>\n<hr>\n<p>Just forward-declare <code>terminal</code>:</p>\n<pre><code>class terminal;\n\nclass symbol\n{\n  std::vector&lt;terminal&gt; first();\n  // ...\n};\n</code></pre>\n<p>You can forward-declare anything that only needs to be an <em>incomplete</em> type. Incomplete types can be used to form pointers, references, function signatures. The complete type only needs to be known when variables of that type are <em>used</em>.</p>\n</hr>", "OwnerUserId": "596781", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:46.047", "Id": "7730266", "Score": "2", "CreationDate": "2011-10-11T17:51:06.747", "LastActivityDate": "2011-10-11T19:13:20.043"}, "7730244": {"ParentId": "7730211", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Avoid circular dependencies by using <strong><a href=\"https://stackoverflow.com/questions/553682/when-to-use-forward-declaration\">Forward Declarations</a>.</strong></p>\n<pre><code>class terminal;\n\nclass symbol\n{\n  std::vector&lt;terminal&gt; first();\n  // ...\n};\n</code></pre>\n<p>There is a speculation of this approach being Undefined as per C++ standard.<br>\n@Ben Voight points out:  </br></p>\n<p><strong>C++03 standard Section 17.6.4.8 says:</strong></p>\n<blockquote>\n<p id=\"so_7730211_7730244_0\">\"In particular, the effects are undefined in the following cases: ... if an incomplete type is used as a template argument <strong>when instantiating a template component</strong>, unless specifically allowed for that component...</p>\n</blockquote>\n<p>Whether <code>std::vector&lt;X&gt; f();</code> is <code>std::vector&lt;X&gt;</code> an instantiation, is being discussed <strong><a href=\"https://stackoverflow.com/questions/7730874/in-the-declaration-stdvectorx-f-is-stdvectorx-an-instantiation\">here</a></strong>. If the answer there proves it is then this answer holds no good and I will delete the same, or else this stays valid.</p>\n", "OwnerUserId": "452307", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T09:59:44.263", "Id": "7730244", "Score": "3", "CreationDate": "2011-10-11T17:49:07.420", "LastActivityDate": "2011-10-11T19:19:06.933"}, "7730354": {"ParentId": "7730211", "CommentCount": "2", "Body": "<p>Rather than having a single member function return a container, consider having <code>begin()</code> and <code>end()</code> functions that return an iterator range, similar to what the Standard Library containers do themselves:</p>\n<pre><code>class terminal;\n\nclass terminal_iterator { /* defined appropriately */\n\nstruct symbol\n{\n    terminal_iterator begin_terminals() const;\n    terminal_iterator end_terminals() const;\n};\n</code></pre>\n<p>If you already have a <code>std::vector&lt;terminal&gt;</code> somewhere that you are going to be iterating over, you can just <code>typedef terminal const* terminal_iterator;</code> (or use a similar typedef) and define the member functions accordingly.</p>\n<p>If you don't have a container (i.e., the member function would materialize the sequence itself), you can consider writing your own iterator class that generates the sequence.</p>\n<p>Providing <code>begin()</code> and <code>end()</code> range accessors is sometimes a bit more work than simply providing an accessor for a container, but range accessors make for greater flexibility and abstraction.</p>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "7730354", "Score": "0", "CreationDate": "2011-10-11T17:58:54.180", "LastActivityDate": "2011-10-11T17:58:54.180"}, "7730306": {"ParentId": "7730211", "CommentCount": "1", "Body": "<p><code>Base</code> class should not need to know anything about <code>Derived</code> class.  That's an important principle in Object Oriented Design.  You could potentially change the base class to be:</p>\n<pre><code>class symbol {\n  public:\n    vector&lt;symbol*&gt; first();\n    virtual void polymorphable();\n};\n</code></pre>\n<p>Now, <code>first()</code> returns a vector of pointers to the base class.  With polymorphism, each pointer can actually point to the derived class.  Note that I changed it to use pointers.  If you changed it to simply <code>vector&lt;symbol&gt;</code> that wouldn't work.</p>\n<p>Alternatly, if you really need the Base class to know about the existence of the Derived class, you can forward declare the derived class:</p>\n<pre><code>#ifndef SYMBOL_H\n#define SYMBOL_H\n\n#include \"terminal.h\"\n#include &lt;vector&gt;\n\nusing namespace std;\nclass terminal;  // forward declare the existence of this class\n\nclass symbol {\n  public:\n    vector&lt;terminal*&gt; first();     // change to be a vector of pointers\n                                   // to avoid issues with incomplete type\n    virtual void polymorphable();\n};\n\n#endif\n</code></pre>\n", "OwnerUserId": "108994", "PostTypeId": "2", "Id": "7730306", "Score": "1", "CreationDate": "2011-10-11T17:54:45.997", "LastActivityDate": "2011-10-11T17:54:45.997"}, "bq_ids": {"n4140": {"so_7730211_7730244_0": {"section_id": 6324, "quality": 1.0, "length": 16}}, "n3337": {"so_7730211_7730244_0": {"section_id": 6081, "quality": 1.0, "length": 16}}, "n4659": {"so_7730211_7730244_0": {"section_id": 7834, "quality": 1.0, "length": 16}}}});