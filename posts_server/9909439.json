post_cb({"9909574": {"ParentId": "9909439", "CommentCount": "0", "Body": "<p>Yes, if you never use polymorphism (that is, never upcast a reference or pointer), there is no way to perform an unsafe destruction.</p>\n<p>Mixin classes are often used this way, and CRTP rarely implies a virtual destructor, to name a couple patterns.</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "9909574", "Score": "2", "CreationDate": "2012-03-28T14:25:33.050", "LastActivityDate": "2012-03-28T14:25:33.050"}, "9909572": {"ParentId": "9909439", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You are welcome to use that object polymorphically, you just can't <code>delete</code> it polymorphically. If you avoid deleting pointers to objects of your class via <code>std::vector&lt;&gt;*</code>, then you are safe.</p>\n<p><em>Aside</em>: You might simplify your <code>operator[]</code> thus:</p>\n<pre><code>T&amp; operator[](unsigned n) { return this-&gt;at(n); }\n</code></pre>\n", "OwnerUserId": "8747", "LastEditorUserId": "8747", "LastEditDate": "2012-03-28T14:33:35.553", "Id": "9909572", "Score": "4", "CreationDate": "2012-03-28T14:25:28.900", "LastActivityDate": "2012-03-28T14:33:35.553"}, "9909439": {"CommentCount": "6", "AcceptedAnswerId": "9910064", "CreationDate": "2012-03-28T14:18:07.983", "LastActivityDate": "2012-03-28T14:50:46.933", "PostTypeId": "1", "ViewCount": "2246", "FavoriteCount": "1", "Title": "Inheriting from classes without virtual destructors", "Id": "9909439", "Score": "7", "Body": "<p>I've always heard that you shouldn't inherit from a class without virtual destructors, and I didn't pay much attention because I just don't use inheritance all that often.  Does this rule apply even if you don't want to use polymorphism, but you just want all of a class functionality, and you want to add some more?  To be concrete, would the following class be safe, with well defined behavior, as long as I didn't use it polymorphically? (i.e. no deleting base pointers to derived objects)</p>\n<pre><code>template&lt;typename T&gt;\nclass SomewhatSafeVector : public std::vector&lt;T&gt;\n{\npublic:\n    typedef std::vector&lt;T&gt; base;\n\n    T&amp; operator[](unsigned n) {\n        if (n &gt;= base::size())\n        {\n            throw IndexOutOfBounds();\n        }\n        return base::operator[](n);\n    }\n};\n</code></pre>\n", "Tags": "<c++><inheritance>", "OwnerUserId": "440119", "AnswerCount": "4"}, "9909559": {"ParentId": "9909439", "CommentCount": "0", "Body": "<p>If you don't intend to use the class polymorphically(no deleting base pointers to derived objects) then it is not Undefined Behavior.   </p>\n<p>Reference:    </p>\n<p><strong>C++03 Standard: 5.3.5 Delete</strong> </p>\n<p><strong>5.3.5/1:</strong></p>\n<blockquote>\n<p id=\"so_9909439_9909559_0\">The delete-expression operator destroys a most derived object (1.8) or array created by a new-expression.<br>\n  delete-expression:<br>\n  ::opt delete cast-expression<br>\n  ::opt delete [ ] cast-expression      </br></br></br></p>\n</blockquote>\n<p><strong>5.3.5/3:</strong></p>\n<blockquote>\n<p id=\"so_9909439_9909559_1\"><strong>In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined.</strong> In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.73)</p>\n</blockquote>\n", "OwnerUserId": "452307", "PostTypeId": "2", "Id": "9909559", "Score": "5", "CreationDate": "2012-03-28T14:24:52.007", "LastActivityDate": "2012-03-28T14:24:52.007"}, "bq_ids": {"n4140": {"so_9909439_9909559_0": {"section_id": 6105, "quality": 0.6470588235294118, "length": 11}, "so_9909439_9909559_1": {"section_id": 6107, "quality": 0.8717948717948718, "length": 34}}, "n3337": {"so_9909439_9909559_0": {"section_id": 5871, "quality": 0.6470588235294118, "length": 11}, "so_9909439_9909559_1": {"section_id": 5873, "quality": 0.8717948717948718, "length": 34}}, "n4659": {"so_9909439_9909559_0": {"section_id": 7602, "quality": 0.6470588235294118, "length": 11}, "so_9909439_9909559_1": {"section_id": 7604, "quality": 0.8717948717948718, "length": 34}}}, "9910064": {"ParentId": "9909439", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_9909439_9910064_0\">I've always heard that you shouldn't inherit from a class without virtual destructors</p>\n</blockquote>\n<p>This is a rule of thumb given to beginners because explaining all the intricacies take too much time and it is just safer (and not that much costly for exercices programs) to actually give them just a few base lines that work all the times (though may be overkill).</p>\n<p>You can perfectly use inheritance without a <code>virtual</code> destructor in the base class. On the other hand, if the base class has no <code>virtual</code> method at all, then inheritance is probably the wrong tool for the job. <em>For example:</em> in your case if I use <code>SafeVector&lt;T&gt; sv; sv[3];</code> then it is safe, however if I do <code>std::vector&lt;T&gt;&amp; v = sv; v[3];</code> it is not... this is because you are merely <em>hiding</em> the base class method, not overriding it (crank up your warning level, they'll let you know).</p>\n<p>The proper way here would be to use composition, and then create forwarding methods to the implementation member for those methods you really use. In practice, it gets tiring because C++ does not support delegation (<code>using attribute.insert;</code>) so many resort to inheriting...</p>\n<p>Another alternative is to provide the safer methods as free methods, since you can always add free methods without restriction. It might feel less idiomatic to people with the \"OO\" mindset, and some operators cannot be so added.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "9910064", "Score": "6", "CreationDate": "2012-03-28T14:50:46.933", "LastActivityDate": "2012-03-28T14:50:46.933"}});