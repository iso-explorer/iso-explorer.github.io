post_cb({"46032965": {"CommentCount": "1", "AcceptedAnswerId": "46033613", "CreationDate": "2017-09-04T08:21:31.163", "LastActivityDate": "2017-09-04T09:32:05.433", "PostTypeId": "1", "ViewCount": "694", "FavoriteCount": "1", "Title": "Create object in thread A, use in thread B. Mutex required?", "Id": "46032965", "Score": "14", "Body": "<p>I have been reading different things on multithreading, C++, proper synchronization and locks to prevent race conditions. One question has not been answered for me, however:\n<strong>Is there a mutex required if I create an object in thread A, but use it exclusively in thread B afterwards?</strong></p>\n<p>In other words, I know that I don't need a mutex to prevent race conditions - do I need a mutex to serve as a memory barrier (or other potential problems)?</p>\n<p>A very basic example to visualize what I mean</p>\n<pre><code>struct Object {\n    void do_stuff();\n};\n\nObject o;\nstd::thread worker_thread([&amp;o](){\n    while (alive)\n        o.do_stuff();\n}).join();\n// `o` is never used outside worker_thread\n</code></pre>\n<p>I would be happy if you could also recommend me articles / books where I can read more into this topic and/or the right keywords to search for these kinds of scenarios.</p>\n", "Tags": "<c++><multithreading><mutex>", "OwnerUserId": "823255", "AnswerCount": "1"}, "46033613": {"ParentId": "46032965", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This is fine, you don't need a <code>mutex</code>.  </p>\n<p>Creating a thread sets a memory barrier, so it is safe to access <code>o</code> via the reference you passed to <code>worker_thread</code>.</p>\n<p>\u00a7 30.3.2.2-6 - [thread.thread.constr]  </p>\n<blockquote>\n<p id=\"so_46032965_46033613_0\">The completion of the invocation of the constructor synchronizes with the beginning of the invocation of the copy of f.</p>\n</blockquote>\n<p>While <code>worker_thread</code> is running, obviously you may not access <code>o</code> in the thread that created it (as you said).  </p>\n<p>Joining a thread sets a barrier too, so after <code>worker_thread</code> has joined, you can access <code>o</code> again in your main thread.  </p>\n<p>\u00a7 30.3.2.5-4 - [thread.thread.destr]  </p>\n<blockquote>\n<p id=\"so_46032965_46033613_1\">The completion of the thread represented by *this synchronizes with (1.10) the corresponding successful join() return.  </p>\n</blockquote>\n<p>For further reading:  </p>\n<ul>\n<li>Anthony Williams wrote a good book on parallel programming (<em>C++ concurrency in action</em>)    </li>\n<li>Bjarne Stroustrup's book (<em>the C++ programming language</em>, 4th edition) has two nice chapters on concurrent programming.</li>\n<li>Jeff Preshing has a nice blog about many of these topics; check out preshing.com</li>\n</ul>\n", "OwnerUserId": "6651824", "LastEditorUserId": "6651824", "LastEditDate": "2017-09-04T09:32:05.433", "Id": "46033613", "Score": "18", "CreationDate": "2017-09-04T08:58:24.827", "LastActivityDate": "2017-09-04T09:32:05.433"}, "bq_ids": {"n4140": {"so_46032965_46033613_1": {"section_id": 2725, "quality": 0.8, "length": 8}, "so_46032965_46033613_0": {"section_id": 2711, "quality": 0.875, "length": 7}}, "n3337": {"so_46032965_46033613_1": {"section_id": 2686, "quality": 0.8, "length": 8}, "so_46032965_46033613_0": {"section_id": 2672, "quality": 0.875, "length": 7}}, "n4659": {"so_46032965_46033613_1": {"section_id": 3464, "quality": 0.8, "length": 8}, "so_46032965_46033613_0": {"section_id": 3451, "quality": 0.875, "length": 7}}}});