post_cb({"48160292": {"ViewCount": "354", "Body": "<p>suppose I have the following code.</p>\n<pre><code>std::string foo() {\n    std::string mystr(\"SOMELONGVALUE\");\n    return mystr;\n}\n\nint main() {\n    std::string result = foo();\n}\n</code></pre>\n<p>When I call 'foo', is the data in <code>mystr</code> copied or moved into <code>result</code>? I believe that it is moved C++11 style, but I was hoping for clarification and/or links to show that.</p>\n<p>Thanks! </p>\n<p>Edit: I suppose I want to know the answer to this question when compiling with g++ for c++11 or later.</p>\n", "Title": "In c++11, does returning a std::string in a function move or copy it?", "CreationDate": "2018-01-09T01:26:44.630", "LastActivityDate": "2018-01-09T07:47:18.907", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2018-01-09T01:30:12.283", "LastEditorUserId": "3754314", "Id": "48160292", "Score": "7", "OwnerUserId": "3754314", "Tags": "<c++><c++11>", "AnswerCount": "5"}, "48160596": {"Id": "48160596", "PostTypeId": "2", "Body": "<p>Like user4581301 said, I suspect copy elision to happen (not a move) in most implementations. For c++11 and c++14, the standard allows copy elision to happen but doesn't mandate it. In c++17, some instances of copy elision will become mandated. So, for c++11 and c++14, technically the answer depends on the implementation being used. In your case specifically, we're talking about a specific type of copy elision: return value optimization (RVO). To check whether RVO happens in your environment for your given case, you can run this code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo {\n  Foo() { std::cout &lt;&lt; \"Constructed\" &lt;&lt; std::endl; }\n\n  Foo(const Foo &amp;) { std::cout &lt;&lt; \"Copy-constructed\" &lt;&lt; std::endl; }\n\n  Foo(Foo &amp;&amp;) { std::cout &lt;&lt; \"Move-constructed\" &lt;&lt; std::endl; }\n\n  ~Foo() { std::cout &lt;&lt; \"Destructed\" &lt;&lt; std::endl; }\n};\n\nFoo foo() {\n    Foo mystr();\n    return mystr;\n}\n\nint main() {\n    Foo result = foo();\n}\n</code></pre>\n<p>My implementation opts for RVO - no move takes place.</p>\n", "LastActivityDate": "2018-01-09T02:16:45.737", "Score": "2", "CreationDate": "2018-01-09T02:16:45.737", "ParentId": "48160292", "CommentCount": "0", "OwnerUserId": "5191841"}, "48160493": {"Id": "48160493", "PostTypeId": "2", "Body": "<p>In my VS2015, the compiler does invoke move ctor when returning an temp variable in such a trivial case.</p>\n<pre><code>class A {\npublic:\n    A(int _x) :x(_x) {}\n    A(const A&amp; a) {\n        cout &lt;&lt; \"copy ctor.\" &lt;&lt; endl;\n        x = a.x;\n    }\n    A(A&amp;&amp; a) {\n        cout &lt;&lt; \"move ctor.\" &lt;&lt; endl;\n        x = 123;\n    }\n    private:\n        int x;\n    };\n\nA foo() {\n    A temp = { 7 };\n    return temp;         //invoke move ctor\n}\n\n\nint main() {\n    A a = foo();\n    return 0;\n}\n</code></pre>\n<p>Besieds, whether the compiler trigger RVO depends on the \nprice of copying, you can see the mechanism of RVO in below:\n<a href=\"https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=en\" rel=\"nofollow noreferrer\">https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=en</a></p>\n", "LastEditorUserId": "8489782", "LastActivityDate": "2018-01-09T02:20:34.267", "Score": "0", "CreationDate": "2018-01-09T02:00:40.587", "ParentId": "48160292", "CommentCount": "0", "OwnerUserId": "8489782", "LastEditDate": "2018-01-09T02:20:34.267"}, "48163186": {"Id": "48163186", "PostTypeId": "2", "Body": "<p>Your example fall on the so-called Named Return Value Optimization, which is defined in <a href=\"https://timsong-cpp.github.io/cppwp/n3337/class.copy#31.1\" rel=\"noreferrer\">this paragraph of the C++11 standard</a>. So the compiler may elide the <em>copy constructor</em> (or <em>move constructor</em> since C++14). This elision is not mandatory.</p>\n<p><em>In C++11</em>, if the compiler does not perform this elision, the returned string will be <em>copy constructed</em>. The returned object would be moved if it were naming a function parameter, <a href=\"https://timsong-cpp.github.io/cppwp/n3337/class.copy#32\" rel=\"noreferrer\">[class.copy]/32</a> (bold is mine):</p>\n<blockquote>\n<p id=\"so_48160292_48163186_0\">When the criteria for elision of a copy operation are met or would be met save for the fact that <strong>the source object is a function parameter</strong>, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for <strong>the copy is first performed as if the object were designated by an rvalue</strong>. [...]</p>\n</blockquote>\n<p>In C++14, this last rule has changed. It also includes the case of automatic variables <a href=\"https://timsong-cpp.github.io/cppwp/n4140/class.copy#32\" rel=\"noreferrer\">[class.copy]/32</a>:</p>\n<blockquote>\n<p id=\"so_48160292_48163186_1\">When the criteria for elision of a copy/move operation are met, but not for an exception-declaration, and the object to be copied is designated by an lvalue, or when the expression in a return statement is a (possibly parenthesized) id-expression that names <strong>an object with automatic storage duration</strong> declared in the body <strong>or parameter-declaration-clause</strong> of the innermost enclosing function or lambda-expression, overload resolution to select the constructor for <strong>the copy is first performed as if the object were designated by an rvalue</strong>. [...]</p>\n</blockquote>\n<p>So in your example code, and <em>in C++14</em>, if the compiler does not elide the copy/move construction, the returned string will be <em>move constructed</em>.</p>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2018-01-09T07:47:18.907", "Score": "5", "CreationDate": "2018-01-09T07:25:39.920", "ParentId": "48160292", "CommentCount": "0", "OwnerUserId": "5632316", "LastEditDate": "2018-01-09T07:47:18.907"}, "bq_ids": {"n4140": {"so_48160292_48163186_1": {"length": 41, "quality": 0.9761904761904762, "section_id": 481}, "so_48160292_48163186_0": {"length": 20, "quality": 0.6896551724137931, "section_id": 481}}, "n3337": {"so_48160292_48163186_0": {"length": 29, "quality": 1.0, "section_id": 472}}, "n4659": {"so_48160292_48163186_1": {"length": 30, "quality": 0.7142857142857143, "section_id": 504}, "so_48160292_48163186_0": {"length": 16, "quality": 0.5517241379310345, "section_id": 504}}}, "48160447": {"Id": "48160447", "PostTypeId": "2", "Body": "<p>The way the <em>most</em> compilers implement return of a class type is to pass an extra \"hidden\" argument to the function that is a pointer to the memory where the value being returned should be constructed.  So the called function can copy or move the return value into that memory as needed without regard to the call site.</p>\n<p>With your example code, such a compiler could even use that same memory to hold the <code>mystr</code> variable, constructing it directly there, and never using either the move or copy constructor of std::string.</p>\n", "LastActivityDate": "2018-01-09T01:51:09.343", "Score": "0", "CreationDate": "2018-01-09T01:51:09.343", "ParentId": "48160292", "CommentCount": "0", "OwnerUserId": "16406"}, "48160510": {"Id": "48160510", "PostTypeId": "2", "Body": "<p>Since <code>std::string result = foo();</code> is an initializer, it will call the constructor rather than the assignment operator.  In C++11 or newer, there is guaranteed to be a move constructor with prototype <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/basic_string\" rel=\"nofollow noreferrer\"><code>std::basic_string::basic_string( basic_string&amp;&amp; other ) noexcept</code></a>.  On every actually-existing implementation, this moves the contents rather than copying them.  Although I don\u2019t believe the standard mandates a particular implementation, it does say this particular operation must run in constant and not linear time, which precludes a deep copy.  As the return value of <code>foo()</code> is a temporary rvalue, that is the constructor that will be called in this snippet.</p>\n<p>So, yes, this code will move the string rather than copy it.</p>\n<p>The expression in a <code>return</code> statement will not always be copied, however.  If you <code>return std::string(\"SOMELONGVALUE\");</code> (a <em>programmatic constructor</em>), the implementation is permitted to construct the result in place instead.  If <code>foo()</code> returns a <code>std::string&amp;</code> and returns anything other than a temporary, that will be returned by reference.  (Returning a reference to a temporary that's been destroyed is, as you know, undefined behavior!)  And some compilers, even before C11, would perform <em>copy elision</em> and avoid creating a temporary only to copy and destroy it.  This is still permitted and your compiler might or might not apply it here.</p>\n", "LastEditorUserId": "4474419", "LastActivityDate": "2018-01-09T02:17:20.130", "Score": "0", "CreationDate": "2018-01-09T02:03:57.700", "ParentId": "48160292", "CommentCount": "2", "OwnerUserId": "4474419", "LastEditDate": "2018-01-09T02:17:20.130"}});