post_cb({"8865755": {"ParentId": "8864311", "LastEditDate": "2017-05-23T11:43:23.557", "CommentCount": "1", "CreationDate": "2012-01-14T22:11:09.633", "OwnerUserId": "167958", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "8865755", "Score": "2", "Body": "<p>This is meant as a supplement to <a href=\"https://stackoverflow.com/a/8864388/167958\">Ben Voigt's answer</a>', not a replacement.</p>\n<p>You might think that this is all just a technicality. That the standard calling it 'undefined' is just a bit of semantic twaddle that has no real-world effects beyond allowing compiler writers to do silly things for no good reason. But this is not the case.</p>\n<p>I could see desirable implementations in which:</p>\n<pre><code>Base *b = new Derived;\ndelete b;\n</code></pre>\n<p>Resulted in behavior that was quite bizarre. This is because storing the size of your allocated chunk of memory when it is known statically by the compiler is kind of silly. For example:</p>\n<pre><code>struct Base {\n};\n\nstruct Derived {\n   int an_int;\n};\n</code></pre>\n<p>In this case, when <code>delete Base</code> is called, the compiler has every reason (because of the rule you quoted at the beginning of your question) to believe that the size of the data pointed at is 1, not 4. If it, for example, implements a version of <code>operator new</code> that has a separate array in which 1 byte entities are all densely packed, and a different array in which 4 byte entities are all densely packed, it will end up assuming the <code>Base *</code> points to somewhere in the 1-byte entity array when in fact it points somewhere in the 4-byte entity array, and making all kinds of interesting errors for this reason.</p>\n<p>I really wish <code>operator delete</code> had been defined to also take a size, and the compiler passed in either the statically known size if <code>operator delete</code> was called on an object with a non-virtual destructor, or the known size of the actual object being pointed at if it were being called as a result of a <code>virtual</code> destructor. Though this would likely have other ill effects and maybe isn't such a good idea (like if there are cases in which <code>operator delete</code> is called without a destructor having been called). But it would make the problem painfully obvious.</p>\n", "LastActivityDate": "2012-01-15T20:54:00.293"}, "8864388": {"ParentId": "8864311", "LastEditDate": "2012-01-14T18:56:57.140", "CommentCount": "6", "CreationDate": "2012-01-14T18:31:07.610", "OwnerUserId": "103167", "LastEditorUserId": "103167", "PostTypeId": "2", "Id": "8864388", "Score": "14", "Body": "<p>You don't care about POD-ness, you care about <em>standard-layout</em>.  Here's the definition, from the standard section 9 <code>[class]</code>:</p>\n<blockquote>\n<p id=\"so_8864311_8864388_0\">A standard-layout class is a class that:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</li>\n<li>has no virtual functions (10.3) and no virtual base classes (10.1),</li>\n<li>has the same access control (Clause 11) for all non-static data members,</li>\n<li>has no non-standard-layout base classes,</li>\n<li>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and</li>\n<li>has no base classes of the same type as the first non-static data member.</li>\n</ul>\n</blockquote>\n<p>And the property you want is then guaranteed (section 9.2 <code>[class.mem]</code>):</p>\n<blockquote>\n<p id=\"so_8864311_8864388_1\">A pointer to a standard-layout struct object, suitably converted using a <code>reinterpret_cast</code>, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa.</p>\n</blockquote>\n<p>This is actually better than the old requirement, because the ability to <code>reinterpret_cast</code> isn't lost by adding non-trivial constructors and/or destructor.</p>\n<hr>\n<p>Now let's move to your second question.  The answer is not what you were hoping for.</p>\n<pre><code>Base *b = new Derived;\ndelete b;\n</code></pre>\n<p>is undefined behavior unless <code>Base</code> has a virtual destructor.  See section 5.3.5 (<code>[expr.delete]</code>)</p>\n<blockquote>\n<p id=\"so_8864311_8864388_2\">In the first alternative (delete object), if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<hr>\n<p>Your earlier snippet using <code>malloc</code> and <code>free</code> is mostly correct.  This will work:</p>\n<pre><code>Base *b = new (malloc(sizeof(Derived))) Derived;\nfree(b);\n</code></pre>\n<p>because the value of pointer <code>b</code> is the same as the address returned from placement new, which is in turn the same address returned from <code>malloc</code>.</p>\n</hr></hr>", "LastActivityDate": "2012-01-14T18:56:57.140"}, "8864497": {"ParentId": "8864311", "CommentCount": "5", "Body": "<p>There is lots of discussion on irrelevant issues above. Yes, mainly for C compatibility there are a number of guarantees you can rely as long as you know what you are doing. All this is, however, irrelevant to your main question. The main question is: Is there any situation where an object can be deleted using a pointer type which doesn't match the dynamic type of the object and where the pointed to type doesn't have a virtual destructor. The answer is: no, there is not.</p>\n<p>The logic for this can be derived from what the run-time system is supposed to do: it gets a pointer to an object and is asked to delete it. It would need to store information on how to call derived class destructors or about the amount of memory the object actually takes if this were to be defined. However, this would imply a possibly quite substantial cost in terms of used memory. For example, if the first member requires very strict alignment, e.g. to be aligned at an 8 byte boundary as is the case for <code>double</code>, adding a size would add an overhead of at least 8 bytes to allocate memory. Even though this might not sound too bad, it may mean that only one object instead of two or four fits into a cache line, reducing performance substantially.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "8864497", "Score": "0", "CreationDate": "2012-01-14T18:50:11.447", "LastActivityDate": "2012-01-14T18:50:11.447"}, "8864502": {"ParentId": "8864311", "LastEditDate": "2012-01-14T18:56:26.747", "CommentCount": "4", "CreationDate": "2012-01-14T18:50:53.910", "OwnerUserId": "179910", "LastEditorUserId": "179910", "PostTypeId": "2", "Id": "8864502", "Score": "2", "Body": "<p>Presumably your last bit of code is intended to say:</p>\n<pre><code>Base *b = new Derived;\ndelete b;  // delete b, not d.\n</code></pre>\n<p>In that case, the short answer is that it remains undefined behavior. The fact that the class or struct in question is POD, standard layout or trivially copyable doesn't really change anything.</p>\n<p>Yes, you're passing the right address, and yes, you and I know that in this case the dtor is pretty much a nop -- nonetheless, the pointer you're passing to <code>delete</code> has a different static type than dynamic type, and the static type does not have a virtual dtor. The standard is quite clear that this gives undefined behavior. </p>\n<p>From a practical viewpoint, you can probably get away with the UB if you really insist -- chances are pretty good that there won't be any harmful side effects from what you're doing, at least with most typical compilers. Beware, however, that even at best the code is extremely fragile so seemingly trivial changes could break everything -- and even switching to a compiler with really heavy type checking and such <em>could</em> do so as well.</p>\n<p>As far as your argument goes, the situation's pretty simple: it basically means the committee probably <em>could</em> make this defined behavior if they wanted to. As far as I know, however, it's never been proposed, and even if it had it would probably be a very low priority item -- it doesn't really add much, enable new styles of programming, etc.</p>\n", "LastActivityDate": "2012-01-14T18:56:26.747"}, "8864311": {"CommentCount": "4", "CreationDate": "2012-01-14T18:20:22.113", "PostTypeId": "1", "AcceptedAnswerId": "8864388", "LastEditorUserId": "146041", "LastActivityDate": "2012-01-15T20:54:00.293", "LastEditDate": "2012-01-15T02:36:16.820", "ViewCount": "2762", "FavoriteCount": "1", "Title": "PODs and inheritance in C++11. Does the address of the struct == address of the first member?", "Id": "8864311", "Score": "7", "Body": "<p>(I've edited this question to avoid distractions. There is one core question which would need to be cleared up before any other question would make sense. Apologies to anybody whose answer now seems less relevant.)</p>\n<p>Let's set up a specific example:</p>\n<pre><code>struct Base {\n    int i;\n};\n</code></pre>\n<p>There are no virtual method, and there is no inheritance, and is generally a very dumb and simple object. Hence it's <a href=\"http://en.wikipedia.org/wiki/C%2B%2B11#Modification_to_the_definition_of_plain_old_data\" rel=\"nofollow\">Plain Old Data (POD)</a> and it falls back on a predictable layout. In particular:</p>\n<pre><code>Base b;\n&amp;b == reinterpret_cast&lt;B*&gt;&amp;(b.i);\n</code></pre>\n<p>This is according to <a href=\"http://en.wikipedia.org/wiki/C%2B%2B_classes#Properties_shared_between_structs_in_C_and_POD-structs_in_C.2B.2B\" rel=\"nofollow\">Wikipedia</a> (which itself claims to reference the C++03 standard):</p>\n<blockquote>\n<p id=\"so_8864311_8864311_0\">A pointer to a POD-struct object, suitably converted using a reinterpret cast, points to its initial member and vice versa, implying that there is no padding at the beginning of a POD-struct.[8]</p>\n</blockquote>\n<p>Now let's consider inheritance:</p>\n<pre><code>struct Derived : public Base {\n};\n</code></pre>\n<p>Again, there are no virtual methods, no virtual inheritance, and no multiple inheritance. Therefore this is POD also.</p>\n<p>Question: Does this fact (Derived is POD in C++11) allow us to say that:</p>\n<pre><code>Derived d;\n&amp;d == reinterpret_cast&lt;D*&gt;&amp;(d.i); // true on g++-4.6\n</code></pre>\n<p></p>\n<p><em>If</em> this is true, then the following would be well-defined:</p>\n<pre><code>Base *b = reinterpret_cast&lt;Base*&gt;(malloc(sizeof(Derived)));\nfree(b); // It will be freeing the same address, so this is OK\n</code></pre>\n<p>I'm not asking about <code>new</code> and <code>delete</code> here - it's easier to consider <code>malloc</code> and <code>free</code>. I'm just curious about the regulations about the layout of derived objects in simple cases like this, and where the initial non-static member of the base class is in a predictable location.</p>\n<p>Is a Derived object supposed to be equivalent to:</p>\n<pre><code>struct Derived { // no inheritance\n    Base b; // it just contains it instead\n};\n</code></pre>\n<p>with no padding beforehand?</p>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "146041", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_8864311_8864388_2": {"section_id": 6107, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_8864311_8864388_1": {"section_id": 5650, "quality": 1.0, "length": 19}, "so_8864311_8864311_0": {"section_id": 5650, "quality": 0.6842105263157895, "length": 13}, "so_8864311_8864388_2": {"section_id": 5873, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_8864311_8864388_2": {"section_id": 7604, "quality": 0.9629629629629629, "length": 26}}}});