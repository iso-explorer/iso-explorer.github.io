post_cb({"32009085": {"CommentCount": "3", "ViewCount": "231", "PostTypeId": "1", "LastEditorUserId": "3953764", "CreationDate": "2015-08-14T11:34:50.717", "LastActivityDate": "2015-08-14T13:28:50.283", "Title": "Compare tuples of different sizes", "AcceptedAnswerId": "32009446", "LastEditDate": "2015-08-14T13:28:50.283", "Id": "32009085", "Score": "3", "Body": "<p>Why isn't it possible to compare two tuples of different size like this:</p>\n<pre><code>#include &lt;tuple&gt;\nint main() {\n  std::tuple&lt;int, int&gt; t1(1, 2);\n  std::tuple&lt;int&gt; t2(1);\n  if(std::tuple_size&lt;decltype(t1)&gt;::value == std::tuple_size&lt;decltype(t2)&gt;::value)\n    return (t1 == t2);\n  else\n    return 0;\n}\n</code></pre>\n<p>I know that <code>t1==t2</code> is not possible. But in this example it wouldn't be executed. Is there a possibility to compare tuples of different sizes?</p>\n", "Tags": "<c++><c++11><tuples>", "OwnerUserId": "5227093", "AnswerCount": "3"}, "32009398": {"ParentId": "32009085", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-08-14T11:50:47.017", "Score": "-1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:29:43.423", "Id": "32009398", "OwnerUserId": "4723732", "Body": "<p>You have problem with size mismatch. Read this, maybe it can help you.\n<a href=\"https://stackoverflow.com/questions/6218812/implementing-comparison-operators-via-tuple-and-tie-a-good-idea\">Implementing comparison operators via 'tuple' and 'tie', a good idea?</a></p>\n", "LastActivityDate": "2015-08-14T11:54:16.953"}, "32009660": {"ParentId": "32009085", "CommentCount": "0", "CreationDate": "2015-08-14T12:04:25.230", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "32009660", "Score": "1", "Body": "<p>You may write several overloads:</p>\n<pre><code>template&lt;typename ...Ts&gt;\nbool is_equal(const std::tuple&lt;Ts...&gt;&amp; lhs, const std::tuple&lt;Ts...&gt;&amp; rhs)\n{\n    return lhs == rhs;\n}\n\ntemplate&lt;typename ...Ts, typename... Us&gt;\nbool is_equal(const std::tuple&lt;Ts...&gt;&amp;, const std::tuple&lt;Us...&gt;&amp;)\n{\n    return false;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/WCiGSq\" rel=\"nofollow\">Live example</a></p>\n", "LastActivityDate": "2015-08-14T12:04:25.230"}, "bq_ids": {"n4140": {"so_32009085_32009446_0": {"section_id": 4092, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_32009085_32009446_0": {"section_id": 3939, "quality": 0.8, "length": 12}}, "n4659": {"so_32009085_32009446_0": {"section_id": 5000, "quality": 0.8666666666666667, "length": 13}}}, "32009446": {"ParentId": "32009085", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-08-14T11:53:57.190", "Score": "4", "LastEditorUserId": "3953764", "LastEditDate": "2015-08-14T11:59:09.960", "Id": "32009446", "OwnerUserId": "3953764", "Body": "<p><code>operator==</code> requires the tuples to be of equal lengths.</p>\n<p>\u00a7 20.4.2.7 [tuple.rel]:</p>\n<blockquote>\n<pre><code>template&lt;class... TTypes, class... UTypes&gt;\nconstexpr bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);\n</code></pre>\n<p id=\"so_32009085_32009446_0\"><sup>1</sup> <em>Requires</em>: For all <code>i</code>, where <code>0 &lt;= i</code> and <code>i &lt; sizeof...(TTypes)</code>, <code>get&lt;i&gt;(t) == get&lt;i&gt;(u)</code> is a valid expression returning a type that is convertible to <code>bool</code>. <code>sizeof...(TTypes) == sizeof...(UTypes)</code>.</p>\n</blockquote>\n<p>If you want two tuples of different lengths to be considered <em>unequal</em>, you'd need to implement this logic yourself:</p>\n<pre><code>template &lt;typename... Ts, typename... Us&gt;\nauto compare(const std::tuple&lt;Ts...&gt;&amp; t1, const std::tuple&lt;Us...&gt;&amp; t2)\n    -&gt; typename std::enable_if&lt;sizeof...(Ts) == sizeof...(Us), bool&gt;::type\n{\n    return t1 == t2;\n}\n\ntemplate &lt;typename... Ts, typename... Us&gt;\nauto compare(const std::tuple&lt;Ts...&gt;&amp; t1, const std::tuple&lt;Us...&gt;&amp; t2)\n    -&gt; typename std::enable_if&lt;sizeof...(Ts) != sizeof...(Us), bool&gt;::type\n{\n    return false;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/df99e90111a7f17a\" rel=\"nofollow\"><strong>DEMO</strong></a></p>\n<p>This way, the code comparing two tuples, <code>t1 == t2</code>, is instantiated only when the lengths of tuples match each other. In your scenario, a compiler is unable to compile your code, since there is no predefined <code>operator==</code> for such a case.</p>\n", "LastActivityDate": "2015-08-14T11:59:09.960"}});