post_cb({"24252692": {"ParentId": "24252464", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-06-16T21:40:29.397", "Score": "6", "LastEditorUserId": "1090079", "LastEditDate": "2014-06-16T21:58:39.733", "Id": "24252692", "OwnerUserId": "1090079", "Body": "<h3>Introduction</h3>\n<p>You are correct that the implementation abuses the <em>\"random memory location\"</em> of a block-scope <em>static</em> variable, but that doesn't mean that the guarantee you are talking about doesn't hold: the returned from <code>GetTypeId&lt;T&gt;</code> will be unique for each instantiation of it.</p>\n<blockquote>\n<p id=\"so_24252464_24252692_0\"><sup><strong>Note</strong>: One should however be aware of the fact that <code>uintptr_t</code> is <strong>not</strong> guaranteed to be available for every platform. A fully portable way to implement the function would be to return a <code>void*</code>, which is guaranteed to be able to hold every address of every object in a program.</sup></p>\n</blockquote>\n<hr>\n<h3>The distinct address guarantee...</h3>\n<p>In <em>C++</em> there's a guarantee that every object must reside at a unique address, unless we are talking about an object which is a subobject if another. In such case they may have the same address (and in cases the sharing of address is required, as with standard-layout classes and their first data-member).</p>\n<blockquote>\n<p id=\"so_24252464_24252692_1\"><code>1.8p6</code> <strong>The C++ object model</strong> <code>[intro.object]</code></p>\n<blockquote>\n<p id=\"so_24252464_24252692_3\">Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the first byte it occupies. Two objects that are not bit-fields may have the same address if one is a subobject of the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, <strong>they shall have distinct addresses</strong>.</p>\n</blockquote>\n</blockquote>\n<hr>\n<h3>Static variables in functions...</h3>\n<p>We also have an explicit clause saying that every specialization of a function-template that includes a <em>static</em> variable has its own unique copy of said static variable:</p>\n<blockquote>\n<p id=\"so_24252464_24252692_4\"><code>14.8p2</code> <strong>Function template specializations</strong> <code>[temp.fct.spec]</code></p>\n<blockquote>\n<p id=\"so_24252464_24252692_6\">Each function template specialization instantiated from a template has its own copy of any static variable.</p>\n</blockquote>\n</blockquote>\n<p>Since a variable that is declared <em>static</em> is unique to every instantiation of <code>GetTypeId&lt;T&gt;</code>, where <code>T</code> is an arbitrary type, every object named <code>placeHolder</code> in this template specialization must an unique object.</p>\n<p>It must be an unique object, and with that; it must have a distinct address.</p>\n<hr>\n<blockquote>\n<p id=\"so_24252464_24252692_7\"><sup> <strong>Note 1)</strong> In <em>C++11</em> we have <a href=\"http://en.cppreference.com/w/cpp/types/type_index\" rel=\"nofollow\"><code>std::type_index</code></a> which fulfils the guarantee you are after.<br/> <strong>Note 2)</strong> The <em>C++11</em> standard draft <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">n3337</a> has been used as a reference in this post.</sup></p>\n</blockquote>\n</hr></hr></hr>", "LastActivityDate": "2014-06-16T21:58:39.733"}, "bq_ids": {"n4140": {"so_24252464_24252692_5": {"section_id": 283, "quality": 1.0, "length": 11}, "so_24252464_24252692_6": {"section_id": 283, "quality": 1.0, "length": 11}, "so_24252464_24252692_3": {"section_id": 5795, "quality": 0.9743589743589743, "length": 38}, "so_24252464_24252692_2": {"section_id": 5795, "quality": 0.9743589743589743, "length": 38}}, "n3337": {"so_24252464_24252692_5": {"section_id": 274, "quality": 1.0, "length": 11}, "so_24252464_24252692_6": {"section_id": 274, "quality": 1.0, "length": 11}, "so_24252464_24252692_3": {"section_id": 5568, "quality": 0.9743589743589743, "length": 38}, "so_24252464_24252692_2": {"section_id": 5568, "quality": 0.9743589743589743, "length": 38}}, "n4659": {"so_24252464_24252692_2": {"section_id": 7254, "quality": 0.9487179487179487, "length": 37}, "so_24252464_24252692_6": {"section_id": 290, "quality": 1.0, "length": 11}, "so_24252464_24252692_3": {"section_id": 7254, "quality": 0.9487179487179487, "length": 37}, "so_24252464_24252692_5": {"section_id": 290, "quality": 1.0, "length": 11}}}, "24252464": {"CommentCount": "4", "ViewCount": "664", "PostTypeId": "1", "LastEditorUserId": "1090079", "CreationDate": "2014-06-16T21:24:22.413", "LastActivityDate": "2014-06-16T21:58:39.733", "Title": "Creation of unique type ID with c++11", "AcceptedAnswerId": "24252692", "LastEditDate": "2014-06-16T21:41:02.317", "Id": "24252464", "Score": "5", "Body": "<p>Why is the following code guaranteed to be a unique typeID ?!</p>\n<pre><code>using TypeId = uintptr_t; \n\ntemplate &lt; typename T &gt;\nstatic TypeId GetTypeId()\n{\n   static uint32_t placeHolder;\n   return (reinterpret_cast&lt;TypeId&gt;(&amp;placeHolder));\n} \n</code></pre>\n<p><a href=\"http://www.codeproject.com/Articles/723656/SW-Message-Bus\" rel=\"noreferrer\">Source</a></p>\n<p>I don't understand why this is not just a kind of random memory location as a kind of \"misused\"... Thanks for answers in advance.</p>\n", "Tags": "<c++><c++11><language-lawyer><unique-id>", "OwnerUserId": "2007358", "AnswerCount": "1"}});