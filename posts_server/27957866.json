post_cb({"27957866": {"CreationDate": "2015-01-15T06:27:39.277", "ViewCount": "131", "Id": "27957866", "Score": "2", "Title": "What does the definition(body) of an inherited constructor look like?", "LastEditorUserId": "-1", "CommentCount": "0", "Body": "<p>From my reading of answers on SO and the <a href=\"http://en.cppreference.com/w/cpp/language/using_declaration\" rel=\"nofollow noreferrer\">cppreference link</a> </p>\n<blockquote>\n<p id=\"so_27957866_27957866_0\">The inherited constructors are equivalent to user-defined constructors with an empty body and with a member initializer list consisting of a single <em>nested-name-specifier</em>, which forwards all of its arguments to the base class constructor.</p>\n</blockquote>\n<p>I had concluded  that the below classes <code>D</code> and <code>E</code> should behave indentically.</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass B\n{\npublic:\n  B(string&amp;&amp; a) : a(move(a))\n  {\n  }\n\n  string a;\n};\n\nclass D : public B\n{\npublic:\n  using B::B;\n};\n\nclass E : public B\n{\npublic:\n  E(string&amp;&amp; a) : B(a)\n  {\n  }\n};\n\nstring foo()\n{\n  return \"bar\";\n}\n\nint main()\n{\n  D d = foo();//This compiles\n  E e = foo();//This does not compile\n  return 0;\n}\n</code></pre>\n<p><code>E e = foo()</code> rightly fails to compile, since <code>B</code>'s constructor only accepts a <code>string&amp;&amp;</code>. However, <code>D d = foo()</code> goes through fine. Why is that?\nThe compiler used is clang3.5.</p>\n<p>EDIT: Also, as explained in this <a href=\"https://stackoverflow.com/a/4129077/862351\">answer</a>, the perfect forwarding idiom isn't a replacement for inheriting constructors. So, what does the body look like exactly?</p>\n", "Tags": "<c++><c++11><inheriting-constructors>", "LastEditDate": "2017-05-23T10:33:19.200", "LastActivityDate": "2015-01-15T09:14:59.190", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "862351"}, "bq_ids": {"n4140": {"so_27957866_27958350_0": {"length": 48, "quality": 0.96, "section_id": 489}}, "n3337": {"so_27957866_27958350_0": {"length": 48, "quality": 0.96, "section_id": 480}}}, "27958056": {"CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_27957866_27958056_0\">However, D d = foo() goes through fine. Why is that?</p>\n</blockquote>\n<p>Because <code>using B::B</code> effectively passes the temporary string straight to <code>B</code>'s constructor, where it can still be bound ala <code>&amp;&amp;</code> (i.e. its <em>value category</em> is still <em>xvalue</em>), then does any extra derived-class initialisation (if there were other data members, a VDT etc).  That's highly desirable as the point of using the base class constructors is to allow the same client usage.</p>\n<p>(That contrasts with <code>E(string&amp;&amp;)</code>, inside which where the named <code>a</code> parameter is no longer considered a xvalue (expiring temporary) ripe for passing to <code>B::B</code>.)</p>\n<p>(If you haven't already, you might want to have a look at (<code>std::forward</code>)[<a href=\"http://en.cppreference.com/w/cpp/utility/forward]\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/utility/forward]</a> too... it helps with perfect forwarding of arguments)</p>\n", "CreationDate": "2015-01-15T06:45:07.780", "ParentId": "27957866", "Id": "27958056", "LastActivityDate": "2015-01-15T06:45:07.780", "PostTypeId": "2", "Score": "2", "OwnerUserId": "410767"}, "27958350": {"LastActivityDate": "2015-01-15T07:16:28.910", "CommentCount": "2", "Body": "<p>The wording from the standard about what the inherited constructor definition in the derived class looks like is a bit more explicit than what the cppreference description alludes to, but the key phrase in the latter is <strong><em>forwards all of its arguments</em></strong>. In other words, the value category of the arguments is preserved, which your definition of <code>E</code> doesn't do, and consequently fails to compile.</p>\n<p>From N3337, <em>\u00a712.9/8</em> <strong>[class.inhctor]</strong></p>\n<blockquote>\n<p id=\"so_27957866_27958350_0\"><code>...</code> An implicitly-defined inheriting constructor performs the set of initializations of the class that would be performed by a user-written inline constructor for that class with a <em>mem-initializer-list</em> whose only <em>mem-initializer</em> has a <em>mem-initializer-id</em> that names the base class denoted in the <em>nested-name-specifier</em> of the <em>using-declaration</em> and an <em>expression-list</em> as specified below, and where the compound-statement in its function body is empty (12.6.2). If that user-written constructor would be ill-formed, the program is ill-formed. <strong>Each expression in the <em>expression-list</em> is of the form <code>static_cast&lt;T&amp;&amp;&gt;(p)</code>, where <code>p</code> is the name of the corresponding constructor parameter and <code>T</code> is the declared type of <code>p</code>.</strong></p>\n</blockquote>\n<p>So the constructor arguments are being perfectly forwarded to the corresponding inherited constructor (<code>std::forward</code> (<em>\u00a720.2.3</em>) is specified to return <code>static_cast&lt;T&amp;&amp;&gt;(p)</code>, exactly the same as the description above). Depending on the declared type of the constructor parameter, reference collapsing occurs as described in <a href=\"https://stackoverflow.com/a/8527373/241631\">this answer</a>. </p>\n<p>In your case, <code>[T=string&amp;&amp;]</code> and the cast yields <code>string&amp;&amp;</code> again, which can bind to <code>B</code>'s parameter. To match that behavior in <code>E</code> you should rewrite the constructor as</p>\n<pre><code>E(string&amp;&amp; a) : B(static_cast&lt;string&amp;&amp;&gt;(a))\n{\n}\n</code></pre>\n", "CreationDate": "2015-01-15T07:10:30.853", "LastEditDate": "2017-05-23T12:10:53.650", "ParentId": "27957866", "Id": "27958350", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "2", "OwnerUserId": "241631"}});