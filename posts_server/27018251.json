post_cb({"bq_ids": {"n4140": {"so_27018251_27018334_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 3260}, "so_27018251_27018334_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3260}, "so_27018251_27018334_2": {"length": 15, "quality": 0.8333333333333334, "section_id": 3260}}, "n3337": {"so_27018251_27018334_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 3132}, "so_27018251_27018334_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3132}, "so_27018251_27018334_2": {"length": 15, "quality": 0.8333333333333334, "section_id": 3132}}, "n4659": {"so_27018251_27018334_0": {"length": 20, "quality": 0.5882352941176471, "section_id": 4018}, "so_27018251_27018334_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 4018}, "so_27018251_27018334_2": {"length": 15, "quality": 0.8333333333333334, "section_id": 4018}}}, "27018333": {"Id": "27018333", "PostTypeId": "2", "Body": "<p>Default arguments aren't evaluated at compile time. They're evaluated each time a function call requires them. They can be any expression that's valid in the context of the function declaration and has a suitable type, except that it can't use any other parameters (including <code>this</code>, in the case of a member function).</p>\n<p>That restriction is because the evaluation order isn't specified, so there's no way to ensure a parameter value is available if it were needed to evaluate another argument.</p>\n", "LastActivityDate": "2014-11-19T13:42:27.740", "CommentCount": "0", "CreationDate": "2014-11-19T13:42:27.740", "ParentId": "27018251", "Score": "7", "OwnerUserId": "204847"}, "27018251": {"ViewCount": "162", "Body": "<p>I've found <a href=\"http://www.mycppquiz.com/question.php?qid=60\">this</a> question, and I'm completely baffled.</p>\n<p>The answer says <code>b</code> is invalid, \"Non-static members can not be used as default arguments.\". That makes perfect sense.</p>\n<p>What I don't understand is why the other two are okay. In fact, I'm struggling to understand what the semantics are if the default is not a constant expression...</p>\n<p>What's going on here? Default parameters are clearly evaluated at compile time. Does the compiler simply pick the current value?</p>\n<pre><code>#include &lt;iostream&gt;\n\nint g_x = 44; \n\nstruct Foo \n{ \n  int m_x; \n  static int s_x; \n\n  Foo(int x) : m_x(x) {} \n  int a(int x = g_x) { return x + 1; } \n  int b(int x = m_x) { return x + 1; }\n  int c(int x = s_x) { return x + 1; }\n}; \n\nint Foo::s_x = 22; \n\nint main(int argc, char** argv) \n{ \n  Foo f(6); \n\n  std::cout &lt;&lt; f.a() &lt;&lt; std::endl; \n  std::cout &lt;&lt; f.b() &lt;&lt; std::endl; \n  std::cout &lt;&lt; f.c() &lt;&lt; std::endl; \n\n  return 0; \n}\n</code></pre>\n", "AcceptedAnswerId": "27018334", "Title": "Why are these default arguments allowed?", "CreationDate": "2014-11-19T13:37:25.307", "Id": "27018251", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2014-11-22T18:43:48.717", "Score": "5", "OwnerUserId": "650405", "Tags": "<c++><default-arguments>", "AnswerCount": "3"}, "27018334": {"Id": "27018334", "PostTypeId": "2", "Body": "<p>Actually, default arguments are evaluated when the function is called, which is why this is okay. From the <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>8.3.6</code> <em>Default arguments</em> which says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_27018251_27018334_0\"><strong>Default arguments are evaluated each time the function is called</strong>. The order of evaluation of function arguments is unspecified.\n  Consequently, parameters of a function shall not be used in a default\n  argument, even if they are not evaluated. Parameters of a function\n  declared before a default argument are in scope and can hide namespace\n  and class member names.</p>\n</blockquote>\n<p>The following example from the same section gives us a rationale for why we can use static members but not non-static ones:</p>\n<blockquote>\n<p id=\"so_27018251_27018334_1\">[ Example: the declaration of X::mem1() in the following example is\n  ill-formed because no object is supplied for the non-static member\n  X::a used as an initializer.</p>\n<pre><code>int b;\nclass X {\n    int a;\n    int mem1(int i = a); // error: non-static member a\n                         // used as default argument\n    int mem2(int i = b); // OK; use X::b\n    static int b;\n};\n</code></pre>\n<p id=\"so_27018251_27018334_2\"><strong>The declaration of X::mem2() is meaningful, however, since no object\n  is needed to access the static member X::b.</strong> Classes, objects, and\n  members are described in Clause 9. \u2014end example ] </p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-11-22T18:43:48.717", "Score": "8", "CreationDate": "2014-11-19T13:42:38.623", "ParentId": "27018251", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-11-22T18:43:48.717"}, "27018504": {"Id": "27018504", "PostTypeId": "2", "Body": "<p>I think this is understandable:\ng_x and s_x are available at compile time but this (and therefore this-&gt;m_x) is not.\nYou can use a trick to use m_x:</p>\n<pre><code>int b(int x = -1) { return x == -1 ? m_x + 1 : x + 1; }\n</code></pre>\n<p>(Of course -1 should be illegal input in this case.)</p>\n", "LastActivityDate": "2014-11-19T13:49:56.373", "CommentCount": "2", "CreationDate": "2014-11-19T13:49:56.373", "ParentId": "27018251", "Score": "0", "OwnerUserId": "3899184"}});