post_cb({"41212992": {"ParentId": "41212740", "CommentCount": "3", "Body": "<p>Yes, it's a standard <em>C++</em> which is described in the <em>8.5 Initializers</em>.</p>\n<p>It's called a <em>brace elision</em> and can be applied in the case of aggregate initialization.</p>\n<p>From the <em>n4296</em>, <em>8.5.1.12 Aggregates</em>:</p>\n<blockquote>\n<p id=\"so_41212740_41212992_0\">Braces can be elided in an initializer-list as follows. If the\n  initializer-list begins with a left brace, then the succeeding\n  comma-separated list of initializer-clauses initializes the members of\n  a subaggregate; it is erroneous for there to be more\n  initializer-clauses than members. If, however, the initializer-list\n  for a subaggregate does not begin with a left brace, then only\n  enough initializer-clauses from the list are taken to initialize the\n  members of the subaggregate; any remaining initializer-clauses are\n  left to initialize the next member of the aggregate of which the\n  current subaggregate is a member.</p>\n</blockquote>\n<p>Here is another example from the <em>8.5.1.13</em>:</p>\n<pre><code>struct A {\n    int i;\n    operator int();\n};\n\nstruct B {\n    A a1, a2;\n    int z;\n};\n\nA a;\nB b = { 4, a, a };\n</code></pre>\n<p>In this example <em>a1</em> is initialized with <em>4</em>, <em>a2</em> is initialized with <em>a</em> and <em>z</em> is initialized with the result of <em>operator int()</em> for <em>a</em>.</p>\n", "OwnerUserId": "5507349", "PostTypeId": "2", "Id": "41212992", "Score": "1", "CreationDate": "2016-12-18T21:19:10.310", "LastActivityDate": "2016-12-18T21:19:10.310"}, "41212807": {"ParentId": "41212740", "CommentCount": "1", "Body": "<p>Yes, this is standard C++. In aggregate initialization (and <em>only</em> in aggregate initialization, not in other forms of list-initialization), braces can be elided, effectively flattening the containment hierarchy of an aggregate.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "41212807", "Score": "3", "CreationDate": "2016-12-18T20:56:51.333", "LastActivityDate": "2016-12-18T20:56:51.333"}, "41212740": {"CommentCount": "2", "ViewCount": "256", "PostTypeId": "1", "LastEditorUserId": "734069", "CreationDate": "2016-12-18T20:49:54.190", "LastActivityDate": "2016-12-18T21:19:10.310", "Title": "C++: flat initializer list for nested struct?", "AcceptedAnswerId": "41212807", "LastEditDate": "2016-12-18T20:54:40.663", "Id": "41212740", "Score": "4", "Body": "<p>Having defined</p>\n<pre><code>struct A {\n  int a,b;\n};\n\nstruct B {\n  A a;\n  int b;\n};\n</code></pre>\n<p>the following initializations are obvious:</p>\n<pre><code>B b1 = { { 1 } };    // initializes b1.a.a\nB b2 = { { 1, 2 } }; // initializes b1.a.a, b1.a.b\nB b3 = { { 1 }, 2 }; // initializes b1.a.a, b1.b\n</code></pre>\n<p>But I am suprised that VC++ 2013 also allows these initializations without any warning:</p>\n<pre><code>B b4 = { 1 };       // initializes b4.a.a\nB b5 = { 1, 2 };    // initializes b5.a.a, b5.a.b\nB b6 = { 1, 2, 3 }; // initializes b6.a.a, b6.a.b, b6.b\n</code></pre>\n<p>Are flat initializer lists for nested structures/classes standard C++?</p>\n", "Tags": "<c++><c++11><visual-c++><visual-studio-2013>", "OwnerUserId": "1725562", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_41212740_41212992_0": {"section_id": 3308, "quality": 1.0, "length": 48}}, "n3337": {"so_41212740_41212992_0": {"section_id": 3178, "quality": 0.9791666666666666, "length": 47}}, "n4659": {"so_41212740_41212992_0": {"section_id": 4074, "quality": 0.8958333333333334, "length": 43}}}});