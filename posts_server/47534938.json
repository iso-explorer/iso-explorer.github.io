post_cb({"bq_ids": {"n4140": {"so_47534938_47637824_1": {"length": 11, "quality": 0.5789473684210527, "section_id": 635}, "so_47534938_47648516_12": {"length": 7, "quality": 0.875, "section_id": 609}, "so_47534938_47648516_2": {"length": 20, "quality": 1.0, "section_id": 599}, "so_47534938_47648516_11": {"length": 5, "quality": 1.0, "section_id": 609}, "so_47534938_47648516_4": {"length": 4, "quality": 1.0, "section_id": 635}, "so_47534938_47648516_0": {"length": 12, "quality": 0.5714285714285714, "section_id": 599}, "so_47534938_47648516_3": {"length": 6, "quality": 1.0, "section_id": 599}, "so_47534938_47648516_10": {"length": 6, "quality": 1.0, "section_id": 609}, "so_47534938_47648516_7": {"length": 9, "quality": 1.0, "section_id": 636}, "so_47534938_47648516_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 599}, "so_47534938_47648516_14": {"length": 15, "quality": 0.7894736842105263, "section_id": 609}, "so_47534938_47648516_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 635}}, "n3337": {"so_47534938_47648516_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 589}, "so_47534938_47648516_12": {"length": 7, "quality": 0.875, "section_id": 599}, "so_47534938_47648516_2": {"length": 20, "quality": 1.0, "section_id": 589}, "so_47534938_47648516_14": {"length": 11, "quality": 0.5789473684210527, "section_id": 599}, "so_47534938_47648516_4": {"length": 4, "quality": 1.0, "section_id": 625}, "so_47534938_47648516_11": {"length": 5, "quality": 1.0, "section_id": 599}, "so_47534938_47648516_3": {"length": 6, "quality": 1.0, "section_id": 589}, "so_47534938_47648516_0": {"length": 12, "quality": 0.5714285714285714, "section_id": 589}, "so_47534938_47648516_10": {"length": 6, "quality": 1.0, "section_id": 629}, "so_47534938_47648516_7": {"length": 9, "quality": 1.0, "section_id": 626}, "so_47534938_47637824_1": {"length": 11, "quality": 0.5789473684210527, "section_id": 625}, "so_47534938_47648516_5": {"length": 6, "quality": 0.8571428571428571, "section_id": 625}}, "n4659": {"so_47534938_47648516_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 622}, "so_47534938_47648516_12": {"length": 7, "quality": 0.875, "section_id": 635}, "so_47534938_47648516_2": {"length": 20, "quality": 1.0, "section_id": 622}, "so_47534938_47648516_14": {"length": 18, "quality": 0.9473684210526315, "section_id": 635}, "so_47534938_47648516_4": {"length": 4, "quality": 1.0, "section_id": 660}, "so_47534938_47648516_11": {"length": 5, "quality": 1.0, "section_id": 586}, "so_47534938_47648516_3": {"length": 6, "quality": 1.0, "section_id": 622}, "so_47534938_47648516_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 622}, "so_47534938_47648516_10": {"length": 6, "quality": 1.0, "section_id": 635}, "so_47534938_47648516_7": {"length": 9, "quality": 1.0, "section_id": 664}, "so_47534938_47637824_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 657}, "so_47534938_47648516_5": {"length": 7, "quality": 1.0, "section_id": 635}}}, "47631411": {"Id": "47631411", "PostTypeId": "2", "Body": "<p><sup><sub>(Edited, thanks @dyp)</sub></sup></p>\n<p>Here's a partial answer and speculative, explaining how I've gone about interpreting what happens, not being a compilation expert and not much of a C++ Guru.</p>\n<p>First I'll go with some intuition and common sense. Obviously the last thing to happen is a <code>B::B(A)</code>, since that's the only constructor available for B b1 (apparently it can't be a <code>B::B(B&amp;&amp;)</code> because there's at least one copy constructor defined, so <code>B::B(B&amp;&amp;)</code> is not implicitly defined for us). Also, the first construction of an A or a B to happen can't be an <code>A::A(const char*)</code> because that one's explicit, so there must be some use of <code>A::A(std::string)</code>. Also, the innermost quoted text is a <code>const char[5]</code>. So I'll guess the first, innermost, construction is a <code>const char*</code>; and then a string construction: <code>std::string::string(const char *)</code>. There's one more curly-bracket construction, and I would guess it's <code>A::A(A&amp;&amp;)</code> (or maybe <code>A::A(A&amp;)</code>?). So, to summarize my intuitive guess, the order of constructions should be:</p>\n<ol>\n<li>A <code>const char*</code></li>\n<li>An <code>std::string</code> (which is really <code>std::basic_string&lt;whatever&gt;</code>)</li>\n<li>an A</li>\n<li>a B</li>\n</ol>\n<p>Then I put this on <a href=\"https://godbolt.org/g/oYoHVZ\" rel=\"nofollow noreferrer\">GodBolt</a>, with GCC as the first example. (Alternatively, you could just compile it yourself while keeping the assembly language output, and pass that through <code>c++filt</code> to make it more readable). Here are all the lines specifically mentioning C++ code:</p>\n<pre><code>call   4006a0 &lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string(char const*, std::allocator&lt;char&gt; const&amp;)@plt&gt;\ncall   400858 &lt;A::A(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;)&gt;\ncall   400868 &lt;B::B(A)&gt;\ncall   400680 &lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::~basic_string()@plt&gt;\ncall   400690 &lt;std::allocator&lt;char&gt;::~allocator()@plt&gt;\ncall   400690 &lt;std::allocator&lt;char&gt;::~allocator()@plt&gt;\n</code></pre>\n<p>So it seems the order of proper actionable constructions we see is:</p>\n<p>(not seeing 1.)\n2. <code>std::basic_string::basic_string(const char* /* ignoring the allocator */)</code>\n3. <code>A::A(std::string)</code>\n4. <code>B::B(A)</code></p>\n<p>With clang 5.0.0, results are similar IIANM, and as for MSVC - who knows? Maybe it's a bug? They have been known to be a bit dodgy sometimes on properly supporting the language standard all the way. Sorry, like I said - partial answer.</p>\n", "LastEditorUserId": "1593077", "LastActivityDate": "2017-12-04T17:07:00.697", "Score": "0", "CreationDate": "2017-12-04T10:38:00.837", "ParentId": "47534938", "CommentCount": "6", "OwnerUserId": "1593077", "LastEditDate": "2017-12-04T17:07:00.697"}, "47534938": {"ViewCount": "416", "Body": "<p>The following code successfully compiles with most modern C++11 compatible compilers (GCC &gt;= 5.x, Clang, ICC, MSVC).</p>\n<pre><code>#include &lt;string&gt;\n\nstruct A\n{\n        explicit A(const char *) {}\n        A(std::string) {}\n};\n\nstruct B\n{\n        B(A) {}\n        B(B &amp;) = delete;\n};\n\nint main( void )\n{\n        B b1({{{\"test\"}}});\n}\n</code></pre>\n<p>But why does it compile in the first place, and how are the listed compilers interpreting that code?</p>\n<p>Why is MSVC able to compile this without <code>B(B &amp;) = delete;</code>, but the other 3 compilers all need it?</p>\n<p>And why does it fail in all compilers except MSVC when I delete a <strong><em>different signature</em></strong> of the copy constructor, e.g. <code>B(const B &amp;) = delete;</code>?</p>\n<p>Are the compilers even all choosing the same constructors?</p>\n<p>Why does Clang emit the following warning?</p>\n<pre><code>17 : &lt;source&gt;:17:16: warning: braces around scalar initializer [-Wbraced-scalar-init]\n        B b1({{{\"test\"}}});\n</code></pre>\n", "AcceptedAnswerId": "47648516", "Title": "Explicit constructors and nested initializer lists", "CreationDate": "2017-11-28T15:16:43.333", "LastActivityDate": "2017-12-07T20:48:10.637", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-11-28T18:43:16.277", "LastEditorUserId": "4672588", "Id": "47534938", "Score": "10", "OwnerUserId": "2879325", "Tags": "<c++><c++11><overload-resolution><list-initialization>", "AnswerCount": "3"}, "47637824": {"Id": "47637824", "PostTypeId": "2", "Body": "<p><code>B b1({{{\"test\"}}});</code> is like <code>B b1(A{std::string{const char*[1]{\"test\"}}});</code></p>\n<blockquote>\n<p id=\"so_47534938_47637824_0\">16.3.3.1.5 List-initialization sequence <a href=\"http://eel.is/c++draft/over.ics.list#4\" rel=\"nofollow noreferrer\">[over.ics.list]</a></p>\n<p id=\"so_47534938_47637824_1\"><a href=\"http://eel.is/c++draft/over.ics.list#4\" rel=\"nofollow noreferrer\">4</a> Otherwise, if the parameter type is a character array 133 and the initializer list has a single element that is an appropriately-typed string literal (11.6.2), the implicit conversion sequence is the identity conversion. </p>\n</blockquote>\n<p>And the compiler tries all possible implicit conversions. For example if we have class C with the following constructors:</p>\n<pre><code>#include &lt;string&gt;\n\nstruct C\n{\n    template&lt;typename T, size_t N&gt;     C(const T* (&amp;&amp;) [N]) {}\n    template&lt;typename T, size_t N&gt;     C(const T  (&amp;&amp;) [N]) {}\n    template&lt;typename T=char&gt;         C(const T* (&amp;&amp;)) {}\n    template&lt;typename T=char&gt;          C(std::initializer_list&lt;char&gt;&amp;&amp;) {}\n};\n\nstruct A\n{\n    explicit A(const char *) {}\n\n    A(C ) {}\n};\n\nstruct B\n{\n    B(A) {}\n    B(B &amp;) = delete;\n};\n\nint main( void )\n{\n    const char* p{\"test\"};\n    const char p2[5]{\"test\"};\n\n    B b1({{{\"test\"}}});\n}\n</code></pre>\n<p>The clang 5.0.0 compiler could not decide which to use and fails with:</p>\n<pre><code>29 : &lt;source&gt;:29:11: error: call to constructor of 'C' is ambiguous\n    B b1({{{\"test\"}}});\n          ^~~~~~~~~~\n5 : &lt;source&gt;:5:40: note: candidate constructor [with T = char, N = 1]\n    template&lt;typename T, size_t N&gt;     C(const T* (&amp;&amp;) [N]) {}\n                                       ^\n6 : &lt;source&gt;:6:40: note: candidate constructor [with T = const char *, N = 1]\n    template&lt;typename T, size_t N&gt;     C(const T  (&amp;&amp;) [N]) {}\n                                       ^\n7 : &lt;source&gt;:7:39: note: candidate constructor [with T = char]\n    template&lt;typename T=char&gt;         C(const T* (&amp;&amp;)) {}\n                                      ^\n15 : &lt;source&gt;:15:9: note: passing argument to parameter here\n    A(C ) {}\n        ^\n</code></pre>\n<p>But if we leave only one of the non-initializer-list constructors the code compiles fine.</p>\n<p>GCC 7.2 just picks the  <code>C(const T* (&amp;&amp;)) {}</code> and compiles. If it's not available it takes <code>C(const T* (&amp;&amp;) [N])</code>.</p>\n<p>MSVC just fails with:</p>\n<pre><code>29 : &lt;source&gt;(29): error C2664: 'B::B(B &amp;)': cannot convert argument 1 from 'initializer list' to 'A'\n</code></pre>\n", "LastEditorUserId": "8918119", "LastActivityDate": "2017-12-07T20:48:10.637", "Score": "1", "CreationDate": "2017-12-04T16:30:12.080", "ParentId": "47534938", "CommentCount": "1", "OwnerUserId": "8918119", "LastEditDate": "2017-12-07T20:48:10.637"}, "47648516": {"Id": "47648516", "PostTypeId": "2", "Body": "<p>Instead of explaining the behavior of compilers, I'll try to explain what the standard says. </p>\n<h1>Primary Example</h1>\n<p>To direct-initialize <code>b1</code> from <code>{{{\"test\"}}}</code>, overload resolution applies to choose the best constructor of <code>B</code>. Because there is no implicit conversion from <code>{{{\"test\"}}}</code> to <code>B&amp;</code> (list initializer is not a lvalue), the constructor <code>B(B&amp;)</code> is not viable. We then focus on the constructor <code>B(A)</code>, and check whether it is viable.</p>\n<p>To determine the implicit conversion sequence from <code>{{{\"test\"}}}</code> to <code>A</code> (I will use the notation <code>{{{\"test\"}}}</code> -&gt; <code>A</code> for simplicity), overload resolution applies to choose the best constructor of <code>A</code>, so we need to compare <code>{{\"test\"}}</code> -&gt; <code>const char*</code> and <code>{{\"test\"}}</code> -&gt; <code>std::string</code> (note the outermost layer of braces is elided) according to <a href=\"http://www.eel.is/c++draft/over.match.list#1\" rel=\"noreferrer\">[over.match.list]/1</a>:</p>\n<blockquote>\n<p id=\"so_47534938_47648516_0\">When objects of non-aggregate class type T are list-initialized such that [dcl.init.list] specifies that overload resolution is performed according to the rules in this subclause, overload resolution selects the constructor in two phases:</p>\n<ul>\n<li><p id=\"so_47534938_47648516_1\">Initially, the candidate functions are the initializer-list constructors ([dcl.init.list]) of the class T...</p></li>\n<li><p id=\"so_47534938_47648516_2\">If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class T and the argument list consists of the elements of the initializer list.</p></li>\n</ul>\n<p id=\"so_47534938_47648516_3\">... In copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed.</p>\n</blockquote>\n<p>Note all constructors are considered here regardless of the specifier <code>explicit</code>. </p>\n<p><code>{{\"test\"}}</code> -&gt; <code>const char*</code> does not exist according to <a href=\"http://www.eel.is/c++draft/over.ics.list#10\" rel=\"noreferrer\">[over.ics.list]/10</a> and <a href=\"http://www.eel.is/c++draft/over.ics.list#11\" rel=\"noreferrer\">[over.ics.list]/11</a>:</p>\n<blockquote>\n<p id=\"so_47534938_47648516_4\">Otherwise, if the parameter type is not a class:</p>\n<ul>\n<li><p id=\"so_47534938_47648516_5\">if the initializer list has one element <strong>that is not itself an initializer list</strong>...</p></li>\n<li><p id=\"so_47534938_47648516_6\">if the initializer list has no elements...</p></li>\n</ul>\n<p id=\"so_47534938_47648516_7\">In all cases other than those enumerated above, no conversion is possible.</p>\n</blockquote>\n<p>To determine <code>{{\"test\"}}</code> -&gt; <code>std::string</code>, the same process is taken, and overload resolution chooses the constructor of <code>std::string</code> that takes a parameter of type <code>const char*</code>.</p>\n<p>As a result, <code>{{{\"test\"}}}</code> -&gt; <code>A</code> is done by choosing the constructor <code>A(std::string)</code>.</p>\n<hr>\n<h1>Variations</h1>\n<h2>What if <code>explicit</code> is removed?</h2>\n<p>The process does not change. GCC will choose the constructor <code>A(const char*)</code> while Clang will choose the constructor <code>A(std::string)</code>. I think it is a bug for GCC. </p>\n<h2>What if there are only two layers of braces in the initializer of <code>b1</code>?</h2>\n<p>Note <code>{{\"test\"}}</code> -&gt; <code>const char*</code> does not exist but <code>{\"test\"}</code> -&gt; <code>const char*</code> exists. So if there are only two layers of braces in the initializer of <code>b1</code>, the constructor <code>A(const char*)</code> is chosen because <code>{\"test\"}</code> -&gt; <code>const char*</code> is better than <code>{\"test\"}</code> -&gt; <code>std::string</code>. As a result, an explicit constructor is chosen in copy-list-initialization (initialization of the parameter <code>A</code> in the constructor <code>B(A)</code> from <code>{\"test\"}</code>), then the program is ill-formed.</p>\n<h2>What if the constructor <code>B(const B&amp;)</code> is declared?</h2>\n<p>Note this also happens if the declaration of <code>B(B&amp;)</code> is removed. This time we need to compare <code>{{{\"test\"}}}</code> -&gt; <code>A</code> and <code>{{{\"test\"}}}</code> -&gt; <code>const B&amp;</code>, or <code>{{{\"test\"}}}</code> -&gt; <code>const B</code> equivalently.</p>\n<p>To determine <code>{{{\"test\"}}}</code> -&gt; <code>const B</code>, the process described above is taken. We need to compare <code>{{\"test\"}}</code> -&gt; <code>A</code> and <code>{{\"test\"}}</code> -&gt; <code>const B&amp;</code>. Note <code>{{\"test\"}}</code> -&gt; <code>const B&amp;</code> does not exist according to <a href=\"http://www.eel.is/c++draft/over.best.ics#4\" rel=\"noreferrer\">[over.best.ics]/4</a>:</p>\n<blockquote>\n<p id=\"so_47534938_47648516_8\">However, if the target is</p>\n<p id=\"so_47534938_47648516_9\">\u2014 the first parameter of a constructor or</p>\n<p id=\"so_47534938_47648516_10\">\u2014 the implicit object parameter of a user-defined conversion function</p>\n<p id=\"so_47534938_47648516_11\">and the constructor or user-defined conversion function is a candidate by</p>\n<p id=\"so_47534938_47648516_12\">\u2014 [over.match.ctor], when the argument is the temporary in the second step of a class copy-initialization,</p>\n<p id=\"so_47534938_47648516_13\">\u2014  [over.match.copy], [over.match.conv], or  [over.match.ref] (in all cases), or</p>\n<p id=\"so_47534938_47648516_14\">\u2014 <strong>the second phase of [over.match.list] when the initializer list has exactly one element that is itself an initializer list, and the target is the first parameter of a constructor of class X, and the conversion is to X or\n  reference to <em>cv</em> X</strong>,</p>\n<p id=\"so_47534938_47648516_15\">user-defined conversion sequences are not considered. </p>\n</blockquote>\n<p>To determine <code>{{\"test\"}}</code> -&gt; <code>A</code>, the process described above is taken again. This is almost the same as the case we talked in the previous subsection. As a result, the constructor <code>A(const char*)</code> is chosen. Note the constructor is chosen here to determine <code>{{{\"test\"}}}</code> -&gt; <code>const B</code>, and does not apply actually. This is permitted though the constructor is explicit.</p>\n<p>As a result, <code>{{{\"test\"}}}</code> -&gt; <code>const B</code> is done by choosing the constructor <code>B(A)</code>, then the constructor <code>A(const char*)</code>. Now both <code>{{{\"test\"}}}</code> -&gt; <code>A</code> and <code>{{{\"test\"}}}</code> -&gt; <code>const B</code> are user-defined conversion sequences and neither is better than the other, so the initialization of <code>b1</code> is ambiguous. </p>\n<h2>What if the parentheses is replaced by braces?</h2>\n<p>According to <a href=\"http://www.eel.is/c++draft/over.best.ics#4\" rel=\"noreferrer\">[over.best.ics]/4</a>, which is block-quoted in the previous subsection, the user defined conversion <code>{{{\"test\"}}}</code> -&gt; <code>const B&amp;</code> is not considered. So the result is the same as the primary example even if the constructor <code>B(const B&amp;)</code> is declared.</p>\n</hr>", "LastEditorUserId": "5376789", "LastActivityDate": "2017-12-05T08:29:10.493", "Score": "5", "CreationDate": "2017-12-05T07:46:57.783", "ParentId": "47534938", "CommentCount": "0", "OwnerUserId": "5376789", "LastEditDate": "2017-12-05T08:29:10.493"}});