post_cb({"39182901": {"ParentId": "39173519", "CommentCount": "0", "Body": "<p>You can use templates to deduce the signature of functions and functors:</p>\n<pre><code>#include&lt;functional&gt;\n\ntemplate&lt;class T&gt;\nstruct AsFunction\n    : public AsFunction&lt;decltype(&amp;T::operator())&gt;\n{};\n\ntemplate&lt;class ReturnType, class... Args&gt;\nstruct AsFunction&lt;ReturnType(Args...)&gt; {\n  using type = std::function&lt;ReturnType(Args...)&gt;;\n};\n\ntemplate&lt;class ReturnType, class... Args&gt;\nstruct AsFunction&lt;ReturnType(*)(Args...)&gt; {\n  using type = std::function&lt;ReturnType(Args...)&gt;;\n};\n\n\ntemplate&lt;class Class, class ReturnType, class... Args&gt;\nstruct AsFunction&lt;ReturnType(Class::*)(Args...) const&gt; {\n  using type = std::function&lt;ReturnType(Args...)&gt;;\n};\n\ntemplate&lt;class F&gt;\nauto toFunction( F f ) -&gt; typename AsFunction&lt;F&gt;::type {\n  return {f};\n}\n\ntemplate &lt;typename T&gt;\nvoid stdfunc_test(std::function&lt;T(T)&gt; func) {};\n\nint test_func(int arg)\n{\n    return arg + 2;\n}\n\n\nint main()\n{\n\n    stdfunc_test( toFunction([](int _) {return _ + 2;}) );\n    stdfunc_test( toFunction(test_func) );\n    return 0;\n}\n</code></pre>\n<p>you can try it live here:  <a href=\"http://fiddle.jyt.io/github/d4ab355eb2ab7fc4cc0a48da261f0127\" rel=\"nofollow\">http://fiddle.jyt.io/github/d4ab355eb2ab7fc4cc0a48da261f0127</a></p>\n", "OwnerUserId": "3053638", "PostTypeId": "2", "Id": "39182901", "Score": "1", "CreationDate": "2016-08-27T15:42:29.147", "LastActivityDate": "2016-08-27T15:42:29.147"}, "39173519": {"CommentCount": "4", "AcceptedAnswerId": "39181969", "PostTypeId": "1", "LastEditorUserId": "4987285", "CreationDate": "2016-08-26T19:30:39.993", "LastActivityDate": "2016-08-27T15:42:29.147", "LastEditDate": "2016-08-26T20:15:23.210", "ViewCount": "1035", "FavoriteCount": "0", "Title": "Template type deduction with std::function", "Id": "39173519", "Score": "6", "Body": "<p>I have discovered the following behaviour with <code>std::function</code> and type deduction, which was unexpected for me:</p>\n<pre><code>#include &lt;functional&gt;\n\ntemplate &lt;typename T&gt;\nvoid stdfunc_test(std::function&lt;T(T)&gt; func) {};\n\nint test_func(int arg)\n{\n    return arg + 2;\n}\n\nint main()\n{\n    stdfunc_test([](int _) {return _ + 2;});\n    stdfunc_test(test_func);\n}\n</code></pre>\n<p>Both lines in <code>main</code> result in error:</p>\n<blockquote>\n<p id=\"so_39173519_39173519_0\">no instance of function template \"stdfunc_test\" matches the argument list</p>\n</blockquote>\n<p>When attempting to compile in Visual Studio 2015.</p>\n<p>Why doesn't the type deduction deduct template type from the function type, and is there a workaround for it?</p>\n", "Tags": "<c++><templates><c++11><std-function>", "OwnerUserId": "4086854", "AnswerCount": "2"}, "39181969": {"ParentId": "39173519", "CommentCount": "0", "Body": "<p>No implicit conversion is performed during template argument deduction, except: <a href=\"http://eel.is/c++draft/temp.deduct.call#4\" rel=\"nofollow\">temp.deduct.call</a></p>\n<blockquote>\n<p id=\"so_39173519_39181969_0\">In general, the deduction process attempts to find template argument values that will make the deduced A identical to A (after the type A is transformed as described above). However, there are three cases that allow a difference:</p>\n<ul>\n<li>If the original P is a reference type, the deduced A (i.e., the type referred to by the reference) can be more cv-qualified than the transformed A.</li>\n<li>The transformed A can be another pointer or pointer to member type that can be converted to the deduced A via a function pointer conversion ([conv.fctptr]) and/or qualification conversion ([conv.qual]).</li>\n<li>If P is a class and P has the form simple-template-id, then the transformed A can be a derived class of the deduced A. Likewise, if P is a pointer to a class of the form simple-template-id, the transformed A can be a pointer to a derived class pointed to by the deduced A.</li>\n</ul>\n</blockquote>\n<p>However, if the template parameter doesn't participate in template argument deduction, implicit conversion will be performed: (<a href=\"http://eel.is/c++draft/temp.arg.explicit#6\" rel=\"nofollow\">temp.arg.explicit</a>)</p>\n<blockquote>\n<p id=\"so_39173519_39181969_1\">Implicit conversions (Clause [conv]) will be performed on a function argument to convert it to the type of the corresponding function parameter if the parameter type contains no template-parameters that participate in template argument deduction. [ Note: Template parameters do not participate in template argument deduction if they are explicitly specified.</p>\n</blockquote>\n<p>So, if you explicitly specify the template argument, it should work:</p>\n<pre><code>stdfunc_test&lt;int&gt;([](int _) {return _ + 2;});\nstdfunc_test&lt;int&gt;(test_func);\n</code></pre>\n", "OwnerUserId": "5845611", "PostTypeId": "2", "Id": "39181969", "Score": "1", "CreationDate": "2016-08-27T13:59:45.860", "LastActivityDate": "2016-08-27T13:59:45.860"}, "bq_ids": {"n4140": {"so_39173519_39181969_0": {"section_id": 305, "quality": 1.0, "length": 23}, "so_39173519_39181969_1": {"section_id": 289, "quality": 0.9354838709677419, "length": 29}, "so_39173519_39173519_0": {"section_id": 102, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_39173519_39181969_1": {"section_id": 280, "quality": 0.9354838709677419, "length": 29}, "so_39173519_39181969_0": {"section_id": 296, "quality": 1.0, "length": 23}, "so_39173519_39173519_0": {"section_id": 97, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_39173519_39181969_1": {"section_id": 296, "quality": 0.9354838709677419, "length": 29}, "so_39173519_39181969_0": {"section_id": 312, "quality": 1.0, "length": 23}, "so_39173519_39173519_0": {"section_id": 106, "quality": 0.5714285714285714, "length": 4}}}});