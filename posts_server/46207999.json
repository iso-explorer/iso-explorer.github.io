post_cb({"46207999": {"ViewCount": "92", "Body": "<p>So, I've got an issue, and I'm not sure if it's a language issue, or a compiler/GCC issue.</p>\n<p><strong>TL;DR</strong> - Am I required to <strong>define</strong> all static methods within a class, even if those static methods are <strong>never called</strong> by the application (i.e. could be legitimately dropped by the linker anyway)?</p>\n<p>I have a library class that implements a device driver for a UART in a microcontroller.  Because I don't want multiple UART objects pointing to the same resource, each UART object is a singleton, retrieved using one of several <code>GetInstance()</code> methods, one for each UART instance in the device (UART0, UART1, etc).  Each UART instance needs to have two FIFOs (Tx and Rx) for storage.  Each FIFO needs to be explicitly sized by the <strong>application</strong> and allocated at the time that the UART object is instantiated (ideally).  So I also have several static <code>GetStorage()</code> methods, again, once for each UART.</p>\n<p>I've created some stripped down code for my proof of concept.  Here's static_instance.h:</p>\n<pre><code>#ifndef STATIC_INSTANCE_H_\n#define STATIC_INSTANCE_H_\n\n#ifdef __cplusplus\n#include &lt;vector&gt;\nnamespace foo {\nclass Uart {\n public:\n  /* Retrieve a singleton instance, using lazy static initialization.  Note\n   * that not all instances will be present for a given device. */\n  static Uart&amp; Uart1GetInstance(void);\n  static Uart&amp; Uart2GetInstance(void);\n  static Uart&amp; Uart3GetInstance(void);\n  /* Does something. */\n  void DoSomething(void) { ++counter; }\n private:\n  /* Structure for the storage that each static Uart instance requires. */\n  struct Storage {\n    Storage(std::vector&lt;char&gt;&amp; vector)\n        : my_vector_(vector) { }\n    std::vector&lt;char&gt;&amp; my_vector_;   // Buffer for data.\n  };\n  /* Instantiate object using provided register base and FIFO structures. */\n  Uart(int instance, Storage&amp; storage)\n      : instance_(instance), storage_(storage) { }\n  ~Uart() { }\n  /* Retrieves the storage required for the static Uart object instances.\n   * These methods are NOT implemented in static_instance.cc, but must be\n   * implemented in the application code, only for those Uart instances\n   * that are invoked in the application. */\n  static Storage&amp; Uart1GetStorage(void);\n  static Storage&amp; Uart2GetStorage(void);\n  static Storage&amp; Uart3GetStorage(void);\n  int const instance_;    // Instance number of this object.\n  Storage&amp; storage_;      // Allocated storage for this object.\n  int counter = 0;        // Dummy counter.\n};\n} // namespace foo\n#endif  // __cplusplus\n\n#endif\n</code></pre>\n<p>And here's static_instance.cc:</p>\n<pre><code>#include &lt;static_instance.h&gt;\nnamespace foo {\n\nUart&amp; Uart::Uart1GetInstance(void) {\n  static Uart uart(1, Uart1GetStorage());\n  return uart;\n}\nUart&amp; Uart::Uart2GetInstance(void) {\n  static Uart uart(2, Uart2GetStorage());\n  return uart;\n}\nUart&amp; Uart::Uart3GetInstance(void) {\n  static Uart uart(3, Uart3GetStorage());\n  return uart;\n}\n\n} // namespace foo\n</code></pre>\n<p>The idea is that you only call <code>GetInstance()</code> for the UART instance you actually need, and then only define <code>GetStorage()</code> for that UART instance.  (For this example, I'm only defining one buffer, and using <code>std::vector&lt;char&gt;</code> as a stand-in.)  Further, it's left to the application to define the storage method, because each application is going to have its own requirements for how big a given UART's buffer needs to be.  (What I absolutely won't do is put macros in my C++ module, because, ew.)  Here's the code snippet in main.cc to instantiate UART2:</p>\n<pre><code>namespace foo {\n\nUart::Storage&amp; Uart::Uart2GetStorage(void) {\n  static std::vector&lt;char&gt; rx_vector(256, 0);\n  static Uart::Storage storage(rx_vector);\n  return storage;\n}\nstatic foo::Uart&amp; uart_ = foo::Uart::Uart2GetInstance();\nvoid wibble(void) {\n  uart_.DoSomething();\n}\n\n} // namespace foo\n</code></pre>\n<p>Now, I was developing an earlier application using an earlier IDE for this chip (Kinetis Design Studio v3.2.0 for the curious), which uses <strong>GCC 4.8.4</strong> and compiles and links with <strong>no errors</strong>.</p>\n<p>But NXP has deprecated KDS for another toolchain (MCUXpresso 10.0), which uses <strong>GCC 5.4.1</strong>, and using the exact same code, this time I get <strong>two linker errors</strong>:</p>\n<pre><code>./source/static_instance.o: In function 'foo::Uart::Uart1GetInstance()':\n../source/static_instance.cc:5: undefined reference to 'foo::Uart::Uart1GetStorage()'\n./source/static_instance.o: In function 'foo::Uart::Uart3GetInstance()':\n../source/static_instance.cc:13: undefined reference to 'foo::Uart::Uart3GetStorage()'\n</code></pre>\n<p>I'm not sure why the linker cares that the <code>GetStorage()</code> methods for UART1 and UART3 aren't defined, because I'm not calling <code>GetInstance()</code> for either UART1 or UART3 in my application, and thus never calling the corresponding <code>GetStorage()</code> methods either.</p>\n<p>My question here is... does C++11 <strong>require</strong> me to have all three storage methods defined in my executable?  That is, was GCC 4.8.4 letting me get away with something that I shouldn't have been able to?  Or is this some GCC 5.4 option that I need to toggle, to allow me to drop unused static members from a class?</p>\n<p>If the answer is \"you have to define them regardless\", then I'll define them, or maybe engineer some other way to allow.  If the answer is \"that should be OK\", and there's no option that I can set on the command line to make GCC 5.4 do it, then I'll take the next step and report a bug in the NXP forums.  Thanks.</p>\n", "AcceptedAnswerId": "46208132", "Title": "c++ - Must all static class methods be defined, even when not used?", "CreationDate": "2017-09-13T22:53:04.740", "Id": "46207999", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-09-13T23:22:23.317", "Score": "2", "OwnerUserId": "7269461", "Tags": "<c++><c++11><gcc>", "AnswerCount": "2"}, "46208132": {"Id": "46208132", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46207999_46208132_0\">TL;DR - Am I required to define all static methods within a class, even if those static methods are never called by the application</p>\n</blockquote>\n<p>You may be required to define such static methods, even if they are never called by the application.</p>\n<p>But, in general, you might not need to, if those functions are not <a href=\"http://en.cppreference.com/w/cpp/language/definition\" rel=\"nofollow noreferrer\">odr-used</a> (one definition rule). For static member functions, this is equivalent to</p>\n<blockquote>\n<p id=\"so_46207999_46208132_1\">A function whose name appears as a potentially-evaluated expression</p>\n</blockquote>\n<p>The difference is subtle. I hope this demonstrates it:</p>\n<pre><code>if(false)\n    function();\n</code></pre>\n<p><code>function</code> is never called, but appears in a potentially-evaluated expression, and is therefore odr-used and therefore must be defined. </p>\n<hr>\n<blockquote>\n<p id=\"so_46207999_46208132_2\">My question here is... does C++11 require me to have all three storage methods defined in my executable?</p>\n</blockquote>\n<p>Yes. They all appear in potentially-evaluated expressions and are therefore odr-used and therefore must be defined.</p>\n<blockquote>\n<p id=\"so_46207999_46208132_3\">I was developing an earlier application using ... GCC 4.8.4 and compiles and links with no errors.</p>\n</blockquote>\n<p>Odr violations have undefined behaviour, which explains why you didn't get an error / warning in the other tool chain.</p>\n</hr>", "LastEditorUserId": "3002139", "LastActivityDate": "2017-09-13T23:22:23.317", "Score": "4", "CreationDate": "2017-09-13T23:09:07.873", "ParentId": "46207999", "CommentCount": "0", "OwnerUserId": "2079303", "LastEditDate": "2017-09-13T23:22:23.317"}, "46208197": {"Id": "46208197", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46207999_46208197_0\">[basic.def.odr]</p>\n<ol start=\"4\">\n<li>Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in\n  that program outside of a discarded statement (9.4.1); no diagnostic required.</li>\n</ol>\n</blockquote>\n<p>This is from a relatively new draft standard, but all versions contain a similar statement.</p>\n<p>The \"no diagnostic required\" clause gives your compiler permission to accept your program even if it violates the rule. An odr-use within an unreachable piece of code is exactly the case when it is reasonable to do so: a compiler may or may not optimise away dead code that contains the offending call. Your program is still in violation and another implementation may reject it.</p>\n", "LastActivityDate": "2017-09-13T23:18:08.927", "CommentCount": "0", "CreationDate": "2017-09-13T23:18:08.927", "ParentId": "46207999", "Score": "2", "OwnerUserId": "775806"}, "bq_ids": {"n4140": {"so_46207999_46208132_1": {"length": 6, "quality": 1.0, "section_id": 7040}}, "n3337": {"so_46207999_46208132_1": {"length": 6, "quality": 1.0, "section_id": 6785}}, "n4659": {"so_46207999_46208132_1": {"length": 6, "quality": 1.0, "section_id": 8537}}}});