post_cb({"45273291": {"CommentCount": "6", "ViewCount": "193", "PostTypeId": "1", "LastEditorUserId": "2410359", "CreationDate": "2017-07-24T05:38:53.840", "LastActivityDate": "2017-07-24T19:53:32.473", "Title": "What are pros and cons of using uint64_t as an universal address of memory instead of void*?", "AcceptedAnswerId": "45283790", "LastEditDate": "2017-07-24T16:22:17.093", "Id": "45273291", "Score": "4", "Body": "<p>I'm a rookie of C programming. I found <code>uint64_t</code> is used as addresses of buffer rather than <code>void*</code> in libibverbs. </p>\n<pre><code>struct ibv_sge{\n    uint64_t addr;\n    uint32_t length;\n    uint32_t lkey;\n}\n</code></pre>\n<p>A disadvantage I can think of is its portability. On a 32-bits system, it will causes compilation error or at least memory waste. So why does it do? Are there any benefits?  </p>\n<p>I also noted there are other alternative approach, such as <code>uintptr_t</code>. What's the best approach to describe an universal address of memory?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "5836863", "AnswerCount": "2"}, "45283790": {"ParentId": "45273291", "PostTypeId": "2", "CommentCount": "8", "Body": "<blockquote>\n<p id=\"so_45273291_45283790_0\">pros and cons of using uint64_t as an universal address of memory</p>\n</blockquote>\n<p>Con:</p>\n<ol>\n<li><p>It may be unnecessarily wide when a narrower <em>universal address</em> would do.</p></li>\n<li><p>It may be unnecessarily narrow when a wider <em>universal address</em> is needed.</p></li>\n</ol>\n<p>C does not have a <em>universal address</em>.  The closest is <code>void *</code>, yet that only specified to be sufficient for object pointers.  <code>void *</code> may be insufficient for function pointers.  Any function pointer type is the same size as another function pointer type.</p>\n<blockquote>\n<p id=\"so_45273291_45283790_1\">A pointer to <code>void</code> may be converted to or from a pointer to any object type. A pointer to any object type may be converted to a pointer to <code>void</code> and back again; the result shall compare equal to the original pointer. C11dr \u00a76.3.2.3 1</p>\n<p id=\"so_45273291_45283790_2\">A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. \u00a76.3.2.3 8</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_45273291_45283790_3\">What's the best approach to describe an universal address of memory?</p>\n</blockquote>\n<p>With C, instead use a <code>union</code>.</p>\n<pre><code>union u_pointer {\n  void *obj;\n  int (*fun)();\n};\n</code></pre>\n<p>Access to read and write these members needs careful handling though, as would be the case with any <em>universal pointer</em>.</p>\n<hr>\n</hr></hr>", "OwnerUserId": "2410359", "LastEditorUserId": "2410359", "LastEditDate": "2017-07-24T19:53:32.473", "Id": "45283790", "Score": "0", "CreationDate": "2017-07-24T14:55:14.510", "LastActivityDate": "2017-07-24T19:53:32.473"}, "45284166": {"ParentId": "45273291", "CommentCount": "2", "Body": "<p>In C++ one shall never need neither <code>int</code>, nor <code>void*</code> as pointer types, ever.</p>\n<p>The library seems to be about 13 000 lines of C. An example of how the structure is used, copied from <a href=\"https://github.com/linux-rdma/rdma-core/tree/master/libibverbs\" rel=\"nofollow noreferrer\">the current master</a>:</p>\n<pre><code>static int pp_post_recv(struct pingpong_context *ctx, int n)\n{\n        struct ibv_sge list = {\n                .addr   = (uintptr_t) ctx-&gt;buf,\n                .length = ctx-&gt;size,\n                .lkey   = ctx-&gt;mr-&gt;lkey\n        };\n        struct ibv_recv_wr wr = {\n                .wr_id      = PINGPONG_RECV_WRID,\n                .sg_list    = &amp;list,\n                .num_sge    = 1,\n        };\n        struct ibv_recv_wr *bad_wr;\n        int i;\n\n        for (i = 0; i &lt; n; ++i)\n                if (ibv_post_srq_recv(ctx-&gt;srq, &amp;wr, &amp;bad_wr))\n                        break;\n\n        return i;\n}\n</code></pre>\n<p>To me, <code>.addr</code> seems like an offset in a buffer. Thus, pointer type would have been misleeding.</p>\n", "OwnerUserId": "1145760", "PostTypeId": "2", "Id": "45284166", "Score": "0", "CreationDate": "2017-07-24T15:12:08.160", "LastActivityDate": "2017-07-24T15:12:08.160"}, "bq_ids": {"n4140": {"so_45273291_45283790_2": {"section_id": 6049, "quality": 0.5555555555555556, "length": 10}, "so_45273291_45283790_1": {"section_id": 6039, "quality": 0.5652173913043478, "length": 13}}, "n3337": {"so_45273291_45283790_2": {"section_id": 5817, "quality": 0.5555555555555556, "length": 10}, "so_45273291_45283790_1": {"section_id": 5807, "quality": 0.5652173913043478, "length": 13}}, "n4659": {"so_45273291_45283790_2": {"section_id": 7548, "quality": 0.5555555555555556, "length": 10}}}});