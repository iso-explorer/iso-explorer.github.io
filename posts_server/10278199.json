post_cb({"10278199": {"CommentCount": "8", "ViewCount": "297", "PostTypeId": "1", "LastEditorUserId": "1350936", "CreationDate": "2012-04-23T09:47:17.033", "LastActivityDate": "2012-04-23T14:06:21.943", "Title": "How can C++ compiler optimize incorrect hierarchical downcast to cause real undefined behavior", "LastEditDate": "2012-04-23T11:53:34.197", "Id": "10278199", "Score": "3", "Body": "<p>Consider the following example:</p>\n<pre><code>class Base {\npublic:\n    int data_;\n};\n\nclass Derived : public Base {\npublic:\n    void fun() { ::std::cout &lt;&lt; \"Hi, I'm \" &lt;&lt; this &lt;&lt; ::std::endl; }\n};\n\nint main() {\n    Base base;\n    Derived *derived = static_cast&lt;Derived*&gt;(&amp;base); // Undefined behavior!\n\n    derived-&gt;fun(); \n\n    return 0;\n}\n</code></pre>\n<p>Function call is obviously undefined behavior according to C++ standard. But on all available machines and compilers (VC2005/2008, gcc on RH Linux and SunOS) it works as expected (prints \"Hi!\"). Do anyone know configuration this code can work incorrectly on? Or may be, more complicated example with the same idea (note, that Derived shouldn't carry any additional data anyway)?</p>\n<p><strong>Update:</strong></p>\n<p>From standard 5.2.9/8:</p>\n<blockquote>\n<p id=\"so_10278199_10278199_0\">An rvalue of type \u201cpointer to cv1 B\u201d, where B is a class type, can be\n  converted to an     rvalue of type \u201cpointer to cv2 D\u201d, where D is a\n  class derived (clause 10) from B, if a valid standard conversion from\n  \u201cpointer to D\u201d to \u201cpointer to B\u201d exists (4.10), cv2 is the same\n  cvqualification as, or greater cvqualification than, cv1, and B is not\n  a virtual base class of D. The null pointer value (4.10) is converted\n  to the null pointer value of the destination type. <strong>If the rvalue of\n  type \u201cpointer to cv1 B\u201d points to a B that is actually a subobject of\n  an object of type D, the resulting pointer points to the enclosing\n  object of type D. Otherwise, the result of the cast is undefined.</strong></p>\n</blockquote>\n<p>And one more 9.3.1 (thanks @Agent_L): </p>\n<blockquote>\n<p id=\"so_10278199_10278199_1\">If a nonstatic member function of a class X is called for an object\n  that is not of type X, or of a type derived from X, the behavior is\n  undefined.</p>\n</blockquote>\n<p>Thanks, \nMike.</p>\n", "Tags": "<c++><compiler-optimization><undefined-behavior>", "OwnerUserId": "1350936", "AnswerCount": "6"}, "10278972": {"ParentId": "10278199", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You have to understand what your code is doing, then you can see it's doing nothing wrong.\n\"this\" is a hidden pointer, generated for you by the compiler.</p>\n<pre><code>class Base\n{\npublic:\n    int data_;\n};\n\nclass Derived : public Base\n{\n\n};\n\n\nvoid fun(Derived* pThis) \n{\n::std::cout &lt;&lt; \"Hi, I'm \" &lt;&lt; pThis &lt;&lt; ::std::endl; \n}\n\n//because you're JUST getting numerical value of a pointer, it can be same as:\nvoid fun(void* pThis) \n{\n    ::std::cout &lt;&lt; \"Hi, I'm \" &lt;&lt; pThis &lt;&lt; ::std::endl; \n}\n\n//but hey, even this is still same:\nvoid fun(unsigned int pThis) \n{\n    ::std::cout &lt;&lt; \"Hi, I'm \" &lt;&lt; pThis &lt;&lt; ::std::endl; \n}\n</code></pre>\n<p>Now it's obvious: this function cannot fail. You can even pass NULL, or some other, completely unrelated class.\n<em>The behaviour is undefined, but there is nothing that can go wrong here.</em></p>\n<p>//Edit: ok, according to Standard, the situations are not equal. ((Derived*)NULL)-&gt;fun(); is explicitly declared UB. However, this behaviour is usually defined in compiler docs about calling conventions.\nI should have written \"For all compilers that I know, nothing can go wrong.\"</p>\n", "OwnerUserId": "1059969", "LastEditorUserId": "1059969", "LastEditDate": "2012-04-23T11:46:32.530", "Id": "10278972", "Score": "1", "CreationDate": "2012-04-23T10:38:38.880", "LastActivityDate": "2012-04-23T11:46:32.530"}, "10281652": {"ParentId": "10278199", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>For example, the compiler may optimize the code out.\nConsider sligthly different program:</p>\n<pre><code>if(some_very_complex_condition)\n{\n  // here is your original snippet:\n\n  Base base;\n  Derived *derived = static_cast&lt;Derived*&gt;(&amp;base); // Undefined behavior!\n\n  derived-&gt;fun(); \n}\n</code></pre>\n<p>The compiler can </p>\n<p>(1) detect the undefined behaviour </p>\n<p>(2) assume that the program shouldn't expose undefined behavior</p>\n<p>Therefore (the compiler decides that) _some_very_complex_condition_ should be always false. Assuming this, the compiler may eliminate the whole code as not reachable.</p>\n<p><b>[edit]</b> A real world example how the compiler may eliminate code which \"serves\" UB case:</p>\n<p><a href=\"https://stackoverflow.com/questions/7682477/gcc-fail-or-undefined-behavior\">Why does integer overflow on x86 with GCC cause an infinite loop?</a></p>\n", "OwnerUserId": "396672", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:52:22.837", "Id": "10281652", "Score": "1", "CreationDate": "2012-04-23T13:37:13.690", "LastActivityDate": "2012-04-23T13:57:58.663"}, "10279777": {"ParentId": "10278199", "CommentCount": "3", "Body": "<p>The comments to the code are incorrect.</p>\n<pre><code>Derived *derived = static_cast&lt;Derived*&gt;(&amp;base);\nderived-&gt;fun(); // Undefined behavior!\n</code></pre>\n<p>Corrected version:</p>\n<pre><code>Derived *derived = static_cast&lt;Derived*&gt;(&amp;base);  // Undefined behavior!\nderived-&gt;fun(); // Uses result of undefined behavior\n</code></pre>\n<p>The undefined behavior starts with the <code>static_cast</code>. Any subsequent use of this ill-begotten pointer is also undefined behavior. Undefined behavior is a get out of jail free card for compiler vendors. Almost any response by the compiler is compliant with the standard.</p>\n<p>There's nothing to stop the compiler from rejecting your cast. A nice compiler might well issue a fatal compilation error for that <code>static_cast</code>. The violation is easy to see <em>in this case</em>. In general it is not easy to see, so most compilers don't bother checking.</p>\n<p>Most compilers instead take the easiest way out. In this case, the easy way out is to simply pretend that that pointer to an instance of class <code>Base</code> is a pointer to an instance of class <code>Derived</code>. Since your function <code>Derived::fun()</code> is rather benign, the easy way out <em>in this case</em> yields a rather benign result.</p>\n<p>Just because you are getting a nice benign result does not mean everything is cool. It is still undefined behavior. The best bet is to never rely on undefined behavior.</p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "10279777", "Score": "5", "CreationDate": "2012-04-23T11:37:27.017", "LastActivityDate": "2012-04-23T11:37:27.017"}, "10278256": {"ParentId": "10278199", "CommentCount": "21", "Body": "<p>The function <code>fun()</code> doesn't actually do anything that matters what the <code>this</code> pointer is, and as it isn't a virtual function, there's nothing special needed to look up the function. Basically, it's called like any normal (non-member) function, with a bad <code>this</code> pointer. It just doesn't crash, which is perfectly valid undefined behavior (if that's not a contradiction).</p>\n", "OwnerUserId": "1171191", "PostTypeId": "2", "Id": "10278256", "Score": "9", "CreationDate": "2012-04-23T09:51:19.933", "LastActivityDate": "2012-04-23T09:51:19.933"}, "10278254": {"ParentId": "10278199", "PostTypeId": "2", "CommentCount": "27", "Body": "<p>Run the same code infinite number of times on the same machine, <em>maybe</em> you will see it working <em>incorrectly</em> and <em>unexpectedly</em> if you're lucky. </p>\n<p>The thing to understand is that undefined behavior (UB) does not mean that it will <em>definitely</em> not run as expected; it <em>might</em> run as expected, 1 time, 2 times, 10 times, even infinite number of times. UB simply means it is just not <em>guaranteed</em> to run as expected.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2012-04-23T09:57:17.127", "Id": "10278254", "Score": "3", "CreationDate": "2012-04-23T09:51:14.910", "LastActivityDate": "2012-04-23T09:57:17.127"}, "bq_ids": {"n4140": {"so_10278199_10278199_1": {"section_id": 5890, "quality": 1.0, "length": 11}, "so_10278199_10278199_0": {"section_id": 6037, "quality": 0.7777777777777778, "length": 49}}, "n3337": {"so_10278199_10278199_1": {"section_id": 5661, "quality": 1.0, "length": 11}, "so_10278199_10278199_0": {"section_id": 5805, "quality": 0.8095238095238095, "length": 51}}, "n4659": {"so_10278199_10278199_1": {"section_id": 7373, "quality": 1.0, "length": 11}, "so_10278199_10278199_0": {"section_id": 7536, "quality": 0.6984126984126984, "length": 44}}}, "10282140": {"ParentId": "10278199", "CommentCount": "6", "Body": "<p>The practical reason why this code often works is that anything which breaks this tends to be optimized out in release/optimized-for-performance builds. However, any compiler setting that focuses on finding errors (such as debug builds) is more likely to trip on this.</p>\n<p>In those cases, your assumption (\"note, that <code>Derived</code> shouldn't carry any additional data anyway\") doesn't hold. It definitely should, to facilitate debugging.</p>\n<p>A slightly more complicated example is even trickier:</p>\n<pre><code>class Base {\npublic:\n    int data_;\n    virtual void bar() { std::cout &lt;&lt; \"Base\\n\"; }\n};\n\nclass Derived : public Base {\npublic:\n    void fun() { ::std::cout &lt;&lt; \"Hi, I'm \" &lt;&lt; this &lt;&lt; ::std::endl; }\n    virtual void bar() { std::cout &lt;&lt; \"Derived\\n\"; }\n};\n\nint main() {\n    Base base;\n    Derived *derived = static_cast&lt;Derived*&gt;(&amp;base); // Undefined behavior!\n\n    derived-&gt;fun(); \n    derived-&gt;bar();\n}\n</code></pre>\n<p>Now a reasonable compiler may decide to skip the vtable and statically call <code>Base::bar()</code> since that's the object you're calling <code>bar()</code> on. Or it may decide that <code>derived</code> must point to a real <code>Derived</code> since you called <code>fun</code> on it, skip the vtable, and call <code>Derived::bar()</code>.  As you see, both optimizations are quite reasonable given the circumstances.</p>\n<p>And in this we see why Undefined Behavior can be so surprising: compilers can make incorrect assumptions following code with UB, even if the statement itself is compiled right.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "10282140", "Score": "1", "CreationDate": "2012-04-23T14:06:21.943", "LastActivityDate": "2012-04-23T14:06:21.943"}});