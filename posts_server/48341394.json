post_cb({"48341734": {"Id": "48341734", "PostTypeId": "2", "Body": "<p>The C++17 standard contains an example <a href=\"http://eel.is/c++draft/class.base.init#7\" rel=\"noreferrer\">almost exactly the same as in the question</a>:</p>\n<pre><code>struct B1 { B1(int); /* ... */ };\nstruct B2 { B2(int); /* ... */ };\nstruct D : B1, B2 {\n  D(int);\n  B1 b;\n  const int c;\n};\n\nD::D(int a) : B2(a+1), B1(a+2), c(a+3), b(a+4) { /* ... */ }\nD d(10);\n</code></pre>\n<p>This is followed by a note:</p>\n<blockquote>\n<p id=\"so_48341394_48341734_0\">[ Note: The initialization performed by each mem-initializer constitutes a full-expression (4.6). Any expression in a mem-initializer is evaluated as part of the full-expression that performs the initialization. \u2014 end note ]</p>\n</blockquote>\n<p>Following the link, section 4.6 tells us that one of the <a href=\"http://eel.is/c++draft/intro.execution#5.3\" rel=\"noreferrer\">definitions of \"full-expression\" is</a></p>\n<blockquote>\n<p id=\"so_48341394_48341734_1\">... a mem-initializer, including the constituent expressions of the initializer,</p>\n</blockquote>\n<p>The phrase \"including constituent expressions of the initiailizer\" strongly suggests to me that the above code is legal, because the side effects of <code>++i</code> will have completed before moving on to the next initializer. This is just my reading of the standard though, I'm happy to defer to anyone with more standardese experience than me.</p>\n<p>(It's also worth noting that initialization of members will happen in the order in which they are declared in the class, not in the order in which they appear in the member initializer list).</p>\n", "LastEditorUserId": "2797826", "LastActivityDate": "2018-01-19T13:15:52.677", "Score": "6", "CreationDate": "2018-01-19T13:00:30.610", "ParentId": "48341394", "CommentCount": "3", "OwnerUserId": "2797826", "LastEditDate": "2018-01-19T13:15:52.677"}, "bq_ids": {"n4140": {"so_48341394_48341908_5": {"length": 15, "quality": 1.0, "section_id": 438}, "so_48341394_48341734_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 434}, "so_48341394_48341908_0": {"length": 13, "quality": 0.8125, "section_id": 434}, "so_48341394_48341908_3": {"length": 6, "quality": 1.0, "section_id": 438}, "so_48341394_48341908_2": {"length": 18, "quality": 1.0, "section_id": 5810}}, "n3337": {"so_48341394_48341908_5": {"length": 15, "quality": 1.0, "section_id": 429}, "so_48341394_48341734_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 426}, "so_48341394_48341908_0": {"length": 13, "quality": 0.8125, "section_id": 426}, "so_48341394_48341908_3": {"length": 6, "quality": 1.0, "section_id": 429}, "so_48341394_48341908_2": {"length": 18, "quality": 1.0, "section_id": 5583}}, "n4659": {"so_48341394_48341908_5": {"length": 15, "quality": 1.0, "section_id": 458}, "so_48341394_48341734_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 452}, "so_48341394_48341908_0": {"length": 13, "quality": 0.8125, "section_id": 452}, "so_48341394_48341734_1": {"length": 5, "quality": 1.0, "section_id": 7267}, "so_48341394_48341908_3": {"length": 6, "quality": 1.0, "section_id": 458}, "so_48341394_48341908_2": {"length": 18, "quality": 1.0, "section_id": 7271}}}, "48341394": {"ViewCount": "1152", "Body": "<p>Is this causing undefined behaviour? Specifically, the incrementing in the initializer list and how will that be evaluated.</p>\n<pre><code>class Wrinkle {\npublic:\n    Wrinkle(int i) : a(++i), b(++i), x(++i) {}\nprivate:\n    int a;\n    int x;\n    int b;\n};\n</code></pre>\n<p>The difference in order between the declaration of members and initializer list is intended since this is an example that would showcase exactly that difference, so please ignore it for now.</p>\n", "AcceptedAnswerId": "48341908", "Title": "Does incrementing in a member initializer list generate undefined behavior?", "CreationDate": "2018-01-19T12:41:34.420", "LastActivityDate": "2018-02-10T15:21:32.277", "CommentCount": "13", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-02-10T15:21:32.277", "LastEditorUserId": "3048763", "Id": "48341394", "Score": "24", "OwnerUserId": "2447529", "Tags": "<c++><language-lawyer><undefined-behavior><ctor-initializer>", "AnswerCount": "2"}, "48341908": {"Id": "48341908", "PostTypeId": "2", "Body": "<p>This does not generate <em>Undefined Behavior</em> because:</p>\n<p><a href=\"http://eel.is/c++draft/class.base.init#7\" rel=\"noreferrer\">[class.base.init]#7</a></p>\n<blockquote>\n<p id=\"so_48341394_48341908_0\">[ <em>Note:</em> The initialization performed by each mem-initializer constitutes a full-expression. Any expression in a mem-initializer is evaluated as part of the full-expression that performs the initialization. ]</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/intro.execution\" rel=\"noreferrer\">[intro.execution]</a></p>\n<blockquote>\n<p id=\"so_48341394_48341908_1\"><a href=\"http://eel.is/c++draft/intro.execution#5\" rel=\"noreferrer\">5.</a> A full-expression is</p>\n<ul>\n<li>[...]</li>\n<li>an init-declarator or a mem-initializer, including the constituent expressions of the initializer,</li>\n</ul>\n<p id=\"so_48341394_48341908_2\"><a href=\"http://eel.is/c++draft/intro.execution#9\" rel=\"noreferrer\">9.</a> Every value computation and side effect associated with a full-expression is sequenced before every value computation and side effect associated with the next full-expression to be evaluated.</p>\n</blockquote>\n<hr>\n<p>But beware that:</p>\n<p><a href=\"http://eel.is/c++draft/class.base.init#13\" rel=\"noreferrer\">[class.base.init]#13</a></p>\n<blockquote>\n<p id=\"so_48341394_48341908_3\">In a non-delegating constructor, initialization proceeds in the following order:</p>\n<ul>\n<li><p id=\"so_48341394_48341908_4\">[...]</p></li>\n<li><p id=\"so_48341394_48341908_5\">Then, non-static data members are initialized in the order they were declared in the class definition (again regardless of the order of the mem-initializers).</p></li>\n</ul>\n</blockquote>\n<p>So your code will effectively assign <code>i + 1</code> to <code>a</code>, <code>i + 2</code> to <code>x</code> and <code>i + 3</code> to <code>b</code>.</p>\n</hr>", "LastEditorUserId": "2666289", "LastActivityDate": "2018-01-19T20:02:53.583", "Score": "31", "CreationDate": "2018-01-19T13:10:58.167", "ParentId": "48341394", "CommentCount": "1", "OwnerUserId": "2666289", "LastEditDate": "2018-01-19T20:02:53.583"}});