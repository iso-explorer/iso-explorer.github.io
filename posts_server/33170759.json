post_cb({"33170934": {"ParentId": "33170759", "CommentCount": "0", "Body": "<p>From [expr.prim.lambda] 5.1.2(15)</p>\n<blockquote>\n<p id=\"so_33170759_33170934_0\">An entity is captured by copy if it is implicitly captured and the capture-default is = or if it is explicitly captured with a capture that is not of the form &amp; identifier or &amp; identifier initializer. <strong>For each entity captured by copy, an unnamed non-static data member is declared in the closure type</strong>. The declaration order of these members is unspecified. The type of such a data member is the type of the corresponding captured entity if the entity is not a reference to an object, or the referenced type otherwise. [ Note: If the\n  captured entity is a reference to a function, the corresponding data member is also a reference to a function. \u2014end note ] A member of an anonymous union shall not be captured by copy.</p>\n</blockquote>\n<p><sup>emphasis mine</sup></p>\n<p>So a variable captured by value will be stored as member of the closure type.  The closure type is unspecified as per 5.1.2(3)</p>\n<blockquote>\n<p id=\"so_33170759_33170934_1\">The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed nonunion class type \u2014 called the closure type \u2014 whose properties are described below. This class type is neither an aggregate (8.5.1) nor a literal type (3.9). The closure type is declared in the smallest block scope, class scope, or namespace scope that contains the corresponding lambda-expression.</p>\n</blockquote>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "33170934", "Score": "0", "CreationDate": "2015-10-16T12:49:12.787", "LastActivityDate": "2015-10-16T12:49:12.787"}, "33171032": {"ParentId": "33170759", "CommentCount": "0", "Body": "<p>At compile time lambdas are actually turned into classes. So if you had the following.</p>\n<pre><code>int a; Widget widget; \n\nauto somelambda = [=a,&amp;widget](){\n\n}\n</code></pre>\n<p>You could actually think of it as</p>\n<pre><code>class SomeLambda\n{\nint a;\nWidge&amp; w;\n...\n}\n</code></pre>\n<p>Which should make you really cautious because you can have dangling references.</p>\n", "OwnerUserId": "168802", "PostTypeId": "2", "Id": "33171032", "Score": "0", "CreationDate": "2015-10-16T12:54:12.950", "LastActivityDate": "2015-10-16T12:54:12.950"}, "bq_ids": {"n4140": {"so_33170759_33170934_1": {"section_id": 5962, "quality": 0.8809523809523809, "length": 37}, "so_33170759_33170934_0": {"section_id": 5974, "quality": 0.8888888888888888, "length": 56}}, "n3337": {"so_33170759_33170934_1": {"section_id": 5731, "quality": 0.7857142857142857, "length": 33}, "so_33170759_33170934_0": {"section_id": 5742, "quality": 0.746031746031746, "length": 47}}, "n4659": {"so_33170759_33170934_0": {"section_id": 7473, "quality": 0.7301587301587301, "length": 46}}}, "33170759": {"CommentCount": "1", "ViewCount": "378", "PostTypeId": "1", "ClosedDate": "2015-10-16T14:03:16.037", "LastEditorUserId": "1938552", "CreationDate": "2015-10-16T12:40:33.723", "LastActivityDate": "2015-10-16T12:54:12.950", "Title": "C++ lambda & std::function capture by value memory management?", "LastEditDate": "2015-10-16T12:43:14.073", "Id": "33170759", "Score": "-1", "Body": "<p>Where do lambdas and std::functions store variables captured by value?</p>\n<pre><code>int i = 1;\nauto l = [i](void) mutable { return i++; };\nstd::function&lt;int(void)&gt; f = l;\n</code></pre>\n<p>Do they call the new operator? If I provide my own new operator, will it be used by lambdas?</p>\n", "Tags": "<c++><memory-management><lambda><new-operator>", "OwnerUserId": "1938552", "AnswerCount": "2"}});