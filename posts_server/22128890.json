post_cb({"22129113": {"ParentId": "22128890", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>If you're using <em>braced-init-lists</em> and the destination type of an initialization is a reference:</p>\n<p>[dcl.init.list]/3 (from n3690)</p>\n<blockquote>\n<ul>\n<li><p id=\"so_22128890_22129113_0\">Otherwise, if the initializer list has a single element of type <code>E</code> and either <code>T</code> is not a reference type or its referenced type is\n  reference-related to <code>E</code>, the object or reference is initialized from\n  that element; if a narrowing conversion (see below) is required to\n  convert the element to <code>T</code>, the program is ill-formed.</p></li>\n<li><p id=\"so_22128890_22129113_1\">Otherwise, if <code>T</code> is a reference type, a prvalue temporary of the type referenced by <code>T</code> is copy-list-initialized or\n  direct-list-initialized, depending on the kind of initialization for\n  the reference, and the reference is bound to that temporary. [<em>Note:</em> As\n  usual, the binding will fail and the program is ill-formed if the\n  reference type is an lvalue reference to a non-const type. <em>\u2014 end note</em>]</p></li>\n<li><p id=\"so_22128890_22129113_2\">Otherwise, if the initializer list has no elements, the object is value-initialized.</p></li>\n</ul>\n</blockquote>\n<p>For the two examples <code>const A&amp; c{1};</code> and <code>const A&amp; d = {1};</code>, the second bullet of the quotation above applies. The first one direct-list-initializes a <code>const A</code>, the second one copy-list-initializes a <code>const A</code>. Copy-initialization selecting an <code>explicit</code> constructor is ill-formed, see [over.match.list]/1.</p>\n<hr>\n<p>If you're not using braced-init-lists, there's no difference between copy-initialization and direct-initialization as far as I can tell. The last bullet of [dcl.init.ref]/5 applies in all cases:</p>\n<blockquote id=\"so_22128890_22129113_3\">\n<ul>\n<li>Otherwise, a temporary of type \u201c<em>cv1</em> <code>T1</code>\u201d is created and initialized from the initializer expression\n  using the rules for a non-reference copy-initialization (8.5). The reference is then bound to the\n  temporary.</li>\n</ul>\n</blockquote>\n<p>Copy-initialization cannot select an <code>explicit</code> ctor, see [over.match.copy]/1 (it's not viable).</p>\n<hr>\n<p>Conclusion:</p>\n<pre><code>const A&amp; c{1};\n</code></pre>\n<p>is legal. The other are not, because they either use copy-initialization or copy-list-initialization and the only viable / selected ctor is <code>explicit</code>.</p>\n</hr></hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2014-03-02T14:59:07.377", "Id": "22129113", "Score": "5", "CreationDate": "2014-03-02T14:51:56.467", "LastActivityDate": "2014-03-02T14:59:07.377"}, "22128975": {"ParentId": "22128890", "CommentCount": "0", "Body": "<p>Your struct can only be created by an explicit call to it's constructor. No implicit conversion is allowed. </p>\n<p>A const reference must point to an existing object of that type on construction.</p>\n<p>None of your lines create an object of type A by calling it's explicit constructor. So I don't see why any of those lines should properly initialize a const reference.</p>\n", "OwnerUserId": "2060725", "PostTypeId": "2", "Id": "22128975", "Score": "0", "CreationDate": "2014-03-02T14:40:12.490", "LastActivityDate": "2014-03-02T14:40:12.490"}, "bq_ids": {"n4140": {"so_22128890_22129113_2": {"section_id": 3325, "quality": 1.0, "length": 6}, "so_22128890_22129113_3": {"section_id": 3321, "quality": 0.6470588235294118, "length": 11}, "so_22128890_22129113_1": {"section_id": 3325, "quality": 0.9, "length": 27}, "so_22128890_22129113_0": {"section_id": 3325, "quality": 1.0, "length": 25}}, "n3337": {"so_22128890_22129113_2": {"section_id": 3195, "quality": 1.0, "length": 6}, "so_22128890_22129113_3": {"section_id": 3191, "quality": 0.8823529411764706, "length": 15}, "so_22128890_22129113_1": {"section_id": 3195, "quality": 0.7, "length": 21}, "so_22128890_22129113_0": {"section_id": 3195, "quality": 0.76, "length": 19}}, "n4659": {"so_22128890_22129113_2": {"section_id": 4091, "quality": 1.0, "length": 6}, "so_22128890_22129113_3": {"section_id": 4087, "quality": 0.5294117647058824, "length": 9}, "so_22128890_22129113_1": {"section_id": 4091, "quality": 0.7, "length": 21}, "so_22128890_22129113_0": {"section_id": 4091, "quality": 1.0, "length": 25}}}, "22128890": {"CommentCount": "0", "ViewCount": "107", "PostTypeId": "1", "LastEditorUserId": "2672165", "CreationDate": "2014-03-02T14:32:34.707", "LastActivityDate": "2014-03-02T14:59:07.377", "Title": "Reference to const T initialized by value of type other than T", "AcceptedAnswerId": "22129113", "LastEditDate": "2014-03-02T14:35:21.590", "Id": "22128890", "Score": "4", "Body": "<p>For the following code:</p>\n<pre><code>struct A {\n    explicit A(int) {}\n};\n\nconst A&amp; a(1);    // error on g++/clang++/vc++\nconst A&amp; b = 1;   // error on g++/clang++/vc++\nconst A&amp; c{1};    // ok on g++/clang++, error on vc++\nconst A&amp; d = {1}; // error on g++/clang++/vc++\n</code></pre>\n<p>Which one(s) of the 4 initialization is(are) legal?  </p>\n<p>If we ignore vc++ first, it seems that the difference between direct-init and copy-init is not behaving consistently here.  If the third one is well-formed because it's direct-init, why does the first one which is also direct-init fail to compile?  What's the logic behind this?  Or it's just a bug for g++/clang++ and vc++ handles it correctly?</p>\n", "Tags": "<c++><visual-c++><c++11><g++><clang++>", "OwnerUserId": "3237645", "AnswerCount": "2"}});