post_cb({"28348429": {"CommentCount": "1", "AcceptedAnswerId": "28349054", "PostTypeId": "1", "LastEditorUserId": "1428839", "CreationDate": "2015-02-05T15:57:11.247", "LastActivityDate": "2015-02-05T22:18:05.543", "LastEditDate": "2015-02-05T22:18:05.543", "ViewCount": "798", "FavoriteCount": "2", "Title": "C++11: Disambiguate class-member in multiple inheritance", "Id": "28348429", "Score": "4", "Body": "<p>Suppose I have this variadic base class-template:</p>\n<pre><code>template &lt;typename ... Types&gt;\nclass Base\n{\npublic:\n    // The member foo() can only be called when its template \n    // parameter is contained within the Types ... pack.\n\n    template &lt;typename T&gt;\n    typename std::enable_if&lt;Contains&lt;T, Types ...&gt;::value&gt;::type\n    foo() {\n        std::cout &lt;&lt; \"Base::foo()\\n\";\n    }\n};\n</code></pre>\n<p>The <code>foo()</code> member can only be called when its template-parameter matches at least one of the parameters of <code>Base</code> (the implementation of <code>Contains</code> is listed at the bottom at this post):</p>\n<pre><code>Base&lt;int, char&gt;().foo&lt;int&gt;(); // fine\nBase&lt;int, char&gt;().foo&lt;void&gt;(); // error\n</code></pre>\n<p>Now I define a derived class that inherits twice from Base, using <strong><em>non-overlapping sets</em></strong> of types:</p>\n<pre><code>struct Derived: public Base&lt;int, char&gt;,\n                public Base&lt;double, void&gt;\n{};\n</code></pre>\n<p>I was hoping that when calling e.g.</p>\n<pre><code>Derived().foo&lt;int&gt;();\n</code></pre>\n<p>the compiler would figure out which base-class to use, because it is SFINAE'd out of the one that does not contain <code>int</code>. However, both GCC 4.9 and Clang 3.5 complain about an ambiguous call. </p>\n<p>My question then is two-fold:</p>\n<ol>\n<li>Why can't the compiler resolve this ambiguity (general interest)?</li>\n<li>What can I do to make this work, without having to write <code>Derived().Base&lt;int, char&gt;::foo&lt;int&gt;();</code>? <strong>EDIT:</strong> GuyGreer showed me that the call is disambiguated when I add two using-declarations. However, since I'm providing the base-class for the user to inherit from, this isn't an ideal solution. If at all possible, I don't want my users to have to add those declarations (which can be quite verbose and repetitive for large type-lists) to their derived classes.</li>\n</ol>\n<p>Implementation of <code>Contains</code>:</p>\n<pre><code>template &lt;typename T, typename ... Pack&gt;\nstruct Contains;\n\ntemplate &lt;typename T&gt;\nstruct Contains&lt;T&gt;: public std::false_type\n{};\n\ntemplate &lt;typename T, typename ... Pack&gt;\nstruct Contains&lt;T, T, Pack ...&gt;: public std::true_type\n{};\n\ntemplate &lt;typename T, typename U, typename ... Pack&gt;\nstruct Contains&lt;T, U, Pack ...&gt;: public Contains&lt;T, Pack...&gt;\n{};\n</code></pre>\n", "Tags": "<c++><c++11><multiple-inheritance><ambiguity><enable-if>", "OwnerUserId": "1428839", "AnswerCount": "2"}, "28349054": {"ParentId": "28348429", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Here's a simpler example:</p>\n<pre><code>template &lt;typename T&gt;\nclass Base2 {\npublic:\n    void foo(T ) { }\n};\n\nstruct Derived: public Base2&lt;int&gt;,\n                public Base2&lt;double&gt;\n{};\n\nint main()\n{\n    Derived().foo(0); // error\n}\n</code></pre>\n<p>The reason for that comes from the merge rules [class.member.lookup]:</p>\n<blockquote>\n<p id=\"so_28348429_28349054_0\">Otherwise (i.e., C does not contain a declaration of f or the resulting declaration set is empty), S(f,C) is\n  initially empty. If C has base classes, calculate the lookup set for f in each direct base class subobject Bi,\n  and merge each such lookup set S(f,Bi) in turn into S(f,C).<br>\n  \u2014 [..]<br>\n  \u2014 Otherwise, if the declaration sets of S(f,Bi) and S(f,C) differ, the merge is ambiguous...</br></br></p>\n</blockquote>\n<p>Since our initial declaration set is empty (<code>Derived</code> has no methods in it), we have to merge from all of our bases - but our bases have differing sets, so the merge fails. However, that rule explicitly only applies if the declaration set of <code>C</code> (<code>Derived</code>) is empty. So to avoid it, we make it non-empty:</p>\n<pre><code>struct Derived: public Base2&lt;int&gt;,\n                public Base2&lt;double&gt;\n{\n    using Base2&lt;int&gt;::foo;\n    using Base2&lt;double&gt;::foo;\n};\n</code></pre>\n<p>That works because the rule for applying <code>using</code> is</p>\n<blockquote>\n<p id=\"so_28348429_28349054_1\">In the declaration set, <em>using-declarations</em> are replaced by the set\n  of designated members that are not hidden or overridden by members of the derived class (7.3.3),</p>\n</blockquote>\n<p>There's no comment there about whether or not the members differ - we effectively just provide <code>Derived</code> with two overloads on <code>foo</code>, bypassing the member name lookup merge rules. </p>\n<p>Now, <code>Derived().foo(0)</code> unambiguously calls <code>Base2&lt;int&gt;::foo(int )</code>. </p>\n<p>Alternatively to having a <code>using</code> for each base explicitly, you could write a collector to do them all:</p>\n<pre><code>template &lt;typename... Bases&gt;\nstruct BaseCollector;\n\ntemplate &lt;typename Base&gt;\nstruct BaseCollector&lt;Base&gt; : Base\n{\n    using Base::foo;\n};\n\ntemplate &lt;typename Base, typename... Bases&gt;\nstruct BaseCollector&lt;Base, Bases...&gt; : Base, BaseCollector&lt;Bases...&gt;\n{\n    using Base::foo;\n    using BaseCollector&lt;Bases...&gt;::foo;\n};\n\nstruct Derived : BaseCollector&lt;Base2&lt;int&gt;, Base2&lt;std::string&gt;&gt;\n{ };\n\nint main() {\n    Derived().foo(0); // OK\n    Derived().foo(std::string(\"Hello\")); // OK\n}\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-02-05T18:45:32.403", "Id": "28349054", "Score": "9", "CreationDate": "2015-02-05T16:26:02.503", "LastActivityDate": "2015-02-05T18:45:32.403"}, "28348575": {"ParentId": "28348429", "CommentCount": "6", "Body": "<p>Though I can't tell you in detail why it doesn't work as is, I added <code>using Base&lt;int, char&gt;::foo;</code> and <code>using Base&lt;double, void&gt;::foo;</code> to <code>Derived</code> and it compiles fine now.  </p>\n<p>Tested with <code>clang-3.4</code> and <code>gcc-4.9</code></p>\n", "OwnerUserId": "1277769", "PostTypeId": "2", "Id": "28348575", "Score": "3", "CreationDate": "2015-02-05T16:03:27.543", "LastActivityDate": "2015-02-05T16:03:27.543"}, "bq_ids": {"n4140": {"so_28348429_28349054_1": {"section_id": 6991, "quality": 0.9230769230769231, "length": 12}, "so_28348429_28349054_0": {"section_id": 6993, "quality": 0.7631578947368421, "length": 29}}, "n3337": {"so_28348429_28349054_0": {"section_id": 6739, "quality": 0.7631578947368421, "length": 29}}, "n4659": {"so_28348429_28349054_1": {"section_id": 8489, "quality": 0.9230769230769231, "length": 12}, "so_28348429_28349054_0": {"section_id": 8491, "quality": 0.7631578947368421, "length": 29}}}});