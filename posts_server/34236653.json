post_cb({"34236669": {"Id": "34236669", "PostTypeId": "2", "Body": "<p>It will always fail. That's pretty much it. It will fail always for the same reason that \"assert(x == 5)\" will succeed whenever x = 5.</p>\n<p>If you're asking for an <em>application</em> then you would put it in code blocks that really shouldn't happen.</p>\n<pre><code>switch(suit) {\n  case CLUB:\n  case DIAMOND:\n  case HEART:\n  case SPADE:\n  // ...\n  default:\n    assert(0);\n }\n</code></pre>\n", "LastEditorUserId": "1339987", "LastActivityDate": "2015-12-12T05:52:56.120", "Score": "12", "CreationDate": "2015-12-12T05:33:08.637", "ParentId": "34236653", "CommentCount": "13", "OwnerUserId": "1339987", "LastEditDate": "2015-12-12T05:52:56.120"}, "34236653": {"ViewCount": "7997", "Body": "<p>I had a question like this on one of my exams and I'm still not too sure how to answer it. I understand that assertions are ways to test your program, however I'm not too sure what <strong><code>assert(0)</code></strong> is checking. Is this a trick question? It will always fail, but I don't understand why. What is it checking? </p>\n<p>Any explanation would be great, thanks.</p>\n", "AcceptedAnswerId": "34236783", "Title": "What does assert(0) mean?", "CreationDate": "2015-12-12T05:31:05.330", "Id": "34236653", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-12-12T05:45:07.270", "LastEditorUserId": "3445324", "LastActivityDate": "2015-12-12T10:28:08.833", "Score": "23", "OwnerUserId": "5671322", "Tags": "<c++><c><assert><assertion>", "AnswerCount": "4"}, "34237373": {"Id": "34237373", "PostTypeId": "2", "Body": "<p>In <em>addition</em> to other answers (notably <a href=\"https://stackoverflow.com/a/34236783/841108\">this</a> one), if you are using a recent <a href=\"http://gcc.gnu.org/\" rel=\"nofollow noreferrer\">GCC</a> (or <a href=\"http://clang.llvm.org/docs/LanguageExtensions.html\" rel=\"nofollow noreferrer\">Clang</a>), you might consider using some <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\" rel=\"nofollow noreferrer\">GCC builtin</a>, notably <code>__builtin_unreachable()</code>  instead of <code>assert(0)</code>.</p>\n<p>There are some differences: first, <code>assert</code> can be disabled with <code>-DNDEBUG</code>. And <code>__builtin_unreachable</code> will change the way the compiler is optimizing your code.</p>\n<p>Of course some compilers don't know about <code>__builtin_unreachable</code>.</p>\n<p>And you could also consider calling some <code>[[noreturn]]</code> C++ function (in C++11 or better) - or <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html\" rel=\"nofollow noreferrer\"><code>__attribute__((noreturn))</code></a> for <a href=\"http://gcc.gnu.org/\" rel=\"nofollow noreferrer\">GCC</a>, such as <code>abort()</code></p>\n<p>BTW, <code>assert(0)</code>  is not exactly like throwing some exception (since exceptions can be caught)</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-12T07:31:06.967", "Score": "3", "CreationDate": "2015-12-12T07:20:19.083", "ParentId": "34236653", "CommentCount": "6", "OwnerUserId": "841108", "LastEditDate": "2017-05-23T12:02:14.733"}, "bq_ids": {"n4140": {"so_34236653_34236783_2": {"length": 33, "quality": 1.0, "section_id": 6269}}, "n3337": {"so_34236653_34236783_2": {"length": 33, "quality": 1.0, "section_id": 6029}}, "n4659": {"so_34236653_34236783_2": {"length": 33, "quality": 1.0, "section_id": 7775}}}, "34236863": {"Id": "34236863", "PostTypeId": "2", "Body": "<p>Yes, it will always fail.</p>\n<p><code>assert(0)</code> or <code>assert(false)</code> is usually used to mark <strong>unreachable code</strong>, so that in debug mode a diagnostic message is emitted and the program is aborted when the supposedly unreachable is actually reached, which is a clear signal that the program isn't doing what we think it is.</p>\n", "LastEditorUserId": "3425536", "LastActivityDate": "2015-12-12T06:10:55.887", "Score": "8", "CreationDate": "2015-12-12T06:03:12.990", "ParentId": "34236653", "CommentCount": "1", "OwnerUserId": "3425536", "LastEditDate": "2015-12-12T06:10:55.887"}, "34236783": {"Id": "34236783", "PostTypeId": "2", "Body": "<p>The C++ standard defers the definition of <code>assert</code> to the C standard.</p>\n\nC99 \u00a77.2/2:\n\n<blockquote>\n<p id=\"so_34236653_34236783_0\"><strong>\u201d</strong> The <code>assert</code> macro puts diagnostic tests into programs; it expands to a void expression. When it is executed, if <em>expression</em> (which shall have a scalar type) is false (that is, compares equal to 0), the assert macro writes information about the particular call that failed (including the text of the argument, the name of the source file, the source line number, and the name of the enclosing function \u2014 the latter are respectively the values of the preprocessing macros <code>__FILE__</code> and <code>__LINE__</code> and of the identifier <code>__func__</code>) on the standard error file in an implementation-defined format. It then calls the <code>abort</code> function.</p>\n</blockquote>\n<hr>\n<p>In <code>assert(0)</code> the <code>0</code> is interpreted as <code>false</code>, so this assertion will always fail, or <strong>fire</strong>, when assertion checking is on.</p>\n<p>Thus it asserts that</p>\n<blockquote>\n<p id=\"so_34236653_34236783_1\">\u201cThe execution will never reach this point.\u201d</p>\n</blockquote>\n<p>In practice it can be difficult to make compilers shut up about the execution reaching or not reaching a given point. Often the compiler will first complain about the execution possibly reaching the end of a function without returning a value. Adding an <code>assert(0)</code> there should ideally solve that issue, but then the compiler may complain about the <code>assert</code>, or not recognize that it says you're already well aware of what it tries to warn about.</p>\n<p>One <sup>(1)</sup>possible measure then is to also throw an exception at that point:</p>\n<pre><code>auto foo( int x )\n    -&gt; int\n{\n    if( x == 1 ) { return 42; }\n    assert( 0 ); throw 0;       // Should never get here!\n}\n</code></pre>\n<p>Of course that double-whammy can be defined as a higher level macro. Regarding the exception type you may want to keep it as not a <code>std::exception</code>, because this is not an exception intended to be caught by an ordinary <code>catch</code> anywhere. Or, if you trust the standard exception hierarchy (it doesn't make sense to me, but) you can use a <code>std::logic_error</code>.</p>\n<hr>\n<p>To turn off <code>assert</code> assertion checking you can define the symbol <code>NDEBUG</code> before including <code>&lt;assert.h&gt;</code>.</p>\n<p>This header has special support so that you can include it multiple times, with or without <code>NDEBUG</code> defined.</p>\n\nC++11 \u00a717.6.2.2/2:\n\n<blockquote>\n<p id=\"so_34236653_34236783_2\"><strong>\u201d</strong> A translation unit may include library headers in any order (Clause 2). Each may be included more than\n  once, with no effect different from being included exactly once, except that the effect of including either <code>&lt;cassert&gt;</code> or <code>&lt;assert.h&gt;</code> depends each time on the lexically current definition of <code>NDEBUG</code>.</p>\n</blockquote>\n<p>A reasonable definition of the double-whammy discussed above can likewise depend on <code>NDEBUG</code> with no include guard, e.g.</p>\n\nFile <i>assert_should_never_get_here.hpp</i>\n<pre><code>#include &lt;stdexcept&gt;        // std::logic_error\n#include &lt;assert.h&gt;\n\n#undef ASSERT_SHOULD_NEVER_GET_HERE\n#ifdef NDEBUG\n#   define ASSERT_SHOULD_NEVER_GET_HERE() \\\n        throw std::logic_error( \"Reached a supposed unreachable point\" )\n#else\n#   define ASSERT_SHOULD_NEVER_GET_HERE() \\\n        do{ \\\n            assert( \"Reached a supposed unreachable point\" &amp;&amp; 0 ); \\\n            throw 0; \\\n        } while( 0 )\n#endif\n</code></pre>\n<p>Disclaimer: While I coded that up a number of times in the early 2000s, I cooked up the code above just for this answer, and while I did test it with g++ it may not necessarily be perfect.</p>\n<hr>\n<p><sup>\n<sup>(1)</sup> See <a href=\"https://stackoverflow.com/a/34237373/464581\">Basile Starynkevitch's answer</a> for discussion of another possibility, the g++-specific intrinsic <code>__builtin_unreachable</code>.\n</sup></p>\n</hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-12T10:28:08.833", "Score": "24", "CreationDate": "2015-12-12T05:51:54.030", "ParentId": "34236653", "CommentCount": "1", "OwnerUserId": "464581", "LastEditDate": "2017-05-23T12:34:16.960"}});