post_cb({"23005015": {"ParentId": "23004941", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strike>No, no difference for you. Just use <code>U() : p() {}</code>.</strike></p>\n<blockquote>\n<p id=\"so_23004941_23005015_0\">[ Note: In general, one must use explicit destructor calls and placement new operators to change the active\n  member of a union. \u2014 end note ]</p>\n<p id=\"so_23004941_23005015_1\">[ Example: Consider an object u of a union type U having non-static data\n  members <code>m</code> of type <code>M</code> and <code>n</code> of type <code>N</code>. If <code>M</code> has a non-trivial destructor and <code>N</code> has a non-trivial constructor\n  (for instance, if they declare or inherit virtual functions), the active member of <code>u</code> can be safely switched from m to n using the destructor and placement new operator as follows:</p>\n<pre><code>u.m.~M();\nnew (&amp;u.n) N;\n</code></pre>\n<p id=\"so_23004941_23005015_2\">\u2014 end example ]</p>\n</blockquote>\n<p>I.e. your first variant is correct.</p>\n<hr>\n<p>The standard also says:</p>\n<blockquote>\n<p id=\"so_23004941_23005015_3\">At most one non-static data member of a union may have a brace-or-equal-initializer.</p>\n</blockquote>\n<p>Personally, I would expect the following to be correct:</p>\n<pre><code>union U {\n    int z;\n    double w;\n    Point p {1,2};\n};\n\n#include &lt;iostream&gt;\nint main () {\n    U u;\n    std::cout &lt;&lt; u.p.x_ &lt;&lt; \":\" &lt;&lt; u.p.y_ &lt;&lt; std::endl;\n}\n</code></pre>\n<p>I would expect the output <code>1:2</code>, but with g++ 4.8.1 I get garbage values. When I try</p>\n<pre><code>union U {\n    int z;\n    double w;\n    Point p = Point(1,2);\n};\n</code></pre>\n<p>I get garbage values, too. I am not sure if this is a compiler bug.</p>\n<p><strong>edit</strong>: <a href=\"https://stackoverflow.com/questions/23005241/brace-or-equal-initializer-in-unions\">brace-or-equal-Initializer in unions</a></p>\n</hr>", "OwnerUserId": "76722", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:16:22.260", "Id": "23005015", "Score": "1", "CreationDate": "2014-04-11T06:25:57.347", "LastActivityDate": "2014-04-11T06:39:24.420"}, "23004941": {"CommentCount": "0", "ViewCount": "766", "PostTypeId": "1", "LastEditorUserId": "718379", "CreationDate": "2014-04-11T06:21:12.153", "LastActivityDate": "2014-05-06T02:53:06.687", "Title": "How to initialize a non-POD member in Union", "LastEditDate": "2014-05-06T02:53:06.687", "Id": "23004941", "Score": "1", "Body": "<p>In c++11, Union supports non-POD member. I want to initialize a non-POD member in the constructor.</p>\n<p>On wikipedia c++11 <a href=\"http://en.wikipedia.org/wiki/C++11#Unrestricted_unions\" rel=\"nofollow\">page</a>, it uses a placement 'new' to initialize a non-POD member.</p>\n<pre><code>#include &lt;new&gt; // Required for placement 'new'.\n\nstruct Point {\n    Point() {}\n    Point(int x, int y): x_(x), y_(y) {}\n    int x_, y_;\n};\n\nunion U {\n    int z;\n    double w;\n    Point p; // Illegal in C++03; legal in C++11.\n    U() {new(&amp;p) Point();} // Due to the Point member, a constructor definition is now required.\n};\n</code></pre>\n<p>I am wondering is there any difference if I use ctor-initializer-list instead of placement 'new'?</p>\n<pre><code>U() : p() {}\n</code></pre>\n", "Tags": "<c++><c++11><constructor><unions>", "OwnerUserId": "3522318", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23004941_23005015_1": {"section_id": 5916, "quality": 0.9375, "length": 30}, "so_23004941_23005015_0": {"section_id": 5916, "quality": 0.8235294117647058, "length": 14}, "so_23004941_23005015_3": {"section_id": 5913, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_23004941_23005015_1": {"section_id": 5688, "quality": 0.9375, "length": 30}, "so_23004941_23005015_0": {"section_id": 5688, "quality": 0.8235294117647058, "length": 14}, "so_23004941_23005015_3": {"section_id": 5686, "quality": 1.0, "length": 9}}, "n4659": {"so_23004941_23005015_1": {"section_id": 7409, "quality": 0.875, "length": 28}, "so_23004941_23005015_0": {"section_id": 7409, "quality": 0.7058823529411765, "length": 12}, "so_23004941_23005015_3": {"section_id": 454, "quality": 0.6666666666666666, "length": 6}}}, "23016005": {"ParentId": "23004941", "CommentCount": "0", "Body": "<p>You are free to initialize at most one member of a union in the <em>ctor-initializer-list</em>. A union is a class, so the rules for member initializers in [class.base.init] (C++11 \u00a712.6.2) apply just as they do to classes with the class-key <code>struct</code> or <code>class</code>. One obvious exception is stated in 12.6.2/8: \"An attempt to initialize more than one non-static data member of a union renders the program ill-formed.\"</p>\n", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "23016005", "Score": "1", "CreationDate": "2014-04-11T14:54:38.787", "LastActivityDate": "2014-04-11T14:54:38.787"}});