post_cb({"17200312": {"CommentCount": "5", "ViewCount": "3944", "PostTypeId": "1", "LastEditorUserId": "1690864", "CreationDate": "2013-06-19T20:06:33.787", "LastActivityDate": "2013-06-20T04:59:49.003", "Title": "What's the point of forward declaring a class template explicit/partial specialization?", "AcceptedAnswerId": "17201574", "LastEditDate": "2013-06-19T20:26:54.383", "Id": "17200312", "Score": "2", "Body": "<p>The C++98 standard says:</p>\n<blockquote>\n<p id=\"so_17200312_17200312_0\">[temp.class.spec] Partial specialization declarations themselves are not found by name lookup.</p>\n</blockquote>\n<p>If this is also true for explicit specializations, this makes a forward-declaration of a class template explicit/partial specialization invisible.</p>\n<blockquote>\n<p id=\"so_17200312_17200312_1\">[temp.class.spec.match] When a class template is used in a context that requires an instantiation of the class, it is necessary to determine whether the instantiation is to be generated using the primary template or one of the partial specializations.</p>\n</blockquote>\n<p>This implies that the choice of explicit/partial specialization is not made until the point of (implicit) instantiation of a matching specialization - which only occurs when the class is required to be completely defined.</p>\n<p>In the following example, the only effect the forward-declared explicit-specializations have is to make the program fail to compile.</p>\n<pre><code>namespace N\n{\n    template&lt;class T&gt;\n    struct S\n    {\n    };\n\n    typedef S&lt;char&gt; Type; // name lookup finds S&lt;T&gt;\n\n    template&lt;&gt;\n    struct S&lt;char&gt;; // invisible to name lookup\n\n    typedef S&lt;char&gt; Type; // name lookup finds S&lt;T&gt;\n\n    int f(S&lt;char&gt;*); // name lookup finds S&lt;T&gt;\n\n    S&lt;int&gt; object; // implicitly instantiates S&lt;int&gt;\n\n    template&lt;&gt;\n    struct S&lt;int&gt;; // illegal, explicit specialization after instantiation\n}\n\nN::S&lt;char&gt;* p = 0; // name lookup finds N::S&lt;T&gt;\nint i = f(p); // name lookup finds N::f via ADL\n\n\nN::S&lt;char&gt; object; // illegal, incomplete type N::S&lt;char&gt;\n</code></pre>\n<p>In both cases, the only way to make the program compile (apart from deleting the specializations) is to provide a definition for both specializations <strong>before</strong> they are instantiated - which makes the forward-declaration a bit pointless.</p>\n<p>Does this behaviour have any practical real-world application? Apart from this, is there anything these forward-declarations are useful for?</p>\n", "Tags": "<c++><templates><language-lawyer><forward-declaration><template-specialization>", "OwnerUserId": "1690864", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_17200312_17200312_1": {"section_id": 143, "quality": 0.9473684210526315, "length": 18}, "so_17200312_17200312_0": {"section_id": 140, "quality": 0.875, "length": 7}}, "n3337": {"so_17200312_17200312_0": {"section_id": 134, "quality": 0.875, "length": 7}, "so_17200312_17200312_1": {"section_id": 137, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_17200312_17200312_0": {"section_id": 144, "quality": 0.875, "length": 7}, "so_17200312_17200312_1": {"section_id": 147, "quality": 0.9473684210526315, "length": 18}}}, "17201574": {"ParentId": "17200312", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2013-06-19T21:21:02.943", "Score": "4", "LastEditorUserId": "34509", "LastEditDate": "2013-06-20T04:59:49.003", "Id": "17201574", "OwnerUserId": "34509", "Body": "<p>It is not true that the only purpose is to make the program fail to compile. In the following, <code>V2</code> is \"ill-formed; no diagnostic required\", while V1 is well-formed. </p>\n<pre><code>namespace N {\n   template&lt;typename T&gt; struct A {\n      friend void f(A *a) { } // would take this with V2\n   };\n}\nvoid f(void*) { } // would take this with V1\n\nnamespace N {\n/* V1: */ template&lt;&gt; struct A&lt;int&gt;;\n}\n\nint main() {\n   N::A&lt;int&gt; *p;\n   f(p);\n}\n\nnamespace N {\n/* V2: */ template&lt;&gt; struct A&lt;int&gt;;\n}\n</code></pre>\n", "LastActivityDate": "2013-06-20T04:59:49.003"}});