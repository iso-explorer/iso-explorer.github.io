post_cb({"bq_ids": {"n4140": {"so_7369314_7370311_1": {"length": 13, "quality": 1.0, "section_id": 216}, "so_7369314_7370311_0": {"length": 12, "quality": 1.0, "section_id": 214}, "so_7369314_7370311_2": {"length": 36, "quality": 1.0, "section_id": 224}}, "n3337": {"so_7369314_7370311_1": {"length": 13, "quality": 1.0, "section_id": 210}, "so_7369314_7370311_0": {"length": 12, "quality": 1.0, "section_id": 208}, "so_7369314_7370311_2": {"length": 36, "quality": 1.0, "section_id": 217}}, "n4659": {"so_7369314_7370311_1": {"length": 13, "quality": 1.0, "section_id": 224}, "so_7369314_7370311_0": {"length": 12, "quality": 1.0, "section_id": 222}, "so_7369314_7370311_2": {"length": 36, "quality": 1.0, "section_id": 232}}}, "7369314": {"ViewCount": "506", "Body": "<p>Consider this example I found on IBM's website:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid f(double) { cout &lt;&lt; \"Function f(double)\" &lt;&lt; endl; }\n\ntemplate&lt;class T&gt; void g(T a) {\n  f(123);\n  h(a);\n}\n\nvoid f(int) { cout &lt;&lt; \"Function f(int)\" &lt;&lt; endl; }\nvoid h(double) { cout &lt;&lt; \"Function h(double)\" &lt;&lt; endl; }\n\nvoid i() {\n  extern void h(int);\n  g&lt;int&gt;(234);\n}\n\nvoid h(int) { cout &lt;&lt; \"Function h(int)\" &lt;&lt; endl; }\n\nint main(void) {\n    i();\n}\n</code></pre>\n<p>What will it print?</p>\n<ul>\n<li><p>The IBM documentation I adapted this example from, available <a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v101v121/advanced/print.jsp?printType=singleTopicPrint&amp;linkId=t1_2_16_6\" rel=\"noreferrer\">here</a>, says it will print:</p>\n<pre><code>Function f(double)\nFunction h(double)\n</code></pre>\n<p>The rationale for this is that template-parameter-dependent name lookup is performed right before the instantiation of <code>i()</code>, so it finds <code>h(double)</code> but not <code>h(int)</code>. </p></li>\n<li><p>When I compile it using GCC 4.4.1, it prints:</p>\n<pre><code>Function f(double)\nFunction h(int)\n</code></pre>\n<p>GCC seems to be looking up the template-parameter-dependent names in the template after everything else has been compiled, so it finds both <code>h(double)</code> and <code>h(int)</code>, and prefers the latter.</p></li>\n<li><p>When I compile it using Clang 2.8, it fails to compile. The compiler error is:</p>\n<pre><code>ibm_example.cc:8:3: error: use of undeclared identifier 'h'\n  h(a);\n  ^\nibm_example.cc:16:3: note: in instantiation of function template specialization 'g&lt;int&gt;' requested here\n  g&lt;int&gt;(234);\n  ^\n1 error generated.\n</code></pre>\n<p>Clang seems to be looking up the template-parameter-dependent names in the template at the point where the template is declared, so it finds neither <code>h(double)</code> nor <code>h(int)</code>.</p></li>\n</ul>\n<p>Which one is right?</p>\n", "AcceptedAnswerId": "7370311", "Title": "GCC, Clang, and IBM disagree on how to perform template-parameter-dependent name lookup. Which one is right?", "CreationDate": "2011-09-10T02:52:31.207", "Id": "7369314", "CommentCount": "4", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2014-11-27T22:20:07.227", "LastEditorUserId": "1505939", "LastActivityDate": "2014-11-27T22:20:07.227", "Score": "22", "OwnerUserId": "547150", "Tags": "<c++><templates><argument-dependent-lookup>", "AnswerCount": "1"}, "7370311": {"Id": "7370311", "PostTypeId": "2", "Body": "<p>They are all correct. No really, read on...</p>\n<pre><code>template&lt;class T&gt; void g(T a) {\n  f(123);\n  h(a);\n}\n</code></pre>\n<p>Here, <code>f</code> is a non-dependent name but <code>h</code> is a dependent name according to 14.6.2/1. <code>f</code> is looked up </p>\n<blockquote>\n<p id=\"so_7369314_7370311_0\">Non-dependent names used in a template definition are found using the usual name lookup and bound at\n  the point they are used.</p>\n</blockquote>\n<p><code>f</code> is looked up immediately and bound to <code>void f(double)</code>, the only <code>f</code> visible at that point.</p>\n<p>According to 14.6.4.1 the point of instantiation of <code>void g&lt;int&gt;(int)</code> is immediately after the definition of <code>void i()</code>, where it is used.</p>\n<blockquote>\n<p id=\"so_7369314_7370311_1\">[..]Otherwise, the point of instantiation for such a specialization\n  immediately follows the namespace scope declaration or definition that refers to the specialization.</p>\n</blockquote>\n<p>This means that sources for resolving the dependent name are declarations visible at the definition of <code>template&lt;class T&gt; void g(T a)</code> and \"declarations from namespaces associated with the types of the function arguments both from the instantiation context (14.6.4.1) and from the definition context\" (14.6.4).</p>\n<p>However, because <code>int</code> is a fundemantal type, the set of associated namespaces is empty (3.4.2) (no, not even the global namespace is included) and according to 14.6.4.2 it is only lookup using the associated namespaces that can use the template instantiation context, normal unqualified name lookup can only use what is visible at the template definition context. This confirms what was said in 14.6.4.</p>\n<p>Now, the bonus point. 14.6.4.2 goes on to say:</p>\n<blockquote>\n<p id=\"so_7369314_7370311_2\">If the call would be ill-formed or would find a better match had the lookup within the associated namespaces considered all the function declarations with external linkage introduced in those namespaces in all translation units, not just considering those declarations found in the template definition and template instantiation contexts, then the program has undefined behavior.</p>\n</blockquote>\n<p>The call <em>is</em> ill formed because lookup fails (the part about associated namespaces doesn't apply here), so the behavior is explicitly <em>undefined</em> so anything could happen. Hence none of the behaviours seen shows a non-conformance with the standard although, to me, Clang's diagnostic seem most in keeping with the standard.</p>\n<p>(All references ISO/IEC 14882:2011.)</p>\n", "LastActivityDate": "2011-09-10T07:36:56.297", "Score": "13", "CreationDate": "2011-09-10T07:36:56.297", "ParentId": "7369314", "CommentCount": "8", "OwnerUserId": "19563"}});