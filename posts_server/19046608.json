post_cb({"19046608": {"CommentCount": "2", "ViewCount": "1175", "CreationDate": "2013-09-27T08:51:54.027", "LastActivityDate": "2014-01-28T16:49:10.423", "Title": "Are locals destroyed before or after evaluation of a function return value?", "AcceptedAnswerId": "19046754", "PostTypeId": "1", "Id": "19046608", "Score": "7", "Body": "<p>I am thinking of making a class which represents <em>ownership</em> of a synchronization primitive, something like this:</p>\n<pre><code>class CCriticalSectionLock\n{\npublic:\n    CCriticalSectionLock( CCriticalSection &amp;cs ) : cs( cs )\n    { cs.Enter(); }\n    ~CCriticalSectionLock()\n    { cs.Leave(); }\nprivate:\n    CCriticalSection &amp;cs;\n};\n</code></pre>\n<p>This looks like a good way to be able to take ownership during a function and ensure  ownership is released even if there are multiple exit points or exceptions.  It does, however, raise some subtle issues about exactly when the compiler will have various things evaluated.  Consider the following use:</p>\n<pre><code>int MyMethod( void )\n{\n    not_locked(); // do something not under lock\n\n    CCriticalSectionLock myLock( someCriticalSection );\n\n    locked(); // do something under lock\n\n    return ...; // some expression\n}\n</code></pre>\n<p>AFAIK, C++ lifetime rules would guarantee that <code>not_locked()</code> would be called <em>before</em> the lock is taken, and that <code>locked()</code> would be called while the lock is held.</p>\n<p>However, what I am not so clear on is exactly when the expression being returned would be evaluated <em>with respect to the point at which the lock destructor is called</em>.  Is it guaranteed that the expression will be evaluated <em>before</em> the destructor?  I would think so but I'm not 100% sure, and if not it could lead to very subtle, intermittent, hard-to-find bugs!</p>\n", "Tags": "<c++><return><destructor><object-lifetime>", "OwnerUserId": "2019892", "AnswerCount": "1"}, "19046754": {"ParentId": "19046608", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>If they weren't, that would be very problematic.</p>\n<p>Indeed, consider the following code :</p>\n<pre><code>int function(){\n\n    MyClass myObject;\n    //stuff\n    return 5 + myObject.getNumericalValue();\n}\n</code></pre>\n<p>with <code>getNumericalValue()</code> a simple member function that returns an int based on computations on member variable. If the expression was evaluated after the destruction of <code>myObject</code>, you would have undefined behavior, and using locals would be impossible in return statement (which isn't the case).</p>\n<p>In your case, the lock will be destroyed <em>after</em> the evaluation of the return statement.</p>\n<p>To add some strictness to that, let me quote the standard (\u00a73.7.3/3, emphasis mine) :</p>\n<blockquote>\n<p id=\"so_19046608_19046754_0\">If a variable with automatic storage duration has initialization or a destructor with side effects, <strong>it shall not\n  be destroyed before the end of its block</strong>, nor shall it be eliminated as an optimization even if it appears to\n  be unused</p>\n</blockquote>\n<p>The end of the block, for a function, is <em>after</em> the return statement.</p>\n", "OwnerUserId": "1594913", "LastEditorUserId": "1594913", "LastEditDate": "2014-01-28T16:49:10.423", "Id": "19046754", "Score": "5", "CreationDate": "2013-09-27T08:59:30.857", "LastActivityDate": "2014-01-28T16:49:10.423"}, "bq_ids": {"n4140": {"so_19046608_19046754_0": {"section_id": 7172, "quality": 1.0, "length": 19}}, "n3337": {"so_19046608_19046754_0": {"section_id": 6916, "quality": 1.0, "length": 19}}, "n4659": {"so_19046608_19046754_0": {"section_id": 8680, "quality": 0.8947368421052632, "length": 17}}}});